# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 1d 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd e9 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd e9 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd e9 0a				call clear_display  
0023			  
0023			  
0023 cd 95 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd de 66			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd c0 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd 0c 0b			call update_display  
0032 cd 66 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd ee 0a			call fill_display  
003a cd 0c 0b			call update_display  
003d cd 66 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd ee 0a			call fill_display  
0045 cd 0c 0b			call update_display  
0048 cd 66 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd ee 0a			call fill_display  
0050 cd 0c 0b			call update_display  
0053 cd 66 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd fc 0a			call str_at_display  
005e cd 0c 0b			call update_display  
0061			  
0061			  
0061 cd 66 0a			call delay1s  
0064 cd 66 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd fc 0a			call str_at_display  
006f cd 0c 0b			call update_display  
0072 cd 66 0a			call delay1s  
0075 cd 66 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 cf f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a cf f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 cf f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a cf f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 cf f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a d1 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a ce f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 ce f9			ld (spi_device), a 
01e0 32 d1 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a cf f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 cf f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a cf f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 cf f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a cf f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 cf f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a cf f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 cf f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 4b 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a cf f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 cf f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a cf f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 cf f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a cf f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 cf f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a cf f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 cf f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 4b 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a cf f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 cf f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a cf f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 cf f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 a5 ef			ld hl,scratch+2 
02bb cd d4 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 c6 f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 aa ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a c6 f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a c6 f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 c6 f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 c6 f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 cb ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a cb ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a c6 f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 c6 f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 cb ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 c6 f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd 47 17			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd 47 17			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 2e 06			call storage_findnextid 
035d			 
035d cd 46 0d			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd 47 17			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd 47 17			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd 47 17			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd 47 17			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd 47 17			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 cd 29 0a			call storage_clear_page 
042b			 
042b 21 e8 f9			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 e9 f9		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 d3 04			ld hl, .defaultbanklabl 
043a 11 eb f9		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; Append the current bank id 
0442 21 f4 f9			ld hl, store_page+3+9 
0445 3a cd f9			ld a, (spi_device_id) 
0448 77				ld (hl), a 
0449			 
0449				; save default page 0 
0449			 
0449 21 00 00			ld hl, 0 
044c 11 e8 f9			ld de, store_page 
044f				if DEBUG_STORESE 
044f					DMARK "SB3" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 bd fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 be fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 bf fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SB3"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			;		push af 
0468			;		ld a, 'F' 
0468			;		ld (debug_mark),a 
0468			;		pop af 
0468					CALLMONITOR 
0468 cd 47 17			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b cd 6e 03			call storage_write_block 
046e				if DEBUG_STORESE 
046e					DMARK "SB4" 
046e f5				push af  
046f 3a 83 04			ld a, (.dmark)  
0472 32 bd fb			ld (debug_mark),a  
0475 3a 84 04			ld a, (.dmark+1)  
0478 32 be fb			ld (debug_mark+1),a  
047b 3a 85 04			ld a, (.dmark+2)  
047e 32 bf fb			ld (debug_mark+2),a  
0481 18 03			jr .pastdmark  
0483 ..			.dmark: db "SB4"  
0486 f1			.pastdmark: pop af  
0487			endm  
# End of macro DMARK
0487			;		push af 
0487			;		ld a, '>' 
0487			;		ld (debug_mark),a 
0487			;		pop af 
0487					CALLMONITOR 
0487 cd 47 17			call break_point_state  
048a				endm  
# End of macro CALLMONITOR
048a				endif 
048a			 
048a 00				nop 
048b 00				nop 
048c 00				nop 
048d			 
048d				; now set 0 in every page to mark as a free block 
048d			 
048d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048f 21 40 00			ld hl, STORE_BLOCK_PHY 
0492			 
0492 3e 00		.setmark1:   	ld a,0 
0494 e5					push hl 
0495 c5					push bc 
0496 cd e7 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 4b 0a			call aDelayInMS 
049e 23				inc hl 
049f cd e7 01				call se_writebyte 
04a2 3e 0a			ld a, 10 
04a4 cd 4b 0a			call aDelayInMS 
04a7 2b				dec hl 
04a8 c1					pop bc 
04a9 e1					pop hl 
04aa 3e 40				ld a, STORE_BLOCK_PHY 
04ac cd 1d 0d				call addatohl 
04af 10 e1				djnz .setmark1 
04b1			 
04b1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b3 3e 00		.setmark2:   	ld a,0 
04b5 e5					push hl 
04b6 c5					push bc 
04b7 cd e7 01				call se_writebyte 
04ba 3e 0a			ld a, 10 
04bc cd 4b 0a			call aDelayInMS 
04bf 23				inc hl 
04c0 cd e7 01				call se_writebyte 
04c3 3e 0a			ld a, 10 
04c5 cd 4b 0a			call aDelayInMS 
04c8 2b				dec hl 
04c9 c1					pop bc 
04ca e1					pop hl 
04cb 3e 40				ld a, STORE_BLOCK_PHY 
04cd cd 1d 0d				call addatohl 
04d0 10 e1				djnz .setmark2 
04d2			 
04d2					 
04d2			 
04d2			 
04d2 c9				ret 
04d3			 
04d3			 
04d3			 
04d3			 
04d3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04de			 
04de			 
04de			 
04de			; Label Bank 
04de			; ---------- 
04de			; 
04de			; With current bank 
04de			; Read block 0 
04de			; Set label 
04de			; Write block 0 
04de			 
04de			; label str pointer in hl 
04de			 
04de			storage_label:     
04de			 
04de				if DEBUG_STORESE 
04de					DMARK "LBL" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 bd fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 be fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 bf fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LBL"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd 47 17			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa			 
04fa e5				push hl 
04fb			 
04fb cd ba 03			call storage_get_block_0 
04fe			 
04fe				; set default label 
04fe			 
04fe e1				pop hl 
04ff			 
04ff 11 eb f9		 	ld de, store_page+3 
0502 01 0f 00			ld bc, 15 
0505				if DEBUG_STORESE 
0505					DMARK "LB3" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 bd fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 be fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 bf fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LB3"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd 47 17			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 ed b0			ldir 
0523				; save default page 0 
0523			 
0523 21 00 00			ld hl, 0 
0526 11 e8 f9			ld de, store_page 
0529				if DEBUG_STORESE 
0529					DMARK "LBW" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 bd fb			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 be fb			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 bf fb			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "LBW"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					CALLMONITOR 
0542 cd 47 17			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545				endif 
0545 cd 6e 03			call storage_write_block 
0548			 
0548 c9				ret 
0549			 
0549			 
0549			 
0549			; Read Block 0 - Config 
0549			; --------------------- 
0549			; 
0549			; With current bank 
0549			; Call presence test 
0549			;    If not present format/init bank  
0549			; Read block 0  
0549			;  
0549			 
0549			 
0549			; Dir 
0549			; --- 
0549			; 
0549			; With current bank 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block read byte 2 
0549			;      if first block of file 
0549			;         Display file name 
0549			;         Display type flags for file 
0549			;        
0549			 
0549			; moving to words as this requires stack control 
0549			 
0549			 
0549			; Delete File 
0549			; ----------- 
0549			; 
0549			; With current bank 
0549			; 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block file id 
0549			;      If first block of file and dont have file id 
0549			;         if file to delete 
0549			;         Save file id 
0549			;         Null file id 
0549			;         Write this block back 
0549			;      If file id is one saved 
0549			;         Null file id 
0549			;         Write this block back 
0549			 
0549			storage_erase: 
0549			 
0549				; hl contains the file id 
0549			 
0549 5d				ld e, l 
054a 16 00			ld d, 0 
054c 21 40 00			ld hl, STORE_BLOCK_PHY 
054f					if DEBUG_FORTH_WORDS 
054f						DMARK "ERA" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 bd fb			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 be fb			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 bf fb			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "ERA"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568						CALLMONITOR 
0568 cd 47 17			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b cd 2e 06			call storage_findnextid 
056e cd 46 0d			call ishlzero 
0571 c8				ret z 
0572			 
0572 e5				push hl 
0573			 
0573				; TODO check file not found 
0573			 
0573 11 e8 f9			ld de, store_page 
0576 cd 09 03			call storage_read_block 
0579			 
0579					if DEBUG_FORTH_WORDS 
0579						DMARK "ER1" 
0579 f5				push af  
057a 3a 8e 05			ld a, (.dmark)  
057d 32 bd fb			ld (debug_mark),a  
0580 3a 8f 05			ld a, (.dmark+1)  
0583 32 be fb			ld (debug_mark+1),a  
0586 3a 90 05			ld a, (.dmark+2)  
0589 32 bf fb			ld (debug_mark+2),a  
058c 18 03			jr .pastdmark  
058e ..			.dmark: db "ER1"  
0591 f1			.pastdmark: pop af  
0592			endm  
# End of macro DMARK
0592						CALLMONITOR 
0592 cd 47 17			call break_point_state  
0595				endm  
# End of macro CALLMONITOR
0595					endif 
0595 3a e8 f9			ld a, (store_page)	; get file id 
0598 32 e1 f9			ld (store_tmpid), a 
059b			 
059b 3a ea f9			ld a, (store_page+2)    ; get count of extends 
059e 32 e0 f9			ld (store_tmpext), a 
05a1			 
05a1				; wipe file header 
05a1			 
05a1 e1				pop hl 
05a2 3e 00			ld a, 0 
05a4 32 e8 f9			ld (store_page), a 
05a7 32 e9 f9			ld (store_page+1),a 
05aa 11 e8 f9			ld de, store_page 
05ad					if DEBUG_FORTH_WORDS 
05ad						DMARK "ER2" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 bd fb			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 be fb			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 bf fb			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "ER2"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 47 17			call break_point_state  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9 cd 6e 03			call storage_write_block 
05cc			 
05cc			 
05cc				; wipe file extents 
05cc			 
05cc 3a e0 f9			ld a, (store_tmpext) 
05cf 47				ld b, a 
05d0			 
05d0			.eraext:	  
05d0 c5				push bc 
05d1			 
05d1 21 40 00			ld hl, STORE_BLOCK_PHY 
05d4 3a e1 f9			ld a,(store_tmpid) 
05d7 5f				ld e, a 
05d8 50				ld d, b	 
05d9					if DEBUG_FORTH_WORDS 
05d9						DMARK "ER3" 
05d9 f5				push af  
05da 3a ee 05			ld a, (.dmark)  
05dd 32 bd fb			ld (debug_mark),a  
05e0 3a ef 05			ld a, (.dmark+1)  
05e3 32 be fb			ld (debug_mark+1),a  
05e6 3a f0 05			ld a, (.dmark+2)  
05e9 32 bf fb			ld (debug_mark+2),a  
05ec 18 03			jr .pastdmark  
05ee ..			.dmark: db "ER3"  
05f1 f1			.pastdmark: pop af  
05f2			endm  
# End of macro DMARK
05f2						CALLMONITOR 
05f2 cd 47 17			call break_point_state  
05f5				endm  
# End of macro CALLMONITOR
05f5					endif 
05f5 cd 2e 06			call storage_findnextid 
05f8			 
05f8 e5				push hl 
05f9 11 e8 f9			ld de, store_page 
05fc cd 09 03			call storage_read_block 
05ff			 
05ff				; free block	 
05ff			 
05ff 3e 00			ld a, 0 
0601 32 e8 f9			ld (store_page), a 
0604 32 e9 f9			ld (store_page+1),a 
0607 11 e8 f9			ld de, store_page 
060a e1				pop hl 
060b					if DEBUG_FORTH_WORDS 
060b						DMARK "ER4" 
060b f5				push af  
060c 3a 20 06			ld a, (.dmark)  
060f 32 bd fb			ld (debug_mark),a  
0612 3a 21 06			ld a, (.dmark+1)  
0615 32 be fb			ld (debug_mark+1),a  
0618 3a 22 06			ld a, (.dmark+2)  
061b 32 bf fb			ld (debug_mark+2),a  
061e 18 03			jr .pastdmark  
0620 ..			.dmark: db "ER4"  
0623 f1			.pastdmark: pop af  
0624			endm  
# End of macro DMARK
0624						CALLMONITOR 
0624 cd 47 17			call break_point_state  
0627				endm  
# End of macro CALLMONITOR
0627					endif 
0627 cd 6e 03			call storage_write_block 
062a			 
062a c1				pop bc 
062b 10 a3			djnz .eraext 
062d			 
062d c9				ret 
062e			 
062e			 
062e			; Find Free Block 
062e			; --------------- 
062e			; 
062e			; With current bank 
062e			;  
062e			; From given starting logical block 
062e			;    Read block  
062e			;    If no file id 
062e			;         Return block id 
062e			 
062e			 
062e			; hl starting page number 
062e			; hl contains free page number or zero if no pages free 
062e			; e contains the file id to locate 
062e			; d contains the block number 
062e			 
062e			; TODO change to find file id and use zero for free block 
062e			 
062e			storage_findnextid: 
062e			 
062e				; now locate first 0 page to mark as a free block 
062e			 
062e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0630			;	ld hl, STORE_BLOCK_PHY 
0630			 
0630					if DEBUG_FORTH_WORDS 
0630					DMARK "FNI" 
0630 f5				push af  
0631 3a 45 06			ld a, (.dmark)  
0634 32 bd fb			ld (debug_mark),a  
0637 3a 46 06			ld a, (.dmark+1)  
063a 32 be fb			ld (debug_mark+1),a  
063d 3a 47 06			ld a, (.dmark+2)  
0640 32 bf fb			ld (debug_mark+2),a  
0643 18 03			jr .pastdmark  
0645 ..			.dmark: db "FNI"  
0648 f1			.pastdmark: pop af  
0649			endm  
# End of macro DMARK
0649						CALLMONITOR 
0649 cd 47 17			call break_point_state  
064c				endm  
# End of macro CALLMONITOR
064c					endif 
064c			.ff1:   	 
064c e5					push hl 
064d c5					push bc 
064e d5					push de 
064f cd 89 02				call se_readbyte 
0652 5f					ld e,a 
0653 23					inc hl 
0654 cd 89 02				call se_readbyte 
0657 57					ld d, a 
0658 e1					pop hl 
0659 e5					push hl 
065a cd 3b 0d				call cmp16 
065d 28 49				jr z, .fffound 
065f			 
065f d1					pop de 
0660 c1					pop bc 
0661 e1					pop hl 
0662			 
0662					; is found? 
0662					;cp e 
0662					;ret z 
0662			 
0662 3e 40				ld a, STORE_BLOCK_PHY 
0664 cd 1d 0d				call addatohl 
0667 10 e3				djnz .ff1 
0669			 
0669 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066b			.ff2:   	 
066b			 
066b e5					push hl 
066c c5					push bc 
066d d5					push de 
066e cd 89 02				call se_readbyte 
0671 5f					ld e,a 
0672 23					inc hl 
0673 cd 89 02				call se_readbyte 
0676 57					ld d, a 
0677			 
0677 e1					pop hl 
0678 e5					push hl 
0679 cd 3b 0d				call cmp16 
067c 28 2a				jr z, .fffound 
067e			 
067e d1					pop de 
067f c1					pop bc 
0680 e1					pop hl 
0681					; is found? 
0681					;cp e 
0681					;ret z 
0681			 
0681 3e 40				ld a, STORE_BLOCK_PHY 
0683 cd 1d 0d				call addatohl 
0686 10 e3				djnz .ff2 
0688			 
0688			 
0688					if DEBUG_FORTH_WORDS 
0688					DMARK "FN-" 
0688 f5				push af  
0689 3a 9d 06			ld a, (.dmark)  
068c 32 bd fb			ld (debug_mark),a  
068f 3a 9e 06			ld a, (.dmark+1)  
0692 32 be fb			ld (debug_mark+1),a  
0695 3a 9f 06			ld a, (.dmark+2)  
0698 32 bf fb			ld (debug_mark+2),a  
069b 18 03			jr .pastdmark  
069d ..			.dmark: db "FN-"  
06a0 f1			.pastdmark: pop af  
06a1			endm  
# End of macro DMARK
06a1					;	push af 
06a1					;	ld a, 'n' 
06a1					;	ld (debug_mark),a 
06a1					;	pop af 
06a1						CALLMONITOR 
06a1 cd 47 17			call break_point_state  
06a4				endm  
# End of macro CALLMONITOR
06a4					endif 
06a4				; no free marks! 
06a4 21 00 00				ld hl, 0 
06a7 c9				ret 
06a8			.fffound: 
06a8				 
06a8			 
06a8 d1					pop de 
06a9 c1					pop bc 
06aa e1					pop hl 
06ab					if DEBUG_FORTH_WORDS 
06ab					DMARK "FNF" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 bd fb			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 be fb			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 bf fb			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "FNF"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					;	push af 
06c4					;	ld a, 'n' 
06c4					;	ld (debug_mark),a 
06c4					;	pop af 
06c4						CALLMONITOR 
06c4 cd 47 17			call break_point_state  
06c7				endm  
# End of macro CALLMONITOR
06c7					endif 
06c7 c9				ret 
06c8			 
06c8			 
06c8			 
06c8			; Free Space 
06c8			; ---------- 
06c8			; 
06c8			; With current bank 
06c8			; 
06c8			; Set block count to zero 
06c8			; Starting with first logical block 
06c8			;      Find free block  
06c8			;      If block id given, increment block count 
06c8			; 
06c8			;  
06c8			 
06c8			 
06c8			; hl contains count of free blocks 
06c8			 
06c8			storage_freeblocks: 
06c8			 
06c8				; now locate first 0 page to mark as a free block 
06c8			 
06c8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06ca 21 40 00			ld hl, STORE_BLOCK_PHY 
06cd 11 00 00			ld de, 0 
06d0			 
06d0			.fb1:   	 
06d0 e5					push hl 
06d1 c5					push bc 
06d2 d5					push de 
06d3 cd 89 02				call se_readbyte 
06d6 d1					pop de 
06d7 c1					pop bc 
06d8 e1					pop hl 
06d9			 
06d9					; is free? 
06d9 fe 00				cp 0 
06db 20 01				jr nz, .ff1cont 
06dd 13					inc de 
06de			 
06de			.ff1cont: 
06de			 
06de			 
06de 3e 40				ld a, STORE_BLOCK_PHY 
06e0 cd 1d 0d				call addatohl 
06e3 10 eb				djnz .fb1 
06e5			 
06e5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e7			.fb2:   	 
06e7 e5					push hl 
06e8 c5					push bc 
06e9 d5					push de 
06ea cd 89 02				call se_readbyte 
06ed d1					pop de 
06ee c1					pop bc 
06ef e1					pop hl 
06f0			 
06f0					; is free? 
06f0 fe 00				cp 0 
06f2 20 01				jr nz, .ff2cont 
06f4 13					inc de 
06f5			 
06f5			.ff2cont: 
06f5			 
06f5 3e 40				ld a, STORE_BLOCK_PHY 
06f7 cd 1d 0d				call addatohl 
06fa 10 eb				djnz .fb2 
06fc			 
06fc eb				ex de, hl 
06fd c9				ret 
06fe			 
06fe			; Get File ID 
06fe			; ----------- 
06fe			; 
06fe			; With current bank 
06fe			;  
06fe			; Load Block 0 Config 
06fe			; Get max file id number 
06fe			; For each logical block 
06fe			;    Read block file id 
06fe			;      If first block of file and dont have file id 
06fe			;         if file get id and exit 
06fe			 
06fe			 
06fe			 
06fe			 
06fe			; Create File 
06fe			; ----------- 
06fe			; 
06fe			; With current bank  
06fe			; Load Block 0 Config 
06fe			; Get max file id number 
06fe			; Increment file id number 
06fe			; Save Config 
06fe			; Find free block 
06fe			; Set buffer with file name and file id 
06fe			; Write buffer to free block  
06fe			 
06fe			 
06fe			; hl point to file name 
06fe			; hl returns file id 
06fe			 
06fe			; file format: 
06fe			; byte 0 - file id 
06fe			; byte 1 - extent number 
06fe			; byte 2-> data 
06fe			 
06fe			; format for extent number 0: 
06fe			; 
06fe			; byte 0 - file id 
06fe			; byte 1 - extent 0 
06fe			; byte 2 - extent count 
06fe			; byte 3 -> file name and meta data 
06fe			 
06fe			 
06fe			storage_create: 
06fe				if DEBUG_STORESE 
06fe					DMARK "SCR" 
06fe f5				push af  
06ff 3a 13 07			ld a, (.dmark)  
0702 32 bd fb			ld (debug_mark),a  
0705 3a 14 07			ld a, (.dmark+1)  
0708 32 be fb			ld (debug_mark+1),a  
070b 3a 15 07			ld a, (.dmark+2)  
070e 32 bf fb			ld (debug_mark+2),a  
0711 18 03			jr .pastdmark  
0713 ..			.dmark: db "SCR"  
0716 f1			.pastdmark: pop af  
0717			endm  
# End of macro DMARK
0717					CALLMONITOR 
0717 cd 47 17			call break_point_state  
071a				endm  
# End of macro CALLMONITOR
071a				endif 
071a			 
071a e5				push hl		; save file name pointer 
071b			 
071b cd ba 03			call storage_get_block_0 
071e			 
071e 3a e8 f9			ld a,(store_page)	; get current file id 
0721 3c				inc a 
0722 32 e8 f9			ld (store_page),a 
0725				 
0725 32 e1 f9			ld (store_tmpid),a			; save id 
0728			 
0728 21 00 00			ld hl, 0 
072b 11 e8 f9			ld de, store_page 
072e				if DEBUG_STORESE 
072e					DMARK "SCw" 
072e f5				push af  
072f 3a 43 07			ld a, (.dmark)  
0732 32 bd fb			ld (debug_mark),a  
0735 3a 44 07			ld a, (.dmark+1)  
0738 32 be fb			ld (debug_mark+1),a  
073b 3a 45 07			ld a, (.dmark+2)  
073e 32 bf fb			ld (debug_mark+2),a  
0741 18 03			jr .pastdmark  
0743 ..			.dmark: db "SCw"  
0746 f1			.pastdmark: pop af  
0747			endm  
# End of macro DMARK
0747					CALLMONITOR 
0747 cd 47 17			call break_point_state  
074a				endm  
# End of macro CALLMONITOR
074a				endif 
074a cd 6e 03			call storage_write_block	 ; save update 
074d			 
074d				if DEBUG_STORESE 
074d 11 e8 f9				ld de, store_page 
0750					DMARK "SCC" 
0750 f5				push af  
0751 3a 65 07			ld a, (.dmark)  
0754 32 bd fb			ld (debug_mark),a  
0757 3a 66 07			ld a, (.dmark+1)  
075a 32 be fb			ld (debug_mark+1),a  
075d 3a 67 07			ld a, (.dmark+2)  
0760 32 bf fb			ld (debug_mark+2),a  
0763 18 03			jr .pastdmark  
0765 ..			.dmark: db "SCC"  
0768 f1			.pastdmark: pop af  
0769			endm  
# End of macro DMARK
0769					CALLMONITOR 
0769 cd 47 17			call break_point_state  
076c				endm  
# End of macro CALLMONITOR
076c				endif 
076c				;  
076c				 
076c 21 40 00			ld hl, STORE_BLOCK_PHY 
076f 11 00 00			ld de, 0 
0772 cd 2e 06			call storage_findnextid 
0775			 
0775 22 d2 f9			ld (store_tmppageid), hl    ; save page to use  
0778			 
0778				; TODO detect 0 = no spare blocks 
0778			 
0778				; hl now contains the free page to use for the file header page 
0778			 
0778				if DEBUG_STORESE 
0778				DMARK "SCF" 
0778 f5				push af  
0779 3a 8d 07			ld a, (.dmark)  
077c 32 bd fb			ld (debug_mark),a  
077f 3a 8e 07			ld a, (.dmark+1)  
0782 32 be fb			ld (debug_mark+1),a  
0785 3a 8f 07			ld a, (.dmark+2)  
0788 32 bf fb			ld (debug_mark+2),a  
078b 18 03			jr .pastdmark  
078d ..			.dmark: db "SCF"  
0790 f1			.pastdmark: pop af  
0791			endm  
# End of macro DMARK
0791					CALLMONITOR 
0791 cd 47 17			call break_point_state  
0794				endm  
# End of macro CALLMONITOR
0794				endif 
0794			 
0794 22 d2 f9			ld (store_tmppageid), hl 
0797				 
0797 3a e1 f9			ld a,(store_tmpid)    ; get file id 
079a			;	ld a, (store_filecache)			; save to cache 
079a			 
079a 32 e8 f9			ld (store_page),a    ; set page id 
079d 3e 00			ld a, 0			 ; extent 0 is file header 
079f 32 e9 f9			ld (store_page+1), a   ; set file extent 
07a2			 
07a2 32 ea f9			ld (store_page+2), a   ; extent count for the file 
07a5			 
07a5			;	inc hl 		; init block 0 of file 
07a5			;	inc hl   		; skip file and extent id 
07a5			 ;       ld a, 0 
07a5			;	ld (hl),a 
07a5			;	ld a, (store_filecache+1)  	; save to cache 
07a5			 
07a5			;	inc hl    ; file name 
07a5				 
07a5				 
07a5 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a8				if DEBUG_STORESE 
07a8					DMARK "SCc" 
07a8 f5				push af  
07a9 3a bd 07			ld a, (.dmark)  
07ac 32 bd fb			ld (debug_mark),a  
07af 3a be 07			ld a, (.dmark+1)  
07b2 32 be fb			ld (debug_mark+1),a  
07b5 3a bf 07			ld a, (.dmark+2)  
07b8 32 bf fb			ld (debug_mark+2),a  
07bb 18 03			jr .pastdmark  
07bd ..			.dmark: db "SCc"  
07c0 f1			.pastdmark: pop af  
07c1			endm  
# End of macro DMARK
07c1					CALLMONITOR 
07c1 cd 47 17			call break_point_state  
07c4				endm  
# End of macro CALLMONITOR
07c4				endif 
07c4 e1				pop hl    ; get zero term string 
07c5 e5				push hl 
07c6 3e 00			ld a, 0 
07c8 cd 86 11			call strlent 
07cb 23				inc hl   ; cover zero term 
07cc 06 00			ld b,0 
07ce 4d				ld c,l 
07cf e1				pop hl 
07d0				;ex de, hl 
07d0				if DEBUG_STORESE 
07d0					DMARK "SCa" 
07d0 f5				push af  
07d1 3a e5 07			ld a, (.dmark)  
07d4 32 bd fb			ld (debug_mark),a  
07d7 3a e6 07			ld a, (.dmark+1)  
07da 32 be fb			ld (debug_mark+1),a  
07dd 3a e7 07			ld a, (.dmark+2)  
07e0 32 bf fb			ld (debug_mark+2),a  
07e3 18 03			jr .pastdmark  
07e5 ..			.dmark: db "SCa"  
07e8 f1			.pastdmark: pop af  
07e9			endm  
# End of macro DMARK
07e9					;push af 
07e9					;ld a, 'a' 
07e9					;ld (debug_mark),a 
07e9					;pop af 
07e9					CALLMONITOR 
07e9 cd 47 17			call break_point_state  
07ec				endm  
# End of macro CALLMONITOR
07ec				endif 
07ec ed b0			ldir    ; copy zero term string 
07ee				if DEBUG_STORESE 
07ee					DMARK "SCA" 
07ee f5				push af  
07ef 3a 03 08			ld a, (.dmark)  
07f2 32 bd fb			ld (debug_mark),a  
07f5 3a 04 08			ld a, (.dmark+1)  
07f8 32 be fb			ld (debug_mark+1),a  
07fb 3a 05 08			ld a, (.dmark+2)  
07fe 32 bf fb			ld (debug_mark+2),a  
0801 18 03			jr .pastdmark  
0803 ..			.dmark: db "SCA"  
0806 f1			.pastdmark: pop af  
0807			endm  
# End of macro DMARK
0807					CALLMONITOR 
0807 cd 47 17			call break_point_state  
080a				endm  
# End of macro CALLMONITOR
080a				endif 
080a			 
080a				; write file header page 
080a			 
080a 2a d2 f9			ld hl,(store_tmppageid) 
080d 11 e8 f9			ld de, store_page 
0810				if DEBUG_STORESE 
0810					DMARK "SCb" 
0810 f5				push af  
0811 3a 25 08			ld a, (.dmark)  
0814 32 bd fb			ld (debug_mark),a  
0817 3a 26 08			ld a, (.dmark+1)  
081a 32 be fb			ld (debug_mark+1),a  
081d 3a 27 08			ld a, (.dmark+2)  
0820 32 bf fb			ld (debug_mark+2),a  
0823 18 03			jr .pastdmark  
0825 ..			.dmark: db "SCb"  
0828 f1			.pastdmark: pop af  
0829			endm  
# End of macro DMARK
0829					;push af 
0829					;ld a, 'b' 
0829					;ld (debug_mark),a 
0829					;pop af 
0829					CALLMONITOR 
0829 cd 47 17			call break_point_state  
082c				endm  
# End of macro CALLMONITOR
082c				endif 
082c cd 6e 03			call storage_write_block 
082f			 
082f 3a e1 f9			ld a, (store_tmpid) 
0832 6f				ld l, a 
0833 26 00			ld h,0 
0835				if DEBUG_STORESE 
0835					DMARK "SCz" 
0835 f5				push af  
0836 3a 4a 08			ld a, (.dmark)  
0839 32 bd fb			ld (debug_mark),a  
083c 3a 4b 08			ld a, (.dmark+1)  
083f 32 be fb			ld (debug_mark+1),a  
0842 3a 4c 08			ld a, (.dmark+2)  
0845 32 bf fb			ld (debug_mark+2),a  
0848 18 03			jr .pastdmark  
084a ..			.dmark: db "SCz"  
084d f1			.pastdmark: pop af  
084e			endm  
# End of macro DMARK
084e					CALLMONITOR 
084e cd 47 17			call break_point_state  
0851				endm  
# End of macro CALLMONITOR
0851				endif 
0851 c9				ret 
0852				 
0852			 
0852			 
0852			; 
0852			; Read File 
0852			; 
0852			; h - file id to locate 
0852			; l - extent to locate 
0852			; de - pointer to string to read into 
0852			; 
0852			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0852			 
0852			.sr_fail: 
0852 d1				pop de 
0853 c9				ret 
0854			 
0854			storage_read: 
0854 d5				push de 
0855			 
0855			; TODO BUG the above push is it popped before the RET Z? 
0855			 
0855			; TODO how to handle multiple part blocks 
0855			 
0855				; locate file extent to read 
0855			 
0855 5c				ld e, h 
0856 55				ld d, l 
0857 21 40 00			ld hl, STORE_BLOCK_PHY 
085a				if DEBUG_STORESE 
085a					DMARK "SRE" 
085a f5				push af  
085b 3a 6f 08			ld a, (.dmark)  
085e 32 bd fb			ld (debug_mark),a  
0861 3a 70 08			ld a, (.dmark+1)  
0864 32 be fb			ld (debug_mark+1),a  
0867 3a 71 08			ld a, (.dmark+2)  
086a 32 bf fb			ld (debug_mark+2),a  
086d 18 03			jr .pastdmark  
086f ..			.dmark: db "SRE"  
0872 f1			.pastdmark: pop af  
0873			endm  
# End of macro DMARK
0873					CALLMONITOR 
0873 cd 47 17			call break_point_state  
0876				endm  
# End of macro CALLMONITOR
0876				endif 
0876 cd 2e 06			call storage_findnextid 
0879			 
0879				if DEBUG_STORESE 
0879					DMARK "SRf" 
0879 f5				push af  
087a 3a 8e 08			ld a, (.dmark)  
087d 32 bd fb			ld (debug_mark),a  
0880 3a 8f 08			ld a, (.dmark+1)  
0883 32 be fb			ld (debug_mark+1),a  
0886 3a 90 08			ld a, (.dmark+2)  
0889 32 bf fb			ld (debug_mark+2),a  
088c 18 03			jr .pastdmark  
088e ..			.dmark: db "SRf"  
0891 f1			.pastdmark: pop af  
0892			endm  
# End of macro DMARK
0892					CALLMONITOR 
0892 cd 47 17			call break_point_state  
0895				endm  
# End of macro CALLMONITOR
0895				endif 
0895 cd 46 0d			call ishlzero 
0898			;	ld a, l 
0898			;	add h 
0898			;	cp 0 
0898 28 b8			jr z,.sr_fail			; block not found so EOF 
089a			 
089a				; hl contains page number to load 
089a d1				pop de   ; get storage 
089b d5				push de 
089c				if DEBUG_STORESE 
089c					DMARK "SRg" 
089c f5				push af  
089d 3a b1 08			ld a, (.dmark)  
08a0 32 bd fb			ld (debug_mark),a  
08a3 3a b2 08			ld a, (.dmark+1)  
08a6 32 be fb			ld (debug_mark+1),a  
08a9 3a b3 08			ld a, (.dmark+2)  
08ac 32 bf fb			ld (debug_mark+2),a  
08af 18 03			jr .pastdmark  
08b1 ..			.dmark: db "SRg"  
08b4 f1			.pastdmark: pop af  
08b5			endm  
# End of macro DMARK
08b5					CALLMONITOR 
08b5 cd 47 17			call break_point_state  
08b8				endm  
# End of macro CALLMONITOR
08b8				endif 
08b8 cd 09 03			call storage_read_block 
08bb			 
08bb			 
08bb			; TODO if block has no zeros then need to read next block  
08bb			 
08bb			 
08bb					 
08bb e1				pop hl 		 ; return start of data to show as not EOF 
08bc 23				inc hl   ; past file id 
08bd 23				inc hl   ; past ext 
08be				if DEBUG_STORESE 
08be					DMARK "SRe" 
08be f5				push af  
08bf 3a d3 08			ld a, (.dmark)  
08c2 32 bd fb			ld (debug_mark),a  
08c5 3a d4 08			ld a, (.dmark+1)  
08c8 32 be fb			ld (debug_mark+1),a  
08cb 3a d5 08			ld a, (.dmark+2)  
08ce 32 bf fb			ld (debug_mark+2),a  
08d1 18 03			jr .pastdmark  
08d3 ..			.dmark: db "SRe"  
08d6 f1			.pastdmark: pop af  
08d7			endm  
# End of macro DMARK
08d7					CALLMONITOR 
08d7 cd 47 17			call break_point_state  
08da				endm  
# End of macro CALLMONITOR
08da				endif 
08da c9					ret 
08db			 
08db			 
08db			 
08db			; 
08db			; Append File 
08db			; 
08db			; hl - file id to locate 
08db			; de - pointer to (multi block) string to write 
08db			 
08db			.sa_notfound: 
08db d1				pop de 
08dc c9				ret 
08dd			 
08dd			 
08dd			storage_append: 
08dd				; hl -  file id to append to 
08dd				; de - string to append 
08dd			 
08dd d5				push de 
08de				 
08de				if DEBUG_STORESE 
08de					DMARK "AP1" 
08de f5				push af  
08df 3a f3 08			ld a, (.dmark)  
08e2 32 bd fb			ld (debug_mark),a  
08e5 3a f4 08			ld a, (.dmark+1)  
08e8 32 be fb			ld (debug_mark+1),a  
08eb 3a f5 08			ld a, (.dmark+2)  
08ee 32 bf fb			ld (debug_mark+2),a  
08f1 18 03			jr .pastdmark  
08f3 ..			.dmark: db "AP1"  
08f6 f1			.pastdmark: pop af  
08f7			endm  
# End of macro DMARK
08f7					CALLMONITOR 
08f7 cd 47 17			call break_point_state  
08fa				endm  
# End of macro CALLMONITOR
08fa				endif 
08fa			 
08fa 7d				ld a, l 
08fb 32 e1 f9			ld (store_tmpid), a 
08fe			 
08fe				; get file header  
08fe			 
08fe 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0900 3a e1 f9			ld a, (store_tmpid) 
0903 5f				ld e, a 
0904			 
0904 21 40 00				ld hl, STORE_BLOCK_PHY 
0907 cd 2e 06				call storage_findnextid 
090a			 
090a cd 46 0d			call ishlzero 
090d 28 cc			jr z, .sa_notfound 
090f			 
090f 22 d2 f9			ld (store_tmppageid), hl 
0912			 
0912				; TODO handle file id not found 
0912			 
0912				if DEBUG_STORESE 
0912					DMARK "AP2" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 bd fb			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 be fb			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 bf fb			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "AP2"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd 47 17			call break_point_state  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e			 
092e				; update file extent count 
092e			 
092e 11 e8 f9			ld de, store_page 
0931			 
0931 cd 09 03			call storage_read_block 
0934			 
0934				if DEBUG_STORESE 
0934					DMARK "AP3" 
0934 f5				push af  
0935 3a 49 09			ld a, (.dmark)  
0938 32 bd fb			ld (debug_mark),a  
093b 3a 4a 09			ld a, (.dmark+1)  
093e 32 be fb			ld (debug_mark+1),a  
0941 3a 4b 09			ld a, (.dmark+2)  
0944 32 bf fb			ld (debug_mark+2),a  
0947 18 03			jr .pastdmark  
0949 ..			.dmark: db "AP3"  
094c f1			.pastdmark: pop af  
094d			endm  
# End of macro DMARK
094d					CALLMONITOR 
094d cd 47 17			call break_point_state  
0950				endm  
# End of macro CALLMONITOR
0950				endif 
0950			;	ld (store_tmppageid), hl 
0950			 
0950 3a ea f9			ld a, (store_page+2) 
0953 3c				inc a 
0954 32 ea f9			ld (store_page+2), a 
0957 32 e0 f9			ld (store_tmpext), a 
095a				 
095a				if DEBUG_STORESE 
095a					DMARK "AP3" 
095a f5				push af  
095b 3a 6f 09			ld a, (.dmark)  
095e 32 bd fb			ld (debug_mark),a  
0961 3a 70 09			ld a, (.dmark+1)  
0964 32 be fb			ld (debug_mark+1),a  
0967 3a 71 09			ld a, (.dmark+2)  
096a 32 bf fb			ld (debug_mark+2),a  
096d 18 03			jr .pastdmark  
096f ..			.dmark: db "AP3"  
0972 f1			.pastdmark: pop af  
0973			endm  
# End of macro DMARK
0973					CALLMONITOR 
0973 cd 47 17			call break_point_state  
0976				endm  
# End of macro CALLMONITOR
0976				endif 
0976 2a d2 f9			ld hl, (store_tmppageid) 
0979 11 e8 f9			ld de, store_page 
097c cd 6e 03			call storage_write_block 
097f			 
097f				; find free block 
097f			 
097f 11 00 00			ld de, 0			 ; file extent to locate 
0982			 
0982 21 40 00				ld hl, STORE_BLOCK_PHY 
0985 cd 2e 06				call storage_findnextid 
0988 cd 46 0d			call ishlzero 
098b ca db 08			jp z, .sa_notfound 
098e			 
098e					; TODO handle no space left 
098e					 
098e 22 d2 f9				ld (store_tmppageid), hl 
0991			 
0991				if DEBUG_STORESE 
0991					DMARK "AP4" 
0991 f5				push af  
0992 3a a6 09			ld a, (.dmark)  
0995 32 bd fb			ld (debug_mark),a  
0998 3a a7 09			ld a, (.dmark+1)  
099b 32 be fb			ld (debug_mark+1),a  
099e 3a a8 09			ld a, (.dmark+2)  
09a1 32 bf fb			ld (debug_mark+2),a  
09a4 18 03			jr .pastdmark  
09a6 ..			.dmark: db "AP4"  
09a9 f1			.pastdmark: pop af  
09aa			endm  
# End of macro DMARK
09aa					CALLMONITOR 
09aa cd 47 17			call break_point_state  
09ad				endm  
# End of macro CALLMONITOR
09ad				endif 
09ad					; init the buffer with zeros so we can id if the buffer is full or not 
09ad			 
09ad e5					push hl 
09ae c5					push bc 
09af			 
09af 21 e8 f9				ld hl, store_page 
09b2 06 40				ld b, STORE_BLOCK_PHY 
09b4 3e 00				ld a, 0 
09b6 77			.zeroblock:	ld (hl), a 
09b7 23					inc hl 
09b8 10 fc				djnz .zeroblock 
09ba			 
09ba c1					pop bc 
09bb e1					pop hl 
09bc			 
09bc					; construct block 
09bc			 
09bc 3a e1 f9				ld a, (store_tmpid) 
09bf 32 e8 f9				ld (store_page), a   ; file id 
09c2 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09c5 32 e9 f9				ld (store_page+1), a 
09c8			 
09c8 e1					pop hl    ; get string to write 
09c9 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09cb 11 ea f9				ld de, store_page+2 
09ce			 
09ce				if DEBUG_STORESE 
09ce					DMARK "AP5" 
09ce f5				push af  
09cf 3a e3 09			ld a, (.dmark)  
09d2 32 bd fb			ld (debug_mark),a  
09d5 3a e4 09			ld a, (.dmark+1)  
09d8 32 be fb			ld (debug_mark+1),a  
09db 3a e5 09			ld a, (.dmark+2)  
09de 32 bf fb			ld (debug_mark+2),a  
09e1 18 03			jr .pastdmark  
09e3 ..			.dmark: db "AP5"  
09e6 f1			.pastdmark: pop af  
09e7			endm  
# End of macro DMARK
09e7					CALLMONITOR 
09e7 cd 47 17			call break_point_state  
09ea				endm  
# End of macro CALLMONITOR
09ea				endif 
09ea			 
09ea			 
09ea			 
09ea					; fill buffer with data until end of string or full block 
09ea			 
09ea 7e			.appd:		ld a, (hl) 
09eb 12					ld (de), a 
09ec fe 00				cp 0 
09ee 28 04				jr z, .appdone 
09f0 23					inc hl 
09f1 13					inc de 
09f2 10 f6				djnz .appd 
09f4			 
09f4 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09f5 f5					push af   		; save last byte dumped 
09f6			 
09f6			 
09f6 2a d2 f9			ld hl, (store_tmppageid) 
09f9 11 e8 f9			ld de, store_page 
09fc				if DEBUG_STORESE 
09fc					DMARK "AP6" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 bd fb			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 be fb			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 bf fb			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "AP6"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd 47 17			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18 cd 6e 03				call storage_write_block 
0a1b			 
0a1b			 
0a1b				; was that a full block of data written? 
0a1b				; any more to write out? 
0a1b			 
0a1b				; if yes then set vars and jump to start of function again 
0a1b			 
0a1b f1					pop af 
0a1c d1					pop de 
0a1d			 
0a1d fe 00				cp 0		 ; no, string was fully written 
0a1f c8					ret z 
0a20			 
0a20					; setup vars for next cycle 
0a20			 
0a20 3a e1 f9				ld a, (store_tmpid) 
0a23 6f					ld l, a 
0a24 26 00				ld h, 0 
0a26			 
0a26 c3 dd 08			 	jp storage_append	 ; yes, need to write out some more 
0a29			 
0a29			 
0a29			 
0a29			 
0a29			 
0a29			 
0a29			 
0a29			if DEBUG_STORECF 
0a29			storageput:	 
0a29					ret 
0a29			storageread: 
0a29					ld hl, store_page 
0a29					ld b, 200 
0a29					ld a,0 
0a29			.src:		ld (hl),a 
0a29					inc hl 
0a29					djnz .src 
0a29					 
0a29			 
0a29					ld de, 0 
0a29					ld bc, 1 
0a29					ld hl, store_page 
0a29					call cfRead 
0a29			 
0a29				call cfGetError 
0a29				ld hl,scratch 
0a29				call hexout 
0a29				ld hl, scratch+2 
0a29				ld a, 0 
0a29				ld (hl),a 
0a29				ld de, scratch 
0a29				ld a,display_row_1 
0a29				call str_at_display 
0a29				call update_display 
0a29			 
0a29					ld hl, store_page 
0a29					ld (os_cur_ptr),hl 
0a29			 
0a29					ret 
0a29			endif 
0a29			 
0a29			 
0a29			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a29			 
0a29			storage_clear_page: 
0a29 e5				push hl 
0a2a d5				push de 
0a2b c5				push bc 
0a2c 21 e8 f9			ld hl, store_page 
0a2f 3e 00			ld a, 0 
0a31 77				ld (hl), a 
0a32			 
0a32 11 e9 f9			ld de, store_page+1 
0a35 01 40 00			ld bc, STORE_BLOCK_PHY 
0a38			 
0a38 ed b0			ldir 
0a3a				 
0a3a c1				pop bc 
0a3b d1				pop de 
0a3c e1				pop hl 
0a3d c9				ret 
0a3e			 
0a3e			; eof 
# End of file firmware_storage.asm
0a3e			  
0a3e			; support routines for above hardware abstraction layer  
0a3e			  
0a3e			include "firmware_general.asm"        ; general support functions  
0a3e			 
0a3e			; word look up 
0a3e			 
0a3e			; in 
0a3e			; a is the index 
0a3e			; hl is pointer start of array 
0a3e			; 
0a3e			; returns 
0a3e			; hl to the word 
0a3e			; 
0a3e			 
0a3e			table_lookup:  
0a3e d5					push de 
0a3f eb					ex de, hl 
0a40			 
0a40 6f					ld l, a 
0a41 26 00				ld h, 0 
0a43 29					add hl, hl 
0a44 19					add hl, de 
0a45 7e					ld a, (hl) 
0a46 23					inc hl 
0a47 66					ld h,(hl) 
0a48 6f					ld l, a 
0a49			 
0a49 d1					pop de 
0a4a c9					ret 
0a4b			 
0a4b			; Delay loops 
0a4b			 
0a4b			 
0a4b			 
0a4b			aDelayInMS: 
0a4b c5				push bc 
0a4c 47				ld b,a 
0a4d			msdelay: 
0a4d c5				push bc 
0a4e				 
0a4e			 
0a4e 01 41 00			ld bc,041h 
0a51 cd 69 0a			call delayloop 
0a54 c1				pop bc 
0a55 05				dec b 
0a56 20 f5			jr nz,msdelay 
0a58			 
0a58			;if CPU_CLOCK_8MHZ 
0a58			;msdelay8: 
0a58			;	push bc 
0a58			;	 
0a58			; 
0a58			;	ld bc,041h 
0a58			;	call delayloop 
0a58			;	pop bc 
0a58			;	dec b 
0a58			;	jr nz,msdelay8 
0a58			;endif 
0a58			 
0a58			 
0a58 c1				pop bc 
0a59 c9				ret 
0a5a			 
0a5a			 
0a5a			delay250ms: 
0a5a				;push de 
0a5a 01 00 40			ld bc, 04000h 
0a5d c3 69 0a			jp delayloop 
0a60			delay500ms: 
0a60				;push de 
0a60 01 00 80			ld bc, 08000h 
0a63 c3 69 0a			jp delayloop 
0a66			delay1s: 
0a66				;push bc 
0a66			   ; Clobbers A, d and e 
0a66 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a69			delayloop: 
0a69 c5			    push bc 
0a6a			 
0a6a			if BASE_CPM 
0a6a				ld bc, CPM_DELAY_TUNE 
0a6a			.cpmloop: 
0a6a				push bc 
0a6a			 
0a6a			endif 
0a6a			 
0a6a			 
0a6a			 
0a6a			delayloopi: 
0a6a			;	push bc 
0a6a			;.dl: 
0a6a cb 47		    bit     0,a    	; 8 
0a6c cb 47		    bit     0,a    	; 8 
0a6e cb 47		    bit     0,a    	; 8 
0a70 e6 ff		    and     255  	; 7 
0a72 0b			    dec     bc      	; 6 
0a73 79			    ld      a,c     	; 4 
0a74 b0			    or      b     	; 4 
0a75 c2 6a 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a78			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a78				;pop de 
0a78			;pop bc 
0a78			 
0a78			if BASE_CPM 
0a78				pop bc 
0a78				 
0a78			    dec     bc      	; 6 
0a78			    ld      a,c     	; 4 
0a78			    or      b     	; 4 
0a78			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a78				 
0a78			 
0a78			endif 
0a78			;if CPU_CLOCK_8MHZ 
0a78			;    pop bc 
0a78			;    push bc 
0a78			;.dl8: 
0a78			;    bit     0,a    	; 8 
0a78			;    bit     0,a    	; 8 
0a78			;    bit     0,a    	; 8 
0a78			;    and     255  	; 7 
0a78			;    dec     bc      	; 6 
0a78			;    ld      a,c     	; 4 
0a78			;    or      b     	; 4 
0a78			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a78			;endif 
0a78			 
0a78			;if CPU_CLOCK_10MHZ 
0a78			;    pop bc 
0a78			;    push bc 
0a78			;.dl8: 
0a78			;    bit     0,a    	; 8 
0a78			;    bit     0,a    	; 8 
0a78			;    bit     0,a    	; 8 
0a78			;    and     255  	; 7 
0a78			;    dec     bc      	; 6 
0a78			;    ld      a,c     	; 4 
0a78			;    or      b     	; 4 
0a78			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a78			;endif 
0a78 c1			    pop bc 
0a79			 
0a79 c9				ret 
0a7a			 
0a7a			 
0a7a			 
0a7a			; eof 
# End of file firmware_general.asm
0a7a			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a7a			; display routines that use the physical hardware abstraction layer 
0a7a			 
0a7a			 
0a7a			; information window 
0a7a			 
0a7a			; pass hl with 1st string to display 
0a7a			; pass de with 2nd string to display 
0a7a			 
0a7a			info_panel: 
0a7a e5				push hl 
0a7b			 
0a7b 2a 5e fa			ld hl, (display_fb_active) 
0a7e e5				push hl    ; future de destination 
0a7f 21 53 fb				ld hl, display_fb0 
0a82 22 5e fa				ld (display_fb_active), hl 
0a85			 
0a85			;	call clear_display 
0a85			 
0a85				if BASE_CPM 
0a85				ld a, '.' 
0a85				else 
0a85 3e a5			ld a, 165 
0a87				endif 
0a87 cd ee 0a			call fill_display 
0a8a			 
0a8a			 
0a8a 3e 2d			ld a, display_row_3 + 5 
0a8c cd fc 0a			call str_at_display 
0a8f			 
0a8f e1				pop hl 
0a90 d1				pop de 
0a91			 
0a91 e5				push hl 
0a92			 
0a92			 
0a92 3e 19			ld a, display_row_2 + 5 
0a94 cd fc 0a			call str_at_display 
0a97			 
0a97			 
0a97 cd 0c 0b			call update_display 
0a9a cd 4f 1c			call next_page_prompt 
0a9d cd e9 0a			call clear_display 
0aa0			 
0aa0				 
0aa0 21 02 fb				ld hl, display_fb1 
0aa3 22 5e fa				ld (display_fb_active), hl 
0aa6 cd 0c 0b			call update_display 
0aa9			 
0aa9 e1				pop hl 
0aaa			 
0aaa c9				ret 
0aab			 
0aab			 
0aab			 
0aab			 
0aab			; TODO windowing? 
0aab			 
0aab			; TODO scroll line up 
0aab			 
0aab			scroll_up: 
0aab			 
0aab e5				push hl 
0aac d5				push de 
0aad c5				push bc 
0aae			 
0aae				; get frame buffer  
0aae			 
0aae 2a 5e fa			ld hl, (display_fb_active) 
0ab1 e5				push hl    ; future de destination 
0ab2			 
0ab2 11 14 00			ld  de, display_cols 
0ab5 19				add hl, de 
0ab6			 
0ab6 d1				pop de 
0ab7			 
0ab7				;ex de, hl 
0ab7 01 4f 00			ld bc, display_fb_len -1  
0aba			;if DEBUG_FORTH_WORDS 
0aba			;	DMARK "SCL" 
0aba			;	CALLMONITOR 
0aba			;endif	 
0aba ed b0			ldir 
0abc			 
0abc				; wipe bottom row 
0abc			 
0abc			 
0abc 2a 5e fa			ld hl, (display_fb_active) 
0abf 11 50 00			ld de, display_cols*display_rows 
0ac2 19				add hl, de 
0ac3 06 14			ld b, display_cols 
0ac5 3e 20			ld a, ' ' 
0ac7			.scwipe: 
0ac7 77				ld (hl), a 
0ac8 2b				dec hl 
0ac9 10 fc			djnz .scwipe 
0acb			 
0acb				;pop hl 
0acb			 
0acb c1				pop bc 
0acc d1				pop de 
0acd e1				pop hl 
0ace			 
0ace c9				ret 
0acf			 
0acf			 
0acf			;scroll_upo: 
0acf			;	ld de, display_row_1 
0acf			 ;	ld hl, display_row_2 
0acf			;	ld bc, display_cols 
0acf			;	ldir 
0acf			;	ld de, display_row_2 
0acf			 ;	ld hl, display_row_3 
0acf			;	ld bc, display_cols 
0acf			;	ldir 
0acf			;	ld de, display_row_3 
0acf			 ;	ld hl, display_row_4 
0acf			;	ld bc, display_cols 
0acf			;	ldir 
0acf			 
0acf			; TODO clear row 4 
0acf			 
0acf			;	ret 
0acf			 
0acf				 
0acf			scroll_down: 
0acf			 
0acf e5				push hl 
0ad0 d5				push de 
0ad1 c5				push bc 
0ad2			 
0ad2				; get frame buffer  
0ad2			 
0ad2 2a 5e fa			ld hl, (display_fb_active) 
0ad5			 
0ad5 11 4f 00			ld de, display_fb_len - 1 
0ad8 19				add hl, de 
0ad9			 
0ad9 e5			push hl    ; future de destination 
0ada			 
0ada 11 14 00			ld  de, display_cols 
0add ed 52			sbc hl, de 
0adf			 
0adf			 
0adf d1				pop de 
0ae0			 
0ae0			;	ex de, hl 
0ae0 01 4f 00			ld bc, display_fb_len -1  
0ae3			 
0ae3			 
0ae3				 
0ae3			 
0ae3 ed b0			ldir 
0ae5			 
0ae5				; wipe bottom row 
0ae5			 
0ae5			 
0ae5			;	ld hl, (display_fb_active) 
0ae5			;;	ld de, display_cols*display_rows 
0ae5			;;	add hl, de 
0ae5			;	ld b, display_cols 
0ae5			;	ld a, ' ' 
0ae5			;.scwiped: 
0ae5			;	ld (hl), a 
0ae5			;	dec hl 
0ae5			;	djnz .scwiped 
0ae5			 
0ae5				;pop hl 
0ae5			 
0ae5 c1				pop bc 
0ae6 d1				pop de 
0ae7 e1				pop hl 
0ae8			 
0ae8 c9				ret 
0ae9			;scroll_down: 
0ae9			;	ld de, display_row_4 
0ae9			;	ld hl, display_row_3 
0ae9			;	ld bc, display_cols 
0ae9			;	ldir 
0ae9			;	ld de, display_row_3 
0ae9			; 	ld hl, display_row_2 
0ae9			;	ld bc, display_cols 
0ae9			;	ldir 
0ae9			;	ld de, display_row_2 
0ae9			;	ld hl, display_row_1 
0ae9			;	ld bc, display_cols 
0ae9			;	ldir 
0ae9			;;; TODO clear row 1 
0ae9			;	ret 
0ae9			 
0ae9			 
0ae9			 
0ae9			 
0ae9			 
0ae9			; clear active frame buffer 
0ae9			 
0ae9			clear_display: 
0ae9 3e 20			ld a, ' ' 
0aeb c3 ee 0a			jp fill_display 
0aee			 
0aee			; fill active frame buffer with a char in A 
0aee			 
0aee			fill_display: 
0aee 06 50			ld b,display_fb_len 
0af0 2a 5e fa			ld hl, (display_fb_active) 
0af3 77			.fd1:	ld (hl),a 
0af4 23				inc hl 
0af5 10 fc			djnz .fd1 
0af7 23				inc hl 
0af8 3e 00			ld a,0 
0afa 77				ld (hl),a 
0afb			 
0afb			 
0afb c9				ret 
0afc			; Write string (DE) at pos (A) to active frame buffer 
0afc			 
0afc 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0aff 06 00					ld b,0 
0b01 4f					ld c,a 
0b02 09					add hl,bc 
0b03 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b04 b7			            OR   A              ;Null terminator? 
0b05 c8			            RET  Z              ;Yes, so finished 
0b06 77					ld (hl),a 
0b07 23				inc hl 
0b08 13			            INC  DE             ;Point to next character 
0b09 18 f8		            JR   .sad1     ;Repeat 
0b0b c9					ret 
0b0c			 
0b0c			; using current frame buffer write to physical display 
0b0c			 
0b0c			update_display: 
0b0c e5				push hl 
0b0d 2a 5e fa			ld hl, (display_fb_active) 
0b10 cd b4 65			call write_display 
0b13 e1				pop hl 
0b14 c9				ret 
0b15			 
0b15			; TODO scrolling 
0b15			 
0b15			 
0b15			; move cursor right one char 
0b15			cursor_right: 
0b15			 
0b15				; TODO shift right 
0b15				; TODO if beyond max col 
0b15				; TODO       cursor_next_line 
0b15			 
0b15 c9				ret 
0b16			 
0b16			 
0b16			cursor_next_line: 
0b16				; TODO first char 
0b16				; TODO line down 
0b16				; TODO if past last row 
0b16				; TODO    scroll up 
0b16			 
0b16 c9				ret 
0b17			 
0b17			cursor_left: 
0b17				; TODO shift left 
0b17				; TODO if beyond left  
0b17				; TODO     cursor prev line 
0b17				 
0b17 c9				ret 
0b18			 
0b18			cursor_prev_line: 
0b18				; TODO last char 
0b18				; TODO line up 
0b18				; TODO if past first row 
0b18				; TODO   scroll down 
0b18			 
0b18 c9				ret 
0b19			 
0b19			 
0b19			cout: 
0b19				; A - char 
0b19 c9				ret 
0b1a			 
0b1a			 
0b1a			; Display a menu and allow item selection (optional toggle items) 
0b1a			; 
0b1a			; format: 
0b1a			; hl pointer to word array with zero term for items 
0b1a			; e.g.    db item1 
0b1a			;         db .... 
0b1a			;         db 0 
0b1a			; 
0b1a			; a = starting menu item  
0b1a			; 
0b1a			; de = pointer item toggle array   (todo) 
0b1a			; 
0b1a			; returns item selected in a 1-... 
0b1a			; returns 0 if back button pressed 
0b1a			; 
0b1a			; NOTE: Uses system frame buffer to display 
0b1a			; 
0b1a			; LEFT, Q = go back 
0b1a			; RIGHT, SPACE, CR = select 
0b1a			; UP, A - Up 
0b1a			; DOWN, Z - Down 
0b1a			 
0b1a			 
0b1a			 
0b1a			 
0b1a			 
0b1a			menu: 
0b1a			 
0b1a					; keep array pointer 
0b1a			 
0b1a 22 e6 f9				ld (store_tmp1), hl 
0b1d 32 e4 f9				ld (store_tmp2), a 
0b20			 
0b20					; check for key bounce 
0b20			 
0b20			if BASE_KEV 
0b20			 
0b20 cd 69 67		.mbounce:	call cin 
0b23 fe 00				cp 0 
0b25 20 f9				jr nz, .mbounce 
0b27			endif 
0b27					; for ease use ex 
0b27			 
0b27					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b27 21 53 fb				ld hl, display_fb0 
0b2a 22 5e fa				ld (display_fb_active), hl 
0b2d			 
0b2d cd e9 0a		.mloop:		call clear_display 
0b30 cd 0c 0b				call update_display 
0b33			 
0b33					; draw selection id '>' at 1 
0b33			 
0b33					; init start of list display 
0b33			 
0b33 3e 05				ld a, 5 
0b35 32 e2 f9				ld (store_tmp3), a   ; display row count 
0b38 3a e4 f9				ld a,( store_tmp2) 
0b3b 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b3e			 
0b3e					 
0b3e			.mitem:	 
0b3e			 
0b3e			 
0b3e 3a e5 f9				ld a,(store_tmp2+1) 
0b41 6f					ld l, a 
0b42 26 00				ld h, 0 
0b44 29					add hl, hl 
0b45 ed 5b e6 f9			ld de, (store_tmp1) 
0b49 19					add hl, de 
0b4a 7e					ld a, (hl) 
0b4b 23					inc hl 
0b4c 66					ld h,(hl) 
0b4d 6f					ld l, a 
0b4e			 
0b4e cd 46 0d				call ishlzero 
0b51 28 1a				jr z, .mdone 
0b53			 
0b53 eb					ex de, hl 
0b54 3a e2 f9				ld a, (store_tmp3) 
0b57 cd fc 0a				call str_at_display 
0b5a					 
0b5a			 
0b5a					; next item 
0b5a 3a e5 f9				ld a, (store_tmp2+1) 
0b5d 3c					inc a 
0b5e 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b61			 
0b61			 		; next row 
0b61			 
0b61 3a e2 f9				ld a, (store_tmp3) 
0b64 c6 14				add display_cols 
0b66 32 e2 f9				ld (store_tmp3), a 
0b69			 
0b69					; at end of screen? 
0b69			 
0b69 fe 10				cp display_rows*4 
0b6b 20 d1				jr nz, .mitem 
0b6d			 
0b6d			 
0b6d			.mdone: 
0b6d cd 46 0d				call ishlzero 
0b70 28 08				jr z, .nodn 
0b72			 
0b72 3e 3c				ld a, display_row_4 
0b74 11 f3 0b				ld de, .mdown 
0b77 cd fc 0a				call str_at_display 
0b7a			 
0b7a					; draw options to fill the screens with active item on line 1 
0b7a					; if current option is 2 or more then display ^ in top 
0b7a			 
0b7a 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b7d fe 00				cp 0 
0b7f 28 08				jr z, .noup 
0b81			 
0b81 3e 00				ld a, 0 
0b83 11 f1 0b				ld de, .mup 
0b86 cd fc 0a				call str_at_display 
0b89			 
0b89 3e 02		.noup:		ld a, 2 
0b8b 11 ef 0b				ld de, .msel 
0b8e cd fc 0a				call str_at_display 
0b91			 
0b91					; if current option + 1 is not null then display V in bottom 
0b91					; get key 
0b91 cd 0c 0b				call update_display 
0b94			 
0b94			 
0b94					; handle key 
0b94			 
0b94 cd 58 67				call cin_wait 
0b97			 
0b97 fe 05				cp KEY_UP 
0b99 28 2b				jr z, .mgoup 
0b9b fe 61				cp 'a' 
0b9d 28 27				jr z, .mgoup 
0b9f fe 0a				cp KEY_DOWN 
0ba1 28 32				jr z, .mgod 
0ba3 fe 7a				cp 'z' 
0ba5 28 2e				jr z, .mgod 
0ba7 fe 20				cp ' ' 
0ba9 28 34				jr z, .goend 
0bab fe 0c				cp KEY_RIGHT 
0bad 28 30				jr z, .goend 
0baf fe 0d				cp KEY_CR 
0bb1 28 2c				jr z, .goend 
0bb3 fe 71				cp 'q' 
0bb5 28 0b				jr z, .goback 
0bb7			 
0bb7 fe 0b				cp KEY_LEFT 
0bb9 28 07				jr z, .goback 
0bbb fe 08				cp KEY_BS 
0bbd 28 03				jr z, .goback 
0bbf c3 2d 0b				jp .mloop 
0bc2			 
0bc2			.goback: 
0bc2 3e 00			ld a, 0 
0bc4 18 1d			jr .goend2 
0bc6			 
0bc6				; move up one 
0bc6			.mgoup: 
0bc6 3a e4 f9				ld a, (store_tmp2) 
0bc9 fe 00				cp 0 
0bcb ca 2d 0b				jp z, .mloop 
0bce 3d					dec a 
0bcf 32 e4 f9				ld (store_tmp2), a 
0bd2 c3 2d 0b				jp .mloop 
0bd5			 
0bd5				; move down one 
0bd5			.mgod: 
0bd5 3a e4 f9				ld a, (store_tmp2) 
0bd8 3c					inc a 
0bd9 32 e4 f9				ld (store_tmp2), a 
0bdc c3 2d 0b				jp .mloop 
0bdf			 
0bdf			 
0bdf			.goend: 
0bdf					; get selected item number 
0bdf			 
0bdf 3a e4 f9				ld a, (store_tmp2) 
0be2 3c					inc a 
0be3			 
0be3			.goend2: 
0be3 f5					push af 
0be4			 
0be4					; restore active fb 
0be4					; TODO BUG assumes fb1 
0be4			 
0be4 21 02 fb				ld hl, display_fb1 
0be7 22 5e fa				ld (display_fb_active), hl 
0bea			 
0bea					; restore main regs 
0bea			 
0bea			 
0bea cd 0c 0b				call update_display 
0bed			 
0bed f1					pop af 
0bee			 
0bee c9				ret 
0bef			 
0bef .. 00		.msel:   db ">",0 
0bf1 .. 00		.mup:   db "^",0 
0bf3 .. 00		.mdown:   db "v",0 
0bf5			 
0bf5			 
0bf5			; eof 
0bf5			 
# End of file firmware_display.asm
0bf5			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bf5			; random number generators 
0bf5			 
0bf5			 
0bf5			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bf5			 
0bf5			 
0bf5			;-----> Generate a random number 
0bf5			; output a=answer 0<=a<=255 
0bf5			; all registers are preserved except: af 
0bf5			random: 
0bf5 e5			        push    hl 
0bf6 d5			        push    de 
0bf7 2a 40 fa		        ld      hl,(randData) 
0bfa ed 5f		        ld      a,r 
0bfc 57			        ld      d,a 
0bfd 5e			        ld      e,(hl) 
0bfe 19			        add     hl,de 
0bff 85			        add     a,l 
0c00 ac			        xor     h 
0c01 22 40 fa		        ld      (randData),hl 
0c04 d1			        pop     de 
0c05 e1			        pop     hl 
0c06 c9			        ret 
0c07			 
0c07			 
0c07			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c07			 
0c07			 
0c07			 
0c07			;------LFSR------ 
0c07			;James Montelongo 
0c07			;optimized by Spencer Putt 
0c07			;out: 
0c07			; a = 8 bit random number 
0c07			RandLFSR: 
0c07 21 46 fa		        ld hl,LFSRSeed+4 
0c0a 5e			        ld e,(hl) 
0c0b 23			        inc hl 
0c0c 56			        ld d,(hl) 
0c0d 23			        inc hl 
0c0e 4e			        ld c,(hl) 
0c0f 23			        inc hl 
0c10 7e			        ld a,(hl) 
0c11 47			        ld b,a 
0c12 cb 13		        rl e  
0c14 cb 12			rl d 
0c16 cb 11		        rl c  
0c18 17				rla 
0c19 cb 13		        rl e  
0c1b cb 12			rl d 
0c1d cb 11		        rl c  
0c1f 17				rla 
0c20 cb 13		        rl e  
0c22 cb 12			rl d 
0c24 cb 11		        rl c  
0c26 17				rla 
0c27 67			        ld h,a 
0c28 cb 13		        rl e  
0c2a cb 12			rl d 
0c2c cb 11		        rl c  
0c2e 17				rla 
0c2f a8			        xor b 
0c30 cb 13		        rl e  
0c32 cb 12			rl d 
0c34 ac			        xor h 
0c35 a9			        xor c 
0c36 aa			        xor d 
0c37 21 48 fa		        ld hl,LFSRSeed+6 
0c3a 11 49 fa		        ld de,LFSRSeed+7 
0c3d 01 07 00		        ld bc,7 
0c40 ed b8		        lddr 
0c42 12			        ld (de),a 
0c43 c9			        ret 
0c44			 
0c44			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c44			 
0c44			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c44			 
0c44			 
0c44			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c44			 
0c44			prng16: 
0c44			;Inputs: 
0c44			;   (seed1) contains a 16-bit seed value 
0c44			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c44			;Outputs: 
0c44			;   HL is the result 
0c44			;   BC is the result of the LCG, so not that great of quality 
0c44			;   DE is preserved 
0c44			;Destroys: 
0c44			;   AF 
0c44			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c44			;160cc 
0c44			;26 bytes 
0c44 2a 3a fa		    ld hl,(seed1) 
0c47 44			    ld b,h 
0c48 4d			    ld c,l 
0c49 29			    add hl,hl 
0c4a 29			    add hl,hl 
0c4b 2c			    inc l 
0c4c 09			    add hl,bc 
0c4d 22 3a fa		    ld (seed1),hl 
0c50 2a 38 fa		    ld hl,(seed2) 
0c53 29			    add hl,hl 
0c54 9f			    sbc a,a 
0c55 e6 2d		    and %00101101 
0c57 ad			    xor l 
0c58 6f			    ld l,a 
0c59 22 38 fa		    ld (seed2),hl 
0c5c 09			    add hl,bc 
0c5d c9			    ret 
0c5e			 
0c5e			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c5e			 
0c5e			rand32: 
0c5e			;Inputs: 
0c5e			;   (seed1_0) holds the lower 16 bits of the first seed 
0c5e			;   (seed1_1) holds the upper 16 bits of the first seed 
0c5e			;   (seed2_0) holds the lower 16 bits of the second seed 
0c5e			;   (seed2_1) holds the upper 16 bits of the second seed 
0c5e			;   **NOTE: seed2 must be non-zero 
0c5e			;Outputs: 
0c5e			;   HL is the result 
0c5e			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c5e			;Destroys: 
0c5e			;   AF 
0c5e			;Tested and passes all CAcert tests 
0c5e			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c5e			;it has a period of 18,446,744,069,414,584,320 
0c5e			;roughly 18.4 quintillion. 
0c5e			;LFSR taps: 0,2,6,7  = 11000101 
0c5e			;291cc 
0c5e			;seed1_0=$+1 
0c5e			;    ld hl,12345 
0c5e			;seed1_1=$+1 
0c5e			;    ld de,6789 
0c5e			;    ld b,h 
0c5e			;    ld c,l 
0c5e			;    add hl,hl \ rl e \ rl d 
0c5e			;    add hl,hl \ rl e \ rl d 
0c5e			;    inc l 
0c5e			;    add hl,bc 
0c5e			;    ld (seed1_0),hl 
0c5e			;    ld hl,(seed1_1) 
0c5e			;    adc hl,de 
0c5e			;    ld (seed1_1),hl 
0c5e			;    ex de,hl 
0c5e			;seed2_0=$+1 
0c5e			;    ld hl,9876 
0c5e			;seed2_1=$+1 
0c5e			;    ld bc,54321 
0c5e			;    add hl,hl \ rl c \ rl b 
0c5e			;    ld (seed2_1),bc 
0c5e			;    sbc a,a 
0c5e			;    and %11000101 
0c5e			;    xor l 
0c5e			;    ld l,a 
0c5e			;    ld (seed2_0),hl 
0c5e			;    ex de,hl 
0c5e			;    add hl,bc 
0c5e			;    ret 
0c5e			; 
0c5e			 
0c5e			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c5e			; 20 bytes, 86 cycles (excluding ret) 
0c5e			 
0c5e			; returns   hl = pseudorandom number 
0c5e			; corrupts   a 
0c5e			 
0c5e			; generates 16-bit pseudorandom numbers with a period of 65535 
0c5e			; using the xorshift method: 
0c5e			 
0c5e			; hl ^= hl << 7 
0c5e			; hl ^= hl >> 9 
0c5e			; hl ^= hl << 8 
0c5e			 
0c5e			; some alternative shift triplets which also perform well are: 
0c5e			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c5e			 
0c5e			;  org 32768 
0c5e			 
0c5e			xrnd: 
0c5e 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c61 3e 00		  ld a,0 
0c63 bd			  cp l 
0c64 20 02		  jr nz, .xrnd1 
0c66 2e 01		  ld l, 1 
0c68			.xrnd1: 
0c68			 
0c68 7c			  ld a,h 
0c69 1f			  rra 
0c6a 7d			  ld a,l 
0c6b 1f			  rra 
0c6c ac			  xor h 
0c6d 67			  ld h,a 
0c6e 7d			  ld a,l 
0c6f 1f			  rra 
0c70 7c			  ld a,h 
0c71 1f			  rra 
0c72 ad			  xor l 
0c73 6f			  ld l,a 
0c74 ac			  xor h 
0c75 67			  ld h,a 
0c76			 
0c76 22 3e fa		  ld (xrandc),hl 
0c79			 
0c79 c9			  ret 
0c7a			;  
0c7a			 
0c7a			 
0c7a			;;;; int maths 
0c7a			 
0c7a			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c7a			; Divide 16-bit values (with 16-bit result) 
0c7a			; In: Divide BC by divider DE 
0c7a			; Out: BC = result, HL = rest 
0c7a			; 
0c7a			Div16: 
0c7a 21 00 00		    ld hl,0 
0c7d 78			    ld a,b 
0c7e 06 08		    ld b,8 
0c80			Div16_Loop1: 
0c80 17			    rla 
0c81 ed 6a		    adc hl,hl 
0c83 ed 52		    sbc hl,de 
0c85 30 01		    jr nc,Div16_NoAdd1 
0c87 19			    add hl,de 
0c88			Div16_NoAdd1: 
0c88 10 f6		    djnz Div16_Loop1 
0c8a 17			    rla 
0c8b 2f			    cpl 
0c8c 47			    ld b,a 
0c8d 79			    ld a,c 
0c8e 48			    ld c,b 
0c8f 06 08		    ld b,8 
0c91			Div16_Loop2: 
0c91 17			    rla 
0c92 ed 6a		    adc hl,hl 
0c94 ed 52		    sbc hl,de 
0c96 30 01		    jr nc,Div16_NoAdd2 
0c98 19			    add hl,de 
0c99			Div16_NoAdd2: 
0c99 10 f6		    djnz Div16_Loop2 
0c9b 17			    rla 
0c9c 2f			    cpl 
0c9d 41			    ld b,c 
0c9e 4f			    ld c,a 
0c9f c9			ret 
0ca0			 
0ca0			 
0ca0			;http://z80-heaven.wikidot.com/math 
0ca0			; 
0ca0			;Inputs: 
0ca0			;     DE and A are factors 
0ca0			;Outputs: 
0ca0			;     A is not changed 
0ca0			;     B is 0 
0ca0			;     C is not changed 
0ca0			;     DE is not changed 
0ca0			;     HL is the product 
0ca0			;Time: 
0ca0			;     342+6x 
0ca0			; 
0ca0			Mult16: 
0ca0			 
0ca0 06 08		     ld b,8          ;7           7 
0ca2 21 00 00		     ld hl,0         ;10         10 
0ca5 29			       add hl,hl     ;11*8       88 
0ca6 07			       rlca          ;4*8        32 
0ca7 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ca9 19			         add hl,de   ;--         -- 
0caa 10 f9		       djnz $-5      ;13*7+8     99 
0cac c9			ret 
0cad			 
0cad			; 
0cad			; Square root of 16-bit value 
0cad			; In:  HL = value 
0cad			; Out:  D = result (rounded down) 
0cad			; 
0cad			;Sqr16: 
0cad			;    ld de,#0040 
0cad			;    ld a,l 
0cad			;    ld l,h 
0cad			;    ld h,d 
0cad			;    or a 
0cad			;    ld b,8 
0cad			;Sqr16_Loop: 
0cad			;    sbc hl,de 
0cad			;    jr nc,Sqr16_Skip 
0cad			;    add hl,de 
0cad			;Sqr16_Skip: 
0cad			;    ccf 
0cad			;    rl d 
0cad			;    add a,a 
0cad			;    adc hl,hl 
0cad			;    add a,a 
0cad			;    adc hl,hl 
0cad			;    djnz Sqr16_Loop 
0cad			;    ret 
0cad			; 
0cad			; 
0cad			; Divide 8-bit values 
0cad			; In: Divide E by divider C 
0cad			; Out: A = result, B = rest 
0cad			; 
0cad			Div8: 
0cad af			    xor a 
0cae 06 08		    ld b,8 
0cb0			Div8_Loop: 
0cb0 cb 13		    rl e 
0cb2 17			    rla 
0cb3 91			    sub c 
0cb4 30 01		    jr nc,Div8_NoAdd 
0cb6 81			    add a,c 
0cb7			Div8_NoAdd: 
0cb7 10 f7		    djnz Div8_Loop 
0cb9 47			    ld b,a 
0cba 7b			    ld a,e 
0cbb 17			    rla 
0cbc 2f			    cpl 
0cbd c9			    ret 
0cbe			 
0cbe			; 
0cbe			; Multiply 8-bit value with a 16-bit value (unrolled) 
0cbe			; In: Multiply A with DE 
0cbe			; Out: HL = result 
0cbe			; 
0cbe			Mult12U: 
0cbe 2e 00		    ld l,0 
0cc0 87			    add a,a 
0cc1 30 01		    jr nc,Mult12U_NoAdd0 
0cc3 19			    add hl,de 
0cc4			Mult12U_NoAdd0: 
0cc4 29			    add hl,hl 
0cc5 87			    add a,a 
0cc6 30 01		    jr nc,Mult12U_NoAdd1 
0cc8 19			    add hl,de 
0cc9			Mult12U_NoAdd1: 
0cc9 29			    add hl,hl 
0cca 87			    add a,a 
0ccb 30 01		    jr nc,Mult12U_NoAdd2 
0ccd 19			    add hl,de 
0cce			Mult12U_NoAdd2: 
0cce 29			    add hl,hl 
0ccf 87			    add a,a 
0cd0 30 01		    jr nc,Mult12U_NoAdd3 
0cd2 19			    add hl,de 
0cd3			Mult12U_NoAdd3: 
0cd3 29			    add hl,hl 
0cd4 87			    add a,a 
0cd5 30 01		    jr nc,Mult12U_NoAdd4 
0cd7 19			    add hl,de 
0cd8			Mult12U_NoAdd4: 
0cd8 29			    add hl,hl 
0cd9 87			    add a,a 
0cda 30 01		    jr nc,Mult12U_NoAdd5 
0cdc 19			    add hl,de 
0cdd			Mult12U_NoAdd5: 
0cdd 29			    add hl,hl 
0cde 87			    add a,a 
0cdf 30 01		    jr nc,Mult12U_NoAdd6 
0ce1 19			    add hl,de 
0ce2			Mult12U_NoAdd6: 
0ce2 29			    add hl,hl 
0ce3 87			    add a,a 
0ce4 d0			    ret nc 
0ce5 19			    add hl,de 
0ce6 c9			    ret 
0ce7			 
0ce7			; 
0ce7			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ce7			; In: Multiply A with DE 
0ce7			;      Put lowest value in A for most efficient calculation 
0ce7			; Out: HL = result 
0ce7			; 
0ce7			Mult12R: 
0ce7 21 00 00		    ld hl,0 
0cea			Mult12R_Loop: 
0cea cb 3f		    srl a 
0cec 30 01		    jr nc,Mult12R_NoAdd 
0cee 19			    add hl,de 
0cef			Mult12R_NoAdd: 
0cef cb 23		    sla e 
0cf1 cb 12		    rl d 
0cf3 b7			    or a 
0cf4 c2 ea 0c		    jp nz,Mult12R_Loop 
0cf7 c9			    ret 
0cf8			 
0cf8			; 
0cf8			; Multiply 16-bit values (with 32-bit result) 
0cf8			; In: Multiply BC with DE 
0cf8			; Out: BCHL = result 
0cf8			; 
0cf8			Mult32: 
0cf8 79			    ld a,c 
0cf9 48			    ld c,b 
0cfa 21 00 00		    ld hl,0 
0cfd 06 10		    ld b,16 
0cff			Mult32_Loop: 
0cff 29			    add hl,hl 
0d00 17			    rla 
0d01 cb 11		    rl c 
0d03 30 07		    jr nc,Mult32_NoAdd 
0d05 19			    add hl,de 
0d06 ce 00		    adc a,0 
0d08 d2 0c 0d		    jp nc,Mult32_NoAdd 
0d0b 0c			    inc c 
0d0c			Mult32_NoAdd: 
0d0c 10 f1		    djnz Mult32_Loop 
0d0e 41			    ld b,c 
0d0f 4f			    ld c,a 
0d10 c9			    ret 
0d11			 
0d11			 
0d11			 
0d11			; 
0d11			; Multiply 8-bit values 
0d11			; In:  Multiply H with E 
0d11			; Out: HL = result 
0d11			; 
0d11			Mult8: 
0d11 16 00		    ld d,0 
0d13 6a			    ld l,d 
0d14 06 08		    ld b,8 
0d16			Mult8_Loop: 
0d16 29			    add hl,hl 
0d17 30 01		    jr nc,Mult8_NoAdd 
0d19 19			    add hl,de 
0d1a			Mult8_NoAdd: 
0d1a 10 fa		    djnz Mult8_Loop 
0d1c c9			    ret 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			;;http://z80-heaven.wikidot.com/math 
0d1d			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d1d			; 
0d1d			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d1d			;     ld a,16        ;7 
0d1d			;     ld hl,0        ;10 
0d1d			;     jp $+5         ;10 
0d1d			;.DivLoop: 
0d1d			;       add hl,bc    ;-- 
0d1d			;       dec a        ;64 
0d1d			;       jr z,.DivLoopEnd        ;86 
0d1d			; 
0d1d			;       sla e        ;128 
0d1d			;       rl d         ;128 
0d1d			;       adc hl,hl    ;240 
0d1d			;       sbc hl,bc    ;240 
0d1d			;       jr nc,.DivLoop ;23|21 
0d1d			;       inc e        ;-- 
0d1d			;       jp .DivLoop+1 
0d1d			; 
0d1d			;.DivLoopEnd: 
0d1d			 
0d1d			;HL_Div_C: 
0d1d			;Inputs: 
0d1d			;     HL is the numerator 
0d1d			;     C is the denominator 
0d1d			;Outputs: 
0d1d			;     A is the remainder 
0d1d			;     B is 0 
0d1d			;     C is not changed 
0d1d			;     DE is not changed 
0d1d			;     HL is the quotient 
0d1d			; 
0d1d			;       ld b,16 
0d1d			;       xor a 
0d1d			;         add hl,hl 
0d1d			;         rla 
0d1d			;         cp c 
0d1d			;         jr c,$+4 
0d1d			;           inc l 
0d1d			;           sub c 
0d1d			;         djnz $-7 
0d1d			 
0d1d			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d1d			 
0d1d			addatohl: 
0d1d 85			    add   a, l    ; A = A+L 
0d1e 6f			    ld    l, a    ; L = A+L 
0d1f 8c			    adc   a, h    ; A = A+L+H+carry 
0d20 95			    sub   l       ; A = H+carry 
0d21 67			    ld    h, a    ; H = H+carry 
0d22 c9			ret 
0d23			 
0d23			addatode: 
0d23 83			    add   a, e    ; A = A+L 
0d24 5f			    ld    e, a    ; L = A+L 
0d25 8a			    adc   a, d    ; A = A+L+H+carry 
0d26 93			    sub   e       ; A = H+carry 
0d27 57			    ld    d, a    ; H = H+carry 
0d28 c9			ret 
0d29			 
0d29			 
0d29			addatobc: 
0d29 81			    add   a, c    ; A = A+L 
0d2a 4f			    ld    c, a    ; L = A+L 
0d2b 88			    adc   a, b    ; A = A+L+H+carry 
0d2c 91			    sub   c       ; A = H+carry 
0d2d 47			    ld    b, a    ; H = H+carry 
0d2e c9			ret 
0d2f			 
0d2f			subafromhl: 
0d2f			   ; If A=0 do nothing 
0d2f			    ; Otherwise flip A's sign. Since 
0d2f			    ; the upper byte becomes -1, also 
0d2f			    ; substract 1 from H. 
0d2f ed 44		    neg 
0d31 ca 3a 0d		    jp    z, Skip 
0d34 25			    dec   h 
0d35			     
0d35			    ; Now add the low byte as usual 
0d35			    ; Two's complement takes care of 
0d35			    ; ensuring the result is correct 
0d35 85			    add   a, l 
0d36 6f			    ld    l, a 
0d37 8c			    adc   a, h 
0d38 95			    sub   l 
0d39 67			    ld    h, a 
0d3a			Skip: 
0d3a c9				ret 
0d3b			 
0d3b			 
0d3b			; compare hl and de 
0d3b			; returns:  
0d3b			; if hl = de, z=1, s=0, c0=0 
0d3b			; if hl > de, z=0, s=0, c=0 
0d3b			; if hl < de, z=0, s=1, c=1 
0d3b			cmp16:	 
0d3b b7				or a 
0d3c ed 52			sbc hl,de 
0d3e e0				ret po 
0d3f 7c				ld a,h 
0d40 1f				rra 
0d41 ee 40			xor 01000000B 
0d43 37				scf 
0d44 8f				adc a,a 
0d45 c9				ret 
0d46			 
0d46			 
0d46			; test if hl contains zero   - A is destroyed 
0d46			 
0d46			ishlzero:    
0d46 b7				or a     ; reset flags 
0d47 7c				ld a, h 
0d48 b5				or l        	 
0d49			 
0d49 c9				ret 
0d4a			 
0d4a			 
0d4a			 
0d4a			 
0d4a			if FORTH_ENABLE_FLOATMATH 
0d4a			;include "float/bbcmath.z80" 
0d4a			include "float/lpfpcalc.asm" 
0d4a			endif 
0d4a			 
0d4a			 
0d4a			; eof 
0d4a			 
# End of file firmware_maths.asm
0d4a			include "firmware_strings.asm"   ; string handling  
0d4a			 
0d4a			 
0d4a			; TODO string len 
0d4a			; input text string, end on cr with zero term 
0d4a			; a offset into frame buffer to start prompt 
0d4a			; d is max length 
0d4a			; e is display size TODO 
0d4a			; c is current cursor position 
0d4a			; hl is ptr to where string will be stored 
0d4a			 
0d4a			 
0d4a			; TODO check limit of buffer for new inserts 
0d4a			; TODO check insert does not push beyond buffer 
0d4a			; TODO scroll in a limited display area 
0d4a			; TODO scroll whole screen on page wrap 
0d4a			 
0d4a			 
0d4a			; TODO handle KEY_PREVWORD 
0d4a			; TODO handle KEY_NEXTWORD 
0d4a			; TODO handle KEY_HOME 
0d4a			; TODO handle KEY_END 
0d4a			; TODO use LCD cursor? 
0d4a			 
0d4a 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d4d 81					add c 
0d4e 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d51 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0d54 79					ld a, c 
0d55 cd 1d 0d				call addatohl 
0d58 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d5b 7a					ld a,d 
0d5c 32 b8 fb			        ld (input_size), a       ; save length of input area 
0d5f 79					ld a, c 
0d60 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d63 7b					ld a,e 
0d64 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d67					 
0d67					 
0d67			 
0d67			;		ld a,(input_ptr) 
0d67			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d67			 
0d67			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d67					; init cursor shape if not set by the cin routines 
0d67 21 56 fa				ld hl, cursor_shape 
0d6a 3e ff				ld a, 255 
0d6c 77					ld (hl), a 
0d6d 23					inc hl 
0d6e 3e 00				ld a, 0 
0d70 77					ld (hl), a 
0d71			 
0d71 3e 0f				ld a, CUR_BLINK_RATE 
0d73 32 b2 fb				ld (input_cur_flash), a 
0d76 3e 01				ld a, 1 
0d78 32 b1 fb				ld (input_cur_onoff),a 
0d7b			 
0d7b			;	if DEBUG_INPUT 
0d7b			;		push af 
0d7b			;		ld a, 'I' 
0d7b			;		ld (debug_mark),a 
0d7b			;		pop af 
0d7b			;		CALLMONITOR 
0d7b			;	endif 
0d7b			.is1:		; main entry loop 
0d7b			 
0d7b			 
0d7b			 
0d7b					; pause 1ms 
0d7b			 
0d7b 3e 01				ld a, 1 
0d7d cd 4b 0a				call aDelayInMS 
0d80			 
0d80					; dec flash counter 
0d80 3a b2 fb				ld a, (input_cur_flash) 
0d83 3d					dec a 
0d84 32 b2 fb				ld (input_cur_flash), a 
0d87 fe 00				cp 0 
0d89 20 0d				jr nz, .nochgstate 
0d8b			 
0d8b			 
0d8b					; change state 
0d8b 3a b1 fb				ld a,(input_cur_onoff) 
0d8e ed 44				neg 
0d90 32 b1 fb				ld (input_cur_onoff),a 
0d93			 
0d93			 
0d93					; reset on change of state 
0d93 3e 0f				ld a, CUR_BLINK_RATE 
0d95 32 b2 fb				ld (input_cur_flash), a 
0d98			 
0d98			.nochgstate: 
0d98					 
0d98					 
0d98			 
0d98					; display cursor  
0d98			 
0d98			;		ld hl, (input_start) 
0d98			;		ld a, (input_cursor) 
0d98			;		call addatohl 
0d98			 
0d98					; get char under cursor and replace with cursor 
0d98 2a bb fb		ld hl, (input_ptr) 
0d9b			;		ld a, (hl) 
0d9b			;		ld (input_under_cursor),a 
0d9b			;		ld a, '_' 
0d9b			;		ld (hl), a 
0d9b			 
0d9b					; display string 
0d9b			 
0d9b ed 5b b9 fb			ld de, (input_start) 
0d9f 3a b6 fb				ld a, (input_at_pos) 
0da2 cd fc 0a				call str_at_display 
0da5			;	        call update_display 
0da5			 
0da5					; find place to put the cursor 
0da5			;		add h 
0da5			;		ld l, display_row_1 
0da5			;		sub l 
0da5			; (input_at_pos) 
0da5					;ld c, a 
0da5			;		ld a, (input_cursor) 
0da5			;		ld l, (input_at_pos) 
0da5			;		;ld b, h 
0da5			;		add l 
0da5			;		ld (input_at_cursor),a 
0da5					;ld l,h 
0da5			 
0da5			;		ld h, 0 
0da5			;		ld l,(input_at_pos) 
0da5			;		ld a, (input_cursor) 
0da5			;		call addatohl 
0da5			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0da5			;		call subafromhl 
0da5			;		ld a,l 
0da5			;		ld (input_at_cursor), a 
0da5			 
0da5				if DEBUG_INPUT 
0da5					ld a, (hardware_diag) 
0da5					cp 0 
0da5					jr z, .skip_input_diag 
0da5			 
0da5					ld a,(input_at_pos) 
0da5					ld hl, LFSRSeed 
0da5					call hexout 
0da5					ld a, (input_cursor) 
0da5					ld hl, LFSRSeed+2 
0da5					call hexout 
0da5					ld a,(input_at_cursor) 
0da5					ld hl, LFSRSeed+4 
0da5					call hexout 
0da5			 
0da5					ld a,(input_cur_onoff) 
0da5					ld hl, LFSRSeed+6 
0da5					call hexout 
0da5			 
0da5					ld a,(input_cur_flash) 
0da5					ld hl, LFSRSeed+8 
0da5					call hexout 
0da5			 
0da5					ld a,(input_len) 
0da5					ld hl, LFSRSeed+10 
0da5					call hexout 
0da5					ld hl, LFSRSeed+12 
0da5					ld a, 0 
0da5					ld (hl),a 
0da5					ld a, display_row_4 
0da5					ld de, LFSRSeed 
0da5					call str_at_display 
0da5					.skip_input_diag: 
0da5				endif 
0da5			 
0da5					; decide on if we are showing the cursor this time round 
0da5			 
0da5 3a b1 fb				ld a, (input_cur_onoff) 
0da8 fe ff				cp 255 
0daa 28 13				jr z, .skipcur 
0dac			 
0dac			 
0dac 3a b4 fb				ld a,(input_at_cursor) 
0daf 11 56 fa				ld de, cursor_shape 
0db2 cd fc 0a				call str_at_display 
0db5			 
0db5					; save length of current input string 
0db5 2a b9 fb				ld hl, (input_start) 
0db8 cd 7b 11				call strlenz 
0dbb 7d					ld a,l 
0dbc 32 ac fb				ld (input_len),a 
0dbf			 
0dbf			.skipcur: 
0dbf			 
0dbf cd 0c 0b			        call update_display 
0dc2					 
0dc2			 
0dc2			 
0dc2					; wait 
0dc2				 
0dc2					; TODO loop without wait to flash the cursor and char under cursor	 
0dc2 cd 69 67				call cin    ; _wait 
0dc5			 
0dc5 fe 00				cp 0 
0dc7 ca 7b 0d				jp z, .is1 
0dca			 
0dca					; get ptr to char to input into 
0dca			 
0dca 4f					ld c,a 
0dcb 2a b9 fb				ld hl, (input_start) 
0dce 3a a7 fb				ld a, (input_cursor) 
0dd1 cd 1d 0d				call addatohl 
0dd4 22 bb fb				ld (input_ptr), hl 
0dd7 79					ld a,c 
0dd8			 
0dd8					; replace char under cursor 
0dd8			 
0dd8			;		ld hl, (input_ptr) 
0dd8			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dd8			;		ld (hl), a 
0dd8			 
0dd8			;	if DEBUG_INPUT 
0dd8			;		push af 
0dd8			;		ld a, 'i' 
0dd8			;		ld (debug_mark),a 
0dd8			;		pop af 
0dd8			;		CALLMONITOR 
0dd8			;	endif 
0dd8 fe 0e				cp KEY_HOME 
0dda 20 0e				jr nz, .iske 
0ddc			 
0ddc 3a b6 fb				ld a, (input_at_pos) 
0ddf 32 b4 fb				ld (input_at_cursor),a 
0de2 3e 00				ld a, 0 
0de4 32 a7 fb				ld (input_cursor), a 
0de7 c3 7b 0d				jp .is1 
0dea					 
0dea fe 0f		.iske:		cp KEY_END 
0dec 20 03				jr nz, .isknw 
0dee c3 7b 0d				jp .is1 
0df1			 
0df1 fe 06		.isknw:		cp KEY_NEXTWORD 
0df3 20 1b				jr nz, .iskpw 
0df5			 
0df5 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0df8 7e					ld a,(hl)	 
0df9 fe 00				cp 0 
0dfb ca 7b 0d				jp z, .is1    ; end of string 
0dfe fe 20				cp ' ' 
0e00 ca 7b 0d				jp z, .is1    ; end of word 
0e03 23					inc hl 
0e04 22 bb fb				ld (input_ptr), hl 
0e07 3a b4 fb				ld a, (input_at_cursor) 
0e0a 3c					inc a 
0e0b 32 b4 fb				ld (input_at_cursor), a 
0e0e 18 e5				jr .isknwm 
0e10			 
0e10 fe 07		.iskpw:		cp KEY_PREVWORD 
0e12 20 1b				jr nz, .iskl 
0e14			.iskpwm:	 
0e14 2a bb fb				ld hl, (input_ptr) 
0e17 7e					ld a,(hl)	 
0e18 fe 00				cp 0  
0e1a ca 7b 0d				jp z, .is1    ; end of string 
0e1d fe 20				cp ' ' 
0e1f ca 7b 0d				jp z, .is1    ; end of word 
0e22 2b					dec hl 
0e23 22 bb fb				ld (input_ptr), hl 
0e26 3a b4 fb				ld a, (input_at_cursor) 
0e29 3d					dec a 
0e2a 32 b4 fb				ld (input_at_cursor), a 
0e2d 18 e5				jr .iskpwm 
0e2f			 
0e2f			 
0e2f fe 0b		.iskl:		cp KEY_LEFT 
0e31 20 27				jr nz, .isk1 
0e33			 
0e33 3a a7 fb				ld a, (input_cursor) 
0e36			 
0e36 fe 00				cp 0 
0e38 ca 7b 0d				jp z, .is1 		; at start of line to ignore  
0e3b			 
0e3b 3d					dec  a 		; TODO check underflow 
0e3c 32 a7 fb				ld (input_cursor), a 
0e3f			 
0e3f 2a bb fb				ld hl, (input_ptr) 
0e42 2b					dec hl 
0e43 22 bb fb				ld (input_ptr), hl 
0e46					 
0e46 3a b4 fb				ld a, (input_at_cursor) 
0e49 3d					dec a 
0e4a 32 b4 fb				ld (input_at_cursor), a 
0e4d			 
0e4d 3e 01				ld a, 1		; show cursor moving 
0e4f 32 b1 fb				ld (input_cur_onoff),a 
0e52 3e 0f				ld a, CUR_BLINK_RATE 
0e54 32 b2 fb				ld (input_cur_flash), a 
0e57			 
0e57 c3 7b 0d				jp .is1 
0e5a			 
0e5a fe 0c		.isk1:		cp KEY_RIGHT 
0e5c 20 2a				jr nz, .isk2 
0e5e			 
0e5e 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e61 5f					ld e,a 
0e62 3a a7 fb				ld a, (input_cursor) 
0e65 bb					cp e 
0e66 ca 7b 0d				jp z, .is1		; at the end of string so dont go right 
0e69			 
0e69 3c					inc  a 		; TODO check overflow 
0e6a 32 a7 fb				ld (input_cursor), a 
0e6d			 
0e6d 3a b4 fb				ld a, (input_at_cursor) 
0e70 3c					inc a 
0e71 32 b4 fb				ld (input_at_cursor), a 
0e74			 
0e74 2a bb fb				ld hl, (input_ptr) 
0e77 23					inc hl 
0e78 22 bb fb				ld (input_ptr), hl 
0e7b			 
0e7b 3e 01				ld a, 1		; show cursor moving 
0e7d 32 b1 fb				ld (input_cur_onoff),a 
0e80 3e 0f				ld a, CUR_BLINK_RATE 
0e82 32 b2 fb				ld (input_cur_flash), a 
0e85			 
0e85 c3 7b 0d				jp .is1 
0e88			 
0e88 fe 05		.isk2:		cp KEY_UP 
0e8a			 
0e8a 20 26				jr nz, .isk3 
0e8c			 
0e8c					; swap last command with the current on 
0e8c			 
0e8c					; move cursor to start of string 
0e8c 2a b9 fb				ld hl, (input_start) 
0e8f 22 bb fb				ld (input_ptr), hl 
0e92			 
0e92 3a b6 fb				ld a, (input_at_pos) 
0e95 32 b4 fb				ld (input_at_cursor), a 
0e98			 
0e98 3e 00				ld a, 0 
0e9a 32 a7 fb				ld (input_cursor), a 
0e9d					 
0e9d					; swap input and last command buffers 
0e9d			 
0e9d 21 ca f2				ld hl, os_cli_cmd 
0ea0 11 c9 f3				ld de, os_last_cmd 
0ea3 06 ff				ld b, 255 
0ea5 7e			.swap1:		ld a, (hl) 
0ea6 4f					ld c,a 
0ea7 1a					ld a, (de) 
0ea8 77					ld (hl), a 
0ea9 79					ld a,c 
0eaa 12					ld (de),a 
0eab 23					inc hl 
0eac 13					inc de 
0ead 10 f6				djnz .swap1 
0eaf			 
0eaf			 
0eaf			 
0eaf			 
0eaf			 
0eaf c3 7b 0d				jp .is1 
0eb2			 
0eb2 fe 08		.isk3:		cp KEY_BS 
0eb4 20 3c				jr nz, .isk4 
0eb6			 
0eb6 3a a7 fb				ld a, (input_cursor) 
0eb9			 
0eb9 fe 00				cp 0 
0ebb ca 7b 0d				jp z, .is1 		; at start of line to ignore  
0ebe			 
0ebe 3d					dec  a 		; TODO check underflow 
0ebf 32 a7 fb				ld (input_cursor), a 
0ec2			 
0ec2					; hl is source 
0ec2					; de needs to be source - 1 
0ec2			 
0ec2			;		ld a, 0 
0ec2			;		dec hl 
0ec2			;		ld (hl), a 
0ec2			 
0ec2 2a bb fb				ld hl, (input_ptr) 
0ec5 2b					dec hl 
0ec6 22 bb fb				ld (input_ptr), hl 
0ec9			 
0ec9					; shift all data 
0ec9			 
0ec9 e5					push hl 
0eca 23					inc hl 
0ecb d1					pop de 
0ecc 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ecf 4f					ld c,a 
0ed0 06 00				ld b,0 
0ed2 ed b0				ldir  
0ed4			 
0ed4			 
0ed4			 
0ed4			 
0ed4 3a b4 fb				ld a, (input_at_cursor) 
0ed7 3d					dec a 
0ed8 32 b4 fb				ld (input_at_cursor), a 
0edb			 
0edb			 
0edb 3e 01				ld a, 1		; show cursor moving 
0edd 32 b1 fb				ld (input_cur_onoff),a 
0ee0 3e 0f				ld a, CUR_BLINK_RATE 
0ee2 32 b2 fb				ld (input_cur_flash), a 
0ee5			 
0ee5					; remove char 
0ee5 3a b4 fb				ld a, (input_at_cursor) 
0ee8 3c					inc a 
0ee9 11 73 0f				ld de,.iblank 
0eec cd fc 0a				call str_at_display 
0eef			 
0eef c3 7b 0d				jp .is1 
0ef2			 
0ef2 fe 0d		.isk4:		cp KEY_CR 
0ef4 28 6c				jr z, .endinput 
0ef6			 
0ef6					; else add the key press to the end 
0ef6			 
0ef6 4f					ld c, a			; save key pressed 
0ef7			 
0ef7 7e					ld a,(hl)		; get what is currently under char 
0ef8			 
0ef8 fe 00				cp 0			; we are at the end of the string 
0efa 20 2f				jr nz, .onchar 
0efc					 
0efc					; add a char to the end of the string 
0efc				 
0efc 71					ld (hl),c 
0efd 23					inc hl 
0efe			;		ld a,' ' 
0efe			;		ld (hl),a 
0efe			;		inc hl 
0efe 3e 00				ld a,0 
0f00 77					ld (hl),a 
0f01 2b					dec hl 
0f02			 
0f02 3a a7 fb				ld a, (input_cursor) 
0f05 3c					inc a				; TODO check max string length and scroll  
0f06 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0f09							 
0f09 3a b4 fb				ld a, (input_at_cursor) 
0f0c 3c					inc a 
0f0d 32 b4 fb				ld (input_at_cursor), a 
0f10			 
0f10 2a bb fb				ld hl, (input_ptr) 
0f13 23					inc hl 
0f14 22 bb fb				ld (input_ptr), hl 
0f17			 
0f17 2a bb fb				ld hl, (input_ptr) 
0f1a 23					inc hl 
0f1b 22 bb fb				ld (input_ptr), hl 
0f1e			;	if DEBUG_INPUT 
0f1e			;		push af 
0f1e			;		ld a, '+' 
0f1e			;		ld (debug_mark),a 
0f1e			;		pop af 
0f1e			;		CALLMONITOR 
0f1e			;	endif 
0f1e 3e 01				ld a, 1		; show cursor moving 
0f20 32 b1 fb				ld (input_cur_onoff),a 
0f23 3e 0f				ld a, CUR_BLINK_RATE 
0f25 32 b2 fb				ld (input_cur_flash), a 
0f28 c3 7b 0d				jp .is1 
0f2b					 
0f2b			 
0f2b			 
0f2b					; if on a char then insert 
0f2b			.onchar: 
0f2b			 
0f2b					; TODO over flow check: make sure insert does not blow out buffer 
0f2b			 
0f2b					; need to do some maths to use lddr 
0f2b			 
0f2b e5					push hl   ; save char pos 
0f2c c5					push bc 
0f2d			 
0f2d 2a b9 fb				ld hl, (input_start) 
0f30 3a ac fb				ld a, (input_len) 
0f33 cd 1d 0d				call addatohl  		; end of string 
0f36 23					inc hl 
0f37 23					inc hl		; past zero term 
0f38 e5					push hl 
0f39 23					inc hl 
0f3a e5					push hl  
0f3b			 
0f3b								; start and end of lddr set, now how much to move? 
0f3b			 
0f3b							 
0f3b 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f3e 47					ld b,a 
0f3f 3a ac fb				ld a,(input_len) 
0f42 5f					ld e,a 
0f43 90					sub b 
0f44 3c					inc a		;?? 
0f45 3c					inc a		;?? 
0f46 3c					inc a		;?? 
0f47			 
0f47 06 00				ld b,0 
0f49 4f					ld c,a 
0f4a			 
0f4a				if DEBUG_INPUT 
0f4a					push af 
0f4a					ld a, 'i' 
0f4a					ld (debug_mark),a 
0f4a					pop af 
0f4a			;		CALLMONITOR 
0f4a				endif 
0f4a d1					pop de 
0f4b e1					pop hl 
0f4c				if DEBUG_INPUT 
0f4c					push af 
0f4c					ld a, 'I' 
0f4c					ld (debug_mark),a 
0f4c					pop af 
0f4c			;		CALLMONITOR 
0f4c				endif 
0f4c ed b8				lddr 
0f4e				 
0f4e			 
0f4e			 
0f4e					; TODO have a key for insert/overwrite mode???? 
0f4e c1					pop bc 
0f4f e1					pop hl 
0f50 71					ld (hl), c		; otherwise overwrite current char 
0f51					 
0f51			 
0f51			 
0f51			 
0f51 3a a7 fb				ld a, (input_cursor) 
0f54 3c					inc  a 		; TODO check overflow 
0f55 32 a7 fb				ld (input_cursor), a 
0f58			 
0f58 3a b4 fb				ld a, (input_at_cursor) 
0f5b 3c					inc a 
0f5c 32 b4 fb				ld (input_at_cursor), a 
0f5f			 
0f5f c3 7b 0d				jp .is1 
0f62			 
0f62			.endinput:	; TODO look for end of string 
0f62			 
0f62					; add trailing space for end of token 
0f62			 
0f62 2a b9 fb				ld hl, (input_start) 
0f65 3a ac fb				ld a,(input_len) 
0f68 cd 1d 0d				call addatohl 
0f6b 3e 20				ld a, ' ' 
0f6d 77					ld (hl),a 
0f6e					; TODO eof of parse marker 
0f6e			 
0f6e 23					inc hl 
0f6f 3e 00				ld a, 0 
0f71 77					ld (hl),a 
0f72			 
0f72			 
0f72 c9					ret 
0f73			 
0f73 .. 00		.iblank: db " ",0 
0f75			 
0f75			 
0f75 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f78 22 b9 fb				ld (input_start), hl 
0f7b 3e 01				ld a,1			; add cursor 
0f7d 77					ld (hl),a 
0f7e 23					inc hl 
0f7f 3e 00				ld a,0 
0f81 77					ld (hl),a 
0f82 22 bb fb				ld (input_ptr), hl 
0f85 7a					ld a,d 
0f86 32 b8 fb				ld (input_size), a 
0f89 3e 00				ld a,0 
0f8b 32 a7 fb				ld (input_cursor),a 
0f8e			.instr1:	 
0f8e			 
0f8e					; TODO do block cursor 
0f8e					; TODO switch cursor depending on the modifer key 
0f8e			 
0f8e					; update cursor shape change on key hold 
0f8e			 
0f8e 2a bb fb				ld hl, (input_ptr) 
0f91 2b					dec hl 
0f92 3a 56 fa				ld a,(cursor_shape) 
0f95 77					ld (hl), a 
0f96			 
0f96					; display entered text 
0f96 3a b6 fb				ld a,(input_at_pos) 
0f99 cd 87 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f9c ed 5b b9 fb	            	LD   de, (input_start) 
0fa0 cd 8f 66		            	CALL fLCD_Str       ;Display string pointed to by DE 
0fa3			 
0fa3 cd 69 67				call cin 
0fa6 fe 00				cp 0 
0fa8 28 e4				jr z, .instr1 
0faa			 
0faa					; proecess keyboard controls first 
0faa			 
0faa 2a bb fb				ld hl,(input_ptr) 
0fad			 
0fad fe 0d				cp KEY_CR	 ; pressing enter ends input 
0faf 28 5a				jr z, .instrcr 
0fb1			 
0fb1 fe 08				cp KEY_BS 	; back space 
0fb3 20 0f				jr nz, .instr2 
0fb5					; process back space 
0fb5			 
0fb5					; TODO stop back space if at start of string 
0fb5 2b					dec hl 
0fb6 2b					dec hl ; to over write cursor 
0fb7 3a 56 fa				ld a,(cursor_shape) 
0fba					;ld a,0 
0fba 77					ld (hl),a 
0fbb 23					inc hl 
0fbc 3e 20				ld a," " 
0fbe 77					ld (hl),a 
0fbf 22 bb fb				ld (input_ptr),hl 
0fc2					 
0fc2			 
0fc2 18 ca				jr .instr1 
0fc4			 
0fc4 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fc6 20 06				jr nz, .instr3 
0fc8 2b					dec hl 
0fc9 22 bb fb				ld (input_ptr),hl 
0fcc 18 c0				jr .instr1 
0fce				 
0fce fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fd0 20 06				jr nz, .instr4 
0fd2 23					inc hl 
0fd3 22 bb fb				ld (input_ptr),hl 
0fd6 18 b6				jr .instr1 
0fd8			 
0fd8 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fda 20 06				jr nz, .instr5 
0fdc 2b					dec hl 
0fdd 22 bb fb				ld (input_ptr),hl 
0fe0 18 ac				jr .instr1 
0fe2			 
0fe2 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fe4 20 06				jr nz, .instr6 
0fe6 2b					dec hl 
0fe7 22 bb fb				ld (input_ptr),hl 
0fea 18 a2				jr .instr1 
0fec fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fee 20 0b				jr nz, .instrnew 
0ff0			 
0ff0 21 a3 ef			ld hl, scratch 
0ff3 11 c9 f3			ld de, os_last_cmd 
0ff6 cd 14 10			call strcpy 
0ff9 18 93				jr .instr1 
0ffb			 
0ffb			 
0ffb			.instrnew:	; no special key pressed to see if we have room to store it 
0ffb			 
0ffb					; TODO do string size test 
0ffb			 
0ffb 2b					dec hl ; to over write cursor 
0ffc 77					ld (hl),a 
0ffd 23					inc hl 
0ffe 3a 56 fa				ld a,(cursor_shape) 
1001 77					ld (hl),a 
1002 23					inc hl 
1003 3e 00				ld a,0 
1005 77					ld (hl),a 
1006			 
1006 22 bb fb				ld (input_ptr),hl 
1009					 
1009 18 83				jr .instr1 
100b 2b			.instrcr:	dec hl		; remove cursor 
100c 3e 20				ld a,' '	; TODO add a trailing space for safety 
100e 77					ld (hl),a 
100f 23					inc hl 
1010 3e 00				ld a,0 
1012 77					ld (hl),a 
1013			 
1013			 
1013					; if at end of line scroll up    
1013					; TODO detecting only end of line 4 for scroll up  
1013			 
1013					;ld   
1013			 
1013 c9					ret 
1014			 
1014			 
1014			; strcpy hl = dest, de source 
1014			 
1014 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1015 b7			            OR   A              ;Null terminator? 
1016 c8			            RET  Z              ;Yes, so finished 
1017 1a					ld a,(de) 
1018 77					ld (hl),a 
1019 13			            INC  DE             ;Point to next character 
101a 23					inc hl 
101b 18 f7		            JR   strcpy       ;Repeat 
101d c9					ret 
101e			 
101e			 
101e			; TODO string_at  
101e			; pass string which starts with lcd offset address and then null term string 
101e			 
101e			; TODO string to dec 
101e			; TODO string to hex 
101e			; TODO byte to string hex 
101e			; TODO byte to string dec 
101e			 
101e			 
101e			 
101e			; from z80uartmonitor 
101e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101e			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
101e			; pass hl for where to put the text 
101e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101e c5			hexout:	PUSH BC 
101f f5					PUSH AF 
1020 47					LD B, A 
1021					; Upper nybble 
1021 cb 3f				SRL A 
1023 cb 3f				SRL A 
1025 cb 3f				SRL A 
1027 cb 3f				SRL A 
1029 cd 39 10				CALL tohex 
102c 77					ld (hl),a 
102d 23					inc hl	 
102e					 
102e					; Lower nybble 
102e 78					LD A, B 
102f e6 0f				AND 0FH 
1031 cd 39 10				CALL tohex 
1034 77					ld (hl),a 
1035 23					inc hl	 
1036					 
1036 f1					POP AF 
1037 c1					POP BC 
1038 c9					RET 
1039					 
1039			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1039			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1039			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1039			tohex: 
1039 e5					PUSH HL 
103a d5					PUSH DE 
103b 16 00				LD D, 0 
103d 5f					LD E, A 
103e 21 46 10				LD HL, .DATA 
1041 19					ADD HL, DE 
1042 7e					LD A, (HL) 
1043 d1					POP DE 
1044 e1					POP HL 
1045 c9					RET 
1046			 
1046			.DATA: 
1046 30					DEFB	30h	; 0 
1047 31					DEFB	31h	; 1 
1048 32					DEFB	32h	; 2 
1049 33					DEFB	33h	; 3 
104a 34					DEFB	34h	; 4 
104b 35					DEFB	35h	; 5 
104c 36					DEFB	36h	; 6 
104d 37					DEFB	37h	; 7 
104e 38					DEFB	38h	; 8 
104f 39					DEFB	39h	; 9 
1050 41					DEFB	41h	; A 
1051 42					DEFB	42h	; B 
1052 43					DEFB	43h	; C 
1053 44					DEFB	44h	; D 
1054 45					DEFB	45h	; E 
1055 46					DEFB	46h	; F 
1056			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1056			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1056			;;    subtract $30, if result > 9 then subtract $7 more 
1056			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1056			atohex: 
1056 d6 30				SUB $30 
1058 fe 0a				CP 10 
105a f8					RET M		; If result negative it was 0-9 so we're done 
105b d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
105d c9					RET		 
105e			 
105e			 
105e			 
105e			 
105e			; Get 2 ASCII characters as hex byte from pointer in hl 
105e			 
105e			BYTERD: 
105e 16 00			LD	D,00h		;Set up 
1060 cd 68 10			CALL	HEXCON		;Get byte and convert to hex 
1063 87				ADD	A,A		;First nibble so 
1064 87				ADD	A,A		;multiply by 16 
1065 87				ADD	A,A		; 
1066 87				ADD	A,A		; 
1067 57				LD	D,A		;Save hi nibble in D 
1068			HEXCON: 
1068 7e				ld a, (hl)		;Get next chr 
1069 23				inc hl 
106a d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
106c fe 0a			CP	00Ah		;Is it 0-9 ? 
106e 38 02			JR	C,NALPHA	;If so miss next bit 
1070 d6 07			SUB	007h		;Else convert alpha 
1072			NALPHA: 
1072 b2				OR	D		;Add hi nibble back 
1073 c9				RET			; 
1074			 
1074			 
1074			; 
1074			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1074			; Since the routines get_byte and therefore get_nibble are called, only valid 
1074			; characters (0-9a-f) are accepted. 
1074			; 
1074			;get_word        push    af 
1074			;                call    get_byte        ; Get the upper byte 
1074			;                ld      h, a 
1074			;                call    get_byte        ; Get the lower byte 
1074			;                ld      l, a 
1074			;                pop     af 
1074			;                ret 
1074			; 
1074			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1074			; the routine get_nibble is used only valid characters are accepted - the  
1074			; input routine only accepts characters 0-9a-f. 
1074			; 
1074 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1075 7e					ld a,(hl) 
1076 23					inc hl 
1077 cd 9c 10		                call    nibble2val      ; Get upper nibble 
107a cb 07		                rlc     a 
107c cb 07		                rlc     a 
107e cb 07		                rlc     a 
1080 cb 07		                rlc     a 
1082 47			                ld      b, a            ; Save upper four bits 
1083 7e					ld a,(hl) 
1084 cd 9c 10		                call    nibble2val      ; Get lower nibble 
1087 b0			                or      b               ; Combine both nibbles 
1088 c1			                pop     bc              ; Restore B (and C) 
1089 c9			                ret 
108a			; 
108a			; Get a hexadecimal digit from the serial line. This routine blocks until 
108a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
108a			; to the serial line interface. The lower 4 bits of A contain the value of  
108a			; that particular digit. 
108a			; 
108a			;get_nibble      ld a,(hl)           ; Read a character 
108a			;                call    to_upper        ; Convert to upper case 
108a			;                call    is_hex          ; Was it a hex digit? 
108a			;                jr      nc, get_nibble  ; No, get another character 
108a			 ;               call    nibble2val      ; Convert nibble to value 
108a			 ;               call    print_nibble 
108a			 ;               ret 
108a			; 
108a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
108a			; A valid hexadecimal digit is denoted by a set C flag. 
108a			; 
108a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
108a			;                ret     nc              ; Yes 
108a			;                cp      '0'             ; Less than '0'? 
108a			;                jr      nc, is_hex_1    ; No, continue 
108a			;                ccf                     ; Complement carry (i.e. clear it) 
108a			;                ret 
108a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
108a			;                ret     c               ; Yes 
108a			;                cp      'A'             ; Less than 'A'? 
108a			;                jr      nc, is_hex_2    ; No, continue 
108a			;                ccf                     ; Yes - clear carry and return 
108a			;                ret 
108a			;is_hex_2        scf                     ; Set carry 
108a			;                ret 
108a			; 
108a			; Convert a single character contained in A to upper case: 
108a			; 
108a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
108c d8			                ret     c 
108d fe 7b		                cp      'z' + 1         ; > 'z'? 
108f d0			                ret     nc              ; Nothing to do, either 
1090 e6 5f		                and     $5f             ; Convert to upper case 
1092 c9			                ret 
1093			 
1093			 
1093			to_lower: 
1093			 
1093			   ; if char is in [A-Z] make it lower case 
1093			 
1093			   ; enter : a = char 
1093			   ; exit  : a = lower case char 
1093			   ; uses  : af 
1093			 
1093 fe 41		   cp 'A' 
1095 d8			   ret c 
1096			    
1096 fe 5b		   cp 'Z'+1 
1098 d0			   ret nc 
1099			    
1099 f6 20		   or $20 
109b c9			   ret 
109c			 
109c			; 
109c			; Expects a hexadecimal digit (upper case!) in A and returns the 
109c			; corresponding value in A. 
109c			; 
109c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
109e 38 02		                jr      c, nibble2val_1 ; Yes 
10a0 d6 07		                sub     7               ; Adjust for A-F 
10a2 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
10a4 e6 0f		                and     $f              ; Only return lower 4 bits 
10a6 c9			                ret 
10a7			; 
10a7			; Print_nibble prints a single hex nibble which is contained in the lower  
10a7			; four bits of A: 
10a7			; 
10a7			;print_nibble    push    af              ; We won't destroy the contents of A 
10a7			;                and     $f              ; Just in case... 
10a7			;                add     a, '0'             ; If we have a digit we are done here. 
10a7			;                cp      '9' + 1         ; Is the result > 9? 
10a7			;                jr      c, print_nibble_1 
10a7			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
10a7			;print_nibble_1  call    putc            ; Print the nibble and 
10a7			;                pop     af              ; restore the original value of A 
10a7			;                ret 
10a7			;; 
10a7			;; Send a CR/LF pair: 
10a7			; 
10a7			;crlf            push    af 
10a7			;                ld      a, cr 
10a7			;                call    putc 
10a7			;                ld      a, lf 
10a7			;                call    putc 
10a7			;                pop     af 
10a7			;                ret 
10a7			; 
10a7			; Print_word prints the four hex digits of a word to the serial line. The  
10a7			; word is expected to be in HL. 
10a7			; 
10a7			;print_word      push    hl 
10a7			;                push    af 
10a7			;                ld      a, h 
10a7			;                call    print_byte 
10a7			;                ld      a, l 
10a7			;                call    print_byte 
10a7			;                pop     af 
10a7			;                pop     hl 
10a7			;                ret 
10a7			; 
10a7			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
10a7			; The byte to be printed is expected to be in A. 
10a7			; 
10a7			;print_byte      push    af              ; Save the contents of the registers 
10a7			;                push    bc 
10a7			;                ld      b, a 
10a7			;                rrca 
10a7			;                rrca 
10a7			;                rrca 
10a7			;                rrca 
10a7			;                call    print_nibble    ; Print high nibble 
10a7			;                ld      a, b 
10a7			;                call    print_nibble    ; Print low nibble 
10a7			;                pop     bc              ; Restore original register contents 
10a7			;                pop     af 
10a7			;                ret 
10a7			 
10a7			 
10a7			 
10a7			 
10a7			 
10a7			fourehexhl:  
10a7 7e				ld a,(hl) 
10a8 cd 56 10			call atohex 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af cb 3f				SRL A 
10b1 cb 3f				SRL A 
10b3 47				ld b, a 
10b4 23				inc hl 
10b5 7e				ld a,(hl) 
10b6 23				inc hl 
10b7 cd 56 10			call atohex 
10ba 80				add b 
10bb 57				ld d,a 
10bc 7e				ld a,(hl) 
10bd cd 56 10			call atohex 
10c0 cb 3f				SRL A 
10c2 cb 3f				SRL A 
10c4 cb 3f				SRL A 
10c6 cb 3f				SRL A 
10c8 47				ld b, a 
10c9 23				inc hl 
10ca 7e				ld a,(hl) 
10cb 23				inc hl 
10cc cd 56 10			call atohex 
10cf 80				add b 
10d0 5f				ld e, a 
10d1 d5				push de 
10d2 e1				pop hl 
10d3 c9				ret 
10d4			 
10d4			; pass hl. returns z set if the byte at hl is a digit 
10d4			;isdigithl:  
10d4			;	push bc 
10d4			;	ld a,(hl) 
10d4			;	cp ':' 
10d4			;	jr nc, .isdf 		; > 
10d4			;	cp '0' 
10d4			;	jr c, .isdf		; < 
10d4			; 
10d4			;	; TODO find a better way to set z 
10d4			; 
10d4			;	ld b,a 
10d4			;	cp b 
10d4			;	pop bc 
10d4			;	ret 
10d4			; 
10d4			;.isdf:	; not digit so clear z 
10d4			; 
10d4			;	; TODO find a better way to unset z 
10d4			; 
10d4			;	ld b,a 
10d4			;	inc b 
10d4			;	cp b 
10d4			; 
10d4			;	pop bc 
10d4			;	ret 
10d4				 
10d4				 
10d4			 
10d4			 
10d4			; pass hl as the four byte address to load 
10d4			 
10d4			get_word_hl:  
10d4 e5				push hl 
10d5 cd 74 10			call get_byte 
10d8				 
10d8 47				ld b, a 
10d9			 
10d9 e1				pop hl 
10da 23				inc hl 
10db 23				inc hl 
10dc			 
10dc			; TODO not able to handle a-f  
10dc 7e				ld a,(hl) 
10dd			;	;cp ':' 
10dd			;	cp 'g' 
10dd			;	jr nc, .single_byte_hl 		; > 
10dd			;	cp 'G' 
10dd			;	jr nc, .single_byte_hl 		; > 
10dd			;	cp '0' 
10dd			;	jr c, .single_byte_hl		; < 
10dd			 
10dd				;call isdigithl 
10dd fe 00			cp 0 
10df 28 06			jr z, .single_byte_hl 
10e1			 
10e1			.getwhln:   ; hex word so get next byte 
10e1			 
10e1 cd 74 10			call get_byte 
10e4 6f				ld l, a 
10e5 60				ld h,b 
10e6 c9				ret 
10e7 68			.single_byte_hl:   ld l,b 
10e8 26 00				ld h,0 
10ea c9					ret 
10eb			 
10eb			 
10eb			 
10eb			 
10eb 21 ee 19			ld hl,asc+1 
10ee			;	ld a, (hl) 
10ee			;	call nibble2val 
10ee cd 74 10			call get_byte 
10f1			 
10f1			;	call fourehexhl 
10f1 32 d7 ef			ld (scratch+52),a 
10f4				 
10f4 21 d5 ef			ld hl,scratch+50 
10f7 22 c6 f2			ld (os_cur_ptr),hl 
10fa			 
10fa c9				ret 
10fb			 
10fb			 
10fb			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10fb			 
10fb			; Decimal Unsigned Version 
10fb			 
10fb			;Number in a to decimal ASCII 
10fb			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10fb			;Example: display a=56 as "056" 
10fb			;input: a = number 
10fb			;Output: a=0,value of a in the screen 
10fb			;destroys af,bc (don't know about hl and de) 
10fb			DispAToASCII: 
10fb 0e 9c			ld	c,-100 
10fd cd 07 11			call	.Na1 
1100 0e f6			ld	c,-10 
1102 cd 07 11			call	.Na1 
1105 0e ff			ld	c,-1 
1107 06 2f		.Na1:	ld	b,'0'-1 
1109 04			.Na2:	inc	b 
110a 81				add	a,c 
110b 38 fc			jr	c,.Na2 
110d 91				sub	c		;works as add 100/10/1 
110e f5				push af		;safer than ld c,a 
110f 78				ld	a,b		;char is in b 
1110			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1110 f1				pop af		;safer than ld a,c 
1111 c9				ret 
1112			 
1112			; Decimal Signed Version 
1112			 
1112			; DispA 
1112			; -------------------------------------------------------------- 
1112			; Converts a signed integer value to a zero-terminated ASCII 
1112			; string representative of that value (using radix 10). 
1112			; -------------------------------------------------------------- 
1112			; INPUTS: 
1112			;     HL     Value to convert (two's complement integer). 
1112			;     DE     Base address of string destination. (pointer). 
1112			; -------------------------------------------------------------- 
1112			; OUTPUTS: 
1112			;     None 
1112			; -------------------------------------------------------------- 
1112			; REGISTERS/MEMORY DESTROYED 
1112			; AF HL 
1112			; -------------------------------------------------------------- 
1112			 
1112			;DispHLToASCII: 
1112			;   push    de 
1112			;   push    bc 
1112			; 
1112			;; Detect sign of HL. 
1112			;    bit    7, h 
1112			;    jr     z, ._DoConvert 
1112			; 
1112			;; HL is negative. Output '-' to string and negate HL. 
1112			;    ld     a, '-' 
1112			;    ld     (de), a 
1112			;    inc    de 
1112			; 
1112			;; Negate HL (using two's complement) 
1112			;    xor    a 
1112			;    sub    l 
1112			;    ld     l, a 
1112			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1112			;    sbc    a, h 
1112			;    ld     h, a 
1112			; 
1112			;; Convert HL to digit characters 
1112			;._DoConvert: 
1112			;    ld     b, 0     ; B will count character length of number 
1112			;-   ld     a, 10 
1112			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1112			;    push   af 
1112			;    inc    b 
1112			;    ld     a, h 
1112			;    or     l 
1112			;    jr     nz, - 
1112			; 
1112			;; Retrieve digits from stack 
1112			;-   pop    af 
1112			;    or     $30 
1112			;    ld     (de), a 
1112			;    inc    de 
1112			;    djnz   - 
1112			; 
1112			;; Terminate string with NULL 
1112			;    xor    a 
1112			;    ld     (de), a 
1112			; 
1112			;    pop    bc 
1112			;    pop    de 
1112			;    ret 
1112			 
1112			;Comments 
1112			; 
1112			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1112			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1112			;    Note that the output string will not be fixed-width. 
1112			; 
1112			;Example Usage 
1112			; 
1112			;    ld    hl, -1004 
1112			;    ld    de, OP1 
1112			;    call  DispA 
1112			;    ld    hl, OP1 
1112			;    syscall  PutS 
1112			 
1112			 
1112			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1112			 
1112			 
1112			;Converts an ASCII string to an unsigned 16-bit integer 
1112			;Quits when it reaches a non-decimal digit 
1112			 
1112			string_to_uint16: 
1112			atoui_16: 
1112			;Input: 
1112			;     DE points to the string 
1112			;Outputs: 
1112			;     HL is the result 
1112			;     A is the 8-bit value of the number 
1112			;     DE points to the byte after the number 
1112			;Destroys: 
1112			;     BC 
1112			;       if the string is non-empty, BC is HL/10 
1112			;Size:  24 bytes 
1112			;Speed: 42+d(104+{0,9}) 
1112			;       d is the number of digits in the number 
1112			;       max is 640 cycles for a 5 digit number 
1112			;Assuming no leading zeros: 
1112			;1 digit:  146cc 
1112			;2 digit:  250cc 
1112			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1112			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1112			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1112			;avg: 544.81158447265625cc (544+13297/16384) 
1112			;=============================================================== 
1112 21 00 00		  ld hl,0 
1115			.u16a: 
1115 1a			  ld a,(de) 
1116 d6 30		  sub 30h 
1118 fe 0a		  cp 10 
111a d0			  ret nc 
111b 13			  inc de 
111c 44			  ld b,h 
111d 4d			  ld c,l 
111e 29			  add hl,hl 
111f 29			  add hl,hl 
1120 09			  add hl,bc 
1121 29			  add hl,hl 
1122 85			  add a,l 
1123 6f			  ld l,a 
1124 30 ef		  jr nc,.u16a 
1126 24			  inc h 
1127 c3 15 11		  jp .u16a 
112a			 
112a			 
112a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
112a			 
112a			;written by Zeda 
112a			;Converts a 16-bit unsigned integer to an ASCII string. 
112a			 
112a			uitoa_16: 
112a			;Input: 
112a			;   DE is the number to convert 
112a			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
112a			;Output: 
112a			;   HL points to the null-terminated ASCII string 
112a			;      NOTE: This isn't necessarily the same as the input HL. 
112a d5			  push de 
112b c5			  push bc 
112c f5			  push af 
112d eb			  ex de,hl 
112e			 
112e 01 f0 d8		  ld bc,-10000 
1131 3e 2f		  ld a,'0'-1 
1133 3c			  inc a 
1134 09			  add hl,bc  
1135 38 fc		   jr c,$-2 
1137 12			  ld (de),a 
1138 13			  inc de 
1139			 
1139 01 e8 03		  ld bc,1000 
113c 3e 3a		  ld a,'9'+1 
113e 3d			  dec a  
113f 09			  add hl,bc  
1140 30 fc		   jr nc,$-2 
1142 12			  ld (de),a 
1143 13			  inc de 
1144			 
1144 01 9c ff		  ld bc,-100 
1147 3e 2f		  ld a,'0'-1 
1149 3c			  inc a  
114a 09			  add hl,bc  
114b 38 fc		   jr c,$-2 
114d 12			  ld (de),a 
114e 13			  inc de 
114f			 
114f 7d			  ld a,l 
1150 26 3a		  ld h,'9'+1 
1152 25			  dec h  
1153 c6 0a		  add a,10  
1155 30 fb		   jr nc,$-3 
1157 c6 30		  add a,'0' 
1159 eb			  ex de,hl 
115a 72			  ld (hl),d 
115b 23			  inc hl 
115c 77			  ld (hl),a 
115d 23			  inc hl 
115e 36 00		  ld (hl),0 
1160			 
1160			;Now strip the leading zeros 
1160 0e fa		  ld c,-6 
1162 09			  add hl,bc 
1163 3e 30		  ld a,'0' 
1165 23			  inc hl  
1166 be			  cp (hl)  
1167 28 fc		  jr z,$-2 
1169			 
1169			;Make sure that the string is non-empty! 
1169 7e			  ld a,(hl) 
116a b7			  or a 
116b 20 01		  jr nz,.atoub 
116d 2b			  dec hl 
116e			.atoub: 
116e			 
116e f1			  pop af 
116f c1			  pop bc 
1170 d1			  pop de 
1171 c9			  ret 
1172			 
1172			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1172			 
1172			toUpper: 
1172			;A is the char. 
1172			;If A is a lowercase letter, this sets it to the matching uppercase 
1172			;18cc or 30cc or 41cc 
1172			;avg: 26.75cc 
1172 fe 61		  cp 'a' 
1174 d8			  ret c 
1175 fe 7b		  cp 'z'+1 
1177 d0			  ret nc 
1178 d6 20		  sub 'a'-'A' 
117a c9			  ret 
117b			 
117b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
117b			 
117b			; String Length 
117b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
117b			 
117b			; Get the length of the null-terminated string starting at $8000 hl 
117b			;    LD     HL, $8000 
117b			 
117b			strlenz: 
117b			 
117b af			    XOR    A               ; Zero is the value we are looking for. 
117c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
117d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
117e			                           ; 65, 536 bytes (the entire addressable memory space). 
117e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1180			 
1180			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1180 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1181 6f			    LD     L, A             ; number of bytes 
1182 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1184 2b			    DEC    HL              ; Compensate for null. 
1185 c9				ret 
1186			 
1186			; Get the length of the A terminated string starting at $8000 hl 
1186			;    LD     HL, $8000 
1186			 
1186			strlent: 
1186			 
1186			                  ; A is the value we are looking for. 
1186 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1188 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
118a			                           ; 65, 536 bytes (the entire addressable memory space). 
118a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
118c			 
118c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
118c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
118e 2e 00		    LD     L, 0             ; number of bytes 
1190 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1192 2b			    DEC    HL              ; Compensate for null. 
1193 c9				ret 
1194			 
1194			 
1194			;Comparing Strings 
1194			 
1194			;IN    HL     Address of string1. 
1194			;      DE     Address of string2. 
1194			 
1194			; doc given but wrong??? 
1194			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1194			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1194			; tested 
1194			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1194			 
1194			strcmp_old: 
1194 e5			    PUSH   HL 
1195 d5			    PUSH   DE 
1196			 
1196 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1197 be			    CP     (HL)            ; (want to minimize work). 
1198 38 01		    JR     C, Str1IsBigger 
119a 7e			    LD     A, (HL) 
119b			 
119b			Str1IsBigger: 
119b 4f			    LD     C, A             ; Put length in BC 
119c 06 00		    LD     B, 0 
119e 13			    INC    DE              ; Increment pointers to meat of string. 
119f 23			    INC    HL 
11a0			 
11a0			CmpLoop: 
11a0 1a			    LD     A, (DE)          ; Compare bytes. 
11a1 ed a1		    CPI 
11a3 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
11a5 13			    INC    DE              ; Update pointer. 
11a6 ea a0 11		    JP     PE, CmpLoop 
11a9			 
11a9 d1			    POP    DE 
11aa e1			    POP    HL 
11ab 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
11ac be			    CP     (HL) 
11ad c9			    RET 
11ae			 
11ae			NoMatch: 
11ae 2b			    DEC    HL 
11af be			    CP     (HL)            ; Compare again to affect carry. 
11b0 d1			    POP    DE 
11b1 e1			    POP    HL 
11b2 c9			    RET 
11b3			 
11b3			;; test strmp 
11b3			; 
11b3			;ld de, .str1 
11b3			;ld hl, .str2 
11b3			;call strcmp 
11b3			;jr z, .z1 
11b3			;;this 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "NZ1" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;.z1: 
11b3			; 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "ZZ1" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			; 
11b3			;ld de, .str1 
11b3			;ld hl, .str1 
11b3			;call strcmp 
11b3			;jr z, .z2 
11b3			;;this 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "NZ2" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;.z2: 
11b3			; 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "ZZ2" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			; 
11b3			;ld de, .str1 
11b3			;ld hl, .str2 
11b3			;call strcmp 
11b3			;jr c, .c1 
11b3			; 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "Nc1" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;.c1: 
11b3			;;this 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "cc1" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			; 
11b3			;ld de, .str1 
11b3			;ld hl, .str1 
11b3			;call strcmp 
11b3			;jr c, .c2 
11b3			;;this 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "Nc2" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;.c2: 
11b3			; 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "cc2" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;	NEXTW 
11b3			;.str1:   db "string1",0 
11b3			;.str2:   db "string2",0 
11b3			 
11b3			; only care about direct match or not 
11b3			; hl and de strings 
11b3			; zero set if the same 
11b3			 
11b3			strcmp: 
11b3 1a				ld a, (de) 
11b4 be				cp (hl) 
11b5 28 02			jr z, .ssame 
11b7 b7				or a 
11b8 c9				ret 
11b9			 
11b9			.ssame:  
11b9 fe 00			cp 0 
11bb c8				ret z 
11bc			 
11bc 23				inc hl 
11bd 13				inc de 
11be 18 f3			jr strcmp 
11c0				 
11c0				 
11c0			 
11c0			 
11c0			 
11c0			 
11c0			; eof 
11c0			 
11c0			 
11c0			 
11c0			 
11c0			 
11c0			 
# End of file firmware_strings.asm
11c0			include "firmware_memory.asm"   ; malloc and free  
11c0			 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0			.mallocsize: db "Wants malloc >256",0 
11c0			.mallocasize: db "MALLOC gives >256",0 
11c0			.malloczero: db "MALLOC gives zero",0 
11c0			 
11c0			malloc_guard_zerolen: 
11c0				push hl 
11c0				push de 
11c0				push af 
11c0			 
11c0				ld de, 0 
11c0			        call cmp16 
11c0				jr nz, .lowalloz 
11c0			 
11c0				push hl 
11c0				push de 
11c0					ld hl, display_fb0 
11c0					ld (display_fb_active), hl 
11c0				call clear_display 
11c0				ld a, 0 
11c0				ld de, .malloczero 
11c0				call str_at_display 
11c0				call update_display 
11c0				call delay1s 
11c0				call delay1s 
11c0				ld a, 0 
11c0				ld (os_view_disable), a 
11c0			 
11c0				pop de 
11c0				pop hl 
11c0			 
11c0				 
11c0			 
11c0				CALLMONITOR 
11c0			.lowalloz: 
11c0			 
11c0			 
11c0				pop af 
11c0				pop de 
11c0				pop hl 
11c0			ret 
11c0			 
11c0			malloc_guard_entry: 
11c0				push hl 
11c0				push de 
11c0				push af 
11c0			 
11c0			 	or a      ;clear carry flag 
11c0				push hl 
11c0				ld de, 255 
11c0				sbc hl, de 
11c0				jr c, .lowalloc 
11c0			 
11c0				push de 
11c0					ld hl, display_fb0 
11c0					ld (display_fb_active), hl 
11c0				call clear_display 
11c0				ld a, 0 
11c0				ld de, .mallocsize 
11c0				call str_at_display 
11c0				call update_display 
11c0				call delay1s 
11c0				call delay1s 
11c0				ld a, 0 
11c0				ld (os_view_disable), a 
11c0			 
11c0				pop de 
11c0				pop hl 
11c0			 
11c0				 
11c0			 
11c0				CALLMONITOR 
11c0				jr .lowdone 
11c0			.lowalloc: 
11c0			 
11c0			 
11c0				pop hl 
11c0			.lowdone:	pop af 
11c0				pop de 
11c0				pop hl 
11c0			ret 
11c0			 
11c0			malloc_guard_exit: 
11c0				push hl 
11c0				push de 
11c0				push af 
11c0			 
11c0			 	or a      ;clear carry flag 
11c0				push hl 
11c0				ld de, 255 
11c0				sbc hl, de 
11c0				jr c, .lowallocx 
11c0			 
11c0				push de 
11c0					ld hl, display_fb0 
11c0					ld (display_fb_active), hl 
11c0				call clear_display 
11c0				ld a, 0 
11c0				ld de, .mallocasize 
11c0				call str_at_display 
11c0				call update_display 
11c0				call delay1s 
11c0				call delay1s 
11c0				ld a, 0 
11c0				ld (os_view_disable), a 
11c0				pop de 
11c0				pop hl 
11c0			 
11c0				CALLMONITOR 
11c0				jr .lowdonex 
11c0			.lowallocx: 
11c0			 
11c0				pop hl 
11c0			.lowdonex:	pop af 
11c0				pop de 
11c0				pop hl 
11c0			ret 
11c0			endif 
11c0			 
11c0			if MALLOC_2 
11c0			; Z80 Malloc and Free Functions 
11c0			 
11c0			; Malloc Function: 
11c0			; Input: 
11c0			;   HL: Size of block to allocate 
11c0			; Output: 
11c0			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11c0			 
11c0			malloc: 
11c0				 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0			call malloc_guard_entry 
11c0			endif 
11c0			 
11c0			 
11c0			 
11c0			 
11c0					if DEBUG_FORTH_MALLOC 
11c0						DMARK "mal" 
11c0						CALLMONITOR 
11c0					endif 
11c0			    push af            ; Save AF register 
11c0			    ld a, l            ; Load low byte of size into A 
11c0			    or h               ; Check if size is zero 
11c0			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11c0			 
11c0			    ; Allocate memory 
11c0			    ld hl, (heap_start) ; Load start of heap into HL 
11c0					if DEBUG_FORTH_MALLOC 
11c0						DMARK "ma1" 
11c0						CALLMONITOR 
11c0					endif 
11c0			    call malloc_internal ; Call internal malloc function 
11c0			    pop af             ; Restore AF register 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0			call malloc_guard_exit 
11c0			call malloc_guard_zerolen 
11c0			endif 
11c0			    ret                ; Return 
11c0			 
11c0			; Free Function: 
11c0			; Input: 
11c0			;   HL: Pointer to memory block to free 
11c0			; Output: 
11c0			;   None 
11c0			 
11c0			free: 
11c0			    push af            ; Save AF register 
11c0			    ld a, l            ; Load low byte of pointer into A 
11c0			    or h               ; Check if pointer is NULL 
11c0			    jp z, free_exit    ; If pointer is NULL, exit 
11c0			 
11c0			    ; Free memory 
11c0			    ld hl, (heap_start) ; Load start of heap into HL 
11c0			    call free_internal  ; Call internal free function 
11c0			    pop af             ; Restore AF register 
11c0			    ret                ; Return 
11c0			 
11c0			; Internal Malloc Function: 
11c0			; Input: 
11c0			;   HL: Size of block to allocate 
11c0			; Output: 
11c0			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11c0			 
11c0			malloc_internal: 
11c0			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11c0			    add hl, bc         ; Add management overhead to requested size 
11c0			    ex de, hl          ; Save total size in DE, and keep it in HL 
11c0					if DEBUG_FORTH_MALLOC 
11c0						DMARK "ma2" 
11c0						CALLMONITOR 
11c0					endif 
11c0			 
11c0			    ; Search for free memory block 
11c0			    ld de, (heap_end)  ; Load end of heap into DE 
11c0			    ld bc, 0           ; Initialize counter 
11c0			 
11c0					if DEBUG_FORTH_MALLOC 
11c0						DMARK "ma2" 
11c0						CALLMONITOR 
11c0					endif 
11c0			malloc_search_loop: 
11c0			    ; Check if current block is free 
11c0			    ld a, (hl)         ; Load current block's status (free or used) 
11c0			    cp 0               ; Compare with zero (free) 
11c0			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11c0			 
11c0			    ; Check if current block is large enough 
11c0			    ld a, (hl+1)       ; Load high byte of block size 
11c0			    cp l               ; Compare with low byte of requested size 
11c0			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11c0			 
11c0			    ld a, (hl+2)       ; Load low byte of block size 
11c0			    cp h               ; Compare with high byte of requested size 
11c0			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11c0			 
11c0			    ; Mark block as used 
11c0			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11c0			 
11c0			    ; Calculate remaining space in block 
11c0			    ld bc, 0           ; Clear BC 
11c0			    add hl, bc         ; Increment HL to point to start of data block 
11c0			    add hl, de         ; HL = HL + DE (total size) 
11c0			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11c0			    add hl, bc         ; Add management overhead to start of data block 
11c0			 
11c0			    ; Save pointer to allocated block in HL 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0						DMARK "ma5" 
11c0			call malloc_guard_exit 
11c0			call malloc_guard_zerolen 
11c0			endif 
11c0			    ret 
11c0			 
11c0			malloc_skip_block_check: 
11c0			    ; Move to the next block 
11c0			    ld bc, 3           ; Size of management overhead 
11c0			    add hl, bc         ; Move to the next block 
11c0			    inc de             ; Increment counter 
11c0			 
11c0			    ; Check if we have reached the end of heap 
11c0			    ld a, e            ; Load low byte of heap end address 
11c0			    cp (hl)            ; Compare with low byte of current address 
11c0			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11c0			    ld a, d            ; Load high byte of heap end address 
11c0			    cp 0               ; Check if it's zero (end of memory) 
11c0			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11c0			 
11c0			    ; If we reached here, allocation failed 
11c0			    xor a              ; Set result to NULL 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0						DMARK "ma6" 
11c0			call malloc_guard_exit 
11c0			call malloc_guard_zerolen 
11c0			endif 
11c0			    ret 
11c0			malloc_exit: 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0						DMARK "ma7" 
11c0			call malloc_guard_exit 
11c0			call malloc_guard_zerolen 
11c0			endif 
11c0			    ret 
11c0			 
11c0			; Internal Free Function: 
11c0			; Input: 
11c0			;   HL: Pointer to memory block to free 
11c0			; Output: 
11c0			;   None 
11c0			 
11c0			free_internal: 
11c0			    ld de, (heap_start) ; Load start of heap into DE 
11c0			    ld bc, 0            ; Initialize counter 
11c0			 
11c0			free_search_loop: 
11c0			    ; Check if current block contains the pointer 
11c0			    ld a, l             ; Load low byte of pointer 
11c0			    cp (hl+1)           ; Compare with high byte of current block's address 
11c0			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11c0			    ld a, h             ; Load high byte of pointer 
11c0			    cp (hl+2)           ; Compare with low byte of current block's address 
11c0			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11c0			 
11c0			    ; Mark block as free 
11c0			    ld (hl), 0          ; Set status byte to indicate free block 
11c0			    ret                 ; Return 
11c0			 
11c0			free_skip_block_check: 
11c0			    ; Move to the next block 
11c0			    ld bc, 3            ; Size of management overhead 
11c0			    add hl, bc          ; Move to the next block 
11c0			    inc de              ; Increment counter 
11c0			 
11c0			    ; Check if we have reached the end of heap 
11c0			    ld a, e             ; Load low byte of heap end address 
11c0			    cp (hl)             ; Compare with low byte of current address 
11c0			    jr nz, free_search_loop  ; If not equal, continue searching 
11c0			    ld a, d             ; Load high byte of heap end address 
11c0			    cp 0                ; Check if it's zero (end of memory) 
11c0			    jr nz, free_search_loop  ; If not zero, continue searching 
11c0			 
11c0			    ; If we reached here, pointer is not found in heap 
11c0			    ret 
11c0			 
11c0			free_exit: 
11c0			    ret                 ; Return 
11c0			 
11c0			; Define heap start and end addresses 
11c0			;heap_start:    .dw 0xC000   ; Start of heap 
11c0			;heap_end:      .dw 0xE000   ; End of heap 
11c0			 
11c0			endif 
11c0			 
11c0			 
11c0			if MALLOC_1 
11c0			 
11c0			 
11c0			 
11c0			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11c0			 
11c0			;moved to firmware.asm 
11c0			;heap_start        .equ  0x9000      ; Starting address of heap 
11c0			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11c0			 
11c0			;      .org 0 
11c0			;      jp    main 
11c0			 
11c0			 
11c0			;      .org  0x100 
11c0			;main: 
11c0			;      ld    HL, 0x8100 
11c0			;      ld    SP, HL 
11c0			; 
11c0			;      call  heap_init 
11c0			; 
11c0			;      ; Make some allocations 
11c0			;      ld    HL, 12 
11c0			;      call  malloc            ; Allocates 0x9004 
11c0			; 
11c0			;      ld    HL, 12 
11c0			;      call  malloc            ; Allocates 0x9014 
11c0			; 
11c0			;      ld    HL, 12 
11c0			;      call  malloc            ; Allocates 0x9024 
11c0			; 
11c0			;      ; Free some allocations 
11c0			;      ld    HL, 0x9014 
11c0			;      call  free 
11c0			; 
11c0			;      ld    HL, 0x9004 
11c0			;      call  free 
11c0			; 
11c0			;      ld    HL, 0x9024 
11c0			;      call  free 
11c0			; 
11c0			; 
11c0			;      halt 
11c0			 
11c0			 
11c0			;------------------------------------------------------------------------------ 
11c0			;     heap_init                                                               : 
11c0			;                                                                             : 
11c0			; Description                                                                 : 
11c0			;     Initialise the heap and make it ready for malloc and free operations.   : 
11c0			;                                                                             : 
11c0			;     The heap is maintained as a linked list, starting with an initial       : 
11c0			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11c0			;     the first free block in the heap. Each block then points to the next    : 
11c0			;     free block within the heap, and the free list ends at the first block   : 
11c0			;     with a null pointer to the next free block.                             : 
11c0			;                                                                             : 
11c0			; Parameters                                                                  : 
11c0			;     Inputs are compile-time only. Two defines which specify the starting    : 
11c0			;     address of the heap and its size are required, along with a memory      : 
11c0			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11c0			;     principally stores a pointer to the first free block in the heap.       : 
11c0			;                                                                             : 
11c0			; Returns                                                                     : 
11c0			;     Nothing                                                                 : 
11c0			;------------------------------------------------------------------------------ 
11c0			heap_init: 
11c0 e5			      push  HL 
11c1			 
11c1			      ; Initialise free list struct 
11c1 21 0e 80		      ld    HL, heap_start 
11c4 22 0a 80		      ld    (free_list), HL 
11c7 21 00 00		      ld    HL, 0 
11ca 22 0c 80		      ld    (free_list+2), HL 
11cd			 
11cd			      ; Insert first free block at bottom of heap, consumes entire heap 
11cd 21 0a 80		      ld    HL, heap_start+heap_size-4 
11d0 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11d3 21 fc ff		      ld    HL, heap_size-4 
11d6 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11d9			 
11d9			      ; Insert end of free list block at top of heap - two null words will 
11d9			      ; terminate the free list 
11d9 21 00 00		      ld    HL, 0 
11dc 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11df 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11e2			 
11e2 e1			      pop   HL 
11e3			 
11e3 c9			      ret 
11e4			 
11e4			 
11e4			;------------------------------------------------------------------------------ 
11e4			;     malloc                                                                  : 
11e4			;                                                                             : 
11e4			; Description                                                                 : 
11e4			;     Allocates the wanted space from the heap and returns the address of the : 
11e4			;     first useable byte of the allocation.                                   : 
11e4			;                                                                             : 
11e4			;     Allocations can happen in one of two ways:                              : 
11e4			;                                                                             : 
11e4			;     1. A free block may be found which is the exact size wanted. In this    : 
11e4			;        case the block is removed from the free list and retuedn to the      : 
11e4			;        caller.                                                              : 
11e4			;     2. A free block may be found which is larger than the size wanted. In   : 
11e4			;        this case, the larger block is split into two. The first portion of  : 
11e4			;        this block will become the requested space by the malloc call and    : 
11e4			;        is returned to the caller. The second portion becomes a new free     : 
11e4			;        block, and the free list is adjusted to maintain continuity via this : 
11e4			;        newly created block.                                                 : 
11e4			;                                                                             : 
11e4			;     malloc does not set any initial value in the allocated space, the       : 
11e4			;     caller is required to do this as required.                              : 
11e4			;                                                                             : 
11e4			;     This implementation of malloc uses the stack exclusively, and is        : 
11e4			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11e4			;     advisable to disable interrupts before calling malloc, and recommended  : 
11e4			;     to avoid the use of malloc inside ISRs in general.                      : 
11e4			;                                                                             : 
11e4			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11e4			;                                                                             : 
11e4			; Parameters                                                                  : 
11e4			;     HL  Number of bytes wanted                                              : 
11e4			;                                                                             : 
11e4			; Returns                                                                     : 
11e4			;     HL  Address of the first useable byte of the allocation                 : 
11e4			;                                                                             : 
11e4			; Flags                                                                       : 
11e4			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11e4			;                                                                             : 
11e4			; Stack frame                                                                 : 
11e4			;       |             |                                                       : 
11e4			;       +-------------+                                                       : 
11e4			;       |     BC      |                                                       : 
11e4			;       +-------------+                                                       : 
11e4			;       |     DE      |                                                       : 
11e4			;       +-------------+                                                       : 
11e4			;       |     IX      |                                                       : 
11e4			;       +-------------+                                                       : 
11e4			;       |  prev_free  |                                                       : 
11e4			;   +4  +-------------+                                                       : 
11e4			;       |  this_free  |                                                       : 
11e4			;   +2  +-------------+                                                       : 
11e4			;       |  next_free  |                                                       : 
11e4			;   +0  +-------------+                                                       : 
11e4			;       |             |                                                       : 
11e4			;                                                                             : 
11e4			;------------------------------------------------------------------------------ 
11e4			 
11e4			 
11e4			;malloc: 
11e4			; 
11e4			;	SAVESP ON 1 
11e4			; 
11e4			;	call malloc_code 
11e4			; 
11e4			;	CHECKSP ON 1 
11e4			;	ret 
11e4			 
11e4			 
11e4			malloc: 
11e4 c5			      push  BC 
11e5 d5			      push  DE 
11e6 dd e5		      push  IX 
11e8			if DEBUG_FORTH_MALLOC_HIGH 
11e8			call malloc_guard_entry 
11e8			endif 
11e8			 
11e8					if DEBUG_FORTH_MALLOC 
11e8						DMARK "mal" 
11e8						CALLMONITOR 
11e8					endif 
11e8 7c			      ld    A, H                    ; Exit if no space requested 
11e9 b5			      or    L 
11ea ca a9 12		      jp    Z, malloc_early_exit 
11ed			 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			; 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			 
11ed			 
11ed			 
11ed			 
11ed					if DEBUG_FORTH_MALLOC 
11ed						DMARK "maA" 
11ed						CALLMONITOR 
11ed					endif 
11ed			      ; Set up stack frame 
11ed eb			      ex    DE, HL 
11ee 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11f1 39			      add   HL, SP 
11f2 f9			      ld    SP, HL 
11f3 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11f7 dd 39		      add   IX, SP 
11f9			 
11f9			      ; Setup initial state 
11f9 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11fc 19			      add   HL, DE 
11fd			 
11fd 44			      ld    B, H                    ; Move want to BC 
11fe 4d			      ld    C, L 
11ff			 
11ff 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1202 dd 75 04		      ld    (IX+4), L 
1205 dd 74 05		      ld    (IX+5), H 
1208			 
1208 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1209 23			      inc   HL 
120a 56			      ld    D, (HL) 
120b dd 73 02		      ld    (IX+2), E 
120e dd 72 03		      ld    (IX+3), D 
1211 eb			      ex    DE, HL                  ; this_free ptr into HL 
1212			 
1212					if DEBUG_FORTH_MALLOC 
1212						DMARK "maB" 
1212						CALLMONITOR 
1212					endif 
1212			      ; Loop through free block list to find some space 
1212			malloc_find_space: 
1212 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1213 23			      inc   HL 
1214 56			      ld    D, (HL) 
1215			 
1215 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1216 b3			      or    E 
1217 ca a3 12		      jp    Z, malloc_no_space 
121a			 
121a dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
121d dd 72 01		      ld    (IX+1), D 
1220			 
1220			      ; Does this block have enough space to make the allocation? 
1220 23			      inc   HL                      ; Load free block size into DE 
1221 5e			      ld    E, (HL) 
1222 23			      inc   HL 
1223 56			      ld    D, (HL) 
1224			 
1224 eb			      ex    DE, HL                  ; Check size of block against want 
1225 b7			      or    A                       ; Ensure carry flag clear 
1226 ed 42		      sbc   HL, BC 
1228 e5			      push  HL                      ; Store the result for later (new block size) 
1229			 
1229 ca 78 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
122c 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
122e			 
122e			      ; this_free block is not big enough, setup ptrs to test next free block 
122e e1			      pop   HL                      ; Discard previous result 
122f			 
122f dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1232 dd 66 03		      ld    H, (IX+3) 
1235 dd 75 04		      ld    (IX+4), L 
1238 dd 74 05		      ld    (IX+5), H 
123b			 
123b dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
123e dd 66 01		      ld    H, (IX+1) 
1241 dd 75 02		      ld    (IX+2), L 
1244 dd 74 03		      ld    (IX+3), H 
1247			 
1247					if DEBUG_FORTH_MALLOC 
1247						DMARK "MA>" 
1247						CALLMONITOR 
1247					endif 
1247 18 c9		      jr    malloc_find_space 
1249			 
1249			      ; split a bigger block into two - requested size and remaining size 
1249			malloc_alloc_split: 
1249					if DEBUG_FORTH_MALLOC 
1249						DMARK "MAs" 
1249						CALLMONITOR 
1249					endif 
1249 eb			      ex    DE, HL                  ; Calculate address of new free block 
124a 2b			      dec   HL 
124b 2b			      dec   HL 
124c 2b			      dec   HL 
124d 09			      add   HL, BC 
124e			 
124e			      ; Create a new block and point it at next_free 
124e dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1251 dd 56 01		      ld    D, (IX+1) 
1254			 
1254 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1255 23			      inc   HL 
1256 72			      ld    (HL), D 
1257			 
1257 d1			      pop   DE                      ; Store size of new block into new block 
1258 23			      inc   HL 
1259 73			      ld    (HL), E 
125a 23			      inc   HL 
125b 72			      ld    (HL), D 
125c			 
125c			      ; Update this_free ptr to point to new block 
125c 2b			      dec   HL 
125d 2b			      dec   HL 
125e 2b			      dec   HL 
125f			 
125f dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1262 dd 56 03		      ld    D, (IX+3) 
1265			 
1265 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1268 dd 74 03		      ld    (IX+3), H 
126b			 
126b			      ; Modify this_free block to be allocation 
126b eb			      ex    DE, HL 
126c af			      xor   A                       ; Null the next block ptr of allocated block 
126d 77			      ld    (HL), A 
126e 23			      inc   HL 
126f 77			      ld    (HL), A 
1270			 
1270 23			      inc   HL                      ; Store want size into allocated block 
1271 71			      ld    (HL), C 
1272 23			      inc   HL 
1273 70			      ld    (HL), B 
1274 23			      inc   HL 
1275 e5			      push  HL                      ; Address of allocation to return 
1276			 
1276 18 19		      jr    malloc_update_links 
1278			 
1278			malloc_alloc_fit: 
1278 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1279			 
1279					if DEBUG_FORTH_MALLOC 
1279						DMARK "MAf" 
1279						CALLMONITOR 
1279					endif 
1279			      ; Modify this_free block to be allocation 
1279 eb			      ex    DE, HL 
127a 2b			      dec   HL 
127b 2b			      dec   HL 
127c 2b			      dec   HL 
127d			 
127d af			      xor   A                       ; Null the next block ptr of allocated block 
127e 77			      ld    (HL), A 
127f 23			      inc   HL 
1280 77			      ld    (HL), A 
1281			 
1281 23			      inc   HL                      ; Store address of allocation to return 
1282 23			      inc   HL 
1283 23			      inc   HL 
1284 e5			      push  HL 
1285			 
1285			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1285 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1288 dd 66 01		      ld    H, (IX+1) 
128b			 
128b dd 75 02		      ld    (IX+2), L               ; HL to this_free 
128e dd 74 03		      ld    (IX+3), H 
1291			 
1291			 
1291			malloc_update_links: 
1291			      ; Update prev_free ptr to point to this_free 
1291 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1294 dd 66 05		      ld    H, (IX+5) 
1297			 
1297 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
129a dd 56 03		      ld    D, (IX+3) 
129d			 
129d 73			      ld    (HL), E                 ; this_free ptr into prev_free 
129e 23			      inc   HL 
129f 72			      ld    (HL), D 
12a0			 
12a0					if DEBUG_FORTH_MALLOC 
12a0						DMARK "Mul" 
12a0						CALLMONITOR 
12a0					endif 
12a0			      ; Clear the Z flag to indicate successful allocation 
12a0 7a			      ld    A, D 
12a1 b3			      or    E 
12a2			 
12a2 d1			      pop   DE                      ; Address of allocation 
12a3					if DEBUG_FORTH_MALLOC 
12a3						DMARK "MAu" 
12a3						CALLMONITOR 
12a3					endif 
12a3			 
12a3			malloc_no_space: 
12a3 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
12a6 39			      add   HL, SP 
12a7 f9			      ld    SP, HL 
12a8			 
12a8 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
12a9					if DEBUG_FORTH_MALLOC 
12a9						DMARK "MAN" 
12a9						CALLMONITOR 
12a9					endif 
12a9			 
12a9			malloc_early_exit: 
12a9					if DEBUG_FORTH_MALLOC 
12a9						DMARK "MAx" 
12a9						CALLMONITOR 
12a9					endif 
12a9 dd e1		      pop   IX 
12ab d1			      pop   DE 
12ac c1			      pop   BC 
12ad			 
12ad			if DEBUG_FORTH_MALLOC_HIGH 
12ad			call malloc_guard_exit 
12ad			call malloc_guard_zerolen 
12ad			endif 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     free                                                                    : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Return the space pointed to by HL to the heap. HL must be an address as : 
12ae			;     returned by malloc, otherwise the behaviour is undefined.               : 
12ae			;                                                                             : 
12ae			;     Where possible, directly adjacent free blocks will be merged together   : 
12ae			;     into larger blocks to help ensure that the heap does not become         : 
12ae			;     excessively fragmented.                                                 : 
12ae			;                                                                             : 
12ae			;     free does not clear or set any other value into the freed space, and    : 
12ae			;     therefore its contents may be visible through subsequent malloc's. The  : 
12ae			;     caller should clear the freed space as required.                        : 
12ae			;                                                                             : 
12ae			;     This implementation of free uses the stack exclusively, and is          : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling free, and recommended    : 
12ae			;     to avoid the use of free inside ISRs in general.                        : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Pointer to address of first byte of allocation to be freed          : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     Nothing                                                                 : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			free: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			 
12b2 7c			      ld    A, H                    ; Exit if ptr is null 
12b3 b5			      or    L 
12b4 ca 78 13		      jp    Z, free_early_exit 
12b7			 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; The address in HL points to the start of the useable allocated space, 
12c3			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12c3			      ; address of the block itself. 
12c3 eb			      ex    DE, HL 
12c4 11 fc ff		      ld    DE, -4 
12c7 19			      add   HL, DE 
12c8			 
12c8			      ; An allocated block must have a null next block pointer in it 
12c8 7e			      ld    A, (HL) 
12c9 23			      inc   HL 
12ca b6			      or    (HL) 
12cb c2 73 13		      jp    NZ, free_done 
12ce			 
12ce 2b			      dec   HL 
12cf			 
12cf 44			      ld    B, H                    ; Copy HL to BC 
12d0 4d			      ld    C, L 
12d1			 
12d1			      ; Loop through the free list to find the first block with an address 
12d1			      ; higher than the block being freed 
12d1 21 0a 80		      ld    HL, free_list 
12d4			 
12d4			free_find_higher_block: 
12d4 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12d5 23			      inc   HL 
12d6 56			      ld    D, (HL) 
12d7 2b			      dec   HL 
12d8			 
12d8 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12db dd 72 01		      ld    (IX+1), D 
12de dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12e1 dd 74 03		      ld    (IX+3), H 
12e4			 
12e4 78			      ld    A, B                    ; Check if DE is greater than BC 
12e5 ba			      cp    D                       ; Compare MSB first 
12e6 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12e8 30 04		      jr    NC, free_find_higher_block_skip 
12ea 79			      ld    A, C 
12eb bb			      cp    E                       ; Then compare LSB 
12ec 38 08		      jr    C, free_found_higher_block 
12ee			 
12ee			free_find_higher_block_skip: 
12ee 7a			      ld    A, D                    ; Reached the end of the free list? 
12ef b3			      or    E 
12f0 ca 73 13		      jp    Z, free_done 
12f3			 
12f3 eb			      ex    DE, HL 
12f4			 
12f4 18 de		      jr    free_find_higher_block 
12f6			 
12f6			free_found_higher_block: 
12f6			      ; Insert freed block between prev and next free blocks 
12f6 71			      ld    (HL), C                 ; Point prev free block to freed block 
12f7 23			      inc   HL 
12f8 70			      ld    (HL), B 
12f9			 
12f9 60			      ld    H, B                    ; Point freed block at next free block 
12fa 69			      ld    L, C 
12fb 73			      ld    (HL), E 
12fc 23			      inc   HL 
12fd 72			      ld    (HL), D 
12fe			 
12fe			      ; Check if the freed block is adjacent to the next free block 
12fe 23			      inc   HL                      ; Load size of freed block into HL 
12ff 5e			      ld    E, (HL) 
1300 23			      inc   HL 
1301 56			      ld    D, (HL) 
1302 eb			      ex    DE, HL 
1303			 
1303 09			      add   HL, BC                  ; Add addr of freed block and its size 
1304			 
1304 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1307 dd 56 01		      ld    D, (IX+1) 
130a			 
130a b7			      or    A                       ; Clear the carry flag 
130b ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
130d 20 22		      jr    NZ, free_check_adjacent_to_prev 
130f			 
130f			      ; Freed block is adjacent to next, merge into one bigger block 
130f eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1310 5e			      ld    E, (HL) 
1311 23			      inc   HL 
1312 56			      ld    D, (HL) 
1313 e5			      push  HL                      ; Save ptr to next block for later 
1314			 
1314 60			      ld    H, B                    ; Store ptr from next block into freed block 
1315 69			      ld    L, C 
1316 73			      ld    (HL), E 
1317 23			      inc   HL 
1318 72			      ld    (HL), D 
1319			 
1319 e1			      pop   HL                      ; Restore ptr to next block 
131a 23			      inc   HL                      ; Load size of next block into DE 
131b 5e			      ld    E, (HL) 
131c 23			      inc   HL 
131d 56			      ld    D, (HL) 
131e d5			      push  DE                      ; Save next block size for later 
131f			 
131f 60			      ld    H, B                    ; Load size of freed block into HL 
1320 69			      ld    L, C 
1321 23			      inc   HL 
1322 23			      inc   HL 
1323 5e			      ld    E, (HL) 
1324 23			      inc   HL 
1325 56			      ld    D, (HL) 
1326 eb			      ex    DE, HL 
1327			 
1327 d1			      pop   DE                      ; Restore size of next block 
1328 19			      add   HL, DE                  ; Add sizes of both blocks 
1329 eb			      ex    DE, HL 
132a			 
132a 60			      ld    H, B                    ; Store new bigger size into freed block 
132b 69			      ld    L, C 
132c 23			      inc   HL 
132d 23			      inc   HL 
132e 73			      ld    (HL), E 
132f 23			      inc   HL 
1330 72			      ld    (HL), D 
1331			 
1331			free_check_adjacent_to_prev: 
1331			      ; Check if the freed block is adjacent to the prev free block 
1331 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1334 dd 66 03		      ld    H, (IX+3) 
1337			 
1337 23			      inc   HL                      ; Size of prev free block into DE 
1338 23			      inc   HL 
1339 5e			      ld    E, (HL) 
133a 23			      inc   HL 
133b 56			      ld    D, (HL) 
133c 2b			      dec   HL 
133d 2b			      dec   HL 
133e 2b			      dec   HL 
133f			 
133f 19			      add   HL, DE                  ; Add prev block addr and size 
1340			 
1340 b7			      or    A                       ; Clear the carry flag 
1341 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1343 20 2e		      jr    NZ, free_done 
1345			 
1345			      ; Freed block is adjacent to prev, merge into one bigger block 
1345 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1346 69			      ld    L, C 
1347 5e			      ld    E, (HL) 
1348 23			      inc   HL 
1349 56			      ld    D, (HL) 
134a e5			      push  HL                      ; Save freed block ptr for later 
134b			 
134b dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
134e dd 66 03		      ld    H, (IX+3) 
1351 73			      ld    (HL), E 
1352 23			      inc   HL 
1353 72			      ld    (HL), D 
1354			 
1354 e1			      pop   HL                      ; Restore freed block ptr 
1355 23			      inc   HL                      ; Load size of freed block into DE 
1356 5e			      ld    E, (HL) 
1357 23			      inc   HL 
1358 56			      ld    D, (HL) 
1359 d5			      push  DE                      ; Save freed block size for later 
135a			 
135a dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
135d dd 66 03		      ld    H, (IX+3) 
1360 23			      inc   HL 
1361 23			      inc   HL 
1362 5e			      ld    E, (HL) 
1363 23			      inc   HL 
1364 56			      ld    D, (HL) 
1365			 
1365 e1			      pop   HL                      ; Add sizes of both blocks 
1366 19			      add   HL, DE 
1367 eb			      ex    DE, HL 
1368			 
1368 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
136b dd 66 03		      ld    H, (IX+3) 
136e 23			      inc   HL 
136f 23			      inc   HL 
1370 73			      ld    (HL), E 
1371 23			      inc   HL 
1372 72			      ld    (HL), D 
1373			 
1373			free_done: 
1373 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1376 39			      add   HL, SP 
1377 f9			      ld    SP, HL 
1378			 
1378			free_early_exit: 
1378 dd e1		      pop   IX 
137a d1			      pop   DE 
137b c1			      pop   BC 
137c			 
137c c9			      ret 
137d			 
137d			; moved to firmware.asm 
137d			; 
137d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
137d			;                  .dw   0 
137d			 
137d			 
137d			endif 
137d			 
137d			 
137d			if MALLOC_3 
137d			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
137d			;heap_start        .equ  0x9000      ; Starting address of heap 
137d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
137d			; 
137d			 ;     .org 0 
137d			  ;    jp    main 
137d			; 
137d			; 
137d			 ;     .org  0x100 
137d			;main: 
137d			 ;     ld    HL, 0x8100 
137d			  ;    ld    SP, HL 
137d			; 
137d			;      call  heap_init 
137d			 
137d			      ; Make some allocations 
137d			;      ld    HL, 12 
137d			;      call  malloc            ; Allocates 0x9004 
137d			; 
137d			 ;     ld    HL, 12 
137d			;      call  malloc            ; Allocates 0x9014 
137d			 
137d			;      ld    HL, 12 
137d			;      call  malloc            ; Allocates 0x9024 
137d			 
137d			      ; Free some allocations 
137d			;      ld    HL, 0x9014 
137d			;      call  free 
137d			 
137d			;      ld    HL, 0x9004 
137d			;      call  free 
137d			; 
137d			;      ld    HL, 0x9024 
137d			;      call  free 
137d			 
137d			 
137d			 ;     halt 
137d			 
137d			 
137d			;------------------------------------------------------------------------------ 
137d			;     heap_init                                                               : 
137d			;                                                                             : 
137d			; Description                                                                 : 
137d			;     Initialise the heap and make it ready for malloc and free operations.   : 
137d			;                                                                             : 
137d			;     The heap is maintained as a linked list, starting with an initial       : 
137d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
137d			;     the first free block in the heap. Each block then points to the next    : 
137d			;     free block within the heap, and the free list ends at the first block   : 
137d			;     with a null pointer to the next free block.                             : 
137d			;                                                                             : 
137d			; Parameters                                                                  : 
137d			;     Inputs are compile-time only. Two defines which specify the starting    : 
137d			;     address of the heap and its size are required, along with a memory      : 
137d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
137d			;     principally stores a pointer to the first free block in the heap.       : 
137d			;                                                                             : 
137d			; Returns                                                                     : 
137d			;     Nothing                                                                 : 
137d			;------------------------------------------------------------------------------ 
137d			heap_init: 
137d			      push  HL 
137d			 
137d			      ; Initialise free list struct 
137d			      ld    HL, heap_start 
137d			      ld    (free_list), HL 
137d			      ld    HL, 0 
137d			      ld    (free_list+2), HL 
137d			 
137d			      ; Insert first free block at bottom of heap, consumes entire heap 
137d			      ld    HL, heap_start+heap_size-4 
137d			      ld    (heap_start), HL        ; Next block (end of free list) 
137d			      ld    HL, heap_size-4 
137d			      ld    (heap_start+2), HL      ; Block size 
137d			 
137d			      ; Insert end of free list block at top of heap - two null words will 
137d			      ; terminate the free list 
137d			      ld    HL, 0 
137d			      ld    (heap_start+heap_size-2), HL 
137d			      ld    (heap_start+heap_size-4), HL 
137d			 
137d			      pop   HL 
137d			 
137d			      ret 
137d			 
137d			 
137d			;------------------------------------------------------------------------------ 
137d			;     malloc                                                                  : 
137d			;                                                                             : 
137d			; Description                                                                 : 
137d			;     Allocates the wanted space from the heap and returns the address of the : 
137d			;     first useable byte of the allocation.                                   : 
137d			;                                                                             : 
137d			;     Allocations can happen in one of two ways:                              : 
137d			;                                                                             : 
137d			;     1. A free block may be found which is the exact size wanted. In this    : 
137d			;        case the block is removed from the free list and retuedn to the      : 
137d			;        caller.                                                              : 
137d			;     2. A free block may be found which is larger than the size wanted. In   : 
137d			;        this case, the larger block is split into two. The first portion of  : 
137d			;        this block will become the requested space by the malloc call and    : 
137d			;        is returned to the caller. The second portion becomes a new free     : 
137d			;        block, and the free list is adjusted to maintain continuity via this : 
137d			;        newly created block.                                                 : 
137d			;                                                                             : 
137d			;     malloc does not set any initial value in the allocated space, the       : 
137d			;     caller is required to do this as required.                              : 
137d			;                                                                             : 
137d			;     This implementation of malloc uses the stack exclusively, and is        : 
137d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
137d			;     advisable to disable interrupts before calling malloc, and recommended  : 
137d			;     to avoid the use of malloc inside ISRs in general.                      : 
137d			;                                                                             : 
137d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
137d			;                                                                             : 
137d			; Parameters                                                                  : 
137d			;     HL  Number of bytes wanted                                              : 
137d			;                                                                             : 
137d			; Returns                                                                     : 
137d			;     HL  Address of the first useable byte of the allocation                 : 
137d			;                                                                             : 
137d			; Flags                                                                       : 
137d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
137d			;                                                                             : 
137d			; Stack frame                                                                 : 
137d			;       |             |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     BC      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     DE      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     IX      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |  prev_free  |                                                       : 
137d			;   +4  +-------------+                                                       : 
137d			;       |  this_free  |                                                       : 
137d			;   +2  +-------------+                                                       : 
137d			;       |  next_free  |                                                       : 
137d			;   +0  +-------------+                                                       : 
137d			;       |             |                                                       : 
137d			;                                                                             : 
137d			;------------------------------------------------------------------------------ 
137d			malloc: 
137d			      push  BC 
137d			      push  DE 
137d			      push  IX 
137d			 
137d			      ld    A, H                    ; Exit if no space requested 
137d			      or    L 
137d			      jp    Z, malloc_early_exit 
137d			 
137d			      ; Set up stack frame 
137d			      ex    DE, HL 
137d			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
137d			      add   HL, SP 
137d			      ld    SP, HL 
137d			      ld    IX, 0                   ; Use IX as a frame pointer 
137d			      add   IX, SP 
137d			 
137d			      ; Setup initial state 
137d			      ld    HL, 4                   ; want must also include space used by block struct 
137d			      add   HL, DE 
137d			 
137d			      ld    B, H                    ; Move want to BC 
137d			      ld    C, L 
137d			 
137d			      ld    HL, free_list           ; Store prev_free ptr to stack 
137d			      ld    (IX+4), L 
137d			      ld    (IX+5), H 
137d			 
137d			      ld    E, (HL)                 ; Store this_free ptr to stack 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      ld    (IX+2), E 
137d			      ld    (IX+3), D 
137d			      ex    DE, HL                  ; this_free ptr into HL 
137d			 
137d			      ; Loop through free block list to find some space 
137d			malloc_find_space: 
137d			      ld    E, (HL)                 ; Load next_free ptr into DE 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			 
137d			      ld    A, D                    ; Check for null next_free ptr - end of free list 
137d			      or    E 
137d			      jp    Z, malloc_no_space 
137d			 
137d			      ld    (IX+0), E               ; Store next_free ptr to stack 
137d			      ld    (IX+1), D 
137d			 
137d			      ; Does this block have enough space to make the allocation? 
137d			      inc   HL                      ; Load free block size into DE 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			 
137d			      ex    DE, HL                  ; Check size of block against want 
137d			      or    A                       ; Ensure carry flag clear 
137d			      sbc   HL, BC 
137d			      push  HL                      ; Store the result for later (new block size) 
137d			 
137d			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
137d			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
137d			 
137d			      ; this_free block is not big enough, setup ptrs to test next free block 
137d			      pop   HL                      ; Discard previous result 
137d			 
137d			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
137d			      ld    H, (IX+3) 
137d			      ld    (IX+4), L 
137d			      ld    (IX+5), H 
137d			 
137d			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
137d			      ld    H, (IX+1) 
137d			      ld    (IX+2), L 
137d			      ld    (IX+3), H 
137d			 
137d			      jr    malloc_find_space 
137d			 
137d			      ; split a bigger block into two - requested size and remaining size 
137d			malloc_alloc_split: 
137d			      ex    DE, HL                  ; Calculate address of new free block 
137d			      dec   HL 
137d			      dec   HL 
137d			      dec   HL 
137d			      add   HL, BC 
137d			 
137d			      ; Create a new block and point it at next_free 
137d			      ld    E, (IX+0)               ; Load next_free ptr into DE 
137d			      ld    D, (IX+1) 
137d			 
137d			      ld    (HL), E                 ; Store next_free ptr into new block 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      pop   DE                      ; Store size of new block into new block 
137d			      inc   HL 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      ; Update this_free ptr to point to new block 
137d			      dec   HL 
137d			      dec   HL 
137d			      dec   HL 
137d			 
137d			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
137d			      ld    D, (IX+3) 
137d			 
137d			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
137d			      ld    (IX+3), H 
137d			 
137d			      ; Modify this_free block to be allocation 
137d			      ex    DE, HL 
137d			      xor   A                       ; Null the next block ptr of allocated block 
137d			      ld    (HL), A 
137d			      inc   HL 
137d			      ld    (HL), A 
137d			 
137d			      inc   HL                      ; Store want size into allocated block 
137d			      ld    (HL), C 
137d			      inc   HL 
137d			      ld    (HL), B 
137d			      inc   HL 
137d			      push  HL                      ; Address of allocation to return 
137d			 
137d			      jr    malloc_update_links 
137d			 
137d			malloc_alloc_fit: 
137d			      pop   HL                      ; Dont need new block size, want is exact fit 
137d			 
137d			      ; Modify this_free block to be allocation 
137d			      ex    DE, HL 
137d			      dec   HL 
137d			      dec   HL 
137d			      dec   HL 
137d			 
137d			      xor   A                       ; Null the next block ptr of allocated block 
137d			      ld    (HL), A 
137d			      inc   HL 
137d			      ld    (HL), A 
137d			 
137d			      inc   HL                      ; Store address of allocation to return 
137d			      inc   HL 
137d			      inc   HL 
137d			      push  HL 
137d			 
137d			      ; Copy next_free ptr to this_free, remove allocated block from free list 
137d			      ld    L, (IX+0)               ; next_free to HL 
137d			      ld    H, (IX+1) 
137d			 
137d			      ld    (IX+2), L               ; HL to this_free 
137d			      ld    (IX+3), H 
137d			 
137d			 
137d			malloc_update_links: 
137d			      ; Update prev_free ptr to point to this_free 
137d			      ld    L, (IX+4)               ; prev_free ptr to HL 
137d			      ld    H, (IX+5) 
137d			 
137d			      ld    E, (IX+2)               ; this_free ptr to DE 
137d			      ld    D, (IX+3) 
137d			 
137d			      ld    (HL), E                 ; this_free ptr into prev_free 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      ; Clear the Z flag to indicate successful allocation 
137d			      ld    A, D 
137d			      or    E 
137d			 
137d			      pop   DE                      ; Address of allocation 
137d			 
137d			malloc_no_space: 
137d			      ld    HL, 6                   ; Clean up stack frame 
137d			      add   HL, SP 
137d			      ld    SP, HL 
137d			 
137d			      ex    DE, HL                  ; Alloc addr into HL for return 
137d			 
137d			malloc_early_exit: 
137d			      pop   IX 
137d			      pop   DE 
137d			      pop   BC 
137d			 
137d			      ret 
137d			 
137d			 
137d			;------------------------------------------------------------------------------ 
137d			;     free                                                                    : 
137d			;                                                                             : 
137d			; Description                                                                 : 
137d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
137d			;     returned by malloc, otherwise the behaviour is undefined.               : 
137d			;                                                                             : 
137d			;     Where possible, directly adjacent free blocks will be merged together   : 
137d			;     into larger blocks to help ensure that the heap does not become         : 
137d			;     excessively fragmented.                                                 : 
137d			;                                                                             : 
137d			;     free does not clear or set any other value into the freed space, and    : 
137d			;     therefore its contents may be visible through subsequent malloc's. The  : 
137d			;     caller should clear the freed space as required.                        : 
137d			;                                                                             : 
137d			;     This implementation of free uses the stack exclusively, and is          : 
137d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
137d			;     advisable to disable interrupts before calling free, and recommended    : 
137d			;     to avoid the use of free inside ISRs in general.                        : 
137d			;                                                                             : 
137d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
137d			;                                                                             : 
137d			; Parameters                                                                  : 
137d			;     HL  Pointer to address of first byte of allocation to be freed          : 
137d			;                                                                             : 
137d			; Returns                                                                     : 
137d			;     Nothing                                                                 : 
137d			;                                                                             : 
137d			; Stack frame                                                                 : 
137d			;       |             |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     BC      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     DE      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     IX      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |  prev_free  |                                                       : 
137d			;   +2  +-------------+                                                       : 
137d			;       |  next_free  |                                                       : 
137d			;   +0  +-------------+                                                       : 
137d			;       |             |                                                       : 
137d			;                                                                             : 
137d			;------------------------------------------------------------------------------ 
137d			free: 
137d			      push  BC 
137d			      push  DE 
137d			      push  IX 
137d			 
137d			      ld    A, H                    ; Exit if ptr is null 
137d			      or    L 
137d			      jp    Z, free_early_exit 
137d			 
137d			      ; Set up stack frame 
137d			      ex    DE, HL 
137d			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
137d			      add   HL, SP 
137d			      ld    SP, HL 
137d			      ld    IX, 0                   ; Use IX as a frame pointer 
137d			      add   IX, SP 
137d			 
137d			      ; The address in HL points to the start of the useable allocated space, 
137d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
137d			      ; address of the block itself. 
137d			      ex    DE, HL 
137d			      ld    DE, -4 
137d			      add   HL, DE 
137d			 
137d			      ; An allocated block must have a null next block pointer in it 
137d			      ld    A, (HL) 
137d			      inc   HL 
137d			      or    (HL) 
137d			      jp    NZ, free_done 
137d			 
137d			      dec   HL 
137d			 
137d			      ld    B, H                    ; Copy HL to BC 
137d			      ld    C, L 
137d			 
137d			      ; Loop through the free list to find the first block with an address 
137d			      ; higher than the block being freed 
137d			      ld    HL, free_list 
137d			 
137d			free_find_higher_block: 
137d			      ld    E, (HL)                 ; Load next ptr from free block 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      dec   HL 
137d			 
137d			      ld    (IX+0), E               ; Save ptr to next free block 
137d			      ld    (IX+1), D 
137d			      ld    (IX+2), L               ; Save ptr to prev free block 
137d			      ld    (IX+3), H 
137d			 
137d			      ld    A, B                    ; Check if DE is greater than BC 
137d			      cp    D                       ; Compare MSB first 
137d			      jr    Z, $+4                  ; MSB the same, compare LSB 
137d			      jr    NC, free_find_higher_block_skip 
137d			      ld    A, C 
137d			      cp    E                       ; Then compare LSB 
137d			      jr    C, free_found_higher_block 
137d			 
137d			free_find_higher_block_skip: 
137d			      ld    A, D                    ; Reached the end of the free list? 
137d			      or    E 
137d			      jp    Z, free_done 
137d			 
137d			      ex    DE, HL 
137d			 
137d			      jr    free_find_higher_block 
137d			 
137d			free_found_higher_block: 
137d			      ; Insert freed block between prev and next free blocks 
137d			      ld    (HL), C                 ; Point prev free block to freed block 
137d			      inc   HL 
137d			      ld    (HL), B 
137d			 
137d			      ld    H, B                    ; Point freed block at next free block 
137d			      ld    L, C 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      ; Check if the freed block is adjacent to the next free block 
137d			      inc   HL                      ; Load size of freed block into HL 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      ex    DE, HL 
137d			 
137d			      add   HL, BC                  ; Add addr of freed block and its size 
137d			 
137d			      ld    E, (IX+0)               ; Load addr of next free block into DE 
137d			      ld    D, (IX+1) 
137d			 
137d			      or    A                       ; Clear the carry flag 
137d			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
137d			      jr    NZ, free_check_adjacent_to_prev 
137d			 
137d			      ; Freed block is adjacent to next, merge into one bigger block 
137d			      ex    DE, HL                  ; Load next ptr from next block into DE 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      push  HL                      ; Save ptr to next block for later 
137d			 
137d			      ld    H, B                    ; Store ptr from next block into freed block 
137d			      ld    L, C 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      pop   HL                      ; Restore ptr to next block 
137d			      inc   HL                      ; Load size of next block into DE 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      push  DE                      ; Save next block size for later 
137d			 
137d			      ld    H, B                    ; Load size of freed block into HL 
137d			      ld    L, C 
137d			      inc   HL 
137d			      inc   HL 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      ex    DE, HL 
137d			 
137d			      pop   DE                      ; Restore size of next block 
137d			      add   HL, DE                  ; Add sizes of both blocks 
137d			      ex    DE, HL 
137d			 
137d			      ld    H, B                    ; Store new bigger size into freed block 
137d			      ld    L, C 
137d			      inc   HL 
137d			      inc   HL 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			free_check_adjacent_to_prev: 
137d			      ; Check if the freed block is adjacent to the prev free block 
137d			      ld    L, (IX+2)               ; Prev free block ptr into HL 
137d			      ld    H, (IX+3) 
137d			 
137d			      inc   HL                      ; Size of prev free block into DE 
137d			      inc   HL 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      dec   HL 
137d			      dec   HL 
137d			      dec   HL 
137d			 
137d			      add   HL, DE                  ; Add prev block addr and size 
137d			 
137d			      or    A                       ; Clear the carry flag 
137d			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
137d			      jr    NZ, free_done 
137d			 
137d			      ; Freed block is adjacent to prev, merge into one bigger block 
137d			      ld    H, B                    ; Load next ptr from freed block into DE 
137d			      ld    L, C 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      push  HL                      ; Save freed block ptr for later 
137d			 
137d			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
137d			      ld    H, (IX+3) 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      pop   HL                      ; Restore freed block ptr 
137d			      inc   HL                      ; Load size of freed block into DE 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      push  DE                      ; Save freed block size for later 
137d			 
137d			      ld    L, (IX+2)               ; Load size of prev block into DE 
137d			      ld    H, (IX+3) 
137d			      inc   HL 
137d			      inc   HL 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			 
137d			      pop   HL                      ; Add sizes of both blocks 
137d			      add   HL, DE 
137d			      ex    DE, HL 
137d			 
137d			      ld    L, (IX+2)               ; Store new bigger size into prev block 
137d			      ld    H, (IX+3) 
137d			      inc   HL 
137d			      inc   HL 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			free_done: 
137d			      ld    HL, 4                   ; Clean up stack frame 
137d			      add   HL, SP 
137d			      ld    SP, HL 
137d			 
137d			free_early_exit: 
137d			      pop   IX 
137d			      pop   DE 
137d			      pop   BC 
137d			 
137d			      ret 
137d			 
137d			 
137d			;      .org 0x8000 
137d			; 
137d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
137d			 ;                 .dw   0 
137d			 
137d			endif 
137d			 
137d			 
137d			if MALLOC_4 
137d			 
137d			; My memory allocation code. Very very simple.... 
137d			; allocate space under 250 chars 
137d			 
137d			heap_init: 
137d				; init start of heap as zero 
137d				;  
137d			 
137d				ld hl, heap_start 
137d				ld a, 0 
137d				ld (hl), a      ; empty block 
137d				inc hl 
137d				ld a, 0 
137d				ld (hl), a      ; length of block 
137d				; write end of list 
137d				inc hl 
137d				ld a,(hl) 
137d				inc hl 
137d				ld a,(hl) 
137d				 
137d			 
137d				; init some malloc vars 
137d			 
137d				ld hl, 0 
137d				ld (free_list), hl       ; store last malloc location 
137d			 
137d				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
137d				ld a, 0 
137d				ld (hl), a 
137d			 
137d			 
137d				ld hl, heap_start 
137d				;  
137d				  
137d				ret 
137d			 
137d			 
137d			;    free block marker 
137d			;    requested size  
137d			;    pointer to next block 
137d			;    .... 
137d			;    next block marker 
137d			 
137d			 
137d			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
137d			; 
137d			 
137d			 
137d			malloc:  
137d				push de 
137d				push bc 
137d				push af 
137d			 
137d				; hl space required 
137d				 
137d				ld c, l    ; hold space   (TODO only a max of 255) 
137d			 
137d			;	inc c     ; TODO BUG need to fix memory leak on push str 
137d			;	inc c 
137d			;	inc c 
137d			;	inc c 
137d			;	inc c 
137d			;	inc c 
137d			;	inc c 
137d			 
137d			 
137d			 
137d				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
137d			 
137d				ld a, (free_list+3) 
137d				cp 0 
137d				jr z, .contheap 
137d			 
137d				ld hl, (free_list)     ; get last alloc 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mrs" 
137d						CALLMONITOR 
137d					endif 
137d				jr .startalloc 
137d			 
137d			.contheap: 
137d				ld hl, heap_start 
137d			 
137d			.startalloc: 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mym" 
137d						CALLMONITOR 
137d					endif 
137d			.findblock: 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mmf" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d				ld a,(hl)  
137d				; if byte is zero then clear to use 
137d			 
137d				cp 0 
137d				jr z, .foundemptyblock 
137d			 
137d				; if byte is not clear 
137d				;     then byte is offset to next block 
137d			 
137d				inc hl 
137d				ld a, (hl) ; get size 
137d			.nextblock:	inc hl 
137d					ld e, (hl) 
137d					inc hl 
137d					ld d, (hl) 
137d					ex de, hl 
137d			;	inc hl  ; move past the store space 
137d			;	inc hl  ; move past zero index  
137d			 
137d				; TODO detect no more space 
137d			 
137d				push hl 
137d				ld de, heap_end 
137d				call cmp16 
137d				pop hl 
137d				jr nc, .nospace 
137d			 
137d				jr .findblock 
137d			 
137d			.nospace: ld hl, 0 
137d				jp .exit 
137d			 
137d			 
137d			.foundemptyblock:	 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mme" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d			; TODO has block enough space if reusing??? 
137d			 
137d				;  
137d			 
137d			; see if this block has been previously used 
137d				inc hl 
137d				ld a, (hl) 
137d				dec hl 
137d				cp 0 
137d				jr z, .newblock 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "meR" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d			; no reusing previously allocated block 
137d			 
137d			; is it smaller than previously used? 
137d				 
137d				inc hl    ; move to size 
137d				ld a, c 
137d				sub (hl)        ; we want c < (hl) 
137d				dec hl    ; move back to marker 
137d			        jr z, .findblock 
137d			 
137d				; update with the new size which should be lower 
137d			 
137d			        ;inc  hl   ; negate next move. move back to size  
137d			 
137d			.newblock: 
137d				; need to be at marker here 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "meN" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d			 
137d				ld a, c 
137d			 
137d				ld (free_list+3), a	 ; flag resume from last malloc  
137d				ld (free_list), hl    ; save out last location 
137d			 
137d			 
137d				;inc a     ; space for length byte 
137d				ld (hl), a     ; save block in use marker 
137d			 
137d				inc hl   ; move to space marker 
137d				ld (hl), a    ; save new space 
137d			 
137d				inc hl   ; move to start of allocated area 
137d				 
137d			;	push hl     ; save where we are - 1  
137d			 
137d			;	inc hl  ; move past zero index  
137d				; skip space to set down new marker 
137d			 
137d				; provide some extra space for now 
137d			 
137d				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
137d				inc a 
137d				inc a 
137d			 
137d				push hl   ; save where we are in the node block 
137d			 
137d				call addatohl 
137d			 
137d				; write linked list point 
137d			 
137d				pop de     ; get our node position 
137d				ex de, hl 
137d			 
137d				ld (hl), e 
137d				inc hl 
137d				ld (hl), d 
137d			 
137d				inc hl 
137d			 
137d				; now at start of allocated data so save pointer 
137d			 
137d				push hl 
137d			 
137d				; jump to position of next node and setup empty header in DE 
137d			 
137d				ex de, hl 
137d			 
137d			;	inc hl ; move past end of block 
137d			 
137d				ld a, 0 
137d				ld (hl), a   ; empty marker 
137d				inc hl 
137d				ld (hl), a   ; size 
137d				inc hl  
137d				ld (hl), a   ; ptr 
137d				inc hl 
137d				ld (hl), a   ; ptr 
137d			 
137d			 
137d				pop hl 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mmr" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d			.exit: 
137d				pop af 
137d				pop bc 
137d				pop de  
137d				ret 
137d			 
137d			 
137d			 
137d			 
137d			free:  
137d				push hl 
137d				push af 
137d				; get address in hl 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "fre" 
137d						CALLMONITOR 
137d					endif 
137d				; data is at hl - move to block count 
137d				dec hl 
137d				dec hl    ; get past pointer 
137d				dec hl 
137d			 
137d				ld a, (hl)    ; need this for a validation check 
137d			 
137d				dec hl    ; move to block marker 
137d			 
137d				; now check that the block count and block marker are the same  
137d			        ; this checks that we are on a malloc node and not random memory 
137d			        ; OK a faint chance this could be a problem but rare - famous last words! 
137d			 
137d				ld c, a 
137d				ld a, (hl)    
137d			 
137d				cp c 
137d				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
137d			 
137d				; yes good chance we are on a malloc node 
137d			 
137d				ld a, 0      
137d				ld (hl), a   ; mark as free 
137d			 
137d				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
137d			 
137d			.freeignore:  
137d			 
137d				pop af 
137d				pop hl 
137d			 
137d				ret 
137d			 
137d			 
137d			 
137d			endif 
137d			 
137d			; eof 
# End of file firmware_memory.asm
137d			  
137d			; device C  
137d			if SOUND_ENABLE  
137d				include "firmware_sound.asm"  
137d			endif  
137d			  
137d			include "firmware_diags.asm"  
137d			; Hardware diags menu 
137d			 
137d			 
137d			config: 
137d			 
137d 3e 00			ld a, 0 
137f 21 ad 13			ld hl, .configmn 
1382 cd 1a 0b			call menu 
1385			 
1385 fe 00			cp 0 
1387 c8				ret z 
1388			 
1388 fe 01			cp 1 
138a cc 17 15			call z, .savetostore 
138d			 
138d fe 02			cp 2 
138f cc 65 14			call z, .selautoload 
1392 fe 03			cp 3 
1394 cc 4e 14			call z, .disautoload 
1397 fe 04			cp 4 
1399 cc 15 15			call z, .selbank 
139c fe 05			cp 5 
139e cc 09 16			call z, .debug_tog 
13a1 fe 06			cp 6 
13a3 cc 51 17			call z, .bpsgo 
13a6 fe 07			cp 7 
13a8 cc 2f 16			call z, hardware_diags 
13ab			 
13ab 18 d0			jr config 
13ad			 
13ad			.configmn: 
13ad bd 13			dw .c3 
13af d4 13			dw .c2 
13b1 e9 13			dw .c2a 
13b3 ff 13			dw .c2b 
13b5			;	dw .c4 
13b5 1c 14			dw .m4 
13b7 37 14			dw .m4b 
13b9 3f 14			dw .c1 
13bb 00 00			dw 0 
13bd				 
13bd			 
13bd .. 00		.c3: db "Add Dictionary To File",0 
13d4 .. 00		.c2: db "Select Autoload File",0 
13e9 .. 00		.c2a: db "Disable Autoload File", 0 
13ff .. 00		.c2b: db "Select Storage Bank",0 
1413 .. 00		.c4: db "Settings",0 
141c .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1437 .. 00		.m4b:   db "Monitor",0 
143f .. 00		.c1: db "Hardware Diags",0 
144e			 
144e			 
144e			.disautoload: 
144e				if STORAGE_SE 
144e 3e fe			ld a, $fe      ; bit 0 clear 
1450 32 ce f9			ld (spi_device), a 
1453			 
1453 cd ba 03			call storage_get_block_0 
1456			 
1456 3e 00			ld a, 0 
1458 32 09 fa			ld (store_page+STORE_0_AUTOFILE), a 
145b			 
145b 21 00 00				ld hl, 0 
145e 11 e8 f9				ld de, store_page 
1461 cd 6e 03			call storage_write_block	 ; save update 
1464				else 
1464			 
1464				ld hl, .notav 
1464				ld de, .empty 
1464				call info_panel 
1464				endif 
1464			 
1464			 
1464 c9				ret 
1465			 
1465			 
1465			 
1465			; Select auto start 
1465			 
1465			.selautoload: 
1465			 
1465				 
1465				if STORAGE_SE 
1465			 
1465 cd 53 15				call config_dir 
1468 21 a3 ef			        ld hl, scratch 
146b 3e 00				ld a, 0 
146d cd 1a 0b				call menu 
1470			 
1470 fe 00				cp 0 
1472 c8					ret z 
1473			 
1473 3d					dec a 
1474			 
1474			 
1474					; locate menu option 
1474			 
1474 21 a3 ef				ld hl, scratch 
1477 cd 3e 0a				call table_lookup 
147a			 
147a					if DEBUG_FORTH_WORDS 
147a						DMARK "ALl" 
147a f5				push af  
147b 3a 8f 14			ld a, (.dmark)  
147e 32 bd fb			ld (debug_mark),a  
1481 3a 90 14			ld a, (.dmark+1)  
1484 32 be fb			ld (debug_mark+1),a  
1487 3a 91 14			ld a, (.dmark+2)  
148a 32 bf fb			ld (debug_mark+2),a  
148d 18 03			jr .pastdmark  
148f ..			.dmark: db "ALl"  
1492 f1			.pastdmark: pop af  
1493			endm  
# End of macro DMARK
1493						CALLMONITOR 
1493 cd 47 17			call break_point_state  
1496				endm  
# End of macro CALLMONITOR
1496					endif 
1496					; with the pointer to the menu it, the byte following the zero term is the file id 
1496			 
1496 3e 00				ld a, 0 
1498 01 32 00				ld bc, 50   ; max of bytes to look at 
149b ed b1				cpir  
149d			 
149d					if DEBUG_FORTH_WORDS 
149d						DMARK "ALb" 
149d f5				push af  
149e 3a b2 14			ld a, (.dmark)  
14a1 32 bd fb			ld (debug_mark),a  
14a4 3a b3 14			ld a, (.dmark+1)  
14a7 32 be fb			ld (debug_mark+1),a  
14aa 3a b4 14			ld a, (.dmark+2)  
14ad 32 bf fb			ld (debug_mark+2),a  
14b0 18 03			jr .pastdmark  
14b2 ..			.dmark: db "ALb"  
14b5 f1			.pastdmark: pop af  
14b6			endm  
# End of macro DMARK
14b6						CALLMONITOR 
14b6 cd 47 17			call break_point_state  
14b9				endm  
# End of macro CALLMONITOR
14b9					endif 
14b9					;inc hl 
14b9			 
14b9 7e					ld a, (hl)   ; file id 
14ba					 
14ba				        ; save bank and file ids 
14ba			 
14ba f5					push af 
14bb			 
14bb			; TODO need to save to block 0 on bank 1	 
14bb			 
14bb cd ba 03				call storage_get_block_0 
14be			 
14be					if DEBUG_FORTH_WORDS 
14be						DMARK "AL0" 
14be f5				push af  
14bf 3a d3 14			ld a, (.dmark)  
14c2 32 bd fb			ld (debug_mark),a  
14c5 3a d4 14			ld a, (.dmark+1)  
14c8 32 be fb			ld (debug_mark+1),a  
14cb 3a d5 14			ld a, (.dmark+2)  
14ce 32 bf fb			ld (debug_mark+2),a  
14d1 18 03			jr .pastdmark  
14d3 ..			.dmark: db "AL0"  
14d6 f1			.pastdmark: pop af  
14d7			endm  
# End of macro DMARK
14d7						CALLMONITOR 
14d7 cd 47 17			call break_point_state  
14da				endm  
# End of macro CALLMONITOR
14da					endif 
14da f1					pop af 
14db			 
14db 32 0c fa				ld (store_page+STORE_0_FILERUN),a 
14de					 
14de					; save bank id 
14de			 
14de 3a ce f9				ld a,(spi_device) 
14e1 32 0b fa				ld (store_page+STORE_0_BANKRUN),a 
14e4			 
14e4					; enable auto run of store file 
14e4			 
14e4 3e 01				ld a, 1 
14e6 32 09 fa				ld (store_page+STORE_0_AUTOFILE),a 
14e9			 
14e9					; save buffer 
14e9			 
14e9 21 00 00				ld hl, 0 
14ec 11 e8 f9				ld de, store_page 
14ef					if DEBUG_FORTH_WORDS 
14ef						DMARK "ALw" 
14ef f5				push af  
14f0 3a 04 15			ld a, (.dmark)  
14f3 32 bd fb			ld (debug_mark),a  
14f6 3a 05 15			ld a, (.dmark+1)  
14f9 32 be fb			ld (debug_mark+1),a  
14fc 3a 06 15			ld a, (.dmark+2)  
14ff 32 bf fb			ld (debug_mark+2),a  
1502 18 03			jr .pastdmark  
1504 ..			.dmark: db "ALw"  
1507 f1			.pastdmark: pop af  
1508			endm  
# End of macro DMARK
1508						CALLMONITOR 
1508 cd 47 17			call break_point_state  
150b				endm  
# End of macro CALLMONITOR
150b					endif 
150b cd 6e 03			call storage_write_block	 ; save update 
150e			  
150e			 
150e			 
150e			 
150e 21 a3 ef				ld hl, scratch 
1511 cd 40 15				call config_fdir 
1514			 
1514				else 
1514			 
1514				ld hl, .notav 
1514				ld de, .empty 
1514				call info_panel 
1514			 
1514				endif 
1514 c9				ret 
1515			 
1515			 
1515			 
1515			; Select storage bank 
1515			 
1515			.selbank: 
1515			 
1515				if STORAGE_SE 
1515				else 
1515			 
1515				ld hl, .notav 
1515				ld de, .empty 
1515				call info_panel 
1515				endif 
1515				 
1515 c9				ret 
1516			 
1516			if STORAGE_SE 
1516			 
1516			.config_ldir:   
1516				; Load storage bank labels into menu array 
1516			 
1516				 
1516			 
1516			 
1516 c9				ret 
1517			 
1517			 
1517			endif 
1517			 
1517			 
1517			; Save user words to storage 
1517			 
1517			.savetostore: 
1517			 
1517				if STORAGE_SE 
1517			 
1517 cd 53 15				call config_dir 
151a 21 a3 ef			        ld hl, scratch 
151d 3e 00				ld a, 0 
151f cd 1a 0b				call menu 
1522					 
1522 21 a3 ef				ld hl, scratch 
1525 cd 40 15				call config_fdir 
1528			 
1528				else 
1528			 
1528				ld hl, .notav 
1528				ld de, .empty 
1528				call info_panel 
1528			 
1528				endif 
1528			 
1528 c9				ret 
1529 .. 00		.notav:    db "Feature not available",0 
153f .. 00		.empty:    db "",0 
1540			 
1540			 
1540			 
1540			if STORAGE_SE 
1540			 
1540			config_fdir: 
1540				; using the scratch dir go through and release the memory allocated for each string 
1540				 
1540 21 a3 ef			ld hl, scratch 
1543 5e			.cfdir:	ld e,(hl) 
1544 23				inc hl 
1545 56				ld d,(hl) 
1546 23				inc hl 
1547			 
1547 eb				ex de, hl 
1548 cd 46 0d			call ishlzero 
154b c8				ret z     ; return on null pointer 
154c cd ae 12			call free 
154f eb				ex de, hl 
1550 18 f1			jr .cfdir 
1552			 
1552			 
1552 c9				ret 
1553			 
1553			 
1553			config_dir: 
1553			 
1553				; for the config menus that need to build a directory of storage call this routine 
1553				; it will construct a menu in scratch to pass to menu 
1553			 
1553				; open storage device 
1553			 
1553				; execute DIR to build a list of files and their ids into scratch in menu format 
1553				; once the menu has finished then will need to call config_fdir to release the strings 
1553				 
1553				; c = number items 
1553			 
1553				 
1553 cd ba 03			call storage_get_block_0 
1556			 
1556 21 e8 f9			ld hl, store_page     ; get current id count 
1559 46				ld b, (hl) 
155a 0e 00			ld c, 0    ; count of files   
155c			 
155c			 
155c 21 a3 ef			ld hl, scratch 
155f 22 e4 f9			ld (store_tmp2), hl    ; location to poke strings 
1562			 
1562				; check for empty drive 
1562			 
1562 3e 00			ld a, 0 
1564 b8				cp b 
1565 ca ff 15			jp z, .dirdone 
1568			 
1568				 
1568					if DEBUG_FORTH_WORDS 
1568						DMARK "Cdc" 
1568 f5				push af  
1569 3a 7d 15			ld a, (.dmark)  
156c 32 bd fb			ld (debug_mark),a  
156f 3a 7e 15			ld a, (.dmark+1)  
1572 32 be fb			ld (debug_mark+1),a  
1575 3a 7f 15			ld a, (.dmark+2)  
1578 32 bf fb			ld (debug_mark+2),a  
157b 18 03			jr .pastdmark  
157d ..			.dmark: db "Cdc"  
1580 f1			.pastdmark: pop af  
1581			endm  
# End of macro DMARK
1581						CALLMONITOR 
1581 cd 47 17			call break_point_state  
1584				endm  
# End of macro CALLMONITOR
1584					endif 
1584			 
1584			 
1584			.diritem:	 
1584 c5				push bc 
1585				; for each of the current ids do a search for them and if found push to stack 
1585			 
1585 21 40 00				ld hl, STORE_BLOCK_PHY 
1588 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
158a 58					ld e,b 
158b			 
158b cd 2e 06				call storage_findnextid 
158e			 
158e			 
158e					; if found hl will be non zero 
158e			 
158e cd 46 0d				call ishlzero 
1591 28 69				jr z, .dirnotfound 
1593			 
1593					; increase count 
1593			 
1593 c1					pop bc	 
1594 0c					inc c 
1595 c5					push bc 
1596					 
1596			 
1596					; get file header and push the file name 
1596			 
1596 11 e8 f9				ld de, store_page 
1599 cd 09 03				call storage_read_block 
159c			 
159c					; push file id to stack 
159c				 
159c 3a e8 f9				ld a, (store_page) 
159f 26 00				ld h, 0 
15a1 6f					ld l, a 
15a2			 
15a2					;call forth_push_numhl 
15a2					; TODO store id 
15a2			 
15a2 e5					push hl 
15a3			 
15a3					; push extent count to stack  
15a3				 
15a3 21 eb f9				ld hl, store_page+3 
15a6			 
15a6					; get file name length 
15a6			 
15a6 cd 7b 11				call strlenz   
15a9			 
15a9 23					inc hl   ; cover zero term 
15aa 23					inc hl  ; stick the id at the end of the area 
15ab			 
15ab e5					push hl 
15ac c1					pop bc    ; move length to bc 
15ad			 
15ad cd e4 11				call malloc 
15b0			 
15b0					; TODO save malloc area to scratch 
15b0			 
15b0 eb					ex de, hl 
15b1 2a e4 f9				ld hl, (store_tmp2) 
15b4 73					ld (hl), e 
15b5 23					inc hl 
15b6 72					ld (hl), d 
15b7 23					inc hl 
15b8 22 e4 f9				ld (store_tmp2), hl 
15bb			 
15bb					 
15bb			 
15bb					;pop hl   ; get source 
15bb			;		ex de, hl    ; swap aronund	 
15bb			 
15bb 21 eb f9				ld hl, store_page+3 
15be					if DEBUG_FORTH_WORDS 
15be						DMARK "CFd" 
15be f5				push af  
15bf 3a d3 15			ld a, (.dmark)  
15c2 32 bd fb			ld (debug_mark),a  
15c5 3a d4 15			ld a, (.dmark+1)  
15c8 32 be fb			ld (debug_mark+1),a  
15cb 3a d5 15			ld a, (.dmark+2)  
15ce 32 bf fb			ld (debug_mark+2),a  
15d1 18 03			jr .pastdmark  
15d3 ..			.dmark: db "CFd"  
15d6 f1			.pastdmark: pop af  
15d7			endm  
# End of macro DMARK
15d7						CALLMONITOR 
15d7 cd 47 17			call break_point_state  
15da				endm  
# End of macro CALLMONITOR
15da					endif 
15da ed b0				ldir 
15dc			 
15dc					; de is past string, move back one and store id 
15dc					 
15dc 1b					dec de 
15dd			 
15dd					; store file id 
15dd			 
15dd e1					pop hl 
15de eb					ex de,hl 
15df 73					ld (hl), e 
15e0			 
15e0					if DEBUG_FORTH_WORDS 
15e0						DMARK "Cdi" 
15e0 f5				push af  
15e1 3a f5 15			ld a, (.dmark)  
15e4 32 bd fb			ld (debug_mark),a  
15e7 3a f6 15			ld a, (.dmark+1)  
15ea 32 be fb			ld (debug_mark+1),a  
15ed 3a f7 15			ld a, (.dmark+2)  
15f0 32 bf fb			ld (debug_mark+2),a  
15f3 18 03			jr .pastdmark  
15f5 ..			.dmark: db "Cdi"  
15f8 f1			.pastdmark: pop af  
15f9			endm  
# End of macro DMARK
15f9						CALLMONITOR 
15f9 cd 47 17			call break_point_state  
15fc				endm  
# End of macro CALLMONITOR
15fc					endif 
15fc					 
15fc			.dirnotfound: 
15fc c1					pop bc     
15fd 10 85				djnz .diritem 
15ff				 
15ff			.dirdone:	 
15ff			 
15ff 3e 00				ld a, 0 
1601 2a e4 f9				ld hl, (store_tmp2) 
1604 77					ld (hl), a 
1605 23					inc hl 
1606 77					ld (hl), a 
1607 23					inc hl 
1608					; push a count of the dir items found 
1608			 
1608			;		ld h, 0 
1608			;		ld l, c 
1608			 
1608 c9				ret 
1609			 
1609			endif 
1609			 
1609			 
1609			; Settings 
1609			; Run  
1609			 
1609			 
1609			 
1609			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1609			;;hd_menu2:   db "        2: Editor",0   
1609			;hd_menu2:   db "        2: Editor       6: Menu",0   
1609			;hd_menu3:   db "        3: Storage",0 
1609			;hd_menu4:   db "0=quit  4: Debug",0 
1609			;hd_don:     db "ON",0 
1609			;hd_doff:     db "OFF",0 
1609			; 
1609			; 
1609			; 
1609			;hardware_diags_old:       
1609			; 
1609			;.diagmenu: 
1609			;	call clear_display 
1609			;	ld a, display_row_1 
1609			;	ld de, hd_menu1 
1609			;	call str_at_display 
1609			; 
1609			;	ld a, display_row_2 
1609			;	ld de, hd_menu2 
1609			;	call str_at_display 
1609			; 
1609			;	ld a, display_row_3 
1609			;	ld de, hd_menu3 
1609			;	call str_at_display 
1609			; 
1609			;	ld a,  display_row_4 
1609			;	ld de, hd_menu4 
1609			;	call str_at_display 
1609			; 
1609			;	; display debug state 
1609			; 
1609			;	ld de, hd_don 
1609			;	ld a, (os_view_disable) 
1609			;	cp 0 
1609			;	jr z, .distog 
1609			;	ld de, hd_doff 
1609			;.distog: ld a, display_row_4+17 
1609			;	call str_at_display 
1609			; 
1609			;	call update_display 
1609			; 
1609			;	call cin_wait 
1609			; 
1609			; 
1609			; 
1609			;	cp '4' 
1609			;	jr nz, .diagn1 
1609			; 
1609			;	; debug toggle 
1609			; 
1609			;	ld a, (os_view_disable) 
1609			;	ld b, '*' 
1609			;	cp 0 
1609			;	jr z, .debtog 
1609			;	ld b, 0 
1609			;.debtog:	 
1609			;	ld a,b 
1609			;	ld (os_view_disable),a 
1609			; 
1609			;.diagn1: cp '0' 
1609			;	 ret z 
1609			; 
1609			;;	cp '1' 
1609			;;       jp z, matrix	 
1609			;;   TODO keyboard matrix test 
1609			; 
1609			;	cp '2' 
1609			;	jp z, .diagedit 
1609			; 
1609			;;	cp '6' 
1609			;;	jp z, .menutest 
1609			;;if ENABLE_BASIC 
1609			;;	cp '6' 
1609			;;	jp z, basic 
1609			;;endif 
1609			 ; 
1609			;	jp .diagmenu 
1609			; 
1609			; 
1609			;	ret 
1609			 
1609			 
1609			.debug_tog: 
1609 21 50 16			ld hl, .menudebug 
160c				 
160c 3a 94 ef			ld a, (os_view_disable) 
160f fe 2a			cp '*' 
1611 20 04			jr nz,.tdon  
1613 3e 01			ld a, 1 
1615 18 02			jr .tog1 
1617 3e 00		.tdon: ld a, 0 
1619			 
1619			.tog1: 
1619 cd 1a 0b			call menu 
161c fe 00			cp 0 
161e c8				ret z 
161f fe 01			cp 1    ; disable debug 
1621 28 04			jr z, .dtog0 
1623 3e 2a			ld a, '*' 
1625 18 02			jr .dtogset 
1627 3e 00		.dtog0: ld a, 0 
1629 32 94 ef		.dtogset:  ld (os_view_disable), a 
162c c3 09 16			jp .debug_tog 
162f			 
162f			 
162f			hardware_diags:       
162f			 
162f			.diagm: 
162f 21 42 16			ld hl, .menuitems 
1632 3e 00			ld a, 0 
1634 cd 1a 0b			call menu 
1637			 
1637 fe 00		         cp 0 
1639 c8				 ret z 
163a			 
163a fe 02			cp 2 
163c ca 9b 16			jp z, .diagedit 
163f			 
163f			;	cp '6' 
163f			;	jp z, .menutest 
163f			;if ENABLE_BASIC 
163f			;	cp '6' 
163f			;	jp z, basic 
163f			;endif 
163f			  
163f c3 2f 16			jp .diagm 
1642			 
1642				 
1642 56 16		.menuitems:   	dw .m1 
1644 61 16				dw .m2 
1646 68 16				dw .m3 
1648 70 16				dw .m5 
164a 76 16				dw .m5a 
164c 7f 16				dw .m5b 
164e 00 00				dw 0 
1650			 
1650			.menudebug: 
1650 88 16				dw .m6 
1652 91 16				dw .m7 
1654 00 00				dw 0 
1656			 
1656 .. 00		.m1:   db "Key Matrix",0 
1661 .. 00		.m2:   db "Editor",0 
1668 .. 00		.m3:   db "Storage",0 
1670 .. 00		.m5:   db "Sound",0 
1676 .. 00		.m5a:  db "RAM Test",0 
167f .. 00		.m5b:  db "LCD Test",0 
1688			 
1688 .. 00		.m6:   db "Debug ON",0 
1691 .. 00		.m7:   db "Debug OFF",0 
169b			 
169b			; debug editor 
169b			 
169b			.diagedit: 
169b			 
169b 21 a3 ef			ld hl, scratch 
169e			;	ld bc, 250 
169e			;	ldir 
169e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
169e 3e 00			ld a, 0 
16a0 77				ld (hl), a 
16a1 23				inc hl 
16a2 77				ld (hl), a 
16a3 23				inc hl 
16a4 77				ld (hl), a 
16a5			 
16a5 cd e9 0a		        call clear_display 
16a8 cd 0c 0b			call update_display 
16ab 3e 01			ld a, 1 
16ad 32 c3 fb			ld (hardware_diag), a 
16b0			.diloop: 
16b0 3e 00			ld a, display_row_1 
16b2 0e 00			ld c, 0 
16b4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16b6 1e 28			ld e, 40 
16b8			 
16b8 21 a3 ef			ld hl, scratch	 
16bb cd 4a 0d			call input_str 
16be			 
16be 3e 14			ld a, display_row_2 
16c0 11 a3 ef			ld de, scratch 
16c3 cd fc 0a			call str_at_display 
16c6 cd 0c 0b			call update_display 
16c9			 
16c9 c3 b0 16			jp .diloop 
16cc			 
16cc			 
16cc			; pass word in hl 
16cc			; a has display location 
16cc			display_word_at: 
16cc f5				push af 
16cd e5				push hl 
16ce 7c				ld a,h 
16cf 21 a8 f2			ld hl, os_word_scratch 
16d2 cd 1e 10			call hexout 
16d5 e1				pop hl 
16d6 7d				ld a,l 
16d7 21 aa f2			ld hl, os_word_scratch+2 
16da cd 1e 10			call hexout 
16dd 21 ac f2			ld hl, os_word_scratch+4 
16e0 3e 00			ld a,0 
16e2 77				ld (hl),a 
16e3 11 a8 f2			ld de,os_word_scratch 
16e6 f1				pop af 
16e7 cd fc 0a				call str_at_display 
16ea c9				ret 
16eb			 
16eb			display_ptr_state: 
16eb			 
16eb				; to restore afterwards 
16eb			 
16eb d5				push de 
16ec c5				push bc 
16ed e5				push hl 
16ee f5				push af 
16ef			 
16ef				; for use in here 
16ef			 
16ef			;	push bc 
16ef			;	push de 
16ef			;	push hl 
16ef			;	push af 
16ef			 
16ef cd e9 0a			call clear_display 
16f2			 
16f2 11 c5 18			ld de, .ptrstate 
16f5 3e 00			ld a, display_row_1 
16f7 cd fc 0a			call str_at_display 
16fa			 
16fa				; display debug step 
16fa			 
16fa			 
16fa 11 bd fb			ld de, debug_mark 
16fd 3e 12			ld a, display_row_1+display_cols-2 
16ff cd fc 0a			call str_at_display 
1702			 
1702				; display a 
1702 11 cf 18			ld de, .ptrcliptr 
1705 3e 14			ld a, display_row_2 
1707 cd fc 0a			call str_at_display 
170a			 
170a f1				pop af 
170b 2a ae f9			ld hl,(cli_ptr) 
170e 3e 1c			ld a, display_row_2+8 
1710 cd cc 16			call display_word_at 
1713			 
1713			 
1713				; display hl 
1713			 
1713			 
1713 11 d7 18			ld de, .ptrclioptr 
1716 3e 1e			ld a, display_row_2+10 
1718 cd fc 0a			call str_at_display 
171b			; 
171b			;	pop hl 
171b 3e 21			ld a, display_row_2+13 
171d 2a ac f9			ld hl,(cli_origptr) 
1720 cd cc 16			call display_word_at 
1723			; 
1723			;	 
1723			;	; display de 
1723			 
1723			;	ld de, .regstatede 
1723			;	ld a, display_row_3 
1723			;	call str_at_display 
1723			 
1723			;	pop de 
1723			;	ld h,d 
1723			;	ld l, e 
1723			;	ld a, display_row_3+3 
1723			;	call display_word_at 
1723			 
1723			 
1723				; display bc 
1723			 
1723			;	ld de, .regstatebc 
1723			;	ld a, display_row_3+10 
1723			;	call str_at_display 
1723			 
1723			;	pop bc 
1723			;	ld h,b 
1723			;	ld l, c 
1723			;	ld a, display_row_3+13 
1723			;	call display_word_at 
1723			 
1723			 
1723				; display dsp 
1723			 
1723			;	ld de, .regstatedsp 
1723			;	ld a, display_row_4 
1723			;	call str_at_display 
1723			 
1723				 
1723			;	ld hl,(cli_data_sp) 
1723			;	ld a, display_row_4+4 
1723			;	call display_word_at 
1723			 
1723				; display rsp 
1723			 
1723 11 06 19			ld de, .regstatersp 
1726 3e 46			ld a, display_row_4+10 
1728 cd fc 0a			call str_at_display 
172b			 
172b				 
172b 2a 94 f9			ld hl,(cli_ret_sp) 
172e 3e 4a			ld a, display_row_4+14 
1730 cd cc 16			call display_word_at 
1733			 
1733 cd 0c 0b			call update_display 
1736			 
1736 cd 66 0a			call delay1s 
1739 cd 66 0a			call delay1s 
173c cd 66 0a			call delay1s 
173f			 
173f			 
173f cd 4f 1c			call next_page_prompt 
1742			 
1742				; restore  
1742			 
1742 f1				pop af 
1743 e1				pop hl 
1744 c1				pop bc 
1745 d1				pop de 
1746 c9				ret 
1747			 
1747			break_point_state: 
1747 f5				push af 
1748			 
1748				; see if disabled 
1748			 
1748 3a 94 ef			ld a, (os_view_disable) 
174b fe 2a			cp '*' 
174d 20 02			jr nz, .bpsgo 
174f f1				pop af 
1750 c9				ret 
1751			 
1751			.bpsgo: 
1751 f1				pop af 
1752 f5				push af 
1753 22 90 ef			ld (os_view_hl), hl 
1756 ed 53 8e ef		ld (os_view_de), de 
175a ed 43 8c ef		ld (os_view_bc), bc 
175e e5				push hl 
175f 6f				ld l, a 
1760 26 00			ld h, 0 
1762 22 92 ef			ld (os_view_af),hl 
1765			 
1765 21 53 fb				ld hl, display_fb0 
1768 22 5e fa				ld (display_fb_active), hl 
176b e1				pop hl	 
176c			 
176c 3e 31			ld a, '1' 
176e fe 2a		.bps1:  cp '*' 
1770 20 03			jr nz, .bps1b 
1772 32 94 ef			ld (os_view_disable),a 
1775 fe 31		.bps1b:  cp '1' 
1777 20 14			jr nz, .bps2 
1779			 
1779				; display reg 
1779			 
1779				 
1779			 
1779 3a 92 ef			ld a, (os_view_af) 
177c 2a 90 ef			ld hl, (os_view_hl) 
177f ed 5b 8e ef		ld de, (os_view_de) 
1783 ed 4b 8c ef		ld bc, (os_view_bc) 
1787 cd 21 18			call display_reg_state 
178a c3 0d 18			jp .bpschk 
178d			 
178d fe 32		.bps2:  cp '2' 
178f 20 08			jr nz, .bps3 
1791				 
1791				; display hl 
1791 2a 90 ef			ld hl, (os_view_hl) 
1794 cd 0b 19			call display_dump_at_hl 
1797			 
1797 18 74			jr .bpschk 
1799			 
1799 fe 33		.bps3:  cp '3' 
179b 20 08			jr nz, .bps4 
179d			 
179d			        ; display de 
179d 2a 8e ef			ld hl, (os_view_de) 
17a0 cd 0b 19			call display_dump_at_hl 
17a3			 
17a3 18 68			jr .bpschk 
17a5 fe 34		.bps4:  cp '4' 
17a7 20 08			jr nz, .bps5 
17a9			 
17a9			        ; display bc 
17a9 2a 8c ef			ld hl, (os_view_bc) 
17ac cd 0b 19			call display_dump_at_hl 
17af			 
17af 18 5c			jr .bpschk 
17b1 fe 35		.bps5:  cp '5' 
17b3 20 08		        jr nz, .bps7 
17b5			 
17b5				; display cur ptr 
17b5 2a ae f9			ld hl, (cli_ptr) 
17b8 cd 0b 19			call display_dump_at_hl 
17bb			 
17bb 18 50			jr .bpschk 
17bd fe 36		.bps7:  cp '6' 
17bf 20 08			jr nz, .bps8b 
17c1				 
17c1				; display cur orig ptr 
17c1 2a ac f9			ld hl, (cli_origptr) 
17c4 cd 0b 19			call display_dump_at_hl 
17c7 18 44			jr .bpschk 
17c9 fe 37		.bps8b:  cp '7' 
17cb 20 08			jr nz, .bps9 
17cd				 
17cd				; display dsp 
17cd 2a 90 f9			ld hl, (cli_data_sp) 
17d0 cd 0b 19			call display_dump_at_hl 
17d3			 
17d3 18 38			jr .bpschk 
17d5 fe 39		.bps9:  cp '9' 
17d7 20 05			jr nz, .bps8c 
17d9				 
17d9				; display SP 
17d9			;	ld hl, sp 
17d9 cd 0b 19			call display_dump_at_hl 
17dc			 
17dc 18 2f			jr .bpschk 
17de fe 38		.bps8c:  cp '8' 
17e0 20 08			jr nz, .bps8d 
17e2				 
17e2				; display rsp 
17e2 2a 94 f9			ld hl, (cli_ret_sp) 
17e5 cd 0b 19			call display_dump_at_hl 
17e8			 
17e8 18 23			jr .bpschk 
17ea fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17ec 20 05			jr nz, .bps8 
17ee cd 45 1a			call monitor 
17f1			 
17f1 18 1a			jr .bpschk 
17f3 fe 30		.bps8:  cp '0' 
17f5 20 16			jr nz, .bpschk 
17f7			 
17f7 21 02 fb				ld hl, display_fb1 
17fa 22 5e fa				ld (display_fb_active), hl 
17fd cd 0c 0b				call update_display 
1800			 
1800				;ld a, (os_view_af) 
1800 2a 90 ef			ld hl, (os_view_hl) 
1803 ed 5b 8e ef		ld de, (os_view_de) 
1807 ed 4b 8c ef		ld bc, (os_view_bc) 
180b f1				pop af 
180c c9				ret 
180d			 
180d			.bpschk:   
180d cd 66 0a			call delay1s 
1810 3e 4f		ld a,display_row_4 + display_cols - 1 
1812 11 4d 1c		        ld de, endprg 
1815 cd fc 0a			call str_at_display 
1818 cd 0c 0b			call update_display 
181b cd 58 67			call cin_wait 
181e			 
181e c3 6e 17			jp .bps1 
1821			 
1821			 
1821			display_reg_state: 
1821			 
1821				; to restore afterwards 
1821			 
1821 d5				push de 
1822 c5				push bc 
1823 e5				push hl 
1824 f5				push af 
1825			 
1825				; for use in here 
1825			 
1825 c5				push bc 
1826 d5				push de 
1827 e5				push hl 
1828 f5				push af 
1829			 
1829 cd e9 0a			call clear_display 
182c			 
182c 11 e1 18			ld de, .regstate 
182f 3e 00			ld a, display_row_1 
1831 cd fc 0a			call str_at_display 
1834			 
1834				; display debug step 
1834			 
1834			 
1834 11 bd fb			ld de, debug_mark 
1837 3e 11			ld a, display_row_1+display_cols-3 
1839 cd fc 0a			call str_at_display 
183c			 
183c				; display a 
183c 11 fd 18			ld de, .regstatea 
183f 3e 14			ld a, display_row_2 
1841 cd fc 0a			call str_at_display 
1844			 
1844 e1				pop hl 
1845			;	ld h,0 
1845			;	ld l, a 
1845 3e 17			ld a, display_row_2+3 
1847 cd cc 16			call display_word_at 
184a			 
184a			 
184a				; display hl 
184a			 
184a			 
184a 11 f1 18			ld de, .regstatehl 
184d 3e 1e			ld a, display_row_2+10 
184f cd fc 0a			call str_at_display 
1852			 
1852 e1				pop hl 
1853 3e 21			ld a, display_row_2+13 
1855 cd cc 16			call display_word_at 
1858			 
1858				 
1858				; display de 
1858			 
1858 11 f5 18			ld de, .regstatede 
185b 3e 28			ld a, display_row_3 
185d cd fc 0a			call str_at_display 
1860			 
1860 e1				pop hl 
1861			;	ld h,d 
1861			;	ld l, e 
1861 3e 2b			ld a, display_row_3+3 
1863 cd cc 16			call display_word_at 
1866			 
1866			 
1866				; display bc 
1866			 
1866 11 f9 18			ld de, .regstatebc 
1869 3e 32			ld a, display_row_3+10 
186b cd fc 0a			call str_at_display 
186e			 
186e e1				pop hl 
186f			;	ld h,b 
186f			;	ld l, c 
186f 3e 35			ld a, display_row_3+13 
1871 cd cc 16			call display_word_at 
1874			 
1874			 
1874				; display dsp 
1874			 
1874 11 01 19			ld de, .regstatedsp 
1877 3e 3c			ld a, display_row_4 
1879 cd fc 0a			call str_at_display 
187c			 
187c				 
187c 2a 90 f9			ld hl,(cli_data_sp) 
187f 3e 40			ld a, display_row_4+4 
1881 cd cc 16			call display_word_at 
1884			 
1884				; display rsp 
1884			 
1884 11 06 19			ld de, .regstatersp 
1887 3e 46			ld a, display_row_4+10 
1889 cd fc 0a			call str_at_display 
188c			 
188c				 
188c 2a 94 f9			ld hl,(cli_ret_sp) 
188f 3e 4a			ld a, display_row_4+14 
1891 cd cc 16			call display_word_at 
1894			 
1894 cd 0c 0b			call update_display 
1897			 
1897			;	call delay1s 
1897			;	call delay1s 
1897			;	call delay1s 
1897			 
1897			 
1897			;	call next_page_prompt 
1897			 
1897				; restore  
1897			 
1897 f1				pop af 
1898 e1				pop hl 
1899 c1				pop bc 
189a d1				pop de 
189b c9				ret 
189c			 
189c .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18b0 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18c5 .. 00		.ptrstate:	db "Ptr State",0 
18cf .. 00		.ptrcliptr:     db "cli_ptr",0 
18d7 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18e1 .. 00		.regstate:	db "Reg State (1/0)",0 
18f1 .. 00		.regstatehl:	db "HL:",0 
18f5 .. 00		.regstatede:	db "DE:",0 
18f9 .. 00		.regstatebc:	db "BC:",0 
18fd .. 00		.regstatea:	db "A :",0 
1901 .. 00		.regstatedsp:	db "DSP:",0 
1906 .. 00		.regstatersp:	db "RSP:",0 
190b			 
190b			display_dump_at_hl: 
190b e5				push hl 
190c d5				push de 
190d c5				push bc 
190e f5				push af 
190f			 
190f 22 c6 f2			ld (os_cur_ptr),hl	 
1912 cd e9 0a			call clear_display 
1915 cd 57 1b			call dumpcont 
1918			;	call delay1s 
1918			;	call next_page_prompt 
1918			 
1918			 
1918 f1				pop af 
1919 c1				pop bc 
191a d1				pop de 
191b e1				pop hl 
191c c9				ret 
191d			 
191d			;if ENABLE_BASIC 
191d			;	include "nascombasic.asm" 
191d			;	basic: 
191d			;	include "forth/FORTH.ASM" 
191d			;endif 
191d			 
191d			; eof 
191d			 
191d			 
# End of file firmware_diags.asm
191d			  
191d			  
191d			  
191d			  
191d			; eof  
191d			  
# End of file firmware.asm
191d			 
191d			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
191d			;if BASE_KEV  
191d			;baseram: equ 08000h 
191d			;endif 
191d			 
191d			;if BASE_SC114 
191d			;baseram:     equ    endofcode 
191d			;endif 
191d			 
191d			 
191d			; start system 
191d			 
191d			coldstart: 
191d				; set sp 
191d				; di/ei 
191d			 
191d f3				di 
191e 31 fd ff			ld sp, tos 
1921			;	ei 
1921			 
1921			 
1921				; disable breakpoint by default 
1921			 
1921 3e 2a			ld a,'*' 
1923 32 94 ef			ld (os_view_disable),a 
1926			 
1926				; init hardware 
1926			 
1926				; init keyboard and screen hardware 
1926			 
1926 cd 03 00			call hardware_init 
1929			 
1929			 
1929				; detect if any keys are held down to enable breakpoints at start up 
1929			 
1929 cd 69 67			call cin  
192c fe 00			cp 0 
192e 28 03			jr z, .nokeys 
1930			 
1930				;call hardware_diags 
1930 cd 7d 13			call config 
1933			 
1933			;	ld de, .bpen 
1933			;	ld a, display_row_4 
1933			;	call str_at_display 
1933			;	call update_display 
1933			; 
1933			;	ld a,0 
1933			;	ld (os_view_disable),a 
1933			; 
1933			;.bpwait: 
1933			;	call cin 
1933			;	cp 0 
1933			;	jr z, .bpwait 
1933			;	jr .nokeys 
1933			; 
1933			; 
1933			;.bpen:  db "Break points enabled!",0 
1933			 
1933			 
1933			 
1933			 
1933			 
1933			 
1933			.nokeys: 
1933			 
1933			 
1933				 
1933			 
1933			;jp  testkey 
1933			 
1933			;call storage_get_block_0 
1933			; 
1933			;ld hl, 0 
1933			;ld de, store_page 
1933			;call storage_read_block 
1933			 
1933				 
1933			;ld hl, 10 
1933			;ld de, store_page 
1933			;call storage_read_block 
1933			 
1933			 
1933			 
1933			 
1933			 
1933			;stop:	nop 
1933			;	jp stop 
1933			 
1933			 
1933			 
1933			main: 
1933 cd e9 0a			call clear_display 
1936 cd 0c 0b			call update_display 
1939			 
1939			 
1939			 
1939			;	call testlcd 
1939			 
1939			 
1939			 
1939 cd 15 20			call forth_init 
193c			 
193c			 
193c			warmstart: 
193c cd eb 1f			call forth_warmstart 
193f			 
193f				; run startup word load 
193f			        ; TODO prevent this running at warmstart after crash  
193f			 
193f				if STARTUP_ENABLE 
193f					if STORAGE_SE 
193f cd 9a 64					call forth_autoload 
1942					endif 
1942 cd a9 61				call forth_startup 
1945			 
1945			 
1945				endif 
1945			 
1945				; show free memory after boot 
1945 11 df 19			ld de, freeram 
1948 3e 00			ld a, display_row_1 
194a cd fc 0a			call str_at_display 
194d			 
194d			; Or use heap_size word???? 
194d 21 89 ef			ld hl, heap_end 
1950 11 0e 80			ld de, heap_start 
1953 ed 52			sbc hl, de 
1955 e5				push hl 
1956 7c				ld a,h	         	 
1957 21 a8 f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
195a cd 1e 10			call hexout 
195d e1			   	pop hl 
195e			 
195e 7d				ld a,l 
195f 21 aa f2			ld hl, os_word_scratch+2 
1962 cd 1e 10			call hexout 
1965 21 ac f2			ld hl, os_word_scratch+4 
1968 3e 00			ld a, 0 
196a 77				ld (hl),a 
196b 11 a8 f2			ld de, os_word_scratch 
196e 3e 0d			ld a, display_row_1 + 13 
1970 cd fc 0a			call str_at_display 
1973 cd 0c 0b			call update_display 
1976			 
1976			 
1976				;call demo 
1976			 
1976			 
1976				; init scratch input area for cli commands 
1976			 
1976 21 ca f2			ld hl, os_cli_cmd 
1979 3e 00			ld a,0 
197b 77				ld (hl),a 
197c 23				inc hl 
197d 77				ld (hl),a 
197e			 
197e 3e 00			ld a,0 
1980 32 c9 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1983			 
1983 32 c6 f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1986 32 c7 f2			ld (os_cur_ptr+1),a	 
1989			 
1989 32 a8 f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
198c 32 a9 f2			ld (os_word_scratch+1),a	 
198f				 
198f			 
198f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
198f 21 ca f2			ld hl, os_cli_cmd 
1992			 
1992 3e 00			ld a, 0		 ; init cli input 
1994 77				ld (hl), a 
1995 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1997			cli: 
1997				; show cli prompt 
1997				;push af 
1997				;ld a, 0 
1997				;ld de, prompt 
1997				;call str_at_display 
1997			 
1997				;call update_display 
1997				;pop af 
1997				;inc a 
1997				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1997 0e 00			ld c, 0 
1999 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
199b 1e 28			ld e, 40 
199d			 
199d 21 ca f2			ld hl, os_cli_cmd 
19a0			 
19a0				STACKFRAME OFF $fefe $9f9f 
19a0				if DEBUG_STACK_IMB 
19a0					if OFF 
19a0						exx 
19a0						ld de, $fefe 
19a0						ld a, d 
19a0						ld hl, curframe 
19a0						call hexout 
19a0						ld a, e 
19a0						ld hl, curframe+2 
19a0						call hexout 
19a0						ld hl, $fefe 
19a0						push hl 
19a0						ld hl, $9f9f 
19a0						push hl 
19a0						exx 
19a0					endif 
19a0				endif 
19a0			endm 
# End of macro STACKFRAME
19a0			 
19a0 cd 4a 0d			call input_str 
19a3			 
19a3				STACKFRAMECHK OFF $fefe $9f9f 
19a3				if DEBUG_STACK_IMB 
19a3					if OFF 
19a3						exx 
19a3						ld hl, $9f9f 
19a3						pop de   ; $9f9f 
19a3						call cmp16 
19a3						jr nz, .spnosame 
19a3						ld hl, $fefe 
19a3						pop de   ; $fefe 
19a3						call cmp16 
19a3						jr z, .spfrsame 
19a3						.spnosame: call showsperror 
19a3						.spfrsame: nop 
19a3						exx 
19a3					endif 
19a3				endif 
19a3			endm 
# End of macro STACKFRAMECHK
19a3			 
19a3				; copy input to last command 
19a3			 
19a3 21 ca f2			ld hl, os_cli_cmd 
19a6 11 c9 f3			ld de, os_last_cmd 
19a9 01 ff 00			ld bc, 255 
19ac ed b0			ldir 
19ae			 
19ae				; wipe current buffer 
19ae			 
19ae			;	ld a, 0 
19ae			;	ld hl, os_cli_cmd 
19ae			;	ld de, os_cli_cmd+1 
19ae			;	ld bc, 254 
19ae			;	ldir 
19ae				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
19ae			;	call strcpy 
19ae			;	ld a, 0 
19ae			;	ld (hl), a 
19ae			;	inc hl 
19ae			;	ld (hl), a 
19ae			;	inc hl 
19ae			;	ld (hl), a 
19ae			 
19ae				; switch frame buffer to program  
19ae			 
19ae 21 02 fb				ld hl, display_fb1 
19b1 22 5e fa				ld (display_fb_active), hl 
19b4			 
19b4			;	nop 
19b4				STACKFRAME ON $fbfe $8f9f 
19b4				if DEBUG_STACK_IMB 
19b4					if ON 
19b4						exx 
19b4						ld de, $fbfe 
19b4						ld a, d 
19b4						ld hl, curframe 
19b4						call hexout 
19b4						ld a, e 
19b4						ld hl, curframe+2 
19b4						call hexout 
19b4						ld hl, $fbfe 
19b4						push hl 
19b4						ld hl, $8f9f 
19b4						push hl 
19b4						exx 
19b4					endif 
19b4				endif 
19b4			endm 
# End of macro STACKFRAME
19b4				; first time into the parser so pass over the current scratch pad 
19b4 21 ca f2			ld hl,os_cli_cmd 
19b7				; tokenise the entered statement(s) in HL 
19b7 cd 8e 20			call forthparse 
19ba			        ; exec forth statements in top of return stack 
19ba cd ce 20			call forthexec 
19bd				;call forthexec_cleanup 
19bd			;	call parsenext 
19bd			 
19bd				STACKFRAMECHK ON $fbfe $8f9f 
19bd				if DEBUG_STACK_IMB 
19bd					if ON 
19bd						exx 
19bd						ld hl, $8f9f 
19bd						pop de   ; $8f9f 
19bd						call cmp16 
19bd						jr nz, .spnosame 
19bd						ld hl, $fbfe 
19bd						pop de   ; $fbfe 
19bd						call cmp16 
19bd						jr z, .spfrsame 
19bd						.spnosame: call showsperror 
19bd						.spfrsame: nop 
19bd						exx 
19bd					endif 
19bd				endif 
19bd			endm 
# End of macro STACKFRAMECHK
19bd				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19bd			 
19bd 3e 3c			ld a, display_row_4 
19bf 11 f1 19			ld de, endprog 
19c2			 
19c2 cd 0c 0b			call update_display		 
19c5			 
19c5 cd 4f 1c			call next_page_prompt 
19c8			 
19c8				; switch frame buffer to cli 
19c8			 
19c8 21 53 fb				ld hl, display_fb0 
19cb 22 5e fa				ld (display_fb_active), hl 
19ce			 
19ce			 
19ce cd e9 0a		        call clear_display 
19d1 cd 0c 0b			call update_display		 
19d4			 
19d4 21 ca f2			ld hl, os_cli_cmd 
19d7			 
19d7 3e 00			ld a, 0		 ; init cli input 
19d9 77				ld (hl), a 
19da			 
19da				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19da			 
19da				; now on last line 
19da			 
19da				; TODO scroll screen up 
19da			 
19da				; TODO instead just clear screen and place at top of screen 
19da			 
19da			;	ld a, 0 
19da			;	ld (f_cursor_ptr),a 
19da			 
19da				;call clear_display 
19da				;call update_display 
19da			 
19da				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19da 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19dc c3 97 19			jp cli 
19df			 
19df .. 00		freeram: db "Free bytes: $",0 
19ed ..			asc: db "1A2F" 
19f1 .. 00		endprog: db "End prog...",0 
19fd			 
19fd			testenter2:   
19fd 21 d5 ef			ld hl,scratch+50 
1a00 22 c6 f2			ld (os_cur_ptr),hl 
1a03 c3 97 19			jp cli 
1a06			 
1a06			testenter:  
1a06			 
1a06 21 ed 19			ld hl,asc 
1a09			;	ld a,(hl) 
1a09			;	call nibble2val 
1a09 cd 74 10			call get_byte 
1a0c			 
1a0c			 
1a0c			;	ld a,(hl) 
1a0c			;	call atohex 
1a0c			 
1a0c			;	call fourehexhl 
1a0c 32 d5 ef			ld (scratch+50),a 
1a0f			 
1a0f			 
1a0f			 
1a0f 21 ef 19			ld hl,asc+2 
1a12			;	ld a, (hl) 
1a12			;	call nibble2val 
1a12 cd 74 10			call get_byte 
1a15			 
1a15			;	call fourehexhl 
1a15 32 d7 ef			ld (scratch+52),a 
1a18				 
1a18 21 d5 ef			ld hl,scratch+50 
1a1b 22 c6 f2			ld (os_cur_ptr),hl 
1a1e c3 97 19			jp cli 
1a21			 
1a21			enter:	 
1a21 3a a7 ef			ld a,(scratch+4) 
1a24 fe 00			cp 0 
1a26 28 0c			jr z, .entercont 
1a28				; no, not a null term line so has an address to work out.... 
1a28			 
1a28 21 a5 ef			ld hl,scratch+2 
1a2b cd d4 10			call get_word_hl 
1a2e			 
1a2e 22 c6 f2			ld (os_cur_ptr),hl	 
1a31 c3 97 19			jp cli 
1a34			 
1a34			 
1a34			.entercont:  
1a34			 
1a34 21 a5 ef			ld hl, scratch+2 
1a37 cd 74 10			call get_byte 
1a3a			 
1a3a 2a c6 f2		   	ld hl,(os_cur_ptr) 
1a3d 77					ld (hl),a 
1a3e 23					inc hl 
1a3f 22 c6 f2				ld (os_cur_ptr),hl 
1a42				 
1a42			; get byte  
1a42			 
1a42			 
1a42 c3 97 19			jp cli 
1a45			 
1a45			 
1a45			; basic monitor support 
1a45			 
1a45			monitor: 
1a45				;  
1a45 cd e9 0a			call clear_display 
1a48 3e 00			ld a, 0 
1a4a 11 92 1a			ld de, .monprompt 
1a4d cd fc 0a			call str_at_display 
1a50 cd 0c 0b			call update_display 
1a53			 
1a53				; get a monitor command 
1a53			 
1a53 0e 00			ld c, 0     ; entry at top left 
1a55 16 64			ld d, 100   ; max buffer size 
1a57 1e 0f			ld e, 15    ; input scroll area 
1a59 3e 00			ld a, 0     ; init string 
1a5b 21 a1 f1			ld hl, os_input 
1a5e 77				ld (hl), a 
1a5f 23				inc hl 
1a60 77				ld (hl), a 
1a61 21 a1 f1			ld hl, os_input 
1a64 3e 01			ld a, 1     ; init string 
1a66 cd 4a 0d			call input_str 
1a69			 
1a69 cd e9 0a		        call clear_display 
1a6c cd 0c 0b			call update_display		 
1a6f			 
1a6f 3a a1 f1			ld a, (os_input) 
1a72 cd 72 11			call toUpper 
1a75 fe 48		        cp 'H' 
1a77 28 6f		        jr z, .monhelp 
1a79 fe 44			cp 'D'		; dump 
1a7b ca 09 1b			jp z, .mondump	 
1a7e fe 43			cp 'C'		; dump 
1a80 ca 23 1b			jp z, .moncdump	 
1a83 fe 4d			cp 'M'		; dump 
1a85 ca 94 1a			jp z, .moneditstart 
1a88 fe 55			cp 'U'		; dump 
1a8a 28 14			jr z, .monedit	 
1a8c fe 51			cp 'Q'		; dump 
1a8e c8				ret z	 
1a8f			 
1a8f			 
1a8f				; TODO "S" to access symbol by name and not need the address 
1a8f				; TODO "F" to find a string in memory 
1a8f			 
1a8f c3 45 1a			jp monitor 
1a92			 
1a92 .. 00		.monprompt: db ">", 0 
1a94			 
1a94			.moneditstart: 
1a94				; get starting address 
1a94			 
1a94 21 a3 f1			ld hl,os_input+2 
1a97 cd d4 10			call get_word_hl 
1a9a			 
1a9a 22 c6 f2			ld (os_cur_ptr),hl	 
1a9d			 
1a9d c3 45 1a			jp monitor 
1aa0			 
1aa0			.monedit: 
1aa0				; get byte to load 
1aa0			 
1aa0 21 a3 f1			ld hl,os_input+2 
1aa3 cd 74 10			call get_byte 
1aa6			 
1aa6				; get address to update 
1aa6 2a c6 f2			ld hl, (os_cur_ptr) 
1aa9			 
1aa9				; update byte 
1aa9			 
1aa9 77				ld (hl), a 
1aaa			 
1aaa				; move to next address and save it 
1aaa			 
1aaa 23				inc hl 
1aab 22 c6 f2			ld (os_cur_ptr),hl	 
1aae			 
1aae c3 45 1a			jp monitor 
1ab1			 
1ab1			 
1ab1 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ac5 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ae1 .. 00		.monhelptext3:  db "Q-Quit",0 
1ae8			        
1ae8			.monhelp: 
1ae8 3e 00			ld a, display_row_1 
1aea 11 b1 1a		        ld de, .monhelptext1 
1aed			 
1aed cd fc 0a			call str_at_display 
1af0 3e 14			ld a, display_row_2 
1af2 11 c5 1a		        ld de, .monhelptext2 
1af5					 
1af5 cd fc 0a			call str_at_display 
1af8 3e 28			ld a, display_row_3 
1afa 11 e1 1a		        ld de, .monhelptext3 
1afd					 
1afd cd fc 0a			call str_at_display 
1b00 cd 0c 0b			call update_display		 
1b03			 
1b03 cd 4f 1c			call next_page_prompt 
1b06 c3 45 1a			jp monitor 
1b09			 
1b09			.mondump:    
1b09 21 a3 f1			ld hl,os_input+2 
1b0c cd d4 10			call get_word_hl 
1b0f			 
1b0f 22 c6 f2			ld (os_cur_ptr),hl	 
1b12 cd 57 1b			call dumpcont 
1b15 3e 3c			ld a, display_row_4 
1b17 11 f1 19			ld de, endprog 
1b1a			 
1b1a cd 0c 0b			call update_display		 
1b1d			 
1b1d cd 4f 1c			call next_page_prompt 
1b20 c3 45 1a			jp monitor 
1b23			.moncdump: 
1b23 cd 57 1b			call dumpcont 
1b26 3e 3c			ld a, display_row_4 
1b28 11 f1 19			ld de, endprog 
1b2b			 
1b2b cd 0c 0b			call update_display		 
1b2e			 
1b2e cd 4f 1c			call next_page_prompt 
1b31 c3 45 1a			jp monitor 
1b34			 
1b34			 
1b34			; TODO symbol access  
1b34			 
1b34			.symbols:     ;; A list of symbols that can be called up  
1b34 53 fb			dw display_fb0 
1b36 .. 00			db "fb0",0  
1b3a e8 f9		     	dw store_page 
1b3c .. 00			db "store_page",0 
1b47			 
1b47			 
1b47			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b47			 
1b47 3a a4 ef			ld a,(scratch+1) 
1b4a fe 00			cp 0 
1b4c 28 09			jr z, dumpcont 
1b4e			 
1b4e				; no, not a null term line so has an address to work out.... 
1b4e			 
1b4e 21 a5 ef			ld hl,scratch+2 
1b51 cd d4 10			call get_word_hl 
1b54			 
1b54 22 c6 f2			ld (os_cur_ptr),hl	 
1b57			 
1b57			 
1b57			 
1b57			dumpcont: 
1b57			 
1b57				; dump bytes at ptr 
1b57			 
1b57			 
1b57 3e 00			ld a, display_row_1 
1b59 2a 5e fa			ld hl, (display_fb_active) 
1b5c cd 1d 0d			call addatohl 
1b5f cd 87 1b			call .dumpbyterow 
1b62			 
1b62 3e 14			ld a, display_row_2 
1b64 2a 5e fa			ld hl, (display_fb_active) 
1b67 cd 1d 0d			call addatohl 
1b6a cd 87 1b			call .dumpbyterow 
1b6d			 
1b6d			 
1b6d 3e 28			ld a, display_row_3 
1b6f 2a 5e fa			ld hl, (display_fb_active) 
1b72 cd 1d 0d			call addatohl 
1b75 cd 87 1b			call .dumpbyterow 
1b78			 
1b78 3e 3c			ld a, display_row_4 
1b7a 2a 5e fa			ld hl, (display_fb_active) 
1b7d cd 1d 0d			call addatohl 
1b80 cd 87 1b			call .dumpbyterow 
1b83			 
1b83 cd 0c 0b			call update_display 
1b86			;		jp cli 
1b86 c9				ret 
1b87			 
1b87			.dumpbyterow: 
1b87			 
1b87				;push af 
1b87			 
1b87 e5				push hl 
1b88			 
1b88				; calc where to poke the ascii 
1b88			if display_cols == 20 
1b88 3e 10			ld a, 16 
1b8a			else 
1b8a				ld a, 31 
1b8a			endif 
1b8a			 
1b8a cd 1d 0d			call addatohl 
1b8d 22 a8 f2			ld (os_word_scratch),hl  		; save pos for later 
1b90			 
1b90			 
1b90			; display decoding address 
1b90 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b93			 
1b93 7c				ld a,h 
1b94 e1				pop hl 
1b95 e5				push hl 
1b96			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b96 cd 1e 10			call hexout 
1b99 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b9c			 
1b9c 7d				ld a,l 
1b9d e1				pop hl 
1b9e 23				inc hl 
1b9f 23				inc hl 
1ba0 e5				push hl 
1ba1			;	ld hl, os_word_scratch+2 
1ba1 cd 1e 10			call hexout 
1ba4 e1				pop hl 
1ba5 23				inc hl 
1ba6 23				inc hl 
1ba7				;ld hl, os_word_scratch+4 
1ba7 3e 3a			ld a, ':' 
1ba9 77				ld (hl),a 
1baa 23				inc hl 
1bab				;ld a, 0 
1bab				;ld (hl),a 
1bab				;ld de, os_word_scratch 
1bab				;pop af 
1bab				;push af 
1bab			;		ld a, display_row_2 
1bab			;		call str_at_display 
1bab			;		call update_display 
1bab			 
1bab			 
1bab			;pop af 
1bab			;	add 5 
1bab			 
1bab			if display_cols == 20 
1bab 06 04			ld b, 4 
1bad			else 
1bad				ld b, 8 
1bad			endif	 
1bad			 
1bad			.dumpbyte: 
1bad c5				push bc 
1bae e5				push hl 
1baf			 
1baf			 
1baf 2a c6 f2		   	ld hl,(os_cur_ptr) 
1bb2 7e					ld a,(hl) 
1bb3			 
1bb3					; poke the ascii to display 
1bb3 2a a8 f2				ld hl,(os_word_scratch) 
1bb6 77					ld (hl),a 
1bb7 23					inc hl 
1bb8 22 a8 f2				ld (os_word_scratch),hl 
1bbb			 
1bbb					 
1bbb			 
1bbb			 
1bbb e1					pop hl 
1bbc e5					push hl 
1bbd			 
1bbd cd 1e 10				call hexout 
1bc0			 
1bc0					 
1bc0 2a c6 f2		   	ld hl,(os_cur_ptr) 
1bc3 23				inc hl 
1bc4 22 c6 f2		   	ld (os_cur_ptr),hl 
1bc7			 
1bc7 e1					pop hl 
1bc8 23					inc hl 
1bc9 23					inc hl 
1bca 23					inc hl 
1bcb			 
1bcb			 
1bcb			 
1bcb					;ld a,0 
1bcb					;ld (os_word_scratch+2),a 
1bcb					;pop af 
1bcb					;push af 
1bcb			 
1bcb					;ld de, os_word_scratch 
1bcb					;call str_at_display 
1bcb			;		call update_display 
1bcb			;		pop af 
1bcb c1					pop bc 
1bcc c6 03				add 3 
1bce 10 dd			djnz .dumpbyte 
1bd0			 
1bd0				 
1bd0			 
1bd0 c9				ret 
1bd1			 
1bd1			jump:	 
1bd1			 
1bd1 21 a5 ef			ld hl,scratch+2 
1bd4 cd d4 10			call get_word_hl 
1bd7				;ld hl,(scratch+2) 
1bd7				;call fourehexhl 
1bd7			 
1bd7 22 c6 f2			ld (os_cur_ptr),hl	 
1bda			 
1bda e9				jp (hl) 
1bdb			 
1bdb			 
1bdb			 
1bdb			; TODO implement a basic monitor mode to start with 
1bdb			 
1bdb			 
1bdb			 
1bdb			 
1bdb			 
1bdb			 
1bdb			 
1bdb			 
1bdb			 
1bdb			; testing and demo code during development 
1bdb			 
1bdb			 
1bdb .. 00		str1: db "Enter some text...",0 
1bee .. 00		clear: db "                    ",0 
1c03			 
1c03			demo: 
1c03			 
1c03			 
1c03			 
1c03			;	call update_display 
1c03			 
1c03				; init scratch input area for testing 
1c03 21 a3 ef			ld hl, scratch	 
1c06 3e 00			ld a,0 
1c08 77				ld (hl),a 
1c09			 
1c09			 
1c09 3e 14		            LD   A, display_row_2 
1c0b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c0b 11 db 1b		            LD   DE, str1 
1c0e cd fc 0a			call str_at_display 
1c11			 
1c11			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c11			cloop:	 
1c11 3e 28		            LD   A, display_row_3 
1c13			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c13 11 ee 1b		            LD   DE, clear 
1c16			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1c16 cd fc 0a				call str_at_display 
1c19 3e 3c			ld a, display_row_4 
1c1b 11 4b 1c			ld de, prompt 
1c1e			 
1c1e cd fc 0a				call str_at_display 
1c21 cd 0c 0b			call update_display 
1c24			 
1c24 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c26 16 0a			ld d, 10 
1c28 21 a3 ef			ld hl, scratch	 
1c2b cd 4a 0d			call input_str 
1c2e			 
1c2e			;	call clear_display 
1c2e			;'	call update_display 
1c2e			 
1c2e 3e 00		            LD   A, display_row_1 
1c30			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c30 11 ee 1b		            LD   DE, clear 
1c33 cd fc 0a				call str_at_display 
1c36			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c36 3e 00		            LD   A, display_row_1 
1c38			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c38 11 a3 ef		            LD   DE, scratch 
1c3b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c3b cd fc 0a				call str_at_display 
1c3e cd 0c 0b			call update_display 
1c41			 
1c41 3e 00				ld a,0 
1c43 21 a3 ef			ld hl, scratch 
1c46 77				ld (hl),a 
1c47			 
1c47 00				nop 
1c48 c3 11 1c			jp cloop 
1c4b			 
1c4b			 
1c4b			 
1c4b			; OS Prompt 
1c4b			 
1c4b .. 00		prompt: db ">",0 
1c4d .. 00		endprg: db "?",0 
1c4f			 
1c4f			 
1c4f			; handy next page prompt 
1c4f			next_page_prompt: 
1c4f e5				push hl 
1c50 d5				push de 
1c51 f5				push af 
1c52 c5				push bc 
1c53			 
1c53 3e 4f			ld a,display_row_4 + display_cols - 1 
1c55 11 4d 1c		        ld de, endprg 
1c58 cd fc 0a			call str_at_display 
1c5b cd 0c 0b			call update_display 
1c5e cd 58 67			call cin_wait 
1c61 c1				pop bc 
1c62 f1				pop af 
1c63 d1				pop de 
1c64 e1				pop hl 
1c65			 
1c65			 
1c65 c9				ret 
1c66			 
1c66			 
1c66			; forth parser 
1c66			 
1c66			; My forth kernel 
1c66			include "forth_kernel.asm" 
1c66			; 
1c66			; kernel to the forth OS 
1c66			 
1c66			DS_TYPE_STR: equ 1     ; string type 
1c66			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c66			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c66			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c66			 
1c66			FORTH_PARSEV1: equ 0 
1c66			FORTH_PARSEV2: equ 0 
1c66			FORTH_PARSEV3: equ 0 
1c66			FORTH_PARSEV4: equ 0 
1c66			FORTH_PARSEV5: equ 1 
1c66			 
1c66			;if FORTH_PARSEV5 
1c66			;	FORTH_END_BUFFER: equ 0 
1c66			;else 
1c66			FORTH_END_BUFFER: equ 127 
1c66			;endif 
1c66			 
1c66			FORTH_TRUE: equ 1 
1c66			FORTH_FALSE: equ 0 
1c66			 
1c66			if FORTH_PARSEV4 
1c66			include "forth_stackops.asm" 
1c66			endif 
1c66			 
1c66			if FORTH_PARSEV5 
1c66			include "forth_stackopsv5.asm" 
1c66			 
1c66			; Stack operations for v5 parser on wards 
1c66			; * DATA stack 
1c66			; * LOOP stack 
1c66			; * RETURN stack 
1c66			 
1c66			 
1c66			 
1c66			FORTH_CHK_DSP_UNDER: macro 
1c66				push hl 
1c66				push de 
1c66				ld hl,(cli_data_sp) 
1c66				ld de, cli_data_stack 
1c66				call cmp16 
1c66				jp c, fault_dsp_under 
1c66				pop de 
1c66				pop hl 
1c66				endm 
1c66			 
1c66			 
1c66			FORTH_CHK_RSP_UNDER: macro 
1c66				push hl 
1c66				push de 
1c66				ld hl,(cli_ret_sp) 
1c66				ld de, cli_ret_stack 
1c66				call cmp16 
1c66				jp c, fault_rsp_under 
1c66				pop de 
1c66				pop hl 
1c66				endm 
1c66			 
1c66			FORTH_CHK_LOOP_UNDER: macro 
1c66				push hl 
1c66				push de 
1c66				ld hl,(cli_loop_sp) 
1c66				ld de, cli_loop_stack 
1c66				call cmp16 
1c66				jp c, fault_loop_under 
1c66				pop de 
1c66				pop hl 
1c66				endm 
1c66			 
1c66			FORTH_ERR_TOS_NOTSTR: macro 
1c66				; TOSO might need more for checks when used 
1c66				push af 
1c66				ld a,(hl) 
1c66				cp DS_TYPE_STR 
1c66				jp nz, type_faultn   
1c66				pop af 
1c66				endm 
1c66			 
1c66			FORTH_ERR_TOS_NOTNUM: macro 
1c66				push af 
1c66				ld a,(hl) 
1c66				cp DS_TYPE_INUM 
1c66				jp nz, type_faultn   
1c66				pop af 
1c66				endm 
1c66			 
1c66			 
1c66			; increase data stack pointer and save hl to it 
1c66				 
1c66			FORTH_DSP_NEXT: macro 
1c66				call macro_forth_dsp_next 
1c66				endm 
1c66			 
1c66			 
1c66			macro_forth_dsp_next: 
1c66				if DEBUG_FORTH_STACK_GUARD 
1c66 cd 73 62				call check_stacks 
1c69				endif 
1c69 e5				push hl 
1c6a d5				push de 
1c6b eb				ex de,hl 
1c6c 2a 90 f9			ld hl,(cli_data_sp) 
1c6f 23				inc hl 
1c70 23				inc hl 
1c71			 
1c71			; PARSEV5 
1c71 23				inc hl 
1c72 22 90 f9			ld (cli_data_sp),hl 
1c75 73				ld (hl), e 
1c76 23				inc hl 
1c77 72				ld (hl), d 
1c78 d1				pop de 
1c79 e1				pop hl 
1c7a				if DEBUG_FORTH_STACK_GUARD 
1c7a cd 73 62				call check_stacks 
1c7d				endif 
1c7d c9				ret 
1c7e			 
1c7e			 
1c7e			; increase ret stack pointer and save hl to it 
1c7e				 
1c7e			FORTH_RSP_NEXT: macro 
1c7e				call macro_forth_rsp_next 
1c7e				endm 
1c7e			 
1c7e			macro_forth_rsp_next: 
1c7e				if DEBUG_FORTH_STACK_GUARD 
1c7e cd 73 62				call check_stacks 
1c81				endif 
1c81 e5				push hl 
1c82 d5				push de 
1c83 eb				ex de,hl 
1c84 2a 94 f9			ld hl,(cli_ret_sp) 
1c87 23				inc hl 
1c88 23				inc hl 
1c89 22 94 f9			ld (cli_ret_sp),hl 
1c8c 73				ld (hl), e 
1c8d 23				inc hl 
1c8e 72				ld (hl), d 
1c8f d1				pop de 
1c90 e1				pop hl 
1c91				if DEBUG_FORTH_STACK_GUARD 
1c91 cd 73 62				call check_stacks 
1c94				endif 
1c94 c9				ret 
1c95			 
1c95			; get current ret stack pointer and save to hl  
1c95				 
1c95			FORTH_RSP_TOS: macro 
1c95				call macro_forth_rsp_tos 
1c95				endm 
1c95			 
1c95			macro_forth_rsp_tos: 
1c95				;push de 
1c95 2a 94 f9			ld hl,(cli_ret_sp) 
1c98 cd d0 1c			call loadhlptrtohl 
1c9b				;ld e, (hl) 
1c9b				;inc hl 
1c9b				;ld d, (hl) 
1c9b				;ex de, hl 
1c9b					if DEBUG_FORTH_WORDS 
1c9b			;			DMARK "RST" 
1c9b						CALLMONITOR 
1c9b cd 47 17			call break_point_state  
1c9e				endm  
# End of macro CALLMONITOR
1c9e					endif 
1c9e				;pop de 
1c9e c9				ret 
1c9f			 
1c9f			; pop ret stack pointer 
1c9f				 
1c9f			FORTH_RSP_POP: macro 
1c9f				call macro_forth_rsp_pop 
1c9f				endm 
1c9f			 
1c9f			 
1c9f			macro_forth_rsp_pop: 
1c9f				if DEBUG_FORTH_STACK_GUARD 
1c9f			;		DMARK "RPP" 
1c9f cd 73 62				call check_stacks 
1ca2					FORTH_CHK_RSP_UNDER 
1ca2 e5				push hl 
1ca3 d5				push de 
1ca4 2a 94 f9			ld hl,(cli_ret_sp) 
1ca7 11 0e f9			ld de, cli_ret_stack 
1caa cd 3b 0d			call cmp16 
1cad da 87 63			jp c, fault_rsp_under 
1cb0 d1				pop de 
1cb1 e1				pop hl 
1cb2				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cb2				endif 
1cb2 e5				push hl 
1cb3 2a 94 f9			ld hl,(cli_ret_sp) 
1cb6			 
1cb6			 
1cb6				if FORTH_ENABLE_FREE 
1cb6			 
1cb6					; get pointer 
1cb6			 
1cb6					push de 
1cb6					push hl 
1cb6			 
1cb6					ld e, (hl) 
1cb6					inc hl 
1cb6					ld d, (hl) 
1cb6			 
1cb6					ex de, hl 
1cb6					call free 
1cb6			 
1cb6					pop hl 
1cb6					pop de 
1cb6			 
1cb6			 
1cb6				endif 
1cb6			 
1cb6			 
1cb6 2b				dec hl 
1cb7 2b				dec hl 
1cb8 22 94 f9			ld (cli_ret_sp), hl 
1cbb				; do stack underflow checks 
1cbb e1				pop hl 
1cbc				if DEBUG_FORTH_STACK_GUARD 
1cbc cd 73 62				call check_stacks 
1cbf					FORTH_CHK_RSP_UNDER 
1cbf e5				push hl 
1cc0 d5				push de 
1cc1 2a 94 f9			ld hl,(cli_ret_sp) 
1cc4 11 0e f9			ld de, cli_ret_stack 
1cc7 cd 3b 0d			call cmp16 
1cca da 87 63			jp c, fault_rsp_under 
1ccd d1				pop de 
1cce e1				pop hl 
1ccf				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ccf				endif 
1ccf c9				ret 
1cd0			 
1cd0			 
1cd0			 
1cd0			; routine to load word pointed to by hl into hl 
1cd0			 
1cd0			loadhlptrtohl: 
1cd0			 
1cd0 d5				push de 
1cd1 5e				ld e, (hl) 
1cd2 23				inc hl 
1cd3 56				ld d, (hl) 
1cd4 eb				ex de, hl 
1cd5 d1				pop de 
1cd6			 
1cd6 c9				ret 
1cd7			 
1cd7			 
1cd7			 
1cd7			 
1cd7			 
1cd7			; push a number held in HL onto the data stack 
1cd7			; entry point for pushing a value when already in hl used in function above 
1cd7			 
1cd7			forth_push_numhl: 
1cd7			 
1cd7 e5				push hl    ; save value to push 
1cd8			 
1cd8			if DEBUG_FORTH_PUSH 
1cd8				; see if disabled 
1cd8			 
1cd8			 
1cd8 f5				push af 
1cd9 3a 94 ef			ld a, (os_view_disable) 
1cdc fe 2a			cp '*' 
1cde 28 34			jr z, .pskip2 
1ce0 e5				push hl 
1ce1 e5			push hl 
1ce2 cd e9 0a			call clear_display 
1ce5 e1			pop hl 
1ce6 7c				ld a,h 
1ce7 21 a8 f2			ld hl, os_word_scratch 
1cea cd 1e 10			call hexout 
1ced e1				pop hl 
1cee 7d				ld a,l 
1cef 21 aa f2			ld hl, os_word_scratch+2 
1cf2 cd 1e 10			call hexout 
1cf5			 
1cf5 21 ac f2			ld hl, os_word_scratch+4 
1cf8 3e 00			ld a,0 
1cfa 77				ld (hl),a 
1cfb 11 a8 f2			ld de,os_word_scratch 
1cfe 3e 14				ld a, display_row_2 
1d00 cd fc 0a				call str_at_display 
1d03 11 81 51			ld de, .push_num 
1d06 3e 00			ld a, display_row_1 
1d08			 
1d08 cd fc 0a				call str_at_display 
1d0b			 
1d0b			 
1d0b cd 0c 0b			call update_display 
1d0e cd 66 0a			call delay1s 
1d11 cd 66 0a			call delay1s 
1d14			.pskip2:  
1d14			 
1d14 f1				pop af 
1d15			endif	 
1d15			 
1d15			 
1d15				FORTH_DSP_NEXT 
1d15 cd 66 1c			call macro_forth_dsp_next 
1d18				endm 
# End of macro FORTH_DSP_NEXT
1d18			 
1d18 2a 90 f9			ld hl, (cli_data_sp) 
1d1b			 
1d1b				; save item type 
1d1b 3e 02			ld a,  DS_TYPE_INUM 
1d1d 77				ld (hl), a 
1d1e 23				inc hl 
1d1f			 
1d1f				; get word off stack 
1d1f d1				pop de 
1d20 7b				ld a,e 
1d21 77				ld (hl), a 
1d22 23				inc hl 
1d23 7a				ld a,d 
1d24 77				ld (hl), a 
1d25			 
1d25			if DEBUG_FORTH_PUSH 
1d25 2b				dec hl 
1d26 2b				dec hl 
1d27 2b				dec hl 
1d28						DMARK "PH5" 
1d28 f5				push af  
1d29 3a 3d 1d			ld a, (.dmark)  
1d2c 32 bd fb			ld (debug_mark),a  
1d2f 3a 3e 1d			ld a, (.dmark+1)  
1d32 32 be fb			ld (debug_mark+1),a  
1d35 3a 3f 1d			ld a, (.dmark+2)  
1d38 32 bf fb			ld (debug_mark+2),a  
1d3b 18 03			jr .pastdmark  
1d3d ..			.dmark: db "PH5"  
1d40 f1			.pastdmark: pop af  
1d41			endm  
# End of macro DMARK
1d41				CALLMONITOR 
1d41 cd 47 17			call break_point_state  
1d44				endm  
# End of macro CALLMONITOR
1d44			endif	 
1d44			 
1d44 c9				ret 
1d45			 
1d45			 
1d45			; Push a string to stack pointed to by hl 
1d45			 
1d45			forth_push_str: 
1d45			 
1d45			if DEBUG_FORTH_PUSH 
1d45						DMARK "PSQ" 
1d45 f5				push af  
1d46 3a 5a 1d			ld a, (.dmark)  
1d49 32 bd fb			ld (debug_mark),a  
1d4c 3a 5b 1d			ld a, (.dmark+1)  
1d4f 32 be fb			ld (debug_mark+1),a  
1d52 3a 5c 1d			ld a, (.dmark+2)  
1d55 32 bf fb			ld (debug_mark+2),a  
1d58 18 03			jr .pastdmark  
1d5a ..			.dmark: db "PSQ"  
1d5d f1			.pastdmark: pop af  
1d5e			endm  
# End of macro DMARK
1d5e				CALLMONITOR 
1d5e cd 47 17			call break_point_state  
1d61				endm  
# End of macro CALLMONITOR
1d61			endif	 
1d61			    
1d61 e5				push hl 
1d62 e5				push hl 
1d63			 
1d63			;	ld a, 0   ; find end of string 
1d63 cd 7b 11			call strlenz 
1d66			if DEBUG_FORTH_PUSH 
1d66						DMARK "PQ2" 
1d66 f5				push af  
1d67 3a 7b 1d			ld a, (.dmark)  
1d6a 32 bd fb			ld (debug_mark),a  
1d6d 3a 7c 1d			ld a, (.dmark+1)  
1d70 32 be fb			ld (debug_mark+1),a  
1d73 3a 7d 1d			ld a, (.dmark+2)  
1d76 32 bf fb			ld (debug_mark+2),a  
1d79 18 03			jr .pastdmark  
1d7b ..			.dmark: db "PQ2"  
1d7e f1			.pastdmark: pop af  
1d7f			endm  
# End of macro DMARK
1d7f				CALLMONITOR 
1d7f cd 47 17			call break_point_state  
1d82				endm  
# End of macro CALLMONITOR
1d82			endif	 
1d82 eb				ex de, hl 
1d83 e1				pop hl   ; get ptr to start of string 
1d84			if DEBUG_FORTH_PUSH 
1d84						DMARK "PQ3" 
1d84 f5				push af  
1d85 3a 99 1d			ld a, (.dmark)  
1d88 32 bd fb			ld (debug_mark),a  
1d8b 3a 9a 1d			ld a, (.dmark+1)  
1d8e 32 be fb			ld (debug_mark+1),a  
1d91 3a 9b 1d			ld a, (.dmark+2)  
1d94 32 bf fb			ld (debug_mark+2),a  
1d97 18 03			jr .pastdmark  
1d99 ..			.dmark: db "PQ3"  
1d9c f1			.pastdmark: pop af  
1d9d			endm  
# End of macro DMARK
1d9d				CALLMONITOR 
1d9d cd 47 17			call break_point_state  
1da0				endm  
# End of macro CALLMONITOR
1da0			endif	 
1da0 19				add hl,de 
1da1			if DEBUG_FORTH_PUSH 
1da1						DMARK "PQE" 
1da1 f5				push af  
1da2 3a b6 1d			ld a, (.dmark)  
1da5 32 bd fb			ld (debug_mark),a  
1da8 3a b7 1d			ld a, (.dmark+1)  
1dab 32 be fb			ld (debug_mark+1),a  
1dae 3a b8 1d			ld a, (.dmark+2)  
1db1 32 bf fb			ld (debug_mark+2),a  
1db4 18 03			jr .pastdmark  
1db6 ..			.dmark: db "PQE"  
1db9 f1			.pastdmark: pop af  
1dba			endm  
# End of macro DMARK
1dba				CALLMONITOR 
1dba cd 47 17			call break_point_state  
1dbd				endm  
# End of macro CALLMONITOR
1dbd			endif	 
1dbd			 
1dbd 2b				dec hl    ; see if there is an optional trailing double quote 
1dbe 7e				ld a,(hl) 
1dbf fe 22			cp '"' 
1dc1 20 03			jr nz, .strnoq 
1dc3 3e 00			ld a, 0      ; get rid of double quote 
1dc5 77				ld (hl), a 
1dc6 23			.strnoq: inc hl 
1dc7			 
1dc7 3e 00			ld a, 0 
1dc9 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1dca			 
1dca 13				inc de ; add one for the type string 
1dcb 13				inc de ; add one for null term??? 
1dcc			 
1dcc				; tos is get string pointer again 
1dcc				; de contains space to allocate 
1dcc				 
1dcc d5				push de 
1dcd			 
1dcd eb				ex de, hl 
1dce			 
1dce				;push af 
1dce			 
1dce			if DEBUG_FORTH_PUSH 
1dce						DMARK "PHm" 
1dce f5				push af  
1dcf 3a e3 1d			ld a, (.dmark)  
1dd2 32 bd fb			ld (debug_mark),a  
1dd5 3a e4 1d			ld a, (.dmark+1)  
1dd8 32 be fb			ld (debug_mark+1),a  
1ddb 3a e5 1d			ld a, (.dmark+2)  
1dde 32 bf fb			ld (debug_mark+2),a  
1de1 18 03			jr .pastdmark  
1de3 ..			.dmark: db "PHm"  
1de6 f1			.pastdmark: pop af  
1de7			endm  
# End of macro DMARK
1de7				CALLMONITOR 
1de7 cd 47 17			call break_point_state  
1dea				endm  
# End of macro CALLMONITOR
1dea			endif	 
1dea cd e4 11			call malloc	; on ret hl now contains allocated memory 
1ded				if DEBUG_FORTH_MALLOC_GUARD 
1ded cc d9 51				call z,malloc_error 
1df0				endif 
1df0			 
1df0				 
1df0 c1				pop bc    ; get length 
1df1 d1				pop de   ;  get string start    
1df2			 
1df2				; hl has destination from malloc 
1df2			 
1df2 eb				ex de, hl    ; prep for ldir 
1df3			 
1df3 d5				push de   ; save malloc area for DSP later 
1df4				;push hl   ; save malloc area for DSP later 
1df4			 
1df4			if DEBUG_FORTH_PUSH 
1df4						DMARK "PHc" 
1df4 f5				push af  
1df5 3a 09 1e			ld a, (.dmark)  
1df8 32 bd fb			ld (debug_mark),a  
1dfb 3a 0a 1e			ld a, (.dmark+1)  
1dfe 32 be fb			ld (debug_mark+1),a  
1e01 3a 0b 1e			ld a, (.dmark+2)  
1e04 32 bf fb			ld (debug_mark+2),a  
1e07 18 03			jr .pastdmark  
1e09 ..			.dmark: db "PHc"  
1e0c f1			.pastdmark: pop af  
1e0d			endm  
# End of macro DMARK
1e0d				CALLMONITOR 
1e0d cd 47 17			call break_point_state  
1e10				endm  
# End of macro CALLMONITOR
1e10			endif	 
1e10			 
1e10			 
1e10 ed b0			ldir 
1e12			 
1e12			 
1e12				; push malloc to data stack     macro?????  
1e12			 
1e12				FORTH_DSP_NEXT 
1e12 cd 66 1c			call macro_forth_dsp_next 
1e15				endm 
# End of macro FORTH_DSP_NEXT
1e15			 
1e15				; save value and type 
1e15			 
1e15 2a 90 f9			ld hl, (cli_data_sp) 
1e18			 
1e18				; save item type 
1e18 3e 01			ld a,  DS_TYPE_STR 
1e1a 77				ld (hl), a 
1e1b 23				inc hl 
1e1c			 
1e1c				; get malloc word off stack 
1e1c d1				pop de 
1e1d 73				ld (hl), e 
1e1e 23				inc hl 
1e1f 72				ld (hl), d 
1e20			 
1e20			 
1e20			 
1e20			if DEBUG_FORTH_PUSH 
1e20 2a 90 f9			ld hl, (cli_data_sp) 
1e23						DMARK "PHS" 
1e23 f5				push af  
1e24 3a 38 1e			ld a, (.dmark)  
1e27 32 bd fb			ld (debug_mark),a  
1e2a 3a 39 1e			ld a, (.dmark+1)  
1e2d 32 be fb			ld (debug_mark+1),a  
1e30 3a 3a 1e			ld a, (.dmark+2)  
1e33 32 bf fb			ld (debug_mark+2),a  
1e36 18 03			jr .pastdmark  
1e38 ..			.dmark: db "PHS"  
1e3b f1			.pastdmark: pop af  
1e3c			endm  
# End of macro DMARK
1e3c				CALLMONITOR 
1e3c cd 47 17			call break_point_state  
1e3f				endm  
# End of macro CALLMONITOR
1e3f			;	ex de,hl 
1e3f			endif	 
1e3f				; in case of spaces, skip the ptr past the copied string 
1e3f				;pop af 
1e3f				;ld (cli_origptr),hl 
1e3f			 
1e3f c9				ret 
1e40			 
1e40			 
1e40			 
1e40			; TODO ascii push input onto stack given hl to start of input 
1e40			 
1e40			; identify type 
1e40			; if starts with a " then a string 
1e40			; otherwise it is a number 
1e40			;  
1e40			; if a string 
1e40			;     scan for ending " to get length of string to malloc for + 1 
1e40			;     malloc 
1e40			;     put pointer to string on stack first byte flags as string 
1e40			; 
1e40			; else a number 
1e40			;    look for number format identifier 
1e40			;    $xx hex 
1e40			;    %xxxxx bin 
1e40			;    xxxxx decimal 
1e40			;    convert number to 16bit word.  
1e40			;    malloc word + 1 with flag to identiy as num 
1e40			;    put pointer to number on stack 
1e40			;   
1e40			;  
1e40			  
1e40			forth_apush: 
1e40				; kernel push 
1e40			 
1e40			if DEBUG_FORTH_PUSH 
1e40						DMARK "PSH" 
1e40 f5				push af  
1e41 3a 55 1e			ld a, (.dmark)  
1e44 32 bd fb			ld (debug_mark),a  
1e47 3a 56 1e			ld a, (.dmark+1)  
1e4a 32 be fb			ld (debug_mark+1),a  
1e4d 3a 57 1e			ld a, (.dmark+2)  
1e50 32 bf fb			ld (debug_mark+2),a  
1e53 18 03			jr .pastdmark  
1e55 ..			.dmark: db "PSH"  
1e58 f1			.pastdmark: pop af  
1e59			endm  
# End of macro DMARK
1e59				CALLMONITOR 
1e59 cd 47 17			call break_point_state  
1e5c				endm  
# End of macro CALLMONITOR
1e5c			endif	 
1e5c				; identify input type 
1e5c			 
1e5c 7e				ld a,(hl) 
1e5d fe 22			cp '"' 
1e5f 28 0a			jr z, .fapstr 
1e61 fe 24			cp '$' 
1e63 ca 8b 1e			jp z, .faphex 
1e66 fe 25			cp '%' 
1e68 ca 73 1e			jp z, .fapbin 
1e6b			;	cp 'b' 
1e6b			;	jp z, .fabin 
1e6b				; else decimal 
1e6b			 
1e6b				; TODO do decimal conversion 
1e6b				; decimal is stored as a 16bit word 
1e6b			 
1e6b				; by default everything is a string if type is not detected 
1e6b			.fapstr: ; 
1e6b fe 22			cp '"' 
1e6d 20 01			jr nz, .strnoqu 
1e6f 23				inc hl 
1e70			.strnoqu: 
1e70 c3 45 1d			jp forth_push_str 
1e73			 
1e73			 
1e73			 
1e73			.fapbin:    ; push a binary string.  
1e73 11 00 00			ld de, 0   ; hold a 16bit value 
1e76			 
1e76 23			.fapbinshift:	inc hl  
1e77 7e				ld a,(hl) 
1e78 fe 00			cp 0     ; done scanning  
1e7a 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e7c			 
1e7c				; left shift de 
1e7c eb				ex de, hl	 
1e7d 29				add hl, hl 
1e7e			 
1e7e				; is 1 
1e7e fe 31			cp '1' 
1e80 20 02			jr nz, .binzero 
1e82 cb 4d			bit 1, l 
1e84			.binzero: 
1e84 eb				ex de, hl	 ; save current de 
1e85 18 ef			jr .fapbinshift 
1e87			 
1e87			.fapbdone: 
1e87 eb				ex de, hl 
1e88 c3 d7 1c			jp forth_push_numhl 
1e8b			 
1e8b			 
1e8b			.faphex:   ; hex is always stored as a 16bit word 
1e8b				; skip number prefix 
1e8b 23				inc hl 
1e8c				; turn ascii into number 
1e8c cd d4 10			call get_word_hl	; ret 16bit word in hl 
1e8f			 
1e8f c3 d7 1c			jp forth_push_numhl 
1e92			 
1e92 00				 nop 
1e93			 
1e93			.fabin:   ; TODO bin conversion 
1e93			 
1e93			 
1e93 c9				ret 
1e94			 
1e94			 
1e94			; get either a string ptr or a 16bit word from the data stack 
1e94			 
1e94			FORTH_DSP: macro 
1e94				call macro_forth_dsp 
1e94				endm 
1e94			 
1e94			macro_forth_dsp: 
1e94				; data stack pointer points to current word on tos 
1e94			 
1e94 2a 90 f9			ld hl,(cli_data_sp) 
1e97			 
1e97				if DEBUG_FORTH_PUSH 
1e97						DMARK "DSP" 
1e97 f5				push af  
1e98 3a ac 1e			ld a, (.dmark)  
1e9b 32 bd fb			ld (debug_mark),a  
1e9e 3a ad 1e			ld a, (.dmark+1)  
1ea1 32 be fb			ld (debug_mark+1),a  
1ea4 3a ae 1e			ld a, (.dmark+2)  
1ea7 32 bf fb			ld (debug_mark+2),a  
1eaa 18 03			jr .pastdmark  
1eac ..			.dmark: db "DSP"  
1eaf f1			.pastdmark: pop af  
1eb0			endm  
# End of macro DMARK
1eb0			 
1eb0 cd 0e 52				call display_data_sp 
1eb3				;call break_point_state 
1eb3				;rst 030h 
1eb3				CALLMONITOR 
1eb3 cd 47 17			call break_point_state  
1eb6				endm  
# End of macro CALLMONITOR
1eb6				endif 
1eb6			 
1eb6 c9				ret 
1eb7			 
1eb7			; return hl to start of value on stack 
1eb7			 
1eb7			FORTH_DSP_VALUE: macro 
1eb7				call macro_forth_dsp_value 
1eb7				endm 
1eb7			 
1eb7			macro_forth_dsp_value: 
1eb7			 
1eb7				FORTH_DSP 
1eb7 cd 94 1e			call macro_forth_dsp 
1eba				endm 
# End of macro FORTH_DSP
1eba			 
1eba d5				push de 
1ebb			 
1ebb 23				inc hl ; skip type 
1ebc			 
1ebc 5e				ld e, (hl) 
1ebd 23				inc hl 
1ebe 56				ld d, (hl) 
1ebf eb				ex de,hl  
1ec0			 
1ec0 d1				pop de 
1ec1			 
1ec1 c9				ret 
1ec2			 
1ec2			; return hl to start of value to second item on stack 
1ec2			 
1ec2			FORTH_DSP_VALUEM1: macro 
1ec2				call macro_forth_dsp_value_m1 
1ec2				endm 
1ec2			 
1ec2			macro_forth_dsp_value_m1: 
1ec2			 
1ec2				FORTH_DSP 
1ec2 cd 94 1e			call macro_forth_dsp 
1ec5				endm 
# End of macro FORTH_DSP
1ec5			 
1ec5 2b				dec hl 
1ec6 2b				dec hl 
1ec7			;	dec hl 
1ec7			 
1ec7 d5				push de 
1ec8			 
1ec8 5e				ld e, (hl) 
1ec9 23				inc hl 
1eca 56				ld d, (hl) 
1ecb eb				ex de,hl  
1ecc			 
1ecc d1				pop de 
1ecd			 
1ecd c9				ret 
1ece			 
1ece				 
1ece			 
1ece			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ece			 
1ece			FORTH_DSP_POP: macro 
1ece				call macro_forth_dsp_pop 
1ece				endm 
1ece			 
1ece			 
1ece			; get the tos data type 
1ece			 
1ece			FORTH_DSP_TYPE:   macro 
1ece			 
1ece				;FORTH_DSP_VALUE 
1ece				FORTH_DSP 
1ece				 
1ece				; hl points to value 
1ece				; check type 
1ece			 
1ece				ld a,(hl) 
1ece			 
1ece				endm 
1ece			 
1ece			; load the tos value into hl 
1ece			 
1ece			 
1ece			FORTH_DSP_VALUEHL:  macro 
1ece				call macro_dsp_valuehl 
1ece				endm 
1ece			 
1ece			 
1ece			 
1ece			macro_dsp_valuehl: 
1ece				FORTH_DSP_VALUE 
1ece cd b7 1e			call macro_forth_dsp_value 
1ed1				endm 
# End of macro FORTH_DSP_VALUE
1ed1			 
1ed1				;FORTH_ERR_TOS_NOTNUM 
1ed1			 
1ed1				;inc hl   ; skip type id 
1ed1			 
1ed1			;	push de 
1ed1			; 
1ed1			;	ld e, (hl) 
1ed1			;	inc hl 
1ed1			;	ld d, (hl) 
1ed1			;	ex de,hl  
1ed1			 
1ed1			;	pop de 
1ed1			 
1ed1				if DEBUG_FORTH_PUSH 
1ed1						DMARK "DVL" 
1ed1 f5				push af  
1ed2 3a e6 1e			ld a, (.dmark)  
1ed5 32 bd fb			ld (debug_mark),a  
1ed8 3a e7 1e			ld a, (.dmark+1)  
1edb 32 be fb			ld (debug_mark+1),a  
1ede 3a e8 1e			ld a, (.dmark+2)  
1ee1 32 bf fb			ld (debug_mark+2),a  
1ee4 18 03			jr .pastdmark  
1ee6 ..			.dmark: db "DVL"  
1ee9 f1			.pastdmark: pop af  
1eea			endm  
# End of macro DMARK
1eea				CALLMONITOR 
1eea cd 47 17			call break_point_state  
1eed				endm  
# End of macro CALLMONITOR
1eed				endif 
1eed c9				ret 
1eee			 
1eee			forth_apushstrhl:      
1eee				; push of string requires use of cli_origptr 
1eee				; bodge use 
1eee			 
1eee				; get current cli_origptr, save, update with temp pointer  
1eee ed 5b ac f9		ld de, (cli_origptr) 
1ef2 22 ac f9			ld (cli_origptr), hl 
1ef5 d5				push de 
1ef6 cd 40 1e			call forth_apush 
1ef9 d1				pop de 
1efa ed 53 ac f9		ld (cli_origptr), de 
1efe c9			        ret	 
1eff			 
1eff			 
1eff			; increase loop stack pointer and save hl to it 
1eff				 
1eff			FORTH_LOOP_NEXT: macro 
1eff				call macro_forth_loop_next 
1eff				;nop 
1eff				endm 
1eff			 
1eff			macro_forth_loop_next: 
1eff				if DEBUG_FORTH_STACK_GUARD 
1eff cd 73 62				call check_stacks 
1f02				endif 
1f02 e5				push hl 
1f03 d5				push de 
1f04 eb				ex de,hl 
1f05 2a 92 f9			ld hl,(cli_loop_sp) 
1f08 23				inc hl 
1f09 23				inc hl 
1f0a					if DEBUG_FORTH_WORDS 
1f0a						DMARK "LNX" 
1f0a f5				push af  
1f0b 3a 1f 1f			ld a, (.dmark)  
1f0e 32 bd fb			ld (debug_mark),a  
1f11 3a 20 1f			ld a, (.dmark+1)  
1f14 32 be fb			ld (debug_mark+1),a  
1f17 3a 21 1f			ld a, (.dmark+2)  
1f1a 32 bf fb			ld (debug_mark+2),a  
1f1d 18 03			jr .pastdmark  
1f1f ..			.dmark: db "LNX"  
1f22 f1			.pastdmark: pop af  
1f23			endm  
# End of macro DMARK
1f23						CALLMONITOR 
1f23 cd 47 17			call break_point_state  
1f26				endm  
# End of macro CALLMONITOR
1f26					endif 
1f26 22 92 f9			ld (cli_loop_sp),hl 
1f29 73				ld (hl), e 
1f2a 23				inc hl 
1f2b 72				ld (hl), d 
1f2c d1				pop de    ; been reversed so save a swap on restore 
1f2d e1				pop hl 
1f2e				if DEBUG_FORTH_STACK_GUARD 
1f2e cd 73 62				call check_stacks 
1f31				endif 
1f31 c9				ret 
1f32			 
1f32			; get current ret stack pointer and save to hl  
1f32				 
1f32			FORTH_LOOP_TOS: macro 
1f32				call macro_forth_loop_tos 
1f32				endm 
1f32			 
1f32			macro_forth_loop_tos: 
1f32 d5				push de 
1f33 2a 92 f9			ld hl,(cli_loop_sp) 
1f36 5e				ld e, (hl) 
1f37 23				inc hl 
1f38 56				ld d, (hl) 
1f39 eb				ex de, hl 
1f3a d1				pop de 
1f3b c9				ret 
1f3c			 
1f3c			; pop loop stack pointer 
1f3c				 
1f3c			FORTH_LOOP_POP: macro 
1f3c				call macro_forth_loop_pop 
1f3c				endm 
1f3c			 
1f3c			 
1f3c			macro_forth_loop_pop: 
1f3c				if DEBUG_FORTH_STACK_GUARD 
1f3c					DMARK "LPP" 
1f3c f5				push af  
1f3d 3a 51 1f			ld a, (.dmark)  
1f40 32 bd fb			ld (debug_mark),a  
1f43 3a 52 1f			ld a, (.dmark+1)  
1f46 32 be fb			ld (debug_mark+1),a  
1f49 3a 53 1f			ld a, (.dmark+2)  
1f4c 32 bf fb			ld (debug_mark+2),a  
1f4f 18 03			jr .pastdmark  
1f51 ..			.dmark: db "LPP"  
1f54 f1			.pastdmark: pop af  
1f55			endm  
# End of macro DMARK
1f55 cd 73 62				call check_stacks 
1f58					FORTH_CHK_LOOP_UNDER 
1f58 e5				push hl 
1f59 d5				push de 
1f5a 2a 92 f9			ld hl,(cli_loop_sp) 
1f5d 11 0c f7			ld de, cli_loop_stack 
1f60 cd 3b 0d			call cmp16 
1f63 da 8d 63			jp c, fault_loop_under 
1f66 d1				pop de 
1f67 e1				pop hl 
1f68				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f68				endif 
1f68 e5				push hl 
1f69 2a 92 f9			ld hl,(cli_loop_sp) 
1f6c 2b				dec hl 
1f6d 2b				dec hl 
1f6e 22 92 f9			ld (cli_loop_sp), hl 
1f71				; TODO do stack underflow checks 
1f71 e1				pop hl 
1f72				if DEBUG_FORTH_STACK_GUARD 
1f72 cd 73 62				call check_stacks 
1f75					FORTH_CHK_LOOP_UNDER 
1f75 e5				push hl 
1f76 d5				push de 
1f77 2a 92 f9			ld hl,(cli_loop_sp) 
1f7a 11 0c f7			ld de, cli_loop_stack 
1f7d cd 3b 0d			call cmp16 
1f80 da 8d 63			jp c, fault_loop_under 
1f83 d1				pop de 
1f84 e1				pop hl 
1f85				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f85				endif 
1f85 c9				ret 
1f86			 
1f86			macro_forth_dsp_pop: 
1f86			 
1f86 e5				push hl 
1f87			 
1f87				; release malloc data 
1f87			 
1f87				if DEBUG_FORTH_STACK_GUARD 
1f87 cd 73 62				call check_stacks 
1f8a					FORTH_CHK_DSP_UNDER 
1f8a e5				push hl 
1f8b d5				push de 
1f8c 2a 90 f9			ld hl,(cli_data_sp) 
1f8f 11 0a f5			ld de, cli_data_stack 
1f92 cd 3b 0d			call cmp16 
1f95 da 81 63			jp c, fault_dsp_under 
1f98 d1				pop de 
1f99 e1				pop hl 
1f9a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f9a				endif 
1f9a				;ld hl,(cli_data_sp) 
1f9a			if DEBUG_FORTH_DOT 
1f9a				DMARK "DPP" 
1f9a				CALLMONITOR 
1f9a			endif	 
1f9a			 
1f9a			 
1f9a			if FORTH_ENABLE_DSPPOPFREE 
1f9a			 
1f9a				FORTH_DSP 
1f9a cd 94 1e			call macro_forth_dsp 
1f9d				endm 
# End of macro FORTH_DSP
1f9d			 
1f9d 7e				ld a, (hl) 
1f9e fe 01			cp DS_TYPE_STR 
1fa0 20 07			jr nz, .skippopfree 
1fa2			 
1fa2				FORTH_DSP_VALUEHL 
1fa2 cd ce 1e			call macro_dsp_valuehl 
1fa5				endm 
# End of macro FORTH_DSP_VALUEHL
1fa5 00				nop 
1fa6			if DEBUG_FORTH_DOT 
1fa6				DMARK "DPf" 
1fa6				CALLMONITOR 
1fa6			endif	 
1fa6 cd ae 12			call free 
1fa9			.skippopfree: 
1fa9				 
1fa9			 
1fa9			endif 
1fa9			 
1fa9			if DEBUG_FORTH_DOT_KEY 
1fa9				DMARK "DP2" 
1fa9				CALLMONITOR 
1fa9			endif	 
1fa9			 
1fa9				; move pointer down 
1fa9			 
1fa9 2a 90 f9			ld hl,(cli_data_sp) 
1fac 2b				dec hl 
1fad 2b				dec hl 
1fae			; PARSEV5 
1fae 2b				dec hl 
1faf 22 90 f9			ld (cli_data_sp), hl 
1fb2			 
1fb2				if DEBUG_FORTH_STACK_GUARD 
1fb2 cd 73 62				call check_stacks 
1fb5					FORTH_CHK_DSP_UNDER 
1fb5 e5				push hl 
1fb6 d5				push de 
1fb7 2a 90 f9			ld hl,(cli_data_sp) 
1fba 11 0a f5			ld de, cli_data_stack 
1fbd cd 3b 0d			call cmp16 
1fc0 da 81 63			jp c, fault_dsp_under 
1fc3 d1				pop de 
1fc4 e1				pop hl 
1fc5				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fc5				endif 
1fc5			 
1fc5 e1				pop hl 
1fc6			 
1fc6 c9				ret 
1fc7			 
1fc7			getwordathl: 
1fc7				; hl points to an address 
1fc7				; load hl with the word at that address 
1fc7			 
1fc7 d5				push de 
1fc8			 
1fc8 5e				ld e, (hl) 
1fc9 23				inc hl 
1fca 56				ld d, (hl) 
1fcb eb				ex de, hl 
1fcc			 
1fcc d1				pop de 
1fcd c9				ret 
1fce			 
1fce			 
1fce			 
1fce			 
1fce			 
1fce			; eof 
1fce			 
# End of file forth_stackopsv5.asm
1fce			endif 
1fce			 
1fce			user_word_eol:  
1fce				; hl contains the pointer to where to create a linked list item from the end 
1fce				; of the user dict to continue on at the system word dict 
1fce				 
1fce				; poke the stub of the word list linked list to repoint to rom words 
1fce			 
1fce				; stub format 
1fce				; db   word id 
1fce				; dw    link to next word 
1fce			        ; db char length of token 
1fce				; db string + 0 term 
1fce				; db exec code....  
1fce			 
1fce 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fd0 77				ld (hl), a		; word id 
1fd1 23				inc hl 
1fd2			 
1fd2 11 98 21			ld de, sysdict 
1fd5 73				ld (hl), e		; next word link ie system dict 
1fd6 23				inc hl 
1fd7 72				ld (hl), d		; next word link ie system dict 
1fd8 23				inc hl	 
1fd9			 
1fd9			;	ld (hl), sysdict		; next word link ie system dict 
1fd9			;	inc hl 
1fd9			;	inc hl 
1fd9			 
1fd9			;	inc hl 
1fd9			;	inc hl 
1fd9			 
1fd9 3e 02			ld a, 2			; word length is 0 
1fdb 77				ld (hl), a	 
1fdc 23				inc hl 
1fdd			 
1fdd 3e 7e			ld a, '~'			; word length is 0 
1fdf 77				ld (hl), a	 
1fe0 23				inc hl 
1fe1 3e 00			ld a, 0			; save empty word 
1fe3 77				ld (hl), a 
1fe4			 
1fe4 c9				ret 
1fe5			 
1fe5				 
1fe5			 
1fe5			forthexec_cleanup: 
1fe5				FORTH_RSP_POP 
1fe5 cd 9f 1c			call macro_forth_rsp_pop 
1fe8				endm 
# End of macro FORTH_RSP_POP
1fe8 c9				ret 
1fe9			 
1fe9			forth_call_hl: 
1fe9				; taking hl 
1fe9 e5				push hl 
1fea c9				ret 
1feb			 
1feb			; this is called to reset Forth system but keep existing uwords etc 
1feb			 
1feb			forth_warmstart: 
1feb				; setup stack over/under flow checks 
1feb				if DEBUG_FORTH_STACK_GUARD 
1feb cd 59 62				call chk_stk_init 
1fee				endif 
1fee			 
1fee				; init stack pointers  - * these stacks go upwards *  
1fee 21 0e f9			ld hl, cli_ret_stack 
1ff1 22 94 f9			ld (cli_ret_sp), hl	 
1ff4				; set bottom of stack 
1ff4 3e 00			ld a,0 
1ff6 77				ld (hl),a 
1ff7 23				inc hl 
1ff8 77				ld (hl),a 
1ff9			 
1ff9 21 0a f5			ld hl, cli_data_stack 
1ffc 22 90 f9			ld (cli_data_sp), hl	 
1fff				; set bottom of stack 
1fff 3e 00			ld a,0 
2001 77				ld (hl),a 
2002 23				inc hl 
2003 77				ld (hl),a 
2004			 
2004 21 0c f7			ld hl, cli_loop_stack 
2007 22 92 f9			ld (cli_loop_sp), hl	 
200a				; set bottom of stack 
200a 3e 00			ld a,0 
200c 77				ld (hl),a 
200d 23				inc hl 
200e 77				ld (hl),a 
200f			 
200f				; init extent of current open file 
200f			 
200f 3e 00			ld a, 0 
2011 32 df f9			ld (store_openext), a 
2014			 
2014 c9				ret 
2015			 
2015			 
2015			; Cold Start - this is called to setup the whole Forth system 
2015			 
2015			forth_init: 
2015			 
2015				; setup stack over/under flow checks 
2015			 
2015			;	if DEBUG_FORTH_STACK_GUARD 
2015			;		call chk_stk_init 
2015			;	endif 
2015			 
2015				; enable auto display updates (slow.....) 
2015			 
2015 3e 01			ld a, 1 
2017 32 aa f9			ld (cli_autodisplay), a 
201a			 
201a			 
201a			 
201a				; show start up screen 
201a			 
201a cd e9 0a			call clear_display 
201d			 
201d 3e 00			ld a,0 
201f 32 cc f9			ld (f_cursor_ptr), a 
2022			 
2022				; set start of word list in start of ram - for use when creating user words 
2022			 
2022 21 00 80			ld hl, baseram 
2025 22 a0 f2			ld (os_last_new_uword), hl 
2028 cd ce 1f			call user_word_eol 
202b				 
202b			;		call display_data_sp 
202b			;		call next_page_prompt 
202b			 
202b			 
202b			 
202b			 
202b c9				ret 
202c			 
202c .. 00		.bootforth: db " Forth Kernel Init ",0 
2040			 
2040			; TODO push to stack 
2040			 
2040			;  
2040			 
2040			if FORTH_PARSEV2 
2040			 
2040			 
2040				include "forth_parserv2.asm" 
2040			 
2040			endif 
2040			 
2040			 
2040			; parse cli version 1 
2040			 
2040			if FORTH_PARSEV1 
2040			 
2040			 
2040			 
2040			      include "forth_parserv1.asm" 
2040			endif 
2040				 
2040			if FORTH_PARSEV3 
2040			 
2040			 
2040			 
2040			      include "forth_parserv3.asm" 
2040				include "forth_wordsv3.asm" 
2040			endif 
2040			 
2040			if FORTH_PARSEV4 
2040			 
2040			 
2040			 
2040			      include "forth_parserv4.asm" 
2040				include "forth_wordsv4.asm" 
2040			endif 
2040			 
2040			if FORTH_PARSEV5 
2040			 
2040			 
2040			 
2040			      include "forth_parserv5.asm" 
2040			 
2040			 
2040			; A better parser without using malloc and string copies all over the place.  
2040			; Exec in situ should be faster 
2040			 
2040			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2040			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2040			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2040			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2040			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2040			WORD_SYS_END: equ 0   ; Opcode for all user words 
2040			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2040			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2040			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2040			 
2040			; Core word preamble macro 
2040			 
2040			CWHEAD:   macro nxtword opcode lit len opflags 
2040				db WORD_SYS_CORE+opcode             
2040				; internal op code number 
2040				dw nxtword            
2040				; link to next dict word block 
2040				db len + 1 
2040				; literal length of dict word inc zero term 
2040				db lit,0              
2040				; literal dict word 
2040			        ; TODO db opflags        
2040				endm 
2040			 
2040			 
2040			NEXTW: macro  
2040				jp macro_next 
2040				endm 
2040			 
2040			macro_next: 
2040			if DEBUG_FORTH_PARSE_KEY 
2040				DMARK "NXT" 
2040				CALLMONITOR 
2040			endif	 
2040			;	inc hl  ; skip token null term  
2040 ed 4b ae f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2044 ed 5b ac f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2048 2a a4 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
204b			if DEBUG_FORTH_PARSE_KEY 
204b				DMARK "}AA" 
204b				CALLMONITOR 
204b			endif	 
204b c3 4e 21			jp execnext 
204e				;jp exec1 
204e			       
204e			 
204e			 
204e			; Another go at the parser to compile  
204e			 
204e			 
204e			; TODO rework parser to change all of the string words to byte tokens 
204e			; TODO do a search for  
204e			 
204e			; TODO first run normal parser to zero term sections 
204e			; TODO for each word do a token look up to get the op code 
204e			; TODO need some means to flag to the exec that this is a byte code form    
204e			 
204e			 
204e			forthcompile: 
204e			 
204e			; 
204e			; line parse: 
204e			;       parse raw input buffer 
204e			;       tokenise the words 
204e			;       malloc new copy (for looping etc) 
204e			;       copy to malloc + current pc in line to start of string and add line term 
204e			;       save on new rsp 
204e			; 
204e			 
204e			; hl to point to the line to tokenise 
204e			 
204e			;	push hl 
204e 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
2051			 
2051			;	ld a,0		; string term on input 
2051			;	call strlent 
2051			 
2051			;	ld (os_tok_len), hl	 ; save string length 
2051			 
2051			;if DEBUG_FORTH_TOK 
2051			;	ex de,hl		 
2051			;endif 
2051			 
2051			;	pop hl 		; get back string pointer 
2051			 
2051			if DEBUG_FORTH_TOK 
2051						DMARK "TOc" 
2051				CALLMONITOR 
2051			endif 
2051 7e			.cptoken2:    ld a,(hl) 
2052 23				inc hl 
2053 fe 7f			cp FORTH_END_BUFFER 
2055 28 29			jr z, .cptokendone2 
2057 fe 00			cp 0 
2059 28 25			jr z, .cptokendone2 
205b fe 22			cp '"' 
205d 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
205f fe 20			cp ' ' 
2061 20 ee			jr nz,  .cptoken2 
2063			 
2063			; TODO consume comments held between ( and ) 
2063			 
2063				; we have a space so change to zero term for dict match later 
2063 2b				dec hl 
2064 3e 00			ld a,0 
2066 77				ld (hl), a 
2067 23				inc hl 
2068 18 e7			jr .cptoken2 
206a				 
206a			 
206a			.cptokenstr2: 
206a				; skip all white space until either eol (because forgot to term) or end double quote 
206a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
206a				;inc hl ; skip current double quote 
206a 7e				ld a,(hl) 
206b 23				inc hl 
206c fe 22			cp '"' 
206e 28 e1			jr z, .cptoken2 
2070 fe 7f			cp FORTH_END_BUFFER 
2072 28 0c			jr z, .cptokendone2 
2074 fe 00			cp 0 
2076 28 08			jr z, .cptokendone2 
2078 fe 20			cp ' ' 
207a 28 02			jr z, .cptmp2 
207c 18 ec			jr .cptokenstr2 
207e			 
207e			.cptmp2:	; we have a space so change to zero term for dict match later 
207e				;dec hl 
207e				;ld a,"-"	; TODO remove this when working 
207e				;ld (hl), a 
207e				;inc hl 
207e 18 ea			jr .cptokenstr2 
2080			 
2080			.cptokendone2: 
2080				;inc hl 
2080 3e 7f			ld a, FORTH_END_BUFFER 
2082 77				ld (hl),a 
2083 23				inc hl 
2084 3e 21			ld a, '!' 
2086 77				ld (hl),a 
2087			 
2087 2a a4 f2			ld hl,(os_tok_ptr) 
208a			         
208a			if DEBUG_FORTH_TOK 
208a						DMARK "Tc1" 
208a				CALLMONITOR 
208a			endif 
208a			 
208a				; push exec string to top of return stack 
208a				FORTH_RSP_NEXT 
208a cd 7e 1c			call macro_forth_rsp_next 
208d				endm 
# End of macro FORTH_RSP_NEXT
208d c9				ret 
208e			 
208e			; Another go at the parser need to simplify the process 
208e			 
208e			forthparse: 
208e			 
208e			; 
208e			; line parse: 
208e			;       parse raw input buffer 
208e			;       tokenise the words 
208e			;       malloc new copy (for looping etc) 
208e			;       copy to malloc + current pc in line to start of string and add line term 
208e			;       save on new rsp 
208e			; 
208e			 
208e			; hl to point to the line to tokenise 
208e			 
208e			;	push hl 
208e 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
2091			 
2091			;	ld a,0		; string term on input 
2091			;	call strlent 
2091			 
2091			;	ld (os_tok_len), hl	 ; save string length 
2091			 
2091			;if DEBUG_FORTH_TOK 
2091			;	ex de,hl		 
2091			;endif 
2091			 
2091			;	pop hl 		; get back string pointer 
2091			 
2091			if DEBUG_FORTH_TOK 
2091						DMARK "TOK" 
2091				CALLMONITOR 
2091			endif 
2091 7e			.ptoken2:    ld a,(hl) 
2092 23				inc hl 
2093 fe 7f			cp FORTH_END_BUFFER 
2095 28 29			jr z, .ptokendone2 
2097 fe 00			cp 0 
2099 28 25			jr z, .ptokendone2 
209b fe 22			cp '"' 
209d 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
209f fe 20			cp ' ' 
20a1 20 ee			jr nz,  .ptoken2 
20a3			 
20a3			; TODO consume comments held between ( and ) 
20a3			 
20a3				; we have a space so change to zero term for dict match later 
20a3 2b				dec hl 
20a4 3e 00			ld a,0 
20a6 77				ld (hl), a 
20a7 23				inc hl 
20a8 18 e7			jr .ptoken2 
20aa				 
20aa			 
20aa			.ptokenstr2: 
20aa				; skip all white space until either eol (because forgot to term) or end double quote 
20aa			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
20aa				;inc hl ; skip current double quote 
20aa 7e				ld a,(hl) 
20ab 23				inc hl 
20ac fe 22			cp '"' 
20ae 28 e1			jr z, .ptoken2 
20b0 fe 7f			cp FORTH_END_BUFFER 
20b2 28 0c			jr z, .ptokendone2 
20b4 fe 00			cp 0 
20b6 28 08			jr z, .ptokendone2 
20b8 fe 20			cp ' ' 
20ba 28 02			jr z, .ptmp2 
20bc 18 ec			jr .ptokenstr2 
20be			 
20be			.ptmp2:	; we have a space so change to zero term for dict match later 
20be				;dec hl 
20be				;ld a,"-"	; TODO remove this when working 
20be				;ld (hl), a 
20be				;inc hl 
20be 18 ea			jr .ptokenstr2 
20c0			 
20c0			.ptokendone2: 
20c0				;inc hl 
20c0 3e 7f			ld a, FORTH_END_BUFFER 
20c2 77				ld (hl),a 
20c3 23				inc hl 
20c4 3e 21			ld a, '!' 
20c6 77				ld (hl),a 
20c7			 
20c7 2a a4 f2			ld hl,(os_tok_ptr) 
20ca			         
20ca			if DEBUG_FORTH_TOK 
20ca						DMARK "TK1" 
20ca				CALLMONITOR 
20ca			endif 
20ca			 
20ca				; push exec string to top of return stack 
20ca				FORTH_RSP_NEXT 
20ca cd 7e 1c			call macro_forth_rsp_next 
20cd				endm 
# End of macro FORTH_RSP_NEXT
20cd c9				ret 
20ce			 
20ce			; 
20ce			;	; malloc size + buffer pointer + if is loop flag 
20ce			;	ld hl,(os_tok_len) 		 ; get string length 
20ce			; 
20ce			;	ld a,l 
20ce			; 
20ce			;	cp 0			; we dont want to use a null string 
20ce			;	ret z 
20ce			; 
20ce			;;	add 3    ; prefix malloc with buffer for current word ptr 
20ce			; 
20ce			;	add 5     ; TODO when certain not over writing memory remove 
20ce			; 
20ce			;		 
20ce			; 
20ce			;if DEBUG_FORTH_TOK 
20ce			;			DMARK "TKE" 
20ce			;	CALLMONITOR 
20ce			;endif 
20ce			; 
20ce			;	ld l,a 
20ce			;	ld h,0 
20ce			;;	push hl   ; save required space for the copy later 
20ce			;	call malloc 
20ce			;if DEBUG_FORTH_TOK 
20ce			;			DMARK "TKM" 
20ce			;	CALLMONITOR 
20ce			;endif 
20ce			;	if DEBUG_FORTH_MALLOC_GUARD 
20ce			;		push af 
20ce			;		call ishlzero 
20ce			;;		ld a, l 
20ce			;;		add h 
20ce			;;		cp 0 
20ce			;		pop af 
20ce			;		 
20ce			;		call z,malloc_error 
20ce			;	endif 
20ce			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20ce			; 
20ce			; 
20ce			;if DEBUG_FORTH_TOK 
20ce			;			DMARK "TKR" 
20ce			;	CALLMONITOR 
20ce			;endif 
20ce			; 
20ce			;	FORTH_RSP_NEXT 
20ce			; 
20ce			;	;inc hl	 ; go past current buffer pointer 
20ce			;	;inc hl 
20ce			;	;inc hl   ; and past if loop flag 
20ce			;		; TODO Need to set flag  
20ce			; 
20ce			;	 
20ce			;	 
20ce			;	ex de,hl	; malloc is dest 
20ce			;	ld hl, (os_tok_len) 
20ce			;;	pop bc 
20ce			;	ld c, l                
20ce			;	ld b,0 
20ce			;	ld hl, (os_tok_ptr) 
20ce			; 
20ce			;if DEBUG_FORTH_TOK 
20ce			;			DMARK "TKT" 
20ce			;	CALLMONITOR 
20ce			;endif 
20ce			; 
20ce			;	; do str cpy 
20ce			; 
20ce			;	ldir      ; copy byte in hl to de 
20ce			; 
20ce			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20ce			; 
20ce			;if DEBUG_FORTH_TOK 
20ce			; 
20ce			;			DMARK "TKY" 
20ce			;	CALLMONITOR 
20ce			;endif 
20ce			;	;ld a,0 
20ce			;	;ld a,FORTH_END_BUFFER 
20ce			;	ex de, hl 
20ce			;	;dec hl			 ; go back over the space delim at the end of word 
20ce			;	;ld (hl),a 
20ce			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20ce			;	ld a,FORTH_END_BUFFER 
20ce			;	ld (hl),a 
20ce			;	inc hl 
20ce			;	ld a,FORTH_END_BUFFER 
20ce			;	ld (hl),a 
20ce			; 
20ce			;	; init the malloc area data 
20ce			;	; set pc for in current area 
20ce			;	;ld hl, (os_tok_malloc) 
20ce			;	;inc hl 
20ce			;	;inc hl 
20ce			;	;inc hl 
20ce			;	;ex de,hl 
20ce			;	;ld hl, (os_tok_malloc) 
20ce			;	;ld (hl),e 
20ce			;	;inc hl 
20ce			;	;ld (hl),d 
20ce			; 
20ce			; 
20ce			;	ld hl,(os_tok_malloc) 
20ce			;if DEBUG_FORTH_PARSE_KEY 
20ce			;			DMARK "TKU" 
20ce			;	CALLMONITOR 
20ce			;endif 
20ce			; 
20ce			;	ret 
20ce			 
20ce			forthexec: 
20ce			 
20ce			; line exec: 
20ce			; forth parser 
20ce			 
20ce			; 
20ce			;       get current exec line on rsp 
20ce			 
20ce				FORTH_RSP_TOS 
20ce cd 95 1c			call macro_forth_rsp_tos 
20d1				endm 
# End of macro FORTH_RSP_TOS
20d1			 
20d1			;       restore current pc - hl points to malloc of data 
20d1			 
20d1				;ld e, (hl) 
20d1				;inc hl 
20d1				;ld d, (hl) 
20d1				;ex de,hl 
20d1			 
20d1			 
20d1			exec1: 
20d1 22 a4 f2			ld (os_tok_ptr), hl 
20d4			 
20d4				; copy our PC to working vars  
20d4 22 ae f9			ld (cli_ptr), hl 
20d7 22 ac f9			ld (cli_origptr), hl 
20da			 
20da 7e				ld a,(hl) 
20db fe 7f			cp FORTH_END_BUFFER 
20dd c8				ret z 
20de			 
20de				; skip any nulls 
20de			 
20de fe 00			cp 0 
20e0 20 03			jr nz, .execword 
20e2 23				inc hl 
20e3 18 ec			jr exec1 
20e5			 
20e5			 
20e5			.execword: 
20e5			 
20e5			 
20e5			 
20e5			if DEBUG_FORTH_PARSE_KEY 
20e5						DMARK "KYQ" 
20e5				CALLMONITOR 
20e5			endif 
20e5			;       while at start of word: 
20e5			; get start of dict (in user area first) 
20e5			 
20e5 21 00 80		ld hl, baseram 
20e8			;ld hl, sysdict 
20e8 22 b0 f9		ld (cli_nextword),hl 
20eb			;           match word at pc 
20eb			;           exec word 
20eb			;           or push to dsp 
20eb			;           forward to next token 
20eb			;           if line term pop rsp and exit 
20eb			;        
20eb			 
20eb			if DEBUG_FORTH_PARSE_KEY 
20eb						DMARK "KYq" 
20eb				CALLMONITOR 
20eb			endif 
20eb			 
20eb			; 
20eb			; word comp 
20eb			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20eb			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20eb			;    move to start of word  
20eb			;    compare word to cli_token 
20eb			 
20eb			.execpnword:	; HL at start of a word in the dictionary to check 
20eb			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20eb			;	ld (cli_ptr), hl 
20eb			 
20eb 2a b0 f9			ld hl,(cli_nextword) 
20ee			 
20ee cd 91 21			call forth_tok_next 
20f1			; tok next start here 
20f1			;	; TODO skip compiled symbol for now 
20f1			;	inc hl 
20f1			; 
20f1			;	; save pointer to next word 
20f1			; 
20f1			;	; hl now points to the address of the next word pointer  
20f1			;	ld e, (hl) 
20f1			;	inc hl 
20f1			;	ld d, (hl) 
20f1			;	inc l 
20f1			; 
20f1			;	ex de,hl 
20f1			;if DEBUG_FORTH_PARSE_NEXTWORD 
20f1			;	push bc 
20f1			;	ld bc, (cli_nextword) 
20f1			;			DMARK "NXW" 
20f1			;	CALLMONITOR 
20f1			;	pop bc 
20f1			;endif 
20f1			; tok next end here 
20f1 22 b0 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
20f4 eb				ex de, hl 
20f5			 
20f5			 
20f5				; save the pointer of the current token - 1 to check against 
20f5				 
20f5 22 b4 f9			ld (cli_token), hl   
20f8				; TODO maybe remove below save if no debug 
20f8				; save token string ptr for any debug later 
20f8 23				inc hl  
20f9 22 b6 f9			ld (cli_origtoken), hl 
20fc 2b				dec hl 
20fd				; save pointer to the start of the next dictionay word 
20fd 7e				ld a,(hl)   ; get string length 
20fe 47				ld b,a 
20ff			.execpnwordinc:  
20ff 23				inc hl 
2100 10 fd			djnz .execpnwordinc 
2102 22 b2 f9			ld (cli_execword), hl      ; save start of this words code 
2105			 
2105				; now check the word token against the string being parsed 
2105			 
2105 2a b4 f9			ld hl,(cli_token) 
2108 23				inc hl     ; skip string length (use zero term instead to end) 
2109 22 b4 f9			ld (cli_token), hl 
210c			 
210c			if DEBUG_FORTH_PARSE_KEY 
210c						DMARK "KY2" 
210c			endif 
210c			if DEBUG_FORTH_PARSE_EXEC 
210c				; see if disabled 
210c			 
210c				ld a, (os_view_disable) 
210c				cp '*' 
210c				jr z, .skip 
210c			 
210c				push hl 
210c				push hl 
210c				call clear_display 
210c				ld de, .compword 
210c				ld a, display_row_1 
210c				call str_at_display 
210c				pop de 
210c				ld a, display_row_2 
210c				call str_at_display 
210c				ld hl,(cli_ptr) 
210c				ld a,(hl) 
210c			        ld hl, os_word_scratch 
210c				ld (hl),a 
210c				ld a,0 
210c				inc hl 
210c				ld (hl),a 	 
210c				ld de, os_word_scratch 
210c				ld a, display_row_2+10 
210c				call str_at_display 
210c				call update_display 
210c				ld a, 100 
210c				call aDelayInMS 
210c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
210c				call delay250ms 
210c				endif 
210c				pop hl 
210c			.skip:  
210c			endif	 
210c			.execpnchar:    ; compare char between token and string to parse 
210c			 
210c			if DEBUG_FORTH_PARSE_KEY 
210c						DMARK "Ky3" 
210c			endif 
210c			if DEBUG_FORTH_PARSE_EXEC 
210c				; see if disabled 
210c			 
210c				ld a, (os_view_disable) 
210c				cp '*' 
210c				jr z, .skip2 
210c			 
210c			;	call clear_display 
210c			ld hl,(cli_token) 
210c			ld a,(hl) 
210c			ld (os_word_scratch),a 
210c				ld hl,(cli_ptr) 
210c			ld a,(hl) 
210c				ld (os_word_scratch+1),a 
210c				ld a,0 
210c				ld (os_word_scratch+2),a 
210c				ld de,os_word_scratch 
210c				ld a,display_row_4 
210c				call str_at_display 
210c				call update_display 
210c			.skip2:  
210c			endif 
210c 2a b4 f9			ld hl,(cli_token) 
210f 7e				ld a, (hl)	 ; char in word token 
2110 23				inc hl 		; move to next char 
2111 22 b4 f9			ld (cli_token), hl ; and save it 
2114 47				ld b,a 
2115			 
2115 2a ae f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
2118 7e				ld a,(hl) 
2119 23				inc hl 
211a 22 ae f9			ld (cli_ptr), hl		; move to next char 
211d cd 72 11			call toUpper 		; make sure the input string matches case 
2120			 
2120			if DEBUG_FORTH_PARSE 
2120			endif 
2120			 
2120				; input stream end of token is a space so get rid of it 
2120			 
2120			;	cp ' ' 
2120			;	jr nz, .pnskipspace 
2120			; 
2120			;	ld a, 0		; make same term as word token term 
2120			; 
2120			;.pnskipspace: 
2120			 
2120			if DEBUG_FORTH_PARSE_KEY 
2120						DMARK "KY7" 
2120			endif 
2120 b8				cp b 
2121 c2 37 21			jp nz, .execpnskipword	 ; no match so move to next word 
2124				 
2124			;    if same 
2124			;       scan for string terms 0 for token and 32 for input 
2124			 
2124				 
2124			if DEBUG_FORTH_PARSE_KEY 
2124						DMARK "KY8" 
2124			endif 
2124			 
2124 80				add b			 
2125 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2127							; TODO need to make sure last word in zero term string is accounted for 
2127 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2129			 
2129			 
2129				; at end of both strings so both are exact match 
2129			 
2129			;       skip ptr for next word 
2129			 
2129 2a ae f9			ld hl,(cli_ptr) 	; at input string term 
212c 23				inc hl			 ; at next char 
212d 22 ae f9			ld (cli_ptr), hl     ; save for next round of the parser 
2130 22 ac f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2133				 
2133				 
2133			if DEBUG_FORTH_PARSE_KEY 
2133						DMARK "KY3" 
2133			endif 
2133			 
2133			 
2133			 
2133			;       exec code block 
2133			if DEBUG_FORTH_JP 
2133				call clear_display 
2133				call update_display 
2133				call delay1s 
2133				ld hl, (cli_execword)     ; save for next check if no match on this word 
2133				ld a,h 
2133				ld hl, os_word_scratch 
2133				call hexout 
2133				ld hl, (cli_execword)     ; save for next check if no match on this word 
2133				ld a,l 
2133				ld hl, os_word_scratch+2 
2133				call hexout 
2133				ld hl, os_word_scratch+4 
2133				ld a,0 
2133				ld (hl),a 
2133				ld de,os_word_scratch 
2133				call str_at_display 
2133					ld a, display_row_2 
2133					call str_at_display 
2133				ld de, (cli_origtoken) 
2133				ld a, display_row_1+10 
2133					call str_at_display 
2133			 
2133				ld a,display_row_1 
2133				ld de, .foundword 
2133				ld a, display_row_3 
2133				call str_at_display 
2133				call update_display 
2133				call delay1s 
2133				call delay1s 
2133				call delay1s 
2133			endif 
2133			 
2133			if DEBUG_FORTH_PARSE_KEY 
2133						DMARK "KYj" 
2133			endif 
2133				; TODO save the word pointer in this exec 
2133			 
2133 2a b2 f9			ld hl,(cli_execword) 
2136 e9				jp (hl) 
2137			 
2137			 
2137			;    if not same 
2137			;	scan for zero term 
2137			;	get ptr for next word 
2137			;	goto word comp 
2137			 
2137			.execpnskipword:	; get pointer to next word 
2137 2a b0 f9			ld hl,(cli_nextword) 
213a			 
213a 7e				ld a,(hl) 
213b fe 00			cp WORD_SYS_END 
213d			;	cp 0 
213d 28 09			jr z, .execendofdict			 ; at end of words 
213f			 
213f			if DEBUG_FORTH_PARSE_KEY 
213f						DMARK "KY4" 
213f			endif 
213f			if DEBUG_FORTH_PARSE_EXEC 
213f			 
213f				; see if disabled 
213f			 
213f				ld a, (os_view_disable) 
213f				cp '*' 
213f				jr z, .noskip 
213f			 
213f			 
213f				ld de, .nowordfound 
213f				ld a, display_row_3 
213f				call str_at_display 
213f				call update_display 
213f				ld a, 100 
213f				call aDelayInMS 
213f				 
213f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
213f					call delay250ms 
213f				endif 
213f			.noskip:  
213f			 
213f			endif	 
213f			 
213f 2a ac f9			ld hl,(cli_origptr) 
2142 22 ae f9			ld (cli_ptr),hl 
2145			 
2145			if DEBUG_FORTH_PARSE_KEY 
2145						DMARK "KY5" 
2145			endif 
2145 c3 eb 20			jp .execpnword			; else go to next word 
2148			 
2148			.execendofdict:  
2148			 
2148			if DEBUG_FORTH_PARSE_KEY 
2148						DMARK "KYe" 
2148			endif 
2148			if DEBUG_FORTH_PARSE_EXEC 
2148				; see if disabled 
2148			 
2148				ld a, (os_view_disable) 
2148				cp '*' 
2148				jr z, .ispskip 
2148			 
2148				call clear_display 
2148				call update_display 
2148				call delay1s 
2148				ld de, (cli_origptr) 
2148				ld a, display_row_1 
2148				call str_at_display 
2148				 
2148				ld de, .enddict 
2148				ld a, display_row_3 
2148				call str_at_display 
2148				call update_display 
2148				ld a, 100 
2148				call aDelayInMS 
2148				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2148				call delay1s 
2148				call delay1s 
2148				call delay1s 
2148				endif 
2148			.ispskip:  
2148				 
2148			endif	 
2148			 
2148			 
2148			 
2148				; if the word is not a keyword then must be a literal so push it to stack 
2148			 
2148			; push token to stack to end of word 
2148			 
2148				STACKFRAME ON $1efe $2f9f 
2148				if DEBUG_STACK_IMB 
2148					if ON 
2148						exx 
2148						ld de, $1efe 
2148						ld a, d 
2148						ld hl, curframe 
2148						call hexout 
2148						ld a, e 
2148						ld hl, curframe+2 
2148						call hexout 
2148						ld hl, $1efe 
2148						push hl 
2148						ld hl, $2f9f 
2148						push hl 
2148						exx 
2148					endif 
2148				endif 
2148			endm 
# End of macro STACKFRAME
2148			 
2148 2a a4 f2		ld hl,(os_tok_ptr) 
214b cd 40 1e		call forth_apush 
214e			 
214e				STACKFRAMECHK ON $1efe $2f9f 
214e				if DEBUG_STACK_IMB 
214e					if ON 
214e						exx 
214e						ld hl, $2f9f 
214e						pop de   ; $2f9f 
214e						call cmp16 
214e						jr nz, .spnosame 
214e						ld hl, $1efe 
214e						pop de   ; $1efe 
214e						call cmp16 
214e						jr z, .spfrsame 
214e						.spnosame: call showsperror 
214e						.spfrsame: nop 
214e						exx 
214e					endif 
214e				endif 
214e			endm 
# End of macro STACKFRAMECHK
214e			 
214e			execnext: 
214e			 
214e			if DEBUG_FORTH_PARSE_KEY 
214e						DMARK "KY>" 
214e			endif 
214e			; move past token to next word 
214e			 
214e 2a a4 f2		ld hl, (os_tok_ptr) 
2151 3e 00		ld a, 0 
2153 01 ff 00		ld bc, 255     ; input buffer size 
2156 ed b1		cpir 
2158			 
2158			if DEBUG_FORTH_PARSE_KEY 
2158						DMARK "KY!" 
2158				CALLMONITOR 
2158			endif	 
2158			; TODO this might place hl on the null, so will need to forward on??? 
2158			;inc hl   ; see if this gets onto the next item 
2158			 
2158			 
2158			; TODO pass a pointer to the buffer to push 
2158			; TODO call function to push 
2158			 
2158			; look for end of input 
2158			 
2158			;inc hl 
2158			;ld a,(hl) 
2158			;cp FORTH_END_BUFFER 
2158			;ret z 
2158			 
2158			 
2158 c3 d1 20		jp exec1 
215b			 
215b			 
215b			 
215b			 
215b			 
215b			 
215b			 
215b			 
215b			 
215b			findnexttok: 
215b			 
215b				; hl is pointer to move 
215b				; de is the token to locate 
215b			 
215b					if DEBUG_FORTH 
215b						DMARK "NTK" 
215b						CALLMONITOR 
215b					endif 
215b d5				push de 
215c			 
215c			.fnt1:	 
215c				; find first char of token to locate 
215c			 
215c 1a				ld a, (de) 
215d 4f				ld c,a 
215e 7e				ld a,(hl) 
215f cd 72 11			call toUpper 
2162					if DEBUG_FORTH 
2162						DMARK "NT1" 
2162						CALLMONITOR 
2162					endif 
2162 b9				cp c 
2163			 
2163 28 03			jr z, .fnt2cmpmorefirst	 
2165			 
2165				; first char not found move to next char 
2165			 
2165 23				inc hl 
2166 18 f4			jr .fnt1 
2168			 
2168			.fnt2cmpmorefirst:	 
2168				; first char of token found.  
2168			 
2168 e5				push hl     ; save start of token just in case it is the right one 
2169 d9				exx 
216a e1				pop hl        ; save it to hl' 
216b d9				exx 
216c			 
216c			 
216c			.fnt2cmpmore:	 
216c				; compare the rest 
216c				 
216c 23				inc hl 
216d 13				inc de 
216e				 
216e 1a				ld a, (de) 
216f 4f				ld c,a 
2170 7e				ld a,(hl) 
2171 cd 72 11			call toUpper 
2174			 
2174					if DEBUG_FORTH 
2174						DMARK "NT2" 
2174						CALLMONITOR 
2174					endif 
2174				; c has the token to find char 
2174				; a has the mem to scan char 
2174			 
2174 b9				cp c 
2175 28 04			jr z,.fntmatch1 
2177			 
2177				; they are not the same 
2177			 
2177					if DEBUG_FORTH 
2177						DMARK "NT3" 
2177						CALLMONITOR 
2177					endif 
2177 d1				pop de	; reset de token to look for 
2178 d5				push de 
2179 18 e1			jr .fnt1 
217b				 
217b			.fntmatch1: 
217b			 
217b				; is the same char a null which means we might have a full hit? 
217b					if DEBUG_FORTH 
217b						DMARK "NT4" 
217b						CALLMONITOR 
217b					endif 
217b			 
217b fe 00			cp 0 
217d 28 0b			jr z, .fntmatchyes 
217f			 
217f				; are we at the end of the token to find? 
217f			 
217f					if DEBUG_FORTH 
217f						DMARK "NT5" 
217f						CALLMONITOR 
217f					endif 
217f 3e 00			ld a, 0 
2181 b9				cp c 
2182			 
2182 c2 6c 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2185			 
2185					if DEBUG_FORTH 
2185						DMARK "NT6" 
2185						CALLMONITOR 
2185					endif 
2185				; token to find is exhusted but no match to stream 
2185			 
2185				; restore tok pointer and continue on 
2185 d1				pop de 
2186 d5				push de 
2187 c3 5c 21			jp .fnt1 
218a			 
218a			 
218a			.fntmatchyes: 
218a			 
218a				; hl now contains the end of the found token 
218a			 
218a				; get rid of saved token pointer to find 
218a			 
218a d1				pop de 
218b			 
218b					if DEBUG_FORTH 
218b						DMARK "NT9" 
218b						CALLMONITOR 
218b					endif 
218b			 
218b				; hl will be on the null term so forward on 
218b			 
218b				; get back the saved start of the token 
218b			 
218b d9				exx 
218c e5				push hl     ; save start of token just in case it is the right one 
218d d9				exx 
218e e1				pop hl        ; save it to hl 
218f			 
218f c9				ret 
2190			 
2190			 
2190			; LIST needs to find a specific token   
2190			; FORGET needs to find a spefici token 
2190			 
2190			; SAVE needs to find all tokens by flag 
2190			; WORDS just needs to scan through all  by flag 
2190			; UWORDS needs to scan through all by flag 
2190			 
2190			 
2190			; given hl as pointer to start of dict look up string 
2190			; return hl as pointer to start of word block 
2190			; or 0 if not found 
2190			 
2190			forth_find_tok: 
2190 c9				ret 
2191			 
2191			; given hl as pointer to dict structure 
2191			; move to the next dict block structure 
2191			 
2191			forth_tok_next: 
2191				; hl now points to the address of the next word pointer  
2191				; TODO skip compiled symbol for now 
2191			;	push de 
2191 23				inc hl 
2192 5e				ld e, (hl) 
2193 23				inc hl 
2194 56				ld d, (hl) 
2195 23				inc hl 
2196			 
2196 eb				ex de,hl 
2197			if DEBUG_FORTH_PARSE_NEXTWORD 
2197				push bc 
2197				ld bc, (cli_nextword) 
2197						DMARK "NXW" 
2197				CALLMONITOR 
2197				pop bc 
2197			endif 
2197			;	pop de	 
2197 c9				ret 
2198			 
2198			 
2198			 
2198			; eof 
# End of file forth_parserv5.asm
2198				include "forth_wordsv4.asm" 
2198			 
2198			; the core word dictionary v4 
2198			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2198			 
2198			; this is a linked list for each of the system words used 
2198			; user defined words will follow the same format but will be in ram 
2198			 
2198			 
2198			; 
2198			; 
2198			; define linked list: 
2198			; 
2198			; 1. compiled byte op code 
2198			; 2. len of text word 
2198			; 3. text word 
2198			; 4. ptr to next dictionary word 
2198			; 5. asm, calls etc for the word 
2198			; 
2198			;  if 1 == 0 then last word in dict  
2198			;   
2198			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2198			;  
2198			;  
2198			; create basic standard set of words 
2198			; 
2198			;  
2198			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2198			; 2DUP 2DROP 2SWAP  
2198			; @ C@ - get byte  
2198			; ! C! - store byte 
2198			; 0< true if less than zero 
2198			; 0= true if zero 
2198			; < >  
2198			; = true if same 
2198			; variables 
2198			 
2198			 
2198			; Hardware specific words I may need 
2198			; 
2198			; IN OUT  
2198			; calls to key util functions 
2198			; calls to hardward abstraction stuff 
2198			; easy control of frame buffers and lcd i/o 
2198			; keyboard  
2198			 
2198			 
2198			;DICT: macro 
2198			; op_code, len, word, next 
2198			;    word: 
2198			;    db op_code 
2198			;    ds word zero term 
2198			;    dw next 
2198			;    endm 
2198			 
2198			 
2198			 
2198			 
2198			; op code 1 is a flag for user define words which are to be handled differently 
2198			 
2198			 
2198			; 
2198			; 
2198			;    TODO on entry to a word this should be the expected environment 
2198			;    hl - tos value if number then held, if string this is the ptr 
2198			;    de -  
2198			 
2198			 
2198			; opcode ranges 
2198			; 0 - end of word dict 
2198			; 255 - user define words 
2198			 
2198			sysdict: 
2198			include "forth_opcodes.asm" 
2198			; op codes for forth keywords 
2198			; free to use code 0  
2198				OPCODE_HEAP: equ  1 
2198				OPCODE_EXEC: equ 2 
2198				OPCODE_DUP: equ 3 
2198				OPCODE_SWAP: equ 4 
2198				OPCODE_COLN: equ 5 
2198				OPCODE_SCOLN: equ 6 
2198				OPCODE_DROP: equ 7 
2198				OPCODE_DUP2: equ 8 
2198				OPCODE_DROP2: equ 9 
2198				OPCODE_SWAP2: equ 10 
2198				OPCODE_AT: equ 11 
2198				OPCODE_CAT: equ 12 
2198				OPCODE_BANG: equ 13 
2198				OPCODE_CBANG: equ 14 
2198				OPCODE_SCALL: equ 15 
2198				OPCODE_DEPTH: equ 16 
2198				OPCODE_OVER: equ 17 
2198				OPCODE_PAUSE: equ 18 
2198				OPCODE_PAUSES: equ 19 
2198				OPCODE_ROT: equ 20 
2198			;free to reuse	OPCODE_WORDS: equ 21 
2198			        OPCODE_NOT: equ 21 
2198				OPCODE_UWORDS: equ 22 
2198				OPCODE_BP: equ 23 
2198				OPCODE_MONITOR: equ 24  
2198				OPCODE_MALLOC: equ 25 
2198				OPCODE_FREE: equ 26 
2198				OPCODE_LIST: equ 27 
2198				OPCODE_FORGET: equ 28 
2198				OPCODE_NOP: equ 29 
2198				OPCODE_COMO: equ 30 
2198				OPCODE_COMC: equ 31 
2198			;free to reuse	OPCODE_ENDCORE: equ 32 
2198				OPCODE_AFTERSOUND: equ 33 
2198				OPCODE_GP2: equ 34 
2198				OPCODE_GP3: equ 35 
2198				OPCODE_GP4: equ 36 
2198				OPCODE_SIN: equ 37 
2198				OPCODE_SOUT: equ 38 
2198				OPCODE_SPIO: equ 39 
2198				OPCODE_SPICEH: equ 40 
2198				OPCODE_SPIOb: equ 41 
2198				OPCODE_SPII: equ 42 
2198				OPCODE_SESEL: equ 43 
2198				OPCODE_CARTDEV: equ 44 
2198			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2198				OPCODE_FB: equ 46 
2198				OPCODE_EMIT: equ 47 
2198				OPCODE_DOTH: equ 48 
2198				OPCODE_DOTF: equ 49 
2198				OPCODE_DOT: equ 50 
2198				OPCODE_CLS: equ 51 
2198				OPCODE_DRAW: equ 52 
2198				OPCODE_DUMP: equ 53 
2198				OPCODE_CDUMP: equ 54 
2198				OPCODE_DAT: equ 55 
2198				OPCODE_HOME: equ 56 
2198				OPCODE_SPACE: equ 57 
2198				OPCODE_SPACES: equ 58 
2198				OPCODE_SCROLL: equ 59 
2198				OPCODE_ATQ: equ 60 
2198				OPCODE_AUTODSP: equ 61 
2198				OPCODE_MENU: equ 62 
2198			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2198				OPCODE_THEN: equ 64 
2198				OPCODE_ELSE: equ 65 
2198				OPCODE_DO: equ 66 
2198				OPCODE_LOOP: equ 67 
2198				OPCODE_I: equ 68 
2198				OPCODE_DLOOP: equ 69  
2198				OPCODE_REPEAT: equ 70  
2198				OPCODE_UNTIL: equ 71 
2198				OPCODE_ENDFLOW: equ 72 
2198				OPCODE_WAITK: equ 73 
2198				OPCODE_ACCEPT: equ 74 
2198				OPCODE_EDIT: equ 75 
2198			;free to reuse	OPCODE_ENDKEY: equ 76 
2198				OPCODE_LZERO: equ 77 
2198				OPCODE_TZERO: equ 78 
2198				OPCODE_LESS: equ 79 
2198				OPCODE_GT: equ 80 
2198				OPCODE_EQUAL: equ 81  
2198			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2198				OPCODE_NEG: equ 83 
2198				OPCODE_DIV: equ 84 
2198				OPCODE_MUL: equ 85 
2198				OPCODE_MIN: equ 86 
2198				OPCODE_MAX: equ 87 
2198				OPCODE_RND16: equ 88 
2198				OPCODE_RND8: equ 89 
2198				OPCODE_RND: equ 90 
2198			;free to reuse	OPCODE_ENDMATHS: equ 91  
2198				OPCODE_BYNAME: equ 92 
2198				OPCODE_DIR: equ 93 
2198				OPCODE_SAVE: equ 94 
2198				OPCODE_LOAD: equ 95 
2198				OPCODE_BSAVE: equ 96 
2198				OPCODE_BLOAD: equ 97 
2198				OPCODE_SEO: equ 98  
2198				OPCODE_SEI: equ 99 
2198				OPCODE_SFREE: equ 100 
2198				OPCODE_SIZE: equ 101 
2198				OPCODE_CREATE: equ 102 
2198				OPCODE_APPEND: equ 103 
2198				OPCODE_SDEL: equ 104 
2198				OPCODE_OPEN: equ 105 
2198				OPCODE_READ: equ 106 
2198				OPCODE_EOF: equ 106 
2198				OPCODE_FORMAT: equ 107 
2198				OPCODE_LABEL: equ 108 
2198				OPCODE_LABELS: equ 109 
2198			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2198				OPCODE_UPPER: equ 111 
2198				OPCODE_LOWER: equ 112 
2198				OPCODE_SUBSTR: equ 113 
2198				OPCODE_LEFT: equ 114 
2198				OPCODE_RIGHT: equ 115 
2198				OPCODE_STR2NUM: equ 116 
2198				OPCODE_NUM2STR: equ 117 
2198				OPCODE_CONCAT: equ 118 
2198				OPCODE_FIND: equ 119 
2198				OPCODE_LEN: equ 120 
2198				OPCODE_CHAR: equ 121 
2198			; free to reuse	OPCODE_STRLEN: equ 122 
2198			; free to reuse	OPCODE_ENDSTR: equ 123 
2198				OPCODE_V0S: equ 124 
2198				OPCODE_V0Q: equ 125 
2198				OPCODE_V1S: equ 126 
2198				OPCODE_V1Q: equ 127 
2198				OPCODE_V2S: equ 128 
2198				OPCODE_V2Q: equ 129 
2198				OPCODE_V3S: equ 130 
2198				OPCODE_V3Q: equ 131 
2198			;free to reuse	OPCODE_END: equ 132 
2198				OPCODE_ZDUP: equ 133 
2198			 
2198			; eof 
# End of file forth_opcodes.asm
2198			 
2198			include "forth_words_core.asm" 
2198			 
2198			; | ## Core Words 
2198			 
2198			;if MALLOC_4 
2198			 
2198			.HEAP: 
2198				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2198 15				db WORD_SYS_CORE+OPCODE_HEAP             
2199 d7 21			dw .EXEC            
219b 05				db 4 + 1 
219c .. 00			db "HEAP",0              
21a1				endm 
# End of macro CWHEAD
21a1			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
21a1			; | | u1 - Current number of bytes in the heap 
21a1			; | | u2 - Remaining bytes left on the heap 
21a1			; | |  
21a1			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
21a1			 
21a1			 
21a1					if DEBUG_FORTH_WORDS_KEY 
21a1						DMARK "HEP" 
21a1 f5				push af  
21a2 3a b6 21			ld a, (.dmark)  
21a5 32 bd fb			ld (debug_mark),a  
21a8 3a b7 21			ld a, (.dmark+1)  
21ab 32 be fb			ld (debug_mark+1),a  
21ae 3a b8 21			ld a, (.dmark+2)  
21b1 32 bf fb			ld (debug_mark+2),a  
21b4 18 03			jr .pastdmark  
21b6 ..			.dmark: db "HEP"  
21b9 f1			.pastdmark: pop af  
21ba			endm  
# End of macro DMARK
21ba						CALLMONITOR 
21ba cd 47 17			call break_point_state  
21bd				endm  
# End of macro CALLMONITOR
21bd					endif 
21bd 2a 0a 80				ld hl, (free_list )      
21c0 11 0e 80				ld de, heap_start 
21c3			 
21c3 ed 52				sbc hl, de  
21c5			 
21c5 cd d7 1c				call forth_push_numhl 
21c8			 
21c8			 
21c8 ed 5b 0a 80			ld de, (free_list )      
21cc 21 89 ef				ld hl, heap_end 
21cf			 
21cf ed 52				sbc hl, de 
21d1			 
21d1 cd d7 1c				call forth_push_numhl 
21d4					 
21d4			 
21d4					 
21d4			 
21d4			 
21d4			 
21d4					NEXTW 
21d4 c3 40 20			jp macro_next 
21d7				endm 
# End of macro NEXTW
21d7			;endif 
21d7			 
21d7			.EXEC: 
21d7			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21d7			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21d7			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21d7			;; > > 
21d7			;; > >   
21d7			;	STACKFRAME OFF $5efe $5f9f 
21d7			; 
21d7			;		if DEBUG_FORTH_WORDS_KEY 
21d7			;			DMARK "EXE" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			; 
21d7			;	FORTH_DSP_VALUEHL 
21d7			; 
21d7			;	FORTH_DSP_POP 
21d7			; 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EX1" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			;;	ld e,(hl) 
21d7			;;	inc hl 
21d7			;;	ld d,(hl) 
21d7			;;	ex de,hl 
21d7			; 
21d7			;;		if DEBUG_FORTH_WORDS 
21d7			;;			DMARK "EX2" 
21d7			;;			CALLMONITOR 
21d7			;;		endif 
21d7			;	push hl 
21d7			; 
21d7			;	;ld a, 0 
21d7			;	;ld a, FORTH_END_BUFFER 
21d7			;	call strlenz 
21d7			;	inc hl   ; include zero term to copy 
21d7			;	inc hl   ; include term 
21d7			;	inc hl   ; include term 
21d7			;	ld b,0 
21d7			;	ld c,l 
21d7			;	pop hl 
21d7			;	ld de, execscratch 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EX3" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			;	ldir 
21d7			; 
21d7			; 
21d7			;	ld hl, execscratch 
21d7			; 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EXe" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			; 
21d7			;	call forthparse 
21d7			;	call forthexec 
21d7			;;	call forthexec_cleanup 
21d7			;;	call forthparse 
21d7			;;	call forthexec 
21d7			; 
21d7			;	STACKFRAMECHK OFF $5efe $5f9f 
21d7			; 
21d7			;	; an immediate word so no need to process any more words 
21d7			;	ret 
21d7			;	NEXTW 
21d7			 
21d7			; dead code - old version  
21d7			;	FORTH_RSP_NEXT 
21d7			 
21d7			;  
21d7			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21d7			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21d7			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21d7			;	push hl 
21d7			;	push de 
21d7			;	push bc 
21d7			; 
21d7			; 
21d7			;		if DEBUG_FORTH_WORDS_KEY 
21d7			;			DMARK "EXR" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			; 
21d7			; 
21d7			; 
21d7			;	;v5 FORTH_DSP_VALUE 
21d7			;	FORTH_DSP_VALUEHL 
21d7			; 
21d7			;	; TODO do string type checks 
21d7			; 
21d7			;;v5	inc hl   ; skip type 
21d7			; 
21d7			;	push hl  ; source code  
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EX1" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			;	ld a, 0 
21d7			;	call strlent 
21d7			; 
21d7			;	inc hl 
21d7			;	inc hl 
21d7			;	inc hl 
21d7			;	inc hl 
21d7			; 
21d7			;	push hl    ; size 
21d7			; 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EX2" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			;	call malloc 
21d7			; 
21d7			;	ex de, hl    ; de now contains malloc area 
21d7			;	pop bc   	; get byte count 
21d7			;	pop hl      ; get string to copy 
21d7			; 
21d7			;	push de     ; save malloc for free later 
21d7			; 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EX3" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			;	ldir       ; duplicate string 
21d7			; 
21d7			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21d7			;	 
21d7			;	; TODO fix the parse would be better than this...  
21d7			;	ex de, hl 
21d7			;	dec hl 
21d7			;	ld a, 0 
21d7			;	ld (hl), a 
21d7			;	dec hl 
21d7			;	ld a, ' ' 
21d7			;	ld (hl), a 
21d7			;	dec hl 
21d7			;	ld (hl), a 
21d7			; 
21d7			;	dec hl 
21d7			;	ld (hl), a 
21d7			; 
21d7			; 
21d7			;	FORTH_DSP_POP  
21d7			; 
21d7			;	pop hl     
21d7			;	push hl    ; save malloc area 
21d7			; 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EX4" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			; 
21d7			;	call forthparse 
21d7			;	call forthexec 
21d7			;	 
21d7			;	pop hl 
21d7			;	if DEBUG_FORTH_WORDS 
21d7			;		DMARK "EX5" 
21d7			;		CALLMONITOR 
21d7			;	endif 
21d7			; 
21d7			;	if FORTH_ENABLE_FREE 
21d7			;	call free 
21d7			;	endif 
21d7			; 
21d7			;	if DEBUG_FORTH_WORDS 
21d7			;		DMARK "EX6" 
21d7			;		CALLMONITOR 
21d7			;	endif 
21d7			; 
21d7			;	pop bc 
21d7			;	pop de 
21d7			;	pop hl 
21d7			;;	FORTH_RSP_POP	  
21d7			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21d7			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21d7			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21d7			; 
21d7			;	if DEBUG_FORTH_WORDS 
21d7			;		DMARK "EX7" 
21d7			;		CALLMONITOR 
21d7			;	endif 
21d7			;	NEXTW 
21d7			 
21d7			;.STKEXEC: 
21d7			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21d7			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21d7			; 
21d7			; 
21d7			;		if DEBUG_FORTH_WORDS_KEY 
21d7			;			DMARK "STX" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			; 
21d7			;	FORTH_DSP_VALUEHL 
21d7			; 
21d7			;	ld (store_tmp1), hl    ; count 
21d7			; 
21d7			;	FORTH_DSP_POP 
21d7			;.stkexec1: 
21d7			;	ld hl, (store_tmp1)   ; count 
21d7			;	ld a, 0 
21d7			;	cp l 
21d7			;	ret z 
21d7			; 
21d7			;	dec hl 
21d7			;	ld (store_tmp1), hl    ; count 
21d7			;	 
21d7			;	FORTH_DSP_VALUEHL 
21d7			;	push hl 
21d7			;	 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EXp" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			;	FORTH_DSP_POP 
21d7			; 
21d7			;	call strlenz 
21d7			;	inc hl   ; include zero term to copy 
21d7			;	inc hl   ; include zero term to copy 
21d7			;	inc hl   ; include zero term to copy 
21d7			;	ld b,0 
21d7			;	ld c,l 
21d7			;	pop hl 
21d7			;	ld de, execscratch 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EX3" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			;	ldir 
21d7			; 
21d7			; 
21d7			;	ld hl, execscratch 
21d7			; 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EXP" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			; 
21d7			;	call forthparse 
21d7			;	ld hl, execscratch 
21d7			;		if DEBUG_FORTH_WORDS 
21d7			;			DMARK "EXx" 
21d7			;			CALLMONITOR 
21d7			;		endif 
21d7			;	call forthexec 
21d7			; 
21d7			;	jp .stkexec1 
21d7			; 
21d7			;	ret 
21d7			 
21d7			 
21d7			.DUP: 
21d7				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21d7 17				db WORD_SYS_CORE+OPCODE_DUP             
21d8 4d 22			dw .ZDUP            
21da 04				db 3 + 1 
21db .. 00			db "DUP",0              
21df				endm 
# End of macro CWHEAD
21df			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21df			 
21df					if DEBUG_FORTH_WORDS_KEY 
21df						DMARK "DUP" 
21df f5				push af  
21e0 3a f4 21			ld a, (.dmark)  
21e3 32 bd fb			ld (debug_mark),a  
21e6 3a f5 21			ld a, (.dmark+1)  
21e9 32 be fb			ld (debug_mark+1),a  
21ec 3a f6 21			ld a, (.dmark+2)  
21ef 32 bf fb			ld (debug_mark+2),a  
21f2 18 03			jr .pastdmark  
21f4 ..			.dmark: db "DUP"  
21f7 f1			.pastdmark: pop af  
21f8			endm  
# End of macro DMARK
21f8						CALLMONITOR 
21f8 cd 47 17			call break_point_state  
21fb				endm  
# End of macro CALLMONITOR
21fb					endif 
21fb			 
21fb					FORTH_DSP 
21fb cd 94 1e			call macro_forth_dsp 
21fe				endm 
# End of macro FORTH_DSP
21fe			 
21fe 7e					ld a, (HL) 
21ff fe 01				cp DS_TYPE_STR 
2201 20 25				jr nz, .dupinum 
2203			 
2203					; push another string 
2203			 
2203					FORTH_DSP_VALUEHL     		 
2203 cd ce 1e			call macro_dsp_valuehl 
2206				endm 
# End of macro FORTH_DSP_VALUEHL
2206			 
2206				if DEBUG_FORTH_WORDS 
2206					DMARK "DUs" 
2206 f5				push af  
2207 3a 1b 22			ld a, (.dmark)  
220a 32 bd fb			ld (debug_mark),a  
220d 3a 1c 22			ld a, (.dmark+1)  
2210 32 be fb			ld (debug_mark+1),a  
2213 3a 1d 22			ld a, (.dmark+2)  
2216 32 bf fb			ld (debug_mark+2),a  
2219 18 03			jr .pastdmark  
221b ..			.dmark: db "DUs"  
221e f1			.pastdmark: pop af  
221f			endm  
# End of macro DMARK
221f					CALLMONITOR 
221f cd 47 17			call break_point_state  
2222				endm  
# End of macro CALLMONITOR
2222				endif 
2222 cd 45 1d				call forth_push_str 
2225			 
2225					NEXTW 
2225 c3 40 20			jp macro_next 
2228				endm 
# End of macro NEXTW
2228			 
2228			 
2228			.dupinum: 
2228					 
2228			 
2228			 
2228					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2228 cd ce 1e			call macro_dsp_valuehl 
222b				endm 
# End of macro FORTH_DSP_VALUEHL
222b			 
222b				; TODO add floating point number detection 
222b			 
222b				if DEBUG_FORTH_WORDS 
222b					DMARK "DUi" 
222b f5				push af  
222c 3a 40 22			ld a, (.dmark)  
222f 32 bd fb			ld (debug_mark),a  
2232 3a 41 22			ld a, (.dmark+1)  
2235 32 be fb			ld (debug_mark+1),a  
2238 3a 42 22			ld a, (.dmark+2)  
223b 32 bf fb			ld (debug_mark+2),a  
223e 18 03			jr .pastdmark  
2240 ..			.dmark: db "DUi"  
2243 f1			.pastdmark: pop af  
2244			endm  
# End of macro DMARK
2244					CALLMONITOR 
2244 cd 47 17			call break_point_state  
2247				endm  
# End of macro CALLMONITOR
2247				endif 
2247			 
2247 cd d7 1c				call forth_push_numhl 
224a					NEXTW 
224a c3 40 20			jp macro_next 
224d				endm 
# End of macro NEXTW
224d			.ZDUP: 
224d				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
224d 99				db WORD_SYS_CORE+OPCODE_ZDUP             
224e 85 22			dw .SWAP            
2250 05				db 4 + 1 
2251 .. 00			db "?DUP",0              
2256				endm 
# End of macro CWHEAD
2256			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2256			 
2256					if DEBUG_FORTH_WORDS_KEY 
2256						DMARK "qDU" 
2256 f5				push af  
2257 3a 6b 22			ld a, (.dmark)  
225a 32 bd fb			ld (debug_mark),a  
225d 3a 6c 22			ld a, (.dmark+1)  
2260 32 be fb			ld (debug_mark+1),a  
2263 3a 6d 22			ld a, (.dmark+2)  
2266 32 bf fb			ld (debug_mark+2),a  
2269 18 03			jr .pastdmark  
226b ..			.dmark: db "qDU"  
226e f1			.pastdmark: pop af  
226f			endm  
# End of macro DMARK
226f						CALLMONITOR 
226f cd 47 17			call break_point_state  
2272				endm  
# End of macro CALLMONITOR
2272					endif 
2272					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2272 cd ce 1e			call macro_dsp_valuehl 
2275				endm 
# End of macro FORTH_DSP_VALUEHL
2275			 
2275 e5					push hl 
2276			 
2276					; is it a zero? 
2276			 
2276 3e 00				ld a, 0 
2278 84					add h 
2279 85					add l 
227a			 
227a e1					pop hl 
227b			 
227b fe 00				cp 0 
227d 28 03				jr z, .dup2orig 
227f			 
227f			 
227f cd d7 1c				call forth_push_numhl 
2282			 
2282			 
2282				; TODO add floating point number detection 
2282			 
2282			.dup2orig: 
2282			 
2282					NEXTW 
2282 c3 40 20			jp macro_next 
2285				endm 
# End of macro NEXTW
2285			.SWAP: 
2285				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2285 18				db WORD_SYS_CORE+OPCODE_SWAP             
2286 c4 22			dw .COLN            
2288 05				db 4 + 1 
2289 .. 00			db "SWAP",0              
228e				endm 
# End of macro CWHEAD
228e			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
228e					if DEBUG_FORTH_WORDS_KEY 
228e						DMARK "SWP" 
228e f5				push af  
228f 3a a3 22			ld a, (.dmark)  
2292 32 bd fb			ld (debug_mark),a  
2295 3a a4 22			ld a, (.dmark+1)  
2298 32 be fb			ld (debug_mark+1),a  
229b 3a a5 22			ld a, (.dmark+2)  
229e 32 bf fb			ld (debug_mark+2),a  
22a1 18 03			jr .pastdmark  
22a3 ..			.dmark: db "SWP"  
22a6 f1			.pastdmark: pop af  
22a7			endm  
# End of macro DMARK
22a7						CALLMONITOR 
22a7 cd 47 17			call break_point_state  
22aa				endm  
# End of macro CALLMONITOR
22aa					endif 
22aa			 
22aa					FORTH_DSP_VALUEHL 
22aa cd ce 1e			call macro_dsp_valuehl 
22ad				endm 
# End of macro FORTH_DSP_VALUEHL
22ad e5					push hl     ; w2 
22ae			 
22ae					FORTH_DSP_POP 
22ae cd 86 1f			call macro_forth_dsp_pop 
22b1				endm 
# End of macro FORTH_DSP_POP
22b1			 
22b1					FORTH_DSP_VALUEHL 
22b1 cd ce 1e			call macro_dsp_valuehl 
22b4				endm 
# End of macro FORTH_DSP_VALUEHL
22b4			 
22b4					FORTH_DSP_POP 
22b4 cd 86 1f			call macro_forth_dsp_pop 
22b7				endm 
# End of macro FORTH_DSP_POP
22b7			 
22b7 d1					pop de     ; w2	, hl = w1 
22b8			 
22b8 eb					ex de, hl 
22b9 d5					push de 
22ba			 
22ba cd d7 1c				call forth_push_numhl 
22bd			 
22bd e1					pop hl 
22be			 
22be cd d7 1c				call forth_push_numhl 
22c1					 
22c1			 
22c1					NEXTW 
22c1 c3 40 20			jp macro_next 
22c4				endm 
# End of macro NEXTW
22c4			.COLN: 
22c4				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22c4 19				db WORD_SYS_CORE+OPCODE_COLN             
22c5 50 24			dw .SCOLN            
22c7 02				db 1 + 1 
22c8 .. 00			db ":",0              
22ca				endm 
# End of macro CWHEAD
22ca			; | : ( -- )         Create new word | DONE 
22ca			 
22ca					if DEBUG_FORTH_WORDS_KEY 
22ca						DMARK "CLN" 
22ca f5				push af  
22cb 3a df 22			ld a, (.dmark)  
22ce 32 bd fb			ld (debug_mark),a  
22d1 3a e0 22			ld a, (.dmark+1)  
22d4 32 be fb			ld (debug_mark+1),a  
22d7 3a e1 22			ld a, (.dmark+2)  
22da 32 bf fb			ld (debug_mark+2),a  
22dd 18 03			jr .pastdmark  
22df ..			.dmark: db "CLN"  
22e2 f1			.pastdmark: pop af  
22e3			endm  
# End of macro DMARK
22e3						CALLMONITOR 
22e3 cd 47 17			call break_point_state  
22e6				endm  
# End of macro CALLMONITOR
22e6					endif 
22e6				STACKFRAME OFF $8efe $989f 
22e6				if DEBUG_STACK_IMB 
22e6					if OFF 
22e6						exx 
22e6						ld de, $8efe 
22e6						ld a, d 
22e6						ld hl, curframe 
22e6						call hexout 
22e6						ld a, e 
22e6						ld hl, curframe+2 
22e6						call hexout 
22e6						ld hl, $8efe 
22e6						push hl 
22e6						ld hl, $989f 
22e6						push hl 
22e6						exx 
22e6					endif 
22e6				endif 
22e6			endm 
# End of macro STACKFRAME
22e6				; get parser buffer length  of new word 
22e6			 
22e6				 
22e6			 
22e6					; move tok past this to start of name defintition 
22e6					; TODO get word to define 
22e6					; TODO Move past word token 
22e6					; TODO get length of string up to the ';' 
22e6			 
22e6 2a a4 f2			ld hl, (os_tok_ptr) 
22e9 23				inc hl 
22ea 23				inc hl 
22eb			 
22eb 3e 3b			ld a, ';' 
22ed cd 86 11			call strlent 
22f0			 
22f0 7d				ld a,l 
22f1 32 9f ef			ld (os_new_parse_len), a 
22f4			 
22f4			 
22f4			if DEBUG_FORTH_UWORD 
22f4 ed 5b a4 f2		ld de, (os_tok_ptr) 
22f8						DMARK ":01" 
22f8 f5				push af  
22f9 3a 0d 23			ld a, (.dmark)  
22fc 32 bd fb			ld (debug_mark),a  
22ff 3a 0e 23			ld a, (.dmark+1)  
2302 32 be fb			ld (debug_mark+1),a  
2305 3a 0f 23			ld a, (.dmark+2)  
2308 32 bf fb			ld (debug_mark+2),a  
230b 18 03			jr .pastdmark  
230d ..			.dmark: db ":01"  
2310 f1			.pastdmark: pop af  
2311			endm  
# End of macro DMARK
2311				CALLMONITOR 
2311 cd 47 17			call break_point_state  
2314				endm  
# End of macro CALLMONITOR
2314			endif 
2314			 
2314			; 
2314			;  new word memory layout: 
2314			;  
2314			;    : adg 6666 ;  
2314			; 
2314			;    db   1     ; user defined word  
2314 23				inc hl    
2315			;    dw   sysdict 
2315 23				inc hl 
2316 23				inc hl 
2317			;    db <word len>+1 (for null) 
2317 23				inc hl 
2318			;    db .... <word> 
2318			; 
2318			 
2318 23				inc hl    ; some extras for the word preamble before the above 
2319 23				inc hl 
231a 23				inc hl 
231b 23				inc hl 
231c 23				inc hl 
231d 23				inc hl 
231e 23				inc hl  
231f 23				inc hl 
2320 23				inc hl 
2321 23				inc hl 
2322 23				inc hl 
2323 23				inc hl 
2324 23				inc hl 
2325 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2326			;       exec word buffer 
2326			;	<ptr word>   
2326 23				inc hl 
2327 23				inc hl 
2328			;       <word list><null term> 7F final term 
2328			 
2328			 
2328			if DEBUG_FORTH_UWORD 
2328						DMARK ":02" 
2328 f5				push af  
2329 3a 3d 23			ld a, (.dmark)  
232c 32 bd fb			ld (debug_mark),a  
232f 3a 3e 23			ld a, (.dmark+1)  
2332 32 be fb			ld (debug_mark+1),a  
2335 3a 3f 23			ld a, (.dmark+2)  
2338 32 bf fb			ld (debug_mark+2),a  
233b 18 03			jr .pastdmark  
233d ..			.dmark: db ":02"  
2340 f1			.pastdmark: pop af  
2341			endm  
# End of macro DMARK
2341				CALLMONITOR 
2341 cd 47 17			call break_point_state  
2344				endm  
# End of macro CALLMONITOR
2344			endif 
2344			 
2344				 
2344					; malloc the size 
2344			 
2344 cd e4 11				call malloc 
2347 22 a1 ef				ld (os_new_malloc), hl     ; save malloc start 
234a			 
234a			;    db   1     ; user defined word  
234a 3e 01				ld a, WORD_SYS_UWORD  
234c 77					ld (hl), a 
234d				 
234d 23				inc hl    
234e			;    dw   sysdict 
234e 11 98 21			ld de, sysdict       ; continue on with the scan to the system dict 
2351 73				ld (hl), e 
2352 23				inc hl 
2353 72				ld (hl), d 
2354 23				inc hl 
2355			 
2355			 
2355			;    Setup dict word 
2355			 
2355 23				inc hl 
2356 22 9b ef			ld (os_new_work_ptr), hl     ; save start of dict word  
2359			 
2359				; 1. get length of dict word 
2359			 
2359			 
2359 2a a4 f2			ld hl, (os_tok_ptr) 
235c 23				inc hl 
235d 23				inc hl    ; position to start of dict word 
235e 3e 00			ld a, 0 
2360 cd 86 11			call strlent 
2363			 
2363			 
2363 23				inc hl    ; to include null??? 
2364			 
2364				; write length of dict word 
2364			 
2364 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2368 1b				dec de 
2369 eb				ex de, hl 
236a 73				ld (hl), e 
236b eb				ex de, hl 
236c			 
236c				 
236c			 
236c				; copy  
236c 4d				ld c, l 
236d 06 00			ld b, 0 
236f ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2373 2a a4 f2			ld hl, (os_tok_ptr) 
2376 23				inc hl 
2377 23				inc hl    ; position to start of dict word 
2378				 
2378			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2378				 
2378				; TODO need to convert word to upper case 
2378			 
2378			ucasetok:	 
2378 7e				ld a,(hl) 
2379 cd 72 11			call toUpper 
237c 77				ld (hl),a 
237d ed a0			ldi 
237f f2 78 23		 	jp p, ucasetok 
2382			 
2382			 
2382			 
2382				; de now points to start of where the word body code should be placed 
2382 ed 53 9b ef		ld (os_new_work_ptr), de 
2386				; hl now points to the words to throw at forthexec which needs to be copied 
2386 22 99 ef			ld (os_new_src_ptr), hl 
2389			 
2389				; TODO add 'call to forthexec' 
2389			 
2389			if DEBUG_FORTH_UWORD 
2389 c5				push bc 
238a ed 4b a1 ef		ld bc, (os_new_malloc) 
238e						DMARK ":0x" 
238e f5				push af  
238f 3a a3 23			ld a, (.dmark)  
2392 32 bd fb			ld (debug_mark),a  
2395 3a a4 23			ld a, (.dmark+1)  
2398 32 be fb			ld (debug_mark+1),a  
239b 3a a5 23			ld a, (.dmark+2)  
239e 32 bf fb			ld (debug_mark+2),a  
23a1 18 03			jr .pastdmark  
23a3 ..			.dmark: db ":0x"  
23a6 f1			.pastdmark: pop af  
23a7			endm  
# End of macro DMARK
23a7				CALLMONITOR 
23a7 cd 47 17			call break_point_state  
23aa				endm  
# End of macro CALLMONITOR
23aa c1				pop bc 
23ab			endif 
23ab			 
23ab			 
23ab				; create word preamble which should be: 
23ab			 
23ab			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23ab			 
23ab				;    ld hl, <word code> 
23ab				;    jp user_exec 
23ab			        ;    <word code bytes> 
23ab			 
23ab			 
23ab			;	inc de     ; TODO ??? or are we already past the word's null 
23ab eb				ex de, hl 
23ac			 
23ac 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23ae			 
23ae 23				inc hl 
23af 22 95 ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23b2 23				inc hl 
23b3			 
23b3 23				inc hl 
23b4 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23b6			 
23b6 01 07 51			ld bc, user_exec 
23b9 23				inc hl 
23ba 71				ld (hl), c     ; poke address of user_exec 
23bb 23				inc hl 
23bc 70				ld (hl), b     
23bd			 ; 
23bd			;	inc hl 
23bd			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23bd			; 
23bd			; 
23bd			;	ld bc, macro_forth_rsp_next 
23bd			;	inc hl 
23bd			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23bd			;	inc hl 
23bd			;	ld (hl), b     
23bd			 ; 
23bd			;	inc hl 
23bd			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23bd			; 
23bd			; 
23bd			;	inc hl 
23bd			;	ld bc, forthexec 
23bd			;	ld (hl), c     ; poke address of forthexec 
23bd			;	inc hl 
23bd			;	ld (hl), b      
23bd			; 
23bd			;	inc hl 
23bd			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23bd			; 
23bd			;	ld bc, user_dict_next 
23bd			;	inc hl 
23bd			;	ld (hl), c     ; poke address of forthexec 
23bd			;	inc hl 
23bd			;	ld (hl), b      
23bd			 
23bd				; hl is now where we need to copy the word byte data to save this 
23bd			 
23bd 23				inc hl 
23be 22 97 ef			ld (os_new_exec), hl 
23c1				 
23c1				; copy definition 
23c1			 
23c1 eb				ex de, hl 
23c2			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23c2			;	inc de    ; skip the PC for this parse 
23c2 3a 9f ef			ld a, (os_new_parse_len) 
23c5 4f				ld c, a 
23c6 06 00			ld b, 0 
23c8 ed b0			ldir		 ; copy defintion 
23ca			 
23ca			 
23ca				; poke the address of where the new word bytes live for forthexec 
23ca			 
23ca 2a 95 ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23cd			 
23cd ed 5b 97 ef		ld de, (os_new_exec)      
23d1				 
23d1 73				ld (hl), e 
23d2 23				inc hl 
23d3 72				ld (hl), d 
23d4			 
23d4					; TODO copy last user dict word next link to this word 
23d4					; TODO update last user dict word to point to this word 
23d4			; 
23d4			; hl f923 de 812a ; bc 811a 
23d4			 
23d4			if DEBUG_FORTH_UWORD 
23d4 c5				push bc 
23d5 ed 4b a1 ef		ld bc, (os_new_malloc) 
23d9						DMARK ":0A" 
23d9 f5				push af  
23da 3a ee 23			ld a, (.dmark)  
23dd 32 bd fb			ld (debug_mark),a  
23e0 3a ef 23			ld a, (.dmark+1)  
23e3 32 be fb			ld (debug_mark+1),a  
23e6 3a f0 23			ld a, (.dmark+2)  
23e9 32 bf fb			ld (debug_mark+2),a  
23ec 18 03			jr .pastdmark  
23ee ..			.dmark: db ":0A"  
23f1 f1			.pastdmark: pop af  
23f2			endm  
# End of macro DMARK
23f2				CALLMONITOR 
23f2 cd 47 17			call break_point_state  
23f5				endm  
# End of macro CALLMONITOR
23f5 c1				pop bc 
23f6			endif 
23f6			if DEBUG_FORTH_UWORD 
23f6 c5				push bc 
23f7 ed 4b a1 ef		ld bc, (os_new_malloc) 
23fb 03				inc bc 
23fc 03				inc bc 
23fd 03				inc bc 
23fe 03				inc bc 
23ff 03				inc bc 
2400 03				inc bc 
2401 03				inc bc 
2402 03				inc bc 
2403			 
2403						DMARK ":0B" 
2403 f5				push af  
2404 3a 18 24			ld a, (.dmark)  
2407 32 bd fb			ld (debug_mark),a  
240a 3a 19 24			ld a, (.dmark+1)  
240d 32 be fb			ld (debug_mark+1),a  
2410 3a 1a 24			ld a, (.dmark+2)  
2413 32 bf fb			ld (debug_mark+2),a  
2416 18 03			jr .pastdmark  
2418 ..			.dmark: db ":0B"  
241b f1			.pastdmark: pop af  
241c			endm  
# End of macro DMARK
241c				CALLMONITOR 
241c cd 47 17			call break_point_state  
241f				endm  
# End of macro CALLMONITOR
241f c1				pop bc 
2420			endif 
2420			 
2420			; update word dict linked list for new word 
2420			 
2420			 
2420 2a a0 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2423 23			inc hl     ; move to next work linked list ptr 
2424			 
2424 ed 5b a1 ef	ld de, (os_new_malloc)		 ; new next word 
2428 73			ld (hl), e 
2429 23			inc hl 
242a 72			ld (hl), d 
242b			 
242b			if DEBUG_FORTH_UWORD 
242b ed 4b a0 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
242f			endif 
242f			 
242f ed 53 a0 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
2433			 
2433			 
2433			if DEBUG_FORTH_UWORD 
2433						DMARK ":0+" 
2433 f5				push af  
2434 3a 48 24			ld a, (.dmark)  
2437 32 bd fb			ld (debug_mark),a  
243a 3a 49 24			ld a, (.dmark+1)  
243d 32 be fb			ld (debug_mark+1),a  
2440 3a 4a 24			ld a, (.dmark+2)  
2443 32 bf fb			ld (debug_mark+2),a  
2446 18 03			jr .pastdmark  
2448 ..			.dmark: db ":0+"  
244b f1			.pastdmark: pop af  
244c			endm  
# End of macro DMARK
244c				CALLMONITOR 
244c cd 47 17			call break_point_state  
244f				endm  
# End of macro CALLMONITOR
244f			endif 
244f			 
244f				STACKFRAMECHK OFF $8efe $989f 
244f				if DEBUG_STACK_IMB 
244f					if OFF 
244f						exx 
244f						ld hl, $989f 
244f						pop de   ; $989f 
244f						call cmp16 
244f						jr nz, .spnosame 
244f						ld hl, $8efe 
244f						pop de   ; $8efe 
244f						call cmp16 
244f						jr z, .spfrsame 
244f						.spnosame: call showsperror 
244f						.spfrsame: nop 
244f						exx 
244f					endif 
244f				endif 
244f			endm 
# End of macro STACKFRAMECHK
244f			 
244f c9			ret    ; dont process any remaining parser tokens as they form new word 
2450			 
2450			 
2450			 
2450			 
2450			;		NEXT 
2450			.SCOLN: 
2450			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2450 06				db OPCODE_SCOLN 
2451 9c 24			dw .DROP 
2453 02				db 2 
2454 .. 00			db ";",0           
2456			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2456					if DEBUG_FORTH_WORDS_KEY 
2456						DMARK "SCN" 
2456 f5				push af  
2457 3a 6b 24			ld a, (.dmark)  
245a 32 bd fb			ld (debug_mark),a  
245d 3a 6c 24			ld a, (.dmark+1)  
2460 32 be fb			ld (debug_mark+1),a  
2463 3a 6d 24			ld a, (.dmark+2)  
2466 32 bf fb			ld (debug_mark+2),a  
2469 18 03			jr .pastdmark  
246b ..			.dmark: db "SCN"  
246e f1			.pastdmark: pop af  
246f			endm  
# End of macro DMARK
246f						CALLMONITOR 
246f cd 47 17			call break_point_state  
2472				endm  
# End of macro CALLMONITOR
2472					endif 
2472					FORTH_RSP_TOS 
2472 cd 95 1c			call macro_forth_rsp_tos 
2475				endm 
# End of macro FORTH_RSP_TOS
2475 e5					push hl 
2476					FORTH_RSP_POP 
2476 cd 9f 1c			call macro_forth_rsp_pop 
2479				endm 
# End of macro FORTH_RSP_POP
2479 e1					pop hl 
247a			;		ex de,hl 
247a 22 a4 f2				ld (os_tok_ptr),hl 
247d			 
247d			if DEBUG_FORTH_UWORD 
247d						DMARK "SCL" 
247d f5				push af  
247e 3a 92 24			ld a, (.dmark)  
2481 32 bd fb			ld (debug_mark),a  
2484 3a 93 24			ld a, (.dmark+1)  
2487 32 be fb			ld (debug_mark+1),a  
248a 3a 94 24			ld a, (.dmark+2)  
248d 32 bf fb			ld (debug_mark+2),a  
2490 18 03			jr .pastdmark  
2492 ..			.dmark: db "SCL"  
2495 f1			.pastdmark: pop af  
2496			endm  
# End of macro DMARK
2496				CALLMONITOR 
2496 cd 47 17			call break_point_state  
2499				endm  
# End of macro CALLMONITOR
2499			endif 
2499					NEXTW 
2499 c3 40 20			jp macro_next 
249c				endm 
# End of macro NEXTW
249c			 
249c			.DROP: 
249c				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
249c 1b				db WORD_SYS_CORE+OPCODE_DROP             
249d c7 24			dw .DUP2            
249f 05				db 4 + 1 
24a0 .. 00			db "DROP",0              
24a5				endm 
# End of macro CWHEAD
24a5			; | DROP ( w -- )   drop the TOS item   | DONE 
24a5					if DEBUG_FORTH_WORDS_KEY 
24a5						DMARK "DRP" 
24a5 f5				push af  
24a6 3a ba 24			ld a, (.dmark)  
24a9 32 bd fb			ld (debug_mark),a  
24ac 3a bb 24			ld a, (.dmark+1)  
24af 32 be fb			ld (debug_mark+1),a  
24b2 3a bc 24			ld a, (.dmark+2)  
24b5 32 bf fb			ld (debug_mark+2),a  
24b8 18 03			jr .pastdmark  
24ba ..			.dmark: db "DRP"  
24bd f1			.pastdmark: pop af  
24be			endm  
# End of macro DMARK
24be						CALLMONITOR 
24be cd 47 17			call break_point_state  
24c1				endm  
# End of macro CALLMONITOR
24c1					endif 
24c1					FORTH_DSP_POP 
24c1 cd 86 1f			call macro_forth_dsp_pop 
24c4				endm 
# End of macro FORTH_DSP_POP
24c4					NEXTW 
24c4 c3 40 20			jp macro_next 
24c7				endm 
# End of macro NEXTW
24c7			.DUP2: 
24c7				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24c7 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24c8 0c 25			dw .DROP2            
24ca 05				db 4 + 1 
24cb .. 00			db "2DUP",0              
24d0				endm 
# End of macro CWHEAD
24d0			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24d0					if DEBUG_FORTH_WORDS_KEY 
24d0						DMARK "2DU" 
24d0 f5				push af  
24d1 3a e5 24			ld a, (.dmark)  
24d4 32 bd fb			ld (debug_mark),a  
24d7 3a e6 24			ld a, (.dmark+1)  
24da 32 be fb			ld (debug_mark+1),a  
24dd 3a e7 24			ld a, (.dmark+2)  
24e0 32 bf fb			ld (debug_mark+2),a  
24e3 18 03			jr .pastdmark  
24e5 ..			.dmark: db "2DU"  
24e8 f1			.pastdmark: pop af  
24e9			endm  
# End of macro DMARK
24e9						CALLMONITOR 
24e9 cd 47 17			call break_point_state  
24ec				endm  
# End of macro CALLMONITOR
24ec					endif 
24ec					FORTH_DSP_VALUEHL 
24ec cd ce 1e			call macro_dsp_valuehl 
24ef				endm 
# End of macro FORTH_DSP_VALUEHL
24ef e5					push hl      ; 2 
24f0			 
24f0					FORTH_DSP_POP 
24f0 cd 86 1f			call macro_forth_dsp_pop 
24f3				endm 
# End of macro FORTH_DSP_POP
24f3					 
24f3					FORTH_DSP_VALUEHL 
24f3 cd ce 1e			call macro_dsp_valuehl 
24f6				endm 
# End of macro FORTH_DSP_VALUEHL
24f6			;		push hl      ; 1 
24f6			 
24f6					FORTH_DSP_POP 
24f6 cd 86 1f			call macro_forth_dsp_pop 
24f9				endm 
# End of macro FORTH_DSP_POP
24f9			 
24f9			;		pop hl       ; 1 
24f9 d1					pop de       ; 2 
24fa			 
24fa cd d7 1c				call forth_push_numhl 
24fd eb					ex de, hl 
24fe cd d7 1c				call forth_push_numhl 
2501			 
2501					 
2501 eb					ex de, hl 
2502			 
2502 cd d7 1c				call forth_push_numhl 
2505 eb					ex de, hl 
2506 cd d7 1c				call forth_push_numhl 
2509			 
2509			 
2509					NEXTW 
2509 c3 40 20			jp macro_next 
250c				endm 
# End of macro NEXTW
250c			.DROP2: 
250c				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
250c 1d				db WORD_SYS_CORE+OPCODE_DROP2             
250d 3b 25			dw .SWAP2            
250f 06				db 5 + 1 
2510 .. 00			db "2DROP",0              
2516				endm 
# End of macro CWHEAD
2516			; | 2DROP ( w w -- )    Double drop | DONE 
2516					if DEBUG_FORTH_WORDS_KEY 
2516						DMARK "2DR" 
2516 f5				push af  
2517 3a 2b 25			ld a, (.dmark)  
251a 32 bd fb			ld (debug_mark),a  
251d 3a 2c 25			ld a, (.dmark+1)  
2520 32 be fb			ld (debug_mark+1),a  
2523 3a 2d 25			ld a, (.dmark+2)  
2526 32 bf fb			ld (debug_mark+2),a  
2529 18 03			jr .pastdmark  
252b ..			.dmark: db "2DR"  
252e f1			.pastdmark: pop af  
252f			endm  
# End of macro DMARK
252f						CALLMONITOR 
252f cd 47 17			call break_point_state  
2532				endm  
# End of macro CALLMONITOR
2532					endif 
2532					FORTH_DSP_POP 
2532 cd 86 1f			call macro_forth_dsp_pop 
2535				endm 
# End of macro FORTH_DSP_POP
2535					FORTH_DSP_POP 
2535 cd 86 1f			call macro_forth_dsp_pop 
2538				endm 
# End of macro FORTH_DSP_POP
2538					NEXTW 
2538 c3 40 20			jp macro_next 
253b				endm 
# End of macro NEXTW
253b			.SWAP2: 
253b				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
253b 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
253c 64 25			dw .AT            
253e 06				db 5 + 1 
253f .. 00			db "2SWAP",0              
2545				endm 
# End of macro CWHEAD
2545			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2545					if DEBUG_FORTH_WORDS_KEY 
2545						DMARK "2SW" 
2545 f5				push af  
2546 3a 5a 25			ld a, (.dmark)  
2549 32 bd fb			ld (debug_mark),a  
254c 3a 5b 25			ld a, (.dmark+1)  
254f 32 be fb			ld (debug_mark+1),a  
2552 3a 5c 25			ld a, (.dmark+2)  
2555 32 bf fb			ld (debug_mark+2),a  
2558 18 03			jr .pastdmark  
255a ..			.dmark: db "2SW"  
255d f1			.pastdmark: pop af  
255e			endm  
# End of macro DMARK
255e						CALLMONITOR 
255e cd 47 17			call break_point_state  
2561				endm  
# End of macro CALLMONITOR
2561					endif 
2561					NEXTW 
2561 c3 40 20			jp macro_next 
2564				endm 
# End of macro NEXTW
2564			.AT: 
2564				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2564 1f				db WORD_SYS_CORE+OPCODE_AT             
2565 96 25			dw .CAT            
2567 02				db 1 + 1 
2568 .. 00			db "@",0              
256a				endm 
# End of macro CWHEAD
256a			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
256a			 
256a					if DEBUG_FORTH_WORDS_KEY 
256a						DMARK "AT." 
256a f5				push af  
256b 3a 7f 25			ld a, (.dmark)  
256e 32 bd fb			ld (debug_mark),a  
2571 3a 80 25			ld a, (.dmark+1)  
2574 32 be fb			ld (debug_mark+1),a  
2577 3a 81 25			ld a, (.dmark+2)  
257a 32 bf fb			ld (debug_mark+2),a  
257d 18 03			jr .pastdmark  
257f ..			.dmark: db "AT."  
2582 f1			.pastdmark: pop af  
2583			endm  
# End of macro DMARK
2583						CALLMONITOR 
2583 cd 47 17			call break_point_state  
2586				endm  
# End of macro CALLMONITOR
2586					endif 
2586			.getbyteat:	 
2586					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2586 cd ce 1e			call macro_dsp_valuehl 
2589				endm 
# End of macro FORTH_DSP_VALUEHL
2589					 
2589			;		push hl 
2589				 
2589					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2589 cd 86 1f			call macro_forth_dsp_pop 
258c				endm 
# End of macro FORTH_DSP_POP
258c			 
258c			;		pop hl 
258c			 
258c 7e					ld a, (hl) 
258d			 
258d 6f					ld l, a 
258e 26 00				ld h, 0 
2590 cd d7 1c				call forth_push_numhl 
2593			 
2593					NEXTW 
2593 c3 40 20			jp macro_next 
2596				endm 
# End of macro NEXTW
2596			.CAT: 
2596				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2596 20				db WORD_SYS_CORE+OPCODE_CAT             
2597 bf 25			dw .BANG            
2599 03				db 2 + 1 
259a .. 00			db "C@",0              
259d				endm 
# End of macro CWHEAD
259d			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
259d					if DEBUG_FORTH_WORDS_KEY 
259d						DMARK "CAA" 
259d f5				push af  
259e 3a b2 25			ld a, (.dmark)  
25a1 32 bd fb			ld (debug_mark),a  
25a4 3a b3 25			ld a, (.dmark+1)  
25a7 32 be fb			ld (debug_mark+1),a  
25aa 3a b4 25			ld a, (.dmark+2)  
25ad 32 bf fb			ld (debug_mark+2),a  
25b0 18 03			jr .pastdmark  
25b2 ..			.dmark: db "CAA"  
25b5 f1			.pastdmark: pop af  
25b6			endm  
# End of macro DMARK
25b6						CALLMONITOR 
25b6 cd 47 17			call break_point_state  
25b9				endm  
# End of macro CALLMONITOR
25b9					endif 
25b9 c3 86 25				jp .getbyteat 
25bc					NEXTW 
25bc c3 40 20			jp macro_next 
25bf				endm 
# End of macro NEXTW
25bf			.BANG: 
25bf				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25bf 21				db WORD_SYS_CORE+OPCODE_BANG             
25c0 f5 25			dw .CBANG            
25c2 02				db 1 + 1 
25c3 .. 00			db "!",0              
25c5				endm 
# End of macro CWHEAD
25c5			; | ! ( x w -- ) Store x at address w      | DONE 
25c5					if DEBUG_FORTH_WORDS_KEY 
25c5						DMARK "BNG" 
25c5 f5				push af  
25c6 3a da 25			ld a, (.dmark)  
25c9 32 bd fb			ld (debug_mark),a  
25cc 3a db 25			ld a, (.dmark+1)  
25cf 32 be fb			ld (debug_mark+1),a  
25d2 3a dc 25			ld a, (.dmark+2)  
25d5 32 bf fb			ld (debug_mark+2),a  
25d8 18 03			jr .pastdmark  
25da ..			.dmark: db "BNG"  
25dd f1			.pastdmark: pop af  
25de			endm  
# End of macro DMARK
25de						CALLMONITOR 
25de cd 47 17			call break_point_state  
25e1				endm  
# End of macro CALLMONITOR
25e1					endif 
25e1			 
25e1			.storebyteat:		 
25e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25e1 cd ce 1e			call macro_dsp_valuehl 
25e4				endm 
# End of macro FORTH_DSP_VALUEHL
25e4					 
25e4 e5					push hl 
25e5				 
25e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25e5 cd 86 1f			call macro_forth_dsp_pop 
25e8				endm 
# End of macro FORTH_DSP_POP
25e8			 
25e8					; get byte to poke 
25e8			 
25e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25e8 cd ce 1e			call macro_dsp_valuehl 
25eb				endm 
# End of macro FORTH_DSP_VALUEHL
25eb e5					push hl 
25ec			 
25ec			 
25ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ec cd 86 1f			call macro_forth_dsp_pop 
25ef				endm 
# End of macro FORTH_DSP_POP
25ef			 
25ef			 
25ef d1					pop de 
25f0 e1					pop hl 
25f1			 
25f1 73					ld (hl),e 
25f2			 
25f2			 
25f2					NEXTW 
25f2 c3 40 20			jp macro_next 
25f5				endm 
# End of macro NEXTW
25f5			.CBANG: 
25f5				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25f5 22				db WORD_SYS_CORE+OPCODE_CBANG             
25f6 1e 26			dw .SCALL            
25f8 03				db 2 + 1 
25f9 .. 00			db "C!",0              
25fc				endm 
# End of macro CWHEAD
25fc			; | C!  ( x w -- ) Store x at address w  | DONE 
25fc					if DEBUG_FORTH_WORDS_KEY 
25fc						DMARK "CBA" 
25fc f5				push af  
25fd 3a 11 26			ld a, (.dmark)  
2600 32 bd fb			ld (debug_mark),a  
2603 3a 12 26			ld a, (.dmark+1)  
2606 32 be fb			ld (debug_mark+1),a  
2609 3a 13 26			ld a, (.dmark+2)  
260c 32 bf fb			ld (debug_mark+2),a  
260f 18 03			jr .pastdmark  
2611 ..			.dmark: db "CBA"  
2614 f1			.pastdmark: pop af  
2615			endm  
# End of macro DMARK
2615						CALLMONITOR 
2615 cd 47 17			call break_point_state  
2618				endm  
# End of macro CALLMONITOR
2618					endif 
2618 c3 e1 25				jp .storebyteat 
261b					NEXTW 
261b c3 40 20			jp macro_next 
261e				endm 
# End of macro NEXTW
261e			.SCALL: 
261e				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
261e 23				db WORD_SYS_CORE+OPCODE_SCALL             
261f 52 26			dw .DEPTH            
2621 05				db 4 + 1 
2622 .. 00			db "CALL",0              
2627				endm 
# End of macro CWHEAD
2627			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2627					if DEBUG_FORTH_WORDS_KEY 
2627						DMARK "CLL" 
2627 f5				push af  
2628 3a 3c 26			ld a, (.dmark)  
262b 32 bd fb			ld (debug_mark),a  
262e 3a 3d 26			ld a, (.dmark+1)  
2631 32 be fb			ld (debug_mark+1),a  
2634 3a 3e 26			ld a, (.dmark+2)  
2637 32 bf fb			ld (debug_mark+2),a  
263a 18 03			jr .pastdmark  
263c ..			.dmark: db "CLL"  
263f f1			.pastdmark: pop af  
2640			endm  
# End of macro DMARK
2640						CALLMONITOR 
2640 cd 47 17			call break_point_state  
2643				endm  
# End of macro CALLMONITOR
2643					endif 
2643			 
2643					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2643 cd ce 1e			call macro_dsp_valuehl 
2646				endm 
# End of macro FORTH_DSP_VALUEHL
2646			 
2646			;		push hl 
2646			 
2646					; destroy value TOS 
2646			 
2646					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2646 cd 86 1f			call macro_forth_dsp_pop 
2649				endm 
# End of macro FORTH_DSP_POP
2649			 
2649						 
2649			;		pop hl 
2649			 
2649					; how to do a call with hl???? save SP? 
2649 cd e9 1f				call forth_call_hl 
264c			 
264c			 
264c					; TODO push value back onto stack for another op etc 
264c			 
264c cd d7 1c				call forth_push_numhl 
264f					NEXTW 
264f c3 40 20			jp macro_next 
2652				endm 
# End of macro NEXTW
2652			.DEPTH: 
2652				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2652 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2653 8f 26			dw .OVER            
2655 06				db 5 + 1 
2656 .. 00			db "DEPTH",0              
265c				endm 
# End of macro CWHEAD
265c			; | DEPTH ( -- u ) Push count of stack | DONE 
265c					; take current TOS and remove from base value div by two to get count 
265c					if DEBUG_FORTH_WORDS_KEY 
265c						DMARK "DEP" 
265c f5				push af  
265d 3a 71 26			ld a, (.dmark)  
2660 32 bd fb			ld (debug_mark),a  
2663 3a 72 26			ld a, (.dmark+1)  
2666 32 be fb			ld (debug_mark+1),a  
2669 3a 73 26			ld a, (.dmark+2)  
266c 32 bf fb			ld (debug_mark+2),a  
266f 18 03			jr .pastdmark  
2671 ..			.dmark: db "DEP"  
2674 f1			.pastdmark: pop af  
2675			endm  
# End of macro DMARK
2675						CALLMONITOR 
2675 cd 47 17			call break_point_state  
2678				endm  
# End of macro CALLMONITOR
2678					endif 
2678			 
2678			 
2678 2a 90 f9			ld hl, (cli_data_sp) 
267b 11 0a f5			ld de, cli_data_stack 
267e ed 52			sbc hl,de 
2680				 
2680				; div by size of stack item 
2680			 
2680 5d				ld e,l 
2681 0e 03			ld c, 3 
2683 cd ad 0c			call Div8 
2686			 
2686 6f				ld l,a 
2687 26 00			ld h,0 
2689			 
2689				;srl h 
2689				;rr l 
2689			 
2689 cd d7 1c				call forth_push_numhl 
268c					NEXTW 
268c c3 40 20			jp macro_next 
268f				endm 
# End of macro NEXTW
268f			.OVER: 
268f				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
268f 42				db WORD_SYS_CORE+46             
2690 d6 26			dw .PAUSE            
2692 05				db 4 + 1 
2693 .. 00			db "OVER",0              
2698				endm 
# End of macro CWHEAD
2698			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2698					if DEBUG_FORTH_WORDS_KEY 
2698						DMARK "OVR" 
2698 f5				push af  
2699 3a ad 26			ld a, (.dmark)  
269c 32 bd fb			ld (debug_mark),a  
269f 3a ae 26			ld a, (.dmark+1)  
26a2 32 be fb			ld (debug_mark+1),a  
26a5 3a af 26			ld a, (.dmark+2)  
26a8 32 bf fb			ld (debug_mark+2),a  
26ab 18 03			jr .pastdmark  
26ad ..			.dmark: db "OVR"  
26b0 f1			.pastdmark: pop af  
26b1			endm  
# End of macro DMARK
26b1						CALLMONITOR 
26b1 cd 47 17			call break_point_state  
26b4				endm  
# End of macro CALLMONITOR
26b4					endif 
26b4			 
26b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b4 cd ce 1e			call macro_dsp_valuehl 
26b7				endm 
# End of macro FORTH_DSP_VALUEHL
26b7 e5					push hl    ; n2 
26b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26b8 cd 86 1f			call macro_forth_dsp_pop 
26bb				endm 
# End of macro FORTH_DSP_POP
26bb			 
26bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26bb cd ce 1e			call macro_dsp_valuehl 
26be				endm 
# End of macro FORTH_DSP_VALUEHL
26be e5					push hl    ; n1 
26bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26bf cd 86 1f			call macro_forth_dsp_pop 
26c2				endm 
# End of macro FORTH_DSP_POP
26c2			 
26c2 d1					pop de     ; n1 
26c3 e1					pop hl     ; n2 
26c4			 
26c4 d5					push de 
26c5 e5					push hl 
26c6 d5					push de 
26c7			 
26c7					; push back  
26c7			 
26c7 e1					pop hl 
26c8 cd d7 1c				call forth_push_numhl 
26cb e1					pop hl 
26cc cd d7 1c				call forth_push_numhl 
26cf e1					pop hl 
26d0 cd d7 1c				call forth_push_numhl 
26d3					NEXTW 
26d3 c3 40 20			jp macro_next 
26d6				endm 
# End of macro NEXTW
26d6			 
26d6			.PAUSE: 
26d6				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26d6 43				db WORD_SYS_CORE+47             
26d7 0b 27			dw .PAUSES            
26d9 08				db 7 + 1 
26da .. 00			db "PAUSEMS",0              
26e2				endm 
# End of macro CWHEAD
26e2			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26e2					if DEBUG_FORTH_WORDS_KEY 
26e2						DMARK "PMS" 
26e2 f5				push af  
26e3 3a f7 26			ld a, (.dmark)  
26e6 32 bd fb			ld (debug_mark),a  
26e9 3a f8 26			ld a, (.dmark+1)  
26ec 32 be fb			ld (debug_mark+1),a  
26ef 3a f9 26			ld a, (.dmark+2)  
26f2 32 bf fb			ld (debug_mark+2),a  
26f5 18 03			jr .pastdmark  
26f7 ..			.dmark: db "PMS"  
26fa f1			.pastdmark: pop af  
26fb			endm  
# End of macro DMARK
26fb						CALLMONITOR 
26fb cd 47 17			call break_point_state  
26fe				endm  
# End of macro CALLMONITOR
26fe					endif 
26fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26fe cd ce 1e			call macro_dsp_valuehl 
2701				endm 
# End of macro FORTH_DSP_VALUEHL
2701			;		push hl    ; n2 
2701					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2701 cd 86 1f			call macro_forth_dsp_pop 
2704				endm 
# End of macro FORTH_DSP_POP
2704			;		pop hl 
2704			 
2704 7d					ld a, l 
2705 cd 4b 0a				call aDelayInMS 
2708				       NEXTW 
2708 c3 40 20			jp macro_next 
270b				endm 
# End of macro NEXTW
270b			.PAUSES:  
270b				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
270b 44				db WORD_SYS_CORE+48             
270c 7a 27			dw .ROT            
270e 06				db 5 + 1 
270f .. 00			db "PAUSE",0              
2715				endm 
# End of macro CWHEAD
2715			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2715					if DEBUG_FORTH_WORDS_KEY 
2715						DMARK "PAU" 
2715 f5				push af  
2716 3a 2a 27			ld a, (.dmark)  
2719 32 bd fb			ld (debug_mark),a  
271c 3a 2b 27			ld a, (.dmark+1)  
271f 32 be fb			ld (debug_mark+1),a  
2722 3a 2c 27			ld a, (.dmark+2)  
2725 32 bf fb			ld (debug_mark+2),a  
2728 18 03			jr .pastdmark  
272a ..			.dmark: db "PAU"  
272d f1			.pastdmark: pop af  
272e			endm  
# End of macro DMARK
272e						CALLMONITOR 
272e cd 47 17			call break_point_state  
2731				endm  
# End of macro CALLMONITOR
2731					endif 
2731					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2731 cd ce 1e			call macro_dsp_valuehl 
2734				endm 
# End of macro FORTH_DSP_VALUEHL
2734			;		push hl    ; n2 
2734					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2734 cd 86 1f			call macro_forth_dsp_pop 
2737				endm 
# End of macro FORTH_DSP_POP
2737			;		pop hl 
2737 45					ld b, l 
2738					if DEBUG_FORTH_WORDS 
2738						DMARK "PAU" 
2738 f5				push af  
2739 3a 4d 27			ld a, (.dmark)  
273c 32 bd fb			ld (debug_mark),a  
273f 3a 4e 27			ld a, (.dmark+1)  
2742 32 be fb			ld (debug_mark+1),a  
2745 3a 4f 27			ld a, (.dmark+2)  
2748 32 bf fb			ld (debug_mark+2),a  
274b 18 03			jr .pastdmark  
274d ..			.dmark: db "PAU"  
2750 f1			.pastdmark: pop af  
2751			endm  
# End of macro DMARK
2751						CALLMONITOR 
2751 cd 47 17			call break_point_state  
2754				endm  
# End of macro CALLMONITOR
2754					endif 
2754 c5			.pauses1:	push bc 
2755 cd 66 0a				call delay1s 
2758 c1					pop bc 
2759					if DEBUG_FORTH_WORDS 
2759						DMARK "PA1" 
2759 f5				push af  
275a 3a 6e 27			ld a, (.dmark)  
275d 32 bd fb			ld (debug_mark),a  
2760 3a 6f 27			ld a, (.dmark+1)  
2763 32 be fb			ld (debug_mark+1),a  
2766 3a 70 27			ld a, (.dmark+2)  
2769 32 bf fb			ld (debug_mark+2),a  
276c 18 03			jr .pastdmark  
276e ..			.dmark: db "PA1"  
2771 f1			.pastdmark: pop af  
2772			endm  
# End of macro DMARK
2772						CALLMONITOR 
2772 cd 47 17			call break_point_state  
2775				endm  
# End of macro CALLMONITOR
2775					endif 
2775 10 dd				djnz .pauses1 
2777			 
2777				       NEXTW 
2777 c3 40 20			jp macro_next 
277a				endm 
# End of macro NEXTW
277a			.ROT: 
277a				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
277a 45				db WORD_SYS_CORE+49             
277b c8 27			dw .UWORDS            
277d 04				db 3 + 1 
277e .. 00			db "ROT",0              
2782				endm 
# End of macro CWHEAD
2782			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2782					if DEBUG_FORTH_WORDS_KEY 
2782						DMARK "ROT" 
2782 f5				push af  
2783 3a 97 27			ld a, (.dmark)  
2786 32 bd fb			ld (debug_mark),a  
2789 3a 98 27			ld a, (.dmark+1)  
278c 32 be fb			ld (debug_mark+1),a  
278f 3a 99 27			ld a, (.dmark+2)  
2792 32 bf fb			ld (debug_mark+2),a  
2795 18 03			jr .pastdmark  
2797 ..			.dmark: db "ROT"  
279a f1			.pastdmark: pop af  
279b			endm  
# End of macro DMARK
279b						CALLMONITOR 
279b cd 47 17			call break_point_state  
279e				endm  
# End of macro CALLMONITOR
279e					endif 
279e			 
279e					FORTH_DSP_VALUEHL 
279e cd ce 1e			call macro_dsp_valuehl 
27a1				endm 
# End of macro FORTH_DSP_VALUEHL
27a1 e5					push hl    ; u3  
27a2			 
27a2					FORTH_DSP_POP 
27a2 cd 86 1f			call macro_forth_dsp_pop 
27a5				endm 
# End of macro FORTH_DSP_POP
27a5			   
27a5					FORTH_DSP_VALUEHL 
27a5 cd ce 1e			call macro_dsp_valuehl 
27a8				endm 
# End of macro FORTH_DSP_VALUEHL
27a8 e5					push hl     ; u2 
27a9			 
27a9					FORTH_DSP_POP 
27a9 cd 86 1f			call macro_forth_dsp_pop 
27ac				endm 
# End of macro FORTH_DSP_POP
27ac			 
27ac					FORTH_DSP_VALUEHL 
27ac cd ce 1e			call macro_dsp_valuehl 
27af				endm 
# End of macro FORTH_DSP_VALUEHL
27af e5					push hl     ; u1 
27b0			 
27b0					FORTH_DSP_POP 
27b0 cd 86 1f			call macro_forth_dsp_pop 
27b3				endm 
# End of macro FORTH_DSP_POP
27b3			 
27b3 c1					pop bc      ; u1 
27b4 e1					pop hl      ; u2 
27b5 d1					pop de      ; u3 
27b6			 
27b6			 
27b6 c5					push bc 
27b7 d5					push de 
27b8 e5					push hl 
27b9			 
27b9			 
27b9 e1					pop hl 
27ba cd d7 1c				call forth_push_numhl 
27bd			 
27bd e1					pop hl 
27be cd d7 1c				call forth_push_numhl 
27c1			 
27c1 e1					pop hl 
27c2 cd d7 1c				call forth_push_numhl 
27c5					 
27c5			 
27c5			 
27c5			 
27c5			 
27c5			 
27c5				       NEXTW 
27c5 c3 40 20			jp macro_next 
27c8				endm 
# End of macro NEXTW
27c8			 
27c8			.UWORDS: 
27c8				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27c8 50				db WORD_SYS_CORE+60             
27c9 8a 28			dw .BP            
27cb 07				db 6 + 1 
27cc .. 00			db "UWORDS",0              
27d3				endm 
# End of macro CWHEAD
27d3			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27d3			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27d3			; | | Following the count are the individual words. 
27d3			; | | 
27d3			; | | e.g. UWORDS 
27d3			; | | BOX DIRLIST 2 
27d3			; | |  
27d3			; | | Can be used to save the words to storage via: 
27d3			; | | UWORDS $01 DO $01 APPEND LOOP 
27d3				if DEBUG_FORTH_WORDS_KEY 
27d3					DMARK "UWR" 
27d3 f5				push af  
27d4 3a e8 27			ld a, (.dmark)  
27d7 32 bd fb			ld (debug_mark),a  
27da 3a e9 27			ld a, (.dmark+1)  
27dd 32 be fb			ld (debug_mark+1),a  
27e0 3a ea 27			ld a, (.dmark+2)  
27e3 32 bf fb			ld (debug_mark+2),a  
27e6 18 03			jr .pastdmark  
27e8 ..			.dmark: db "UWR"  
27eb f1			.pastdmark: pop af  
27ec			endm  
# End of macro DMARK
27ec					CALLMONITOR 
27ec cd 47 17			call break_point_state  
27ef				endm  
# End of macro CALLMONITOR
27ef				endif 
27ef 21 00 80				ld hl, baseram 
27f2					;ld hl, baseusermem 
27f2 01 00 00				ld bc, 0    ; start a counter 
27f5			 
27f5				; skip dict stub 
27f5			 
27f5 cd 91 21				call forth_tok_next 
27f8			 
27f8			 
27f8			; while we have words to look for 
27f8			 
27f8 7e			.douscan:	ld a, (hl)      
27f9				if DEBUG_FORTH_WORDS 
27f9					DMARK "UWs" 
27f9 f5				push af  
27fa 3a 0e 28			ld a, (.dmark)  
27fd 32 bd fb			ld (debug_mark),a  
2800 3a 0f 28			ld a, (.dmark+1)  
2803 32 be fb			ld (debug_mark+1),a  
2806 3a 10 28			ld a, (.dmark+2)  
2809 32 bf fb			ld (debug_mark+2),a  
280c 18 03			jr .pastdmark  
280e ..			.dmark: db "UWs"  
2811 f1			.pastdmark: pop af  
2812			endm  
# End of macro DMARK
2812					CALLMONITOR 
2812 cd 47 17			call break_point_state  
2815				endm  
# End of macro CALLMONITOR
2815				endif 
2815 fe 00				cp WORD_SYS_END 
2817 28 4d				jr z, .udone 
2819 fe 01				cp WORD_SYS_UWORD 
281b 20 44				jr nz, .nuword 
281d			 
281d				if DEBUG_FORTH_WORDS 
281d					DMARK "UWu" 
281d f5				push af  
281e 3a 32 28			ld a, (.dmark)  
2821 32 bd fb			ld (debug_mark),a  
2824 3a 33 28			ld a, (.dmark+1)  
2827 32 be fb			ld (debug_mark+1),a  
282a 3a 34 28			ld a, (.dmark+2)  
282d 32 bf fb			ld (debug_mark+2),a  
2830 18 03			jr .pastdmark  
2832 ..			.dmark: db "UWu"  
2835 f1			.pastdmark: pop af  
2836			endm  
# End of macro DMARK
2836					CALLMONITOR 
2836 cd 47 17			call break_point_state  
2839				endm  
# End of macro CALLMONITOR
2839				endif 
2839					; we have a uword so push its name to the stack 
2839			 
2839 e5				   	push hl  ; save so we can move to next dict block 
283a			 
283a					; skip opcode 
283a 23					inc hl  
283b					; skip next ptr 
283b 23					inc hl  
283c 23					inc hl 
283d					; skip len 
283d 23					inc hl 
283e				if DEBUG_FORTH_WORDS 
283e					DMARK "UWt" 
283e f5				push af  
283f 3a 53 28			ld a, (.dmark)  
2842 32 bd fb			ld (debug_mark),a  
2845 3a 54 28			ld a, (.dmark+1)  
2848 32 be fb			ld (debug_mark+1),a  
284b 3a 55 28			ld a, (.dmark+2)  
284e 32 bf fb			ld (debug_mark+2),a  
2851 18 03			jr .pastdmark  
2853 ..			.dmark: db "UWt"  
2856 f1			.pastdmark: pop af  
2857			endm  
# End of macro DMARK
2857					CALLMONITOR 
2857 cd 47 17			call break_point_state  
285a				endm  
# End of macro CALLMONITOR
285a				endif 
285a 03					inc bc 
285b			 
285b c5					push bc 
285c cd 45 1d				call forth_push_str 
285f c1					pop bc 
2860			 
2860 e1					pop hl 	 
2861			 
2861 cd 91 21		.nuword:	call forth_tok_next 
2864 18 92				jr .douscan  
2866			 
2866			.udone:		 ; push count of uwords found 
2866 c5					push bc 
2867 e1					pop hl 
2868			 
2868				if DEBUG_FORTH_WORDS 
2868					DMARK "UWc" 
2868 f5				push af  
2869 3a 7d 28			ld a, (.dmark)  
286c 32 bd fb			ld (debug_mark),a  
286f 3a 7e 28			ld a, (.dmark+1)  
2872 32 be fb			ld (debug_mark+1),a  
2875 3a 7f 28			ld a, (.dmark+2)  
2878 32 bf fb			ld (debug_mark+2),a  
287b 18 03			jr .pastdmark  
287d ..			.dmark: db "UWc"  
2880 f1			.pastdmark: pop af  
2881			endm  
# End of macro DMARK
2881					CALLMONITOR 
2881 cd 47 17			call break_point_state  
2884				endm  
# End of macro CALLMONITOR
2884				endif 
2884 cd d7 1c				call forth_push_numhl 
2887			 
2887			 
2887				       NEXTW 
2887 c3 40 20			jp macro_next 
288a				endm 
# End of macro NEXTW
288a			 
288a			.BP: 
288a				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
288a 54				db WORD_SYS_CORE+64             
288b c0 28			dw .MONITOR            
288d 03				db 2 + 1 
288e .. 00			db "BP",0              
2891				endm 
# End of macro CWHEAD
2891			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2891			; | | $00 Will enable the break points within specific code paths 
2891			; | | $01 Will disable break points 
2891			; | |  
2891			; | | By default break points are off. Either the above can be used to enable them 
2891			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2891			; | | and on release of the pressed key a message will be disaplayed to notify 
2891			; | | that break points are enabled. Pressing any key will then continue boot process. 
2891					; get byte count 
2891					if DEBUG_FORTH_WORDS_KEY 
2891						DMARK "BP." 
2891 f5				push af  
2892 3a a6 28			ld a, (.dmark)  
2895 32 bd fb			ld (debug_mark),a  
2898 3a a7 28			ld a, (.dmark+1)  
289b 32 be fb			ld (debug_mark+1),a  
289e 3a a8 28			ld a, (.dmark+2)  
28a1 32 bf fb			ld (debug_mark+2),a  
28a4 18 03			jr .pastdmark  
28a6 ..			.dmark: db "BP."  
28a9 f1			.pastdmark: pop af  
28aa			endm  
# End of macro DMARK
28aa						CALLMONITOR 
28aa cd 47 17			call break_point_state  
28ad				endm  
# End of macro CALLMONITOR
28ad					endif 
28ad			 
28ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28ad cd ce 1e			call macro_dsp_valuehl 
28b0				endm 
# End of macro FORTH_DSP_VALUEHL
28b0			 
28b0			;		push hl 
28b0			 
28b0					; destroy value TOS 
28b0			 
28b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28b0 cd 86 1f			call macro_forth_dsp_pop 
28b3				endm 
# End of macro FORTH_DSP_POP
28b3			 
28b3			;		pop hl 
28b3			 
28b3 3e 00				ld a,0 
28b5 bd					cp l 
28b6 28 02				jr z, .bpset 
28b8 3e 2a				ld a, '*' 
28ba			 
28ba 32 94 ef		.bpset:		ld (os_view_disable), a 
28bd			 
28bd			 
28bd					NEXTW 
28bd c3 40 20			jp macro_next 
28c0				endm 
# End of macro NEXTW
28c0			 
28c0			 
28c0			.MONITOR: 
28c0				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28c0 55				db WORD_SYS_CORE+65             
28c1 f3 28			dw .MALLOC            
28c3 08				db 7 + 1 
28c4 .. 00			db "MONITOR",0              
28cc				endm 
# End of macro CWHEAD
28cc			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28cc			; | | At start the current various registers will be displayed with contents. 
28cc			; | | Top right corner will show the most recent debug marker seen. 
28cc			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28cc			; | | and the return stack pointer (RSP). 
28cc			; | | Pressing: 
28cc			; | |    1 - Initial screen 
28cc			; | |    2 - Display a data dump of HL 
28cc			; | |    3 - Display a data dump of DE 
28cc			; | |    4 - Display a data dump of BC 
28cc			; | |    5 - Display a data dump of HL 
28cc			; | |    6 - Display a data dump of DSP 
28cc			; | |    7 - Display a data dump of RSP 
28cc			; | |    8 - Display a data dump of what is at DSP 
28cc			; | |    9 - Display a data dump of what is at RSP 
28cc			; | |    0 - Exit monitor and continue running. This will also enable break points 
28cc			; | |    * - Disable break points 
28cc			; | |    # - Enter traditional monitor mode 
28cc			; | | 
28cc			; | | Monitor Mode 
28cc			; | | ------------ 
28cc			; | | A prompt of '>' will be shown for various commands: 
28cc			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28cc			; | |    C - Continue display a data dump from the last set address 
28cc			; | |    M xxxx - Set start of memory edit at address xx 
28cc			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28cc			; | |    Q - Return to previous 
28cc					if DEBUG_FORTH_WORDS_KEY 
28cc						DMARK "MON" 
28cc f5				push af  
28cd 3a e1 28			ld a, (.dmark)  
28d0 32 bd fb			ld (debug_mark),a  
28d3 3a e2 28			ld a, (.dmark+1)  
28d6 32 be fb			ld (debug_mark+1),a  
28d9 3a e3 28			ld a, (.dmark+2)  
28dc 32 bf fb			ld (debug_mark+2),a  
28df 18 03			jr .pastdmark  
28e1 ..			.dmark: db "MON"  
28e4 f1			.pastdmark: pop af  
28e5			endm  
# End of macro DMARK
28e5						CALLMONITOR 
28e5 cd 47 17			call break_point_state  
28e8				endm  
# End of macro CALLMONITOR
28e8					endif 
28e8 3e 00				ld a, 0 
28ea 32 94 ef				ld (os_view_disable), a 
28ed			 
28ed					CALLMONITOR 
28ed cd 47 17			call break_point_state  
28f0				endm  
# End of macro CALLMONITOR
28f0			 
28f0			;	call monitor 
28f0			 
28f0					NEXTW 
28f0 c3 40 20			jp macro_next 
28f3				endm 
# End of macro NEXTW
28f3			 
28f3			 
28f3			.MALLOC: 
28f3				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28f3 56				db WORD_SYS_CORE+66             
28f4 1c 29			dw .MALLOC2            
28f6 06				db 5 + 1 
28f7 .. 00			db "ALLOT",0              
28fd				endm 
# End of macro CWHEAD
28fd			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28fd					if DEBUG_FORTH_WORDS_KEY 
28fd						DMARK "ALL" 
28fd f5				push af  
28fe 3a 12 29			ld a, (.dmark)  
2901 32 bd fb			ld (debug_mark),a  
2904 3a 13 29			ld a, (.dmark+1)  
2907 32 be fb			ld (debug_mark+1),a  
290a 3a 14 29			ld a, (.dmark+2)  
290d 32 bf fb			ld (debug_mark+2),a  
2910 18 03			jr .pastdmark  
2912 ..			.dmark: db "ALL"  
2915 f1			.pastdmark: pop af  
2916			endm  
# End of macro DMARK
2916						CALLMONITOR 
2916 cd 47 17			call break_point_state  
2919				endm  
# End of macro CALLMONITOR
2919					endif 
2919 c3 43 29				jp .mallocc 
291c			.MALLOC2: 
291c				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
291c 56				db WORD_SYS_CORE+66             
291d 5a 29			dw .FREE            
291f 07				db 6 + 1 
2920 .. 00			db "MALLOC",0              
2927				endm 
# End of macro CWHEAD
2927			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2927					; get byte count 
2927					if DEBUG_FORTH_WORDS_KEY 
2927						DMARK "MAL" 
2927 f5				push af  
2928 3a 3c 29			ld a, (.dmark)  
292b 32 bd fb			ld (debug_mark),a  
292e 3a 3d 29			ld a, (.dmark+1)  
2931 32 be fb			ld (debug_mark+1),a  
2934 3a 3e 29			ld a, (.dmark+2)  
2937 32 bf fb			ld (debug_mark+2),a  
293a 18 03			jr .pastdmark  
293c ..			.dmark: db "MAL"  
293f f1			.pastdmark: pop af  
2940			endm  
# End of macro DMARK
2940						CALLMONITOR 
2940 cd 47 17			call break_point_state  
2943				endm  
# End of macro CALLMONITOR
2943					endif 
2943			.mallocc: 
2943					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2943 cd ce 1e			call macro_dsp_valuehl 
2946				endm 
# End of macro FORTH_DSP_VALUEHL
2946			 
2946			;		push hl 
2946			 
2946					; destroy value TOS 
2946			 
2946					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2946 cd 86 1f			call macro_forth_dsp_pop 
2949				endm 
# End of macro FORTH_DSP_POP
2949			 
2949			;		pop hl 
2949 cd e4 11				call malloc 
294c				if DEBUG_FORTH_MALLOC_GUARD 
294c f5					push af 
294d cd 46 0d				call ishlzero 
2950			;		ld a, l 
2950			;		add h 
2950			;		cp 0 
2950 f1					pop af 
2951					 
2951 cc d9 51				call z,malloc_error 
2954				endif 
2954			 
2954 cd d7 1c				call forth_push_numhl 
2957					NEXTW 
2957 c3 40 20			jp macro_next 
295a				endm 
# End of macro NEXTW
295a			 
295a			.FREE: 
295a				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
295a 57				db WORD_SYS_CORE+67             
295b 8b 29			dw .LIST            
295d 05				db 4 + 1 
295e .. 00			db "FREE",0              
2963				endm 
# End of macro CWHEAD
2963			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2963					if DEBUG_FORTH_WORDS_KEY 
2963						DMARK "FRE" 
2963 f5				push af  
2964 3a 78 29			ld a, (.dmark)  
2967 32 bd fb			ld (debug_mark),a  
296a 3a 79 29			ld a, (.dmark+1)  
296d 32 be fb			ld (debug_mark+1),a  
2970 3a 7a 29			ld a, (.dmark+2)  
2973 32 bf fb			ld (debug_mark+2),a  
2976 18 03			jr .pastdmark  
2978 ..			.dmark: db "FRE"  
297b f1			.pastdmark: pop af  
297c			endm  
# End of macro DMARK
297c						CALLMONITOR 
297c cd 47 17			call break_point_state  
297f				endm  
# End of macro CALLMONITOR
297f					endif 
297f					; get address 
297f			 
297f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
297f cd ce 1e			call macro_dsp_valuehl 
2982				endm 
# End of macro FORTH_DSP_VALUEHL
2982			 
2982			;		push hl 
2982			 
2982					; destroy value TOS 
2982			 
2982					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2982 cd 86 1f			call macro_forth_dsp_pop 
2985				endm 
# End of macro FORTH_DSP_POP
2985			 
2985			;		pop hl 
2985			if FORTH_ENABLE_MALLOCFREE 
2985 cd ae 12				call free 
2988			endif 
2988					NEXTW 
2988 c3 40 20			jp macro_next 
298b				endm 
# End of macro NEXTW
298b			.LIST: 
298b				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
298b 5c				db WORD_SYS_CORE+72             
298c 79 2b			dw .FORGET            
298e 05				db 4 + 1 
298f .. 00			db "LIST",0              
2994				endm 
# End of macro CWHEAD
2994			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2994			; | | The quoted word must be in upper case. 
2994				if DEBUG_FORTH_WORDS_KEY 
2994					DMARK "LST" 
2994 f5				push af  
2995 3a a9 29			ld a, (.dmark)  
2998 32 bd fb			ld (debug_mark),a  
299b 3a aa 29			ld a, (.dmark+1)  
299e 32 be fb			ld (debug_mark+1),a  
29a1 3a ab 29			ld a, (.dmark+2)  
29a4 32 bf fb			ld (debug_mark+2),a  
29a7 18 03			jr .pastdmark  
29a9 ..			.dmark: db "LST"  
29ac f1			.pastdmark: pop af  
29ad			endm  
# End of macro DMARK
29ad					CALLMONITOR 
29ad cd 47 17			call break_point_state  
29b0				endm  
# End of macro CALLMONITOR
29b0				endif 
29b0			 
29b0					FORTH_DSP_VALUEHL 
29b0 cd ce 1e			call macro_dsp_valuehl 
29b3				endm 
# End of macro FORTH_DSP_VALUEHL
29b3			 
29b3 e5					push hl 
29b4					FORTH_DSP_POP 
29b4 cd 86 1f			call macro_forth_dsp_pop 
29b7				endm 
# End of macro FORTH_DSP_POP
29b7 c1					pop bc 
29b8			 
29b8			; Start format of scratch string 
29b8			 
29b8 21 a3 ef				ld hl, scratch 
29bb			 
29bb 3e 3a				ld a, ':' 
29bd 77					ld (hl),a 
29be 23					inc hl 
29bf 3e 20				ld a, ' ' 
29c1 77					ld (hl), a 
29c2			 
29c2					; Get ptr to the word we need to look up 
29c2			 
29c2			;		FORTH_DSP_VALUEHL 
29c2					;v5 FORTH_DSP_VALUE 
29c2				; TODO type check 
29c2			;		inc hl    ; Skip type check  
29c2			;		push hl 
29c2			;		ex de, hl    ; put into DE 
29c2			 
29c2			 
29c2 21 00 80				ld hl, baseram 
29c5					;ld hl, baseusermem 
29c5			 
29c5 e5			push hl   ; sacreifical push 
29c6			 
29c6			.ldouscanm: 
29c6 e1				pop hl 
29c7			.ldouscan: 
29c7				if DEBUG_FORTH_WORDS 
29c7					DMARK "LSs" 
29c7 f5				push af  
29c8 3a dc 29			ld a, (.dmark)  
29cb 32 bd fb			ld (debug_mark),a  
29ce 3a dd 29			ld a, (.dmark+1)  
29d1 32 be fb			ld (debug_mark+1),a  
29d4 3a de 29			ld a, (.dmark+2)  
29d7 32 bf fb			ld (debug_mark+2),a  
29da 18 03			jr .pastdmark  
29dc ..			.dmark: db "LSs"  
29df f1			.pastdmark: pop af  
29e0			endm  
# End of macro DMARK
29e0					CALLMONITOR 
29e0 cd 47 17			call break_point_state  
29e3				endm  
# End of macro CALLMONITOR
29e3				endif 
29e3				; skip dict stub 
29e3 cd 91 21				call forth_tok_next 
29e6			 
29e6			 
29e6			; while we have words to look for 
29e6			 
29e6 7e				ld a, (hl)      
29e7				if DEBUG_FORTH_WORDS 
29e7					DMARK "LSk" 
29e7 f5				push af  
29e8 3a fc 29			ld a, (.dmark)  
29eb 32 bd fb			ld (debug_mark),a  
29ee 3a fd 29			ld a, (.dmark+1)  
29f1 32 be fb			ld (debug_mark+1),a  
29f4 3a fe 29			ld a, (.dmark+2)  
29f7 32 bf fb			ld (debug_mark+2),a  
29fa 18 03			jr .pastdmark  
29fc ..			.dmark: db "LSk"  
29ff f1			.pastdmark: pop af  
2a00			endm  
# End of macro DMARK
2a00					CALLMONITOR 
2a00 cd 47 17			call break_point_state  
2a03				endm  
# End of macro CALLMONITOR
2a03				endif 
2a03					;cp WORD_SYS_END 
2a03					;jp z, .lunotfound 
2a03			 
2a03					; if we hit non uwords then gone too far 
2a03 fe 01				cp WORD_SYS_UWORD 
2a05 c2 35 2b				jp nz, .lunotfound 
2a08			 
2a08				if DEBUG_FORTH_WORDS 
2a08					DMARK "LSu" 
2a08 f5				push af  
2a09 3a 1d 2a			ld a, (.dmark)  
2a0c 32 bd fb			ld (debug_mark),a  
2a0f 3a 1e 2a			ld a, (.dmark+1)  
2a12 32 be fb			ld (debug_mark+1),a  
2a15 3a 1f 2a			ld a, (.dmark+2)  
2a18 32 bf fb			ld (debug_mark+2),a  
2a1b 18 03			jr .pastdmark  
2a1d ..			.dmark: db "LSu"  
2a20 f1			.pastdmark: pop af  
2a21			endm  
# End of macro DMARK
2a21					CALLMONITOR 
2a21 cd 47 17			call break_point_state  
2a24				endm  
# End of macro CALLMONITOR
2a24				endif 
2a24			 
2a24					; found a uword but is it the one we want... 
2a24			 
2a24 c5					push bc     ; uword to find is on bc 
2a25 d1					pop de 
2a26			 
2a26 e5					push hl  ; to save the ptr 
2a27			 
2a27					; skip opcode 
2a27 23					inc hl  
2a28					; skip next ptr 
2a28 23					inc hl  
2a29 23					inc hl 
2a2a					; skip len 
2a2a 23					inc hl 
2a2b			 
2a2b				if DEBUG_FORTH_WORDS 
2a2b					DMARK "LSc" 
2a2b f5				push af  
2a2c 3a 40 2a			ld a, (.dmark)  
2a2f 32 bd fb			ld (debug_mark),a  
2a32 3a 41 2a			ld a, (.dmark+1)  
2a35 32 be fb			ld (debug_mark+1),a  
2a38 3a 42 2a			ld a, (.dmark+2)  
2a3b 32 bf fb			ld (debug_mark+2),a  
2a3e 18 03			jr .pastdmark  
2a40 ..			.dmark: db "LSc"  
2a43 f1			.pastdmark: pop af  
2a44			endm  
# End of macro DMARK
2a44					CALLMONITOR 
2a44 cd 47 17			call break_point_state  
2a47				endm  
# End of macro CALLMONITOR
2a47				endif 
2a47 cd b3 11				call strcmp 
2a4a c2 c6 29				jp nz, .ldouscanm 
2a4d				 
2a4d			 
2a4d			 
2a4d					; we have a uword so push its name to the stack 
2a4d			 
2a4d			;	   	push hl  ; save so we can move to next dict block 
2a4d e1			pop hl 
2a4e			 
2a4e				if DEBUG_FORTH_WORDS 
2a4e					DMARK "LSm" 
2a4e f5				push af  
2a4f 3a 63 2a			ld a, (.dmark)  
2a52 32 bd fb			ld (debug_mark),a  
2a55 3a 64 2a			ld a, (.dmark+1)  
2a58 32 be fb			ld (debug_mark+1),a  
2a5b 3a 65 2a			ld a, (.dmark+2)  
2a5e 32 bf fb			ld (debug_mark+2),a  
2a61 18 03			jr .pastdmark  
2a63 ..			.dmark: db "LSm"  
2a66 f1			.pastdmark: pop af  
2a67			endm  
# End of macro DMARK
2a67					CALLMONITOR 
2a67 cd 47 17			call break_point_state  
2a6a				endm  
# End of macro CALLMONITOR
2a6a				endif 
2a6a			 
2a6a					; skip opcode 
2a6a 23					inc hl  
2a6b					; skip next ptr 
2a6b 23					inc hl  
2a6c 23					inc hl 
2a6d					; skip len 
2a6d 7e					ld a, (hl)   ; save length to add 
2a6e				if DEBUG_FORTH_WORDS 
2a6e					DMARK "LS2" 
2a6e f5				push af  
2a6f 3a 83 2a			ld a, (.dmark)  
2a72 32 bd fb			ld (debug_mark),a  
2a75 3a 84 2a			ld a, (.dmark+1)  
2a78 32 be fb			ld (debug_mark+1),a  
2a7b 3a 85 2a			ld a, (.dmark+2)  
2a7e 32 bf fb			ld (debug_mark+2),a  
2a81 18 03			jr .pastdmark  
2a83 ..			.dmark: db "LS2"  
2a86 f1			.pastdmark: pop af  
2a87			endm  
# End of macro DMARK
2a87					CALLMONITOR 
2a87 cd 47 17			call break_point_state  
2a8a				endm  
# End of macro CALLMONITOR
2a8a				endif 
2a8a			 
2a8a					; save this location 
2a8a				 
2a8a e5					push hl 
2a8b			 
2a8b 23					inc hl 
2a8c 11 a5 ef				ld de, scratch+2 
2a8f 4f					ld c, a 
2a90 06 00				ld b, 0 
2a92			 
2a92				if DEBUG_FORTH_WORDS 
2a92					DMARK "LSn" 
2a92 f5				push af  
2a93 3a a7 2a			ld a, (.dmark)  
2a96 32 bd fb			ld (debug_mark),a  
2a99 3a a8 2a			ld a, (.dmark+1)  
2a9c 32 be fb			ld (debug_mark+1),a  
2a9f 3a a9 2a			ld a, (.dmark+2)  
2aa2 32 bf fb			ld (debug_mark+2),a  
2aa5 18 03			jr .pastdmark  
2aa7 ..			.dmark: db "LSn"  
2aaa f1			.pastdmark: pop af  
2aab			endm  
# End of macro DMARK
2aab					CALLMONITOR 
2aab cd 47 17			call break_point_state  
2aae				endm  
# End of macro CALLMONITOR
2aae				endif 
2aae			 
2aae					; copy uword name to scratch 
2aae			 
2aae ed b0				ldir 
2ab0			 
2ab0 1b					dec de 
2ab1 3e 20				ld a, ' '    ; change null to space 
2ab3 12					ld (de), a 
2ab4			 
2ab4 13					inc de 
2ab5			 
2ab5 d5					push de 
2ab6 c1					pop bc     ; move scratch pointer to end of word name and save it 
2ab7			 
2ab7 e1					pop hl 
2ab8 7e					ld a, (hl) 
2ab9					;inc hl 
2ab9					; skip word string 
2ab9 cd 1d 0d				call addatohl 
2abc			 
2abc 23					inc hl 
2abd			 
2abd				if DEBUG_FORTH_WORDS 
2abd					DMARK "LS3" 
2abd f5				push af  
2abe 3a d2 2a			ld a, (.dmark)  
2ac1 32 bd fb			ld (debug_mark),a  
2ac4 3a d3 2a			ld a, (.dmark+1)  
2ac7 32 be fb			ld (debug_mark+1),a  
2aca 3a d4 2a			ld a, (.dmark+2)  
2acd 32 bf fb			ld (debug_mark+2),a  
2ad0 18 03			jr .pastdmark  
2ad2 ..			.dmark: db "LS3"  
2ad5 f1			.pastdmark: pop af  
2ad6			endm  
# End of macro DMARK
2ad6					CALLMONITOR 
2ad6 cd 47 17			call break_point_state  
2ad9				endm  
# End of macro CALLMONITOR
2ad9				endif 
2ad9					; should now be at the start of the machine code to setup the eval of the uword 
2ad9					; now locate the ptr to the string defintion 
2ad9			 
2ad9					; skip ld hl, 
2ad9					; then load the ptr 
2ad9			; TODO use get from hl ptr 
2ad9 23					inc hl 
2ada 5e					ld e, (hl) 
2adb 23					inc hl 
2adc 56					ld d, (hl) 
2add eb					ex de, hl 
2ade			 
2ade			 
2ade				if DEBUG_FORTH_WORDS 
2ade					DMARK "LSt" 
2ade f5				push af  
2adf 3a f3 2a			ld a, (.dmark)  
2ae2 32 bd fb			ld (debug_mark),a  
2ae5 3a f4 2a			ld a, (.dmark+1)  
2ae8 32 be fb			ld (debug_mark+1),a  
2aeb 3a f5 2a			ld a, (.dmark+2)  
2aee 32 bf fb			ld (debug_mark+2),a  
2af1 18 03			jr .pastdmark  
2af3 ..			.dmark: db "LSt"  
2af6 f1			.pastdmark: pop af  
2af7			endm  
# End of macro DMARK
2af7					CALLMONITOR 
2af7 cd 47 17			call break_point_state  
2afa				endm  
# End of macro CALLMONITOR
2afa				endif 
2afa			 
2afa			; cant push right now due to tokenised strings  
2afa			 
2afa			; get the destination of where to copy this definition to. 
2afa			 
2afa c5					push bc 
2afb d1					pop de 
2afc			 
2afc 7e			.listl:         ld a,(hl) 
2afd fe 00				cp 0 
2aff 28 09				jr z, .lreplsp     ; replace zero with space 
2b01					;cp FORTH_END_BUFFER 
2b01 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2b03 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b05				 
2b05					; just copy this char as is then 
2b05			 
2b05 12					ld (de), a 
2b06			 
2b06 23			.listnxt:	inc hl 
2b07 13					inc de 
2b08 18 f2				jr .listl 
2b0a			 
2b0a 3e 20		.lreplsp:	ld a,' ' 
2b0c 12					ld (de), a 
2b0d 18 f7				jr .listnxt 
2b0f			 
2b0f			; close up uword def 
2b0f			 
2b0f			.listdone: 
2b0f 12					ld (de), a 
2b10 13					inc de 
2b11 3e 00				ld a, 0 
2b13 12					ld (de), a 
2b14			 
2b14			; now have def so clean up and push to stack 
2b14			 
2b14 21 a3 ef				ld hl, scratch 
2b17				if DEBUG_FORTH_WORDS 
2b17					DMARK "Ltp" 
2b17 f5				push af  
2b18 3a 2c 2b			ld a, (.dmark)  
2b1b 32 bd fb			ld (debug_mark),a  
2b1e 3a 2d 2b			ld a, (.dmark+1)  
2b21 32 be fb			ld (debug_mark+1),a  
2b24 3a 2e 2b			ld a, (.dmark+2)  
2b27 32 bf fb			ld (debug_mark+2),a  
2b2a 18 03			jr .pastdmark  
2b2c ..			.dmark: db "Ltp"  
2b2f f1			.pastdmark: pop af  
2b30			endm  
# End of macro DMARK
2b30					CALLMONITOR 
2b30 cd 47 17			call break_point_state  
2b33				endm  
# End of macro CALLMONITOR
2b33				endif 
2b33			 
2b33 18 1f			jr .listpush 
2b35			 
2b35			;.lnuword:	pop hl 
2b35			;		call forth_tok_next 
2b35			;		jp .ldouscan  
2b35			 
2b35			.lunotfound:		  
2b35			 
2b35				if DEBUG_FORTH_WORDS 
2b35					DMARK "LSn" 
2b35 f5				push af  
2b36 3a 4a 2b			ld a, (.dmark)  
2b39 32 bd fb			ld (debug_mark),a  
2b3c 3a 4b 2b			ld a, (.dmark+1)  
2b3f 32 be fb			ld (debug_mark+1),a  
2b42 3a 4c 2b			ld a, (.dmark+2)  
2b45 32 bf fb			ld (debug_mark+2),a  
2b48 18 03			jr .pastdmark  
2b4a ..			.dmark: db "LSn"  
2b4d f1			.pastdmark: pop af  
2b4e			endm  
# End of macro DMARK
2b4e					CALLMONITOR 
2b4e cd 47 17			call break_point_state  
2b51				endm  
# End of macro CALLMONITOR
2b51				endif 
2b51			 
2b51					 
2b51			;		FORTH_DSP_POP 
2b51			;		ld hl, .luno 
2b51			 
2b51					NEXTW			 
2b51 c3 40 20			jp macro_next 
2b54				endm 
# End of macro NEXTW
2b54			 
2b54			.listpush: 
2b54				if DEBUG_FORTH_WORDS 
2b54					DMARK "LS>" 
2b54 f5				push af  
2b55 3a 69 2b			ld a, (.dmark)  
2b58 32 bd fb			ld (debug_mark),a  
2b5b 3a 6a 2b			ld a, (.dmark+1)  
2b5e 32 be fb			ld (debug_mark+1),a  
2b61 3a 6b 2b			ld a, (.dmark+2)  
2b64 32 bf fb			ld (debug_mark+2),a  
2b67 18 03			jr .pastdmark  
2b69 ..			.dmark: db "LS>"  
2b6c f1			.pastdmark: pop af  
2b6d			endm  
# End of macro DMARK
2b6d					CALLMONITOR 
2b6d cd 47 17			call break_point_state  
2b70				endm  
# End of macro CALLMONITOR
2b70				endif 
2b70 cd 45 1d				call forth_push_str 
2b73			 
2b73			 
2b73			 
2b73					NEXTW 
2b73 c3 40 20			jp macro_next 
2b76				endm 
# End of macro NEXTW
2b76			 
2b76			;.luno:    db "Word not found",0 
2b76			 
2b76			 
2b76			 
2b76			 
2b76			 
2b76			;		push hl   ; save pointer to start of uword def string 
2b76			; 
2b76			;; look for FORTH_EOL_LINE 
2b76			;		ld a, FORTH_END_BUFFER 
2b76			;		call strlent 
2b76			; 
2b76			;		inc hl		 ; space for coln def 
2b76			;		inc hl 
2b76			;		inc hl          ; space for terms 
2b76			;		inc hl 
2b76			; 
2b76			;		ld a, 20   ; TODO get actual length 
2b76			;		call addatohl    ; include a random amount of room for the uword name 
2b76			; 
2b76			;		 
2b76			;	if DEBUG_FORTH_WORDS 
2b76			;		DMARK "Lt1" 
2b76			;		CALLMONITOR 
2b76			;	endif 
2b76			;		 
2b76			; 
2b76			;; malloc space for the string because we cant change it 
2b76			; 
2b76			;		call malloc 
2b76			;	if DEBUG_FORTH_MALLOC_GUARD 
2b76			;		push af 
2b76			;		call ishlzero 
2b76			;		pop af 
2b76			;		 
2b76			;		call z,malloc_error 
2b76			;	endif 
2b76			; 
2b76			;	if DEBUG_FORTH_WORDS 
2b76			;		DMARK "Lt2" 
2b76			;		CALLMONITOR 
2b76			;	endif 
2b76			;		pop de 
2b76			;		push hl    ; push the malloc to release later 
2b76			;		push hl   ;  push back a copy for the later stack push 
2b76			;		 
2b76			;; copy the string swapping out the zero terms for spaces 
2b76			; 
2b76			;		; de has our source 
2b76			;		; hl has our dest 
2b76			; 
2b76			;; add the coln def 
2b76			; 
2b76			;		ld a, ':' 
2b76			;		ld (hl), a 
2b76			;		inc hl 
2b76			;		ld a, ' ' 
2b76			;		ld (hl), a 
2b76			;		inc hl 
2b76			; 
2b76			;; add the uname word 
2b76			;		push de   ; save our string for now 
2b76			;		ex de, hl 
2b76			; 
2b76			;		FORTH_DSP_VALUE 
2b76			;		;v5 FORTH_DSP_VALUE 
2b76			; 
2b76			;		inc hl   ; skip type but we know by now this is OK 
2b76			; 
2b76			;.luword:	ld a,(hl) 
2b76			;		cp 0 
2b76			;		jr z, .luword2 
2b76			;		ld (de), a 
2b76			;		inc de 
2b76			;		inc hl 
2b76			;		jr .luword 
2b76			; 
2b76			;.luword2:	ld a, ' ' 
2b76			;		ld (de), a 
2b76			;;		inc hl 
2b76			;;		inc de 
2b76			;;		ld (de), a 
2b76			;;		inc hl 
2b76			;		inc de 
2b76			; 
2b76			;		ex de, hl 
2b76			;		pop de 
2b76			;		 
2b76			;		 
2b76			; 
2b76			;; detoken that string and copy it 
2b76			; 
2b76			;	if DEBUG_FORTH_WORDS 
2b76			;		DMARK "Lt2" 
2b76			;		CALLMONITOR 
2b76			;	endif 
2b76			;.ldetok:	ld a, (de) 
2b76			;		cp FORTH_END_BUFFER 
2b76			;		jr z, .ldetokend 
2b76			;		; swap out any zero term for space 
2b76			;		cp 0 
2b76			;		jr nz, .ldetoknext 
2b76			;		ld a, ' ' 
2b76			; 
2b76			;	if DEBUG_FORTH_WORDS 
2b76			;		DMARK "LtS" 
2b76			;		CALLMONITOR 
2b76			;	endif 
2b76			;.ldetoknext:	ld (hl), a 
2b76			;		inc de 
2b76			;		inc hl 
2b76			;		jr .ldetok 
2b76			; 
2b76			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b76			;		ld (hl), a  
2b76			; 
2b76			;; free that temp malloc 
2b76			; 
2b76			;		pop hl    
2b76			; 
2b76			;	if DEBUG_FORTH_WORDS 
2b76			;		DMARK "Lt4" 
2b76			;		CALLMONITOR 
2b76			;	endif 
2b76			;		call forth_apushstrhl 
2b76			; 
2b76			;		; get rid of temp malloc area 
2b76			; 
2b76			;		pop hl 
2b76			;		call free 
2b76			; 
2b76			;		jr .ludone 
2b76			; 
2b76			;.lnuword:	pop hl 
2b76			;		call forth_tok_next 
2b76			;		jp .ldouscan  
2b76			; 
2b76			;.ludone:		 pop hl 
2b76			; 
2b76					NEXTW 
2b76 c3 40 20			jp macro_next 
2b79				endm 
# End of macro NEXTW
2b79			 
2b79			.FORGET: 
2b79				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b79 5d				db WORD_SYS_CORE+73             
2b7a f2 2b			dw .NOP            
2b7c 07				db 6 + 1 
2b7d .. 00			db "FORGET",0              
2b84				endm 
# End of macro CWHEAD
2b84			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b84			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b84			; | |  
2b84			; | | e.g. "MORE" forget 
2b84					if DEBUG_FORTH_WORDS_KEY 
2b84						DMARK "FRG" 
2b84 f5				push af  
2b85 3a 99 2b			ld a, (.dmark)  
2b88 32 bd fb			ld (debug_mark),a  
2b8b 3a 9a 2b			ld a, (.dmark+1)  
2b8e 32 be fb			ld (debug_mark+1),a  
2b91 3a 9b 2b			ld a, (.dmark+2)  
2b94 32 bf fb			ld (debug_mark+2),a  
2b97 18 03			jr .pastdmark  
2b99 ..			.dmark: db "FRG"  
2b9c f1			.pastdmark: pop af  
2b9d			endm  
# End of macro DMARK
2b9d						CALLMONITOR 
2b9d cd 47 17			call break_point_state  
2ba0				endm  
# End of macro CALLMONITOR
2ba0					endif 
2ba0			 
2ba0				; find uword 
2ba0			        ; update start of word with "_" 
2ba0				; replace uword with deleted flag 
2ba0			 
2ba0			 
2ba0			;	if DEBUG_FORTH_WORDS 
2ba0			;		DMARK "FOG" 
2ba0			;		CALLMONITOR 
2ba0			;	endif 
2ba0			 
2ba0			 
2ba0					; Get ptr to the word we need to look up 
2ba0			 
2ba0					FORTH_DSP_VALUEHL 
2ba0 cd ce 1e			call macro_dsp_valuehl 
2ba3				endm 
# End of macro FORTH_DSP_VALUEHL
2ba3					;v5 FORTH_DSP_VALUE 
2ba3				; TODO type check 
2ba3			;		inc hl    ; Skip type check  
2ba3 e5					push hl 
2ba4 c1					pop bc 
2ba5			;		ex de, hl    ; put into DE 
2ba5			 
2ba5			 
2ba5 21 00 80				ld hl, baseram 
2ba8					;ld hl, baseusermem 
2ba8			 
2ba8				; skip dict stub 
2ba8			;	call forth_tok_next 
2ba8 e5			push hl   ; sacreifical push 
2ba9			 
2ba9			.fldouscanm: 
2ba9 e1				pop hl 
2baa			.fldouscan: 
2baa			;	if DEBUG_FORTH_WORDS 
2baa			;		DMARK "LSs" 
2baa			;		CALLMONITOR 
2baa			;	endif 
2baa				; skip dict stub 
2baa cd 91 21				call forth_tok_next 
2bad			 
2bad			 
2bad			; while we have words to look for 
2bad			 
2bad 7e				ld a, (hl)      
2bae			;	if DEBUG_FORTH_WORDS 
2bae			;		DMARK "LSk" 
2bae			;		CALLMONITOR 
2bae			;	endif 
2bae fe 00				cp WORD_SYS_END 
2bb0 ca ec 2b				jp z, .flunotfound 
2bb3 fe 01				cp WORD_SYS_UWORD 
2bb5 c2 aa 2b				jp nz, .fldouscan 
2bb8			 
2bb8			;	if DEBUG_FORTH_WORDS 
2bb8			;		DMARK "LSu" 
2bb8			;		CALLMONITOR 
2bb8			;	endif 
2bb8			 
2bb8					; found a uword but is it the one we want... 
2bb8			 
2bb8 c5					push bc     ; uword to find is on bc 
2bb9 d1					pop de 
2bba			 
2bba e5					push hl  ; to save the ptr 
2bbb			 
2bbb					; skip opcode 
2bbb 23					inc hl  
2bbc					; skip next ptr 
2bbc 23					inc hl  
2bbd 23					inc hl 
2bbe					; skip len 
2bbe 23					inc hl 
2bbf			 
2bbf			;	if DEBUG_FORTH_WORDS 
2bbf			;		DMARK "LSc" 
2bbf			;		CALLMONITOR 
2bbf			;	endif 
2bbf cd b3 11				call strcmp 
2bc2 c2 a9 2b				jp nz, .fldouscanm 
2bc5			; 
2bc5			; 
2bc5			;; while we have words to look for 
2bc5			; 
2bc5			;.fdouscan:	ld a, (hl)      
2bc5			;	if DEBUG_FORTH_WORDS 
2bc5			;		DMARK "LSs" 
2bc5			;		CALLMONITOR 
2bc5			;	endif 
2bc5			;		cp WORD_SYS_END 
2bc5			;		jp z, .fudone 
2bc5			;		cp WORD_SYS_UWORD 
2bc5			;		jp nz, .fnuword 
2bc5			; 
2bc5			;	if DEBUG_FORTH_WORDS 
2bc5			;		DMARK "FGu" 
2bc5			;		CALLMONITOR 
2bc5			;	endif 
2bc5			; 
2bc5			;		; found a uword but is it the one we want... 
2bc5			; 
2bc5			; 
2bc5			;	        pop de   ; get back the dsp name 
2bc5			;		push de 
2bc5			; 
2bc5			;		push hl  ; to save the ptr 
2bc5			; 
2bc5			;		; skip opcode 
2bc5			;		inc hl  
2bc5			;		; skip next ptr 
2bc5			;		inc hl  
2bc5			;		inc hl 
2bc5			;		; skip len 
2bc5			;		inc hl 
2bc5			; 
2bc5			;	if DEBUG_FORTH_WORDS 
2bc5			;		DMARK "FGc" 
2bc5			;		CALLMONITOR 
2bc5			;	endif 
2bc5			;		call strcmp 
2bc5			;		jp nz, .fnuword 
2bc5			 
2bc5			 
2bc5 e1			pop hl 
2bc6			 
2bc6				 
2bc6				if DEBUG_FORTH_WORDS 
2bc6					DMARK "FGm" 
2bc6 f5				push af  
2bc7 3a db 2b			ld a, (.dmark)  
2bca 32 bd fb			ld (debug_mark),a  
2bcd 3a dc 2b			ld a, (.dmark+1)  
2bd0 32 be fb			ld (debug_mark+1),a  
2bd3 3a dd 2b			ld a, (.dmark+2)  
2bd6 32 bf fb			ld (debug_mark+2),a  
2bd9 18 03			jr .pastdmark  
2bdb ..			.dmark: db "FGm"  
2bde f1			.pastdmark: pop af  
2bdf			endm  
# End of macro DMARK
2bdf					CALLMONITOR 
2bdf cd 47 17			call break_point_state  
2be2				endm  
# End of macro CALLMONITOR
2be2				endif 
2be2			 
2be2			 
2be2			 
2be2					; we have a uword so push its name to the stack 
2be2			 
2be2			;	   	push hl  ; save so we can move to next dict block 
2be2			;pop hl 
2be2			 
2be2					; update opcode to deleted 
2be2 3e 03				ld a, WORD_SYS_DELETED 
2be4 77					ld (hl), a 
2be5			 
2be5 23					inc hl  
2be6					; skip next ptr 
2be6 23					inc hl  
2be7 23					inc hl 
2be8					; skip len 
2be8 23					inc hl 
2be9			 
2be9					; TODO change parser to skip deleted words but for now mark it out 
2be9 3e 5f				ld a, "_" 
2beb 77					ld  (hl),a 
2bec			 
2bec			;		jr .fudone 
2bec			; 
2bec			;.fnuword:	pop hl 
2bec			;		call forth_tok_next 
2bec			;		jp .fdouscan  
2bec			 
2bec			.flunotfound:		  
2bec			 
2bec			 
2bec					 
2bec					FORTH_DSP_POP 
2bec cd 86 1f			call macro_forth_dsp_pop 
2bef				endm 
# End of macro FORTH_DSP_POP
2bef			;		ld hl, .luno 
2bef			;.fudone:		 pop hl 
2bef					NEXTW 
2bef c3 40 20			jp macro_next 
2bf2				endm 
# End of macro NEXTW
2bf2			.NOP: 
2bf2				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bf2 61				db WORD_SYS_CORE+77             
2bf3 19 2c			dw .COMO            
2bf5 04				db 3 + 1 
2bf6 .. 00			db "NOP",0              
2bfa				endm 
# End of macro CWHEAD
2bfa			; | NOP (  --  ) Do nothing | DONE 
2bfa					if DEBUG_FORTH_WORDS_KEY 
2bfa						DMARK "NOP" 
2bfa f5				push af  
2bfb 3a 0f 2c			ld a, (.dmark)  
2bfe 32 bd fb			ld (debug_mark),a  
2c01 3a 10 2c			ld a, (.dmark+1)  
2c04 32 be fb			ld (debug_mark+1),a  
2c07 3a 11 2c			ld a, (.dmark+2)  
2c0a 32 bf fb			ld (debug_mark+2),a  
2c0d 18 03			jr .pastdmark  
2c0f ..			.dmark: db "NOP"  
2c12 f1			.pastdmark: pop af  
2c13			endm  
# End of macro DMARK
2c13						CALLMONITOR 
2c13 cd 47 17			call break_point_state  
2c16				endm  
# End of macro CALLMONITOR
2c16					endif 
2c16				       NEXTW 
2c16 c3 40 20			jp macro_next 
2c19				endm 
# End of macro NEXTW
2c19			.COMO: 
2c19				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c19 6e				db WORD_SYS_CORE+90             
2c1a 6b 2c			dw .COMC            
2c1c 02				db 1 + 1 
2c1d .. 00			db "(",0              
2c1f				endm 
# End of macro CWHEAD
2c1f			; | ( ( -- )  Start of comment | DONE 
2c1f			 
2c1f			 
2c1f 2a a4 f2				ld hl, ( os_tok_ptr) 
2c22 11 66 2c			ld de, .closepar 
2c25					 
2c25					if DEBUG_FORTH_WORDS 
2c25						DMARK ").." 
2c25 f5				push af  
2c26 3a 3a 2c			ld a, (.dmark)  
2c29 32 bd fb			ld (debug_mark),a  
2c2c 3a 3b 2c			ld a, (.dmark+1)  
2c2f 32 be fb			ld (debug_mark+1),a  
2c32 3a 3c 2c			ld a, (.dmark+2)  
2c35 32 bf fb			ld (debug_mark+2),a  
2c38 18 03			jr .pastdmark  
2c3a ..			.dmark: db ").."  
2c3d f1			.pastdmark: pop af  
2c3e			endm  
# End of macro DMARK
2c3e						CALLMONITOR 
2c3e cd 47 17			call break_point_state  
2c41				endm  
# End of macro CALLMONITOR
2c41					endif 
2c41 cd 5b 21			call findnexttok  
2c44			 
2c44					if DEBUG_FORTH_WORDS 
2c44						DMARK "IF5" 
2c44 f5				push af  
2c45 3a 59 2c			ld a, (.dmark)  
2c48 32 bd fb			ld (debug_mark),a  
2c4b 3a 5a 2c			ld a, (.dmark+1)  
2c4e 32 be fb			ld (debug_mark+1),a  
2c51 3a 5b 2c			ld a, (.dmark+2)  
2c54 32 bf fb			ld (debug_mark+2),a  
2c57 18 03			jr .pastdmark  
2c59 ..			.dmark: db "IF5"  
2c5c f1			.pastdmark: pop af  
2c5d			endm  
# End of macro DMARK
2c5d						CALLMONITOR 
2c5d cd 47 17			call break_point_state  
2c60				endm  
# End of macro CALLMONITOR
2c60					endif 
2c60				; replace below with ) exec using tok_ptr 
2c60 22 a4 f2			ld (os_tok_ptr), hl 
2c63 c3 d1 20			jp exec1 
2c66			 
2c66 .. 00			.closepar:   db ")",0 
2c68			 
2c68				       NEXTW 
2c68 c3 40 20			jp macro_next 
2c6b				endm 
# End of macro NEXTW
2c6b			.COMC: 
2c6b				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c6b 6f				db WORD_SYS_CORE+91             
2c6c 74 2c			dw .SCRATCH            
2c6e 02				db 1 + 1 
2c6f .. 00			db ")",0              
2c71				endm 
# End of macro CWHEAD
2c71			; | ) ( -- )  End of comment |  DONE  
2c71				       NEXTW 
2c71 c3 40 20			jp macro_next 
2c74				endm 
# End of macro NEXTW
2c74			 
2c74			.SCRATCH: 
2c74				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c74 6f				db WORD_SYS_CORE+91             
2c75 af 2c			dw .INC            
2c77 08				db 7 + 1 
2c78 .. 00			db "SCRATCH",0              
2c80				endm 
# End of macro CWHEAD
2c80			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c80			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c80			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c80			; | |  
2c80			; | | e.g.    : score $00 scratch ; 
2c80			; | |  
2c80			; | | $00 score ! 
2c80			; | | $01 score +! 
2c80			; | |  
2c80			; | | e.g.   : varword $0a scratch ;  
2c80			; | | 
2c80			; | | $8000 varword ! 
2c80					if DEBUG_FORTH_WORDS_KEY 
2c80						DMARK "SCR" 
2c80 f5				push af  
2c81 3a 95 2c			ld a, (.dmark)  
2c84 32 bd fb			ld (debug_mark),a  
2c87 3a 96 2c			ld a, (.dmark+1)  
2c8a 32 be fb			ld (debug_mark+1),a  
2c8d 3a 97 2c			ld a, (.dmark+2)  
2c90 32 bf fb			ld (debug_mark+2),a  
2c93 18 03			jr .pastdmark  
2c95 ..			.dmark: db "SCR"  
2c98 f1			.pastdmark: pop af  
2c99			endm  
# End of macro DMARK
2c99						CALLMONITOR 
2c99 cd 47 17			call break_point_state  
2c9c				endm  
# End of macro CALLMONITOR
2c9c					endif 
2c9c			 
2c9c					FORTH_DSP_VALUEHL 
2c9c cd ce 1e			call macro_dsp_valuehl 
2c9f				endm 
# End of macro FORTH_DSP_VALUEHL
2c9f				 
2c9f					FORTH_DSP_POP 
2c9f cd 86 1f			call macro_forth_dsp_pop 
2ca2				endm 
# End of macro FORTH_DSP_POP
2ca2			 
2ca2 7d					ld a, l 
2ca3 21 c8 f4				ld hl, os_var_array 
2ca6 cd 1d 0d				call addatohl 
2ca9			 
2ca9 cd d7 1c				call forth_push_numhl 
2cac			 
2cac				       NEXTW 
2cac c3 40 20			jp macro_next 
2caf				endm 
# End of macro NEXTW
2caf			 
2caf			.INC: 
2caf				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2caf 6f				db WORD_SYS_CORE+91             
2cb0 03 2d			dw .DEC            
2cb2 03				db 2 + 1 
2cb3 .. 00			db "+!",0              
2cb6				endm 
# End of macro CWHEAD
2cb6			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2cb6					if DEBUG_FORTH_WORDS_KEY 
2cb6						DMARK "+s_" 
2cb6 f5				push af  
2cb7 3a cb 2c			ld a, (.dmark)  
2cba 32 bd fb			ld (debug_mark),a  
2cbd 3a cc 2c			ld a, (.dmark+1)  
2cc0 32 be fb			ld (debug_mark+1),a  
2cc3 3a cd 2c			ld a, (.dmark+2)  
2cc6 32 bf fb			ld (debug_mark+2),a  
2cc9 18 03			jr .pastdmark  
2ccb ..			.dmark: db "+s_"  
2cce f1			.pastdmark: pop af  
2ccf			endm  
# End of macro DMARK
2ccf						CALLMONITOR 
2ccf cd 47 17			call break_point_state  
2cd2				endm  
# End of macro CALLMONITOR
2cd2					endif 
2cd2			 
2cd2					FORTH_DSP_VALUEHL 
2cd2 cd ce 1e			call macro_dsp_valuehl 
2cd5				endm 
# End of macro FORTH_DSP_VALUEHL
2cd5			 
2cd5 e5					push hl   ; save address 
2cd6			 
2cd6					FORTH_DSP_POP 
2cd6 cd 86 1f			call macro_forth_dsp_pop 
2cd9				endm 
# End of macro FORTH_DSP_POP
2cd9			 
2cd9					FORTH_DSP_VALUEHL 
2cd9 cd ce 1e			call macro_dsp_valuehl 
2cdc				endm 
# End of macro FORTH_DSP_VALUEHL
2cdc			 
2cdc					FORTH_DSP_POP 
2cdc cd 86 1f			call macro_forth_dsp_pop 
2cdf				endm 
# End of macro FORTH_DSP_POP
2cdf			 
2cdf					; hl contains value to add to byte at a 
2cdf				 
2cdf eb					ex de, hl 
2ce0			 
2ce0 e1					pop hl 
2ce1			 
2ce1					if DEBUG_FORTH_WORDS 
2ce1						DMARK "INC" 
2ce1 f5				push af  
2ce2 3a f6 2c			ld a, (.dmark)  
2ce5 32 bd fb			ld (debug_mark),a  
2ce8 3a f7 2c			ld a, (.dmark+1)  
2ceb 32 be fb			ld (debug_mark+1),a  
2cee 3a f8 2c			ld a, (.dmark+2)  
2cf1 32 bf fb			ld (debug_mark+2),a  
2cf4 18 03			jr .pastdmark  
2cf6 ..			.dmark: db "INC"  
2cf9 f1			.pastdmark: pop af  
2cfa			endm  
# End of macro DMARK
2cfa						CALLMONITOR 
2cfa cd 47 17			call break_point_state  
2cfd				endm  
# End of macro CALLMONITOR
2cfd					endif 
2cfd			 
2cfd 7e					ld a,(hl) 
2cfe 83					add e 
2cff 77					ld (hl),a 
2d00			 
2d00			 
2d00			 
2d00				       NEXTW 
2d00 c3 40 20			jp macro_next 
2d03				endm 
# End of macro NEXTW
2d03			 
2d03			.DEC: 
2d03				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d03 6f				db WORD_SYS_CORE+91             
2d04 54 2d			dw .INC2            
2d06 03				db 2 + 1 
2d07 .. 00			db "-!",0              
2d0a				endm 
# End of macro CWHEAD
2d0a			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d0a					if DEBUG_FORTH_WORDS_KEY 
2d0a						DMARK "-s_" 
2d0a f5				push af  
2d0b 3a 1f 2d			ld a, (.dmark)  
2d0e 32 bd fb			ld (debug_mark),a  
2d11 3a 20 2d			ld a, (.dmark+1)  
2d14 32 be fb			ld (debug_mark+1),a  
2d17 3a 21 2d			ld a, (.dmark+2)  
2d1a 32 bf fb			ld (debug_mark+2),a  
2d1d 18 03			jr .pastdmark  
2d1f ..			.dmark: db "-s_"  
2d22 f1			.pastdmark: pop af  
2d23			endm  
# End of macro DMARK
2d23						CALLMONITOR 
2d23 cd 47 17			call break_point_state  
2d26				endm  
# End of macro CALLMONITOR
2d26					endif 
2d26			 
2d26					FORTH_DSP_VALUEHL 
2d26 cd ce 1e			call macro_dsp_valuehl 
2d29				endm 
# End of macro FORTH_DSP_VALUEHL
2d29			 
2d29 e5					push hl   ; save address 
2d2a			 
2d2a					FORTH_DSP_POP 
2d2a cd 86 1f			call macro_forth_dsp_pop 
2d2d				endm 
# End of macro FORTH_DSP_POP
2d2d			 
2d2d					FORTH_DSP_VALUEHL 
2d2d cd ce 1e			call macro_dsp_valuehl 
2d30				endm 
# End of macro FORTH_DSP_VALUEHL
2d30			 
2d30					; hl contains value to add to byte at a 
2d30				 
2d30 eb					ex de, hl 
2d31			 
2d31 e1					pop hl 
2d32			 
2d32					if DEBUG_FORTH_WORDS 
2d32						DMARK "DEC" 
2d32 f5				push af  
2d33 3a 47 2d			ld a, (.dmark)  
2d36 32 bd fb			ld (debug_mark),a  
2d39 3a 48 2d			ld a, (.dmark+1)  
2d3c 32 be fb			ld (debug_mark+1),a  
2d3f 3a 49 2d			ld a, (.dmark+2)  
2d42 32 bf fb			ld (debug_mark+2),a  
2d45 18 03			jr .pastdmark  
2d47 ..			.dmark: db "DEC"  
2d4a f1			.pastdmark: pop af  
2d4b			endm  
# End of macro DMARK
2d4b						CALLMONITOR 
2d4b cd 47 17			call break_point_state  
2d4e				endm  
# End of macro CALLMONITOR
2d4e					endif 
2d4e			 
2d4e 7e					ld a,(hl) 
2d4f 93					sub e 
2d50 77					ld (hl),a 
2d51			 
2d51			 
2d51			 
2d51				       NEXTW 
2d51 c3 40 20			jp macro_next 
2d54				endm 
# End of macro NEXTW
2d54			 
2d54			.INC2: 
2d54				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d54 6f				db WORD_SYS_CORE+91             
2d55 fe 2d			dw .DEC2            
2d57 04				db 3 + 1 
2d58 .. 00			db "+2!",0              
2d5c				endm 
# End of macro CWHEAD
2d5c			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d5c			 
2d5c					if DEBUG_FORTH_WORDS_KEY 
2d5c						DMARK "+2s" 
2d5c f5				push af  
2d5d 3a 71 2d			ld a, (.dmark)  
2d60 32 bd fb			ld (debug_mark),a  
2d63 3a 72 2d			ld a, (.dmark+1)  
2d66 32 be fb			ld (debug_mark+1),a  
2d69 3a 73 2d			ld a, (.dmark+2)  
2d6c 32 bf fb			ld (debug_mark+2),a  
2d6f 18 03			jr .pastdmark  
2d71 ..			.dmark: db "+2s"  
2d74 f1			.pastdmark: pop af  
2d75			endm  
# End of macro DMARK
2d75						CALLMONITOR 
2d75 cd 47 17			call break_point_state  
2d78				endm  
# End of macro CALLMONITOR
2d78					endif 
2d78			 
2d78					; Address 
2d78			 
2d78					FORTH_DSP_VALUEHL 
2d78 cd ce 1e			call macro_dsp_valuehl 
2d7b				endm 
# End of macro FORTH_DSP_VALUEHL
2d7b			 
2d7b e5					push hl    ; save address 
2d7c			 
2d7c					; load content into de 
2d7c			 
2d7c 5e					ld e,(hl) 
2d7d 23					inc hl 
2d7e 56					ld d, (hl) 
2d7f			 
2d7f					if DEBUG_FORTH_WORDS 
2d7f						DMARK "+2a" 
2d7f f5				push af  
2d80 3a 94 2d			ld a, (.dmark)  
2d83 32 bd fb			ld (debug_mark),a  
2d86 3a 95 2d			ld a, (.dmark+1)  
2d89 32 be fb			ld (debug_mark+1),a  
2d8c 3a 96 2d			ld a, (.dmark+2)  
2d8f 32 bf fb			ld (debug_mark+2),a  
2d92 18 03			jr .pastdmark  
2d94 ..			.dmark: db "+2a"  
2d97 f1			.pastdmark: pop af  
2d98			endm  
# End of macro DMARK
2d98						CALLMONITOR 
2d98 cd 47 17			call break_point_state  
2d9b				endm  
# End of macro CALLMONITOR
2d9b					endif 
2d9b			 
2d9b					FORTH_DSP_POP 
2d9b cd 86 1f			call macro_forth_dsp_pop 
2d9e				endm 
# End of macro FORTH_DSP_POP
2d9e			 
2d9e					; Get value to add 
2d9e			 
2d9e					FORTH_DSP_VALUE 
2d9e cd b7 1e			call macro_forth_dsp_value 
2da1				endm 
# End of macro FORTH_DSP_VALUE
2da1			 
2da1					if DEBUG_FORTH_WORDS 
2da1						DMARK "+2v" 
2da1 f5				push af  
2da2 3a b6 2d			ld a, (.dmark)  
2da5 32 bd fb			ld (debug_mark),a  
2da8 3a b7 2d			ld a, (.dmark+1)  
2dab 32 be fb			ld (debug_mark+1),a  
2dae 3a b8 2d			ld a, (.dmark+2)  
2db1 32 bf fb			ld (debug_mark+2),a  
2db4 18 03			jr .pastdmark  
2db6 ..			.dmark: db "+2v"  
2db9 f1			.pastdmark: pop af  
2dba			endm  
# End of macro DMARK
2dba						CALLMONITOR 
2dba cd 47 17			call break_point_state  
2dbd				endm  
# End of macro CALLMONITOR
2dbd					endif 
2dbd			 
2dbd 19					add hl, de 
2dbe			 
2dbe					if DEBUG_FORTH_WORDS 
2dbe						DMARK "+2+" 
2dbe f5				push af  
2dbf 3a d3 2d			ld a, (.dmark)  
2dc2 32 bd fb			ld (debug_mark),a  
2dc5 3a d4 2d			ld a, (.dmark+1)  
2dc8 32 be fb			ld (debug_mark+1),a  
2dcb 3a d5 2d			ld a, (.dmark+2)  
2dce 32 bf fb			ld (debug_mark+2),a  
2dd1 18 03			jr .pastdmark  
2dd3 ..			.dmark: db "+2+"  
2dd6 f1			.pastdmark: pop af  
2dd7			endm  
# End of macro DMARK
2dd7						CALLMONITOR 
2dd7 cd 47 17			call break_point_state  
2dda				endm  
# End of macro CALLMONITOR
2dda					endif 
2dda			 
2dda					; move result to de 
2dda			 
2dda eb					ex de, hl 
2ddb			 
2ddb					; Address 
2ddb			 
2ddb e1					pop hl 
2ddc			 
2ddc					; save it back 
2ddc			 
2ddc 73					ld (hl), e 
2ddd 23					inc hl 
2dde 72					ld (hl), d 
2ddf			 
2ddf					if DEBUG_FORTH_WORDS 
2ddf						DMARK "+2e" 
2ddf f5				push af  
2de0 3a f4 2d			ld a, (.dmark)  
2de3 32 bd fb			ld (debug_mark),a  
2de6 3a f5 2d			ld a, (.dmark+1)  
2de9 32 be fb			ld (debug_mark+1),a  
2dec 3a f6 2d			ld a, (.dmark+2)  
2def 32 bf fb			ld (debug_mark+2),a  
2df2 18 03			jr .pastdmark  
2df4 ..			.dmark: db "+2e"  
2df7 f1			.pastdmark: pop af  
2df8			endm  
# End of macro DMARK
2df8						CALLMONITOR 
2df8 cd 47 17			call break_point_state  
2dfb				endm  
# End of macro CALLMONITOR
2dfb					endif 
2dfb			 
2dfb			 
2dfb			 
2dfb			 
2dfb			 
2dfb				       NEXTW 
2dfb c3 40 20			jp macro_next 
2dfe				endm 
# End of macro NEXTW
2dfe			 
2dfe			.DEC2: 
2dfe				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dfe 6f				db WORD_SYS_CORE+91             
2dff aa 2e			dw .GET2            
2e01 04				db 3 + 1 
2e02 .. 00			db "-2!",0              
2e06				endm 
# End of macro CWHEAD
2e06			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e06			 
2e06			 
2e06					if DEBUG_FORTH_WORDS_KEY 
2e06						DMARK "-2s" 
2e06 f5				push af  
2e07 3a 1b 2e			ld a, (.dmark)  
2e0a 32 bd fb			ld (debug_mark),a  
2e0d 3a 1c 2e			ld a, (.dmark+1)  
2e10 32 be fb			ld (debug_mark+1),a  
2e13 3a 1d 2e			ld a, (.dmark+2)  
2e16 32 bf fb			ld (debug_mark+2),a  
2e19 18 03			jr .pastdmark  
2e1b ..			.dmark: db "-2s"  
2e1e f1			.pastdmark: pop af  
2e1f			endm  
# End of macro DMARK
2e1f						CALLMONITOR 
2e1f cd 47 17			call break_point_state  
2e22				endm  
# End of macro CALLMONITOR
2e22					endif 
2e22			 
2e22					; Address 
2e22			 
2e22					FORTH_DSP_VALUEHL 
2e22 cd ce 1e			call macro_dsp_valuehl 
2e25				endm 
# End of macro FORTH_DSP_VALUEHL
2e25			 
2e25 e5					push hl    ; save address 
2e26			 
2e26					; load content into de 
2e26			 
2e26 5e					ld e,(hl) 
2e27 23					inc hl 
2e28 56					ld d, (hl) 
2e29			 
2e29					if DEBUG_FORTH_WORDS 
2e29						DMARK "-2a" 
2e29 f5				push af  
2e2a 3a 3e 2e			ld a, (.dmark)  
2e2d 32 bd fb			ld (debug_mark),a  
2e30 3a 3f 2e			ld a, (.dmark+1)  
2e33 32 be fb			ld (debug_mark+1),a  
2e36 3a 40 2e			ld a, (.dmark+2)  
2e39 32 bf fb			ld (debug_mark+2),a  
2e3c 18 03			jr .pastdmark  
2e3e ..			.dmark: db "-2a"  
2e41 f1			.pastdmark: pop af  
2e42			endm  
# End of macro DMARK
2e42						CALLMONITOR 
2e42 cd 47 17			call break_point_state  
2e45				endm  
# End of macro CALLMONITOR
2e45					endif 
2e45			 
2e45					FORTH_DSP_POP 
2e45 cd 86 1f			call macro_forth_dsp_pop 
2e48				endm 
# End of macro FORTH_DSP_POP
2e48			 
2e48					; Get value to remove 
2e48			 
2e48					FORTH_DSP_VALUE 
2e48 cd b7 1e			call macro_forth_dsp_value 
2e4b				endm 
# End of macro FORTH_DSP_VALUE
2e4b			 
2e4b					if DEBUG_FORTH_WORDS 
2e4b						DMARK "-2v" 
2e4b f5				push af  
2e4c 3a 60 2e			ld a, (.dmark)  
2e4f 32 bd fb			ld (debug_mark),a  
2e52 3a 61 2e			ld a, (.dmark+1)  
2e55 32 be fb			ld (debug_mark+1),a  
2e58 3a 62 2e			ld a, (.dmark+2)  
2e5b 32 bf fb			ld (debug_mark+2),a  
2e5e 18 03			jr .pastdmark  
2e60 ..			.dmark: db "-2v"  
2e63 f1			.pastdmark: pop af  
2e64			endm  
# End of macro DMARK
2e64						CALLMONITOR 
2e64 cd 47 17			call break_point_state  
2e67				endm  
# End of macro CALLMONITOR
2e67					endif 
2e67			 
2e67 eb					ex de, hl 
2e68 ed 52				sbc hl, de 
2e6a			 
2e6a					if DEBUG_FORTH_WORDS 
2e6a						DMARK "-2d" 
2e6a f5				push af  
2e6b 3a 7f 2e			ld a, (.dmark)  
2e6e 32 bd fb			ld (debug_mark),a  
2e71 3a 80 2e			ld a, (.dmark+1)  
2e74 32 be fb			ld (debug_mark+1),a  
2e77 3a 81 2e			ld a, (.dmark+2)  
2e7a 32 bf fb			ld (debug_mark+2),a  
2e7d 18 03			jr .pastdmark  
2e7f ..			.dmark: db "-2d"  
2e82 f1			.pastdmark: pop af  
2e83			endm  
# End of macro DMARK
2e83						CALLMONITOR 
2e83 cd 47 17			call break_point_state  
2e86				endm  
# End of macro CALLMONITOR
2e86					endif 
2e86			 
2e86					; move result to de 
2e86			 
2e86 eb					ex de, hl 
2e87			 
2e87					; Address 
2e87			 
2e87 e1					pop hl 
2e88			 
2e88					; save it back 
2e88			 
2e88 73					ld (hl), e 
2e89 23					inc hl 
2e8a 72					ld (hl), d 
2e8b			 
2e8b					if DEBUG_FORTH_WORDS 
2e8b						DMARK "-2e" 
2e8b f5				push af  
2e8c 3a a0 2e			ld a, (.dmark)  
2e8f 32 bd fb			ld (debug_mark),a  
2e92 3a a1 2e			ld a, (.dmark+1)  
2e95 32 be fb			ld (debug_mark+1),a  
2e98 3a a2 2e			ld a, (.dmark+2)  
2e9b 32 bf fb			ld (debug_mark+2),a  
2e9e 18 03			jr .pastdmark  
2ea0 ..			.dmark: db "-2e"  
2ea3 f1			.pastdmark: pop af  
2ea4			endm  
# End of macro DMARK
2ea4						CALLMONITOR 
2ea4 cd 47 17			call break_point_state  
2ea7				endm  
# End of macro CALLMONITOR
2ea7					endif 
2ea7			 
2ea7			 
2ea7			 
2ea7			 
2ea7			 
2ea7				       NEXTW 
2ea7 c3 40 20			jp macro_next 
2eaa				endm 
# End of macro NEXTW
2eaa			.GET2: 
2eaa				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2eaa 6f				db WORD_SYS_CORE+91             
2eab da 2e			dw .BANG2            
2ead 03				db 2 + 1 
2eae .. 00			db "2@",0              
2eb1				endm 
# End of macro CWHEAD
2eb1			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2eb1					if DEBUG_FORTH_WORDS_KEY 
2eb1						DMARK "2A_" 
2eb1 f5				push af  
2eb2 3a c6 2e			ld a, (.dmark)  
2eb5 32 bd fb			ld (debug_mark),a  
2eb8 3a c7 2e			ld a, (.dmark+1)  
2ebb 32 be fb			ld (debug_mark+1),a  
2ebe 3a c8 2e			ld a, (.dmark+2)  
2ec1 32 bf fb			ld (debug_mark+2),a  
2ec4 18 03			jr .pastdmark  
2ec6 ..			.dmark: db "2A_"  
2ec9 f1			.pastdmark: pop af  
2eca			endm  
# End of macro DMARK
2eca						CALLMONITOR 
2eca cd 47 17			call break_point_state  
2ecd				endm  
# End of macro CALLMONITOR
2ecd					endif 
2ecd			 
2ecd					FORTH_DSP_VALUEHL 
2ecd cd ce 1e			call macro_dsp_valuehl 
2ed0				endm 
# End of macro FORTH_DSP_VALUEHL
2ed0			 
2ed0 5e					ld e, (hl) 
2ed1 23					inc hl 
2ed2 56					ld d, (hl) 
2ed3			 
2ed3 eb					ex de, hl 
2ed4			 
2ed4 cd d7 1c				call forth_push_numhl 
2ed7			 
2ed7				       NEXTW 
2ed7 c3 40 20			jp macro_next 
2eda				endm 
# End of macro NEXTW
2eda			.BANG2: 
2eda				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2eda 6f				db WORD_SYS_CORE+91             
2edb 12 2f			dw .CONFIG            
2edd 03				db 2 + 1 
2ede .. 00			db "2!",0              
2ee1				endm 
# End of macro CWHEAD
2ee1			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ee1					if DEBUG_FORTH_WORDS_KEY 
2ee1						DMARK "2S_" 
2ee1 f5				push af  
2ee2 3a f6 2e			ld a, (.dmark)  
2ee5 32 bd fb			ld (debug_mark),a  
2ee8 3a f7 2e			ld a, (.dmark+1)  
2eeb 32 be fb			ld (debug_mark+1),a  
2eee 3a f8 2e			ld a, (.dmark+2)  
2ef1 32 bf fb			ld (debug_mark+2),a  
2ef4 18 03			jr .pastdmark  
2ef6 ..			.dmark: db "2S_"  
2ef9 f1			.pastdmark: pop af  
2efa			endm  
# End of macro DMARK
2efa						CALLMONITOR 
2efa cd 47 17			call break_point_state  
2efd				endm  
# End of macro CALLMONITOR
2efd					endif 
2efd			 
2efd					FORTH_DSP_VALUEHL 
2efd cd ce 1e			call macro_dsp_valuehl 
2f00				endm 
# End of macro FORTH_DSP_VALUEHL
2f00			 
2f00 e5					push hl   ; save address 
2f01			 
2f01			 
2f01					FORTH_DSP_POP 
2f01 cd 86 1f			call macro_forth_dsp_pop 
2f04				endm 
# End of macro FORTH_DSP_POP
2f04			 
2f04					 
2f04					FORTH_DSP_VALUEHL 
2f04 cd ce 1e			call macro_dsp_valuehl 
2f07				endm 
# End of macro FORTH_DSP_VALUEHL
2f07			 
2f07					FORTH_DSP_POP 
2f07 cd 86 1f			call macro_forth_dsp_pop 
2f0a				endm 
# End of macro FORTH_DSP_POP
2f0a			 
2f0a eb					ex de, hl    ; value now in de 
2f0b			 
2f0b e1					pop hl 
2f0c			 
2f0c 73					ld (hl), e 
2f0d			 
2f0d 23					inc hl 
2f0e			 
2f0e 72					ld (hl), d 
2f0f			 
2f0f			 
2f0f				       NEXTW 
2f0f c3 40 20			jp macro_next 
2f12				endm 
# End of macro NEXTW
2f12			.CONFIG: 
2f12				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f12 6f				db WORD_SYS_CORE+91             
2f13 23 2f			dw .ENDCORE            
2f15 07				db 6 + 1 
2f16 .. 00			db "CONFIG",0              
2f1d				endm 
# End of macro CWHEAD
2f1d			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2f1d			 
2f1d cd 7d 13				call config 
2f20					NEXTW 
2f20 c3 40 20			jp macro_next 
2f23				endm 
# End of macro NEXTW
2f23			.ENDCORE: 
2f23			 
2f23			; eof 
2f23			 
2f23			 
# End of file forth_words_core.asm
2f23			include "forth_words_flow.asm" 
2f23			 
2f23			; | ## Program Flow Words 
2f23			 
2f23			.IF: 
2f23				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f23 1e				db WORD_SYS_CORE+10             
2f24 18 30			dw .THEN            
2f26 03				db 2 + 1 
2f27 .. 00			db "IF",0              
2f2a				endm 
# End of macro CWHEAD
2f2a			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f2a			; 
2f2a					if DEBUG_FORTH_WORDS_KEY 
2f2a						DMARK "IF." 
2f2a f5				push af  
2f2b 3a 3f 2f			ld a, (.dmark)  
2f2e 32 bd fb			ld (debug_mark),a  
2f31 3a 40 2f			ld a, (.dmark+1)  
2f34 32 be fb			ld (debug_mark+1),a  
2f37 3a 41 2f			ld a, (.dmark+2)  
2f3a 32 bf fb			ld (debug_mark+2),a  
2f3d 18 03			jr .pastdmark  
2f3f ..			.dmark: db "IF."  
2f42 f1			.pastdmark: pop af  
2f43			endm  
# End of macro DMARK
2f43						CALLMONITOR 
2f43 cd 47 17			call break_point_state  
2f46				endm  
# End of macro CALLMONITOR
2f46					endif 
2f46			; eval TOS 
2f46			 
2f46				FORTH_DSP_VALUEHL 
2f46 cd ce 1e			call macro_dsp_valuehl 
2f49				endm 
# End of macro FORTH_DSP_VALUEHL
2f49			 
2f49			;	push hl 
2f49				FORTH_DSP_POP 
2f49 cd 86 1f			call macro_forth_dsp_pop 
2f4c				endm 
# End of macro FORTH_DSP_POP
2f4c			;	pop hl 
2f4c			 
2f4c					if DEBUG_FORTH_WORDS 
2f4c						DMARK "IF1" 
2f4c f5				push af  
2f4d 3a 61 2f			ld a, (.dmark)  
2f50 32 bd fb			ld (debug_mark),a  
2f53 3a 62 2f			ld a, (.dmark+1)  
2f56 32 be fb			ld (debug_mark+1),a  
2f59 3a 63 2f			ld a, (.dmark+2)  
2f5c 32 bf fb			ld (debug_mark+2),a  
2f5f 18 03			jr .pastdmark  
2f61 ..			.dmark: db "IF1"  
2f64 f1			.pastdmark: pop af  
2f65			endm  
# End of macro DMARK
2f65						CALLMONITOR 
2f65 cd 47 17			call break_point_state  
2f68				endm  
# End of macro CALLMONITOR
2f68					endif 
2f68 b7				or a        ; clear carry flag 
2f69 11 00 00			ld de, 0 
2f6c eb				ex de,hl 
2f6d ed 52			sbc hl, de 
2f6f c2 f9 2f			jp nz, .iftrue 
2f72			 
2f72					if DEBUG_FORTH_WORDS 
2f72						DMARK "IF2" 
2f72 f5				push af  
2f73 3a 87 2f			ld a, (.dmark)  
2f76 32 bd fb			ld (debug_mark),a  
2f79 3a 88 2f			ld a, (.dmark+1)  
2f7c 32 be fb			ld (debug_mark+1),a  
2f7f 3a 89 2f			ld a, (.dmark+2)  
2f82 32 bf fb			ld (debug_mark+2),a  
2f85 18 03			jr .pastdmark  
2f87 ..			.dmark: db "IF2"  
2f8a f1			.pastdmark: pop af  
2f8b			endm  
# End of macro DMARK
2f8b						CALLMONITOR 
2f8b cd 47 17			call break_point_state  
2f8e				endm  
# End of macro CALLMONITOR
2f8e					endif 
2f8e			 
2f8e			; if not true then skip to THEN 
2f8e			 
2f8e				; TODO get tok_ptr 
2f8e				; TODO consume toks until we get to THEN 
2f8e			 
2f8e 2a a4 f2			ld hl, (os_tok_ptr) 
2f91					if DEBUG_FORTH_WORDS 
2f91						DMARK "IF3" 
2f91 f5				push af  
2f92 3a a6 2f			ld a, (.dmark)  
2f95 32 bd fb			ld (debug_mark),a  
2f98 3a a7 2f			ld a, (.dmark+1)  
2f9b 32 be fb			ld (debug_mark+1),a  
2f9e 3a a8 2f			ld a, (.dmark+2)  
2fa1 32 bf fb			ld (debug_mark+2),a  
2fa4 18 03			jr .pastdmark  
2fa6 ..			.dmark: db "IF3"  
2fa9 f1			.pastdmark: pop af  
2faa			endm  
# End of macro DMARK
2faa						CALLMONITOR 
2faa cd 47 17			call break_point_state  
2fad				endm  
# End of macro CALLMONITOR
2fad						 
2fad					endif 
2fad 11 f4 2f			ld de, .ifthen 
2fb0					if DEBUG_FORTH_WORDS 
2fb0						DMARK "IF4" 
2fb0 f5				push af  
2fb1 3a c5 2f			ld a, (.dmark)  
2fb4 32 bd fb			ld (debug_mark),a  
2fb7 3a c6 2f			ld a, (.dmark+1)  
2fba 32 be fb			ld (debug_mark+1),a  
2fbd 3a c7 2f			ld a, (.dmark+2)  
2fc0 32 bf fb			ld (debug_mark+2),a  
2fc3 18 03			jr .pastdmark  
2fc5 ..			.dmark: db "IF4"  
2fc8 f1			.pastdmark: pop af  
2fc9			endm  
# End of macro DMARK
2fc9						CALLMONITOR 
2fc9 cd 47 17			call break_point_state  
2fcc				endm  
# End of macro CALLMONITOR
2fcc					endif 
2fcc cd 5b 21			call findnexttok  
2fcf			 
2fcf					if DEBUG_FORTH_WORDS 
2fcf						DMARK "IF5" 
2fcf f5				push af  
2fd0 3a e4 2f			ld a, (.dmark)  
2fd3 32 bd fb			ld (debug_mark),a  
2fd6 3a e5 2f			ld a, (.dmark+1)  
2fd9 32 be fb			ld (debug_mark+1),a  
2fdc 3a e6 2f			ld a, (.dmark+2)  
2fdf 32 bf fb			ld (debug_mark+2),a  
2fe2 18 03			jr .pastdmark  
2fe4 ..			.dmark: db "IF5"  
2fe7 f1			.pastdmark: pop af  
2fe8			endm  
# End of macro DMARK
2fe8						CALLMONITOR 
2fe8 cd 47 17			call break_point_state  
2feb				endm  
# End of macro CALLMONITOR
2feb					endif 
2feb				; TODO replace below with ; exec using tok_ptr 
2feb 22 a4 f2			ld (os_tok_ptr), hl 
2fee c3 d1 20			jp exec1 
2ff1				NEXTW 
2ff1 c3 40 20			jp macro_next 
2ff4				endm 
# End of macro NEXTW
2ff4			 
2ff4 .. 00		.ifthen:  db "THEN",0 
2ff9			 
2ff9			.iftrue:		 
2ff9				; Exec next words normally 
2ff9			 
2ff9				; if true then exec following IF as normal 
2ff9					if DEBUG_FORTH_WORDS 
2ff9						DMARK "IFT" 
2ff9 f5				push af  
2ffa 3a 0e 30			ld a, (.dmark)  
2ffd 32 bd fb			ld (debug_mark),a  
3000 3a 0f 30			ld a, (.dmark+1)  
3003 32 be fb			ld (debug_mark+1),a  
3006 3a 10 30			ld a, (.dmark+2)  
3009 32 bf fb			ld (debug_mark+2),a  
300c 18 03			jr .pastdmark  
300e ..			.dmark: db "IFT"  
3011 f1			.pastdmark: pop af  
3012			endm  
# End of macro DMARK
3012						CALLMONITOR 
3012 cd 47 17			call break_point_state  
3015				endm  
# End of macro CALLMONITOR
3015					endif 
3015			 
3015					NEXTW 
3015 c3 40 20			jp macro_next 
3018				endm 
# End of macro NEXTW
3018			.THEN: 
3018				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3018 1f				db WORD_SYS_CORE+11             
3019 40 30			dw .ELSE            
301b 05				db 4 + 1 
301c .. 00			db "THEN",0              
3021				endm 
# End of macro CWHEAD
3021			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3021					if DEBUG_FORTH_WORDS_KEY 
3021						DMARK "THN" 
3021 f5				push af  
3022 3a 36 30			ld a, (.dmark)  
3025 32 bd fb			ld (debug_mark),a  
3028 3a 37 30			ld a, (.dmark+1)  
302b 32 be fb			ld (debug_mark+1),a  
302e 3a 38 30			ld a, (.dmark+2)  
3031 32 bf fb			ld (debug_mark+2),a  
3034 18 03			jr .pastdmark  
3036 ..			.dmark: db "THN"  
3039 f1			.pastdmark: pop af  
303a			endm  
# End of macro DMARK
303a						CALLMONITOR 
303a cd 47 17			call break_point_state  
303d				endm  
# End of macro CALLMONITOR
303d					endif 
303d					NEXTW 
303d c3 40 20			jp macro_next 
3040				endm 
# End of macro NEXTW
3040			.ELSE: 
3040				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3040 20				db WORD_SYS_CORE+12             
3041 68 30			dw .DO            
3043 03				db 2 + 1 
3044 .. 00			db "ELSE",0              
3049				endm 
# End of macro CWHEAD
3049			; | ELSE ( -- ) Not supported - does nothing | TODO 
3049			 
3049					if DEBUG_FORTH_WORDS_KEY 
3049						DMARK "ELS" 
3049 f5				push af  
304a 3a 5e 30			ld a, (.dmark)  
304d 32 bd fb			ld (debug_mark),a  
3050 3a 5f 30			ld a, (.dmark+1)  
3053 32 be fb			ld (debug_mark+1),a  
3056 3a 60 30			ld a, (.dmark+2)  
3059 32 bf fb			ld (debug_mark+2),a  
305c 18 03			jr .pastdmark  
305e ..			.dmark: db "ELS"  
3061 f1			.pastdmark: pop af  
3062			endm  
# End of macro DMARK
3062						CALLMONITOR 
3062 cd 47 17			call break_point_state  
3065				endm  
# End of macro CALLMONITOR
3065					endif 
3065			 
3065			 
3065					NEXTW 
3065 c3 40 20			jp macro_next 
3068				endm 
# End of macro NEXTW
3068			.DO: 
3068				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3068 21				db WORD_SYS_CORE+13             
3069 8f 31			dw .LOOP            
306b 03				db 2 + 1 
306c .. 00			db "DO",0              
306f				endm 
# End of macro CWHEAD
306f			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
306f			 
306f					if DEBUG_FORTH_WORDS_KEY 
306f						DMARK "DO." 
306f f5				push af  
3070 3a 84 30			ld a, (.dmark)  
3073 32 bd fb			ld (debug_mark),a  
3076 3a 85 30			ld a, (.dmark+1)  
3079 32 be fb			ld (debug_mark+1),a  
307c 3a 86 30			ld a, (.dmark+2)  
307f 32 bf fb			ld (debug_mark+2),a  
3082 18 03			jr .pastdmark  
3084 ..			.dmark: db "DO."  
3087 f1			.pastdmark: pop af  
3088			endm  
# End of macro DMARK
3088						CALLMONITOR 
3088 cd 47 17			call break_point_state  
308b				endm  
# End of macro CALLMONITOR
308b					endif 
308b			;  push pc to rsp stack past the DO 
308b			 
308b 2a a4 f2				ld hl, (os_tok_ptr) 
308e 23					inc hl   ; D 
308f 23					inc hl  ; O 
3090 23					inc hl   ; null 
3091					if DEBUG_FORTH_WORDS 
3091						DMARK "DO2" 
3091 f5				push af  
3092 3a a6 30			ld a, (.dmark)  
3095 32 bd fb			ld (debug_mark),a  
3098 3a a7 30			ld a, (.dmark+1)  
309b 32 be fb			ld (debug_mark+1),a  
309e 3a a8 30			ld a, (.dmark+2)  
30a1 32 bf fb			ld (debug_mark+2),a  
30a4 18 03			jr .pastdmark  
30a6 ..			.dmark: db "DO2"  
30a9 f1			.pastdmark: pop af  
30aa			endm  
# End of macro DMARK
30aa						CALLMONITOR 
30aa cd 47 17			call break_point_state  
30ad				endm  
# End of macro CALLMONITOR
30ad					endif 
30ad					FORTH_RSP_NEXT 
30ad cd 7e 1c			call macro_forth_rsp_next 
30b0				endm 
# End of macro FORTH_RSP_NEXT
30b0					if DEBUG_FORTH_WORDS 
30b0						DMARK "DO3" 
30b0 f5				push af  
30b1 3a c5 30			ld a, (.dmark)  
30b4 32 bd fb			ld (debug_mark),a  
30b7 3a c6 30			ld a, (.dmark+1)  
30ba 32 be fb			ld (debug_mark+1),a  
30bd 3a c7 30			ld a, (.dmark+2)  
30c0 32 bf fb			ld (debug_mark+2),a  
30c3 18 03			jr .pastdmark  
30c5 ..			.dmark: db "DO3"  
30c8 f1			.pastdmark: pop af  
30c9			endm  
# End of macro DMARK
30c9						CALLMONITOR 
30c9 cd 47 17			call break_point_state  
30cc				endm  
# End of macro CALLMONITOR
30cc					endif 
30cc			 
30cc					;if DEBUG_FORTH_WORDS 
30cc				;		push hl 
30cc			;		endif  
30cc			 
30cc			; get counters from data stack 
30cc			 
30cc			 
30cc					FORTH_DSP_VALUEHL 
30cc cd ce 1e			call macro_dsp_valuehl 
30cf				endm 
# End of macro FORTH_DSP_VALUEHL
30cf e5					push hl		 ; hl now has starting counter which needs to be tos 
30d0			 
30d0					if DEBUG_FORTH_WORDS 
30d0						DMARK "DO4" 
30d0 f5				push af  
30d1 3a e5 30			ld a, (.dmark)  
30d4 32 bd fb			ld (debug_mark),a  
30d7 3a e6 30			ld a, (.dmark+1)  
30da 32 be fb			ld (debug_mark+1),a  
30dd 3a e7 30			ld a, (.dmark+2)  
30e0 32 bf fb			ld (debug_mark+2),a  
30e3 18 03			jr .pastdmark  
30e5 ..			.dmark: db "DO4"  
30e8 f1			.pastdmark: pop af  
30e9			endm  
# End of macro DMARK
30e9						CALLMONITOR 
30e9 cd 47 17			call break_point_state  
30ec				endm  
# End of macro CALLMONITOR
30ec					endif 
30ec					FORTH_DSP_POP 
30ec cd 86 1f			call macro_forth_dsp_pop 
30ef				endm 
# End of macro FORTH_DSP_POP
30ef			 
30ef					if DEBUG_FORTH_WORDS 
30ef						DMARK "DO5" 
30ef f5				push af  
30f0 3a 04 31			ld a, (.dmark)  
30f3 32 bd fb			ld (debug_mark),a  
30f6 3a 05 31			ld a, (.dmark+1)  
30f9 32 be fb			ld (debug_mark+1),a  
30fc 3a 06 31			ld a, (.dmark+2)  
30ff 32 bf fb			ld (debug_mark+2),a  
3102 18 03			jr .pastdmark  
3104 ..			.dmark: db "DO5"  
3107 f1			.pastdmark: pop af  
3108			endm  
# End of macro DMARK
3108						CALLMONITOR 
3108 cd 47 17			call break_point_state  
310b				endm  
# End of macro CALLMONITOR
310b					endif 
310b			 
310b					FORTH_DSP_VALUEHL 
310b cd ce 1e			call macro_dsp_valuehl 
310e				endm 
# End of macro FORTH_DSP_VALUEHL
310e			;		push hl		 ; hl now has starting limit counter 
310e			 
310e					if DEBUG_FORTH_WORDS 
310e						DMARK "DO6" 
310e f5				push af  
310f 3a 23 31			ld a, (.dmark)  
3112 32 bd fb			ld (debug_mark),a  
3115 3a 24 31			ld a, (.dmark+1)  
3118 32 be fb			ld (debug_mark+1),a  
311b 3a 25 31			ld a, (.dmark+2)  
311e 32 bf fb			ld (debug_mark+2),a  
3121 18 03			jr .pastdmark  
3123 ..			.dmark: db "DO6"  
3126 f1			.pastdmark: pop af  
3127			endm  
# End of macro DMARK
3127						CALLMONITOR 
3127 cd 47 17			call break_point_state  
312a				endm  
# End of macro CALLMONITOR
312a					endif 
312a					FORTH_DSP_POP 
312a cd 86 1f			call macro_forth_dsp_pop 
312d				endm 
# End of macro FORTH_DSP_POP
312d			 
312d			; put counters on the loop stack 
312d			 
312d			;		pop hl			 ; limit counter 
312d d1					pop de			; start counter 
312e			 
312e					; push limit counter 
312e			 
312e					if DEBUG_FORTH_WORDS 
312e						DMARK "DO7" 
312e f5				push af  
312f 3a 43 31			ld a, (.dmark)  
3132 32 bd fb			ld (debug_mark),a  
3135 3a 44 31			ld a, (.dmark+1)  
3138 32 be fb			ld (debug_mark+1),a  
313b 3a 45 31			ld a, (.dmark+2)  
313e 32 bf fb			ld (debug_mark+2),a  
3141 18 03			jr .pastdmark  
3143 ..			.dmark: db "DO7"  
3146 f1			.pastdmark: pop af  
3147			endm  
# End of macro DMARK
3147						CALLMONITOR 
3147 cd 47 17			call break_point_state  
314a				endm  
# End of macro CALLMONITOR
314a					endif 
314a					FORTH_LOOP_NEXT 
314a cd ff 1e			call macro_forth_loop_next 
314d				endm 
# End of macro FORTH_LOOP_NEXT
314d			 
314d					; push start counter 
314d			 
314d eb					ex de, hl 
314e					if DEBUG_FORTH_WORDS 
314e						DMARK "DO7" 
314e f5				push af  
314f 3a 63 31			ld a, (.dmark)  
3152 32 bd fb			ld (debug_mark),a  
3155 3a 64 31			ld a, (.dmark+1)  
3158 32 be fb			ld (debug_mark+1),a  
315b 3a 65 31			ld a, (.dmark+2)  
315e 32 bf fb			ld (debug_mark+2),a  
3161 18 03			jr .pastdmark  
3163 ..			.dmark: db "DO7"  
3166 f1			.pastdmark: pop af  
3167			endm  
# End of macro DMARK
3167						CALLMONITOR 
3167 cd 47 17			call break_point_state  
316a				endm  
# End of macro CALLMONITOR
316a					endif 
316a					FORTH_LOOP_NEXT 
316a cd ff 1e			call macro_forth_loop_next 
316d				endm 
# End of macro FORTH_LOOP_NEXT
316d			 
316d			 
316d					; init first round of I counter 
316d			 
316d 22 c8 f2				ld (os_current_i), hl 
3170			 
3170					if DEBUG_FORTH_WORDS 
3170						DMARK "DO8" 
3170 f5				push af  
3171 3a 85 31			ld a, (.dmark)  
3174 32 bd fb			ld (debug_mark),a  
3177 3a 86 31			ld a, (.dmark+1)  
317a 32 be fb			ld (debug_mark+1),a  
317d 3a 87 31			ld a, (.dmark+2)  
3180 32 bf fb			ld (debug_mark+2),a  
3183 18 03			jr .pastdmark  
3185 ..			.dmark: db "DO8"  
3188 f1			.pastdmark: pop af  
3189			endm  
# End of macro DMARK
3189						CALLMONITOR 
3189 cd 47 17			call break_point_state  
318c				endm  
# End of macro CALLMONITOR
318c					endif 
318c			 
318c					NEXTW 
318c c3 40 20			jp macro_next 
318f				endm 
# End of macro NEXTW
318f			.LOOP: 
318f				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
318f 22				db WORD_SYS_CORE+14             
3190 a7 32			dw .I            
3192 05				db 4 + 1 
3193 .. 00			db "LOOP",0              
3198				endm 
# End of macro CWHEAD
3198			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3198			 
3198				; pop tos as current loop count to hl 
3198			 
3198				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3198			 
3198				FORTH_LOOP_TOS 
3198 cd 32 1f			call macro_forth_loop_tos 
319b				endm 
# End of macro FORTH_LOOP_TOS
319b e5				push hl 
319c			 
319c					if DEBUG_FORTH_WORDS_KEY 
319c						DMARK "LOP" 
319c f5				push af  
319d 3a b1 31			ld a, (.dmark)  
31a0 32 bd fb			ld (debug_mark),a  
31a3 3a b2 31			ld a, (.dmark+1)  
31a6 32 be fb			ld (debug_mark+1),a  
31a9 3a b3 31			ld a, (.dmark+2)  
31ac 32 bf fb			ld (debug_mark+2),a  
31af 18 03			jr .pastdmark  
31b1 ..			.dmark: db "LOP"  
31b4 f1			.pastdmark: pop af  
31b5			endm  
# End of macro DMARK
31b5						CALLMONITOR 
31b5 cd 47 17			call break_point_state  
31b8				endm  
# End of macro CALLMONITOR
31b8					endif 
31b8				; next item on the stack is the limit. get it 
31b8			 
31b8			 
31b8				FORTH_LOOP_POP 
31b8 cd 3c 1f			call macro_forth_loop_pop 
31bb				endm 
# End of macro FORTH_LOOP_POP
31bb			 
31bb				FORTH_LOOP_TOS 
31bb cd 32 1f			call macro_forth_loop_tos 
31be				endm 
# End of macro FORTH_LOOP_TOS
31be			 
31be d1				pop de		 ; de = i, hl = limit 
31bf			 
31bf					if DEBUG_FORTH_WORDS 
31bf						DMARK "LP1" 
31bf f5				push af  
31c0 3a d4 31			ld a, (.dmark)  
31c3 32 bd fb			ld (debug_mark),a  
31c6 3a d5 31			ld a, (.dmark+1)  
31c9 32 be fb			ld (debug_mark+1),a  
31cc 3a d6 31			ld a, (.dmark+2)  
31cf 32 bf fb			ld (debug_mark+2),a  
31d2 18 03			jr .pastdmark  
31d4 ..			.dmark: db "LP1"  
31d7 f1			.pastdmark: pop af  
31d8			endm  
# End of macro DMARK
31d8						CALLMONITOR 
31d8 cd 47 17			call break_point_state  
31db				endm  
# End of macro CALLMONITOR
31db					endif 
31db			 
31db				; go back to previous word 
31db			 
31db d5				push de    ; save I for inc later 
31dc			 
31dc			 
31dc				; get limit 
31dc				;  is I at limit? 
31dc			 
31dc			 
31dc					if DEBUG_FORTH_WORDS 
31dc						DMARK "LP1" 
31dc f5				push af  
31dd 3a f1 31			ld a, (.dmark)  
31e0 32 bd fb			ld (debug_mark),a  
31e3 3a f2 31			ld a, (.dmark+1)  
31e6 32 be fb			ld (debug_mark+1),a  
31e9 3a f3 31			ld a, (.dmark+2)  
31ec 32 bf fb			ld (debug_mark+2),a  
31ef 18 03			jr .pastdmark  
31f1 ..			.dmark: db "LP1"  
31f4 f1			.pastdmark: pop af  
31f5			endm  
# End of macro DMARK
31f5						CALLMONITOR 
31f5 cd 47 17			call break_point_state  
31f8				endm  
# End of macro CALLMONITOR
31f8					endif 
31f8			 
31f8 ed 52			sbc hl, de 
31fa			 
31fa			 
31fa				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31fa			 
31fa 20 26				jr nz, .loopnotdone 
31fc			 
31fc e1				pop hl   ; get rid of saved I 
31fd				FORTH_LOOP_POP     ; get rid of limit 
31fd cd 3c 1f			call macro_forth_loop_pop 
3200				endm 
# End of macro FORTH_LOOP_POP
3200			 
3200				FORTH_RSP_POP     ; get rid of DO ptr 
3200 cd 9f 1c			call macro_forth_rsp_pop 
3203				endm 
# End of macro FORTH_RSP_POP
3203			 
3203			if DEBUG_FORTH_WORDS 
3203						DMARK "LP>" 
3203 f5				push af  
3204 3a 18 32			ld a, (.dmark)  
3207 32 bd fb			ld (debug_mark),a  
320a 3a 19 32			ld a, (.dmark+1)  
320d 32 be fb			ld (debug_mark+1),a  
3210 3a 1a 32			ld a, (.dmark+2)  
3213 32 bf fb			ld (debug_mark+2),a  
3216 18 03			jr .pastdmark  
3218 ..			.dmark: db "LP>"  
321b f1			.pastdmark: pop af  
321c			endm  
# End of macro DMARK
321c				CALLMONITOR 
321c cd 47 17			call break_point_state  
321f				endm  
# End of macro CALLMONITOR
321f			endif 
321f			 
321f					NEXTW 
321f c3 40 20			jp macro_next 
3222				endm 
# End of macro NEXTW
3222				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3222			 
3222			.loopnotdone: 
3222			 
3222 e1				pop hl    ; get I 
3223 23				inc hl 
3224			 
3224			   	; save new I 
3224			 
3224			 
3224					; set I counter 
3224			 
3224 22 c8 f2				ld (os_current_i), hl 
3227			 
3227					if DEBUG_FORTH_WORDS 
3227						DMARK "LPN" 
3227 f5				push af  
3228 3a 3c 32			ld a, (.dmark)  
322b 32 bd fb			ld (debug_mark),a  
322e 3a 3d 32			ld a, (.dmark+1)  
3231 32 be fb			ld (debug_mark+1),a  
3234 3a 3e 32			ld a, (.dmark+2)  
3237 32 bf fb			ld (debug_mark+2),a  
323a 18 03			jr .pastdmark  
323c ..			.dmark: db "LPN"  
323f f1			.pastdmark: pop af  
3240			endm  
# End of macro DMARK
3240					CALLMONITOR 
3240 cd 47 17			call break_point_state  
3243				endm  
# End of macro CALLMONITOR
3243					endif 
3243					 
3243				FORTH_LOOP_NEXT 
3243 cd ff 1e			call macro_forth_loop_next 
3246				endm 
# End of macro FORTH_LOOP_NEXT
3246			 
3246			 
3246					if DEBUG_FORTH_WORDS 
3246 eb						ex de,hl 
3247					endif 
3247			 
3247			;	; get DO ptr 
3247			; 
3247					if DEBUG_FORTH_WORDS 
3247						DMARK "LP7" 
3247 f5				push af  
3248 3a 5c 32			ld a, (.dmark)  
324b 32 bd fb			ld (debug_mark),a  
324e 3a 5d 32			ld a, (.dmark+1)  
3251 32 be fb			ld (debug_mark+1),a  
3254 3a 5e 32			ld a, (.dmark+2)  
3257 32 bf fb			ld (debug_mark+2),a  
325a 18 03			jr .pastdmark  
325c ..			.dmark: db "LP7"  
325f f1			.pastdmark: pop af  
3260			endm  
# End of macro DMARK
3260					CALLMONITOR 
3260 cd 47 17			call break_point_state  
3263				endm  
# End of macro CALLMONITOR
3263					endif 
3263				FORTH_RSP_TOS 
3263 cd 95 1c			call macro_forth_rsp_tos 
3266				endm 
# End of macro FORTH_RSP_TOS
3266			 
3266					if DEBUG_FORTH_WORDS 
3266						DMARK "LP8" 
3266 f5				push af  
3267 3a 7b 32			ld a, (.dmark)  
326a 32 bd fb			ld (debug_mark),a  
326d 3a 7c 32			ld a, (.dmark+1)  
3270 32 be fb			ld (debug_mark+1),a  
3273 3a 7d 32			ld a, (.dmark+2)  
3276 32 bf fb			ld (debug_mark+2),a  
3279 18 03			jr .pastdmark  
327b ..			.dmark: db "LP8"  
327e f1			.pastdmark: pop af  
327f			endm  
# End of macro DMARK
327f					CALLMONITOR 
327f cd 47 17			call break_point_state  
3282				endm  
# End of macro CALLMONITOR
3282					endif 
3282				;push hl 
3282			 
3282				; not going to DO any more 
3282				; get rid of the RSP pointer as DO will add it back in 
3282				;FORTH_RSP_POP 
3282				;pop hl 
3282			 
3282				;ld hl,(cli_ret_sp) 
3282				;ld e, (hl) 
3282				;inc hl 
3282				;ld d, (hl) 
3282				;ex de,hl 
3282 22 a4 f2			ld (os_tok_ptr), hl 
3285					if DEBUG_FORTH_WORDS 
3285						DMARK "LP<" 
3285 f5				push af  
3286 3a 9a 32			ld a, (.dmark)  
3289 32 bd fb			ld (debug_mark),a  
328c 3a 9b 32			ld a, (.dmark+1)  
328f 32 be fb			ld (debug_mark+1),a  
3292 3a 9c 32			ld a, (.dmark+2)  
3295 32 bf fb			ld (debug_mark+2),a  
3298 18 03			jr .pastdmark  
329a ..			.dmark: db "LP<"  
329d f1			.pastdmark: pop af  
329e			endm  
# End of macro DMARK
329e					CALLMONITOR 
329e cd 47 17			call break_point_state  
32a1				endm  
# End of macro CALLMONITOR
32a1				endif 
32a1 c3 d1 20			jp exec1 
32a4			 
32a4					 
32a4			 
32a4			 
32a4					NEXTW 
32a4 c3 40 20			jp macro_next 
32a7				endm 
# End of macro NEXTW
32a7			.I:  
32a7			 
32a7				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32a7 5e				db WORD_SYS_CORE+74             
32a8 d2 32			dw .DLOOP            
32aa 02				db 1 + 1 
32ab .. 00			db "I",0              
32ad				endm 
# End of macro CWHEAD
32ad			; | I ( -- ) Current loop counter | DONE 
32ad					if DEBUG_FORTH_WORDS_KEY 
32ad						DMARK "I.." 
32ad f5				push af  
32ae 3a c2 32			ld a, (.dmark)  
32b1 32 bd fb			ld (debug_mark),a  
32b4 3a c3 32			ld a, (.dmark+1)  
32b7 32 be fb			ld (debug_mark+1),a  
32ba 3a c4 32			ld a, (.dmark+2)  
32bd 32 bf fb			ld (debug_mark+2),a  
32c0 18 03			jr .pastdmark  
32c2 ..			.dmark: db "I.."  
32c5 f1			.pastdmark: pop af  
32c6			endm  
# End of macro DMARK
32c6						CALLMONITOR 
32c6 cd 47 17			call break_point_state  
32c9				endm  
# End of macro CALLMONITOR
32c9					endif 
32c9			 
32c9 2a c8 f2				ld hl,(os_current_i) 
32cc cd d7 1c				call forth_push_numhl 
32cf			 
32cf					NEXTW 
32cf c3 40 20			jp macro_next 
32d2				endm 
# End of macro NEXTW
32d2			.DLOOP: 
32d2				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32d2 5f				db WORD_SYS_CORE+75             
32d3 b3 33			dw .REPEAT            
32d5 06				db 5 + 1 
32d6 .. 00			db "-LOOP",0              
32dc				endm 
# End of macro CWHEAD
32dc			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32dc				; pop tos as current loop count to hl 
32dc					if DEBUG_FORTH_WORDS_KEY 
32dc						DMARK "-LP" 
32dc f5				push af  
32dd 3a f1 32			ld a, (.dmark)  
32e0 32 bd fb			ld (debug_mark),a  
32e3 3a f2 32			ld a, (.dmark+1)  
32e6 32 be fb			ld (debug_mark+1),a  
32e9 3a f3 32			ld a, (.dmark+2)  
32ec 32 bf fb			ld (debug_mark+2),a  
32ef 18 03			jr .pastdmark  
32f1 ..			.dmark: db "-LP"  
32f4 f1			.pastdmark: pop af  
32f5			endm  
# End of macro DMARK
32f5						CALLMONITOR 
32f5 cd 47 17			call break_point_state  
32f8				endm  
# End of macro CALLMONITOR
32f8					endif 
32f8			 
32f8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32f8			 
32f8				FORTH_LOOP_TOS 
32f8 cd 32 1f			call macro_forth_loop_tos 
32fb				endm 
# End of macro FORTH_LOOP_TOS
32fb e5				push hl 
32fc			 
32fc					if DEBUG_FORTH_WORDS 
32fc						DMARK "-LP" 
32fc f5				push af  
32fd 3a 11 33			ld a, (.dmark)  
3300 32 bd fb			ld (debug_mark),a  
3303 3a 12 33			ld a, (.dmark+1)  
3306 32 be fb			ld (debug_mark+1),a  
3309 3a 13 33			ld a, (.dmark+2)  
330c 32 bf fb			ld (debug_mark+2),a  
330f 18 03			jr .pastdmark  
3311 ..			.dmark: db "-LP"  
3314 f1			.pastdmark: pop af  
3315			endm  
# End of macro DMARK
3315						CALLMONITOR 
3315 cd 47 17			call break_point_state  
3318				endm  
# End of macro CALLMONITOR
3318					endif 
3318				; next item on the stack is the limit. get it 
3318			 
3318			 
3318				FORTH_LOOP_POP 
3318 cd 3c 1f			call macro_forth_loop_pop 
331b				endm 
# End of macro FORTH_LOOP_POP
331b			 
331b				FORTH_LOOP_TOS 
331b cd 32 1f			call macro_forth_loop_tos 
331e				endm 
# End of macro FORTH_LOOP_TOS
331e			 
331e d1				pop de		 ; de = i, hl = limit 
331f			 
331f					if DEBUG_FORTH_WORDS 
331f						DMARK "-L1" 
331f f5				push af  
3320 3a 34 33			ld a, (.dmark)  
3323 32 bd fb			ld (debug_mark),a  
3326 3a 35 33			ld a, (.dmark+1)  
3329 32 be fb			ld (debug_mark+1),a  
332c 3a 36 33			ld a, (.dmark+2)  
332f 32 bf fb			ld (debug_mark+2),a  
3332 18 03			jr .pastdmark  
3334 ..			.dmark: db "-L1"  
3337 f1			.pastdmark: pop af  
3338			endm  
# End of macro DMARK
3338						CALLMONITOR 
3338 cd 47 17			call break_point_state  
333b				endm  
# End of macro CALLMONITOR
333b					endif 
333b			 
333b				; go back to previous word 
333b			 
333b d5				push de    ; save I for inc later 
333c			 
333c			 
333c				; get limit 
333c				;  is I at limit? 
333c			 
333c			 
333c					if DEBUG_FORTH_WORDS 
333c						DMARK "-L1" 
333c f5				push af  
333d 3a 51 33			ld a, (.dmark)  
3340 32 bd fb			ld (debug_mark),a  
3343 3a 52 33			ld a, (.dmark+1)  
3346 32 be fb			ld (debug_mark+1),a  
3349 3a 53 33			ld a, (.dmark+2)  
334c 32 bf fb			ld (debug_mark+2),a  
334f 18 03			jr .pastdmark  
3351 ..			.dmark: db "-L1"  
3354 f1			.pastdmark: pop af  
3355			endm  
# End of macro DMARK
3355						CALLMONITOR 
3355 cd 47 17			call break_point_state  
3358				endm  
# End of macro CALLMONITOR
3358					endif 
3358			 
3358 ed 52			sbc hl, de 
335a			 
335a			 
335a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
335a			 
335a 20 26				jr nz, .mloopnotdone 
335c			 
335c e1				pop hl   ; get rid of saved I 
335d				FORTH_LOOP_POP     ; get rid of limit 
335d cd 3c 1f			call macro_forth_loop_pop 
3360				endm 
# End of macro FORTH_LOOP_POP
3360			 
3360				FORTH_RSP_POP     ; get rid of DO ptr 
3360 cd 9f 1c			call macro_forth_rsp_pop 
3363				endm 
# End of macro FORTH_RSP_POP
3363			 
3363			if DEBUG_FORTH_WORDS 
3363						DMARK "-L>" 
3363 f5				push af  
3364 3a 78 33			ld a, (.dmark)  
3367 32 bd fb			ld (debug_mark),a  
336a 3a 79 33			ld a, (.dmark+1)  
336d 32 be fb			ld (debug_mark+1),a  
3370 3a 7a 33			ld a, (.dmark+2)  
3373 32 bf fb			ld (debug_mark+2),a  
3376 18 03			jr .pastdmark  
3378 ..			.dmark: db "-L>"  
337b f1			.pastdmark: pop af  
337c			endm  
# End of macro DMARK
337c				CALLMONITOR 
337c cd 47 17			call break_point_state  
337f				endm  
# End of macro CALLMONITOR
337f			endif 
337f			 
337f					NEXTW 
337f c3 40 20			jp macro_next 
3382				endm 
# End of macro NEXTW
3382				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3382			 
3382			.mloopnotdone: 
3382			 
3382 e1				pop hl    ; get I 
3383 2b				dec hl 
3384			 
3384			   	; save new I 
3384			 
3384			 
3384					; set I counter 
3384			 
3384 22 c8 f2				ld (os_current_i), hl 
3387			 
3387					 
3387				FORTH_LOOP_NEXT 
3387 cd ff 1e			call macro_forth_loop_next 
338a				endm 
# End of macro FORTH_LOOP_NEXT
338a			 
338a			 
338a					if DEBUG_FORTH_WORDS 
338a eb						ex de,hl 
338b					endif 
338b			 
338b			;	; get DO ptr 
338b			; 
338b				FORTH_RSP_TOS 
338b cd 95 1c			call macro_forth_rsp_tos 
338e				endm 
# End of macro FORTH_RSP_TOS
338e			 
338e				;push hl 
338e			 
338e				; not going to DO any more 
338e				; get rid of the RSP pointer as DO will add it back in 
338e				;FORTH_RSP_POP 
338e				;pop hl 
338e			 
338e			 
338e 22 a4 f2			ld (os_tok_ptr), hl 
3391					if DEBUG_FORTH_WORDS 
3391						DMARK "-L<" 
3391 f5				push af  
3392 3a a6 33			ld a, (.dmark)  
3395 32 bd fb			ld (debug_mark),a  
3398 3a a7 33			ld a, (.dmark+1)  
339b 32 be fb			ld (debug_mark+1),a  
339e 3a a8 33			ld a, (.dmark+2)  
33a1 32 bf fb			ld (debug_mark+2),a  
33a4 18 03			jr .pastdmark  
33a6 ..			.dmark: db "-L<"  
33a9 f1			.pastdmark: pop af  
33aa			endm  
# End of macro DMARK
33aa					CALLMONITOR 
33aa cd 47 17			call break_point_state  
33ad				endm  
# End of macro CALLMONITOR
33ad				endif 
33ad c3 d1 20			jp exec1 
33b0			 
33b0					 
33b0			 
33b0			 
33b0			 
33b0				NEXTW 
33b0 c3 40 20			jp macro_next 
33b3				endm 
# End of macro NEXTW
33b3			 
33b3			 
33b3			 
33b3			 
33b3			.REPEAT: 
33b3				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33b3 71				db WORD_SYS_CORE+93             
33b4 06 34			dw .UNTIL            
33b6 06				db 5 + 1 
33b7 .. 00			db "REPEAT",0              
33be				endm 
# End of macro CWHEAD
33be			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33be			;  push pc to rsp stack past the REPEAT 
33be					if DEBUG_FORTH_WORDS_KEY 
33be						DMARK "REP" 
33be f5				push af  
33bf 3a d3 33			ld a, (.dmark)  
33c2 32 bd fb			ld (debug_mark),a  
33c5 3a d4 33			ld a, (.dmark+1)  
33c8 32 be fb			ld (debug_mark+1),a  
33cb 3a d5 33			ld a, (.dmark+2)  
33ce 32 bf fb			ld (debug_mark+2),a  
33d1 18 03			jr .pastdmark  
33d3 ..			.dmark: db "REP"  
33d6 f1			.pastdmark: pop af  
33d7			endm  
# End of macro DMARK
33d7						CALLMONITOR 
33d7 cd 47 17			call break_point_state  
33da				endm  
# End of macro CALLMONITOR
33da					endif 
33da			 
33da 2a a4 f2				ld hl, (os_tok_ptr) 
33dd 23					inc hl   ; R 
33de 23					inc hl  ; E 
33df 23					inc hl   ; P 
33e0 23					inc hl   ; E 
33e1 23					inc hl   ; A 
33e2 23					inc hl   ; T 
33e3 23					inc hl   ; zero 
33e4					FORTH_RSP_NEXT 
33e4 cd 7e 1c			call macro_forth_rsp_next 
33e7				endm 
# End of macro FORTH_RSP_NEXT
33e7			 
33e7			 
33e7					if DEBUG_FORTH_WORDS 
33e7						DMARK "REP" 
33e7 f5				push af  
33e8 3a fc 33			ld a, (.dmark)  
33eb 32 bd fb			ld (debug_mark),a  
33ee 3a fd 33			ld a, (.dmark+1)  
33f1 32 be fb			ld (debug_mark+1),a  
33f4 3a fe 33			ld a, (.dmark+2)  
33f7 32 bf fb			ld (debug_mark+2),a  
33fa 18 03			jr .pastdmark  
33fc ..			.dmark: db "REP"  
33ff f1			.pastdmark: pop af  
3400			endm  
# End of macro DMARK
3400						;pop bc    ; TODO BUG ?????? what is this for???? 
3400						CALLMONITOR 
3400 cd 47 17			call break_point_state  
3403				endm  
# End of macro CALLMONITOR
3403					endif 
3403			 
3403					NEXTW 
3403 c3 40 20			jp macro_next 
3406				endm 
# End of macro NEXTW
3406			;	       NEXTW 
3406			 
3406			.UNTIL: 
3406				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3406 72				db WORD_SYS_CORE+94             
3407 9d 34			dw .ENDFLOW            
3409 06				db 5 + 1 
340a .. 00			db "UNTIL",0              
3410				endm 
# End of macro CWHEAD
3410			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3410			 
3410				; pop tos as check 
3410			 
3410				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3410			 
3410				FORTH_DSP_VALUEHL 
3410 cd ce 1e			call macro_dsp_valuehl 
3413				endm 
# End of macro FORTH_DSP_VALUEHL
3413			 
3413					if DEBUG_FORTH_WORDS_KEY 
3413						DMARK "UNT" 
3413 f5				push af  
3414 3a 28 34			ld a, (.dmark)  
3417 32 bd fb			ld (debug_mark),a  
341a 3a 29 34			ld a, (.dmark+1)  
341d 32 be fb			ld (debug_mark+1),a  
3420 3a 2a 34			ld a, (.dmark+2)  
3423 32 bf fb			ld (debug_mark+2),a  
3426 18 03			jr .pastdmark  
3428 ..			.dmark: db "UNT"  
342b f1			.pastdmark: pop af  
342c			endm  
# End of macro DMARK
342c						CALLMONITOR 
342c cd 47 17			call break_point_state  
342f				endm  
# End of macro CALLMONITOR
342f					endif 
342f			 
342f			;	push hl 
342f				FORTH_DSP_POP 
342f cd 86 1f			call macro_forth_dsp_pop 
3432				endm 
# End of macro FORTH_DSP_POP
3432			 
3432			;	pop hl 
3432			 
3432				; test if true 
3432			 
3432 cd 46 0d			call ishlzero 
3435			;	ld a,l 
3435			;	add h 
3435			; 
3435			;	cp 0 
3435			 
3435 20 3e			jr nz, .untilnotdone 
3437			 
3437					if DEBUG_FORTH_WORDS 
3437						DMARK "UNf" 
3437 f5				push af  
3438 3a 4c 34			ld a, (.dmark)  
343b 32 bd fb			ld (debug_mark),a  
343e 3a 4d 34			ld a, (.dmark+1)  
3441 32 be fb			ld (debug_mark+1),a  
3444 3a 4e 34			ld a, (.dmark+2)  
3447 32 bf fb			ld (debug_mark+2),a  
344a 18 03			jr .pastdmark  
344c ..			.dmark: db "UNf"  
344f f1			.pastdmark: pop af  
3450			endm  
# End of macro DMARK
3450						CALLMONITOR 
3450 cd 47 17			call break_point_state  
3453				endm  
# End of macro CALLMONITOR
3453					endif 
3453			 
3453			 
3453			 
3453				FORTH_RSP_POP     ; get rid of DO ptr 
3453 cd 9f 1c			call macro_forth_rsp_pop 
3456				endm 
# End of macro FORTH_RSP_POP
3456			 
3456			if DEBUG_FORTH_WORDS 
3456						DMARK "UN>" 
3456 f5				push af  
3457 3a 6b 34			ld a, (.dmark)  
345a 32 bd fb			ld (debug_mark),a  
345d 3a 6c 34			ld a, (.dmark+1)  
3460 32 be fb			ld (debug_mark+1),a  
3463 3a 6d 34			ld a, (.dmark+2)  
3466 32 bf fb			ld (debug_mark+2),a  
3469 18 03			jr .pastdmark  
346b ..			.dmark: db "UN>"  
346e f1			.pastdmark: pop af  
346f			endm  
# End of macro DMARK
346f				CALLMONITOR 
346f cd 47 17			call break_point_state  
3472				endm  
# End of macro CALLMONITOR
3472			endif 
3472			 
3472					NEXTW 
3472 c3 40 20			jp macro_next 
3475				endm 
# End of macro NEXTW
3475				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3475			 
3475			.untilnotdone: 
3475			 
3475			 
3475			;	; get DO ptr 
3475			; 
3475				FORTH_RSP_TOS 
3475 cd 95 1c			call macro_forth_rsp_tos 
3478				endm 
# End of macro FORTH_RSP_TOS
3478			 
3478				;push hl 
3478			 
3478				; not going to DO any more 
3478				; get rid of the RSP pointer as DO will add it back in 
3478				;FORTH_RSP_POP 
3478				;pop hl 
3478			 
3478			 
3478 22 a4 f2			ld (os_tok_ptr), hl 
347b					if DEBUG_FORTH_WORDS 
347b						DMARK "UN<" 
347b f5				push af  
347c 3a 90 34			ld a, (.dmark)  
347f 32 bd fb			ld (debug_mark),a  
3482 3a 91 34			ld a, (.dmark+1)  
3485 32 be fb			ld (debug_mark+1),a  
3488 3a 92 34			ld a, (.dmark+2)  
348b 32 bf fb			ld (debug_mark+2),a  
348e 18 03			jr .pastdmark  
3490 ..			.dmark: db "UN<"  
3493 f1			.pastdmark: pop af  
3494			endm  
# End of macro DMARK
3494					CALLMONITOR 
3494 cd 47 17			call break_point_state  
3497				endm  
# End of macro CALLMONITOR
3497				endif 
3497 c3 d1 20			jp exec1 
349a			 
349a					 
349a			 
349a			 
349a					NEXTW 
349a c3 40 20			jp macro_next 
349d				endm 
# End of macro NEXTW
349d			 
349d			 
349d			.ENDFLOW: 
349d			 
349d			; eof 
349d			 
# End of file forth_words_flow.asm
349d			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
349d			include "forth_words_logic.asm" 
349d			 
349d			; | ## Logic Words 
349d			 
349d			.NOT: 
349d				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
349d 2d				db WORD_SYS_CORE+25             
349e e5 34			dw .IS            
34a0 04				db 3 + 1 
34a1 .. 00			db "NOT",0              
34a5				endm 
# End of macro CWHEAD
34a5			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34a5					if DEBUG_FORTH_WORDS_KEY 
34a5						DMARK "NOT" 
34a5 f5				push af  
34a6 3a ba 34			ld a, (.dmark)  
34a9 32 bd fb			ld (debug_mark),a  
34ac 3a bb 34			ld a, (.dmark+1)  
34af 32 be fb			ld (debug_mark+1),a  
34b2 3a bc 34			ld a, (.dmark+2)  
34b5 32 bf fb			ld (debug_mark+2),a  
34b8 18 03			jr .pastdmark  
34ba ..			.dmark: db "NOT"  
34bd f1			.pastdmark: pop af  
34be			endm  
# End of macro DMARK
34be						CALLMONITOR 
34be cd 47 17			call break_point_state  
34c1				endm  
# End of macro CALLMONITOR
34c1					endif 
34c1					FORTH_DSP 
34c1 cd 94 1e			call macro_forth_dsp 
34c4				endm 
# End of macro FORTH_DSP
34c4 7e					ld a,(hl)	; get type of value on TOS 
34c5 fe 02				cp DS_TYPE_INUM  
34c7 28 03				jr z, .noti 
34c9					NEXTW 
34c9 c3 40 20			jp macro_next 
34cc				endm 
# End of macro NEXTW
34cc			.noti:          FORTH_DSP_VALUEHL 
34cc cd ce 1e			call macro_dsp_valuehl 
34cf				endm 
# End of macro FORTH_DSP_VALUEHL
34cf			;		push hl 
34cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34cf cd 86 1f			call macro_forth_dsp_pop 
34d2				endm 
# End of macro FORTH_DSP_POP
34d2			;		pop hl 
34d2 3e 00				ld a,0 
34d4 bd					cp l 
34d5 28 04				jr z, .not2t 
34d7 2e 00				ld l, 0 
34d9 18 02				jr .notip 
34db			 
34db 2e ff		.not2t:		ld l, 255 
34dd			 
34dd 26 00		.notip:		ld h, 0	 
34df			 
34df cd d7 1c				call forth_push_numhl 
34e2					NEXTW 
34e2 c3 40 20			jp macro_next 
34e5				endm 
# End of macro NEXTW
34e5			 
34e5			.IS: 
34e5				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34e5 2d				db WORD_SYS_CORE+25             
34e6 0b 35			dw .LZERO            
34e8 03				db 2 + 1 
34e9 .. 00			db "IS",0              
34ec				endm 
# End of macro CWHEAD
34ec			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34ec					if DEBUG_FORTH_WORDS_KEY 
34ec						DMARK "IS." 
34ec f5				push af  
34ed 3a 01 35			ld a, (.dmark)  
34f0 32 bd fb			ld (debug_mark),a  
34f3 3a 02 35			ld a, (.dmark+1)  
34f6 32 be fb			ld (debug_mark+1),a  
34f9 3a 03 35			ld a, (.dmark+2)  
34fc 32 bf fb			ld (debug_mark+2),a  
34ff 18 03			jr .pastdmark  
3501 ..			.dmark: db "IS."  
3504 f1			.pastdmark: pop af  
3505			endm  
# End of macro DMARK
3505						CALLMONITOR 
3505 cd 47 17			call break_point_state  
3508				endm  
# End of macro CALLMONITOR
3508					endif 
3508					NEXTW 
3508 c3 40 20			jp macro_next 
350b				endm 
# End of macro NEXTW
350b			.LZERO: 
350b				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
350b 2d				db WORD_SYS_CORE+25             
350c 15 35			dw .TZERO            
350e 03				db 2 + 1 
350f .. 00			db "0<",0              
3512				endm 
# End of macro CWHEAD
3512			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3512					NEXTW 
3512 c3 40 20			jp macro_next 
3515				endm 
# End of macro NEXTW
3515			.TZERO: 
3515				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3515 2e				db WORD_SYS_CORE+26             
3516 5c 35			dw .LESS            
3518 03				db 2 + 1 
3519 .. 00			db "0=",0              
351c				endm 
# End of macro CWHEAD
351c			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
351c				; TODO add floating point number detection 
351c					;v5 FORTH_DSP_VALUE 
351c					if DEBUG_FORTH_WORDS_KEY 
351c						DMARK "0=." 
351c f5				push af  
351d 3a 31 35			ld a, (.dmark)  
3520 32 bd fb			ld (debug_mark),a  
3523 3a 32 35			ld a, (.dmark+1)  
3526 32 be fb			ld (debug_mark+1),a  
3529 3a 33 35			ld a, (.dmark+2)  
352c 32 bf fb			ld (debug_mark+2),a  
352f 18 03			jr .pastdmark  
3531 ..			.dmark: db "0=."  
3534 f1			.pastdmark: pop af  
3535			endm  
# End of macro DMARK
3535						CALLMONITOR 
3535 cd 47 17			call break_point_state  
3538				endm  
# End of macro CALLMONITOR
3538					endif 
3538					FORTH_DSP 
3538 cd 94 1e			call macro_forth_dsp 
353b				endm 
# End of macro FORTH_DSP
353b 7e					ld a,(hl)	; get type of value on TOS 
353c fe 02				cp DS_TYPE_INUM  
353e 28 00				jr z, .tz_inum 
3540			 
3540				if FORTH_ENABLE_FLOATMATH 
3540					jr .tz_done 
3540			 
3540				endif 
3540					 
3540			 
3540			.tz_inum: 
3540					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3540 cd ce 1e			call macro_dsp_valuehl 
3543				endm 
# End of macro FORTH_DSP_VALUEHL
3543			 
3543			;		push hl 
3543			 
3543					; destroy value TOS 
3543			 
3543					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3543 cd 86 1f			call macro_forth_dsp_pop 
3546				endm 
# End of macro FORTH_DSP_POP
3546			 
3546			;		pop hl 
3546			 
3546 3e 00				ld a,0 
3548			 
3548 bd					cp l 
3549 20 08				jr nz, .tz_notzero 
354b			 
354b bc					cp h 
354c			 
354c 20 05				jr nz, .tz_notzero 
354e			 
354e			 
354e 21 01 00				ld hl, FORTH_TRUE 
3551 18 03				jr .tz_done 
3553			 
3553 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3556			 
3556					; push value back onto stack for another op etc 
3556			 
3556			.tz_done: 
3556 cd d7 1c				call forth_push_numhl 
3559			 
3559					NEXTW 
3559 c3 40 20			jp macro_next 
355c				endm 
# End of macro NEXTW
355c			.LESS: 
355c				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
355c 2f				db WORD_SYS_CORE+27             
355d c5 35			dw .GT            
355f 02				db 1 + 1 
3560 .. 00			db "<",0              
3562				endm 
# End of macro CWHEAD
3562			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3562				; TODO add floating point number detection 
3562					if DEBUG_FORTH_WORDS_KEY 
3562						DMARK "LES" 
3562 f5				push af  
3563 3a 77 35			ld a, (.dmark)  
3566 32 bd fb			ld (debug_mark),a  
3569 3a 78 35			ld a, (.dmark+1)  
356c 32 be fb			ld (debug_mark+1),a  
356f 3a 79 35			ld a, (.dmark+2)  
3572 32 bf fb			ld (debug_mark+2),a  
3575 18 03			jr .pastdmark  
3577 ..			.dmark: db "LES"  
357a f1			.pastdmark: pop af  
357b			endm  
# End of macro DMARK
357b						CALLMONITOR 
357b cd 47 17			call break_point_state  
357e				endm  
# End of macro CALLMONITOR
357e					endif 
357e					FORTH_DSP 
357e cd 94 1e			call macro_forth_dsp 
3581				endm 
# End of macro FORTH_DSP
3581					;v5 FORTH_DSP_VALUE 
3581 7e					ld a,(hl)	; get type of value on TOS 
3582 fe 02				cp DS_TYPE_INUM  
3584 28 00				jr z, .less_inum 
3586			 
3586				if FORTH_ENABLE_FLOATMATH 
3586					jr .less_done 
3586			 
3586				endif 
3586					 
3586			 
3586			.less_inum: 
3586					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3586 cd ce 1e			call macro_dsp_valuehl 
3589				endm 
# End of macro FORTH_DSP_VALUEHL
3589			 
3589 e5					push hl  ; u2 
358a			 
358a					; destroy value TOS 
358a			 
358a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
358a cd 86 1f			call macro_forth_dsp_pop 
358d				endm 
# End of macro FORTH_DSP_POP
358d			 
358d			 
358d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
358d cd ce 1e			call macro_dsp_valuehl 
3590				endm 
# End of macro FORTH_DSP_VALUEHL
3590			 
3590 e5					push hl    ; u1 
3591			 
3591					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3591 cd 86 1f			call macro_forth_dsp_pop 
3594				endm 
# End of macro FORTH_DSP_POP
3594			 
3594			 
3594 b7			 or a      ;clear carry flag 
3595 01 00 00		 ld bc, FORTH_FALSE 
3598 e1			  pop hl    ; u1 
3599 d1			  pop de    ; u2 
359a ed 52		  sbc hl,de 
359c 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
359e			 
359e 01 01 00		 ld bc, FORTH_TRUE 
35a1			.lscont:  
35a1 c5					push bc 
35a2 e1					pop hl 
35a3			 
35a3					if DEBUG_FORTH_WORDS 
35a3						DMARK "LT1" 
35a3 f5				push af  
35a4 3a b8 35			ld a, (.dmark)  
35a7 32 bd fb			ld (debug_mark),a  
35aa 3a b9 35			ld a, (.dmark+1)  
35ad 32 be fb			ld (debug_mark+1),a  
35b0 3a ba 35			ld a, (.dmark+2)  
35b3 32 bf fb			ld (debug_mark+2),a  
35b6 18 03			jr .pastdmark  
35b8 ..			.dmark: db "LT1"  
35bb f1			.pastdmark: pop af  
35bc			endm  
# End of macro DMARK
35bc						CALLMONITOR 
35bc cd 47 17			call break_point_state  
35bf				endm  
# End of macro CALLMONITOR
35bf					endif 
35bf cd d7 1c				call forth_push_numhl 
35c2			 
35c2					NEXTW 
35c2 c3 40 20			jp macro_next 
35c5				endm 
# End of macro NEXTW
35c5			.GT: 
35c5				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35c5 30				db WORD_SYS_CORE+28             
35c6 2e 36			dw .EQUAL            
35c8 02				db 1 + 1 
35c9 .. 00			db ">",0              
35cb				endm 
# End of macro CWHEAD
35cb			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35cb				; TODO add floating point number detection 
35cb					if DEBUG_FORTH_WORDS_KEY 
35cb						DMARK "GRT" 
35cb f5				push af  
35cc 3a e0 35			ld a, (.dmark)  
35cf 32 bd fb			ld (debug_mark),a  
35d2 3a e1 35			ld a, (.dmark+1)  
35d5 32 be fb			ld (debug_mark+1),a  
35d8 3a e2 35			ld a, (.dmark+2)  
35db 32 bf fb			ld (debug_mark+2),a  
35de 18 03			jr .pastdmark  
35e0 ..			.dmark: db "GRT"  
35e3 f1			.pastdmark: pop af  
35e4			endm  
# End of macro DMARK
35e4						CALLMONITOR 
35e4 cd 47 17			call break_point_state  
35e7				endm  
# End of macro CALLMONITOR
35e7					endif 
35e7					FORTH_DSP 
35e7 cd 94 1e			call macro_forth_dsp 
35ea				endm 
# End of macro FORTH_DSP
35ea					;FORTH_DSP_VALUE 
35ea 7e					ld a,(hl)	; get type of value on TOS 
35eb fe 02				cp DS_TYPE_INUM  
35ed 28 00				jr z, .gt_inum 
35ef			 
35ef				if FORTH_ENABLE_FLOATMATH 
35ef					jr .gt_done 
35ef			 
35ef				endif 
35ef					 
35ef			 
35ef			.gt_inum: 
35ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ef cd ce 1e			call macro_dsp_valuehl 
35f2				endm 
# End of macro FORTH_DSP_VALUEHL
35f2			 
35f2 e5					push hl  ; u2 
35f3			 
35f3					; destroy value TOS 
35f3			 
35f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f3 cd 86 1f			call macro_forth_dsp_pop 
35f6				endm 
# End of macro FORTH_DSP_POP
35f6			 
35f6			 
35f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35f6 cd ce 1e			call macro_dsp_valuehl 
35f9				endm 
# End of macro FORTH_DSP_VALUEHL
35f9			 
35f9 e5					push hl    ; u1 
35fa			 
35fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35fa cd 86 1f			call macro_forth_dsp_pop 
35fd				endm 
# End of macro FORTH_DSP_POP
35fd			 
35fd			 
35fd b7			 or a      ;clear carry flag 
35fe 01 00 00		 ld bc, FORTH_FALSE 
3601 e1			  pop hl    ; u1 
3602 d1			  pop de    ; u2 
3603 ed 52		  sbc hl,de 
3605 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3607			 
3607 01 01 00		 ld bc, FORTH_TRUE 
360a			.gtcont:  
360a c5					push bc 
360b e1					pop hl 
360c			 
360c					if DEBUG_FORTH_WORDS 
360c						DMARK "GT1" 
360c f5				push af  
360d 3a 21 36			ld a, (.dmark)  
3610 32 bd fb			ld (debug_mark),a  
3613 3a 22 36			ld a, (.dmark+1)  
3616 32 be fb			ld (debug_mark+1),a  
3619 3a 23 36			ld a, (.dmark+2)  
361c 32 bf fb			ld (debug_mark+2),a  
361f 18 03			jr .pastdmark  
3621 ..			.dmark: db "GT1"  
3624 f1			.pastdmark: pop af  
3625			endm  
# End of macro DMARK
3625						CALLMONITOR 
3625 cd 47 17			call break_point_state  
3628				endm  
# End of macro CALLMONITOR
3628					endif 
3628 cd d7 1c				call forth_push_numhl 
362b			 
362b					NEXTW 
362b c3 40 20			jp macro_next 
362e				endm 
# End of macro NEXTW
362e			.EQUAL: 
362e				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
362e 31				db WORD_SYS_CORE+29             
362f 99 36			dw .ENDLOGIC            
3631 02				db 1 + 1 
3632 .. 00			db "=",0              
3634				endm 
# End of macro CWHEAD
3634			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3634				; TODO add floating point number detection 
3634					if DEBUG_FORTH_WORDS_KEY 
3634						DMARK "EQ." 
3634 f5				push af  
3635 3a 49 36			ld a, (.dmark)  
3638 32 bd fb			ld (debug_mark),a  
363b 3a 4a 36			ld a, (.dmark+1)  
363e 32 be fb			ld (debug_mark+1),a  
3641 3a 4b 36			ld a, (.dmark+2)  
3644 32 bf fb			ld (debug_mark+2),a  
3647 18 03			jr .pastdmark  
3649 ..			.dmark: db "EQ."  
364c f1			.pastdmark: pop af  
364d			endm  
# End of macro DMARK
364d						CALLMONITOR 
364d cd 47 17			call break_point_state  
3650				endm  
# End of macro CALLMONITOR
3650					endif 
3650					FORTH_DSP 
3650 cd 94 1e			call macro_forth_dsp 
3653				endm 
# End of macro FORTH_DSP
3653					;v5 FORTH_DSP_VALUE 
3653 7e					ld a,(hl)	; get type of value on TOS 
3654 fe 02				cp DS_TYPE_INUM  
3656 28 00				jr z, .eq_inum 
3658			 
3658				if FORTH_ENABLE_FLOATMATH 
3658					jr .eq_done 
3658			 
3658				endif 
3658					 
3658			 
3658			.eq_inum: 
3658					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3658 cd ce 1e			call macro_dsp_valuehl 
365b				endm 
# End of macro FORTH_DSP_VALUEHL
365b			 
365b e5					push hl 
365c			 
365c					; destroy value TOS 
365c			 
365c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
365c cd 86 1f			call macro_forth_dsp_pop 
365f				endm 
# End of macro FORTH_DSP_POP
365f			 
365f			 
365f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
365f cd ce 1e			call macro_dsp_valuehl 
3662				endm 
# End of macro FORTH_DSP_VALUEHL
3662			 
3662					; one value on hl get other one back 
3662			 
3662 e5					push hl 
3663			 
3663					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3663 cd 86 1f			call macro_forth_dsp_pop 
3666				endm 
# End of macro FORTH_DSP_POP
3666			 
3666 0e 00				ld c, FORTH_FALSE 
3668			 
3668 e1					pop hl 
3669 d1					pop de 
366a			 
366a 7b					ld a, e 
366b bd					cp l 
366c			 
366c 20 06				jr nz, .eq_done 
366e			 
366e 7a					ld a, d 
366f bc					cp h 
3670			 
3670 20 02				jr nz, .eq_done 
3672			 
3672 0e 01				ld c, FORTH_TRUE 
3674					 
3674			 
3674			 
3674			.eq_done: 
3674			 
3674					; TODO push value back onto stack for another op etc 
3674			 
3674 26 00				ld h, 0 
3676 69					ld l, c 
3677					if DEBUG_FORTH_WORDS 
3677						DMARK "EQ1" 
3677 f5				push af  
3678 3a 8c 36			ld a, (.dmark)  
367b 32 bd fb			ld (debug_mark),a  
367e 3a 8d 36			ld a, (.dmark+1)  
3681 32 be fb			ld (debug_mark+1),a  
3684 3a 8e 36			ld a, (.dmark+2)  
3687 32 bf fb			ld (debug_mark+2),a  
368a 18 03			jr .pastdmark  
368c ..			.dmark: db "EQ1"  
368f f1			.pastdmark: pop af  
3690			endm  
# End of macro DMARK
3690						CALLMONITOR 
3690 cd 47 17			call break_point_state  
3693				endm  
# End of macro CALLMONITOR
3693					endif 
3693 cd d7 1c				call forth_push_numhl 
3696			 
3696					NEXTW 
3696 c3 40 20			jp macro_next 
3699				endm 
# End of macro NEXTW
3699			 
3699			 
3699			.ENDLOGIC: 
3699			; eof 
3699			 
3699			 
# End of file forth_words_logic.asm
3699			include "forth_words_maths.asm" 
3699			 
3699			; | ## Maths Words 
3699			 
3699			.PLUS:	 
3699				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3699 15				db WORD_SYS_CORE+1             
369a db 36			dw .NEG            
369c 02				db 1 + 1 
369d .. 00			db "+",0              
369f				endm 
# End of macro CWHEAD
369f			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
369f					if DEBUG_FORTH_WORDS_KEY 
369f						DMARK "PLU" 
369f f5				push af  
36a0 3a b4 36			ld a, (.dmark)  
36a3 32 bd fb			ld (debug_mark),a  
36a6 3a b5 36			ld a, (.dmark+1)  
36a9 32 be fb			ld (debug_mark+1),a  
36ac 3a b6 36			ld a, (.dmark+2)  
36af 32 bf fb			ld (debug_mark+2),a  
36b2 18 03			jr .pastdmark  
36b4 ..			.dmark: db "PLU"  
36b7 f1			.pastdmark: pop af  
36b8			endm  
# End of macro DMARK
36b8						CALLMONITOR 
36b8 cd 47 17			call break_point_state  
36bb				endm  
# End of macro CALLMONITOR
36bb					endif 
36bb					; add top two values and push back result 
36bb			 
36bb					;for v5 FORTH_DSP_VALUE 
36bb					FORTH_DSP 
36bb cd 94 1e			call macro_forth_dsp 
36be				endm 
# End of macro FORTH_DSP
36be 7e					ld a,(hl)	; get type of value on TOS 
36bf fe 02				cp DS_TYPE_INUM  
36c1 28 03				jr z, .dot_inum 
36c3			 
36c3					NEXTW 
36c3 c3 40 20			jp macro_next 
36c6				endm 
# End of macro NEXTW
36c6			 
36c6			; float maths 
36c6			 
36c6				if FORTH_ENABLE_FLOATMATH 
36c6						inc hl      ; now at start of numeric as string 
36c6			 
36c6					if DEBUG_FORTH_MATHS 
36c6						DMARK "ADD" 
36c6				CALLMONITOR 
36c6					endif 
36c6			 
36c6					;ld ix, hl 
36c6					call CON 
36c6			 
36c6			 
36c6					push hl 
36c6					 
36c6					 
36c6			 
36c6						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36c6			 
36c6					; get next number 
36c6			 
36c6						FORTH_DSP_VALUE 
36c6			 
36c6						inc hl      ; now at start of numeric as string 
36c6			 
36c6					;ld ix, hl 
36c6					call CON 
36c6			 
36c6					push hl 
36c6			 
36c6			 
36c6						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c6			 
36c6						; TODO do add 
36c6			 
36c6						call IADD 
36c6			 
36c6						; TODO get result back as ascii 
36c6			 
36c6						; TODO push result  
36c6			 
36c6			 
36c6			 
36c6						jr .dot_done 
36c6				endif 
36c6			 
36c6			.dot_inum: 
36c6			 
36c6			 
36c6					if DEBUG_FORTH_DOT 
36c6						DMARK "+IT" 
36c6				CALLMONITOR 
36c6					endif 
36c6			 
36c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36c6 cd ce 1e			call macro_dsp_valuehl 
36c9				endm 
# End of macro FORTH_DSP_VALUEHL
36c9			 
36c9				; TODO add floating point number detection 
36c9			 
36c9 e5					push hl 
36ca			 
36ca					; destroy value TOS 
36ca			 
36ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ca cd 86 1f			call macro_forth_dsp_pop 
36cd				endm 
# End of macro FORTH_DSP_POP
36cd			 
36cd			 
36cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36cd cd ce 1e			call macro_dsp_valuehl 
36d0				endm 
# End of macro FORTH_DSP_VALUEHL
36d0			 
36d0					; one value on hl get other one back 
36d0			 
36d0 d1					pop de 
36d1			 
36d1					; do the add 
36d1			 
36d1 19					add hl,de 
36d2			 
36d2					; save it 
36d2			 
36d2			;		push hl	 
36d2			 
36d2					; 
36d2			 
36d2					; destroy value TOS 
36d2			 
36d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36d2 cd 86 1f			call macro_forth_dsp_pop 
36d5				endm 
# End of macro FORTH_DSP_POP
36d5			 
36d5					; TODO push value back onto stack for another op etc 
36d5			 
36d5			;		pop hl 
36d5			 
36d5			.dot_done: 
36d5 cd d7 1c				call forth_push_numhl 
36d8			 
36d8					NEXTW 
36d8 c3 40 20			jp macro_next 
36db				endm 
# End of macro NEXTW
36db			.NEG: 
36db			 
36db				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36db 17				db WORD_SYS_CORE+3             
36dc 1e 37			dw .DIV            
36de 02				db 1 + 1 
36df .. 00			db "-",0              
36e1				endm 
# End of macro CWHEAD
36e1			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36e1					if DEBUG_FORTH_WORDS_KEY 
36e1						DMARK "SUB" 
36e1 f5				push af  
36e2 3a f6 36			ld a, (.dmark)  
36e5 32 bd fb			ld (debug_mark),a  
36e8 3a f7 36			ld a, (.dmark+1)  
36eb 32 be fb			ld (debug_mark+1),a  
36ee 3a f8 36			ld a, (.dmark+2)  
36f1 32 bf fb			ld (debug_mark+2),a  
36f4 18 03			jr .pastdmark  
36f6 ..			.dmark: db "SUB"  
36f9 f1			.pastdmark: pop af  
36fa			endm  
# End of macro DMARK
36fa						CALLMONITOR 
36fa cd 47 17			call break_point_state  
36fd				endm  
# End of macro CALLMONITOR
36fd					endif 
36fd			 
36fd			 
36fd				; TODO add floating point number detection 
36fd					; v5 FORTH_DSP_VALUE 
36fd					FORTH_DSP 
36fd cd 94 1e			call macro_forth_dsp 
3700				endm 
# End of macro FORTH_DSP
3700 7e					ld a,(hl)	; get type of value on TOS 
3701 fe 02				cp DS_TYPE_INUM  
3703 28 03				jr z, .neg_inum 
3705			 
3705					NEXTW 
3705 c3 40 20			jp macro_next 
3708				endm 
# End of macro NEXTW
3708			 
3708			; float maths 
3708			 
3708				if FORTH_ENABLE_FLOATMATH 
3708					jr .neg_done 
3708			 
3708				endif 
3708					 
3708			 
3708			.neg_inum: 
3708					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3708 cd ce 1e			call macro_dsp_valuehl 
370b				endm 
# End of macro FORTH_DSP_VALUEHL
370b			 
370b e5					push hl 
370c			 
370c					; destroy value TOS 
370c			 
370c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
370c cd 86 1f			call macro_forth_dsp_pop 
370f				endm 
# End of macro FORTH_DSP_POP
370f			 
370f			 
370f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
370f cd ce 1e			call macro_dsp_valuehl 
3712				endm 
# End of macro FORTH_DSP_VALUEHL
3712			 
3712					; one value on hl get other one back 
3712			 
3712 d1					pop de 
3713			 
3713					; do the sub 
3713			;		ex de, hl 
3713			 
3713 ed 52				sbc hl,de 
3715			 
3715					; save it 
3715			 
3715			;		push hl	 
3715			 
3715					; 
3715			 
3715					; destroy value TOS 
3715			 
3715					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3715 cd 86 1f			call macro_forth_dsp_pop 
3718				endm 
# End of macro FORTH_DSP_POP
3718			 
3718					; TODO push value back onto stack for another op etc 
3718			 
3718			;		pop hl 
3718			 
3718 cd d7 1c				call forth_push_numhl 
371b			.neg_done: 
371b			 
371b					NEXTW 
371b c3 40 20			jp macro_next 
371e				endm 
# End of macro NEXTW
371e			.DIV: 
371e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
371e 18				db WORD_SYS_CORE+4             
371f 6b 37			dw .MUL            
3721 02				db 1 + 1 
3722 .. 00			db "/",0              
3724				endm 
# End of macro CWHEAD
3724			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3724					if DEBUG_FORTH_WORDS_KEY 
3724						DMARK "DIV" 
3724 f5				push af  
3725 3a 39 37			ld a, (.dmark)  
3728 32 bd fb			ld (debug_mark),a  
372b 3a 3a 37			ld a, (.dmark+1)  
372e 32 be fb			ld (debug_mark+1),a  
3731 3a 3b 37			ld a, (.dmark+2)  
3734 32 bf fb			ld (debug_mark+2),a  
3737 18 03			jr .pastdmark  
3739 ..			.dmark: db "DIV"  
373c f1			.pastdmark: pop af  
373d			endm  
# End of macro DMARK
373d						CALLMONITOR 
373d cd 47 17			call break_point_state  
3740				endm  
# End of macro CALLMONITOR
3740					endif 
3740				; TODO add floating point number detection 
3740					; v5 FORTH_DSP_VALUE 
3740					FORTH_DSP 
3740 cd 94 1e			call macro_forth_dsp 
3743				endm 
# End of macro FORTH_DSP
3743 7e					ld a,(hl)	; get type of value on TOS 
3744 fe 02				cp DS_TYPE_INUM  
3746 28 03				jr z, .div_inum 
3748			 
3748				if FORTH_ENABLE_FLOATMATH 
3748					jr .div_done 
3748			 
3748				endif 
3748					NEXTW 
3748 c3 40 20			jp macro_next 
374b				endm 
# End of macro NEXTW
374b			.div_inum: 
374b			 
374b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
374b cd ce 1e			call macro_dsp_valuehl 
374e				endm 
# End of macro FORTH_DSP_VALUEHL
374e			 
374e e5					push hl    ; to go to bc 
374f			 
374f					; destroy value TOS 
374f			 
374f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
374f cd 86 1f			call macro_forth_dsp_pop 
3752				endm 
# End of macro FORTH_DSP_POP
3752			 
3752			 
3752					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3752 cd ce 1e			call macro_dsp_valuehl 
3755				endm 
# End of macro FORTH_DSP_VALUEHL
3755			 
3755					; hl to go to de 
3755			 
3755 e5					push hl 
3756			 
3756 c1					pop bc 
3757 d1					pop de		 
3758			 
3758			 
3758					if DEBUG_FORTH_MATHS 
3758						DMARK "DIV" 
3758				CALLMONITOR 
3758					endif 
3758					; one value on hl but move to a get other one back 
3758			 
3758			        
3758 cd 7a 0c			call Div16 
375b			 
375b			;	push af	 
375b e5				push hl 
375c c5				push bc 
375d			 
375d					if DEBUG_FORTH_MATHS 
375d						DMARK "DI1" 
375d				CALLMONITOR 
375d					endif 
375d			 
375d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
375d cd 86 1f			call macro_forth_dsp_pop 
3760				endm 
# End of macro FORTH_DSP_POP
3760			 
3760			 
3760			 
3760 e1					pop hl    ; result 
3761			 
3761 cd d7 1c				call forth_push_numhl 
3764			 
3764 e1					pop hl    ; reminder 
3765			;		ld h,0 
3765			;		ld l,d 
3765			 
3765 cd d7 1c				call forth_push_numhl 
3768			.div_done: 
3768					NEXTW 
3768 c3 40 20			jp macro_next 
376b				endm 
# End of macro NEXTW
376b			.MUL: 
376b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
376b 19				db WORD_SYS_CORE+5             
376c b0 37			dw .MIN            
376e 02				db 1 + 1 
376f .. 00			db "*",0              
3771				endm 
# End of macro CWHEAD
3771			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3771				; TODO add floating point number detection 
3771					if DEBUG_FORTH_WORDS_KEY 
3771						DMARK "MUL" 
3771 f5				push af  
3772 3a 86 37			ld a, (.dmark)  
3775 32 bd fb			ld (debug_mark),a  
3778 3a 87 37			ld a, (.dmark+1)  
377b 32 be fb			ld (debug_mark+1),a  
377e 3a 88 37			ld a, (.dmark+2)  
3781 32 bf fb			ld (debug_mark+2),a  
3784 18 03			jr .pastdmark  
3786 ..			.dmark: db "MUL"  
3789 f1			.pastdmark: pop af  
378a			endm  
# End of macro DMARK
378a						CALLMONITOR 
378a cd 47 17			call break_point_state  
378d				endm  
# End of macro CALLMONITOR
378d					endif 
378d					FORTH_DSP 
378d cd 94 1e			call macro_forth_dsp 
3790				endm 
# End of macro FORTH_DSP
3790					; v5 FORTH_DSP_VALUE 
3790 7e					ld a,(hl)	; get type of value on TOS 
3791 fe 02				cp DS_TYPE_INUM  
3793 28 03				jr z, .mul_inum 
3795			 
3795				if FORTH_ENABLE_FLOATMATH 
3795					jr .mul_done 
3795			 
3795				endif 
3795			 
3795					NEXTW 
3795 c3 40 20			jp macro_next 
3798				endm 
# End of macro NEXTW
3798			.mul_inum:	 
3798			 
3798					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3798 cd ce 1e			call macro_dsp_valuehl 
379b				endm 
# End of macro FORTH_DSP_VALUEHL
379b			 
379b e5					push hl 
379c			 
379c					; destroy value TOS 
379c			 
379c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
379c cd 86 1f			call macro_forth_dsp_pop 
379f				endm 
# End of macro FORTH_DSP_POP
379f			 
379f			 
379f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
379f cd ce 1e			call macro_dsp_valuehl 
37a2				endm 
# End of macro FORTH_DSP_VALUEHL
37a2			 
37a2					; one value on hl but move to a get other one back 
37a2			 
37a2 7d					ld a, l 
37a3			 
37a3 d1					pop de 
37a4			 
37a4					; do the mull 
37a4			;		ex de, hl 
37a4			 
37a4 cd a0 0c				call Mult16 
37a7					; save it 
37a7			 
37a7			;		push hl	 
37a7			 
37a7					; 
37a7			 
37a7					; destroy value TOS 
37a7			 
37a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a7 cd 86 1f			call macro_forth_dsp_pop 
37aa				endm 
# End of macro FORTH_DSP_POP
37aa			 
37aa					; TODO push value back onto stack for another op etc 
37aa			 
37aa			;		pop hl 
37aa			 
37aa cd d7 1c				call forth_push_numhl 
37ad			 
37ad			.mul_done: 
37ad					NEXTW 
37ad c3 40 20			jp macro_next 
37b0				endm 
# End of macro NEXTW
37b0			 
37b0			 
37b0			 
37b0			 
37b0			.MIN: 
37b0				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37b0 49				db WORD_SYS_CORE+53             
37b1 31 38			dw .MAX            
37b3 04				db 3 + 1 
37b4 .. 00			db "MIN",0              
37b8				endm 
# End of macro CWHEAD
37b8			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37b8					if DEBUG_FORTH_WORDS_KEY 
37b8						DMARK "MIN" 
37b8 f5				push af  
37b9 3a cd 37			ld a, (.dmark)  
37bc 32 bd fb			ld (debug_mark),a  
37bf 3a ce 37			ld a, (.dmark+1)  
37c2 32 be fb			ld (debug_mark+1),a  
37c5 3a cf 37			ld a, (.dmark+2)  
37c8 32 bf fb			ld (debug_mark+2),a  
37cb 18 03			jr .pastdmark  
37cd ..			.dmark: db "MIN"  
37d0 f1			.pastdmark: pop af  
37d1			endm  
# End of macro DMARK
37d1						CALLMONITOR 
37d1 cd 47 17			call break_point_state  
37d4				endm  
# End of macro CALLMONITOR
37d4					endif 
37d4					; get u2 
37d4			 
37d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d4 cd ce 1e			call macro_dsp_valuehl 
37d7				endm 
# End of macro FORTH_DSP_VALUEHL
37d7			 
37d7 e5					push hl   ; u2 
37d8			 
37d8					; destroy value TOS 
37d8			 
37d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d8 cd 86 1f			call macro_forth_dsp_pop 
37db				endm 
# End of macro FORTH_DSP_POP
37db			 
37db					; get u1 
37db			 
37db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37db cd ce 1e			call macro_dsp_valuehl 
37de				endm 
# End of macro FORTH_DSP_VALUEHL
37de			 
37de e5					push hl  ; u1 
37df			 
37df					; destroy value TOS 
37df			 
37df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37df cd 86 1f			call macro_forth_dsp_pop 
37e2				endm 
# End of macro FORTH_DSP_POP
37e2			 
37e2 b7			 or a      ;clear carry flag 
37e3 e1			  pop hl    ; u1 
37e4 d1			  pop de    ; u2 
37e5 e5				push hl   ; saved in case hl is lowest 
37e6 ed 52		  sbc hl,de 
37e8 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37ea			 
37ea e1				pop hl 
37eb					if DEBUG_FORTH_WORDS 
37eb						DMARK "MIN" 
37eb f5				push af  
37ec 3a 00 38			ld a, (.dmark)  
37ef 32 bd fb			ld (debug_mark),a  
37f2 3a 01 38			ld a, (.dmark+1)  
37f5 32 be fb			ld (debug_mark+1),a  
37f8 3a 02 38			ld a, (.dmark+2)  
37fb 32 bf fb			ld (debug_mark+2),a  
37fe 18 03			jr .pastdmark  
3800 ..			.dmark: db "MIN"  
3803 f1			.pastdmark: pop af  
3804			endm  
# End of macro DMARK
3804						CALLMONITOR 
3804 cd 47 17			call break_point_state  
3807				endm  
# End of macro CALLMONITOR
3807					endif 
3807 cd d7 1c				call forth_push_numhl 
380a			 
380a				       NEXTW 
380a c3 40 20			jp macro_next 
380d				endm 
# End of macro NEXTW
380d			 
380d			.mincont:  
380d c1				pop bc   ; tidy up 
380e eb				ex de , hl  
380f					if DEBUG_FORTH_WORDS 
380f						DMARK "MI1" 
380f f5				push af  
3810 3a 24 38			ld a, (.dmark)  
3813 32 bd fb			ld (debug_mark),a  
3816 3a 25 38			ld a, (.dmark+1)  
3819 32 be fb			ld (debug_mark+1),a  
381c 3a 26 38			ld a, (.dmark+2)  
381f 32 bf fb			ld (debug_mark+2),a  
3822 18 03			jr .pastdmark  
3824 ..			.dmark: db "MI1"  
3827 f1			.pastdmark: pop af  
3828			endm  
# End of macro DMARK
3828						CALLMONITOR 
3828 cd 47 17			call break_point_state  
382b				endm  
# End of macro CALLMONITOR
382b					endif 
382b cd d7 1c				call forth_push_numhl 
382e			 
382e				       NEXTW 
382e c3 40 20			jp macro_next 
3831				endm 
# End of macro NEXTW
3831			.MAX: 
3831				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3831 4a				db WORD_SYS_CORE+54             
3832 b2 38			dw .RND16            
3834 04				db 3 + 1 
3835 .. 00			db "MAX",0              
3839				endm 
# End of macro CWHEAD
3839			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3839					if DEBUG_FORTH_WORDS_KEY 
3839						DMARK "MAX" 
3839 f5				push af  
383a 3a 4e 38			ld a, (.dmark)  
383d 32 bd fb			ld (debug_mark),a  
3840 3a 4f 38			ld a, (.dmark+1)  
3843 32 be fb			ld (debug_mark+1),a  
3846 3a 50 38			ld a, (.dmark+2)  
3849 32 bf fb			ld (debug_mark+2),a  
384c 18 03			jr .pastdmark  
384e ..			.dmark: db "MAX"  
3851 f1			.pastdmark: pop af  
3852			endm  
# End of macro DMARK
3852						CALLMONITOR 
3852 cd 47 17			call break_point_state  
3855				endm  
# End of macro CALLMONITOR
3855					endif 
3855					; get u2 
3855			 
3855					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3855 cd ce 1e			call macro_dsp_valuehl 
3858				endm 
# End of macro FORTH_DSP_VALUEHL
3858			 
3858 e5					push hl   ; u2 
3859			 
3859					; destroy value TOS 
3859			 
3859					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3859 cd 86 1f			call macro_forth_dsp_pop 
385c				endm 
# End of macro FORTH_DSP_POP
385c			 
385c					; get u1 
385c			 
385c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
385c cd ce 1e			call macro_dsp_valuehl 
385f				endm 
# End of macro FORTH_DSP_VALUEHL
385f			 
385f e5					push hl  ; u1 
3860			 
3860					; destroy value TOS 
3860			 
3860					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3860 cd 86 1f			call macro_forth_dsp_pop 
3863				endm 
# End of macro FORTH_DSP_POP
3863			 
3863 b7			 or a      ;clear carry flag 
3864 e1			  pop hl    ; u1 
3865 d1			  pop de    ; u2 
3866 e5				push hl   ; saved in case hl is lowest 
3867 ed 52		  sbc hl,de 
3869 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
386b			 
386b e1				pop hl 
386c					if DEBUG_FORTH_WORDS 
386c						DMARK "MAX" 
386c f5				push af  
386d 3a 81 38			ld a, (.dmark)  
3870 32 bd fb			ld (debug_mark),a  
3873 3a 82 38			ld a, (.dmark+1)  
3876 32 be fb			ld (debug_mark+1),a  
3879 3a 83 38			ld a, (.dmark+2)  
387c 32 bf fb			ld (debug_mark+2),a  
387f 18 03			jr .pastdmark  
3881 ..			.dmark: db "MAX"  
3884 f1			.pastdmark: pop af  
3885			endm  
# End of macro DMARK
3885						CALLMONITOR 
3885 cd 47 17			call break_point_state  
3888				endm  
# End of macro CALLMONITOR
3888					endif 
3888 cd d7 1c				call forth_push_numhl 
388b			 
388b				       NEXTW 
388b c3 40 20			jp macro_next 
388e				endm 
# End of macro NEXTW
388e			 
388e			.maxcont:  
388e c1				pop bc   ; tidy up 
388f eb				ex de , hl  
3890					if DEBUG_FORTH_WORDS 
3890						DMARK "MA1" 
3890 f5				push af  
3891 3a a5 38			ld a, (.dmark)  
3894 32 bd fb			ld (debug_mark),a  
3897 3a a6 38			ld a, (.dmark+1)  
389a 32 be fb			ld (debug_mark+1),a  
389d 3a a7 38			ld a, (.dmark+2)  
38a0 32 bf fb			ld (debug_mark+2),a  
38a3 18 03			jr .pastdmark  
38a5 ..			.dmark: db "MA1"  
38a8 f1			.pastdmark: pop af  
38a9			endm  
# End of macro DMARK
38a9						CALLMONITOR 
38a9 cd 47 17			call break_point_state  
38ac				endm  
# End of macro CALLMONITOR
38ac					endif 
38ac cd d7 1c				call forth_push_numhl 
38af				       NEXTW 
38af c3 40 20			jp macro_next 
38b2				endm 
# End of macro NEXTW
38b2			 
38b2			.RND16: 
38b2				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38b2 4e				db WORD_SYS_CORE+58             
38b3 e1 38			dw .RND8            
38b5 06				db 5 + 1 
38b6 .. 00			db "RND16",0              
38bc				endm 
# End of macro CWHEAD
38bc			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38bc					if DEBUG_FORTH_WORDS_KEY 
38bc						DMARK "R16" 
38bc f5				push af  
38bd 3a d1 38			ld a, (.dmark)  
38c0 32 bd fb			ld (debug_mark),a  
38c3 3a d2 38			ld a, (.dmark+1)  
38c6 32 be fb			ld (debug_mark+1),a  
38c9 3a d3 38			ld a, (.dmark+2)  
38cc 32 bf fb			ld (debug_mark+2),a  
38cf 18 03			jr .pastdmark  
38d1 ..			.dmark: db "R16"  
38d4 f1			.pastdmark: pop af  
38d5			endm  
# End of macro DMARK
38d5						CALLMONITOR 
38d5 cd 47 17			call break_point_state  
38d8				endm  
# End of macro CALLMONITOR
38d8					endif 
38d8 cd 44 0c				call prng16  
38db cd d7 1c				call forth_push_numhl 
38de				       NEXTW 
38de c3 40 20			jp macro_next 
38e1				endm 
# End of macro NEXTW
38e1			.RND8: 
38e1				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38e1 60				db WORD_SYS_CORE+76             
38e2 16 39			dw .RND            
38e4 05				db 4 + 1 
38e5 .. 00			db "RND8",0              
38ea				endm 
# End of macro CWHEAD
38ea			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38ea					if DEBUG_FORTH_WORDS_KEY 
38ea						DMARK "RN8" 
38ea f5				push af  
38eb 3a ff 38			ld a, (.dmark)  
38ee 32 bd fb			ld (debug_mark),a  
38f1 3a 00 39			ld a, (.dmark+1)  
38f4 32 be fb			ld (debug_mark+1),a  
38f7 3a 01 39			ld a, (.dmark+2)  
38fa 32 bf fb			ld (debug_mark+2),a  
38fd 18 03			jr .pastdmark  
38ff ..			.dmark: db "RN8"  
3902 f1			.pastdmark: pop af  
3903			endm  
# End of macro DMARK
3903						CALLMONITOR 
3903 cd 47 17			call break_point_state  
3906				endm  
# End of macro CALLMONITOR
3906					endif 
3906 2a 3e fa				ld hl,(xrandc) 
3909 23					inc hl 
390a cd 5e 0c				call xrnd 
390d 6f					ld l,a	 
390e 26 00				ld h,0 
3910 cd d7 1c				call forth_push_numhl 
3913				       NEXTW 
3913 c3 40 20			jp macro_next 
3916				endm 
# End of macro NEXTW
3916			.RND: 
3916				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3916 60				db WORD_SYS_CORE+76             
3917 1c 3a			dw .ENDMATHS            
3919 04				db 3 + 1 
391a .. 00			db "RND",0              
391e				endm 
# End of macro CWHEAD
391e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
391e			 
391e					if DEBUG_FORTH_WORDS_KEY 
391e						DMARK "RND" 
391e f5				push af  
391f 3a 33 39			ld a, (.dmark)  
3922 32 bd fb			ld (debug_mark),a  
3925 3a 34 39			ld a, (.dmark+1)  
3928 32 be fb			ld (debug_mark+1),a  
392b 3a 35 39			ld a, (.dmark+2)  
392e 32 bf fb			ld (debug_mark+2),a  
3931 18 03			jr .pastdmark  
3933 ..			.dmark: db "RND"  
3936 f1			.pastdmark: pop af  
3937			endm  
# End of macro DMARK
3937						CALLMONITOR 
3937 cd 47 17			call break_point_state  
393a				endm  
# End of macro CALLMONITOR
393a					endif 
393a					 
393a					FORTH_DSP_VALUEHL    ; upper range 
393a cd ce 1e			call macro_dsp_valuehl 
393d				endm 
# End of macro FORTH_DSP_VALUEHL
393d			 
393d 22 42 fa				ld (LFSRSeed), hl	 
3940			 
3940					if DEBUG_FORTH_WORDS 
3940						DMARK "RN1" 
3940 f5				push af  
3941 3a 55 39			ld a, (.dmark)  
3944 32 bd fb			ld (debug_mark),a  
3947 3a 56 39			ld a, (.dmark+1)  
394a 32 be fb			ld (debug_mark+1),a  
394d 3a 57 39			ld a, (.dmark+2)  
3950 32 bf fb			ld (debug_mark+2),a  
3953 18 03			jr .pastdmark  
3955 ..			.dmark: db "RN1"  
3958 f1			.pastdmark: pop af  
3959			endm  
# End of macro DMARK
3959						CALLMONITOR 
3959 cd 47 17			call break_point_state  
395c				endm  
# End of macro CALLMONITOR
395c					endif 
395c					FORTH_DSP_POP 
395c cd 86 1f			call macro_forth_dsp_pop 
395f				endm 
# End of macro FORTH_DSP_POP
395f			 
395f					FORTH_DSP_VALUEHL    ; low range 
395f cd ce 1e			call macro_dsp_valuehl 
3962				endm 
# End of macro FORTH_DSP_VALUEHL
3962			 
3962					if DEBUG_FORTH_WORDS 
3962						DMARK "RN2" 
3962 f5				push af  
3963 3a 77 39			ld a, (.dmark)  
3966 32 bd fb			ld (debug_mark),a  
3969 3a 78 39			ld a, (.dmark+1)  
396c 32 be fb			ld (debug_mark+1),a  
396f 3a 79 39			ld a, (.dmark+2)  
3972 32 bf fb			ld (debug_mark+2),a  
3975 18 03			jr .pastdmark  
3977 ..			.dmark: db "RN2"  
397a f1			.pastdmark: pop af  
397b			endm  
# End of macro DMARK
397b						CALLMONITOR 
397b cd 47 17			call break_point_state  
397e				endm  
# End of macro CALLMONITOR
397e					endif 
397e 22 44 fa				ld (LFSRSeed+2), hl 
3981			 
3981					FORTH_DSP_POP 
3981 cd 86 1f			call macro_forth_dsp_pop 
3984				endm 
# End of macro FORTH_DSP_POP
3984			 
3984 e5					push hl 
3985			 
3985 e1			.inrange:	pop hl 
3986 cd 44 0c				call prng16  
3989					if DEBUG_FORTH_WORDS 
3989						DMARK "RN3" 
3989 f5				push af  
398a 3a 9e 39			ld a, (.dmark)  
398d 32 bd fb			ld (debug_mark),a  
3990 3a 9f 39			ld a, (.dmark+1)  
3993 32 be fb			ld (debug_mark+1),a  
3996 3a a0 39			ld a, (.dmark+2)  
3999 32 bf fb			ld (debug_mark+2),a  
399c 18 03			jr .pastdmark  
399e ..			.dmark: db "RN3"  
39a1 f1			.pastdmark: pop af  
39a2			endm  
# End of macro DMARK
39a2						CALLMONITOR 
39a2 cd 47 17			call break_point_state  
39a5				endm  
# End of macro CALLMONITOR
39a5					endif 
39a5					 
39a5					; if the range is 8bit knock out the high byte 
39a5			 
39a5 ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
39a9			 
39a9 3e 00				ld a, 0 
39ab ba					cp d  
39ac 20 1e				jr nz, .hirange 
39ae 26 00				ld h, 0   ; knock it down to 8bit 
39b0			 
39b0					if DEBUG_FORTH_WORDS 
39b0						DMARK "RNk" 
39b0 f5				push af  
39b1 3a c5 39			ld a, (.dmark)  
39b4 32 bd fb			ld (debug_mark),a  
39b7 3a c6 39			ld a, (.dmark+1)  
39ba 32 be fb			ld (debug_mark+1),a  
39bd 3a c7 39			ld a, (.dmark+2)  
39c0 32 bf fb			ld (debug_mark+2),a  
39c3 18 03			jr .pastdmark  
39c5 ..			.dmark: db "RNk"  
39c8 f1			.pastdmark: pop af  
39c9			endm  
# End of macro DMARK
39c9						CALLMONITOR 
39c9 cd 47 17			call break_point_state  
39cc				endm  
# End of macro CALLMONITOR
39cc					endif 
39cc			.hirange:   
39cc e5					push hl  
39cd b7					or a  
39ce ed 52		                sbc hl, de 
39d0			 
39d0					;call cmp16 
39d0			 
39d0 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39d2 e1					pop hl 
39d3 e5					push hl 
39d4			 
39d4					if DEBUG_FORTH_WORDS 
39d4						DMARK "RN4" 
39d4 f5				push af  
39d5 3a e9 39			ld a, (.dmark)  
39d8 32 bd fb			ld (debug_mark),a  
39db 3a ea 39			ld a, (.dmark+1)  
39de 32 be fb			ld (debug_mark+1),a  
39e1 3a eb 39			ld a, (.dmark+2)  
39e4 32 bf fb			ld (debug_mark+2),a  
39e7 18 03			jr .pastdmark  
39e9 ..			.dmark: db "RN4"  
39ec f1			.pastdmark: pop af  
39ed			endm  
# End of macro DMARK
39ed						CALLMONITOR 
39ed cd 47 17			call break_point_state  
39f0				endm  
# End of macro CALLMONITOR
39f0					endif 
39f0 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
39f4					;call cmp16 
39f4				 
39f4 b7					or a  
39f5 ed 52		                sbc hl, de 
39f7 38 8c				jr c, .inrange 
39f9			 
39f9 e1					pop hl 
39fa					 
39fa					if DEBUG_FORTH_WORDS 
39fa						DMARK "RNd" 
39fa f5				push af  
39fb 3a 0f 3a			ld a, (.dmark)  
39fe 32 bd fb			ld (debug_mark),a  
3a01 3a 10 3a			ld a, (.dmark+1)  
3a04 32 be fb			ld (debug_mark+1),a  
3a07 3a 11 3a			ld a, (.dmark+2)  
3a0a 32 bf fb			ld (debug_mark+2),a  
3a0d 18 03			jr .pastdmark  
3a0f ..			.dmark: db "RNd"  
3a12 f1			.pastdmark: pop af  
3a13			endm  
# End of macro DMARK
3a13						CALLMONITOR 
3a13 cd 47 17			call break_point_state  
3a16				endm  
# End of macro CALLMONITOR
3a16					endif 
3a16			 
3a16			 
3a16 cd d7 1c				call forth_push_numhl 
3a19				       NEXTW 
3a19 c3 40 20			jp macro_next 
3a1c				endm 
# End of macro NEXTW
3a1c			 
3a1c			.ENDMATHS: 
3a1c			 
3a1c			; eof 
3a1c			 
# End of file forth_words_maths.asm
3a1c			include "forth_words_display.asm" 
3a1c			 
3a1c			; | ## Display Words 
3a1c			 
3a1c			.INFO: 
3a1c			 
3a1c				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a1c 62				db WORD_SYS_CORE+78             
3a1d 39 3a			dw .ATP            
3a1f 05				db 4 + 1 
3a20 .. 00			db "INFO",0              
3a25				endm 
# End of macro CWHEAD
3a25			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a25					FORTH_DSP_VALUEHL 
3a25 cd ce 1e			call macro_dsp_valuehl 
3a28				endm 
# End of macro FORTH_DSP_VALUEHL
3a28			 
3a28					FORTH_DSP_POP 
3a28 cd 86 1f			call macro_forth_dsp_pop 
3a2b				endm 
# End of macro FORTH_DSP_POP
3a2b			 
3a2b e5					push hl 
3a2c			 
3a2c					FORTH_DSP_VALUEHL 
3a2c cd ce 1e			call macro_dsp_valuehl 
3a2f				endm 
# End of macro FORTH_DSP_VALUEHL
3a2f			 
3a2f					FORTH_DSP_POP 
3a2f cd 86 1f			call macro_forth_dsp_pop 
3a32				endm 
# End of macro FORTH_DSP_POP
3a32			 
3a32 d1					pop de 
3a33			 
3a33 cd 7a 0a				call info_panel 
3a36			 
3a36			 
3a36					NEXTW 
3a36 c3 40 20			jp macro_next 
3a39				endm 
# End of macro NEXTW
3a39			.ATP: 
3a39				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a39 62				db WORD_SYS_CORE+78             
3a3a b0 3a			dw .FB            
3a3c 04				db 3 + 1 
3a3d .. 00			db "AT?",0              
3a41				endm 
# End of macro CWHEAD
3a41			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a41					if DEBUG_FORTH_WORDS_KEY 
3a41						DMARK "AT?" 
3a41 f5				push af  
3a42 3a 56 3a			ld a, (.dmark)  
3a45 32 bd fb			ld (debug_mark),a  
3a48 3a 57 3a			ld a, (.dmark+1)  
3a4b 32 be fb			ld (debug_mark+1),a  
3a4e 3a 58 3a			ld a, (.dmark+2)  
3a51 32 bf fb			ld (debug_mark+2),a  
3a54 18 03			jr .pastdmark  
3a56 ..			.dmark: db "AT?"  
3a59 f1			.pastdmark: pop af  
3a5a			endm  
# End of macro DMARK
3a5a						CALLMONITOR 
3a5a cd 47 17			call break_point_state  
3a5d				endm  
# End of macro CALLMONITOR
3a5d					endif 
3a5d 3a cc f9				ld a, (f_cursor_ptr) 
3a60			 
3a60			if DEBUG_FORTH_WORDS 
3a60				DMARK "AT?" 
3a60 f5				push af  
3a61 3a 75 3a			ld a, (.dmark)  
3a64 32 bd fb			ld (debug_mark),a  
3a67 3a 76 3a			ld a, (.dmark+1)  
3a6a 32 be fb			ld (debug_mark+1),a  
3a6d 3a 77 3a			ld a, (.dmark+2)  
3a70 32 bf fb			ld (debug_mark+2),a  
3a73 18 03			jr .pastdmark  
3a75 ..			.dmark: db "AT?"  
3a78 f1			.pastdmark: pop af  
3a79			endm  
# End of macro DMARK
3a79				CALLMONITOR 
3a79 cd 47 17			call break_point_state  
3a7c				endm  
# End of macro CALLMONITOR
3a7c			endif	 
3a7c					; count the number of rows 
3a7c			 
3a7c 06 00				ld b, 0 
3a7e 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a7f d6 14				sub display_cols 
3a81 f2 87 3a				jp p, .atprunder 
3a84 04					inc b 
3a85 18 f7				jr .atpr 
3a87			.atprunder:	 
3a87			if DEBUG_FORTH_WORDS 
3a87				DMARK "A?2" 
3a87 f5				push af  
3a88 3a 9c 3a			ld a, (.dmark)  
3a8b 32 bd fb			ld (debug_mark),a  
3a8e 3a 9d 3a			ld a, (.dmark+1)  
3a91 32 be fb			ld (debug_mark+1),a  
3a94 3a 9e 3a			ld a, (.dmark+2)  
3a97 32 bf fb			ld (debug_mark+2),a  
3a9a 18 03			jr .pastdmark  
3a9c ..			.dmark: db "A?2"  
3a9f f1			.pastdmark: pop af  
3aa0			endm  
# End of macro DMARK
3aa0				CALLMONITOR 
3aa0 cd 47 17			call break_point_state  
3aa3				endm  
# End of macro CALLMONITOR
3aa3			endif	 
3aa3 26 00				ld h, 0 
3aa5 69					ld l, c 
3aa6 cd d7 1c				call forth_push_numhl 
3aa9 68					ld l, b  
3aaa cd d7 1c				call forth_push_numhl 
3aad			 
3aad			 
3aad				NEXTW 
3aad c3 40 20			jp macro_next 
3ab0				endm 
# End of macro NEXTW
3ab0			 
3ab0			.FB: 
3ab0				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ab0 1b				db WORD_SYS_CORE+7             
3ab1 fe 3a			dw .EMIT            
3ab3 03				db 2 + 1 
3ab4 .. 00			db "FB",0              
3ab7				endm 
# End of macro CWHEAD
3ab7			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ab7			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ab7			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ab7			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ab7					if DEBUG_FORTH_WORDS_KEY 
3ab7						DMARK "FB." 
3ab7 f5				push af  
3ab8 3a cc 3a			ld a, (.dmark)  
3abb 32 bd fb			ld (debug_mark),a  
3abe 3a cd 3a			ld a, (.dmark+1)  
3ac1 32 be fb			ld (debug_mark+1),a  
3ac4 3a ce 3a			ld a, (.dmark+2)  
3ac7 32 bf fb			ld (debug_mark+2),a  
3aca 18 03			jr .pastdmark  
3acc ..			.dmark: db "FB."  
3acf f1			.pastdmark: pop af  
3ad0			endm  
# End of macro DMARK
3ad0						CALLMONITOR 
3ad0 cd 47 17			call break_point_state  
3ad3				endm  
# End of macro CALLMONITOR
3ad3					endif 
3ad3			 
3ad3					FORTH_DSP_VALUEHL 
3ad3 cd ce 1e			call macro_dsp_valuehl 
3ad6				endm 
# End of macro FORTH_DSP_VALUEHL
3ad6			 
3ad6 7d					ld a, l 
3ad7 fe 01				cp 1 
3ad9 20 05				jr nz, .fbn1 
3adb 21 02 fb				ld hl, display_fb1 
3ade 18 15				jr .fbset 
3ae0 fe 02		.fbn1:		cp 2 
3ae2 20 05				jr nz, .fbn2 
3ae4 21 60 fa				ld hl, display_fb2 
3ae7 18 0c				jr .fbset 
3ae9 fe 03		.fbn2:		cp 3 
3aeb 20 05				jr nz, .fbn3 
3aed 21 b1 fa				ld hl, display_fb3 
3af0 18 03				jr .fbset 
3af2			.fbn3:		 ; if invalid number select first 
3af2 21 02 fb				ld hl, display_fb1 
3af5 22 5e fa		.fbset:		ld (display_fb_active), hl 
3af8			 
3af8					FORTH_DSP_POP 
3af8 cd 86 1f			call macro_forth_dsp_pop 
3afb				endm 
# End of macro FORTH_DSP_POP
3afb			 
3afb					NEXTW 
3afb c3 40 20			jp macro_next 
3afe				endm 
# End of macro NEXTW
3afe			 
3afe			 
3afe			.EMIT: 
3afe				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3afe 1b				db WORD_SYS_CORE+7             
3aff 4f 3b			dw .DOTH            
3b01 05				db 4 + 1 
3b02 .. 00			db "EMIT",0              
3b07				endm 
# End of macro CWHEAD
3b07			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b07					; get value off TOS and display it 
3b07			 
3b07					if DEBUG_FORTH_WORDS_KEY 
3b07						DMARK "EMT" 
3b07 f5				push af  
3b08 3a 1c 3b			ld a, (.dmark)  
3b0b 32 bd fb			ld (debug_mark),a  
3b0e 3a 1d 3b			ld a, (.dmark+1)  
3b11 32 be fb			ld (debug_mark+1),a  
3b14 3a 1e 3b			ld a, (.dmark+2)  
3b17 32 bf fb			ld (debug_mark+2),a  
3b1a 18 03			jr .pastdmark  
3b1c ..			.dmark: db "EMT"  
3b1f f1			.pastdmark: pop af  
3b20			endm  
# End of macro DMARK
3b20						CALLMONITOR 
3b20 cd 47 17			call break_point_state  
3b23				endm  
# End of macro CALLMONITOR
3b23					endif 
3b23			 
3b23					FORTH_DSP_VALUEHL 
3b23 cd ce 1e			call macro_dsp_valuehl 
3b26				endm 
# End of macro FORTH_DSP_VALUEHL
3b26			 
3b26 7d					ld a,l 
3b27			 
3b27					; TODO write to display 
3b27			 
3b27 32 a1 f1				ld (os_input), a 
3b2a 3e 00				ld a, 0 
3b2c 32 a2 f1				ld (os_input+1), a 
3b2f					 
3b2f 3a cc f9				ld a, (f_cursor_ptr) 
3b32 11 a1 f1				ld de, os_input 
3b35 cd fc 0a				call str_at_display 
3b38			 
3b38			 
3b38 3a aa f9				ld a,(cli_autodisplay) 
3b3b fe 00				cp 0 
3b3d 28 03				jr z, .enoupdate 
3b3f cd 0c 0b						call update_display 
3b42					.enoupdate: 
3b42			 
3b42 3a cc f9				ld a, (f_cursor_ptr) 
3b45 3c					inc a 
3b46 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3b49			 
3b49			 
3b49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b49 cd 86 1f			call macro_forth_dsp_pop 
3b4c				endm 
# End of macro FORTH_DSP_POP
3b4c			  
3b4c			 
3b4c					NEXTW 
3b4c c3 40 20			jp macro_next 
3b4f				endm 
# End of macro NEXTW
3b4f			.DOTH: 
3b4f				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b4f 1c				db WORD_SYS_CORE+8             
3b50 7f 3b			dw .DOTF            
3b52 03				db 2 + 1 
3b53 .. 00			db ".-",0              
3b56				endm 
# End of macro CWHEAD
3b56			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b56					; get value off TOS and display it 
3b56					if DEBUG_FORTH_WORDS_KEY 
3b56						DMARK "DTD" 
3b56 f5				push af  
3b57 3a 6b 3b			ld a, (.dmark)  
3b5a 32 bd fb			ld (debug_mark),a  
3b5d 3a 6c 3b			ld a, (.dmark+1)  
3b60 32 be fb			ld (debug_mark+1),a  
3b63 3a 6d 3b			ld a, (.dmark+2)  
3b66 32 bf fb			ld (debug_mark+2),a  
3b69 18 03			jr .pastdmark  
3b6b ..			.dmark: db "DTD"  
3b6e f1			.pastdmark: pop af  
3b6f			endm  
# End of macro DMARK
3b6f						CALLMONITOR 
3b6f cd 47 17			call break_point_state  
3b72				endm  
# End of macro CALLMONITOR
3b72					endif 
3b72 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b74 3e 00			ld a, 0 
3b76 32 ab f9			ld (cli_mvdot), a 
3b79 c3 d6 3b			jp .dotgo 
3b7c				NEXTW 
3b7c c3 40 20			jp macro_next 
3b7f				endm 
# End of macro NEXTW
3b7f			.DOTF: 
3b7f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b7f 1c				db WORD_SYS_CORE+8             
3b80 ad 3b			dw .DOT            
3b82 03				db 2 + 1 
3b83 .. 00			db ".>",0              
3b86				endm 
# End of macro CWHEAD
3b86			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b86					; get value off TOS and display it 
3b86			        ; TODO BUG adds extra spaces 
3b86			        ; TODO BUG handle numerics? 
3b86					if DEBUG_FORTH_WORDS_KEY 
3b86						DMARK "DTC" 
3b86 f5				push af  
3b87 3a 9b 3b			ld a, (.dmark)  
3b8a 32 bd fb			ld (debug_mark),a  
3b8d 3a 9c 3b			ld a, (.dmark+1)  
3b90 32 be fb			ld (debug_mark+1),a  
3b93 3a 9d 3b			ld a, (.dmark+2)  
3b96 32 bf fb			ld (debug_mark+2),a  
3b99 18 03			jr .pastdmark  
3b9b ..			.dmark: db "DTC"  
3b9e f1			.pastdmark: pop af  
3b9f			endm  
# End of macro DMARK
3b9f						CALLMONITOR 
3b9f cd 47 17			call break_point_state  
3ba2				endm  
# End of macro CALLMONITOR
3ba2					endif 
3ba2 3e 01			ld a, 1 
3ba4 32 ab f9			ld (cli_mvdot), a 
3ba7 c3 d6 3b			jp .dotgo 
3baa				NEXTW 
3baa c3 40 20			jp macro_next 
3bad				endm 
# End of macro NEXTW
3bad			 
3bad			.DOT: 
3bad				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bad 1c				db WORD_SYS_CORE+8             
3bae 39 3c			dw .CLS            
3bb0 02				db 1 + 1 
3bb1 .. 00			db ".",0              
3bb3				endm 
# End of macro CWHEAD
3bb3			        ; | . ( u -- ) Display TOS | DONE 
3bb3					; get value off TOS and display it 
3bb3			 
3bb3					if DEBUG_FORTH_WORDS_KEY 
3bb3						DMARK "DOT" 
3bb3 f5				push af  
3bb4 3a c8 3b			ld a, (.dmark)  
3bb7 32 bd fb			ld (debug_mark),a  
3bba 3a c9 3b			ld a, (.dmark+1)  
3bbd 32 be fb			ld (debug_mark+1),a  
3bc0 3a ca 3b			ld a, (.dmark+2)  
3bc3 32 bf fb			ld (debug_mark+2),a  
3bc6 18 03			jr .pastdmark  
3bc8 ..			.dmark: db "DOT"  
3bcb f1			.pastdmark: pop af  
3bcc			endm  
# End of macro DMARK
3bcc						CALLMONITOR 
3bcc cd 47 17			call break_point_state  
3bcf				endm  
# End of macro CALLMONITOR
3bcf					endif 
3bcf 3e 00			ld a, 0 
3bd1 32 ab f9			ld (cli_mvdot), a 
3bd4 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bd6				 
3bd6			 
3bd6			.dotgo: 
3bd6			 
3bd6			; move up type to on stack for parserv5 
3bd6					FORTH_DSP 
3bd6 cd 94 1e			call macro_forth_dsp 
3bd9				endm 
# End of macro FORTH_DSP
3bd9				;FORTH_DSP_VALUE  
3bd9			 
3bd9			if DEBUG_FORTH_DOT 
3bd9				DMARK "DOT" 
3bd9				CALLMONITOR 
3bd9			endif	 
3bd9			;		.print: 
3bd9			 
3bd9 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3bda 23				inc hl   ; position to the actual value 
3bdb fe 01			cp DS_TYPE_STR 
3bdd 20 06			jr nz, .dotnum1  
3bdf			 
3bdf			; display string 
3bdf				FORTH_DSP_VALUE  
3bdf cd b7 1e			call macro_forth_dsp_value 
3be2				endm 
# End of macro FORTH_DSP_VALUE
3be2 eb				ex de,hl 
3be3 18 11			jr .dotwrite 
3be5			 
3be5			.dotnum1: 
3be5 fe 02			cp DS_TYPE_INUM 
3be7 20 0c			jr nz, .dotflot 
3be9			 
3be9			 
3be9			; display number 
3be9			 
3be9			;	push hl 
3be9			;	call clear_display 
3be9			;	pop hl 
3be9			 
3be9 5e				ld e, (hl) 
3bea 23				inc hl 
3beb 56				ld d, (hl) 
3bec 21 a3 ef			ld hl, scratch 
3bef			if DEBUG_FORTH_DOT 
3bef				DMARK "DT1" 
3bef				CALLMONITOR 
3bef			endif	 
3bef			 
3bef cd 2a 11			call uitoa_16 
3bf2 eb				ex de,hl 
3bf3			 
3bf3			if DEBUG_FORTH_DOT 
3bf3				DMARK "DT2" 
3bf3				CALLMONITOR 
3bf3			endif	 
3bf3			 
3bf3			;	ld de, os_word_scratch 
3bf3 18 01			jr .dotwrite 
3bf5			 
3bf5 00			.dotflot:   nop 
3bf6			; TODO print floating point number 
3bf6			 
3bf6			.dotwrite:		 
3bf6			 
3bf6					; if c is set then set all '-' to spaces 
3bf6					; need to also take into account .>  
3bf6			 
3bf6 3e 01				ld a, 1 
3bf8 b9					cp c 
3bf9 20 13				jr nz, .nodashswap 
3bfb			 
3bfb					; DE has the string to write, working with HL 
3bfb			 
3bfb 06 ff				ld b, 255 
3bfd d5					push de 
3bfe e1					pop hl 
3bff			 
3bff			if DEBUG_FORTH_DOT 
3bff				DMARK "DT-" 
3bff				CALLMONITOR 
3bff			endif	 
3bff 7e			.dashscan:	ld a, (hl) 
3c00 fe 00				cp 0 
3c02 28 0a				jr z, .nodashswap 
3c04 fe 2d				cp '-' 
3c06 20 03				jr nz, .dashskip 
3c08 3e 20				ld a, ' ' 
3c0a 77					ld (hl), a 
3c0b 23			.dashskip:	inc hl 
3c0c			if DEBUG_FORTH_DOT 
3c0c				DMARK "D-2" 
3c0c				CALLMONITOR 
3c0c			endif	 
3c0c 10 f1				djnz .dashscan 
3c0e			 
3c0e			if DEBUG_FORTH_DOT 
3c0e				DMARK "D-1" 
3c0e				CALLMONITOR 
3c0e			endif	 
3c0e			 
3c0e			.nodashswap: 
3c0e			 
3c0e e5					push hl   ; save string start in case we need to advance print 
3c0f			 
3c0f 3a cc f9				ld a, (f_cursor_ptr) 
3c12 cd fc 0a				call str_at_display 
3c15 3a aa f9				ld a,(cli_autodisplay) 
3c18 fe 00				cp 0 
3c1a 28 03				jr z, .noupdate 
3c1c cd 0c 0b						call update_display 
3c1f					.noupdate: 
3c1f			 
3c1f			 
3c1f					; see if we need to advance the print position 
3c1f			 
3c1f e1					pop hl   ; get back string 
3c20			 
3c20 3a ab f9				ld a, (cli_mvdot) 
3c23			if DEBUG_FORTH_DOT 
3c23					ld e,a 
3c23				DMARK "D>1" 
3c23				CALLMONITOR 
3c23			endif	 
3c23 fe 00				cp 0 
3c25 28 0c				jr z, .noadv 
3c27					; yes, lets advance the print position 
3c27 3e 00				ld a, 0 
3c29 cd 86 11				call strlent 
3c2c 3a cc f9				ld a, (f_cursor_ptr) 
3c2f 85					add a,l 
3c30					;call addatohl 
3c30					;ld a, l 
3c30 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3c33			 
3c33			if DEBUG_FORTH_DOT 
3c33				DMARK "D->" 
3c33				CALLMONITOR 
3c33			endif	 
3c33			 
3c33			.noadv:	 
3c33			 
3c33					if DEBUG_FORTH_DOT_WAIT 
3c33							call next_page_prompt 
3c33					endif	 
3c33			; TODO this pop off the stack causes a crash. i dont know why 
3c33			 
3c33			 
3c33			if DEBUG_FORTH_DOT 
3c33				DMARK "DTh" 
3c33				CALLMONITOR 
3c33			endif	 
3c33			 
3c33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c33 cd 86 1f			call macro_forth_dsp_pop 
3c36				endm 
# End of macro FORTH_DSP_POP
3c36			 
3c36			if DEBUG_FORTH_DOT 
3c36				DMARK "DTi" 
3c36				CALLMONITOR 
3c36			endif	 
3c36			 
3c36			 
3c36					NEXTW 
3c36 c3 40 20			jp macro_next 
3c39				endm 
# End of macro NEXTW
3c39			 
3c39			.CLS: 
3c39				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c39 35				db WORD_SYS_CORE+33             
3c3a 66 3c			dw .DRAW            
3c3c 04				db 3 + 1 
3c3d .. 00			db "CLS",0              
3c41				endm 
# End of macro CWHEAD
3c41			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c41					if DEBUG_FORTH_WORDS_KEY 
3c41						DMARK "CLS" 
3c41 f5				push af  
3c42 3a 56 3c			ld a, (.dmark)  
3c45 32 bd fb			ld (debug_mark),a  
3c48 3a 57 3c			ld a, (.dmark+1)  
3c4b 32 be fb			ld (debug_mark+1),a  
3c4e 3a 58 3c			ld a, (.dmark+2)  
3c51 32 bf fb			ld (debug_mark+2),a  
3c54 18 03			jr .pastdmark  
3c56 ..			.dmark: db "CLS"  
3c59 f1			.pastdmark: pop af  
3c5a			endm  
# End of macro DMARK
3c5a						CALLMONITOR 
3c5a cd 47 17			call break_point_state  
3c5d				endm  
# End of macro CALLMONITOR
3c5d					endif 
3c5d cd e9 0a				call clear_display 
3c60 c3 74 3d				jp .home		; and home cursor 
3c63					NEXTW 
3c63 c3 40 20			jp macro_next 
3c66				endm 
# End of macro NEXTW
3c66			 
3c66			.DRAW: 
3c66				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c66 36				db WORD_SYS_CORE+34             
3c67 91 3c			dw .DUMP            
3c69 05				db 4 + 1 
3c6a .. 00			db "DRAW",0              
3c6f				endm 
# End of macro CWHEAD
3c6f			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c6f					if DEBUG_FORTH_WORDS_KEY 
3c6f						DMARK "DRW" 
3c6f f5				push af  
3c70 3a 84 3c			ld a, (.dmark)  
3c73 32 bd fb			ld (debug_mark),a  
3c76 3a 85 3c			ld a, (.dmark+1)  
3c79 32 be fb			ld (debug_mark+1),a  
3c7c 3a 86 3c			ld a, (.dmark+2)  
3c7f 32 bf fb			ld (debug_mark+2),a  
3c82 18 03			jr .pastdmark  
3c84 ..			.dmark: db "DRW"  
3c87 f1			.pastdmark: pop af  
3c88			endm  
# End of macro DMARK
3c88						CALLMONITOR 
3c88 cd 47 17			call break_point_state  
3c8b				endm  
# End of macro CALLMONITOR
3c8b					endif 
3c8b cd 0c 0b				call update_display 
3c8e					NEXTW 
3c8e c3 40 20			jp macro_next 
3c91				endm 
# End of macro NEXTW
3c91			 
3c91			.DUMP: 
3c91				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c91 37				db WORD_SYS_CORE+35             
3c92 c9 3c			dw .CDUMP            
3c94 05				db 4 + 1 
3c95 .. 00			db "DUMP",0              
3c9a				endm 
# End of macro CWHEAD
3c9a			; | DUMP ( x -- ) With address x display dump   | DONE 
3c9a			; TODO pop address to use off of the stack 
3c9a					if DEBUG_FORTH_WORDS_KEY 
3c9a						DMARK "DUM" 
3c9a f5				push af  
3c9b 3a af 3c			ld a, (.dmark)  
3c9e 32 bd fb			ld (debug_mark),a  
3ca1 3a b0 3c			ld a, (.dmark+1)  
3ca4 32 be fb			ld (debug_mark+1),a  
3ca7 3a b1 3c			ld a, (.dmark+2)  
3caa 32 bf fb			ld (debug_mark+2),a  
3cad 18 03			jr .pastdmark  
3caf ..			.dmark: db "DUM"  
3cb2 f1			.pastdmark: pop af  
3cb3			endm  
# End of macro DMARK
3cb3						CALLMONITOR 
3cb3 cd 47 17			call break_point_state  
3cb6				endm  
# End of macro CALLMONITOR
3cb6					endif 
3cb6 cd e9 0a				call clear_display 
3cb9			 
3cb9					; get address 
3cb9			 
3cb9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cb9 cd ce 1e			call macro_dsp_valuehl 
3cbc				endm 
# End of macro FORTH_DSP_VALUEHL
3cbc				 
3cbc					; save it for cdump 
3cbc			 
3cbc 22 c6 f2				ld (os_cur_ptr),hl 
3cbf			 
3cbf					; destroy value TOS 
3cbf			 
3cbf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cbf cd 86 1f			call macro_forth_dsp_pop 
3cc2				endm 
# End of macro FORTH_DSP_POP
3cc2			 
3cc2 cd 57 1b				call dumpcont	; skip old style of param parsing	 
3cc5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3cc6					NEXTW 
3cc6 c3 40 20			jp macro_next 
3cc9				endm 
# End of macro NEXTW
3cc9			.CDUMP: 
3cc9				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3cc9 38				db WORD_SYS_CORE+36             
3cca f9 3c			dw .DAT            
3ccc 06				db 5 + 1 
3ccd .. 00			db "CDUMP",0              
3cd3				endm 
# End of macro CWHEAD
3cd3			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3cd3					if DEBUG_FORTH_WORDS_KEY 
3cd3						DMARK "CDP" 
3cd3 f5				push af  
3cd4 3a e8 3c			ld a, (.dmark)  
3cd7 32 bd fb			ld (debug_mark),a  
3cda 3a e9 3c			ld a, (.dmark+1)  
3cdd 32 be fb			ld (debug_mark+1),a  
3ce0 3a ea 3c			ld a, (.dmark+2)  
3ce3 32 bf fb			ld (debug_mark+2),a  
3ce6 18 03			jr .pastdmark  
3ce8 ..			.dmark: db "CDP"  
3ceb f1			.pastdmark: pop af  
3cec			endm  
# End of macro DMARK
3cec						CALLMONITOR 
3cec cd 47 17			call break_point_state  
3cef				endm  
# End of macro CALLMONITOR
3cef					endif 
3cef cd e9 0a				call clear_display 
3cf2 cd 57 1b				call dumpcont	 
3cf5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3cf6					NEXTW 
3cf6 c3 40 20			jp macro_next 
3cf9				endm 
# End of macro NEXTW
3cf9			 
3cf9			 
3cf9			 
3cf9			 
3cf9			.DAT: 
3cf9				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3cf9 3d				db WORD_SYS_CORE+41             
3cfa 4f 3d			dw .HOME            
3cfc 03				db 2 + 1 
3cfd .. 00			db "AT",0              
3d00				endm 
# End of macro CWHEAD
3d00			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d00					if DEBUG_FORTH_WORDS_KEY 
3d00						DMARK "AT." 
3d00 f5				push af  
3d01 3a 15 3d			ld a, (.dmark)  
3d04 32 bd fb			ld (debug_mark),a  
3d07 3a 16 3d			ld a, (.dmark+1)  
3d0a 32 be fb			ld (debug_mark+1),a  
3d0d 3a 17 3d			ld a, (.dmark+2)  
3d10 32 bf fb			ld (debug_mark+2),a  
3d13 18 03			jr .pastdmark  
3d15 ..			.dmark: db "AT."  
3d18 f1			.pastdmark: pop af  
3d19			endm  
# End of macro DMARK
3d19						CALLMONITOR 
3d19 cd 47 17			call break_point_state  
3d1c				endm  
# End of macro CALLMONITOR
3d1c					endif 
3d1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d1c cd ce 1e			call macro_dsp_valuehl 
3d1f				endm 
# End of macro FORTH_DSP_VALUEHL
3d1f			 
3d1f			 
3d1f					; TODO save cursor row 
3d1f 7d					ld a,l 
3d20 fe 02				cp 2 
3d22 20 04				jr nz, .crow3 
3d24 3e 14				ld a, display_row_2 
3d26 18 12				jr .ccol1 
3d28 fe 03		.crow3:		cp 3 
3d2a 20 04				jr nz, .crow4 
3d2c 3e 28				ld a, display_row_3 
3d2e 18 0a				jr .ccol1 
3d30 fe 04		.crow4:		cp 4 
3d32 20 04				jr nz, .crow1 
3d34 3e 3c				ld a, display_row_4 
3d36 18 02				jr .ccol1 
3d38 3e 00		.crow1:		ld a,display_row_1 
3d3a f5			.ccol1:		push af			; got row offset 
3d3b 6f					ld l,a 
3d3c 26 00				ld h,0 
3d3e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d3e cd 86 1f			call macro_forth_dsp_pop 
3d41				endm 
# End of macro FORTH_DSP_POP
3d41					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d41 cd ce 1e			call macro_dsp_valuehl 
3d44				endm 
# End of macro FORTH_DSP_VALUEHL
3d44					; TODO save cursor col 
3d44 f1					pop af 
3d45 85					add l		; add col offset 
3d46 32 cc f9				ld (f_cursor_ptr), a 
3d49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d49 cd 86 1f			call macro_forth_dsp_pop 
3d4c				endm 
# End of macro FORTH_DSP_POP
3d4c			 
3d4c					; calculate  
3d4c			 
3d4c					NEXTW 
3d4c c3 40 20			jp macro_next 
3d4f				endm 
# End of macro NEXTW
3d4f			 
3d4f			 
3d4f			.HOME: 
3d4f				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d4f 41				db WORD_SYS_CORE+45             
3d50 7c 3d			dw .SPACE            
3d52 05				db 4 + 1 
3d53 .. 00			db "HOME",0              
3d58				endm 
# End of macro CWHEAD
3d58			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d58					if DEBUG_FORTH_WORDS_KEY 
3d58						DMARK "HOM" 
3d58 f5				push af  
3d59 3a 6d 3d			ld a, (.dmark)  
3d5c 32 bd fb			ld (debug_mark),a  
3d5f 3a 6e 3d			ld a, (.dmark+1)  
3d62 32 be fb			ld (debug_mark+1),a  
3d65 3a 6f 3d			ld a, (.dmark+2)  
3d68 32 bf fb			ld (debug_mark+2),a  
3d6b 18 03			jr .pastdmark  
3d6d ..			.dmark: db "HOM"  
3d70 f1			.pastdmark: pop af  
3d71			endm  
# End of macro DMARK
3d71						CALLMONITOR 
3d71 cd 47 17			call break_point_state  
3d74				endm  
# End of macro CALLMONITOR
3d74					endif 
3d74 3e 00		.home:		ld a, 0		; and home cursor 
3d76 32 cc f9				ld (f_cursor_ptr), a 
3d79					NEXTW 
3d79 c3 40 20			jp macro_next 
3d7c				endm 
# End of macro NEXTW
3d7c			 
3d7c			 
3d7c			.SPACE: 
3d7c				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d7c 46				db WORD_SYS_CORE+50             
3d7d aa 3d			dw .SPACES            
3d7f 03				db 2 + 1 
3d80 .. 00			db "BL",0              
3d83				endm 
# End of macro CWHEAD
3d83			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d83					if DEBUG_FORTH_WORDS_KEY 
3d83						DMARK "BL." 
3d83 f5				push af  
3d84 3a 98 3d			ld a, (.dmark)  
3d87 32 bd fb			ld (debug_mark),a  
3d8a 3a 99 3d			ld a, (.dmark+1)  
3d8d 32 be fb			ld (debug_mark+1),a  
3d90 3a 9a 3d			ld a, (.dmark+2)  
3d93 32 bf fb			ld (debug_mark+2),a  
3d96 18 03			jr .pastdmark  
3d98 ..			.dmark: db "BL."  
3d9b f1			.pastdmark: pop af  
3d9c			endm  
# End of macro DMARK
3d9c						CALLMONITOR 
3d9c cd 47 17			call break_point_state  
3d9f				endm  
# End of macro CALLMONITOR
3d9f					endif 
3d9f 21 a8 3d				ld hl, .blstr 
3da2 cd 45 1d				call forth_push_str 
3da5					 
3da5				       NEXTW 
3da5 c3 40 20			jp macro_next 
3da8				endm 
# End of macro NEXTW
3da8			 
3da8 .. 00		.blstr: db " ", 0 
3daa			 
3daa			.SPACES: 
3daa				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3daa 47				db WORD_SYS_CORE+51             
3dab 45 3e			dw .SCROLL            
3dad 07				db 6 + 1 
3dae .. 00			db "SPACES",0              
3db5				endm 
# End of macro CWHEAD
3db5			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3db5					if DEBUG_FORTH_WORDS_KEY 
3db5						DMARK "SPS" 
3db5 f5				push af  
3db6 3a ca 3d			ld a, (.dmark)  
3db9 32 bd fb			ld (debug_mark),a  
3dbc 3a cb 3d			ld a, (.dmark+1)  
3dbf 32 be fb			ld (debug_mark+1),a  
3dc2 3a cc 3d			ld a, (.dmark+2)  
3dc5 32 bf fb			ld (debug_mark+2),a  
3dc8 18 03			jr .pastdmark  
3dca ..			.dmark: db "SPS"  
3dcd f1			.pastdmark: pop af  
3dce			endm  
# End of macro DMARK
3dce						CALLMONITOR 
3dce cd 47 17			call break_point_state  
3dd1				endm  
# End of macro CALLMONITOR
3dd1					endif 
3dd1			 
3dd1			 
3dd1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dd1 cd ce 1e			call macro_dsp_valuehl 
3dd4				endm 
# End of macro FORTH_DSP_VALUEHL
3dd4			 
3dd4			;		push hl    ; u 
3dd4					if DEBUG_FORTH_WORDS 
3dd4						DMARK "SPA" 
3dd4 f5				push af  
3dd5 3a e9 3d			ld a, (.dmark)  
3dd8 32 bd fb			ld (debug_mark),a  
3ddb 3a ea 3d			ld a, (.dmark+1)  
3dde 32 be fb			ld (debug_mark+1),a  
3de1 3a eb 3d			ld a, (.dmark+2)  
3de4 32 bf fb			ld (debug_mark+2),a  
3de7 18 03			jr .pastdmark  
3de9 ..			.dmark: db "SPA"  
3dec f1			.pastdmark: pop af  
3ded			endm  
# End of macro DMARK
3ded						CALLMONITOR 
3ded cd 47 17			call break_point_state  
3df0				endm  
# End of macro CALLMONITOR
3df0					endif 
3df0			 
3df0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3df0 cd 86 1f			call macro_forth_dsp_pop 
3df3				endm 
# End of macro FORTH_DSP_POP
3df3			;		pop hl 
3df3 4d					ld c, l 
3df4 06 00				ld b, 0 
3df6 21 a3 ef				ld hl, scratch  
3df9			 
3df9					if DEBUG_FORTH_WORDS 
3df9						DMARK "SP2" 
3df9 f5				push af  
3dfa 3a 0e 3e			ld a, (.dmark)  
3dfd 32 bd fb			ld (debug_mark),a  
3e00 3a 0f 3e			ld a, (.dmark+1)  
3e03 32 be fb			ld (debug_mark+1),a  
3e06 3a 10 3e			ld a, (.dmark+2)  
3e09 32 bf fb			ld (debug_mark+2),a  
3e0c 18 03			jr .pastdmark  
3e0e ..			.dmark: db "SP2"  
3e11 f1			.pastdmark: pop af  
3e12			endm  
# End of macro DMARK
3e12						CALLMONITOR 
3e12 cd 47 17			call break_point_state  
3e15				endm  
# End of macro CALLMONITOR
3e15					endif 
3e15 3e 20				ld a, ' ' 
3e17 c5			.spaces1:	push bc 
3e18 77					ld (hl),a 
3e19 23					inc hl 
3e1a c1					pop bc 
3e1b 10 fa				djnz .spaces1 
3e1d 3e 00				ld a,0 
3e1f 77					ld (hl),a 
3e20 21 a3 ef				ld hl, scratch 
3e23					if DEBUG_FORTH_WORDS 
3e23						DMARK "SP3" 
3e23 f5				push af  
3e24 3a 38 3e			ld a, (.dmark)  
3e27 32 bd fb			ld (debug_mark),a  
3e2a 3a 39 3e			ld a, (.dmark+1)  
3e2d 32 be fb			ld (debug_mark+1),a  
3e30 3a 3a 3e			ld a, (.dmark+2)  
3e33 32 bf fb			ld (debug_mark+2),a  
3e36 18 03			jr .pastdmark  
3e38 ..			.dmark: db "SP3"  
3e3b f1			.pastdmark: pop af  
3e3c			endm  
# End of macro DMARK
3e3c						CALLMONITOR 
3e3c cd 47 17			call break_point_state  
3e3f				endm  
# End of macro CALLMONITOR
3e3f					endif 
3e3f cd 40 1e				call forth_apush 
3e42			 
3e42				       NEXTW 
3e42 c3 40 20			jp macro_next 
3e45				endm 
# End of macro NEXTW
3e45			 
3e45			 
3e45			 
3e45			.SCROLL: 
3e45				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e45 53				db WORD_SYS_CORE+63             
3e46 72 3e			dw .SCROLLD            
3e48 07				db 6 + 1 
3e49 .. 00			db "SCROLL",0              
3e50				endm 
# End of macro CWHEAD
3e50			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e50					if DEBUG_FORTH_WORDS_KEY 
3e50						DMARK "SCR" 
3e50 f5				push af  
3e51 3a 65 3e			ld a, (.dmark)  
3e54 32 bd fb			ld (debug_mark),a  
3e57 3a 66 3e			ld a, (.dmark+1)  
3e5a 32 be fb			ld (debug_mark+1),a  
3e5d 3a 67 3e			ld a, (.dmark+2)  
3e60 32 bf fb			ld (debug_mark+2),a  
3e63 18 03			jr .pastdmark  
3e65 ..			.dmark: db "SCR"  
3e68 f1			.pastdmark: pop af  
3e69			endm  
# End of macro DMARK
3e69						CALLMONITOR 
3e69 cd 47 17			call break_point_state  
3e6c				endm  
# End of macro CALLMONITOR
3e6c					endif 
3e6c			 
3e6c cd ab 0a			call scroll_up 
3e6f			;	call update_display 
3e6f			 
3e6f					NEXTW 
3e6f c3 40 20			jp macro_next 
3e72				endm 
# End of macro NEXTW
3e72			 
3e72			 
3e72			 
3e72			;		; get dir 
3e72			; 
3e72			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e72			; 
3e72			;		push hl 
3e72			; 
3e72			;		; destroy value TOS 
3e72			; 
3e72			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e72			; 
3e72			;		; get count 
3e72			; 
3e72			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e72			; 
3e72			;		push hl 
3e72			; 
3e72			;		; destroy value TOS 
3e72			; 
3e72			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e72			; 
3e72			;		; one value on hl get other one back 
3e72			; 
3e72			;		pop bc    ; count 
3e72			; 
3e72			;		pop de   ; dir 
3e72			; 
3e72			; 
3e72			;		ld b, c 
3e72			; 
3e72			;.scrolldir:     push bc 
3e72			;		push de 
3e72			; 
3e72			;		ld a, 0 
3e72			;		cp e 
3e72			;		jr z, .scrollup  
3e72			;		call scroll_down 
3e72			;		jr .scrollnext 
3e72			;.scrollup:	call scroll_up 
3e72			; 
3e72			;		 
3e72			;.scrollnext: 
3e72			;		pop de 
3e72			;		pop bc 
3e72			;		djnz .scrolldir 
3e72			; 
3e72			; 
3e72			; 
3e72			; 
3e72			; 
3e72			;		NEXTW 
3e72			 
3e72			.SCROLLD: 
3e72				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e72 53				db WORD_SYS_CORE+63             
3e73 a0 3e			dw .ATQ            
3e75 08				db 7 + 1 
3e76 .. 00			db "SCROLLD",0              
3e7e				endm 
# End of macro CWHEAD
3e7e			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e7e					if DEBUG_FORTH_WORDS_KEY 
3e7e						DMARK "SCD" 
3e7e f5				push af  
3e7f 3a 93 3e			ld a, (.dmark)  
3e82 32 bd fb			ld (debug_mark),a  
3e85 3a 94 3e			ld a, (.dmark+1)  
3e88 32 be fb			ld (debug_mark+1),a  
3e8b 3a 95 3e			ld a, (.dmark+2)  
3e8e 32 bf fb			ld (debug_mark+2),a  
3e91 18 03			jr .pastdmark  
3e93 ..			.dmark: db "SCD"  
3e96 f1			.pastdmark: pop af  
3e97			endm  
# End of macro DMARK
3e97						CALLMONITOR 
3e97 cd 47 17			call break_point_state  
3e9a				endm  
# End of macro CALLMONITOR
3e9a					endif 
3e9a			 
3e9a cd cf 0a			call scroll_down 
3e9d			;	call update_display 
3e9d			 
3e9d					NEXTW 
3e9d c3 40 20			jp macro_next 
3ea0				endm 
# End of macro NEXTW
3ea0			 
3ea0			 
3ea0			.ATQ: 
3ea0				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ea0 62				db WORD_SYS_CORE+78             
3ea1 fe 3e			dw .AUTODSP            
3ea3 04				db 3 + 1 
3ea4 .. 00			db "AT@",0              
3ea8				endm 
# End of macro CWHEAD
3ea8			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3ea8					if DEBUG_FORTH_WORDS_KEY 
3ea8						DMARK "ATA" 
3ea8 f5				push af  
3ea9 3a bd 3e			ld a, (.dmark)  
3eac 32 bd fb			ld (debug_mark),a  
3eaf 3a be 3e			ld a, (.dmark+1)  
3eb2 32 be fb			ld (debug_mark+1),a  
3eb5 3a bf 3e			ld a, (.dmark+2)  
3eb8 32 bf fb			ld (debug_mark+2),a  
3ebb 18 03			jr .pastdmark  
3ebd ..			.dmark: db "ATA"  
3ec0 f1			.pastdmark: pop af  
3ec1			endm  
# End of macro DMARK
3ec1						CALLMONITOR 
3ec1 cd 47 17			call break_point_state  
3ec4				endm  
# End of macro CALLMONITOR
3ec4					endif 
3ec4			 
3ec4			 
3ec4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ec4 cd ce 1e			call macro_dsp_valuehl 
3ec7				endm 
# End of macro FORTH_DSP_VALUEHL
3ec7			 
3ec7					; TODO save cursor row 
3ec7 7d					ld a,l 
3ec8 fe 02				cp 2 
3eca 20 04				jr nz, .crow3aq 
3ecc 3e 14				ld a, display_row_2 
3ece 18 12				jr .ccol1aq 
3ed0 fe 03		.crow3aq:		cp 3 
3ed2 20 04				jr nz, .crow4aq 
3ed4 3e 28				ld a, display_row_3 
3ed6 18 0a				jr .ccol1aq 
3ed8 fe 04		.crow4aq:		cp 4 
3eda 20 04				jr nz, .crow1aq 
3edc 3e 3c				ld a, display_row_4 
3ede 18 02				jr .ccol1aq 
3ee0 3e 00		.crow1aq:		ld a,display_row_1 
3ee2 f5			.ccol1aq:		push af			; got row offset 
3ee3 6f					ld l,a 
3ee4 26 00				ld h,0 
3ee6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee6 cd 86 1f			call macro_forth_dsp_pop 
3ee9				endm 
# End of macro FORTH_DSP_POP
3ee9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee9 cd ce 1e			call macro_dsp_valuehl 
3eec				endm 
# End of macro FORTH_DSP_VALUEHL
3eec					; TODO save cursor col 
3eec f1					pop af 
3eed 85					add l		; add col offset 
3eee			 
3eee					; add current frame buffer address 
3eee 2a 5e fa				ld hl, (display_fb_active) 
3ef1 cd 1d 0d				call addatohl 
3ef4			 
3ef4			 
3ef4			 
3ef4			 
3ef4					; get char frame buffer location offset in hl 
3ef4			 
3ef4 7e					ld a,(hl) 
3ef5 26 00				ld h, 0 
3ef7 6f					ld l, a 
3ef8			 
3ef8 cd d7 1c				call forth_push_numhl 
3efb			 
3efb			 
3efb					NEXTW 
3efb c3 40 20			jp macro_next 
3efe				endm 
# End of macro NEXTW
3efe			 
3efe			.AUTODSP: 
3efe				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3efe 63				db WORD_SYS_CORE+79             
3eff 14 3f			dw .MENU            
3f01 05				db 4 + 1 
3f02 .. 00			db "ADSP",0              
3f07				endm 
# End of macro CWHEAD
3f07			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f07			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f07			 
3f07					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f07 cd ce 1e			call macro_dsp_valuehl 
3f0a				endm 
# End of macro FORTH_DSP_VALUEHL
3f0a			 
3f0a			;		push hl 
3f0a			 
3f0a					; destroy value TOS 
3f0a			 
3f0a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f0a cd 86 1f			call macro_forth_dsp_pop 
3f0d				endm 
# End of macro FORTH_DSP_POP
3f0d			 
3f0d			;		pop hl 
3f0d			 
3f0d 7d					ld a,l 
3f0e 32 aa f9				ld (cli_autodisplay), a 
3f11				       NEXTW 
3f11 c3 40 20			jp macro_next 
3f14				endm 
# End of macro NEXTW
3f14			 
3f14			.MENU: 
3f14				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f14 70				db WORD_SYS_CORE+92             
3f15 bd 3f			dw .ENDDISPLAY            
3f17 05				db 4 + 1 
3f18 .. 00			db "MENU",0              
3f1d				endm 
# End of macro CWHEAD
3f1d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f1d			 
3f1d			;		; get number of items on the stack 
3f1d			; 
3f1d				 
3f1d					FORTH_DSP_VALUEHL 
3f1d cd ce 1e			call macro_dsp_valuehl 
3f20				endm 
# End of macro FORTH_DSP_VALUEHL
3f20				 
3f20					if DEBUG_FORTH_WORDS_KEY 
3f20						DMARK "MNU" 
3f20 f5				push af  
3f21 3a 35 3f			ld a, (.dmark)  
3f24 32 bd fb			ld (debug_mark),a  
3f27 3a 36 3f			ld a, (.dmark+1)  
3f2a 32 be fb			ld (debug_mark+1),a  
3f2d 3a 37 3f			ld a, (.dmark+2)  
3f30 32 bf fb			ld (debug_mark+2),a  
3f33 18 03			jr .pastdmark  
3f35 ..			.dmark: db "MNU"  
3f38 f1			.pastdmark: pop af  
3f39			endm  
# End of macro DMARK
3f39						CALLMONITOR 
3f39 cd 47 17			call break_point_state  
3f3c				endm  
# End of macro CALLMONITOR
3f3c					endif 
3f3c			 
3f3c 45					ld b, l	 
3f3d 05					dec b 
3f3e			 
3f3e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f3e cd 86 1f			call macro_forth_dsp_pop 
3f41				endm 
# End of macro FORTH_DSP_POP
3f41			 
3f41			 
3f41					; go directly through the stack to pluck out the string pointers and build an array 
3f41			 
3f41			;		FORTH_DSP 
3f41			 
3f41					; hl contains top most stack item 
3f41				 
3f41 11 a3 ef				ld de, scratch 
3f44			 
3f44			.mbuild: 
3f44			 
3f44					FORTH_DSP_VALUEHL 
3f44 cd ce 1e			call macro_dsp_valuehl 
3f47				endm 
# End of macro FORTH_DSP_VALUEHL
3f47			 
3f47					if DEBUG_FORTH_WORDS 
3f47						DMARK "MN3" 
3f47 f5				push af  
3f48 3a 5c 3f			ld a, (.dmark)  
3f4b 32 bd fb			ld (debug_mark),a  
3f4e 3a 5d 3f			ld a, (.dmark+1)  
3f51 32 be fb			ld (debug_mark+1),a  
3f54 3a 5e 3f			ld a, (.dmark+2)  
3f57 32 bf fb			ld (debug_mark+2),a  
3f5a 18 03			jr .pastdmark  
3f5c ..			.dmark: db "MN3"  
3f5f f1			.pastdmark: pop af  
3f60			endm  
# End of macro DMARK
3f60						CALLMONITOR 
3f60 cd 47 17			call break_point_state  
3f63				endm  
# End of macro CALLMONITOR
3f63					endif 
3f63 eb					ex de, hl 
3f64 73					ld (hl), e 
3f65 23					inc hl 
3f66 72					ld (hl), d 
3f67 23					inc hl 
3f68 eb					ex de, hl 
3f69			 
3f69					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f69 cd 86 1f			call macro_forth_dsp_pop 
3f6c				endm 
# End of macro FORTH_DSP_POP
3f6c			 
3f6c 10 d6				djnz .mbuild 
3f6e			 
3f6e					; done add term 
3f6e			 
3f6e eb					ex de, hl 
3f6f 36 00				ld (hl), 0 
3f71 23					inc hl 
3f72 36 00				ld (hl), 0 
3f74			 
3f74				 
3f74					 
3f74 21 a3 ef				ld hl, scratch 
3f77			 
3f77					if DEBUG_FORTH_WORDS 
3f77						DMARK "MNx" 
3f77 f5				push af  
3f78 3a 8c 3f			ld a, (.dmark)  
3f7b 32 bd fb			ld (debug_mark),a  
3f7e 3a 8d 3f			ld a, (.dmark+1)  
3f81 32 be fb			ld (debug_mark+1),a  
3f84 3a 8e 3f			ld a, (.dmark+2)  
3f87 32 bf fb			ld (debug_mark+2),a  
3f8a 18 03			jr .pastdmark  
3f8c ..			.dmark: db "MNx"  
3f8f f1			.pastdmark: pop af  
3f90			endm  
# End of macro DMARK
3f90						CALLMONITOR 
3f90 cd 47 17			call break_point_state  
3f93				endm  
# End of macro CALLMONITOR
3f93					endif 
3f93			 
3f93			 
3f93			 
3f93 3e 00				ld a, 0 
3f95 cd 1a 0b				call menu 
3f98			 
3f98			 
3f98 6f					ld l, a 
3f99 26 00				ld h, 0 
3f9b			 
3f9b					if DEBUG_FORTH_WORDS 
3f9b						DMARK "MNr" 
3f9b f5				push af  
3f9c 3a b0 3f			ld a, (.dmark)  
3f9f 32 bd fb			ld (debug_mark),a  
3fa2 3a b1 3f			ld a, (.dmark+1)  
3fa5 32 be fb			ld (debug_mark+1),a  
3fa8 3a b2 3f			ld a, (.dmark+2)  
3fab 32 bf fb			ld (debug_mark+2),a  
3fae 18 03			jr .pastdmark  
3fb0 ..			.dmark: db "MNr"  
3fb3 f1			.pastdmark: pop af  
3fb4			endm  
# End of macro DMARK
3fb4						CALLMONITOR 
3fb4 cd 47 17			call break_point_state  
3fb7				endm  
# End of macro CALLMONITOR
3fb7					endif 
3fb7			 
3fb7 cd d7 1c				call forth_push_numhl 
3fba			 
3fba			 
3fba			 
3fba			 
3fba				       NEXTW 
3fba c3 40 20			jp macro_next 
3fbd				endm 
# End of macro NEXTW
3fbd			 
3fbd			 
3fbd			.ENDDISPLAY: 
3fbd			 
3fbd			; eof 
# End of file forth_words_display.asm
3fbd			include "forth_words_str.asm" 
3fbd			 
3fbd			; | ## String Words 
3fbd			 
3fbd			.PTR:   
3fbd			 
3fbd				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3fbd 48				db WORD_SYS_CORE+52             
3fbe ea 3f			dw .STYPE            
3fc0 04				db 3 + 1 
3fc1 .. 00			db "PTR",0              
3fc5				endm 
# End of macro CWHEAD
3fc5			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3fc5			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3fc5			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3fc5			 
3fc5					if DEBUG_FORTH_WORDS_KEY 
3fc5						DMARK "PTR" 
3fc5 f5				push af  
3fc6 3a da 3f			ld a, (.dmark)  
3fc9 32 bd fb			ld (debug_mark),a  
3fcc 3a db 3f			ld a, (.dmark+1)  
3fcf 32 be fb			ld (debug_mark+1),a  
3fd2 3a dc 3f			ld a, (.dmark+2)  
3fd5 32 bf fb			ld (debug_mark+2),a  
3fd8 18 03			jr .pastdmark  
3fda ..			.dmark: db "PTR"  
3fdd f1			.pastdmark: pop af  
3fde			endm  
# End of macro DMARK
3fde						CALLMONITOR 
3fde cd 47 17			call break_point_state  
3fe1				endm  
# End of macro CALLMONITOR
3fe1					endif 
3fe1					FORTH_DSP_VALUEHL 
3fe1 cd ce 1e			call macro_dsp_valuehl 
3fe4				endm 
# End of macro FORTH_DSP_VALUEHL
3fe4 cd d7 1c				call forth_push_numhl 
3fe7			 
3fe7			 
3fe7					NEXTW 
3fe7 c3 40 20			jp macro_next 
3fea				endm 
# End of macro NEXTW
3fea			.STYPE: 
3fea				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3fea 48				db WORD_SYS_CORE+52             
3feb 39 40			dw .UPPER            
3fed 06				db 5 + 1 
3fee .. 00			db "STYPE",0              
3ff4				endm 
# End of macro CWHEAD
3ff4			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3ff4					if DEBUG_FORTH_WORDS_KEY 
3ff4						DMARK "STY" 
3ff4 f5				push af  
3ff5 3a 09 40			ld a, (.dmark)  
3ff8 32 bd fb			ld (debug_mark),a  
3ffb 3a 0a 40			ld a, (.dmark+1)  
3ffe 32 be fb			ld (debug_mark+1),a  
4001 3a 0b 40			ld a, (.dmark+2)  
4004 32 bf fb			ld (debug_mark+2),a  
4007 18 03			jr .pastdmark  
4009 ..			.dmark: db "STY"  
400c f1			.pastdmark: pop af  
400d			endm  
# End of macro DMARK
400d						CALLMONITOR 
400d cd 47 17			call break_point_state  
4010				endm  
# End of macro CALLMONITOR
4010					endif 
4010					FORTH_DSP 
4010 cd 94 1e			call macro_forth_dsp 
4013				endm 
# End of macro FORTH_DSP
4013					;v5 FORTH_DSP_VALUE 
4013			 
4013 7e					ld a, (hl) 
4014			 
4014 f5					push af 
4015			 
4015			; Dont destroy TOS		FORTH_DSP_POP 
4015			 
4015 f1					pop af 
4016			 
4016 fe 01				cp DS_TYPE_STR 
4018 28 09				jr z, .typestr 
401a			 
401a fe 02				cp DS_TYPE_INUM 
401c 28 0a				jr z, .typeinum 
401e			 
401e 21 37 40				ld hl, .tna 
4021 18 0a				jr .tpush 
4023			 
4023 21 33 40		.typestr:	ld hl, .tstr 
4026 18 05				jr .tpush 
4028 21 35 40		.typeinum:	ld hl, .tinum 
402b 18 00				jr .tpush 
402d			 
402d			.tpush: 
402d			 
402d cd 45 1d				call forth_push_str 
4030			 
4030					NEXTW 
4030 c3 40 20			jp macro_next 
4033				endm 
# End of macro NEXTW
4033 .. 00		.tstr:	db "s",0 
4035 .. 00		.tinum:  db "i",0 
4037 .. 00		.tna:   db "?", 0 
4039			 
4039			 
4039			.UPPER: 
4039				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4039 48				db WORD_SYS_CORE+52             
403a 74 40			dw .LOWER            
403c 06				db 5 + 1 
403d .. 00			db "UPPER",0              
4043				endm 
# End of macro CWHEAD
4043			; | UPPER ( s -- s ) Upper case string s  | DONE 
4043					if DEBUG_FORTH_WORDS_KEY 
4043						DMARK "UPR" 
4043 f5				push af  
4044 3a 58 40			ld a, (.dmark)  
4047 32 bd fb			ld (debug_mark),a  
404a 3a 59 40			ld a, (.dmark+1)  
404d 32 be fb			ld (debug_mark+1),a  
4050 3a 5a 40			ld a, (.dmark+2)  
4053 32 bf fb			ld (debug_mark+2),a  
4056 18 03			jr .pastdmark  
4058 ..			.dmark: db "UPR"  
405b f1			.pastdmark: pop af  
405c			endm  
# End of macro DMARK
405c						CALLMONITOR 
405c cd 47 17			call break_point_state  
405f				endm  
# End of macro CALLMONITOR
405f					endif 
405f			 
405f					FORTH_DSP 
405f cd 94 1e			call macro_forth_dsp 
4062				endm 
# End of macro FORTH_DSP
4062					 
4062			; TODO check is string type 
4062			 
4062					FORTH_DSP_VALUEHL 
4062 cd ce 1e			call macro_dsp_valuehl 
4065				endm 
# End of macro FORTH_DSP_VALUEHL
4065			; get pointer to string in hl 
4065			 
4065 7e			.toup:		ld a, (hl) 
4066 fe 00				cp 0 
4068 28 07				jr z, .toupdone 
406a			 
406a cd 8a 10				call to_upper 
406d			 
406d 77					ld (hl), a 
406e 23					inc hl 
406f 18 f4				jr .toup 
4071			 
4071					 
4071			 
4071			 
4071			; for each char convert to upper 
4071					 
4071			.toupdone: 
4071			 
4071			 
4071					NEXTW 
4071 c3 40 20			jp macro_next 
4074				endm 
# End of macro NEXTW
4074			.LOWER: 
4074				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4074 48				db WORD_SYS_CORE+52             
4075 af 40			dw .TCASE            
4077 06				db 5 + 1 
4078 .. 00			db "LOWER",0              
407e				endm 
# End of macro CWHEAD
407e			; | LOWER ( s -- s ) Lower case string s  | DONE 
407e					if DEBUG_FORTH_WORDS_KEY 
407e						DMARK "LWR" 
407e f5				push af  
407f 3a 93 40			ld a, (.dmark)  
4082 32 bd fb			ld (debug_mark),a  
4085 3a 94 40			ld a, (.dmark+1)  
4088 32 be fb			ld (debug_mark+1),a  
408b 3a 95 40			ld a, (.dmark+2)  
408e 32 bf fb			ld (debug_mark+2),a  
4091 18 03			jr .pastdmark  
4093 ..			.dmark: db "LWR"  
4096 f1			.pastdmark: pop af  
4097			endm  
# End of macro DMARK
4097						CALLMONITOR 
4097 cd 47 17			call break_point_state  
409a				endm  
# End of macro CALLMONITOR
409a					endif 
409a			 
409a					FORTH_DSP 
409a cd 94 1e			call macro_forth_dsp 
409d				endm 
# End of macro FORTH_DSP
409d					 
409d			; TODO check is string type 
409d			 
409d					FORTH_DSP_VALUEHL 
409d cd ce 1e			call macro_dsp_valuehl 
40a0				endm 
# End of macro FORTH_DSP_VALUEHL
40a0			; get pointer to string in hl 
40a0			 
40a0 7e			.tolow:		ld a, (hl) 
40a1 fe 00				cp 0 
40a3 28 07				jr z, .tolowdone 
40a5			 
40a5 cd 93 10				call to_lower 
40a8			 
40a8 77					ld (hl), a 
40a9 23					inc hl 
40aa 18 f4				jr .tolow 
40ac			 
40ac					 
40ac			 
40ac			 
40ac			; for each char convert to low 
40ac					 
40ac			.tolowdone: 
40ac					NEXTW 
40ac c3 40 20			jp macro_next 
40af				endm 
# End of macro NEXTW
40af			.TCASE: 
40af				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40af 48				db WORD_SYS_CORE+52             
40b0 e5 41			dw .SUBSTR            
40b2 06				db 5 + 1 
40b3 .. 00			db "TCASE",0              
40b9				endm 
# End of macro CWHEAD
40b9			; | TCASE ( s -- s ) Title case string s  | DONE 
40b9					if DEBUG_FORTH_WORDS_KEY 
40b9						DMARK "TCS" 
40b9 f5				push af  
40ba 3a ce 40			ld a, (.dmark)  
40bd 32 bd fb			ld (debug_mark),a  
40c0 3a cf 40			ld a, (.dmark+1)  
40c3 32 be fb			ld (debug_mark+1),a  
40c6 3a d0 40			ld a, (.dmark+2)  
40c9 32 bf fb			ld (debug_mark+2),a  
40cc 18 03			jr .pastdmark  
40ce ..			.dmark: db "TCS"  
40d1 f1			.pastdmark: pop af  
40d2			endm  
# End of macro DMARK
40d2						CALLMONITOR 
40d2 cd 47 17			call break_point_state  
40d5				endm  
# End of macro CALLMONITOR
40d5					endif 
40d5			 
40d5					FORTH_DSP 
40d5 cd 94 1e			call macro_forth_dsp 
40d8				endm 
# End of macro FORTH_DSP
40d8					 
40d8			; TODO check is string type 
40d8			 
40d8					FORTH_DSP_VALUEHL 
40d8 cd ce 1e			call macro_dsp_valuehl 
40db				endm 
# End of macro FORTH_DSP_VALUEHL
40db			; get pointer to string in hl 
40db			 
40db					if DEBUG_FORTH_WORDS 
40db						DMARK "TC1" 
40db f5				push af  
40dc 3a f0 40			ld a, (.dmark)  
40df 32 bd fb			ld (debug_mark),a  
40e2 3a f1 40			ld a, (.dmark+1)  
40e5 32 be fb			ld (debug_mark+1),a  
40e8 3a f2 40			ld a, (.dmark+2)  
40eb 32 bf fb			ld (debug_mark+2),a  
40ee 18 03			jr .pastdmark  
40f0 ..			.dmark: db "TC1"  
40f3 f1			.pastdmark: pop af  
40f4			endm  
# End of macro DMARK
40f4						CALLMONITOR 
40f4 cd 47 17			call break_point_state  
40f7				endm  
# End of macro CALLMONITOR
40f7					endif 
40f7			 
40f7					; first time in turn to upper case first char 
40f7			 
40f7 7e					ld a, (hl) 
40f8 c3 82 41				jp .totsiptou 
40fb			 
40fb			 
40fb 7e			.tot:		ld a, (hl) 
40fc fe 00				cp 0 
40fe ca c6 41				jp z, .totdone 
4101			 
4101					if DEBUG_FORTH_WORDS 
4101						DMARK "TC2" 
4101 f5				push af  
4102 3a 16 41			ld a, (.dmark)  
4105 32 bd fb			ld (debug_mark),a  
4108 3a 17 41			ld a, (.dmark+1)  
410b 32 be fb			ld (debug_mark+1),a  
410e 3a 18 41			ld a, (.dmark+2)  
4111 32 bf fb			ld (debug_mark+2),a  
4114 18 03			jr .pastdmark  
4116 ..			.dmark: db "TC2"  
4119 f1			.pastdmark: pop af  
411a			endm  
# End of macro DMARK
411a						CALLMONITOR 
411a cd 47 17			call break_point_state  
411d				endm  
# End of macro CALLMONITOR
411d					endif 
411d					; check to see if current char is a space 
411d			 
411d fe 20				cp ' ' 
411f 28 21				jr z, .totsp 
4121 cd 93 10				call to_lower 
4124					if DEBUG_FORTH_WORDS 
4124						DMARK "TC3" 
4124 f5				push af  
4125 3a 39 41			ld a, (.dmark)  
4128 32 bd fb			ld (debug_mark),a  
412b 3a 3a 41			ld a, (.dmark+1)  
412e 32 be fb			ld (debug_mark+1),a  
4131 3a 3b 41			ld a, (.dmark+2)  
4134 32 bf fb			ld (debug_mark+2),a  
4137 18 03			jr .pastdmark  
4139 ..			.dmark: db "TC3"  
413c f1			.pastdmark: pop af  
413d			endm  
# End of macro DMARK
413d						CALLMONITOR 
413d cd 47 17			call break_point_state  
4140				endm  
# End of macro CALLMONITOR
4140					endif 
4140 18 63				jr .totnxt 
4142			 
4142			.totsp:         ; on a space, find next char which should be upper 
4142			 
4142					if DEBUG_FORTH_WORDS 
4142						DMARK "TC4" 
4142 f5				push af  
4143 3a 57 41			ld a, (.dmark)  
4146 32 bd fb			ld (debug_mark),a  
4149 3a 58 41			ld a, (.dmark+1)  
414c 32 be fb			ld (debug_mark+1),a  
414f 3a 59 41			ld a, (.dmark+2)  
4152 32 bf fb			ld (debug_mark+2),a  
4155 18 03			jr .pastdmark  
4157 ..			.dmark: db "TC4"  
415a f1			.pastdmark: pop af  
415b			endm  
# End of macro DMARK
415b						CALLMONITOR 
415b cd 47 17			call break_point_state  
415e				endm  
# End of macro CALLMONITOR
415e					endif 
415e					;; 
415e			 
415e fe 20				cp ' ' 
4160 20 20				jr nz, .totsiptou 
4162 23					inc hl 
4163 7e					ld a, (hl) 
4164					if DEBUG_FORTH_WORDS 
4164						DMARK "TC5" 
4164 f5				push af  
4165 3a 79 41			ld a, (.dmark)  
4168 32 bd fb			ld (debug_mark),a  
416b 3a 7a 41			ld a, (.dmark+1)  
416e 32 be fb			ld (debug_mark+1),a  
4171 3a 7b 41			ld a, (.dmark+2)  
4174 32 bf fb			ld (debug_mark+2),a  
4177 18 03			jr .pastdmark  
4179 ..			.dmark: db "TC5"  
417c f1			.pastdmark: pop af  
417d			endm  
# End of macro DMARK
417d						CALLMONITOR 
417d cd 47 17			call break_point_state  
4180				endm  
# End of macro CALLMONITOR
4180					endif 
4180 18 c0				jr .totsp 
4182 fe 00		.totsiptou:    cp 0 
4184 28 40				jr z, .totdone 
4186					; not space and not zero term so upper case it 
4186 cd 8a 10				call to_upper 
4189			 
4189					if DEBUG_FORTH_WORDS 
4189						DMARK "TC6" 
4189 f5				push af  
418a 3a 9e 41			ld a, (.dmark)  
418d 32 bd fb			ld (debug_mark),a  
4190 3a 9f 41			ld a, (.dmark+1)  
4193 32 be fb			ld (debug_mark+1),a  
4196 3a a0 41			ld a, (.dmark+2)  
4199 32 bf fb			ld (debug_mark+2),a  
419c 18 03			jr .pastdmark  
419e ..			.dmark: db "TC6"  
41a1 f1			.pastdmark: pop af  
41a2			endm  
# End of macro DMARK
41a2						CALLMONITOR 
41a2 cd 47 17			call break_point_state  
41a5				endm  
# End of macro CALLMONITOR
41a5					endif 
41a5			 
41a5			 
41a5			.totnxt: 
41a5			 
41a5 77					ld (hl), a 
41a6 23					inc hl 
41a7					if DEBUG_FORTH_WORDS 
41a7						DMARK "TC7" 
41a7 f5				push af  
41a8 3a bc 41			ld a, (.dmark)  
41ab 32 bd fb			ld (debug_mark),a  
41ae 3a bd 41			ld a, (.dmark+1)  
41b1 32 be fb			ld (debug_mark+1),a  
41b4 3a be 41			ld a, (.dmark+2)  
41b7 32 bf fb			ld (debug_mark+2),a  
41ba 18 03			jr .pastdmark  
41bc ..			.dmark: db "TC7"  
41bf f1			.pastdmark: pop af  
41c0			endm  
# End of macro DMARK
41c0						CALLMONITOR 
41c0 cd 47 17			call break_point_state  
41c3				endm  
# End of macro CALLMONITOR
41c3					endif 
41c3 c3 fb 40				jp .tot 
41c6			 
41c6					 
41c6			 
41c6			 
41c6			; for each char convert to low 
41c6					 
41c6			.totdone: 
41c6					if DEBUG_FORTH_WORDS 
41c6						DMARK "TCd" 
41c6 f5				push af  
41c7 3a db 41			ld a, (.dmark)  
41ca 32 bd fb			ld (debug_mark),a  
41cd 3a dc 41			ld a, (.dmark+1)  
41d0 32 be fb			ld (debug_mark+1),a  
41d3 3a dd 41			ld a, (.dmark+2)  
41d6 32 bf fb			ld (debug_mark+2),a  
41d9 18 03			jr .pastdmark  
41db ..			.dmark: db "TCd"  
41de f1			.pastdmark: pop af  
41df			endm  
# End of macro DMARK
41df						CALLMONITOR 
41df cd 47 17			call break_point_state  
41e2				endm  
# End of macro CALLMONITOR
41e2					endif 
41e2					NEXTW 
41e2 c3 40 20			jp macro_next 
41e5				endm 
# End of macro NEXTW
41e5			 
41e5			.SUBSTR: 
41e5				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
41e5 48				db WORD_SYS_CORE+52             
41e6 43 42			dw .LEFT            
41e8 07				db 6 + 1 
41e9 .. 00			db "SUBSTR",0              
41f0				endm 
# End of macro CWHEAD
41f0			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
41f0			 
41f0					if DEBUG_FORTH_WORDS_KEY 
41f0						DMARK "SST" 
41f0 f5				push af  
41f1 3a 05 42			ld a, (.dmark)  
41f4 32 bd fb			ld (debug_mark),a  
41f7 3a 06 42			ld a, (.dmark+1)  
41fa 32 be fb			ld (debug_mark+1),a  
41fd 3a 07 42			ld a, (.dmark+2)  
4200 32 bf fb			ld (debug_mark+2),a  
4203 18 03			jr .pastdmark  
4205 ..			.dmark: db "SST"  
4208 f1			.pastdmark: pop af  
4209			endm  
# End of macro DMARK
4209						CALLMONITOR 
4209 cd 47 17			call break_point_state  
420c				endm  
# End of macro CALLMONITOR
420c					endif 
420c			; TODO check string type 
420c					FORTH_DSP_VALUEHL 
420c cd ce 1e			call macro_dsp_valuehl 
420f				endm 
# End of macro FORTH_DSP_VALUEHL
420f			 
420f e5					push hl      ; string length 
4210			 
4210					FORTH_DSP_POP 
4210 cd 86 1f			call macro_forth_dsp_pop 
4213				endm 
# End of macro FORTH_DSP_POP
4213			 
4213					FORTH_DSP_VALUEHL 
4213 cd ce 1e			call macro_dsp_valuehl 
4216				endm 
# End of macro FORTH_DSP_VALUEHL
4216			 
4216 e5					push hl     ; start char 
4217			 
4217					FORTH_DSP_POP 
4217 cd 86 1f			call macro_forth_dsp_pop 
421a				endm 
# End of macro FORTH_DSP_POP
421a			 
421a			 
421a					FORTH_DSP_VALUE 
421a cd b7 1e			call macro_forth_dsp_value 
421d				endm 
# End of macro FORTH_DSP_VALUE
421d			 
421d d1					pop de    ; get start post offset 
421e			 
421e 19					add hl, de    ; starting offset 
421f			 
421f c1					pop bc 
4220 c5					push bc      ; grab size of string 
4221			 
4221 e5					push hl    ; save string start  
4222			 
4222 26 00				ld h, 0 
4224 69					ld l, c 
4225 23					inc hl 
4226 23					inc hl 
4227			 
4227 cd e4 11				call malloc 
422a				if DEBUG_FORTH_MALLOC_GUARD 
422a cc d9 51				call z,malloc_error 
422d				endif 
422d			 
422d eb					ex de, hl      ; save malloc area for string copy 
422e e1					pop hl    ; get back source 
422f c1					pop bc    ; get length of string back 
4230			 
4230 d5					push de    ; save malloc area for after we push 
4231 ed b0				ldir     ; copy substr 
4233			 
4233			 
4233 eb					ex de, hl 
4234 3e 00				ld a, 0 
4236 77					ld (hl), a   ; term substr 
4237			 
4237					 
4237 e1					pop hl    ; get malloc so we can push it 
4238 e5					push hl   ; save so we can free it afterwards 
4239			 
4239 cd 45 1d				call forth_push_str 
423c			 
423c e1					pop hl 
423d cd ae 12				call free 
4240			 
4240					 
4240					 
4240			 
4240			 
4240					NEXTW 
4240 c3 40 20			jp macro_next 
4243				endm 
# End of macro NEXTW
4243			 
4243			.LEFT: 
4243				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4243 48				db WORD_SYS_CORE+52             
4244 6b 42			dw .RIGHT            
4246 05				db 4 + 1 
4247 .. 00			db "LEFT",0              
424c				endm 
# End of macro CWHEAD
424c			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
424c					if DEBUG_FORTH_WORDS_KEY 
424c						DMARK "LEF" 
424c f5				push af  
424d 3a 61 42			ld a, (.dmark)  
4250 32 bd fb			ld (debug_mark),a  
4253 3a 62 42			ld a, (.dmark+1)  
4256 32 be fb			ld (debug_mark+1),a  
4259 3a 63 42			ld a, (.dmark+2)  
425c 32 bf fb			ld (debug_mark+2),a  
425f 18 03			jr .pastdmark  
4261 ..			.dmark: db "LEF"  
4264 f1			.pastdmark: pop af  
4265			endm  
# End of macro DMARK
4265						CALLMONITOR 
4265 cd 47 17			call break_point_state  
4268				endm  
# End of macro CALLMONITOR
4268					endif 
4268			 
4268					NEXTW 
4268 c3 40 20			jp macro_next 
426b				endm 
# End of macro NEXTW
426b			.RIGHT: 
426b				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
426b 48				db WORD_SYS_CORE+52             
426c 94 42			dw .STR2NUM            
426e 06				db 5 + 1 
426f .. 00			db "RIGHT",0              
4275				endm 
# End of macro CWHEAD
4275			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4275					if DEBUG_FORTH_WORDS_KEY 
4275						DMARK "RIG" 
4275 f5				push af  
4276 3a 8a 42			ld a, (.dmark)  
4279 32 bd fb			ld (debug_mark),a  
427c 3a 8b 42			ld a, (.dmark+1)  
427f 32 be fb			ld (debug_mark+1),a  
4282 3a 8c 42			ld a, (.dmark+2)  
4285 32 bf fb			ld (debug_mark+2),a  
4288 18 03			jr .pastdmark  
428a ..			.dmark: db "RIG"  
428d f1			.pastdmark: pop af  
428e			endm  
# End of macro DMARK
428e						CALLMONITOR 
428e cd 47 17			call break_point_state  
4291				endm  
# End of macro CALLMONITOR
4291					endif 
4291			 
4291					NEXTW 
4291 c3 40 20			jp macro_next 
4294				endm 
# End of macro NEXTW
4294			 
4294			 
4294			.STR2NUM: 
4294				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4294 48				db WORD_SYS_CORE+52             
4295 20 43			dw .NUM2STR            
4297 08				db 7 + 1 
4298 .. 00			db "STR2NUM",0              
42a0				endm 
# End of macro CWHEAD
42a0			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
42a0			 
42a0			 
42a0			; TODO STR type check to do 
42a0					if DEBUG_FORTH_WORDS_KEY 
42a0						DMARK "S2N" 
42a0 f5				push af  
42a1 3a b5 42			ld a, (.dmark)  
42a4 32 bd fb			ld (debug_mark),a  
42a7 3a b6 42			ld a, (.dmark+1)  
42aa 32 be fb			ld (debug_mark+1),a  
42ad 3a b7 42			ld a, (.dmark+2)  
42b0 32 bf fb			ld (debug_mark+2),a  
42b3 18 03			jr .pastdmark  
42b5 ..			.dmark: db "S2N"  
42b8 f1			.pastdmark: pop af  
42b9			endm  
# End of macro DMARK
42b9						CALLMONITOR 
42b9 cd 47 17			call break_point_state  
42bc				endm  
# End of macro CALLMONITOR
42bc					endif 
42bc			 
42bc					;FORTH_DSP 
42bc					FORTH_DSP_VALUE 
42bc cd b7 1e			call macro_forth_dsp_value 
42bf				endm 
# End of macro FORTH_DSP_VALUE
42bf					;inc hl 
42bf			 
42bf eb					ex de, hl 
42c0					if DEBUG_FORTH_WORDS 
42c0						DMARK "S2a" 
42c0 f5				push af  
42c1 3a d5 42			ld a, (.dmark)  
42c4 32 bd fb			ld (debug_mark),a  
42c7 3a d6 42			ld a, (.dmark+1)  
42ca 32 be fb			ld (debug_mark+1),a  
42cd 3a d7 42			ld a, (.dmark+2)  
42d0 32 bf fb			ld (debug_mark+2),a  
42d3 18 03			jr .pastdmark  
42d5 ..			.dmark: db "S2a"  
42d8 f1			.pastdmark: pop af  
42d9			endm  
# End of macro DMARK
42d9						CALLMONITOR 
42d9 cd 47 17			call break_point_state  
42dc				endm  
# End of macro CALLMONITOR
42dc					endif 
42dc cd 12 11				call string_to_uint16 
42df			 
42df					if DEBUG_FORTH_WORDS 
42df						DMARK "S2b" 
42df f5				push af  
42e0 3a f4 42			ld a, (.dmark)  
42e3 32 bd fb			ld (debug_mark),a  
42e6 3a f5 42			ld a, (.dmark+1)  
42e9 32 be fb			ld (debug_mark+1),a  
42ec 3a f6 42			ld a, (.dmark+2)  
42ef 32 bf fb			ld (debug_mark+2),a  
42f2 18 03			jr .pastdmark  
42f4 ..			.dmark: db "S2b"  
42f7 f1			.pastdmark: pop af  
42f8			endm  
# End of macro DMARK
42f8						CALLMONITOR 
42f8 cd 47 17			call break_point_state  
42fb				endm  
# End of macro CALLMONITOR
42fb					endif 
42fb			;		push hl 
42fb					FORTH_DSP_POP 
42fb cd 86 1f			call macro_forth_dsp_pop 
42fe				endm 
# End of macro FORTH_DSP_POP
42fe			;		pop hl 
42fe					 
42fe					if DEBUG_FORTH_WORDS 
42fe						DMARK "S2b" 
42fe f5				push af  
42ff 3a 13 43			ld a, (.dmark)  
4302 32 bd fb			ld (debug_mark),a  
4305 3a 14 43			ld a, (.dmark+1)  
4308 32 be fb			ld (debug_mark+1),a  
430b 3a 15 43			ld a, (.dmark+2)  
430e 32 bf fb			ld (debug_mark+2),a  
4311 18 03			jr .pastdmark  
4313 ..			.dmark: db "S2b"  
4316 f1			.pastdmark: pop af  
4317			endm  
# End of macro DMARK
4317						CALLMONITOR 
4317 cd 47 17			call break_point_state  
431a				endm  
# End of macro CALLMONITOR
431a					endif 
431a cd d7 1c				call forth_push_numhl	 
431d			 
431d				 
431d				       NEXTW 
431d c3 40 20			jp macro_next 
4320				endm 
# End of macro NEXTW
4320			.NUM2STR: 
4320				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4320 48				db WORD_SYS_CORE+52             
4321 2f 43			dw .CONCAT            
4323 08				db 7 + 1 
4324 .. 00			db "NUM2STR",0              
432c				endm 
# End of macro CWHEAD
432c			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
432c			 
432c			;		; malloc a string to target 
432c			;		ld hl, 10     ; TODO max string size should be fine 
432c			;		call malloc 
432c			;		push hl    ; save malloc location 
432c			; 
432c			; 
432c			;; TODO check int type 
432c			;		FORTH_DSP_VALUEHL 
432c			;		ld a, l 
432c			;		call DispAToASCII   
432c			;;TODO need to chage above call to dump into string 
432c			; 
432c			; 
432c			 
432c				       NEXTW 
432c c3 40 20			jp macro_next 
432f				endm 
# End of macro NEXTW
432f			 
432f			.CONCAT: 
432f				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
432f 48				db WORD_SYS_CORE+52             
4330 e2 43			dw .FIND            
4332 07				db 6 + 1 
4333 .. 00			db "CONCAT",0              
433a				endm 
# End of macro CWHEAD
433a			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
433a			 
433a			; TODO check string type 
433a			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
433a			 
433a					if DEBUG_FORTH_WORDS_KEY 
433a						DMARK "CON" 
433a f5				push af  
433b 3a 4f 43			ld a, (.dmark)  
433e 32 bd fb			ld (debug_mark),a  
4341 3a 50 43			ld a, (.dmark+1)  
4344 32 be fb			ld (debug_mark+1),a  
4347 3a 51 43			ld a, (.dmark+2)  
434a 32 bf fb			ld (debug_mark+2),a  
434d 18 03			jr .pastdmark  
434f ..			.dmark: db "CON"  
4352 f1			.pastdmark: pop af  
4353			endm  
# End of macro DMARK
4353						CALLMONITOR 
4353 cd 47 17			call break_point_state  
4356				endm  
# End of macro CALLMONITOR
4356					endif 
4356			 
4356			 
4356					FORTH_DSP_VALUE 
4356 cd b7 1e			call macro_forth_dsp_value 
4359				endm 
# End of macro FORTH_DSP_VALUE
4359 e5					push hl   ; s2 
435a			 
435a					FORTH_DSP_POP 
435a cd 86 1f			call macro_forth_dsp_pop 
435d				endm 
# End of macro FORTH_DSP_POP
435d			 
435d					FORTH_DSP_VALUE 
435d cd b7 1e			call macro_forth_dsp_value 
4360				endm 
# End of macro FORTH_DSP_VALUE
4360			 
4360 e5					push hl   ; s1 
4361			 
4361					FORTH_DSP_POP 
4361 cd 86 1f			call macro_forth_dsp_pop 
4364				endm 
# End of macro FORTH_DSP_POP
4364					 
4364			 
4364					; copy s1 
4364			 
4364				 
4364					; save ptr 
4364 e1					pop hl  
4365 e5					push hl 
4366 3e 00				ld a, 0 
4368 cd 86 11				call strlent 
436b					;inc hl    ; zer0 
436b 06 00				ld b, 0 
436d 4d					ld c, l 
436e e1					pop hl		 
436f 11 a3 ef				ld de, scratch	 
4372					if DEBUG_FORTH_WORDS 
4372						DMARK "CO1" 
4372 f5				push af  
4373 3a 87 43			ld a, (.dmark)  
4376 32 bd fb			ld (debug_mark),a  
4379 3a 88 43			ld a, (.dmark+1)  
437c 32 be fb			ld (debug_mark+1),a  
437f 3a 89 43			ld a, (.dmark+2)  
4382 32 bf fb			ld (debug_mark+2),a  
4385 18 03			jr .pastdmark  
4387 ..			.dmark: db "CO1"  
438a f1			.pastdmark: pop af  
438b			endm  
# End of macro DMARK
438b						CALLMONITOR 
438b cd 47 17			call break_point_state  
438e				endm  
# End of macro CALLMONITOR
438e					endif 
438e ed b0				ldir 
4390			 
4390 e1					pop hl 
4391 e5					push hl 
4392 d5					push de 
4393			 
4393			 
4393 3e 00				ld a, 0 
4395 cd 86 11				call strlent 
4398 23					inc hl    ; zer0 
4399 23					inc hl 
439a 06 00				ld b, 0 
439c 4d					ld c, l 
439d d1					pop de 
439e e1					pop hl		 
439f					if DEBUG_FORTH_WORDS 
439f						DMARK "CO2" 
439f f5				push af  
43a0 3a b4 43			ld a, (.dmark)  
43a3 32 bd fb			ld (debug_mark),a  
43a6 3a b5 43			ld a, (.dmark+1)  
43a9 32 be fb			ld (debug_mark+1),a  
43ac 3a b6 43			ld a, (.dmark+2)  
43af 32 bf fb			ld (debug_mark+2),a  
43b2 18 03			jr .pastdmark  
43b4 ..			.dmark: db "CO2"  
43b7 f1			.pastdmark: pop af  
43b8			endm  
# End of macro DMARK
43b8						CALLMONITOR 
43b8 cd 47 17			call break_point_state  
43bb				endm  
# End of macro CALLMONITOR
43bb					endif 
43bb ed b0				ldir 
43bd			 
43bd			 
43bd			 
43bd 21 a3 ef				ld hl, scratch 
43c0					if DEBUG_FORTH_WORDS 
43c0						DMARK "CO5" 
43c0 f5				push af  
43c1 3a d5 43			ld a, (.dmark)  
43c4 32 bd fb			ld (debug_mark),a  
43c7 3a d6 43			ld a, (.dmark+1)  
43ca 32 be fb			ld (debug_mark+1),a  
43cd 3a d7 43			ld a, (.dmark+2)  
43d0 32 bf fb			ld (debug_mark+2),a  
43d3 18 03			jr .pastdmark  
43d5 ..			.dmark: db "CO5"  
43d8 f1			.pastdmark: pop af  
43d9			endm  
# End of macro DMARK
43d9						CALLMONITOR 
43d9 cd 47 17			call break_point_state  
43dc				endm  
# End of macro CALLMONITOR
43dc					endif 
43dc			 
43dc cd 45 1d				call forth_push_str 
43df			 
43df			 
43df			 
43df			 
43df				       NEXTW 
43df c3 40 20			jp macro_next 
43e2				endm 
# End of macro NEXTW
43e2			 
43e2			 
43e2			.FIND: 
43e2				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
43e2 4b				db WORD_SYS_CORE+55             
43e3 a0 44			dw .LEN            
43e5 05				db 4 + 1 
43e6 .. 00			db "FIND",0              
43eb				endm 
# End of macro CWHEAD
43eb			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
43eb			 
43eb					if DEBUG_FORTH_WORDS_KEY 
43eb						DMARK "FND" 
43eb f5				push af  
43ec 3a 00 44			ld a, (.dmark)  
43ef 32 bd fb			ld (debug_mark),a  
43f2 3a 01 44			ld a, (.dmark+1)  
43f5 32 be fb			ld (debug_mark+1),a  
43f8 3a 02 44			ld a, (.dmark+2)  
43fb 32 bf fb			ld (debug_mark+2),a  
43fe 18 03			jr .pastdmark  
4400 ..			.dmark: db "FND"  
4403 f1			.pastdmark: pop af  
4404			endm  
# End of macro DMARK
4404						CALLMONITOR 
4404 cd 47 17			call break_point_state  
4407				endm  
# End of macro CALLMONITOR
4407					endif 
4407			 
4407			; TODO check string type 
4407					FORTH_DSP_VALUE 
4407 cd b7 1e			call macro_forth_dsp_value 
440a				endm 
# End of macro FORTH_DSP_VALUE
440a			 
440a e5					push hl    
440b 7e					ld a,(hl)    ; char to find   
440c			; TODO change char to substr 
440c			 
440c f5					push af 
440d					 
440d			 
440d			 
440d					if DEBUG_FORTH_WORDS 
440d						DMARK "FN1" 
440d f5				push af  
440e 3a 22 44			ld a, (.dmark)  
4411 32 bd fb			ld (debug_mark),a  
4414 3a 23 44			ld a, (.dmark+1)  
4417 32 be fb			ld (debug_mark+1),a  
441a 3a 24 44			ld a, (.dmark+2)  
441d 32 bf fb			ld (debug_mark+2),a  
4420 18 03			jr .pastdmark  
4422 ..			.dmark: db "FN1"  
4425 f1			.pastdmark: pop af  
4426			endm  
# End of macro DMARK
4426						CALLMONITOR 
4426 cd 47 17			call break_point_state  
4429				endm  
# End of macro CALLMONITOR
4429					endif 
4429			 
4429					FORTH_DSP_POP 
4429 cd 86 1f			call macro_forth_dsp_pop 
442c				endm 
# End of macro FORTH_DSP_POP
442c			 
442c					; string to search 
442c			 
442c					FORTH_DSP_VALUE 
442c cd b7 1e			call macro_forth_dsp_value 
442f				endm 
# End of macro FORTH_DSP_VALUE
442f			 
442f d1					pop de  ; d is char to find  
4430			 
4430					if DEBUG_FORTH_WORDS 
4430						DMARK "FN2" 
4430 f5				push af  
4431 3a 45 44			ld a, (.dmark)  
4434 32 bd fb			ld (debug_mark),a  
4437 3a 46 44			ld a, (.dmark+1)  
443a 32 be fb			ld (debug_mark+1),a  
443d 3a 47 44			ld a, (.dmark+2)  
4440 32 bf fb			ld (debug_mark+2),a  
4443 18 03			jr .pastdmark  
4445 ..			.dmark: db "FN2"  
4448 f1			.pastdmark: pop af  
4449			endm  
# End of macro DMARK
4449						CALLMONITOR 
4449 cd 47 17			call break_point_state  
444c				endm  
# End of macro CALLMONITOR
444c					endif 
444c					 
444c 01 00 00				ld bc, 0 
444f 7e			.findchar:      ld a,(hl) 
4450 fe 00				cp 0   		 
4452 28 27				jr z, .finddone     
4454 ba					cp d 
4455 28 20				jr z, .foundchar 
4457 03					inc bc 
4458 23					inc hl 
4459					if DEBUG_FORTH_WORDS 
4459						DMARK "FN3" 
4459 f5				push af  
445a 3a 6e 44			ld a, (.dmark)  
445d 32 bd fb			ld (debug_mark),a  
4460 3a 6f 44			ld a, (.dmark+1)  
4463 32 be fb			ld (debug_mark+1),a  
4466 3a 70 44			ld a, (.dmark+2)  
4469 32 bf fb			ld (debug_mark+2),a  
446c 18 03			jr .pastdmark  
446e ..			.dmark: db "FN3"  
4471 f1			.pastdmark: pop af  
4472			endm  
# End of macro DMARK
4472						CALLMONITOR 
4472 cd 47 17			call break_point_state  
4475				endm  
# End of macro CALLMONITOR
4475					endif 
4475 18 d8				jr .findchar 
4477			 
4477			 
4477 c5			.foundchar:	push bc 
4478 e1					pop hl 
4479 18 03				jr .findexit 
447b			 
447b			 
447b							 
447b			 
447b			.finddone:     ; got to end of string with no find 
447b 21 00 00				ld hl, 0 
447e			.findexit: 
447e			 
447e					if DEBUG_FORTH_WORDS 
447e						DMARK "FNd" 
447e f5				push af  
447f 3a 93 44			ld a, (.dmark)  
4482 32 bd fb			ld (debug_mark),a  
4485 3a 94 44			ld a, (.dmark+1)  
4488 32 be fb			ld (debug_mark+1),a  
448b 3a 95 44			ld a, (.dmark+2)  
448e 32 bf fb			ld (debug_mark+2),a  
4491 18 03			jr .pastdmark  
4493 ..			.dmark: db "FNd"  
4496 f1			.pastdmark: pop af  
4497			endm  
# End of macro DMARK
4497						CALLMONITOR 
4497 cd 47 17			call break_point_state  
449a				endm  
# End of macro CALLMONITOR
449a					endif 
449a cd d7 1c			call forth_push_numhl 
449d			 
449d				       NEXTW 
449d c3 40 20			jp macro_next 
44a0				endm 
# End of macro NEXTW
44a0			 
44a0			.LEN: 
44a0				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
44a0 4c				db WORD_SYS_CORE+56             
44a1 d5 44			dw .CHAR            
44a3 06				db 5 + 1 
44a4 .. 00			db "COUNT",0              
44aa				endm 
# End of macro CWHEAD
44aa			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44aa			 
44aa					if DEBUG_FORTH_WORDS_KEY 
44aa						DMARK "CNT" 
44aa f5				push af  
44ab 3a bf 44			ld a, (.dmark)  
44ae 32 bd fb			ld (debug_mark),a  
44b1 3a c0 44			ld a, (.dmark+1)  
44b4 32 be fb			ld (debug_mark+1),a  
44b7 3a c1 44			ld a, (.dmark+2)  
44ba 32 bf fb			ld (debug_mark+2),a  
44bd 18 03			jr .pastdmark  
44bf ..			.dmark: db "CNT"  
44c2 f1			.pastdmark: pop af  
44c3			endm  
# End of macro DMARK
44c3						CALLMONITOR 
44c3 cd 47 17			call break_point_state  
44c6				endm  
# End of macro CALLMONITOR
44c6					endif 
44c6			; TODO check string type 
44c6					FORTH_DSP 
44c6 cd 94 1e			call macro_forth_dsp 
44c9				endm 
# End of macro FORTH_DSP
44c9					;v5FORTH_DSP_VALUE 
44c9			 
44c9 23					inc hl 
44ca			 
44ca 3e 00				ld a, 0 
44cc cd 86 11				call strlent 
44cf			 
44cf cd d7 1c				call forth_push_numhl 
44d2			 
44d2			 
44d2			 
44d2				       NEXTW 
44d2 c3 40 20			jp macro_next 
44d5				endm 
# End of macro NEXTW
44d5			.CHAR: 
44d5				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
44d5 4d				db WORD_SYS_CORE+57             
44d6 0b 45			dw .ENDSTR            
44d8 05				db 4 + 1 
44d9 .. 00			db "CHAR",0              
44de				endm 
# End of macro CWHEAD
44de			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
44de					if DEBUG_FORTH_WORDS_KEY 
44de						DMARK "CHR" 
44de f5				push af  
44df 3a f3 44			ld a, (.dmark)  
44e2 32 bd fb			ld (debug_mark),a  
44e5 3a f4 44			ld a, (.dmark+1)  
44e8 32 be fb			ld (debug_mark+1),a  
44eb 3a f5 44			ld a, (.dmark+2)  
44ee 32 bf fb			ld (debug_mark+2),a  
44f1 18 03			jr .pastdmark  
44f3 ..			.dmark: db "CHR"  
44f6 f1			.pastdmark: pop af  
44f7			endm  
# End of macro DMARK
44f7						CALLMONITOR 
44f7 cd 47 17			call break_point_state  
44fa				endm  
# End of macro CALLMONITOR
44fa					endif 
44fa					FORTH_DSP 
44fa cd 94 1e			call macro_forth_dsp 
44fd				endm 
# End of macro FORTH_DSP
44fd					;v5 FORTH_DSP_VALUE 
44fd 23					inc hl      ; now at start of numeric as string 
44fe			 
44fe			;		push hl 
44fe			 
44fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44fe cd 86 1f			call macro_forth_dsp_pop 
4501				endm 
# End of macro FORTH_DSP_POP
4501			 
4501			;		pop hl 
4501			 
4501					; push the content of a onto the stack as a value 
4501			 
4501 7e					ld a,(hl)   ; get char 
4502 26 00				ld h,0 
4504 6f					ld l,a 
4505 cd d7 1c				call forth_push_numhl 
4508			 
4508				       NEXTW 
4508 c3 40 20			jp macro_next 
450b				endm 
# End of macro NEXTW
450b			 
450b			 
450b			 
450b			 
450b			.ENDSTR: 
450b			; eof 
450b			 
# End of file forth_words_str.asm
450b			include "forth_words_key.asm" 
450b			 
450b			; | ## Keyboard Words 
450b			 
450b			.KEY: 
450b				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
450b 3e				db WORD_SYS_CORE+42             
450c 3b 45			dw .WAITK            
450e 04				db 3 + 1 
450f .. 00			db "KEY",0              
4513				endm 
# End of macro CWHEAD
4513			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4513			 
4513					if DEBUG_FORTH_WORDS_KEY 
4513						DMARK "KEY" 
4513 f5				push af  
4514 3a 28 45			ld a, (.dmark)  
4517 32 bd fb			ld (debug_mark),a  
451a 3a 29 45			ld a, (.dmark+1)  
451d 32 be fb			ld (debug_mark+1),a  
4520 3a 2a 45			ld a, (.dmark+2)  
4523 32 bf fb			ld (debug_mark+2),a  
4526 18 03			jr .pastdmark  
4528 ..			.dmark: db "KEY"  
452b f1			.pastdmark: pop af  
452c			endm  
# End of macro DMARK
452c						CALLMONITOR 
452c cd 47 17			call break_point_state  
452f				endm  
# End of macro CALLMONITOR
452f					endif 
452f			; TODO currently waits 
452f cd 69 67				call cin 
4532					;call cin_wait 
4532 6f					ld l, a 
4533 26 00				ld h, 0 
4535 cd d7 1c				call forth_push_numhl 
4538					NEXTW 
4538 c3 40 20			jp macro_next 
453b				endm 
# End of macro NEXTW
453b			.WAITK: 
453b				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
453b 3f				db WORD_SYS_CORE+43             
453c 6d 45			dw .ACCEPT            
453e 06				db 5 + 1 
453f .. 00			db "WAITK",0              
4545				endm 
# End of macro CWHEAD
4545			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4545					if DEBUG_FORTH_WORDS_KEY 
4545						DMARK "WAI" 
4545 f5				push af  
4546 3a 5a 45			ld a, (.dmark)  
4549 32 bd fb			ld (debug_mark),a  
454c 3a 5b 45			ld a, (.dmark+1)  
454f 32 be fb			ld (debug_mark+1),a  
4552 3a 5c 45			ld a, (.dmark+2)  
4555 32 bf fb			ld (debug_mark+2),a  
4558 18 03			jr .pastdmark  
455a ..			.dmark: db "WAI"  
455d f1			.pastdmark: pop af  
455e			endm  
# End of macro DMARK
455e						CALLMONITOR 
455e cd 47 17			call break_point_state  
4561				endm  
# End of macro CALLMONITOR
4561					endif 
4561 cd 58 67				call cin_wait 
4564 6f					ld l, a 
4565 26 00				ld h, 0 
4567 cd d7 1c				call forth_push_numhl 
456a					NEXTW 
456a c3 40 20			jp macro_next 
456d				endm 
# End of macro NEXTW
456d			.ACCEPT: 
456d				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
456d 40				db WORD_SYS_CORE+44             
456e cb 45			dw .EDIT            
4570 07				db 6 + 1 
4571 .. 00			db "ACCEPT",0              
4578				endm 
# End of macro CWHEAD
4578			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4578					; TODO crashes on push 
4578					if DEBUG_FORTH_WORDS_KEY 
4578						DMARK "ACC" 
4578 f5				push af  
4579 3a 8d 45			ld a, (.dmark)  
457c 32 bd fb			ld (debug_mark),a  
457f 3a 8e 45			ld a, (.dmark+1)  
4582 32 be fb			ld (debug_mark+1),a  
4585 3a 8f 45			ld a, (.dmark+2)  
4588 32 bf fb			ld (debug_mark+2),a  
458b 18 03			jr .pastdmark  
458d ..			.dmark: db "ACC"  
4590 f1			.pastdmark: pop af  
4591			endm  
# End of macro DMARK
4591						CALLMONITOR 
4591 cd 47 17			call break_point_state  
4594				endm  
# End of macro CALLMONITOR
4594					endif 
4594 21 a1 f1				ld hl, os_input 
4597 3e 00				ld a, 0 
4599 77					ld (hl),a 
459a 3a cc f9				ld a,(f_cursor_ptr) 
459d 16 64				ld d, 100 
459f 0e 00				ld c, 0 
45a1 1e 28				ld e, 40 
45a3 cd 4a 0d				call input_str 
45a6					; TODO perhaps do a type check and wrap in quotes if not a number 
45a6 21 a1 f1				ld hl, os_input 
45a9					if DEBUG_FORTH_WORDS 
45a9						DMARK "AC1" 
45a9 f5				push af  
45aa 3a be 45			ld a, (.dmark)  
45ad 32 bd fb			ld (debug_mark),a  
45b0 3a bf 45			ld a, (.dmark+1)  
45b3 32 be fb			ld (debug_mark+1),a  
45b6 3a c0 45			ld a, (.dmark+2)  
45b9 32 bf fb			ld (debug_mark+2),a  
45bc 18 03			jr .pastdmark  
45be ..			.dmark: db "AC1"  
45c1 f1			.pastdmark: pop af  
45c2			endm  
# End of macro DMARK
45c2						CALLMONITOR 
45c2 cd 47 17			call break_point_state  
45c5				endm  
# End of macro CALLMONITOR
45c5					endif 
45c5 cd 45 1d				call forth_push_str 
45c8					NEXTW 
45c8 c3 40 20			jp macro_next 
45cb				endm 
# End of macro NEXTW
45cb			 
45cb			.EDIT: 
45cb				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
45cb 40				db WORD_SYS_CORE+44             
45cc 6d 46			dw .ENDKEY            
45ce 05				db 4 + 1 
45cf .. 00			db "EDIT",0              
45d4				endm 
# End of macro CWHEAD
45d4			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
45d4			 
45d4					; TODO does not copy from stack 
45d4					if DEBUG_FORTH_WORDS_KEY 
45d4						DMARK "EDT" 
45d4 f5				push af  
45d5 3a e9 45			ld a, (.dmark)  
45d8 32 bd fb			ld (debug_mark),a  
45db 3a ea 45			ld a, (.dmark+1)  
45de 32 be fb			ld (debug_mark+1),a  
45e1 3a eb 45			ld a, (.dmark+2)  
45e4 32 bf fb			ld (debug_mark+2),a  
45e7 18 03			jr .pastdmark  
45e9 ..			.dmark: db "EDT"  
45ec f1			.pastdmark: pop af  
45ed			endm  
# End of macro DMARK
45ed						CALLMONITOR 
45ed cd 47 17			call break_point_state  
45f0				endm  
# End of macro CALLMONITOR
45f0					endif 
45f0			 
45f0					;FORTH_DSP 
45f0					FORTH_DSP_VALUEHL 
45f0 cd ce 1e			call macro_dsp_valuehl 
45f3				endm 
# End of macro FORTH_DSP_VALUEHL
45f3			;		inc hl    ; TODO do type check 
45f3			 
45f3			;		call get_word_hl 
45f3 e5					push hl 
45f4					if DEBUG_FORTH_WORDS 
45f4						DMARK "EDp" 
45f4 f5				push af  
45f5 3a 09 46			ld a, (.dmark)  
45f8 32 bd fb			ld (debug_mark),a  
45fb 3a 0a 46			ld a, (.dmark+1)  
45fe 32 be fb			ld (debug_mark+1),a  
4601 3a 0b 46			ld a, (.dmark+2)  
4604 32 bf fb			ld (debug_mark+2),a  
4607 18 03			jr .pastdmark  
4609 ..			.dmark: db "EDp"  
460c f1			.pastdmark: pop af  
460d			endm  
# End of macro DMARK
460d						CALLMONITOR 
460d cd 47 17			call break_point_state  
4610				endm  
# End of macro CALLMONITOR
4610					endif 
4610				;	ld a, 0 
4610 cd 7b 11				call strlenz 
4613 23					inc hl 
4614			 
4614 06 00				ld b, 0 
4616 4d					ld c, l 
4617			 
4617 e1					pop hl 
4618 11 a1 f1				ld de, os_input 
461b					if DEBUG_FORTH_WORDS_KEY 
461b						DMARK "EDc" 
461b f5				push af  
461c 3a 30 46			ld a, (.dmark)  
461f 32 bd fb			ld (debug_mark),a  
4622 3a 31 46			ld a, (.dmark+1)  
4625 32 be fb			ld (debug_mark+1),a  
4628 3a 32 46			ld a, (.dmark+2)  
462b 32 bf fb			ld (debug_mark+2),a  
462e 18 03			jr .pastdmark  
4630 ..			.dmark: db "EDc"  
4633 f1			.pastdmark: pop af  
4634			endm  
# End of macro DMARK
4634						CALLMONITOR 
4634 cd 47 17			call break_point_state  
4637				endm  
# End of macro CALLMONITOR
4637					endif 
4637 ed b0				ldir 
4639			 
4639			 
4639 21 a1 f1				ld hl, os_input 
463c					;ld a, 0 
463c					;ld (hl),a 
463c 3a cc f9				ld a,(f_cursor_ptr) 
463f 16 64				ld d, 100 
4641 0e 00				ld c, 0 
4643 1e 28				ld e, 40 
4645 cd 4a 0d				call input_str 
4648					; TODO perhaps do a type check and wrap in quotes if not a number 
4648 21 a1 f1				ld hl, os_input 
464b					if DEBUG_FORTH_WORDS 
464b						DMARK "ED1" 
464b f5				push af  
464c 3a 60 46			ld a, (.dmark)  
464f 32 bd fb			ld (debug_mark),a  
4652 3a 61 46			ld a, (.dmark+1)  
4655 32 be fb			ld (debug_mark+1),a  
4658 3a 62 46			ld a, (.dmark+2)  
465b 32 bf fb			ld (debug_mark+2),a  
465e 18 03			jr .pastdmark  
4660 ..			.dmark: db "ED1"  
4663 f1			.pastdmark: pop af  
4664			endm  
# End of macro DMARK
4664						CALLMONITOR 
4664 cd 47 17			call break_point_state  
4667				endm  
# End of macro CALLMONITOR
4667					endif 
4667 cd 45 1d				call forth_push_str 
466a					NEXTW 
466a c3 40 20			jp macro_next 
466d				endm 
# End of macro NEXTW
466d			 
466d			 
466d			 
466d			.ENDKEY: 
466d			; eof 
466d			 
# End of file forth_words_key.asm
466d			 
466d			if STORAGE_SE 
466d			   	include "forth_words_storage.asm" 
466d			 
466d			; | ## Fixed Storage Words 
466d			 
466d			 
466d			.BREAD: 
466d			  
466d				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
466d 3a				db WORD_SYS_CORE+38             
466e f0 46			dw .BWRITE            
4670 06				db 5 + 1 
4671 .. 00			db "BREAD",0              
4677				endm 
# End of macro CWHEAD
4677			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4677				 
4677					if DEBUG_FORTH_WORDS_KEY 
4677						DMARK "BRD" 
4677 f5				push af  
4678 3a 8c 46			ld a, (.dmark)  
467b 32 bd fb			ld (debug_mark),a  
467e 3a 8d 46			ld a, (.dmark+1)  
4681 32 be fb			ld (debug_mark+1),a  
4684 3a 8e 46			ld a, (.dmark+2)  
4687 32 bf fb			ld (debug_mark+2),a  
468a 18 03			jr .pastdmark  
468c ..			.dmark: db "BRD"  
468f f1			.pastdmark: pop af  
4690			endm  
# End of macro DMARK
4690						CALLMONITOR 
4690 cd 47 17			call break_point_state  
4693				endm  
# End of macro CALLMONITOR
4693					endif 
4693			 
4693				FORTH_DSP_VALUEHL 
4693 cd ce 1e			call macro_dsp_valuehl 
4696				endm 
# End of macro FORTH_DSP_VALUEHL
4696			 
4696				FORTH_DSP_POP 
4696 cd 86 1f			call macro_forth_dsp_pop 
4699				endm 
# End of macro FORTH_DSP_POP
4699			 
4699				; calc block address 
4699			 
4699 eb				ex de, hl 
469a 3e 40			ld a, STORE_BLOCK_PHY 
469c cd a0 0c			call Mult16 
469f			 
469f			 
469f 11 e8 f9			ld de, store_page 
46a2			 
46a2					if DEBUG_FORTH_WORDS 
46a2						DMARK "BR1" 
46a2 f5				push af  
46a3 3a b7 46			ld a, (.dmark)  
46a6 32 bd fb			ld (debug_mark),a  
46a9 3a b8 46			ld a, (.dmark+1)  
46ac 32 be fb			ld (debug_mark+1),a  
46af 3a b9 46			ld a, (.dmark+2)  
46b2 32 bf fb			ld (debug_mark+2),a  
46b5 18 03			jr .pastdmark  
46b7 ..			.dmark: db "BR1"  
46ba f1			.pastdmark: pop af  
46bb			endm  
# End of macro DMARK
46bb						CALLMONITOR 
46bb cd 47 17			call break_point_state  
46be				endm  
# End of macro CALLMONITOR
46be					endif 
46be			 
46be cd 09 03			call storage_read_block 
46c1			 
46c1 cd 46 0d			call ishlzero 
46c4 20 05			jr nz, .brfound 
46c6			 
46c6 cd d7 1c			call forth_push_numhl 
46c9 18 22			jr .brdone 
46cb			 
46cb			 
46cb			.brfound: 
46cb 21 ea f9		        ld hl, store_page+2 
46ce			 
46ce					if DEBUG_FORTH_WORDS 
46ce						DMARK "BR2" 
46ce f5				push af  
46cf 3a e3 46			ld a, (.dmark)  
46d2 32 bd fb			ld (debug_mark),a  
46d5 3a e4 46			ld a, (.dmark+1)  
46d8 32 be fb			ld (debug_mark+1),a  
46db 3a e5 46			ld a, (.dmark+2)  
46de 32 bf fb			ld (debug_mark+2),a  
46e1 18 03			jr .pastdmark  
46e3 ..			.dmark: db "BR2"  
46e6 f1			.pastdmark: pop af  
46e7			endm  
# End of macro DMARK
46e7						CALLMONITOR 
46e7 cd 47 17			call break_point_state  
46ea				endm  
# End of macro CALLMONITOR
46ea					endif 
46ea			 
46ea cd 45 1d			call forth_push_str 
46ed			 
46ed			 
46ed			.brdone: 
46ed			 
46ed					NEXTW 
46ed c3 40 20			jp macro_next 
46f0				endm 
# End of macro NEXTW
46f0			.BWRITE: 
46f0				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
46f0 3a				db WORD_SYS_CORE+38             
46f1 85 47			dw .BUPD            
46f3 07				db 6 + 1 
46f4 .. 00			db "BWRITE",0              
46fb				endm 
# End of macro CWHEAD
46fb			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
46fb			 
46fb					if DEBUG_FORTH_WORDS_KEY 
46fb						DMARK "BWR" 
46fb f5				push af  
46fc 3a 10 47			ld a, (.dmark)  
46ff 32 bd fb			ld (debug_mark),a  
4702 3a 11 47			ld a, (.dmark+1)  
4705 32 be fb			ld (debug_mark+1),a  
4708 3a 12 47			ld a, (.dmark+2)  
470b 32 bf fb			ld (debug_mark+2),a  
470e 18 03			jr .pastdmark  
4710 ..			.dmark: db "BWR"  
4713 f1			.pastdmark: pop af  
4714			endm  
# End of macro DMARK
4714						CALLMONITOR 
4714 cd 47 17			call break_point_state  
4717				endm  
# End of macro CALLMONITOR
4717					endif 
4717			 
4717				FORTH_DSP_VALUEHL 
4717 cd ce 1e			call macro_dsp_valuehl 
471a				endm 
# End of macro FORTH_DSP_VALUEHL
471a			 
471a				; calc block address 
471a			 
471a eb				ex de, hl 
471b 3e 40			ld a, STORE_BLOCK_PHY 
471d cd a0 0c			call Mult16 
4720			 
4720 e5				push hl         ; address 
4721			 
4721				FORTH_DSP_POP 
4721 cd 86 1f			call macro_forth_dsp_pop 
4724				endm 
# End of macro FORTH_DSP_POP
4724			 
4724				FORTH_DSP_VALUEHL 
4724 cd ce 1e			call macro_dsp_valuehl 
4727				endm 
# End of macro FORTH_DSP_VALUEHL
4727			 
4727				FORTH_DSP_POP 
4727 cd 86 1f			call macro_forth_dsp_pop 
472a				endm 
# End of macro FORTH_DSP_POP
472a			 
472a cd 29 0a			call storage_clear_page 
472d			 
472d				; copy string to store page 
472d			 
472d e5				push hl     ; save string address 
472e			 
472e 3e 00			ld a, 0 
4730 cd 86 11			call strlent 
4733			 
4733 23				inc hl 
4734			 
4734 4d				ld c, l 
4735 06 00			ld b, 0 
4737			 
4737 e1				pop hl 
4738 11 ea f9			ld de, store_page + 2 
473b					if DEBUG_FORTH_WORDS 
473b						DMARK "BW1" 
473b f5				push af  
473c 3a 50 47			ld a, (.dmark)  
473f 32 bd fb			ld (debug_mark),a  
4742 3a 51 47			ld a, (.dmark+1)  
4745 32 be fb			ld (debug_mark+1),a  
4748 3a 52 47			ld a, (.dmark+2)  
474b 32 bf fb			ld (debug_mark+2),a  
474e 18 03			jr .pastdmark  
4750 ..			.dmark: db "BW1"  
4753 f1			.pastdmark: pop af  
4754			endm  
# End of macro DMARK
4754						CALLMONITOR 
4754 cd 47 17			call break_point_state  
4757				endm  
# End of macro CALLMONITOR
4757					endif 
4757 ed b0			ldir 
4759			 
4759			 
4759				; poke the start of the block with flags to prevent high level file ops hitting the block 
4759			 
4759 21 ff ff			ld hl, $ffff 
475c			 
475c 22 e8 f9			ld (store_page), hl	 
475f				 
475f e1				pop hl    ; get address 
4760 11 e8 f9			ld de, store_page 
4763			 
4763					if DEBUG_FORTH_WORDS 
4763						DMARK "BW2" 
4763 f5				push af  
4764 3a 78 47			ld a, (.dmark)  
4767 32 bd fb			ld (debug_mark),a  
476a 3a 79 47			ld a, (.dmark+1)  
476d 32 be fb			ld (debug_mark+1),a  
4770 3a 7a 47			ld a, (.dmark+2)  
4773 32 bf fb			ld (debug_mark+2),a  
4776 18 03			jr .pastdmark  
4778 ..			.dmark: db "BW2"  
477b f1			.pastdmark: pop af  
477c			endm  
# End of macro DMARK
477c						CALLMONITOR 
477c cd 47 17			call break_point_state  
477f				endm  
# End of macro CALLMONITOR
477f					endif 
477f			 
477f cd 6e 03			call storage_write_block 
4782			 
4782					NEXTW 
4782 c3 40 20			jp macro_next 
4785				endm 
# End of macro NEXTW
4785			 
4785			.BUPD: 
4785				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4785 3a				db WORD_SYS_CORE+38             
4786 db 47			dw .BYID            
4788 05				db 4 + 1 
4789 .. 00			db "BUPD",0              
478e				endm 
# End of macro CWHEAD
478e			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
478e			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
478e			; | | or completely different file system structure. 
478e			 
478e					if DEBUG_FORTH_WORDS_KEY 
478e						DMARK "BUD" 
478e f5				push af  
478f 3a a3 47			ld a, (.dmark)  
4792 32 bd fb			ld (debug_mark),a  
4795 3a a4 47			ld a, (.dmark+1)  
4798 32 be fb			ld (debug_mark+1),a  
479b 3a a5 47			ld a, (.dmark+2)  
479e 32 bf fb			ld (debug_mark+2),a  
47a1 18 03			jr .pastdmark  
47a3 ..			.dmark: db "BUD"  
47a6 f1			.pastdmark: pop af  
47a7			endm  
# End of macro DMARK
47a7						CALLMONITOR 
47a7 cd 47 17			call break_point_state  
47aa				endm  
# End of macro CALLMONITOR
47aa					endif 
47aa			 
47aa				FORTH_DSP_VALUEHL 
47aa cd ce 1e			call macro_dsp_valuehl 
47ad				endm 
# End of macro FORTH_DSP_VALUEHL
47ad			 
47ad				; calc block address 
47ad			 
47ad eb				ex de, hl 
47ae 3e 40			ld a, STORE_BLOCK_PHY 
47b0 cd a0 0c			call Mult16 
47b3			 
47b3				FORTH_DSP_POP 
47b3 cd 86 1f			call macro_forth_dsp_pop 
47b6				endm 
# End of macro FORTH_DSP_POP
47b6			 
47b6			 
47b6 11 e8 f9			ld de, store_page 
47b9			 
47b9					if DEBUG_FORTH_WORDS 
47b9						DMARK "BUe" 
47b9 f5				push af  
47ba 3a ce 47			ld a, (.dmark)  
47bd 32 bd fb			ld (debug_mark),a  
47c0 3a cf 47			ld a, (.dmark+1)  
47c3 32 be fb			ld (debug_mark+1),a  
47c6 3a d0 47			ld a, (.dmark+2)  
47c9 32 bf fb			ld (debug_mark+2),a  
47cc 18 03			jr .pastdmark  
47ce ..			.dmark: db "BUe"  
47d1 f1			.pastdmark: pop af  
47d2			endm  
# End of macro DMARK
47d2						CALLMONITOR 
47d2 cd 47 17			call break_point_state  
47d5				endm  
# End of macro CALLMONITOR
47d5					endif 
47d5			 
47d5 cd 6e 03			call storage_write_block 
47d8			 
47d8					NEXTW 
47d8 c3 40 20			jp macro_next 
47db				endm 
# End of macro NEXTW
47db			 
47db			.BYID: 
47db			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
47db			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
47db			; 
47db			;		 
47db			;		if DEBUG_FORTH_WORDS_KEY 
47db			;			DMARK "BYID" 
47db			;			CALLMONITOR 
47db			;		endif 
47db			; 
47db			;		; get direct address 
47db			; 
47db			;		FORTH_DSP_VALUEHL 
47db			; 
47db			;		FORTH_DSP_POP 
47db			; 
47db			;	; calc block address 
47db			; 
47db			;	ex de, hl 
47db			;	ld a, STORE_BLOCK_PHY 
47db			;	call Mult16 
47db			;	;	do BREAD with number as param 
47db			;	; push the file name	 
47db			;	ld de, store_page 
47db			;	call storage_read_block 
47db			 ;       ld hl, store_page+2 
47db			; 
47db			; 
47db			;		NEXTW 
47db			;.BYNAME: 
47db			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
47db			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
47db			;		NEXTW 
47db			; 
47db			.DIR: 
47db				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
47db 3a				db WORD_SYS_CORE+38             
47dc df 48			dw .SAVE            
47de 04				db 3 + 1 
47df .. 00			db "DIR",0              
47e3				endm 
# End of macro CWHEAD
47e3			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
47e3			 
47e3					if DEBUG_FORTH_WORDS_KEY 
47e3						DMARK "DIR" 
47e3 f5				push af  
47e4 3a f8 47			ld a, (.dmark)  
47e7 32 bd fb			ld (debug_mark),a  
47ea 3a f9 47			ld a, (.dmark+1)  
47ed 32 be fb			ld (debug_mark+1),a  
47f0 3a fa 47			ld a, (.dmark+2)  
47f3 32 bf fb			ld (debug_mark+2),a  
47f6 18 03			jr .pastdmark  
47f8 ..			.dmark: db "DIR"  
47fb f1			.pastdmark: pop af  
47fc			endm  
# End of macro DMARK
47fc						CALLMONITOR 
47fc cd 47 17			call break_point_state  
47ff				endm  
# End of macro CALLMONITOR
47ff					endif 
47ff cd ba 03			call storage_get_block_0 
4802			 
4802 21 e8 f9			ld hl, store_page     ; get current id count 
4805 46				ld b, (hl) 
4806 0e 00			ld c, 0    ; count of files   
4808					if DEBUG_FORTH_WORDS 
4808						DMARK "DI1" 
4808 f5				push af  
4809 3a 1d 48			ld a, (.dmark)  
480c 32 bd fb			ld (debug_mark),a  
480f 3a 1e 48			ld a, (.dmark+1)  
4812 32 be fb			ld (debug_mark+1),a  
4815 3a 1f 48			ld a, (.dmark+2)  
4818 32 bf fb			ld (debug_mark+2),a  
481b 18 03			jr .pastdmark  
481d ..			.dmark: db "DI1"  
4820 f1			.pastdmark: pop af  
4821			endm  
# End of macro DMARK
4821						CALLMONITOR 
4821 cd 47 17			call break_point_state  
4824				endm  
# End of macro CALLMONITOR
4824					endif 
4824			 
4824				; check for empty drive 
4824			 
4824 3e 00			ld a, 0 
4826 b8				cp b 
4827 ca 95 48			jp z, .dirdone 
482a			 
482a				; for each of the current ids do a search for them and if found push to stack 
482a			 
482a c5			.diritem:	push bc 
482b 21 40 00				ld hl, STORE_BLOCK_PHY 
482e 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4830 58					ld e,b 
4831			 
4831			;		if DEBUG_FORTH_WORDS 
4831			;			DMARK "DI2" 
4831			;			CALLMONITOR 
4831			;		endif 
4831			 
4831 cd 2e 06				call storage_findnextid 
4834			 
4834			;		if DEBUG_FORTH_WORDS 
4834			;			DMARK "DI3" 
4834			;			CALLMONITOR 
4834			;		endif 
4834			 
4834					; if found hl will be non zero 
4834			 
4834 cd 46 0d				call ishlzero 
4837			;		ld a, l 
4837			;		add h 
4837			; 
4837			;		cp 0 
4837 28 59				jr z, .dirnotfound 
4839			 
4839					; increase count 
4839			 
4839 c1					pop bc	 
483a 0c					inc c 
483b c5					push bc 
483c					 
483c			 
483c					; get file header and push the file name 
483c			 
483c 11 e8 f9				ld de, store_page 
483f cd 09 03				call storage_read_block 
4842			 
4842					; push file id to stack 
4842				 
4842 3a e8 f9				ld a, (store_page) 
4845 26 00				ld h, 0 
4847 6f					ld l, a 
4848 cd d7 1c				call forth_push_numhl 
484b			 
484b					; push extent count to stack  
484b				 
484b 3a ea f9				ld a, (store_page+2) 
484e 26 00				ld h, 0 
4850 6f					ld l, a 
4851 cd d7 1c				call forth_push_numhl 
4854			 
4854					; push file name 
4854			 
4854 21 eb f9				ld hl, store_page+3 
4857					if DEBUG_FORTH_WORDS 
4857						DMARK "DI5" 
4857 f5				push af  
4858 3a 6c 48			ld a, (.dmark)  
485b 32 bd fb			ld (debug_mark),a  
485e 3a 6d 48			ld a, (.dmark+1)  
4861 32 be fb			ld (debug_mark+1),a  
4864 3a 6e 48			ld a, (.dmark+2)  
4867 32 bf fb			ld (debug_mark+2),a  
486a 18 03			jr .pastdmark  
486c ..			.dmark: db "DI5"  
486f f1			.pastdmark: pop af  
4870			endm  
# End of macro DMARK
4870						CALLMONITOR 
4870 cd 47 17			call break_point_state  
4873				endm  
# End of macro CALLMONITOR
4873					endif 
4873 cd 45 1d				call forth_push_str 
4876					if DEBUG_FORTH_WORDS 
4876						DMARK "DI6" 
4876 f5				push af  
4877 3a 8b 48			ld a, (.dmark)  
487a 32 bd fb			ld (debug_mark),a  
487d 3a 8c 48			ld a, (.dmark+1)  
4880 32 be fb			ld (debug_mark+1),a  
4883 3a 8d 48			ld a, (.dmark+2)  
4886 32 bf fb			ld (debug_mark+2),a  
4889 18 03			jr .pastdmark  
488b ..			.dmark: db "DI6"  
488e f1			.pastdmark: pop af  
488f			endm  
# End of macro DMARK
488f						CALLMONITOR 
488f cd 47 17			call break_point_state  
4892				endm  
# End of macro CALLMONITOR
4892					endif 
4892			.dirnotfound: 
4892 c1					pop bc     
4893 10 95				djnz .diritem 
4895				 
4895			.dirdone:	 
4895					if DEBUG_FORTH_WORDS 
4895						DMARK "DI7" 
4895 f5				push af  
4896 3a aa 48			ld a, (.dmark)  
4899 32 bd fb			ld (debug_mark),a  
489c 3a ab 48			ld a, (.dmark+1)  
489f 32 be fb			ld (debug_mark+1),a  
48a2 3a ac 48			ld a, (.dmark+2)  
48a5 32 bf fb			ld (debug_mark+2),a  
48a8 18 03			jr .pastdmark  
48aa ..			.dmark: db "DI7"  
48ad f1			.pastdmark: pop af  
48ae			endm  
# End of macro DMARK
48ae						CALLMONITOR 
48ae cd 47 17			call break_point_state  
48b1				endm  
# End of macro CALLMONITOR
48b1					endif 
48b1			 
48b1					; push a count of the dir items found 
48b1			 
48b1 26 00				ld h, 0 
48b3 69					ld l, c 
48b4 cd d7 1c				call forth_push_numhl 
48b7			 
48b7					; push the bank label 
48b7			 
48b7 cd ba 03				call storage_get_block_0 
48ba			 
48ba				 
48ba 21 eb f9		 		ld hl, store_page+3 
48bd			 
48bd					if DEBUG_FORTH_WORDS 
48bd						DMARK "DI8" 
48bd f5				push af  
48be 3a d2 48			ld a, (.dmark)  
48c1 32 bd fb			ld (debug_mark),a  
48c4 3a d3 48			ld a, (.dmark+1)  
48c7 32 be fb			ld (debug_mark+1),a  
48ca 3a d4 48			ld a, (.dmark+2)  
48cd 32 bf fb			ld (debug_mark+2),a  
48d0 18 03			jr .pastdmark  
48d2 ..			.dmark: db "DI8"  
48d5 f1			.pastdmark: pop af  
48d6			endm  
# End of macro DMARK
48d6						CALLMONITOR 
48d6 cd 47 17			call break_point_state  
48d9				endm  
# End of macro CALLMONITOR
48d9					endif 
48d9 cd 45 1d				call forth_push_str 
48dc			 
48dc			 
48dc				 
48dc					NEXTW 
48dc c3 40 20			jp macro_next 
48df				endm 
# End of macro NEXTW
48df			.SAVE: 
48df			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
48df			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
48df			;		NEXTW 
48df			;.LOAD: 
48df			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
48df			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
48df			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
48df			;; > > The LOAD command can not be used in any user words or compound lines. 
48df			; 
48df			;		; store_openext use it. If zero it is EOF 
48df			; 
48df			;		; read block from current stream id 
48df			;		; if the block does not contain zero term keep reading blocks until zero found 
48df			;		; push the block to stack 
48df			;		; save the block id to stream 
48df			; 
48df			; 
48df			;		FORTH_DSP_VALUEHL 
48df			; 
48df			;;		push hl 
48df			; 
48df			;	if DEBUG_STORESE 
48df			;		DMARK "LOA" 
48df			;		CALLMONITOR 
48df			;	endif 
48df			;		FORTH_DSP_POP 
48df			; 
48df			;;		pop hl 
48df			; 
48df			;		ld h, l 
48df			;		ld l, 0 
48df			; 
48df			;		push hl     ; stack holds current file id and extent to work with 
48df			; 
48df			; 
48df			;		ld de, store_page      ; get block zero of file 
48df			;	if DEBUG_STORESE 
48df			;		DMARK "LO0" 
48df			;		CALLMONITOR 
48df			;	endif 
48df			;		call storage_read 
48df			; 
48df			;		ld a, (store_page+2)    ; max extents for this file 
48df			;		ld  (store_openmaxext),a   ; get our limit 
48df			; 
48df			;	if DEBUG_STORESE 
48df			;		DMARK "LOE" 
48df			;		CALLMONITOR 
48df			;	endif 
48df			; 
48df			;; TODO dont know why max extents are not present 
48df			;;		cp 0 
48df			;;		jp z, .loadeof     ; dont read past eof 
48df			; 
48df			;;		ld a, 1   ; start from the head of the file 
48df			; 
48df			;.loadline:	pop hl 
48df			;		inc hl 
48df			;		ld  a, (store_openmaxext)   ; get our limit 
48df			;	if DEBUG_STORESE 
48df			;		DMARK "LOx" 
48df			;		CALLMONITOR 
48df			;	endif 
48df			;		inc a 
48df			;		cp l 
48df			;		jp z, .loadeof 
48df			;		push hl    ; save current extent 
48df			; 
48df			;		ld de, store_page 
48df			; 
48df			;	if DEBUG_STORESE 
48df			;		DMARK "LO1" 
48df			;		CALLMONITOR 
48df			;	endif 
48df			;		call storage_read 
48df			; 
48df			;	if DEBUG_STORESE 
48df			;		DMARK "LO2" 
48df			;		CALLMONITOR 
48df			;	endif 
48df			;	call ishlzero 
48df			;	ld a, l 
48df			;	add h 
48df			;	cp 0 
48df			;	jr z, .loadeof 
48df			; 
48df			;	; not eof so hl should point to data to exec 
48df			; 
48df			;	; will need to add the FORTH_END_BUFFER flag 
48df			 ; 
48df			;	ld hl, store_page+2 
48df			;	ld bc, 255 
48df			;	ld a, 0 
48df			;	cpir 
48df			;	if DEBUG_STORESE 
48df			;		DMARK "LOt" 
48df			;		CALLMONITOR 
48df			;	endif 
48df			;	dec hl 
48df			;	ld a, ' ' 
48df			;	ld (hl), a 
48df			;	inc hl 
48df			;	ld (hl), a 
48df			;	inc hl 
48df			;	ld (hl), a 
48df			;	inc hl 
48df			;	ld a, FORTH_END_BUFFER 
48df			;	ld (hl), a 
48df			; 
48df			;	; TODO handle more than a single block read 
48df			; 
48df			; 
48df			;	ld hl, store_page+2 
48df			; 
48df			;	ld (os_tok_ptr), hl 
48df			; 
48df			;	if DEBUG_STORESE 
48df			;		DMARK "LO3" 
48df			;		CALLMONITOR 
48df			;	endif 
48df			; 
48df			;	call forthparse 
48df			;	call forthexec 
48df			;	call forthexec_cleanup 
48df			; 
48df			;	; go to next extent 
48df			; 
48df			;	; get next block  or mark as eof 
48df			;	jp .loadline 
48df			; 
48df			; 
48df			; 
48df			;	       NEXTW 
48df			;.loadeof:	ld a, 0 
48df			;		ld (store_openext), a 
48df			; 
48df			;	if DEBUG_STORESE 
48df			;		DMARK "LOF" 
48df			;		CALLMONITOR 
48df			;	endif 
48df			;		ret 
48df			;		;NEXTW 
48df			;.BSAVE:   
48df			; 
48df			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
48df			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
48df			;		NEXTW 
48df			;.BLOAD: 
48df			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
48df			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
48df			;		NEXTW 
48df			;;;; counter gap 
48df			 
48df			 
48df			.SEO: 
48df				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
48df 64				db WORD_SYS_CORE+80             
48e0 fe 48			dw .SEI            
48e2 04				db 3 + 1 
48e3 .. 00			db "SEO",0              
48e7				endm 
# End of macro CWHEAD
48e7			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
48e7			 
48e7					; get port 
48e7			 
48e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48e7 cd ce 1e			call macro_dsp_valuehl 
48ea				endm 
# End of macro FORTH_DSP_VALUEHL
48ea			 
48ea e5					push hl    ; u2 - byte 
48eb			 
48eb					; destroy value TOS 
48eb			 
48eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48eb cd 86 1f			call macro_forth_dsp_pop 
48ee				endm 
# End of macro FORTH_DSP_POP
48ee			 
48ee					; get byte to send 
48ee			 
48ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48ee cd ce 1e			call macro_dsp_valuehl 
48f1				endm 
# End of macro FORTH_DSP_VALUEHL
48f1			 
48f1 e5					push hl    ; u1 - addr 
48f2			 
48f2					; destroy value TOS 
48f2			 
48f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48f2 cd 86 1f			call macro_forth_dsp_pop 
48f5				endm 
# End of macro FORTH_DSP_POP
48f5			 
48f5					; one value on hl get other one back 
48f5			 
48f5 d1					pop de   ; u1 - byte 
48f6			 
48f6 e1					pop hl   ; u2 - addr 
48f7			 
48f7					; TODO Send SPI byte 
48f7			 
48f7			 
48f7 7b					ld a, e 
48f8 cd e7 01				call se_writebyte 
48fb			 
48fb					 
48fb			 
48fb					NEXTW 
48fb c3 40 20			jp macro_next 
48fe				endm 
# End of macro NEXTW
48fe			 
48fe			.SEI: 
48fe				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
48fe 65				db WORD_SYS_CORE+81             
48ff 18 49			dw .SFREE            
4901 04				db 3 + 1 
4902 .. 00			db "SEI",0              
4906				endm 
# End of macro CWHEAD
4906			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4906			 
4906					; get port 
4906			 
4906					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4906 cd ce 1e			call macro_dsp_valuehl 
4909				endm 
# End of macro FORTH_DSP_VALUEHL
4909			 
4909			;		push hl 
4909			 
4909					; destroy value TOS 
4909			 
4909					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4909 cd 86 1f			call macro_forth_dsp_pop 
490c				endm 
# End of macro FORTH_DSP_POP
490c			 
490c					; one value on hl get other one back 
490c			 
490c			;		pop hl 
490c			 
490c			 
490c					; TODO Get SPI byte 
490c			 
490c cd 89 02				call se_readbyte 
490f			 
490f 26 00				ld h, 0 
4911 6f					ld l, a 
4912 cd d7 1c				call forth_push_numhl 
4915			 
4915					NEXTW 
4915 c3 40 20			jp macro_next 
4918				endm 
# End of macro NEXTW
4918			 
4918			.SFREE: 
4918				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4918 67				db WORD_SYS_CORE+83             
4919 47 49			dw .SIZE            
491b 06				db 5 + 1 
491c .. 00			db "FFREE",0              
4922				endm 
# End of macro CWHEAD
4922			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4922					if DEBUG_FORTH_WORDS_KEY 
4922						DMARK "FFR" 
4922 f5				push af  
4923 3a 37 49			ld a, (.dmark)  
4926 32 bd fb			ld (debug_mark),a  
4929 3a 38 49			ld a, (.dmark+1)  
492c 32 be fb			ld (debug_mark+1),a  
492f 3a 39 49			ld a, (.dmark+2)  
4932 32 bf fb			ld (debug_mark+2),a  
4935 18 03			jr .pastdmark  
4937 ..			.dmark: db "FFR"  
493a f1			.pastdmark: pop af  
493b			endm  
# End of macro DMARK
493b						CALLMONITOR 
493b cd 47 17			call break_point_state  
493e				endm  
# End of macro CALLMONITOR
493e					endif 
493e			 
493e cd c8 06				call storage_freeblocks 
4941			 
4941 cd d7 1c				call forth_push_numhl 
4944			 
4944				       NEXTW 
4944 c3 40 20			jp macro_next 
4947				endm 
# End of macro NEXTW
4947			.SIZE: 
4947				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4947 67				db WORD_SYS_CORE+83             
4948 7b 49			dw .CREATE            
494a 05				db 4 + 1 
494b .. 00			db "SIZE",0              
4950				endm 
# End of macro CWHEAD
4950			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4950					if DEBUG_FORTH_WORDS_KEY 
4950						DMARK "SIZ" 
4950 f5				push af  
4951 3a 65 49			ld a, (.dmark)  
4954 32 bd fb			ld (debug_mark),a  
4957 3a 66 49			ld a, (.dmark+1)  
495a 32 be fb			ld (debug_mark+1),a  
495d 3a 67 49			ld a, (.dmark+2)  
4960 32 bf fb			ld (debug_mark+2),a  
4963 18 03			jr .pastdmark  
4965 ..			.dmark: db "SIZ"  
4968 f1			.pastdmark: pop af  
4969			endm  
# End of macro DMARK
4969						CALLMONITOR 
4969 cd 47 17			call break_point_state  
496c				endm  
# End of macro CALLMONITOR
496c					endif 
496c			 
496c					FORTH_DSP_VALUEHL 
496c cd ce 1e			call macro_dsp_valuehl 
496f				endm 
# End of macro FORTH_DSP_VALUEHL
496f			;		push hl 
496f					FORTH_DSP_POP 
496f cd 86 1f			call macro_forth_dsp_pop 
4972				endm 
# End of macro FORTH_DSP_POP
4972			;		pop hl 
4972 cd 38 03				call storage_file_size 
4975			 
4975 cd d7 1c				call forth_push_numhl 
4978			  
4978			 
4978				       NEXTW 
4978 c3 40 20			jp macro_next 
497b				endm 
# End of macro NEXTW
497b			 
497b			.CREATE: 
497b				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
497b 68				db WORD_SYS_CORE+84             
497c e9 49			dw .APPEND            
497e 07				db 6 + 1 
497f .. 00			db "CREATE",0              
4986				endm 
# End of macro CWHEAD
4986			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4986			; | | e.g.  
4986			; | | TestProgram CREATE 
4986			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4986			; | |  
4986			; | | Max file IDs are 255. 
4986			; | |  
4986					 
4986					if DEBUG_FORTH_WORDS_KEY 
4986						DMARK "CRT" 
4986 f5				push af  
4987 3a 9b 49			ld a, (.dmark)  
498a 32 bd fb			ld (debug_mark),a  
498d 3a 9c 49			ld a, (.dmark+1)  
4990 32 be fb			ld (debug_mark+1),a  
4993 3a 9d 49			ld a, (.dmark+2)  
4996 32 bf fb			ld (debug_mark+2),a  
4999 18 03			jr .pastdmark  
499b ..			.dmark: db "CRT"  
499e f1			.pastdmark: pop af  
499f			endm  
# End of macro DMARK
499f						CALLMONITOR 
499f cd 47 17			call break_point_state  
49a2				endm  
# End of macro CALLMONITOR
49a2					endif 
49a2			;		call storage_get_block_0 
49a2			 
49a2					; TODO pop hl 
49a2			 
49a2					;v5 FORTH_DSP_VALUE 
49a2					FORTH_DSP_VALUE 
49a2 cd b7 1e			call macro_forth_dsp_value 
49a5				endm 
# End of macro FORTH_DSP_VALUE
49a5			 
49a5				if DEBUG_STORESE 
49a5					DMARK "CR1" 
49a5 f5				push af  
49a6 3a ba 49			ld a, (.dmark)  
49a9 32 bd fb			ld (debug_mark),a  
49ac 3a bb 49			ld a, (.dmark+1)  
49af 32 be fb			ld (debug_mark+1),a  
49b2 3a bc 49			ld a, (.dmark+2)  
49b5 32 bf fb			ld (debug_mark+2),a  
49b8 18 03			jr .pastdmark  
49ba ..			.dmark: db "CR1"  
49bd f1			.pastdmark: pop af  
49be			endm  
# End of macro DMARK
49be					CALLMONITOR 
49be cd 47 17			call break_point_state  
49c1				endm  
# End of macro CALLMONITOR
49c1				endif 
49c1			;		push hl 
49c1			;		FORTH_DSP_POP 
49c1			;		pop hl 
49c1			 
49c1			;		inc hl   ; move past the type marker 
49c1			 
49c1 cd fe 06				call storage_create 
49c4			 
49c4				if DEBUG_STORESE 
49c4					DMARK "CT1" 
49c4 f5				push af  
49c5 3a d9 49			ld a, (.dmark)  
49c8 32 bd fb			ld (debug_mark),a  
49cb 3a da 49			ld a, (.dmark+1)  
49ce 32 be fb			ld (debug_mark+1),a  
49d1 3a db 49			ld a, (.dmark+2)  
49d4 32 bf fb			ld (debug_mark+2),a  
49d7 18 03			jr .pastdmark  
49d9 ..			.dmark: db "CT1"  
49dc f1			.pastdmark: pop af  
49dd			endm  
# End of macro DMARK
49dd					CALLMONITOR 
49dd cd 47 17			call break_point_state  
49e0				endm  
# End of macro CALLMONITOR
49e0				endif 
49e0			;		push hl 
49e0					FORTH_DSP_POP 
49e0 cd 86 1f			call macro_forth_dsp_pop 
49e3				endm 
# End of macro FORTH_DSP_POP
49e3			;		pop hl 
49e3					; push file id to stack 
49e3 cd d7 1c				call forth_push_numhl 
49e6			 
49e6			 
49e6			 
49e6				       NEXTW 
49e6 c3 40 20			jp macro_next 
49e9				endm 
# End of macro NEXTW
49e9			 
49e9			.APPEND: 
49e9				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
49e9 69				db WORD_SYS_CORE+85             
49ea 7a 4a			dw .SDEL            
49ec 07				db 6 + 1 
49ed .. 00			db "APPEND",0              
49f4				endm 
# End of macro CWHEAD
49f4			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
49f4			; | | e.g. 
49f4			; | | Test CREATE      -> $01 
49f4			; | | "A string to add to file" $01 APPEND 
49f4			; | |  
49f4			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
49f4					if DEBUG_FORTH_WORDS_KEY 
49f4						DMARK "APP" 
49f4 f5				push af  
49f5 3a 09 4a			ld a, (.dmark)  
49f8 32 bd fb			ld (debug_mark),a  
49fb 3a 0a 4a			ld a, (.dmark+1)  
49fe 32 be fb			ld (debug_mark+1),a  
4a01 3a 0b 4a			ld a, (.dmark+2)  
4a04 32 bf fb			ld (debug_mark+2),a  
4a07 18 03			jr .pastdmark  
4a09 ..			.dmark: db "APP"  
4a0c f1			.pastdmark: pop af  
4a0d			endm  
# End of macro DMARK
4a0d						CALLMONITOR 
4a0d cd 47 17			call break_point_state  
4a10				endm  
# End of macro CALLMONITOR
4a10					endif 
4a10			 
4a10					FORTH_DSP_VALUEHL 
4a10 cd ce 1e			call macro_dsp_valuehl 
4a13				endm 
# End of macro FORTH_DSP_VALUEHL
4a13 e5					push hl 	; save file id 
4a14			 
4a14				if DEBUG_STORESE 
4a14					DMARK "AP1" 
4a14 f5				push af  
4a15 3a 29 4a			ld a, (.dmark)  
4a18 32 bd fb			ld (debug_mark),a  
4a1b 3a 2a 4a			ld a, (.dmark+1)  
4a1e 32 be fb			ld (debug_mark+1),a  
4a21 3a 2b 4a			ld a, (.dmark+2)  
4a24 32 bf fb			ld (debug_mark+2),a  
4a27 18 03			jr .pastdmark  
4a29 ..			.dmark: db "AP1"  
4a2c f1			.pastdmark: pop af  
4a2d			endm  
# End of macro DMARK
4a2d					CALLMONITOR 
4a2d cd 47 17			call break_point_state  
4a30				endm  
# End of macro CALLMONITOR
4a30				endif 
4a30					FORTH_DSP_POP 
4a30 cd 86 1f			call macro_forth_dsp_pop 
4a33				endm 
# End of macro FORTH_DSP_POP
4a33			 
4a33					FORTH_DSP_VALUEHL 
4a33 cd ce 1e			call macro_dsp_valuehl 
4a36				endm 
# End of macro FORTH_DSP_VALUEHL
4a36					;v5 FORTH_DSP_VALUE 
4a36 e5					push hl 	; save ptr to string to save 
4a37			 
4a37				if DEBUG_STORESE 
4a37					DMARK "AP1" 
4a37 f5				push af  
4a38 3a 4c 4a			ld a, (.dmark)  
4a3b 32 bd fb			ld (debug_mark),a  
4a3e 3a 4d 4a			ld a, (.dmark+1)  
4a41 32 be fb			ld (debug_mark+1),a  
4a44 3a 4e 4a			ld a, (.dmark+2)  
4a47 32 bf fb			ld (debug_mark+2),a  
4a4a 18 03			jr .pastdmark  
4a4c ..			.dmark: db "AP1"  
4a4f f1			.pastdmark: pop af  
4a50			endm  
# End of macro DMARK
4a50					CALLMONITOR 
4a50 cd 47 17			call break_point_state  
4a53				endm  
# End of macro CALLMONITOR
4a53				endif 
4a53					FORTH_DSP_POP 
4a53 cd 86 1f			call macro_forth_dsp_pop 
4a56				endm 
# End of macro FORTH_DSP_POP
4a56			 
4a56 d1					pop de 
4a57 e1					pop hl 
4a58				if DEBUG_STORESE 
4a58					DMARK "AP2" 
4a58 f5				push af  
4a59 3a 6d 4a			ld a, (.dmark)  
4a5c 32 bd fb			ld (debug_mark),a  
4a5f 3a 6e 4a			ld a, (.dmark+1)  
4a62 32 be fb			ld (debug_mark+1),a  
4a65 3a 6f 4a			ld a, (.dmark+2)  
4a68 32 bf fb			ld (debug_mark+2),a  
4a6b 18 03			jr .pastdmark  
4a6d ..			.dmark: db "AP2"  
4a70 f1			.pastdmark: pop af  
4a71			endm  
# End of macro DMARK
4a71					CALLMONITOR 
4a71 cd 47 17			call break_point_state  
4a74				endm  
# End of macro CALLMONITOR
4a74				endif 
4a74					;inc de ; skip var type indicator 
4a74			 
4a74					; TODO how to append numerics???? 
4a74			 
4a74 cd dd 08				call storage_append		 
4a77			 
4a77				       NEXTW 
4a77 c3 40 20			jp macro_next 
4a7a				endm 
# End of macro NEXTW
4a7a			.SDEL: 
4a7a				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a7a 6a				db WORD_SYS_CORE+86             
4a7b c6 4a			dw .OPEN            
4a7d 05				db 4 + 1 
4a7e .. 00			db "ERA",0              
4a82				endm 
# End of macro CWHEAD
4a82			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4a82					FORTH_DSP_VALUEHL 
4a82 cd ce 1e			call macro_dsp_valuehl 
4a85				endm 
# End of macro FORTH_DSP_VALUEHL
4a85			;		push hl 	; save file id 
4a85			 
4a85					if DEBUG_FORTH_WORDS_KEY 
4a85						DMARK "ERA" 
4a85 f5				push af  
4a86 3a 9a 4a			ld a, (.dmark)  
4a89 32 bd fb			ld (debug_mark),a  
4a8c 3a 9b 4a			ld a, (.dmark+1)  
4a8f 32 be fb			ld (debug_mark+1),a  
4a92 3a 9c 4a			ld a, (.dmark+2)  
4a95 32 bf fb			ld (debug_mark+2),a  
4a98 18 03			jr .pastdmark  
4a9a ..			.dmark: db "ERA"  
4a9d f1			.pastdmark: pop af  
4a9e			endm  
# End of macro DMARK
4a9e						CALLMONITOR 
4a9e cd 47 17			call break_point_state  
4aa1				endm  
# End of macro CALLMONITOR
4aa1					endif 
4aa1				if DEBUG_STORESE 
4aa1					DMARK "ER1" 
4aa1 f5				push af  
4aa2 3a b6 4a			ld a, (.dmark)  
4aa5 32 bd fb			ld (debug_mark),a  
4aa8 3a b7 4a			ld a, (.dmark+1)  
4aab 32 be fb			ld (debug_mark+1),a  
4aae 3a b8 4a			ld a, (.dmark+2)  
4ab1 32 bf fb			ld (debug_mark+2),a  
4ab4 18 03			jr .pastdmark  
4ab6 ..			.dmark: db "ER1"  
4ab9 f1			.pastdmark: pop af  
4aba			endm  
# End of macro DMARK
4aba					CALLMONITOR 
4aba cd 47 17			call break_point_state  
4abd				endm  
# End of macro CALLMONITOR
4abd				endif 
4abd					FORTH_DSP_POP 
4abd cd 86 1f			call macro_forth_dsp_pop 
4ac0				endm 
# End of macro FORTH_DSP_POP
4ac0			 
4ac0			;		pop hl 
4ac0			 
4ac0 cd 49 05				call storage_erase 
4ac3				       NEXTW 
4ac3 c3 40 20			jp macro_next 
4ac6				endm 
# End of macro NEXTW
4ac6			 
4ac6			.OPEN: 
4ac6				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4ac6 6b				db WORD_SYS_CORE+87             
4ac7 56 4b			dw .READ            
4ac9 05				db 4 + 1 
4aca .. 00			db "OPEN",0              
4acf				endm 
# End of macro CWHEAD
4acf			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4acf			; | | e.g. 
4acf			; | | $01 OPEN $01 DO $01 READ . LOOP 
4acf			; | | 
4acf			; | | Will return with 255 blocks if the file does not exist 
4acf			 
4acf					if DEBUG_FORTH_WORDS_KEY 
4acf						DMARK "OPN" 
4acf f5				push af  
4ad0 3a e4 4a			ld a, (.dmark)  
4ad3 32 bd fb			ld (debug_mark),a  
4ad6 3a e5 4a			ld a, (.dmark+1)  
4ad9 32 be fb			ld (debug_mark+1),a  
4adc 3a e6 4a			ld a, (.dmark+2)  
4adf 32 bf fb			ld (debug_mark+2),a  
4ae2 18 03			jr .pastdmark  
4ae4 ..			.dmark: db "OPN"  
4ae7 f1			.pastdmark: pop af  
4ae8			endm  
# End of macro DMARK
4ae8						CALLMONITOR 
4ae8 cd 47 17			call break_point_state  
4aeb				endm  
# End of macro CALLMONITOR
4aeb					endif 
4aeb					; TODO handle multiple file opens 
4aeb			 
4aeb 3e 01			       	ld a, 1 
4aed 32 df f9				ld (store_openext), a 
4af0			 
4af0					; get max extents for this file 
4af0				 
4af0								 
4af0					FORTH_DSP_VALUEHL 
4af0 cd ce 1e			call macro_dsp_valuehl 
4af3				endm 
# End of macro FORTH_DSP_VALUEHL
4af3			 
4af3 65					ld h, l 
4af4 2e 00				ld l, 0 
4af6			 
4af6				if DEBUG_STORESE 
4af6					DMARK "OPN" 
4af6 f5				push af  
4af7 3a 0b 4b			ld a, (.dmark)  
4afa 32 bd fb			ld (debug_mark),a  
4afd 3a 0c 4b			ld a, (.dmark+1)  
4b00 32 be fb			ld (debug_mark+1),a  
4b03 3a 0d 4b			ld a, (.dmark+2)  
4b06 32 bf fb			ld (debug_mark+2),a  
4b09 18 03			jr .pastdmark  
4b0b ..			.dmark: db "OPN"  
4b0e f1			.pastdmark: pop af  
4b0f			endm  
# End of macro DMARK
4b0f					CALLMONITOR 
4b0f cd 47 17			call break_point_state  
4b12				endm  
# End of macro CALLMONITOR
4b12				endif 
4b12			;		push hl 
4b12					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b12 cd 86 1f			call macro_forth_dsp_pop 
4b15				endm 
# End of macro FORTH_DSP_POP
4b15			;		pop hl 
4b15						 
4b15 11 e8 f9				ld de, store_page      ; get block zero of file 
4b18 cd 54 08				call storage_read 
4b1b cd 46 0d			call ishlzero 
4b1e 20 04			jr nz, .opfound 
4b20			 
4b20				; file does not exist so indicate with 255 extents in use 
4b20			 
4b20 3e ff			ld a, 255 
4b22 18 29			jr .skipopeneof 
4b24			 
4b24			 
4b24			.opfound: 
4b24			 
4b24			 
4b24 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4b27 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4b2a					 
4b2a				if DEBUG_STORESE 
4b2a					DMARK "OPx" 
4b2a f5				push af  
4b2b 3a 3f 4b			ld a, (.dmark)  
4b2e 32 bd fb			ld (debug_mark),a  
4b31 3a 40 4b			ld a, (.dmark+1)  
4b34 32 be fb			ld (debug_mark+1),a  
4b37 3a 41 4b			ld a, (.dmark+2)  
4b3a 32 bf fb			ld (debug_mark+2),a  
4b3d 18 03			jr .pastdmark  
4b3f ..			.dmark: db "OPx"  
4b42 f1			.pastdmark: pop af  
4b43			endm  
# End of macro DMARK
4b43					CALLMONITOR 
4b43 cd 47 17			call break_point_state  
4b46				endm  
# End of macro CALLMONITOR
4b46				endif 
4b46 fe 00				cp 0 
4b48 20 03				jr nz, .skipopeneof 
4b4a					; have opened an empty file 
4b4a					 
4b4a 32 df f9				ld (store_openext), a 
4b4d			 
4b4d			.skipopeneof: 
4b4d			 
4b4d 6f					ld l, a 
4b4e 26 00				ld h, 0 
4b50 cd d7 1c				call forth_push_numhl 
4b53			 
4b53			 
4b53				       NEXTW 
4b53 c3 40 20			jp macro_next 
4b56				endm 
# End of macro NEXTW
4b56			.READ: 
4b56				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b56 6c				db WORD_SYS_CORE+88             
4b57 9d 4c			dw .EOF            
4b59 05				db 4 + 1 
4b5a .. 00			db "READ",0              
4b5f				endm 
# End of macro CWHEAD
4b5f			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b5f			; | | e.g. 
4b5f			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b5f			 
4b5f					if DEBUG_FORTH_WORDS_KEY 
4b5f						DMARK "REA" 
4b5f f5				push af  
4b60 3a 74 4b			ld a, (.dmark)  
4b63 32 bd fb			ld (debug_mark),a  
4b66 3a 75 4b			ld a, (.dmark+1)  
4b69 32 be fb			ld (debug_mark+1),a  
4b6c 3a 76 4b			ld a, (.dmark+2)  
4b6f 32 bf fb			ld (debug_mark+2),a  
4b72 18 03			jr .pastdmark  
4b74 ..			.dmark: db "REA"  
4b77 f1			.pastdmark: pop af  
4b78			endm  
# End of macro DMARK
4b78						CALLMONITOR 
4b78 cd 47 17			call break_point_state  
4b7b				endm  
# End of macro CALLMONITOR
4b7b					endif 
4b7b					; store_openext use it. If zero it is EOF 
4b7b			 
4b7b					; read block from current stream id 
4b7b					; if the block does not contain zero term keep reading blocks until zero found 
4b7b					; push the block to stack 
4b7b					; save the block id to stream 
4b7b			 
4b7b			 
4b7b					FORTH_DSP_VALUEHL 
4b7b cd ce 1e			call macro_dsp_valuehl 
4b7e				endm 
# End of macro FORTH_DSP_VALUEHL
4b7e			 
4b7e			;		push hl 
4b7e			 
4b7e				if DEBUG_STORESE 
4b7e					DMARK "REA" 
4b7e f5				push af  
4b7f 3a 93 4b			ld a, (.dmark)  
4b82 32 bd fb			ld (debug_mark),a  
4b85 3a 94 4b			ld a, (.dmark+1)  
4b88 32 be fb			ld (debug_mark+1),a  
4b8b 3a 95 4b			ld a, (.dmark+2)  
4b8e 32 bf fb			ld (debug_mark+2),a  
4b91 18 03			jr .pastdmark  
4b93 ..			.dmark: db "REA"  
4b96 f1			.pastdmark: pop af  
4b97			endm  
# End of macro DMARK
4b97					CALLMONITOR 
4b97 cd 47 17			call break_point_state  
4b9a				endm  
# End of macro CALLMONITOR
4b9a				endif 
4b9a					FORTH_DSP_POP 
4b9a cd 86 1f			call macro_forth_dsp_pop 
4b9d				endm 
# End of macro FORTH_DSP_POP
4b9d			 
4b9d			;		pop hl 
4b9d				 
4b9d 65					ld h,l 
4b9e			 
4b9e 3a df f9				ld a, (store_openext) 
4ba1 6f					ld l, a 
4ba2					 
4ba2 fe 00				cp 0 
4ba4 ca 6f 4c				jp z, .ateof     ; dont read past eof 
4ba7			 
4ba7			 
4ba7 11 e8 f9				ld de, store_page 
4baa				if DEBUG_STORESE 
4baa					DMARK "RE1" 
4baa f5				push af  
4bab 3a bf 4b			ld a, (.dmark)  
4bae 32 bd fb			ld (debug_mark),a  
4bb1 3a c0 4b			ld a, (.dmark+1)  
4bb4 32 be fb			ld (debug_mark+1),a  
4bb7 3a c1 4b			ld a, (.dmark+2)  
4bba 32 bf fb			ld (debug_mark+2),a  
4bbd 18 03			jr .pastdmark  
4bbf ..			.dmark: db "RE1"  
4bc2 f1			.pastdmark: pop af  
4bc3			endm  
# End of macro DMARK
4bc3					CALLMONITOR 
4bc3 cd 47 17			call break_point_state  
4bc6				endm  
# End of macro CALLMONITOR
4bc6				endif 
4bc6 cd 54 08				call storage_read 
4bc9			 
4bc9				if DEBUG_STORESE 
4bc9					DMARK "RE2" 
4bc9 f5				push af  
4bca 3a de 4b			ld a, (.dmark)  
4bcd 32 bd fb			ld (debug_mark),a  
4bd0 3a df 4b			ld a, (.dmark+1)  
4bd3 32 be fb			ld (debug_mark+1),a  
4bd6 3a e0 4b			ld a, (.dmark+2)  
4bd9 32 bf fb			ld (debug_mark+2),a  
4bdc 18 03			jr .pastdmark  
4bde ..			.dmark: db "RE2"  
4be1 f1			.pastdmark: pop af  
4be2			endm  
# End of macro DMARK
4be2					CALLMONITOR 
4be2 cd 47 17			call break_point_state  
4be5				endm  
# End of macro CALLMONITOR
4be5				endif 
4be5 cd 46 0d			call ishlzero 
4be8			;	ld a, l 
4be8			;	add h 
4be8			;	cp 0 
4be8 ca 75 4c			jp z, .readeof 
4beb			 
4beb				; not eof so hl should point to data to push to stack 
4beb			 
4beb				if DEBUG_STORESE 
4beb					DMARK "RE3" 
4beb f5				push af  
4bec 3a 00 4c			ld a, (.dmark)  
4bef 32 bd fb			ld (debug_mark),a  
4bf2 3a 01 4c			ld a, (.dmark+1)  
4bf5 32 be fb			ld (debug_mark+1),a  
4bf8 3a 02 4c			ld a, (.dmark+2)  
4bfb 32 bf fb			ld (debug_mark+2),a  
4bfe 18 03			jr .pastdmark  
4c00 ..			.dmark: db "RE3"  
4c03 f1			.pastdmark: pop af  
4c04			endm  
# End of macro DMARK
4c04					CALLMONITOR 
4c04 cd 47 17			call break_point_state  
4c07				endm  
# End of macro CALLMONITOR
4c07				endif 
4c07 cd 45 1d			call forth_push_str 
4c0a			 
4c0a				if DEBUG_STORESE 
4c0a					DMARK "RE4" 
4c0a f5				push af  
4c0b 3a 1f 4c			ld a, (.dmark)  
4c0e 32 bd fb			ld (debug_mark),a  
4c11 3a 20 4c			ld a, (.dmark+1)  
4c14 32 be fb			ld (debug_mark+1),a  
4c17 3a 21 4c			ld a, (.dmark+2)  
4c1a 32 bf fb			ld (debug_mark+2),a  
4c1d 18 03			jr .pastdmark  
4c1f ..			.dmark: db "RE4"  
4c22 f1			.pastdmark: pop af  
4c23			endm  
# End of macro DMARK
4c23					CALLMONITOR 
4c23 cd 47 17			call break_point_state  
4c26				endm  
# End of macro CALLMONITOR
4c26				endif 
4c26				; get next block  or mark as eof 
4c26			 
4c26 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4c29 4f				ld c, a	 
4c2a 3a df f9			ld a, (store_openext) 
4c2d			 
4c2d				if DEBUG_STORESE 
4c2d					DMARK "RE5" 
4c2d f5				push af  
4c2e 3a 42 4c			ld a, (.dmark)  
4c31 32 bd fb			ld (debug_mark),a  
4c34 3a 43 4c			ld a, (.dmark+1)  
4c37 32 be fb			ld (debug_mark+1),a  
4c3a 3a 44 4c			ld a, (.dmark+2)  
4c3d 32 bf fb			ld (debug_mark+2),a  
4c40 18 03			jr .pastdmark  
4c42 ..			.dmark: db "RE5"  
4c45 f1			.pastdmark: pop af  
4c46			endm  
# End of macro DMARK
4c46					CALLMONITOR 
4c46 cd 47 17			call break_point_state  
4c49				endm  
# End of macro CALLMONITOR
4c49				endif 
4c49 b9				cp c 
4c4a 28 29			jr z, .readeof     ; at last extent 
4c4c			 
4c4c 3c					inc a 
4c4d 32 df f9				ld (store_openext), a 
4c50			 
4c50				if DEBUG_STORESE 
4c50					DMARK "RE6" 
4c50 f5				push af  
4c51 3a 65 4c			ld a, (.dmark)  
4c54 32 bd fb			ld (debug_mark),a  
4c57 3a 66 4c			ld a, (.dmark+1)  
4c5a 32 be fb			ld (debug_mark+1),a  
4c5d 3a 67 4c			ld a, (.dmark+2)  
4c60 32 bf fb			ld (debug_mark+2),a  
4c63 18 03			jr .pastdmark  
4c65 ..			.dmark: db "RE6"  
4c68 f1			.pastdmark: pop af  
4c69			endm  
# End of macro DMARK
4c69					CALLMONITOR 
4c69 cd 47 17			call break_point_state  
4c6c				endm  
# End of macro CALLMONITOR
4c6c				endif 
4c6c			 
4c6c			 
4c6c				       NEXTW 
4c6c c3 40 20			jp macro_next 
4c6f				endm 
# End of macro NEXTW
4c6f			.ateof: 
4c6f 21 99 4c				ld hl, .showeof 
4c72 cd 45 1d				call forth_push_str 
4c75 3e 00		.readeof:	ld a, 0 
4c77 32 df f9				ld (store_openext), a 
4c7a			 
4c7a					 
4c7a				if DEBUG_STORESE 
4c7a					DMARK "REF" 
4c7a f5				push af  
4c7b 3a 8f 4c			ld a, (.dmark)  
4c7e 32 bd fb			ld (debug_mark),a  
4c81 3a 90 4c			ld a, (.dmark+1)  
4c84 32 be fb			ld (debug_mark+1),a  
4c87 3a 91 4c			ld a, (.dmark+2)  
4c8a 32 bf fb			ld (debug_mark+2),a  
4c8d 18 03			jr .pastdmark  
4c8f ..			.dmark: db "REF"  
4c92 f1			.pastdmark: pop af  
4c93			endm  
# End of macro DMARK
4c93					CALLMONITOR 
4c93 cd 47 17			call break_point_state  
4c96				endm  
# End of macro CALLMONITOR
4c96				endif 
4c96				       NEXTW 
4c96 c3 40 20			jp macro_next 
4c99				endm 
# End of macro NEXTW
4c99			 
4c99 .. 00		.showeof:   db "eof", 0 
4c9d			 
4c9d			 
4c9d			.EOF: 
4c9d				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4c9d 6d				db WORD_SYS_CORE+89             
4c9e de 4c			dw .FORMAT            
4ca0 04				db 3 + 1 
4ca1 .. 00			db "EOF",0              
4ca5				endm 
# End of macro CWHEAD
4ca5			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4ca5			; | | e.g. 
4ca5			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4ca5					; TODO if current block id for stream is zero then push true else false 
4ca5			 
4ca5					if DEBUG_FORTH_WORDS_KEY 
4ca5						DMARK "EOF" 
4ca5 f5				push af  
4ca6 3a ba 4c			ld a, (.dmark)  
4ca9 32 bd fb			ld (debug_mark),a  
4cac 3a bb 4c			ld a, (.dmark+1)  
4caf 32 be fb			ld (debug_mark+1),a  
4cb2 3a bc 4c			ld a, (.dmark+2)  
4cb5 32 bf fb			ld (debug_mark+2),a  
4cb8 18 03			jr .pastdmark  
4cba ..			.dmark: db "EOF"  
4cbd f1			.pastdmark: pop af  
4cbe			endm  
# End of macro DMARK
4cbe						CALLMONITOR 
4cbe cd 47 17			call break_point_state  
4cc1				endm  
# End of macro CALLMONITOR
4cc1					endif 
4cc1			 
4cc1					; TODO handlue multiple file streams 
4cc1			 
4cc1					FORTH_DSP_POP     ; for now just get rid of stream id 
4cc1 cd 86 1f			call macro_forth_dsp_pop 
4cc4				endm 
# End of macro FORTH_DSP_POP
4cc4			 
4cc4 2e 01				ld l, 1 
4cc6 3a de f9				ld a, (store_openmaxext) 
4cc9 fe 00				cp 0 
4ccb 28 09				jr  z, .eofdone   ; empty file 
4ccd 3a df f9				ld a, (store_openext) 
4cd0 fe 00				cp 0 
4cd2 28 02				jr  z, .eofdone 
4cd4 2e 00				ld l, 0 
4cd6 26 00		.eofdone:	ld h, 0 
4cd8 cd d7 1c				call forth_push_numhl 
4cdb			 
4cdb			 
4cdb				       NEXTW 
4cdb c3 40 20			jp macro_next 
4cde				endm 
# End of macro NEXTW
4cde			 
4cde			.FORMAT: 
4cde				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4cde 6d				db WORD_SYS_CORE+89             
4cdf 2f 4d			dw .LABEL            
4ce1 07				db 6 + 1 
4ce2 .. 00			db "FORMAT",0              
4ce9				endm 
# End of macro CWHEAD
4ce9			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4ce9					; TODO if current block id for stream is zero then push true else false 
4ce9				 
4ce9				if DEBUG_STORESE 
4ce9					DMARK "FOR" 
4ce9 f5				push af  
4cea 3a fe 4c			ld a, (.dmark)  
4ced 32 bd fb			ld (debug_mark),a  
4cf0 3a ff 4c			ld a, (.dmark+1)  
4cf3 32 be fb			ld (debug_mark+1),a  
4cf6 3a 00 4d			ld a, (.dmark+2)  
4cf9 32 bf fb			ld (debug_mark+2),a  
4cfc 18 03			jr .pastdmark  
4cfe ..			.dmark: db "FOR"  
4d01 f1			.pastdmark: pop af  
4d02			endm  
# End of macro DMARK
4d02					CALLMONITOR 
4d02 cd 47 17			call break_point_state  
4d05				endm  
# End of macro CALLMONITOR
4d05				endif 
4d05					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d05			 
4d05 21 01 00				ld hl, 1 
4d08 3e 00				ld a, 0 
4d0a cd e7 01				call se_writebyte 
4d0d			 
4d0d				if DEBUG_STORESE 
4d0d					DMARK "FO0" 
4d0d f5				push af  
4d0e 3a 22 4d			ld a, (.dmark)  
4d11 32 bd fb			ld (debug_mark),a  
4d14 3a 23 4d			ld a, (.dmark+1)  
4d17 32 be fb			ld (debug_mark+1),a  
4d1a 3a 24 4d			ld a, (.dmark+2)  
4d1d 32 bf fb			ld (debug_mark+2),a  
4d20 18 03			jr .pastdmark  
4d22 ..			.dmark: db "FO0"  
4d25 f1			.pastdmark: pop af  
4d26			endm  
# End of macro DMARK
4d26					CALLMONITOR 
4d26 cd 47 17			call break_point_state  
4d29				endm  
# End of macro CALLMONITOR
4d29				endif 
4d29					; force bank init 
4d29			 
4d29 cd ba 03				call storage_get_block_0 
4d2c					 
4d2c				       NEXTW 
4d2c c3 40 20			jp macro_next 
4d2f				endm 
# End of macro NEXTW
4d2f			.LABEL: 
4d2f				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d2f 6d				db WORD_SYS_CORE+89             
4d30 7d 4d			dw .STOREPAGE            
4d32 06				db 5 + 1 
4d33 .. 00			db "LABEL",0              
4d39				endm 
# End of macro CWHEAD
4d39			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d39					; TODO test to see if bank is selected 
4d39				 
4d39					if DEBUG_FORTH_WORDS_KEY 
4d39						DMARK "LBL" 
4d39 f5				push af  
4d3a 3a 4e 4d			ld a, (.dmark)  
4d3d 32 bd fb			ld (debug_mark),a  
4d40 3a 4f 4d			ld a, (.dmark+1)  
4d43 32 be fb			ld (debug_mark+1),a  
4d46 3a 50 4d			ld a, (.dmark+2)  
4d49 32 bf fb			ld (debug_mark+2),a  
4d4c 18 03			jr .pastdmark  
4d4e ..			.dmark: db "LBL"  
4d51 f1			.pastdmark: pop af  
4d52			endm  
# End of macro DMARK
4d52						CALLMONITOR 
4d52 cd 47 17			call break_point_state  
4d55				endm  
# End of macro CALLMONITOR
4d55					endif 
4d55			;	if DEBUG_STORESE 
4d55			;		DMARK "LBL" 
4d55			;		CALLMONITOR 
4d55			;	endif 
4d55					FORTH_DSP_VALUEHL 
4d55 cd ce 1e			call macro_dsp_valuehl 
4d58				endm 
# End of macro FORTH_DSP_VALUEHL
4d58					;v5FORTH_DSP_VALUE 
4d58					 
4d58			;		push hl 
4d58					FORTH_DSP_POP 
4d58 cd 86 1f			call macro_forth_dsp_pop 
4d5b				endm 
# End of macro FORTH_DSP_POP
4d5b			;		pop hl 
4d5b			 
4d5b			;v5		inc hl   ; move past the type marker 
4d5b			 
4d5b				if DEBUG_STORESE 
4d5b					DMARK "LBl" 
4d5b f5				push af  
4d5c 3a 70 4d			ld a, (.dmark)  
4d5f 32 bd fb			ld (debug_mark),a  
4d62 3a 71 4d			ld a, (.dmark+1)  
4d65 32 be fb			ld (debug_mark+1),a  
4d68 3a 72 4d			ld a, (.dmark+2)  
4d6b 32 bf fb			ld (debug_mark+2),a  
4d6e 18 03			jr .pastdmark  
4d70 ..			.dmark: db "LBl"  
4d73 f1			.pastdmark: pop af  
4d74			endm  
# End of macro DMARK
4d74					CALLMONITOR 
4d74 cd 47 17			call break_point_state  
4d77				endm  
# End of macro CALLMONITOR
4d77				endif 
4d77 cd de 04				call storage_label 
4d7a			 
4d7a				       NEXTW 
4d7a c3 40 20			jp macro_next 
4d7d				endm 
# End of macro NEXTW
4d7d			.STOREPAGE: 
4d7d				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d7d 6d				db WORD_SYS_CORE+89             
4d7e b0 4d			dw .LABELS            
4d80 0a				db 9 + 1 
4d81 .. 00			db "STOREPAGE",0              
4d8b				endm 
# End of macro CWHEAD
4d8b			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4d8b					; TODO test to see if bank is selected 
4d8b				 
4d8b					if DEBUG_FORTH_WORDS_KEY 
4d8b						DMARK "STP" 
4d8b f5				push af  
4d8c 3a a0 4d			ld a, (.dmark)  
4d8f 32 bd fb			ld (debug_mark),a  
4d92 3a a1 4d			ld a, (.dmark+1)  
4d95 32 be fb			ld (debug_mark+1),a  
4d98 3a a2 4d			ld a, (.dmark+2)  
4d9b 32 bf fb			ld (debug_mark+2),a  
4d9e 18 03			jr .pastdmark  
4da0 ..			.dmark: db "STP"  
4da3 f1			.pastdmark: pop af  
4da4			endm  
# End of macro DMARK
4da4						CALLMONITOR 
4da4 cd 47 17			call break_point_state  
4da7				endm  
# End of macro CALLMONITOR
4da7					endif 
4da7			;	if DEBUG_STORESE 
4da7			;		DMARK "STP" 
4da7			;		CALLMONITOR 
4da7			;	endif 
4da7			 
4da7 21 e8 f9			ld hl, store_page 
4daa cd d7 1c			call forth_push_numhl 
4dad			 
4dad			 
4dad				       NEXTW 
4dad c3 40 20			jp macro_next 
4db0				endm 
# End of macro NEXTW
4db0			.LABELS: 
4db0				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4db0 6d				db WORD_SYS_CORE+89             
4db1 3a 4e			dw .ENDSTORAGE            
4db3 07				db 6 + 1 
4db4 .. 00			db "LABELS",0              
4dbb				endm 
# End of macro CWHEAD
4dbb			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4dbb					;  
4dbb			 
4dbb					; save the current device selected to restore afterwards 
4dbb				 
4dbb 3a ce f9				ld a, (spi_device) 
4dbe f5					push af 
4dbf			 
4dbf			 
4dbf					; run through each of the banks 
4dbf			 
4dbf 21 01 00				ld hl, 1 
4dc2 cd d7 1c				call forth_push_numhl 
4dc5 3e ff				ld a, SPI_CE_HIGH 
4dc7 cb 87				res SPI_CE0, a 
4dc9 32 ce f9				ld (spi_device), a 
4dcc cd ba 03				call storage_get_block_0 
4dcf 21 eb f9				ld hl, store_page+3 
4dd2 cd 45 1d				call forth_push_str 
4dd5			 
4dd5					 
4dd5 21 02 00				ld hl, 2 
4dd8 cd d7 1c				call forth_push_numhl 
4ddb 3e ff				ld a, SPI_CE_HIGH 
4ddd cb 8f				res SPI_CE1, a 
4ddf 32 ce f9				ld (spi_device), a 
4de2 cd ba 03				call storage_get_block_0 
4de5 21 eb f9				ld hl, store_page+3 
4de8 cd 45 1d				call forth_push_str 
4deb			 
4deb					 
4deb 21 03 00				ld hl, 3 
4dee cd d7 1c				call forth_push_numhl 
4df1 3e ff				ld a, SPI_CE_HIGH 
4df3 cb 97				res SPI_CE2, a 
4df5 32 ce f9				ld (spi_device), a 
4df8 cd ba 03				call storage_get_block_0 
4dfb 21 eb f9				ld hl, store_page+3 
4dfe cd 45 1d				call forth_push_str 
4e01			 
4e01			 
4e01 21 04 00				ld hl, 4 
4e04 cd d7 1c				call forth_push_numhl 
4e07 3e ff				ld a, SPI_CE_HIGH 
4e09 cb 9f				res SPI_CE3, a 
4e0b 32 ce f9				ld (spi_device), a 
4e0e cd ba 03				call storage_get_block_0 
4e11 21 eb f9				ld hl, store_page+3 
4e14 cd 45 1d				call forth_push_str 
4e17			 
4e17					 
4e17			 
4e17 21 05 00				ld hl, 5 
4e1a cd d7 1c				call forth_push_numhl 
4e1d 3e ff				ld a, SPI_CE_HIGH 
4e1f cb a7				res SPI_CE4, a 
4e21 32 ce f9				ld (spi_device), a 
4e24 cd ba 03				call storage_get_block_0 
4e27 21 eb f9				ld hl, store_page+3 
4e2a cd 45 1d				call forth_push_str 
4e2d			 
4e2d					 
4e2d					; push fixed count of storage devices (on board) for now 
4e2d			 
4e2d 21 05 00				ld hl, 5 
4e30 cd d7 1c				call forth_push_numhl 
4e33			 
4e33					; restore selected device  
4e33				 
4e33 f1					pop af 
4e34 32 ce f9				ld (spi_device), a 
4e37			 
4e37				       NEXTW 
4e37 c3 40 20			jp macro_next 
4e3a				endm 
# End of macro NEXTW
4e3a			 
4e3a			.ENDSTORAGE: 
4e3a			; eof 
# End of file forth_words_storage.asm
4e3a			endif 
4e3a				include "forth_words_device.asm" 
4e3a			; Device related words 
4e3a			 
4e3a			; | ## Device Words 
4e3a			 
4e3a			if SOUND_ENABLE 
4e3a			.NOTE: 
4e3a				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e3a			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e3a					if DEBUG_FORTH_WORDS_KEY 
4e3a						DMARK "NTE" 
4e3a						CALLMONITOR 
4e3a					endif 
4e3a			 
4e3a				 
4e3a			 
4e3a					NEXTW 
4e3a			.AFTERSOUND: 
4e3a			endif 
4e3a			 
4e3a			 
4e3a			USE_GPIO: equ 0 
4e3a			 
4e3a			if USE_GPIO 
4e3a			.GP1: 
4e3a				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e3a			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e3a					NEXTW 
4e3a			.GP2: 
4e3a				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e3a			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e3a			 
4e3a					NEXTW 
4e3a			 
4e3a			.GP3: 
4e3a				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e3a			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e3a			 
4e3a					NEXTW 
4e3a			 
4e3a			.GP4: 
4e3a				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e3a			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e3a			 
4e3a					NEXTW 
4e3a			.SIN: 
4e3a			 
4e3a			 
4e3a			endif 
4e3a			 
4e3a			 
4e3a				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e3a 33				db WORD_SYS_CORE+31             
4e3b 6f 4e			dw .SOUT            
4e3d 03				db 2 + 1 
4e3e .. 00			db "IN",0              
4e41				endm 
# End of macro CWHEAD
4e41			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e41					if DEBUG_FORTH_WORDS_KEY 
4e41						DMARK "IN." 
4e41 f5				push af  
4e42 3a 56 4e			ld a, (.dmark)  
4e45 32 bd fb			ld (debug_mark),a  
4e48 3a 57 4e			ld a, (.dmark+1)  
4e4b 32 be fb			ld (debug_mark+1),a  
4e4e 3a 58 4e			ld a, (.dmark+2)  
4e51 32 bf fb			ld (debug_mark+2),a  
4e54 18 03			jr .pastdmark  
4e56 ..			.dmark: db "IN."  
4e59 f1			.pastdmark: pop af  
4e5a			endm  
# End of macro DMARK
4e5a						CALLMONITOR 
4e5a cd 47 17			call break_point_state  
4e5d				endm  
# End of macro CALLMONITOR
4e5d					endif 
4e5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e5d cd ce 1e			call macro_dsp_valuehl 
4e60				endm 
# End of macro FORTH_DSP_VALUEHL
4e60			 
4e60 e5					push hl 
4e61			 
4e61					; destroy value TOS 
4e61			 
4e61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e61 cd 86 1f			call macro_forth_dsp_pop 
4e64				endm 
# End of macro FORTH_DSP_POP
4e64			 
4e64					; one value on hl get other one back 
4e64			 
4e64 c1					pop bc 
4e65			 
4e65					; do the sub 
4e65			;		ex de, hl 
4e65			 
4e65 ed 68				in l,(c) 
4e67			 
4e67					; save it 
4e67			 
4e67 26 00				ld h,0 
4e69			 
4e69					; TODO push value back onto stack for another op etc 
4e69			 
4e69 cd d7 1c				call forth_push_numhl 
4e6c					NEXTW 
4e6c c3 40 20			jp macro_next 
4e6f				endm 
# End of macro NEXTW
4e6f			.SOUT: 
4e6f				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e6f 34				db WORD_SYS_CORE+32             
4e70 c2 4e			dw .SPIO            
4e72 04				db 3 + 1 
4e73 .. 00			db "OUT",0              
4e77				endm 
# End of macro CWHEAD
4e77			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e77					if DEBUG_FORTH_WORDS_KEY 
4e77						DMARK "OUT" 
4e77 f5				push af  
4e78 3a 8c 4e			ld a, (.dmark)  
4e7b 32 bd fb			ld (debug_mark),a  
4e7e 3a 8d 4e			ld a, (.dmark+1)  
4e81 32 be fb			ld (debug_mark+1),a  
4e84 3a 8e 4e			ld a, (.dmark+2)  
4e87 32 bf fb			ld (debug_mark+2),a  
4e8a 18 03			jr .pastdmark  
4e8c ..			.dmark: db "OUT"  
4e8f f1			.pastdmark: pop af  
4e90			endm  
# End of macro DMARK
4e90						CALLMONITOR 
4e90 cd 47 17			call break_point_state  
4e93				endm  
# End of macro CALLMONITOR
4e93					endif 
4e93			 
4e93					; get port 
4e93			 
4e93					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e93 cd ce 1e			call macro_dsp_valuehl 
4e96				endm 
# End of macro FORTH_DSP_VALUEHL
4e96			 
4e96 e5					push hl 
4e97			 
4e97					; destroy value TOS 
4e97			 
4e97					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e97 cd 86 1f			call macro_forth_dsp_pop 
4e9a				endm 
# End of macro FORTH_DSP_POP
4e9a			 
4e9a					; get byte to send 
4e9a			 
4e9a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e9a cd ce 1e			call macro_dsp_valuehl 
4e9d				endm 
# End of macro FORTH_DSP_VALUEHL
4e9d			 
4e9d			;		push hl 
4e9d			 
4e9d					; destroy value TOS 
4e9d			 
4e9d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e9d cd 86 1f			call macro_forth_dsp_pop 
4ea0				endm 
# End of macro FORTH_DSP_POP
4ea0			 
4ea0					; one value on hl get other one back 
4ea0			 
4ea0			;		pop hl 
4ea0			 
4ea0 c1					pop bc 
4ea1			 
4ea1					if DEBUG_FORTH_WORDS 
4ea1						DMARK "OUT" 
4ea1 f5				push af  
4ea2 3a b6 4e			ld a, (.dmark)  
4ea5 32 bd fb			ld (debug_mark),a  
4ea8 3a b7 4e			ld a, (.dmark+1)  
4eab 32 be fb			ld (debug_mark+1),a  
4eae 3a b8 4e			ld a, (.dmark+2)  
4eb1 32 bf fb			ld (debug_mark+2),a  
4eb4 18 03			jr .pastdmark  
4eb6 ..			.dmark: db "OUT"  
4eb9 f1			.pastdmark: pop af  
4eba			endm  
# End of macro DMARK
4eba						CALLMONITOR 
4eba cd 47 17			call break_point_state  
4ebd				endm  
# End of macro CALLMONITOR
4ebd					endif 
4ebd			 
4ebd ed 69				out (c), l 
4ebf			 
4ebf					NEXTW 
4ebf c3 40 20			jp macro_next 
4ec2				endm 
# End of macro NEXTW
4ec2			 
4ec2			 
4ec2			.SPIO: 
4ec2			 
4ec2			if STORAGE_SE 
4ec2				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ec2 51				db WORD_SYS_CORE+61             
4ec3 d3 4e			dw .SPICEH            
4ec5 07				db 6 + 1 
4ec6 .. 00			db "SPICEL",0              
4ecd				endm 
# End of macro CWHEAD
4ecd			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ecd			 
4ecd cd 95 01				call spi_ce_low 
4ed0			    NEXTW 
4ed0 c3 40 20			jp macro_next 
4ed3				endm 
# End of macro NEXTW
4ed3			 
4ed3			.SPICEH: 
4ed3				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ed3 51				db WORD_SYS_CORE+61             
4ed4 e4 4e			dw .SPIOb            
4ed6 07				db 6 + 1 
4ed7 .. 00			db "SPICEH",0              
4ede				endm 
# End of macro CWHEAD
4ede			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ede			 
4ede cd 84 01				call spi_ce_high 
4ee1			    NEXTW 
4ee1 c3 40 20			jp macro_next 
4ee4				endm 
# End of macro NEXTW
4ee4			 
4ee4			 
4ee4			.SPIOb: 
4ee4			 
4ee4				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ee4 51				db WORD_SYS_CORE+61             
4ee5 fa 4e			dw .SPII            
4ee7 05				db 4 + 1 
4ee8 .. 00			db "SPIO",0              
4eed				endm 
# End of macro CWHEAD
4eed			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4eed			 
4eed					; get port 
4eed			 
4eed			 
4eed					; get byte to send 
4eed			 
4eed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eed cd ce 1e			call macro_dsp_valuehl 
4ef0				endm 
# End of macro FORTH_DSP_VALUEHL
4ef0			 
4ef0			;		push hl    ; u1  
4ef0			 
4ef0					; destroy value TOS 
4ef0			 
4ef0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ef0 cd 86 1f			call macro_forth_dsp_pop 
4ef3				endm 
# End of macro FORTH_DSP_POP
4ef3			 
4ef3					; one value on hl get other one back 
4ef3			 
4ef3			;		pop hl   ; u2 - addr 
4ef3			 
4ef3					; TODO Send SPI byte 
4ef3			 
4ef3 7d					ld a, l 
4ef4 cd b9 00				call spi_send_byte 
4ef7			 
4ef7					NEXTW 
4ef7 c3 40 20			jp macro_next 
4efa				endm 
# End of macro NEXTW
4efa			 
4efa			.SPII: 
4efa				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4efa 52				db WORD_SYS_CORE+62             
4efb 0f 4f			dw .SESEL            
4efd 06				db 5 + 1 
4efe .. 00			db "SPII",0              
4f03				endm 
# End of macro CWHEAD
4f03			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f03			 
4f03					; TODO Get SPI byte 
4f03			 
4f03 cd da 00				call spi_read_byte 
4f06			 
4f06 26 00				ld h, 0 
4f08 6f					ld l, a 
4f09 cd d7 1c				call forth_push_numhl 
4f0c			 
4f0c					NEXTW 
4f0c c3 40 20			jp macro_next 
4f0f				endm 
# End of macro NEXTW
4f0f			 
4f0f			 
4f0f			 
4f0f			.SESEL: 
4f0f				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f0f 66				db WORD_SYS_CORE+82             
4f10 b3 4f			dw .CARTDEV            
4f12 05				db 4 + 1 
4f13 .. 00			db "BANK",0              
4f18				endm 
# End of macro CWHEAD
4f18			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f18					if DEBUG_FORTH_WORDS_KEY 
4f18						DMARK "BNK" 
4f18 f5				push af  
4f19 3a 2d 4f			ld a, (.dmark)  
4f1c 32 bd fb			ld (debug_mark),a  
4f1f 3a 2e 4f			ld a, (.dmark+1)  
4f22 32 be fb			ld (debug_mark+1),a  
4f25 3a 2f 4f			ld a, (.dmark+2)  
4f28 32 bf fb			ld (debug_mark+2),a  
4f2b 18 03			jr .pastdmark  
4f2d ..			.dmark: db "BNK"  
4f30 f1			.pastdmark: pop af  
4f31			endm  
# End of macro DMARK
4f31						CALLMONITOR 
4f31 cd 47 17			call break_point_state  
4f34				endm  
# End of macro CALLMONITOR
4f34					endif 
4f34			 
4f34 3e ff				ld a, 255 
4f36 32 d1 f9				ld (spi_cartdev), a 
4f39			 
4f39					; get bank 
4f39			 
4f39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f39 cd ce 1e			call macro_dsp_valuehl 
4f3c				endm 
# End of macro FORTH_DSP_VALUEHL
4f3c			 
4f3c			;		push hl 
4f3c			 
4f3c					; destroy value TOS 
4f3c			 
4f3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f3c cd 86 1f			call macro_forth_dsp_pop 
4f3f				endm 
# End of macro FORTH_DSP_POP
4f3f			 
4f3f					; one value on hl get other one back 
4f3f			 
4f3f			;		pop hl 
4f3f			 
4f3f			 
4f3f 0e ff				ld c, SPI_CE_HIGH 
4f41 06 30				ld b, '0'    ; human readable bank number 
4f43			 
4f43 7d					ld a, l 
4f44			 
4f44					if DEBUG_FORTH_WORDS 
4f44						DMARK "BNK" 
4f44 f5				push af  
4f45 3a 59 4f			ld a, (.dmark)  
4f48 32 bd fb			ld (debug_mark),a  
4f4b 3a 5a 4f			ld a, (.dmark+1)  
4f4e 32 be fb			ld (debug_mark+1),a  
4f51 3a 5b 4f			ld a, (.dmark+2)  
4f54 32 bf fb			ld (debug_mark+2),a  
4f57 18 03			jr .pastdmark  
4f59 ..			.dmark: db "BNK"  
4f5c f1			.pastdmark: pop af  
4f5d			endm  
# End of macro DMARK
4f5d						CALLMONITOR 
4f5d cd 47 17			call break_point_state  
4f60				endm  
# End of macro CALLMONITOR
4f60					endif 
4f60			 
4f60					; active low 
4f60			 
4f60 fe 00				cp 0 
4f62 28 28				jr z, .bset 
4f64 fe 01				cp 1 
4f66 20 04				jr nz, .b2 
4f68 cb 81				res 0, c 
4f6a 06 31				ld b, '1'    ; human readable bank number 
4f6c fe 02		.b2:		cp 2 
4f6e 20 04				jr nz, .b3 
4f70 cb 89				res 1, c 
4f72 06 32				ld b, '2'    ; human readable bank number 
4f74 fe 03		.b3:		cp 3 
4f76 20 04				jr nz, .b4 
4f78 cb 91				res 2, c 
4f7a 06 33				ld b, '3'    ; human readable bank number 
4f7c fe 04		.b4:		cp 4 
4f7e 20 04				jr nz, .b5 
4f80 cb 99				res 3, c 
4f82 06 34				ld b, '4'    ; human readable bank number 
4f84 fe 05		.b5:		cp 5 
4f86 20 04				jr nz, .bset 
4f88 cb a1				res 4, c 
4f8a 06 35				ld b, '5'    ; human readable bank number 
4f8c			 
4f8c			.bset: 
4f8c 79					ld a, c 
4f8d 32 ce f9				ld (spi_device),a 
4f90 78					ld a, b 
4f91 32 cd f9				ld (spi_device_id),a 
4f94					if DEBUG_FORTH_WORDS 
4f94						DMARK "BN2" 
4f94 f5				push af  
4f95 3a a9 4f			ld a, (.dmark)  
4f98 32 bd fb			ld (debug_mark),a  
4f9b 3a aa 4f			ld a, (.dmark+1)  
4f9e 32 be fb			ld (debug_mark+1),a  
4fa1 3a ab 4f			ld a, (.dmark+2)  
4fa4 32 bf fb			ld (debug_mark+2),a  
4fa7 18 03			jr .pastdmark  
4fa9 ..			.dmark: db "BN2"  
4fac f1			.pastdmark: pop af  
4fad			endm  
# End of macro DMARK
4fad						CALLMONITOR 
4fad cd 47 17			call break_point_state  
4fb0				endm  
# End of macro CALLMONITOR
4fb0					endif 
4fb0			 
4fb0					NEXTW 
4fb0 c3 40 20			jp macro_next 
4fb3				endm 
# End of macro NEXTW
4fb3			 
4fb3			.CARTDEV: 
4fb3				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4fb3 66				db WORD_SYS_CORE+82             
4fb4 5c 50			dw .ENDDEVICE            
4fb6 08				db 7 + 1 
4fb7 .. 00			db "CARTDEV",0              
4fbf				endm 
# End of macro CWHEAD
4fbf			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4fbf					if DEBUG_FORTH_WORDS_KEY 
4fbf						DMARK "CDV" 
4fbf f5				push af  
4fc0 3a d4 4f			ld a, (.dmark)  
4fc3 32 bd fb			ld (debug_mark),a  
4fc6 3a d5 4f			ld a, (.dmark+1)  
4fc9 32 be fb			ld (debug_mark+1),a  
4fcc 3a d6 4f			ld a, (.dmark+2)  
4fcf 32 bf fb			ld (debug_mark+2),a  
4fd2 18 03			jr .pastdmark  
4fd4 ..			.dmark: db "CDV"  
4fd7 f1			.pastdmark: pop af  
4fd8			endm  
# End of macro DMARK
4fd8						CALLMONITOR 
4fd8 cd 47 17			call break_point_state  
4fdb				endm  
# End of macro CALLMONITOR
4fdb					endif 
4fdb			 
4fdb					; disable se storage bank selection 
4fdb			 
4fdb 3e ff				ld a, SPI_CE_HIGH		; ce high 
4fdd 32 ce f9				ld (spi_device), a 
4fe0			 
4fe0					; get bank 
4fe0			 
4fe0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fe0 cd ce 1e			call macro_dsp_valuehl 
4fe3				endm 
# End of macro FORTH_DSP_VALUEHL
4fe3			 
4fe3			;		push hl 
4fe3			 
4fe3					; destroy value TOS 
4fe3			 
4fe3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fe3 cd 86 1f			call macro_forth_dsp_pop 
4fe6				endm 
# End of macro FORTH_DSP_POP
4fe6			 
4fe6					; one value on hl get other one back 
4fe6			 
4fe6			;		pop hl 
4fe6			 
4fe6					; active low 
4fe6			 
4fe6 0e ff				ld c, 255 
4fe8			 
4fe8 7d					ld a, l 
4fe9					if DEBUG_FORTH_WORDS 
4fe9						DMARK "CDV" 
4fe9 f5				push af  
4fea 3a fe 4f			ld a, (.dmark)  
4fed 32 bd fb			ld (debug_mark),a  
4ff0 3a ff 4f			ld a, (.dmark+1)  
4ff3 32 be fb			ld (debug_mark+1),a  
4ff6 3a 00 50			ld a, (.dmark+2)  
4ff9 32 bf fb			ld (debug_mark+2),a  
4ffc 18 03			jr .pastdmark  
4ffe ..			.dmark: db "CDV"  
5001 f1			.pastdmark: pop af  
5002			endm  
# End of macro DMARK
5002						CALLMONITOR 
5002 cd 47 17			call break_point_state  
5005				endm  
# End of macro CALLMONITOR
5005					endif 
5005 fe 00				cp 0 
5007 28 30				jr z, .cset 
5009 fe 01				cp 1 
500b 20 02				jr nz, .c2 
500d cb 81				res 0, c 
500f fe 02		.c2:		cp 2 
5011 20 02				jr nz, .c3 
5013 cb 89				res 1, c 
5015 fe 03		.c3:		cp 3 
5017 20 02				jr nz, .c4 
5019 cb 91				res 2, c 
501b fe 04		.c4:		cp 4 
501d 20 02				jr nz, .c5 
501f cb 99				res 3, c 
5021 fe 05		.c5:		cp 5 
5023 20 02				jr nz, .c6 
5025 cb a1				res 4, c 
5027 fe 06		.c6:		cp 6 
5029 20 02				jr nz, .c7 
502b cb a9				res 5, c 
502d fe 07		.c7:		cp 7 
502f 20 02				jr nz, .c8 
5031 cb b1				res 6, c 
5033 fe 08		.c8:		cp 8 
5035 20 02				jr nz, .cset 
5037 cb b9				res 7, c 
5039 79			.cset:		ld a, c 
503a 32 d1 f9				ld (spi_cartdev),a 
503d			 
503d					if DEBUG_FORTH_WORDS 
503d						DMARK "CD2" 
503d f5				push af  
503e 3a 52 50			ld a, (.dmark)  
5041 32 bd fb			ld (debug_mark),a  
5044 3a 53 50			ld a, (.dmark+1)  
5047 32 be fb			ld (debug_mark+1),a  
504a 3a 54 50			ld a, (.dmark+2)  
504d 32 bf fb			ld (debug_mark+2),a  
5050 18 03			jr .pastdmark  
5052 ..			.dmark: db "CD2"  
5055 f1			.pastdmark: pop af  
5056			endm  
# End of macro DMARK
5056						CALLMONITOR 
5056 cd 47 17			call break_point_state  
5059				endm  
# End of macro CALLMONITOR
5059					endif 
5059					NEXTW 
5059 c3 40 20			jp macro_next 
505c				endm 
# End of macro NEXTW
505c			endif 
505c			 
505c			.ENDDEVICE: 
505c			; eof 
505c			 
# End of file forth_words_device.asm
505c			 
505c			; var handler 
505c			 
505c			 
505c			.VARS: 
505c				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
505c 78				db WORD_SYS_CORE+100             
505d 74 50			dw .V0Q            
505f 04				db 3 + 1 
5060 .. 00			db "V0!",0              
5064				endm 
# End of macro CWHEAD
5064			;| V0! ( u1 -- )  Store value to v0  | DONE 
5064			 
5064					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5064 cd ce 1e			call macro_dsp_valuehl 
5067				endm 
# End of macro FORTH_DSP_VALUEHL
5067			 
5067 11 96 f9				ld de, cli_var_array 
506a			 
506a eb					ex de, hl 
506b 73					ld (hl), e 
506c 23					inc hl 
506d 72					ld (hl), d 
506e			 
506e					; destroy value TOS 
506e			 
506e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
506e cd 86 1f			call macro_forth_dsp_pop 
5071				endm 
# End of macro FORTH_DSP_POP
5071			 
5071				       NEXTW 
5071 c3 40 20			jp macro_next 
5074				endm 
# End of macro NEXTW
5074			.V0Q: 
5074				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5074 79				db WORD_SYS_CORE+101             
5075 85 50			dw .V1S            
5077 04				db 3 + 1 
5078 .. 00			db "V0@",0              
507c				endm 
# End of macro CWHEAD
507c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
507c 2a 96 f9				ld hl, (cli_var_array) 
507f cd d7 1c				call forth_push_numhl 
5082			 
5082				       NEXTW 
5082 c3 40 20			jp macro_next 
5085				endm 
# End of macro NEXTW
5085			.V1S: 
5085				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5085 7a				db WORD_SYS_CORE+102             
5086 9d 50			dw .V1Q            
5088 04				db 3 + 1 
5089 .. 00			db "V1!",0              
508d				endm 
# End of macro CWHEAD
508d			;| V1! ( u1 -- )  Store value to v1 | DONE 
508d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
508d cd ce 1e			call macro_dsp_valuehl 
5090				endm 
# End of macro FORTH_DSP_VALUEHL
5090			 
5090 11 98 f9				ld de, cli_var_array+2 
5093				 
5093 eb					ex de, hl 
5094 73					ld (hl), e 
5095 23					inc hl 
5096 72					ld (hl), d 
5097			 
5097					; destroy value TOS 
5097			 
5097					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5097 cd 86 1f			call macro_forth_dsp_pop 
509a				endm 
# End of macro FORTH_DSP_POP
509a				       NEXTW 
509a c3 40 20			jp macro_next 
509d				endm 
# End of macro NEXTW
509d			.V1Q: 
509d				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
509d 7b				db WORD_SYS_CORE+103             
509e ae 50			dw .V2S            
50a0 04				db 3 + 1 
50a1 .. 00			db "V1@",0              
50a5				endm 
# End of macro CWHEAD
50a5			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
50a5 2a 98 f9				ld hl, (cli_var_array+2) 
50a8 cd d7 1c				call forth_push_numhl 
50ab				       NEXTW 
50ab c3 40 20			jp macro_next 
50ae				endm 
# End of macro NEXTW
50ae			.V2S: 
50ae				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
50ae 7c				db WORD_SYS_CORE+104             
50af c6 50			dw .V2Q            
50b1 04				db 3 + 1 
50b2 .. 00			db "V2!",0              
50b6				endm 
# End of macro CWHEAD
50b6			;| V2! ( u1 -- )  Store value to v2 | DONE 
50b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50b6 cd ce 1e			call macro_dsp_valuehl 
50b9				endm 
# End of macro FORTH_DSP_VALUEHL
50b9			 
50b9 11 9a f9				ld de, cli_var_array+4 
50bc				 
50bc eb					ex de, hl 
50bd 73					ld (hl), e 
50be 23					inc hl 
50bf 72					ld (hl), d 
50c0			 
50c0					; destroy value TOS 
50c0			 
50c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50c0 cd 86 1f			call macro_forth_dsp_pop 
50c3				endm 
# End of macro FORTH_DSP_POP
50c3				       NEXTW 
50c3 c3 40 20			jp macro_next 
50c6				endm 
# End of macro NEXTW
50c6			.V2Q: 
50c6				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
50c6 7d				db WORD_SYS_CORE+105             
50c7 d7 50			dw .V3S            
50c9 04				db 3 + 1 
50ca .. 00			db "V2@",0              
50ce				endm 
# End of macro CWHEAD
50ce			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
50ce 2a 9a f9				ld hl, (cli_var_array+4) 
50d1 cd d7 1c				call forth_push_numhl 
50d4				       NEXTW 
50d4 c3 40 20			jp macro_next 
50d7				endm 
# End of macro NEXTW
50d7			.V3S: 
50d7				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50d7 7c				db WORD_SYS_CORE+104             
50d8 ef 50			dw .V3Q            
50da 04				db 3 + 1 
50db .. 00			db "V3!",0              
50df				endm 
# End of macro CWHEAD
50df			;| V3! ( u1 -- )  Store value to v3 | DONE 
50df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50df cd ce 1e			call macro_dsp_valuehl 
50e2				endm 
# End of macro FORTH_DSP_VALUEHL
50e2			 
50e2 11 9c f9				ld de, cli_var_array+6 
50e5				 
50e5 eb					ex de, hl 
50e6 73					ld (hl), e 
50e7 23					inc hl 
50e8 72					ld (hl), d 
50e9			 
50e9					; destroy value TOS 
50e9			 
50e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50e9 cd 86 1f			call macro_forth_dsp_pop 
50ec				endm 
# End of macro FORTH_DSP_POP
50ec				       NEXTW 
50ec c3 40 20			jp macro_next 
50ef				endm 
# End of macro NEXTW
50ef			.V3Q: 
50ef				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
50ef 7d				db WORD_SYS_CORE+105             
50f0 00 51			dw .END            
50f2 04				db 3 + 1 
50f3 .. 00			db "V3@",0              
50f7				endm 
# End of macro CWHEAD
50f7			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
50f7 2a 9c f9				ld hl, (cli_var_array+6) 
50fa cd d7 1c				call forth_push_numhl 
50fd				       NEXTW 
50fd c3 40 20			jp macro_next 
5100				endm 
# End of macro NEXTW
5100			 
5100			 
5100			 
5100			 
5100			 
5100			; end of dict marker 
5100			 
5100 00			.END:    db WORD_SYS_END 
5101 00 00			dw 0 
5103 00				db 0 
5104			 
5104			; use to jp here for user dict words to save on macro expansion  
5104			 
5104			user_dict_next: 
5104				NEXTW 
5104 c3 40 20			jp macro_next 
5107				endm 
# End of macro NEXTW
5107			 
5107			 
5107			user_exec: 
5107				;    ld hl, <word code> 
5107				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5107				;    call forthexec 
5107				;    jp user_dict_next   (NEXT) 
5107			        ;    <word code bytes> 
5107 eb				ex de, hl 
5108 2a a4 f2			ld hl,(os_tok_ptr) 
510b				 
510b				FORTH_RSP_NEXT 
510b cd 7e 1c			call macro_forth_rsp_next 
510e				endm 
# End of macro FORTH_RSP_NEXT
510e			 
510e			if DEBUG_FORTH_UWORD 
510e						DMARK "UEX" 
510e f5				push af  
510f 3a 23 51			ld a, (.dmark)  
5112 32 bd fb			ld (debug_mark),a  
5115 3a 24 51			ld a, (.dmark+1)  
5118 32 be fb			ld (debug_mark+1),a  
511b 3a 25 51			ld a, (.dmark+2)  
511e 32 bf fb			ld (debug_mark+2),a  
5121 18 03			jr .pastdmark  
5123 ..			.dmark: db "UEX"  
5126 f1			.pastdmark: pop af  
5127			endm  
# End of macro DMARK
5127				CALLMONITOR 
5127 cd 47 17			call break_point_state  
512a				endm  
# End of macro CALLMONITOR
512a			endif 
512a			 
512a			 
512a			 
512a eb				ex de, hl 
512b 22 a4 f2			ld (os_tok_ptr), hl 
512e				 
512e				; Don't use next - Skips the first word in uword. 
512e			 
512e c3 d1 20			jp exec1 
5131			;	NEXT 
5131			 
5131			 
5131			; eof 
# End of file forth_wordsv4.asm
5131			endif 
5131			;;;;;;;;;;;;;; Debug code 
5131			 
5131			 
5131			;if DEBUG_FORTH_PARSE 
5131 .. 00		.nowordfound: db "No match",0 
513a .. 00		.compword:	db "Comparing word ",0 
514a .. 00		.nextwordat:	db "Next word at",0 
5157 .. 00		.charmatch:	db "Char match",0 
5162			;endif 
5162			if DEBUG_FORTH_JP 
5162			.foundword:	db "Word match. Exec..",0 
5162			endif 
5162			;if DEBUG_FORTH_PUSH 
5162 .. 00		.enddict:	db "Dict end. Push.",0 
5172 .. 00		.push_str:	db "Pushing string",0 
5181 .. 00		.push_num:	db "Pushing number",0 
5190 .. 00		.data_sp:	db "SP:",0 
5194 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
51a6 .. 00		.wordinde:	db "Word in DE (3/0):",0 
51b8 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
51ca			;endif 
51ca			;if DEBUG_FORTH_MALLOC 
51ca .. 00		.push_malloc:	db "Malloc address",0 
51d9			;endif 
51d9			 
51d9			 
51d9			 
51d9			; display malloc address and current data stack pointer  
51d9			 
51d9			malloc_error: 
51d9 d5				push de 
51da f5				push af 
51db e5				push hl 
51dc cd e9 0a			call clear_display 
51df 11 01 52			ld de, .mallocerr 
51e2 3e 00			ld a,0 
51e4			;	ld de,os_word_scratch 
51e4 cd fc 0a			call str_at_display 
51e7 3e 11			ld a, display_row_1+17 
51e9 11 bd fb			ld de, debug_mark 
51ec cd fc 0a			call str_at_display 
51ef cd 0c 0b			call update_display 
51f2				;call break_point_state 
51f2 cd 58 67			call cin_wait 
51f5			 
51f5 3e 20			ld a, ' ' 
51f7 32 94 ef			ld (os_view_disable), a 
51fa e1				pop hl 
51fb f1				pop af 
51fc d1				pop de	 
51fd				CALLMONITOR 
51fd cd 47 17			call break_point_state  
5200				endm  
# End of macro CALLMONITOR
5200 c9				ret 
5201			 
5201 .. 00		.mallocerr: 	db "Malloc Error",0 
520e			;if DEBUG_FORTH_PUSH 
520e			display_data_sp: 
520e f5				push af 
520f			 
520f				; see if disabled 
520f			 
520f 3a 94 ef			ld a, (os_view_disable) 
5212 fe 2a			cp '*' 
5214 28 67			jr z, .skipdsp 
5216			 
5216 e5				push hl 
5217 e5				push hl 
5218 e5			push hl 
5219 cd e9 0a			call clear_display 
521c e1			pop hl 
521d 7c				ld a,h 
521e 21 a8 f2			ld hl, os_word_scratch 
5221 cd 1e 10			call hexout 
5224 e1				pop hl 
5225 7d				ld a,l 
5226 21 aa f2			ld hl, os_word_scratch+2 
5229 cd 1e 10			call hexout 
522c 21 ac f2			ld hl, os_word_scratch+4 
522f 3e 00			ld a,0 
5231 77				ld (hl),a 
5232 11 a8 f2			ld de,os_word_scratch 
5235 3e 14				ld a, display_row_2 
5237 cd fc 0a				call str_at_display 
523a 11 94 51			ld de, .wordinhl 
523d 3e 00			ld a, display_row_1 
523f			 
523f cd fc 0a				call str_at_display 
5242 11 bd fb			ld de, debug_mark 
5245 3e 11			ld a, display_row_1+17 
5247			 
5247 cd fc 0a				call str_at_display 
524a			 
524a				; display current data stack pointer 
524a 11 90 51			ld de,.data_sp 
524d 3e 1c				ld a, display_row_2 + 8 
524f cd fc 0a				call str_at_display 
5252			 
5252 2a 90 f9			ld hl,(cli_data_sp) 
5255 e5				push hl 
5256 7c				ld a,h 
5257 21 a8 f2			ld hl, os_word_scratch 
525a cd 1e 10			call hexout 
525d e1				pop hl 
525e 7d				ld a,l 
525f 21 aa f2			ld hl, os_word_scratch+2 
5262 cd 1e 10			call hexout 
5265 21 ac f2			ld hl, os_word_scratch+4 
5268 3e 00			ld a,0 
526a 77				ld (hl),a 
526b 11 a8 f2			ld de,os_word_scratch 
526e 3e 1f				ld a, display_row_2 + 11 
5270 cd fc 0a				call str_at_display 
5273			 
5273			 
5273 cd 0c 0b			call update_display 
5276 cd 66 0a			call delay1s 
5279 cd 66 0a			call delay1s 
527c e1				pop hl 
527d			.skipdsp: 
527d f1				pop af 
527e c9				ret 
527f			 
527f			display_data_malloc: 
527f			 
527f f5				push af 
5280 e5				push hl 
5281 e5				push hl 
5282 e5			push hl 
5283 cd e9 0a			call clear_display 
5286 e1			pop hl 
5287 7c				ld a,h 
5288 21 a8 f2			ld hl, os_word_scratch 
528b cd 1e 10			call hexout 
528e e1				pop hl 
528f 7d				ld a,l 
5290 21 aa f2			ld hl, os_word_scratch+2 
5293 cd 1e 10			call hexout 
5296 21 ac f2			ld hl, os_word_scratch+4 
5299 3e 00			ld a,0 
529b 77				ld (hl),a 
529c 11 a8 f2			ld de,os_word_scratch 
529f 3e 14				ld a, display_row_2 
52a1 cd fc 0a				call str_at_display 
52a4 11 ca 51			ld de, .push_malloc 
52a7 3e 00			ld a, display_row_1 
52a9			 
52a9 cd fc 0a				call str_at_display 
52ac			 
52ac				; display current data stack pointer 
52ac 11 90 51			ld de,.data_sp 
52af 3e 1c				ld a, display_row_2 + 8 
52b1 cd fc 0a				call str_at_display 
52b4			 
52b4 2a 90 f9			ld hl,(cli_data_sp) 
52b7 e5				push hl 
52b8 7c				ld a,h 
52b9 21 a8 f2			ld hl, os_word_scratch 
52bc cd 1e 10			call hexout 
52bf e1				pop hl 
52c0 7d				ld a,l 
52c1 21 aa f2			ld hl, os_word_scratch+2 
52c4 cd 1e 10			call hexout 
52c7 21 ac f2			ld hl, os_word_scratch+4 
52ca 3e 00			ld a,0 
52cc 77				ld (hl),a 
52cd 11 a8 f2			ld de,os_word_scratch 
52d0 3e 1f				ld a, display_row_2 + 11 
52d2 cd fc 0a				call str_at_display 
52d5			 
52d5 cd 0c 0b			call update_display 
52d8 cd 66 0a			call delay1s 
52db cd 66 0a			call delay1s 
52de e1				pop hl 
52df f1				pop af 
52e0 c9				ret 
52e1			;endif 
52e1			 
52e1			include "forth_autostart.asm" 
52e1			; list of commands to perform at system start up 
52e1			 
52e1			startcmds: 
52e1			;	dw test11 
52e1			;	dw test12 
52e1			;	dw test13 
52e1			;	dw test14 
52e1			;	dw test15 
52e1			;	dw test16 
52e1			;	dw test17 
52e1			;	dw ifthtest1 
52e1			;	dw ifthtest2 
52e1			;	dw ifthtest3 
52e1			;	dw mmtest1 
52e1			;	dw mmtest2 
52e1			;	dw mmtest3 
52e1			;	dw mmtest4 
52e1			;	dw mmtest5 
52e1			;	dw mmtest6 
52e1			;	dw iftest1 
52e1			;	dw iftest2 
52e1			;	dw iftest3 
52e1			;	dw looptest1 
52e1			;	dw looptest2 
52e1			;	dw test1 
52e1			;	dw test2 
52e1			;	dw test3 
52e1			;	dw test4 
52e1			;	dw game2r 
52e1			;	dw game2b1 
52e1			;	dw game2b2 
52e1			 
52e1				; start up words that are actually useful 
52e1			 
52e1 3f 53			dw clrstack 
52e3 72 53			dw type 
52e5 33 55			dw stest 
52e7 96 53			dw strncpy 
52e9 d4 54			dw list 
52eb f7 53			dw start1 
52ed 09 54			dw start2 
52ef			;	dw start3 
52ef 1c 54			dw start3b 
52f1 74 54			dw start3c 
52f3			 
52f3				; (unit) testing words 
52f3			 
52f3 aa 55			dw mtesta 
52f5 5f 56			dw mtestb 
52f7 02 57			dw mtestc 
52f9 b7 57			dw mtestd 
52fb 5b 58			dw mteste 
52fd			 
52fd				; demo/game words 
52fd			 
52fd 67 5f		        dw game3w 
52ff 95 5f		        dw game3p 
5301 b3 5f		        dw game3sc 
5303 e4 5f		        dw game3vsi 
5305 10 60		        dw game3vs 
5307				 
5307 5a 5d			dw game2b 
5309 c8 5d			dw game2bf 
530b 12 5e			dw game2mba 
530d a8 5e			dw game2mbas 
530f ea 5e			dw game2mb 
5311			 
5311 1b 5a			dw game1 
5313 2c 5a			dw game1a 
5315 8e 5a			dw game1b 
5317 c3 5a			dw game1c 
5319 f9 5a			dw game1d 
531b 2a 5b			dw game1s 
531d 3e 5b			dw game1t 
531f 53 5b			dw game1f 
5321 87 5b			dw game1z 
5323 cb 5b			dw game1zz 
5325			 
5325 11 59			dw test5 
5327 49 59			dw test6 
5329 81 59			dw test7 
532b 95 59			dw test8 
532d c1 59			dw test9 
532f d7 59			dw test10 
5331				 
5331 a2 5c		        dw ssv5 
5333 86 5c		        dw ssv4 
5335 6a 5c		        dw ssv3 
5337 34 5c		        dw ssv2 
5339 bb 5c		        dw ssv1 
533b 03 5d		        dw ssv1cpm 
533d			;	dw keyup 
533d			;	dw keydown 
533d			;	dw keyleft 
533d			;	dw keyright 
533d			;	dw 	keyf1 
533d			;	dw keyf2 
533d			;	dw keyf3 
533d			;	dw keyf4 
533d			;	dw keyf5 
533d			;	dw keyf6 
533d			;	dw keyf7 
533d			;	dw keyf8 
533d			;	dw keyf9 
533d			;	dw keyf10 
533d			;	dw keyf11 
533d			;	dw keyf12 
533d			;	dw keytab 
533d			;	dw keycr 
533d			;	dw keyhome 
533d			;	dw keyend 
533d			;	dw keybs 
533d 00 00			db 0, 0	 
533f			 
533f			 
533f			; clear stack  
533f			 
533f .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5372			 
5372			; type ( addr count - ) 
5372 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5396			 
5396			; some direct memory words 
5396			; strncpy ( len t f -- t ) 
5396			 
5396 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
53f7			 
53f7 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5409 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
541c			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
541c .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5474 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54d4			 
54d4			 
54d4			; a handy word to list items on the stack 
54d4			 
54d4 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5533			 
5533			 
5533			; test stack  
5533			; rnd8 stest 
5533			 
5533 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
55aa			 
55aa			; random malloc and free cycles 
55aa			 
55aa .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
565f			 
565f			; fixed malloc and free cycles 
565f			 
565f .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5702			 
5702			; fixed double string push and drop cycle  
5702			 
5702 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
57b7			 
57b7			; consistent fixed string push and drop cycle  
57b7			 
57b7 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
585b			 
585b .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5911			 
5911			;test1:		db ": aa 1 2 3 ;", 0 
5911			;test2:     	db "111 aa 888 999",0 
5911			;test3:     	db ": bb 77 ;",0 
5911			;test4:     	db "$02 $01 do i . loop bb",0 
5911			 
5911 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5949 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5981 .. 00		test7:     	db ": box hline vline ;",0 
5995 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
59c1 .. 00		test9:     	db ": sw $01 adsp world ;",0 
59d7 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
59fc .. 00		test11:     	db "hello create .",0 
5a0b .. 00		test12:     	db "hello2 create .",0 
5a1b			 
5a1b			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a1b			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a1b			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a1b			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a1b			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a1b			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a1b			 
5a1b			;iftest1:     	db "$0001 IF cls .",0 
5a1b			;iftest2:     	db "$0000 IF cls .",0 
5a1b			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a1b			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a1b			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a1b			 
5a1b			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a1b			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a1b			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a1b			 
5a1b			 
5a1b			 
5a1b			; a small guess the number game 
5a1b			 
5a1b .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a2c .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a8e			 
5a8e .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ac3 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5af9 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b2a .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b3e .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b53 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b87 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5bcb			 
5bcb			; Using 'ga' save a high score across multiple runs using external storage 
5bcb			 
5bcb .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c34			 
5c34			 
5c34			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c34			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c34			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c34			 
5c34			; simple screen saver to test code memory reuse to destruction 
5c34			 
5c34 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c6a .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c86 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5ca2 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cbb .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d03 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d5a			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d5a			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d5a			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d5a			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d5a			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d5a			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d5a			 
5d5a			 
5d5a			 
5d5a			; minesweeper/battleship finding game 
5d5a			; draws a game board of random ship/mine positions 
5d5a			; user enters coords to see if it hits on 
5d5a			; game ends when all are hit 
5d5a			; when hit or miss says how many may be in the area 
5d5a			 
5d5a			; setup the game board and then hide it 
5d5a .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5dc8 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e12			; prompt for where to target 
5e12 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5ea8 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ecd			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ecd .. 00		game2mbht:      db ": mbckht nop ;",0 
5edc .. 00		game2mbms:      db ": mbcms nop ;",0 
5eea			; TODO how many might be near by 
5eea .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f67			 
5f67			; Game 3 
5f67			 
5f67			; Vert scroller ski game - avoid the trees! 
5f67			 
5f67			; v0 score (ie turns) 
5f67			; v1 player pos 
5f67			; v2 left wall 
5f67			; v3 right wall 
5f67			 
5f67			; Draw side walls randomly 
5f67			 
5f67 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f95			 
5f95			; Draw player 
5f95 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fb3			 
5fb3			; TODO Get Key 
5fb3			 
5fb3			; TODO Move left right 
5fb3			 
5fb3			; scroll and move walls a bit 
5fb3			 
5fb3 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fe4			 
5fe4			; main game loop 
5fe4			 
5fe4 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6010 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
604f			 
604f			; key board defs 
604f			 
604f .. 00		keyup:       db ": keyup $05 ;",0 
605d .. 00		keydown:       db ": keydown $0a ;",0 
606d .. 00		keyleft:       db ": keyleft $0b ;",0 
607d .. 00		keyright:       db ": keyright $0c ;",0 
608e .. 00		keyf1:       db ": keyf1 $10 ;",0 
609c .. 00		keyf2:       db ": keyf2 $11 ;",0 
60aa .. 00		keyf3:       db ": keyf3 $12 ;",0 
60b8 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60c6 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60d4 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60e2 .. 00		keyf7:       db ": keyf7 $16 ;",0 
60f0 .. 00		keyf8:       db ": keyf8 $17 ;",0 
60fe .. 00		keyf9:       db ": keyf9 $18 ;",0 
610c .. 00		keyf10:       db ": keyf10 $19 ;",0 
611b .. 00		keyf11:       db ": keyf11 $1a ;",0 
612a .. 00		keyf12:       db ": keyf12 $1b ;",0 
6139			 
6139 .. 00		keytab:       db ": keytab $09 ;",0 
6148 .. 00		keycr:       db ": keycr $0d ;",0 
6156 .. 00		keyhome:       db ": keyhome $0e ;",0 
6166 .. 00		keyend:       db ": keyend $0f ;",0 
6175 .. 00		keybs:       db ": keybs $08 ;",0 
6183			 
6183			   
6183			 
6183			 
6183			 
6183			; eof 
# End of file forth_autostart.asm
6183			 
6183 .. 00		sprompt1: db "Startup load...",0 
6193 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
61a9			 
61a9			 
61a9			 
61a9			 
61a9			forth_startup: 
61a9 21 e1 52			ld hl, startcmds 
61ac 3e 00			ld a, 0 
61ae 32 c9 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
61b1			 
61b1 e5			.start1:	push hl 
61b2 cd e9 0a			call clear_display 
61b5 11 83 61			ld de, sprompt1 
61b8 3e 00		        ld a, display_row_1 
61ba cd fc 0a			call str_at_display 
61bd 11 93 61			ld de, sprompt2 
61c0 3e 14		        ld a, display_row_2 
61c2 cd fc 0a			call str_at_display 
61c5 e1				pop hl 
61c6 e5				push hl 
61c7 5e				ld e,(hl) 
61c8 23				inc hl 
61c9 56				ld d,(hl) 
61ca 3e 28		        ld a, display_row_3 
61cc cd fc 0a			call str_at_display 
61cf cd 0c 0b			call update_display 
61d2			 
61d2			 
61d2 3a c9 f3			ld a, (os_last_cmd) 
61d5 fe 00			cp 0 
61d7 28 05			jr z, .startprompt 
61d9 cd 5a 0a			call delay250ms 
61dc 18 24			jr .startdo 
61de				 
61de				 
61de			 
61de			.startprompt: 
61de			 
61de 3e 4f			ld a,display_row_4 + display_cols - 1 
61e0 11 4d 1c		        ld de, endprg 
61e3 cd fc 0a			call str_at_display 
61e6 cd 0c 0b			call update_display 
61e9 cd 66 0a			call delay1s 
61ec cd 58 67			call cin_wait 
61ef						 
61ef fe 2a			cp '*' 
61f1 28 5e			jr z, .startupend1 
61f3 fe 23			cp '#' 
61f5 20 07			jr nz, .startno 
61f7 3e 01			ld a, 1 
61f9 32 c9 f3			ld (os_last_cmd),a 
61fc 18 04			jr .startdo 
61fe fe 31		.startno:	cp '1' 
6200 28 3a			jr z,.startnxt  
6202			 
6202				; exec startup line 
6202			.startdo:	 
6202 e1				pop hl 
6203 e5				push hl 
6204				 
6204 5e				ld e,(hl) 
6205 23				inc hl 
6206 56				ld d,(hl) 
6207 eb				ex de,hl 
6208			 
6208 e5				push hl 
6209			 
6209 3e 00			ld a, 0 
620b				;ld a, FORTH_END_BUFFER 
620b cd 86 11			call strlent 
620e 23				inc hl   ; include zero term to copy 
620f 06 00			ld b,0 
6211 4d				ld c,l 
6212 e1				pop hl 
6213 11 a3 ef			ld de, scratch 
6216 ed b0			ldir 
6218			 
6218			 
6218 21 a3 ef			ld hl, scratch 
621b cd 8e 20			call forthparse 
621e cd ce 20			call forthexec 
6221 cd e5 1f			call forthexec_cleanup 
6224			 
6224 3e 3c			ld a, display_row_4 
6226 11 f1 19			ld de, endprog 
6229			 
6229 cd 0c 0b			call update_display		 
622c			 
622c 3a c9 f3			ld a, (os_last_cmd) 
622f fe 00			cp 0 
6231 20 09			jr nz, .startnxt 
6233 cd 4f 1c			call next_page_prompt 
6236 cd e9 0a		        call clear_display 
6239 cd 0c 0b			call update_display		 
623c			 
623c				; move onto next startup line? 
623c			.startnxt: 
623c			 
623c cd 5a 0a			call delay250ms 
623f e1				pop hl 
6240			 
6240 23				inc hl 
6241 23				inc hl 
6242			 
6242 e5				push hl 
6243 5e				ld e, (hl) 
6244 23				inc hl 
6245 56				ld d, (hl) 
6246 e1				pop hl 
6247				; TODO replace 0 test 
6247			 
6247 eb				ex de, hl 
6248 cd 46 0d			call ishlzero 
624b			;	ld a,e 
624b			;	add d 
624b			;	cp 0    ; any left to do? 
624b eb				ex de, hl 
624c c2 b1 61			jp nz, .start1 
624f 18 01			jr .startupend 
6251			 
6251 e1			.startupend1: pop hl 
6252			.startupend: 
6252			 
6252 cd e9 0a			call clear_display 
6255 cd 0c 0b			call update_display 
6258 c9				ret 
6259			 
6259			 
6259			; stack over and underflow checks 
6259			 
6259			; init the words to detect the under/overflow 
6259			 
6259			chk_stk_init: 
6259				; a vague random number to check so we dont get any "lucky" hits 
6259 3e 2d			ld a, 45 
625b 6f				ld l, a 
625c 00				nop 
625d 3e 17			ld a, 23 
625f 67				ld h, a 
6260			 
6260 22 8a ef			ld (chk_word), hl     ; the word we need to check against 
6263			 
6263			;	ld (chk_stund), hl	; stack points.... 
6263 22 fd fb			ld (chk_stovr), hl 
6266 22 8e f9			ld (chk_ret_und), hl 
6269 22 0c f9			ld (chk_ret_ovr), hl 
626c 22 0a f7			ld (chk_loop_ovr), hl 
626f 22 08 f5			ld (chk_data_ovr), hl 
6272 c9				ret 
6273				 
6273			check_stacks: 
6273				; check all stack words 
6273			 
6273 e5				push hl 
6274 d5				push de 
6275			 
6275			;	ld de,(chk_word) 
6275			;	ld hl, (chk_stund)	; stack points.... 
6275			;	if DEBUG_STK_FAULT 
6275			;		DMARK "FAa" 
6275			;		CALLMONITOR 
6275			;	endif 
6275			;	call cmp16 
6275			;	jp z, .chk_faulta 
6275			; 
6275			;	ld de, sfaultsu 
6275			;	jp .chk_fault 
6275			 
6275 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6278 ed 5b 8a ef		ld de,(chk_word) 
627c				if DEBUG_STK_FAULT 
627c					DMARK "FAb" 
627c					CALLMONITOR 
627c				endif 
627c cd 3b 0d			call cmp16 
627f 28 06			jr z, .chk_fault1 
6281 11 22 63			ld de, sfaultso 
6284 c3 d6 62			jp .chk_fault 
6287			.chk_fault1:  
6287 2a 8e f9			ld hl, (chk_ret_und) 
628a ed 5b 8a ef		ld de,(chk_word) 
628e				if DEBUG_STK_FAULT 
628e					DMARK "FAU" 
628e					CALLMONITOR 
628e				endif 
628e cd 3b 0d			call cmp16 
6291 ca 9a 62			jp z, .chk_fault2 
6294 11 32 63			ld de, sfaultru 
6297 c3 d6 62			jp .chk_fault 
629a			.chk_fault2:  
629a 2a 0c f9			ld hl, (chk_ret_ovr) 
629d ed 5b 8a ef		ld de,(chk_word) 
62a1				if DEBUG_STK_FAULT 
62a1					DMARK "FA1" 
62a1					CALLMONITOR 
62a1				endif 
62a1 cd 3b 0d			call cmp16 
62a4 ca ad 62			jp z, .chk_fault3 
62a7 11 40 63			ld de, sfaultro 
62aa c3 d6 62			jp .chk_fault 
62ad			.chk_fault3:  
62ad 2a 0a f7			ld hl, (chk_loop_ovr) 
62b0 ed 5b 8a ef		ld de,(chk_word) 
62b4				if DEBUG_STK_FAULT 
62b4					DMARK "FA2" 
62b4					CALLMONITOR 
62b4				endif 
62b4 cd 3b 0d			call cmp16 
62b7 ca c0 62			jp z, .chk_fault4 
62ba 11 5a 63			ld de, sfaultlo 
62bd c3 d6 62			jp .chk_fault 
62c0			.chk_fault4:  
62c0 2a 08 f5			ld hl, (chk_data_ovr) 
62c3 ed 5b 8a ef		ld de,(chk_word) 
62c7				if DEBUG_STK_FAULT 
62c7					DMARK "FA3" 
62c7					CALLMONITOR 
62c7				endif 
62c7 cd 3b 0d			call cmp16 
62ca ca d3 62			jp z, .chk_fault5 
62cd 11 74 63			ld de, sfaultdo 
62d0 c3 d6 62			jp .chk_fault 
62d3			 
62d3			 
62d3			.chk_fault5:  
62d3 d1				pop de 
62d4 e1				pop hl 
62d5			 
62d5 c9				ret 
62d6			 
62d6 cd e9 0a		.chk_fault: 	call clear_display 
62d9 3e 14				ld a, display_row_2 
62db cd fc 0a				call str_at_display 
62de 11 04 63				   ld de, .stackfault 
62e1 3e 00				ld a, display_row_1 
62e3 cd fc 0a				call str_at_display 
62e6 11 bd fb				    ld de, debug_mark 
62e9 3e 11				ld a, display_row_1+17 
62eb cd fc 0a				call str_at_display 
62ee cd 0c 0b				call update_display 
62f1			 
62f1				; prompt before entering montior for investigating issue 
62f1			 
62f1 3e 3c			ld a, display_row_4 
62f3 11 f1 19			ld de, endprog 
62f6			 
62f6 cd 0c 0b			call update_display		 
62f9			 
62f9 cd 4f 1c			call next_page_prompt 
62fc			 
62fc d1				pop de 
62fd e1				pop hl 
62fe cd 45 1a				call monitor 
6301 c3 3c 19				jp warmstart 
6304					;jp 0 
6304					;halt 
6304			 
6304			 
6304			 
6304 .. 00		.stackfault: 	db "Stack fault:",0 
6311			 
6311 .. 00		sfaultsu: 	db	"Stack under flow",0 
6322 .. 00		sfaultso: 	db	"Stack over flow",0 
6332 .. 00		sfaultru:	db "RTS underflow",0 
6340 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
635a .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6374 .. 00		sfaultdo:	db "DTS overflow", 0 
6381			 
6381			 
6381			fault_dsp_under: 
6381 11 93 63			ld de, .dsp_under 
6384 c3 43 64			jp .show_fault 
6387			 
6387			fault_rsp_under: 
6387 11 a1 63			ld de, .rsp_under 
638a c3 43 64			jp .show_fault 
638d			fault_loop_under: 
638d 11 af 63			ld de, .loop_under 
6390 c3 43 64			jp .show_fault 
6393			 
6393 .. 00		.dsp_under: db "DSP Underflow",0 
63a1 .. 00		.rsp_under: db "RSP Underflow",0 
63af .. 00		.loop_under: db "LOOP Underflow",0 
63be			 
63be			 
63be d5			type_faultn: 	push de 
63bf e5					push hl 
63c0 cd e9 0a				call clear_display 
63c3 11 ea 63				   ld de, .typefaultn 
63c6 3e 00				ld a, display_row_1 
63c8 cd fc 0a				call str_at_display 
63cb 11 bd fb				    ld de, debug_mark 
63ce 3e 11				ld a, display_row_1+17 
63d0 cd fc 0a				call str_at_display 
63d3 cd 0c 0b				call update_display 
63d6			 
63d6				; prompt before entering montior for investigating issue 
63d6			 
63d6 3e 3c			ld a, display_row_4 
63d8 11 f1 19			ld de, endprog 
63db			 
63db cd 0c 0b			call update_display		 
63de			 
63de cd 4f 1c			call next_page_prompt 
63e1			 
63e1 e5					push hl 
63e2 d5					push de 
63e3 cd 45 1a				call monitor 
63e6 c3 3c 19				jp warmstart 
63e9 76					halt 
63ea			 
63ea			 
63ea .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6401			 
6401 d5			type_faults: 	push de 
6402 e5					push hl 
6403 cd e9 0a				call clear_display 
6406 11 2c 64				   ld de, .typefaults 
6409 3e 00				ld a, display_row_1 
640b cd fc 0a				call str_at_display 
640e 11 bd fb				    ld de, debug_mark 
6411 3e 11				ld a, display_row_1+17 
6413 cd fc 0a				call str_at_display 
6416 cd 0c 0b				call update_display 
6419			 
6419				; prompt before entering montior for investigating issue 
6419			 
6419 3e 3c			ld a, display_row_4 
641b 11 f1 19			ld de, endprog 
641e			 
641e cd 0c 0b			call update_display		 
6421			 
6421 cd 4f 1c			call next_page_prompt 
6424			 
6424 e1					pop hl 
6425 d1					pop de 
6426 cd 45 1a				call monitor 
6429 c3 3c 19				jp warmstart 
642c			 
642c			 
642c .. 00		.typefaults: db "STR Type Expected TOS!",0 
6443			 
6443			.show_fault: 	 
6443 d5					push de 
6444 cd e9 0a				call clear_display 
6447 d1					pop de 
6448 3e 00				ld a, display_row_1 
644a cd fc 0a				call str_at_display 
644d 11 bd fb				    ld de, debug_mark 
6450 3e 11				ld a, display_row_1+17 
6452 cd fc 0a				call str_at_display 
6455 cd 0c 0b				call update_display 
6458			 
6458				; prompt before entering montior for investigating issue 
6458			 
6458 3e 3c			ld a, display_row_4 
645a 11 f1 19			ld de, endprog 
645d			 
645d cd 0c 0b			call update_display		 
6460			 
6460 cd 4f 1c			call next_page_prompt 
6463			 
6463 e1					pop hl 
6464 d1					pop de 
6465 cd 45 1a				call monitor 
6468			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6468			; TODO Make optional fault restart to cli or warm boot? 
6468					;jp warmstart 
6468 c3 97 19				jp cli 
646b 76					halt 
646c			 
646c			; handle the auto run of code from files in storage 
646c			 
646c			 
646c			if STORAGE_SE 
646c			 
646c .. 00		sprompt3: db "Loading from start-up file?:",0 
6489 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
649a			 
649a			 
649a			forth_autoload: 
649a			 
649a				; load block 0 of store 1 
649a				 
649a 3e fe			ld a, $fe      ; bit 0 clear 
649c 32 ce f9			ld (spi_device), a 
649f			 
649f cd ba 03			call storage_get_block_0 
64a2			 
64a2 3a 09 fa			ld a, (store_page+STORE_0_AUTOFILE) 
64a5			 
64a5 fe 00			cp 0 
64a7 c8				ret z     ; auto start not enabled 
64a8			 
64a8 cd e9 0a			call clear_display 
64ab			 
64ab				; set bank 
64ab			 
64ab 3a 0b fa				ld a, (store_page+STORE_0_BANKRUN) 
64ae 32 ce f9				ld (spi_device), a 
64b1			 
64b1				; get file id to load from and get the file name to display 
64b1			 
64b1 3a 0c fa				ld a, (store_page+STORE_0_FILERUN) 
64b4			 
64b4 2e 00				ld l, 0 
64b6 67					ld h, a 
64b7 11 e8 f9				ld de, store_page 
64ba			 
64ba					if DEBUG_FORTH_WORDS 
64ba						DMARK "ASp" 
64ba f5				push af  
64bb 3a cf 64			ld a, (.dmark)  
64be 32 bd fb			ld (debug_mark),a  
64c1 3a d0 64			ld a, (.dmark+1)  
64c4 32 be fb			ld (debug_mark+1),a  
64c7 3a d1 64			ld a, (.dmark+2)  
64ca 32 bf fb			ld (debug_mark+2),a  
64cd 18 03			jr .pastdmark  
64cf ..			.dmark: db "ASp"  
64d2 f1			.pastdmark: pop af  
64d3			endm  
# End of macro DMARK
64d3						CALLMONITOR 
64d3 cd 47 17			call break_point_state  
64d6				endm  
# End of macro CALLMONITOR
64d6					endif 
64d6 cd 54 08				call storage_read 
64d9			 
64d9					if DEBUG_FORTH_WORDS 
64d9						DMARK "ASr" 
64d9 f5				push af  
64da 3a ee 64			ld a, (.dmark)  
64dd 32 bd fb			ld (debug_mark),a  
64e0 3a ef 64			ld a, (.dmark+1)  
64e3 32 be fb			ld (debug_mark+1),a  
64e6 3a f0 64			ld a, (.dmark+2)  
64e9 32 bf fb			ld (debug_mark+2),a  
64ec 18 03			jr .pastdmark  
64ee ..			.dmark: db "ASr"  
64f1 f1			.pastdmark: pop af  
64f2			endm  
# End of macro DMARK
64f2						CALLMONITOR 
64f2 cd 47 17			call break_point_state  
64f5				endm  
# End of macro CALLMONITOR
64f5					endif 
64f5			 
64f5 cd 46 0d				call ishlzero 
64f8 c8					ret z             ; file not found 
64f9			 
64f9 3e 1e				ld a, display_row_2 + 10 
64fb 11 eb f9				ld de, store_page+3 
64fe cd fc 0a				call str_at_display 
6501				 
6501			; 
6501			 
6501 3e 05			ld a, display_row_1+5 
6503 11 6c 64			ld de, sprompt3 
6506 cd fc 0a			call str_at_display 
6509 3e 37			ld a, display_row_3+15 
650b 11 89 64			ld de, sprompt4 
650e cd fc 0a			call str_at_display 
6511			 
6511 cd 0c 0b			call update_display 
6514			 
6514 cd 58 67			call cin_wait 
6517 fe 6e			cp 'n' 
6519 c8				ret z 
651a fe 4e			cp 'N' 
651c c8				ret z 
651d			 
651d cd 66 0a			call delay1s 
6520			 
6520 3a ea f9			ld a, (store_page+2) 
6523 32 de f9			ld (store_openmaxext), a    ; save count of ext 
6526 3e 01			ld a, 1  
6528 32 df f9			ld (store_openext), a    ; save count of ext 
652b			 
652b			.autof:  
652b 6f				ld l , a 
652c				 
652c 3a e8 f9			ld a, (store_page) 
652f 67				ld h, a	 
6530 11 e8 f9			ld de, store_page 
6533					if DEBUG_FORTH_WORDS 
6533						DMARK "ASl" 
6533 f5				push af  
6534 3a 48 65			ld a, (.dmark)  
6537 32 bd fb			ld (debug_mark),a  
653a 3a 49 65			ld a, (.dmark+1)  
653d 32 be fb			ld (debug_mark+1),a  
6540 3a 4a 65			ld a, (.dmark+2)  
6543 32 bf fb			ld (debug_mark+2),a  
6546 18 03			jr .pastdmark  
6548 ..			.dmark: db "ASl"  
654b f1			.pastdmark: pop af  
654c			endm  
# End of macro DMARK
654c						CALLMONITOR 
654c cd 47 17			call break_point_state  
654f				endm  
# End of macro CALLMONITOR
654f					endif 
654f cd 54 08				call storage_read 
6552 cd 46 0d			call ishlzero 
6555 c8				ret z 
6556			;	jr z, .autoend 
6556			 
6556					if DEBUG_FORTH_WORDS 
6556						DMARK "ASc" 
6556 f5				push af  
6557 3a 6b 65			ld a, (.dmark)  
655a 32 bd fb			ld (debug_mark),a  
655d 3a 6c 65			ld a, (.dmark+1)  
6560 32 be fb			ld (debug_mark+1),a  
6563 3a 6d 65			ld a, (.dmark+2)  
6566 32 bf fb			ld (debug_mark+2),a  
6569 18 03			jr .pastdmark  
656b ..			.dmark: db "ASc"  
656e f1			.pastdmark: pop af  
656f			endm  
# End of macro DMARK
656f						CALLMONITOR 
656f cd 47 17			call break_point_state  
6572				endm  
# End of macro CALLMONITOR
6572					endif 
6572 11 ea f9			ld de, store_page+2 
6575 3e 3c			ld a, display_row_4 
6577 cd fc 0a			call str_at_display 
657a			 
657a cd 0c 0b			call update_display 
657d cd 5a 0a			call delay250ms 
6580			 
6580			 
6580			 
6580 21 ea f9			ld hl, store_page+2 
6583 cd 8e 20			call forthparse 
6586 cd ce 20			call forthexec 
6589 cd e5 1f			call forthexec_cleanup 
658c			 
658c				 
658c 3a df f9			ld a, (store_openext) 
658f 3c				inc a 
6590 32 df f9			ld (store_openext), a    ; save count of ext 
6593			 
6593 18 96			jr .autof 
6595			;.autofdone: 
6595			; 
6595			;		if DEBUG_FORTH_WORDS 
6595			;			DMARK "ASx" 
6595			;			CALLMONITOR 
6595			;		endif 
6595			;;	call clear_display 
6595			;	ret 
6595			 
6595			 
6595			 
6595			endif 
6595			 
6595			 
6595			; eof 
# End of file forth_kernel.asm
6595			;include "nascombasic.asm" 
6595			 
6595			 
6595			; find out where the code ends if loaded into RAM (for SC114) 
6595			;endofcode:  
6595			;	nop 
6595			 
6595			 
6595			; eof 
6595			 
# End of file main.asm
6595			include "firmware_lcd_4x20.asm" 
6595			; **********************************************************************  
6595			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6595			; **********************************************************************  
6595			;  
6595			; **  Written as a Small Computer Monitor App  
6595			; **  www.scc.me.uk  
6595			;  
6595			; History  
6595			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6595			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6595			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6595			;  
6595			; **********************************************************************  
6595			;  
6595			; This program is an example of one of the methods of interfacing an   
6595			; alphanumeric LCD module.   
6595			;  
6595			; In this example the display is connected to either a Z80 PIO or a   
6595			; simple 8-bit output port.   
6595			;  
6595			; This interfacing method uses 4-bit data mode and uses time delays  
6595			; rather than polling the display's ready status. As a result the   
6595			; interface only requires 6 simple output lines:  
6595			;   Output bit 0 = not used  
6595			;   Output bit 1 = not used  
6595			;   Output bit 2 = RS         High = data, Low = instruction  
6595			;   Output bit 3 = E          Active high  
6595			;   Output bit 4 = DB4  
6595			;   Output bit 5 = DB5  
6595			;   Output bit 6 = DB6  
6595			;   Output bit 7 = DB7  
6595			; Display's R/W is connected to 0v so it is always in write mode  
6595			;  
6595			; This set up should work with any system supporting the RC2014 bus  
6595			  
6595			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6595			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6595			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6595			;  
6595			; **********************************************************************  
6595			  
6595			; **********************************************************************  
6595			; **  Constants  
6595			; **********************************************************************  
6595			; LCD constants required by LCD support module  
6595			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6595			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6595			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6595			kLCDWidth:  EQU display_cols             ;Width in characters  
6595			  
6595			; **********************************************************************  
6595			; **  Code library usage  
6595			; **********************************************************************  
6595			  
6595			; send character to current cursor position  
6595			; wraps and/or scrolls screen automatically  
6595			  
6595			  
6595			lcd_init:  
6595			  
6595			; SCMonAPI functions used  
6595			  
6595			; Alphanumeric LCD functions used  
6595			; no need to specify specific functions for this module  
6595			  
6595 3e cf		            LD   A, 11001111b  
6597 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6599 3e 00		            LD   A, 00000000b  
659b d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
659d			  
659d			; Initialise alphanumeric LCD module  
659d cd 16 66		            CALL fLCD_Init      ;Initialise LCD module  
65a0			  
65a0 c9				ret  
65a1			  
65a1			;  
65a1			;;  
65a1			; lcd functions  
65a1			;  
65a1			;  
65a1			  
65a1			; what is at cursor position   
65a1			  
65a1			;get_cursor:	ld de, (cursor_row)   ;  row + col  
65a1			;		call curptr  
65a1			;		ret  
65a1			  
65a1			  
65a1			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
65a1			  
65a1			curptr:  
65a1 c5				push bc  
65a2 21 53 fb			ld hl, display_fb0  
65a5			cpr:	  
65a5				; loop for cursor whole row  
65a5 0e 14			ld c, display_cols  
65a7 23			cpr1:	inc hl  
65a8 0d				dec c  
65a9 20 fc			jr nz, cpr1  
65ab 05				dec b  
65ac 20 f7			jr nz, cpr  
65ae			  
65ae				; add col	  
65ae			  
65ae 23			cpr2:	inc hl  
65af 1d				dec e  
65b0 20 fc			jr nz, cpr2  
65b2			  
65b2 c1				pop bc  
65b3 c9				ret  
65b4				  
65b4			  
65b4			  
65b4			  
65b4			  
65b4			; write the frame buffer given in hl to hardware   
65b4 22 5b fa		write_display: ld (display_write_tmp), hl 	   
65b7 3e 00			ld a, kLCD_Line1  
65b9 cd 87 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65bc 06 14			ld b, display_cols  
65be ed 5b 5b fa		ld de, (display_write_tmp)  
65c2 cd 0e 66			call write_len_string  
65c5				  
65c5				  
65c5 2a 5b fa			ld hl, (display_write_tmp)  
65c8 11 14 00			ld de, display_cols  
65cb 19				add hl,de  
65cc 22 5b fa			ld (display_write_tmp),hl  
65cf			  
65cf				  
65cf 3e 40			ld a, kLCD_Line2  
65d1 cd 87 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65d4 06 14			ld b, display_cols  
65d6 ed 5b 5b fa		ld de, (display_write_tmp)  
65da cd 0e 66			call write_len_string  
65dd				  
65dd 2a 5b fa			ld hl, (display_write_tmp)  
65e0 11 14 00			ld de, display_cols  
65e3 19				add hl,de  
65e4 22 5b fa			ld (display_write_tmp),hl  
65e7			  
65e7				  
65e7 3e 14			ld a, kLCD_Line3  
65e9 cd 87 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65ec 06 14			ld b, display_cols  
65ee ed 5b 5b fa		ld de, (display_write_tmp)  
65f2 cd 0e 66			call write_len_string  
65f5				  
65f5 2a 5b fa			ld hl, (display_write_tmp)  
65f8 11 14 00			ld de, display_cols  
65fb 19				add hl,de  
65fc 22 5b fa			ld (display_write_tmp),hl  
65ff			  
65ff				  
65ff 3e 54			ld a, kLCD_Line4  
6601 cd 87 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6604 06 14			ld b, display_cols  
6606 ed 5b 5b fa		ld de, (display_write_tmp)  
660a cd 0e 66			call write_len_string  
660d c9					ret  
660e				  
660e				; write out a fixed length string given in b from de  
660e			  
660e 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
660f cd 60 66		            CALL fLCD_Data      ;Write character to display  
6612 13				inc de  
6613 10 f9			djnz write_len_string  
6615 c9				ret  
6616			  
6616			; Some other things to do  
6616			;            LD   A, kLCD_Clear ;Display clear  
6616			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6616			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6616			;            LD   A, kLCD_On     ;Display on with no cursor  
6616			;            ;LD   A, kLCD_Off   ;Display off  
6616			;            CALL fLCD_Inst      ;Send instruction to display  
6616			;  
6616			;  
6616			;            halt  
6616			;  
6616			;  
6616			;MsgHello:   DB  "Hello World!",0  
6616			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6616			  
6616			; Custom characters 5 pixels wide by 8 pixels high  
6616			; Up to 8 custom characters can be defined  
6616			;BitMaps:      
6616			;; Character 0x00 = Battery icon  
6616			;            DB  01110b  
6616			;            DB  11011b  
6616			;            DB  10001b  
6616			;            DB  10001b  
6616			;            DB  11111b  
6616			;            DB  11111b  
6616			;            DB  11111b  
6616			;            DB  11111b  
6616			;; Character 0x01 = Bluetooth icon  
6616			;            DB  01100b  
6616			;            DB  01010b  
6616			;            DB  11100b  
6616			;            DB  01000b  
6616			;            DB  11100b  
6616			;            DB  01010b  
6616			;            DB  01100b  
6616			;            DB  00000b  
6616			;  
6616			  
6616			  
6616			; **********************************************************************  
6616			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6616			; **********************************************************************  
6616			;  
6616			; **  Written as a Small Computer Monitor App   
6616			; **  Version 0.1 SCC 2018-05-16  
6616			; **  www.scc.me.uk  
6616			;  
6616			; **********************************************************************  
6616			;  
6616			; This module provides support for alphanumeric LCD modules using with  
6616			; *  HD44780 (or compatible) controller  
6616			; *  5 x 7 pixel fonts  
6616			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6616			; *  Interface via six digital outputs to the display (see below)  
6616			;  
6616			; LCD module pinout:  
6616			;   1  Vss   0v supply  
6616			;   2  Vdd   5v supply  
6616			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6616			;   4  RS    High = data, Low = instruction  
6616			;   5  R/W   High = Read, Low = Write  
6616			;   6  E     Enable signal (active high)  
6616			;   7  DB0   Data bit 0  
6616			;   8  DB1   Data bit 1  
6616			;   9  DB2   Data bit 2  
6616			;  10  DB3   Data bit 3  
6616			;  11  DB4   Data bit 4  
6616			;  12  DB5   Data bit 5  
6616			;  13  DB6   Data bit 6  
6616			;  14  DB7   Data bit 7  
6616			;  15  A     Backlight anode (+)  
6616			;  16  K     Backlight cathode (-)  
6616			;  
6616			; This interfacing method uses 4-bit data mode and uses time delays  
6616			; rather than polling the display's ready status. As a result the   
6616			; interface only requires 6 simple output lines:  
6616			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6616			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6616			;   LCD DB4 = Microcomputer output port bit 4  
6616			;   LCD DB5 = Microcomputer output port bit 5  
6616			;   LCD DB6 = Microcomputer output port bit 6  
6616			;   LCD DB7 = Microcomputer output port bit 7  
6616			; Display's R/W is connected to 0v so it is always in write mode  
6616			; All 6 connections must be on the same port address <kLCDPrt>  
6616			; This method also allows a decent length of cable from micro to LCD  
6616			;  
6616			; **********************************************************************  
6616			;  
6616			; To include the code for any given function provided by this module,   
6616			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6616			; the parent source file.  
6616			; For example:  #REQUIRES   uHexPrefix  
6616			;  
6616			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6616			; in the parent source file.  
6616			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6616			;  
6616			; These are the function names provided by this module:  
6616			; fLCD_Init                     ;Initialise LCD  
6616			; fLCD_Inst                     ;Send instruction to LCD  
6616			; fLCD_Data                     ;Send data byte to LCD  
6616			; fLCD_Pos                      ;Position cursor  
6616			; fLCD_Str                      ;Display string  
6616			; fLCD_Def                      ;Define custom character  
6616			;  
6616			; **********************************************************************  
6616			;  
6616			; Requires SCMonAPI.asm to also be included in the project  
6616			;  
6616			  
6616			  
6616			; **********************************************************************  
6616			; **  Constants  
6616			; **********************************************************************  
6616			  
6616			; Constants that must be defined externally  
6616			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6616			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6616			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6616			;kLCDWidth: EQU 20             ;Width in characters  
6616			  
6616			; general line offsets in any frame buffer  
6616			  
6616			  
6616			display_row_1: equ 0  
6616			display_row_2: equ display_row_1+display_cols  
6616			display_row_3: equ display_row_2 + display_cols  
6616			display_row_4: equ display_row_3 + display_cols  
6616			;display_row_4_eol:   
6616			  
6616			  
6616			; Cursor position values for the start of each line  
6616			kLCD_Line1: EQU 0x00   
6616			kLCD_Line2: EQU 0x40    
6616			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6616			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6616			  
6616			; Instructions to send as A register to fLCD_Inst  
6616			kLCD_Clear: EQU 00000001b     ;LCD clear  
6616			kLCD_Off:   EQU 00001000b     ;LCD off  
6616			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6616			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6616			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6616			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6616			  
6616			; Constants used by this code module  
6616			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6616			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6616			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6616			  
6616			  
6616			  
6616			; **********************************************************************  
6616			; **  LCD support functions  
6616			; **********************************************************************  
6616			  
6616			; Initialise alphanumeric LCD module  
6616			; LCD control register codes:  
6616			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6616			;   N    0 = 1-line mode       1 = 2-line mode  
6616			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6616			;   D    0 = Display off       1 = Display on  
6616			;   C    0 = Cursor off        1 = Cursor on  
6616			;   B    0 = Blinking off      1 = Blinking on  
6616			;   ID   0 = Decrement mode    1 = Increment mode  
6616			;   SH   0 = Entire shift off  1 = Entire shift on  
6616 3e 28		fLCD_Init:  LD   A, 40  
6618 cd cd 66		            CALL LCDDelay       ;Delay 40ms after power up  
661b			; For reliable reset set 8-bit mode - 3 times  
661b cd b7 66		            CALL WrFn8bit       ;Function = 8-bit mode  
661e cd b7 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6621 cd b7 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6624			; Set 4-bit mode  
6624 cd b3 66		            CALL WrFn4bit       ;Function = 4-bit mode  
6627 cd cb 66		            CALL LCDDelay1      ;Delay 37 us or more  
662a			; Function set  
662a 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
662c cd 3f 66		            CALL fLCD_Inst      ;2 line, display on  
662f			; Display On/Off control  
662f 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6631 cd 3f 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6634			; Display Clear  
6634 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6636 cd 3f 66		            CALL fLCD_Inst      ;Clear display  
6639			; Entry mode  
6639 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
663b cd 3f 66		            CALL fLCD_Inst      ;Increment mode, shift off  
663e			; Display module now initialised  
663e c9			            RET  
663f			; ok to here  
663f			  
663f			; Write instruction to LCD  
663f			;   On entry: A = Instruction byte to be written  
663f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
663f f5			fLCD_Inst:  PUSH AF  
6640 f5			            PUSH AF  
6641 cd 53 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6644 f1			            POP  AF  
6645 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6646 17			            RLA  
6647 17			            RLA  
6648 17			            RLA  
6649 cd 53 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
664c 3e 02		            LD   A, 2  
664e cd cd 66		            CALL LCDDelay       ;Delay 2 ms to complete   
6651 f1			            POP  AF  
6652 c9			            RET  
6653 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
6655 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6657 cb df		            SET  kLCDBitE, A  
6659 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
665b cb 9f		            RES  kLCDBitE, A  
665d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
665f c9			            RET  
6660			  
6660			  
6660			; Write data to LCD  
6660			;   On entry: A = Data byte to be written  
6660			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6660 f5			fLCD_Data:  PUSH AF  
6661 f5			            PUSH AF  
6662 cd 74 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6665 f1			            POP  AF  
6666 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6667 17			            RLA  
6668 17			            RLA  
6669 17			            RLA  
666a cd 74 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
666d 3e 96		            LD   A, 150  
666f 3d			Wait:      DEC  A              ;Wait a while to allow data   
6670 20 fd		            JR   NZ, Wait      ;  write to complete  
6672 f1			            POP  AF  
6673 c9			            RET  
6674 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
6676 cb d7		            SET  kLCDBitRS, A  
6678 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
667a cb df		            SET  kLCDBitE, A  
667c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
667e cb 9f		            RES  kLCDBitE, A  
6680 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6682 cb 97		            RES  kLCDBitRS, A  
6684 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6686 c9			            RET  
6687			  
6687			  
6687			; Position cursor to specified location  
6687			;   On entry: A = Cursor position  
6687			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6687 f5			fLCD_Pos:   PUSH AF  
6688 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
668a cd 3f 66		            CALL fLCD_Inst      ;Write instruction to LCD  
668d f1			            POP  AF  
668e c9			            RET  
668f			  
668f			  
668f			; Output text string to LCD  
668f			;   On entry: DE = Pointer to null terminated text string  
668f			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
668f 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6690 b7			            OR   A              ;Null terminator?  
6691 c8			            RET  Z              ;Yes, so finished  
6692 cd 60 66		            CALL fLCD_Data      ;Write character to display  
6695 13			            INC  DE             ;Point to next character  
6696 18 f7		            JR   fLCD_Str       ;Repeat  
6698 c9					ret  
6699			  
6699			; Define custom character  
6699			;   On entry: A = Character number (0 to 7)  
6699			;             DE = Pointer to character bitmap data  
6699			;   On exit:  A = Next character number  
6699			;             DE = Next location following bitmap  
6699			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6699			; Character is   
6699 c5			fLCD_Def:   PUSH BC  
669a f5			            PUSH AF  
669b 07			            RLCA                ;Calculate location  
669c 07			            RLCA                ;  for bitmap data  
669d 07			            RLCA                ;  = 8 x CharacterNumber  
669e f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
66a0 cd 3f 66		            CALL fLCD_Inst      ;Write instruction to LCD  
66a3 06 00		            LD   B, 0  
66a5 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
66a6 cd 60 66		            CALL fLCD_Data      ;Write byte to display  
66a9 13			            INC  DE             ;Point to next byte  
66aa 04			            INC  B              ;Count bytes  
66ab cb 58		            BIT  3, B           ;Finish all 8 bytes?  
66ad 28 f6		            JR   Z, Loop       ;No, so repeat  
66af f1			            POP  AF  
66b0 3c			            INC  A              ;Increment character number  
66b1 c1			            POP  BC  
66b2 c9			            RET  
66b3			  
66b3			  
66b3			; **********************************************************************  
66b3			; **  Private functions  
66b3			; **********************************************************************  
66b3			  
66b3			; Write function to LCD  
66b3			;   On entry: A = Function byte to be written  
66b3			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66b3 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
66b5 18 02		            JR   WrFunc  
66b7 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
66b9 f5			WrFunc:     PUSH AF  
66ba d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66bc cb df		            SET  kLCDBitE, A  
66be d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66c0 cb 9f		            RES  kLCDBitE, A  
66c2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66c4 3e 05		            LD   A, 5  
66c6 cd cd 66		            CALL LCDDelay       ;Delay 5 ms to complete  
66c9 f1			            POP  AF  
66ca c9			            RET  
66cb			  
66cb			  
66cb			; Delay in milliseconds  
66cb			;   On entry: A = Number of milliseconds delay  
66cb			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66cb 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
66cd d5			LCDDelay:   PUSH DE  
66ce 5f			            LD   E, A           ;Delay by 'A' ms  
66cf 16 00		            LD   D, 0  
66d1 cd 4b 0a		            CALL aDelayInMS  
66d4 d1			            POP  DE  
66d5 c9			            RET  
66d6			  
66d6			  
66d6			  
66d6			  
66d6			; eof  
66d6			  
# End of file firmware_lcd_4x20.asm
66d6			include "firmware_key_4x4.asm" 
66d6			  
66d6			  
66d6			; bit mask for each scan column and row for teing the matrix  
66d6			  
66d6			; out   
66d6 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
66da			; in  
66da 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
66de			  
66de			; row/col to character map  
66de			  
66de			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
66de			;    
66de			  
66de			; physical key matrix map to face of key  
66de			  
66de			  
66de			;      	1	2	3	A  
66de			;   	abc”	def&	ghi$	s1  
66de			;			  
66de			;	4	5	6	B  
66de			; 	jkl,	mno.	pqr:	s2  
66de			;			  
66de			; 	7	8	9	C  
66de			;	stu;	vwx@	yz?!	s3  
66de			;			  
66de			; 	*	0	#	D  
66de			; 	shift lck '	Space < >	Enter ( )	s4  
66de			;       tab bs 		  
66de			  
66de			  
66de			  
66de			  
66de			key_init:  
66de			  
66de			; SCMonAPI functions used  
66de			  
66de			; Alphanumeric LCD functions used  
66de			; no need to specify specific functions for this module  
66de			  
66de			  
66de 3e cf		            LD   A, 11001111b  
66e0 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
66e2			;            LD   A, 00000000b  
66e2 3e 0f		            LD   A, 00001111b  
66e4 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
66e6			  
66e6			  
66e6				; TODO Configure cursor shapes  
66e6			  
66e6				; Load cursor shapes   
66e6 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
66e8 11 f8 66		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
66eb 06 02		            LD   B, 2           ;Number of characters to define  
66ed cd 99 66		.DefLoop:   CALL fLCD_Def       ;Define custom character  
66f0 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
66f2			  
66f2 3e 01				ld a, 1  
66f4 32 56 fa			ld (cursor_shape),a  
66f7 c9				ret  
66f8			  
66f8			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
66f8			; Up to 8 custom characters can be defined  
66f8			.cursor_shapes:      
66f8			;; Character 0x00 = Normal  
66f8 1f			            DB  11111b  
66f9 1f			            DB  11111b  
66fa 1f			            DB  11111b  
66fb 1f			            DB  11111b  
66fc 1f			            DB  11111b  
66fd 1f			            DB  11111b  
66fe 1f			            DB  11111b  
66ff 1f			            DB  11111b  
6700			;; Character 0x01 = Modifier  
6700 1f			            DB  11111b  
6701 1b			            DB  11011b  
6702 1b			            DB  11011b  
6703 1b			            DB  11011b  
6704 1b			            DB  11011b  
6705 1f			            DB  11111b  
6706 1b			            DB  11011b  
6707 1f			            DB  11111b  
6708			  
6708			  
6708			  
6708			  
6708			; Display custom character 0  
6708			;            LD   A, kLCD_Line1+14  
6708			;            CALL fLCD_Pos       ;Position cursor to location in A  
6708			;            LD   A, 0  
6708			;            CALL fLCD_Data      ;Write character in A at cursor  
6708			  
6708			; Display custom character 1  
6708			;            LD   A, kLCD_Line2+14  
6708			;            CALL fLCD_Pos      ;Position cursor to location in A  
6708			;            LD   A, 1  
6708			;            CALL fLCD_Data     ;Write character in A at cursor  
6708			  
6708			; keyboard scanning   
6708			  
6708			  
6708			; key_rows: equ 4  
6708			; key_cols: equ 4  
6708			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
6708			  
6708			; key_scanr: equ key_row_bitmask  
6708			; key_scanc: equ key_col_bitmask  
6708			  
6708			; key_char_map: equ key_map  
6708			  
6708			  
6708			  
6708			; character in from keyboard  
6708			  
6708 ..			.matrix_to_char: db "D#0*C987B654A321"  
6718			  
6718			  
6718			; map the physical key to a char dependant on state  
6718			  
6718			.key_map_fa:   
6718			  
6718 ..					db 'D'  
6719 0d					db KEY_CR    ; cr  
671a ..					db ' '  
671b 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
671c ..					db 'C'  
671d ..					db 'y'  
671e ..					db 'v'  
671f ..					db 's'  
6720 ..					db 'B'  
6721 ..					db 'p'  
6722 ..					db 'm'  
6723 ..					db 'j'  
6724 ..					db 'A'  
6725 ..					db 'g'  
6726 ..					db 'd'  
6727 ..					db 'a'  
6728			  
6728			.key_map_fb:  
6728			  
6728 ..					db 'A'  
6729 ..					db '+'   
672a ..					db '<'  
672b ..					db  "'"    
672c			  
672c ..					db 'A'  
672d ..					db 'z'  
672e ..					db 'w'  
672f ..					db 't'  
6730 ..					db 'A'  
6731 ..					db 'q'  
6732 ..					db 'n'  
6733 ..					db 'k'  
6734 ..					db 'A'  
6735 ..					db 'h'  
6736 ..					db 'e'  
6737 ..			 		db 'b'  
6738			  
6738			.key_map_fc:   
6738			  
6738			  
6738 ..					db 'A'  
6739 ..					db '-'   
673a ..					db '>'  
673b ..					db  '='   	  
673c ..					db 'A'  
673d ..					db '?'  
673e ..					db 'x'  
673f ..					db 'u'  
6740 ..					db 'A'  
6741 ..					db 'r'  
6742 ..					db 'o'  
6743 ..					db 'l'  
6744 ..					db 'A'  
6745 ..					db 'i'  
6746 ..					db 'f'  
6747 ..					db 'c'  
6748			  
6748				  
6748			.key_map_fd:  
6748			  
6748 ..					db 'A'  
6749 ..					db '/'   
674a ..					db '%'   
674b 08					db KEY_BS  ; back space  
674c ..					db 'A'  
674d ..					db '!'  
674e ..					db '@'  
674f ..					db ';'  
6750 ..					db 'A'  
6751 ..					db ':'  
6752 ..					db '.'  
6753 ..					db ','  
6754 ..					db 'A'  
6755 ..					db '$'  
6756 ..					db '&'  
6757 ..				 	db '"'  
6758			  
6758					  
6758				  
6758			  
6758			; add cin and cin_wait  
6758			  
6758 cd 69 67		cin_wait: 	call cin  
675b fe 00			cp 0  
675d 28 f9			jr z, cin_wait   ; block until key press  
675f			  
675f f5				push af   ; save key pressed  
6760			  
6760 cd 69 67		.cin_wait1:	call cin  
6763 fe 00			cp 0  
6765 20 f9			jr nz, .cin_wait1  	; wait for key release  
6767			  
6767 f1				pop af   ; get key  
6768 c9				ret  
6769			  
6769			  
6769 cd 7a 67		cin: 	call .mtoc  
676c			  
676c				; no key held  
676c fe 00			cp 0  
676e c8				ret z  
676f			  
676f				; stop key bounce  
676f			  
676f			;	ld (key_held),a		 ; save it  
676f 47				ld b, a  
6770			  
6770 c5			.cina1:	push bc  
6771 cd 7a 67			call .mtoc  
6774 c1				pop bc  
6775 b8				cp b  
6776 28 f8			jr z, .cina1  
6778 78				ld a,b		  
6779 c9				ret  
677a			  
677a			; detect keyboard modifier key press and apply new overlay to the face key held  
677a			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
677a			  
677a			;.cin_map_modifier:   
677a			;	ld a, (hl)  
677a			;	and 255  
677a			;	ret NZ		; modifier key not flagged  
677a			;  
677a			;	; get key face  
677a			;  
677a			;	ld b,(key_face_held)  
677a			;  
677a			;	ld b, key_cols * key_rows  
677a			;  
677a			;	push de  
677a			;	pop hl  
677a			;  
677a			;.mmod1: ld a,(hl)   ; get map test  
677a			;	cp b  
677a			;	jr z, .mmod2  
677a			;  
677a			;  
677a			;  
677a			;.mmod2: inc hl    ;   
677a			;  
677a			;	  
677a			;  
677a			;	  
677a			;  
677a			;	ld hl,key_actual_pressed  
677a			;	ld (hl),a,  
677a			;	ret  
677a			  
677a				  
677a			  
677a			; map matrix key held to char on face of key  
677a			  
677a			.mtoc:  
677a			  
677a			  
677a				; TODO optimise the code....  
677a			  
677a			; scan keyboard row 1  
677a 3e 80			ld a, 128  
677c 21 d3 fb			ld hl, keyscan_table  
677f cd 61 68			call .rowscan  
6782			  
6782				   
6782			  
6782 3e 40			ld a, 64  
6784 21 d7 fb			ld hl, keyscan_table+key_cols  
6787 cd 61 68			call .rowscan  
678a			  
678a			  
678a			  
678a			  
678a 3e 20			ld a, 32  
678c 21 db fb			ld hl, keyscan_table+(key_cols*2)  
678f cd 61 68			call .rowscan  
6792			  
6792			  
6792			  
6792 3e 10			ld a, 16  
6794 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6797 cd 61 68			call .rowscan  
679a			  
679a			  
679a				; flag if key D is held down and remove from reporting  
679a 01 48 67			ld bc, .key_map_fd    
679d 21 d3 fb			ld hl, keyscan_table  
67a0 11 c5 fb			ld de, key_fd  
67a3 cd f3 67			call .key_shift_hold  
67a6 fe ff			cp 255  
67a8 28 33			jr z, .cinmap  
67aa				; flag if key C is held down and remove from reporting  
67aa 01 38 67			ld bc, .key_map_fc    
67ad 21 d7 fb			ld hl, keyscan_table+key_cols  
67b0 11 c6 fb			ld de, key_fc  
67b3 cd f3 67			call .key_shift_hold  
67b6 fe ff			cp 255  
67b8 28 23			jr z, .cinmap  
67ba				; flag if key B is held down and remove from reporting  
67ba 01 28 67			ld bc, .key_map_fb    
67bd 21 db fb			ld hl, keyscan_table+(key_cols*2)  
67c0 11 c7 fb			ld de, key_fb  
67c3 cd f3 67			call .key_shift_hold  
67c6 fe ff			cp 255  
67c8 28 13			jr z, .cinmap  
67ca				; flag if key A is held down and remove from reporting  
67ca 01 18 67			ld bc, .key_map_fa    
67cd 21 df fb			ld hl, keyscan_table+(key_cols*3)  
67d0 11 c8 fb			ld de, key_fa  
67d3 cd f3 67			call .key_shift_hold  
67d6 fe ff			cp 255  
67d8 28 03			jr z, .cinmap  
67da			  
67da 11 08 67			ld de, .matrix_to_char  
67dd			  
67dd			  
67dd			.cinmap:   
67dd				if DEBUG_KEY  
67dd			            LD   A, kLCD_Line4  
67dd			            CALL fLCD_Pos       ;Position cursor to location in A  
67dd					push de  
67dd			            LD   DE, keyscan_table  
67dd			            CALL fLCD_Str       ;Display string pointed to by DE  
67dd					pop de  
67dd				endif  
67dd			  
67dd				; scan key matrix table for any held key  
67dd			  
67dd				; de holds either the default matrix or one selected above  
67dd			  
67dd 21 d3 fb			ld hl, keyscan_table  
67e0 06 10			ld b,key_cols*key_rows  
67e2			  
67e2 7e			.cin1:	ld a,(hl)  
67e3 fe 23			cp '#'  
67e5 28 08			jr z, .cinhit  
67e7 23				inc hl  
67e8 13				inc de  
67e9 05				dec b  
67ea 20 f6			jr nz, .cin1  
67ec				; no key found held  
67ec 3e 00			ld a,0  
67ee c9				ret  
67ef d5			.cinhit: push de  
67f0 e1				pop hl  
67f1 7e				ld a,(hl)  
67f2 c9				ret  
67f3			  
67f3			; flag a control key is held   
67f3			; hl is key pin, de is flag indicator  
67f3			  
67f3			.key_shift_hold:  
67f3 c5				push bc  
67f4 3e 01			ld a, 1  
67f6 32 56 fa			ld (cursor_shape),a  
67f9 06 00			ld b, 0  
67fb 7e				ld a, (hl)  
67fc fe 2e			cp '.'  
67fe 28 0a			jr z, .key_shift1  
6800 06 ff			ld b, 255  
6802 3e 2b			ld a, '+'    ; hide key from later scans  
6804 77				ld (hl),a  
6805 3e 02			ld a, 2  
6807 32 56 fa			ld (cursor_shape),a  
680a			.key_shift1:  
680a				; write flag indicator  
680a 78				ld a,b  
680b 12				ld (de),a  
680c			  
680c d1				pop de    ; de now holds the key map ptr  
680d c9				ret  
680e			  
680e				  
680e				  
680e			  
680e			  
680e			  
680e			  
680e			  
680e			  
680e			  
680e			  
680e			  
680e			  
680e c9				ret  
680f			  
680f			;	push hl  
680f			;	push de  
680f			;	push bc  
680f			;	call keyscan  
680f			;	; map key matrix to ascii value of key face  
680f			;  
680f			;	ld hl, key_face_map  
680f			;	ld de, keyscan_table  
680f			;  
680f			;	; get how many keys to look at  
680f			;	ld b, keyscan_table_len  
680f			;	  
680f			;  
680f			;	; at this stage fall out on first key hit  
680f			;	; TODO handle multiple key press  
680f			;  
680f			;map1:	ld a,(hl)  
680f			;	cp '#'  
680f			;	jr z, keyhit  
680f			;	inc hl  
680f			;	inc de  
680f			;	dec b  
680f			;	jr nz, map1  
680f			;nohit:	ld a, 0  
680f			;	jr keydone  
680f			;keyhit: push de  
680f			;	pop hl  
680f			;	ld a,(hl)  
680f			;keydone:  
680f			;	push bc  
680f			;	push de  
680f			; 	push hl  
680f			;	ret   
680f			;  
680f			  
680f			  
680f			  
680f			  
680f			; scan physical key matrix  
680f			  
680f			  
680f			;keyscan:  
680f			;  
680f			;; for each key_row use keyscanr bit mask for out  
680f			;; then read in for keyscanc bitmask  
680f			;; save result of row scan to keyscantable  
680f			;  
680f			;; scan keyboard row 1  
680f			;  
680f			;	ld b, key_rows  
680f			;	ld hl, key_scanr  
680f			;	ld de, keyscan_table  
680f			;  
680f			;rowloop:  
680f			;  
680f			;	ld a,(hl)		; out bit mask to energise keyboard row  
680f			;	call rowscan  
680f			;	inc hl  
680f			;	dec b  
680f			;	jr nz, rowloop  
680f			;  
680f			;	ret  
680f			;  
680f			;  
680f			;; pass a out bitmask, b row number  
680f			;arowscan:   
680f			;	push bc  
680f			;  
680f			;	ld d, b  
680f			;  
680f			;	; calculate buffer location for this row  
680f			;  
680f			;	ld hl, keyscan_table	  
680f			;kbufr:  ld e, key_cols  
680f			;kbufc:	inc hl  
680f			;	dec e  
680f			;	jr nz, kbufc  
680f			;	dec d  
680f			;	jr nz, kbufr  
680f			;  
680f			;	; energise row and read columns  
680f			;  
680f			;	out (portbdata),a  
680f			;	in a,(portbdata)  
680f			;	ld c,a  
680f			;  
680f			;  
680f			;	; save buffer loc  
680f			;  
680f			;	ld (keybufptr), hl  
680f			;  
680f			;	ld hl, key_scanc  
680f			;	ld d, key_cols  
680f			;  
680f			;	; for each column check each bit mask  
680f			;  
680f			;colloop:  
680f			;	  
680f			;  
680f			;	; reset flags for the row   
680f			;  
680f			;	ld b,'.'  
680f			;	and (hl)  
680f			;	jr z, maskskip  
680f			;	ld b,'#'  
680f			;maskskip:  
680f			;	; save  key state  
680f			;	push hl  
680f			;	ld hl, (keybufptr)  
680f			;	ld (hl), b  
680f			;	inc hl  
680f			;	ld (keybufptr), hl  
680f			;  
680f			;	; move to next bit mask  
680f			;	pop hl  
680f			;	inc hl  
680f			;  
680f			;	dec d  
680f			;	jr nz, colloop  
680f			;  
680f			;	ret  
680f			;  
680f			;  
680f			;;  
680f			; lcd functions  
680f			;  
680f			;  
680f			  
680f			;if DEBUG_KEY_MATRIX  
680f			  
680f			; test function to display hardware view of matrix state  
680f			  
680f			matrix:  
680f			  
680f			  
680f			  
680f			; scan keyboard row 1  
680f 3e 80			ld a, 128  
6811 21 f8 fb			ld hl, keyscan_table_row1  
6814 cd 61 68			call .rowscan  
6817			  
6817 3e 40			ld a, 64  
6819 21 f3 fb			ld hl, keyscan_table_row2  
681c cd 61 68			call .rowscan  
681f			  
681f 3e 20			ld a, 32  
6821 21 ee fb			ld hl, keyscan_table_row3  
6824 cd 61 68			call .rowscan  
6827			  
6827 3e 10			ld a, 16  
6829 21 e9 fb			ld hl, keyscan_table_row4  
682c cd 61 68			call .rowscan  
682f			  
682f			; Display text on first line  
682f 3e 00		            LD   A, kLCD_Line1  
6831 cd 87 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6834 11 f8 fb		            LD   DE, keyscan_table_row1  
6837			            ;LD   DE, MsgHello  
6837 cd 8f 66		            CALL fLCD_Str       ;Display string pointed to by DE  
683a			  
683a			; Display text on second line  
683a 3e 40		            LD   A, kLCD_Line2  
683c cd 87 66		            CALL fLCD_Pos       ;Position cursor to location in A  
683f 11 f3 fb		            LD   DE, keyscan_table_row2  
6842 cd 8f 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6845 3e 14		            LD   A, kLCD_Line3  
6847 cd 87 66		            CALL fLCD_Pos       ;Position cursor to location in A  
684a 11 ee fb		            LD   DE, keyscan_table_row3  
684d cd 8f 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6850 3e 54		            LD   A, kLCD_Line4  
6852 cd 87 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6855 11 e9 fb		            LD   DE, keyscan_table_row4  
6858 cd 8f 66		            CALL fLCD_Str       ;Display string pointed to by DE  
685b			  
685b cd 5a 0a			call delay250ms  
685e c3 0f 68			jp matrix  
6861			  
6861			; pass de as row display flags  
6861			.rowscan:   
6861 d3 c1			out (portbdata),a  
6863 db c1			in a,(portbdata)  
6865 4f				ld c,a  
6866				; reset flags for the row   
6866 06 2e			ld b,'.'  
6868 e6 01			and 1  
686a 28 02			jr z, .p1on  
686c 06 23			ld b,'#'  
686e			.p1on:  
686e 70				ld (hl), b  
686f 23				inc hl  
6870			  
6870 06 2e			ld b,'.'  
6872 79				ld a,c  
6873 e6 02			and 2  
6875			;	bit 0,a  
6875 28 02			jr z, .p2on  
6877 06 23			ld b,'#'  
6879			.p2on:  
6879 70				ld (hl), b  
687a 23				inc hl  
687b			;  
687b 06 2e			ld b,'.'  
687d 79				ld a,c  
687e e6 04			and 4  
6880			;;	bit 0,a  
6880 28 02			jr z, .p3on  
6882 06 23			ld b,'#'  
6884			.p3on:  
6884 70				ld (hl), b  
6885 23				inc hl  
6886			;;  
6886 06 2e			ld b,'.'  
6888			;;	bit 0,a  
6888 79				ld a,c  
6889 e6 08			and 8  
688b 28 02			jr z, .p4on  
688d 06 23			ld b,'#'  
688f			.p4on:  
688f 70				ld (hl), b  
6890 23				inc hl  
6891			  
6891			; zero term  
6891 06 00			ld b,0  
6893 70				ld (hl), b  
6894			  
6894 c9			.rscandone: ret  
6895			  
6895			  
6895			  
6895			;endif  
6895			  
6895			  
6895			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6895
