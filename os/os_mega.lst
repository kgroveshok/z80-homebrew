# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 9f 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-09-06 16:19' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 75 76			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
006c			  
006c			debug_umark: equ parse_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 42 fc				ld hl, display_fb1  
006f 22 fe fa				ld (display_fb_active), hl  
0072			  
0072 cd aa 0d				call clear_display  
0075			  
0075 21 00 fb				ld hl, display_fb2  
0078 22 fe fa				ld (display_fb_active), hl  
007b			  
007b cd aa 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 e3 fc				ld hl, display_fb0  
0081 22 fe fa				ld (display_fb_active), hl  
0084			  
0084 cd aa 0d				call clear_display  
0087			  
0087			  
0087 cd 82 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd 19 79			call key_init  
008d cd 56 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 95 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd cd 0d			call update_display  
0096 cd ed 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd af 0d			call fill_display  
009e cd cd 0d			call update_display  
00a1 cd ed 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd af 0d			call fill_display  
00a9 cd cd 0d			call update_display  
00ac cd ed 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd af 0d			call fill_display  
00b4 cd cd 0d			call update_display  
00b7 cd ed 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 9e 1a			ld de, prom_bootmsg  
00bf cd bd 0d			call str_at_display  
00c2 cd cd 0d			call update_display  
00c5			  
00c5			  
00c5 cd ed 0c			call delay1s  
00c8 cd ed 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 b3 1a			ld de, prom_bootmsg1  
00d0 cd bd 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd bd 0d			call str_at_display  
00db			  
00db cd cd 0d			call update_display  
00de cd ed 0c			call delay1s  
00e1 cd ed 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 9d fd		ld (debug_mark),a  
00e9 32 9e fd		ld (debug_mark+1),a  
00ec 32 9f fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a0 fd		ld (debug_mark+3),a  
00f4 32 a1 fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 96 f9			ld a, (spi_clktime) 
00fc fe 00			cp 0 
00fe 28 03			jr z, .scskip 
0100 cd d2 0c			call aDelayInMS 
0103			.scskip: 
0103 f1				pop af 
0104 c9				ret 
0105			 
0105			 
0105			 
0105			; TODO store port id for spi device ie dev c 
0105			; TODO store pin for SO 
0105			; TODO store pin for SI 
0105			; TODO store pin for SCLK 
0105			 
0105			; 
0105			 
0105			; ensure that spi bus is in a stable state with default pins  
0105			 
0105			se_stable_spi:   
0105			 
0105				 ; set DI high, CE high , SCLK low 
0105				;ld a, SPI_DI | SPI_CE0 
0105 3e 07			ld a, SPI_DI  
0107 cd 11 02			call spi_ce_high 
010a d3 80			 out (storage_adata),a 
010c 32 93 f9			ld (spi_portbyte),a 
010f			 
010f				if DEBUG_SPI 
010f					push hl 
010f					ld l, a 
010f					DMARK "SPI" 
010f					CALLMONITOR 
010f					pop hl 
010f				endif 
010f c9				ret 
0110			 
0110			; byte to send in a 
0110			 
0110			spi_send_byte: 
0110				; save byte to send for bit mask shift out 
0110 4f			        ld c,a 
0111 3a 93 f9			ld a,(spi_portbyte) 
0114				  
0114				; clock out	each bit of the byte msb first 
0114			 
0114 06 08			ld b, 8 
0116			.ssb1: 
0116				; clear so bit  
0116 cb bf			res SPI_DI, a 
0118 cb 11			rl c 
011a				; if bit 7 is set then carry is set 
011a 30 02			jr nc, .ssb2 
011c cb ff			set SPI_DI,a 
011e			.ssb2:  ; output bit to ensure it is stable 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126 cd f8 00			call spi_clk 
0129				; then low 
0129 cb af			res SPI_SCLK,a 
012b d3 80			out (storage_adata),a 
012d 00				nop 
012e cd f8 00			call spi_clk 
0131 10 e3			djnz .ssb1 
0133			 
0133 32 93 f9			ld (spi_portbyte),a 
0136 c9				ret 
0137			 
0137			; TODO low level get byte into A on spi 
0137			 
0137			spi_read_byte:  
0137			 
0137				; save byte to send for bit mask shift out 
0137 0e 00		    ld c,0 
0139 3a 93 f9			ld a,(spi_portbyte) 
013c				  
013c				; clock out	each bit of the byte msb first 
013c			 
013c			 
013c				; clock bit high 
013c cb ef			set SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141 cd f8 00			call spi_clk 
0144			 
0144			    ; read DO  
0144			 
0144 cb f9		    set 7,c 
0146 db 80			in a,(storage_adata) 
0148 cb 77		    bit SPI_DO,a 
014a 20 02		    jr nz, .b7 
014c cb b9		    res 7,c 
014e			.b7: 
014e				; then low 
014e cb af			res SPI_SCLK,a 
0150 d3 80			out (storage_adata),a 
0152 00				nop 
0153 cd f8 00			call spi_clk 
0156			     
0156			 
0156				; clock bit high 
0156 cb ef			set SPI_SCLK,a 
0158 d3 80			out (storage_adata),a 
015a 00				nop 
015b cd f8 00			call spi_clk 
015e			 
015e			    ; read DO  
015e			 
015e cb f1		    set 6,c 
0160 db 80			in a,(storage_adata) 
0162 cb 77		    bit SPI_DO,a 
0164 20 02		    jr nz, .b6 
0166 cb b1		    res 6,c 
0168			.b6: 
0168				; then low 
0168 cb af			res SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c 00				nop 
016d cd f8 00			call spi_clk 
0170			 
0170				; clock bit high 
0170 cb ef			set SPI_SCLK,a 
0172 d3 80			out (storage_adata),a 
0174 00				nop 
0175 cd f8 00			call spi_clk 
0178			 
0178			 
0178			    ; read DO  
0178			 
0178 cb e9		    set 5,c 
017a db 80			in a,(storage_adata) 
017c cb 77		    bit SPI_DO,a 
017e 20 02		    jr nz, .b5 
0180 cb a9		    res 5,c 
0182			.b5: 
0182				; then low 
0182 cb af			res SPI_SCLK,a 
0184 d3 80			out (storage_adata),a 
0186 00				nop 
0187 cd f8 00			call spi_clk 
018a				; clock bit high 
018a cb ef			set SPI_SCLK,a 
018c d3 80			out (storage_adata),a 
018e 00				nop 
018f cd f8 00			call spi_clk 
0192			 
0192			    ; read DO  
0192			 
0192 cb e1		    set 4,c 
0194 db 80			in a,(storage_adata) 
0196 cb 77		    bit SPI_DO,a 
0198 20 02		    jr nz, .b4 
019a cb a1		    res 4,c 
019c			.b4: 
019c				; then low 
019c cb af			res SPI_SCLK,a 
019e d3 80			out (storage_adata),a 
01a0 00				nop 
01a1 cd f8 00			call spi_clk 
01a4				; clock bit high 
01a4 cb ef			set SPI_SCLK,a 
01a6 d3 80			out (storage_adata),a 
01a8 00				nop 
01a9 cd f8 00			call spi_clk 
01ac			 
01ac			    ; read DO  
01ac			 
01ac cb d9		    set 3,c 
01ae db 80			in a,(storage_adata) 
01b0 cb 77		    bit SPI_DO,a 
01b2 20 02		    jr nz, .b3 
01b4 cb 99		    res 3,c 
01b6			.b3: 
01b6				; then low 
01b6 cb af			res SPI_SCLK,a 
01b8 d3 80			out (storage_adata),a 
01ba 00				nop 
01bb cd f8 00			call spi_clk 
01be				; clock bit high 
01be cb ef			set SPI_SCLK,a 
01c0 d3 80			out (storage_adata),a 
01c2 00				nop 
01c3 cd f8 00			call spi_clk 
01c6			 
01c6			    ; read DO  
01c6			 
01c6 cb d1		    set 2,c 
01c8 db 80			in a,(storage_adata) 
01ca cb 77		    bit SPI_DO,a 
01cc 20 02		    jr nz, .b2 
01ce cb 91		    res 2,c 
01d0			.b2: 
01d0				; then low 
01d0 cb af			res SPI_SCLK,a 
01d2 d3 80			out (storage_adata),a 
01d4 00				nop 
01d5 cd f8 00			call spi_clk 
01d8				; clock bit high 
01d8 cb ef			set SPI_SCLK,a 
01da d3 80			out (storage_adata),a 
01dc 00				nop 
01dd cd f8 00			call spi_clk 
01e0			 
01e0			    ; read DO  
01e0			 
01e0 cb c9		    set 1,c 
01e2 db 80			in a,(storage_adata) 
01e4 cb 77		    bit SPI_DO,a 
01e6 20 02		    jr nz, .b1 
01e8 cb 89		    res 1,c 
01ea			.b1: 
01ea				; then low 
01ea cb af			res SPI_SCLK,a 
01ec d3 80			out (storage_adata),a 
01ee 00				nop 
01ef cd f8 00			call spi_clk 
01f2				; clock bit high 
01f2 cb ef			set SPI_SCLK,a 
01f4 d3 80			out (storage_adata),a 
01f6 00				nop 
01f7 cd f8 00			call spi_clk 
01fa			 
01fa			    ; read DO  
01fa			 
01fa cb c1		    set 0,c 
01fc db 80			in a,(storage_adata) 
01fe cb 77		    bit SPI_DO,a 
0200 20 02		    jr nz, .b0 
0202 cb 81		    res 0,c 
0204			.b0: 
0204				; then low 
0204 cb af			res SPI_SCLK,a 
0206 d3 80			out (storage_adata),a 
0208 00				nop 
0209 cd f8 00			call spi_clk 
020c			 
020c			 
020c 32 93 f9			ld (spi_portbyte),a 
020f			 
020f			    ; return byte 
020f 79			    ld a,c 
0210			 
0210			 
0210 c9				ret 
0211			 
0211			 
0211			 
0211			spi_ce_high: 
0211			 
0211				if DEBUG_SPI_HARD_CE0 
0211			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0211					ret 
0211			 
0211				endif 
0211			 
0211			 
0211 f5				push af 
0212			 
0212				; send direct ce to port b 
0212 3e ff			ld a, 255 
0214 d3 81			out (storage_bdata), a 
0216			 
0216 f1				pop af 
0217			 
0217				; for port a that shares with spi lines AND the mask 
0217			  
0217				if DEBUG_SPI 
0217					push hl 
0217					ld h, a 
0217				endif 
0217			;	ld c, SPI_CE_HIGH 
0217			;	and c 
0217 cb c7			set SPI_CE0, a 
0219 cb cf			set SPI_CE1, a 
021b cb d7			set SPI_CE2, a 
021d cb df			set SPI_CE3, a 
021f cb e7			set SPI_CE4, a 
0221			 
0221				if DEBUG_SPI 
0221					ld l, a 
0221					DMARK "CEh" 
0221					CALLMONITOR 
0221					pop hl 
0221				endif 
0221 c9				ret 
0222			 
0222			 
0222			spi_ce_low: 
0222			 
0222				if DEBUG_SPI_HARD_CE0 
0222			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0222					ret 
0222			 
0222				endif 
0222			 
0222 c5				push bc 
0223 f5				push af 
0224			 
0224				; send direct ce to port b 
0224 3a 95 f9			ld a, (spi_cartdev) 
0227 d3 81			out (storage_bdata), a 
0229			 
0229			 
0229			 
0229				; for port a that shares with spi lines AND the mask 
0229			 
0229 3a 92 f9			ld a, (spi_device)  
022c 4f				ld c, a 
022d			 
022d f1				pop af 
022e			 
022e				; detect CEx 
022e			 
022e				if DEBUG_SPI 
022e					push hl 
022e					ld h, a 
022e				endif 
022e			 
022e cb 41			bit SPI_CE0, c 
0230 20 04			jr nz, .cel1 
0232 cb 87			res SPI_CE0, a 
0234 18 1e			jr .celn 
0236			.cel1: 
0236 cb 49			bit SPI_CE1, c 
0238 20 04			jr nz, .cel2 
023a cb 8f			res SPI_CE1, a 
023c 18 16			jr .celn 
023e			.cel2: 
023e cb 51			bit SPI_CE2, c 
0240 20 04			jr nz, .cel3 
0242 cb 97			res SPI_CE2, a 
0244 18 0e			jr .celn 
0246			.cel3: 
0246 cb 59			bit SPI_CE3, c 
0248 20 04			jr nz, .cel4 
024a cb 9f			res SPI_CE3, a 
024c 18 06			jr .celn 
024e			.cel4: 
024e cb 61			bit SPI_CE4, c 
0250 20 02			jr nz, .celn 
0252 cb a7			res SPI_CE4, a 
0254			.celn: 
0254			 
0254			 
0254			 
0254			;	add c 
0254			 
0254				if DEBUG_SPI 
0254					ld l, a 
0254					DMARK "CEl" 
0254					CALLMONITOR 
0254					pop hl 
0254				endif 
0254 c1				pop bc 
0255 c9				ret 
0256			 
0256			 
0256			 
0256			; eof 
0256			 
0256			 
0256			 
0256			 
0256			 
# End of file firmware_spi.asm
0256				include "firmware_seeprom.asm"  
0256			; 
0256			; persisent storage interface via microchip serial eeprom 
0256			 
0256			; port a pio 2 
0256			; pa 7 - si 
0256			; pa 6 - sclk  
0256			; pa 5 - so 
0256			; pa 4 - cs 
0256			; pa 3 - cs 
0256			; pa 2 - cs 
0256			; pa 1 - cs 
0256			; pa 0 - cs 
0256			; 
0256			; TODO get block 
0256			; TODO save block 
0256			; TODO load file 
0256			; TODO save file 
0256			; TODO get dir  
0256			 
0256			;  
0256			storage_adata: equ Device_C    ; device c port a - onboard storage 
0256			storage_actl: equ Device_C+2     ; device c port a 
0256			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0256			storage_bctl: equ Device_C+3     ; device c port b 
0256			 
0256			 
0256			; TODO move these to hardware driver file 
0256			 
0256			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0256			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0256			; storage bank file system format 
0256			; 
0256			; first page of bank: 
0256			; 	addr 0 - status check 
0256			;       addr 1 - write protect flag 
0256			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0256			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0256			;         TODO see if scanning whole of for available next file id is fast enough 
0256			;	addr 4 > zero term string of bank label 
0256			; 
0256			;        
0256			;  
0256			; first page of any file: 
0256			;      byte 0 - file id  
0256			;      byte 1-17 - fixed file name  
0256			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0256			; 
0256			; other pages of any file: 
0256			;      byte 0 - file id 
0256			;      byte 1> - file data 
0256			; 
0256			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0256			;  
0256			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0256			 
0256			 
0256			;storage_so_bit: 5 
0256			;storage_si_bit: 7 
0256			;storage_sclk_bit: 6 
0256			  
0256			 
0256			; init storage pio 
0256			 
0256			storage_init: 
0256			 
0256			 
0256					; set default SPI clk pulse time as disabled 
0256			 
0256 3e 00				ld a, 0 
0258 32 96 f9				ld (spi_clktime), a 
025b			 
025b					; init hardware 
025b			 
025b 3e cf		            LD   A, 11001111b 
025d d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
025f 3e 00		            LD   A, 00000000b 
0261 cb f7			set SPI_DO,a 
0263			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0263 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0265			 
0265 3e cf		            LD   A, 11001111b 
0267 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0269 3e 00		            LD   A, 00000000b 
026b d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
026d			 
026d				; set all external spi devices off  
026d 3e ff			ld a, 255 
026f 32 92 f9			ld (spi_device), a 
0272 32 95 f9			ld (spi_cartdev), a 
0275			 
0275					; ensure the spi bus is in a default stable state 
0275 cd 05 01				call se_stable_spi 
0278			 
0278			; TODO scan spi bus and gather which storage banks are present 
0278			 
0278			; populate store_bank_active  
0278			; for each ce line activate and attempt to write first byte of bank and read back 
0278			; if zero is returned then bank is empty 
0278			;   
0278			; 
0278			 
0278					; init file extent cache to save on slow reads 
0278			 
0278			;	ld hl, store_filecache 
0278			;	ld de, 0 
0278			;	ld hl,(de)	 
0278			 
0278			 
0278 c9			    ret 
0279			 
0279			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0279			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0279			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0279			 
0279			; INSTRUCTION SET 
0279			; READ 0000 0011 Read data from memory array beginning at selected address 
0279			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0279			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0279			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0279			; RDSR 0000 0101 Read STATUS register 
0279			; WRSR 0000 0001 Write STATUS register 
0279			; PE 0100 0010 Page Erase – erase one page in memory array 
0279			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0279			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0279			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0279			 
0279			; TODO send byte steam for page without setting the address for every single byte 
0279			; TODO read byte  
0279			 
0279			; byte in a 
0279			; address in hl  
0279			se_writebyte: 
0279			        
0279			    ;   ld c, a 
0279 f5			        push af 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a 93 f9		       ld a,(spi_portbyte) 
027e cd 22 02			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 93 f9		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 06		    ld a, store_wren_ins 
0288 cd 10 01		    call spi_send_byte  
028b			 
028b			    ;cs high to enable write latch 
028b			 
028b 3a 93 f9		       ld a,(spi_portbyte) 
028e cd 11 02			call spi_ce_high 
0291			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0291 d3 80		       out (storage_adata),a 
0293 32 93 f9		       ld (spi_portbyte), a 
0296			 
0296 00				nop 
0297			    ; 
0297			    ; intial write data 
0297			    ; 
0297			    ; cs low 
0297			     
0297 3a 93 f9		       ld a,(spi_portbyte) 
029a cd 22 02			call spi_ce_low 
029d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
029d d3 80		       out (storage_adata),a 
029f 32 93 f9		       ld (spi_portbyte), a 
02a2			 
02a2			    ; clock out write instruction 
02a2			     
02a2 3e 02		    ld a, store_write_ins  
02a4 cd 10 01		    call spi_send_byte  
02a7			 
02a7			    ; clock out address (depending on address size) 
02a7			     
02a7 e1			    pop hl 
02a8 7c			    ld a,h    ; address out msb first 
02a9 cd 10 01		    call spi_send_byte  
02ac 7d			    ld a,l 
02ad cd 10 01		    call spi_send_byte  
02b0			 
02b0			    ; clock out byte(s) for page 
02b0			 
02b0 f1			    pop af 
02b1 cd 10 01		    call spi_send_byte  
02b4			 
02b4			    ; end write with ce high 
02b4 3a 93 f9		       ld a,(spi_portbyte) 
02b7			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b7 cd 11 02			call spi_ce_high 
02ba d3 80		       out (storage_adata),a 
02bc 32 93 f9		       ld (spi_portbyte), a 
02bf			 
02bf				; pause for internal write cycle 
02bf 3e 0a			ld a, 10 
02c1 cd d2 0c			call aDelayInMS 
02c4 c9			    ret 
02c5			 
02c5			; buffer to write in de 
02c5			; address in hl  
02c5			se_writepage: 
02c5			        
02c5			    ;   ld c, a 
02c5 d5				push de 
02c6 e5			        push hl 
02c7			 
02c7			    ; initi write mode 
02c7			    ; 
02c7			    ;CS low 
02c7			 
02c7 3a 93 f9		       ld a,(spi_portbyte) 
02ca cd 22 02			call spi_ce_low 
02cd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cd d3 80		       out (storage_adata),a 
02cf 32 93 f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ;clock out wren instruction 
02d2			 
02d2 3e 06		    ld a, store_wren_ins 
02d4 cd 10 01		    call spi_send_byte  
02d7			 
02d7			    ;cs high to enable write latch 
02d7			 
02d7 3a 93 f9		       ld a,(spi_portbyte) 
02da cd 11 02			call spi_ce_high 
02dd			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02dd d3 80		       out (storage_adata),a 
02df 32 93 f9		       ld (spi_portbyte), a 
02e2			 
02e2 00				nop 
02e3			    ; 
02e3			    ; intial write data 
02e3			    ; 
02e3			    ; cs low 
02e3			     
02e3 3a 93 f9		       ld a,(spi_portbyte) 
02e6			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02e6 cd 22 02			call spi_ce_low 
02e9 d3 80		       out (storage_adata),a 
02eb 32 93 f9		       ld (spi_portbyte), a 
02ee			 
02ee			    ; clock out write instruction 
02ee			     
02ee 3e 02		    ld a, store_write_ins  
02f0 cd 10 01		    call spi_send_byte  
02f3			 
02f3			    ; clock out address (depending on address size) 
02f3			     
02f3 e1			    pop hl 
02f4 7c			    ld a,h    ; address out msb first 
02f5 cd 10 01		    call spi_send_byte  
02f8 7d			    ld a,l 
02f9 cd 10 01		    call spi_send_byte  
02fc			 
02fc			    ; clock out byte(s) for page 
02fc			 
02fc e1				pop hl 
02fd 06 40			ld b, STORE_BLOCK_PHY 
02ff			.bytewrite: 
02ff			 
02ff 7e				ld a,(hl) 
0300 e5			    push hl 
0301 c5				push bc 
0302 cd 10 01		    call spi_send_byte  
0305 c1				pop bc 
0306 e1				pop hl 
0307			 
0307			    ; end write with ce high 
0307 3a 93 f9		       ld a,(spi_portbyte) 
030a cd 11 02			call spi_ce_high 
030d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
030d d3 80		       out (storage_adata),a 
030f 32 93 f9		       ld (spi_portbyte), a 
0312			 
0312 23				inc hl 
0313 10 ea			djnz .bytewrite 
0315			 
0315				; pause for internal write cycle 
0315 3e 64			ld a, 100 
0317 cd d2 0c			call aDelayInMS 
031a c9			    ret 
031b			; returns byte in a 
031b			; address in hl  
031b			se_readbyte: 
031b d5				push de 
031c c5				push bc 
031d			 
031d			    ;   ld c, a 
031d e5			        push hl 
031e			 
031e			    ; initi write mode 
031e			    ; 
031e			    ;CS low 
031e			 
031e 3a 93 f9		       ld a,(spi_portbyte) 
0321 cd 22 02			call spi_ce_low 
0324			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0324 d3 80		       out (storage_adata),a 
0326 32 93 f9		       ld (spi_portbyte), a 
0329			 
0329			    ;clock out wren instruction 
0329			 
0329 3e 03		    ld a, store_read_ins 
032b cd 10 01		    call spi_send_byte  
032e			 
032e			 
032e			    ; clock out address (depending on address size) 
032e			     
032e e1			    pop hl 
032f 7c			    ld a,h    ; address out msb first 
0330 cd 10 01		    call spi_send_byte  
0333 7d			    ld a,l 
0334 cd 10 01		    call spi_send_byte  
0337			 
0337			    ; clock in byte(s) for page 
0337			 
0337 cd 37 01		    call spi_read_byte  
033a f5				push af 
033b			 
033b			    ; end write with ce high 
033b 3a 93 f9		       ld a,(spi_portbyte) 
033e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
033e cd 11 02			call spi_ce_high 
0341 d3 80		       out (storage_adata),a 
0343 32 93 f9		       ld (spi_portbyte), a 
0346			 
0346 f1				pop af 
0347			 
0347 c1				pop bc 
0348 d1				pop de 
0349			 
0349 c9			    ret 
034a			 
034a			if DEBUG_STORESE 
034a			 
034a			storageput:  
034a			 
034a			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
034a			 
034a 21 f5 f0			ld hl,scratch+2 
034d cd 9d 12			call get_word_hl 
0350			 
0350				; stuff it here for the moment as it will be overwritten later anyway 
0350			 
0350 22 16 f4			ld (os_cur_ptr),hl	 
0353			 
0353			 
0353			; get pointer to start of string 
0353			 
0353 21 fa f0			ld hl, scratch+7 
0356			 
0356			; loop writing char of string to eeprom 
0356			 
0356 7e			.writestr:	ld a,(hl) 
0357 fe 00				cp 0 
0359 28 12				jr z, .wsdone		; done writing 
035b e5					push hl 
035c 2a 16 f4				ld hl,(os_cur_ptr) 
035f cd 79 02				call se_writebyte 
0362			 
0362 2a 16 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0365 23					inc hl 
0366 22 16 f4				ld (os_cur_ptr),hl 
0369			 
0369					; restore string pointer and get next char 
0369			 
0369 e1					pop hl 
036a 23					inc hl 
036b 18 e9				jr .writestr 
036d			 
036d			 
036d			 
036d			.wsdone: 
036d			 
036d			 
036d			; when done load first page into a buffer  
036d			 
036d 21 00 80				ld hl,08000h		; start in ram 
0370 22 16 f4				ld (os_cur_ptr),hl 
0373 21 00 00				ld hl, 0		 ; start of page 
0376 22 1b f1				ld (scratch+40),hl	; hang on to it 
0379			 
0379 06 80				ld b, 128		; actually get more then one page 
037b c5			.wsload:	push bc 
037c 2a 1b f1				ld hl,(scratch+40) 
037f e5					push hl 
0380 cd 1b 03				call se_readbyte 
0383			 
0383					; a now as the byte 
0383			 
0383 2a 16 f4				ld hl,(os_cur_ptr) 
0386 77					ld (hl),a 
0387					; inc next buffer area 
0387 23					inc hl 
0388 22 16 f4				ld (os_cur_ptr),hl 
038b			 
038b					; get eeprom position, inc and save for next round 
038b e1					pop hl		 
038c 23					inc hl 
038d 22 1b f1				ld (scratch+40),hl 
0390 c1					pop bc 
0391 10 e8				djnz .wsload 
0393			 
0393			; set 'd' pointer to start of buffer 
0393			 
0393 21 00 80				ld hl,08000h 
0396 22 16 f4				ld (os_cur_ptr),hl 
0399			 
0399			 
0399 c9			ret 
039a			 
039a			 
039a c9			storageread: ret 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			endif 
039b			 
039b			 
039b			 
# End of file firmware_seeprom.asm
039b			else  
039b			   ; create some stubs for the labels  
039b			se_readbyte: ret  
039b			se_writebyte: ret  
039b			storage_init: ret  
039b			  
039b			endif  
039b			  
039b			; use cf card for storage - throwing timeout errors. Hardware or software?????  
039b			;include "firmware_cf.asm"  
039b			  
039b			; load up high level storage hardward abstractions  
039b			include "firmware_storage.asm"  
039b			 
039b			; persisent storage hardware abstraction layer  
039b			 
039b			 
039b			 
039b			; Block 0 on storage is a config state 
039b			 
039b			 
039b			 
039b			; TODO add read phy block and write phy block functions 
039b			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
039b			 
039b			; Abstraction layer  
039b			 
039b			; Logocial block size is same size as physical size - using tape concept 
039b			 
039b			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
039b			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
039b			 
039b			 
039b			 
039b			; Filesystem layout (Logical layout) 
039b			; 
039b			; Block 0 - Bank config  
039b			; 
039b			;      Byte - 0 file id counter 
039b			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
039b			;      Byte - 3-20 zero terminated bank label 
039b			; 
039b			; Block 1 > File storage 
039b			; 
039b			;      Byte 0 file id    - block 0 file details 
039b			;      Byte 1 block id - block 0 is file  
039b			;            Byte 2-15 - File name 
039b			; 
039b			;       - to end of block data 
039b			; 
039b			 
039b			; Get ID for the file named in pointer held HL 
039b			; Returns ID in HL = 255 if no file found 
039b			 
039b			storage_getid: 
039b			 
039b 22 a5 f9			ld (store_tmp1), hl 
039e			 
039e				if DEBUG_STORESE 
039e					DMARK "SGI" 
039e f5				push af  
039f 3a b3 03			ld a, (.dmark)  
03a2 32 9d fd			ld (debug_mark),a  
03a5 3a b4 03			ld a, (.dmark+1)  
03a8 32 9e fd			ld (debug_mark+1),a  
03ab 3a b5 03			ld a, (.dmark+2)  
03ae 32 9f fd			ld (debug_mark+2),a  
03b1 18 03			jr .pastdmark  
03b3 ..			.dmark: db "SGI"  
03b6 f1			.pastdmark: pop af  
03b7			endm  
# End of macro DMARK
03b7					CALLMONITOR 
03b7 cd aa fd			call debug_vector  
03ba				endm  
# End of macro CALLMONITOR
03ba				endif 
03ba				; get block 0 and set counter for number of files to scan 
03ba			 
03ba cd 25 05			call storage_get_block_0 
03bd			 
03bd 3a ac f9			ld a, (store_page) 
03c0 47				ld b, a 
03c1			 
03c1				; get extent 0 of each file id 
03c1			 
03c1				if DEBUG_STORESE 
03c1					DMARK "SGc" 
03c1 f5				push af  
03c2 3a d6 03			ld a, (.dmark)  
03c5 32 9d fd			ld (debug_mark),a  
03c8 3a d7 03			ld a, (.dmark+1)  
03cb 32 9e fd			ld (debug_mark+1),a  
03ce 3a d8 03			ld a, (.dmark+2)  
03d1 32 9f fd			ld (debug_mark+2),a  
03d4 18 03			jr .pastdmark  
03d6 ..			.dmark: db "SGc"  
03d9 f1			.pastdmark: pop af  
03da			endm  
# End of macro DMARK
03da					CALLMONITOR 
03da cd aa fd			call debug_vector  
03dd				endm  
# End of macro CALLMONITOR
03dd				endif 
03dd 60			.getloop:	ld h, b 
03de 2e 00				ld l, 0 
03e0 c5					push bc 
03e1			 
03e1 11 ac f9				ld de, store_page 
03e4				if DEBUG_STORESE 
03e4					DMARK "SGr" 
03e4 f5				push af  
03e5 3a f9 03			ld a, (.dmark)  
03e8 32 9d fd			ld (debug_mark),a  
03eb 3a fa 03			ld a, (.dmark+1)  
03ee 32 9e fd			ld (debug_mark+1),a  
03f1 3a fb 03			ld a, (.dmark+2)  
03f4 32 9f fd			ld (debug_mark+2),a  
03f7 18 03			jr .pastdmark  
03f9 ..			.dmark: db "SGr"  
03fc f1			.pastdmark: pop af  
03fd			endm  
# End of macro DMARK
03fd					CALLMONITOR 
03fd cd aa fd			call debug_vector  
0400				endm  
# End of macro CALLMONITOR
0400				endif 
0400 cd cd 09				call storage_read 
0403 cd 07 10				call ishlzero 
0406 28 2d				jr z, .gap 
0408					 
0408					; have a file name read. Is it one we want. 
0408			 
0408 2a a5 f9				ld hl, (store_tmp1) 
040b 11 af f9				ld de, store_page+3   ; file name 
040e			 
040e				if DEBUG_STORESE 
040e					DMARK "SGc" 
040e f5				push af  
040f 3a 23 04			ld a, (.dmark)  
0412 32 9d fd			ld (debug_mark),a  
0415 3a 24 04			ld a, (.dmark+1)  
0418 32 9e fd			ld (debug_mark+1),a  
041b 3a 25 04			ld a, (.dmark+2)  
041e 32 9f fd			ld (debug_mark+2),a  
0421 18 03			jr .pastdmark  
0423 ..			.dmark: db "SGc"  
0426 f1			.pastdmark: pop af  
0427			endm  
# End of macro DMARK
0427					CALLMONITOR 
0427 cd aa fd			call debug_vector  
042a				endm  
# End of macro CALLMONITOR
042a				endif 
042a cd 7c 13				call strcmp 
042d 20 06				jr nz, .gap   ; not this one 
042f			 
042f c1				        pop bc 
0430			 
0430 26 00				ld h, 0 
0432 68					ld l, b 
0433 18 22				jr .getdone 
0435						 
0435			 
0435			 
0435			 
0435			.gap: 
0435				if DEBUG_STORESE 
0435					DMARK "SGg" 
0435 f5				push af  
0436 3a 4a 04			ld a, (.dmark)  
0439 32 9d fd			ld (debug_mark),a  
043c 3a 4b 04			ld a, (.dmark+1)  
043f 32 9e fd			ld (debug_mark+1),a  
0442 3a 4c 04			ld a, (.dmark+2)  
0445 32 9f fd			ld (debug_mark+2),a  
0448 18 03			jr .pastdmark  
044a ..			.dmark: db "SGg"  
044d f1			.pastdmark: pop af  
044e			endm  
# End of macro DMARK
044e					CALLMONITOR 
044e cd aa fd			call debug_vector  
0451				endm  
# End of macro CALLMONITOR
0451				endif 
0451			 
0451 c1					pop bc 
0452 10 89				djnz .getloop 
0454 21 ff 00				ld hl, 255 
0457			.getdone: 
0457			 
0457				if DEBUG_STORESE 
0457					DMARK "SGe" 
0457 f5				push af  
0458 3a 6c 04			ld a, (.dmark)  
045b 32 9d fd			ld (debug_mark),a  
045e 3a 6d 04			ld a, (.dmark+1)  
0461 32 9e fd			ld (debug_mark+1),a  
0464 3a 6e 04			ld a, (.dmark+2)  
0467 32 9f fd			ld (debug_mark+2),a  
046a 18 03			jr .pastdmark  
046c ..			.dmark: db "SGe"  
046f f1			.pastdmark: pop af  
0470			endm  
# End of macro DMARK
0470					CALLMONITOR 
0470 cd aa fd			call debug_vector  
0473				endm  
# End of macro CALLMONITOR
0473				endif 
0473			 
0473 c9				ret 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			; Read Block 
0474			; ---------- 
0474			; 
0474			; With current bank 
0474			;  
0474			; Get block number to read 
0474			; Load physical blocks starting at start block into buffer 
0474			 
0474			; de points to buffer to use 
0474			; hl holds logical block number  
0474			 
0474			storage_read_block: 
0474			 
0474				; TODO bank selection 
0474			 
0474				; for each of the physical blocks read it into the buffer 
0474 06 40			ld b, STORE_BLOCK_PHY 
0476			 
0476				if DEBUG_STORESE 
0476 d5					push de 
0477				endif 
0477				 
0477			.rl1:    
0477			 
0477				; read physical block at hl into de 
0477			        ; increment hl and de to next read position on exit 
0477			 
0477 e5				push hl 
0478 d5				push de	 
0479 c5				push bc 
047a			;	if DEBUG_STORESE 
047a			;		push af 
047a			;		ld a, 'R' 
047a			;		ld (debug_mark),a 
047a			;		pop af 
047a			;		CALLMONITOR 
047a			;	endif 
047a cd 1b 03			call se_readbyte 
047d			;	if DEBUG_STORESE 
047d			;		ld a,(spi_portbyte) 
047d			;		ld l, a 
047d			;		push af 
047d			;		ld a, '1' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d			;		CALLMONITOR 
047d			;	endif 
047d c1				pop bc 
047e d1				pop de 
047f e1				pop hl 
0480 12				ld (de),a 
0481 23				inc hl 
0482 13				inc de 
0483			 
0483			;	if DEBUG_STORESE 
0483			;		push af 
0483			;		ld a, 'r' 
0483			;		ld (debug_mark),a 
0483			;		pop af 
0483			;		CALLMONITOR 
0483			;	endif 
0483			 
0483 10 f2			djnz .rl1 
0485			 
0485				if DEBUG_STORESE 
0485					DMARK "SRB" 
0485 f5				push af  
0486 3a 9a 04			ld a, (.dmark)  
0489 32 9d fd			ld (debug_mark),a  
048c 3a 9b 04			ld a, (.dmark+1)  
048f 32 9e fd			ld (debug_mark+1),a  
0492 3a 9c 04			ld a, (.dmark+2)  
0495 32 9f fd			ld (debug_mark+2),a  
0498 18 03			jr .pastdmark  
049a ..			.dmark: db "SRB"  
049d f1			.pastdmark: pop af  
049e			endm  
# End of macro DMARK
049e d1					pop de 
049f			; 
049f			;		push af 
049f			;		ld a, 'R' 
049f			;		ld (debug_mark),a 
049f			;		pop af 
049f					CALLMONITOR 
049f cd aa fd			call debug_vector  
04a2				endm  
# End of macro CALLMONITOR
04a2				endif 
04a2 c9				ret	 
04a3				 
04a3			 
04a3			; File Size 
04a3			; --------- 
04a3			; 
04a3			;   hl file id 
04a3			; 
04a3			;  returns in hl the number of blocks 
04a3			 
04a3			storage_file_size: 
04a3 5d				ld e, l 
04a4 16 00			ld d, 0 
04a6 21 40 00			ld hl, STORE_BLOCK_PHY 
04a9					if DEBUG_FORTH_WORDS 
04a9						DMARK "SIZ" 
04a9 f5				push af  
04aa 3a be 04			ld a, (.dmark)  
04ad 32 9d fd			ld (debug_mark),a  
04b0 3a bf 04			ld a, (.dmark+1)  
04b3 32 9e fd			ld (debug_mark+1),a  
04b6 3a c0 04			ld a, (.dmark+2)  
04b9 32 9f fd			ld (debug_mark+2),a  
04bc 18 03			jr .pastdmark  
04be ..			.dmark: db "SIZ"  
04c1 f1			.pastdmark: pop af  
04c2			endm  
# End of macro DMARK
04c2						CALLMONITOR 
04c2 cd aa fd			call debug_vector  
04c5				endm  
# End of macro CALLMONITOR
04c5					endif 
04c5 cd a7 07			call storage_findnextid 
04c8			 
04c8 cd 07 10			call ishlzero 
04cb			;	ld a, l 
04cb			;	add h 
04cb			;	cp 0 
04cb c8				ret z			; block not found so EOF 
04cc			 
04cc 11 ac f9			ld de, store_page 
04cf cd 74 04			call storage_read_block 
04d2			 
04d2 3a ae f9			ld a, (store_page+2)	 ; get extent count 
04d5 6f				ld l, a 
04d6 26 00			ld h, 0 
04d8 c9			 	ret 
04d9			 
04d9			 
04d9			; Write Block 
04d9			; ----------- 
04d9			; 
04d9			; With current bank 
04d9			;  
04d9			; Get block number to write 
04d9			; Write physical blocks starting at start block from buffer 
04d9			  
04d9			storage_write_block: 
04d9				; TODO bank selection 
04d9			 
04d9				; for each of the physical blocks read it into the buffer 
04d9 06 40			ld b, STORE_BLOCK_PHY 
04db			 
04db				if DEBUG_STORESE 
04db					DMARK "SWB" 
04db f5				push af  
04dc 3a f0 04			ld a, (.dmark)  
04df 32 9d fd			ld (debug_mark),a  
04e2 3a f1 04			ld a, (.dmark+1)  
04e5 32 9e fd			ld (debug_mark+1),a  
04e8 3a f2 04			ld a, (.dmark+2)  
04eb 32 9f fd			ld (debug_mark+2),a  
04ee 18 03			jr .pastdmark  
04f0 ..			.dmark: db "SWB"  
04f3 f1			.pastdmark: pop af  
04f4			endm  
# End of macro DMARK
04f4			 
04f4					;push af 
04f4					;ld a, 'W' 
04f4					;ld (debug_mark),a 
04f4					;pop af 
04f4					CALLMONITOR 
04f4 cd aa fd			call debug_vector  
04f7				endm  
# End of macro CALLMONITOR
04f7				endif 
04f7			 
04f7			; might not be working 
04f7			;	call se_writepage 
04f7			 
04f7			;	ret 
04f7			; 
04f7			 
04f7			 
04f7			 
04f7			.wl1:    
04f7			 
04f7				; read physical block at hl into de 
04f7			        ; increment hl and de to next read position on exit 
04f7			 
04f7 e5				push hl 
04f8 d5				push de	 
04f9 c5				push bc 
04fa 1a				ld a,(de) 
04fb				;if DEBUG_STORESE 
04fb			;		push af 
04fb			;		ld a, 'W' 
04fb			;		ld (debug_mark),a 
04fb			;		pop af 
04fb			;		CALLMONITOR 
04fb			;	endif 
04fb cd 79 02			call se_writebyte 
04fe			;	call delay250ms 
04fe 00				nop 
04ff 00				nop 
0500 00				nop 
0501			;	if DEBUG_STORESE 
0501			;		push af 
0501			;		ld a, 'w' 
0501			;		ld (debug_mark),a 
0501			;		pop af 
0501			;		CALLMONITOR 
0501			;	endif 
0501 c1				pop bc 
0502 d1				pop de 
0503 e1				pop hl 
0504 23				inc hl 
0505 13				inc de 
0506			 
0506			 
0506 10 ef			djnz .wl1 
0508			 
0508				if DEBUG_STORESE 
0508					DMARK "SW2" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 9d fd			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 9e fd			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 9f fd			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "SW2"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521			 
0521					;push af 
0521					;ld a, 'W' 
0521					;ld (debug_mark),a 
0521					;pop af 
0521					CALLMONITOR 
0521 cd aa fd			call debug_vector  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 c9				ret	 
0525			 
0525			; Init bank 
0525			; --------- 
0525			; 
0525			; With current bank 
0525			; 
0525			; Setup block 0 config 
0525			;     Set 0 file id counter 
0525			;     Set formatted byte pattern 
0525			;     Zero out bank label 
0525			;      
0525			; For every logical block write 0-1 byte as null 
0525			 
0525			storage_get_block_0: 
0525			 
0525				; TODO check presence 
0525			 
0525				; get block 0 config 
0525			 
0525 21 00 00			ld hl, 0 
0528 11 ac f9			ld de, store_page 
052b cd 74 04			call storage_read_block 
052e			 
052e				if DEBUG_STORESE 
052e					DMARK "SB0" 
052e f5				push af  
052f 3a 43 05			ld a, (.dmark)  
0532 32 9d fd			ld (debug_mark),a  
0535 3a 44 05			ld a, (.dmark+1)  
0538 32 9e fd			ld (debug_mark+1),a  
053b 3a 45 05			ld a, (.dmark+2)  
053e 32 9f fd			ld (debug_mark+2),a  
0541 18 03			jr .pastdmark  
0543 ..			.dmark: db "SB0"  
0546 f1			.pastdmark: pop af  
0547			endm  
# End of macro DMARK
0547 11 ac f9				ld de, store_page 
054a			;		push af 
054a			;		ld a, 'i' 
054a			;		ld (debug_mark),a 
054a			;		pop af 
054a					CALLMONITOR 
054a cd aa fd			call debug_vector  
054d				endm  
# End of macro CALLMONITOR
054d				endif 
054d			 
054d				; is this area formatted? 
054d			 
054d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
054d 2a ad f9			ld hl, (store_page+1) 
0550 3e 80			ld a,0x80 
0552 bd				cp l 
0553 20 22			jr nz, .ininotformatted 
0555				; do a double check 
0555 3e 27			ld a, 0x27 
0557 bc				cp h 
0558 20 1d			jr nz, .ininotformatted 
055a			 
055a				; formatted then 
055a			 
055a				if DEBUG_STORESE 
055a					DMARK "SB1" 
055a f5				push af  
055b 3a 6f 05			ld a, (.dmark)  
055e 32 9d fd			ld (debug_mark),a  
0561 3a 70 05			ld a, (.dmark+1)  
0564 32 9e fd			ld (debug_mark+1),a  
0567 3a 71 05			ld a, (.dmark+2)  
056a 32 9f fd			ld (debug_mark+2),a  
056d 18 03			jr .pastdmark  
056f ..			.dmark: db "SB1"  
0572 f1			.pastdmark: pop af  
0573			endm  
# End of macro DMARK
0573					;push af 
0573					;ld a, 'I' 
0573					;ld (debug_mark),a 
0573					;pop af 
0573					CALLMONITOR 
0573 cd aa fd			call debug_vector  
0576				endm  
# End of macro CALLMONITOR
0576				endif 
0576 c9				ret 
0577			 
0577			.ininotformatted: 
0577				; bank not formatted so poke various bits to make sure 
0577			 
0577				if DEBUG_STORESE 
0577					DMARK "SB2" 
0577 f5				push af  
0578 3a 8c 05			ld a, (.dmark)  
057b 32 9d fd			ld (debug_mark),a  
057e 3a 8d 05			ld a, (.dmark+1)  
0581 32 9e fd			ld (debug_mark+1),a  
0584 3a 8e 05			ld a, (.dmark+2)  
0587 32 9f fd			ld (debug_mark+2),a  
058a 18 03			jr .pastdmark  
058c ..			.dmark: db "SB2"  
058f f1			.pastdmark: pop af  
0590			endm  
# End of macro DMARK
0590					;push af 
0590					;ld a, 'f' 
0590					;ld (debug_mark),a 
0590					;pop af 
0590					CALLMONITOR 
0590 cd aa fd			call debug_vector  
0593				endm  
# End of macro CALLMONITOR
0593				endif 
0593			 
0593 cd b0 0c			call storage_clear_page 
0596			 
0596 21 ac f9			ld hl, store_page 
0599 3e 00			ld a, 0 
059b				 
059b 77				ld (hl),a   ; reset file counter 
059c			 
059c 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
059f 22 ad f9		 	ld (store_page+1), hl	 
05a2			 
05a2				; set default label 
05a2			 
05a2 21 3e 06			ld hl, .defaultbanklabl 
05a5 11 af f9		 	ld de, store_page+3 
05a8 01 0f 00			ld bc, 15 
05ab ed b0			ldir 
05ad			 
05ad				; Append the current bank id 
05ad 21 b8 f9			ld hl, store_page+3+9 
05b0 3a 91 f9			ld a, (spi_device_id) 
05b3 77				ld (hl), a 
05b4			 
05b4				; save default page 0 
05b4			 
05b4 21 00 00			ld hl, 0 
05b7 11 ac f9			ld de, store_page 
05ba				if DEBUG_STORESE 
05ba					DMARK "SB3" 
05ba f5				push af  
05bb 3a cf 05			ld a, (.dmark)  
05be 32 9d fd			ld (debug_mark),a  
05c1 3a d0 05			ld a, (.dmark+1)  
05c4 32 9e fd			ld (debug_mark+1),a  
05c7 3a d1 05			ld a, (.dmark+2)  
05ca 32 9f fd			ld (debug_mark+2),a  
05cd 18 03			jr .pastdmark  
05cf ..			.dmark: db "SB3"  
05d2 f1			.pastdmark: pop af  
05d3			endm  
# End of macro DMARK
05d3			;		push af 
05d3			;		ld a, 'F' 
05d3			;		ld (debug_mark),a 
05d3			;		pop af 
05d3					CALLMONITOR 
05d3 cd aa fd			call debug_vector  
05d6				endm  
# End of macro CALLMONITOR
05d6				endif 
05d6 cd d9 04			call storage_write_block 
05d9				if DEBUG_STORESE 
05d9					DMARK "SB4" 
05d9 f5				push af  
05da 3a ee 05			ld a, (.dmark)  
05dd 32 9d fd			ld (debug_mark),a  
05e0 3a ef 05			ld a, (.dmark+1)  
05e3 32 9e fd			ld (debug_mark+1),a  
05e6 3a f0 05			ld a, (.dmark+2)  
05e9 32 9f fd			ld (debug_mark+2),a  
05ec 18 03			jr .pastdmark  
05ee ..			.dmark: db "SB4"  
05f1 f1			.pastdmark: pop af  
05f2			endm  
# End of macro DMARK
05f2			;		push af 
05f2			;		ld a, '>' 
05f2			;		ld (debug_mark),a 
05f2			;		pop af 
05f2					CALLMONITOR 
05f2 cd aa fd			call debug_vector  
05f5				endm  
# End of macro CALLMONITOR
05f5				endif 
05f5			 
05f5 00				nop 
05f6 00				nop 
05f7 00				nop 
05f8			 
05f8				; now set 0 in every page to mark as a free block 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 21 40 00			ld hl, STORE_BLOCK_PHY 
05fd			 
05fd 3e 00		.setmark1:   	ld a,0 
05ff e5					push hl 
0600 c5					push bc 
0601 cd 79 02				call se_writebyte 
0604 3e 0a			ld a, 10 
0606 cd d2 0c			call aDelayInMS 
0609 23				inc hl 
060a cd 79 02				call se_writebyte 
060d 3e 0a			ld a, 10 
060f cd d2 0c			call aDelayInMS 
0612 2b				dec hl 
0613 c1					pop bc 
0614 e1					pop hl 
0615 3e 40				ld a, STORE_BLOCK_PHY 
0617 cd de 0f				call addatohl 
061a 10 e1				djnz .setmark1 
061c			 
061c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
061e 3e 00		.setmark2:   	ld a,0 
0620 e5					push hl 
0621 c5					push bc 
0622 cd 79 02				call se_writebyte 
0625 3e 0a			ld a, 10 
0627 cd d2 0c			call aDelayInMS 
062a 23				inc hl 
062b cd 79 02				call se_writebyte 
062e 3e 0a			ld a, 10 
0630 cd d2 0c			call aDelayInMS 
0633 2b				dec hl 
0634 c1					pop bc 
0635 e1					pop hl 
0636 3e 40				ld a, STORE_BLOCK_PHY 
0638 cd de 0f				call addatohl 
063b 10 e1				djnz .setmark2 
063d			 
063d					 
063d			 
063d			 
063d c9				ret 
063e			 
063e			 
063e			 
063e			 
063e .. 00		.defaultbanklabl:   db "BankLabel_",0 
0649			 
0649			 
0649			 
0649			; Label Bank 
0649			; ---------- 
0649			; 
0649			; With current bank 
0649			; Read block 0 
0649			; Set label 
0649			; Write block 0 
0649			 
0649			; label str pointer in hl 
0649			 
0649			storage_label:     
0649			 
0649				if DEBUG_STORESE 
0649					DMARK "LBL" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 9d fd			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 9e fd			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 9f fd			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "LBL"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662					CALLMONITOR 
0662 cd aa fd			call debug_vector  
0665				endm  
# End of macro CALLMONITOR
0665				endif 
0665			 
0665 e5				push hl 
0666			 
0666 cd 25 05			call storage_get_block_0 
0669			 
0669				; set default label 
0669			 
0669 e1				pop hl 
066a			 
066a 11 af f9		 	ld de, store_page+3 
066d 01 0f 00			ld bc, 15 
0670				if DEBUG_STORESE 
0670					DMARK "LB3" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 9d fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 9e fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 9f fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LB3"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd aa fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c ed b0			ldir 
068e				; save default page 0 
068e			 
068e 21 00 00			ld hl, 0 
0691 11 ac f9			ld de, store_page 
0694				if DEBUG_STORESE 
0694					DMARK "LBW" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 9d fd			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 9e fd			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 9f fd			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "LBW"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad					CALLMONITOR 
06ad cd aa fd			call debug_vector  
06b0				endm  
# End of macro CALLMONITOR
06b0				endif 
06b0 cd d9 04			call storage_write_block 
06b3			 
06b3 c9				ret 
06b4			 
06b4			 
06b4			 
06b4			; Read Block 0 - Config 
06b4			; --------------------- 
06b4			; 
06b4			; With current bank 
06b4			; Call presence test 
06b4			;    If not present format/init bank  
06b4			; Read block 0  
06b4			;  
06b4			 
06b4			 
06b4			; Dir 
06b4			; --- 
06b4			; 
06b4			; With current bank 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block read byte 2 
06b4			;      if first block of file 
06b4			;         Display file name 
06b4			;         Display type flags for file 
06b4			;        
06b4			 
06b4			; moving to words as this requires stack control 
06b4			 
06b4			 
06b4			; Delete File 
06b4			; ----------- 
06b4			; 
06b4			; With current bank 
06b4			; 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block file id 
06b4			;      If first block of file and dont have file id 
06b4			;         if file to delete 
06b4			;         Save file id 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			;      If file id is one saved 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			 
06b4			 
06b4			.se_done: 
06b4 e1				pop hl 
06b5 c9				ret 
06b6			 
06b6			storage_erase: 
06b6			 
06b6				; hl contains the file id 
06b6			 
06b6 5d				ld e, l 
06b7 16 00			ld d, 0 
06b9 21 40 00			ld hl, STORE_BLOCK_PHY 
06bc					if DEBUG_FORTH_WORDS 
06bc						DMARK "ERA" 
06bc f5				push af  
06bd 3a d1 06			ld a, (.dmark)  
06c0 32 9d fd			ld (debug_mark),a  
06c3 3a d2 06			ld a, (.dmark+1)  
06c6 32 9e fd			ld (debug_mark+1),a  
06c9 3a d3 06			ld a, (.dmark+2)  
06cc 32 9f fd			ld (debug_mark+2),a  
06cf 18 03			jr .pastdmark  
06d1 ..			.dmark: db "ERA"  
06d4 f1			.pastdmark: pop af  
06d5			endm  
# End of macro DMARK
06d5						CALLMONITOR 
06d5 cd aa fd			call debug_vector  
06d8				endm  
# End of macro CALLMONITOR
06d8					endif 
06d8 cd a7 07			call storage_findnextid 
06db cd 07 10			call ishlzero 
06de c8				ret z 
06df			 
06df e5				push hl 
06e0			 
06e0				; TODO check file not found 
06e0			 
06e0 11 ac f9			ld de, store_page 
06e3 cd 74 04			call storage_read_block 
06e6			 
06e6 cd 07 10			call ishlzero 
06e9 ca b4 06			jp z,.se_done 
06ec			 
06ec					if DEBUG_FORTH_WORDS 
06ec						DMARK "ER1" 
06ec f5				push af  
06ed 3a 01 07			ld a, (.dmark)  
06f0 32 9d fd			ld (debug_mark),a  
06f3 3a 02 07			ld a, (.dmark+1)  
06f6 32 9e fd			ld (debug_mark+1),a  
06f9 3a 03 07			ld a, (.dmark+2)  
06fc 32 9f fd			ld (debug_mark+2),a  
06ff 18 03			jr .pastdmark  
0701 ..			.dmark: db "ER1"  
0704 f1			.pastdmark: pop af  
0705			endm  
# End of macro DMARK
0705						CALLMONITOR 
0705 cd aa fd			call debug_vector  
0708				endm  
# End of macro CALLMONITOR
0708					endif 
0708 3a ac f9			ld a, (store_page)	; get file id 
070b 32 a0 f9			ld (store_tmpid), a 
070e			 
070e 3a ae f9			ld a, (store_page+2)    ; get count of extends 
0711 32 9f f9			ld (store_tmpext), a 
0714			 
0714				; wipe file header 
0714			 
0714 e1				pop hl 
0715 3e 00			ld a, 0 
0717 32 ac f9			ld (store_page), a 
071a 32 ad f9			ld (store_page+1),a 
071d 11 ac f9			ld de, store_page 
0720					if DEBUG_FORTH_WORDS 
0720						DMARK "ER2" 
0720 f5				push af  
0721 3a 35 07			ld a, (.dmark)  
0724 32 9d fd			ld (debug_mark),a  
0727 3a 36 07			ld a, (.dmark+1)  
072a 32 9e fd			ld (debug_mark+1),a  
072d 3a 37 07			ld a, (.dmark+2)  
0730 32 9f fd			ld (debug_mark+2),a  
0733 18 03			jr .pastdmark  
0735 ..			.dmark: db "ER2"  
0738 f1			.pastdmark: pop af  
0739			endm  
# End of macro DMARK
0739						CALLMONITOR 
0739 cd aa fd			call debug_vector  
073c				endm  
# End of macro CALLMONITOR
073c					endif 
073c cd d9 04			call storage_write_block 
073f			 
073f			 
073f				; wipe file extents 
073f			 
073f 3a 9f f9			ld a, (store_tmpext) 
0742 47				ld b, a 
0743			 
0743			.eraext:	  
0743 c5				push bc 
0744			 
0744 21 40 00			ld hl, STORE_BLOCK_PHY 
0747 3a a0 f9			ld a,(store_tmpid) 
074a 5f				ld e, a 
074b 50				ld d, b	 
074c					if DEBUG_FORTH_WORDS 
074c						DMARK "ER3" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 9d fd			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 9e fd			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 9f fd			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "ER3"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765						CALLMONITOR 
0765 cd aa fd			call debug_vector  
0768				endm  
# End of macro CALLMONITOR
0768					endif 
0768 cd a7 07			call storage_findnextid 
076b cd 07 10			call ishlzero 
076e ca b4 06			jp z,.se_done 
0771			 
0771 e5				push hl 
0772 11 ac f9			ld de, store_page 
0775 cd 74 04			call storage_read_block 
0778			 
0778				; free block	 
0778			 
0778 3e 00			ld a, 0 
077a 32 ac f9			ld (store_page), a 
077d 32 ad f9			ld (store_page+1),a 
0780 11 ac f9			ld de, store_page 
0783 e1				pop hl 
0784					if DEBUG_FORTH_WORDS 
0784						DMARK "ER4" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 9d fd			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 9e fd			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 9f fd			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "ER4"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d						CALLMONITOR 
079d cd aa fd			call debug_vector  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 cd d9 04			call storage_write_block 
07a3			 
07a3 c1				pop bc 
07a4 10 9d			djnz .eraext 
07a6			 
07a6 c9				ret 
07a7			 
07a7			 
07a7			; Find Free Block 
07a7			; --------------- 
07a7			; 
07a7			; With current bank 
07a7			;  
07a7			; From given starting logical block 
07a7			;    Read block  
07a7			;    If no file id 
07a7			;         Return block id 
07a7			 
07a7			 
07a7			; hl starting page number 
07a7			; hl contains free page number or zero if no pages free 
07a7			; e contains the file id to locate 
07a7			; d contains the block number 
07a7			 
07a7			; TODO change to find file id and use zero for free block 
07a7			 
07a7			storage_findnextid: 
07a7			 
07a7				; now locate first 0 page to mark as a free block 
07a7			 
07a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a9			;	ld hl, STORE_BLOCK_PHY 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FNI" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 9d fd			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 9e fd			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 9f fd			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FNI"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2						CALLMONITOR 
07c2 cd aa fd			call debug_vector  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5			.ff1:   	 
07c5 e5					push hl 
07c6 c5					push bc 
07c7 d5					push de 
07c8 cd 1b 03				call se_readbyte 
07cb 5f					ld e,a 
07cc 23					inc hl 
07cd cd 1b 03				call se_readbyte 
07d0 57					ld d, a 
07d1 e1					pop hl 
07d2 e5					push hl 
07d3 cd fc 0f				call cmp16 
07d6 28 49				jr z, .fffound 
07d8			 
07d8 d1					pop de 
07d9 c1					pop bc 
07da e1					pop hl 
07db			 
07db					; is found? 
07db					;cp e 
07db					;ret z 
07db			 
07db 3e 40				ld a, STORE_BLOCK_PHY 
07dd cd de 0f				call addatohl 
07e0 10 e3				djnz .ff1 
07e2			 
07e2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e4			.ff2:   	 
07e4			 
07e4 e5					push hl 
07e5 c5					push bc 
07e6 d5					push de 
07e7 cd 1b 03				call se_readbyte 
07ea 5f					ld e,a 
07eb 23					inc hl 
07ec cd 1b 03				call se_readbyte 
07ef 57					ld d, a 
07f0			 
07f0 e1					pop hl 
07f1 e5					push hl 
07f2 cd fc 0f				call cmp16 
07f5 28 2a				jr z, .fffound 
07f7			 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa					; is found? 
07fa					;cp e 
07fa					;ret z 
07fa			 
07fa 3e 40				ld a, STORE_BLOCK_PHY 
07fc cd de 0f				call addatohl 
07ff 10 e3				djnz .ff2 
0801			 
0801			 
0801					if DEBUG_FORTH_WORDS 
0801					DMARK "FN-" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 9d fd			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 9e fd			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 9f fd			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "FN-"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;	push af 
081a					;	ld a, 'n' 
081a					;	ld (debug_mark),a 
081a					;	pop af 
081a						CALLMONITOR 
081a cd aa fd			call debug_vector  
081d				endm  
# End of macro CALLMONITOR
081d					endif 
081d				; no free marks! 
081d 21 00 00				ld hl, 0 
0820 c9				ret 
0821			.fffound: 
0821				 
0821			 
0821 d1					pop de 
0822 c1					pop bc 
0823 e1					pop hl 
0824					if DEBUG_FORTH_WORDS 
0824					DMARK "FNF" 
0824 f5				push af  
0825 3a 39 08			ld a, (.dmark)  
0828 32 9d fd			ld (debug_mark),a  
082b 3a 3a 08			ld a, (.dmark+1)  
082e 32 9e fd			ld (debug_mark+1),a  
0831 3a 3b 08			ld a, (.dmark+2)  
0834 32 9f fd			ld (debug_mark+2),a  
0837 18 03			jr .pastdmark  
0839 ..			.dmark: db "FNF"  
083c f1			.pastdmark: pop af  
083d			endm  
# End of macro DMARK
083d					;	push af 
083d					;	ld a, 'n' 
083d					;	ld (debug_mark),a 
083d					;	pop af 
083d						CALLMONITOR 
083d cd aa fd			call debug_vector  
0840				endm  
# End of macro CALLMONITOR
0840					endif 
0840 c9				ret 
0841			 
0841			 
0841			 
0841			; Free Space 
0841			; ---------- 
0841			; 
0841			; With current bank 
0841			; 
0841			; Set block count to zero 
0841			; Starting with first logical block 
0841			;      Find free block  
0841			;      If block id given, increment block count 
0841			; 
0841			;  
0841			 
0841			 
0841			; hl contains count of free blocks 
0841			 
0841			storage_freeblocks: 
0841			 
0841				; now locate first 0 page to mark as a free block 
0841			 
0841 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0843 21 40 00			ld hl, STORE_BLOCK_PHY 
0846 11 00 00			ld de, 0 
0849			 
0849			.fb1:   	 
0849 e5					push hl 
084a c5					push bc 
084b d5					push de 
084c cd 1b 03				call se_readbyte 
084f d1					pop de 
0850 c1					pop bc 
0851 e1					pop hl 
0852			 
0852					; is free? 
0852 fe 00				cp 0 
0854 20 01				jr nz, .ff1cont 
0856 13					inc de 
0857			 
0857			.ff1cont: 
0857			 
0857			 
0857 3e 40				ld a, STORE_BLOCK_PHY 
0859 cd de 0f				call addatohl 
085c 10 eb				djnz .fb1 
085e			 
085e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0860			.fb2:   	 
0860 e5					push hl 
0861 c5					push bc 
0862 d5					push de 
0863 cd 1b 03				call se_readbyte 
0866 d1					pop de 
0867 c1					pop bc 
0868 e1					pop hl 
0869			 
0869					; is free? 
0869 fe 00				cp 0 
086b 20 01				jr nz, .ff2cont 
086d 13					inc de 
086e			 
086e			.ff2cont: 
086e			 
086e 3e 40				ld a, STORE_BLOCK_PHY 
0870 cd de 0f				call addatohl 
0873 10 eb				djnz .fb2 
0875			 
0875 eb				ex de, hl 
0876 c9				ret 
0877			 
0877			; Get File ID 
0877			; ----------- 
0877			; 
0877			; With current bank 
0877			;  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; For each logical block 
0877			;    Read block file id 
0877			;      If first block of file and dont have file id 
0877			;         if file get id and exit 
0877			 
0877			 
0877			 
0877			 
0877			; Create File 
0877			; ----------- 
0877			; 
0877			; With current bank  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; Increment file id number 
0877			; Save Config 
0877			; Find free block 
0877			; Set buffer with file name and file id 
0877			; Write buffer to free block  
0877			 
0877			 
0877			; hl point to file name 
0877			; hl returns file id 
0877			 
0877			; file format: 
0877			; byte 0 - file id 
0877			; byte 1 - extent number 
0877			; byte 2-> data 
0877			 
0877			; format for extent number 0: 
0877			; 
0877			; byte 0 - file id 
0877			; byte 1 - extent 0 
0877			; byte 2 - extent count 
0877			; byte 3 -> file name and meta data 
0877			 
0877			 
0877			storage_create: 
0877				if DEBUG_STORESE 
0877					DMARK "SCR" 
0877 f5				push af  
0878 3a 8c 08			ld a, (.dmark)  
087b 32 9d fd			ld (debug_mark),a  
087e 3a 8d 08			ld a, (.dmark+1)  
0881 32 9e fd			ld (debug_mark+1),a  
0884 3a 8e 08			ld a, (.dmark+2)  
0887 32 9f fd			ld (debug_mark+2),a  
088a 18 03			jr .pastdmark  
088c ..			.dmark: db "SCR"  
088f f1			.pastdmark: pop af  
0890			endm  
# End of macro DMARK
0890					CALLMONITOR 
0890 cd aa fd			call debug_vector  
0893				endm  
# End of macro CALLMONITOR
0893				endif 
0893			 
0893 e5				push hl		; save file name pointer 
0894			 
0894 cd 25 05			call storage_get_block_0 
0897			 
0897 3a ac f9			ld a,(store_page)	; get current file id 
089a 3c				inc a 
089b 32 ac f9			ld (store_page),a 
089e				 
089e 32 a0 f9			ld (store_tmpid),a			; save id 
08a1			 
08a1 21 00 00			ld hl, 0 
08a4 11 ac f9			ld de, store_page 
08a7				if DEBUG_STORESE 
08a7					DMARK "SCw" 
08a7 f5				push af  
08a8 3a bc 08			ld a, (.dmark)  
08ab 32 9d fd			ld (debug_mark),a  
08ae 3a bd 08			ld a, (.dmark+1)  
08b1 32 9e fd			ld (debug_mark+1),a  
08b4 3a be 08			ld a, (.dmark+2)  
08b7 32 9f fd			ld (debug_mark+2),a  
08ba 18 03			jr .pastdmark  
08bc ..			.dmark: db "SCw"  
08bf f1			.pastdmark: pop af  
08c0			endm  
# End of macro DMARK
08c0					CALLMONITOR 
08c0 cd aa fd			call debug_vector  
08c3				endm  
# End of macro CALLMONITOR
08c3				endif 
08c3 cd d9 04			call storage_write_block	 ; save update 
08c6			 
08c6				if DEBUG_STORESE 
08c6 11 ac f9				ld de, store_page 
08c9					DMARK "SCC" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 9d fd			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 9e fd			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 9f fd			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCC"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd aa fd			call debug_vector  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5				;  
08e5				 
08e5 21 40 00			ld hl, STORE_BLOCK_PHY 
08e8 11 00 00			ld de, 0 
08eb cd a7 07			call storage_findnextid 
08ee			 
08ee 22 97 f9			ld (store_tmppageid), hl    ; save page to use  
08f1			 
08f1				; TODO detect 0 = no spare blocks 
08f1			 
08f1				; hl now contains the free page to use for the file header page 
08f1			 
08f1				if DEBUG_STORESE 
08f1				DMARK "SCF" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 9d fd			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 9e fd			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 9f fd			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCF"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					CALLMONITOR 
090a cd aa fd			call debug_vector  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d			 
090d 22 97 f9			ld (store_tmppageid), hl 
0910				 
0910 3a a0 f9			ld a,(store_tmpid)    ; get file id 
0913			;	ld a, (store_filecache)			; save to cache 
0913			 
0913 32 ac f9			ld (store_page),a    ; set page id 
0916 3e 00			ld a, 0			 ; extent 0 is file header 
0918 32 ad f9			ld (store_page+1), a   ; set file extent 
091b			 
091b 32 ae f9			ld (store_page+2), a   ; extent count for the file 
091e			 
091e			;	inc hl 		; init block 0 of file 
091e			;	inc hl   		; skip file and extent id 
091e			 ;       ld a, 0 
091e			;	ld (hl),a 
091e			;	ld a, (store_filecache+1)  	; save to cache 
091e			 
091e			;	inc hl    ; file name 
091e				 
091e				 
091e 11 af f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0921				if DEBUG_STORESE 
0921					DMARK "SCc" 
0921 f5				push af  
0922 3a 36 09			ld a, (.dmark)  
0925 32 9d fd			ld (debug_mark),a  
0928 3a 37 09			ld a, (.dmark+1)  
092b 32 9e fd			ld (debug_mark+1),a  
092e 3a 38 09			ld a, (.dmark+2)  
0931 32 9f fd			ld (debug_mark+2),a  
0934 18 03			jr .pastdmark  
0936 ..			.dmark: db "SCc"  
0939 f1			.pastdmark: pop af  
093a			endm  
# End of macro DMARK
093a					CALLMONITOR 
093a cd aa fd			call debug_vector  
093d				endm  
# End of macro CALLMONITOR
093d				endif 
093d e1				pop hl    ; get zero term string 
093e e5				push hl 
093f 3e 00			ld a, 0 
0941 cd 4f 13			call strlent 
0944 23				inc hl   ; cover zero term 
0945 06 00			ld b,0 
0947 4d				ld c,l 
0948 e1				pop hl 
0949				;ex de, hl 
0949				if DEBUG_STORESE 
0949					DMARK "SCa" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 9d fd			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 9e fd			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 9f fd			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SCa"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					;push af 
0962					;ld a, 'a' 
0962					;ld (debug_mark),a 
0962					;pop af 
0962					CALLMONITOR 
0962 cd aa fd			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 ed b0			ldir    ; copy zero term string 
0967				if DEBUG_STORESE 
0967					DMARK "SCA" 
0967 f5				push af  
0968 3a 7c 09			ld a, (.dmark)  
096b 32 9d fd			ld (debug_mark),a  
096e 3a 7d 09			ld a, (.dmark+1)  
0971 32 9e fd			ld (debug_mark+1),a  
0974 3a 7e 09			ld a, (.dmark+2)  
0977 32 9f fd			ld (debug_mark+2),a  
097a 18 03			jr .pastdmark  
097c ..			.dmark: db "SCA"  
097f f1			.pastdmark: pop af  
0980			endm  
# End of macro DMARK
0980					CALLMONITOR 
0980 cd aa fd			call debug_vector  
0983				endm  
# End of macro CALLMONITOR
0983				endif 
0983			 
0983				; write file header page 
0983			 
0983 2a 97 f9			ld hl,(store_tmppageid) 
0986 11 ac f9			ld de, store_page 
0989				if DEBUG_STORESE 
0989					DMARK "SCb" 
0989 f5				push af  
098a 3a 9e 09			ld a, (.dmark)  
098d 32 9d fd			ld (debug_mark),a  
0990 3a 9f 09			ld a, (.dmark+1)  
0993 32 9e fd			ld (debug_mark+1),a  
0996 3a a0 09			ld a, (.dmark+2)  
0999 32 9f fd			ld (debug_mark+2),a  
099c 18 03			jr .pastdmark  
099e ..			.dmark: db "SCb"  
09a1 f1			.pastdmark: pop af  
09a2			endm  
# End of macro DMARK
09a2					;push af 
09a2					;ld a, 'b' 
09a2					;ld (debug_mark),a 
09a2					;pop af 
09a2					CALLMONITOR 
09a2 cd aa fd			call debug_vector  
09a5				endm  
# End of macro CALLMONITOR
09a5				endif 
09a5 cd d9 04			call storage_write_block 
09a8			 
09a8 3a a0 f9			ld a, (store_tmpid) 
09ab 6f				ld l, a 
09ac 26 00			ld h,0 
09ae				if DEBUG_STORESE 
09ae					DMARK "SCz" 
09ae f5				push af  
09af 3a c3 09			ld a, (.dmark)  
09b2 32 9d fd			ld (debug_mark),a  
09b5 3a c4 09			ld a, (.dmark+1)  
09b8 32 9e fd			ld (debug_mark+1),a  
09bb 3a c5 09			ld a, (.dmark+2)  
09be 32 9f fd			ld (debug_mark+2),a  
09c1 18 03			jr .pastdmark  
09c3 ..			.dmark: db "SCz"  
09c6 f1			.pastdmark: pop af  
09c7			endm  
# End of macro DMARK
09c7					CALLMONITOR 
09c7 cd aa fd			call debug_vector  
09ca				endm  
# End of macro CALLMONITOR
09ca				endif 
09ca c9				ret 
09cb				 
09cb			 
09cb			 
09cb			; 
09cb			; Read File 
09cb			; 
09cb			; h - file id to locate 
09cb			; l - extent to locate 
09cb			; de - pointer to string to read into 
09cb			; 
09cb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09cb			 
09cb			.sr_fail: 
09cb d1				pop de 
09cc c9				ret 
09cd			 
09cd			storage_read: 
09cd			 
09cd			 
09cd d5				push de 
09ce			 
09ce			; TODO BUG the above push is it popped before the RET Z? 
09ce			 
09ce			; TODO how to handle multiple part blocks 
09ce			 
09ce				; locate file extent to read 
09ce			 
09ce 5c				ld e, h 
09cf 55				ld d, l 
09d0			 
09d0			.srext: 
09d0 22 aa f9			ld (store_readptr), hl     ; save the current extent to load 
09d3 ed 53 a8 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09d7			 
09d7 21 40 00			ld hl, STORE_BLOCK_PHY 
09da				if DEBUG_STORESE 
09da					DMARK "sre" 
09da f5				push af  
09db 3a ef 09			ld a, (.dmark)  
09de 32 9d fd			ld (debug_mark),a  
09e1 3a f0 09			ld a, (.dmark+1)  
09e4 32 9e fd			ld (debug_mark+1),a  
09e7 3a f1 09			ld a, (.dmark+2)  
09ea 32 9f fd			ld (debug_mark+2),a  
09ed 18 03			jr .pastdmark  
09ef ..			.dmark: db "sre"  
09f2 f1			.pastdmark: pop af  
09f3			endm  
# End of macro DMARK
09f3					CALLMONITOR 
09f3 cd aa fd			call debug_vector  
09f6				endm  
# End of macro CALLMONITOR
09f6				endif 
09f6 cd a7 07			call storage_findnextid 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srf" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 9d fd			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 9e fd			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 9f fd			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srf"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd aa fd			call debug_vector  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15 cd 07 10			call ishlzero 
0a18			;	ld a, l 
0a18			;	add h 
0a18			;	cp 0 
0a18 28 b1			jr z,.sr_fail			; block not found so EOF 
0a1a			 
0a1a				; save current address for use by higher level words etc 
0a1a			 
0a1a 22 9d f9			ld (store_openaddr),hl 
0a1d			 
0a1d			 
0a1d				; hl contains page number to load 
0a1d d1				pop de   ; get storage 
0a1e ed 53 a8 f9		ld (store_readbuf), de     ; current buffer to load in to 
0a22 d5				push de 
0a23				if DEBUG_STORESE 
0a23					DMARK "srg" 
0a23 f5				push af  
0a24 3a 38 0a			ld a, (.dmark)  
0a27 32 9d fd			ld (debug_mark),a  
0a2a 3a 39 0a			ld a, (.dmark+1)  
0a2d 32 9e fd			ld (debug_mark+1),a  
0a30 3a 3a 0a			ld a, (.dmark+2)  
0a33 32 9f fd			ld (debug_mark+2),a  
0a36 18 03			jr .pastdmark  
0a38 ..			.dmark: db "srg"  
0a3b f1			.pastdmark: pop af  
0a3c			endm  
# End of macro DMARK
0a3c					CALLMONITOR 
0a3c cd aa fd			call debug_vector  
0a3f				endm  
# End of macro CALLMONITOR
0a3f				endif 
0a3f cd 74 04			call storage_read_block 
0a42			 
0a42				; if this a continuation read??? 
0a42			 
0a42 2a a8 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a45			 
0a45 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a47 cd de 0f			call addatohl 
0a4a 7e				ld a,(hl) 
0a4b fe 00			cp 0 
0a4d 28 02			jr z, .markiscont 
0a4f 3e ff			ld a, 255 
0a51			 
0a51			.markiscont: 
0a51 32 9f f9			ld (store_readcont), a 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "srC" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 9d fd			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 9e fd			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 9f fd			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "srC"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd aa fd			call debug_vector  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70				; only short reads enabled 
0a70			 
0a70 3a a7 f9			ld a, (store_longread) 
0a73 fe 00			cp 0 
0a75 ca 42 0b			jp z, .readdone 
0a78			 
0a78			; TODO if block has no zeros then need to read next block  
0a78			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a78			; check last byte of physical block. 
0a78			; if not zero then the next block needs to be loaded 
0a78			 
0a78			 
0a78 2a a8 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a7b			 
0a7b 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a7d cd de 0f			call addatohl 
0a80				;dec hl 
0a80 7e				ld a,(hl) 
0a81				if DEBUG_STORESE 
0a81					DMARK "sr?" 
0a81 f5				push af  
0a82 3a 96 0a			ld a, (.dmark)  
0a85 32 9d fd			ld (debug_mark),a  
0a88 3a 97 0a			ld a, (.dmark+1)  
0a8b 32 9e fd			ld (debug_mark+1),a  
0a8e 3a 98 0a			ld a, (.dmark+2)  
0a91 32 9f fd			ld (debug_mark+2),a  
0a94 18 03			jr .pastdmark  
0a96 ..			.dmark: db "sr?"  
0a99 f1			.pastdmark: pop af  
0a9a			endm  
# End of macro DMARK
0a9a					CALLMONITOR 
0a9a cd aa fd			call debug_vector  
0a9d				endm  
# End of macro CALLMONITOR
0a9d				endif 
0a9d fe 00			cp 0 
0a9f ca 42 0b			jp z, .readdone 
0aa2			 
0aa2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0aa2			 
0aa2 23				inc hl 
0aa3			 
0aa3 22 a8 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0aa6			 
0aa6 ed 5b aa f9		ld de, (store_readptr)     ; save the current extent to load 
0aaa			 
0aaa eb				ex de, hl 
0aab			 
0aab				; next ext 
0aab			 
0aab 23				inc hl 
0aac 22 aa f9			ld  (store_readptr), hl     ; save the current extent to load 
0aaf			 
0aaf				if DEBUG_STORESE 
0aaf					DMARK "sF2" 
0aaf f5				push af  
0ab0 3a c4 0a			ld a, (.dmark)  
0ab3 32 9d fd			ld (debug_mark),a  
0ab6 3a c5 0a			ld a, (.dmark+1)  
0ab9 32 9e fd			ld (debug_mark+1),a  
0abc 3a c6 0a			ld a, (.dmark+2)  
0abf 32 9f fd			ld (debug_mark+2),a  
0ac2 18 03			jr .pastdmark  
0ac4 ..			.dmark: db "sF2"  
0ac7 f1			.pastdmark: pop af  
0ac8			endm  
# End of macro DMARK
0ac8					CALLMONITOR 
0ac8 cd aa fd			call debug_vector  
0acb				endm  
# End of macro CALLMONITOR
0acb				endif 
0acb			 
0acb				; get and load block 
0acb			 
0acb cd a7 07			call storage_findnextid 
0ace			 
0ace				if DEBUG_STORESE 
0ace					DMARK "sf2" 
0ace f5				push af  
0acf 3a e3 0a			ld a, (.dmark)  
0ad2 32 9d fd			ld (debug_mark),a  
0ad5 3a e4 0a			ld a, (.dmark+1)  
0ad8 32 9e fd			ld (debug_mark+1),a  
0adb 3a e5 0a			ld a, (.dmark+2)  
0ade 32 9f fd			ld (debug_mark+2),a  
0ae1 18 03			jr .pastdmark  
0ae3 ..			.dmark: db "sf2"  
0ae6 f1			.pastdmark: pop af  
0ae7			endm  
# End of macro DMARK
0ae7					CALLMONITOR 
0ae7 cd aa fd			call debug_vector  
0aea				endm  
# End of macro CALLMONITOR
0aea				endif 
0aea cd 07 10			call ishlzero 
0aed			;	ld a, l 
0aed			;	add h 
0aed			;	cp 0 
0aed ca cb 09			jp z,.sr_fail			; block not found so EOF 
0af0				 
0af0				; save current address for use by higher level words etc 
0af0			 
0af0 22 9d f9			ld (store_openaddr),hl 
0af3			 
0af3 cd 74 04			call storage_read_block 
0af6			 
0af6				; on a continuation block, we now have the file id and ext in the middle of the block 
0af6				; we need to pull everything back  
0af6			 
0af6 ed 5b a8 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0afa 2a a8 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0afd 23				inc hl 
0afe 23				inc hl     ; skip id and ext 
0aff 01 40 00			ld bc, STORE_BLOCK_PHY 
0b02				if DEBUG_STORESE 
0b02					DMARK "SR<" 
0b02 f5				push af  
0b03 3a 17 0b			ld a, (.dmark)  
0b06 32 9d fd			ld (debug_mark),a  
0b09 3a 18 0b			ld a, (.dmark+1)  
0b0c 32 9e fd			ld (debug_mark+1),a  
0b0f 3a 19 0b			ld a, (.dmark+2)  
0b12 32 9f fd			ld (debug_mark+2),a  
0b15 18 03			jr .pastdmark  
0b17 ..			.dmark: db "SR<"  
0b1a f1			.pastdmark: pop af  
0b1b			endm  
# End of macro DMARK
0b1b					CALLMONITOR 
0b1b cd aa fd			call debug_vector  
0b1e				endm  
# End of macro CALLMONITOR
0b1e				endif 
0b1e ed b0			ldir     ; copy data 
0b20			 
0b20				; move the pointer back and pretend we have a full buffer for next recheck 
0b20			 
0b20 1b				dec de 
0b21 1b				dec de 
0b22			 
0b22			; TODO do pop below now short circuit loop????? 
0b22 c1				pop bc     ; get rid of spare de on stack 
0b23				if DEBUG_STORESE 
0b23					DMARK "SR>" 
0b23 f5				push af  
0b24 3a 38 0b			ld a, (.dmark)  
0b27 32 9d fd			ld (debug_mark),a  
0b2a 3a 39 0b			ld a, (.dmark+1)  
0b2d 32 9e fd			ld (debug_mark+1),a  
0b30 3a 3a 0b			ld a, (.dmark+2)  
0b33 32 9f fd			ld (debug_mark+2),a  
0b36 18 03			jr .pastdmark  
0b38 ..			.dmark: db "SR>"  
0b3b f1			.pastdmark: pop af  
0b3c			endm  
# End of macro DMARK
0b3c					CALLMONITOR 
0b3c cd aa fd			call debug_vector  
0b3f				endm  
# End of macro CALLMONITOR
0b3f				endif 
0b3f c3 d0 09			jp .srext 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			.readdone:		 
0b42 e1				pop hl 		 ; return start of data to show as not EOF 
0b43 23				inc hl   ; past file id 
0b44 23				inc hl   ; past ext 
0b45				if DEBUG_STORESE 
0b45					DMARK "SRe" 
0b45 f5				push af  
0b46 3a 5a 0b			ld a, (.dmark)  
0b49 32 9d fd			ld (debug_mark),a  
0b4c 3a 5b 0b			ld a, (.dmark+1)  
0b4f 32 9e fd			ld (debug_mark+1),a  
0b52 3a 5c 0b			ld a, (.dmark+2)  
0b55 32 9f fd			ld (debug_mark+2),a  
0b58 18 03			jr .pastdmark  
0b5a ..			.dmark: db "SRe"  
0b5d f1			.pastdmark: pop af  
0b5e			endm  
# End of macro DMARK
0b5e					CALLMONITOR 
0b5e cd aa fd			call debug_vector  
0b61				endm  
# End of macro CALLMONITOR
0b61				endif 
0b61 c9					ret 
0b62			 
0b62			 
0b62			 
0b62			; 
0b62			; Append File 
0b62			; 
0b62			; hl - file id to locate 
0b62			; de - pointer to (multi block) string to write 
0b62			 
0b62			.sa_notfound: 
0b62 d1				pop de 
0b63 c9				ret 
0b64			 
0b64			 
0b64			storage_append: 
0b64				; hl -  file id to append to 
0b64				; de - string to append 
0b64			 
0b64 d5				push de 
0b65				 
0b65				if DEBUG_STORESE 
0b65					DMARK "AP1" 
0b65 f5				push af  
0b66 3a 7a 0b			ld a, (.dmark)  
0b69 32 9d fd			ld (debug_mark),a  
0b6c 3a 7b 0b			ld a, (.dmark+1)  
0b6f 32 9e fd			ld (debug_mark+1),a  
0b72 3a 7c 0b			ld a, (.dmark+2)  
0b75 32 9f fd			ld (debug_mark+2),a  
0b78 18 03			jr .pastdmark  
0b7a ..			.dmark: db "AP1"  
0b7d f1			.pastdmark: pop af  
0b7e			endm  
# End of macro DMARK
0b7e					CALLMONITOR 
0b7e cd aa fd			call debug_vector  
0b81				endm  
# End of macro CALLMONITOR
0b81				endif 
0b81			 
0b81 7d				ld a, l 
0b82 32 a0 f9			ld (store_tmpid), a 
0b85			 
0b85				; get file header  
0b85			 
0b85 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b87 3a a0 f9			ld a, (store_tmpid) 
0b8a 5f				ld e, a 
0b8b			 
0b8b 21 40 00				ld hl, STORE_BLOCK_PHY 
0b8e cd a7 07				call storage_findnextid 
0b91			 
0b91 cd 07 10			call ishlzero 
0b94 28 cc			jr z, .sa_notfound 
0b96			 
0b96 22 97 f9			ld (store_tmppageid), hl 
0b99			 
0b99				; TODO handle file id not found 
0b99			 
0b99				if DEBUG_STORESE 
0b99					DMARK "AP2" 
0b99 f5				push af  
0b9a 3a ae 0b			ld a, (.dmark)  
0b9d 32 9d fd			ld (debug_mark),a  
0ba0 3a af 0b			ld a, (.dmark+1)  
0ba3 32 9e fd			ld (debug_mark+1),a  
0ba6 3a b0 0b			ld a, (.dmark+2)  
0ba9 32 9f fd			ld (debug_mark+2),a  
0bac 18 03			jr .pastdmark  
0bae ..			.dmark: db "AP2"  
0bb1 f1			.pastdmark: pop af  
0bb2			endm  
# End of macro DMARK
0bb2					CALLMONITOR 
0bb2 cd aa fd			call debug_vector  
0bb5				endm  
# End of macro CALLMONITOR
0bb5				endif 
0bb5			 
0bb5				; update file extent count 
0bb5			 
0bb5 11 ac f9			ld de, store_page 
0bb8			 
0bb8 cd 74 04			call storage_read_block 
0bbb			 
0bbb				if DEBUG_STORESE 
0bbb					DMARK "AP3" 
0bbb f5				push af  
0bbc 3a d0 0b			ld a, (.dmark)  
0bbf 32 9d fd			ld (debug_mark),a  
0bc2 3a d1 0b			ld a, (.dmark+1)  
0bc5 32 9e fd			ld (debug_mark+1),a  
0bc8 3a d2 0b			ld a, (.dmark+2)  
0bcb 32 9f fd			ld (debug_mark+2),a  
0bce 18 03			jr .pastdmark  
0bd0 ..			.dmark: db "AP3"  
0bd3 f1			.pastdmark: pop af  
0bd4			endm  
# End of macro DMARK
0bd4					CALLMONITOR 
0bd4 cd aa fd			call debug_vector  
0bd7				endm  
# End of macro CALLMONITOR
0bd7				endif 
0bd7			;	ld (store_tmppageid), hl 
0bd7			 
0bd7 3a ae f9			ld a, (store_page+2) 
0bda 3c				inc a 
0bdb 32 ae f9			ld (store_page+2), a 
0bde 32 9f f9			ld (store_tmpext), a 
0be1				 
0be1				if DEBUG_STORESE 
0be1					DMARK "AP3" 
0be1 f5				push af  
0be2 3a f6 0b			ld a, (.dmark)  
0be5 32 9d fd			ld (debug_mark),a  
0be8 3a f7 0b			ld a, (.dmark+1)  
0beb 32 9e fd			ld (debug_mark+1),a  
0bee 3a f8 0b			ld a, (.dmark+2)  
0bf1 32 9f fd			ld (debug_mark+2),a  
0bf4 18 03			jr .pastdmark  
0bf6 ..			.dmark: db "AP3"  
0bf9 f1			.pastdmark: pop af  
0bfa			endm  
# End of macro DMARK
0bfa					CALLMONITOR 
0bfa cd aa fd			call debug_vector  
0bfd				endm  
# End of macro CALLMONITOR
0bfd				endif 
0bfd 2a 97 f9			ld hl, (store_tmppageid) 
0c00 11 ac f9			ld de, store_page 
0c03 cd d9 04			call storage_write_block 
0c06			 
0c06				; find free block 
0c06			 
0c06 11 00 00			ld de, 0			 ; file extent to locate 
0c09			 
0c09 21 40 00				ld hl, STORE_BLOCK_PHY 
0c0c cd a7 07				call storage_findnextid 
0c0f cd 07 10			call ishlzero 
0c12 ca 62 0b			jp z, .sa_notfound 
0c15			 
0c15					; TODO handle no space left 
0c15					 
0c15 22 97 f9				ld (store_tmppageid), hl 
0c18			 
0c18				if DEBUG_STORESE 
0c18					DMARK "AP4" 
0c18 f5				push af  
0c19 3a 2d 0c			ld a, (.dmark)  
0c1c 32 9d fd			ld (debug_mark),a  
0c1f 3a 2e 0c			ld a, (.dmark+1)  
0c22 32 9e fd			ld (debug_mark+1),a  
0c25 3a 2f 0c			ld a, (.dmark+2)  
0c28 32 9f fd			ld (debug_mark+2),a  
0c2b 18 03			jr .pastdmark  
0c2d ..			.dmark: db "AP4"  
0c30 f1			.pastdmark: pop af  
0c31			endm  
# End of macro DMARK
0c31					CALLMONITOR 
0c31 cd aa fd			call debug_vector  
0c34				endm  
# End of macro CALLMONITOR
0c34				endif 
0c34					; init the buffer with zeros so we can id if the buffer is full or not 
0c34			 
0c34 e5					push hl 
0c35 c5					push bc 
0c36			 
0c36 21 ac f9				ld hl, store_page 
0c39 06 40				ld b, STORE_BLOCK_PHY 
0c3b 3e 00				ld a, 0 
0c3d 77			.zeroblock:	ld (hl), a 
0c3e 23					inc hl 
0c3f 10 fc				djnz .zeroblock 
0c41			 
0c41 c1					pop bc 
0c42 e1					pop hl 
0c43			 
0c43					; construct block 
0c43			 
0c43 3a a0 f9				ld a, (store_tmpid) 
0c46 32 ac f9				ld (store_page), a   ; file id 
0c49 3a 9f f9				ld a, (store_tmpext)   ; extent for this block 
0c4c 32 ad f9				ld (store_page+1), a 
0c4f			 
0c4f e1					pop hl    ; get string to write 
0c50 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c52 11 ae f9				ld de, store_page+2 
0c55			 
0c55				if DEBUG_STORESE 
0c55					DMARK "AP5" 
0c55 f5				push af  
0c56 3a 6a 0c			ld a, (.dmark)  
0c59 32 9d fd			ld (debug_mark),a  
0c5c 3a 6b 0c			ld a, (.dmark+1)  
0c5f 32 9e fd			ld (debug_mark+1),a  
0c62 3a 6c 0c			ld a, (.dmark+2)  
0c65 32 9f fd			ld (debug_mark+2),a  
0c68 18 03			jr .pastdmark  
0c6a ..			.dmark: db "AP5"  
0c6d f1			.pastdmark: pop af  
0c6e			endm  
# End of macro DMARK
0c6e					CALLMONITOR 
0c6e cd aa fd			call debug_vector  
0c71				endm  
# End of macro CALLMONITOR
0c71				endif 
0c71			 
0c71			 
0c71			 
0c71					; fill buffer with data until end of string or full block 
0c71			 
0c71 7e			.appd:		ld a, (hl) 
0c72 12					ld (de), a 
0c73 fe 00				cp 0 
0c75 28 04				jr z, .appdone 
0c77 23					inc hl 
0c78 13					inc de 
0c79 10 f6				djnz .appd 
0c7b			 
0c7b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c7c f5					push af   		; save last byte dumped 
0c7d			 
0c7d			 
0c7d 2a 97 f9			ld hl, (store_tmppageid) 
0c80 11 ac f9			ld de, store_page 
0c83				if DEBUG_STORESE 
0c83					DMARK "AP6" 
0c83 f5				push af  
0c84 3a 98 0c			ld a, (.dmark)  
0c87 32 9d fd			ld (debug_mark),a  
0c8a 3a 99 0c			ld a, (.dmark+1)  
0c8d 32 9e fd			ld (debug_mark+1),a  
0c90 3a 9a 0c			ld a, (.dmark+2)  
0c93 32 9f fd			ld (debug_mark+2),a  
0c96 18 03			jr .pastdmark  
0c98 ..			.dmark: db "AP6"  
0c9b f1			.pastdmark: pop af  
0c9c			endm  
# End of macro DMARK
0c9c					CALLMONITOR 
0c9c cd aa fd			call debug_vector  
0c9f				endm  
# End of macro CALLMONITOR
0c9f				endif 
0c9f cd d9 04				call storage_write_block 
0ca2			 
0ca2			 
0ca2				; was that a full block of data written? 
0ca2				; any more to write out? 
0ca2			 
0ca2				; if yes then set vars and jump to start of function again 
0ca2			 
0ca2 f1					pop af 
0ca3 d1					pop de 
0ca4			 
0ca4 fe 00				cp 0		 ; no, string was fully written 
0ca6 c8					ret z 
0ca7			 
0ca7					; setup vars for next cycle 
0ca7			 
0ca7 3a a0 f9				ld a, (store_tmpid) 
0caa 6f					ld l, a 
0cab 26 00				ld h, 0 
0cad			 
0cad c3 64 0b			 	jp storage_append	 ; yes, need to write out some more 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			if DEBUG_STORECF 
0cb0			storageput:	 
0cb0					ret 
0cb0			storageread: 
0cb0					ld hl, store_page 
0cb0					ld b, 200 
0cb0					ld a,0 
0cb0			.src:		ld (hl),a 
0cb0					inc hl 
0cb0					djnz .src 
0cb0					 
0cb0			 
0cb0					ld de, 0 
0cb0					ld bc, 1 
0cb0					ld hl, store_page 
0cb0					call cfRead 
0cb0			 
0cb0				call cfGetError 
0cb0				ld hl,scratch 
0cb0				call hexout 
0cb0				ld hl, scratch+2 
0cb0				ld a, 0 
0cb0				ld (hl),a 
0cb0				ld de, scratch 
0cb0				ld a,display_row_1 
0cb0				call str_at_display 
0cb0				call update_display 
0cb0			 
0cb0					ld hl, store_page 
0cb0					ld (os_cur_ptr),hl 
0cb0			 
0cb0					ret 
0cb0			endif 
0cb0			 
0cb0			 
0cb0			; Clear out the main buffer store (used to remove junk before writing a new block) 
0cb0			 
0cb0			storage_clear_page: 
0cb0 e5				push hl 
0cb1 d5				push de 
0cb2 c5				push bc 
0cb3 21 ac f9			ld hl, store_page 
0cb6 3e 00			ld a, 0 
0cb8 77				ld (hl), a 
0cb9			 
0cb9 11 ad f9			ld de, store_page+1 
0cbc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cbf			 
0cbf ed b0			ldir 
0cc1				 
0cc1 c1				pop bc 
0cc2 d1				pop de 
0cc3 e1				pop hl 
0cc4 c9				ret 
0cc5			 
0cc5			; eof 
# End of file firmware_storage.asm
0cc5			  
0cc5			; support routines for above hardware abstraction layer  
0cc5			  
0cc5			include "firmware_general.asm"        ; general support functions  
0cc5			 
0cc5			; word look up 
0cc5			 
0cc5			; in 
0cc5			; a is the index 
0cc5			; hl is pointer start of array 
0cc5			; 
0cc5			; returns 
0cc5			; hl to the word 
0cc5			; 
0cc5			 
0cc5			table_lookup:  
0cc5 d5					push de 
0cc6 eb					ex de, hl 
0cc7			 
0cc7 6f					ld l, a 
0cc8 26 00				ld h, 0 
0cca 29					add hl, hl 
0ccb 19					add hl, de 
0ccc 7e					ld a, (hl) 
0ccd 23					inc hl 
0cce 66					ld h,(hl) 
0ccf 6f					ld l, a 
0cd0			 
0cd0 d1					pop de 
0cd1 c9					ret 
0cd2			 
0cd2			; Delay loops 
0cd2			 
0cd2			 
0cd2			 
0cd2			aDelayInMS: 
0cd2 c5				push bc 
0cd3 47				ld b,a 
0cd4			msdelay: 
0cd4 c5				push bc 
0cd5				 
0cd5			 
0cd5 01 41 00			ld bc,041h 
0cd8 cd f0 0c			call delayloop 
0cdb c1				pop bc 
0cdc 05				dec b 
0cdd 20 f5			jr nz,msdelay 
0cdf			 
0cdf			;if CPU_CLOCK_8MHZ 
0cdf			;msdelay8: 
0cdf			;	push bc 
0cdf			;	 
0cdf			; 
0cdf			;	ld bc,041h 
0cdf			;	call delayloop 
0cdf			;	pop bc 
0cdf			;	dec b 
0cdf			;	jr nz,msdelay8 
0cdf			;endif 
0cdf			 
0cdf			 
0cdf c1				pop bc 
0ce0 c9				ret 
0ce1			 
0ce1			 
0ce1			delay250ms: 
0ce1				;push de 
0ce1 01 00 40			ld bc, 04000h 
0ce4 c3 f0 0c			jp delayloop 
0ce7			delay500ms: 
0ce7				;push de 
0ce7 01 00 80			ld bc, 08000h 
0cea c3 f0 0c			jp delayloop 
0ced			delay1s: 
0ced				;push bc 
0ced			   ; Clobbers A, d and e 
0ced 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cf0			delayloop: 
0cf0 c5			    push bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				ld bc, CPM_DELAY_TUNE 
0cf1			.cpmloop: 
0cf1				push bc 
0cf1			 
0cf1			endif 
0cf1			 
0cf1			 
0cf1			 
0cf1			delayloopi: 
0cf1			;	push bc 
0cf1			;.dl: 
0cf1 cb 47		    bit     0,a    	; 8 
0cf3 cb 47		    bit     0,a    	; 8 
0cf5 cb 47		    bit     0,a    	; 8 
0cf7 e6 ff		    and     255  	; 7 
0cf9 0b			    dec     bc      	; 6 
0cfa 79			    ld      a,c     	; 4 
0cfb b0			    or      b     	; 4 
0cfc c2 f1 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cff			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cff				;pop de 
0cff			;pop bc 
0cff			 
0cff			if BASE_CPM 
0cff				pop bc 
0cff				 
0cff			    dec     bc      	; 6 
0cff			    ld      a,c     	; 4 
0cff			    or      b     	; 4 
0cff			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cff				 
0cff			 
0cff			endif 
0cff			;if CPU_CLOCK_8MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff			 
0cff			;if CPU_CLOCK_10MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff c1			    pop bc 
0d00			 
0d00 c9				ret 
0d01			 
0d01			 
0d01			 
0d01			; eof 
# End of file firmware_general.asm
0d01			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0d01			; display routines that use the physical hardware abstraction layer 
0d01			 
0d01			 
0d01			; Display an activity indicator 
0d01			; Each call returns the new char pointed to in hl 
0d01			 
0d01			active: 
0d01 3a f8 fa			ld a, (display_active) 
0d04 fe 06			cp 6 
0d06			 
0d06 20 02			jr nz, .sne 
0d08				; gone past the last one reset sequence 
0d08 3e ff			ld a, 255 
0d0a			 
0d0a			.sne:   
0d0a				; get the next char in seq 
0d0a 3c				inc a 
0d0b 32 f8 fa			ld (display_active), a 
0d0e			 
0d0e				; look up the string in the table 
0d0e 21 25 0d			ld hl, actseq 
0d11 cb 27			sla a 
0d13 cd de 0f			call addatohl 
0d16 cd 2a 23			call loadwordinhl 
0d19			 
0d19				; forth will write the to string when pushing so move from rom to ram 
0d19			 
0d19 11 f9 fa			ld de, display_active+1 
0d1c 01 02 00			ld bc, 2 
0d1f ed b0			ldir 
0d21			 
0d21 21 f9 fa			ld hl, display_active+1 
0d24 c9				ret 
0d25				 
0d25				 
0d25			 
0d25			 
0d25			;db "|/-\|-\" 
0d25			 
0d25			actseq: 
0d25			 
0d25 33 0d		dw spin0 
0d27 35 0d		dw spin1 
0d29 37 0d		dw spin2 
0d2b 39 0d		dw spin3 
0d2d 37 0d		dw spin2 
0d2f 35 0d		dw spin1 
0d31 33 0d		dw spin0 
0d33			 
0d33 .. 00		spin0: db " ", 0 
0d35 .. 00		spin1: db "-", 0 
0d37 .. 00		spin2: db "+", 0 
0d39 .. 00		spin3: db "#", 0 
0d3b			 
0d3b			 
0d3b			; information window 
0d3b			 
0d3b			; pass hl with 1st string to display 
0d3b			; pass de with 2nd string to display 
0d3b			 
0d3b			info_panel: 
0d3b e5				push hl 
0d3c			 
0d3c 2a fe fa			ld hl, (display_fb_active) 
0d3f e5				push hl    ; future de destination 
0d40 21 e3 fc				ld hl, display_fb0 
0d43 22 fe fa				ld (display_fb_active), hl 
0d46			 
0d46			;	call clear_display 
0d46			 
0d46				if BASE_CPM 
0d46				ld a, '.' 
0d46				else 
0d46 3e a5			ld a, 165 
0d48				endif 
0d48 cd af 0d			call fill_display 
0d4b			 
0d4b			 
0d4b 3e 55			ld a, display_row_3 + 5 
0d4d cd bd 0d			call str_at_display 
0d50			 
0d50 e1				pop hl 
0d51 d1				pop de 
0d52			 
0d52 e5				push hl 
0d53			 
0d53			 
0d53 3e 2d			ld a, display_row_2 + 5 
0d55 cd bd 0d			call str_at_display 
0d58			 
0d58			 
0d58 cd cd 0d			call update_display 
0d5b cd 30 1f			call next_page_prompt 
0d5e cd aa 0d			call clear_display 
0d61			 
0d61				 
0d61 21 42 fc				ld hl, display_fb1 
0d64 22 fe fa				ld (display_fb_active), hl 
0d67 cd cd 0d			call update_display 
0d6a			 
0d6a e1				pop hl 
0d6b			 
0d6b c9				ret 
0d6c			 
0d6c			 
0d6c			 
0d6c			 
0d6c			; TODO windowing? 
0d6c			 
0d6c			; TODO scroll line up 
0d6c			 
0d6c			scroll_up: 
0d6c			 
0d6c e5				push hl 
0d6d d5				push de 
0d6e c5				push bc 
0d6f			 
0d6f				; get frame buffer  
0d6f			 
0d6f 2a fe fa			ld hl, (display_fb_active) 
0d72 e5				push hl    ; future de destination 
0d73			 
0d73 11 28 00			ld  de, display_cols 
0d76 19				add hl, de 
0d77			 
0d77 d1				pop de 
0d78			 
0d78				;ex de, hl 
0d78 01 9f 00			ld bc, display_fb_len -1  
0d7b			;if DEBUG_FORTH_WORDS 
0d7b			;	DMARK "SCL" 
0d7b			;	CALLMONITOR 
0d7b			;endif	 
0d7b ed b0			ldir 
0d7d			 
0d7d				; wipe bottom row 
0d7d			 
0d7d			 
0d7d 2a fe fa			ld hl, (display_fb_active) 
0d80 11 a0 00			ld de, display_cols*display_rows 
0d83 19				add hl, de 
0d84 06 28			ld b, display_cols 
0d86 3e 20			ld a, ' ' 
0d88			.scwipe: 
0d88 77				ld (hl), a 
0d89 2b				dec hl 
0d8a 10 fc			djnz .scwipe 
0d8c			 
0d8c				;pop hl 
0d8c			 
0d8c c1				pop bc 
0d8d d1				pop de 
0d8e e1				pop hl 
0d8f			 
0d8f c9				ret 
0d90			 
0d90			 
0d90			;scroll_upo: 
0d90			;	ld de, display_row_1 
0d90			 ;	ld hl, display_row_2 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_2 
0d90			 ;	ld hl, display_row_3 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_3 
0d90			 ;	ld hl, display_row_4 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			 
0d90			; TODO clear row 4 
0d90			 
0d90			;	ret 
0d90			 
0d90				 
0d90			scroll_down: 
0d90			 
0d90 e5				push hl 
0d91 d5				push de 
0d92 c5				push bc 
0d93			 
0d93				; get frame buffer  
0d93			 
0d93 2a fe fa			ld hl, (display_fb_active) 
0d96			 
0d96 11 9f 00			ld de, display_fb_len - 1 
0d99 19				add hl, de 
0d9a			 
0d9a e5			push hl    ; future de destination 
0d9b			 
0d9b 11 28 00			ld  de, display_cols 
0d9e ed 52			sbc hl, de 
0da0			 
0da0			 
0da0 d1				pop de 
0da1			 
0da1			;	ex de, hl 
0da1 01 9f 00			ld bc, display_fb_len -1  
0da4			 
0da4			 
0da4				 
0da4			 
0da4 ed b0			ldir 
0da6			 
0da6				; wipe bottom row 
0da6			 
0da6			 
0da6			;	ld hl, (display_fb_active) 
0da6			;;	ld de, display_cols*display_rows 
0da6			;;	add hl, de 
0da6			;	ld b, display_cols 
0da6			;	ld a, ' ' 
0da6			;.scwiped: 
0da6			;	ld (hl), a 
0da6			;	dec hl 
0da6			;	djnz .scwiped 
0da6			 
0da6				;pop hl 
0da6			 
0da6 c1				pop bc 
0da7 d1				pop de 
0da8 e1				pop hl 
0da9			 
0da9 c9				ret 
0daa			;scroll_down: 
0daa			;	ld de, display_row_4 
0daa			;	ld hl, display_row_3 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_3 
0daa			; 	ld hl, display_row_2 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_2 
0daa			;	ld hl, display_row_1 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;;; TODO clear row 1 
0daa			;	ret 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			; clear active frame buffer 
0daa			 
0daa			clear_display: 
0daa 3e 20			ld a, ' ' 
0dac c3 af 0d			jp fill_display 
0daf			 
0daf			; fill active frame buffer with a char in A 
0daf			 
0daf			fill_display: 
0daf 06 a0			ld b,display_fb_len 
0db1 2a fe fa			ld hl, (display_fb_active) 
0db4 77			.fd1:	ld (hl),a 
0db5 23				inc hl 
0db6 10 fc			djnz .fd1 
0db8 23				inc hl 
0db9 3e 00			ld a,0 
0dbb 77				ld (hl),a 
0dbc			 
0dbc			 
0dbc c9				ret 
0dbd			; Write string (DE) at pos (A) to active frame buffer 
0dbd			 
0dbd 2a fe fa		str_at_display:    ld hl,(display_fb_active) 
0dc0 06 00					ld b,0 
0dc2 4f					ld c,a 
0dc3 09					add hl,bc 
0dc4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0dc5 b7			            OR   A              ;Null terminator? 
0dc6 c8			            RET  Z              ;Yes, so finished 
0dc7 77					ld (hl),a 
0dc8 23				inc hl 
0dc9 13			            INC  DE             ;Point to next character 
0dca 18 f8		            JR   .sad1     ;Repeat 
0dcc c9					ret 
0dcd			 
0dcd			; using current frame buffer write to physical display 
0dcd			 
0dcd			update_display: 
0dcd e5				push hl 
0dce 2a fe fa			ld hl, (display_fb_active) 
0dd1 cd ae 76			call write_display 
0dd4 e1				pop hl 
0dd5 c9				ret 
0dd6			 
0dd6			; TODO scrolling 
0dd6			 
0dd6			 
0dd6			; move cursor right one char 
0dd6			cursor_right: 
0dd6			 
0dd6				; TODO shift right 
0dd6				; TODO if beyond max col 
0dd6				; TODO       cursor_next_line 
0dd6			 
0dd6 c9				ret 
0dd7			 
0dd7			 
0dd7			cursor_next_line: 
0dd7				; TODO first char 
0dd7				; TODO line down 
0dd7				; TODO if past last row 
0dd7				; TODO    scroll up 
0dd7			 
0dd7 c9				ret 
0dd8			 
0dd8			cursor_left: 
0dd8				; TODO shift left 
0dd8				; TODO if beyond left  
0dd8				; TODO     cursor prev line 
0dd8				 
0dd8 c9				ret 
0dd9			 
0dd9			cursor_prev_line: 
0dd9				; TODO last char 
0dd9				; TODO line up 
0dd9				; TODO if past first row 
0dd9				; TODO   scroll down 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			cout: 
0dda				; A - char 
0dda c9				ret 
0ddb			 
0ddb			 
0ddb			; Display a menu and allow item selection (optional toggle items) 
0ddb			; 
0ddb			; format: 
0ddb			; hl pointer to word array with zero term for items 
0ddb			; e.g.    db item1 
0ddb			;         db .... 
0ddb			;         db 0 
0ddb			; 
0ddb			; a = starting menu item  
0ddb			; 
0ddb			; de = pointer item toggle array   (todo) 
0ddb			; 
0ddb			; returns item selected in a 1-... 
0ddb			; returns 0 if back button pressed 
0ddb			; 
0ddb			; NOTE: Uses system frame buffer to display 
0ddb			; 
0ddb			; LEFT, Q = go back 
0ddb			; RIGHT, SPACE, CR = select 
0ddb			; UP, A - Up 
0ddb			; DOWN, Z - Down 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			menu: 
0ddb			 
0ddb					; keep array pointer 
0ddb			 
0ddb 22 a5 f9				ld (store_tmp1), hl 
0dde 32 a3 f9				ld (store_tmp2), a 
0de1			 
0de1					; check for key bounce 
0de1			 
0de1			if BASE_KEV 
0de1			 
0de1 cd f9 79		.mbounce:	call cin 
0de4 fe 00				cp 0 
0de6 20 f9				jr nz, .mbounce 
0de8			endif 
0de8					; for ease use ex 
0de8			 
0de8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0de8 21 e3 fc				ld hl, display_fb0 
0deb 22 fe fa				ld (display_fb_active), hl 
0dee			 
0dee cd aa 0d		.mloop:		call clear_display 
0df1 cd cd 0d				call update_display 
0df4			 
0df4					; draw selection id '>' at 1 
0df4			 
0df4					; init start of list display 
0df4			 
0df4 3e 05				ld a, 5 
0df6 32 a1 f9				ld (store_tmp3), a   ; display row count 
0df9 3a a3 f9				ld a,( store_tmp2) 
0dfc 32 a4 f9				ld (store_tmp2+1), a   ; display item count 
0dff			 
0dff					 
0dff			.mitem:	 
0dff			 
0dff			 
0dff 3a a4 f9				ld a,(store_tmp2+1) 
0e02 6f					ld l, a 
0e03 26 00				ld h, 0 
0e05 29					add hl, hl 
0e06 ed 5b a5 f9			ld de, (store_tmp1) 
0e0a 19					add hl, de 
0e0b 7e					ld a, (hl) 
0e0c 23					inc hl 
0e0d 66					ld h,(hl) 
0e0e 6f					ld l, a 
0e0f			 
0e0f cd 07 10				call ishlzero 
0e12 28 1a				jr z, .mdone 
0e14			 
0e14 eb					ex de, hl 
0e15 3a a1 f9				ld a, (store_tmp3) 
0e18 cd bd 0d				call str_at_display 
0e1b					 
0e1b			 
0e1b					; next item 
0e1b 3a a4 f9				ld a, (store_tmp2+1) 
0e1e 3c					inc a 
0e1f 32 a4 f9				ld (store_tmp2+1), a   ; display item count 
0e22			 
0e22			 		; next row 
0e22			 
0e22 3a a1 f9				ld a, (store_tmp3) 
0e25 c6 28				add display_cols 
0e27 32 a1 f9				ld (store_tmp3), a 
0e2a			 
0e2a					; at end of screen? 
0e2a			 
0e2a fe 10				cp display_rows*4 
0e2c 20 d1				jr nz, .mitem 
0e2e			 
0e2e			 
0e2e			.mdone: 
0e2e cd 07 10				call ishlzero 
0e31 28 08				jr z, .nodn 
0e33			 
0e33 3e 78				ld a, display_row_4 
0e35 11 b4 0e				ld de, .mdown 
0e38 cd bd 0d				call str_at_display 
0e3b			 
0e3b					; draw options to fill the screens with active item on line 1 
0e3b					; if current option is 2 or more then display ^ in top 
0e3b			 
0e3b 3a a3 f9		.nodn:		ld a, (store_tmp2) 
0e3e fe 00				cp 0 
0e40 28 08				jr z, .noup 
0e42			 
0e42 3e 00				ld a, 0 
0e44 11 b2 0e				ld de, .mup 
0e47 cd bd 0d				call str_at_display 
0e4a			 
0e4a 3e 02		.noup:		ld a, 2 
0e4c 11 b0 0e				ld de, .msel 
0e4f cd bd 0d				call str_at_display 
0e52			 
0e52					; if current option + 1 is not null then display V in bottom 
0e52					; get key 
0e52 cd cd 0d				call update_display 
0e55			 
0e55			 
0e55					; handle key 
0e55			 
0e55 cd e8 79				call cin_wait 
0e58			 
0e58 fe 05				cp KEY_UP 
0e5a 28 2b				jr z, .mgoup 
0e5c fe 61				cp 'a' 
0e5e 28 27				jr z, .mgoup 
0e60 fe 0a				cp KEY_DOWN 
0e62 28 32				jr z, .mgod 
0e64 fe 7a				cp 'z' 
0e66 28 2e				jr z, .mgod 
0e68 fe 20				cp ' ' 
0e6a 28 34				jr z, .goend 
0e6c fe 0c				cp KEY_RIGHT 
0e6e 28 30				jr z, .goend 
0e70 fe 0d				cp KEY_CR 
0e72 28 2c				jr z, .goend 
0e74 fe 71				cp 'q' 
0e76 28 0b				jr z, .goback 
0e78			 
0e78 fe 0b				cp KEY_LEFT 
0e7a 28 07				jr z, .goback 
0e7c fe 08				cp KEY_BS 
0e7e 28 03				jr z, .goback 
0e80 c3 ee 0d				jp .mloop 
0e83			 
0e83			.goback: 
0e83 3e 00			ld a, 0 
0e85 18 1d			jr .goend2 
0e87			 
0e87				; move up one 
0e87			.mgoup: 
0e87 3a a3 f9				ld a, (store_tmp2) 
0e8a fe 00				cp 0 
0e8c ca ee 0d				jp z, .mloop 
0e8f 3d					dec a 
0e90 32 a3 f9				ld (store_tmp2), a 
0e93 c3 ee 0d				jp .mloop 
0e96			 
0e96				; move down one 
0e96			.mgod: 
0e96 3a a3 f9				ld a, (store_tmp2) 
0e99 3c					inc a 
0e9a 32 a3 f9				ld (store_tmp2), a 
0e9d c3 ee 0d				jp .mloop 
0ea0			 
0ea0			 
0ea0			.goend: 
0ea0					; get selected item number 
0ea0			 
0ea0 3a a3 f9				ld a, (store_tmp2) 
0ea3 3c					inc a 
0ea4			 
0ea4			.goend2: 
0ea4 f5					push af 
0ea5			 
0ea5					; restore active fb 
0ea5					; TODO BUG assumes fb1 
0ea5			 
0ea5 21 42 fc				ld hl, display_fb1 
0ea8 22 fe fa				ld (display_fb_active), hl 
0eab			 
0eab					; restore main regs 
0eab			 
0eab			 
0eab cd cd 0d				call update_display 
0eae			 
0eae f1					pop af 
0eaf			 
0eaf c9				ret 
0eb0			 
0eb0 .. 00		.msel:   db ">",0 
0eb2 .. 00		.mup:   db "^",0 
0eb4 .. 00		.mdown:   db "v",0 
0eb6			 
0eb6			 
0eb6			; eof 
0eb6			 
# End of file firmware_display.asm
0eb6			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0eb6			; random number generators 
0eb6			 
0eb6			 
0eb6			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0eb6			 
0eb6			 
0eb6			;-----> Generate a random number 
0eb6			; output a=answer 0<=a<=255 
0eb6			; all registers are preserved except: af 
0eb6			random: 
0eb6 e5			        push    hl 
0eb7 d5			        push    de 
0eb8 2a dd fa		        ld      hl,(randData) 
0ebb ed 5f		        ld      a,r 
0ebd 57			        ld      d,a 
0ebe 5e			        ld      e,(hl) 
0ebf 19			        add     hl,de 
0ec0 85			        add     a,l 
0ec1 ac			        xor     h 
0ec2 22 dd fa		        ld      (randData),hl 
0ec5 d1			        pop     de 
0ec6 e1			        pop     hl 
0ec7 c9			        ret 
0ec8			 
0ec8			 
0ec8			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ec8			 
0ec8			 
0ec8			 
0ec8			;------LFSR------ 
0ec8			;James Montelongo 
0ec8			;optimized by Spencer Putt 
0ec8			;out: 
0ec8			; a = 8 bit random number 
0ec8			RandLFSR: 
0ec8 21 e3 fa		        ld hl,LFSRSeed+4 
0ecb 5e			        ld e,(hl) 
0ecc 23			        inc hl 
0ecd 56			        ld d,(hl) 
0ece 23			        inc hl 
0ecf 4e			        ld c,(hl) 
0ed0 23			        inc hl 
0ed1 7e			        ld a,(hl) 
0ed2 47			        ld b,a 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 cb 13		        rl e  
0ee3 cb 12			rl d 
0ee5 cb 11		        rl c  
0ee7 17				rla 
0ee8 67			        ld h,a 
0ee9 cb 13		        rl e  
0eeb cb 12			rl d 
0eed cb 11		        rl c  
0eef 17				rla 
0ef0 a8			        xor b 
0ef1 cb 13		        rl e  
0ef3 cb 12			rl d 
0ef5 ac			        xor h 
0ef6 a9			        xor c 
0ef7 aa			        xor d 
0ef8 21 e5 fa		        ld hl,LFSRSeed+6 
0efb 11 e6 fa		        ld de,LFSRSeed+7 
0efe 01 07 00		        ld bc,7 
0f01 ed b8		        lddr 
0f03 12			        ld (de),a 
0f04 c9			        ret 
0f05			 
0f05			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0f05			 
0f05			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0f05			 
0f05			 
0f05			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0f05			 
0f05			prng16: 
0f05			;Inputs: 
0f05			;   (seed1) contains a 16-bit seed value 
0f05			;   (seed2) contains a NON-ZERO 16-bit seed value 
0f05			;Outputs: 
0f05			;   HL is the result 
0f05			;   BC is the result of the LCG, so not that great of quality 
0f05			;   DE is preserved 
0f05			;Destroys: 
0f05			;   AF 
0f05			;cycle: 4,294,901,760 (almost 4.3 billion) 
0f05			;160cc 
0f05			;26 bytes 
0f05 2a d7 fa		    ld hl,(seed1) 
0f08 44			    ld b,h 
0f09 4d			    ld c,l 
0f0a 29			    add hl,hl 
0f0b 29			    add hl,hl 
0f0c 2c			    inc l 
0f0d 09			    add hl,bc 
0f0e 22 d7 fa		    ld (seed1),hl 
0f11 2a d5 fa		    ld hl,(seed2) 
0f14 29			    add hl,hl 
0f15 9f			    sbc a,a 
0f16 e6 2d		    and %00101101 
0f18 ad			    xor l 
0f19 6f			    ld l,a 
0f1a 22 d5 fa		    ld (seed2),hl 
0f1d 09			    add hl,bc 
0f1e c9			    ret 
0f1f			 
0f1f			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f1f			 
0f1f			rand32: 
0f1f			;Inputs: 
0f1f			;   (seed1_0) holds the lower 16 bits of the first seed 
0f1f			;   (seed1_1) holds the upper 16 bits of the first seed 
0f1f			;   (seed2_0) holds the lower 16 bits of the second seed 
0f1f			;   (seed2_1) holds the upper 16 bits of the second seed 
0f1f			;   **NOTE: seed2 must be non-zero 
0f1f			;Outputs: 
0f1f			;   HL is the result 
0f1f			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f1f			;Destroys: 
0f1f			;   AF 
0f1f			;Tested and passes all CAcert tests 
0f1f			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f1f			;it has a period of 18,446,744,069,414,584,320 
0f1f			;roughly 18.4 quintillion. 
0f1f			;LFSR taps: 0,2,6,7  = 11000101 
0f1f			;291cc 
0f1f			;seed1_0=$+1 
0f1f			;    ld hl,12345 
0f1f			;seed1_1=$+1 
0f1f			;    ld de,6789 
0f1f			;    ld b,h 
0f1f			;    ld c,l 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    inc l 
0f1f			;    add hl,bc 
0f1f			;    ld (seed1_0),hl 
0f1f			;    ld hl,(seed1_1) 
0f1f			;    adc hl,de 
0f1f			;    ld (seed1_1),hl 
0f1f			;    ex de,hl 
0f1f			;seed2_0=$+1 
0f1f			;    ld hl,9876 
0f1f			;seed2_1=$+1 
0f1f			;    ld bc,54321 
0f1f			;    add hl,hl \ rl c \ rl b 
0f1f			;    ld (seed2_1),bc 
0f1f			;    sbc a,a 
0f1f			;    and %11000101 
0f1f			;    xor l 
0f1f			;    ld l,a 
0f1f			;    ld (seed2_0),hl 
0f1f			;    ex de,hl 
0f1f			;    add hl,bc 
0f1f			;    ret 
0f1f			; 
0f1f			 
0f1f			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f1f			; 20 bytes, 86 cycles (excluding ret) 
0f1f			 
0f1f			; returns   hl = pseudorandom number 
0f1f			; corrupts   a 
0f1f			 
0f1f			; generates 16-bit pseudorandom numbers with a period of 65535 
0f1f			; using the xorshift method: 
0f1f			 
0f1f			; hl ^= hl << 7 
0f1f			; hl ^= hl >> 9 
0f1f			; hl ^= hl << 8 
0f1f			 
0f1f			; some alternative shift triplets which also perform well are: 
0f1f			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f1f			 
0f1f			;  org 32768 
0f1f			 
0f1f			xrnd: 
0f1f 2a db fa		  ld hl,(xrandc)       ; seed must not be 0 
0f22 3e 00		  ld a,0 
0f24 bd			  cp l 
0f25 20 02		  jr nz, .xrnd1 
0f27 2e 01		  ld l, 1 
0f29			.xrnd1: 
0f29			 
0f29 7c			  ld a,h 
0f2a 1f			  rra 
0f2b 7d			  ld a,l 
0f2c 1f			  rra 
0f2d ac			  xor h 
0f2e 67			  ld h,a 
0f2f 7d			  ld a,l 
0f30 1f			  rra 
0f31 7c			  ld a,h 
0f32 1f			  rra 
0f33 ad			  xor l 
0f34 6f			  ld l,a 
0f35 ac			  xor h 
0f36 67			  ld h,a 
0f37			 
0f37 22 db fa		  ld (xrandc),hl 
0f3a			 
0f3a c9			  ret 
0f3b			;  
0f3b			 
0f3b			 
0f3b			;;;; int maths 
0f3b			 
0f3b			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f3b			; Divide 16-bit values (with 16-bit result) 
0f3b			; In: Divide BC by divider DE 
0f3b			; Out: BC = result, HL = rest 
0f3b			; 
0f3b			Div16: 
0f3b 21 00 00		    ld hl,0 
0f3e 78			    ld a,b 
0f3f 06 08		    ld b,8 
0f41			Div16_Loop1: 
0f41 17			    rla 
0f42 ed 6a		    adc hl,hl 
0f44 ed 52		    sbc hl,de 
0f46 30 01		    jr nc,Div16_NoAdd1 
0f48 19			    add hl,de 
0f49			Div16_NoAdd1: 
0f49 10 f6		    djnz Div16_Loop1 
0f4b 17			    rla 
0f4c 2f			    cpl 
0f4d 47			    ld b,a 
0f4e 79			    ld a,c 
0f4f 48			    ld c,b 
0f50 06 08		    ld b,8 
0f52			Div16_Loop2: 
0f52 17			    rla 
0f53 ed 6a		    adc hl,hl 
0f55 ed 52		    sbc hl,de 
0f57 30 01		    jr nc,Div16_NoAdd2 
0f59 19			    add hl,de 
0f5a			Div16_NoAdd2: 
0f5a 10 f6		    djnz Div16_Loop2 
0f5c 17			    rla 
0f5d 2f			    cpl 
0f5e 41			    ld b,c 
0f5f 4f			    ld c,a 
0f60 c9			ret 
0f61			 
0f61			 
0f61			;http://z80-heaven.wikidot.com/math 
0f61			; 
0f61			;Inputs: 
0f61			;     DE and A are factors 
0f61			;Outputs: 
0f61			;     A is not changed 
0f61			;     B is 0 
0f61			;     C is not changed 
0f61			;     DE is not changed 
0f61			;     HL is the product 
0f61			;Time: 
0f61			;     342+6x 
0f61			; 
0f61			Mult16: 
0f61			 
0f61 06 08		     ld b,8          ;7           7 
0f63 21 00 00		     ld hl,0         ;10         10 
0f66 29			       add hl,hl     ;11*8       88 
0f67 07			       rlca          ;4*8        32 
0f68 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f6a 19			         add hl,de   ;--         -- 
0f6b 10 f9		       djnz $-5      ;13*7+8     99 
0f6d c9			ret 
0f6e			 
0f6e			; 
0f6e			; Square root of 16-bit value 
0f6e			; In:  HL = value 
0f6e			; Out:  D = result (rounded down) 
0f6e			; 
0f6e			;Sqr16: 
0f6e			;    ld de,#0040 
0f6e			;    ld a,l 
0f6e			;    ld l,h 
0f6e			;    ld h,d 
0f6e			;    or a 
0f6e			;    ld b,8 
0f6e			;Sqr16_Loop: 
0f6e			;    sbc hl,de 
0f6e			;    jr nc,Sqr16_Skip 
0f6e			;    add hl,de 
0f6e			;Sqr16_Skip: 
0f6e			;    ccf 
0f6e			;    rl d 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    djnz Sqr16_Loop 
0f6e			;    ret 
0f6e			; 
0f6e			; 
0f6e			; Divide 8-bit values 
0f6e			; In: Divide E by divider C 
0f6e			; Out: A = result, B = rest 
0f6e			; 
0f6e			Div8: 
0f6e af			    xor a 
0f6f 06 08		    ld b,8 
0f71			Div8_Loop: 
0f71 cb 13		    rl e 
0f73 17			    rla 
0f74 91			    sub c 
0f75 30 01		    jr nc,Div8_NoAdd 
0f77 81			    add a,c 
0f78			Div8_NoAdd: 
0f78 10 f7		    djnz Div8_Loop 
0f7a 47			    ld b,a 
0f7b 7b			    ld a,e 
0f7c 17			    rla 
0f7d 2f			    cpl 
0f7e c9			    ret 
0f7f			 
0f7f			; 
0f7f			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f7f			; In: Multiply A with DE 
0f7f			; Out: HL = result 
0f7f			; 
0f7f			Mult12U: 
0f7f 2e 00		    ld l,0 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd0 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd0: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd1 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd1: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd2 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd2: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd3 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd3: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 30 01		    jr nc,Mult12U_NoAdd4 
0f98 19			    add hl,de 
0f99			Mult12U_NoAdd4: 
0f99 29			    add hl,hl 
0f9a 87			    add a,a 
0f9b 30 01		    jr nc,Mult12U_NoAdd5 
0f9d 19			    add hl,de 
0f9e			Mult12U_NoAdd5: 
0f9e 29			    add hl,hl 
0f9f 87			    add a,a 
0fa0 30 01		    jr nc,Mult12U_NoAdd6 
0fa2 19			    add hl,de 
0fa3			Mult12U_NoAdd6: 
0fa3 29			    add hl,hl 
0fa4 87			    add a,a 
0fa5 d0			    ret nc 
0fa6 19			    add hl,de 
0fa7 c9			    ret 
0fa8			 
0fa8			; 
0fa8			; Multiply 8-bit value with a 16-bit value (right rotating) 
0fa8			; In: Multiply A with DE 
0fa8			;      Put lowest value in A for most efficient calculation 
0fa8			; Out: HL = result 
0fa8			; 
0fa8			Mult12R: 
0fa8 21 00 00		    ld hl,0 
0fab			Mult12R_Loop: 
0fab cb 3f		    srl a 
0fad 30 01		    jr nc,Mult12R_NoAdd 
0faf 19			    add hl,de 
0fb0			Mult12R_NoAdd: 
0fb0 cb 23		    sla e 
0fb2 cb 12		    rl d 
0fb4 b7			    or a 
0fb5 c2 ab 0f		    jp nz,Mult12R_Loop 
0fb8 c9			    ret 
0fb9			 
0fb9			; 
0fb9			; Multiply 16-bit values (with 32-bit result) 
0fb9			; In: Multiply BC with DE 
0fb9			; Out: BCHL = result 
0fb9			; 
0fb9			Mult32: 
0fb9 79			    ld a,c 
0fba 48			    ld c,b 
0fbb 21 00 00		    ld hl,0 
0fbe 06 10		    ld b,16 
0fc0			Mult32_Loop: 
0fc0 29			    add hl,hl 
0fc1 17			    rla 
0fc2 cb 11		    rl c 
0fc4 30 07		    jr nc,Mult32_NoAdd 
0fc6 19			    add hl,de 
0fc7 ce 00		    adc a,0 
0fc9 d2 cd 0f		    jp nc,Mult32_NoAdd 
0fcc 0c			    inc c 
0fcd			Mult32_NoAdd: 
0fcd 10 f1		    djnz Mult32_Loop 
0fcf 41			    ld b,c 
0fd0 4f			    ld c,a 
0fd1 c9			    ret 
0fd2			 
0fd2			 
0fd2			 
0fd2			; 
0fd2			; Multiply 8-bit values 
0fd2			; In:  Multiply H with E 
0fd2			; Out: HL = result 
0fd2			; 
0fd2			Mult8: 
0fd2 16 00		    ld d,0 
0fd4 6a			    ld l,d 
0fd5 06 08		    ld b,8 
0fd7			Mult8_Loop: 
0fd7 29			    add hl,hl 
0fd8 30 01		    jr nc,Mult8_NoAdd 
0fda 19			    add hl,de 
0fdb			Mult8_NoAdd: 
0fdb 10 fa		    djnz Mult8_Loop 
0fdd c9			    ret 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			;;http://z80-heaven.wikidot.com/math 
0fde			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fde			; 
0fde			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fde			;     ld a,16        ;7 
0fde			;     ld hl,0        ;10 
0fde			;     jp $+5         ;10 
0fde			;.DivLoop: 
0fde			;       add hl,bc    ;-- 
0fde			;       dec a        ;64 
0fde			;       jr z,.DivLoopEnd        ;86 
0fde			; 
0fde			;       sla e        ;128 
0fde			;       rl d         ;128 
0fde			;       adc hl,hl    ;240 
0fde			;       sbc hl,bc    ;240 
0fde			;       jr nc,.DivLoop ;23|21 
0fde			;       inc e        ;-- 
0fde			;       jp .DivLoop+1 
0fde			; 
0fde			;.DivLoopEnd: 
0fde			 
0fde			;HL_Div_C: 
0fde			;Inputs: 
0fde			;     HL is the numerator 
0fde			;     C is the denominator 
0fde			;Outputs: 
0fde			;     A is the remainder 
0fde			;     B is 0 
0fde			;     C is not changed 
0fde			;     DE is not changed 
0fde			;     HL is the quotient 
0fde			; 
0fde			;       ld b,16 
0fde			;       xor a 
0fde			;         add hl,hl 
0fde			;         rla 
0fde			;         cp c 
0fde			;         jr c,$+4 
0fde			;           inc l 
0fde			;           sub c 
0fde			;         djnz $-7 
0fde			 
0fde			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fde			 
0fde			addatohl: 
0fde 85			    add   a, l    ; A = A+L 
0fdf 6f			    ld    l, a    ; L = A+L 
0fe0 8c			    adc   a, h    ; A = A+L+H+carry 
0fe1 95			    sub   l       ; A = H+carry 
0fe2 67			    ld    h, a    ; H = H+carry 
0fe3 c9			ret 
0fe4			 
0fe4			addatode: 
0fe4 83			    add   a, e    ; A = A+L 
0fe5 5f			    ld    e, a    ; L = A+L 
0fe6 8a			    adc   a, d    ; A = A+L+H+carry 
0fe7 93			    sub   e       ; A = H+carry 
0fe8 57			    ld    d, a    ; H = H+carry 
0fe9 c9			ret 
0fea			 
0fea			 
0fea			addatobc: 
0fea 81			    add   a, c    ; A = A+L 
0feb 4f			    ld    c, a    ; L = A+L 
0fec 88			    adc   a, b    ; A = A+L+H+carry 
0fed 91			    sub   c       ; A = H+carry 
0fee 47			    ld    b, a    ; H = H+carry 
0fef c9			ret 
0ff0			 
0ff0			subafromhl: 
0ff0			   ; If A=0 do nothing 
0ff0			    ; Otherwise flip A's sign. Since 
0ff0			    ; the upper byte becomes -1, also 
0ff0			    ; substract 1 from H. 
0ff0 ed 44		    neg 
0ff2 ca fb 0f		    jp    z, Skip 
0ff5 25			    dec   h 
0ff6			     
0ff6			    ; Now add the low byte as usual 
0ff6			    ; Two's complement takes care of 
0ff6			    ; ensuring the result is correct 
0ff6 85			    add   a, l 
0ff7 6f			    ld    l, a 
0ff8 8c			    adc   a, h 
0ff9 95			    sub   l 
0ffa 67			    ld    h, a 
0ffb			Skip: 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			; compare hl and de 
0ffc			; returns:  
0ffc			; if hl = de, z=1, s=0, c0=0 
0ffc			; if hl > de, z=0, s=0, c=0 
0ffc			; if hl < de, z=0, s=1, c=1 
0ffc			cmp16:	 
0ffc b7				or a 
0ffd ed 52			sbc hl,de 
0fff e0				ret po 
1000 7c				ld a,h 
1001 1f				rra 
1002 ee 40			xor 01000000B 
1004 37				scf 
1005 8f				adc a,a 
1006 c9				ret 
1007			 
1007			 
1007			; test if hl contains zero   - A is destroyed 
1007			 
1007			ishlzero:    
1007 b7				or a     ; reset flags 
1008 7c				ld a, h 
1009 b5				or l        	 
100a			 
100a c9				ret 
100b			 
100b			 
100b			 
100b			 
100b			if FORTH_ENABLE_FLOATMATH 
100b			;include "float/bbcmath.z80" 
100b			include "float/lpfpcalc.asm" 
100b			endif 
100b			 
100b			 
100b			; eof 
100b			 
# End of file firmware_maths.asm
100b			include "firmware_strings.asm"   ; string handling  
100b			 
100b			 
100b			; TODO string len 
100b			; input text string, end on cr with zero term 
100b			; a offset into frame buffer to start prompt 
100b			; d is max length 
100b			; e is display size TODO 
100b			; c is current cursor position 
100b			; hl is ptr to where string will be stored and edited directly 
100b			 
100b			 
100b			; TODO check limit of buffer for new inserts 
100b			; TODO check insert does not push beyond buffer 
100b			; TODO scroll in a limited display area 
100b			; TODO scroll whole screen on page wrap 
100b			 
100b			 
100b			; TODO use LCD cursor? 
100b			 
100b			EDIT_V1: equ 0 
100b			EDIT_V2: equ 1 
100b			 
100b			 
100b			 
100b			if EDIT_V2 
100b			input_str: 
100b			 
100b 32 96 fd			    	ld (input_at_pos),a      ; save display position to start 
100e			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
100e 22 99 fd				ld (input_start), hl     ; save ptr to buffer 
1011			;		ld a, c 
1011			;		call addatohl 
1011			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1011 7a					ld a,d 
1012 32 98 fd			        ld (input_size), a       ; save length of input area 
1015 79					ld a, c 
1016 32 87 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
1019 7b					ld a,e 
101a 32 97 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101d			 
101d			 
101d					; add a trailing space to make screen refresh nicer 
101d			 
101d					;ld hl, (input_start) 
101d					;push hl 
101d					;ld a, 0 
101d					;call strlent 
101d					;ld a, l 
101d					;pop hl 
101d					;call addatohl 
101d					;dec hl 
101d					;ld a, ' ' 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld a, 0 
101d					;ld (hl), a 
101d			 
101d			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101d					; init cursor shape if not set by the cin routines 
101d 21 f3 fa				ld hl, cursor_shape 
1020			if BASE_KEV 
1020 3e ff				ld a, 255 
1022			else 
1022					ld a, '#' 
1022			endif 
1022 77					ld (hl), a 
1023 23					inc hl 
1024 3e 00				ld a, 0 
1026 77					ld (hl), a 
1027			 
1027 3e 09				ld a, CUR_BLINK_RATE 
1029 32 92 fd				ld (input_cur_flash), a 
102c 3e 01				ld a, 1 
102e 32 91 fd				ld (input_cur_onoff),a 
1031			.inmain:	 
1031			 
1031 cd 59 11				call input_disp_ref 
1034			 
1034					; save current length of string 
1034			 
1034 2a 99 fd				ld hl, (input_start) 
1037 3e 00				ld a, 0 
1039 cd 4f 13				call strlent 
103c 7d					ld a,l 
103d 32 8c fd				ld (input_len), a 
1040			 
1040					;call input_disp_oncur 
1040			 
1040					; display current state of input buffer 
1040			 
1040					; clean any backspace chars 
1040			 
1040 3e 20				ld a, " " 
1042 32 f3 f0				ld (scratch),a 
1045 3e 00				ld a, 0 
1047 32 f4 f0				ld (scratch+1),a 
104a 3a 96 fd				ld a,(input_at_pos) 
104d 85					add l 
104e 11 f3 f0				ld de, scratch 
1051 cd bd 0d				call str_at_display 
1054			 
1054					; pause 1ms 
1054			 
1054 3e 01				ld a, 1 
1056 cd d2 0c				call aDelayInMS 
1059			 
1059			; display cursor if visible on this cycle 
1059			 
1059					; dec flash counter 
1059 3a 92 fd				ld a, (input_cur_flash) 
105c 3d					dec a 
105d 32 92 fd				ld (input_cur_flash), a 
1060 fe 00				cp 0 
1062 20 0d				jr nz, .inochgstate 
1064			 
1064			 
1064					; reset on change of state 
1064 3e 09				ld a, CUR_BLINK_RATE 
1066 32 92 fd				ld (input_cur_flash), a 
1069			 
1069					; change state 
1069 3a 91 fd				ld a,(input_cur_onoff) 
106c ed 44				neg 
106e 32 91 fd				ld (input_cur_onoff),a 
1071			 
1071			 
1071			 
1071			 
1071					; TODO is cursor visible? 
1071					; TODO if so then over write the char at curspos pos with the cursor shape 
1071			 
1071								 
1071			 
1071			.inochgstate: 
1071 3a 91 fd				ld a,(input_cur_onoff) 
1074 fe ff				cp 255 
1076 28 0e				jr z, .skipcursor 
1078 3a 96 fd				ld a, (input_at_pos) 
107b 47					ld b, a 
107c 3a 87 fd				ld a, (input_cursor) 
107f 80					add b 
1080 11 f3 fa				ld de, cursor_shape 
1083					 
1083 cd bd 0d				call str_at_display 
1086			 
1086			.skipcursor: 
1086				if DEBUG_INPUTV2 
1086			 
1086					ld a,(input_at_pos) 
1086					ld hl, LFSRSeed 
1086					call hexout 
1086					ld a, (input_cursor) 
1086					ld hl, LFSRSeed+2 
1086					call hexout 
1086					ld a,(input_size) 
1086					ld hl, LFSRSeed+4 
1086					call hexout 
1086			 
1086					ld a,(input_cur_onoff) 
1086					ld hl, LFSRSeed+6 
1086					call hexout 
1086			 
1086					ld a,(input_cur_flash) 
1086					ld hl, LFSRSeed+8 
1086					call hexout 
1086			 
1086					ld a,(input_len) 
1086					ld hl, LFSRSeed+10 
1086					call hexout 
1086					ld hl, LFSRSeed+12 
1086					ld a, 0 
1086					ld (hl),a 
1086					ld a, display_row_4 
1086					ld de, LFSRSeed 
1086					call str_at_display 
1086				endif 
1086 cd cd 0d				call update_display 
1089			 
1089					; TODO keyboard processing 
1089			 
1089			if BASE_CPM 
1089					call cin_wait 
1089			else 
1089 cd f9 79				call cin    ; _wait 
108c			endif 
108c fe 00				cp 0 
108e ca 31 10				jp z, .inmain 
1091			 
1091 fe 0b				cp KEY_LEFT    ; cursor left 
1093 ca 4b 11				jp z, input_left 
1096				 
1096 fe 0c				cp KEY_RIGHT      ; cursor right 
1098 ca 52 11				jp z, input_right 
109b			 
109b fe 0d				cp KEY_CR 
109d c8					ret z 
109e			 
109e fe 08				cp KEY_BS 
10a0 ca c0 11				jp z, input_delchar 
10a3			 
10a3 fe 06				cp KEY_NEXTWORD 
10a5 ca cc 10				jp z, input_nxtword 
10a8			 
10a8 fe 07				cp KEY_PREVWORD 
10aa ca f3 10				jp z, input_prvword 
10ad			 
10ad fe 0e				cp KEY_HOME    ; jump to start of line 
10af 20 08				jr nz, .ikh 
10b1 3e 00				ld a, 0 
10b3 32 87 fd				ld (input_cursor), a 
10b6 ca 31 10				jp z, .inmain 
10b9			.ikh: 
10b9			 
10b9 fe 0f				cp KEY_END     ; jump to end of line 
10bb 20 09				jr nz, .ike 
10bd 3a 8c fd				ld a, (input_len) 
10c0 32 87 fd				ld (input_cursor),a 
10c3 ca 31 10				jp z, .inmain 
10c6			.ike: 
10c6 fe 05			        cp KEY_UP      ; recall last command 
10c8 c8					ret z 
10c9			;jr nz, .irec 
10c9			; TODO next word 
10c9			; TODO prev word 
10c9			;  
10c9			; 
10c9			;	ld hl, scratch 
10c9			;	ld de, os_last_cmd 
10c9			;	call strcpy 
10c9			;		jp  .inmain 
10c9			.irec: 
10c9			;		jr .instr1 
10c9			 
10c9			 
10c9			 
10c9					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10c9			 
10c9			; TODO return if any special keys are given 
10c9			;		ld l, a 
10c9			;		ld a, 28 ; KEY_F12   ; 27 
10c9			;		sub l 
10c9			;		ret m 
10c9			;		ld a, l 
10c9					; if no special key then insert as a char 
10c9			 
10c9 c3 92 11				jp input_inschr 
10cc			 
10cc				 
10cc			input_nxtword: 
10cc				; jump to start next word after the cursor 
10cc			 
10cc			.insknwn:	 
10cc cd 88 11				call input_curptr	 
10cf 7e					ld a,(hl)	 
10d0 fe 00				cp 0 
10d2 ca 31 10				jp z, .inmain    ; end of string 
10d5			 
10d5			; if we are on a word, then move off of it 
10d5			 
10d5 fe 20				cp ' ' 
10d7 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10d9 21 87 fd				ld hl, input_cursor 
10dc 34					inc (hl) 
10dd 18 ed				jr .insknwn 
10df			 
10df			.inspace: 
10df			 
10df cd 88 11				call input_curptr	 
10e2 7e					ld a,(hl)	 
10e3 fe 00				cp 0 
10e5 ca 31 10				jp z, .inmain    ; end of string 
10e8			 
10e8			; if we are on a word, then move off of it 
10e8			 
10e8 fe 20				cp ' ' 
10ea c2 31 10				jp nz, .inmain     ; we are on non space so at next word 
10ed 21 87 fd				ld hl, input_cursor 
10f0 34					inc (hl) 
10f1 18 ec				jr .inspace 
10f3			 
10f3			 
10f3			 
10f3			 
10f3			input_prvword: 
10f3				; jump to the start of previous word before the cursor 
10f3			 
10f3			; where are we to start with currently? 
10f3			 
10f3 cd 88 11				call input_curptr	 
10f6 7e					ld a, (hl) 
10f7 fe 20				cp ' ' 
10f9 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10fb			 
10fb			 
10fb			 
10fb			.inskpwn:	 
10fb 3a 87 fd				ld a,(input_cursor) 
10fe fe 00				cp 0 
1100 ca 31 10				jp z, .inmain    ; start of string 
1103			 
1103			;if we are on a word, then move off of it 
1103			 
1103 cd 88 11				call input_curptr	 
1106 7e					ld a, (hl) 
1107 fe 20				cp ' ' 
1109 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
110b					;jp z, .inmain    ; start of string 
110b 21 87 fd				ld hl, input_cursor 
110e 35					dec (hl) 
110f 18 ea				jr .inskpwn 
1111			.iwstart: 
1111 21 87 fd				ld hl, input_cursor 
1114 34					inc (hl) 
1115 c3 31 10				jp .inmain 
1118					 
1118			 
1118			.inspacep: 
1118			 
1118					;jp .inmain    ; start of string 
1118			 
1118			 
1118			 
1118 3a 87 fd				ld a,(input_cursor) 
111b fe 00				cp 0 
111d ca 31 10				jp z, .inmain    ; start of string 
1120			 
1120			; if we are on a word, then move off of it 
1120			 
1120 cd 88 11				call input_curptr	 
1123 7e					ld a, (hl) 
1124 fe 20				cp ' ' 
1126 c2 2f 11				jp nz, .incharp     ; we are on non space so at end of prev word 
1129 21 87 fd				ld hl, input_cursor 
112c 35					dec (hl) 
112d 18 e9				jr .inspacep 
112f			 
112f			 
112f			.incharp:	 
112f					; eat the word to get to the start 
112f 3a 87 fd				ld a,(input_cursor) 
1132 fe 00				cp 0 
1134 ca 31 10				jp z, .inmain    ; start of string 
1137			 
1137			; if we are on a word, then move off of it 
1137			 
1137 cd 88 11				call input_curptr	 
113a 7e					ld a, (hl) 
113b fe 20				cp ' ' 
113d 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
113f 21 87 fd				ld hl, input_cursor 
1142 35					dec (hl) 
1143 18 ea				jr .incharp 
1145			.ipwordst: 
1145					; at space before the prev word so reposition over it 
1145 21 87 fd				ld hl, input_cursor 
1148 34					inc (hl) 
1149 18 b0				jr .inskpwn 
114b					 
114b			 
114b			 
114b			input_left: 
114b				; move cursor left 
114b 21 87 fd			ld hl, input_cursor 
114e 35				dec (hl) 
114f			;	cp 0 
114f			;	jp z, .inmain    ; ignore left as at the start of the string 
114f c3 31 10			jp .inmain 
1152			 
1152			input_right: 
1152				; move cursor right 
1152				 
1152				;ld a, (input_size) 
1152				;ld b, a 
1152 21 87 fd			ld hl, input_cursor 
1155 34				inc (hl) 
1156				;dec b 
1156				;cp 0 
1156				;jp z, .inmain   ; ignore as at end of the string buffer 
1156				;ld a, b 
1156				;inc a 
1156				;ld (input_cursor), a 
1156 c3 31 10			jp .inmain 
1159			 
1159			 
1159			 
1159			input_disp_ref: 
1159				; display the text from start of buffer (ie full refresh) 
1159 3a 96 fd			ld a, (input_at_pos) 
115c 2a 99 fd			ld hl,(input_start) 
115f eb				ex de, hl 
1160 cd bd 0d			call str_at_display  
1163 c9				ret 
1164			input_disp_oncur: 
1164				; display the text from cursor position to end of buffer 
1164				; TODO position start of string at cursor position on screen 
1164				; TODO draw from that point on 
1164 3a 87 fd			ld a, (input_cursor) 
1167 47				ld b, a 
1168 3a 96 fd			ld a, (input_at_pos) 
116b 80				add b 
116c 48				ld c, b     ; save a 
116d 78				ld a, b     ; inc string start for cursor 
116e 2a 99 fd			ld hl,(input_start) 
1171 cd de 0f			call addatohl 
1174 eb				ex de, hl 
1175 79				ld a, c 
1176 cd bd 0d			call str_at_display  
1179 c9				ret 
117a			 
117a			input_nxtw: 
117a				; Find next word 
117a c9				ret 
117b			 
117b			input_prvw: 
117b				; Find previous word 
117b c9				ret 
117c			 
117c			input_lenrem:   
117c				; Calculate the length of string remaining from current cursor 
117c				; position to end of buffer (exc null term) 
117c				 
117c 3a 87 fd			ld a, (input_cursor) 
117f 4f				ld c, a 
1180 3a 98 fd			ld a, (input_size) 
1183 91				sub c 
1184 06 00			ld b, 0 
1186 0d				dec c 
1187 c9				ret	 
1188			 
1188			input_curptr: 
1188				; calc address of the character under the cursor 
1188				 
1188 2a 99 fd			ld hl, (input_start) 
118b 3a 87 fd			ld a, (input_cursor) 
118e cd de 0f			call addatohl 
1191 c9				ret 
1192			 
1192			input_inschr: 
1192				; Insert char at cursor position 
1192 f5				push af   ; save char 
1193				;call input_lenrem    ; get bc length of remaining string 
1193			 
1193				 
1193 cd 88 11			call input_curptr 
1196			;	ld hl, (input_start) 
1196			;	ld a, (input_cursor) 
1196			;	call addatohl 
1196				;push hl   ; save to come back to 
1196			 
1196				; shift everything up one to end of buffer 
1196			 
1196				;push hl 
1196				;dec de 
1196				;inc de 
1196			;	ldir 
1196				 
1196				;pop hl 
1196			 
1196				; are we adding to the end of line? 
1196			 
1196 3a 87 fd			ld a, (input_cursor) 
1199 47				ld b, a 
119a 3a 8c fd			ld a, (input_len) 
119d b8				cp b 
119e 20 09			jr nz, .insmid   ; no, insert in middle of text 
11a0			 
11a0				; tack on the end of the line 
11a0 f1				pop af 
11a1 77				ld (hl), a   ; save new char 
11a2 23				inc hl 
11a3 3e 00			ld a, 0 
11a5 77				ld (hl), a 
11a6 c3 52 11			jp input_right 
11a9				 
11a9			.insmid: 
11a9				; hl has insertion point so move everything up one to allow for insertion 
11a9				;call input_shiftright 
11a9 f1				pop af 
11aa			 
11aa			.shufinsmid: 
11aa 47				ld b, a     ; b contains new char, c prev char at this position  
11ab 7e				ld a, (hl) 
11ac			 
11ac fe 00			cp 0    ; at end of string need to then dump new char and add term 
11ae 28 07			jr z, .endinsmid 
11b0 4f				ld c, a 
11b1 78				ld a, b 
11b2 77				ld (hl), a 
11b3 23				inc hl 
11b4 79				ld a, c 
11b5 18 f3			jr .shufinsmid 
11b7				 
11b7			 
11b7			 
11b7			 
11b7			.endinsmid: 
11b7 78				ld a, b 
11b8 77				ld (hl), a 
11b9 23				inc hl 
11ba 3e 00			ld a, 0 
11bc 77				ld (hl), a 
11bd			 
11bd			 
11bd			;	ld (hl), a   ; save new char 
11bd			 
11bd c3 52 11			jp input_right 
11c0			 
11c0			;input_shiftright: 
11c0			;	; shift text right at cursor, hl has shift start 
11c0			;	push hl 
11c0			;	push de 
11c0			;	push bc 
11c0			; 
11c0			; 
11c0			;	; move to end of string past zero term 
11c0			;	ld hl,(input_start) 
11c0			;	ld a, (input_len) 
11c0			;	call addatohl 
11c0			;	inc hl 
11c0			;;	inc hl 
11c0			;;	inc hl 
11c0			;	ld a, 0 
11c0			;	ld (hl), a 
11c0			;;	dec hl 
11c0			;	 
11c0			;;	ld (hl), a 
11c0			;;	dec hl 
11c0			; 
11c0			;	push hl 
11c0			;	pop de 
11c0			;	inc de 
11c0			;	 
11c0			; 
11c0			;;	ld hl,(input_start) 
11c0			;;	ld a, (input_cursor) 
11c0			;;	call addatohl 
11c0			; 
11c0			; 
11c0			;	; calc how many bytes from cursor pos to end of string we need to shift 
11c0			;	call input_lenrem    ; get bc length of remaining string 
11c0			;	;ld a, (input_cursor) 
11c0			;	;ld c, a 
11c0			;	ld a, (input_len) 
11c0			;	cp 2 
11c0			;	jr z, .iskipzero	 
11c0			;	;sub c 
11c0			;	;inc a 
11c0			;	;ld c, a 
11c0			;	;ld b, 0 
11c0			;	inc c 
11c0			;	inc c 
11c0			;	; move data 
11c0			;	lddr 
11c0			;.iskipzero: 
11c0			; 
11c0			;	pop bc 
11c0			;	pop de 
11c0			;	pop hl 
11c0			;	ret	 
11c0			 
11c0			input_delchar: 
11c0				; Delete char at cursor position 
11c0 cd 7c 11			call input_lenrem    ; get bc length of remaining string 
11c3 2a 99 fd			ld hl, (input_start) 
11c6 3a 87 fd			ld a, (input_cursor) 
11c9 cd de 0f			call addatohl 
11cc			 
11cc e5				push hl 
11cd d1				pop de 
11ce 1b				dec de 
11cf			 
11cf			.dl:	 
11cf ed a0			ldi  
11d1 7e				ld a, (hl) 
11d2 fe 00			cp 0 
11d4 28 02			jr z, .dldone 
11d6 18 f7			jr .dl 
11d8			.dldone: 
11d8 ed a0			ldi 
11da			 
11da c3 4b 11			jp input_left 
11dd			 
11dd			 
11dd			endif 
11dd			 
11dd			 
11dd			 
11dd			if EDIT_V1 
11dd			input_str: 
11dd			 
11dd				    	ld (input_at_pos),a      ; save display position to start 
11dd					add c 
11dd					ld (input_at_cursor),a	; save draw pos of cursor 
11dd					ld (input_start), hl     ; save ptr to buffer 
11dd					ld a, c 
11dd					call addatohl 
11dd					ld (input_ptr), hl     ; save ptr to point under the cursor 
11dd					ld a,d 
11dd				        ld (input_size), a       ; save length of input area 
11dd					ld a, c 
11dd					ld (input_cursor),a      ; init cursor start position  
11dd					ld a,e 
11dd				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11dd					 
11dd					 
11dd			 
11dd			;		ld a,(input_ptr) 
11dd			;		ld (input_under_cursor),a 	; save what is under the cursor 
11dd			 
11dd			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11dd					; init cursor shape if not set by the cin routines 
11dd					ld hl, cursor_shape 
11dd			if BASE_KEV 
11dd					ld a, 255 
11dd			else 
11dd					ld a, '#' 
11dd			endif 
11dd					ld (hl), a 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl), a 
11dd			 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					ld a, 1 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'I' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd			.is1:		; main entry loop 
11dd			 
11dd			 
11dd			 
11dd					; pause 1ms 
11dd			 
11dd					ld a, 1 
11dd					call aDelayInMS 
11dd			 
11dd					; dec flash counter 
11dd					ld a, (input_cur_flash) 
11dd					dec a 
11dd					ld (input_cur_flash), a 
11dd					cp 0 
11dd					jr nz, .nochgstate 
11dd			 
11dd			 
11dd					; change state 
11dd					ld a,(input_cur_onoff) 
11dd					neg 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			 
11dd					; reset on change of state 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd			.nochgstate: 
11dd					 
11dd					 
11dd			 
11dd					; display cursor  
11dd			 
11dd			;		ld hl, (input_start) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			 
11dd					; get char under cursor and replace with cursor 
11dd			ld hl, (input_ptr) 
11dd			;		ld a, (hl) 
11dd			;		ld (input_under_cursor),a 
11dd			;		ld a, '_' 
11dd			;		ld (hl), a 
11dd			 
11dd					; display string 
11dd			 
11dd					ld de, (input_start) 
11dd					ld a, (input_at_pos) 
11dd					call str_at_display 
11dd			;	        call update_display 
11dd			 
11dd					; find place to put the cursor 
11dd			;		add h 
11dd			;		ld l, display_row_1 
11dd			;		sub l 
11dd			; (input_at_pos) 
11dd					;ld c, a 
11dd			;		ld a, (input_cursor) 
11dd			;		ld l, (input_at_pos) 
11dd			;		;ld b, h 
11dd			;		add l 
11dd			;		ld (input_at_cursor),a 
11dd					;ld l,h 
11dd			 
11dd			;		ld h, 0 
11dd			;		ld l,(input_at_pos) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11dd			;		call subafromhl 
11dd			;		ld a,l 
11dd			;		ld (input_at_cursor), a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					ld a, (hardware_diag) 
11dd					cp 0 
11dd					jr z, .skip_input_diag 
11dd			 
11dd					ld a,(input_at_pos) 
11dd					ld hl, LFSRSeed 
11dd					call hexout 
11dd					ld a, (input_cursor) 
11dd					ld hl, LFSRSeed+2 
11dd					call hexout 
11dd					ld a,(input_at_cursor) 
11dd					ld hl, LFSRSeed+4 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_onoff) 
11dd					ld hl, LFSRSeed+6 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_flash) 
11dd					ld hl, LFSRSeed+8 
11dd					call hexout 
11dd			 
11dd					ld a,(input_len) 
11dd					ld hl, LFSRSeed+10 
11dd					call hexout 
11dd					ld hl, LFSRSeed+12 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd					ld a, display_row_4 
11dd					ld de, LFSRSeed 
11dd					call str_at_display 
11dd					.skip_input_diag: 
11dd				endif 
11dd			 
11dd					; decide on if we are showing the cursor this time round 
11dd			 
11dd					ld a, (input_cur_onoff) 
11dd					cp 255 
11dd					jr z, .skipcur 
11dd			 
11dd			 
11dd					ld a,(input_at_cursor) 
11dd					ld de, cursor_shape 
11dd					call str_at_display 
11dd			 
11dd					; save length of current input string 
11dd					ld hl, (input_start) 
11dd					ld a, 0 
11dd					call strlent 
11dd					ld a,l 
11dd					ld (input_len),a 
11dd			 
11dd			.skipcur: 
11dd			 
11dd				        call update_display 
11dd					 
11dd			 
11dd			 
11dd					; wait 
11dd				 
11dd					; TODO loop without wait to flash the cursor and char under cursor	 
11dd					call cin    ; _wait 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 
11dd			 
11dd					; get ptr to char to input into 
11dd			 
11dd					ld c,a 
11dd					ld hl, (input_start) 
11dd					ld a, (input_cursor) 
11dd					call addatohl 
11dd					ld (input_ptr), hl 
11dd					ld a,c 
11dd			 
11dd					; replace char under cursor 
11dd			 
11dd			;		ld hl, (input_ptr) 
11dd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11dd			;		ld (hl), a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'i' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					cp KEY_HOME 
11dd					jr nz, .iske 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor),a 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					jp .is1 
11dd					 
11dd			.iske:		cp KEY_END 
11dd					jr nz, .isknw 
11dd					jp .is1 
11dd			 
11dd			.isknw:		cp KEY_NEXTWORD 
11dd					jr nz, .iskpw 
11dd			 
11dd			.isknwm:	ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0 
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd					jr .isknwm 
11dd			 
11dd			.iskpw:		cp KEY_PREVWORD 
11dd					jr nz, .iskl 
11dd			.iskpwm:	 
11dd					ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0  
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd					jr .iskpwm 
11dd			 
11dd			 
11dd			.iskl:		cp KEY_LEFT 
11dd					jr nz, .isk1 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk1:		cp KEY_RIGHT 
11dd					jr nz, .isk2 
11dd			 
11dd					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11dd					ld e,a 
11dd					ld a, (input_cursor) 
11dd					cp e 
11dd					jp z, .is1		; at the end of string so dont go right 
11dd			 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk2:		cp KEY_UP 
11dd			 
11dd					jr nz, .isk3 
11dd			 
11dd					; swap last command with the current on 
11dd			 
11dd					; move cursor to start of string 
11dd					ld hl, (input_start) 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					 
11dd					; swap input and last command buffers 
11dd			 
11dd					ld hl, os_cli_cmd 
11dd					ld de, os_last_cmd 
11dd					ld b, 255 
11dd			.swap1:		ld a, (hl) 
11dd					ld c,a 
11dd					ld a, (de) 
11dd					ld (hl), a 
11dd					ld a,c 
11dd					ld (de),a 
11dd					inc hl 
11dd					inc de 
11dd					djnz .swap1 
11dd			 
11dd			 
11dd			 
11dd			 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk3:		cp KEY_BS 
11dd					jr nz, .isk4 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					; hl is source 
11dd					; de needs to be source - 1 
11dd			 
11dd			;		ld a, 0 
11dd			;		dec hl 
11dd			;		ld (hl), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					; shift all data 
11dd			 
11dd					push hl 
11dd					inc hl 
11dd					pop de 
11dd					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11dd					ld c,a 
11dd					ld b,0 
11dd					ldir  
11dd			 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					; remove char 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld de,.iblank 
11dd					call str_at_display 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk4:		cp KEY_CR 
11dd					jr z, .endinput 
11dd			 
11dd					; else add the key press to the end 
11dd			 
11dd					ld c, a			; save key pressed 
11dd			 
11dd					ld a,(hl)		; get what is currently under char 
11dd			 
11dd					cp 0			; we are at the end of the string 
11dd					jr nz, .onchar 
11dd					 
11dd					; add a char to the end of the string 
11dd				 
11dd					ld (hl),c 
11dd					inc hl 
11dd			;		ld a,' ' 
11dd			;		ld (hl),a 
11dd			;		inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					dec hl 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc a				; TODO check max string length and scroll  
11dd					ld (input_cursor), a		; inc cursor pos 
11dd							 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, '+' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					jp .is1 
11dd					 
11dd			 
11dd			 
11dd					; if on a char then insert 
11dd			.onchar: 
11dd			 
11dd					; TODO over flow check: make sure insert does not blow out buffer 
11dd			 
11dd					; need to do some maths to use lddr 
11dd			 
11dd					push hl   ; save char pos 
11dd					push bc 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a, (input_len) 
11dd					call addatohl  		; end of string 
11dd					inc hl 
11dd					inc hl		; past zero term 
11dd					push hl 
11dd					inc hl 
11dd					push hl  
11dd			 
11dd								; start and end of lddr set, now how much to move? 
11dd			 
11dd							 
11dd					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11dd					ld b,a 
11dd					ld a,(input_len) 
11dd					ld e,a 
11dd					sub b 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd			 
11dd					ld b,0 
11dd					ld c,a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'i' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					pop de 
11dd					pop hl 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'I' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					lddr 
11dd				 
11dd			 
11dd			 
11dd					; TODO have a key for insert/overwrite mode???? 
11dd					pop bc 
11dd					pop hl 
11dd					ld (hl), c		; otherwise overwrite current char 
11dd					 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.endinput:	; TODO look for end of string 
11dd			 
11dd					; add trailing space for end of token 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a,(input_len) 
11dd					call addatohl 
11dd					ld a, ' ' 
11dd					ld (hl),a 
11dd					; TODO eof of parse marker 
11dd			 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					ret 
11dd			 
11dd			.iblank: db " ",0 
11dd			 
11dd			 
11dd			input_str_prev:	ld (input_at_pos), a 
11dd					ld (input_start), hl 
11dd					ld a,1			; add cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					ld (input_ptr), hl 
11dd					ld a,d 
11dd					ld (input_size), a 
11dd					ld a,0 
11dd					ld (input_cursor),a 
11dd			.instr1:	 
11dd			 
11dd					; TODO do block cursor 
11dd					; TODO switch cursor depending on the modifer key 
11dd			 
11dd					; update cursor shape change on key hold 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl), a 
11dd			 
11dd					; display entered text 
11dd					ld a,(input_at_pos) 
11dd			            	CALL fLCD_Pos       ;Position cursor to location in A 
11dd			            	LD   de, (input_start) 
11dd			            	CALL fLCD_Str       ;Display string pointed to by DE 
11dd			 
11dd					call cin 
11dd					cp 0 
11dd					jr z, .instr1 
11dd			 
11dd					; proecess keyboard controls first 
11dd			 
11dd					ld hl,(input_ptr) 
11dd			 
11dd					cp KEY_CR	 ; pressing enter ends input 
11dd					jr z, .instrcr 
11dd			 
11dd					cp KEY_BS 	; back space 
11dd					jr nz, .instr2 
11dd					; process back space 
11dd			 
11dd					; TODO stop back space if at start of string 
11dd					dec hl 
11dd					dec hl ; to over write cursor 
11dd					ld a,(cursor_shape) 
11dd					;ld a,0 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a," " 
11dd					ld (hl),a 
11dd					ld (input_ptr),hl 
11dd					 
11dd			 
11dd					jr .instr1 
11dd			 
11dd			.instr2:	cp KEY_LEFT    ; cursor left 
11dd					jr nz, .instr3 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd				 
11dd			.instr3:	cp KEY_RIGHT      ; cursor right 
11dd					jr nz, .instr4 
11dd					inc hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr4:	cp KEY_HOME    ; jump to start of line 
11dd					jr nz, .instr5 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr5:	cp KEY_END     ; jump to end of line 
11dd					jr nz, .instr6 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			.instr6:        cp KEY_UP      ; recall last command 
11dd					jr nz, .instrnew 
11dd			 
11dd				ld hl, scratch 
11dd				ld de, os_last_cmd 
11dd				call strcpy 
11dd					jr .instr1 
11dd			 
11dd			 
11dd			.instrnew:	; no special key pressed to see if we have room to store it 
11dd			 
11dd					; TODO do string size test 
11dd			 
11dd					dec hl ; to over write cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd					ld (input_ptr),hl 
11dd					 
11dd					jr .instr1 
11dd			.instrcr:	dec hl		; remove cursor 
11dd					ld a,' '	; TODO add a trailing space for safety 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					; if at end of line scroll up    
11dd					; TODO detecting only end of line 4 for scroll up  
11dd			 
11dd					;ld   
11dd			 
11dd					ret 
11dd			 
11dd			 
11dd			endif 
11dd			; strcpy hl = dest, de source 
11dd			 
11dd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11de b7			            OR   A              ;Null terminator? 
11df c8			            RET  Z              ;Yes, so finished 
11e0 1a					ld a,(de) 
11e1 77					ld (hl),a 
11e2 13			            INC  DE             ;Point to next character 
11e3 23					inc hl 
11e4 18 f7		            JR   strcpy       ;Repeat 
11e6 c9					ret 
11e7			 
11e7			 
11e7			; TODO string_at  
11e7			; pass string which starts with lcd offset address and then null term string 
11e7			 
11e7			; TODO string to dec 
11e7			; TODO string to hex 
11e7			; TODO byte to string hex 
11e7			; TODO byte to string dec 
11e7			 
11e7			 
11e7			 
11e7			; from z80uartmonitor 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11e7			; pass hl for where to put the text 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7 c5			hexout:	PUSH BC 
11e8 f5					PUSH AF 
11e9 47					LD B, A 
11ea					; Upper nybble 
11ea cb 3f				SRL A 
11ec cb 3f				SRL A 
11ee cb 3f				SRL A 
11f0 cb 3f				SRL A 
11f2 cd 02 12				CALL tohex 
11f5 77					ld (hl),a 
11f6 23					inc hl	 
11f7					 
11f7					; Lower nybble 
11f7 78					LD A, B 
11f8 e6 0f				AND 0FH 
11fa cd 02 12				CALL tohex 
11fd 77					ld (hl),a 
11fe 23					inc hl	 
11ff					 
11ff f1					POP AF 
1200 c1					POP BC 
1201 c9					RET 
1202					 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			tohex: 
1202 e5					PUSH HL 
1203 d5					PUSH DE 
1204 16 00				LD D, 0 
1206 5f					LD E, A 
1207 21 0f 12				LD HL, .DATA 
120a 19					ADD HL, DE 
120b 7e					LD A, (HL) 
120c d1					POP DE 
120d e1					POP HL 
120e c9					RET 
120f			 
120f			.DATA: 
120f 30					DEFB	30h	; 0 
1210 31					DEFB	31h	; 1 
1211 32					DEFB	32h	; 2 
1212 33					DEFB	33h	; 3 
1213 34					DEFB	34h	; 4 
1214 35					DEFB	35h	; 5 
1215 36					DEFB	36h	; 6 
1216 37					DEFB	37h	; 7 
1217 38					DEFB	38h	; 8 
1218 39					DEFB	39h	; 9 
1219 41					DEFB	41h	; A 
121a 42					DEFB	42h	; B 
121b 43					DEFB	43h	; C 
121c 44					DEFB	44h	; D 
121d 45					DEFB	45h	; E 
121e 46					DEFB	46h	; F 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
121f			;;    subtract $30, if result > 9 then subtract $7 more 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			atohex: 
121f d6 30				SUB $30 
1221 fe 0a				CP 10 
1223 f8					RET M		; If result negative it was 0-9 so we're done 
1224 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1226 c9					RET		 
1227			 
1227			 
1227			 
1227			 
1227			; Get 2 ASCII characters as hex byte from pointer in hl 
1227			 
1227			BYTERD: 
1227 16 00			LD	D,00h		;Set up 
1229 cd 31 12			CALL	HEXCON		;Get byte and convert to hex 
122c 87				ADD	A,A		;First nibble so 
122d 87				ADD	A,A		;multiply by 16 
122e 87				ADD	A,A		; 
122f 87				ADD	A,A		; 
1230 57				LD	D,A		;Save hi nibble in D 
1231			HEXCON: 
1231 7e				ld a, (hl)		;Get next chr 
1232 23				inc hl 
1233 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1235 fe 0a			CP	00Ah		;Is it 0-9 ? 
1237 38 02			JR	C,NALPHA	;If so miss next bit 
1239 d6 07			SUB	007h		;Else convert alpha 
123b			NALPHA: 
123b b2				OR	D		;Add hi nibble back 
123c c9				RET			; 
123d			 
123d			 
123d			; 
123d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
123d			; Since the routines get_byte and therefore get_nibble are called, only valid 
123d			; characters (0-9a-f) are accepted. 
123d			; 
123d			;get_word        push    af 
123d			;                call    get_byte        ; Get the upper byte 
123d			;                ld      h, a 
123d			;                call    get_byte        ; Get the lower byte 
123d			;                ld      l, a 
123d			;                pop     af 
123d			;                ret 
123d			; 
123d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
123d			; the routine get_nibble is used only valid characters are accepted - the  
123d			; input routine only accepts characters 0-9a-f. 
123d			; 
123d c5			get_byte:        push    bc              ; Save contents of B (and C) 
123e 7e					ld a,(hl) 
123f 23					inc hl 
1240 cd 65 12		                call    nibble2val      ; Get upper nibble 
1243 cb 07		                rlc     a 
1245 cb 07		                rlc     a 
1247 cb 07		                rlc     a 
1249 cb 07		                rlc     a 
124b 47			                ld      b, a            ; Save upper four bits 
124c 7e					ld a,(hl) 
124d cd 65 12		                call    nibble2val      ; Get lower nibble 
1250 b0			                or      b               ; Combine both nibbles 
1251 c1			                pop     bc              ; Restore B (and C) 
1252 c9			                ret 
1253			; 
1253			; Get a hexadecimal digit from the serial line. This routine blocks until 
1253			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1253			; to the serial line interface. The lower 4 bits of A contain the value of  
1253			; that particular digit. 
1253			; 
1253			;get_nibble      ld a,(hl)           ; Read a character 
1253			;                call    to_upper        ; Convert to upper case 
1253			;                call    is_hex          ; Was it a hex digit? 
1253			;                jr      nc, get_nibble  ; No, get another character 
1253			 ;               call    nibble2val      ; Convert nibble to value 
1253			 ;               call    print_nibble 
1253			 ;               ret 
1253			; 
1253			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1253			; A valid hexadecimal digit is denoted by a set C flag. 
1253			; 
1253			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1253			;                ret     nc              ; Yes 
1253			;                cp      '0'             ; Less than '0'? 
1253			;                jr      nc, is_hex_1    ; No, continue 
1253			;                ccf                     ; Complement carry (i.e. clear it) 
1253			;                ret 
1253			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1253			;                ret     c               ; Yes 
1253			;                cp      'A'             ; Less than 'A'? 
1253			;                jr      nc, is_hex_2    ; No, continue 
1253			;                ccf                     ; Yes - clear carry and return 
1253			;                ret 
1253			;is_hex_2        scf                     ; Set carry 
1253			;                ret 
1253			; 
1253			; Convert a single character contained in A to upper case: 
1253			; 
1253 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1255 d8			                ret     c 
1256 fe 7b		                cp      'z' + 1         ; > 'z'? 
1258 d0			                ret     nc              ; Nothing to do, either 
1259 e6 5f		                and     $5f             ; Convert to upper case 
125b c9			                ret 
125c			 
125c			 
125c			to_lower: 
125c			 
125c			   ; if char is in [A-Z] make it lower case 
125c			 
125c			   ; enter : a = char 
125c			   ; exit  : a = lower case char 
125c			   ; uses  : af 
125c			 
125c fe 41		   cp 'A' 
125e d8			   ret c 
125f			    
125f fe 5b		   cp 'Z'+1 
1261 d0			   ret nc 
1262			    
1262 f6 20		   or $20 
1264 c9			   ret 
1265			 
1265			; 
1265			; Expects a hexadecimal digit (upper case!) in A and returns the 
1265			; corresponding value in A. 
1265			; 
1265 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1267 38 02		                jr      c, nibble2val_1 ; Yes 
1269 d6 07		                sub     7               ; Adjust for A-F 
126b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
126d e6 0f		                and     $f              ; Only return lower 4 bits 
126f c9			                ret 
1270			; 
1270			; Print_nibble prints a single hex nibble which is contained in the lower  
1270			; four bits of A: 
1270			; 
1270			;print_nibble    push    af              ; We won't destroy the contents of A 
1270			;                and     $f              ; Just in case... 
1270			;                add     a, '0'             ; If we have a digit we are done here. 
1270			;                cp      '9' + 1         ; Is the result > 9? 
1270			;                jr      c, print_nibble_1 
1270			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1270			;print_nibble_1  call    putc            ; Print the nibble and 
1270			;                pop     af              ; restore the original value of A 
1270			;                ret 
1270			;; 
1270			;; Send a CR/LF pair: 
1270			; 
1270			;crlf            push    af 
1270			;                ld      a, cr 
1270			;                call    putc 
1270			;                ld      a, lf 
1270			;                call    putc 
1270			;                pop     af 
1270			;                ret 
1270			; 
1270			; Print_word prints the four hex digits of a word to the serial line. The  
1270			; word is expected to be in HL. 
1270			; 
1270			;print_word      push    hl 
1270			;                push    af 
1270			;                ld      a, h 
1270			;                call    print_byte 
1270			;                ld      a, l 
1270			;                call    print_byte 
1270			;                pop     af 
1270			;                pop     hl 
1270			;                ret 
1270			; 
1270			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1270			; The byte to be printed is expected to be in A. 
1270			; 
1270			;print_byte      push    af              ; Save the contents of the registers 
1270			;                push    bc 
1270			;                ld      b, a 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                call    print_nibble    ; Print high nibble 
1270			;                ld      a, b 
1270			;                call    print_nibble    ; Print low nibble 
1270			;                pop     bc              ; Restore original register contents 
1270			;                pop     af 
1270			;                ret 
1270			 
1270			 
1270			 
1270			 
1270			 
1270			fourehexhl:  
1270 7e				ld a,(hl) 
1271 cd 1f 12			call atohex 
1274 cb 3f				SRL A 
1276 cb 3f				SRL A 
1278 cb 3f				SRL A 
127a cb 3f				SRL A 
127c 47				ld b, a 
127d 23				inc hl 
127e 7e				ld a,(hl) 
127f 23				inc hl 
1280 cd 1f 12			call atohex 
1283 80				add b 
1284 57				ld d,a 
1285 7e				ld a,(hl) 
1286 cd 1f 12			call atohex 
1289 cb 3f				SRL A 
128b cb 3f				SRL A 
128d cb 3f				SRL A 
128f cb 3f				SRL A 
1291 47				ld b, a 
1292 23				inc hl 
1293 7e				ld a,(hl) 
1294 23				inc hl 
1295 cd 1f 12			call atohex 
1298 80				add b 
1299 5f				ld e, a 
129a d5				push de 
129b e1				pop hl 
129c c9				ret 
129d			 
129d			; pass hl. returns z set if the byte at hl is a digit 
129d			;isdigithl:  
129d			;	push bc 
129d			;	ld a,(hl) 
129d			;	cp ':' 
129d			;	jr nc, .isdf 		; > 
129d			;	cp '0' 
129d			;	jr c, .isdf		; < 
129d			; 
129d			;	; TODO find a better way to set z 
129d			; 
129d			;	ld b,a 
129d			;	cp b 
129d			;	pop bc 
129d			;	ret 
129d			; 
129d			;.isdf:	; not digit so clear z 
129d			; 
129d			;	; TODO find a better way to unset z 
129d			; 
129d			;	ld b,a 
129d			;	inc b 
129d			;	cp b 
129d			; 
129d			;	pop bc 
129d			;	ret 
129d				 
129d				 
129d			 
129d			 
129d			; pass hl as the four byte address to load 
129d			 
129d			get_word_hl:  
129d e5				push hl 
129e cd 3d 12			call get_byte 
12a1				 
12a1 47				ld b, a 
12a2			 
12a2 e1				pop hl 
12a3 23				inc hl 
12a4 23				inc hl 
12a5			 
12a5			; TODO not able to handle a-f  
12a5 7e				ld a,(hl) 
12a6			;	;cp ':' 
12a6			;	cp 'g' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp 'G' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp '0' 
12a6			;	jr c, .single_byte_hl		; < 
12a6			 
12a6				;call isdigithl 
12a6 fe 00			cp 0 
12a8 28 06			jr z, .single_byte_hl 
12aa			 
12aa			.getwhln:   ; hex word so get next byte 
12aa			 
12aa cd 3d 12			call get_byte 
12ad 6f				ld l, a 
12ae 60				ld h,b 
12af c9				ret 
12b0 68			.single_byte_hl:   ld l,b 
12b1 26 00				ld h,0 
12b3 c9					ret 
12b4			 
12b4			 
12b4			 
12b4			 
12b4 21 93 1c			ld hl,asc+1 
12b7			;	ld a, (hl) 
12b7			;	call nibble2val 
12b7 cd 3d 12			call get_byte 
12ba			 
12ba			;	call fourehexhl 
12ba 32 27 f1			ld (scratch+52),a 
12bd				 
12bd 21 25 f1			ld hl,scratch+50 
12c0 22 16 f4			ld (os_cur_ptr),hl 
12c3			 
12c3 c9				ret 
12c4			 
12c4			 
12c4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12c4			 
12c4			; Decimal Unsigned Version 
12c4			 
12c4			;Number in a to decimal ASCII 
12c4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12c4			;Example: display a=56 as "056" 
12c4			;input: a = number 
12c4			;Output: a=0,value of a in the screen 
12c4			;destroys af,bc (don't know about hl and de) 
12c4			DispAToASCII: 
12c4 0e 9c			ld	c,-100 
12c6 cd d0 12			call	.Na1 
12c9 0e f6			ld	c,-10 
12cb cd d0 12			call	.Na1 
12ce 0e ff			ld	c,-1 
12d0 06 2f		.Na1:	ld	b,'0'-1 
12d2 04			.Na2:	inc	b 
12d3 81				add	a,c 
12d4 38 fc			jr	c,.Na2 
12d6 91				sub	c		;works as add 100/10/1 
12d7 f5				push af		;safer than ld c,a 
12d8 78				ld	a,b		;char is in b 
12d9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12d9 f1				pop af		;safer than ld a,c 
12da c9				ret 
12db			 
12db			; Decimal Signed Version 
12db			 
12db			; DispA 
12db			; -------------------------------------------------------------- 
12db			; Converts a signed integer value to a zero-terminated ASCII 
12db			; string representative of that value (using radix 10). 
12db			; -------------------------------------------------------------- 
12db			; INPUTS: 
12db			;     HL     Value to convert (two's complement integer). 
12db			;     DE     Base address of string destination. (pointer). 
12db			; -------------------------------------------------------------- 
12db			; OUTPUTS: 
12db			;     None 
12db			; -------------------------------------------------------------- 
12db			; REGISTERS/MEMORY DESTROYED 
12db			; AF HL 
12db			; -------------------------------------------------------------- 
12db			 
12db			;DispHLToASCII: 
12db			;   push    de 
12db			;   push    bc 
12db			; 
12db			;; Detect sign of HL. 
12db			;    bit    7, h 
12db			;    jr     z, ._DoConvert 
12db			; 
12db			;; HL is negative. Output '-' to string and negate HL. 
12db			;    ld     a, '-' 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			; 
12db			;; Negate HL (using two's complement) 
12db			;    xor    a 
12db			;    sub    l 
12db			;    ld     l, a 
12db			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12db			;    sbc    a, h 
12db			;    ld     h, a 
12db			; 
12db			;; Convert HL to digit characters 
12db			;._DoConvert: 
12db			;    ld     b, 0     ; B will count character length of number 
12db			;-   ld     a, 10 
12db			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12db			;    push   af 
12db			;    inc    b 
12db			;    ld     a, h 
12db			;    or     l 
12db			;    jr     nz, - 
12db			; 
12db			;; Retrieve digits from stack 
12db			;-   pop    af 
12db			;    or     $30 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			;    djnz   - 
12db			; 
12db			;; Terminate string with NULL 
12db			;    xor    a 
12db			;    ld     (de), a 
12db			; 
12db			;    pop    bc 
12db			;    pop    de 
12db			;    ret 
12db			 
12db			;Comments 
12db			; 
12db			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12db			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12db			;    Note that the output string will not be fixed-width. 
12db			; 
12db			;Example Usage 
12db			; 
12db			;    ld    hl, -1004 
12db			;    ld    de, OP1 
12db			;    call  DispA 
12db			;    ld    hl, OP1 
12db			;    syscall  PutS 
12db			 
12db			 
12db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12db			 
12db			 
12db			;Converts an ASCII string to an unsigned 16-bit integer 
12db			;Quits when it reaches a non-decimal digit 
12db			 
12db			string_to_uint16: 
12db			atoui_16: 
12db			;Input: 
12db			;     DE points to the string 
12db			;Outputs: 
12db			;     HL is the result 
12db			;     A is the 8-bit value of the number 
12db			;     DE points to the byte after the number 
12db			;Destroys: 
12db			;     BC 
12db			;       if the string is non-empty, BC is HL/10 
12db			;Size:  24 bytes 
12db			;Speed: 42+d(104+{0,9}) 
12db			;       d is the number of digits in the number 
12db			;       max is 640 cycles for a 5 digit number 
12db			;Assuming no leading zeros: 
12db			;1 digit:  146cc 
12db			;2 digit:  250cc 
12db			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12db			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12db			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12db			;avg: 544.81158447265625cc (544+13297/16384) 
12db			;=============================================================== 
12db 21 00 00		  ld hl,0 
12de			.u16a: 
12de 1a			  ld a,(de) 
12df d6 30		  sub 30h 
12e1 fe 0a		  cp 10 
12e3 d0			  ret nc 
12e4 13			  inc de 
12e5 44			  ld b,h 
12e6 4d			  ld c,l 
12e7 29			  add hl,hl 
12e8 29			  add hl,hl 
12e9 09			  add hl,bc 
12ea 29			  add hl,hl 
12eb 85			  add a,l 
12ec 6f			  ld l,a 
12ed 30 ef		  jr nc,.u16a 
12ef 24			  inc h 
12f0 c3 de 12		  jp .u16a 
12f3			 
12f3			 
12f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f3			 
12f3			;written by Zeda 
12f3			;Converts a 16-bit unsigned integer to an ASCII string. 
12f3			 
12f3			uitoa_16: 
12f3			;Input: 
12f3			;   DE is the number to convert 
12f3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12f3			;Output: 
12f3			;   HL points to the null-terminated ASCII string 
12f3			;      NOTE: This isn't necessarily the same as the input HL. 
12f3 d5			  push de 
12f4 c5			  push bc 
12f5 f5			  push af 
12f6 eb			  ex de,hl 
12f7			 
12f7 01 f0 d8		  ld bc,-10000 
12fa 3e 2f		  ld a,'0'-1 
12fc 3c			  inc a 
12fd 09			  add hl,bc  
12fe 38 fc		   jr c,$-2 
1300 12			  ld (de),a 
1301 13			  inc de 
1302			 
1302 01 e8 03		  ld bc,1000 
1305 3e 3a		  ld a,'9'+1 
1307 3d			  dec a  
1308 09			  add hl,bc  
1309 30 fc		   jr nc,$-2 
130b 12			  ld (de),a 
130c 13			  inc de 
130d			 
130d 01 9c ff		  ld bc,-100 
1310 3e 2f		  ld a,'0'-1 
1312 3c			  inc a  
1313 09			  add hl,bc  
1314 38 fc		   jr c,$-2 
1316 12			  ld (de),a 
1317 13			  inc de 
1318			 
1318 7d			  ld a,l 
1319 26 3a		  ld h,'9'+1 
131b 25			  dec h  
131c c6 0a		  add a,10  
131e 30 fb		   jr nc,$-3 
1320 c6 30		  add a,'0' 
1322 eb			  ex de,hl 
1323 72			  ld (hl),d 
1324 23			  inc hl 
1325 77			  ld (hl),a 
1326 23			  inc hl 
1327 36 00		  ld (hl),0 
1329			 
1329			;Now strip the leading zeros 
1329 0e fa		  ld c,-6 
132b 09			  add hl,bc 
132c 3e 30		  ld a,'0' 
132e 23			  inc hl  
132f be			  cp (hl)  
1330 28 fc		  jr z,$-2 
1332			 
1332			;Make sure that the string is non-empty! 
1332 7e			  ld a,(hl) 
1333 b7			  or a 
1334 20 01		  jr nz,.atoub 
1336 2b			  dec hl 
1337			.atoub: 
1337			 
1337 f1			  pop af 
1338 c1			  pop bc 
1339 d1			  pop de 
133a c9			  ret 
133b			 
133b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
133b			 
133b			toUpper: 
133b			;A is the char. 
133b			;If A is a lowercase letter, this sets it to the matching uppercase 
133b			;18cc or 30cc or 41cc 
133b			;avg: 26.75cc 
133b fe 61		  cp 'a' 
133d d8			  ret c 
133e fe 7b		  cp 'z'+1 
1340 d0			  ret nc 
1341 d6 20		  sub 'a'-'A' 
1343 c9			  ret 
1344			 
1344			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1344			 
1344			; String Length 
1344			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1344			 
1344			; Get the length of the null-terminated string starting at $8000 hl 
1344			;    LD     HL, $8000 
1344			 
1344			strlenz: 
1344			 
1344 af			    XOR    A               ; Zero is the value we are looking for. 
1345 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1346 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1347			                           ; 65, 536 bytes (the entire addressable memory space). 
1347 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1349			 
1349			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1349 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
134a 6f			    LD     L, A             ; number of bytes 
134b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134d 2b			    DEC    HL              ; Compensate for null. 
134e c9				ret 
134f			 
134f			; Get the length of the A terminated string starting at $8000 hl 
134f			;    LD     HL, $8000 
134f			 
134f			strlent: 
134f			 
134f			                  ; A is the value we are looking for. 
134f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1351 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1353			                           ; 65, 536 bytes (the entire addressable memory space). 
1353 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1355			 
1355			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1355 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1357 2e 00		    LD     L, 0             ; number of bytes 
1359 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
135b 2b			    DEC    HL              ; Compensate for null. 
135c c9				ret 
135d			 
135d			 
135d			;Comparing Strings 
135d			 
135d			;IN    HL     Address of string1. 
135d			;      DE     Address of string2. 
135d			 
135d			; doc given but wrong??? 
135d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
135d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
135d			; tested 
135d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
135d			 
135d			strcmp_old: 
135d e5			    PUSH   HL 
135e d5			    PUSH   DE 
135f			 
135f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1360 be			    CP     (HL)            ; (want to minimize work). 
1361 38 01		    JR     C, Str1IsBigger 
1363 7e			    LD     A, (HL) 
1364			 
1364			Str1IsBigger: 
1364 4f			    LD     C, A             ; Put length in BC 
1365 06 00		    LD     B, 0 
1367 13			    INC    DE              ; Increment pointers to meat of string. 
1368 23			    INC    HL 
1369			 
1369			CmpLoop: 
1369 1a			    LD     A, (DE)          ; Compare bytes. 
136a ed a1		    CPI 
136c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
136e 13			    INC    DE              ; Update pointer. 
136f ea 69 13		    JP     PE, CmpLoop 
1372			 
1372 d1			    POP    DE 
1373 e1			    POP    HL 
1374 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1375 be			    CP     (HL) 
1376 c9			    RET 
1377			 
1377			NoMatch: 
1377 2b			    DEC    HL 
1378 be			    CP     (HL)            ; Compare again to affect carry. 
1379 d1			    POP    DE 
137a e1			    POP    HL 
137b c9			    RET 
137c			 
137c			;; test strmp 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr z, .z1 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z1: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr z, .z2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr c, .c1 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c1: 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr c, .c2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;	NEXTW 
137c			;.str1:   db "string1",0 
137c			;.str2:   db "string2",0 
137c			 
137c			; only care about direct match or not 
137c			; hl and de strings 
137c			; zero set if the same 
137c			 
137c			strcmp: 
137c 1a				ld a, (de) 
137d be				cp (hl) 
137e 28 02			jr z, .ssame 
1380 b7				or a 
1381 c9				ret 
1382			 
1382			.ssame:  
1382 fe 00			cp 0 
1384 c8				ret z 
1385			 
1385 23				inc hl 
1386 13				inc de 
1387 18 f3			jr strcmp 
1389				 
1389				 
1389			 
1389			;Copyright (c) 2014, Luke Maurits 
1389			;All rights reserved. 
1389			; 
1389			;Redistribution and use in source and binary forms, with or without 
1389			;modification, are permitted provided that the following conditions are met: 
1389			; 
1389			;* Redistributions of source code must retain the above copyright notice, this 
1389			;  list of conditions and the following disclaimer. 
1389			; 
1389			;* Redistributions in binary form must reproduce the above copyright notice, 
1389			;  this list of conditions and the following disclaimer in the documentation 
1389			;  and/or other materials provided with the distribution. 
1389			; 
1389			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1389			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1389			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1389			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1389			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1389			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1389			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1389			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1389			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1389			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1389			 
1389			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1389			 
1389			StrictStrCmp: 
1389				; Load next chars of each string 
1389 1a				ld a, (de) 
138a 47				ld b, a 
138b 7e				ld a, (hl) 
138c				; Compare 
138c b8				cp b 
138d				; Return non-zero if chars don't match 
138d c0				ret nz 
138e				; Check for end of both strings 
138e fe 00			cp "\0" 
1390				; Return if strings have ended 
1390 c8				ret z 
1391				; Otherwise, advance to next chars 
1391 23				inc hl 
1392 13				inc de 
1393 18 f4			jr StrictStrCmp 
1395			 
1395			;end 
1395			; eof 
1395			 
1395			 
1395			 
1395			 
1395			 
1395			 
# End of file firmware_strings.asm
1395			include "firmware_memory.asm"   ; malloc and free  
1395			 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			.mallocsize: db "Wants malloc >256",0 
1395			.mallocasize: db "MALLOC gives >256",0 
1395			.malloczero: db "MALLOC gives zero",0 
1395			 
1395			malloc_guard_zerolen: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395				ld de, 0 
1395			        call cmp16 
1395				jr nz, .lowalloz 
1395			 
1395				push hl 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .malloczero 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395				call bp_on 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395			.lowalloz: 
1395			 
1395			 
1395				pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_entry: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowalloc 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocsize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395				jr .lowdone 
1395			.lowalloc: 
1395			 
1395			 
1395				pop hl 
1395			.lowdone:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_exit: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowallocx 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocasize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395				pop de 
1395				pop hl 
1395			 
1395				CALLMONITOR 
1395				jr .lowdonex 
1395			.lowallocx: 
1395			 
1395				pop hl 
1395			.lowdonex:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			endif 
1395			 
1395			if MALLOC_2 
1395			; Z80 Malloc and Free Functions 
1395			 
1395			; Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc: 
1395				 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_entry 
1395			endif 
1395			 
1395			 
1395			 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "mal" 
1395						CALLMONITOR 
1395					endif 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of size into A 
1395			    or h               ; Check if size is zero 
1395			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1395			 
1395			    ; Allocate memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma1" 
1395						CALLMONITOR 
1395					endif 
1395			    call malloc_internal ; Call internal malloc function 
1395			    pop af             ; Restore AF register 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret                ; Return 
1395			 
1395			; Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free: 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of pointer into A 
1395			    or h               ; Check if pointer is NULL 
1395			    jp z, free_exit    ; If pointer is NULL, exit 
1395			 
1395			    ; Free memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395			    call free_internal  ; Call internal free function 
1395			    pop af             ; Restore AF register 
1395			    ret                ; Return 
1395			 
1395			; Internal Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc_internal: 
1395			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to requested size 
1395			    ex de, hl          ; Save total size in DE, and keep it in HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			 
1395			    ; Search for free memory block 
1395			    ld de, (heap_end)  ; Load end of heap into DE 
1395			    ld bc, 0           ; Initialize counter 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			malloc_search_loop: 
1395			    ; Check if current block is free 
1395			    ld a, (hl)         ; Load current block's status (free or used) 
1395			    cp 0               ; Compare with zero (free) 
1395			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1395			 
1395			    ; Check if current block is large enough 
1395			    ld a, (hl+1)       ; Load high byte of block size 
1395			    cp l               ; Compare with low byte of requested size 
1395			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1395			 
1395			    ld a, (hl+2)       ; Load low byte of block size 
1395			    cp h               ; Compare with high byte of requested size 
1395			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1395			 
1395			    ; Mark block as used 
1395			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1395			 
1395			    ; Calculate remaining space in block 
1395			    ld bc, 0           ; Clear BC 
1395			    add hl, bc         ; Increment HL to point to start of data block 
1395			    add hl, de         ; HL = HL + DE (total size) 
1395			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to start of data block 
1395			 
1395			    ; Save pointer to allocated block in HL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma5" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			malloc_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3           ; Size of management overhead 
1395			    add hl, bc         ; Move to the next block 
1395			    inc de             ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e            ; Load low byte of heap end address 
1395			    cp (hl)            ; Compare with low byte of current address 
1395			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1395			    ld a, d            ; Load high byte of heap end address 
1395			    cp 0               ; Check if it's zero (end of memory) 
1395			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, allocation failed 
1395			    xor a              ; Set result to NULL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma6" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			malloc_exit: 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma7" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			; Internal Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free_internal: 
1395			    ld de, (heap_start) ; Load start of heap into DE 
1395			    ld bc, 0            ; Initialize counter 
1395			 
1395			free_search_loop: 
1395			    ; Check if current block contains the pointer 
1395			    ld a, l             ; Load low byte of pointer 
1395			    cp (hl+1)           ; Compare with high byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			    ld a, h             ; Load high byte of pointer 
1395			    cp (hl+2)           ; Compare with low byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			 
1395			    ; Mark block as free 
1395			    ld (hl), 0          ; Set status byte to indicate free block 
1395			    ret                 ; Return 
1395			 
1395			free_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3            ; Size of management overhead 
1395			    add hl, bc          ; Move to the next block 
1395			    inc de              ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e             ; Load low byte of heap end address 
1395			    cp (hl)             ; Compare with low byte of current address 
1395			    jr nz, free_search_loop  ; If not equal, continue searching 
1395			    ld a, d             ; Load high byte of heap end address 
1395			    cp 0                ; Check if it's zero (end of memory) 
1395			    jr nz, free_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, pointer is not found in heap 
1395			    ret 
1395			 
1395			free_exit: 
1395			    ret                 ; Return 
1395			 
1395			; Define heap start and end addresses 
1395			;heap_start:    .dw 0xC000   ; Start of heap 
1395			;heap_end:      .dw 0xE000   ; End of heap 
1395			 
1395			endif 
1395			 
1395			 
1395			if MALLOC_1 
1395			 
1395			 
1395			 
1395			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1395			 
1395			;moved to firmware.asm 
1395			;heap_start        .equ  0x9000      ; Starting address of heap 
1395			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1395			 
1395			;      .org 0 
1395			;      jp    main 
1395			 
1395			 
1395			;      .org  0x100 
1395			;main: 
1395			;      ld    HL, 0x8100 
1395			;      ld    SP, HL 
1395			; 
1395			;      call  heap_init 
1395			; 
1395			;      ; Make some allocations 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9004 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9014 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9024 
1395			; 
1395			;      ; Free some allocations 
1395			;      ld    HL, 0x9014 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9004 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9024 
1395			;      call  free 
1395			; 
1395			; 
1395			;      halt 
1395			 
1395			 
1395			;------------------------------------------------------------------------------ 
1395			;     heap_init                                                               : 
1395			;                                                                             : 
1395			; Description                                                                 : 
1395			;     Initialise the heap and make it ready for malloc and free operations.   : 
1395			;                                                                             : 
1395			;     The heap is maintained as a linked list, starting with an initial       : 
1395			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1395			;     the first free block in the heap. Each block then points to the next    : 
1395			;     free block within the heap, and the free list ends at the first block   : 
1395			;     with a null pointer to the next free block.                             : 
1395			;                                                                             : 
1395			; Parameters                                                                  : 
1395			;     Inputs are compile-time only. Two defines which specify the starting    : 
1395			;     address of the heap and its size are required, along with a memory      : 
1395			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1395			;     principally stores a pointer to the first free block in the heap.       : 
1395			;                                                                             : 
1395			; Returns                                                                     : 
1395			;     Nothing                                                                 : 
1395			;------------------------------------------------------------------------------ 
1395			heap_init: 
1395 e5			      push  HL 
1396			 
1396			      ; Initialise free list struct 
1396 21 0e 80		      ld    HL, heap_start 
1399 22 0a 80		      ld    (free_list), HL 
139c 21 00 00		      ld    HL, 0 
139f 22 0c 80		      ld    (free_list+2), HL 
13a2			 
13a2			      ; Insert first free block at bottom of heap, consumes entire heap 
13a2 21 ca f0		      ld    HL, heap_start+heap_size-4 
13a5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13a8 21 bc 70		      ld    HL, heap_size-4 
13ab 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ae			 
13ae			      ; Insert end of free list block at top of heap - two null words will 
13ae			      ; terminate the free list 
13ae 21 00 00		      ld    HL, 0 
13b1 22 cc f0		      ld    (heap_start+heap_size-2), HL 
13b4 22 ca f0		      ld    (heap_start+heap_size-4), HL 
13b7			 
13b7 e1			      pop   HL 
13b8			 
13b8 c9			      ret 
13b9			 
13b9			 
13b9			;------------------------------------------------------------------------------ 
13b9			;     malloc                                                                  : 
13b9			;                                                                             : 
13b9			; Description                                                                 : 
13b9			;     Allocates the wanted space from the heap and returns the address of the : 
13b9			;     first useable byte of the allocation.                                   : 
13b9			;                                                                             : 
13b9			;     Allocations can happen in one of two ways:                              : 
13b9			;                                                                             : 
13b9			;     1. A free block may be found which is the exact size wanted. In this    : 
13b9			;        case the block is removed from the free list and retuedn to the      : 
13b9			;        caller.                                                              : 
13b9			;     2. A free block may be found which is larger than the size wanted. In   : 
13b9			;        this case, the larger block is split into two. The first portion of  : 
13b9			;        this block will become the requested space by the malloc call and    : 
13b9			;        is returned to the caller. The second portion becomes a new free     : 
13b9			;        block, and the free list is adjusted to maintain continuity via this : 
13b9			;        newly created block.                                                 : 
13b9			;                                                                             : 
13b9			;     malloc does not set any initial value in the allocated space, the       : 
13b9			;     caller is required to do this as required.                              : 
13b9			;                                                                             : 
13b9			;     This implementation of malloc uses the stack exclusively, and is        : 
13b9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13b9			;     advisable to disable interrupts before calling malloc, and recommended  : 
13b9			;     to avoid the use of malloc inside ISRs in general.                      : 
13b9			;                                                                             : 
13b9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13b9			;                                                                             : 
13b9			; Parameters                                                                  : 
13b9			;     HL  Number of bytes wanted                                              : 
13b9			;                                                                             : 
13b9			; Returns                                                                     : 
13b9			;     HL  Address of the first useable byte of the allocation                 : 
13b9			;                                                                             : 
13b9			; Flags                                                                       : 
13b9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13b9			;                                                                             : 
13b9			; Stack frame                                                                 : 
13b9			;       |             |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     BC      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     DE      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     IX      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |  prev_free  |                                                       : 
13b9			;   +4  +-------------+                                                       : 
13b9			;       |  this_free  |                                                       : 
13b9			;   +2  +-------------+                                                       : 
13b9			;       |  next_free  |                                                       : 
13b9			;   +0  +-------------+                                                       : 
13b9			;       |             |                                                       : 
13b9			;                                                                             : 
13b9			;------------------------------------------------------------------------------ 
13b9			 
13b9			 
13b9			;malloc: 
13b9			; 
13b9			;	SAVESP ON 1 
13b9			; 
13b9			;	call malloc_code 
13b9			; 
13b9			;	CHECKSP ON 1 
13b9			;	ret 
13b9			 
13b9			 
13b9			malloc: 
13b9 c5			      push  BC 
13ba d5			      push  DE 
13bb dd e5		      push  IX 
13bd			if DEBUG_FORTH_MALLOC_HIGH 
13bd			call malloc_guard_entry 
13bd			endif 
13bd			 
13bd					if DEBUG_FORTH_MALLOC 
13bd						DMARK "mal" 
13bd						CALLMONITOR 
13bd					endif 
13bd 7c			      ld    A, H                    ; Exit if no space requested 
13be b5			      or    L 
13bf ca 7e 14		      jp    Z, malloc_early_exit 
13c2			 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			; 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			 
13c2			 
13c2			 
13c2			 
13c2					if DEBUG_FORTH_MALLOC 
13c2						DMARK "maA" 
13c2						CALLMONITOR 
13c2					endif 
13c2			      ; Set up stack frame 
13c2 eb			      ex    DE, HL 
13c3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13c6 39			      add   HL, SP 
13c7 f9			      ld    SP, HL 
13c8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13cc dd 39		      add   IX, SP 
13ce			 
13ce			      ; Setup initial state 
13ce 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13d1 19			      add   HL, DE 
13d2			 
13d2 44			      ld    B, H                    ; Move want to BC 
13d3 4d			      ld    C, L 
13d4			 
13d4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13d7 dd 75 04		      ld    (IX+4), L 
13da dd 74 05		      ld    (IX+5), H 
13dd			 
13dd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13de 23			      inc   HL 
13df 56			      ld    D, (HL) 
13e0 dd 73 02		      ld    (IX+2), E 
13e3 dd 72 03		      ld    (IX+3), D 
13e6 eb			      ex    DE, HL                  ; this_free ptr into HL 
13e7			 
13e7					if DEBUG_FORTH_MALLOC 
13e7						DMARK "maB" 
13e7						CALLMONITOR 
13e7					endif 
13e7			      ; Loop through free block list to find some space 
13e7			malloc_find_space: 
13e7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13e8 23			      inc   HL 
13e9 56			      ld    D, (HL) 
13ea			 
13ea 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13eb b3			      or    E 
13ec ca 78 14		      jp    Z, malloc_no_space 
13ef			 
13ef dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13f2 dd 72 01		      ld    (IX+1), D 
13f5			 
13f5			      ; Does this block have enough space to make the allocation? 
13f5 23			      inc   HL                      ; Load free block size into DE 
13f6 5e			      ld    E, (HL) 
13f7 23			      inc   HL 
13f8 56			      ld    D, (HL) 
13f9			 
13f9 eb			      ex    DE, HL                  ; Check size of block against want 
13fa b7			      or    A                       ; Ensure carry flag clear 
13fb ed 42		      sbc   HL, BC 
13fd e5			      push  HL                      ; Store the result for later (new block size) 
13fe			 
13fe ca 4d 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1401 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1403			 
1403			      ; this_free block is not big enough, setup ptrs to test next free block 
1403 e1			      pop   HL                      ; Discard previous result 
1404			 
1404 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1407 dd 66 03		      ld    H, (IX+3) 
140a dd 75 04		      ld    (IX+4), L 
140d dd 74 05		      ld    (IX+5), H 
1410			 
1410 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1413 dd 66 01		      ld    H, (IX+1) 
1416 dd 75 02		      ld    (IX+2), L 
1419 dd 74 03		      ld    (IX+3), H 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "MA>" 
141c						CALLMONITOR 
141c					endif 
141c 18 c9		      jr    malloc_find_space 
141e			 
141e			      ; split a bigger block into two - requested size and remaining size 
141e			malloc_alloc_split: 
141e					if DEBUG_FORTH_MALLOC 
141e						DMARK "MAs" 
141e						CALLMONITOR 
141e					endif 
141e eb			      ex    DE, HL                  ; Calculate address of new free block 
141f 2b			      dec   HL 
1420 2b			      dec   HL 
1421 2b			      dec   HL 
1422 09			      add   HL, BC 
1423			 
1423			      ; Create a new block and point it at next_free 
1423 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1426 dd 56 01		      ld    D, (IX+1) 
1429			 
1429 73			      ld    (HL), E                 ; Store next_free ptr into new block 
142a 23			      inc   HL 
142b 72			      ld    (HL), D 
142c			 
142c d1			      pop   DE                      ; Store size of new block into new block 
142d 23			      inc   HL 
142e 73			      ld    (HL), E 
142f 23			      inc   HL 
1430 72			      ld    (HL), D 
1431			 
1431			      ; Update this_free ptr to point to new block 
1431 2b			      dec   HL 
1432 2b			      dec   HL 
1433 2b			      dec   HL 
1434			 
1434 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1437 dd 56 03		      ld    D, (IX+3) 
143a			 
143a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143d dd 74 03		      ld    (IX+3), H 
1440			 
1440			      ; Modify this_free block to be allocation 
1440 eb			      ex    DE, HL 
1441 af			      xor   A                       ; Null the next block ptr of allocated block 
1442 77			      ld    (HL), A 
1443 23			      inc   HL 
1444 77			      ld    (HL), A 
1445			 
1445 23			      inc   HL                      ; Store want size into allocated block 
1446 71			      ld    (HL), C 
1447 23			      inc   HL 
1448 70			      ld    (HL), B 
1449 23			      inc   HL 
144a e5			      push  HL                      ; Address of allocation to return 
144b			 
144b 18 19		      jr    malloc_update_links 
144d			 
144d			malloc_alloc_fit: 
144d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
144e			 
144e					if DEBUG_FORTH_MALLOC 
144e						DMARK "MAf" 
144e						CALLMONITOR 
144e					endif 
144e			      ; Modify this_free block to be allocation 
144e eb			      ex    DE, HL 
144f 2b			      dec   HL 
1450 2b			      dec   HL 
1451 2b			      dec   HL 
1452			 
1452 af			      xor   A                       ; Null the next block ptr of allocated block 
1453 77			      ld    (HL), A 
1454 23			      inc   HL 
1455 77			      ld    (HL), A 
1456			 
1456 23			      inc   HL                      ; Store address of allocation to return 
1457 23			      inc   HL 
1458 23			      inc   HL 
1459 e5			      push  HL 
145a			 
145a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
145a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
145d dd 66 01		      ld    H, (IX+1) 
1460			 
1460 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1463 dd 74 03		      ld    (IX+3), H 
1466			 
1466			 
1466			malloc_update_links: 
1466			      ; Update prev_free ptr to point to this_free 
1466 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1469 dd 66 05		      ld    H, (IX+5) 
146c			 
146c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
146f dd 56 03		      ld    D, (IX+3) 
1472			 
1472 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1473 23			      inc   HL 
1474 72			      ld    (HL), D 
1475			 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "Mul" 
1475						CALLMONITOR 
1475					endif 
1475			      ; Clear the Z flag to indicate successful allocation 
1475 7a			      ld    A, D 
1476 b3			      or    E 
1477			 
1477 d1			      pop   DE                      ; Address of allocation 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAu" 
1478						CALLMONITOR 
1478					endif 
1478			 
1478			malloc_no_space: 
1478 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
147b 39			      add   HL, SP 
147c f9			      ld    SP, HL 
147d			 
147d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAN" 
147e						CALLMONITOR 
147e					endif 
147e			 
147e			malloc_early_exit: 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAx" 
147e						CALLMONITOR 
147e					endif 
147e dd e1		      pop   IX 
1480 d1			      pop   DE 
1481 c1			      pop   BC 
1482			 
1482			if DEBUG_FORTH_MALLOC_HIGH 
1482			call malloc_guard_exit 
1482			call malloc_guard_zerolen 
1482			endif 
1482 c9			      ret 
1483			 
1483			 
1483			;------------------------------------------------------------------------------ 
1483			;     free                                                                    : 
1483			;                                                                             : 
1483			; Description                                                                 : 
1483			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1483			;     returned by malloc, otherwise the behaviour is undefined.               : 
1483			;                                                                             : 
1483			;     Where possible, directly adjacent free blocks will be merged together   : 
1483			;     into larger blocks to help ensure that the heap does not become         : 
1483			;     excessively fragmented.                                                 : 
1483			;                                                                             : 
1483			;     free does not clear or set any other value into the freed space, and    : 
1483			;     therefore its contents may be visible through subsequent malloc's. The  : 
1483			;     caller should clear the freed space as required.                        : 
1483			;                                                                             : 
1483			;     This implementation of free uses the stack exclusively, and is          : 
1483			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1483			;     advisable to disable interrupts before calling free, and recommended    : 
1483			;     to avoid the use of free inside ISRs in general.                        : 
1483			;                                                                             : 
1483			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1483			;                                                                             : 
1483			; Parameters                                                                  : 
1483			;     HL  Pointer to address of first byte of allocation to be freed          : 
1483			;                                                                             : 
1483			; Returns                                                                     : 
1483			;     Nothing                                                                 : 
1483			;                                                                             : 
1483			; Stack frame                                                                 : 
1483			;       |             |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     BC      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     DE      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     IX      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |  prev_free  |                                                       : 
1483			;   +2  +-------------+                                                       : 
1483			;       |  next_free  |                                                       : 
1483			;   +0  +-------------+                                                       : 
1483			;       |             |                                                       : 
1483			;                                                                             : 
1483			;------------------------------------------------------------------------------ 
1483			free: 
1483 c5			      push  BC 
1484 d5			      push  DE 
1485 dd e5		      push  IX 
1487			 
1487 7c			      ld    A, H                    ; Exit if ptr is null 
1488 b5			      or    L 
1489 ca 4d 15		      jp    Z, free_early_exit 
148c			 
148c			      ; Set up stack frame 
148c eb			      ex    DE, HL 
148d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1490 39			      add   HL, SP 
1491 f9			      ld    SP, HL 
1492 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1496 dd 39		      add   IX, SP 
1498			 
1498			      ; The address in HL points to the start of the useable allocated space, 
1498			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1498			      ; address of the block itself. 
1498 eb			      ex    DE, HL 
1499 11 fc ff		      ld    DE, -4 
149c 19			      add   HL, DE 
149d			 
149d			      ; An allocated block must have a null next block pointer in it 
149d 7e			      ld    A, (HL) 
149e 23			      inc   HL 
149f b6			      or    (HL) 
14a0 c2 48 15		      jp    NZ, free_done 
14a3			 
14a3 2b			      dec   HL 
14a4			 
14a4 44			      ld    B, H                    ; Copy HL to BC 
14a5 4d			      ld    C, L 
14a6			 
14a6			      ; Loop through the free list to find the first block with an address 
14a6			      ; higher than the block being freed 
14a6 21 0a 80		      ld    HL, free_list 
14a9			 
14a9			free_find_higher_block: 
14a9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14aa 23			      inc   HL 
14ab 56			      ld    D, (HL) 
14ac 2b			      dec   HL 
14ad			 
14ad dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14b0 dd 72 01		      ld    (IX+1), D 
14b3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14b6 dd 74 03		      ld    (IX+3), H 
14b9			 
14b9 78			      ld    A, B                    ; Check if DE is greater than BC 
14ba ba			      cp    D                       ; Compare MSB first 
14bb 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14bd 30 04		      jr    NC, free_find_higher_block_skip 
14bf 79			      ld    A, C 
14c0 bb			      cp    E                       ; Then compare LSB 
14c1 38 08		      jr    C, free_found_higher_block 
14c3			 
14c3			free_find_higher_block_skip: 
14c3 7a			      ld    A, D                    ; Reached the end of the free list? 
14c4 b3			      or    E 
14c5 ca 48 15		      jp    Z, free_done 
14c8			 
14c8 eb			      ex    DE, HL 
14c9			 
14c9 18 de		      jr    free_find_higher_block 
14cb			 
14cb			free_found_higher_block: 
14cb			      ; Insert freed block between prev and next free blocks 
14cb 71			      ld    (HL), C                 ; Point prev free block to freed block 
14cc 23			      inc   HL 
14cd 70			      ld    (HL), B 
14ce			 
14ce 60			      ld    H, B                    ; Point freed block at next free block 
14cf 69			      ld    L, C 
14d0 73			      ld    (HL), E 
14d1 23			      inc   HL 
14d2 72			      ld    (HL), D 
14d3			 
14d3			      ; Check if the freed block is adjacent to the next free block 
14d3 23			      inc   HL                      ; Load size of freed block into HL 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7 eb			      ex    DE, HL 
14d8			 
14d8 09			      add   HL, BC                  ; Add addr of freed block and its size 
14d9			 
14d9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14dc dd 56 01		      ld    D, (IX+1) 
14df			 
14df b7			      or    A                       ; Clear the carry flag 
14e0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14e2 20 22		      jr    NZ, free_check_adjacent_to_prev 
14e4			 
14e4			      ; Freed block is adjacent to next, merge into one bigger block 
14e4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14e5 5e			      ld    E, (HL) 
14e6 23			      inc   HL 
14e7 56			      ld    D, (HL) 
14e8 e5			      push  HL                      ; Save ptr to next block for later 
14e9			 
14e9 60			      ld    H, B                    ; Store ptr from next block into freed block 
14ea 69			      ld    L, C 
14eb 73			      ld    (HL), E 
14ec 23			      inc   HL 
14ed 72			      ld    (HL), D 
14ee			 
14ee e1			      pop   HL                      ; Restore ptr to next block 
14ef 23			      inc   HL                      ; Load size of next block into DE 
14f0 5e			      ld    E, (HL) 
14f1 23			      inc   HL 
14f2 56			      ld    D, (HL) 
14f3 d5			      push  DE                      ; Save next block size for later 
14f4			 
14f4 60			      ld    H, B                    ; Load size of freed block into HL 
14f5 69			      ld    L, C 
14f6 23			      inc   HL 
14f7 23			      inc   HL 
14f8 5e			      ld    E, (HL) 
14f9 23			      inc   HL 
14fa 56			      ld    D, (HL) 
14fb eb			      ex    DE, HL 
14fc			 
14fc d1			      pop   DE                      ; Restore size of next block 
14fd 19			      add   HL, DE                  ; Add sizes of both blocks 
14fe eb			      ex    DE, HL 
14ff			 
14ff 60			      ld    H, B                    ; Store new bigger size into freed block 
1500 69			      ld    L, C 
1501 23			      inc   HL 
1502 23			      inc   HL 
1503 73			      ld    (HL), E 
1504 23			      inc   HL 
1505 72			      ld    (HL), D 
1506			 
1506			free_check_adjacent_to_prev: 
1506			      ; Check if the freed block is adjacent to the prev free block 
1506 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1509 dd 66 03		      ld    H, (IX+3) 
150c			 
150c 23			      inc   HL                      ; Size of prev free block into DE 
150d 23			      inc   HL 
150e 5e			      ld    E, (HL) 
150f 23			      inc   HL 
1510 56			      ld    D, (HL) 
1511 2b			      dec   HL 
1512 2b			      dec   HL 
1513 2b			      dec   HL 
1514			 
1514 19			      add   HL, DE                  ; Add prev block addr and size 
1515			 
1515 b7			      or    A                       ; Clear the carry flag 
1516 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1518 20 2e		      jr    NZ, free_done 
151a			 
151a			      ; Freed block is adjacent to prev, merge into one bigger block 
151a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
151b 69			      ld    L, C 
151c 5e			      ld    E, (HL) 
151d 23			      inc   HL 
151e 56			      ld    D, (HL) 
151f e5			      push  HL                      ; Save freed block ptr for later 
1520			 
1520 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1523 dd 66 03		      ld    H, (IX+3) 
1526 73			      ld    (HL), E 
1527 23			      inc   HL 
1528 72			      ld    (HL), D 
1529			 
1529 e1			      pop   HL                      ; Restore freed block ptr 
152a 23			      inc   HL                      ; Load size of freed block into DE 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e d5			      push  DE                      ; Save freed block size for later 
152f			 
152f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1532 dd 66 03		      ld    H, (IX+3) 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 5e			      ld    E, (HL) 
1538 23			      inc   HL 
1539 56			      ld    D, (HL) 
153a			 
153a e1			      pop   HL                      ; Add sizes of both blocks 
153b 19			      add   HL, DE 
153c eb			      ex    DE, HL 
153d			 
153d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1540 dd 66 03		      ld    H, (IX+3) 
1543 23			      inc   HL 
1544 23			      inc   HL 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548			free_done: 
1548 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
154b 39			      add   HL, SP 
154c f9			      ld    SP, HL 
154d			 
154d			free_early_exit: 
154d dd e1		      pop   IX 
154f d1			      pop   DE 
1550 c1			      pop   BC 
1551			 
1551 c9			      ret 
1552			 
1552			; moved to firmware.asm 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			;                  .dw   0 
1552			 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_3 
1552			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1552			;heap_start        .equ  0x9000      ; Starting address of heap 
1552			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1552			; 
1552			 ;     .org 0 
1552			  ;    jp    main 
1552			; 
1552			; 
1552			 ;     .org  0x100 
1552			;main: 
1552			 ;     ld    HL, 0x8100 
1552			  ;    ld    SP, HL 
1552			; 
1552			;      call  heap_init 
1552			 
1552			      ; Make some allocations 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9004 
1552			; 
1552			 ;     ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9014 
1552			 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9024 
1552			 
1552			      ; Free some allocations 
1552			;      ld    HL, 0x9014 
1552			;      call  free 
1552			 
1552			;      ld    HL, 0x9004 
1552			;      call  free 
1552			; 
1552			;      ld    HL, 0x9024 
1552			;      call  free 
1552			 
1552			 
1552			 ;     halt 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     heap_init                                                               : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Initialise the heap and make it ready for malloc and free operations.   : 
1552			;                                                                             : 
1552			;     The heap is maintained as a linked list, starting with an initial       : 
1552			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1552			;     the first free block in the heap. Each block then points to the next    : 
1552			;     free block within the heap, and the free list ends at the first block   : 
1552			;     with a null pointer to the next free block.                             : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     Inputs are compile-time only. Two defines which specify the starting    : 
1552			;     address of the heap and its size are required, along with a memory      : 
1552			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1552			;     principally stores a pointer to the first free block in the heap.       : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;------------------------------------------------------------------------------ 
1552			heap_init: 
1552			      push  HL 
1552			 
1552			      ; Initialise free list struct 
1552			      ld    HL, heap_start 
1552			      ld    (free_list), HL 
1552			      ld    HL, 0 
1552			      ld    (free_list+2), HL 
1552			 
1552			      ; Insert first free block at bottom of heap, consumes entire heap 
1552			      ld    HL, heap_start+heap_size-4 
1552			      ld    (heap_start), HL        ; Next block (end of free list) 
1552			      ld    HL, heap_size-4 
1552			      ld    (heap_start+2), HL      ; Block size 
1552			 
1552			      ; Insert end of free list block at top of heap - two null words will 
1552			      ; terminate the free list 
1552			      ld    HL, 0 
1552			      ld    (heap_start+heap_size-2), HL 
1552			      ld    (heap_start+heap_size-4), HL 
1552			 
1552			      pop   HL 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     malloc                                                                  : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Allocates the wanted space from the heap and returns the address of the : 
1552			;     first useable byte of the allocation.                                   : 
1552			;                                                                             : 
1552			;     Allocations can happen in one of two ways:                              : 
1552			;                                                                             : 
1552			;     1. A free block may be found which is the exact size wanted. In this    : 
1552			;        case the block is removed from the free list and retuedn to the      : 
1552			;        caller.                                                              : 
1552			;     2. A free block may be found which is larger than the size wanted. In   : 
1552			;        this case, the larger block is split into two. The first portion of  : 
1552			;        this block will become the requested space by the malloc call and    : 
1552			;        is returned to the caller. The second portion becomes a new free     : 
1552			;        block, and the free list is adjusted to maintain continuity via this : 
1552			;        newly created block.                                                 : 
1552			;                                                                             : 
1552			;     malloc does not set any initial value in the allocated space, the       : 
1552			;     caller is required to do this as required.                              : 
1552			;                                                                             : 
1552			;     This implementation of malloc uses the stack exclusively, and is        : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling malloc, and recommended  : 
1552			;     to avoid the use of malloc inside ISRs in general.                      : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Number of bytes wanted                                              : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     HL  Address of the first useable byte of the allocation                 : 
1552			;                                                                             : 
1552			; Flags                                                                       : 
1552			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +4  +-------------+                                                       : 
1552			;       |  this_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			malloc: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if no space requested 
1552			      or    L 
1552			      jp    Z, malloc_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; Setup initial state 
1552			      ld    HL, 4                   ; want must also include space used by block struct 
1552			      add   HL, DE 
1552			 
1552			      ld    B, H                    ; Move want to BC 
1552			      ld    C, L 
1552			 
1552			      ld    HL, free_list           ; Store prev_free ptr to stack 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    E, (HL)                 ; Store this_free ptr to stack 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ld    (IX+2), E 
1552			      ld    (IX+3), D 
1552			      ex    DE, HL                  ; this_free ptr into HL 
1552			 
1552			      ; Loop through free block list to find some space 
1552			malloc_find_space: 
1552			      ld    E, (HL)                 ; Load next_free ptr into DE 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1552			      or    E 
1552			      jp    Z, malloc_no_space 
1552			 
1552			      ld    (IX+0), E               ; Store next_free ptr to stack 
1552			      ld    (IX+1), D 
1552			 
1552			      ; Does this block have enough space to make the allocation? 
1552			      inc   HL                      ; Load free block size into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ex    DE, HL                  ; Check size of block against want 
1552			      or    A                       ; Ensure carry flag clear 
1552			      sbc   HL, BC 
1552			      push  HL                      ; Store the result for later (new block size) 
1552			 
1552			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1552			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1552			 
1552			      ; this_free block is not big enough, setup ptrs to test next free block 
1552			      pop   HL                      ; Discard previous result 
1552			 
1552			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1552			      ld    H, (IX+3) 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1552			      ld    H, (IX+1) 
1552			      ld    (IX+2), L 
1552			      ld    (IX+3), H 
1552			 
1552			      jr    malloc_find_space 
1552			 
1552			      ; split a bigger block into two - requested size and remaining size 
1552			malloc_alloc_split: 
1552			      ex    DE, HL                  ; Calculate address of new free block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      add   HL, BC 
1552			 
1552			      ; Create a new block and point it at next_free 
1552			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      ld    (HL), E                 ; Store next_free ptr into new block 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   DE                      ; Store size of new block into new block 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Update this_free ptr to point to new block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1552			      ld    (IX+3), H 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store want size into allocated block 
1552			      ld    (HL), C 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			      inc   HL 
1552			      push  HL                      ; Address of allocation to return 
1552			 
1552			      jr    malloc_update_links 
1552			 
1552			malloc_alloc_fit: 
1552			      pop   HL                      ; Dont need new block size, want is exact fit 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store address of allocation to return 
1552			      inc   HL 
1552			      inc   HL 
1552			      push  HL 
1552			 
1552			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1552			      ld    L, (IX+0)               ; next_free to HL 
1552			      ld    H, (IX+1) 
1552			 
1552			      ld    (IX+2), L               ; HL to this_free 
1552			      ld    (IX+3), H 
1552			 
1552			 
1552			malloc_update_links: 
1552			      ; Update prev_free ptr to point to this_free 
1552			      ld    L, (IX+4)               ; prev_free ptr to HL 
1552			      ld    H, (IX+5) 
1552			 
1552			      ld    E, (IX+2)               ; this_free ptr to DE 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (HL), E                 ; this_free ptr into prev_free 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Clear the Z flag to indicate successful allocation 
1552			      ld    A, D 
1552			      or    E 
1552			 
1552			      pop   DE                      ; Address of allocation 
1552			 
1552			malloc_no_space: 
1552			      ld    HL, 6                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			      ex    DE, HL                  ; Alloc addr into HL for return 
1552			 
1552			malloc_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     free                                                                    : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1552			;     returned by malloc, otherwise the behaviour is undefined.               : 
1552			;                                                                             : 
1552			;     Where possible, directly adjacent free blocks will be merged together   : 
1552			;     into larger blocks to help ensure that the heap does not become         : 
1552			;     excessively fragmented.                                                 : 
1552			;                                                                             : 
1552			;     free does not clear or set any other value into the freed space, and    : 
1552			;     therefore its contents may be visible through subsequent malloc's. The  : 
1552			;     caller should clear the freed space as required.                        : 
1552			;                                                                             : 
1552			;     This implementation of free uses the stack exclusively, and is          : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling free, and recommended    : 
1552			;     to avoid the use of free inside ISRs in general.                        : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Pointer to address of first byte of allocation to be freed          : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			free: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if ptr is null 
1552			      or    L 
1552			      jp    Z, free_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; The address in HL points to the start of the useable allocated space, 
1552			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1552			      ; address of the block itself. 
1552			      ex    DE, HL 
1552			      ld    DE, -4 
1552			      add   HL, DE 
1552			 
1552			      ; An allocated block must have a null next block pointer in it 
1552			      ld    A, (HL) 
1552			      inc   HL 
1552			      or    (HL) 
1552			      jp    NZ, free_done 
1552			 
1552			      dec   HL 
1552			 
1552			      ld    B, H                    ; Copy HL to BC 
1552			      ld    C, L 
1552			 
1552			      ; Loop through the free list to find the first block with an address 
1552			      ; higher than the block being freed 
1552			      ld    HL, free_list 
1552			 
1552			free_find_higher_block: 
1552			      ld    E, (HL)                 ; Load next ptr from free block 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			 
1552			      ld    (IX+0), E               ; Save ptr to next free block 
1552			      ld    (IX+1), D 
1552			      ld    (IX+2), L               ; Save ptr to prev free block 
1552			      ld    (IX+3), H 
1552			 
1552			      ld    A, B                    ; Check if DE is greater than BC 
1552			      cp    D                       ; Compare MSB first 
1552			      jr    Z, $+4                  ; MSB the same, compare LSB 
1552			      jr    NC, free_find_higher_block_skip 
1552			      ld    A, C 
1552			      cp    E                       ; Then compare LSB 
1552			      jr    C, free_found_higher_block 
1552			 
1552			free_find_higher_block_skip: 
1552			      ld    A, D                    ; Reached the end of the free list? 
1552			      or    E 
1552			      jp    Z, free_done 
1552			 
1552			      ex    DE, HL 
1552			 
1552			      jr    free_find_higher_block 
1552			 
1552			free_found_higher_block: 
1552			      ; Insert freed block between prev and next free blocks 
1552			      ld    (HL), C                 ; Point prev free block to freed block 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			 
1552			      ld    H, B                    ; Point freed block at next free block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Check if the freed block is adjacent to the next free block 
1552			      inc   HL                      ; Load size of freed block into HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      add   HL, BC                  ; Add addr of freed block and its size 
1552			 
1552			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_check_adjacent_to_prev 
1552			 
1552			      ; Freed block is adjacent to next, merge into one bigger block 
1552			      ex    DE, HL                  ; Load next ptr from next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save ptr to next block for later 
1552			 
1552			      ld    H, B                    ; Store ptr from next block into freed block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore ptr to next block 
1552			      inc   HL                      ; Load size of next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save next block size for later 
1552			 
1552			      ld    H, B                    ; Load size of freed block into HL 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      pop   DE                      ; Restore size of next block 
1552			      add   HL, DE                  ; Add sizes of both blocks 
1552			      ex    DE, HL 
1552			 
1552			      ld    H, B                    ; Store new bigger size into freed block 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_check_adjacent_to_prev: 
1552			      ; Check if the freed block is adjacent to the prev free block 
1552			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1552			      ld    H, (IX+3) 
1552			 
1552			      inc   HL                      ; Size of prev free block into DE 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      add   HL, DE                  ; Add prev block addr and size 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_done 
1552			 
1552			      ; Freed block is adjacent to prev, merge into one bigger block 
1552			      ld    H, B                    ; Load next ptr from freed block into DE 
1552			      ld    L, C 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save freed block ptr for later 
1552			 
1552			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1552			      ld    H, (IX+3) 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore freed block ptr 
1552			      inc   HL                      ; Load size of freed block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save freed block size for later 
1552			 
1552			      ld    L, (IX+2)               ; Load size of prev block into DE 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      pop   HL                      ; Add sizes of both blocks 
1552			      add   HL, DE 
1552			      ex    DE, HL 
1552			 
1552			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_done: 
1552			      ld    HL, 4                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			free_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;      .org 0x8000 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			 ;                 .dw   0 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_4 
1552			 
1552			; My memory allocation code. Very very simple.... 
1552			; allocate space under 250 chars 
1552			 
1552			heap_init: 
1552				; init start of heap as zero 
1552				;  
1552			 
1552				ld hl, heap_start 
1552				ld a, 0 
1552				ld (hl), a      ; empty block 
1552				inc hl 
1552				ld a, 0 
1552				ld (hl), a      ; length of block 
1552				; write end of list 
1552				inc hl 
1552				ld a,(hl) 
1552				inc hl 
1552				ld a,(hl) 
1552				 
1552			 
1552				; init some malloc vars 
1552			 
1552				ld hl, 0 
1552				ld (free_list), hl       ; store last malloc location 
1552			 
1552				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1552				ld a, 0 
1552				ld (hl), a 
1552			 
1552			 
1552				ld hl, heap_start 
1552				;  
1552				  
1552				ret 
1552			 
1552			 
1552			;    free block marker 
1552			;    requested size  
1552			;    pointer to next block 
1552			;    .... 
1552			;    next block marker 
1552			 
1552			 
1552			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1552			; 
1552			 
1552			 
1552			malloc:  
1552				push de 
1552				push bc 
1552				push af 
1552			 
1552				; hl space required 
1552				 
1552				ld c, l    ; hold space   (TODO only a max of 255) 
1552			 
1552			;	inc c     ; TODO BUG need to fix memory leak on push str 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			 
1552			 
1552			 
1552				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1552			 
1552				ld a, (free_list+3) 
1552				cp 0 
1552				jr z, .contheap 
1552			 
1552				ld hl, (free_list)     ; get last alloc 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mrs" 
1552						CALLMONITOR 
1552					endif 
1552				jr .startalloc 
1552			 
1552			.contheap: 
1552				ld hl, heap_start 
1552			 
1552			.startalloc: 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mym" 
1552						CALLMONITOR 
1552					endif 
1552			.findblock: 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmf" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552				ld a,(hl)  
1552				; if byte is zero then clear to use 
1552			 
1552				cp 0 
1552				jr z, .foundemptyblock 
1552			 
1552				; if byte is not clear 
1552				;     then byte is offset to next block 
1552			 
1552				inc hl 
1552				ld a, (hl) ; get size 
1552			.nextblock:	inc hl 
1552					ld e, (hl) 
1552					inc hl 
1552					ld d, (hl) 
1552					ex de, hl 
1552			;	inc hl  ; move past the store space 
1552			;	inc hl  ; move past zero index  
1552			 
1552				; TODO detect no more space 
1552			 
1552				push hl 
1552				ld de, heap_end 
1552				call cmp16 
1552				pop hl 
1552				jr nc, .nospace 
1552			 
1552				jr .findblock 
1552			 
1552			.nospace: ld hl, 0 
1552				jp .exit 
1552			 
1552			 
1552			.foundemptyblock:	 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mme" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; TODO has block enough space if reusing??? 
1552			 
1552				;  
1552			 
1552			; see if this block has been previously used 
1552				inc hl 
1552				ld a, (hl) 
1552				dec hl 
1552				cp 0 
1552				jr z, .newblock 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meR" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; no reusing previously allocated block 
1552			 
1552			; is it smaller than previously used? 
1552				 
1552				inc hl    ; move to size 
1552				ld a, c 
1552				sub (hl)        ; we want c < (hl) 
1552				dec hl    ; move back to marker 
1552			        jr z, .findblock 
1552			 
1552				; update with the new size which should be lower 
1552			 
1552			        ;inc  hl   ; negate next move. move back to size  
1552			 
1552			.newblock: 
1552				; need to be at marker here 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meN" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			 
1552				ld a, c 
1552			 
1552				ld (free_list+3), a	 ; flag resume from last malloc  
1552				ld (free_list), hl    ; save out last location 
1552			 
1552			 
1552				;inc a     ; space for length byte 
1552				ld (hl), a     ; save block in use marker 
1552			 
1552				inc hl   ; move to space marker 
1552				ld (hl), a    ; save new space 
1552			 
1552				inc hl   ; move to start of allocated area 
1552				 
1552			;	push hl     ; save where we are - 1  
1552			 
1552			;	inc hl  ; move past zero index  
1552				; skip space to set down new marker 
1552			 
1552				; provide some extra space for now 
1552			 
1552				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1552				inc a 
1552				inc a 
1552			 
1552				push hl   ; save where we are in the node block 
1552			 
1552				call addatohl 
1552			 
1552				; write linked list point 
1552			 
1552				pop de     ; get our node position 
1552				ex de, hl 
1552			 
1552				ld (hl), e 
1552				inc hl 
1552				ld (hl), d 
1552			 
1552				inc hl 
1552			 
1552				; now at start of allocated data so save pointer 
1552			 
1552				push hl 
1552			 
1552				; jump to position of next node and setup empty header in DE 
1552			 
1552				ex de, hl 
1552			 
1552			;	inc hl ; move past end of block 
1552			 
1552				ld a, 0 
1552				ld (hl), a   ; empty marker 
1552				inc hl 
1552				ld (hl), a   ; size 
1552				inc hl  
1552				ld (hl), a   ; ptr 
1552				inc hl 
1552				ld (hl), a   ; ptr 
1552			 
1552			 
1552				pop hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmr" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			.exit: 
1552				pop af 
1552				pop bc 
1552				pop de  
1552				ret 
1552			 
1552			 
1552			 
1552			 
1552			free:  
1552				push hl 
1552				push af 
1552				; get address in hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "fre" 
1552						CALLMONITOR 
1552					endif 
1552				; data is at hl - move to block count 
1552				dec hl 
1552				dec hl    ; get past pointer 
1552				dec hl 
1552			 
1552				ld a, (hl)    ; need this for a validation check 
1552			 
1552				dec hl    ; move to block marker 
1552			 
1552				; now check that the block count and block marker are the same  
1552			        ; this checks that we are on a malloc node and not random memory 
1552			        ; OK a faint chance this could be a problem but rare - famous last words! 
1552			 
1552				ld c, a 
1552				ld a, (hl)    
1552			 
1552				cp c 
1552				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1552			 
1552				; yes good chance we are on a malloc node 
1552			 
1552				ld a, 0      
1552				ld (hl), a   ; mark as free 
1552			 
1552				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1552			 
1552			.freeignore:  
1552			 
1552				pop af 
1552				pop hl 
1552			 
1552				ret 
1552			 
1552			 
1552			 
1552			endif 
1552			 
1552			; eof 
# End of file firmware_memory.asm
1552			  
1552			; device C  
1552			; Now handled by SPI  
1552			;if SOUND_ENABLE  
1552			;	include "firmware_sound.asm"  
1552			;endif  
1552			  
1552			include "firmware_diags.asm"  
1552			; Hardware diags menu 
1552			 
1552			 
1552			config: 
1552			 
1552 3e 00			ld a, 0 
1554 21 78 15			ld hl, .configmn 
1557 cd db 0d			call menu 
155a			 
155a fe 00			cp 0 
155c c8				ret z 
155d			 
155d			;	cp 1 
155d			;	call z, .savetostore 
155d			 
155d fe 01			cp 1 
155f			if STARTUP_V1 
155f				call z, .selautoload 
155f			endif 
155f			 
155f			if STARTUP_V2 
155f cc 84 15			call z, .enautoload 
1562			endif 
1562 fe 02			cp 2 
1564 cc 9b 15			call z, .disautoload 
1567			;	cp 3 
1567			;	call z, .selbank 
1567 fe 03			cp 3 
1569 cc 06 18			call z, .debug_tog 
156c fe 04			cp 4 
156e cc d5 18			call z, .bpsgo 
1571			;	cp 5 
1571			;	call z, hardware_diags 
1571			if STARTUP_V2 
1571 fe 05			cp 5 
1573 cc c7 15			call z, create_startup 
1576			endif 
1576 18 da			jr config 
1578			 
1578			.configmn: 
1578			;	dw prom_c3 
1578 c3 1a			dw prom_c2 
157a d9 1a			dw prom_c2a 
157c			;	dw prom_c2b 
157c			;	dw prom_c4 
157c 50 1b			dw prom_m4 
157e 6b 1b			dw prom_m4b 
1580			;	dw prom_c1 
1580			if STARTUP_V2 
1580 73 1b			dw prom_c9 
1582			endif 
1582 00 00			dw 0 
1584				 
1584			 
1584			if STARTUP_V2 
1584			.enautoload: 
1584				if STORAGE_SE 
1584 3e fe			ld a, $fe      ; bit 0 clear 
1586 32 92 f9			ld (spi_device), a 
1589			 
1589 cd 25 05			call storage_get_block_0 
158c			 
158c 3e 01			ld a, 1 
158e 32 cd f9			ld (store_page+STORE_0_AUTOFILE), a 
1591			 
1591 21 00 00				ld hl, 0 
1594 11 ac f9				ld de, store_page 
1597 cd d9 04			call storage_write_block	 ; save update 
159a				else 
159a			 
159a				ld hl, prom_notav 
159a				ld de, prom_empty 
159a				call info_panel 
159a				endif 
159a			 
159a			 
159a c9				ret 
159b			endif 
159b			 
159b			.disautoload: 
159b				if STORAGE_SE 
159b 3e fe			ld a, $fe      ; bit 0 clear 
159d 32 92 f9			ld (spi_device), a 
15a0			 
15a0 cd 25 05			call storage_get_block_0 
15a3			 
15a3 3e 00			ld a, 0 
15a5 32 cd f9			ld (store_page+STORE_0_AUTOFILE), a 
15a8			 
15a8 21 00 00				ld hl, 0 
15ab 11 ac f9				ld de, store_page 
15ae cd d9 04			call storage_write_block	 ; save update 
15b1				else 
15b1			 
15b1				ld hl, prom_notav 
15b1				ld de, prom_empty 
15b1				call info_panel 
15b1				endif 
15b1			 
15b1			 
15b1 c9				ret 
15b2			 
15b2			if STARTUP_V1 
15b2			 
15b2			; Select auto start 
15b2			 
15b2			.selautoload: 
15b2			 
15b2				 
15b2				if STORAGE_SE 
15b2			 
15b2					call config_dir 
15b2				        ld hl, scratch 
15b2					ld a, 0 
15b2					call menu 
15b2			 
15b2					cp 0 
15b2					ret z 
15b2			 
15b2					dec a 
15b2			 
15b2			 
15b2					; locate menu option 
15b2			 
15b2					ld hl, scratch 
15b2					call table_lookup 
15b2			 
15b2					if DEBUG_FORTH_WORDS 
15b2						DMARK "ALl" 
15b2						CALLMONITOR 
15b2					endif 
15b2					; with the pointer to the menu it, the byte following the zero term is the file id 
15b2			 
15b2					ld a, 0 
15b2					ld bc, 50   ; max of bytes to look at 
15b2					cpir  
15b2			 
15b2					if DEBUG_FORTH_WORDS 
15b2						DMARK "ALb" 
15b2						CALLMONITOR 
15b2					endif 
15b2					;inc hl 
15b2			 
15b2					ld a, (hl)   ; file id 
15b2					 
15b2				        ; save bank and file ids 
15b2			 
15b2					push af 
15b2			 
15b2			; TODO need to save to block 0 on bank 1	 
15b2			 
15b2					call storage_get_block_0 
15b2			 
15b2					if DEBUG_FORTH_WORDS 
15b2						DMARK "AL0" 
15b2						CALLMONITOR 
15b2					endif 
15b2					pop af 
15b2			 
15b2					ld (store_page+STORE_0_FILERUN),a 
15b2					 
15b2					; save bank id 
15b2			 
15b2					ld a,(spi_device) 
15b2					ld (store_page+STORE_0_BANKRUN),a 
15b2			 
15b2					; enable auto run of store file 
15b2			 
15b2					ld a, 1 
15b2					ld (store_page+STORE_0_AUTOFILE),a 
15b2			 
15b2					; save buffer 
15b2			 
15b2					ld hl, 0 
15b2					ld de, store_page 
15b2					if DEBUG_FORTH_WORDS 
15b2						DMARK "ALw" 
15b2						CALLMONITOR 
15b2					endif 
15b2				call storage_write_block	 ; save update 
15b2			  
15b2			 
15b2			 
15b2			 
15b2					ld hl, scratch 
15b2					call config_fdir 
15b2			 
15b2				else 
15b2			 
15b2				ld hl, prom_notav 
15b2				ld de, prom_empty 
15b2				call info_panel 
15b2			 
15b2				endif 
15b2				ret 
15b2			endif 
15b2			 
15b2			 
15b2			; Select storage bank 
15b2			 
15b2			.selbank: 
15b2			 
15b2			;	if STORAGE_SE 
15b2			;	else 
15b2			 
15b2 21 88 1b			ld hl, prom_notav 
15b5 11 9e 1b			ld de, prom_empty 
15b8 cd 3b 0d			call info_panel 
15bb			;	endif 
15bb				 
15bb c9				ret 
15bc			 
15bc			if STORAGE_SE 
15bc			 
15bc			.config_ldir:   
15bc				; Load storage bank labels into menu array 
15bc			 
15bc				 
15bc			 
15bc			 
15bc c9				ret 
15bd			 
15bd			 
15bd			endif 
15bd			 
15bd			 
15bd			; Save user words to storage 
15bd			 
15bd			.savetostore: 
15bd			 
15bd			;	if STORAGE_SE 
15bd			; 
15bd			;		call config_dir 
15bd			;	        ld hl, scratch 
15bd			;		ld a, 0 
15bd			;		call menu 
15bd			;		 
15bd			;		ld hl, scratch 
15bd			;		call config_fdir 
15bd			; 
15bd			;	else 
15bd			 
15bd 21 88 1b			ld hl, prom_notav 
15c0 11 9e 1b			ld de, prom_empty 
15c3 cd 3b 0d			call info_panel 
15c6			 
15c6			;	endif 
15c6			 
15c6 c9				ret 
15c7			 
15c7			if STARTUP_V2 
15c7			 
15c7			create_startup: 
15c7			 
15c7 3e 00			ld a, 0 
15c9 21 2b 17			ld hl, .crstart 
15cc cd db 0d			call menu 
15cf			 
15cf fe 00			cp 0 
15d1 c8				ret z 
15d2			 
15d2 fe 01			cp 1 
15d4 cc 10 16			call z, .genlsword 
15d7 fe 02			cp 2 
15d9 cc 1a 16			call z, .genedword 
15dc			 
15dc fe 03			cp 3 
15de cc 24 16			call z, .gendemword 
15e1			 
15e1 fe 04			cp 4 
15e3 cc 2e 16			call z, .genutlword 
15e6 fe 05			cp 5 
15e8 cc 38 16			call z, .genspiword 
15eb fe 06			cp 6 
15ed cc 42 16			call z, .genkeyword 
15f0 fe 07			cp 7 
15f2 cc 06 16			call z, .gensoundword 
15f5 fe 08			cp 8 
15f7 cc fc 15			call z, .genhwword 
15fa 18 cb			jr create_startup 
15fc			 
15fc			.genhwword: 
15fc 21 3a 1b			ld hl, crs_hw 
15ff 11 8f 16			ld de, .hwworddef 
1602 cd 4c 16			call .genfile 
1605 c9				ret 
1606			.gensoundword: 
1606 21 2e 1b			ld hl, crs_sound 
1609 11 9d 16			ld de, .soundworddef 
160c cd 4c 16			call .genfile 
160f c9				ret 
1610			.genlsword: 
1610 21 f0 1a			ld hl, crs_s1 
1613 11 c3 16			ld de, .lsworddef 
1616 cd 4c 16			call .genfile 
1619 c9				ret 
161a			 
161a			.genedword: 
161a 11 c7 16			ld de, .edworddef 
161d 21 f9 1a			ld hl, crs_s2 
1620 cd 4c 16			call .genfile 
1623 c9				ret 
1624			 
1624			.gendemword: 
1624 11 cf 16			ld de, .demoworddef 
1627 21 02 1b			ld hl, crs_s3 
162a cd 4c 16			call .genfile 
162d c9				ret 
162e			 
162e			.genutlword: 
162e 21 0e 1b			ld hl, crs_s4 
1631 11 b1 16			ld de, .utilwordef 
1634 cd 4c 16			call .genfile 
1637 c9				ret 
1638			.genspiword: 
1638 21 15 1b			ld hl, crs_s5 
163b 11 f1 16			ld de, .spiworddef 
163e cd 4c 16			call .genfile 
1641 c9				ret 
1642			.genkeyword: 
1642 21 1f 1b			ld hl, crs_s6 
1645 11 ff 16			ld de, .keyworddef 
1648 cd 4c 16			call .genfile 
164b c9				ret 
164c			 
164c			; hl - points to file name 
164c			; de - points to strings to add to file 
164c			 
164c			.genfile: 
164c e5				push hl 
164d d5				push de 
164e			 
164e cd aa 0d			call clear_display 
1651 3e 00			ld a, display_row_1 
1653 11 7e 16			ld de, .genfiletxt 
1656 cd bd 0d			call str_at_display 
1659 cd cd 0d			call update_display 
165c			 
165c d1				pop de 
165d e1				pop hl 
165e			 
165e			 
165e d5				push de 
165f cd 77 08			call storage_create 
1662				; id in hl 
1662 d1				pop de   ; table of strings to add 
1663			 
1663			.genloop: 
1663			 
1663 e5				push hl ; save id for next time around 
1664 d5				push de ; save de for next time around 
1665			 
1665 eb				ex de, hl 
1666 cd 2a 23			call loadwordinhl 
1669 eb				ex de, hl 
166a			 
166a				; need hl to be the id 
166a				; need de to be the string ptr 
166a				 
166a cd 64 0b			call storage_append 
166d			 
166d d1				pop de 
166e e1				pop hl 
166f			 
166f 13				inc de 
1670 13				inc de 
1671			 
1671 1a				ld a,(de) 
1672 fe 00			cp 0 
1674 20 ed			jr nz, .genloop 
1676 13				inc de 
1677 1a				ld a, (de) 
1678 1b				dec de 
1679 fe 00			cp 0 
167b 20 e6			jr nz, .genloop	 
167d			 
167d c9				ret 
167e			 
167e .. 00		.genfiletxt:  db "Creating file...",0 
168f			 
168f			.hwworddef: 
168f 38 6c			dw test5 
1691 70 6c			dw test6 
1693 a8 6c			dw test7 
1695 bc 6c			dw test8 
1697 e8 6c			dw test9 
1699 fe 6c			dw test10 
169b 00 00			dw 0 
169d			 
169d			.soundworddef: 
169d 23 6d			dw sound1 
169f 47 6d			dw sound2 
16a1 77 6d			dw sound3 
16a3 9c 6d			dw sound4 
16a5 a9 6d			dw sound5 
16a7 b6 6d			dw sound6 
16a9 c3 6d			dw sound7 
16ab d0 6d			dw sound8 
16ad e8 6d			dw sound9 
16af 00 00			dw 0 
16b1			 
16b1			.utilwordef: 
16b1 5e 6a			dw strncpy 
16b3 39 6a			dw type 
16b5 bb 6b			dw tuck 
16b7 05 6a			dw clrstack 
16b9 be 69			dw longread 
16bb bf 6a			dw start1 
16bd cf 6a			dw start2 
16bf			; duplicated 
16bf			;	dw start3b 
16bf			;	dw start3c 
16bf ce 6b			dw list 
16c1 00 00			dw 0 
16c3			 
16c3			.lsworddef: 
16c3 e0 6a			dw start3b 
16c5 00 00			dw 0 
16c7			 
16c7			.edworddef: 
16c7 1d 66			dw edit1 
16c9 3e 66			dw edit2 
16cb 73 66			dw edit3 
16cd 00 00			dw 0 
16cf			 
16cf			.demoworddef: 
16cf ff 6d			dw game1 
16d1 10 6e			dw game1a 
16d3 72 6e			dw game1b 
16d5 a7 6e			dw game1c 
16d7 dd 6e			dw game1d 
16d9 0e 6f			dw game1s 
16db 22 6f			dw game1t 
16dd 37 6f			dw game1f 
16df 6b 6f			dw game1z 
16e1 af 6f			dw game1zz 
16e3 18 70			dw ssv2 
16e5 4e 70			dw ssv3 
16e7 6a 70			dw ssv4 
16e9 86 70			dw ssv5 
16eb 9f 70			dw ssv1 
16ed e7 70			dw ssv1cpm	 
16ef			;	dw game2b 
16ef			;	dw game2bf 
16ef			;	dw game2mba 
16ef			;	dw game2mbas	 
16ef			;	dw game2mbht 
16ef			;	dw game2mbms 
16ef			;	dw game2mb 
16ef			;	dw game3w 
16ef			;	dw game3p 
16ef			;	dw game3sc 
16ef			;	dw game3vsi 
16ef			;	dw game3vs 
16ef 00 00			dw 0 
16f1			 
16f1			 
16f1			.spiworddef: 
16f1			 
16f1 ab 66		    dw spi1 
16f3 04 67		    dw spi2 
16f5 38 67		    dw spi2b 
16f7 bc 67		    dw spi3 
16f9 66 67		    dw spi4 
16fb 8f 67		    dw spi5 
16fd			;    dw spi6 
16fd			;    dw spi7 
16fd			 
16fd			;    dw spi8 
16fd			;    dw spi9 
16fd			;    dw spi10 
16fd 00 00		    dw 0 
16ff			 
16ff			.keyworddef: 
16ff			 
16ff 3e 71			dw keyup 
1701 4c 71			dw keydown 
1703 5c 71			dw keyleft 
1705 6c 71			dw keyright 
1707 7d 71			dw 	keyf1 
1709 8b 71			dw keyf2 
170b 99 71			dw keyf3 
170d a7 71			dw keyf4 
170f b5 71			dw keyf5 
1711 c3 71			dw keyf6 
1713 d1 71			dw keyf7 
1715 df 71			dw keyf8 
1717 ed 71			dw keyf9 
1719 fb 71			dw keyf10 
171b 0a 72			dw keyf11 
171d 19 72			dw keyf12 
171f 28 72			dw keytab 
1721 37 72			dw keycr 
1723 45 72			dw keyhome 
1725 55 72			dw keyend 
1727 64 72			dw keybs 
1729 00 00			dw 0 
172b			 
172b			.crstart: 
172b f0 1a			dw crs_s1 
172d f9 1a			dw crs_s2 
172f 02 1b			dw crs_s3 
1731 0e 1b			dw crs_s4 
1733 15 1b			dw crs_s5 
1735 1f 1b			dw crs_s6 
1737 2e 1b			dw crs_sound 
1739 3a 1b			dw crs_hw 
173b 00 00			dw 0 
173d			 
173d			endif 
173d			 
173d			 
173d			if STORAGE_SE 
173d			 
173d			config_fdir: 
173d				; using the scratch dir go through and release the memory allocated for each string 
173d				 
173d 21 f3 f0			ld hl, scratch 
1740 5e			.cfdir:	ld e,(hl) 
1741 23				inc hl 
1742 56				ld d,(hl) 
1743 23				inc hl 
1744			 
1744 eb				ex de, hl 
1745 cd 07 10			call ishlzero 
1748 c8				ret z     ; return on null pointer 
1749 cd 83 14			call free 
174c eb				ex de, hl 
174d 18 f1			jr .cfdir 
174f			 
174f			 
174f c9				ret 
1750			 
1750			 
1750			config_dir: 
1750			 
1750				; for the config menus that need to build a directory of storage call this routine 
1750				; it will construct a menu in scratch to pass to menu 
1750			 
1750				; open storage device 
1750			 
1750				; execute DIR to build a list of files and their ids into scratch in menu format 
1750				; once the menu has finished then will need to call config_fdir to release the strings 
1750				 
1750				; c = number items 
1750			 
1750				 
1750 cd 25 05			call storage_get_block_0 
1753			 
1753 21 ac f9			ld hl, store_page     ; get current id count 
1756 46				ld b, (hl) 
1757 0e 00			ld c, 0    ; count of files   
1759			 
1759			 
1759 21 f3 f0			ld hl, scratch 
175c 22 a3 f9			ld (store_tmp2), hl    ; location to poke strings 
175f			 
175f				; check for empty drive 
175f			 
175f 3e 00			ld a, 0 
1761 b8				cp b 
1762 ca fc 17			jp z, .dirdone 
1765			 
1765				 
1765					if DEBUG_FORTH_WORDS 
1765						DMARK "Cdc" 
1765 f5				push af  
1766 3a 7a 17			ld a, (.dmark)  
1769 32 9d fd			ld (debug_mark),a  
176c 3a 7b 17			ld a, (.dmark+1)  
176f 32 9e fd			ld (debug_mark+1),a  
1772 3a 7c 17			ld a, (.dmark+2)  
1775 32 9f fd			ld (debug_mark+2),a  
1778 18 03			jr .pastdmark  
177a ..			.dmark: db "Cdc"  
177d f1			.pastdmark: pop af  
177e			endm  
# End of macro DMARK
177e						CALLMONITOR 
177e cd aa fd			call debug_vector  
1781				endm  
# End of macro CALLMONITOR
1781					endif 
1781			 
1781			 
1781			.diritem:	 
1781 c5				push bc 
1782				; for each of the current ids do a search for them and if found push to stack 
1782			 
1782 21 40 00				ld hl, STORE_BLOCK_PHY 
1785 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1787 58					ld e,b 
1788			 
1788 cd a7 07				call storage_findnextid 
178b			 
178b			 
178b					; if found hl will be non zero 
178b			 
178b cd 07 10				call ishlzero 
178e 28 69				jr z, .dirnotfound 
1790			 
1790					; increase count 
1790			 
1790 c1					pop bc	 
1791 0c					inc c 
1792 c5					push bc 
1793					 
1793			 
1793					; get file header and push the file name 
1793			 
1793 11 ac f9				ld de, store_page 
1796 cd 74 04				call storage_read_block 
1799			 
1799					; push file id to stack 
1799				 
1799 3a ac f9				ld a, (store_page) 
179c 26 00				ld h, 0 
179e 6f					ld l, a 
179f			 
179f					;call forth_push_numhl 
179f					; TODO store id 
179f			 
179f e5					push hl 
17a0			 
17a0					; push extent count to stack  
17a0				 
17a0 21 af f9				ld hl, store_page+3 
17a3			 
17a3					; get file name length 
17a3			 
17a3 cd 44 13				call strlenz   
17a6			 
17a6 23					inc hl   ; cover zero term 
17a7 23					inc hl  ; stick the id at the end of the area 
17a8			 
17a8 e5					push hl 
17a9 c1					pop bc    ; move length to bc 
17aa			 
17aa cd b9 13				call malloc 
17ad			 
17ad					; TODO save malloc area to scratch 
17ad			 
17ad eb					ex de, hl 
17ae 2a a3 f9				ld hl, (store_tmp2) 
17b1 73					ld (hl), e 
17b2 23					inc hl 
17b3 72					ld (hl), d 
17b4 23					inc hl 
17b5 22 a3 f9				ld (store_tmp2), hl 
17b8			 
17b8					 
17b8			 
17b8					;pop hl   ; get source 
17b8			;		ex de, hl    ; swap aronund	 
17b8			 
17b8 21 af f9				ld hl, store_page+3 
17bb					if DEBUG_FORTH_WORDS 
17bb						DMARK "CFd" 
17bb f5				push af  
17bc 3a d0 17			ld a, (.dmark)  
17bf 32 9d fd			ld (debug_mark),a  
17c2 3a d1 17			ld a, (.dmark+1)  
17c5 32 9e fd			ld (debug_mark+1),a  
17c8 3a d2 17			ld a, (.dmark+2)  
17cb 32 9f fd			ld (debug_mark+2),a  
17ce 18 03			jr .pastdmark  
17d0 ..			.dmark: db "CFd"  
17d3 f1			.pastdmark: pop af  
17d4			endm  
# End of macro DMARK
17d4						CALLMONITOR 
17d4 cd aa fd			call debug_vector  
17d7				endm  
# End of macro CALLMONITOR
17d7					endif 
17d7 ed b0				ldir 
17d9			 
17d9					; de is past string, move back one and store id 
17d9					 
17d9 1b					dec de 
17da			 
17da					; store file id 
17da			 
17da e1					pop hl 
17db eb					ex de,hl 
17dc 73					ld (hl), e 
17dd			 
17dd					if DEBUG_FORTH_WORDS 
17dd						DMARK "Cdi" 
17dd f5				push af  
17de 3a f2 17			ld a, (.dmark)  
17e1 32 9d fd			ld (debug_mark),a  
17e4 3a f3 17			ld a, (.dmark+1)  
17e7 32 9e fd			ld (debug_mark+1),a  
17ea 3a f4 17			ld a, (.dmark+2)  
17ed 32 9f fd			ld (debug_mark+2),a  
17f0 18 03			jr .pastdmark  
17f2 ..			.dmark: db "Cdi"  
17f5 f1			.pastdmark: pop af  
17f6			endm  
# End of macro DMARK
17f6						CALLMONITOR 
17f6 cd aa fd			call debug_vector  
17f9				endm  
# End of macro CALLMONITOR
17f9					endif 
17f9					 
17f9			.dirnotfound: 
17f9 c1					pop bc     
17fa 10 85				djnz .diritem 
17fc				 
17fc			.dirdone:	 
17fc			 
17fc 3e 00				ld a, 0 
17fe 2a a3 f9				ld hl, (store_tmp2) 
1801 77					ld (hl), a 
1802 23					inc hl 
1803 77					ld (hl), a 
1804 23					inc hl 
1805					; push a count of the dir items found 
1805			 
1805			;		ld h, 0 
1805			;		ld l, c 
1805			 
1805 c9				ret 
1806			 
1806			endif 
1806			 
1806			 
1806			; Settings 
1806			; Run  
1806			 
1806			 
1806			 
1806			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1806			;;hd_menu2:   db "        2: Editor",0   
1806			;hd_menu2:   db "        2: Editor       6: Menu",0   
1806			;hd_menu3:   db "        3: Storage",0 
1806			;hd_menu4:   db "0=quit  4: Debug",0 
1806			;hd_don:     db "ON",0 
1806			;hd_doff:     db "OFF",0 
1806			; 
1806			; 
1806			; 
1806			;hardware_diags_old:       
1806			; 
1806			;.diagmenu: 
1806			;	call clear_display 
1806			;	ld a, display_row_1 
1806			;	ld de, hd_menu1 
1806			;	call str_at_display 
1806			; 
1806			;	ld a, display_row_2 
1806			;	ld de, hd_menu2 
1806			;	call str_at_display 
1806			; 
1806			;	ld a, display_row_3 
1806			;	ld de, hd_menu3 
1806			;	call str_at_display 
1806			; 
1806			;	ld a,  display_row_4 
1806			;	ld de, hd_menu4 
1806			;	call str_at_display 
1806			; 
1806			;	; display debug state 
1806			; 
1806			;	ld de, hd_don 
1806			;	ld a, (os_view_disable) 
1806			;	cp 0 
1806			;	jr z, .distog 
1806			;	ld de, hd_doff 
1806			;.distog: ld a, display_row_4+17 
1806			;	call str_at_display 
1806			; 
1806			;	call update_display 
1806			; 
1806			;	call cin_wait 
1806			; 
1806			; 
1806			; 
1806			;	cp '4' 
1806			;	jr nz, .diagn1 
1806			; 
1806			;	; debug toggle 
1806			; 
1806			;	ld a, (os_view_disable) 
1806			;	ld b, '*' 
1806			;	cp 0 
1806			;	jr z, .debtog 
1806			;	ld b, 0 
1806			;.debtog:	 
1806			;	ld a,b 
1806			;	ld (os_view_disable),a 
1806			; 
1806			;.diagn1: cp '0' 
1806			;	 ret z 
1806			; 
1806			;;	cp '1' 
1806			;;       jp z, matrix	 
1806			;;   TODO keyboard matrix test 
1806			; 
1806			;	cp '2' 
1806			;	jp z, .diagedit 
1806			; 
1806			;;	cp '6' 
1806			;;	jp z, .menutest 
1806			;;if ENABLE_BASIC 
1806			;;	cp '6' 
1806			;;	jp z, basic 
1806			;;endif 
1806			 ; 
1806			;	jp .diagmenu 
1806			; 
1806			; 
1806			;	ret 
1806			 
1806			 
1806			.debug_tog: 
1806 21 2f 18			ld hl, .menudebug 
1809				 
1809			;	ld a, (os_view_disable) 
1809			;	cp '*' 
1809 3a aa fd			ld a,(debug_vector) 
180c fe c9			cp $C9   ; RET 
180e 20 04			jr nz,.tdon  
1810 3e 01			ld a, 1 
1812 18 02			jr .tog1 
1814 3e 00		.tdon: ld a, 0 
1816			 
1816			.tog1: 
1816 cd db 0d			call menu 
1819 fe 00			cp 0 
181b c8				ret z 
181c fe 01			cp 1    ; disable debug 
181e 28 04			jr z, .dtog0 
1820 3e 2a			ld a, '*' 
1822 18 05			jr .dtogset 
1824			.dtog0:  
1824				;ld a, 0 
1824 cd c3 18			call bp_on 
1827 18 dd			jr .debug_tog 
1829			.dtogset:  
1829				; ld (os_view_disable), a 
1829 cd cf 18			call bp_off 
182c c3 06 18			jp .debug_tog 
182f			 
182f			 
182f			.menudebug: 
182f 35 18				dw .m6 
1831 3e 18				dw .m7 
1833 00 00				dw 0 
1835 .. 00		.m6:   db "Debug ON",0 
183e .. 00		.m7:   db "Debug OFF",0 
1848			;hardware_diags:       
1848			 
1848			ENABLE_HDIAGS: equ 0 
1848			 
1848			if ENABLE_HDIAGS 
1848			.diagm: 
1848				ld hl, .menuitems 
1848				ld a, 0 
1848				call menu 
1848			 
1848			         cp 0 
1848				 ret z 
1848			 
1848				cp 2 
1848				jp z, .diagedit 
1848			 
1848			;	cp '6' 
1848			;	jp z, .menutest 
1848			;if ENABLE_BASIC 
1848			;	cp '6' 
1848			;	jp z, basic 
1848			;endif 
1848			  
1848				jp .diagm 
1848			 
1848				 
1848			.menuitems:   	dw .m1 
1848					dw .m2 
1848					dw .m3 
1848					dw .m5 
1848					dw .m5a 
1848					dw .m5b 
1848					dw 0 
1848			 
1848			 
1848			.m1:   db "Key Matrix",0 
1848			.m2:   db "Editor",0 
1848			.m3:   db "Storage",0 
1848			.m5:   db "Sound",0 
1848			.m5a:  db "RAM Test",0 
1848			.m5b:  db "LCD Test",0 
1848			 
1848			 
1848			; debug editor 
1848			 
1848			.diagedit: 
1848			 
1848				ld hl, scratch 
1848			;	ld bc, 250 
1848			;	ldir 
1848				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1848				ld a, 0 
1848				ld (hl), a 
1848				inc hl 
1848				ld (hl), a 
1848				inc hl 
1848				ld (hl), a 
1848			 
1848			        call clear_display 
1848				call update_display 
1848				;ld a, 1 
1848				;ld (hardware_diag), a 
1848			.diloop: 
1848				ld a, display_row_1 
1848				ld c, 0 
1848				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1848				ld e, 40 
1848			 
1848				ld hl, scratch	 
1848				call input_str 
1848			 
1848				ld a, display_row_2 
1848				ld de, scratch 
1848				call str_at_display 
1848				call update_display 
1848			 
1848				jp .diloop 
1848			endif 
1848			 
1848			; pass word in hl 
1848			; a has display location 
1848			display_word_at: 
1848 f5				push af 
1849 e5				push hl 
184a 7c				ld a,h 
184b 21 f8 f3			ld hl, os_word_scratch 
184e cd e7 11			call hexout 
1851 e1				pop hl 
1852 7d				ld a,l 
1853 21 fa f3			ld hl, os_word_scratch+2 
1856 cd e7 11			call hexout 
1859 21 fc f3			ld hl, os_word_scratch+4 
185c 3e 00			ld a,0 
185e 77				ld (hl),a 
185f 11 f8 f3			ld de,os_word_scratch 
1862 f1				pop af 
1863 cd bd 0d				call str_at_display 
1866 c9				ret 
1867			 
1867			display_ptr_state: 
1867			 
1867				; to restore afterwards 
1867			 
1867 d5				push de 
1868 c5				push bc 
1869 e5				push hl 
186a f5				push af 
186b			 
186b				; for use in here 
186b			 
186b			;	push bc 
186b			;	push de 
186b			;	push hl 
186b			;	push af 
186b			 
186b cd aa 0d			call clear_display 
186e			 
186e 11 46 1a			ld de, .ptrstate 
1871 3e 00			ld a, display_row_1 
1873 cd bd 0d			call str_at_display 
1876			 
1876				; display debug step 
1876			 
1876			 
1876 11 9d fd			ld de, debug_mark 
1879 3e 26			ld a, display_row_1+display_cols-2 
187b cd bd 0d			call str_at_display 
187e			 
187e				; display a 
187e 11 50 1a			ld de, .ptrcliptr 
1881 3e 28			ld a, display_row_2 
1883 cd bd 0d			call str_at_display 
1886			 
1886 f1				pop af 
1887 2a 72 f9			ld hl,(cli_ptr) 
188a 3e 30			ld a, display_row_2+8 
188c cd 48 18			call display_word_at 
188f			 
188f			 
188f				; display hl 
188f			 
188f			 
188f 11 58 1a			ld de, .ptrclioptr 
1892 3e 32			ld a, display_row_2+10 
1894 cd bd 0d			call str_at_display 
1897			; 
1897			;	pop hl 
1897 3e 35			ld a, display_row_2+13 
1899 2a 70 f9			ld hl,(cli_origptr) 
189c cd 48 18			call display_word_at 
189f			; 
189f			;	 
189f			;	; display de 
189f			 
189f			;	ld de, .regstatede 
189f			;	ld a, display_row_3 
189f			;	call str_at_display 
189f			 
189f			;	pop de 
189f			;	ld h,d 
189f			;	ld l, e 
189f			;	ld a, display_row_3+3 
189f			;	call display_word_at 
189f			 
189f			 
189f				; display bc 
189f			 
189f			;	ld de, .regstatebc 
189f			;	ld a, display_row_3+10 
189f			;	call str_at_display 
189f			 
189f			;	pop bc 
189f			;	ld h,b 
189f			;	ld l, c 
189f			;	ld a, display_row_3+13 
189f			;	call display_word_at 
189f			 
189f			 
189f				; display dsp 
189f			 
189f			;	ld de, .regstatedsp 
189f			;	ld a, display_row_4 
189f			;	call str_at_display 
189f			 
189f				 
189f			;	ld hl,(cli_data_sp) 
189f			;	ld a, display_row_4+4 
189f			;	call display_word_at 
189f			 
189f				; display rsp 
189f			 
189f 11 87 1a			ld de, .regstatersp 
18a2 3e 82			ld a, display_row_4+10 
18a4 cd bd 0d			call str_at_display 
18a7			 
18a7				 
18a7 2a 24 f9			ld hl,(cli_ret_sp) 
18aa 3e 86			ld a, display_row_4+14 
18ac cd 48 18			call display_word_at 
18af			 
18af cd cd 0d			call update_display 
18b2			 
18b2 cd ed 0c			call delay1s 
18b5 cd ed 0c			call delay1s 
18b8 cd ed 0c			call delay1s 
18bb			 
18bb			 
18bb cd 30 1f			call next_page_prompt 
18be			 
18be				; restore  
18be			 
18be f1				pop af 
18bf e1				pop hl 
18c0 c1				pop bc 
18c1 d1				pop de 
18c2 c9				ret 
18c3			 
18c3			; Update the break point vector so that the user can hook a new routine 
18c3			 
18c3			bp_on: 
18c3 3e c3			ld a, $c3    ; JP 
18c5 32 aa fd			ld (debug_vector), a 
18c8 21 d5 18			ld hl, break_point_state 
18cb 22 ab fd			ld (debug_vector+1), hl 
18ce c9				ret 
18cf			 
18cf			bp_off: 
18cf 3e c9			ld a, $c9    ; RET 
18d1 32 aa fd			ld (debug_vector), a 
18d4 c9				ret 
18d5			 
18d5			 
18d5			break_point_state: 
18d5			;	push af 
18d5			; 
18d5			;	; see if disabled 
18d5			; 
18d5			;	ld a, (os_view_disable) 
18d5			;	cp '*' 
18d5			;	jr nz, .bpsgo 
18d5			;	pop af 
18d5			;	ret 
18d5			 
18d5			.bpsgo: 
18d5			;	pop af 
18d5 f5				push af 
18d6 22 d5 f0			ld (os_view_hl), hl 
18d9 ed 53 d3 f0		ld (os_view_de), de 
18dd ed 43 d1 f0		ld (os_view_bc), bc 
18e1 e5				push hl 
18e2 6f				ld l, a 
18e3 26 00			ld h, 0 
18e5 22 d7 f0			ld (os_view_af),hl 
18e8			 
18e8 21 e3 fc				ld hl, display_fb0 
18eb 22 fe fa				ld (display_fb_active), hl 
18ee e1				pop hl	 
18ef			 
18ef 3e 31			ld a, '1' 
18f1 fe 2a		.bps1:  cp '*' 
18f3 cc cf 18			call z, bp_off 
18f6			;	jr nz, .bps1b 
18f6			;	ld (os_view_disable),a 
18f6 fe 31		.bps1b:  cp '1' 
18f8 20 14			jr nz, .bps2 
18fa			 
18fa				; display reg 
18fa			 
18fa				 
18fa			 
18fa 3a d7 f0			ld a, (os_view_af) 
18fd 2a d5 f0			ld hl, (os_view_hl) 
1900 ed 5b d3 f0		ld de, (os_view_de) 
1904 ed 4b d1 f0		ld bc, (os_view_bc) 
1908 cd a2 19			call display_reg_state 
190b c3 8e 19			jp .bpschk 
190e			 
190e fe 32		.bps2:  cp '2' 
1910 20 08			jr nz, .bps3 
1912				 
1912				; display hl 
1912 2a d5 f0			ld hl, (os_view_hl) 
1915 cd 8c 1a			call display_dump_at_hl 
1918			 
1918 18 74			jr .bpschk 
191a			 
191a fe 33		.bps3:  cp '3' 
191c 20 08			jr nz, .bps4 
191e			 
191e			        ; display de 
191e 2a d3 f0			ld hl, (os_view_de) 
1921 cd 8c 1a			call display_dump_at_hl 
1924			 
1924 18 68			jr .bpschk 
1926 fe 34		.bps4:  cp '4' 
1928 20 08			jr nz, .bps5 
192a			 
192a			        ; display bc 
192a 2a d1 f0			ld hl, (os_view_bc) 
192d cd 8c 1a			call display_dump_at_hl 
1930			 
1930 18 5c			jr .bpschk 
1932 fe 35		.bps5:  cp '5' 
1934 20 08		        jr nz, .bps7 
1936			 
1936				; display cur ptr 
1936 2a 72 f9			ld hl, (cli_ptr) 
1939 cd 8c 1a			call display_dump_at_hl 
193c			 
193c 18 50			jr .bpschk 
193e fe 36		.bps7:  cp '6' 
1940 20 08			jr nz, .bps8b 
1942				 
1942				; display cur orig ptr 
1942 2a 70 f9			ld hl, (cli_origptr) 
1945 cd 8c 1a			call display_dump_at_hl 
1948 18 44			jr .bpschk 
194a fe 37		.bps8b:  cp '7' 
194c 20 08			jr nz, .bps9 
194e				 
194e				; display dsp 
194e 2a 20 f9			ld hl, (cli_data_sp) 
1951 cd 8c 1a			call display_dump_at_hl 
1954			 
1954 18 38			jr .bpschk 
1956 fe 39		.bps9:  cp '9' 
1958 20 05			jr nz, .bps8c 
195a				 
195a				; display SP 
195a			;	ld hl, sp 
195a cd 8c 1a			call display_dump_at_hl 
195d			 
195d 18 2f			jr .bpschk 
195f fe 38		.bps8c:  cp '8' 
1961 20 08			jr nz, .bps8d 
1963				 
1963				; display rsp 
1963 2a 24 f9			ld hl, (cli_ret_sp) 
1966 cd 8c 1a			call display_dump_at_hl 
1969			 
1969 18 23			jr .bpschk 
196b fe 23		.bps8d:  cp '#'     ; access monitor sub system 
196d 20 05			jr nz, .bps8 
196f cd ea 1c			call monitor 
1972			 
1972 18 1a			jr .bpschk 
1974 fe 30		.bps8:  cp '0' 
1976 20 16			jr nz, .bpschk 
1978			 
1978 21 42 fc				ld hl, display_fb1 
197b 22 fe fa				ld (display_fb_active), hl 
197e cd cd 0d				call update_display 
1981			 
1981				;ld a, (os_view_af) 
1981 2a d5 f0			ld hl, (os_view_hl) 
1984 ed 5b d3 f0		ld de, (os_view_de) 
1988 ed 4b d1 f0		ld bc, (os_view_bc) 
198c f1				pop af 
198d c9				ret 
198e			 
198e			.bpschk:   
198e cd ed 0c			call delay1s 
1991 3e 9f		ld a,display_row_4 + display_cols - 1 
1993 11 2e 1f		        ld de, endprg 
1996 cd bd 0d			call str_at_display 
1999 cd cd 0d			call update_display 
199c cd e8 79			call cin_wait 
199f			 
199f c3 f1 18			jp .bps1 
19a2			 
19a2			 
19a2			display_reg_state: 
19a2			 
19a2				; to restore afterwards 
19a2			 
19a2 d5				push de 
19a3 c5				push bc 
19a4 e5				push hl 
19a5 f5				push af 
19a6			 
19a6				; for use in here 
19a6			 
19a6 c5				push bc 
19a7 d5				push de 
19a8 e5				push hl 
19a9 f5				push af 
19aa			 
19aa cd aa 0d			call clear_display 
19ad			 
19ad 11 62 1a			ld de, .regstate 
19b0 3e 00			ld a, display_row_1 
19b2 cd bd 0d			call str_at_display 
19b5			 
19b5				; display debug step 
19b5			 
19b5			 
19b5 11 9d fd			ld de, debug_mark 
19b8 3e 25			ld a, display_row_1+display_cols-3 
19ba cd bd 0d			call str_at_display 
19bd			 
19bd				; display a 
19bd 11 7e 1a			ld de, .regstatea 
19c0 3e 28			ld a, display_row_2 
19c2 cd bd 0d			call str_at_display 
19c5			 
19c5 e1				pop hl 
19c6			;	ld h,0 
19c6			;	ld l, a 
19c6 3e 2b			ld a, display_row_2+3 
19c8 cd 48 18			call display_word_at 
19cb			 
19cb			 
19cb				; display hl 
19cb			 
19cb			 
19cb 11 72 1a			ld de, .regstatehl 
19ce 3e 32			ld a, display_row_2+10 
19d0 cd bd 0d			call str_at_display 
19d3			 
19d3 e1				pop hl 
19d4 3e 35			ld a, display_row_2+13 
19d6 cd 48 18			call display_word_at 
19d9			 
19d9				 
19d9				; display de 
19d9			 
19d9 11 76 1a			ld de, .regstatede 
19dc 3e 50			ld a, display_row_3 
19de cd bd 0d			call str_at_display 
19e1			 
19e1 e1				pop hl 
19e2			;	ld h,d 
19e2			;	ld l, e 
19e2 3e 53			ld a, display_row_3+3 
19e4 cd 48 18			call display_word_at 
19e7			 
19e7			 
19e7				; display bc 
19e7			 
19e7 11 7a 1a			ld de, .regstatebc 
19ea 3e 5a			ld a, display_row_3+10 
19ec cd bd 0d			call str_at_display 
19ef			 
19ef e1				pop hl 
19f0			;	ld h,b 
19f0			;	ld l, c 
19f0 3e 5d			ld a, display_row_3+13 
19f2 cd 48 18			call display_word_at 
19f5			 
19f5			 
19f5				; display dsp 
19f5			 
19f5 11 82 1a			ld de, .regstatedsp 
19f8 3e 78			ld a, display_row_4 
19fa cd bd 0d			call str_at_display 
19fd			 
19fd				 
19fd 2a 20 f9			ld hl,(cli_data_sp) 
1a00 3e 7c			ld a, display_row_4+4 
1a02 cd 48 18			call display_word_at 
1a05			 
1a05				; display rsp 
1a05			 
1a05 11 87 1a			ld de, .regstatersp 
1a08 3e 82			ld a, display_row_4+10 
1a0a cd bd 0d			call str_at_display 
1a0d			 
1a0d				 
1a0d 2a 24 f9			ld hl,(cli_ret_sp) 
1a10 3e 86			ld a, display_row_4+14 
1a12 cd 48 18			call display_word_at 
1a15			 
1a15 cd cd 0d			call update_display 
1a18			 
1a18			;	call delay1s 
1a18			;	call delay1s 
1a18			;	call delay1s 
1a18			 
1a18			 
1a18			;	call next_page_prompt 
1a18			 
1a18				; restore  
1a18			 
1a18 f1				pop af 
1a19 e1				pop hl 
1a1a c1				pop bc 
1a1b d1				pop de 
1a1c c9				ret 
1a1d			 
1a1d .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a31 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a46 .. 00		.ptrstate:	db "Ptr State",0 
1a50 .. 00		.ptrcliptr:     db "cli_ptr",0 
1a58 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a62 .. 00		.regstate:	db "Reg State (1/0)",0 
1a72 .. 00		.regstatehl:	db "HL:",0 
1a76 .. 00		.regstatede:	db "DE:",0 
1a7a .. 00		.regstatebc:	db "BC:",0 
1a7e .. 00		.regstatea:	db "A :",0 
1a82 .. 00		.regstatedsp:	db "DSP:",0 
1a87 .. 00		.regstatersp:	db "RSP:",0 
1a8c			 
1a8c			display_dump_at_hl: 
1a8c e5				push hl 
1a8d d5				push de 
1a8e c5				push bc 
1a8f f5				push af 
1a90			 
1a90 22 16 f4			ld (os_cur_ptr),hl	 
1a93 cd aa 0d			call clear_display 
1a96 cd 38 1e			call dumpcont 
1a99			;	call delay1s 
1a99			;	call next_page_prompt 
1a99			 
1a99			 
1a99 f1				pop af 
1a9a c1				pop bc 
1a9b d1				pop de 
1a9c e1				pop hl 
1a9d c9				ret 
1a9e			 
1a9e			;if ENABLE_BASIC 
1a9e			;	include "nascombasic.asm" 
1a9e			;	basic: 
1a9e			;	include "forth/FORTH.ASM" 
1a9e			;endif 
1a9e			 
1a9e			; eof 
1a9e			 
1a9e			 
# End of file firmware_diags.asm
1a9e			  
1a9e			include "firmware_prompts.asm"  
1a9e			; Prompts  
1a9e			 
1a9e			; boot messages 
1a9e			 
1a9e .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1ab3 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1ac3			 
1ac3			 
1ac3			; config menus 
1ac3			 
1ac3			;prom_c3: db "Add Dictionary To File",0 
1ac3			 
1ac3			if STARTUP_V1 
1ac3			prom_c2: db "Select Autoload File",0 
1ac3			prom_c2a: db "Disable Autoload File", 0 
1ac3			endif 
1ac3			 
1ac3			if STARTUP_V2 
1ac3 .. 00		prom_c2: db "Enable Autoload Files",0 
1ad9 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1af0			 
1af0 .. 00		crs_s1: db "*ls-word", 0 
1af9 .. 00		crs_s2: db "*ed-word", 0 
1b02 .. 00		crs_s3: db "*Demo-Games", 0 
1b0e .. 00		crs_s4: db "*Utils", 0 
1b15 .. 00		crs_s5: db "*SPI-Util", 0 
1b1f .. 00		crs_s6: db "*Key-Constants", 0 
1b2e .. 00		crs_sound: db "*Sound-Util", 0 
1b3a .. 00		crs_hw: db "*Hello-World",0 
1b47			 
1b47			 
1b47			 
1b47			endif 
1b47			;prom_c2b: db "Select Storage Bank",0 
1b47 .. 00		prom_c4: db "Settings",0 
1b50 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b6b .. 00		prom_m4b:   db "Monitor",0 
1b73			;prom_c1: db "Hardware Diags",0 
1b73			 
1b73			 
1b73			if STARTUP_V2 
1b73 .. 00		prom_c9: db "Create Startup Files",0 
1b88			endif 
1b88			 
1b88 .. 00		prom_notav:    db "Feature not available",0 
1b9e .. 00		prom_empty:    db "",0 
1b9f			 
1b9f			; eof 
1b9f			 
# End of file firmware_prompts.asm
1b9f			  
1b9f			; eof  
1b9f			  
# End of file firmware.asm
1b9f			 
1b9f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b9f			;if BASE_KEV  
1b9f			;baseram: equ 08000h 
1b9f			;endif 
1b9f			 
1b9f			;if BASE_SC114 
1b9f			;baseram:     equ    endofcode 
1b9f			;endif 
1b9f			 
1b9f			 
1b9f			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1b9f			 
1b9f			; start system 
1b9f			 
1b9f			coldstart: 
1b9f				; set sp 
1b9f				; di/ei 
1b9f			 
1b9f f3				di 
1ba0 31 fd ff			ld sp, tos 
1ba3 cd 6f 76			call init_nmi 
1ba6			;	ei 
1ba6			 
1ba6				; init spinner 
1ba6 3e 00			ld a,0 
1ba8 32 f8 fa			ld (display_active), a 
1bab			 
1bab				; disable breakpoint by default 
1bab			 
1bab				;ld a,'*' 
1bab			;	ld a,' ' 
1bab			;	ld (os_view_disable),a 
1bab			 
1bab				; set break point vector as new break point on or off 
1bab cd cf 18			call bp_off 
1bae			 
1bae			 
1bae				; default the parse vector to just a RET 
1bae 3e c9			ld a, $c9 
1bb0 32 a7 fd			ld (parse_vector), a 
1bb3			 
1bb3				; init hardware 
1bb3			 
1bb3				; init keyboard and screen hardware 
1bb3			 
1bb3 cd 6c 00			call hardware_init 
1bb6			 
1bb6			 
1bb6 cd ed 0c			call delay1s 
1bb9 3e 58			ld a, display_row_3+8 
1bbb 11 03 00			ld de, buildtime 
1bbe cd bd 0d			call str_at_display 
1bc1 cd cd 0d			call update_display 
1bc4			 
1bc4 cd ed 0c			call delay1s 
1bc7 cd ed 0c			call delay1s 
1bca cd ed 0c			call delay1s 
1bcd			 
1bcd				; detect if any keys are held down to enable breakpoints at start up 
1bcd			 
1bcd cd f9 79			call cin  
1bd0 fe 00			cp 0 
1bd2 28 03			jr z, .nokeys 
1bd4			 
1bd4				;call hardware_diags 
1bd4 cd 52 15			call config 
1bd7			 
1bd7			;	ld de, .bpen 
1bd7			;	ld a, display_row_4 
1bd7			;	call str_at_display 
1bd7			;	call update_display 
1bd7			; 
1bd7			;	ld a,0 
1bd7			;	ld (os_view_disable),a 
1bd7			; 
1bd7			;.bpwait: 
1bd7			;	call cin 
1bd7			;	cp 0 
1bd7			;	jr z, .bpwait 
1bd7			;	jr .nokeys 
1bd7			; 
1bd7			; 
1bd7			;.bpen:  db "Break points enabled!",0 
1bd7			 
1bd7			 
1bd7			 
1bd7			 
1bd7			 
1bd7			 
1bd7			.nokeys: 
1bd7			 
1bd7			 
1bd7				 
1bd7			 
1bd7			;jp  testkey 
1bd7			 
1bd7			;call storage_get_block_0 
1bd7			; 
1bd7			;ld hl, 0 
1bd7			;ld de, store_page 
1bd7			;call storage_read_block 
1bd7			 
1bd7				 
1bd7			;ld hl, 10 
1bd7			;ld de, store_page 
1bd7			;call storage_read_block 
1bd7			 
1bd7			 
1bd7			 
1bd7			 
1bd7			 
1bd7			;stop:	nop 
1bd7			;	jp stop 
1bd7			 
1bd7			 
1bd7			 
1bd7			main: 
1bd7 cd aa 0d			call clear_display 
1bda cd cd 0d			call update_display 
1bdd			 
1bdd			 
1bdd			 
1bdd			;	call testlcd 
1bdd			 
1bdd			 
1bdd			 
1bdd cd 78 23			call forth_init 
1be0			 
1be0			 
1be0			warmstart: 
1be0 cd 4e 23			call forth_warmstart 
1be3			 
1be3				; run startup word load 
1be3			        ; TODO prevent this running at warmstart after crash  
1be3			 
1be3				if STARTUP_ENABLE 
1be3			 
1be3					if STARTUP_V1 
1be3			 
1be3						if STORAGE_SE 
1be3							call forth_autoload 
1be3						endif 
1be3						call forth_startup 
1be3					endif 
1be3			 
1be3					if STARTUP_V2 
1be3			 
1be3						if STORAGE_SE 
1be3 cd 9d 74						call forth_autoload 
1be6						else 
1be6							call forth_startup 
1be6						endif 
1be6			 
1be6			 
1be6					endif 
1be6			 
1be6				endif 
1be6			 
1be6			warmstart_afterauto: 
1be6			 
1be6				; show free memory after boot 
1be6 11 85 1c			ld de, freeram 
1be9 3e 00			ld a, display_row_1 
1beb cd bd 0d			call str_at_display 
1bee			 
1bee				; get current heap start after loading any uwords 
1bee			 
1bee				;ld de, (os_last_new_uword) 
1bee				;ex de, hl 
1bee			 
1bee			; Or use heap_size word???? 
1bee				;ld hl, heap_end 
1bee				;ld hl, heap_size 
1bee				;ld de, topusermem 
1bee				;ld de, heap_start 
1bee ed 5b 0a 80			ld de, (free_list )      
1bf2 21 ce f0				ld hl, heap_end 
1bf5 ed 52			sbc hl, de 
1bf7				;push hl 
1bf7				;ld a,h	         	 
1bf7				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bf7				;call hexout 
1bf7			   	;pop hl 
1bf7			; 
1bf7			;	ld a,l 
1bf7			;	ld hl, os_word_scratch+2 
1bf7			;	call hexout 
1bf7			;	ld hl, os_word_scratch+4 
1bf7			;	ld a, 0 
1bf7			;	ld (hl),a 
1bf7 eb				ex de, hl 
1bf8 21 f8 f3			ld hl, os_word_scratch 
1bfb cd f3 12			call uitoa_16 
1bfe			 
1bfe			 
1bfe 11 f8 f3			ld de, os_word_scratch 
1c01 3e 0d			ld a, display_row_1 + 13 
1c03 cd bd 0d			call str_at_display 
1c06 cd cd 0d			call update_display 
1c09			 
1c09			 
1c09				;call demo 
1c09			 
1c09			 
1c09				; init scratch input area for cli commands 
1c09			 
1c09 21 1a f4			ld hl, os_cli_cmd 
1c0c 3e 00			ld a,0 
1c0e 77				ld (hl),a 
1c0f 23				inc hl 
1c10 77				ld (hl),a 
1c11			 
1c11 3e 00			ld a,0 
1c13 32 19 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c16			 
1c16 32 16 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1c19 32 17 f4			ld (os_cur_ptr+1),a	 
1c1c			 
1c1c 32 f8 f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1c1f 32 f9 f3			ld (os_word_scratch+1),a	 
1c22				 
1c22			 
1c22				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c22 21 1a f4			ld hl, os_cli_cmd 
1c25			 
1c25 3e 00			ld a, 0		 ; init cli input 
1c27 77				ld (hl), a 
1c28 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c2a			cli: 
1c2a				; show cli prompt 
1c2a				;push af 
1c2a				;ld a, 0 
1c2a				;ld de, prompt 
1c2a				;call str_at_display 
1c2a			 
1c2a				;call update_display 
1c2a				;pop af 
1c2a				;inc a 
1c2a				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c2a			 
1c2a			.lastrecall: 
1c2a			 
1c2a 0e 00			ld c, 0 
1c2c 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1c2e 1e 28			ld e, 40 
1c30			 
1c30 21 1a f4			ld hl, os_cli_cmd 
1c33			 
1c33				STACKFRAME OFF $fefe $9f9f 
1c33				if DEBUG_STACK_IMB 
1c33					if OFF 
1c33						exx 
1c33						ld de, $fefe 
1c33						ld a, d 
1c33						ld hl, curframe 
1c33						call hexout 
1c33						ld a, e 
1c33						ld hl, curframe+2 
1c33						call hexout 
1c33						ld hl, $fefe 
1c33						push hl 
1c33						ld hl, $9f9f 
1c33						push hl 
1c33						exx 
1c33					endif 
1c33				endif 
1c33			endm 
# End of macro STACKFRAME
1c33			 
1c33 cd 0b 10			call input_str 
1c36			 
1c36				STACKFRAMECHK OFF $fefe $9f9f 
1c36				if DEBUG_STACK_IMB 
1c36					if OFF 
1c36						exx 
1c36						ld hl, $9f9f 
1c36						pop de   ; $9f9f 
1c36						call cmp16 
1c36						jr nz, .spnosame 
1c36						ld hl, $fefe 
1c36						pop de   ; $fefe 
1c36						call cmp16 
1c36						jr z, .spfrsame 
1c36						.spnosame: call showsperror 
1c36						.spfrsame: nop 
1c36						exx 
1c36					endif 
1c36				endif 
1c36			endm 
# End of macro STACKFRAMECHK
1c36			 
1c36			 
1c36				; check to see if last line recall has been requested 
1c36			 
1c36			if EDIT_V2 
1c36 fe 05			cp KEY_UP 
1c38 20 0f			jr nz, .noexecline 
1c3a			 
1c3a 11 1a f4			ld de, os_cli_cmd 
1c3d 21 19 f5			ld hl, os_last_cmd 
1c40 01 ff 00			ld bc, 255 
1c43 ed b0			ldir 
1c45 3e 00			ld a, 0 
1c47 18 e1			jr .lastrecall 
1c49			endif 
1c49			 
1c49			.noexecline: 
1c49				; no so exec the line		 
1c49			 
1c49				; copy input to last command 
1c49			 
1c49 21 1a f4			ld hl, os_cli_cmd 
1c4c 11 19 f5			ld de, os_last_cmd 
1c4f 01 ff 00			ld bc, 255 
1c52 ed b0			ldir 
1c54			 
1c54				; wipe current buffer 
1c54			 
1c54			;	ld a, 0 
1c54			;	ld hl, os_cli_cmd 
1c54			;	ld de, os_cli_cmd+1 
1c54			;	ld bc, 254 
1c54			;	ldir 
1c54				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c54			;	call strcpy 
1c54			;	ld a, 0 
1c54			;	ld (hl), a 
1c54			;	inc hl 
1c54			;	ld (hl), a 
1c54			;	inc hl 
1c54			;	ld (hl), a 
1c54			 
1c54				; switch frame buffer to program  
1c54			 
1c54 21 42 fc				ld hl, display_fb1 
1c57 22 fe fa				ld (display_fb_active), hl 
1c5a			 
1c5a			;	nop 
1c5a				STACKFRAME ON $fbfe $8f9f 
1c5a				if DEBUG_STACK_IMB 
1c5a					if ON 
1c5a						exx 
1c5a						ld de, $fbfe 
1c5a						ld a, d 
1c5a						ld hl, curframe 
1c5a						call hexout 
1c5a						ld a, e 
1c5a						ld hl, curframe+2 
1c5a						call hexout 
1c5a						ld hl, $fbfe 
1c5a						push hl 
1c5a						ld hl, $8f9f 
1c5a						push hl 
1c5a						exx 
1c5a					endif 
1c5a				endif 
1c5a			endm 
# End of macro STACKFRAME
1c5a				; first time into the parser so pass over the current scratch pad 
1c5a 21 1a f4			ld hl,os_cli_cmd 
1c5d				; tokenise the entered statement(s) in HL 
1c5d cd f2 23			call forthparse 
1c60			        ; exec forth statements in top of return stack 
1c60 cd 2e 24			call forthexec 
1c63				;call forthexec_cleanup 
1c63			;	call parsenext 
1c63			 
1c63				STACKFRAMECHK ON $fbfe $8f9f 
1c63				if DEBUG_STACK_IMB 
1c63					if ON 
1c63						exx 
1c63						ld hl, $8f9f 
1c63						pop de   ; $8f9f 
1c63						call cmp16 
1c63						jr nz, .spnosame 
1c63						ld hl, $fbfe 
1c63						pop de   ; $fbfe 
1c63						call cmp16 
1c63						jr z, .spfrsame 
1c63						.spnosame: call showsperror 
1c63						.spfrsame: nop 
1c63						exx 
1c63					endif 
1c63				endif 
1c63			endm 
# End of macro STACKFRAMECHK
1c63				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c63			 
1c63 3e 78			ld a, display_row_4 
1c65 11 96 1c			ld de, endprog 
1c68			 
1c68 cd cd 0d			call update_display		 
1c6b			 
1c6b cd 30 1f			call next_page_prompt 
1c6e			 
1c6e				; switch frame buffer to cli 
1c6e			 
1c6e 21 e3 fc				ld hl, display_fb0 
1c71 22 fe fa				ld (display_fb_active), hl 
1c74			 
1c74			 
1c74 cd aa 0d		        call clear_display 
1c77 cd cd 0d			call update_display		 
1c7a			 
1c7a 21 1a f4			ld hl, os_cli_cmd 
1c7d			 
1c7d 3e 00			ld a, 0		 ; init cli input 
1c7f 77				ld (hl), a 
1c80			 
1c80				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c80			 
1c80				; now on last line 
1c80			 
1c80				; TODO scroll screen up 
1c80			 
1c80				; TODO instead just clear screen and place at top of screen 
1c80			 
1c80			;	ld a, 0 
1c80			;	ld (f_cursor_ptr),a 
1c80			 
1c80				;call clear_display 
1c80				;call update_display 
1c80			 
1c80				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c80 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c82 c3 2a 1c			jp cli 
1c85			 
1c85 .. 00		freeram: db "Free bytes: ",0 
1c92 ..			asc: db "1A2F" 
1c96 .. 00		endprog: db "End prog...",0 
1ca2			 
1ca2			testenter2:   
1ca2 21 25 f1			ld hl,scratch+50 
1ca5 22 16 f4			ld (os_cur_ptr),hl 
1ca8 c3 2a 1c			jp cli 
1cab			 
1cab			testenter:  
1cab			 
1cab 21 92 1c			ld hl,asc 
1cae			;	ld a,(hl) 
1cae			;	call nibble2val 
1cae cd 3d 12			call get_byte 
1cb1			 
1cb1			 
1cb1			;	ld a,(hl) 
1cb1			;	call atohex 
1cb1			 
1cb1			;	call fourehexhl 
1cb1 32 25 f1			ld (scratch+50),a 
1cb4			 
1cb4			 
1cb4			 
1cb4 21 94 1c			ld hl,asc+2 
1cb7			;	ld a, (hl) 
1cb7			;	call nibble2val 
1cb7 cd 3d 12			call get_byte 
1cba			 
1cba			;	call fourehexhl 
1cba 32 27 f1			ld (scratch+52),a 
1cbd				 
1cbd 21 25 f1			ld hl,scratch+50 
1cc0 22 16 f4			ld (os_cur_ptr),hl 
1cc3 c3 2a 1c			jp cli 
1cc6			 
1cc6			enter:	 
1cc6 3a f7 f0			ld a,(scratch+4) 
1cc9 fe 00			cp 0 
1ccb 28 0c			jr z, .entercont 
1ccd				; no, not a null term line so has an address to work out.... 
1ccd			 
1ccd 21 f5 f0			ld hl,scratch+2 
1cd0 cd 9d 12			call get_word_hl 
1cd3			 
1cd3 22 16 f4			ld (os_cur_ptr),hl	 
1cd6 c3 2a 1c			jp cli 
1cd9			 
1cd9			 
1cd9			.entercont:  
1cd9			 
1cd9 21 f5 f0			ld hl, scratch+2 
1cdc cd 3d 12			call get_byte 
1cdf			 
1cdf 2a 16 f4		   	ld hl,(os_cur_ptr) 
1ce2 77					ld (hl),a 
1ce3 23					inc hl 
1ce4 22 16 f4				ld (os_cur_ptr),hl 
1ce7				 
1ce7			; get byte  
1ce7			 
1ce7			 
1ce7 c3 2a 1c			jp cli 
1cea			 
1cea			 
1cea			; basic monitor support 
1cea			 
1cea			monitor: 
1cea				;  
1cea cd aa 0d			call clear_display 
1ced 3e 00			ld a, 0 
1cef 11 43 1d			ld de, .monprompt 
1cf2 cd bd 0d			call str_at_display 
1cf5 cd cd 0d			call update_display 
1cf8			 
1cf8				; get a monitor command 
1cf8			 
1cf8 0e 00			ld c, 0     ; entry at top left 
1cfa 16 64			ld d, 100   ; max buffer size 
1cfc 1e 0f			ld e, 15    ; input scroll area 
1cfe 3e 00			ld a, 0     ; init string 
1d00 21 f1 f2			ld hl, os_input 
1d03 77				ld (hl), a 
1d04 23				inc hl 
1d05 77				ld (hl), a 
1d06 21 f1 f2			ld hl, os_input 
1d09 3e 01			ld a, 1     ; init string 
1d0b cd 0b 10			call input_str 
1d0e			 
1d0e cd aa 0d		        call clear_display 
1d11 cd cd 0d			call update_display		 
1d14			 
1d14 3a f1 f2			ld a, (os_input) 
1d17 cd 3b 13			call toUpper 
1d1a fe 48		        cp 'H' 
1d1c ca b7 1d		        jp z, .monhelp 
1d1f fe 44			cp 'D'		; dump 
1d21 ca ea 1d			jp z, .mondump	 
1d24 fe 43			cp 'C'		; dump 
1d26 ca 04 1e			jp z, .moncdump	 
1d29 fe 4d			cp 'M'		; dump 
1d2b ca 45 1d			jp z, .moneditstart 
1d2e fe 55			cp 'U'		; dump 
1d30 ca 51 1d			jp z, .monedit	 
1d33 fe 47			cp 'G'		; dump 
1d35 ca e0 1d			jp z, .monjump 
1d38 fe 42			cp 'B'		; forth breakpoint 
1d3a cc d5 18			call z, break_point_state 
1d3d fe 51			cp 'Q'		; dump 
1d3f c8				ret z	 
1d40			 
1d40			 
1d40				; TODO "S" to access symbol by name and not need the address 
1d40				; TODO "F" to find a string in memory 
1d40			 
1d40 c3 ea 1c			jp monitor 
1d43			 
1d43 .. 00		.monprompt: db ">", 0 
1d45			 
1d45			.moneditstart: 
1d45				; get starting address 
1d45			 
1d45 21 f3 f2			ld hl,os_input+2 
1d48 cd 9d 12			call get_word_hl 
1d4b			 
1d4b 22 16 f4			ld (os_cur_ptr),hl	 
1d4e			 
1d4e c3 ea 1c			jp monitor 
1d51			 
1d51			.monedit: 
1d51				; get byte to load 
1d51			 
1d51 21 f3 f2			ld hl,os_input+2 
1d54 cd 3d 12			call get_byte 
1d57			 
1d57				; get address to update 
1d57 2a 16 f4			ld hl, (os_cur_ptr) 
1d5a			 
1d5a				; update byte 
1d5a			 
1d5a 77				ld (hl), a 
1d5b			 
1d5b				; move to next address and save it 
1d5b			 
1d5b 23				inc hl 
1d5c 22 16 f4			ld (os_cur_ptr),hl	 
1d5f			 
1d5f c3 ea 1c			jp monitor 
1d62			 
1d62			 
1d62 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d76 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d92 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1db0 .. 00		.monhelptext4:  db "Q-Quit",0 
1db7			        
1db7			.monhelp: 
1db7 3e 00			ld a, display_row_1 
1db9 11 62 1d		        ld de, .monhelptext1 
1dbc			 
1dbc cd bd 0d			call str_at_display 
1dbf 3e 28			ld a, display_row_2 
1dc1 11 76 1d		        ld de, .monhelptext2 
1dc4					 
1dc4 cd bd 0d			call str_at_display 
1dc7 3e 50			ld a, display_row_3 
1dc9 11 92 1d		        ld de, .monhelptext3 
1dcc					 
1dcc cd bd 0d			call str_at_display 
1dcf 3e 78			ld a, display_row_4 
1dd1 11 b0 1d		        ld de, .monhelptext4 
1dd4 cd bd 0d			call str_at_display 
1dd7			 
1dd7 cd cd 0d			call update_display		 
1dda			 
1dda cd 30 1f			call next_page_prompt 
1ddd c3 ea 1c			jp monitor 
1de0			 
1de0			.monjump:    
1de0 21 f3 f2			ld hl,os_input+2 
1de3 cd 9d 12			call get_word_hl 
1de6			 
1de6 e9				jp (hl) 
1de7 c3 ea 1c			jp monitor 
1dea			 
1dea			.mondump:    
1dea 21 f3 f2			ld hl,os_input+2 
1ded cd 9d 12			call get_word_hl 
1df0			 
1df0 22 16 f4			ld (os_cur_ptr),hl	 
1df3 cd 38 1e			call dumpcont 
1df6 3e 78			ld a, display_row_4 
1df8 11 96 1c			ld de, endprog 
1dfb			 
1dfb cd cd 0d			call update_display		 
1dfe			 
1dfe cd 30 1f			call next_page_prompt 
1e01 c3 ea 1c			jp monitor 
1e04			.moncdump: 
1e04 cd 38 1e			call dumpcont 
1e07 3e 78			ld a, display_row_4 
1e09 11 96 1c			ld de, endprog 
1e0c			 
1e0c cd cd 0d			call update_display		 
1e0f			 
1e0f cd 30 1f			call next_page_prompt 
1e12 c3 ea 1c			jp monitor 
1e15			 
1e15			 
1e15			; TODO symbol access  
1e15			 
1e15			.symbols:     ;; A list of symbols that can be called up  
1e15 e3 fc			dw display_fb0 
1e17 .. 00			db "fb0",0  
1e1b ac f9		     	dw store_page 
1e1d .. 00			db "store_page",0 
1e28			 
1e28			 
1e28			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1e28			 
1e28 3a f4 f0			ld a,(scratch+1) 
1e2b fe 00			cp 0 
1e2d 28 09			jr z, dumpcont 
1e2f			 
1e2f				; no, not a null term line so has an address to work out.... 
1e2f			 
1e2f 21 f5 f0			ld hl,scratch+2 
1e32 cd 9d 12			call get_word_hl 
1e35			 
1e35 22 16 f4			ld (os_cur_ptr),hl	 
1e38			 
1e38			 
1e38			 
1e38			dumpcont: 
1e38			 
1e38				; dump bytes at ptr 
1e38			 
1e38			 
1e38 3e 00			ld a, display_row_1 
1e3a 2a fe fa			ld hl, (display_fb_active) 
1e3d cd de 0f			call addatohl 
1e40 cd 68 1e			call .dumpbyterow 
1e43			 
1e43 3e 28			ld a, display_row_2 
1e45 2a fe fa			ld hl, (display_fb_active) 
1e48 cd de 0f			call addatohl 
1e4b cd 68 1e			call .dumpbyterow 
1e4e			 
1e4e			 
1e4e 3e 50			ld a, display_row_3 
1e50 2a fe fa			ld hl, (display_fb_active) 
1e53 cd de 0f			call addatohl 
1e56 cd 68 1e			call .dumpbyterow 
1e59			 
1e59 3e 78			ld a, display_row_4 
1e5b 2a fe fa			ld hl, (display_fb_active) 
1e5e cd de 0f			call addatohl 
1e61 cd 68 1e			call .dumpbyterow 
1e64			 
1e64 cd cd 0d			call update_display 
1e67			;		jp cli 
1e67 c9				ret 
1e68			 
1e68			.dumpbyterow: 
1e68			 
1e68				;push af 
1e68			 
1e68 e5				push hl 
1e69			 
1e69				; calc where to poke the ascii 
1e69			if display_cols == 20 
1e69				ld a, 16 
1e69			else 
1e69 3e 1f			ld a, 31 
1e6b			endif 
1e6b			 
1e6b cd de 0f			call addatohl 
1e6e 22 f8 f3			ld (os_word_scratch),hl  		; save pos for later 
1e71			 
1e71			 
1e71			; display decoding address 
1e71 2a 16 f4		   	ld hl,(os_cur_ptr) 
1e74			 
1e74 7c				ld a,h 
1e75 e1				pop hl 
1e76 e5				push hl 
1e77			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1e77 cd e7 11			call hexout 
1e7a 2a 16 f4		   	ld hl,(os_cur_ptr) 
1e7d			 
1e7d 7d				ld a,l 
1e7e e1				pop hl 
1e7f 23				inc hl 
1e80 23				inc hl 
1e81 e5				push hl 
1e82			;	ld hl, os_word_scratch+2 
1e82 cd e7 11			call hexout 
1e85 e1				pop hl 
1e86 23				inc hl 
1e87 23				inc hl 
1e88				;ld hl, os_word_scratch+4 
1e88 3e 3a			ld a, ':' 
1e8a 77				ld (hl),a 
1e8b 23				inc hl 
1e8c				;ld a, 0 
1e8c				;ld (hl),a 
1e8c				;ld de, os_word_scratch 
1e8c				;pop af 
1e8c				;push af 
1e8c			;		ld a, display_row_2 
1e8c			;		call str_at_display 
1e8c			;		call update_display 
1e8c			 
1e8c			 
1e8c			;pop af 
1e8c			;	add 5 
1e8c			 
1e8c			if display_cols == 20 
1e8c				ld b, 4 
1e8c			else 
1e8c 06 08			ld b, 8 
1e8e			endif	 
1e8e			 
1e8e			.dumpbyte: 
1e8e c5				push bc 
1e8f e5				push hl 
1e90			 
1e90			 
1e90 2a 16 f4		   	ld hl,(os_cur_ptr) 
1e93 7e					ld a,(hl) 
1e94			 
1e94					; poke the ascii to display 
1e94 2a f8 f3				ld hl,(os_word_scratch) 
1e97 77					ld (hl),a 
1e98 23					inc hl 
1e99 22 f8 f3				ld (os_word_scratch),hl 
1e9c			 
1e9c					 
1e9c			 
1e9c			 
1e9c e1					pop hl 
1e9d e5					push hl 
1e9e			 
1e9e cd e7 11				call hexout 
1ea1			 
1ea1					 
1ea1 2a 16 f4		   	ld hl,(os_cur_ptr) 
1ea4 23				inc hl 
1ea5 22 16 f4		   	ld (os_cur_ptr),hl 
1ea8			 
1ea8 e1					pop hl 
1ea9 23					inc hl 
1eaa 23					inc hl 
1eab 23					inc hl 
1eac			 
1eac			 
1eac			 
1eac					;ld a,0 
1eac					;ld (os_word_scratch+2),a 
1eac					;pop af 
1eac					;push af 
1eac			 
1eac					;ld de, os_word_scratch 
1eac					;call str_at_display 
1eac			;		call update_display 
1eac			;		pop af 
1eac c1					pop bc 
1ead c6 03				add 3 
1eaf 10 dd			djnz .dumpbyte 
1eb1			 
1eb1				 
1eb1			 
1eb1 c9				ret 
1eb2			 
1eb2			jump:	 
1eb2			 
1eb2 21 f5 f0			ld hl,scratch+2 
1eb5 cd 9d 12			call get_word_hl 
1eb8				;ld hl,(scratch+2) 
1eb8				;call fourehexhl 
1eb8			 
1eb8 22 16 f4			ld (os_cur_ptr),hl	 
1ebb			 
1ebb e9				jp (hl) 
1ebc			 
1ebc			 
1ebc			 
1ebc			; TODO implement a basic monitor mode to start with 
1ebc			 
1ebc			 
1ebc			 
1ebc			 
1ebc			 
1ebc			 
1ebc			 
1ebc			 
1ebc			 
1ebc			; testing and demo code during development 
1ebc			 
1ebc			 
1ebc .. 00		str1: db "Enter some text...",0 
1ecf .. 00		clear: db "                    ",0 
1ee4			 
1ee4			demo: 
1ee4			 
1ee4			 
1ee4			 
1ee4			;	call update_display 
1ee4			 
1ee4				; init scratch input area for testing 
1ee4 21 f3 f0			ld hl, scratch	 
1ee7 3e 00			ld a,0 
1ee9 77				ld (hl),a 
1eea			 
1eea			 
1eea 3e 28		            LD   A, display_row_2 
1eec			;            CALL fLCD_Pos       ;Position cursor to location in A 
1eec 11 bc 1e		            LD   DE, str1 
1eef cd bd 0d			call str_at_display 
1ef2			 
1ef2			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ef2			cloop:	 
1ef2 3e 50		            LD   A, display_row_3 
1ef4			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ef4 11 cf 1e		            LD   DE, clear 
1ef7			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1ef7 cd bd 0d				call str_at_display 
1efa 3e 78			ld a, display_row_4 
1efc 11 2c 1f			ld de, prompt 
1eff			 
1eff cd bd 0d				call str_at_display 
1f02 cd cd 0d			call update_display 
1f05			 
1f05 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f07 16 0a			ld d, 10 
1f09 21 f3 f0			ld hl, scratch	 
1f0c cd 0b 10			call input_str 
1f0f			 
1f0f			;	call clear_display 
1f0f			;'	call update_display 
1f0f			 
1f0f 3e 00		            LD   A, display_row_1 
1f11			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f11 11 cf 1e		            LD   DE, clear 
1f14 cd bd 0d				call str_at_display 
1f17			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f17 3e 00		            LD   A, display_row_1 
1f19			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f19 11 f3 f0		            LD   DE, scratch 
1f1c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f1c cd bd 0d				call str_at_display 
1f1f cd cd 0d			call update_display 
1f22			 
1f22 3e 00				ld a,0 
1f24 21 f3 f0			ld hl, scratch 
1f27 77				ld (hl),a 
1f28			 
1f28 00				nop 
1f29 c3 f2 1e			jp cloop 
1f2c			 
1f2c			 
1f2c			 
1f2c			; OS Prompt 
1f2c			 
1f2c .. 00		prompt: db ">",0 
1f2e .. 00		endprg: db "?",0 
1f30			 
1f30			 
1f30			; handy next page prompt 
1f30			next_page_prompt: 
1f30 e5				push hl 
1f31 d5				push de 
1f32 f5				push af 
1f33 c5				push bc 
1f34			 
1f34 3e 9f			ld a,display_row_4 + display_cols - 1 
1f36 11 2e 1f		        ld de, endprg 
1f39 cd bd 0d			call str_at_display 
1f3c cd cd 0d			call update_display 
1f3f cd e8 79			call cin_wait 
1f42 c1				pop bc 
1f43 f1				pop af 
1f44 d1				pop de 
1f45 e1				pop hl 
1f46			 
1f46			 
1f46 c9				ret 
1f47			 
1f47			 
1f47			; forth parser 
1f47			 
1f47			; My forth kernel 
1f47			include "forth_kernel.asm" 
1f47			; 
1f47			; kernel to the forth OS 
1f47			 
1f47			DS_TYPE_STR: equ 1     ; string type 
1f47			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1f47			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1f47			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1f47			 
1f47			FORTH_PARSEV1: equ 0 
1f47			FORTH_PARSEV2: equ 0 
1f47			FORTH_PARSEV3: equ 0 
1f47			FORTH_PARSEV4: equ 0 
1f47			FORTH_PARSEV5: equ 0 
1f47			FORTH_PARSEV6: equ 1 
1f47			 
1f47			;if FORTH_PARSEV5 
1f47			;	FORTH_END_BUFFER: equ 0 
1f47			;else 
1f47			FORTH_END_BUFFER: equ 127 
1f47			;endif 
1f47			 
1f47			FORTH_TRUE: equ 1 
1f47			FORTH_FALSE: equ 0 
1f47			 
1f47			if FORTH_PARSEV4 
1f47			include "forth_stackops.asm" 
1f47			endif 
1f47			 
1f47			if FORTH_PARSEV5 
1f47			include "forth_stackopsv5.asm" 
1f47			endif 
1f47			 
1f47			if FORTH_PARSEV6 
1f47			include "forth_stackopsv5.asm" 
1f47			 
1f47			; Stack operations for v5 parser on wards 
1f47			; * DATA stack 
1f47			; * LOOP stack 
1f47			; * RETURN stack 
1f47			 
1f47			 
1f47			 
1f47			FORTH_CHK_DSP_UNDER: macro 
1f47				push hl 
1f47				push de 
1f47				ld hl,(cli_data_sp) 
1f47				ld de, cli_data_stack 
1f47				call cmp16 
1f47				jp c, fault_dsp_under 
1f47				pop de 
1f47				pop hl 
1f47				endm 
1f47			 
1f47			 
1f47			FORTH_CHK_RSP_UNDER: macro 
1f47				push hl 
1f47				push de 
1f47				ld hl,(cli_ret_sp) 
1f47				ld de, cli_ret_stack 
1f47				call cmp16 
1f47				jp c, fault_rsp_under 
1f47				pop de 
1f47				pop hl 
1f47				endm 
1f47			 
1f47			FORTH_CHK_LOOP_UNDER: macro 
1f47				push hl 
1f47				push de 
1f47				ld hl,(cli_loop_sp) 
1f47				ld de, cli_loop_stack 
1f47				call cmp16 
1f47				jp c, fault_loop_under 
1f47				pop de 
1f47				pop hl 
1f47				endm 
1f47			 
1f47			FORTH_ERR_TOS_NOTSTR: macro 
1f47				; TOSO might need more for checks when used 
1f47				push af 
1f47				ld a,(hl) 
1f47				cp DS_TYPE_STR 
1f47				jp nz, type_faultn   
1f47				pop af 
1f47				endm 
1f47			 
1f47			FORTH_ERR_TOS_NOTNUM: macro 
1f47				push af 
1f47				ld a,(hl) 
1f47				cp DS_TYPE_INUM 
1f47				jp nz, type_faultn   
1f47				pop af 
1f47				endm 
1f47			 
1f47			 
1f47			; increase data stack pointer and save hl to it 
1f47				 
1f47			FORTH_DSP_NEXT: macro 
1f47				call macro_forth_dsp_next 
1f47				endm 
1f47			 
1f47			 
1f47			macro_forth_dsp_next: 
1f47				if DEBUG_FORTH_STACK_GUARD 
1f47 cd 8c 72				call check_stacks 
1f4a				endif 
1f4a e5				push hl 
1f4b d5				push de 
1f4c eb				ex de,hl 
1f4d 2a 20 f9			ld hl,(cli_data_sp) 
1f50 23				inc hl 
1f51 23				inc hl 
1f52			 
1f52			; PARSEV5 
1f52 23				inc hl 
1f53 22 20 f9			ld (cli_data_sp),hl 
1f56 73				ld (hl), e 
1f57 23				inc hl 
1f58 72				ld (hl), d 
1f59 d1				pop de 
1f5a e1				pop hl 
1f5b				if DEBUG_FORTH_STACK_GUARD 
1f5b cd 8c 72				call check_stacks 
1f5e				endif 
1f5e c9				ret 
1f5f			 
1f5f			 
1f5f			; increase ret stack pointer and save hl to it 
1f5f				 
1f5f			FORTH_RSP_NEXT: macro 
1f5f				call macro_forth_rsp_next 
1f5f				endm 
1f5f			 
1f5f			macro_forth_rsp_next: 
1f5f				if DEBUG_FORTH_STACK_GUARD 
1f5f cd 8c 72				call check_stacks 
1f62				endif 
1f62 e5				push hl 
1f63 d5				push de 
1f64 eb				ex de,hl 
1f65 2a 24 f9			ld hl,(cli_ret_sp) 
1f68 23				inc hl 
1f69 23				inc hl 
1f6a 22 24 f9			ld (cli_ret_sp),hl 
1f6d 73				ld (hl), e 
1f6e 23				inc hl 
1f6f 72				ld (hl), d 
1f70 d1				pop de 
1f71 e1				pop hl 
1f72				if DEBUG_FORTH_STACK_GUARD 
1f72 cd 8c 72				call check_stacks 
1f75				endif 
1f75 c9				ret 
1f76			 
1f76			; get current ret stack pointer and save to hl  
1f76				 
1f76			FORTH_RSP_TOS: macro 
1f76				call macro_forth_rsp_tos 
1f76				endm 
1f76			 
1f76			macro_forth_rsp_tos: 
1f76				;push de 
1f76 2a 24 f9			ld hl,(cli_ret_sp) 
1f79 cd b1 1f			call loadhlptrtohl 
1f7c				;ld e, (hl) 
1f7c				;inc hl 
1f7c				;ld d, (hl) 
1f7c				;ex de, hl 
1f7c					if DEBUG_FORTH_WORDS 
1f7c			;			DMARK "RST" 
1f7c						CALLMONITOR 
1f7c cd aa fd			call debug_vector  
1f7f				endm  
# End of macro CALLMONITOR
1f7f					endif 
1f7f				;pop de 
1f7f c9				ret 
1f80			 
1f80			; pop ret stack pointer 
1f80				 
1f80			FORTH_RSP_POP: macro 
1f80				call macro_forth_rsp_pop 
1f80				endm 
1f80			 
1f80			 
1f80			macro_forth_rsp_pop: 
1f80				if DEBUG_FORTH_STACK_GUARD 
1f80			;		DMARK "RPP" 
1f80 cd 8c 72				call check_stacks 
1f83					FORTH_CHK_RSP_UNDER 
1f83 e5				push hl 
1f84 d5				push de 
1f85 2a 24 f9			ld hl,(cli_ret_sp) 
1f88 11 de f8			ld de, cli_ret_stack 
1f8b cd fc 0f			call cmp16 
1f8e da a3 73			jp c, fault_rsp_under 
1f91 d1				pop de 
1f92 e1				pop hl 
1f93				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f93				endif 
1f93 e5				push hl 
1f94 2a 24 f9			ld hl,(cli_ret_sp) 
1f97			 
1f97			 
1f97				if FORTH_ENABLE_FREE 
1f97			 
1f97					; get pointer 
1f97			 
1f97					push de 
1f97					push hl 
1f97			 
1f97					ld e, (hl) 
1f97					inc hl 
1f97					ld d, (hl) 
1f97			 
1f97					ex de, hl 
1f97					call free 
1f97			 
1f97					pop hl 
1f97					pop de 
1f97			 
1f97			 
1f97				endif 
1f97			 
1f97			 
1f97 2b				dec hl 
1f98 2b				dec hl 
1f99 22 24 f9			ld (cli_ret_sp), hl 
1f9c				; do stack underflow checks 
1f9c e1				pop hl 
1f9d				if DEBUG_FORTH_STACK_GUARD 
1f9d cd 8c 72				call check_stacks 
1fa0					FORTH_CHK_RSP_UNDER 
1fa0 e5				push hl 
1fa1 d5				push de 
1fa2 2a 24 f9			ld hl,(cli_ret_sp) 
1fa5 11 de f8			ld de, cli_ret_stack 
1fa8 cd fc 0f			call cmp16 
1fab da a3 73			jp c, fault_rsp_under 
1fae d1				pop de 
1faf e1				pop hl 
1fb0				endm 
# End of macro FORTH_CHK_RSP_UNDER
1fb0				endif 
1fb0 c9				ret 
1fb1			 
1fb1			 
1fb1			 
1fb1			; routine to load word pointed to by hl into hl 
1fb1			 
1fb1			loadhlptrtohl: 
1fb1			 
1fb1 d5				push de 
1fb2 5e				ld e, (hl) 
1fb3 23				inc hl 
1fb4 56				ld d, (hl) 
1fb5 eb				ex de, hl 
1fb6 d1				pop de 
1fb7			 
1fb7 c9				ret 
1fb8			 
1fb8			 
1fb8			 
1fb8			 
1fb8			 
1fb8			; push a number held in HL onto the data stack 
1fb8			; entry point for pushing a value when already in hl used in function above 
1fb8			 
1fb8			forth_push_numhl: 
1fb8			 
1fb8 e5				push hl    ; save value to push 
1fb9			 
1fb9			if DEBUG_FORTH_PUSH 
1fb9				; see if disabled 
1fb9			 
1fb9			 
1fb9 f5				push af 
1fba 3a aa fd			ld a,(debug_vector) 
1fbd fe c9			cp $c9   ; ret 
1fbf			;	ld a, (os_view_disable) 
1fbf			;	cp '*' 
1fbf 28 34			jr z, .pskip2 
1fc1 e5				push hl 
1fc2 e5			push hl 
1fc3 cd aa 0d			call clear_display 
1fc6 e1			pop hl 
1fc7 7c				ld a,h 
1fc8 21 f8 f3			ld hl, os_word_scratch 
1fcb cd e7 11			call hexout 
1fce e1				pop hl 
1fcf 7d				ld a,l 
1fd0 21 fa f3			ld hl, os_word_scratch+2 
1fd3 cd e7 11			call hexout 
1fd6			 
1fd6 21 fc f3			ld hl, os_word_scratch+4 
1fd9 3e 00			ld a,0 
1fdb 77				ld (hl),a 
1fdc 11 f8 f3			ld de,os_word_scratch 
1fdf 3e 28				ld a, display_row_2 
1fe1 cd bd 0d				call str_at_display 
1fe4 11 85 64			ld de, .push_num 
1fe7 3e 00			ld a, display_row_1 
1fe9			 
1fe9 cd bd 0d				call str_at_display 
1fec			 
1fec			 
1fec cd cd 0d			call update_display 
1fef cd ed 0c			call delay1s 
1ff2 cd ed 0c			call delay1s 
1ff5			.pskip2:  
1ff5			 
1ff5 f1				pop af 
1ff6			endif	 
1ff6			 
1ff6			 
1ff6				FORTH_DSP_NEXT 
1ff6 cd 47 1f			call macro_forth_dsp_next 
1ff9				endm 
# End of macro FORTH_DSP_NEXT
1ff9			 
1ff9 2a 20 f9			ld hl, (cli_data_sp) 
1ffc			 
1ffc				; save item type 
1ffc 3e 02			ld a,  DS_TYPE_INUM 
1ffe 77				ld (hl), a 
1fff 23				inc hl 
2000			 
2000				; get word off stack 
2000 d1				pop de 
2001 7b				ld a,e 
2002 77				ld (hl), a 
2003 23				inc hl 
2004 7a				ld a,d 
2005 77				ld (hl), a 
2006			 
2006			if DEBUG_FORTH_PUSH 
2006 2b				dec hl 
2007 2b				dec hl 
2008 2b				dec hl 
2009						DMARK "PH5" 
2009 f5				push af  
200a 3a 1e 20			ld a, (.dmark)  
200d 32 9d fd			ld (debug_mark),a  
2010 3a 1f 20			ld a, (.dmark+1)  
2013 32 9e fd			ld (debug_mark+1),a  
2016 3a 20 20			ld a, (.dmark+2)  
2019 32 9f fd			ld (debug_mark+2),a  
201c 18 03			jr .pastdmark  
201e ..			.dmark: db "PH5"  
2021 f1			.pastdmark: pop af  
2022			endm  
# End of macro DMARK
2022				CALLMONITOR 
2022 cd aa fd			call debug_vector  
2025				endm  
# End of macro CALLMONITOR
2025			endif	 
2025			 
2025 c9				ret 
2026			 
2026			 
2026			; Push a string to stack pointed to by hl 
2026			 
2026			forth_push_str: 
2026			 
2026			if DEBUG_FORTH_PUSH 
2026						DMARK "PSQ" 
2026 f5				push af  
2027 3a 3b 20			ld a, (.dmark)  
202a 32 9d fd			ld (debug_mark),a  
202d 3a 3c 20			ld a, (.dmark+1)  
2030 32 9e fd			ld (debug_mark+1),a  
2033 3a 3d 20			ld a, (.dmark+2)  
2036 32 9f fd			ld (debug_mark+2),a  
2039 18 03			jr .pastdmark  
203b ..			.dmark: db "PSQ"  
203e f1			.pastdmark: pop af  
203f			endm  
# End of macro DMARK
203f				CALLMONITOR 
203f cd aa fd			call debug_vector  
2042				endm  
# End of macro CALLMONITOR
2042			endif	 
2042			 
2042			 
2042			    
2042 e5				push hl 
2043 e5				push hl 
2044			 
2044			;	ld a, 0   ; find end of string 
2044 cd 44 13			call strlenz 
2047			if DEBUG_FORTH_PUSH 
2047						DMARK "PQ2" 
2047 f5				push af  
2048 3a 5c 20			ld a, (.dmark)  
204b 32 9d fd			ld (debug_mark),a  
204e 3a 5d 20			ld a, (.dmark+1)  
2051 32 9e fd			ld (debug_mark+1),a  
2054 3a 5e 20			ld a, (.dmark+2)  
2057 32 9f fd			ld (debug_mark+2),a  
205a 18 03			jr .pastdmark  
205c ..			.dmark: db "PQ2"  
205f f1			.pastdmark: pop af  
2060			endm  
# End of macro DMARK
2060				CALLMONITOR 
2060 cd aa fd			call debug_vector  
2063				endm  
# End of macro CALLMONITOR
2063			endif	 
2063 eb				ex de, hl 
2064 e1				pop hl   ; get ptr to start of string 
2065			if DEBUG_FORTH_PUSH 
2065						DMARK "PQ3" 
2065 f5				push af  
2066 3a 7a 20			ld a, (.dmark)  
2069 32 9d fd			ld (debug_mark),a  
206c 3a 7b 20			ld a, (.dmark+1)  
206f 32 9e fd			ld (debug_mark+1),a  
2072 3a 7c 20			ld a, (.dmark+2)  
2075 32 9f fd			ld (debug_mark+2),a  
2078 18 03			jr .pastdmark  
207a ..			.dmark: db "PQ3"  
207d f1			.pastdmark: pop af  
207e			endm  
# End of macro DMARK
207e				CALLMONITOR 
207e cd aa fd			call debug_vector  
2081				endm  
# End of macro CALLMONITOR
2081			endif	 
2081 19				add hl,de 
2082			if DEBUG_FORTH_PUSH 
2082						DMARK "PQE" 
2082 f5				push af  
2083 3a 97 20			ld a, (.dmark)  
2086 32 9d fd			ld (debug_mark),a  
2089 3a 98 20			ld a, (.dmark+1)  
208c 32 9e fd			ld (debug_mark+1),a  
208f 3a 99 20			ld a, (.dmark+2)  
2092 32 9f fd			ld (debug_mark+2),a  
2095 18 03			jr .pastdmark  
2097 ..			.dmark: db "PQE"  
209a f1			.pastdmark: pop af  
209b			endm  
# End of macro DMARK
209b				CALLMONITOR 
209b cd aa fd			call debug_vector  
209e				endm  
# End of macro CALLMONITOR
209e			endif	 
209e			 
209e 2b				dec hl    ; see if there is an optional trailing double quote 
209f 7e				ld a,(hl) 
20a0 fe 22			cp '"' 
20a2 20 03			jr nz, .strnoq 
20a4 3e 00			ld a, 0      ; get rid of double quote 
20a6 77				ld (hl), a 
20a7 23			.strnoq: inc hl 
20a8			 
20a8 3e 00			ld a, 0 
20aa 77				ld (hl), a     ; add null term and get rid of trailing double quote 
20ab			 
20ab 13				inc de ; add one for the type string 
20ac 13				inc de ; add one for null term??? 
20ad			 
20ad				; tos is get string pointer again 
20ad				; de contains space to allocate 
20ad				 
20ad d5				push de 
20ae			 
20ae eb				ex de, hl 
20af			 
20af				;push af 
20af			 
20af			if DEBUG_FORTH_PUSH 
20af						DMARK "PHm" 
20af f5				push af  
20b0 3a c4 20			ld a, (.dmark)  
20b3 32 9d fd			ld (debug_mark),a  
20b6 3a c5 20			ld a, (.dmark+1)  
20b9 32 9e fd			ld (debug_mark+1),a  
20bc 3a c6 20			ld a, (.dmark+2)  
20bf 32 9f fd			ld (debug_mark+2),a  
20c2 18 03			jr .pastdmark  
20c4 ..			.dmark: db "PHm"  
20c7 f1			.pastdmark: pop af  
20c8			endm  
# End of macro DMARK
20c8				CALLMONITOR 
20c8 cd aa fd			call debug_vector  
20cb				endm  
# End of macro CALLMONITOR
20cb			endif	 
20cb cd b9 13			call malloc	; on ret hl now contains allocated memory 
20ce				if DEBUG_FORTH_MALLOC_GUARD 
20ce cc dd 64				call z,malloc_error 
20d1				endif 
20d1			 
20d1				 
20d1 c1				pop bc    ; get length 
20d2 d1				pop de   ;  get string start    
20d3			 
20d3				; hl has destination from malloc 
20d3			 
20d3 eb				ex de, hl    ; prep for ldir 
20d4			 
20d4 d5				push de   ; save malloc area for DSP later 
20d5				;push hl   ; save malloc area for DSP later 
20d5			 
20d5			if DEBUG_FORTH_PUSH 
20d5						DMARK "PHc" 
20d5 f5				push af  
20d6 3a ea 20			ld a, (.dmark)  
20d9 32 9d fd			ld (debug_mark),a  
20dc 3a eb 20			ld a, (.dmark+1)  
20df 32 9e fd			ld (debug_mark+1),a  
20e2 3a ec 20			ld a, (.dmark+2)  
20e5 32 9f fd			ld (debug_mark+2),a  
20e8 18 03			jr .pastdmark  
20ea ..			.dmark: db "PHc"  
20ed f1			.pastdmark: pop af  
20ee			endm  
# End of macro DMARK
20ee				CALLMONITOR 
20ee cd aa fd			call debug_vector  
20f1				endm  
# End of macro CALLMONITOR
20f1			endif	 
20f1			 
20f1			 
20f1 ed b0			ldir 
20f3			 
20f3			 
20f3				; push malloc to data stack     macro?????  
20f3			 
20f3				FORTH_DSP_NEXT 
20f3 cd 47 1f			call macro_forth_dsp_next 
20f6				endm 
# End of macro FORTH_DSP_NEXT
20f6			 
20f6				; save value and type 
20f6			 
20f6 2a 20 f9			ld hl, (cli_data_sp) 
20f9			 
20f9				; save item type 
20f9 3e 01			ld a,  DS_TYPE_STR 
20fb 77				ld (hl), a 
20fc 23				inc hl 
20fd			 
20fd				; get malloc word off stack 
20fd d1				pop de 
20fe 73				ld (hl), e 
20ff 23				inc hl 
2100 72				ld (hl), d 
2101			 
2101			 
2101			 
2101			if DEBUG_FORTH_PUSH 
2101 2a 20 f9			ld hl, (cli_data_sp) 
2104						DMARK "PHS" 
2104 f5				push af  
2105 3a 19 21			ld a, (.dmark)  
2108 32 9d fd			ld (debug_mark),a  
210b 3a 1a 21			ld a, (.dmark+1)  
210e 32 9e fd			ld (debug_mark+1),a  
2111 3a 1b 21			ld a, (.dmark+2)  
2114 32 9f fd			ld (debug_mark+2),a  
2117 18 03			jr .pastdmark  
2119 ..			.dmark: db "PHS"  
211c f1			.pastdmark: pop af  
211d			endm  
# End of macro DMARK
211d				CALLMONITOR 
211d cd aa fd			call debug_vector  
2120				endm  
# End of macro CALLMONITOR
2120			;	ex de,hl 
2120			endif	 
2120				; in case of spaces, skip the ptr past the copied string 
2120				;pop af 
2120				;ld (cli_origptr),hl 
2120			 
2120 c9				ret 
2121			 
2121			 
2121			 
2121			; TODO ascii push input onto stack given hl to start of input 
2121			 
2121			; identify type 
2121			; if starts with a " then a string 
2121			; otherwise it is a number 
2121			;  
2121			; if a string 
2121			;     scan for ending " to get length of string to malloc for + 1 
2121			;     malloc 
2121			;     put pointer to string on stack first byte flags as string 
2121			; 
2121			; else a number 
2121			;    look for number format identifier 
2121			;    $xx hex 
2121			;    %xxxxx bin 
2121			;    xxxxx decimal 
2121			;    convert number to 16bit word.  
2121			;    malloc word + 1 with flag to identiy as num 
2121			;    put pointer to number on stack 
2121			;   
2121			;  
2121			  
2121			forth_apush: 
2121				; kernel push 
2121			 
2121			if DEBUG_FORTH_PUSH 
2121						DMARK "PSH" 
2121 f5				push af  
2122 3a 36 21			ld a, (.dmark)  
2125 32 9d fd			ld (debug_mark),a  
2128 3a 37 21			ld a, (.dmark+1)  
212b 32 9e fd			ld (debug_mark+1),a  
212e 3a 38 21			ld a, (.dmark+2)  
2131 32 9f fd			ld (debug_mark+2),a  
2134 18 03			jr .pastdmark  
2136 ..			.dmark: db "PSH"  
2139 f1			.pastdmark: pop af  
213a			endm  
# End of macro DMARK
213a				CALLMONITOR 
213a cd aa fd			call debug_vector  
213d				endm  
# End of macro CALLMONITOR
213d			endif	 
213d				; identify input type 
213d			 
213d 7e				ld a,(hl) 
213e			 
213e fe 23			cp '#' 
2140 ca 7a 21			jp z, .fapdec 
2143			 
2143			 
2143 fe 22			cp '"' 
2145 28 0a			jr z, .fapstr 
2147 fe 24			cp '$' 
2149 ca 71 21			jp z, .faphex 
214c fe 25			cp '%' 
214e ca 59 21			jp z, .fapbin 
2151			;	cp 'b' 
2151			;	jp z, .fabin 
2151				; else decimal 
2151			 
2151				; TODO do decimal conversion 
2151				; decimal is stored as a 16bit word 
2151			 
2151				; by default everything is a string if type is not detected 
2151			.fapstr: ; 
2151 fe 22			cp '"' 
2153 20 01			jr nz, .strnoqu 
2155 23				inc hl 
2156			.strnoqu: 
2156 c3 26 20			jp forth_push_str 
2159			 
2159			 
2159			 
2159			.fapbin:    ; push a binary string.  
2159 11 00 00			ld de, 0   ; hold a 16bit value 
215c			 
215c 23			.fapbinshift:	inc hl  
215d 7e				ld a,(hl) 
215e fe 00			cp 0     ; done scanning  
2160 28 0b			jr z, .fapbdone  	; got it in HL so push  
2162			 
2162				; left shift de 
2162 eb				ex de, hl	 
2163 29				add hl, hl 
2164			 
2164				; is 1 
2164 fe 31			cp '1' 
2166 20 02			jr nz, .binzero 
2168 cb 4d			bit 1, l 
216a			.binzero: 
216a eb				ex de, hl	 ; save current de 
216b 18 ef			jr .fapbinshift 
216d			 
216d			.fapbdone: 
216d eb				ex de, hl 
216e c3 b8 1f			jp forth_push_numhl 
2171			 
2171			 
2171			.faphex:   ; hex is always stored as a 16bit word 
2171				; skip number prefix 
2171 23				inc hl 
2172				; turn ascii into number 
2172 cd 9d 12			call get_word_hl	; ret 16bit word in hl 
2175			 
2175 c3 b8 1f			jp forth_push_numhl 
2178			 
2178 00				 nop 
2179			 
2179			.fabin:   ; TODO bin conversion 
2179			 
2179			 
2179 c9				ret 
217a			.fapdec:	 
217a				; string to dec conversion 
217a 23				inc hl 
217b eb				ex de, hl 
217c cd db 12			call string_to_uint16 
217f c3 b8 1f			jp forth_push_numhl 
2182 c9				ret 
2183				 
2183			;atoui_16: 
2183			 
2183			; get either a string ptr or a 16bit word from the data stack 
2183			 
2183			FORTH_DSP: macro 
2183				call macro_forth_dsp 
2183				endm 
2183			 
2183			macro_forth_dsp: 
2183				; data stack pointer points to current word on tos 
2183			 
2183 2a 20 f9			ld hl,(cli_data_sp) 
2186			 
2186				if DEBUG_FORTH_PUSH 
2186						DMARK "DSP" 
2186 f5				push af  
2187 3a 9b 21			ld a, (.dmark)  
218a 32 9d fd			ld (debug_mark),a  
218d 3a 9c 21			ld a, (.dmark+1)  
2190 32 9e fd			ld (debug_mark+1),a  
2193 3a 9d 21			ld a, (.dmark+2)  
2196 32 9f fd			ld (debug_mark+2),a  
2199 18 03			jr .pastdmark  
219b ..			.dmark: db "DSP"  
219e f1			.pastdmark: pop af  
219f			endm  
# End of macro DMARK
219f			 
219f cd 10 65				call display_data_sp 
21a2				;call break_point_state 
21a2				;rst 030h 
21a2				CALLMONITOR 
21a2 cd aa fd			call debug_vector  
21a5				endm  
# End of macro CALLMONITOR
21a5				endif 
21a5			 
21a5 c9				ret 
21a6			 
21a6			; return hl to start of value on stack 
21a6			 
21a6			FORTH_DSP_VALUE: macro 
21a6				call macro_forth_dsp_value 
21a6				endm 
21a6			 
21a6			macro_forth_dsp_value: 
21a6			 
21a6				FORTH_DSP 
21a6 cd 83 21			call macro_forth_dsp 
21a9				endm 
# End of macro FORTH_DSP
21a9			 
21a9 d5				push de 
21aa			 
21aa 23				inc hl ; skip type 
21ab			 
21ab 5e				ld e, (hl) 
21ac 23				inc hl 
21ad 56				ld d, (hl) 
21ae eb				ex de,hl  
21af			 
21af d1				pop de 
21b0			 
21b0 c9				ret 
21b1			 
21b1			; return hl to start of value to second item on stack 
21b1			 
21b1			FORTH_DSP_VALUEM1: macro 
21b1				call macro_forth_dsp_value_m1 
21b1				endm 
21b1			 
21b1			macro_forth_dsp_value_m1: 
21b1			 
21b1				FORTH_DSP 
21b1 cd 83 21			call macro_forth_dsp 
21b4				endm 
# End of macro FORTH_DSP
21b4			 
21b4 2b				dec hl 
21b5 2b				dec hl 
21b6			;	dec hl 
21b6			 
21b6 d5				push de 
21b7			 
21b7 5e				ld e, (hl) 
21b8 23				inc hl 
21b9 56				ld d, (hl) 
21ba eb				ex de,hl  
21bb			 
21bb d1				pop de 
21bc			 
21bc c9				ret 
21bd			 
21bd				 
21bd			 
21bd			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
21bd			 
21bd			FORTH_DSP_POP: macro 
21bd				call macro_forth_dsp_pop 
21bd				endm 
21bd			 
21bd			 
21bd			; get the tos data type 
21bd			 
21bd			FORTH_DSP_TYPE:   macro 
21bd			 
21bd				;FORTH_DSP_VALUE 
21bd				FORTH_DSP 
21bd				 
21bd				; hl points to value 
21bd				; check type 
21bd			 
21bd				ld a,(hl) 
21bd			 
21bd				endm 
21bd			 
21bd			; load the tos value into hl 
21bd			 
21bd			 
21bd			FORTH_DSP_VALUEHL:  macro 
21bd				call macro_dsp_valuehl 
21bd				endm 
21bd			 
21bd			 
21bd			 
21bd			macro_dsp_valuehl: 
21bd				FORTH_DSP_VALUE 
21bd cd a6 21			call macro_forth_dsp_value 
21c0				endm 
# End of macro FORTH_DSP_VALUE
21c0			 
21c0				;FORTH_ERR_TOS_NOTNUM 
21c0			 
21c0				;inc hl   ; skip type id 
21c0			 
21c0			;	push de 
21c0			; 
21c0			;	ld e, (hl) 
21c0			;	inc hl 
21c0			;	ld d, (hl) 
21c0			;	ex de,hl  
21c0			 
21c0			;	pop de 
21c0			 
21c0				if DEBUG_FORTH_PUSH 
21c0						DMARK "DVL" 
21c0 f5				push af  
21c1 3a d5 21			ld a, (.dmark)  
21c4 32 9d fd			ld (debug_mark),a  
21c7 3a d6 21			ld a, (.dmark+1)  
21ca 32 9e fd			ld (debug_mark+1),a  
21cd 3a d7 21			ld a, (.dmark+2)  
21d0 32 9f fd			ld (debug_mark+2),a  
21d3 18 03			jr .pastdmark  
21d5 ..			.dmark: db "DVL"  
21d8 f1			.pastdmark: pop af  
21d9			endm  
# End of macro DMARK
21d9				CALLMONITOR 
21d9 cd aa fd			call debug_vector  
21dc				endm  
# End of macro CALLMONITOR
21dc				endif 
21dc c9				ret 
21dd			 
21dd			forth_apushstrhl:      
21dd				; push of string requires use of cli_origptr 
21dd				; bodge use 
21dd			 
21dd				; get current cli_origptr, save, update with temp pointer  
21dd ed 5b 70 f9		ld de, (cli_origptr) 
21e1 22 70 f9			ld (cli_origptr), hl 
21e4 d5				push de 
21e5 cd 21 21			call forth_apush 
21e8 d1				pop de 
21e9 ed 53 70 f9		ld (cli_origptr), de 
21ed c9			        ret	 
21ee			 
21ee			 
21ee			; increase loop stack pointer and save hl to it 
21ee				 
21ee			FORTH_LOOP_NEXT: macro 
21ee				call macro_forth_loop_next 
21ee				;nop 
21ee				endm 
21ee			 
21ee			macro_forth_loop_next: 
21ee				if DEBUG_FORTH_STACK_GUARD 
21ee cd 8c 72				call check_stacks 
21f1				endif 
21f1 e5				push hl 
21f2 d5				push de 
21f3 eb				ex de,hl 
21f4 2a 22 f9			ld hl,(cli_loop_sp) 
21f7 23				inc hl 
21f8 23				inc hl 
21f9					if DEBUG_FORTH_WORDS 
21f9						DMARK "LNX" 
21f9 f5				push af  
21fa 3a 0e 22			ld a, (.dmark)  
21fd 32 9d fd			ld (debug_mark),a  
2200 3a 0f 22			ld a, (.dmark+1)  
2203 32 9e fd			ld (debug_mark+1),a  
2206 3a 10 22			ld a, (.dmark+2)  
2209 32 9f fd			ld (debug_mark+2),a  
220c 18 03			jr .pastdmark  
220e ..			.dmark: db "LNX"  
2211 f1			.pastdmark: pop af  
2212			endm  
# End of macro DMARK
2212						CALLMONITOR 
2212 cd aa fd			call debug_vector  
2215				endm  
# End of macro CALLMONITOR
2215					endif 
2215 22 22 f9			ld (cli_loop_sp),hl 
2218 73				ld (hl), e 
2219 23				inc hl 
221a 72				ld (hl), d 
221b d1				pop de    ; been reversed so save a swap on restore 
221c e1				pop hl 
221d				if DEBUG_FORTH_STACK_GUARD 
221d cd 8c 72				call check_stacks 
2220				endif 
2220 c9				ret 
2221			 
2221			; get current ret stack pointer and save to hl  
2221				 
2221			FORTH_LOOP_TOS: macro 
2221				call macro_forth_loop_tos 
2221				endm 
2221			 
2221			macro_forth_loop_tos: 
2221 d5				push de 
2222 2a 22 f9			ld hl,(cli_loop_sp) 
2225 5e				ld e, (hl) 
2226 23				inc hl 
2227 56				ld d, (hl) 
2228 eb				ex de, hl 
2229 d1				pop de 
222a c9				ret 
222b			 
222b			; pop loop stack pointer 
222b				 
222b			FORTH_LOOP_POP: macro 
222b				call macro_forth_loop_pop 
222b				endm 
222b			 
222b			 
222b			macro_forth_loop_pop: 
222b				if DEBUG_FORTH_STACK_GUARD 
222b					DMARK "LPP" 
222b f5				push af  
222c 3a 40 22			ld a, (.dmark)  
222f 32 9d fd			ld (debug_mark),a  
2232 3a 41 22			ld a, (.dmark+1)  
2235 32 9e fd			ld (debug_mark+1),a  
2238 3a 42 22			ld a, (.dmark+2)  
223b 32 9f fd			ld (debug_mark+2),a  
223e 18 03			jr .pastdmark  
2240 ..			.dmark: db "LPP"  
2243 f1			.pastdmark: pop af  
2244			endm  
# End of macro DMARK
2244 cd 8c 72				call check_stacks 
2247					FORTH_CHK_LOOP_UNDER 
2247 e5				push hl 
2248 d5				push de 
2249 2a 22 f9			ld hl,(cli_loop_sp) 
224c 11 5c f8			ld de, cli_loop_stack 
224f cd fc 0f			call cmp16 
2252 da a9 73			jp c, fault_loop_under 
2255 d1				pop de 
2256 e1				pop hl 
2257				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2257				endif 
2257 e5				push hl 
2258 2a 22 f9			ld hl,(cli_loop_sp) 
225b 2b				dec hl 
225c 2b				dec hl 
225d 22 22 f9			ld (cli_loop_sp), hl 
2260				; TODO do stack underflow checks 
2260 e1				pop hl 
2261				if DEBUG_FORTH_STACK_GUARD 
2261 cd 8c 72				call check_stacks 
2264					FORTH_CHK_LOOP_UNDER 
2264 e5				push hl 
2265 d5				push de 
2266 2a 22 f9			ld hl,(cli_loop_sp) 
2269 11 5c f8			ld de, cli_loop_stack 
226c cd fc 0f			call cmp16 
226f da a9 73			jp c, fault_loop_under 
2272 d1				pop de 
2273 e1				pop hl 
2274				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2274				endif 
2274 c9				ret 
2275			 
2275			macro_forth_dsp_pop: 
2275			 
2275 e5				push hl 
2276			 
2276				; release malloc data 
2276			 
2276				if DEBUG_FORTH_STACK_GUARD 
2276 cd 8c 72				call check_stacks 
2279					FORTH_CHK_DSP_UNDER 
2279 e5				push hl 
227a d5				push de 
227b 2a 20 f9			ld hl,(cli_data_sp) 
227e 11 5a f6			ld de, cli_data_stack 
2281 cd fc 0f			call cmp16 
2284 da 9d 73			jp c, fault_dsp_under 
2287 d1				pop de 
2288 e1				pop hl 
2289				endm 
# End of macro FORTH_CHK_DSP_UNDER
2289				endif 
2289				;ld hl,(cli_data_sp) 
2289			if DEBUG_FORTH_DOT 
2289				DMARK "DPP" 
2289 f5				push af  
228a 3a 9e 22			ld a, (.dmark)  
228d 32 9d fd			ld (debug_mark),a  
2290 3a 9f 22			ld a, (.dmark+1)  
2293 32 9e fd			ld (debug_mark+1),a  
2296 3a a0 22			ld a, (.dmark+2)  
2299 32 9f fd			ld (debug_mark+2),a  
229c 18 03			jr .pastdmark  
229e ..			.dmark: db "DPP"  
22a1 f1			.pastdmark: pop af  
22a2			endm  
# End of macro DMARK
22a2				CALLMONITOR 
22a2 cd aa fd			call debug_vector  
22a5				endm  
# End of macro CALLMONITOR
22a5			endif	 
22a5			 
22a5			 
22a5			if FORTH_ENABLE_DSPPOPFREE 
22a5			 
22a5				FORTH_DSP 
22a5 cd 83 21			call macro_forth_dsp 
22a8				endm 
# End of macro FORTH_DSP
22a8			 
22a8 7e				ld a, (hl) 
22a9 fe 01			cp DS_TYPE_STR 
22ab 20 22			jr nz, .skippopfree 
22ad			 
22ad				FORTH_DSP_VALUEHL 
22ad cd bd 21			call macro_dsp_valuehl 
22b0				endm 
# End of macro FORTH_DSP_VALUEHL
22b0			;	nop 
22b0			if DEBUG_FORTH_DOT 
22b0				DMARK "DPf" 
22b0 f5				push af  
22b1 3a c5 22			ld a, (.dmark)  
22b4 32 9d fd			ld (debug_mark),a  
22b7 3a c6 22			ld a, (.dmark+1)  
22ba 32 9e fd			ld (debug_mark+1),a  
22bd 3a c7 22			ld a, (.dmark+2)  
22c0 32 9f fd			ld (debug_mark+2),a  
22c3 18 03			jr .pastdmark  
22c5 ..			.dmark: db "DPf"  
22c8 f1			.pastdmark: pop af  
22c9			endm  
# End of macro DMARK
22c9				CALLMONITOR 
22c9 cd aa fd			call debug_vector  
22cc				endm  
# End of macro CALLMONITOR
22cc			endif	 
22cc cd 83 14			call free 
22cf			.skippopfree: 
22cf				 
22cf			 
22cf			endif 
22cf			 
22cf			if DEBUG_FORTH_DOT_KEY 
22cf				DMARK "DP2" 
22cf				CALLMONITOR 
22cf			endif	 
22cf			 
22cf				; move pointer down 
22cf			 
22cf 2a 20 f9			ld hl,(cli_data_sp) 
22d2 2b				dec hl 
22d3 2b				dec hl 
22d4			; PARSEV5 
22d4 2b				dec hl 
22d5 22 20 f9			ld (cli_data_sp), hl 
22d8			 
22d8				if DEBUG_FORTH_STACK_GUARD 
22d8 cd 8c 72				call check_stacks 
22db					FORTH_CHK_DSP_UNDER 
22db e5				push hl 
22dc d5				push de 
22dd 2a 20 f9			ld hl,(cli_data_sp) 
22e0 11 5a f6			ld de, cli_data_stack 
22e3 cd fc 0f			call cmp16 
22e6 da 9d 73			jp c, fault_dsp_under 
22e9 d1				pop de 
22ea e1				pop hl 
22eb				endm 
# End of macro FORTH_CHK_DSP_UNDER
22eb				endif 
22eb			 
22eb e1				pop hl 
22ec			 
22ec c9				ret 
22ed			 
22ed			getwordathl: 
22ed				; hl points to an address 
22ed				; load hl with the word at that address 
22ed			 
22ed d5				push de 
22ee			 
22ee 5e				ld e, (hl) 
22ef 23				inc hl 
22f0 56				ld d, (hl) 
22f1 eb				ex de, hl 
22f2			 
22f2 d1				pop de 
22f3 c9				ret 
22f4			 
22f4			 
22f4			; functions to manuplite stack pointers 
22f4			 
22f4			; generate fragment to set hl to be pointer to a stack item 
22f4			 
22f4			FORTH_DSP_PTR: macro  x 
22f4				ld hl,(cli_data_sp) 
22f4				ld de, x * 3 
22f4				sbc hl, de 
22f4				endm 
22f4			 
22f4			 
22f4			 
22f4			; copy point in hl to stack tmp storage slots 1-4 
22f4			hltostack1: 
22f4 11 f0 f0			ld de, os_stack_1  
22f7 c3 22 23			jp hltostackmv 
22fa			 
22fa			hltostack2:  
22fa 11 ed f0			ld de, os_stack_2 
22fd c3 22 23			jp hltostackmv 
2300			 
2300			hltostack3:  
2300 11 ea f0			ld de, os_stack_3 
2303 c3 22 23			jp hltostackmv 
2306			 
2306			hltostack4:  
2306 11 e7 f0			ld de, os_stack_4  
2309 c3 22 23			jp hltostackmv 
230c			 
230c			; copy to point in hl from stack tmp storage slots 1-4 
230c			hlfromstack1: 
230c 11 f0 f0			ld de, os_stack_1 
230f c3 21 23			jp hlfromsttackmv 
2312			 
2312			hlfromstack2:  
2312 11 ed f0			ld de, os_stack_2 
2315 c3 21 23			jp hlfromsttackmv 
2318			 
2318			hlfromstack3:  
2318 11 ea f0			ld de, os_stack_3 
231b c3 21 23			jp hlfromsttackmv 
231e			 
231e			hlfromstack4:  
231e 11 e7 f0			ld de, os_stack_4 
2321			 
2321			hlfromsttackmv: 
2321 eb				ex de, hl 
2322			 
2322			hltostackmv: 
2322			 
2322				; do stack move 
2322 c5				push bc 
2323 01 03 00			ld bc, 3 
2326 ed b0			ldir  
2328 c1				pop bc	 
2329 c9				ret 
232a			 
232a			; eof 
232a			 
# End of file forth_stackopsv5.asm
232a			endif 
232a			loadwordinhl:	 
232a			 
232a d5				push de 
232b			 
232b 5e				ld e, (hl) 
232c 23				inc hl 
232d 56				ld d, (hl) 
232e eb				ex de,hl  
232f			 
232f d1				pop de 
2330			 
2330 c9				ret 
2331			 
2331			user_word_eol:  
2331				; hl contains the pointer to where to create a linked list item from the end 
2331				; of the user dict to continue on at the system word dict 
2331				 
2331				; poke the stub of the word list linked list to repoint to rom words 
2331			 
2331				; stub format 
2331				; db   word id 
2331				; dw    link to next word 
2331			        ; db char length of token 
2331				; db string + 0 term 
2331				; db exec code....  
2331			 
2331 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2333 77				ld (hl), a		; word id 
2334 23				inc hl 
2335			 
2335 11 ec 24			ld de, sysdict 
2338 73				ld (hl), e		; next word link ie system dict 
2339 23				inc hl 
233a 72				ld (hl), d		; next word link ie system dict 
233b 23				inc hl	 
233c			 
233c			;	ld (hl), sysdict		; next word link ie system dict 
233c			;	inc hl 
233c			;	inc hl 
233c			 
233c			;	inc hl 
233c			;	inc hl 
233c			 
233c 3e 02			ld a, 2			; word length is 0 
233e 77				ld (hl), a	 
233f 23				inc hl 
2340			 
2340 3e 7e			ld a, '~'			; word length is 0 
2342 77				ld (hl), a	 
2343 23				inc hl 
2344 3e 00			ld a, 0			; save empty word 
2346 77				ld (hl), a 
2347			 
2347 c9				ret 
2348			 
2348				 
2348			 
2348			forthexec_cleanup: 
2348				FORTH_RSP_POP 
2348 cd 80 1f			call macro_forth_rsp_pop 
234b				endm 
# End of macro FORTH_RSP_POP
234b c9				ret 
234c			 
234c			forth_call_hl: 
234c				; taking hl 
234c e5				push hl 
234d c9				ret 
234e			 
234e			; this is called to reset Forth system but keep existing uwords etc 
234e			 
234e			forth_warmstart: 
234e				; setup stack over/under flow checks 
234e				if DEBUG_FORTH_STACK_GUARD 
234e cd 72 72				call chk_stk_init 
2351				endif 
2351			 
2351				; init stack pointers  - * these stacks go upwards *  
2351 21 de f8			ld hl, cli_ret_stack 
2354 22 24 f9			ld (cli_ret_sp), hl	 
2357				; set bottom of stack 
2357 3e 00			ld a,0 
2359 77				ld (hl),a 
235a 23				inc hl 
235b 77				ld (hl),a 
235c			 
235c 21 5a f6			ld hl, cli_data_stack 
235f 22 20 f9			ld (cli_data_sp), hl	 
2362				; set bottom of stack 
2362 3e 00			ld a,0 
2364 77				ld (hl),a 
2365 23				inc hl 
2366 77				ld (hl),a 
2367			 
2367 21 5c f8			ld hl, cli_loop_stack 
236a 22 22 f9			ld (cli_loop_sp), hl	 
236d				; set bottom of stack 
236d 3e 00			ld a,0 
236f 77				ld (hl),a 
2370 23				inc hl 
2371 77				ld (hl),a 
2372			 
2372				; init extent of current open file 
2372			 
2372 3e 00			ld a, 0 
2374 32 9c f9			ld (store_openext), a 
2377			 
2377 c9				ret 
2378			 
2378			 
2378			 
2378			; Cold Start - this is called to setup the whole Forth system 
2378			 
2378			forth_init: 
2378			 
2378				; setup stack over/under flow checks 
2378			 
2378			;	if DEBUG_FORTH_STACK_GUARD 
2378			;		call chk_stk_init 
2378			;	endif 
2378			 
2378				; enable auto display updates (slow.....) 
2378			 
2378 3e 01			ld a, 1 
237a 32 6e f9			ld (cli_autodisplay), a 
237d			 
237d				; if storage is in use disable long reads for now 
237d 3e 00			ld a, 0 
237f 32 a7 f9			ld (store_longread), a 
2382			 
2382			 
2382				; show start up screen 
2382			 
2382 cd aa 0d			call clear_display 
2385			 
2385 3e 00			ld a,0 
2387 32 90 f9			ld (f_cursor_ptr), a 
238a			 
238a				; set start of word list in start of ram - for use when creating user words 
238a			 
238a 21 00 80			ld hl, baseram 
238d 22 f0 f3			ld (os_last_new_uword), hl 
2390 cd 31 23			call user_word_eol 
2393				 
2393			;		call display_data_sp 
2393			;		call next_page_prompt 
2393			 
2393			 
2393			 
2393			 
2393 c9				ret 
2394			 
2394 .. 00		.bootforth: db " Forth Kernel Init ",0 
23a8			 
23a8			; TODO push to stack 
23a8			 
23a8			;  
23a8			 
23a8			if FORTH_PARSEV2 
23a8			 
23a8			 
23a8				include "forth_parserv2.asm" 
23a8			 
23a8			endif 
23a8			 
23a8			 
23a8			; parse cli version 1 
23a8			 
23a8			if FORTH_PARSEV1 
23a8			 
23a8			 
23a8			 
23a8			      include "forth_parserv1.asm" 
23a8			endif 
23a8				 
23a8			if FORTH_PARSEV3 
23a8			      include "forth_parserv3.asm" 
23a8				include "forth_wordsv3.asm" 
23a8			endif 
23a8			 
23a8			if FORTH_PARSEV4 
23a8			      include "forth_parserv4.asm" 
23a8				include "forth_wordsv4.asm" 
23a8			endif 
23a8			 
23a8			if FORTH_PARSEV5 
23a8			      include "forth_parserv5.asm" 
23a8				include "forth_wordsv4.asm" 
23a8			endif 
23a8			 
23a8			if FORTH_PARSEV6 
23a8			      include "forth_parserv6.asm" 
23a8			 
23a8			 
23a8			; A better parser without using malloc and string copies all over the place.  
23a8			; Exec in situ should be faster 
23a8			 
23a8			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
23a8			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
23a8			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
23a8			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
23a8			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
23a8			WORD_SYS_END: equ 0   ; Opcode for all user words 
23a8			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
23a8			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
23a8			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
23a8			 
23a8			; Core word preamble macro 
23a8			 
23a8			CWHEAD:   macro nxtword opcode lit len opflags 
23a8				db WORD_SYS_CORE+opcode             
23a8				; internal op code number 
23a8				dw nxtword            
23a8				; link to next dict word block 
23a8				db len + 1 
23a8				; literal length of dict word inc zero term 
23a8				db lit,0              
23a8				; literal dict word 
23a8			        ; TODO db opflags        
23a8				endm 
23a8			 
23a8			 
23a8			NEXTW: macro  
23a8				call parse_vector 
23a8				jp macro_next 
23a8				endm 
23a8			 
23a8			macro_next: 
23a8			if DEBUG_FORTH_PARSE_EXEC 
23a8				DMARK "NXT" 
23a8				CALLMONITOR 
23a8			endif	 
23a8			;	inc hl  ; skip token null term  
23a8 ed 4b 72 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23ac ed 5b 70 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23b0 2a f4 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23b3			if DEBUG_FORTH_PARSE_EXEC 
23b3				DMARK "}AA" 
23b3				CALLMONITOR 
23b3			endif	 
23b3 c3 a2 24			jp execnext 
23b6				;jp exec1 
23b6			       
23b6			 
23b6			 
23b6			; Another go at the parser to compile  
23b6			 
23b6			 
23b6			; TODO rework parser to change all of the string words to byte tokens 
23b6			; TODO do a search for  
23b6			 
23b6			; TODO first run normal parser to zero term sections 
23b6			; TODO for each word do a token look up to get the op code 
23b6			; TODO need some means to flag to the exec that this is a byte code form    
23b6			 
23b6			 
23b6			forthcompile: 
23b6			 
23b6			; 
23b6			; line parse: 
23b6			;       parse raw input buffer 
23b6			;       tokenise the words 
23b6			;       malloc new copy (for looping etc) 
23b6			;       copy to malloc + current pc in line to start of string and add line term 
23b6			;       save on new rsp 
23b6			; 
23b6			 
23b6			; hl to point to the line to tokenise 
23b6			 
23b6			;	push hl 
23b6 22 f4 f3			ld (os_tok_ptr), hl  ; save ptr to string 
23b9			 
23b9			;	ld a,0		; string term on input 
23b9			;	call strlent 
23b9			 
23b9			;	ld (os_tok_len), hl	 ; save string length 
23b9			 
23b9			;if DEBUG_FORTH_TOK 
23b9			;	ex de,hl		 
23b9			;endif 
23b9			 
23b9			;	pop hl 		; get back string pointer 
23b9			 
23b9			if DEBUG_FORTH_TOK 
23b9						DMARK "TOc" 
23b9				CALLMONITOR 
23b9			endif 
23b9 7e			.cptoken2:    ld a,(hl) 
23ba 23				inc hl 
23bb fe 7f			cp FORTH_END_BUFFER 
23bd 28 29			jr z, .cptokendone2 
23bf fe 00			cp 0 
23c1 28 25			jr z, .cptokendone2 
23c3 fe 22			cp '"' 
23c5 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
23c7 fe 20			cp ' ' 
23c9 20 ee			jr nz,  .cptoken2 
23cb			 
23cb			; TODO consume comments held between ( and ) 
23cb			 
23cb				; we have a space so change to zero term for dict match later 
23cb 2b				dec hl 
23cc 3e 00			ld a,0 
23ce 77				ld (hl), a 
23cf 23				inc hl 
23d0 18 e7			jr .cptoken2 
23d2				 
23d2			 
23d2			.cptokenstr2: 
23d2				; skip all white space until either eol (because forgot to term) or end double quote 
23d2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
23d2				;inc hl ; skip current double quote 
23d2 7e				ld a,(hl) 
23d3 23				inc hl 
23d4 fe 22			cp '"' 
23d6 28 e1			jr z, .cptoken2 
23d8 fe 7f			cp FORTH_END_BUFFER 
23da 28 0c			jr z, .cptokendone2 
23dc fe 00			cp 0 
23de 28 08			jr z, .cptokendone2 
23e0 fe 20			cp ' ' 
23e2 28 02			jr z, .cptmp2 
23e4 18 ec			jr .cptokenstr2 
23e6			 
23e6			.cptmp2:	; we have a space so change to zero term for dict match later 
23e6				;dec hl 
23e6				;ld a,"-"	; TODO remove this when working 
23e6				;ld (hl), a 
23e6				;inc hl 
23e6 18 ea			jr .cptokenstr2 
23e8			 
23e8			.cptokendone2: 
23e8				;inc hl 
23e8 3e 7f			ld a, FORTH_END_BUFFER 
23ea 77				ld (hl),a 
23eb			;	inc hl 
23eb			;	ld a, '!' 
23eb			;	ld (hl),a 
23eb			 
23eb 2a f4 f3			ld hl,(os_tok_ptr) 
23ee			         
23ee			if DEBUG_FORTH_TOK 
23ee						DMARK "Tc1" 
23ee				CALLMONITOR 
23ee			endif 
23ee			 
23ee				; push exec string to top of return stack 
23ee				FORTH_RSP_NEXT 
23ee cd 5f 1f			call macro_forth_rsp_next 
23f1				endm 
# End of macro FORTH_RSP_NEXT
23f1 c9				ret 
23f2			 
23f2			; Another go at the parser need to simplify the process 
23f2			 
23f2			forthparse: 
23f2			 
23f2			; 
23f2			; line parse: 
23f2			;       parse raw input buffer 
23f2			;       tokenise the words 
23f2			;       malloc new copy (for looping etc) 
23f2			;       copy to malloc + current pc in line to start of string and add line term 
23f2			;       save on new rsp 
23f2			; 
23f2			 
23f2			; hl to point to the line to tokenise 
23f2			 
23f2			;	push hl 
23f2 22 f4 f3			ld (os_tok_ptr), hl  ; save ptr to string 
23f5			 
23f5			;	ld a,0		; string term on input 
23f5			;	call strlent 
23f5			 
23f5			;	ld (os_tok_len), hl	 ; save string length 
23f5			 
23f5			;if DEBUG_FORTH_TOK 
23f5			;	ex de,hl		 
23f5			;endif 
23f5			 
23f5			;	pop hl 		; get back string pointer 
23f5			 
23f5			if DEBUG_FORTH_TOK 
23f5						DMARK "TOK" 
23f5				CALLMONITOR 
23f5			endif 
23f5 7e			.ptoken2:    ld a,(hl) 
23f6 23				inc hl 
23f7 fe 7f			cp FORTH_END_BUFFER 
23f9 28 29			jr z, .ptokendone2 
23fb fe 00			cp 0 
23fd 28 25			jr z, .ptokendone2 
23ff fe 22			cp '"' 
2401 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2403 fe 20			cp ' ' 
2405 20 ee			jr nz,  .ptoken2 
2407			 
2407			; TODO consume comments held between ( and ) 
2407			 
2407				; we have a space so change to zero term for dict match later 
2407 2b				dec hl 
2408 3e 00			ld a,0 
240a 77				ld (hl), a 
240b 23				inc hl 
240c 18 e7			jr .ptoken2 
240e				 
240e			 
240e			.ptokenstr2: 
240e				; skip all white space until either eol (because forgot to term) or end double quote 
240e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
240e				;inc hl ; skip current double quote 
240e 7e				ld a,(hl) 
240f 23				inc hl 
2410 fe 22			cp '"' 
2412 28 e1			jr z, .ptoken2 
2414 fe 7f			cp FORTH_END_BUFFER 
2416 28 0c			jr z, .ptokendone2 
2418 fe 00			cp 0 
241a 28 08			jr z, .ptokendone2 
241c fe 20			cp ' ' 
241e 28 02			jr z, .ptmp2 
2420 18 ec			jr .ptokenstr2 
2422			 
2422			.ptmp2:	; we have a space so change to zero term for dict match later 
2422				;dec hl 
2422				;ld a,"-"	; TODO remove this when working 
2422				;ld (hl), a 
2422				;inc hl 
2422 18 ea			jr .ptokenstr2 
2424			 
2424			.ptokendone2: 
2424				;inc hl 
2424 3e 7f			ld a, FORTH_END_BUFFER 
2426 77				ld (hl),a 
2427			;	inc hl 
2427			;	ld a, '!' 
2427			;	ld (hl),a 
2427			 
2427 2a f4 f3			ld hl,(os_tok_ptr) 
242a			         
242a			if DEBUG_FORTH_TOK 
242a						DMARK "TK1" 
242a				CALLMONITOR 
242a			endif 
242a			 
242a				; push exec string to top of return stack 
242a				FORTH_RSP_NEXT 
242a cd 5f 1f			call macro_forth_rsp_next 
242d				endm 
# End of macro FORTH_RSP_NEXT
242d c9				ret 
242e			 
242e			; 
242e			;	; malloc size + buffer pointer + if is loop flag 
242e			;	ld hl,(os_tok_len) 		 ; get string length 
242e			; 
242e			;	ld a,l 
242e			; 
242e			;	cp 0			; we dont want to use a null string 
242e			;	ret z 
242e			; 
242e			;;	add 3    ; prefix malloc with buffer for current word ptr 
242e			; 
242e			;	add 5     ; TODO when certain not over writing memory remove 
242e			; 
242e			;		 
242e			; 
242e			;if DEBUG_FORTH_TOK 
242e			;			DMARK "TKE" 
242e			;	CALLMONITOR 
242e			;endif 
242e			; 
242e			;	ld l,a 
242e			;	ld h,0 
242e			;;	push hl   ; save required space for the copy later 
242e			;	call malloc 
242e			;if DEBUG_FORTH_TOK 
242e			;			DMARK "TKM" 
242e			;	CALLMONITOR 
242e			;endif 
242e			;	if DEBUG_FORTH_MALLOC_GUARD 
242e			;		push af 
242e			;		call ishlzero 
242e			;;		ld a, l 
242e			;;		add h 
242e			;;		cp 0 
242e			;		pop af 
242e			;		 
242e			;		call z,malloc_error 
242e			;	endif 
242e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
242e			; 
242e			; 
242e			;if DEBUG_FORTH_TOK 
242e			;			DMARK "TKR" 
242e			;	CALLMONITOR 
242e			;endif 
242e			; 
242e			;	FORTH_RSP_NEXT 
242e			; 
242e			;	;inc hl	 ; go past current buffer pointer 
242e			;	;inc hl 
242e			;	;inc hl   ; and past if loop flag 
242e			;		; TODO Need to set flag  
242e			; 
242e			;	 
242e			;	 
242e			;	ex de,hl	; malloc is dest 
242e			;	ld hl, (os_tok_len) 
242e			;;	pop bc 
242e			;	ld c, l                
242e			;	ld b,0 
242e			;	ld hl, (os_tok_ptr) 
242e			; 
242e			;if DEBUG_FORTH_TOK 
242e			;			DMARK "TKT" 
242e			;	CALLMONITOR 
242e			;endif 
242e			; 
242e			;	; do str cpy 
242e			; 
242e			;	ldir      ; copy byte in hl to de 
242e			; 
242e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
242e			; 
242e			;if DEBUG_FORTH_TOK 
242e			; 
242e			;			DMARK "TKY" 
242e			;	CALLMONITOR 
242e			;endif 
242e			;	;ld a,0 
242e			;	;ld a,FORTH_END_BUFFER 
242e			;	ex de, hl 
242e			;	;dec hl			 ; go back over the space delim at the end of word 
242e			;	;ld (hl),a 
242e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
242e			;	ld a,FORTH_END_BUFFER 
242e			;	ld (hl),a 
242e			;	inc hl 
242e			;	ld a,FORTH_END_BUFFER 
242e			;	ld (hl),a 
242e			; 
242e			;	; init the malloc area data 
242e			;	; set pc for in current area 
242e			;	;ld hl, (os_tok_malloc) 
242e			;	;inc hl 
242e			;	;inc hl 
242e			;	;inc hl 
242e			;	;ex de,hl 
242e			;	;ld hl, (os_tok_malloc) 
242e			;	;ld (hl),e 
242e			;	;inc hl 
242e			;	;ld (hl),d 
242e			; 
242e			; 
242e			;	ld hl,(os_tok_malloc) 
242e			;if DEBUG_FORTH_PARSE_KEY 
242e			;			DMARK "TKU" 
242e			;	CALLMONITOR 
242e			;endif 
242e			; 
242e			;	ret 
242e			 
242e			forthexec: 
242e			 
242e			; line exec: 
242e			; forth parser 
242e			 
242e			; 
242e			;       get current exec line on rsp 
242e			 
242e				FORTH_RSP_TOS 
242e cd 76 1f			call macro_forth_rsp_tos 
2431				endm 
# End of macro FORTH_RSP_TOS
2431			 
2431			;       restore current pc - hl points to malloc of data 
2431			 
2431				;ld e, (hl) 
2431				;inc hl 
2431				;ld d, (hl) 
2431				;ex de,hl 
2431			 
2431			 
2431			exec1: 
2431 22 f4 f3			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
2434			 
2434				; copy our PC to working vars  
2434 22 72 f9			ld (cli_ptr), hl                    ; here 
2437 22 70 f9			ld (cli_origptr), hl                ; here 
243a			 
243a 7e				ld a,(hl)                           ; here make hl be the ram ptr 
243b fe 7f			cp FORTH_END_BUFFER 
243d c8				ret z 
243e			 
243e				; skip any nulls 
243e			 
243e fe 00			cp 0 
2440 20 03			jr nz, .execword 
2442 23				inc hl 
2443 18 ec			jr exec1 
2445			 
2445			 
2445			.execword: 
2445			 
2445			 
2445			 
2445			if DEBUG_FORTH_PARSE_EXEC 
2445						DMARK "KYQ" 
2445				CALLMONITOR 
2445			endif 
2445			;       while at start of word: 
2445			; get start of dict (in user area first) 
2445			 
2445 21 00 80		ld hl, baseram 
2448			;ld hl, sysdict 
2448 22 74 f9		ld (cli_nextword),hl                            ; here do we need to do this? 
244b			;           match word at pc 
244b			;           exec word 
244b			;           or push to dsp 
244b			;           forward to next token 
244b			;           if line term pop rsp and exit 
244b			;        
244b			 
244b			if DEBUG_FORTH_PARSE_EXEC 
244b						DMARK "KYq" 
244b				CALLMONITOR 
244b			endif 
244b			 
244b			; 
244b			; word comp 
244b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
244b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
244b			;    move to start of word  
244b			;    compare word to cli_token 
244b			 
244b			.execpnword:	; HL at start of a word in the dictionary to check 
244b			 
244b 2a 74 f9			ld hl,(cli_nextword)                  ; here remove the need to store???? 
244e			 
244e cd e5 24			call forth_tok_next 
2451			; tok next end here 
2451 22 74 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2454 eb				ex de, hl 
2455			 
2455			 
2455				; save the pointer of the current token - 1 to check against 
2455				 
2455 22 78 f9			ld (cli_token), hl   
2458				; TODO maybe remove below save if no debug 
2458				; save token string ptr for any debug later 
2458 23				inc hl  
2459 22 7a f9			ld (cli_origtoken), hl 
245c 2b				dec hl 
245d				; save pointer to the start of the next dictionay word 
245d 7e				ld a,(hl)   ; get string length 
245e 47				ld b,a 
245f			.execpnwordinc:  
245f 23				inc hl 
2460 10 fd			djnz .execpnwordinc 
2462 22 76 f9			ld (cli_execword), hl      ; save start of this words code 
2465			 
2465				; now check the word token against the string being parsed 
2465			 
2465 2a 78 f9			ld hl,(cli_token) 
2468 23				inc hl     ; skip string length (use zero term instead to end) 
2469				;ld (cli_token), hl 
2469			 
2469			.execpnchar:    ; compare char between token and string to parse 
2469			 
2469			 
2469				;ld hl, (cli_token)     ; the dict word  
2469 ed 5b 72 f9		ld de, (cli_ptr)     ; cli to parse 
246d			 
246d			 
246d			.execpncharl:    ; compare char between token and string to parse (loop) 
246d			 
246d 1a				ld a,(de) 
246e cd 3b 13			call toUpper 		; make sure the input string matches case 
2471 be				cp (hl) 
2472			 
2472 c2 8b 24			jp nz, .execpnskipword	 ; no match so move to next word 
2475				 
2475			;    if same 
2475			;       scan for string terms 0 for token and 32 for input 
2475 46				ld b,(hl) 
2476 80				add b			 
2477 23				inc hl 
2478 13				inc de 
2479 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
247b							; TODO need to make sure last word in zero term string is accounted for 
247b 20 f0			jr nz, .execpncharl 		 ; not at end of strings yet 
247d			 
247d			 
247d				; at end of both strings so both are exact match 
247d			 
247d			;       skip ptr for next word 
247d			 
247d 2a 72 f9			ld hl,(cli_ptr) 	; at input string term 
2480 23				inc hl			 ; at next char 
2481 22 72 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2484 22 70 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2487				 
2487				 
2487			 
2487			 
2487			 
2487			;       exec code block 
2487			if DEBUG_FORTH_JP 
2487				call clear_display 
2487				call update_display 
2487				call delay1s 
2487				ld hl, (cli_execword)     ; save for next check if no match on this word 
2487				ld a,h 
2487				ld hl, os_word_scratch 
2487				call hexout 
2487				ld hl, (cli_execword)     ; save for next check if no match on this word 
2487				ld a,l 
2487				ld hl, os_word_scratch+2 
2487				call hexout 
2487				ld hl, os_word_scratch+4 
2487				ld a,0 
2487				ld (hl),a 
2487				ld de,os_word_scratch 
2487				call str_at_display 
2487					ld a, display_row_2 
2487					call str_at_display 
2487				ld de, (cli_origtoken) 
2487				ld a, display_row_1+10 
2487					call str_at_display 
2487			 
2487				ld a,display_row_1 
2487				ld de, .foundword 
2487				ld a, display_row_3 
2487				call str_at_display 
2487				call update_display 
2487				call delay1s 
2487				call delay1s 
2487				call delay1s 
2487			endif 
2487			 
2487			if DEBUG_FORTH_PARSE_EXEC 
2487						DMARK "KYj" 
2487			endif 
2487				; TODO save the word pointer in this exec 
2487			 
2487 2a 76 f9			ld hl,(cli_execword) 
248a e9				jp (hl) 
248b			 
248b			 
248b			;    if not same 
248b			;	scan for zero term 
248b			;	get ptr for next word 
248b			;	goto word comp 
248b			 
248b			.execpnskipword:	; get pointer to next word 
248b 2a 74 f9			ld hl,(cli_nextword) 
248e			 
248e 7e				ld a,(hl) 
248f fe 00			cp WORD_SYS_END 
2491			;	cp 0 
2491 28 09			jr z, .execendofdict			 ; at end of words 
2493			 
2493			if DEBUG_FORTH_PARSE_EXEC 
2493						DMARK "KY4" 
2493			endif 
2493			if DEBUG_FORTH_PARSE_EXEC 
2493			 
2493				; see if disabled 
2493			 
2493			;	ld a, (os_view_disable) 
2493			;	cp '*' 
2493				ld a,(debug_vector) 
2493				cp $c9   ; RET 
2493				jr z, .noskip 
2493			 
2493			 
2493				ld de, .nowordfound 
2493				ld a, display_row_3 
2493				call str_at_display 
2493				call update_display 
2493				ld a, 100 
2493				call aDelayInMS 
2493				 
2493				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2493					call delay250ms 
2493				endif 
2493			.noskip:  
2493			 
2493			endif	 
2493			 
2493 2a 70 f9			ld hl,(cli_origptr) 
2496 22 72 f9			ld (cli_ptr),hl 
2499			 
2499			if DEBUG_FORTH_PARSE_EXEC 
2499						DMARK "KY5" 
2499			endif 
2499 c3 4b 24			jp .execpnword			; else go to next word 
249c			 
249c			.execendofdict:  
249c			 
249c			if DEBUG_FORTH_PARSE_EXEC 
249c						DMARK "KYe" 
249c			endif 
249c			if DEBUG_FORTH_PARSE_EXEC 
249c				; see if disabled 
249c			 
249c			;	ld a, (os_view_disable) 
249c			;	cp '*' 
249c				ld a,(debug_vector) 
249c				cp $c9   ; ret 
249c				jr z, .ispskip 
249c			 
249c				call clear_display 
249c				call update_display 
249c				call delay1s 
249c				ld de, (cli_origptr) 
249c				ld a, display_row_1 
249c				call str_at_display 
249c				 
249c				ld de, .enddict 
249c				ld a, display_row_3 
249c				call str_at_display 
249c				call update_display 
249c				ld a, 100 
249c				call aDelayInMS 
249c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
249c				call delay1s 
249c				call delay1s 
249c				call delay1s 
249c				endif 
249c			.ispskip:  
249c				 
249c			endif	 
249c			 
249c			 
249c			 
249c				; if the word is not a keyword then must be a literal so push it to stack 
249c			 
249c			; push token to stack to end of word 
249c			 
249c				STACKFRAME ON $1efe $2f9f 
249c				if DEBUG_STACK_IMB 
249c					if ON 
249c						exx 
249c						ld de, $1efe 
249c						ld a, d 
249c						ld hl, curframe 
249c						call hexout 
249c						ld a, e 
249c						ld hl, curframe+2 
249c						call hexout 
249c						ld hl, $1efe 
249c						push hl 
249c						ld hl, $2f9f 
249c						push hl 
249c						exx 
249c					endif 
249c				endif 
249c			endm 
# End of macro STACKFRAME
249c			 
249c 2a f4 f3		ld hl,(os_tok_ptr) 
249f cd 21 21		call forth_apush 
24a2			 
24a2				STACKFRAMECHK ON $1efe $2f9f 
24a2				if DEBUG_STACK_IMB 
24a2					if ON 
24a2						exx 
24a2						ld hl, $2f9f 
24a2						pop de   ; $2f9f 
24a2						call cmp16 
24a2						jr nz, .spnosame 
24a2						ld hl, $1efe 
24a2						pop de   ; $1efe 
24a2						call cmp16 
24a2						jr z, .spfrsame 
24a2						.spnosame: call showsperror 
24a2						.spfrsame: nop 
24a2						exx 
24a2					endif 
24a2				endif 
24a2			endm 
# End of macro STACKFRAMECHK
24a2			 
24a2			execnext: 
24a2			 
24a2			if DEBUG_FORTH_PARSE_EXEC 
24a2						DMARK "KY>" 
24a2			endif 
24a2			; move past token to next word 
24a2			 
24a2 2a f4 f3		ld hl, (os_tok_ptr) 
24a5 3e 00		ld a, 0 
24a7 01 ff 00		ld bc, 255     ; input buffer size 
24aa ed b1		cpir 
24ac			 
24ac			if DEBUG_FORTH_PARSE_EXEC 
24ac						DMARK "KY!" 
24ac				CALLMONITOR 
24ac			endif	 
24ac			; TODO this might place hl on the null, so will need to forward on??? 
24ac			;inc hl   ; see if this gets onto the next item 
24ac			 
24ac			 
24ac			; TODO pass a pointer to the buffer to push 
24ac			; TODO call function to push 
24ac			 
24ac			; look for end of input 
24ac			 
24ac			;inc hl 
24ac			;ld a,(hl) 
24ac			;cp FORTH_END_BUFFER 
24ac			;ret z 
24ac			 
24ac			 
24ac c3 31 24		jp exec1 
24af			 
24af			 
24af			 
24af			 
24af			 
24af			 
24af			 
24af			 
24af			 
24af			findnexttok: 
24af			 
24af				; hl is pointer to move 
24af				; de is the token to locate 
24af			 
24af					if DEBUG_FORTH 
24af						DMARK "NTK" 
24af						CALLMONITOR 
24af					endif 
24af d5				push de 
24b0			 
24b0			.fnt1:	 
24b0				; find first char of token to locate 
24b0			 
24b0 1a				ld a, (de) 
24b1 4f				ld c,a 
24b2 7e				ld a,(hl) 
24b3 cd 3b 13			call toUpper 
24b6					if DEBUG_FORTH 
24b6						DMARK "NT1" 
24b6						CALLMONITOR 
24b6					endif 
24b6 b9				cp c 
24b7			 
24b7 28 03			jr z, .fnt2cmpmorefirst	 
24b9			 
24b9				; first char not found move to next char 
24b9			 
24b9 23				inc hl 
24ba 18 f4			jr .fnt1 
24bc			 
24bc			.fnt2cmpmorefirst:	 
24bc				; first char of token found.  
24bc			 
24bc e5				push hl     ; save start of token just in case it is the right one 
24bd d9				exx 
24be e1				pop hl        ; save it to hl' 
24bf d9				exx 
24c0			 
24c0			 
24c0			.fnt2cmpmore:	 
24c0				; compare the rest 
24c0				 
24c0 23				inc hl 
24c1 13				inc de 
24c2				 
24c2 1a				ld a, (de) 
24c3 4f				ld c,a 
24c4 7e				ld a,(hl) 
24c5 cd 3b 13			call toUpper 
24c8			 
24c8					if DEBUG_FORTH 
24c8						DMARK "NT2" 
24c8						CALLMONITOR 
24c8					endif 
24c8				; c has the token to find char 
24c8				; a has the mem to scan char 
24c8			 
24c8 b9				cp c 
24c9 28 04			jr z,.fntmatch1 
24cb			 
24cb				; they are not the same 
24cb			 
24cb					if DEBUG_FORTH 
24cb						DMARK "NT3" 
24cb						CALLMONITOR 
24cb					endif 
24cb d1				pop de	; reset de token to look for 
24cc d5				push de 
24cd 18 e1			jr .fnt1 
24cf				 
24cf			.fntmatch1: 
24cf			 
24cf				; is the same char a null which means we might have a full hit? 
24cf					if DEBUG_FORTH 
24cf						DMARK "NT4" 
24cf						CALLMONITOR 
24cf					endif 
24cf			 
24cf fe 00			cp 0 
24d1 28 0b			jr z, .fntmatchyes 
24d3			 
24d3				; are we at the end of the token to find? 
24d3			 
24d3					if DEBUG_FORTH 
24d3						DMARK "NT5" 
24d3						CALLMONITOR 
24d3					endif 
24d3 3e 00			ld a, 0 
24d5 b9				cp c 
24d6			 
24d6 c2 c0 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
24d9			 
24d9					if DEBUG_FORTH 
24d9						DMARK "NT6" 
24d9						CALLMONITOR 
24d9					endif 
24d9				; token to find is exhusted but no match to stream 
24d9			 
24d9				; restore tok pointer and continue on 
24d9 d1				pop de 
24da d5				push de 
24db c3 b0 24			jp .fnt1 
24de			 
24de			 
24de			.fntmatchyes: 
24de			 
24de				; hl now contains the end of the found token 
24de			 
24de				; get rid of saved token pointer to find 
24de			 
24de d1				pop de 
24df			 
24df					if DEBUG_FORTH 
24df						DMARK "NT9" 
24df						CALLMONITOR 
24df					endif 
24df			 
24df				; hl will be on the null term so forward on 
24df			 
24df				; get back the saved start of the token 
24df			 
24df d9				exx 
24e0 e5				push hl     ; save start of token just in case it is the right one 
24e1 d9				exx 
24e2 e1				pop hl        ; save it to hl 
24e3			 
24e3 c9				ret 
24e4			 
24e4			 
24e4			; LIST needs to find a specific token   
24e4			; FORGET needs to find a spefici token 
24e4			 
24e4			; SAVE needs to find all tokens by flag 
24e4			; WORDS just needs to scan through all  by flag 
24e4			; UWORDS needs to scan through all by flag 
24e4			 
24e4			 
24e4			; given hl as pointer to start of dict look up string 
24e4			; return hl as pointer to start of word block 
24e4			; or 0 if not found 
24e4			 
24e4			forth_find_tok: 
24e4 c9				ret 
24e5			 
24e5			; given hl as pointer to dict structure 
24e5			; move to the next dict block structure 
24e5			 
24e5			forth_tok_next: 
24e5				; hl now points to the address of the next word pointer  
24e5				; TODO skip compiled symbol for now 
24e5			;	push de 
24e5 23				inc hl 
24e6 5e				ld e, (hl) 
24e7 23				inc hl 
24e8 56				ld d, (hl) 
24e9 23				inc hl 
24ea			 
24ea eb				ex de,hl 
24eb			if DEBUG_FORTH_PARSE_NEXTWORD 
24eb				push bc 
24eb				ld bc, (cli_nextword) 
24eb						DMARK "NXW" 
24eb				CALLMONITOR 
24eb				pop bc 
24eb			endif 
24eb			;	pop de	 
24eb c9				ret 
24ec			 
24ec			 
24ec			 
24ec			; eof 
# End of file forth_parserv6.asm
24ec				include "forth_wordsv4.asm" 
24ec			 
24ec			; the core word dictionary v4 
24ec			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
24ec			 
24ec			; this is a linked list for each of the system words used 
24ec			; user defined words will follow the same format but will be in ram 
24ec			 
24ec			 
24ec			; 
24ec			; 
24ec			; define linked list: 
24ec			; 
24ec			; 1. compiled byte op code 
24ec			; 2. len of text word 
24ec			; 3. text word 
24ec			; 4. ptr to next dictionary word 
24ec			; 5. asm, calls etc for the word 
24ec			; 
24ec			;  if 1 == 0 then last word in dict  
24ec			;   
24ec			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
24ec			;  
24ec			;  
24ec			; create basic standard set of words 
24ec			; 
24ec			;  
24ec			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
24ec			; 2DUP 2DROP 2SWAP  
24ec			; @ C@ - get byte  
24ec			; ! C! - store byte 
24ec			; 0< true if less than zero 
24ec			; 0= true if zero 
24ec			; < >  
24ec			; = true if same 
24ec			; variables 
24ec			 
24ec			 
24ec			; Hardware specific words I may need 
24ec			; 
24ec			; IN OUT  
24ec			; calls to key util functions 
24ec			; calls to hardward abstraction stuff 
24ec			; easy control of frame buffers and lcd i/o 
24ec			; keyboard  
24ec			 
24ec			 
24ec			;DICT: macro 
24ec			; op_code, len, word, next 
24ec			;    word: 
24ec			;    db op_code 
24ec			;    ds word zero term 
24ec			;    dw next 
24ec			;    endm 
24ec			 
24ec			 
24ec			 
24ec			 
24ec			; op code 1 is a flag for user define words which are to be handled differently 
24ec			 
24ec			 
24ec			; 
24ec			; 
24ec			;    TODO on entry to a word this should be the expected environment 
24ec			;    hl - tos value if number then held, if string this is the ptr 
24ec			;    de -  
24ec			 
24ec			 
24ec			; opcode ranges 
24ec			; 0 - end of word dict 
24ec			; 255 - user define words 
24ec			 
24ec			sysdict: 
24ec			include "forth_opcodes.asm" 
24ec			; op codes for forth keywords 
24ec			 
24ec			; Changing use of opcodes to flag is the word exists in compiled form or not.  
24ec			; This provides a means to compile uwords if required for higher performance 
24ec			; by avoiding the use of the keyword parser and just jumping directly to the code 
24ec			; Actually there is already a flag for if the code exists as binary thinking about it... 
24ec			 
24ec			 
24ec			 
24ec			 
24ec			 
24ec			; free to use code 0  
24ec				OPCODE_HEAP: equ  1 
24ec				OPCODE_EXEC: equ 2 
24ec				OPCODE_DUP: equ 3 
24ec				OPCODE_SWAP: equ 4 
24ec				OPCODE_COLN: equ 5 
24ec				OPCODE_SCOLN: equ 6 
24ec				OPCODE_DROP: equ 7 
24ec				OPCODE_DUP2: equ 8 
24ec				OPCODE_DROP2: equ 9 
24ec				OPCODE_SWAP2: equ 10 
24ec				OPCODE_AT: equ 11 
24ec				OPCODE_CAT: equ 12 
24ec				OPCODE_BANG: equ 13 
24ec				OPCODE_CBANG: equ 14 
24ec				OPCODE_SCALL: equ 15 
24ec				OPCODE_DEPTH: equ 16 
24ec				OPCODE_OVER: equ 17 
24ec				OPCODE_PAUSE: equ 18 
24ec				OPCODE_PAUSES: equ 19 
24ec				OPCODE_ROT: equ 20 
24ec			;free to reuse	OPCODE_WORDS: equ 21 
24ec			        OPCODE_NOT: equ 21 
24ec				OPCODE_UWORDS: equ 22 
24ec				OPCODE_BP: equ 23 
24ec				OPCODE_MONITOR: equ 24  
24ec				OPCODE_MALLOC: equ 25 
24ec				OPCODE_FREE: equ 26 
24ec				OPCODE_LIST: equ 27 
24ec				OPCODE_FORGET: equ 28 
24ec				OPCODE_NOP: equ 29 
24ec				OPCODE_COMO: equ 30 
24ec				OPCODE_COMC: equ 31 
24ec			;free to reuse	OPCODE_ENDCORE: equ 32 
24ec				OPCODE_AFTERSOUND: equ 33 
24ec				OPCODE_GP2: equ 34 
24ec				OPCODE_GP3: equ 35 
24ec				OPCODE_GP4: equ 36 
24ec				OPCODE_SIN: equ 37 
24ec				OPCODE_SOUT: equ 38 
24ec				OPCODE_SPIO: equ 39 
24ec				OPCODE_SPICEH: equ 40 
24ec				OPCODE_SPIOb: equ 41 
24ec				OPCODE_SPII: equ 42 
24ec				OPCODE_SESEL: equ 43 
24ec				OPCODE_CARTDEV: equ 44 
24ec			; free to reuse	OPCODE_ENDDEVICE: equ 45 
24ec				OPCODE_FB: equ 46 
24ec				OPCODE_EMIT: equ 47 
24ec				OPCODE_DOTH: equ 48 
24ec				OPCODE_DOTF: equ 49 
24ec				OPCODE_DOT: equ 50 
24ec				OPCODE_CLS: equ 51 
24ec				OPCODE_DRAW: equ 52 
24ec				OPCODE_DUMP: equ 53 
24ec				OPCODE_CDUMP: equ 54 
24ec				OPCODE_DAT: equ 55 
24ec				OPCODE_HOME: equ 56 
24ec				OPCODE_SPACE: equ 57 
24ec				OPCODE_SPACES: equ 58 
24ec				OPCODE_SCROLL: equ 59 
24ec				OPCODE_ATQ: equ 60 
24ec				OPCODE_AUTODSP: equ 61 
24ec				OPCODE_MENU: equ 62 
24ec			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
24ec				OPCODE_THEN: equ 64 
24ec				OPCODE_ELSE: equ 65 
24ec				OPCODE_DO: equ 66 
24ec				OPCODE_LOOP: equ 67 
24ec				OPCODE_I: equ 68 
24ec				OPCODE_DLOOP: equ 69  
24ec				OPCODE_REPEAT: equ 70  
24ec				OPCODE_UNTIL: equ 71 
24ec				OPCODE_ENDFLOW: equ 72 
24ec				OPCODE_WAITK: equ 73 
24ec				OPCODE_ACCEPT: equ 74 
24ec				OPCODE_EDIT: equ 75 
24ec			;free to reuse	OPCODE_ENDKEY: equ 76 
24ec				OPCODE_LZERO: equ 77 
24ec				OPCODE_TZERO: equ 78 
24ec				OPCODE_LESS: equ 79 
24ec				OPCODE_GT: equ 80 
24ec				OPCODE_EQUAL: equ 81  
24ec			;free to reuse	OPCODE_ENDLOGIC: equ 82 
24ec				OPCODE_NEG: equ 83 
24ec				OPCODE_DIV: equ 84 
24ec				OPCODE_MUL: equ 85 
24ec				OPCODE_MIN: equ 86 
24ec				OPCODE_MAX: equ 87 
24ec				OPCODE_RND16: equ 88 
24ec				OPCODE_RND8: equ 89 
24ec				OPCODE_RND: equ 90 
24ec			;free to reuse	OPCODE_ENDMATHS: equ 91  
24ec				OPCODE_BYNAME: equ 92 
24ec				OPCODE_DIR: equ 93 
24ec				OPCODE_SAVE: equ 94 
24ec				OPCODE_LOAD: equ 95 
24ec				OPCODE_BSAVE: equ 96 
24ec				OPCODE_BLOAD: equ 97 
24ec				OPCODE_SEO: equ 98  
24ec				OPCODE_SEI: equ 99 
24ec				OPCODE_SFREE: equ 100 
24ec				OPCODE_SIZE: equ 101 
24ec				OPCODE_CREATE: equ 102 
24ec				OPCODE_APPEND: equ 103 
24ec				OPCODE_SDEL: equ 104 
24ec				OPCODE_OPEN: equ 105 
24ec				OPCODE_READ: equ 106 
24ec				OPCODE_EOF: equ 106 
24ec				OPCODE_FORMAT: equ 107 
24ec				OPCODE_LABEL: equ 108 
24ec				OPCODE_LABELS: equ 109 
24ec			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
24ec				OPCODE_UPPER: equ 111 
24ec				OPCODE_LOWER: equ 112 
24ec				OPCODE_SUBSTR: equ 113 
24ec				OPCODE_LEFT: equ 114 
24ec				OPCODE_RIGHT: equ 115 
24ec				OPCODE_STR2NUM: equ 116 
24ec				OPCODE_NUM2STR: equ 117 
24ec				OPCODE_CONCAT: equ 118 
24ec				OPCODE_FIND: equ 119 
24ec				OPCODE_LEN: equ 120 
24ec				OPCODE_CHAR: equ 121 
24ec			; free to reuse	OPCODE_STRLEN: equ 122 
24ec			; free to reuse	OPCODE_ENDSTR: equ 123 
24ec				OPCODE_V0S: equ 124 
24ec				OPCODE_V0Q: equ 125 
24ec				OPCODE_V1S: equ 126 
24ec				OPCODE_V1Q: equ 127 
24ec				OPCODE_V2S: equ 128 
24ec				OPCODE_V2Q: equ 129 
24ec				OPCODE_V3S: equ 130 
24ec				OPCODE_V3Q: equ 131 
24ec			;free to reuse	OPCODE_END: equ 132 
24ec				OPCODE_ZDUP: equ 133 
24ec			 
24ec			; eof 
# End of file forth_opcodes.asm
24ec			 
24ec			include "forth_words_core.asm" 
24ec			 
24ec			; | ## Core Words 
24ec			 
24ec			;if MALLOC_4 
24ec			 
24ec			.HEAP: 
24ec			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
24ec 15				db WORD_SYS_CORE+OPCODE_HEAP             
24ed 2e 25			dw .EXEC            
24ef 05				db 4 + 1 
24f0 .. 00			db "HEAP",0              
24f5				endm 
# End of macro CWHEAD
24f5			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
24f5			; | | u1 - Current number of bytes in the heap 
24f5			; | | u2 - Remaining bytes left on the heap 
24f5			; | |  
24f5			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
24f5			 
24f5			 
24f5				if DEBUG_FORTH_WORDS_KEY 
24f5					DMARK "HEP" 
24f5 f5				push af  
24f6 3a 0a 25			ld a, (.dmark)  
24f9 32 9d fd			ld (debug_mark),a  
24fc 3a 0b 25			ld a, (.dmark+1)  
24ff 32 9e fd			ld (debug_mark+1),a  
2502 3a 0c 25			ld a, (.dmark+2)  
2505 32 9f fd			ld (debug_mark+2),a  
2508 18 03			jr .pastdmark  
250a ..			.dmark: db "HEP"  
250d f1			.pastdmark: pop af  
250e			endm  
# End of macro DMARK
250e					CALLMONITOR 
250e cd aa fd			call debug_vector  
2511				endm  
# End of macro CALLMONITOR
2511				endif 
2511 2a 0a 80			ld hl, (free_list )      
2514 11 0e 80			ld de, heap_start 
2517			 
2517 ed 52			sbc hl, de  
2519			 
2519 cd b8 1f			call forth_push_numhl 
251c			 
251c			 
251c ed 5b 0a 80		ld de, (free_list )      
2520 21 ce f0			ld hl, heap_end 
2523			 
2523 ed 52			sbc hl, de 
2525			 
2525 cd b8 1f			call forth_push_numhl 
2528				 
2528			 
2528				 
2528			 
2528			 
2528			 
2528				NEXTW 
2528 cd a7 fd			call parse_vector 
252b c3 a8 23			jp macro_next 
252e				endm 
# End of macro NEXTW
252e			;endif 
252e			 
252e			.EXEC: 
252e			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
252e			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
252e			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
252e			;; > > 
252e			;; > >   
252e			;	STACKFRAME OFF $5efe $5f9f 
252e			; 
252e			;		if DEBUG_FORTH_WORDS_KEY 
252e			;			DMARK "EXE" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			; 
252e			;	FORTH_DSP_VALUEHL 
252e			; 
252e			;	FORTH_DSP_POP 
252e			; 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EX1" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			;;	ld e,(hl) 
252e			;;	inc hl 
252e			;;	ld d,(hl) 
252e			;;	ex de,hl 
252e			; 
252e			;;		if DEBUG_FORTH_WORDS 
252e			;;			DMARK "EX2" 
252e			;;			CALLMONITOR 
252e			;;		endif 
252e			;	push hl 
252e			; 
252e			;	;ld a, 0 
252e			;	;ld a, FORTH_END_BUFFER 
252e			;	call strlenz 
252e			;	inc hl   ; include zero term to copy 
252e			;	inc hl   ; include term 
252e			;	inc hl   ; include term 
252e			;	ld b,0 
252e			;	ld c,l 
252e			;	pop hl 
252e			;	ld de, execscratch 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EX3" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			;	ldir 
252e			; 
252e			; 
252e			;	ld hl, execscratch 
252e			; 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EXe" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			; 
252e			;	call forthparse 
252e			;	call forthexec 
252e			;;	call forthexec_cleanup 
252e			;;	call forthparse 
252e			;;	call forthexec 
252e			; 
252e			;	STACKFRAMECHK OFF $5efe $5f9f 
252e			; 
252e			;	; an immediate word so no need to process any more words 
252e			;	ret 
252e			;	NEXTW 
252e			 
252e			; dead code - old version  
252e			;	FORTH_RSP_NEXT 
252e			 
252e			;  
252e			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
252e			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
252e			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
252e			;	push hl 
252e			;	push de 
252e			;	push bc 
252e			; 
252e			; 
252e			;		if DEBUG_FORTH_WORDS_KEY 
252e			;			DMARK "EXR" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			; 
252e			; 
252e			; 
252e			;	;v5 FORTH_DSP_VALUE 
252e			;	FORTH_DSP_VALUEHL 
252e			; 
252e			;	; TODO do string type checks 
252e			; 
252e			;;v5	inc hl   ; skip type 
252e			; 
252e			;	push hl  ; source code  
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EX1" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			;	ld a, 0 
252e			;	call strlent 
252e			; 
252e			;	inc hl 
252e			;	inc hl 
252e			;	inc hl 
252e			;	inc hl 
252e			; 
252e			;	push hl    ; size 
252e			; 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EX2" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			;	call malloc 
252e			; 
252e			;	ex de, hl    ; de now contains malloc area 
252e			;	pop bc   	; get byte count 
252e			;	pop hl      ; get string to copy 
252e			; 
252e			;	push de     ; save malloc for free later 
252e			; 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EX3" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			;	ldir       ; duplicate string 
252e			; 
252e			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
252e			;	 
252e			;	; TODO fix the parse would be better than this...  
252e			;	ex de, hl 
252e			;	dec hl 
252e			;	ld a, 0 
252e			;	ld (hl), a 
252e			;	dec hl 
252e			;	ld a, ' ' 
252e			;	ld (hl), a 
252e			;	dec hl 
252e			;	ld (hl), a 
252e			; 
252e			;	dec hl 
252e			;	ld (hl), a 
252e			; 
252e			; 
252e			;	FORTH_DSP_POP  
252e			; 
252e			;	pop hl     
252e			;	push hl    ; save malloc area 
252e			; 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EX4" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			; 
252e			;	call forthparse 
252e			;	call forthexec 
252e			;	 
252e			;	pop hl 
252e			;	if DEBUG_FORTH_WORDS 
252e			;		DMARK "EX5" 
252e			;		CALLMONITOR 
252e			;	endif 
252e			; 
252e			;	if FORTH_ENABLE_FREE 
252e			;	call free 
252e			;	endif 
252e			; 
252e			;	if DEBUG_FORTH_WORDS 
252e			;		DMARK "EX6" 
252e			;		CALLMONITOR 
252e			;	endif 
252e			; 
252e			;	pop bc 
252e			;	pop de 
252e			;	pop hl 
252e			;;	FORTH_RSP_POP	  
252e			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
252e			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
252e			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
252e			; 
252e			;	if DEBUG_FORTH_WORDS 
252e			;		DMARK "EX7" 
252e			;		CALLMONITOR 
252e			;	endif 
252e			;	NEXTW 
252e			 
252e			;.STKEXEC: 
252e			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
252e			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
252e			; 
252e			; 
252e			;		if DEBUG_FORTH_WORDS_KEY 
252e			;			DMARK "STX" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			; 
252e			;	FORTH_DSP_VALUEHL 
252e			; 
252e			;	ld (store_tmp1), hl    ; count 
252e			; 
252e			;	FORTH_DSP_POP 
252e			;.stkexec1: 
252e			;	ld hl, (store_tmp1)   ; count 
252e			;	ld a, 0 
252e			;	cp l 
252e			;	ret z 
252e			; 
252e			;	dec hl 
252e			;	ld (store_tmp1), hl    ; count 
252e			;	 
252e			;	FORTH_DSP_VALUEHL 
252e			;	push hl 
252e			;	 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EXp" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			;	FORTH_DSP_POP 
252e			; 
252e			;	call strlenz 
252e			;	inc hl   ; include zero term to copy 
252e			;	inc hl   ; include zero term to copy 
252e			;	inc hl   ; include zero term to copy 
252e			;	ld b,0 
252e			;	ld c,l 
252e			;	pop hl 
252e			;	ld de, execscratch 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EX3" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			;	ldir 
252e			; 
252e			; 
252e			;	ld hl, execscratch 
252e			; 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EXP" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			; 
252e			;	call forthparse 
252e			;	ld hl, execscratch 
252e			;		if DEBUG_FORTH_WORDS 
252e			;			DMARK "EXx" 
252e			;			CALLMONITOR 
252e			;		endif 
252e			;	call forthexec 
252e			; 
252e			;	jp .stkexec1 
252e			; 
252e			;	ret 
252e			 
252e			 
252e			.DUP: 
252e			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
252e 17				db WORD_SYS_CORE+OPCODE_DUP             
252f aa 25			dw .ZDUP            
2531 04				db 3 + 1 
2532 .. 00			db "DUP",0              
2536				endm 
# End of macro CWHEAD
2536			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2536			 
2536				if DEBUG_FORTH_WORDS_KEY 
2536					DMARK "DUP" 
2536 f5				push af  
2537 3a 4b 25			ld a, (.dmark)  
253a 32 9d fd			ld (debug_mark),a  
253d 3a 4c 25			ld a, (.dmark+1)  
2540 32 9e fd			ld (debug_mark+1),a  
2543 3a 4d 25			ld a, (.dmark+2)  
2546 32 9f fd			ld (debug_mark+2),a  
2549 18 03			jr .pastdmark  
254b ..			.dmark: db "DUP"  
254e f1			.pastdmark: pop af  
254f			endm  
# End of macro DMARK
254f					CALLMONITOR 
254f cd aa fd			call debug_vector  
2552				endm  
# End of macro CALLMONITOR
2552				endif 
2552			 
2552				FORTH_DSP 
2552 cd 83 21			call macro_forth_dsp 
2555				endm 
# End of macro FORTH_DSP
2555			 
2555 7e				ld a, (HL) 
2556 fe 01			cp DS_TYPE_STR 
2558 20 28			jr nz, .dupinum 
255a			 
255a				; push another string 
255a			 
255a				FORTH_DSP_VALUEHL     		 
255a cd bd 21			call macro_dsp_valuehl 
255d				endm 
# End of macro FORTH_DSP_VALUEHL
255d			 
255d			if DEBUG_FORTH_WORDS 
255d				DMARK "DUs" 
255d f5				push af  
255e 3a 72 25			ld a, (.dmark)  
2561 32 9d fd			ld (debug_mark),a  
2564 3a 73 25			ld a, (.dmark+1)  
2567 32 9e fd			ld (debug_mark+1),a  
256a 3a 74 25			ld a, (.dmark+2)  
256d 32 9f fd			ld (debug_mark+2),a  
2570 18 03			jr .pastdmark  
2572 ..			.dmark: db "DUs"  
2575 f1			.pastdmark: pop af  
2576			endm  
# End of macro DMARK
2576				CALLMONITOR 
2576 cd aa fd			call debug_vector  
2579				endm  
# End of macro CALLMONITOR
2579			endif 
2579 cd 26 20			call forth_push_str 
257c			 
257c				NEXTW 
257c cd a7 fd			call parse_vector 
257f c3 a8 23			jp macro_next 
2582				endm 
# End of macro NEXTW
2582			 
2582			 
2582			.dupinum: 
2582				 
2582			 
2582			 
2582				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2582 cd bd 21			call macro_dsp_valuehl 
2585				endm 
# End of macro FORTH_DSP_VALUEHL
2585			 
2585			; TODO add floating point number detection 
2585			 
2585			if DEBUG_FORTH_WORDS 
2585				DMARK "DUi" 
2585 f5				push af  
2586 3a 9a 25			ld a, (.dmark)  
2589 32 9d fd			ld (debug_mark),a  
258c 3a 9b 25			ld a, (.dmark+1)  
258f 32 9e fd			ld (debug_mark+1),a  
2592 3a 9c 25			ld a, (.dmark+2)  
2595 32 9f fd			ld (debug_mark+2),a  
2598 18 03			jr .pastdmark  
259a ..			.dmark: db "DUi"  
259d f1			.pastdmark: pop af  
259e			endm  
# End of macro DMARK
259e				CALLMONITOR 
259e cd aa fd			call debug_vector  
25a1				endm  
# End of macro CALLMONITOR
25a1			endif 
25a1			 
25a1 cd b8 1f			call forth_push_numhl 
25a4				NEXTW 
25a4 cd a7 fd			call parse_vector 
25a7 c3 a8 23			jp macro_next 
25aa				endm 
# End of macro NEXTW
25aa			.ZDUP: 
25aa			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
25aa 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25ab e5 25			dw .DMRK            
25ad 05				db 4 + 1 
25ae .. 00			db "?DUP",0              
25b3				endm 
# End of macro CWHEAD
25b3			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
25b3			 
25b3				if DEBUG_FORTH_WORDS_KEY 
25b3					DMARK "qDU" 
25b3 f5				push af  
25b4 3a c8 25			ld a, (.dmark)  
25b7 32 9d fd			ld (debug_mark),a  
25ba 3a c9 25			ld a, (.dmark+1)  
25bd 32 9e fd			ld (debug_mark+1),a  
25c0 3a ca 25			ld a, (.dmark+2)  
25c3 32 9f fd			ld (debug_mark+2),a  
25c6 18 03			jr .pastdmark  
25c8 ..			.dmark: db "qDU"  
25cb f1			.pastdmark: pop af  
25cc			endm  
# End of macro DMARK
25cc					CALLMONITOR 
25cc cd aa fd			call debug_vector  
25cf				endm  
# End of macro CALLMONITOR
25cf				endif 
25cf				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25cf cd bd 21			call macro_dsp_valuehl 
25d2				endm 
# End of macro FORTH_DSP_VALUEHL
25d2			 
25d2 e5				push hl 
25d3			 
25d3				; is it a zero? 
25d3			 
25d3 3e 00			ld a, 0 
25d5 84				add h 
25d6 85				add l 
25d7			 
25d7 e1				pop hl 
25d8			 
25d8 fe 00			cp 0 
25da 28 03			jr z, .dup2orig 
25dc			 
25dc			 
25dc cd b8 1f			call forth_push_numhl 
25df			 
25df			 
25df			; TODO add floating point number detection 
25df			 
25df			.dup2orig: 
25df			 
25df				NEXTW 
25df cd a7 fd			call parse_vector 
25e2 c3 a8 23			jp macro_next 
25e5				endm 
# End of macro NEXTW
25e5			.DMRK: 
25e5			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
25e5 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25e6 25 26			dw .LSHIFT            
25e8 06				db 5 + 1 
25e9 .. 00			db "DMARK",0              
25ef				endm 
# End of macro CWHEAD
25ef			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
25ef			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
25ef				if DEBUG_FORTH_WORDS_KEY 
25ef					DMARK "DMK" 
25ef f5				push af  
25f0 3a 04 26			ld a, (.dmark)  
25f3 32 9d fd			ld (debug_mark),a  
25f6 3a 05 26			ld a, (.dmark+1)  
25f9 32 9e fd			ld (debug_mark+1),a  
25fc 3a 06 26			ld a, (.dmark+2)  
25ff 32 9f fd			ld (debug_mark+2),a  
2602 18 03			jr .pastdmark  
2604 ..			.dmark: db "DMK"  
2607 f1			.pastdmark: pop af  
2608			endm  
# End of macro DMARK
2608					CALLMONITOR 
2608 cd aa fd			call debug_vector  
260b				endm  
# End of macro CALLMONITOR
260b				endif 
260b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260b cd bd 21			call macro_dsp_valuehl 
260e				endm 
# End of macro FORTH_DSP_VALUEHL
260e			 
260e 7e				ld a, (hl) 
260f 32 9d fd			ld (debug_mark),a 
2612 23				inc hl 
2613 7e				ld a, (hl) 
2614 32 9e fd			ld (debug_mark+1),a 
2617 23				inc hl 
2618 7e				ld a, (hl) 
2619 32 9f fd			ld (debug_mark+2),a 
261c			 
261c			 
261c				FORTH_DSP_POP 
261c cd 75 22			call macro_forth_dsp_pop 
261f				endm 
# End of macro FORTH_DSP_POP
261f				NEXTW 
261f cd a7 fd			call parse_vector 
2622 c3 a8 23			jp macro_next 
2625				endm 
# End of macro NEXTW
2625			.LSHIFT: 
2625			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
2625 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2626 5c 26			dw .RSHIFT            
2628 07				db 6 + 1 
2629 .. 00			db "LSHIFT",0              
2630				endm 
# End of macro CWHEAD
2630			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
2630				if DEBUG_FORTH_WORDS_KEY 
2630					DMARK "LSH" 
2630 f5				push af  
2631 3a 45 26			ld a, (.dmark)  
2634 32 9d fd			ld (debug_mark),a  
2637 3a 46 26			ld a, (.dmark+1)  
263a 32 9e fd			ld (debug_mark+1),a  
263d 3a 47 26			ld a, (.dmark+2)  
2640 32 9f fd			ld (debug_mark+2),a  
2643 18 03			jr .pastdmark  
2645 ..			.dmark: db "LSH"  
2648 f1			.pastdmark: pop af  
2649			endm  
# End of macro DMARK
2649					CALLMONITOR 
2649 cd aa fd			call debug_vector  
264c				endm  
# End of macro CALLMONITOR
264c				endif 
264c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
264c cd bd 21			call macro_dsp_valuehl 
264f				endm 
# End of macro FORTH_DSP_VALUEHL
264f				FORTH_DSP_POP 
264f cd 75 22			call macro_forth_dsp_pop 
2652				endm 
# End of macro FORTH_DSP_POP
2652			 
2652 29				add hl, hl 
2653 cd b8 1f			call forth_push_numhl 
2656				NEXTW 
2656 cd a7 fd			call parse_vector 
2659 c3 a8 23			jp macro_next 
265c				endm 
# End of macro NEXTW
265c			.RSHIFT: 
265c			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
265c 99				db WORD_SYS_CORE+OPCODE_ZDUP             
265d 96 26			dw .SWAP            
265f 07				db 6 + 1 
2660 .. 00			db "RSHIFT",0              
2667				endm 
# End of macro CWHEAD
2667			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
2667				if DEBUG_FORTH_WORDS_KEY 
2667					DMARK "RSH" 
2667 f5				push af  
2668 3a 7c 26			ld a, (.dmark)  
266b 32 9d fd			ld (debug_mark),a  
266e 3a 7d 26			ld a, (.dmark+1)  
2671 32 9e fd			ld (debug_mark+1),a  
2674 3a 7e 26			ld a, (.dmark+2)  
2677 32 9f fd			ld (debug_mark+2),a  
267a 18 03			jr .pastdmark  
267c ..			.dmark: db "RSH"  
267f f1			.pastdmark: pop af  
2680			endm  
# End of macro DMARK
2680					CALLMONITOR 
2680 cd aa fd			call debug_vector  
2683				endm  
# End of macro CALLMONITOR
2683				endif 
2683				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2683 cd bd 21			call macro_dsp_valuehl 
2686				endm 
# End of macro FORTH_DSP_VALUEHL
2686				FORTH_DSP_POP 
2686 cd 75 22			call macro_forth_dsp_pop 
2689				endm 
# End of macro FORTH_DSP_POP
2689 cb 3c			srl h 
268b cb 1d			rr l 
268d cd b8 1f			call forth_push_numhl 
2690				NEXTW 
2690 cd a7 fd			call parse_vector 
2693 c3 a8 23			jp macro_next 
2696				endm 
# End of macro NEXTW
2696			.SWAP: 
2696			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2696 18				db WORD_SYS_CORE+OPCODE_SWAP             
2697 ed 26			dw .COLN            
2699 05				db 4 + 1 
269a .. 00			db "SWAP",0              
269f				endm 
# End of macro CWHEAD
269f			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
269f				if DEBUG_FORTH_WORDS_KEY 
269f					DMARK "SWP" 
269f f5				push af  
26a0 3a b4 26			ld a, (.dmark)  
26a3 32 9d fd			ld (debug_mark),a  
26a6 3a b5 26			ld a, (.dmark+1)  
26a9 32 9e fd			ld (debug_mark+1),a  
26ac 3a b6 26			ld a, (.dmark+2)  
26af 32 9f fd			ld (debug_mark+2),a  
26b2 18 03			jr .pastdmark  
26b4 ..			.dmark: db "SWP"  
26b7 f1			.pastdmark: pop af  
26b8			endm  
# End of macro DMARK
26b8					CALLMONITOR 
26b8 cd aa fd			call debug_vector  
26bb				endm  
# End of macro CALLMONITOR
26bb				endif 
26bb			 
26bb			; DONE Use os stack swap memory 
26bb			 
26bb				FORTH_DSP_PTR 0     ; TOS 
26bb 2a 20 f9			ld hl,(cli_data_sp) 
26be 11 00 00			ld de, 0 * 3 
26c1 ed 52			sbc hl, de 
26c3				endm 
# End of macro FORTH_DSP_PTR
26c3 cd f4 22			call hltostack1 
26c6			  
26c6				FORTH_DSP_PTR 1     ; TOS 
26c6 2a 20 f9			ld hl,(cli_data_sp) 
26c9 11 03 00			ld de, 1 * 3 
26cc ed 52			sbc hl, de 
26ce				endm 
# End of macro FORTH_DSP_PTR
26ce cd fa 22			call hltostack2 
26d1			 
26d1				FORTH_DSP_PTR 0     ; TOS 
26d1 2a 20 f9			ld hl,(cli_data_sp) 
26d4 11 00 00			ld de, 0 * 3 
26d7 ed 52			sbc hl, de 
26d9				endm 
# End of macro FORTH_DSP_PTR
26d9 cd 12 23			call hlfromstack2 
26dc			 
26dc				FORTH_DSP_PTR 1     ; TOS 
26dc 2a 20 f9			ld hl,(cli_data_sp) 
26df 11 03 00			ld de, 1 * 3 
26e2 ed 52			sbc hl, de 
26e4				endm 
# End of macro FORTH_DSP_PTR
26e4 cd 0c 23			call hlfromstack1 
26e7			;	FORTH_DSP_VALUEHL 
26e7			;	push hl     ; w2 
26e7			; 
26e7			;	FORTH_DSP_POP 
26e7			; 
26e7			;	FORTH_DSP_VALUEHL 
26e7			; 
26e7			;	FORTH_DSP_POP 
26e7			; 
26e7			;	pop de     ; w2	, hl = w1 
26e7			; 
26e7			;	ex de, hl 
26e7			;	push de 
26e7			; 
26e7			;	call forth_push_numhl 
26e7			; 
26e7			;	pop hl 
26e7			; 
26e7			;	call forth_push_numhl 
26e7				 
26e7			 
26e7				NEXTW 
26e7 cd a7 fd			call parse_vector 
26ea c3 a8 23			jp macro_next 
26ed				endm 
# End of macro NEXTW
26ed			.COLN: 
26ed			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
26ed 19				db WORD_SYS_CORE+OPCODE_COLN             
26ee 79 28			dw .SCOLN            
26f0 02				db 1 + 1 
26f1 .. 00			db ":",0              
26f3				endm 
# End of macro CWHEAD
26f3			; | : ( -- )         Create new word | DONE 
26f3			 
26f3				if DEBUG_FORTH_WORDS_KEY 
26f3					DMARK "CLN" 
26f3 f5				push af  
26f4 3a 08 27			ld a, (.dmark)  
26f7 32 9d fd			ld (debug_mark),a  
26fa 3a 09 27			ld a, (.dmark+1)  
26fd 32 9e fd			ld (debug_mark+1),a  
2700 3a 0a 27			ld a, (.dmark+2)  
2703 32 9f fd			ld (debug_mark+2),a  
2706 18 03			jr .pastdmark  
2708 ..			.dmark: db "CLN"  
270b f1			.pastdmark: pop af  
270c			endm  
# End of macro DMARK
270c					CALLMONITOR 
270c cd aa fd			call debug_vector  
270f				endm  
# End of macro CALLMONITOR
270f				endif 
270f			STACKFRAME OFF $8efe $989f 
270f				if DEBUG_STACK_IMB 
270f					if OFF 
270f						exx 
270f						ld de, $8efe 
270f						ld a, d 
270f						ld hl, curframe 
270f						call hexout 
270f						ld a, e 
270f						ld hl, curframe+2 
270f						call hexout 
270f						ld hl, $8efe 
270f						push hl 
270f						ld hl, $989f 
270f						push hl 
270f						exx 
270f					endif 
270f				endif 
270f			endm 
# End of macro STACKFRAME
270f			; get parser buffer length  of new word 
270f			 
270f			 
270f			 
270f				; move tok past this to start of name defintition 
270f				; TODO get word to define 
270f				; TODO Move past word token 
270f				; TODO get length of string up to the ';' 
270f			 
270f 2a f4 f3		ld hl, (os_tok_ptr) 
2712 23			inc hl 
2713 23			inc hl 
2714			 
2714 3e 3b		ld a, ';' 
2716 cd 4f 13		call strlent 
2719			 
2719 7d			ld a,l 
271a 32 e3 f0		ld (os_new_parse_len), a 
271d			 
271d			 
271d			if DEBUG_FORTH_UWORD 
271d ed 5b f4 f3	ld de, (os_tok_ptr) 
2721					DMARK ":01" 
2721 f5				push af  
2722 3a 36 27			ld a, (.dmark)  
2725 32 9d fd			ld (debug_mark),a  
2728 3a 37 27			ld a, (.dmark+1)  
272b 32 9e fd			ld (debug_mark+1),a  
272e 3a 38 27			ld a, (.dmark+2)  
2731 32 9f fd			ld (debug_mark+2),a  
2734 18 03			jr .pastdmark  
2736 ..			.dmark: db ":01"  
2739 f1			.pastdmark: pop af  
273a			endm  
# End of macro DMARK
273a			CALLMONITOR 
273a cd aa fd			call debug_vector  
273d				endm  
# End of macro CALLMONITOR
273d			endif 
273d			 
273d			; 
273d			;  new word memory layout: 
273d			;  
273d			;    : adg 6666 ;  
273d			; 
273d			;    db   1     ; user defined word  
273d 23			inc hl    
273e			;    dw   sysdict 
273e 23			inc hl 
273f 23			inc hl 
2740			;    db <word len>+1 (for null) 
2740 23			inc hl 
2741			;    db .... <word> 
2741			; 
2741			 
2741 23			inc hl    ; some extras for the word preamble before the above 
2742 23			inc hl 
2743 23			inc hl 
2744 23			inc hl 
2745 23			inc hl 
2746 23			inc hl 
2747 23			inc hl  
2748 23			inc hl 
2749 23			inc hl 
274a 23			inc hl 
274b 23			inc hl 
274c 23			inc hl 
274d 23			inc hl 
274e 23			inc hl     ; TODO how many do we really need?     maybe only 6 
274f			;       exec word buffer 
274f			;	<ptr word>   
274f 23			inc hl 
2750 23			inc hl 
2751			;       <word list><null term> 7F final term 
2751			 
2751			 
2751			if DEBUG_FORTH_UWORD 
2751					DMARK ":02" 
2751 f5				push af  
2752 3a 66 27			ld a, (.dmark)  
2755 32 9d fd			ld (debug_mark),a  
2758 3a 67 27			ld a, (.dmark+1)  
275b 32 9e fd			ld (debug_mark+1),a  
275e 3a 68 27			ld a, (.dmark+2)  
2761 32 9f fd			ld (debug_mark+2),a  
2764 18 03			jr .pastdmark  
2766 ..			.dmark: db ":02"  
2769 f1			.pastdmark: pop af  
276a			endm  
# End of macro DMARK
276a			CALLMONITOR 
276a cd aa fd			call debug_vector  
276d				endm  
# End of macro CALLMONITOR
276d			endif 
276d			 
276d			 
276d				; malloc the size 
276d			 
276d cd b9 13			call malloc 
2770 22 e5 f0			ld (os_new_malloc), hl     ; save malloc start 
2773			 
2773			;    db   1     ; user defined word  
2773 3e 01			ld a, WORD_SYS_UWORD  
2775 77				ld (hl), a 
2776			 
2776 23			inc hl    
2777			;    dw   sysdict 
2777 11 ec 24		ld de, sysdict       ; continue on with the scan to the system dict 
277a 73			ld (hl), e 
277b 23			inc hl 
277c 72			ld (hl), d 
277d 23			inc hl 
277e			 
277e			 
277e			;    Setup dict word 
277e			 
277e 23			inc hl 
277f 22 df f0		ld (os_new_work_ptr), hl     ; save start of dict word  
2782			 
2782			; 1. get length of dict word 
2782			 
2782			 
2782 2a f4 f3		ld hl, (os_tok_ptr) 
2785 23			inc hl 
2786 23			inc hl    ; position to start of dict word 
2787 3e 00		ld a, 0 
2789 cd 4f 13		call strlent 
278c			 
278c			 
278c 23			inc hl    ; to include null??? 
278d			 
278d			; write length of dict word 
278d			 
278d ed 5b df f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2791 1b			dec de 
2792 eb			ex de, hl 
2793 73			ld (hl), e 
2794 eb			ex de, hl 
2795			 
2795			 
2795			 
2795			; copy  
2795 4d			ld c, l 
2796 06 00		ld b, 0 
2798 ed 5b df f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
279c 2a f4 f3		ld hl, (os_tok_ptr) 
279f 23			inc hl 
27a0 23			inc hl    ; position to start of dict word 
27a1			 
27a1			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27a1			 
27a1			; TODO need to convert word to upper case 
27a1			 
27a1			ucasetok:	 
27a1 7e			ld a,(hl) 
27a2 cd 3b 13		call toUpper 
27a5 77			ld (hl),a 
27a6 ed a0		ldi 
27a8 f2 a1 27		jp p, ucasetok 
27ab			 
27ab			 
27ab			 
27ab			; de now points to start of where the word body code should be placed 
27ab ed 53 df f0	ld (os_new_work_ptr), de 
27af			; hl now points to the words to throw at forthexec which needs to be copied 
27af 22 dd f0		ld (os_new_src_ptr), hl 
27b2			 
27b2			; TODO add 'call to forthexec' 
27b2			 
27b2			if DEBUG_FORTH_UWORD 
27b2 c5			push bc 
27b3 ed 4b e5 f0	ld bc, (os_new_malloc) 
27b7					DMARK ":0x" 
27b7 f5				push af  
27b8 3a cc 27			ld a, (.dmark)  
27bb 32 9d fd			ld (debug_mark),a  
27be 3a cd 27			ld a, (.dmark+1)  
27c1 32 9e fd			ld (debug_mark+1),a  
27c4 3a ce 27			ld a, (.dmark+2)  
27c7 32 9f fd			ld (debug_mark+2),a  
27ca 18 03			jr .pastdmark  
27cc ..			.dmark: db ":0x"  
27cf f1			.pastdmark: pop af  
27d0			endm  
# End of macro DMARK
27d0			CALLMONITOR 
27d0 cd aa fd			call debug_vector  
27d3				endm  
# End of macro CALLMONITOR
27d3 c1			pop bc 
27d4			endif 
27d4			 
27d4			 
27d4			; create word preamble which should be: 
27d4			 
27d4			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
27d4			 
27d4			;    ld hl, <word code> 
27d4			;    jp user_exec 
27d4			;    <word code bytes> 
27d4			 
27d4			 
27d4			;	inc de     ; TODO ??? or are we already past the word's null 
27d4 eb			ex de, hl 
27d5			 
27d5 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
27d7			 
27d7 23			inc hl 
27d8 22 d9 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
27db 23			inc hl 
27dc			 
27dc 23			inc hl 
27dd 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
27df			 
27df 01 0b 64		ld bc, user_exec 
27e2 23			inc hl 
27e3 71			ld (hl), c     ; poke address of user_exec 
27e4 23			inc hl 
27e5 70			ld (hl), b     
27e6			; 
27e6			;	inc hl 
27e6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27e6			; 
27e6			; 
27e6			;	ld bc, macro_forth_rsp_next 
27e6			;	inc hl 
27e6			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
27e6			;	inc hl 
27e6			;	ld (hl), b     
27e6			; 
27e6			;	inc hl 
27e6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27e6			; 
27e6			; 
27e6			;	inc hl 
27e6			;	ld bc, forthexec 
27e6			;	ld (hl), c     ; poke address of forthexec 
27e6			;	inc hl 
27e6			;	ld (hl), b      
27e6			; 
27e6			;	inc hl 
27e6			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
27e6			; 
27e6			;	ld bc, user_dict_next 
27e6			;	inc hl 
27e6			;	ld (hl), c     ; poke address of forthexec 
27e6			;	inc hl 
27e6			;	ld (hl), b      
27e6			 
27e6			; hl is now where we need to copy the word byte data to save this 
27e6			 
27e6 23			inc hl 
27e7 22 db f0		ld (os_new_exec), hl 
27ea			 
27ea			; copy definition 
27ea			 
27ea eb			ex de, hl 
27eb			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
27eb			;	inc de    ; skip the PC for this parse 
27eb 3a e3 f0		ld a, (os_new_parse_len) 
27ee 4f			ld c, a 
27ef 06 00		ld b, 0 
27f1 ed b0		ldir		 ; copy defintion 
27f3			 
27f3			 
27f3			; poke the address of where the new word bytes live for forthexec 
27f3			 
27f3 2a d9 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
27f6			 
27f6 ed 5b db f0	ld de, (os_new_exec)      
27fa			 
27fa 73			ld (hl), e 
27fb 23			inc hl 
27fc 72			ld (hl), d 
27fd			 
27fd				; TODO copy last user dict word next link to this word 
27fd				; TODO update last user dict word to point to this word 
27fd			; 
27fd			; hl f923 de 812a ; bc 811a 
27fd			 
27fd			if DEBUG_FORTH_UWORD 
27fd c5			push bc 
27fe ed 4b e5 f0	ld bc, (os_new_malloc) 
2802					DMARK ":0A" 
2802 f5				push af  
2803 3a 17 28			ld a, (.dmark)  
2806 32 9d fd			ld (debug_mark),a  
2809 3a 18 28			ld a, (.dmark+1)  
280c 32 9e fd			ld (debug_mark+1),a  
280f 3a 19 28			ld a, (.dmark+2)  
2812 32 9f fd			ld (debug_mark+2),a  
2815 18 03			jr .pastdmark  
2817 ..			.dmark: db ":0A"  
281a f1			.pastdmark: pop af  
281b			endm  
# End of macro DMARK
281b			CALLMONITOR 
281b cd aa fd			call debug_vector  
281e				endm  
# End of macro CALLMONITOR
281e c1			pop bc 
281f			endif 
281f			if DEBUG_FORTH_UWORD 
281f c5			push bc 
2820 ed 4b e5 f0	ld bc, (os_new_malloc) 
2824 03			inc bc 
2825 03			inc bc 
2826 03			inc bc 
2827 03			inc bc 
2828 03			inc bc 
2829 03			inc bc 
282a 03			inc bc 
282b 03			inc bc 
282c			 
282c					DMARK ":0B" 
282c f5				push af  
282d 3a 41 28			ld a, (.dmark)  
2830 32 9d fd			ld (debug_mark),a  
2833 3a 42 28			ld a, (.dmark+1)  
2836 32 9e fd			ld (debug_mark+1),a  
2839 3a 43 28			ld a, (.dmark+2)  
283c 32 9f fd			ld (debug_mark+2),a  
283f 18 03			jr .pastdmark  
2841 ..			.dmark: db ":0B"  
2844 f1			.pastdmark: pop af  
2845			endm  
# End of macro DMARK
2845			CALLMONITOR 
2845 cd aa fd			call debug_vector  
2848				endm  
# End of macro CALLMONITOR
2848 c1			pop bc 
2849			endif 
2849			 
2849			; update word dict linked list for new word 
2849			 
2849			 
2849 2a f0 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
284c 23			inc hl     ; move to next work linked list ptr 
284d			 
284d ed 5b e5 f0	ld de, (os_new_malloc)		 ; new next word 
2851 73			ld (hl), e 
2852 23			inc hl 
2853 72			ld (hl), d 
2854			 
2854			if DEBUG_FORTH_UWORD 
2854 ed 4b f0 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2858			endif 
2858			 
2858 ed 53 f0 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
285c			 
285c			 
285c			if DEBUG_FORTH_UWORD 
285c					DMARK ":0+" 
285c f5				push af  
285d 3a 71 28			ld a, (.dmark)  
2860 32 9d fd			ld (debug_mark),a  
2863 3a 72 28			ld a, (.dmark+1)  
2866 32 9e fd			ld (debug_mark+1),a  
2869 3a 73 28			ld a, (.dmark+2)  
286c 32 9f fd			ld (debug_mark+2),a  
286f 18 03			jr .pastdmark  
2871 ..			.dmark: db ":0+"  
2874 f1			.pastdmark: pop af  
2875			endm  
# End of macro DMARK
2875			CALLMONITOR 
2875 cd aa fd			call debug_vector  
2878				endm  
# End of macro CALLMONITOR
2878			endif 
2878			 
2878			STACKFRAMECHK OFF $8efe $989f 
2878				if DEBUG_STACK_IMB 
2878					if OFF 
2878						exx 
2878						ld hl, $989f 
2878						pop de   ; $989f 
2878						call cmp16 
2878						jr nz, .spnosame 
2878						ld hl, $8efe 
2878						pop de   ; $8efe 
2878						call cmp16 
2878						jr z, .spfrsame 
2878						.spnosame: call showsperror 
2878						.spfrsame: nop 
2878						exx 
2878					endif 
2878				endif 
2878			endm 
# End of macro STACKFRAMECHK
2878			 
2878 c9			ret    ; dont process any remaining parser tokens as they form new word 
2879			 
2879			 
2879			 
2879			 
2879			;		NEXT 
2879			.SCOLN: 
2879			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2879 06			db OPCODE_SCOLN 
287a c8 28		dw .DROP 
287c 02			db 2 
287d .. 00		db ";",0           
287f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
287f				if DEBUG_FORTH_WORDS_KEY 
287f					DMARK "SCN" 
287f f5				push af  
2880 3a 94 28			ld a, (.dmark)  
2883 32 9d fd			ld (debug_mark),a  
2886 3a 95 28			ld a, (.dmark+1)  
2889 32 9e fd			ld (debug_mark+1),a  
288c 3a 96 28			ld a, (.dmark+2)  
288f 32 9f fd			ld (debug_mark+2),a  
2892 18 03			jr .pastdmark  
2894 ..			.dmark: db "SCN"  
2897 f1			.pastdmark: pop af  
2898			endm  
# End of macro DMARK
2898					CALLMONITOR 
2898 cd aa fd			call debug_vector  
289b				endm  
# End of macro CALLMONITOR
289b				endif 
289b				FORTH_RSP_TOS 
289b cd 76 1f			call macro_forth_rsp_tos 
289e				endm 
# End of macro FORTH_RSP_TOS
289e e5				push hl 
289f				FORTH_RSP_POP 
289f cd 80 1f			call macro_forth_rsp_pop 
28a2				endm 
# End of macro FORTH_RSP_POP
28a2 e1				pop hl 
28a3			;		ex de,hl 
28a3 22 f4 f3			ld (os_tok_ptr),hl 
28a6			 
28a6			if DEBUG_FORTH_UWORD 
28a6					DMARK "SCL" 
28a6 f5				push af  
28a7 3a bb 28			ld a, (.dmark)  
28aa 32 9d fd			ld (debug_mark),a  
28ad 3a bc 28			ld a, (.dmark+1)  
28b0 32 9e fd			ld (debug_mark+1),a  
28b3 3a bd 28			ld a, (.dmark+2)  
28b6 32 9f fd			ld (debug_mark+2),a  
28b9 18 03			jr .pastdmark  
28bb ..			.dmark: db "SCL"  
28be f1			.pastdmark: pop af  
28bf			endm  
# End of macro DMARK
28bf			CALLMONITOR 
28bf cd aa fd			call debug_vector  
28c2				endm  
# End of macro CALLMONITOR
28c2			endif 
28c2				NEXTW 
28c2 cd a7 fd			call parse_vector 
28c5 c3 a8 23			jp macro_next 
28c8				endm 
# End of macro NEXTW
28c8			 
28c8			.DROP: 
28c8			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
28c8 1b				db WORD_SYS_CORE+OPCODE_DROP             
28c9 f6 28			dw .DUP2            
28cb 05				db 4 + 1 
28cc .. 00			db "DROP",0              
28d1				endm 
# End of macro CWHEAD
28d1			; | DROP ( w -- )   drop the TOS item   | DONE 
28d1				if DEBUG_FORTH_WORDS_KEY 
28d1					DMARK "DRP" 
28d1 f5				push af  
28d2 3a e6 28			ld a, (.dmark)  
28d5 32 9d fd			ld (debug_mark),a  
28d8 3a e7 28			ld a, (.dmark+1)  
28db 32 9e fd			ld (debug_mark+1),a  
28de 3a e8 28			ld a, (.dmark+2)  
28e1 32 9f fd			ld (debug_mark+2),a  
28e4 18 03			jr .pastdmark  
28e6 ..			.dmark: db "DRP"  
28e9 f1			.pastdmark: pop af  
28ea			endm  
# End of macro DMARK
28ea					CALLMONITOR 
28ea cd aa fd			call debug_vector  
28ed				endm  
# End of macro CALLMONITOR
28ed				endif 
28ed				FORTH_DSP_POP 
28ed cd 75 22			call macro_forth_dsp_pop 
28f0				endm 
# End of macro FORTH_DSP_POP
28f0				NEXTW 
28f0 cd a7 fd			call parse_vector 
28f3 c3 a8 23			jp macro_next 
28f6				endm 
# End of macro NEXTW
28f6			.DUP2: 
28f6			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
28f6 1c				db WORD_SYS_CORE+OPCODE_DUP2             
28f7 3e 29			dw .DROP2            
28f9 05				db 4 + 1 
28fa .. 00			db "2DUP",0              
28ff				endm 
# End of macro CWHEAD
28ff			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
28ff				if DEBUG_FORTH_WORDS_KEY 
28ff					DMARK "2DU" 
28ff f5				push af  
2900 3a 14 29			ld a, (.dmark)  
2903 32 9d fd			ld (debug_mark),a  
2906 3a 15 29			ld a, (.dmark+1)  
2909 32 9e fd			ld (debug_mark+1),a  
290c 3a 16 29			ld a, (.dmark+2)  
290f 32 9f fd			ld (debug_mark+2),a  
2912 18 03			jr .pastdmark  
2914 ..			.dmark: db "2DU"  
2917 f1			.pastdmark: pop af  
2918			endm  
# End of macro DMARK
2918					CALLMONITOR 
2918 cd aa fd			call debug_vector  
291b				endm  
# End of macro CALLMONITOR
291b				endif 
291b				FORTH_DSP_VALUEHL 
291b cd bd 21			call macro_dsp_valuehl 
291e				endm 
# End of macro FORTH_DSP_VALUEHL
291e e5				push hl      ; 2 
291f			 
291f				FORTH_DSP_POP 
291f cd 75 22			call macro_forth_dsp_pop 
2922				endm 
# End of macro FORTH_DSP_POP
2922				 
2922				FORTH_DSP_VALUEHL 
2922 cd bd 21			call macro_dsp_valuehl 
2925				endm 
# End of macro FORTH_DSP_VALUEHL
2925			;		push hl      ; 1 
2925			 
2925				FORTH_DSP_POP 
2925 cd 75 22			call macro_forth_dsp_pop 
2928				endm 
# End of macro FORTH_DSP_POP
2928			 
2928			;		pop hl       ; 1 
2928 d1				pop de       ; 2 
2929			 
2929 cd b8 1f			call forth_push_numhl 
292c eb				ex de, hl 
292d cd b8 1f			call forth_push_numhl 
2930			 
2930				 
2930 eb				ex de, hl 
2931			 
2931 cd b8 1f			call forth_push_numhl 
2934 eb				ex de, hl 
2935 cd b8 1f			call forth_push_numhl 
2938			 
2938			 
2938				NEXTW 
2938 cd a7 fd			call parse_vector 
293b c3 a8 23			jp macro_next 
293e				endm 
# End of macro NEXTW
293e			.DROP2: 
293e			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
293e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
293f 70 29			dw .PICK            
2941 06				db 5 + 1 
2942 .. 00			db "2DROP",0              
2948				endm 
# End of macro CWHEAD
2948			; | 2DROP ( w w -- )    Double drop | DONE 
2948				if DEBUG_FORTH_WORDS_KEY 
2948					DMARK "2DR" 
2948 f5				push af  
2949 3a 5d 29			ld a, (.dmark)  
294c 32 9d fd			ld (debug_mark),a  
294f 3a 5e 29			ld a, (.dmark+1)  
2952 32 9e fd			ld (debug_mark+1),a  
2955 3a 5f 29			ld a, (.dmark+2)  
2958 32 9f fd			ld (debug_mark+2),a  
295b 18 03			jr .pastdmark  
295d ..			.dmark: db "2DR"  
2960 f1			.pastdmark: pop af  
2961			endm  
# End of macro DMARK
2961					CALLMONITOR 
2961 cd aa fd			call debug_vector  
2964				endm  
# End of macro CALLMONITOR
2964				endif 
2964				FORTH_DSP_POP 
2964 cd 75 22			call macro_forth_dsp_pop 
2967				endm 
# End of macro FORTH_DSP_POP
2967				FORTH_DSP_POP 
2967 cd 75 22			call macro_forth_dsp_pop 
296a				endm 
# End of macro FORTH_DSP_POP
296a				NEXTW 
296a cd a7 fd			call parse_vector 
296d c3 a8 23			jp macro_next 
2970				endm 
# End of macro NEXTW
2970			.PICK: 
2970			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
2970 77				db WORD_SYS_CORE+99             
2971 0d 2a			dw .SWAP2            
2973 05				db 4 + 1 
2974 .. 00			db "PICK",0              
2979				endm 
# End of macro CWHEAD
2979			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
2979			; | | >[!NOTE] 
2979			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
2979				if DEBUG_FORTH_WORDS_KEY 
2979					DMARK "PIK" 
2979 f5				push af  
297a 3a 8e 29			ld a, (.dmark)  
297d 32 9d fd			ld (debug_mark),a  
2980 3a 8f 29			ld a, (.dmark+1)  
2983 32 9e fd			ld (debug_mark+1),a  
2986 3a 90 29			ld a, (.dmark+2)  
2989 32 9f fd			ld (debug_mark+2),a  
298c 18 03			jr .pastdmark  
298e ..			.dmark: db "PIK"  
2991 f1			.pastdmark: pop af  
2992			endm  
# End of macro DMARK
2992					CALLMONITOR 
2992 cd aa fd			call debug_vector  
2995				endm  
# End of macro CALLMONITOR
2995				endif 
2995			 
2995				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2995 cd bd 21			call macro_dsp_valuehl 
2998				endm 
# End of macro FORTH_DSP_VALUEHL
2998				 
2998				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2998 cd 75 22			call macro_forth_dsp_pop 
299b				endm 
# End of macro FORTH_DSP_POP
299b			 
299b				; init from TOS 
299b e5				push hl 
299c				FORTH_DSP 
299c cd 83 21			call macro_forth_dsp 
299f				endm 
# End of macro FORTH_DSP
299f			;	ld hl, cli_data_sp 
299f				if DEBUG_FORTH_WORDS 
299f					DMARK "PK1" 
299f f5				push af  
29a0 3a b4 29			ld a, (.dmark)  
29a3 32 9d fd			ld (debug_mark),a  
29a6 3a b5 29			ld a, (.dmark+1)  
29a9 32 9e fd			ld (debug_mark+1),a  
29ac 3a b6 29			ld a, (.dmark+2)  
29af 32 9f fd			ld (debug_mark+2),a  
29b2 18 03			jr .pastdmark  
29b4 ..			.dmark: db "PK1"  
29b7 f1			.pastdmark: pop af  
29b8			endm  
# End of macro DMARK
29b8					CALLMONITOR 
29b8 cd aa fd			call debug_vector  
29bb				endm  
# End of macro CALLMONITOR
29bb				endif 
29bb c1				pop bc 
29bc 41				ld b,c 
29bd 3e 00			ld a, 0 
29bf b8				cp b 
29c0 28 21			jr z, .pdone	 
29c2			.pkl: 
29c2 2b				dec hl 
29c3 2b				dec hl 
29c4 2b				dec hl 
29c5			 
29c5				if DEBUG_FORTH_WORDS 
29c5					DMARK "PKl" 
29c5 f5				push af  
29c6 3a da 29			ld a, (.dmark)  
29c9 32 9d fd			ld (debug_mark),a  
29cc 3a db 29			ld a, (.dmark+1)  
29cf 32 9e fd			ld (debug_mark+1),a  
29d2 3a dc 29			ld a, (.dmark+2)  
29d5 32 9f fd			ld (debug_mark+2),a  
29d8 18 03			jr .pastdmark  
29da ..			.dmark: db "PKl"  
29dd f1			.pastdmark: pop af  
29de			endm  
# End of macro DMARK
29de					CALLMONITOR 
29de cd aa fd			call debug_vector  
29e1				endm  
# End of macro CALLMONITOR
29e1				endif 
29e1 10 df			djnz .pkl 
29e3			.pdone: 
29e3				 
29e3				; TODO do type check with correct push 
29e3			 
29e3 23				inc hl 
29e4				;call loadwordinhl 
29e4 5e				ld e, (hl) 
29e5 23				inc hl 
29e6 56				ld d, (hl) 
29e7 eb				ex de,hl 
29e8				if DEBUG_FORTH_WORDS 
29e8					DMARK "PKp" 
29e8 f5				push af  
29e9 3a fd 29			ld a, (.dmark)  
29ec 32 9d fd			ld (debug_mark),a  
29ef 3a fe 29			ld a, (.dmark+1)  
29f2 32 9e fd			ld (debug_mark+1),a  
29f5 3a ff 29			ld a, (.dmark+2)  
29f8 32 9f fd			ld (debug_mark+2),a  
29fb 18 03			jr .pastdmark  
29fd ..			.dmark: db "PKp"  
2a00 f1			.pastdmark: pop af  
2a01			endm  
# End of macro DMARK
2a01					CALLMONITOR 
2a01 cd aa fd			call debug_vector  
2a04				endm  
# End of macro CALLMONITOR
2a04				endif 
2a04 cd b8 1f			call forth_push_numhl 
2a07			 
2a07				NEXTW 
2a07 cd a7 fd			call parse_vector 
2a0a c3 a8 23			jp macro_next 
2a0d				endm 
# End of macro NEXTW
2a0d			.SWAP2: 
2a0d			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2a0d 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2a0e 91 2a			dw .AT            
2a10 06				db 5 + 1 
2a11 .. 00			db "2SWAP",0              
2a17				endm 
# End of macro CWHEAD
2a17			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2a17				if DEBUG_FORTH_WORDS_KEY 
2a17					DMARK "2SW" 
2a17 f5				push af  
2a18 3a 2c 2a			ld a, (.dmark)  
2a1b 32 9d fd			ld (debug_mark),a  
2a1e 3a 2d 2a			ld a, (.dmark+1)  
2a21 32 9e fd			ld (debug_mark+1),a  
2a24 3a 2e 2a			ld a, (.dmark+2)  
2a27 32 9f fd			ld (debug_mark+2),a  
2a2a 18 03			jr .pastdmark  
2a2c ..			.dmark: db "2SW"  
2a2f f1			.pastdmark: pop af  
2a30			endm  
# End of macro DMARK
2a30					CALLMONITOR 
2a30 cd aa fd			call debug_vector  
2a33				endm  
# End of macro CALLMONITOR
2a33				endif 
2a33			; TODO Use os stack swap memory 
2a33			 
2a33				FORTH_DSP_PTR 0     ; TOS    w4 
2a33 2a 20 f9			ld hl,(cli_data_sp) 
2a36 11 00 00			ld de, 0 * 3 
2a39 ed 52			sbc hl, de 
2a3b				endm 
# End of macro FORTH_DSP_PTR
2a3b cd f4 22			call hltostack1 
2a3e			  
2a3e				FORTH_DSP_PTR 1     ; TOS    w3 
2a3e 2a 20 f9			ld hl,(cli_data_sp) 
2a41 11 03 00			ld de, 1 * 3 
2a44 ed 52			sbc hl, de 
2a46				endm 
# End of macro FORTH_DSP_PTR
2a46 cd fa 22			call hltostack2 
2a49			 
2a49			 
2a49			 
2a49				FORTH_DSP_PTR 2     ; TOS    w2 
2a49 2a 20 f9			ld hl,(cli_data_sp) 
2a4c 11 06 00			ld de, 2 * 3 
2a4f ed 52			sbc hl, de 
2a51				endm 
# End of macro FORTH_DSP_PTR
2a51 cd 00 23			call hltostack3 
2a54			 
2a54				FORTH_DSP_PTR 3     ; TOS   w1 
2a54 2a 20 f9			ld hl,(cli_data_sp) 
2a57 11 09 00			ld de, 3 * 3 
2a5a ed 52			sbc hl, de 
2a5c				endm 
# End of macro FORTH_DSP_PTR
2a5c cd 06 23			call hltostack4 
2a5f			 
2a5f			 
2a5f			 
2a5f			 
2a5f				FORTH_DSP_PTR 0     ; TOS 
2a5f 2a 20 f9			ld hl,(cli_data_sp) 
2a62 11 00 00			ld de, 0 * 3 
2a65 ed 52			sbc hl, de 
2a67				endm 
# End of macro FORTH_DSP_PTR
2a67 cd 18 23			call hlfromstack3 
2a6a			 
2a6a				FORTH_DSP_PTR 1     ; TOS 
2a6a 2a 20 f9			ld hl,(cli_data_sp) 
2a6d 11 03 00			ld de, 1 * 3 
2a70 ed 52			sbc hl, de 
2a72				endm 
# End of macro FORTH_DSP_PTR
2a72 cd 1e 23			call hlfromstack4 
2a75			 
2a75			 
2a75			 
2a75				FORTH_DSP_PTR 2     ; TOS 
2a75 2a 20 f9			ld hl,(cli_data_sp) 
2a78 11 06 00			ld de, 2 * 3 
2a7b ed 52			sbc hl, de 
2a7d				endm 
# End of macro FORTH_DSP_PTR
2a7d cd 0c 23			call hlfromstack1 
2a80			 
2a80				FORTH_DSP_PTR 3     ; TOS 
2a80 2a 20 f9			ld hl,(cli_data_sp) 
2a83 11 09 00			ld de, 3 * 3 
2a86 ed 52			sbc hl, de 
2a88				endm 
# End of macro FORTH_DSP_PTR
2a88 cd 12 23			call hlfromstack2 
2a8b			 
2a8b				NEXTW 
2a8b cd a7 fd			call parse_vector 
2a8e c3 a8 23			jp macro_next 
2a91				endm 
# End of macro NEXTW
2a91			.AT: 
2a91			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2a91 1f				db WORD_SYS_CORE+OPCODE_AT             
2a92 c6 2a			dw .CAT            
2a94 02				db 1 + 1 
2a95 .. 00			db "@",0              
2a97				endm 
# End of macro CWHEAD
2a97			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2a97			 
2a97				if DEBUG_FORTH_WORDS_KEY 
2a97					DMARK "AT." 
2a97 f5				push af  
2a98 3a ac 2a			ld a, (.dmark)  
2a9b 32 9d fd			ld (debug_mark),a  
2a9e 3a ad 2a			ld a, (.dmark+1)  
2aa1 32 9e fd			ld (debug_mark+1),a  
2aa4 3a ae 2a			ld a, (.dmark+2)  
2aa7 32 9f fd			ld (debug_mark+2),a  
2aaa 18 03			jr .pastdmark  
2aac ..			.dmark: db "AT."  
2aaf f1			.pastdmark: pop af  
2ab0			endm  
# End of macro DMARK
2ab0					CALLMONITOR 
2ab0 cd aa fd			call debug_vector  
2ab3				endm  
# End of macro CALLMONITOR
2ab3				endif 
2ab3			.getbyteat:	 
2ab3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab3 cd bd 21			call macro_dsp_valuehl 
2ab6				endm 
# End of macro FORTH_DSP_VALUEHL
2ab6				 
2ab6			;		push hl 
2ab6			 
2ab6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab6 cd 75 22			call macro_forth_dsp_pop 
2ab9				endm 
# End of macro FORTH_DSP_POP
2ab9			 
2ab9			;		pop hl 
2ab9			 
2ab9 7e				ld a, (hl) 
2aba			 
2aba 6f				ld l, a 
2abb 26 00			ld h, 0 
2abd cd b8 1f			call forth_push_numhl 
2ac0			 
2ac0				NEXTW 
2ac0 cd a7 fd			call parse_vector 
2ac3 c3 a8 23			jp macro_next 
2ac6				endm 
# End of macro NEXTW
2ac6			.CAT: 
2ac6			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2ac6 20				db WORD_SYS_CORE+OPCODE_CAT             
2ac7 f2 2a			dw .BANG            
2ac9 03				db 2 + 1 
2aca .. 00			db "C@",0              
2acd				endm 
# End of macro CWHEAD
2acd			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2acd				if DEBUG_FORTH_WORDS_KEY 
2acd					DMARK "CAA" 
2acd f5				push af  
2ace 3a e2 2a			ld a, (.dmark)  
2ad1 32 9d fd			ld (debug_mark),a  
2ad4 3a e3 2a			ld a, (.dmark+1)  
2ad7 32 9e fd			ld (debug_mark+1),a  
2ada 3a e4 2a			ld a, (.dmark+2)  
2add 32 9f fd			ld (debug_mark+2),a  
2ae0 18 03			jr .pastdmark  
2ae2 ..			.dmark: db "CAA"  
2ae5 f1			.pastdmark: pop af  
2ae6			endm  
# End of macro DMARK
2ae6					CALLMONITOR 
2ae6 cd aa fd			call debug_vector  
2ae9				endm  
# End of macro CALLMONITOR
2ae9				endif 
2ae9 c3 b3 2a			jp .getbyteat 
2aec				NEXTW 
2aec cd a7 fd			call parse_vector 
2aef c3 a8 23			jp macro_next 
2af2				endm 
# End of macro NEXTW
2af2			.BANG: 
2af2			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2af2 21				db WORD_SYS_CORE+OPCODE_BANG             
2af3 2b 2b			dw .CBANG            
2af5 02				db 1 + 1 
2af6 .. 00			db "!",0              
2af8				endm 
# End of macro CWHEAD
2af8			; | ! ( x w -- ) Store x at address w      | DONE 
2af8				if DEBUG_FORTH_WORDS_KEY 
2af8					DMARK "BNG" 
2af8 f5				push af  
2af9 3a 0d 2b			ld a, (.dmark)  
2afc 32 9d fd			ld (debug_mark),a  
2aff 3a 0e 2b			ld a, (.dmark+1)  
2b02 32 9e fd			ld (debug_mark+1),a  
2b05 3a 0f 2b			ld a, (.dmark+2)  
2b08 32 9f fd			ld (debug_mark+2),a  
2b0b 18 03			jr .pastdmark  
2b0d ..			.dmark: db "BNG"  
2b10 f1			.pastdmark: pop af  
2b11			endm  
# End of macro DMARK
2b11					CALLMONITOR 
2b11 cd aa fd			call debug_vector  
2b14				endm  
# End of macro CALLMONITOR
2b14				endif 
2b14			 
2b14			.storebyteat:		 
2b14				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b14 cd bd 21			call macro_dsp_valuehl 
2b17				endm 
# End of macro FORTH_DSP_VALUEHL
2b17				 
2b17 e5				push hl 
2b18			 
2b18				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b18 cd 75 22			call macro_forth_dsp_pop 
2b1b				endm 
# End of macro FORTH_DSP_POP
2b1b			 
2b1b				; get byte to poke 
2b1b			 
2b1b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b1b cd bd 21			call macro_dsp_valuehl 
2b1e				endm 
# End of macro FORTH_DSP_VALUEHL
2b1e e5				push hl 
2b1f			 
2b1f			 
2b1f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b1f cd 75 22			call macro_forth_dsp_pop 
2b22				endm 
# End of macro FORTH_DSP_POP
2b22			 
2b22			 
2b22 d1				pop de 
2b23 e1				pop hl 
2b24			 
2b24 73				ld (hl),e 
2b25			 
2b25			 
2b25				NEXTW 
2b25 cd a7 fd			call parse_vector 
2b28 c3 a8 23			jp macro_next 
2b2b				endm 
# End of macro NEXTW
2b2b			.CBANG: 
2b2b			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2b2b 22				db WORD_SYS_CORE+OPCODE_CBANG             
2b2c 57 2b			dw .SCALL            
2b2e 03				db 2 + 1 
2b2f .. 00			db "C!",0              
2b32				endm 
# End of macro CWHEAD
2b32			; | C!  ( x w -- ) Store x at address w  | DONE 
2b32				if DEBUG_FORTH_WORDS_KEY 
2b32					DMARK "CBA" 
2b32 f5				push af  
2b33 3a 47 2b			ld a, (.dmark)  
2b36 32 9d fd			ld (debug_mark),a  
2b39 3a 48 2b			ld a, (.dmark+1)  
2b3c 32 9e fd			ld (debug_mark+1),a  
2b3f 3a 49 2b			ld a, (.dmark+2)  
2b42 32 9f fd			ld (debug_mark+2),a  
2b45 18 03			jr .pastdmark  
2b47 ..			.dmark: db "CBA"  
2b4a f1			.pastdmark: pop af  
2b4b			endm  
# End of macro DMARK
2b4b					CALLMONITOR 
2b4b cd aa fd			call debug_vector  
2b4e				endm  
# End of macro CALLMONITOR
2b4e				endif 
2b4e c3 14 2b			jp .storebyteat 
2b51				NEXTW 
2b51 cd a7 fd			call parse_vector 
2b54 c3 a8 23			jp macro_next 
2b57				endm 
# End of macro NEXTW
2b57			.SCALL: 
2b57			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2b57 23				db WORD_SYS_CORE+OPCODE_SCALL             
2b58 8e 2b			dw .DEPTH            
2b5a 05				db 4 + 1 
2b5b .. 00			db "CALL",0              
2b60				endm 
# End of macro CWHEAD
2b60			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2b60				if DEBUG_FORTH_WORDS_KEY 
2b60					DMARK "CLL" 
2b60 f5				push af  
2b61 3a 75 2b			ld a, (.dmark)  
2b64 32 9d fd			ld (debug_mark),a  
2b67 3a 76 2b			ld a, (.dmark+1)  
2b6a 32 9e fd			ld (debug_mark+1),a  
2b6d 3a 77 2b			ld a, (.dmark+2)  
2b70 32 9f fd			ld (debug_mark+2),a  
2b73 18 03			jr .pastdmark  
2b75 ..			.dmark: db "CLL"  
2b78 f1			.pastdmark: pop af  
2b79			endm  
# End of macro DMARK
2b79					CALLMONITOR 
2b79 cd aa fd			call debug_vector  
2b7c				endm  
# End of macro CALLMONITOR
2b7c				endif 
2b7c			 
2b7c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b7c cd bd 21			call macro_dsp_valuehl 
2b7f				endm 
# End of macro FORTH_DSP_VALUEHL
2b7f			 
2b7f			;		push hl 
2b7f			 
2b7f				; destroy value TOS 
2b7f			 
2b7f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b7f cd 75 22			call macro_forth_dsp_pop 
2b82				endm 
# End of macro FORTH_DSP_POP
2b82			 
2b82					 
2b82			;		pop hl 
2b82			 
2b82				; how to do a call with hl???? save SP? 
2b82 cd 4c 23			call forth_call_hl 
2b85			 
2b85			 
2b85				; TODO push value back onto stack for another op etc 
2b85			 
2b85 cd b8 1f			call forth_push_numhl 
2b88				NEXTW 
2b88 cd a7 fd			call parse_vector 
2b8b c3 a8 23			jp macro_next 
2b8e				endm 
# End of macro NEXTW
2b8e			.DEPTH: 
2b8e			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2b8e 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2b8f ce 2b			dw .OVER            
2b91 06				db 5 + 1 
2b92 .. 00			db "DEPTH",0              
2b98				endm 
# End of macro CWHEAD
2b98			; | DEPTH ( -- u ) Push count of stack | DONE 
2b98				; take current TOS and remove from base value div by two to get count 
2b98				if DEBUG_FORTH_WORDS_KEY 
2b98					DMARK "DEP" 
2b98 f5				push af  
2b99 3a ad 2b			ld a, (.dmark)  
2b9c 32 9d fd			ld (debug_mark),a  
2b9f 3a ae 2b			ld a, (.dmark+1)  
2ba2 32 9e fd			ld (debug_mark+1),a  
2ba5 3a af 2b			ld a, (.dmark+2)  
2ba8 32 9f fd			ld (debug_mark+2),a  
2bab 18 03			jr .pastdmark  
2bad ..			.dmark: db "DEP"  
2bb0 f1			.pastdmark: pop af  
2bb1			endm  
# End of macro DMARK
2bb1					CALLMONITOR 
2bb1 cd aa fd			call debug_vector  
2bb4				endm  
# End of macro CALLMONITOR
2bb4				endif 
2bb4			 
2bb4			 
2bb4 2a 20 f9		ld hl, (cli_data_sp) 
2bb7 11 5a f6		ld de, cli_data_stack 
2bba ed 52		sbc hl,de 
2bbc			 
2bbc			; div by size of stack item 
2bbc			 
2bbc 5d			ld e,l 
2bbd 0e 03		ld c, 3 
2bbf cd 6e 0f		call Div8 
2bc2			 
2bc2 6f			ld l,a 
2bc3 26 00		ld h,0 
2bc5			 
2bc5			;srl h 
2bc5			;rr l 
2bc5			 
2bc5 cd b8 1f			call forth_push_numhl 
2bc8				NEXTW 
2bc8 cd a7 fd			call parse_vector 
2bcb c3 a8 23			jp macro_next 
2bce				endm 
# End of macro NEXTW
2bce			.OVER: 
2bce			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2bce 42				db WORD_SYS_CORE+46             
2bcf 1e 2c			dw .PAUSE            
2bd1 05				db 4 + 1 
2bd2 .. 00			db "OVER",0              
2bd7				endm 
# End of macro CWHEAD
2bd7			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2bd7			; | | If the copied item is a string it is properly duplicated allowing for a safe release after use.  
2bd7				if DEBUG_FORTH_WORDS_KEY 
2bd7					DMARK "OVR" 
2bd7 f5				push af  
2bd8 3a ec 2b			ld a, (.dmark)  
2bdb 32 9d fd			ld (debug_mark),a  
2bde 3a ed 2b			ld a, (.dmark+1)  
2be1 32 9e fd			ld (debug_mark+1),a  
2be4 3a ee 2b			ld a, (.dmark+2)  
2be7 32 9f fd			ld (debug_mark+2),a  
2bea 18 03			jr .pastdmark  
2bec ..			.dmark: db "OVR"  
2bef f1			.pastdmark: pop af  
2bf0			endm  
# End of macro DMARK
2bf0					CALLMONITOR 
2bf0 cd aa fd			call debug_vector  
2bf3				endm  
# End of macro CALLMONITOR
2bf3				endif 
2bf3			 
2bf3			; TODO Use os stack swap memory 
2bf3			 
2bf3				; work out what type we are looking at 
2bf3			 
2bf3				FORTH_DSP_PTR 1 
2bf3 2a 20 f9			ld hl,(cli_data_sp) 
2bf6 11 03 00			ld de, 1 * 3 
2bf9 ed 52			sbc hl, de 
2bfb				endm 
# End of macro FORTH_DSP_PTR
2bfb			 
2bfb 7e				ld a, (hl) 
2bfc				 
2bfc f5				push af 
2bfd				; whatever the type lets get the pointer or word 
2bfd 23				inc hl 
2bfe			;; 
2bfe			 
2bfe				; type check now to decide on how to push  
2bfe			 
2bfe cd 2a 23			call loadwordinhl 
2c01 f1				pop af 
2c02 fe 01			cp DS_TYPE_STR 
2c04 28 09			jr z, .ovstr 
2c06			 
2c06				; we have a numeric so load the word and push 
2c06			;	ld e, (hl) 
2c06			;	inc hl 
2c06			;	ld d, (hl) 
2c06			;	ex de, hl 
2c06 cd b8 1f			call forth_push_numhl 
2c09				NEXTW 
2c09 cd a7 fd			call parse_vector 
2c0c c3 a8 23			jp macro_next 
2c0f				endm 
# End of macro NEXTW
2c0f			 
2c0f			.ovstr: 
2c0f				; ok, a string so get the pointer and push as a string 
2c0f			 
2c0f			;	call loadwordinhl 
2c0f cd 26 20			call forth_push_str 
2c12				NEXTW 
2c12 cd a7 fd			call parse_vector 
2c15 c3 a8 23			jp macro_next 
2c18				endm 
# End of macro NEXTW
2c18			 
2c18			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c18			;	push hl    ; n2 
2c18			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c18			; 
2c18			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c18			;	push hl    ; n1 
2c18			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c18			; 
2c18			;	pop de     ; n1 
2c18			;	pop hl     ; n2 
2c18			; 
2c18			;	push de 
2c18			;	push hl 
2c18			;	push de 
2c18			 
2c18				; push back  
2c18			 
2c18			;	pop hl 
2c18			;	call forth_push_numhl 
2c18			;	pop hl 
2c18			;	call forth_push_numhl 
2c18			;	pop hl 
2c18			;	call forth_push_numhl 
2c18				NEXTW 
2c18 cd a7 fd			call parse_vector 
2c1b c3 a8 23			jp macro_next 
2c1e				endm 
# End of macro NEXTW
2c1e			 
2c1e			.PAUSE: 
2c1e			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2c1e 43				db WORD_SYS_CORE+47             
2c1f 56 2c			dw .PAUSES            
2c21 08				db 7 + 1 
2c22 .. 00			db "PAUSEMS",0              
2c2a				endm 
# End of macro CWHEAD
2c2a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2c2a				if DEBUG_FORTH_WORDS_KEY 
2c2a					DMARK "PMS" 
2c2a f5				push af  
2c2b 3a 3f 2c			ld a, (.dmark)  
2c2e 32 9d fd			ld (debug_mark),a  
2c31 3a 40 2c			ld a, (.dmark+1)  
2c34 32 9e fd			ld (debug_mark+1),a  
2c37 3a 41 2c			ld a, (.dmark+2)  
2c3a 32 9f fd			ld (debug_mark+2),a  
2c3d 18 03			jr .pastdmark  
2c3f ..			.dmark: db "PMS"  
2c42 f1			.pastdmark: pop af  
2c43			endm  
# End of macro DMARK
2c43					CALLMONITOR 
2c43 cd aa fd			call debug_vector  
2c46				endm  
# End of macro CALLMONITOR
2c46				endif 
2c46				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c46 cd bd 21			call macro_dsp_valuehl 
2c49				endm 
# End of macro FORTH_DSP_VALUEHL
2c49			;		push hl    ; n2 
2c49				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c49 cd 75 22			call macro_forth_dsp_pop 
2c4c				endm 
# End of macro FORTH_DSP_POP
2c4c			;		pop hl 
2c4c			 
2c4c 7d				ld a, l 
2c4d cd d2 0c			call aDelayInMS 
2c50			       NEXTW 
2c50 cd a7 fd			call parse_vector 
2c53 c3 a8 23			jp macro_next 
2c56				endm 
# End of macro NEXTW
2c56			.PAUSES:  
2c56			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2c56 44				db WORD_SYS_CORE+48             
2c57 c8 2c			dw .ROT            
2c59 06				db 5 + 1 
2c5a .. 00			db "PAUSE",0              
2c60				endm 
# End of macro CWHEAD
2c60			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2c60				if DEBUG_FORTH_WORDS_KEY 
2c60					DMARK "PAU" 
2c60 f5				push af  
2c61 3a 75 2c			ld a, (.dmark)  
2c64 32 9d fd			ld (debug_mark),a  
2c67 3a 76 2c			ld a, (.dmark+1)  
2c6a 32 9e fd			ld (debug_mark+1),a  
2c6d 3a 77 2c			ld a, (.dmark+2)  
2c70 32 9f fd			ld (debug_mark+2),a  
2c73 18 03			jr .pastdmark  
2c75 ..			.dmark: db "PAU"  
2c78 f1			.pastdmark: pop af  
2c79			endm  
# End of macro DMARK
2c79					CALLMONITOR 
2c79 cd aa fd			call debug_vector  
2c7c				endm  
# End of macro CALLMONITOR
2c7c				endif 
2c7c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c7c cd bd 21			call macro_dsp_valuehl 
2c7f				endm 
# End of macro FORTH_DSP_VALUEHL
2c7f			;		push hl    ; n2 
2c7f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c7f cd 75 22			call macro_forth_dsp_pop 
2c82				endm 
# End of macro FORTH_DSP_POP
2c82			;		pop hl 
2c82 45				ld b, l 
2c83				if DEBUG_FORTH_WORDS 
2c83					DMARK "PAU" 
2c83 f5				push af  
2c84 3a 98 2c			ld a, (.dmark)  
2c87 32 9d fd			ld (debug_mark),a  
2c8a 3a 99 2c			ld a, (.dmark+1)  
2c8d 32 9e fd			ld (debug_mark+1),a  
2c90 3a 9a 2c			ld a, (.dmark+2)  
2c93 32 9f fd			ld (debug_mark+2),a  
2c96 18 03			jr .pastdmark  
2c98 ..			.dmark: db "PAU"  
2c9b f1			.pastdmark: pop af  
2c9c			endm  
# End of macro DMARK
2c9c					CALLMONITOR 
2c9c cd aa fd			call debug_vector  
2c9f				endm  
# End of macro CALLMONITOR
2c9f				endif 
2c9f c5			.pauses1:	push bc 
2ca0 cd ed 0c			call delay1s 
2ca3 c1				pop bc 
2ca4				if DEBUG_FORTH_WORDS 
2ca4					DMARK "PA1" 
2ca4 f5				push af  
2ca5 3a b9 2c			ld a, (.dmark)  
2ca8 32 9d fd			ld (debug_mark),a  
2cab 3a ba 2c			ld a, (.dmark+1)  
2cae 32 9e fd			ld (debug_mark+1),a  
2cb1 3a bb 2c			ld a, (.dmark+2)  
2cb4 32 9f fd			ld (debug_mark+2),a  
2cb7 18 03			jr .pastdmark  
2cb9 ..			.dmark: db "PA1"  
2cbc f1			.pastdmark: pop af  
2cbd			endm  
# End of macro DMARK
2cbd					CALLMONITOR 
2cbd cd aa fd			call debug_vector  
2cc0				endm  
# End of macro CALLMONITOR
2cc0				endif 
2cc0 10 dd			djnz .pauses1 
2cc2			 
2cc2			       NEXTW 
2cc2 cd a7 fd			call parse_vector 
2cc5 c3 a8 23			jp macro_next 
2cc8				endm 
# End of macro NEXTW
2cc8			.ROT: 
2cc8			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2cc8 45				db WORD_SYS_CORE+49             
2cc9 34 2d			dw .UWORDS            
2ccb 04				db 3 + 1 
2ccc .. 00			db "ROT",0              
2cd0				endm 
# End of macro CWHEAD
2cd0			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2cd0				if DEBUG_FORTH_WORDS_KEY 
2cd0					DMARK "ROT" 
2cd0 f5				push af  
2cd1 3a e5 2c			ld a, (.dmark)  
2cd4 32 9d fd			ld (debug_mark),a  
2cd7 3a e6 2c			ld a, (.dmark+1)  
2cda 32 9e fd			ld (debug_mark+1),a  
2cdd 3a e7 2c			ld a, (.dmark+2)  
2ce0 32 9f fd			ld (debug_mark+2),a  
2ce3 18 03			jr .pastdmark  
2ce5 ..			.dmark: db "ROT"  
2ce8 f1			.pastdmark: pop af  
2ce9			endm  
# End of macro DMARK
2ce9					CALLMONITOR 
2ce9 cd aa fd			call debug_vector  
2cec				endm  
# End of macro CALLMONITOR
2cec				endif 
2cec			 
2cec			; DONE Use os stack swap memory 
2cec			 
2cec				FORTH_DSP_PTR 0     ; u3 
2cec 2a 20 f9			ld hl,(cli_data_sp) 
2cef 11 00 00			ld de, 0 * 3 
2cf2 ed 52			sbc hl, de 
2cf4				endm 
# End of macro FORTH_DSP_PTR
2cf4 cd f4 22			call hltostack1     
2cf7			  
2cf7				FORTH_DSP_PTR 1     ; u2 
2cf7 2a 20 f9			ld hl,(cli_data_sp) 
2cfa 11 03 00			ld de, 1 * 3 
2cfd ed 52			sbc hl, de 
2cff				endm 
# End of macro FORTH_DSP_PTR
2cff cd fa 22			call hltostack2      
2d02			 
2d02				FORTH_DSP_PTR 2     ; u1 
2d02 2a 20 f9			ld hl,(cli_data_sp) 
2d05 11 06 00			ld de, 2 * 3 
2d08 ed 52			sbc hl, de 
2d0a				endm 
# End of macro FORTH_DSP_PTR
2d0a cd 00 23			call hltostack3 
2d0d			 
2d0d			 
2d0d				FORTH_DSP_PTR 0     ;  
2d0d 2a 20 f9			ld hl,(cli_data_sp) 
2d10 11 00 00			ld de, 0 * 3 
2d13 ed 52			sbc hl, de 
2d15				endm 
# End of macro FORTH_DSP_PTR
2d15 cd 18 23			call hlfromstack3 
2d18			 
2d18				FORTH_DSP_PTR 1     ; TOS 
2d18 2a 20 f9			ld hl,(cli_data_sp) 
2d1b 11 03 00			ld de, 1 * 3 
2d1e ed 52			sbc hl, de 
2d20				endm 
# End of macro FORTH_DSP_PTR
2d20 cd 0c 23			call hlfromstack1 
2d23			 
2d23				FORTH_DSP_PTR 2     ; TOS 
2d23 2a 20 f9			ld hl,(cli_data_sp) 
2d26 11 06 00			ld de, 2 * 3 
2d29 ed 52			sbc hl, de 
2d2b				endm 
# End of macro FORTH_DSP_PTR
2d2b cd 12 23			call hlfromstack2 
2d2e			 
2d2e			 
2d2e			;	FORTH_DSP_VALUEHL 
2d2e			;	push hl    ; u3  
2d2e			; 
2d2e			;	FORTH_DSP_POP 
2d2e			; 
2d2e			;	FORTH_DSP_VALUEHL 
2d2e			;	push hl     ; u2 
2d2e			; 
2d2e			;	FORTH_DSP_POP 
2d2e			; 
2d2e			;	FORTH_DSP_VALUEHL 
2d2e			;	push hl     ; u1 
2d2e			; 
2d2e			;	FORTH_DSP_POP 
2d2e			; 
2d2e			;	pop bc      ; u1 
2d2e			;	pop hl      ; u2 
2d2e			;	pop de      ; u3 
2d2e			; 
2d2e			; 
2d2e			;	push bc 
2d2e			;	push de 
2d2e			;	push hl 
2d2e			; 
2d2e			; 
2d2e			;	pop hl 
2d2e			;	call forth_push_numhl 
2d2e			; 
2d2e			;	pop hl 
2d2e			;	call forth_push_numhl 
2d2e			; 
2d2e			;	pop hl 
2d2e			;	call forth_push_numhl 
2d2e				 
2d2e			 
2d2e			 
2d2e			 
2d2e			 
2d2e			 
2d2e			       NEXTW 
2d2e cd a7 fd			call parse_vector 
2d31 c3 a8 23			jp macro_next 
2d34				endm 
# End of macro NEXTW
2d34			 
2d34			.UWORDS: 
2d34			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2d34 50				db WORD_SYS_CORE+60             
2d35 f9 2d			dw .BP            
2d37 07				db 6 + 1 
2d38 .. 00			db "UWORDS",0              
2d3f				endm 
# End of macro CWHEAD
2d3f			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2d3f			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2d3f			; | | Following the count are the individual words. 
2d3f			; | | 
2d3f			; | | e.g. UWORDS 
2d3f			; | | BOX DIRLIST 2 
2d3f			; | |  
2d3f			; | | Can be used to save the words to storage via: 
2d3f			; | | UWORDS $01 DO $01 APPEND LOOP 
2d3f			if DEBUG_FORTH_WORDS_KEY 
2d3f				DMARK "UWR" 
2d3f f5				push af  
2d40 3a 54 2d			ld a, (.dmark)  
2d43 32 9d fd			ld (debug_mark),a  
2d46 3a 55 2d			ld a, (.dmark+1)  
2d49 32 9e fd			ld (debug_mark+1),a  
2d4c 3a 56 2d			ld a, (.dmark+2)  
2d4f 32 9f fd			ld (debug_mark+2),a  
2d52 18 03			jr .pastdmark  
2d54 ..			.dmark: db "UWR"  
2d57 f1			.pastdmark: pop af  
2d58			endm  
# End of macro DMARK
2d58				CALLMONITOR 
2d58 cd aa fd			call debug_vector  
2d5b				endm  
# End of macro CALLMONITOR
2d5b			endif 
2d5b 21 00 80			ld hl, baseram 
2d5e				;ld hl, baseusermem 
2d5e 01 00 00			ld bc, 0    ; start a counter 
2d61			 
2d61			; skip dict stub 
2d61			 
2d61 cd e5 24			call forth_tok_next 
2d64			 
2d64			 
2d64			; while we have words to look for 
2d64			 
2d64 7e			.douscan:	ld a, (hl)      
2d65			if DEBUG_FORTH_WORDS 
2d65				DMARK "UWs" 
2d65 f5				push af  
2d66 3a 7a 2d			ld a, (.dmark)  
2d69 32 9d fd			ld (debug_mark),a  
2d6c 3a 7b 2d			ld a, (.dmark+1)  
2d6f 32 9e fd			ld (debug_mark+1),a  
2d72 3a 7c 2d			ld a, (.dmark+2)  
2d75 32 9f fd			ld (debug_mark+2),a  
2d78 18 03			jr .pastdmark  
2d7a ..			.dmark: db "UWs"  
2d7d f1			.pastdmark: pop af  
2d7e			endm  
# End of macro DMARK
2d7e				CALLMONITOR 
2d7e cd aa fd			call debug_vector  
2d81				endm  
# End of macro CALLMONITOR
2d81			endif 
2d81 fe 00			cp WORD_SYS_END 
2d83 28 4d			jr z, .udone 
2d85 fe 01			cp WORD_SYS_UWORD 
2d87 20 44			jr nz, .nuword 
2d89			 
2d89			if DEBUG_FORTH_WORDS 
2d89				DMARK "UWu" 
2d89 f5				push af  
2d8a 3a 9e 2d			ld a, (.dmark)  
2d8d 32 9d fd			ld (debug_mark),a  
2d90 3a 9f 2d			ld a, (.dmark+1)  
2d93 32 9e fd			ld (debug_mark+1),a  
2d96 3a a0 2d			ld a, (.dmark+2)  
2d99 32 9f fd			ld (debug_mark+2),a  
2d9c 18 03			jr .pastdmark  
2d9e ..			.dmark: db "UWu"  
2da1 f1			.pastdmark: pop af  
2da2			endm  
# End of macro DMARK
2da2				CALLMONITOR 
2da2 cd aa fd			call debug_vector  
2da5				endm  
# End of macro CALLMONITOR
2da5			endif 
2da5				; we have a uword so push its name to the stack 
2da5			 
2da5 e5				push hl  ; save so we can move to next dict block 
2da6			 
2da6				; skip opcode 
2da6 23				inc hl  
2da7				; skip next ptr 
2da7 23				inc hl  
2da8 23				inc hl 
2da9				; skip len 
2da9 23				inc hl 
2daa			if DEBUG_FORTH_WORDS 
2daa				DMARK "UWt" 
2daa f5				push af  
2dab 3a bf 2d			ld a, (.dmark)  
2dae 32 9d fd			ld (debug_mark),a  
2db1 3a c0 2d			ld a, (.dmark+1)  
2db4 32 9e fd			ld (debug_mark+1),a  
2db7 3a c1 2d			ld a, (.dmark+2)  
2dba 32 9f fd			ld (debug_mark+2),a  
2dbd 18 03			jr .pastdmark  
2dbf ..			.dmark: db "UWt"  
2dc2 f1			.pastdmark: pop af  
2dc3			endm  
# End of macro DMARK
2dc3				CALLMONITOR 
2dc3 cd aa fd			call debug_vector  
2dc6				endm  
# End of macro CALLMONITOR
2dc6			endif 
2dc6 03				inc bc 
2dc7			 
2dc7 c5				push bc 
2dc8 cd 26 20			call forth_push_str 
2dcb c1				pop bc 
2dcc			 
2dcc e1				pop hl 	 
2dcd			 
2dcd cd e5 24		.nuword:	call forth_tok_next 
2dd0 18 92			jr .douscan  
2dd2			 
2dd2			.udone:		 ; push count of uwords found 
2dd2 c5				push bc 
2dd3 e1				pop hl 
2dd4			 
2dd4			if DEBUG_FORTH_WORDS 
2dd4				DMARK "UWc" 
2dd4 f5				push af  
2dd5 3a e9 2d			ld a, (.dmark)  
2dd8 32 9d fd			ld (debug_mark),a  
2ddb 3a ea 2d			ld a, (.dmark+1)  
2dde 32 9e fd			ld (debug_mark+1),a  
2de1 3a eb 2d			ld a, (.dmark+2)  
2de4 32 9f fd			ld (debug_mark+2),a  
2de7 18 03			jr .pastdmark  
2de9 ..			.dmark: db "UWc"  
2dec f1			.pastdmark: pop af  
2ded			endm  
# End of macro DMARK
2ded				CALLMONITOR 
2ded cd aa fd			call debug_vector  
2df0				endm  
# End of macro CALLMONITOR
2df0			endif 
2df0 cd b8 1f			call forth_push_numhl 
2df3			 
2df3			 
2df3			       NEXTW 
2df3 cd a7 fd			call parse_vector 
2df6 c3 a8 23			jp macro_next 
2df9				endm 
# End of macro NEXTW
2df9			 
2df9			.BP: 
2df9			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2df9 54				db WORD_SYS_CORE+64             
2dfa 39 2e			dw .MONITOR            
2dfc 03				db 2 + 1 
2dfd .. 00			db "BP",0              
2e00				endm 
# End of macro CWHEAD
2e00			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2e00			; | | $00 Will enable the break points within specific code paths 
2e00			; | | $01 Will disable break points 
2e00			; | |  
2e00			; | | By default break points are off. Either the above can be used to enable them 
2e00			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2e00			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2e00			; | | can disable break points. Exiting will then continue boot process. 
2e00				; get byte count 
2e00				if DEBUG_FORTH_WORDS_KEY 
2e00					DMARK "BP." 
2e00 f5				push af  
2e01 3a 15 2e			ld a, (.dmark)  
2e04 32 9d fd			ld (debug_mark),a  
2e07 3a 16 2e			ld a, (.dmark+1)  
2e0a 32 9e fd			ld (debug_mark+1),a  
2e0d 3a 17 2e			ld a, (.dmark+2)  
2e10 32 9f fd			ld (debug_mark+2),a  
2e13 18 03			jr .pastdmark  
2e15 ..			.dmark: db "BP."  
2e18 f1			.pastdmark: pop af  
2e19			endm  
# End of macro DMARK
2e19					CALLMONITOR 
2e19 cd aa fd			call debug_vector  
2e1c				endm  
# End of macro CALLMONITOR
2e1c				endif 
2e1c			 
2e1c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e1c cd bd 21			call macro_dsp_valuehl 
2e1f				endm 
# End of macro FORTH_DSP_VALUEHL
2e1f			 
2e1f			;		push hl 
2e1f			 
2e1f				; destroy value TOS 
2e1f			 
2e1f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e1f cd 75 22			call macro_forth_dsp_pop 
2e22				endm 
# End of macro FORTH_DSP_POP
2e22			 
2e22			;		pop hl 
2e22			 
2e22 3e 00			ld a,0 
2e24 bd				cp l 
2e25 28 09			jr z, .bpset 
2e27			;		ld a, '*' 
2e27 cd cf 18			call bp_off 
2e2a				NEXTW 
2e2a cd a7 fd			call parse_vector 
2e2d c3 a8 23			jp macro_next 
2e30				endm 
# End of macro NEXTW
2e30			 
2e30			.bpset:	 
2e30				;	ld (os_view_disable), a 
2e30 cd c3 18			call bp_on 
2e33			 
2e33			 
2e33				NEXTW 
2e33 cd a7 fd			call parse_vector 
2e36 c3 a8 23			jp macro_next 
2e39				endm 
# End of macro NEXTW
2e39			 
2e39			 
2e39			.MONITOR: 
2e39			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2e39 55				db WORD_SYS_CORE+65             
2e3a 6d 2e			dw .MALLOC            
2e3c 08				db 7 + 1 
2e3d .. 00			db "MONITOR",0              
2e45				endm 
# End of macro CWHEAD
2e45			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2e45			; | | At start the current various registers will be displayed with contents. 
2e45			; | | Top right corner will show the most recent debug marker seen. 
2e45			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2e45			; | | and the return stack pointer (RSP). 
2e45			; | | Pressing: 
2e45			; | |    1 - Initial screen 
2e45			; | |    2 - Display a data dump of HL 
2e45			; | |    3 - Display a data dump of DE 
2e45			; | |    4 - Display a data dump of BC 
2e45			; | |    5 - Display a data dump of HL 
2e45			; | |    6 - Display a data dump of DSP 
2e45			; | |    7 - Display a data dump of RSP 
2e45			; | |    8 - Display a data dump of what is at DSP 
2e45			; | |    9 - Display a data dump of what is at RSP 
2e45			; | |    0 - Exit monitor and continue running. This will also enable break points 
2e45			; | |    * - Disable break points 
2e45			; | |    # - Enter traditional monitor mode 
2e45			; | | 
2e45			; | | Monitor Mode 
2e45			; | | ------------ 
2e45			; | | A prompt of '>' will be shown for various commands: 
2e45			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2e45			; | |    C - Continue display a data dump from the last set address 
2e45			; | |    M xxxx - Set start of memory edit at address xx 
2e45			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2e45			; | |    G xxxx - Exec code at specific address 
2e45			; | |    Q - Return to previous 
2e45				if DEBUG_FORTH_WORDS_KEY 
2e45					DMARK "MON" 
2e45 f5				push af  
2e46 3a 5a 2e			ld a, (.dmark)  
2e49 32 9d fd			ld (debug_mark),a  
2e4c 3a 5b 2e			ld a, (.dmark+1)  
2e4f 32 9e fd			ld (debug_mark+1),a  
2e52 3a 5c 2e			ld a, (.dmark+2)  
2e55 32 9f fd			ld (debug_mark+2),a  
2e58 18 03			jr .pastdmark  
2e5a ..			.dmark: db "MON"  
2e5d f1			.pastdmark: pop af  
2e5e			endm  
# End of macro DMARK
2e5e					CALLMONITOR 
2e5e cd aa fd			call debug_vector  
2e61				endm  
# End of macro CALLMONITOR
2e61				endif 
2e61			;		ld a, 0 
2e61			;		ld (os_view_disable), a 
2e61 cd c3 18			call bp_on 
2e64			 
2e64				CALLMONITOR 
2e64 cd aa fd			call debug_vector  
2e67				endm  
# End of macro CALLMONITOR
2e67			 
2e67			;	call monitor 
2e67			 
2e67				NEXTW 
2e67 cd a7 fd			call parse_vector 
2e6a c3 a8 23			jp macro_next 
2e6d				endm 
# End of macro NEXTW
2e6d			 
2e6d			 
2e6d			.MALLOC: 
2e6d			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2e6d 56				db WORD_SYS_CORE+66             
2e6e 96 2e			dw .MALLOC2            
2e70 06				db 5 + 1 
2e71 .. 00			db "ALLOT",0              
2e77				endm 
# End of macro CWHEAD
2e77			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2e77				if DEBUG_FORTH_WORDS_KEY 
2e77					DMARK "ALL" 
2e77 f5				push af  
2e78 3a 8c 2e			ld a, (.dmark)  
2e7b 32 9d fd			ld (debug_mark),a  
2e7e 3a 8d 2e			ld a, (.dmark+1)  
2e81 32 9e fd			ld (debug_mark+1),a  
2e84 3a 8e 2e			ld a, (.dmark+2)  
2e87 32 9f fd			ld (debug_mark+2),a  
2e8a 18 03			jr .pastdmark  
2e8c ..			.dmark: db "ALL"  
2e8f f1			.pastdmark: pop af  
2e90			endm  
# End of macro DMARK
2e90					CALLMONITOR 
2e90 cd aa fd			call debug_vector  
2e93				endm  
# End of macro CALLMONITOR
2e93				endif 
2e93 c3 bd 2e			jp .mallocc 
2e96			.MALLOC2: 
2e96			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2e96 56				db WORD_SYS_CORE+66             
2e97 d7 2e			dw .FREE            
2e99 07				db 6 + 1 
2e9a .. 00			db "MALLOC",0              
2ea1				endm 
# End of macro CWHEAD
2ea1			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ea1				; get byte count 
2ea1				if DEBUG_FORTH_WORDS_KEY 
2ea1					DMARK "MAL" 
2ea1 f5				push af  
2ea2 3a b6 2e			ld a, (.dmark)  
2ea5 32 9d fd			ld (debug_mark),a  
2ea8 3a b7 2e			ld a, (.dmark+1)  
2eab 32 9e fd			ld (debug_mark+1),a  
2eae 3a b8 2e			ld a, (.dmark+2)  
2eb1 32 9f fd			ld (debug_mark+2),a  
2eb4 18 03			jr .pastdmark  
2eb6 ..			.dmark: db "MAL"  
2eb9 f1			.pastdmark: pop af  
2eba			endm  
# End of macro DMARK
2eba					CALLMONITOR 
2eba cd aa fd			call debug_vector  
2ebd				endm  
# End of macro CALLMONITOR
2ebd				endif 
2ebd			.mallocc: 
2ebd				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ebd cd bd 21			call macro_dsp_valuehl 
2ec0				endm 
# End of macro FORTH_DSP_VALUEHL
2ec0			 
2ec0			;		push hl 
2ec0			 
2ec0				; destroy value TOS 
2ec0			 
2ec0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ec0 cd 75 22			call macro_forth_dsp_pop 
2ec3				endm 
# End of macro FORTH_DSP_POP
2ec3			 
2ec3			;		pop hl 
2ec3 cd b9 13			call malloc 
2ec6			if DEBUG_FORTH_MALLOC_GUARD 
2ec6 f5				push af 
2ec7 cd 07 10			call ishlzero 
2eca			;		ld a, l 
2eca			;		add h 
2eca			;		cp 0 
2eca f1				pop af 
2ecb				 
2ecb cc dd 64			call z,malloc_error 
2ece			endif 
2ece			 
2ece cd b8 1f			call forth_push_numhl 
2ed1				NEXTW 
2ed1 cd a7 fd			call parse_vector 
2ed4 c3 a8 23			jp macro_next 
2ed7				endm 
# End of macro NEXTW
2ed7			 
2ed7			.FREE: 
2ed7			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
2ed7 57				db WORD_SYS_CORE+67             
2ed8 0b 2f			dw .UPTR            
2eda 05				db 4 + 1 
2edb .. 00			db "FREE",0              
2ee0				endm 
# End of macro CWHEAD
2ee0			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2ee0				if DEBUG_FORTH_WORDS_KEY 
2ee0					DMARK "FRE" 
2ee0 f5				push af  
2ee1 3a f5 2e			ld a, (.dmark)  
2ee4 32 9d fd			ld (debug_mark),a  
2ee7 3a f6 2e			ld a, (.dmark+1)  
2eea 32 9e fd			ld (debug_mark+1),a  
2eed 3a f7 2e			ld a, (.dmark+2)  
2ef0 32 9f fd			ld (debug_mark+2),a  
2ef3 18 03			jr .pastdmark  
2ef5 ..			.dmark: db "FRE"  
2ef8 f1			.pastdmark: pop af  
2ef9			endm  
# End of macro DMARK
2ef9					CALLMONITOR 
2ef9 cd aa fd			call debug_vector  
2efc				endm  
# End of macro CALLMONITOR
2efc				endif 
2efc				; get address 
2efc			 
2efc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2efc cd bd 21			call macro_dsp_valuehl 
2eff				endm 
# End of macro FORTH_DSP_VALUEHL
2eff			 
2eff			;		push hl 
2eff			 
2eff				; destroy value TOS 
2eff			 
2eff				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2eff cd 75 22			call macro_forth_dsp_pop 
2f02				endm 
# End of macro FORTH_DSP_POP
2f02			 
2f02			;		pop hl 
2f02			if FORTH_ENABLE_MALLOCFREE 
2f02 cd 83 14			call free 
2f05			endif 
2f05				NEXTW 
2f05 cd a7 fd			call parse_vector 
2f08 c3 a8 23			jp macro_next 
2f0b				endm 
# End of macro NEXTW
2f0b			.UPTR: 
2f0b			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2f0b 57				db WORD_SYS_CORE+67             
2f0c 11 30			dw .LIST            
2f0e 05				db 4 + 1 
2f0f .. 00			db "UPTR",0              
2f14				endm 
# End of macro CWHEAD
2f14			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2f14				if DEBUG_FORTH_WORDS_KEY 
2f14					DMARK "UPT" 
2f14 f5				push af  
2f15 3a 29 2f			ld a, (.dmark)  
2f18 32 9d fd			ld (debug_mark),a  
2f1b 3a 2a 2f			ld a, (.dmark+1)  
2f1e 32 9e fd			ld (debug_mark+1),a  
2f21 3a 2b 2f			ld a, (.dmark+2)  
2f24 32 9f fd			ld (debug_mark+2),a  
2f27 18 03			jr .pastdmark  
2f29 ..			.dmark: db "UPT"  
2f2c f1			.pastdmark: pop af  
2f2d			endm  
# End of macro DMARK
2f2d					CALLMONITOR 
2f2d cd aa fd			call debug_vector  
2f30				endm  
# End of macro CALLMONITOR
2f30				endif 
2f30				FORTH_DSP_VALUEHL 
2f30 cd bd 21			call macro_dsp_valuehl 
2f33				endm 
# End of macro FORTH_DSP_VALUEHL
2f33			 
2f33 e5				push hl 
2f34				FORTH_DSP_POP 
2f34 cd 75 22			call macro_forth_dsp_pop 
2f37				endm 
# End of macro FORTH_DSP_POP
2f37 c1				pop bc 
2f38			 
2f38			 
2f38				; Get ptr to the word we need to look up 
2f38			 
2f38			;		FORTH_DSP_VALUEHL 
2f38				;v5 FORTH_DSP_VALUE 
2f38			; TODO type check 
2f38			;		inc hl    ; Skip type check  
2f38			;		push hl 
2f38			;		ex de, hl    ; put into DE 
2f38			 
2f38			 
2f38 21 00 80			ld hl, baseram 
2f3b				;ld hl, baseusermem 
2f3b			 
2f3b e5			push hl   ; sacreifical push 
2f3c			 
2f3c			.uldouscanm: 
2f3c e1			pop hl 
2f3d			.uldouscan: 
2f3d			if DEBUG_FORTH_WORDS 
2f3d				DMARK "LSs" 
2f3d f5				push af  
2f3e 3a 52 2f			ld a, (.dmark)  
2f41 32 9d fd			ld (debug_mark),a  
2f44 3a 53 2f			ld a, (.dmark+1)  
2f47 32 9e fd			ld (debug_mark+1),a  
2f4a 3a 54 2f			ld a, (.dmark+2)  
2f4d 32 9f fd			ld (debug_mark+2),a  
2f50 18 03			jr .pastdmark  
2f52 ..			.dmark: db "LSs"  
2f55 f1			.pastdmark: pop af  
2f56			endm  
# End of macro DMARK
2f56				CALLMONITOR 
2f56 cd aa fd			call debug_vector  
2f59				endm  
# End of macro CALLMONITOR
2f59			endif 
2f59			; skip dict stub 
2f59 cd e5 24			call forth_tok_next 
2f5c			 
2f5c			 
2f5c			; while we have words to look for 
2f5c			 
2f5c 7e			ld a, (hl)      
2f5d			if DEBUG_FORTH_WORDS 
2f5d				DMARK "LSk" 
2f5d f5				push af  
2f5e 3a 72 2f			ld a, (.dmark)  
2f61 32 9d fd			ld (debug_mark),a  
2f64 3a 73 2f			ld a, (.dmark+1)  
2f67 32 9e fd			ld (debug_mark+1),a  
2f6a 3a 74 2f			ld a, (.dmark+2)  
2f6d 32 9f fd			ld (debug_mark+2),a  
2f70 18 03			jr .pastdmark  
2f72 ..			.dmark: db "LSk"  
2f75 f1			.pastdmark: pop af  
2f76			endm  
# End of macro DMARK
2f76				CALLMONITOR 
2f76 cd aa fd			call debug_vector  
2f79				endm  
# End of macro CALLMONITOR
2f79			endif 
2f79				;cp WORD_SYS_END 
2f79				;jp z, .lunotfound 
2f79			 
2f79					; if we hit non uwords then gone too far 
2f79 fe 01				cp WORD_SYS_UWORD 
2f7b c2 08 30				jp nz, .ulunotfound 
2f7e			 
2f7e				if DEBUG_FORTH_WORDS 
2f7e					DMARK "LSu" 
2f7e f5				push af  
2f7f 3a 93 2f			ld a, (.dmark)  
2f82 32 9d fd			ld (debug_mark),a  
2f85 3a 94 2f			ld a, (.dmark+1)  
2f88 32 9e fd			ld (debug_mark+1),a  
2f8b 3a 95 2f			ld a, (.dmark+2)  
2f8e 32 9f fd			ld (debug_mark+2),a  
2f91 18 03			jr .pastdmark  
2f93 ..			.dmark: db "LSu"  
2f96 f1			.pastdmark: pop af  
2f97			endm  
# End of macro DMARK
2f97					CALLMONITOR 
2f97 cd aa fd			call debug_vector  
2f9a				endm  
# End of macro CALLMONITOR
2f9a				endif 
2f9a			 
2f9a					; found a uword but is it the one we want... 
2f9a			 
2f9a c5					push bc     ; uword to find is on bc 
2f9b d1					pop de 
2f9c			 
2f9c e5					push hl  ; to save the ptr 
2f9d			 
2f9d					; skip opcode 
2f9d 23					inc hl  
2f9e					; skip next ptr 
2f9e 23					inc hl  
2f9f 23					inc hl 
2fa0					; skip len 
2fa0 23					inc hl 
2fa1			 
2fa1				if DEBUG_FORTH_WORDS 
2fa1					DMARK "LSc" 
2fa1 f5				push af  
2fa2 3a b6 2f			ld a, (.dmark)  
2fa5 32 9d fd			ld (debug_mark),a  
2fa8 3a b7 2f			ld a, (.dmark+1)  
2fab 32 9e fd			ld (debug_mark+1),a  
2fae 3a b8 2f			ld a, (.dmark+2)  
2fb1 32 9f fd			ld (debug_mark+2),a  
2fb4 18 03			jr .pastdmark  
2fb6 ..			.dmark: db "LSc"  
2fb9 f1			.pastdmark: pop af  
2fba			endm  
# End of macro DMARK
2fba					CALLMONITOR 
2fba cd aa fd			call debug_vector  
2fbd				endm  
# End of macro CALLMONITOR
2fbd				endif 
2fbd			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2fbd			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2fbd			; Nope that has gone the other way. It needs to be exact not on first zero 
2fbd			;		call strcmp 
2fbd c5					push bc 
2fbe cd 89 13				call StrictStrCmp 
2fc1 c1					pop bc 
2fc2 c2 3c 2f				jp nz, .uldouscanm 
2fc5				 
2fc5			 
2fc5			 
2fc5					; we have a uword so push its name to the stack 
2fc5			 
2fc5			;	   	push hl  ; save so we can move to next dict block 
2fc5 e1			pop hl 
2fc6			 
2fc6				if DEBUG_FORTH_WORDS 
2fc6					DMARK "LSm" 
2fc6 f5				push af  
2fc7 3a db 2f			ld a, (.dmark)  
2fca 32 9d fd			ld (debug_mark),a  
2fcd 3a dc 2f			ld a, (.dmark+1)  
2fd0 32 9e fd			ld (debug_mark+1),a  
2fd3 3a dd 2f			ld a, (.dmark+2)  
2fd6 32 9f fd			ld (debug_mark+2),a  
2fd9 18 03			jr .pastdmark  
2fdb ..			.dmark: db "LSm"  
2fde f1			.pastdmark: pop af  
2fdf			endm  
# End of macro DMARK
2fdf					CALLMONITOR 
2fdf cd aa fd			call debug_vector  
2fe2				endm  
# End of macro CALLMONITOR
2fe2				endif 
2fe2			 
2fe2					; skip opcode 
2fe2 23					inc hl  
2fe3					; skip next ptr 
2fe3 23					inc hl  
2fe4 23					inc hl 
2fe5					; skip len 
2fe5 7e					ld a, (hl)   ; save length to add 
2fe6				if DEBUG_FORTH_WORDS 
2fe6					DMARK "LS2" 
2fe6 f5				push af  
2fe7 3a fb 2f			ld a, (.dmark)  
2fea 32 9d fd			ld (debug_mark),a  
2fed 3a fc 2f			ld a, (.dmark+1)  
2ff0 32 9e fd			ld (debug_mark+1),a  
2ff3 3a fd 2f			ld a, (.dmark+2)  
2ff6 32 9f fd			ld (debug_mark+2),a  
2ff9 18 03			jr .pastdmark  
2ffb ..			.dmark: db "LS2"  
2ffe f1			.pastdmark: pop af  
2fff			endm  
# End of macro DMARK
2fff					CALLMONITOR 
2fff cd aa fd			call debug_vector  
3002				endm  
# End of macro CALLMONITOR
3002				endif 
3002			 
3002				; skip zero term and other uword defs to position right at the exec code 
3002 06 04			ld b, 4 
3004 80				add a,b 
3005			 
3005 cd de 0f			call addatohl 
3008					; save this location 
3008				 
3008			.ulunotfound: 
3008 cd b8 1f			call forth_push_numhl 
300b						 
300b				NEXTW 
300b cd a7 fd			call parse_vector 
300e c3 a8 23			jp macro_next 
3011				endm 
# End of macro NEXTW
3011			.LIST: 
3011			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
3011 5c				db WORD_SYS_CORE+72             
3012 16 32			dw .FORGET            
3014 05				db 4 + 1 
3015 .. 00			db "LIST",0              
301a				endm 
# End of macro CWHEAD
301a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
301a			; | | The quoted word must be in upper case. 
301a			if DEBUG_FORTH_WORDS_KEY 
301a				DMARK "LST" 
301a f5				push af  
301b 3a 2f 30			ld a, (.dmark)  
301e 32 9d fd			ld (debug_mark),a  
3021 3a 30 30			ld a, (.dmark+1)  
3024 32 9e fd			ld (debug_mark+1),a  
3027 3a 31 30			ld a, (.dmark+2)  
302a 32 9f fd			ld (debug_mark+2),a  
302d 18 03			jr .pastdmark  
302f ..			.dmark: db "LST"  
3032 f1			.pastdmark: pop af  
3033			endm  
# End of macro DMARK
3033				CALLMONITOR 
3033 cd aa fd			call debug_vector  
3036				endm  
# End of macro CALLMONITOR
3036			endif 
3036			 
3036				FORTH_DSP_VALUEHL 
3036 cd bd 21			call macro_dsp_valuehl 
3039				endm 
# End of macro FORTH_DSP_VALUEHL
3039			 
3039 e5				push hl 
303a				FORTH_DSP_POP 
303a cd 75 22			call macro_forth_dsp_pop 
303d				endm 
# End of macro FORTH_DSP_POP
303d c1				pop bc 
303e			 
303e			; Start format of scratch string 
303e			 
303e 21 f3 f0			ld hl, scratch 
3041			 
3041 3e 3a			ld a, ':' 
3043 77				ld (hl),a 
3044 23				inc hl 
3045 3e 20			ld a, ' ' 
3047 77				ld (hl), a 
3048			 
3048				; Get ptr to the word we need to look up 
3048			 
3048			;		FORTH_DSP_VALUEHL 
3048				;v5 FORTH_DSP_VALUE 
3048			; TODO type check 
3048			;		inc hl    ; Skip type check  
3048			;		push hl 
3048			;		ex de, hl    ; put into DE 
3048			 
3048			 
3048 21 00 80			ld hl, baseram 
304b				;ld hl, baseusermem 
304b			 
304b e5			push hl   ; sacreifical push 
304c			 
304c			.ldouscanm: 
304c e1			pop hl 
304d			.ldouscan: 
304d			if DEBUG_FORTH_WORDS 
304d				DMARK "LSs" 
304d f5				push af  
304e 3a 62 30			ld a, (.dmark)  
3051 32 9d fd			ld (debug_mark),a  
3054 3a 63 30			ld a, (.dmark+1)  
3057 32 9e fd			ld (debug_mark+1),a  
305a 3a 64 30			ld a, (.dmark+2)  
305d 32 9f fd			ld (debug_mark+2),a  
3060 18 03			jr .pastdmark  
3062 ..			.dmark: db "LSs"  
3065 f1			.pastdmark: pop af  
3066			endm  
# End of macro DMARK
3066				CALLMONITOR 
3066 cd aa fd			call debug_vector  
3069				endm  
# End of macro CALLMONITOR
3069			endif 
3069			; skip dict stub 
3069 cd e5 24			call forth_tok_next 
306c			 
306c			 
306c			; while we have words to look for 
306c			 
306c 7e			ld a, (hl)      
306d			if DEBUG_FORTH_WORDS 
306d				DMARK "LSk" 
306d f5				push af  
306e 3a 82 30			ld a, (.dmark)  
3071 32 9d fd			ld (debug_mark),a  
3074 3a 83 30			ld a, (.dmark+1)  
3077 32 9e fd			ld (debug_mark+1),a  
307a 3a 84 30			ld a, (.dmark+2)  
307d 32 9f fd			ld (debug_mark+2),a  
3080 18 03			jr .pastdmark  
3082 ..			.dmark: db "LSk"  
3085 f1			.pastdmark: pop af  
3086			endm  
# End of macro DMARK
3086				CALLMONITOR 
3086 cd aa fd			call debug_vector  
3089				endm  
# End of macro CALLMONITOR
3089			endif 
3089				;cp WORD_SYS_END 
3089				;jp z, .lunotfound 
3089			 
3089					; if we hit non uwords then gone too far 
3089 fe 01				cp WORD_SYS_UWORD 
308b c2 c9 31				jp nz, .lunotfound 
308e			 
308e				if DEBUG_FORTH_WORDS 
308e					DMARK "LSu" 
308e f5				push af  
308f 3a a3 30			ld a, (.dmark)  
3092 32 9d fd			ld (debug_mark),a  
3095 3a a4 30			ld a, (.dmark+1)  
3098 32 9e fd			ld (debug_mark+1),a  
309b 3a a5 30			ld a, (.dmark+2)  
309e 32 9f fd			ld (debug_mark+2),a  
30a1 18 03			jr .pastdmark  
30a3 ..			.dmark: db "LSu"  
30a6 f1			.pastdmark: pop af  
30a7			endm  
# End of macro DMARK
30a7					CALLMONITOR 
30a7 cd aa fd			call debug_vector  
30aa				endm  
# End of macro CALLMONITOR
30aa				endif 
30aa			 
30aa					; found a uword but is it the one we want... 
30aa			 
30aa c5					push bc     ; uword to find is on bc 
30ab d1					pop de 
30ac			 
30ac e5					push hl  ; to save the ptr 
30ad			 
30ad					; skip opcode 
30ad 23					inc hl  
30ae					; skip next ptr 
30ae 23					inc hl  
30af 23					inc hl 
30b0					; skip len 
30b0 23					inc hl 
30b1			 
30b1				if DEBUG_FORTH_WORDS 
30b1					DMARK "LSc" 
30b1 f5				push af  
30b2 3a c6 30			ld a, (.dmark)  
30b5 32 9d fd			ld (debug_mark),a  
30b8 3a c7 30			ld a, (.dmark+1)  
30bb 32 9e fd			ld (debug_mark+1),a  
30be 3a c8 30			ld a, (.dmark+2)  
30c1 32 9f fd			ld (debug_mark+2),a  
30c4 18 03			jr .pastdmark  
30c6 ..			.dmark: db "LSc"  
30c9 f1			.pastdmark: pop af  
30ca			endm  
# End of macro DMARK
30ca					CALLMONITOR 
30ca cd aa fd			call debug_vector  
30cd				endm  
# End of macro CALLMONITOR
30cd				endif 
30cd			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
30cd			; ie. If WOO is defined first and then WO. Couldnt list WO. 
30cd			; Nope that has gone the other way. It needs to be exact not on first zero 
30cd			;		call strcmp 
30cd c5					push bc 
30ce cd 89 13				call StrictStrCmp 
30d1 c1					pop bc 
30d2 c2 4c 30				jp nz, .ldouscanm 
30d5				 
30d5			 
30d5			 
30d5					; we have a uword so push its name to the stack 
30d5			 
30d5			;	   	push hl  ; save so we can move to next dict block 
30d5 e1			pop hl 
30d6			 
30d6				if DEBUG_FORTH_WORDS 
30d6					DMARK "LSm" 
30d6 f5				push af  
30d7 3a eb 30			ld a, (.dmark)  
30da 32 9d fd			ld (debug_mark),a  
30dd 3a ec 30			ld a, (.dmark+1)  
30e0 32 9e fd			ld (debug_mark+1),a  
30e3 3a ed 30			ld a, (.dmark+2)  
30e6 32 9f fd			ld (debug_mark+2),a  
30e9 18 03			jr .pastdmark  
30eb ..			.dmark: db "LSm"  
30ee f1			.pastdmark: pop af  
30ef			endm  
# End of macro DMARK
30ef					CALLMONITOR 
30ef cd aa fd			call debug_vector  
30f2				endm  
# End of macro CALLMONITOR
30f2				endif 
30f2			 
30f2					; skip opcode 
30f2 23					inc hl  
30f3					; skip next ptr 
30f3 23					inc hl  
30f4 23					inc hl 
30f5					; skip len 
30f5 7e					ld a, (hl)   ; save length to add 
30f6				if DEBUG_FORTH_WORDS 
30f6					DMARK "LS2" 
30f6 f5				push af  
30f7 3a 0b 31			ld a, (.dmark)  
30fa 32 9d fd			ld (debug_mark),a  
30fd 3a 0c 31			ld a, (.dmark+1)  
3100 32 9e fd			ld (debug_mark+1),a  
3103 3a 0d 31			ld a, (.dmark+2)  
3106 32 9f fd			ld (debug_mark+2),a  
3109 18 03			jr .pastdmark  
310b ..			.dmark: db "LS2"  
310e f1			.pastdmark: pop af  
310f			endm  
# End of macro DMARK
310f					CALLMONITOR 
310f cd aa fd			call debug_vector  
3112				endm  
# End of macro CALLMONITOR
3112				endif 
3112			 
3112					; save this location 
3112				 
3112 e5					push hl 
3113			 
3113 23					inc hl 
3114 11 f5 f0				ld de, scratch+2 
3117 4f					ld c, a 
3118 06 00				ld b, 0 
311a			 
311a				if DEBUG_FORTH_WORDS 
311a					DMARK "LSn" 
311a f5				push af  
311b 3a 2f 31			ld a, (.dmark)  
311e 32 9d fd			ld (debug_mark),a  
3121 3a 30 31			ld a, (.dmark+1)  
3124 32 9e fd			ld (debug_mark+1),a  
3127 3a 31 31			ld a, (.dmark+2)  
312a 32 9f fd			ld (debug_mark+2),a  
312d 18 03			jr .pastdmark  
312f ..			.dmark: db "LSn"  
3132 f1			.pastdmark: pop af  
3133			endm  
# End of macro DMARK
3133					CALLMONITOR 
3133 cd aa fd			call debug_vector  
3136				endm  
# End of macro CALLMONITOR
3136				endif 
3136			 
3136					; copy uword name to scratch 
3136			 
3136			;		ldir 
3136			.licplw:	; copy uword name to scratch converting to lower case as we go 
3136 ed a0				ldi 
3138 1b					dec de 
3139 1a					ld a, (de) 
313a cd 5c 12				call to_lower 
313d 12					ld (de),a 
313e 13					inc de 
313f 3e 00				ld a, 0 
3141 b9					cp c 
3142 20 f2				jr nz, .licplw 
3144			 
3144			 
3144			 
3144 1b					dec de 
3145 3e 20				ld a, ' '    ; change null to space 
3147 12					ld (de), a 
3148			 
3148 13					inc de 
3149			 
3149 d5					push de 
314a c1					pop bc     ; move scratch pointer to end of word name and save it 
314b			 
314b e1					pop hl 
314c 7e					ld a, (hl) 
314d					;inc hl 
314d					; skip word string 
314d cd de 0f				call addatohl 
3150			 
3150 23					inc hl 
3151			 
3151				if DEBUG_FORTH_WORDS 
3151					DMARK "LS3" 
3151 f5				push af  
3152 3a 66 31			ld a, (.dmark)  
3155 32 9d fd			ld (debug_mark),a  
3158 3a 67 31			ld a, (.dmark+1)  
315b 32 9e fd			ld (debug_mark+1),a  
315e 3a 68 31			ld a, (.dmark+2)  
3161 32 9f fd			ld (debug_mark+2),a  
3164 18 03			jr .pastdmark  
3166 ..			.dmark: db "LS3"  
3169 f1			.pastdmark: pop af  
316a			endm  
# End of macro DMARK
316a					CALLMONITOR 
316a cd aa fd			call debug_vector  
316d				endm  
# End of macro CALLMONITOR
316d				endif 
316d					; should now be at the start of the machine code to setup the eval of the uword 
316d					; now locate the ptr to the string defintion 
316d			 
316d					; skip ld hl, 
316d					; then load the ptr 
316d			; TODO use get from hl ptr 
316d 23					inc hl 
316e 5e					ld e, (hl) 
316f 23					inc hl 
3170 56					ld d, (hl) 
3171 eb					ex de, hl 
3172			 
3172			 
3172				if DEBUG_FORTH_WORDS 
3172					DMARK "LSt" 
3172 f5				push af  
3173 3a 87 31			ld a, (.dmark)  
3176 32 9d fd			ld (debug_mark),a  
3179 3a 88 31			ld a, (.dmark+1)  
317c 32 9e fd			ld (debug_mark+1),a  
317f 3a 89 31			ld a, (.dmark+2)  
3182 32 9f fd			ld (debug_mark+2),a  
3185 18 03			jr .pastdmark  
3187 ..			.dmark: db "LSt"  
318a f1			.pastdmark: pop af  
318b			endm  
# End of macro DMARK
318b					CALLMONITOR 
318b cd aa fd			call debug_vector  
318e				endm  
# End of macro CALLMONITOR
318e				endif 
318e			 
318e			; cant push right now due to tokenised strings  
318e			 
318e			; get the destination of where to copy this definition to. 
318e			 
318e c5					push bc 
318f d1					pop de 
3190			 
3190 7e			.listl:         ld a,(hl) 
3191 fe 00				cp 0 
3193 28 09				jr z, .lreplsp     ; replace zero with space 
3195					;cp FORTH_END_BUFFER 
3195 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
3197 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
3199				 
3199					; just copy this char as is then 
3199			 
3199 12					ld (de), a 
319a			 
319a 23			.listnxt:	inc hl 
319b 13					inc de 
319c 18 f2				jr .listl 
319e			 
319e 3e 20		.lreplsp:	ld a,' ' 
31a0 12					ld (de), a 
31a1 18 f7				jr .listnxt 
31a3			 
31a3			; close up uword def 
31a3			 
31a3			.listdone: 
31a3 12					ld (de), a 
31a4 13					inc de 
31a5 3e 00				ld a, 0 
31a7 12					ld (de), a 
31a8			 
31a8			; now have def so clean up and push to stack 
31a8			 
31a8 21 f3 f0				ld hl, scratch 
31ab				if DEBUG_FORTH_WORDS 
31ab					DMARK "Ltp" 
31ab f5				push af  
31ac 3a c0 31			ld a, (.dmark)  
31af 32 9d fd			ld (debug_mark),a  
31b2 3a c1 31			ld a, (.dmark+1)  
31b5 32 9e fd			ld (debug_mark+1),a  
31b8 3a c2 31			ld a, (.dmark+2)  
31bb 32 9f fd			ld (debug_mark+2),a  
31be 18 03			jr .pastdmark  
31c0 ..			.dmark: db "Ltp"  
31c3 f1			.pastdmark: pop af  
31c4			endm  
# End of macro DMARK
31c4					CALLMONITOR 
31c4 cd aa fd			call debug_vector  
31c7				endm  
# End of macro CALLMONITOR
31c7				endif 
31c7			 
31c7 18 22			jr .listpush 
31c9			 
31c9			;.lnuword:	pop hl 
31c9			;		call forth_tok_next 
31c9			;		jp .ldouscan  
31c9			 
31c9			.lunotfound:		  
31c9			 
31c9				if DEBUG_FORTH_WORDS 
31c9					DMARK "LSn" 
31c9 f5				push af  
31ca 3a de 31			ld a, (.dmark)  
31cd 32 9d fd			ld (debug_mark),a  
31d0 3a df 31			ld a, (.dmark+1)  
31d3 32 9e fd			ld (debug_mark+1),a  
31d6 3a e0 31			ld a, (.dmark+2)  
31d9 32 9f fd			ld (debug_mark+2),a  
31dc 18 03			jr .pastdmark  
31de ..			.dmark: db "LSn"  
31e1 f1			.pastdmark: pop af  
31e2			endm  
# End of macro DMARK
31e2					CALLMONITOR 
31e2 cd aa fd			call debug_vector  
31e5				endm  
# End of macro CALLMONITOR
31e5				endif 
31e5			 
31e5					 
31e5			;		FORTH_DSP_POP 
31e5			;		ld hl, .luno 
31e5			 
31e5					NEXTW			 
31e5 cd a7 fd			call parse_vector 
31e8 c3 a8 23			jp macro_next 
31eb				endm 
# End of macro NEXTW
31eb			 
31eb			.listpush: 
31eb				if DEBUG_FORTH_WORDS 
31eb					DMARK "LS>" 
31eb f5				push af  
31ec 3a 00 32			ld a, (.dmark)  
31ef 32 9d fd			ld (debug_mark),a  
31f2 3a 01 32			ld a, (.dmark+1)  
31f5 32 9e fd			ld (debug_mark+1),a  
31f8 3a 02 32			ld a, (.dmark+2)  
31fb 32 9f fd			ld (debug_mark+2),a  
31fe 18 03			jr .pastdmark  
3200 ..			.dmark: db "LS>"  
3203 f1			.pastdmark: pop af  
3204			endm  
# End of macro DMARK
3204					CALLMONITOR 
3204 cd aa fd			call debug_vector  
3207				endm  
# End of macro CALLMONITOR
3207				endif 
3207 cd 26 20				call forth_push_str 
320a			 
320a			 
320a			 
320a					NEXTW 
320a cd a7 fd			call parse_vector 
320d c3 a8 23			jp macro_next 
3210				endm 
# End of macro NEXTW
3210			 
3210			;.luno:    db "Word not found",0 
3210			 
3210			 
3210			 
3210			 
3210			 
3210			;		push hl   ; save pointer to start of uword def string 
3210			; 
3210			;; look for FORTH_EOL_LINE 
3210			;		ld a, FORTH_END_BUFFER 
3210			;		call strlent 
3210			; 
3210			;		inc hl		 ; space for coln def 
3210			;		inc hl 
3210			;		inc hl          ; space for terms 
3210			;		inc hl 
3210			; 
3210			;		ld a, 20   ; TODO get actual length 
3210			;		call addatohl    ; include a random amount of room for the uword name 
3210			; 
3210			;		 
3210			;	if DEBUG_FORTH_WORDS 
3210			;		DMARK "Lt1" 
3210			;		CALLMONITOR 
3210			;	endif 
3210			;		 
3210			; 
3210			;; malloc space for the string because we cant change it 
3210			; 
3210			;		call malloc 
3210			;	if DEBUG_FORTH_MALLOC_GUARD 
3210			;		push af 
3210			;		call ishlzero 
3210			;		pop af 
3210			;		 
3210			;		call z,malloc_error 
3210			;	endif 
3210			; 
3210			;	if DEBUG_FORTH_WORDS 
3210			;		DMARK "Lt2" 
3210			;		CALLMONITOR 
3210			;	endif 
3210			;		pop de 
3210			;		push hl    ; push the malloc to release later 
3210			;		push hl   ;  push back a copy for the later stack push 
3210			;		 
3210			;; copy the string swapping out the zero terms for spaces 
3210			; 
3210			;		; de has our source 
3210			;		; hl has our dest 
3210			; 
3210			;; add the coln def 
3210			; 
3210			;		ld a, ':' 
3210			;		ld (hl), a 
3210			;		inc hl 
3210			;		ld a, ' ' 
3210			;		ld (hl), a 
3210			;		inc hl 
3210			; 
3210			;; add the uname word 
3210			;		push de   ; save our string for now 
3210			;		ex de, hl 
3210			; 
3210			;		FORTH_DSP_VALUE 
3210			;		;v5 FORTH_DSP_VALUE 
3210			; 
3210			;		inc hl   ; skip type but we know by now this is OK 
3210			; 
3210			;.luword:	ld a,(hl) 
3210			;		cp 0 
3210			;		jr z, .luword2 
3210			;		ld (de), a 
3210			;		inc de 
3210			;		inc hl 
3210			;		jr .luword 
3210			; 
3210			;.luword2:	ld a, ' ' 
3210			;		ld (de), a 
3210			;;		inc hl 
3210			;;		inc de 
3210			;;		ld (de), a 
3210			;;		inc hl 
3210			;		inc de 
3210			; 
3210			;		ex de, hl 
3210			;		pop de 
3210			;		 
3210			;		 
3210			; 
3210			;; detoken that string and copy it 
3210			; 
3210			;	if DEBUG_FORTH_WORDS 
3210			;		DMARK "Lt2" 
3210			;		CALLMONITOR 
3210			;	endif 
3210			;.ldetok:	ld a, (de) 
3210			;		cp FORTH_END_BUFFER 
3210			;		jr z, .ldetokend 
3210			;		; swap out any zero term for space 
3210			;		cp 0 
3210			;		jr nz, .ldetoknext 
3210			;		ld a, ' ' 
3210			; 
3210			;	if DEBUG_FORTH_WORDS 
3210			;		DMARK "LtS" 
3210			;		CALLMONITOR 
3210			;	endif 
3210			;.ldetoknext:	ld (hl), a 
3210			;		inc de 
3210			;		inc hl 
3210			;		jr .ldetok 
3210			; 
3210			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
3210			;		ld (hl), a  
3210			; 
3210			;; free that temp malloc 
3210			; 
3210			;		pop hl    
3210			; 
3210			;	if DEBUG_FORTH_WORDS 
3210			;		DMARK "Lt4" 
3210			;		CALLMONITOR 
3210			;	endif 
3210			;		call forth_apushstrhl 
3210			; 
3210			;		; get rid of temp malloc area 
3210			; 
3210			;		pop hl 
3210			;		call free 
3210			; 
3210			;		jr .ludone 
3210			; 
3210			;.lnuword:	pop hl 
3210			;		call forth_tok_next 
3210			;		jp .ldouscan  
3210			; 
3210			;.ludone:		 pop hl 
3210			; 
3210					NEXTW 
3210 cd a7 fd			call parse_vector 
3213 c3 a8 23			jp macro_next 
3216				endm 
# End of macro NEXTW
3216			 
3216			.FORGET: 
3216				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
3216 5d				db WORD_SYS_CORE+73             
3217 92 32			dw .NOP            
3219 07				db 6 + 1 
321a .. 00			db "FORGET",0              
3221				endm 
# End of macro CWHEAD
3221			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
3221			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
3221			; | |  
3221			; | | e.g. "MORE" forget 
3221					if DEBUG_FORTH_WORDS_KEY 
3221						DMARK "FRG" 
3221 f5				push af  
3222 3a 36 32			ld a, (.dmark)  
3225 32 9d fd			ld (debug_mark),a  
3228 3a 37 32			ld a, (.dmark+1)  
322b 32 9e fd			ld (debug_mark+1),a  
322e 3a 38 32			ld a, (.dmark+2)  
3231 32 9f fd			ld (debug_mark+2),a  
3234 18 03			jr .pastdmark  
3236 ..			.dmark: db "FRG"  
3239 f1			.pastdmark: pop af  
323a			endm  
# End of macro DMARK
323a						CALLMONITOR 
323a cd aa fd			call debug_vector  
323d				endm  
# End of macro CALLMONITOR
323d					endif 
323d			 
323d				; find uword 
323d			        ; update start of word with "_" 
323d				; replace uword with deleted flag 
323d			 
323d			 
323d			;	if DEBUG_FORTH_WORDS 
323d			;		DMARK "FOG" 
323d			;		CALLMONITOR 
323d			;	endif 
323d			 
323d			 
323d					; Get ptr to the word we need to look up 
323d			 
323d					FORTH_DSP_VALUEHL 
323d cd bd 21			call macro_dsp_valuehl 
3240				endm 
# End of macro FORTH_DSP_VALUEHL
3240					;v5 FORTH_DSP_VALUE 
3240				; TODO type check 
3240			;		inc hl    ; Skip type check  
3240 e5					push hl 
3241 c1					pop bc 
3242			;		ex de, hl    ; put into DE 
3242			 
3242			 
3242 21 00 80				ld hl, baseram 
3245					;ld hl, baseusermem 
3245			 
3245				; skip dict stub 
3245			;	call forth_tok_next 
3245 e5			push hl   ; sacreifical push 
3246			 
3246			.fldouscanm: 
3246 e1				pop hl 
3247			.fldouscan: 
3247			;	if DEBUG_FORTH_WORDS 
3247			;		DMARK "LSs" 
3247			;		CALLMONITOR 
3247			;	endif 
3247				; skip dict stub 
3247 cd e5 24				call forth_tok_next 
324a			 
324a			 
324a			; while we have words to look for 
324a			 
324a 7e				ld a, (hl)      
324b			;	if DEBUG_FORTH_WORDS 
324b			;		DMARK "LSk" 
324b			;		CALLMONITOR 
324b			;	endif 
324b fe 00				cp WORD_SYS_END 
324d ca 89 32				jp z, .flunotfound 
3250 fe 01				cp WORD_SYS_UWORD 
3252 c2 47 32				jp nz, .fldouscan 
3255			 
3255			;	if DEBUG_FORTH_WORDS 
3255			;		DMARK "LSu" 
3255			;		CALLMONITOR 
3255			;	endif 
3255			 
3255					; found a uword but is it the one we want... 
3255			 
3255 c5					push bc     ; uword to find is on bc 
3256 d1					pop de 
3257			 
3257 e5					push hl  ; to save the ptr 
3258			 
3258					; skip opcode 
3258 23					inc hl  
3259					; skip next ptr 
3259 23					inc hl  
325a 23					inc hl 
325b					; skip len 
325b 23					inc hl 
325c			 
325c			;	if DEBUG_FORTH_WORDS 
325c			;		DMARK "LSc" 
325c			;		CALLMONITOR 
325c			;	endif 
325c cd 7c 13				call strcmp 
325f c2 46 32				jp nz, .fldouscanm 
3262			; 
3262			; 
3262			;; while we have words to look for 
3262			; 
3262			;.fdouscan:	ld a, (hl)      
3262			;	if DEBUG_FORTH_WORDS 
3262			;		DMARK "LSs" 
3262			;		CALLMONITOR 
3262			;	endif 
3262			;		cp WORD_SYS_END 
3262			;		jp z, .fudone 
3262			;		cp WORD_SYS_UWORD 
3262			;		jp nz, .fnuword 
3262			; 
3262			;	if DEBUG_FORTH_WORDS 
3262			;		DMARK "FGu" 
3262			;		CALLMONITOR 
3262			;	endif 
3262			; 
3262			;		; found a uword but is it the one we want... 
3262			; 
3262			; 
3262			;	        pop de   ; get back the dsp name 
3262			;		push de 
3262			; 
3262			;		push hl  ; to save the ptr 
3262			; 
3262			;		; skip opcode 
3262			;		inc hl  
3262			;		; skip next ptr 
3262			;		inc hl  
3262			;		inc hl 
3262			;		; skip len 
3262			;		inc hl 
3262			; 
3262			;	if DEBUG_FORTH_WORDS 
3262			;		DMARK "FGc" 
3262			;		CALLMONITOR 
3262			;	endif 
3262			;		call strcmp 
3262			;		jp nz, .fnuword 
3262			 
3262			 
3262 e1			pop hl 
3263			 
3263				 
3263				if DEBUG_FORTH_WORDS 
3263					DMARK "FGm" 
3263 f5				push af  
3264 3a 78 32			ld a, (.dmark)  
3267 32 9d fd			ld (debug_mark),a  
326a 3a 79 32			ld a, (.dmark+1)  
326d 32 9e fd			ld (debug_mark+1),a  
3270 3a 7a 32			ld a, (.dmark+2)  
3273 32 9f fd			ld (debug_mark+2),a  
3276 18 03			jr .pastdmark  
3278 ..			.dmark: db "FGm"  
327b f1			.pastdmark: pop af  
327c			endm  
# End of macro DMARK
327c					CALLMONITOR 
327c cd aa fd			call debug_vector  
327f				endm  
# End of macro CALLMONITOR
327f				endif 
327f			 
327f			 
327f			 
327f					; we have a uword so push its name to the stack 
327f			 
327f			;	   	push hl  ; save so we can move to next dict block 
327f			;pop hl 
327f			 
327f					; update opcode to deleted 
327f 3e 03				ld a, WORD_SYS_DELETED 
3281 77					ld (hl), a 
3282			 
3282 23					inc hl  
3283					; skip next ptr 
3283 23					inc hl  
3284 23					inc hl 
3285					; skip len 
3285 23					inc hl 
3286			 
3286					; TODO change parser to skip deleted words but for now mark it out 
3286 3e 5f				ld a, "_" 
3288 77					ld  (hl),a 
3289			 
3289			;		jr .fudone 
3289			; 
3289			;.fnuword:	pop hl 
3289			;		call forth_tok_next 
3289			;		jp .fdouscan  
3289			 
3289			.flunotfound:		  
3289			 
3289			 
3289					 
3289					FORTH_DSP_POP 
3289 cd 75 22			call macro_forth_dsp_pop 
328c				endm 
# End of macro FORTH_DSP_POP
328c			;		ld hl, .luno 
328c			;.fudone:		 pop hl 
328c					NEXTW 
328c cd a7 fd			call parse_vector 
328f c3 a8 23			jp macro_next 
3292				endm 
# End of macro NEXTW
3292			.NOP: 
3292				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3292 61				db WORD_SYS_CORE+77             
3293 bc 32			dw .COMO            
3295 04				db 3 + 1 
3296 .. 00			db "NOP",0              
329a				endm 
# End of macro CWHEAD
329a			; | NOP (  --  ) Do nothing | DONE 
329a					if DEBUG_FORTH_WORDS_KEY 
329a						DMARK "NOP" 
329a f5				push af  
329b 3a af 32			ld a, (.dmark)  
329e 32 9d fd			ld (debug_mark),a  
32a1 3a b0 32			ld a, (.dmark+1)  
32a4 32 9e fd			ld (debug_mark+1),a  
32a7 3a b1 32			ld a, (.dmark+2)  
32aa 32 9f fd			ld (debug_mark+2),a  
32ad 18 03			jr .pastdmark  
32af ..			.dmark: db "NOP"  
32b2 f1			.pastdmark: pop af  
32b3			endm  
# End of macro DMARK
32b3						CALLMONITOR 
32b3 cd aa fd			call debug_vector  
32b6				endm  
# End of macro CALLMONITOR
32b6					endif 
32b6				       NEXTW 
32b6 cd a7 fd			call parse_vector 
32b9 c3 a8 23			jp macro_next 
32bc				endm 
# End of macro NEXTW
32bc			.COMO: 
32bc				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
32bc 6e				db WORD_SYS_CORE+90             
32bd 11 33			dw .COMC            
32bf 02				db 1 + 1 
32c0 .. 00			db "(",0              
32c2				endm 
# End of macro CWHEAD
32c2			; | ( ( -- )  Start of comment | DONE 
32c2			 
32c2			 
32c2 2a f4 f3				ld hl, ( os_tok_ptr) 
32c5 11 09 33			ld de, .closepar 
32c8					 
32c8					if DEBUG_FORTH_WORDS 
32c8						DMARK ").." 
32c8 f5				push af  
32c9 3a dd 32			ld a, (.dmark)  
32cc 32 9d fd			ld (debug_mark),a  
32cf 3a de 32			ld a, (.dmark+1)  
32d2 32 9e fd			ld (debug_mark+1),a  
32d5 3a df 32			ld a, (.dmark+2)  
32d8 32 9f fd			ld (debug_mark+2),a  
32db 18 03			jr .pastdmark  
32dd ..			.dmark: db ").."  
32e0 f1			.pastdmark: pop af  
32e1			endm  
# End of macro DMARK
32e1						CALLMONITOR 
32e1 cd aa fd			call debug_vector  
32e4				endm  
# End of macro CALLMONITOR
32e4					endif 
32e4 cd af 24			call findnexttok  
32e7			 
32e7					if DEBUG_FORTH_WORDS 
32e7						DMARK "IF5" 
32e7 f5				push af  
32e8 3a fc 32			ld a, (.dmark)  
32eb 32 9d fd			ld (debug_mark),a  
32ee 3a fd 32			ld a, (.dmark+1)  
32f1 32 9e fd			ld (debug_mark+1),a  
32f4 3a fe 32			ld a, (.dmark+2)  
32f7 32 9f fd			ld (debug_mark+2),a  
32fa 18 03			jr .pastdmark  
32fc ..			.dmark: db "IF5"  
32ff f1			.pastdmark: pop af  
3300			endm  
# End of macro DMARK
3300						CALLMONITOR 
3300 cd aa fd			call debug_vector  
3303				endm  
# End of macro CALLMONITOR
3303					endif 
3303				; replace below with ) exec using tok_ptr 
3303 22 f4 f3			ld (os_tok_ptr), hl 
3306 c3 31 24			jp exec1 
3309			 
3309 .. 00			.closepar:   db ")",0 
330b			 
330b				       NEXTW 
330b cd a7 fd			call parse_vector 
330e c3 a8 23			jp macro_next 
3311				endm 
# End of macro NEXTW
3311			.COMC: 
3311				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
3311 6f				db WORD_SYS_CORE+91             
3312 1d 33			dw .SCRATCH            
3314 02				db 1 + 1 
3315 .. 00			db ")",0              
3317				endm 
# End of macro CWHEAD
3317			; | ) ( -- )  End of comment |  DONE  
3317				       NEXTW 
3317 cd a7 fd			call parse_vector 
331a c3 a8 23			jp macro_next 
331d				endm 
# End of macro NEXTW
331d			 
331d			.SCRATCH: 
331d				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
331d 6f				db WORD_SYS_CORE+91             
331e 5b 33			dw .INC            
3320 08				db 7 + 1 
3321 .. 00			db "SCRATCH",0              
3329				endm 
# End of macro CWHEAD
3329			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3329			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3329			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3329			; | |  
3329			; | | e.g.    : score $00 scratch ; 
3329			; | |  
3329			; | | $00 score ! 
3329			; | | $01 score +! 
3329			; | |  
3329			; | | e.g.   : varword $0a scratch ;  
3329			; | | 
3329			; | | $8000 varword ! 
3329					if DEBUG_FORTH_WORDS_KEY 
3329						DMARK "SCR" 
3329 f5				push af  
332a 3a 3e 33			ld a, (.dmark)  
332d 32 9d fd			ld (debug_mark),a  
3330 3a 3f 33			ld a, (.dmark+1)  
3333 32 9e fd			ld (debug_mark+1),a  
3336 3a 40 33			ld a, (.dmark+2)  
3339 32 9f fd			ld (debug_mark+2),a  
333c 18 03			jr .pastdmark  
333e ..			.dmark: db "SCR"  
3341 f1			.pastdmark: pop af  
3342			endm  
# End of macro DMARK
3342						CALLMONITOR 
3342 cd aa fd			call debug_vector  
3345				endm  
# End of macro CALLMONITOR
3345					endif 
3345			 
3345					FORTH_DSP_VALUEHL 
3345 cd bd 21			call macro_dsp_valuehl 
3348				endm 
# End of macro FORTH_DSP_VALUEHL
3348				 
3348					FORTH_DSP_POP 
3348 cd 75 22			call macro_forth_dsp_pop 
334b				endm 
# End of macro FORTH_DSP_POP
334b			 
334b 7d					ld a, l 
334c 21 18 f6				ld hl, os_var_array 
334f cd de 0f				call addatohl 
3352			 
3352 cd b8 1f				call forth_push_numhl 
3355			 
3355				       NEXTW 
3355 cd a7 fd			call parse_vector 
3358 c3 a8 23			jp macro_next 
335b				endm 
# End of macro NEXTW
335b			 
335b			.INC: 
335b				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
335b 6f				db WORD_SYS_CORE+91             
335c b4 33			dw .DEC            
335e 03				db 2 + 1 
335f .. 00			db "+!",0              
3362				endm 
# End of macro CWHEAD
3362			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3362					if DEBUG_FORTH_WORDS_KEY 
3362						DMARK "+s_" 
3362 f5				push af  
3363 3a 77 33			ld a, (.dmark)  
3366 32 9d fd			ld (debug_mark),a  
3369 3a 78 33			ld a, (.dmark+1)  
336c 32 9e fd			ld (debug_mark+1),a  
336f 3a 79 33			ld a, (.dmark+2)  
3372 32 9f fd			ld (debug_mark+2),a  
3375 18 03			jr .pastdmark  
3377 ..			.dmark: db "+s_"  
337a f1			.pastdmark: pop af  
337b			endm  
# End of macro DMARK
337b						CALLMONITOR 
337b cd aa fd			call debug_vector  
337e				endm  
# End of macro CALLMONITOR
337e					endif 
337e			 
337e					FORTH_DSP_VALUEHL 
337e cd bd 21			call macro_dsp_valuehl 
3381				endm 
# End of macro FORTH_DSP_VALUEHL
3381			 
3381 e5					push hl   ; save address 
3382			 
3382					FORTH_DSP_POP 
3382 cd 75 22			call macro_forth_dsp_pop 
3385				endm 
# End of macro FORTH_DSP_POP
3385			 
3385					FORTH_DSP_VALUEHL 
3385 cd bd 21			call macro_dsp_valuehl 
3388				endm 
# End of macro FORTH_DSP_VALUEHL
3388			 
3388 e5					push hl 
3389					FORTH_DSP_POP 
3389 cd 75 22			call macro_forth_dsp_pop 
338c				endm 
# End of macro FORTH_DSP_POP
338c e1					pop hl 
338d			 
338d					; hl contains value to add to byte at a 
338d				 
338d eb					ex de, hl 
338e			 
338e e1					pop hl 
338f			 
338f					if DEBUG_FORTH_WORDS 
338f						DMARK "INC" 
338f f5				push af  
3390 3a a4 33			ld a, (.dmark)  
3393 32 9d fd			ld (debug_mark),a  
3396 3a a5 33			ld a, (.dmark+1)  
3399 32 9e fd			ld (debug_mark+1),a  
339c 3a a6 33			ld a, (.dmark+2)  
339f 32 9f fd			ld (debug_mark+2),a  
33a2 18 03			jr .pastdmark  
33a4 ..			.dmark: db "INC"  
33a7 f1			.pastdmark: pop af  
33a8			endm  
# End of macro DMARK
33a8						CALLMONITOR 
33a8 cd aa fd			call debug_vector  
33ab				endm  
# End of macro CALLMONITOR
33ab					endif 
33ab			 
33ab 7e					ld a,(hl) 
33ac 83					add e 
33ad 77					ld (hl),a 
33ae			 
33ae			 
33ae			 
33ae				       NEXTW 
33ae cd a7 fd			call parse_vector 
33b1 c3 a8 23			jp macro_next 
33b4				endm 
# End of macro NEXTW
33b4			 
33b4			.DEC: 
33b4				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
33b4 6f				db WORD_SYS_CORE+91             
33b5 0b 34			dw .INC2            
33b7 03				db 2 + 1 
33b8 .. 00			db "-!",0              
33bb				endm 
# End of macro CWHEAD
33bb			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
33bb					if DEBUG_FORTH_WORDS_KEY 
33bb						DMARK "-s_" 
33bb f5				push af  
33bc 3a d0 33			ld a, (.dmark)  
33bf 32 9d fd			ld (debug_mark),a  
33c2 3a d1 33			ld a, (.dmark+1)  
33c5 32 9e fd			ld (debug_mark+1),a  
33c8 3a d2 33			ld a, (.dmark+2)  
33cb 32 9f fd			ld (debug_mark+2),a  
33ce 18 03			jr .pastdmark  
33d0 ..			.dmark: db "-s_"  
33d3 f1			.pastdmark: pop af  
33d4			endm  
# End of macro DMARK
33d4						CALLMONITOR 
33d4 cd aa fd			call debug_vector  
33d7				endm  
# End of macro CALLMONITOR
33d7					endif 
33d7			 
33d7					FORTH_DSP_VALUEHL 
33d7 cd bd 21			call macro_dsp_valuehl 
33da				endm 
# End of macro FORTH_DSP_VALUEHL
33da			 
33da e5					push hl   ; save address 
33db			 
33db					FORTH_DSP_POP 
33db cd 75 22			call macro_forth_dsp_pop 
33de				endm 
# End of macro FORTH_DSP_POP
33de			 
33de					FORTH_DSP_VALUEHL 
33de cd bd 21			call macro_dsp_valuehl 
33e1				endm 
# End of macro FORTH_DSP_VALUEHL
33e1			 
33e1					; hl contains value to add to byte at a 
33e1				 
33e1 eb					ex de, hl 
33e2			 
33e2 e1					pop hl 
33e3			 
33e3					if DEBUG_FORTH_WORDS 
33e3						DMARK "DEC" 
33e3 f5				push af  
33e4 3a f8 33			ld a, (.dmark)  
33e7 32 9d fd			ld (debug_mark),a  
33ea 3a f9 33			ld a, (.dmark+1)  
33ed 32 9e fd			ld (debug_mark+1),a  
33f0 3a fa 33			ld a, (.dmark+2)  
33f3 32 9f fd			ld (debug_mark+2),a  
33f6 18 03			jr .pastdmark  
33f8 ..			.dmark: db "DEC"  
33fb f1			.pastdmark: pop af  
33fc			endm  
# End of macro DMARK
33fc						CALLMONITOR 
33fc cd aa fd			call debug_vector  
33ff				endm  
# End of macro CALLMONITOR
33ff					endif 
33ff			 
33ff 7e					ld a,(hl) 
3400 93					sub e 
3401 77					ld (hl),a 
3402			 
3402			 
3402					FORTH_DSP_POP 
3402 cd 75 22			call macro_forth_dsp_pop 
3405				endm 
# End of macro FORTH_DSP_POP
3405			 
3405				       NEXTW 
3405 cd a7 fd			call parse_vector 
3408 c3 a8 23			jp macro_next 
340b				endm 
# End of macro NEXTW
340b			 
340b			.INC2: 
340b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
340b 6f				db WORD_SYS_CORE+91             
340c bb 34			dw .DEC2            
340e 04				db 3 + 1 
340f .. 00			db "+2!",0              
3413				endm 
# End of macro CWHEAD
3413			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3413			 
3413					if DEBUG_FORTH_WORDS_KEY 
3413						DMARK "+2s" 
3413 f5				push af  
3414 3a 28 34			ld a, (.dmark)  
3417 32 9d fd			ld (debug_mark),a  
341a 3a 29 34			ld a, (.dmark+1)  
341d 32 9e fd			ld (debug_mark+1),a  
3420 3a 2a 34			ld a, (.dmark+2)  
3423 32 9f fd			ld (debug_mark+2),a  
3426 18 03			jr .pastdmark  
3428 ..			.dmark: db "+2s"  
342b f1			.pastdmark: pop af  
342c			endm  
# End of macro DMARK
342c						CALLMONITOR 
342c cd aa fd			call debug_vector  
342f				endm  
# End of macro CALLMONITOR
342f					endif 
342f			 
342f					; Address 
342f			 
342f					FORTH_DSP_VALUEHL 
342f cd bd 21			call macro_dsp_valuehl 
3432				endm 
# End of macro FORTH_DSP_VALUEHL
3432			 
3432 e5					push hl    ; save address 
3433			 
3433					; load content into de 
3433			 
3433 5e					ld e,(hl) 
3434 23					inc hl 
3435 56					ld d, (hl) 
3436			 
3436					if DEBUG_FORTH_WORDS 
3436						DMARK "+2a" 
3436 f5				push af  
3437 3a 4b 34			ld a, (.dmark)  
343a 32 9d fd			ld (debug_mark),a  
343d 3a 4c 34			ld a, (.dmark+1)  
3440 32 9e fd			ld (debug_mark+1),a  
3443 3a 4d 34			ld a, (.dmark+2)  
3446 32 9f fd			ld (debug_mark+2),a  
3449 18 03			jr .pastdmark  
344b ..			.dmark: db "+2a"  
344e f1			.pastdmark: pop af  
344f			endm  
# End of macro DMARK
344f						CALLMONITOR 
344f cd aa fd			call debug_vector  
3452				endm  
# End of macro CALLMONITOR
3452					endif 
3452			 
3452					FORTH_DSP_POP 
3452 cd 75 22			call macro_forth_dsp_pop 
3455				endm 
# End of macro FORTH_DSP_POP
3455			 
3455					; Get value to add 
3455			 
3455					FORTH_DSP_VALUE 
3455 cd a6 21			call macro_forth_dsp_value 
3458				endm 
# End of macro FORTH_DSP_VALUE
3458			 
3458					if DEBUG_FORTH_WORDS 
3458						DMARK "+2v" 
3458 f5				push af  
3459 3a 6d 34			ld a, (.dmark)  
345c 32 9d fd			ld (debug_mark),a  
345f 3a 6e 34			ld a, (.dmark+1)  
3462 32 9e fd			ld (debug_mark+1),a  
3465 3a 6f 34			ld a, (.dmark+2)  
3468 32 9f fd			ld (debug_mark+2),a  
346b 18 03			jr .pastdmark  
346d ..			.dmark: db "+2v"  
3470 f1			.pastdmark: pop af  
3471			endm  
# End of macro DMARK
3471						CALLMONITOR 
3471 cd aa fd			call debug_vector  
3474				endm  
# End of macro CALLMONITOR
3474					endif 
3474			 
3474 19					add hl, de 
3475			 
3475					if DEBUG_FORTH_WORDS 
3475						DMARK "+2+" 
3475 f5				push af  
3476 3a 8a 34			ld a, (.dmark)  
3479 32 9d fd			ld (debug_mark),a  
347c 3a 8b 34			ld a, (.dmark+1)  
347f 32 9e fd			ld (debug_mark+1),a  
3482 3a 8c 34			ld a, (.dmark+2)  
3485 32 9f fd			ld (debug_mark+2),a  
3488 18 03			jr .pastdmark  
348a ..			.dmark: db "+2+"  
348d f1			.pastdmark: pop af  
348e			endm  
# End of macro DMARK
348e						CALLMONITOR 
348e cd aa fd			call debug_vector  
3491				endm  
# End of macro CALLMONITOR
3491					endif 
3491			 
3491					; move result to de 
3491			 
3491 eb					ex de, hl 
3492			 
3492					; Address 
3492			 
3492 e1					pop hl 
3493			 
3493					; save it back 
3493			 
3493 73					ld (hl), e 
3494 23					inc hl 
3495 72					ld (hl), d 
3496			 
3496					if DEBUG_FORTH_WORDS 
3496						DMARK "+2e" 
3496 f5				push af  
3497 3a ab 34			ld a, (.dmark)  
349a 32 9d fd			ld (debug_mark),a  
349d 3a ac 34			ld a, (.dmark+1)  
34a0 32 9e fd			ld (debug_mark+1),a  
34a3 3a ad 34			ld a, (.dmark+2)  
34a6 32 9f fd			ld (debug_mark+2),a  
34a9 18 03			jr .pastdmark  
34ab ..			.dmark: db "+2e"  
34ae f1			.pastdmark: pop af  
34af			endm  
# End of macro DMARK
34af						CALLMONITOR 
34af cd aa fd			call debug_vector  
34b2				endm  
# End of macro CALLMONITOR
34b2					endif 
34b2			 
34b2			 
34b2			 
34b2					FORTH_DSP_POP 
34b2 cd 75 22			call macro_forth_dsp_pop 
34b5				endm 
# End of macro FORTH_DSP_POP
34b5			 
34b5			 
34b5				       NEXTW 
34b5 cd a7 fd			call parse_vector 
34b8 c3 a8 23			jp macro_next 
34bb				endm 
# End of macro NEXTW
34bb			 
34bb			.DEC2: 
34bb				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
34bb 6f				db WORD_SYS_CORE+91             
34bc 6d 35			dw .GET2            
34be 04				db 3 + 1 
34bf .. 00			db "-2!",0              
34c3				endm 
# End of macro CWHEAD
34c3			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
34c3			 
34c3			 
34c3					if DEBUG_FORTH_WORDS_KEY 
34c3						DMARK "-2s" 
34c3 f5				push af  
34c4 3a d8 34			ld a, (.dmark)  
34c7 32 9d fd			ld (debug_mark),a  
34ca 3a d9 34			ld a, (.dmark+1)  
34cd 32 9e fd			ld (debug_mark+1),a  
34d0 3a da 34			ld a, (.dmark+2)  
34d3 32 9f fd			ld (debug_mark+2),a  
34d6 18 03			jr .pastdmark  
34d8 ..			.dmark: db "-2s"  
34db f1			.pastdmark: pop af  
34dc			endm  
# End of macro DMARK
34dc						CALLMONITOR 
34dc cd aa fd			call debug_vector  
34df				endm  
# End of macro CALLMONITOR
34df					endif 
34df			 
34df					; Address 
34df			 
34df					FORTH_DSP_VALUEHL 
34df cd bd 21			call macro_dsp_valuehl 
34e2				endm 
# End of macro FORTH_DSP_VALUEHL
34e2			 
34e2 e5					push hl    ; save address 
34e3			 
34e3					; load content into de 
34e3			 
34e3 5e					ld e,(hl) 
34e4 23					inc hl 
34e5 56					ld d, (hl) 
34e6			 
34e6					if DEBUG_FORTH_WORDS 
34e6						DMARK "-2a" 
34e6 f5				push af  
34e7 3a fb 34			ld a, (.dmark)  
34ea 32 9d fd			ld (debug_mark),a  
34ed 3a fc 34			ld a, (.dmark+1)  
34f0 32 9e fd			ld (debug_mark+1),a  
34f3 3a fd 34			ld a, (.dmark+2)  
34f6 32 9f fd			ld (debug_mark+2),a  
34f9 18 03			jr .pastdmark  
34fb ..			.dmark: db "-2a"  
34fe f1			.pastdmark: pop af  
34ff			endm  
# End of macro DMARK
34ff						CALLMONITOR 
34ff cd aa fd			call debug_vector  
3502				endm  
# End of macro CALLMONITOR
3502					endif 
3502			 
3502					FORTH_DSP_POP 
3502 cd 75 22			call macro_forth_dsp_pop 
3505				endm 
# End of macro FORTH_DSP_POP
3505			 
3505					; Get value to remove 
3505			 
3505					FORTH_DSP_VALUE 
3505 cd a6 21			call macro_forth_dsp_value 
3508				endm 
# End of macro FORTH_DSP_VALUE
3508			 
3508					if DEBUG_FORTH_WORDS 
3508						DMARK "-2v" 
3508 f5				push af  
3509 3a 1d 35			ld a, (.dmark)  
350c 32 9d fd			ld (debug_mark),a  
350f 3a 1e 35			ld a, (.dmark+1)  
3512 32 9e fd			ld (debug_mark+1),a  
3515 3a 1f 35			ld a, (.dmark+2)  
3518 32 9f fd			ld (debug_mark+2),a  
351b 18 03			jr .pastdmark  
351d ..			.dmark: db "-2v"  
3520 f1			.pastdmark: pop af  
3521			endm  
# End of macro DMARK
3521						CALLMONITOR 
3521 cd aa fd			call debug_vector  
3524				endm  
# End of macro CALLMONITOR
3524					endif 
3524			 
3524 eb					ex de, hl 
3525 ed 52				sbc hl, de 
3527			 
3527					if DEBUG_FORTH_WORDS 
3527						DMARK "-2d" 
3527 f5				push af  
3528 3a 3c 35			ld a, (.dmark)  
352b 32 9d fd			ld (debug_mark),a  
352e 3a 3d 35			ld a, (.dmark+1)  
3531 32 9e fd			ld (debug_mark+1),a  
3534 3a 3e 35			ld a, (.dmark+2)  
3537 32 9f fd			ld (debug_mark+2),a  
353a 18 03			jr .pastdmark  
353c ..			.dmark: db "-2d"  
353f f1			.pastdmark: pop af  
3540			endm  
# End of macro DMARK
3540						CALLMONITOR 
3540 cd aa fd			call debug_vector  
3543				endm  
# End of macro CALLMONITOR
3543					endif 
3543			 
3543					; move result to de 
3543			 
3543 eb					ex de, hl 
3544			 
3544					; Address 
3544			 
3544 e1					pop hl 
3545			 
3545					; save it back 
3545			 
3545 73					ld (hl), e 
3546 23					inc hl 
3547 72					ld (hl), d 
3548			 
3548					if DEBUG_FORTH_WORDS 
3548						DMARK "-2e" 
3548 f5				push af  
3549 3a 5d 35			ld a, (.dmark)  
354c 32 9d fd			ld (debug_mark),a  
354f 3a 5e 35			ld a, (.dmark+1)  
3552 32 9e fd			ld (debug_mark+1),a  
3555 3a 5f 35			ld a, (.dmark+2)  
3558 32 9f fd			ld (debug_mark+2),a  
355b 18 03			jr .pastdmark  
355d ..			.dmark: db "-2e"  
3560 f1			.pastdmark: pop af  
3561			endm  
# End of macro DMARK
3561						CALLMONITOR 
3561 cd aa fd			call debug_vector  
3564				endm  
# End of macro CALLMONITOR
3564					endif 
3564			 
3564			 
3564					FORTH_DSP_POP 
3564 cd 75 22			call macro_forth_dsp_pop 
3567				endm 
# End of macro FORTH_DSP_POP
3567			 
3567			 
3567			 
3567				       NEXTW 
3567 cd a7 fd			call parse_vector 
356a c3 a8 23			jp macro_next 
356d				endm 
# End of macro NEXTW
356d			.GET2: 
356d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
356d 6f				db WORD_SYS_CORE+91             
356e a5 35			dw .BANG2            
3570 03				db 2 + 1 
3571 .. 00			db "2@",0              
3574				endm 
# End of macro CWHEAD
3574			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3574					if DEBUG_FORTH_WORDS_KEY 
3574						DMARK "2A_" 
3574 f5				push af  
3575 3a 89 35			ld a, (.dmark)  
3578 32 9d fd			ld (debug_mark),a  
357b 3a 8a 35			ld a, (.dmark+1)  
357e 32 9e fd			ld (debug_mark+1),a  
3581 3a 8b 35			ld a, (.dmark+2)  
3584 32 9f fd			ld (debug_mark+2),a  
3587 18 03			jr .pastdmark  
3589 ..			.dmark: db "2A_"  
358c f1			.pastdmark: pop af  
358d			endm  
# End of macro DMARK
358d						CALLMONITOR 
358d cd aa fd			call debug_vector  
3590				endm  
# End of macro CALLMONITOR
3590					endif 
3590			 
3590					FORTH_DSP_VALUEHL 
3590 cd bd 21			call macro_dsp_valuehl 
3593				endm 
# End of macro FORTH_DSP_VALUEHL
3593			 
3593 e5					push hl   ; save address 
3594			 
3594					FORTH_DSP_POP 
3594 cd 75 22			call macro_forth_dsp_pop 
3597				endm 
# End of macro FORTH_DSP_POP
3597			 
3597 e1					pop hl 
3598			 
3598 5e					ld e, (hl) 
3599 23					inc hl 
359a 56					ld d, (hl) 
359b			 
359b eb					ex de, hl 
359c			 
359c cd b8 1f				call forth_push_numhl 
359f			 
359f				       NEXTW 
359f cd a7 fd			call parse_vector 
35a2 c3 a8 23			jp macro_next 
35a5				endm 
# End of macro NEXTW
35a5			.BANG2: 
35a5				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
35a5 6f				db WORD_SYS_CORE+91             
35a6 e0 35			dw .CONFIG            
35a8 03				db 2 + 1 
35a9 .. 00			db "2!",0              
35ac				endm 
# End of macro CWHEAD
35ac			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
35ac					if DEBUG_FORTH_WORDS_KEY 
35ac						DMARK "2S_" 
35ac f5				push af  
35ad 3a c1 35			ld a, (.dmark)  
35b0 32 9d fd			ld (debug_mark),a  
35b3 3a c2 35			ld a, (.dmark+1)  
35b6 32 9e fd			ld (debug_mark+1),a  
35b9 3a c3 35			ld a, (.dmark+2)  
35bc 32 9f fd			ld (debug_mark+2),a  
35bf 18 03			jr .pastdmark  
35c1 ..			.dmark: db "2S_"  
35c4 f1			.pastdmark: pop af  
35c5			endm  
# End of macro DMARK
35c5						CALLMONITOR 
35c5 cd aa fd			call debug_vector  
35c8				endm  
# End of macro CALLMONITOR
35c8					endif 
35c8			 
35c8					FORTH_DSP_VALUEHL 
35c8 cd bd 21			call macro_dsp_valuehl 
35cb				endm 
# End of macro FORTH_DSP_VALUEHL
35cb			 
35cb e5					push hl   ; save address 
35cc			 
35cc			 
35cc					FORTH_DSP_POP 
35cc cd 75 22			call macro_forth_dsp_pop 
35cf				endm 
# End of macro FORTH_DSP_POP
35cf			 
35cf					 
35cf					FORTH_DSP_VALUEHL 
35cf cd bd 21			call macro_dsp_valuehl 
35d2				endm 
# End of macro FORTH_DSP_VALUEHL
35d2			 
35d2					FORTH_DSP_POP 
35d2 cd 75 22			call macro_forth_dsp_pop 
35d5				endm 
# End of macro FORTH_DSP_POP
35d5			 
35d5 eb					ex de, hl    ; value now in de 
35d6			 
35d6 e1					pop hl 
35d7			 
35d7 73					ld (hl), e 
35d8			 
35d8 23					inc hl 
35d9			 
35d9 72					ld (hl), d 
35da			 
35da			 
35da				       NEXTW 
35da cd a7 fd			call parse_vector 
35dd c3 a8 23			jp macro_next 
35e0				endm 
# End of macro NEXTW
35e0			.CONFIG: 
35e0				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
35e0 6f				db WORD_SYS_CORE+91             
35e1 f4 35			dw .ADTOS            
35e3 07				db 6 + 1 
35e4 .. 00			db "CONFIG",0              
35eb				endm 
# End of macro CWHEAD
35eb			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
35eb			 
35eb cd 52 15				call config 
35ee					NEXTW 
35ee cd a7 fd			call parse_vector 
35f1 c3 a8 23			jp macro_next 
35f4				endm 
# End of macro NEXTW
35f4			 
35f4			.ADTOS: 
35f4				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
35f4 6f				db WORD_SYS_CORE+91             
35f5 0d 36			dw .SBTOS            
35f7 03				db 2 + 1 
35f8 .. 00			db "1+",0              
35fb				endm 
# End of macro CWHEAD
35fb			; | 1+ ( u -- u )  Increment value on TOS | DONE 
35fb			 
35fb					FORTH_DSP_VALUEHL 
35fb cd bd 21			call macro_dsp_valuehl 
35fe				endm 
# End of macro FORTH_DSP_VALUEHL
35fe e5					push hl 
35ff			 
35ff					FORTH_DSP_POP 
35ff cd 75 22			call macro_forth_dsp_pop 
3602				endm 
# End of macro FORTH_DSP_POP
3602 e1					pop hl 
3603			 
3603 23					inc hl 
3604 cd b8 1f				call forth_push_numhl 
3607					 
3607					NEXTW 
3607 cd a7 fd			call parse_vector 
360a c3 a8 23			jp macro_next 
360d				endm 
# End of macro NEXTW
360d			.SBTOS: 
360d				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
360d 6f				db WORD_SYS_CORE+91             
360e 26 36			dw .ADSTORE            
3610 03				db 2 + 1 
3611 .. 00			db "1-",0              
3614				endm 
# End of macro CWHEAD
3614			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3614			 
3614					FORTH_DSP_VALUEHL 
3614 cd bd 21			call macro_dsp_valuehl 
3617				endm 
# End of macro FORTH_DSP_VALUEHL
3617 e5					push hl 
3618			 
3618					FORTH_DSP_POP 
3618 cd 75 22			call macro_forth_dsp_pop 
361b				endm 
# End of macro FORTH_DSP_POP
361b e1					pop hl 
361c			 
361c 2b					dec hl 
361d cd b8 1f				call forth_push_numhl 
3620					 
3620					NEXTW 
3620 cd a7 fd			call parse_vector 
3623 c3 a8 23			jp macro_next 
3626				endm 
# End of macro NEXTW
3626			.ADSTORE: 
3626				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3626 6f				db WORD_SYS_CORE+91             
3627 3f 36			dw .ADWSTORE            
3629 04				db 3 + 1 
362a .. 00			db "1+!",0              
362e				endm 
# End of macro CWHEAD
362e			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
362e			 
362e					FORTH_DSP_VALUEHL 
362e cd bd 21			call macro_dsp_valuehl 
3631				endm 
# End of macro FORTH_DSP_VALUEHL
3631 e5					push hl 
3632			 
3632					FORTH_DSP_POP 
3632 cd 75 22			call macro_forth_dsp_pop 
3635				endm 
# End of macro FORTH_DSP_POP
3635 e1					pop hl 
3636			 
3636 7e					ld a, (hl) 
3637 3c					inc a 
3638 77					ld (hl), a 
3639					 
3639					NEXTW 
3639 cd a7 fd			call parse_vector 
363c c3 a8 23			jp macro_next 
363f				endm 
# End of macro NEXTW
363f			.ADWSTORE: 
363f				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
363f 6f				db WORD_SYS_CORE+91             
3640 60 36			dw .SBSTORE            
3642 05				db 4 + 1 
3643 .. 00			db "1+2!",0              
3648				endm 
# End of macro CWHEAD
3648			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3648			 
3648					FORTH_DSP_VALUEHL 
3648 cd bd 21			call macro_dsp_valuehl 
364b				endm 
# End of macro FORTH_DSP_VALUEHL
364b e5					push hl 
364c			 
364c					FORTH_DSP_POP 
364c cd 75 22			call macro_forth_dsp_pop 
364f				endm 
# End of macro FORTH_DSP_POP
364f e1					pop hl 
3650			 
3650 e5					push hl 
3651			 
3651 cd 2a 23				call loadwordinhl 
3654 23					inc hl 
3655			 
3655 d1					pop de 
3656 eb					ex de, hl 
3657 73					ld (hl), e 
3658 23					inc hl 
3659 72					ld (hl), d 
365a					 
365a					NEXTW 
365a cd a7 fd			call parse_vector 
365d c3 a8 23			jp macro_next 
3660				endm 
# End of macro NEXTW
3660			.SBSTORE: 
3660				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3660 6f				db WORD_SYS_CORE+91             
3661 79 36			dw .SBWSTORE            
3663 04				db 3 + 1 
3664 .. 00			db "1-!",0              
3668				endm 
# End of macro CWHEAD
3668			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3668			 
3668					FORTH_DSP_VALUEHL 
3668 cd bd 21			call macro_dsp_valuehl 
366b				endm 
# End of macro FORTH_DSP_VALUEHL
366b e5					push hl 
366c			 
366c					FORTH_DSP_POP 
366c cd 75 22			call macro_forth_dsp_pop 
366f				endm 
# End of macro FORTH_DSP_POP
366f e1					pop hl 
3670			 
3670 7e					ld a, (hl) 
3671 3d					dec a 
3672 77					ld (hl), a 
3673					 
3673					NEXTW 
3673 cd a7 fd			call parse_vector 
3676 c3 a8 23			jp macro_next 
3679				endm 
# End of macro NEXTW
3679			.SBWSTORE: 
3679				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3679 6f				db WORD_SYS_CORE+91             
367a 9a 36			dw .ENDCORE            
367c 05				db 4 + 1 
367d .. 00			db "1-2!",0              
3682				endm 
# End of macro CWHEAD
3682			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3682			 
3682					FORTH_DSP_VALUEHL 
3682 cd bd 21			call macro_dsp_valuehl 
3685				endm 
# End of macro FORTH_DSP_VALUEHL
3685 e5					push hl 
3686			 
3686					FORTH_DSP_POP 
3686 cd 75 22			call macro_forth_dsp_pop 
3689				endm 
# End of macro FORTH_DSP_POP
3689 e1					pop hl 
368a			 
368a e5					push hl 
368b			 
368b cd 2a 23				call loadwordinhl 
368e 2b					dec hl 
368f			 
368f d1					pop de 
3690 eb					ex de, hl 
3691 73					ld (hl), e 
3692 23					inc hl 
3693 72					ld (hl), d 
3694					 
3694					NEXTW 
3694 cd a7 fd			call parse_vector 
3697 c3 a8 23			jp macro_next 
369a				endm 
# End of macro NEXTW
369a			.ENDCORE: 
369a			 
369a			; eof 
369a			 
369a			 
# End of file forth_words_core.asm
369a			include "forth_words_flow.asm" 
369a			 
369a			; | ## Program Flow Words 
369a			 
369a			.IF: 
369a				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
369a 1e				db WORD_SYS_CORE+10             
369b 95 37			dw .THEN            
369d 03				db 2 + 1 
369e .. 00			db "IF",0              
36a1				endm 
# End of macro CWHEAD
36a1			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
36a1			; | | Note: currently not supporting ELSE or nested IF 
36a1			; 
36a1					if DEBUG_FORTH_WORDS_KEY 
36a1						DMARK "IF." 
36a1 f5				push af  
36a2 3a b6 36			ld a, (.dmark)  
36a5 32 9d fd			ld (debug_mark),a  
36a8 3a b7 36			ld a, (.dmark+1)  
36ab 32 9e fd			ld (debug_mark+1),a  
36ae 3a b8 36			ld a, (.dmark+2)  
36b1 32 9f fd			ld (debug_mark+2),a  
36b4 18 03			jr .pastdmark  
36b6 ..			.dmark: db "IF."  
36b9 f1			.pastdmark: pop af  
36ba			endm  
# End of macro DMARK
36ba						CALLMONITOR 
36ba cd aa fd			call debug_vector  
36bd				endm  
# End of macro CALLMONITOR
36bd					endif 
36bd			; eval TOS 
36bd			 
36bd				FORTH_DSP_VALUEHL 
36bd cd bd 21			call macro_dsp_valuehl 
36c0				endm 
# End of macro FORTH_DSP_VALUEHL
36c0			 
36c0			;	push hl 
36c0				FORTH_DSP_POP 
36c0 cd 75 22			call macro_forth_dsp_pop 
36c3				endm 
# End of macro FORTH_DSP_POP
36c3			;	pop hl 
36c3			 
36c3					if DEBUG_FORTH_WORDS 
36c3						DMARK "IF1" 
36c3 f5				push af  
36c4 3a d8 36			ld a, (.dmark)  
36c7 32 9d fd			ld (debug_mark),a  
36ca 3a d9 36			ld a, (.dmark+1)  
36cd 32 9e fd			ld (debug_mark+1),a  
36d0 3a da 36			ld a, (.dmark+2)  
36d3 32 9f fd			ld (debug_mark+2),a  
36d6 18 03			jr .pastdmark  
36d8 ..			.dmark: db "IF1"  
36db f1			.pastdmark: pop af  
36dc			endm  
# End of macro DMARK
36dc						CALLMONITOR 
36dc cd aa fd			call debug_vector  
36df				endm  
# End of macro CALLMONITOR
36df					endif 
36df b7				or a        ; clear carry flag 
36e0 11 00 00			ld de, 0 
36e3 eb				ex de,hl 
36e4 ed 52			sbc hl, de 
36e6 c2 73 37			jp nz, .iftrue 
36e9			 
36e9					if DEBUG_FORTH_WORDS 
36e9						DMARK "IF2" 
36e9 f5				push af  
36ea 3a fe 36			ld a, (.dmark)  
36ed 32 9d fd			ld (debug_mark),a  
36f0 3a ff 36			ld a, (.dmark+1)  
36f3 32 9e fd			ld (debug_mark+1),a  
36f6 3a 00 37			ld a, (.dmark+2)  
36f9 32 9f fd			ld (debug_mark+2),a  
36fc 18 03			jr .pastdmark  
36fe ..			.dmark: db "IF2"  
3701 f1			.pastdmark: pop af  
3702			endm  
# End of macro DMARK
3702						CALLMONITOR 
3702 cd aa fd			call debug_vector  
3705				endm  
# End of macro CALLMONITOR
3705					endif 
3705			 
3705			; if not true then skip to THEN 
3705			 
3705				; TODO get tok_ptr 
3705				; TODO consume toks until we get to THEN 
3705			 
3705 2a f4 f3			ld hl, (os_tok_ptr) 
3708					if DEBUG_FORTH_WORDS 
3708						DMARK "IF3" 
3708 f5				push af  
3709 3a 1d 37			ld a, (.dmark)  
370c 32 9d fd			ld (debug_mark),a  
370f 3a 1e 37			ld a, (.dmark+1)  
3712 32 9e fd			ld (debug_mark+1),a  
3715 3a 1f 37			ld a, (.dmark+2)  
3718 32 9f fd			ld (debug_mark+2),a  
371b 18 03			jr .pastdmark  
371d ..			.dmark: db "IF3"  
3720 f1			.pastdmark: pop af  
3721			endm  
# End of macro DMARK
3721						CALLMONITOR 
3721 cd aa fd			call debug_vector  
3724				endm  
# End of macro CALLMONITOR
3724						 
3724					endif 
3724 11 6e 37			ld de, .ifthen 
3727					if DEBUG_FORTH_WORDS 
3727						DMARK "IF4" 
3727 f5				push af  
3728 3a 3c 37			ld a, (.dmark)  
372b 32 9d fd			ld (debug_mark),a  
372e 3a 3d 37			ld a, (.dmark+1)  
3731 32 9e fd			ld (debug_mark+1),a  
3734 3a 3e 37			ld a, (.dmark+2)  
3737 32 9f fd			ld (debug_mark+2),a  
373a 18 03			jr .pastdmark  
373c ..			.dmark: db "IF4"  
373f f1			.pastdmark: pop af  
3740			endm  
# End of macro DMARK
3740						CALLMONITOR 
3740 cd aa fd			call debug_vector  
3743				endm  
# End of macro CALLMONITOR
3743					endif 
3743 cd af 24			call findnexttok  
3746			 
3746					if DEBUG_FORTH_WORDS 
3746						DMARK "IF5" 
3746 f5				push af  
3747 3a 5b 37			ld a, (.dmark)  
374a 32 9d fd			ld (debug_mark),a  
374d 3a 5c 37			ld a, (.dmark+1)  
3750 32 9e fd			ld (debug_mark+1),a  
3753 3a 5d 37			ld a, (.dmark+2)  
3756 32 9f fd			ld (debug_mark+2),a  
3759 18 03			jr .pastdmark  
375b ..			.dmark: db "IF5"  
375e f1			.pastdmark: pop af  
375f			endm  
# End of macro DMARK
375f						CALLMONITOR 
375f cd aa fd			call debug_vector  
3762				endm  
# End of macro CALLMONITOR
3762					endif 
3762				; TODO replace below with ; exec using tok_ptr 
3762 22 f4 f3			ld (os_tok_ptr), hl 
3765 c3 31 24			jp exec1 
3768				NEXTW 
3768 cd a7 fd			call parse_vector 
376b c3 a8 23			jp macro_next 
376e				endm 
# End of macro NEXTW
376e			 
376e .. 00		.ifthen:  db "THEN",0 
3773			 
3773			.iftrue:		 
3773				; Exec next words normally 
3773			 
3773				; if true then exec following IF as normal 
3773					if DEBUG_FORTH_WORDS 
3773						DMARK "IFT" 
3773 f5				push af  
3774 3a 88 37			ld a, (.dmark)  
3777 32 9d fd			ld (debug_mark),a  
377a 3a 89 37			ld a, (.dmark+1)  
377d 32 9e fd			ld (debug_mark+1),a  
3780 3a 8a 37			ld a, (.dmark+2)  
3783 32 9f fd			ld (debug_mark+2),a  
3786 18 03			jr .pastdmark  
3788 ..			.dmark: db "IFT"  
378b f1			.pastdmark: pop af  
378c			endm  
# End of macro DMARK
378c						CALLMONITOR 
378c cd aa fd			call debug_vector  
378f				endm  
# End of macro CALLMONITOR
378f					endif 
378f			 
378f					NEXTW 
378f cd a7 fd			call parse_vector 
3792 c3 a8 23			jp macro_next 
3795				endm 
# End of macro NEXTW
3795			.THEN: 
3795				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3795 1f				db WORD_SYS_CORE+11             
3796 c0 37			dw .ELSE            
3798 05				db 4 + 1 
3799 .. 00			db "THEN",0              
379e				endm 
# End of macro CWHEAD
379e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
379e					if DEBUG_FORTH_WORDS_KEY 
379e						DMARK "THN" 
379e f5				push af  
379f 3a b3 37			ld a, (.dmark)  
37a2 32 9d fd			ld (debug_mark),a  
37a5 3a b4 37			ld a, (.dmark+1)  
37a8 32 9e fd			ld (debug_mark+1),a  
37ab 3a b5 37			ld a, (.dmark+2)  
37ae 32 9f fd			ld (debug_mark+2),a  
37b1 18 03			jr .pastdmark  
37b3 ..			.dmark: db "THN"  
37b6 f1			.pastdmark: pop af  
37b7			endm  
# End of macro DMARK
37b7						CALLMONITOR 
37b7 cd aa fd			call debug_vector  
37ba				endm  
# End of macro CALLMONITOR
37ba					endif 
37ba					NEXTW 
37ba cd a7 fd			call parse_vector 
37bd c3 a8 23			jp macro_next 
37c0				endm 
# End of macro NEXTW
37c0			.ELSE: 
37c0				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
37c0 20				db WORD_SYS_CORE+12             
37c1 eb 37			dw .DO            
37c3 03				db 2 + 1 
37c4 .. 00			db "ELSE",0              
37c9				endm 
# End of macro CWHEAD
37c9			; | ELSE ( -- ) Not supported - does nothing | TODO 
37c9			 
37c9					if DEBUG_FORTH_WORDS_KEY 
37c9						DMARK "ELS" 
37c9 f5				push af  
37ca 3a de 37			ld a, (.dmark)  
37cd 32 9d fd			ld (debug_mark),a  
37d0 3a df 37			ld a, (.dmark+1)  
37d3 32 9e fd			ld (debug_mark+1),a  
37d6 3a e0 37			ld a, (.dmark+2)  
37d9 32 9f fd			ld (debug_mark+2),a  
37dc 18 03			jr .pastdmark  
37de ..			.dmark: db "ELS"  
37e1 f1			.pastdmark: pop af  
37e2			endm  
# End of macro DMARK
37e2						CALLMONITOR 
37e2 cd aa fd			call debug_vector  
37e5				endm  
# End of macro CALLMONITOR
37e5					endif 
37e5			 
37e5			 
37e5					NEXTW 
37e5 cd a7 fd			call parse_vector 
37e8 c3 a8 23			jp macro_next 
37eb				endm 
# End of macro NEXTW
37eb			.DO: 
37eb				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
37eb 21				db WORD_SYS_CORE+13             
37ec 15 39			dw .LOOP            
37ee 03				db 2 + 1 
37ef .. 00			db "DO",0              
37f2				endm 
# End of macro CWHEAD
37f2			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
37f2			 
37f2					if DEBUG_FORTH_WORDS_KEY 
37f2						DMARK "DO." 
37f2 f5				push af  
37f3 3a 07 38			ld a, (.dmark)  
37f6 32 9d fd			ld (debug_mark),a  
37f9 3a 08 38			ld a, (.dmark+1)  
37fc 32 9e fd			ld (debug_mark+1),a  
37ff 3a 09 38			ld a, (.dmark+2)  
3802 32 9f fd			ld (debug_mark+2),a  
3805 18 03			jr .pastdmark  
3807 ..			.dmark: db "DO."  
380a f1			.pastdmark: pop af  
380b			endm  
# End of macro DMARK
380b						CALLMONITOR 
380b cd aa fd			call debug_vector  
380e				endm  
# End of macro CALLMONITOR
380e					endif 
380e			;  push pc to rsp stack past the DO 
380e			 
380e 2a f4 f3				ld hl, (os_tok_ptr) 
3811 23					inc hl   ; D 
3812 23					inc hl  ; O 
3813 23					inc hl   ; null 
3814					if DEBUG_FORTH_WORDS 
3814						DMARK "DO2" 
3814 f5				push af  
3815 3a 29 38			ld a, (.dmark)  
3818 32 9d fd			ld (debug_mark),a  
381b 3a 2a 38			ld a, (.dmark+1)  
381e 32 9e fd			ld (debug_mark+1),a  
3821 3a 2b 38			ld a, (.dmark+2)  
3824 32 9f fd			ld (debug_mark+2),a  
3827 18 03			jr .pastdmark  
3829 ..			.dmark: db "DO2"  
382c f1			.pastdmark: pop af  
382d			endm  
# End of macro DMARK
382d						CALLMONITOR 
382d cd aa fd			call debug_vector  
3830				endm  
# End of macro CALLMONITOR
3830					endif 
3830					FORTH_RSP_NEXT 
3830 cd 5f 1f			call macro_forth_rsp_next 
3833				endm 
# End of macro FORTH_RSP_NEXT
3833					if DEBUG_FORTH_WORDS 
3833						DMARK "DO3" 
3833 f5				push af  
3834 3a 48 38			ld a, (.dmark)  
3837 32 9d fd			ld (debug_mark),a  
383a 3a 49 38			ld a, (.dmark+1)  
383d 32 9e fd			ld (debug_mark+1),a  
3840 3a 4a 38			ld a, (.dmark+2)  
3843 32 9f fd			ld (debug_mark+2),a  
3846 18 03			jr .pastdmark  
3848 ..			.dmark: db "DO3"  
384b f1			.pastdmark: pop af  
384c			endm  
# End of macro DMARK
384c						CALLMONITOR 
384c cd aa fd			call debug_vector  
384f				endm  
# End of macro CALLMONITOR
384f					endif 
384f			 
384f					;if DEBUG_FORTH_WORDS 
384f				;		push hl 
384f			;		endif  
384f			 
384f			; get counters from data stack 
384f			 
384f			 
384f					FORTH_DSP_VALUEHL 
384f cd bd 21			call macro_dsp_valuehl 
3852				endm 
# End of macro FORTH_DSP_VALUEHL
3852 e5					push hl		 ; hl now has starting counter which needs to be tos 
3853			 
3853					if DEBUG_FORTH_WORDS 
3853						DMARK "DO4" 
3853 f5				push af  
3854 3a 68 38			ld a, (.dmark)  
3857 32 9d fd			ld (debug_mark),a  
385a 3a 69 38			ld a, (.dmark+1)  
385d 32 9e fd			ld (debug_mark+1),a  
3860 3a 6a 38			ld a, (.dmark+2)  
3863 32 9f fd			ld (debug_mark+2),a  
3866 18 03			jr .pastdmark  
3868 ..			.dmark: db "DO4"  
386b f1			.pastdmark: pop af  
386c			endm  
# End of macro DMARK
386c						CALLMONITOR 
386c cd aa fd			call debug_vector  
386f				endm  
# End of macro CALLMONITOR
386f					endif 
386f					FORTH_DSP_POP 
386f cd 75 22			call macro_forth_dsp_pop 
3872				endm 
# End of macro FORTH_DSP_POP
3872			 
3872					if DEBUG_FORTH_WORDS 
3872						DMARK "DO5" 
3872 f5				push af  
3873 3a 87 38			ld a, (.dmark)  
3876 32 9d fd			ld (debug_mark),a  
3879 3a 88 38			ld a, (.dmark+1)  
387c 32 9e fd			ld (debug_mark+1),a  
387f 3a 89 38			ld a, (.dmark+2)  
3882 32 9f fd			ld (debug_mark+2),a  
3885 18 03			jr .pastdmark  
3887 ..			.dmark: db "DO5"  
388a f1			.pastdmark: pop af  
388b			endm  
# End of macro DMARK
388b						CALLMONITOR 
388b cd aa fd			call debug_vector  
388e				endm  
# End of macro CALLMONITOR
388e					endif 
388e			 
388e					FORTH_DSP_VALUEHL 
388e cd bd 21			call macro_dsp_valuehl 
3891				endm 
# End of macro FORTH_DSP_VALUEHL
3891			;		push hl		 ; hl now has starting limit counter 
3891			 
3891					if DEBUG_FORTH_WORDS 
3891						DMARK "DO6" 
3891 f5				push af  
3892 3a a6 38			ld a, (.dmark)  
3895 32 9d fd			ld (debug_mark),a  
3898 3a a7 38			ld a, (.dmark+1)  
389b 32 9e fd			ld (debug_mark+1),a  
389e 3a a8 38			ld a, (.dmark+2)  
38a1 32 9f fd			ld (debug_mark+2),a  
38a4 18 03			jr .pastdmark  
38a6 ..			.dmark: db "DO6"  
38a9 f1			.pastdmark: pop af  
38aa			endm  
# End of macro DMARK
38aa						CALLMONITOR 
38aa cd aa fd			call debug_vector  
38ad				endm  
# End of macro CALLMONITOR
38ad					endif 
38ad					FORTH_DSP_POP 
38ad cd 75 22			call macro_forth_dsp_pop 
38b0				endm 
# End of macro FORTH_DSP_POP
38b0			 
38b0			; put counters on the loop stack 
38b0			 
38b0			;		pop hl			 ; limit counter 
38b0 d1					pop de			; start counter 
38b1			 
38b1					; push limit counter 
38b1			 
38b1					if DEBUG_FORTH_WORDS 
38b1						DMARK "DO7" 
38b1 f5				push af  
38b2 3a c6 38			ld a, (.dmark)  
38b5 32 9d fd			ld (debug_mark),a  
38b8 3a c7 38			ld a, (.dmark+1)  
38bb 32 9e fd			ld (debug_mark+1),a  
38be 3a c8 38			ld a, (.dmark+2)  
38c1 32 9f fd			ld (debug_mark+2),a  
38c4 18 03			jr .pastdmark  
38c6 ..			.dmark: db "DO7"  
38c9 f1			.pastdmark: pop af  
38ca			endm  
# End of macro DMARK
38ca						CALLMONITOR 
38ca cd aa fd			call debug_vector  
38cd				endm  
# End of macro CALLMONITOR
38cd					endif 
38cd					FORTH_LOOP_NEXT 
38cd cd ee 21			call macro_forth_loop_next 
38d0				endm 
# End of macro FORTH_LOOP_NEXT
38d0			 
38d0					; push start counter 
38d0			 
38d0 eb					ex de, hl 
38d1					if DEBUG_FORTH_WORDS 
38d1						DMARK "DO7" 
38d1 f5				push af  
38d2 3a e6 38			ld a, (.dmark)  
38d5 32 9d fd			ld (debug_mark),a  
38d8 3a e7 38			ld a, (.dmark+1)  
38db 32 9e fd			ld (debug_mark+1),a  
38de 3a e8 38			ld a, (.dmark+2)  
38e1 32 9f fd			ld (debug_mark+2),a  
38e4 18 03			jr .pastdmark  
38e6 ..			.dmark: db "DO7"  
38e9 f1			.pastdmark: pop af  
38ea			endm  
# End of macro DMARK
38ea						CALLMONITOR 
38ea cd aa fd			call debug_vector  
38ed				endm  
# End of macro CALLMONITOR
38ed					endif 
38ed					FORTH_LOOP_NEXT 
38ed cd ee 21			call macro_forth_loop_next 
38f0				endm 
# End of macro FORTH_LOOP_NEXT
38f0			 
38f0			 
38f0					; init first round of I counter 
38f0			 
38f0 22 18 f4				ld (os_current_i), hl 
38f3			 
38f3					if DEBUG_FORTH_WORDS 
38f3						DMARK "DO8" 
38f3 f5				push af  
38f4 3a 08 39			ld a, (.dmark)  
38f7 32 9d fd			ld (debug_mark),a  
38fa 3a 09 39			ld a, (.dmark+1)  
38fd 32 9e fd			ld (debug_mark+1),a  
3900 3a 0a 39			ld a, (.dmark+2)  
3903 32 9f fd			ld (debug_mark+2),a  
3906 18 03			jr .pastdmark  
3908 ..			.dmark: db "DO8"  
390b f1			.pastdmark: pop af  
390c			endm  
# End of macro DMARK
390c						CALLMONITOR 
390c cd aa fd			call debug_vector  
390f				endm  
# End of macro CALLMONITOR
390f					endif 
390f			 
390f					NEXTW 
390f cd a7 fd			call parse_vector 
3912 c3 a8 23			jp macro_next 
3915				endm 
# End of macro NEXTW
3915			.LOOP: 
3915				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3915 22				db WORD_SYS_CORE+14             
3916 33 3a			dw .I            
3918 05				db 4 + 1 
3919 .. 00			db "LOOP",0              
391e				endm 
# End of macro CWHEAD
391e			; | LOOP ( -- ) Increment and test loop counter  | DONE 
391e			 
391e				; pop tos as current loop count to hl 
391e			 
391e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
391e			 
391e				FORTH_LOOP_TOS 
391e cd 21 22			call macro_forth_loop_tos 
3921				endm 
# End of macro FORTH_LOOP_TOS
3921 e5				push hl 
3922			 
3922					if DEBUG_FORTH_WORDS_KEY 
3922						DMARK "LOP" 
3922 f5				push af  
3923 3a 37 39			ld a, (.dmark)  
3926 32 9d fd			ld (debug_mark),a  
3929 3a 38 39			ld a, (.dmark+1)  
392c 32 9e fd			ld (debug_mark+1),a  
392f 3a 39 39			ld a, (.dmark+2)  
3932 32 9f fd			ld (debug_mark+2),a  
3935 18 03			jr .pastdmark  
3937 ..			.dmark: db "LOP"  
393a f1			.pastdmark: pop af  
393b			endm  
# End of macro DMARK
393b						CALLMONITOR 
393b cd aa fd			call debug_vector  
393e				endm  
# End of macro CALLMONITOR
393e					endif 
393e				; next item on the stack is the limit. get it 
393e			 
393e			 
393e				FORTH_LOOP_POP 
393e cd 2b 22			call macro_forth_loop_pop 
3941				endm 
# End of macro FORTH_LOOP_POP
3941			 
3941				FORTH_LOOP_TOS 
3941 cd 21 22			call macro_forth_loop_tos 
3944				endm 
# End of macro FORTH_LOOP_TOS
3944			 
3944 d1				pop de		 ; de = i, hl = limit 
3945			 
3945					if DEBUG_FORTH_WORDS 
3945						DMARK "LP1" 
3945 f5				push af  
3946 3a 5a 39			ld a, (.dmark)  
3949 32 9d fd			ld (debug_mark),a  
394c 3a 5b 39			ld a, (.dmark+1)  
394f 32 9e fd			ld (debug_mark+1),a  
3952 3a 5c 39			ld a, (.dmark+2)  
3955 32 9f fd			ld (debug_mark+2),a  
3958 18 03			jr .pastdmark  
395a ..			.dmark: db "LP1"  
395d f1			.pastdmark: pop af  
395e			endm  
# End of macro DMARK
395e						CALLMONITOR 
395e cd aa fd			call debug_vector  
3961				endm  
# End of macro CALLMONITOR
3961					endif 
3961			 
3961				; go back to previous word 
3961			 
3961 d5				push de    ; save I for inc later 
3962			 
3962			 
3962				; get limit 
3962				;  is I at limit? 
3962			 
3962			 
3962					if DEBUG_FORTH_WORDS 
3962						DMARK "LP1" 
3962 f5				push af  
3963 3a 77 39			ld a, (.dmark)  
3966 32 9d fd			ld (debug_mark),a  
3969 3a 78 39			ld a, (.dmark+1)  
396c 32 9e fd			ld (debug_mark+1),a  
396f 3a 79 39			ld a, (.dmark+2)  
3972 32 9f fd			ld (debug_mark+2),a  
3975 18 03			jr .pastdmark  
3977 ..			.dmark: db "LP1"  
397a f1			.pastdmark: pop af  
397b			endm  
# End of macro DMARK
397b						CALLMONITOR 
397b cd aa fd			call debug_vector  
397e				endm  
# End of macro CALLMONITOR
397e					endif 
397e			 
397e ed 52			sbc hl, de 
3980			 
3980			 
3980				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3980			 
3980 20 29				jr nz, .loopnotdone 
3982			 
3982 e1				pop hl   ; get rid of saved I 
3983				FORTH_LOOP_POP     ; get rid of limit 
3983 cd 2b 22			call macro_forth_loop_pop 
3986				endm 
# End of macro FORTH_LOOP_POP
3986			 
3986				FORTH_RSP_POP     ; get rid of DO ptr 
3986 cd 80 1f			call macro_forth_rsp_pop 
3989				endm 
# End of macro FORTH_RSP_POP
3989			 
3989			if DEBUG_FORTH_WORDS 
3989						DMARK "LP>" 
3989 f5				push af  
398a 3a 9e 39			ld a, (.dmark)  
398d 32 9d fd			ld (debug_mark),a  
3990 3a 9f 39			ld a, (.dmark+1)  
3993 32 9e fd			ld (debug_mark+1),a  
3996 3a a0 39			ld a, (.dmark+2)  
3999 32 9f fd			ld (debug_mark+2),a  
399c 18 03			jr .pastdmark  
399e ..			.dmark: db "LP>"  
39a1 f1			.pastdmark: pop af  
39a2			endm  
# End of macro DMARK
39a2				CALLMONITOR 
39a2 cd aa fd			call debug_vector  
39a5				endm  
# End of macro CALLMONITOR
39a5			endif 
39a5			 
39a5					NEXTW 
39a5 cd a7 fd			call parse_vector 
39a8 c3 a8 23			jp macro_next 
39ab				endm 
# End of macro NEXTW
39ab				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
39ab			 
39ab			.loopnotdone: 
39ab			 
39ab e1				pop hl    ; get I 
39ac 23				inc hl 
39ad			 
39ad			   	; save new I 
39ad			 
39ad			 
39ad					; set I counter 
39ad			 
39ad 22 18 f4				ld (os_current_i), hl 
39b0			 
39b0					if DEBUG_FORTH_WORDS 
39b0						DMARK "LPN" 
39b0 f5				push af  
39b1 3a c5 39			ld a, (.dmark)  
39b4 32 9d fd			ld (debug_mark),a  
39b7 3a c6 39			ld a, (.dmark+1)  
39ba 32 9e fd			ld (debug_mark+1),a  
39bd 3a c7 39			ld a, (.dmark+2)  
39c0 32 9f fd			ld (debug_mark+2),a  
39c3 18 03			jr .pastdmark  
39c5 ..			.dmark: db "LPN"  
39c8 f1			.pastdmark: pop af  
39c9			endm  
# End of macro DMARK
39c9					CALLMONITOR 
39c9 cd aa fd			call debug_vector  
39cc				endm  
# End of macro CALLMONITOR
39cc					endif 
39cc					 
39cc				FORTH_LOOP_NEXT 
39cc cd ee 21			call macro_forth_loop_next 
39cf				endm 
# End of macro FORTH_LOOP_NEXT
39cf			 
39cf			 
39cf					if DEBUG_FORTH_WORDS 
39cf eb						ex de,hl 
39d0					endif 
39d0			 
39d0			;	; get DO ptr 
39d0			; 
39d0					if DEBUG_FORTH_WORDS 
39d0						DMARK "LP7" 
39d0 f5				push af  
39d1 3a e5 39			ld a, (.dmark)  
39d4 32 9d fd			ld (debug_mark),a  
39d7 3a e6 39			ld a, (.dmark+1)  
39da 32 9e fd			ld (debug_mark+1),a  
39dd 3a e7 39			ld a, (.dmark+2)  
39e0 32 9f fd			ld (debug_mark+2),a  
39e3 18 03			jr .pastdmark  
39e5 ..			.dmark: db "LP7"  
39e8 f1			.pastdmark: pop af  
39e9			endm  
# End of macro DMARK
39e9					CALLMONITOR 
39e9 cd aa fd			call debug_vector  
39ec				endm  
# End of macro CALLMONITOR
39ec					endif 
39ec				FORTH_RSP_TOS 
39ec cd 76 1f			call macro_forth_rsp_tos 
39ef				endm 
# End of macro FORTH_RSP_TOS
39ef			 
39ef					if DEBUG_FORTH_WORDS 
39ef						DMARK "LP8" 
39ef f5				push af  
39f0 3a 04 3a			ld a, (.dmark)  
39f3 32 9d fd			ld (debug_mark),a  
39f6 3a 05 3a			ld a, (.dmark+1)  
39f9 32 9e fd			ld (debug_mark+1),a  
39fc 3a 06 3a			ld a, (.dmark+2)  
39ff 32 9f fd			ld (debug_mark+2),a  
3a02 18 03			jr .pastdmark  
3a04 ..			.dmark: db "LP8"  
3a07 f1			.pastdmark: pop af  
3a08			endm  
# End of macro DMARK
3a08					CALLMONITOR 
3a08 cd aa fd			call debug_vector  
3a0b				endm  
# End of macro CALLMONITOR
3a0b					endif 
3a0b				;push hl 
3a0b			 
3a0b				; not going to DO any more 
3a0b				; get rid of the RSP pointer as DO will add it back in 
3a0b				;FORTH_RSP_POP 
3a0b				;pop hl 
3a0b			 
3a0b				;ld hl,(cli_ret_sp) 
3a0b				;ld e, (hl) 
3a0b				;inc hl 
3a0b				;ld d, (hl) 
3a0b				;ex de,hl 
3a0b 22 f4 f3			ld (os_tok_ptr), hl 
3a0e					if DEBUG_FORTH_WORDS 
3a0e						DMARK "LP<" 
3a0e f5				push af  
3a0f 3a 23 3a			ld a, (.dmark)  
3a12 32 9d fd			ld (debug_mark),a  
3a15 3a 24 3a			ld a, (.dmark+1)  
3a18 32 9e fd			ld (debug_mark+1),a  
3a1b 3a 25 3a			ld a, (.dmark+2)  
3a1e 32 9f fd			ld (debug_mark+2),a  
3a21 18 03			jr .pastdmark  
3a23 ..			.dmark: db "LP<"  
3a26 f1			.pastdmark: pop af  
3a27			endm  
# End of macro DMARK
3a27					CALLMONITOR 
3a27 cd aa fd			call debug_vector  
3a2a				endm  
# End of macro CALLMONITOR
3a2a				endif 
3a2a c3 31 24			jp exec1 
3a2d			 
3a2d					 
3a2d			 
3a2d			 
3a2d					NEXTW 
3a2d cd a7 fd			call parse_vector 
3a30 c3 a8 23			jp macro_next 
3a33				endm 
# End of macro NEXTW
3a33			.I:  
3a33			 
3a33				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3a33 5e				db WORD_SYS_CORE+74             
3a34 61 3a			dw .DLOOP            
3a36 02				db 1 + 1 
3a37 .. 00			db "I",0              
3a39				endm 
# End of macro CWHEAD
3a39			; | I ( -- ) Current loop counter | DONE 
3a39					if DEBUG_FORTH_WORDS_KEY 
3a39						DMARK "I.." 
3a39 f5				push af  
3a3a 3a 4e 3a			ld a, (.dmark)  
3a3d 32 9d fd			ld (debug_mark),a  
3a40 3a 4f 3a			ld a, (.dmark+1)  
3a43 32 9e fd			ld (debug_mark+1),a  
3a46 3a 50 3a			ld a, (.dmark+2)  
3a49 32 9f fd			ld (debug_mark+2),a  
3a4c 18 03			jr .pastdmark  
3a4e ..			.dmark: db "I.."  
3a51 f1			.pastdmark: pop af  
3a52			endm  
# End of macro DMARK
3a52						CALLMONITOR 
3a52 cd aa fd			call debug_vector  
3a55				endm  
# End of macro CALLMONITOR
3a55					endif 
3a55			 
3a55 2a 18 f4				ld hl,(os_current_i) 
3a58 cd b8 1f				call forth_push_numhl 
3a5b			 
3a5b					NEXTW 
3a5b cd a7 fd			call parse_vector 
3a5e c3 a8 23			jp macro_next 
3a61				endm 
# End of macro NEXTW
3a61			.DLOOP: 
3a61				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3a61 5f				db WORD_SYS_CORE+75             
3a62 48 3b			dw .REPEAT            
3a64 06				db 5 + 1 
3a65 .. 00			db "-LOOP",0              
3a6b				endm 
# End of macro CWHEAD
3a6b			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3a6b				; pop tos as current loop count to hl 
3a6b					if DEBUG_FORTH_WORDS_KEY 
3a6b						DMARK "-LP" 
3a6b f5				push af  
3a6c 3a 80 3a			ld a, (.dmark)  
3a6f 32 9d fd			ld (debug_mark),a  
3a72 3a 81 3a			ld a, (.dmark+1)  
3a75 32 9e fd			ld (debug_mark+1),a  
3a78 3a 82 3a			ld a, (.dmark+2)  
3a7b 32 9f fd			ld (debug_mark+2),a  
3a7e 18 03			jr .pastdmark  
3a80 ..			.dmark: db "-LP"  
3a83 f1			.pastdmark: pop af  
3a84			endm  
# End of macro DMARK
3a84						CALLMONITOR 
3a84 cd aa fd			call debug_vector  
3a87				endm  
# End of macro CALLMONITOR
3a87					endif 
3a87			 
3a87				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3a87			 
3a87				FORTH_LOOP_TOS 
3a87 cd 21 22			call macro_forth_loop_tos 
3a8a				endm 
# End of macro FORTH_LOOP_TOS
3a8a e5				push hl 
3a8b			 
3a8b					if DEBUG_FORTH_WORDS 
3a8b						DMARK "-LP" 
3a8b f5				push af  
3a8c 3a a0 3a			ld a, (.dmark)  
3a8f 32 9d fd			ld (debug_mark),a  
3a92 3a a1 3a			ld a, (.dmark+1)  
3a95 32 9e fd			ld (debug_mark+1),a  
3a98 3a a2 3a			ld a, (.dmark+2)  
3a9b 32 9f fd			ld (debug_mark+2),a  
3a9e 18 03			jr .pastdmark  
3aa0 ..			.dmark: db "-LP"  
3aa3 f1			.pastdmark: pop af  
3aa4			endm  
# End of macro DMARK
3aa4						CALLMONITOR 
3aa4 cd aa fd			call debug_vector  
3aa7				endm  
# End of macro CALLMONITOR
3aa7					endif 
3aa7				; next item on the stack is the limit. get it 
3aa7			 
3aa7			 
3aa7				FORTH_LOOP_POP 
3aa7 cd 2b 22			call macro_forth_loop_pop 
3aaa				endm 
# End of macro FORTH_LOOP_POP
3aaa			 
3aaa				FORTH_LOOP_TOS 
3aaa cd 21 22			call macro_forth_loop_tos 
3aad				endm 
# End of macro FORTH_LOOP_TOS
3aad			 
3aad d1				pop de		 ; de = i, hl = limit 
3aae			 
3aae					if DEBUG_FORTH_WORDS 
3aae						DMARK "-L1" 
3aae f5				push af  
3aaf 3a c3 3a			ld a, (.dmark)  
3ab2 32 9d fd			ld (debug_mark),a  
3ab5 3a c4 3a			ld a, (.dmark+1)  
3ab8 32 9e fd			ld (debug_mark+1),a  
3abb 3a c5 3a			ld a, (.dmark+2)  
3abe 32 9f fd			ld (debug_mark+2),a  
3ac1 18 03			jr .pastdmark  
3ac3 ..			.dmark: db "-L1"  
3ac6 f1			.pastdmark: pop af  
3ac7			endm  
# End of macro DMARK
3ac7						CALLMONITOR 
3ac7 cd aa fd			call debug_vector  
3aca				endm  
# End of macro CALLMONITOR
3aca					endif 
3aca			 
3aca				; go back to previous word 
3aca			 
3aca d5				push de    ; save I for inc later 
3acb			 
3acb			 
3acb				; get limit 
3acb				;  is I at limit? 
3acb			 
3acb			 
3acb					if DEBUG_FORTH_WORDS 
3acb						DMARK "-L1" 
3acb f5				push af  
3acc 3a e0 3a			ld a, (.dmark)  
3acf 32 9d fd			ld (debug_mark),a  
3ad2 3a e1 3a			ld a, (.dmark+1)  
3ad5 32 9e fd			ld (debug_mark+1),a  
3ad8 3a e2 3a			ld a, (.dmark+2)  
3adb 32 9f fd			ld (debug_mark+2),a  
3ade 18 03			jr .pastdmark  
3ae0 ..			.dmark: db "-L1"  
3ae3 f1			.pastdmark: pop af  
3ae4			endm  
# End of macro DMARK
3ae4						CALLMONITOR 
3ae4 cd aa fd			call debug_vector  
3ae7				endm  
# End of macro CALLMONITOR
3ae7					endif 
3ae7			 
3ae7 ed 52			sbc hl, de 
3ae9			 
3ae9			 
3ae9				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3ae9			 
3ae9 20 29				jr nz, .mloopnotdone 
3aeb			 
3aeb e1				pop hl   ; get rid of saved I 
3aec				FORTH_LOOP_POP     ; get rid of limit 
3aec cd 2b 22			call macro_forth_loop_pop 
3aef				endm 
# End of macro FORTH_LOOP_POP
3aef			 
3aef				FORTH_RSP_POP     ; get rid of DO ptr 
3aef cd 80 1f			call macro_forth_rsp_pop 
3af2				endm 
# End of macro FORTH_RSP_POP
3af2			 
3af2			if DEBUG_FORTH_WORDS 
3af2						DMARK "-L>" 
3af2 f5				push af  
3af3 3a 07 3b			ld a, (.dmark)  
3af6 32 9d fd			ld (debug_mark),a  
3af9 3a 08 3b			ld a, (.dmark+1)  
3afc 32 9e fd			ld (debug_mark+1),a  
3aff 3a 09 3b			ld a, (.dmark+2)  
3b02 32 9f fd			ld (debug_mark+2),a  
3b05 18 03			jr .pastdmark  
3b07 ..			.dmark: db "-L>"  
3b0a f1			.pastdmark: pop af  
3b0b			endm  
# End of macro DMARK
3b0b				CALLMONITOR 
3b0b cd aa fd			call debug_vector  
3b0e				endm  
# End of macro CALLMONITOR
3b0e			endif 
3b0e			 
3b0e					NEXTW 
3b0e cd a7 fd			call parse_vector 
3b11 c3 a8 23			jp macro_next 
3b14				endm 
# End of macro NEXTW
3b14				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3b14			 
3b14			.mloopnotdone: 
3b14			 
3b14 e1				pop hl    ; get I 
3b15 2b				dec hl 
3b16			 
3b16			   	; save new I 
3b16			 
3b16			 
3b16					; set I counter 
3b16			 
3b16 22 18 f4				ld (os_current_i), hl 
3b19			 
3b19					 
3b19				FORTH_LOOP_NEXT 
3b19 cd ee 21			call macro_forth_loop_next 
3b1c				endm 
# End of macro FORTH_LOOP_NEXT
3b1c			 
3b1c			 
3b1c					if DEBUG_FORTH_WORDS 
3b1c eb						ex de,hl 
3b1d					endif 
3b1d			 
3b1d			;	; get DO ptr 
3b1d			; 
3b1d				FORTH_RSP_TOS 
3b1d cd 76 1f			call macro_forth_rsp_tos 
3b20				endm 
# End of macro FORTH_RSP_TOS
3b20			 
3b20				;push hl 
3b20			 
3b20				; not going to DO any more 
3b20				; get rid of the RSP pointer as DO will add it back in 
3b20				;FORTH_RSP_POP 
3b20				;pop hl 
3b20			 
3b20			 
3b20 22 f4 f3			ld (os_tok_ptr), hl 
3b23					if DEBUG_FORTH_WORDS 
3b23						DMARK "-L<" 
3b23 f5				push af  
3b24 3a 38 3b			ld a, (.dmark)  
3b27 32 9d fd			ld (debug_mark),a  
3b2a 3a 39 3b			ld a, (.dmark+1)  
3b2d 32 9e fd			ld (debug_mark+1),a  
3b30 3a 3a 3b			ld a, (.dmark+2)  
3b33 32 9f fd			ld (debug_mark+2),a  
3b36 18 03			jr .pastdmark  
3b38 ..			.dmark: db "-L<"  
3b3b f1			.pastdmark: pop af  
3b3c			endm  
# End of macro DMARK
3b3c					CALLMONITOR 
3b3c cd aa fd			call debug_vector  
3b3f				endm  
# End of macro CALLMONITOR
3b3f				endif 
3b3f c3 31 24			jp exec1 
3b42			 
3b42					 
3b42			 
3b42			 
3b42			 
3b42				NEXTW 
3b42 cd a7 fd			call parse_vector 
3b45 c3 a8 23			jp macro_next 
3b48				endm 
# End of macro NEXTW
3b48			 
3b48			 
3b48			 
3b48			 
3b48			.REPEAT: 
3b48				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3b48 71				db WORD_SYS_CORE+93             
3b49 9e 3b			dw .UNTIL            
3b4b 06				db 5 + 1 
3b4c .. 00			db "REPEAT",0              
3b53				endm 
# End of macro CWHEAD
3b53			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3b53			;  push pc to rsp stack past the REPEAT 
3b53					if DEBUG_FORTH_WORDS_KEY 
3b53						DMARK "REP" 
3b53 f5				push af  
3b54 3a 68 3b			ld a, (.dmark)  
3b57 32 9d fd			ld (debug_mark),a  
3b5a 3a 69 3b			ld a, (.dmark+1)  
3b5d 32 9e fd			ld (debug_mark+1),a  
3b60 3a 6a 3b			ld a, (.dmark+2)  
3b63 32 9f fd			ld (debug_mark+2),a  
3b66 18 03			jr .pastdmark  
3b68 ..			.dmark: db "REP"  
3b6b f1			.pastdmark: pop af  
3b6c			endm  
# End of macro DMARK
3b6c						CALLMONITOR 
3b6c cd aa fd			call debug_vector  
3b6f				endm  
# End of macro CALLMONITOR
3b6f					endif 
3b6f			 
3b6f 2a f4 f3				ld hl, (os_tok_ptr) 
3b72 23					inc hl   ; R 
3b73 23					inc hl  ; E 
3b74 23					inc hl   ; P 
3b75 23					inc hl   ; E 
3b76 23					inc hl   ; A 
3b77 23					inc hl   ; T 
3b78 23					inc hl   ; zero 
3b79					FORTH_RSP_NEXT 
3b79 cd 5f 1f			call macro_forth_rsp_next 
3b7c				endm 
# End of macro FORTH_RSP_NEXT
3b7c			 
3b7c			 
3b7c					if DEBUG_FORTH_WORDS 
3b7c						DMARK "REP" 
3b7c f5				push af  
3b7d 3a 91 3b			ld a, (.dmark)  
3b80 32 9d fd			ld (debug_mark),a  
3b83 3a 92 3b			ld a, (.dmark+1)  
3b86 32 9e fd			ld (debug_mark+1),a  
3b89 3a 93 3b			ld a, (.dmark+2)  
3b8c 32 9f fd			ld (debug_mark+2),a  
3b8f 18 03			jr .pastdmark  
3b91 ..			.dmark: db "REP"  
3b94 f1			.pastdmark: pop af  
3b95			endm  
# End of macro DMARK
3b95						;pop bc    ; TODO BUG ?????? what is this for???? 
3b95						CALLMONITOR 
3b95 cd aa fd			call debug_vector  
3b98				endm  
# End of macro CALLMONITOR
3b98					endif 
3b98			 
3b98					NEXTW 
3b98 cd a7 fd			call parse_vector 
3b9b c3 a8 23			jp macro_next 
3b9e				endm 
# End of macro NEXTW
3b9e			;	       NEXTW 
3b9e			 
3b9e			.UNTIL: 
3b9e				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3b9e 72				db WORD_SYS_CORE+94             
3b9f 3b 3c			dw .ENDFLOW            
3ba1 06				db 5 + 1 
3ba2 .. 00			db "UNTIL",0              
3ba8				endm 
# End of macro CWHEAD
3ba8			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3ba8			 
3ba8				; pop tos as check 
3ba8			 
3ba8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3ba8			 
3ba8				FORTH_DSP_VALUEHL 
3ba8 cd bd 21			call macro_dsp_valuehl 
3bab				endm 
# End of macro FORTH_DSP_VALUEHL
3bab			 
3bab					if DEBUG_FORTH_WORDS_KEY 
3bab						DMARK "UNT" 
3bab f5				push af  
3bac 3a c0 3b			ld a, (.dmark)  
3baf 32 9d fd			ld (debug_mark),a  
3bb2 3a c1 3b			ld a, (.dmark+1)  
3bb5 32 9e fd			ld (debug_mark+1),a  
3bb8 3a c2 3b			ld a, (.dmark+2)  
3bbb 32 9f fd			ld (debug_mark+2),a  
3bbe 18 03			jr .pastdmark  
3bc0 ..			.dmark: db "UNT"  
3bc3 f1			.pastdmark: pop af  
3bc4			endm  
# End of macro DMARK
3bc4						CALLMONITOR 
3bc4 cd aa fd			call debug_vector  
3bc7				endm  
# End of macro CALLMONITOR
3bc7					endif 
3bc7			 
3bc7			;	push hl 
3bc7				FORTH_DSP_POP 
3bc7 cd 75 22			call macro_forth_dsp_pop 
3bca				endm 
# End of macro FORTH_DSP_POP
3bca			 
3bca			;	pop hl 
3bca			 
3bca				; test if true 
3bca			 
3bca cd 07 10			call ishlzero 
3bcd			;	ld a,l 
3bcd			;	add h 
3bcd			; 
3bcd			;	cp 0 
3bcd			 
3bcd 20 41			jr nz, .untilnotdone 
3bcf			 
3bcf					if DEBUG_FORTH_WORDS 
3bcf						DMARK "UNf" 
3bcf f5				push af  
3bd0 3a e4 3b			ld a, (.dmark)  
3bd3 32 9d fd			ld (debug_mark),a  
3bd6 3a e5 3b			ld a, (.dmark+1)  
3bd9 32 9e fd			ld (debug_mark+1),a  
3bdc 3a e6 3b			ld a, (.dmark+2)  
3bdf 32 9f fd			ld (debug_mark+2),a  
3be2 18 03			jr .pastdmark  
3be4 ..			.dmark: db "UNf"  
3be7 f1			.pastdmark: pop af  
3be8			endm  
# End of macro DMARK
3be8						CALLMONITOR 
3be8 cd aa fd			call debug_vector  
3beb				endm  
# End of macro CALLMONITOR
3beb					endif 
3beb			 
3beb			 
3beb			 
3beb				FORTH_RSP_POP     ; get rid of DO ptr 
3beb cd 80 1f			call macro_forth_rsp_pop 
3bee				endm 
# End of macro FORTH_RSP_POP
3bee			 
3bee			if DEBUG_FORTH_WORDS 
3bee						DMARK "UN>" 
3bee f5				push af  
3bef 3a 03 3c			ld a, (.dmark)  
3bf2 32 9d fd			ld (debug_mark),a  
3bf5 3a 04 3c			ld a, (.dmark+1)  
3bf8 32 9e fd			ld (debug_mark+1),a  
3bfb 3a 05 3c			ld a, (.dmark+2)  
3bfe 32 9f fd			ld (debug_mark+2),a  
3c01 18 03			jr .pastdmark  
3c03 ..			.dmark: db "UN>"  
3c06 f1			.pastdmark: pop af  
3c07			endm  
# End of macro DMARK
3c07				CALLMONITOR 
3c07 cd aa fd			call debug_vector  
3c0a				endm  
# End of macro CALLMONITOR
3c0a			endif 
3c0a			 
3c0a					NEXTW 
3c0a cd a7 fd			call parse_vector 
3c0d c3 a8 23			jp macro_next 
3c10				endm 
# End of macro NEXTW
3c10				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3c10			 
3c10			.untilnotdone: 
3c10			 
3c10			 
3c10			;	; get DO ptr 
3c10			; 
3c10				FORTH_RSP_TOS 
3c10 cd 76 1f			call macro_forth_rsp_tos 
3c13				endm 
# End of macro FORTH_RSP_TOS
3c13			 
3c13				;push hl 
3c13			 
3c13				; not going to DO any more 
3c13				; get rid of the RSP pointer as DO will add it back in 
3c13				;FORTH_RSP_POP 
3c13				;pop hl 
3c13			 
3c13			 
3c13 22 f4 f3			ld (os_tok_ptr), hl 
3c16					if DEBUG_FORTH_WORDS 
3c16						DMARK "UN<" 
3c16 f5				push af  
3c17 3a 2b 3c			ld a, (.dmark)  
3c1a 32 9d fd			ld (debug_mark),a  
3c1d 3a 2c 3c			ld a, (.dmark+1)  
3c20 32 9e fd			ld (debug_mark+1),a  
3c23 3a 2d 3c			ld a, (.dmark+2)  
3c26 32 9f fd			ld (debug_mark+2),a  
3c29 18 03			jr .pastdmark  
3c2b ..			.dmark: db "UN<"  
3c2e f1			.pastdmark: pop af  
3c2f			endm  
# End of macro DMARK
3c2f					CALLMONITOR 
3c2f cd aa fd			call debug_vector  
3c32				endm  
# End of macro CALLMONITOR
3c32				endif 
3c32 c3 31 24			jp exec1 
3c35			 
3c35					 
3c35			 
3c35			 
3c35					NEXTW 
3c35 cd a7 fd			call parse_vector 
3c38 c3 a8 23			jp macro_next 
3c3b				endm 
# End of macro NEXTW
3c3b			 
3c3b			 
3c3b			.ENDFLOW: 
3c3b			 
3c3b			; eof 
3c3b			 
# End of file forth_words_flow.asm
3c3b			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3c3b			include "forth_words_logic.asm" 
3c3b			 
3c3b			; | ## Logic Words 
3c3b			 
3c3b			.NOT: 
3c3b				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3c3b 2d				db WORD_SYS_CORE+25             
3c3c 89 3c			dw .IS            
3c3e 04				db 3 + 1 
3c3f .. 00			db "NOT",0              
3c43				endm 
# End of macro CWHEAD
3c43			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3c43					if DEBUG_FORTH_WORDS_KEY 
3c43						DMARK "NOT" 
3c43 f5				push af  
3c44 3a 58 3c			ld a, (.dmark)  
3c47 32 9d fd			ld (debug_mark),a  
3c4a 3a 59 3c			ld a, (.dmark+1)  
3c4d 32 9e fd			ld (debug_mark+1),a  
3c50 3a 5a 3c			ld a, (.dmark+2)  
3c53 32 9f fd			ld (debug_mark+2),a  
3c56 18 03			jr .pastdmark  
3c58 ..			.dmark: db "NOT"  
3c5b f1			.pastdmark: pop af  
3c5c			endm  
# End of macro DMARK
3c5c						CALLMONITOR 
3c5c cd aa fd			call debug_vector  
3c5f				endm  
# End of macro CALLMONITOR
3c5f					endif 
3c5f					FORTH_DSP 
3c5f cd 83 21			call macro_forth_dsp 
3c62				endm 
# End of macro FORTH_DSP
3c62 7e					ld a,(hl)	; get type of value on TOS 
3c63 fe 02				cp DS_TYPE_INUM  
3c65 28 06				jr z, .noti 
3c67					NEXTW 
3c67 cd a7 fd			call parse_vector 
3c6a c3 a8 23			jp macro_next 
3c6d				endm 
# End of macro NEXTW
3c6d			.noti:          FORTH_DSP_VALUEHL 
3c6d cd bd 21			call macro_dsp_valuehl 
3c70				endm 
# End of macro FORTH_DSP_VALUEHL
3c70			;		push hl 
3c70					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c70 cd 75 22			call macro_forth_dsp_pop 
3c73				endm 
# End of macro FORTH_DSP_POP
3c73			;		pop hl 
3c73 3e 00				ld a,0 
3c75 bd					cp l 
3c76 28 04				jr z, .not2t 
3c78 2e 00				ld l, 0 
3c7a 18 02				jr .notip 
3c7c			 
3c7c 2e ff		.not2t:		ld l, 255 
3c7e			 
3c7e 26 00		.notip:		ld h, 0	 
3c80			 
3c80 cd b8 1f				call forth_push_numhl 
3c83					NEXTW 
3c83 cd a7 fd			call parse_vector 
3c86 c3 a8 23			jp macro_next 
3c89				endm 
# End of macro NEXTW
3c89			 
3c89			.IS: 
3c89				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
3c89 2d				db WORD_SYS_CORE+25             
3c8a cd 3c			dw .LZERO            
3c8c 08				db 7 + 1 
3c8d .. 00			db "COMPARE",0              
3c95				endm 
# End of macro CWHEAD
3c95			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
3c95					if DEBUG_FORTH_WORDS_KEY 
3c95						DMARK "CMP" 
3c95 f5				push af  
3c96 3a aa 3c			ld a, (.dmark)  
3c99 32 9d fd			ld (debug_mark),a  
3c9c 3a ab 3c			ld a, (.dmark+1)  
3c9f 32 9e fd			ld (debug_mark+1),a  
3ca2 3a ac 3c			ld a, (.dmark+2)  
3ca5 32 9f fd			ld (debug_mark+2),a  
3ca8 18 03			jr .pastdmark  
3caa ..			.dmark: db "CMP"  
3cad f1			.pastdmark: pop af  
3cae			endm  
# End of macro DMARK
3cae						CALLMONITOR 
3cae cd aa fd			call debug_vector  
3cb1				endm  
# End of macro CALLMONITOR
3cb1					endif 
3cb1			 
3cb1					FORTH_DSP_VALUEHL 
3cb1 cd bd 21			call macro_dsp_valuehl 
3cb4				endm 
# End of macro FORTH_DSP_VALUEHL
3cb4			 
3cb4 e5					push hl 
3cb5			 
3cb5					FORTH_DSP_VALUEM1 
3cb5 cd b1 21			call macro_forth_dsp_value_m1 
3cb8				endm 
# End of macro FORTH_DSP_VALUEM1
3cb8			 
3cb8 d1					pop de 
3cb9			 
3cb9					; got pointers to both. Now check. 
3cb9			 
3cb9 cd 7c 13				call strcmp 
3cbc				 
3cbc 26 00				ld h, 0 
3cbe 2e 00				ld l, 0 
3cc0 20 02				jr nz, .compnsame 
3cc2 2e 01				ld l, 1	 
3cc4			.compnsame: 
3cc4 cd b8 1f				call forth_push_numhl 
3cc7			 
3cc7					NEXTW 
3cc7 cd a7 fd			call parse_vector 
3cca c3 a8 23			jp macro_next 
3ccd				endm 
# End of macro NEXTW
3ccd			.LZERO: 
3ccd				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3ccd 2d				db WORD_SYS_CORE+25             
3cce da 3c			dw .TZERO            
3cd0 03				db 2 + 1 
3cd1 .. 00			db "0<",0              
3cd4				endm 
# End of macro CWHEAD
3cd4			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3cd4					NEXTW 
3cd4 cd a7 fd			call parse_vector 
3cd7 c3 a8 23			jp macro_next 
3cda				endm 
# End of macro NEXTW
3cda			.TZERO: 
3cda				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3cda 2e				db WORD_SYS_CORE+26             
3cdb 24 3d			dw .LESS            
3cdd 03				db 2 + 1 
3cde .. 00			db "0=",0              
3ce1				endm 
# End of macro CWHEAD
3ce1			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3ce1				; TODO add floating point number detection 
3ce1					;v5 FORTH_DSP_VALUE 
3ce1					if DEBUG_FORTH_WORDS_KEY 
3ce1						DMARK "0=." 
3ce1 f5				push af  
3ce2 3a f6 3c			ld a, (.dmark)  
3ce5 32 9d fd			ld (debug_mark),a  
3ce8 3a f7 3c			ld a, (.dmark+1)  
3ceb 32 9e fd			ld (debug_mark+1),a  
3cee 3a f8 3c			ld a, (.dmark+2)  
3cf1 32 9f fd			ld (debug_mark+2),a  
3cf4 18 03			jr .pastdmark  
3cf6 ..			.dmark: db "0=."  
3cf9 f1			.pastdmark: pop af  
3cfa			endm  
# End of macro DMARK
3cfa						CALLMONITOR 
3cfa cd aa fd			call debug_vector  
3cfd				endm  
# End of macro CALLMONITOR
3cfd					endif 
3cfd					FORTH_DSP 
3cfd cd 83 21			call macro_forth_dsp 
3d00				endm 
# End of macro FORTH_DSP
3d00 7e					ld a,(hl)	; get type of value on TOS 
3d01 fe 02				cp DS_TYPE_INUM  
3d03 28 00				jr z, .tz_inum 
3d05			 
3d05				if FORTH_ENABLE_FLOATMATH 
3d05					jr .tz_done 
3d05			 
3d05				endif 
3d05					 
3d05			 
3d05			.tz_inum: 
3d05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d05 cd bd 21			call macro_dsp_valuehl 
3d08				endm 
# End of macro FORTH_DSP_VALUEHL
3d08			 
3d08			;		push hl 
3d08			 
3d08					; destroy value TOS 
3d08			 
3d08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d08 cd 75 22			call macro_forth_dsp_pop 
3d0b				endm 
# End of macro FORTH_DSP_POP
3d0b			 
3d0b			;		pop hl 
3d0b			 
3d0b 3e 00				ld a,0 
3d0d			 
3d0d bd					cp l 
3d0e 20 08				jr nz, .tz_notzero 
3d10			 
3d10 bc					cp h 
3d11			 
3d11 20 05				jr nz, .tz_notzero 
3d13			 
3d13			 
3d13 21 01 00				ld hl, FORTH_TRUE 
3d16 18 03				jr .tz_done 
3d18			 
3d18 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3d1b			 
3d1b					; push value back onto stack for another op etc 
3d1b			 
3d1b			.tz_done: 
3d1b cd b8 1f				call forth_push_numhl 
3d1e			 
3d1e					NEXTW 
3d1e cd a7 fd			call parse_vector 
3d21 c3 a8 23			jp macro_next 
3d24				endm 
# End of macro NEXTW
3d24			.LESS: 
3d24				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3d24 2f				db WORD_SYS_CORE+27             
3d25 90 3d			dw .GT            
3d27 02				db 1 + 1 
3d28 .. 00			db "<",0              
3d2a				endm 
# End of macro CWHEAD
3d2a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3d2a				; TODO add floating point number detection 
3d2a					if DEBUG_FORTH_WORDS_KEY 
3d2a						DMARK "LES" 
3d2a f5				push af  
3d2b 3a 3f 3d			ld a, (.dmark)  
3d2e 32 9d fd			ld (debug_mark),a  
3d31 3a 40 3d			ld a, (.dmark+1)  
3d34 32 9e fd			ld (debug_mark+1),a  
3d37 3a 41 3d			ld a, (.dmark+2)  
3d3a 32 9f fd			ld (debug_mark+2),a  
3d3d 18 03			jr .pastdmark  
3d3f ..			.dmark: db "LES"  
3d42 f1			.pastdmark: pop af  
3d43			endm  
# End of macro DMARK
3d43						CALLMONITOR 
3d43 cd aa fd			call debug_vector  
3d46				endm  
# End of macro CALLMONITOR
3d46					endif 
3d46					FORTH_DSP 
3d46 cd 83 21			call macro_forth_dsp 
3d49				endm 
# End of macro FORTH_DSP
3d49					;v5 FORTH_DSP_VALUE 
3d49 7e					ld a,(hl)	; get type of value on TOS 
3d4a fe 02				cp DS_TYPE_INUM  
3d4c 28 00				jr z, .less_inum 
3d4e			 
3d4e				if FORTH_ENABLE_FLOATMATH 
3d4e					jr .less_done 
3d4e			 
3d4e				endif 
3d4e					 
3d4e			 
3d4e			.less_inum: 
3d4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d4e cd bd 21			call macro_dsp_valuehl 
3d51				endm 
# End of macro FORTH_DSP_VALUEHL
3d51			 
3d51 e5					push hl  ; u2 
3d52			 
3d52					; destroy value TOS 
3d52			 
3d52					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d52 cd 75 22			call macro_forth_dsp_pop 
3d55				endm 
# End of macro FORTH_DSP_POP
3d55			 
3d55			 
3d55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d55 cd bd 21			call macro_dsp_valuehl 
3d58				endm 
# End of macro FORTH_DSP_VALUEHL
3d58			 
3d58 e5					push hl    ; u1 
3d59			 
3d59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d59 cd 75 22			call macro_forth_dsp_pop 
3d5c				endm 
# End of macro FORTH_DSP_POP
3d5c			 
3d5c			 
3d5c b7			 or a      ;clear carry flag 
3d5d 01 00 00		 ld bc, FORTH_FALSE 
3d60 e1			  pop hl    ; u1 
3d61 d1			  pop de    ; u2 
3d62 ed 52		  sbc hl,de 
3d64 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3d66			 
3d66 01 01 00		 ld bc, FORTH_TRUE 
3d69			.lscont:  
3d69 c5					push bc 
3d6a e1					pop hl 
3d6b			 
3d6b					if DEBUG_FORTH_WORDS 
3d6b						DMARK "LT1" 
3d6b f5				push af  
3d6c 3a 80 3d			ld a, (.dmark)  
3d6f 32 9d fd			ld (debug_mark),a  
3d72 3a 81 3d			ld a, (.dmark+1)  
3d75 32 9e fd			ld (debug_mark+1),a  
3d78 3a 82 3d			ld a, (.dmark+2)  
3d7b 32 9f fd			ld (debug_mark+2),a  
3d7e 18 03			jr .pastdmark  
3d80 ..			.dmark: db "LT1"  
3d83 f1			.pastdmark: pop af  
3d84			endm  
# End of macro DMARK
3d84						CALLMONITOR 
3d84 cd aa fd			call debug_vector  
3d87				endm  
# End of macro CALLMONITOR
3d87					endif 
3d87 cd b8 1f				call forth_push_numhl 
3d8a			 
3d8a					NEXTW 
3d8a cd a7 fd			call parse_vector 
3d8d c3 a8 23			jp macro_next 
3d90				endm 
# End of macro NEXTW
3d90			.GT: 
3d90				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3d90 30				db WORD_SYS_CORE+28             
3d91 fc 3d			dw .EQUAL            
3d93 02				db 1 + 1 
3d94 .. 00			db ">",0              
3d96				endm 
# End of macro CWHEAD
3d96			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3d96				; TODO add floating point number detection 
3d96					if DEBUG_FORTH_WORDS_KEY 
3d96						DMARK "GRT" 
3d96 f5				push af  
3d97 3a ab 3d			ld a, (.dmark)  
3d9a 32 9d fd			ld (debug_mark),a  
3d9d 3a ac 3d			ld a, (.dmark+1)  
3da0 32 9e fd			ld (debug_mark+1),a  
3da3 3a ad 3d			ld a, (.dmark+2)  
3da6 32 9f fd			ld (debug_mark+2),a  
3da9 18 03			jr .pastdmark  
3dab ..			.dmark: db "GRT"  
3dae f1			.pastdmark: pop af  
3daf			endm  
# End of macro DMARK
3daf						CALLMONITOR 
3daf cd aa fd			call debug_vector  
3db2				endm  
# End of macro CALLMONITOR
3db2					endif 
3db2					FORTH_DSP 
3db2 cd 83 21			call macro_forth_dsp 
3db5				endm 
# End of macro FORTH_DSP
3db5					;FORTH_DSP_VALUE 
3db5 7e					ld a,(hl)	; get type of value on TOS 
3db6 fe 02				cp DS_TYPE_INUM  
3db8 28 00				jr z, .gt_inum 
3dba			 
3dba				if FORTH_ENABLE_FLOATMATH 
3dba					jr .gt_done 
3dba			 
3dba				endif 
3dba					 
3dba			 
3dba			.gt_inum: 
3dba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dba cd bd 21			call macro_dsp_valuehl 
3dbd				endm 
# End of macro FORTH_DSP_VALUEHL
3dbd			 
3dbd e5					push hl  ; u2 
3dbe			 
3dbe					; destroy value TOS 
3dbe			 
3dbe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dbe cd 75 22			call macro_forth_dsp_pop 
3dc1				endm 
# End of macro FORTH_DSP_POP
3dc1			 
3dc1			 
3dc1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dc1 cd bd 21			call macro_dsp_valuehl 
3dc4				endm 
# End of macro FORTH_DSP_VALUEHL
3dc4			 
3dc4 e5					push hl    ; u1 
3dc5			 
3dc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dc5 cd 75 22			call macro_forth_dsp_pop 
3dc8				endm 
# End of macro FORTH_DSP_POP
3dc8			 
3dc8			 
3dc8 b7			 or a      ;clear carry flag 
3dc9 01 00 00		 ld bc, FORTH_FALSE 
3dcc e1			  pop hl    ; u1 
3dcd d1			  pop de    ; u2 
3dce ed 52		  sbc hl,de 
3dd0 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3dd2			 
3dd2 01 01 00		 ld bc, FORTH_TRUE 
3dd5			.gtcont:  
3dd5 c5					push bc 
3dd6 e1					pop hl 
3dd7			 
3dd7					if DEBUG_FORTH_WORDS 
3dd7						DMARK "GT1" 
3dd7 f5				push af  
3dd8 3a ec 3d			ld a, (.dmark)  
3ddb 32 9d fd			ld (debug_mark),a  
3dde 3a ed 3d			ld a, (.dmark+1)  
3de1 32 9e fd			ld (debug_mark+1),a  
3de4 3a ee 3d			ld a, (.dmark+2)  
3de7 32 9f fd			ld (debug_mark+2),a  
3dea 18 03			jr .pastdmark  
3dec ..			.dmark: db "GT1"  
3def f1			.pastdmark: pop af  
3df0			endm  
# End of macro DMARK
3df0						CALLMONITOR 
3df0 cd aa fd			call debug_vector  
3df3				endm  
# End of macro CALLMONITOR
3df3					endif 
3df3 cd b8 1f				call forth_push_numhl 
3df6			 
3df6					NEXTW 
3df6 cd a7 fd			call parse_vector 
3df9 c3 a8 23			jp macro_next 
3dfc				endm 
# End of macro NEXTW
3dfc			.EQUAL: 
3dfc				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3dfc 31				db WORD_SYS_CORE+29             
3dfd 6a 3e			dw .ENDLOGIC            
3dff 02				db 1 + 1 
3e00 .. 00			db "=",0              
3e02				endm 
# End of macro CWHEAD
3e02			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3e02				; TODO add floating point number detection 
3e02					if DEBUG_FORTH_WORDS_KEY 
3e02						DMARK "EQ." 
3e02 f5				push af  
3e03 3a 17 3e			ld a, (.dmark)  
3e06 32 9d fd			ld (debug_mark),a  
3e09 3a 18 3e			ld a, (.dmark+1)  
3e0c 32 9e fd			ld (debug_mark+1),a  
3e0f 3a 19 3e			ld a, (.dmark+2)  
3e12 32 9f fd			ld (debug_mark+2),a  
3e15 18 03			jr .pastdmark  
3e17 ..			.dmark: db "EQ."  
3e1a f1			.pastdmark: pop af  
3e1b			endm  
# End of macro DMARK
3e1b						CALLMONITOR 
3e1b cd aa fd			call debug_vector  
3e1e				endm  
# End of macro CALLMONITOR
3e1e					endif 
3e1e					FORTH_DSP 
3e1e cd 83 21			call macro_forth_dsp 
3e21				endm 
# End of macro FORTH_DSP
3e21					;v5 FORTH_DSP_VALUE 
3e21 7e					ld a,(hl)	; get type of value on TOS 
3e22 fe 02				cp DS_TYPE_INUM  
3e24 28 00				jr z, .eq_inum 
3e26			 
3e26				if FORTH_ENABLE_FLOATMATH 
3e26					jr .eq_done 
3e26			 
3e26				endif 
3e26					 
3e26			 
3e26			.eq_inum: 
3e26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e26 cd bd 21			call macro_dsp_valuehl 
3e29				endm 
# End of macro FORTH_DSP_VALUEHL
3e29			 
3e29 e5					push hl 
3e2a			 
3e2a					; destroy value TOS 
3e2a			 
3e2a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e2a cd 75 22			call macro_forth_dsp_pop 
3e2d				endm 
# End of macro FORTH_DSP_POP
3e2d			 
3e2d			 
3e2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e2d cd bd 21			call macro_dsp_valuehl 
3e30				endm 
# End of macro FORTH_DSP_VALUEHL
3e30			 
3e30					; one value on hl get other one back 
3e30			 
3e30 e5					push hl 
3e31			 
3e31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e31 cd 75 22			call macro_forth_dsp_pop 
3e34				endm 
# End of macro FORTH_DSP_POP
3e34			 
3e34 0e 00				ld c, FORTH_FALSE 
3e36			 
3e36 e1					pop hl 
3e37 d1					pop de 
3e38			 
3e38 7b					ld a, e 
3e39 bd					cp l 
3e3a			 
3e3a 20 06				jr nz, .eq_done 
3e3c			 
3e3c 7a					ld a, d 
3e3d bc					cp h 
3e3e			 
3e3e 20 02				jr nz, .eq_done 
3e40			 
3e40 0e 01				ld c, FORTH_TRUE 
3e42					 
3e42			 
3e42			 
3e42			.eq_done: 
3e42			 
3e42					; TODO push value back onto stack for another op etc 
3e42			 
3e42 26 00				ld h, 0 
3e44 69					ld l, c 
3e45					if DEBUG_FORTH_WORDS 
3e45						DMARK "EQ1" 
3e45 f5				push af  
3e46 3a 5a 3e			ld a, (.dmark)  
3e49 32 9d fd			ld (debug_mark),a  
3e4c 3a 5b 3e			ld a, (.dmark+1)  
3e4f 32 9e fd			ld (debug_mark+1),a  
3e52 3a 5c 3e			ld a, (.dmark+2)  
3e55 32 9f fd			ld (debug_mark+2),a  
3e58 18 03			jr .pastdmark  
3e5a ..			.dmark: db "EQ1"  
3e5d f1			.pastdmark: pop af  
3e5e			endm  
# End of macro DMARK
3e5e						CALLMONITOR 
3e5e cd aa fd			call debug_vector  
3e61				endm  
# End of macro CALLMONITOR
3e61					endif 
3e61 cd b8 1f				call forth_push_numhl 
3e64			 
3e64					NEXTW 
3e64 cd a7 fd			call parse_vector 
3e67 c3 a8 23			jp macro_next 
3e6a				endm 
# End of macro NEXTW
3e6a			 
3e6a			 
3e6a			.ENDLOGIC: 
3e6a			; eof 
3e6a			 
3e6a			 
# End of file forth_words_logic.asm
3e6a			include "forth_words_maths.asm" 
3e6a			 
3e6a			; | ## Maths Words 
3e6a			 
3e6a			.PLUS:	 
3e6a				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3e6a 15				db WORD_SYS_CORE+1             
3e6b ce 3e			dw .NEG            
3e6d 02				db 1 + 1 
3e6e .. 00			db "+",0              
3e70				endm 
# End of macro CWHEAD
3e70			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3e70					if DEBUG_FORTH_WORDS_KEY 
3e70						DMARK "PLU" 
3e70 f5				push af  
3e71 3a 85 3e			ld a, (.dmark)  
3e74 32 9d fd			ld (debug_mark),a  
3e77 3a 86 3e			ld a, (.dmark+1)  
3e7a 32 9e fd			ld (debug_mark+1),a  
3e7d 3a 87 3e			ld a, (.dmark+2)  
3e80 32 9f fd			ld (debug_mark+2),a  
3e83 18 03			jr .pastdmark  
3e85 ..			.dmark: db "PLU"  
3e88 f1			.pastdmark: pop af  
3e89			endm  
# End of macro DMARK
3e89						CALLMONITOR 
3e89 cd aa fd			call debug_vector  
3e8c				endm  
# End of macro CALLMONITOR
3e8c					endif 
3e8c					; add top two values and push back result 
3e8c			 
3e8c					;for v5 FORTH_DSP_VALUE 
3e8c					FORTH_DSP 
3e8c cd 83 21			call macro_forth_dsp 
3e8f				endm 
# End of macro FORTH_DSP
3e8f 7e					ld a,(hl)	; get type of value on TOS 
3e90 fe 02				cp DS_TYPE_INUM  
3e92 28 06				jr z, .dot_inum 
3e94			 
3e94					NEXTW 
3e94 cd a7 fd			call parse_vector 
3e97 c3 a8 23			jp macro_next 
3e9a				endm 
# End of macro NEXTW
3e9a			 
3e9a			; float maths 
3e9a			 
3e9a				if FORTH_ENABLE_FLOATMATH 
3e9a						inc hl      ; now at start of numeric as string 
3e9a			 
3e9a					if DEBUG_FORTH_MATHS 
3e9a						DMARK "ADD" 
3e9a				CALLMONITOR 
3e9a					endif 
3e9a			 
3e9a					;ld ix, hl 
3e9a					call CON 
3e9a			 
3e9a			 
3e9a					push hl 
3e9a					 
3e9a					 
3e9a			 
3e9a						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3e9a			 
3e9a					; get next number 
3e9a			 
3e9a						FORTH_DSP_VALUE 
3e9a			 
3e9a						inc hl      ; now at start of numeric as string 
3e9a			 
3e9a					;ld ix, hl 
3e9a					call CON 
3e9a			 
3e9a					push hl 
3e9a			 
3e9a			 
3e9a						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9a			 
3e9a						; TODO do add 
3e9a			 
3e9a						call IADD 
3e9a			 
3e9a						; TODO get result back as ascii 
3e9a			 
3e9a						; TODO push result  
3e9a			 
3e9a			 
3e9a			 
3e9a						jr .dot_done 
3e9a				endif 
3e9a			 
3e9a			.dot_inum: 
3e9a			 
3e9a			 
3e9a					if DEBUG_FORTH_DOT 
3e9a						DMARK "+IT" 
3e9a f5				push af  
3e9b 3a af 3e			ld a, (.dmark)  
3e9e 32 9d fd			ld (debug_mark),a  
3ea1 3a b0 3e			ld a, (.dmark+1)  
3ea4 32 9e fd			ld (debug_mark+1),a  
3ea7 3a b1 3e			ld a, (.dmark+2)  
3eaa 32 9f fd			ld (debug_mark+2),a  
3ead 18 03			jr .pastdmark  
3eaf ..			.dmark: db "+IT"  
3eb2 f1			.pastdmark: pop af  
3eb3			endm  
# End of macro DMARK
3eb3				CALLMONITOR 
3eb3 cd aa fd			call debug_vector  
3eb6				endm  
# End of macro CALLMONITOR
3eb6					endif 
3eb6			 
3eb6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eb6 cd bd 21			call macro_dsp_valuehl 
3eb9				endm 
# End of macro FORTH_DSP_VALUEHL
3eb9			 
3eb9				; TODO add floating point number detection 
3eb9			 
3eb9 e5					push hl 
3eba			 
3eba					; destroy value TOS 
3eba			 
3eba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eba cd 75 22			call macro_forth_dsp_pop 
3ebd				endm 
# End of macro FORTH_DSP_POP
3ebd			 
3ebd			 
3ebd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ebd cd bd 21			call macro_dsp_valuehl 
3ec0				endm 
# End of macro FORTH_DSP_VALUEHL
3ec0			 
3ec0					; one value on hl get other one back 
3ec0			 
3ec0 d1					pop de 
3ec1			 
3ec1					; do the add 
3ec1			 
3ec1 19					add hl,de 
3ec2			 
3ec2					; save it 
3ec2			 
3ec2			;		push hl	 
3ec2			 
3ec2					; 
3ec2			 
3ec2					; destroy value TOS 
3ec2			 
3ec2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ec2 cd 75 22			call macro_forth_dsp_pop 
3ec5				endm 
# End of macro FORTH_DSP_POP
3ec5			 
3ec5					; TODO push value back onto stack for another op etc 
3ec5			 
3ec5			;		pop hl 
3ec5			 
3ec5			.dot_done: 
3ec5 cd b8 1f				call forth_push_numhl 
3ec8			 
3ec8					NEXTW 
3ec8 cd a7 fd			call parse_vector 
3ecb c3 a8 23			jp macro_next 
3ece				endm 
# End of macro NEXTW
3ece			.NEG: 
3ece			 
3ece				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3ece 17				db WORD_SYS_CORE+3             
3ecf 17 3f			dw .DIV            
3ed1 02				db 1 + 1 
3ed2 .. 00			db "-",0              
3ed4				endm 
# End of macro CWHEAD
3ed4			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3ed4					if DEBUG_FORTH_WORDS_KEY 
3ed4						DMARK "SUB" 
3ed4 f5				push af  
3ed5 3a e9 3e			ld a, (.dmark)  
3ed8 32 9d fd			ld (debug_mark),a  
3edb 3a ea 3e			ld a, (.dmark+1)  
3ede 32 9e fd			ld (debug_mark+1),a  
3ee1 3a eb 3e			ld a, (.dmark+2)  
3ee4 32 9f fd			ld (debug_mark+2),a  
3ee7 18 03			jr .pastdmark  
3ee9 ..			.dmark: db "SUB"  
3eec f1			.pastdmark: pop af  
3eed			endm  
# End of macro DMARK
3eed						CALLMONITOR 
3eed cd aa fd			call debug_vector  
3ef0				endm  
# End of macro CALLMONITOR
3ef0					endif 
3ef0			 
3ef0			 
3ef0				; TODO add floating point number detection 
3ef0					; v5 FORTH_DSP_VALUE 
3ef0					FORTH_DSP 
3ef0 cd 83 21			call macro_forth_dsp 
3ef3				endm 
# End of macro FORTH_DSP
3ef3 7e					ld a,(hl)	; get type of value on TOS 
3ef4 fe 02				cp DS_TYPE_INUM  
3ef6 28 06				jr z, .neg_inum 
3ef8			 
3ef8					NEXTW 
3ef8 cd a7 fd			call parse_vector 
3efb c3 a8 23			jp macro_next 
3efe				endm 
# End of macro NEXTW
3efe			 
3efe			; float maths 
3efe			 
3efe				if FORTH_ENABLE_FLOATMATH 
3efe					jr .neg_done 
3efe			 
3efe				endif 
3efe					 
3efe			 
3efe			.neg_inum: 
3efe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3efe cd bd 21			call macro_dsp_valuehl 
3f01				endm 
# End of macro FORTH_DSP_VALUEHL
3f01			 
3f01 e5					push hl 
3f02			 
3f02					; destroy value TOS 
3f02			 
3f02					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f02 cd 75 22			call macro_forth_dsp_pop 
3f05				endm 
# End of macro FORTH_DSP_POP
3f05			 
3f05			 
3f05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f05 cd bd 21			call macro_dsp_valuehl 
3f08				endm 
# End of macro FORTH_DSP_VALUEHL
3f08			 
3f08					; one value on hl get other one back 
3f08			 
3f08 d1					pop de 
3f09			 
3f09					; do the sub 
3f09			;		ex de, hl 
3f09			 
3f09 ed 52				sbc hl,de 
3f0b			 
3f0b					; save it 
3f0b			 
3f0b			;		push hl	 
3f0b			 
3f0b					; 
3f0b			 
3f0b					; destroy value TOS 
3f0b			 
3f0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f0b cd 75 22			call macro_forth_dsp_pop 
3f0e				endm 
# End of macro FORTH_DSP_POP
3f0e			 
3f0e					; TODO push value back onto stack for another op etc 
3f0e			 
3f0e			;		pop hl 
3f0e			 
3f0e cd b8 1f				call forth_push_numhl 
3f11			.neg_done: 
3f11			 
3f11					NEXTW 
3f11 cd a7 fd			call parse_vector 
3f14 c3 a8 23			jp macro_next 
3f17				endm 
# End of macro NEXTW
3f17			.DIV: 
3f17				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3f17 18				db WORD_SYS_CORE+4             
3f18 6a 3f			dw .MUL            
3f1a 02				db 1 + 1 
3f1b .. 00			db "/",0              
3f1d				endm 
# End of macro CWHEAD
3f1d			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3f1d					if DEBUG_FORTH_WORDS_KEY 
3f1d						DMARK "DIV" 
3f1d f5				push af  
3f1e 3a 32 3f			ld a, (.dmark)  
3f21 32 9d fd			ld (debug_mark),a  
3f24 3a 33 3f			ld a, (.dmark+1)  
3f27 32 9e fd			ld (debug_mark+1),a  
3f2a 3a 34 3f			ld a, (.dmark+2)  
3f2d 32 9f fd			ld (debug_mark+2),a  
3f30 18 03			jr .pastdmark  
3f32 ..			.dmark: db "DIV"  
3f35 f1			.pastdmark: pop af  
3f36			endm  
# End of macro DMARK
3f36						CALLMONITOR 
3f36 cd aa fd			call debug_vector  
3f39				endm  
# End of macro CALLMONITOR
3f39					endif 
3f39				; TODO add floating point number detection 
3f39					; v5 FORTH_DSP_VALUE 
3f39					FORTH_DSP 
3f39 cd 83 21			call macro_forth_dsp 
3f3c				endm 
# End of macro FORTH_DSP
3f3c 7e					ld a,(hl)	; get type of value on TOS 
3f3d fe 02				cp DS_TYPE_INUM  
3f3f 28 06				jr z, .div_inum 
3f41			 
3f41				if FORTH_ENABLE_FLOATMATH 
3f41					jr .div_done 
3f41			 
3f41				endif 
3f41					NEXTW 
3f41 cd a7 fd			call parse_vector 
3f44 c3 a8 23			jp macro_next 
3f47				endm 
# End of macro NEXTW
3f47			.div_inum: 
3f47			 
3f47					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f47 cd bd 21			call macro_dsp_valuehl 
3f4a				endm 
# End of macro FORTH_DSP_VALUEHL
3f4a			 
3f4a e5					push hl    ; to go to bc 
3f4b			 
3f4b					; destroy value TOS 
3f4b			 
3f4b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f4b cd 75 22			call macro_forth_dsp_pop 
3f4e				endm 
# End of macro FORTH_DSP_POP
3f4e			 
3f4e			 
3f4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f4e cd bd 21			call macro_dsp_valuehl 
3f51				endm 
# End of macro FORTH_DSP_VALUEHL
3f51			 
3f51					; hl to go to de 
3f51			 
3f51 e5					push hl 
3f52			 
3f52 c1					pop bc 
3f53 d1					pop de		 
3f54			 
3f54			 
3f54					if DEBUG_FORTH_MATHS 
3f54						DMARK "DIV" 
3f54				CALLMONITOR 
3f54					endif 
3f54					; one value on hl but move to a get other one back 
3f54			 
3f54			        
3f54 cd 3b 0f			call Div16 
3f57			 
3f57			;	push af	 
3f57 e5				push hl 
3f58 c5				push bc 
3f59			 
3f59					if DEBUG_FORTH_MATHS 
3f59						DMARK "DI1" 
3f59				CALLMONITOR 
3f59					endif 
3f59			 
3f59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f59 cd 75 22			call macro_forth_dsp_pop 
3f5c				endm 
# End of macro FORTH_DSP_POP
3f5c			 
3f5c			 
3f5c			 
3f5c e1					pop hl    ; result 
3f5d			 
3f5d cd b8 1f				call forth_push_numhl 
3f60			 
3f60 e1					pop hl    ; reminder 
3f61			;		ld h,0 
3f61			;		ld l,d 
3f61			 
3f61 cd b8 1f				call forth_push_numhl 
3f64			.div_done: 
3f64					NEXTW 
3f64 cd a7 fd			call parse_vector 
3f67 c3 a8 23			jp macro_next 
3f6a				endm 
# End of macro NEXTW
3f6a			.MUL: 
3f6a				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3f6a 19				db WORD_SYS_CORE+5             
3f6b b5 3f			dw .MIN            
3f6d 02				db 1 + 1 
3f6e .. 00			db "*",0              
3f70				endm 
# End of macro CWHEAD
3f70			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3f70				; TODO add floating point number detection 
3f70					if DEBUG_FORTH_WORDS_KEY 
3f70						DMARK "MUL" 
3f70 f5				push af  
3f71 3a 85 3f			ld a, (.dmark)  
3f74 32 9d fd			ld (debug_mark),a  
3f77 3a 86 3f			ld a, (.dmark+1)  
3f7a 32 9e fd			ld (debug_mark+1),a  
3f7d 3a 87 3f			ld a, (.dmark+2)  
3f80 32 9f fd			ld (debug_mark+2),a  
3f83 18 03			jr .pastdmark  
3f85 ..			.dmark: db "MUL"  
3f88 f1			.pastdmark: pop af  
3f89			endm  
# End of macro DMARK
3f89						CALLMONITOR 
3f89 cd aa fd			call debug_vector  
3f8c				endm  
# End of macro CALLMONITOR
3f8c					endif 
3f8c					FORTH_DSP 
3f8c cd 83 21			call macro_forth_dsp 
3f8f				endm 
# End of macro FORTH_DSP
3f8f					; v5 FORTH_DSP_VALUE 
3f8f 7e					ld a,(hl)	; get type of value on TOS 
3f90 fe 02				cp DS_TYPE_INUM  
3f92 28 06				jr z, .mul_inum 
3f94			 
3f94				if FORTH_ENABLE_FLOATMATH 
3f94					jr .mul_done 
3f94			 
3f94				endif 
3f94			 
3f94					NEXTW 
3f94 cd a7 fd			call parse_vector 
3f97 c3 a8 23			jp macro_next 
3f9a				endm 
# End of macro NEXTW
3f9a			.mul_inum:	 
3f9a			 
3f9a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f9a cd bd 21			call macro_dsp_valuehl 
3f9d				endm 
# End of macro FORTH_DSP_VALUEHL
3f9d			 
3f9d e5					push hl 
3f9e			 
3f9e					; destroy value TOS 
3f9e			 
3f9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f9e cd 75 22			call macro_forth_dsp_pop 
3fa1				endm 
# End of macro FORTH_DSP_POP
3fa1			 
3fa1			 
3fa1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa1 cd bd 21			call macro_dsp_valuehl 
3fa4				endm 
# End of macro FORTH_DSP_VALUEHL
3fa4			 
3fa4					; one value on hl but move to a get other one back 
3fa4			 
3fa4 7d					ld a, l 
3fa5			 
3fa5 d1					pop de 
3fa6			 
3fa6					; do the mull 
3fa6			;		ex de, hl 
3fa6			 
3fa6 cd 61 0f				call Mult16 
3fa9					; save it 
3fa9			 
3fa9			;		push hl	 
3fa9			 
3fa9					; 
3fa9			 
3fa9					; destroy value TOS 
3fa9			 
3fa9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fa9 cd 75 22			call macro_forth_dsp_pop 
3fac				endm 
# End of macro FORTH_DSP_POP
3fac			 
3fac					; TODO push value back onto stack for another op etc 
3fac			 
3fac			;		pop hl 
3fac			 
3fac cd b8 1f				call forth_push_numhl 
3faf			 
3faf			.mul_done: 
3faf					NEXTW 
3faf cd a7 fd			call parse_vector 
3fb2 c3 a8 23			jp macro_next 
3fb5				endm 
# End of macro NEXTW
3fb5			 
3fb5			 
3fb5			 
3fb5			 
3fb5			.MIN: 
3fb5				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3fb5 49				db WORD_SYS_CORE+53             
3fb6 3c 40			dw .MAX            
3fb8 04				db 3 + 1 
3fb9 .. 00			db "MIN",0              
3fbd				endm 
# End of macro CWHEAD
3fbd			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3fbd					if DEBUG_FORTH_WORDS_KEY 
3fbd						DMARK "MIN" 
3fbd f5				push af  
3fbe 3a d2 3f			ld a, (.dmark)  
3fc1 32 9d fd			ld (debug_mark),a  
3fc4 3a d3 3f			ld a, (.dmark+1)  
3fc7 32 9e fd			ld (debug_mark+1),a  
3fca 3a d4 3f			ld a, (.dmark+2)  
3fcd 32 9f fd			ld (debug_mark+2),a  
3fd0 18 03			jr .pastdmark  
3fd2 ..			.dmark: db "MIN"  
3fd5 f1			.pastdmark: pop af  
3fd6			endm  
# End of macro DMARK
3fd6						CALLMONITOR 
3fd6 cd aa fd			call debug_vector  
3fd9				endm  
# End of macro CALLMONITOR
3fd9					endif 
3fd9					; get u2 
3fd9			 
3fd9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fd9 cd bd 21			call macro_dsp_valuehl 
3fdc				endm 
# End of macro FORTH_DSP_VALUEHL
3fdc			 
3fdc e5					push hl   ; u2 
3fdd			 
3fdd					; destroy value TOS 
3fdd			 
3fdd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fdd cd 75 22			call macro_forth_dsp_pop 
3fe0				endm 
# End of macro FORTH_DSP_POP
3fe0			 
3fe0					; get u1 
3fe0			 
3fe0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fe0 cd bd 21			call macro_dsp_valuehl 
3fe3				endm 
# End of macro FORTH_DSP_VALUEHL
3fe3			 
3fe3 e5					push hl  ; u1 
3fe4			 
3fe4					; destroy value TOS 
3fe4			 
3fe4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fe4 cd 75 22			call macro_forth_dsp_pop 
3fe7				endm 
# End of macro FORTH_DSP_POP
3fe7			 
3fe7 b7			 or a      ;clear carry flag 
3fe8 e1			  pop hl    ; u1 
3fe9 d1			  pop de    ; u2 
3fea e5				push hl   ; saved in case hl is lowest 
3feb ed 52		  sbc hl,de 
3fed 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3fef			 
3fef e1				pop hl 
3ff0					if DEBUG_FORTH_WORDS 
3ff0						DMARK "MIN" 
3ff0 f5				push af  
3ff1 3a 05 40			ld a, (.dmark)  
3ff4 32 9d fd			ld (debug_mark),a  
3ff7 3a 06 40			ld a, (.dmark+1)  
3ffa 32 9e fd			ld (debug_mark+1),a  
3ffd 3a 07 40			ld a, (.dmark+2)  
4000 32 9f fd			ld (debug_mark+2),a  
4003 18 03			jr .pastdmark  
4005 ..			.dmark: db "MIN"  
4008 f1			.pastdmark: pop af  
4009			endm  
# End of macro DMARK
4009						CALLMONITOR 
4009 cd aa fd			call debug_vector  
400c				endm  
# End of macro CALLMONITOR
400c					endif 
400c cd b8 1f				call forth_push_numhl 
400f			 
400f				       NEXTW 
400f cd a7 fd			call parse_vector 
4012 c3 a8 23			jp macro_next 
4015				endm 
# End of macro NEXTW
4015			 
4015			.mincont:  
4015 c1				pop bc   ; tidy up 
4016 eb				ex de , hl  
4017					if DEBUG_FORTH_WORDS 
4017						DMARK "MI1" 
4017 f5				push af  
4018 3a 2c 40			ld a, (.dmark)  
401b 32 9d fd			ld (debug_mark),a  
401e 3a 2d 40			ld a, (.dmark+1)  
4021 32 9e fd			ld (debug_mark+1),a  
4024 3a 2e 40			ld a, (.dmark+2)  
4027 32 9f fd			ld (debug_mark+2),a  
402a 18 03			jr .pastdmark  
402c ..			.dmark: db "MI1"  
402f f1			.pastdmark: pop af  
4030			endm  
# End of macro DMARK
4030						CALLMONITOR 
4030 cd aa fd			call debug_vector  
4033				endm  
# End of macro CALLMONITOR
4033					endif 
4033 cd b8 1f				call forth_push_numhl 
4036			 
4036				       NEXTW 
4036 cd a7 fd			call parse_vector 
4039 c3 a8 23			jp macro_next 
403c				endm 
# End of macro NEXTW
403c			.MAX: 
403c				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
403c 4a				db WORD_SYS_CORE+54             
403d c3 40			dw .RND16            
403f 04				db 3 + 1 
4040 .. 00			db "MAX",0              
4044				endm 
# End of macro CWHEAD
4044			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
4044					if DEBUG_FORTH_WORDS_KEY 
4044						DMARK "MAX" 
4044 f5				push af  
4045 3a 59 40			ld a, (.dmark)  
4048 32 9d fd			ld (debug_mark),a  
404b 3a 5a 40			ld a, (.dmark+1)  
404e 32 9e fd			ld (debug_mark+1),a  
4051 3a 5b 40			ld a, (.dmark+2)  
4054 32 9f fd			ld (debug_mark+2),a  
4057 18 03			jr .pastdmark  
4059 ..			.dmark: db "MAX"  
405c f1			.pastdmark: pop af  
405d			endm  
# End of macro DMARK
405d						CALLMONITOR 
405d cd aa fd			call debug_vector  
4060				endm  
# End of macro CALLMONITOR
4060					endif 
4060					; get u2 
4060			 
4060					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4060 cd bd 21			call macro_dsp_valuehl 
4063				endm 
# End of macro FORTH_DSP_VALUEHL
4063			 
4063 e5					push hl   ; u2 
4064			 
4064					; destroy value TOS 
4064			 
4064					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4064 cd 75 22			call macro_forth_dsp_pop 
4067				endm 
# End of macro FORTH_DSP_POP
4067			 
4067					; get u1 
4067			 
4067					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4067 cd bd 21			call macro_dsp_valuehl 
406a				endm 
# End of macro FORTH_DSP_VALUEHL
406a			 
406a e5					push hl  ; u1 
406b			 
406b					; destroy value TOS 
406b			 
406b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
406b cd 75 22			call macro_forth_dsp_pop 
406e				endm 
# End of macro FORTH_DSP_POP
406e			 
406e b7			 or a      ;clear carry flag 
406f e1			  pop hl    ; u1 
4070 d1			  pop de    ; u2 
4071 e5				push hl   ; saved in case hl is lowest 
4072 ed 52		  sbc hl,de 
4074 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
4076			 
4076 e1				pop hl 
4077					if DEBUG_FORTH_WORDS 
4077						DMARK "MAX" 
4077 f5				push af  
4078 3a 8c 40			ld a, (.dmark)  
407b 32 9d fd			ld (debug_mark),a  
407e 3a 8d 40			ld a, (.dmark+1)  
4081 32 9e fd			ld (debug_mark+1),a  
4084 3a 8e 40			ld a, (.dmark+2)  
4087 32 9f fd			ld (debug_mark+2),a  
408a 18 03			jr .pastdmark  
408c ..			.dmark: db "MAX"  
408f f1			.pastdmark: pop af  
4090			endm  
# End of macro DMARK
4090						CALLMONITOR 
4090 cd aa fd			call debug_vector  
4093				endm  
# End of macro CALLMONITOR
4093					endif 
4093 cd b8 1f				call forth_push_numhl 
4096			 
4096				       NEXTW 
4096 cd a7 fd			call parse_vector 
4099 c3 a8 23			jp macro_next 
409c				endm 
# End of macro NEXTW
409c			 
409c			.maxcont:  
409c c1				pop bc   ; tidy up 
409d eb				ex de , hl  
409e					if DEBUG_FORTH_WORDS 
409e						DMARK "MA1" 
409e f5				push af  
409f 3a b3 40			ld a, (.dmark)  
40a2 32 9d fd			ld (debug_mark),a  
40a5 3a b4 40			ld a, (.dmark+1)  
40a8 32 9e fd			ld (debug_mark+1),a  
40ab 3a b5 40			ld a, (.dmark+2)  
40ae 32 9f fd			ld (debug_mark+2),a  
40b1 18 03			jr .pastdmark  
40b3 ..			.dmark: db "MA1"  
40b6 f1			.pastdmark: pop af  
40b7			endm  
# End of macro DMARK
40b7						CALLMONITOR 
40b7 cd aa fd			call debug_vector  
40ba				endm  
# End of macro CALLMONITOR
40ba					endif 
40ba cd b8 1f				call forth_push_numhl 
40bd				       NEXTW 
40bd cd a7 fd			call parse_vector 
40c0 c3 a8 23			jp macro_next 
40c3				endm 
# End of macro NEXTW
40c3			 
40c3			.RND16: 
40c3				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
40c3 4e				db WORD_SYS_CORE+58             
40c4 f5 40			dw .RND8            
40c6 06				db 5 + 1 
40c7 .. 00			db "RND16",0              
40cd				endm 
# End of macro CWHEAD
40cd			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
40cd					if DEBUG_FORTH_WORDS_KEY 
40cd						DMARK "R16" 
40cd f5				push af  
40ce 3a e2 40			ld a, (.dmark)  
40d1 32 9d fd			ld (debug_mark),a  
40d4 3a e3 40			ld a, (.dmark+1)  
40d7 32 9e fd			ld (debug_mark+1),a  
40da 3a e4 40			ld a, (.dmark+2)  
40dd 32 9f fd			ld (debug_mark+2),a  
40e0 18 03			jr .pastdmark  
40e2 ..			.dmark: db "R16"  
40e5 f1			.pastdmark: pop af  
40e6			endm  
# End of macro DMARK
40e6						CALLMONITOR 
40e6 cd aa fd			call debug_vector  
40e9				endm  
# End of macro CALLMONITOR
40e9					endif 
40e9 cd 05 0f				call prng16  
40ec cd b8 1f				call forth_push_numhl 
40ef				       NEXTW 
40ef cd a7 fd			call parse_vector 
40f2 c3 a8 23			jp macro_next 
40f5				endm 
# End of macro NEXTW
40f5			.RND8: 
40f5				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
40f5 60				db WORD_SYS_CORE+76             
40f6 2d 41			dw .RND            
40f8 05				db 4 + 1 
40f9 .. 00			db "RND8",0              
40fe				endm 
# End of macro CWHEAD
40fe			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
40fe					if DEBUG_FORTH_WORDS_KEY 
40fe						DMARK "RN8" 
40fe f5				push af  
40ff 3a 13 41			ld a, (.dmark)  
4102 32 9d fd			ld (debug_mark),a  
4105 3a 14 41			ld a, (.dmark+1)  
4108 32 9e fd			ld (debug_mark+1),a  
410b 3a 15 41			ld a, (.dmark+2)  
410e 32 9f fd			ld (debug_mark+2),a  
4111 18 03			jr .pastdmark  
4113 ..			.dmark: db "RN8"  
4116 f1			.pastdmark: pop af  
4117			endm  
# End of macro DMARK
4117						CALLMONITOR 
4117 cd aa fd			call debug_vector  
411a				endm  
# End of macro CALLMONITOR
411a					endif 
411a 2a db fa				ld hl,(xrandc) 
411d 23					inc hl 
411e cd 1f 0f				call xrnd 
4121 6f					ld l,a	 
4122 26 00				ld h,0 
4124 cd b8 1f				call forth_push_numhl 
4127				       NEXTW 
4127 cd a7 fd			call parse_vector 
412a c3 a8 23			jp macro_next 
412d				endm 
# End of macro NEXTW
412d			.RND: 
412d				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
412d 60				db WORD_SYS_CORE+76             
412e 36 42			dw .ENDMATHS            
4130 04				db 3 + 1 
4131 .. 00			db "RND",0              
4135				endm 
# End of macro CWHEAD
4135			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
4135			 
4135					if DEBUG_FORTH_WORDS_KEY 
4135						DMARK "RND" 
4135 f5				push af  
4136 3a 4a 41			ld a, (.dmark)  
4139 32 9d fd			ld (debug_mark),a  
413c 3a 4b 41			ld a, (.dmark+1)  
413f 32 9e fd			ld (debug_mark+1),a  
4142 3a 4c 41			ld a, (.dmark+2)  
4145 32 9f fd			ld (debug_mark+2),a  
4148 18 03			jr .pastdmark  
414a ..			.dmark: db "RND"  
414d f1			.pastdmark: pop af  
414e			endm  
# End of macro DMARK
414e						CALLMONITOR 
414e cd aa fd			call debug_vector  
4151				endm  
# End of macro CALLMONITOR
4151					endif 
4151					 
4151					FORTH_DSP_VALUEHL    ; upper range 
4151 cd bd 21			call macro_dsp_valuehl 
4154				endm 
# End of macro FORTH_DSP_VALUEHL
4154			 
4154 22 df fa				ld (LFSRSeed), hl	 
4157			 
4157					if DEBUG_FORTH_WORDS 
4157						DMARK "RN1" 
4157 f5				push af  
4158 3a 6c 41			ld a, (.dmark)  
415b 32 9d fd			ld (debug_mark),a  
415e 3a 6d 41			ld a, (.dmark+1)  
4161 32 9e fd			ld (debug_mark+1),a  
4164 3a 6e 41			ld a, (.dmark+2)  
4167 32 9f fd			ld (debug_mark+2),a  
416a 18 03			jr .pastdmark  
416c ..			.dmark: db "RN1"  
416f f1			.pastdmark: pop af  
4170			endm  
# End of macro DMARK
4170						CALLMONITOR 
4170 cd aa fd			call debug_vector  
4173				endm  
# End of macro CALLMONITOR
4173					endif 
4173					FORTH_DSP_POP 
4173 cd 75 22			call macro_forth_dsp_pop 
4176				endm 
# End of macro FORTH_DSP_POP
4176			 
4176					FORTH_DSP_VALUEHL    ; low range 
4176 cd bd 21			call macro_dsp_valuehl 
4179				endm 
# End of macro FORTH_DSP_VALUEHL
4179			 
4179					if DEBUG_FORTH_WORDS 
4179						DMARK "RN2" 
4179 f5				push af  
417a 3a 8e 41			ld a, (.dmark)  
417d 32 9d fd			ld (debug_mark),a  
4180 3a 8f 41			ld a, (.dmark+1)  
4183 32 9e fd			ld (debug_mark+1),a  
4186 3a 90 41			ld a, (.dmark+2)  
4189 32 9f fd			ld (debug_mark+2),a  
418c 18 03			jr .pastdmark  
418e ..			.dmark: db "RN2"  
4191 f1			.pastdmark: pop af  
4192			endm  
# End of macro DMARK
4192						CALLMONITOR 
4192 cd aa fd			call debug_vector  
4195				endm  
# End of macro CALLMONITOR
4195					endif 
4195 22 e1 fa				ld (LFSRSeed+2), hl 
4198			 
4198					FORTH_DSP_POP 
4198 cd 75 22			call macro_forth_dsp_pop 
419b				endm 
# End of macro FORTH_DSP_POP
419b			 
419b e5					push hl 
419c			 
419c e1			.inrange:	pop hl 
419d cd 05 0f				call prng16  
41a0					if DEBUG_FORTH_WORDS 
41a0						DMARK "RN3" 
41a0 f5				push af  
41a1 3a b5 41			ld a, (.dmark)  
41a4 32 9d fd			ld (debug_mark),a  
41a7 3a b6 41			ld a, (.dmark+1)  
41aa 32 9e fd			ld (debug_mark+1),a  
41ad 3a b7 41			ld a, (.dmark+2)  
41b0 32 9f fd			ld (debug_mark+2),a  
41b3 18 03			jr .pastdmark  
41b5 ..			.dmark: db "RN3"  
41b8 f1			.pastdmark: pop af  
41b9			endm  
# End of macro DMARK
41b9						CALLMONITOR 
41b9 cd aa fd			call debug_vector  
41bc				endm  
# End of macro CALLMONITOR
41bc					endif 
41bc					 
41bc					; if the range is 8bit knock out the high byte 
41bc			 
41bc ed 5b df fa			ld de, (LFSRSeed)     ; check high level 
41c0			 
41c0 3e 00				ld a, 0 
41c2 ba					cp d  
41c3 20 1e				jr nz, .hirange 
41c5 26 00				ld h, 0   ; knock it down to 8bit 
41c7			 
41c7					if DEBUG_FORTH_WORDS 
41c7						DMARK "RNk" 
41c7 f5				push af  
41c8 3a dc 41			ld a, (.dmark)  
41cb 32 9d fd			ld (debug_mark),a  
41ce 3a dd 41			ld a, (.dmark+1)  
41d1 32 9e fd			ld (debug_mark+1),a  
41d4 3a de 41			ld a, (.dmark+2)  
41d7 32 9f fd			ld (debug_mark+2),a  
41da 18 03			jr .pastdmark  
41dc ..			.dmark: db "RNk"  
41df f1			.pastdmark: pop af  
41e0			endm  
# End of macro DMARK
41e0						CALLMONITOR 
41e0 cd aa fd			call debug_vector  
41e3				endm  
# End of macro CALLMONITOR
41e3					endif 
41e3			.hirange:   
41e3 e5					push hl  
41e4 b7					or a  
41e5 ed 52		                sbc hl, de 
41e7			 
41e7					;call cmp16 
41e7			 
41e7 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
41e9 e1					pop hl 
41ea e5					push hl 
41eb			 
41eb					if DEBUG_FORTH_WORDS 
41eb						DMARK "RN4" 
41eb f5				push af  
41ec 3a 00 42			ld a, (.dmark)  
41ef 32 9d fd			ld (debug_mark),a  
41f2 3a 01 42			ld a, (.dmark+1)  
41f5 32 9e fd			ld (debug_mark+1),a  
41f8 3a 02 42			ld a, (.dmark+2)  
41fb 32 9f fd			ld (debug_mark+2),a  
41fe 18 03			jr .pastdmark  
4200 ..			.dmark: db "RN4"  
4203 f1			.pastdmark: pop af  
4204			endm  
# End of macro DMARK
4204						CALLMONITOR 
4204 cd aa fd			call debug_vector  
4207				endm  
# End of macro CALLMONITOR
4207					endif 
4207 ed 5b e1 fa			ld de, (LFSRSeed+2)   ; check low range 
420b					;call cmp16 
420b				 
420b b7					or a  
420c ed 52		                sbc hl, de 
420e 38 8c				jr c, .inrange 
4210			 
4210 e1					pop hl 
4211					 
4211					if DEBUG_FORTH_WORDS 
4211						DMARK "RNd" 
4211 f5				push af  
4212 3a 26 42			ld a, (.dmark)  
4215 32 9d fd			ld (debug_mark),a  
4218 3a 27 42			ld a, (.dmark+1)  
421b 32 9e fd			ld (debug_mark+1),a  
421e 3a 28 42			ld a, (.dmark+2)  
4221 32 9f fd			ld (debug_mark+2),a  
4224 18 03			jr .pastdmark  
4226 ..			.dmark: db "RNd"  
4229 f1			.pastdmark: pop af  
422a			endm  
# End of macro DMARK
422a						CALLMONITOR 
422a cd aa fd			call debug_vector  
422d				endm  
# End of macro CALLMONITOR
422d					endif 
422d			 
422d			 
422d cd b8 1f				call forth_push_numhl 
4230				       NEXTW 
4230 cd a7 fd			call parse_vector 
4233 c3 a8 23			jp macro_next 
4236				endm 
# End of macro NEXTW
4236			 
4236			.ENDMATHS: 
4236			 
4236			; eof 
4236			 
# End of file forth_words_maths.asm
4236			include "forth_words_display.asm" 
4236			 
4236			; | ## Display Words 
4236			 
4236			.ACT: 
4236			 
4236				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
4236 62				db WORD_SYS_CORE+78             
4237 85 42			dw .INFO            
4239 07				db 6 + 1 
423a .. 00			db "ACTIVE",0              
4241				endm 
# End of macro CWHEAD
4241			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
4241			;  
4241			; | | To display a pulsing activity indicator in a processing loop do this... 
4241			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
4241			 
4241					if DEBUG_FORTH_WORDS_KEY 
4241						DMARK "ACT" 
4241 f5				push af  
4242 3a 56 42			ld a, (.dmark)  
4245 32 9d fd			ld (debug_mark),a  
4248 3a 57 42			ld a, (.dmark+1)  
424b 32 9e fd			ld (debug_mark+1),a  
424e 3a 58 42			ld a, (.dmark+2)  
4251 32 9f fd			ld (debug_mark+2),a  
4254 18 03			jr .pastdmark  
4256 ..			.dmark: db "ACT"  
4259 f1			.pastdmark: pop af  
425a			endm  
# End of macro DMARK
425a						CALLMONITOR 
425a cd aa fd			call debug_vector  
425d				endm  
# End of macro CALLMONITOR
425d					endif 
425d cd 01 0d				call active 
4260					if DEBUG_FORTH_WORDS 
4260						DMARK "ACp" 
4260 f5				push af  
4261 3a 75 42			ld a, (.dmark)  
4264 32 9d fd			ld (debug_mark),a  
4267 3a 76 42			ld a, (.dmark+1)  
426a 32 9e fd			ld (debug_mark+1),a  
426d 3a 77 42			ld a, (.dmark+2)  
4270 32 9f fd			ld (debug_mark+2),a  
4273 18 03			jr .pastdmark  
4275 ..			.dmark: db "ACp"  
4278 f1			.pastdmark: pop af  
4279			endm  
# End of macro DMARK
4279						CALLMONITOR 
4279 cd aa fd			call debug_vector  
427c				endm  
# End of macro CALLMONITOR
427c					endif 
427c cd 26 20				call forth_push_str 
427f			 
427f					NEXTW 
427f cd a7 fd			call parse_vector 
4282 c3 a8 23			jp macro_next 
4285				endm 
# End of macro NEXTW
4285			.INFO: 
4285			 
4285				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
4285 62				db WORD_SYS_CORE+78             
4286 a5 42			dw .ATP            
4288 05				db 4 + 1 
4289 .. 00			db "INFO",0              
428e				endm 
# End of macro CWHEAD
428e			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
428e					FORTH_DSP_VALUEHL 
428e cd bd 21			call macro_dsp_valuehl 
4291				endm 
# End of macro FORTH_DSP_VALUEHL
4291			 
4291					FORTH_DSP_POP 
4291 cd 75 22			call macro_forth_dsp_pop 
4294				endm 
# End of macro FORTH_DSP_POP
4294			 
4294 e5					push hl 
4295			 
4295					FORTH_DSP_VALUEHL 
4295 cd bd 21			call macro_dsp_valuehl 
4298				endm 
# End of macro FORTH_DSP_VALUEHL
4298			 
4298					FORTH_DSP_POP 
4298 cd 75 22			call macro_forth_dsp_pop 
429b				endm 
# End of macro FORTH_DSP_POP
429b			 
429b d1					pop de 
429c			 
429c cd 3b 0d				call info_panel 
429f			 
429f			 
429f					NEXTW 
429f cd a7 fd			call parse_vector 
42a2 c3 a8 23			jp macro_next 
42a5				endm 
# End of macro NEXTW
42a5			.ATP: 
42a5				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
42a5 62				db WORD_SYS_CORE+78             
42a6 1f 43			dw .FB            
42a8 04				db 3 + 1 
42a9 .. 00			db "AT?",0              
42ad				endm 
# End of macro CWHEAD
42ad			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
42ad					if DEBUG_FORTH_WORDS_KEY 
42ad						DMARK "AT?" 
42ad f5				push af  
42ae 3a c2 42			ld a, (.dmark)  
42b1 32 9d fd			ld (debug_mark),a  
42b4 3a c3 42			ld a, (.dmark+1)  
42b7 32 9e fd			ld (debug_mark+1),a  
42ba 3a c4 42			ld a, (.dmark+2)  
42bd 32 9f fd			ld (debug_mark+2),a  
42c0 18 03			jr .pastdmark  
42c2 ..			.dmark: db "AT?"  
42c5 f1			.pastdmark: pop af  
42c6			endm  
# End of macro DMARK
42c6						CALLMONITOR 
42c6 cd aa fd			call debug_vector  
42c9				endm  
# End of macro CALLMONITOR
42c9					endif 
42c9 3a 90 f9				ld a, (f_cursor_ptr) 
42cc			 
42cc			if DEBUG_FORTH_WORDS 
42cc				DMARK "AT?" 
42cc f5				push af  
42cd 3a e1 42			ld a, (.dmark)  
42d0 32 9d fd			ld (debug_mark),a  
42d3 3a e2 42			ld a, (.dmark+1)  
42d6 32 9e fd			ld (debug_mark+1),a  
42d9 3a e3 42			ld a, (.dmark+2)  
42dc 32 9f fd			ld (debug_mark+2),a  
42df 18 03			jr .pastdmark  
42e1 ..			.dmark: db "AT?"  
42e4 f1			.pastdmark: pop af  
42e5			endm  
# End of macro DMARK
42e5				CALLMONITOR 
42e5 cd aa fd			call debug_vector  
42e8				endm  
# End of macro CALLMONITOR
42e8			endif	 
42e8					; count the number of rows 
42e8			 
42e8 06 00				ld b, 0 
42ea 4f			.atpr:		ld c, a    ; save in case we go below zero 
42eb d6 28				sub display_cols 
42ed f2 f3 42				jp p, .atprunder 
42f0 04					inc b 
42f1 18 f7				jr .atpr 
42f3			.atprunder:	 
42f3			if DEBUG_FORTH_WORDS 
42f3				DMARK "A?2" 
42f3 f5				push af  
42f4 3a 08 43			ld a, (.dmark)  
42f7 32 9d fd			ld (debug_mark),a  
42fa 3a 09 43			ld a, (.dmark+1)  
42fd 32 9e fd			ld (debug_mark+1),a  
4300 3a 0a 43			ld a, (.dmark+2)  
4303 32 9f fd			ld (debug_mark+2),a  
4306 18 03			jr .pastdmark  
4308 ..			.dmark: db "A?2"  
430b f1			.pastdmark: pop af  
430c			endm  
# End of macro DMARK
430c				CALLMONITOR 
430c cd aa fd			call debug_vector  
430f				endm  
# End of macro CALLMONITOR
430f			endif	 
430f 26 00				ld h, 0 
4311 69					ld l, c 
4312 cd b8 1f				call forth_push_numhl 
4315 68					ld l, b  
4316 cd b8 1f				call forth_push_numhl 
4319			 
4319			 
4319				NEXTW 
4319 cd a7 fd			call parse_vector 
431c c3 a8 23			jp macro_next 
431f				endm 
# End of macro NEXTW
431f			 
431f			.FB: 
431f				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
431f 1b				db WORD_SYS_CORE+7             
4320 70 43			dw .EMIT            
4322 03				db 2 + 1 
4323 .. 00			db "FB",0              
4326				endm 
# End of macro CWHEAD
4326			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
4326			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
4326			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
4326			; | | If automatic display is off then updates will not be shown until DRAW is used. 
4326					if DEBUG_FORTH_WORDS_KEY 
4326						DMARK "FB." 
4326 f5				push af  
4327 3a 3b 43			ld a, (.dmark)  
432a 32 9d fd			ld (debug_mark),a  
432d 3a 3c 43			ld a, (.dmark+1)  
4330 32 9e fd			ld (debug_mark+1),a  
4333 3a 3d 43			ld a, (.dmark+2)  
4336 32 9f fd			ld (debug_mark+2),a  
4339 18 03			jr .pastdmark  
433b ..			.dmark: db "FB."  
433e f1			.pastdmark: pop af  
433f			endm  
# End of macro DMARK
433f						CALLMONITOR 
433f cd aa fd			call debug_vector  
4342				endm  
# End of macro CALLMONITOR
4342					endif 
4342			 
4342					FORTH_DSP_VALUEHL 
4342 cd bd 21			call macro_dsp_valuehl 
4345				endm 
# End of macro FORTH_DSP_VALUEHL
4345			 
4345 7d					ld a, l 
4346 fe 01				cp 1 
4348 20 05				jr nz, .fbn1 
434a 21 42 fc				ld hl, display_fb1 
434d 18 15				jr .fbset 
434f fe 02		.fbn1:		cp 2 
4351 20 05				jr nz, .fbn2 
4353 21 00 fb				ld hl, display_fb2 
4356 18 0c				jr .fbset 
4358 fe 03		.fbn2:		cp 3 
435a 20 05				jr nz, .fbn3 
435c 21 a1 fb				ld hl, display_fb3 
435f 18 03				jr .fbset 
4361			.fbn3:		 ; if invalid number select first 
4361 21 42 fc				ld hl, display_fb1 
4364 22 fe fa		.fbset:		ld (display_fb_active), hl 
4367			 
4367					FORTH_DSP_POP 
4367 cd 75 22			call macro_forth_dsp_pop 
436a				endm 
# End of macro FORTH_DSP_POP
436a			 
436a					NEXTW 
436a cd a7 fd			call parse_vector 
436d c3 a8 23			jp macro_next 
4370				endm 
# End of macro NEXTW
4370			 
4370			 
4370			.EMIT: 
4370				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
4370 1b				db WORD_SYS_CORE+7             
4371 c4 43			dw .DOTH            
4373 05				db 4 + 1 
4374 .. 00			db "EMIT",0              
4379				endm 
# End of macro CWHEAD
4379			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
4379					; get value off TOS and display it 
4379			 
4379					if DEBUG_FORTH_WORDS_KEY 
4379						DMARK "EMT" 
4379 f5				push af  
437a 3a 8e 43			ld a, (.dmark)  
437d 32 9d fd			ld (debug_mark),a  
4380 3a 8f 43			ld a, (.dmark+1)  
4383 32 9e fd			ld (debug_mark+1),a  
4386 3a 90 43			ld a, (.dmark+2)  
4389 32 9f fd			ld (debug_mark+2),a  
438c 18 03			jr .pastdmark  
438e ..			.dmark: db "EMT"  
4391 f1			.pastdmark: pop af  
4392			endm  
# End of macro DMARK
4392						CALLMONITOR 
4392 cd aa fd			call debug_vector  
4395				endm  
# End of macro CALLMONITOR
4395					endif 
4395			 
4395					FORTH_DSP_VALUEHL 
4395 cd bd 21			call macro_dsp_valuehl 
4398				endm 
# End of macro FORTH_DSP_VALUEHL
4398			 
4398 7d					ld a,l 
4399			 
4399					; TODO write to display 
4399			 
4399 32 f1 f2				ld (os_input), a 
439c 3e 00				ld a, 0 
439e 32 f2 f2				ld (os_input+1), a 
43a1					 
43a1 3a 90 f9				ld a, (f_cursor_ptr) 
43a4 11 f1 f2				ld de, os_input 
43a7 cd bd 0d				call str_at_display 
43aa			 
43aa			 
43aa 3a 6e f9				ld a,(cli_autodisplay) 
43ad fe 00				cp 0 
43af 28 03				jr z, .enoupdate 
43b1 cd cd 0d						call update_display 
43b4					.enoupdate: 
43b4			 
43b4 3a 90 f9				ld a, (f_cursor_ptr) 
43b7 3c					inc a 
43b8 32 90 f9				ld (f_cursor_ptr), a   ; save new pos 
43bb			 
43bb			 
43bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43bb cd 75 22			call macro_forth_dsp_pop 
43be				endm 
# End of macro FORTH_DSP_POP
43be			  
43be			 
43be					NEXTW 
43be cd a7 fd			call parse_vector 
43c1 c3 a8 23			jp macro_next 
43c4				endm 
# End of macro NEXTW
43c4			.DOTH: 
43c4				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
43c4 1c				db WORD_SYS_CORE+8             
43c5 f7 43			dw .DOTF            
43c7 03				db 2 + 1 
43c8 .. 00			db ".-",0              
43cb				endm 
# End of macro CWHEAD
43cb			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
43cb					; get value off TOS and display it 
43cb					if DEBUG_FORTH_WORDS_KEY 
43cb						DMARK "DTD" 
43cb f5				push af  
43cc 3a e0 43			ld a, (.dmark)  
43cf 32 9d fd			ld (debug_mark),a  
43d2 3a e1 43			ld a, (.dmark+1)  
43d5 32 9e fd			ld (debug_mark+1),a  
43d8 3a e2 43			ld a, (.dmark+2)  
43db 32 9f fd			ld (debug_mark+2),a  
43de 18 03			jr .pastdmark  
43e0 ..			.dmark: db "DTD"  
43e3 f1			.pastdmark: pop af  
43e4			endm  
# End of macro DMARK
43e4						CALLMONITOR 
43e4 cd aa fd			call debug_vector  
43e7				endm  
# End of macro CALLMONITOR
43e7					endif 
43e7 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
43e9 3e 00			ld a, 0 
43eb 32 6f f9			ld (cli_mvdot), a 
43ee c3 51 44			jp .dotgo 
43f1				NEXTW 
43f1 cd a7 fd			call parse_vector 
43f4 c3 a8 23			jp macro_next 
43f7				endm 
# End of macro NEXTW
43f7			.DOTF: 
43f7				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
43f7 1c				db WORD_SYS_CORE+8             
43f8 28 44			dw .DOT            
43fa 03				db 2 + 1 
43fb .. 00			db ".>",0              
43fe				endm 
# End of macro CWHEAD
43fe			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
43fe					; get value off TOS and display it 
43fe			        ; TODO BUG adds extra spaces 
43fe			        ; TODO BUG handle numerics? 
43fe					if DEBUG_FORTH_WORDS_KEY 
43fe						DMARK "DTC" 
43fe f5				push af  
43ff 3a 13 44			ld a, (.dmark)  
4402 32 9d fd			ld (debug_mark),a  
4405 3a 14 44			ld a, (.dmark+1)  
4408 32 9e fd			ld (debug_mark+1),a  
440b 3a 15 44			ld a, (.dmark+2)  
440e 32 9f fd			ld (debug_mark+2),a  
4411 18 03			jr .pastdmark  
4413 ..			.dmark: db "DTC"  
4416 f1			.pastdmark: pop af  
4417			endm  
# End of macro DMARK
4417						CALLMONITOR 
4417 cd aa fd			call debug_vector  
441a				endm  
# End of macro CALLMONITOR
441a					endif 
441a 3e 01			ld a, 1 
441c 32 6f f9			ld (cli_mvdot), a 
441f c3 51 44			jp .dotgo 
4422				NEXTW 
4422 cd a7 fd			call parse_vector 
4425 c3 a8 23			jp macro_next 
4428				endm 
# End of macro NEXTW
4428			 
4428			.DOT: 
4428				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4428 1c				db WORD_SYS_CORE+8             
4429 07 46			dw .CLS            
442b 02				db 1 + 1 
442c .. 00			db ".",0              
442e				endm 
# End of macro CWHEAD
442e			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
442e					; get value off TOS and display it 
442e			 
442e					if DEBUG_FORTH_WORDS_KEY 
442e						DMARK "DOT" 
442e f5				push af  
442f 3a 43 44			ld a, (.dmark)  
4432 32 9d fd			ld (debug_mark),a  
4435 3a 44 44			ld a, (.dmark+1)  
4438 32 9e fd			ld (debug_mark+1),a  
443b 3a 45 44			ld a, (.dmark+2)  
443e 32 9f fd			ld (debug_mark+2),a  
4441 18 03			jr .pastdmark  
4443 ..			.dmark: db "DOT"  
4446 f1			.pastdmark: pop af  
4447			endm  
# End of macro DMARK
4447						CALLMONITOR 
4447 cd aa fd			call debug_vector  
444a				endm  
# End of macro CALLMONITOR
444a					endif 
444a 3e 00			ld a, 0 
444c 32 6f f9			ld (cli_mvdot), a 
444f 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4451				 
4451			 
4451			.dotgo: 
4451			 
4451			; move up type to on stack for parserv5 
4451					FORTH_DSP 
4451 cd 83 21			call macro_forth_dsp 
4454				endm 
# End of macro FORTH_DSP
4454				;FORTH_DSP_VALUE  
4454			 
4454			if DEBUG_FORTH_DOT 
4454				DMARK "DOT" 
4454 f5				push af  
4455 3a 69 44			ld a, (.dmark)  
4458 32 9d fd			ld (debug_mark),a  
445b 3a 6a 44			ld a, (.dmark+1)  
445e 32 9e fd			ld (debug_mark+1),a  
4461 3a 6b 44			ld a, (.dmark+2)  
4464 32 9f fd			ld (debug_mark+2),a  
4467 18 03			jr .pastdmark  
4469 ..			.dmark: db "DOT"  
446c f1			.pastdmark: pop af  
446d			endm  
# End of macro DMARK
446d				CALLMONITOR 
446d cd aa fd			call debug_vector  
4470				endm  
# End of macro CALLMONITOR
4470			endif	 
4470			;		.print: 
4470			 
4470 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4471 23				inc hl   ; position to the actual value 
4472 fe 01			cp DS_TYPE_STR 
4474 20 06			jr nz, .dotnum1  
4476			 
4476			; display string 
4476				FORTH_DSP_VALUE  
4476 cd a6 21			call macro_forth_dsp_value 
4479				endm 
# End of macro FORTH_DSP_VALUE
4479 eb				ex de,hl 
447a 18 49			jr .dotwrite 
447c			 
447c			.dotnum1: 
447c fe 02			cp DS_TYPE_INUM 
447e 20 44			jr nz, .dotflot 
4480			 
4480			 
4480			; display number 
4480			 
4480			;	push hl 
4480			;	call clear_display 
4480			;	pop hl 
4480			 
4480 5e				ld e, (hl) 
4481 23				inc hl 
4482 56				ld d, (hl) 
4483 21 f3 f0			ld hl, scratch 
4486			if DEBUG_FORTH_DOT 
4486				DMARK "DT1" 
4486 f5				push af  
4487 3a 9b 44			ld a, (.dmark)  
448a 32 9d fd			ld (debug_mark),a  
448d 3a 9c 44			ld a, (.dmark+1)  
4490 32 9e fd			ld (debug_mark+1),a  
4493 3a 9d 44			ld a, (.dmark+2)  
4496 32 9f fd			ld (debug_mark+2),a  
4499 18 03			jr .pastdmark  
449b ..			.dmark: db "DT1"  
449e f1			.pastdmark: pop af  
449f			endm  
# End of macro DMARK
449f				CALLMONITOR 
449f cd aa fd			call debug_vector  
44a2				endm  
# End of macro CALLMONITOR
44a2			endif	 
44a2			 
44a2 cd f3 12			call uitoa_16 
44a5 eb				ex de,hl 
44a6			 
44a6			if DEBUG_FORTH_DOT 
44a6				DMARK "DT2" 
44a6 f5				push af  
44a7 3a bb 44			ld a, (.dmark)  
44aa 32 9d fd			ld (debug_mark),a  
44ad 3a bc 44			ld a, (.dmark+1)  
44b0 32 9e fd			ld (debug_mark+1),a  
44b3 3a bd 44			ld a, (.dmark+2)  
44b6 32 9f fd			ld (debug_mark+2),a  
44b9 18 03			jr .pastdmark  
44bb ..			.dmark: db "DT2"  
44be f1			.pastdmark: pop af  
44bf			endm  
# End of macro DMARK
44bf				CALLMONITOR 
44bf cd aa fd			call debug_vector  
44c2				endm  
# End of macro CALLMONITOR
44c2			endif	 
44c2			 
44c2			;	ld de, os_word_scratch 
44c2 18 01			jr .dotwrite 
44c4			 
44c4 00			.dotflot:   nop 
44c5			; TODO print floating point number 
44c5			 
44c5			.dotwrite:		 
44c5			 
44c5					; if c is set then set all '-' to spaces 
44c5					; need to also take into account .>  
44c5			 
44c5 3e 01				ld a, 1 
44c7 b9					cp c 
44c8 20 67				jr nz, .nodashswap 
44ca			 
44ca					; DE has the string to write, working with HL 
44ca			 
44ca 06 ff				ld b, 255 
44cc d5					push de 
44cd e1					pop hl 
44ce			 
44ce			if DEBUG_FORTH_DOT 
44ce				DMARK "DT-" 
44ce f5				push af  
44cf 3a e3 44			ld a, (.dmark)  
44d2 32 9d fd			ld (debug_mark),a  
44d5 3a e4 44			ld a, (.dmark+1)  
44d8 32 9e fd			ld (debug_mark+1),a  
44db 3a e5 44			ld a, (.dmark+2)  
44de 32 9f fd			ld (debug_mark+2),a  
44e1 18 03			jr .pastdmark  
44e3 ..			.dmark: db "DT-"  
44e6 f1			.pastdmark: pop af  
44e7			endm  
# End of macro DMARK
44e7				CALLMONITOR 
44e7 cd aa fd			call debug_vector  
44ea				endm  
# End of macro CALLMONITOR
44ea			endif	 
44ea 7e			.dashscan:	ld a, (hl) 
44eb fe 00				cp 0 
44ed 28 42				jr z, .nodashswap 
44ef fe 2d				cp '-' 
44f1 20 03				jr nz, .dashskip 
44f3 3e 20				ld a, ' ' 
44f5 77					ld (hl), a 
44f6 23			.dashskip:	inc hl 
44f7			if DEBUG_FORTH_DOT 
44f7				DMARK "D-2" 
44f7 f5				push af  
44f8 3a 0c 45			ld a, (.dmark)  
44fb 32 9d fd			ld (debug_mark),a  
44fe 3a 0d 45			ld a, (.dmark+1)  
4501 32 9e fd			ld (debug_mark+1),a  
4504 3a 0e 45			ld a, (.dmark+2)  
4507 32 9f fd			ld (debug_mark+2),a  
450a 18 03			jr .pastdmark  
450c ..			.dmark: db "D-2"  
450f f1			.pastdmark: pop af  
4510			endm  
# End of macro DMARK
4510				CALLMONITOR 
4510 cd aa fd			call debug_vector  
4513				endm  
# End of macro CALLMONITOR
4513			endif	 
4513 10 d5				djnz .dashscan 
4515			 
4515			if DEBUG_FORTH_DOT 
4515				DMARK "D-1" 
4515 f5				push af  
4516 3a 2a 45			ld a, (.dmark)  
4519 32 9d fd			ld (debug_mark),a  
451c 3a 2b 45			ld a, (.dmark+1)  
451f 32 9e fd			ld (debug_mark+1),a  
4522 3a 2c 45			ld a, (.dmark+2)  
4525 32 9f fd			ld (debug_mark+2),a  
4528 18 03			jr .pastdmark  
452a ..			.dmark: db "D-1"  
452d f1			.pastdmark: pop af  
452e			endm  
# End of macro DMARK
452e				CALLMONITOR 
452e cd aa fd			call debug_vector  
4531				endm  
# End of macro CALLMONITOR
4531			endif	 
4531			 
4531			.nodashswap: 
4531			 
4531			if DEBUG_FORTH_DOT 
4531				DMARK "D-o" 
4531 f5				push af  
4532 3a 46 45			ld a, (.dmark)  
4535 32 9d fd			ld (debug_mark),a  
4538 3a 47 45			ld a, (.dmark+1)  
453b 32 9e fd			ld (debug_mark+1),a  
453e 3a 48 45			ld a, (.dmark+2)  
4541 32 9f fd			ld (debug_mark+2),a  
4544 18 03			jr .pastdmark  
4546 ..			.dmark: db "D-o"  
4549 f1			.pastdmark: pop af  
454a			endm  
# End of macro DMARK
454a				CALLMONITOR 
454a cd aa fd			call debug_vector  
454d				endm  
# End of macro CALLMONITOR
454d			endif	 
454d			 
454d d5					push de   ; save string start in case we need to advance print 
454e			 
454e 3a 90 f9				ld a, (f_cursor_ptr) 
4551 cd bd 0d				call str_at_display 
4554 3a 6e f9				ld a,(cli_autodisplay) 
4557 fe 00				cp 0 
4559 28 03				jr z, .noupdate 
455b cd cd 0d						call update_display 
455e					.noupdate: 
455e			 
455e			 
455e					; see if we need to advance the print position 
455e			 
455e e1					pop hl   ; get back string 
455f			;		ex de,hl 
455f			 
455f 3a 6f f9				ld a, (cli_mvdot) 
4562			if DEBUG_FORTH_DOT 
4562			;		ld e,a 
4562				DMARK "D>1" 
4562 f5				push af  
4563 3a 77 45			ld a, (.dmark)  
4566 32 9d fd			ld (debug_mark),a  
4569 3a 78 45			ld a, (.dmark+1)  
456c 32 9e fd			ld (debug_mark+1),a  
456f 3a 79 45			ld a, (.dmark+2)  
4572 32 9f fd			ld (debug_mark+2),a  
4575 18 03			jr .pastdmark  
4577 ..			.dmark: db "D>1"  
457a f1			.pastdmark: pop af  
457b			endm  
# End of macro DMARK
457b				CALLMONITOR 
457b cd aa fd			call debug_vector  
457e				endm  
# End of macro CALLMONITOR
457e			endif	 
457e fe 00				cp 0 
4580 28 44				jr z, .noadv 
4582					; yes, lets advance the print position 
4582 3e 00				ld a, 0 
4584 cd 4f 13				call strlent 
4587			if DEBUG_FORTH_DOT 
4587				DMARK "D-?" 
4587 f5				push af  
4588 3a 9c 45			ld a, (.dmark)  
458b 32 9d fd			ld (debug_mark),a  
458e 3a 9d 45			ld a, (.dmark+1)  
4591 32 9e fd			ld (debug_mark+1),a  
4594 3a 9e 45			ld a, (.dmark+2)  
4597 32 9f fd			ld (debug_mark+2),a  
459a 18 03			jr .pastdmark  
459c ..			.dmark: db "D-?"  
459f f1			.pastdmark: pop af  
45a0			endm  
# End of macro DMARK
45a0				CALLMONITOR 
45a0 cd aa fd			call debug_vector  
45a3				endm  
# End of macro CALLMONITOR
45a3			endif	 
45a3 3a 90 f9				ld a, (f_cursor_ptr) 
45a6 85					add a,l 
45a7					;call addatohl 
45a7					;ld a, l 
45a7 32 90 f9				ld (f_cursor_ptr), a   ; save new pos 
45aa			 
45aa			if DEBUG_FORTH_DOT 
45aa				DMARK "D->" 
45aa f5				push af  
45ab 3a bf 45			ld a, (.dmark)  
45ae 32 9d fd			ld (debug_mark),a  
45b1 3a c0 45			ld a, (.dmark+1)  
45b4 32 9e fd			ld (debug_mark+1),a  
45b7 3a c1 45			ld a, (.dmark+2)  
45ba 32 9f fd			ld (debug_mark+2),a  
45bd 18 03			jr .pastdmark  
45bf ..			.dmark: db "D->"  
45c2 f1			.pastdmark: pop af  
45c3			endm  
# End of macro DMARK
45c3				CALLMONITOR 
45c3 cd aa fd			call debug_vector  
45c6				endm  
# End of macro CALLMONITOR
45c6			endif	 
45c6			 
45c6			.noadv:	 
45c6			 
45c6					if DEBUG_FORTH_DOT_WAIT 
45c6							call next_page_prompt 
45c6					endif	 
45c6			; TODO this pop off the stack causes a crash. i dont know why 
45c6			 
45c6			 
45c6			if DEBUG_FORTH_DOT 
45c6				DMARK "DTh" 
45c6 f5				push af  
45c7 3a db 45			ld a, (.dmark)  
45ca 32 9d fd			ld (debug_mark),a  
45cd 3a dc 45			ld a, (.dmark+1)  
45d0 32 9e fd			ld (debug_mark+1),a  
45d3 3a dd 45			ld a, (.dmark+2)  
45d6 32 9f fd			ld (debug_mark+2),a  
45d9 18 03			jr .pastdmark  
45db ..			.dmark: db "DTh"  
45de f1			.pastdmark: pop af  
45df			endm  
# End of macro DMARK
45df				CALLMONITOR 
45df cd aa fd			call debug_vector  
45e2				endm  
# End of macro CALLMONITOR
45e2			endif	 
45e2			 
45e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45e2 cd 75 22			call macro_forth_dsp_pop 
45e5				endm 
# End of macro FORTH_DSP_POP
45e5			 
45e5			if DEBUG_FORTH_DOT 
45e5				DMARK "DTi" 
45e5 f5				push af  
45e6 3a fa 45			ld a, (.dmark)  
45e9 32 9d fd			ld (debug_mark),a  
45ec 3a fb 45			ld a, (.dmark+1)  
45ef 32 9e fd			ld (debug_mark+1),a  
45f2 3a fc 45			ld a, (.dmark+2)  
45f5 32 9f fd			ld (debug_mark+2),a  
45f8 18 03			jr .pastdmark  
45fa ..			.dmark: db "DTi"  
45fd f1			.pastdmark: pop af  
45fe			endm  
# End of macro DMARK
45fe				CALLMONITOR 
45fe cd aa fd			call debug_vector  
4601				endm  
# End of macro CALLMONITOR
4601			endif	 
4601			 
4601			 
4601					NEXTW 
4601 cd a7 fd			call parse_vector 
4604 c3 a8 23			jp macro_next 
4607				endm 
# End of macro NEXTW
4607			 
4607			.CLS: 
4607				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4607 35				db WORD_SYS_CORE+33             
4608 37 46			dw .DRAW            
460a 04				db 3 + 1 
460b .. 00			db "CLS",0              
460f				endm 
# End of macro CWHEAD
460f			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
460f					if DEBUG_FORTH_WORDS_KEY 
460f						DMARK "CLS" 
460f f5				push af  
4610 3a 24 46			ld a, (.dmark)  
4613 32 9d fd			ld (debug_mark),a  
4616 3a 25 46			ld a, (.dmark+1)  
4619 32 9e fd			ld (debug_mark+1),a  
461c 3a 26 46			ld a, (.dmark+2)  
461f 32 9f fd			ld (debug_mark+2),a  
4622 18 03			jr .pastdmark  
4624 ..			.dmark: db "CLS"  
4627 f1			.pastdmark: pop af  
4628			endm  
# End of macro DMARK
4628						CALLMONITOR 
4628 cd aa fd			call debug_vector  
462b				endm  
# End of macro CALLMONITOR
462b					endif 
462b cd aa 0d				call clear_display 
462e c3 51 47				jp .home		; and home cursor 
4631					NEXTW 
4631 cd a7 fd			call parse_vector 
4634 c3 a8 23			jp macro_next 
4637				endm 
# End of macro NEXTW
4637			 
4637			.DRAW: 
4637				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4637 36				db WORD_SYS_CORE+34             
4638 65 46			dw .DUMP            
463a 05				db 4 + 1 
463b .. 00			db "DRAW",0              
4640				endm 
# End of macro CWHEAD
4640			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4640					if DEBUG_FORTH_WORDS_KEY 
4640						DMARK "DRW" 
4640 f5				push af  
4641 3a 55 46			ld a, (.dmark)  
4644 32 9d fd			ld (debug_mark),a  
4647 3a 56 46			ld a, (.dmark+1)  
464a 32 9e fd			ld (debug_mark+1),a  
464d 3a 57 46			ld a, (.dmark+2)  
4650 32 9f fd			ld (debug_mark+2),a  
4653 18 03			jr .pastdmark  
4655 ..			.dmark: db "DRW"  
4658 f1			.pastdmark: pop af  
4659			endm  
# End of macro DMARK
4659						CALLMONITOR 
4659 cd aa fd			call debug_vector  
465c				endm  
# End of macro CALLMONITOR
465c					endif 
465c cd cd 0d				call update_display 
465f					NEXTW 
465f cd a7 fd			call parse_vector 
4662 c3 a8 23			jp macro_next 
4665				endm 
# End of macro NEXTW
4665			 
4665			.DUMP: 
4665				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4665 37				db WORD_SYS_CORE+35             
4666 a0 46			dw .CDUMP            
4668 05				db 4 + 1 
4669 .. 00			db "DUMP",0              
466e				endm 
# End of macro CWHEAD
466e			; | DUMP ( x -- ) With address x display dump   | DONE 
466e			; TODO pop address to use off of the stack 
466e					if DEBUG_FORTH_WORDS_KEY 
466e						DMARK "DUM" 
466e f5				push af  
466f 3a 83 46			ld a, (.dmark)  
4672 32 9d fd			ld (debug_mark),a  
4675 3a 84 46			ld a, (.dmark+1)  
4678 32 9e fd			ld (debug_mark+1),a  
467b 3a 85 46			ld a, (.dmark+2)  
467e 32 9f fd			ld (debug_mark+2),a  
4681 18 03			jr .pastdmark  
4683 ..			.dmark: db "DUM"  
4686 f1			.pastdmark: pop af  
4687			endm  
# End of macro DMARK
4687						CALLMONITOR 
4687 cd aa fd			call debug_vector  
468a				endm  
# End of macro CALLMONITOR
468a					endif 
468a cd aa 0d				call clear_display 
468d			 
468d					; get address 
468d			 
468d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
468d cd bd 21			call macro_dsp_valuehl 
4690				endm 
# End of macro FORTH_DSP_VALUEHL
4690				 
4690					; save it for cdump 
4690			 
4690 22 16 f4				ld (os_cur_ptr),hl 
4693			 
4693					; destroy value TOS 
4693			 
4693					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4693 cd 75 22			call macro_forth_dsp_pop 
4696				endm 
# End of macro FORTH_DSP_POP
4696			 
4696 cd 38 1e				call dumpcont	; skip old style of param parsing	 
4699 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
469a					NEXTW 
469a cd a7 fd			call parse_vector 
469d c3 a8 23			jp macro_next 
46a0				endm 
# End of macro NEXTW
46a0			.CDUMP: 
46a0				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
46a0 38				db WORD_SYS_CORE+36             
46a1 d3 46			dw .DAT            
46a3 06				db 5 + 1 
46a4 .. 00			db "CDUMP",0              
46aa				endm 
# End of macro CWHEAD
46aa			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
46aa					if DEBUG_FORTH_WORDS_KEY 
46aa						DMARK "CDP" 
46aa f5				push af  
46ab 3a bf 46			ld a, (.dmark)  
46ae 32 9d fd			ld (debug_mark),a  
46b1 3a c0 46			ld a, (.dmark+1)  
46b4 32 9e fd			ld (debug_mark+1),a  
46b7 3a c1 46			ld a, (.dmark+2)  
46ba 32 9f fd			ld (debug_mark+2),a  
46bd 18 03			jr .pastdmark  
46bf ..			.dmark: db "CDP"  
46c2 f1			.pastdmark: pop af  
46c3			endm  
# End of macro DMARK
46c3						CALLMONITOR 
46c3 cd aa fd			call debug_vector  
46c6				endm  
# End of macro CALLMONITOR
46c6					endif 
46c6 cd aa 0d				call clear_display 
46c9 cd 38 1e				call dumpcont	 
46cc c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
46cd					NEXTW 
46cd cd a7 fd			call parse_vector 
46d0 c3 a8 23			jp macro_next 
46d3				endm 
# End of macro NEXTW
46d3			 
46d3			 
46d3			 
46d3			 
46d3			.DAT: 
46d3				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
46d3 3d				db WORD_SYS_CORE+41             
46d4 2c 47			dw .HOME            
46d6 03				db 2 + 1 
46d7 .. 00			db "AT",0              
46da				endm 
# End of macro CWHEAD
46da			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
46da					if DEBUG_FORTH_WORDS_KEY 
46da						DMARK "AT." 
46da f5				push af  
46db 3a ef 46			ld a, (.dmark)  
46de 32 9d fd			ld (debug_mark),a  
46e1 3a f0 46			ld a, (.dmark+1)  
46e4 32 9e fd			ld (debug_mark+1),a  
46e7 3a f1 46			ld a, (.dmark+2)  
46ea 32 9f fd			ld (debug_mark+2),a  
46ed 18 03			jr .pastdmark  
46ef ..			.dmark: db "AT."  
46f2 f1			.pastdmark: pop af  
46f3			endm  
# End of macro DMARK
46f3						CALLMONITOR 
46f3 cd aa fd			call debug_vector  
46f6				endm  
# End of macro CALLMONITOR
46f6					endif 
46f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46f6 cd bd 21			call macro_dsp_valuehl 
46f9				endm 
# End of macro FORTH_DSP_VALUEHL
46f9			 
46f9			 
46f9					; TODO save cursor row 
46f9 7d					ld a,l 
46fa fe 02				cp 2 
46fc 20 04				jr nz, .crow3 
46fe 3e 28				ld a, display_row_2 
4700 18 12				jr .ccol1 
4702 fe 03		.crow3:		cp 3 
4704 20 04				jr nz, .crow4 
4706 3e 50				ld a, display_row_3 
4708 18 0a				jr .ccol1 
470a fe 04		.crow4:		cp 4 
470c 20 04				jr nz, .crow1 
470e 3e 78				ld a, display_row_4 
4710 18 02				jr .ccol1 
4712 3e 00		.crow1:		ld a,display_row_1 
4714 f5			.ccol1:		push af			; got row offset 
4715 6f					ld l,a 
4716 26 00				ld h,0 
4718					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4718 cd 75 22			call macro_forth_dsp_pop 
471b				endm 
# End of macro FORTH_DSP_POP
471b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
471b cd bd 21			call macro_dsp_valuehl 
471e				endm 
# End of macro FORTH_DSP_VALUEHL
471e					; TODO save cursor col 
471e f1					pop af 
471f 85					add l		; add col offset 
4720 32 90 f9				ld (f_cursor_ptr), a 
4723					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4723 cd 75 22			call macro_forth_dsp_pop 
4726				endm 
# End of macro FORTH_DSP_POP
4726			 
4726					; calculate  
4726			 
4726					NEXTW 
4726 cd a7 fd			call parse_vector 
4729 c3 a8 23			jp macro_next 
472c				endm 
# End of macro NEXTW
472c			 
472c			 
472c			.HOME: 
472c				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
472c 41				db WORD_SYS_CORE+45             
472d 5c 47			dw .CR            
472f 05				db 4 + 1 
4730 .. 00			db "HOME",0              
4735				endm 
# End of macro CWHEAD
4735			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4735					if DEBUG_FORTH_WORDS_KEY 
4735						DMARK "HOM" 
4735 f5				push af  
4736 3a 4a 47			ld a, (.dmark)  
4739 32 9d fd			ld (debug_mark),a  
473c 3a 4b 47			ld a, (.dmark+1)  
473f 32 9e fd			ld (debug_mark+1),a  
4742 3a 4c 47			ld a, (.dmark+2)  
4745 32 9f fd			ld (debug_mark+2),a  
4748 18 03			jr .pastdmark  
474a ..			.dmark: db "HOM"  
474d f1			.pastdmark: pop af  
474e			endm  
# End of macro DMARK
474e						CALLMONITOR 
474e cd aa fd			call debug_vector  
4751				endm  
# End of macro CALLMONITOR
4751					endif 
4751 3e 00		.home:		ld a, 0		; and home cursor 
4753 32 90 f9				ld (f_cursor_ptr), a 
4756					NEXTW 
4756 cd a7 fd			call parse_vector 
4759 c3 a8 23			jp macro_next 
475c				endm 
# End of macro NEXTW
475c			 
475c			 
475c			.CR: 
475c				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
475c 46				db WORD_SYS_CORE+50             
475d 9a 47			dw .SPACE            
475f 03				db 2 + 1 
4760 .. 00			db "CR",0              
4763				endm 
# End of macro CWHEAD
4763			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4763					if DEBUG_FORTH_WORDS_KEY 
4763						DMARK "CR." 
4763 f5				push af  
4764 3a 78 47			ld a, (.dmark)  
4767 32 9d fd			ld (debug_mark),a  
476a 3a 79 47			ld a, (.dmark+1)  
476d 32 9e fd			ld (debug_mark+1),a  
4770 3a 7a 47			ld a, (.dmark+2)  
4773 32 9f fd			ld (debug_mark+2),a  
4776 18 03			jr .pastdmark  
4778 ..			.dmark: db "CR."  
477b f1			.pastdmark: pop af  
477c			endm  
# End of macro DMARK
477c						CALLMONITOR 
477c cd aa fd			call debug_vector  
477f				endm  
# End of macro CALLMONITOR
477f					endif 
477f 3e 0d				ld a, 13 
4781 32 f3 f0				ld (scratch),a 
4784 3e 0a				ld a, 10 
4786 32 f4 f0				ld (scratch+1),a 
4789 3e 00				ld a, 0 
478b 32 f5 f0				ld (scratch+2),a 
478e 21 f3 f0				ld hl, scratch 
4791 cd 26 20				call forth_push_str 
4794					 
4794				       NEXTW 
4794 cd a7 fd			call parse_vector 
4797 c3 a8 23			jp macro_next 
479a				endm 
# End of macro NEXTW
479a			.SPACE: 
479a				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
479a 46				db WORD_SYS_CORE+50             
479b d3 47			dw .SPACES            
479d 03				db 2 + 1 
479e .. 00			db "BL",0              
47a1				endm 
# End of macro CWHEAD
47a1			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
47a1					if DEBUG_FORTH_WORDS_KEY 
47a1						DMARK "BL." 
47a1 f5				push af  
47a2 3a b6 47			ld a, (.dmark)  
47a5 32 9d fd			ld (debug_mark),a  
47a8 3a b7 47			ld a, (.dmark+1)  
47ab 32 9e fd			ld (debug_mark+1),a  
47ae 3a b8 47			ld a, (.dmark+2)  
47b1 32 9f fd			ld (debug_mark+2),a  
47b4 18 03			jr .pastdmark  
47b6 ..			.dmark: db "BL."  
47b9 f1			.pastdmark: pop af  
47ba			endm  
# End of macro DMARK
47ba						CALLMONITOR 
47ba cd aa fd			call debug_vector  
47bd				endm  
# End of macro CALLMONITOR
47bd					endif 
47bd 3e 20				ld a, " " 
47bf 32 f3 f0				ld (scratch),a 
47c2 3e 00				ld a, 0 
47c4 32 f4 f0				ld (scratch+1),a 
47c7 21 f3 f0				ld hl, scratch 
47ca cd 26 20				call forth_push_str 
47cd					 
47cd				       NEXTW 
47cd cd a7 fd			call parse_vector 
47d0 c3 a8 23			jp macro_next 
47d3				endm 
# End of macro NEXTW
47d3			 
47d3			;.blstr: db " ", 0 
47d3			 
47d3			.SPACES: 
47d3				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
47d3 47				db WORD_SYS_CORE+51             
47d4 71 48			dw .SCROLL            
47d6 07				db 6 + 1 
47d7 .. 00			db "SPACES",0              
47de				endm 
# End of macro CWHEAD
47de			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
47de					if DEBUG_FORTH_WORDS_KEY 
47de						DMARK "SPS" 
47de f5				push af  
47df 3a f3 47			ld a, (.dmark)  
47e2 32 9d fd			ld (debug_mark),a  
47e5 3a f4 47			ld a, (.dmark+1)  
47e8 32 9e fd			ld (debug_mark+1),a  
47eb 3a f5 47			ld a, (.dmark+2)  
47ee 32 9f fd			ld (debug_mark+2),a  
47f1 18 03			jr .pastdmark  
47f3 ..			.dmark: db "SPS"  
47f6 f1			.pastdmark: pop af  
47f7			endm  
# End of macro DMARK
47f7						CALLMONITOR 
47f7 cd aa fd			call debug_vector  
47fa				endm  
# End of macro CALLMONITOR
47fa					endif 
47fa			 
47fa			 
47fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
47fa cd bd 21			call macro_dsp_valuehl 
47fd				endm 
# End of macro FORTH_DSP_VALUEHL
47fd			 
47fd e5					push hl    ; u 
47fe					if DEBUG_FORTH_WORDS 
47fe						DMARK "SPA" 
47fe f5				push af  
47ff 3a 13 48			ld a, (.dmark)  
4802 32 9d fd			ld (debug_mark),a  
4805 3a 14 48			ld a, (.dmark+1)  
4808 32 9e fd			ld (debug_mark+1),a  
480b 3a 15 48			ld a, (.dmark+2)  
480e 32 9f fd			ld (debug_mark+2),a  
4811 18 03			jr .pastdmark  
4813 ..			.dmark: db "SPA"  
4816 f1			.pastdmark: pop af  
4817			endm  
# End of macro DMARK
4817						CALLMONITOR 
4817 cd aa fd			call debug_vector  
481a				endm  
# End of macro CALLMONITOR
481a					endif 
481a			 
481a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
481a cd 75 22			call macro_forth_dsp_pop 
481d				endm 
# End of macro FORTH_DSP_POP
481d e1					pop hl 
481e 0e 00				ld c, 0 
4820 45					ld b, l 
4821 21 f3 f0				ld hl, scratch  
4824			 
4824					if DEBUG_FORTH_WORDS 
4824						DMARK "SP2" 
4824 f5				push af  
4825 3a 39 48			ld a, (.dmark)  
4828 32 9d fd			ld (debug_mark),a  
482b 3a 3a 48			ld a, (.dmark+1)  
482e 32 9e fd			ld (debug_mark+1),a  
4831 3a 3b 48			ld a, (.dmark+2)  
4834 32 9f fd			ld (debug_mark+2),a  
4837 18 03			jr .pastdmark  
4839 ..			.dmark: db "SP2"  
483c f1			.pastdmark: pop af  
483d			endm  
# End of macro DMARK
483d						CALLMONITOR 
483d cd aa fd			call debug_vector  
4840				endm  
# End of macro CALLMONITOR
4840					endif 
4840 3e 20				ld a, ' ' 
4842			.spaces1:	 
4842 77					ld (hl),a 
4843 23					inc hl 
4844					 
4844 10 fc				djnz .spaces1 
4846 3e 00				ld a,0 
4848 77					ld (hl),a 
4849 21 f3 f0				ld hl, scratch 
484c					if DEBUG_FORTH_WORDS 
484c						DMARK "SP3" 
484c f5				push af  
484d 3a 61 48			ld a, (.dmark)  
4850 32 9d fd			ld (debug_mark),a  
4853 3a 62 48			ld a, (.dmark+1)  
4856 32 9e fd			ld (debug_mark+1),a  
4859 3a 63 48			ld a, (.dmark+2)  
485c 32 9f fd			ld (debug_mark+2),a  
485f 18 03			jr .pastdmark  
4861 ..			.dmark: db "SP3"  
4864 f1			.pastdmark: pop af  
4865			endm  
# End of macro DMARK
4865						CALLMONITOR 
4865 cd aa fd			call debug_vector  
4868				endm  
# End of macro CALLMONITOR
4868					endif 
4868 cd 26 20				call forth_push_str 
486b			 
486b				       NEXTW 
486b cd a7 fd			call parse_vector 
486e c3 a8 23			jp macro_next 
4871				endm 
# End of macro NEXTW
4871			 
4871			 
4871			 
4871			.SCROLL: 
4871				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4871 53				db WORD_SYS_CORE+63             
4872 a1 48			dw .SCROLLD            
4874 07				db 6 + 1 
4875 .. 00			db "SCROLL",0              
487c				endm 
# End of macro CWHEAD
487c			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
487c					if DEBUG_FORTH_WORDS_KEY 
487c						DMARK "SCR" 
487c f5				push af  
487d 3a 91 48			ld a, (.dmark)  
4880 32 9d fd			ld (debug_mark),a  
4883 3a 92 48			ld a, (.dmark+1)  
4886 32 9e fd			ld (debug_mark+1),a  
4889 3a 93 48			ld a, (.dmark+2)  
488c 32 9f fd			ld (debug_mark+2),a  
488f 18 03			jr .pastdmark  
4891 ..			.dmark: db "SCR"  
4894 f1			.pastdmark: pop af  
4895			endm  
# End of macro DMARK
4895						CALLMONITOR 
4895 cd aa fd			call debug_vector  
4898				endm  
# End of macro CALLMONITOR
4898					endif 
4898			 
4898 cd 6c 0d			call scroll_up 
489b			;	call update_display 
489b			 
489b					NEXTW 
489b cd a7 fd			call parse_vector 
489e c3 a8 23			jp macro_next 
48a1				endm 
# End of macro NEXTW
48a1			 
48a1			 
48a1			 
48a1			;		; get dir 
48a1			; 
48a1			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48a1			; 
48a1			;		push hl 
48a1			; 
48a1			;		; destroy value TOS 
48a1			; 
48a1			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48a1			; 
48a1			;		; get count 
48a1			; 
48a1			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48a1			; 
48a1			;		push hl 
48a1			; 
48a1			;		; destroy value TOS 
48a1			; 
48a1			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48a1			; 
48a1			;		; one value on hl get other one back 
48a1			; 
48a1			;		pop bc    ; count 
48a1			; 
48a1			;		pop de   ; dir 
48a1			; 
48a1			; 
48a1			;		ld b, c 
48a1			; 
48a1			;.scrolldir:     push bc 
48a1			;		push de 
48a1			; 
48a1			;		ld a, 0 
48a1			;		cp e 
48a1			;		jr z, .scrollup  
48a1			;		call scroll_down 
48a1			;		jr .scrollnext 
48a1			;.scrollup:	call scroll_up 
48a1			; 
48a1			;		 
48a1			;.scrollnext: 
48a1			;		pop de 
48a1			;		pop bc 
48a1			;		djnz .scrolldir 
48a1			; 
48a1			; 
48a1			; 
48a1			; 
48a1			; 
48a1			;		NEXTW 
48a1			 
48a1			.SCROLLD: 
48a1				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
48a1 53				db WORD_SYS_CORE+63             
48a2 d2 48			dw .ATQ            
48a4 08				db 7 + 1 
48a5 .. 00			db "SCROLLD",0              
48ad				endm 
# End of macro CWHEAD
48ad			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
48ad					if DEBUG_FORTH_WORDS_KEY 
48ad						DMARK "SCD" 
48ad f5				push af  
48ae 3a c2 48			ld a, (.dmark)  
48b1 32 9d fd			ld (debug_mark),a  
48b4 3a c3 48			ld a, (.dmark+1)  
48b7 32 9e fd			ld (debug_mark+1),a  
48ba 3a c4 48			ld a, (.dmark+2)  
48bd 32 9f fd			ld (debug_mark+2),a  
48c0 18 03			jr .pastdmark  
48c2 ..			.dmark: db "SCD"  
48c5 f1			.pastdmark: pop af  
48c6			endm  
# End of macro DMARK
48c6						CALLMONITOR 
48c6 cd aa fd			call debug_vector  
48c9				endm  
# End of macro CALLMONITOR
48c9					endif 
48c9			 
48c9 cd 90 0d			call scroll_down 
48cc			;	call update_display 
48cc			 
48cc					NEXTW 
48cc cd a7 fd			call parse_vector 
48cf c3 a8 23			jp macro_next 
48d2				endm 
# End of macro NEXTW
48d2			 
48d2			 
48d2			.ATQ: 
48d2				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
48d2 62				db WORD_SYS_CORE+78             
48d3 33 49			dw .AUTODSP            
48d5 04				db 3 + 1 
48d6 .. 00			db "AT@",0              
48da				endm 
# End of macro CWHEAD
48da			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
48da					if DEBUG_FORTH_WORDS_KEY 
48da						DMARK "ATA" 
48da f5				push af  
48db 3a ef 48			ld a, (.dmark)  
48de 32 9d fd			ld (debug_mark),a  
48e1 3a f0 48			ld a, (.dmark+1)  
48e4 32 9e fd			ld (debug_mark+1),a  
48e7 3a f1 48			ld a, (.dmark+2)  
48ea 32 9f fd			ld (debug_mark+2),a  
48ed 18 03			jr .pastdmark  
48ef ..			.dmark: db "ATA"  
48f2 f1			.pastdmark: pop af  
48f3			endm  
# End of macro DMARK
48f3						CALLMONITOR 
48f3 cd aa fd			call debug_vector  
48f6				endm  
# End of macro CALLMONITOR
48f6					endif 
48f6			 
48f6			 
48f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48f6 cd bd 21			call macro_dsp_valuehl 
48f9				endm 
# End of macro FORTH_DSP_VALUEHL
48f9			 
48f9					; TODO save cursor row 
48f9 7d					ld a,l 
48fa fe 02				cp 2 
48fc 20 04				jr nz, .crow3aq 
48fe 3e 28				ld a, display_row_2 
4900 18 12				jr .ccol1aq 
4902 fe 03		.crow3aq:		cp 3 
4904 20 04				jr nz, .crow4aq 
4906 3e 50				ld a, display_row_3 
4908 18 0a				jr .ccol1aq 
490a fe 04		.crow4aq:		cp 4 
490c 20 04				jr nz, .crow1aq 
490e 3e 78				ld a, display_row_4 
4910 18 02				jr .ccol1aq 
4912 3e 00		.crow1aq:		ld a,display_row_1 
4914 f5			.ccol1aq:		push af			; got row offset 
4915 6f					ld l,a 
4916 26 00				ld h,0 
4918					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4918 cd 75 22			call macro_forth_dsp_pop 
491b				endm 
# End of macro FORTH_DSP_POP
491b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
491b cd bd 21			call macro_dsp_valuehl 
491e				endm 
# End of macro FORTH_DSP_VALUEHL
491e					; TODO save cursor col 
491e f1					pop af 
491f 85					add l		; add col offset 
4920			 
4920					; add current frame buffer address 
4920 2a fe fa				ld hl, (display_fb_active) 
4923 cd de 0f				call addatohl 
4926			 
4926			 
4926			 
4926			 
4926					; get char frame buffer location offset in hl 
4926			 
4926 7e					ld a,(hl) 
4927 26 00				ld h, 0 
4929 6f					ld l, a 
492a			 
492a cd b8 1f				call forth_push_numhl 
492d			 
492d			 
492d					NEXTW 
492d cd a7 fd			call parse_vector 
4930 c3 a8 23			jp macro_next 
4933				endm 
# End of macro NEXTW
4933			 
4933			.AUTODSP: 
4933				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4933 63				db WORD_SYS_CORE+79             
4934 4c 49			dw .MENU            
4936 05				db 4 + 1 
4937 .. 00			db "ADSP",0              
493c				endm 
# End of macro CWHEAD
493c			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
493c			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
493c			 
493c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
493c cd bd 21			call macro_dsp_valuehl 
493f				endm 
# End of macro FORTH_DSP_VALUEHL
493f			 
493f			;		push hl 
493f			 
493f					; destroy value TOS 
493f			 
493f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
493f cd 75 22			call macro_forth_dsp_pop 
4942				endm 
# End of macro FORTH_DSP_POP
4942			 
4942			;		pop hl 
4942			 
4942 7d					ld a,l 
4943 32 6e f9				ld (cli_autodisplay), a 
4946				       NEXTW 
4946 cd a7 fd			call parse_vector 
4949 c3 a8 23			jp macro_next 
494c				endm 
# End of macro NEXTW
494c			 
494c			.MENU: 
494c				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
494c 70				db WORD_SYS_CORE+92             
494d f8 49			dw .ENDDISPLAY            
494f 05				db 4 + 1 
4950 .. 00			db "MENU",0              
4955				endm 
# End of macro CWHEAD
4955			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4955			 
4955			;		; get number of items on the stack 
4955			; 
4955				 
4955					FORTH_DSP_VALUEHL 
4955 cd bd 21			call macro_dsp_valuehl 
4958				endm 
# End of macro FORTH_DSP_VALUEHL
4958				 
4958					if DEBUG_FORTH_WORDS_KEY 
4958						DMARK "MNU" 
4958 f5				push af  
4959 3a 6d 49			ld a, (.dmark)  
495c 32 9d fd			ld (debug_mark),a  
495f 3a 6e 49			ld a, (.dmark+1)  
4962 32 9e fd			ld (debug_mark+1),a  
4965 3a 6f 49			ld a, (.dmark+2)  
4968 32 9f fd			ld (debug_mark+2),a  
496b 18 03			jr .pastdmark  
496d ..			.dmark: db "MNU"  
4970 f1			.pastdmark: pop af  
4971			endm  
# End of macro DMARK
4971						CALLMONITOR 
4971 cd aa fd			call debug_vector  
4974				endm  
# End of macro CALLMONITOR
4974					endif 
4974			 
4974 45					ld b, l	 
4975 05					dec b 
4976			 
4976					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4976 cd 75 22			call macro_forth_dsp_pop 
4979				endm 
# End of macro FORTH_DSP_POP
4979			 
4979			 
4979					; go directly through the stack to pluck out the string pointers and build an array 
4979			 
4979			;		FORTH_DSP 
4979			 
4979					; hl contains top most stack item 
4979				 
4979 11 f3 f0				ld de, scratch 
497c			 
497c			.mbuild: 
497c			 
497c					FORTH_DSP_VALUEHL 
497c cd bd 21			call macro_dsp_valuehl 
497f				endm 
# End of macro FORTH_DSP_VALUEHL
497f			 
497f					if DEBUG_FORTH_WORDS 
497f						DMARK "MN3" 
497f f5				push af  
4980 3a 94 49			ld a, (.dmark)  
4983 32 9d fd			ld (debug_mark),a  
4986 3a 95 49			ld a, (.dmark+1)  
4989 32 9e fd			ld (debug_mark+1),a  
498c 3a 96 49			ld a, (.dmark+2)  
498f 32 9f fd			ld (debug_mark+2),a  
4992 18 03			jr .pastdmark  
4994 ..			.dmark: db "MN3"  
4997 f1			.pastdmark: pop af  
4998			endm  
# End of macro DMARK
4998						CALLMONITOR 
4998 cd aa fd			call debug_vector  
499b				endm  
# End of macro CALLMONITOR
499b					endif 
499b eb					ex de, hl 
499c 73					ld (hl), e 
499d 23					inc hl 
499e 72					ld (hl), d 
499f 23					inc hl 
49a0 eb					ex de, hl 
49a1			 
49a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49a1 cd 75 22			call macro_forth_dsp_pop 
49a4				endm 
# End of macro FORTH_DSP_POP
49a4			 
49a4 10 d6				djnz .mbuild 
49a6			 
49a6					; done add term 
49a6			 
49a6 eb					ex de, hl 
49a7 36 00				ld (hl), 0 
49a9 23					inc hl 
49aa 36 00				ld (hl), 0 
49ac			 
49ac				 
49ac					 
49ac 21 f3 f0				ld hl, scratch 
49af			 
49af					if DEBUG_FORTH_WORDS 
49af						DMARK "MNx" 
49af f5				push af  
49b0 3a c4 49			ld a, (.dmark)  
49b3 32 9d fd			ld (debug_mark),a  
49b6 3a c5 49			ld a, (.dmark+1)  
49b9 32 9e fd			ld (debug_mark+1),a  
49bc 3a c6 49			ld a, (.dmark+2)  
49bf 32 9f fd			ld (debug_mark+2),a  
49c2 18 03			jr .pastdmark  
49c4 ..			.dmark: db "MNx"  
49c7 f1			.pastdmark: pop af  
49c8			endm  
# End of macro DMARK
49c8						CALLMONITOR 
49c8 cd aa fd			call debug_vector  
49cb				endm  
# End of macro CALLMONITOR
49cb					endif 
49cb			 
49cb			 
49cb			 
49cb 3e 00				ld a, 0 
49cd cd db 0d				call menu 
49d0			 
49d0			 
49d0 6f					ld l, a 
49d1 26 00				ld h, 0 
49d3			 
49d3					if DEBUG_FORTH_WORDS 
49d3						DMARK "MNr" 
49d3 f5				push af  
49d4 3a e8 49			ld a, (.dmark)  
49d7 32 9d fd			ld (debug_mark),a  
49da 3a e9 49			ld a, (.dmark+1)  
49dd 32 9e fd			ld (debug_mark+1),a  
49e0 3a ea 49			ld a, (.dmark+2)  
49e3 32 9f fd			ld (debug_mark+2),a  
49e6 18 03			jr .pastdmark  
49e8 ..			.dmark: db "MNr"  
49eb f1			.pastdmark: pop af  
49ec			endm  
# End of macro DMARK
49ec						CALLMONITOR 
49ec cd aa fd			call debug_vector  
49ef				endm  
# End of macro CALLMONITOR
49ef					endif 
49ef			 
49ef cd b8 1f				call forth_push_numhl 
49f2			 
49f2			 
49f2			 
49f2			 
49f2				       NEXTW 
49f2 cd a7 fd			call parse_vector 
49f5 c3 a8 23			jp macro_next 
49f8				endm 
# End of macro NEXTW
49f8			 
49f8			 
49f8			.ENDDISPLAY: 
49f8			 
49f8			; eof 
# End of file forth_words_display.asm
49f8			include "forth_words_str.asm" 
49f8			 
49f8			; | ## String Words 
49f8			 
49f8			.SPLIT:   
49f8			 
49f8				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
49f8 48				db WORD_SYS_CORE+52             
49f9 f0 4a			dw .PTR            
49fb 06				db 5 + 1 
49fc .. 00			db "SPLIT",0              
4a02				endm 
# End of macro CWHEAD
4a02			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
4a02					if DEBUG_FORTH_WORDS_KEY 
4a02						DMARK "SPT" 
4a02 f5				push af  
4a03 3a 17 4a			ld a, (.dmark)  
4a06 32 9d fd			ld (debug_mark),a  
4a09 3a 18 4a			ld a, (.dmark+1)  
4a0c 32 9e fd			ld (debug_mark+1),a  
4a0f 3a 19 4a			ld a, (.dmark+2)  
4a12 32 9f fd			ld (debug_mark+2),a  
4a15 18 03			jr .pastdmark  
4a17 ..			.dmark: db "SPT"  
4a1a f1			.pastdmark: pop af  
4a1b			endm  
# End of macro DMARK
4a1b						CALLMONITOR 
4a1b cd aa fd			call debug_vector  
4a1e				endm  
# End of macro CALLMONITOR
4a1e					endif 
4a1e			 
4a1e					; get delim 
4a1e					FORTH_DSP_VALUEHL 
4a1e cd bd 21			call macro_dsp_valuehl 
4a21				endm 
# End of macro FORTH_DSP_VALUEHL
4a21			 
4a21					FORTH_DSP_POP 
4a21 cd 75 22			call macro_forth_dsp_pop 
4a24				endm 
# End of macro FORTH_DSP_POP
4a24					 
4a24			 
4a24 45					ld b, l    ; move delim to b 
4a25 0e 01				ld c, 1   ; count of poritions 
4a27			 
4a27 c5					push bc 
4a28			 
4a28					if DEBUG_FORTH_WORDS 
4a28						DMARK "SPa" 
4a28 f5				push af  
4a29 3a 3d 4a			ld a, (.dmark)  
4a2c 32 9d fd			ld (debug_mark),a  
4a2f 3a 3e 4a			ld a, (.dmark+1)  
4a32 32 9e fd			ld (debug_mark+1),a  
4a35 3a 3f 4a			ld a, (.dmark+2)  
4a38 32 9f fd			ld (debug_mark+2),a  
4a3b 18 03			jr .pastdmark  
4a3d ..			.dmark: db "SPa"  
4a40 f1			.pastdmark: pop af  
4a41			endm  
# End of macro DMARK
4a41						CALLMONITOR 
4a41 cd aa fd			call debug_vector  
4a44				endm  
# End of macro CALLMONITOR
4a44					endif 
4a44					; get pointer to string to chop up 
4a44					FORTH_DSP_VALUEHL 
4a44 cd bd 21			call macro_dsp_valuehl 
4a47				endm 
# End of macro FORTH_DSP_VALUEHL
4a47			 
4a47			;		push hl 
4a47 11 f3 f0				ld de, scratch 
4a4a			.spllop: 
4a4a c1					pop bc 
4a4b c5					push bc 
4a4c			;		pop hl 
4a4c					if DEBUG_FORTH_WORDS 
4a4c						DMARK "SPl" 
4a4c f5				push af  
4a4d 3a 61 4a			ld a, (.dmark)  
4a50 32 9d fd			ld (debug_mark),a  
4a53 3a 62 4a			ld a, (.dmark+1)  
4a56 32 9e fd			ld (debug_mark+1),a  
4a59 3a 63 4a			ld a, (.dmark+2)  
4a5c 32 9f fd			ld (debug_mark+2),a  
4a5f 18 03			jr .pastdmark  
4a61 ..			.dmark: db "SPl"  
4a64 f1			.pastdmark: pop af  
4a65			endm  
# End of macro DMARK
4a65						CALLMONITOR 
4a65 cd aa fd			call debug_vector  
4a68				endm  
# End of macro CALLMONITOR
4a68					endif 
4a68 7e					ld a, (hl) 
4a69 b8					cp b 
4a6a 28 08				jr z, .splnxt 
4a6c fe 00				cp 0 
4a6e 28 34				jr z, .splend 
4a70 ed a0				ldi 
4a72 18 d6				jr .spllop 
4a74			 
4a74					; hit dlim 
4a74			 
4a74			.splnxt: 
4a74					if DEBUG_FORTH_WORDS 
4a74						DMARK "SPx" 
4a74 f5				push af  
4a75 3a 89 4a			ld a, (.dmark)  
4a78 32 9d fd			ld (debug_mark),a  
4a7b 3a 8a 4a			ld a, (.dmark+1)  
4a7e 32 9e fd			ld (debug_mark+1),a  
4a81 3a 8b 4a			ld a, (.dmark+2)  
4a84 32 9f fd			ld (debug_mark+2),a  
4a87 18 03			jr .pastdmark  
4a89 ..			.dmark: db "SPx"  
4a8c f1			.pastdmark: pop af  
4a8d			endm  
# End of macro DMARK
4a8d						CALLMONITOR 
4a8d cd aa fd			call debug_vector  
4a90				endm  
# End of macro CALLMONITOR
4a90					endif 
4a90 3e 00				ld a, 0 
4a92 12					ld (de), a 
4a93					;ex de, hl 
4a93 e5					push hl 
4a94 21 f3 f0				ld hl, scratch 
4a97 cd 26 20				call forth_push_str 
4a9a e1					pop hl 
4a9b					;ex de, hl 
4a9b 23					inc hl 
4a9c c1					pop bc 
4a9d 0c					inc c 
4a9e c5					push bc 
4a9f 11 f3 f0				ld de, scratch 
4aa2 18 a6				jr .spllop 
4aa4			 
4aa4			.splend:		 
4aa4					if DEBUG_FORTH_WORDS 
4aa4						DMARK "SPe" 
4aa4 f5				push af  
4aa5 3a b9 4a			ld a, (.dmark)  
4aa8 32 9d fd			ld (debug_mark),a  
4aab 3a ba 4a			ld a, (.dmark+1)  
4aae 32 9e fd			ld (debug_mark+1),a  
4ab1 3a bb 4a			ld a, (.dmark+2)  
4ab4 32 9f fd			ld (debug_mark+2),a  
4ab7 18 03			jr .pastdmark  
4ab9 ..			.dmark: db "SPe"  
4abc f1			.pastdmark: pop af  
4abd			endm  
# End of macro DMARK
4abd						CALLMONITOR 
4abd cd aa fd			call debug_vector  
4ac0				endm  
# End of macro CALLMONITOR
4ac0					endif 
4ac0 12					ld (de), a 
4ac1 eb					ex de, hl 
4ac2			;		push hl 
4ac2 21 f3 f0				ld hl, scratch 
4ac5 cd 26 20				call forth_push_str 
4ac8					 
4ac8					if DEBUG_FORTH_WORDS 
4ac8						DMARK "SPc" 
4ac8 f5				push af  
4ac9 3a dd 4a			ld a, (.dmark)  
4acc 32 9d fd			ld (debug_mark),a  
4acf 3a de 4a			ld a, (.dmark+1)  
4ad2 32 9e fd			ld (debug_mark+1),a  
4ad5 3a df 4a			ld a, (.dmark+2)  
4ad8 32 9f fd			ld (debug_mark+2),a  
4adb 18 03			jr .pastdmark  
4add ..			.dmark: db "SPc"  
4ae0 f1			.pastdmark: pop af  
4ae1			endm  
# End of macro DMARK
4ae1						CALLMONITOR 
4ae1 cd aa fd			call debug_vector  
4ae4				endm  
# End of macro CALLMONITOR
4ae4					endif 
4ae4			 
4ae4 e1					pop hl    ; get counter from bc which has been push 
4ae5 26 00				ld h, 0 
4ae7			;		ld l, c 
4ae7 cd b8 1f				call forth_push_numhl 
4aea			 
4aea			 
4aea				NEXTW 
4aea cd a7 fd			call parse_vector 
4aed c3 a8 23			jp macro_next 
4af0				endm 
# End of macro NEXTW
4af0			.PTR:   
4af0			 
4af0				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4af0 48				db WORD_SYS_CORE+52             
4af1 20 4b			dw .STYPE            
4af3 04				db 3 + 1 
4af4 .. 00			db "PTR",0              
4af8				endm 
# End of macro CWHEAD
4af8			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4af8			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4af8			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4af8			 
4af8					if DEBUG_FORTH_WORDS_KEY 
4af8						DMARK "PTR" 
4af8 f5				push af  
4af9 3a 0d 4b			ld a, (.dmark)  
4afc 32 9d fd			ld (debug_mark),a  
4aff 3a 0e 4b			ld a, (.dmark+1)  
4b02 32 9e fd			ld (debug_mark+1),a  
4b05 3a 0f 4b			ld a, (.dmark+2)  
4b08 32 9f fd			ld (debug_mark+2),a  
4b0b 18 03			jr .pastdmark  
4b0d ..			.dmark: db "PTR"  
4b10 f1			.pastdmark: pop af  
4b11			endm  
# End of macro DMARK
4b11						CALLMONITOR 
4b11 cd aa fd			call debug_vector  
4b14				endm  
# End of macro CALLMONITOR
4b14					endif 
4b14					FORTH_DSP_VALUEHL 
4b14 cd bd 21			call macro_dsp_valuehl 
4b17				endm 
# End of macro FORTH_DSP_VALUEHL
4b17 cd b8 1f				call forth_push_numhl 
4b1a			 
4b1a			 
4b1a					NEXTW 
4b1a cd a7 fd			call parse_vector 
4b1d c3 a8 23			jp macro_next 
4b20				endm 
# End of macro NEXTW
4b20			.STYPE: 
4b20				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4b20 48				db WORD_SYS_CORE+52             
4b21 72 4b			dw .UPPER            
4b23 06				db 5 + 1 
4b24 .. 00			db "STYPE",0              
4b2a				endm 
# End of macro CWHEAD
4b2a			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
4b2a			; | | 's' string or 'i' integer 
4b2a					if DEBUG_FORTH_WORDS_KEY 
4b2a						DMARK "STY" 
4b2a f5				push af  
4b2b 3a 3f 4b			ld a, (.dmark)  
4b2e 32 9d fd			ld (debug_mark),a  
4b31 3a 40 4b			ld a, (.dmark+1)  
4b34 32 9e fd			ld (debug_mark+1),a  
4b37 3a 41 4b			ld a, (.dmark+2)  
4b3a 32 9f fd			ld (debug_mark+2),a  
4b3d 18 03			jr .pastdmark  
4b3f ..			.dmark: db "STY"  
4b42 f1			.pastdmark: pop af  
4b43			endm  
# End of macro DMARK
4b43						CALLMONITOR 
4b43 cd aa fd			call debug_vector  
4b46				endm  
# End of macro CALLMONITOR
4b46					endif 
4b46					FORTH_DSP 
4b46 cd 83 21			call macro_forth_dsp 
4b49				endm 
# End of macro FORTH_DSP
4b49					;v5 FORTH_DSP_VALUE 
4b49			 
4b49 7e					ld a, (hl) 
4b4a			 
4b4a f5					push af 
4b4b			 
4b4b			; Dont destroy TOS		FORTH_DSP_POP 
4b4b			 
4b4b f1					pop af 
4b4c			 
4b4c fe 01				cp DS_TYPE_STR 
4b4e 28 09				jr z, .typestr 
4b50			 
4b50 fe 02				cp DS_TYPE_INUM 
4b52 28 0a				jr z, .typeinum 
4b54			 
4b54 21 70 4b				ld hl, .tna 
4b57 18 0a				jr .tpush 
4b59			 
4b59 21 6c 4b		.typestr:	ld hl, .tstr 
4b5c 18 05				jr .tpush 
4b5e 21 6e 4b		.typeinum:	ld hl, .tinum 
4b61 18 00				jr .tpush 
4b63			 
4b63			.tpush: 
4b63			 
4b63 cd 26 20				call forth_push_str 
4b66			 
4b66					NEXTW 
4b66 cd a7 fd			call parse_vector 
4b69 c3 a8 23			jp macro_next 
4b6c				endm 
# End of macro NEXTW
4b6c .. 00		.tstr:	db "s",0 
4b6e .. 00		.tinum:  db "i",0 
4b70 .. 00		.tna:   db "?", 0 
4b72			 
4b72			 
4b72			.UPPER: 
4b72				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4b72 48				db WORD_SYS_CORE+52             
4b73 b0 4b			dw .LOWER            
4b75 06				db 5 + 1 
4b76 .. 00			db "UPPER",0              
4b7c				endm 
# End of macro CWHEAD
4b7c			; | UPPER ( s -- s ) Upper case string s  | DONE 
4b7c					if DEBUG_FORTH_WORDS_KEY 
4b7c						DMARK "UPR" 
4b7c f5				push af  
4b7d 3a 91 4b			ld a, (.dmark)  
4b80 32 9d fd			ld (debug_mark),a  
4b83 3a 92 4b			ld a, (.dmark+1)  
4b86 32 9e fd			ld (debug_mark+1),a  
4b89 3a 93 4b			ld a, (.dmark+2)  
4b8c 32 9f fd			ld (debug_mark+2),a  
4b8f 18 03			jr .pastdmark  
4b91 ..			.dmark: db "UPR"  
4b94 f1			.pastdmark: pop af  
4b95			endm  
# End of macro DMARK
4b95						CALLMONITOR 
4b95 cd aa fd			call debug_vector  
4b98				endm  
# End of macro CALLMONITOR
4b98					endif 
4b98			 
4b98					FORTH_DSP 
4b98 cd 83 21			call macro_forth_dsp 
4b9b				endm 
# End of macro FORTH_DSP
4b9b					 
4b9b			; TODO check is string type 
4b9b			 
4b9b					FORTH_DSP_VALUEHL 
4b9b cd bd 21			call macro_dsp_valuehl 
4b9e				endm 
# End of macro FORTH_DSP_VALUEHL
4b9e			; get pointer to string in hl 
4b9e			 
4b9e 7e			.toup:		ld a, (hl) 
4b9f fe 00				cp 0 
4ba1 28 07				jr z, .toupdone 
4ba3			 
4ba3 cd 53 12				call to_upper 
4ba6			 
4ba6 77					ld (hl), a 
4ba7 23					inc hl 
4ba8 18 f4				jr .toup 
4baa			 
4baa					 
4baa			 
4baa			 
4baa			; for each char convert to upper 
4baa					 
4baa			.toupdone: 
4baa			 
4baa			 
4baa					NEXTW 
4baa cd a7 fd			call parse_vector 
4bad c3 a8 23			jp macro_next 
4bb0				endm 
# End of macro NEXTW
4bb0			.LOWER: 
4bb0				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4bb0 48				db WORD_SYS_CORE+52             
4bb1 ee 4b			dw .TCASE            
4bb3 06				db 5 + 1 
4bb4 .. 00			db "LOWER",0              
4bba				endm 
# End of macro CWHEAD
4bba			; | LOWER ( s -- s ) Lower case string s  | DONE 
4bba					if DEBUG_FORTH_WORDS_KEY 
4bba						DMARK "LWR" 
4bba f5				push af  
4bbb 3a cf 4b			ld a, (.dmark)  
4bbe 32 9d fd			ld (debug_mark),a  
4bc1 3a d0 4b			ld a, (.dmark+1)  
4bc4 32 9e fd			ld (debug_mark+1),a  
4bc7 3a d1 4b			ld a, (.dmark+2)  
4bca 32 9f fd			ld (debug_mark+2),a  
4bcd 18 03			jr .pastdmark  
4bcf ..			.dmark: db "LWR"  
4bd2 f1			.pastdmark: pop af  
4bd3			endm  
# End of macro DMARK
4bd3						CALLMONITOR 
4bd3 cd aa fd			call debug_vector  
4bd6				endm  
# End of macro CALLMONITOR
4bd6					endif 
4bd6			 
4bd6					FORTH_DSP 
4bd6 cd 83 21			call macro_forth_dsp 
4bd9				endm 
# End of macro FORTH_DSP
4bd9					 
4bd9			; TODO check is string type 
4bd9			 
4bd9					FORTH_DSP_VALUEHL 
4bd9 cd bd 21			call macro_dsp_valuehl 
4bdc				endm 
# End of macro FORTH_DSP_VALUEHL
4bdc			; get pointer to string in hl 
4bdc			 
4bdc 7e			.tolow:		ld a, (hl) 
4bdd fe 00				cp 0 
4bdf 28 07				jr z, .tolowdone 
4be1			 
4be1 cd 5c 12				call to_lower 
4be4			 
4be4 77					ld (hl), a 
4be5 23					inc hl 
4be6 18 f4				jr .tolow 
4be8			 
4be8					 
4be8			 
4be8			 
4be8			; for each char convert to low 
4be8					 
4be8			.tolowdone: 
4be8					NEXTW 
4be8 cd a7 fd			call parse_vector 
4beb c3 a8 23			jp macro_next 
4bee				endm 
# End of macro NEXTW
4bee			.TCASE: 
4bee				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4bee 48				db WORD_SYS_CORE+52             
4bef 27 4d			dw .SUBSTR            
4bf1 06				db 5 + 1 
4bf2 .. 00			db "TCASE",0              
4bf8				endm 
# End of macro CWHEAD
4bf8			; | TCASE ( s -- s ) Title case string s  | DONE 
4bf8					if DEBUG_FORTH_WORDS_KEY 
4bf8						DMARK "TCS" 
4bf8 f5				push af  
4bf9 3a 0d 4c			ld a, (.dmark)  
4bfc 32 9d fd			ld (debug_mark),a  
4bff 3a 0e 4c			ld a, (.dmark+1)  
4c02 32 9e fd			ld (debug_mark+1),a  
4c05 3a 0f 4c			ld a, (.dmark+2)  
4c08 32 9f fd			ld (debug_mark+2),a  
4c0b 18 03			jr .pastdmark  
4c0d ..			.dmark: db "TCS"  
4c10 f1			.pastdmark: pop af  
4c11			endm  
# End of macro DMARK
4c11						CALLMONITOR 
4c11 cd aa fd			call debug_vector  
4c14				endm  
# End of macro CALLMONITOR
4c14					endif 
4c14			 
4c14					FORTH_DSP 
4c14 cd 83 21			call macro_forth_dsp 
4c17				endm 
# End of macro FORTH_DSP
4c17					 
4c17			; TODO check is string type 
4c17			 
4c17					FORTH_DSP_VALUEHL 
4c17 cd bd 21			call macro_dsp_valuehl 
4c1a				endm 
# End of macro FORTH_DSP_VALUEHL
4c1a			; get pointer to string in hl 
4c1a			 
4c1a					if DEBUG_FORTH_WORDS 
4c1a						DMARK "TC1" 
4c1a f5				push af  
4c1b 3a 2f 4c			ld a, (.dmark)  
4c1e 32 9d fd			ld (debug_mark),a  
4c21 3a 30 4c			ld a, (.dmark+1)  
4c24 32 9e fd			ld (debug_mark+1),a  
4c27 3a 31 4c			ld a, (.dmark+2)  
4c2a 32 9f fd			ld (debug_mark+2),a  
4c2d 18 03			jr .pastdmark  
4c2f ..			.dmark: db "TC1"  
4c32 f1			.pastdmark: pop af  
4c33			endm  
# End of macro DMARK
4c33						CALLMONITOR 
4c33 cd aa fd			call debug_vector  
4c36				endm  
# End of macro CALLMONITOR
4c36					endif 
4c36			 
4c36					; first time in turn to upper case first char 
4c36			 
4c36 7e					ld a, (hl) 
4c37 c3 c1 4c				jp .totsiptou 
4c3a			 
4c3a			 
4c3a 7e			.tot:		ld a, (hl) 
4c3b fe 00				cp 0 
4c3d ca 05 4d				jp z, .totdone 
4c40			 
4c40					if DEBUG_FORTH_WORDS 
4c40						DMARK "TC2" 
4c40 f5				push af  
4c41 3a 55 4c			ld a, (.dmark)  
4c44 32 9d fd			ld (debug_mark),a  
4c47 3a 56 4c			ld a, (.dmark+1)  
4c4a 32 9e fd			ld (debug_mark+1),a  
4c4d 3a 57 4c			ld a, (.dmark+2)  
4c50 32 9f fd			ld (debug_mark+2),a  
4c53 18 03			jr .pastdmark  
4c55 ..			.dmark: db "TC2"  
4c58 f1			.pastdmark: pop af  
4c59			endm  
# End of macro DMARK
4c59						CALLMONITOR 
4c59 cd aa fd			call debug_vector  
4c5c				endm  
# End of macro CALLMONITOR
4c5c					endif 
4c5c					; check to see if current char is a space 
4c5c			 
4c5c fe 20				cp ' ' 
4c5e 28 21				jr z, .totsp 
4c60 cd 5c 12				call to_lower 
4c63					if DEBUG_FORTH_WORDS 
4c63						DMARK "TC3" 
4c63 f5				push af  
4c64 3a 78 4c			ld a, (.dmark)  
4c67 32 9d fd			ld (debug_mark),a  
4c6a 3a 79 4c			ld a, (.dmark+1)  
4c6d 32 9e fd			ld (debug_mark+1),a  
4c70 3a 7a 4c			ld a, (.dmark+2)  
4c73 32 9f fd			ld (debug_mark+2),a  
4c76 18 03			jr .pastdmark  
4c78 ..			.dmark: db "TC3"  
4c7b f1			.pastdmark: pop af  
4c7c			endm  
# End of macro DMARK
4c7c						CALLMONITOR 
4c7c cd aa fd			call debug_vector  
4c7f				endm  
# End of macro CALLMONITOR
4c7f					endif 
4c7f 18 63				jr .totnxt 
4c81			 
4c81			.totsp:         ; on a space, find next char which should be upper 
4c81			 
4c81					if DEBUG_FORTH_WORDS 
4c81						DMARK "TC4" 
4c81 f5				push af  
4c82 3a 96 4c			ld a, (.dmark)  
4c85 32 9d fd			ld (debug_mark),a  
4c88 3a 97 4c			ld a, (.dmark+1)  
4c8b 32 9e fd			ld (debug_mark+1),a  
4c8e 3a 98 4c			ld a, (.dmark+2)  
4c91 32 9f fd			ld (debug_mark+2),a  
4c94 18 03			jr .pastdmark  
4c96 ..			.dmark: db "TC4"  
4c99 f1			.pastdmark: pop af  
4c9a			endm  
# End of macro DMARK
4c9a						CALLMONITOR 
4c9a cd aa fd			call debug_vector  
4c9d				endm  
# End of macro CALLMONITOR
4c9d					endif 
4c9d					;; 
4c9d			 
4c9d fe 20				cp ' ' 
4c9f 20 20				jr nz, .totsiptou 
4ca1 23					inc hl 
4ca2 7e					ld a, (hl) 
4ca3					if DEBUG_FORTH_WORDS 
4ca3						DMARK "TC5" 
4ca3 f5				push af  
4ca4 3a b8 4c			ld a, (.dmark)  
4ca7 32 9d fd			ld (debug_mark),a  
4caa 3a b9 4c			ld a, (.dmark+1)  
4cad 32 9e fd			ld (debug_mark+1),a  
4cb0 3a ba 4c			ld a, (.dmark+2)  
4cb3 32 9f fd			ld (debug_mark+2),a  
4cb6 18 03			jr .pastdmark  
4cb8 ..			.dmark: db "TC5"  
4cbb f1			.pastdmark: pop af  
4cbc			endm  
# End of macro DMARK
4cbc						CALLMONITOR 
4cbc cd aa fd			call debug_vector  
4cbf				endm  
# End of macro CALLMONITOR
4cbf					endif 
4cbf 18 c0				jr .totsp 
4cc1 fe 00		.totsiptou:    cp 0 
4cc3 28 40				jr z, .totdone 
4cc5					; not space and not zero term so upper case it 
4cc5 cd 53 12				call to_upper 
4cc8			 
4cc8					if DEBUG_FORTH_WORDS 
4cc8						DMARK "TC6" 
4cc8 f5				push af  
4cc9 3a dd 4c			ld a, (.dmark)  
4ccc 32 9d fd			ld (debug_mark),a  
4ccf 3a de 4c			ld a, (.dmark+1)  
4cd2 32 9e fd			ld (debug_mark+1),a  
4cd5 3a df 4c			ld a, (.dmark+2)  
4cd8 32 9f fd			ld (debug_mark+2),a  
4cdb 18 03			jr .pastdmark  
4cdd ..			.dmark: db "TC6"  
4ce0 f1			.pastdmark: pop af  
4ce1			endm  
# End of macro DMARK
4ce1						CALLMONITOR 
4ce1 cd aa fd			call debug_vector  
4ce4				endm  
# End of macro CALLMONITOR
4ce4					endif 
4ce4			 
4ce4			 
4ce4			.totnxt: 
4ce4			 
4ce4 77					ld (hl), a 
4ce5 23					inc hl 
4ce6					if DEBUG_FORTH_WORDS 
4ce6						DMARK "TC7" 
4ce6 f5				push af  
4ce7 3a fb 4c			ld a, (.dmark)  
4cea 32 9d fd			ld (debug_mark),a  
4ced 3a fc 4c			ld a, (.dmark+1)  
4cf0 32 9e fd			ld (debug_mark+1),a  
4cf3 3a fd 4c			ld a, (.dmark+2)  
4cf6 32 9f fd			ld (debug_mark+2),a  
4cf9 18 03			jr .pastdmark  
4cfb ..			.dmark: db "TC7"  
4cfe f1			.pastdmark: pop af  
4cff			endm  
# End of macro DMARK
4cff						CALLMONITOR 
4cff cd aa fd			call debug_vector  
4d02				endm  
# End of macro CALLMONITOR
4d02					endif 
4d02 c3 3a 4c				jp .tot 
4d05			 
4d05					 
4d05			 
4d05			 
4d05			; for each char convert to low 
4d05					 
4d05			.totdone: 
4d05					if DEBUG_FORTH_WORDS 
4d05						DMARK "TCd" 
4d05 f5				push af  
4d06 3a 1a 4d			ld a, (.dmark)  
4d09 32 9d fd			ld (debug_mark),a  
4d0c 3a 1b 4d			ld a, (.dmark+1)  
4d0f 32 9e fd			ld (debug_mark+1),a  
4d12 3a 1c 4d			ld a, (.dmark+2)  
4d15 32 9f fd			ld (debug_mark+2),a  
4d18 18 03			jr .pastdmark  
4d1a ..			.dmark: db "TCd"  
4d1d f1			.pastdmark: pop af  
4d1e			endm  
# End of macro DMARK
4d1e						CALLMONITOR 
4d1e cd aa fd			call debug_vector  
4d21				endm  
# End of macro CALLMONITOR
4d21					endif 
4d21					NEXTW 
4d21 cd a7 fd			call parse_vector 
4d24 c3 a8 23			jp macro_next 
4d27				endm 
# End of macro NEXTW
4d27			 
4d27			.SUBSTR: 
4d27				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4d27 48				db WORD_SYS_CORE+52             
4d28 88 4d			dw .LEFT            
4d2a 07				db 6 + 1 
4d2b .. 00			db "SUBSTR",0              
4d32				endm 
# End of macro CWHEAD
4d32			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4d32			 
4d32					if DEBUG_FORTH_WORDS_KEY 
4d32						DMARK "SST" 
4d32 f5				push af  
4d33 3a 47 4d			ld a, (.dmark)  
4d36 32 9d fd			ld (debug_mark),a  
4d39 3a 48 4d			ld a, (.dmark+1)  
4d3c 32 9e fd			ld (debug_mark+1),a  
4d3f 3a 49 4d			ld a, (.dmark+2)  
4d42 32 9f fd			ld (debug_mark+2),a  
4d45 18 03			jr .pastdmark  
4d47 ..			.dmark: db "SST"  
4d4a f1			.pastdmark: pop af  
4d4b			endm  
# End of macro DMARK
4d4b						CALLMONITOR 
4d4b cd aa fd			call debug_vector  
4d4e				endm  
# End of macro CALLMONITOR
4d4e					endif 
4d4e			; TODO check string type 
4d4e					FORTH_DSP_VALUEHL 
4d4e cd bd 21			call macro_dsp_valuehl 
4d51				endm 
# End of macro FORTH_DSP_VALUEHL
4d51			 
4d51 e5					push hl      ; string length 
4d52			 
4d52					FORTH_DSP_POP 
4d52 cd 75 22			call macro_forth_dsp_pop 
4d55				endm 
# End of macro FORTH_DSP_POP
4d55			 
4d55					FORTH_DSP_VALUEHL 
4d55 cd bd 21			call macro_dsp_valuehl 
4d58				endm 
# End of macro FORTH_DSP_VALUEHL
4d58			 
4d58 e5					push hl     ; start char 
4d59			 
4d59					FORTH_DSP_POP 
4d59 cd 75 22			call macro_forth_dsp_pop 
4d5c				endm 
# End of macro FORTH_DSP_POP
4d5c			 
4d5c			 
4d5c					FORTH_DSP_VALUE 
4d5c cd a6 21			call macro_forth_dsp_value 
4d5f				endm 
# End of macro FORTH_DSP_VALUE
4d5f			 
4d5f d1					pop de    ; get start post offset 
4d60			 
4d60 19					add hl, de    ; starting offset 
4d61			 
4d61 c1					pop bc 
4d62 c5					push bc      ; grab size of string 
4d63			 
4d63 e5					push hl    ; save string start  
4d64			 
4d64 26 00				ld h, 0 
4d66 69					ld l, c 
4d67 23					inc hl 
4d68 23					inc hl 
4d69			 
4d69 cd b9 13				call malloc 
4d6c				if DEBUG_FORTH_MALLOC_GUARD 
4d6c cc dd 64				call z,malloc_error 
4d6f				endif 
4d6f			 
4d6f eb					ex de, hl      ; save malloc area for string copy 
4d70 e1					pop hl    ; get back source 
4d71 c1					pop bc    ; get length of string back 
4d72			 
4d72 d5					push de    ; save malloc area for after we push 
4d73 ed b0				ldir     ; copy substr 
4d75			 
4d75			 
4d75 eb					ex de, hl 
4d76 3e 00				ld a, 0 
4d78 77					ld (hl), a   ; term substr 
4d79			 
4d79					 
4d79 e1					pop hl    ; get malloc so we can push it 
4d7a e5					push hl   ; save so we can free it afterwards 
4d7b			 
4d7b cd 26 20				call forth_push_str 
4d7e			 
4d7e e1					pop hl 
4d7f cd 83 14				call free 
4d82			 
4d82					 
4d82					 
4d82			 
4d82			 
4d82					NEXTW 
4d82 cd a7 fd			call parse_vector 
4d85 c3 a8 23			jp macro_next 
4d88				endm 
# End of macro NEXTW
4d88			 
4d88			.LEFT: 
4d88				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4d88 48				db WORD_SYS_CORE+52             
4d89 cc 4d			dw .RIGHT            
4d8b 05				db 4 + 1 
4d8c .. 00			db "LEFT",0              
4d91				endm 
# End of macro CWHEAD
4d91			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
4d91					if DEBUG_FORTH_WORDS_KEY 
4d91						DMARK "LEF" 
4d91 f5				push af  
4d92 3a a6 4d			ld a, (.dmark)  
4d95 32 9d fd			ld (debug_mark),a  
4d98 3a a7 4d			ld a, (.dmark+1)  
4d9b 32 9e fd			ld (debug_mark+1),a  
4d9e 3a a8 4d			ld a, (.dmark+2)  
4da1 32 9f fd			ld (debug_mark+2),a  
4da4 18 03			jr .pastdmark  
4da6 ..			.dmark: db "LEF"  
4da9 f1			.pastdmark: pop af  
4daa			endm  
# End of macro DMARK
4daa						CALLMONITOR 
4daa cd aa fd			call debug_vector  
4dad				endm  
# End of macro CALLMONITOR
4dad					endif 
4dad			 
4dad					 
4dad			; TODO check string type 
4dad					FORTH_DSP_VALUEHL 
4dad cd bd 21			call macro_dsp_valuehl 
4db0				endm 
# End of macro FORTH_DSP_VALUEHL
4db0			 
4db0 e5					push hl      ; string length 
4db1			 
4db1					FORTH_DSP_POP 
4db1 cd 75 22			call macro_forth_dsp_pop 
4db4				endm 
# End of macro FORTH_DSP_POP
4db4			 
4db4					FORTH_DSP_VALUEHL 
4db4 cd bd 21			call macro_dsp_valuehl 
4db7				endm 
# End of macro FORTH_DSP_VALUEHL
4db7			 
4db7 c1					pop bc 
4db8			 
4db8 11 f3 f0				ld de, scratch 
4dbb ed b0				ldir 
4dbd 3e 00				ld a, 0 
4dbf 12					ld (de), a 
4dc0					 
4dc0 21 f3 f0				ld hl, scratch 
4dc3 cd 26 20				call forth_push_str 
4dc6			 
4dc6					NEXTW 
4dc6 cd a7 fd			call parse_vector 
4dc9 c3 a8 23			jp macro_next 
4dcc				endm 
# End of macro NEXTW
4dcc			.RIGHT: 
4dcc				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4dcc 48				db WORD_SYS_CORE+52             
4dcd 8d 4e			dw .STR2NUM            
4dcf 06				db 5 + 1 
4dd0 .. 00			db "RIGHT",0              
4dd6				endm 
# End of macro CWHEAD
4dd6			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
4dd6					if DEBUG_FORTH_WORDS_KEY 
4dd6						DMARK "RIG" 
4dd6 f5				push af  
4dd7 3a eb 4d			ld a, (.dmark)  
4dda 32 9d fd			ld (debug_mark),a  
4ddd 3a ec 4d			ld a, (.dmark+1)  
4de0 32 9e fd			ld (debug_mark+1),a  
4de3 3a ed 4d			ld a, (.dmark+2)  
4de6 32 9f fd			ld (debug_mark+2),a  
4de9 18 03			jr .pastdmark  
4deb ..			.dmark: db "RIG"  
4dee f1			.pastdmark: pop af  
4def			endm  
# End of macro DMARK
4def						CALLMONITOR 
4def cd aa fd			call debug_vector  
4df2				endm  
# End of macro CALLMONITOR
4df2					endif 
4df2			 
4df2			; TODO check string type 
4df2					FORTH_DSP_VALUEHL 
4df2 cd bd 21			call macro_dsp_valuehl 
4df5				endm 
# End of macro FORTH_DSP_VALUEHL
4df5			 
4df5 e5					push hl      ; string length 
4df6			 
4df6					FORTH_DSP_POP 
4df6 cd 75 22			call macro_forth_dsp_pop 
4df9				endm 
# End of macro FORTH_DSP_POP
4df9			 
4df9					FORTH_DSP_VALUEHL 
4df9 cd bd 21			call macro_dsp_valuehl 
4dfc				endm 
# End of macro FORTH_DSP_VALUEHL
4dfc			 
4dfc					if DEBUG_FORTH_WORDS 
4dfc						DMARK "RI1" 
4dfc f5				push af  
4dfd 3a 11 4e			ld a, (.dmark)  
4e00 32 9d fd			ld (debug_mark),a  
4e03 3a 12 4e			ld a, (.dmark+1)  
4e06 32 9e fd			ld (debug_mark+1),a  
4e09 3a 13 4e			ld a, (.dmark+2)  
4e0c 32 9f fd			ld (debug_mark+2),a  
4e0f 18 03			jr .pastdmark  
4e11 ..			.dmark: db "RI1"  
4e14 f1			.pastdmark: pop af  
4e15			endm  
# End of macro DMARK
4e15						CALLMONITOR 
4e15 cd aa fd			call debug_vector  
4e18				endm  
# End of macro CALLMONITOR
4e18					endif 
4e18					; from the pointer to string get to the end of string 
4e18			 
4e18 01 ff 00				ld bc, 255 
4e1b 3e 00				ld a, 0 
4e1d ed b1				cpir 
4e1f 2b					dec hl 
4e20			 
4e20					;  
4e20			 
4e20					if DEBUG_FORTH_WORDS 
4e20						DMARK "RI2" 
4e20 f5				push af  
4e21 3a 35 4e			ld a, (.dmark)  
4e24 32 9d fd			ld (debug_mark),a  
4e27 3a 36 4e			ld a, (.dmark+1)  
4e2a 32 9e fd			ld (debug_mark+1),a  
4e2d 3a 37 4e			ld a, (.dmark+2)  
4e30 32 9f fd			ld (debug_mark+2),a  
4e33 18 03			jr .pastdmark  
4e35 ..			.dmark: db "RI2"  
4e38 f1			.pastdmark: pop af  
4e39			endm  
# End of macro DMARK
4e39						CALLMONITOR 
4e39 cd aa fd			call debug_vector  
4e3c				endm  
# End of macro CALLMONITOR
4e3c					endif 
4e3c			 
4e3c c1					pop bc    ;  length of string to copy 
4e3d			 
4e3d 79					ld a, c 
4e3e eb					ex de, hl 
4e3f 21 f3 f0				ld hl, scratch  
4e42 cd de 0f				call addatohl 
4e45			 
4e45 eb					ex de, hl 
4e46			 
4e46					if DEBUG_FORTH_WORDS 
4e46						DMARK "RI3" 
4e46 f5				push af  
4e47 3a 5b 4e			ld a, (.dmark)  
4e4a 32 9d fd			ld (debug_mark),a  
4e4d 3a 5c 4e			ld a, (.dmark+1)  
4e50 32 9e fd			ld (debug_mark+1),a  
4e53 3a 5d 4e			ld a, (.dmark+2)  
4e56 32 9f fd			ld (debug_mark+2),a  
4e59 18 03			jr .pastdmark  
4e5b ..			.dmark: db "RI3"  
4e5e f1			.pastdmark: pop af  
4e5f			endm  
# End of macro DMARK
4e5f						CALLMONITOR 
4e5f cd aa fd			call debug_vector  
4e62				endm  
# End of macro CALLMONITOR
4e62					endif 
4e62			 
4e62 03					inc bc 
4e63 ed b8				lddr 
4e65					 
4e65 21 f3 f0				ld hl, scratch 
4e68					if DEBUG_FORTH_WORDS 
4e68						DMARK "RI4" 
4e68 f5				push af  
4e69 3a 7d 4e			ld a, (.dmark)  
4e6c 32 9d fd			ld (debug_mark),a  
4e6f 3a 7e 4e			ld a, (.dmark+1)  
4e72 32 9e fd			ld (debug_mark+1),a  
4e75 3a 7f 4e			ld a, (.dmark+2)  
4e78 32 9f fd			ld (debug_mark+2),a  
4e7b 18 03			jr .pastdmark  
4e7d ..			.dmark: db "RI4"  
4e80 f1			.pastdmark: pop af  
4e81			endm  
# End of macro DMARK
4e81						CALLMONITOR 
4e81 cd aa fd			call debug_vector  
4e84				endm  
# End of macro CALLMONITOR
4e84					endif 
4e84 cd 26 20				call forth_push_str 
4e87			 
4e87			 
4e87					NEXTW 
4e87 cd a7 fd			call parse_vector 
4e8a c3 a8 23			jp macro_next 
4e8d				endm 
# End of macro NEXTW
4e8d			 
4e8d			 
4e8d			.STR2NUM: 
4e8d				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4e8d 48				db WORD_SYS_CORE+52             
4e8e 1c 4f			dw .NUM2STR            
4e90 08				db 7 + 1 
4e91 .. 00			db "STR2NUM",0              
4e99				endm 
# End of macro CWHEAD
4e99			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4e99			 
4e99			 
4e99			; TODO STR type check to do 
4e99					if DEBUG_FORTH_WORDS_KEY 
4e99						DMARK "S2N" 
4e99 f5				push af  
4e9a 3a ae 4e			ld a, (.dmark)  
4e9d 32 9d fd			ld (debug_mark),a  
4ea0 3a af 4e			ld a, (.dmark+1)  
4ea3 32 9e fd			ld (debug_mark+1),a  
4ea6 3a b0 4e			ld a, (.dmark+2)  
4ea9 32 9f fd			ld (debug_mark+2),a  
4eac 18 03			jr .pastdmark  
4eae ..			.dmark: db "S2N"  
4eb1 f1			.pastdmark: pop af  
4eb2			endm  
# End of macro DMARK
4eb2						CALLMONITOR 
4eb2 cd aa fd			call debug_vector  
4eb5				endm  
# End of macro CALLMONITOR
4eb5					endif 
4eb5			 
4eb5					;FORTH_DSP 
4eb5					FORTH_DSP_VALUE 
4eb5 cd a6 21			call macro_forth_dsp_value 
4eb8				endm 
# End of macro FORTH_DSP_VALUE
4eb8					;inc hl 
4eb8			 
4eb8 eb					ex de, hl 
4eb9					if DEBUG_FORTH_WORDS 
4eb9						DMARK "S2a" 
4eb9 f5				push af  
4eba 3a ce 4e			ld a, (.dmark)  
4ebd 32 9d fd			ld (debug_mark),a  
4ec0 3a cf 4e			ld a, (.dmark+1)  
4ec3 32 9e fd			ld (debug_mark+1),a  
4ec6 3a d0 4e			ld a, (.dmark+2)  
4ec9 32 9f fd			ld (debug_mark+2),a  
4ecc 18 03			jr .pastdmark  
4ece ..			.dmark: db "S2a"  
4ed1 f1			.pastdmark: pop af  
4ed2			endm  
# End of macro DMARK
4ed2						CALLMONITOR 
4ed2 cd aa fd			call debug_vector  
4ed5				endm  
# End of macro CALLMONITOR
4ed5					endif 
4ed5 cd db 12				call string_to_uint16 
4ed8			 
4ed8					if DEBUG_FORTH_WORDS 
4ed8						DMARK "S2b" 
4ed8 f5				push af  
4ed9 3a ed 4e			ld a, (.dmark)  
4edc 32 9d fd			ld (debug_mark),a  
4edf 3a ee 4e			ld a, (.dmark+1)  
4ee2 32 9e fd			ld (debug_mark+1),a  
4ee5 3a ef 4e			ld a, (.dmark+2)  
4ee8 32 9f fd			ld (debug_mark+2),a  
4eeb 18 03			jr .pastdmark  
4eed ..			.dmark: db "S2b"  
4ef0 f1			.pastdmark: pop af  
4ef1			endm  
# End of macro DMARK
4ef1						CALLMONITOR 
4ef1 cd aa fd			call debug_vector  
4ef4				endm  
# End of macro CALLMONITOR
4ef4					endif 
4ef4			;		push hl 
4ef4					FORTH_DSP_POP 
4ef4 cd 75 22			call macro_forth_dsp_pop 
4ef7				endm 
# End of macro FORTH_DSP_POP
4ef7			;		pop hl 
4ef7					 
4ef7					if DEBUG_FORTH_WORDS 
4ef7						DMARK "S2b" 
4ef7 f5				push af  
4ef8 3a 0c 4f			ld a, (.dmark)  
4efb 32 9d fd			ld (debug_mark),a  
4efe 3a 0d 4f			ld a, (.dmark+1)  
4f01 32 9e fd			ld (debug_mark+1),a  
4f04 3a 0e 4f			ld a, (.dmark+2)  
4f07 32 9f fd			ld (debug_mark+2),a  
4f0a 18 03			jr .pastdmark  
4f0c ..			.dmark: db "S2b"  
4f0f f1			.pastdmark: pop af  
4f10			endm  
# End of macro DMARK
4f10						CALLMONITOR 
4f10 cd aa fd			call debug_vector  
4f13				endm  
# End of macro CALLMONITOR
4f13					endif 
4f13 cd b8 1f				call forth_push_numhl	 
4f16			 
4f16				 
4f16				       NEXTW 
4f16 cd a7 fd			call parse_vector 
4f19 c3 a8 23			jp macro_next 
4f1c				endm 
# End of macro NEXTW
4f1c			.NUM2STR: 
4f1c				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4f1c 48				db WORD_SYS_CORE+52             
4f1d b1 4f			dw .CONCAT            
4f1f 08				db 7 + 1 
4f20 .. 00			db "NUM2STR",0              
4f28				endm 
# End of macro CWHEAD
4f28			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4f28			 
4f28			;		; malloc a string to target 
4f28			;		ld hl, 10     ; TODO max string size should be fine 
4f28			;		call malloc 
4f28			;		push hl    ; save malloc location 
4f28			; 
4f28			; 
4f28			;; TODO check int type 
4f28					if DEBUG_FORTH_WORDS_KEY 
4f28						DMARK "N2S" 
4f28 f5				push af  
4f29 3a 3d 4f			ld a, (.dmark)  
4f2c 32 9d fd			ld (debug_mark),a  
4f2f 3a 3e 4f			ld a, (.dmark+1)  
4f32 32 9e fd			ld (debug_mark+1),a  
4f35 3a 3f 4f			ld a, (.dmark+2)  
4f38 32 9f fd			ld (debug_mark+2),a  
4f3b 18 03			jr .pastdmark  
4f3d ..			.dmark: db "N2S"  
4f40 f1			.pastdmark: pop af  
4f41			endm  
# End of macro DMARK
4f41						CALLMONITOR 
4f41 cd aa fd			call debug_vector  
4f44				endm  
# End of macro CALLMONITOR
4f44					endif 
4f44			 
4f44					FORTH_DSP_VALUEHL 
4f44 cd bd 21			call macro_dsp_valuehl 
4f47				endm 
# End of macro FORTH_DSP_VALUEHL
4f47			 
4f47					if DEBUG_FORTH_WORDS 
4f47						DMARK "NS1" 
4f47 f5				push af  
4f48 3a 5c 4f			ld a, (.dmark)  
4f4b 32 9d fd			ld (debug_mark),a  
4f4e 3a 5d 4f			ld a, (.dmark+1)  
4f51 32 9e fd			ld (debug_mark+1),a  
4f54 3a 5e 4f			ld a, (.dmark+2)  
4f57 32 9f fd			ld (debug_mark+2),a  
4f5a 18 03			jr .pastdmark  
4f5c ..			.dmark: db "NS1"  
4f5f f1			.pastdmark: pop af  
4f60			endm  
# End of macro DMARK
4f60						CALLMONITOR 
4f60 cd aa fd			call debug_vector  
4f63				endm  
# End of macro CALLMONITOR
4f63					endif 
4f63					FORTH_DSP_POP 
4f63 cd 75 22			call macro_forth_dsp_pop 
4f66				endm 
# End of macro FORTH_DSP_POP
4f66			 
4f66 eb					ex de, hl 
4f67 21 f3 f0				ld hl, scratch 
4f6a					if DEBUG_FORTH_WORDS 
4f6a						DMARK "NS2" 
4f6a f5				push af  
4f6b 3a 7f 4f			ld a, (.dmark)  
4f6e 32 9d fd			ld (debug_mark),a  
4f71 3a 80 4f			ld a, (.dmark+1)  
4f74 32 9e fd			ld (debug_mark+1),a  
4f77 3a 81 4f			ld a, (.dmark+2)  
4f7a 32 9f fd			ld (debug_mark+2),a  
4f7d 18 03			jr .pastdmark  
4f7f ..			.dmark: db "NS2"  
4f82 f1			.pastdmark: pop af  
4f83			endm  
# End of macro DMARK
4f83						CALLMONITOR 
4f83 cd aa fd			call debug_vector  
4f86				endm  
# End of macro CALLMONITOR
4f86					endif 
4f86 cd f3 12				call uitoa_16 
4f89 21 f3 f0				ld hl, scratch 
4f8c					if DEBUG_FORTH_WORDS 
4f8c						DMARK "NS3" 
4f8c f5				push af  
4f8d 3a a1 4f			ld a, (.dmark)  
4f90 32 9d fd			ld (debug_mark),a  
4f93 3a a2 4f			ld a, (.dmark+1)  
4f96 32 9e fd			ld (debug_mark+1),a  
4f99 3a a3 4f			ld a, (.dmark+2)  
4f9c 32 9f fd			ld (debug_mark+2),a  
4f9f 18 03			jr .pastdmark  
4fa1 ..			.dmark: db "NS3"  
4fa4 f1			.pastdmark: pop af  
4fa5			endm  
# End of macro DMARK
4fa5						CALLMONITOR 
4fa5 cd aa fd			call debug_vector  
4fa8				endm  
# End of macro CALLMONITOR
4fa8					endif 
4fa8 cd 26 20				call forth_push_str 
4fab			;		ld a, l 
4fab			;		call DispAToASCII   
4fab			;;TODO need to chage above call to dump into string 
4fab			; 
4fab			; 
4fab			 
4fab				       NEXTW 
4fab cd a7 fd			call parse_vector 
4fae c3 a8 23			jp macro_next 
4fb1				endm 
# End of macro NEXTW
4fb1			 
4fb1			.CONCAT: 
4fb1				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4fb1 48				db WORD_SYS_CORE+52             
4fb2 67 50			dw .FIND            
4fb4 07				db 6 + 1 
4fb5 .. 00			db "CONCAT",0              
4fbc				endm 
# End of macro CWHEAD
4fbc			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4fbc			 
4fbc			; TODO check string type 
4fbc			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4fbc			 
4fbc					if DEBUG_FORTH_WORDS_KEY 
4fbc						DMARK "CON" 
4fbc f5				push af  
4fbd 3a d1 4f			ld a, (.dmark)  
4fc0 32 9d fd			ld (debug_mark),a  
4fc3 3a d2 4f			ld a, (.dmark+1)  
4fc6 32 9e fd			ld (debug_mark+1),a  
4fc9 3a d3 4f			ld a, (.dmark+2)  
4fcc 32 9f fd			ld (debug_mark+2),a  
4fcf 18 03			jr .pastdmark  
4fd1 ..			.dmark: db "CON"  
4fd4 f1			.pastdmark: pop af  
4fd5			endm  
# End of macro DMARK
4fd5						CALLMONITOR 
4fd5 cd aa fd			call debug_vector  
4fd8				endm  
# End of macro CALLMONITOR
4fd8					endif 
4fd8			 
4fd8			 
4fd8					FORTH_DSP_VALUE 
4fd8 cd a6 21			call macro_forth_dsp_value 
4fdb				endm 
# End of macro FORTH_DSP_VALUE
4fdb e5					push hl   ; s2 
4fdc			 
4fdc					FORTH_DSP_POP 
4fdc cd 75 22			call macro_forth_dsp_pop 
4fdf				endm 
# End of macro FORTH_DSP_POP
4fdf			 
4fdf					FORTH_DSP_VALUE 
4fdf cd a6 21			call macro_forth_dsp_value 
4fe2				endm 
# End of macro FORTH_DSP_VALUE
4fe2			 
4fe2 e5					push hl   ; s1 
4fe3			 
4fe3					FORTH_DSP_POP 
4fe3 cd 75 22			call macro_forth_dsp_pop 
4fe6				endm 
# End of macro FORTH_DSP_POP
4fe6					 
4fe6			 
4fe6					; copy s1 
4fe6			 
4fe6				 
4fe6					; save ptr 
4fe6 e1					pop hl  
4fe7 e5					push hl 
4fe8 3e 00				ld a, 0 
4fea cd 4f 13				call strlent 
4fed					;inc hl    ; zer0 
4fed 06 00				ld b, 0 
4fef 4d					ld c, l 
4ff0 e1					pop hl		 
4ff1 11 f3 f0				ld de, scratch	 
4ff4					if DEBUG_FORTH_WORDS 
4ff4						DMARK "CO1" 
4ff4 f5				push af  
4ff5 3a 09 50			ld a, (.dmark)  
4ff8 32 9d fd			ld (debug_mark),a  
4ffb 3a 0a 50			ld a, (.dmark+1)  
4ffe 32 9e fd			ld (debug_mark+1),a  
5001 3a 0b 50			ld a, (.dmark+2)  
5004 32 9f fd			ld (debug_mark+2),a  
5007 18 03			jr .pastdmark  
5009 ..			.dmark: db "CO1"  
500c f1			.pastdmark: pop af  
500d			endm  
# End of macro DMARK
500d						CALLMONITOR 
500d cd aa fd			call debug_vector  
5010				endm  
# End of macro CALLMONITOR
5010					endif 
5010 ed b0				ldir 
5012			 
5012 e1					pop hl 
5013 e5					push hl 
5014 d5					push de 
5015			 
5015			 
5015 3e 00				ld a, 0 
5017 cd 4f 13				call strlent 
501a 23					inc hl    ; zer0 
501b 23					inc hl 
501c 06 00				ld b, 0 
501e 4d					ld c, l 
501f d1					pop de 
5020 e1					pop hl		 
5021					if DEBUG_FORTH_WORDS 
5021						DMARK "CO2" 
5021 f5				push af  
5022 3a 36 50			ld a, (.dmark)  
5025 32 9d fd			ld (debug_mark),a  
5028 3a 37 50			ld a, (.dmark+1)  
502b 32 9e fd			ld (debug_mark+1),a  
502e 3a 38 50			ld a, (.dmark+2)  
5031 32 9f fd			ld (debug_mark+2),a  
5034 18 03			jr .pastdmark  
5036 ..			.dmark: db "CO2"  
5039 f1			.pastdmark: pop af  
503a			endm  
# End of macro DMARK
503a						CALLMONITOR 
503a cd aa fd			call debug_vector  
503d				endm  
# End of macro CALLMONITOR
503d					endif 
503d ed b0				ldir 
503f			 
503f			 
503f			 
503f 21 f3 f0				ld hl, scratch 
5042					if DEBUG_FORTH_WORDS 
5042						DMARK "CO5" 
5042 f5				push af  
5043 3a 57 50			ld a, (.dmark)  
5046 32 9d fd			ld (debug_mark),a  
5049 3a 58 50			ld a, (.dmark+1)  
504c 32 9e fd			ld (debug_mark+1),a  
504f 3a 59 50			ld a, (.dmark+2)  
5052 32 9f fd			ld (debug_mark+2),a  
5055 18 03			jr .pastdmark  
5057 ..			.dmark: db "CO5"  
505a f1			.pastdmark: pop af  
505b			endm  
# End of macro DMARK
505b						CALLMONITOR 
505b cd aa fd			call debug_vector  
505e				endm  
# End of macro CALLMONITOR
505e					endif 
505e			 
505e cd 26 20				call forth_push_str 
5061			 
5061			 
5061			 
5061			 
5061				       NEXTW 
5061 cd a7 fd			call parse_vector 
5064 c3 a8 23			jp macro_next 
5067				endm 
# End of macro NEXTW
5067			 
5067			 
5067			.FIND: 
5067				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
5067 4b				db WORD_SYS_CORE+55             
5068 28 51			dw .LEN            
506a 05				db 4 + 1 
506b .. 00			db "FIND",0              
5070				endm 
# End of macro CWHEAD
5070			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
5070			 
5070					if DEBUG_FORTH_WORDS_KEY 
5070						DMARK "FND" 
5070 f5				push af  
5071 3a 85 50			ld a, (.dmark)  
5074 32 9d fd			ld (debug_mark),a  
5077 3a 86 50			ld a, (.dmark+1)  
507a 32 9e fd			ld (debug_mark+1),a  
507d 3a 87 50			ld a, (.dmark+2)  
5080 32 9f fd			ld (debug_mark+2),a  
5083 18 03			jr .pastdmark  
5085 ..			.dmark: db "FND"  
5088 f1			.pastdmark: pop af  
5089			endm  
# End of macro DMARK
5089						CALLMONITOR 
5089 cd aa fd			call debug_vector  
508c				endm  
# End of macro CALLMONITOR
508c					endif 
508c			 
508c			; TODO check string type 
508c					FORTH_DSP_VALUE 
508c cd a6 21			call macro_forth_dsp_value 
508f				endm 
# End of macro FORTH_DSP_VALUE
508f			 
508f e5					push hl    
5090 7e					ld a,(hl)    ; char to find   
5091			; TODO change char to substr 
5091			 
5091 f5					push af 
5092					 
5092			 
5092			 
5092					if DEBUG_FORTH_WORDS 
5092						DMARK "FN1" 
5092 f5				push af  
5093 3a a7 50			ld a, (.dmark)  
5096 32 9d fd			ld (debug_mark),a  
5099 3a a8 50			ld a, (.dmark+1)  
509c 32 9e fd			ld (debug_mark+1),a  
509f 3a a9 50			ld a, (.dmark+2)  
50a2 32 9f fd			ld (debug_mark+2),a  
50a5 18 03			jr .pastdmark  
50a7 ..			.dmark: db "FN1"  
50aa f1			.pastdmark: pop af  
50ab			endm  
# End of macro DMARK
50ab						CALLMONITOR 
50ab cd aa fd			call debug_vector  
50ae				endm  
# End of macro CALLMONITOR
50ae					endif 
50ae			 
50ae					FORTH_DSP_POP 
50ae cd 75 22			call macro_forth_dsp_pop 
50b1				endm 
# End of macro FORTH_DSP_POP
50b1			 
50b1					; string to search 
50b1			 
50b1					FORTH_DSP_VALUE 
50b1 cd a6 21			call macro_forth_dsp_value 
50b4				endm 
# End of macro FORTH_DSP_VALUE
50b4			 
50b4 d1					pop de  ; d is char to find  
50b5			 
50b5					if DEBUG_FORTH_WORDS 
50b5						DMARK "FN2" 
50b5 f5				push af  
50b6 3a ca 50			ld a, (.dmark)  
50b9 32 9d fd			ld (debug_mark),a  
50bc 3a cb 50			ld a, (.dmark+1)  
50bf 32 9e fd			ld (debug_mark+1),a  
50c2 3a cc 50			ld a, (.dmark+2)  
50c5 32 9f fd			ld (debug_mark+2),a  
50c8 18 03			jr .pastdmark  
50ca ..			.dmark: db "FN2"  
50cd f1			.pastdmark: pop af  
50ce			endm  
# End of macro DMARK
50ce						CALLMONITOR 
50ce cd aa fd			call debug_vector  
50d1				endm  
# End of macro CALLMONITOR
50d1					endif 
50d1					 
50d1 01 00 00				ld bc, 0 
50d4 7e			.findchar:      ld a,(hl) 
50d5 fe 00				cp 0   		 
50d7 28 27				jr z, .finddone     
50d9 ba					cp d 
50da 28 20				jr z, .foundchar 
50dc 03					inc bc 
50dd 23					inc hl 
50de					if DEBUG_FORTH_WORDS 
50de						DMARK "FN3" 
50de f5				push af  
50df 3a f3 50			ld a, (.dmark)  
50e2 32 9d fd			ld (debug_mark),a  
50e5 3a f4 50			ld a, (.dmark+1)  
50e8 32 9e fd			ld (debug_mark+1),a  
50eb 3a f5 50			ld a, (.dmark+2)  
50ee 32 9f fd			ld (debug_mark+2),a  
50f1 18 03			jr .pastdmark  
50f3 ..			.dmark: db "FN3"  
50f6 f1			.pastdmark: pop af  
50f7			endm  
# End of macro DMARK
50f7						CALLMONITOR 
50f7 cd aa fd			call debug_vector  
50fa				endm  
# End of macro CALLMONITOR
50fa					endif 
50fa 18 d8				jr .findchar 
50fc			 
50fc			 
50fc c5			.foundchar:	push bc 
50fd e1					pop hl 
50fe 18 03				jr .findexit 
5100			 
5100			 
5100							 
5100			 
5100			.finddone:     ; got to end of string with no find 
5100 21 00 00				ld hl, 0 
5103			.findexit: 
5103			 
5103					if DEBUG_FORTH_WORDS 
5103						DMARK "FNd" 
5103 f5				push af  
5104 3a 18 51			ld a, (.dmark)  
5107 32 9d fd			ld (debug_mark),a  
510a 3a 19 51			ld a, (.dmark+1)  
510d 32 9e fd			ld (debug_mark+1),a  
5110 3a 1a 51			ld a, (.dmark+2)  
5113 32 9f fd			ld (debug_mark+2),a  
5116 18 03			jr .pastdmark  
5118 ..			.dmark: db "FNd"  
511b f1			.pastdmark: pop af  
511c			endm  
# End of macro DMARK
511c						CALLMONITOR 
511c cd aa fd			call debug_vector  
511f				endm  
# End of macro CALLMONITOR
511f					endif 
511f cd b8 1f			call forth_push_numhl 
5122			 
5122				       NEXTW 
5122 cd a7 fd			call parse_vector 
5125 c3 a8 23			jp macro_next 
5128				endm 
# End of macro NEXTW
5128			 
5128			.LEN: 
5128				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
5128 4c				db WORD_SYS_CORE+56             
5129 95 51			dw .ASC            
512b 06				db 5 + 1 
512c .. 00			db "COUNT",0              
5132				endm 
# End of macro CWHEAD
5132			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
5132			 
5132					if DEBUG_FORTH_WORDS_KEY 
5132						DMARK "CNT" 
5132 f5				push af  
5133 3a 47 51			ld a, (.dmark)  
5136 32 9d fd			ld (debug_mark),a  
5139 3a 48 51			ld a, (.dmark+1)  
513c 32 9e fd			ld (debug_mark+1),a  
513f 3a 49 51			ld a, (.dmark+2)  
5142 32 9f fd			ld (debug_mark+2),a  
5145 18 03			jr .pastdmark  
5147 ..			.dmark: db "CNT"  
514a f1			.pastdmark: pop af  
514b			endm  
# End of macro DMARK
514b						CALLMONITOR 
514b cd aa fd			call debug_vector  
514e				endm  
# End of macro CALLMONITOR
514e					endif 
514e			; TODO check string type 
514e					FORTH_DSP_VALUE 
514e cd a6 21			call macro_forth_dsp_value 
5151				endm 
# End of macro FORTH_DSP_VALUE
5151			 
5151			 
5151					if DEBUG_FORTH_WORDS 
5151						DMARK "CN?" 
5151 f5				push af  
5152 3a 66 51			ld a, (.dmark)  
5155 32 9d fd			ld (debug_mark),a  
5158 3a 67 51			ld a, (.dmark+1)  
515b 32 9e fd			ld (debug_mark+1),a  
515e 3a 68 51			ld a, (.dmark+2)  
5161 32 9f fd			ld (debug_mark+2),a  
5164 18 03			jr .pastdmark  
5166 ..			.dmark: db "CN?"  
5169 f1			.pastdmark: pop af  
516a			endm  
# End of macro DMARK
516a						CALLMONITOR 
516a cd aa fd			call debug_vector  
516d				endm  
# End of macro CALLMONITOR
516d					endif 
516d cd 44 13				call strlenz 
5170					if DEBUG_FORTH_WORDS 
5170						DMARK "CNl" 
5170 f5				push af  
5171 3a 85 51			ld a, (.dmark)  
5174 32 9d fd			ld (debug_mark),a  
5177 3a 86 51			ld a, (.dmark+1)  
517a 32 9e fd			ld (debug_mark+1),a  
517d 3a 87 51			ld a, (.dmark+2)  
5180 32 9f fd			ld (debug_mark+2),a  
5183 18 03			jr .pastdmark  
5185 ..			.dmark: db "CNl"  
5188 f1			.pastdmark: pop af  
5189			endm  
# End of macro DMARK
5189						CALLMONITOR 
5189 cd aa fd			call debug_vector  
518c				endm  
# End of macro CALLMONITOR
518c					endif 
518c			 
518c cd b8 1f				call forth_push_numhl 
518f			 
518f			 
518f			 
518f				       NEXTW 
518f cd a7 fd			call parse_vector 
5192 c3 a8 23			jp macro_next 
5195				endm 
# End of macro NEXTW
5195			.ASC: 
5195				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
5195 4d				db WORD_SYS_CORE+57             
5196 06 52			dw .CHR            
5198 04				db 3 + 1 
5199 .. 00			db "ASC",0              
519d				endm 
# End of macro CWHEAD
519d			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
519d					if DEBUG_FORTH_WORDS_KEY 
519d						DMARK "ASC" 
519d f5				push af  
519e 3a b2 51			ld a, (.dmark)  
51a1 32 9d fd			ld (debug_mark),a  
51a4 3a b3 51			ld a, (.dmark+1)  
51a7 32 9e fd			ld (debug_mark+1),a  
51aa 3a b4 51			ld a, (.dmark+2)  
51ad 32 9f fd			ld (debug_mark+2),a  
51b0 18 03			jr .pastdmark  
51b2 ..			.dmark: db "ASC"  
51b5 f1			.pastdmark: pop af  
51b6			endm  
# End of macro DMARK
51b6						CALLMONITOR 
51b6 cd aa fd			call debug_vector  
51b9				endm  
# End of macro CALLMONITOR
51b9					endif 
51b9					FORTH_DSP_VALUE 
51b9 cd a6 21			call macro_forth_dsp_value 
51bc				endm 
# End of macro FORTH_DSP_VALUE
51bc					;v5 FORTH_DSP_VALUE 
51bc			;		inc hl      ; now at start of numeric as string 
51bc			 
51bc e5					push hl 
51bd			 
51bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51bd cd 75 22			call macro_forth_dsp_pop 
51c0				endm 
# End of macro FORTH_DSP_POP
51c0			 
51c0 e1					pop hl 
51c1			 
51c1					if DEBUG_FORTH_WORDS 
51c1						DMARK "AS1" 
51c1 f5				push af  
51c2 3a d6 51			ld a, (.dmark)  
51c5 32 9d fd			ld (debug_mark),a  
51c8 3a d7 51			ld a, (.dmark+1)  
51cb 32 9e fd			ld (debug_mark+1),a  
51ce 3a d8 51			ld a, (.dmark+2)  
51d1 32 9f fd			ld (debug_mark+2),a  
51d4 18 03			jr .pastdmark  
51d6 ..			.dmark: db "AS1"  
51d9 f1			.pastdmark: pop af  
51da			endm  
# End of macro DMARK
51da						CALLMONITOR 
51da cd aa fd			call debug_vector  
51dd				endm  
# End of macro CALLMONITOR
51dd					endif 
51dd					; push the content of a onto the stack as a value 
51dd			 
51dd 7e					ld a,(hl)   ; get char 
51de 26 00				ld h,0 
51e0 6f					ld l,a 
51e1					if DEBUG_FORTH_WORDS 
51e1						DMARK "AS2" 
51e1 f5				push af  
51e2 3a f6 51			ld a, (.dmark)  
51e5 32 9d fd			ld (debug_mark),a  
51e8 3a f7 51			ld a, (.dmark+1)  
51eb 32 9e fd			ld (debug_mark+1),a  
51ee 3a f8 51			ld a, (.dmark+2)  
51f1 32 9f fd			ld (debug_mark+2),a  
51f4 18 03			jr .pastdmark  
51f6 ..			.dmark: db "AS2"  
51f9 f1			.pastdmark: pop af  
51fa			endm  
# End of macro DMARK
51fa						CALLMONITOR 
51fa cd aa fd			call debug_vector  
51fd				endm  
# End of macro CALLMONITOR
51fd					endif 
51fd cd b8 1f				call forth_push_numhl 
5200			 
5200				       NEXTW 
5200 cd a7 fd			call parse_vector 
5203 c3 a8 23			jp macro_next 
5206				endm 
# End of macro NEXTW
5206			 
5206			.CHR: 
5206				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
5206 4d				db WORD_SYS_CORE+57             
5207 45 52			dw .ENDSTR            
5209 04				db 3 + 1 
520a .. 00			db "CHR",0              
520e				endm 
# End of macro CWHEAD
520e			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
520e					if DEBUG_FORTH_WORDS_KEY 
520e						DMARK "CHR" 
520e f5				push af  
520f 3a 23 52			ld a, (.dmark)  
5212 32 9d fd			ld (debug_mark),a  
5215 3a 24 52			ld a, (.dmark+1)  
5218 32 9e fd			ld (debug_mark+1),a  
521b 3a 25 52			ld a, (.dmark+2)  
521e 32 9f fd			ld (debug_mark+2),a  
5221 18 03			jr .pastdmark  
5223 ..			.dmark: db "CHR"  
5226 f1			.pastdmark: pop af  
5227			endm  
# End of macro DMARK
5227						CALLMONITOR 
5227 cd aa fd			call debug_vector  
522a				endm  
# End of macro CALLMONITOR
522a					endif 
522a					FORTH_DSP_VALUEHL 
522a cd bd 21			call macro_dsp_valuehl 
522d				endm 
# End of macro FORTH_DSP_VALUEHL
522d			 
522d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
522d cd 75 22			call macro_forth_dsp_pop 
5230				endm 
# End of macro FORTH_DSP_POP
5230			 
5230					; save asci byte as a zero term string and push string 
5230			 
5230 7d					ld a,l 
5231 32 f3 f0				ld (scratch), a 
5234			 
5234 3e 00				ld a, 0 
5236 32 f4 f0				ld (scratch+1), a 
5239			 
5239 21 f3 f0				ld hl, scratch 
523c cd 26 20				call forth_push_str 
523f			 
523f			 
523f				       NEXTW 
523f cd a7 fd			call parse_vector 
5242 c3 a8 23			jp macro_next 
5245				endm 
# End of macro NEXTW
5245			 
5245			 
5245			 
5245			 
5245			.ENDSTR: 
5245			; eof 
5245			 
# End of file forth_words_str.asm
5245			include "forth_words_key.asm" 
5245			 
5245			; | ## Keyboard Words 
5245			 
5245			.KEY: 
5245				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
5245 3e				db WORD_SYS_CORE+42             
5246 78 52			dw .KEYDB            
5248 04				db 3 + 1 
5249 .. 00			db "KEY",0              
524d				endm 
# End of macro CWHEAD
524d			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
524d			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
524d			; | | Can use something like this to process: 
524d			; | | > repeat active . key ?dup if emit then #1 until  
524d			 
524d					if DEBUG_FORTH_WORDS_KEY 
524d						DMARK "KEY" 
524d f5				push af  
524e 3a 62 52			ld a, (.dmark)  
5251 32 9d fd			ld (debug_mark),a  
5254 3a 63 52			ld a, (.dmark+1)  
5257 32 9e fd			ld (debug_mark+1),a  
525a 3a 64 52			ld a, (.dmark+2)  
525d 32 9f fd			ld (debug_mark+2),a  
5260 18 03			jr .pastdmark  
5262 ..			.dmark: db "KEY"  
5265 f1			.pastdmark: pop af  
5266			endm  
# End of macro DMARK
5266						CALLMONITOR 
5266 cd aa fd			call debug_vector  
5269				endm  
# End of macro CALLMONITOR
5269					endif 
5269			; TODO currently waits 
5269 cd 0d 7a				call cinndb 
526c					;call cin_wait 
526c 6f					ld l, a 
526d 26 00				ld h, 0 
526f cd b8 1f				call forth_push_numhl 
5272					NEXTW 
5272 cd a7 fd			call parse_vector 
5275 c3 a8 23			jp macro_next 
5278				endm 
# End of macro NEXTW
5278			.KEYDB: 
5278				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
5278 3e				db WORD_SYS_CORE+42             
5279 ad 52			dw .WAITK            
527b 06				db 5 + 1 
527c .. 00			db "KEYDB",0              
5282				endm 
# End of macro CWHEAD
5282			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
5282			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
5282			; | | Can use something like this to process: 
5282			; | | > repeat active . key ?dup if emit then #1 until  
5282			 
5282					if DEBUG_FORTH_WORDS_KEY 
5282						DMARK "KEB" 
5282 f5				push af  
5283 3a 97 52			ld a, (.dmark)  
5286 32 9d fd			ld (debug_mark),a  
5289 3a 98 52			ld a, (.dmark+1)  
528c 32 9e fd			ld (debug_mark+1),a  
528f 3a 99 52			ld a, (.dmark+2)  
5292 32 9f fd			ld (debug_mark+2),a  
5295 18 03			jr .pastdmark  
5297 ..			.dmark: db "KEB"  
529a f1			.pastdmark: pop af  
529b			endm  
# End of macro DMARK
529b						CALLMONITOR 
529b cd aa fd			call debug_vector  
529e				endm  
# End of macro CALLMONITOR
529e					endif 
529e			; TODO currently waits 
529e cd f9 79				call cin 
52a1					;call cin_wait 
52a1 6f					ld l, a 
52a2 26 00				ld h, 0 
52a4 cd b8 1f				call forth_push_numhl 
52a7					NEXTW 
52a7 cd a7 fd			call parse_vector 
52aa c3 a8 23			jp macro_next 
52ad				endm 
# End of macro NEXTW
52ad			.WAITK: 
52ad				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
52ad 3f				db WORD_SYS_CORE+43             
52ae e2 52			dw .ACCEPT            
52b0 06				db 5 + 1 
52b1 .. 00			db "WAITK",0              
52b7				endm 
# End of macro CWHEAD
52b7			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
52b7					if DEBUG_FORTH_WORDS_KEY 
52b7						DMARK "WAI" 
52b7 f5				push af  
52b8 3a cc 52			ld a, (.dmark)  
52bb 32 9d fd			ld (debug_mark),a  
52be 3a cd 52			ld a, (.dmark+1)  
52c1 32 9e fd			ld (debug_mark+1),a  
52c4 3a ce 52			ld a, (.dmark+2)  
52c7 32 9f fd			ld (debug_mark+2),a  
52ca 18 03			jr .pastdmark  
52cc ..			.dmark: db "WAI"  
52cf f1			.pastdmark: pop af  
52d0			endm  
# End of macro DMARK
52d0						CALLMONITOR 
52d0 cd aa fd			call debug_vector  
52d3				endm  
# End of macro CALLMONITOR
52d3					endif 
52d3 cd e8 79				call cin_wait 
52d6 6f					ld l, a 
52d7 26 00				ld h, 0 
52d9 cd b8 1f				call forth_push_numhl 
52dc					NEXTW 
52dc cd a7 fd			call parse_vector 
52df c3 a8 23			jp macro_next 
52e2				endm 
# End of macro NEXTW
52e2			.ACCEPT: 
52e2				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
52e2 40				db WORD_SYS_CORE+44             
52e3 43 53			dw .EDIT            
52e5 07				db 6 + 1 
52e6 .. 00			db "ACCEPT",0              
52ed				endm 
# End of macro CWHEAD
52ed			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
52ed					; TODO crashes on push 
52ed					if DEBUG_FORTH_WORDS_KEY 
52ed						DMARK "ACC" 
52ed f5				push af  
52ee 3a 02 53			ld a, (.dmark)  
52f1 32 9d fd			ld (debug_mark),a  
52f4 3a 03 53			ld a, (.dmark+1)  
52f7 32 9e fd			ld (debug_mark+1),a  
52fa 3a 04 53			ld a, (.dmark+2)  
52fd 32 9f fd			ld (debug_mark+2),a  
5300 18 03			jr .pastdmark  
5302 ..			.dmark: db "ACC"  
5305 f1			.pastdmark: pop af  
5306			endm  
# End of macro DMARK
5306						CALLMONITOR 
5306 cd aa fd			call debug_vector  
5309				endm  
# End of macro CALLMONITOR
5309					endif 
5309 21 f1 f2				ld hl, os_input 
530c 3e 00				ld a, 0 
530e 77					ld (hl),a 
530f 3a 90 f9				ld a,(f_cursor_ptr) 
5312 16 64				ld d, 100 
5314 0e 00				ld c, 0 
5316 1e 28				ld e, 40 
5318 cd 0b 10				call input_str 
531b					; TODO perhaps do a type check and wrap in quotes if not a number 
531b 21 f1 f2				ld hl, os_input 
531e					if DEBUG_FORTH_WORDS 
531e						DMARK "AC1" 
531e f5				push af  
531f 3a 33 53			ld a, (.dmark)  
5322 32 9d fd			ld (debug_mark),a  
5325 3a 34 53			ld a, (.dmark+1)  
5328 32 9e fd			ld (debug_mark+1),a  
532b 3a 35 53			ld a, (.dmark+2)  
532e 32 9f fd			ld (debug_mark+2),a  
5331 18 03			jr .pastdmark  
5333 ..			.dmark: db "AC1"  
5336 f1			.pastdmark: pop af  
5337			endm  
# End of macro DMARK
5337						CALLMONITOR 
5337 cd aa fd			call debug_vector  
533a				endm  
# End of macro CALLMONITOR
533a					endif 
533a cd 26 20				call forth_push_str 
533d					NEXTW 
533d cd a7 fd			call parse_vector 
5340 c3 a8 23			jp macro_next 
5343				endm 
# End of macro NEXTW
5343			 
5343			.EDIT: 
5343				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
5343 40				db WORD_SYS_CORE+44             
5344 e8 53			dw .DEDIT            
5346 05				db 4 + 1 
5347 .. 00			db "EDIT",0              
534c				endm 
# End of macro CWHEAD
534c			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
534c			 
534c					; TODO does not copy from stack 
534c					if DEBUG_FORTH_WORDS_KEY 
534c						DMARK "EDT" 
534c f5				push af  
534d 3a 61 53			ld a, (.dmark)  
5350 32 9d fd			ld (debug_mark),a  
5353 3a 62 53			ld a, (.dmark+1)  
5356 32 9e fd			ld (debug_mark+1),a  
5359 3a 63 53			ld a, (.dmark+2)  
535c 32 9f fd			ld (debug_mark+2),a  
535f 18 03			jr .pastdmark  
5361 ..			.dmark: db "EDT"  
5364 f1			.pastdmark: pop af  
5365			endm  
# End of macro DMARK
5365						CALLMONITOR 
5365 cd aa fd			call debug_vector  
5368				endm  
# End of macro CALLMONITOR
5368					endif 
5368			 
5368					;FORTH_DSP 
5368					FORTH_DSP_VALUEHL 
5368 cd bd 21			call macro_dsp_valuehl 
536b				endm 
# End of macro FORTH_DSP_VALUEHL
536b			;		inc hl    ; TODO do type check 
536b			 
536b			;		call get_word_hl 
536b e5					push hl 
536c					if DEBUG_FORTH_WORDS 
536c						DMARK "EDp" 
536c f5				push af  
536d 3a 81 53			ld a, (.dmark)  
5370 32 9d fd			ld (debug_mark),a  
5373 3a 82 53			ld a, (.dmark+1)  
5376 32 9e fd			ld (debug_mark+1),a  
5379 3a 83 53			ld a, (.dmark+2)  
537c 32 9f fd			ld (debug_mark+2),a  
537f 18 03			jr .pastdmark  
5381 ..			.dmark: db "EDp"  
5384 f1			.pastdmark: pop af  
5385			endm  
# End of macro DMARK
5385						CALLMONITOR 
5385 cd aa fd			call debug_vector  
5388				endm  
# End of macro CALLMONITOR
5388					endif 
5388				;	ld a, 0 
5388 cd 44 13				call strlenz 
538b 23					inc hl 
538c			 
538c 06 00				ld b, 0 
538e 4d					ld c, l 
538f			 
538f e1					pop hl 
5390 11 f1 f2				ld de, os_input 
5393					if DEBUG_FORTH_WORDS_KEY 
5393						DMARK "EDc" 
5393 f5				push af  
5394 3a a8 53			ld a, (.dmark)  
5397 32 9d fd			ld (debug_mark),a  
539a 3a a9 53			ld a, (.dmark+1)  
539d 32 9e fd			ld (debug_mark+1),a  
53a0 3a aa 53			ld a, (.dmark+2)  
53a3 32 9f fd			ld (debug_mark+2),a  
53a6 18 03			jr .pastdmark  
53a8 ..			.dmark: db "EDc"  
53ab f1			.pastdmark: pop af  
53ac			endm  
# End of macro DMARK
53ac						CALLMONITOR 
53ac cd aa fd			call debug_vector  
53af				endm  
# End of macro CALLMONITOR
53af					endif 
53af ed b0				ldir 
53b1			 
53b1			 
53b1 21 f1 f2				ld hl, os_input 
53b4					;ld a, 0 
53b4					;ld (hl),a 
53b4 3a 90 f9				ld a,(f_cursor_ptr) 
53b7 16 64				ld d, 100 
53b9 0e 00				ld c, 0 
53bb 1e 28				ld e, 40 
53bd cd 0b 10				call input_str 
53c0					; TODO perhaps do a type check and wrap in quotes if not a number 
53c0 21 f1 f2				ld hl, os_input 
53c3					if DEBUG_FORTH_WORDS 
53c3						DMARK "ED1" 
53c3 f5				push af  
53c4 3a d8 53			ld a, (.dmark)  
53c7 32 9d fd			ld (debug_mark),a  
53ca 3a d9 53			ld a, (.dmark+1)  
53cd 32 9e fd			ld (debug_mark+1),a  
53d0 3a da 53			ld a, (.dmark+2)  
53d3 32 9f fd			ld (debug_mark+2),a  
53d6 18 03			jr .pastdmark  
53d8 ..			.dmark: db "ED1"  
53db f1			.pastdmark: pop af  
53dc			endm  
# End of macro DMARK
53dc						CALLMONITOR 
53dc cd aa fd			call debug_vector  
53df				endm  
# End of macro CALLMONITOR
53df					endif 
53df cd 26 20				call forth_push_str 
53e2					NEXTW 
53e2 cd a7 fd			call parse_vector 
53e5 c3 a8 23			jp macro_next 
53e8				endm 
# End of macro NEXTW
53e8			 
53e8			.DEDIT: 
53e8				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
53e8 40				db WORD_SYS_CORE+44             
53e9 4d 54			dw .ENDKEY            
53eb 06				db 5 + 1 
53ec .. 00			db "DEDIT",0              
53f2				endm 
# End of macro CWHEAD
53f2			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
53f2			 
53f2					; TODO does not copy from stack 
53f2					if DEBUG_FORTH_WORDS_KEY 
53f2						DMARK "DED" 
53f2 f5				push af  
53f3 3a 07 54			ld a, (.dmark)  
53f6 32 9d fd			ld (debug_mark),a  
53f9 3a 08 54			ld a, (.dmark+1)  
53fc 32 9e fd			ld (debug_mark+1),a  
53ff 3a 09 54			ld a, (.dmark+2)  
5402 32 9f fd			ld (debug_mark+2),a  
5405 18 03			jr .pastdmark  
5407 ..			.dmark: db "DED"  
540a f1			.pastdmark: pop af  
540b			endm  
# End of macro DMARK
540b						CALLMONITOR 
540b cd aa fd			call debug_vector  
540e				endm  
# End of macro CALLMONITOR
540e					endif 
540e			 
540e					;FORTH_DSP 
540e					FORTH_DSP_VALUEHL 
540e cd bd 21			call macro_dsp_valuehl 
5411				endm 
# End of macro FORTH_DSP_VALUEHL
5411			;		inc hl    ; TODO do type check 
5411			 
5411			;		call get_word_hl 
5411 e5					push hl 
5412 e5					push hl 
5413					FORTH_DSP_POP 
5413 cd 75 22			call macro_forth_dsp_pop 
5416				endm 
# End of macro FORTH_DSP_POP
5416 e1					pop hl 
5417					if DEBUG_FORTH_WORDS 
5417						DMARK "EDp" 
5417 f5				push af  
5418 3a 2c 54			ld a, (.dmark)  
541b 32 9d fd			ld (debug_mark),a  
541e 3a 2d 54			ld a, (.dmark+1)  
5421 32 9e fd			ld (debug_mark+1),a  
5424 3a 2e 54			ld a, (.dmark+2)  
5427 32 9f fd			ld (debug_mark+2),a  
542a 18 03			jr .pastdmark  
542c ..			.dmark: db "EDp"  
542f f1			.pastdmark: pop af  
5430			endm  
# End of macro DMARK
5430						CALLMONITOR 
5430 cd aa fd			call debug_vector  
5433				endm  
# End of macro CALLMONITOR
5433					endif 
5433				;	ld a, 0 
5433 cd 44 13				call strlenz 
5436 23					inc hl 
5437			 
5437 06 00				ld b, 0 
5439 4d					ld c, l 
543a			 
543a e1					pop hl 
543b			 
543b					;ld a, 0 
543b					;ld (hl),a 
543b 3a 90 f9				ld a,(f_cursor_ptr) 
543e 16 64				ld d, 100 
5440 0e 00				ld c, 0 
5442 1e 28				ld e, 40 
5444 cd 0b 10				call input_str 
5447					; TODO perhaps do a type check and wrap in quotes if not a number 
5447					NEXTW 
5447 cd a7 fd			call parse_vector 
544a c3 a8 23			jp macro_next 
544d				endm 
# End of macro NEXTW
544d			 
544d			 
544d			.ENDKEY: 
544d			; eof 
544d			 
# End of file forth_words_key.asm
544d			include "forth_words_const.asm" 
544d			 
544d			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
544d			 
544d			 
544d			.SPITIME: 
544d				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
544d 77				db WORD_SYS_CORE+99             
544e 65 54			dw .VA            
5450 08				db 7 + 1 
5451 .. 00			db "SPITIME",0              
5459				endm 
# End of macro CWHEAD
5459			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
5459			; 
5459			; | | If using BANK devices then leave as is. 
5459			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
5459			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
5459			 
5459 21 96 f9				ld hl, spi_clktime  
545c cd b8 1f				call forth_push_numhl 
545f			 
545f					NEXTW 
545f cd a7 fd			call parse_vector 
5462 c3 a8 23			jp macro_next 
5465				endm 
# End of macro NEXTW
5465			 
5465			 
5465			.VA: 
5465				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
5465 77				db WORD_SYS_CORE+99             
5466 78 54			dw .SYMBOL            
5468 03				db 2 + 1 
5469 .. 00			db "VA",0              
546c				endm 
# End of macro CWHEAD
546c			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
546c 21 5a f9				ld hl, cli_var_array 
546f cd b8 1f				call forth_push_numhl 
5472			 
5472					NEXTW 
5472 cd a7 fd			call parse_vector 
5475 c3 a8 23			jp macro_next 
5478				endm 
# End of macro NEXTW
5478			 
5478			.SYMBOL: 
5478				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
5478 77				db WORD_SYS_CORE+99             
5479 87 55			dw .ENDCONST            
547b 07				db 6 + 1 
547c .. 00			db "SYMBOL",0              
5483				endm 
# End of macro CWHEAD
5483			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
5483			; | 
5483			; | | The value is the number reference and the final address is pushed to stack 
5483			 
5483			; | | ``` 
5483			; | | dw sym_table 
5483			; | | dw nmi_vector 
5483			; | | dw cli_autodisplay 
5483			; | | dw cli_data_sp 
5483			; | | dw cli_data_stack 
5483			; | | dw cli_loop_sp 
5483			; | | dw cli_loop_stack 
5483			; | | dw cli_var_array 
5483			; | | dw cursor_col 
5483			; | | dw cursor_ptr 
5483			; | | ; 10 
5483			; | | dw cursor_row 
5483			; | | dw debug_mark 
5483			; | | dw display_fb0 
5483			; | | dw display_fb1 
5483			; | | dw display_fb2 
5483			; | | dw display_fb3 
5483			; | | dw display_fb_active 
5483			; | | dw execscratch 
5483			; | | dw f_cursor_ptr 
5483			; | | dw hardware_word 
5483			; | | ;20 
5483			; | | dw input_at_cursor 
5483			; | | dw input_at_pos 
5483			; | | dw input_cur_flash 
5483			; | | dw input_cur_onoff 
5483			; | | dw input_cursor 
5483			; | | dw input_display_size 
5483			; | | dw input_len 
5483			; | | dw input_ptr 
5483			; | | dw input_size 
5483			; | | dw input_start 
5483			; | | ; 30 
5483			; | | dw input_str 
5483			; | | dw input_under_cursor 
5483			; | | dw os_cli_cmd 
5483			; | | dw os_cur_ptr 
5483			; | | dw os_current_i 
5483			; | | dw os_input 
5483			; | | dw os_last_cmd 
5483			; | | dw os_last_new_uword 
5483			; | | dw debug_vector 
5483			; | | dw os_view_hl 
5483			; | | ;40 
5483			; | | dw os_word_scratch 
5483			; | | dw portbctl 
5483			; | | dw portbdata 
5483			; | | dw spi_cartdev 
5483			; | | dw spi_cartdev2 
5483			; | | dw spi_clktime 
5483			; | | dw spi_device 
5483			; | | dw spi_device_id 
5483			; | | dw spi_portbyte 
5483			; | | dw stackstore 
5483			; | | ; 50 
5483			; | | if STORAGE_SE 
5483			; | | dw storage_actl 
5483			; | | dw storage_adata 
5483			; | | else 
5483			; | | dw 0 
5483			; | | dw 0 
5483			; | | endif 
5483			; | | dw storage_append 
5483			; | | if STORAGE_SE 
5483			; | | dw storage_bctl 
5483			; | | else 
5483			; | | dw 0 
5483			; | | endif 
5483			; | | dw store_bank_active 
5483			; | | dw store_filecache 
5483			; | | dw store_longread 
5483			; | | dw store_openaddr 
5483			; | | dw store_openext 
5483			; | | dw store_openmaxext 
5483			; | | ; 60 
5483			; | | dw store_page 
5483			; | | dw store_readbuf 
5483			; | | dw store_readcont 
5483			; | | dw store_readptr 
5483			; | | dw store_tmpext 
5483			; | | dw store_tmpid 
5483			; | | dw store_tmppageid 
5483			; | | dw malloc 
5483			; | | dw free 
5483			; | | dw cin 
5483			; | | ; 70 
5483			; | | dw cin_wait 
5483			; | | dw forth_push_numhl 
5483			; | | dw forth_push_str 
5483			; | | dw parse_vector 
5483			; | | ``` 
5483			 
5483					if DEBUG_FORTH_WORDS_KEY 
5483						DMARK "SYM" 
5483 f5				push af  
5484 3a 98 54			ld a, (.dmark)  
5487 32 9d fd			ld (debug_mark),a  
548a 3a 99 54			ld a, (.dmark+1)  
548d 32 9e fd			ld (debug_mark+1),a  
5490 3a 9a 54			ld a, (.dmark+2)  
5493 32 9f fd			ld (debug_mark+2),a  
5496 18 03			jr .pastdmark  
5498 ..			.dmark: db "SYM"  
549b f1			.pastdmark: pop af  
549c			endm  
# End of macro DMARK
549c						CALLMONITOR 
549c cd aa fd			call debug_vector  
549f				endm  
# End of macro CALLMONITOR
549f					endif 
549f			 
549f					FORTH_DSP_VALUEHL 
549f cd bd 21			call macro_dsp_valuehl 
54a2				endm 
# End of macro FORTH_DSP_VALUEHL
54a2			 
54a2 7d					ld a, l     
54a3			 
54a3			 
54a3					if DEBUG_FORTH_WORDS 
54a3						DMARK "SY1" 
54a3 f5				push af  
54a4 3a b8 54			ld a, (.dmark)  
54a7 32 9d fd			ld (debug_mark),a  
54aa 3a b9 54			ld a, (.dmark+1)  
54ad 32 9e fd			ld (debug_mark+1),a  
54b0 3a ba 54			ld a, (.dmark+2)  
54b3 32 9f fd			ld (debug_mark+2),a  
54b6 18 03			jr .pastdmark  
54b8 ..			.dmark: db "SY1"  
54bb f1			.pastdmark: pop af  
54bc			endm  
# End of macro DMARK
54bc						CALLMONITOR 
54bc cd aa fd			call debug_vector  
54bf				endm  
# End of macro CALLMONITOR
54bf					endif 
54bf					 
54bf f5					push af	 
54c0					FORTH_DSP_POP 
54c0 cd 75 22			call macro_forth_dsp_pop 
54c3				endm 
# End of macro FORTH_DSP_POP
54c3 f1					pop af 
54c4			 
54c4 cb 27				sla a  
54c6				 
54c6					 
54c6					if DEBUG_FORTH_WORDS 
54c6						DMARK "SY" 
54c6 f5				push af  
54c7 3a db 54			ld a, (.dmark)  
54ca 32 9d fd			ld (debug_mark),a  
54cd 3a dc 54			ld a, (.dmark+1)  
54d0 32 9e fd			ld (debug_mark+1),a  
54d3 3a dd 54			ld a, (.dmark+2)  
54d6 32 9f fd			ld (debug_mark+2),a  
54d9 18 02			jr .pastdmark  
54db ..			.dmark: db "SY"  
54dd f1			.pastdmark: pop af  
54de			endm  
# End of macro DMARK
54de						CALLMONITOR 
54de cd aa fd			call debug_vector  
54e1				endm  
# End of macro CALLMONITOR
54e1					endif 
54e1			 
54e1 21 f3 54				ld hl, sym_table 
54e4 cd de 0f				call addatohl 
54e7 cd 2a 23				call loadwordinhl 
54ea cd b8 1f				call forth_push_numhl 
54ed			 
54ed			 
54ed				       NEXTW 
54ed cd a7 fd			call parse_vector 
54f0 c3 a8 23			jp macro_next 
54f3				endm 
# End of macro NEXTW
54f3			 
54f3			sym_table: 
54f3			 
54f3			; 0 
54f3 f3 54		dw sym_table 
54f5 ad fd		dw nmi_vector 
54f7 6e f9		dw cli_autodisplay 
54f9 20 f9		dw cli_data_sp 
54fb 5a f6		dw cli_data_stack 
54fd 22 f9		dw cli_loop_sp 
54ff 5c f8		dw cli_loop_stack 
5501 5a f9		dw cli_var_array 
5503 f7 fa		dw cursor_col 
5505 f5 fa		dw cursor_ptr 
5507			; 10 
5507 f6 fa		dw cursor_row 
5509 9d fd		dw debug_mark 
550b e3 fc		dw display_fb0 
550d 42 fc		dw display_fb1 
550f 00 fb		dw display_fb2 
5511 a1 fb		dw display_fb3 
5513 fe fa		dw display_fb_active 
5515 f2 f1		dw execscratch 
5517 90 f9		dw f_cursor_ptr 
5519 b0 fd		dw hardware_word 
551b			;20 
551b 94 fd		dw input_at_cursor 
551d 96 fd		dw input_at_pos 
551f 92 fd		dw input_cur_flash 
5521 91 fd		dw input_cur_onoff 
5523 87 fd		dw input_cursor 
5525 97 fd		dw input_display_size 
5527 8c fd		dw input_len 
5529 9b fd		dw input_ptr 
552b 98 fd		dw input_size 
552d 99 fd		dw input_start 
552f			; 30 
552f 0b 10		dw input_str 
5531 95 fd		dw input_under_cursor 
5533 1a f4		dw os_cli_cmd 
5535 16 f4		dw os_cur_ptr 
5537 18 f4		dw os_current_i 
5539 f1 f2		dw os_input 
553b 19 f5		dw os_last_cmd 
553d f0 f3		dw os_last_new_uword 
553f aa fd		dw debug_vector 
5541 d5 f0		dw os_view_hl 
5543			;40 
5543 f8 f3		dw os_word_scratch 
5545 c3 00		dw portbctl 
5547 c1 00		dw portbdata 
5549 95 f9		dw spi_cartdev 
554b 94 f9		dw spi_cartdev2 
554d 96 f9		dw spi_clktime 
554f 92 f9		dw spi_device 
5551 91 f9		dw spi_device_id 
5553 93 f9		dw spi_portbyte 
5555 d9 fa		dw stackstore 
5557			; 50 
5557			if STORAGE_SE 
5557 82 00		dw storage_actl 
5559 80 00		dw storage_adata 
555b			else 
555b			dw 0 
555b			dw 0 
555b			endif 
555b 64 0b		dw storage_append 
555d			if STORAGE_SE 
555d 83 00		dw storage_bctl 
555f			else 
555f			dw 0 
555f			endif 
555f c5 fa		dw store_bank_active 
5561 99 f9		dw store_filecache 
5563 a7 f9		dw store_longread 
5565 9d f9		dw store_openaddr 
5567 9c f9		dw store_openext 
5569 9b f9		dw store_openmaxext 
556b			; 60 
556b ac f9		dw store_page 
556d a8 f9		dw store_readbuf 
556f 9f f9		dw store_readcont 
5571 aa f9		dw store_readptr 
5573 9f f9		dw store_tmpext 
5575 a0 f9		dw store_tmpid 
5577 97 f9		dw store_tmppageid 
5579 b9 13		dw malloc 
557b 83 14		dw free 
557d f9 79		dw cin 
557f			; 70 
557f e8 79		dw cin_wait 
5581 b8 1f		dw forth_push_numhl 
5583 26 20		dw forth_push_str 
5585 a7 fd		dw parse_vector 
5587			 
5587			.ENDCONST: 
5587			 
5587			; eof 
5587			 
5587			 
# End of file forth_words_const.asm
5587			 
5587			if STORAGE_SE 
5587			   	include "forth_words_storage.asm" 
5587			 
5587			; | ## Fixed Storage Words 
5587			 
5587			.RENAME: 
5587			  
5587				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
5587 3a				db WORD_SYS_CORE+38             
5588 80 56			dw .RECORD            
558a 07				db 6 + 1 
558b .. 00			db "RENAME",0              
5592				endm 
# End of macro CWHEAD
5592			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
5592			; | | > [!NOTE] 
5592			; | | > Compatible with PicoSPINet  
5592					if DEBUG_FORTH_WORDS_KEY 
5592						DMARK "REN" 
5592 f5				push af  
5593 3a a7 55			ld a, (.dmark)  
5596 32 9d fd			ld (debug_mark),a  
5599 3a a8 55			ld a, (.dmark+1)  
559c 32 9e fd			ld (debug_mark+1),a  
559f 3a a9 55			ld a, (.dmark+2)  
55a2 32 9f fd			ld (debug_mark+2),a  
55a5 18 03			jr .pastdmark  
55a7 ..			.dmark: db "REN"  
55aa f1			.pastdmark: pop af  
55ab			endm  
# End of macro DMARK
55ab						CALLMONITOR 
55ab cd aa fd			call debug_vector  
55ae				endm  
# End of macro CALLMONITOR
55ae					endif 
55ae			 
55ae			 
55ae					; preserve some internal vars used by other file handing routines 
55ae			 
55ae 2a 9d f9				ld hl, (store_openaddr) 
55b1 e5					push hl 
55b2 3a 9f f9				ld a, (store_readcont) 
55b5 f5					push af 
55b6			 
55b6					FORTH_DSP_VALUEHL 
55b6 cd bd 21			call macro_dsp_valuehl 
55b9				endm 
# End of macro FORTH_DSP_VALUEHL
55b9			 
55b9					; move ext and id around for the file header 
55b9			 
55b9 65					ld h, l 
55ba 2e 00				ld l, 0 
55bc			 
55bc e5					push hl    ; id 
55bd			 
55bd					FORTH_DSP_POP 
55bd cd 75 22			call macro_forth_dsp_pop 
55c0				endm 
# End of macro FORTH_DSP_POP
55c0			 
55c0					; Locate the file header 
55c0			 
55c0 e1					pop hl 
55c1 e5					push hl 
55c2 11 ac f9				ld de, store_page      ; get block zero of file 
55c5					if DEBUG_FORTH_WORDS 
55c5						DMARK "REr" 
55c5 f5				push af  
55c6 3a da 55			ld a, (.dmark)  
55c9 32 9d fd			ld (debug_mark),a  
55cc 3a db 55			ld a, (.dmark+1)  
55cf 32 9e fd			ld (debug_mark+1),a  
55d2 3a dc 55			ld a, (.dmark+2)  
55d5 32 9f fd			ld (debug_mark+2),a  
55d8 18 03			jr .pastdmark  
55da ..			.dmark: db "REr"  
55dd f1			.pastdmark: pop af  
55de			endm  
# End of macro DMARK
55de						CALLMONITOR 
55de cd aa fd			call debug_vector  
55e1				endm  
# End of macro CALLMONITOR
55e1					endif 
55e1 cd cd 09				call storage_read 
55e4			 
55e4 cd 07 10			call ishlzero 
55e7 20 05			jr nz, .rnfound 
55e9			 
55e9				; file does not exist so indicate with 255 extents in use 
55e9			 
55e9 3e ff			ld a, 255 
55eb e1				pop hl ; clear dup hl 
55ec 18 7b			jr .skiprneof 
55ee			 
55ee			 
55ee			.rnfound: 
55ee					; file found so rename 
55ee			 
55ee					FORTH_DSP_VALUEHL 
55ee cd bd 21			call macro_dsp_valuehl 
55f1				endm 
# End of macro FORTH_DSP_VALUEHL
55f1			 
55f1 e5				push hl 
55f2 3e 00			ld a, 0 
55f4 cd 4f 13			call strlent 
55f7 23				inc hl   ; cover zero term 
55f8 06 00			ld b,0 
55fa 4d				ld c,l 
55fb e1				pop hl 
55fc 11 af f9				ld de, store_page + 3 
55ff ed b0				ldir 
5601			 
5601 11 ac f9				ld de, store_page 
5604					if DEBUG_FORTH_WORDS 
5604						DMARK "RER" 
5604 f5				push af  
5605 3a 19 56			ld a, (.dmark)  
5608 32 9d fd			ld (debug_mark),a  
560b 3a 1a 56			ld a, (.dmark+1)  
560e 32 9e fd			ld (debug_mark+1),a  
5611 3a 1b 56			ld a, (.dmark+2)  
5614 32 9f fd			ld (debug_mark+2),a  
5617 18 03			jr .pastdmark  
5619 ..			.dmark: db "RER"  
561c f1			.pastdmark: pop af  
561d			endm  
# End of macro DMARK
561d						CALLMONITOR 
561d cd aa fd			call debug_vector  
5620				endm  
# End of macro CALLMONITOR
5620					endif 
5620			 
5620 e1					pop hl    ; get orig file id and mangle it for find id 
5621 55					ld d, l 
5622 5c					ld e, h 
5623			 
5623 21 00 00				ld hl, 0 
5626					if DEBUG_FORTH_WORDS 
5626						DMARK "REf" 
5626 f5				push af  
5627 3a 3b 56			ld a, (.dmark)  
562a 32 9d fd			ld (debug_mark),a  
562d 3a 3c 56			ld a, (.dmark+1)  
5630 32 9e fd			ld (debug_mark+1),a  
5633 3a 3d 56			ld a, (.dmark+2)  
5636 32 9f fd			ld (debug_mark+2),a  
5639 18 03			jr .pastdmark  
563b ..			.dmark: db "REf"  
563e f1			.pastdmark: pop af  
563f			endm  
# End of macro DMARK
563f						CALLMONITOR 
563f cd aa fd			call debug_vector  
5642				endm  
# End of macro CALLMONITOR
5642					endif 
5642 cd a7 07				call storage_findnextid 
5645 11 ac f9				ld de, store_page 
5648					if DEBUG_FORTH_WORDS 
5648						DMARK "REw" 
5648 f5				push af  
5649 3a 5d 56			ld a, (.dmark)  
564c 32 9d fd			ld (debug_mark),a  
564f 3a 5e 56			ld a, (.dmark+1)  
5652 32 9e fd			ld (debug_mark+1),a  
5655 3a 5f 56			ld a, (.dmark+2)  
5658 32 9f fd			ld (debug_mark+2),a  
565b 18 03			jr .pastdmark  
565d ..			.dmark: db "REw"  
5660 f1			.pastdmark: pop af  
5661			endm  
# End of macro DMARK
5661						CALLMONITOR 
5661 cd aa fd			call debug_vector  
5664				endm  
# End of macro CALLMONITOR
5664					endif 
5664 cd d9 04				call storage_write_block 
5667			 
5667 3e 00				ld a, 0 
5669			.skiprneof: 
5669					; drop file name 
5669					FORTH_DSP_POP 
5669 cd 75 22			call macro_forth_dsp_pop 
566c				endm 
# End of macro FORTH_DSP_POP
566c			 
566c 6f					ld l, a 
566d 26 00				ld h, 0 
566f cd b8 1f				call forth_push_numhl 
5672			 
5672			 
5672 f1					pop af 
5673 32 9f f9				ld (store_readcont),a 
5676 e1					pop hl 
5677 22 9d f9				ld (store_openaddr), hl 
567a						 
567a				NEXTW 
567a cd a7 fd			call parse_vector 
567d c3 a8 23			jp macro_next 
5680				endm 
# End of macro NEXTW
5680			.RECORD: 
5680			  
5680				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
5680 3a				db WORD_SYS_CORE+38             
5681 2a 57			dw .BREAD            
5683 07				db 6 + 1 
5684 .. 00			db "RECORD",0              
568b				endm 
# End of macro CWHEAD
568b			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
568b			; | | > [!NOTE] 
568b			; | | > Compatible with PicoSPINet  
568b			 
568b					if DEBUG_FORTH_WORDS_KEY 
568b						DMARK "REC" 
568b f5				push af  
568c 3a a0 56			ld a, (.dmark)  
568f 32 9d fd			ld (debug_mark),a  
5692 3a a1 56			ld a, (.dmark+1)  
5695 32 9e fd			ld (debug_mark+1),a  
5698 3a a2 56			ld a, (.dmark+2)  
569b 32 9f fd			ld (debug_mark+2),a  
569e 18 03			jr .pastdmark  
56a0 ..			.dmark: db "REC"  
56a3 f1			.pastdmark: pop af  
56a4			endm  
# End of macro DMARK
56a4						CALLMONITOR 
56a4 cd aa fd			call debug_vector  
56a7				endm  
# End of macro CALLMONITOR
56a7					endif 
56a7			 
56a7					FORTH_DSP_VALUEHL 
56a7 cd bd 21			call macro_dsp_valuehl 
56aa				endm 
# End of macro FORTH_DSP_VALUEHL
56aa			 
56aa e5					push hl    ; id 
56ab			 
56ab					FORTH_DSP_POP 
56ab cd 75 22			call macro_forth_dsp_pop 
56ae				endm 
# End of macro FORTH_DSP_POP
56ae			 
56ae					FORTH_DSP_VALUEHL 
56ae cd bd 21			call macro_dsp_valuehl 
56b1				endm 
# End of macro FORTH_DSP_VALUEHL
56b1			 
56b1					FORTH_DSP_POP 
56b1 cd 75 22			call macro_forth_dsp_pop 
56b4				endm 
# End of macro FORTH_DSP_POP
56b4			 
56b4 d1					pop de     ; get file id 
56b5			 
56b5					; e = file id 
56b5					; l = file extent 
56b5			 
56b5			 
56b5					; construct request to access file extent 
56b5			 
56b5			;		ld a, e 
56b5 63					ld h, e 
56b6					 
56b6					 
56b6					 
56b6			 
56b6					; e has id 
56b6			 
56b6 11 ac f9			ld de, store_page 
56b9					if DEBUG_FORTH_WORDS 
56b9						DMARK "REr" 
56b9 f5				push af  
56ba 3a ce 56			ld a, (.dmark)  
56bd 32 9d fd			ld (debug_mark),a  
56c0 3a cf 56			ld a, (.dmark+1)  
56c3 32 9e fd			ld (debug_mark+1),a  
56c6 3a d0 56			ld a, (.dmark+2)  
56c9 32 9f fd			ld (debug_mark+2),a  
56cc 18 03			jr .pastdmark  
56ce ..			.dmark: db "REr"  
56d1 f1			.pastdmark: pop af  
56d2			endm  
# End of macro DMARK
56d2						CALLMONITOR 
56d2 cd aa fd			call debug_vector  
56d5				endm  
# End of macro CALLMONITOR
56d5					endif 
56d5 cd cd 09				call storage_read 
56d8 cd 07 10			call ishlzero 
56db 28 25			jr z, .recnotfound 
56dd			 
56dd			 
56dd					if DEBUG_FORTH_WORDS 
56dd						DMARK "REe" 
56dd f5				push af  
56de 3a f2 56			ld a, (.dmark)  
56e1 32 9d fd			ld (debug_mark),a  
56e4 3a f3 56			ld a, (.dmark+1)  
56e7 32 9e fd			ld (debug_mark+1),a  
56ea 3a f4 56			ld a, (.dmark+2)  
56ed 32 9f fd			ld (debug_mark+2),a  
56f0 18 03			jr .pastdmark  
56f2 ..			.dmark: db "REe"  
56f5 f1			.pastdmark: pop af  
56f6			endm  
# End of macro DMARK
56f6						CALLMONITOR 
56f6 cd aa fd			call debug_vector  
56f9				endm  
# End of macro CALLMONITOR
56f9					endif 
56f9 cd 26 20			call forth_push_str 
56fc			 
56fc					NEXTW 
56fc cd a7 fd			call parse_vector 
56ff c3 a8 23			jp macro_next 
5702				endm 
# End of macro NEXTW
5702			 
5702			.recnotfound: 
5702					if DEBUG_FORTH_WORDS 
5702						DMARK "REf" 
5702 f5				push af  
5703 3a 17 57			ld a, (.dmark)  
5706 32 9d fd			ld (debug_mark),a  
5709 3a 18 57			ld a, (.dmark+1)  
570c 32 9e fd			ld (debug_mark+1),a  
570f 3a 19 57			ld a, (.dmark+2)  
5712 32 9f fd			ld (debug_mark+2),a  
5715 18 03			jr .pastdmark  
5717 ..			.dmark: db "REf"  
571a f1			.pastdmark: pop af  
571b			endm  
# End of macro DMARK
571b						CALLMONITOR 
571b cd aa fd			call debug_vector  
571e				endm  
# End of macro CALLMONITOR
571e					endif 
571e 21 ff 00			ld hl, 255 
5721 cd b8 1f			call forth_push_numhl 
5724				NEXTW 
5724 cd a7 fd			call parse_vector 
5727 c3 a8 23			jp macro_next 
572a				endm 
# End of macro NEXTW
572a			 
572a			 
572a			.BREAD: 
572a			  
572a				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
572a 3a				db WORD_SYS_CORE+38             
572b b0 57			dw .BWRITE            
572d 06				db 5 + 1 
572e .. 00			db "BREAD",0              
5734				endm 
# End of macro CWHEAD
5734			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5734			; | | > [!NOTE] 
5734			; | | > Compatible with PicoSPINet  
5734				 
5734					if DEBUG_FORTH_WORDS_KEY 
5734						DMARK "BRD" 
5734 f5				push af  
5735 3a 49 57			ld a, (.dmark)  
5738 32 9d fd			ld (debug_mark),a  
573b 3a 4a 57			ld a, (.dmark+1)  
573e 32 9e fd			ld (debug_mark+1),a  
5741 3a 4b 57			ld a, (.dmark+2)  
5744 32 9f fd			ld (debug_mark+2),a  
5747 18 03			jr .pastdmark  
5749 ..			.dmark: db "BRD"  
574c f1			.pastdmark: pop af  
574d			endm  
# End of macro DMARK
574d						CALLMONITOR 
574d cd aa fd			call debug_vector  
5750				endm  
# End of macro CALLMONITOR
5750					endif 
5750			 
5750				FORTH_DSP_VALUEHL 
5750 cd bd 21			call macro_dsp_valuehl 
5753				endm 
# End of macro FORTH_DSP_VALUEHL
5753			 
5753				FORTH_DSP_POP 
5753 cd 75 22			call macro_forth_dsp_pop 
5756				endm 
# End of macro FORTH_DSP_POP
5756			 
5756				; calc block address 
5756			 
5756 eb				ex de, hl 
5757 3e 40			ld a, STORE_BLOCK_PHY 
5759 cd 61 0f			call Mult16 
575c			 
575c			 
575c 11 ac f9			ld de, store_page 
575f			 
575f					if DEBUG_FORTH_WORDS 
575f						DMARK "BR1" 
575f f5				push af  
5760 3a 74 57			ld a, (.dmark)  
5763 32 9d fd			ld (debug_mark),a  
5766 3a 75 57			ld a, (.dmark+1)  
5769 32 9e fd			ld (debug_mark+1),a  
576c 3a 76 57			ld a, (.dmark+2)  
576f 32 9f fd			ld (debug_mark+2),a  
5772 18 03			jr .pastdmark  
5774 ..			.dmark: db "BR1"  
5777 f1			.pastdmark: pop af  
5778			endm  
# End of macro DMARK
5778						CALLMONITOR 
5778 cd aa fd			call debug_vector  
577b				endm  
# End of macro CALLMONITOR
577b					endif 
577b			 
577b cd 74 04			call storage_read_block 
577e			 
577e cd 07 10			call ishlzero 
5781 20 05			jr nz, .brfound 
5783			 
5783 cd b8 1f			call forth_push_numhl 
5786 18 22			jr .brdone 
5788			 
5788			 
5788			.brfound: 
5788 21 ae f9		        ld hl, store_page+2 
578b			 
578b					if DEBUG_FORTH_WORDS 
578b						DMARK "BR2" 
578b f5				push af  
578c 3a a0 57			ld a, (.dmark)  
578f 32 9d fd			ld (debug_mark),a  
5792 3a a1 57			ld a, (.dmark+1)  
5795 32 9e fd			ld (debug_mark+1),a  
5798 3a a2 57			ld a, (.dmark+2)  
579b 32 9f fd			ld (debug_mark+2),a  
579e 18 03			jr .pastdmark  
57a0 ..			.dmark: db "BR2"  
57a3 f1			.pastdmark: pop af  
57a4			endm  
# End of macro DMARK
57a4						CALLMONITOR 
57a4 cd aa fd			call debug_vector  
57a7				endm  
# End of macro CALLMONITOR
57a7					endif 
57a7			 
57a7 cd 26 20			call forth_push_str 
57aa			 
57aa			 
57aa			.brdone: 
57aa			 
57aa					NEXTW 
57aa cd a7 fd			call parse_vector 
57ad c3 a8 23			jp macro_next 
57b0				endm 
# End of macro NEXTW
57b0			.BWRITE: 
57b0				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
57b0 3a				db WORD_SYS_CORE+38             
57b1 48 58			dw .BUPD            
57b3 07				db 6 + 1 
57b4 .. 00			db "BWRITE",0              
57bb				endm 
# End of macro CWHEAD
57bb			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
57bb			; | | > [!NOTE] 
57bb			; | | > Compatible with PicoSPINet  
57bb			 
57bb					if DEBUG_FORTH_WORDS_KEY 
57bb						DMARK "BWR" 
57bb f5				push af  
57bc 3a d0 57			ld a, (.dmark)  
57bf 32 9d fd			ld (debug_mark),a  
57c2 3a d1 57			ld a, (.dmark+1)  
57c5 32 9e fd			ld (debug_mark+1),a  
57c8 3a d2 57			ld a, (.dmark+2)  
57cb 32 9f fd			ld (debug_mark+2),a  
57ce 18 03			jr .pastdmark  
57d0 ..			.dmark: db "BWR"  
57d3 f1			.pastdmark: pop af  
57d4			endm  
# End of macro DMARK
57d4						CALLMONITOR 
57d4 cd aa fd			call debug_vector  
57d7				endm  
# End of macro CALLMONITOR
57d7					endif 
57d7			 
57d7				FORTH_DSP_VALUEHL 
57d7 cd bd 21			call macro_dsp_valuehl 
57da				endm 
# End of macro FORTH_DSP_VALUEHL
57da			 
57da				; calc block address 
57da			 
57da eb				ex de, hl 
57db 3e 40			ld a, STORE_BLOCK_PHY 
57dd cd 61 0f			call Mult16 
57e0			 
57e0 e5				push hl         ; address 
57e1			 
57e1				FORTH_DSP_POP 
57e1 cd 75 22			call macro_forth_dsp_pop 
57e4				endm 
# End of macro FORTH_DSP_POP
57e4			 
57e4				FORTH_DSP_VALUEHL 
57e4 cd bd 21			call macro_dsp_valuehl 
57e7				endm 
# End of macro FORTH_DSP_VALUEHL
57e7			 
57e7				FORTH_DSP_POP 
57e7 cd 75 22			call macro_forth_dsp_pop 
57ea				endm 
# End of macro FORTH_DSP_POP
57ea			 
57ea cd b0 0c			call storage_clear_page 
57ed			 
57ed				; copy string to store page 
57ed			 
57ed e5				push hl     ; save string address 
57ee			 
57ee 3e 00			ld a, 0 
57f0 cd 4f 13			call strlent 
57f3			 
57f3 23				inc hl 
57f4			 
57f4 4d				ld c, l 
57f5 06 00			ld b, 0 
57f7			 
57f7 e1				pop hl 
57f8 11 ae f9			ld de, store_page + 2 
57fb					if DEBUG_FORTH_WORDS 
57fb						DMARK "BW1" 
57fb f5				push af  
57fc 3a 10 58			ld a, (.dmark)  
57ff 32 9d fd			ld (debug_mark),a  
5802 3a 11 58			ld a, (.dmark+1)  
5805 32 9e fd			ld (debug_mark+1),a  
5808 3a 12 58			ld a, (.dmark+2)  
580b 32 9f fd			ld (debug_mark+2),a  
580e 18 03			jr .pastdmark  
5810 ..			.dmark: db "BW1"  
5813 f1			.pastdmark: pop af  
5814			endm  
# End of macro DMARK
5814						CALLMONITOR 
5814 cd aa fd			call debug_vector  
5817				endm  
# End of macro CALLMONITOR
5817					endif 
5817 ed b0			ldir 
5819			 
5819			 
5819				; poke the start of the block with flags to prevent high level file ops hitting the block 
5819			 
5819 21 ff ff			ld hl, $ffff 
581c			 
581c 22 ac f9			ld (store_page), hl	 
581f				 
581f e1				pop hl    ; get address 
5820 11 ac f9			ld de, store_page 
5823			 
5823					if DEBUG_FORTH_WORDS 
5823						DMARK "BW2" 
5823 f5				push af  
5824 3a 38 58			ld a, (.dmark)  
5827 32 9d fd			ld (debug_mark),a  
582a 3a 39 58			ld a, (.dmark+1)  
582d 32 9e fd			ld (debug_mark+1),a  
5830 3a 3a 58			ld a, (.dmark+2)  
5833 32 9f fd			ld (debug_mark+2),a  
5836 18 03			jr .pastdmark  
5838 ..			.dmark: db "BW2"  
583b f1			.pastdmark: pop af  
583c			endm  
# End of macro DMARK
583c						CALLMONITOR 
583c cd aa fd			call debug_vector  
583f				endm  
# End of macro CALLMONITOR
583f					endif 
583f			 
583f cd d9 04			call storage_write_block 
5842			 
5842					NEXTW 
5842 cd a7 fd			call parse_vector 
5845 c3 a8 23			jp macro_next 
5848				endm 
# End of macro NEXTW
5848			 
5848			.BUPD: 
5848				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
5848 3a				db WORD_SYS_CORE+38             
5849 a1 58			dw .BYID            
584b 05				db 4 + 1 
584c .. 00			db "BUPD",0              
5851				endm 
# End of macro CWHEAD
5851			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5851			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5851			; | | or completely different file system structure. 
5851			; | | > [!NOTE] 
5851			; | | > Compatible with PicoSPINet  
5851			 
5851					if DEBUG_FORTH_WORDS_KEY 
5851						DMARK "BUD" 
5851 f5				push af  
5852 3a 66 58			ld a, (.dmark)  
5855 32 9d fd			ld (debug_mark),a  
5858 3a 67 58			ld a, (.dmark+1)  
585b 32 9e fd			ld (debug_mark+1),a  
585e 3a 68 58			ld a, (.dmark+2)  
5861 32 9f fd			ld (debug_mark+2),a  
5864 18 03			jr .pastdmark  
5866 ..			.dmark: db "BUD"  
5869 f1			.pastdmark: pop af  
586a			endm  
# End of macro DMARK
586a						CALLMONITOR 
586a cd aa fd			call debug_vector  
586d				endm  
# End of macro CALLMONITOR
586d					endif 
586d			 
586d				FORTH_DSP_VALUEHL 
586d cd bd 21			call macro_dsp_valuehl 
5870				endm 
# End of macro FORTH_DSP_VALUEHL
5870			 
5870				; calc block address 
5870			 
5870 eb				ex de, hl 
5871 3e 40			ld a, STORE_BLOCK_PHY 
5873 cd 61 0f			call Mult16 
5876			 
5876				FORTH_DSP_POP 
5876 cd 75 22			call macro_forth_dsp_pop 
5879				endm 
# End of macro FORTH_DSP_POP
5879			 
5879			 
5879 11 ac f9			ld de, store_page 
587c			 
587c					if DEBUG_FORTH_WORDS 
587c						DMARK "BUe" 
587c f5				push af  
587d 3a 91 58			ld a, (.dmark)  
5880 32 9d fd			ld (debug_mark),a  
5883 3a 92 58			ld a, (.dmark+1)  
5886 32 9e fd			ld (debug_mark+1),a  
5889 3a 93 58			ld a, (.dmark+2)  
588c 32 9f fd			ld (debug_mark+2),a  
588f 18 03			jr .pastdmark  
5891 ..			.dmark: db "BUe"  
5894 f1			.pastdmark: pop af  
5895			endm  
# End of macro DMARK
5895						CALLMONITOR 
5895 cd aa fd			call debug_vector  
5898				endm  
# End of macro CALLMONITOR
5898					endif 
5898			 
5898 cd d9 04			call storage_write_block 
589b			 
589b					NEXTW 
589b cd a7 fd			call parse_vector 
589e c3 a8 23			jp macro_next 
58a1				endm 
# End of macro NEXTW
58a1			 
58a1			.BYID: 
58a1			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
58a1			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
58a1			; 
58a1			;		 
58a1			;		if DEBUG_FORTH_WORDS_KEY 
58a1			;			DMARK "BYID" 
58a1			;			CALLMONITOR 
58a1			;		endif 
58a1			; 
58a1			;		; get direct address 
58a1			; 
58a1			;		FORTH_DSP_VALUEHL 
58a1			; 
58a1			;		FORTH_DSP_POP 
58a1			; 
58a1			;	; calc block address 
58a1			; 
58a1			;	ex de, hl 
58a1			;	ld a, STORE_BLOCK_PHY 
58a1			;	call Mult16 
58a1			;	;	do BREAD with number as param 
58a1			;	; push the file name	 
58a1			;	ld de, store_page 
58a1			;	call storage_read_block 
58a1			 ;       ld hl, store_page+2 
58a1			; 
58a1			; 
58a1			;		NEXTW 
58a1			;.BYNAME: 
58a1				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
58a1 3a				db WORD_SYS_CORE+38             
58a2 bd 58			dw .DIR            
58a4 06				db 5 + 1 
58a5 .. 00			db "GETID",0              
58ab				endm 
# End of macro CWHEAD
58ab			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
58ab			; | | > [!NOTE] 
58ab			; | | > Compatible with PicoSPINet  
58ab			 
58ab					; get pointer to file name to seek 
58ab			 
58ab					FORTH_DSP_VALUEHL 
58ab cd bd 21			call macro_dsp_valuehl 
58ae				endm 
# End of macro FORTH_DSP_VALUEHL
58ae			 
58ae			 
58ae cd 9b 03				call storage_getid  
58b1			 
58b1					FORTH_DSP_POP 
58b1 cd 75 22			call macro_forth_dsp_pop 
58b4				endm 
# End of macro FORTH_DSP_POP
58b4			 
58b4 cd b8 1f				call forth_push_numhl 
58b7			 
58b7					NEXTW 
58b7 cd a7 fd			call parse_vector 
58ba c3 a8 23			jp macro_next 
58bd				endm 
# End of macro NEXTW
58bd			; 
58bd			.DIR: 
58bd				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
58bd 3a				db WORD_SYS_CORE+38             
58be c4 59			dw .SAVE            
58c0 04				db 3 + 1 
58c1 .. 00			db "DIR",0              
58c5				endm 
# End of macro CWHEAD
58c5			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
58c5			; | | > [!NOTE] 
58c5			; | | > Compatible with PicoSPINet  
58c5			 
58c5					if DEBUG_FORTH_WORDS_KEY 
58c5						DMARK "DIR" 
58c5 f5				push af  
58c6 3a da 58			ld a, (.dmark)  
58c9 32 9d fd			ld (debug_mark),a  
58cc 3a db 58			ld a, (.dmark+1)  
58cf 32 9e fd			ld (debug_mark+1),a  
58d2 3a dc 58			ld a, (.dmark+2)  
58d5 32 9f fd			ld (debug_mark+2),a  
58d8 18 03			jr .pastdmark  
58da ..			.dmark: db "DIR"  
58dd f1			.pastdmark: pop af  
58de			endm  
# End of macro DMARK
58de						CALLMONITOR 
58de cd aa fd			call debug_vector  
58e1				endm  
# End of macro CALLMONITOR
58e1					endif 
58e1 cd 25 05			call storage_get_block_0 
58e4			 
58e4 21 ac f9			ld hl, store_page     ; get current id count 
58e7 46				ld b, (hl) 
58e8 0e 00			ld c, 0    ; count of files   
58ea					if DEBUG_FORTH_WORDS 
58ea						DMARK "DI1" 
58ea f5				push af  
58eb 3a ff 58			ld a, (.dmark)  
58ee 32 9d fd			ld (debug_mark),a  
58f1 3a 00 59			ld a, (.dmark+1)  
58f4 32 9e fd			ld (debug_mark+1),a  
58f7 3a 01 59			ld a, (.dmark+2)  
58fa 32 9f fd			ld (debug_mark+2),a  
58fd 18 03			jr .pastdmark  
58ff ..			.dmark: db "DI1"  
5902 f1			.pastdmark: pop af  
5903			endm  
# End of macro DMARK
5903						CALLMONITOR 
5903 cd aa fd			call debug_vector  
5906				endm  
# End of macro CALLMONITOR
5906					endif 
5906			 
5906				; check for empty drive 
5906			 
5906 3e 00			ld a, 0 
5908 b8				cp b 
5909 ca 77 59			jp z, .dirdone 
590c			 
590c				; for each of the current ids do a search for them and if found push to stack 
590c			 
590c c5			.diritem:	push bc 
590d 21 40 00				ld hl, STORE_BLOCK_PHY 
5910 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5912 58					ld e,b 
5913			 
5913			;		if DEBUG_FORTH_WORDS 
5913			;			DMARK "DI2" 
5913			;			CALLMONITOR 
5913			;		endif 
5913			 
5913 cd a7 07				call storage_findnextid 
5916			 
5916			;		if DEBUG_FORTH_WORDS 
5916			;			DMARK "DI3" 
5916			;			CALLMONITOR 
5916			;		endif 
5916			 
5916					; if found hl will be non zero 
5916			 
5916 cd 07 10				call ishlzero 
5919			;		ld a, l 
5919			;		add h 
5919			; 
5919			;		cp 0 
5919 28 59				jr z, .dirnotfound 
591b			 
591b					; increase count 
591b			 
591b c1					pop bc	 
591c 0c					inc c 
591d c5					push bc 
591e					 
591e			 
591e					; get file header and push the file name 
591e			 
591e 11 ac f9				ld de, store_page 
5921 cd 74 04				call storage_read_block 
5924			 
5924					; push file id to stack 
5924				 
5924 3a ac f9				ld a, (store_page) 
5927 26 00				ld h, 0 
5929 6f					ld l, a 
592a cd b8 1f				call forth_push_numhl 
592d			 
592d					; push extent count to stack  
592d				 
592d 3a ae f9				ld a, (store_page+2) 
5930 26 00				ld h, 0 
5932 6f					ld l, a 
5933 cd b8 1f				call forth_push_numhl 
5936			 
5936					; push file name 
5936			 
5936 21 af f9				ld hl, store_page+3 
5939					if DEBUG_FORTH_WORDS 
5939						DMARK "DI5" 
5939 f5				push af  
593a 3a 4e 59			ld a, (.dmark)  
593d 32 9d fd			ld (debug_mark),a  
5940 3a 4f 59			ld a, (.dmark+1)  
5943 32 9e fd			ld (debug_mark+1),a  
5946 3a 50 59			ld a, (.dmark+2)  
5949 32 9f fd			ld (debug_mark+2),a  
594c 18 03			jr .pastdmark  
594e ..			.dmark: db "DI5"  
5951 f1			.pastdmark: pop af  
5952			endm  
# End of macro DMARK
5952						CALLMONITOR 
5952 cd aa fd			call debug_vector  
5955				endm  
# End of macro CALLMONITOR
5955					endif 
5955 cd 26 20				call forth_push_str 
5958					if DEBUG_FORTH_WORDS 
5958						DMARK "DI6" 
5958 f5				push af  
5959 3a 6d 59			ld a, (.dmark)  
595c 32 9d fd			ld (debug_mark),a  
595f 3a 6e 59			ld a, (.dmark+1)  
5962 32 9e fd			ld (debug_mark+1),a  
5965 3a 6f 59			ld a, (.dmark+2)  
5968 32 9f fd			ld (debug_mark+2),a  
596b 18 03			jr .pastdmark  
596d ..			.dmark: db "DI6"  
5970 f1			.pastdmark: pop af  
5971			endm  
# End of macro DMARK
5971						CALLMONITOR 
5971 cd aa fd			call debug_vector  
5974				endm  
# End of macro CALLMONITOR
5974					endif 
5974			.dirnotfound: 
5974 c1					pop bc     
5975 10 95				djnz .diritem 
5977				 
5977			.dirdone:	 
5977					if DEBUG_FORTH_WORDS 
5977						DMARK "DI7" 
5977 f5				push af  
5978 3a 8c 59			ld a, (.dmark)  
597b 32 9d fd			ld (debug_mark),a  
597e 3a 8d 59			ld a, (.dmark+1)  
5981 32 9e fd			ld (debug_mark+1),a  
5984 3a 8e 59			ld a, (.dmark+2)  
5987 32 9f fd			ld (debug_mark+2),a  
598a 18 03			jr .pastdmark  
598c ..			.dmark: db "DI7"  
598f f1			.pastdmark: pop af  
5990			endm  
# End of macro DMARK
5990						CALLMONITOR 
5990 cd aa fd			call debug_vector  
5993				endm  
# End of macro CALLMONITOR
5993					endif 
5993			 
5993					; push a count of the dir items found 
5993			 
5993 26 00				ld h, 0 
5995 69					ld l, c 
5996 cd b8 1f				call forth_push_numhl 
5999			 
5999					; push the bank label 
5999			 
5999 cd 25 05				call storage_get_block_0 
599c			 
599c				 
599c 21 af f9		 		ld hl, store_page+3 
599f			 
599f					if DEBUG_FORTH_WORDS 
599f						DMARK "DI8" 
599f f5				push af  
59a0 3a b4 59			ld a, (.dmark)  
59a3 32 9d fd			ld (debug_mark),a  
59a6 3a b5 59			ld a, (.dmark+1)  
59a9 32 9e fd			ld (debug_mark+1),a  
59ac 3a b6 59			ld a, (.dmark+2)  
59af 32 9f fd			ld (debug_mark+2),a  
59b2 18 03			jr .pastdmark  
59b4 ..			.dmark: db "DI8"  
59b7 f1			.pastdmark: pop af  
59b8			endm  
# End of macro DMARK
59b8						CALLMONITOR 
59b8 cd aa fd			call debug_vector  
59bb				endm  
# End of macro CALLMONITOR
59bb					endif 
59bb cd 26 20				call forth_push_str 
59be			 
59be			 
59be				 
59be					NEXTW 
59be cd a7 fd			call parse_vector 
59c1 c3 a8 23			jp macro_next 
59c4				endm 
# End of macro NEXTW
59c4			.SAVE: 
59c4			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
59c4			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
59c4			;		NEXTW 
59c4			;.LOAD: 
59c4			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
59c4			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
59c4			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
59c4			;; > > The LOAD command can not be used in any user words or compound lines. 
59c4			; 
59c4			;		; store_openext use it. If zero it is EOF 
59c4			; 
59c4			;		; read block from current stream id 
59c4			;		; if the block does not contain zero term keep reading blocks until zero found 
59c4			;		; push the block to stack 
59c4			;		; save the block id to stream 
59c4			; 
59c4			; 
59c4			;		FORTH_DSP_VALUEHL 
59c4			; 
59c4			;;		push hl 
59c4			; 
59c4			;	if DEBUG_STORESE 
59c4			;		DMARK "LOA" 
59c4			;		CALLMONITOR 
59c4			;	endif 
59c4			;		FORTH_DSP_POP 
59c4			; 
59c4			;;		pop hl 
59c4			; 
59c4			;		ld h, l 
59c4			;		ld l, 0 
59c4			; 
59c4			;		push hl     ; stack holds current file id and extent to work with 
59c4			; 
59c4			; 
59c4			;		ld de, store_page      ; get block zero of file 
59c4			;	if DEBUG_STORESE 
59c4			;		DMARK "LO0" 
59c4			;		CALLMONITOR 
59c4			;	endif 
59c4			;		call storage_read 
59c4			; 
59c4			;		ld a, (store_page+2)    ; max extents for this file 
59c4			;		ld  (store_openmaxext),a   ; get our limit 
59c4			; 
59c4			;	if DEBUG_STORESE 
59c4			;		DMARK "LOE" 
59c4			;		CALLMONITOR 
59c4			;	endif 
59c4			; 
59c4			;; TODO dont know why max extents are not present 
59c4			;;		cp 0 
59c4			;;		jp z, .loadeof     ; dont read past eof 
59c4			; 
59c4			;;		ld a, 1   ; start from the head of the file 
59c4			; 
59c4			;.loadline:	pop hl 
59c4			;		inc hl 
59c4			;		ld  a, (store_openmaxext)   ; get our limit 
59c4			;	if DEBUG_STORESE 
59c4			;		DMARK "LOx" 
59c4			;		CALLMONITOR 
59c4			;	endif 
59c4			;		inc a 
59c4			;		cp l 
59c4			;		jp z, .loadeof 
59c4			;		push hl    ; save current extent 
59c4			; 
59c4			;		ld de, store_page 
59c4			; 
59c4			;	if DEBUG_STORESE 
59c4			;		DMARK "LO1" 
59c4			;		CALLMONITOR 
59c4			;	endif 
59c4			;		call storage_read 
59c4			; 
59c4			;	if DEBUG_STORESE 
59c4			;		DMARK "LO2" 
59c4			;		CALLMONITOR 
59c4			;	endif 
59c4			;	call ishlzero 
59c4			;	ld a, l 
59c4			;	add h 
59c4			;	cp 0 
59c4			;	jr z, .loadeof 
59c4			; 
59c4			;	; not eof so hl should point to data to exec 
59c4			; 
59c4			;	; will need to add the FORTH_END_BUFFER flag 
59c4			 ; 
59c4			;	ld hl, store_page+2 
59c4			;	ld bc, 255 
59c4			;	ld a, 0 
59c4			;	cpir 
59c4			;	if DEBUG_STORESE 
59c4			;		DMARK "LOt" 
59c4			;		CALLMONITOR 
59c4			;	endif 
59c4			;	dec hl 
59c4			;	ld a, ' ' 
59c4			;	ld (hl), a 
59c4			;	inc hl 
59c4			;	ld (hl), a 
59c4			;	inc hl 
59c4			;	ld (hl), a 
59c4			;	inc hl 
59c4			;	ld a, FORTH_END_BUFFER 
59c4			;	ld (hl), a 
59c4			; 
59c4			;	; TODO handle more than a single block read 
59c4			; 
59c4			; 
59c4			;	ld hl, store_page+2 
59c4			; 
59c4			;	ld (os_tok_ptr), hl 
59c4			; 
59c4			;	if DEBUG_STORESE 
59c4			;		DMARK "LO3" 
59c4			;		CALLMONITOR 
59c4			;	endif 
59c4			; 
59c4			;	call forthparse 
59c4			;	call forthexec 
59c4			;	call forthexec_cleanup 
59c4			; 
59c4			;	; go to next extent 
59c4			; 
59c4			;	; get next block  or mark as eof 
59c4			;	jp .loadline 
59c4			; 
59c4			; 
59c4			; 
59c4			;	       NEXTW 
59c4			;.loadeof:	ld a, 0 
59c4			;		ld (store_openext), a 
59c4			; 
59c4			;	if DEBUG_STORESE 
59c4			;		DMARK "LOF" 
59c4			;		CALLMONITOR 
59c4			;	endif 
59c4			;		ret 
59c4			;		;NEXTW 
59c4			;.BSAVE:   
59c4			; 
59c4			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
59c4			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
59c4			;		NEXTW 
59c4			;.BLOAD: 
59c4			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
59c4			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
59c4			;		NEXTW 
59c4			;;;; counter gap 
59c4			 
59c4			 
59c4			.SEO: 
59c4				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
59c4 64				db WORD_SYS_CORE+80             
59c5 e6 59			dw .SEI            
59c7 04				db 3 + 1 
59c8 .. 00			db "SEO",0              
59cc				endm 
# End of macro CWHEAD
59cc			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
59cc			 
59cc					; get port 
59cc			 
59cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59cc cd bd 21			call macro_dsp_valuehl 
59cf				endm 
# End of macro FORTH_DSP_VALUEHL
59cf			 
59cf e5					push hl    ; u2 - byte 
59d0			 
59d0					; destroy value TOS 
59d0			 
59d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59d0 cd 75 22			call macro_forth_dsp_pop 
59d3				endm 
# End of macro FORTH_DSP_POP
59d3			 
59d3					; get byte to send 
59d3			 
59d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59d3 cd bd 21			call macro_dsp_valuehl 
59d6				endm 
# End of macro FORTH_DSP_VALUEHL
59d6			 
59d6 e5					push hl    ; u1 - addr 
59d7			 
59d7					; destroy value TOS 
59d7			 
59d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59d7 cd 75 22			call macro_forth_dsp_pop 
59da				endm 
# End of macro FORTH_DSP_POP
59da			 
59da					; one value on hl get other one back 
59da			 
59da d1					pop de   ; u1 - byte 
59db			 
59db e1					pop hl   ; u2 - addr 
59dc			 
59dc					; TODO Send SPI byte 
59dc			 
59dc			 
59dc 7b					ld a, e 
59dd cd 79 02				call se_writebyte 
59e0			 
59e0					 
59e0			 
59e0					NEXTW 
59e0 cd a7 fd			call parse_vector 
59e3 c3 a8 23			jp macro_next 
59e6				endm 
# End of macro NEXTW
59e6			 
59e6			.SEI: 
59e6				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
59e6 65				db WORD_SYS_CORE+81             
59e7 03 5a			dw .SFREE            
59e9 04				db 3 + 1 
59ea .. 00			db "SEI",0              
59ee				endm 
# End of macro CWHEAD
59ee			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
59ee			 
59ee					; get port 
59ee			 
59ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59ee cd bd 21			call macro_dsp_valuehl 
59f1				endm 
# End of macro FORTH_DSP_VALUEHL
59f1			 
59f1			;		push hl 
59f1			 
59f1					; destroy value TOS 
59f1			 
59f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59f1 cd 75 22			call macro_forth_dsp_pop 
59f4				endm 
# End of macro FORTH_DSP_POP
59f4			 
59f4					; one value on hl get other one back 
59f4			 
59f4			;		pop hl 
59f4			 
59f4			 
59f4					; TODO Get SPI byte 
59f4			 
59f4 cd 1b 03				call se_readbyte 
59f7			 
59f7 26 00				ld h, 0 
59f9 6f					ld l, a 
59fa cd b8 1f				call forth_push_numhl 
59fd			 
59fd					NEXTW 
59fd cd a7 fd			call parse_vector 
5a00 c3 a8 23			jp macro_next 
5a03				endm 
# End of macro NEXTW
5a03			 
5a03			.SFREE: 
5a03				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5a03 67				db WORD_SYS_CORE+83             
5a04 35 5a			dw .SIZE            
5a06 06				db 5 + 1 
5a07 .. 00			db "FFREE",0              
5a0d				endm 
# End of macro CWHEAD
5a0d			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5a0d			; | | > [!NOTE] 
5a0d			; | | > Compatible with PicoSPINet  
5a0d					if DEBUG_FORTH_WORDS_KEY 
5a0d						DMARK "FFR" 
5a0d f5				push af  
5a0e 3a 22 5a			ld a, (.dmark)  
5a11 32 9d fd			ld (debug_mark),a  
5a14 3a 23 5a			ld a, (.dmark+1)  
5a17 32 9e fd			ld (debug_mark+1),a  
5a1a 3a 24 5a			ld a, (.dmark+2)  
5a1d 32 9f fd			ld (debug_mark+2),a  
5a20 18 03			jr .pastdmark  
5a22 ..			.dmark: db "FFR"  
5a25 f1			.pastdmark: pop af  
5a26			endm  
# End of macro DMARK
5a26						CALLMONITOR 
5a26 cd aa fd			call debug_vector  
5a29				endm  
# End of macro CALLMONITOR
5a29					endif 
5a29			 
5a29 cd 41 08				call storage_freeblocks 
5a2c			 
5a2c cd b8 1f				call forth_push_numhl 
5a2f			 
5a2f				       NEXTW 
5a2f cd a7 fd			call parse_vector 
5a32 c3 a8 23			jp macro_next 
5a35				endm 
# End of macro NEXTW
5a35			.SIZE: 
5a35				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5a35 67				db WORD_SYS_CORE+83             
5a36 6c 5a			dw .CREATE            
5a38 05				db 4 + 1 
5a39 .. 00			db "SIZE",0              
5a3e				endm 
# End of macro CWHEAD
5a3e			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5a3e			; | | > [!NOTE] 
5a3e			; | | > Compatible with PicoSPINet  
5a3e					if DEBUG_FORTH_WORDS_KEY 
5a3e						DMARK "SIZ" 
5a3e f5				push af  
5a3f 3a 53 5a			ld a, (.dmark)  
5a42 32 9d fd			ld (debug_mark),a  
5a45 3a 54 5a			ld a, (.dmark+1)  
5a48 32 9e fd			ld (debug_mark+1),a  
5a4b 3a 55 5a			ld a, (.dmark+2)  
5a4e 32 9f fd			ld (debug_mark+2),a  
5a51 18 03			jr .pastdmark  
5a53 ..			.dmark: db "SIZ"  
5a56 f1			.pastdmark: pop af  
5a57			endm  
# End of macro DMARK
5a57						CALLMONITOR 
5a57 cd aa fd			call debug_vector  
5a5a				endm  
# End of macro CALLMONITOR
5a5a					endif 
5a5a			 
5a5a					FORTH_DSP_VALUEHL 
5a5a cd bd 21			call macro_dsp_valuehl 
5a5d				endm 
# End of macro FORTH_DSP_VALUEHL
5a5d			;		push hl 
5a5d					FORTH_DSP_POP 
5a5d cd 75 22			call macro_forth_dsp_pop 
5a60				endm 
# End of macro FORTH_DSP_POP
5a60			;		pop hl 
5a60 cd a3 04				call storage_file_size 
5a63			 
5a63 cd b8 1f				call forth_push_numhl 
5a66			  
5a66			 
5a66				       NEXTW 
5a66 cd a7 fd			call parse_vector 
5a69 c3 a8 23			jp macro_next 
5a6c				endm 
# End of macro NEXTW
5a6c			 
5a6c			.CREATE: 
5a6c				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5a6c 68				db WORD_SYS_CORE+84             
5a6d dd 5a			dw .APPEND            
5a6f 07				db 6 + 1 
5a70 .. 00			db "CREATE",0              
5a77				endm 
# End of macro CWHEAD
5a77			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5a77			; | | e.g.  
5a77			; | | TestProgram CREATE 
5a77			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5a77			; | |  
5a77			; | | Max file IDs are 255. 
5a77			; | |  
5a77			; | | > [!NOTE] 
5a77			; | | > Compatible with PicoSPINet  
5a77					 
5a77					if DEBUG_FORTH_WORDS_KEY 
5a77						DMARK "CRT" 
5a77 f5				push af  
5a78 3a 8c 5a			ld a, (.dmark)  
5a7b 32 9d fd			ld (debug_mark),a  
5a7e 3a 8d 5a			ld a, (.dmark+1)  
5a81 32 9e fd			ld (debug_mark+1),a  
5a84 3a 8e 5a			ld a, (.dmark+2)  
5a87 32 9f fd			ld (debug_mark+2),a  
5a8a 18 03			jr .pastdmark  
5a8c ..			.dmark: db "CRT"  
5a8f f1			.pastdmark: pop af  
5a90			endm  
# End of macro DMARK
5a90						CALLMONITOR 
5a90 cd aa fd			call debug_vector  
5a93				endm  
# End of macro CALLMONITOR
5a93					endif 
5a93			;		call storage_get_block_0 
5a93			 
5a93					; TODO pop hl 
5a93			 
5a93					;v5 FORTH_DSP_VALUE 
5a93					FORTH_DSP_VALUE 
5a93 cd a6 21			call macro_forth_dsp_value 
5a96				endm 
# End of macro FORTH_DSP_VALUE
5a96			 
5a96				if DEBUG_STORESE 
5a96					DMARK "CR1" 
5a96 f5				push af  
5a97 3a ab 5a			ld a, (.dmark)  
5a9a 32 9d fd			ld (debug_mark),a  
5a9d 3a ac 5a			ld a, (.dmark+1)  
5aa0 32 9e fd			ld (debug_mark+1),a  
5aa3 3a ad 5a			ld a, (.dmark+2)  
5aa6 32 9f fd			ld (debug_mark+2),a  
5aa9 18 03			jr .pastdmark  
5aab ..			.dmark: db "CR1"  
5aae f1			.pastdmark: pop af  
5aaf			endm  
# End of macro DMARK
5aaf					CALLMONITOR 
5aaf cd aa fd			call debug_vector  
5ab2				endm  
# End of macro CALLMONITOR
5ab2				endif 
5ab2			;		push hl 
5ab2			;		FORTH_DSP_POP 
5ab2			;		pop hl 
5ab2			 
5ab2			;		inc hl   ; move past the type marker 
5ab2			 
5ab2 cd 77 08				call storage_create 
5ab5			 
5ab5				if DEBUG_STORESE 
5ab5					DMARK "CT1" 
5ab5 f5				push af  
5ab6 3a ca 5a			ld a, (.dmark)  
5ab9 32 9d fd			ld (debug_mark),a  
5abc 3a cb 5a			ld a, (.dmark+1)  
5abf 32 9e fd			ld (debug_mark+1),a  
5ac2 3a cc 5a			ld a, (.dmark+2)  
5ac5 32 9f fd			ld (debug_mark+2),a  
5ac8 18 03			jr .pastdmark  
5aca ..			.dmark: db "CT1"  
5acd f1			.pastdmark: pop af  
5ace			endm  
# End of macro DMARK
5ace					CALLMONITOR 
5ace cd aa fd			call debug_vector  
5ad1				endm  
# End of macro CALLMONITOR
5ad1				endif 
5ad1			;		push hl 
5ad1					FORTH_DSP_POP 
5ad1 cd 75 22			call macro_forth_dsp_pop 
5ad4				endm 
# End of macro FORTH_DSP_POP
5ad4			;		pop hl 
5ad4					; push file id to stack 
5ad4 cd b8 1f				call forth_push_numhl 
5ad7			 
5ad7			 
5ad7			 
5ad7				       NEXTW 
5ad7 cd a7 fd			call parse_vector 
5ada c3 a8 23			jp macro_next 
5add				endm 
# End of macro NEXTW
5add			 
5add			.APPEND: 
5add				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5add 69				db WORD_SYS_CORE+85             
5ade 71 5b			dw .SDEL            
5ae0 07				db 6 + 1 
5ae1 .. 00			db "APPEND",0              
5ae8				endm 
# End of macro CWHEAD
5ae8			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5ae8			; | | e.g. 
5ae8			; | | Test CREATE      -> $01 
5ae8			; | | "A string to add to file" $01 APPEND 
5ae8			; | |  
5ae8			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5ae8			; | | > [!NOTE] 
5ae8			; | | > Compatible with PicoSPINet  
5ae8					if DEBUG_FORTH_WORDS_KEY 
5ae8						DMARK "APP" 
5ae8 f5				push af  
5ae9 3a fd 5a			ld a, (.dmark)  
5aec 32 9d fd			ld (debug_mark),a  
5aef 3a fe 5a			ld a, (.dmark+1)  
5af2 32 9e fd			ld (debug_mark+1),a  
5af5 3a ff 5a			ld a, (.dmark+2)  
5af8 32 9f fd			ld (debug_mark+2),a  
5afb 18 03			jr .pastdmark  
5afd ..			.dmark: db "APP"  
5b00 f1			.pastdmark: pop af  
5b01			endm  
# End of macro DMARK
5b01						CALLMONITOR 
5b01 cd aa fd			call debug_vector  
5b04				endm  
# End of macro CALLMONITOR
5b04					endif 
5b04			 
5b04					FORTH_DSP_VALUEHL 
5b04 cd bd 21			call macro_dsp_valuehl 
5b07				endm 
# End of macro FORTH_DSP_VALUEHL
5b07 e5					push hl 	; save file id 
5b08			 
5b08				if DEBUG_STORESE 
5b08					DMARK "AP1" 
5b08 f5				push af  
5b09 3a 1d 5b			ld a, (.dmark)  
5b0c 32 9d fd			ld (debug_mark),a  
5b0f 3a 1e 5b			ld a, (.dmark+1)  
5b12 32 9e fd			ld (debug_mark+1),a  
5b15 3a 1f 5b			ld a, (.dmark+2)  
5b18 32 9f fd			ld (debug_mark+2),a  
5b1b 18 03			jr .pastdmark  
5b1d ..			.dmark: db "AP1"  
5b20 f1			.pastdmark: pop af  
5b21			endm  
# End of macro DMARK
5b21					CALLMONITOR 
5b21 cd aa fd			call debug_vector  
5b24				endm  
# End of macro CALLMONITOR
5b24				endif 
5b24					FORTH_DSP_POP 
5b24 cd 75 22			call macro_forth_dsp_pop 
5b27				endm 
# End of macro FORTH_DSP_POP
5b27			 
5b27					FORTH_DSP_VALUEHL 
5b27 cd bd 21			call macro_dsp_valuehl 
5b2a				endm 
# End of macro FORTH_DSP_VALUEHL
5b2a					;v5 FORTH_DSP_VALUE 
5b2a e5					push hl 	; save ptr to string to save 
5b2b			 
5b2b				if DEBUG_STORESE 
5b2b					DMARK "AP1" 
5b2b f5				push af  
5b2c 3a 40 5b			ld a, (.dmark)  
5b2f 32 9d fd			ld (debug_mark),a  
5b32 3a 41 5b			ld a, (.dmark+1)  
5b35 32 9e fd			ld (debug_mark+1),a  
5b38 3a 42 5b			ld a, (.dmark+2)  
5b3b 32 9f fd			ld (debug_mark+2),a  
5b3e 18 03			jr .pastdmark  
5b40 ..			.dmark: db "AP1"  
5b43 f1			.pastdmark: pop af  
5b44			endm  
# End of macro DMARK
5b44					CALLMONITOR 
5b44 cd aa fd			call debug_vector  
5b47				endm  
# End of macro CALLMONITOR
5b47				endif 
5b47					FORTH_DSP_POP 
5b47 cd 75 22			call macro_forth_dsp_pop 
5b4a				endm 
# End of macro FORTH_DSP_POP
5b4a			 
5b4a d1					pop de 
5b4b e1					pop hl 
5b4c				if DEBUG_STORESE 
5b4c					DMARK "AP2" 
5b4c f5				push af  
5b4d 3a 61 5b			ld a, (.dmark)  
5b50 32 9d fd			ld (debug_mark),a  
5b53 3a 62 5b			ld a, (.dmark+1)  
5b56 32 9e fd			ld (debug_mark+1),a  
5b59 3a 63 5b			ld a, (.dmark+2)  
5b5c 32 9f fd			ld (debug_mark+2),a  
5b5f 18 03			jr .pastdmark  
5b61 ..			.dmark: db "AP2"  
5b64 f1			.pastdmark: pop af  
5b65			endm  
# End of macro DMARK
5b65					CALLMONITOR 
5b65 cd aa fd			call debug_vector  
5b68				endm  
# End of macro CALLMONITOR
5b68				endif 
5b68					;inc de ; skip var type indicator 
5b68			 
5b68					; TODO how to append numerics???? 
5b68			 
5b68 cd 64 0b				call storage_append		 
5b6b			 
5b6b				       NEXTW 
5b6b cd a7 fd			call parse_vector 
5b6e c3 a8 23			jp macro_next 
5b71				endm 
# End of macro NEXTW
5b71			.SDEL: 
5b71				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5b71 6a				db WORD_SYS_CORE+86             
5b72 c0 5b			dw .OPEN            
5b74 05				db 4 + 1 
5b75 .. 00			db "ERA",0              
5b79				endm 
# End of macro CWHEAD
5b79			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5b79			; | | > [!NOTE] 
5b79			; | | > Compatible with PicoSPINet  
5b79					FORTH_DSP_VALUEHL 
5b79 cd bd 21			call macro_dsp_valuehl 
5b7c				endm 
# End of macro FORTH_DSP_VALUEHL
5b7c			;		push hl 	; save file id 
5b7c			 
5b7c					if DEBUG_FORTH_WORDS_KEY 
5b7c						DMARK "ERA" 
5b7c f5				push af  
5b7d 3a 91 5b			ld a, (.dmark)  
5b80 32 9d fd			ld (debug_mark),a  
5b83 3a 92 5b			ld a, (.dmark+1)  
5b86 32 9e fd			ld (debug_mark+1),a  
5b89 3a 93 5b			ld a, (.dmark+2)  
5b8c 32 9f fd			ld (debug_mark+2),a  
5b8f 18 03			jr .pastdmark  
5b91 ..			.dmark: db "ERA"  
5b94 f1			.pastdmark: pop af  
5b95			endm  
# End of macro DMARK
5b95						CALLMONITOR 
5b95 cd aa fd			call debug_vector  
5b98				endm  
# End of macro CALLMONITOR
5b98					endif 
5b98				if DEBUG_STORESE 
5b98					DMARK "ER1" 
5b98 f5				push af  
5b99 3a ad 5b			ld a, (.dmark)  
5b9c 32 9d fd			ld (debug_mark),a  
5b9f 3a ae 5b			ld a, (.dmark+1)  
5ba2 32 9e fd			ld (debug_mark+1),a  
5ba5 3a af 5b			ld a, (.dmark+2)  
5ba8 32 9f fd			ld (debug_mark+2),a  
5bab 18 03			jr .pastdmark  
5bad ..			.dmark: db "ER1"  
5bb0 f1			.pastdmark: pop af  
5bb1			endm  
# End of macro DMARK
5bb1					CALLMONITOR 
5bb1 cd aa fd			call debug_vector  
5bb4				endm  
# End of macro CALLMONITOR
5bb4				endif 
5bb4					FORTH_DSP_POP 
5bb4 cd 75 22			call macro_forth_dsp_pop 
5bb7				endm 
# End of macro FORTH_DSP_POP
5bb7			 
5bb7			;		pop hl 
5bb7			 
5bb7 cd b6 06				call storage_erase 
5bba				       NEXTW 
5bba cd a7 fd			call parse_vector 
5bbd c3 a8 23			jp macro_next 
5bc0				endm 
# End of macro NEXTW
5bc0			 
5bc0			.OPEN: 
5bc0				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5bc0 6b				db WORD_SYS_CORE+87             
5bc1 57 5c			dw .READ            
5bc3 05				db 4 + 1 
5bc4 .. 00			db "OPEN",0              
5bc9				endm 
# End of macro CWHEAD
5bc9			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5bc9			; | | e.g. 
5bc9			; | | $01 OPEN $01 DO $01 READ . LOOP 
5bc9			; | | 
5bc9			; | | Will return with 255 blocks if the file does not exist 
5bc9			; | | > [!NOTE] 
5bc9			; | | > Compatible with PicoSPINet  
5bc9			 
5bc9					if DEBUG_FORTH_WORDS_KEY 
5bc9						DMARK "OPN" 
5bc9 f5				push af  
5bca 3a de 5b			ld a, (.dmark)  
5bcd 32 9d fd			ld (debug_mark),a  
5bd0 3a df 5b			ld a, (.dmark+1)  
5bd3 32 9e fd			ld (debug_mark+1),a  
5bd6 3a e0 5b			ld a, (.dmark+2)  
5bd9 32 9f fd			ld (debug_mark+2),a  
5bdc 18 03			jr .pastdmark  
5bde ..			.dmark: db "OPN"  
5be1 f1			.pastdmark: pop af  
5be2			endm  
# End of macro DMARK
5be2						CALLMONITOR 
5be2 cd aa fd			call debug_vector  
5be5				endm  
# End of macro CALLMONITOR
5be5					endif 
5be5					; TODO handle multiple file opens 
5be5			 
5be5 3e 01			       	ld a, 1 
5be7 32 9c f9				ld (store_openext), a 
5bea			 
5bea					; get max extents for this file 
5bea				 
5bea								 
5bea					FORTH_DSP_VALUEHL 
5bea cd bd 21			call macro_dsp_valuehl 
5bed				endm 
# End of macro FORTH_DSP_VALUEHL
5bed			 
5bed 65					ld h, l 
5bee 2e 00				ld l, 0 
5bf0			 
5bf0					; store file id 
5bf0			 
5bf0 7c					ld a, h 
5bf1 32 99 f9				ld (store_filecache), a 
5bf4			 
5bf4				if DEBUG_STORESE 
5bf4					DMARK "OPN" 
5bf4 f5				push af  
5bf5 3a 09 5c			ld a, (.dmark)  
5bf8 32 9d fd			ld (debug_mark),a  
5bfb 3a 0a 5c			ld a, (.dmark+1)  
5bfe 32 9e fd			ld (debug_mark+1),a  
5c01 3a 0b 5c			ld a, (.dmark+2)  
5c04 32 9f fd			ld (debug_mark+2),a  
5c07 18 03			jr .pastdmark  
5c09 ..			.dmark: db "OPN"  
5c0c f1			.pastdmark: pop af  
5c0d			endm  
# End of macro DMARK
5c0d					CALLMONITOR 
5c0d cd aa fd			call debug_vector  
5c10				endm  
# End of macro CALLMONITOR
5c10				endif 
5c10			;		push hl 
5c10					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5c10 cd 75 22			call macro_forth_dsp_pop 
5c13				endm 
# End of macro FORTH_DSP_POP
5c13			;		pop hl 
5c13						 
5c13 11 ac f9				ld de, store_page      ; get block zero of file 
5c16 cd cd 09				call storage_read 
5c19 cd 07 10			call ishlzero 
5c1c 20 04			jr nz, .opfound 
5c1e			 
5c1e				; file does not exist so indicate with 255 extents in use 
5c1e			 
5c1e 3e ff			ld a, 255 
5c20 18 29			jr .skipopeneof 
5c22			 
5c22			 
5c22			.opfound: 
5c22			 
5c22			 
5c22 3a ae f9				ld a, (store_page+2)    ; max extents for this file 
5c25 32 9b f9				ld  (store_openmaxext), a   ; get our limit and push 
5c28					 
5c28				if DEBUG_STORESE 
5c28					DMARK "OPx" 
5c28 f5				push af  
5c29 3a 3d 5c			ld a, (.dmark)  
5c2c 32 9d fd			ld (debug_mark),a  
5c2f 3a 3e 5c			ld a, (.dmark+1)  
5c32 32 9e fd			ld (debug_mark+1),a  
5c35 3a 3f 5c			ld a, (.dmark+2)  
5c38 32 9f fd			ld (debug_mark+2),a  
5c3b 18 03			jr .pastdmark  
5c3d ..			.dmark: db "OPx"  
5c40 f1			.pastdmark: pop af  
5c41			endm  
# End of macro DMARK
5c41					CALLMONITOR 
5c41 cd aa fd			call debug_vector  
5c44				endm  
# End of macro CALLMONITOR
5c44				endif 
5c44 fe 00				cp 0 
5c46 20 03				jr nz, .skipopeneof 
5c48					; have opened an empty file 
5c48					 
5c48 32 9c f9				ld (store_openext), a 
5c4b			 
5c4b			.skipopeneof: 
5c4b			 
5c4b 6f					ld l, a 
5c4c 26 00				ld h, 0 
5c4e cd b8 1f				call forth_push_numhl 
5c51			 
5c51			 
5c51				       NEXTW 
5c51 cd a7 fd			call parse_vector 
5c54 c3 a8 23			jp macro_next 
5c57				endm 
# End of macro NEXTW
5c57			.READ: 
5c57				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5c57 6c				db WORD_SYS_CORE+88             
5c58 87 5d			dw .EOF            
5c5a 05				db 4 + 1 
5c5b .. 00			db "READ",0              
5c60				endm 
# End of macro CWHEAD
5c60			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5c60			; | | e.g. 
5c60			; | | $01 OPEN $01 DO READ . LOOP 
5c60			; | | 
5c60			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5c60			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5c60			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5c60			; | | two bytes contain the file id and extent. 
5c60			; | |  
5c60			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5c60			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5c60			; | | > [!NOTE] 
5c60			; | | > Compatible with PicoSPINet  
5c60			 
5c60					if DEBUG_FORTH_WORDS_KEY 
5c60						DMARK "REA" 
5c60 f5				push af  
5c61 3a 75 5c			ld a, (.dmark)  
5c64 32 9d fd			ld (debug_mark),a  
5c67 3a 76 5c			ld a, (.dmark+1)  
5c6a 32 9e fd			ld (debug_mark+1),a  
5c6d 3a 77 5c			ld a, (.dmark+2)  
5c70 32 9f fd			ld (debug_mark+2),a  
5c73 18 03			jr .pastdmark  
5c75 ..			.dmark: db "REA"  
5c78 f1			.pastdmark: pop af  
5c79			endm  
# End of macro DMARK
5c79						CALLMONITOR 
5c79 cd aa fd			call debug_vector  
5c7c				endm  
# End of macro CALLMONITOR
5c7c					endif 
5c7c					; store_openext use it. If zero it is EOF 
5c7c			 
5c7c					; read block from current stream id 
5c7c					; if the block does not contain zero term keep reading blocks until zero found 
5c7c					; push the block to stack 
5c7c					; save the block id to stream 
5c7c			 
5c7c			 
5c7c cd b7 5d				call .testeof 
5c7f 3e 01				ld a, 1 
5c81 bd					cp l 
5c82 ca 60 5d				jp z, .ateof 
5c85			 
5c85			 
5c85			;		FORTH_DSP_VALUEHL 
5c85			 
5c85			;		push hl 
5c85			 
5c85			;	if DEBUG_STORESE 
5c85			;		DMARK "REA" 
5c85			;		CALLMONITOR 
5c85			;	endif 
5c85			;		FORTH_DSP_POP 
5c85			 
5c85			;		pop hl 
5c85				 
5c85 3a 99 f9				ld a, (store_filecache) 
5c88 67					ld h,a 
5c89			 
5c89 3a 9c f9				ld a, (store_openext) 
5c8c 6f					ld l, a 
5c8d					 
5c8d fe 00				cp 0 
5c8f ca 60 5d				jp z, .ateof     ; dont read past eof 
5c92			 
5c92 cd b0 0c				call storage_clear_page 
5c95			 
5c95 11 ac f9				ld de, store_page 
5c98				if DEBUG_STORESE 
5c98					DMARK "RE1" 
5c98 f5				push af  
5c99 3a ad 5c			ld a, (.dmark)  
5c9c 32 9d fd			ld (debug_mark),a  
5c9f 3a ae 5c			ld a, (.dmark+1)  
5ca2 32 9e fd			ld (debug_mark+1),a  
5ca5 3a af 5c			ld a, (.dmark+2)  
5ca8 32 9f fd			ld (debug_mark+2),a  
5cab 18 03			jr .pastdmark  
5cad ..			.dmark: db "RE1"  
5cb0 f1			.pastdmark: pop af  
5cb1			endm  
# End of macro DMARK
5cb1					CALLMONITOR 
5cb1 cd aa fd			call debug_vector  
5cb4				endm  
# End of macro CALLMONITOR
5cb4				endif 
5cb4 cd cd 09				call storage_read 
5cb7			 
5cb7				if DEBUG_STORESE 
5cb7					DMARK "RE2" 
5cb7 f5				push af  
5cb8 3a cc 5c			ld a, (.dmark)  
5cbb 32 9d fd			ld (debug_mark),a  
5cbe 3a cd 5c			ld a, (.dmark+1)  
5cc1 32 9e fd			ld (debug_mark+1),a  
5cc4 3a ce 5c			ld a, (.dmark+2)  
5cc7 32 9f fd			ld (debug_mark+2),a  
5cca 18 03			jr .pastdmark  
5ccc ..			.dmark: db "RE2"  
5ccf f1			.pastdmark: pop af  
5cd0			endm  
# End of macro DMARK
5cd0					CALLMONITOR 
5cd0 cd aa fd			call debug_vector  
5cd3				endm  
# End of macro CALLMONITOR
5cd3				endif 
5cd3 cd 07 10			call ishlzero 
5cd6			;	ld a, l 
5cd6			;	add h 
5cd6			;	cp 0 
5cd6 ca 60 5d			jp z, .readeof 
5cd9			 
5cd9				; not eof so hl should point to data to push to stack 
5cd9			 
5cd9				if DEBUG_STORESE 
5cd9					DMARK "RE3" 
5cd9 f5				push af  
5cda 3a ee 5c			ld a, (.dmark)  
5cdd 32 9d fd			ld (debug_mark),a  
5ce0 3a ef 5c			ld a, (.dmark+1)  
5ce3 32 9e fd			ld (debug_mark+1),a  
5ce6 3a f0 5c			ld a, (.dmark+2)  
5ce9 32 9f fd			ld (debug_mark+2),a  
5cec 18 03			jr .pastdmark  
5cee ..			.dmark: db "RE3"  
5cf1 f1			.pastdmark: pop af  
5cf2			endm  
# End of macro DMARK
5cf2					CALLMONITOR 
5cf2 cd aa fd			call debug_vector  
5cf5				endm  
# End of macro CALLMONITOR
5cf5				endif 
5cf5 cd 26 20			call forth_push_str 
5cf8			 
5cf8				if DEBUG_STORESE 
5cf8					DMARK "RE4" 
5cf8 f5				push af  
5cf9 3a 0d 5d			ld a, (.dmark)  
5cfc 32 9d fd			ld (debug_mark),a  
5cff 3a 0e 5d			ld a, (.dmark+1)  
5d02 32 9e fd			ld (debug_mark+1),a  
5d05 3a 0f 5d			ld a, (.dmark+2)  
5d08 32 9f fd			ld (debug_mark+2),a  
5d0b 18 03			jr .pastdmark  
5d0d ..			.dmark: db "RE4"  
5d10 f1			.pastdmark: pop af  
5d11			endm  
# End of macro DMARK
5d11					CALLMONITOR 
5d11 cd aa fd			call debug_vector  
5d14				endm  
# End of macro CALLMONITOR
5d14				endif 
5d14				; get next block  or mark as eof 
5d14			 
5d14 3a 9b f9			ld a, (store_openmaxext)   ; get our limit 
5d17 4f				ld c, a	 
5d18 3a 9c f9			ld a, (store_openext) 
5d1b			 
5d1b				if DEBUG_STORESE 
5d1b					DMARK "RE5" 
5d1b f5				push af  
5d1c 3a 30 5d			ld a, (.dmark)  
5d1f 32 9d fd			ld (debug_mark),a  
5d22 3a 31 5d			ld a, (.dmark+1)  
5d25 32 9e fd			ld (debug_mark+1),a  
5d28 3a 32 5d			ld a, (.dmark+2)  
5d2b 32 9f fd			ld (debug_mark+2),a  
5d2e 18 03			jr .pastdmark  
5d30 ..			.dmark: db "RE5"  
5d33 f1			.pastdmark: pop af  
5d34			endm  
# End of macro DMARK
5d34					CALLMONITOR 
5d34 cd aa fd			call debug_vector  
5d37				endm  
# End of macro CALLMONITOR
5d37				endif 
5d37 b9				cp c 
5d38 28 26			jr z, .readeof     ; at last extent 
5d3a			 
5d3a 3c					inc a 
5d3b 32 9c f9				ld (store_openext), a 
5d3e			 
5d3e				if DEBUG_STORESE 
5d3e					DMARK "RE6" 
5d3e f5				push af  
5d3f 3a 53 5d			ld a, (.dmark)  
5d42 32 9d fd			ld (debug_mark),a  
5d45 3a 54 5d			ld a, (.dmark+1)  
5d48 32 9e fd			ld (debug_mark+1),a  
5d4b 3a 55 5d			ld a, (.dmark+2)  
5d4e 32 9f fd			ld (debug_mark+2),a  
5d51 18 03			jr .pastdmark  
5d53 ..			.dmark: db "RE6"  
5d56 f1			.pastdmark: pop af  
5d57			endm  
# End of macro DMARK
5d57					CALLMONITOR 
5d57 cd aa fd			call debug_vector  
5d5a				endm  
# End of macro CALLMONITOR
5d5a				endif 
5d5a			 
5d5a			 
5d5a				       NEXTW 
5d5a cd a7 fd			call parse_vector 
5d5d c3 a8 23			jp macro_next 
5d60				endm 
# End of macro NEXTW
5d60			.ateof: 
5d60				;	ld hl, .showeof 
5d60				;	call forth_push_str 
5d60 3e 00		.readeof:	ld a, 0 
5d62 32 9c f9				ld (store_openext), a 
5d65			 
5d65					 
5d65				if DEBUG_STORESE 
5d65					DMARK "REF" 
5d65 f5				push af  
5d66 3a 7a 5d			ld a, (.dmark)  
5d69 32 9d fd			ld (debug_mark),a  
5d6c 3a 7b 5d			ld a, (.dmark+1)  
5d6f 32 9e fd			ld (debug_mark+1),a  
5d72 3a 7c 5d			ld a, (.dmark+2)  
5d75 32 9f fd			ld (debug_mark+2),a  
5d78 18 03			jr .pastdmark  
5d7a ..			.dmark: db "REF"  
5d7d f1			.pastdmark: pop af  
5d7e			endm  
# End of macro DMARK
5d7e					CALLMONITOR 
5d7e cd aa fd			call debug_vector  
5d81				endm  
# End of macro CALLMONITOR
5d81				endif 
5d81				       NEXTW 
5d81 cd a7 fd			call parse_vector 
5d84 c3 a8 23			jp macro_next 
5d87				endm 
# End of macro NEXTW
5d87			 
5d87			;.showeof:   db "eof", 0 
5d87			 
5d87			 
5d87			.EOF: 
5d87				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5d87 6d				db WORD_SYS_CORE+89             
5d88 cc 5d			dw .FORMAT            
5d8a 04				db 3 + 1 
5d8b .. 00			db "EOF",0              
5d8f				endm 
# End of macro CWHEAD
5d8f			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5d8f			; | | e.g. 
5d8f			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5d8f			; | | > [!NOTE] 
5d8f			; | | > Compatible with PicoSPINet  
5d8f					; TODO if current block id for stream is zero then push true else false 
5d8f			 
5d8f					if DEBUG_FORTH_WORDS_KEY 
5d8f						DMARK "EOF" 
5d8f f5				push af  
5d90 3a a4 5d			ld a, (.dmark)  
5d93 32 9d fd			ld (debug_mark),a  
5d96 3a a5 5d			ld a, (.dmark+1)  
5d99 32 9e fd			ld (debug_mark+1),a  
5d9c 3a a6 5d			ld a, (.dmark+2)  
5d9f 32 9f fd			ld (debug_mark+2),a  
5da2 18 03			jr .pastdmark  
5da4 ..			.dmark: db "EOF"  
5da7 f1			.pastdmark: pop af  
5da8			endm  
# End of macro DMARK
5da8						CALLMONITOR 
5da8 cd aa fd			call debug_vector  
5dab				endm  
# End of macro CALLMONITOR
5dab					endif 
5dab			 
5dab					; TODO handlue multiple file streams 
5dab			 
5dab			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5dab cd b7 5d				call .testeof 
5dae cd b8 1f				call forth_push_numhl 
5db1			 
5db1			 
5db1				       NEXTW 
5db1 cd a7 fd			call parse_vector 
5db4 c3 a8 23			jp macro_next 
5db7				endm 
# End of macro NEXTW
5db7			 
5db7			.testeof: 
5db7 2e 01				ld l, 1 
5db9 3a 9b f9				ld a, (store_openmaxext) 
5dbc fe 00				cp 0 
5dbe 28 09				jr  z, .eofdone   ; empty file 
5dc0 3a 9c f9				ld a, (store_openext) 
5dc3 fe 00				cp 0 
5dc5 28 02				jr  z, .eofdone 
5dc7 2e 00				ld l, 0 
5dc9 26 00		.eofdone:	ld h, 0 
5dcb c9					ret 
5dcc			 
5dcc			 
5dcc			 
5dcc			 
5dcc			.FORMAT: 
5dcc				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5dcc 6d				db WORD_SYS_CORE+89             
5dcd 20 5e			dw .LABEL            
5dcf 07				db 6 + 1 
5dd0 .. 00			db "FORMAT",0              
5dd7				endm 
# End of macro CWHEAD
5dd7			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5dd7			; | | > [!NOTE] 
5dd7			; | | > Compatible with PicoSPINet  
5dd7					; TODO if current block id for stream is zero then push true else false 
5dd7				 
5dd7				if DEBUG_STORESE 
5dd7					DMARK "FOR" 
5dd7 f5				push af  
5dd8 3a ec 5d			ld a, (.dmark)  
5ddb 32 9d fd			ld (debug_mark),a  
5dde 3a ed 5d			ld a, (.dmark+1)  
5de1 32 9e fd			ld (debug_mark+1),a  
5de4 3a ee 5d			ld a, (.dmark+2)  
5de7 32 9f fd			ld (debug_mark+2),a  
5dea 18 03			jr .pastdmark  
5dec ..			.dmark: db "FOR"  
5def f1			.pastdmark: pop af  
5df0			endm  
# End of macro DMARK
5df0					CALLMONITOR 
5df0 cd aa fd			call debug_vector  
5df3				endm  
# End of macro CALLMONITOR
5df3				endif 
5df3					; Wipes the bank check flags to cause a reformat on next block 0 read 
5df3			 
5df3 21 01 00				ld hl, 1 
5df6 3e 00				ld a, 0 
5df8 cd 79 02				call se_writebyte 
5dfb			 
5dfb				if DEBUG_STORESE 
5dfb					DMARK "FO0" 
5dfb f5				push af  
5dfc 3a 10 5e			ld a, (.dmark)  
5dff 32 9d fd			ld (debug_mark),a  
5e02 3a 11 5e			ld a, (.dmark+1)  
5e05 32 9e fd			ld (debug_mark+1),a  
5e08 3a 12 5e			ld a, (.dmark+2)  
5e0b 32 9f fd			ld (debug_mark+2),a  
5e0e 18 03			jr .pastdmark  
5e10 ..			.dmark: db "FO0"  
5e13 f1			.pastdmark: pop af  
5e14			endm  
# End of macro DMARK
5e14					CALLMONITOR 
5e14 cd aa fd			call debug_vector  
5e17				endm  
# End of macro CALLMONITOR
5e17				endif 
5e17					; force bank init 
5e17			 
5e17 cd 25 05				call storage_get_block_0 
5e1a					 
5e1a				       NEXTW 
5e1a cd a7 fd			call parse_vector 
5e1d c3 a8 23			jp macro_next 
5e20				endm 
# End of macro NEXTW
5e20			.LABEL: 
5e20				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5e20 6d				db WORD_SYS_CORE+89             
5e21 71 5e			dw .STOREPAGE            
5e23 06				db 5 + 1 
5e24 .. 00			db "LABEL",0              
5e2a				endm 
# End of macro CWHEAD
5e2a			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5e2a			; | | > [!NOTE] 
5e2a			; | | > Compatible with PicoSPINet  
5e2a					; TODO test to see if bank is selected 
5e2a				 
5e2a					if DEBUG_FORTH_WORDS_KEY 
5e2a						DMARK "LBL" 
5e2a f5				push af  
5e2b 3a 3f 5e			ld a, (.dmark)  
5e2e 32 9d fd			ld (debug_mark),a  
5e31 3a 40 5e			ld a, (.dmark+1)  
5e34 32 9e fd			ld (debug_mark+1),a  
5e37 3a 41 5e			ld a, (.dmark+2)  
5e3a 32 9f fd			ld (debug_mark+2),a  
5e3d 18 03			jr .pastdmark  
5e3f ..			.dmark: db "LBL"  
5e42 f1			.pastdmark: pop af  
5e43			endm  
# End of macro DMARK
5e43						CALLMONITOR 
5e43 cd aa fd			call debug_vector  
5e46				endm  
# End of macro CALLMONITOR
5e46					endif 
5e46			;	if DEBUG_STORESE 
5e46			;		DMARK "LBL" 
5e46			;		CALLMONITOR 
5e46			;	endif 
5e46					FORTH_DSP_VALUEHL 
5e46 cd bd 21			call macro_dsp_valuehl 
5e49				endm 
# End of macro FORTH_DSP_VALUEHL
5e49					;v5FORTH_DSP_VALUE 
5e49					 
5e49			;		push hl 
5e49					FORTH_DSP_POP 
5e49 cd 75 22			call macro_forth_dsp_pop 
5e4c				endm 
# End of macro FORTH_DSP_POP
5e4c			;		pop hl 
5e4c			 
5e4c			;v5		inc hl   ; move past the type marker 
5e4c			 
5e4c				if DEBUG_STORESE 
5e4c					DMARK "LBl" 
5e4c f5				push af  
5e4d 3a 61 5e			ld a, (.dmark)  
5e50 32 9d fd			ld (debug_mark),a  
5e53 3a 62 5e			ld a, (.dmark+1)  
5e56 32 9e fd			ld (debug_mark+1),a  
5e59 3a 63 5e			ld a, (.dmark+2)  
5e5c 32 9f fd			ld (debug_mark+2),a  
5e5f 18 03			jr .pastdmark  
5e61 ..			.dmark: db "LBl"  
5e64 f1			.pastdmark: pop af  
5e65			endm  
# End of macro DMARK
5e65					CALLMONITOR 
5e65 cd aa fd			call debug_vector  
5e68				endm  
# End of macro CALLMONITOR
5e68				endif 
5e68 cd 49 06				call storage_label 
5e6b			 
5e6b				       NEXTW 
5e6b cd a7 fd			call parse_vector 
5e6e c3 a8 23			jp macro_next 
5e71				endm 
# End of macro NEXTW
5e71			.STOREPAGE: 
5e71				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5e71 6d				db WORD_SYS_CORE+89             
5e72 a7 5e			dw .LABELS            
5e74 0a				db 9 + 1 
5e75 .. 00			db "STOREPAGE",0              
5e7f				endm 
# End of macro CWHEAD
5e7f			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5e7f			; | | > [!NOTE] 
5e7f			; | | > Compatible with PicoSPINet  
5e7f					; TODO test to see if bank is selected 
5e7f				 
5e7f					if DEBUG_FORTH_WORDS_KEY 
5e7f						DMARK "STP" 
5e7f f5				push af  
5e80 3a 94 5e			ld a, (.dmark)  
5e83 32 9d fd			ld (debug_mark),a  
5e86 3a 95 5e			ld a, (.dmark+1)  
5e89 32 9e fd			ld (debug_mark+1),a  
5e8c 3a 96 5e			ld a, (.dmark+2)  
5e8f 32 9f fd			ld (debug_mark+2),a  
5e92 18 03			jr .pastdmark  
5e94 ..			.dmark: db "STP"  
5e97 f1			.pastdmark: pop af  
5e98			endm  
# End of macro DMARK
5e98						CALLMONITOR 
5e98 cd aa fd			call debug_vector  
5e9b				endm  
# End of macro CALLMONITOR
5e9b					endif 
5e9b			;	if DEBUG_STORESE 
5e9b			;		DMARK "STP" 
5e9b			;		CALLMONITOR 
5e9b			;	endif 
5e9b			 
5e9b 21 ac f9			ld hl, store_page 
5e9e cd b8 1f			call forth_push_numhl 
5ea1			 
5ea1			 
5ea1				       NEXTW 
5ea1 cd a7 fd			call parse_vector 
5ea4 c3 a8 23			jp macro_next 
5ea7				endm 
# End of macro NEXTW
5ea7			.LABELS: 
5ea7				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5ea7 6d				db WORD_SYS_CORE+89             
5ea8 34 5f			dw .SCONST1            
5eaa 07				db 6 + 1 
5eab .. 00			db "LABELS",0              
5eb2				endm 
# End of macro CWHEAD
5eb2			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5eb2			; | | > [!CAUTION] 
5eb2			; | | > *NOT* Compatible with PicoSPINet  
5eb2					;  
5eb2			 
5eb2					; save the current device selected to restore afterwards 
5eb2				 
5eb2 3a 92 f9				ld a, (spi_device) 
5eb5 f5					push af 
5eb6			 
5eb6			 
5eb6					; run through each of the banks 
5eb6			 
5eb6 21 01 00				ld hl, 1 
5eb9 cd b8 1f				call forth_push_numhl 
5ebc 3e ff				ld a, SPI_CE_HIGH 
5ebe cb 87				res SPI_CE0, a 
5ec0 32 92 f9				ld (spi_device), a 
5ec3 cd 25 05				call storage_get_block_0 
5ec6 21 af f9				ld hl, store_page+3 
5ec9 cd 26 20				call forth_push_str 
5ecc			 
5ecc					 
5ecc 21 02 00				ld hl, 2 
5ecf cd b8 1f				call forth_push_numhl 
5ed2 3e ff				ld a, SPI_CE_HIGH 
5ed4 cb 8f				res SPI_CE1, a 
5ed6 32 92 f9				ld (spi_device), a 
5ed9 cd 25 05				call storage_get_block_0 
5edc 21 af f9				ld hl, store_page+3 
5edf cd 26 20				call forth_push_str 
5ee2			 
5ee2					 
5ee2 21 03 00				ld hl, 3 
5ee5 cd b8 1f				call forth_push_numhl 
5ee8 3e ff				ld a, SPI_CE_HIGH 
5eea cb 97				res SPI_CE2, a 
5eec 32 92 f9				ld (spi_device), a 
5eef cd 25 05				call storage_get_block_0 
5ef2 21 af f9				ld hl, store_page+3 
5ef5 cd 26 20				call forth_push_str 
5ef8			 
5ef8			 
5ef8 21 04 00				ld hl, 4 
5efb cd b8 1f				call forth_push_numhl 
5efe 3e ff				ld a, SPI_CE_HIGH 
5f00 cb 9f				res SPI_CE3, a 
5f02 32 92 f9				ld (spi_device), a 
5f05 cd 25 05				call storage_get_block_0 
5f08 21 af f9				ld hl, store_page+3 
5f0b cd 26 20				call forth_push_str 
5f0e			 
5f0e					 
5f0e			 
5f0e 21 05 00				ld hl, 5 
5f11 cd b8 1f				call forth_push_numhl 
5f14 3e ff				ld a, SPI_CE_HIGH 
5f16 cb a7				res SPI_CE4, a 
5f18 32 92 f9				ld (spi_device), a 
5f1b cd 25 05				call storage_get_block_0 
5f1e 21 af f9				ld hl, store_page+3 
5f21 cd 26 20				call forth_push_str 
5f24			 
5f24					 
5f24					; push fixed count of storage devices (on board) for now 
5f24			 
5f24 21 05 00				ld hl, 5 
5f27 cd b8 1f				call forth_push_numhl 
5f2a			 
5f2a					; restore selected device  
5f2a				 
5f2a f1					pop af 
5f2b 32 92 f9				ld (spi_device), a 
5f2e			 
5f2e				       NEXTW 
5f2e cd a7 fd			call parse_vector 
5f31 c3 a8 23			jp macro_next 
5f34				endm 
# End of macro NEXTW
5f34			 
5f34			.SCONST1: 
5f34				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5f34 6d				db WORD_SYS_CORE+89             
5f35 4e 5f			dw .SCONST2            
5f37 07				db 6 + 1 
5f38 .. 00			db "FILEID",0              
5f3f				endm 
# End of macro CWHEAD
5f3f			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5f3f			; | | > [!NOTE] 
5f3f			; | | > Compatible with PicoSPINet  
5f3f 3a 99 f9				ld a, (store_filecache) 
5f42 26 00				ld h, 0 
5f44 6f					ld l, a 
5f45 cd b8 1f				call forth_push_numhl 
5f48					NEXTW 
5f48 cd a7 fd			call parse_vector 
5f4b c3 a8 23			jp macro_next 
5f4e				endm 
# End of macro NEXTW
5f4e			.SCONST2: 
5f4e				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5f4e 6d				db WORD_SYS_CORE+89             
5f4f 69 5f			dw .SCONST3            
5f51 08				db 7 + 1 
5f52 .. 00			db "FILEEXT",0              
5f5a				endm 
# End of macro CWHEAD
5f5a			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5f5a			; | | > [!NOTE] 
5f5a			; | | > Compatible with PicoSPINet  
5f5a 3a 9c f9				ld a, (store_openext) 
5f5d 26 00				ld h, 0 
5f5f 6f					ld l, a 
5f60 cd b8 1f				call forth_push_numhl 
5f63					NEXTW 
5f63 cd a7 fd			call parse_vector 
5f66 c3 a8 23			jp macro_next 
5f69				endm 
# End of macro NEXTW
5f69			.SCONST3: 
5f69				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5f69 6d				db WORD_SYS_CORE+89             
5f6a 84 5f			dw .SCONST4            
5f6c 08				db 7 + 1 
5f6d .. 00			db "FILEMAX",0              
5f75				endm 
# End of macro CWHEAD
5f75			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5f75			; | | > [!NOTE] 
5f75			; | | > Compatible with PicoSPINet  
5f75 3a 9b f9				ld a, (store_openmaxext) 
5f78 26 00				ld h, 0 
5f7a 6f					ld l, a 
5f7b cd b8 1f				call forth_push_numhl 
5f7e					NEXTW 
5f7e cd a7 fd			call parse_vector 
5f81 c3 a8 23			jp macro_next 
5f84				endm 
# End of macro NEXTW
5f84			.SCONST4: 
5f84				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5f84 6d				db WORD_SYS_CORE+89             
5f85 9d 5f			dw .SCONST5            
5f87 09				db 8 + 1 
5f88 .. 00			db "FILEADDR",0              
5f91				endm 
# End of macro CWHEAD
5f91			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5f91			; | | > [!NOTE] 
5f91			; | | > Compatible with PicoSPINet  
5f91 2a 9d f9				ld hl, (store_openaddr) 
5f94 cd b8 1f				call forth_push_numhl 
5f97					NEXTW 
5f97 cd a7 fd			call parse_vector 
5f9a c3 a8 23			jp macro_next 
5f9d				endm 
# End of macro NEXTW
5f9d			.SCONST5: 
5f9d				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5f9d 6d				db WORD_SYS_CORE+89             
5f9e c1 5f			dw .SCONST6            
5fa0 09				db 8 + 1 
5fa1 .. 00			db "FILEPAGE",0              
5faa				endm 
# End of macro CWHEAD
5faa			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5faa			; | | > [!NOTE] 
5faa			; | | > Compatible with PicoSPINet  
5faa 2a 9d f9				ld hl, (store_openaddr) 
5fad e5					push hl 
5fae c1					pop bc 
5faf 16 00				ld d, 0 
5fb1 1e 40				ld e, STORE_BLOCK_PHY 
5fb3 cd 3b 0f				call Div16 
5fb6 c5					push bc 
5fb7 e1					pop hl 
5fb8 cd b8 1f				call forth_push_numhl 
5fbb					NEXTW 
5fbb cd a7 fd			call parse_vector 
5fbe c3 a8 23			jp macro_next 
5fc1				endm 
# End of macro NEXTW
5fc1			.SCONST6: 
5fc1				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5fc1 6d				db WORD_SYS_CORE+89             
5fc2 dd 5f			dw .ENDSTORAGE            
5fc4 09				db 8 + 1 
5fc5 .. 00			db "READCONT",0              
5fce				endm 
# End of macro CWHEAD
5fce			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5fce			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5fce			; | | a further read should, if applicable, be CONCAT to the previous read. 
5fce			; | | > [!NOTE] 
5fce			; | | > Compatible with PicoSPINet  
5fce 3a 9f f9				ld a, (store_readcont) 
5fd1 26 00				ld h, 0 
5fd3 6f					ld l, a 
5fd4 cd b8 1f				call forth_push_numhl 
5fd7					NEXTW 
5fd7 cd a7 fd			call parse_vector 
5fda c3 a8 23			jp macro_next 
5fdd				endm 
# End of macro NEXTW
5fdd			.ENDSTORAGE: 
5fdd			; eof 
# End of file forth_words_storage.asm
5fdd			endif 
5fdd				include "forth_words_device.asm" 
5fdd			; Device related words 
5fdd			 
5fdd			; | ## Device Words 
5fdd			 
5fdd			;if SOUND_ENABLE 
5fdd			;.NOTE: 
5fdd			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5fdd			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
5fdd			;		if DEBUG_FORTH_WORDS_KEY 
5fdd			;			DMARK "NTE" 
5fdd			;			CALLMONITOR 
5fdd			;		endif 
5fdd			; 
5fdd			;	 
5fdd			; 
5fdd			;		NEXTW 
5fdd			;.AFTERSOUND: 
5fdd			;endif 
5fdd			 
5fdd			 
5fdd			USE_GPIO: equ 0 
5fdd			 
5fdd			if USE_GPIO 
5fdd			.GP1: 
5fdd				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5fdd			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
5fdd					NEXTW 
5fdd			.GP2: 
5fdd				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5fdd			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
5fdd			 
5fdd					NEXTW 
5fdd			 
5fdd			.GP3: 
5fdd				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5fdd			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
5fdd			 
5fdd					NEXTW 
5fdd			 
5fdd			.GP4: 
5fdd				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5fdd			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
5fdd			 
5fdd					NEXTW 
5fdd			.SIN: 
5fdd			 
5fdd			 
5fdd			endif 
5fdd			 
5fdd			 
5fdd				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5fdd 33				db WORD_SYS_CORE+31             
5fde 15 60			dw .SOUT            
5fe0 03				db 2 + 1 
5fe1 .. 00			db "IN",0              
5fe4				endm 
# End of macro CWHEAD
5fe4			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5fe4					if DEBUG_FORTH_WORDS_KEY 
5fe4						DMARK "IN." 
5fe4 f5				push af  
5fe5 3a f9 5f			ld a, (.dmark)  
5fe8 32 9d fd			ld (debug_mark),a  
5feb 3a fa 5f			ld a, (.dmark+1)  
5fee 32 9e fd			ld (debug_mark+1),a  
5ff1 3a fb 5f			ld a, (.dmark+2)  
5ff4 32 9f fd			ld (debug_mark+2),a  
5ff7 18 03			jr .pastdmark  
5ff9 ..			.dmark: db "IN."  
5ffc f1			.pastdmark: pop af  
5ffd			endm  
# End of macro DMARK
5ffd						CALLMONITOR 
5ffd cd aa fd			call debug_vector  
6000				endm  
# End of macro CALLMONITOR
6000					endif 
6000					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6000 cd bd 21			call macro_dsp_valuehl 
6003				endm 
# End of macro FORTH_DSP_VALUEHL
6003			 
6003 e5					push hl 
6004			 
6004					; destroy value TOS 
6004			 
6004					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6004 cd 75 22			call macro_forth_dsp_pop 
6007				endm 
# End of macro FORTH_DSP_POP
6007			 
6007					; one value on hl get other one back 
6007			 
6007 c1					pop bc 
6008			 
6008					; do the sub 
6008			;		ex de, hl 
6008			 
6008 ed 68				in l,(c) 
600a			 
600a					; save it 
600a			 
600a 26 00				ld h,0 
600c			 
600c					; TODO push value back onto stack for another op etc 
600c			 
600c cd b8 1f				call forth_push_numhl 
600f					NEXTW 
600f cd a7 fd			call parse_vector 
6012 c3 a8 23			jp macro_next 
6015				endm 
# End of macro NEXTW
6015			.SOUT: 
6015				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
6015 34				db WORD_SYS_CORE+32             
6016 6b 60			dw .SPIO            
6018 04				db 3 + 1 
6019 .. 00			db "OUT",0              
601d				endm 
# End of macro CWHEAD
601d			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
601d					if DEBUG_FORTH_WORDS_KEY 
601d						DMARK "OUT" 
601d f5				push af  
601e 3a 32 60			ld a, (.dmark)  
6021 32 9d fd			ld (debug_mark),a  
6024 3a 33 60			ld a, (.dmark+1)  
6027 32 9e fd			ld (debug_mark+1),a  
602a 3a 34 60			ld a, (.dmark+2)  
602d 32 9f fd			ld (debug_mark+2),a  
6030 18 03			jr .pastdmark  
6032 ..			.dmark: db "OUT"  
6035 f1			.pastdmark: pop af  
6036			endm  
# End of macro DMARK
6036						CALLMONITOR 
6036 cd aa fd			call debug_vector  
6039				endm  
# End of macro CALLMONITOR
6039					endif 
6039			 
6039					; get port 
6039			 
6039					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6039 cd bd 21			call macro_dsp_valuehl 
603c				endm 
# End of macro FORTH_DSP_VALUEHL
603c			 
603c e5					push hl 
603d			 
603d					; destroy value TOS 
603d			 
603d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
603d cd 75 22			call macro_forth_dsp_pop 
6040				endm 
# End of macro FORTH_DSP_POP
6040			 
6040					; get byte to send 
6040			 
6040					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6040 cd bd 21			call macro_dsp_valuehl 
6043				endm 
# End of macro FORTH_DSP_VALUEHL
6043			 
6043			;		push hl 
6043			 
6043					; destroy value TOS 
6043			 
6043					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6043 cd 75 22			call macro_forth_dsp_pop 
6046				endm 
# End of macro FORTH_DSP_POP
6046			 
6046					; one value on hl get other one back 
6046			 
6046			;		pop hl 
6046			 
6046 c1					pop bc 
6047			 
6047					if DEBUG_FORTH_WORDS 
6047						DMARK "OUT" 
6047 f5				push af  
6048 3a 5c 60			ld a, (.dmark)  
604b 32 9d fd			ld (debug_mark),a  
604e 3a 5d 60			ld a, (.dmark+1)  
6051 32 9e fd			ld (debug_mark+1),a  
6054 3a 5e 60			ld a, (.dmark+2)  
6057 32 9f fd			ld (debug_mark+2),a  
605a 18 03			jr .pastdmark  
605c ..			.dmark: db "OUT"  
605f f1			.pastdmark: pop af  
6060			endm  
# End of macro DMARK
6060						CALLMONITOR 
6060 cd aa fd			call debug_vector  
6063				endm  
# End of macro CALLMONITOR
6063					endif 
6063			 
6063 ed 69				out (c), l 
6065			 
6065					NEXTW 
6065 cd a7 fd			call parse_vector 
6068 c3 a8 23			jp macro_next 
606b				endm 
# End of macro NEXTW
606b			 
606b			 
606b			.SPIO: 
606b			 
606b			if STORAGE_SE 
606b				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
606b 51				db WORD_SYS_CORE+61             
606c 7f 60			dw .SPICEH            
606e 07				db 6 + 1 
606f .. 00			db "SPICEL",0              
6076				endm 
# End of macro CWHEAD
6076			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
6076			 
6076 cd 22 02				call spi_ce_low 
6079			    NEXTW 
6079 cd a7 fd			call parse_vector 
607c c3 a8 23			jp macro_next 
607f				endm 
# End of macro NEXTW
607f			 
607f			.SPICEH: 
607f				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
607f 51				db WORD_SYS_CORE+61             
6080 93 60			dw .SPIOb            
6082 07				db 6 + 1 
6083 .. 00			db "SPICEH",0              
608a				endm 
# End of macro CWHEAD
608a			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
608a			 
608a cd 11 02				call spi_ce_high 
608d			    NEXTW 
608d cd a7 fd			call parse_vector 
6090 c3 a8 23			jp macro_next 
6093				endm 
# End of macro NEXTW
6093			 
6093			 
6093			.SPIOb: 
6093			 
6093				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
6093 51				db WORD_SYS_CORE+61             
6094 c8 60			dw .SPII            
6096 05				db 4 + 1 
6097 .. 00			db "SPIO",0              
609c				endm 
# End of macro CWHEAD
609c			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
609c			 
609c					if DEBUG_FORTH_WORDS_KEY 
609c						DMARK "SPo" 
609c f5				push af  
609d 3a b1 60			ld a, (.dmark)  
60a0 32 9d fd			ld (debug_mark),a  
60a3 3a b2 60			ld a, (.dmark+1)  
60a6 32 9e fd			ld (debug_mark+1),a  
60a9 3a b3 60			ld a, (.dmark+2)  
60ac 32 9f fd			ld (debug_mark+2),a  
60af 18 03			jr .pastdmark  
60b1 ..			.dmark: db "SPo"  
60b4 f1			.pastdmark: pop af  
60b5			endm  
# End of macro DMARK
60b5						CALLMONITOR 
60b5 cd aa fd			call debug_vector  
60b8				endm  
# End of macro CALLMONITOR
60b8					endif 
60b8					; get port 
60b8			 
60b8			 
60b8					; get byte to send 
60b8			 
60b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
60b8 cd bd 21			call macro_dsp_valuehl 
60bb				endm 
# End of macro FORTH_DSP_VALUEHL
60bb			 
60bb			;		push hl    ; u1  
60bb			 
60bb					; destroy value TOS 
60bb			 
60bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
60bb cd 75 22			call macro_forth_dsp_pop 
60be				endm 
# End of macro FORTH_DSP_POP
60be			 
60be					; one value on hl get other one back 
60be			 
60be			;		pop hl   ; u2 - addr 
60be			 
60be					; TODO Send SPI byte 
60be			 
60be			;		push hl 
60be			;		call spi_ce_low 
60be			;		pop hl 
60be 7d					ld a, l 
60bf cd 10 01				call spi_send_byte 
60c2			;		call spi_ce_high 
60c2			 
60c2					NEXTW 
60c2 cd a7 fd			call parse_vector 
60c5 c3 a8 23			jp macro_next 
60c8				endm 
# End of macro NEXTW
60c8			 
60c8			.SPII: 
60c8				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
60c8 52				db WORD_SYS_CORE+62             
60c9 34 61			dw .SESEL            
60cb 06				db 5 + 1 
60cc .. 00			db "SPII",0              
60d1				endm 
# End of macro CWHEAD
60d1			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
60d1					if DEBUG_FORTH_WORDS_KEY 
60d1						DMARK "SPi" 
60d1 f5				push af  
60d2 3a e6 60			ld a, (.dmark)  
60d5 32 9d fd			ld (debug_mark),a  
60d8 3a e7 60			ld a, (.dmark+1)  
60db 32 9e fd			ld (debug_mark+1),a  
60de 3a e8 60			ld a, (.dmark+2)  
60e1 32 9f fd			ld (debug_mark+2),a  
60e4 18 03			jr .pastdmark  
60e6 ..			.dmark: db "SPi"  
60e9 f1			.pastdmark: pop af  
60ea			endm  
# End of macro DMARK
60ea						CALLMONITOR 
60ea cd aa fd			call debug_vector  
60ed				endm  
# End of macro CALLMONITOR
60ed					endif 
60ed			 
60ed					; TODO Get SPI byte 
60ed			 
60ed cd 37 01				call spi_read_byte 
60f0			 
60f0					if DEBUG_FORTH_WORDS 
60f0						DMARK "Si2" 
60f0 f5				push af  
60f1 3a 05 61			ld a, (.dmark)  
60f4 32 9d fd			ld (debug_mark),a  
60f7 3a 06 61			ld a, (.dmark+1)  
60fa 32 9e fd			ld (debug_mark+1),a  
60fd 3a 07 61			ld a, (.dmark+2)  
6100 32 9f fd			ld (debug_mark+2),a  
6103 18 03			jr .pastdmark  
6105 ..			.dmark: db "Si2"  
6108 f1			.pastdmark: pop af  
6109			endm  
# End of macro DMARK
6109						CALLMONITOR 
6109 cd aa fd			call debug_vector  
610c				endm  
# End of macro CALLMONITOR
610c					endif 
610c 26 00				ld h, 0 
610e 6f					ld l, a 
610f					if DEBUG_FORTH_WORDS 
610f						DMARK "Si3" 
610f f5				push af  
6110 3a 24 61			ld a, (.dmark)  
6113 32 9d fd			ld (debug_mark),a  
6116 3a 25 61			ld a, (.dmark+1)  
6119 32 9e fd			ld (debug_mark+1),a  
611c 3a 26 61			ld a, (.dmark+2)  
611f 32 9f fd			ld (debug_mark+2),a  
6122 18 03			jr .pastdmark  
6124 ..			.dmark: db "Si3"  
6127 f1			.pastdmark: pop af  
6128			endm  
# End of macro DMARK
6128						CALLMONITOR 
6128 cd aa fd			call debug_vector  
612b				endm  
# End of macro CALLMONITOR
612b					endif 
612b cd b8 1f				call forth_push_numhl 
612e			 
612e					NEXTW 
612e cd a7 fd			call parse_vector 
6131 c3 a8 23			jp macro_next 
6134				endm 
# End of macro NEXTW
6134			 
6134			 
6134			 
6134			.SESEL: 
6134				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
6134 66				db WORD_SYS_CORE+82             
6135 e0 61			dw .CARTDEV            
6137 05				db 4 + 1 
6138 .. 00			db "BANK",0              
613d				endm 
# End of macro CWHEAD
613d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
613d					if DEBUG_FORTH_WORDS_KEY 
613d						DMARK "BNK" 
613d f5				push af  
613e 3a 52 61			ld a, (.dmark)  
6141 32 9d fd			ld (debug_mark),a  
6144 3a 53 61			ld a, (.dmark+1)  
6147 32 9e fd			ld (debug_mark+1),a  
614a 3a 54 61			ld a, (.dmark+2)  
614d 32 9f fd			ld (debug_mark+2),a  
6150 18 03			jr .pastdmark  
6152 ..			.dmark: db "BNK"  
6155 f1			.pastdmark: pop af  
6156			endm  
# End of macro DMARK
6156						CALLMONITOR 
6156 cd aa fd			call debug_vector  
6159				endm  
# End of macro CALLMONITOR
6159					endif 
6159			 
6159 3e ff				ld a, 255 
615b 32 95 f9				ld (spi_cartdev), a 
615e			 
615e					; get bank 
615e			 
615e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
615e cd bd 21			call macro_dsp_valuehl 
6161				endm 
# End of macro FORTH_DSP_VALUEHL
6161			 
6161			;		push hl 
6161			 
6161					; destroy value TOS 
6161			 
6161					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6161 cd 75 22			call macro_forth_dsp_pop 
6164				endm 
# End of macro FORTH_DSP_POP
6164			 
6164					; one value on hl get other one back 
6164			 
6164			;		pop hl 
6164			 
6164			 
6164 0e ff				ld c, SPI_CE_HIGH 
6166 06 30				ld b, '0'    ; human readable bank number 
6168			 
6168 7d					ld a, l 
6169			 
6169					if DEBUG_FORTH_WORDS 
6169						DMARK "BNK" 
6169 f5				push af  
616a 3a 7e 61			ld a, (.dmark)  
616d 32 9d fd			ld (debug_mark),a  
6170 3a 7f 61			ld a, (.dmark+1)  
6173 32 9e fd			ld (debug_mark+1),a  
6176 3a 80 61			ld a, (.dmark+2)  
6179 32 9f fd			ld (debug_mark+2),a  
617c 18 03			jr .pastdmark  
617e ..			.dmark: db "BNK"  
6181 f1			.pastdmark: pop af  
6182			endm  
# End of macro DMARK
6182						CALLMONITOR 
6182 cd aa fd			call debug_vector  
6185				endm  
# End of macro CALLMONITOR
6185					endif 
6185			 
6185					; active low 
6185			 
6185 fe 00				cp 0 
6187 28 28				jr z, .bset 
6189 fe 01				cp 1 
618b 20 04				jr nz, .b2 
618d cb 81				res 0, c 
618f 06 31				ld b, '1'    ; human readable bank number 
6191 fe 02		.b2:		cp 2 
6193 20 04				jr nz, .b3 
6195 cb 89				res 1, c 
6197 06 32				ld b, '2'    ; human readable bank number 
6199 fe 03		.b3:		cp 3 
619b 20 04				jr nz, .b4 
619d cb 91				res 2, c 
619f 06 33				ld b, '3'    ; human readable bank number 
61a1 fe 04		.b4:		cp 4 
61a3 20 04				jr nz, .b5 
61a5 cb 99				res 3, c 
61a7 06 34				ld b, '4'    ; human readable bank number 
61a9 fe 05		.b5:		cp 5 
61ab 20 04				jr nz, .bset 
61ad cb a1				res 4, c 
61af 06 35				ld b, '5'    ; human readable bank number 
61b1			 
61b1			.bset: 
61b1 79					ld a, c 
61b2 32 92 f9				ld (spi_device),a 
61b5 78					ld a, b 
61b6 32 91 f9				ld (spi_device_id),a 
61b9					if DEBUG_FORTH_WORDS 
61b9						DMARK "BN2" 
61b9 f5				push af  
61ba 3a ce 61			ld a, (.dmark)  
61bd 32 9d fd			ld (debug_mark),a  
61c0 3a cf 61			ld a, (.dmark+1)  
61c3 32 9e fd			ld (debug_mark+1),a  
61c6 3a d0 61			ld a, (.dmark+2)  
61c9 32 9f fd			ld (debug_mark+2),a  
61cc 18 03			jr .pastdmark  
61ce ..			.dmark: db "BN2"  
61d1 f1			.pastdmark: pop af  
61d2			endm  
# End of macro DMARK
61d2						CALLMONITOR 
61d2 cd aa fd			call debug_vector  
61d5				endm  
# End of macro CALLMONITOR
61d5					endif 
61d5			 
61d5					; set default SPI clk pulse time as disabled for BANK use 
61d5			 
61d5 3e 00				ld a, 0 
61d7 32 96 f9				ld (spi_clktime), a 
61da			 
61da					NEXTW 
61da cd a7 fd			call parse_vector 
61dd c3 a8 23			jp macro_next 
61e0				endm 
# End of macro NEXTW
61e0			 
61e0			.CARTDEV: 
61e0				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
61e0 66				db WORD_SYS_CORE+82             
61e1 91 62			dw .ENDDEVICE            
61e3 08				db 7 + 1 
61e4 .. 00			db "CARTDEV",0              
61ec				endm 
# End of macro CWHEAD
61ec			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
61ec					if DEBUG_FORTH_WORDS_KEY 
61ec						DMARK "CDV" 
61ec f5				push af  
61ed 3a 01 62			ld a, (.dmark)  
61f0 32 9d fd			ld (debug_mark),a  
61f3 3a 02 62			ld a, (.dmark+1)  
61f6 32 9e fd			ld (debug_mark+1),a  
61f9 3a 03 62			ld a, (.dmark+2)  
61fc 32 9f fd			ld (debug_mark+2),a  
61ff 18 03			jr .pastdmark  
6201 ..			.dmark: db "CDV"  
6204 f1			.pastdmark: pop af  
6205			endm  
# End of macro DMARK
6205						CALLMONITOR 
6205 cd aa fd			call debug_vector  
6208				endm  
# End of macro CALLMONITOR
6208					endif 
6208			 
6208					; disable se storage bank selection 
6208			 
6208 3e ff				ld a, SPI_CE_HIGH		; ce high 
620a 32 92 f9				ld (spi_device), a 
620d			 
620d					; get bank 
620d			 
620d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
620d cd bd 21			call macro_dsp_valuehl 
6210				endm 
# End of macro FORTH_DSP_VALUEHL
6210			 
6210			;		push hl 
6210			 
6210					; destroy value TOS 
6210			 
6210					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6210 cd 75 22			call macro_forth_dsp_pop 
6213				endm 
# End of macro FORTH_DSP_POP
6213			 
6213					; one value on hl get other one back 
6213			 
6213			;		pop hl 
6213			 
6213					; active low 
6213			 
6213 0e ff				ld c, 255 
6215			 
6215 7d					ld a, l 
6216					if DEBUG_FORTH_WORDS 
6216						DMARK "CDV" 
6216 f5				push af  
6217 3a 2b 62			ld a, (.dmark)  
621a 32 9d fd			ld (debug_mark),a  
621d 3a 2c 62			ld a, (.dmark+1)  
6220 32 9e fd			ld (debug_mark+1),a  
6223 3a 2d 62			ld a, (.dmark+2)  
6226 32 9f fd			ld (debug_mark+2),a  
6229 18 03			jr .pastdmark  
622b ..			.dmark: db "CDV"  
622e f1			.pastdmark: pop af  
622f			endm  
# End of macro DMARK
622f						CALLMONITOR 
622f cd aa fd			call debug_vector  
6232				endm  
# End of macro CALLMONITOR
6232					endif 
6232 fe 00				cp 0 
6234 28 30				jr z, .cset 
6236 fe 01				cp 1 
6238 20 02				jr nz, .c2 
623a cb 81				res 0, c 
623c fe 02		.c2:		cp 2 
623e 20 02				jr nz, .c3 
6240 cb 89				res 1, c 
6242 fe 03		.c3:		cp 3 
6244 20 02				jr nz, .c4 
6246 cb 91				res 2, c 
6248 fe 04		.c4:		cp 4 
624a 20 02				jr nz, .c5 
624c cb 99				res 3, c 
624e fe 05		.c5:		cp 5 
6250 20 02				jr nz, .c6 
6252 cb a1				res 4, c 
6254 fe 06		.c6:		cp 6 
6256 20 02				jr nz, .c7 
6258 cb a9				res 5, c 
625a fe 07		.c7:		cp 7 
625c 20 02				jr nz, .c8 
625e cb b1				res 6, c 
6260 fe 08		.c8:		cp 8 
6262 20 02				jr nz, .cset 
6264 cb b9				res 7, c 
6266 79			.cset:		ld a, c 
6267 32 95 f9				ld (spi_cartdev),a 
626a			 
626a					if DEBUG_FORTH_WORDS 
626a						DMARK "CD2" 
626a f5				push af  
626b 3a 7f 62			ld a, (.dmark)  
626e 32 9d fd			ld (debug_mark),a  
6271 3a 80 62			ld a, (.dmark+1)  
6274 32 9e fd			ld (debug_mark+1),a  
6277 3a 81 62			ld a, (.dmark+2)  
627a 32 9f fd			ld (debug_mark+2),a  
627d 18 03			jr .pastdmark  
627f ..			.dmark: db "CD2"  
6282 f1			.pastdmark: pop af  
6283			endm  
# End of macro DMARK
6283						CALLMONITOR 
6283 cd aa fd			call debug_vector  
6286				endm  
# End of macro CALLMONITOR
6286					endif 
6286			 
6286					; set default SPI clk pulse time as 10ms for CARTDEV use 
6286			 
6286 3e 0a				ld a, $0a 
6288 32 96 f9				ld (spi_clktime), a 
628b					NEXTW 
628b cd a7 fd			call parse_vector 
628e c3 a8 23			jp macro_next 
6291				endm 
# End of macro NEXTW
6291			endif 
6291			 
6291			.ENDDEVICE: 
6291			; eof 
6291			 
# End of file forth_words_device.asm
6291			 
6291			; var handler 
6291			 
6291			 
6291			.VARS: 
6291				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
6291 77				db WORD_SYS_CORE+99             
6292 45 63			dw .V0            
6294 04				db 3 + 1 
6295 .. 00			db "VAR",0              
6299				endm 
# End of macro CWHEAD
6299			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
6299			;| 
6299			;| The variable name should consist of a single letter. e.g. "a" 
6299			;! If a full string is passed then only the first char is looked at 
6299			;| Any other char could exceed bounds checks!  
6299			 
6299					if DEBUG_FORTH_WORDS_KEY 
6299						DMARK "VAR" 
6299 f5				push af  
629a 3a ae 62			ld a, (.dmark)  
629d 32 9d fd			ld (debug_mark),a  
62a0 3a af 62			ld a, (.dmark+1)  
62a3 32 9e fd			ld (debug_mark+1),a  
62a6 3a b0 62			ld a, (.dmark+2)  
62a9 32 9f fd			ld (debug_mark+2),a  
62ac 18 03			jr .pastdmark  
62ae ..			.dmark: db "VAR"  
62b1 f1			.pastdmark: pop af  
62b2			endm  
# End of macro DMARK
62b2						CALLMONITOR 
62b2 cd aa fd			call debug_vector  
62b5				endm  
# End of macro CALLMONITOR
62b5					endif 
62b5			 
62b5					FORTH_DSP_VALUEHL 
62b5 cd bd 21			call macro_dsp_valuehl 
62b8				endm 
# End of macro FORTH_DSP_VALUEHL
62b8			 
62b8 7e					ld a, (hl)    ; get first char on of the string 
62b9			 
62b9			 
62b9					if DEBUG_FORTH_WORDS 
62b9						DMARK "VR1" 
62b9 f5				push af  
62ba 3a ce 62			ld a, (.dmark)  
62bd 32 9d fd			ld (debug_mark),a  
62c0 3a cf 62			ld a, (.dmark+1)  
62c3 32 9e fd			ld (debug_mark+1),a  
62c6 3a d0 62			ld a, (.dmark+2)  
62c9 32 9f fd			ld (debug_mark+2),a  
62cc 18 03			jr .pastdmark  
62ce ..			.dmark: db "VR1"  
62d1 f1			.pastdmark: pop af  
62d2			endm  
# End of macro DMARK
62d2						CALLMONITOR 
62d2 cd aa fd			call debug_vector  
62d5				endm  
# End of macro CALLMONITOR
62d5					endif 
62d5					 
62d5 f5					push af	 
62d6					FORTH_DSP_POP 
62d6 cd 75 22			call macro_forth_dsp_pop 
62d9				endm 
# End of macro FORTH_DSP_POP
62d9 f1					pop af 
62da			 
62da					; convert to upper 
62da			 
62da cd 53 12				call to_upper 
62dd					if DEBUG_FORTH_WORDS 
62dd						DMARK "Vaa" 
62dd f5				push af  
62de 3a f2 62			ld a, (.dmark)  
62e1 32 9d fd			ld (debug_mark),a  
62e4 3a f3 62			ld a, (.dmark+1)  
62e7 32 9e fd			ld (debug_mark+1),a  
62ea 3a f4 62			ld a, (.dmark+2)  
62ed 32 9f fd			ld (debug_mark+2),a  
62f0 18 03			jr .pastdmark  
62f2 ..			.dmark: db "Vaa"  
62f5 f1			.pastdmark: pop af  
62f6			endm  
# End of macro DMARK
62f6						CALLMONITOR 
62f6 cd aa fd			call debug_vector  
62f9				endm  
# End of macro CALLMONITOR
62f9					endif 
62f9 06 41				ld b, 'A' 
62fb 90					sub b			; set offset 
62fc					if DEBUG_FORTH_WORDS 
62fc						DMARK "Vbb" 
62fc f5				push af  
62fd 3a 11 63			ld a, (.dmark)  
6300 32 9d fd			ld (debug_mark),a  
6303 3a 12 63			ld a, (.dmark+1)  
6306 32 9e fd			ld (debug_mark+1),a  
6309 3a 13 63			ld a, (.dmark+2)  
630c 32 9f fd			ld (debug_mark+2),a  
630f 18 03			jr .pastdmark  
6311 ..			.dmark: db "Vbb"  
6314 f1			.pastdmark: pop af  
6315			endm  
# End of macro DMARK
6315						CALLMONITOR 
6315 cd aa fd			call debug_vector  
6318				endm  
# End of macro CALLMONITOR
6318					endif 
6318 cb 27				sla a  
631a				 
631a					 
631a					if DEBUG_FORTH_WORDS 
631a						DMARK "VR2" 
631a f5				push af  
631b 3a 2f 63			ld a, (.dmark)  
631e 32 9d fd			ld (debug_mark),a  
6321 3a 30 63			ld a, (.dmark+1)  
6324 32 9e fd			ld (debug_mark+1),a  
6327 3a 31 63			ld a, (.dmark+2)  
632a 32 9f fd			ld (debug_mark+2),a  
632d 18 03			jr .pastdmark  
632f ..			.dmark: db "VR2"  
6332 f1			.pastdmark: pop af  
6333			endm  
# End of macro DMARK
6333						CALLMONITOR 
6333 cd aa fd			call debug_vector  
6336				endm  
# End of macro CALLMONITOR
6336					endif 
6336			 
6336 21 26 f9				ld hl, cli_var_array2 
6339 cd de 0f				call addatohl 
633c cd b8 1f				call forth_push_numhl 
633f			 
633f			 
633f				       NEXTW 
633f cd a7 fd			call parse_vector 
6342 c3 a8 23			jp macro_next 
6345				endm 
# End of macro NEXTW
6345			.V0: 
6345				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
6345 78				db WORD_SYS_CORE+100             
6346 60 63			dw .V0Q            
6348 04				db 3 + 1 
6349 .. 00			db "V0!",0              
634d				endm 
# End of macro CWHEAD
634d			;| V0! ( u1 -- )  Store value to v0  | DONE 
634d			 
634d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
634d cd bd 21			call macro_dsp_valuehl 
6350				endm 
# End of macro FORTH_DSP_VALUEHL
6350			 
6350 11 5a f9				ld de, cli_var_array 
6353			 
6353 eb					ex de, hl 
6354 73					ld (hl), e 
6355 23					inc hl 
6356 72					ld (hl), d 
6357			 
6357					; destroy value TOS 
6357			 
6357					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6357 cd 75 22			call macro_forth_dsp_pop 
635a				endm 
# End of macro FORTH_DSP_POP
635a			 
635a				       NEXTW 
635a cd a7 fd			call parse_vector 
635d c3 a8 23			jp macro_next 
6360				endm 
# End of macro NEXTW
6360			.V0Q: 
6360				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
6360 79				db WORD_SYS_CORE+101             
6361 74 63			dw .V1S            
6363 04				db 3 + 1 
6364 .. 00			db "V0@",0              
6368				endm 
# End of macro CWHEAD
6368			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
6368 2a 5a f9				ld hl, (cli_var_array) 
636b cd b8 1f				call forth_push_numhl 
636e			 
636e				       NEXTW 
636e cd a7 fd			call parse_vector 
6371 c3 a8 23			jp macro_next 
6374				endm 
# End of macro NEXTW
6374			.V1S: 
6374				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
6374 7a				db WORD_SYS_CORE+102             
6375 8f 63			dw .V1Q            
6377 04				db 3 + 1 
6378 .. 00			db "V1!",0              
637c				endm 
# End of macro CWHEAD
637c			;| V1! ( u1 -- )  Store value to v1 | DONE 
637c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
637c cd bd 21			call macro_dsp_valuehl 
637f				endm 
# End of macro FORTH_DSP_VALUEHL
637f			 
637f 11 5c f9				ld de, cli_var_array+2 
6382				 
6382 eb					ex de, hl 
6383 73					ld (hl), e 
6384 23					inc hl 
6385 72					ld (hl), d 
6386			 
6386					; destroy value TOS 
6386			 
6386					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6386 cd 75 22			call macro_forth_dsp_pop 
6389				endm 
# End of macro FORTH_DSP_POP
6389				       NEXTW 
6389 cd a7 fd			call parse_vector 
638c c3 a8 23			jp macro_next 
638f				endm 
# End of macro NEXTW
638f			.V1Q: 
638f				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
638f 7b				db WORD_SYS_CORE+103             
6390 a3 63			dw .V2S            
6392 04				db 3 + 1 
6393 .. 00			db "V1@",0              
6397				endm 
# End of macro CWHEAD
6397			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
6397 2a 5c f9				ld hl, (cli_var_array+2) 
639a cd b8 1f				call forth_push_numhl 
639d				       NEXTW 
639d cd a7 fd			call parse_vector 
63a0 c3 a8 23			jp macro_next 
63a3				endm 
# End of macro NEXTW
63a3			.V2S: 
63a3				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
63a3 7c				db WORD_SYS_CORE+104             
63a4 be 63			dw .V2Q            
63a6 04				db 3 + 1 
63a7 .. 00			db "V2!",0              
63ab				endm 
# End of macro CWHEAD
63ab			;| V2! ( u1 -- )  Store value to v2 | DONE 
63ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
63ab cd bd 21			call macro_dsp_valuehl 
63ae				endm 
# End of macro FORTH_DSP_VALUEHL
63ae			 
63ae 11 5e f9				ld de, cli_var_array+4 
63b1				 
63b1 eb					ex de, hl 
63b2 73					ld (hl), e 
63b3 23					inc hl 
63b4 72					ld (hl), d 
63b5			 
63b5					; destroy value TOS 
63b5			 
63b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
63b5 cd 75 22			call macro_forth_dsp_pop 
63b8				endm 
# End of macro FORTH_DSP_POP
63b8				       NEXTW 
63b8 cd a7 fd			call parse_vector 
63bb c3 a8 23			jp macro_next 
63be				endm 
# End of macro NEXTW
63be			.V2Q: 
63be				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
63be 7d				db WORD_SYS_CORE+105             
63bf d2 63			dw .V3S            
63c1 04				db 3 + 1 
63c2 .. 00			db "V2@",0              
63c6				endm 
# End of macro CWHEAD
63c6			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
63c6 2a 5e f9				ld hl, (cli_var_array+4) 
63c9 cd b8 1f				call forth_push_numhl 
63cc				       NEXTW 
63cc cd a7 fd			call parse_vector 
63cf c3 a8 23			jp macro_next 
63d2				endm 
# End of macro NEXTW
63d2			.V3S: 
63d2				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
63d2 7c				db WORD_SYS_CORE+104             
63d3 ed 63			dw .V3Q            
63d5 04				db 3 + 1 
63d6 .. 00			db "V3!",0              
63da				endm 
# End of macro CWHEAD
63da			;| V3! ( u1 -- )  Store value to v3 | DONE 
63da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
63da cd bd 21			call macro_dsp_valuehl 
63dd				endm 
# End of macro FORTH_DSP_VALUEHL
63dd			 
63dd 11 60 f9				ld de, cli_var_array+6 
63e0				 
63e0 eb					ex de, hl 
63e1 73					ld (hl), e 
63e2 23					inc hl 
63e3 72					ld (hl), d 
63e4			 
63e4					; destroy value TOS 
63e4			 
63e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
63e4 cd 75 22			call macro_forth_dsp_pop 
63e7				endm 
# End of macro FORTH_DSP_POP
63e7				       NEXTW 
63e7 cd a7 fd			call parse_vector 
63ea c3 a8 23			jp macro_next 
63ed				endm 
# End of macro NEXTW
63ed			.V3Q: 
63ed				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
63ed 7d				db WORD_SYS_CORE+105             
63ee 01 64			dw .END            
63f0 04				db 3 + 1 
63f1 .. 00			db "V3@",0              
63f5				endm 
# End of macro CWHEAD
63f5			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
63f5 2a 60 f9				ld hl, (cli_var_array+6) 
63f8 cd b8 1f				call forth_push_numhl 
63fb				       NEXTW 
63fb cd a7 fd			call parse_vector 
63fe c3 a8 23			jp macro_next 
6401				endm 
# End of macro NEXTW
6401			 
6401			 
6401			 
6401			 
6401			 
6401			; end of dict marker 
6401			 
6401 00			.END:    db WORD_SYS_END 
6402 00 00			dw 0 
6404 00				db 0 
6405			 
6405			; use to jp here for user dict words to save on macro expansion  
6405			 
6405			user_dict_next: 
6405				NEXTW 
6405 cd a7 fd			call parse_vector 
6408 c3 a8 23			jp macro_next 
640b				endm 
# End of macro NEXTW
640b			 
640b			 
640b			user_exec: 
640b				;    ld hl, <word code> 
640b				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
640b				;    call forthexec 
640b				;    jp user_dict_next   (NEXT) 
640b			        ;    <word code bytes> 
640b eb				ex de, hl 
640c 2a f4 f3			ld hl,(os_tok_ptr) 
640f				 
640f				FORTH_RSP_NEXT 
640f cd 5f 1f			call macro_forth_rsp_next 
6412				endm 
# End of macro FORTH_RSP_NEXT
6412			 
6412			if DEBUG_FORTH_UWORD 
6412						DMARK "UEX" 
6412 f5				push af  
6413 3a 27 64			ld a, (.dmark)  
6416 32 9d fd			ld (debug_mark),a  
6419 3a 28 64			ld a, (.dmark+1)  
641c 32 9e fd			ld (debug_mark+1),a  
641f 3a 29 64			ld a, (.dmark+2)  
6422 32 9f fd			ld (debug_mark+2),a  
6425 18 03			jr .pastdmark  
6427 ..			.dmark: db "UEX"  
642a f1			.pastdmark: pop af  
642b			endm  
# End of macro DMARK
642b				CALLMONITOR 
642b cd aa fd			call debug_vector  
642e				endm  
# End of macro CALLMONITOR
642e			endif 
642e			 
642e			 
642e			 
642e eb				ex de, hl 
642f 22 f4 f3			ld (os_tok_ptr), hl 
6432				 
6432				; Don't use next - Skips the first word in uword. 
6432			 
6432 c3 31 24			jp exec1 
6435			;	NEXT 
6435			 
6435			 
6435			; eof 
# End of file forth_wordsv4.asm
6435			endif 
6435			;;;;;;;;;;;;;; Debug code 
6435			 
6435			 
6435			;if DEBUG_FORTH_PARSE 
6435 .. 00		.nowordfound: db "No match",0 
643e .. 00		.compword:	db "Comparing word ",0 
644e .. 00		.nextwordat:	db "Next word at",0 
645b .. 00		.charmatch:	db "Char match",0 
6466			;endif 
6466			if DEBUG_FORTH_JP 
6466			.foundword:	db "Word match. Exec..",0 
6466			endif 
6466			;if DEBUG_FORTH_PUSH 
6466 .. 00		.enddict:	db "Dict end. Push.",0 
6476 .. 00		.push_str:	db "Pushing string",0 
6485 .. 00		.push_num:	db "Pushing number",0 
6494 .. 00		.data_sp:	db "SP:",0 
6498 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
64aa .. 00		.wordinde:	db "Word in DE (3/0):",0 
64bc .. 00		.wordinbc:	db "Word in BC (4/0):",0 
64ce			;endif 
64ce			;if DEBUG_FORTH_MALLOC 
64ce .. 00		.push_malloc:	db "Malloc address",0 
64dd			;endif 
64dd			 
64dd			 
64dd			 
64dd			; display malloc address and current data stack pointer  
64dd			 
64dd			malloc_error: 
64dd d5				push de 
64de f5				push af 
64df e5				push hl 
64e0 cd aa 0d			call clear_display 
64e3 11 03 65			ld de, .mallocerr 
64e6 3e 00			ld a,0 
64e8			;	ld de,os_word_scratch 
64e8 cd bd 0d			call str_at_display 
64eb 3e 11			ld a, display_row_1+17 
64ed 11 9d fd			ld de, debug_mark 
64f0 cd bd 0d			call str_at_display 
64f3 cd cd 0d			call update_display 
64f6				;call break_point_state 
64f6 cd e8 79			call cin_wait 
64f9			 
64f9			;	ld a, ' ' 
64f9			;	ld (os_view_disable), a 
64f9 cd c3 18			call bp_on 
64fc e1				pop hl 
64fd f1				pop af 
64fe d1				pop de	 
64ff				CALLMONITOR 
64ff cd aa fd			call debug_vector  
6502				endm  
# End of macro CALLMONITOR
6502 c9				ret 
6503			 
6503 .. 00		.mallocerr: 	db "Malloc Error",0 
6510			;if DEBUG_FORTH_PUSH 
6510			display_data_sp: 
6510 f5				push af 
6511			 
6511				; see if disabled 
6511			 
6511			 
6511 3a aa fd			ld a, (debug_vector) 
6514 fe c9			cp $C9  ; RET 
6516				;ld a, (os_view_disable) 
6516				;cp '*' 
6516 28 67			jr z, .skipdsp 
6518			 
6518 e5				push hl 
6519 e5				push hl 
651a e5			push hl 
651b cd aa 0d			call clear_display 
651e e1			pop hl 
651f 7c				ld a,h 
6520 21 f8 f3			ld hl, os_word_scratch 
6523 cd e7 11			call hexout 
6526 e1				pop hl 
6527 7d				ld a,l 
6528 21 fa f3			ld hl, os_word_scratch+2 
652b cd e7 11			call hexout 
652e 21 fc f3			ld hl, os_word_scratch+4 
6531 3e 00			ld a,0 
6533 77				ld (hl),a 
6534 11 f8 f3			ld de,os_word_scratch 
6537 3e 28				ld a, display_row_2 
6539 cd bd 0d				call str_at_display 
653c 11 98 64			ld de, .wordinhl 
653f 3e 00			ld a, display_row_1 
6541			 
6541 cd bd 0d				call str_at_display 
6544 11 9d fd			ld de, debug_mark 
6547 3e 11			ld a, display_row_1+17 
6549			 
6549 cd bd 0d				call str_at_display 
654c			 
654c				; display current data stack pointer 
654c 11 94 64			ld de,.data_sp 
654f 3e 30				ld a, display_row_2 + 8 
6551 cd bd 0d				call str_at_display 
6554			 
6554 2a 20 f9			ld hl,(cli_data_sp) 
6557 e5				push hl 
6558 7c				ld a,h 
6559 21 f8 f3			ld hl, os_word_scratch 
655c cd e7 11			call hexout 
655f e1				pop hl 
6560 7d				ld a,l 
6561 21 fa f3			ld hl, os_word_scratch+2 
6564 cd e7 11			call hexout 
6567 21 fc f3			ld hl, os_word_scratch+4 
656a 3e 00			ld a,0 
656c 77				ld (hl),a 
656d 11 f8 f3			ld de,os_word_scratch 
6570 3e 33				ld a, display_row_2 + 11 
6572 cd bd 0d				call str_at_display 
6575			 
6575			 
6575 cd cd 0d			call update_display 
6578 cd ed 0c			call delay1s 
657b cd ed 0c			call delay1s 
657e e1				pop hl 
657f			.skipdsp: 
657f f1				pop af 
6580 c9				ret 
6581			 
6581			display_data_malloc: 
6581			 
6581 f5				push af 
6582 e5				push hl 
6583 e5				push hl 
6584 e5			push hl 
6585 cd aa 0d			call clear_display 
6588 e1			pop hl 
6589 7c				ld a,h 
658a 21 f8 f3			ld hl, os_word_scratch 
658d cd e7 11			call hexout 
6590 e1				pop hl 
6591 7d				ld a,l 
6592 21 fa f3			ld hl, os_word_scratch+2 
6595 cd e7 11			call hexout 
6598 21 fc f3			ld hl, os_word_scratch+4 
659b 3e 00			ld a,0 
659d 77				ld (hl),a 
659e 11 f8 f3			ld de,os_word_scratch 
65a1 3e 28				ld a, display_row_2 
65a3 cd bd 0d				call str_at_display 
65a6 11 ce 64			ld de, .push_malloc 
65a9 3e 00			ld a, display_row_1 
65ab			 
65ab cd bd 0d				call str_at_display 
65ae			 
65ae				; display current data stack pointer 
65ae 11 94 64			ld de,.data_sp 
65b1 3e 30				ld a, display_row_2 + 8 
65b3 cd bd 0d				call str_at_display 
65b6			 
65b6 2a 20 f9			ld hl,(cli_data_sp) 
65b9 e5				push hl 
65ba 7c				ld a,h 
65bb 21 f8 f3			ld hl, os_word_scratch 
65be cd e7 11			call hexout 
65c1 e1				pop hl 
65c2 7d				ld a,l 
65c3 21 fa f3			ld hl, os_word_scratch+2 
65c6 cd e7 11			call hexout 
65c9 21 fc f3			ld hl, os_word_scratch+4 
65cc 3e 00			ld a,0 
65ce 77				ld (hl),a 
65cf 11 f8 f3			ld de,os_word_scratch 
65d2 3e 33				ld a, display_row_2 + 11 
65d4 cd bd 0d				call str_at_display 
65d7			 
65d7 cd cd 0d			call update_display 
65da cd ed 0c			call delay1s 
65dd cd ed 0c			call delay1s 
65e0 e1				pop hl 
65e1 f1				pop af 
65e2 c9				ret 
65e3			;endif 
65e3			 
65e3			include "forth_autostart.asm" 
65e3			; list of commands to perform at system start up 
65e3			 
65e3			startcmds: 
65e3			;	dw test11 
65e3			;	dw test12 
65e3			;	dw test13 
65e3			;	dw test14 
65e3			;	dw test15 
65e3			;	dw test16 
65e3			;	dw test17 
65e3			;	dw ifthtest1 
65e3			;	dw ifthtest2 
65e3			;	dw ifthtest3 
65e3			;	dw mmtest1 
65e3			;	dw mmtest2 
65e3			;	dw mmtest3 
65e3			;	dw mmtest4 
65e3			;	dw mmtest5 
65e3			;	dw mmtest6 
65e3			;	dw iftest1 
65e3			;	dw iftest2 
65e3			;	dw iftest3 
65e3			;	dw looptest1 
65e3			;	dw looptest2 
65e3			;	dw test1 
65e3			;	dw test2 
65e3			;	dw test3 
65e3			;	dw test4 
65e3			;	dw game2r 
65e3			;	dw game2b1 
65e3			;	dw game2b2 
65e3			 
65e3				; start up words that are actually useful 
65e3			 
65e3			;    dw spi1 
65e3			;    dw spi2 
65e3			;    dw spi3 
65e3			;    dw spi4 
65e3			;    dw spi5 
65e3			;    dw spi6 
65e3			;    dw spi7 
65e3			; 
65e3			;    dw spi8 
65e3			;    dw spi9 
65e3			;    dw spi10 
65e3			 
65e3			; file editor 
65e3			;	dw edit1 
65e3			;	dw edit2 
65e3			;	dw edit3 
65e3			 
65e3			;	dw longread 
65e3 05 6a			dw clrstack 
65e5 39 6a			dw type 
65e7			;	dw stest 
65e7 5e 6a			dw strncpy 
65e9 ce 6b			dw list 
65eb bf 6a			dw start1 
65ed cf 6a			dw start2 
65ef			;	dw start3 
65ef			;	dw start3b 
65ef			;	dw start3c 
65ef			 
65ef				; (unit) testing words 
65ef			 
65ef			;	dw mtesta 
65ef			;	dw mtestb 
65ef			;	dw mtestc 
65ef			;	dw mtestd 
65ef			;	dw mteste 
65ef			 
65ef				; demo/game words 
65ef			 
65ef			;        dw game3w 
65ef			;        dw game3p 
65ef			;        dw game3sc 
65ef			;        dw game3vsi 
65ef			;        dw game3vs 
65ef				 
65ef			;	dw game2b 
65ef			;	dw game2bf 
65ef			;	dw game2mba 
65ef			;	dw game2mbas 
65ef			;	dw game2mb 
65ef			 
65ef ff 6d			dw game1 
65f1 10 6e			dw game1a 
65f3 72 6e			dw game1b 
65f5 a7 6e			dw game1c 
65f7 dd 6e			dw game1d 
65f9 0e 6f			dw game1s 
65fb 22 6f			dw game1t 
65fd 37 6f			dw game1f 
65ff 6b 6f			dw game1z 
6601 af 6f			dw game1zz 
6603			 
6603 38 6c			dw test5 
6605 70 6c			dw test6 
6607 a8 6c			dw test7 
6609 bc 6c			dw test8 
660b e8 6c			dw test9 
660d fe 6c			dw test10 
660f				 
660f 86 70		        dw ssv5 
6611 6a 70		        dw ssv4 
6613 4e 70		        dw ssv3 
6615 18 70		        dw ssv2 
6617 9f 70		        dw ssv1 
6619 e7 70		        dw ssv1cpm 
661b			;	dw keyup 
661b			;	dw keydown 
661b			;	dw keyleft 
661b			;	dw keyright 
661b			;	dw 	keyf1 
661b			;	dw keyf2 
661b			;	dw keyf3 
661b			;	dw keyf4 
661b			;	dw keyf5 
661b			;	dw keyf6 
661b			;	dw keyf7 
661b			;	dw keyf8 
661b			;	dw keyf9 
661b			;	dw keyf10 
661b			;	dw keyf11 
661b			;	dw keyf12 
661b			;	dw keytab 
661b			;	dw keycr 
661b			;	dw keyhome 
661b			;	dw keyend 
661b			;	dw keybs 
661b 00 00			db 0, 0	 
661d			 
661d			 
661d			; File Editor 
661d			 
661d			; ( id - ) use 'e' to edit the displayed line 
661d .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
663e .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6673			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6673 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
66ab			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
66ab			 
66ab			; SPI Net support words 
66ab			 
66ab			; v0! = node to send to 
66ab			; ( str count - ) 
66ab .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6704			 
6704			; spiputc ( char node - ) 
6704 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
6738			; spiputc ( u node - ) 
6738 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
6766			 
6766			; spigetc ( - n ) 
6766 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
678f			 
678f			; getnode ( - n ) 
678f .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
67bc			 
67bc			; ( str node - )  
67bc .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6822			; store string ( str i - ) 
6822			 
6822			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6822 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
6877			 
6877			; get string ( addr i -  )    TO FIX 
6877			 
6877 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
68cf			 
68cf			 
68cf			; NETCHAT (TODO) 
68cf			; Program to allow two nodes to chat with eachother 
68cf			; 
68cf			; v0 - target node 
68cf			;  
68cf			; accept input at 0,0 
68cf			; if input is string send spitype to target node 
68cf			; starting at row 2,0 , while spigetchr is not zero ->  
68cf			; 
68cf			; 
68cf			; TODO add paging of get request 
68cf			 
68cf			; ( node - ) 
68cf .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
68ee .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6946 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
69be			 
69be			 
69be			; Long read of currently open file 
69be .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6a05			 
6a05			; clear stack  
6a05			 
6a05 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
6a39			 
6a39			; type ( addr count - ) 
6a39 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6a5e			 
6a5e			; some direct memory words 
6a5e			; strncpy ( len t f -- t ) 
6a5e			 
6a5e .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6abf			 
6abf .. 00		start1:     	db ": bpon $00 bp ;",0 
6acf .. 00		start2:     	db ": bpoff $01 bp ;",0 
6ae0 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6b5b .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6bbb			 
6bbb .. 00		tuck:         db ": tuck swap over ;", 0 
6bce			 
6bce			; a handy word to list items on the stack 
6bce			 
6bce .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6c38			 
6c38			 
6c38			; test stack  
6c38			; rnd8 stest 
6c38			 
6c38			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6c38			 
6c38			; random malloc and free cycles 
6c38			 
6c38			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6c38			 
6c38			; fixed malloc and free cycles 
6c38			 
6c38			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6c38			 
6c38			; fixed double string push and drop cycle  
6c38			 
6c38			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6c38			 
6c38			; consistent fixed string push and drop cycle  
6c38			 
6c38			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6c38			 
6c38			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6c38			 
6c38			;test1:		db ": aa 1 2 3 ;", 0 
6c38			;test2:     	db "111 aa 888 999",0 
6c38			;test3:     	db ": bb 77 ;",0 
6c38			;test4:     	db "$02 $01 do i . loop bb",0 
6c38			 
6c38 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6c70 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6ca8 .. 00		test7:     	db ": box hline vline ;",0 
6cbc .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6ce8 .. 00		test9:     	db ": sw $01 adsp world ;",0 
6cfe .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6d23			;test11:     	db "hello create .",0 
6d23			;test12:     	db "hello2 create .",0 
6d23			 
6d23			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6d23			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6d23			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6d23			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6d23			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6d23			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6d23			 
6d23			;iftest1:     	db "$0001 IF cls .",0 
6d23			;iftest2:     	db "$0000 IF cls .",0 
6d23			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6d23			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6d23			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6d23			 
6d23			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6d23			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6d23			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6d23			 
6d23			 
6d23 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6d47 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6d77 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6d9c .. 00		sound4: db ": cha $00 ; ",0 
6da9 .. 00		sound5: db ": chb $20 ; ",0 
6db6 .. 00		sound6: db ": chc $40 ; ",0 
6dc3 .. 00		sound7: db ": chd $60 ; ",0 
6dd0 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6de8 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6dff			 
6dff			 
6dff			 
6dff			 
6dff			; a small guess the number game 
6dff			 
6dff .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6e10 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6e72			 
6e72 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6ea7 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6edd .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6f0e .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6f22 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6f37 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6f6b .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6faf			 
6faf			; Using 'ga' save a high score across multiple runs using external storage 
6faf			 
6faf .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
7018			 
7018			 
7018			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
7018			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
7018			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
7018			 
7018			; simple screen saver to test code memory reuse to destruction 
7018			 
7018 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
704e .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
706a .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
7086 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
709f .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
70e7 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
713e			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
713e			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
713e			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
713e			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
713e			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
713e			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
713e			 
713e			 
713e			 
713e			; minesweeper/battleship finding game 
713e			; draws a game board of random ship/mine positions 
713e			; user enters coords to see if it hits on 
713e			; game ends when all are hit 
713e			; when hit or miss says how many may be in the area 
713e			 
713e			; setup the game board and then hide it 
713e			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
713e			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
713e			;; prompt for where to target 
713e			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
713e			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
713e			;; TODO see if the entered coords hits or misses pushes char hit of miss 
713e			;game2mbht:      db ": mbckht nop ;",0 
713e			;game2mbms:      db ": mbcms nop ;",0 
713e			; TODO how many might be near by 
713e			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
713e			 
713e			; Game 3 
713e			 
713e			; Vert scroller ski game - avoid the trees! 
713e			 
713e			; v0 score (ie turns) 
713e			; v1 player pos 
713e			; v2 left wall 
713e			; v3 right wall 
713e			 
713e			; Draw side walls randomly 
713e			 
713e			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
713e			 
713e			; Draw player 
713e			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
713e			 
713e			; TODO Get Key 
713e			 
713e			; TODO Move left right 
713e			 
713e			; scroll and move walls a bit 
713e			 
713e			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
713e			 
713e			; main game loop 
713e			 
713e			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
713e			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
713e			 
713e			; key board defs 
713e			 
713e .. 00		keyup:       db ": keyup $05 ;",0 
714c .. 00		keydown:       db ": keydown $0a ;",0 
715c .. 00		keyleft:       db ": keyleft $0b ;",0 
716c .. 00		keyright:       db ": keyright $0c ;",0 
717d .. 00		keyf1:       db ": keyf1 $10 ;",0 
718b .. 00		keyf2:       db ": keyf2 $11 ;",0 
7199 .. 00		keyf3:       db ": keyf3 $12 ;",0 
71a7 .. 00		keyf4:       db ": keyf4 $13 ;",0 
71b5 .. 00		keyf5:       db ": keyf5 $14 ;",0 
71c3 .. 00		keyf6:       db ": keyf6 $15 ;",0 
71d1 .. 00		keyf7:       db ": keyf7 $16 ;",0 
71df .. 00		keyf8:       db ": keyf8 $17 ;",0 
71ed .. 00		keyf9:       db ": keyf9 $18 ;",0 
71fb .. 00		keyf10:       db ": keyf10 $19 ;",0 
720a .. 00		keyf11:       db ": keyf11 $1a ;",0 
7219 .. 00		keyf12:       db ": keyf12 $1b ;",0 
7228			 
7228 .. 00		keytab:       db ": keytab $09 ;",0 
7237 .. 00		keycr:       db ": keycr $0d ;",0 
7245 .. 00		keyhome:       db ": keyhome $0e ;",0 
7255 .. 00		keyend:       db ": keyend $0f ;",0 
7264 .. 00		keybs:       db ": keybs $08 ;",0 
7272			 
7272			   
7272			 
7272			 
7272			 
7272			; eof 
# End of file forth_autostart.asm
7272			 
7272			 
7272			 
7272			; stack over and underflow checks 
7272			 
7272			; init the words to detect the under/overflow 
7272			 
7272			chk_stk_init: 
7272				; a vague random number to check so we dont get any "lucky" hits 
7272 3e 2d			ld a, 45 
7274 6f				ld l, a 
7275 00				nop 
7276 3e 17			ld a, 23 
7278 67				ld h, a 
7279			 
7279 22 cf f0			ld (chk_word), hl     ; the word we need to check against 
727c			 
727c			;	ld (chk_stund), hl	; stack points.... 
727c 22 3b fe			ld (chk_stovr), hl 
727f 22 1e f9			ld (chk_ret_und), hl 
7282 22 dc f8			ld (chk_ret_ovr), hl 
7285 22 5a f8			ld (chk_loop_ovr), hl 
7288 22 58 f6			ld (chk_data_ovr), hl 
728b c9				ret 
728c				 
728c			check_stacks: 
728c				; check all stack words 
728c			 
728c e5				push hl 
728d d5				push de 
728e			 
728e			;	ld de,(chk_word) 
728e			;	ld hl, (chk_stund)	; stack points.... 
728e			;	if DEBUG_STK_FAULT 
728e			;		DMARK "FAa" 
728e			;		CALLMONITOR 
728e			;	endif 
728e			;	call cmp16 
728e			;	jp z, .chk_faulta 
728e			; 
728e			;	ld de, sfaultsu 
728e			;	jp .chk_fault 
728e			 
728e 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
7291 ed 5b cf f0		ld de,(chk_word) 
7295				if DEBUG_STK_FAULT 
7295					DMARK "FAb" 
7295					CALLMONITOR 
7295				endif 
7295 cd fc 0f			call cmp16 
7298 28 06			jr z, .chk_fault1 
729a 11 3e 73			ld de, sfaultso 
729d c3 ef 72			jp .chk_fault 
72a0			.chk_fault1:  
72a0 2a 1e f9			ld hl, (chk_ret_und) 
72a3 ed 5b cf f0		ld de,(chk_word) 
72a7				if DEBUG_STK_FAULT 
72a7					DMARK "FAU" 
72a7					CALLMONITOR 
72a7				endif 
72a7 cd fc 0f			call cmp16 
72aa ca b3 72			jp z, .chk_fault2 
72ad 11 4e 73			ld de, sfaultru 
72b0 c3 ef 72			jp .chk_fault 
72b3			.chk_fault2:  
72b3 2a dc f8			ld hl, (chk_ret_ovr) 
72b6 ed 5b cf f0		ld de,(chk_word) 
72ba				if DEBUG_STK_FAULT 
72ba					DMARK "FA1" 
72ba					CALLMONITOR 
72ba				endif 
72ba cd fc 0f			call cmp16 
72bd ca c6 72			jp z, .chk_fault3 
72c0 11 5c 73			ld de, sfaultro 
72c3 c3 ef 72			jp .chk_fault 
72c6			.chk_fault3:  
72c6 2a 5a f8			ld hl, (chk_loop_ovr) 
72c9 ed 5b cf f0		ld de,(chk_word) 
72cd				if DEBUG_STK_FAULT 
72cd					DMARK "FA2" 
72cd					CALLMONITOR 
72cd				endif 
72cd cd fc 0f			call cmp16 
72d0 ca d9 72			jp z, .chk_fault4 
72d3 11 76 73			ld de, sfaultlo 
72d6 c3 ef 72			jp .chk_fault 
72d9			.chk_fault4:  
72d9 2a 58 f6			ld hl, (chk_data_ovr) 
72dc ed 5b cf f0		ld de,(chk_word) 
72e0				if DEBUG_STK_FAULT 
72e0					DMARK "FA3" 
72e0					CALLMONITOR 
72e0				endif 
72e0 cd fc 0f			call cmp16 
72e3 ca ec 72			jp z, .chk_fault5 
72e6 11 90 73			ld de, sfaultdo 
72e9 c3 ef 72			jp .chk_fault 
72ec			 
72ec			 
72ec			.chk_fault5:  
72ec d1				pop de 
72ed e1				pop hl 
72ee			 
72ee c9				ret 
72ef			 
72ef cd aa 0d		.chk_fault: 	call clear_display 
72f2 3e 28				ld a, display_row_2 
72f4 cd bd 0d				call str_at_display 
72f7 11 20 73				   ld de, .stackfault 
72fa 3e 00				ld a, display_row_1 
72fc cd bd 0d				call str_at_display 
72ff 11 9d fd				    ld de, debug_mark 
7302 3e 11				ld a, display_row_1+17 
7304 cd bd 0d				call str_at_display 
7307 cd cd 0d				call update_display 
730a			 
730a				; prompt before entering montior for investigating issue 
730a			 
730a 3e 78			ld a, display_row_4 
730c 11 96 1c			ld de, endprog 
730f			 
730f cd cd 0d			call update_display		 
7312			 
7312 cd 30 1f			call next_page_prompt 
7315			 
7315 d1				pop de 
7316 e1				pop hl 
7317 cd ea 1c				call monitor 
731a cd 4e 23				call forth_warmstart 
731d c3 e6 1b				jp warmstart_afterauto 
7320					;jp 0 
7320					;halt 
7320			 
7320			 
7320			 
7320 .. 00		.stackfault: 	db "Stack fault:",0 
732d			 
732d .. 00		sfaultsu: 	db	"Stack under flow",0 
733e .. 00		sfaultso: 	db	"Stack over flow",0 
734e .. 00		sfaultru:	db "RTS underflow",0 
735c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7376 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7390 .. 00		sfaultdo:	db "DTS overflow", 0 
739d			 
739d			 
739d			fault_dsp_under: 
739d 11 af 73			ld de, .dsp_under 
73a0 c3 65 74			jp .show_fault 
73a3			 
73a3			fault_rsp_under: 
73a3 11 bd 73			ld de, .rsp_under 
73a6 c3 65 74			jp .show_fault 
73a9			fault_loop_under: 
73a9 11 cb 73			ld de, .loop_under 
73ac c3 65 74			jp .show_fault 
73af			 
73af .. 00		.dsp_under: db "DSP Underflow",0 
73bd .. 00		.rsp_under: db "RSP Underflow",0 
73cb .. 00		.loop_under: db "LOOP Underflow",0 
73da			 
73da			 
73da d5			type_faultn: 	push de 
73db e5					push hl 
73dc cd aa 0d				call clear_display 
73df 11 09 74				   ld de, .typefaultn 
73e2 3e 00				ld a, display_row_1 
73e4 cd bd 0d				call str_at_display 
73e7 11 9d fd				    ld de, debug_mark 
73ea 3e 11				ld a, display_row_1+17 
73ec cd bd 0d				call str_at_display 
73ef cd cd 0d				call update_display 
73f2			 
73f2				; prompt before entering montior for investigating issue 
73f2			 
73f2 3e 78			ld a, display_row_4 
73f4 11 96 1c			ld de, endprog 
73f7			 
73f7 cd cd 0d			call update_display		 
73fa			 
73fa cd 30 1f			call next_page_prompt 
73fd			 
73fd e5					push hl 
73fe d5					push de 
73ff cd ea 1c				call monitor 
7402 cd 4e 23				call forth_warmstart 
7405 c3 e6 1b				jp warmstart_afterauto 
7408 76					halt 
7409			 
7409			 
7409 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7420			 
7420 d5			type_faults: 	push de 
7421 e5					push hl 
7422 cd aa 0d				call clear_display 
7425 11 4e 74				   ld de, .typefaults 
7428 3e 00				ld a, display_row_1 
742a cd bd 0d				call str_at_display 
742d 11 9d fd				    ld de, debug_mark 
7430 3e 11				ld a, display_row_1+17 
7432 cd bd 0d				call str_at_display 
7435 cd cd 0d				call update_display 
7438			 
7438				; prompt before entering montior for investigating issue 
7438			 
7438 3e 78			ld a, display_row_4 
743a 11 96 1c			ld de, endprog 
743d			 
743d cd cd 0d			call update_display		 
7440			 
7440 cd 30 1f			call next_page_prompt 
7443			 
7443 e1					pop hl 
7444 d1					pop de 
7445 cd ea 1c				call monitor 
7448 cd 4e 23				call forth_warmstart 
744b c3 e6 1b				jp warmstart_afterauto 
744e			 
744e			 
744e .. 00		.typefaults: db "STR Type Expected TOS!",0 
7465			 
7465			.show_fault: 	 
7465 d5					push de 
7466 cd aa 0d				call clear_display 
7469 d1					pop de 
746a 3e 00				ld a, display_row_1 
746c cd bd 0d				call str_at_display 
746f 11 9d fd				    ld de, debug_mark 
7472 3e 11				ld a, display_row_1+17 
7474 cd bd 0d				call str_at_display 
7477 cd cd 0d				call update_display 
747a			 
747a				; prompt before entering montior for investigating issue 
747a			 
747a 3e 78			ld a, display_row_4 
747c 11 96 1c			ld de, endprog 
747f			 
747f cd cd 0d			call update_display		 
7482			 
7482 cd 30 1f			call next_page_prompt 
7485			 
7485 e1					pop hl 
7486 d1					pop de 
7487 cd ea 1c				call monitor 
748a			; do a dump to cli and not warmstart so we preserve all of the uwords.  
748a			; TODO Make optional fault restart to cli or warm boot? 
748a					;jp warmstart 
748a c3 2a 1c				jp cli 
748d 76					halt 
748e			 
748e			 
748e			; handle the auto run of code from files in storage 
748e			 
748e			 
748e			include "forth_startup.asm" 
748e			; Which startup method to use? 
748e			; 
748e			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
748e			; followed by loading of a list of scripts in eeprom 
748e			 
748e			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
748e			; from eeprom 
748e			 
748e			; Select with define in main stubs 
748e			 
748e			if STARTUP_V1 
748e				include "forth_startupv1.asm" 
748e			endif 
748e			if STARTUP_V2 
748e				include "forth_startupv2.asm" 
748e			; Version 2 of the startup  
748e			;  
748e			; Auto load any files in bank 1 that start with a '*' 
748e			; If no se storage then revert to using eprom 
748e			 
748e			 
748e			if STORAGE_SE = 0 
748e			 
748e			sprompt1: db "Startup load...",0 
748e			sprompt2: db "Run? 1=No *=End #=All",0 
748e			 
748e			 
748e			 
748e			 
748e			forth_startup: 
748e				ld hl, startcmds 
748e				ld a, 0 
748e				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
748e			 
748e			.start1:	push hl 
748e				call clear_display 
748e				ld de, sprompt1 
748e			        ld a, display_row_1 
748e				call str_at_display 
748e				ld de, sprompt2 
748e			        ld a, display_row_2 
748e				call str_at_display 
748e				pop hl 
748e				push hl 
748e				ld e,(hl) 
748e				inc hl 
748e				ld d,(hl) 
748e			        ld a, display_row_3 
748e				call str_at_display 
748e				call update_display 
748e			 
748e			 
748e				ld a, (os_last_cmd) 
748e				cp 0 
748e				jr z, .startprompt 
748e				call delay250ms 
748e				jr .startdo 
748e				 
748e				 
748e			 
748e			.startprompt: 
748e			 
748e				ld a,display_row_4 + display_cols - 1 
748e			        ld de, endprg 
748e				call str_at_display 
748e				call update_display 
748e				call delay1s 
748e				call cin_wait 
748e						 
748e				cp '*' 
748e				jr z, .startupend1 
748e				cp '#' 
748e				jr nz, .startno 
748e				ld a, 1 
748e				ld (os_last_cmd),a 
748e				jr .startdo 
748e			.startno:	cp '1' 
748e				jr z,.startnxt  
748e			 
748e				; exec startup line 
748e			.startdo:	 
748e				pop hl 
748e				push hl 
748e				 
748e				ld e,(hl) 
748e				inc hl 
748e				ld d,(hl) 
748e				ex de,hl 
748e			 
748e				push hl 
748e			 
748e				ld a, 0 
748e				;ld a, FORTH_END_BUFFER 
748e				call strlent 
748e				inc hl   ; include zero term to copy 
748e				ld b,0 
748e				ld c,l 
748e				pop hl 
748e				ld de, scratch 
748e				ldir 
748e			 
748e			 
748e				ld hl, scratch 
748e				call forthparse 
748e				call forthexec 
748e				call forthexec_cleanup 
748e			 
748e				ld a, display_row_4 
748e				ld de, endprog 
748e			 
748e				call update_display		 
748e			 
748e				ld a, (os_last_cmd) 
748e				cp 0 
748e				jr nz, .startnxt 
748e				call next_page_prompt 
748e			        call clear_display 
748e				call update_display		 
748e			 
748e				; move onto next startup line? 
748e			.startnxt: 
748e			 
748e				call delay250ms 
748e				pop hl 
748e			 
748e				inc hl 
748e				inc hl 
748e			 
748e				push hl 
748e				ld e, (hl) 
748e				inc hl 
748e				ld d, (hl) 
748e				pop hl 
748e				; TODO replace 0 test 
748e			 
748e				ex de, hl 
748e				call ishlzero 
748e			;	ld a,e 
748e			;	add d 
748e			;	cp 0    ; any left to do? 
748e				ex de, hl 
748e				jp nz, .start1 
748e				jr .startupend 
748e			 
748e			.startupend1: pop hl 
748e			.startupend: 
748e			 
748e				call clear_display 
748e				call update_display 
748e				ret 
748e			endif 
748e			 
748e			 
748e			if STORAGE_SE 
748e			 
748e			;sprompt3: db "Loading from start-up file:",0 
748e .. 00		sprompt3: db "  Searching...",0 
749d			;sprompt4: db "(Any key to stop)",0 
749d			 
749d			 
749d			forth_autoload: 
749d			 
749d				; load block 0 of store 1 
749d				 
749d 3e fe			ld a, $fe      ; bit 0 clear 
749f 32 92 f9			ld (spi_device), a 
74a2			 
74a2 cd 25 05			call storage_get_block_0 
74a5			 
74a5 3a cd f9			ld a, (store_page+STORE_0_AUTOFILE) 
74a8			 
74a8 fe 00			cp 0 
74aa c8				ret z     ; auto start not enabled 
74ab			 
74ab cd aa 0d			call clear_display 
74ae			 
74ae				; set bank 
74ae			 
74ae 3a cf f9				ld a, (store_page+STORE_0_BANKRUN) 
74b1 32 92 f9				ld (spi_device), a 
74b4			 
74b4			 
74b4				; generate a directory of bank 1 and search for flagged files 
74b4			 
74b4					if DEBUG_FORTH_WORDS_KEY 
74b4						DMARK "DIR" 
74b4 f5				push af  
74b5 3a c9 74			ld a, (.dmark)  
74b8 32 9d fd			ld (debug_mark),a  
74bb 3a ca 74			ld a, (.dmark+1)  
74be 32 9e fd			ld (debug_mark+1),a  
74c1 3a cb 74			ld a, (.dmark+2)  
74c4 32 9f fd			ld (debug_mark+2),a  
74c7 18 03			jr .pastdmark  
74c9 ..			.dmark: db "DIR"  
74cc f1			.pastdmark: pop af  
74cd			endm  
# End of macro DMARK
74cd						CALLMONITOR 
74cd cd aa fd			call debug_vector  
74d0				endm  
# End of macro CALLMONITOR
74d0					endif 
74d0			 
74d0 cd 25 05			call storage_get_block_0 
74d3			 
74d3 21 ac f9			ld hl, store_page     ; get current id count 
74d6 46				ld b, (hl) 
74d7 0e 00			ld c, 0    ; count of files   
74d9					if DEBUG_FORTH_WORDS 
74d9						DMARK "DI1" 
74d9 f5				push af  
74da 3a ee 74			ld a, (.dmark)  
74dd 32 9d fd			ld (debug_mark),a  
74e0 3a ef 74			ld a, (.dmark+1)  
74e3 32 9e fd			ld (debug_mark+1),a  
74e6 3a f0 74			ld a, (.dmark+2)  
74e9 32 9f fd			ld (debug_mark+2),a  
74ec 18 03			jr .pastdmark  
74ee ..			.dmark: db "DI1"  
74f1 f1			.pastdmark: pop af  
74f2			endm  
# End of macro DMARK
74f2						CALLMONITOR 
74f2 cd aa fd			call debug_vector  
74f5				endm  
# End of macro CALLMONITOR
74f5					endif 
74f5			 
74f5				; check for empty drive 
74f5			 
74f5 3e 00			ld a, 0 
74f7 b8				cp b 
74f8 ca 45 75			jp z, .dirdone 
74fb			 
74fb				; for each of the current ids do a search for them and if found push to stack 
74fb			 
74fb c5			.diritem:	push bc 
74fc 21 40 00				ld hl, STORE_BLOCK_PHY 
74ff 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
7501 58					ld e,b 
7502			 
7502 d5					push de 
7503 e5					push hl 
7504 cd aa 0d			call clear_display 
7507 3e 32			ld a, display_row_2 + 10 
7509 11 8e 74			ld de, sprompt3 
750c cd bd 0d			call str_at_display 
750f cd 01 0d			call active 
7512 eb				ex de, hl 
7513 3e 2f			ld a, display_row_2 + 7 
7515 cd bd 0d			call str_at_display 
7518 cd cd 0d			call update_display 
751b e1				pop hl 
751c d1				pop de 
751d			 
751d			;		if DEBUG_FORTH_WORDS 
751d			;			DMARK "DI2" 
751d			;			CALLMONITOR 
751d			;		endif 
751d			 
751d cd a7 07				call storage_findnextid 
7520			 
7520			;		if DEBUG_FORTH_WORDS 
7520			;			DMARK "DI3" 
7520			;			CALLMONITOR 
7520			;		endif 
7520			 
7520					; if found hl will be non zero 
7520			 
7520 cd 07 10				call ishlzero 
7523			;		ld a, l 
7523			;		add h 
7523			; 
7523			;		cp 0 
7523 28 1d				jr z, .dirnotfound 
7525			 
7525					; increase count 
7525			 
7525 c1					pop bc	 
7526 0c					inc c 
7527 c5					push bc 
7528					 
7528			 
7528					; get file header and push the file name 
7528			 
7528 11 ac f9				ld de, store_page 
752b cd 74 04				call storage_read_block 
752e			 
752e					; push file id to stack 
752e				 
752e			 
752e					; is this a file we want to run? 
752e			 
752e 21 af f9				ld hl, store_page+3 
7531 7e					ld a,(hl) 
7532 fe 2a				cp '*' 
7534 20 0c				jr nz,  .dirnotfound 
7536					 
7536			 
7536			 
7536 3a ac f9				ld a, (store_page) 
7539 d5					push de 
753a e5					push hl 
753b c5					push bc 
753c cd 68 75				call .autorunf 
753f c1					pop bc 
7540 e1					pop hl 
7541 d1					pop de 
7542			 
7542			 
7542			 
7542				; save this extent 
7542			 
7542					; push file name 
7542			;display file name to run 
7542			 
7542			;		ld hl, store_page+3 
7542			;		if DEBUG_FORTH_WORDS 
7542			;			DMARK "DI5" 
7542			;			CALLMONITOR 
7542			;		endif 
7542			; 
7542			;		 
7542			; 
7542			;		call forth_push_str 
7542			;		if DEBUG_FORTH_WORDS 
7542			;			DMARK "DI6" 
7542			;			CALLMONITOR 
7542			;		endif 
7542			.dirnotfound: 
7542 c1					pop bc     
7543 10 b6				djnz .diritem 
7545				 
7545			.dirdone:	 
7545					if DEBUG_FORTH_WORDS 
7545						DMARK "DI7" 
7545 f5				push af  
7546 3a 5a 75			ld a, (.dmark)  
7549 32 9d fd			ld (debug_mark),a  
754c 3a 5b 75			ld a, (.dmark+1)  
754f 32 9e fd			ld (debug_mark+1),a  
7552 3a 5c 75			ld a, (.dmark+2)  
7555 32 9f fd			ld (debug_mark+2),a  
7558 18 03			jr .pastdmark  
755a ..			.dmark: db "DI7"  
755d f1			.pastdmark: pop af  
755e			endm  
# End of macro DMARK
755e						CALLMONITOR 
755e cd aa fd			call debug_vector  
7561				endm  
# End of macro CALLMONITOR
7561					endif 
7561			 
7561 cd aa 0d				call clear_display 
7564 cd cd 0d				call update_display 
7567			 
7567 c9					ret 
7568			 
7568			 
7568			 
7568			 
7568			 
7568			.autorunf: 
7568			 
7568			 
7568				; get file id to load from and get the file name to display 
7568			 
7568			;		ld a, (store_page+STORE_0_FILERUN) 
7568			 
7568 2e 00				ld l, 0 
756a 67					ld h, a 
756b 11 ac f9				ld de, store_page 
756e			 
756e					if DEBUG_FORTH_WORDS 
756e						DMARK "ASp" 
756e f5				push af  
756f 3a 83 75			ld a, (.dmark)  
7572 32 9d fd			ld (debug_mark),a  
7575 3a 84 75			ld a, (.dmark+1)  
7578 32 9e fd			ld (debug_mark+1),a  
757b 3a 85 75			ld a, (.dmark+2)  
757e 32 9f fd			ld (debug_mark+2),a  
7581 18 03			jr .pastdmark  
7583 ..			.dmark: db "ASp"  
7586 f1			.pastdmark: pop af  
7587			endm  
# End of macro DMARK
7587						CALLMONITOR 
7587 cd aa fd			call debug_vector  
758a				endm  
# End of macro CALLMONITOR
758a					endif 
758a cd cd 09				call storage_read 
758d			 
758d					if DEBUG_FORTH_WORDS 
758d						DMARK "ASr" 
758d f5				push af  
758e 3a a2 75			ld a, (.dmark)  
7591 32 9d fd			ld (debug_mark),a  
7594 3a a3 75			ld a, (.dmark+1)  
7597 32 9e fd			ld (debug_mark+1),a  
759a 3a a4 75			ld a, (.dmark+2)  
759d 32 9f fd			ld (debug_mark+2),a  
75a0 18 03			jr .pastdmark  
75a2 ..			.dmark: db "ASr"  
75a5 f1			.pastdmark: pop af  
75a6			endm  
# End of macro DMARK
75a6						CALLMONITOR 
75a6 cd aa fd			call debug_vector  
75a9				endm  
# End of macro CALLMONITOR
75a9					endif 
75a9			 
75a9 cd 07 10				call ishlzero 
75ac c8					ret z             ; file not found 
75ad			 
75ad					; display file name we are loading 
75ad			 
75ad cd aa 0d				call clear_display 
75b0			 
75b0 3e 32				ld a, display_row_2 + 10 
75b2 11 af f9				ld de, store_page+3 
75b5 cd bd 0d				call str_at_display 
75b8				 
75b8			; 
75b8			 
75b8			;	ld a, display_row_1+5 
75b8			;	ld de, sprompt3 
75b8			;	call str_at_display 
75b8			;	ld a, display_row_2+7 
75b8			;	call active 
75b8			;	ex de, hl 
75b8			;;	ld de, sprompt4 
75b8			;	call str_at_display 
75b8			; 
75b8 cd cd 0d			call update_display 
75bb			 
75bb			;	call cin_wait 
75bb			;	cp 'n' 
75bb			;	ret z 
75bb			;	cp 'N' 
75bb			;	ret z 
75bb			 
75bb			;	call delay1s 
75bb			 
75bb 3a ae f9			ld a, (store_page+2) 
75be 32 9b f9			ld (store_openmaxext), a    ; save count of ext 
75c1 3e 01			ld a, 1  
75c3 32 9c f9			ld (store_openext), a    ; save count of ext 
75c6			 
75c6			.autof: 
75c6				; begin to read a line from file 
75c6			 
75c6 21 1a f4			ld hl, os_cli_cmd 
75c9 22 18 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
75cc			  
75cc			.readext: 
75cc 3a 9c f9			ld a, (store_openext) 
75cf 6f				ld l , a 
75d0				 
75d0 3a ac f9			ld a, (store_page) 
75d3 67				ld h, a	 
75d4 11 ac f9			ld de, store_page 
75d7					if DEBUG_FORTH_WORDS 
75d7						DMARK "ASl" 
75d7 f5				push af  
75d8 3a ec 75			ld a, (.dmark)  
75db 32 9d fd			ld (debug_mark),a  
75de 3a ed 75			ld a, (.dmark+1)  
75e1 32 9e fd			ld (debug_mark+1),a  
75e4 3a ee 75			ld a, (.dmark+2)  
75e7 32 9f fd			ld (debug_mark+2),a  
75ea 18 03			jr .pastdmark  
75ec ..			.dmark: db "ASl"  
75ef f1			.pastdmark: pop af  
75f0			endm  
# End of macro DMARK
75f0						CALLMONITOR 
75f0 cd aa fd			call debug_vector  
75f3				endm  
# End of macro CALLMONITOR
75f3					endif 
75f3 cd cd 09				call storage_read 
75f6 cd 07 10			call ishlzero 
75f9 c8				ret z 
75fa			 
75fa			; TODO copy to exec buffer 
75fa			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75fa			 
75fa				; copy the record buffer to the cli buffer 
75fa			 
75fa ed 5b 18 f6		ld de, (os_var_array) 
75fe 21 ae f9			ld hl, store_page+2 
7601			;	ex de, hl 
7601 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
7604 ed b0			ldir 
7606 ed 53 18 f6		ld (os_var_array), de 
760a				 
760a 3a 9c f9			ld a, (store_openext) 
760d 3c				inc a 
760e 32 9c f9			ld (store_openext), a    ; save count of ext 
7611			 
7611			 
7611			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7611				 
7611 3a 9f f9			ld a, (store_readcont) 
7614 fe 00			cp 0 
7616 20 b4			jr nz, .readext 
7618			 
7618			;	jr z, .autoend 
7618			 
7618					if DEBUG_FORTH_WORDS 
7618						DMARK "ASc" 
7618 f5				push af  
7619 3a 2d 76			ld a, (.dmark)  
761c 32 9d fd			ld (debug_mark),a  
761f 3a 2e 76			ld a, (.dmark+1)  
7622 32 9e fd			ld (debug_mark+1),a  
7625 3a 2f 76			ld a, (.dmark+2)  
7628 32 9f fd			ld (debug_mark+2),a  
762b 18 03			jr .pastdmark  
762d ..			.dmark: db "ASc"  
7630 f1			.pastdmark: pop af  
7631			endm  
# End of macro DMARK
7631						CALLMONITOR 
7631 cd aa fd			call debug_vector  
7634				endm  
# End of macro CALLMONITOR
7634					endif 
7634 e5				push hl	 
7635 d5				push de 
7636 cd 01 0d			call active 
7639 eb				ex de, hl 
763a 3e 2f			ld a, display_row_2 + 7 
763c cd bd 0d			call str_at_display 
763f			 
763f cd cd 0d			call update_display 
7642 d1				pop de  
7643 e1				pop hl 
7644			;	call delay250ms 
7644			 
7644			 
7644			 
7644			 
7644			.autoexec: 
7644			 
7644			 
7644 21 1a f4			ld hl, os_cli_cmd 
7647					if DEBUG_FORTH_WORDS 
7647						DMARK "ASx" 
7647 f5				push af  
7648 3a 5c 76			ld a, (.dmark)  
764b 32 9d fd			ld (debug_mark),a  
764e 3a 5d 76			ld a, (.dmark+1)  
7651 32 9e fd			ld (debug_mark+1),a  
7654 3a 5e 76			ld a, (.dmark+2)  
7657 32 9f fd			ld (debug_mark+2),a  
765a 18 03			jr .pastdmark  
765c ..			.dmark: db "ASx"  
765f f1			.pastdmark: pop af  
7660			endm  
# End of macro DMARK
7660						CALLMONITOR 
7660 cd aa fd			call debug_vector  
7663				endm  
# End of macro CALLMONITOR
7663					endif 
7663 cd f2 23			call forthparse 
7666 cd 2e 24			call forthexec 
7669 cd 48 23			call forthexec_cleanup 
766c			 
766c			 
766c			 
766c c3 c6 75			jp .autof 
766f			;.autofdone: 
766f			; 
766f			;		if DEBUG_FORTH_WORDS 
766f			;			DMARK "ASx" 
766f			;			CALLMONITOR 
766f			;		endif 
766f			;;	call clear_display 
766f			;	ret 
766f			 
766f			 
766f			 
766f			endif 
# End of file forth_startupv2.asm
766f			endif 
766f			 
# End of file forth_startup.asm
766f			 
766f			; eof 
# End of file forth_kernel.asm
766f			;include "nascombasic.asm" 
766f			 
766f			 
766f			; find out where the code ends if loaded into RAM (for SC114) 
766f			;endofcode:  
766f			;	nop 
766f			 
766f			 
766f			; jump to nmi vector 
766f			 
766f			init_nmi: 
766f 3e c9			ld a, $c9   ; RET 
7671 32 ad fd			ld (nmi_vector), a 
7674 c9				ret 
7675			nmi: 
7675 e5				push hl 
7676 d5				push de 
7677 c5				push bc 
7678 f5				push af 
7679 cd ad fd			call nmi_vector 
767c f5				push af 
767d c5				push bc 
767e d5				push de 
767f e5				push hl 
7680 ed 4d			reti 
7682			 
7682			 
7682			; eof 
7682			 
# End of file main.asm
7682			include "firmware_lcd_4x40.asm" 
7682			; **********************************************************************  
7682			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7682			; **********************************************************************  
7682			;  
7682			; **  Written as a Small Computer Monitor App  
7682			; **  www.scc.me.uk  
7682			;  
7682			; History  
7682			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7682			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7682			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7682			;  
7682			; **********************************************************************  
7682			;  
7682			; This program is an example of one of the methods of interfacing an   
7682			; alphanumeric LCD module.   
7682			;  
7682			; In this example the display is connected to either a Z80 PIO or a   
7682			; simple 8-bit output port.   
7682			;  
7682			; This interfacing method uses 4-bit data mode and uses time delays  
7682			; rather than polling the display's ready status. As a result the   
7682			; interface only requires 6 simple output lines:  
7682			;   Output bit 0 = not used  
7682			;   Output bit 1 = not used  
7682			;   Output bit 2 = RS         High = data, Low = instruction  
7682			;   Output bit 3 = E          Active high  
7682			;   Output bit 4 = DB4  
7682			;   Output bit 5 = DB5  
7682			;   Output bit 6 = DB6  
7682			;   Output bit 7 = DB7  
7682			; Display's R/W is connected to 0v so it is always in write mode  
7682			;  
7682			; This set up should work with any system supporting the RC2014 bus  
7682			  
7682			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7682			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7682			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7682			;  
7682			; **********************************************************************  
7682			  
7682			; Additonal for 4x40. E1 and E2 instead of just E   
7682			; TODO swipe vidout signal on port a to activate E2  
7682			  
7682			; **********************************************************************  
7682			; **  Constants  
7682			; **********************************************************************  
7682			; LCD constants required by LCD support module  
7682			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7682			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7682			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
7682			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
7682			; TODO Decide which E is being set  
7682			kLCDWidth:  EQU display_cols             ;Width in characters  
7682			  
7682			; **********************************************************************  
7682			; **  Code library usage  
7682			; **********************************************************************  
7682			  
7682			; send character to current cursor position  
7682			; wraps and/or scrolls screen automatically  
7682			  
7682			  
7682			  
7682			lcd_init:  
7682			  
7682			; SCMonAPI functions used  
7682			  
7682			; Alphanumeric LCD functions used  
7682			; no need to specify specific functions for this module  
7682			  
7682 3e cf		            LD   A, 11001111b  
7684 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7686 3e 00		            LD   A, 00000000b  
7688 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
768a			  
768a			; Initialise alphanumeric LCD module  
768a 3e 00				ld a, 0  
768c 32 fd fa				ld (display_lcde1e2), a  
768f cd 10 77		            CALL fLCD_Init      ;Initialise LCD module  
7692 3e 01				ld a, 1  
7694 32 fd fa				ld (display_lcde1e2), a  
7697 cd 10 77		            CALL fLCD_Init      ;Initialise LCD module  
769a			  
769a c9				ret  
769b			  
769b			;  
769b			;;  
769b			; lcd functions  
769b			;  
769b			;  
769b			  
769b			; what is at cursor position   
769b			  
769b			;get_cursor:	ld de, (cursor_row)   ;  row + col  
769b			;		call curptr  
769b			;		ret  
769b			  
769b			  
769b			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
769b			  
769b			curptr:  
769b c5				push bc  
769c 21 e3 fc			ld hl, display_fb0  
769f			cpr:	  
769f				; loop for cursor whole row  
769f 0e 28			ld c, display_cols  
76a1 23			cpr1:	inc hl  
76a2 0d				dec c  
76a3 20 fc			jr nz, cpr1  
76a5 05				dec b  
76a6 20 f7			jr nz, cpr  
76a8			  
76a8				; add col	  
76a8			  
76a8 23			cpr2:	inc hl  
76a9 1d				dec e  
76aa 20 fc			jr nz, cpr2  
76ac			  
76ac c1				pop bc  
76ad c9				ret  
76ae				  
76ae			  
76ae			  
76ae			  
76ae			  
76ae			; write the frame buffer given in hl to hardware   
76ae 22 fb fa		write_display: ld (display_write_tmp), hl 	   
76b1 3e 00			ld a, kLCD_Line1  
76b3 cd bd 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76b6 06 28			ld b, display_cols  
76b8 ed 5b fb fa		ld de, (display_write_tmp)  
76bc cd 08 77			call write_len_string  
76bf				  
76bf				  
76bf 2a fb fa			ld hl, (display_write_tmp)  
76c2 11 28 00			ld de, display_cols  
76c5 19				add hl,de  
76c6 22 fb fa			ld (display_write_tmp),hl  
76c9			  
76c9				  
76c9 3e 28			ld a, kLCD_Line2  
76cb cd bd 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76ce 06 28			ld b, display_cols  
76d0 ed 5b fb fa		ld de, (display_write_tmp)  
76d4 cd 08 77			call write_len_string  
76d7				  
76d7 2a fb fa			ld hl, (display_write_tmp)  
76da 11 28 00			ld de, display_cols  
76dd 19				add hl,de  
76de 22 fb fa			ld (display_write_tmp),hl  
76e1			  
76e1				  
76e1 3e 50			ld a, kLCD_Line3  
76e3 cd bd 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76e6 06 28			ld b, display_cols  
76e8 ed 5b fb fa		ld de, (display_write_tmp)  
76ec cd 08 77			call write_len_string  
76ef				  
76ef 2a fb fa			ld hl, (display_write_tmp)  
76f2 11 28 00			ld de, display_cols  
76f5 19				add hl,de  
76f6 22 fb fa			ld (display_write_tmp),hl  
76f9			  
76f9				  
76f9 3e 78			ld a, kLCD_Line4  
76fb cd bd 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76fe 06 28			ld b, display_cols  
7700 ed 5b fb fa		ld de, (display_write_tmp)  
7704 cd 08 77			call write_len_string  
7707 c9					ret  
7708				  
7708				; write out a fixed length string given in b from de  
7708			  
7708 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7709 cd 75 77		            CALL fLCD_Data      ;Write character to display  
770c 13				inc de  
770d 10 f9			djnz write_len_string  
770f c9				ret  
7710			  
7710			; Some other things to do  
7710			;            LD   A, kLCD_Clear ;Display clear  
7710			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7710			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7710			;            LD   A, kLCD_On     ;Display on with no cursor  
7710			;            ;LD   A, kLCD_Off   ;Display off  
7710			;            CALL fLCD_Inst      ;Send instruction to display  
7710			;  
7710			;  
7710			;            halt  
7710			;  
7710			;  
7710			;MsgHello:   DB  "Hello World!",0  
7710			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7710			  
7710			; Custom characters 5 pixels wide by 8 pixels high  
7710			; Up to 8 custom characters can be defined  
7710			;BitMaps:      
7710			;; Character 0x00 = Battery icon  
7710			;            DB  01110b  
7710			;            DB  11011b  
7710			;            DB  10001b  
7710			;            DB  10001b  
7710			;            DB  11111b  
7710			;            DB  11111b  
7710			;            DB  11111b  
7710			;            DB  11111b  
7710			;; Character 0x01 = Bluetooth icon  
7710			;            DB  01100b  
7710			;            DB  01010b  
7710			;            DB  11100b  
7710			;            DB  01000b  
7710			;            DB  11100b  
7710			;            DB  01010b  
7710			;            DB  01100b  
7710			;            DB  00000b  
7710			;  
7710			  
7710			  
7710			; **********************************************************************  
7710			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7710			; **********************************************************************  
7710			;  
7710			; **  Written as a Small Computer Monitor App   
7710			; **  Version 0.1 SCC 2018-05-16  
7710			; **  www.scc.me.uk  
7710			;  
7710			; **********************************************************************  
7710			;  
7710			; This module provides support for alphanumeric LCD modules using with  
7710			; *  HD44780 (or compatible) controller  
7710			; *  5 x 7 pixel fonts  
7710			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7710			; *  Interface via six digital outputs to the display (see below)  
7710			;  
7710			; LCD module pinout:  
7710			;   1  Vss   0v supply  
7710			;   2  Vdd   5v supply  
7710			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7710			;   4  RS    High = data, Low = instruction  
7710			;   5  R/W   High = Read, Low = Write  
7710			;   6  E     Enable signal (active high)  
7710			;   7  DB0   Data bit 0  
7710			;   8  DB1   Data bit 1  
7710			;   9  DB2   Data bit 2  
7710			;  10  DB3   Data bit 3  
7710			;  11  DB4   Data bit 4  
7710			;  12  DB5   Data bit 5  
7710			;  13  DB6   Data bit 6  
7710			;  14  DB7   Data bit 7  
7710			;  15  A     Backlight anode (+)  
7710			;  16  K     Backlight cathode (-)  
7710			;  
7710			; This interfacing method uses 4-bit data mode and uses time delays  
7710			; rather than polling the display's ready status. As a result the   
7710			; interface only requires 6 simple output lines:  
7710			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7710			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7710			;   LCD DB4 = Microcomputer output port bit 4  
7710			;   LCD DB5 = Microcomputer output port bit 5  
7710			;   LCD DB6 = Microcomputer output port bit 6  
7710			;   LCD DB7 = Microcomputer output port bit 7  
7710			; Display's R/W is connected to 0v so it is always in write mode  
7710			; All 6 connections must be on the same port address <kLCDPrt>  
7710			; This method also allows a decent length of cable from micro to LCD  
7710			;  
7710			; **********************************************************************  
7710			;  
7710			; To include the code for any given function provided by this module,   
7710			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7710			; the parent source file.  
7710			; For example:  #REQUIRES   uHexPrefix  
7710			;  
7710			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7710			; in the parent source file.  
7710			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7710			;  
7710			; These are the function names provided by this module:  
7710			; fLCD_Init                     ;Initialise LCD  
7710			; fLCD_Inst                     ;Send instruction to LCD  
7710			; fLCD_Data                     ;Send data byte to LCD  
7710			; fLCD_Pos                      ;Position cursor  
7710			; fLCD_Str                      ;Display string  
7710			; fLCD_Def                      ;Define custom character  
7710			;  
7710			; **********************************************************************  
7710			;  
7710			; Requires SCMonAPI.asm to also be included in the project  
7710			;  
7710			  
7710			  
7710			; **********************************************************************  
7710			; **  Constants  
7710			; **********************************************************************  
7710			  
7710			; Constants that must be defined externally  
7710			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7710			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7710			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7710			;kLCDWidth: EQU 20             ;Width in characters  
7710			  
7710			; general line offsets in any frame buffer  
7710			  
7710			  
7710			display_row_1: equ 0  
7710			display_row_2: equ display_row_1+display_cols  
7710			display_row_3: equ display_row_2 + display_cols  
7710			display_row_4: equ display_row_3 + display_cols  
7710			;display_row_4_eol:   
7710			  
7710			  
7710			; Cursor position values for the start of each line  
7710			  
7710			; E  
7710			kLCD_Line1: EQU 0x00   
7710			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7710			; E1  
7710			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7710			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7710			  
7710			; Instructions to send as A register to fLCD_Inst  
7710			kLCD_Clear: EQU 00000001b     ;LCD clear  
7710			kLCD_Off:   EQU 00001000b     ;LCD off  
7710			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7710			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7710			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7710			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7710			  
7710			; Constants used by this code module  
7710			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7710			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7710			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7710			  
7710			  
7710			  
7710			; **********************************************************************  
7710			; **  LCD support functions  
7710			; **********************************************************************  
7710			  
7710			; Initialise alphanumeric LCD module  
7710			; LCD control register codes:  
7710			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7710			;   N    0 = 1-line mode       1 = 2-line mode  
7710			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7710			;   D    0 = Display off       1 = Display on  
7710			;   C    0 = Cursor off        1 = Cursor on  
7710			;   B    0 = Blinking off      1 = Blinking on  
7710			;   ID   0 = Decrement mode    1 = Increment mode  
7710			;   SH   0 = Entire shift off  1 = Entire shift on  
7710 3e 28		fLCD_Init:  LD   A, 40  
7712 cd 37 78		            CALL LCDDelay       ;Delay 40ms after power up  
7715			; For reliable reset set 8-bit mode - 3 times  
7715 cd 07 78		            CALL WrFn8bit       ;Function = 8-bit mode  
7718 cd 07 78		            CALL WrFn8bit       ;Function = 8-bit mode  
771b cd 07 78		            CALL WrFn8bit       ;Function = 8-bit mode  
771e			; Set 4-bit mode  
771e cd 03 78		            CALL WrFn4bit       ;Function = 4-bit mode  
7721 cd 35 78		            CALL LCDDelay1      ;Delay 37 us or more  
7724			; Function set  
7724 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7726 cd 39 77		            CALL fLCD_Inst      ;2 line, display on  
7729			; Display On/Off control  
7729 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
772b cd 39 77		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
772e			; Display Clear  
772e 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7730 cd 39 77		            CALL fLCD_Inst      ;Clear display  
7733			; Entry mode  
7733 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7735 cd 39 77		            CALL fLCD_Inst      ;Increment mode, shift off  
7738			; Display module now initialised  
7738 c9			            RET  
7739			; ok to here  
7739			  
7739			; Write instruction to LCD  
7739			;   On entry: A = Instruction byte to be written  
7739			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7739 f5			fLCD_Inst:  PUSH AF  
773a f5			            PUSH AF  
773b cd 4d 77		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
773e f1			            POP  AF  
773f 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7740 17			            RLA  
7741 17			            RLA  
7742 17			            RLA  
7743 cd 4d 77		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7746 3e 02		            LD   A, 2  
7748 cd 37 78		            CALL LCDDelay       ;Delay 2 ms to complete   
774b f1			            POP  AF  
774c c9			            RET  
774d			Wr4bits:   
774d f5					push af  
774e 3a fd fa				ld a, (display_lcde1e2)  
7751 fe 00				cp 0     ; e  
7753 20 10				jr nz, .wea2	  
7755 f1					pop af  
7756 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7758 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
775a cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
775c cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
775e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7760 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7762 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7764 c9			            RET  
7765 f1			.wea2:		pop af  
7766 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7768 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
776a cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
776c cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
776e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7770 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7772 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7774 c9			            RET  
7775			  
7775			  
7775			; Write data to LCD  
7775			;   On entry: A = Data byte to be written  
7775			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7775 f5			fLCD_Data:  PUSH AF  
7776 f5			            PUSH AF  
7777 cd 89 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
777a f1			            POP  AF  
777b 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
777c 17			            RLA  
777d 17			            RLA  
777e 17			            RLA  
777f cd 89 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7782 3e 96		            LD   A, 150  
7784 3d			Wait:      DEC  A              ;Wait a while to allow data   
7785 20 fd		            JR   NZ, Wait      ;  write to complete  
7787 f1			            POP  AF  
7788 c9			            RET  
7789			Wr4bitsa:     
7789 f5					push af  
778a 3a fd fa				ld a, (display_lcde1e2)  
778d fe 00				cp 0     ; e1  
778f 20 16				jr nz, .we2	  
7791 f1					pop af  
7792 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7794 cb d7		            SET  kLCDBitRS, A  
7796 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7798 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
779a cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
779c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
779e cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
77a0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77a2 cb 97		            RES  kLCDBitRS, A  
77a4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77a6 c9			            RET  
77a7 f1			.we2:		pop af  
77a8 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77aa cb d7		            SET  kLCDBitRS, A  
77ac d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77ae cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
77b0 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
77b2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
77b4 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
77b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77b8 cb 97		            RES  kLCDBitRS, A  
77ba d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77bc c9			            RET  
77bd			  
77bd			  
77bd			; Position cursor to specified location  
77bd			;   On entry: A = Cursor position  
77bd			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77bd f5			fLCD_Pos:   PUSH AF  
77be					; at this point set the E1 or E2 flag depending on position  
77be			  
77be c5					push bc  
77bf			;		push af  
77bf 06 00				ld b, 0  
77c1 4f					ld c, a  
77c2 3e 4f				ld a, kLCD_Line3-1  
77c4 b7			 		or a      ;clear carry flag  
77c5 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
77c6 38 04				jr c, .pe1  
77c8			  
77c8					; E selection  
77c8 cb 80				res 0, b         ; bit 0 unset e  
77ca			;		pop af    ; before line 3 so recover orig pos  
77ca			;		ld c, a    ; save for poking back  
77ca 18 06				jr .peset	          
77cc			.pe1:          	; E2 selection  
77cc cb c0				set 0, b         ; bit 0 set e1  
77ce 79					ld a, c  
77cf de 4f				sbc a, kLCD_Line3-1  
77d1 4f					ld c, a	         ; save caculated offset  
77d2			;		pop af     ; bin this original value now we have calculated form  
77d2			  
77d2			.peset:		; set bit  
77d2 78					ld a, b  
77d3 32 fd fa				ld (display_lcde1e2), a 	  
77d6 79					ld a, c  
77d7 c1					pop bc  
77d8			  
77d8 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
77da cd 39 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77dd f1			            POP  AF  
77de c9			            RET  
77df			  
77df			  
77df			; Output text string to LCD  
77df			;   On entry: DE = Pointer to null terminated text string  
77df			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
77df 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
77e0 b7			            OR   A              ;Null terminator?  
77e1 c8			            RET  Z              ;Yes, so finished  
77e2 cd 75 77		            CALL fLCD_Data      ;Write character to display  
77e5 13			            INC  DE             ;Point to next character  
77e6 18 f7		            JR   fLCD_Str       ;Repeat  
77e8 c9					ret  
77e9			  
77e9			; Define custom character  
77e9			;   On entry: A = Character number (0 to 7)  
77e9			;             DE = Pointer to character bitmap data  
77e9			;   On exit:  A = Next character number  
77e9			;             DE = Next location following bitmap  
77e9			;             BC HL IX IY I AF' BC' DE' HL' preserved  
77e9			; Character is   
77e9 c5			fLCD_Def:   PUSH BC  
77ea f5			            PUSH AF  
77eb 07			            RLCA                ;Calculate location  
77ec 07			            RLCA                ;  for bitmap data  
77ed 07			            RLCA                ;  = 8 x CharacterNumber  
77ee f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
77f0 cd 39 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77f3 06 00		            LD   B, 0  
77f5 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
77f6 cd 75 77		            CALL fLCD_Data      ;Write byte to display  
77f9 13			            INC  DE             ;Point to next byte  
77fa 04			            INC  B              ;Count bytes  
77fb cb 58		            BIT  3, B           ;Finish all 8 bytes?  
77fd 28 f6		            JR   Z, Loop       ;No, so repeat  
77ff f1			            POP  AF  
7800 3c			            INC  A              ;Increment character number  
7801 c1			            POP  BC  
7802 c9			            RET  
7803			  
7803			  
7803			; **********************************************************************  
7803			; **  Private functions  
7803			; **********************************************************************  
7803			  
7803			; Write function to LCD  
7803			;   On entry: A = Function byte to be written  
7803			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7803 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7805 18 02		            JR   WrFunc  
7807 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7809 f5			WrFunc:     PUSH AF  
780a f5					push af  
780b 3a fd fa				ld a, (display_lcde1e2)  
780e fe 00				cp 0     ; e1  
7810 20 0f				jr nz, .wfea2	  
7812 f1					pop af  
7813 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7815 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
7817 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7819 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
781b cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
781d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
781f 18 0d			jr .wfskip  
7821 f1			.wfea2:		pop af  
7822 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7824 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7826 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7828 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
782a cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
782c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
782e 3e 05		.wfskip:            LD  A, 5  
7830 cd 37 78		            CALL LCDDelay       ;Delay 5 ms to complete  
7833 f1			            POP  AF  
7834 c9			            RET  
7835			  
7835			  
7835			; Delay in milliseconds  
7835			;   On entry: A = Number of milliseconds delay  
7835			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7835 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7837 d5			LCDDelay:   PUSH DE  
7838 5f			            LD   E, A           ;Delay by 'A' ms  
7839 16 00		            LD   D, 0  
783b cd d2 0c		            CALL aDelayInMS  
783e d1			            POP  DE  
783f c9			            RET  
7840			  
7840			  
7840			testlcd:  
7840 3e 00			ld a, kLCD_Line1  
7842 cd bd 77			call fLCD_Pos  
7845 06 28			ld b, 40  
7847 11 75 78			ld de, .ttext1  
784a cd 08 77			call write_len_string  
784d			  
784d 3e 28			ld a, kLCD_Line2  
784f cd bd 77			call fLCD_Pos  
7852 06 28			ld b, 40  
7854 11 9e 78			ld de, .ttext2  
7857 cd 08 77			call write_len_string  
785a 3e 50			ld a, kLCD_Line3  
785c cd bd 77			call fLCD_Pos  
785f 06 28			ld b, 40  
7861 11 c7 78			ld de, .ttext3  
7864 cd 08 77			call write_len_string  
7867 3e 78			ld a, kLCD_Line4  
7869 cd bd 77			call fLCD_Pos  
786c 06 28			ld b, 40  
786e 11 f0 78			ld de, .ttext4  
7871 cd 08 77			call write_len_string  
7874			  
7874 76				halt  
7875			  
7875			  
7875 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
789e .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
78c7 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
78f0 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7919			   
7919			  
7919			  
7919			; eof  
7919			  
# End of file firmware_lcd_4x40.asm
7919			;include "firmware_lcd_4x20.asm" 
7919			include "firmware_key_5x10.asm" 
7919			; 5 x 10 decade counter scanner  
7919			  
7919			  
7919			; TODO do cursor shape change for shift keys  
7919			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7919			  
7919			  
7919			; bit mask for each scan column and row for teing the matrix  
7919			  
7919			  
7919			key_init:  
7919			  
7919			; SCMonAPI functions used  
7919			  
7919			; Alphanumeric LCD functions used  
7919			; no need to specify specific functions for this module  
7919			  
7919			  
7919 3e cf		            LD   A, 11001111b  
791b d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
791d			;            LD   A, 00000000b  
791d 3e 1f		            LD   A, 00011111b  
791f d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7921			  
7921			  
7921				; TODO Configure cursor shapes  
7921			  
7921				; Load cursor shapes   
7921 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7923 11 33 79		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7926 06 02		            LD   B, 2           ;Number of characters to define  
7928 cd e9 77		.DefLoop:   CALL fLCD_Def       ;Define custom character  
792b 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
792d			  
792d 3e 01				ld a, 1  
792f 32 f3 fa			ld (cursor_shape),a  
7932 c9				ret  
7933			  
7933			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7933			; Up to 8 custom characters can be defined  
7933			.cursor_shapes:      
7933			;; Character 0x00 = Normal  
7933 1f			            DB  11111b  
7934 1f			            DB  11111b  
7935 1f			            DB  11111b  
7936 1f			            DB  11111b  
7937 1f			            DB  11111b  
7938 1f			            DB  11111b  
7939 1f			            DB  11111b  
793a 1f			            DB  11111b  
793b			;; Character 0x01 = Modifier  
793b 1f			            DB  11111b  
793c 1b			            DB  11011b  
793d 1b			            DB  11011b  
793e 1b			            DB  11011b  
793f 1b			            DB  11011b  
7940 1f			            DB  11111b  
7941 1b			            DB  11011b  
7942 1f			            DB  11111b  
7943			  
7943			  
7943			  
7943			  
7943			; Display custom character 0  
7943			;            LD   A, kLCD_Line1+14  
7943			;            CALL fLCD_Pos       ;Position cursor to location in A  
7943			;            LD   A, 0  
7943			;            CALL fLCD_Data      ;Write character in A at cursor  
7943			  
7943			; Display custom character 1  
7943			;            LD   A, kLCD_Line2+14  
7943			;            CALL fLCD_Pos      ;Position cursor to location in A  
7943			;            LD   A, 1  
7943			;            CALL fLCD_Data     ;Write character in A at cursor  
7943			  
7943			; keyboard scanning   
7943			  
7943			; character in from keyboard  
7943			  
7943			; mapping for the pcb layout  
7943			  
7943			.matrix_to_char:  
7943 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
794e .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7959 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7964 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
796f .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
797a			.matrix_to_shift:  
797a			  
797a .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7985 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7990 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
799b 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
79a6 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
79b1			  
79b1			.matrix_to_symbolshift:  
79b1			  
79b1 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
79bc .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
79c7 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
79d2			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
79d2 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
79dd .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
79e8			  
79e8			  
79e8			  
79e8			; mapping for a simple straight through breadboard layout  
79e8			  
79e8			;.matrix_to_char:  
79e8			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79e8			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
79e8			;		db "asdfghjkl",KEY_CR,0  
79e8			;		db "qwertyuiop",0  
79e8			;		 db "1234567890",0  
79e8			;.matrix_to_shift:  
79e8			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
79e8			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
79e8			;		db "ASDFGHJKL",KEY_CR,0  
79e8			;		db "QWERTYUIOP",0  
79e8			;		 db "!",'"',"#$%^&*()",0  
79e8			;.matrix_to_symbolshift:  
79e8			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79e8			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
79e8			;		db "_?*fghjk=",KEY_CR,0  
79e8			;		db "-/+*[]{}@#",0  
79e8			;		 db "1234567890",0  
79e8			  
79e8			;.matrix_to_char: db "D#0*C987B654A321"  
79e8			  
79e8			  
79e8				  
79e8			  
79e8			; add cin and cin_wait  
79e8			  
79e8 cd f9 79		cin_wait: 	call cin  
79eb						if DEBUG_KEYCINWAIT  
79eb							push af  
79eb							  
79eb							ld hl,key_repeat_ct  
79eb							ld (hl),a  
79eb							inc hl  
79eb							call hexout  
79eb							ld hl,key_repeat_ct+3  
79eb							ld a,0  
79eb							ld (hl),a  
79eb			  
79eb							    LD   A, kLCD_Line1+11  
79eb							    CALL fLCD_Pos       ;Position cursor to location in A  
79eb							    LD   DE, key_repeat_ct  
79eb							    ;LD   DE, MsgHello  
79eb							    CALL fLCD_Str       ;Display string pointed to by DE  
79eb			  
79eb			  
79eb			  
79eb							pop af  
79eb						endif  
79eb fe 00			cp 0  
79ed 28 f9			jr z, cin_wait   ; block until key press  
79ef			  
79ef							if DEBUG_KEYCINWAIT  
79ef								push af  
79ef			  
79ef								ld a, 'A'	  
79ef								ld hl,key_repeat_ct  
79ef								ld (hl),a  
79ef								inc hl  
79ef								ld a,0  
79ef								ld (hl),a  
79ef			  
79ef								    LD   A, kLCD_Line2+11  
79ef								    CALL fLCD_Pos       ;Position cursor to location in A  
79ef								    LD   DE, key_repeat_ct  
79ef								    ;LD   DE, MsgHello  
79ef								    CALL fLCD_Str       ;Display string pointed to by DE  
79ef			  
79ef							call delay500ms  
79ef			  
79ef								pop af  
79ef							endif  
79ef f5				push af   ; save key pressed  
79f0			  
79f0			.cin_wait1:	  
79f0							if DEBUG_KEYCINWAIT  
79f0								push af  
79f0			  
79f0								ld a, 'b'	  
79f0								ld hl,key_repeat_ct  
79f0								ld (hl),a  
79f0								inc hl  
79f0								ld a,0  
79f0								ld (hl),a  
79f0			  
79f0								    LD   A, kLCD_Line2+11  
79f0								    CALL fLCD_Pos       ;Position cursor to location in A  
79f0								    LD   DE, key_repeat_ct  
79f0								    ;LD   DE, MsgHello  
79f0								    CALL fLCD_Str       ;Display string pointed to by DE  
79f0			  
79f0			  
79f0							call delay500ms  
79f0			  
79f0								pop af  
79f0							endif  
79f0			  
79f0 cd f9 79		call cin  
79f3 fe 00			cp 0  
79f5 20 f9			jr nz, .cin_wait1  	; wait for key release  
79f7			if DEBUG_KEYCINWAIT  
79f7				push af  
79f7			  
79f7				ld a, '3'	  
79f7				ld hl,key_repeat_ct  
79f7				ld (hl),a  
79f7				inc hl  
79f7				ld a,0  
79f7				ld (hl),a  
79f7			  
79f7			            LD   A, kLCD_Line2+11  
79f7			            CALL fLCD_Pos       ;Position cursor to location in A  
79f7			            LD   DE, key_repeat_ct  
79f7			            ;LD   DE, MsgHello  
79f7			            CALL fLCD_Str       ;Display string pointed to by DE  
79f7			  
79f7			  
79f7			call delay500ms  
79f7			  
79f7				pop af  
79f7			endif  
79f7			  
79f7 f1				pop af   ; get key  
79f8 c9				ret  
79f9			  
79f9			  
79f9			; cin - key non-blocking except for keybounce release  
79f9			  
79f9 cd 17 7a		cin: 	call .mtoc  
79fc			  
79fc			if DEBUG_KEYCIN  
79fc				push af  
79fc				  
79fc				ld hl,key_repeat_ct  
79fc				ld (hl),a  
79fc				inc hl  
79fc				call hexout  
79fc				ld hl,key_repeat_ct+3  
79fc				ld a,0  
79fc				ld (hl),a  
79fc			  
79fc			            LD   A, kLCD_Line3+15  
79fc			            CALL fLCD_Pos       ;Position cursor to location in A  
79fc			            LD   DE, key_repeat_ct  
79fc			            ;LD   DE, MsgHello  
79fc			            CALL fLCD_Str       ;Display string pointed to by DE  
79fc			  
79fc			  
79fc			call delay500ms  
79fc			  
79fc				pop af  
79fc			endif  
79fc			  
79fc			  
79fc				; no key held  
79fc fe 00			cp 0  
79fe c8				ret z  
79ff			  
79ff			if DEBUG_KEYCIN  
79ff				push af  
79ff			  
79ff				ld a, '1'	  
79ff				ld hl,key_repeat_ct  
79ff				ld (hl),a  
79ff				inc hl  
79ff				ld a,0  
79ff				ld (hl),a  
79ff			  
79ff			            LD   A, kLCD_Line4+15  
79ff			            CALL fLCD_Pos       ;Position cursor to location in A  
79ff			            LD   DE, key_repeat_ct  
79ff			            ;LD   DE, MsgHello  
79ff			            CALL fLCD_Str       ;Display string pointed to by DE  
79ff			  
79ff			  
79ff			call delay500ms  
79ff			  
79ff				pop af  
79ff			endif  
79ff			  
79ff				; stop key bounce  
79ff			  
79ff 32 c6 fd			ld (key_held),a		 ; save it  
7a02 47				ld b, a  
7a03			  
7a03 c5			.cina1:	push bc  
7a04			if DEBUG_KEYCIN  
7a04				push af  
7a04			  
7a04				ld hl,key_repeat_ct  
7a04				inc hl  
7a04				call hexout  
7a04				ld hl,key_repeat_ct+3  
7a04				ld a,0  
7a04				ld (hl),a  
7a04				ld hl,key_repeat_ct  
7a04				ld a, '2'	  
7a04				ld (hl),a  
7a04			  
7a04			            LD   A, kLCD_Line4+15  
7a04			            CALL fLCD_Pos       ;Position cursor to location in A  
7a04			            LD   DE, key_repeat_ct  
7a04			            ;LD   DE, MsgHello  
7a04			            CALL fLCD_Str       ;Display string pointed to by DE  
7a04			  
7a04				pop af  
7a04			endif  
7a04 cd 17 7a			call .mtoc  
7a07 c1				pop bc  
7a08 b8				cp b  
7a09 28 f8			jr z, .cina1  
7a0b 78				ld a,b		  
7a0c			if DEBUG_KEYCIN  
7a0c				push af  
7a0c			  
7a0c				ld hl,key_repeat_ct  
7a0c				inc hl  
7a0c				call hexout  
7a0c				ld hl,key_repeat_ct+3  
7a0c				ld a,0  
7a0c				ld (hl),a  
7a0c				ld hl,key_repeat_ct  
7a0c				ld a, '3'	  
7a0c				ld (hl),a  
7a0c			  
7a0c			            LD   A, kLCD_Line4+15  
7a0c			            CALL fLCD_Pos       ;Position cursor to location in A  
7a0c			            LD   DE, key_repeat_ct  
7a0c			            ;LD   DE, MsgHello  
7a0c			            CALL fLCD_Str       ;Display string pointed to by DE  
7a0c			  
7a0c				pop af  
7a0c			endif  
7a0c c9				ret  
7a0d			  
7a0d			; cinndb - key non-blocking without keybounce release  
7a0d			  
7a0d cd 17 7a		cinndb: 	call .mtoc  
7a10			  
7a10			if DEBUG_KEYCIN  
7a10				push af  
7a10				  
7a10				ld hl,key_repeat_ct  
7a10				ld (hl),a  
7a10				inc hl  
7a10				call hexout  
7a10				ld hl,key_repeat_ct+3  
7a10				ld a,0  
7a10				ld (hl),a  
7a10			  
7a10			            LD   A, kLCD_Line3+15  
7a10			            CALL fLCD_Pos       ;Position cursor to location in A  
7a10			            LD   DE, key_repeat_ct  
7a10			            ;LD   DE, MsgHello  
7a10			            CALL fLCD_Str       ;Display string pointed to by DE  
7a10			  
7a10			  
7a10			call delay500ms  
7a10			  
7a10				pop af  
7a10			endif  
7a10			  
7a10			  
7a10				; no key held  
7a10 fe 00			cp 0  
7a12 c8				ret z  
7a13			  
7a13			if DEBUG_KEYCIN  
7a13				push af  
7a13			  
7a13				ld a, '1'	  
7a13				ld hl,key_repeat_ct  
7a13				ld (hl),a  
7a13				inc hl  
7a13				ld a,0  
7a13				ld (hl),a  
7a13			  
7a13			            LD   A, kLCD_Line4+15  
7a13			            CALL fLCD_Pos       ;Position cursor to location in A  
7a13			            LD   DE, key_repeat_ct  
7a13			            ;LD   DE, MsgHello  
7a13			            CALL fLCD_Str       ;Display string pointed to by DE  
7a13			  
7a13			  
7a13			call delay500ms  
7a13			  
7a13				pop af  
7a13			endif  
7a13			  
7a13 32 c6 fd			ld (key_held),a		 ; save it  
7a16			  
7a16			if DEBUG_KEYCIN  
7a16				push af  
7a16			  
7a16				ld hl,key_repeat_ct  
7a16				inc hl  
7a16				call hexout  
7a16				ld hl,key_repeat_ct+3  
7a16				ld a,0  
7a16				ld (hl),a  
7a16				ld hl,key_repeat_ct  
7a16				ld a, '3'	  
7a16				ld (hl),a  
7a16			  
7a16			            LD   A, kLCD_Line4+15  
7a16			            CALL fLCD_Pos       ;Position cursor to location in A  
7a16			            LD   DE, key_repeat_ct  
7a16			            ;LD   DE, MsgHello  
7a16			            CALL fLCD_Str       ;Display string pointed to by DE  
7a16			  
7a16				pop af  
7a16			endif  
7a16 c9				ret  
7a17			; detect keyboard modifier key press and apply new overlay to the face key held  
7a17			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7a17			  
7a17			;.cin_map_modifier:   
7a17			;	ld a, (hl)  
7a17			;	and 255  
7a17			;	ret NZ		; modifier key not flagged  
7a17			;  
7a17			;	; get key face  
7a17			;  
7a17			;	ld b,(key_face_held)  
7a17			;  
7a17			;	ld b, key_cols * key_rows  
7a17			;  
7a17			;	push de  
7a17			;	pop hl  
7a17			;  
7a17			;.mmod1: ld a,(hl)   ; get map test  
7a17			;	cp b  
7a17			;	jr z, .mmod2  
7a17			;  
7a17			;  
7a17			;  
7a17			;.mmod2: inc hl    ;   
7a17			;  
7a17			;	  
7a17			;  
7a17			;	  
7a17			;  
7a17			;	ld hl,key_actual_pressed  
7a17			;	ld (hl),a,  
7a17			;	ret  
7a17			  
7a17			; map matrix key held to char on face of key  
7a17			  
7a17			.mtoc:  
7a17			  
7a17			; test decade counter strobes  
7a17			  
7a17			;.decadetest1:  
7a17			  
7a17			; reset counter  
7a17			;ld a, 128  
7a17			;out (portbdata),a  
7a17			  
7a17			  
7a17			;ld b, 5  
7a17			;.dec1:  
7a17			;ld a, 0  
7a17			;out (portbdata),a  
7a17			;call delay1s  
7a17			  
7a17			;ld a, 32  
7a17			;out (portbdata),a  
7a17			;call delay1s  
7a17			;call delay1s  
7a17			;call delay1s  
7a17			;  
7a17			;ld a, 64+32  
7a17			;out (portbdata),a  
7a17			;call delay1s  
7a17			;;djnz .dec1  
7a17			;  
7a17			;jp .decadetest1  
7a17			  
7a17			  
7a17			  
7a17			  
7a17			  
7a17			  
7a17			  
7a17			  
7a17			  
7a17			  
7a17				; scan keyboard matrix and generate raw scan map  
7a17 cd aa 7a			call matrix  
7a1a			  
7a1a				; reuse c bit 0 left modifer button - ie shift  
7a1a			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7a1a				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7a1a			  
7a1a 0e 00			ld c, 0  
7a1c			  
7a1c				; TODO set flags for modifer key presses   
7a1c				; TODO do a search for modifer key...  
7a1c			  
7a1c				;ld hl,keyscan_table_row4  
7a1c 21 25 fe			ld hl,keyscan_table_row2  
7a1f			  
7a1f 7e				ld a, (hl)  
7a20 fe 23			cp '#'  
7a22 20 07			jr nz, .nextmodcheck  
7a24 cb c1			set 0, c  
7a26 21 7a 79			ld hl, .matrix_to_shift  
7a29 18 21			jr .dokeymap  
7a2b				; TODO for now igonre  
7a2b			.nextmodcheck:  
7a2b 21 1a fe			ld hl,keyscan_table_row3  
7a2e			  
7a2e 7e				ld a, (hl)  
7a2f fe 23			cp '#'  
7a31 20 07			jr nz, .nextmodcheck2  
7a33 cb c9			set 1, c   
7a35 21 b1 79			ld hl, .matrix_to_symbolshift  
7a38 18 12			jr .dokeymap  
7a3a			.nextmodcheck2:  
7a3a 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
7a3d			  
7a3d 7e				ld a, (hl)  
7a3e fe 23			cp '#'  
7a40 20 07			jr nz, .donemodcheck  
7a42 cb c9			set 1, c   
7a44 21 7a 79			ld hl, .matrix_to_shift  
7a47 18 03			jr .dokeymap  
7a49			  
7a49				; no modifer found so just map to normal keys  
7a49				; get mtoc map matrix to respective keys  
7a49			;	ld hl, .matrix_to_char  
7a49			;	ld hl, .matrix_to_char  
7a49			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a49			;	ld a, KEY_SHIFT  
7a49			;	call findchar  
7a49			;  
7a49			;	; got offset to key modifer in b  
7a49			;  
7a49			;	ld hl,keyscan_table_row5  
7a49			;  
7a49			;	ld a,b  
7a49			;	call addatohl  
7a49			;	ld a,(hl)  
7a49			;  
7a49			;	cp '#'  
7a49			;	jr nz, .nextmodcheck  
7a49			;	set 0, c  
7a49			;	ld hl, .matrix_to_char  
7a49			;	jr .dokeymap  
7a49			;	; TODO for now igonre  
7a49			;.nextmodcheck:  
7a49			;	ld hl, .matrix_to_symbolshift  
7a49			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a49			;	ld a, KEY_SYMBOLSHIFT  
7a49			;	call findchar  
7a49			;  
7a49			;  
7a49			;	; got offset to key modifer in b  
7a49			;  
7a49			;	ld hl,keyscan_table_row5  
7a49			;  
7a49			;	ld a,b  
7a49			;	call addatohl  
7a49			;	ld a,(hl)  
7a49			;  
7a49			;	cp '#'  
7a49			;	jr nz, .donemodcheck  
7a49			;	set 1, c   
7a49			;	ld hl, .matrix_to_symbolshift  
7a49			;	jr .dokeymap  
7a49			  
7a49			  
7a49			  
7a49			.donemodcheck:  
7a49				; no modifer found so just map to normal keys  
7a49				; get mtoc map matrix to respective keys  
7a49 21 43 79			ld hl, .matrix_to_char  
7a4c			  
7a4c			.dokeymap:  
7a4c				;ld (key_fa), c   
7a4c cd 65 7a			call .mapkeys  
7a4f			  
7a4f			  
7a4f			if DEBUG_KEY  
7a4f			  
7a4f			; Display text on first line  
7a4f			            LD   A, kLCD_Line1  
7a4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4f			            LD   DE, keyscan_table_row1  
7a4f			            ;LD   DE, MsgHello  
7a4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4f			  
7a4f			; Display text on second line  
7a4f			            LD   A, kLCD_Line2  
7a4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4f			            LD   DE, keyscan_table_row2  
7a4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4f			            LD   A, kLCD_Line3  
7a4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4f			            LD   DE, keyscan_table_row3  
7a4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4f			            LD   A, kLCD_Line4  
7a4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4f			            LD   DE, keyscan_table_row4  
7a4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4f			            LD   A, kLCD_Line1+10  
7a4f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4f			            LD   DE, keyscan_table_row5  
7a4f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4f			  
7a4f				;call delay250ms  
7a4f			endif  
7a4f			;	jp testkey  
7a4f			  
7a4f			; get first char reported  
7a4f			  
7a4f 21 04 fe			ld hl,keyscan_table_row5  
7a52			  
7a52				;ld b, 46   ; 30 keys to remap + 8 nulls   
7a52 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a54			.findkey:  
7a54 7e				ld a,(hl)  
7a55 fe 00			cp 0  
7a57 28 04			jr z, .nextkey  
7a59 fe 7e			cp KEY_MATRIX_NO_PRESS  
7a5b 20 06			jr nz, .foundkey  
7a5d			.nextkey:  
7a5d 23				inc hl  
7a5e 10 f4			djnz .findkey  
7a60 3e 00			ld a,0  
7a62 c9				ret  
7a63			.foundkey:  
7a63 7e				ld a,(hl)  
7a64 c9				ret  
7a65				  
7a65			  
7a65			; convert the raw key map given hl for destination key  
7a65			.mapkeys:  
7a65 11 04 fe			ld de,keyscan_table_row5  
7a68			  
7a68 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a6a			.remap:  
7a6a 1a				ld a,(de)  
7a6b fe 23			cp '#'  
7a6d 20 02			jr nz, .remapnext  
7a6f				;CALLMONITOR  
7a6f 7e				ld a,(hl)  
7a70 12				ld (de),a  
7a71			  
7a71			  
7a71			  
7a71			.remapnext:  
7a71 23				inc hl  
7a72 13				inc de  
7a73 10 f5			djnz .remap  
7a75				  
7a75 c9				ret  
7a76			  
7a76			  
7a76			  
7a76			.mtocold2:  
7a76			  
7a76			;	; flag if key D is held down and remove from reporting  
7a76			;	ld bc, .key_map_fd    
7a76			;	ld hl, keyscan_table  
7a76			;	ld de, key_fd  
7a76			;	call .key_shift_hold  
7a76			;	cp 255  
7a76			;	jr z, .cinmap  
7a76			;	; flag if key C is held down and remove from reporting  
7a76			;	ld bc, .key_map_fc    
7a76			;	ld hl, keyscan_table+key_cols  
7a76			;	ld de, key_fc  
7a76			;	call .key_shift_hold  
7a76			;	cp 255  
7a76			;	jr z, .cinmap  
7a76			;	; flag if key B is held down and remove from reporting  
7a76			;	ld bc, .key_map_fb    
7a76			;	ld hl, keyscan_table+(key_cols*2)  
7a76			;	ld de, key_fb  
7a76			;	call .key_shift_hold  
7a76			;	cp 255  
7a76			;	jr z, .cinmap  
7a76			;	; flag if key A is held down and remove from reporting  
7a76			;	ld bc, .key_map_fa    
7a76			;	ld hl, keyscan_table+(key_cols*3)  
7a76			;	ld de, key_fa  
7a76			;	call .key_shift_hold  
7a76			;	cp 255  
7a76			;	jr z, .cinmap  
7a76			  
7a76 11 43 79			ld de, .matrix_to_char  
7a79			  
7a79			  
7a79			.cinmap1:   
7a79				if DEBUG_KEY  
7a79			            LD   A, kLCD_Line4  
7a79			            CALL fLCD_Pos       ;Position cursor to location in A  
7a79					push de  
7a79			            LD   DE, keyscan_table  
7a79			            CALL fLCD_Str       ;Display string pointed to by DE  
7a79					pop de  
7a79				endif  
7a79			  
7a79				; scan key matrix table for any held key  
7a79			  
7a79				; de holds either the default matrix or one selected above  
7a79			  
7a79 21 d1 fd			ld hl, keyscan_table  
7a7c 06 32			ld b,key_cols*key_rows  
7a7e			  
7a7e 7e			.cin11:	ld a,(hl)  
7a7f fe 23			cp '#'  
7a81 28 08			jr z, .cinhit1  
7a83 23				inc hl  
7a84 13				inc de  
7a85 05				dec b  
7a86 20 f6			jr nz, .cin11  
7a88				; no key found held  
7a88 3e 00			ld a,0  
7a8a c9				ret  
7a8b d5			.cinhit1: push de  
7a8c e1				pop hl  
7a8d 7e				ld a,(hl)  
7a8e c9				ret  
7a8f			  
7a8f			; flag a control key is held   
7a8f			; hl is key pin, de is flag indicator  
7a8f			  
7a8f			.key_shift_hold1:  
7a8f c5				push bc  
7a90 3e 01			ld a, 1  
7a92 32 f3 fa			ld (cursor_shape),a  
7a95 06 00			ld b, 0  
7a97 7e				ld a, (hl)  
7a98 fe 2e			cp '.'  
7a9a 28 0a			jr z, .key_shift11  
7a9c 06 ff			ld b, 255  
7a9e 3e 2b			ld a, '+'    ; hide key from later scans  
7aa0 77				ld (hl),a  
7aa1 3e 02			ld a, 2  
7aa3 32 f3 fa			ld (cursor_shape),a  
7aa6			.key_shift11:  
7aa6				; write flag indicator  
7aa6 78				ld a,b  
7aa7 12				ld (de),a  
7aa8			  
7aa8 d1				pop de    ; de now holds the key map ptr  
7aa9 c9				ret  
7aaa			  
7aaa				  
7aaa			  
7aaa			; scans keyboard matrix and flags key press in memory array	  
7aaa				  
7aaa			matrix:  
7aaa				;call matrix  
7aaa				; TODO optimise the code....  
7aaa			  
7aaa			  
7aaa			;ld hl, keyscan_table_row1  
7aaa			;ld de, keyscan_table_row1+1  
7aaa			;ld bc,46  
7aaa			;ld a,KEY_MATRIX_NO_PRESS  
7aaa			;ldir  
7aaa			  
7aaa			  
7aaa			  
7aaa			; reset counter  
7aaa 3e 80		ld a, 128  
7aac d3 c1		out (portbdata),a  
7aae			  
7aae 06 0a		ld b, 10  
7ab0 0e 00		ld c, 0       ; current clock toggle  
7ab2			  
7ab2			.colscan:  
7ab2			  
7ab2			; set current column  
7ab2			; disable clock enable and set clock low  
7ab2			  
7ab2			;ld a, 0  
7ab2			;out (portbdata),a  
7ab2			  
7ab2			; For each column scan for switches  
7ab2			  
7ab2 c5			push bc  
7ab3 21 c7 fd		ld hl, keyscan_scancol  
7ab6 cd bf 7b		call .rowscan  
7ab9 c1			pop bc  
7aba			  
7aba			  
7aba			; get back current column  
7aba			  
7aba			; translate the row scan  
7aba			  
7aba			;   
7aba			; row 1  
7aba			  
7aba 78			ld a,b  
7abb			  
7abb 21 3a fe		LD   hl, keyscan_table_row1+10  
7abe			  
7abe cd f0 0f		call subafromhl  
7ac1			;call addatohl  
7ac1			  
7ac1 11 c7 fd		ld de, keyscan_scancol  
7ac4			  
7ac4 1a			ld a,(de)  
7ac5 77			ld (hl),a  
7ac6			  
7ac6			  
7ac6			  
7ac6			  
7ac6			; row 2  
7ac6			  
7ac6 78			ld a,b  
7ac7			  
7ac7 21 2f fe		LD   hl, keyscan_table_row2+10  
7aca			  
7aca			;call addatohl  
7aca cd f0 0f		call subafromhl  
7acd			  
7acd			  
7acd 11 c8 fd		ld de, keyscan_scancol+1  
7ad0			  
7ad0 1a			ld a,(de)  
7ad1 77			ld (hl),a  
7ad2			  
7ad2			  
7ad2			; row 3  
7ad2			  
7ad2 78			ld a,b  
7ad3			  
7ad3 21 24 fe		LD   hl, keyscan_table_row3+10  
7ad6			  
7ad6			;call addatohl  
7ad6 cd f0 0f		call subafromhl  
7ad9			  
7ad9 11 c9 fd		ld de, keyscan_scancol+2  
7adc			  
7adc 1a			ld a,(de)  
7add 77			ld (hl),a  
7ade			  
7ade			  
7ade			  
7ade			; row 4  
7ade			  
7ade 78			ld a,b  
7adf			  
7adf 21 19 fe		LD   hl, keyscan_table_row4+10  
7ae2			  
7ae2			;call addatohl  
7ae2 cd f0 0f		call subafromhl  
7ae5			  
7ae5 11 ca fd		ld de, keyscan_scancol+3  
7ae8			  
7ae8 1a			ld a,(de)  
7ae9 77			ld (hl),a  
7aea			  
7aea			; row 5  
7aea			  
7aea 78			ld a,b  
7aeb			  
7aeb 21 0e fe		LD   hl, keyscan_table_row5+10  
7aee			  
7aee			;call addatohl  
7aee cd f0 0f		call subafromhl  
7af1			  
7af1 11 cb fd		ld de, keyscan_scancol+4  
7af4			  
7af4 1a			ld a,(de)  
7af5 77			ld (hl),a  
7af6			  
7af6			; handshake next column  
7af6			  
7af6			  
7af6 3e 40		ld a, 64  
7af8 d3 c1		out (portbdata),a  
7afa			  
7afa 3e 00		ld a, 0  
7afc d3 c1		out (portbdata),a  
7afe			  
7afe			; toggle clk and move to next column  
7afe			;ld a, 64  
7afe			;cp c  
7afe			;  
7afe			;jr z, .coltoglow  
7afe			;ld c, a  
7afe			;jr .coltog  
7afe			;.coltoglow:  
7afe			;ld c, 0  
7afe			;.coltog:  
7afe			;ld a, c  
7afe			;out (portbdata),a  
7afe			  
7afe 10 b2		djnz .colscan  
7b00			  
7b00 3e 0a		ld a,10  
7b02 21 30 fe		LD   hl, keyscan_table_row1  
7b05 cd de 0f		call addatohl  
7b08 3e 00		ld a, 0  
7b0a 77			ld (hl), a  
7b0b			  
7b0b			  
7b0b 3e 0a		ld a,10  
7b0d 21 25 fe		LD   hl, keyscan_table_row2  
7b10 cd de 0f		call addatohl  
7b13 3e 00		ld a, 0  
7b15 77			ld (hl), a  
7b16			  
7b16 3e 0a		ld a,10  
7b18 21 1a fe		LD   hl, keyscan_table_row3  
7b1b cd de 0f		call addatohl  
7b1e 3e 00		ld a, 0  
7b20 77			ld (hl), a  
7b21			  
7b21 3e 0a		ld a,10  
7b23 21 0f fe		LD   hl, keyscan_table_row4  
7b26 cd de 0f		call addatohl  
7b29 3e 00		ld a, 0  
7b2b 77			ld (hl), a  
7b2c			  
7b2c 3e 0a		ld a,10  
7b2e 21 04 fe		LD   hl, keyscan_table_row5  
7b31 cd de 0f		call addatohl  
7b34 3e 00		ld a, 0  
7b36 77			ld (hl), a  
7b37			  
7b37			if DEBUG_KEY_MATRIX  
7b37			  
7b37			; Display text on first line  
7b37			            LD   A, kLCD_Line1  
7b37			            CALL fLCD_Pos       ;Position cursor to location in A  
7b37			            LD   DE, keyscan_table_row1  
7b37			            ;LD   DE, MsgHello  
7b37			            CALL fLCD_Str       ;Display string pointed to by DE  
7b37			  
7b37			; Display text on second line  
7b37			            LD   A, kLCD_Line2  
7b37			            CALL fLCD_Pos       ;Position cursor to location in A  
7b37			            LD   DE, keyscan_table_row2  
7b37			            CALL fLCD_Str       ;Display string pointed to by DE  
7b37			            LD   A, kLCD_Line3  
7b37			            CALL fLCD_Pos       ;Position cursor to location in A  
7b37			            LD   DE, keyscan_table_row3  
7b37			            CALL fLCD_Str       ;Display string pointed to by DE  
7b37			            LD   A, kLCD_Line4  
7b37			            CALL fLCD_Pos       ;Position cursor to location in A  
7b37			            LD   DE, keyscan_table_row4  
7b37			            CALL fLCD_Str       ;Display string pointed to by DE  
7b37			            LD   A, kLCD_Line4+10  
7b37			            CALL fLCD_Pos       ;Position cursor to location in A  
7b37			            LD   DE, keyscan_table_row5  
7b37			            CALL fLCD_Str       ;Display string pointed to by DE  
7b37			  
7b37			;call delay250ms  
7b37				jp matrix  
7b37			endif  
7b37 c9			ret  
7b38			  
7b38			; using decade counter....  
7b38			  
7b38			  
7b38			; TODO reset decade counter to start of scan  
7b38			  
7b38			; reset 15  
7b38			; clock 14  
7b38			; ce 13  
7b38			  
7b38			; 1 - q5  
7b38			; 2 - q1  
7b38			; 3 - q0  
7b38			; 4 - q2  
7b38			; 5 - q6  
7b38			; 6 - q7  
7b38			; 7 - q3  
7b38			; 8 - vss  
7b38			; 9 - q8  
7b38			; 10 - q4  
7b38			; 11 - q9  
7b38			; 12 - cout  
7b38			; 16 - vdd  
7b38			  
7b38			; clock      ce       reset     output  
7b38			; 0          x        0         n  
7b38			; x          1        0         n  
7b38			; x          x        1         q0  
7b38			; rising     0        0         n+1  
7b38			; falling    x        0         n  
7b38			; x          rising   0         n  
7b38			; 1          falling  0         x+1  
7b38			;  
7b38			; x = dont care, if n < 5 carry = 1 otherwise 0  
7b38			  
7b38			;   
7b38			; reset   
7b38			; 13=0, 14=0, 15=1 .. 15=0  
7b38			;  
7b38			; handshake line  
7b38			; 14=1.... read line 14=0  
7b38			  
7b38			  
7b38			  
7b38			  
7b38			  
7b38			; TODO hand shake clock for next column scan  
7b38			; TODO detect each row  
7b38			  
7b38			  
7b38			  
7b38			  
7b38			; reset 128  
7b38			; clock 64  
7b38			; ce 32  
7b38			  
7b38			  
7b38			.cyclestart:  
7b38			  
7b38			; reset counter  
7b38 3e 80		ld a, 128  
7b3a d3 c1		out (portbdata),a  
7b3c			  
7b3c			; loop leds  
7b3c 06 0a		ld b,10  
7b3e			  
7b3e			.cycle1:  
7b3e c5			push bc  
7b3f 3e 00		ld a, 0  
7b41 d3 c1		out (portbdata),a  
7b43 cd e1 0c		call delay250ms  
7b46			  
7b46 3e 40		ld a, 64  
7b48 d3 c1		out (portbdata),a  
7b4a cd e1 0c		call delay250ms  
7b4d			  
7b4d 3e 00		ld a, 0  
7b4f d3 c1		out (portbdata),a  
7b51 cd e1 0c		call delay250ms  
7b54			  
7b54 c1			pop bc  
7b55 10 e7		djnz .cycle1  
7b57			  
7b57			  
7b57 18 df		jr .cyclestart  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			; map matrix key held to char on face of key  
7b59			  
7b59			;.mtocold:  
7b59			;  
7b59			;  
7b59			;; reset counter  
7b59			;ld a, 128  
7b59			;out (portbdata),a  
7b59			;  
7b59			;  
7b59			;; scan keyboard row 1  
7b59			;ld a, 0  
7b59			;out (portbdata),a  
7b59			;;ld a, 64  
7b59			;;out (portbdata),a  
7b59			;  
7b59			;  
7b59			;	ld a, 128  
7b59			;	ld hl, keyscan_table  
7b59			;	call .rowscan  
7b59			;  
7b59			;;ld a, 0  
7b59			;;out (portbdata),a  
7b59			;ld a, 64  
7b59			;out (portbdata),a  
7b59			;  
7b59			;	ld a, 64  
7b59			;	ld hl, keyscan_table+key_cols  
7b59			;	call .rowscan  
7b59			;  
7b59			;ld a, 0  
7b59			;out (portbdata),a  
7b59			;;ld a, 64  
7b59			;;out (portbdata),a  
7b59			;	ld a, 32  
7b59			;	ld hl, keyscan_table+(key_cols*2)  
7b59			;	call .rowscan  
7b59			;  
7b59			;  
7b59			;;ld a, 0  
7b59			;;out (portbdata),a  
7b59			;ld a, 64  
7b59			;out (portbdata),a  
7b59			;  
7b59			;	ld a, 16  
7b59			;	ld hl, keyscan_table+(key_cols*3)  
7b59			;	call .rowscan  
7b59			;  
7b59			;  
7b59			;	; flag if key D is held down and remove from reporting  
7b59			;	ld bc, .key_map_fd    
7b59			;	ld hl, keyscan_table  
7b59			;	ld de, key_fd  
7b59			;	call .key_shift_hold  
7b59			;	cp 255  
7b59			;	jr z, .cinmap  
7b59			;	; flag if key C is held down and remove from reporting  
7b59			;	ld bc, .key_map_fc    
7b59			;	ld hl, keyscan_table+key_cols  
7b59			;	ld de, key_fc  
7b59			;	call .key_shift_hold  
7b59			;	cp 255  
7b59			;	jr z, .cinmap  
7b59			;	; flag if key B is held down and remove from reporting  
7b59			;	ld bc, .key_map_fb    
7b59			;	ld hl, keyscan_table+(key_cols*2)  
7b59			;	ld de, key_fb  
7b59			;	call .key_shift_hold  
7b59			;	cp 255  
7b59			;	jr z, .cinmap  
7b59			;	; flag if key A is held down and remove from reporting  
7b59			;	ld bc, .key_map_fa    
7b59			;	ld hl, keyscan_table+(key_cols*3)  
7b59			;	ld de, key_fa  
7b59			;	call .key_shift_hold  
7b59			;	cp 255  
7b59			;	jr z, .cinmap  
7b59			;  
7b59			;	ld de, .matrix_to_char  
7b59			;  
7b59			;  
7b59			;.cinmap:   
7b59			;	if DEBUG_KEY  
7b59			;            LD   A, kLCD_Line4  
7b59			;            CALL fLCD_Pos       ;Position cursor to location in A  
7b59			;		push de  
7b59			;            LD   DE, keyscan_table  
7b59			;            CALL fLCD_Str       ;Display string pointed to by DE  
7b59			;		pop de  
7b59			;	endif  
7b59			  
7b59				; scan key matrix table for any held key  
7b59			  
7b59				; de holds either the default matrix or one selected above  
7b59			  
7b59			;	ld hl, keyscan_table  
7b59			;	ld b,key_cols*key_rows  
7b59			;  
7b59			;.cin1:	ld a,(hl)  
7b59			;	cp '#'  
7b59			;	jr z, .cinhit  
7b59			;	inc hl  
7b59			;	inc de  
7b59			;	dec b  
7b59			;	jr nz, .cin1  
7b59			;	; no key found held  
7b59			;	ld a,0  
7b59			;	ret  
7b59			;.cinhit: push de  
7b59			;	pop hl  
7b59			;	ld a,(hl)  
7b59			;	ret  
7b59			  
7b59			; flag a control key is held   
7b59			; hl is key pin, de is flag indicator  
7b59			  
7b59			;.key_shift_hold:  
7b59			;	push bc  
7b59			;	ld a, 1  
7b59			;	ld (cursor_shape),a  
7b59			;	ld b, 0  
7b59			;	ld a, (hl)  
7b59			;	cp '.'  
7b59			;	jr z, .key_shift1  
7b59			;	ld b, 255  
7b59			;	ld a, '+'    ; hide key from later scans  
7b59			;	ld (hl),a  
7b59			;	ld a, 2  
7b59			;	ld (cursor_shape),a  
7b59			;.key_shift1:  
7b59			;	; write flag indicator  
7b59			;	ld a,b  
7b59			;	ld (de),a  
7b59			;  
7b59			;	pop de    ; de now holds the key map ptr  
7b59			;	ret  
7b59			  
7b59				  
7b59				  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			;	push hl  
7b59			;	push de  
7b59			;	push bc  
7b59			;	call keyscan  
7b59			;	; map key matrix to ascii value of key face  
7b59			;  
7b59			;	ld hl, key_face_map  
7b59			;	ld de, keyscan_table  
7b59			;  
7b59			;	; get how many keys to look at  
7b59			;	ld b, keyscan_table_len  
7b59			;	  
7b59			;  
7b59			;	; at this stage fall out on first key hit  
7b59			;	; TODO handle multiple key press  
7b59			;  
7b59			;map1:	ld a,(hl)  
7b59			;	cp '#'  
7b59			;	jr z, keyhit  
7b59			;	inc hl  
7b59			;	inc de  
7b59			;	dec b  
7b59			;	jr nz, map1  
7b59			;nohit:	ld a, 0  
7b59			;	jr keydone  
7b59			;keyhit: push de  
7b59			;	pop hl  
7b59			;	ld a,(hl)  
7b59			;keydone:  
7b59			;	push bc  
7b59			;	push de  
7b59			; 	push hl  
7b59			;	ret   
7b59			;  
7b59			  
7b59			  
7b59			  
7b59			  
7b59			; scan physical key matrix  
7b59			  
7b59			  
7b59			;keyscan:  
7b59			;  
7b59			;; for each key_row use keyscanr bit mask for out  
7b59			;; then read in for keyscanc bitmask  
7b59			;; save result of row scan to keyscantable  
7b59			;  
7b59			;; scan keyboard row 1  
7b59			;  
7b59			;	ld b, key_rows  
7b59			;	ld hl, key_scanr  
7b59			;	ld de, keyscan_table  
7b59			;  
7b59			;rowloop:  
7b59			;  
7b59			;	ld a,(hl)		; out bit mask to energise keyboard row  
7b59			;	call rowscan  
7b59			;	inc hl  
7b59			;	dec b  
7b59			;	jr nz, rowloop  
7b59			;  
7b59			;	ret  
7b59			;  
7b59			;  
7b59			;; pass a out bitmask, b row number  
7b59			;arowscan:   
7b59			;	push bc  
7b59			;  
7b59			;	ld d, b  
7b59			;  
7b59			;	; calculate buffer location for this row  
7b59			;  
7b59			;	ld hl, keyscan_table	  
7b59			;kbufr:  ld e, key_cols  
7b59			;kbufc:	inc hl  
7b59			;	dec e  
7b59			;	jr nz, kbufc  
7b59			;	dec d  
7b59			;	jr nz, kbufr  
7b59			;  
7b59			;	; energise row and read columns  
7b59			;  
7b59			;	out (portbdata),a  
7b59			;	in a,(portbdata)  
7b59			;	ld c,a  
7b59			;  
7b59			;  
7b59			;	; save buffer loc  
7b59			;  
7b59			;	ld (keybufptr), hl  
7b59			;  
7b59			;	ld hl, key_scanc  
7b59			;	ld d, key_cols  
7b59			;  
7b59			;	; for each column check each bit mask  
7b59			;  
7b59			;colloop:  
7b59			;	  
7b59			;  
7b59			;	; reset flags for the row   
7b59			;  
7b59			;	ld b,'.'  
7b59			;	and (hl)  
7b59			;	jr z, maskskip  
7b59			;	ld b,'#'  
7b59			;maskskip:  
7b59			;	; save  key state  
7b59			;	push hl  
7b59			;	ld hl, (keybufptr)  
7b59			;	ld (hl), b  
7b59			;	inc hl  
7b59			;	ld (keybufptr), hl  
7b59			;  
7b59			;	; move to next bit mask  
7b59			;	pop hl  
7b59			;	inc hl  
7b59			;  
7b59			;	dec d  
7b59			;	jr nz, colloop  
7b59			;  
7b59			;	ret  
7b59			;  
7b59			;  
7b59			;;  
7b59			; lcd functions  
7b59			;  
7b59			;  
7b59			  
7b59			;if DEBUG_KEY_MATRIX  
7b59			  
7b59			; test function to display hardware view of matrix state  
7b59			  
7b59			matrixold:  
7b59			  
7b59			  
7b59			  
7b59			; reset counter  
7b59 3e 80		ld a, 128  
7b5b d3 c1		out (portbdata),a  
7b5d			; scan keyboard row 1  
7b5d 3e 00		ld a, 0  
7b5f d3 c1		out (portbdata),a  
7b61			;ld a, 64  
7b61			;out (portbdata),a  
7b61 3e 80			ld a, 128  
7b63 21 30 fe			ld hl, keyscan_table_row1  
7b66 cd bf 7b			call .rowscan  
7b69			  
7b69			;ld a, 0  
7b69			;out (portbdata),a  
7b69 3e 40		ld a, 64  
7b6b d3 c1		out (portbdata),a  
7b6d 3e 40			ld a, 64  
7b6f 21 25 fe			ld hl, keyscan_table_row2  
7b72 cd bf 7b			call .rowscan  
7b75			  
7b75 3e 00		ld a, 0  
7b77 d3 c1		out (portbdata),a  
7b79			;ld a, 64  
7b79			;out (portbdata),a  
7b79 3e 20			ld a, 32  
7b7b 21 1a fe			ld hl, keyscan_table_row3  
7b7e cd bf 7b			call .rowscan  
7b81			  
7b81			;ld a, 0  
7b81			;out (portbdata),a  
7b81 3e 40		ld a, 64  
7b83 d3 c1		out (portbdata),a  
7b85 3e 10			ld a, 16  
7b87 21 0f fe			ld hl, keyscan_table_row4  
7b8a cd bf 7b			call .rowscan  
7b8d			  
7b8d			; Display text on first line  
7b8d 3e 00		            LD   A, kLCD_Line1  
7b8f cd bd 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b92 11 30 fe		            LD   DE, keyscan_table_row1  
7b95			            ;LD   DE, MsgHello  
7b95 cd df 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b98			  
7b98			; Display text on second line  
7b98 3e 28		            LD   A, kLCD_Line2  
7b9a cd bd 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b9d 11 25 fe		            LD   DE, keyscan_table_row2  
7ba0 cd df 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7ba3 3e 50		            LD   A, kLCD_Line3  
7ba5 cd bd 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7ba8 11 1a fe		            LD   DE, keyscan_table_row3  
7bab cd df 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7bae 3e 78		            LD   A, kLCD_Line4  
7bb0 cd bd 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7bb3 11 0f fe		            LD   DE, keyscan_table_row4  
7bb6 cd df 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7bb9			  
7bb9 cd e1 0c			call delay250ms  
7bbc c3 aa 7a			jp matrix  
7bbf			  
7bbf			; pass de as row display flags  
7bbf			.rowscan:   
7bbf			;	out (portbdata),a  
7bbf db c1			in a,(portbdata)  
7bc1 4f				ld c,a  
7bc2				; reset flags for the row   
7bc2 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bc4 e6 01			and 1  
7bc6 28 02			jr z, .p1on  
7bc8 06 23			ld b,'#'  
7bca			.p1on:  
7bca 70				ld (hl), b  
7bcb 23				inc hl  
7bcc			  
7bcc 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bce 79				ld a,c  
7bcf e6 02			and 2  
7bd1			;	bit 0,a  
7bd1 28 02			jr z, .p2on  
7bd3 06 23			ld b,'#'  
7bd5			.p2on:  
7bd5 70				ld (hl), b  
7bd6 23				inc hl  
7bd7			;  
7bd7 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bd9 79				ld a,c  
7bda e6 04			and 4  
7bdc			;;	bit 0,a  
7bdc 28 02			jr z, .p3on  
7bde 06 23			ld b,'#'  
7be0			.p3on:  
7be0 70				ld (hl), b  
7be1 23				inc hl  
7be2			;;  
7be2 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7be4			;;	bit 0,a  
7be4 79				ld a,c  
7be5 e6 08			and 8  
7be7 28 02			jr z, .p4on  
7be9 06 23			ld b,'#'  
7beb			.p4on:  
7beb 70				ld (hl), b  
7bec 23				inc hl  
7bed			  
7bed 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bef			;;	bit 0,a  
7bef 79				ld a,c  
7bf0 e6 10			and 16  
7bf2 28 02			jr z, .p5on  
7bf4 06 23			ld b,'#'  
7bf6			.p5on:  
7bf6 70				ld (hl), b  
7bf7 23				inc hl  
7bf8			; zero term  
7bf8 06 00			ld b,0  
7bfa 70				ld (hl), b  
7bfb			  
7bfb c9			.rscandone: ret  
7bfc			  
7bfc			;addatohl:  
7bfc			;  
7bfc			 ;add   a, l    ; A = A+L  
7bfc			  ;  ld    l, a    ; L = A+L  
7bfc			   ; adc   a, h    ; A = A+L+H+carry  
7bfc			   ; sub   l       ; A = H+carry  
7bfc			   ; ld    h, a    ; H = H+carry  
7bfc			  
7bfc			;ret  
7bfc			; eof  
# End of file firmware_key_5x10.asm
7bfc			;include "firmware_key_4x10.asm" 
7bfc			 
7bfc			heap_size:    equ heap_end - heap_start 
7bfc			;eof 
# End of file os_mega.asm
7bfc
