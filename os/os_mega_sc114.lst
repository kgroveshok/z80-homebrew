# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 4f 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			if BASE_KEV = 1  
801c			 
801c				; need to be at $66 for nmi support 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255 
801c				jp nmi 
801c			endif 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 0       
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c			;	call break_point_state  
801c			; now use the break point debug vector  
801c				call debug_vector  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801c			  
801c			debug_mark: equ debug_vector - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_active-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			;os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_new_exec_ptr - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c			;	ld a, ' ' 
801c			;	ld (os_view_disable), a 
801c				call bp_on 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 10 ed				ld hl, display_fb1  
801f 22 cc eb				ld (display_fb_active), hl  
8022			  
8022 cd af 8a				call clear_display  
8025			  
8025 21 ce eb				ld hl, display_fb2  
8028 22 cc eb				ld (display_fb_active), hl  
802b			  
802b cd af 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b1 ed				ld hl, display_fb0  
8031 22 cc eb				ld (display_fb_active), hl  
8034			  
8034 cd af 8a				call clear_display  
8037			  
8037			  
8037 cd 25 e3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd c7 e3			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 7f 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd d2 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd b4 8a			call fill_display  
804e cd d2 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd b4 8a			call fill_display  
8059 cd d2 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd b4 8a			call fill_display  
8064 cd d2 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 ad 96			ld de, prom_bootmsg  
806f cd c2 8a			call str_at_display  
8072 cd d2 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 c2 96			ld de, prom_bootmsg1  
8080 cd c2 8a			call str_at_display  
8083 cd d2 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 6b ee		ld (debug_mark),a  
8091 32 6c ee		ld (debug_mark+1),a  
8094 32 6d ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 6e ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 73 ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 6b ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 6c ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 6d ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd 6f ee			call debug_vector  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 7a ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 6b ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 6c ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 6d ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd 6f ee			call debug_vector  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 7a ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 6b ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 6c ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 6d ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd 6f ee			call debug_vector  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd 05 8d				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 73 ea				ld hl, (store_tmp1) 
8110 11 7d ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 6b ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 6c ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 6d ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd 6f ee			call debug_vector  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 72 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 6b ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 6c ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 6d ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd 6f ee			call debug_vector  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 6b ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 6c ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 6d ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd 6f ee			call debug_vector  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 6b ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 6c ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 6d ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd 6f ee			call debug_vector  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 6b ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 6c ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 6d ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd 6f ee			call debug_vector  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd 05 8d			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 7a ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 6b ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 6c ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 6d ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd 6f ee			call debug_vector  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 6b ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 6c ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 6d ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd 6f ee			call debug_vector  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 7a ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 6b ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 6c ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 6d ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 7a ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd 6f ee			call debug_vector  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 7b ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 6b ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 6c ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 6d ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd 6f ee			call debug_vector  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 6b ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 6c ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 6d ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd 6f ee			call debug_vector  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 7a ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 7b ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 7d ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 86 ea			ld hl, store_page+3+9 
82b5 3a 5f ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 7a ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 6b ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 6c ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 6d ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd 6f ee			call debug_vector  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 6b ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 6c ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 6d ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd 6f ee			call debug_vector  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd dc 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd dc 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 6b ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 6c ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 6d ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd 6f ee			call debug_vector  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 7d ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 6b ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 6c ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 6d ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd 6f ee			call debug_vector  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 7a ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 6b ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 6c ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 6d ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd 6f ee			call debug_vector  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 6b ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 6c ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 6d ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd 6f ee			call debug_vector  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd 05 8d			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 7a ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd 05 8d			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 6b ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 6c ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 6d ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd 6f ee			call debug_vector  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 7a ea			ld a, (store_page)	; get file id 
8410 32 6e ea			ld (store_tmpid), a 
8413			 
8413 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8416 32 6d ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 7a ea			ld (store_page), a 
841f 32 7b ea			ld (store_page+1),a 
8422 11 7a ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 6b ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 6c ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 6d ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd 6f ee			call debug_vector  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 6d ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 6e ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 6b ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 6c ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 6d ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd 6f ee			call debug_vector  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd 05 8d			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 7a ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 7a ea			ld (store_page), a 
8482 32 7b ea			ld (store_page+1),a 
8485 11 7a ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 6b ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 6c ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 6d ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd 6f ee			call debug_vector  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 6b ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 6c ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 6d ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd 6f ee			call debug_vector  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd fa 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd dc 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd fa 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd dc 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 6b ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 6c ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 6d ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd 6f ee			call debug_vector  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 6b ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 6c ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 6d ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd 6f ee			call debug_vector  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd dc 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd dc 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 6b ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 6c ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 6d ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd 6f ee			call debug_vector  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 7a ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 7a ea			ld (store_page),a 
85a3				 
85a3 32 6e ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 7a ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 6b ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 6c ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 6d ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd 6f ee			call debug_vector  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 7a ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 6b ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 6c ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 6d ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 6f ee			call debug_vector  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 6b ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 6c ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 6d ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd 6f ee			call debug_vector  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 65 ea			ld (store_tmppageid), hl 
8615				 
8615 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 7a ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 7b ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 6b ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 6c ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 6d ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd 6f ee			call debug_vector  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 45 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 6b ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 6c ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 6d ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd 6f ee			call debug_vector  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 6b ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 6c ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 6d ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd 6f ee			call debug_vector  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 65 ea			ld hl,(store_tmppageid) 
868b 11 7a ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 6b ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 6c ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 6d ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd 6f ee			call debug_vector  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 6e ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 6b ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 6c ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 6d ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd 6f ee			call debug_vector  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 6b ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 6c ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 6d ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd 6f ee			call debug_vector  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 6b ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 6c ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 6d ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd 6f ee			call debug_vector  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd 05 8d			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 6b ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 6b ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 6c ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 6d ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd 6f ee			call debug_vector  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd dc 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 6d ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 6b ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 6c ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 6d ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd 6f ee			call debug_vector  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 75 ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd dc 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 6b ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 6c ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 6d ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd 6f ee			call debug_vector  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 6b ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 6c ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 6d ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd 6f ee			call debug_vector  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 6b ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 6c ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 6d ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd 6f ee			call debug_vector  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd 05 8d			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 6b ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 6b ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 6c ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 6d ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd 6f ee			call debug_vector  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 6b ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 6c ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 6d ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd 6f ee			call debug_vector  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 6b ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 6c ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 6d ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd 6f ee			call debug_vector  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 6b ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 6c ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 6d ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd 6f ee			call debug_vector  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 6e ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 6e ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd 05 8d			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 65 ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 6b ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 6c ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 6d ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd 6f ee			call debug_vector  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 7a ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 6b ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 6c ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 6d ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd 6f ee			call debug_vector  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 7c ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 7c ea			ld (store_page+2), a 
88e3 32 6d ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 6b ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 6c ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 6d ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd 6f ee			call debug_vector  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 65 ea			ld hl, (store_tmppageid) 
8905 11 7a ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd 05 8d			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 65 ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 6b ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 6c ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 6d ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd 6f ee			call debug_vector  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 7a ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 6e ea				ld a, (store_tmpid) 
894b 32 7a ea				ld (store_page), a   ; file id 
894e 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 7b ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 7c ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 6b ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 6c ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 6d ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd 6f ee			call debug_vector  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 65 ea			ld hl, (store_tmppageid) 
8985 11 7a ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 6b ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 6c ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 6d ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd 6f ee			call debug_vector  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 6e ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 7a ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 7b ea			ld de, store_page+1 
89c1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; Display an activity indicator 
8a06			; Each call returns the new char pointed to in hl 
8a06			 
8a06			active: 
8a06 3a c6 eb			ld a, (display_active) 
8a09 fe 06			cp 6 
8a0b			 
8a0b 20 02			jr nz, .sne 
8a0d				; gone past the last one reset sequence 
8a0d 3e ff			ld a, 255 
8a0f			 
8a0f			.sne:   
8a0f				; get the next char in seq 
8a0f 3c				inc a 
8a10 32 c6 eb			ld (display_active), a 
8a13			 
8a13				; look up the string in the table 
8a13 21 2a 8a			ld hl, actseq 
8a16 cb 27			sla a 
8a18 cd dc 8c			call addatohl 
8a1b cd 7a 9e			call loadwordinhl 
8a1e			 
8a1e				; forth will write the to string when pushing so move from rom to ram 
8a1e			 
8a1e 11 c7 eb			ld de, display_active+1 
8a21 01 02 00			ld bc, 2 
8a24 ed b0			ldir 
8a26			 
8a26 21 c7 eb			ld hl, display_active+1 
8a29 c9				ret 
8a2a				 
8a2a				 
8a2a			 
8a2a			 
8a2a			;db "|/-\|-\" 
8a2a			 
8a2a			actseq: 
8a2a			 
8a2a 38 8a		dw spin0 
8a2c 3a 8a		dw spin1 
8a2e 3c 8a		dw spin2 
8a30 3e 8a		dw spin3 
8a32 3c 8a		dw spin2 
8a34 3a 8a		dw spin1 
8a36 38 8a		dw spin0 
8a38			 
8a38 .. 00		spin0: db " ", 0 
8a3a .. 00		spin1: db "-", 0 
8a3c .. 00		spin2: db "+", 0 
8a3e .. 00		spin3: db "#", 0 
8a40			 
8a40			 
8a40			; information window 
8a40			 
8a40			; pass hl with 1st string to display 
8a40			; pass de with 2nd string to display 
8a40			 
8a40			info_panel: 
8a40 e5				push hl 
8a41			 
8a41 2a cc eb			ld hl, (display_fb_active) 
8a44 e5				push hl    ; future de destination 
8a45 21 b1 ed				ld hl, display_fb0 
8a48 22 cc eb				ld (display_fb_active), hl 
8a4b			 
8a4b			;	call clear_display 
8a4b			 
8a4b				if BASE_CPM 
8a4b				ld a, '.' 
8a4b				else 
8a4b 3e a5			ld a, 165 
8a4d				endif 
8a4d cd b4 8a			call fill_display 
8a50			 
8a50			 
8a50 3e 55			ld a, display_row_3 + 5 
8a52 cd c2 8a			call str_at_display 
8a55			 
8a55 e1				pop hl 
8a56 d1				pop de 
8a57			 
8a57 e5				push hl 
8a58			 
8a58			 
8a58 3e 2d			ld a, display_row_2 + 5 
8a5a cd c2 8a			call str_at_display 
8a5d			 
8a5d			 
8a5d cd d2 8a			call update_display 
8a60 cd c3 9a			call next_page_prompt 
8a63 cd af 8a			call clear_display 
8a66			 
8a66				 
8a66 21 10 ed				ld hl, display_fb1 
8a69 22 cc eb				ld (display_fb_active), hl 
8a6c cd d2 8a			call update_display 
8a6f			 
8a6f e1				pop hl 
8a70			 
8a70 c9				ret 
8a71			 
8a71			 
8a71			 
8a71			 
8a71			; TODO windowing? 
8a71			 
8a71			; TODO scroll line up 
8a71			 
8a71			scroll_up: 
8a71			 
8a71 e5				push hl 
8a72 d5				push de 
8a73 c5				push bc 
8a74			 
8a74				; get frame buffer  
8a74			 
8a74 2a cc eb			ld hl, (display_fb_active) 
8a77 e5				push hl    ; future de destination 
8a78			 
8a78 11 28 00			ld  de, display_cols 
8a7b 19				add hl, de 
8a7c			 
8a7c d1				pop de 
8a7d			 
8a7d				;ex de, hl 
8a7d 01 9f 00			ld bc, display_fb_len -1  
8a80			;if DEBUG_FORTH_WORDS 
8a80			;	DMARK "SCL" 
8a80			;	CALLMONITOR 
8a80			;endif	 
8a80 ed b0			ldir 
8a82			 
8a82				; wipe bottom row 
8a82			 
8a82			 
8a82 2a cc eb			ld hl, (display_fb_active) 
8a85 11 a0 00			ld de, display_cols*display_rows 
8a88 19				add hl, de 
8a89 06 28			ld b, display_cols 
8a8b 3e 20			ld a, ' ' 
8a8d			.scwipe: 
8a8d 77				ld (hl), a 
8a8e 2b				dec hl 
8a8f 10 fc			djnz .scwipe 
8a91			 
8a91				;pop hl 
8a91			 
8a91 c1				pop bc 
8a92 d1				pop de 
8a93 e1				pop hl 
8a94			 
8a94 c9				ret 
8a95			 
8a95			 
8a95			;scroll_upo: 
8a95			;	ld de, display_row_1 
8a95			 ;	ld hl, display_row_2 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_2 
8a95			 ;	ld hl, display_row_3 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_3 
8a95			 ;	ld hl, display_row_4 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			 
8a95			; TODO clear row 4 
8a95			 
8a95			;	ret 
8a95			 
8a95				 
8a95			scroll_down: 
8a95			 
8a95 e5				push hl 
8a96 d5				push de 
8a97 c5				push bc 
8a98			 
8a98				; get frame buffer  
8a98			 
8a98 2a cc eb			ld hl, (display_fb_active) 
8a9b			 
8a9b 11 9f 00			ld de, display_fb_len - 1 
8a9e 19				add hl, de 
8a9f			 
8a9f e5			push hl    ; future de destination 
8aa0			 
8aa0 11 28 00			ld  de, display_cols 
8aa3 ed 52			sbc hl, de 
8aa5			 
8aa5			 
8aa5 d1				pop de 
8aa6			 
8aa6			;	ex de, hl 
8aa6 01 9f 00			ld bc, display_fb_len -1  
8aa9			 
8aa9			 
8aa9				 
8aa9			 
8aa9 ed b0			ldir 
8aab			 
8aab				; wipe bottom row 
8aab			 
8aab			 
8aab			;	ld hl, (display_fb_active) 
8aab			;;	ld de, display_cols*display_rows 
8aab			;;	add hl, de 
8aab			;	ld b, display_cols 
8aab			;	ld a, ' ' 
8aab			;.scwiped: 
8aab			;	ld (hl), a 
8aab			;	dec hl 
8aab			;	djnz .scwiped 
8aab			 
8aab				;pop hl 
8aab			 
8aab c1				pop bc 
8aac d1				pop de 
8aad e1				pop hl 
8aae			 
8aae c9				ret 
8aaf			;scroll_down: 
8aaf			;	ld de, display_row_4 
8aaf			;	ld hl, display_row_3 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_3 
8aaf			; 	ld hl, display_row_2 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_2 
8aaf			;	ld hl, display_row_1 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;;; TODO clear row 1 
8aaf			;	ret 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			; clear active frame buffer 
8aaf			 
8aaf			clear_display: 
8aaf 3e 20			ld a, ' ' 
8ab1 c3 b4 8a			jp fill_display 
8ab4			 
8ab4			; fill active frame buffer with a char in A 
8ab4			 
8ab4			fill_display: 
8ab4 06 a0			ld b,display_fb_len 
8ab6 2a cc eb			ld hl, (display_fb_active) 
8ab9 77			.fd1:	ld (hl),a 
8aba 23				inc hl 
8abb 10 fc			djnz .fd1 
8abd 23				inc hl 
8abe 3e 00			ld a,0 
8ac0 77				ld (hl),a 
8ac1			 
8ac1			 
8ac1 c9				ret 
8ac2			; Write string (DE) at pos (A) to active frame buffer 
8ac2			 
8ac2 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac5 06 00					ld b,0 
8ac7 4f					ld c,a 
8ac8 09					add hl,bc 
8ac9 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8aca b7			            OR   A              ;Null terminator? 
8acb c8			            RET  Z              ;Yes, so finished 
8acc 77					ld (hl),a 
8acd 23				inc hl 
8ace 13			            INC  DE             ;Point to next character 
8acf 18 f8		            JR   .sad1     ;Repeat 
8ad1 c9					ret 
8ad2			 
8ad2			; using current frame buffer write to physical display 
8ad2			 
8ad2			update_display: 
8ad2 e5				push hl 
8ad3 2a cc eb			ld hl, (display_fb_active) 
8ad6 cd 3c e3			call write_display 
8ad9 e1				pop hl 
8ada c9				ret 
8adb			 
8adb			; TODO scrolling 
8adb			 
8adb			 
8adb			; move cursor right one char 
8adb			cursor_right: 
8adb			 
8adb				; TODO shift right 
8adb				; TODO if beyond max col 
8adb				; TODO       cursor_next_line 
8adb			 
8adb c9				ret 
8adc			 
8adc			 
8adc			cursor_next_line: 
8adc				; TODO first char 
8adc				; TODO line down 
8adc				; TODO if past last row 
8adc				; TODO    scroll up 
8adc			 
8adc c9				ret 
8add			 
8add			cursor_left: 
8add				; TODO shift left 
8add				; TODO if beyond left  
8add				; TODO     cursor prev line 
8add				 
8add c9				ret 
8ade			 
8ade			cursor_prev_line: 
8ade				; TODO last char 
8ade				; TODO line up 
8ade				; TODO if past first row 
8ade				; TODO   scroll down 
8ade			 
8ade c9				ret 
8adf			 
8adf			 
8adf			cout: 
8adf				; A - char 
8adf c9				ret 
8ae0			 
8ae0			 
8ae0			; Display a menu and allow item selection (optional toggle items) 
8ae0			; 
8ae0			; format: 
8ae0			; hl pointer to word array with zero term for items 
8ae0			; e.g.    db item1 
8ae0			;         db .... 
8ae0			;         db 0 
8ae0			; 
8ae0			; a = starting menu item  
8ae0			; 
8ae0			; de = pointer item toggle array   (todo) 
8ae0			; 
8ae0			; returns item selected in a 1-... 
8ae0			; returns 0 if back button pressed 
8ae0			; 
8ae0			; NOTE: Uses system frame buffer to display 
8ae0			; 
8ae0			; LEFT, Q = go back 
8ae0			; RIGHT, SPACE, CR = select 
8ae0			; UP, A - Up 
8ae0			; DOWN, Z - Down 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			menu: 
8ae0			 
8ae0					; keep array pointer 
8ae0			 
8ae0 22 73 ea				ld (store_tmp1), hl 
8ae3 32 71 ea				ld (store_tmp2), a 
8ae6			 
8ae6					; check for key bounce 
8ae6			 
8ae6			if BASE_KEV 
8ae6			 
8ae6			.mbounce:	call cin 
8ae6					cp 0 
8ae6					jr nz, .mbounce 
8ae6			endif 
8ae6					; for ease use ex 
8ae6			 
8ae6					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae6 21 b1 ed				ld hl, display_fb0 
8ae9 22 cc eb				ld (display_fb_active), hl 
8aec			 
8aec cd af 8a		.mloop:		call clear_display 
8aef cd d2 8a				call update_display 
8af2			 
8af2					; draw selection id '>' at 1 
8af2			 
8af2					; init start of list display 
8af2			 
8af2 3e 05				ld a, 5 
8af4 32 6f ea				ld (store_tmp3), a   ; display row count 
8af7 3a 71 ea				ld a,( store_tmp2) 
8afa 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afd			 
8afd					 
8afd			.mitem:	 
8afd			 
8afd			 
8afd 3a 72 ea				ld a,(store_tmp2+1) 
8b00 6f					ld l, a 
8b01 26 00				ld h, 0 
8b03 29					add hl, hl 
8b04 ed 5b 73 ea			ld de, (store_tmp1) 
8b08 19					add hl, de 
8b09 7e					ld a, (hl) 
8b0a 23					inc hl 
8b0b 66					ld h,(hl) 
8b0c 6f					ld l, a 
8b0d			 
8b0d cd 05 8d				call ishlzero 
8b10 28 1a				jr z, .mdone 
8b12			 
8b12 eb					ex de, hl 
8b13 3a 6f ea				ld a, (store_tmp3) 
8b16 cd c2 8a				call str_at_display 
8b19					 
8b19			 
8b19					; next item 
8b19 3a 72 ea				ld a, (store_tmp2+1) 
8b1c 3c					inc a 
8b1d 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b20			 
8b20			 		; next row 
8b20			 
8b20 3a 6f ea				ld a, (store_tmp3) 
8b23 c6 28				add display_cols 
8b25 32 6f ea				ld (store_tmp3), a 
8b28			 
8b28					; at end of screen? 
8b28			 
8b28 fe 10				cp display_rows*4 
8b2a 20 d1				jr nz, .mitem 
8b2c			 
8b2c			 
8b2c			.mdone: 
8b2c cd 05 8d				call ishlzero 
8b2f 28 08				jr z, .nodn 
8b31			 
8b31 3e 78				ld a, display_row_4 
8b33 11 b2 8b				ld de, .mdown 
8b36 cd c2 8a				call str_at_display 
8b39			 
8b39					; draw options to fill the screens with active item on line 1 
8b39					; if current option is 2 or more then display ^ in top 
8b39			 
8b39 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3c fe 00				cp 0 
8b3e 28 08				jr z, .noup 
8b40			 
8b40 3e 00				ld a, 0 
8b42 11 b0 8b				ld de, .mup 
8b45 cd c2 8a				call str_at_display 
8b48			 
8b48 3e 02		.noup:		ld a, 2 
8b4a 11 ae 8b				ld de, .msel 
8b4d cd c2 8a				call str_at_display 
8b50			 
8b50					; if current option + 1 is not null then display V in bottom 
8b50					; get key 
8b50 cd d2 8a				call update_display 
8b53			 
8b53			 
8b53					; handle key 
8b53			 
8b53 cd c8 e3				call cin_wait 
8b56			 
8b56 fe 05				cp KEY_UP 
8b58 28 2b				jr z, .mgoup 
8b5a fe 61				cp 'a' 
8b5c 28 27				jr z, .mgoup 
8b5e fe 0a				cp KEY_DOWN 
8b60 28 32				jr z, .mgod 
8b62 fe 7a				cp 'z' 
8b64 28 2e				jr z, .mgod 
8b66 fe 20				cp ' ' 
8b68 28 34				jr z, .goend 
8b6a fe 0c				cp KEY_RIGHT 
8b6c 28 30				jr z, .goend 
8b6e fe 0d				cp KEY_CR 
8b70 28 2c				jr z, .goend 
8b72 fe 71				cp 'q' 
8b74 28 0b				jr z, .goback 
8b76			 
8b76 fe 0b				cp KEY_LEFT 
8b78 28 07				jr z, .goback 
8b7a fe 08				cp KEY_BS 
8b7c 28 03				jr z, .goback 
8b7e c3 ec 8a				jp .mloop 
8b81			 
8b81			.goback: 
8b81 3e 00			ld a, 0 
8b83 18 1d			jr .goend2 
8b85			 
8b85				; move up one 
8b85			.mgoup: 
8b85 3a 71 ea				ld a, (store_tmp2) 
8b88 fe 00				cp 0 
8b8a ca ec 8a				jp z, .mloop 
8b8d 3d					dec a 
8b8e 32 71 ea				ld (store_tmp2), a 
8b91 c3 ec 8a				jp .mloop 
8b94			 
8b94				; move down one 
8b94			.mgod: 
8b94 3a 71 ea				ld a, (store_tmp2) 
8b97 3c					inc a 
8b98 32 71 ea				ld (store_tmp2), a 
8b9b c3 ec 8a				jp .mloop 
8b9e			 
8b9e			 
8b9e			.goend: 
8b9e					; get selected item number 
8b9e			 
8b9e 3a 71 ea				ld a, (store_tmp2) 
8ba1 3c					inc a 
8ba2			 
8ba2			.goend2: 
8ba2 f5					push af 
8ba3			 
8ba3					; restore active fb 
8ba3					; TODO BUG assumes fb1 
8ba3			 
8ba3 21 10 ed				ld hl, display_fb1 
8ba6 22 cc eb				ld (display_fb_active), hl 
8ba9			 
8ba9					; restore main regs 
8ba9			 
8ba9			 
8ba9 cd d2 8a				call update_display 
8bac			 
8bac f1					pop af 
8bad			 
8bad c9				ret 
8bae			 
8bae .. 00		.msel:   db ">",0 
8bb0 .. 00		.mup:   db "^",0 
8bb2 .. 00		.mdown:   db "v",0 
8bb4			 
8bb4			 
8bb4			; eof 
8bb4			 
# End of file firmware_display.asm
8bb4			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb4			; random number generators 
8bb4			 
8bb4			 
8bb4			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb4			 
8bb4			 
8bb4			;-----> Generate a random number 
8bb4			; output a=answer 0<=a<=255 
8bb4			; all registers are preserved except: af 
8bb4			random: 
8bb4 e5			        push    hl 
8bb5 d5			        push    de 
8bb6 2a ab eb		        ld      hl,(randData) 
8bb9 ed 5f		        ld      a,r 
8bbb 57			        ld      d,a 
8bbc 5e			        ld      e,(hl) 
8bbd 19			        add     hl,de 
8bbe 85			        add     a,l 
8bbf ac			        xor     h 
8bc0 22 ab eb		        ld      (randData),hl 
8bc3 d1			        pop     de 
8bc4 e1			        pop     hl 
8bc5 c9			        ret 
8bc6			 
8bc6			 
8bc6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc6			 
8bc6			 
8bc6			 
8bc6			;------LFSR------ 
8bc6			;James Montelongo 
8bc6			;optimized by Spencer Putt 
8bc6			;out: 
8bc6			; a = 8 bit random number 
8bc6			RandLFSR: 
8bc6 21 b1 eb		        ld hl,LFSRSeed+4 
8bc9 5e			        ld e,(hl) 
8bca 23			        inc hl 
8bcb 56			        ld d,(hl) 
8bcc 23			        inc hl 
8bcd 4e			        ld c,(hl) 
8bce 23			        inc hl 
8bcf 7e			        ld a,(hl) 
8bd0 47			        ld b,a 
8bd1 cb 13		        rl e  
8bd3 cb 12			rl d 
8bd5 cb 11		        rl c  
8bd7 17				rla 
8bd8 cb 13		        rl e  
8bda cb 12			rl d 
8bdc cb 11		        rl c  
8bde 17				rla 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 67			        ld h,a 
8be7 cb 13		        rl e  
8be9 cb 12			rl d 
8beb cb 11		        rl c  
8bed 17				rla 
8bee a8			        xor b 
8bef cb 13		        rl e  
8bf1 cb 12			rl d 
8bf3 ac			        xor h 
8bf4 a9			        xor c 
8bf5 aa			        xor d 
8bf6 21 b3 eb		        ld hl,LFSRSeed+6 
8bf9 11 b4 eb		        ld de,LFSRSeed+7 
8bfc 01 07 00		        ld bc,7 
8bff ed b8		        lddr 
8c01 12			        ld (de),a 
8c02 c9			        ret 
8c03			 
8c03			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c03			 
8c03			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c03			 
8c03			 
8c03			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c03			 
8c03			prng16: 
8c03			;Inputs: 
8c03			;   (seed1) contains a 16-bit seed value 
8c03			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c03			;Outputs: 
8c03			;   HL is the result 
8c03			;   BC is the result of the LCG, so not that great of quality 
8c03			;   DE is preserved 
8c03			;Destroys: 
8c03			;   AF 
8c03			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c03			;160cc 
8c03			;26 bytes 
8c03 2a a5 eb		    ld hl,(seed1) 
8c06 44			    ld b,h 
8c07 4d			    ld c,l 
8c08 29			    add hl,hl 
8c09 29			    add hl,hl 
8c0a 2c			    inc l 
8c0b 09			    add hl,bc 
8c0c 22 a5 eb		    ld (seed1),hl 
8c0f 2a a3 eb		    ld hl,(seed2) 
8c12 29			    add hl,hl 
8c13 9f			    sbc a,a 
8c14 e6 2d		    and %00101101 
8c16 ad			    xor l 
8c17 6f			    ld l,a 
8c18 22 a3 eb		    ld (seed2),hl 
8c1b 09			    add hl,bc 
8c1c c9			    ret 
8c1d			 
8c1d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1d			 
8c1d			rand32: 
8c1d			;Inputs: 
8c1d			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1d			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1d			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1d			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1d			;   **NOTE: seed2 must be non-zero 
8c1d			;Outputs: 
8c1d			;   HL is the result 
8c1d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1d			;Destroys: 
8c1d			;   AF 
8c1d			;Tested and passes all CAcert tests 
8c1d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1d			;it has a period of 18,446,744,069,414,584,320 
8c1d			;roughly 18.4 quintillion. 
8c1d			;LFSR taps: 0,2,6,7  = 11000101 
8c1d			;291cc 
8c1d			;seed1_0=$+1 
8c1d			;    ld hl,12345 
8c1d			;seed1_1=$+1 
8c1d			;    ld de,6789 
8c1d			;    ld b,h 
8c1d			;    ld c,l 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    inc l 
8c1d			;    add hl,bc 
8c1d			;    ld (seed1_0),hl 
8c1d			;    ld hl,(seed1_1) 
8c1d			;    adc hl,de 
8c1d			;    ld (seed1_1),hl 
8c1d			;    ex de,hl 
8c1d			;seed2_0=$+1 
8c1d			;    ld hl,9876 
8c1d			;seed2_1=$+1 
8c1d			;    ld bc,54321 
8c1d			;    add hl,hl \ rl c \ rl b 
8c1d			;    ld (seed2_1),bc 
8c1d			;    sbc a,a 
8c1d			;    and %11000101 
8c1d			;    xor l 
8c1d			;    ld l,a 
8c1d			;    ld (seed2_0),hl 
8c1d			;    ex de,hl 
8c1d			;    add hl,bc 
8c1d			;    ret 
8c1d			; 
8c1d			 
8c1d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1d			; 20 bytes, 86 cycles (excluding ret) 
8c1d			 
8c1d			; returns   hl = pseudorandom number 
8c1d			; corrupts   a 
8c1d			 
8c1d			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1d			; using the xorshift method: 
8c1d			 
8c1d			; hl ^= hl << 7 
8c1d			; hl ^= hl >> 9 
8c1d			; hl ^= hl << 8 
8c1d			 
8c1d			; some alternative shift triplets which also perform well are: 
8c1d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1d			 
8c1d			;  org 32768 
8c1d			 
8c1d			xrnd: 
8c1d 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c20 3e 00		  ld a,0 
8c22 bd			  cp l 
8c23 20 02		  jr nz, .xrnd1 
8c25 2e 01		  ld l, 1 
8c27			.xrnd1: 
8c27			 
8c27 7c			  ld a,h 
8c28 1f			  rra 
8c29 7d			  ld a,l 
8c2a 1f			  rra 
8c2b ac			  xor h 
8c2c 67			  ld h,a 
8c2d 7d			  ld a,l 
8c2e 1f			  rra 
8c2f 7c			  ld a,h 
8c30 1f			  rra 
8c31 ad			  xor l 
8c32 6f			  ld l,a 
8c33 ac			  xor h 
8c34 67			  ld h,a 
8c35			 
8c35 22 a9 eb		  ld (xrandc),hl 
8c38			 
8c38 c9			  ret 
8c39			;  
8c39			 
8c39			 
8c39			;;;; int maths 
8c39			 
8c39			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c39			; Divide 16-bit values (with 16-bit result) 
8c39			; In: Divide BC by divider DE 
8c39			; Out: BC = result, HL = rest 
8c39			; 
8c39			Div16: 
8c39 21 00 00		    ld hl,0 
8c3c 78			    ld a,b 
8c3d 06 08		    ld b,8 
8c3f			Div16_Loop1: 
8c3f 17			    rla 
8c40 ed 6a		    adc hl,hl 
8c42 ed 52		    sbc hl,de 
8c44 30 01		    jr nc,Div16_NoAdd1 
8c46 19			    add hl,de 
8c47			Div16_NoAdd1: 
8c47 10 f6		    djnz Div16_Loop1 
8c49 17			    rla 
8c4a 2f			    cpl 
8c4b 47			    ld b,a 
8c4c 79			    ld a,c 
8c4d 48			    ld c,b 
8c4e 06 08		    ld b,8 
8c50			Div16_Loop2: 
8c50 17			    rla 
8c51 ed 6a		    adc hl,hl 
8c53 ed 52		    sbc hl,de 
8c55 30 01		    jr nc,Div16_NoAdd2 
8c57 19			    add hl,de 
8c58			Div16_NoAdd2: 
8c58 10 f6		    djnz Div16_Loop2 
8c5a 17			    rla 
8c5b 2f			    cpl 
8c5c 41			    ld b,c 
8c5d 4f			    ld c,a 
8c5e c9			ret 
8c5f			 
8c5f			 
8c5f			;http://z80-heaven.wikidot.com/math 
8c5f			; 
8c5f			;Inputs: 
8c5f			;     DE and A are factors 
8c5f			;Outputs: 
8c5f			;     A is not changed 
8c5f			;     B is 0 
8c5f			;     C is not changed 
8c5f			;     DE is not changed 
8c5f			;     HL is the product 
8c5f			;Time: 
8c5f			;     342+6x 
8c5f			; 
8c5f			Mult16: 
8c5f			 
8c5f 06 08		     ld b,8          ;7           7 
8c61 21 00 00		     ld hl,0         ;10         10 
8c64 29			       add hl,hl     ;11*8       88 
8c65 07			       rlca          ;4*8        32 
8c66 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c68 19			         add hl,de   ;--         -- 
8c69 10 f9		       djnz $-5      ;13*7+8     99 
8c6b c9			ret 
8c6c			 
8c6c			; 
8c6c			; Square root of 16-bit value 
8c6c			; In:  HL = value 
8c6c			; Out:  D = result (rounded down) 
8c6c			; 
8c6c			;Sqr16: 
8c6c			;    ld de,#0040 
8c6c			;    ld a,l 
8c6c			;    ld l,h 
8c6c			;    ld h,d 
8c6c			;    or a 
8c6c			;    ld b,8 
8c6c			;Sqr16_Loop: 
8c6c			;    sbc hl,de 
8c6c			;    jr nc,Sqr16_Skip 
8c6c			;    add hl,de 
8c6c			;Sqr16_Skip: 
8c6c			;    ccf 
8c6c			;    rl d 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    djnz Sqr16_Loop 
8c6c			;    ret 
8c6c			; 
8c6c			; 
8c6c			; Divide 8-bit values 
8c6c			; In: Divide E by divider C 
8c6c			; Out: A = result, B = rest 
8c6c			; 
8c6c			Div8: 
8c6c af			    xor a 
8c6d 06 08		    ld b,8 
8c6f			Div8_Loop: 
8c6f cb 13		    rl e 
8c71 17			    rla 
8c72 91			    sub c 
8c73 30 01		    jr nc,Div8_NoAdd 
8c75 81			    add a,c 
8c76			Div8_NoAdd: 
8c76 10 f7		    djnz Div8_Loop 
8c78 47			    ld b,a 
8c79 7b			    ld a,e 
8c7a 17			    rla 
8c7b 2f			    cpl 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7d			; In: Multiply A with DE 
8c7d			; Out: HL = result 
8c7d			; 
8c7d			Mult12U: 
8c7d 2e 00		    ld l,0 
8c7f 87			    add a,a 
8c80 30 01		    jr nc,Mult12U_NoAdd0 
8c82 19			    add hl,de 
8c83			Mult12U_NoAdd0: 
8c83 29			    add hl,hl 
8c84 87			    add a,a 
8c85 30 01		    jr nc,Mult12U_NoAdd1 
8c87 19			    add hl,de 
8c88			Mult12U_NoAdd1: 
8c88 29			    add hl,hl 
8c89 87			    add a,a 
8c8a 30 01		    jr nc,Mult12U_NoAdd2 
8c8c 19			    add hl,de 
8c8d			Mult12U_NoAdd2: 
8c8d 29			    add hl,hl 
8c8e 87			    add a,a 
8c8f 30 01		    jr nc,Mult12U_NoAdd3 
8c91 19			    add hl,de 
8c92			Mult12U_NoAdd3: 
8c92 29			    add hl,hl 
8c93 87			    add a,a 
8c94 30 01		    jr nc,Mult12U_NoAdd4 
8c96 19			    add hl,de 
8c97			Mult12U_NoAdd4: 
8c97 29			    add hl,hl 
8c98 87			    add a,a 
8c99 30 01		    jr nc,Mult12U_NoAdd5 
8c9b 19			    add hl,de 
8c9c			Mult12U_NoAdd5: 
8c9c 29			    add hl,hl 
8c9d 87			    add a,a 
8c9e 30 01		    jr nc,Mult12U_NoAdd6 
8ca0 19			    add hl,de 
8ca1			Mult12U_NoAdd6: 
8ca1 29			    add hl,hl 
8ca2 87			    add a,a 
8ca3 d0			    ret nc 
8ca4 19			    add hl,de 
8ca5 c9			    ret 
8ca6			 
8ca6			; 
8ca6			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca6			; In: Multiply A with DE 
8ca6			;      Put lowest value in A for most efficient calculation 
8ca6			; Out: HL = result 
8ca6			; 
8ca6			Mult12R: 
8ca6 21 00 00		    ld hl,0 
8ca9			Mult12R_Loop: 
8ca9 cb 3f		    srl a 
8cab 30 01		    jr nc,Mult12R_NoAdd 
8cad 19			    add hl,de 
8cae			Mult12R_NoAdd: 
8cae cb 23		    sla e 
8cb0 cb 12		    rl d 
8cb2 b7			    or a 
8cb3 c2 a9 8c		    jp nz,Mult12R_Loop 
8cb6 c9			    ret 
8cb7			 
8cb7			; 
8cb7			; Multiply 16-bit values (with 32-bit result) 
8cb7			; In: Multiply BC with DE 
8cb7			; Out: BCHL = result 
8cb7			; 
8cb7			Mult32: 
8cb7 79			    ld a,c 
8cb8 48			    ld c,b 
8cb9 21 00 00		    ld hl,0 
8cbc 06 10		    ld b,16 
8cbe			Mult32_Loop: 
8cbe 29			    add hl,hl 
8cbf 17			    rla 
8cc0 cb 11		    rl c 
8cc2 30 07		    jr nc,Mult32_NoAdd 
8cc4 19			    add hl,de 
8cc5 ce 00		    adc a,0 
8cc7 d2 cb 8c		    jp nc,Mult32_NoAdd 
8cca 0c			    inc c 
8ccb			Mult32_NoAdd: 
8ccb 10 f1		    djnz Mult32_Loop 
8ccd 41			    ld b,c 
8cce 4f			    ld c,a 
8ccf c9			    ret 
8cd0			 
8cd0			 
8cd0			 
8cd0			; 
8cd0			; Multiply 8-bit values 
8cd0			; In:  Multiply H with E 
8cd0			; Out: HL = result 
8cd0			; 
8cd0			Mult8: 
8cd0 16 00		    ld d,0 
8cd2 6a			    ld l,d 
8cd3 06 08		    ld b,8 
8cd5			Mult8_Loop: 
8cd5 29			    add hl,hl 
8cd6 30 01		    jr nc,Mult8_NoAdd 
8cd8 19			    add hl,de 
8cd9			Mult8_NoAdd: 
8cd9 10 fa		    djnz Mult8_Loop 
8cdb c9			    ret 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			;;http://z80-heaven.wikidot.com/math 
8cdc			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdc			; 
8cdc			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdc			;     ld a,16        ;7 
8cdc			;     ld hl,0        ;10 
8cdc			;     jp $+5         ;10 
8cdc			;.DivLoop: 
8cdc			;       add hl,bc    ;-- 
8cdc			;       dec a        ;64 
8cdc			;       jr z,.DivLoopEnd        ;86 
8cdc			; 
8cdc			;       sla e        ;128 
8cdc			;       rl d         ;128 
8cdc			;       adc hl,hl    ;240 
8cdc			;       sbc hl,bc    ;240 
8cdc			;       jr nc,.DivLoop ;23|21 
8cdc			;       inc e        ;-- 
8cdc			;       jp .DivLoop+1 
8cdc			; 
8cdc			;.DivLoopEnd: 
8cdc			 
8cdc			;HL_Div_C: 
8cdc			;Inputs: 
8cdc			;     HL is the numerator 
8cdc			;     C is the denominator 
8cdc			;Outputs: 
8cdc			;     A is the remainder 
8cdc			;     B is 0 
8cdc			;     C is not changed 
8cdc			;     DE is not changed 
8cdc			;     HL is the quotient 
8cdc			; 
8cdc			;       ld b,16 
8cdc			;       xor a 
8cdc			;         add hl,hl 
8cdc			;         rla 
8cdc			;         cp c 
8cdc			;         jr c,$+4 
8cdc			;           inc l 
8cdc			;           sub c 
8cdc			;         djnz $-7 
8cdc			 
8cdc			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdc			 
8cdc			addatohl: 
8cdc 85			    add   a, l    ; A = A+L 
8cdd 6f			    ld    l, a    ; L = A+L 
8cde 8c			    adc   a, h    ; A = A+L+H+carry 
8cdf 95			    sub   l       ; A = H+carry 
8ce0 67			    ld    h, a    ; H = H+carry 
8ce1 c9			ret 
8ce2			 
8ce2			addatode: 
8ce2 83			    add   a, e    ; A = A+L 
8ce3 5f			    ld    e, a    ; L = A+L 
8ce4 8a			    adc   a, d    ; A = A+L+H+carry 
8ce5 93			    sub   e       ; A = H+carry 
8ce6 57			    ld    d, a    ; H = H+carry 
8ce7 c9			ret 
8ce8			 
8ce8			 
8ce8			addatobc: 
8ce8 81			    add   a, c    ; A = A+L 
8ce9 4f			    ld    c, a    ; L = A+L 
8cea 88			    adc   a, b    ; A = A+L+H+carry 
8ceb 91			    sub   c       ; A = H+carry 
8cec 47			    ld    b, a    ; H = H+carry 
8ced c9			ret 
8cee			 
8cee			subafromhl: 
8cee			   ; If A=0 do nothing 
8cee			    ; Otherwise flip A's sign. Since 
8cee			    ; the upper byte becomes -1, also 
8cee			    ; substract 1 from H. 
8cee ed 44		    neg 
8cf0 ca f9 8c		    jp    z, Skip 
8cf3 25			    dec   h 
8cf4			     
8cf4			    ; Now add the low byte as usual 
8cf4			    ; Two's complement takes care of 
8cf4			    ; ensuring the result is correct 
8cf4 85			    add   a, l 
8cf5 6f			    ld    l, a 
8cf6 8c			    adc   a, h 
8cf7 95			    sub   l 
8cf8 67			    ld    h, a 
8cf9			Skip: 
8cf9 c9				ret 
8cfa			 
8cfa			 
8cfa			; compare hl and de 
8cfa			; returns:  
8cfa			; if hl = de, z=1, s=0, c0=0 
8cfa			; if hl > de, z=0, s=0, c=0 
8cfa			; if hl < de, z=0, s=1, c=1 
8cfa			cmp16:	 
8cfa b7				or a 
8cfb ed 52			sbc hl,de 
8cfd e0				ret po 
8cfe 7c				ld a,h 
8cff 1f				rra 
8d00 ee 40			xor 01000000B 
8d02 37				scf 
8d03 8f				adc a,a 
8d04 c9				ret 
8d05			 
8d05			 
8d05			; test if hl contains zero   - A is destroyed 
8d05			 
8d05			ishlzero:    
8d05 b7				or a     ; reset flags 
8d06 7c				ld a, h 
8d07 b5				or l        	 
8d08			 
8d08 c9				ret 
8d09			 
8d09			 
8d09			 
8d09			 
8d09			if FORTH_ENABLE_FLOATMATH 
8d09			;include "float/bbcmath.z80" 
8d09			include "float/lpfpcalc.asm" 
8d09			endif 
8d09			 
8d09			 
8d09			; eof 
8d09			 
# End of file firmware_maths.asm
8d09			include "firmware_strings.asm"   ; string handling  
8d09			 
8d09			 
8d09			; TODO string len 
8d09			; input text string, end on cr with zero term 
8d09			; a offset into frame buffer to start prompt 
8d09			; d is max length 
8d09			; e is display size TODO 
8d09			; c is current cursor position 
8d09			; hl is ptr to where string will be stored 
8d09			 
8d09			 
8d09			; TODO check limit of buffer for new inserts 
8d09			; TODO check insert does not push beyond buffer 
8d09			; TODO scroll in a limited display area 
8d09			; TODO scroll whole screen on page wrap 
8d09			 
8d09			 
8d09			; TODO handle KEY_PREVWORD 
8d09			; TODO handle KEY_NEXTWORD 
8d09			; TODO handle KEY_HOME 
8d09			; TODO handle KEY_END 
8d09			; TODO use LCD cursor? 
8d09			 
8d09 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8d0c 81					add c 
8d0d 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8d10 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d13 79					ld a, c 
8d14 cd dc 8c				call addatohl 
8d17 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1a 7a					ld a,d 
8d1b 32 66 ee			        ld (input_size), a       ; save length of input area 
8d1e 79					ld a, c 
8d1f 32 55 ee				ld (input_cursor),a      ; init cursor start position  
8d22 7b					ld a,e 
8d23 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d26					 
8d26					 
8d26			 
8d26			;		ld a,(input_ptr) 
8d26			;		ld (input_under_cursor),a 	; save what is under the cursor 
8d26			 
8d26			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d26					; init cursor shape if not set by the cin routines 
8d26 21 c1 eb				ld hl, cursor_shape 
8d29 3e ff				ld a, 255 
8d2b 77					ld (hl), a 
8d2c 23					inc hl 
8d2d 3e 00				ld a, 0 
8d2f 77					ld (hl), a 
8d30			 
8d30 3e 0f				ld a, CUR_BLINK_RATE 
8d32 32 60 ee				ld (input_cur_flash), a 
8d35 3e 01				ld a, 1 
8d37 32 5f ee				ld (input_cur_onoff),a 
8d3a			 
8d3a			;	if DEBUG_INPUT 
8d3a			;		push af 
8d3a			;		ld a, 'I' 
8d3a			;		ld (debug_mark),a 
8d3a			;		pop af 
8d3a			;		CALLMONITOR 
8d3a			;	endif 
8d3a			.is1:		; main entry loop 
8d3a			 
8d3a			 
8d3a			 
8d3a					; pause 1ms 
8d3a			 
8d3a 3e 01				ld a, 1 
8d3c cd d7 89				call aDelayInMS 
8d3f			 
8d3f					; dec flash counter 
8d3f 3a 60 ee				ld a, (input_cur_flash) 
8d42 3d					dec a 
8d43 32 60 ee				ld (input_cur_flash), a 
8d46 fe 00				cp 0 
8d48 20 0d				jr nz, .nochgstate 
8d4a			 
8d4a			 
8d4a					; change state 
8d4a 3a 5f ee				ld a,(input_cur_onoff) 
8d4d ed 44				neg 
8d4f 32 5f ee				ld (input_cur_onoff),a 
8d52			 
8d52			 
8d52					; reset on change of state 
8d52 3e 0f				ld a, CUR_BLINK_RATE 
8d54 32 60 ee				ld (input_cur_flash), a 
8d57			 
8d57			.nochgstate: 
8d57					 
8d57					 
8d57			 
8d57					; display cursor  
8d57			 
8d57			;		ld hl, (input_start) 
8d57			;		ld a, (input_cursor) 
8d57			;		call addatohl 
8d57			 
8d57					; get char under cursor and replace with cursor 
8d57 2a 69 ee		ld hl, (input_ptr) 
8d5a			;		ld a, (hl) 
8d5a			;		ld (input_under_cursor),a 
8d5a			;		ld a, '_' 
8d5a			;		ld (hl), a 
8d5a			 
8d5a					; display string 
8d5a			 
8d5a ed 5b 67 ee			ld de, (input_start) 
8d5e 3a 64 ee				ld a, (input_at_pos) 
8d61 cd c2 8a				call str_at_display 
8d64			;	        call update_display 
8d64			 
8d64					; find place to put the cursor 
8d64			;		add h 
8d64			;		ld l, display_row_1 
8d64			;		sub l 
8d64			; (input_at_pos) 
8d64					;ld c, a 
8d64			;		ld a, (input_cursor) 
8d64			;		ld l, (input_at_pos) 
8d64			;		;ld b, h 
8d64			;		add l 
8d64			;		ld (input_at_cursor),a 
8d64					;ld l,h 
8d64			 
8d64			;		ld h, 0 
8d64			;		ld l,(input_at_pos) 
8d64			;		ld a, (input_cursor) 
8d64			;		call addatohl 
8d64			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d64			;		call subafromhl 
8d64			;		ld a,l 
8d64			;		ld (input_at_cursor), a 
8d64			 
8d64				if DEBUG_INPUT 
8d64					ld a, (hardware_diag) 
8d64					cp 0 
8d64					jr z, .skip_input_diag 
8d64			 
8d64					ld a,(input_at_pos) 
8d64					ld hl, LFSRSeed 
8d64					call hexout 
8d64					ld a, (input_cursor) 
8d64					ld hl, LFSRSeed+2 
8d64					call hexout 
8d64					ld a,(input_at_cursor) 
8d64					ld hl, LFSRSeed+4 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_onoff) 
8d64					ld hl, LFSRSeed+6 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_flash) 
8d64					ld hl, LFSRSeed+8 
8d64					call hexout 
8d64			 
8d64					ld a,(input_len) 
8d64					ld hl, LFSRSeed+10 
8d64					call hexout 
8d64					ld hl, LFSRSeed+12 
8d64					ld a, 0 
8d64					ld (hl),a 
8d64					ld a, display_row_4 
8d64					ld de, LFSRSeed 
8d64					call str_at_display 
8d64					.skip_input_diag: 
8d64				endif 
8d64			 
8d64					; decide on if we are showing the cursor this time round 
8d64			 
8d64 3a 5f ee				ld a, (input_cur_onoff) 
8d67 fe ff				cp 255 
8d69 28 13				jr z, .skipcur 
8d6b			 
8d6b			 
8d6b 3a 62 ee				ld a,(input_at_cursor) 
8d6e 11 c1 eb				ld de, cursor_shape 
8d71 cd c2 8a				call str_at_display 
8d74			 
8d74					; save length of current input string 
8d74 2a 67 ee				ld hl, (input_start) 
8d77 cd 3a 91				call strlenz 
8d7a 7d					ld a,l 
8d7b 32 5a ee				ld (input_len),a 
8d7e			 
8d7e			.skipcur: 
8d7e			 
8d7e cd d2 8a			        call update_display 
8d81					 
8d81			 
8d81			 
8d81					; wait 
8d81				 
8d81					; TODO loop without wait to flash the cursor and char under cursor	 
8d81 cd ce e3				call cin    ; _wait 
8d84			 
8d84 fe 00				cp 0 
8d86 ca 3a 8d				jp z, .is1 
8d89			 
8d89					; get ptr to char to input into 
8d89			 
8d89 4f					ld c,a 
8d8a 2a 67 ee				ld hl, (input_start) 
8d8d 3a 55 ee				ld a, (input_cursor) 
8d90 cd dc 8c				call addatohl 
8d93 22 69 ee				ld (input_ptr), hl 
8d96 79					ld a,c 
8d97			 
8d97					; replace char under cursor 
8d97			 
8d97			;		ld hl, (input_ptr) 
8d97			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d97			;		ld (hl), a 
8d97			 
8d97			;	if DEBUG_INPUT 
8d97			;		push af 
8d97			;		ld a, 'i' 
8d97			;		ld (debug_mark),a 
8d97			;		pop af 
8d97			;		CALLMONITOR 
8d97			;	endif 
8d97 fe 0e				cp KEY_HOME 
8d99 20 0e				jr nz, .iske 
8d9b			 
8d9b 3a 64 ee				ld a, (input_at_pos) 
8d9e 32 62 ee				ld (input_at_cursor),a 
8da1 3e 00				ld a, 0 
8da3 32 55 ee				ld (input_cursor), a 
8da6 c3 3a 8d				jp .is1 
8da9					 
8da9 fe 0f		.iske:		cp KEY_END 
8dab 20 03				jr nz, .isknw 
8dad c3 3a 8d				jp .is1 
8db0			 
8db0 fe 06		.isknw:		cp KEY_NEXTWORD 
8db2 20 1b				jr nz, .iskpw 
8db4			 
8db4 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
8db7 7e					ld a,(hl)	 
8db8 fe 00				cp 0 
8dba ca 3a 8d				jp z, .is1    ; end of string 
8dbd fe 20				cp ' ' 
8dbf ca 3a 8d				jp z, .is1    ; end of word 
8dc2 23					inc hl 
8dc3 22 69 ee				ld (input_ptr), hl 
8dc6 3a 62 ee				ld a, (input_at_cursor) 
8dc9 3c					inc a 
8dca 32 62 ee				ld (input_at_cursor), a 
8dcd 18 e5				jr .isknwm 
8dcf			 
8dcf fe 07		.iskpw:		cp KEY_PREVWORD 
8dd1 20 1b				jr nz, .iskl 
8dd3			.iskpwm:	 
8dd3 2a 69 ee				ld hl, (input_ptr) 
8dd6 7e					ld a,(hl)	 
8dd7 fe 00				cp 0  
8dd9 ca 3a 8d				jp z, .is1    ; end of string 
8ddc fe 20				cp ' ' 
8dde ca 3a 8d				jp z, .is1    ; end of word 
8de1 2b					dec hl 
8de2 22 69 ee				ld (input_ptr), hl 
8de5 3a 62 ee				ld a, (input_at_cursor) 
8de8 3d					dec a 
8de9 32 62 ee				ld (input_at_cursor), a 
8dec 18 e5				jr .iskpwm 
8dee			 
8dee			 
8dee fe 0b		.iskl:		cp KEY_LEFT 
8df0 20 27				jr nz, .isk1 
8df2			 
8df2 3a 55 ee				ld a, (input_cursor) 
8df5			 
8df5 fe 00				cp 0 
8df7 ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8dfa			 
8dfa 3d					dec  a 		; TODO check underflow 
8dfb 32 55 ee				ld (input_cursor), a 
8dfe			 
8dfe 2a 69 ee				ld hl, (input_ptr) 
8e01 2b					dec hl 
8e02 22 69 ee				ld (input_ptr), hl 
8e05					 
8e05 3a 62 ee				ld a, (input_at_cursor) 
8e08 3d					dec a 
8e09 32 62 ee				ld (input_at_cursor), a 
8e0c			 
8e0c 3e 01				ld a, 1		; show cursor moving 
8e0e 32 5f ee				ld (input_cur_onoff),a 
8e11 3e 0f				ld a, CUR_BLINK_RATE 
8e13 32 60 ee				ld (input_cur_flash), a 
8e16			 
8e16 c3 3a 8d				jp .is1 
8e19			 
8e19 fe 0c		.isk1:		cp KEY_RIGHT 
8e1b 20 2a				jr nz, .isk2 
8e1d			 
8e1d 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8e20 5f					ld e,a 
8e21 3a 55 ee				ld a, (input_cursor) 
8e24 bb					cp e 
8e25 ca 3a 8d				jp z, .is1		; at the end of string so dont go right 
8e28			 
8e28 3c					inc  a 		; TODO check overflow 
8e29 32 55 ee				ld (input_cursor), a 
8e2c			 
8e2c 3a 62 ee				ld a, (input_at_cursor) 
8e2f 3c					inc a 
8e30 32 62 ee				ld (input_at_cursor), a 
8e33			 
8e33 2a 69 ee				ld hl, (input_ptr) 
8e36 23					inc hl 
8e37 22 69 ee				ld (input_ptr), hl 
8e3a			 
8e3a 3e 01				ld a, 1		; show cursor moving 
8e3c 32 5f ee				ld (input_cur_onoff),a 
8e3f 3e 0f				ld a, CUR_BLINK_RATE 
8e41 32 60 ee				ld (input_cur_flash), a 
8e44			 
8e44 c3 3a 8d				jp .is1 
8e47			 
8e47 fe 05		.isk2:		cp KEY_UP 
8e49			 
8e49 20 26				jr nz, .isk3 
8e4b			 
8e4b					; swap last command with the current on 
8e4b			 
8e4b					; move cursor to start of string 
8e4b 2a 67 ee				ld hl, (input_start) 
8e4e 22 69 ee				ld (input_ptr), hl 
8e51			 
8e51 3a 64 ee				ld a, (input_at_pos) 
8e54 32 62 ee				ld (input_at_cursor), a 
8e57			 
8e57 3e 00				ld a, 0 
8e59 32 55 ee				ld (input_cursor), a 
8e5c					 
8e5c					; swap input and last command buffers 
8e5c			 
8e5c 21 e8 e5				ld hl, os_cli_cmd 
8e5f 11 e7 e6				ld de, os_last_cmd 
8e62 06 ff				ld b, 255 
8e64 7e			.swap1:		ld a, (hl) 
8e65 4f					ld c,a 
8e66 1a					ld a, (de) 
8e67 77					ld (hl), a 
8e68 79					ld a,c 
8e69 12					ld (de),a 
8e6a 23					inc hl 
8e6b 13					inc de 
8e6c 10 f6				djnz .swap1 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e c3 3a 8d				jp .is1 
8e71			 
8e71 fe 08		.isk3:		cp KEY_BS 
8e73 20 3c				jr nz, .isk4 
8e75			 
8e75 3a 55 ee				ld a, (input_cursor) 
8e78			 
8e78 fe 00				cp 0 
8e7a ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8e7d			 
8e7d 3d					dec  a 		; TODO check underflow 
8e7e 32 55 ee				ld (input_cursor), a 
8e81			 
8e81					; hl is source 
8e81					; de needs to be source - 1 
8e81			 
8e81			;		ld a, 0 
8e81			;		dec hl 
8e81			;		ld (hl), a 
8e81			 
8e81 2a 69 ee				ld hl, (input_ptr) 
8e84 2b					dec hl 
8e85 22 69 ee				ld (input_ptr), hl 
8e88			 
8e88					; shift all data 
8e88			 
8e88 e5					push hl 
8e89 23					inc hl 
8e8a d1					pop de 
8e8b 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e8e 4f					ld c,a 
8e8f 06 00				ld b,0 
8e91 ed b0				ldir  
8e93			 
8e93			 
8e93			 
8e93			 
8e93 3a 62 ee				ld a, (input_at_cursor) 
8e96 3d					dec a 
8e97 32 62 ee				ld (input_at_cursor), a 
8e9a			 
8e9a			 
8e9a 3e 01				ld a, 1		; show cursor moving 
8e9c 32 5f ee				ld (input_cur_onoff),a 
8e9f 3e 0f				ld a, CUR_BLINK_RATE 
8ea1 32 60 ee				ld (input_cur_flash), a 
8ea4			 
8ea4					; remove char 
8ea4 3a 62 ee				ld a, (input_at_cursor) 
8ea7 3c					inc a 
8ea8 11 32 8f				ld de,.iblank 
8eab cd c2 8a				call str_at_display 
8eae			 
8eae c3 3a 8d				jp .is1 
8eb1			 
8eb1 fe 0d		.isk4:		cp KEY_CR 
8eb3 28 6c				jr z, .endinput 
8eb5			 
8eb5					; else add the key press to the end 
8eb5			 
8eb5 4f					ld c, a			; save key pressed 
8eb6			 
8eb6 7e					ld a,(hl)		; get what is currently under char 
8eb7			 
8eb7 fe 00				cp 0			; we are at the end of the string 
8eb9 20 2f				jr nz, .onchar 
8ebb					 
8ebb					; add a char to the end of the string 
8ebb				 
8ebb 71					ld (hl),c 
8ebc 23					inc hl 
8ebd			;		ld a,' ' 
8ebd			;		ld (hl),a 
8ebd			;		inc hl 
8ebd 3e 00				ld a,0 
8ebf 77					ld (hl),a 
8ec0 2b					dec hl 
8ec1			 
8ec1 3a 55 ee				ld a, (input_cursor) 
8ec4 3c					inc a				; TODO check max string length and scroll  
8ec5 32 55 ee				ld (input_cursor), a		; inc cursor pos 
8ec8							 
8ec8 3a 62 ee				ld a, (input_at_cursor) 
8ecb 3c					inc a 
8ecc 32 62 ee				ld (input_at_cursor), a 
8ecf			 
8ecf 2a 69 ee				ld hl, (input_ptr) 
8ed2 23					inc hl 
8ed3 22 69 ee				ld (input_ptr), hl 
8ed6			 
8ed6 2a 69 ee				ld hl, (input_ptr) 
8ed9 23					inc hl 
8eda 22 69 ee				ld (input_ptr), hl 
8edd			;	if DEBUG_INPUT 
8edd			;		push af 
8edd			;		ld a, '+' 
8edd			;		ld (debug_mark),a 
8edd			;		pop af 
8edd			;		CALLMONITOR 
8edd			;	endif 
8edd 3e 01				ld a, 1		; show cursor moving 
8edf 32 5f ee				ld (input_cur_onoff),a 
8ee2 3e 0f				ld a, CUR_BLINK_RATE 
8ee4 32 60 ee				ld (input_cur_flash), a 
8ee7 c3 3a 8d				jp .is1 
8eea					 
8eea			 
8eea			 
8eea					; if on a char then insert 
8eea			.onchar: 
8eea			 
8eea					; TODO over flow check: make sure insert does not blow out buffer 
8eea			 
8eea					; need to do some maths to use lddr 
8eea			 
8eea e5					push hl   ; save char pos 
8eeb c5					push bc 
8eec			 
8eec 2a 67 ee				ld hl, (input_start) 
8eef 3a 5a ee				ld a, (input_len) 
8ef2 cd dc 8c				call addatohl  		; end of string 
8ef5 23					inc hl 
8ef6 23					inc hl		; past zero term 
8ef7 e5					push hl 
8ef8 23					inc hl 
8ef9 e5					push hl  
8efa			 
8efa								; start and end of lddr set, now how much to move? 
8efa			 
8efa							 
8efa 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8efd 47					ld b,a 
8efe 3a 5a ee				ld a,(input_len) 
8f01 5f					ld e,a 
8f02 90					sub b 
8f03 3c					inc a		;?? 
8f04 3c					inc a		;?? 
8f05 3c					inc a		;?? 
8f06			 
8f06 06 00				ld b,0 
8f08 4f					ld c,a 
8f09			 
8f09				if DEBUG_INPUT 
8f09					push af 
8f09					ld a, 'i' 
8f09					ld (debug_mark),a 
8f09					pop af 
8f09			;		CALLMONITOR 
8f09				endif 
8f09 d1					pop de 
8f0a e1					pop hl 
8f0b				if DEBUG_INPUT 
8f0b					push af 
8f0b					ld a, 'I' 
8f0b					ld (debug_mark),a 
8f0b					pop af 
8f0b			;		CALLMONITOR 
8f0b				endif 
8f0b ed b8				lddr 
8f0d				 
8f0d			 
8f0d			 
8f0d					; TODO have a key for insert/overwrite mode???? 
8f0d c1					pop bc 
8f0e e1					pop hl 
8f0f 71					ld (hl), c		; otherwise overwrite current char 
8f10					 
8f10			 
8f10			 
8f10			 
8f10 3a 55 ee				ld a, (input_cursor) 
8f13 3c					inc  a 		; TODO check overflow 
8f14 32 55 ee				ld (input_cursor), a 
8f17			 
8f17 3a 62 ee				ld a, (input_at_cursor) 
8f1a 3c					inc a 
8f1b 32 62 ee				ld (input_at_cursor), a 
8f1e			 
8f1e c3 3a 8d				jp .is1 
8f21			 
8f21			.endinput:	; TODO look for end of string 
8f21			 
8f21					; add trailing space for end of token 
8f21			 
8f21 2a 67 ee				ld hl, (input_start) 
8f24 3a 5a ee				ld a,(input_len) 
8f27 cd dc 8c				call addatohl 
8f2a 3e 20				ld a, ' ' 
8f2c 77					ld (hl),a 
8f2d					; TODO eof of parse marker 
8f2d			 
8f2d 23					inc hl 
8f2e 3e 00				ld a, 0 
8f30 77					ld (hl),a 
8f31			 
8f31			 
8f31 c9					ret 
8f32			 
8f32 .. 00		.iblank: db " ",0 
8f34			 
8f34			 
8f34 32 64 ee		input_str_prev:	ld (input_at_pos), a 
8f37 22 67 ee				ld (input_start), hl 
8f3a 3e 01				ld a,1			; add cursor 
8f3c 77					ld (hl),a 
8f3d 23					inc hl 
8f3e 3e 00				ld a,0 
8f40 77					ld (hl),a 
8f41 22 69 ee				ld (input_ptr), hl 
8f44 7a					ld a,d 
8f45 32 66 ee				ld (input_size), a 
8f48 3e 00				ld a,0 
8f4a 32 55 ee				ld (input_cursor),a 
8f4d			.instr1:	 
8f4d			 
8f4d					; TODO do block cursor 
8f4d					; TODO switch cursor depending on the modifer key 
8f4d			 
8f4d					; update cursor shape change on key hold 
8f4d			 
8f4d 2a 69 ee				ld hl, (input_ptr) 
8f50 2b					dec hl 
8f51 3a c1 eb				ld a,(cursor_shape) 
8f54 77					ld (hl), a 
8f55			 
8f55					; display entered text 
8f55 3a 64 ee				ld a,(input_at_pos) 
8f58 cd 2c e3		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f5b ed 5b 67 ee	            	LD   de, (input_start) 
8f5f cd 26 e3		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f62			 
8f62 cd ce e3				call cin 
8f65 fe 00				cp 0 
8f67 28 e4				jr z, .instr1 
8f69			 
8f69					; proecess keyboard controls first 
8f69			 
8f69 2a 69 ee				ld hl,(input_ptr) 
8f6c			 
8f6c fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f6e 28 5a				jr z, .instrcr 
8f70			 
8f70 fe 08				cp KEY_BS 	; back space 
8f72 20 0f				jr nz, .instr2 
8f74					; process back space 
8f74			 
8f74					; TODO stop back space if at start of string 
8f74 2b					dec hl 
8f75 2b					dec hl ; to over write cursor 
8f76 3a c1 eb				ld a,(cursor_shape) 
8f79					;ld a,0 
8f79 77					ld (hl),a 
8f7a 23					inc hl 
8f7b 3e 20				ld a," " 
8f7d 77					ld (hl),a 
8f7e 22 69 ee				ld (input_ptr),hl 
8f81					 
8f81			 
8f81 18 ca				jr .instr1 
8f83			 
8f83 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f85 20 06				jr nz, .instr3 
8f87 2b					dec hl 
8f88 22 69 ee				ld (input_ptr),hl 
8f8b 18 c0				jr .instr1 
8f8d				 
8f8d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f8f 20 06				jr nz, .instr4 
8f91 23					inc hl 
8f92 22 69 ee				ld (input_ptr),hl 
8f95 18 b6				jr .instr1 
8f97			 
8f97 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f99 20 06				jr nz, .instr5 
8f9b 2b					dec hl 
8f9c 22 69 ee				ld (input_ptr),hl 
8f9f 18 ac				jr .instr1 
8fa1			 
8fa1 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8fa3 20 06				jr nz, .instr6 
8fa5 2b					dec hl 
8fa6 22 69 ee				ld (input_ptr),hl 
8fa9 18 a2				jr .instr1 
8fab fe 05		.instr6:        cp KEY_UP      ; recall last command 
8fad 20 0b				jr nz, .instrnew 
8faf			 
8faf 21 c1 e2			ld hl, scratch 
8fb2 11 e7 e6			ld de, os_last_cmd 
8fb5 cd d3 8f			call strcpy 
8fb8 18 93				jr .instr1 
8fba			 
8fba			 
8fba			.instrnew:	; no special key pressed to see if we have room to store it 
8fba			 
8fba					; TODO do string size test 
8fba			 
8fba 2b					dec hl ; to over write cursor 
8fbb 77					ld (hl),a 
8fbc 23					inc hl 
8fbd 3a c1 eb				ld a,(cursor_shape) 
8fc0 77					ld (hl),a 
8fc1 23					inc hl 
8fc2 3e 00				ld a,0 
8fc4 77					ld (hl),a 
8fc5			 
8fc5 22 69 ee				ld (input_ptr),hl 
8fc8					 
8fc8 18 83				jr .instr1 
8fca 2b			.instrcr:	dec hl		; remove cursor 
8fcb 3e 20				ld a,' '	; TODO add a trailing space for safety 
8fcd 77					ld (hl),a 
8fce 23					inc hl 
8fcf 3e 00				ld a,0 
8fd1 77					ld (hl),a 
8fd2			 
8fd2			 
8fd2					; if at end of line scroll up    
8fd2					; TODO detecting only end of line 4 for scroll up  
8fd2			 
8fd2					;ld   
8fd2			 
8fd2 c9					ret 
8fd3			 
8fd3			 
8fd3			; strcpy hl = dest, de source 
8fd3			 
8fd3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8fd4 b7			            OR   A              ;Null terminator? 
8fd5 c8			            RET  Z              ;Yes, so finished 
8fd6 1a					ld a,(de) 
8fd7 77					ld (hl),a 
8fd8 13			            INC  DE             ;Point to next character 
8fd9 23					inc hl 
8fda 18 f7		            JR   strcpy       ;Repeat 
8fdc c9					ret 
8fdd			 
8fdd			 
8fdd			; TODO string_at  
8fdd			; pass string which starts with lcd offset address and then null term string 
8fdd			 
8fdd			; TODO string to dec 
8fdd			; TODO string to hex 
8fdd			; TODO byte to string hex 
8fdd			; TODO byte to string dec 
8fdd			 
8fdd			 
8fdd			 
8fdd			; from z80uartmonitor 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fdd			; pass hl for where to put the text 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd c5			hexout:	PUSH BC 
8fde f5					PUSH AF 
8fdf 47					LD B, A 
8fe0					; Upper nybble 
8fe0 cb 3f				SRL A 
8fe2 cb 3f				SRL A 
8fe4 cb 3f				SRL A 
8fe6 cb 3f				SRL A 
8fe8 cd f8 8f				CALL tohex 
8feb 77					ld (hl),a 
8fec 23					inc hl	 
8fed					 
8fed					; Lower nybble 
8fed 78					LD A, B 
8fee e6 0f				AND 0FH 
8ff0 cd f8 8f				CALL tohex 
8ff3 77					ld (hl),a 
8ff4 23					inc hl	 
8ff5					 
8ff5 f1					POP AF 
8ff6 c1					POP BC 
8ff7 c9					RET 
8ff8					 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			tohex: 
8ff8 e5					PUSH HL 
8ff9 d5					PUSH DE 
8ffa 16 00				LD D, 0 
8ffc 5f					LD E, A 
8ffd 21 05 90				LD HL, .DATA 
9000 19					ADD HL, DE 
9001 7e					LD A, (HL) 
9002 d1					POP DE 
9003 e1					POP HL 
9004 c9					RET 
9005			 
9005			.DATA: 
9005 30					DEFB	30h	; 0 
9006 31					DEFB	31h	; 1 
9007 32					DEFB	32h	; 2 
9008 33					DEFB	33h	; 3 
9009 34					DEFB	34h	; 4 
900a 35					DEFB	35h	; 5 
900b 36					DEFB	36h	; 6 
900c 37					DEFB	37h	; 7 
900d 38					DEFB	38h	; 8 
900e 39					DEFB	39h	; 9 
900f 41					DEFB	41h	; A 
9010 42					DEFB	42h	; B 
9011 43					DEFB	43h	; C 
9012 44					DEFB	44h	; D 
9013 45					DEFB	45h	; E 
9014 46					DEFB	46h	; F 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9015			;;    subtract $30, if result > 9 then subtract $7 more 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			atohex: 
9015 d6 30				SUB $30 
9017 fe 0a				CP 10 
9019 f8					RET M		; If result negative it was 0-9 so we're done 
901a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
901c c9					RET		 
901d			 
901d			 
901d			 
901d			 
901d			; Get 2 ASCII characters as hex byte from pointer in hl 
901d			 
901d			BYTERD: 
901d 16 00			LD	D,00h		;Set up 
901f cd 27 90			CALL	HEXCON		;Get byte and convert to hex 
9022 87				ADD	A,A		;First nibble so 
9023 87				ADD	A,A		;multiply by 16 
9024 87				ADD	A,A		; 
9025 87				ADD	A,A		; 
9026 57				LD	D,A		;Save hi nibble in D 
9027			HEXCON: 
9027 7e				ld a, (hl)		;Get next chr 
9028 23				inc hl 
9029 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
902b fe 0a			CP	00Ah		;Is it 0-9 ? 
902d 38 02			JR	C,NALPHA	;If so miss next bit 
902f d6 07			SUB	007h		;Else convert alpha 
9031			NALPHA: 
9031 b2				OR	D		;Add hi nibble back 
9032 c9				RET			; 
9033			 
9033			 
9033			; 
9033			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9033			; Since the routines get_byte and therefore get_nibble are called, only valid 
9033			; characters (0-9a-f) are accepted. 
9033			; 
9033			;get_word        push    af 
9033			;                call    get_byte        ; Get the upper byte 
9033			;                ld      h, a 
9033			;                call    get_byte        ; Get the lower byte 
9033			;                ld      l, a 
9033			;                pop     af 
9033			;                ret 
9033			; 
9033			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9033			; the routine get_nibble is used only valid characters are accepted - the  
9033			; input routine only accepts characters 0-9a-f. 
9033			; 
9033 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9034 7e					ld a,(hl) 
9035 23					inc hl 
9036 cd 5b 90		                call    nibble2val      ; Get upper nibble 
9039 cb 07		                rlc     a 
903b cb 07		                rlc     a 
903d cb 07		                rlc     a 
903f cb 07		                rlc     a 
9041 47			                ld      b, a            ; Save upper four bits 
9042 7e					ld a,(hl) 
9043 cd 5b 90		                call    nibble2val      ; Get lower nibble 
9046 b0			                or      b               ; Combine both nibbles 
9047 c1			                pop     bc              ; Restore B (and C) 
9048 c9			                ret 
9049			; 
9049			; Get a hexadecimal digit from the serial line. This routine blocks until 
9049			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9049			; to the serial line interface. The lower 4 bits of A contain the value of  
9049			; that particular digit. 
9049			; 
9049			;get_nibble      ld a,(hl)           ; Read a character 
9049			;                call    to_upper        ; Convert to upper case 
9049			;                call    is_hex          ; Was it a hex digit? 
9049			;                jr      nc, get_nibble  ; No, get another character 
9049			 ;               call    nibble2val      ; Convert nibble to value 
9049			 ;               call    print_nibble 
9049			 ;               ret 
9049			; 
9049			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9049			; A valid hexadecimal digit is denoted by a set C flag. 
9049			; 
9049			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9049			;                ret     nc              ; Yes 
9049			;                cp      '0'             ; Less than '0'? 
9049			;                jr      nc, is_hex_1    ; No, continue 
9049			;                ccf                     ; Complement carry (i.e. clear it) 
9049			;                ret 
9049			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9049			;                ret     c               ; Yes 
9049			;                cp      'A'             ; Less than 'A'? 
9049			;                jr      nc, is_hex_2    ; No, continue 
9049			;                ccf                     ; Yes - clear carry and return 
9049			;                ret 
9049			;is_hex_2        scf                     ; Set carry 
9049			;                ret 
9049			; 
9049			; Convert a single character contained in A to upper case: 
9049			; 
9049 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
904b d8			                ret     c 
904c fe 7b		                cp      'z' + 1         ; > 'z'? 
904e d0			                ret     nc              ; Nothing to do, either 
904f e6 5f		                and     $5f             ; Convert to upper case 
9051 c9			                ret 
9052			 
9052			 
9052			to_lower: 
9052			 
9052			   ; if char is in [A-Z] make it lower case 
9052			 
9052			   ; enter : a = char 
9052			   ; exit  : a = lower case char 
9052			   ; uses  : af 
9052			 
9052 fe 41		   cp 'A' 
9054 d8			   ret c 
9055			    
9055 fe 5b		   cp 'Z'+1 
9057 d0			   ret nc 
9058			    
9058 f6 20		   or $20 
905a c9			   ret 
905b			 
905b			; 
905b			; Expects a hexadecimal digit (upper case!) in A and returns the 
905b			; corresponding value in A. 
905b			; 
905b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
905d 38 02		                jr      c, nibble2val_1 ; Yes 
905f d6 07		                sub     7               ; Adjust for A-F 
9061 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9063 e6 0f		                and     $f              ; Only return lower 4 bits 
9065 c9			                ret 
9066			; 
9066			; Print_nibble prints a single hex nibble which is contained in the lower  
9066			; four bits of A: 
9066			; 
9066			;print_nibble    push    af              ; We won't destroy the contents of A 
9066			;                and     $f              ; Just in case... 
9066			;                add     a, '0'             ; If we have a digit we are done here. 
9066			;                cp      '9' + 1         ; Is the result > 9? 
9066			;                jr      c, print_nibble_1 
9066			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9066			;print_nibble_1  call    putc            ; Print the nibble and 
9066			;                pop     af              ; restore the original value of A 
9066			;                ret 
9066			;; 
9066			;; Send a CR/LF pair: 
9066			; 
9066			;crlf            push    af 
9066			;                ld      a, cr 
9066			;                call    putc 
9066			;                ld      a, lf 
9066			;                call    putc 
9066			;                pop     af 
9066			;                ret 
9066			; 
9066			; Print_word prints the four hex digits of a word to the serial line. The  
9066			; word is expected to be in HL. 
9066			; 
9066			;print_word      push    hl 
9066			;                push    af 
9066			;                ld      a, h 
9066			;                call    print_byte 
9066			;                ld      a, l 
9066			;                call    print_byte 
9066			;                pop     af 
9066			;                pop     hl 
9066			;                ret 
9066			; 
9066			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9066			; The byte to be printed is expected to be in A. 
9066			; 
9066			;print_byte      push    af              ; Save the contents of the registers 
9066			;                push    bc 
9066			;                ld      b, a 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                call    print_nibble    ; Print high nibble 
9066			;                ld      a, b 
9066			;                call    print_nibble    ; Print low nibble 
9066			;                pop     bc              ; Restore original register contents 
9066			;                pop     af 
9066			;                ret 
9066			 
9066			 
9066			 
9066			 
9066			 
9066			fourehexhl:  
9066 7e				ld a,(hl) 
9067 cd 15 90			call atohex 
906a cb 3f				SRL A 
906c cb 3f				SRL A 
906e cb 3f				SRL A 
9070 cb 3f				SRL A 
9072 47				ld b, a 
9073 23				inc hl 
9074 7e				ld a,(hl) 
9075 23				inc hl 
9076 cd 15 90			call atohex 
9079 80				add b 
907a 57				ld d,a 
907b 7e				ld a,(hl) 
907c cd 15 90			call atohex 
907f cb 3f				SRL A 
9081 cb 3f				SRL A 
9083 cb 3f				SRL A 
9085 cb 3f				SRL A 
9087 47				ld b, a 
9088 23				inc hl 
9089 7e				ld a,(hl) 
908a 23				inc hl 
908b cd 15 90			call atohex 
908e 80				add b 
908f 5f				ld e, a 
9090 d5				push de 
9091 e1				pop hl 
9092 c9				ret 
9093			 
9093			; pass hl. returns z set if the byte at hl is a digit 
9093			;isdigithl:  
9093			;	push bc 
9093			;	ld a,(hl) 
9093			;	cp ':' 
9093			;	jr nc, .isdf 		; > 
9093			;	cp '0' 
9093			;	jr c, .isdf		; < 
9093			; 
9093			;	; TODO find a better way to set z 
9093			; 
9093			;	ld b,a 
9093			;	cp b 
9093			;	pop bc 
9093			;	ret 
9093			; 
9093			;.isdf:	; not digit so clear z 
9093			; 
9093			;	; TODO find a better way to unset z 
9093			; 
9093			;	ld b,a 
9093			;	inc b 
9093			;	cp b 
9093			; 
9093			;	pop bc 
9093			;	ret 
9093				 
9093				 
9093			 
9093			 
9093			; pass hl as the four byte address to load 
9093			 
9093			get_word_hl:  
9093 e5				push hl 
9094 cd 33 90			call get_byte 
9097				 
9097 47				ld b, a 
9098			 
9098 e1				pop hl 
9099 23				inc hl 
909a 23				inc hl 
909b			 
909b			; TODO not able to handle a-f  
909b 7e				ld a,(hl) 
909c			;	;cp ':' 
909c			;	cp 'g' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp 'G' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp '0' 
909c			;	jr c, .single_byte_hl		; < 
909c			 
909c				;call isdigithl 
909c fe 00			cp 0 
909e 28 06			jr z, .single_byte_hl 
90a0			 
90a0			.getwhln:   ; hex word so get next byte 
90a0			 
90a0 cd 33 90			call get_byte 
90a3 6f				ld l, a 
90a4 60				ld h,b 
90a5 c9				ret 
90a6 68			.single_byte_hl:   ld l,b 
90a7 26 00				ld h,0 
90a9 c9					ret 
90aa			 
90aa			 
90aa			 
90aa			 
90aa 21 3a 98			ld hl,asc+1 
90ad			;	ld a, (hl) 
90ad			;	call nibble2val 
90ad cd 33 90			call get_byte 
90b0			 
90b0			;	call fourehexhl 
90b0 32 f5 e2			ld (scratch+52),a 
90b3				 
90b3 21 f3 e2			ld hl,scratch+50 
90b6 22 e4 e5			ld (os_cur_ptr),hl 
90b9			 
90b9 c9				ret 
90ba			 
90ba			 
90ba			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
90ba			 
90ba			; Decimal Unsigned Version 
90ba			 
90ba			;Number in a to decimal ASCII 
90ba			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
90ba			;Example: display a=56 as "056" 
90ba			;input: a = number 
90ba			;Output: a=0,value of a in the screen 
90ba			;destroys af,bc (don't know about hl and de) 
90ba			DispAToASCII: 
90ba 0e 9c			ld	c,-100 
90bc cd c6 90			call	.Na1 
90bf 0e f6			ld	c,-10 
90c1 cd c6 90			call	.Na1 
90c4 0e ff			ld	c,-1 
90c6 06 2f		.Na1:	ld	b,'0'-1 
90c8 04			.Na2:	inc	b 
90c9 81				add	a,c 
90ca 38 fc			jr	c,.Na2 
90cc 91				sub	c		;works as add 100/10/1 
90cd f5				push af		;safer than ld c,a 
90ce 78				ld	a,b		;char is in b 
90cf			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
90cf f1				pop af		;safer than ld a,c 
90d0 c9				ret 
90d1			 
90d1			; Decimal Signed Version 
90d1			 
90d1			; DispA 
90d1			; -------------------------------------------------------------- 
90d1			; Converts a signed integer value to a zero-terminated ASCII 
90d1			; string representative of that value (using radix 10). 
90d1			; -------------------------------------------------------------- 
90d1			; INPUTS: 
90d1			;     HL     Value to convert (two's complement integer). 
90d1			;     DE     Base address of string destination. (pointer). 
90d1			; -------------------------------------------------------------- 
90d1			; OUTPUTS: 
90d1			;     None 
90d1			; -------------------------------------------------------------- 
90d1			; REGISTERS/MEMORY DESTROYED 
90d1			; AF HL 
90d1			; -------------------------------------------------------------- 
90d1			 
90d1			;DispHLToASCII: 
90d1			;   push    de 
90d1			;   push    bc 
90d1			; 
90d1			;; Detect sign of HL. 
90d1			;    bit    7, h 
90d1			;    jr     z, ._DoConvert 
90d1			; 
90d1			;; HL is negative. Output '-' to string and negate HL. 
90d1			;    ld     a, '-' 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			; 
90d1			;; Negate HL (using two's complement) 
90d1			;    xor    a 
90d1			;    sub    l 
90d1			;    ld     l, a 
90d1			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
90d1			;    sbc    a, h 
90d1			;    ld     h, a 
90d1			; 
90d1			;; Convert HL to digit characters 
90d1			;._DoConvert: 
90d1			;    ld     b, 0     ; B will count character length of number 
90d1			;-   ld     a, 10 
90d1			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
90d1			;    push   af 
90d1			;    inc    b 
90d1			;    ld     a, h 
90d1			;    or     l 
90d1			;    jr     nz, - 
90d1			; 
90d1			;; Retrieve digits from stack 
90d1			;-   pop    af 
90d1			;    or     $30 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			;    djnz   - 
90d1			; 
90d1			;; Terminate string with NULL 
90d1			;    xor    a 
90d1			;    ld     (de), a 
90d1			; 
90d1			;    pop    bc 
90d1			;    pop    de 
90d1			;    ret 
90d1			 
90d1			;Comments 
90d1			; 
90d1			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
90d1			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
90d1			;    Note that the output string will not be fixed-width. 
90d1			; 
90d1			;Example Usage 
90d1			; 
90d1			;    ld    hl, -1004 
90d1			;    ld    de, OP1 
90d1			;    call  DispA 
90d1			;    ld    hl, OP1 
90d1			;    syscall  PutS 
90d1			 
90d1			 
90d1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90d1			 
90d1			 
90d1			;Converts an ASCII string to an unsigned 16-bit integer 
90d1			;Quits when it reaches a non-decimal digit 
90d1			 
90d1			string_to_uint16: 
90d1			atoui_16: 
90d1			;Input: 
90d1			;     DE points to the string 
90d1			;Outputs: 
90d1			;     HL is the result 
90d1			;     A is the 8-bit value of the number 
90d1			;     DE points to the byte after the number 
90d1			;Destroys: 
90d1			;     BC 
90d1			;       if the string is non-empty, BC is HL/10 
90d1			;Size:  24 bytes 
90d1			;Speed: 42+d(104+{0,9}) 
90d1			;       d is the number of digits in the number 
90d1			;       max is 640 cycles for a 5 digit number 
90d1			;Assuming no leading zeros: 
90d1			;1 digit:  146cc 
90d1			;2 digit:  250cc 
90d1			;3 digit:  354cc or 363cc (avg: 354.126cc) 
90d1			;4 digit:  458cc or 467cc (avg: 458.27cc) 
90d1			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
90d1			;avg: 544.81158447265625cc (544+13297/16384) 
90d1			;=============================================================== 
90d1 21 00 00		  ld hl,0 
90d4			.u16a: 
90d4 1a			  ld a,(de) 
90d5 d6 30		  sub 30h 
90d7 fe 0a		  cp 10 
90d9 d0			  ret nc 
90da 13			  inc de 
90db 44			  ld b,h 
90dc 4d			  ld c,l 
90dd 29			  add hl,hl 
90de 29			  add hl,hl 
90df 09			  add hl,bc 
90e0 29			  add hl,hl 
90e1 85			  add a,l 
90e2 6f			  ld l,a 
90e3 30 ef		  jr nc,.u16a 
90e5 24			  inc h 
90e6 c3 d4 90		  jp .u16a 
90e9			 
90e9			 
90e9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90e9			 
90e9			;written by Zeda 
90e9			;Converts a 16-bit unsigned integer to an ASCII string. 
90e9			 
90e9			uitoa_16: 
90e9			;Input: 
90e9			;   DE is the number to convert 
90e9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90e9			;Output: 
90e9			;   HL points to the null-terminated ASCII string 
90e9			;      NOTE: This isn't necessarily the same as the input HL. 
90e9 d5			  push de 
90ea c5			  push bc 
90eb f5			  push af 
90ec eb			  ex de,hl 
90ed			 
90ed 01 f0 d8		  ld bc,-10000 
90f0 3e 2f		  ld a,'0'-1 
90f2 3c			  inc a 
90f3 09			  add hl,bc  
90f4 38 fc		   jr c,$-2 
90f6 12			  ld (de),a 
90f7 13			  inc de 
90f8			 
90f8 01 e8 03		  ld bc,1000 
90fb 3e 3a		  ld a,'9'+1 
90fd 3d			  dec a  
90fe 09			  add hl,bc  
90ff 30 fc		   jr nc,$-2 
9101 12			  ld (de),a 
9102 13			  inc de 
9103			 
9103 01 9c ff		  ld bc,-100 
9106 3e 2f		  ld a,'0'-1 
9108 3c			  inc a  
9109 09			  add hl,bc  
910a 38 fc		   jr c,$-2 
910c 12			  ld (de),a 
910d 13			  inc de 
910e			 
910e 7d			  ld a,l 
910f 26 3a		  ld h,'9'+1 
9111 25			  dec h  
9112 c6 0a		  add a,10  
9114 30 fb		   jr nc,$-3 
9116 c6 30		  add a,'0' 
9118 eb			  ex de,hl 
9119 72			  ld (hl),d 
911a 23			  inc hl 
911b 77			  ld (hl),a 
911c 23			  inc hl 
911d 36 00		  ld (hl),0 
911f			 
911f			;Now strip the leading zeros 
911f 0e fa		  ld c,-6 
9121 09			  add hl,bc 
9122 3e 30		  ld a,'0' 
9124 23			  inc hl  
9125 be			  cp (hl)  
9126 28 fc		  jr z,$-2 
9128			 
9128			;Make sure that the string is non-empty! 
9128 7e			  ld a,(hl) 
9129 b7			  or a 
912a 20 01		  jr nz,.atoub 
912c 2b			  dec hl 
912d			.atoub: 
912d			 
912d f1			  pop af 
912e c1			  pop bc 
912f d1			  pop de 
9130 c9			  ret 
9131			 
9131			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9131			 
9131			toUpper: 
9131			;A is the char. 
9131			;If A is a lowercase letter, this sets it to the matching uppercase 
9131			;18cc or 30cc or 41cc 
9131			;avg: 26.75cc 
9131 fe 61		  cp 'a' 
9133 d8			  ret c 
9134 fe 7b		  cp 'z'+1 
9136 d0			  ret nc 
9137 d6 20		  sub 'a'-'A' 
9139 c9			  ret 
913a			 
913a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
913a			 
913a			; String Length 
913a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
913a			 
913a			; Get the length of the null-terminated string starting at $8000 hl 
913a			;    LD     HL, $8000 
913a			 
913a			strlenz: 
913a			 
913a af			    XOR    A               ; Zero is the value we are looking for. 
913b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
913c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
913d			                           ; 65, 536 bytes (the entire addressable memory space). 
913d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
913f			 
913f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
913f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9140 6f			    LD     L, A             ; number of bytes 
9141 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9143 2b			    DEC    HL              ; Compensate for null. 
9144 c9				ret 
9145			 
9145			; Get the length of the A terminated string starting at $8000 hl 
9145			;    LD     HL, $8000 
9145			 
9145			strlent: 
9145			 
9145			                  ; A is the value we are looking for. 
9145 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9147 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9149			                           ; 65, 536 bytes (the entire addressable memory space). 
9149 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
914b			 
914b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
914b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
914d 2e 00		    LD     L, 0             ; number of bytes 
914f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9151 2b			    DEC    HL              ; Compensate for null. 
9152 c9				ret 
9153			 
9153			 
9153			;Comparing Strings 
9153			 
9153			;IN    HL     Address of string1. 
9153			;      DE     Address of string2. 
9153			 
9153			; doc given but wrong??? 
9153			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9153			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9153			; tested 
9153			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9153			 
9153			strcmp_old: 
9153 e5			    PUSH   HL 
9154 d5			    PUSH   DE 
9155			 
9155 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9156 be			    CP     (HL)            ; (want to minimize work). 
9157 38 01		    JR     C, Str1IsBigger 
9159 7e			    LD     A, (HL) 
915a			 
915a			Str1IsBigger: 
915a 4f			    LD     C, A             ; Put length in BC 
915b 06 00		    LD     B, 0 
915d 13			    INC    DE              ; Increment pointers to meat of string. 
915e 23			    INC    HL 
915f			 
915f			CmpLoop: 
915f 1a			    LD     A, (DE)          ; Compare bytes. 
9160 ed a1		    CPI 
9162 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9164 13			    INC    DE              ; Update pointer. 
9165 ea 5f 91		    JP     PE, CmpLoop 
9168			 
9168 d1			    POP    DE 
9169 e1			    POP    HL 
916a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
916b be			    CP     (HL) 
916c c9			    RET 
916d			 
916d			NoMatch: 
916d 2b			    DEC    HL 
916e be			    CP     (HL)            ; Compare again to affect carry. 
916f d1			    POP    DE 
9170 e1			    POP    HL 
9171 c9			    RET 
9172			 
9172			;; test strmp 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr z, .z1 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z1: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr z, .z2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr c, .c1 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c1: 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr c, .c2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;	NEXTW 
9172			;.str1:   db "string1",0 
9172			;.str2:   db "string2",0 
9172			 
9172			; only care about direct match or not 
9172			; hl and de strings 
9172			; zero set if the same 
9172			 
9172			strcmp: 
9172 1a				ld a, (de) 
9173 be				cp (hl) 
9174 28 02			jr z, .ssame 
9176 b7				or a 
9177 c9				ret 
9178			 
9178			.ssame:  
9178 fe 00			cp 0 
917a c8				ret z 
917b			 
917b 23				inc hl 
917c 13				inc de 
917d 18 f3			jr strcmp 
917f				 
917f				 
917f			 
917f			 
917f			 
917f			 
917f			; eof 
917f			 
917f			 
917f			 
917f			 
917f			 
917f			 
# End of file firmware_strings.asm
917f			include "firmware_memory.asm"   ; malloc and free  
917f			 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			.mallocsize: db "Wants malloc >256",0 
917f			.mallocasize: db "MALLOC gives >256",0 
917f			.malloczero: db "MALLOC gives zero",0 
917f			 
917f			malloc_guard_zerolen: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f				ld de, 0 
917f			        call cmp16 
917f				jr nz, .lowalloz 
917f			 
917f				push hl 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .malloczero 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				call bp_on 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f			.lowalloz: 
917f			 
917f			 
917f				pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_entry: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowalloc 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocsize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f				jr .lowdone 
917f			.lowalloc: 
917f			 
917f			 
917f				pop hl 
917f			.lowdone:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_exit: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowallocx 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocasize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f				pop de 
917f				pop hl 
917f			 
917f				CALLMONITOR 
917f				jr .lowdonex 
917f			.lowallocx: 
917f			 
917f				pop hl 
917f			.lowdonex:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			endif 
917f			 
917f			if MALLOC_2 
917f			; Z80 Malloc and Free Functions 
917f			 
917f			; Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc: 
917f				 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_entry 
917f			endif 
917f			 
917f			 
917f			 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "mal" 
917f						CALLMONITOR 
917f					endif 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of size into A 
917f			    or h               ; Check if size is zero 
917f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
917f			 
917f			    ; Allocate memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma1" 
917f						CALLMONITOR 
917f					endif 
917f			    call malloc_internal ; Call internal malloc function 
917f			    pop af             ; Restore AF register 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret                ; Return 
917f			 
917f			; Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free: 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of pointer into A 
917f			    or h               ; Check if pointer is NULL 
917f			    jp z, free_exit    ; If pointer is NULL, exit 
917f			 
917f			    ; Free memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f			    call free_internal  ; Call internal free function 
917f			    pop af             ; Restore AF register 
917f			    ret                ; Return 
917f			 
917f			; Internal Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc_internal: 
917f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to requested size 
917f			    ex de, hl          ; Save total size in DE, and keep it in HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			 
917f			    ; Search for free memory block 
917f			    ld de, (heap_end)  ; Load end of heap into DE 
917f			    ld bc, 0           ; Initialize counter 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			malloc_search_loop: 
917f			    ; Check if current block is free 
917f			    ld a, (hl)         ; Load current block's status (free or used) 
917f			    cp 0               ; Compare with zero (free) 
917f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
917f			 
917f			    ; Check if current block is large enough 
917f			    ld a, (hl+1)       ; Load high byte of block size 
917f			    cp l               ; Compare with low byte of requested size 
917f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
917f			 
917f			    ld a, (hl+2)       ; Load low byte of block size 
917f			    cp h               ; Compare with high byte of requested size 
917f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
917f			 
917f			    ; Mark block as used 
917f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
917f			 
917f			    ; Calculate remaining space in block 
917f			    ld bc, 0           ; Clear BC 
917f			    add hl, bc         ; Increment HL to point to start of data block 
917f			    add hl, de         ; HL = HL + DE (total size) 
917f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to start of data block 
917f			 
917f			    ; Save pointer to allocated block in HL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma5" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			malloc_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3           ; Size of management overhead 
917f			    add hl, bc         ; Move to the next block 
917f			    inc de             ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e            ; Load low byte of heap end address 
917f			    cp (hl)            ; Compare with low byte of current address 
917f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
917f			    ld a, d            ; Load high byte of heap end address 
917f			    cp 0               ; Check if it's zero (end of memory) 
917f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, allocation failed 
917f			    xor a              ; Set result to NULL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma6" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			malloc_exit: 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma7" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			; Internal Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free_internal: 
917f			    ld de, (heap_start) ; Load start of heap into DE 
917f			    ld bc, 0            ; Initialize counter 
917f			 
917f			free_search_loop: 
917f			    ; Check if current block contains the pointer 
917f			    ld a, l             ; Load low byte of pointer 
917f			    cp (hl+1)           ; Compare with high byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			    ld a, h             ; Load high byte of pointer 
917f			    cp (hl+2)           ; Compare with low byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			 
917f			    ; Mark block as free 
917f			    ld (hl), 0          ; Set status byte to indicate free block 
917f			    ret                 ; Return 
917f			 
917f			free_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3            ; Size of management overhead 
917f			    add hl, bc          ; Move to the next block 
917f			    inc de              ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e             ; Load low byte of heap end address 
917f			    cp (hl)             ; Compare with low byte of current address 
917f			    jr nz, free_search_loop  ; If not equal, continue searching 
917f			    ld a, d             ; Load high byte of heap end address 
917f			    cp 0                ; Check if it's zero (end of memory) 
917f			    jr nz, free_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, pointer is not found in heap 
917f			    ret 
917f			 
917f			free_exit: 
917f			    ret                 ; Return 
917f			 
917f			; Define heap start and end addresses 
917f			;heap_start:    .dw 0xC000   ; Start of heap 
917f			;heap_end:      .dw 0xE000   ; End of heap 
917f			 
917f			endif 
917f			 
917f			 
917f			if MALLOC_1 
917f			 
917f			 
917f			 
917f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
917f			 
917f			;moved to firmware.asm 
917f			;heap_start        .equ  0x9000      ; Starting address of heap 
917f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
917f			 
917f			;      .org 0 
917f			;      jp    main 
917f			 
917f			 
917f			;      .org  0x100 
917f			;main: 
917f			;      ld    HL, 0x8100 
917f			;      ld    SP, HL 
917f			; 
917f			;      call  heap_init 
917f			; 
917f			;      ; Make some allocations 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9004 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9014 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9024 
917f			; 
917f			;      ; Free some allocations 
917f			;      ld    HL, 0x9014 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9004 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9024 
917f			;      call  free 
917f			; 
917f			; 
917f			;      halt 
917f			 
917f			 
917f			;------------------------------------------------------------------------------ 
917f			;     heap_init                                                               : 
917f			;                                                                             : 
917f			; Description                                                                 : 
917f			;     Initialise the heap and make it ready for malloc and free operations.   : 
917f			;                                                                             : 
917f			;     The heap is maintained as a linked list, starting with an initial       : 
917f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
917f			;     the first free block in the heap. Each block then points to the next    : 
917f			;     free block within the heap, and the free list ends at the first block   : 
917f			;     with a null pointer to the next free block.                             : 
917f			;                                                                             : 
917f			; Parameters                                                                  : 
917f			;     Inputs are compile-time only. Two defines which specify the starting    : 
917f			;     address of the heap and its size are required, along with a memory      : 
917f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
917f			;     principally stores a pointer to the first free block in the heap.       : 
917f			;                                                                             : 
917f			; Returns                                                                     : 
917f			;     Nothing                                                                 : 
917f			;------------------------------------------------------------------------------ 
917f			heap_init: 
917f e5			      push  HL 
9180			 
9180			      ; Initialise free list struct 
9180 21 ec e3		      ld    HL, heap_start 
9183 22 e7 e3		      ld    (free_list), HL 
9186 21 00 00		      ld    HL, 0 
9189 22 e9 e3		      ld    (free_list+2), HL 
918c			 
918c			      ; Insert first free block at bottom of heap, consumes entire heap 
918c 21 a4 e2		      ld    HL, heap_start+heap_size-4 
918f 22 ec e3		      ld    (heap_start), HL        ; Next block (end of free list) 
9192 21 b8 fe		      ld    HL, heap_size-4 
9195 22 ee e3		      ld    (heap_start+2), HL      ; Block size 
9198			 
9198			      ; Insert end of free list block at top of heap - two null words will 
9198			      ; terminate the free list 
9198 21 00 00		      ld    HL, 0 
919b 22 a6 e2		      ld    (heap_start+heap_size-2), HL 
919e 22 a4 e2		      ld    (heap_start+heap_size-4), HL 
91a1			 
91a1 e1			      pop   HL 
91a2			 
91a2 c9			      ret 
91a3			 
91a3			 
91a3			;------------------------------------------------------------------------------ 
91a3			;     malloc                                                                  : 
91a3			;                                                                             : 
91a3			; Description                                                                 : 
91a3			;     Allocates the wanted space from the heap and returns the address of the : 
91a3			;     first useable byte of the allocation.                                   : 
91a3			;                                                                             : 
91a3			;     Allocations can happen in one of two ways:                              : 
91a3			;                                                                             : 
91a3			;     1. A free block may be found which is the exact size wanted. In this    : 
91a3			;        case the block is removed from the free list and retuedn to the      : 
91a3			;        caller.                                                              : 
91a3			;     2. A free block may be found which is larger than the size wanted. In   : 
91a3			;        this case, the larger block is split into two. The first portion of  : 
91a3			;        this block will become the requested space by the malloc call and    : 
91a3			;        is returned to the caller. The second portion becomes a new free     : 
91a3			;        block, and the free list is adjusted to maintain continuity via this : 
91a3			;        newly created block.                                                 : 
91a3			;                                                                             : 
91a3			;     malloc does not set any initial value in the allocated space, the       : 
91a3			;     caller is required to do this as required.                              : 
91a3			;                                                                             : 
91a3			;     This implementation of malloc uses the stack exclusively, and is        : 
91a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91a3			;     advisable to disable interrupts before calling malloc, and recommended  : 
91a3			;     to avoid the use of malloc inside ISRs in general.                      : 
91a3			;                                                                             : 
91a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91a3			;                                                                             : 
91a3			; Parameters                                                                  : 
91a3			;     HL  Number of bytes wanted                                              : 
91a3			;                                                                             : 
91a3			; Returns                                                                     : 
91a3			;     HL  Address of the first useable byte of the allocation                 : 
91a3			;                                                                             : 
91a3			; Flags                                                                       : 
91a3			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91a3			;                                                                             : 
91a3			; Stack frame                                                                 : 
91a3			;       |             |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     BC      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     DE      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     IX      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |  prev_free  |                                                       : 
91a3			;   +4  +-------------+                                                       : 
91a3			;       |  this_free  |                                                       : 
91a3			;   +2  +-------------+                                                       : 
91a3			;       |  next_free  |                                                       : 
91a3			;   +0  +-------------+                                                       : 
91a3			;       |             |                                                       : 
91a3			;                                                                             : 
91a3			;------------------------------------------------------------------------------ 
91a3			 
91a3			 
91a3			;malloc: 
91a3			; 
91a3			;	SAVESP ON 1 
91a3			; 
91a3			;	call malloc_code 
91a3			; 
91a3			;	CHECKSP ON 1 
91a3			;	ret 
91a3			 
91a3			 
91a3			malloc: 
91a3 c5			      push  BC 
91a4 d5			      push  DE 
91a5 dd e5		      push  IX 
91a7			if DEBUG_FORTH_MALLOC_HIGH 
91a7			call malloc_guard_entry 
91a7			endif 
91a7			 
91a7					if DEBUG_FORTH_MALLOC 
91a7						DMARK "mal" 
91a7						CALLMONITOR 
91a7					endif 
91a7 7c			      ld    A, H                    ; Exit if no space requested 
91a8 b5			      or    L 
91a9 ca 68 92		      jp    Z, malloc_early_exit 
91ac			 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			; 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			 
91ac			 
91ac			 
91ac			 
91ac					if DEBUG_FORTH_MALLOC 
91ac						DMARK "maA" 
91ac						CALLMONITOR 
91ac					endif 
91ac			      ; Set up stack frame 
91ac eb			      ex    DE, HL 
91ad 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91b0 39			      add   HL, SP 
91b1 f9			      ld    SP, HL 
91b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91b6 dd 39		      add   IX, SP 
91b8			 
91b8			      ; Setup initial state 
91b8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
91bb 19			      add   HL, DE 
91bc			 
91bc 44			      ld    B, H                    ; Move want to BC 
91bd 4d			      ld    C, L 
91be			 
91be 21 e7 e3		      ld    HL, free_list           ; Store prev_free ptr to stack 
91c1 dd 75 04		      ld    (IX+4), L 
91c4 dd 74 05		      ld    (IX+5), H 
91c7			 
91c7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
91c8 23			      inc   HL 
91c9 56			      ld    D, (HL) 
91ca dd 73 02		      ld    (IX+2), E 
91cd dd 72 03		      ld    (IX+3), D 
91d0 eb			      ex    DE, HL                  ; this_free ptr into HL 
91d1			 
91d1					if DEBUG_FORTH_MALLOC 
91d1						DMARK "maB" 
91d1						CALLMONITOR 
91d1					endif 
91d1			      ; Loop through free block list to find some space 
91d1			malloc_find_space: 
91d1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
91d2 23			      inc   HL 
91d3 56			      ld    D, (HL) 
91d4			 
91d4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91d5 b3			      or    E 
91d6 ca 62 92		      jp    Z, malloc_no_space 
91d9			 
91d9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91dc dd 72 01		      ld    (IX+1), D 
91df			 
91df			      ; Does this block have enough space to make the allocation? 
91df 23			      inc   HL                      ; Load free block size into DE 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3			 
91e3 eb			      ex    DE, HL                  ; Check size of block against want 
91e4 b7			      or    A                       ; Ensure carry flag clear 
91e5 ed 42		      sbc   HL, BC 
91e7 e5			      push  HL                      ; Store the result for later (new block size) 
91e8			 
91e8 ca 37 92		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91eb 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91ed			 
91ed			      ; this_free block is not big enough, setup ptrs to test next free block 
91ed e1			      pop   HL                      ; Discard previous result 
91ee			 
91ee dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91f1 dd 66 03		      ld    H, (IX+3) 
91f4 dd 75 04		      ld    (IX+4), L 
91f7 dd 74 05		      ld    (IX+5), H 
91fa			 
91fa dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91fd dd 66 01		      ld    H, (IX+1) 
9200 dd 75 02		      ld    (IX+2), L 
9203 dd 74 03		      ld    (IX+3), H 
9206			 
9206					if DEBUG_FORTH_MALLOC 
9206						DMARK "MA>" 
9206						CALLMONITOR 
9206					endif 
9206 18 c9		      jr    malloc_find_space 
9208			 
9208			      ; split a bigger block into two - requested size and remaining size 
9208			malloc_alloc_split: 
9208					if DEBUG_FORTH_MALLOC 
9208						DMARK "MAs" 
9208						CALLMONITOR 
9208					endif 
9208 eb			      ex    DE, HL                  ; Calculate address of new free block 
9209 2b			      dec   HL 
920a 2b			      dec   HL 
920b 2b			      dec   HL 
920c 09			      add   HL, BC 
920d			 
920d			      ; Create a new block and point it at next_free 
920d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9210 dd 56 01		      ld    D, (IX+1) 
9213			 
9213 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9214 23			      inc   HL 
9215 72			      ld    (HL), D 
9216			 
9216 d1			      pop   DE                      ; Store size of new block into new block 
9217 23			      inc   HL 
9218 73			      ld    (HL), E 
9219 23			      inc   HL 
921a 72			      ld    (HL), D 
921b			 
921b			      ; Update this_free ptr to point to new block 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d 2b			      dec   HL 
921e			 
921e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9221 dd 56 03		      ld    D, (IX+3) 
9224			 
9224 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9227 dd 74 03		      ld    (IX+3), H 
922a			 
922a			      ; Modify this_free block to be allocation 
922a eb			      ex    DE, HL 
922b af			      xor   A                       ; Null the next block ptr of allocated block 
922c 77			      ld    (HL), A 
922d 23			      inc   HL 
922e 77			      ld    (HL), A 
922f			 
922f 23			      inc   HL                      ; Store want size into allocated block 
9230 71			      ld    (HL), C 
9231 23			      inc   HL 
9232 70			      ld    (HL), B 
9233 23			      inc   HL 
9234 e5			      push  HL                      ; Address of allocation to return 
9235			 
9235 18 19		      jr    malloc_update_links 
9237			 
9237			malloc_alloc_fit: 
9237 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9238			 
9238					if DEBUG_FORTH_MALLOC 
9238						DMARK "MAf" 
9238						CALLMONITOR 
9238					endif 
9238			      ; Modify this_free block to be allocation 
9238 eb			      ex    DE, HL 
9239 2b			      dec   HL 
923a 2b			      dec   HL 
923b 2b			      dec   HL 
923c			 
923c af			      xor   A                       ; Null the next block ptr of allocated block 
923d 77			      ld    (HL), A 
923e 23			      inc   HL 
923f 77			      ld    (HL), A 
9240			 
9240 23			      inc   HL                      ; Store address of allocation to return 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 e5			      push  HL 
9244			 
9244			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9244 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9247 dd 66 01		      ld    H, (IX+1) 
924a			 
924a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
924d dd 74 03		      ld    (IX+3), H 
9250			 
9250			 
9250			malloc_update_links: 
9250			      ; Update prev_free ptr to point to this_free 
9250 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9253 dd 66 05		      ld    H, (IX+5) 
9256			 
9256 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9259 dd 56 03		      ld    D, (IX+3) 
925c			 
925c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
925d 23			      inc   HL 
925e 72			      ld    (HL), D 
925f			 
925f					if DEBUG_FORTH_MALLOC 
925f						DMARK "Mul" 
925f						CALLMONITOR 
925f					endif 
925f			      ; Clear the Z flag to indicate successful allocation 
925f 7a			      ld    A, D 
9260 b3			      or    E 
9261			 
9261 d1			      pop   DE                      ; Address of allocation 
9262					if DEBUG_FORTH_MALLOC 
9262						DMARK "MAu" 
9262						CALLMONITOR 
9262					endif 
9262			 
9262			malloc_no_space: 
9262 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9265 39			      add   HL, SP 
9266 f9			      ld    SP, HL 
9267			 
9267 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAN" 
9268						CALLMONITOR 
9268					endif 
9268			 
9268			malloc_early_exit: 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAx" 
9268						CALLMONITOR 
9268					endif 
9268 dd e1		      pop   IX 
926a d1			      pop   DE 
926b c1			      pop   BC 
926c			 
926c			if DEBUG_FORTH_MALLOC_HIGH 
926c			call malloc_guard_exit 
926c			call malloc_guard_zerolen 
926c			endif 
926c c9			      ret 
926d			 
926d			 
926d			;------------------------------------------------------------------------------ 
926d			;     free                                                                    : 
926d			;                                                                             : 
926d			; Description                                                                 : 
926d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
926d			;     returned by malloc, otherwise the behaviour is undefined.               : 
926d			;                                                                             : 
926d			;     Where possible, directly adjacent free blocks will be merged together   : 
926d			;     into larger blocks to help ensure that the heap does not become         : 
926d			;     excessively fragmented.                                                 : 
926d			;                                                                             : 
926d			;     free does not clear or set any other value into the freed space, and    : 
926d			;     therefore its contents may be visible through subsequent malloc's. The  : 
926d			;     caller should clear the freed space as required.                        : 
926d			;                                                                             : 
926d			;     This implementation of free uses the stack exclusively, and is          : 
926d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
926d			;     advisable to disable interrupts before calling free, and recommended    : 
926d			;     to avoid the use of free inside ISRs in general.                        : 
926d			;                                                                             : 
926d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
926d			;                                                                             : 
926d			; Parameters                                                                  : 
926d			;     HL  Pointer to address of first byte of allocation to be freed          : 
926d			;                                                                             : 
926d			; Returns                                                                     : 
926d			;     Nothing                                                                 : 
926d			;                                                                             : 
926d			; Stack frame                                                                 : 
926d			;       |             |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     BC      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     DE      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     IX      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |  prev_free  |                                                       : 
926d			;   +2  +-------------+                                                       : 
926d			;       |  next_free  |                                                       : 
926d			;   +0  +-------------+                                                       : 
926d			;       |             |                                                       : 
926d			;                                                                             : 
926d			;------------------------------------------------------------------------------ 
926d			free: 
926d c5			      push  BC 
926e d5			      push  DE 
926f dd e5		      push  IX 
9271			 
9271 7c			      ld    A, H                    ; Exit if ptr is null 
9272 b5			      or    L 
9273 ca 37 93		      jp    Z, free_early_exit 
9276			 
9276			      ; Set up stack frame 
9276 eb			      ex    DE, HL 
9277 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
927a 39			      add   HL, SP 
927b f9			      ld    SP, HL 
927c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9280 dd 39		      add   IX, SP 
9282			 
9282			      ; The address in HL points to the start of the useable allocated space, 
9282			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9282			      ; address of the block itself. 
9282 eb			      ex    DE, HL 
9283 11 fc ff		      ld    DE, -4 
9286 19			      add   HL, DE 
9287			 
9287			      ; An allocated block must have a null next block pointer in it 
9287 7e			      ld    A, (HL) 
9288 23			      inc   HL 
9289 b6			      or    (HL) 
928a c2 32 93		      jp    NZ, free_done 
928d			 
928d 2b			      dec   HL 
928e			 
928e 44			      ld    B, H                    ; Copy HL to BC 
928f 4d			      ld    C, L 
9290			 
9290			      ; Loop through the free list to find the first block with an address 
9290			      ; higher than the block being freed 
9290 21 e7 e3		      ld    HL, free_list 
9293			 
9293			free_find_higher_block: 
9293 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9294 23			      inc   HL 
9295 56			      ld    D, (HL) 
9296 2b			      dec   HL 
9297			 
9297 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
929a dd 72 01		      ld    (IX+1), D 
929d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
92a0 dd 74 03		      ld    (IX+3), H 
92a3			 
92a3 78			      ld    A, B                    ; Check if DE is greater than BC 
92a4 ba			      cp    D                       ; Compare MSB first 
92a5 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
92a7 30 04		      jr    NC, free_find_higher_block_skip 
92a9 79			      ld    A, C 
92aa bb			      cp    E                       ; Then compare LSB 
92ab 38 08		      jr    C, free_found_higher_block 
92ad			 
92ad			free_find_higher_block_skip: 
92ad 7a			      ld    A, D                    ; Reached the end of the free list? 
92ae b3			      or    E 
92af ca 32 93		      jp    Z, free_done 
92b2			 
92b2 eb			      ex    DE, HL 
92b3			 
92b3 18 de		      jr    free_find_higher_block 
92b5			 
92b5			free_found_higher_block: 
92b5			      ; Insert freed block between prev and next free blocks 
92b5 71			      ld    (HL), C                 ; Point prev free block to freed block 
92b6 23			      inc   HL 
92b7 70			      ld    (HL), B 
92b8			 
92b8 60			      ld    H, B                    ; Point freed block at next free block 
92b9 69			      ld    L, C 
92ba 73			      ld    (HL), E 
92bb 23			      inc   HL 
92bc 72			      ld    (HL), D 
92bd			 
92bd			      ; Check if the freed block is adjacent to the next free block 
92bd 23			      inc   HL                      ; Load size of freed block into HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 eb			      ex    DE, HL 
92c2			 
92c2 09			      add   HL, BC                  ; Add addr of freed block and its size 
92c3			 
92c3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
92c6 dd 56 01		      ld    D, (IX+1) 
92c9			 
92c9 b7			      or    A                       ; Clear the carry flag 
92ca ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92cc 20 22		      jr    NZ, free_check_adjacent_to_prev 
92ce			 
92ce			      ; Freed block is adjacent to next, merge into one bigger block 
92ce eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
92cf 5e			      ld    E, (HL) 
92d0 23			      inc   HL 
92d1 56			      ld    D, (HL) 
92d2 e5			      push  HL                      ; Save ptr to next block for later 
92d3			 
92d3 60			      ld    H, B                    ; Store ptr from next block into freed block 
92d4 69			      ld    L, C 
92d5 73			      ld    (HL), E 
92d6 23			      inc   HL 
92d7 72			      ld    (HL), D 
92d8			 
92d8 e1			      pop   HL                      ; Restore ptr to next block 
92d9 23			      inc   HL                      ; Load size of next block into DE 
92da 5e			      ld    E, (HL) 
92db 23			      inc   HL 
92dc 56			      ld    D, (HL) 
92dd d5			      push  DE                      ; Save next block size for later 
92de			 
92de 60			      ld    H, B                    ; Load size of freed block into HL 
92df 69			      ld    L, C 
92e0 23			      inc   HL 
92e1 23			      inc   HL 
92e2 5e			      ld    E, (HL) 
92e3 23			      inc   HL 
92e4 56			      ld    D, (HL) 
92e5 eb			      ex    DE, HL 
92e6			 
92e6 d1			      pop   DE                      ; Restore size of next block 
92e7 19			      add   HL, DE                  ; Add sizes of both blocks 
92e8 eb			      ex    DE, HL 
92e9			 
92e9 60			      ld    H, B                    ; Store new bigger size into freed block 
92ea 69			      ld    L, C 
92eb 23			      inc   HL 
92ec 23			      inc   HL 
92ed 73			      ld    (HL), E 
92ee 23			      inc   HL 
92ef 72			      ld    (HL), D 
92f0			 
92f0			free_check_adjacent_to_prev: 
92f0			      ; Check if the freed block is adjacent to the prev free block 
92f0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92f3 dd 66 03		      ld    H, (IX+3) 
92f6			 
92f6 23			      inc   HL                      ; Size of prev free block into DE 
92f7 23			      inc   HL 
92f8 5e			      ld    E, (HL) 
92f9 23			      inc   HL 
92fa 56			      ld    D, (HL) 
92fb 2b			      dec   HL 
92fc 2b			      dec   HL 
92fd 2b			      dec   HL 
92fe			 
92fe 19			      add   HL, DE                  ; Add prev block addr and size 
92ff			 
92ff b7			      or    A                       ; Clear the carry flag 
9300 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302 20 2e		      jr    NZ, free_done 
9304			 
9304			      ; Freed block is adjacent to prev, merge into one bigger block 
9304 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9305 69			      ld    L, C 
9306 5e			      ld    E, (HL) 
9307 23			      inc   HL 
9308 56			      ld    D, (HL) 
9309 e5			      push  HL                      ; Save freed block ptr for later 
930a			 
930a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
930d dd 66 03		      ld    H, (IX+3) 
9310 73			      ld    (HL), E 
9311 23			      inc   HL 
9312 72			      ld    (HL), D 
9313			 
9313 e1			      pop   HL                      ; Restore freed block ptr 
9314 23			      inc   HL                      ; Load size of freed block into DE 
9315 5e			      ld    E, (HL) 
9316 23			      inc   HL 
9317 56			      ld    D, (HL) 
9318 d5			      push  DE                      ; Save freed block size for later 
9319			 
9319 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
931c dd 66 03		      ld    H, (IX+3) 
931f 23			      inc   HL 
9320 23			      inc   HL 
9321 5e			      ld    E, (HL) 
9322 23			      inc   HL 
9323 56			      ld    D, (HL) 
9324			 
9324 e1			      pop   HL                      ; Add sizes of both blocks 
9325 19			      add   HL, DE 
9326 eb			      ex    DE, HL 
9327			 
9327 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
932a dd 66 03		      ld    H, (IX+3) 
932d 23			      inc   HL 
932e 23			      inc   HL 
932f 73			      ld    (HL), E 
9330 23			      inc   HL 
9331 72			      ld    (HL), D 
9332			 
9332			free_done: 
9332 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9335 39			      add   HL, SP 
9336 f9			      ld    SP, HL 
9337			 
9337			free_early_exit: 
9337 dd e1		      pop   IX 
9339 d1			      pop   DE 
933a c1			      pop   BC 
933b			 
933b c9			      ret 
933c			 
933c			; moved to firmware.asm 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			;                  .dw   0 
933c			 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_3 
933c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
933c			;heap_start        .equ  0x9000      ; Starting address of heap 
933c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
933c			; 
933c			 ;     .org 0 
933c			  ;    jp    main 
933c			; 
933c			; 
933c			 ;     .org  0x100 
933c			;main: 
933c			 ;     ld    HL, 0x8100 
933c			  ;    ld    SP, HL 
933c			; 
933c			;      call  heap_init 
933c			 
933c			      ; Make some allocations 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9004 
933c			; 
933c			 ;     ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9014 
933c			 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9024 
933c			 
933c			      ; Free some allocations 
933c			;      ld    HL, 0x9014 
933c			;      call  free 
933c			 
933c			;      ld    HL, 0x9004 
933c			;      call  free 
933c			; 
933c			;      ld    HL, 0x9024 
933c			;      call  free 
933c			 
933c			 
933c			 ;     halt 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     heap_init                                                               : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Initialise the heap and make it ready for malloc and free operations.   : 
933c			;                                                                             : 
933c			;     The heap is maintained as a linked list, starting with an initial       : 
933c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
933c			;     the first free block in the heap. Each block then points to the next    : 
933c			;     free block within the heap, and the free list ends at the first block   : 
933c			;     with a null pointer to the next free block.                             : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     Inputs are compile-time only. Two defines which specify the starting    : 
933c			;     address of the heap and its size are required, along with a memory      : 
933c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
933c			;     principally stores a pointer to the first free block in the heap.       : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;------------------------------------------------------------------------------ 
933c			heap_init: 
933c			      push  HL 
933c			 
933c			      ; Initialise free list struct 
933c			      ld    HL, heap_start 
933c			      ld    (free_list), HL 
933c			      ld    HL, 0 
933c			      ld    (free_list+2), HL 
933c			 
933c			      ; Insert first free block at bottom of heap, consumes entire heap 
933c			      ld    HL, heap_start+heap_size-4 
933c			      ld    (heap_start), HL        ; Next block (end of free list) 
933c			      ld    HL, heap_size-4 
933c			      ld    (heap_start+2), HL      ; Block size 
933c			 
933c			      ; Insert end of free list block at top of heap - two null words will 
933c			      ; terminate the free list 
933c			      ld    HL, 0 
933c			      ld    (heap_start+heap_size-2), HL 
933c			      ld    (heap_start+heap_size-4), HL 
933c			 
933c			      pop   HL 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     malloc                                                                  : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Allocates the wanted space from the heap and returns the address of the : 
933c			;     first useable byte of the allocation.                                   : 
933c			;                                                                             : 
933c			;     Allocations can happen in one of two ways:                              : 
933c			;                                                                             : 
933c			;     1. A free block may be found which is the exact size wanted. In this    : 
933c			;        case the block is removed from the free list and retuedn to the      : 
933c			;        caller.                                                              : 
933c			;     2. A free block may be found which is larger than the size wanted. In   : 
933c			;        this case, the larger block is split into two. The first portion of  : 
933c			;        this block will become the requested space by the malloc call and    : 
933c			;        is returned to the caller. The second portion becomes a new free     : 
933c			;        block, and the free list is adjusted to maintain continuity via this : 
933c			;        newly created block.                                                 : 
933c			;                                                                             : 
933c			;     malloc does not set any initial value in the allocated space, the       : 
933c			;     caller is required to do this as required.                              : 
933c			;                                                                             : 
933c			;     This implementation of malloc uses the stack exclusively, and is        : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling malloc, and recommended  : 
933c			;     to avoid the use of malloc inside ISRs in general.                      : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Number of bytes wanted                                              : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     HL  Address of the first useable byte of the allocation                 : 
933c			;                                                                             : 
933c			; Flags                                                                       : 
933c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +4  +-------------+                                                       : 
933c			;       |  this_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			malloc: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if no space requested 
933c			      or    L 
933c			      jp    Z, malloc_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; Setup initial state 
933c			      ld    HL, 4                   ; want must also include space used by block struct 
933c			      add   HL, DE 
933c			 
933c			      ld    B, H                    ; Move want to BC 
933c			      ld    C, L 
933c			 
933c			      ld    HL, free_list           ; Store prev_free ptr to stack 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    E, (HL)                 ; Store this_free ptr to stack 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ld    (IX+2), E 
933c			      ld    (IX+3), D 
933c			      ex    DE, HL                  ; this_free ptr into HL 
933c			 
933c			      ; Loop through free block list to find some space 
933c			malloc_find_space: 
933c			      ld    E, (HL)                 ; Load next_free ptr into DE 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
933c			      or    E 
933c			      jp    Z, malloc_no_space 
933c			 
933c			      ld    (IX+0), E               ; Store next_free ptr to stack 
933c			      ld    (IX+1), D 
933c			 
933c			      ; Does this block have enough space to make the allocation? 
933c			      inc   HL                      ; Load free block size into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ex    DE, HL                  ; Check size of block against want 
933c			      or    A                       ; Ensure carry flag clear 
933c			      sbc   HL, BC 
933c			      push  HL                      ; Store the result for later (new block size) 
933c			 
933c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
933c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
933c			 
933c			      ; this_free block is not big enough, setup ptrs to test next free block 
933c			      pop   HL                      ; Discard previous result 
933c			 
933c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
933c			      ld    H, (IX+3) 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
933c			      ld    H, (IX+1) 
933c			      ld    (IX+2), L 
933c			      ld    (IX+3), H 
933c			 
933c			      jr    malloc_find_space 
933c			 
933c			      ; split a bigger block into two - requested size and remaining size 
933c			malloc_alloc_split: 
933c			      ex    DE, HL                  ; Calculate address of new free block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      add   HL, BC 
933c			 
933c			      ; Create a new block and point it at next_free 
933c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      ld    (HL), E                 ; Store next_free ptr into new block 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   DE                      ; Store size of new block into new block 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Update this_free ptr to point to new block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
933c			      ld    (IX+3), H 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store want size into allocated block 
933c			      ld    (HL), C 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			      inc   HL 
933c			      push  HL                      ; Address of allocation to return 
933c			 
933c			      jr    malloc_update_links 
933c			 
933c			malloc_alloc_fit: 
933c			      pop   HL                      ; Dont need new block size, want is exact fit 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store address of allocation to return 
933c			      inc   HL 
933c			      inc   HL 
933c			      push  HL 
933c			 
933c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
933c			      ld    L, (IX+0)               ; next_free to HL 
933c			      ld    H, (IX+1) 
933c			 
933c			      ld    (IX+2), L               ; HL to this_free 
933c			      ld    (IX+3), H 
933c			 
933c			 
933c			malloc_update_links: 
933c			      ; Update prev_free ptr to point to this_free 
933c			      ld    L, (IX+4)               ; prev_free ptr to HL 
933c			      ld    H, (IX+5) 
933c			 
933c			      ld    E, (IX+2)               ; this_free ptr to DE 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (HL), E                 ; this_free ptr into prev_free 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Clear the Z flag to indicate successful allocation 
933c			      ld    A, D 
933c			      or    E 
933c			 
933c			      pop   DE                      ; Address of allocation 
933c			 
933c			malloc_no_space: 
933c			      ld    HL, 6                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			      ex    DE, HL                  ; Alloc addr into HL for return 
933c			 
933c			malloc_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     free                                                                    : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
933c			;     returned by malloc, otherwise the behaviour is undefined.               : 
933c			;                                                                             : 
933c			;     Where possible, directly adjacent free blocks will be merged together   : 
933c			;     into larger blocks to help ensure that the heap does not become         : 
933c			;     excessively fragmented.                                                 : 
933c			;                                                                             : 
933c			;     free does not clear or set any other value into the freed space, and    : 
933c			;     therefore its contents may be visible through subsequent malloc's. The  : 
933c			;     caller should clear the freed space as required.                        : 
933c			;                                                                             : 
933c			;     This implementation of free uses the stack exclusively, and is          : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling free, and recommended    : 
933c			;     to avoid the use of free inside ISRs in general.                        : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Pointer to address of first byte of allocation to be freed          : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			free: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if ptr is null 
933c			      or    L 
933c			      jp    Z, free_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; The address in HL points to the start of the useable allocated space, 
933c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
933c			      ; address of the block itself. 
933c			      ex    DE, HL 
933c			      ld    DE, -4 
933c			      add   HL, DE 
933c			 
933c			      ; An allocated block must have a null next block pointer in it 
933c			      ld    A, (HL) 
933c			      inc   HL 
933c			      or    (HL) 
933c			      jp    NZ, free_done 
933c			 
933c			      dec   HL 
933c			 
933c			      ld    B, H                    ; Copy HL to BC 
933c			      ld    C, L 
933c			 
933c			      ; Loop through the free list to find the first block with an address 
933c			      ; higher than the block being freed 
933c			      ld    HL, free_list 
933c			 
933c			free_find_higher_block: 
933c			      ld    E, (HL)                 ; Load next ptr from free block 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			 
933c			      ld    (IX+0), E               ; Save ptr to next free block 
933c			      ld    (IX+1), D 
933c			      ld    (IX+2), L               ; Save ptr to prev free block 
933c			      ld    (IX+3), H 
933c			 
933c			      ld    A, B                    ; Check if DE is greater than BC 
933c			      cp    D                       ; Compare MSB first 
933c			      jr    Z, $+4                  ; MSB the same, compare LSB 
933c			      jr    NC, free_find_higher_block_skip 
933c			      ld    A, C 
933c			      cp    E                       ; Then compare LSB 
933c			      jr    C, free_found_higher_block 
933c			 
933c			free_find_higher_block_skip: 
933c			      ld    A, D                    ; Reached the end of the free list? 
933c			      or    E 
933c			      jp    Z, free_done 
933c			 
933c			      ex    DE, HL 
933c			 
933c			      jr    free_find_higher_block 
933c			 
933c			free_found_higher_block: 
933c			      ; Insert freed block between prev and next free blocks 
933c			      ld    (HL), C                 ; Point prev free block to freed block 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			 
933c			      ld    H, B                    ; Point freed block at next free block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Check if the freed block is adjacent to the next free block 
933c			      inc   HL                      ; Load size of freed block into HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      add   HL, BC                  ; Add addr of freed block and its size 
933c			 
933c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_check_adjacent_to_prev 
933c			 
933c			      ; Freed block is adjacent to next, merge into one bigger block 
933c			      ex    DE, HL                  ; Load next ptr from next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save ptr to next block for later 
933c			 
933c			      ld    H, B                    ; Store ptr from next block into freed block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore ptr to next block 
933c			      inc   HL                      ; Load size of next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save next block size for later 
933c			 
933c			      ld    H, B                    ; Load size of freed block into HL 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      pop   DE                      ; Restore size of next block 
933c			      add   HL, DE                  ; Add sizes of both blocks 
933c			      ex    DE, HL 
933c			 
933c			      ld    H, B                    ; Store new bigger size into freed block 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_check_adjacent_to_prev: 
933c			      ; Check if the freed block is adjacent to the prev free block 
933c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
933c			      ld    H, (IX+3) 
933c			 
933c			      inc   HL                      ; Size of prev free block into DE 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      add   HL, DE                  ; Add prev block addr and size 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_done 
933c			 
933c			      ; Freed block is adjacent to prev, merge into one bigger block 
933c			      ld    H, B                    ; Load next ptr from freed block into DE 
933c			      ld    L, C 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save freed block ptr for later 
933c			 
933c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
933c			      ld    H, (IX+3) 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore freed block ptr 
933c			      inc   HL                      ; Load size of freed block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save freed block size for later 
933c			 
933c			      ld    L, (IX+2)               ; Load size of prev block into DE 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      pop   HL                      ; Add sizes of both blocks 
933c			      add   HL, DE 
933c			      ex    DE, HL 
933c			 
933c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_done: 
933c			      ld    HL, 4                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			free_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;      .org 0x8000 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			 ;                 .dw   0 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_4 
933c			 
933c			; My memory allocation code. Very very simple.... 
933c			; allocate space under 250 chars 
933c			 
933c			heap_init: 
933c				; init start of heap as zero 
933c				;  
933c			 
933c				ld hl, heap_start 
933c				ld a, 0 
933c				ld (hl), a      ; empty block 
933c				inc hl 
933c				ld a, 0 
933c				ld (hl), a      ; length of block 
933c				; write end of list 
933c				inc hl 
933c				ld a,(hl) 
933c				inc hl 
933c				ld a,(hl) 
933c				 
933c			 
933c				; init some malloc vars 
933c			 
933c				ld hl, 0 
933c				ld (free_list), hl       ; store last malloc location 
933c			 
933c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
933c				ld a, 0 
933c				ld (hl), a 
933c			 
933c			 
933c				ld hl, heap_start 
933c				;  
933c				  
933c				ret 
933c			 
933c			 
933c			;    free block marker 
933c			;    requested size  
933c			;    pointer to next block 
933c			;    .... 
933c			;    next block marker 
933c			 
933c			 
933c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
933c			; 
933c			 
933c			 
933c			malloc:  
933c				push de 
933c				push bc 
933c				push af 
933c			 
933c				; hl space required 
933c				 
933c				ld c, l    ; hold space   (TODO only a max of 255) 
933c			 
933c			;	inc c     ; TODO BUG need to fix memory leak on push str 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			 
933c			 
933c			 
933c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
933c			 
933c				ld a, (free_list+3) 
933c				cp 0 
933c				jr z, .contheap 
933c			 
933c				ld hl, (free_list)     ; get last alloc 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mrs" 
933c						CALLMONITOR 
933c					endif 
933c				jr .startalloc 
933c			 
933c			.contheap: 
933c				ld hl, heap_start 
933c			 
933c			.startalloc: 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mym" 
933c						CALLMONITOR 
933c					endif 
933c			.findblock: 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmf" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c				ld a,(hl)  
933c				; if byte is zero then clear to use 
933c			 
933c				cp 0 
933c				jr z, .foundemptyblock 
933c			 
933c				; if byte is not clear 
933c				;     then byte is offset to next block 
933c			 
933c				inc hl 
933c				ld a, (hl) ; get size 
933c			.nextblock:	inc hl 
933c					ld e, (hl) 
933c					inc hl 
933c					ld d, (hl) 
933c					ex de, hl 
933c			;	inc hl  ; move past the store space 
933c			;	inc hl  ; move past zero index  
933c			 
933c				; TODO detect no more space 
933c			 
933c				push hl 
933c				ld de, heap_end 
933c				call cmp16 
933c				pop hl 
933c				jr nc, .nospace 
933c			 
933c				jr .findblock 
933c			 
933c			.nospace: ld hl, 0 
933c				jp .exit 
933c			 
933c			 
933c			.foundemptyblock:	 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mme" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; TODO has block enough space if reusing??? 
933c			 
933c				;  
933c			 
933c			; see if this block has been previously used 
933c				inc hl 
933c				ld a, (hl) 
933c				dec hl 
933c				cp 0 
933c				jr z, .newblock 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meR" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; no reusing previously allocated block 
933c			 
933c			; is it smaller than previously used? 
933c				 
933c				inc hl    ; move to size 
933c				ld a, c 
933c				sub (hl)        ; we want c < (hl) 
933c				dec hl    ; move back to marker 
933c			        jr z, .findblock 
933c			 
933c				; update with the new size which should be lower 
933c			 
933c			        ;inc  hl   ; negate next move. move back to size  
933c			 
933c			.newblock: 
933c				; need to be at marker here 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meN" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			 
933c				ld a, c 
933c			 
933c				ld (free_list+3), a	 ; flag resume from last malloc  
933c				ld (free_list), hl    ; save out last location 
933c			 
933c			 
933c				;inc a     ; space for length byte 
933c				ld (hl), a     ; save block in use marker 
933c			 
933c				inc hl   ; move to space marker 
933c				ld (hl), a    ; save new space 
933c			 
933c				inc hl   ; move to start of allocated area 
933c				 
933c			;	push hl     ; save where we are - 1  
933c			 
933c			;	inc hl  ; move past zero index  
933c				; skip space to set down new marker 
933c			 
933c				; provide some extra space for now 
933c			 
933c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
933c				inc a 
933c				inc a 
933c			 
933c				push hl   ; save where we are in the node block 
933c			 
933c				call addatohl 
933c			 
933c				; write linked list point 
933c			 
933c				pop de     ; get our node position 
933c				ex de, hl 
933c			 
933c				ld (hl), e 
933c				inc hl 
933c				ld (hl), d 
933c			 
933c				inc hl 
933c			 
933c				; now at start of allocated data so save pointer 
933c			 
933c				push hl 
933c			 
933c				; jump to position of next node and setup empty header in DE 
933c			 
933c				ex de, hl 
933c			 
933c			;	inc hl ; move past end of block 
933c			 
933c				ld a, 0 
933c				ld (hl), a   ; empty marker 
933c				inc hl 
933c				ld (hl), a   ; size 
933c				inc hl  
933c				ld (hl), a   ; ptr 
933c				inc hl 
933c				ld (hl), a   ; ptr 
933c			 
933c			 
933c				pop hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmr" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			.exit: 
933c				pop af 
933c				pop bc 
933c				pop de  
933c				ret 
933c			 
933c			 
933c			 
933c			 
933c			free:  
933c				push hl 
933c				push af 
933c				; get address in hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "fre" 
933c						CALLMONITOR 
933c					endif 
933c				; data is at hl - move to block count 
933c				dec hl 
933c				dec hl    ; get past pointer 
933c				dec hl 
933c			 
933c				ld a, (hl)    ; need this for a validation check 
933c			 
933c				dec hl    ; move to block marker 
933c			 
933c				; now check that the block count and block marker are the same  
933c			        ; this checks that we are on a malloc node and not random memory 
933c			        ; OK a faint chance this could be a problem but rare - famous last words! 
933c			 
933c				ld c, a 
933c				ld a, (hl)    
933c			 
933c				cp c 
933c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
933c			 
933c				; yes good chance we are on a malloc node 
933c			 
933c				ld a, 0      
933c				ld (hl), a   ; mark as free 
933c			 
933c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
933c			 
933c			.freeignore:  
933c			 
933c				pop af 
933c				pop hl 
933c			 
933c				ret 
933c			 
933c			 
933c			 
933c			endif 
933c			 
933c			; eof 
# End of file firmware_memory.asm
933c			  
933c			; device C  
933c			; Now handled by SPI  
933c			;if SOUND_ENABLE  
933c			;	include "firmware_sound.asm"  
933c			;endif  
933c			  
933c			include "firmware_diags.asm"  
933c			; Hardware diags menu 
933c			 
933c			 
933c			config: 
933c			 
933c 3e 00			ld a, 0 
933e 21 62 93			ld hl, .configmn 
9341 cd e0 8a			call menu 
9344			 
9344 fe 00			cp 0 
9346 c8				ret z 
9347			 
9347			;	cp 1 
9347			;	call z, .savetostore 
9347			 
9347 fe 01			cp 1 
9349			if STARTUP_V1 
9349 cc 78 93			call z, .selautoload 
934c			endif 
934c			 
934c			if STARTUP_V2 
934c				call z, .enautoload 
934c			endif 
934c fe 02			cp 2 
934e cc 6e 93			call z, .disautoload 
9351			;	cp 3 
9351			;	call z, .selbank 
9351 fe 03			cp 3 
9353 cc 96 93			call z, .debug_tog 
9356 fe 04			cp 4 
9358 cc e4 94			call z, .bpsgo 
935b fe 05			cp 5 
935d cc bf 93			call z, hardware_diags 
9360			if STARTUP_V2 
9360				cp 6 
9360				call z, create_startup 
9360			endif 
9360 18 da			jr config 
9362			 
9362			.configmn: 
9362			;	dw prom_c3 
9362 d2 96			dw prom_c2 
9364 e7 96			dw prom_c2a 
9366			;	dw prom_c2b 
9366			;	dw prom_c4 
9366 06 97			dw prom_m4 
9368 21 97			dw prom_m4b 
936a 29 97			dw prom_c1 
936c			if STARTUP_V2 
936c				dw prom_c9 
936c			endif 
936c 00 00			dw 0 
936e				 
936e			 
936e			if STARTUP_V2 
936e			.enautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 1 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e				ld hl, prom_notav 
936e				ld de, prom_empty 
936e				call info_panel 
936e				endif 
936e			 
936e			 
936e				ret 
936e			endif 
936e			 
936e			.disautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 0 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e 21 38 97			ld hl, prom_notav 
9371 11 4e 97			ld de, prom_empty 
9374 cd 40 8a			call info_panel 
9377				endif 
9377			 
9377			 
9377 c9				ret 
9378			 
9378			if STARTUP_V1 
9378			 
9378			; Select auto start 
9378			 
9378			.selautoload: 
9378			 
9378				 
9378				if STORAGE_SE 
9378			 
9378					call config_dir 
9378				        ld hl, scratch 
9378					ld a, 0 
9378					call menu 
9378			 
9378					cp 0 
9378					ret z 
9378			 
9378					dec a 
9378			 
9378			 
9378					; locate menu option 
9378			 
9378					ld hl, scratch 
9378					call table_lookup 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALl" 
9378						CALLMONITOR 
9378					endif 
9378					; with the pointer to the menu it, the byte following the zero term is the file id 
9378			 
9378					ld a, 0 
9378					ld bc, 50   ; max of bytes to look at 
9378					cpir  
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALb" 
9378						CALLMONITOR 
9378					endif 
9378					;inc hl 
9378			 
9378					ld a, (hl)   ; file id 
9378					 
9378				        ; save bank and file ids 
9378			 
9378					push af 
9378			 
9378			; TODO need to save to block 0 on bank 1	 
9378			 
9378					call storage_get_block_0 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "AL0" 
9378						CALLMONITOR 
9378					endif 
9378					pop af 
9378			 
9378					ld (store_page+STORE_0_FILERUN),a 
9378					 
9378					; save bank id 
9378			 
9378					ld a,(spi_device) 
9378					ld (store_page+STORE_0_BANKRUN),a 
9378			 
9378					; enable auto run of store file 
9378			 
9378					ld a, 1 
9378					ld (store_page+STORE_0_AUTOFILE),a 
9378			 
9378					; save buffer 
9378			 
9378					ld hl, 0 
9378					ld de, store_page 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALw" 
9378						CALLMONITOR 
9378					endif 
9378				call storage_write_block	 ; save update 
9378			  
9378			 
9378			 
9378			 
9378					ld hl, scratch 
9378					call config_fdir 
9378			 
9378				else 
9378			 
9378 21 38 97			ld hl, prom_notav 
937b 11 4e 97			ld de, prom_empty 
937e cd 40 8a			call info_panel 
9381			 
9381				endif 
9381 c9				ret 
9382			endif 
9382			 
9382			 
9382			; Select storage bank 
9382			 
9382			.selbank: 
9382			 
9382			;	if STORAGE_SE 
9382			;	else 
9382			 
9382 21 38 97			ld hl, prom_notav 
9385 11 4e 97			ld de, prom_empty 
9388 cd 40 8a			call info_panel 
938b			;	endif 
938b				 
938b c9				ret 
938c			 
938c			if STORAGE_SE 
938c			 
938c			.config_ldir:   
938c				; Load storage bank labels into menu array 
938c			 
938c				 
938c			 
938c			 
938c				ret 
938c			 
938c			 
938c			endif 
938c			 
938c			 
938c			; Save user words to storage 
938c			 
938c			.savetostore: 
938c			 
938c			;	if STORAGE_SE 
938c			; 
938c			;		call config_dir 
938c			;	        ld hl, scratch 
938c			;		ld a, 0 
938c			;		call menu 
938c			;		 
938c			;		ld hl, scratch 
938c			;		call config_fdir 
938c			; 
938c			;	else 
938c			 
938c 21 38 97			ld hl, prom_notav 
938f 11 4e 97			ld de, prom_empty 
9392 cd 40 8a			call info_panel 
9395			 
9395			;	endif 
9395			 
9395 c9				ret 
9396			 
9396			if STARTUP_V2 
9396			 
9396			create_startup: 
9396			 
9396				ld a, 0 
9396				ld hl, .crstart 
9396				call menu 
9396			 
9396				cp 0 
9396				ret z 
9396			 
9396				cp 1 
9396				call z, .genlsword 
9396				cp 2 
9396				call z, .genedword 
9396			 
9396				cp 3 
9396				call z, .gendemword 
9396			 
9396				cp 4 
9396				call z, .genutlword 
9396				cp 5 
9396				call z, .genspiword 
9396				cp 6 
9396				call z, .genkeyword 
9396				cp 7 
9396				call z, .gensoundword 
9396				jr create_startup 
9396			 
9396			.gensoundword: 
9396				ld hl, crs_sound 
9396				ld de, .soundworddef 
9396				call .genfile 
9396				ret 
9396			.genlsword: 
9396				ld hl, crs_s1 
9396				ld de, .lsworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			.genedword: 
9396				ld de, .edworddef 
9396				ld hl, crs_s2 
9396				call .genfile 
9396				ret 
9396			 
9396			.gendemword: 
9396				ld de, .demoworddef 
9396				ld hl, crs_s3 
9396				call .genfile 
9396				ret 
9396			 
9396			.genutlword: 
9396				ld hl, crs_s4 
9396				ld de, .utilwordef 
9396				call .genfile 
9396				ret 
9396			.genspiword: 
9396				ld hl, crs_s5 
9396				ld de, .spiworddef 
9396				call .genfile 
9396				ret 
9396			.genkeyword: 
9396				ld hl, crs_s6 
9396				ld de, .keyworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			; hl - points to file name 
9396			; de - points to strings to add to file 
9396			 
9396			.genfile: 
9396				push hl 
9396				push de 
9396			 
9396				call clear_display 
9396				ld a, display_row_1 
9396				ld de, .genfiletxt 
9396				call str_at_display 
9396				call update_display 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396			 
9396				push de 
9396				call storage_create 
9396				; id in hl 
9396				pop de   ; table of strings to add 
9396			 
9396			.genloop: 
9396			 
9396				push hl ; save id for next time around 
9396				push de ; save de for next time around 
9396			 
9396				ex de, hl 
9396				call loadwordinhl 
9396				ex de, hl 
9396			 
9396				; need hl to be the id 
9396				; need de to be the string ptr 
9396				 
9396				call storage_append 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396				inc de 
9396				inc de 
9396			 
9396				ld a,(de) 
9396				cp 0 
9396				jr nz, .genloop 
9396				inc de 
9396				ld a, (de) 
9396				dec de 
9396				cp 0 
9396				jr nz, .genloop	 
9396			 
9396				ret 
9396			 
9396			.genfiletxt:  db "Creating file...",0 
9396			 
9396			.soundworddef: 
9396				dw sound1 
9396				dw sound2 
9396				dw sound3 
9396				dw sound4 
9396				dw sound5 
9396				dw sound6 
9396				dw sound7 
9396				dw sound8 
9396				dw sound9 
9396				dw 0 
9396			 
9396			.utilwordef: 
9396				dw strncpy 
9396				dw type 
9396				dw clrstack 
9396				dw longread 
9396				dw start1 
9396				dw start2 
9396				dw start3b 
9396				dw start3c 
9396				dw list 
9396				dw 0 
9396			 
9396			.lsworddef: 
9396				dw start3b 
9396				dw 0 
9396			 
9396			.edworddef: 
9396				dw edit1 
9396				dw edit2 
9396				dw edit3 
9396				dw 0 
9396			 
9396			.demoworddef: 
9396				dw test5 
9396				dw test6 
9396				dw test7 
9396				dw test8 
9396				dw test9 
9396				dw test10 
9396				dw game1 
9396				dw game1a 
9396				dw game1b 
9396				dw game1c 
9396				dw game1d 
9396				dw game1s 
9396				dw game1t 
9396				dw game1f 
9396				dw game1z 
9396				dw game1zz 
9396				dw ssv2 
9396				dw ssv3 
9396				dw ssv4 
9396				dw ssv5 
9396				dw ssv1 
9396				dw ssv1cpm	 
9396				dw game2b 
9396				dw game2bf 
9396				dw game2mba 
9396				dw game2mbas	 
9396				dw game2mbht 
9396				dw game2mbms 
9396				dw game2mb 
9396				dw game3w 
9396				dw game3p 
9396				dw game3sc 
9396				dw game3vsi 
9396				dw game3vs 
9396				dw 0 
9396			 
9396			 
9396			.spiworddef: 
9396			 
9396			    dw spi1 
9396			    dw spi2 
9396			    dw spi3 
9396			    dw spi4 
9396			    dw spi5 
9396			    dw spi6 
9396			    dw spi7 
9396			 
9396			    dw spi8 
9396			    dw spi9 
9396			    dw spi10 
9396			    dw 0 
9396			 
9396			.keyworddef: 
9396			 
9396				dw keyup 
9396				dw keydown 
9396				dw keyleft 
9396				dw keyright 
9396				dw 	keyf1 
9396				dw keyf2 
9396				dw keyf3 
9396				dw keyf4 
9396				dw keyf5 
9396				dw keyf6 
9396				dw keyf7 
9396				dw keyf8 
9396				dw keyf9 
9396				dw keyf10 
9396				dw keyf11 
9396				dw keyf12 
9396				dw keytab 
9396				dw keycr 
9396				dw keyhome 
9396				dw keyend 
9396				dw keybs 
9396				dw 0 
9396			 
9396			.crstart: 
9396				dw crs_s1 
9396				dw crs_s2 
9396				dw crs_s3 
9396				dw crs_s4 
9396				dw crs_s5 
9396				dw crs_s6 
9396				dw 0 
9396			 
9396			endif 
9396			 
9396			 
9396			if STORAGE_SE 
9396			 
9396			config_fdir: 
9396				; using the scratch dir go through and release the memory allocated for each string 
9396				 
9396				ld hl, scratch 
9396			.cfdir:	ld e,(hl) 
9396				inc hl 
9396				ld d,(hl) 
9396				inc hl 
9396			 
9396				ex de, hl 
9396				call ishlzero 
9396				ret z     ; return on null pointer 
9396				call free 
9396				ex de, hl 
9396				jr .cfdir 
9396			 
9396			 
9396				ret 
9396			 
9396			 
9396			config_dir: 
9396			 
9396				; for the config menus that need to build a directory of storage call this routine 
9396				; it will construct a menu in scratch to pass to menu 
9396			 
9396				; open storage device 
9396			 
9396				; execute DIR to build a list of files and their ids into scratch in menu format 
9396				; once the menu has finished then will need to call config_fdir to release the strings 
9396				 
9396				; c = number items 
9396			 
9396				 
9396				call storage_get_block_0 
9396			 
9396				ld hl, store_page     ; get current id count 
9396				ld b, (hl) 
9396				ld c, 0    ; count of files   
9396			 
9396			 
9396				ld hl, scratch 
9396				ld (store_tmp2), hl    ; location to poke strings 
9396			 
9396				; check for empty drive 
9396			 
9396				ld a, 0 
9396				cp b 
9396				jp z, .dirdone 
9396			 
9396				 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdc" 
9396						CALLMONITOR 
9396					endif 
9396			 
9396			 
9396			.diritem:	 
9396				push bc 
9396				; for each of the current ids do a search for them and if found push to stack 
9396			 
9396					ld hl, STORE_BLOCK_PHY 
9396					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9396					ld e,b 
9396			 
9396					call storage_findnextid 
9396			 
9396			 
9396					; if found hl will be non zero 
9396			 
9396					call ishlzero 
9396					jr z, .dirnotfound 
9396			 
9396					; increase count 
9396			 
9396					pop bc	 
9396					inc c 
9396					push bc 
9396					 
9396			 
9396					; get file header and push the file name 
9396			 
9396					ld de, store_page 
9396					call storage_read_block 
9396			 
9396					; push file id to stack 
9396				 
9396					ld a, (store_page) 
9396					ld h, 0 
9396					ld l, a 
9396			 
9396					;call forth_push_numhl 
9396					; TODO store id 
9396			 
9396					push hl 
9396			 
9396					; push extent count to stack  
9396				 
9396					ld hl, store_page+3 
9396			 
9396					; get file name length 
9396			 
9396					call strlenz   
9396			 
9396					inc hl   ; cover zero term 
9396					inc hl  ; stick the id at the end of the area 
9396			 
9396					push hl 
9396					pop bc    ; move length to bc 
9396			 
9396					call malloc 
9396			 
9396					; TODO save malloc area to scratch 
9396			 
9396					ex de, hl 
9396					ld hl, (store_tmp2) 
9396					ld (hl), e 
9396					inc hl 
9396					ld (hl), d 
9396					inc hl 
9396					ld (store_tmp2), hl 
9396			 
9396					 
9396			 
9396					;pop hl   ; get source 
9396			;		ex de, hl    ; swap aronund	 
9396			 
9396					ld hl, store_page+3 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "CFd" 
9396						CALLMONITOR 
9396					endif 
9396					ldir 
9396			 
9396					; de is past string, move back one and store id 
9396					 
9396					dec de 
9396			 
9396					; store file id 
9396			 
9396					pop hl 
9396					ex de,hl 
9396					ld (hl), e 
9396			 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdi" 
9396						CALLMONITOR 
9396					endif 
9396					 
9396			.dirnotfound: 
9396					pop bc     
9396					djnz .diritem 
9396				 
9396			.dirdone:	 
9396			 
9396					ld a, 0 
9396					ld hl, (store_tmp2) 
9396					ld (hl), a 
9396					inc hl 
9396					ld (hl), a 
9396					inc hl 
9396					; push a count of the dir items found 
9396			 
9396			;		ld h, 0 
9396			;		ld l, c 
9396			 
9396				ret 
9396			 
9396			endif 
9396			 
9396			 
9396			; Settings 
9396			; Run  
9396			 
9396			 
9396			 
9396			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9396			;;hd_menu2:   db "        2: Editor",0   
9396			;hd_menu2:   db "        2: Editor       6: Menu",0   
9396			;hd_menu3:   db "        3: Storage",0 
9396			;hd_menu4:   db "0=quit  4: Debug",0 
9396			;hd_don:     db "ON",0 
9396			;hd_doff:     db "OFF",0 
9396			; 
9396			; 
9396			; 
9396			;hardware_diags_old:       
9396			; 
9396			;.diagmenu: 
9396			;	call clear_display 
9396			;	ld a, display_row_1 
9396			;	ld de, hd_menu1 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_2 
9396			;	ld de, hd_menu2 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_3 
9396			;	ld de, hd_menu3 
9396			;	call str_at_display 
9396			; 
9396			;	ld a,  display_row_4 
9396			;	ld de, hd_menu4 
9396			;	call str_at_display 
9396			; 
9396			;	; display debug state 
9396			; 
9396			;	ld de, hd_don 
9396			;	ld a, (os_view_disable) 
9396			;	cp 0 
9396			;	jr z, .distog 
9396			;	ld de, hd_doff 
9396			;.distog: ld a, display_row_4+17 
9396			;	call str_at_display 
9396			; 
9396			;	call update_display 
9396			; 
9396			;	call cin_wait 
9396			; 
9396			; 
9396			; 
9396			;	cp '4' 
9396			;	jr nz, .diagn1 
9396			; 
9396			;	; debug toggle 
9396			; 
9396			;	ld a, (os_view_disable) 
9396			;	ld b, '*' 
9396			;	cp 0 
9396			;	jr z, .debtog 
9396			;	ld b, 0 
9396			;.debtog:	 
9396			;	ld a,b 
9396			;	ld (os_view_disable),a 
9396			; 
9396			;.diagn1: cp '0' 
9396			;	 ret z 
9396			; 
9396			;;	cp '1' 
9396			;;       jp z, matrix	 
9396			;;   TODO keyboard matrix test 
9396			; 
9396			;	cp '2' 
9396			;	jp z, .diagedit 
9396			; 
9396			;;	cp '6' 
9396			;;	jp z, .menutest 
9396			;;if ENABLE_BASIC 
9396			;;	cp '6' 
9396			;;	jp z, basic 
9396			;;endif 
9396			 ; 
9396			;	jp .diagmenu 
9396			; 
9396			; 
9396			;	ret 
9396			 
9396			 
9396			.debug_tog: 
9396 21 e0 93			ld hl, .menudebug 
9399				 
9399			;	ld a, (os_view_disable) 
9399			;	cp '*' 
9399 3a 6f ee			ld a,(debug_vector) 
939c fe c9			cp $C9   ; RET 
939e 20 04			jr nz,.tdon  
93a0 3e 01			ld a, 1 
93a2 18 02			jr .tog1 
93a4 3e 00		.tdon: ld a, 0 
93a6			 
93a6			.tog1: 
93a6 cd e0 8a			call menu 
93a9 fe 00			cp 0 
93ab c8				ret z 
93ac fe 01			cp 1    ; disable debug 
93ae 28 04			jr z, .dtog0 
93b0 3e 2a			ld a, '*' 
93b2 18 05			jr .dtogset 
93b4			.dtog0:  
93b4				;ld a, 0 
93b4 cd d2 94			call bp_on 
93b7 18 dd			jr .debug_tog 
93b9			.dtogset:  
93b9				; ld (os_view_disable), a 
93b9 cd de 94			call bp_off 
93bc c3 96 93			jp .debug_tog 
93bf			 
93bf			 
93bf			hardware_diags:       
93bf			 
93bf			.diagm: 
93bf 21 d2 93			ld hl, .menuitems 
93c2 3e 00			ld a, 0 
93c4 cd e0 8a			call menu 
93c7			 
93c7 fe 00		         cp 0 
93c9 c8				 ret z 
93ca			 
93ca fe 02			cp 2 
93cc ca 2b 94			jp z, .diagedit 
93cf			 
93cf			;	cp '6' 
93cf			;	jp z, .menutest 
93cf			;if ENABLE_BASIC 
93cf			;	cp '6' 
93cf			;	jp z, basic 
93cf			;endif 
93cf			  
93cf c3 bf 93			jp .diagm 
93d2			 
93d2				 
93d2 e6 93		.menuitems:   	dw .m1 
93d4 f1 93				dw .m2 
93d6 f8 93				dw .m3 
93d8 00 94				dw .m5 
93da 06 94				dw .m5a 
93dc 0f 94				dw .m5b 
93de 00 00				dw 0 
93e0			 
93e0			.menudebug: 
93e0 18 94				dw .m6 
93e2 21 94				dw .m7 
93e4 00 00				dw 0 
93e6			 
93e6 .. 00		.m1:   db "Key Matrix",0 
93f1 .. 00		.m2:   db "Editor",0 
93f8 .. 00		.m3:   db "Storage",0 
9400 .. 00		.m5:   db "Sound",0 
9406 .. 00		.m5a:  db "RAM Test",0 
940f .. 00		.m5b:  db "LCD Test",0 
9418			 
9418 .. 00		.m6:   db "Debug ON",0 
9421 .. 00		.m7:   db "Debug OFF",0 
942b			 
942b			; debug editor 
942b			 
942b			.diagedit: 
942b			 
942b 21 c1 e2			ld hl, scratch 
942e			;	ld bc, 250 
942e			;	ldir 
942e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
942e 3e 00			ld a, 0 
9430 77				ld (hl), a 
9431 23				inc hl 
9432 77				ld (hl), a 
9433 23				inc hl 
9434 77				ld (hl), a 
9435			 
9435 cd af 8a		        call clear_display 
9438 cd d2 8a			call update_display 
943b				;ld a, 1 
943b				;ld (hardware_diag), a 
943b			.diloop: 
943b 3e 00			ld a, display_row_1 
943d 0e 00			ld c, 0 
943f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9441 1e 28			ld e, 40 
9443			 
9443 21 c1 e2			ld hl, scratch	 
9446 cd 09 8d			call input_str 
9449			 
9449 3e 28			ld a, display_row_2 
944b 11 c1 e2			ld de, scratch 
944e cd c2 8a			call str_at_display 
9451 cd d2 8a			call update_display 
9454			 
9454 c3 3b 94			jp .diloop 
9457			 
9457			 
9457			; pass word in hl 
9457			; a has display location 
9457			display_word_at: 
9457 f5				push af 
9458 e5				push hl 
9459 7c				ld a,h 
945a 21 c6 e5			ld hl, os_word_scratch 
945d cd dd 8f			call hexout 
9460 e1				pop hl 
9461 7d				ld a,l 
9462 21 c8 e5			ld hl, os_word_scratch+2 
9465 cd dd 8f			call hexout 
9468 21 ca e5			ld hl, os_word_scratch+4 
946b 3e 00			ld a,0 
946d 77				ld (hl),a 
946e 11 c6 e5			ld de,os_word_scratch 
9471 f1				pop af 
9472 cd c2 8a				call str_at_display 
9475 c9				ret 
9476			 
9476			display_ptr_state: 
9476			 
9476				; to restore afterwards 
9476			 
9476 d5				push de 
9477 c5				push bc 
9478 e5				push hl 
9479 f5				push af 
947a			 
947a				; for use in here 
947a			 
947a			;	push bc 
947a			;	push de 
947a			;	push hl 
947a			;	push af 
947a			 
947a cd af 8a			call clear_display 
947d			 
947d 11 55 96			ld de, .ptrstate 
9480 3e 00			ld a, display_row_1 
9482 cd c2 8a			call str_at_display 
9485			 
9485				; display debug step 
9485			 
9485			 
9485 11 6b ee			ld de, debug_mark 
9488 3e 26			ld a, display_row_1+display_cols-2 
948a cd c2 8a			call str_at_display 
948d			 
948d				; display a 
948d 11 5f 96			ld de, .ptrcliptr 
9490 3e 28			ld a, display_row_2 
9492 cd c2 8a			call str_at_display 
9495			 
9495 f1				pop af 
9496 2a 40 ea			ld hl,(cli_ptr) 
9499 3e 30			ld a, display_row_2+8 
949b cd 57 94			call display_word_at 
949e			 
949e			 
949e				; display hl 
949e			 
949e			 
949e 11 67 96			ld de, .ptrclioptr 
94a1 3e 32			ld a, display_row_2+10 
94a3 cd c2 8a			call str_at_display 
94a6			; 
94a6			;	pop hl 
94a6 3e 35			ld a, display_row_2+13 
94a8 2a 3e ea			ld hl,(cli_origptr) 
94ab cd 57 94			call display_word_at 
94ae			; 
94ae			;	 
94ae			;	; display de 
94ae			 
94ae			;	ld de, .regstatede 
94ae			;	ld a, display_row_3 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop de 
94ae			;	ld h,d 
94ae			;	ld l, e 
94ae			;	ld a, display_row_3+3 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display bc 
94ae			 
94ae			;	ld de, .regstatebc 
94ae			;	ld a, display_row_3+10 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop bc 
94ae			;	ld h,b 
94ae			;	ld l, c 
94ae			;	ld a, display_row_3+13 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display dsp 
94ae			 
94ae			;	ld de, .regstatedsp 
94ae			;	ld a, display_row_4 
94ae			;	call str_at_display 
94ae			 
94ae				 
94ae			;	ld hl,(cli_data_sp) 
94ae			;	ld a, display_row_4+4 
94ae			;	call display_word_at 
94ae			 
94ae				; display rsp 
94ae			 
94ae 11 96 96			ld de, .regstatersp 
94b1 3e 82			ld a, display_row_4+10 
94b3 cd c2 8a			call str_at_display 
94b6			 
94b6				 
94b6 2a f2 e9			ld hl,(cli_ret_sp) 
94b9 3e 86			ld a, display_row_4+14 
94bb cd 57 94			call display_word_at 
94be			 
94be cd d2 8a			call update_display 
94c1			 
94c1 cd f2 89			call delay1s 
94c4 cd f2 89			call delay1s 
94c7 cd f2 89			call delay1s 
94ca			 
94ca			 
94ca cd c3 9a			call next_page_prompt 
94cd			 
94cd				; restore  
94cd			 
94cd f1				pop af 
94ce e1				pop hl 
94cf c1				pop bc 
94d0 d1				pop de 
94d1 c9				ret 
94d2			 
94d2			; Update the break point vector so that the user can hook a new routine 
94d2			 
94d2			bp_on: 
94d2 3e c3			ld a, $c3    ; JP 
94d4 32 6f ee			ld (debug_vector), a 
94d7 21 e4 94			ld hl, break_point_state 
94da 22 70 ee			ld (debug_vector+1), hl 
94dd c9				ret 
94de			 
94de			bp_off: 
94de 3e c9			ld a, $c9    ; RET 
94e0 32 6f ee			ld (debug_vector), a 
94e3 c9				ret 
94e4			 
94e4			 
94e4			break_point_state: 
94e4			;	push af 
94e4			; 
94e4			;	; see if disabled 
94e4			; 
94e4			;	ld a, (os_view_disable) 
94e4			;	cp '*' 
94e4			;	jr nz, .bpsgo 
94e4			;	pop af 
94e4			;	ret 
94e4			 
94e4			.bpsgo: 
94e4			;	pop af 
94e4 f5				push af 
94e5 22 af e2			ld (os_view_hl), hl 
94e8 ed 53 ad e2		ld (os_view_de), de 
94ec ed 43 ab e2		ld (os_view_bc), bc 
94f0 e5				push hl 
94f1 6f				ld l, a 
94f2 26 00			ld h, 0 
94f4 22 b1 e2			ld (os_view_af),hl 
94f7			 
94f7 21 b1 ed				ld hl, display_fb0 
94fa 22 cc eb				ld (display_fb_active), hl 
94fd e1				pop hl	 
94fe			 
94fe 3e 31			ld a, '1' 
9500 fe 2a		.bps1:  cp '*' 
9502 cc de 94			call z, bp_off 
9505			;	jr nz, .bps1b 
9505			;	ld (os_view_disable),a 
9505 fe 31		.bps1b:  cp '1' 
9507 20 14			jr nz, .bps2 
9509			 
9509				; display reg 
9509			 
9509				 
9509			 
9509 3a b1 e2			ld a, (os_view_af) 
950c 2a af e2			ld hl, (os_view_hl) 
950f ed 5b ad e2		ld de, (os_view_de) 
9513 ed 4b ab e2		ld bc, (os_view_bc) 
9517 cd b1 95			call display_reg_state 
951a c3 9d 95			jp .bpschk 
951d			 
951d fe 32		.bps2:  cp '2' 
951f 20 08			jr nz, .bps3 
9521				 
9521				; display hl 
9521 2a af e2			ld hl, (os_view_hl) 
9524 cd 9b 96			call display_dump_at_hl 
9527			 
9527 18 74			jr .bpschk 
9529			 
9529 fe 33		.bps3:  cp '3' 
952b 20 08			jr nz, .bps4 
952d			 
952d			        ; display de 
952d 2a ad e2			ld hl, (os_view_de) 
9530 cd 9b 96			call display_dump_at_hl 
9533			 
9533 18 68			jr .bpschk 
9535 fe 34		.bps4:  cp '4' 
9537 20 08			jr nz, .bps5 
9539			 
9539			        ; display bc 
9539 2a ab e2			ld hl, (os_view_bc) 
953c cd 9b 96			call display_dump_at_hl 
953f			 
953f 18 5c			jr .bpschk 
9541 fe 35		.bps5:  cp '5' 
9543 20 08		        jr nz, .bps7 
9545			 
9545				; display cur ptr 
9545 2a 40 ea			ld hl, (cli_ptr) 
9548 cd 9b 96			call display_dump_at_hl 
954b			 
954b 18 50			jr .bpschk 
954d fe 36		.bps7:  cp '6' 
954f 20 08			jr nz, .bps8b 
9551				 
9551				; display cur orig ptr 
9551 2a 3e ea			ld hl, (cli_origptr) 
9554 cd 9b 96			call display_dump_at_hl 
9557 18 44			jr .bpschk 
9559 fe 37		.bps8b:  cp '7' 
955b 20 08			jr nz, .bps9 
955d				 
955d				; display dsp 
955d 2a ee e9			ld hl, (cli_data_sp) 
9560 cd 9b 96			call display_dump_at_hl 
9563			 
9563 18 38			jr .bpschk 
9565 fe 39		.bps9:  cp '9' 
9567 20 05			jr nz, .bps8c 
9569				 
9569				; display SP 
9569			;	ld hl, sp 
9569 cd 9b 96			call display_dump_at_hl 
956c			 
956c 18 2f			jr .bpschk 
956e fe 38		.bps8c:  cp '8' 
9570 20 08			jr nz, .bps8d 
9572				 
9572				; display rsp 
9572 2a f2 e9			ld hl, (cli_ret_sp) 
9575 cd 9b 96			call display_dump_at_hl 
9578			 
9578 18 23			jr .bpschk 
957a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
957c 20 05			jr nz, .bps8 
957e cd 91 98			call monitor 
9581			 
9581 18 1a			jr .bpschk 
9583 fe 30		.bps8:  cp '0' 
9585 20 16			jr nz, .bpschk 
9587			 
9587 21 10 ed				ld hl, display_fb1 
958a 22 cc eb				ld (display_fb_active), hl 
958d cd d2 8a				call update_display 
9590			 
9590				;ld a, (os_view_af) 
9590 2a af e2			ld hl, (os_view_hl) 
9593 ed 5b ad e2		ld de, (os_view_de) 
9597 ed 4b ab e2		ld bc, (os_view_bc) 
959b f1				pop af 
959c c9				ret 
959d			 
959d			.bpschk:   
959d cd f2 89			call delay1s 
95a0 3e 9f		ld a,display_row_4 + display_cols - 1 
95a2 11 c1 9a		        ld de, endprg 
95a5 cd c2 8a			call str_at_display 
95a8 cd d2 8a			call update_display 
95ab cd c8 e3			call cin_wait 
95ae			 
95ae c3 00 95			jp .bps1 
95b1			 
95b1			 
95b1			display_reg_state: 
95b1			 
95b1				; to restore afterwards 
95b1			 
95b1 d5				push de 
95b2 c5				push bc 
95b3 e5				push hl 
95b4 f5				push af 
95b5			 
95b5				; for use in here 
95b5			 
95b5 c5				push bc 
95b6 d5				push de 
95b7 e5				push hl 
95b8 f5				push af 
95b9			 
95b9 cd af 8a			call clear_display 
95bc			 
95bc 11 71 96			ld de, .regstate 
95bf 3e 00			ld a, display_row_1 
95c1 cd c2 8a			call str_at_display 
95c4			 
95c4				; display debug step 
95c4			 
95c4			 
95c4 11 6b ee			ld de, debug_mark 
95c7 3e 25			ld a, display_row_1+display_cols-3 
95c9 cd c2 8a			call str_at_display 
95cc			 
95cc				; display a 
95cc 11 8d 96			ld de, .regstatea 
95cf 3e 28			ld a, display_row_2 
95d1 cd c2 8a			call str_at_display 
95d4			 
95d4 e1				pop hl 
95d5			;	ld h,0 
95d5			;	ld l, a 
95d5 3e 2b			ld a, display_row_2+3 
95d7 cd 57 94			call display_word_at 
95da			 
95da			 
95da				; display hl 
95da			 
95da			 
95da 11 81 96			ld de, .regstatehl 
95dd 3e 32			ld a, display_row_2+10 
95df cd c2 8a			call str_at_display 
95e2			 
95e2 e1				pop hl 
95e3 3e 35			ld a, display_row_2+13 
95e5 cd 57 94			call display_word_at 
95e8			 
95e8				 
95e8				; display de 
95e8			 
95e8 11 85 96			ld de, .regstatede 
95eb 3e 50			ld a, display_row_3 
95ed cd c2 8a			call str_at_display 
95f0			 
95f0 e1				pop hl 
95f1			;	ld h,d 
95f1			;	ld l, e 
95f1 3e 53			ld a, display_row_3+3 
95f3 cd 57 94			call display_word_at 
95f6			 
95f6			 
95f6				; display bc 
95f6			 
95f6 11 89 96			ld de, .regstatebc 
95f9 3e 5a			ld a, display_row_3+10 
95fb cd c2 8a			call str_at_display 
95fe			 
95fe e1				pop hl 
95ff			;	ld h,b 
95ff			;	ld l, c 
95ff 3e 5d			ld a, display_row_3+13 
9601 cd 57 94			call display_word_at 
9604			 
9604			 
9604				; display dsp 
9604			 
9604 11 91 96			ld de, .regstatedsp 
9607 3e 78			ld a, display_row_4 
9609 cd c2 8a			call str_at_display 
960c			 
960c				 
960c 2a ee e9			ld hl,(cli_data_sp) 
960f 3e 7c			ld a, display_row_4+4 
9611 cd 57 94			call display_word_at 
9614			 
9614				; display rsp 
9614			 
9614 11 96 96			ld de, .regstatersp 
9617 3e 82			ld a, display_row_4+10 
9619 cd c2 8a			call str_at_display 
961c			 
961c				 
961c 2a f2 e9			ld hl,(cli_ret_sp) 
961f 3e 86			ld a, display_row_4+14 
9621 cd 57 94			call display_word_at 
9624			 
9624 cd d2 8a			call update_display 
9627			 
9627			;	call delay1s 
9627			;	call delay1s 
9627			;	call delay1s 
9627			 
9627			 
9627			;	call next_page_prompt 
9627			 
9627				; restore  
9627			 
9627 f1				pop af 
9628 e1				pop hl 
9629 c1				pop bc 
962a d1				pop de 
962b c9				ret 
962c			 
962c .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9640 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9655 .. 00		.ptrstate:	db "Ptr State",0 
965f .. 00		.ptrcliptr:     db "cli_ptr",0 
9667 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9671 .. 00		.regstate:	db "Reg State (1/0)",0 
9681 .. 00		.regstatehl:	db "HL:",0 
9685 .. 00		.regstatede:	db "DE:",0 
9689 .. 00		.regstatebc:	db "BC:",0 
968d .. 00		.regstatea:	db "A :",0 
9691 .. 00		.regstatedsp:	db "DSP:",0 
9696 .. 00		.regstatersp:	db "RSP:",0 
969b			 
969b			display_dump_at_hl: 
969b e5				push hl 
969c d5				push de 
969d c5				push bc 
969e f5				push af 
969f			 
969f 22 e4 e5			ld (os_cur_ptr),hl	 
96a2 cd af 8a			call clear_display 
96a5 cd cb 99			call dumpcont 
96a8			;	call delay1s 
96a8			;	call next_page_prompt 
96a8			 
96a8			 
96a8 f1				pop af 
96a9 c1				pop bc 
96aa d1				pop de 
96ab e1				pop hl 
96ac c9				ret 
96ad			 
96ad			;if ENABLE_BASIC 
96ad			;	include "nascombasic.asm" 
96ad			;	basic: 
96ad			;	include "forth/FORTH.ASM" 
96ad			;endif 
96ad			 
96ad			; eof 
96ad			 
96ad			 
# End of file firmware_diags.asm
96ad			  
96ad			include "firmware_prompts.asm"  
96ad			; Prompts  
96ad			 
96ad			; boot messages 
96ad			 
96ad .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
96c2 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
96d2			 
96d2			 
96d2			; config menus 
96d2			 
96d2			;prom_c3: db "Add Dictionary To File",0 
96d2			 
96d2			if STARTUP_V1 
96d2 .. 00		prom_c2: db "Select Autoload File",0 
96e7 .. 00		prom_c2a: db "Disable Autoload File", 0 
96fd			endif 
96fd			 
96fd			if STARTUP_V2 
96fd			prom_c2: db "Enable Autoload Files",0 
96fd			prom_c2a: db "Disable Autoload Files", 0 
96fd			 
96fd			crs_s1: db "*ls-word", 0 
96fd			crs_s2: db "*ed-word", 0 
96fd			crs_s3: db "*Demo-Programs", 0 
96fd			crs_s4: db "*Utils", 0 
96fd			crs_s5: db "*SPI-Addons", 0 
96fd			crs_s6: db "*Key-constants", 0 
96fd			crs_sound: db "*Sound-Util", 0 
96fd			 
96fd			 
96fd			 
96fd			endif 
96fd			;prom_c2b: db "Select Storage Bank",0 
96fd .. 00		prom_c4: db "Settings",0 
9706 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9721 .. 00		prom_m4b:   db "Monitor",0 
9729 .. 00		prom_c1: db "Hardware Diags",0 
9738			 
9738			 
9738			if STARTUP_V2 
9738			prom_c9: db "Create Startup Files",0 
9738			endif 
9738			 
9738 .. 00		prom_notav:    db "Feature not available",0 
974e .. 00		prom_empty:    db "",0 
974f			 
974f			; eof 
974f			 
# End of file firmware_prompts.asm
974f			  
974f			  
974f			; eof  
974f			  
# End of file firmware.asm
974f			 
974f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
974f			;if BASE_KEV  
974f			;baseram: equ 08000h 
974f			;endif 
974f			 
974f			;if BASE_SC114 
974f			;baseram:     equ    endofcode 
974f			;endif 
974f			 
974f			 
974f			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
974f			 
974f			; start system 
974f			 
974f			coldstart: 
974f				; set sp 
974f				; di/ei 
974f			 
974f f3				di 
9750 31 00 f0			ld sp, tos 
9753 cd 12 e3			call init_nmi 
9756			;	ei 
9756			 
9756				; init spinner 
9756 3e 00			ld a,0 
9758 32 c6 eb			ld (display_active), a 
975b			 
975b				; disable breakpoint by default 
975b			 
975b				;ld a,'*' 
975b			;	ld a,' ' 
975b			;	ld (os_view_disable),a 
975b			 
975b				; set break point vector as new break point on or off 
975b cd de 94			call bp_off 
975e			 
975e				; init hardware 
975e			 
975e				; init keyboard and screen hardware 
975e			 
975e cd 1c 80			call hardware_init 
9761			 
9761			 
9761 cd f2 89			call delay1s 
9764 3e 58			ld a, display_row_3+8 
9766 11 03 80			ld de, buildtime 
9769 cd c2 8a			call str_at_display 
976c cd d2 8a			call update_display 
976f			 
976f cd f2 89			call delay1s 
9772 cd f2 89			call delay1s 
9775 cd f2 89			call delay1s 
9778			 
9778				; detect if any keys are held down to enable breakpoints at start up 
9778			 
9778 cd ce e3			call cin  
977b fe 00			cp 0 
977d 28 03			jr z, .nokeys 
977f			 
977f				;call hardware_diags 
977f cd 3c 93			call config 
9782			 
9782			;	ld de, .bpen 
9782			;	ld a, display_row_4 
9782			;	call str_at_display 
9782			;	call update_display 
9782			; 
9782			;	ld a,0 
9782			;	ld (os_view_disable),a 
9782			; 
9782			;.bpwait: 
9782			;	call cin 
9782			;	cp 0 
9782			;	jr z, .bpwait 
9782			;	jr .nokeys 
9782			; 
9782			; 
9782			;.bpen:  db "Break points enabled!",0 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			.nokeys: 
9782			 
9782			 
9782				 
9782			 
9782			;jp  testkey 
9782			 
9782			;call storage_get_block_0 
9782			; 
9782			;ld hl, 0 
9782			;ld de, store_page 
9782			;call storage_read_block 
9782			 
9782				 
9782			;ld hl, 10 
9782			;ld de, store_page 
9782			;call storage_read_block 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			;stop:	nop 
9782			;	jp stop 
9782			 
9782			 
9782			 
9782			main: 
9782 cd af 8a			call clear_display 
9785 cd d2 8a			call update_display 
9788			 
9788			 
9788			 
9788			;	call testlcd 
9788			 
9788			 
9788			 
9788 cd c8 9e			call forth_init 
978b			 
978b			 
978b			warmstart: 
978b cd 9e 9e			call forth_warmstart 
978e			 
978e				; run startup word load 
978e			        ; TODO prevent this running at warmstart after crash  
978e			 
978e				if STARTUP_ENABLE 
978e			 
978e					if STARTUP_V1 
978e			 
978e						if STORAGE_SE 
978e							call forth_autoload 
978e						endif 
978e cd 62 e2					call forth_startup 
9791					endif 
9791			 
9791					if STARTUP_V2 
9791			 
9791						if STORAGE_SE 
9791							call forth_autoload 
9791						else 
9791							call forth_startup 
9791						endif 
9791			 
9791			 
9791					endif 
9791			 
9791				endif 
9791			 
9791				; show free memory after boot 
9791 11 2b 98			ld de, freeram 
9794 3e 00			ld a, display_row_1 
9796 cd c2 8a			call str_at_display 
9799			 
9799			; Or use heap_size word???? 
9799 21 a8 e2			ld hl, heap_end 
979c 11 ec e3			ld de, heap_start 
979f ed 52			sbc hl, de 
97a1 e5				push hl 
97a2 7c				ld a,h	         	 
97a3 21 c6 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97a6 cd dd 8f			call hexout 
97a9 e1			   	pop hl 
97aa			 
97aa 7d				ld a,l 
97ab 21 c8 e5			ld hl, os_word_scratch+2 
97ae cd dd 8f			call hexout 
97b1 21 ca e5			ld hl, os_word_scratch+4 
97b4 3e 00			ld a, 0 
97b6 77				ld (hl),a 
97b7 11 c6 e5			ld de, os_word_scratch 
97ba 3e 0d			ld a, display_row_1 + 13 
97bc cd c2 8a			call str_at_display 
97bf cd d2 8a			call update_display 
97c2			 
97c2			 
97c2				;call demo 
97c2			 
97c2			 
97c2				; init scratch input area for cli commands 
97c2			 
97c2 21 e8 e5			ld hl, os_cli_cmd 
97c5 3e 00			ld a,0 
97c7 77				ld (hl),a 
97c8 23				inc hl 
97c9 77				ld (hl),a 
97ca			 
97ca 3e 00			ld a,0 
97cc 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97cf			 
97cf 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97d2 32 e5 e5			ld (os_cur_ptr+1),a	 
97d5			 
97d5 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97d8 32 c7 e5			ld (os_word_scratch+1),a	 
97db				 
97db			 
97db				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97db 21 e8 e5			ld hl, os_cli_cmd 
97de			 
97de 3e 00			ld a, 0		 ; init cli input 
97e0 77				ld (hl), a 
97e1 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97e3			cli: 
97e3				; show cli prompt 
97e3				;push af 
97e3				;ld a, 0 
97e3				;ld de, prompt 
97e3				;call str_at_display 
97e3			 
97e3				;call update_display 
97e3				;pop af 
97e3				;inc a 
97e3				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97e3 0e 00			ld c, 0 
97e5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97e7 1e 28			ld e, 40 
97e9			 
97e9 21 e8 e5			ld hl, os_cli_cmd 
97ec			 
97ec				STACKFRAME OFF $fefe $9f9f 
97ec				if DEBUG_STACK_IMB 
97ec					if OFF 
97ec						exx 
97ec						ld de, $fefe 
97ec						ld a, d 
97ec						ld hl, curframe 
97ec						call hexout 
97ec						ld a, e 
97ec						ld hl, curframe+2 
97ec						call hexout 
97ec						ld hl, $fefe 
97ec						push hl 
97ec						ld hl, $9f9f 
97ec						push hl 
97ec						exx 
97ec					endif 
97ec				endif 
97ec			endm 
# End of macro STACKFRAME
97ec			 
97ec cd 09 8d			call input_str 
97ef			 
97ef				STACKFRAMECHK OFF $fefe $9f9f 
97ef				if DEBUG_STACK_IMB 
97ef					if OFF 
97ef						exx 
97ef						ld hl, $9f9f 
97ef						pop de   ; $9f9f 
97ef						call cmp16 
97ef						jr nz, .spnosame 
97ef						ld hl, $fefe 
97ef						pop de   ; $fefe 
97ef						call cmp16 
97ef						jr z, .spfrsame 
97ef						.spnosame: call showsperror 
97ef						.spfrsame: nop 
97ef						exx 
97ef					endif 
97ef				endif 
97ef			endm 
# End of macro STACKFRAMECHK
97ef			 
97ef				; copy input to last command 
97ef			 
97ef 21 e8 e5			ld hl, os_cli_cmd 
97f2 11 e7 e6			ld de, os_last_cmd 
97f5 01 ff 00			ld bc, 255 
97f8 ed b0			ldir 
97fa			 
97fa				; wipe current buffer 
97fa			 
97fa			;	ld a, 0 
97fa			;	ld hl, os_cli_cmd 
97fa			;	ld de, os_cli_cmd+1 
97fa			;	ld bc, 254 
97fa			;	ldir 
97fa				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97fa			;	call strcpy 
97fa			;	ld a, 0 
97fa			;	ld (hl), a 
97fa			;	inc hl 
97fa			;	ld (hl), a 
97fa			;	inc hl 
97fa			;	ld (hl), a 
97fa			 
97fa				; switch frame buffer to program  
97fa			 
97fa 21 10 ed				ld hl, display_fb1 
97fd 22 cc eb				ld (display_fb_active), hl 
9800			 
9800			;	nop 
9800				STACKFRAME ON $fbfe $8f9f 
9800				if DEBUG_STACK_IMB 
9800					if ON 
9800						exx 
9800						ld de, $fbfe 
9800						ld a, d 
9800						ld hl, curframe 
9800						call hexout 
9800						ld a, e 
9800						ld hl, curframe+2 
9800						call hexout 
9800						ld hl, $fbfe 
9800						push hl 
9800						ld hl, $8f9f 
9800						push hl 
9800						exx 
9800					endif 
9800				endif 
9800			endm 
# End of macro STACKFRAME
9800				; first time into the parser so pass over the current scratch pad 
9800 21 e8 e5			ld hl,os_cli_cmd 
9803				; tokenise the entered statement(s) in HL 
9803 cd 46 9f			call forthparse 
9806			        ; exec forth statements in top of return stack 
9806 cd 86 9f			call forthexec 
9809				;call forthexec_cleanup 
9809			;	call parsenext 
9809			 
9809				STACKFRAMECHK ON $fbfe $8f9f 
9809				if DEBUG_STACK_IMB 
9809					if ON 
9809						exx 
9809						ld hl, $8f9f 
9809						pop de   ; $8f9f 
9809						call cmp16 
9809						jr nz, .spnosame 
9809						ld hl, $fbfe 
9809						pop de   ; $fbfe 
9809						call cmp16 
9809						jr z, .spfrsame 
9809						.spnosame: call showsperror 
9809						.spfrsame: nop 
9809						exx 
9809					endif 
9809				endif 
9809			endm 
# End of macro STACKFRAMECHK
9809				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9809			 
9809 3e 78			ld a, display_row_4 
980b 11 3d 98			ld de, endprog 
980e			 
980e cd d2 8a			call update_display		 
9811			 
9811 cd c3 9a			call next_page_prompt 
9814			 
9814				; switch frame buffer to cli 
9814			 
9814 21 b1 ed				ld hl, display_fb0 
9817 22 cc eb				ld (display_fb_active), hl 
981a			 
981a			 
981a cd af 8a		        call clear_display 
981d cd d2 8a			call update_display		 
9820			 
9820 21 e8 e5			ld hl, os_cli_cmd 
9823			 
9823 3e 00			ld a, 0		 ; init cli input 
9825 77				ld (hl), a 
9826			 
9826				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9826			 
9826				; now on last line 
9826			 
9826				; TODO scroll screen up 
9826			 
9826				; TODO instead just clear screen and place at top of screen 
9826			 
9826			;	ld a, 0 
9826			;	ld (f_cursor_ptr),a 
9826			 
9826				;call clear_display 
9826				;call update_display 
9826			 
9826				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9826 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9828 c3 e3 97			jp cli 
982b			 
982b .. 00		freeram: db "Free bytes: $",0 
9839 ..			asc: db "1A2F" 
983d .. 00		endprog: db "End prog...",0 
9849			 
9849			testenter2:   
9849 21 f3 e2			ld hl,scratch+50 
984c 22 e4 e5			ld (os_cur_ptr),hl 
984f c3 e3 97			jp cli 
9852			 
9852			testenter:  
9852			 
9852 21 39 98			ld hl,asc 
9855			;	ld a,(hl) 
9855			;	call nibble2val 
9855 cd 33 90			call get_byte 
9858			 
9858			 
9858			;	ld a,(hl) 
9858			;	call atohex 
9858			 
9858			;	call fourehexhl 
9858 32 f3 e2			ld (scratch+50),a 
985b			 
985b			 
985b			 
985b 21 3b 98			ld hl,asc+2 
985e			;	ld a, (hl) 
985e			;	call nibble2val 
985e cd 33 90			call get_byte 
9861			 
9861			;	call fourehexhl 
9861 32 f5 e2			ld (scratch+52),a 
9864				 
9864 21 f3 e2			ld hl,scratch+50 
9867 22 e4 e5			ld (os_cur_ptr),hl 
986a c3 e3 97			jp cli 
986d			 
986d			enter:	 
986d 3a c5 e2			ld a,(scratch+4) 
9870 fe 00			cp 0 
9872 28 0c			jr z, .entercont 
9874				; no, not a null term line so has an address to work out.... 
9874			 
9874 21 c3 e2			ld hl,scratch+2 
9877 cd 93 90			call get_word_hl 
987a			 
987a 22 e4 e5			ld (os_cur_ptr),hl	 
987d c3 e3 97			jp cli 
9880			 
9880			 
9880			.entercont:  
9880			 
9880 21 c3 e2			ld hl, scratch+2 
9883 cd 33 90			call get_byte 
9886			 
9886 2a e4 e5		   	ld hl,(os_cur_ptr) 
9889 77					ld (hl),a 
988a 23					inc hl 
988b 22 e4 e5				ld (os_cur_ptr),hl 
988e				 
988e			; get byte  
988e			 
988e			 
988e c3 e3 97			jp cli 
9891			 
9891			 
9891			; basic monitor support 
9891			 
9891			monitor: 
9891				;  
9891 cd af 8a			call clear_display 
9894 3e 00			ld a, 0 
9896 11 e5 98			ld de, .monprompt 
9899 cd c2 8a			call str_at_display 
989c cd d2 8a			call update_display 
989f			 
989f				; get a monitor command 
989f			 
989f 0e 00			ld c, 0     ; entry at top left 
98a1 16 64			ld d, 100   ; max buffer size 
98a3 1e 0f			ld e, 15    ; input scroll area 
98a5 3e 00			ld a, 0     ; init string 
98a7 21 bf e4			ld hl, os_input 
98aa 77				ld (hl), a 
98ab 23				inc hl 
98ac 77				ld (hl), a 
98ad 21 bf e4			ld hl, os_input 
98b0 3e 01			ld a, 1     ; init string 
98b2 cd 09 8d			call input_str 
98b5			 
98b5 cd af 8a		        call clear_display 
98b8 cd d2 8a			call update_display		 
98bb			 
98bb 3a bf e4			ld a, (os_input) 
98be cd 31 91			call toUpper 
98c1 fe 48		        cp 'H' 
98c3 ca 4a 99		        jp z, .monhelp 
98c6 fe 44			cp 'D'		; dump 
98c8 ca 7d 99			jp z, .mondump	 
98cb fe 43			cp 'C'		; dump 
98cd ca 97 99			jp z, .moncdump	 
98d0 fe 4d			cp 'M'		; dump 
98d2 ca e7 98			jp z, .moneditstart 
98d5 fe 55			cp 'U'		; dump 
98d7 ca f3 98			jp z, .monedit	 
98da fe 47			cp 'G'		; dump 
98dc ca 73 99			jp z, .monjump 
98df fe 51			cp 'Q'		; dump 
98e1 c8				ret z	 
98e2			 
98e2			 
98e2				; TODO "S" to access symbol by name and not need the address 
98e2				; TODO "F" to find a string in memory 
98e2			 
98e2 c3 91 98			jp monitor 
98e5			 
98e5 .. 00		.monprompt: db ">", 0 
98e7			 
98e7			.moneditstart: 
98e7				; get starting address 
98e7			 
98e7 21 c1 e4			ld hl,os_input+2 
98ea cd 93 90			call get_word_hl 
98ed			 
98ed 22 e4 e5			ld (os_cur_ptr),hl	 
98f0			 
98f0 c3 91 98			jp monitor 
98f3			 
98f3			.monedit: 
98f3				; get byte to load 
98f3			 
98f3 21 c1 e4			ld hl,os_input+2 
98f6 cd 33 90			call get_byte 
98f9			 
98f9				; get address to update 
98f9 2a e4 e5			ld hl, (os_cur_ptr) 
98fc			 
98fc				; update byte 
98fc			 
98fc 77				ld (hl), a 
98fd			 
98fd				; move to next address and save it 
98fd			 
98fd 23				inc hl 
98fe 22 e4 e5			ld (os_cur_ptr),hl	 
9901			 
9901 c3 91 98			jp monitor 
9904			 
9904			 
9904 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9918 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9934 .. 00		.monhelptext3:  db "G-Call address",0 
9943 .. 00		.monhelptext4:  db "Q-Quit",0 
994a			        
994a			.monhelp: 
994a 3e 00			ld a, display_row_1 
994c 11 04 99		        ld de, .monhelptext1 
994f			 
994f cd c2 8a			call str_at_display 
9952 3e 28			ld a, display_row_2 
9954 11 18 99		        ld de, .monhelptext2 
9957					 
9957 cd c2 8a			call str_at_display 
995a 3e 50			ld a, display_row_3 
995c 11 34 99		        ld de, .monhelptext3 
995f					 
995f cd c2 8a			call str_at_display 
9962 3e 78			ld a, display_row_4 
9964 11 43 99		        ld de, .monhelptext4 
9967 cd c2 8a			call str_at_display 
996a			 
996a cd d2 8a			call update_display		 
996d			 
996d cd c3 9a			call next_page_prompt 
9970 c3 91 98			jp monitor 
9973			 
9973			.monjump:    
9973 21 c1 e4			ld hl,os_input+2 
9976 cd 93 90			call get_word_hl 
9979			 
9979 e9				jp (hl) 
997a c3 91 98			jp monitor 
997d			 
997d			.mondump:    
997d 21 c1 e4			ld hl,os_input+2 
9980 cd 93 90			call get_word_hl 
9983			 
9983 22 e4 e5			ld (os_cur_ptr),hl	 
9986 cd cb 99			call dumpcont 
9989 3e 78			ld a, display_row_4 
998b 11 3d 98			ld de, endprog 
998e			 
998e cd d2 8a			call update_display		 
9991			 
9991 cd c3 9a			call next_page_prompt 
9994 c3 91 98			jp monitor 
9997			.moncdump: 
9997 cd cb 99			call dumpcont 
999a 3e 78			ld a, display_row_4 
999c 11 3d 98			ld de, endprog 
999f			 
999f cd d2 8a			call update_display		 
99a2			 
99a2 cd c3 9a			call next_page_prompt 
99a5 c3 91 98			jp monitor 
99a8			 
99a8			 
99a8			; TODO symbol access  
99a8			 
99a8			.symbols:     ;; A list of symbols that can be called up  
99a8 b1 ed			dw display_fb0 
99aa .. 00			db "fb0",0  
99ae 7a ea		     	dw store_page 
99b0 .. 00			db "store_page",0 
99bb			 
99bb			 
99bb			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
99bb			 
99bb 3a c2 e2			ld a,(scratch+1) 
99be fe 00			cp 0 
99c0 28 09			jr z, dumpcont 
99c2			 
99c2				; no, not a null term line so has an address to work out.... 
99c2			 
99c2 21 c3 e2			ld hl,scratch+2 
99c5 cd 93 90			call get_word_hl 
99c8			 
99c8 22 e4 e5			ld (os_cur_ptr),hl	 
99cb			 
99cb			 
99cb			 
99cb			dumpcont: 
99cb			 
99cb				; dump bytes at ptr 
99cb			 
99cb			 
99cb 3e 00			ld a, display_row_1 
99cd 2a cc eb			ld hl, (display_fb_active) 
99d0 cd dc 8c			call addatohl 
99d3 cd fb 99			call .dumpbyterow 
99d6			 
99d6 3e 28			ld a, display_row_2 
99d8 2a cc eb			ld hl, (display_fb_active) 
99db cd dc 8c			call addatohl 
99de cd fb 99			call .dumpbyterow 
99e1			 
99e1			 
99e1 3e 50			ld a, display_row_3 
99e3 2a cc eb			ld hl, (display_fb_active) 
99e6 cd dc 8c			call addatohl 
99e9 cd fb 99			call .dumpbyterow 
99ec			 
99ec 3e 78			ld a, display_row_4 
99ee 2a cc eb			ld hl, (display_fb_active) 
99f1 cd dc 8c			call addatohl 
99f4 cd fb 99			call .dumpbyterow 
99f7			 
99f7 cd d2 8a			call update_display 
99fa			;		jp cli 
99fa c9				ret 
99fb			 
99fb			.dumpbyterow: 
99fb			 
99fb				;push af 
99fb			 
99fb e5				push hl 
99fc			 
99fc				; calc where to poke the ascii 
99fc			if display_cols == 20 
99fc				ld a, 16 
99fc			else 
99fc 3e 1f			ld a, 31 
99fe			endif 
99fe			 
99fe cd dc 8c			call addatohl 
9a01 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
9a04			 
9a04			 
9a04			; display decoding address 
9a04 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a07			 
9a07 7c				ld a,h 
9a08 e1				pop hl 
9a09 e5				push hl 
9a0a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9a0a cd dd 8f			call hexout 
9a0d 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a10			 
9a10 7d				ld a,l 
9a11 e1				pop hl 
9a12 23				inc hl 
9a13 23				inc hl 
9a14 e5				push hl 
9a15			;	ld hl, os_word_scratch+2 
9a15 cd dd 8f			call hexout 
9a18 e1				pop hl 
9a19 23				inc hl 
9a1a 23				inc hl 
9a1b				;ld hl, os_word_scratch+4 
9a1b 3e 3a			ld a, ':' 
9a1d 77				ld (hl),a 
9a1e 23				inc hl 
9a1f				;ld a, 0 
9a1f				;ld (hl),a 
9a1f				;ld de, os_word_scratch 
9a1f				;pop af 
9a1f				;push af 
9a1f			;		ld a, display_row_2 
9a1f			;		call str_at_display 
9a1f			;		call update_display 
9a1f			 
9a1f			 
9a1f			;pop af 
9a1f			;	add 5 
9a1f			 
9a1f			if display_cols == 20 
9a1f				ld b, 4 
9a1f			else 
9a1f 06 08			ld b, 8 
9a21			endif	 
9a21			 
9a21			.dumpbyte: 
9a21 c5				push bc 
9a22 e5				push hl 
9a23			 
9a23			 
9a23 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a26 7e					ld a,(hl) 
9a27			 
9a27					; poke the ascii to display 
9a27 2a c6 e5				ld hl,(os_word_scratch) 
9a2a 77					ld (hl),a 
9a2b 23					inc hl 
9a2c 22 c6 e5				ld (os_word_scratch),hl 
9a2f			 
9a2f					 
9a2f			 
9a2f			 
9a2f e1					pop hl 
9a30 e5					push hl 
9a31			 
9a31 cd dd 8f				call hexout 
9a34			 
9a34					 
9a34 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a37 23				inc hl 
9a38 22 e4 e5		   	ld (os_cur_ptr),hl 
9a3b			 
9a3b e1					pop hl 
9a3c 23					inc hl 
9a3d 23					inc hl 
9a3e 23					inc hl 
9a3f			 
9a3f			 
9a3f			 
9a3f					;ld a,0 
9a3f					;ld (os_word_scratch+2),a 
9a3f					;pop af 
9a3f					;push af 
9a3f			 
9a3f					;ld de, os_word_scratch 
9a3f					;call str_at_display 
9a3f			;		call update_display 
9a3f			;		pop af 
9a3f c1					pop bc 
9a40 c6 03				add 3 
9a42 10 dd			djnz .dumpbyte 
9a44			 
9a44				 
9a44			 
9a44 c9				ret 
9a45			 
9a45			jump:	 
9a45			 
9a45 21 c3 e2			ld hl,scratch+2 
9a48 cd 93 90			call get_word_hl 
9a4b				;ld hl,(scratch+2) 
9a4b				;call fourehexhl 
9a4b			 
9a4b 22 e4 e5			ld (os_cur_ptr),hl	 
9a4e			 
9a4e e9				jp (hl) 
9a4f			 
9a4f			 
9a4f			 
9a4f			; TODO implement a basic monitor mode to start with 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			 
9a4f			; testing and demo code during development 
9a4f			 
9a4f			 
9a4f .. 00		str1: db "Enter some text...",0 
9a62 .. 00		clear: db "                    ",0 
9a77			 
9a77			demo: 
9a77			 
9a77			 
9a77			 
9a77			;	call update_display 
9a77			 
9a77				; init scratch input area for testing 
9a77 21 c1 e2			ld hl, scratch	 
9a7a 3e 00			ld a,0 
9a7c 77				ld (hl),a 
9a7d			 
9a7d			 
9a7d 3e 28		            LD   A, display_row_2 
9a7f			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a7f 11 4f 9a		            LD   DE, str1 
9a82 cd c2 8a			call str_at_display 
9a85			 
9a85			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a85			cloop:	 
9a85 3e 50		            LD   A, display_row_3 
9a87			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a87 11 62 9a		            LD   DE, clear 
9a8a			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a8a cd c2 8a				call str_at_display 
9a8d 3e 78			ld a, display_row_4 
9a8f 11 bf 9a			ld de, prompt 
9a92			 
9a92 cd c2 8a				call str_at_display 
9a95 cd d2 8a			call update_display 
9a98			 
9a98 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a9a 16 0a			ld d, 10 
9a9c 21 c1 e2			ld hl, scratch	 
9a9f cd 09 8d			call input_str 
9aa2			 
9aa2			;	call clear_display 
9aa2			;'	call update_display 
9aa2			 
9aa2 3e 00		            LD   A, display_row_1 
9aa4			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aa4 11 62 9a		            LD   DE, clear 
9aa7 cd c2 8a				call str_at_display 
9aaa			;            CALL fLCD_Str       ;Display string pointed to by DE 
9aaa 3e 00		            LD   A, display_row_1 
9aac			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aac 11 c1 e2		            LD   DE, scratch 
9aaf			;            CALL fLCD_Str       ;Display string pointed to by DE 
9aaf cd c2 8a				call str_at_display 
9ab2 cd d2 8a			call update_display 
9ab5			 
9ab5 3e 00				ld a,0 
9ab7 21 c1 e2			ld hl, scratch 
9aba 77				ld (hl),a 
9abb			 
9abb 00				nop 
9abc c3 85 9a			jp cloop 
9abf			 
9abf			 
9abf			 
9abf			; OS Prompt 
9abf			 
9abf .. 00		prompt: db ">",0 
9ac1 .. 00		endprg: db "?",0 
9ac3			 
9ac3			 
9ac3			; handy next page prompt 
9ac3			next_page_prompt: 
9ac3 e5				push hl 
9ac4 d5				push de 
9ac5 f5				push af 
9ac6 c5				push bc 
9ac7			 
9ac7 3e 9f			ld a,display_row_4 + display_cols - 1 
9ac9 11 c1 9a		        ld de, endprg 
9acc cd c2 8a			call str_at_display 
9acf cd d2 8a			call update_display 
9ad2 cd c8 e3			call cin_wait 
9ad5 c1				pop bc 
9ad6 f1				pop af 
9ad7 d1				pop de 
9ad8 e1				pop hl 
9ad9			 
9ad9			 
9ad9 c9				ret 
9ada			 
9ada			 
9ada			; forth parser 
9ada			 
9ada			; My forth kernel 
9ada			include "forth_kernel.asm" 
9ada			; 
9ada			; kernel to the forth OS 
9ada			 
9ada			DS_TYPE_STR: equ 1     ; string type 
9ada			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9ada			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9ada			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9ada			 
9ada			FORTH_PARSEV1: equ 0 
9ada			FORTH_PARSEV2: equ 0 
9ada			FORTH_PARSEV3: equ 0 
9ada			FORTH_PARSEV4: equ 0 
9ada			FORTH_PARSEV5: equ 1 
9ada			 
9ada			;if FORTH_PARSEV5 
9ada			;	FORTH_END_BUFFER: equ 0 
9ada			;else 
9ada			FORTH_END_BUFFER: equ 127 
9ada			;endif 
9ada			 
9ada			FORTH_TRUE: equ 1 
9ada			FORTH_FALSE: equ 0 
9ada			 
9ada			if FORTH_PARSEV4 
9ada			include "forth_stackops.asm" 
9ada			endif 
9ada			 
9ada			if FORTH_PARSEV5 
9ada			include "forth_stackopsv5.asm" 
9ada			 
9ada			; Stack operations for v5 parser on wards 
9ada			; * DATA stack 
9ada			; * LOOP stack 
9ada			; * RETURN stack 
9ada			 
9ada			 
9ada			 
9ada			FORTH_CHK_DSP_UNDER: macro 
9ada				push hl 
9ada				push de 
9ada				ld hl,(cli_data_sp) 
9ada				ld de, cli_data_stack 
9ada				call cmp16 
9ada				jp c, fault_dsp_under 
9ada				pop de 
9ada				pop hl 
9ada				endm 
9ada			 
9ada			 
9ada			FORTH_CHK_RSP_UNDER: macro 
9ada				push hl 
9ada				push de 
9ada				ld hl,(cli_ret_sp) 
9ada				ld de, cli_ret_stack 
9ada				call cmp16 
9ada				jp c, fault_rsp_under 
9ada				pop de 
9ada				pop hl 
9ada				endm 
9ada			 
9ada			FORTH_CHK_LOOP_UNDER: macro 
9ada				push hl 
9ada				push de 
9ada				ld hl,(cli_loop_sp) 
9ada				ld de, cli_loop_stack 
9ada				call cmp16 
9ada				jp c, fault_loop_under 
9ada				pop de 
9ada				pop hl 
9ada				endm 
9ada			 
9ada			FORTH_ERR_TOS_NOTSTR: macro 
9ada				; TOSO might need more for checks when used 
9ada				push af 
9ada				ld a,(hl) 
9ada				cp DS_TYPE_STR 
9ada				jp nz, type_faultn   
9ada				pop af 
9ada				endm 
9ada			 
9ada			FORTH_ERR_TOS_NOTNUM: macro 
9ada				push af 
9ada				ld a,(hl) 
9ada				cp DS_TYPE_INUM 
9ada				jp nz, type_faultn   
9ada				pop af 
9ada				endm 
9ada			 
9ada			 
9ada			; increase data stack pointer and save hl to it 
9ada				 
9ada			FORTH_DSP_NEXT: macro 
9ada				call macro_forth_dsp_next 
9ada				endm 
9ada			 
9ada			 
9ada			macro_forth_dsp_next: 
9ada				if DEBUG_FORTH_STACK_GUARD 
9ada cd 43 e0				call check_stacks 
9add				endif 
9add e5				push hl 
9ade d5				push de 
9adf eb				ex de,hl 
9ae0 2a ee e9			ld hl,(cli_data_sp) 
9ae3 23				inc hl 
9ae4 23				inc hl 
9ae5			 
9ae5			; PARSEV5 
9ae5 23				inc hl 
9ae6 22 ee e9			ld (cli_data_sp),hl 
9ae9 73				ld (hl), e 
9aea 23				inc hl 
9aeb 72				ld (hl), d 
9aec d1				pop de 
9aed e1				pop hl 
9aee				if DEBUG_FORTH_STACK_GUARD 
9aee cd 43 e0				call check_stacks 
9af1				endif 
9af1 c9				ret 
9af2			 
9af2			 
9af2			; increase ret stack pointer and save hl to it 
9af2				 
9af2			FORTH_RSP_NEXT: macro 
9af2				call macro_forth_rsp_next 
9af2				endm 
9af2			 
9af2			macro_forth_rsp_next: 
9af2				if DEBUG_FORTH_STACK_GUARD 
9af2 cd 43 e0				call check_stacks 
9af5				endif 
9af5 e5				push hl 
9af6 d5				push de 
9af7 eb				ex de,hl 
9af8 2a f2 e9			ld hl,(cli_ret_sp) 
9afb 23				inc hl 
9afc 23				inc hl 
9afd 22 f2 e9			ld (cli_ret_sp),hl 
9b00 73				ld (hl), e 
9b01 23				inc hl 
9b02 72				ld (hl), d 
9b03 d1				pop de 
9b04 e1				pop hl 
9b05				if DEBUG_FORTH_STACK_GUARD 
9b05 cd 43 e0				call check_stacks 
9b08				endif 
9b08 c9				ret 
9b09			 
9b09			; get current ret stack pointer and save to hl  
9b09				 
9b09			FORTH_RSP_TOS: macro 
9b09				call macro_forth_rsp_tos 
9b09				endm 
9b09			 
9b09			macro_forth_rsp_tos: 
9b09				;push de 
9b09 2a f2 e9			ld hl,(cli_ret_sp) 
9b0c cd 44 9b			call loadhlptrtohl 
9b0f				;ld e, (hl) 
9b0f				;inc hl 
9b0f				;ld d, (hl) 
9b0f				;ex de, hl 
9b0f					if DEBUG_FORTH_WORDS 
9b0f			;			DMARK "RST" 
9b0f						CALLMONITOR 
9b0f cd 6f ee			call debug_vector  
9b12				endm  
# End of macro CALLMONITOR
9b12					endif 
9b12				;pop de 
9b12 c9				ret 
9b13			 
9b13			; pop ret stack pointer 
9b13				 
9b13			FORTH_RSP_POP: macro 
9b13				call macro_forth_rsp_pop 
9b13				endm 
9b13			 
9b13			 
9b13			macro_forth_rsp_pop: 
9b13				if DEBUG_FORTH_STACK_GUARD 
9b13			;		DMARK "RPP" 
9b13 cd 43 e0				call check_stacks 
9b16					FORTH_CHK_RSP_UNDER 
9b16 e5				push hl 
9b17 d5				push de 
9b18 2a f2 e9			ld hl,(cli_ret_sp) 
9b1b 11 ac e9			ld de, cli_ret_stack 
9b1e cd fa 8c			call cmp16 
9b21 da 57 e1			jp c, fault_rsp_under 
9b24 d1				pop de 
9b25 e1				pop hl 
9b26				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b26				endif 
9b26 e5				push hl 
9b27 2a f2 e9			ld hl,(cli_ret_sp) 
9b2a			 
9b2a			 
9b2a				if FORTH_ENABLE_FREE 
9b2a			 
9b2a					; get pointer 
9b2a			 
9b2a					push de 
9b2a					push hl 
9b2a			 
9b2a					ld e, (hl) 
9b2a					inc hl 
9b2a					ld d, (hl) 
9b2a			 
9b2a					ex de, hl 
9b2a					call free 
9b2a			 
9b2a					pop hl 
9b2a					pop de 
9b2a			 
9b2a			 
9b2a				endif 
9b2a			 
9b2a			 
9b2a 2b				dec hl 
9b2b 2b				dec hl 
9b2c 22 f2 e9			ld (cli_ret_sp), hl 
9b2f				; do stack underflow checks 
9b2f e1				pop hl 
9b30				if DEBUG_FORTH_STACK_GUARD 
9b30 cd 43 e0				call check_stacks 
9b33					FORTH_CHK_RSP_UNDER 
9b33 e5				push hl 
9b34 d5				push de 
9b35 2a f2 e9			ld hl,(cli_ret_sp) 
9b38 11 ac e9			ld de, cli_ret_stack 
9b3b cd fa 8c			call cmp16 
9b3e da 57 e1			jp c, fault_rsp_under 
9b41 d1				pop de 
9b42 e1				pop hl 
9b43				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b43				endif 
9b43 c9				ret 
9b44			 
9b44			 
9b44			 
9b44			; routine to load word pointed to by hl into hl 
9b44			 
9b44			loadhlptrtohl: 
9b44			 
9b44 d5				push de 
9b45 5e				ld e, (hl) 
9b46 23				inc hl 
9b47 56				ld d, (hl) 
9b48 eb				ex de, hl 
9b49 d1				pop de 
9b4a			 
9b4a c9				ret 
9b4b			 
9b4b			 
9b4b			 
9b4b			 
9b4b			 
9b4b			; push a number held in HL onto the data stack 
9b4b			; entry point for pushing a value when already in hl used in function above 
9b4b			 
9b4b			forth_push_numhl: 
9b4b			 
9b4b e5				push hl    ; save value to push 
9b4c			 
9b4c			if DEBUG_FORTH_PUSH 
9b4c				; see if disabled 
9b4c			 
9b4c			 
9b4c f5				push af 
9b4d 3a 6f ee			ld a,(debug_vector) 
9b50 fe c9			cp $c9   ; ret 
9b52			;	ld a, (os_view_disable) 
9b52			;	cp '*' 
9b52 28 34			jr z, .pskip2 
9b54 e5				push hl 
9b55 e5			push hl 
9b56 cd af 8a			call clear_display 
9b59 e1			pop hl 
9b5a 7c				ld a,h 
9b5b 21 c6 e5			ld hl, os_word_scratch 
9b5e cd dd 8f			call hexout 
9b61 e1				pop hl 
9b62 7d				ld a,l 
9b63 21 c8 e5			ld hl, os_word_scratch+2 
9b66 cd dd 8f			call hexout 
9b69			 
9b69 21 ca e5			ld hl, os_word_scratch+4 
9b6c 3e 00			ld a,0 
9b6e 77				ld (hl),a 
9b6f 11 c6 e5			ld de,os_word_scratch 
9b72 3e 28				ld a, display_row_2 
9b74 cd c2 8a				call str_at_display 
9b77 11 7f cb			ld de, .push_num 
9b7a 3e 00			ld a, display_row_1 
9b7c			 
9b7c cd c2 8a				call str_at_display 
9b7f			 
9b7f			 
9b7f cd d2 8a			call update_display 
9b82 cd f2 89			call delay1s 
9b85 cd f2 89			call delay1s 
9b88			.pskip2:  
9b88			 
9b88 f1				pop af 
9b89			endif	 
9b89			 
9b89			 
9b89				FORTH_DSP_NEXT 
9b89 cd da 9a			call macro_forth_dsp_next 
9b8c				endm 
# End of macro FORTH_DSP_NEXT
9b8c			 
9b8c 2a ee e9			ld hl, (cli_data_sp) 
9b8f			 
9b8f				; save item type 
9b8f 3e 02			ld a,  DS_TYPE_INUM 
9b91 77				ld (hl), a 
9b92 23				inc hl 
9b93			 
9b93				; get word off stack 
9b93 d1				pop de 
9b94 7b				ld a,e 
9b95 77				ld (hl), a 
9b96 23				inc hl 
9b97 7a				ld a,d 
9b98 77				ld (hl), a 
9b99			 
9b99			if DEBUG_FORTH_PUSH 
9b99 2b				dec hl 
9b9a 2b				dec hl 
9b9b 2b				dec hl 
9b9c						DMARK "PH5" 
9b9c f5				push af  
9b9d 3a b1 9b			ld a, (.dmark)  
9ba0 32 6b ee			ld (debug_mark),a  
9ba3 3a b2 9b			ld a, (.dmark+1)  
9ba6 32 6c ee			ld (debug_mark+1),a  
9ba9 3a b3 9b			ld a, (.dmark+2)  
9bac 32 6d ee			ld (debug_mark+2),a  
9baf 18 03			jr .pastdmark  
9bb1 ..			.dmark: db "PH5"  
9bb4 f1			.pastdmark: pop af  
9bb5			endm  
# End of macro DMARK
9bb5				CALLMONITOR 
9bb5 cd 6f ee			call debug_vector  
9bb8				endm  
# End of macro CALLMONITOR
9bb8			endif	 
9bb8			 
9bb8 c9				ret 
9bb9			 
9bb9			 
9bb9			; Push a string to stack pointed to by hl 
9bb9			 
9bb9			forth_push_str: 
9bb9			 
9bb9			if DEBUG_FORTH_PUSH 
9bb9						DMARK "PSQ" 
9bb9 f5				push af  
9bba 3a ce 9b			ld a, (.dmark)  
9bbd 32 6b ee			ld (debug_mark),a  
9bc0 3a cf 9b			ld a, (.dmark+1)  
9bc3 32 6c ee			ld (debug_mark+1),a  
9bc6 3a d0 9b			ld a, (.dmark+2)  
9bc9 32 6d ee			ld (debug_mark+2),a  
9bcc 18 03			jr .pastdmark  
9bce ..			.dmark: db "PSQ"  
9bd1 f1			.pastdmark: pop af  
9bd2			endm  
# End of macro DMARK
9bd2				CALLMONITOR 
9bd2 cd 6f ee			call debug_vector  
9bd5				endm  
# End of macro CALLMONITOR
9bd5			endif	 
9bd5			    
9bd5 e5				push hl 
9bd6 e5				push hl 
9bd7			 
9bd7			;	ld a, 0   ; find end of string 
9bd7 cd 3a 91			call strlenz 
9bda			if DEBUG_FORTH_PUSH 
9bda						DMARK "PQ2" 
9bda f5				push af  
9bdb 3a ef 9b			ld a, (.dmark)  
9bde 32 6b ee			ld (debug_mark),a  
9be1 3a f0 9b			ld a, (.dmark+1)  
9be4 32 6c ee			ld (debug_mark+1),a  
9be7 3a f1 9b			ld a, (.dmark+2)  
9bea 32 6d ee			ld (debug_mark+2),a  
9bed 18 03			jr .pastdmark  
9bef ..			.dmark: db "PQ2"  
9bf2 f1			.pastdmark: pop af  
9bf3			endm  
# End of macro DMARK
9bf3				CALLMONITOR 
9bf3 cd 6f ee			call debug_vector  
9bf6				endm  
# End of macro CALLMONITOR
9bf6			endif	 
9bf6 eb				ex de, hl 
9bf7 e1				pop hl   ; get ptr to start of string 
9bf8			if DEBUG_FORTH_PUSH 
9bf8						DMARK "PQ3" 
9bf8 f5				push af  
9bf9 3a 0d 9c			ld a, (.dmark)  
9bfc 32 6b ee			ld (debug_mark),a  
9bff 3a 0e 9c			ld a, (.dmark+1)  
9c02 32 6c ee			ld (debug_mark+1),a  
9c05 3a 0f 9c			ld a, (.dmark+2)  
9c08 32 6d ee			ld (debug_mark+2),a  
9c0b 18 03			jr .pastdmark  
9c0d ..			.dmark: db "PQ3"  
9c10 f1			.pastdmark: pop af  
9c11			endm  
# End of macro DMARK
9c11				CALLMONITOR 
9c11 cd 6f ee			call debug_vector  
9c14				endm  
# End of macro CALLMONITOR
9c14			endif	 
9c14 19				add hl,de 
9c15			if DEBUG_FORTH_PUSH 
9c15						DMARK "PQE" 
9c15 f5				push af  
9c16 3a 2a 9c			ld a, (.dmark)  
9c19 32 6b ee			ld (debug_mark),a  
9c1c 3a 2b 9c			ld a, (.dmark+1)  
9c1f 32 6c ee			ld (debug_mark+1),a  
9c22 3a 2c 9c			ld a, (.dmark+2)  
9c25 32 6d ee			ld (debug_mark+2),a  
9c28 18 03			jr .pastdmark  
9c2a ..			.dmark: db "PQE"  
9c2d f1			.pastdmark: pop af  
9c2e			endm  
# End of macro DMARK
9c2e				CALLMONITOR 
9c2e cd 6f ee			call debug_vector  
9c31				endm  
# End of macro CALLMONITOR
9c31			endif	 
9c31			 
9c31 2b				dec hl    ; see if there is an optional trailing double quote 
9c32 7e				ld a,(hl) 
9c33 fe 22			cp '"' 
9c35 20 03			jr nz, .strnoq 
9c37 3e 00			ld a, 0      ; get rid of double quote 
9c39 77				ld (hl), a 
9c3a 23			.strnoq: inc hl 
9c3b			 
9c3b 3e 00			ld a, 0 
9c3d 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c3e			 
9c3e 13				inc de ; add one for the type string 
9c3f 13				inc de ; add one for null term??? 
9c40			 
9c40				; tos is get string pointer again 
9c40				; de contains space to allocate 
9c40				 
9c40 d5				push de 
9c41			 
9c41 eb				ex de, hl 
9c42			 
9c42				;push af 
9c42			 
9c42			if DEBUG_FORTH_PUSH 
9c42						DMARK "PHm" 
9c42 f5				push af  
9c43 3a 57 9c			ld a, (.dmark)  
9c46 32 6b ee			ld (debug_mark),a  
9c49 3a 58 9c			ld a, (.dmark+1)  
9c4c 32 6c ee			ld (debug_mark+1),a  
9c4f 3a 59 9c			ld a, (.dmark+2)  
9c52 32 6d ee			ld (debug_mark+2),a  
9c55 18 03			jr .pastdmark  
9c57 ..			.dmark: db "PHm"  
9c5a f1			.pastdmark: pop af  
9c5b			endm  
# End of macro DMARK
9c5b				CALLMONITOR 
9c5b cd 6f ee			call debug_vector  
9c5e				endm  
# End of macro CALLMONITOR
9c5e			endif	 
9c5e cd a3 91			call malloc	; on ret hl now contains allocated memory 
9c61				if DEBUG_FORTH_MALLOC_GUARD 
9c61 cc d7 cb				call z,malloc_error 
9c64				endif 
9c64			 
9c64				 
9c64 c1				pop bc    ; get length 
9c65 d1				pop de   ;  get string start    
9c66			 
9c66				; hl has destination from malloc 
9c66			 
9c66 eb				ex de, hl    ; prep for ldir 
9c67			 
9c67 d5				push de   ; save malloc area for DSP later 
9c68				;push hl   ; save malloc area for DSP later 
9c68			 
9c68			if DEBUG_FORTH_PUSH 
9c68						DMARK "PHc" 
9c68 f5				push af  
9c69 3a 7d 9c			ld a, (.dmark)  
9c6c 32 6b ee			ld (debug_mark),a  
9c6f 3a 7e 9c			ld a, (.dmark+1)  
9c72 32 6c ee			ld (debug_mark+1),a  
9c75 3a 7f 9c			ld a, (.dmark+2)  
9c78 32 6d ee			ld (debug_mark+2),a  
9c7b 18 03			jr .pastdmark  
9c7d ..			.dmark: db "PHc"  
9c80 f1			.pastdmark: pop af  
9c81			endm  
# End of macro DMARK
9c81				CALLMONITOR 
9c81 cd 6f ee			call debug_vector  
9c84				endm  
# End of macro CALLMONITOR
9c84			endif	 
9c84			 
9c84			 
9c84 ed b0			ldir 
9c86			 
9c86			 
9c86				; push malloc to data stack     macro?????  
9c86			 
9c86				FORTH_DSP_NEXT 
9c86 cd da 9a			call macro_forth_dsp_next 
9c89				endm 
# End of macro FORTH_DSP_NEXT
9c89			 
9c89				; save value and type 
9c89			 
9c89 2a ee e9			ld hl, (cli_data_sp) 
9c8c			 
9c8c				; save item type 
9c8c 3e 01			ld a,  DS_TYPE_STR 
9c8e 77				ld (hl), a 
9c8f 23				inc hl 
9c90			 
9c90				; get malloc word off stack 
9c90 d1				pop de 
9c91 73				ld (hl), e 
9c92 23				inc hl 
9c93 72				ld (hl), d 
9c94			 
9c94			 
9c94			 
9c94			if DEBUG_FORTH_PUSH 
9c94 2a ee e9			ld hl, (cli_data_sp) 
9c97						DMARK "PHS" 
9c97 f5				push af  
9c98 3a ac 9c			ld a, (.dmark)  
9c9b 32 6b ee			ld (debug_mark),a  
9c9e 3a ad 9c			ld a, (.dmark+1)  
9ca1 32 6c ee			ld (debug_mark+1),a  
9ca4 3a ae 9c			ld a, (.dmark+2)  
9ca7 32 6d ee			ld (debug_mark+2),a  
9caa 18 03			jr .pastdmark  
9cac ..			.dmark: db "PHS"  
9caf f1			.pastdmark: pop af  
9cb0			endm  
# End of macro DMARK
9cb0				CALLMONITOR 
9cb0 cd 6f ee			call debug_vector  
9cb3				endm  
# End of macro CALLMONITOR
9cb3			;	ex de,hl 
9cb3			endif	 
9cb3				; in case of spaces, skip the ptr past the copied string 
9cb3				;pop af 
9cb3				;ld (cli_origptr),hl 
9cb3			 
9cb3 c9				ret 
9cb4			 
9cb4			 
9cb4			 
9cb4			; TODO ascii push input onto stack given hl to start of input 
9cb4			 
9cb4			; identify type 
9cb4			; if starts with a " then a string 
9cb4			; otherwise it is a number 
9cb4			;  
9cb4			; if a string 
9cb4			;     scan for ending " to get length of string to malloc for + 1 
9cb4			;     malloc 
9cb4			;     put pointer to string on stack first byte flags as string 
9cb4			; 
9cb4			; else a number 
9cb4			;    look for number format identifier 
9cb4			;    $xx hex 
9cb4			;    %xxxxx bin 
9cb4			;    xxxxx decimal 
9cb4			;    convert number to 16bit word.  
9cb4			;    malloc word + 1 with flag to identiy as num 
9cb4			;    put pointer to number on stack 
9cb4			;   
9cb4			;  
9cb4			  
9cb4			forth_apush: 
9cb4				; kernel push 
9cb4			 
9cb4			if DEBUG_FORTH_PUSH 
9cb4						DMARK "PSH" 
9cb4 f5				push af  
9cb5 3a c9 9c			ld a, (.dmark)  
9cb8 32 6b ee			ld (debug_mark),a  
9cbb 3a ca 9c			ld a, (.dmark+1)  
9cbe 32 6c ee			ld (debug_mark+1),a  
9cc1 3a cb 9c			ld a, (.dmark+2)  
9cc4 32 6d ee			ld (debug_mark+2),a  
9cc7 18 03			jr .pastdmark  
9cc9 ..			.dmark: db "PSH"  
9ccc f1			.pastdmark: pop af  
9ccd			endm  
# End of macro DMARK
9ccd				CALLMONITOR 
9ccd cd 6f ee			call debug_vector  
9cd0				endm  
# End of macro CALLMONITOR
9cd0			endif	 
9cd0				; identify input type 
9cd0			 
9cd0 7e				ld a,(hl) 
9cd1 fe 22			cp '"' 
9cd3 28 0a			jr z, .fapstr 
9cd5 fe 24			cp '$' 
9cd7 ca ff 9c			jp z, .faphex 
9cda fe 25			cp '%' 
9cdc ca e7 9c			jp z, .fapbin 
9cdf			;	cp 'b' 
9cdf			;	jp z, .fabin 
9cdf				; else decimal 
9cdf			 
9cdf				; TODO do decimal conversion 
9cdf				; decimal is stored as a 16bit word 
9cdf			 
9cdf				; by default everything is a string if type is not detected 
9cdf			.fapstr: ; 
9cdf fe 22			cp '"' 
9ce1 20 01			jr nz, .strnoqu 
9ce3 23				inc hl 
9ce4			.strnoqu: 
9ce4 c3 b9 9b			jp forth_push_str 
9ce7			 
9ce7			 
9ce7			 
9ce7			.fapbin:    ; push a binary string.  
9ce7 11 00 00			ld de, 0   ; hold a 16bit value 
9cea			 
9cea 23			.fapbinshift:	inc hl  
9ceb 7e				ld a,(hl) 
9cec fe 00			cp 0     ; done scanning  
9cee 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cf0			 
9cf0				; left shift de 
9cf0 eb				ex de, hl	 
9cf1 29				add hl, hl 
9cf2			 
9cf2				; is 1 
9cf2 fe 31			cp '1' 
9cf4 20 02			jr nz, .binzero 
9cf6 cb 4d			bit 1, l 
9cf8			.binzero: 
9cf8 eb				ex de, hl	 ; save current de 
9cf9 18 ef			jr .fapbinshift 
9cfb			 
9cfb			.fapbdone: 
9cfb eb				ex de, hl 
9cfc c3 4b 9b			jp forth_push_numhl 
9cff			 
9cff			 
9cff			.faphex:   ; hex is always stored as a 16bit word 
9cff				; skip number prefix 
9cff 23				inc hl 
9d00				; turn ascii into number 
9d00 cd 93 90			call get_word_hl	; ret 16bit word in hl 
9d03			 
9d03 c3 4b 9b			jp forth_push_numhl 
9d06			 
9d06 00				 nop 
9d07			 
9d07			.fabin:   ; TODO bin conversion 
9d07			 
9d07			 
9d07 c9				ret 
9d08			 
9d08			 
9d08			; get either a string ptr or a 16bit word from the data stack 
9d08			 
9d08			FORTH_DSP: macro 
9d08				call macro_forth_dsp 
9d08				endm 
9d08			 
9d08			macro_forth_dsp: 
9d08				; data stack pointer points to current word on tos 
9d08			 
9d08 2a ee e9			ld hl,(cli_data_sp) 
9d0b			 
9d0b				if DEBUG_FORTH_PUSH 
9d0b						DMARK "DSP" 
9d0b f5				push af  
9d0c 3a 20 9d			ld a, (.dmark)  
9d0f 32 6b ee			ld (debug_mark),a  
9d12 3a 21 9d			ld a, (.dmark+1)  
9d15 32 6c ee			ld (debug_mark+1),a  
9d18 3a 22 9d			ld a, (.dmark+2)  
9d1b 32 6d ee			ld (debug_mark+2),a  
9d1e 18 03			jr .pastdmark  
9d20 ..			.dmark: db "DSP"  
9d23 f1			.pastdmark: pop af  
9d24			endm  
# End of macro DMARK
9d24			 
9d24 cd 0a cc				call display_data_sp 
9d27				;call break_point_state 
9d27				;rst 030h 
9d27				CALLMONITOR 
9d27 cd 6f ee			call debug_vector  
9d2a				endm  
# End of macro CALLMONITOR
9d2a				endif 
9d2a			 
9d2a c9				ret 
9d2b			 
9d2b			; return hl to start of value on stack 
9d2b			 
9d2b			FORTH_DSP_VALUE: macro 
9d2b				call macro_forth_dsp_value 
9d2b				endm 
9d2b			 
9d2b			macro_forth_dsp_value: 
9d2b			 
9d2b				FORTH_DSP 
9d2b cd 08 9d			call macro_forth_dsp 
9d2e				endm 
# End of macro FORTH_DSP
9d2e			 
9d2e d5				push de 
9d2f			 
9d2f 23				inc hl ; skip type 
9d30			 
9d30 5e				ld e, (hl) 
9d31 23				inc hl 
9d32 56				ld d, (hl) 
9d33 eb				ex de,hl  
9d34			 
9d34 d1				pop de 
9d35			 
9d35 c9				ret 
9d36			 
9d36			; return hl to start of value to second item on stack 
9d36			 
9d36			FORTH_DSP_VALUEM1: macro 
9d36				call macro_forth_dsp_value_m1 
9d36				endm 
9d36			 
9d36			macro_forth_dsp_value_m1: 
9d36			 
9d36				FORTH_DSP 
9d36 cd 08 9d			call macro_forth_dsp 
9d39				endm 
# End of macro FORTH_DSP
9d39			 
9d39 2b				dec hl 
9d3a 2b				dec hl 
9d3b			;	dec hl 
9d3b			 
9d3b d5				push de 
9d3c			 
9d3c 5e				ld e, (hl) 
9d3d 23				inc hl 
9d3e 56				ld d, (hl) 
9d3f eb				ex de,hl  
9d40			 
9d40 d1				pop de 
9d41			 
9d41 c9				ret 
9d42			 
9d42				 
9d42			 
9d42			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d42			 
9d42			FORTH_DSP_POP: macro 
9d42				call macro_forth_dsp_pop 
9d42				endm 
9d42			 
9d42			 
9d42			; get the tos data type 
9d42			 
9d42			FORTH_DSP_TYPE:   macro 
9d42			 
9d42				;FORTH_DSP_VALUE 
9d42				FORTH_DSP 
9d42				 
9d42				; hl points to value 
9d42				; check type 
9d42			 
9d42				ld a,(hl) 
9d42			 
9d42				endm 
9d42			 
9d42			; load the tos value into hl 
9d42			 
9d42			 
9d42			FORTH_DSP_VALUEHL:  macro 
9d42				call macro_dsp_valuehl 
9d42				endm 
9d42			 
9d42			 
9d42			 
9d42			macro_dsp_valuehl: 
9d42				FORTH_DSP_VALUE 
9d42 cd 2b 9d			call macro_forth_dsp_value 
9d45				endm 
# End of macro FORTH_DSP_VALUE
9d45			 
9d45				;FORTH_ERR_TOS_NOTNUM 
9d45			 
9d45				;inc hl   ; skip type id 
9d45			 
9d45			;	push de 
9d45			; 
9d45			;	ld e, (hl) 
9d45			;	inc hl 
9d45			;	ld d, (hl) 
9d45			;	ex de,hl  
9d45			 
9d45			;	pop de 
9d45			 
9d45				if DEBUG_FORTH_PUSH 
9d45						DMARK "DVL" 
9d45 f5				push af  
9d46 3a 5a 9d			ld a, (.dmark)  
9d49 32 6b ee			ld (debug_mark),a  
9d4c 3a 5b 9d			ld a, (.dmark+1)  
9d4f 32 6c ee			ld (debug_mark+1),a  
9d52 3a 5c 9d			ld a, (.dmark+2)  
9d55 32 6d ee			ld (debug_mark+2),a  
9d58 18 03			jr .pastdmark  
9d5a ..			.dmark: db "DVL"  
9d5d f1			.pastdmark: pop af  
9d5e			endm  
# End of macro DMARK
9d5e				CALLMONITOR 
9d5e cd 6f ee			call debug_vector  
9d61				endm  
# End of macro CALLMONITOR
9d61				endif 
9d61 c9				ret 
9d62			 
9d62			forth_apushstrhl:      
9d62				; push of string requires use of cli_origptr 
9d62				; bodge use 
9d62			 
9d62				; get current cli_origptr, save, update with temp pointer  
9d62 ed 5b 3e ea		ld de, (cli_origptr) 
9d66 22 3e ea			ld (cli_origptr), hl 
9d69 d5				push de 
9d6a cd b4 9c			call forth_apush 
9d6d d1				pop de 
9d6e ed 53 3e ea		ld (cli_origptr), de 
9d72 c9			        ret	 
9d73			 
9d73			 
9d73			; increase loop stack pointer and save hl to it 
9d73				 
9d73			FORTH_LOOP_NEXT: macro 
9d73				call macro_forth_loop_next 
9d73				;nop 
9d73				endm 
9d73			 
9d73			macro_forth_loop_next: 
9d73				if DEBUG_FORTH_STACK_GUARD 
9d73 cd 43 e0				call check_stacks 
9d76				endif 
9d76 e5				push hl 
9d77 d5				push de 
9d78 eb				ex de,hl 
9d79 2a f0 e9			ld hl,(cli_loop_sp) 
9d7c 23				inc hl 
9d7d 23				inc hl 
9d7e					if DEBUG_FORTH_WORDS 
9d7e						DMARK "LNX" 
9d7e f5				push af  
9d7f 3a 93 9d			ld a, (.dmark)  
9d82 32 6b ee			ld (debug_mark),a  
9d85 3a 94 9d			ld a, (.dmark+1)  
9d88 32 6c ee			ld (debug_mark+1),a  
9d8b 3a 95 9d			ld a, (.dmark+2)  
9d8e 32 6d ee			ld (debug_mark+2),a  
9d91 18 03			jr .pastdmark  
9d93 ..			.dmark: db "LNX"  
9d96 f1			.pastdmark: pop af  
9d97			endm  
# End of macro DMARK
9d97						CALLMONITOR 
9d97 cd 6f ee			call debug_vector  
9d9a				endm  
# End of macro CALLMONITOR
9d9a					endif 
9d9a 22 f0 e9			ld (cli_loop_sp),hl 
9d9d 73				ld (hl), e 
9d9e 23				inc hl 
9d9f 72				ld (hl), d 
9da0 d1				pop de    ; been reversed so save a swap on restore 
9da1 e1				pop hl 
9da2				if DEBUG_FORTH_STACK_GUARD 
9da2 cd 43 e0				call check_stacks 
9da5				endif 
9da5 c9				ret 
9da6			 
9da6			; get current ret stack pointer and save to hl  
9da6				 
9da6			FORTH_LOOP_TOS: macro 
9da6				call macro_forth_loop_tos 
9da6				endm 
9da6			 
9da6			macro_forth_loop_tos: 
9da6 d5				push de 
9da7 2a f0 e9			ld hl,(cli_loop_sp) 
9daa 5e				ld e, (hl) 
9dab 23				inc hl 
9dac 56				ld d, (hl) 
9dad eb				ex de, hl 
9dae d1				pop de 
9daf c9				ret 
9db0			 
9db0			; pop loop stack pointer 
9db0				 
9db0			FORTH_LOOP_POP: macro 
9db0				call macro_forth_loop_pop 
9db0				endm 
9db0			 
9db0			 
9db0			macro_forth_loop_pop: 
9db0				if DEBUG_FORTH_STACK_GUARD 
9db0					DMARK "LPP" 
9db0 f5				push af  
9db1 3a c5 9d			ld a, (.dmark)  
9db4 32 6b ee			ld (debug_mark),a  
9db7 3a c6 9d			ld a, (.dmark+1)  
9dba 32 6c ee			ld (debug_mark+1),a  
9dbd 3a c7 9d			ld a, (.dmark+2)  
9dc0 32 6d ee			ld (debug_mark+2),a  
9dc3 18 03			jr .pastdmark  
9dc5 ..			.dmark: db "LPP"  
9dc8 f1			.pastdmark: pop af  
9dc9			endm  
# End of macro DMARK
9dc9 cd 43 e0				call check_stacks 
9dcc					FORTH_CHK_LOOP_UNDER 
9dcc e5				push hl 
9dcd d5				push de 
9dce 2a f0 e9			ld hl,(cli_loop_sp) 
9dd1 11 2a e9			ld de, cli_loop_stack 
9dd4 cd fa 8c			call cmp16 
9dd7 da 5d e1			jp c, fault_loop_under 
9dda d1				pop de 
9ddb e1				pop hl 
9ddc				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9ddc				endif 
9ddc e5				push hl 
9ddd 2a f0 e9			ld hl,(cli_loop_sp) 
9de0 2b				dec hl 
9de1 2b				dec hl 
9de2 22 f0 e9			ld (cli_loop_sp), hl 
9de5				; TODO do stack underflow checks 
9de5 e1				pop hl 
9de6				if DEBUG_FORTH_STACK_GUARD 
9de6 cd 43 e0				call check_stacks 
9de9					FORTH_CHK_LOOP_UNDER 
9de9 e5				push hl 
9dea d5				push de 
9deb 2a f0 e9			ld hl,(cli_loop_sp) 
9dee 11 2a e9			ld de, cli_loop_stack 
9df1 cd fa 8c			call cmp16 
9df4 da 5d e1			jp c, fault_loop_under 
9df7 d1				pop de 
9df8 e1				pop hl 
9df9				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9df9				endif 
9df9 c9				ret 
9dfa			 
9dfa			macro_forth_dsp_pop: 
9dfa			 
9dfa e5				push hl 
9dfb			 
9dfb				; release malloc data 
9dfb			 
9dfb				if DEBUG_FORTH_STACK_GUARD 
9dfb cd 43 e0				call check_stacks 
9dfe					FORTH_CHK_DSP_UNDER 
9dfe e5				push hl 
9dff d5				push de 
9e00 2a ee e9			ld hl,(cli_data_sp) 
9e03 11 28 e8			ld de, cli_data_stack 
9e06 cd fa 8c			call cmp16 
9e09 da 51 e1			jp c, fault_dsp_under 
9e0c d1				pop de 
9e0d e1				pop hl 
9e0e				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e0e				endif 
9e0e				;ld hl,(cli_data_sp) 
9e0e			if DEBUG_FORTH_DOT 
9e0e				DMARK "DPP" 
9e0e f5				push af  
9e0f 3a 23 9e			ld a, (.dmark)  
9e12 32 6b ee			ld (debug_mark),a  
9e15 3a 24 9e			ld a, (.dmark+1)  
9e18 32 6c ee			ld (debug_mark+1),a  
9e1b 3a 25 9e			ld a, (.dmark+2)  
9e1e 32 6d ee			ld (debug_mark+2),a  
9e21 18 03			jr .pastdmark  
9e23 ..			.dmark: db "DPP"  
9e26 f1			.pastdmark: pop af  
9e27			endm  
# End of macro DMARK
9e27				CALLMONITOR 
9e27 cd 6f ee			call debug_vector  
9e2a				endm  
# End of macro CALLMONITOR
9e2a			endif	 
9e2a			 
9e2a			 
9e2a			if FORTH_ENABLE_DSPPOPFREE 
9e2a			 
9e2a				FORTH_DSP 
9e2a cd 08 9d			call macro_forth_dsp 
9e2d				endm 
# End of macro FORTH_DSP
9e2d			 
9e2d 7e				ld a, (hl) 
9e2e fe 01			cp DS_TYPE_STR 
9e30 20 23			jr nz, .skippopfree 
9e32			 
9e32				FORTH_DSP_VALUEHL 
9e32 cd 42 9d			call macro_dsp_valuehl 
9e35				endm 
# End of macro FORTH_DSP_VALUEHL
9e35 00				nop 
9e36			if DEBUG_FORTH_DOT 
9e36				DMARK "DPf" 
9e36 f5				push af  
9e37 3a 4b 9e			ld a, (.dmark)  
9e3a 32 6b ee			ld (debug_mark),a  
9e3d 3a 4c 9e			ld a, (.dmark+1)  
9e40 32 6c ee			ld (debug_mark+1),a  
9e43 3a 4d 9e			ld a, (.dmark+2)  
9e46 32 6d ee			ld (debug_mark+2),a  
9e49 18 03			jr .pastdmark  
9e4b ..			.dmark: db "DPf"  
9e4e f1			.pastdmark: pop af  
9e4f			endm  
# End of macro DMARK
9e4f				CALLMONITOR 
9e4f cd 6f ee			call debug_vector  
9e52				endm  
# End of macro CALLMONITOR
9e52			endif	 
9e52 cd 6d 92			call free 
9e55			.skippopfree: 
9e55				 
9e55			 
9e55			endif 
9e55			 
9e55			if DEBUG_FORTH_DOT_KEY 
9e55				DMARK "DP2" 
9e55				CALLMONITOR 
9e55			endif	 
9e55			 
9e55				; move pointer down 
9e55			 
9e55 2a ee e9			ld hl,(cli_data_sp) 
9e58 2b				dec hl 
9e59 2b				dec hl 
9e5a			; PARSEV5 
9e5a 2b				dec hl 
9e5b 22 ee e9			ld (cli_data_sp), hl 
9e5e			 
9e5e				if DEBUG_FORTH_STACK_GUARD 
9e5e cd 43 e0				call check_stacks 
9e61					FORTH_CHK_DSP_UNDER 
9e61 e5				push hl 
9e62 d5				push de 
9e63 2a ee e9			ld hl,(cli_data_sp) 
9e66 11 28 e8			ld de, cli_data_stack 
9e69 cd fa 8c			call cmp16 
9e6c da 51 e1			jp c, fault_dsp_under 
9e6f d1				pop de 
9e70 e1				pop hl 
9e71				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e71				endif 
9e71			 
9e71 e1				pop hl 
9e72			 
9e72 c9				ret 
9e73			 
9e73			getwordathl: 
9e73				; hl points to an address 
9e73				; load hl with the word at that address 
9e73			 
9e73 d5				push de 
9e74			 
9e74 5e				ld e, (hl) 
9e75 23				inc hl 
9e76 56				ld d, (hl) 
9e77 eb				ex de, hl 
9e78			 
9e78 d1				pop de 
9e79 c9				ret 
9e7a			 
9e7a			 
9e7a			 
9e7a			 
9e7a			 
9e7a			; eof 
9e7a			 
# End of file forth_stackopsv5.asm
9e7a			endif 
9e7a			 
9e7a			loadwordinhl:	 
9e7a			 
9e7a d5				push de 
9e7b			 
9e7b 5e				ld e, (hl) 
9e7c 23				inc hl 
9e7d 56				ld d, (hl) 
9e7e eb				ex de,hl  
9e7f			 
9e7f d1				pop de 
9e80			 
9e80 c9				ret 
9e81			 
9e81			user_word_eol:  
9e81				; hl contains the pointer to where to create a linked list item from the end 
9e81				; of the user dict to continue on at the system word dict 
9e81				 
9e81				; poke the stub of the word list linked list to repoint to rom words 
9e81			 
9e81				; stub format 
9e81				; db   word id 
9e81				; dw    link to next word 
9e81			        ; db char length of token 
9e81				; db string + 0 term 
9e81				; db exec code....  
9e81			 
9e81 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e83 77				ld (hl), a		; word id 
9e84 23				inc hl 
9e85			 
9e85 11 50 a0			ld de, sysdict 
9e88 73				ld (hl), e		; next word link ie system dict 
9e89 23				inc hl 
9e8a 72				ld (hl), d		; next word link ie system dict 
9e8b 23				inc hl	 
9e8c			 
9e8c			;	ld (hl), sysdict		; next word link ie system dict 
9e8c			;	inc hl 
9e8c			;	inc hl 
9e8c			 
9e8c			;	inc hl 
9e8c			;	inc hl 
9e8c			 
9e8c 3e 02			ld a, 2			; word length is 0 
9e8e 77				ld (hl), a	 
9e8f 23				inc hl 
9e90			 
9e90 3e 7e			ld a, '~'			; word length is 0 
9e92 77				ld (hl), a	 
9e93 23				inc hl 
9e94 3e 00			ld a, 0			; save empty word 
9e96 77				ld (hl), a 
9e97			 
9e97 c9				ret 
9e98			 
9e98				 
9e98			 
9e98			forthexec_cleanup: 
9e98				FORTH_RSP_POP 
9e98 cd 13 9b			call macro_forth_rsp_pop 
9e9b				endm 
# End of macro FORTH_RSP_POP
9e9b c9				ret 
9e9c			 
9e9c			forth_call_hl: 
9e9c				; taking hl 
9e9c e5				push hl 
9e9d c9				ret 
9e9e			 
9e9e			; this is called to reset Forth system but keep existing uwords etc 
9e9e			 
9e9e			forth_warmstart: 
9e9e				; setup stack over/under flow checks 
9e9e				if DEBUG_FORTH_STACK_GUARD 
9e9e cd 29 e0				call chk_stk_init 
9ea1				endif 
9ea1			 
9ea1				; init stack pointers  - * these stacks go upwards *  
9ea1 21 ac e9			ld hl, cli_ret_stack 
9ea4 22 f2 e9			ld (cli_ret_sp), hl	 
9ea7				; set bottom of stack 
9ea7 3e 00			ld a,0 
9ea9 77				ld (hl),a 
9eaa 23				inc hl 
9eab 77				ld (hl),a 
9eac			 
9eac 21 28 e8			ld hl, cli_data_stack 
9eaf 22 ee e9			ld (cli_data_sp), hl	 
9eb2				; set bottom of stack 
9eb2 3e 00			ld a,0 
9eb4 77				ld (hl),a 
9eb5 23				inc hl 
9eb6 77				ld (hl),a 
9eb7			 
9eb7 21 2a e9			ld hl, cli_loop_stack 
9eba 22 f0 e9			ld (cli_loop_sp), hl	 
9ebd				; set bottom of stack 
9ebd 3e 00			ld a,0 
9ebf 77				ld (hl),a 
9ec0 23				inc hl 
9ec1 77				ld (hl),a 
9ec2			 
9ec2				; init extent of current open file 
9ec2			 
9ec2 3e 00			ld a, 0 
9ec4 32 6a ea			ld (store_openext), a 
9ec7			 
9ec7 c9				ret 
9ec8			 
9ec8			 
9ec8			 
9ec8			; Cold Start - this is called to setup the whole Forth system 
9ec8			 
9ec8			forth_init: 
9ec8			 
9ec8				; setup stack over/under flow checks 
9ec8			 
9ec8			;	if DEBUG_FORTH_STACK_GUARD 
9ec8			;		call chk_stk_init 
9ec8			;	endif 
9ec8			 
9ec8				; enable auto display updates (slow.....) 
9ec8			 
9ec8 3e 01			ld a, 1 
9eca 32 3c ea			ld (cli_autodisplay), a 
9ecd			 
9ecd				; if storage is in use disable long reads for now 
9ecd 3e 00			ld a, 0 
9ecf 32 75 ea			ld (store_longread), a 
9ed2			 
9ed2			 
9ed2				; show start up screen 
9ed2			 
9ed2 cd af 8a			call clear_display 
9ed5			 
9ed5 3e 00			ld a,0 
9ed7 32 5e ea			ld (f_cursor_ptr), a 
9eda			 
9eda				; set start of word list in start of ram - for use when creating user words 
9eda			 
9eda 21 dd e3			ld hl, baseram 
9edd 22 be e5			ld (os_last_new_uword), hl 
9ee0 cd 81 9e			call user_word_eol 
9ee3				 
9ee3			;		call display_data_sp 
9ee3			;		call next_page_prompt 
9ee3			 
9ee3			 
9ee3			 
9ee3			 
9ee3 c9				ret 
9ee4			 
9ee4 .. 00		.bootforth: db " Forth Kernel Init ",0 
9ef8			 
9ef8			; TODO push to stack 
9ef8			 
9ef8			;  
9ef8			 
9ef8			if FORTH_PARSEV2 
9ef8			 
9ef8			 
9ef8				include "forth_parserv2.asm" 
9ef8			 
9ef8			endif 
9ef8			 
9ef8			 
9ef8			; parse cli version 1 
9ef8			 
9ef8			if FORTH_PARSEV1 
9ef8			 
9ef8			 
9ef8			 
9ef8			      include "forth_parserv1.asm" 
9ef8			endif 
9ef8				 
9ef8			if FORTH_PARSEV3 
9ef8			 
9ef8			 
9ef8			 
9ef8			      include "forth_parserv3.asm" 
9ef8				include "forth_wordsv3.asm" 
9ef8			endif 
9ef8			 
9ef8			if FORTH_PARSEV4 
9ef8			 
9ef8			 
9ef8			 
9ef8			      include "forth_parserv4.asm" 
9ef8				include "forth_wordsv4.asm" 
9ef8			endif 
9ef8			 
9ef8			if FORTH_PARSEV5 
9ef8			 
9ef8			 
9ef8			 
9ef8			      include "forth_parserv5.asm" 
9ef8			 
9ef8			 
9ef8			; A better parser without using malloc and string copies all over the place.  
9ef8			; Exec in situ should be faster 
9ef8			 
9ef8			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ef8			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ef8			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ef8			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ef8			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ef8			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ef8			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ef8			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ef8			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ef8			 
9ef8			; Core word preamble macro 
9ef8			 
9ef8			CWHEAD:   macro nxtword opcode lit len opflags 
9ef8				db WORD_SYS_CORE+opcode             
9ef8				; internal op code number 
9ef8				dw nxtword            
9ef8				; link to next dict word block 
9ef8				db len + 1 
9ef8				; literal length of dict word inc zero term 
9ef8				db lit,0              
9ef8				; literal dict word 
9ef8			        ; TODO db opflags        
9ef8				endm 
9ef8			 
9ef8			 
9ef8			NEXTW: macro  
9ef8				jp macro_next 
9ef8				endm 
9ef8			 
9ef8			macro_next: 
9ef8			if DEBUG_FORTH_PARSE_KEY 
9ef8				DMARK "NXT" 
9ef8				CALLMONITOR 
9ef8			endif	 
9ef8			;	inc hl  ; skip token null term  
9ef8 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9efc ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9f00 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f03			if DEBUG_FORTH_PARSE_KEY 
9f03				DMARK "}AA" 
9f03				CALLMONITOR 
9f03			endif	 
9f03 c3 06 a0			jp execnext 
9f06				;jp exec1 
9f06			       
9f06			 
9f06			 
9f06			; Another go at the parser to compile  
9f06			 
9f06			 
9f06			; TODO rework parser to change all of the string words to byte tokens 
9f06			; TODO do a search for  
9f06			 
9f06			; TODO first run normal parser to zero term sections 
9f06			; TODO for each word do a token look up to get the op code 
9f06			; TODO need some means to flag to the exec that this is a byte code form    
9f06			 
9f06			 
9f06			forthcompile: 
9f06			 
9f06			; 
9f06			; line parse: 
9f06			;       parse raw input buffer 
9f06			;       tokenise the words 
9f06			;       malloc new copy (for looping etc) 
9f06			;       copy to malloc + current pc in line to start of string and add line term 
9f06			;       save on new rsp 
9f06			; 
9f06			 
9f06			; hl to point to the line to tokenise 
9f06			 
9f06			;	push hl 
9f06 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f09			 
9f09			;	ld a,0		; string term on input 
9f09			;	call strlent 
9f09			 
9f09			;	ld (os_tok_len), hl	 ; save string length 
9f09			 
9f09			;if DEBUG_FORTH_TOK 
9f09			;	ex de,hl		 
9f09			;endif 
9f09			 
9f09			;	pop hl 		; get back string pointer 
9f09			 
9f09			if DEBUG_FORTH_TOK 
9f09						DMARK "TOc" 
9f09				CALLMONITOR 
9f09			endif 
9f09 7e			.cptoken2:    ld a,(hl) 
9f0a 23				inc hl 
9f0b fe 7f			cp FORTH_END_BUFFER 
9f0d 28 29			jr z, .cptokendone2 
9f0f fe 00			cp 0 
9f11 28 25			jr z, .cptokendone2 
9f13 fe 22			cp '"' 
9f15 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9f17 fe 20			cp ' ' 
9f19 20 ee			jr nz,  .cptoken2 
9f1b			 
9f1b			; TODO consume comments held between ( and ) 
9f1b			 
9f1b				; we have a space so change to zero term for dict match later 
9f1b 2b				dec hl 
9f1c 3e 00			ld a,0 
9f1e 77				ld (hl), a 
9f1f 23				inc hl 
9f20 18 e7			jr .cptoken2 
9f22				 
9f22			 
9f22			.cptokenstr2: 
9f22				; skip all white space until either eol (because forgot to term) or end double quote 
9f22			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f22				;inc hl ; skip current double quote 
9f22 7e				ld a,(hl) 
9f23 23				inc hl 
9f24 fe 22			cp '"' 
9f26 28 e1			jr z, .cptoken2 
9f28 fe 7f			cp FORTH_END_BUFFER 
9f2a 28 0c			jr z, .cptokendone2 
9f2c fe 00			cp 0 
9f2e 28 08			jr z, .cptokendone2 
9f30 fe 20			cp ' ' 
9f32 28 02			jr z, .cptmp2 
9f34 18 ec			jr .cptokenstr2 
9f36			 
9f36			.cptmp2:	; we have a space so change to zero term for dict match later 
9f36				;dec hl 
9f36				;ld a,"-"	; TODO remove this when working 
9f36				;ld (hl), a 
9f36				;inc hl 
9f36 18 ea			jr .cptokenstr2 
9f38			 
9f38			.cptokendone2: 
9f38				;inc hl 
9f38 3e 7f			ld a, FORTH_END_BUFFER 
9f3a 77				ld (hl),a 
9f3b 23				inc hl 
9f3c 3e 21			ld a, '!' 
9f3e 77				ld (hl),a 
9f3f			 
9f3f 2a c2 e5			ld hl,(os_tok_ptr) 
9f42			         
9f42			if DEBUG_FORTH_TOK 
9f42						DMARK "Tc1" 
9f42				CALLMONITOR 
9f42			endif 
9f42			 
9f42				; push exec string to top of return stack 
9f42				FORTH_RSP_NEXT 
9f42 cd f2 9a			call macro_forth_rsp_next 
9f45				endm 
# End of macro FORTH_RSP_NEXT
9f45 c9				ret 
9f46			 
9f46			; Another go at the parser need to simplify the process 
9f46			 
9f46			forthparse: 
9f46			 
9f46			; 
9f46			; line parse: 
9f46			;       parse raw input buffer 
9f46			;       tokenise the words 
9f46			;       malloc new copy (for looping etc) 
9f46			;       copy to malloc + current pc in line to start of string and add line term 
9f46			;       save on new rsp 
9f46			; 
9f46			 
9f46			; hl to point to the line to tokenise 
9f46			 
9f46			;	push hl 
9f46 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f49			 
9f49			;	ld a,0		; string term on input 
9f49			;	call strlent 
9f49			 
9f49			;	ld (os_tok_len), hl	 ; save string length 
9f49			 
9f49			;if DEBUG_FORTH_TOK 
9f49			;	ex de,hl		 
9f49			;endif 
9f49			 
9f49			;	pop hl 		; get back string pointer 
9f49			 
9f49			if DEBUG_FORTH_TOK 
9f49						DMARK "TOK" 
9f49				CALLMONITOR 
9f49			endif 
9f49 7e			.ptoken2:    ld a,(hl) 
9f4a 23				inc hl 
9f4b fe 7f			cp FORTH_END_BUFFER 
9f4d 28 29			jr z, .ptokendone2 
9f4f fe 00			cp 0 
9f51 28 25			jr z, .ptokendone2 
9f53 fe 22			cp '"' 
9f55 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f57 fe 20			cp ' ' 
9f59 20 ee			jr nz,  .ptoken2 
9f5b			 
9f5b			; TODO consume comments held between ( and ) 
9f5b			 
9f5b				; we have a space so change to zero term for dict match later 
9f5b 2b				dec hl 
9f5c 3e 00			ld a,0 
9f5e 77				ld (hl), a 
9f5f 23				inc hl 
9f60 18 e7			jr .ptoken2 
9f62				 
9f62			 
9f62			.ptokenstr2: 
9f62				; skip all white space until either eol (because forgot to term) or end double quote 
9f62			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f62				;inc hl ; skip current double quote 
9f62 7e				ld a,(hl) 
9f63 23				inc hl 
9f64 fe 22			cp '"' 
9f66 28 e1			jr z, .ptoken2 
9f68 fe 7f			cp FORTH_END_BUFFER 
9f6a 28 0c			jr z, .ptokendone2 
9f6c fe 00			cp 0 
9f6e 28 08			jr z, .ptokendone2 
9f70 fe 20			cp ' ' 
9f72 28 02			jr z, .ptmp2 
9f74 18 ec			jr .ptokenstr2 
9f76			 
9f76			.ptmp2:	; we have a space so change to zero term for dict match later 
9f76				;dec hl 
9f76				;ld a,"-"	; TODO remove this when working 
9f76				;ld (hl), a 
9f76				;inc hl 
9f76 18 ea			jr .ptokenstr2 
9f78			 
9f78			.ptokendone2: 
9f78				;inc hl 
9f78 3e 7f			ld a, FORTH_END_BUFFER 
9f7a 77				ld (hl),a 
9f7b 23				inc hl 
9f7c 3e 21			ld a, '!' 
9f7e 77				ld (hl),a 
9f7f			 
9f7f 2a c2 e5			ld hl,(os_tok_ptr) 
9f82			         
9f82			if DEBUG_FORTH_TOK 
9f82						DMARK "TK1" 
9f82				CALLMONITOR 
9f82			endif 
9f82			 
9f82				; push exec string to top of return stack 
9f82				FORTH_RSP_NEXT 
9f82 cd f2 9a			call macro_forth_rsp_next 
9f85				endm 
# End of macro FORTH_RSP_NEXT
9f85 c9				ret 
9f86			 
9f86			; 
9f86			;	; malloc size + buffer pointer + if is loop flag 
9f86			;	ld hl,(os_tok_len) 		 ; get string length 
9f86			; 
9f86			;	ld a,l 
9f86			; 
9f86			;	cp 0			; we dont want to use a null string 
9f86			;	ret z 
9f86			; 
9f86			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f86			; 
9f86			;	add 5     ; TODO when certain not over writing memory remove 
9f86			; 
9f86			;		 
9f86			; 
9f86			;if DEBUG_FORTH_TOK 
9f86			;			DMARK "TKE" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			; 
9f86			;	ld l,a 
9f86			;	ld h,0 
9f86			;;	push hl   ; save required space for the copy later 
9f86			;	call malloc 
9f86			;if DEBUG_FORTH_TOK 
9f86			;			DMARK "TKM" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			;	if DEBUG_FORTH_MALLOC_GUARD 
9f86			;		push af 
9f86			;		call ishlzero 
9f86			;;		ld a, l 
9f86			;;		add h 
9f86			;;		cp 0 
9f86			;		pop af 
9f86			;		 
9f86			;		call z,malloc_error 
9f86			;	endif 
9f86			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f86			; 
9f86			; 
9f86			;if DEBUG_FORTH_TOK 
9f86			;			DMARK "TKR" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			; 
9f86			;	FORTH_RSP_NEXT 
9f86			; 
9f86			;	;inc hl	 ; go past current buffer pointer 
9f86			;	;inc hl 
9f86			;	;inc hl   ; and past if loop flag 
9f86			;		; TODO Need to set flag  
9f86			; 
9f86			;	 
9f86			;	 
9f86			;	ex de,hl	; malloc is dest 
9f86			;	ld hl, (os_tok_len) 
9f86			;;	pop bc 
9f86			;	ld c, l                
9f86			;	ld b,0 
9f86			;	ld hl, (os_tok_ptr) 
9f86			; 
9f86			;if DEBUG_FORTH_TOK 
9f86			;			DMARK "TKT" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			; 
9f86			;	; do str cpy 
9f86			; 
9f86			;	ldir      ; copy byte in hl to de 
9f86			; 
9f86			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f86			; 
9f86			;if DEBUG_FORTH_TOK 
9f86			; 
9f86			;			DMARK "TKY" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			;	;ld a,0 
9f86			;	;ld a,FORTH_END_BUFFER 
9f86			;	ex de, hl 
9f86			;	;dec hl			 ; go back over the space delim at the end of word 
9f86			;	;ld (hl),a 
9f86			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f86			;	ld a,FORTH_END_BUFFER 
9f86			;	ld (hl),a 
9f86			;	inc hl 
9f86			;	ld a,FORTH_END_BUFFER 
9f86			;	ld (hl),a 
9f86			; 
9f86			;	; init the malloc area data 
9f86			;	; set pc for in current area 
9f86			;	;ld hl, (os_tok_malloc) 
9f86			;	;inc hl 
9f86			;	;inc hl 
9f86			;	;inc hl 
9f86			;	;ex de,hl 
9f86			;	;ld hl, (os_tok_malloc) 
9f86			;	;ld (hl),e 
9f86			;	;inc hl 
9f86			;	;ld (hl),d 
9f86			; 
9f86			; 
9f86			;	ld hl,(os_tok_malloc) 
9f86			;if DEBUG_FORTH_PARSE_KEY 
9f86			;			DMARK "TKU" 
9f86			;	CALLMONITOR 
9f86			;endif 
9f86			; 
9f86			;	ret 
9f86			 
9f86			forthexec: 
9f86			 
9f86			; line exec: 
9f86			; forth parser 
9f86			 
9f86			; 
9f86			;       get current exec line on rsp 
9f86			 
9f86				FORTH_RSP_TOS 
9f86 cd 09 9b			call macro_forth_rsp_tos 
9f89				endm 
# End of macro FORTH_RSP_TOS
9f89			 
9f89			;       restore current pc - hl points to malloc of data 
9f89			 
9f89				;ld e, (hl) 
9f89				;inc hl 
9f89				;ld d, (hl) 
9f89				;ex de,hl 
9f89			 
9f89			 
9f89			exec1: 
9f89 22 c2 e5			ld (os_tok_ptr), hl 
9f8c			 
9f8c				; copy our PC to working vars  
9f8c 22 40 ea			ld (cli_ptr), hl 
9f8f 22 3e ea			ld (cli_origptr), hl 
9f92			 
9f92 7e				ld a,(hl) 
9f93 fe 7f			cp FORTH_END_BUFFER 
9f95 c8				ret z 
9f96			 
9f96				; skip any nulls 
9f96			 
9f96 fe 00			cp 0 
9f98 20 03			jr nz, .execword 
9f9a 23				inc hl 
9f9b 18 ec			jr exec1 
9f9d			 
9f9d			 
9f9d			.execword: 
9f9d			 
9f9d			 
9f9d			 
9f9d			if DEBUG_FORTH_PARSE_KEY 
9f9d						DMARK "KYQ" 
9f9d				CALLMONITOR 
9f9d			endif 
9f9d			;       while at start of word: 
9f9d			; get start of dict (in user area first) 
9f9d			 
9f9d 21 dd e3		ld hl, baseram 
9fa0			;ld hl, sysdict 
9fa0 22 42 ea		ld (cli_nextword),hl 
9fa3			;           match word at pc 
9fa3			;           exec word 
9fa3			;           or push to dsp 
9fa3			;           forward to next token 
9fa3			;           if line term pop rsp and exit 
9fa3			;        
9fa3			 
9fa3			if DEBUG_FORTH_PARSE_KEY 
9fa3						DMARK "KYq" 
9fa3				CALLMONITOR 
9fa3			endif 
9fa3			 
9fa3			; 
9fa3			; word comp 
9fa3			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9fa3			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9fa3			;    move to start of word  
9fa3			;    compare word to cli_token 
9fa3			 
9fa3			.execpnword:	; HL at start of a word in the dictionary to check 
9fa3			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9fa3			;	ld (cli_ptr), hl 
9fa3			 
9fa3 2a 42 ea			ld hl,(cli_nextword) 
9fa6			 
9fa6 cd 49 a0			call forth_tok_next 
9fa9			; tok next start here 
9fa9			;	; TODO skip compiled symbol for now 
9fa9			;	inc hl 
9fa9			; 
9fa9			;	; save pointer to next word 
9fa9			; 
9fa9			;	; hl now points to the address of the next word pointer  
9fa9			;	ld e, (hl) 
9fa9			;	inc hl 
9fa9			;	ld d, (hl) 
9fa9			;	inc l 
9fa9			; 
9fa9			;	ex de,hl 
9fa9			;if DEBUG_FORTH_PARSE_NEXTWORD 
9fa9			;	push bc 
9fa9			;	ld bc, (cli_nextword) 
9fa9			;			DMARK "NXW" 
9fa9			;	CALLMONITOR 
9fa9			;	pop bc 
9fa9			;endif 
9fa9			; tok next end here 
9fa9 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9fac eb				ex de, hl 
9fad			 
9fad			 
9fad				; save the pointer of the current token - 1 to check against 
9fad				 
9fad 22 46 ea			ld (cli_token), hl   
9fb0				; TODO maybe remove below save if no debug 
9fb0				; save token string ptr for any debug later 
9fb0 23				inc hl  
9fb1 22 48 ea			ld (cli_origtoken), hl 
9fb4 2b				dec hl 
9fb5				; save pointer to the start of the next dictionay word 
9fb5 7e				ld a,(hl)   ; get string length 
9fb6 47				ld b,a 
9fb7			.execpnwordinc:  
9fb7 23				inc hl 
9fb8 10 fd			djnz .execpnwordinc 
9fba 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9fbd			 
9fbd				; now check the word token against the string being parsed 
9fbd			 
9fbd 2a 46 ea			ld hl,(cli_token) 
9fc0 23				inc hl     ; skip string length (use zero term instead to end) 
9fc1 22 46 ea			ld (cli_token), hl 
9fc4			 
9fc4			if DEBUG_FORTH_PARSE_KEY 
9fc4						DMARK "KY2" 
9fc4			endif 
9fc4			if DEBUG_FORTH_PARSE_EXEC 
9fc4				; see if disabled 
9fc4			 
9fc4			;	ld a, (os_view_disable) 
9fc4			;	cp '*' 
9fc4				ld a, (debug_vector) 
9fc4				cp $c9   ; RET  
9fc4				jr z, .skip 
9fc4			 
9fc4				push hl 
9fc4				push hl 
9fc4				call clear_display 
9fc4				ld de, .compword 
9fc4				ld a, display_row_1 
9fc4				call str_at_display 
9fc4				pop de 
9fc4				ld a, display_row_2 
9fc4				call str_at_display 
9fc4				ld hl,(cli_ptr) 
9fc4				ld a,(hl) 
9fc4			        ld hl, os_word_scratch 
9fc4				ld (hl),a 
9fc4				ld a,0 
9fc4				inc hl 
9fc4				ld (hl),a 	 
9fc4				ld de, os_word_scratch 
9fc4				ld a, display_row_2+10 
9fc4				call str_at_display 
9fc4				call update_display 
9fc4				ld a, 100 
9fc4				call aDelayInMS 
9fc4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fc4				call delay250ms 
9fc4				endif 
9fc4				pop hl 
9fc4			.skip:  
9fc4			endif	 
9fc4			.execpnchar:    ; compare char between token and string to parse 
9fc4			 
9fc4			if DEBUG_FORTH_PARSE_KEY 
9fc4						DMARK "Ky3" 
9fc4			endif 
9fc4			if DEBUG_FORTH_PARSE_EXEC 
9fc4				; see if disabled 
9fc4			 
9fc4			;	ld a, (os_view_disable) 
9fc4			;	cp '*' 
9fc4				ld a, (debug_vector) 
9fc4				cp $C9  ; RET 
9fc4				jr z, .skip2 
9fc4			 
9fc4			;	call clear_display 
9fc4			ld hl,(cli_token) 
9fc4			ld a,(hl) 
9fc4			ld (os_word_scratch),a 
9fc4				ld hl,(cli_ptr) 
9fc4			ld a,(hl) 
9fc4				ld (os_word_scratch+1),a 
9fc4				ld a,0 
9fc4				ld (os_word_scratch+2),a 
9fc4				ld de,os_word_scratch 
9fc4				ld a,display_row_4 
9fc4				call str_at_display 
9fc4				call update_display 
9fc4			.skip2:  
9fc4			endif 
9fc4 2a 46 ea			ld hl,(cli_token) 
9fc7 7e				ld a, (hl)	 ; char in word token 
9fc8 23				inc hl 		; move to next char 
9fc9 22 46 ea			ld (cli_token), hl ; and save it 
9fcc 47				ld b,a 
9fcd			 
9fcd 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9fd0 7e				ld a,(hl) 
9fd1 23				inc hl 
9fd2 22 40 ea			ld (cli_ptr), hl		; move to next char 
9fd5 cd 31 91			call toUpper 		; make sure the input string matches case 
9fd8			 
9fd8			if DEBUG_FORTH_PARSE 
9fd8			endif 
9fd8			 
9fd8				; input stream end of token is a space so get rid of it 
9fd8			 
9fd8			;	cp ' ' 
9fd8			;	jr nz, .pnskipspace 
9fd8			; 
9fd8			;	ld a, 0		; make same term as word token term 
9fd8			; 
9fd8			;.pnskipspace: 
9fd8			 
9fd8			if DEBUG_FORTH_PARSE_KEY 
9fd8						DMARK "KY7" 
9fd8			endif 
9fd8 b8				cp b 
9fd9 c2 ef 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fdc				 
9fdc			;    if same 
9fdc			;       scan for string terms 0 for token and 32 for input 
9fdc			 
9fdc				 
9fdc			if DEBUG_FORTH_PARSE_KEY 
9fdc						DMARK "KY8" 
9fdc			endif 
9fdc			 
9fdc 80				add b			 
9fdd fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fdf							; TODO need to make sure last word in zero term string is accounted for 
9fdf 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9fe1			 
9fe1			 
9fe1				; at end of both strings so both are exact match 
9fe1			 
9fe1			;       skip ptr for next word 
9fe1			 
9fe1 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9fe4 23				inc hl			 ; at next char 
9fe5 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9fe8 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9feb				 
9feb				 
9feb			if DEBUG_FORTH_PARSE_KEY 
9feb						DMARK "KY3" 
9feb			endif 
9feb			 
9feb			 
9feb			 
9feb			;       exec code block 
9feb			if DEBUG_FORTH_JP 
9feb				call clear_display 
9feb				call update_display 
9feb				call delay1s 
9feb				ld hl, (cli_execword)     ; save for next check if no match on this word 
9feb				ld a,h 
9feb				ld hl, os_word_scratch 
9feb				call hexout 
9feb				ld hl, (cli_execword)     ; save for next check if no match on this word 
9feb				ld a,l 
9feb				ld hl, os_word_scratch+2 
9feb				call hexout 
9feb				ld hl, os_word_scratch+4 
9feb				ld a,0 
9feb				ld (hl),a 
9feb				ld de,os_word_scratch 
9feb				call str_at_display 
9feb					ld a, display_row_2 
9feb					call str_at_display 
9feb				ld de, (cli_origtoken) 
9feb				ld a, display_row_1+10 
9feb					call str_at_display 
9feb			 
9feb				ld a,display_row_1 
9feb				ld de, .foundword 
9feb				ld a, display_row_3 
9feb				call str_at_display 
9feb				call update_display 
9feb				call delay1s 
9feb				call delay1s 
9feb				call delay1s 
9feb			endif 
9feb			 
9feb			if DEBUG_FORTH_PARSE_KEY 
9feb						DMARK "KYj" 
9feb			endif 
9feb				; TODO save the word pointer in this exec 
9feb			 
9feb 2a 44 ea			ld hl,(cli_execword) 
9fee e9				jp (hl) 
9fef			 
9fef			 
9fef			;    if not same 
9fef			;	scan for zero term 
9fef			;	get ptr for next word 
9fef			;	goto word comp 
9fef			 
9fef			.execpnskipword:	; get pointer to next word 
9fef 2a 42 ea			ld hl,(cli_nextword) 
9ff2			 
9ff2 7e				ld a,(hl) 
9ff3 fe 00			cp WORD_SYS_END 
9ff5			;	cp 0 
9ff5 28 09			jr z, .execendofdict			 ; at end of words 
9ff7			 
9ff7			if DEBUG_FORTH_PARSE_KEY 
9ff7						DMARK "KY4" 
9ff7			endif 
9ff7			if DEBUG_FORTH_PARSE_EXEC 
9ff7			 
9ff7				; see if disabled 
9ff7			 
9ff7			;	ld a, (os_view_disable) 
9ff7			;	cp '*' 
9ff7				ld a,(debug_vector) 
9ff7				cp $c9   ; RET 
9ff7				jr z, .noskip 
9ff7			 
9ff7			 
9ff7				ld de, .nowordfound 
9ff7				ld a, display_row_3 
9ff7				call str_at_display 
9ff7				call update_display 
9ff7				ld a, 100 
9ff7				call aDelayInMS 
9ff7				 
9ff7				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ff7					call delay250ms 
9ff7				endif 
9ff7			.noskip:  
9ff7			 
9ff7			endif	 
9ff7			 
9ff7 2a 3e ea			ld hl,(cli_origptr) 
9ffa 22 40 ea			ld (cli_ptr),hl 
9ffd			 
9ffd			if DEBUG_FORTH_PARSE_KEY 
9ffd						DMARK "KY5" 
9ffd			endif 
9ffd c3 a3 9f			jp .execpnword			; else go to next word 
a000			 
a000			.execendofdict:  
a000			 
a000			if DEBUG_FORTH_PARSE_KEY 
a000						DMARK "KYe" 
a000			endif 
a000			if DEBUG_FORTH_PARSE_EXEC 
a000				; see if disabled 
a000			 
a000			;	ld a, (os_view_disable) 
a000			;	cp '*' 
a000				ld a,(debug_vector) 
a000				cp $c9   ; ret 
a000				jr z, .ispskip 
a000			 
a000				call clear_display 
a000				call update_display 
a000				call delay1s 
a000				ld de, (cli_origptr) 
a000				ld a, display_row_1 
a000				call str_at_display 
a000				 
a000				ld de, .enddict 
a000				ld a, display_row_3 
a000				call str_at_display 
a000				call update_display 
a000				ld a, 100 
a000				call aDelayInMS 
a000				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a000				call delay1s 
a000				call delay1s 
a000				call delay1s 
a000				endif 
a000			.ispskip:  
a000				 
a000			endif	 
a000			 
a000			 
a000			 
a000				; if the word is not a keyword then must be a literal so push it to stack 
a000			 
a000			; push token to stack to end of word 
a000			 
a000				STACKFRAME ON $1efe $2f9f 
a000				if DEBUG_STACK_IMB 
a000					if ON 
a000						exx 
a000						ld de, $1efe 
a000						ld a, d 
a000						ld hl, curframe 
a000						call hexout 
a000						ld a, e 
a000						ld hl, curframe+2 
a000						call hexout 
a000						ld hl, $1efe 
a000						push hl 
a000						ld hl, $2f9f 
a000						push hl 
a000						exx 
a000					endif 
a000				endif 
a000			endm 
# End of macro STACKFRAME
a000			 
a000 2a c2 e5		ld hl,(os_tok_ptr) 
a003 cd b4 9c		call forth_apush 
a006			 
a006				STACKFRAMECHK ON $1efe $2f9f 
a006				if DEBUG_STACK_IMB 
a006					if ON 
a006						exx 
a006						ld hl, $2f9f 
a006						pop de   ; $2f9f 
a006						call cmp16 
a006						jr nz, .spnosame 
a006						ld hl, $1efe 
a006						pop de   ; $1efe 
a006						call cmp16 
a006						jr z, .spfrsame 
a006						.spnosame: call showsperror 
a006						.spfrsame: nop 
a006						exx 
a006					endif 
a006				endif 
a006			endm 
# End of macro STACKFRAMECHK
a006			 
a006			execnext: 
a006			 
a006			if DEBUG_FORTH_PARSE_KEY 
a006						DMARK "KY>" 
a006			endif 
a006			; move past token to next word 
a006			 
a006 2a c2 e5		ld hl, (os_tok_ptr) 
a009 3e 00		ld a, 0 
a00b 01 ff 00		ld bc, 255     ; input buffer size 
a00e ed b1		cpir 
a010			 
a010			if DEBUG_FORTH_PARSE_KEY 
a010						DMARK "KY!" 
a010				CALLMONITOR 
a010			endif	 
a010			; TODO this might place hl on the null, so will need to forward on??? 
a010			;inc hl   ; see if this gets onto the next item 
a010			 
a010			 
a010			; TODO pass a pointer to the buffer to push 
a010			; TODO call function to push 
a010			 
a010			; look for end of input 
a010			 
a010			;inc hl 
a010			;ld a,(hl) 
a010			;cp FORTH_END_BUFFER 
a010			;ret z 
a010			 
a010			 
a010 c3 89 9f		jp exec1 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			 
a013			findnexttok: 
a013			 
a013				; hl is pointer to move 
a013				; de is the token to locate 
a013			 
a013					if DEBUG_FORTH 
a013						DMARK "NTK" 
a013						CALLMONITOR 
a013					endif 
a013 d5				push de 
a014			 
a014			.fnt1:	 
a014				; find first char of token to locate 
a014			 
a014 1a				ld a, (de) 
a015 4f				ld c,a 
a016 7e				ld a,(hl) 
a017 cd 31 91			call toUpper 
a01a					if DEBUG_FORTH 
a01a						DMARK "NT1" 
a01a						CALLMONITOR 
a01a					endif 
a01a b9				cp c 
a01b			 
a01b 28 03			jr z, .fnt2cmpmorefirst	 
a01d			 
a01d				; first char not found move to next char 
a01d			 
a01d 23				inc hl 
a01e 18 f4			jr .fnt1 
a020			 
a020			.fnt2cmpmorefirst:	 
a020				; first char of token found.  
a020			 
a020 e5				push hl     ; save start of token just in case it is the right one 
a021 d9				exx 
a022 e1				pop hl        ; save it to hl' 
a023 d9				exx 
a024			 
a024			 
a024			.fnt2cmpmore:	 
a024				; compare the rest 
a024				 
a024 23				inc hl 
a025 13				inc de 
a026				 
a026 1a				ld a, (de) 
a027 4f				ld c,a 
a028 7e				ld a,(hl) 
a029 cd 31 91			call toUpper 
a02c			 
a02c					if DEBUG_FORTH 
a02c						DMARK "NT2" 
a02c						CALLMONITOR 
a02c					endif 
a02c				; c has the token to find char 
a02c				; a has the mem to scan char 
a02c			 
a02c b9				cp c 
a02d 28 04			jr z,.fntmatch1 
a02f			 
a02f				; they are not the same 
a02f			 
a02f					if DEBUG_FORTH 
a02f						DMARK "NT3" 
a02f						CALLMONITOR 
a02f					endif 
a02f d1				pop de	; reset de token to look for 
a030 d5				push de 
a031 18 e1			jr .fnt1 
a033				 
a033			.fntmatch1: 
a033			 
a033				; is the same char a null which means we might have a full hit? 
a033					if DEBUG_FORTH 
a033						DMARK "NT4" 
a033						CALLMONITOR 
a033					endif 
a033			 
a033 fe 00			cp 0 
a035 28 0b			jr z, .fntmatchyes 
a037			 
a037				; are we at the end of the token to find? 
a037			 
a037					if DEBUG_FORTH 
a037						DMARK "NT5" 
a037						CALLMONITOR 
a037					endif 
a037 3e 00			ld a, 0 
a039 b9				cp c 
a03a			 
a03a c2 24 a0			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a03d			 
a03d					if DEBUG_FORTH 
a03d						DMARK "NT6" 
a03d						CALLMONITOR 
a03d					endif 
a03d				; token to find is exhusted but no match to stream 
a03d			 
a03d				; restore tok pointer and continue on 
a03d d1				pop de 
a03e d5				push de 
a03f c3 14 a0			jp .fnt1 
a042			 
a042			 
a042			.fntmatchyes: 
a042			 
a042				; hl now contains the end of the found token 
a042			 
a042				; get rid of saved token pointer to find 
a042			 
a042 d1				pop de 
a043			 
a043					if DEBUG_FORTH 
a043						DMARK "NT9" 
a043						CALLMONITOR 
a043					endif 
a043			 
a043				; hl will be on the null term so forward on 
a043			 
a043				; get back the saved start of the token 
a043			 
a043 d9				exx 
a044 e5				push hl     ; save start of token just in case it is the right one 
a045 d9				exx 
a046 e1				pop hl        ; save it to hl 
a047			 
a047 c9				ret 
a048			 
a048			 
a048			; LIST needs to find a specific token   
a048			; FORGET needs to find a spefici token 
a048			 
a048			; SAVE needs to find all tokens by flag 
a048			; WORDS just needs to scan through all  by flag 
a048			; UWORDS needs to scan through all by flag 
a048			 
a048			 
a048			; given hl as pointer to start of dict look up string 
a048			; return hl as pointer to start of word block 
a048			; or 0 if not found 
a048			 
a048			forth_find_tok: 
a048 c9				ret 
a049			 
a049			; given hl as pointer to dict structure 
a049			; move to the next dict block structure 
a049			 
a049			forth_tok_next: 
a049				; hl now points to the address of the next word pointer  
a049				; TODO skip compiled symbol for now 
a049			;	push de 
a049 23				inc hl 
a04a 5e				ld e, (hl) 
a04b 23				inc hl 
a04c 56				ld d, (hl) 
a04d 23				inc hl 
a04e			 
a04e eb				ex de,hl 
a04f			if DEBUG_FORTH_PARSE_NEXTWORD 
a04f				push bc 
a04f				ld bc, (cli_nextword) 
a04f						DMARK "NXW" 
a04f				CALLMONITOR 
a04f				pop bc 
a04f			endif 
a04f			;	pop de	 
a04f c9				ret 
a050			 
a050			 
a050			 
a050			; eof 
# End of file forth_parserv5.asm
a050				include "forth_wordsv4.asm" 
a050			 
a050			; the core word dictionary v4 
a050			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a050			 
a050			; this is a linked list for each of the system words used 
a050			; user defined words will follow the same format but will be in ram 
a050			 
a050			 
a050			; 
a050			; 
a050			; define linked list: 
a050			; 
a050			; 1. compiled byte op code 
a050			; 2. len of text word 
a050			; 3. text word 
a050			; 4. ptr to next dictionary word 
a050			; 5. asm, calls etc for the word 
a050			; 
a050			;  if 1 == 0 then last word in dict  
a050			;   
a050			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a050			;  
a050			;  
a050			; create basic standard set of words 
a050			; 
a050			;  
a050			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a050			; 2DUP 2DROP 2SWAP  
a050			; @ C@ - get byte  
a050			; ! C! - store byte 
a050			; 0< true if less than zero 
a050			; 0= true if zero 
a050			; < >  
a050			; = true if same 
a050			; variables 
a050			 
a050			 
a050			; Hardware specific words I may need 
a050			; 
a050			; IN OUT  
a050			; calls to key util functions 
a050			; calls to hardward abstraction stuff 
a050			; easy control of frame buffers and lcd i/o 
a050			; keyboard  
a050			 
a050			 
a050			;DICT: macro 
a050			; op_code, len, word, next 
a050			;    word: 
a050			;    db op_code 
a050			;    ds word zero term 
a050			;    dw next 
a050			;    endm 
a050			 
a050			 
a050			 
a050			 
a050			; op code 1 is a flag for user define words which are to be handled differently 
a050			 
a050			 
a050			; 
a050			; 
a050			;    TODO on entry to a word this should be the expected environment 
a050			;    hl - tos value if number then held, if string this is the ptr 
a050			;    de -  
a050			 
a050			 
a050			; opcode ranges 
a050			; 0 - end of word dict 
a050			; 255 - user define words 
a050			 
a050			sysdict: 
a050			include "forth_opcodes.asm" 
a050			; op codes for forth keywords 
a050			; free to use code 0  
a050				OPCODE_HEAP: equ  1 
a050				OPCODE_EXEC: equ 2 
a050				OPCODE_DUP: equ 3 
a050				OPCODE_SWAP: equ 4 
a050				OPCODE_COLN: equ 5 
a050				OPCODE_SCOLN: equ 6 
a050				OPCODE_DROP: equ 7 
a050				OPCODE_DUP2: equ 8 
a050				OPCODE_DROP2: equ 9 
a050				OPCODE_SWAP2: equ 10 
a050				OPCODE_AT: equ 11 
a050				OPCODE_CAT: equ 12 
a050				OPCODE_BANG: equ 13 
a050				OPCODE_CBANG: equ 14 
a050				OPCODE_SCALL: equ 15 
a050				OPCODE_DEPTH: equ 16 
a050				OPCODE_OVER: equ 17 
a050				OPCODE_PAUSE: equ 18 
a050				OPCODE_PAUSES: equ 19 
a050				OPCODE_ROT: equ 20 
a050			;free to reuse	OPCODE_WORDS: equ 21 
a050			        OPCODE_NOT: equ 21 
a050				OPCODE_UWORDS: equ 22 
a050				OPCODE_BP: equ 23 
a050				OPCODE_MONITOR: equ 24  
a050				OPCODE_MALLOC: equ 25 
a050				OPCODE_FREE: equ 26 
a050				OPCODE_LIST: equ 27 
a050				OPCODE_FORGET: equ 28 
a050				OPCODE_NOP: equ 29 
a050				OPCODE_COMO: equ 30 
a050				OPCODE_COMC: equ 31 
a050			;free to reuse	OPCODE_ENDCORE: equ 32 
a050				OPCODE_AFTERSOUND: equ 33 
a050				OPCODE_GP2: equ 34 
a050				OPCODE_GP3: equ 35 
a050				OPCODE_GP4: equ 36 
a050				OPCODE_SIN: equ 37 
a050				OPCODE_SOUT: equ 38 
a050				OPCODE_SPIO: equ 39 
a050				OPCODE_SPICEH: equ 40 
a050				OPCODE_SPIOb: equ 41 
a050				OPCODE_SPII: equ 42 
a050				OPCODE_SESEL: equ 43 
a050				OPCODE_CARTDEV: equ 44 
a050			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a050				OPCODE_FB: equ 46 
a050				OPCODE_EMIT: equ 47 
a050				OPCODE_DOTH: equ 48 
a050				OPCODE_DOTF: equ 49 
a050				OPCODE_DOT: equ 50 
a050				OPCODE_CLS: equ 51 
a050				OPCODE_DRAW: equ 52 
a050				OPCODE_DUMP: equ 53 
a050				OPCODE_CDUMP: equ 54 
a050				OPCODE_DAT: equ 55 
a050				OPCODE_HOME: equ 56 
a050				OPCODE_SPACE: equ 57 
a050				OPCODE_SPACES: equ 58 
a050				OPCODE_SCROLL: equ 59 
a050				OPCODE_ATQ: equ 60 
a050				OPCODE_AUTODSP: equ 61 
a050				OPCODE_MENU: equ 62 
a050			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a050				OPCODE_THEN: equ 64 
a050				OPCODE_ELSE: equ 65 
a050				OPCODE_DO: equ 66 
a050				OPCODE_LOOP: equ 67 
a050				OPCODE_I: equ 68 
a050				OPCODE_DLOOP: equ 69  
a050				OPCODE_REPEAT: equ 70  
a050				OPCODE_UNTIL: equ 71 
a050				OPCODE_ENDFLOW: equ 72 
a050				OPCODE_WAITK: equ 73 
a050				OPCODE_ACCEPT: equ 74 
a050				OPCODE_EDIT: equ 75 
a050			;free to reuse	OPCODE_ENDKEY: equ 76 
a050				OPCODE_LZERO: equ 77 
a050				OPCODE_TZERO: equ 78 
a050				OPCODE_LESS: equ 79 
a050				OPCODE_GT: equ 80 
a050				OPCODE_EQUAL: equ 81  
a050			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a050				OPCODE_NEG: equ 83 
a050				OPCODE_DIV: equ 84 
a050				OPCODE_MUL: equ 85 
a050				OPCODE_MIN: equ 86 
a050				OPCODE_MAX: equ 87 
a050				OPCODE_RND16: equ 88 
a050				OPCODE_RND8: equ 89 
a050				OPCODE_RND: equ 90 
a050			;free to reuse	OPCODE_ENDMATHS: equ 91  
a050				OPCODE_BYNAME: equ 92 
a050				OPCODE_DIR: equ 93 
a050				OPCODE_SAVE: equ 94 
a050				OPCODE_LOAD: equ 95 
a050				OPCODE_BSAVE: equ 96 
a050				OPCODE_BLOAD: equ 97 
a050				OPCODE_SEO: equ 98  
a050				OPCODE_SEI: equ 99 
a050				OPCODE_SFREE: equ 100 
a050				OPCODE_SIZE: equ 101 
a050				OPCODE_CREATE: equ 102 
a050				OPCODE_APPEND: equ 103 
a050				OPCODE_SDEL: equ 104 
a050				OPCODE_OPEN: equ 105 
a050				OPCODE_READ: equ 106 
a050				OPCODE_EOF: equ 106 
a050				OPCODE_FORMAT: equ 107 
a050				OPCODE_LABEL: equ 108 
a050				OPCODE_LABELS: equ 109 
a050			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a050				OPCODE_UPPER: equ 111 
a050				OPCODE_LOWER: equ 112 
a050				OPCODE_SUBSTR: equ 113 
a050				OPCODE_LEFT: equ 114 
a050				OPCODE_RIGHT: equ 115 
a050				OPCODE_STR2NUM: equ 116 
a050				OPCODE_NUM2STR: equ 117 
a050				OPCODE_CONCAT: equ 118 
a050				OPCODE_FIND: equ 119 
a050				OPCODE_LEN: equ 120 
a050				OPCODE_CHAR: equ 121 
a050			; free to reuse	OPCODE_STRLEN: equ 122 
a050			; free to reuse	OPCODE_ENDSTR: equ 123 
a050				OPCODE_V0S: equ 124 
a050				OPCODE_V0Q: equ 125 
a050				OPCODE_V1S: equ 126 
a050				OPCODE_V1Q: equ 127 
a050				OPCODE_V2S: equ 128 
a050				OPCODE_V2Q: equ 129 
a050				OPCODE_V3S: equ 130 
a050				OPCODE_V3Q: equ 131 
a050			;free to reuse	OPCODE_END: equ 132 
a050				OPCODE_ZDUP: equ 133 
a050			 
a050			; eof 
# End of file forth_opcodes.asm
a050			 
a050			include "forth_words_core.asm" 
a050			 
a050			; | ## Core Words 
a050			 
a050			;if MALLOC_4 
a050			 
a050			.HEAP: 
a050				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a050 15				db WORD_SYS_CORE+OPCODE_HEAP             
a051 8f a0			dw .EXEC            
a053 05				db 4 + 1 
a054 .. 00			db "HEAP",0              
a059				endm 
# End of macro CWHEAD
a059			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a059			; | | u1 - Current number of bytes in the heap 
a059			; | | u2 - Remaining bytes left on the heap 
a059			; | |  
a059			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a059			 
a059			 
a059					if DEBUG_FORTH_WORDS_KEY 
a059						DMARK "HEP" 
a059 f5				push af  
a05a 3a 6e a0			ld a, (.dmark)  
a05d 32 6b ee			ld (debug_mark),a  
a060 3a 6f a0			ld a, (.dmark+1)  
a063 32 6c ee			ld (debug_mark+1),a  
a066 3a 70 a0			ld a, (.dmark+2)  
a069 32 6d ee			ld (debug_mark+2),a  
a06c 18 03			jr .pastdmark  
a06e ..			.dmark: db "HEP"  
a071 f1			.pastdmark: pop af  
a072			endm  
# End of macro DMARK
a072						CALLMONITOR 
a072 cd 6f ee			call debug_vector  
a075				endm  
# End of macro CALLMONITOR
a075					endif 
a075 2a e7 e3				ld hl, (free_list )      
a078 11 ec e3				ld de, heap_start 
a07b			 
a07b ed 52				sbc hl, de  
a07d			 
a07d cd 4b 9b				call forth_push_numhl 
a080			 
a080			 
a080 ed 5b e7 e3			ld de, (free_list )      
a084 21 a8 e2				ld hl, heap_end 
a087			 
a087 ed 52				sbc hl, de 
a089			 
a089 cd 4b 9b				call forth_push_numhl 
a08c					 
a08c			 
a08c					 
a08c			 
a08c			 
a08c			 
a08c					NEXTW 
a08c c3 f8 9e			jp macro_next 
a08f				endm 
# End of macro NEXTW
a08f			;endif 
a08f			 
a08f			.EXEC: 
a08f			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a08f			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a08f			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a08f			;; > > 
a08f			;; > >   
a08f			;	STACKFRAME OFF $5efe $5f9f 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS_KEY 
a08f			;			DMARK "EXE" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	FORTH_DSP_VALUEHL 
a08f			; 
a08f			;	FORTH_DSP_POP 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX1" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;;	ld e,(hl) 
a08f			;;	inc hl 
a08f			;;	ld d,(hl) 
a08f			;;	ex de,hl 
a08f			; 
a08f			;;		if DEBUG_FORTH_WORDS 
a08f			;;			DMARK "EX2" 
a08f			;;			CALLMONITOR 
a08f			;;		endif 
a08f			;	push hl 
a08f			; 
a08f			;	;ld a, 0 
a08f			;	;ld a, FORTH_END_BUFFER 
a08f			;	call strlenz 
a08f			;	inc hl   ; include zero term to copy 
a08f			;	inc hl   ; include term 
a08f			;	inc hl   ; include term 
a08f			;	ld b,0 
a08f			;	ld c,l 
a08f			;	pop hl 
a08f			;	ld de, execscratch 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX3" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	ldir 
a08f			; 
a08f			; 
a08f			;	ld hl, execscratch 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EXe" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	call forthparse 
a08f			;	call forthexec 
a08f			;;	call forthexec_cleanup 
a08f			;;	call forthparse 
a08f			;;	call forthexec 
a08f			; 
a08f			;	STACKFRAMECHK OFF $5efe $5f9f 
a08f			; 
a08f			;	; an immediate word so no need to process any more words 
a08f			;	ret 
a08f			;	NEXTW 
a08f			 
a08f			; dead code - old version  
a08f			;	FORTH_RSP_NEXT 
a08f			 
a08f			;  
a08f			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a08f			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a08f			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a08f			;	push hl 
a08f			;	push de 
a08f			;	push bc 
a08f			; 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS_KEY 
a08f			;			DMARK "EXR" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			; 
a08f			; 
a08f			;	;v5 FORTH_DSP_VALUE 
a08f			;	FORTH_DSP_VALUEHL 
a08f			; 
a08f			;	; TODO do string type checks 
a08f			; 
a08f			;;v5	inc hl   ; skip type 
a08f			; 
a08f			;	push hl  ; source code  
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX1" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	ld a, 0 
a08f			;	call strlent 
a08f			; 
a08f			;	inc hl 
a08f			;	inc hl 
a08f			;	inc hl 
a08f			;	inc hl 
a08f			; 
a08f			;	push hl    ; size 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX2" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	call malloc 
a08f			; 
a08f			;	ex de, hl    ; de now contains malloc area 
a08f			;	pop bc   	; get byte count 
a08f			;	pop hl      ; get string to copy 
a08f			; 
a08f			;	push de     ; save malloc for free later 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX3" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	ldir       ; duplicate string 
a08f			; 
a08f			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a08f			;	 
a08f			;	; TODO fix the parse would be better than this...  
a08f			;	ex de, hl 
a08f			;	dec hl 
a08f			;	ld a, 0 
a08f			;	ld (hl), a 
a08f			;	dec hl 
a08f			;	ld a, ' ' 
a08f			;	ld (hl), a 
a08f			;	dec hl 
a08f			;	ld (hl), a 
a08f			; 
a08f			;	dec hl 
a08f			;	ld (hl), a 
a08f			; 
a08f			; 
a08f			;	FORTH_DSP_POP  
a08f			; 
a08f			;	pop hl     
a08f			;	push hl    ; save malloc area 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX4" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	call forthparse 
a08f			;	call forthexec 
a08f			;	 
a08f			;	pop hl 
a08f			;	if DEBUG_FORTH_WORDS 
a08f			;		DMARK "EX5" 
a08f			;		CALLMONITOR 
a08f			;	endif 
a08f			; 
a08f			;	if FORTH_ENABLE_FREE 
a08f			;	call free 
a08f			;	endif 
a08f			; 
a08f			;	if DEBUG_FORTH_WORDS 
a08f			;		DMARK "EX6" 
a08f			;		CALLMONITOR 
a08f			;	endif 
a08f			; 
a08f			;	pop bc 
a08f			;	pop de 
a08f			;	pop hl 
a08f			;;	FORTH_RSP_POP	  
a08f			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a08f			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a08f			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a08f			; 
a08f			;	if DEBUG_FORTH_WORDS 
a08f			;		DMARK "EX7" 
a08f			;		CALLMONITOR 
a08f			;	endif 
a08f			;	NEXTW 
a08f			 
a08f			;.STKEXEC: 
a08f			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a08f			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a08f			; 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS_KEY 
a08f			;			DMARK "STX" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	FORTH_DSP_VALUEHL 
a08f			; 
a08f			;	ld (store_tmp1), hl    ; count 
a08f			; 
a08f			;	FORTH_DSP_POP 
a08f			;.stkexec1: 
a08f			;	ld hl, (store_tmp1)   ; count 
a08f			;	ld a, 0 
a08f			;	cp l 
a08f			;	ret z 
a08f			; 
a08f			;	dec hl 
a08f			;	ld (store_tmp1), hl    ; count 
a08f			;	 
a08f			;	FORTH_DSP_VALUEHL 
a08f			;	push hl 
a08f			;	 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EXp" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	FORTH_DSP_POP 
a08f			; 
a08f			;	call strlenz 
a08f			;	inc hl   ; include zero term to copy 
a08f			;	inc hl   ; include zero term to copy 
a08f			;	inc hl   ; include zero term to copy 
a08f			;	ld b,0 
a08f			;	ld c,l 
a08f			;	pop hl 
a08f			;	ld de, execscratch 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EX3" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	ldir 
a08f			; 
a08f			; 
a08f			;	ld hl, execscratch 
a08f			; 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EXP" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			; 
a08f			;	call forthparse 
a08f			;	ld hl, execscratch 
a08f			;		if DEBUG_FORTH_WORDS 
a08f			;			DMARK "EXx" 
a08f			;			CALLMONITOR 
a08f			;		endif 
a08f			;	call forthexec 
a08f			; 
a08f			;	jp .stkexec1 
a08f			; 
a08f			;	ret 
a08f			 
a08f			 
a08f			.DUP: 
a08f				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a08f 17				db WORD_SYS_CORE+OPCODE_DUP             
a090 05 a1			dw .ZDUP            
a092 04				db 3 + 1 
a093 .. 00			db "DUP",0              
a097				endm 
# End of macro CWHEAD
a097			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a097			 
a097					if DEBUG_FORTH_WORDS_KEY 
a097						DMARK "DUP" 
a097 f5				push af  
a098 3a ac a0			ld a, (.dmark)  
a09b 32 6b ee			ld (debug_mark),a  
a09e 3a ad a0			ld a, (.dmark+1)  
a0a1 32 6c ee			ld (debug_mark+1),a  
a0a4 3a ae a0			ld a, (.dmark+2)  
a0a7 32 6d ee			ld (debug_mark+2),a  
a0aa 18 03			jr .pastdmark  
a0ac ..			.dmark: db "DUP"  
a0af f1			.pastdmark: pop af  
a0b0			endm  
# End of macro DMARK
a0b0						CALLMONITOR 
a0b0 cd 6f ee			call debug_vector  
a0b3				endm  
# End of macro CALLMONITOR
a0b3					endif 
a0b3			 
a0b3					FORTH_DSP 
a0b3 cd 08 9d			call macro_forth_dsp 
a0b6				endm 
# End of macro FORTH_DSP
a0b6			 
a0b6 7e					ld a, (HL) 
a0b7 fe 01				cp DS_TYPE_STR 
a0b9 20 25				jr nz, .dupinum 
a0bb			 
a0bb					; push another string 
a0bb			 
a0bb					FORTH_DSP_VALUEHL     		 
a0bb cd 42 9d			call macro_dsp_valuehl 
a0be				endm 
# End of macro FORTH_DSP_VALUEHL
a0be			 
a0be				if DEBUG_FORTH_WORDS 
a0be					DMARK "DUs" 
a0be f5				push af  
a0bf 3a d3 a0			ld a, (.dmark)  
a0c2 32 6b ee			ld (debug_mark),a  
a0c5 3a d4 a0			ld a, (.dmark+1)  
a0c8 32 6c ee			ld (debug_mark+1),a  
a0cb 3a d5 a0			ld a, (.dmark+2)  
a0ce 32 6d ee			ld (debug_mark+2),a  
a0d1 18 03			jr .pastdmark  
a0d3 ..			.dmark: db "DUs"  
a0d6 f1			.pastdmark: pop af  
a0d7			endm  
# End of macro DMARK
a0d7					CALLMONITOR 
a0d7 cd 6f ee			call debug_vector  
a0da				endm  
# End of macro CALLMONITOR
a0da				endif 
a0da cd b9 9b				call forth_push_str 
a0dd			 
a0dd					NEXTW 
a0dd c3 f8 9e			jp macro_next 
a0e0				endm 
# End of macro NEXTW
a0e0			 
a0e0			 
a0e0			.dupinum: 
a0e0					 
a0e0			 
a0e0			 
a0e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0e0 cd 42 9d			call macro_dsp_valuehl 
a0e3				endm 
# End of macro FORTH_DSP_VALUEHL
a0e3			 
a0e3				; TODO add floating point number detection 
a0e3			 
a0e3				if DEBUG_FORTH_WORDS 
a0e3					DMARK "DUi" 
a0e3 f5				push af  
a0e4 3a f8 a0			ld a, (.dmark)  
a0e7 32 6b ee			ld (debug_mark),a  
a0ea 3a f9 a0			ld a, (.dmark+1)  
a0ed 32 6c ee			ld (debug_mark+1),a  
a0f0 3a fa a0			ld a, (.dmark+2)  
a0f3 32 6d ee			ld (debug_mark+2),a  
a0f6 18 03			jr .pastdmark  
a0f8 ..			.dmark: db "DUi"  
a0fb f1			.pastdmark: pop af  
a0fc			endm  
# End of macro DMARK
a0fc					CALLMONITOR 
a0fc cd 6f ee			call debug_vector  
a0ff				endm  
# End of macro CALLMONITOR
a0ff				endif 
a0ff			 
a0ff cd 4b 9b				call forth_push_numhl 
a102					NEXTW 
a102 c3 f8 9e			jp macro_next 
a105				endm 
# End of macro NEXTW
a105			.ZDUP: 
a105				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a105 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a106 3d a1			dw .SWAP            
a108 05				db 4 + 1 
a109 .. 00			db "?DUP",0              
a10e				endm 
# End of macro CWHEAD
a10e			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a10e			 
a10e					if DEBUG_FORTH_WORDS_KEY 
a10e						DMARK "qDU" 
a10e f5				push af  
a10f 3a 23 a1			ld a, (.dmark)  
a112 32 6b ee			ld (debug_mark),a  
a115 3a 24 a1			ld a, (.dmark+1)  
a118 32 6c ee			ld (debug_mark+1),a  
a11b 3a 25 a1			ld a, (.dmark+2)  
a11e 32 6d ee			ld (debug_mark+2),a  
a121 18 03			jr .pastdmark  
a123 ..			.dmark: db "qDU"  
a126 f1			.pastdmark: pop af  
a127			endm  
# End of macro DMARK
a127						CALLMONITOR 
a127 cd 6f ee			call debug_vector  
a12a				endm  
# End of macro CALLMONITOR
a12a					endif 
a12a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a12a cd 42 9d			call macro_dsp_valuehl 
a12d				endm 
# End of macro FORTH_DSP_VALUEHL
a12d			 
a12d e5					push hl 
a12e			 
a12e					; is it a zero? 
a12e			 
a12e 3e 00				ld a, 0 
a130 84					add h 
a131 85					add l 
a132			 
a132 e1					pop hl 
a133			 
a133 fe 00				cp 0 
a135 28 03				jr z, .dup2orig 
a137			 
a137			 
a137 cd 4b 9b				call forth_push_numhl 
a13a			 
a13a			 
a13a				; TODO add floating point number detection 
a13a			 
a13a			.dup2orig: 
a13a			 
a13a					NEXTW 
a13a c3 f8 9e			jp macro_next 
a13d				endm 
# End of macro NEXTW
a13d			.SWAP: 
a13d				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a13d 18				db WORD_SYS_CORE+OPCODE_SWAP             
a13e 7c a1			dw .COLN            
a140 05				db 4 + 1 
a141 .. 00			db "SWAP",0              
a146				endm 
# End of macro CWHEAD
a146			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a146					if DEBUG_FORTH_WORDS_KEY 
a146						DMARK "SWP" 
a146 f5				push af  
a147 3a 5b a1			ld a, (.dmark)  
a14a 32 6b ee			ld (debug_mark),a  
a14d 3a 5c a1			ld a, (.dmark+1)  
a150 32 6c ee			ld (debug_mark+1),a  
a153 3a 5d a1			ld a, (.dmark+2)  
a156 32 6d ee			ld (debug_mark+2),a  
a159 18 03			jr .pastdmark  
a15b ..			.dmark: db "SWP"  
a15e f1			.pastdmark: pop af  
a15f			endm  
# End of macro DMARK
a15f						CALLMONITOR 
a15f cd 6f ee			call debug_vector  
a162				endm  
# End of macro CALLMONITOR
a162					endif 
a162			 
a162					FORTH_DSP_VALUEHL 
a162 cd 42 9d			call macro_dsp_valuehl 
a165				endm 
# End of macro FORTH_DSP_VALUEHL
a165 e5					push hl     ; w2 
a166			 
a166					FORTH_DSP_POP 
a166 cd fa 9d			call macro_forth_dsp_pop 
a169				endm 
# End of macro FORTH_DSP_POP
a169			 
a169					FORTH_DSP_VALUEHL 
a169 cd 42 9d			call macro_dsp_valuehl 
a16c				endm 
# End of macro FORTH_DSP_VALUEHL
a16c			 
a16c					FORTH_DSP_POP 
a16c cd fa 9d			call macro_forth_dsp_pop 
a16f				endm 
# End of macro FORTH_DSP_POP
a16f			 
a16f d1					pop de     ; w2	, hl = w1 
a170			 
a170 eb					ex de, hl 
a171 d5					push de 
a172			 
a172 cd 4b 9b				call forth_push_numhl 
a175			 
a175 e1					pop hl 
a176			 
a176 cd 4b 9b				call forth_push_numhl 
a179					 
a179			 
a179					NEXTW 
a179 c3 f8 9e			jp macro_next 
a17c				endm 
# End of macro NEXTW
a17c			.COLN: 
a17c				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a17c 19				db WORD_SYS_CORE+OPCODE_COLN             
a17d 08 a3			dw .SCOLN            
a17f 02				db 1 + 1 
a180 .. 00			db ":",0              
a182				endm 
# End of macro CWHEAD
a182			; | : ( -- )         Create new word | DONE 
a182			 
a182					if DEBUG_FORTH_WORDS_KEY 
a182						DMARK "CLN" 
a182 f5				push af  
a183 3a 97 a1			ld a, (.dmark)  
a186 32 6b ee			ld (debug_mark),a  
a189 3a 98 a1			ld a, (.dmark+1)  
a18c 32 6c ee			ld (debug_mark+1),a  
a18f 3a 99 a1			ld a, (.dmark+2)  
a192 32 6d ee			ld (debug_mark+2),a  
a195 18 03			jr .pastdmark  
a197 ..			.dmark: db "CLN"  
a19a f1			.pastdmark: pop af  
a19b			endm  
# End of macro DMARK
a19b						CALLMONITOR 
a19b cd 6f ee			call debug_vector  
a19e				endm  
# End of macro CALLMONITOR
a19e					endif 
a19e				STACKFRAME OFF $8efe $989f 
a19e				if DEBUG_STACK_IMB 
a19e					if OFF 
a19e						exx 
a19e						ld de, $8efe 
a19e						ld a, d 
a19e						ld hl, curframe 
a19e						call hexout 
a19e						ld a, e 
a19e						ld hl, curframe+2 
a19e						call hexout 
a19e						ld hl, $8efe 
a19e						push hl 
a19e						ld hl, $989f 
a19e						push hl 
a19e						exx 
a19e					endif 
a19e				endif 
a19e			endm 
# End of macro STACKFRAME
a19e				; get parser buffer length  of new word 
a19e			 
a19e				 
a19e			 
a19e					; move tok past this to start of name defintition 
a19e					; TODO get word to define 
a19e					; TODO Move past word token 
a19e					; TODO get length of string up to the ';' 
a19e			 
a19e 2a c2 e5			ld hl, (os_tok_ptr) 
a1a1 23				inc hl 
a1a2 23				inc hl 
a1a3			 
a1a3 3e 3b			ld a, ';' 
a1a5 cd 45 91			call strlent 
a1a8			 
a1a8 7d				ld a,l 
a1a9 32 bd e2			ld (os_new_parse_len), a 
a1ac			 
a1ac			 
a1ac			if DEBUG_FORTH_UWORD 
a1ac ed 5b c2 e5		ld de, (os_tok_ptr) 
a1b0						DMARK ":01" 
a1b0 f5				push af  
a1b1 3a c5 a1			ld a, (.dmark)  
a1b4 32 6b ee			ld (debug_mark),a  
a1b7 3a c6 a1			ld a, (.dmark+1)  
a1ba 32 6c ee			ld (debug_mark+1),a  
a1bd 3a c7 a1			ld a, (.dmark+2)  
a1c0 32 6d ee			ld (debug_mark+2),a  
a1c3 18 03			jr .pastdmark  
a1c5 ..			.dmark: db ":01"  
a1c8 f1			.pastdmark: pop af  
a1c9			endm  
# End of macro DMARK
a1c9				CALLMONITOR 
a1c9 cd 6f ee			call debug_vector  
a1cc				endm  
# End of macro CALLMONITOR
a1cc			endif 
a1cc			 
a1cc			; 
a1cc			;  new word memory layout: 
a1cc			;  
a1cc			;    : adg 6666 ;  
a1cc			; 
a1cc			;    db   1     ; user defined word  
a1cc 23				inc hl    
a1cd			;    dw   sysdict 
a1cd 23				inc hl 
a1ce 23				inc hl 
a1cf			;    db <word len>+1 (for null) 
a1cf 23				inc hl 
a1d0			;    db .... <word> 
a1d0			; 
a1d0			 
a1d0 23				inc hl    ; some extras for the word preamble before the above 
a1d1 23				inc hl 
a1d2 23				inc hl 
a1d3 23				inc hl 
a1d4 23				inc hl 
a1d5 23				inc hl 
a1d6 23				inc hl  
a1d7 23				inc hl 
a1d8 23				inc hl 
a1d9 23				inc hl 
a1da 23				inc hl 
a1db 23				inc hl 
a1dc 23				inc hl 
a1dd 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a1de			;       exec word buffer 
a1de			;	<ptr word>   
a1de 23				inc hl 
a1df 23				inc hl 
a1e0			;       <word list><null term> 7F final term 
a1e0			 
a1e0			 
a1e0			if DEBUG_FORTH_UWORD 
a1e0						DMARK ":02" 
a1e0 f5				push af  
a1e1 3a f5 a1			ld a, (.dmark)  
a1e4 32 6b ee			ld (debug_mark),a  
a1e7 3a f6 a1			ld a, (.dmark+1)  
a1ea 32 6c ee			ld (debug_mark+1),a  
a1ed 3a f7 a1			ld a, (.dmark+2)  
a1f0 32 6d ee			ld (debug_mark+2),a  
a1f3 18 03			jr .pastdmark  
a1f5 ..			.dmark: db ":02"  
a1f8 f1			.pastdmark: pop af  
a1f9			endm  
# End of macro DMARK
a1f9				CALLMONITOR 
a1f9 cd 6f ee			call debug_vector  
a1fc				endm  
# End of macro CALLMONITOR
a1fc			endif 
a1fc			 
a1fc				 
a1fc					; malloc the size 
a1fc			 
a1fc cd a3 91				call malloc 
a1ff 22 bf e2				ld (os_new_malloc), hl     ; save malloc start 
a202			 
a202			;    db   1     ; user defined word  
a202 3e 01				ld a, WORD_SYS_UWORD  
a204 77					ld (hl), a 
a205				 
a205 23				inc hl    
a206			;    dw   sysdict 
a206 11 50 a0			ld de, sysdict       ; continue on with the scan to the system dict 
a209 73				ld (hl), e 
a20a 23				inc hl 
a20b 72				ld (hl), d 
a20c 23				inc hl 
a20d			 
a20d			 
a20d			;    Setup dict word 
a20d			 
a20d 23				inc hl 
a20e 22 b9 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a211			 
a211				; 1. get length of dict word 
a211			 
a211			 
a211 2a c2 e5			ld hl, (os_tok_ptr) 
a214 23				inc hl 
a215 23				inc hl    ; position to start of dict word 
a216 3e 00			ld a, 0 
a218 cd 45 91			call strlent 
a21b			 
a21b			 
a21b 23				inc hl    ; to include null??? 
a21c			 
a21c				; write length of dict word 
a21c			 
a21c ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a220 1b				dec de 
a221 eb				ex de, hl 
a222 73				ld (hl), e 
a223 eb				ex de, hl 
a224			 
a224				 
a224			 
a224				; copy  
a224 4d				ld c, l 
a225 06 00			ld b, 0 
a227 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a22b 2a c2 e5			ld hl, (os_tok_ptr) 
a22e 23				inc hl 
a22f 23				inc hl    ; position to start of dict word 
a230				 
a230			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a230				 
a230				; TODO need to convert word to upper case 
a230			 
a230			ucasetok:	 
a230 7e				ld a,(hl) 
a231 cd 31 91			call toUpper 
a234 77				ld (hl),a 
a235 ed a0			ldi 
a237 f2 30 a2		 	jp p, ucasetok 
a23a			 
a23a			 
a23a			 
a23a				; de now points to start of where the word body code should be placed 
a23a ed 53 b9 e2		ld (os_new_work_ptr), de 
a23e				; hl now points to the words to throw at forthexec which needs to be copied 
a23e 22 b7 e2			ld (os_new_src_ptr), hl 
a241			 
a241				; TODO add 'call to forthexec' 
a241			 
a241			if DEBUG_FORTH_UWORD 
a241 c5				push bc 
a242 ed 4b bf e2		ld bc, (os_new_malloc) 
a246						DMARK ":0x" 
a246 f5				push af  
a247 3a 5b a2			ld a, (.dmark)  
a24a 32 6b ee			ld (debug_mark),a  
a24d 3a 5c a2			ld a, (.dmark+1)  
a250 32 6c ee			ld (debug_mark+1),a  
a253 3a 5d a2			ld a, (.dmark+2)  
a256 32 6d ee			ld (debug_mark+2),a  
a259 18 03			jr .pastdmark  
a25b ..			.dmark: db ":0x"  
a25e f1			.pastdmark: pop af  
a25f			endm  
# End of macro DMARK
a25f				CALLMONITOR 
a25f cd 6f ee			call debug_vector  
a262				endm  
# End of macro CALLMONITOR
a262 c1				pop bc 
a263			endif 
a263			 
a263			 
a263				; create word preamble which should be: 
a263			 
a263			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a263			 
a263				;    ld hl, <word code> 
a263				;    jp user_exec 
a263			        ;    <word code bytes> 
a263			 
a263			 
a263			;	inc de     ; TODO ??? or are we already past the word's null 
a263 eb				ex de, hl 
a264			 
a264 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a266			 
a266 23				inc hl 
a267 22 b3 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a26a 23				inc hl 
a26b			 
a26b 23				inc hl 
a26c 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a26e			 
a26e 01 05 cb			ld bc, user_exec 
a271 23				inc hl 
a272 71				ld (hl), c     ; poke address of user_exec 
a273 23				inc hl 
a274 70				ld (hl), b     
a275			 ; 
a275			;	inc hl 
a275			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a275			; 
a275			; 
a275			;	ld bc, macro_forth_rsp_next 
a275			;	inc hl 
a275			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a275			;	inc hl 
a275			;	ld (hl), b     
a275			 ; 
a275			;	inc hl 
a275			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a275			; 
a275			; 
a275			;	inc hl 
a275			;	ld bc, forthexec 
a275			;	ld (hl), c     ; poke address of forthexec 
a275			;	inc hl 
a275			;	ld (hl), b      
a275			; 
a275			;	inc hl 
a275			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a275			; 
a275			;	ld bc, user_dict_next 
a275			;	inc hl 
a275			;	ld (hl), c     ; poke address of forthexec 
a275			;	inc hl 
a275			;	ld (hl), b      
a275			 
a275				; hl is now where we need to copy the word byte data to save this 
a275			 
a275 23				inc hl 
a276 22 b5 e2			ld (os_new_exec), hl 
a279				 
a279				; copy definition 
a279			 
a279 eb				ex de, hl 
a27a			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a27a			;	inc de    ; skip the PC for this parse 
a27a 3a bd e2			ld a, (os_new_parse_len) 
a27d 4f				ld c, a 
a27e 06 00			ld b, 0 
a280 ed b0			ldir		 ; copy defintion 
a282			 
a282			 
a282				; poke the address of where the new word bytes live for forthexec 
a282			 
a282 2a b3 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a285			 
a285 ed 5b b5 e2		ld de, (os_new_exec)      
a289				 
a289 73				ld (hl), e 
a28a 23				inc hl 
a28b 72				ld (hl), d 
a28c			 
a28c					; TODO copy last user dict word next link to this word 
a28c					; TODO update last user dict word to point to this word 
a28c			; 
a28c			; hl f923 de 812a ; bc 811a 
a28c			 
a28c			if DEBUG_FORTH_UWORD 
a28c c5				push bc 
a28d ed 4b bf e2		ld bc, (os_new_malloc) 
a291						DMARK ":0A" 
a291 f5				push af  
a292 3a a6 a2			ld a, (.dmark)  
a295 32 6b ee			ld (debug_mark),a  
a298 3a a7 a2			ld a, (.dmark+1)  
a29b 32 6c ee			ld (debug_mark+1),a  
a29e 3a a8 a2			ld a, (.dmark+2)  
a2a1 32 6d ee			ld (debug_mark+2),a  
a2a4 18 03			jr .pastdmark  
a2a6 ..			.dmark: db ":0A"  
a2a9 f1			.pastdmark: pop af  
a2aa			endm  
# End of macro DMARK
a2aa				CALLMONITOR 
a2aa cd 6f ee			call debug_vector  
a2ad				endm  
# End of macro CALLMONITOR
a2ad c1				pop bc 
a2ae			endif 
a2ae			if DEBUG_FORTH_UWORD 
a2ae c5				push bc 
a2af ed 4b bf e2		ld bc, (os_new_malloc) 
a2b3 03				inc bc 
a2b4 03				inc bc 
a2b5 03				inc bc 
a2b6 03				inc bc 
a2b7 03				inc bc 
a2b8 03				inc bc 
a2b9 03				inc bc 
a2ba 03				inc bc 
a2bb			 
a2bb						DMARK ":0B" 
a2bb f5				push af  
a2bc 3a d0 a2			ld a, (.dmark)  
a2bf 32 6b ee			ld (debug_mark),a  
a2c2 3a d1 a2			ld a, (.dmark+1)  
a2c5 32 6c ee			ld (debug_mark+1),a  
a2c8 3a d2 a2			ld a, (.dmark+2)  
a2cb 32 6d ee			ld (debug_mark+2),a  
a2ce 18 03			jr .pastdmark  
a2d0 ..			.dmark: db ":0B"  
a2d3 f1			.pastdmark: pop af  
a2d4			endm  
# End of macro DMARK
a2d4				CALLMONITOR 
a2d4 cd 6f ee			call debug_vector  
a2d7				endm  
# End of macro CALLMONITOR
a2d7 c1				pop bc 
a2d8			endif 
a2d8			 
a2d8			; update word dict linked list for new word 
a2d8			 
a2d8			 
a2d8 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2db 23			inc hl     ; move to next work linked list ptr 
a2dc			 
a2dc ed 5b bf e2	ld de, (os_new_malloc)		 ; new next word 
a2e0 73			ld (hl), e 
a2e1 23			inc hl 
a2e2 72			ld (hl), d 
a2e3			 
a2e3			if DEBUG_FORTH_UWORD 
a2e3 ed 4b be e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2e7			endif 
a2e7			 
a2e7 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2eb			 
a2eb			 
a2eb			if DEBUG_FORTH_UWORD 
a2eb						DMARK ":0+" 
a2eb f5				push af  
a2ec 3a 00 a3			ld a, (.dmark)  
a2ef 32 6b ee			ld (debug_mark),a  
a2f2 3a 01 a3			ld a, (.dmark+1)  
a2f5 32 6c ee			ld (debug_mark+1),a  
a2f8 3a 02 a3			ld a, (.dmark+2)  
a2fb 32 6d ee			ld (debug_mark+2),a  
a2fe 18 03			jr .pastdmark  
a300 ..			.dmark: db ":0+"  
a303 f1			.pastdmark: pop af  
a304			endm  
# End of macro DMARK
a304				CALLMONITOR 
a304 cd 6f ee			call debug_vector  
a307				endm  
# End of macro CALLMONITOR
a307			endif 
a307			 
a307				STACKFRAMECHK OFF $8efe $989f 
a307				if DEBUG_STACK_IMB 
a307					if OFF 
a307						exx 
a307						ld hl, $989f 
a307						pop de   ; $989f 
a307						call cmp16 
a307						jr nz, .spnosame 
a307						ld hl, $8efe 
a307						pop de   ; $8efe 
a307						call cmp16 
a307						jr z, .spfrsame 
a307						.spnosame: call showsperror 
a307						.spfrsame: nop 
a307						exx 
a307					endif 
a307				endif 
a307			endm 
# End of macro STACKFRAMECHK
a307			 
a307 c9			ret    ; dont process any remaining parser tokens as they form new word 
a308			 
a308			 
a308			 
a308			 
a308			;		NEXT 
a308			.SCOLN: 
a308			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a308 06				db OPCODE_SCOLN 
a309 54 a3			dw .DROP 
a30b 02				db 2 
a30c .. 00			db ";",0           
a30e			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a30e					if DEBUG_FORTH_WORDS_KEY 
a30e						DMARK "SCN" 
a30e f5				push af  
a30f 3a 23 a3			ld a, (.dmark)  
a312 32 6b ee			ld (debug_mark),a  
a315 3a 24 a3			ld a, (.dmark+1)  
a318 32 6c ee			ld (debug_mark+1),a  
a31b 3a 25 a3			ld a, (.dmark+2)  
a31e 32 6d ee			ld (debug_mark+2),a  
a321 18 03			jr .pastdmark  
a323 ..			.dmark: db "SCN"  
a326 f1			.pastdmark: pop af  
a327			endm  
# End of macro DMARK
a327						CALLMONITOR 
a327 cd 6f ee			call debug_vector  
a32a				endm  
# End of macro CALLMONITOR
a32a					endif 
a32a					FORTH_RSP_TOS 
a32a cd 09 9b			call macro_forth_rsp_tos 
a32d				endm 
# End of macro FORTH_RSP_TOS
a32d e5					push hl 
a32e					FORTH_RSP_POP 
a32e cd 13 9b			call macro_forth_rsp_pop 
a331				endm 
# End of macro FORTH_RSP_POP
a331 e1					pop hl 
a332			;		ex de,hl 
a332 22 c2 e5				ld (os_tok_ptr),hl 
a335			 
a335			if DEBUG_FORTH_UWORD 
a335						DMARK "SCL" 
a335 f5				push af  
a336 3a 4a a3			ld a, (.dmark)  
a339 32 6b ee			ld (debug_mark),a  
a33c 3a 4b a3			ld a, (.dmark+1)  
a33f 32 6c ee			ld (debug_mark+1),a  
a342 3a 4c a3			ld a, (.dmark+2)  
a345 32 6d ee			ld (debug_mark+2),a  
a348 18 03			jr .pastdmark  
a34a ..			.dmark: db "SCL"  
a34d f1			.pastdmark: pop af  
a34e			endm  
# End of macro DMARK
a34e				CALLMONITOR 
a34e cd 6f ee			call debug_vector  
a351				endm  
# End of macro CALLMONITOR
a351			endif 
a351					NEXTW 
a351 c3 f8 9e			jp macro_next 
a354				endm 
# End of macro NEXTW
a354			 
a354			.DROP: 
a354				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a354 1b				db WORD_SYS_CORE+OPCODE_DROP             
a355 7f a3			dw .DUP2            
a357 05				db 4 + 1 
a358 .. 00			db "DROP",0              
a35d				endm 
# End of macro CWHEAD
a35d			; | DROP ( w -- )   drop the TOS item   | DONE 
a35d					if DEBUG_FORTH_WORDS_KEY 
a35d						DMARK "DRP" 
a35d f5				push af  
a35e 3a 72 a3			ld a, (.dmark)  
a361 32 6b ee			ld (debug_mark),a  
a364 3a 73 a3			ld a, (.dmark+1)  
a367 32 6c ee			ld (debug_mark+1),a  
a36a 3a 74 a3			ld a, (.dmark+2)  
a36d 32 6d ee			ld (debug_mark+2),a  
a370 18 03			jr .pastdmark  
a372 ..			.dmark: db "DRP"  
a375 f1			.pastdmark: pop af  
a376			endm  
# End of macro DMARK
a376						CALLMONITOR 
a376 cd 6f ee			call debug_vector  
a379				endm  
# End of macro CALLMONITOR
a379					endif 
a379					FORTH_DSP_POP 
a379 cd fa 9d			call macro_forth_dsp_pop 
a37c				endm 
# End of macro FORTH_DSP_POP
a37c					NEXTW 
a37c c3 f8 9e			jp macro_next 
a37f				endm 
# End of macro NEXTW
a37f			.DUP2: 
a37f				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a37f 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a380 c4 a3			dw .DROP2            
a382 05				db 4 + 1 
a383 .. 00			db "2DUP",0              
a388				endm 
# End of macro CWHEAD
a388			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a388					if DEBUG_FORTH_WORDS_KEY 
a388						DMARK "2DU" 
a388 f5				push af  
a389 3a 9d a3			ld a, (.dmark)  
a38c 32 6b ee			ld (debug_mark),a  
a38f 3a 9e a3			ld a, (.dmark+1)  
a392 32 6c ee			ld (debug_mark+1),a  
a395 3a 9f a3			ld a, (.dmark+2)  
a398 32 6d ee			ld (debug_mark+2),a  
a39b 18 03			jr .pastdmark  
a39d ..			.dmark: db "2DU"  
a3a0 f1			.pastdmark: pop af  
a3a1			endm  
# End of macro DMARK
a3a1						CALLMONITOR 
a3a1 cd 6f ee			call debug_vector  
a3a4				endm  
# End of macro CALLMONITOR
a3a4					endif 
a3a4					FORTH_DSP_VALUEHL 
a3a4 cd 42 9d			call macro_dsp_valuehl 
a3a7				endm 
# End of macro FORTH_DSP_VALUEHL
a3a7 e5					push hl      ; 2 
a3a8			 
a3a8					FORTH_DSP_POP 
a3a8 cd fa 9d			call macro_forth_dsp_pop 
a3ab				endm 
# End of macro FORTH_DSP_POP
a3ab					 
a3ab					FORTH_DSP_VALUEHL 
a3ab cd 42 9d			call macro_dsp_valuehl 
a3ae				endm 
# End of macro FORTH_DSP_VALUEHL
a3ae			;		push hl      ; 1 
a3ae			 
a3ae					FORTH_DSP_POP 
a3ae cd fa 9d			call macro_forth_dsp_pop 
a3b1				endm 
# End of macro FORTH_DSP_POP
a3b1			 
a3b1			;		pop hl       ; 1 
a3b1 d1					pop de       ; 2 
a3b2			 
a3b2 cd 4b 9b				call forth_push_numhl 
a3b5 eb					ex de, hl 
a3b6 cd 4b 9b				call forth_push_numhl 
a3b9			 
a3b9					 
a3b9 eb					ex de, hl 
a3ba			 
a3ba cd 4b 9b				call forth_push_numhl 
a3bd eb					ex de, hl 
a3be cd 4b 9b				call forth_push_numhl 
a3c1			 
a3c1			 
a3c1					NEXTW 
a3c1 c3 f8 9e			jp macro_next 
a3c4				endm 
# End of macro NEXTW
a3c4			.DROP2: 
a3c4				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3c4 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3c5 f3 a3			dw .SWAP2            
a3c7 06				db 5 + 1 
a3c8 .. 00			db "2DROP",0              
a3ce				endm 
# End of macro CWHEAD
a3ce			; | 2DROP ( w w -- )    Double drop | DONE 
a3ce					if DEBUG_FORTH_WORDS_KEY 
a3ce						DMARK "2DR" 
a3ce f5				push af  
a3cf 3a e3 a3			ld a, (.dmark)  
a3d2 32 6b ee			ld (debug_mark),a  
a3d5 3a e4 a3			ld a, (.dmark+1)  
a3d8 32 6c ee			ld (debug_mark+1),a  
a3db 3a e5 a3			ld a, (.dmark+2)  
a3de 32 6d ee			ld (debug_mark+2),a  
a3e1 18 03			jr .pastdmark  
a3e3 ..			.dmark: db "2DR"  
a3e6 f1			.pastdmark: pop af  
a3e7			endm  
# End of macro DMARK
a3e7						CALLMONITOR 
a3e7 cd 6f ee			call debug_vector  
a3ea				endm  
# End of macro CALLMONITOR
a3ea					endif 
a3ea					FORTH_DSP_POP 
a3ea cd fa 9d			call macro_forth_dsp_pop 
a3ed				endm 
# End of macro FORTH_DSP_POP
a3ed					FORTH_DSP_POP 
a3ed cd fa 9d			call macro_forth_dsp_pop 
a3f0				endm 
# End of macro FORTH_DSP_POP
a3f0					NEXTW 
a3f0 c3 f8 9e			jp macro_next 
a3f3				endm 
# End of macro NEXTW
a3f3			.SWAP2: 
a3f3				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3f3 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3f4 1c a4			dw .AT            
a3f6 06				db 5 + 1 
a3f7 .. 00			db "2SWAP",0              
a3fd				endm 
# End of macro CWHEAD
a3fd			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3fd					if DEBUG_FORTH_WORDS_KEY 
a3fd						DMARK "2SW" 
a3fd f5				push af  
a3fe 3a 12 a4			ld a, (.dmark)  
a401 32 6b ee			ld (debug_mark),a  
a404 3a 13 a4			ld a, (.dmark+1)  
a407 32 6c ee			ld (debug_mark+1),a  
a40a 3a 14 a4			ld a, (.dmark+2)  
a40d 32 6d ee			ld (debug_mark+2),a  
a410 18 03			jr .pastdmark  
a412 ..			.dmark: db "2SW"  
a415 f1			.pastdmark: pop af  
a416			endm  
# End of macro DMARK
a416						CALLMONITOR 
a416 cd 6f ee			call debug_vector  
a419				endm  
# End of macro CALLMONITOR
a419					endif 
a419					NEXTW 
a419 c3 f8 9e			jp macro_next 
a41c				endm 
# End of macro NEXTW
a41c			.AT: 
a41c				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a41c 1f				db WORD_SYS_CORE+OPCODE_AT             
a41d 4e a4			dw .CAT            
a41f 02				db 1 + 1 
a420 .. 00			db "@",0              
a422				endm 
# End of macro CWHEAD
a422			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a422			 
a422					if DEBUG_FORTH_WORDS_KEY 
a422						DMARK "AT." 
a422 f5				push af  
a423 3a 37 a4			ld a, (.dmark)  
a426 32 6b ee			ld (debug_mark),a  
a429 3a 38 a4			ld a, (.dmark+1)  
a42c 32 6c ee			ld (debug_mark+1),a  
a42f 3a 39 a4			ld a, (.dmark+2)  
a432 32 6d ee			ld (debug_mark+2),a  
a435 18 03			jr .pastdmark  
a437 ..			.dmark: db "AT."  
a43a f1			.pastdmark: pop af  
a43b			endm  
# End of macro DMARK
a43b						CALLMONITOR 
a43b cd 6f ee			call debug_vector  
a43e				endm  
# End of macro CALLMONITOR
a43e					endif 
a43e			.getbyteat:	 
a43e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a43e cd 42 9d			call macro_dsp_valuehl 
a441				endm 
# End of macro FORTH_DSP_VALUEHL
a441					 
a441			;		push hl 
a441				 
a441					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a441 cd fa 9d			call macro_forth_dsp_pop 
a444				endm 
# End of macro FORTH_DSP_POP
a444			 
a444			;		pop hl 
a444			 
a444 7e					ld a, (hl) 
a445			 
a445 6f					ld l, a 
a446 26 00				ld h, 0 
a448 cd 4b 9b				call forth_push_numhl 
a44b			 
a44b					NEXTW 
a44b c3 f8 9e			jp macro_next 
a44e				endm 
# End of macro NEXTW
a44e			.CAT: 
a44e				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a44e 20				db WORD_SYS_CORE+OPCODE_CAT             
a44f 77 a4			dw .BANG            
a451 03				db 2 + 1 
a452 .. 00			db "C@",0              
a455				endm 
# End of macro CWHEAD
a455			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a455					if DEBUG_FORTH_WORDS_KEY 
a455						DMARK "CAA" 
a455 f5				push af  
a456 3a 6a a4			ld a, (.dmark)  
a459 32 6b ee			ld (debug_mark),a  
a45c 3a 6b a4			ld a, (.dmark+1)  
a45f 32 6c ee			ld (debug_mark+1),a  
a462 3a 6c a4			ld a, (.dmark+2)  
a465 32 6d ee			ld (debug_mark+2),a  
a468 18 03			jr .pastdmark  
a46a ..			.dmark: db "CAA"  
a46d f1			.pastdmark: pop af  
a46e			endm  
# End of macro DMARK
a46e						CALLMONITOR 
a46e cd 6f ee			call debug_vector  
a471				endm  
# End of macro CALLMONITOR
a471					endif 
a471 c3 3e a4				jp .getbyteat 
a474					NEXTW 
a474 c3 f8 9e			jp macro_next 
a477				endm 
# End of macro NEXTW
a477			.BANG: 
a477				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a477 21				db WORD_SYS_CORE+OPCODE_BANG             
a478 ad a4			dw .CBANG            
a47a 02				db 1 + 1 
a47b .. 00			db "!",0              
a47d				endm 
# End of macro CWHEAD
a47d			; | ! ( x w -- ) Store x at address w      | DONE 
a47d					if DEBUG_FORTH_WORDS_KEY 
a47d						DMARK "BNG" 
a47d f5				push af  
a47e 3a 92 a4			ld a, (.dmark)  
a481 32 6b ee			ld (debug_mark),a  
a484 3a 93 a4			ld a, (.dmark+1)  
a487 32 6c ee			ld (debug_mark+1),a  
a48a 3a 94 a4			ld a, (.dmark+2)  
a48d 32 6d ee			ld (debug_mark+2),a  
a490 18 03			jr .pastdmark  
a492 ..			.dmark: db "BNG"  
a495 f1			.pastdmark: pop af  
a496			endm  
# End of macro DMARK
a496						CALLMONITOR 
a496 cd 6f ee			call debug_vector  
a499				endm  
# End of macro CALLMONITOR
a499					endif 
a499			 
a499			.storebyteat:		 
a499					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a499 cd 42 9d			call macro_dsp_valuehl 
a49c				endm 
# End of macro FORTH_DSP_VALUEHL
a49c					 
a49c e5					push hl 
a49d				 
a49d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a49d cd fa 9d			call macro_forth_dsp_pop 
a4a0				endm 
# End of macro FORTH_DSP_POP
a4a0			 
a4a0					; get byte to poke 
a4a0			 
a4a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4a0 cd 42 9d			call macro_dsp_valuehl 
a4a3				endm 
# End of macro FORTH_DSP_VALUEHL
a4a3 e5					push hl 
a4a4			 
a4a4			 
a4a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4a4 cd fa 9d			call macro_forth_dsp_pop 
a4a7				endm 
# End of macro FORTH_DSP_POP
a4a7			 
a4a7			 
a4a7 d1					pop de 
a4a8 e1					pop hl 
a4a9			 
a4a9 73					ld (hl),e 
a4aa			 
a4aa			 
a4aa					NEXTW 
a4aa c3 f8 9e			jp macro_next 
a4ad				endm 
# End of macro NEXTW
a4ad			.CBANG: 
a4ad				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a4ad 22				db WORD_SYS_CORE+OPCODE_CBANG             
a4ae d6 a4			dw .SCALL            
a4b0 03				db 2 + 1 
a4b1 .. 00			db "C!",0              
a4b4				endm 
# End of macro CWHEAD
a4b4			; | C!  ( x w -- ) Store x at address w  | DONE 
a4b4					if DEBUG_FORTH_WORDS_KEY 
a4b4						DMARK "CBA" 
a4b4 f5				push af  
a4b5 3a c9 a4			ld a, (.dmark)  
a4b8 32 6b ee			ld (debug_mark),a  
a4bb 3a ca a4			ld a, (.dmark+1)  
a4be 32 6c ee			ld (debug_mark+1),a  
a4c1 3a cb a4			ld a, (.dmark+2)  
a4c4 32 6d ee			ld (debug_mark+2),a  
a4c7 18 03			jr .pastdmark  
a4c9 ..			.dmark: db "CBA"  
a4cc f1			.pastdmark: pop af  
a4cd			endm  
# End of macro DMARK
a4cd						CALLMONITOR 
a4cd cd 6f ee			call debug_vector  
a4d0				endm  
# End of macro CALLMONITOR
a4d0					endif 
a4d0 c3 99 a4				jp .storebyteat 
a4d3					NEXTW 
a4d3 c3 f8 9e			jp macro_next 
a4d6				endm 
# End of macro NEXTW
a4d6			.SCALL: 
a4d6				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a4d6 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4d7 0a a5			dw .DEPTH            
a4d9 05				db 4 + 1 
a4da .. 00			db "CALL",0              
a4df				endm 
# End of macro CWHEAD
a4df			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4df					if DEBUG_FORTH_WORDS_KEY 
a4df						DMARK "CLL" 
a4df f5				push af  
a4e0 3a f4 a4			ld a, (.dmark)  
a4e3 32 6b ee			ld (debug_mark),a  
a4e6 3a f5 a4			ld a, (.dmark+1)  
a4e9 32 6c ee			ld (debug_mark+1),a  
a4ec 3a f6 a4			ld a, (.dmark+2)  
a4ef 32 6d ee			ld (debug_mark+2),a  
a4f2 18 03			jr .pastdmark  
a4f4 ..			.dmark: db "CLL"  
a4f7 f1			.pastdmark: pop af  
a4f8			endm  
# End of macro DMARK
a4f8						CALLMONITOR 
a4f8 cd 6f ee			call debug_vector  
a4fb				endm  
# End of macro CALLMONITOR
a4fb					endif 
a4fb			 
a4fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4fb cd 42 9d			call macro_dsp_valuehl 
a4fe				endm 
# End of macro FORTH_DSP_VALUEHL
a4fe			 
a4fe			;		push hl 
a4fe			 
a4fe					; destroy value TOS 
a4fe			 
a4fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4fe cd fa 9d			call macro_forth_dsp_pop 
a501				endm 
# End of macro FORTH_DSP_POP
a501			 
a501						 
a501			;		pop hl 
a501			 
a501					; how to do a call with hl???? save SP? 
a501 cd 9c 9e				call forth_call_hl 
a504			 
a504			 
a504					; TODO push value back onto stack for another op etc 
a504			 
a504 cd 4b 9b				call forth_push_numhl 
a507					NEXTW 
a507 c3 f8 9e			jp macro_next 
a50a				endm 
# End of macro NEXTW
a50a			.DEPTH: 
a50a				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a50a 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a50b 47 a5			dw .OVER            
a50d 06				db 5 + 1 
a50e .. 00			db "DEPTH",0              
a514				endm 
# End of macro CWHEAD
a514			; | DEPTH ( -- u ) Push count of stack | DONE 
a514					; take current TOS and remove from base value div by two to get count 
a514					if DEBUG_FORTH_WORDS_KEY 
a514						DMARK "DEP" 
a514 f5				push af  
a515 3a 29 a5			ld a, (.dmark)  
a518 32 6b ee			ld (debug_mark),a  
a51b 3a 2a a5			ld a, (.dmark+1)  
a51e 32 6c ee			ld (debug_mark+1),a  
a521 3a 2b a5			ld a, (.dmark+2)  
a524 32 6d ee			ld (debug_mark+2),a  
a527 18 03			jr .pastdmark  
a529 ..			.dmark: db "DEP"  
a52c f1			.pastdmark: pop af  
a52d			endm  
# End of macro DMARK
a52d						CALLMONITOR 
a52d cd 6f ee			call debug_vector  
a530				endm  
# End of macro CALLMONITOR
a530					endif 
a530			 
a530			 
a530 2a ee e9			ld hl, (cli_data_sp) 
a533 11 28 e8			ld de, cli_data_stack 
a536 ed 52			sbc hl,de 
a538				 
a538				; div by size of stack item 
a538			 
a538 5d				ld e,l 
a539 0e 03			ld c, 3 
a53b cd 6c 8c			call Div8 
a53e			 
a53e 6f				ld l,a 
a53f 26 00			ld h,0 
a541			 
a541				;srl h 
a541				;rr l 
a541			 
a541 cd 4b 9b				call forth_push_numhl 
a544					NEXTW 
a544 c3 f8 9e			jp macro_next 
a547				endm 
# End of macro NEXTW
a547			.OVER: 
a547				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a547 42				db WORD_SYS_CORE+46             
a548 8e a5			dw .PAUSE            
a54a 05				db 4 + 1 
a54b .. 00			db "OVER",0              
a550				endm 
# End of macro CWHEAD
a550			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a550					if DEBUG_FORTH_WORDS_KEY 
a550						DMARK "OVR" 
a550 f5				push af  
a551 3a 65 a5			ld a, (.dmark)  
a554 32 6b ee			ld (debug_mark),a  
a557 3a 66 a5			ld a, (.dmark+1)  
a55a 32 6c ee			ld (debug_mark+1),a  
a55d 3a 67 a5			ld a, (.dmark+2)  
a560 32 6d ee			ld (debug_mark+2),a  
a563 18 03			jr .pastdmark  
a565 ..			.dmark: db "OVR"  
a568 f1			.pastdmark: pop af  
a569			endm  
# End of macro DMARK
a569						CALLMONITOR 
a569 cd 6f ee			call debug_vector  
a56c				endm  
# End of macro CALLMONITOR
a56c					endif 
a56c			 
a56c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a56c cd 42 9d			call macro_dsp_valuehl 
a56f				endm 
# End of macro FORTH_DSP_VALUEHL
a56f e5					push hl    ; n2 
a570					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a570 cd fa 9d			call macro_forth_dsp_pop 
a573				endm 
# End of macro FORTH_DSP_POP
a573			 
a573					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a573 cd 42 9d			call macro_dsp_valuehl 
a576				endm 
# End of macro FORTH_DSP_VALUEHL
a576 e5					push hl    ; n1 
a577					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a577 cd fa 9d			call macro_forth_dsp_pop 
a57a				endm 
# End of macro FORTH_DSP_POP
a57a			 
a57a d1					pop de     ; n1 
a57b e1					pop hl     ; n2 
a57c			 
a57c d5					push de 
a57d e5					push hl 
a57e d5					push de 
a57f			 
a57f					; push back  
a57f			 
a57f e1					pop hl 
a580 cd 4b 9b				call forth_push_numhl 
a583 e1					pop hl 
a584 cd 4b 9b				call forth_push_numhl 
a587 e1					pop hl 
a588 cd 4b 9b				call forth_push_numhl 
a58b					NEXTW 
a58b c3 f8 9e			jp macro_next 
a58e				endm 
# End of macro NEXTW
a58e			 
a58e			.PAUSE: 
a58e				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a58e 43				db WORD_SYS_CORE+47             
a58f c3 a5			dw .PAUSES            
a591 08				db 7 + 1 
a592 .. 00			db "PAUSEMS",0              
a59a				endm 
# End of macro CWHEAD
a59a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a59a					if DEBUG_FORTH_WORDS_KEY 
a59a						DMARK "PMS" 
a59a f5				push af  
a59b 3a af a5			ld a, (.dmark)  
a59e 32 6b ee			ld (debug_mark),a  
a5a1 3a b0 a5			ld a, (.dmark+1)  
a5a4 32 6c ee			ld (debug_mark+1),a  
a5a7 3a b1 a5			ld a, (.dmark+2)  
a5aa 32 6d ee			ld (debug_mark+2),a  
a5ad 18 03			jr .pastdmark  
a5af ..			.dmark: db "PMS"  
a5b2 f1			.pastdmark: pop af  
a5b3			endm  
# End of macro DMARK
a5b3						CALLMONITOR 
a5b3 cd 6f ee			call debug_vector  
a5b6				endm  
# End of macro CALLMONITOR
a5b6					endif 
a5b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b6 cd 42 9d			call macro_dsp_valuehl 
a5b9				endm 
# End of macro FORTH_DSP_VALUEHL
a5b9			;		push hl    ; n2 
a5b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5b9 cd fa 9d			call macro_forth_dsp_pop 
a5bc				endm 
# End of macro FORTH_DSP_POP
a5bc			;		pop hl 
a5bc			 
a5bc 7d					ld a, l 
a5bd cd d7 89				call aDelayInMS 
a5c0				       NEXTW 
a5c0 c3 f8 9e			jp macro_next 
a5c3				endm 
# End of macro NEXTW
a5c3			.PAUSES:  
a5c3				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a5c3 44				db WORD_SYS_CORE+48             
a5c4 32 a6			dw .ROT            
a5c6 06				db 5 + 1 
a5c7 .. 00			db "PAUSE",0              
a5cd				endm 
# End of macro CWHEAD
a5cd			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a5cd					if DEBUG_FORTH_WORDS_KEY 
a5cd						DMARK "PAU" 
a5cd f5				push af  
a5ce 3a e2 a5			ld a, (.dmark)  
a5d1 32 6b ee			ld (debug_mark),a  
a5d4 3a e3 a5			ld a, (.dmark+1)  
a5d7 32 6c ee			ld (debug_mark+1),a  
a5da 3a e4 a5			ld a, (.dmark+2)  
a5dd 32 6d ee			ld (debug_mark+2),a  
a5e0 18 03			jr .pastdmark  
a5e2 ..			.dmark: db "PAU"  
a5e5 f1			.pastdmark: pop af  
a5e6			endm  
# End of macro DMARK
a5e6						CALLMONITOR 
a5e6 cd 6f ee			call debug_vector  
a5e9				endm  
# End of macro CALLMONITOR
a5e9					endif 
a5e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5e9 cd 42 9d			call macro_dsp_valuehl 
a5ec				endm 
# End of macro FORTH_DSP_VALUEHL
a5ec			;		push hl    ; n2 
a5ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5ec cd fa 9d			call macro_forth_dsp_pop 
a5ef				endm 
# End of macro FORTH_DSP_POP
a5ef			;		pop hl 
a5ef 45					ld b, l 
a5f0					if DEBUG_FORTH_WORDS 
a5f0						DMARK "PAU" 
a5f0 f5				push af  
a5f1 3a 05 a6			ld a, (.dmark)  
a5f4 32 6b ee			ld (debug_mark),a  
a5f7 3a 06 a6			ld a, (.dmark+1)  
a5fa 32 6c ee			ld (debug_mark+1),a  
a5fd 3a 07 a6			ld a, (.dmark+2)  
a600 32 6d ee			ld (debug_mark+2),a  
a603 18 03			jr .pastdmark  
a605 ..			.dmark: db "PAU"  
a608 f1			.pastdmark: pop af  
a609			endm  
# End of macro DMARK
a609						CALLMONITOR 
a609 cd 6f ee			call debug_vector  
a60c				endm  
# End of macro CALLMONITOR
a60c					endif 
a60c c5			.pauses1:	push bc 
a60d cd f2 89				call delay1s 
a610 c1					pop bc 
a611					if DEBUG_FORTH_WORDS 
a611						DMARK "PA1" 
a611 f5				push af  
a612 3a 26 a6			ld a, (.dmark)  
a615 32 6b ee			ld (debug_mark),a  
a618 3a 27 a6			ld a, (.dmark+1)  
a61b 32 6c ee			ld (debug_mark+1),a  
a61e 3a 28 a6			ld a, (.dmark+2)  
a621 32 6d ee			ld (debug_mark+2),a  
a624 18 03			jr .pastdmark  
a626 ..			.dmark: db "PA1"  
a629 f1			.pastdmark: pop af  
a62a			endm  
# End of macro DMARK
a62a						CALLMONITOR 
a62a cd 6f ee			call debug_vector  
a62d				endm  
# End of macro CALLMONITOR
a62d					endif 
a62d 10 dd				djnz .pauses1 
a62f			 
a62f				       NEXTW 
a62f c3 f8 9e			jp macro_next 
a632				endm 
# End of macro NEXTW
a632			.ROT: 
a632				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a632 45				db WORD_SYS_CORE+49             
a633 80 a6			dw .UWORDS            
a635 04				db 3 + 1 
a636 .. 00			db "ROT",0              
a63a				endm 
# End of macro CWHEAD
a63a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a63a					if DEBUG_FORTH_WORDS_KEY 
a63a						DMARK "ROT" 
a63a f5				push af  
a63b 3a 4f a6			ld a, (.dmark)  
a63e 32 6b ee			ld (debug_mark),a  
a641 3a 50 a6			ld a, (.dmark+1)  
a644 32 6c ee			ld (debug_mark+1),a  
a647 3a 51 a6			ld a, (.dmark+2)  
a64a 32 6d ee			ld (debug_mark+2),a  
a64d 18 03			jr .pastdmark  
a64f ..			.dmark: db "ROT"  
a652 f1			.pastdmark: pop af  
a653			endm  
# End of macro DMARK
a653						CALLMONITOR 
a653 cd 6f ee			call debug_vector  
a656				endm  
# End of macro CALLMONITOR
a656					endif 
a656			 
a656					FORTH_DSP_VALUEHL 
a656 cd 42 9d			call macro_dsp_valuehl 
a659				endm 
# End of macro FORTH_DSP_VALUEHL
a659 e5					push hl    ; u3  
a65a			 
a65a					FORTH_DSP_POP 
a65a cd fa 9d			call macro_forth_dsp_pop 
a65d				endm 
# End of macro FORTH_DSP_POP
a65d			   
a65d					FORTH_DSP_VALUEHL 
a65d cd 42 9d			call macro_dsp_valuehl 
a660				endm 
# End of macro FORTH_DSP_VALUEHL
a660 e5					push hl     ; u2 
a661			 
a661					FORTH_DSP_POP 
a661 cd fa 9d			call macro_forth_dsp_pop 
a664				endm 
# End of macro FORTH_DSP_POP
a664			 
a664					FORTH_DSP_VALUEHL 
a664 cd 42 9d			call macro_dsp_valuehl 
a667				endm 
# End of macro FORTH_DSP_VALUEHL
a667 e5					push hl     ; u1 
a668			 
a668					FORTH_DSP_POP 
a668 cd fa 9d			call macro_forth_dsp_pop 
a66b				endm 
# End of macro FORTH_DSP_POP
a66b			 
a66b c1					pop bc      ; u1 
a66c e1					pop hl      ; u2 
a66d d1					pop de      ; u3 
a66e			 
a66e			 
a66e c5					push bc 
a66f d5					push de 
a670 e5					push hl 
a671			 
a671			 
a671 e1					pop hl 
a672 cd 4b 9b				call forth_push_numhl 
a675			 
a675 e1					pop hl 
a676 cd 4b 9b				call forth_push_numhl 
a679			 
a679 e1					pop hl 
a67a cd 4b 9b				call forth_push_numhl 
a67d					 
a67d			 
a67d			 
a67d			 
a67d			 
a67d			 
a67d				       NEXTW 
a67d c3 f8 9e			jp macro_next 
a680				endm 
# End of macro NEXTW
a680			 
a680			.UWORDS: 
a680				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a680 50				db WORD_SYS_CORE+60             
a681 42 a7			dw .BP            
a683 07				db 6 + 1 
a684 .. 00			db "UWORDS",0              
a68b				endm 
# End of macro CWHEAD
a68b			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a68b			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a68b			; | | Following the count are the individual words. 
a68b			; | | 
a68b			; | | e.g. UWORDS 
a68b			; | | BOX DIRLIST 2 
a68b			; | |  
a68b			; | | Can be used to save the words to storage via: 
a68b			; | | UWORDS $01 DO $01 APPEND LOOP 
a68b				if DEBUG_FORTH_WORDS_KEY 
a68b					DMARK "UWR" 
a68b f5				push af  
a68c 3a a0 a6			ld a, (.dmark)  
a68f 32 6b ee			ld (debug_mark),a  
a692 3a a1 a6			ld a, (.dmark+1)  
a695 32 6c ee			ld (debug_mark+1),a  
a698 3a a2 a6			ld a, (.dmark+2)  
a69b 32 6d ee			ld (debug_mark+2),a  
a69e 18 03			jr .pastdmark  
a6a0 ..			.dmark: db "UWR"  
a6a3 f1			.pastdmark: pop af  
a6a4			endm  
# End of macro DMARK
a6a4					CALLMONITOR 
a6a4 cd 6f ee			call debug_vector  
a6a7				endm  
# End of macro CALLMONITOR
a6a7				endif 
a6a7 21 dd e3				ld hl, baseram 
a6aa					;ld hl, baseusermem 
a6aa 01 00 00				ld bc, 0    ; start a counter 
a6ad			 
a6ad				; skip dict stub 
a6ad			 
a6ad cd 49 a0				call forth_tok_next 
a6b0			 
a6b0			 
a6b0			; while we have words to look for 
a6b0			 
a6b0 7e			.douscan:	ld a, (hl)      
a6b1				if DEBUG_FORTH_WORDS 
a6b1					DMARK "UWs" 
a6b1 f5				push af  
a6b2 3a c6 a6			ld a, (.dmark)  
a6b5 32 6b ee			ld (debug_mark),a  
a6b8 3a c7 a6			ld a, (.dmark+1)  
a6bb 32 6c ee			ld (debug_mark+1),a  
a6be 3a c8 a6			ld a, (.dmark+2)  
a6c1 32 6d ee			ld (debug_mark+2),a  
a6c4 18 03			jr .pastdmark  
a6c6 ..			.dmark: db "UWs"  
a6c9 f1			.pastdmark: pop af  
a6ca			endm  
# End of macro DMARK
a6ca					CALLMONITOR 
a6ca cd 6f ee			call debug_vector  
a6cd				endm  
# End of macro CALLMONITOR
a6cd				endif 
a6cd fe 00				cp WORD_SYS_END 
a6cf 28 4d				jr z, .udone 
a6d1 fe 01				cp WORD_SYS_UWORD 
a6d3 20 44				jr nz, .nuword 
a6d5			 
a6d5				if DEBUG_FORTH_WORDS 
a6d5					DMARK "UWu" 
a6d5 f5				push af  
a6d6 3a ea a6			ld a, (.dmark)  
a6d9 32 6b ee			ld (debug_mark),a  
a6dc 3a eb a6			ld a, (.dmark+1)  
a6df 32 6c ee			ld (debug_mark+1),a  
a6e2 3a ec a6			ld a, (.dmark+2)  
a6e5 32 6d ee			ld (debug_mark+2),a  
a6e8 18 03			jr .pastdmark  
a6ea ..			.dmark: db "UWu"  
a6ed f1			.pastdmark: pop af  
a6ee			endm  
# End of macro DMARK
a6ee					CALLMONITOR 
a6ee cd 6f ee			call debug_vector  
a6f1				endm  
# End of macro CALLMONITOR
a6f1				endif 
a6f1					; we have a uword so push its name to the stack 
a6f1			 
a6f1 e5				   	push hl  ; save so we can move to next dict block 
a6f2			 
a6f2					; skip opcode 
a6f2 23					inc hl  
a6f3					; skip next ptr 
a6f3 23					inc hl  
a6f4 23					inc hl 
a6f5					; skip len 
a6f5 23					inc hl 
a6f6				if DEBUG_FORTH_WORDS 
a6f6					DMARK "UWt" 
a6f6 f5				push af  
a6f7 3a 0b a7			ld a, (.dmark)  
a6fa 32 6b ee			ld (debug_mark),a  
a6fd 3a 0c a7			ld a, (.dmark+1)  
a700 32 6c ee			ld (debug_mark+1),a  
a703 3a 0d a7			ld a, (.dmark+2)  
a706 32 6d ee			ld (debug_mark+2),a  
a709 18 03			jr .pastdmark  
a70b ..			.dmark: db "UWt"  
a70e f1			.pastdmark: pop af  
a70f			endm  
# End of macro DMARK
a70f					CALLMONITOR 
a70f cd 6f ee			call debug_vector  
a712				endm  
# End of macro CALLMONITOR
a712				endif 
a712 03					inc bc 
a713			 
a713 c5					push bc 
a714 cd b9 9b				call forth_push_str 
a717 c1					pop bc 
a718			 
a718 e1					pop hl 	 
a719			 
a719 cd 49 a0		.nuword:	call forth_tok_next 
a71c 18 92				jr .douscan  
a71e			 
a71e			.udone:		 ; push count of uwords found 
a71e c5					push bc 
a71f e1					pop hl 
a720			 
a720				if DEBUG_FORTH_WORDS 
a720					DMARK "UWc" 
a720 f5				push af  
a721 3a 35 a7			ld a, (.dmark)  
a724 32 6b ee			ld (debug_mark),a  
a727 3a 36 a7			ld a, (.dmark+1)  
a72a 32 6c ee			ld (debug_mark+1),a  
a72d 3a 37 a7			ld a, (.dmark+2)  
a730 32 6d ee			ld (debug_mark+2),a  
a733 18 03			jr .pastdmark  
a735 ..			.dmark: db "UWc"  
a738 f1			.pastdmark: pop af  
a739			endm  
# End of macro DMARK
a739					CALLMONITOR 
a739 cd 6f ee			call debug_vector  
a73c				endm  
# End of macro CALLMONITOR
a73c				endif 
a73c cd 4b 9b				call forth_push_numhl 
a73f			 
a73f			 
a73f				       NEXTW 
a73f c3 f8 9e			jp macro_next 
a742				endm 
# End of macro NEXTW
a742			 
a742			.BP: 
a742				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a742 54				db WORD_SYS_CORE+64             
a743 7c a7			dw .MONITOR            
a745 03				db 2 + 1 
a746 .. 00			db "BP",0              
a749				endm 
# End of macro CWHEAD
a749			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a749			; | | $00 Will enable the break points within specific code paths 
a749			; | | $01 Will disable break points 
a749			; | |  
a749			; | | By default break points are off. Either the above can be used to enable them 
a749			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a749			; | | and on release of the pressed key a message will be disaplayed to notify 
a749			; | | that break points are enabled. Pressing any key will then continue boot process. 
a749					; get byte count 
a749					if DEBUG_FORTH_WORDS_KEY 
a749						DMARK "BP." 
a749 f5				push af  
a74a 3a 5e a7			ld a, (.dmark)  
a74d 32 6b ee			ld (debug_mark),a  
a750 3a 5f a7			ld a, (.dmark+1)  
a753 32 6c ee			ld (debug_mark+1),a  
a756 3a 60 a7			ld a, (.dmark+2)  
a759 32 6d ee			ld (debug_mark+2),a  
a75c 18 03			jr .pastdmark  
a75e ..			.dmark: db "BP."  
a761 f1			.pastdmark: pop af  
a762			endm  
# End of macro DMARK
a762						CALLMONITOR 
a762 cd 6f ee			call debug_vector  
a765				endm  
# End of macro CALLMONITOR
a765					endif 
a765			 
a765					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a765 cd 42 9d			call macro_dsp_valuehl 
a768				endm 
# End of macro FORTH_DSP_VALUEHL
a768			 
a768			;		push hl 
a768			 
a768					; destroy value TOS 
a768			 
a768					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a768 cd fa 9d			call macro_forth_dsp_pop 
a76b				endm 
# End of macro FORTH_DSP_POP
a76b			 
a76b			;		pop hl 
a76b			 
a76b 3e 00				ld a,0 
a76d bd					cp l 
a76e 28 06				jr z, .bpset 
a770			;		ld a, '*' 
a770 cd de 94				call bp_off 
a773					NEXTW 
a773 c3 f8 9e			jp macro_next 
a776				endm 
# End of macro NEXTW
a776			 
a776			.bpset:	 
a776					;	ld (os_view_disable), a 
a776 cd d2 94				call bp_on 
a779			 
a779			 
a779					NEXTW 
a779 c3 f8 9e			jp macro_next 
a77c				endm 
# End of macro NEXTW
a77c			 
a77c			 
a77c			.MONITOR: 
a77c				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a77c 55				db WORD_SYS_CORE+65             
a77d ad a7			dw .MALLOC            
a77f 08				db 7 + 1 
a780 .. 00			db "MONITOR",0              
a788				endm 
# End of macro CWHEAD
a788			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a788			; | | At start the current various registers will be displayed with contents. 
a788			; | | Top right corner will show the most recent debug marker seen. 
a788			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a788			; | | and the return stack pointer (RSP). 
a788			; | | Pressing: 
a788			; | |    1 - Initial screen 
a788			; | |    2 - Display a data dump of HL 
a788			; | |    3 - Display a data dump of DE 
a788			; | |    4 - Display a data dump of BC 
a788			; | |    5 - Display a data dump of HL 
a788			; | |    6 - Display a data dump of DSP 
a788			; | |    7 - Display a data dump of RSP 
a788			; | |    8 - Display a data dump of what is at DSP 
a788			; | |    9 - Display a data dump of what is at RSP 
a788			; | |    0 - Exit monitor and continue running. This will also enable break points 
a788			; | |    * - Disable break points 
a788			; | |    # - Enter traditional monitor mode 
a788			; | | 
a788			; | | Monitor Mode 
a788			; | | ------------ 
a788			; | | A prompt of '>' will be shown for various commands: 
a788			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a788			; | |    C - Continue display a data dump from the last set address 
a788			; | |    M xxxx - Set start of memory edit at address xx 
a788			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a788			; | |    Q - Return to previous 
a788					if DEBUG_FORTH_WORDS_KEY 
a788						DMARK "MON" 
a788 f5				push af  
a789 3a 9d a7			ld a, (.dmark)  
a78c 32 6b ee			ld (debug_mark),a  
a78f 3a 9e a7			ld a, (.dmark+1)  
a792 32 6c ee			ld (debug_mark+1),a  
a795 3a 9f a7			ld a, (.dmark+2)  
a798 32 6d ee			ld (debug_mark+2),a  
a79b 18 03			jr .pastdmark  
a79d ..			.dmark: db "MON"  
a7a0 f1			.pastdmark: pop af  
a7a1			endm  
# End of macro DMARK
a7a1						CALLMONITOR 
a7a1 cd 6f ee			call debug_vector  
a7a4				endm  
# End of macro CALLMONITOR
a7a4					endif 
a7a4			;		ld a, 0 
a7a4			;		ld (os_view_disable), a 
a7a4 cd d2 94				call bp_on 
a7a7			 
a7a7					CALLMONITOR 
a7a7 cd 6f ee			call debug_vector  
a7aa				endm  
# End of macro CALLMONITOR
a7aa			 
a7aa			;	call monitor 
a7aa			 
a7aa					NEXTW 
a7aa c3 f8 9e			jp macro_next 
a7ad				endm 
# End of macro NEXTW
a7ad			 
a7ad			 
a7ad			.MALLOC: 
a7ad				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a7ad 56				db WORD_SYS_CORE+66             
a7ae d6 a7			dw .MALLOC2            
a7b0 06				db 5 + 1 
a7b1 .. 00			db "ALLOT",0              
a7b7				endm 
# End of macro CWHEAD
a7b7			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7b7					if DEBUG_FORTH_WORDS_KEY 
a7b7						DMARK "ALL" 
a7b7 f5				push af  
a7b8 3a cc a7			ld a, (.dmark)  
a7bb 32 6b ee			ld (debug_mark),a  
a7be 3a cd a7			ld a, (.dmark+1)  
a7c1 32 6c ee			ld (debug_mark+1),a  
a7c4 3a ce a7			ld a, (.dmark+2)  
a7c7 32 6d ee			ld (debug_mark+2),a  
a7ca 18 03			jr .pastdmark  
a7cc ..			.dmark: db "ALL"  
a7cf f1			.pastdmark: pop af  
a7d0			endm  
# End of macro DMARK
a7d0						CALLMONITOR 
a7d0 cd 6f ee			call debug_vector  
a7d3				endm  
# End of macro CALLMONITOR
a7d3					endif 
a7d3 c3 fd a7				jp .mallocc 
a7d6			.MALLOC2: 
a7d6				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a7d6 56				db WORD_SYS_CORE+66             
a7d7 14 a8			dw .FREE            
a7d9 07				db 6 + 1 
a7da .. 00			db "MALLOC",0              
a7e1				endm 
# End of macro CWHEAD
a7e1			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7e1					; get byte count 
a7e1					if DEBUG_FORTH_WORDS_KEY 
a7e1						DMARK "MAL" 
a7e1 f5				push af  
a7e2 3a f6 a7			ld a, (.dmark)  
a7e5 32 6b ee			ld (debug_mark),a  
a7e8 3a f7 a7			ld a, (.dmark+1)  
a7eb 32 6c ee			ld (debug_mark+1),a  
a7ee 3a f8 a7			ld a, (.dmark+2)  
a7f1 32 6d ee			ld (debug_mark+2),a  
a7f4 18 03			jr .pastdmark  
a7f6 ..			.dmark: db "MAL"  
a7f9 f1			.pastdmark: pop af  
a7fa			endm  
# End of macro DMARK
a7fa						CALLMONITOR 
a7fa cd 6f ee			call debug_vector  
a7fd				endm  
# End of macro CALLMONITOR
a7fd					endif 
a7fd			.mallocc: 
a7fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7fd cd 42 9d			call macro_dsp_valuehl 
a800				endm 
# End of macro FORTH_DSP_VALUEHL
a800			 
a800			;		push hl 
a800			 
a800					; destroy value TOS 
a800			 
a800					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a800 cd fa 9d			call macro_forth_dsp_pop 
a803				endm 
# End of macro FORTH_DSP_POP
a803			 
a803			;		pop hl 
a803 cd a3 91				call malloc 
a806				if DEBUG_FORTH_MALLOC_GUARD 
a806 f5					push af 
a807 cd 05 8d				call ishlzero 
a80a			;		ld a, l 
a80a			;		add h 
a80a			;		cp 0 
a80a f1					pop af 
a80b					 
a80b cc d7 cb				call z,malloc_error 
a80e				endif 
a80e			 
a80e cd 4b 9b				call forth_push_numhl 
a811					NEXTW 
a811 c3 f8 9e			jp macro_next 
a814				endm 
# End of macro NEXTW
a814			 
a814			.FREE: 
a814				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a814 57				db WORD_SYS_CORE+67             
a815 45 a8			dw .LIST            
a817 05				db 4 + 1 
a818 .. 00			db "FREE",0              
a81d				endm 
# End of macro CWHEAD
a81d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a81d					if DEBUG_FORTH_WORDS_KEY 
a81d						DMARK "FRE" 
a81d f5				push af  
a81e 3a 32 a8			ld a, (.dmark)  
a821 32 6b ee			ld (debug_mark),a  
a824 3a 33 a8			ld a, (.dmark+1)  
a827 32 6c ee			ld (debug_mark+1),a  
a82a 3a 34 a8			ld a, (.dmark+2)  
a82d 32 6d ee			ld (debug_mark+2),a  
a830 18 03			jr .pastdmark  
a832 ..			.dmark: db "FRE"  
a835 f1			.pastdmark: pop af  
a836			endm  
# End of macro DMARK
a836						CALLMONITOR 
a836 cd 6f ee			call debug_vector  
a839				endm  
# End of macro CALLMONITOR
a839					endif 
a839					; get address 
a839			 
a839					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a839 cd 42 9d			call macro_dsp_valuehl 
a83c				endm 
# End of macro FORTH_DSP_VALUEHL
a83c			 
a83c			;		push hl 
a83c			 
a83c					; destroy value TOS 
a83c			 
a83c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a83c cd fa 9d			call macro_forth_dsp_pop 
a83f				endm 
# End of macro FORTH_DSP_POP
a83f			 
a83f			;		pop hl 
a83f			if FORTH_ENABLE_MALLOCFREE 
a83f cd 6d 92				call free 
a842			endif 
a842					NEXTW 
a842 c3 f8 9e			jp macro_next 
a845				endm 
# End of macro NEXTW
a845			.LIST: 
a845				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a845 5c				db WORD_SYS_CORE+72             
a846 33 aa			dw .FORGET            
a848 05				db 4 + 1 
a849 .. 00			db "LIST",0              
a84e				endm 
# End of macro CWHEAD
a84e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a84e			; | | The quoted word must be in upper case. 
a84e				if DEBUG_FORTH_WORDS_KEY 
a84e					DMARK "LST" 
a84e f5				push af  
a84f 3a 63 a8			ld a, (.dmark)  
a852 32 6b ee			ld (debug_mark),a  
a855 3a 64 a8			ld a, (.dmark+1)  
a858 32 6c ee			ld (debug_mark+1),a  
a85b 3a 65 a8			ld a, (.dmark+2)  
a85e 32 6d ee			ld (debug_mark+2),a  
a861 18 03			jr .pastdmark  
a863 ..			.dmark: db "LST"  
a866 f1			.pastdmark: pop af  
a867			endm  
# End of macro DMARK
a867					CALLMONITOR 
a867 cd 6f ee			call debug_vector  
a86a				endm  
# End of macro CALLMONITOR
a86a				endif 
a86a			 
a86a					FORTH_DSP_VALUEHL 
a86a cd 42 9d			call macro_dsp_valuehl 
a86d				endm 
# End of macro FORTH_DSP_VALUEHL
a86d			 
a86d e5					push hl 
a86e					FORTH_DSP_POP 
a86e cd fa 9d			call macro_forth_dsp_pop 
a871				endm 
# End of macro FORTH_DSP_POP
a871 c1					pop bc 
a872			 
a872			; Start format of scratch string 
a872			 
a872 21 c1 e2				ld hl, scratch 
a875			 
a875 3e 3a				ld a, ':' 
a877 77					ld (hl),a 
a878 23					inc hl 
a879 3e 20				ld a, ' ' 
a87b 77					ld (hl), a 
a87c			 
a87c					; Get ptr to the word we need to look up 
a87c			 
a87c			;		FORTH_DSP_VALUEHL 
a87c					;v5 FORTH_DSP_VALUE 
a87c				; TODO type check 
a87c			;		inc hl    ; Skip type check  
a87c			;		push hl 
a87c			;		ex de, hl    ; put into DE 
a87c			 
a87c			 
a87c 21 dd e3				ld hl, baseram 
a87f					;ld hl, baseusermem 
a87f			 
a87f e5			push hl   ; sacreifical push 
a880			 
a880			.ldouscanm: 
a880 e1				pop hl 
a881			.ldouscan: 
a881				if DEBUG_FORTH_WORDS 
a881					DMARK "LSs" 
a881 f5				push af  
a882 3a 96 a8			ld a, (.dmark)  
a885 32 6b ee			ld (debug_mark),a  
a888 3a 97 a8			ld a, (.dmark+1)  
a88b 32 6c ee			ld (debug_mark+1),a  
a88e 3a 98 a8			ld a, (.dmark+2)  
a891 32 6d ee			ld (debug_mark+2),a  
a894 18 03			jr .pastdmark  
a896 ..			.dmark: db "LSs"  
a899 f1			.pastdmark: pop af  
a89a			endm  
# End of macro DMARK
a89a					CALLMONITOR 
a89a cd 6f ee			call debug_vector  
a89d				endm  
# End of macro CALLMONITOR
a89d				endif 
a89d				; skip dict stub 
a89d cd 49 a0				call forth_tok_next 
a8a0			 
a8a0			 
a8a0			; while we have words to look for 
a8a0			 
a8a0 7e				ld a, (hl)      
a8a1				if DEBUG_FORTH_WORDS 
a8a1					DMARK "LSk" 
a8a1 f5				push af  
a8a2 3a b6 a8			ld a, (.dmark)  
a8a5 32 6b ee			ld (debug_mark),a  
a8a8 3a b7 a8			ld a, (.dmark+1)  
a8ab 32 6c ee			ld (debug_mark+1),a  
a8ae 3a b8 a8			ld a, (.dmark+2)  
a8b1 32 6d ee			ld (debug_mark+2),a  
a8b4 18 03			jr .pastdmark  
a8b6 ..			.dmark: db "LSk"  
a8b9 f1			.pastdmark: pop af  
a8ba			endm  
# End of macro DMARK
a8ba					CALLMONITOR 
a8ba cd 6f ee			call debug_vector  
a8bd				endm  
# End of macro CALLMONITOR
a8bd				endif 
a8bd					;cp WORD_SYS_END 
a8bd					;jp z, .lunotfound 
a8bd			 
a8bd					; if we hit non uwords then gone too far 
a8bd fe 01				cp WORD_SYS_UWORD 
a8bf c2 ef a9				jp nz, .lunotfound 
a8c2			 
a8c2				if DEBUG_FORTH_WORDS 
a8c2					DMARK "LSu" 
a8c2 f5				push af  
a8c3 3a d7 a8			ld a, (.dmark)  
a8c6 32 6b ee			ld (debug_mark),a  
a8c9 3a d8 a8			ld a, (.dmark+1)  
a8cc 32 6c ee			ld (debug_mark+1),a  
a8cf 3a d9 a8			ld a, (.dmark+2)  
a8d2 32 6d ee			ld (debug_mark+2),a  
a8d5 18 03			jr .pastdmark  
a8d7 ..			.dmark: db "LSu"  
a8da f1			.pastdmark: pop af  
a8db			endm  
# End of macro DMARK
a8db					CALLMONITOR 
a8db cd 6f ee			call debug_vector  
a8de				endm  
# End of macro CALLMONITOR
a8de				endif 
a8de			 
a8de					; found a uword but is it the one we want... 
a8de			 
a8de c5					push bc     ; uword to find is on bc 
a8df d1					pop de 
a8e0			 
a8e0 e5					push hl  ; to save the ptr 
a8e1			 
a8e1					; skip opcode 
a8e1 23					inc hl  
a8e2					; skip next ptr 
a8e2 23					inc hl  
a8e3 23					inc hl 
a8e4					; skip len 
a8e4 23					inc hl 
a8e5			 
a8e5				if DEBUG_FORTH_WORDS 
a8e5					DMARK "LSc" 
a8e5 f5				push af  
a8e6 3a fa a8			ld a, (.dmark)  
a8e9 32 6b ee			ld (debug_mark),a  
a8ec 3a fb a8			ld a, (.dmark+1)  
a8ef 32 6c ee			ld (debug_mark+1),a  
a8f2 3a fc a8			ld a, (.dmark+2)  
a8f5 32 6d ee			ld (debug_mark+2),a  
a8f8 18 03			jr .pastdmark  
a8fa ..			.dmark: db "LSc"  
a8fd f1			.pastdmark: pop af  
a8fe			endm  
# End of macro DMARK
a8fe					CALLMONITOR 
a8fe cd 6f ee			call debug_vector  
a901				endm  
# End of macro CALLMONITOR
a901				endif 
a901 cd 72 91				call strcmp 
a904 c2 80 a8				jp nz, .ldouscanm 
a907				 
a907			 
a907			 
a907					; we have a uword so push its name to the stack 
a907			 
a907			;	   	push hl  ; save so we can move to next dict block 
a907 e1			pop hl 
a908			 
a908				if DEBUG_FORTH_WORDS 
a908					DMARK "LSm" 
a908 f5				push af  
a909 3a 1d a9			ld a, (.dmark)  
a90c 32 6b ee			ld (debug_mark),a  
a90f 3a 1e a9			ld a, (.dmark+1)  
a912 32 6c ee			ld (debug_mark+1),a  
a915 3a 1f a9			ld a, (.dmark+2)  
a918 32 6d ee			ld (debug_mark+2),a  
a91b 18 03			jr .pastdmark  
a91d ..			.dmark: db "LSm"  
a920 f1			.pastdmark: pop af  
a921			endm  
# End of macro DMARK
a921					CALLMONITOR 
a921 cd 6f ee			call debug_vector  
a924				endm  
# End of macro CALLMONITOR
a924				endif 
a924			 
a924					; skip opcode 
a924 23					inc hl  
a925					; skip next ptr 
a925 23					inc hl  
a926 23					inc hl 
a927					; skip len 
a927 7e					ld a, (hl)   ; save length to add 
a928				if DEBUG_FORTH_WORDS 
a928					DMARK "LS2" 
a928 f5				push af  
a929 3a 3d a9			ld a, (.dmark)  
a92c 32 6b ee			ld (debug_mark),a  
a92f 3a 3e a9			ld a, (.dmark+1)  
a932 32 6c ee			ld (debug_mark+1),a  
a935 3a 3f a9			ld a, (.dmark+2)  
a938 32 6d ee			ld (debug_mark+2),a  
a93b 18 03			jr .pastdmark  
a93d ..			.dmark: db "LS2"  
a940 f1			.pastdmark: pop af  
a941			endm  
# End of macro DMARK
a941					CALLMONITOR 
a941 cd 6f ee			call debug_vector  
a944				endm  
# End of macro CALLMONITOR
a944				endif 
a944			 
a944					; save this location 
a944				 
a944 e5					push hl 
a945			 
a945 23					inc hl 
a946 11 c3 e2				ld de, scratch+2 
a949 4f					ld c, a 
a94a 06 00				ld b, 0 
a94c			 
a94c				if DEBUG_FORTH_WORDS 
a94c					DMARK "LSn" 
a94c f5				push af  
a94d 3a 61 a9			ld a, (.dmark)  
a950 32 6b ee			ld (debug_mark),a  
a953 3a 62 a9			ld a, (.dmark+1)  
a956 32 6c ee			ld (debug_mark+1),a  
a959 3a 63 a9			ld a, (.dmark+2)  
a95c 32 6d ee			ld (debug_mark+2),a  
a95f 18 03			jr .pastdmark  
a961 ..			.dmark: db "LSn"  
a964 f1			.pastdmark: pop af  
a965			endm  
# End of macro DMARK
a965					CALLMONITOR 
a965 cd 6f ee			call debug_vector  
a968				endm  
# End of macro CALLMONITOR
a968				endif 
a968			 
a968					; copy uword name to scratch 
a968			 
a968 ed b0				ldir 
a96a			 
a96a 1b					dec de 
a96b 3e 20				ld a, ' '    ; change null to space 
a96d 12					ld (de), a 
a96e			 
a96e 13					inc de 
a96f			 
a96f d5					push de 
a970 c1					pop bc     ; move scratch pointer to end of word name and save it 
a971			 
a971 e1					pop hl 
a972 7e					ld a, (hl) 
a973					;inc hl 
a973					; skip word string 
a973 cd dc 8c				call addatohl 
a976			 
a976 23					inc hl 
a977			 
a977				if DEBUG_FORTH_WORDS 
a977					DMARK "LS3" 
a977 f5				push af  
a978 3a 8c a9			ld a, (.dmark)  
a97b 32 6b ee			ld (debug_mark),a  
a97e 3a 8d a9			ld a, (.dmark+1)  
a981 32 6c ee			ld (debug_mark+1),a  
a984 3a 8e a9			ld a, (.dmark+2)  
a987 32 6d ee			ld (debug_mark+2),a  
a98a 18 03			jr .pastdmark  
a98c ..			.dmark: db "LS3"  
a98f f1			.pastdmark: pop af  
a990			endm  
# End of macro DMARK
a990					CALLMONITOR 
a990 cd 6f ee			call debug_vector  
a993				endm  
# End of macro CALLMONITOR
a993				endif 
a993					; should now be at the start of the machine code to setup the eval of the uword 
a993					; now locate the ptr to the string defintion 
a993			 
a993					; skip ld hl, 
a993					; then load the ptr 
a993			; TODO use get from hl ptr 
a993 23					inc hl 
a994 5e					ld e, (hl) 
a995 23					inc hl 
a996 56					ld d, (hl) 
a997 eb					ex de, hl 
a998			 
a998			 
a998				if DEBUG_FORTH_WORDS 
a998					DMARK "LSt" 
a998 f5				push af  
a999 3a ad a9			ld a, (.dmark)  
a99c 32 6b ee			ld (debug_mark),a  
a99f 3a ae a9			ld a, (.dmark+1)  
a9a2 32 6c ee			ld (debug_mark+1),a  
a9a5 3a af a9			ld a, (.dmark+2)  
a9a8 32 6d ee			ld (debug_mark+2),a  
a9ab 18 03			jr .pastdmark  
a9ad ..			.dmark: db "LSt"  
a9b0 f1			.pastdmark: pop af  
a9b1			endm  
# End of macro DMARK
a9b1					CALLMONITOR 
a9b1 cd 6f ee			call debug_vector  
a9b4				endm  
# End of macro CALLMONITOR
a9b4				endif 
a9b4			 
a9b4			; cant push right now due to tokenised strings  
a9b4			 
a9b4			; get the destination of where to copy this definition to. 
a9b4			 
a9b4 c5					push bc 
a9b5 d1					pop de 
a9b6			 
a9b6 7e			.listl:         ld a,(hl) 
a9b7 fe 00				cp 0 
a9b9 28 09				jr z, .lreplsp     ; replace zero with space 
a9bb					;cp FORTH_END_BUFFER 
a9bb fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9bd 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9bf				 
a9bf					; just copy this char as is then 
a9bf			 
a9bf 12					ld (de), a 
a9c0			 
a9c0 23			.listnxt:	inc hl 
a9c1 13					inc de 
a9c2 18 f2				jr .listl 
a9c4			 
a9c4 3e 20		.lreplsp:	ld a,' ' 
a9c6 12					ld (de), a 
a9c7 18 f7				jr .listnxt 
a9c9			 
a9c9			; close up uword def 
a9c9			 
a9c9			.listdone: 
a9c9 12					ld (de), a 
a9ca 13					inc de 
a9cb 3e 00				ld a, 0 
a9cd 12					ld (de), a 
a9ce			 
a9ce			; now have def so clean up and push to stack 
a9ce			 
a9ce 21 c1 e2				ld hl, scratch 
a9d1				if DEBUG_FORTH_WORDS 
a9d1					DMARK "Ltp" 
a9d1 f5				push af  
a9d2 3a e6 a9			ld a, (.dmark)  
a9d5 32 6b ee			ld (debug_mark),a  
a9d8 3a e7 a9			ld a, (.dmark+1)  
a9db 32 6c ee			ld (debug_mark+1),a  
a9de 3a e8 a9			ld a, (.dmark+2)  
a9e1 32 6d ee			ld (debug_mark+2),a  
a9e4 18 03			jr .pastdmark  
a9e6 ..			.dmark: db "Ltp"  
a9e9 f1			.pastdmark: pop af  
a9ea			endm  
# End of macro DMARK
a9ea					CALLMONITOR 
a9ea cd 6f ee			call debug_vector  
a9ed				endm  
# End of macro CALLMONITOR
a9ed				endif 
a9ed			 
a9ed 18 1f			jr .listpush 
a9ef			 
a9ef			;.lnuword:	pop hl 
a9ef			;		call forth_tok_next 
a9ef			;		jp .ldouscan  
a9ef			 
a9ef			.lunotfound:		  
a9ef			 
a9ef				if DEBUG_FORTH_WORDS 
a9ef					DMARK "LSn" 
a9ef f5				push af  
a9f0 3a 04 aa			ld a, (.dmark)  
a9f3 32 6b ee			ld (debug_mark),a  
a9f6 3a 05 aa			ld a, (.dmark+1)  
a9f9 32 6c ee			ld (debug_mark+1),a  
a9fc 3a 06 aa			ld a, (.dmark+2)  
a9ff 32 6d ee			ld (debug_mark+2),a  
aa02 18 03			jr .pastdmark  
aa04 ..			.dmark: db "LSn"  
aa07 f1			.pastdmark: pop af  
aa08			endm  
# End of macro DMARK
aa08					CALLMONITOR 
aa08 cd 6f ee			call debug_vector  
aa0b				endm  
# End of macro CALLMONITOR
aa0b				endif 
aa0b			 
aa0b					 
aa0b			;		FORTH_DSP_POP 
aa0b			;		ld hl, .luno 
aa0b			 
aa0b					NEXTW			 
aa0b c3 f8 9e			jp macro_next 
aa0e				endm 
# End of macro NEXTW
aa0e			 
aa0e			.listpush: 
aa0e				if DEBUG_FORTH_WORDS 
aa0e					DMARK "LS>" 
aa0e f5				push af  
aa0f 3a 23 aa			ld a, (.dmark)  
aa12 32 6b ee			ld (debug_mark),a  
aa15 3a 24 aa			ld a, (.dmark+1)  
aa18 32 6c ee			ld (debug_mark+1),a  
aa1b 3a 25 aa			ld a, (.dmark+2)  
aa1e 32 6d ee			ld (debug_mark+2),a  
aa21 18 03			jr .pastdmark  
aa23 ..			.dmark: db "LS>"  
aa26 f1			.pastdmark: pop af  
aa27			endm  
# End of macro DMARK
aa27					CALLMONITOR 
aa27 cd 6f ee			call debug_vector  
aa2a				endm  
# End of macro CALLMONITOR
aa2a				endif 
aa2a cd b9 9b				call forth_push_str 
aa2d			 
aa2d			 
aa2d			 
aa2d					NEXTW 
aa2d c3 f8 9e			jp macro_next 
aa30				endm 
# End of macro NEXTW
aa30			 
aa30			;.luno:    db "Word not found",0 
aa30			 
aa30			 
aa30			 
aa30			 
aa30			 
aa30			;		push hl   ; save pointer to start of uword def string 
aa30			; 
aa30			;; look for FORTH_EOL_LINE 
aa30			;		ld a, FORTH_END_BUFFER 
aa30			;		call strlent 
aa30			; 
aa30			;		inc hl		 ; space for coln def 
aa30			;		inc hl 
aa30			;		inc hl          ; space for terms 
aa30			;		inc hl 
aa30			; 
aa30			;		ld a, 20   ; TODO get actual length 
aa30			;		call addatohl    ; include a random amount of room for the uword name 
aa30			; 
aa30			;		 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "Lt1" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;		 
aa30			; 
aa30			;; malloc space for the string because we cant change it 
aa30			; 
aa30			;		call malloc 
aa30			;	if DEBUG_FORTH_MALLOC_GUARD 
aa30			;		push af 
aa30			;		call ishlzero 
aa30			;		pop af 
aa30			;		 
aa30			;		call z,malloc_error 
aa30			;	endif 
aa30			; 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "Lt2" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;		pop de 
aa30			;		push hl    ; push the malloc to release later 
aa30			;		push hl   ;  push back a copy for the later stack push 
aa30			;		 
aa30			;; copy the string swapping out the zero terms for spaces 
aa30			; 
aa30			;		; de has our source 
aa30			;		; hl has our dest 
aa30			; 
aa30			;; add the coln def 
aa30			; 
aa30			;		ld a, ':' 
aa30			;		ld (hl), a 
aa30			;		inc hl 
aa30			;		ld a, ' ' 
aa30			;		ld (hl), a 
aa30			;		inc hl 
aa30			; 
aa30			;; add the uname word 
aa30			;		push de   ; save our string for now 
aa30			;		ex de, hl 
aa30			; 
aa30			;		FORTH_DSP_VALUE 
aa30			;		;v5 FORTH_DSP_VALUE 
aa30			; 
aa30			;		inc hl   ; skip type but we know by now this is OK 
aa30			; 
aa30			;.luword:	ld a,(hl) 
aa30			;		cp 0 
aa30			;		jr z, .luword2 
aa30			;		ld (de), a 
aa30			;		inc de 
aa30			;		inc hl 
aa30			;		jr .luword 
aa30			; 
aa30			;.luword2:	ld a, ' ' 
aa30			;		ld (de), a 
aa30			;;		inc hl 
aa30			;;		inc de 
aa30			;;		ld (de), a 
aa30			;;		inc hl 
aa30			;		inc de 
aa30			; 
aa30			;		ex de, hl 
aa30			;		pop de 
aa30			;		 
aa30			;		 
aa30			; 
aa30			;; detoken that string and copy it 
aa30			; 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "Lt2" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;.ldetok:	ld a, (de) 
aa30			;		cp FORTH_END_BUFFER 
aa30			;		jr z, .ldetokend 
aa30			;		; swap out any zero term for space 
aa30			;		cp 0 
aa30			;		jr nz, .ldetoknext 
aa30			;		ld a, ' ' 
aa30			; 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "LtS" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;.ldetoknext:	ld (hl), a 
aa30			;		inc de 
aa30			;		inc hl 
aa30			;		jr .ldetok 
aa30			; 
aa30			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa30			;		ld (hl), a  
aa30			; 
aa30			;; free that temp malloc 
aa30			; 
aa30			;		pop hl    
aa30			; 
aa30			;	if DEBUG_FORTH_WORDS 
aa30			;		DMARK "Lt4" 
aa30			;		CALLMONITOR 
aa30			;	endif 
aa30			;		call forth_apushstrhl 
aa30			; 
aa30			;		; get rid of temp malloc area 
aa30			; 
aa30			;		pop hl 
aa30			;		call free 
aa30			; 
aa30			;		jr .ludone 
aa30			; 
aa30			;.lnuword:	pop hl 
aa30			;		call forth_tok_next 
aa30			;		jp .ldouscan  
aa30			; 
aa30			;.ludone:		 pop hl 
aa30			; 
aa30					NEXTW 
aa30 c3 f8 9e			jp macro_next 
aa33				endm 
# End of macro NEXTW
aa33			 
aa33			.FORGET: 
aa33				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa33 5d				db WORD_SYS_CORE+73             
aa34 ac aa			dw .NOP            
aa36 07				db 6 + 1 
aa37 .. 00			db "FORGET",0              
aa3e				endm 
# End of macro CWHEAD
aa3e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa3e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa3e			; | |  
aa3e			; | | e.g. "MORE" forget 
aa3e					if DEBUG_FORTH_WORDS_KEY 
aa3e						DMARK "FRG" 
aa3e f5				push af  
aa3f 3a 53 aa			ld a, (.dmark)  
aa42 32 6b ee			ld (debug_mark),a  
aa45 3a 54 aa			ld a, (.dmark+1)  
aa48 32 6c ee			ld (debug_mark+1),a  
aa4b 3a 55 aa			ld a, (.dmark+2)  
aa4e 32 6d ee			ld (debug_mark+2),a  
aa51 18 03			jr .pastdmark  
aa53 ..			.dmark: db "FRG"  
aa56 f1			.pastdmark: pop af  
aa57			endm  
# End of macro DMARK
aa57						CALLMONITOR 
aa57 cd 6f ee			call debug_vector  
aa5a				endm  
# End of macro CALLMONITOR
aa5a					endif 
aa5a			 
aa5a				; find uword 
aa5a			        ; update start of word with "_" 
aa5a				; replace uword with deleted flag 
aa5a			 
aa5a			 
aa5a			;	if DEBUG_FORTH_WORDS 
aa5a			;		DMARK "FOG" 
aa5a			;		CALLMONITOR 
aa5a			;	endif 
aa5a			 
aa5a			 
aa5a					; Get ptr to the word we need to look up 
aa5a			 
aa5a					FORTH_DSP_VALUEHL 
aa5a cd 42 9d			call macro_dsp_valuehl 
aa5d				endm 
# End of macro FORTH_DSP_VALUEHL
aa5d					;v5 FORTH_DSP_VALUE 
aa5d				; TODO type check 
aa5d			;		inc hl    ; Skip type check  
aa5d e5					push hl 
aa5e c1					pop bc 
aa5f			;		ex de, hl    ; put into DE 
aa5f			 
aa5f			 
aa5f 21 dd e3				ld hl, baseram 
aa62					;ld hl, baseusermem 
aa62			 
aa62				; skip dict stub 
aa62			;	call forth_tok_next 
aa62 e5			push hl   ; sacreifical push 
aa63			 
aa63			.fldouscanm: 
aa63 e1				pop hl 
aa64			.fldouscan: 
aa64			;	if DEBUG_FORTH_WORDS 
aa64			;		DMARK "LSs" 
aa64			;		CALLMONITOR 
aa64			;	endif 
aa64				; skip dict stub 
aa64 cd 49 a0				call forth_tok_next 
aa67			 
aa67			 
aa67			; while we have words to look for 
aa67			 
aa67 7e				ld a, (hl)      
aa68			;	if DEBUG_FORTH_WORDS 
aa68			;		DMARK "LSk" 
aa68			;		CALLMONITOR 
aa68			;	endif 
aa68 fe 00				cp WORD_SYS_END 
aa6a ca a6 aa				jp z, .flunotfound 
aa6d fe 01				cp WORD_SYS_UWORD 
aa6f c2 64 aa				jp nz, .fldouscan 
aa72			 
aa72			;	if DEBUG_FORTH_WORDS 
aa72			;		DMARK "LSu" 
aa72			;		CALLMONITOR 
aa72			;	endif 
aa72			 
aa72					; found a uword but is it the one we want... 
aa72			 
aa72 c5					push bc     ; uword to find is on bc 
aa73 d1					pop de 
aa74			 
aa74 e5					push hl  ; to save the ptr 
aa75			 
aa75					; skip opcode 
aa75 23					inc hl  
aa76					; skip next ptr 
aa76 23					inc hl  
aa77 23					inc hl 
aa78					; skip len 
aa78 23					inc hl 
aa79			 
aa79			;	if DEBUG_FORTH_WORDS 
aa79			;		DMARK "LSc" 
aa79			;		CALLMONITOR 
aa79			;	endif 
aa79 cd 72 91				call strcmp 
aa7c c2 63 aa				jp nz, .fldouscanm 
aa7f			; 
aa7f			; 
aa7f			;; while we have words to look for 
aa7f			; 
aa7f			;.fdouscan:	ld a, (hl)      
aa7f			;	if DEBUG_FORTH_WORDS 
aa7f			;		DMARK "LSs" 
aa7f			;		CALLMONITOR 
aa7f			;	endif 
aa7f			;		cp WORD_SYS_END 
aa7f			;		jp z, .fudone 
aa7f			;		cp WORD_SYS_UWORD 
aa7f			;		jp nz, .fnuword 
aa7f			; 
aa7f			;	if DEBUG_FORTH_WORDS 
aa7f			;		DMARK "FGu" 
aa7f			;		CALLMONITOR 
aa7f			;	endif 
aa7f			; 
aa7f			;		; found a uword but is it the one we want... 
aa7f			; 
aa7f			; 
aa7f			;	        pop de   ; get back the dsp name 
aa7f			;		push de 
aa7f			; 
aa7f			;		push hl  ; to save the ptr 
aa7f			; 
aa7f			;		; skip opcode 
aa7f			;		inc hl  
aa7f			;		; skip next ptr 
aa7f			;		inc hl  
aa7f			;		inc hl 
aa7f			;		; skip len 
aa7f			;		inc hl 
aa7f			; 
aa7f			;	if DEBUG_FORTH_WORDS 
aa7f			;		DMARK "FGc" 
aa7f			;		CALLMONITOR 
aa7f			;	endif 
aa7f			;		call strcmp 
aa7f			;		jp nz, .fnuword 
aa7f			 
aa7f			 
aa7f e1			pop hl 
aa80			 
aa80				 
aa80				if DEBUG_FORTH_WORDS 
aa80					DMARK "FGm" 
aa80 f5				push af  
aa81 3a 95 aa			ld a, (.dmark)  
aa84 32 6b ee			ld (debug_mark),a  
aa87 3a 96 aa			ld a, (.dmark+1)  
aa8a 32 6c ee			ld (debug_mark+1),a  
aa8d 3a 97 aa			ld a, (.dmark+2)  
aa90 32 6d ee			ld (debug_mark+2),a  
aa93 18 03			jr .pastdmark  
aa95 ..			.dmark: db "FGm"  
aa98 f1			.pastdmark: pop af  
aa99			endm  
# End of macro DMARK
aa99					CALLMONITOR 
aa99 cd 6f ee			call debug_vector  
aa9c				endm  
# End of macro CALLMONITOR
aa9c				endif 
aa9c			 
aa9c			 
aa9c			 
aa9c					; we have a uword so push its name to the stack 
aa9c			 
aa9c			;	   	push hl  ; save so we can move to next dict block 
aa9c			;pop hl 
aa9c			 
aa9c					; update opcode to deleted 
aa9c 3e 03				ld a, WORD_SYS_DELETED 
aa9e 77					ld (hl), a 
aa9f			 
aa9f 23					inc hl  
aaa0					; skip next ptr 
aaa0 23					inc hl  
aaa1 23					inc hl 
aaa2					; skip len 
aaa2 23					inc hl 
aaa3			 
aaa3					; TODO change parser to skip deleted words but for now mark it out 
aaa3 3e 5f				ld a, "_" 
aaa5 77					ld  (hl),a 
aaa6			 
aaa6			;		jr .fudone 
aaa6			; 
aaa6			;.fnuword:	pop hl 
aaa6			;		call forth_tok_next 
aaa6			;		jp .fdouscan  
aaa6			 
aaa6			.flunotfound:		  
aaa6			 
aaa6			 
aaa6					 
aaa6					FORTH_DSP_POP 
aaa6 cd fa 9d			call macro_forth_dsp_pop 
aaa9				endm 
# End of macro FORTH_DSP_POP
aaa9			;		ld hl, .luno 
aaa9			;.fudone:		 pop hl 
aaa9					NEXTW 
aaa9 c3 f8 9e			jp macro_next 
aaac				endm 
# End of macro NEXTW
aaac			.NOP: 
aaac				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aaac 61				db WORD_SYS_CORE+77             
aaad d3 aa			dw .COMO            
aaaf 04				db 3 + 1 
aab0 .. 00			db "NOP",0              
aab4				endm 
# End of macro CWHEAD
aab4			; | NOP (  --  ) Do nothing | DONE 
aab4					if DEBUG_FORTH_WORDS_KEY 
aab4						DMARK "NOP" 
aab4 f5				push af  
aab5 3a c9 aa			ld a, (.dmark)  
aab8 32 6b ee			ld (debug_mark),a  
aabb 3a ca aa			ld a, (.dmark+1)  
aabe 32 6c ee			ld (debug_mark+1),a  
aac1 3a cb aa			ld a, (.dmark+2)  
aac4 32 6d ee			ld (debug_mark+2),a  
aac7 18 03			jr .pastdmark  
aac9 ..			.dmark: db "NOP"  
aacc f1			.pastdmark: pop af  
aacd			endm  
# End of macro DMARK
aacd						CALLMONITOR 
aacd cd 6f ee			call debug_vector  
aad0				endm  
# End of macro CALLMONITOR
aad0					endif 
aad0				       NEXTW 
aad0 c3 f8 9e			jp macro_next 
aad3				endm 
# End of macro NEXTW
aad3			.COMO: 
aad3				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aad3 6e				db WORD_SYS_CORE+90             
aad4 25 ab			dw .COMC            
aad6 02				db 1 + 1 
aad7 .. 00			db "(",0              
aad9				endm 
# End of macro CWHEAD
aad9			; | ( ( -- )  Start of comment | DONE 
aad9			 
aad9			 
aad9 2a c2 e5				ld hl, ( os_tok_ptr) 
aadc 11 20 ab			ld de, .closepar 
aadf					 
aadf					if DEBUG_FORTH_WORDS 
aadf						DMARK ").." 
aadf f5				push af  
aae0 3a f4 aa			ld a, (.dmark)  
aae3 32 6b ee			ld (debug_mark),a  
aae6 3a f5 aa			ld a, (.dmark+1)  
aae9 32 6c ee			ld (debug_mark+1),a  
aaec 3a f6 aa			ld a, (.dmark+2)  
aaef 32 6d ee			ld (debug_mark+2),a  
aaf2 18 03			jr .pastdmark  
aaf4 ..			.dmark: db ").."  
aaf7 f1			.pastdmark: pop af  
aaf8			endm  
# End of macro DMARK
aaf8						CALLMONITOR 
aaf8 cd 6f ee			call debug_vector  
aafb				endm  
# End of macro CALLMONITOR
aafb					endif 
aafb cd 13 a0			call findnexttok  
aafe			 
aafe					if DEBUG_FORTH_WORDS 
aafe						DMARK "IF5" 
aafe f5				push af  
aaff 3a 13 ab			ld a, (.dmark)  
ab02 32 6b ee			ld (debug_mark),a  
ab05 3a 14 ab			ld a, (.dmark+1)  
ab08 32 6c ee			ld (debug_mark+1),a  
ab0b 3a 15 ab			ld a, (.dmark+2)  
ab0e 32 6d ee			ld (debug_mark+2),a  
ab11 18 03			jr .pastdmark  
ab13 ..			.dmark: db "IF5"  
ab16 f1			.pastdmark: pop af  
ab17			endm  
# End of macro DMARK
ab17						CALLMONITOR 
ab17 cd 6f ee			call debug_vector  
ab1a				endm  
# End of macro CALLMONITOR
ab1a					endif 
ab1a				; replace below with ) exec using tok_ptr 
ab1a 22 c2 e5			ld (os_tok_ptr), hl 
ab1d c3 89 9f			jp exec1 
ab20			 
ab20 .. 00			.closepar:   db ")",0 
ab22			 
ab22				       NEXTW 
ab22 c3 f8 9e			jp macro_next 
ab25				endm 
# End of macro NEXTW
ab25			.COMC: 
ab25				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab25 6f				db WORD_SYS_CORE+91             
ab26 2e ab			dw .SCRATCH            
ab28 02				db 1 + 1 
ab29 .. 00			db ")",0              
ab2b				endm 
# End of macro CWHEAD
ab2b			; | ) ( -- )  End of comment |  DONE  
ab2b				       NEXTW 
ab2b c3 f8 9e			jp macro_next 
ab2e				endm 
# End of macro NEXTW
ab2e			 
ab2e			.SCRATCH: 
ab2e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab2e 6f				db WORD_SYS_CORE+91             
ab2f 69 ab			dw .INC            
ab31 08				db 7 + 1 
ab32 .. 00			db "SCRATCH",0              
ab3a				endm 
# End of macro CWHEAD
ab3a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab3a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab3a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab3a			; | |  
ab3a			; | | e.g.    : score $00 scratch ; 
ab3a			; | |  
ab3a			; | | $00 score ! 
ab3a			; | | $01 score +! 
ab3a			; | |  
ab3a			; | | e.g.   : varword $0a scratch ;  
ab3a			; | | 
ab3a			; | | $8000 varword ! 
ab3a					if DEBUG_FORTH_WORDS_KEY 
ab3a						DMARK "SCR" 
ab3a f5				push af  
ab3b 3a 4f ab			ld a, (.dmark)  
ab3e 32 6b ee			ld (debug_mark),a  
ab41 3a 50 ab			ld a, (.dmark+1)  
ab44 32 6c ee			ld (debug_mark+1),a  
ab47 3a 51 ab			ld a, (.dmark+2)  
ab4a 32 6d ee			ld (debug_mark+2),a  
ab4d 18 03			jr .pastdmark  
ab4f ..			.dmark: db "SCR"  
ab52 f1			.pastdmark: pop af  
ab53			endm  
# End of macro DMARK
ab53						CALLMONITOR 
ab53 cd 6f ee			call debug_vector  
ab56				endm  
# End of macro CALLMONITOR
ab56					endif 
ab56			 
ab56					FORTH_DSP_VALUEHL 
ab56 cd 42 9d			call macro_dsp_valuehl 
ab59				endm 
# End of macro FORTH_DSP_VALUEHL
ab59				 
ab59					FORTH_DSP_POP 
ab59 cd fa 9d			call macro_forth_dsp_pop 
ab5c				endm 
# End of macro FORTH_DSP_POP
ab5c			 
ab5c 7d					ld a, l 
ab5d 21 e6 e7				ld hl, os_var_array 
ab60 cd dc 8c				call addatohl 
ab63			 
ab63 cd 4b 9b				call forth_push_numhl 
ab66			 
ab66				       NEXTW 
ab66 c3 f8 9e			jp macro_next 
ab69				endm 
# End of macro NEXTW
ab69			 
ab69			.INC: 
ab69				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab69 6f				db WORD_SYS_CORE+91             
ab6a bd ab			dw .DEC            
ab6c 03				db 2 + 1 
ab6d .. 00			db "+!",0              
ab70				endm 
# End of macro CWHEAD
ab70			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab70					if DEBUG_FORTH_WORDS_KEY 
ab70						DMARK "+s_" 
ab70 f5				push af  
ab71 3a 85 ab			ld a, (.dmark)  
ab74 32 6b ee			ld (debug_mark),a  
ab77 3a 86 ab			ld a, (.dmark+1)  
ab7a 32 6c ee			ld (debug_mark+1),a  
ab7d 3a 87 ab			ld a, (.dmark+2)  
ab80 32 6d ee			ld (debug_mark+2),a  
ab83 18 03			jr .pastdmark  
ab85 ..			.dmark: db "+s_"  
ab88 f1			.pastdmark: pop af  
ab89			endm  
# End of macro DMARK
ab89						CALLMONITOR 
ab89 cd 6f ee			call debug_vector  
ab8c				endm  
# End of macro CALLMONITOR
ab8c					endif 
ab8c			 
ab8c					FORTH_DSP_VALUEHL 
ab8c cd 42 9d			call macro_dsp_valuehl 
ab8f				endm 
# End of macro FORTH_DSP_VALUEHL
ab8f			 
ab8f e5					push hl   ; save address 
ab90			 
ab90					FORTH_DSP_POP 
ab90 cd fa 9d			call macro_forth_dsp_pop 
ab93				endm 
# End of macro FORTH_DSP_POP
ab93			 
ab93					FORTH_DSP_VALUEHL 
ab93 cd 42 9d			call macro_dsp_valuehl 
ab96				endm 
# End of macro FORTH_DSP_VALUEHL
ab96			 
ab96					FORTH_DSP_POP 
ab96 cd fa 9d			call macro_forth_dsp_pop 
ab99				endm 
# End of macro FORTH_DSP_POP
ab99			 
ab99					; hl contains value to add to byte at a 
ab99				 
ab99 eb					ex de, hl 
ab9a			 
ab9a e1					pop hl 
ab9b			 
ab9b					if DEBUG_FORTH_WORDS 
ab9b						DMARK "INC" 
ab9b f5				push af  
ab9c 3a b0 ab			ld a, (.dmark)  
ab9f 32 6b ee			ld (debug_mark),a  
aba2 3a b1 ab			ld a, (.dmark+1)  
aba5 32 6c ee			ld (debug_mark+1),a  
aba8 3a b2 ab			ld a, (.dmark+2)  
abab 32 6d ee			ld (debug_mark+2),a  
abae 18 03			jr .pastdmark  
abb0 ..			.dmark: db "INC"  
abb3 f1			.pastdmark: pop af  
abb4			endm  
# End of macro DMARK
abb4						CALLMONITOR 
abb4 cd 6f ee			call debug_vector  
abb7				endm  
# End of macro CALLMONITOR
abb7					endif 
abb7			 
abb7 7e					ld a,(hl) 
abb8 83					add e 
abb9 77					ld (hl),a 
abba			 
abba			 
abba			 
abba				       NEXTW 
abba c3 f8 9e			jp macro_next 
abbd				endm 
# End of macro NEXTW
abbd			 
abbd			.DEC: 
abbd				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
abbd 6f				db WORD_SYS_CORE+91             
abbe 0e ac			dw .INC2            
abc0 03				db 2 + 1 
abc1 .. 00			db "-!",0              
abc4				endm 
# End of macro CWHEAD
abc4			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abc4					if DEBUG_FORTH_WORDS_KEY 
abc4						DMARK "-s_" 
abc4 f5				push af  
abc5 3a d9 ab			ld a, (.dmark)  
abc8 32 6b ee			ld (debug_mark),a  
abcb 3a da ab			ld a, (.dmark+1)  
abce 32 6c ee			ld (debug_mark+1),a  
abd1 3a db ab			ld a, (.dmark+2)  
abd4 32 6d ee			ld (debug_mark+2),a  
abd7 18 03			jr .pastdmark  
abd9 ..			.dmark: db "-s_"  
abdc f1			.pastdmark: pop af  
abdd			endm  
# End of macro DMARK
abdd						CALLMONITOR 
abdd cd 6f ee			call debug_vector  
abe0				endm  
# End of macro CALLMONITOR
abe0					endif 
abe0			 
abe0					FORTH_DSP_VALUEHL 
abe0 cd 42 9d			call macro_dsp_valuehl 
abe3				endm 
# End of macro FORTH_DSP_VALUEHL
abe3			 
abe3 e5					push hl   ; save address 
abe4			 
abe4					FORTH_DSP_POP 
abe4 cd fa 9d			call macro_forth_dsp_pop 
abe7				endm 
# End of macro FORTH_DSP_POP
abe7			 
abe7					FORTH_DSP_VALUEHL 
abe7 cd 42 9d			call macro_dsp_valuehl 
abea				endm 
# End of macro FORTH_DSP_VALUEHL
abea			 
abea					; hl contains value to add to byte at a 
abea				 
abea eb					ex de, hl 
abeb			 
abeb e1					pop hl 
abec			 
abec					if DEBUG_FORTH_WORDS 
abec						DMARK "DEC" 
abec f5				push af  
abed 3a 01 ac			ld a, (.dmark)  
abf0 32 6b ee			ld (debug_mark),a  
abf3 3a 02 ac			ld a, (.dmark+1)  
abf6 32 6c ee			ld (debug_mark+1),a  
abf9 3a 03 ac			ld a, (.dmark+2)  
abfc 32 6d ee			ld (debug_mark+2),a  
abff 18 03			jr .pastdmark  
ac01 ..			.dmark: db "DEC"  
ac04 f1			.pastdmark: pop af  
ac05			endm  
# End of macro DMARK
ac05						CALLMONITOR 
ac05 cd 6f ee			call debug_vector  
ac08				endm  
# End of macro CALLMONITOR
ac08					endif 
ac08			 
ac08 7e					ld a,(hl) 
ac09 93					sub e 
ac0a 77					ld (hl),a 
ac0b			 
ac0b			 
ac0b			 
ac0b				       NEXTW 
ac0b c3 f8 9e			jp macro_next 
ac0e				endm 
# End of macro NEXTW
ac0e			 
ac0e			.INC2: 
ac0e				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ac0e 6f				db WORD_SYS_CORE+91             
ac0f b8 ac			dw .DEC2            
ac11 04				db 3 + 1 
ac12 .. 00			db "+2!",0              
ac16				endm 
# End of macro CWHEAD
ac16			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac16			 
ac16					if DEBUG_FORTH_WORDS_KEY 
ac16						DMARK "+2s" 
ac16 f5				push af  
ac17 3a 2b ac			ld a, (.dmark)  
ac1a 32 6b ee			ld (debug_mark),a  
ac1d 3a 2c ac			ld a, (.dmark+1)  
ac20 32 6c ee			ld (debug_mark+1),a  
ac23 3a 2d ac			ld a, (.dmark+2)  
ac26 32 6d ee			ld (debug_mark+2),a  
ac29 18 03			jr .pastdmark  
ac2b ..			.dmark: db "+2s"  
ac2e f1			.pastdmark: pop af  
ac2f			endm  
# End of macro DMARK
ac2f						CALLMONITOR 
ac2f cd 6f ee			call debug_vector  
ac32				endm  
# End of macro CALLMONITOR
ac32					endif 
ac32			 
ac32					; Address 
ac32			 
ac32					FORTH_DSP_VALUEHL 
ac32 cd 42 9d			call macro_dsp_valuehl 
ac35				endm 
# End of macro FORTH_DSP_VALUEHL
ac35			 
ac35 e5					push hl    ; save address 
ac36			 
ac36					; load content into de 
ac36			 
ac36 5e					ld e,(hl) 
ac37 23					inc hl 
ac38 56					ld d, (hl) 
ac39			 
ac39					if DEBUG_FORTH_WORDS 
ac39						DMARK "+2a" 
ac39 f5				push af  
ac3a 3a 4e ac			ld a, (.dmark)  
ac3d 32 6b ee			ld (debug_mark),a  
ac40 3a 4f ac			ld a, (.dmark+1)  
ac43 32 6c ee			ld (debug_mark+1),a  
ac46 3a 50 ac			ld a, (.dmark+2)  
ac49 32 6d ee			ld (debug_mark+2),a  
ac4c 18 03			jr .pastdmark  
ac4e ..			.dmark: db "+2a"  
ac51 f1			.pastdmark: pop af  
ac52			endm  
# End of macro DMARK
ac52						CALLMONITOR 
ac52 cd 6f ee			call debug_vector  
ac55				endm  
# End of macro CALLMONITOR
ac55					endif 
ac55			 
ac55					FORTH_DSP_POP 
ac55 cd fa 9d			call macro_forth_dsp_pop 
ac58				endm 
# End of macro FORTH_DSP_POP
ac58			 
ac58					; Get value to add 
ac58			 
ac58					FORTH_DSP_VALUE 
ac58 cd 2b 9d			call macro_forth_dsp_value 
ac5b				endm 
# End of macro FORTH_DSP_VALUE
ac5b			 
ac5b					if DEBUG_FORTH_WORDS 
ac5b						DMARK "+2v" 
ac5b f5				push af  
ac5c 3a 70 ac			ld a, (.dmark)  
ac5f 32 6b ee			ld (debug_mark),a  
ac62 3a 71 ac			ld a, (.dmark+1)  
ac65 32 6c ee			ld (debug_mark+1),a  
ac68 3a 72 ac			ld a, (.dmark+2)  
ac6b 32 6d ee			ld (debug_mark+2),a  
ac6e 18 03			jr .pastdmark  
ac70 ..			.dmark: db "+2v"  
ac73 f1			.pastdmark: pop af  
ac74			endm  
# End of macro DMARK
ac74						CALLMONITOR 
ac74 cd 6f ee			call debug_vector  
ac77				endm  
# End of macro CALLMONITOR
ac77					endif 
ac77			 
ac77 19					add hl, de 
ac78			 
ac78					if DEBUG_FORTH_WORDS 
ac78						DMARK "+2+" 
ac78 f5				push af  
ac79 3a 8d ac			ld a, (.dmark)  
ac7c 32 6b ee			ld (debug_mark),a  
ac7f 3a 8e ac			ld a, (.dmark+1)  
ac82 32 6c ee			ld (debug_mark+1),a  
ac85 3a 8f ac			ld a, (.dmark+2)  
ac88 32 6d ee			ld (debug_mark+2),a  
ac8b 18 03			jr .pastdmark  
ac8d ..			.dmark: db "+2+"  
ac90 f1			.pastdmark: pop af  
ac91			endm  
# End of macro DMARK
ac91						CALLMONITOR 
ac91 cd 6f ee			call debug_vector  
ac94				endm  
# End of macro CALLMONITOR
ac94					endif 
ac94			 
ac94					; move result to de 
ac94			 
ac94 eb					ex de, hl 
ac95			 
ac95					; Address 
ac95			 
ac95 e1					pop hl 
ac96			 
ac96					; save it back 
ac96			 
ac96 73					ld (hl), e 
ac97 23					inc hl 
ac98 72					ld (hl), d 
ac99			 
ac99					if DEBUG_FORTH_WORDS 
ac99						DMARK "+2e" 
ac99 f5				push af  
ac9a 3a ae ac			ld a, (.dmark)  
ac9d 32 6b ee			ld (debug_mark),a  
aca0 3a af ac			ld a, (.dmark+1)  
aca3 32 6c ee			ld (debug_mark+1),a  
aca6 3a b0 ac			ld a, (.dmark+2)  
aca9 32 6d ee			ld (debug_mark+2),a  
acac 18 03			jr .pastdmark  
acae ..			.dmark: db "+2e"  
acb1 f1			.pastdmark: pop af  
acb2			endm  
# End of macro DMARK
acb2						CALLMONITOR 
acb2 cd 6f ee			call debug_vector  
acb5				endm  
# End of macro CALLMONITOR
acb5					endif 
acb5			 
acb5			 
acb5			 
acb5			 
acb5			 
acb5				       NEXTW 
acb5 c3 f8 9e			jp macro_next 
acb8				endm 
# End of macro NEXTW
acb8			 
acb8			.DEC2: 
acb8				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
acb8 6f				db WORD_SYS_CORE+91             
acb9 64 ad			dw .GET2            
acbb 04				db 3 + 1 
acbc .. 00			db "-2!",0              
acc0				endm 
# End of macro CWHEAD
acc0			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acc0			 
acc0			 
acc0					if DEBUG_FORTH_WORDS_KEY 
acc0						DMARK "-2s" 
acc0 f5				push af  
acc1 3a d5 ac			ld a, (.dmark)  
acc4 32 6b ee			ld (debug_mark),a  
acc7 3a d6 ac			ld a, (.dmark+1)  
acca 32 6c ee			ld (debug_mark+1),a  
accd 3a d7 ac			ld a, (.dmark+2)  
acd0 32 6d ee			ld (debug_mark+2),a  
acd3 18 03			jr .pastdmark  
acd5 ..			.dmark: db "-2s"  
acd8 f1			.pastdmark: pop af  
acd9			endm  
# End of macro DMARK
acd9						CALLMONITOR 
acd9 cd 6f ee			call debug_vector  
acdc				endm  
# End of macro CALLMONITOR
acdc					endif 
acdc			 
acdc					; Address 
acdc			 
acdc					FORTH_DSP_VALUEHL 
acdc cd 42 9d			call macro_dsp_valuehl 
acdf				endm 
# End of macro FORTH_DSP_VALUEHL
acdf			 
acdf e5					push hl    ; save address 
ace0			 
ace0					; load content into de 
ace0			 
ace0 5e					ld e,(hl) 
ace1 23					inc hl 
ace2 56					ld d, (hl) 
ace3			 
ace3					if DEBUG_FORTH_WORDS 
ace3						DMARK "-2a" 
ace3 f5				push af  
ace4 3a f8 ac			ld a, (.dmark)  
ace7 32 6b ee			ld (debug_mark),a  
acea 3a f9 ac			ld a, (.dmark+1)  
aced 32 6c ee			ld (debug_mark+1),a  
acf0 3a fa ac			ld a, (.dmark+2)  
acf3 32 6d ee			ld (debug_mark+2),a  
acf6 18 03			jr .pastdmark  
acf8 ..			.dmark: db "-2a"  
acfb f1			.pastdmark: pop af  
acfc			endm  
# End of macro DMARK
acfc						CALLMONITOR 
acfc cd 6f ee			call debug_vector  
acff				endm  
# End of macro CALLMONITOR
acff					endif 
acff			 
acff					FORTH_DSP_POP 
acff cd fa 9d			call macro_forth_dsp_pop 
ad02				endm 
# End of macro FORTH_DSP_POP
ad02			 
ad02					; Get value to remove 
ad02			 
ad02					FORTH_DSP_VALUE 
ad02 cd 2b 9d			call macro_forth_dsp_value 
ad05				endm 
# End of macro FORTH_DSP_VALUE
ad05			 
ad05					if DEBUG_FORTH_WORDS 
ad05						DMARK "-2v" 
ad05 f5				push af  
ad06 3a 1a ad			ld a, (.dmark)  
ad09 32 6b ee			ld (debug_mark),a  
ad0c 3a 1b ad			ld a, (.dmark+1)  
ad0f 32 6c ee			ld (debug_mark+1),a  
ad12 3a 1c ad			ld a, (.dmark+2)  
ad15 32 6d ee			ld (debug_mark+2),a  
ad18 18 03			jr .pastdmark  
ad1a ..			.dmark: db "-2v"  
ad1d f1			.pastdmark: pop af  
ad1e			endm  
# End of macro DMARK
ad1e						CALLMONITOR 
ad1e cd 6f ee			call debug_vector  
ad21				endm  
# End of macro CALLMONITOR
ad21					endif 
ad21			 
ad21 eb					ex de, hl 
ad22 ed 52				sbc hl, de 
ad24			 
ad24					if DEBUG_FORTH_WORDS 
ad24						DMARK "-2d" 
ad24 f5				push af  
ad25 3a 39 ad			ld a, (.dmark)  
ad28 32 6b ee			ld (debug_mark),a  
ad2b 3a 3a ad			ld a, (.dmark+1)  
ad2e 32 6c ee			ld (debug_mark+1),a  
ad31 3a 3b ad			ld a, (.dmark+2)  
ad34 32 6d ee			ld (debug_mark+2),a  
ad37 18 03			jr .pastdmark  
ad39 ..			.dmark: db "-2d"  
ad3c f1			.pastdmark: pop af  
ad3d			endm  
# End of macro DMARK
ad3d						CALLMONITOR 
ad3d cd 6f ee			call debug_vector  
ad40				endm  
# End of macro CALLMONITOR
ad40					endif 
ad40			 
ad40					; move result to de 
ad40			 
ad40 eb					ex de, hl 
ad41			 
ad41					; Address 
ad41			 
ad41 e1					pop hl 
ad42			 
ad42					; save it back 
ad42			 
ad42 73					ld (hl), e 
ad43 23					inc hl 
ad44 72					ld (hl), d 
ad45			 
ad45					if DEBUG_FORTH_WORDS 
ad45						DMARK "-2e" 
ad45 f5				push af  
ad46 3a 5a ad			ld a, (.dmark)  
ad49 32 6b ee			ld (debug_mark),a  
ad4c 3a 5b ad			ld a, (.dmark+1)  
ad4f 32 6c ee			ld (debug_mark+1),a  
ad52 3a 5c ad			ld a, (.dmark+2)  
ad55 32 6d ee			ld (debug_mark+2),a  
ad58 18 03			jr .pastdmark  
ad5a ..			.dmark: db "-2e"  
ad5d f1			.pastdmark: pop af  
ad5e			endm  
# End of macro DMARK
ad5e						CALLMONITOR 
ad5e cd 6f ee			call debug_vector  
ad61				endm  
# End of macro CALLMONITOR
ad61					endif 
ad61			 
ad61			 
ad61			 
ad61			 
ad61			 
ad61				       NEXTW 
ad61 c3 f8 9e			jp macro_next 
ad64				endm 
# End of macro NEXTW
ad64			.GET2: 
ad64				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad64 6f				db WORD_SYS_CORE+91             
ad65 94 ad			dw .BANG2            
ad67 03				db 2 + 1 
ad68 .. 00			db "2@",0              
ad6b				endm 
# End of macro CWHEAD
ad6b			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad6b					if DEBUG_FORTH_WORDS_KEY 
ad6b						DMARK "2A_" 
ad6b f5				push af  
ad6c 3a 80 ad			ld a, (.dmark)  
ad6f 32 6b ee			ld (debug_mark),a  
ad72 3a 81 ad			ld a, (.dmark+1)  
ad75 32 6c ee			ld (debug_mark+1),a  
ad78 3a 82 ad			ld a, (.dmark+2)  
ad7b 32 6d ee			ld (debug_mark+2),a  
ad7e 18 03			jr .pastdmark  
ad80 ..			.dmark: db "2A_"  
ad83 f1			.pastdmark: pop af  
ad84			endm  
# End of macro DMARK
ad84						CALLMONITOR 
ad84 cd 6f ee			call debug_vector  
ad87				endm  
# End of macro CALLMONITOR
ad87					endif 
ad87			 
ad87					FORTH_DSP_VALUEHL 
ad87 cd 42 9d			call macro_dsp_valuehl 
ad8a				endm 
# End of macro FORTH_DSP_VALUEHL
ad8a			 
ad8a 5e					ld e, (hl) 
ad8b 23					inc hl 
ad8c 56					ld d, (hl) 
ad8d			 
ad8d eb					ex de, hl 
ad8e			 
ad8e cd 4b 9b				call forth_push_numhl 
ad91			 
ad91				       NEXTW 
ad91 c3 f8 9e			jp macro_next 
ad94				endm 
# End of macro NEXTW
ad94			.BANG2: 
ad94				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad94 6f				db WORD_SYS_CORE+91             
ad95 cc ad			dw .CONFIG            
ad97 03				db 2 + 1 
ad98 .. 00			db "2!",0              
ad9b				endm 
# End of macro CWHEAD
ad9b			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad9b					if DEBUG_FORTH_WORDS_KEY 
ad9b						DMARK "2S_" 
ad9b f5				push af  
ad9c 3a b0 ad			ld a, (.dmark)  
ad9f 32 6b ee			ld (debug_mark),a  
ada2 3a b1 ad			ld a, (.dmark+1)  
ada5 32 6c ee			ld (debug_mark+1),a  
ada8 3a b2 ad			ld a, (.dmark+2)  
adab 32 6d ee			ld (debug_mark+2),a  
adae 18 03			jr .pastdmark  
adb0 ..			.dmark: db "2S_"  
adb3 f1			.pastdmark: pop af  
adb4			endm  
# End of macro DMARK
adb4						CALLMONITOR 
adb4 cd 6f ee			call debug_vector  
adb7				endm  
# End of macro CALLMONITOR
adb7					endif 
adb7			 
adb7					FORTH_DSP_VALUEHL 
adb7 cd 42 9d			call macro_dsp_valuehl 
adba				endm 
# End of macro FORTH_DSP_VALUEHL
adba			 
adba e5					push hl   ; save address 
adbb			 
adbb			 
adbb					FORTH_DSP_POP 
adbb cd fa 9d			call macro_forth_dsp_pop 
adbe				endm 
# End of macro FORTH_DSP_POP
adbe			 
adbe					 
adbe					FORTH_DSP_VALUEHL 
adbe cd 42 9d			call macro_dsp_valuehl 
adc1				endm 
# End of macro FORTH_DSP_VALUEHL
adc1			 
adc1					FORTH_DSP_POP 
adc1 cd fa 9d			call macro_forth_dsp_pop 
adc4				endm 
# End of macro FORTH_DSP_POP
adc4			 
adc4 eb					ex de, hl    ; value now in de 
adc5			 
adc5 e1					pop hl 
adc6			 
adc6 73					ld (hl), e 
adc7			 
adc7 23					inc hl 
adc8			 
adc8 72					ld (hl), d 
adc9			 
adc9			 
adc9				       NEXTW 
adc9 c3 f8 9e			jp macro_next 
adcc				endm 
# End of macro NEXTW
adcc			.CONFIG: 
adcc				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
adcc 6f				db WORD_SYS_CORE+91             
adcd dd ad			dw .ENDCORE            
adcf 07				db 6 + 1 
add0 .. 00			db "CONFIG",0              
add7				endm 
# End of macro CWHEAD
add7			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
add7			 
add7 cd 3c 93				call config 
adda					NEXTW 
adda c3 f8 9e			jp macro_next 
addd				endm 
# End of macro NEXTW
addd			.ENDCORE: 
addd			 
addd			; eof 
addd			 
addd			 
# End of file forth_words_core.asm
addd			include "forth_words_flow.asm" 
addd			 
addd			; | ## Program Flow Words 
addd			 
addd			.IF: 
addd				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
addd 1e				db WORD_SYS_CORE+10             
adde d2 ae			dw .THEN            
ade0 03				db 2 + 1 
ade1 .. 00			db "IF",0              
ade4				endm 
# End of macro CWHEAD
ade4			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ade4			; 
ade4					if DEBUG_FORTH_WORDS_KEY 
ade4						DMARK "IF." 
ade4 f5				push af  
ade5 3a f9 ad			ld a, (.dmark)  
ade8 32 6b ee			ld (debug_mark),a  
adeb 3a fa ad			ld a, (.dmark+1)  
adee 32 6c ee			ld (debug_mark+1),a  
adf1 3a fb ad			ld a, (.dmark+2)  
adf4 32 6d ee			ld (debug_mark+2),a  
adf7 18 03			jr .pastdmark  
adf9 ..			.dmark: db "IF."  
adfc f1			.pastdmark: pop af  
adfd			endm  
# End of macro DMARK
adfd						CALLMONITOR 
adfd cd 6f ee			call debug_vector  
ae00				endm  
# End of macro CALLMONITOR
ae00					endif 
ae00			; eval TOS 
ae00			 
ae00				FORTH_DSP_VALUEHL 
ae00 cd 42 9d			call macro_dsp_valuehl 
ae03				endm 
# End of macro FORTH_DSP_VALUEHL
ae03			 
ae03			;	push hl 
ae03				FORTH_DSP_POP 
ae03 cd fa 9d			call macro_forth_dsp_pop 
ae06				endm 
# End of macro FORTH_DSP_POP
ae06			;	pop hl 
ae06			 
ae06					if DEBUG_FORTH_WORDS 
ae06						DMARK "IF1" 
ae06 f5				push af  
ae07 3a 1b ae			ld a, (.dmark)  
ae0a 32 6b ee			ld (debug_mark),a  
ae0d 3a 1c ae			ld a, (.dmark+1)  
ae10 32 6c ee			ld (debug_mark+1),a  
ae13 3a 1d ae			ld a, (.dmark+2)  
ae16 32 6d ee			ld (debug_mark+2),a  
ae19 18 03			jr .pastdmark  
ae1b ..			.dmark: db "IF1"  
ae1e f1			.pastdmark: pop af  
ae1f			endm  
# End of macro DMARK
ae1f						CALLMONITOR 
ae1f cd 6f ee			call debug_vector  
ae22				endm  
# End of macro CALLMONITOR
ae22					endif 
ae22 b7				or a        ; clear carry flag 
ae23 11 00 00			ld de, 0 
ae26 eb				ex de,hl 
ae27 ed 52			sbc hl, de 
ae29 c2 b3 ae			jp nz, .iftrue 
ae2c			 
ae2c					if DEBUG_FORTH_WORDS 
ae2c						DMARK "IF2" 
ae2c f5				push af  
ae2d 3a 41 ae			ld a, (.dmark)  
ae30 32 6b ee			ld (debug_mark),a  
ae33 3a 42 ae			ld a, (.dmark+1)  
ae36 32 6c ee			ld (debug_mark+1),a  
ae39 3a 43 ae			ld a, (.dmark+2)  
ae3c 32 6d ee			ld (debug_mark+2),a  
ae3f 18 03			jr .pastdmark  
ae41 ..			.dmark: db "IF2"  
ae44 f1			.pastdmark: pop af  
ae45			endm  
# End of macro DMARK
ae45						CALLMONITOR 
ae45 cd 6f ee			call debug_vector  
ae48				endm  
# End of macro CALLMONITOR
ae48					endif 
ae48			 
ae48			; if not true then skip to THEN 
ae48			 
ae48				; TODO get tok_ptr 
ae48				; TODO consume toks until we get to THEN 
ae48			 
ae48 2a c2 e5			ld hl, (os_tok_ptr) 
ae4b					if DEBUG_FORTH_WORDS 
ae4b						DMARK "IF3" 
ae4b f5				push af  
ae4c 3a 60 ae			ld a, (.dmark)  
ae4f 32 6b ee			ld (debug_mark),a  
ae52 3a 61 ae			ld a, (.dmark+1)  
ae55 32 6c ee			ld (debug_mark+1),a  
ae58 3a 62 ae			ld a, (.dmark+2)  
ae5b 32 6d ee			ld (debug_mark+2),a  
ae5e 18 03			jr .pastdmark  
ae60 ..			.dmark: db "IF3"  
ae63 f1			.pastdmark: pop af  
ae64			endm  
# End of macro DMARK
ae64						CALLMONITOR 
ae64 cd 6f ee			call debug_vector  
ae67				endm  
# End of macro CALLMONITOR
ae67						 
ae67					endif 
ae67 11 ae ae			ld de, .ifthen 
ae6a					if DEBUG_FORTH_WORDS 
ae6a						DMARK "IF4" 
ae6a f5				push af  
ae6b 3a 7f ae			ld a, (.dmark)  
ae6e 32 6b ee			ld (debug_mark),a  
ae71 3a 80 ae			ld a, (.dmark+1)  
ae74 32 6c ee			ld (debug_mark+1),a  
ae77 3a 81 ae			ld a, (.dmark+2)  
ae7a 32 6d ee			ld (debug_mark+2),a  
ae7d 18 03			jr .pastdmark  
ae7f ..			.dmark: db "IF4"  
ae82 f1			.pastdmark: pop af  
ae83			endm  
# End of macro DMARK
ae83						CALLMONITOR 
ae83 cd 6f ee			call debug_vector  
ae86				endm  
# End of macro CALLMONITOR
ae86					endif 
ae86 cd 13 a0			call findnexttok  
ae89			 
ae89					if DEBUG_FORTH_WORDS 
ae89						DMARK "IF5" 
ae89 f5				push af  
ae8a 3a 9e ae			ld a, (.dmark)  
ae8d 32 6b ee			ld (debug_mark),a  
ae90 3a 9f ae			ld a, (.dmark+1)  
ae93 32 6c ee			ld (debug_mark+1),a  
ae96 3a a0 ae			ld a, (.dmark+2)  
ae99 32 6d ee			ld (debug_mark+2),a  
ae9c 18 03			jr .pastdmark  
ae9e ..			.dmark: db "IF5"  
aea1 f1			.pastdmark: pop af  
aea2			endm  
# End of macro DMARK
aea2						CALLMONITOR 
aea2 cd 6f ee			call debug_vector  
aea5				endm  
# End of macro CALLMONITOR
aea5					endif 
aea5				; TODO replace below with ; exec using tok_ptr 
aea5 22 c2 e5			ld (os_tok_ptr), hl 
aea8 c3 89 9f			jp exec1 
aeab				NEXTW 
aeab c3 f8 9e			jp macro_next 
aeae				endm 
# End of macro NEXTW
aeae			 
aeae .. 00		.ifthen:  db "THEN",0 
aeb3			 
aeb3			.iftrue:		 
aeb3				; Exec next words normally 
aeb3			 
aeb3				; if true then exec following IF as normal 
aeb3					if DEBUG_FORTH_WORDS 
aeb3						DMARK "IFT" 
aeb3 f5				push af  
aeb4 3a c8 ae			ld a, (.dmark)  
aeb7 32 6b ee			ld (debug_mark),a  
aeba 3a c9 ae			ld a, (.dmark+1)  
aebd 32 6c ee			ld (debug_mark+1),a  
aec0 3a ca ae			ld a, (.dmark+2)  
aec3 32 6d ee			ld (debug_mark+2),a  
aec6 18 03			jr .pastdmark  
aec8 ..			.dmark: db "IFT"  
aecb f1			.pastdmark: pop af  
aecc			endm  
# End of macro DMARK
aecc						CALLMONITOR 
aecc cd 6f ee			call debug_vector  
aecf				endm  
# End of macro CALLMONITOR
aecf					endif 
aecf			 
aecf					NEXTW 
aecf c3 f8 9e			jp macro_next 
aed2				endm 
# End of macro NEXTW
aed2			.THEN: 
aed2				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
aed2 1f				db WORD_SYS_CORE+11             
aed3 fa ae			dw .ELSE            
aed5 05				db 4 + 1 
aed6 .. 00			db "THEN",0              
aedb				endm 
# End of macro CWHEAD
aedb			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aedb					if DEBUG_FORTH_WORDS_KEY 
aedb						DMARK "THN" 
aedb f5				push af  
aedc 3a f0 ae			ld a, (.dmark)  
aedf 32 6b ee			ld (debug_mark),a  
aee2 3a f1 ae			ld a, (.dmark+1)  
aee5 32 6c ee			ld (debug_mark+1),a  
aee8 3a f2 ae			ld a, (.dmark+2)  
aeeb 32 6d ee			ld (debug_mark+2),a  
aeee 18 03			jr .pastdmark  
aef0 ..			.dmark: db "THN"  
aef3 f1			.pastdmark: pop af  
aef4			endm  
# End of macro DMARK
aef4						CALLMONITOR 
aef4 cd 6f ee			call debug_vector  
aef7				endm  
# End of macro CALLMONITOR
aef7					endif 
aef7					NEXTW 
aef7 c3 f8 9e			jp macro_next 
aefa				endm 
# End of macro NEXTW
aefa			.ELSE: 
aefa				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aefa 20				db WORD_SYS_CORE+12             
aefb 22 af			dw .DO            
aefd 03				db 2 + 1 
aefe .. 00			db "ELSE",0              
af03				endm 
# End of macro CWHEAD
af03			; | ELSE ( -- ) Not supported - does nothing | TODO 
af03			 
af03					if DEBUG_FORTH_WORDS_KEY 
af03						DMARK "ELS" 
af03 f5				push af  
af04 3a 18 af			ld a, (.dmark)  
af07 32 6b ee			ld (debug_mark),a  
af0a 3a 19 af			ld a, (.dmark+1)  
af0d 32 6c ee			ld (debug_mark+1),a  
af10 3a 1a af			ld a, (.dmark+2)  
af13 32 6d ee			ld (debug_mark+2),a  
af16 18 03			jr .pastdmark  
af18 ..			.dmark: db "ELS"  
af1b f1			.pastdmark: pop af  
af1c			endm  
# End of macro DMARK
af1c						CALLMONITOR 
af1c cd 6f ee			call debug_vector  
af1f				endm  
# End of macro CALLMONITOR
af1f					endif 
af1f			 
af1f			 
af1f					NEXTW 
af1f c3 f8 9e			jp macro_next 
af22				endm 
# End of macro NEXTW
af22			.DO: 
af22				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
af22 21				db WORD_SYS_CORE+13             
af23 49 b0			dw .LOOP            
af25 03				db 2 + 1 
af26 .. 00			db "DO",0              
af29				endm 
# End of macro CWHEAD
af29			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af29			 
af29					if DEBUG_FORTH_WORDS_KEY 
af29						DMARK "DO." 
af29 f5				push af  
af2a 3a 3e af			ld a, (.dmark)  
af2d 32 6b ee			ld (debug_mark),a  
af30 3a 3f af			ld a, (.dmark+1)  
af33 32 6c ee			ld (debug_mark+1),a  
af36 3a 40 af			ld a, (.dmark+2)  
af39 32 6d ee			ld (debug_mark+2),a  
af3c 18 03			jr .pastdmark  
af3e ..			.dmark: db "DO."  
af41 f1			.pastdmark: pop af  
af42			endm  
# End of macro DMARK
af42						CALLMONITOR 
af42 cd 6f ee			call debug_vector  
af45				endm  
# End of macro CALLMONITOR
af45					endif 
af45			;  push pc to rsp stack past the DO 
af45			 
af45 2a c2 e5				ld hl, (os_tok_ptr) 
af48 23					inc hl   ; D 
af49 23					inc hl  ; O 
af4a 23					inc hl   ; null 
af4b					if DEBUG_FORTH_WORDS 
af4b						DMARK "DO2" 
af4b f5				push af  
af4c 3a 60 af			ld a, (.dmark)  
af4f 32 6b ee			ld (debug_mark),a  
af52 3a 61 af			ld a, (.dmark+1)  
af55 32 6c ee			ld (debug_mark+1),a  
af58 3a 62 af			ld a, (.dmark+2)  
af5b 32 6d ee			ld (debug_mark+2),a  
af5e 18 03			jr .pastdmark  
af60 ..			.dmark: db "DO2"  
af63 f1			.pastdmark: pop af  
af64			endm  
# End of macro DMARK
af64						CALLMONITOR 
af64 cd 6f ee			call debug_vector  
af67				endm  
# End of macro CALLMONITOR
af67					endif 
af67					FORTH_RSP_NEXT 
af67 cd f2 9a			call macro_forth_rsp_next 
af6a				endm 
# End of macro FORTH_RSP_NEXT
af6a					if DEBUG_FORTH_WORDS 
af6a						DMARK "DO3" 
af6a f5				push af  
af6b 3a 7f af			ld a, (.dmark)  
af6e 32 6b ee			ld (debug_mark),a  
af71 3a 80 af			ld a, (.dmark+1)  
af74 32 6c ee			ld (debug_mark+1),a  
af77 3a 81 af			ld a, (.dmark+2)  
af7a 32 6d ee			ld (debug_mark+2),a  
af7d 18 03			jr .pastdmark  
af7f ..			.dmark: db "DO3"  
af82 f1			.pastdmark: pop af  
af83			endm  
# End of macro DMARK
af83						CALLMONITOR 
af83 cd 6f ee			call debug_vector  
af86				endm  
# End of macro CALLMONITOR
af86					endif 
af86			 
af86					;if DEBUG_FORTH_WORDS 
af86				;		push hl 
af86			;		endif  
af86			 
af86			; get counters from data stack 
af86			 
af86			 
af86					FORTH_DSP_VALUEHL 
af86 cd 42 9d			call macro_dsp_valuehl 
af89				endm 
# End of macro FORTH_DSP_VALUEHL
af89 e5					push hl		 ; hl now has starting counter which needs to be tos 
af8a			 
af8a					if DEBUG_FORTH_WORDS 
af8a						DMARK "DO4" 
af8a f5				push af  
af8b 3a 9f af			ld a, (.dmark)  
af8e 32 6b ee			ld (debug_mark),a  
af91 3a a0 af			ld a, (.dmark+1)  
af94 32 6c ee			ld (debug_mark+1),a  
af97 3a a1 af			ld a, (.dmark+2)  
af9a 32 6d ee			ld (debug_mark+2),a  
af9d 18 03			jr .pastdmark  
af9f ..			.dmark: db "DO4"  
afa2 f1			.pastdmark: pop af  
afa3			endm  
# End of macro DMARK
afa3						CALLMONITOR 
afa3 cd 6f ee			call debug_vector  
afa6				endm  
# End of macro CALLMONITOR
afa6					endif 
afa6					FORTH_DSP_POP 
afa6 cd fa 9d			call macro_forth_dsp_pop 
afa9				endm 
# End of macro FORTH_DSP_POP
afa9			 
afa9					if DEBUG_FORTH_WORDS 
afa9						DMARK "DO5" 
afa9 f5				push af  
afaa 3a be af			ld a, (.dmark)  
afad 32 6b ee			ld (debug_mark),a  
afb0 3a bf af			ld a, (.dmark+1)  
afb3 32 6c ee			ld (debug_mark+1),a  
afb6 3a c0 af			ld a, (.dmark+2)  
afb9 32 6d ee			ld (debug_mark+2),a  
afbc 18 03			jr .pastdmark  
afbe ..			.dmark: db "DO5"  
afc1 f1			.pastdmark: pop af  
afc2			endm  
# End of macro DMARK
afc2						CALLMONITOR 
afc2 cd 6f ee			call debug_vector  
afc5				endm  
# End of macro CALLMONITOR
afc5					endif 
afc5			 
afc5					FORTH_DSP_VALUEHL 
afc5 cd 42 9d			call macro_dsp_valuehl 
afc8				endm 
# End of macro FORTH_DSP_VALUEHL
afc8			;		push hl		 ; hl now has starting limit counter 
afc8			 
afc8					if DEBUG_FORTH_WORDS 
afc8						DMARK "DO6" 
afc8 f5				push af  
afc9 3a dd af			ld a, (.dmark)  
afcc 32 6b ee			ld (debug_mark),a  
afcf 3a de af			ld a, (.dmark+1)  
afd2 32 6c ee			ld (debug_mark+1),a  
afd5 3a df af			ld a, (.dmark+2)  
afd8 32 6d ee			ld (debug_mark+2),a  
afdb 18 03			jr .pastdmark  
afdd ..			.dmark: db "DO6"  
afe0 f1			.pastdmark: pop af  
afe1			endm  
# End of macro DMARK
afe1						CALLMONITOR 
afe1 cd 6f ee			call debug_vector  
afe4				endm  
# End of macro CALLMONITOR
afe4					endif 
afe4					FORTH_DSP_POP 
afe4 cd fa 9d			call macro_forth_dsp_pop 
afe7				endm 
# End of macro FORTH_DSP_POP
afe7			 
afe7			; put counters on the loop stack 
afe7			 
afe7			;		pop hl			 ; limit counter 
afe7 d1					pop de			; start counter 
afe8			 
afe8					; push limit counter 
afe8			 
afe8					if DEBUG_FORTH_WORDS 
afe8						DMARK "DO7" 
afe8 f5				push af  
afe9 3a fd af			ld a, (.dmark)  
afec 32 6b ee			ld (debug_mark),a  
afef 3a fe af			ld a, (.dmark+1)  
aff2 32 6c ee			ld (debug_mark+1),a  
aff5 3a ff af			ld a, (.dmark+2)  
aff8 32 6d ee			ld (debug_mark+2),a  
affb 18 03			jr .pastdmark  
affd ..			.dmark: db "DO7"  
b000 f1			.pastdmark: pop af  
b001			endm  
# End of macro DMARK
b001						CALLMONITOR 
b001 cd 6f ee			call debug_vector  
b004				endm  
# End of macro CALLMONITOR
b004					endif 
b004					FORTH_LOOP_NEXT 
b004 cd 73 9d			call macro_forth_loop_next 
b007				endm 
# End of macro FORTH_LOOP_NEXT
b007			 
b007					; push start counter 
b007			 
b007 eb					ex de, hl 
b008					if DEBUG_FORTH_WORDS 
b008						DMARK "DO7" 
b008 f5				push af  
b009 3a 1d b0			ld a, (.dmark)  
b00c 32 6b ee			ld (debug_mark),a  
b00f 3a 1e b0			ld a, (.dmark+1)  
b012 32 6c ee			ld (debug_mark+1),a  
b015 3a 1f b0			ld a, (.dmark+2)  
b018 32 6d ee			ld (debug_mark+2),a  
b01b 18 03			jr .pastdmark  
b01d ..			.dmark: db "DO7"  
b020 f1			.pastdmark: pop af  
b021			endm  
# End of macro DMARK
b021						CALLMONITOR 
b021 cd 6f ee			call debug_vector  
b024				endm  
# End of macro CALLMONITOR
b024					endif 
b024					FORTH_LOOP_NEXT 
b024 cd 73 9d			call macro_forth_loop_next 
b027				endm 
# End of macro FORTH_LOOP_NEXT
b027			 
b027			 
b027					; init first round of I counter 
b027			 
b027 22 e6 e5				ld (os_current_i), hl 
b02a			 
b02a					if DEBUG_FORTH_WORDS 
b02a						DMARK "DO8" 
b02a f5				push af  
b02b 3a 3f b0			ld a, (.dmark)  
b02e 32 6b ee			ld (debug_mark),a  
b031 3a 40 b0			ld a, (.dmark+1)  
b034 32 6c ee			ld (debug_mark+1),a  
b037 3a 41 b0			ld a, (.dmark+2)  
b03a 32 6d ee			ld (debug_mark+2),a  
b03d 18 03			jr .pastdmark  
b03f ..			.dmark: db "DO8"  
b042 f1			.pastdmark: pop af  
b043			endm  
# End of macro DMARK
b043						CALLMONITOR 
b043 cd 6f ee			call debug_vector  
b046				endm  
# End of macro CALLMONITOR
b046					endif 
b046			 
b046					NEXTW 
b046 c3 f8 9e			jp macro_next 
b049				endm 
# End of macro NEXTW
b049			.LOOP: 
b049				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b049 22				db WORD_SYS_CORE+14             
b04a 61 b1			dw .I            
b04c 05				db 4 + 1 
b04d .. 00			db "LOOP",0              
b052				endm 
# End of macro CWHEAD
b052			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b052			 
b052				; pop tos as current loop count to hl 
b052			 
b052				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b052			 
b052				FORTH_LOOP_TOS 
b052 cd a6 9d			call macro_forth_loop_tos 
b055				endm 
# End of macro FORTH_LOOP_TOS
b055 e5				push hl 
b056			 
b056					if DEBUG_FORTH_WORDS_KEY 
b056						DMARK "LOP" 
b056 f5				push af  
b057 3a 6b b0			ld a, (.dmark)  
b05a 32 6b ee			ld (debug_mark),a  
b05d 3a 6c b0			ld a, (.dmark+1)  
b060 32 6c ee			ld (debug_mark+1),a  
b063 3a 6d b0			ld a, (.dmark+2)  
b066 32 6d ee			ld (debug_mark+2),a  
b069 18 03			jr .pastdmark  
b06b ..			.dmark: db "LOP"  
b06e f1			.pastdmark: pop af  
b06f			endm  
# End of macro DMARK
b06f						CALLMONITOR 
b06f cd 6f ee			call debug_vector  
b072				endm  
# End of macro CALLMONITOR
b072					endif 
b072				; next item on the stack is the limit. get it 
b072			 
b072			 
b072				FORTH_LOOP_POP 
b072 cd b0 9d			call macro_forth_loop_pop 
b075				endm 
# End of macro FORTH_LOOP_POP
b075			 
b075				FORTH_LOOP_TOS 
b075 cd a6 9d			call macro_forth_loop_tos 
b078				endm 
# End of macro FORTH_LOOP_TOS
b078			 
b078 d1				pop de		 ; de = i, hl = limit 
b079			 
b079					if DEBUG_FORTH_WORDS 
b079						DMARK "LP1" 
b079 f5				push af  
b07a 3a 8e b0			ld a, (.dmark)  
b07d 32 6b ee			ld (debug_mark),a  
b080 3a 8f b0			ld a, (.dmark+1)  
b083 32 6c ee			ld (debug_mark+1),a  
b086 3a 90 b0			ld a, (.dmark+2)  
b089 32 6d ee			ld (debug_mark+2),a  
b08c 18 03			jr .pastdmark  
b08e ..			.dmark: db "LP1"  
b091 f1			.pastdmark: pop af  
b092			endm  
# End of macro DMARK
b092						CALLMONITOR 
b092 cd 6f ee			call debug_vector  
b095				endm  
# End of macro CALLMONITOR
b095					endif 
b095			 
b095				; go back to previous word 
b095			 
b095 d5				push de    ; save I for inc later 
b096			 
b096			 
b096				; get limit 
b096				;  is I at limit? 
b096			 
b096			 
b096					if DEBUG_FORTH_WORDS 
b096						DMARK "LP1" 
b096 f5				push af  
b097 3a ab b0			ld a, (.dmark)  
b09a 32 6b ee			ld (debug_mark),a  
b09d 3a ac b0			ld a, (.dmark+1)  
b0a0 32 6c ee			ld (debug_mark+1),a  
b0a3 3a ad b0			ld a, (.dmark+2)  
b0a6 32 6d ee			ld (debug_mark+2),a  
b0a9 18 03			jr .pastdmark  
b0ab ..			.dmark: db "LP1"  
b0ae f1			.pastdmark: pop af  
b0af			endm  
# End of macro DMARK
b0af						CALLMONITOR 
b0af cd 6f ee			call debug_vector  
b0b2				endm  
# End of macro CALLMONITOR
b0b2					endif 
b0b2			 
b0b2 ed 52			sbc hl, de 
b0b4			 
b0b4			 
b0b4				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b0b4			 
b0b4 20 26				jr nz, .loopnotdone 
b0b6			 
b0b6 e1				pop hl   ; get rid of saved I 
b0b7				FORTH_LOOP_POP     ; get rid of limit 
b0b7 cd b0 9d			call macro_forth_loop_pop 
b0ba				endm 
# End of macro FORTH_LOOP_POP
b0ba			 
b0ba				FORTH_RSP_POP     ; get rid of DO ptr 
b0ba cd 13 9b			call macro_forth_rsp_pop 
b0bd				endm 
# End of macro FORTH_RSP_POP
b0bd			 
b0bd			if DEBUG_FORTH_WORDS 
b0bd						DMARK "LP>" 
b0bd f5				push af  
b0be 3a d2 b0			ld a, (.dmark)  
b0c1 32 6b ee			ld (debug_mark),a  
b0c4 3a d3 b0			ld a, (.dmark+1)  
b0c7 32 6c ee			ld (debug_mark+1),a  
b0ca 3a d4 b0			ld a, (.dmark+2)  
b0cd 32 6d ee			ld (debug_mark+2),a  
b0d0 18 03			jr .pastdmark  
b0d2 ..			.dmark: db "LP>"  
b0d5 f1			.pastdmark: pop af  
b0d6			endm  
# End of macro DMARK
b0d6				CALLMONITOR 
b0d6 cd 6f ee			call debug_vector  
b0d9				endm  
# End of macro CALLMONITOR
b0d9			endif 
b0d9			 
b0d9					NEXTW 
b0d9 c3 f8 9e			jp macro_next 
b0dc				endm 
# End of macro NEXTW
b0dc				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0dc			 
b0dc			.loopnotdone: 
b0dc			 
b0dc e1				pop hl    ; get I 
b0dd 23				inc hl 
b0de			 
b0de			   	; save new I 
b0de			 
b0de			 
b0de					; set I counter 
b0de			 
b0de 22 e6 e5				ld (os_current_i), hl 
b0e1			 
b0e1					if DEBUG_FORTH_WORDS 
b0e1						DMARK "LPN" 
b0e1 f5				push af  
b0e2 3a f6 b0			ld a, (.dmark)  
b0e5 32 6b ee			ld (debug_mark),a  
b0e8 3a f7 b0			ld a, (.dmark+1)  
b0eb 32 6c ee			ld (debug_mark+1),a  
b0ee 3a f8 b0			ld a, (.dmark+2)  
b0f1 32 6d ee			ld (debug_mark+2),a  
b0f4 18 03			jr .pastdmark  
b0f6 ..			.dmark: db "LPN"  
b0f9 f1			.pastdmark: pop af  
b0fa			endm  
# End of macro DMARK
b0fa					CALLMONITOR 
b0fa cd 6f ee			call debug_vector  
b0fd				endm  
# End of macro CALLMONITOR
b0fd					endif 
b0fd					 
b0fd				FORTH_LOOP_NEXT 
b0fd cd 73 9d			call macro_forth_loop_next 
b100				endm 
# End of macro FORTH_LOOP_NEXT
b100			 
b100			 
b100					if DEBUG_FORTH_WORDS 
b100 eb						ex de,hl 
b101					endif 
b101			 
b101			;	; get DO ptr 
b101			; 
b101					if DEBUG_FORTH_WORDS 
b101						DMARK "LP7" 
b101 f5				push af  
b102 3a 16 b1			ld a, (.dmark)  
b105 32 6b ee			ld (debug_mark),a  
b108 3a 17 b1			ld a, (.dmark+1)  
b10b 32 6c ee			ld (debug_mark+1),a  
b10e 3a 18 b1			ld a, (.dmark+2)  
b111 32 6d ee			ld (debug_mark+2),a  
b114 18 03			jr .pastdmark  
b116 ..			.dmark: db "LP7"  
b119 f1			.pastdmark: pop af  
b11a			endm  
# End of macro DMARK
b11a					CALLMONITOR 
b11a cd 6f ee			call debug_vector  
b11d				endm  
# End of macro CALLMONITOR
b11d					endif 
b11d				FORTH_RSP_TOS 
b11d cd 09 9b			call macro_forth_rsp_tos 
b120				endm 
# End of macro FORTH_RSP_TOS
b120			 
b120					if DEBUG_FORTH_WORDS 
b120						DMARK "LP8" 
b120 f5				push af  
b121 3a 35 b1			ld a, (.dmark)  
b124 32 6b ee			ld (debug_mark),a  
b127 3a 36 b1			ld a, (.dmark+1)  
b12a 32 6c ee			ld (debug_mark+1),a  
b12d 3a 37 b1			ld a, (.dmark+2)  
b130 32 6d ee			ld (debug_mark+2),a  
b133 18 03			jr .pastdmark  
b135 ..			.dmark: db "LP8"  
b138 f1			.pastdmark: pop af  
b139			endm  
# End of macro DMARK
b139					CALLMONITOR 
b139 cd 6f ee			call debug_vector  
b13c				endm  
# End of macro CALLMONITOR
b13c					endif 
b13c				;push hl 
b13c			 
b13c				; not going to DO any more 
b13c				; get rid of the RSP pointer as DO will add it back in 
b13c				;FORTH_RSP_POP 
b13c				;pop hl 
b13c			 
b13c				;ld hl,(cli_ret_sp) 
b13c				;ld e, (hl) 
b13c				;inc hl 
b13c				;ld d, (hl) 
b13c				;ex de,hl 
b13c 22 c2 e5			ld (os_tok_ptr), hl 
b13f					if DEBUG_FORTH_WORDS 
b13f						DMARK "LP<" 
b13f f5				push af  
b140 3a 54 b1			ld a, (.dmark)  
b143 32 6b ee			ld (debug_mark),a  
b146 3a 55 b1			ld a, (.dmark+1)  
b149 32 6c ee			ld (debug_mark+1),a  
b14c 3a 56 b1			ld a, (.dmark+2)  
b14f 32 6d ee			ld (debug_mark+2),a  
b152 18 03			jr .pastdmark  
b154 ..			.dmark: db "LP<"  
b157 f1			.pastdmark: pop af  
b158			endm  
# End of macro DMARK
b158					CALLMONITOR 
b158 cd 6f ee			call debug_vector  
b15b				endm  
# End of macro CALLMONITOR
b15b				endif 
b15b c3 89 9f			jp exec1 
b15e			 
b15e					 
b15e			 
b15e			 
b15e					NEXTW 
b15e c3 f8 9e			jp macro_next 
b161				endm 
# End of macro NEXTW
b161			.I:  
b161			 
b161				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b161 5e				db WORD_SYS_CORE+74             
b162 8c b1			dw .DLOOP            
b164 02				db 1 + 1 
b165 .. 00			db "I",0              
b167				endm 
# End of macro CWHEAD
b167			; | I ( -- ) Current loop counter | DONE 
b167					if DEBUG_FORTH_WORDS_KEY 
b167						DMARK "I.." 
b167 f5				push af  
b168 3a 7c b1			ld a, (.dmark)  
b16b 32 6b ee			ld (debug_mark),a  
b16e 3a 7d b1			ld a, (.dmark+1)  
b171 32 6c ee			ld (debug_mark+1),a  
b174 3a 7e b1			ld a, (.dmark+2)  
b177 32 6d ee			ld (debug_mark+2),a  
b17a 18 03			jr .pastdmark  
b17c ..			.dmark: db "I.."  
b17f f1			.pastdmark: pop af  
b180			endm  
# End of macro DMARK
b180						CALLMONITOR 
b180 cd 6f ee			call debug_vector  
b183				endm  
# End of macro CALLMONITOR
b183					endif 
b183			 
b183 2a e6 e5				ld hl,(os_current_i) 
b186 cd 4b 9b				call forth_push_numhl 
b189			 
b189					NEXTW 
b189 c3 f8 9e			jp macro_next 
b18c				endm 
# End of macro NEXTW
b18c			.DLOOP: 
b18c				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b18c 5f				db WORD_SYS_CORE+75             
b18d 6d b2			dw .REPEAT            
b18f 06				db 5 + 1 
b190 .. 00			db "-LOOP",0              
b196				endm 
# End of macro CWHEAD
b196			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b196				; pop tos as current loop count to hl 
b196					if DEBUG_FORTH_WORDS_KEY 
b196						DMARK "-LP" 
b196 f5				push af  
b197 3a ab b1			ld a, (.dmark)  
b19a 32 6b ee			ld (debug_mark),a  
b19d 3a ac b1			ld a, (.dmark+1)  
b1a0 32 6c ee			ld (debug_mark+1),a  
b1a3 3a ad b1			ld a, (.dmark+2)  
b1a6 32 6d ee			ld (debug_mark+2),a  
b1a9 18 03			jr .pastdmark  
b1ab ..			.dmark: db "-LP"  
b1ae f1			.pastdmark: pop af  
b1af			endm  
# End of macro DMARK
b1af						CALLMONITOR 
b1af cd 6f ee			call debug_vector  
b1b2				endm  
# End of macro CALLMONITOR
b1b2					endif 
b1b2			 
b1b2				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b1b2			 
b1b2				FORTH_LOOP_TOS 
b1b2 cd a6 9d			call macro_forth_loop_tos 
b1b5				endm 
# End of macro FORTH_LOOP_TOS
b1b5 e5				push hl 
b1b6			 
b1b6					if DEBUG_FORTH_WORDS 
b1b6						DMARK "-LP" 
b1b6 f5				push af  
b1b7 3a cb b1			ld a, (.dmark)  
b1ba 32 6b ee			ld (debug_mark),a  
b1bd 3a cc b1			ld a, (.dmark+1)  
b1c0 32 6c ee			ld (debug_mark+1),a  
b1c3 3a cd b1			ld a, (.dmark+2)  
b1c6 32 6d ee			ld (debug_mark+2),a  
b1c9 18 03			jr .pastdmark  
b1cb ..			.dmark: db "-LP"  
b1ce f1			.pastdmark: pop af  
b1cf			endm  
# End of macro DMARK
b1cf						CALLMONITOR 
b1cf cd 6f ee			call debug_vector  
b1d2				endm  
# End of macro CALLMONITOR
b1d2					endif 
b1d2				; next item on the stack is the limit. get it 
b1d2			 
b1d2			 
b1d2				FORTH_LOOP_POP 
b1d2 cd b0 9d			call macro_forth_loop_pop 
b1d5				endm 
# End of macro FORTH_LOOP_POP
b1d5			 
b1d5				FORTH_LOOP_TOS 
b1d5 cd a6 9d			call macro_forth_loop_tos 
b1d8				endm 
# End of macro FORTH_LOOP_TOS
b1d8			 
b1d8 d1				pop de		 ; de = i, hl = limit 
b1d9			 
b1d9					if DEBUG_FORTH_WORDS 
b1d9						DMARK "-L1" 
b1d9 f5				push af  
b1da 3a ee b1			ld a, (.dmark)  
b1dd 32 6b ee			ld (debug_mark),a  
b1e0 3a ef b1			ld a, (.dmark+1)  
b1e3 32 6c ee			ld (debug_mark+1),a  
b1e6 3a f0 b1			ld a, (.dmark+2)  
b1e9 32 6d ee			ld (debug_mark+2),a  
b1ec 18 03			jr .pastdmark  
b1ee ..			.dmark: db "-L1"  
b1f1 f1			.pastdmark: pop af  
b1f2			endm  
# End of macro DMARK
b1f2						CALLMONITOR 
b1f2 cd 6f ee			call debug_vector  
b1f5				endm  
# End of macro CALLMONITOR
b1f5					endif 
b1f5			 
b1f5				; go back to previous word 
b1f5			 
b1f5 d5				push de    ; save I for inc later 
b1f6			 
b1f6			 
b1f6				; get limit 
b1f6				;  is I at limit? 
b1f6			 
b1f6			 
b1f6					if DEBUG_FORTH_WORDS 
b1f6						DMARK "-L1" 
b1f6 f5				push af  
b1f7 3a 0b b2			ld a, (.dmark)  
b1fa 32 6b ee			ld (debug_mark),a  
b1fd 3a 0c b2			ld a, (.dmark+1)  
b200 32 6c ee			ld (debug_mark+1),a  
b203 3a 0d b2			ld a, (.dmark+2)  
b206 32 6d ee			ld (debug_mark+2),a  
b209 18 03			jr .pastdmark  
b20b ..			.dmark: db "-L1"  
b20e f1			.pastdmark: pop af  
b20f			endm  
# End of macro DMARK
b20f						CALLMONITOR 
b20f cd 6f ee			call debug_vector  
b212				endm  
# End of macro CALLMONITOR
b212					endif 
b212			 
b212 ed 52			sbc hl, de 
b214			 
b214			 
b214				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b214			 
b214 20 26				jr nz, .mloopnotdone 
b216			 
b216 e1				pop hl   ; get rid of saved I 
b217				FORTH_LOOP_POP     ; get rid of limit 
b217 cd b0 9d			call macro_forth_loop_pop 
b21a				endm 
# End of macro FORTH_LOOP_POP
b21a			 
b21a				FORTH_RSP_POP     ; get rid of DO ptr 
b21a cd 13 9b			call macro_forth_rsp_pop 
b21d				endm 
# End of macro FORTH_RSP_POP
b21d			 
b21d			if DEBUG_FORTH_WORDS 
b21d						DMARK "-L>" 
b21d f5				push af  
b21e 3a 32 b2			ld a, (.dmark)  
b221 32 6b ee			ld (debug_mark),a  
b224 3a 33 b2			ld a, (.dmark+1)  
b227 32 6c ee			ld (debug_mark+1),a  
b22a 3a 34 b2			ld a, (.dmark+2)  
b22d 32 6d ee			ld (debug_mark+2),a  
b230 18 03			jr .pastdmark  
b232 ..			.dmark: db "-L>"  
b235 f1			.pastdmark: pop af  
b236			endm  
# End of macro DMARK
b236				CALLMONITOR 
b236 cd 6f ee			call debug_vector  
b239				endm  
# End of macro CALLMONITOR
b239			endif 
b239			 
b239					NEXTW 
b239 c3 f8 9e			jp macro_next 
b23c				endm 
# End of macro NEXTW
b23c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b23c			 
b23c			.mloopnotdone: 
b23c			 
b23c e1				pop hl    ; get I 
b23d 2b				dec hl 
b23e			 
b23e			   	; save new I 
b23e			 
b23e			 
b23e					; set I counter 
b23e			 
b23e 22 e6 e5				ld (os_current_i), hl 
b241			 
b241					 
b241				FORTH_LOOP_NEXT 
b241 cd 73 9d			call macro_forth_loop_next 
b244				endm 
# End of macro FORTH_LOOP_NEXT
b244			 
b244			 
b244					if DEBUG_FORTH_WORDS 
b244 eb						ex de,hl 
b245					endif 
b245			 
b245			;	; get DO ptr 
b245			; 
b245				FORTH_RSP_TOS 
b245 cd 09 9b			call macro_forth_rsp_tos 
b248				endm 
# End of macro FORTH_RSP_TOS
b248			 
b248				;push hl 
b248			 
b248				; not going to DO any more 
b248				; get rid of the RSP pointer as DO will add it back in 
b248				;FORTH_RSP_POP 
b248				;pop hl 
b248			 
b248			 
b248 22 c2 e5			ld (os_tok_ptr), hl 
b24b					if DEBUG_FORTH_WORDS 
b24b						DMARK "-L<" 
b24b f5				push af  
b24c 3a 60 b2			ld a, (.dmark)  
b24f 32 6b ee			ld (debug_mark),a  
b252 3a 61 b2			ld a, (.dmark+1)  
b255 32 6c ee			ld (debug_mark+1),a  
b258 3a 62 b2			ld a, (.dmark+2)  
b25b 32 6d ee			ld (debug_mark+2),a  
b25e 18 03			jr .pastdmark  
b260 ..			.dmark: db "-L<"  
b263 f1			.pastdmark: pop af  
b264			endm  
# End of macro DMARK
b264					CALLMONITOR 
b264 cd 6f ee			call debug_vector  
b267				endm  
# End of macro CALLMONITOR
b267				endif 
b267 c3 89 9f			jp exec1 
b26a			 
b26a					 
b26a			 
b26a			 
b26a			 
b26a				NEXTW 
b26a c3 f8 9e			jp macro_next 
b26d				endm 
# End of macro NEXTW
b26d			 
b26d			 
b26d			 
b26d			 
b26d			.REPEAT: 
b26d				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b26d 71				db WORD_SYS_CORE+93             
b26e c0 b2			dw .UNTIL            
b270 06				db 5 + 1 
b271 .. 00			db "REPEAT",0              
b278				endm 
# End of macro CWHEAD
b278			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b278			;  push pc to rsp stack past the REPEAT 
b278					if DEBUG_FORTH_WORDS_KEY 
b278						DMARK "REP" 
b278 f5				push af  
b279 3a 8d b2			ld a, (.dmark)  
b27c 32 6b ee			ld (debug_mark),a  
b27f 3a 8e b2			ld a, (.dmark+1)  
b282 32 6c ee			ld (debug_mark+1),a  
b285 3a 8f b2			ld a, (.dmark+2)  
b288 32 6d ee			ld (debug_mark+2),a  
b28b 18 03			jr .pastdmark  
b28d ..			.dmark: db "REP"  
b290 f1			.pastdmark: pop af  
b291			endm  
# End of macro DMARK
b291						CALLMONITOR 
b291 cd 6f ee			call debug_vector  
b294				endm  
# End of macro CALLMONITOR
b294					endif 
b294			 
b294 2a c2 e5				ld hl, (os_tok_ptr) 
b297 23					inc hl   ; R 
b298 23					inc hl  ; E 
b299 23					inc hl   ; P 
b29a 23					inc hl   ; E 
b29b 23					inc hl   ; A 
b29c 23					inc hl   ; T 
b29d 23					inc hl   ; zero 
b29e					FORTH_RSP_NEXT 
b29e cd f2 9a			call macro_forth_rsp_next 
b2a1				endm 
# End of macro FORTH_RSP_NEXT
b2a1			 
b2a1			 
b2a1					if DEBUG_FORTH_WORDS 
b2a1						DMARK "REP" 
b2a1 f5				push af  
b2a2 3a b6 b2			ld a, (.dmark)  
b2a5 32 6b ee			ld (debug_mark),a  
b2a8 3a b7 b2			ld a, (.dmark+1)  
b2ab 32 6c ee			ld (debug_mark+1),a  
b2ae 3a b8 b2			ld a, (.dmark+2)  
b2b1 32 6d ee			ld (debug_mark+2),a  
b2b4 18 03			jr .pastdmark  
b2b6 ..			.dmark: db "REP"  
b2b9 f1			.pastdmark: pop af  
b2ba			endm  
# End of macro DMARK
b2ba						;pop bc    ; TODO BUG ?????? what is this for???? 
b2ba						CALLMONITOR 
b2ba cd 6f ee			call debug_vector  
b2bd				endm  
# End of macro CALLMONITOR
b2bd					endif 
b2bd			 
b2bd					NEXTW 
b2bd c3 f8 9e			jp macro_next 
b2c0				endm 
# End of macro NEXTW
b2c0			;	       NEXTW 
b2c0			 
b2c0			.UNTIL: 
b2c0				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b2c0 72				db WORD_SYS_CORE+94             
b2c1 57 b3			dw .ENDFLOW            
b2c3 06				db 5 + 1 
b2c4 .. 00			db "UNTIL",0              
b2ca				endm 
# End of macro CWHEAD
b2ca			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b2ca			 
b2ca				; pop tos as check 
b2ca			 
b2ca				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b2ca			 
b2ca				FORTH_DSP_VALUEHL 
b2ca cd 42 9d			call macro_dsp_valuehl 
b2cd				endm 
# End of macro FORTH_DSP_VALUEHL
b2cd			 
b2cd					if DEBUG_FORTH_WORDS_KEY 
b2cd						DMARK "UNT" 
b2cd f5				push af  
b2ce 3a e2 b2			ld a, (.dmark)  
b2d1 32 6b ee			ld (debug_mark),a  
b2d4 3a e3 b2			ld a, (.dmark+1)  
b2d7 32 6c ee			ld (debug_mark+1),a  
b2da 3a e4 b2			ld a, (.dmark+2)  
b2dd 32 6d ee			ld (debug_mark+2),a  
b2e0 18 03			jr .pastdmark  
b2e2 ..			.dmark: db "UNT"  
b2e5 f1			.pastdmark: pop af  
b2e6			endm  
# End of macro DMARK
b2e6						CALLMONITOR 
b2e6 cd 6f ee			call debug_vector  
b2e9				endm  
# End of macro CALLMONITOR
b2e9					endif 
b2e9			 
b2e9			;	push hl 
b2e9				FORTH_DSP_POP 
b2e9 cd fa 9d			call macro_forth_dsp_pop 
b2ec				endm 
# End of macro FORTH_DSP_POP
b2ec			 
b2ec			;	pop hl 
b2ec			 
b2ec				; test if true 
b2ec			 
b2ec cd 05 8d			call ishlzero 
b2ef			;	ld a,l 
b2ef			;	add h 
b2ef			; 
b2ef			;	cp 0 
b2ef			 
b2ef 20 3e			jr nz, .untilnotdone 
b2f1			 
b2f1					if DEBUG_FORTH_WORDS 
b2f1						DMARK "UNf" 
b2f1 f5				push af  
b2f2 3a 06 b3			ld a, (.dmark)  
b2f5 32 6b ee			ld (debug_mark),a  
b2f8 3a 07 b3			ld a, (.dmark+1)  
b2fb 32 6c ee			ld (debug_mark+1),a  
b2fe 3a 08 b3			ld a, (.dmark+2)  
b301 32 6d ee			ld (debug_mark+2),a  
b304 18 03			jr .pastdmark  
b306 ..			.dmark: db "UNf"  
b309 f1			.pastdmark: pop af  
b30a			endm  
# End of macro DMARK
b30a						CALLMONITOR 
b30a cd 6f ee			call debug_vector  
b30d				endm  
# End of macro CALLMONITOR
b30d					endif 
b30d			 
b30d			 
b30d			 
b30d				FORTH_RSP_POP     ; get rid of DO ptr 
b30d cd 13 9b			call macro_forth_rsp_pop 
b310				endm 
# End of macro FORTH_RSP_POP
b310			 
b310			if DEBUG_FORTH_WORDS 
b310						DMARK "UN>" 
b310 f5				push af  
b311 3a 25 b3			ld a, (.dmark)  
b314 32 6b ee			ld (debug_mark),a  
b317 3a 26 b3			ld a, (.dmark+1)  
b31a 32 6c ee			ld (debug_mark+1),a  
b31d 3a 27 b3			ld a, (.dmark+2)  
b320 32 6d ee			ld (debug_mark+2),a  
b323 18 03			jr .pastdmark  
b325 ..			.dmark: db "UN>"  
b328 f1			.pastdmark: pop af  
b329			endm  
# End of macro DMARK
b329				CALLMONITOR 
b329 cd 6f ee			call debug_vector  
b32c				endm  
# End of macro CALLMONITOR
b32c			endif 
b32c			 
b32c					NEXTW 
b32c c3 f8 9e			jp macro_next 
b32f				endm 
# End of macro NEXTW
b32f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b32f			 
b32f			.untilnotdone: 
b32f			 
b32f			 
b32f			;	; get DO ptr 
b32f			; 
b32f				FORTH_RSP_TOS 
b32f cd 09 9b			call macro_forth_rsp_tos 
b332				endm 
# End of macro FORTH_RSP_TOS
b332			 
b332				;push hl 
b332			 
b332				; not going to DO any more 
b332				; get rid of the RSP pointer as DO will add it back in 
b332				;FORTH_RSP_POP 
b332				;pop hl 
b332			 
b332			 
b332 22 c2 e5			ld (os_tok_ptr), hl 
b335					if DEBUG_FORTH_WORDS 
b335						DMARK "UN<" 
b335 f5				push af  
b336 3a 4a b3			ld a, (.dmark)  
b339 32 6b ee			ld (debug_mark),a  
b33c 3a 4b b3			ld a, (.dmark+1)  
b33f 32 6c ee			ld (debug_mark+1),a  
b342 3a 4c b3			ld a, (.dmark+2)  
b345 32 6d ee			ld (debug_mark+2),a  
b348 18 03			jr .pastdmark  
b34a ..			.dmark: db "UN<"  
b34d f1			.pastdmark: pop af  
b34e			endm  
# End of macro DMARK
b34e					CALLMONITOR 
b34e cd 6f ee			call debug_vector  
b351				endm  
# End of macro CALLMONITOR
b351				endif 
b351 c3 89 9f			jp exec1 
b354			 
b354					 
b354			 
b354			 
b354					NEXTW 
b354 c3 f8 9e			jp macro_next 
b357				endm 
# End of macro NEXTW
b357			 
b357			 
b357			.ENDFLOW: 
b357			 
b357			; eof 
b357			 
# End of file forth_words_flow.asm
b357			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b357			include "forth_words_logic.asm" 
b357			 
b357			; | ## Logic Words 
b357			 
b357			.NOT: 
b357				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b357 2d				db WORD_SYS_CORE+25             
b358 9f b3			dw .IS            
b35a 04				db 3 + 1 
b35b .. 00			db "NOT",0              
b35f				endm 
# End of macro CWHEAD
b35f			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b35f					if DEBUG_FORTH_WORDS_KEY 
b35f						DMARK "NOT" 
b35f f5				push af  
b360 3a 74 b3			ld a, (.dmark)  
b363 32 6b ee			ld (debug_mark),a  
b366 3a 75 b3			ld a, (.dmark+1)  
b369 32 6c ee			ld (debug_mark+1),a  
b36c 3a 76 b3			ld a, (.dmark+2)  
b36f 32 6d ee			ld (debug_mark+2),a  
b372 18 03			jr .pastdmark  
b374 ..			.dmark: db "NOT"  
b377 f1			.pastdmark: pop af  
b378			endm  
# End of macro DMARK
b378						CALLMONITOR 
b378 cd 6f ee			call debug_vector  
b37b				endm  
# End of macro CALLMONITOR
b37b					endif 
b37b					FORTH_DSP 
b37b cd 08 9d			call macro_forth_dsp 
b37e				endm 
# End of macro FORTH_DSP
b37e 7e					ld a,(hl)	; get type of value on TOS 
b37f fe 02				cp DS_TYPE_INUM  
b381 28 03				jr z, .noti 
b383					NEXTW 
b383 c3 f8 9e			jp macro_next 
b386				endm 
# End of macro NEXTW
b386			.noti:          FORTH_DSP_VALUEHL 
b386 cd 42 9d			call macro_dsp_valuehl 
b389				endm 
# End of macro FORTH_DSP_VALUEHL
b389			;		push hl 
b389					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b389 cd fa 9d			call macro_forth_dsp_pop 
b38c				endm 
# End of macro FORTH_DSP_POP
b38c			;		pop hl 
b38c 3e 00				ld a,0 
b38e bd					cp l 
b38f 28 04				jr z, .not2t 
b391 2e 00				ld l, 0 
b393 18 02				jr .notip 
b395			 
b395 2e ff		.not2t:		ld l, 255 
b397			 
b397 26 00		.notip:		ld h, 0	 
b399			 
b399 cd 4b 9b				call forth_push_numhl 
b39c					NEXTW 
b39c c3 f8 9e			jp macro_next 
b39f				endm 
# End of macro NEXTW
b39f			 
b39f			.IS: 
b39f				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b39f 2d				db WORD_SYS_CORE+25             
b3a0 c5 b3			dw .LZERO            
b3a2 03				db 2 + 1 
b3a3 .. 00			db "IS",0              
b3a6				endm 
# End of macro CWHEAD
b3a6			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b3a6					if DEBUG_FORTH_WORDS_KEY 
b3a6						DMARK "IS." 
b3a6 f5				push af  
b3a7 3a bb b3			ld a, (.dmark)  
b3aa 32 6b ee			ld (debug_mark),a  
b3ad 3a bc b3			ld a, (.dmark+1)  
b3b0 32 6c ee			ld (debug_mark+1),a  
b3b3 3a bd b3			ld a, (.dmark+2)  
b3b6 32 6d ee			ld (debug_mark+2),a  
b3b9 18 03			jr .pastdmark  
b3bb ..			.dmark: db "IS."  
b3be f1			.pastdmark: pop af  
b3bf			endm  
# End of macro DMARK
b3bf						CALLMONITOR 
b3bf cd 6f ee			call debug_vector  
b3c2				endm  
# End of macro CALLMONITOR
b3c2					endif 
b3c2					NEXTW 
b3c2 c3 f8 9e			jp macro_next 
b3c5				endm 
# End of macro NEXTW
b3c5			.LZERO: 
b3c5				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b3c5 2d				db WORD_SYS_CORE+25             
b3c6 cf b3			dw .TZERO            
b3c8 03				db 2 + 1 
b3c9 .. 00			db "0<",0              
b3cc				endm 
# End of macro CWHEAD
b3cc			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b3cc					NEXTW 
b3cc c3 f8 9e			jp macro_next 
b3cf				endm 
# End of macro NEXTW
b3cf			.TZERO: 
b3cf				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b3cf 2e				db WORD_SYS_CORE+26             
b3d0 16 b4			dw .LESS            
b3d2 03				db 2 + 1 
b3d3 .. 00			db "0=",0              
b3d6				endm 
# End of macro CWHEAD
b3d6			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b3d6				; TODO add floating point number detection 
b3d6					;v5 FORTH_DSP_VALUE 
b3d6					if DEBUG_FORTH_WORDS_KEY 
b3d6						DMARK "0=." 
b3d6 f5				push af  
b3d7 3a eb b3			ld a, (.dmark)  
b3da 32 6b ee			ld (debug_mark),a  
b3dd 3a ec b3			ld a, (.dmark+1)  
b3e0 32 6c ee			ld (debug_mark+1),a  
b3e3 3a ed b3			ld a, (.dmark+2)  
b3e6 32 6d ee			ld (debug_mark+2),a  
b3e9 18 03			jr .pastdmark  
b3eb ..			.dmark: db "0=."  
b3ee f1			.pastdmark: pop af  
b3ef			endm  
# End of macro DMARK
b3ef						CALLMONITOR 
b3ef cd 6f ee			call debug_vector  
b3f2				endm  
# End of macro CALLMONITOR
b3f2					endif 
b3f2					FORTH_DSP 
b3f2 cd 08 9d			call macro_forth_dsp 
b3f5				endm 
# End of macro FORTH_DSP
b3f5 7e					ld a,(hl)	; get type of value on TOS 
b3f6 fe 02				cp DS_TYPE_INUM  
b3f8 28 00				jr z, .tz_inum 
b3fa			 
b3fa				if FORTH_ENABLE_FLOATMATH 
b3fa					jr .tz_done 
b3fa			 
b3fa				endif 
b3fa					 
b3fa			 
b3fa			.tz_inum: 
b3fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3fa cd 42 9d			call macro_dsp_valuehl 
b3fd				endm 
# End of macro FORTH_DSP_VALUEHL
b3fd			 
b3fd			;		push hl 
b3fd			 
b3fd					; destroy value TOS 
b3fd			 
b3fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3fd cd fa 9d			call macro_forth_dsp_pop 
b400				endm 
# End of macro FORTH_DSP_POP
b400			 
b400			;		pop hl 
b400			 
b400 3e 00				ld a,0 
b402			 
b402 bd					cp l 
b403 20 08				jr nz, .tz_notzero 
b405			 
b405 bc					cp h 
b406			 
b406 20 05				jr nz, .tz_notzero 
b408			 
b408			 
b408 21 01 00				ld hl, FORTH_TRUE 
b40b 18 03				jr .tz_done 
b40d			 
b40d 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b410			 
b410					; push value back onto stack for another op etc 
b410			 
b410			.tz_done: 
b410 cd 4b 9b				call forth_push_numhl 
b413			 
b413					NEXTW 
b413 c3 f8 9e			jp macro_next 
b416				endm 
# End of macro NEXTW
b416			.LESS: 
b416				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b416 2f				db WORD_SYS_CORE+27             
b417 7f b4			dw .GT            
b419 02				db 1 + 1 
b41a .. 00			db "<",0              
b41c				endm 
# End of macro CWHEAD
b41c			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b41c				; TODO add floating point number detection 
b41c					if DEBUG_FORTH_WORDS_KEY 
b41c						DMARK "LES" 
b41c f5				push af  
b41d 3a 31 b4			ld a, (.dmark)  
b420 32 6b ee			ld (debug_mark),a  
b423 3a 32 b4			ld a, (.dmark+1)  
b426 32 6c ee			ld (debug_mark+1),a  
b429 3a 33 b4			ld a, (.dmark+2)  
b42c 32 6d ee			ld (debug_mark+2),a  
b42f 18 03			jr .pastdmark  
b431 ..			.dmark: db "LES"  
b434 f1			.pastdmark: pop af  
b435			endm  
# End of macro DMARK
b435						CALLMONITOR 
b435 cd 6f ee			call debug_vector  
b438				endm  
# End of macro CALLMONITOR
b438					endif 
b438					FORTH_DSP 
b438 cd 08 9d			call macro_forth_dsp 
b43b				endm 
# End of macro FORTH_DSP
b43b					;v5 FORTH_DSP_VALUE 
b43b 7e					ld a,(hl)	; get type of value on TOS 
b43c fe 02				cp DS_TYPE_INUM  
b43e 28 00				jr z, .less_inum 
b440			 
b440				if FORTH_ENABLE_FLOATMATH 
b440					jr .less_done 
b440			 
b440				endif 
b440					 
b440			 
b440			.less_inum: 
b440					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b440 cd 42 9d			call macro_dsp_valuehl 
b443				endm 
# End of macro FORTH_DSP_VALUEHL
b443			 
b443 e5					push hl  ; u2 
b444			 
b444					; destroy value TOS 
b444			 
b444					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b444 cd fa 9d			call macro_forth_dsp_pop 
b447				endm 
# End of macro FORTH_DSP_POP
b447			 
b447			 
b447					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b447 cd 42 9d			call macro_dsp_valuehl 
b44a				endm 
# End of macro FORTH_DSP_VALUEHL
b44a			 
b44a e5					push hl    ; u1 
b44b			 
b44b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b44b cd fa 9d			call macro_forth_dsp_pop 
b44e				endm 
# End of macro FORTH_DSP_POP
b44e			 
b44e			 
b44e b7			 or a      ;clear carry flag 
b44f 01 00 00		 ld bc, FORTH_FALSE 
b452 e1			  pop hl    ; u1 
b453 d1			  pop de    ; u2 
b454 ed 52		  sbc hl,de 
b456 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b458			 
b458 01 01 00		 ld bc, FORTH_TRUE 
b45b			.lscont:  
b45b c5					push bc 
b45c e1					pop hl 
b45d			 
b45d					if DEBUG_FORTH_WORDS 
b45d						DMARK "LT1" 
b45d f5				push af  
b45e 3a 72 b4			ld a, (.dmark)  
b461 32 6b ee			ld (debug_mark),a  
b464 3a 73 b4			ld a, (.dmark+1)  
b467 32 6c ee			ld (debug_mark+1),a  
b46a 3a 74 b4			ld a, (.dmark+2)  
b46d 32 6d ee			ld (debug_mark+2),a  
b470 18 03			jr .pastdmark  
b472 ..			.dmark: db "LT1"  
b475 f1			.pastdmark: pop af  
b476			endm  
# End of macro DMARK
b476						CALLMONITOR 
b476 cd 6f ee			call debug_vector  
b479				endm  
# End of macro CALLMONITOR
b479					endif 
b479 cd 4b 9b				call forth_push_numhl 
b47c			 
b47c					NEXTW 
b47c c3 f8 9e			jp macro_next 
b47f				endm 
# End of macro NEXTW
b47f			.GT: 
b47f				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b47f 30				db WORD_SYS_CORE+28             
b480 e8 b4			dw .EQUAL            
b482 02				db 1 + 1 
b483 .. 00			db ">",0              
b485				endm 
# End of macro CWHEAD
b485			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b485				; TODO add floating point number detection 
b485					if DEBUG_FORTH_WORDS_KEY 
b485						DMARK "GRT" 
b485 f5				push af  
b486 3a 9a b4			ld a, (.dmark)  
b489 32 6b ee			ld (debug_mark),a  
b48c 3a 9b b4			ld a, (.dmark+1)  
b48f 32 6c ee			ld (debug_mark+1),a  
b492 3a 9c b4			ld a, (.dmark+2)  
b495 32 6d ee			ld (debug_mark+2),a  
b498 18 03			jr .pastdmark  
b49a ..			.dmark: db "GRT"  
b49d f1			.pastdmark: pop af  
b49e			endm  
# End of macro DMARK
b49e						CALLMONITOR 
b49e cd 6f ee			call debug_vector  
b4a1				endm  
# End of macro CALLMONITOR
b4a1					endif 
b4a1					FORTH_DSP 
b4a1 cd 08 9d			call macro_forth_dsp 
b4a4				endm 
# End of macro FORTH_DSP
b4a4					;FORTH_DSP_VALUE 
b4a4 7e					ld a,(hl)	; get type of value on TOS 
b4a5 fe 02				cp DS_TYPE_INUM  
b4a7 28 00				jr z, .gt_inum 
b4a9			 
b4a9				if FORTH_ENABLE_FLOATMATH 
b4a9					jr .gt_done 
b4a9			 
b4a9				endif 
b4a9					 
b4a9			 
b4a9			.gt_inum: 
b4a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4a9 cd 42 9d			call macro_dsp_valuehl 
b4ac				endm 
# End of macro FORTH_DSP_VALUEHL
b4ac			 
b4ac e5					push hl  ; u2 
b4ad			 
b4ad					; destroy value TOS 
b4ad			 
b4ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4ad cd fa 9d			call macro_forth_dsp_pop 
b4b0				endm 
# End of macro FORTH_DSP_POP
b4b0			 
b4b0			 
b4b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4b0 cd 42 9d			call macro_dsp_valuehl 
b4b3				endm 
# End of macro FORTH_DSP_VALUEHL
b4b3			 
b4b3 e5					push hl    ; u1 
b4b4			 
b4b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4b4 cd fa 9d			call macro_forth_dsp_pop 
b4b7				endm 
# End of macro FORTH_DSP_POP
b4b7			 
b4b7			 
b4b7 b7			 or a      ;clear carry flag 
b4b8 01 00 00		 ld bc, FORTH_FALSE 
b4bb e1			  pop hl    ; u1 
b4bc d1			  pop de    ; u2 
b4bd ed 52		  sbc hl,de 
b4bf 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b4c1			 
b4c1 01 01 00		 ld bc, FORTH_TRUE 
b4c4			.gtcont:  
b4c4 c5					push bc 
b4c5 e1					pop hl 
b4c6			 
b4c6					if DEBUG_FORTH_WORDS 
b4c6						DMARK "GT1" 
b4c6 f5				push af  
b4c7 3a db b4			ld a, (.dmark)  
b4ca 32 6b ee			ld (debug_mark),a  
b4cd 3a dc b4			ld a, (.dmark+1)  
b4d0 32 6c ee			ld (debug_mark+1),a  
b4d3 3a dd b4			ld a, (.dmark+2)  
b4d6 32 6d ee			ld (debug_mark+2),a  
b4d9 18 03			jr .pastdmark  
b4db ..			.dmark: db "GT1"  
b4de f1			.pastdmark: pop af  
b4df			endm  
# End of macro DMARK
b4df						CALLMONITOR 
b4df cd 6f ee			call debug_vector  
b4e2				endm  
# End of macro CALLMONITOR
b4e2					endif 
b4e2 cd 4b 9b				call forth_push_numhl 
b4e5			 
b4e5					NEXTW 
b4e5 c3 f8 9e			jp macro_next 
b4e8				endm 
# End of macro NEXTW
b4e8			.EQUAL: 
b4e8				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4e8 31				db WORD_SYS_CORE+29             
b4e9 53 b5			dw .ENDLOGIC            
b4eb 02				db 1 + 1 
b4ec .. 00			db "=",0              
b4ee				endm 
# End of macro CWHEAD
b4ee			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4ee				; TODO add floating point number detection 
b4ee					if DEBUG_FORTH_WORDS_KEY 
b4ee						DMARK "EQ." 
b4ee f5				push af  
b4ef 3a 03 b5			ld a, (.dmark)  
b4f2 32 6b ee			ld (debug_mark),a  
b4f5 3a 04 b5			ld a, (.dmark+1)  
b4f8 32 6c ee			ld (debug_mark+1),a  
b4fb 3a 05 b5			ld a, (.dmark+2)  
b4fe 32 6d ee			ld (debug_mark+2),a  
b501 18 03			jr .pastdmark  
b503 ..			.dmark: db "EQ."  
b506 f1			.pastdmark: pop af  
b507			endm  
# End of macro DMARK
b507						CALLMONITOR 
b507 cd 6f ee			call debug_vector  
b50a				endm  
# End of macro CALLMONITOR
b50a					endif 
b50a					FORTH_DSP 
b50a cd 08 9d			call macro_forth_dsp 
b50d				endm 
# End of macro FORTH_DSP
b50d					;v5 FORTH_DSP_VALUE 
b50d 7e					ld a,(hl)	; get type of value on TOS 
b50e fe 02				cp DS_TYPE_INUM  
b510 28 00				jr z, .eq_inum 
b512			 
b512				if FORTH_ENABLE_FLOATMATH 
b512					jr .eq_done 
b512			 
b512				endif 
b512					 
b512			 
b512			.eq_inum: 
b512					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b512 cd 42 9d			call macro_dsp_valuehl 
b515				endm 
# End of macro FORTH_DSP_VALUEHL
b515			 
b515 e5					push hl 
b516			 
b516					; destroy value TOS 
b516			 
b516					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b516 cd fa 9d			call macro_forth_dsp_pop 
b519				endm 
# End of macro FORTH_DSP_POP
b519			 
b519			 
b519					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b519 cd 42 9d			call macro_dsp_valuehl 
b51c				endm 
# End of macro FORTH_DSP_VALUEHL
b51c			 
b51c					; one value on hl get other one back 
b51c			 
b51c e5					push hl 
b51d			 
b51d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b51d cd fa 9d			call macro_forth_dsp_pop 
b520				endm 
# End of macro FORTH_DSP_POP
b520			 
b520 0e 00				ld c, FORTH_FALSE 
b522			 
b522 e1					pop hl 
b523 d1					pop de 
b524			 
b524 7b					ld a, e 
b525 bd					cp l 
b526			 
b526 20 06				jr nz, .eq_done 
b528			 
b528 7a					ld a, d 
b529 bc					cp h 
b52a			 
b52a 20 02				jr nz, .eq_done 
b52c			 
b52c 0e 01				ld c, FORTH_TRUE 
b52e					 
b52e			 
b52e			 
b52e			.eq_done: 
b52e			 
b52e					; TODO push value back onto stack for another op etc 
b52e			 
b52e 26 00				ld h, 0 
b530 69					ld l, c 
b531					if DEBUG_FORTH_WORDS 
b531						DMARK "EQ1" 
b531 f5				push af  
b532 3a 46 b5			ld a, (.dmark)  
b535 32 6b ee			ld (debug_mark),a  
b538 3a 47 b5			ld a, (.dmark+1)  
b53b 32 6c ee			ld (debug_mark+1),a  
b53e 3a 48 b5			ld a, (.dmark+2)  
b541 32 6d ee			ld (debug_mark+2),a  
b544 18 03			jr .pastdmark  
b546 ..			.dmark: db "EQ1"  
b549 f1			.pastdmark: pop af  
b54a			endm  
# End of macro DMARK
b54a						CALLMONITOR 
b54a cd 6f ee			call debug_vector  
b54d				endm  
# End of macro CALLMONITOR
b54d					endif 
b54d cd 4b 9b				call forth_push_numhl 
b550			 
b550					NEXTW 
b550 c3 f8 9e			jp macro_next 
b553				endm 
# End of macro NEXTW
b553			 
b553			 
b553			.ENDLOGIC: 
b553			; eof 
b553			 
b553			 
# End of file forth_words_logic.asm
b553			include "forth_words_maths.asm" 
b553			 
b553			; | ## Maths Words 
b553			 
b553			.PLUS:	 
b553				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b553 15				db WORD_SYS_CORE+1             
b554 b1 b5			dw .NEG            
b556 02				db 1 + 1 
b557 .. 00			db "+",0              
b559				endm 
# End of macro CWHEAD
b559			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b559					if DEBUG_FORTH_WORDS_KEY 
b559						DMARK "PLU" 
b559 f5				push af  
b55a 3a 6e b5			ld a, (.dmark)  
b55d 32 6b ee			ld (debug_mark),a  
b560 3a 6f b5			ld a, (.dmark+1)  
b563 32 6c ee			ld (debug_mark+1),a  
b566 3a 70 b5			ld a, (.dmark+2)  
b569 32 6d ee			ld (debug_mark+2),a  
b56c 18 03			jr .pastdmark  
b56e ..			.dmark: db "PLU"  
b571 f1			.pastdmark: pop af  
b572			endm  
# End of macro DMARK
b572						CALLMONITOR 
b572 cd 6f ee			call debug_vector  
b575				endm  
# End of macro CALLMONITOR
b575					endif 
b575					; add top two values and push back result 
b575			 
b575					;for v5 FORTH_DSP_VALUE 
b575					FORTH_DSP 
b575 cd 08 9d			call macro_forth_dsp 
b578				endm 
# End of macro FORTH_DSP
b578 7e					ld a,(hl)	; get type of value on TOS 
b579 fe 02				cp DS_TYPE_INUM  
b57b 28 03				jr z, .dot_inum 
b57d			 
b57d					NEXTW 
b57d c3 f8 9e			jp macro_next 
b580				endm 
# End of macro NEXTW
b580			 
b580			; float maths 
b580			 
b580				if FORTH_ENABLE_FLOATMATH 
b580						inc hl      ; now at start of numeric as string 
b580			 
b580					if DEBUG_FORTH_MATHS 
b580						DMARK "ADD" 
b580				CALLMONITOR 
b580					endif 
b580			 
b580					;ld ix, hl 
b580					call CON 
b580			 
b580			 
b580					push hl 
b580					 
b580					 
b580			 
b580						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b580			 
b580					; get next number 
b580			 
b580						FORTH_DSP_VALUE 
b580			 
b580						inc hl      ; now at start of numeric as string 
b580			 
b580					;ld ix, hl 
b580					call CON 
b580			 
b580					push hl 
b580			 
b580			 
b580						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b580			 
b580						; TODO do add 
b580			 
b580						call IADD 
b580			 
b580						; TODO get result back as ascii 
b580			 
b580						; TODO push result  
b580			 
b580			 
b580			 
b580						jr .dot_done 
b580				endif 
b580			 
b580			.dot_inum: 
b580			 
b580			 
b580					if DEBUG_FORTH_DOT 
b580						DMARK "+IT" 
b580 f5				push af  
b581 3a 95 b5			ld a, (.dmark)  
b584 32 6b ee			ld (debug_mark),a  
b587 3a 96 b5			ld a, (.dmark+1)  
b58a 32 6c ee			ld (debug_mark+1),a  
b58d 3a 97 b5			ld a, (.dmark+2)  
b590 32 6d ee			ld (debug_mark+2),a  
b593 18 03			jr .pastdmark  
b595 ..			.dmark: db "+IT"  
b598 f1			.pastdmark: pop af  
b599			endm  
# End of macro DMARK
b599				CALLMONITOR 
b599 cd 6f ee			call debug_vector  
b59c				endm  
# End of macro CALLMONITOR
b59c					endif 
b59c			 
b59c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b59c cd 42 9d			call macro_dsp_valuehl 
b59f				endm 
# End of macro FORTH_DSP_VALUEHL
b59f			 
b59f				; TODO add floating point number detection 
b59f			 
b59f e5					push hl 
b5a0			 
b5a0					; destroy value TOS 
b5a0			 
b5a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a0 cd fa 9d			call macro_forth_dsp_pop 
b5a3				endm 
# End of macro FORTH_DSP_POP
b5a3			 
b5a3			 
b5a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a3 cd 42 9d			call macro_dsp_valuehl 
b5a6				endm 
# End of macro FORTH_DSP_VALUEHL
b5a6			 
b5a6					; one value on hl get other one back 
b5a6			 
b5a6 d1					pop de 
b5a7			 
b5a7					; do the add 
b5a7			 
b5a7 19					add hl,de 
b5a8			 
b5a8					; save it 
b5a8			 
b5a8			;		push hl	 
b5a8			 
b5a8					; 
b5a8			 
b5a8					; destroy value TOS 
b5a8			 
b5a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a8 cd fa 9d			call macro_forth_dsp_pop 
b5ab				endm 
# End of macro FORTH_DSP_POP
b5ab			 
b5ab					; TODO push value back onto stack for another op etc 
b5ab			 
b5ab			;		pop hl 
b5ab			 
b5ab			.dot_done: 
b5ab cd 4b 9b				call forth_push_numhl 
b5ae			 
b5ae					NEXTW 
b5ae c3 f8 9e			jp macro_next 
b5b1				endm 
# End of macro NEXTW
b5b1			.NEG: 
b5b1			 
b5b1				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b5b1 17				db WORD_SYS_CORE+3             
b5b2 f4 b5			dw .DIV            
b5b4 02				db 1 + 1 
b5b5 .. 00			db "-",0              
b5b7				endm 
# End of macro CWHEAD
b5b7			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b5b7					if DEBUG_FORTH_WORDS_KEY 
b5b7						DMARK "SUB" 
b5b7 f5				push af  
b5b8 3a cc b5			ld a, (.dmark)  
b5bb 32 6b ee			ld (debug_mark),a  
b5be 3a cd b5			ld a, (.dmark+1)  
b5c1 32 6c ee			ld (debug_mark+1),a  
b5c4 3a ce b5			ld a, (.dmark+2)  
b5c7 32 6d ee			ld (debug_mark+2),a  
b5ca 18 03			jr .pastdmark  
b5cc ..			.dmark: db "SUB"  
b5cf f1			.pastdmark: pop af  
b5d0			endm  
# End of macro DMARK
b5d0						CALLMONITOR 
b5d0 cd 6f ee			call debug_vector  
b5d3				endm  
# End of macro CALLMONITOR
b5d3					endif 
b5d3			 
b5d3			 
b5d3				; TODO add floating point number detection 
b5d3					; v5 FORTH_DSP_VALUE 
b5d3					FORTH_DSP 
b5d3 cd 08 9d			call macro_forth_dsp 
b5d6				endm 
# End of macro FORTH_DSP
b5d6 7e					ld a,(hl)	; get type of value on TOS 
b5d7 fe 02				cp DS_TYPE_INUM  
b5d9 28 03				jr z, .neg_inum 
b5db			 
b5db					NEXTW 
b5db c3 f8 9e			jp macro_next 
b5de				endm 
# End of macro NEXTW
b5de			 
b5de			; float maths 
b5de			 
b5de				if FORTH_ENABLE_FLOATMATH 
b5de					jr .neg_done 
b5de			 
b5de				endif 
b5de					 
b5de			 
b5de			.neg_inum: 
b5de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5de cd 42 9d			call macro_dsp_valuehl 
b5e1				endm 
# End of macro FORTH_DSP_VALUEHL
b5e1			 
b5e1 e5					push hl 
b5e2			 
b5e2					; destroy value TOS 
b5e2			 
b5e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e2 cd fa 9d			call macro_forth_dsp_pop 
b5e5				endm 
# End of macro FORTH_DSP_POP
b5e5			 
b5e5			 
b5e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e5 cd 42 9d			call macro_dsp_valuehl 
b5e8				endm 
# End of macro FORTH_DSP_VALUEHL
b5e8			 
b5e8					; one value on hl get other one back 
b5e8			 
b5e8 d1					pop de 
b5e9			 
b5e9					; do the sub 
b5e9			;		ex de, hl 
b5e9			 
b5e9 ed 52				sbc hl,de 
b5eb			 
b5eb					; save it 
b5eb			 
b5eb			;		push hl	 
b5eb			 
b5eb					; 
b5eb			 
b5eb					; destroy value TOS 
b5eb			 
b5eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5eb cd fa 9d			call macro_forth_dsp_pop 
b5ee				endm 
# End of macro FORTH_DSP_POP
b5ee			 
b5ee					; TODO push value back onto stack for another op etc 
b5ee			 
b5ee			;		pop hl 
b5ee			 
b5ee cd 4b 9b				call forth_push_numhl 
b5f1			.neg_done: 
b5f1			 
b5f1					NEXTW 
b5f1 c3 f8 9e			jp macro_next 
b5f4				endm 
# End of macro NEXTW
b5f4			.DIV: 
b5f4				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5f4 18				db WORD_SYS_CORE+4             
b5f5 41 b6			dw .MUL            
b5f7 02				db 1 + 1 
b5f8 .. 00			db "/",0              
b5fa				endm 
# End of macro CWHEAD
b5fa			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5fa					if DEBUG_FORTH_WORDS_KEY 
b5fa						DMARK "DIV" 
b5fa f5				push af  
b5fb 3a 0f b6			ld a, (.dmark)  
b5fe 32 6b ee			ld (debug_mark),a  
b601 3a 10 b6			ld a, (.dmark+1)  
b604 32 6c ee			ld (debug_mark+1),a  
b607 3a 11 b6			ld a, (.dmark+2)  
b60a 32 6d ee			ld (debug_mark+2),a  
b60d 18 03			jr .pastdmark  
b60f ..			.dmark: db "DIV"  
b612 f1			.pastdmark: pop af  
b613			endm  
# End of macro DMARK
b613						CALLMONITOR 
b613 cd 6f ee			call debug_vector  
b616				endm  
# End of macro CALLMONITOR
b616					endif 
b616				; TODO add floating point number detection 
b616					; v5 FORTH_DSP_VALUE 
b616					FORTH_DSP 
b616 cd 08 9d			call macro_forth_dsp 
b619				endm 
# End of macro FORTH_DSP
b619 7e					ld a,(hl)	; get type of value on TOS 
b61a fe 02				cp DS_TYPE_INUM  
b61c 28 03				jr z, .div_inum 
b61e			 
b61e				if FORTH_ENABLE_FLOATMATH 
b61e					jr .div_done 
b61e			 
b61e				endif 
b61e					NEXTW 
b61e c3 f8 9e			jp macro_next 
b621				endm 
# End of macro NEXTW
b621			.div_inum: 
b621			 
b621					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b621 cd 42 9d			call macro_dsp_valuehl 
b624				endm 
# End of macro FORTH_DSP_VALUEHL
b624			 
b624 e5					push hl    ; to go to bc 
b625			 
b625					; destroy value TOS 
b625			 
b625					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b625 cd fa 9d			call macro_forth_dsp_pop 
b628				endm 
# End of macro FORTH_DSP_POP
b628			 
b628			 
b628					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b628 cd 42 9d			call macro_dsp_valuehl 
b62b				endm 
# End of macro FORTH_DSP_VALUEHL
b62b			 
b62b					; hl to go to de 
b62b			 
b62b e5					push hl 
b62c			 
b62c c1					pop bc 
b62d d1					pop de		 
b62e			 
b62e			 
b62e					if DEBUG_FORTH_MATHS 
b62e						DMARK "DIV" 
b62e				CALLMONITOR 
b62e					endif 
b62e					; one value on hl but move to a get other one back 
b62e			 
b62e			        
b62e cd 39 8c			call Div16 
b631			 
b631			;	push af	 
b631 e5				push hl 
b632 c5				push bc 
b633			 
b633					if DEBUG_FORTH_MATHS 
b633						DMARK "DI1" 
b633				CALLMONITOR 
b633					endif 
b633			 
b633					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b633 cd fa 9d			call macro_forth_dsp_pop 
b636				endm 
# End of macro FORTH_DSP_POP
b636			 
b636			 
b636			 
b636 e1					pop hl    ; result 
b637			 
b637 cd 4b 9b				call forth_push_numhl 
b63a			 
b63a e1					pop hl    ; reminder 
b63b			;		ld h,0 
b63b			;		ld l,d 
b63b			 
b63b cd 4b 9b				call forth_push_numhl 
b63e			.div_done: 
b63e					NEXTW 
b63e c3 f8 9e			jp macro_next 
b641				endm 
# End of macro NEXTW
b641			.MUL: 
b641				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b641 19				db WORD_SYS_CORE+5             
b642 86 b6			dw .MIN            
b644 02				db 1 + 1 
b645 .. 00			db "*",0              
b647				endm 
# End of macro CWHEAD
b647			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b647				; TODO add floating point number detection 
b647					if DEBUG_FORTH_WORDS_KEY 
b647						DMARK "MUL" 
b647 f5				push af  
b648 3a 5c b6			ld a, (.dmark)  
b64b 32 6b ee			ld (debug_mark),a  
b64e 3a 5d b6			ld a, (.dmark+1)  
b651 32 6c ee			ld (debug_mark+1),a  
b654 3a 5e b6			ld a, (.dmark+2)  
b657 32 6d ee			ld (debug_mark+2),a  
b65a 18 03			jr .pastdmark  
b65c ..			.dmark: db "MUL"  
b65f f1			.pastdmark: pop af  
b660			endm  
# End of macro DMARK
b660						CALLMONITOR 
b660 cd 6f ee			call debug_vector  
b663				endm  
# End of macro CALLMONITOR
b663					endif 
b663					FORTH_DSP 
b663 cd 08 9d			call macro_forth_dsp 
b666				endm 
# End of macro FORTH_DSP
b666					; v5 FORTH_DSP_VALUE 
b666 7e					ld a,(hl)	; get type of value on TOS 
b667 fe 02				cp DS_TYPE_INUM  
b669 28 03				jr z, .mul_inum 
b66b			 
b66b				if FORTH_ENABLE_FLOATMATH 
b66b					jr .mul_done 
b66b			 
b66b				endif 
b66b			 
b66b					NEXTW 
b66b c3 f8 9e			jp macro_next 
b66e				endm 
# End of macro NEXTW
b66e			.mul_inum:	 
b66e			 
b66e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b66e cd 42 9d			call macro_dsp_valuehl 
b671				endm 
# End of macro FORTH_DSP_VALUEHL
b671			 
b671 e5					push hl 
b672			 
b672					; destroy value TOS 
b672			 
b672					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b672 cd fa 9d			call macro_forth_dsp_pop 
b675				endm 
# End of macro FORTH_DSP_POP
b675			 
b675			 
b675					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b675 cd 42 9d			call macro_dsp_valuehl 
b678				endm 
# End of macro FORTH_DSP_VALUEHL
b678			 
b678					; one value on hl but move to a get other one back 
b678			 
b678 7d					ld a, l 
b679			 
b679 d1					pop de 
b67a			 
b67a					; do the mull 
b67a			;		ex de, hl 
b67a			 
b67a cd 5f 8c				call Mult16 
b67d					; save it 
b67d			 
b67d			;		push hl	 
b67d			 
b67d					; 
b67d			 
b67d					; destroy value TOS 
b67d			 
b67d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b67d cd fa 9d			call macro_forth_dsp_pop 
b680				endm 
# End of macro FORTH_DSP_POP
b680			 
b680					; TODO push value back onto stack for another op etc 
b680			 
b680			;		pop hl 
b680			 
b680 cd 4b 9b				call forth_push_numhl 
b683			 
b683			.mul_done: 
b683					NEXTW 
b683 c3 f8 9e			jp macro_next 
b686				endm 
# End of macro NEXTW
b686			 
b686			 
b686			 
b686			 
b686			.MIN: 
b686				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b686 49				db WORD_SYS_CORE+53             
b687 07 b7			dw .MAX            
b689 04				db 3 + 1 
b68a .. 00			db "MIN",0              
b68e				endm 
# End of macro CWHEAD
b68e			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b68e					if DEBUG_FORTH_WORDS_KEY 
b68e						DMARK "MIN" 
b68e f5				push af  
b68f 3a a3 b6			ld a, (.dmark)  
b692 32 6b ee			ld (debug_mark),a  
b695 3a a4 b6			ld a, (.dmark+1)  
b698 32 6c ee			ld (debug_mark+1),a  
b69b 3a a5 b6			ld a, (.dmark+2)  
b69e 32 6d ee			ld (debug_mark+2),a  
b6a1 18 03			jr .pastdmark  
b6a3 ..			.dmark: db "MIN"  
b6a6 f1			.pastdmark: pop af  
b6a7			endm  
# End of macro DMARK
b6a7						CALLMONITOR 
b6a7 cd 6f ee			call debug_vector  
b6aa				endm  
# End of macro CALLMONITOR
b6aa					endif 
b6aa					; get u2 
b6aa			 
b6aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6aa cd 42 9d			call macro_dsp_valuehl 
b6ad				endm 
# End of macro FORTH_DSP_VALUEHL
b6ad			 
b6ad e5					push hl   ; u2 
b6ae			 
b6ae					; destroy value TOS 
b6ae			 
b6ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6ae cd fa 9d			call macro_forth_dsp_pop 
b6b1				endm 
# End of macro FORTH_DSP_POP
b6b1			 
b6b1					; get u1 
b6b1			 
b6b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6b1 cd 42 9d			call macro_dsp_valuehl 
b6b4				endm 
# End of macro FORTH_DSP_VALUEHL
b6b4			 
b6b4 e5					push hl  ; u1 
b6b5			 
b6b5					; destroy value TOS 
b6b5			 
b6b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6b5 cd fa 9d			call macro_forth_dsp_pop 
b6b8				endm 
# End of macro FORTH_DSP_POP
b6b8			 
b6b8 b7			 or a      ;clear carry flag 
b6b9 e1			  pop hl    ; u1 
b6ba d1			  pop de    ; u2 
b6bb e5				push hl   ; saved in case hl is lowest 
b6bc ed 52		  sbc hl,de 
b6be 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b6c0			 
b6c0 e1				pop hl 
b6c1					if DEBUG_FORTH_WORDS 
b6c1						DMARK "MIN" 
b6c1 f5				push af  
b6c2 3a d6 b6			ld a, (.dmark)  
b6c5 32 6b ee			ld (debug_mark),a  
b6c8 3a d7 b6			ld a, (.dmark+1)  
b6cb 32 6c ee			ld (debug_mark+1),a  
b6ce 3a d8 b6			ld a, (.dmark+2)  
b6d1 32 6d ee			ld (debug_mark+2),a  
b6d4 18 03			jr .pastdmark  
b6d6 ..			.dmark: db "MIN"  
b6d9 f1			.pastdmark: pop af  
b6da			endm  
# End of macro DMARK
b6da						CALLMONITOR 
b6da cd 6f ee			call debug_vector  
b6dd				endm  
# End of macro CALLMONITOR
b6dd					endif 
b6dd cd 4b 9b				call forth_push_numhl 
b6e0			 
b6e0				       NEXTW 
b6e0 c3 f8 9e			jp macro_next 
b6e3				endm 
# End of macro NEXTW
b6e3			 
b6e3			.mincont:  
b6e3 c1				pop bc   ; tidy up 
b6e4 eb				ex de , hl  
b6e5					if DEBUG_FORTH_WORDS 
b6e5						DMARK "MI1" 
b6e5 f5				push af  
b6e6 3a fa b6			ld a, (.dmark)  
b6e9 32 6b ee			ld (debug_mark),a  
b6ec 3a fb b6			ld a, (.dmark+1)  
b6ef 32 6c ee			ld (debug_mark+1),a  
b6f2 3a fc b6			ld a, (.dmark+2)  
b6f5 32 6d ee			ld (debug_mark+2),a  
b6f8 18 03			jr .pastdmark  
b6fa ..			.dmark: db "MI1"  
b6fd f1			.pastdmark: pop af  
b6fe			endm  
# End of macro DMARK
b6fe						CALLMONITOR 
b6fe cd 6f ee			call debug_vector  
b701				endm  
# End of macro CALLMONITOR
b701					endif 
b701 cd 4b 9b				call forth_push_numhl 
b704			 
b704				       NEXTW 
b704 c3 f8 9e			jp macro_next 
b707				endm 
# End of macro NEXTW
b707			.MAX: 
b707				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b707 4a				db WORD_SYS_CORE+54             
b708 88 b7			dw .RND16            
b70a 04				db 3 + 1 
b70b .. 00			db "MAX",0              
b70f				endm 
# End of macro CWHEAD
b70f			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b70f					if DEBUG_FORTH_WORDS_KEY 
b70f						DMARK "MAX" 
b70f f5				push af  
b710 3a 24 b7			ld a, (.dmark)  
b713 32 6b ee			ld (debug_mark),a  
b716 3a 25 b7			ld a, (.dmark+1)  
b719 32 6c ee			ld (debug_mark+1),a  
b71c 3a 26 b7			ld a, (.dmark+2)  
b71f 32 6d ee			ld (debug_mark+2),a  
b722 18 03			jr .pastdmark  
b724 ..			.dmark: db "MAX"  
b727 f1			.pastdmark: pop af  
b728			endm  
# End of macro DMARK
b728						CALLMONITOR 
b728 cd 6f ee			call debug_vector  
b72b				endm  
# End of macro CALLMONITOR
b72b					endif 
b72b					; get u2 
b72b			 
b72b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b72b cd 42 9d			call macro_dsp_valuehl 
b72e				endm 
# End of macro FORTH_DSP_VALUEHL
b72e			 
b72e e5					push hl   ; u2 
b72f			 
b72f					; destroy value TOS 
b72f			 
b72f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b72f cd fa 9d			call macro_forth_dsp_pop 
b732				endm 
# End of macro FORTH_DSP_POP
b732			 
b732					; get u1 
b732			 
b732					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b732 cd 42 9d			call macro_dsp_valuehl 
b735				endm 
# End of macro FORTH_DSP_VALUEHL
b735			 
b735 e5					push hl  ; u1 
b736			 
b736					; destroy value TOS 
b736			 
b736					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b736 cd fa 9d			call macro_forth_dsp_pop 
b739				endm 
# End of macro FORTH_DSP_POP
b739			 
b739 b7			 or a      ;clear carry flag 
b73a e1			  pop hl    ; u1 
b73b d1			  pop de    ; u2 
b73c e5				push hl   ; saved in case hl is lowest 
b73d ed 52		  sbc hl,de 
b73f 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b741			 
b741 e1				pop hl 
b742					if DEBUG_FORTH_WORDS 
b742						DMARK "MAX" 
b742 f5				push af  
b743 3a 57 b7			ld a, (.dmark)  
b746 32 6b ee			ld (debug_mark),a  
b749 3a 58 b7			ld a, (.dmark+1)  
b74c 32 6c ee			ld (debug_mark+1),a  
b74f 3a 59 b7			ld a, (.dmark+2)  
b752 32 6d ee			ld (debug_mark+2),a  
b755 18 03			jr .pastdmark  
b757 ..			.dmark: db "MAX"  
b75a f1			.pastdmark: pop af  
b75b			endm  
# End of macro DMARK
b75b						CALLMONITOR 
b75b cd 6f ee			call debug_vector  
b75e				endm  
# End of macro CALLMONITOR
b75e					endif 
b75e cd 4b 9b				call forth_push_numhl 
b761			 
b761				       NEXTW 
b761 c3 f8 9e			jp macro_next 
b764				endm 
# End of macro NEXTW
b764			 
b764			.maxcont:  
b764 c1				pop bc   ; tidy up 
b765 eb				ex de , hl  
b766					if DEBUG_FORTH_WORDS 
b766						DMARK "MA1" 
b766 f5				push af  
b767 3a 7b b7			ld a, (.dmark)  
b76a 32 6b ee			ld (debug_mark),a  
b76d 3a 7c b7			ld a, (.dmark+1)  
b770 32 6c ee			ld (debug_mark+1),a  
b773 3a 7d b7			ld a, (.dmark+2)  
b776 32 6d ee			ld (debug_mark+2),a  
b779 18 03			jr .pastdmark  
b77b ..			.dmark: db "MA1"  
b77e f1			.pastdmark: pop af  
b77f			endm  
# End of macro DMARK
b77f						CALLMONITOR 
b77f cd 6f ee			call debug_vector  
b782				endm  
# End of macro CALLMONITOR
b782					endif 
b782 cd 4b 9b				call forth_push_numhl 
b785				       NEXTW 
b785 c3 f8 9e			jp macro_next 
b788				endm 
# End of macro NEXTW
b788			 
b788			.RND16: 
b788				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b788 4e				db WORD_SYS_CORE+58             
b789 b7 b7			dw .RND8            
b78b 06				db 5 + 1 
b78c .. 00			db "RND16",0              
b792				endm 
# End of macro CWHEAD
b792			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b792					if DEBUG_FORTH_WORDS_KEY 
b792						DMARK "R16" 
b792 f5				push af  
b793 3a a7 b7			ld a, (.dmark)  
b796 32 6b ee			ld (debug_mark),a  
b799 3a a8 b7			ld a, (.dmark+1)  
b79c 32 6c ee			ld (debug_mark+1),a  
b79f 3a a9 b7			ld a, (.dmark+2)  
b7a2 32 6d ee			ld (debug_mark+2),a  
b7a5 18 03			jr .pastdmark  
b7a7 ..			.dmark: db "R16"  
b7aa f1			.pastdmark: pop af  
b7ab			endm  
# End of macro DMARK
b7ab						CALLMONITOR 
b7ab cd 6f ee			call debug_vector  
b7ae				endm  
# End of macro CALLMONITOR
b7ae					endif 
b7ae cd 03 8c				call prng16  
b7b1 cd 4b 9b				call forth_push_numhl 
b7b4				       NEXTW 
b7b4 c3 f8 9e			jp macro_next 
b7b7				endm 
# End of macro NEXTW
b7b7			.RND8: 
b7b7				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b7b7 60				db WORD_SYS_CORE+76             
b7b8 ec b7			dw .RND            
b7ba 05				db 4 + 1 
b7bb .. 00			db "RND8",0              
b7c0				endm 
# End of macro CWHEAD
b7c0			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b7c0					if DEBUG_FORTH_WORDS_KEY 
b7c0						DMARK "RN8" 
b7c0 f5				push af  
b7c1 3a d5 b7			ld a, (.dmark)  
b7c4 32 6b ee			ld (debug_mark),a  
b7c7 3a d6 b7			ld a, (.dmark+1)  
b7ca 32 6c ee			ld (debug_mark+1),a  
b7cd 3a d7 b7			ld a, (.dmark+2)  
b7d0 32 6d ee			ld (debug_mark+2),a  
b7d3 18 03			jr .pastdmark  
b7d5 ..			.dmark: db "RN8"  
b7d8 f1			.pastdmark: pop af  
b7d9			endm  
# End of macro DMARK
b7d9						CALLMONITOR 
b7d9 cd 6f ee			call debug_vector  
b7dc				endm  
# End of macro CALLMONITOR
b7dc					endif 
b7dc 2a a9 eb				ld hl,(xrandc) 
b7df 23					inc hl 
b7e0 cd 1d 8c				call xrnd 
b7e3 6f					ld l,a	 
b7e4 26 00				ld h,0 
b7e6 cd 4b 9b				call forth_push_numhl 
b7e9				       NEXTW 
b7e9 c3 f8 9e			jp macro_next 
b7ec				endm 
# End of macro NEXTW
b7ec			.RND: 
b7ec				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7ec 60				db WORD_SYS_CORE+76             
b7ed f2 b8			dw .ENDMATHS            
b7ef 04				db 3 + 1 
b7f0 .. 00			db "RND",0              
b7f4				endm 
# End of macro CWHEAD
b7f4			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7f4			 
b7f4					if DEBUG_FORTH_WORDS_KEY 
b7f4						DMARK "RND" 
b7f4 f5				push af  
b7f5 3a 09 b8			ld a, (.dmark)  
b7f8 32 6b ee			ld (debug_mark),a  
b7fb 3a 0a b8			ld a, (.dmark+1)  
b7fe 32 6c ee			ld (debug_mark+1),a  
b801 3a 0b b8			ld a, (.dmark+2)  
b804 32 6d ee			ld (debug_mark+2),a  
b807 18 03			jr .pastdmark  
b809 ..			.dmark: db "RND"  
b80c f1			.pastdmark: pop af  
b80d			endm  
# End of macro DMARK
b80d						CALLMONITOR 
b80d cd 6f ee			call debug_vector  
b810				endm  
# End of macro CALLMONITOR
b810					endif 
b810					 
b810					FORTH_DSP_VALUEHL    ; upper range 
b810 cd 42 9d			call macro_dsp_valuehl 
b813				endm 
# End of macro FORTH_DSP_VALUEHL
b813			 
b813 22 ad eb				ld (LFSRSeed), hl	 
b816			 
b816					if DEBUG_FORTH_WORDS 
b816						DMARK "RN1" 
b816 f5				push af  
b817 3a 2b b8			ld a, (.dmark)  
b81a 32 6b ee			ld (debug_mark),a  
b81d 3a 2c b8			ld a, (.dmark+1)  
b820 32 6c ee			ld (debug_mark+1),a  
b823 3a 2d b8			ld a, (.dmark+2)  
b826 32 6d ee			ld (debug_mark+2),a  
b829 18 03			jr .pastdmark  
b82b ..			.dmark: db "RN1"  
b82e f1			.pastdmark: pop af  
b82f			endm  
# End of macro DMARK
b82f						CALLMONITOR 
b82f cd 6f ee			call debug_vector  
b832				endm  
# End of macro CALLMONITOR
b832					endif 
b832					FORTH_DSP_POP 
b832 cd fa 9d			call macro_forth_dsp_pop 
b835				endm 
# End of macro FORTH_DSP_POP
b835			 
b835					FORTH_DSP_VALUEHL    ; low range 
b835 cd 42 9d			call macro_dsp_valuehl 
b838				endm 
# End of macro FORTH_DSP_VALUEHL
b838			 
b838					if DEBUG_FORTH_WORDS 
b838						DMARK "RN2" 
b838 f5				push af  
b839 3a 4d b8			ld a, (.dmark)  
b83c 32 6b ee			ld (debug_mark),a  
b83f 3a 4e b8			ld a, (.dmark+1)  
b842 32 6c ee			ld (debug_mark+1),a  
b845 3a 4f b8			ld a, (.dmark+2)  
b848 32 6d ee			ld (debug_mark+2),a  
b84b 18 03			jr .pastdmark  
b84d ..			.dmark: db "RN2"  
b850 f1			.pastdmark: pop af  
b851			endm  
# End of macro DMARK
b851						CALLMONITOR 
b851 cd 6f ee			call debug_vector  
b854				endm  
# End of macro CALLMONITOR
b854					endif 
b854 22 af eb				ld (LFSRSeed+2), hl 
b857			 
b857					FORTH_DSP_POP 
b857 cd fa 9d			call macro_forth_dsp_pop 
b85a				endm 
# End of macro FORTH_DSP_POP
b85a			 
b85a e5					push hl 
b85b			 
b85b e1			.inrange:	pop hl 
b85c cd 03 8c				call prng16  
b85f					if DEBUG_FORTH_WORDS 
b85f						DMARK "RN3" 
b85f f5				push af  
b860 3a 74 b8			ld a, (.dmark)  
b863 32 6b ee			ld (debug_mark),a  
b866 3a 75 b8			ld a, (.dmark+1)  
b869 32 6c ee			ld (debug_mark+1),a  
b86c 3a 76 b8			ld a, (.dmark+2)  
b86f 32 6d ee			ld (debug_mark+2),a  
b872 18 03			jr .pastdmark  
b874 ..			.dmark: db "RN3"  
b877 f1			.pastdmark: pop af  
b878			endm  
# End of macro DMARK
b878						CALLMONITOR 
b878 cd 6f ee			call debug_vector  
b87b				endm  
# End of macro CALLMONITOR
b87b					endif 
b87b					 
b87b					; if the range is 8bit knock out the high byte 
b87b			 
b87b ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b87f			 
b87f 3e 00				ld a, 0 
b881 ba					cp d  
b882 20 1e				jr nz, .hirange 
b884 26 00				ld h, 0   ; knock it down to 8bit 
b886			 
b886					if DEBUG_FORTH_WORDS 
b886						DMARK "RNk" 
b886 f5				push af  
b887 3a 9b b8			ld a, (.dmark)  
b88a 32 6b ee			ld (debug_mark),a  
b88d 3a 9c b8			ld a, (.dmark+1)  
b890 32 6c ee			ld (debug_mark+1),a  
b893 3a 9d b8			ld a, (.dmark+2)  
b896 32 6d ee			ld (debug_mark+2),a  
b899 18 03			jr .pastdmark  
b89b ..			.dmark: db "RNk"  
b89e f1			.pastdmark: pop af  
b89f			endm  
# End of macro DMARK
b89f						CALLMONITOR 
b89f cd 6f ee			call debug_vector  
b8a2				endm  
# End of macro CALLMONITOR
b8a2					endif 
b8a2			.hirange:   
b8a2 e5					push hl  
b8a3 b7					or a  
b8a4 ed 52		                sbc hl, de 
b8a6			 
b8a6					;call cmp16 
b8a6			 
b8a6 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b8a8 e1					pop hl 
b8a9 e5					push hl 
b8aa			 
b8aa					if DEBUG_FORTH_WORDS 
b8aa						DMARK "RN4" 
b8aa f5				push af  
b8ab 3a bf b8			ld a, (.dmark)  
b8ae 32 6b ee			ld (debug_mark),a  
b8b1 3a c0 b8			ld a, (.dmark+1)  
b8b4 32 6c ee			ld (debug_mark+1),a  
b8b7 3a c1 b8			ld a, (.dmark+2)  
b8ba 32 6d ee			ld (debug_mark+2),a  
b8bd 18 03			jr .pastdmark  
b8bf ..			.dmark: db "RN4"  
b8c2 f1			.pastdmark: pop af  
b8c3			endm  
# End of macro DMARK
b8c3						CALLMONITOR 
b8c3 cd 6f ee			call debug_vector  
b8c6				endm  
# End of macro CALLMONITOR
b8c6					endif 
b8c6 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b8ca					;call cmp16 
b8ca				 
b8ca b7					or a  
b8cb ed 52		                sbc hl, de 
b8cd 38 8c				jr c, .inrange 
b8cf			 
b8cf e1					pop hl 
b8d0					 
b8d0					if DEBUG_FORTH_WORDS 
b8d0						DMARK "RNd" 
b8d0 f5				push af  
b8d1 3a e5 b8			ld a, (.dmark)  
b8d4 32 6b ee			ld (debug_mark),a  
b8d7 3a e6 b8			ld a, (.dmark+1)  
b8da 32 6c ee			ld (debug_mark+1),a  
b8dd 3a e7 b8			ld a, (.dmark+2)  
b8e0 32 6d ee			ld (debug_mark+2),a  
b8e3 18 03			jr .pastdmark  
b8e5 ..			.dmark: db "RNd"  
b8e8 f1			.pastdmark: pop af  
b8e9			endm  
# End of macro DMARK
b8e9						CALLMONITOR 
b8e9 cd 6f ee			call debug_vector  
b8ec				endm  
# End of macro CALLMONITOR
b8ec					endif 
b8ec			 
b8ec			 
b8ec cd 4b 9b				call forth_push_numhl 
b8ef				       NEXTW 
b8ef c3 f8 9e			jp macro_next 
b8f2				endm 
# End of macro NEXTW
b8f2			 
b8f2			.ENDMATHS: 
b8f2			 
b8f2			; eof 
b8f2			 
# End of file forth_words_maths.asm
b8f2			include "forth_words_display.asm" 
b8f2			 
b8f2			; | ## Display Words 
b8f2			 
b8f2			.ACT: 
b8f2			 
b8f2				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b8f2 62				db WORD_SYS_CORE+78             
b8f3 3e b9			dw .INFO            
b8f5 07				db 6 + 1 
b8f6 .. 00			db "ACTIVE",0              
b8fd				endm 
# End of macro CWHEAD
b8fd			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b8fd			;  
b8fd			; | | e.g. $ff $00 do active . $01 pause loop 
b8fd			 
b8fd					if DEBUG_FORTH_WORDS_KEY 
b8fd						DMARK "ACT" 
b8fd f5				push af  
b8fe 3a 12 b9			ld a, (.dmark)  
b901 32 6b ee			ld (debug_mark),a  
b904 3a 13 b9			ld a, (.dmark+1)  
b907 32 6c ee			ld (debug_mark+1),a  
b90a 3a 14 b9			ld a, (.dmark+2)  
b90d 32 6d ee			ld (debug_mark+2),a  
b910 18 03			jr .pastdmark  
b912 ..			.dmark: db "ACT"  
b915 f1			.pastdmark: pop af  
b916			endm  
# End of macro DMARK
b916						CALLMONITOR 
b916 cd 6f ee			call debug_vector  
b919				endm  
# End of macro CALLMONITOR
b919					endif 
b919 cd 06 8a				call active 
b91c					if DEBUG_FORTH_WORDS 
b91c						DMARK "ACp" 
b91c f5				push af  
b91d 3a 31 b9			ld a, (.dmark)  
b920 32 6b ee			ld (debug_mark),a  
b923 3a 32 b9			ld a, (.dmark+1)  
b926 32 6c ee			ld (debug_mark+1),a  
b929 3a 33 b9			ld a, (.dmark+2)  
b92c 32 6d ee			ld (debug_mark+2),a  
b92f 18 03			jr .pastdmark  
b931 ..			.dmark: db "ACp"  
b934 f1			.pastdmark: pop af  
b935			endm  
# End of macro DMARK
b935						CALLMONITOR 
b935 cd 6f ee			call debug_vector  
b938				endm  
# End of macro CALLMONITOR
b938					endif 
b938 cd b9 9b				call forth_push_str 
b93b			 
b93b					NEXTW 
b93b c3 f8 9e			jp macro_next 
b93e				endm 
# End of macro NEXTW
b93e			.INFO: 
b93e			 
b93e				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b93e 62				db WORD_SYS_CORE+78             
b93f 5b b9			dw .ATP            
b941 05				db 4 + 1 
b942 .. 00			db "INFO",0              
b947				endm 
# End of macro CWHEAD
b947			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b947					FORTH_DSP_VALUEHL 
b947 cd 42 9d			call macro_dsp_valuehl 
b94a				endm 
# End of macro FORTH_DSP_VALUEHL
b94a			 
b94a					FORTH_DSP_POP 
b94a cd fa 9d			call macro_forth_dsp_pop 
b94d				endm 
# End of macro FORTH_DSP_POP
b94d			 
b94d e5					push hl 
b94e			 
b94e					FORTH_DSP_VALUEHL 
b94e cd 42 9d			call macro_dsp_valuehl 
b951				endm 
# End of macro FORTH_DSP_VALUEHL
b951			 
b951					FORTH_DSP_POP 
b951 cd fa 9d			call macro_forth_dsp_pop 
b954				endm 
# End of macro FORTH_DSP_POP
b954			 
b954 d1					pop de 
b955			 
b955 cd 40 8a				call info_panel 
b958			 
b958			 
b958					NEXTW 
b958 c3 f8 9e			jp macro_next 
b95b				endm 
# End of macro NEXTW
b95b			.ATP: 
b95b				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b95b 62				db WORD_SYS_CORE+78             
b95c d2 b9			dw .FB            
b95e 04				db 3 + 1 
b95f .. 00			db "AT?",0              
b963				endm 
# End of macro CWHEAD
b963			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b963					if DEBUG_FORTH_WORDS_KEY 
b963						DMARK "AT?" 
b963 f5				push af  
b964 3a 78 b9			ld a, (.dmark)  
b967 32 6b ee			ld (debug_mark),a  
b96a 3a 79 b9			ld a, (.dmark+1)  
b96d 32 6c ee			ld (debug_mark+1),a  
b970 3a 7a b9			ld a, (.dmark+2)  
b973 32 6d ee			ld (debug_mark+2),a  
b976 18 03			jr .pastdmark  
b978 ..			.dmark: db "AT?"  
b97b f1			.pastdmark: pop af  
b97c			endm  
# End of macro DMARK
b97c						CALLMONITOR 
b97c cd 6f ee			call debug_vector  
b97f				endm  
# End of macro CALLMONITOR
b97f					endif 
b97f 3a 5e ea				ld a, (f_cursor_ptr) 
b982			 
b982			if DEBUG_FORTH_WORDS 
b982				DMARK "AT?" 
b982 f5				push af  
b983 3a 97 b9			ld a, (.dmark)  
b986 32 6b ee			ld (debug_mark),a  
b989 3a 98 b9			ld a, (.dmark+1)  
b98c 32 6c ee			ld (debug_mark+1),a  
b98f 3a 99 b9			ld a, (.dmark+2)  
b992 32 6d ee			ld (debug_mark+2),a  
b995 18 03			jr .pastdmark  
b997 ..			.dmark: db "AT?"  
b99a f1			.pastdmark: pop af  
b99b			endm  
# End of macro DMARK
b99b				CALLMONITOR 
b99b cd 6f ee			call debug_vector  
b99e				endm  
# End of macro CALLMONITOR
b99e			endif	 
b99e					; count the number of rows 
b99e			 
b99e 06 00				ld b, 0 
b9a0 4f			.atpr:		ld c, a    ; save in case we go below zero 
b9a1 d6 28				sub display_cols 
b9a3 f2 a9 b9				jp p, .atprunder 
b9a6 04					inc b 
b9a7 18 f7				jr .atpr 
b9a9			.atprunder:	 
b9a9			if DEBUG_FORTH_WORDS 
b9a9				DMARK "A?2" 
b9a9 f5				push af  
b9aa 3a be b9			ld a, (.dmark)  
b9ad 32 6b ee			ld (debug_mark),a  
b9b0 3a bf b9			ld a, (.dmark+1)  
b9b3 32 6c ee			ld (debug_mark+1),a  
b9b6 3a c0 b9			ld a, (.dmark+2)  
b9b9 32 6d ee			ld (debug_mark+2),a  
b9bc 18 03			jr .pastdmark  
b9be ..			.dmark: db "A?2"  
b9c1 f1			.pastdmark: pop af  
b9c2			endm  
# End of macro DMARK
b9c2				CALLMONITOR 
b9c2 cd 6f ee			call debug_vector  
b9c5				endm  
# End of macro CALLMONITOR
b9c5			endif	 
b9c5 26 00				ld h, 0 
b9c7 69					ld l, c 
b9c8 cd 4b 9b				call forth_push_numhl 
b9cb 68					ld l, b  
b9cc cd 4b 9b				call forth_push_numhl 
b9cf			 
b9cf			 
b9cf				NEXTW 
b9cf c3 f8 9e			jp macro_next 
b9d2				endm 
# End of macro NEXTW
b9d2			 
b9d2			.FB: 
b9d2				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b9d2 1b				db WORD_SYS_CORE+7             
b9d3 20 ba			dw .EMIT            
b9d5 03				db 2 + 1 
b9d6 .. 00			db "FB",0              
b9d9				endm 
# End of macro CWHEAD
b9d9			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b9d9			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b9d9			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b9d9			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b9d9					if DEBUG_FORTH_WORDS_KEY 
b9d9						DMARK "FB." 
b9d9 f5				push af  
b9da 3a ee b9			ld a, (.dmark)  
b9dd 32 6b ee			ld (debug_mark),a  
b9e0 3a ef b9			ld a, (.dmark+1)  
b9e3 32 6c ee			ld (debug_mark+1),a  
b9e6 3a f0 b9			ld a, (.dmark+2)  
b9e9 32 6d ee			ld (debug_mark+2),a  
b9ec 18 03			jr .pastdmark  
b9ee ..			.dmark: db "FB."  
b9f1 f1			.pastdmark: pop af  
b9f2			endm  
# End of macro DMARK
b9f2						CALLMONITOR 
b9f2 cd 6f ee			call debug_vector  
b9f5				endm  
# End of macro CALLMONITOR
b9f5					endif 
b9f5			 
b9f5					FORTH_DSP_VALUEHL 
b9f5 cd 42 9d			call macro_dsp_valuehl 
b9f8				endm 
# End of macro FORTH_DSP_VALUEHL
b9f8			 
b9f8 7d					ld a, l 
b9f9 fe 01				cp 1 
b9fb 20 05				jr nz, .fbn1 
b9fd 21 10 ed				ld hl, display_fb1 
ba00 18 15				jr .fbset 
ba02 fe 02		.fbn1:		cp 2 
ba04 20 05				jr nz, .fbn2 
ba06 21 ce eb				ld hl, display_fb2 
ba09 18 0c				jr .fbset 
ba0b fe 03		.fbn2:		cp 3 
ba0d 20 05				jr nz, .fbn3 
ba0f 21 6f ec				ld hl, display_fb3 
ba12 18 03				jr .fbset 
ba14			.fbn3:		 ; if invalid number select first 
ba14 21 10 ed				ld hl, display_fb1 
ba17 22 cc eb		.fbset:		ld (display_fb_active), hl 
ba1a			 
ba1a					FORTH_DSP_POP 
ba1a cd fa 9d			call macro_forth_dsp_pop 
ba1d				endm 
# End of macro FORTH_DSP_POP
ba1d			 
ba1d					NEXTW 
ba1d c3 f8 9e			jp macro_next 
ba20				endm 
# End of macro NEXTW
ba20			 
ba20			 
ba20			.EMIT: 
ba20				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
ba20 1b				db WORD_SYS_CORE+7             
ba21 71 ba			dw .DOTH            
ba23 05				db 4 + 1 
ba24 .. 00			db "EMIT",0              
ba29				endm 
# End of macro CWHEAD
ba29			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba29					; get value off TOS and display it 
ba29			 
ba29					if DEBUG_FORTH_WORDS_KEY 
ba29						DMARK "EMT" 
ba29 f5				push af  
ba2a 3a 3e ba			ld a, (.dmark)  
ba2d 32 6b ee			ld (debug_mark),a  
ba30 3a 3f ba			ld a, (.dmark+1)  
ba33 32 6c ee			ld (debug_mark+1),a  
ba36 3a 40 ba			ld a, (.dmark+2)  
ba39 32 6d ee			ld (debug_mark+2),a  
ba3c 18 03			jr .pastdmark  
ba3e ..			.dmark: db "EMT"  
ba41 f1			.pastdmark: pop af  
ba42			endm  
# End of macro DMARK
ba42						CALLMONITOR 
ba42 cd 6f ee			call debug_vector  
ba45				endm  
# End of macro CALLMONITOR
ba45					endif 
ba45			 
ba45					FORTH_DSP_VALUEHL 
ba45 cd 42 9d			call macro_dsp_valuehl 
ba48				endm 
# End of macro FORTH_DSP_VALUEHL
ba48			 
ba48 7d					ld a,l 
ba49			 
ba49					; TODO write to display 
ba49			 
ba49 32 bf e4				ld (os_input), a 
ba4c 3e 00				ld a, 0 
ba4e 32 c0 e4				ld (os_input+1), a 
ba51					 
ba51 3a 5e ea				ld a, (f_cursor_ptr) 
ba54 11 bf e4				ld de, os_input 
ba57 cd c2 8a				call str_at_display 
ba5a			 
ba5a			 
ba5a 3a 3c ea				ld a,(cli_autodisplay) 
ba5d fe 00				cp 0 
ba5f 28 03				jr z, .enoupdate 
ba61 cd d2 8a						call update_display 
ba64					.enoupdate: 
ba64			 
ba64 3a 5e ea				ld a, (f_cursor_ptr) 
ba67 3c					inc a 
ba68 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
ba6b			 
ba6b			 
ba6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba6b cd fa 9d			call macro_forth_dsp_pop 
ba6e				endm 
# End of macro FORTH_DSP_POP
ba6e			  
ba6e			 
ba6e					NEXTW 
ba6e c3 f8 9e			jp macro_next 
ba71				endm 
# End of macro NEXTW
ba71			.DOTH: 
ba71				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
ba71 1c				db WORD_SYS_CORE+8             
ba72 a1 ba			dw .DOTF            
ba74 03				db 2 + 1 
ba75 .. 00			db ".-",0              
ba78				endm 
# End of macro CWHEAD
ba78			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
ba78					; get value off TOS and display it 
ba78					if DEBUG_FORTH_WORDS_KEY 
ba78						DMARK "DTD" 
ba78 f5				push af  
ba79 3a 8d ba			ld a, (.dmark)  
ba7c 32 6b ee			ld (debug_mark),a  
ba7f 3a 8e ba			ld a, (.dmark+1)  
ba82 32 6c ee			ld (debug_mark+1),a  
ba85 3a 8f ba			ld a, (.dmark+2)  
ba88 32 6d ee			ld (debug_mark+2),a  
ba8b 18 03			jr .pastdmark  
ba8d ..			.dmark: db "DTD"  
ba90 f1			.pastdmark: pop af  
ba91			endm  
# End of macro DMARK
ba91						CALLMONITOR 
ba91 cd 6f ee			call debug_vector  
ba94				endm  
# End of macro CALLMONITOR
ba94					endif 
ba94 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba96 3e 00			ld a, 0 
ba98 32 3d ea			ld (cli_mvdot), a 
ba9b c3 f8 ba			jp .dotgo 
ba9e				NEXTW 
ba9e c3 f8 9e			jp macro_next 
baa1				endm 
# End of macro NEXTW
baa1			.DOTF: 
baa1				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
baa1 1c				db WORD_SYS_CORE+8             
baa2 cf ba			dw .DOT            
baa4 03				db 2 + 1 
baa5 .. 00			db ".>",0              
baa8				endm 
# End of macro CWHEAD
baa8			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
baa8					; get value off TOS and display it 
baa8			        ; TODO BUG adds extra spaces 
baa8			        ; TODO BUG handle numerics? 
baa8					if DEBUG_FORTH_WORDS_KEY 
baa8						DMARK "DTC" 
baa8 f5				push af  
baa9 3a bd ba			ld a, (.dmark)  
baac 32 6b ee			ld (debug_mark),a  
baaf 3a be ba			ld a, (.dmark+1)  
bab2 32 6c ee			ld (debug_mark+1),a  
bab5 3a bf ba			ld a, (.dmark+2)  
bab8 32 6d ee			ld (debug_mark+2),a  
babb 18 03			jr .pastdmark  
babd ..			.dmark: db "DTC"  
bac0 f1			.pastdmark: pop af  
bac1			endm  
# End of macro DMARK
bac1						CALLMONITOR 
bac1 cd 6f ee			call debug_vector  
bac4				endm  
# End of macro CALLMONITOR
bac4					endif 
bac4 3e 01			ld a, 1 
bac6 32 3d ea			ld (cli_mvdot), a 
bac9 c3 f8 ba			jp .dotgo 
bacc				NEXTW 
bacc c3 f8 9e			jp macro_next 
bacf				endm 
# End of macro NEXTW
bacf			 
bacf			.DOT: 
bacf				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bacf 1c				db WORD_SYS_CORE+8             
bad0 ab bc			dw .CLS            
bad2 02				db 1 + 1 
bad3 .. 00			db ".",0              
bad5				endm 
# End of macro CWHEAD
bad5			        ; | . ( u -- ) Display TOS | DONE 
bad5					; get value off TOS and display it 
bad5			 
bad5					if DEBUG_FORTH_WORDS_KEY 
bad5						DMARK "DOT" 
bad5 f5				push af  
bad6 3a ea ba			ld a, (.dmark)  
bad9 32 6b ee			ld (debug_mark),a  
badc 3a eb ba			ld a, (.dmark+1)  
badf 32 6c ee			ld (debug_mark+1),a  
bae2 3a ec ba			ld a, (.dmark+2)  
bae5 32 6d ee			ld (debug_mark+2),a  
bae8 18 03			jr .pastdmark  
baea ..			.dmark: db "DOT"  
baed f1			.pastdmark: pop af  
baee			endm  
# End of macro DMARK
baee						CALLMONITOR 
baee cd 6f ee			call debug_vector  
baf1				endm  
# End of macro CALLMONITOR
baf1					endif 
baf1 3e 00			ld a, 0 
baf3 32 3d ea			ld (cli_mvdot), a 
baf6 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
baf8				 
baf8			 
baf8			.dotgo: 
baf8			 
baf8			; move up type to on stack for parserv5 
baf8					FORTH_DSP 
baf8 cd 08 9d			call macro_forth_dsp 
bafb				endm 
# End of macro FORTH_DSP
bafb				;FORTH_DSP_VALUE  
bafb			 
bafb			if DEBUG_FORTH_DOT 
bafb				DMARK "DOT" 
bafb f5				push af  
bafc 3a 10 bb			ld a, (.dmark)  
baff 32 6b ee			ld (debug_mark),a  
bb02 3a 11 bb			ld a, (.dmark+1)  
bb05 32 6c ee			ld (debug_mark+1),a  
bb08 3a 12 bb			ld a, (.dmark+2)  
bb0b 32 6d ee			ld (debug_mark+2),a  
bb0e 18 03			jr .pastdmark  
bb10 ..			.dmark: db "DOT"  
bb13 f1			.pastdmark: pop af  
bb14			endm  
# End of macro DMARK
bb14				CALLMONITOR 
bb14 cd 6f ee			call debug_vector  
bb17				endm  
# End of macro CALLMONITOR
bb17			endif	 
bb17			;		.print: 
bb17			 
bb17 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bb18 23				inc hl   ; position to the actual value 
bb19 fe 01			cp DS_TYPE_STR 
bb1b 20 06			jr nz, .dotnum1  
bb1d			 
bb1d			; display string 
bb1d				FORTH_DSP_VALUE  
bb1d cd 2b 9d			call macro_forth_dsp_value 
bb20				endm 
# End of macro FORTH_DSP_VALUE
bb20 eb				ex de,hl 
bb21 18 49			jr .dotwrite 
bb23			 
bb23			.dotnum1: 
bb23 fe 02			cp DS_TYPE_INUM 
bb25 20 44			jr nz, .dotflot 
bb27			 
bb27			 
bb27			; display number 
bb27			 
bb27			;	push hl 
bb27			;	call clear_display 
bb27			;	pop hl 
bb27			 
bb27 5e				ld e, (hl) 
bb28 23				inc hl 
bb29 56				ld d, (hl) 
bb2a 21 c1 e2			ld hl, scratch 
bb2d			if DEBUG_FORTH_DOT 
bb2d				DMARK "DT1" 
bb2d f5				push af  
bb2e 3a 42 bb			ld a, (.dmark)  
bb31 32 6b ee			ld (debug_mark),a  
bb34 3a 43 bb			ld a, (.dmark+1)  
bb37 32 6c ee			ld (debug_mark+1),a  
bb3a 3a 44 bb			ld a, (.dmark+2)  
bb3d 32 6d ee			ld (debug_mark+2),a  
bb40 18 03			jr .pastdmark  
bb42 ..			.dmark: db "DT1"  
bb45 f1			.pastdmark: pop af  
bb46			endm  
# End of macro DMARK
bb46				CALLMONITOR 
bb46 cd 6f ee			call debug_vector  
bb49				endm  
# End of macro CALLMONITOR
bb49			endif	 
bb49			 
bb49 cd e9 90			call uitoa_16 
bb4c eb				ex de,hl 
bb4d			 
bb4d			if DEBUG_FORTH_DOT 
bb4d				DMARK "DT2" 
bb4d f5				push af  
bb4e 3a 62 bb			ld a, (.dmark)  
bb51 32 6b ee			ld (debug_mark),a  
bb54 3a 63 bb			ld a, (.dmark+1)  
bb57 32 6c ee			ld (debug_mark+1),a  
bb5a 3a 64 bb			ld a, (.dmark+2)  
bb5d 32 6d ee			ld (debug_mark+2),a  
bb60 18 03			jr .pastdmark  
bb62 ..			.dmark: db "DT2"  
bb65 f1			.pastdmark: pop af  
bb66			endm  
# End of macro DMARK
bb66				CALLMONITOR 
bb66 cd 6f ee			call debug_vector  
bb69				endm  
# End of macro CALLMONITOR
bb69			endif	 
bb69			 
bb69			;	ld de, os_word_scratch 
bb69 18 01			jr .dotwrite 
bb6b			 
bb6b 00			.dotflot:   nop 
bb6c			; TODO print floating point number 
bb6c			 
bb6c			.dotwrite:		 
bb6c			 
bb6c					; if c is set then set all '-' to spaces 
bb6c					; need to also take into account .>  
bb6c			 
bb6c 3e 01				ld a, 1 
bb6e b9					cp c 
bb6f 20 67				jr nz, .nodashswap 
bb71			 
bb71					; DE has the string to write, working with HL 
bb71			 
bb71 06 ff				ld b, 255 
bb73 d5					push de 
bb74 e1					pop hl 
bb75			 
bb75			if DEBUG_FORTH_DOT 
bb75				DMARK "DT-" 
bb75 f5				push af  
bb76 3a 8a bb			ld a, (.dmark)  
bb79 32 6b ee			ld (debug_mark),a  
bb7c 3a 8b bb			ld a, (.dmark+1)  
bb7f 32 6c ee			ld (debug_mark+1),a  
bb82 3a 8c bb			ld a, (.dmark+2)  
bb85 32 6d ee			ld (debug_mark+2),a  
bb88 18 03			jr .pastdmark  
bb8a ..			.dmark: db "DT-"  
bb8d f1			.pastdmark: pop af  
bb8e			endm  
# End of macro DMARK
bb8e				CALLMONITOR 
bb8e cd 6f ee			call debug_vector  
bb91				endm  
# End of macro CALLMONITOR
bb91			endif	 
bb91 7e			.dashscan:	ld a, (hl) 
bb92 fe 00				cp 0 
bb94 28 42				jr z, .nodashswap 
bb96 fe 2d				cp '-' 
bb98 20 03				jr nz, .dashskip 
bb9a 3e 20				ld a, ' ' 
bb9c 77					ld (hl), a 
bb9d 23			.dashskip:	inc hl 
bb9e			if DEBUG_FORTH_DOT 
bb9e				DMARK "D-2" 
bb9e f5				push af  
bb9f 3a b3 bb			ld a, (.dmark)  
bba2 32 6b ee			ld (debug_mark),a  
bba5 3a b4 bb			ld a, (.dmark+1)  
bba8 32 6c ee			ld (debug_mark+1),a  
bbab 3a b5 bb			ld a, (.dmark+2)  
bbae 32 6d ee			ld (debug_mark+2),a  
bbb1 18 03			jr .pastdmark  
bbb3 ..			.dmark: db "D-2"  
bbb6 f1			.pastdmark: pop af  
bbb7			endm  
# End of macro DMARK
bbb7				CALLMONITOR 
bbb7 cd 6f ee			call debug_vector  
bbba				endm  
# End of macro CALLMONITOR
bbba			endif	 
bbba 10 d5				djnz .dashscan 
bbbc			 
bbbc			if DEBUG_FORTH_DOT 
bbbc				DMARK "D-1" 
bbbc f5				push af  
bbbd 3a d1 bb			ld a, (.dmark)  
bbc0 32 6b ee			ld (debug_mark),a  
bbc3 3a d2 bb			ld a, (.dmark+1)  
bbc6 32 6c ee			ld (debug_mark+1),a  
bbc9 3a d3 bb			ld a, (.dmark+2)  
bbcc 32 6d ee			ld (debug_mark+2),a  
bbcf 18 03			jr .pastdmark  
bbd1 ..			.dmark: db "D-1"  
bbd4 f1			.pastdmark: pop af  
bbd5			endm  
# End of macro DMARK
bbd5				CALLMONITOR 
bbd5 cd 6f ee			call debug_vector  
bbd8				endm  
# End of macro CALLMONITOR
bbd8			endif	 
bbd8			 
bbd8			.nodashswap: 
bbd8			 
bbd8			if DEBUG_FORTH_DOT 
bbd8				DMARK "D-o" 
bbd8 f5				push af  
bbd9 3a ed bb			ld a, (.dmark)  
bbdc 32 6b ee			ld (debug_mark),a  
bbdf 3a ee bb			ld a, (.dmark+1)  
bbe2 32 6c ee			ld (debug_mark+1),a  
bbe5 3a ef bb			ld a, (.dmark+2)  
bbe8 32 6d ee			ld (debug_mark+2),a  
bbeb 18 03			jr .pastdmark  
bbed ..			.dmark: db "D-o"  
bbf0 f1			.pastdmark: pop af  
bbf1			endm  
# End of macro DMARK
bbf1				CALLMONITOR 
bbf1 cd 6f ee			call debug_vector  
bbf4				endm  
# End of macro CALLMONITOR
bbf4			endif	 
bbf4			 
bbf4 d5					push de   ; save string start in case we need to advance print 
bbf5			 
bbf5 3a 5e ea				ld a, (f_cursor_ptr) 
bbf8 cd c2 8a				call str_at_display 
bbfb 3a 3c ea				ld a,(cli_autodisplay) 
bbfe fe 00				cp 0 
bc00 28 03				jr z, .noupdate 
bc02 cd d2 8a						call update_display 
bc05					.noupdate: 
bc05			 
bc05			 
bc05					; see if we need to advance the print position 
bc05			 
bc05 e1					pop hl   ; get back string 
bc06			;		ex de,hl 
bc06			 
bc06 3a 3d ea				ld a, (cli_mvdot) 
bc09			if DEBUG_FORTH_DOT 
bc09			;		ld e,a 
bc09				DMARK "D>1" 
bc09 f5				push af  
bc0a 3a 1e bc			ld a, (.dmark)  
bc0d 32 6b ee			ld (debug_mark),a  
bc10 3a 1f bc			ld a, (.dmark+1)  
bc13 32 6c ee			ld (debug_mark+1),a  
bc16 3a 20 bc			ld a, (.dmark+2)  
bc19 32 6d ee			ld (debug_mark+2),a  
bc1c 18 03			jr .pastdmark  
bc1e ..			.dmark: db "D>1"  
bc21 f1			.pastdmark: pop af  
bc22			endm  
# End of macro DMARK
bc22				CALLMONITOR 
bc22 cd 6f ee			call debug_vector  
bc25				endm  
# End of macro CALLMONITOR
bc25			endif	 
bc25 fe 00				cp 0 
bc27 28 44				jr z, .noadv 
bc29					; yes, lets advance the print position 
bc29 3e 00				ld a, 0 
bc2b cd 45 91				call strlent 
bc2e			if DEBUG_FORTH_DOT 
bc2e				DMARK "D-?" 
bc2e f5				push af  
bc2f 3a 43 bc			ld a, (.dmark)  
bc32 32 6b ee			ld (debug_mark),a  
bc35 3a 44 bc			ld a, (.dmark+1)  
bc38 32 6c ee			ld (debug_mark+1),a  
bc3b 3a 45 bc			ld a, (.dmark+2)  
bc3e 32 6d ee			ld (debug_mark+2),a  
bc41 18 03			jr .pastdmark  
bc43 ..			.dmark: db "D-?"  
bc46 f1			.pastdmark: pop af  
bc47			endm  
# End of macro DMARK
bc47				CALLMONITOR 
bc47 cd 6f ee			call debug_vector  
bc4a				endm  
# End of macro CALLMONITOR
bc4a			endif	 
bc4a 3a 5e ea				ld a, (f_cursor_ptr) 
bc4d 85					add a,l 
bc4e					;call addatohl 
bc4e					;ld a, l 
bc4e 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bc51			 
bc51			if DEBUG_FORTH_DOT 
bc51				DMARK "D->" 
bc51 f5				push af  
bc52 3a 66 bc			ld a, (.dmark)  
bc55 32 6b ee			ld (debug_mark),a  
bc58 3a 67 bc			ld a, (.dmark+1)  
bc5b 32 6c ee			ld (debug_mark+1),a  
bc5e 3a 68 bc			ld a, (.dmark+2)  
bc61 32 6d ee			ld (debug_mark+2),a  
bc64 18 03			jr .pastdmark  
bc66 ..			.dmark: db "D->"  
bc69 f1			.pastdmark: pop af  
bc6a			endm  
# End of macro DMARK
bc6a				CALLMONITOR 
bc6a cd 6f ee			call debug_vector  
bc6d				endm  
# End of macro CALLMONITOR
bc6d			endif	 
bc6d			 
bc6d			.noadv:	 
bc6d			 
bc6d					if DEBUG_FORTH_DOT_WAIT 
bc6d							call next_page_prompt 
bc6d					endif	 
bc6d			; TODO this pop off the stack causes a crash. i dont know why 
bc6d			 
bc6d			 
bc6d			if DEBUG_FORTH_DOT 
bc6d				DMARK "DTh" 
bc6d f5				push af  
bc6e 3a 82 bc			ld a, (.dmark)  
bc71 32 6b ee			ld (debug_mark),a  
bc74 3a 83 bc			ld a, (.dmark+1)  
bc77 32 6c ee			ld (debug_mark+1),a  
bc7a 3a 84 bc			ld a, (.dmark+2)  
bc7d 32 6d ee			ld (debug_mark+2),a  
bc80 18 03			jr .pastdmark  
bc82 ..			.dmark: db "DTh"  
bc85 f1			.pastdmark: pop af  
bc86			endm  
# End of macro DMARK
bc86				CALLMONITOR 
bc86 cd 6f ee			call debug_vector  
bc89				endm  
# End of macro CALLMONITOR
bc89			endif	 
bc89			 
bc89					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc89 cd fa 9d			call macro_forth_dsp_pop 
bc8c				endm 
# End of macro FORTH_DSP_POP
bc8c			 
bc8c			if DEBUG_FORTH_DOT 
bc8c				DMARK "DTi" 
bc8c f5				push af  
bc8d 3a a1 bc			ld a, (.dmark)  
bc90 32 6b ee			ld (debug_mark),a  
bc93 3a a2 bc			ld a, (.dmark+1)  
bc96 32 6c ee			ld (debug_mark+1),a  
bc99 3a a3 bc			ld a, (.dmark+2)  
bc9c 32 6d ee			ld (debug_mark+2),a  
bc9f 18 03			jr .pastdmark  
bca1 ..			.dmark: db "DTi"  
bca4 f1			.pastdmark: pop af  
bca5			endm  
# End of macro DMARK
bca5				CALLMONITOR 
bca5 cd 6f ee			call debug_vector  
bca8				endm  
# End of macro CALLMONITOR
bca8			endif	 
bca8			 
bca8			 
bca8					NEXTW 
bca8 c3 f8 9e			jp macro_next 
bcab				endm 
# End of macro NEXTW
bcab			 
bcab			.CLS: 
bcab				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bcab 35				db WORD_SYS_CORE+33             
bcac d8 bc			dw .DRAW            
bcae 04				db 3 + 1 
bcaf .. 00			db "CLS",0              
bcb3				endm 
# End of macro CWHEAD
bcb3			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bcb3					if DEBUG_FORTH_WORDS_KEY 
bcb3						DMARK "CLS" 
bcb3 f5				push af  
bcb4 3a c8 bc			ld a, (.dmark)  
bcb7 32 6b ee			ld (debug_mark),a  
bcba 3a c9 bc			ld a, (.dmark+1)  
bcbd 32 6c ee			ld (debug_mark+1),a  
bcc0 3a ca bc			ld a, (.dmark+2)  
bcc3 32 6d ee			ld (debug_mark+2),a  
bcc6 18 03			jr .pastdmark  
bcc8 ..			.dmark: db "CLS"  
bccb f1			.pastdmark: pop af  
bccc			endm  
# End of macro DMARK
bccc						CALLMONITOR 
bccc cd 6f ee			call debug_vector  
bccf				endm  
# End of macro CALLMONITOR
bccf					endif 
bccf cd af 8a				call clear_display 
bcd2 c3 e6 bd				jp .home		; and home cursor 
bcd5					NEXTW 
bcd5 c3 f8 9e			jp macro_next 
bcd8				endm 
# End of macro NEXTW
bcd8			 
bcd8			.DRAW: 
bcd8				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bcd8 36				db WORD_SYS_CORE+34             
bcd9 03 bd			dw .DUMP            
bcdb 05				db 4 + 1 
bcdc .. 00			db "DRAW",0              
bce1				endm 
# End of macro CWHEAD
bce1			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bce1					if DEBUG_FORTH_WORDS_KEY 
bce1						DMARK "DRW" 
bce1 f5				push af  
bce2 3a f6 bc			ld a, (.dmark)  
bce5 32 6b ee			ld (debug_mark),a  
bce8 3a f7 bc			ld a, (.dmark+1)  
bceb 32 6c ee			ld (debug_mark+1),a  
bcee 3a f8 bc			ld a, (.dmark+2)  
bcf1 32 6d ee			ld (debug_mark+2),a  
bcf4 18 03			jr .pastdmark  
bcf6 ..			.dmark: db "DRW"  
bcf9 f1			.pastdmark: pop af  
bcfa			endm  
# End of macro DMARK
bcfa						CALLMONITOR 
bcfa cd 6f ee			call debug_vector  
bcfd				endm  
# End of macro CALLMONITOR
bcfd					endif 
bcfd cd d2 8a				call update_display 
bd00					NEXTW 
bd00 c3 f8 9e			jp macro_next 
bd03				endm 
# End of macro NEXTW
bd03			 
bd03			.DUMP: 
bd03				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bd03 37				db WORD_SYS_CORE+35             
bd04 3b bd			dw .CDUMP            
bd06 05				db 4 + 1 
bd07 .. 00			db "DUMP",0              
bd0c				endm 
# End of macro CWHEAD
bd0c			; | DUMP ( x -- ) With address x display dump   | DONE 
bd0c			; TODO pop address to use off of the stack 
bd0c					if DEBUG_FORTH_WORDS_KEY 
bd0c						DMARK "DUM" 
bd0c f5				push af  
bd0d 3a 21 bd			ld a, (.dmark)  
bd10 32 6b ee			ld (debug_mark),a  
bd13 3a 22 bd			ld a, (.dmark+1)  
bd16 32 6c ee			ld (debug_mark+1),a  
bd19 3a 23 bd			ld a, (.dmark+2)  
bd1c 32 6d ee			ld (debug_mark+2),a  
bd1f 18 03			jr .pastdmark  
bd21 ..			.dmark: db "DUM"  
bd24 f1			.pastdmark: pop af  
bd25			endm  
# End of macro DMARK
bd25						CALLMONITOR 
bd25 cd 6f ee			call debug_vector  
bd28				endm  
# End of macro CALLMONITOR
bd28					endif 
bd28 cd af 8a				call clear_display 
bd2b			 
bd2b					; get address 
bd2b			 
bd2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd2b cd 42 9d			call macro_dsp_valuehl 
bd2e				endm 
# End of macro FORTH_DSP_VALUEHL
bd2e				 
bd2e					; save it for cdump 
bd2e			 
bd2e 22 e4 e5				ld (os_cur_ptr),hl 
bd31			 
bd31					; destroy value TOS 
bd31			 
bd31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd31 cd fa 9d			call macro_forth_dsp_pop 
bd34				endm 
# End of macro FORTH_DSP_POP
bd34			 
bd34 cd cb 99				call dumpcont	; skip old style of param parsing	 
bd37 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd38					NEXTW 
bd38 c3 f8 9e			jp macro_next 
bd3b				endm 
# End of macro NEXTW
bd3b			.CDUMP: 
bd3b				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd3b 38				db WORD_SYS_CORE+36             
bd3c 6b bd			dw .DAT            
bd3e 06				db 5 + 1 
bd3f .. 00			db "CDUMP",0              
bd45				endm 
# End of macro CWHEAD
bd45			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd45					if DEBUG_FORTH_WORDS_KEY 
bd45						DMARK "CDP" 
bd45 f5				push af  
bd46 3a 5a bd			ld a, (.dmark)  
bd49 32 6b ee			ld (debug_mark),a  
bd4c 3a 5b bd			ld a, (.dmark+1)  
bd4f 32 6c ee			ld (debug_mark+1),a  
bd52 3a 5c bd			ld a, (.dmark+2)  
bd55 32 6d ee			ld (debug_mark+2),a  
bd58 18 03			jr .pastdmark  
bd5a ..			.dmark: db "CDP"  
bd5d f1			.pastdmark: pop af  
bd5e			endm  
# End of macro DMARK
bd5e						CALLMONITOR 
bd5e cd 6f ee			call debug_vector  
bd61				endm  
# End of macro CALLMONITOR
bd61					endif 
bd61 cd af 8a				call clear_display 
bd64 cd cb 99				call dumpcont	 
bd67 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bd68					NEXTW 
bd68 c3 f8 9e			jp macro_next 
bd6b				endm 
# End of macro NEXTW
bd6b			 
bd6b			 
bd6b			 
bd6b			 
bd6b			.DAT: 
bd6b				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bd6b 3d				db WORD_SYS_CORE+41             
bd6c c1 bd			dw .HOME            
bd6e 03				db 2 + 1 
bd6f .. 00			db "AT",0              
bd72				endm 
# End of macro CWHEAD
bd72			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bd72					if DEBUG_FORTH_WORDS_KEY 
bd72						DMARK "AT." 
bd72 f5				push af  
bd73 3a 87 bd			ld a, (.dmark)  
bd76 32 6b ee			ld (debug_mark),a  
bd79 3a 88 bd			ld a, (.dmark+1)  
bd7c 32 6c ee			ld (debug_mark+1),a  
bd7f 3a 89 bd			ld a, (.dmark+2)  
bd82 32 6d ee			ld (debug_mark+2),a  
bd85 18 03			jr .pastdmark  
bd87 ..			.dmark: db "AT."  
bd8a f1			.pastdmark: pop af  
bd8b			endm  
# End of macro DMARK
bd8b						CALLMONITOR 
bd8b cd 6f ee			call debug_vector  
bd8e				endm  
# End of macro CALLMONITOR
bd8e					endif 
bd8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd8e cd 42 9d			call macro_dsp_valuehl 
bd91				endm 
# End of macro FORTH_DSP_VALUEHL
bd91			 
bd91			 
bd91					; TODO save cursor row 
bd91 7d					ld a,l 
bd92 fe 02				cp 2 
bd94 20 04				jr nz, .crow3 
bd96 3e 28				ld a, display_row_2 
bd98 18 12				jr .ccol1 
bd9a fe 03		.crow3:		cp 3 
bd9c 20 04				jr nz, .crow4 
bd9e 3e 50				ld a, display_row_3 
bda0 18 0a				jr .ccol1 
bda2 fe 04		.crow4:		cp 4 
bda4 20 04				jr nz, .crow1 
bda6 3e 78				ld a, display_row_4 
bda8 18 02				jr .ccol1 
bdaa 3e 00		.crow1:		ld a,display_row_1 
bdac f5			.ccol1:		push af			; got row offset 
bdad 6f					ld l,a 
bdae 26 00				ld h,0 
bdb0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdb0 cd fa 9d			call macro_forth_dsp_pop 
bdb3				endm 
# End of macro FORTH_DSP_POP
bdb3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdb3 cd 42 9d			call macro_dsp_valuehl 
bdb6				endm 
# End of macro FORTH_DSP_VALUEHL
bdb6					; TODO save cursor col 
bdb6 f1					pop af 
bdb7 85					add l		; add col offset 
bdb8 32 5e ea				ld (f_cursor_ptr), a 
bdbb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdbb cd fa 9d			call macro_forth_dsp_pop 
bdbe				endm 
# End of macro FORTH_DSP_POP
bdbe			 
bdbe					; calculate  
bdbe			 
bdbe					NEXTW 
bdbe c3 f8 9e			jp macro_next 
bdc1				endm 
# End of macro NEXTW
bdc1			 
bdc1			 
bdc1			.HOME: 
bdc1				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bdc1 41				db WORD_SYS_CORE+45             
bdc2 ee bd			dw .SPACE            
bdc4 05				db 4 + 1 
bdc5 .. 00			db "HOME",0              
bdca				endm 
# End of macro CWHEAD
bdca			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bdca					if DEBUG_FORTH_WORDS_KEY 
bdca						DMARK "HOM" 
bdca f5				push af  
bdcb 3a df bd			ld a, (.dmark)  
bdce 32 6b ee			ld (debug_mark),a  
bdd1 3a e0 bd			ld a, (.dmark+1)  
bdd4 32 6c ee			ld (debug_mark+1),a  
bdd7 3a e1 bd			ld a, (.dmark+2)  
bdda 32 6d ee			ld (debug_mark+2),a  
bddd 18 03			jr .pastdmark  
bddf ..			.dmark: db "HOM"  
bde2 f1			.pastdmark: pop af  
bde3			endm  
# End of macro DMARK
bde3						CALLMONITOR 
bde3 cd 6f ee			call debug_vector  
bde6				endm  
# End of macro CALLMONITOR
bde6					endif 
bde6 3e 00		.home:		ld a, 0		; and home cursor 
bde8 32 5e ea				ld (f_cursor_ptr), a 
bdeb					NEXTW 
bdeb c3 f8 9e			jp macro_next 
bdee				endm 
# End of macro NEXTW
bdee			 
bdee			 
bdee			.SPACE: 
bdee				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bdee 46				db WORD_SYS_CORE+50             
bdef 24 be			dw .SPACES            
bdf1 03				db 2 + 1 
bdf2 .. 00			db "BL",0              
bdf5				endm 
# End of macro CWHEAD
bdf5			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bdf5					if DEBUG_FORTH_WORDS_KEY 
bdf5						DMARK "BL." 
bdf5 f5				push af  
bdf6 3a 0a be			ld a, (.dmark)  
bdf9 32 6b ee			ld (debug_mark),a  
bdfc 3a 0b be			ld a, (.dmark+1)  
bdff 32 6c ee			ld (debug_mark+1),a  
be02 3a 0c be			ld a, (.dmark+2)  
be05 32 6d ee			ld (debug_mark+2),a  
be08 18 03			jr .pastdmark  
be0a ..			.dmark: db "BL."  
be0d f1			.pastdmark: pop af  
be0e			endm  
# End of macro DMARK
be0e						CALLMONITOR 
be0e cd 6f ee			call debug_vector  
be11				endm  
# End of macro CALLMONITOR
be11					endif 
be11 3e 20				ld a, " " 
be13 32 c1 e2				ld (scratch),a 
be16 3e 00				ld a, 0 
be18 32 c2 e2				ld (scratch+1),a 
be1b 21 c1 e2				ld hl, scratch 
be1e cd b9 9b				call forth_push_str 
be21					 
be21				       NEXTW 
be21 c3 f8 9e			jp macro_next 
be24				endm 
# End of macro NEXTW
be24			 
be24			;.blstr: db " ", 0 
be24			 
be24			.SPACES: 
be24				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be24 47				db WORD_SYS_CORE+51             
be25 bf be			dw .SCROLL            
be27 07				db 6 + 1 
be28 .. 00			db "SPACES",0              
be2f				endm 
# End of macro CWHEAD
be2f			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be2f					if DEBUG_FORTH_WORDS_KEY 
be2f						DMARK "SPS" 
be2f f5				push af  
be30 3a 44 be			ld a, (.dmark)  
be33 32 6b ee			ld (debug_mark),a  
be36 3a 45 be			ld a, (.dmark+1)  
be39 32 6c ee			ld (debug_mark+1),a  
be3c 3a 46 be			ld a, (.dmark+2)  
be3f 32 6d ee			ld (debug_mark+2),a  
be42 18 03			jr .pastdmark  
be44 ..			.dmark: db "SPS"  
be47 f1			.pastdmark: pop af  
be48			endm  
# End of macro DMARK
be48						CALLMONITOR 
be48 cd 6f ee			call debug_vector  
be4b				endm  
# End of macro CALLMONITOR
be4b					endif 
be4b			 
be4b			 
be4b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be4b cd 42 9d			call macro_dsp_valuehl 
be4e				endm 
# End of macro FORTH_DSP_VALUEHL
be4e			 
be4e e5					push hl    ; u 
be4f					if DEBUG_FORTH_WORDS 
be4f						DMARK "SPA" 
be4f f5				push af  
be50 3a 64 be			ld a, (.dmark)  
be53 32 6b ee			ld (debug_mark),a  
be56 3a 65 be			ld a, (.dmark+1)  
be59 32 6c ee			ld (debug_mark+1),a  
be5c 3a 66 be			ld a, (.dmark+2)  
be5f 32 6d ee			ld (debug_mark+2),a  
be62 18 03			jr .pastdmark  
be64 ..			.dmark: db "SPA"  
be67 f1			.pastdmark: pop af  
be68			endm  
# End of macro DMARK
be68						CALLMONITOR 
be68 cd 6f ee			call debug_vector  
be6b				endm  
# End of macro CALLMONITOR
be6b					endif 
be6b			 
be6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be6b cd fa 9d			call macro_forth_dsp_pop 
be6e				endm 
# End of macro FORTH_DSP_POP
be6e e1					pop hl 
be6f 0e 00				ld c, 0 
be71 45					ld b, l 
be72 21 c1 e2				ld hl, scratch  
be75			 
be75					if DEBUG_FORTH_WORDS 
be75						DMARK "SP2" 
be75 f5				push af  
be76 3a 8a be			ld a, (.dmark)  
be79 32 6b ee			ld (debug_mark),a  
be7c 3a 8b be			ld a, (.dmark+1)  
be7f 32 6c ee			ld (debug_mark+1),a  
be82 3a 8c be			ld a, (.dmark+2)  
be85 32 6d ee			ld (debug_mark+2),a  
be88 18 03			jr .pastdmark  
be8a ..			.dmark: db "SP2"  
be8d f1			.pastdmark: pop af  
be8e			endm  
# End of macro DMARK
be8e						CALLMONITOR 
be8e cd 6f ee			call debug_vector  
be91				endm  
# End of macro CALLMONITOR
be91					endif 
be91 3e 20				ld a, ' ' 
be93			.spaces1:	 
be93 77					ld (hl),a 
be94 23					inc hl 
be95					 
be95 10 fc				djnz .spaces1 
be97 3e 00				ld a,0 
be99 77					ld (hl),a 
be9a 21 c1 e2				ld hl, scratch 
be9d					if DEBUG_FORTH_WORDS 
be9d						DMARK "SP3" 
be9d f5				push af  
be9e 3a b2 be			ld a, (.dmark)  
bea1 32 6b ee			ld (debug_mark),a  
bea4 3a b3 be			ld a, (.dmark+1)  
bea7 32 6c ee			ld (debug_mark+1),a  
beaa 3a b4 be			ld a, (.dmark+2)  
bead 32 6d ee			ld (debug_mark+2),a  
beb0 18 03			jr .pastdmark  
beb2 ..			.dmark: db "SP3"  
beb5 f1			.pastdmark: pop af  
beb6			endm  
# End of macro DMARK
beb6						CALLMONITOR 
beb6 cd 6f ee			call debug_vector  
beb9				endm  
# End of macro CALLMONITOR
beb9					endif 
beb9 cd b9 9b				call forth_push_str 
bebc			 
bebc				       NEXTW 
bebc c3 f8 9e			jp macro_next 
bebf				endm 
# End of macro NEXTW
bebf			 
bebf			 
bebf			 
bebf			.SCROLL: 
bebf				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bebf 53				db WORD_SYS_CORE+63             
bec0 ec be			dw .SCROLLD            
bec2 07				db 6 + 1 
bec3 .. 00			db "SCROLL",0              
beca				endm 
# End of macro CWHEAD
beca			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
beca					if DEBUG_FORTH_WORDS_KEY 
beca						DMARK "SCR" 
beca f5				push af  
becb 3a df be			ld a, (.dmark)  
bece 32 6b ee			ld (debug_mark),a  
bed1 3a e0 be			ld a, (.dmark+1)  
bed4 32 6c ee			ld (debug_mark+1),a  
bed7 3a e1 be			ld a, (.dmark+2)  
beda 32 6d ee			ld (debug_mark+2),a  
bedd 18 03			jr .pastdmark  
bedf ..			.dmark: db "SCR"  
bee2 f1			.pastdmark: pop af  
bee3			endm  
# End of macro DMARK
bee3						CALLMONITOR 
bee3 cd 6f ee			call debug_vector  
bee6				endm  
# End of macro CALLMONITOR
bee6					endif 
bee6			 
bee6 cd 71 8a			call scroll_up 
bee9			;	call update_display 
bee9			 
bee9					NEXTW 
bee9 c3 f8 9e			jp macro_next 
beec				endm 
# End of macro NEXTW
beec			 
beec			 
beec			 
beec			;		; get dir 
beec			; 
beec			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
beec			; 
beec			;		push hl 
beec			; 
beec			;		; destroy value TOS 
beec			; 
beec			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
beec			; 
beec			;		; get count 
beec			; 
beec			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
beec			; 
beec			;		push hl 
beec			; 
beec			;		; destroy value TOS 
beec			; 
beec			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
beec			; 
beec			;		; one value on hl get other one back 
beec			; 
beec			;		pop bc    ; count 
beec			; 
beec			;		pop de   ; dir 
beec			; 
beec			; 
beec			;		ld b, c 
beec			; 
beec			;.scrolldir:     push bc 
beec			;		push de 
beec			; 
beec			;		ld a, 0 
beec			;		cp e 
beec			;		jr z, .scrollup  
beec			;		call scroll_down 
beec			;		jr .scrollnext 
beec			;.scrollup:	call scroll_up 
beec			; 
beec			;		 
beec			;.scrollnext: 
beec			;		pop de 
beec			;		pop bc 
beec			;		djnz .scrolldir 
beec			; 
beec			; 
beec			; 
beec			; 
beec			; 
beec			;		NEXTW 
beec			 
beec			.SCROLLD: 
beec				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
beec 53				db WORD_SYS_CORE+63             
beed 1a bf			dw .ATQ            
beef 08				db 7 + 1 
bef0 .. 00			db "SCROLLD",0              
bef8				endm 
# End of macro CWHEAD
bef8			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bef8					if DEBUG_FORTH_WORDS_KEY 
bef8						DMARK "SCD" 
bef8 f5				push af  
bef9 3a 0d bf			ld a, (.dmark)  
befc 32 6b ee			ld (debug_mark),a  
beff 3a 0e bf			ld a, (.dmark+1)  
bf02 32 6c ee			ld (debug_mark+1),a  
bf05 3a 0f bf			ld a, (.dmark+2)  
bf08 32 6d ee			ld (debug_mark+2),a  
bf0b 18 03			jr .pastdmark  
bf0d ..			.dmark: db "SCD"  
bf10 f1			.pastdmark: pop af  
bf11			endm  
# End of macro DMARK
bf11						CALLMONITOR 
bf11 cd 6f ee			call debug_vector  
bf14				endm  
# End of macro CALLMONITOR
bf14					endif 
bf14			 
bf14 cd 95 8a			call scroll_down 
bf17			;	call update_display 
bf17			 
bf17					NEXTW 
bf17 c3 f8 9e			jp macro_next 
bf1a				endm 
# End of macro NEXTW
bf1a			 
bf1a			 
bf1a			.ATQ: 
bf1a				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf1a 62				db WORD_SYS_CORE+78             
bf1b 78 bf			dw .AUTODSP            
bf1d 04				db 3 + 1 
bf1e .. 00			db "AT@",0              
bf22				endm 
# End of macro CWHEAD
bf22			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf22					if DEBUG_FORTH_WORDS_KEY 
bf22						DMARK "ATA" 
bf22 f5				push af  
bf23 3a 37 bf			ld a, (.dmark)  
bf26 32 6b ee			ld (debug_mark),a  
bf29 3a 38 bf			ld a, (.dmark+1)  
bf2c 32 6c ee			ld (debug_mark+1),a  
bf2f 3a 39 bf			ld a, (.dmark+2)  
bf32 32 6d ee			ld (debug_mark+2),a  
bf35 18 03			jr .pastdmark  
bf37 ..			.dmark: db "ATA"  
bf3a f1			.pastdmark: pop af  
bf3b			endm  
# End of macro DMARK
bf3b						CALLMONITOR 
bf3b cd 6f ee			call debug_vector  
bf3e				endm  
# End of macro CALLMONITOR
bf3e					endif 
bf3e			 
bf3e			 
bf3e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf3e cd 42 9d			call macro_dsp_valuehl 
bf41				endm 
# End of macro FORTH_DSP_VALUEHL
bf41			 
bf41					; TODO save cursor row 
bf41 7d					ld a,l 
bf42 fe 02				cp 2 
bf44 20 04				jr nz, .crow3aq 
bf46 3e 28				ld a, display_row_2 
bf48 18 12				jr .ccol1aq 
bf4a fe 03		.crow3aq:		cp 3 
bf4c 20 04				jr nz, .crow4aq 
bf4e 3e 50				ld a, display_row_3 
bf50 18 0a				jr .ccol1aq 
bf52 fe 04		.crow4aq:		cp 4 
bf54 20 04				jr nz, .crow1aq 
bf56 3e 78				ld a, display_row_4 
bf58 18 02				jr .ccol1aq 
bf5a 3e 00		.crow1aq:		ld a,display_row_1 
bf5c f5			.ccol1aq:		push af			; got row offset 
bf5d 6f					ld l,a 
bf5e 26 00				ld h,0 
bf60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf60 cd fa 9d			call macro_forth_dsp_pop 
bf63				endm 
# End of macro FORTH_DSP_POP
bf63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf63 cd 42 9d			call macro_dsp_valuehl 
bf66				endm 
# End of macro FORTH_DSP_VALUEHL
bf66					; TODO save cursor col 
bf66 f1					pop af 
bf67 85					add l		; add col offset 
bf68			 
bf68					; add current frame buffer address 
bf68 2a cc eb				ld hl, (display_fb_active) 
bf6b cd dc 8c				call addatohl 
bf6e			 
bf6e			 
bf6e			 
bf6e			 
bf6e					; get char frame buffer location offset in hl 
bf6e			 
bf6e 7e					ld a,(hl) 
bf6f 26 00				ld h, 0 
bf71 6f					ld l, a 
bf72			 
bf72 cd 4b 9b				call forth_push_numhl 
bf75			 
bf75			 
bf75					NEXTW 
bf75 c3 f8 9e			jp macro_next 
bf78				endm 
# End of macro NEXTW
bf78			 
bf78			.AUTODSP: 
bf78				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bf78 63				db WORD_SYS_CORE+79             
bf79 8e bf			dw .MENU            
bf7b 05				db 4 + 1 
bf7c .. 00			db "ADSP",0              
bf81				endm 
# End of macro CWHEAD
bf81			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bf81			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bf81			 
bf81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf81 cd 42 9d			call macro_dsp_valuehl 
bf84				endm 
# End of macro FORTH_DSP_VALUEHL
bf84			 
bf84			;		push hl 
bf84			 
bf84					; destroy value TOS 
bf84			 
bf84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf84 cd fa 9d			call macro_forth_dsp_pop 
bf87				endm 
# End of macro FORTH_DSP_POP
bf87			 
bf87			;		pop hl 
bf87			 
bf87 7d					ld a,l 
bf88 32 3c ea				ld (cli_autodisplay), a 
bf8b				       NEXTW 
bf8b c3 f8 9e			jp macro_next 
bf8e				endm 
# End of macro NEXTW
bf8e			 
bf8e			.MENU: 
bf8e				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bf8e 70				db WORD_SYS_CORE+92             
bf8f 37 c0			dw .ENDDISPLAY            
bf91 05				db 4 + 1 
bf92 .. 00			db "MENU",0              
bf97				endm 
# End of macro CWHEAD
bf97			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bf97			 
bf97			;		; get number of items on the stack 
bf97			; 
bf97				 
bf97					FORTH_DSP_VALUEHL 
bf97 cd 42 9d			call macro_dsp_valuehl 
bf9a				endm 
# End of macro FORTH_DSP_VALUEHL
bf9a				 
bf9a					if DEBUG_FORTH_WORDS_KEY 
bf9a						DMARK "MNU" 
bf9a f5				push af  
bf9b 3a af bf			ld a, (.dmark)  
bf9e 32 6b ee			ld (debug_mark),a  
bfa1 3a b0 bf			ld a, (.dmark+1)  
bfa4 32 6c ee			ld (debug_mark+1),a  
bfa7 3a b1 bf			ld a, (.dmark+2)  
bfaa 32 6d ee			ld (debug_mark+2),a  
bfad 18 03			jr .pastdmark  
bfaf ..			.dmark: db "MNU"  
bfb2 f1			.pastdmark: pop af  
bfb3			endm  
# End of macro DMARK
bfb3						CALLMONITOR 
bfb3 cd 6f ee			call debug_vector  
bfb6				endm  
# End of macro CALLMONITOR
bfb6					endif 
bfb6			 
bfb6 45					ld b, l	 
bfb7 05					dec b 
bfb8			 
bfb8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfb8 cd fa 9d			call macro_forth_dsp_pop 
bfbb				endm 
# End of macro FORTH_DSP_POP
bfbb			 
bfbb			 
bfbb					; go directly through the stack to pluck out the string pointers and build an array 
bfbb			 
bfbb			;		FORTH_DSP 
bfbb			 
bfbb					; hl contains top most stack item 
bfbb				 
bfbb 11 c1 e2				ld de, scratch 
bfbe			 
bfbe			.mbuild: 
bfbe			 
bfbe					FORTH_DSP_VALUEHL 
bfbe cd 42 9d			call macro_dsp_valuehl 
bfc1				endm 
# End of macro FORTH_DSP_VALUEHL
bfc1			 
bfc1					if DEBUG_FORTH_WORDS 
bfc1						DMARK "MN3" 
bfc1 f5				push af  
bfc2 3a d6 bf			ld a, (.dmark)  
bfc5 32 6b ee			ld (debug_mark),a  
bfc8 3a d7 bf			ld a, (.dmark+1)  
bfcb 32 6c ee			ld (debug_mark+1),a  
bfce 3a d8 bf			ld a, (.dmark+2)  
bfd1 32 6d ee			ld (debug_mark+2),a  
bfd4 18 03			jr .pastdmark  
bfd6 ..			.dmark: db "MN3"  
bfd9 f1			.pastdmark: pop af  
bfda			endm  
# End of macro DMARK
bfda						CALLMONITOR 
bfda cd 6f ee			call debug_vector  
bfdd				endm  
# End of macro CALLMONITOR
bfdd					endif 
bfdd eb					ex de, hl 
bfde 73					ld (hl), e 
bfdf 23					inc hl 
bfe0 72					ld (hl), d 
bfe1 23					inc hl 
bfe2 eb					ex de, hl 
bfe3			 
bfe3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfe3 cd fa 9d			call macro_forth_dsp_pop 
bfe6				endm 
# End of macro FORTH_DSP_POP
bfe6			 
bfe6 10 d6				djnz .mbuild 
bfe8			 
bfe8					; done add term 
bfe8			 
bfe8 eb					ex de, hl 
bfe9 36 00				ld (hl), 0 
bfeb 23					inc hl 
bfec 36 00				ld (hl), 0 
bfee			 
bfee				 
bfee					 
bfee 21 c1 e2				ld hl, scratch 
bff1			 
bff1					if DEBUG_FORTH_WORDS 
bff1						DMARK "MNx" 
bff1 f5				push af  
bff2 3a 06 c0			ld a, (.dmark)  
bff5 32 6b ee			ld (debug_mark),a  
bff8 3a 07 c0			ld a, (.dmark+1)  
bffb 32 6c ee			ld (debug_mark+1),a  
bffe 3a 08 c0			ld a, (.dmark+2)  
c001 32 6d ee			ld (debug_mark+2),a  
c004 18 03			jr .pastdmark  
c006 ..			.dmark: db "MNx"  
c009 f1			.pastdmark: pop af  
c00a			endm  
# End of macro DMARK
c00a						CALLMONITOR 
c00a cd 6f ee			call debug_vector  
c00d				endm  
# End of macro CALLMONITOR
c00d					endif 
c00d			 
c00d			 
c00d			 
c00d 3e 00				ld a, 0 
c00f cd e0 8a				call menu 
c012			 
c012			 
c012 6f					ld l, a 
c013 26 00				ld h, 0 
c015			 
c015					if DEBUG_FORTH_WORDS 
c015						DMARK "MNr" 
c015 f5				push af  
c016 3a 2a c0			ld a, (.dmark)  
c019 32 6b ee			ld (debug_mark),a  
c01c 3a 2b c0			ld a, (.dmark+1)  
c01f 32 6c ee			ld (debug_mark+1),a  
c022 3a 2c c0			ld a, (.dmark+2)  
c025 32 6d ee			ld (debug_mark+2),a  
c028 18 03			jr .pastdmark  
c02a ..			.dmark: db "MNr"  
c02d f1			.pastdmark: pop af  
c02e			endm  
# End of macro DMARK
c02e						CALLMONITOR 
c02e cd 6f ee			call debug_vector  
c031				endm  
# End of macro CALLMONITOR
c031					endif 
c031			 
c031 cd 4b 9b				call forth_push_numhl 
c034			 
c034			 
c034			 
c034			 
c034				       NEXTW 
c034 c3 f8 9e			jp macro_next 
c037				endm 
# End of macro NEXTW
c037			 
c037			 
c037			.ENDDISPLAY: 
c037			 
c037			; eof 
# End of file forth_words_display.asm
c037			include "forth_words_str.asm" 
c037			 
c037			; | ## String Words 
c037			 
c037			.PTR:   
c037			 
c037				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c037 48				db WORD_SYS_CORE+52             
c038 64 c0			dw .STYPE            
c03a 04				db 3 + 1 
c03b .. 00			db "PTR",0              
c03f				endm 
# End of macro CWHEAD
c03f			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c03f			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c03f			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c03f			 
c03f					if DEBUG_FORTH_WORDS_KEY 
c03f						DMARK "PTR" 
c03f f5				push af  
c040 3a 54 c0			ld a, (.dmark)  
c043 32 6b ee			ld (debug_mark),a  
c046 3a 55 c0			ld a, (.dmark+1)  
c049 32 6c ee			ld (debug_mark+1),a  
c04c 3a 56 c0			ld a, (.dmark+2)  
c04f 32 6d ee			ld (debug_mark+2),a  
c052 18 03			jr .pastdmark  
c054 ..			.dmark: db "PTR"  
c057 f1			.pastdmark: pop af  
c058			endm  
# End of macro DMARK
c058						CALLMONITOR 
c058 cd 6f ee			call debug_vector  
c05b				endm  
# End of macro CALLMONITOR
c05b					endif 
c05b					FORTH_DSP_VALUEHL 
c05b cd 42 9d			call macro_dsp_valuehl 
c05e				endm 
# End of macro FORTH_DSP_VALUEHL
c05e cd 4b 9b				call forth_push_numhl 
c061			 
c061			 
c061					NEXTW 
c061 c3 f8 9e			jp macro_next 
c064				endm 
# End of macro NEXTW
c064			.STYPE: 
c064				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c064 48				db WORD_SYS_CORE+52             
c065 b3 c0			dw .UPPER            
c067 06				db 5 + 1 
c068 .. 00			db "STYPE",0              
c06e				endm 
# End of macro CWHEAD
c06e			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c06e					if DEBUG_FORTH_WORDS_KEY 
c06e						DMARK "STY" 
c06e f5				push af  
c06f 3a 83 c0			ld a, (.dmark)  
c072 32 6b ee			ld (debug_mark),a  
c075 3a 84 c0			ld a, (.dmark+1)  
c078 32 6c ee			ld (debug_mark+1),a  
c07b 3a 85 c0			ld a, (.dmark+2)  
c07e 32 6d ee			ld (debug_mark+2),a  
c081 18 03			jr .pastdmark  
c083 ..			.dmark: db "STY"  
c086 f1			.pastdmark: pop af  
c087			endm  
# End of macro DMARK
c087						CALLMONITOR 
c087 cd 6f ee			call debug_vector  
c08a				endm  
# End of macro CALLMONITOR
c08a					endif 
c08a					FORTH_DSP 
c08a cd 08 9d			call macro_forth_dsp 
c08d				endm 
# End of macro FORTH_DSP
c08d					;v5 FORTH_DSP_VALUE 
c08d			 
c08d 7e					ld a, (hl) 
c08e			 
c08e f5					push af 
c08f			 
c08f			; Dont destroy TOS		FORTH_DSP_POP 
c08f			 
c08f f1					pop af 
c090			 
c090 fe 01				cp DS_TYPE_STR 
c092 28 09				jr z, .typestr 
c094			 
c094 fe 02				cp DS_TYPE_INUM 
c096 28 0a				jr z, .typeinum 
c098			 
c098 21 b1 c0				ld hl, .tna 
c09b 18 0a				jr .tpush 
c09d			 
c09d 21 ad c0		.typestr:	ld hl, .tstr 
c0a0 18 05				jr .tpush 
c0a2 21 af c0		.typeinum:	ld hl, .tinum 
c0a5 18 00				jr .tpush 
c0a7			 
c0a7			.tpush: 
c0a7			 
c0a7 cd b9 9b				call forth_push_str 
c0aa			 
c0aa					NEXTW 
c0aa c3 f8 9e			jp macro_next 
c0ad				endm 
# End of macro NEXTW
c0ad .. 00		.tstr:	db "s",0 
c0af .. 00		.tinum:  db "i",0 
c0b1 .. 00		.tna:   db "?", 0 
c0b3			 
c0b3			 
c0b3			.UPPER: 
c0b3				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c0b3 48				db WORD_SYS_CORE+52             
c0b4 ee c0			dw .LOWER            
c0b6 06				db 5 + 1 
c0b7 .. 00			db "UPPER",0              
c0bd				endm 
# End of macro CWHEAD
c0bd			; | UPPER ( s -- s ) Upper case string s  | DONE 
c0bd					if DEBUG_FORTH_WORDS_KEY 
c0bd						DMARK "UPR" 
c0bd f5				push af  
c0be 3a d2 c0			ld a, (.dmark)  
c0c1 32 6b ee			ld (debug_mark),a  
c0c4 3a d3 c0			ld a, (.dmark+1)  
c0c7 32 6c ee			ld (debug_mark+1),a  
c0ca 3a d4 c0			ld a, (.dmark+2)  
c0cd 32 6d ee			ld (debug_mark+2),a  
c0d0 18 03			jr .pastdmark  
c0d2 ..			.dmark: db "UPR"  
c0d5 f1			.pastdmark: pop af  
c0d6			endm  
# End of macro DMARK
c0d6						CALLMONITOR 
c0d6 cd 6f ee			call debug_vector  
c0d9				endm  
# End of macro CALLMONITOR
c0d9					endif 
c0d9			 
c0d9					FORTH_DSP 
c0d9 cd 08 9d			call macro_forth_dsp 
c0dc				endm 
# End of macro FORTH_DSP
c0dc					 
c0dc			; TODO check is string type 
c0dc			 
c0dc					FORTH_DSP_VALUEHL 
c0dc cd 42 9d			call macro_dsp_valuehl 
c0df				endm 
# End of macro FORTH_DSP_VALUEHL
c0df			; get pointer to string in hl 
c0df			 
c0df 7e			.toup:		ld a, (hl) 
c0e0 fe 00				cp 0 
c0e2 28 07				jr z, .toupdone 
c0e4			 
c0e4 cd 49 90				call to_upper 
c0e7			 
c0e7 77					ld (hl), a 
c0e8 23					inc hl 
c0e9 18 f4				jr .toup 
c0eb			 
c0eb					 
c0eb			 
c0eb			 
c0eb			; for each char convert to upper 
c0eb					 
c0eb			.toupdone: 
c0eb			 
c0eb			 
c0eb					NEXTW 
c0eb c3 f8 9e			jp macro_next 
c0ee				endm 
# End of macro NEXTW
c0ee			.LOWER: 
c0ee				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c0ee 48				db WORD_SYS_CORE+52             
c0ef 29 c1			dw .TCASE            
c0f1 06				db 5 + 1 
c0f2 .. 00			db "LOWER",0              
c0f8				endm 
# End of macro CWHEAD
c0f8			; | LOWER ( s -- s ) Lower case string s  | DONE 
c0f8					if DEBUG_FORTH_WORDS_KEY 
c0f8						DMARK "LWR" 
c0f8 f5				push af  
c0f9 3a 0d c1			ld a, (.dmark)  
c0fc 32 6b ee			ld (debug_mark),a  
c0ff 3a 0e c1			ld a, (.dmark+1)  
c102 32 6c ee			ld (debug_mark+1),a  
c105 3a 0f c1			ld a, (.dmark+2)  
c108 32 6d ee			ld (debug_mark+2),a  
c10b 18 03			jr .pastdmark  
c10d ..			.dmark: db "LWR"  
c110 f1			.pastdmark: pop af  
c111			endm  
# End of macro DMARK
c111						CALLMONITOR 
c111 cd 6f ee			call debug_vector  
c114				endm  
# End of macro CALLMONITOR
c114					endif 
c114			 
c114					FORTH_DSP 
c114 cd 08 9d			call macro_forth_dsp 
c117				endm 
# End of macro FORTH_DSP
c117					 
c117			; TODO check is string type 
c117			 
c117					FORTH_DSP_VALUEHL 
c117 cd 42 9d			call macro_dsp_valuehl 
c11a				endm 
# End of macro FORTH_DSP_VALUEHL
c11a			; get pointer to string in hl 
c11a			 
c11a 7e			.tolow:		ld a, (hl) 
c11b fe 00				cp 0 
c11d 28 07				jr z, .tolowdone 
c11f			 
c11f cd 52 90				call to_lower 
c122			 
c122 77					ld (hl), a 
c123 23					inc hl 
c124 18 f4				jr .tolow 
c126			 
c126					 
c126			 
c126			 
c126			; for each char convert to low 
c126					 
c126			.tolowdone: 
c126					NEXTW 
c126 c3 f8 9e			jp macro_next 
c129				endm 
# End of macro NEXTW
c129			.TCASE: 
c129				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c129 48				db WORD_SYS_CORE+52             
c12a 5f c2			dw .SUBSTR            
c12c 06				db 5 + 1 
c12d .. 00			db "TCASE",0              
c133				endm 
# End of macro CWHEAD
c133			; | TCASE ( s -- s ) Title case string s  | DONE 
c133					if DEBUG_FORTH_WORDS_KEY 
c133						DMARK "TCS" 
c133 f5				push af  
c134 3a 48 c1			ld a, (.dmark)  
c137 32 6b ee			ld (debug_mark),a  
c13a 3a 49 c1			ld a, (.dmark+1)  
c13d 32 6c ee			ld (debug_mark+1),a  
c140 3a 4a c1			ld a, (.dmark+2)  
c143 32 6d ee			ld (debug_mark+2),a  
c146 18 03			jr .pastdmark  
c148 ..			.dmark: db "TCS"  
c14b f1			.pastdmark: pop af  
c14c			endm  
# End of macro DMARK
c14c						CALLMONITOR 
c14c cd 6f ee			call debug_vector  
c14f				endm  
# End of macro CALLMONITOR
c14f					endif 
c14f			 
c14f					FORTH_DSP 
c14f cd 08 9d			call macro_forth_dsp 
c152				endm 
# End of macro FORTH_DSP
c152					 
c152			; TODO check is string type 
c152			 
c152					FORTH_DSP_VALUEHL 
c152 cd 42 9d			call macro_dsp_valuehl 
c155				endm 
# End of macro FORTH_DSP_VALUEHL
c155			; get pointer to string in hl 
c155			 
c155					if DEBUG_FORTH_WORDS 
c155						DMARK "TC1" 
c155 f5				push af  
c156 3a 6a c1			ld a, (.dmark)  
c159 32 6b ee			ld (debug_mark),a  
c15c 3a 6b c1			ld a, (.dmark+1)  
c15f 32 6c ee			ld (debug_mark+1),a  
c162 3a 6c c1			ld a, (.dmark+2)  
c165 32 6d ee			ld (debug_mark+2),a  
c168 18 03			jr .pastdmark  
c16a ..			.dmark: db "TC1"  
c16d f1			.pastdmark: pop af  
c16e			endm  
# End of macro DMARK
c16e						CALLMONITOR 
c16e cd 6f ee			call debug_vector  
c171				endm  
# End of macro CALLMONITOR
c171					endif 
c171			 
c171					; first time in turn to upper case first char 
c171			 
c171 7e					ld a, (hl) 
c172 c3 fc c1				jp .totsiptou 
c175			 
c175			 
c175 7e			.tot:		ld a, (hl) 
c176 fe 00				cp 0 
c178 ca 40 c2				jp z, .totdone 
c17b			 
c17b					if DEBUG_FORTH_WORDS 
c17b						DMARK "TC2" 
c17b f5				push af  
c17c 3a 90 c1			ld a, (.dmark)  
c17f 32 6b ee			ld (debug_mark),a  
c182 3a 91 c1			ld a, (.dmark+1)  
c185 32 6c ee			ld (debug_mark+1),a  
c188 3a 92 c1			ld a, (.dmark+2)  
c18b 32 6d ee			ld (debug_mark+2),a  
c18e 18 03			jr .pastdmark  
c190 ..			.dmark: db "TC2"  
c193 f1			.pastdmark: pop af  
c194			endm  
# End of macro DMARK
c194						CALLMONITOR 
c194 cd 6f ee			call debug_vector  
c197				endm  
# End of macro CALLMONITOR
c197					endif 
c197					; check to see if current char is a space 
c197			 
c197 fe 20				cp ' ' 
c199 28 21				jr z, .totsp 
c19b cd 52 90				call to_lower 
c19e					if DEBUG_FORTH_WORDS 
c19e						DMARK "TC3" 
c19e f5				push af  
c19f 3a b3 c1			ld a, (.dmark)  
c1a2 32 6b ee			ld (debug_mark),a  
c1a5 3a b4 c1			ld a, (.dmark+1)  
c1a8 32 6c ee			ld (debug_mark+1),a  
c1ab 3a b5 c1			ld a, (.dmark+2)  
c1ae 32 6d ee			ld (debug_mark+2),a  
c1b1 18 03			jr .pastdmark  
c1b3 ..			.dmark: db "TC3"  
c1b6 f1			.pastdmark: pop af  
c1b7			endm  
# End of macro DMARK
c1b7						CALLMONITOR 
c1b7 cd 6f ee			call debug_vector  
c1ba				endm  
# End of macro CALLMONITOR
c1ba					endif 
c1ba 18 63				jr .totnxt 
c1bc			 
c1bc			.totsp:         ; on a space, find next char which should be upper 
c1bc			 
c1bc					if DEBUG_FORTH_WORDS 
c1bc						DMARK "TC4" 
c1bc f5				push af  
c1bd 3a d1 c1			ld a, (.dmark)  
c1c0 32 6b ee			ld (debug_mark),a  
c1c3 3a d2 c1			ld a, (.dmark+1)  
c1c6 32 6c ee			ld (debug_mark+1),a  
c1c9 3a d3 c1			ld a, (.dmark+2)  
c1cc 32 6d ee			ld (debug_mark+2),a  
c1cf 18 03			jr .pastdmark  
c1d1 ..			.dmark: db "TC4"  
c1d4 f1			.pastdmark: pop af  
c1d5			endm  
# End of macro DMARK
c1d5						CALLMONITOR 
c1d5 cd 6f ee			call debug_vector  
c1d8				endm  
# End of macro CALLMONITOR
c1d8					endif 
c1d8					;; 
c1d8			 
c1d8 fe 20				cp ' ' 
c1da 20 20				jr nz, .totsiptou 
c1dc 23					inc hl 
c1dd 7e					ld a, (hl) 
c1de					if DEBUG_FORTH_WORDS 
c1de						DMARK "TC5" 
c1de f5				push af  
c1df 3a f3 c1			ld a, (.dmark)  
c1e2 32 6b ee			ld (debug_mark),a  
c1e5 3a f4 c1			ld a, (.dmark+1)  
c1e8 32 6c ee			ld (debug_mark+1),a  
c1eb 3a f5 c1			ld a, (.dmark+2)  
c1ee 32 6d ee			ld (debug_mark+2),a  
c1f1 18 03			jr .pastdmark  
c1f3 ..			.dmark: db "TC5"  
c1f6 f1			.pastdmark: pop af  
c1f7			endm  
# End of macro DMARK
c1f7						CALLMONITOR 
c1f7 cd 6f ee			call debug_vector  
c1fa				endm  
# End of macro CALLMONITOR
c1fa					endif 
c1fa 18 c0				jr .totsp 
c1fc fe 00		.totsiptou:    cp 0 
c1fe 28 40				jr z, .totdone 
c200					; not space and not zero term so upper case it 
c200 cd 49 90				call to_upper 
c203			 
c203					if DEBUG_FORTH_WORDS 
c203						DMARK "TC6" 
c203 f5				push af  
c204 3a 18 c2			ld a, (.dmark)  
c207 32 6b ee			ld (debug_mark),a  
c20a 3a 19 c2			ld a, (.dmark+1)  
c20d 32 6c ee			ld (debug_mark+1),a  
c210 3a 1a c2			ld a, (.dmark+2)  
c213 32 6d ee			ld (debug_mark+2),a  
c216 18 03			jr .pastdmark  
c218 ..			.dmark: db "TC6"  
c21b f1			.pastdmark: pop af  
c21c			endm  
# End of macro DMARK
c21c						CALLMONITOR 
c21c cd 6f ee			call debug_vector  
c21f				endm  
# End of macro CALLMONITOR
c21f					endif 
c21f			 
c21f			 
c21f			.totnxt: 
c21f			 
c21f 77					ld (hl), a 
c220 23					inc hl 
c221					if DEBUG_FORTH_WORDS 
c221						DMARK "TC7" 
c221 f5				push af  
c222 3a 36 c2			ld a, (.dmark)  
c225 32 6b ee			ld (debug_mark),a  
c228 3a 37 c2			ld a, (.dmark+1)  
c22b 32 6c ee			ld (debug_mark+1),a  
c22e 3a 38 c2			ld a, (.dmark+2)  
c231 32 6d ee			ld (debug_mark+2),a  
c234 18 03			jr .pastdmark  
c236 ..			.dmark: db "TC7"  
c239 f1			.pastdmark: pop af  
c23a			endm  
# End of macro DMARK
c23a						CALLMONITOR 
c23a cd 6f ee			call debug_vector  
c23d				endm  
# End of macro CALLMONITOR
c23d					endif 
c23d c3 75 c1				jp .tot 
c240			 
c240					 
c240			 
c240			 
c240			; for each char convert to low 
c240					 
c240			.totdone: 
c240					if DEBUG_FORTH_WORDS 
c240						DMARK "TCd" 
c240 f5				push af  
c241 3a 55 c2			ld a, (.dmark)  
c244 32 6b ee			ld (debug_mark),a  
c247 3a 56 c2			ld a, (.dmark+1)  
c24a 32 6c ee			ld (debug_mark+1),a  
c24d 3a 57 c2			ld a, (.dmark+2)  
c250 32 6d ee			ld (debug_mark+2),a  
c253 18 03			jr .pastdmark  
c255 ..			.dmark: db "TCd"  
c258 f1			.pastdmark: pop af  
c259			endm  
# End of macro DMARK
c259						CALLMONITOR 
c259 cd 6f ee			call debug_vector  
c25c				endm  
# End of macro CALLMONITOR
c25c					endif 
c25c					NEXTW 
c25c c3 f8 9e			jp macro_next 
c25f				endm 
# End of macro NEXTW
c25f			 
c25f			.SUBSTR: 
c25f				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c25f 48				db WORD_SYS_CORE+52             
c260 bd c2			dw .LEFT            
c262 07				db 6 + 1 
c263 .. 00			db "SUBSTR",0              
c26a				endm 
# End of macro CWHEAD
c26a			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c26a			 
c26a					if DEBUG_FORTH_WORDS_KEY 
c26a						DMARK "SST" 
c26a f5				push af  
c26b 3a 7f c2			ld a, (.dmark)  
c26e 32 6b ee			ld (debug_mark),a  
c271 3a 80 c2			ld a, (.dmark+1)  
c274 32 6c ee			ld (debug_mark+1),a  
c277 3a 81 c2			ld a, (.dmark+2)  
c27a 32 6d ee			ld (debug_mark+2),a  
c27d 18 03			jr .pastdmark  
c27f ..			.dmark: db "SST"  
c282 f1			.pastdmark: pop af  
c283			endm  
# End of macro DMARK
c283						CALLMONITOR 
c283 cd 6f ee			call debug_vector  
c286				endm  
# End of macro CALLMONITOR
c286					endif 
c286			; TODO check string type 
c286					FORTH_DSP_VALUEHL 
c286 cd 42 9d			call macro_dsp_valuehl 
c289				endm 
# End of macro FORTH_DSP_VALUEHL
c289			 
c289 e5					push hl      ; string length 
c28a			 
c28a					FORTH_DSP_POP 
c28a cd fa 9d			call macro_forth_dsp_pop 
c28d				endm 
# End of macro FORTH_DSP_POP
c28d			 
c28d					FORTH_DSP_VALUEHL 
c28d cd 42 9d			call macro_dsp_valuehl 
c290				endm 
# End of macro FORTH_DSP_VALUEHL
c290			 
c290 e5					push hl     ; start char 
c291			 
c291					FORTH_DSP_POP 
c291 cd fa 9d			call macro_forth_dsp_pop 
c294				endm 
# End of macro FORTH_DSP_POP
c294			 
c294			 
c294					FORTH_DSP_VALUE 
c294 cd 2b 9d			call macro_forth_dsp_value 
c297				endm 
# End of macro FORTH_DSP_VALUE
c297			 
c297 d1					pop de    ; get start post offset 
c298			 
c298 19					add hl, de    ; starting offset 
c299			 
c299 c1					pop bc 
c29a c5					push bc      ; grab size of string 
c29b			 
c29b e5					push hl    ; save string start  
c29c			 
c29c 26 00				ld h, 0 
c29e 69					ld l, c 
c29f 23					inc hl 
c2a0 23					inc hl 
c2a1			 
c2a1 cd a3 91				call malloc 
c2a4				if DEBUG_FORTH_MALLOC_GUARD 
c2a4 cc d7 cb				call z,malloc_error 
c2a7				endif 
c2a7			 
c2a7 eb					ex de, hl      ; save malloc area for string copy 
c2a8 e1					pop hl    ; get back source 
c2a9 c1					pop bc    ; get length of string back 
c2aa			 
c2aa d5					push de    ; save malloc area for after we push 
c2ab ed b0				ldir     ; copy substr 
c2ad			 
c2ad			 
c2ad eb					ex de, hl 
c2ae 3e 00				ld a, 0 
c2b0 77					ld (hl), a   ; term substr 
c2b1			 
c2b1					 
c2b1 e1					pop hl    ; get malloc so we can push it 
c2b2 e5					push hl   ; save so we can free it afterwards 
c2b3			 
c2b3 cd b9 9b				call forth_push_str 
c2b6			 
c2b6 e1					pop hl 
c2b7 cd 6d 92				call free 
c2ba			 
c2ba					 
c2ba					 
c2ba			 
c2ba			 
c2ba					NEXTW 
c2ba c3 f8 9e			jp macro_next 
c2bd				endm 
# End of macro NEXTW
c2bd			 
c2bd			.LEFT: 
c2bd				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c2bd 48				db WORD_SYS_CORE+52             
c2be e5 c2			dw .RIGHT            
c2c0 05				db 4 + 1 
c2c1 .. 00			db "LEFT",0              
c2c6				endm 
# End of macro CWHEAD
c2c6			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c2c6					if DEBUG_FORTH_WORDS_KEY 
c2c6						DMARK "LEF" 
c2c6 f5				push af  
c2c7 3a db c2			ld a, (.dmark)  
c2ca 32 6b ee			ld (debug_mark),a  
c2cd 3a dc c2			ld a, (.dmark+1)  
c2d0 32 6c ee			ld (debug_mark+1),a  
c2d3 3a dd c2			ld a, (.dmark+2)  
c2d6 32 6d ee			ld (debug_mark+2),a  
c2d9 18 03			jr .pastdmark  
c2db ..			.dmark: db "LEF"  
c2de f1			.pastdmark: pop af  
c2df			endm  
# End of macro DMARK
c2df						CALLMONITOR 
c2df cd 6f ee			call debug_vector  
c2e2				endm  
# End of macro CALLMONITOR
c2e2					endif 
c2e2			 
c2e2					NEXTW 
c2e2 c3 f8 9e			jp macro_next 
c2e5				endm 
# End of macro NEXTW
c2e5			.RIGHT: 
c2e5				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c2e5 48				db WORD_SYS_CORE+52             
c2e6 0e c3			dw .STR2NUM            
c2e8 06				db 5 + 1 
c2e9 .. 00			db "RIGHT",0              
c2ef				endm 
# End of macro CWHEAD
c2ef			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c2ef					if DEBUG_FORTH_WORDS_KEY 
c2ef						DMARK "RIG" 
c2ef f5				push af  
c2f0 3a 04 c3			ld a, (.dmark)  
c2f3 32 6b ee			ld (debug_mark),a  
c2f6 3a 05 c3			ld a, (.dmark+1)  
c2f9 32 6c ee			ld (debug_mark+1),a  
c2fc 3a 06 c3			ld a, (.dmark+2)  
c2ff 32 6d ee			ld (debug_mark+2),a  
c302 18 03			jr .pastdmark  
c304 ..			.dmark: db "RIG"  
c307 f1			.pastdmark: pop af  
c308			endm  
# End of macro DMARK
c308						CALLMONITOR 
c308 cd 6f ee			call debug_vector  
c30b				endm  
# End of macro CALLMONITOR
c30b					endif 
c30b			 
c30b					NEXTW 
c30b c3 f8 9e			jp macro_next 
c30e				endm 
# End of macro NEXTW
c30e			 
c30e			 
c30e			.STR2NUM: 
c30e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c30e 48				db WORD_SYS_CORE+52             
c30f 9a c3			dw .NUM2STR            
c311 08				db 7 + 1 
c312 .. 00			db "STR2NUM",0              
c31a				endm 
# End of macro CWHEAD
c31a			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c31a			 
c31a			 
c31a			; TODO STR type check to do 
c31a					if DEBUG_FORTH_WORDS_KEY 
c31a						DMARK "S2N" 
c31a f5				push af  
c31b 3a 2f c3			ld a, (.dmark)  
c31e 32 6b ee			ld (debug_mark),a  
c321 3a 30 c3			ld a, (.dmark+1)  
c324 32 6c ee			ld (debug_mark+1),a  
c327 3a 31 c3			ld a, (.dmark+2)  
c32a 32 6d ee			ld (debug_mark+2),a  
c32d 18 03			jr .pastdmark  
c32f ..			.dmark: db "S2N"  
c332 f1			.pastdmark: pop af  
c333			endm  
# End of macro DMARK
c333						CALLMONITOR 
c333 cd 6f ee			call debug_vector  
c336				endm  
# End of macro CALLMONITOR
c336					endif 
c336			 
c336					;FORTH_DSP 
c336					FORTH_DSP_VALUE 
c336 cd 2b 9d			call macro_forth_dsp_value 
c339				endm 
# End of macro FORTH_DSP_VALUE
c339					;inc hl 
c339			 
c339 eb					ex de, hl 
c33a					if DEBUG_FORTH_WORDS 
c33a						DMARK "S2a" 
c33a f5				push af  
c33b 3a 4f c3			ld a, (.dmark)  
c33e 32 6b ee			ld (debug_mark),a  
c341 3a 50 c3			ld a, (.dmark+1)  
c344 32 6c ee			ld (debug_mark+1),a  
c347 3a 51 c3			ld a, (.dmark+2)  
c34a 32 6d ee			ld (debug_mark+2),a  
c34d 18 03			jr .pastdmark  
c34f ..			.dmark: db "S2a"  
c352 f1			.pastdmark: pop af  
c353			endm  
# End of macro DMARK
c353						CALLMONITOR 
c353 cd 6f ee			call debug_vector  
c356				endm  
# End of macro CALLMONITOR
c356					endif 
c356 cd d1 90				call string_to_uint16 
c359			 
c359					if DEBUG_FORTH_WORDS 
c359						DMARK "S2b" 
c359 f5				push af  
c35a 3a 6e c3			ld a, (.dmark)  
c35d 32 6b ee			ld (debug_mark),a  
c360 3a 6f c3			ld a, (.dmark+1)  
c363 32 6c ee			ld (debug_mark+1),a  
c366 3a 70 c3			ld a, (.dmark+2)  
c369 32 6d ee			ld (debug_mark+2),a  
c36c 18 03			jr .pastdmark  
c36e ..			.dmark: db "S2b"  
c371 f1			.pastdmark: pop af  
c372			endm  
# End of macro DMARK
c372						CALLMONITOR 
c372 cd 6f ee			call debug_vector  
c375				endm  
# End of macro CALLMONITOR
c375					endif 
c375			;		push hl 
c375					FORTH_DSP_POP 
c375 cd fa 9d			call macro_forth_dsp_pop 
c378				endm 
# End of macro FORTH_DSP_POP
c378			;		pop hl 
c378					 
c378					if DEBUG_FORTH_WORDS 
c378						DMARK "S2b" 
c378 f5				push af  
c379 3a 8d c3			ld a, (.dmark)  
c37c 32 6b ee			ld (debug_mark),a  
c37f 3a 8e c3			ld a, (.dmark+1)  
c382 32 6c ee			ld (debug_mark+1),a  
c385 3a 8f c3			ld a, (.dmark+2)  
c388 32 6d ee			ld (debug_mark+2),a  
c38b 18 03			jr .pastdmark  
c38d ..			.dmark: db "S2b"  
c390 f1			.pastdmark: pop af  
c391			endm  
# End of macro DMARK
c391						CALLMONITOR 
c391 cd 6f ee			call debug_vector  
c394				endm  
# End of macro CALLMONITOR
c394					endif 
c394 cd 4b 9b				call forth_push_numhl	 
c397			 
c397				 
c397				       NEXTW 
c397 c3 f8 9e			jp macro_next 
c39a				endm 
# End of macro NEXTW
c39a			.NUM2STR: 
c39a				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c39a 48				db WORD_SYS_CORE+52             
c39b a9 c3			dw .CONCAT            
c39d 08				db 7 + 1 
c39e .. 00			db "NUM2STR",0              
c3a6				endm 
# End of macro CWHEAD
c3a6			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c3a6			 
c3a6			;		; malloc a string to target 
c3a6			;		ld hl, 10     ; TODO max string size should be fine 
c3a6			;		call malloc 
c3a6			;		push hl    ; save malloc location 
c3a6			; 
c3a6			; 
c3a6			;; TODO check int type 
c3a6			;		FORTH_DSP_VALUEHL 
c3a6			;		ld a, l 
c3a6			;		call DispAToASCII   
c3a6			;;TODO need to chage above call to dump into string 
c3a6			; 
c3a6			; 
c3a6			 
c3a6				       NEXTW 
c3a6 c3 f8 9e			jp macro_next 
c3a9				endm 
# End of macro NEXTW
c3a9			 
c3a9			.CONCAT: 
c3a9				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3a9 48				db WORD_SYS_CORE+52             
c3aa 5c c4			dw .FIND            
c3ac 07				db 6 + 1 
c3ad .. 00			db "CONCAT",0              
c3b4				endm 
# End of macro CWHEAD
c3b4			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c3b4			 
c3b4			; TODO check string type 
c3b4			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c3b4			 
c3b4					if DEBUG_FORTH_WORDS_KEY 
c3b4						DMARK "CON" 
c3b4 f5				push af  
c3b5 3a c9 c3			ld a, (.dmark)  
c3b8 32 6b ee			ld (debug_mark),a  
c3bb 3a ca c3			ld a, (.dmark+1)  
c3be 32 6c ee			ld (debug_mark+1),a  
c3c1 3a cb c3			ld a, (.dmark+2)  
c3c4 32 6d ee			ld (debug_mark+2),a  
c3c7 18 03			jr .pastdmark  
c3c9 ..			.dmark: db "CON"  
c3cc f1			.pastdmark: pop af  
c3cd			endm  
# End of macro DMARK
c3cd						CALLMONITOR 
c3cd cd 6f ee			call debug_vector  
c3d0				endm  
# End of macro CALLMONITOR
c3d0					endif 
c3d0			 
c3d0			 
c3d0					FORTH_DSP_VALUE 
c3d0 cd 2b 9d			call macro_forth_dsp_value 
c3d3				endm 
# End of macro FORTH_DSP_VALUE
c3d3 e5					push hl   ; s2 
c3d4			 
c3d4					FORTH_DSP_POP 
c3d4 cd fa 9d			call macro_forth_dsp_pop 
c3d7				endm 
# End of macro FORTH_DSP_POP
c3d7			 
c3d7					FORTH_DSP_VALUE 
c3d7 cd 2b 9d			call macro_forth_dsp_value 
c3da				endm 
# End of macro FORTH_DSP_VALUE
c3da			 
c3da e5					push hl   ; s1 
c3db			 
c3db					FORTH_DSP_POP 
c3db cd fa 9d			call macro_forth_dsp_pop 
c3de				endm 
# End of macro FORTH_DSP_POP
c3de					 
c3de			 
c3de					; copy s1 
c3de			 
c3de				 
c3de					; save ptr 
c3de e1					pop hl  
c3df e5					push hl 
c3e0 3e 00				ld a, 0 
c3e2 cd 45 91				call strlent 
c3e5					;inc hl    ; zer0 
c3e5 06 00				ld b, 0 
c3e7 4d					ld c, l 
c3e8 e1					pop hl		 
c3e9 11 c1 e2				ld de, scratch	 
c3ec					if DEBUG_FORTH_WORDS 
c3ec						DMARK "CO1" 
c3ec f5				push af  
c3ed 3a 01 c4			ld a, (.dmark)  
c3f0 32 6b ee			ld (debug_mark),a  
c3f3 3a 02 c4			ld a, (.dmark+1)  
c3f6 32 6c ee			ld (debug_mark+1),a  
c3f9 3a 03 c4			ld a, (.dmark+2)  
c3fc 32 6d ee			ld (debug_mark+2),a  
c3ff 18 03			jr .pastdmark  
c401 ..			.dmark: db "CO1"  
c404 f1			.pastdmark: pop af  
c405			endm  
# End of macro DMARK
c405						CALLMONITOR 
c405 cd 6f ee			call debug_vector  
c408				endm  
# End of macro CALLMONITOR
c408					endif 
c408 ed b0				ldir 
c40a			 
c40a e1					pop hl 
c40b e5					push hl 
c40c d5					push de 
c40d			 
c40d			 
c40d 3e 00				ld a, 0 
c40f cd 45 91				call strlent 
c412 23					inc hl    ; zer0 
c413 23					inc hl 
c414 06 00				ld b, 0 
c416 4d					ld c, l 
c417 d1					pop de 
c418 e1					pop hl		 
c419					if DEBUG_FORTH_WORDS 
c419						DMARK "CO2" 
c419 f5				push af  
c41a 3a 2e c4			ld a, (.dmark)  
c41d 32 6b ee			ld (debug_mark),a  
c420 3a 2f c4			ld a, (.dmark+1)  
c423 32 6c ee			ld (debug_mark+1),a  
c426 3a 30 c4			ld a, (.dmark+2)  
c429 32 6d ee			ld (debug_mark+2),a  
c42c 18 03			jr .pastdmark  
c42e ..			.dmark: db "CO2"  
c431 f1			.pastdmark: pop af  
c432			endm  
# End of macro DMARK
c432						CALLMONITOR 
c432 cd 6f ee			call debug_vector  
c435				endm  
# End of macro CALLMONITOR
c435					endif 
c435 ed b0				ldir 
c437			 
c437			 
c437			 
c437 21 c1 e2				ld hl, scratch 
c43a					if DEBUG_FORTH_WORDS 
c43a						DMARK "CO5" 
c43a f5				push af  
c43b 3a 4f c4			ld a, (.dmark)  
c43e 32 6b ee			ld (debug_mark),a  
c441 3a 50 c4			ld a, (.dmark+1)  
c444 32 6c ee			ld (debug_mark+1),a  
c447 3a 51 c4			ld a, (.dmark+2)  
c44a 32 6d ee			ld (debug_mark+2),a  
c44d 18 03			jr .pastdmark  
c44f ..			.dmark: db "CO5"  
c452 f1			.pastdmark: pop af  
c453			endm  
# End of macro DMARK
c453						CALLMONITOR 
c453 cd 6f ee			call debug_vector  
c456				endm  
# End of macro CALLMONITOR
c456					endif 
c456			 
c456 cd b9 9b				call forth_push_str 
c459			 
c459			 
c459			 
c459			 
c459				       NEXTW 
c459 c3 f8 9e			jp macro_next 
c45c				endm 
# End of macro NEXTW
c45c			 
c45c			 
c45c			.FIND: 
c45c				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c45c 4b				db WORD_SYS_CORE+55             
c45d 1a c5			dw .LEN            
c45f 05				db 4 + 1 
c460 .. 00			db "FIND",0              
c465				endm 
# End of macro CWHEAD
c465			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c465			 
c465					if DEBUG_FORTH_WORDS_KEY 
c465						DMARK "FND" 
c465 f5				push af  
c466 3a 7a c4			ld a, (.dmark)  
c469 32 6b ee			ld (debug_mark),a  
c46c 3a 7b c4			ld a, (.dmark+1)  
c46f 32 6c ee			ld (debug_mark+1),a  
c472 3a 7c c4			ld a, (.dmark+2)  
c475 32 6d ee			ld (debug_mark+2),a  
c478 18 03			jr .pastdmark  
c47a ..			.dmark: db "FND"  
c47d f1			.pastdmark: pop af  
c47e			endm  
# End of macro DMARK
c47e						CALLMONITOR 
c47e cd 6f ee			call debug_vector  
c481				endm  
# End of macro CALLMONITOR
c481					endif 
c481			 
c481			; TODO check string type 
c481					FORTH_DSP_VALUE 
c481 cd 2b 9d			call macro_forth_dsp_value 
c484				endm 
# End of macro FORTH_DSP_VALUE
c484			 
c484 e5					push hl    
c485 7e					ld a,(hl)    ; char to find   
c486			; TODO change char to substr 
c486			 
c486 f5					push af 
c487					 
c487			 
c487			 
c487					if DEBUG_FORTH_WORDS 
c487						DMARK "FN1" 
c487 f5				push af  
c488 3a 9c c4			ld a, (.dmark)  
c48b 32 6b ee			ld (debug_mark),a  
c48e 3a 9d c4			ld a, (.dmark+1)  
c491 32 6c ee			ld (debug_mark+1),a  
c494 3a 9e c4			ld a, (.dmark+2)  
c497 32 6d ee			ld (debug_mark+2),a  
c49a 18 03			jr .pastdmark  
c49c ..			.dmark: db "FN1"  
c49f f1			.pastdmark: pop af  
c4a0			endm  
# End of macro DMARK
c4a0						CALLMONITOR 
c4a0 cd 6f ee			call debug_vector  
c4a3				endm  
# End of macro CALLMONITOR
c4a3					endif 
c4a3			 
c4a3					FORTH_DSP_POP 
c4a3 cd fa 9d			call macro_forth_dsp_pop 
c4a6				endm 
# End of macro FORTH_DSP_POP
c4a6			 
c4a6					; string to search 
c4a6			 
c4a6					FORTH_DSP_VALUE 
c4a6 cd 2b 9d			call macro_forth_dsp_value 
c4a9				endm 
# End of macro FORTH_DSP_VALUE
c4a9			 
c4a9 d1					pop de  ; d is char to find  
c4aa			 
c4aa					if DEBUG_FORTH_WORDS 
c4aa						DMARK "FN2" 
c4aa f5				push af  
c4ab 3a bf c4			ld a, (.dmark)  
c4ae 32 6b ee			ld (debug_mark),a  
c4b1 3a c0 c4			ld a, (.dmark+1)  
c4b4 32 6c ee			ld (debug_mark+1),a  
c4b7 3a c1 c4			ld a, (.dmark+2)  
c4ba 32 6d ee			ld (debug_mark+2),a  
c4bd 18 03			jr .pastdmark  
c4bf ..			.dmark: db "FN2"  
c4c2 f1			.pastdmark: pop af  
c4c3			endm  
# End of macro DMARK
c4c3						CALLMONITOR 
c4c3 cd 6f ee			call debug_vector  
c4c6				endm  
# End of macro CALLMONITOR
c4c6					endif 
c4c6					 
c4c6 01 00 00				ld bc, 0 
c4c9 7e			.findchar:      ld a,(hl) 
c4ca fe 00				cp 0   		 
c4cc 28 27				jr z, .finddone     
c4ce ba					cp d 
c4cf 28 20				jr z, .foundchar 
c4d1 03					inc bc 
c4d2 23					inc hl 
c4d3					if DEBUG_FORTH_WORDS 
c4d3						DMARK "FN3" 
c4d3 f5				push af  
c4d4 3a e8 c4			ld a, (.dmark)  
c4d7 32 6b ee			ld (debug_mark),a  
c4da 3a e9 c4			ld a, (.dmark+1)  
c4dd 32 6c ee			ld (debug_mark+1),a  
c4e0 3a ea c4			ld a, (.dmark+2)  
c4e3 32 6d ee			ld (debug_mark+2),a  
c4e6 18 03			jr .pastdmark  
c4e8 ..			.dmark: db "FN3"  
c4eb f1			.pastdmark: pop af  
c4ec			endm  
# End of macro DMARK
c4ec						CALLMONITOR 
c4ec cd 6f ee			call debug_vector  
c4ef				endm  
# End of macro CALLMONITOR
c4ef					endif 
c4ef 18 d8				jr .findchar 
c4f1			 
c4f1			 
c4f1 c5			.foundchar:	push bc 
c4f2 e1					pop hl 
c4f3 18 03				jr .findexit 
c4f5			 
c4f5			 
c4f5							 
c4f5			 
c4f5			.finddone:     ; got to end of string with no find 
c4f5 21 00 00				ld hl, 0 
c4f8			.findexit: 
c4f8			 
c4f8					if DEBUG_FORTH_WORDS 
c4f8						DMARK "FNd" 
c4f8 f5				push af  
c4f9 3a 0d c5			ld a, (.dmark)  
c4fc 32 6b ee			ld (debug_mark),a  
c4ff 3a 0e c5			ld a, (.dmark+1)  
c502 32 6c ee			ld (debug_mark+1),a  
c505 3a 0f c5			ld a, (.dmark+2)  
c508 32 6d ee			ld (debug_mark+2),a  
c50b 18 03			jr .pastdmark  
c50d ..			.dmark: db "FNd"  
c510 f1			.pastdmark: pop af  
c511			endm  
# End of macro DMARK
c511						CALLMONITOR 
c511 cd 6f ee			call debug_vector  
c514				endm  
# End of macro CALLMONITOR
c514					endif 
c514 cd 4b 9b			call forth_push_numhl 
c517			 
c517				       NEXTW 
c517 c3 f8 9e			jp macro_next 
c51a				endm 
# End of macro NEXTW
c51a			 
c51a			.LEN: 
c51a				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c51a 4c				db WORD_SYS_CORE+56             
c51b 84 c5			dw .ASC            
c51d 06				db 5 + 1 
c51e .. 00			db "COUNT",0              
c524				endm 
# End of macro CWHEAD
c524			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c524			 
c524					if DEBUG_FORTH_WORDS_KEY 
c524						DMARK "CNT" 
c524 f5				push af  
c525 3a 39 c5			ld a, (.dmark)  
c528 32 6b ee			ld (debug_mark),a  
c52b 3a 3a c5			ld a, (.dmark+1)  
c52e 32 6c ee			ld (debug_mark+1),a  
c531 3a 3b c5			ld a, (.dmark+2)  
c534 32 6d ee			ld (debug_mark+2),a  
c537 18 03			jr .pastdmark  
c539 ..			.dmark: db "CNT"  
c53c f1			.pastdmark: pop af  
c53d			endm  
# End of macro DMARK
c53d						CALLMONITOR 
c53d cd 6f ee			call debug_vector  
c540				endm  
# End of macro CALLMONITOR
c540					endif 
c540			; TODO check string type 
c540					FORTH_DSP_VALUE 
c540 cd 2b 9d			call macro_forth_dsp_value 
c543				endm 
# End of macro FORTH_DSP_VALUE
c543			 
c543			 
c543					if DEBUG_FORTH_WORDS 
c543						DMARK "CN?" 
c543 f5				push af  
c544 3a 58 c5			ld a, (.dmark)  
c547 32 6b ee			ld (debug_mark),a  
c54a 3a 59 c5			ld a, (.dmark+1)  
c54d 32 6c ee			ld (debug_mark+1),a  
c550 3a 5a c5			ld a, (.dmark+2)  
c553 32 6d ee			ld (debug_mark+2),a  
c556 18 03			jr .pastdmark  
c558 ..			.dmark: db "CN?"  
c55b f1			.pastdmark: pop af  
c55c			endm  
# End of macro DMARK
c55c						CALLMONITOR 
c55c cd 6f ee			call debug_vector  
c55f				endm  
# End of macro CALLMONITOR
c55f					endif 
c55f cd 3a 91				call strlenz 
c562					if DEBUG_FORTH_WORDS 
c562						DMARK "CNl" 
c562 f5				push af  
c563 3a 77 c5			ld a, (.dmark)  
c566 32 6b ee			ld (debug_mark),a  
c569 3a 78 c5			ld a, (.dmark+1)  
c56c 32 6c ee			ld (debug_mark+1),a  
c56f 3a 79 c5			ld a, (.dmark+2)  
c572 32 6d ee			ld (debug_mark+2),a  
c575 18 03			jr .pastdmark  
c577 ..			.dmark: db "CNl"  
c57a f1			.pastdmark: pop af  
c57b			endm  
# End of macro DMARK
c57b						CALLMONITOR 
c57b cd 6f ee			call debug_vector  
c57e				endm  
# End of macro CALLMONITOR
c57e					endif 
c57e			 
c57e cd 4b 9b				call forth_push_numhl 
c581			 
c581			 
c581			 
c581				       NEXTW 
c581 c3 f8 9e			jp macro_next 
c584				endm 
# End of macro NEXTW
c584			.ASC: 
c584				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c584 4d				db WORD_SYS_CORE+57             
c585 f2 c5			dw .CHR            
c587 04				db 3 + 1 
c588 .. 00			db "ASC",0              
c58c				endm 
# End of macro CWHEAD
c58c			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c58c					if DEBUG_FORTH_WORDS_KEY 
c58c						DMARK "ASC" 
c58c f5				push af  
c58d 3a a1 c5			ld a, (.dmark)  
c590 32 6b ee			ld (debug_mark),a  
c593 3a a2 c5			ld a, (.dmark+1)  
c596 32 6c ee			ld (debug_mark+1),a  
c599 3a a3 c5			ld a, (.dmark+2)  
c59c 32 6d ee			ld (debug_mark+2),a  
c59f 18 03			jr .pastdmark  
c5a1 ..			.dmark: db "ASC"  
c5a4 f1			.pastdmark: pop af  
c5a5			endm  
# End of macro DMARK
c5a5						CALLMONITOR 
c5a5 cd 6f ee			call debug_vector  
c5a8				endm  
# End of macro CALLMONITOR
c5a8					endif 
c5a8					FORTH_DSP_VALUE 
c5a8 cd 2b 9d			call macro_forth_dsp_value 
c5ab				endm 
# End of macro FORTH_DSP_VALUE
c5ab					;v5 FORTH_DSP_VALUE 
c5ab			;		inc hl      ; now at start of numeric as string 
c5ab			 
c5ab e5					push hl 
c5ac			 
c5ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5ac cd fa 9d			call macro_forth_dsp_pop 
c5af				endm 
# End of macro FORTH_DSP_POP
c5af			 
c5af e1					pop hl 
c5b0			 
c5b0					if DEBUG_FORTH_WORDS 
c5b0						DMARK "AS1" 
c5b0 f5				push af  
c5b1 3a c5 c5			ld a, (.dmark)  
c5b4 32 6b ee			ld (debug_mark),a  
c5b7 3a c6 c5			ld a, (.dmark+1)  
c5ba 32 6c ee			ld (debug_mark+1),a  
c5bd 3a c7 c5			ld a, (.dmark+2)  
c5c0 32 6d ee			ld (debug_mark+2),a  
c5c3 18 03			jr .pastdmark  
c5c5 ..			.dmark: db "AS1"  
c5c8 f1			.pastdmark: pop af  
c5c9			endm  
# End of macro DMARK
c5c9						CALLMONITOR 
c5c9 cd 6f ee			call debug_vector  
c5cc				endm  
# End of macro CALLMONITOR
c5cc					endif 
c5cc					; push the content of a onto the stack as a value 
c5cc			 
c5cc 7e					ld a,(hl)   ; get char 
c5cd 26 00				ld h,0 
c5cf 6f					ld l,a 
c5d0					if DEBUG_FORTH_WORDS 
c5d0						DMARK "AS2" 
c5d0 f5				push af  
c5d1 3a e5 c5			ld a, (.dmark)  
c5d4 32 6b ee			ld (debug_mark),a  
c5d7 3a e6 c5			ld a, (.dmark+1)  
c5da 32 6c ee			ld (debug_mark+1),a  
c5dd 3a e7 c5			ld a, (.dmark+2)  
c5e0 32 6d ee			ld (debug_mark+2),a  
c5e3 18 03			jr .pastdmark  
c5e5 ..			.dmark: db "AS2"  
c5e8 f1			.pastdmark: pop af  
c5e9			endm  
# End of macro DMARK
c5e9						CALLMONITOR 
c5e9 cd 6f ee			call debug_vector  
c5ec				endm  
# End of macro CALLMONITOR
c5ec					endif 
c5ec cd 4b 9b				call forth_push_numhl 
c5ef			 
c5ef				       NEXTW 
c5ef c3 f8 9e			jp macro_next 
c5f2				endm 
# End of macro NEXTW
c5f2			 
c5f2			.CHR: 
c5f2				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c5f2 4d				db WORD_SYS_CORE+57             
c5f3 2e c6			dw .ENDSTR            
c5f5 04				db 3 + 1 
c5f6 .. 00			db "CHR",0              
c5fa				endm 
# End of macro CWHEAD
c5fa			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c5fa					if DEBUG_FORTH_WORDS_KEY 
c5fa						DMARK "CHR" 
c5fa f5				push af  
c5fb 3a 0f c6			ld a, (.dmark)  
c5fe 32 6b ee			ld (debug_mark),a  
c601 3a 10 c6			ld a, (.dmark+1)  
c604 32 6c ee			ld (debug_mark+1),a  
c607 3a 11 c6			ld a, (.dmark+2)  
c60a 32 6d ee			ld (debug_mark+2),a  
c60d 18 03			jr .pastdmark  
c60f ..			.dmark: db "CHR"  
c612 f1			.pastdmark: pop af  
c613			endm  
# End of macro DMARK
c613						CALLMONITOR 
c613 cd 6f ee			call debug_vector  
c616				endm  
# End of macro CALLMONITOR
c616					endif 
c616					FORTH_DSP_VALUEHL 
c616 cd 42 9d			call macro_dsp_valuehl 
c619				endm 
# End of macro FORTH_DSP_VALUEHL
c619			 
c619					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c619 cd fa 9d			call macro_forth_dsp_pop 
c61c				endm 
# End of macro FORTH_DSP_POP
c61c			 
c61c					; save asci byte as a zero term string and push string 
c61c			 
c61c 7d					ld a,l 
c61d 32 c1 e2				ld (scratch), a 
c620			 
c620 3e 00				ld a, 0 
c622 32 c2 e2				ld (scratch+1), a 
c625			 
c625 21 c1 e2				ld hl, scratch 
c628 cd b9 9b				call forth_push_str 
c62b			 
c62b			 
c62b				       NEXTW 
c62b c3 f8 9e			jp macro_next 
c62e				endm 
# End of macro NEXTW
c62e			 
c62e			 
c62e			 
c62e			 
c62e			.ENDSTR: 
c62e			; eof 
c62e			 
# End of file forth_words_str.asm
c62e			include "forth_words_key.asm" 
c62e			 
c62e			; | ## Keyboard Words 
c62e			 
c62e			.KEY: 
c62e				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c62e 3e				db WORD_SYS_CORE+42             
c62f 5e c6			dw .WAITK            
c631 04				db 3 + 1 
c632 .. 00			db "KEY",0              
c636				endm 
# End of macro CWHEAD
c636			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c636			 
c636					if DEBUG_FORTH_WORDS_KEY 
c636						DMARK "KEY" 
c636 f5				push af  
c637 3a 4b c6			ld a, (.dmark)  
c63a 32 6b ee			ld (debug_mark),a  
c63d 3a 4c c6			ld a, (.dmark+1)  
c640 32 6c ee			ld (debug_mark+1),a  
c643 3a 4d c6			ld a, (.dmark+2)  
c646 32 6d ee			ld (debug_mark+2),a  
c649 18 03			jr .pastdmark  
c64b ..			.dmark: db "KEY"  
c64e f1			.pastdmark: pop af  
c64f			endm  
# End of macro DMARK
c64f						CALLMONITOR 
c64f cd 6f ee			call debug_vector  
c652				endm  
# End of macro CALLMONITOR
c652					endif 
c652			; TODO currently waits 
c652 cd ce e3				call cin 
c655					;call cin_wait 
c655 6f					ld l, a 
c656 26 00				ld h, 0 
c658 cd 4b 9b				call forth_push_numhl 
c65b					NEXTW 
c65b c3 f8 9e			jp macro_next 
c65e				endm 
# End of macro NEXTW
c65e			.WAITK: 
c65e				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c65e 3f				db WORD_SYS_CORE+43             
c65f 90 c6			dw .ACCEPT            
c661 06				db 5 + 1 
c662 .. 00			db "WAITK",0              
c668				endm 
# End of macro CWHEAD
c668			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c668					if DEBUG_FORTH_WORDS_KEY 
c668						DMARK "WAI" 
c668 f5				push af  
c669 3a 7d c6			ld a, (.dmark)  
c66c 32 6b ee			ld (debug_mark),a  
c66f 3a 7e c6			ld a, (.dmark+1)  
c672 32 6c ee			ld (debug_mark+1),a  
c675 3a 7f c6			ld a, (.dmark+2)  
c678 32 6d ee			ld (debug_mark+2),a  
c67b 18 03			jr .pastdmark  
c67d ..			.dmark: db "WAI"  
c680 f1			.pastdmark: pop af  
c681			endm  
# End of macro DMARK
c681						CALLMONITOR 
c681 cd 6f ee			call debug_vector  
c684				endm  
# End of macro CALLMONITOR
c684					endif 
c684 cd c8 e3				call cin_wait 
c687 6f					ld l, a 
c688 26 00				ld h, 0 
c68a cd 4b 9b				call forth_push_numhl 
c68d					NEXTW 
c68d c3 f8 9e			jp macro_next 
c690				endm 
# End of macro NEXTW
c690			.ACCEPT: 
c690				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c690 40				db WORD_SYS_CORE+44             
c691 ee c6			dw .EDIT            
c693 07				db 6 + 1 
c694 .. 00			db "ACCEPT",0              
c69b				endm 
# End of macro CWHEAD
c69b			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c69b					; TODO crashes on push 
c69b					if DEBUG_FORTH_WORDS_KEY 
c69b						DMARK "ACC" 
c69b f5				push af  
c69c 3a b0 c6			ld a, (.dmark)  
c69f 32 6b ee			ld (debug_mark),a  
c6a2 3a b1 c6			ld a, (.dmark+1)  
c6a5 32 6c ee			ld (debug_mark+1),a  
c6a8 3a b2 c6			ld a, (.dmark+2)  
c6ab 32 6d ee			ld (debug_mark+2),a  
c6ae 18 03			jr .pastdmark  
c6b0 ..			.dmark: db "ACC"  
c6b3 f1			.pastdmark: pop af  
c6b4			endm  
# End of macro DMARK
c6b4						CALLMONITOR 
c6b4 cd 6f ee			call debug_vector  
c6b7				endm  
# End of macro CALLMONITOR
c6b7					endif 
c6b7 21 bf e4				ld hl, os_input 
c6ba 3e 00				ld a, 0 
c6bc 77					ld (hl),a 
c6bd 3a 5e ea				ld a,(f_cursor_ptr) 
c6c0 16 64				ld d, 100 
c6c2 0e 00				ld c, 0 
c6c4 1e 28				ld e, 40 
c6c6 cd 09 8d				call input_str 
c6c9					; TODO perhaps do a type check and wrap in quotes if not a number 
c6c9 21 bf e4				ld hl, os_input 
c6cc					if DEBUG_FORTH_WORDS 
c6cc						DMARK "AC1" 
c6cc f5				push af  
c6cd 3a e1 c6			ld a, (.dmark)  
c6d0 32 6b ee			ld (debug_mark),a  
c6d3 3a e2 c6			ld a, (.dmark+1)  
c6d6 32 6c ee			ld (debug_mark+1),a  
c6d9 3a e3 c6			ld a, (.dmark+2)  
c6dc 32 6d ee			ld (debug_mark+2),a  
c6df 18 03			jr .pastdmark  
c6e1 ..			.dmark: db "AC1"  
c6e4 f1			.pastdmark: pop af  
c6e5			endm  
# End of macro DMARK
c6e5						CALLMONITOR 
c6e5 cd 6f ee			call debug_vector  
c6e8				endm  
# End of macro CALLMONITOR
c6e8					endif 
c6e8 cd b9 9b				call forth_push_str 
c6eb					NEXTW 
c6eb c3 f8 9e			jp macro_next 
c6ee				endm 
# End of macro NEXTW
c6ee			 
c6ee			.EDIT: 
c6ee				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c6ee 40				db WORD_SYS_CORE+44             
c6ef 90 c7			dw .DEDIT            
c6f1 05				db 4 + 1 
c6f2 .. 00			db "EDIT",0              
c6f7				endm 
# End of macro CWHEAD
c6f7			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c6f7			 
c6f7					; TODO does not copy from stack 
c6f7					if DEBUG_FORTH_WORDS_KEY 
c6f7						DMARK "EDT" 
c6f7 f5				push af  
c6f8 3a 0c c7			ld a, (.dmark)  
c6fb 32 6b ee			ld (debug_mark),a  
c6fe 3a 0d c7			ld a, (.dmark+1)  
c701 32 6c ee			ld (debug_mark+1),a  
c704 3a 0e c7			ld a, (.dmark+2)  
c707 32 6d ee			ld (debug_mark+2),a  
c70a 18 03			jr .pastdmark  
c70c ..			.dmark: db "EDT"  
c70f f1			.pastdmark: pop af  
c710			endm  
# End of macro DMARK
c710						CALLMONITOR 
c710 cd 6f ee			call debug_vector  
c713				endm  
# End of macro CALLMONITOR
c713					endif 
c713			 
c713					;FORTH_DSP 
c713					FORTH_DSP_VALUEHL 
c713 cd 42 9d			call macro_dsp_valuehl 
c716				endm 
# End of macro FORTH_DSP_VALUEHL
c716			;		inc hl    ; TODO do type check 
c716			 
c716			;		call get_word_hl 
c716 e5					push hl 
c717					if DEBUG_FORTH_WORDS 
c717						DMARK "EDp" 
c717 f5				push af  
c718 3a 2c c7			ld a, (.dmark)  
c71b 32 6b ee			ld (debug_mark),a  
c71e 3a 2d c7			ld a, (.dmark+1)  
c721 32 6c ee			ld (debug_mark+1),a  
c724 3a 2e c7			ld a, (.dmark+2)  
c727 32 6d ee			ld (debug_mark+2),a  
c72a 18 03			jr .pastdmark  
c72c ..			.dmark: db "EDp"  
c72f f1			.pastdmark: pop af  
c730			endm  
# End of macro DMARK
c730						CALLMONITOR 
c730 cd 6f ee			call debug_vector  
c733				endm  
# End of macro CALLMONITOR
c733					endif 
c733				;	ld a, 0 
c733 cd 3a 91				call strlenz 
c736 23					inc hl 
c737			 
c737 06 00				ld b, 0 
c739 4d					ld c, l 
c73a			 
c73a e1					pop hl 
c73b 11 bf e4				ld de, os_input 
c73e					if DEBUG_FORTH_WORDS_KEY 
c73e						DMARK "EDc" 
c73e f5				push af  
c73f 3a 53 c7			ld a, (.dmark)  
c742 32 6b ee			ld (debug_mark),a  
c745 3a 54 c7			ld a, (.dmark+1)  
c748 32 6c ee			ld (debug_mark+1),a  
c74b 3a 55 c7			ld a, (.dmark+2)  
c74e 32 6d ee			ld (debug_mark+2),a  
c751 18 03			jr .pastdmark  
c753 ..			.dmark: db "EDc"  
c756 f1			.pastdmark: pop af  
c757			endm  
# End of macro DMARK
c757						CALLMONITOR 
c757 cd 6f ee			call debug_vector  
c75a				endm  
# End of macro CALLMONITOR
c75a					endif 
c75a ed b0				ldir 
c75c			 
c75c			 
c75c 21 bf e4				ld hl, os_input 
c75f					;ld a, 0 
c75f					;ld (hl),a 
c75f 3a 5e ea				ld a,(f_cursor_ptr) 
c762 16 64				ld d, 100 
c764 0e 00				ld c, 0 
c766 1e 28				ld e, 40 
c768 cd 09 8d				call input_str 
c76b					; TODO perhaps do a type check and wrap in quotes if not a number 
c76b 21 bf e4				ld hl, os_input 
c76e					if DEBUG_FORTH_WORDS 
c76e						DMARK "ED1" 
c76e f5				push af  
c76f 3a 83 c7			ld a, (.dmark)  
c772 32 6b ee			ld (debug_mark),a  
c775 3a 84 c7			ld a, (.dmark+1)  
c778 32 6c ee			ld (debug_mark+1),a  
c77b 3a 85 c7			ld a, (.dmark+2)  
c77e 32 6d ee			ld (debug_mark+2),a  
c781 18 03			jr .pastdmark  
c783 ..			.dmark: db "ED1"  
c786 f1			.pastdmark: pop af  
c787			endm  
# End of macro DMARK
c787						CALLMONITOR 
c787 cd 6f ee			call debug_vector  
c78a				endm  
# End of macro CALLMONITOR
c78a					endif 
c78a cd b9 9b				call forth_push_str 
c78d					NEXTW 
c78d c3 f8 9e			jp macro_next 
c790				endm 
# End of macro NEXTW
c790			 
c790			.DEDIT: 
c790				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c790 40				db WORD_SYS_CORE+44             
c791 f2 c7			dw .ENDKEY            
c793 06				db 5 + 1 
c794 .. 00			db "DEDIT",0              
c79a				endm 
# End of macro CWHEAD
c79a			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c79a			 
c79a					; TODO does not copy from stack 
c79a					if DEBUG_FORTH_WORDS_KEY 
c79a						DMARK "DED" 
c79a f5				push af  
c79b 3a af c7			ld a, (.dmark)  
c79e 32 6b ee			ld (debug_mark),a  
c7a1 3a b0 c7			ld a, (.dmark+1)  
c7a4 32 6c ee			ld (debug_mark+1),a  
c7a7 3a b1 c7			ld a, (.dmark+2)  
c7aa 32 6d ee			ld (debug_mark+2),a  
c7ad 18 03			jr .pastdmark  
c7af ..			.dmark: db "DED"  
c7b2 f1			.pastdmark: pop af  
c7b3			endm  
# End of macro DMARK
c7b3						CALLMONITOR 
c7b3 cd 6f ee			call debug_vector  
c7b6				endm  
# End of macro CALLMONITOR
c7b6					endif 
c7b6			 
c7b6					;FORTH_DSP 
c7b6					FORTH_DSP_VALUEHL 
c7b6 cd 42 9d			call macro_dsp_valuehl 
c7b9				endm 
# End of macro FORTH_DSP_VALUEHL
c7b9			;		inc hl    ; TODO do type check 
c7b9			 
c7b9			;		call get_word_hl 
c7b9 e5					push hl 
c7ba e5					push hl 
c7bb					FORTH_DSP_POP 
c7bb cd fa 9d			call macro_forth_dsp_pop 
c7be				endm 
# End of macro FORTH_DSP_POP
c7be e1					pop hl 
c7bf					if DEBUG_FORTH_WORDS 
c7bf						DMARK "EDp" 
c7bf f5				push af  
c7c0 3a d4 c7			ld a, (.dmark)  
c7c3 32 6b ee			ld (debug_mark),a  
c7c6 3a d5 c7			ld a, (.dmark+1)  
c7c9 32 6c ee			ld (debug_mark+1),a  
c7cc 3a d6 c7			ld a, (.dmark+2)  
c7cf 32 6d ee			ld (debug_mark+2),a  
c7d2 18 03			jr .pastdmark  
c7d4 ..			.dmark: db "EDp"  
c7d7 f1			.pastdmark: pop af  
c7d8			endm  
# End of macro DMARK
c7d8						CALLMONITOR 
c7d8 cd 6f ee			call debug_vector  
c7db				endm  
# End of macro CALLMONITOR
c7db					endif 
c7db				;	ld a, 0 
c7db cd 3a 91				call strlenz 
c7de 23					inc hl 
c7df			 
c7df 06 00				ld b, 0 
c7e1 4d					ld c, l 
c7e2			 
c7e2 e1					pop hl 
c7e3			 
c7e3					;ld a, 0 
c7e3					;ld (hl),a 
c7e3 3a 5e ea				ld a,(f_cursor_ptr) 
c7e6 16 64				ld d, 100 
c7e8 0e 00				ld c, 0 
c7ea 1e 28				ld e, 40 
c7ec cd 09 8d				call input_str 
c7ef					; TODO perhaps do a type check and wrap in quotes if not a number 
c7ef					NEXTW 
c7ef c3 f8 9e			jp macro_next 
c7f2				endm 
# End of macro NEXTW
c7f2			 
c7f2			 
c7f2			.ENDKEY: 
c7f2			; eof 
c7f2			 
# End of file forth_words_key.asm
c7f2			include "forth_words_const.asm" 
c7f2			 
c7f2			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c7f2			 
c7f2			 
c7f2			.SPITIME: 
c7f2				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c7f2 77				db WORD_SYS_CORE+99             
c7f3 07 c8			dw .VA            
c7f5 08				db 7 + 1 
c7f6 .. 00			db "SPITIME",0              
c7fe				endm 
# End of macro CWHEAD
c7fe			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c7fe			; 
c7fe			; | If using BANK devices then leave as is. 
c7fe			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c7fe			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c7fe			 
c7fe 21 64 ea				ld hl, spi_clktime  
c801 cd 4b 9b				call forth_push_numhl 
c804			 
c804					NEXTW 
c804 c3 f8 9e			jp macro_next 
c807				endm 
# End of macro NEXTW
c807			 
c807			 
c807			.VA: 
c807				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c807 77				db WORD_SYS_CORE+99             
c808 17 c8			dw .SYMBOL            
c80a 03				db 2 + 1 
c80b .. 00			db "VA",0              
c80e				endm 
# End of macro CWHEAD
c80e			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c80e 21 28 ea				ld hl, cli_var_array 
c811 cd 4b 9b				call forth_push_numhl 
c814			 
c814					NEXTW 
c814 c3 f8 9e			jp macro_next 
c817				endm 
# End of macro NEXTW
c817			 
c817			.SYMBOL: 
c817				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c817 77				db WORD_SYS_CORE+99             
c818 21 c9			dw .ENDCONST            
c81a 07				db 6 + 1 
c81b .. 00			db "SYMBOL",0              
c822				endm 
# End of macro CWHEAD
c822			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c822			; | 
c822			; | The value is the number reference and the final address is pushed to stack 
c822			 
c822			; | dw sym_table 
c822			; | dw nmi_vector 
c822			; | dw cli_autodisplay 
c822			; | dw cli_data_sp 
c822			; | dw cli_data_stack 
c822			; | dw cli_loop_sp 
c822			; | dw cli_loop_stack 
c822			; | dw cli_var_array 
c822			; | dw cursor_col 
c822			; | dw cursor_ptr 
c822			; | ; 10 
c822			; | dw cursor_row 
c822			; | dw debug_mark 
c822			; | dw display_fb0 
c822			; | dw display_fb1 
c822			; | dw display_fb2 
c822			; | dw display_fb3 
c822			; | dw display_fb_active 
c822			; | dw execscratch 
c822			; | dw f_cursor_ptr 
c822			; | dw hardware_word 
c822			; | ;20 
c822			; | dw input_at_cursor 
c822			; | dw input_at_pos 
c822			; | dw input_cur_flash 
c822			; | dw input_cur_onoff 
c822			; | dw input_cursor 
c822			; | dw input_display_size 
c822			; | dw input_len 
c822			; | dw input_ptr 
c822			; | dw input_size 
c822			; | dw input_start 
c822			; | ; 30 
c822			; | dw input_str 
c822			; | dw input_under_cursor 
c822			; | dw os_cli_cmd 
c822			; | dw os_cur_ptr 
c822			; | dw os_current_i 
c822			; | dw os_input 
c822			; | dw os_last_cmd 
c822			; | dw os_last_new_uword 
c822			; | dw debug_vector 
c822			; | dw os_view_hl 
c822			; | ;40 
c822			; | dw os_word_scratch 
c822			; | dw portbctl 
c822			; | dw portbdata 
c822			; | dw spi_cartdev 
c822			; | dw spi_cartdev2 
c822			; | dw spi_clktime 
c822			; | dw spi_device 
c822			; | dw spi_device_id 
c822			; | dw spi_portbyte 
c822			; | dw stackstore 
c822			; | ; 50 
c822			; | if STORAGE_SE 
c822			; | dw storage_actl 
c822			; | dw storage_adata 
c822			; | else 
c822			; | dw 0 
c822			; | dw 0 
c822			; | endif 
c822			; | dw storage_append 
c822			; | if STORAGE_SE 
c822			; | dw storage_bctl 
c822			; | else 
c822			; | dw 0 
c822			; | endif 
c822			; | dw store_bank_active 
c822			; | dw store_filecache 
c822			; | dw store_longread 
c822			; | dw store_openaddr 
c822			; | dw store_openext 
c822			; | dw store_openmaxext 
c822			; | ; 60 
c822			; | dw store_page 
c822			; | dw store_readbuf 
c822			; | dw store_readcont 
c822			; | dw store_readptr 
c822			; | dw store_tmpext 
c822			; | dw store_tmpid 
c822			; | dw store_tmppageid 
c822			; | dw malloc 
c822			; | dw free 
c822			; | dw cin 
c822			; | ; 70 
c822			; | dw cin_wait 
c822			; | dw forth_push_numhl 
c822			; | dw forth_push_str 
c822			 
c822					if DEBUG_FORTH_WORDS_KEY 
c822						DMARK "SYM" 
c822 f5				push af  
c823 3a 37 c8			ld a, (.dmark)  
c826 32 6b ee			ld (debug_mark),a  
c829 3a 38 c8			ld a, (.dmark+1)  
c82c 32 6c ee			ld (debug_mark+1),a  
c82f 3a 39 c8			ld a, (.dmark+2)  
c832 32 6d ee			ld (debug_mark+2),a  
c835 18 03			jr .pastdmark  
c837 ..			.dmark: db "SYM"  
c83a f1			.pastdmark: pop af  
c83b			endm  
# End of macro DMARK
c83b						CALLMONITOR 
c83b cd 6f ee			call debug_vector  
c83e				endm  
# End of macro CALLMONITOR
c83e					endif 
c83e			 
c83e					FORTH_DSP_VALUEHL 
c83e cd 42 9d			call macro_dsp_valuehl 
c841				endm 
# End of macro FORTH_DSP_VALUEHL
c841			 
c841 7d					ld a, l     
c842			 
c842			 
c842					if DEBUG_FORTH_WORDS 
c842						DMARK "SY1" 
c842 f5				push af  
c843 3a 57 c8			ld a, (.dmark)  
c846 32 6b ee			ld (debug_mark),a  
c849 3a 58 c8			ld a, (.dmark+1)  
c84c 32 6c ee			ld (debug_mark+1),a  
c84f 3a 59 c8			ld a, (.dmark+2)  
c852 32 6d ee			ld (debug_mark+2),a  
c855 18 03			jr .pastdmark  
c857 ..			.dmark: db "SY1"  
c85a f1			.pastdmark: pop af  
c85b			endm  
# End of macro DMARK
c85b						CALLMONITOR 
c85b cd 6f ee			call debug_vector  
c85e				endm  
# End of macro CALLMONITOR
c85e					endif 
c85e					 
c85e f5					push af	 
c85f					FORTH_DSP_POP 
c85f cd fa 9d			call macro_forth_dsp_pop 
c862				endm 
# End of macro FORTH_DSP_POP
c862 f1					pop af 
c863			 
c863 cb 27				sla a  
c865				 
c865					 
c865					if DEBUG_FORTH_WORDS 
c865						DMARK "SY" 
c865 f5				push af  
c866 3a 7a c8			ld a, (.dmark)  
c869 32 6b ee			ld (debug_mark),a  
c86c 3a 7b c8			ld a, (.dmark+1)  
c86f 32 6c ee			ld (debug_mark+1),a  
c872 3a 7c c8			ld a, (.dmark+2)  
c875 32 6d ee			ld (debug_mark+2),a  
c878 18 02			jr .pastdmark  
c87a ..			.dmark: db "SY"  
c87c f1			.pastdmark: pop af  
c87d			endm  
# End of macro DMARK
c87d						CALLMONITOR 
c87d cd 6f ee			call debug_vector  
c880				endm  
# End of macro CALLMONITOR
c880					endif 
c880			 
c880 21 8f c8				ld hl, sym_table 
c883 cd dc 8c				call addatohl 
c886 cd 7a 9e				call loadwordinhl 
c889 cd 4b 9b				call forth_push_numhl 
c88c			 
c88c			 
c88c				       NEXTW 
c88c c3 f8 9e			jp macro_next 
c88f				endm 
# End of macro NEXTW
c88f			 
c88f			sym_table: 
c88f			 
c88f			; 0 
c88f 8f c8		dw sym_table 
c891 72 ee		dw nmi_vector 
c893 3c ea		dw cli_autodisplay 
c895 ee e9		dw cli_data_sp 
c897 28 e8		dw cli_data_stack 
c899 f0 e9		dw cli_loop_sp 
c89b 2a e9		dw cli_loop_stack 
c89d 28 ea		dw cli_var_array 
c89f c5 eb		dw cursor_col 
c8a1 c3 eb		dw cursor_ptr 
c8a3			; 10 
c8a3 c4 eb		dw cursor_row 
c8a5 6b ee		dw debug_mark 
c8a7 b1 ed		dw display_fb0 
c8a9 10 ed		dw display_fb1 
c8ab ce eb		dw display_fb2 
c8ad 6f ec		dw display_fb3 
c8af cc eb		dw display_fb_active 
c8b1 c0 e3		dw execscratch 
c8b3 5e ea		dw f_cursor_ptr 
c8b5 75 ee		dw hardware_word 
c8b7			;20 
c8b7 62 ee		dw input_at_cursor 
c8b9 64 ee		dw input_at_pos 
c8bb 60 ee		dw input_cur_flash 
c8bd 5f ee		dw input_cur_onoff 
c8bf 55 ee		dw input_cursor 
c8c1 65 ee		dw input_display_size 
c8c3 5a ee		dw input_len 
c8c5 69 ee		dw input_ptr 
c8c7 66 ee		dw input_size 
c8c9 67 ee		dw input_start 
c8cb			; 30 
c8cb 09 8d		dw input_str 
c8cd 63 ee		dw input_under_cursor 
c8cf e8 e5		dw os_cli_cmd 
c8d1 e4 e5		dw os_cur_ptr 
c8d3 e6 e5		dw os_current_i 
c8d5 bf e4		dw os_input 
c8d7 e7 e6		dw os_last_cmd 
c8d9 be e5		dw os_last_new_uword 
c8db 6f ee		dw debug_vector 
c8dd af e2		dw os_view_hl 
c8df			;40 
c8df c6 e5		dw os_word_scratch 
c8e1 c3 00		dw portbctl 
c8e3 c1 00		dw portbdata 
c8e5 63 ea		dw spi_cartdev 
c8e7 62 ea		dw spi_cartdev2 
c8e9 64 ea		dw spi_clktime 
c8eb 60 ea		dw spi_device 
c8ed 5f ea		dw spi_device_id 
c8ef 61 ea		dw spi_portbyte 
c8f1 a7 eb		dw stackstore 
c8f3			; 50 
c8f3			if STORAGE_SE 
c8f3			dw storage_actl 
c8f3			dw storage_adata 
c8f3			else 
c8f3 00 00		dw 0 
c8f5 00 00		dw 0 
c8f7			endif 
c8f7 69 88		dw storage_append 
c8f9			if STORAGE_SE 
c8f9			dw storage_bctl 
c8f9			else 
c8f9 00 00		dw 0 
c8fb			endif 
c8fb 93 eb		dw store_bank_active 
c8fd 67 ea		dw store_filecache 
c8ff 75 ea		dw store_longread 
c901 6b ea		dw store_openaddr 
c903 6a ea		dw store_openext 
c905 69 ea		dw store_openmaxext 
c907			; 60 
c907 7a ea		dw store_page 
c909 76 ea		dw store_readbuf 
c90b 6d ea		dw store_readcont 
c90d 78 ea		dw store_readptr 
c90f 6d ea		dw store_tmpext 
c911 6e ea		dw store_tmpid 
c913 65 ea		dw store_tmppageid 
c915 a3 91		dw malloc 
c917 6d 92		dw free 
c919 ce e3		dw cin 
c91b			; 70 
c91b c8 e3		dw cin_wait 
c91d 4b 9b		dw forth_push_numhl 
c91f b9 9b		dw forth_push_str 
c921			 
c921			 
c921			.ENDCONST: 
c921			 
c921			; eof 
c921			 
c921			 
# End of file forth_words_const.asm
c921			 
c921			if STORAGE_SE 
c921			   	include "forth_words_storage.asm" 
c921			endif 
c921				include "forth_words_device.asm" 
c921			; Device related words 
c921			 
c921			; | ## Device Words 
c921			 
c921			;if SOUND_ENABLE 
c921			;.NOTE: 
c921			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c921			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c921			;		if DEBUG_FORTH_WORDS_KEY 
c921			;			DMARK "NTE" 
c921			;			CALLMONITOR 
c921			;		endif 
c921			; 
c921			;	 
c921			; 
c921			;		NEXTW 
c921			;.AFTERSOUND: 
c921			;endif 
c921			 
c921			 
c921			USE_GPIO: equ 0 
c921			 
c921			if USE_GPIO 
c921			.GP1: 
c921				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c921			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c921					NEXTW 
c921			.GP2: 
c921				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c921			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c921			 
c921					NEXTW 
c921			 
c921			.GP3: 
c921				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c921			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c921			 
c921					NEXTW 
c921			 
c921			.GP4: 
c921				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c921			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c921			 
c921					NEXTW 
c921			.SIN: 
c921			 
c921			 
c921			endif 
c921			 
c921			 
c921				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c921 33				db WORD_SYS_CORE+31             
c922 56 c9			dw .SOUT            
c924 03				db 2 + 1 
c925 .. 00			db "IN",0              
c928				endm 
# End of macro CWHEAD
c928			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c928					if DEBUG_FORTH_WORDS_KEY 
c928						DMARK "IN." 
c928 f5				push af  
c929 3a 3d c9			ld a, (.dmark)  
c92c 32 6b ee			ld (debug_mark),a  
c92f 3a 3e c9			ld a, (.dmark+1)  
c932 32 6c ee			ld (debug_mark+1),a  
c935 3a 3f c9			ld a, (.dmark+2)  
c938 32 6d ee			ld (debug_mark+2),a  
c93b 18 03			jr .pastdmark  
c93d ..			.dmark: db "IN."  
c940 f1			.pastdmark: pop af  
c941			endm  
# End of macro DMARK
c941						CALLMONITOR 
c941 cd 6f ee			call debug_vector  
c944				endm  
# End of macro CALLMONITOR
c944					endif 
c944					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c944 cd 42 9d			call macro_dsp_valuehl 
c947				endm 
# End of macro FORTH_DSP_VALUEHL
c947			 
c947 e5					push hl 
c948			 
c948					; destroy value TOS 
c948			 
c948					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c948 cd fa 9d			call macro_forth_dsp_pop 
c94b				endm 
# End of macro FORTH_DSP_POP
c94b			 
c94b					; one value on hl get other one back 
c94b			 
c94b c1					pop bc 
c94c			 
c94c					; do the sub 
c94c			;		ex de, hl 
c94c			 
c94c ed 68				in l,(c) 
c94e			 
c94e					; save it 
c94e			 
c94e 26 00				ld h,0 
c950			 
c950					; TODO push value back onto stack for another op etc 
c950			 
c950 cd 4b 9b				call forth_push_numhl 
c953					NEXTW 
c953 c3 f8 9e			jp macro_next 
c956				endm 
# End of macro NEXTW
c956			.SOUT: 
c956				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c956 34				db WORD_SYS_CORE+32             
c957 a9 c9			dw .SPIO            
c959 04				db 3 + 1 
c95a .. 00			db "OUT",0              
c95e				endm 
# End of macro CWHEAD
c95e			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c95e					if DEBUG_FORTH_WORDS_KEY 
c95e						DMARK "OUT" 
c95e f5				push af  
c95f 3a 73 c9			ld a, (.dmark)  
c962 32 6b ee			ld (debug_mark),a  
c965 3a 74 c9			ld a, (.dmark+1)  
c968 32 6c ee			ld (debug_mark+1),a  
c96b 3a 75 c9			ld a, (.dmark+2)  
c96e 32 6d ee			ld (debug_mark+2),a  
c971 18 03			jr .pastdmark  
c973 ..			.dmark: db "OUT"  
c976 f1			.pastdmark: pop af  
c977			endm  
# End of macro DMARK
c977						CALLMONITOR 
c977 cd 6f ee			call debug_vector  
c97a				endm  
# End of macro CALLMONITOR
c97a					endif 
c97a			 
c97a					; get port 
c97a			 
c97a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c97a cd 42 9d			call macro_dsp_valuehl 
c97d				endm 
# End of macro FORTH_DSP_VALUEHL
c97d			 
c97d e5					push hl 
c97e			 
c97e					; destroy value TOS 
c97e			 
c97e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c97e cd fa 9d			call macro_forth_dsp_pop 
c981				endm 
# End of macro FORTH_DSP_POP
c981			 
c981					; get byte to send 
c981			 
c981					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c981 cd 42 9d			call macro_dsp_valuehl 
c984				endm 
# End of macro FORTH_DSP_VALUEHL
c984			 
c984			;		push hl 
c984			 
c984					; destroy value TOS 
c984			 
c984					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c984 cd fa 9d			call macro_forth_dsp_pop 
c987				endm 
# End of macro FORTH_DSP_POP
c987			 
c987					; one value on hl get other one back 
c987			 
c987			;		pop hl 
c987			 
c987 c1					pop bc 
c988			 
c988					if DEBUG_FORTH_WORDS 
c988						DMARK "OUT" 
c988 f5				push af  
c989 3a 9d c9			ld a, (.dmark)  
c98c 32 6b ee			ld (debug_mark),a  
c98f 3a 9e c9			ld a, (.dmark+1)  
c992 32 6c ee			ld (debug_mark+1),a  
c995 3a 9f c9			ld a, (.dmark+2)  
c998 32 6d ee			ld (debug_mark+2),a  
c99b 18 03			jr .pastdmark  
c99d ..			.dmark: db "OUT"  
c9a0 f1			.pastdmark: pop af  
c9a1			endm  
# End of macro DMARK
c9a1						CALLMONITOR 
c9a1 cd 6f ee			call debug_vector  
c9a4				endm  
# End of macro CALLMONITOR
c9a4					endif 
c9a4			 
c9a4 ed 69				out (c), l 
c9a6			 
c9a6					NEXTW 
c9a6 c3 f8 9e			jp macro_next 
c9a9				endm 
# End of macro NEXTW
c9a9			 
c9a9			 
c9a9			.SPIO: 
c9a9			 
c9a9			if STORAGE_SE 
c9a9				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c9a9			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c9a9			 
c9a9					call spi_ce_low 
c9a9			    NEXTW 
c9a9			 
c9a9			.SPICEH: 
c9a9				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c9a9			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c9a9			 
c9a9					call spi_ce_high 
c9a9			    NEXTW 
c9a9			 
c9a9			 
c9a9			.SPIOb: 
c9a9			 
c9a9				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c9a9			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c9a9			 
c9a9					if DEBUG_FORTH_WORDS_KEY 
c9a9						DMARK "SPo" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9					; get port 
c9a9			 
c9a9			 
c9a9					; get byte to send 
c9a9			 
c9a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9a9			 
c9a9			;		push hl    ; u1  
c9a9			 
c9a9					; destroy value TOS 
c9a9			 
c9a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9a9			 
c9a9					; one value on hl get other one back 
c9a9			 
c9a9			;		pop hl   ; u2 - addr 
c9a9			 
c9a9					; TODO Send SPI byte 
c9a9			 
c9a9			;		push hl 
c9a9			;		call spi_ce_low 
c9a9			;		pop hl 
c9a9					ld a, l 
c9a9					call spi_send_byte 
c9a9			;		call spi_ce_high 
c9a9			 
c9a9					NEXTW 
c9a9			 
c9a9			.SPII: 
c9a9				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c9a9			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c9a9					if DEBUG_FORTH_WORDS_KEY 
c9a9						DMARK "SPi" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9			 
c9a9					; TODO Get SPI byte 
c9a9			 
c9a9					call spi_read_byte 
c9a9			 
c9a9					if DEBUG_FORTH_WORDS 
c9a9						DMARK "Si2" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9					ld h, 0 
c9a9					ld l, a 
c9a9					if DEBUG_FORTH_WORDS 
c9a9						DMARK "Si3" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9					call forth_push_numhl 
c9a9			 
c9a9					NEXTW 
c9a9			 
c9a9			 
c9a9			 
c9a9			.SESEL: 
c9a9				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c9a9			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c9a9					if DEBUG_FORTH_WORDS_KEY 
c9a9						DMARK "BNK" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9			 
c9a9					ld a, 255 
c9a9					ld (spi_cartdev), a 
c9a9			 
c9a9					; get bank 
c9a9			 
c9a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9a9			 
c9a9			;		push hl 
c9a9			 
c9a9					; destroy value TOS 
c9a9			 
c9a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9a9			 
c9a9					; one value on hl get other one back 
c9a9			 
c9a9			;		pop hl 
c9a9			 
c9a9			 
c9a9					ld c, SPI_CE_HIGH 
c9a9					ld b, '0'    ; human readable bank number 
c9a9			 
c9a9					ld a, l 
c9a9			 
c9a9					if DEBUG_FORTH_WORDS 
c9a9						DMARK "BNK" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9			 
c9a9					; active low 
c9a9			 
c9a9					cp 0 
c9a9					jr z, .bset 
c9a9					cp 1 
c9a9					jr nz, .b2 
c9a9					res 0, c 
c9a9					ld b, '1'    ; human readable bank number 
c9a9			.b2:		cp 2 
c9a9					jr nz, .b3 
c9a9					res 1, c 
c9a9					ld b, '2'    ; human readable bank number 
c9a9			.b3:		cp 3 
c9a9					jr nz, .b4 
c9a9					res 2, c 
c9a9					ld b, '3'    ; human readable bank number 
c9a9			.b4:		cp 4 
c9a9					jr nz, .b5 
c9a9					res 3, c 
c9a9					ld b, '4'    ; human readable bank number 
c9a9			.b5:		cp 5 
c9a9					jr nz, .bset 
c9a9					res 4, c 
c9a9					ld b, '5'    ; human readable bank number 
c9a9			 
c9a9			.bset: 
c9a9					ld a, c 
c9a9					ld (spi_device),a 
c9a9					ld a, b 
c9a9					ld (spi_device_id),a 
c9a9					if DEBUG_FORTH_WORDS 
c9a9						DMARK "BN2" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9			 
c9a9					; set default SPI clk pulse time as disabled for BANK use 
c9a9			 
c9a9					ld a, 0 
c9a9					ld (spi_clktime), a 
c9a9			 
c9a9					NEXTW 
c9a9			 
c9a9			.CARTDEV: 
c9a9				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c9a9			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c9a9					if DEBUG_FORTH_WORDS_KEY 
c9a9						DMARK "CDV" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9			 
c9a9					; disable se storage bank selection 
c9a9			 
c9a9					ld a, SPI_CE_HIGH		; ce high 
c9a9					ld (spi_device), a 
c9a9			 
c9a9					; get bank 
c9a9			 
c9a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9a9			 
c9a9			;		push hl 
c9a9			 
c9a9					; destroy value TOS 
c9a9			 
c9a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9a9			 
c9a9					; one value on hl get other one back 
c9a9			 
c9a9			;		pop hl 
c9a9			 
c9a9					; active low 
c9a9			 
c9a9					ld c, 255 
c9a9			 
c9a9					ld a, l 
c9a9					if DEBUG_FORTH_WORDS 
c9a9						DMARK "CDV" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9					cp 0 
c9a9					jr z, .cset 
c9a9					cp 1 
c9a9					jr nz, .c2 
c9a9					res 0, c 
c9a9			.c2:		cp 2 
c9a9					jr nz, .c3 
c9a9					res 1, c 
c9a9			.c3:		cp 3 
c9a9					jr nz, .c4 
c9a9					res 2, c 
c9a9			.c4:		cp 4 
c9a9					jr nz, .c5 
c9a9					res 3, c 
c9a9			.c5:		cp 5 
c9a9					jr nz, .c6 
c9a9					res 4, c 
c9a9			.c6:		cp 6 
c9a9					jr nz, .c7 
c9a9					res 5, c 
c9a9			.c7:		cp 7 
c9a9					jr nz, .c8 
c9a9					res 6, c 
c9a9			.c8:		cp 8 
c9a9					jr nz, .cset 
c9a9					res 7, c 
c9a9			.cset:		ld a, c 
c9a9					ld (spi_cartdev),a 
c9a9			 
c9a9					if DEBUG_FORTH_WORDS 
c9a9						DMARK "CD2" 
c9a9						CALLMONITOR 
c9a9					endif 
c9a9			 
c9a9					; set default SPI clk pulse time as 10ms for CARTDEV use 
c9a9			 
c9a9					ld a, $0a 
c9a9					ld (spi_clktime), a 
c9a9					NEXTW 
c9a9			endif 
c9a9			 
c9a9			.ENDDEVICE: 
c9a9			; eof 
c9a9			 
# End of file forth_words_device.asm
c9a9			 
c9a9			; var handler 
c9a9			 
c9a9			 
c9a9			.VARS: 
c9a9				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c9a9 77				db WORD_SYS_CORE+99             
c9aa 5a ca			dw .V0            
c9ac 04				db 3 + 1 
c9ad .. 00			db "VAR",0              
c9b1				endm 
# End of macro CWHEAD
c9b1			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c9b1			;| 
c9b1			;| The variable name should consist of a single letter. e.g. "a" 
c9b1			;! If a full string is passed then only the first char is looked at 
c9b1			;| Any other char could exceed bounds checks!  
c9b1			 
c9b1					if DEBUG_FORTH_WORDS_KEY 
c9b1						DMARK "VAR" 
c9b1 f5				push af  
c9b2 3a c6 c9			ld a, (.dmark)  
c9b5 32 6b ee			ld (debug_mark),a  
c9b8 3a c7 c9			ld a, (.dmark+1)  
c9bb 32 6c ee			ld (debug_mark+1),a  
c9be 3a c8 c9			ld a, (.dmark+2)  
c9c1 32 6d ee			ld (debug_mark+2),a  
c9c4 18 03			jr .pastdmark  
c9c6 ..			.dmark: db "VAR"  
c9c9 f1			.pastdmark: pop af  
c9ca			endm  
# End of macro DMARK
c9ca						CALLMONITOR 
c9ca cd 6f ee			call debug_vector  
c9cd				endm  
# End of macro CALLMONITOR
c9cd					endif 
c9cd			 
c9cd					FORTH_DSP_VALUEHL 
c9cd cd 42 9d			call macro_dsp_valuehl 
c9d0				endm 
# End of macro FORTH_DSP_VALUEHL
c9d0			 
c9d0 7e					ld a, (hl)    ; get first char on of the string 
c9d1			 
c9d1			 
c9d1					if DEBUG_FORTH_WORDS 
c9d1						DMARK "VR1" 
c9d1 f5				push af  
c9d2 3a e6 c9			ld a, (.dmark)  
c9d5 32 6b ee			ld (debug_mark),a  
c9d8 3a e7 c9			ld a, (.dmark+1)  
c9db 32 6c ee			ld (debug_mark+1),a  
c9de 3a e8 c9			ld a, (.dmark+2)  
c9e1 32 6d ee			ld (debug_mark+2),a  
c9e4 18 03			jr .pastdmark  
c9e6 ..			.dmark: db "VR1"  
c9e9 f1			.pastdmark: pop af  
c9ea			endm  
# End of macro DMARK
c9ea						CALLMONITOR 
c9ea cd 6f ee			call debug_vector  
c9ed				endm  
# End of macro CALLMONITOR
c9ed					endif 
c9ed					 
c9ed f5					push af	 
c9ee					FORTH_DSP_POP 
c9ee cd fa 9d			call macro_forth_dsp_pop 
c9f1				endm 
# End of macro FORTH_DSP_POP
c9f1 f1					pop af 
c9f2			 
c9f2					; convert to upper 
c9f2			 
c9f2 cd 49 90				call to_upper 
c9f5					if DEBUG_FORTH_WORDS 
c9f5						DMARK "Vaa" 
c9f5 f5				push af  
c9f6 3a 0a ca			ld a, (.dmark)  
c9f9 32 6b ee			ld (debug_mark),a  
c9fc 3a 0b ca			ld a, (.dmark+1)  
c9ff 32 6c ee			ld (debug_mark+1),a  
ca02 3a 0c ca			ld a, (.dmark+2)  
ca05 32 6d ee			ld (debug_mark+2),a  
ca08 18 03			jr .pastdmark  
ca0a ..			.dmark: db "Vaa"  
ca0d f1			.pastdmark: pop af  
ca0e			endm  
# End of macro DMARK
ca0e						CALLMONITOR 
ca0e cd 6f ee			call debug_vector  
ca11				endm  
# End of macro CALLMONITOR
ca11					endif 
ca11 06 41				ld b, 'A' 
ca13 90					sub b			; set offset 
ca14					if DEBUG_FORTH_WORDS 
ca14						DMARK "Vbb" 
ca14 f5				push af  
ca15 3a 29 ca			ld a, (.dmark)  
ca18 32 6b ee			ld (debug_mark),a  
ca1b 3a 2a ca			ld a, (.dmark+1)  
ca1e 32 6c ee			ld (debug_mark+1),a  
ca21 3a 2b ca			ld a, (.dmark+2)  
ca24 32 6d ee			ld (debug_mark+2),a  
ca27 18 03			jr .pastdmark  
ca29 ..			.dmark: db "Vbb"  
ca2c f1			.pastdmark: pop af  
ca2d			endm  
# End of macro DMARK
ca2d						CALLMONITOR 
ca2d cd 6f ee			call debug_vector  
ca30				endm  
# End of macro CALLMONITOR
ca30					endif 
ca30 cb 27				sla a  
ca32				 
ca32					 
ca32					if DEBUG_FORTH_WORDS 
ca32						DMARK "VR2" 
ca32 f5				push af  
ca33 3a 47 ca			ld a, (.dmark)  
ca36 32 6b ee			ld (debug_mark),a  
ca39 3a 48 ca			ld a, (.dmark+1)  
ca3c 32 6c ee			ld (debug_mark+1),a  
ca3f 3a 49 ca			ld a, (.dmark+2)  
ca42 32 6d ee			ld (debug_mark+2),a  
ca45 18 03			jr .pastdmark  
ca47 ..			.dmark: db "VR2"  
ca4a f1			.pastdmark: pop af  
ca4b			endm  
# End of macro DMARK
ca4b						CALLMONITOR 
ca4b cd 6f ee			call debug_vector  
ca4e				endm  
# End of macro CALLMONITOR
ca4e					endif 
ca4e			 
ca4e 21 f4 e9				ld hl, cli_var_array2 
ca51 cd dc 8c				call addatohl 
ca54 cd 4b 9b				call forth_push_numhl 
ca57			 
ca57			 
ca57				       NEXTW 
ca57 c3 f8 9e			jp macro_next 
ca5a				endm 
# End of macro NEXTW
ca5a			.V0: 
ca5a				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ca5a 78				db WORD_SYS_CORE+100             
ca5b 72 ca			dw .V0Q            
ca5d 04				db 3 + 1 
ca5e .. 00			db "V0!",0              
ca62				endm 
# End of macro CWHEAD
ca62			;| V0! ( u1 -- )  Store value to v0  | DONE 
ca62			 
ca62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca62 cd 42 9d			call macro_dsp_valuehl 
ca65				endm 
# End of macro FORTH_DSP_VALUEHL
ca65			 
ca65 11 28 ea				ld de, cli_var_array 
ca68			 
ca68 eb					ex de, hl 
ca69 73					ld (hl), e 
ca6a 23					inc hl 
ca6b 72					ld (hl), d 
ca6c			 
ca6c					; destroy value TOS 
ca6c			 
ca6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca6c cd fa 9d			call macro_forth_dsp_pop 
ca6f				endm 
# End of macro FORTH_DSP_POP
ca6f			 
ca6f				       NEXTW 
ca6f c3 f8 9e			jp macro_next 
ca72				endm 
# End of macro NEXTW
ca72			.V0Q: 
ca72				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
ca72 79				db WORD_SYS_CORE+101             
ca73 83 ca			dw .V1S            
ca75 04				db 3 + 1 
ca76 .. 00			db "V0@",0              
ca7a				endm 
# End of macro CWHEAD
ca7a			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
ca7a 2a 28 ea				ld hl, (cli_var_array) 
ca7d cd 4b 9b				call forth_push_numhl 
ca80			 
ca80				       NEXTW 
ca80 c3 f8 9e			jp macro_next 
ca83				endm 
# End of macro NEXTW
ca83			.V1S: 
ca83				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
ca83 7a				db WORD_SYS_CORE+102             
ca84 9b ca			dw .V1Q            
ca86 04				db 3 + 1 
ca87 .. 00			db "V1!",0              
ca8b				endm 
# End of macro CWHEAD
ca8b			;| V1! ( u1 -- )  Store value to v1 | DONE 
ca8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca8b cd 42 9d			call macro_dsp_valuehl 
ca8e				endm 
# End of macro FORTH_DSP_VALUEHL
ca8e			 
ca8e 11 2a ea				ld de, cli_var_array+2 
ca91				 
ca91 eb					ex de, hl 
ca92 73					ld (hl), e 
ca93 23					inc hl 
ca94 72					ld (hl), d 
ca95			 
ca95					; destroy value TOS 
ca95			 
ca95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca95 cd fa 9d			call macro_forth_dsp_pop 
ca98				endm 
# End of macro FORTH_DSP_POP
ca98				       NEXTW 
ca98 c3 f8 9e			jp macro_next 
ca9b				endm 
# End of macro NEXTW
ca9b			.V1Q: 
ca9b				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
ca9b 7b				db WORD_SYS_CORE+103             
ca9c ac ca			dw .V2S            
ca9e 04				db 3 + 1 
ca9f .. 00			db "V1@",0              
caa3				endm 
# End of macro CWHEAD
caa3			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
caa3 2a 2a ea				ld hl, (cli_var_array+2) 
caa6 cd 4b 9b				call forth_push_numhl 
caa9				       NEXTW 
caa9 c3 f8 9e			jp macro_next 
caac				endm 
# End of macro NEXTW
caac			.V2S: 
caac				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
caac 7c				db WORD_SYS_CORE+104             
caad c4 ca			dw .V2Q            
caaf 04				db 3 + 1 
cab0 .. 00			db "V2!",0              
cab4				endm 
# End of macro CWHEAD
cab4			;| V2! ( u1 -- )  Store value to v2 | DONE 
cab4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cab4 cd 42 9d			call macro_dsp_valuehl 
cab7				endm 
# End of macro FORTH_DSP_VALUEHL
cab7			 
cab7 11 2c ea				ld de, cli_var_array+4 
caba				 
caba eb					ex de, hl 
cabb 73					ld (hl), e 
cabc 23					inc hl 
cabd 72					ld (hl), d 
cabe			 
cabe					; destroy value TOS 
cabe			 
cabe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cabe cd fa 9d			call macro_forth_dsp_pop 
cac1				endm 
# End of macro FORTH_DSP_POP
cac1				       NEXTW 
cac1 c3 f8 9e			jp macro_next 
cac4				endm 
# End of macro NEXTW
cac4			.V2Q: 
cac4				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cac4 7d				db WORD_SYS_CORE+105             
cac5 d5 ca			dw .V3S            
cac7 04				db 3 + 1 
cac8 .. 00			db "V2@",0              
cacc				endm 
# End of macro CWHEAD
cacc			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cacc 2a 2c ea				ld hl, (cli_var_array+4) 
cacf cd 4b 9b				call forth_push_numhl 
cad2				       NEXTW 
cad2 c3 f8 9e			jp macro_next 
cad5				endm 
# End of macro NEXTW
cad5			.V3S: 
cad5				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cad5 7c				db WORD_SYS_CORE+104             
cad6 ed ca			dw .V3Q            
cad8 04				db 3 + 1 
cad9 .. 00			db "V3!",0              
cadd				endm 
# End of macro CWHEAD
cadd			;| V3! ( u1 -- )  Store value to v3 | DONE 
cadd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cadd cd 42 9d			call macro_dsp_valuehl 
cae0				endm 
# End of macro FORTH_DSP_VALUEHL
cae0			 
cae0 11 2e ea				ld de, cli_var_array+6 
cae3				 
cae3 eb					ex de, hl 
cae4 73					ld (hl), e 
cae5 23					inc hl 
cae6 72					ld (hl), d 
cae7			 
cae7					; destroy value TOS 
cae7			 
cae7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cae7 cd fa 9d			call macro_forth_dsp_pop 
caea				endm 
# End of macro FORTH_DSP_POP
caea				       NEXTW 
caea c3 f8 9e			jp macro_next 
caed				endm 
# End of macro NEXTW
caed			.V3Q: 
caed				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
caed 7d				db WORD_SYS_CORE+105             
caee fe ca			dw .END            
caf0 04				db 3 + 1 
caf1 .. 00			db "V3@",0              
caf5				endm 
# End of macro CWHEAD
caf5			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
caf5 2a 2e ea				ld hl, (cli_var_array+6) 
caf8 cd 4b 9b				call forth_push_numhl 
cafb				       NEXTW 
cafb c3 f8 9e			jp macro_next 
cafe				endm 
# End of macro NEXTW
cafe			 
cafe			 
cafe			 
cafe			 
cafe			 
cafe			; end of dict marker 
cafe			 
cafe 00			.END:    db WORD_SYS_END 
caff 00 00			dw 0 
cb01 00				db 0 
cb02			 
cb02			; use to jp here for user dict words to save on macro expansion  
cb02			 
cb02			user_dict_next: 
cb02				NEXTW 
cb02 c3 f8 9e			jp macro_next 
cb05				endm 
# End of macro NEXTW
cb05			 
cb05			 
cb05			user_exec: 
cb05				;    ld hl, <word code> 
cb05				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb05				;    call forthexec 
cb05				;    jp user_dict_next   (NEXT) 
cb05			        ;    <word code bytes> 
cb05 eb				ex de, hl 
cb06 2a c2 e5			ld hl,(os_tok_ptr) 
cb09				 
cb09				FORTH_RSP_NEXT 
cb09 cd f2 9a			call macro_forth_rsp_next 
cb0c				endm 
# End of macro FORTH_RSP_NEXT
cb0c			 
cb0c			if DEBUG_FORTH_UWORD 
cb0c						DMARK "UEX" 
cb0c f5				push af  
cb0d 3a 21 cb			ld a, (.dmark)  
cb10 32 6b ee			ld (debug_mark),a  
cb13 3a 22 cb			ld a, (.dmark+1)  
cb16 32 6c ee			ld (debug_mark+1),a  
cb19 3a 23 cb			ld a, (.dmark+2)  
cb1c 32 6d ee			ld (debug_mark+2),a  
cb1f 18 03			jr .pastdmark  
cb21 ..			.dmark: db "UEX"  
cb24 f1			.pastdmark: pop af  
cb25			endm  
# End of macro DMARK
cb25				CALLMONITOR 
cb25 cd 6f ee			call debug_vector  
cb28				endm  
# End of macro CALLMONITOR
cb28			endif 
cb28			 
cb28			 
cb28			 
cb28 eb				ex de, hl 
cb29 22 c2 e5			ld (os_tok_ptr), hl 
cb2c				 
cb2c				; Don't use next - Skips the first word in uword. 
cb2c			 
cb2c c3 89 9f			jp exec1 
cb2f			;	NEXT 
cb2f			 
cb2f			 
cb2f			; eof 
# End of file forth_wordsv4.asm
cb2f			endif 
cb2f			;;;;;;;;;;;;;; Debug code 
cb2f			 
cb2f			 
cb2f			;if DEBUG_FORTH_PARSE 
cb2f .. 00		.nowordfound: db "No match",0 
cb38 .. 00		.compword:	db "Comparing word ",0 
cb48 .. 00		.nextwordat:	db "Next word at",0 
cb55 .. 00		.charmatch:	db "Char match",0 
cb60			;endif 
cb60			if DEBUG_FORTH_JP 
cb60			.foundword:	db "Word match. Exec..",0 
cb60			endif 
cb60			;if DEBUG_FORTH_PUSH 
cb60 .. 00		.enddict:	db "Dict end. Push.",0 
cb70 .. 00		.push_str:	db "Pushing string",0 
cb7f .. 00		.push_num:	db "Pushing number",0 
cb8e .. 00		.data_sp:	db "SP:",0 
cb92 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cba4 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cbb6 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cbc8			;endif 
cbc8			;if DEBUG_FORTH_MALLOC 
cbc8 .. 00		.push_malloc:	db "Malloc address",0 
cbd7			;endif 
cbd7			 
cbd7			 
cbd7			 
cbd7			; display malloc address and current data stack pointer  
cbd7			 
cbd7			malloc_error: 
cbd7 d5				push de 
cbd8 f5				push af 
cbd9 e5				push hl 
cbda cd af 8a			call clear_display 
cbdd 11 fd cb			ld de, .mallocerr 
cbe0 3e 00			ld a,0 
cbe2			;	ld de,os_word_scratch 
cbe2 cd c2 8a			call str_at_display 
cbe5 3e 11			ld a, display_row_1+17 
cbe7 11 6b ee			ld de, debug_mark 
cbea cd c2 8a			call str_at_display 
cbed cd d2 8a			call update_display 
cbf0				;call break_point_state 
cbf0 cd c8 e3			call cin_wait 
cbf3			 
cbf3			;	ld a, ' ' 
cbf3			;	ld (os_view_disable), a 
cbf3 cd d2 94			call bp_on 
cbf6 e1				pop hl 
cbf7 f1				pop af 
cbf8 d1				pop de	 
cbf9				CALLMONITOR 
cbf9 cd 6f ee			call debug_vector  
cbfc				endm  
# End of macro CALLMONITOR
cbfc c9				ret 
cbfd			 
cbfd .. 00		.mallocerr: 	db "Malloc Error",0 
cc0a			;if DEBUG_FORTH_PUSH 
cc0a			display_data_sp: 
cc0a f5				push af 
cc0b			 
cc0b				; see if disabled 
cc0b			 
cc0b			 
cc0b 3a 6f ee			ld a, (debug_vector) 
cc0e fe c9			cp $C9  ; RET 
cc10				;ld a, (os_view_disable) 
cc10				;cp '*' 
cc10 28 67			jr z, .skipdsp 
cc12			 
cc12 e5				push hl 
cc13 e5				push hl 
cc14 e5			push hl 
cc15 cd af 8a			call clear_display 
cc18 e1			pop hl 
cc19 7c				ld a,h 
cc1a 21 c6 e5			ld hl, os_word_scratch 
cc1d cd dd 8f			call hexout 
cc20 e1				pop hl 
cc21 7d				ld a,l 
cc22 21 c8 e5			ld hl, os_word_scratch+2 
cc25 cd dd 8f			call hexout 
cc28 21 ca e5			ld hl, os_word_scratch+4 
cc2b 3e 00			ld a,0 
cc2d 77				ld (hl),a 
cc2e 11 c6 e5			ld de,os_word_scratch 
cc31 3e 28				ld a, display_row_2 
cc33 cd c2 8a				call str_at_display 
cc36 11 92 cb			ld de, .wordinhl 
cc39 3e 00			ld a, display_row_1 
cc3b			 
cc3b cd c2 8a				call str_at_display 
cc3e 11 6b ee			ld de, debug_mark 
cc41 3e 11			ld a, display_row_1+17 
cc43			 
cc43 cd c2 8a				call str_at_display 
cc46			 
cc46				; display current data stack pointer 
cc46 11 8e cb			ld de,.data_sp 
cc49 3e 30				ld a, display_row_2 + 8 
cc4b cd c2 8a				call str_at_display 
cc4e			 
cc4e 2a ee e9			ld hl,(cli_data_sp) 
cc51 e5				push hl 
cc52 7c				ld a,h 
cc53 21 c6 e5			ld hl, os_word_scratch 
cc56 cd dd 8f			call hexout 
cc59 e1				pop hl 
cc5a 7d				ld a,l 
cc5b 21 c8 e5			ld hl, os_word_scratch+2 
cc5e cd dd 8f			call hexout 
cc61 21 ca e5			ld hl, os_word_scratch+4 
cc64 3e 00			ld a,0 
cc66 77				ld (hl),a 
cc67 11 c6 e5			ld de,os_word_scratch 
cc6a 3e 33				ld a, display_row_2 + 11 
cc6c cd c2 8a				call str_at_display 
cc6f			 
cc6f			 
cc6f cd d2 8a			call update_display 
cc72 cd f2 89			call delay1s 
cc75 cd f2 89			call delay1s 
cc78 e1				pop hl 
cc79			.skipdsp: 
cc79 f1				pop af 
cc7a c9				ret 
cc7b			 
cc7b			display_data_malloc: 
cc7b			 
cc7b f5				push af 
cc7c e5				push hl 
cc7d e5				push hl 
cc7e e5			push hl 
cc7f cd af 8a			call clear_display 
cc82 e1			pop hl 
cc83 7c				ld a,h 
cc84 21 c6 e5			ld hl, os_word_scratch 
cc87 cd dd 8f			call hexout 
cc8a e1				pop hl 
cc8b 7d				ld a,l 
cc8c 21 c8 e5			ld hl, os_word_scratch+2 
cc8f cd dd 8f			call hexout 
cc92 21 ca e5			ld hl, os_word_scratch+4 
cc95 3e 00			ld a,0 
cc97 77				ld (hl),a 
cc98 11 c6 e5			ld de,os_word_scratch 
cc9b 3e 28				ld a, display_row_2 
cc9d cd c2 8a				call str_at_display 
cca0 11 c8 cb			ld de, .push_malloc 
cca3 3e 00			ld a, display_row_1 
cca5			 
cca5 cd c2 8a				call str_at_display 
cca8			 
cca8				; display current data stack pointer 
cca8 11 8e cb			ld de,.data_sp 
ccab 3e 30				ld a, display_row_2 + 8 
ccad cd c2 8a				call str_at_display 
ccb0			 
ccb0 2a ee e9			ld hl,(cli_data_sp) 
ccb3 e5				push hl 
ccb4 7c				ld a,h 
ccb5 21 c6 e5			ld hl, os_word_scratch 
ccb8 cd dd 8f			call hexout 
ccbb e1				pop hl 
ccbc 7d				ld a,l 
ccbd 21 c8 e5			ld hl, os_word_scratch+2 
ccc0 cd dd 8f			call hexout 
ccc3 21 ca e5			ld hl, os_word_scratch+4 
ccc6 3e 00			ld a,0 
ccc8 77				ld (hl),a 
ccc9 11 c6 e5			ld de,os_word_scratch 
cccc 3e 33				ld a, display_row_2 + 11 
ccce cd c2 8a				call str_at_display 
ccd1			 
ccd1 cd d2 8a			call update_display 
ccd4 cd f2 89			call delay1s 
ccd7 cd f2 89			call delay1s 
ccda e1				pop hl 
ccdb f1				pop af 
ccdc c9				ret 
ccdd			;endif 
ccdd			 
ccdd			include "forth_autostart.asm" 
ccdd			; list of commands to perform at system start up 
ccdd			 
ccdd			startcmds: 
ccdd			;	dw test11 
ccdd			;	dw test12 
ccdd			;	dw test13 
ccdd			;	dw test14 
ccdd			;	dw test15 
ccdd			;	dw test16 
ccdd			;	dw test17 
ccdd			;	dw ifthtest1 
ccdd			;	dw ifthtest2 
ccdd			;	dw ifthtest3 
ccdd			;	dw mmtest1 
ccdd			;	dw mmtest2 
ccdd			;	dw mmtest3 
ccdd			;	dw mmtest4 
ccdd			;	dw mmtest5 
ccdd			;	dw mmtest6 
ccdd			;	dw iftest1 
ccdd			;	dw iftest2 
ccdd			;	dw iftest3 
ccdd			;	dw looptest1 
ccdd			;	dw looptest2 
ccdd			;	dw test1 
ccdd			;	dw test2 
ccdd			;	dw test3 
ccdd			;	dw test4 
ccdd			;	dw game2r 
ccdd			;	dw game2b1 
ccdd			;	dw game2b2 
ccdd			 
ccdd				; start up words that are actually useful 
ccdd			 
ccdd			;    dw spi1 
ccdd			;    dw spi2 
ccdd			;    dw spi3 
ccdd			;    dw spi4 
ccdd			;    dw spi5 
ccdd			;    dw spi6 
ccdd			;    dw spi7 
ccdd			; 
ccdd			;    dw spi8 
ccdd			;    dw spi9 
ccdd			;    dw spi10 
ccdd			 
ccdd			; file editor 
ccdd			;	dw edit1 
ccdd			;	dw edit2 
ccdd			;	dw edit3 
ccdd			 
ccdd			;	dw longread 
ccdd dd d0			dw clrstack 
ccdf 11 d1			dw type 
cce1			;	dw stest 
cce1 36 d1			dw strncpy 
cce3			;	dw list 
cce3 97 d1			dw start1 
cce5 a7 d1			dw start2 
cce7			;	dw start3 
cce7			;	dw start3b 
cce7			;	dw start3c 
cce7			 
cce7				; (unit) testing words 
cce7			 
cce7			;	dw mtesta 
cce7			;	dw mtestb 
cce7			;	dw mtestc 
cce7			;	dw mtestd 
cce7			;	dw mteste 
cce7			 
cce7				; demo/game words 
cce7			 
cce7			;        dw game3w 
cce7			;        dw game3p 
cce7			;        dw game3sc 
cce7			;        dw game3vsi 
cce7			;        dw game3vs 
cce7				 
cce7 00 dc			dw game2b 
cce9 6e dc			dw game2bf 
cceb b8 dc			dw game2mba 
cced 4e dd			dw game2mbas 
ccef 90 dd			dw game2mb 
ccf1			 
ccf1 c1 d8			dw game1 
ccf3 d2 d8			dw game1a 
ccf5 34 d9			dw game1b 
ccf7 69 d9			dw game1c 
ccf9 9f d9			dw game1d 
ccfb d0 d9			dw game1s 
ccfd e4 d9			dw game1t 
ccff f9 d9			dw game1f 
cd01 2d da			dw game1z 
cd03 71 da			dw game1zz 
cd05			 
cd05 db d6			dw test5 
cd07 13 d7			dw test6 
cd09 4b d7			dw test7 
cd0b 5f d7			dw test8 
cd0d 8b d7			dw test9 
cd0f a1 d7			dw test10 
cd11				 
cd11 48 db		        dw ssv5 
cd13 2c db		        dw ssv4 
cd15 10 db		        dw ssv3 
cd17 da da		        dw ssv2 
cd19 61 db		        dw ssv1 
cd1b a9 db		        dw ssv1cpm 
cd1d			;	dw keyup 
cd1d			;	dw keydown 
cd1d			;	dw keyleft 
cd1d			;	dw keyright 
cd1d			;	dw 	keyf1 
cd1d			;	dw keyf2 
cd1d			;	dw keyf3 
cd1d			;	dw keyf4 
cd1d			;	dw keyf5 
cd1d			;	dw keyf6 
cd1d			;	dw keyf7 
cd1d			;	dw keyf8 
cd1d			;	dw keyf9 
cd1d			;	dw keyf10 
cd1d			;	dw keyf11 
cd1d			;	dw keyf12 
cd1d			;	dw keytab 
cd1d			;	dw keycr 
cd1d			;	dw keyhome 
cd1d			;	dw keyend 
cd1d			;	dw keybs 
cd1d 00 00			db 0, 0	 
cd1f			 
cd1f			 
cd1f			; File Editor 
cd1f			 
cd1f			; ( id - ) use 'e' to edit the displayed line 
cd1f .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cd40 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd75			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd75 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cdad			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cdad			 
cdad			; SPI Net support words 
cdad			 
cdad			; v0! = node to send to 
cdad			; ( str count - ) 
cdad .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce06			 
ce06			; spiputchr ( char node - ) 
ce06 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce3c			 
ce3c			; spigetchr ( - n ) 
ce3c .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
ce67			 
ce67			; getnode ( - n ) 
ce67 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
ce94			 
ce94			; ( str node - )  
ce94 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cefa			; store string ( str i - ) 
cefa			 
cefa			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cefa .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cf4f			 
cf4f			; get string ( addr i -  )    TO FIX 
cf4f			 
cf4f .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
cfa7			 
cfa7			 
cfa7			; NETCHAT (TODO) 
cfa7			; Program to allow two nodes to chat with eachother 
cfa7			; 
cfa7			; v0 - target node 
cfa7			;  
cfa7			; accept input at 0,0 
cfa7			; if input is string send spitype to target node 
cfa7			; starting at row 2,0 , while spigetchr is not zero ->  
cfa7			; 
cfa7			; 
cfa7			; TODO add paging of get request 
cfa7			 
cfa7			; ( node - ) 
cfa7 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
cfc6 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d01e .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d096			 
d096			 
d096			; Long read of currently open file 
d096 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d0dd			 
d0dd			; clear stack  
d0dd			 
d0dd .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d111			 
d111			; type ( addr count - ) 
d111 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d136			 
d136			; some direct memory words 
d136			; strncpy ( len t f -- t ) 
d136			 
d136 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d197			 
d197 .. 00		start1:     	db ": bpon $00 bp ;",0 
d1a7 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d1b8 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d233 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d293			 
d293			 
d293			; a handy word to list items on the stack 
d293			 
d293 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d2fd			 
d2fd			 
d2fd			; test stack  
d2fd			; rnd8 stest 
d2fd			 
d2fd .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d374			 
d374			; random malloc and free cycles 
d374			 
d374 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d429			 
d429			; fixed malloc and free cycles 
d429			 
d429 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d4cc			 
d4cc			; fixed double string push and drop cycle  
d4cc			 
d4cc .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d581			 
d581			; consistent fixed string push and drop cycle  
d581			 
d581 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d625			 
d625 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d6db			 
d6db			;test1:		db ": aa 1 2 3 ;", 0 
d6db			;test2:     	db "111 aa 888 999",0 
d6db			;test3:     	db ": bb 77 ;",0 
d6db			;test4:     	db "$02 $01 do i . loop bb",0 
d6db			 
d6db .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d713 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d74b .. 00		test7:     	db ": box hline vline ;",0 
d75f .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d78b .. 00		test9:     	db ": sw $01 adsp world ;",0 
d7a1 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d7c6 .. 00		test11:     	db "hello create .",0 
d7d5 .. 00		test12:     	db "hello2 create .",0 
d7e5			 
d7e5			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d7e5			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d7e5			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d7e5			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d7e5			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d7e5			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d7e5			 
d7e5			;iftest1:     	db "$0001 IF cls .",0 
d7e5			;iftest2:     	db "$0000 IF cls .",0 
d7e5			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d7e5			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d7e5			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d7e5			 
d7e5			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d7e5			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d7e5			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d7e5			 
d7e5			 
d7e5 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d809 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d839 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d85e .. 00		sound4: db ": cha $00 ; ",0 
d86b .. 00		sound5: db ": chb $20 ; ",0 
d878 .. 00		sound6: db ": chc $40 ; ",0 
d885 .. 00		sound7: db ": chd $60 ; ",0 
d892 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d8aa .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d8c1			 
d8c1			 
d8c1			 
d8c1			 
d8c1			; a small guess the number game 
d8c1			 
d8c1 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d8d2 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d934			 
d934 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d969 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d99f .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d9d0 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d9e4 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d9f9 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
da2d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
da71			 
da71			; Using 'ga' save a high score across multiple runs using external storage 
da71			 
da71 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
dada			 
dada			 
dada			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
dada			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
dada			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
dada			 
dada			; simple screen saver to test code memory reuse to destruction 
dada			 
dada .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
db10 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
db2c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
db48 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
db61 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dba9 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dc00			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc00			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dc00			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dc00			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dc00			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dc00			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dc00			 
dc00			 
dc00			 
dc00			; minesweeper/battleship finding game 
dc00			; draws a game board of random ship/mine positions 
dc00			; user enters coords to see if it hits on 
dc00			; game ends when all are hit 
dc00			; when hit or miss says how many may be in the area 
dc00			 
dc00			; setup the game board and then hide it 
dc00 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dc6e .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dcb8			; prompt for where to target 
dcb8 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dd4e .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
dd73			; TODO see if the entered coords hits or misses pushes char hit of miss 
dd73 .. 00		game2mbht:      db ": mbckht nop ;",0 
dd82 .. 00		game2mbms:      db ": mbcms nop ;",0 
dd90			; TODO how many might be near by 
dd90 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
de0d			 
de0d			; Game 3 
de0d			 
de0d			; Vert scroller ski game - avoid the trees! 
de0d			 
de0d			; v0 score (ie turns) 
de0d			; v1 player pos 
de0d			; v2 left wall 
de0d			; v3 right wall 
de0d			 
de0d			; Draw side walls randomly 
de0d			 
de0d .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
de3b			 
de3b			; Draw player 
de3b .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
de59			 
de59			; TODO Get Key 
de59			 
de59			; TODO Move left right 
de59			 
de59			; scroll and move walls a bit 
de59			 
de59 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
de8a			 
de8a			; main game loop 
de8a			 
de8a .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
deb6 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
def5			 
def5			; key board defs 
def5			 
def5 .. 00		keyup:       db ": keyup $05 ;",0 
df03 .. 00		keydown:       db ": keydown $0a ;",0 
df13 .. 00		keyleft:       db ": keyleft $0b ;",0 
df23 .. 00		keyright:       db ": keyright $0c ;",0 
df34 .. 00		keyf1:       db ": keyf1 $10 ;",0 
df42 .. 00		keyf2:       db ": keyf2 $11 ;",0 
df50 .. 00		keyf3:       db ": keyf3 $12 ;",0 
df5e .. 00		keyf4:       db ": keyf4 $13 ;",0 
df6c .. 00		keyf5:       db ": keyf5 $14 ;",0 
df7a .. 00		keyf6:       db ": keyf6 $15 ;",0 
df88 .. 00		keyf7:       db ": keyf7 $16 ;",0 
df96 .. 00		keyf8:       db ": keyf8 $17 ;",0 
dfa4 .. 00		keyf9:       db ": keyf9 $18 ;",0 
dfb2 .. 00		keyf10:       db ": keyf10 $19 ;",0 
dfc1 .. 00		keyf11:       db ": keyf11 $1a ;",0 
dfd0 .. 00		keyf12:       db ": keyf12 $1b ;",0 
dfdf			 
dfdf .. 00		keytab:       db ": keytab $09 ;",0 
dfee .. 00		keycr:       db ": keycr $0d ;",0 
dffc .. 00		keyhome:       db ": keyhome $0e ;",0 
e00c .. 00		keyend:       db ": keyend $0f ;",0 
e01b .. 00		keybs:       db ": keybs $08 ;",0 
e029			 
e029			   
e029			 
e029			 
e029			 
e029			; eof 
# End of file forth_autostart.asm
e029			 
e029			 
e029			 
e029			; stack over and underflow checks 
e029			 
e029			; init the words to detect the under/overflow 
e029			 
e029			chk_stk_init: 
e029				; a vague random number to check so we dont get any "lucky" hits 
e029 3e 2d			ld a, 45 
e02b 6f				ld l, a 
e02c 00				nop 
e02d 3e 17			ld a, 23 
e02f 67				ld h, a 
e030			 
e030 22 a9 e2			ld (chk_word), hl     ; the word we need to check against 
e033			 
e033			;	ld (chk_stund), hl	; stack points.... 
e033 22 00 ef			ld (chk_stovr), hl 
e036 22 ec e9			ld (chk_ret_und), hl 
e039 22 aa e9			ld (chk_ret_ovr), hl 
e03c 22 28 e9			ld (chk_loop_ovr), hl 
e03f 22 26 e8			ld (chk_data_ovr), hl 
e042 c9				ret 
e043				 
e043			check_stacks: 
e043				; check all stack words 
e043			 
e043 e5				push hl 
e044 d5				push de 
e045			 
e045			;	ld de,(chk_word) 
e045			;	ld hl, (chk_stund)	; stack points.... 
e045			;	if DEBUG_STK_FAULT 
e045			;		DMARK "FAa" 
e045			;		CALLMONITOR 
e045			;	endif 
e045			;	call cmp16 
e045			;	jp z, .chk_faulta 
e045			; 
e045			;	ld de, sfaultsu 
e045			;	jp .chk_fault 
e045			 
e045 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e048 ed 5b a9 e2		ld de,(chk_word) 
e04c				if DEBUG_STK_FAULT 
e04c					DMARK "FAb" 
e04c					CALLMONITOR 
e04c				endif 
e04c cd fa 8c			call cmp16 
e04f 28 06			jr z, .chk_fault1 
e051 11 f2 e0			ld de, sfaultso 
e054 c3 a6 e0			jp .chk_fault 
e057			.chk_fault1:  
e057 2a ec e9			ld hl, (chk_ret_und) 
e05a ed 5b a9 e2		ld de,(chk_word) 
e05e				if DEBUG_STK_FAULT 
e05e					DMARK "FAU" 
e05e					CALLMONITOR 
e05e				endif 
e05e cd fa 8c			call cmp16 
e061 ca 6a e0			jp z, .chk_fault2 
e064 11 02 e1			ld de, sfaultru 
e067 c3 a6 e0			jp .chk_fault 
e06a			.chk_fault2:  
e06a 2a aa e9			ld hl, (chk_ret_ovr) 
e06d ed 5b a9 e2		ld de,(chk_word) 
e071				if DEBUG_STK_FAULT 
e071					DMARK "FA1" 
e071					CALLMONITOR 
e071				endif 
e071 cd fa 8c			call cmp16 
e074 ca 7d e0			jp z, .chk_fault3 
e077 11 10 e1			ld de, sfaultro 
e07a c3 a6 e0			jp .chk_fault 
e07d			.chk_fault3:  
e07d 2a 28 e9			ld hl, (chk_loop_ovr) 
e080 ed 5b a9 e2		ld de,(chk_word) 
e084				if DEBUG_STK_FAULT 
e084					DMARK "FA2" 
e084					CALLMONITOR 
e084				endif 
e084 cd fa 8c			call cmp16 
e087 ca 90 e0			jp z, .chk_fault4 
e08a 11 2a e1			ld de, sfaultlo 
e08d c3 a6 e0			jp .chk_fault 
e090			.chk_fault4:  
e090 2a 26 e8			ld hl, (chk_data_ovr) 
e093 ed 5b a9 e2		ld de,(chk_word) 
e097				if DEBUG_STK_FAULT 
e097					DMARK "FA3" 
e097					CALLMONITOR 
e097				endif 
e097 cd fa 8c			call cmp16 
e09a ca a3 e0			jp z, .chk_fault5 
e09d 11 44 e1			ld de, sfaultdo 
e0a0 c3 a6 e0			jp .chk_fault 
e0a3			 
e0a3			 
e0a3			.chk_fault5:  
e0a3 d1				pop de 
e0a4 e1				pop hl 
e0a5			 
e0a5 c9				ret 
e0a6			 
e0a6 cd af 8a		.chk_fault: 	call clear_display 
e0a9 3e 28				ld a, display_row_2 
e0ab cd c2 8a				call str_at_display 
e0ae 11 d4 e0				   ld de, .stackfault 
e0b1 3e 00				ld a, display_row_1 
e0b3 cd c2 8a				call str_at_display 
e0b6 11 6b ee				    ld de, debug_mark 
e0b9 3e 11				ld a, display_row_1+17 
e0bb cd c2 8a				call str_at_display 
e0be cd d2 8a				call update_display 
e0c1			 
e0c1				; prompt before entering montior for investigating issue 
e0c1			 
e0c1 3e 78			ld a, display_row_4 
e0c3 11 3d 98			ld de, endprog 
e0c6			 
e0c6 cd d2 8a			call update_display		 
e0c9			 
e0c9 cd c3 9a			call next_page_prompt 
e0cc			 
e0cc d1				pop de 
e0cd e1				pop hl 
e0ce cd 91 98				call monitor 
e0d1 c3 8b 97				jp warmstart 
e0d4					;jp 0 
e0d4					;halt 
e0d4			 
e0d4			 
e0d4			 
e0d4 .. 00		.stackfault: 	db "Stack fault:",0 
e0e1			 
e0e1 .. 00		sfaultsu: 	db	"Stack under flow",0 
e0f2 .. 00		sfaultso: 	db	"Stack over flow",0 
e102 .. 00		sfaultru:	db "RTS underflow",0 
e110 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e12a .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e144 .. 00		sfaultdo:	db "DTS overflow", 0 
e151			 
e151			 
e151			fault_dsp_under: 
e151 11 63 e1			ld de, .dsp_under 
e154 c3 13 e2			jp .show_fault 
e157			 
e157			fault_rsp_under: 
e157 11 71 e1			ld de, .rsp_under 
e15a c3 13 e2			jp .show_fault 
e15d			fault_loop_under: 
e15d 11 7f e1			ld de, .loop_under 
e160 c3 13 e2			jp .show_fault 
e163			 
e163 .. 00		.dsp_under: db "DSP Underflow",0 
e171 .. 00		.rsp_under: db "RSP Underflow",0 
e17f .. 00		.loop_under: db "LOOP Underflow",0 
e18e			 
e18e			 
e18e d5			type_faultn: 	push de 
e18f e5					push hl 
e190 cd af 8a				call clear_display 
e193 11 ba e1				   ld de, .typefaultn 
e196 3e 00				ld a, display_row_1 
e198 cd c2 8a				call str_at_display 
e19b 11 6b ee				    ld de, debug_mark 
e19e 3e 11				ld a, display_row_1+17 
e1a0 cd c2 8a				call str_at_display 
e1a3 cd d2 8a				call update_display 
e1a6			 
e1a6				; prompt before entering montior for investigating issue 
e1a6			 
e1a6 3e 78			ld a, display_row_4 
e1a8 11 3d 98			ld de, endprog 
e1ab			 
e1ab cd d2 8a			call update_display		 
e1ae			 
e1ae cd c3 9a			call next_page_prompt 
e1b1			 
e1b1 e5					push hl 
e1b2 d5					push de 
e1b3 cd 91 98				call monitor 
e1b6 c3 8b 97				jp warmstart 
e1b9 76					halt 
e1ba			 
e1ba			 
e1ba .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e1d1			 
e1d1 d5			type_faults: 	push de 
e1d2 e5					push hl 
e1d3 cd af 8a				call clear_display 
e1d6 11 fc e1				   ld de, .typefaults 
e1d9 3e 00				ld a, display_row_1 
e1db cd c2 8a				call str_at_display 
e1de 11 6b ee				    ld de, debug_mark 
e1e1 3e 11				ld a, display_row_1+17 
e1e3 cd c2 8a				call str_at_display 
e1e6 cd d2 8a				call update_display 
e1e9			 
e1e9				; prompt before entering montior for investigating issue 
e1e9			 
e1e9 3e 78			ld a, display_row_4 
e1eb 11 3d 98			ld de, endprog 
e1ee			 
e1ee cd d2 8a			call update_display		 
e1f1			 
e1f1 cd c3 9a			call next_page_prompt 
e1f4			 
e1f4 e1					pop hl 
e1f5 d1					pop de 
e1f6 cd 91 98				call monitor 
e1f9 c3 8b 97				jp warmstart 
e1fc			 
e1fc			 
e1fc .. 00		.typefaults: db "STR Type Expected TOS!",0 
e213			 
e213			.show_fault: 	 
e213 d5					push de 
e214 cd af 8a				call clear_display 
e217 d1					pop de 
e218 3e 00				ld a, display_row_1 
e21a cd c2 8a				call str_at_display 
e21d 11 6b ee				    ld de, debug_mark 
e220 3e 11				ld a, display_row_1+17 
e222 cd c2 8a				call str_at_display 
e225 cd d2 8a				call update_display 
e228			 
e228				; prompt before entering montior for investigating issue 
e228			 
e228 3e 78			ld a, display_row_4 
e22a 11 3d 98			ld de, endprog 
e22d			 
e22d cd d2 8a			call update_display		 
e230			 
e230 cd c3 9a			call next_page_prompt 
e233			 
e233 e1					pop hl 
e234 d1					pop de 
e235 cd 91 98				call monitor 
e238			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e238			; TODO Make optional fault restart to cli or warm boot? 
e238					;jp warmstart 
e238 c3 e3 97				jp cli 
e23b 76					halt 
e23c			 
e23c			; handle the auto run of code from files in storage 
e23c			 
e23c			 
e23c			include "forth_startup.asm" 
e23c			; Which startup method to use? 
e23c			; 
e23c			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e23c			; followed by loading of a list of scripts in eeprom 
e23c			 
e23c			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e23c			; from eeprom 
e23c			 
e23c			; Select with define in main stubs 
e23c			 
e23c			if STARTUP_V1 
e23c				include "forth_startupv1.asm" 
e23c			; Startup script loading version 1 
e23c			 
e23c			; If SE storage is available first stage is to use the selected file 
e23c			; then go through the eeprom list 
e23c			 
e23c .. 00		sprompt1: db "Startup load...",0 
e24c .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e262			 
e262			 
e262			 
e262			 
e262			forth_startup: 
e262 21 dd cc			ld hl, startcmds 
e265 3e 00			ld a, 0 
e267 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e26a			 
e26a e5			.start1:	push hl 
e26b cd af 8a			call clear_display 
e26e 11 3c e2			ld de, sprompt1 
e271 3e 00		        ld a, display_row_1 
e273 cd c2 8a			call str_at_display 
e276 11 4c e2			ld de, sprompt2 
e279 3e 28		        ld a, display_row_2 
e27b cd c2 8a			call str_at_display 
e27e e1				pop hl 
e27f e5				push hl 
e280 5e				ld e,(hl) 
e281 23				inc hl 
e282 56				ld d,(hl) 
e283 3e 50		        ld a, display_row_3 
e285 cd c2 8a			call str_at_display 
e288 cd d2 8a			call update_display 
e28b			 
e28b			 
e28b 3a e7 e6			ld a, (os_last_cmd) 
e28e fe 00			cp 0 
e290 28 05			jr z, .startprompt 
e292 cd e6 89			call delay250ms 
e295 18 24			jr .startdo 
e297				 
e297				 
e297			 
e297			.startprompt: 
e297			 
e297 3e 9f			ld a,display_row_4 + display_cols - 1 
e299 11 c1 9a		        ld de, endprg 
e29c cd c2 8a			call str_at_display 
e29f cd d2 8a			call update_display 
e2a2 cd f2 89			call delay1s 
e2a5 cd c8 e3			call cin_wait 
e2a8						 
e2a8 fe 2a			cp '*' 
e2aa 28 5e			jr z, .startupend1 
e2ac fe 23			cp '#' 
e2ae 20 07			jr nz, .startno 
e2b0 3e 01			ld a, 1 
e2b2 32 e7 e6			ld (os_last_cmd),a 
e2b5 18 04			jr .startdo 
e2b7 fe 31		.startno:	cp '1' 
e2b9 28 3a			jr z,.startnxt  
e2bb			 
e2bb				; exec startup line 
e2bb			.startdo:	 
e2bb e1				pop hl 
e2bc e5				push hl 
e2bd				 
e2bd 5e				ld e,(hl) 
e2be 23				inc hl 
e2bf 56				ld d,(hl) 
e2c0 eb				ex de,hl 
e2c1			 
e2c1 e5				push hl 
e2c2			 
e2c2 3e 00			ld a, 0 
e2c4				;ld a, FORTH_END_BUFFER 
e2c4 cd 45 91			call strlent 
e2c7 23				inc hl   ; include zero term to copy 
e2c8 06 00			ld b,0 
e2ca 4d				ld c,l 
e2cb e1				pop hl 
e2cc 11 c1 e2			ld de, scratch 
e2cf ed b0			ldir 
e2d1			 
e2d1			 
e2d1 21 c1 e2			ld hl, scratch 
e2d4 cd 46 9f			call forthparse 
e2d7 cd 86 9f			call forthexec 
e2da cd 98 9e			call forthexec_cleanup 
e2dd			 
e2dd 3e 78			ld a, display_row_4 
e2df 11 3d 98			ld de, endprog 
e2e2			 
e2e2 cd d2 8a			call update_display		 
e2e5			 
e2e5 3a e7 e6			ld a, (os_last_cmd) 
e2e8 fe 00			cp 0 
e2ea 20 09			jr nz, .startnxt 
e2ec cd c3 9a			call next_page_prompt 
e2ef cd af 8a		        call clear_display 
e2f2 cd d2 8a			call update_display		 
e2f5			 
e2f5				; move onto next startup line? 
e2f5			.startnxt: 
e2f5			 
e2f5 cd e6 89			call delay250ms 
e2f8 e1				pop hl 
e2f9			 
e2f9 23				inc hl 
e2fa 23				inc hl 
e2fb			 
e2fb e5				push hl 
e2fc 5e				ld e, (hl) 
e2fd 23				inc hl 
e2fe 56				ld d, (hl) 
e2ff e1				pop hl 
e300				; TODO replace 0 test 
e300			 
e300 eb				ex de, hl 
e301 cd 05 8d			call ishlzero 
e304			;	ld a,e 
e304			;	add d 
e304			;	cp 0    ; any left to do? 
e304 eb				ex de, hl 
e305 c2 6a e2			jp nz, .start1 
e308 18 01			jr .startupend 
e30a			 
e30a e1			.startupend1: pop hl 
e30b			.startupend: 
e30b			 
e30b cd af 8a			call clear_display 
e30e cd d2 8a			call update_display 
e311 c9				ret 
e312			if STORAGE_SE 
e312			 
e312			sprompt3: db "Loading from start-up file?:",0 
e312			sprompt4: db "(Y=Any key/N=No)",0 
e312			 
e312			 
e312			forth_autoload: 
e312			 
e312				; load block 0 of store 1 
e312				 
e312				ld a, $fe      ; bit 0 clear 
e312				ld (spi_device), a 
e312			 
e312				call storage_get_block_0 
e312			 
e312				ld a, (store_page+STORE_0_AUTOFILE) 
e312			 
e312				cp 0 
e312				ret z     ; auto start not enabled 
e312			 
e312				call clear_display 
e312			 
e312				; set bank 
e312			 
e312					ld a, (store_page+STORE_0_BANKRUN) 
e312					ld (spi_device), a 
e312			 
e312				; get file id to load from and get the file name to display 
e312			 
e312					ld a, (store_page+STORE_0_FILERUN) 
e312			 
e312					ld l, 0 
e312					ld h, a 
e312					ld de, store_page 
e312			 
e312					if DEBUG_FORTH_WORDS 
e312						DMARK "ASp" 
e312						CALLMONITOR 
e312					endif 
e312					call storage_read 
e312			 
e312					if DEBUG_FORTH_WORDS 
e312						DMARK "ASr" 
e312						CALLMONITOR 
e312					endif 
e312			 
e312					call ishlzero 
e312					ret z             ; file not found 
e312			 
e312					ld a, display_row_2 + 10 
e312					ld de, store_page+3 
e312					call str_at_display 
e312				 
e312			; 
e312			 
e312				ld a, display_row_1+5 
e312				ld de, sprompt3 
e312				call str_at_display 
e312				ld a, display_row_3+15 
e312				ld de, sprompt4 
e312				call str_at_display 
e312			 
e312				call update_display 
e312			 
e312				call cin_wait 
e312				cp 'n' 
e312				ret z 
e312				cp 'N' 
e312				ret z 
e312			 
e312				call delay1s 
e312			 
e312				ld a, (store_page+2) 
e312				ld (store_openmaxext), a    ; save count of ext 
e312				ld a, 1  
e312				ld (store_openext), a    ; save count of ext 
e312			 
e312			.autof:  
e312				ld l , a 
e312				 
e312				ld a, (store_page) 
e312				ld h, a	 
e312				ld de, store_page 
e312					if DEBUG_FORTH_WORDS 
e312						DMARK "ASl" 
e312						CALLMONITOR 
e312					endif 
e312					call storage_read 
e312				call ishlzero 
e312				ret z 
e312			;	jr z, .autoend 
e312			 
e312					if DEBUG_FORTH_WORDS 
e312						DMARK "ASc" 
e312						CALLMONITOR 
e312					endif 
e312				ld de, store_page+2 
e312				ld a, display_row_4 
e312				call str_at_display 
e312			 
e312				call update_display 
e312				call delay250ms 
e312			 
e312			 
e312			 
e312				ld hl, store_page+2 
e312				call forthparse 
e312				call forthexec 
e312				call forthexec_cleanup 
e312			 
e312				 
e312				ld a, (store_openext) 
e312				inc a 
e312				ld (store_openext), a    ; save count of ext 
e312			 
e312				jr .autof 
e312			;.autofdone: 
e312			; 
e312			;		if DEBUG_FORTH_WORDS 
e312			;			DMARK "ASx" 
e312			;			CALLMONITOR 
e312			;		endif 
e312			;;	call clear_display 
e312			;	ret 
e312			 
e312			 
e312			 
e312			endif 
# End of file forth_startupv1.asm
e312			endif 
e312			if STARTUP_V2 
e312				include "forth_startupv2.asm" 
e312			endif 
e312			 
# End of file forth_startup.asm
e312			 
e312			; eof 
# End of file forth_kernel.asm
e312			;include "nascombasic.asm" 
e312			 
e312			 
e312			; find out where the code ends if loaded into RAM (for SC114) 
e312			;endofcode:  
e312			;	nop 
e312			 
e312			 
e312			; jump to nmi vector 
e312			 
e312			init_nmi: 
e312 3e c9			ld a, $c9   ; RET 
e314 32 72 ee			ld (nmi_vector), a 
e317 c9				ret 
e318			nmi: 
e318 e5				push hl 
e319 d5				push de 
e31a c5				push bc 
e31b f5				push af 
e31c cd 72 ee			call nmi_vector 
e31f f5				push af 
e320 c5				push bc 
e321 d5				push de 
e322 e5				push hl 
e323 ed 4d			reti 
e325			 
e325			 
e325			; eof 
e325			 
# End of file main.asm
e325			;include "firmware_lcd_4x40.asm" 
e325			;;include "firmware_lcd_4x20.asm" 
e325			include "firmware_serial_display.asm" 
e325			 
e325			; Serial display interface for SC114 
e325			 
e325			 
e325			display_row_1: equ 0 
e325			display_row_2: equ display_row_1+display_cols 
e325			display_row_3: equ display_row_2 + display_cols 
e325			display_row_4: equ display_row_3 + display_cols 
e325			 
e325			kLCDWidth:  EQU display_cols             ;Width in characters 
e325			kLCD_Line1: EQU 0x00  
e325			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e325			; E1 
e325			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e325			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e325			 
e325			lcd_init: 
e325				; no init as handled by the SCM bios 
e325 c9				ret 
e326			 
e326			 
e326			; low level functions for direct screen writes 
e326			 
e326			; output char at pos? 
e326			fLCD_Str: 
e326			        ;out (SC114_SIO_1_OUT),a 
e326 c5				push bc 
e327 0e 02			ld c, $02 
e329 f7				rst $30 
e32a c1				pop bc 
e32b c9				ret 
e32c			 
e32c			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e32c			fLCD_Pos: 
e32c				; use ASCII escape to position 
e32c			        ;out (SC114_SIO_1_OUT),a 
e32c c5				push bc 
e32d 0e 02			ld c, $02 
e32f f7				rst $30 
e330 c1				pop bc 
e331			 
e331 c9				ret 
e332			 
e332			; output char at pos 
e332			fLCD_Data: 
e332			      ;  out (SC114_SIO_1_OUT),a 
e332 c5				push bc 
e333 0e 02			ld c, $02 
e335 f7				rst $30 
e336 c1				pop bc 
e337			 
e337 c9				ret 
e338			 
e338			; ascii cls  
e338			 
e338 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e33c			 
e33c			; write the frame buffer given in hl to hardware  
e33c			write_display: 
e33c			 
e33c			API: equ 0 
e33c			 
e33c			if API 
e33c				push bc 
e33c				ld b, 4 
e33c			 
e33c			        ld (display_write_tmp), hl 	  
e33c			 
e33c				; clear and home cursor 
e33c			 
e33c				ld c, 6 
e33c				ld de, .cls 
e33c				rst $30 
e33c			 
e33c			 
e33c			.writeln: 
e33c			 
e33c				ld de, (display_write_tmp) 
e33c				ld c, 6 
e33c				rst $30 
e33c				ld c, 7 
e33c				rst $30 
e33c			 
e33c				ld hl, (display_write_tmp) 
e33c				ld de, display_cols 
e33c				add hl,de 
e33c				ld (display_write_tmp),hl 
e33c			 
e33c				djnz  .writeln 
e33c			 
e33c				pop bc 
e33c			 
e33c			 
e33c				ret 
e33c			endif 
e33c e5				push hl 
e33d c5				push bc 
e33e d5				push de 
e33f			 
e33f			;	ld c, 2 
e33f			;	;ld de, .cls 
e33f			;	ld a, 27 
e33f			;	rst $30 
e33f			;	ld c, 2 
e33f			;	;ld de, .cls 
e33f			;	ld a, '[' 
e33f			;	rst $30 
e33f			; 
e33f			;	ld c, 2 
e33f			;	;ld de, .cls 
e33f			;	ld a, 'H' 
e33f			;	rst $30 
e33f			; 
e33f			 
e33f 0e 02			ld c, 2 
e341				;ld de, .cls 
e341 3e 1b			ld a, 27 
e343 f7				rst $30 
e344			 
e344			 
e344 0e 02			ld c, 2 
e346				;ld de, .cls 
e346 3e 5b			ld a, '[' 
e348 f7				rst $30 
e349 0e 02			ld c, 2 
e34b				;ld de, .cls 
e34b 3e 32			ld a, '2' 
e34d f7				rst $30 
e34e 0e 02			ld c, 2 
e350				;ld de, .cls 
e350 3e 4a			ld a, 'J' 
e352 f7				rst $30 
e353 d1				pop de 
e354 c1				pop bc 
e355 e1				pop hl 
e356			 
e356			 
e356 22 c9 eb		        ld (display_write_tmp), hl 	  
e359 3e 00			ld a, kLCD_Line1 
e35b			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e35b 06 28			ld b, display_cols 
e35d ed 5b c9 eb		ld de, (display_write_tmp) 
e361 cd bf e3			call write_len_string 
e364				 
e364			 
e364 e5			push hl 
e365 d5			push de 
e366 c5			push bc 
e367 0e 07			ld c, 7 
e369 f7				rst $30 
e36a c1			pop bc 
e36b d1			pop de 
e36c e1			pop hl 
e36d			 
e36d				 
e36d 2a c9 eb			ld hl, (display_write_tmp) 
e370 11 28 00			ld de, display_cols 
e373 19				add hl,de 
e374 22 c9 eb			ld (display_write_tmp),hl 
e377			 
e377				 
e377 3e 28			ld a, kLCD_Line2 
e379			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e379 06 28			ld b, display_cols 
e37b ed 5b c9 eb		ld de, (display_write_tmp) 
e37f cd bf e3			call write_len_string 
e382				 
e382 2a c9 eb			ld hl, (display_write_tmp) 
e385 11 28 00			ld de, display_cols 
e388 19				add hl,de 
e389 22 c9 eb			ld (display_write_tmp),hl 
e38c			 
e38c e5			push hl 
e38d d5			push de 
e38e c5			push bc 
e38f 0e 07			ld c, 7 
e391 f7				rst $30 
e392 c1			pop bc 
e393 d1			pop de 
e394 e1			pop hl 
e395			 
e395				 
e395 3e 50			ld a, kLCD_Line3 
e397			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e397 06 28			ld b, display_cols 
e399 ed 5b c9 eb		ld de, (display_write_tmp) 
e39d cd bf e3			call write_len_string 
e3a0				 
e3a0 2a c9 eb			ld hl, (display_write_tmp) 
e3a3 11 28 00			ld de, display_cols 
e3a6 19				add hl,de 
e3a7 22 c9 eb			ld (display_write_tmp),hl 
e3aa			 
e3aa e5			push hl 
e3ab d5			push de 
e3ac c5			push bc 
e3ad 0e 07			ld c, 7 
e3af f7				rst $30 
e3b0 c1			pop bc 
e3b1 d1			pop de 
e3b2 e1			pop hl 
e3b3			 
e3b3				 
e3b3 3e 78			ld a, kLCD_Line4 
e3b5			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e3b5 06 28			ld b, display_cols 
e3b7 ed 5b c9 eb		ld de, (display_write_tmp) 
e3bb cd bf e3			call write_len_string 
e3be c9					ret 
e3bf			 
e3bf			 
e3bf				; write out a fixed length string given in b from de 
e3bf			 
e3bf 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e3c0 cd 32 e3		            CALL fLCD_Data      ;Write character to display 
e3c3 13				inc de 
e3c4 10 f9			djnz write_len_string 
e3c6 c9				ret 
e3c7			 
e3c7			 
e3c7			; eof 
# End of file firmware_serial_display.asm
e3c7			;include "firmware_key_5x10.asm" 
e3c7			;;include "firmware_key_4x10.asm" 
e3c7			include "firmware_key_serial.asm" 
e3c7			; Serial keyboard interface for SC114 
e3c7			 
e3c7			key_init: 
e3c7				; no init as handled by the SCM bios 
e3c7 c9				ret 
e3c8			 
e3c8			 
e3c8			cin_wait: 
e3c8			;	ld a, 0 
e3c8			;	ret 
e3c8			 
e3c8				;in a,(SC114_SIO_1_IN) 
e3c8			        ; Use SCM API to get from whatever console device we are using 
e3c8 c5				push bc 
e3c9 0e 01			ld c, $01 
e3cb f7				rst $30 
e3cc c1				pop bc 
e3cd c9				ret 
e3ce			 
e3ce			cin: 
e3ce			 
e3ce			 
e3ce c5				push bc 
e3cf			 
e3cf				; any key waiting to process? 
e3cf 0e 03			ld c, $03 
e3d1 f7				rst $30 
e3d2 28 05			jr z, .cin_skip 
e3d4			 
e3d4				; yep, get it 
e3d4			 
e3d4 0e 01			ld c, $01 
e3d6 f7				rst $30 
e3d7 c1				pop bc 
e3d8 c9				ret 
e3d9			.cin_skip: 
e3d9 3e 00			ld a, 0 
e3db c1				pop bc 
e3dc c9				ret 
e3dd			 
e3dd			 
e3dd			 
e3dd			 
# End of file firmware_key_serial.asm
e3dd			endofcode:  
e3dd			baseram:  
e3dd 00				nop 
e3de			 
e3de			heap_start: equ baseram+15  ; Starting address of heap 
e3de			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e3de			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e3de			;VDU:  EQU     endofcode           ; BASIC Work space 
e3de			; eof 
e3de			 
# End of file os_mega_sc114.asm
e3de
