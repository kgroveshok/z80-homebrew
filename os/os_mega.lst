# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 68 18			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3c holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOEFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd d5 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd d5 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd d5 0a				call clear_display  
0023			  
0023			  
0023 cd d6 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 6d 67			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd ac 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 69 13				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd f8 0a			call update_display  
0035 cd 55 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd da 0a			call fill_display  
003d cd f8 0a			call update_display  
0040 cd 55 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd da 0a			call fill_display  
0048 cd f8 0a			call update_display  
004b cd 55 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd da 0a			call fill_display  
0053 cd f8 0a			call update_display  
0056 cd 55 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd e8 0a			call str_at_display  
0061 cd f8 0a			call update_display  
0064			  
0064			  
0064 cd 55 0a			call delay1s  
0067 cd 55 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd e8 0a			call str_at_display  
0072 cd f8 0a			call update_display  
0075 cd 55 0a			call delay1s  
0078 cd 55 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 49 f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 49 f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 49 f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 49 f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 49 f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 4b f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 48 f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 48 f8			ld (spi_device), a 
01e3 32 4b f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 49 f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 49 f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 49 f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 49 f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 49 f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 49 f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 49 f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 49 f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 3a 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 49 f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 49 f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 49 f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 49 f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 49 f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 49 f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 49 f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 49 f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 3a 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 49 f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 49 f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 49 f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 49 f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 1f ee			ld hl,scratch+2 
02be cd c0 10			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 40 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 24 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 40 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 40 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 40 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 40 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 45 ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 45 ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 40 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 40 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 45 ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 40 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 92 16			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 92 16			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 2d 06			call storage_findnextid 
0360			 
0360 cd 32 0d			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 92 16			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 92 16			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 92 16			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 92 16			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 92 16			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b cd 18 0a			call storage_clear_page 
042e			 
042e 21 62 f8			ld hl, store_page 
0431 3e 00			ld a, 0 
0433				 
0433 77				ld (hl),a   ; reset file counter 
0434			 
0434 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0437 22 63 f8		 	ld (store_page+1), hl	 
043a			 
043a				; set default label 
043a			 
043a 21 d6 04			ld hl, .defaultbanklabl 
043d 11 65 f8		 	ld de, store_page+3 
0440 01 0f 00			ld bc, 15 
0443 ed b0			ldir 
0445			 
0445				; Append the current bank id 
0445 21 6e f8			ld hl, store_page+3+9 
0448 3a 47 f8			ld a, (spi_device_id) 
044b 77				ld (hl), a 
044c			 
044c				; save default page 0 
044c			 
044c 21 00 00			ld hl, 0 
044f 11 62 f8			ld de, store_page 
0452				if DEBUG_STORESE 
0452					DMARK "SB3" 
0452 f5				push af  
0453 3a 67 04			ld a, (.dmark)  
0456 32 77 fb			ld (debug_mark),a  
0459 3a 68 04			ld a, (.dmark+1)  
045c 32 78 fb			ld (debug_mark+1),a  
045f 3a 69 04			ld a, (.dmark+2)  
0462 32 79 fb			ld (debug_mark+2),a  
0465 18 03			jr .pastdmark  
0467 ..			.dmark: db "SB3"  
046a f1			.pastdmark: pop af  
046b			endm  
# End of macro DMARK
046b			;		push af 
046b			;		ld a, 'F' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b					CALLMONITOR 
046b cd 92 16			call break_point_state  
046e				endm  
# End of macro CALLMONITOR
046e				endif 
046e cd 71 03			call storage_write_block 
0471				if DEBUG_STORESE 
0471					DMARK "SB4" 
0471 f5				push af  
0472 3a 86 04			ld a, (.dmark)  
0475 32 77 fb			ld (debug_mark),a  
0478 3a 87 04			ld a, (.dmark+1)  
047b 32 78 fb			ld (debug_mark+1),a  
047e 3a 88 04			ld a, (.dmark+2)  
0481 32 79 fb			ld (debug_mark+2),a  
0484 18 03			jr .pastdmark  
0486 ..			.dmark: db "SB4"  
0489 f1			.pastdmark: pop af  
048a			endm  
# End of macro DMARK
048a			;		push af 
048a			;		ld a, '>' 
048a			;		ld (debug_mark),a 
048a			;		pop af 
048a					CALLMONITOR 
048a cd 92 16			call break_point_state  
048d				endm  
# End of macro CALLMONITOR
048d				endif 
048d			 
048d 00				nop 
048e 00				nop 
048f 00				nop 
0490			 
0490				; now set 0 in every page to mark as a free block 
0490			 
0490 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0492 21 40 00			ld hl, STORE_BLOCK_PHY 
0495			 
0495 3e 00		.setmark1:   	ld a,0 
0497 e5					push hl 
0498 c5					push bc 
0499 cd ea 01				call se_writebyte 
049c 3e 0a			ld a, 10 
049e cd 3a 0a			call aDelayInMS 
04a1 23				inc hl 
04a2 cd ea 01				call se_writebyte 
04a5 3e 0a			ld a, 10 
04a7 cd 3a 0a			call aDelayInMS 
04aa 2b				dec hl 
04ab c1					pop bc 
04ac e1					pop hl 
04ad 3e 40				ld a, STORE_BLOCK_PHY 
04af cd 09 0d				call addatohl 
04b2 10 e1				djnz .setmark1 
04b4			 
04b4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b6 3e 00		.setmark2:   	ld a,0 
04b8 e5					push hl 
04b9 c5					push bc 
04ba cd ea 01				call se_writebyte 
04bd 3e 0a			ld a, 10 
04bf cd 3a 0a			call aDelayInMS 
04c2 23				inc hl 
04c3 cd ea 01				call se_writebyte 
04c6 3e 0a			ld a, 10 
04c8 cd 3a 0a			call aDelayInMS 
04cb 2b				dec hl 
04cc c1					pop bc 
04cd e1					pop hl 
04ce 3e 40				ld a, STORE_BLOCK_PHY 
04d0 cd 09 0d				call addatohl 
04d3 10 e1				djnz .setmark2 
04d5			 
04d5					 
04d5			 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			 
04d6			 
04d6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04e1			 
04e1			 
04e1			 
04e1			; Label Bank 
04e1			; ---------- 
04e1			; 
04e1			; With current bank 
04e1			; Read block 0 
04e1			; Set label 
04e1			; Write block 0 
04e1			 
04e1			; label str pointer in hl 
04e1			 
04e1			storage_label:     
04e1			 
04e1				if DEBUG_STORESE 
04e1					DMARK "LBL" 
04e1 f5				push af  
04e2 3a f6 04			ld a, (.dmark)  
04e5 32 77 fb			ld (debug_mark),a  
04e8 3a f7 04			ld a, (.dmark+1)  
04eb 32 78 fb			ld (debug_mark+1),a  
04ee 3a f8 04			ld a, (.dmark+2)  
04f1 32 79 fb			ld (debug_mark+2),a  
04f4 18 03			jr .pastdmark  
04f6 ..			.dmark: db "LBL"  
04f9 f1			.pastdmark: pop af  
04fa			endm  
# End of macro DMARK
04fa					CALLMONITOR 
04fa cd 92 16			call break_point_state  
04fd				endm  
# End of macro CALLMONITOR
04fd				endif 
04fd			 
04fd e5				push hl 
04fe			 
04fe cd bd 03			call storage_get_block_0 
0501			 
0501				; set default label 
0501			 
0501 e1				pop hl 
0502			 
0502 11 65 f8		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508				if DEBUG_STORESE 
0508					DMARK "LB3" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 77 fb			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 78 fb			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 79 fb			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "LB3"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521					CALLMONITOR 
0521 cd 92 16			call break_point_state  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 ed b0			ldir 
0526				; save default page 0 
0526			 
0526 21 00 00			ld hl, 0 
0529 11 62 f8			ld de, store_page 
052c				if DEBUG_STORESE 
052c					DMARK "LBW" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 77 fb			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 78 fb			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 79 fb			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "LBW"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					CALLMONITOR 
0545 cd 92 16			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548				endif 
0548 cd 71 03			call storage_write_block 
054b			 
054b c9				ret 
054c			 
054c			 
054c			 
054c			; Read Block 0 - Config 
054c			; --------------------- 
054c			; 
054c			; With current bank 
054c			; Call presence test 
054c			;    If not present format/init bank  
054c			; Read block 0  
054c			;  
054c			 
054c			 
054c			; Dir 
054c			; --- 
054c			; 
054c			; With current bank 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block read byte 2 
054c			;      if first block of file 
054c			;         Display file name 
054c			;         Display type flags for file 
054c			;        
054c			 
054c			; moving to words as this requires stack control 
054c			 
054c			 
054c			; Delete File 
054c			; ----------- 
054c			; 
054c			; With current bank 
054c			; 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block file id 
054c			;      If first block of file and dont have file id 
054c			;         if file to delete 
054c			;         Save file id 
054c			;         Null file id 
054c			;         Write this block back 
054c			;      If file id is one saved 
054c			;         Null file id 
054c			;         Write this block back 
054c			 
054c			storage_erase: 
054c			 
054c				; hl contains the file id 
054c			 
054c 5d				ld e, l 
054d 16 00			ld d, 0 
054f 21 40 00			ld hl, STORE_BLOCK_PHY 
0552					if DEBUG_FORTH_WORDS 
0552						DMARK "ERA" 
0552 f5				push af  
0553 3a 67 05			ld a, (.dmark)  
0556 32 77 fb			ld (debug_mark),a  
0559 3a 68 05			ld a, (.dmark+1)  
055c 32 78 fb			ld (debug_mark+1),a  
055f 3a 69 05			ld a, (.dmark+2)  
0562 32 79 fb			ld (debug_mark+2),a  
0565 18 03			jr .pastdmark  
0567 ..			.dmark: db "ERA"  
056a f1			.pastdmark: pop af  
056b			endm  
# End of macro DMARK
056b						CALLMONITOR 
056b cd 92 16			call break_point_state  
056e				endm  
# End of macro CALLMONITOR
056e					endif 
056e cd 2d 06			call storage_findnextid 
0571			 
0571 e5				push hl 
0572			 
0572				; TODO check file not found 
0572			 
0572 11 62 f8			ld de, store_page 
0575 cd 0c 03			call storage_read_block 
0578			 
0578					if DEBUG_FORTH_WORDS 
0578						DMARK "ER1" 
0578 f5				push af  
0579 3a 8d 05			ld a, (.dmark)  
057c 32 77 fb			ld (debug_mark),a  
057f 3a 8e 05			ld a, (.dmark+1)  
0582 32 78 fb			ld (debug_mark+1),a  
0585 3a 8f 05			ld a, (.dmark+2)  
0588 32 79 fb			ld (debug_mark+2),a  
058b 18 03			jr .pastdmark  
058d ..			.dmark: db "ER1"  
0590 f1			.pastdmark: pop af  
0591			endm  
# End of macro DMARK
0591						CALLMONITOR 
0591 cd 92 16			call break_point_state  
0594				endm  
# End of macro CALLMONITOR
0594					endif 
0594 3a 62 f8			ld a, (store_page)	; get file id 
0597 32 5b f8			ld (store_tmpid), a 
059a			 
059a 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
059d 32 5a f8			ld (store_tmpext), a 
05a0			 
05a0				; wipe file header 
05a0			 
05a0 e1				pop hl 
05a1 3e 00			ld a, 0 
05a3 32 62 f8			ld (store_page), a 
05a6 32 63 f8			ld (store_page+1),a 
05a9 11 62 f8			ld de, store_page 
05ac					if DEBUG_FORTH_WORDS 
05ac						DMARK "ER2" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 77 fb			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 78 fb			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 79 fb			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "ER2"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5						CALLMONITOR 
05c5 cd 92 16			call break_point_state  
05c8				endm  
# End of macro CALLMONITOR
05c8					endif 
05c8 cd 71 03			call storage_write_block 
05cb			 
05cb			 
05cb				; wipe file extents 
05cb			 
05cb 3a 5a f8			ld a, (store_tmpext) 
05ce 47				ld b, a 
05cf			 
05cf			.eraext:	  
05cf c5				push bc 
05d0			 
05d0 21 40 00			ld hl, STORE_BLOCK_PHY 
05d3 3a 5b f8			ld a,(store_tmpid) 
05d6 5f				ld e, a 
05d7 50				ld d, b	 
05d8					if DEBUG_FORTH_WORDS 
05d8						DMARK "ER3" 
05d8 f5				push af  
05d9 3a ed 05			ld a, (.dmark)  
05dc 32 77 fb			ld (debug_mark),a  
05df 3a ee 05			ld a, (.dmark+1)  
05e2 32 78 fb			ld (debug_mark+1),a  
05e5 3a ef 05			ld a, (.dmark+2)  
05e8 32 79 fb			ld (debug_mark+2),a  
05eb 18 03			jr .pastdmark  
05ed ..			.dmark: db "ER3"  
05f0 f1			.pastdmark: pop af  
05f1			endm  
# End of macro DMARK
05f1						CALLMONITOR 
05f1 cd 92 16			call break_point_state  
05f4				endm  
# End of macro CALLMONITOR
05f4					endif 
05f4 cd 2d 06			call storage_findnextid 
05f7			 
05f7 e5				push hl 
05f8 11 62 f8			ld de, store_page 
05fb cd 0c 03			call storage_read_block 
05fe			 
05fe				; free block	 
05fe			 
05fe 3e 00			ld a, 0 
0600 32 62 f8			ld (store_page), a 
0603 32 63 f8			ld (store_page+1),a 
0606 11 62 f8			ld de, store_page 
0609 e1				pop hl 
060a					if DEBUG_FORTH_WORDS 
060a						DMARK "ER4" 
060a f5				push af  
060b 3a 1f 06			ld a, (.dmark)  
060e 32 77 fb			ld (debug_mark),a  
0611 3a 20 06			ld a, (.dmark+1)  
0614 32 78 fb			ld (debug_mark+1),a  
0617 3a 21 06			ld a, (.dmark+2)  
061a 32 79 fb			ld (debug_mark+2),a  
061d 18 03			jr .pastdmark  
061f ..			.dmark: db "ER4"  
0622 f1			.pastdmark: pop af  
0623			endm  
# End of macro DMARK
0623						CALLMONITOR 
0623 cd 92 16			call break_point_state  
0626				endm  
# End of macro CALLMONITOR
0626					endif 
0626 cd 71 03			call storage_write_block 
0629			 
0629 c1				pop bc 
062a 10 a3			djnz .eraext 
062c			 
062c c9				ret 
062d			 
062d			 
062d			; Find Free Block 
062d			; --------------- 
062d			; 
062d			; With current bank 
062d			;  
062d			; From given starting logical block 
062d			;    Read block  
062d			;    If no file id 
062d			;         Return block id 
062d			 
062d			 
062d			; hl starting page number 
062d			; hl contains free page number or zero if no pages free 
062d			; e contains the file id to locate 
062d			; d contains the block number 
062d			 
062d			; TODO change to find file id and use zero for free block 
062d			 
062d			storage_findnextid: 
062d			 
062d				; now locate first 0 page to mark as a free block 
062d			 
062d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062f			;	ld hl, STORE_BLOCK_PHY 
062f			 
062f					if DEBUG_FORTH_WORDS 
062f					DMARK "FNI" 
062f f5				push af  
0630 3a 44 06			ld a, (.dmark)  
0633 32 77 fb			ld (debug_mark),a  
0636 3a 45 06			ld a, (.dmark+1)  
0639 32 78 fb			ld (debug_mark+1),a  
063c 3a 46 06			ld a, (.dmark+2)  
063f 32 79 fb			ld (debug_mark+2),a  
0642 18 03			jr .pastdmark  
0644 ..			.dmark: db "FNI"  
0647 f1			.pastdmark: pop af  
0648			endm  
# End of macro DMARK
0648						CALLMONITOR 
0648 cd 92 16			call break_point_state  
064b				endm  
# End of macro CALLMONITOR
064b					endif 
064b			.ff1:   	 
064b e5					push hl 
064c c5					push bc 
064d d5					push de 
064e cd 8c 02				call se_readbyte 
0651 5f					ld e,a 
0652 23					inc hl 
0653 cd 8c 02				call se_readbyte 
0656 57					ld d, a 
0657 e1					pop hl 
0658 e5					push hl 
0659 cd 27 0d				call cmp16 
065c 28 49				jr z, .fffound 
065e			 
065e d1					pop de 
065f c1					pop bc 
0660 e1					pop hl 
0661			 
0661					; is found? 
0661					;cp e 
0661					;ret z 
0661			 
0661 3e 40				ld a, STORE_BLOCK_PHY 
0663 cd 09 0d				call addatohl 
0666 10 e3				djnz .ff1 
0668			 
0668 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066a			.ff2:   	 
066a			 
066a e5					push hl 
066b c5					push bc 
066c d5					push de 
066d cd 8c 02				call se_readbyte 
0670 5f					ld e,a 
0671 23					inc hl 
0672 cd 8c 02				call se_readbyte 
0675 57					ld d, a 
0676			 
0676 e1					pop hl 
0677 e5					push hl 
0678 cd 27 0d				call cmp16 
067b 28 2a				jr z, .fffound 
067d			 
067d d1					pop de 
067e c1					pop bc 
067f e1					pop hl 
0680					; is found? 
0680					;cp e 
0680					;ret z 
0680			 
0680 3e 40				ld a, STORE_BLOCK_PHY 
0682 cd 09 0d				call addatohl 
0685 10 e3				djnz .ff2 
0687			 
0687			 
0687					if DEBUG_FORTH_WORDS 
0687					DMARK "FN-" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 77 fb			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 78 fb			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 79 fb			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "FN-"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					;	push af 
06a0					;	ld a, 'n' 
06a0					;	ld (debug_mark),a 
06a0					;	pop af 
06a0						CALLMONITOR 
06a0 cd 92 16			call break_point_state  
06a3				endm  
# End of macro CALLMONITOR
06a3					endif 
06a3				; no free marks! 
06a3 21 00 00				ld hl, 0 
06a6 c9				ret 
06a7			.fffound: 
06a7				 
06a7			 
06a7 d1					pop de 
06a8 c1					pop bc 
06a9 e1					pop hl 
06aa					if DEBUG_FORTH_WORDS 
06aa					DMARK "FNF" 
06aa f5				push af  
06ab 3a bf 06			ld a, (.dmark)  
06ae 32 77 fb			ld (debug_mark),a  
06b1 3a c0 06			ld a, (.dmark+1)  
06b4 32 78 fb			ld (debug_mark+1),a  
06b7 3a c1 06			ld a, (.dmark+2)  
06ba 32 79 fb			ld (debug_mark+2),a  
06bd 18 03			jr .pastdmark  
06bf ..			.dmark: db "FNF"  
06c2 f1			.pastdmark: pop af  
06c3			endm  
# End of macro DMARK
06c3					;	push af 
06c3					;	ld a, 'n' 
06c3					;	ld (debug_mark),a 
06c3					;	pop af 
06c3						CALLMONITOR 
06c3 cd 92 16			call break_point_state  
06c6				endm  
# End of macro CALLMONITOR
06c6					endif 
06c6 c9				ret 
06c7			 
06c7			 
06c7			 
06c7			; Free Space 
06c7			; ---------- 
06c7			; 
06c7			; With current bank 
06c7			; 
06c7			; Set block count to zero 
06c7			; Starting with first logical block 
06c7			;      Find free block  
06c7			;      If block id given, increment block count 
06c7			; 
06c7			;  
06c7			 
06c7			 
06c7			; hl contains count of free blocks 
06c7			 
06c7			storage_freeblocks: 
06c7			 
06c7				; now locate first 0 page to mark as a free block 
06c7			 
06c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c9 21 40 00			ld hl, STORE_BLOCK_PHY 
06cc 11 00 00			ld de, 0 
06cf			 
06cf			.fb1:   	 
06cf e5					push hl 
06d0 c5					push bc 
06d1 d5					push de 
06d2 cd 8c 02				call se_readbyte 
06d5 d1					pop de 
06d6 c1					pop bc 
06d7 e1					pop hl 
06d8			 
06d8					; is free? 
06d8 fe 00				cp 0 
06da 20 01				jr nz, .ff1cont 
06dc 13					inc de 
06dd			 
06dd			.ff1cont: 
06dd			 
06dd			 
06dd 3e 40				ld a, STORE_BLOCK_PHY 
06df cd 09 0d				call addatohl 
06e2 10 eb				djnz .fb1 
06e4			 
06e4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e6			.fb2:   	 
06e6 e5					push hl 
06e7 c5					push bc 
06e8 d5					push de 
06e9 cd 8c 02				call se_readbyte 
06ec d1					pop de 
06ed c1					pop bc 
06ee e1					pop hl 
06ef			 
06ef					; is free? 
06ef fe 00				cp 0 
06f1 20 01				jr nz, .ff2cont 
06f3 13					inc de 
06f4			 
06f4			.ff2cont: 
06f4			 
06f4 3e 40				ld a, STORE_BLOCK_PHY 
06f6 cd 09 0d				call addatohl 
06f9 10 eb				djnz .fb2 
06fb			 
06fb eb				ex de, hl 
06fc c9				ret 
06fd			 
06fd			; Get File ID 
06fd			; ----------- 
06fd			; 
06fd			; With current bank 
06fd			;  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; For each logical block 
06fd			;    Read block file id 
06fd			;      If first block of file and dont have file id 
06fd			;         if file get id and exit 
06fd			 
06fd			 
06fd			 
06fd			 
06fd			; Create File 
06fd			; ----------- 
06fd			; 
06fd			; With current bank  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; Increment file id number 
06fd			; Save Config 
06fd			; Find free block 
06fd			; Set buffer with file name and file id 
06fd			; Write buffer to free block  
06fd			 
06fd			 
06fd			; hl point to file name 
06fd			; hl returns file id 
06fd			 
06fd			; file format: 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent number 
06fd			; byte 2-> data 
06fd			 
06fd			; format for extent number 0: 
06fd			; 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent 0 
06fd			; byte 2 - extent count 
06fd			; byte 3 -> file name and meta data 
06fd			 
06fd			 
06fd			storage_create: 
06fd				if DEBUG_STORESE 
06fd					DMARK "SCR" 
06fd f5				push af  
06fe 3a 12 07			ld a, (.dmark)  
0701 32 77 fb			ld (debug_mark),a  
0704 3a 13 07			ld a, (.dmark+1)  
0707 32 78 fb			ld (debug_mark+1),a  
070a 3a 14 07			ld a, (.dmark+2)  
070d 32 79 fb			ld (debug_mark+2),a  
0710 18 03			jr .pastdmark  
0712 ..			.dmark: db "SCR"  
0715 f1			.pastdmark: pop af  
0716			endm  
# End of macro DMARK
0716					CALLMONITOR 
0716 cd 92 16			call break_point_state  
0719				endm  
# End of macro CALLMONITOR
0719				endif 
0719			 
0719 e5				push hl		; save file name pointer 
071a			 
071a cd bd 03			call storage_get_block_0 
071d			 
071d 3a 62 f8			ld a,(store_page)	; get current file id 
0720 3c				inc a 
0721 32 62 f8			ld (store_page),a 
0724				 
0724 32 5b f8			ld (store_tmpid),a			; save id 
0727			 
0727 21 00 00			ld hl, 0 
072a 11 62 f8			ld de, store_page 
072d				if DEBUG_STORESE 
072d					DMARK "SCw" 
072d f5				push af  
072e 3a 42 07			ld a, (.dmark)  
0731 32 77 fb			ld (debug_mark),a  
0734 3a 43 07			ld a, (.dmark+1)  
0737 32 78 fb			ld (debug_mark+1),a  
073a 3a 44 07			ld a, (.dmark+2)  
073d 32 79 fb			ld (debug_mark+2),a  
0740 18 03			jr .pastdmark  
0742 ..			.dmark: db "SCw"  
0745 f1			.pastdmark: pop af  
0746			endm  
# End of macro DMARK
0746					CALLMONITOR 
0746 cd 92 16			call break_point_state  
0749				endm  
# End of macro CALLMONITOR
0749				endif 
0749 cd 71 03			call storage_write_block	 ; save update 
074c			 
074c				if DEBUG_STORESE 
074c 11 62 f8				ld de, store_page 
074f					DMARK "SCC" 
074f f5				push af  
0750 3a 64 07			ld a, (.dmark)  
0753 32 77 fb			ld (debug_mark),a  
0756 3a 65 07			ld a, (.dmark+1)  
0759 32 78 fb			ld (debug_mark+1),a  
075c 3a 66 07			ld a, (.dmark+2)  
075f 32 79 fb			ld (debug_mark+2),a  
0762 18 03			jr .pastdmark  
0764 ..			.dmark: db "SCC"  
0767 f1			.pastdmark: pop af  
0768			endm  
# End of macro DMARK
0768					CALLMONITOR 
0768 cd 92 16			call break_point_state  
076b				endm  
# End of macro CALLMONITOR
076b				endif 
076b				;  
076b				 
076b 21 40 00			ld hl, STORE_BLOCK_PHY 
076e 11 00 00			ld de, 0 
0771 cd 2d 06			call storage_findnextid 
0774			 
0774 22 4c f8			ld (store_tmppageid), hl    ; save page to use  
0777			 
0777				; TODO detect 0 = no spare blocks 
0777			 
0777				; hl now contains the free page to use for the file header page 
0777			 
0777				if DEBUG_STORESE 
0777				DMARK "SCF" 
0777 f5				push af  
0778 3a 8c 07			ld a, (.dmark)  
077b 32 77 fb			ld (debug_mark),a  
077e 3a 8d 07			ld a, (.dmark+1)  
0781 32 78 fb			ld (debug_mark+1),a  
0784 3a 8e 07			ld a, (.dmark+2)  
0787 32 79 fb			ld (debug_mark+2),a  
078a 18 03			jr .pastdmark  
078c ..			.dmark: db "SCF"  
078f f1			.pastdmark: pop af  
0790			endm  
# End of macro DMARK
0790					CALLMONITOR 
0790 cd 92 16			call break_point_state  
0793				endm  
# End of macro CALLMONITOR
0793				endif 
0793			 
0793 22 4c f8			ld (store_tmppageid), hl 
0796				 
0796 3a 5b f8			ld a,(store_tmpid)    ; get file id 
0799			;	ld a, (store_filecache)			; save to cache 
0799			 
0799 32 62 f8			ld (store_page),a    ; set page id 
079c 3e 00			ld a, 0			 ; extent 0 is file header 
079e 32 63 f8			ld (store_page+1), a   ; set file extent 
07a1			 
07a1 32 64 f8			ld (store_page+2), a   ; extent count for the file 
07a4			 
07a4			;	inc hl 		; init block 0 of file 
07a4			;	inc hl   		; skip file and extent id 
07a4			 ;       ld a, 0 
07a4			;	ld (hl),a 
07a4			;	ld a, (store_filecache+1)  	; save to cache 
07a4			 
07a4			;	inc hl    ; file name 
07a4				 
07a4				 
07a4 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
07a7				if DEBUG_STORESE 
07a7					DMARK "SCc" 
07a7 f5				push af  
07a8 3a bc 07			ld a, (.dmark)  
07ab 32 77 fb			ld (debug_mark),a  
07ae 3a bd 07			ld a, (.dmark+1)  
07b1 32 78 fb			ld (debug_mark+1),a  
07b4 3a be 07			ld a, (.dmark+2)  
07b7 32 79 fb			ld (debug_mark+2),a  
07ba 18 03			jr .pastdmark  
07bc ..			.dmark: db "SCc"  
07bf f1			.pastdmark: pop af  
07c0			endm  
# End of macro DMARK
07c0					CALLMONITOR 
07c0 cd 92 16			call break_point_state  
07c3				endm  
# End of macro CALLMONITOR
07c3				endif 
07c3 e1				pop hl    ; get zero term string 
07c4 e5				push hl 
07c5 3e 00			ld a, 0 
07c7 cd 72 11			call strlent 
07ca 23				inc hl   ; cover zero term 
07cb 06 00			ld b,0 
07cd 4d				ld c,l 
07ce e1				pop hl 
07cf				;ex de, hl 
07cf				if DEBUG_STORESE 
07cf					DMARK "SCa" 
07cf f5				push af  
07d0 3a e4 07			ld a, (.dmark)  
07d3 32 77 fb			ld (debug_mark),a  
07d6 3a e5 07			ld a, (.dmark+1)  
07d9 32 78 fb			ld (debug_mark+1),a  
07dc 3a e6 07			ld a, (.dmark+2)  
07df 32 79 fb			ld (debug_mark+2),a  
07e2 18 03			jr .pastdmark  
07e4 ..			.dmark: db "SCa"  
07e7 f1			.pastdmark: pop af  
07e8			endm  
# End of macro DMARK
07e8					;push af 
07e8					;ld a, 'a' 
07e8					;ld (debug_mark),a 
07e8					;pop af 
07e8					CALLMONITOR 
07e8 cd 92 16			call break_point_state  
07eb				endm  
# End of macro CALLMONITOR
07eb				endif 
07eb ed b0			ldir    ; copy zero term string 
07ed				if DEBUG_STORESE 
07ed					DMARK "SCA" 
07ed f5				push af  
07ee 3a 02 08			ld a, (.dmark)  
07f1 32 77 fb			ld (debug_mark),a  
07f4 3a 03 08			ld a, (.dmark+1)  
07f7 32 78 fb			ld (debug_mark+1),a  
07fa 3a 04 08			ld a, (.dmark+2)  
07fd 32 79 fb			ld (debug_mark+2),a  
0800 18 03			jr .pastdmark  
0802 ..			.dmark: db "SCA"  
0805 f1			.pastdmark: pop af  
0806			endm  
# End of macro DMARK
0806					CALLMONITOR 
0806 cd 92 16			call break_point_state  
0809				endm  
# End of macro CALLMONITOR
0809				endif 
0809			 
0809				; write file header page 
0809			 
0809 2a 4c f8			ld hl,(store_tmppageid) 
080c 11 62 f8			ld de, store_page 
080f				if DEBUG_STORESE 
080f					DMARK "SCb" 
080f f5				push af  
0810 3a 24 08			ld a, (.dmark)  
0813 32 77 fb			ld (debug_mark),a  
0816 3a 25 08			ld a, (.dmark+1)  
0819 32 78 fb			ld (debug_mark+1),a  
081c 3a 26 08			ld a, (.dmark+2)  
081f 32 79 fb			ld (debug_mark+2),a  
0822 18 03			jr .pastdmark  
0824 ..			.dmark: db "SCb"  
0827 f1			.pastdmark: pop af  
0828			endm  
# End of macro DMARK
0828					;push af 
0828					;ld a, 'b' 
0828					;ld (debug_mark),a 
0828					;pop af 
0828					CALLMONITOR 
0828 cd 92 16			call break_point_state  
082b				endm  
# End of macro CALLMONITOR
082b				endif 
082b cd 71 03			call storage_write_block 
082e			 
082e 3a 5b f8			ld a, (store_tmpid) 
0831 6f				ld l, a 
0832 26 00			ld h,0 
0834				if DEBUG_STORESE 
0834					DMARK "SCz" 
0834 f5				push af  
0835 3a 49 08			ld a, (.dmark)  
0838 32 77 fb			ld (debug_mark),a  
083b 3a 4a 08			ld a, (.dmark+1)  
083e 32 78 fb			ld (debug_mark+1),a  
0841 3a 4b 08			ld a, (.dmark+2)  
0844 32 79 fb			ld (debug_mark+2),a  
0847 18 03			jr .pastdmark  
0849 ..			.dmark: db "SCz"  
084c f1			.pastdmark: pop af  
084d			endm  
# End of macro DMARK
084d					CALLMONITOR 
084d cd 92 16			call break_point_state  
0850				endm  
# End of macro CALLMONITOR
0850				endif 
0850 c9				ret 
0851				 
0851			 
0851			 
0851			; 
0851			; Read File 
0851			; 
0851			; h - file id to locate 
0851			; l - extent to locate 
0851			; de - pointer to string to read into 
0851			; 
0851			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0851			storage_read: 
0851 d5				push de 
0852			 
0852			; TODO BUG the above push is it popped before the RET Z? 
0852			 
0852			; TODO how to handle multiple part blocks 
0852			 
0852				; locate file extent to read 
0852			 
0852 5c				ld e, h 
0853 55				ld d, l 
0854 21 40 00			ld hl, STORE_BLOCK_PHY 
0857				if DEBUG_STORESE 
0857					DMARK "SRE" 
0857 f5				push af  
0858 3a 6c 08			ld a, (.dmark)  
085b 32 77 fb			ld (debug_mark),a  
085e 3a 6d 08			ld a, (.dmark+1)  
0861 32 78 fb			ld (debug_mark+1),a  
0864 3a 6e 08			ld a, (.dmark+2)  
0867 32 79 fb			ld (debug_mark+2),a  
086a 18 03			jr .pastdmark  
086c ..			.dmark: db "SRE"  
086f f1			.pastdmark: pop af  
0870			endm  
# End of macro DMARK
0870					CALLMONITOR 
0870 cd 92 16			call break_point_state  
0873				endm  
# End of macro CALLMONITOR
0873				endif 
0873 cd 2d 06			call storage_findnextid 
0876			 
0876				if DEBUG_STORESE 
0876					DMARK "SRf" 
0876 f5				push af  
0877 3a 8b 08			ld a, (.dmark)  
087a 32 77 fb			ld (debug_mark),a  
087d 3a 8c 08			ld a, (.dmark+1)  
0880 32 78 fb			ld (debug_mark+1),a  
0883 3a 8d 08			ld a, (.dmark+2)  
0886 32 79 fb			ld (debug_mark+2),a  
0889 18 03			jr .pastdmark  
088b ..			.dmark: db "SRf"  
088e f1			.pastdmark: pop af  
088f			endm  
# End of macro DMARK
088f					CALLMONITOR 
088f cd 92 16			call break_point_state  
0892				endm  
# End of macro CALLMONITOR
0892				endif 
0892 cd 32 0d			call ishlzero 
0895			;	ld a, l 
0895			;	add h 
0895			;	cp 0 
0895 c8				ret z			; block not found so EOF 
0896			 
0896				; hl contains page number to load 
0896 d1				pop de   ; get storage 
0897 d5				push de 
0898				if DEBUG_STORESE 
0898					DMARK "SRg" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 77 fb			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 78 fb			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 79 fb			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SRg"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd 92 16			call break_point_state  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd 0c 03			call storage_read_block 
08b7			 
08b7			 
08b7			; TODO if block has no zeros then need to read next block  
08b7			 
08b7			 
08b7					 
08b7 e1				pop hl 		 ; return start of data to show as not EOF 
08b8 23				inc hl   ; past file id 
08b9 23				inc hl   ; past ext 
08ba				if DEBUG_STORESE 
08ba					DMARK "SRe" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 77 fb			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 78 fb			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 79 fb			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SRe"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd 92 16			call break_point_state  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6 c9					ret 
08d7			 
08d7			 
08d7			 
08d7			; 
08d7			; Append File 
08d7			; 
08d7			; hl - file id to locate 
08d7			; de - pointer to (multi block) string to write 
08d7			 
08d7			 
08d7			storage_append: 
08d7				; hl -  file id to append to 
08d7				; de - string to append 
08d7			 
08d7 d5				push de 
08d8				 
08d8				if DEBUG_STORESE 
08d8					DMARK "AP1" 
08d8 f5				push af  
08d9 3a ed 08			ld a, (.dmark)  
08dc 32 77 fb			ld (debug_mark),a  
08df 3a ee 08			ld a, (.dmark+1)  
08e2 32 78 fb			ld (debug_mark+1),a  
08e5 3a ef 08			ld a, (.dmark+2)  
08e8 32 79 fb			ld (debug_mark+2),a  
08eb 18 03			jr .pastdmark  
08ed ..			.dmark: db "AP1"  
08f0 f1			.pastdmark: pop af  
08f1			endm  
# End of macro DMARK
08f1					CALLMONITOR 
08f1 cd 92 16			call break_point_state  
08f4				endm  
# End of macro CALLMONITOR
08f4				endif 
08f4			 
08f4 7d				ld a, l 
08f5 32 5b f8			ld (store_tmpid), a 
08f8			 
08f8				; get file header  
08f8			 
08f8 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08fa 3a 5b f8			ld a, (store_tmpid) 
08fd 5f				ld e, a 
08fe			 
08fe 21 40 00				ld hl, STORE_BLOCK_PHY 
0901 cd 2d 06				call storage_findnextid 
0904			 
0904 22 4c f8			ld (store_tmppageid), hl 
0907			 
0907				; TODO handle file id not found 
0907			 
0907				if DEBUG_STORESE 
0907					DMARK "AP2" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 77 fb			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 78 fb			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 79 fb			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "AP2"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 92 16			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923			 
0923				; update file extent count 
0923			 
0923 11 62 f8			ld de, store_page 
0926			 
0926 cd 0c 03			call storage_read_block 
0929			 
0929				if DEBUG_STORESE 
0929					DMARK "AP3" 
0929 f5				push af  
092a 3a 3e 09			ld a, (.dmark)  
092d 32 77 fb			ld (debug_mark),a  
0930 3a 3f 09			ld a, (.dmark+1)  
0933 32 78 fb			ld (debug_mark+1),a  
0936 3a 40 09			ld a, (.dmark+2)  
0939 32 79 fb			ld (debug_mark+2),a  
093c 18 03			jr .pastdmark  
093e ..			.dmark: db "AP3"  
0941 f1			.pastdmark: pop af  
0942			endm  
# End of macro DMARK
0942					CALLMONITOR 
0942 cd 92 16			call break_point_state  
0945				endm  
# End of macro CALLMONITOR
0945				endif 
0945			;	ld (store_tmppageid), hl 
0945			 
0945 3a 64 f8			ld a, (store_page+2) 
0948 3c				inc a 
0949 32 64 f8			ld (store_page+2), a 
094c 32 5a f8			ld (store_tmpext), a 
094f				 
094f				if DEBUG_STORESE 
094f					DMARK "AP3" 
094f f5				push af  
0950 3a 64 09			ld a, (.dmark)  
0953 32 77 fb			ld (debug_mark),a  
0956 3a 65 09			ld a, (.dmark+1)  
0959 32 78 fb			ld (debug_mark+1),a  
095c 3a 66 09			ld a, (.dmark+2)  
095f 32 79 fb			ld (debug_mark+2),a  
0962 18 03			jr .pastdmark  
0964 ..			.dmark: db "AP3"  
0967 f1			.pastdmark: pop af  
0968			endm  
# End of macro DMARK
0968					CALLMONITOR 
0968 cd 92 16			call break_point_state  
096b				endm  
# End of macro CALLMONITOR
096b				endif 
096b 2a 4c f8			ld hl, (store_tmppageid) 
096e 11 62 f8			ld de, store_page 
0971 cd 71 03			call storage_write_block 
0974			 
0974				; find free block 
0974			 
0974 11 00 00			ld de, 0			 ; file extent to locate 
0977			 
0977 21 40 00				ld hl, STORE_BLOCK_PHY 
097a cd 2d 06				call storage_findnextid 
097d			 
097d					; TODO handle no space left 
097d					 
097d 22 4c f8				ld (store_tmppageid), hl 
0980			 
0980				if DEBUG_STORESE 
0980					DMARK "AP4" 
0980 f5				push af  
0981 3a 95 09			ld a, (.dmark)  
0984 32 77 fb			ld (debug_mark),a  
0987 3a 96 09			ld a, (.dmark+1)  
098a 32 78 fb			ld (debug_mark+1),a  
098d 3a 97 09			ld a, (.dmark+2)  
0990 32 79 fb			ld (debug_mark+2),a  
0993 18 03			jr .pastdmark  
0995 ..			.dmark: db "AP4"  
0998 f1			.pastdmark: pop af  
0999			endm  
# End of macro DMARK
0999					CALLMONITOR 
0999 cd 92 16			call break_point_state  
099c				endm  
# End of macro CALLMONITOR
099c				endif 
099c					; init the buffer with zeros so we can id if the buffer is full or not 
099c			 
099c e5					push hl 
099d c5					push bc 
099e			 
099e 21 62 f8				ld hl, store_page 
09a1 06 40				ld b, STORE_BLOCK_PHY 
09a3 3e 00				ld a, 0 
09a5 77			.zeroblock:	ld (hl), a 
09a6 23					inc hl 
09a7 10 fc				djnz .zeroblock 
09a9			 
09a9 c1					pop bc 
09aa e1					pop hl 
09ab			 
09ab					; construct block 
09ab			 
09ab 3a 5b f8				ld a, (store_tmpid) 
09ae 32 62 f8				ld (store_page), a   ; file id 
09b1 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09b4 32 63 f8				ld (store_page+1), a 
09b7			 
09b7 e1					pop hl    ; get string to write 
09b8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ba 11 64 f8				ld de, store_page+2 
09bd			 
09bd				if DEBUG_STORESE 
09bd					DMARK "AP5" 
09bd f5				push af  
09be 3a d2 09			ld a, (.dmark)  
09c1 32 77 fb			ld (debug_mark),a  
09c4 3a d3 09			ld a, (.dmark+1)  
09c7 32 78 fb			ld (debug_mark+1),a  
09ca 3a d4 09			ld a, (.dmark+2)  
09cd 32 79 fb			ld (debug_mark+2),a  
09d0 18 03			jr .pastdmark  
09d2 ..			.dmark: db "AP5"  
09d5 f1			.pastdmark: pop af  
09d6			endm  
# End of macro DMARK
09d6					CALLMONITOR 
09d6 cd 92 16			call break_point_state  
09d9				endm  
# End of macro CALLMONITOR
09d9				endif 
09d9			 
09d9			 
09d9			 
09d9					; fill buffer with data until end of string or full block 
09d9			 
09d9 7e			.appd:		ld a, (hl) 
09da 12					ld (de), a 
09db fe 00				cp 0 
09dd 28 04				jr z, .appdone 
09df 23					inc hl 
09e0 13					inc de 
09e1 10 f6				djnz .appd 
09e3			 
09e3 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e4 f5					push af   		; save last byte dumped 
09e5			 
09e5			 
09e5 2a 4c f8			ld hl, (store_tmppageid) 
09e8 11 62 f8			ld de, store_page 
09eb				if DEBUG_STORESE 
09eb					DMARK "AP6" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 77 fb			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 78 fb			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 79 fb			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "AP6"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 92 16			call break_point_state  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd 71 03				call storage_write_block 
0a0a			 
0a0a			 
0a0a				; was that a full block of data written? 
0a0a				; any more to write out? 
0a0a			 
0a0a				; if yes then set vars and jump to start of function again 
0a0a			 
0a0a f1					pop af 
0a0b d1					pop de 
0a0c			 
0a0c fe 00				cp 0		 ; no, string was fully written 
0a0e c8					ret z 
0a0f			 
0a0f					; setup vars for next cycle 
0a0f			 
0a0f 3a 5b f8				ld a, (store_tmpid) 
0a12 6f					ld l, a 
0a13 26 00				ld h, 0 
0a15			 
0a15 c3 d7 08			 	jp storage_append	 ; yes, need to write out some more 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			if DEBUG_STORECF 
0a18			storageput:	 
0a18					ret 
0a18			storageread: 
0a18					ld hl, store_page 
0a18					ld b, 200 
0a18					ld a,0 
0a18			.src:		ld (hl),a 
0a18					inc hl 
0a18					djnz .src 
0a18					 
0a18			 
0a18					ld de, 0 
0a18					ld bc, 1 
0a18					ld hl, store_page 
0a18					call cfRead 
0a18			 
0a18				call cfGetError 
0a18				ld hl,scratch 
0a18				call hexout 
0a18				ld hl, scratch+2 
0a18				ld a, 0 
0a18				ld (hl),a 
0a18				ld de, scratch 
0a18				ld a,display_row_1 
0a18				call str_at_display 
0a18				call update_display 
0a18			 
0a18					ld hl, store_page 
0a18					ld (os_cur_ptr),hl 
0a18			 
0a18					ret 
0a18			endif 
0a18			 
0a18			 
0a18			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a18			 
0a18			storage_clear_page: 
0a18 e5				push hl 
0a19 d5				push de 
0a1a c5				push bc 
0a1b 21 62 f8			ld hl, store_page 
0a1e 3e 00			ld a, 0 
0a20 77				ld (hl), a 
0a21			 
0a21 11 63 f8			ld de, store_page+1 
0a24 01 40 00			ld bc, STORE_BLOCK_PHY 
0a27			 
0a27 ed b0			ldir 
0a29				 
0a29 c1				pop bc 
0a2a d1				pop de 
0a2b e1				pop hl 
0a2c c9				ret 
0a2d			 
0a2d			; eof 
# End of file firmware_storage.asm
0a2d			  
0a2d			; support routines for above hardware abstraction layer  
0a2d			  
0a2d			include "firmware_general.asm"        ; general support functions  
0a2d			 
0a2d			; word look up 
0a2d			 
0a2d			; in 
0a2d			; a is the index 
0a2d			; hl is pointer start of array 
0a2d			; 
0a2d			; returns 
0a2d			; hl to the word 
0a2d			; 
0a2d			 
0a2d			table_lookup:  
0a2d d5					push de 
0a2e eb					ex de, hl 
0a2f			 
0a2f 6f					ld l, a 
0a30 26 00				ld h, 0 
0a32 29					add hl, hl 
0a33 19					add hl, de 
0a34 7e					ld a, (hl) 
0a35 23					inc hl 
0a36 66					ld h,(hl) 
0a37 6f					ld l, a 
0a38			 
0a38 d1					pop de 
0a39 c9					ret 
0a3a			 
0a3a			; Delay loops 
0a3a			 
0a3a			 
0a3a			 
0a3a			aDelayInMS: 
0a3a c5				push bc 
0a3b 47				ld b,a 
0a3c			msdelay: 
0a3c c5				push bc 
0a3d				 
0a3d			 
0a3d 01 41 00			ld bc,041h 
0a40 cd 58 0a			call delayloop 
0a43 c1				pop bc 
0a44 05				dec b 
0a45 20 f5			jr nz,msdelay 
0a47			 
0a47			;if CPU_CLOCK_8MHZ 
0a47			;msdelay8: 
0a47			;	push bc 
0a47			;	 
0a47			; 
0a47			;	ld bc,041h 
0a47			;	call delayloop 
0a47			;	pop bc 
0a47			;	dec b 
0a47			;	jr nz,msdelay8 
0a47			;endif 
0a47			 
0a47			 
0a47 c1				pop bc 
0a48 c9				ret 
0a49			 
0a49			 
0a49			delay250ms: 
0a49				;push de 
0a49 01 00 40			ld bc, 04000h 
0a4c c3 58 0a			jp delayloop 
0a4f			delay500ms: 
0a4f				;push de 
0a4f 01 00 80			ld bc, 08000h 
0a52 c3 58 0a			jp delayloop 
0a55			delay1s: 
0a55				;push bc 
0a55			   ; Clobbers A, d and e 
0a55 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a58			delayloop: 
0a58 c5			    push bc 
0a59			 
0a59			if BASE_CPM 
0a59				ld bc, CPM_DELAY_TUNE 
0a59			.cpmloop: 
0a59				push bc 
0a59			 
0a59			endif 
0a59			 
0a59			 
0a59			 
0a59			delayloopi: 
0a59			;	push bc 
0a59			;.dl: 
0a59 cb 47		    bit     0,a    	; 8 
0a5b cb 47		    bit     0,a    	; 8 
0a5d cb 47		    bit     0,a    	; 8 
0a5f e6 ff		    and     255  	; 7 
0a61 0b			    dec     bc      	; 6 
0a62 79			    ld      a,c     	; 4 
0a63 b0			    or      b     	; 4 
0a64 c2 59 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a67			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a67				;pop de 
0a67			;pop bc 
0a67			 
0a67			if BASE_CPM 
0a67				pop bc 
0a67				 
0a67			    dec     bc      	; 6 
0a67			    ld      a,c     	; 4 
0a67			    or      b     	; 4 
0a67			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a67				 
0a67			 
0a67			endif 
0a67			;if CPU_CLOCK_8MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67			 
0a67			;if CPU_CLOCK_10MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67 c1			    pop bc 
0a68			 
0a68 c9				ret 
0a69			 
0a69			 
0a69			 
0a69			; eof 
# End of file firmware_general.asm
0a69			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a69			; display routines that use the physical hardware abstraction layer 
0a69			 
0a69			 
0a69			; information window 
0a69			 
0a69			; pass hl with 1st string to display 
0a69			; pass de with 2nd string to display 
0a69			 
0a69			info_panel: 
0a69 e5				push hl 
0a6a			 
0a6a 2a d8 f8			ld hl, (display_fb_active) 
0a6d e5				push hl    ; future de destination 
0a6e 21 bd fa				ld hl, display_fb0 
0a71 22 d8 f8				ld (display_fb_active), hl 
0a74			 
0a74 cd d5 0a			call clear_display 
0a77			 
0a77			 
0a77 3e 55			ld a, display_row_3 + 5 
0a79 cd e8 0a			call str_at_display 
0a7c			 
0a7c e1				pop hl 
0a7d d1				pop de 
0a7e			 
0a7e e5				push hl 
0a7f			 
0a7f			 
0a7f 3e 2d			ld a, display_row_2 + 5 
0a81 cd e8 0a			call str_at_display 
0a84			 
0a84			 
0a84 cd f8 0a			call update_display 
0a87 cd 97 1b			call next_page_prompt 
0a8a cd d5 0a			call clear_display 
0a8d			 
0a8d				 
0a8d 21 1c fa				ld hl, display_fb1 
0a90 22 d8 f8				ld (display_fb_active), hl 
0a93 cd f8 0a			call update_display 
0a96			 
0a96			 
0a96 c9				ret 
0a97			 
0a97			 
0a97			 
0a97			 
0a97			; TODO windowing? 
0a97			 
0a97			; TODO scroll line up 
0a97			 
0a97			scroll_up: 
0a97			 
0a97 e5				push hl 
0a98 d5				push de 
0a99 c5				push bc 
0a9a			 
0a9a				; get frame buffer  
0a9a			 
0a9a 2a d8 f8			ld hl, (display_fb_active) 
0a9d e5				push hl    ; future de destination 
0a9e			 
0a9e 11 28 00			ld  de, display_cols 
0aa1 19				add hl, de 
0aa2			 
0aa2 d1				pop de 
0aa3			 
0aa3				;ex de, hl 
0aa3 01 9f 00			ld bc, display_fb_len -1  
0aa6			;if DEBUG_FORTH_WORDS 
0aa6			;	DMARK "SCL" 
0aa6			;	CALLMONITOR 
0aa6			;endif	 
0aa6 ed b0			ldir 
0aa8			 
0aa8				; wipe bottom row 
0aa8			 
0aa8			 
0aa8 2a d8 f8			ld hl, (display_fb_active) 
0aab 11 a0 00			ld de, display_cols*display_rows 
0aae 19				add hl, de 
0aaf 06 28			ld b, display_cols 
0ab1 3e 20			ld a, ' ' 
0ab3			.scwipe: 
0ab3 77				ld (hl), a 
0ab4 2b				dec hl 
0ab5 10 fc			djnz .scwipe 
0ab7			 
0ab7				;pop hl 
0ab7			 
0ab7 c1				pop bc 
0ab8 d1				pop de 
0ab9 e1				pop hl 
0aba			 
0aba c9				ret 
0abb			 
0abb			 
0abb			;scroll_upo: 
0abb			;	ld de, display_row_1 
0abb			 ;	ld hl, display_row_2 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_2 
0abb			 ;	ld hl, display_row_3 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_3 
0abb			 ;	ld hl, display_row_4 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			 
0abb			; TODO clear row 4 
0abb			 
0abb			;	ret 
0abb			 
0abb				 
0abb			scroll_down: 
0abb			 
0abb e5				push hl 
0abc d5				push de 
0abd c5				push bc 
0abe			 
0abe				; get frame buffer  
0abe			 
0abe 2a d8 f8			ld hl, (display_fb_active) 
0ac1			 
0ac1 11 9f 00			ld de, display_fb_len - 1 
0ac4 19				add hl, de 
0ac5			 
0ac5 e5			push hl    ; future de destination 
0ac6			 
0ac6 11 28 00			ld  de, display_cols 
0ac9 ed 52			sbc hl, de 
0acb			 
0acb			 
0acb d1				pop de 
0acc			 
0acc			;	ex de, hl 
0acc 01 9f 00			ld bc, display_fb_len -1  
0acf			 
0acf			 
0acf				 
0acf			 
0acf ed b0			ldir 
0ad1			 
0ad1				; wipe bottom row 
0ad1			 
0ad1			 
0ad1			;	ld hl, (display_fb_active) 
0ad1			;;	ld de, display_cols*display_rows 
0ad1			;;	add hl, de 
0ad1			;	ld b, display_cols 
0ad1			;	ld a, ' ' 
0ad1			;.scwiped: 
0ad1			;	ld (hl), a 
0ad1			;	dec hl 
0ad1			;	djnz .scwiped 
0ad1			 
0ad1				;pop hl 
0ad1			 
0ad1 c1				pop bc 
0ad2 d1				pop de 
0ad3 e1				pop hl 
0ad4			 
0ad4 c9				ret 
0ad5			;scroll_down: 
0ad5			;	ld de, display_row_4 
0ad5			;	ld hl, display_row_3 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_3 
0ad5			; 	ld hl, display_row_2 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_2 
0ad5			;	ld hl, display_row_1 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;;; TODO clear row 1 
0ad5			;	ret 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			; clear active frame buffer 
0ad5			 
0ad5			clear_display: 
0ad5 3e 20			ld a, ' ' 
0ad7 c3 da 0a			jp fill_display 
0ada			 
0ada			; fill active frame buffer with a char in A 
0ada			 
0ada			fill_display: 
0ada 06 a0			ld b,display_fb_len 
0adc 2a d8 f8			ld hl, (display_fb_active) 
0adf 77			.fd1:	ld (hl),a 
0ae0 23				inc hl 
0ae1 10 fc			djnz .fd1 
0ae3 23				inc hl 
0ae4 3e 00			ld a,0 
0ae6 77				ld (hl),a 
0ae7			 
0ae7			 
0ae7 c9				ret 
0ae8			; Write string (DE) at pos (A) to active frame buffer 
0ae8			 
0ae8 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0aeb 06 00					ld b,0 
0aed 4f					ld c,a 
0aee 09					add hl,bc 
0aef 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0af0 b7			            OR   A              ;Null terminator? 
0af1 c8			            RET  Z              ;Yes, so finished 
0af2 77					ld (hl),a 
0af3 23				inc hl 
0af4 13			            INC  DE             ;Point to next character 
0af5 18 f8		            JR   .sad1     ;Repeat 
0af7 c9					ret 
0af8			 
0af8			; using current frame buffer write to physical display 
0af8			 
0af8			update_display: 
0af8 e5				push hl 
0af9 2a d8 f8			ld hl, (display_fb_active) 
0afc cd 02 65			call write_display 
0aff e1				pop hl 
0b00 c9				ret 
0b01			 
0b01			; TODO scrolling 
0b01			 
0b01			 
0b01			; move cursor right one char 
0b01			cursor_right: 
0b01			 
0b01				; TODO shift right 
0b01				; TODO if beyond max col 
0b01				; TODO       cursor_next_line 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cursor_next_line: 
0b02				; TODO first char 
0b02				; TODO line down 
0b02				; TODO if past last row 
0b02				; TODO    scroll up 
0b02			 
0b02 c9				ret 
0b03			 
0b03			cursor_left: 
0b03				; TODO shift left 
0b03				; TODO if beyond left  
0b03				; TODO     cursor prev line 
0b03				 
0b03 c9				ret 
0b04			 
0b04			cursor_prev_line: 
0b04				; TODO last char 
0b04				; TODO line up 
0b04				; TODO if past first row 
0b04				; TODO   scroll down 
0b04			 
0b04 c9				ret 
0b05			 
0b05			 
0b05			cout: 
0b05				; A - char 
0b05 c9				ret 
0b06			 
0b06			 
0b06			; Display a menu and allow item selection (optional toggle items) 
0b06			; 
0b06			; format: 
0b06			; hl pointer to word array with zero term for items 
0b06			; e.g.    db item1 
0b06			;         db .... 
0b06			;         db 0 
0b06			; 
0b06			; a = starting menu item  
0b06			; 
0b06			; de = pointer item toggle array   (todo) 
0b06			; 
0b06			; returns item selected in a 1-... 
0b06			; returns 0 if back button pressed 
0b06			; 
0b06			; NOTE: Uses system frame buffer to display 
0b06			; 
0b06			; LEFT, Q = go back 
0b06			; RIGHT, SPACE, CR = select 
0b06			; UP, A - Up 
0b06			; DOWN, Z - Down 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			menu: 
0b06			 
0b06					; keep array pointer 
0b06			 
0b06 22 60 f8				ld (store_tmp1), hl 
0b09 32 5e f8				ld (store_tmp2), a 
0b0c			 
0b0c					; check for key bounce 
0b0c			 
0b0c			if BASE_KEV 
0b0c			 
0b0c cd 4d 68		.mbounce:	call cin 
0b0f fe 00				cp 0 
0b11 20 f9				jr nz, .mbounce 
0b13			endif 
0b13					; for ease use ex 
0b13			 
0b13					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b13 21 bd fa				ld hl, display_fb0 
0b16 22 d8 f8				ld (display_fb_active), hl 
0b19			 
0b19 cd d5 0a		.mloop:		call clear_display 
0b1c cd f8 0a				call update_display 
0b1f			 
0b1f					; draw selection id '>' at 1 
0b1f			 
0b1f					; init start of list display 
0b1f			 
0b1f 3e 05				ld a, 5 
0b21 32 5c f8				ld (store_tmp3), a   ; display row count 
0b24 3a 5e f8				ld a,( store_tmp2) 
0b27 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b2a			 
0b2a					 
0b2a			.mitem:	 
0b2a			 
0b2a			 
0b2a 3a 5f f8				ld a,(store_tmp2+1) 
0b2d 6f					ld l, a 
0b2e 26 00				ld h, 0 
0b30 29					add hl, hl 
0b31 ed 5b 60 f8			ld de, (store_tmp1) 
0b35 19					add hl, de 
0b36 7e					ld a, (hl) 
0b37 23					inc hl 
0b38 66					ld h,(hl) 
0b39 6f					ld l, a 
0b3a			 
0b3a cd 32 0d				call ishlzero 
0b3d 28 1a				jr z, .mdone 
0b3f			 
0b3f eb					ex de, hl 
0b40 3a 5c f8				ld a, (store_tmp3) 
0b43 cd e8 0a				call str_at_display 
0b46					 
0b46			 
0b46					; next item 
0b46 3a 5f f8				ld a, (store_tmp2+1) 
0b49 3c					inc a 
0b4a 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b4d			 
0b4d			 		; next row 
0b4d			 
0b4d 3a 5c f8				ld a, (store_tmp3) 
0b50 c6 28				add display_cols 
0b52 32 5c f8				ld (store_tmp3), a 
0b55			 
0b55					; at end of screen? 
0b55			 
0b55 fe 10				cp display_rows*4 
0b57 20 d1				jr nz, .mitem 
0b59			 
0b59			 
0b59			.mdone: 
0b59 cd 32 0d				call ishlzero 
0b5c 28 08				jr z, .nodn 
0b5e			 
0b5e 3e 78				ld a, display_row_4 
0b60 11 df 0b				ld de, .mdown 
0b63 cd e8 0a				call str_at_display 
0b66			 
0b66					; draw options to fill the screens with active item on line 1 
0b66					; if current option is 2 or more then display ^ in top 
0b66			 
0b66 3a 5e f8		.nodn:		ld a, (store_tmp2) 
0b69 fe 00				cp 0 
0b6b 28 08				jr z, .noup 
0b6d			 
0b6d 3e 00				ld a, 0 
0b6f 11 dd 0b				ld de, .mup 
0b72 cd e8 0a				call str_at_display 
0b75			 
0b75 3e 02		.noup:		ld a, 2 
0b77 11 db 0b				ld de, .msel 
0b7a cd e8 0a				call str_at_display 
0b7d			 
0b7d					; if current option + 1 is not null then display V in bottom 
0b7d					; get key 
0b7d cd f8 0a				call update_display 
0b80			 
0b80			 
0b80					; handle key 
0b80			 
0b80 cd 3c 68				call cin_wait 
0b83			 
0b83 fe 05				cp KEY_UP 
0b85 28 2b				jr z, .mgoup 
0b87 fe 61				cp 'a' 
0b89 28 27				jr z, .mgoup 
0b8b fe 0a				cp KEY_DOWN 
0b8d 28 32				jr z, .mgod 
0b8f fe 7a				cp 'z' 
0b91 28 2e				jr z, .mgod 
0b93 fe 20				cp ' ' 
0b95 28 34				jr z, .goend 
0b97 fe 0c				cp KEY_RIGHT 
0b99 28 30				jr z, .goend 
0b9b fe 0d				cp KEY_CR 
0b9d 28 2c				jr z, .goend 
0b9f fe 71				cp 'q' 
0ba1 28 0b				jr z, .goback 
0ba3			 
0ba3 fe 0b				cp KEY_LEFT 
0ba5 28 07				jr z, .goback 
0ba7 fe 08				cp KEY_BS 
0ba9 28 03				jr z, .goback 
0bab c3 19 0b				jp .mloop 
0bae			 
0bae			.goback: 
0bae 3e 00			ld a, 0 
0bb0 18 1d			jr .goend2 
0bb2			 
0bb2				; move up one 
0bb2			.mgoup: 
0bb2 3a 5e f8				ld a, (store_tmp2) 
0bb5 fe 00				cp 0 
0bb7 ca 19 0b				jp z, .mloop 
0bba 3d					dec a 
0bbb 32 5e f8				ld (store_tmp2), a 
0bbe c3 19 0b				jp .mloop 
0bc1			 
0bc1				; move down one 
0bc1			.mgod: 
0bc1 3a 5e f8				ld a, (store_tmp2) 
0bc4 3c					inc a 
0bc5 32 5e f8				ld (store_tmp2), a 
0bc8 c3 19 0b				jp .mloop 
0bcb			 
0bcb			 
0bcb			.goend: 
0bcb					; get selected item number 
0bcb			 
0bcb 3a 5e f8				ld a, (store_tmp2) 
0bce 3c					inc a 
0bcf			 
0bcf			.goend2: 
0bcf f5					push af 
0bd0			 
0bd0					; restore active fb 
0bd0					; TODO BUG assumes fb1 
0bd0			 
0bd0 21 1c fa				ld hl, display_fb1 
0bd3 22 d8 f8				ld (display_fb_active), hl 
0bd6			 
0bd6					; restore main regs 
0bd6			 
0bd6			 
0bd6 cd f8 0a				call update_display 
0bd9			 
0bd9 f1					pop af 
0bda			 
0bda c9				ret 
0bdb			 
0bdb .. 00		.msel:   db ">",0 
0bdd .. 00		.mup:   db "^",0 
0bdf .. 00		.mdown:   db "v",0 
0be1			 
0be1			 
0be1			; eof 
0be1			 
# End of file firmware_display.asm
0be1			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0be1			; random number generators 
0be1			 
0be1			 
0be1			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0be1			 
0be1			 
0be1			;-----> Generate a random number 
0be1			; output a=answer 0<=a<=255 
0be1			; all registers are preserved except: af 
0be1			random: 
0be1 e5			        push    hl 
0be2 d5			        push    de 
0be3 2a ba f8		        ld      hl,(randData) 
0be6 ed 5f		        ld      a,r 
0be8 57			        ld      d,a 
0be9 5e			        ld      e,(hl) 
0bea 19			        add     hl,de 
0beb 85			        add     a,l 
0bec ac			        xor     h 
0bed 22 ba f8		        ld      (randData),hl 
0bf0 d1			        pop     de 
0bf1 e1			        pop     hl 
0bf2 c9			        ret 
0bf3			 
0bf3			 
0bf3			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf3			 
0bf3			 
0bf3			 
0bf3			;------LFSR------ 
0bf3			;James Montelongo 
0bf3			;optimized by Spencer Putt 
0bf3			;out: 
0bf3			; a = 8 bit random number 
0bf3			RandLFSR: 
0bf3 21 c0 f8		        ld hl,LFSRSeed+4 
0bf6 5e			        ld e,(hl) 
0bf7 23			        inc hl 
0bf8 56			        ld d,(hl) 
0bf9 23			        inc hl 
0bfa 4e			        ld c,(hl) 
0bfb 23			        inc hl 
0bfc 7e			        ld a,(hl) 
0bfd 47			        ld b,a 
0bfe cb 13		        rl e  
0c00 cb 12			rl d 
0c02 cb 11		        rl c  
0c04 17				rla 
0c05 cb 13		        rl e  
0c07 cb 12			rl d 
0c09 cb 11		        rl c  
0c0b 17				rla 
0c0c cb 13		        rl e  
0c0e cb 12			rl d 
0c10 cb 11		        rl c  
0c12 17				rla 
0c13 67			        ld h,a 
0c14 cb 13		        rl e  
0c16 cb 12			rl d 
0c18 cb 11		        rl c  
0c1a 17				rla 
0c1b a8			        xor b 
0c1c cb 13		        rl e  
0c1e cb 12			rl d 
0c20 ac			        xor h 
0c21 a9			        xor c 
0c22 aa			        xor d 
0c23 21 c2 f8		        ld hl,LFSRSeed+6 
0c26 11 c3 f8		        ld de,LFSRSeed+7 
0c29 01 07 00		        ld bc,7 
0c2c ed b8		        lddr 
0c2e 12			        ld (de),a 
0c2f c9			        ret 
0c30			 
0c30			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c30			 
0c30			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c30			 
0c30			 
0c30			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c30			 
0c30			prng16: 
0c30			;Inputs: 
0c30			;   (seed1) contains a 16-bit seed value 
0c30			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c30			;Outputs: 
0c30			;   HL is the result 
0c30			;   BC is the result of the LCG, so not that great of quality 
0c30			;   DE is preserved 
0c30			;Destroys: 
0c30			;   AF 
0c30			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c30			;160cc 
0c30			;26 bytes 
0c30 2a b4 f8		    ld hl,(seed1) 
0c33 44			    ld b,h 
0c34 4d			    ld c,l 
0c35 29			    add hl,hl 
0c36 29			    add hl,hl 
0c37 2c			    inc l 
0c38 09			    add hl,bc 
0c39 22 b4 f8		    ld (seed1),hl 
0c3c 2a b2 f8		    ld hl,(seed2) 
0c3f 29			    add hl,hl 
0c40 9f			    sbc a,a 
0c41 e6 2d		    and %00101101 
0c43 ad			    xor l 
0c44 6f			    ld l,a 
0c45 22 b2 f8		    ld (seed2),hl 
0c48 09			    add hl,bc 
0c49 c9			    ret 
0c4a			 
0c4a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c4a			 
0c4a			rand32: 
0c4a			;Inputs: 
0c4a			;   (seed1_0) holds the lower 16 bits of the first seed 
0c4a			;   (seed1_1) holds the upper 16 bits of the first seed 
0c4a			;   (seed2_0) holds the lower 16 bits of the second seed 
0c4a			;   (seed2_1) holds the upper 16 bits of the second seed 
0c4a			;   **NOTE: seed2 must be non-zero 
0c4a			;Outputs: 
0c4a			;   HL is the result 
0c4a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c4a			;Destroys: 
0c4a			;   AF 
0c4a			;Tested and passes all CAcert tests 
0c4a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c4a			;it has a period of 18,446,744,069,414,584,320 
0c4a			;roughly 18.4 quintillion. 
0c4a			;LFSR taps: 0,2,6,7  = 11000101 
0c4a			;291cc 
0c4a			;seed1_0=$+1 
0c4a			;    ld hl,12345 
0c4a			;seed1_1=$+1 
0c4a			;    ld de,6789 
0c4a			;    ld b,h 
0c4a			;    ld c,l 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    inc l 
0c4a			;    add hl,bc 
0c4a			;    ld (seed1_0),hl 
0c4a			;    ld hl,(seed1_1) 
0c4a			;    adc hl,de 
0c4a			;    ld (seed1_1),hl 
0c4a			;    ex de,hl 
0c4a			;seed2_0=$+1 
0c4a			;    ld hl,9876 
0c4a			;seed2_1=$+1 
0c4a			;    ld bc,54321 
0c4a			;    add hl,hl \ rl c \ rl b 
0c4a			;    ld (seed2_1),bc 
0c4a			;    sbc a,a 
0c4a			;    and %11000101 
0c4a			;    xor l 
0c4a			;    ld l,a 
0c4a			;    ld (seed2_0),hl 
0c4a			;    ex de,hl 
0c4a			;    add hl,bc 
0c4a			;    ret 
0c4a			; 
0c4a			 
0c4a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c4a			; 20 bytes, 86 cycles (excluding ret) 
0c4a			 
0c4a			; returns   hl = pseudorandom number 
0c4a			; corrupts   a 
0c4a			 
0c4a			; generates 16-bit pseudorandom numbers with a period of 65535 
0c4a			; using the xorshift method: 
0c4a			 
0c4a			; hl ^= hl << 7 
0c4a			; hl ^= hl >> 9 
0c4a			; hl ^= hl << 8 
0c4a			 
0c4a			; some alternative shift triplets which also perform well are: 
0c4a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c4a			 
0c4a			;  org 32768 
0c4a			 
0c4a			xrnd: 
0c4a 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0c4d 3e 00		  ld a,0 
0c4f bd			  cp l 
0c50 20 02		  jr nz, .xrnd1 
0c52 2e 01		  ld l, 1 
0c54			.xrnd1: 
0c54			 
0c54 7c			  ld a,h 
0c55 1f			  rra 
0c56 7d			  ld a,l 
0c57 1f			  rra 
0c58 ac			  xor h 
0c59 67			  ld h,a 
0c5a 7d			  ld a,l 
0c5b 1f			  rra 
0c5c 7c			  ld a,h 
0c5d 1f			  rra 
0c5e ad			  xor l 
0c5f 6f			  ld l,a 
0c60 ac			  xor h 
0c61 67			  ld h,a 
0c62			 
0c62 22 b8 f8		  ld (xrandc),hl 
0c65			 
0c65 c9			  ret 
0c66			;  
0c66			 
0c66			 
0c66			;;;; int maths 
0c66			 
0c66			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c66			; Divide 16-bit values (with 16-bit result) 
0c66			; In: Divide BC by divider DE 
0c66			; Out: BC = result, HL = rest 
0c66			; 
0c66			Div16: 
0c66 21 00 00		    ld hl,0 
0c69 78			    ld a,b 
0c6a 06 08		    ld b,8 
0c6c			Div16_Loop1: 
0c6c 17			    rla 
0c6d ed 6a		    adc hl,hl 
0c6f ed 52		    sbc hl,de 
0c71 30 01		    jr nc,Div16_NoAdd1 
0c73 19			    add hl,de 
0c74			Div16_NoAdd1: 
0c74 10 f6		    djnz Div16_Loop1 
0c76 17			    rla 
0c77 2f			    cpl 
0c78 47			    ld b,a 
0c79 79			    ld a,c 
0c7a 48			    ld c,b 
0c7b 06 08		    ld b,8 
0c7d			Div16_Loop2: 
0c7d 17			    rla 
0c7e ed 6a		    adc hl,hl 
0c80 ed 52		    sbc hl,de 
0c82 30 01		    jr nc,Div16_NoAdd2 
0c84 19			    add hl,de 
0c85			Div16_NoAdd2: 
0c85 10 f6		    djnz Div16_Loop2 
0c87 17			    rla 
0c88 2f			    cpl 
0c89 41			    ld b,c 
0c8a 4f			    ld c,a 
0c8b c9			ret 
0c8c			 
0c8c			 
0c8c			;http://z80-heaven.wikidot.com/math 
0c8c			; 
0c8c			;Inputs: 
0c8c			;     DE and A are factors 
0c8c			;Outputs: 
0c8c			;     A is not changed 
0c8c			;     B is 0 
0c8c			;     C is not changed 
0c8c			;     DE is not changed 
0c8c			;     HL is the product 
0c8c			;Time: 
0c8c			;     342+6x 
0c8c			; 
0c8c			Mult16: 
0c8c			 
0c8c 06 08		     ld b,8          ;7           7 
0c8e 21 00 00		     ld hl,0         ;10         10 
0c91 29			       add hl,hl     ;11*8       88 
0c92 07			       rlca          ;4*8        32 
0c93 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c95 19			         add hl,de   ;--         -- 
0c96 10 f9		       djnz $-5      ;13*7+8     99 
0c98 c9			ret 
0c99			 
0c99			; 
0c99			; Square root of 16-bit value 
0c99			; In:  HL = value 
0c99			; Out:  D = result (rounded down) 
0c99			; 
0c99			;Sqr16: 
0c99			;    ld de,#0040 
0c99			;    ld a,l 
0c99			;    ld l,h 
0c99			;    ld h,d 
0c99			;    or a 
0c99			;    ld b,8 
0c99			;Sqr16_Loop: 
0c99			;    sbc hl,de 
0c99			;    jr nc,Sqr16_Skip 
0c99			;    add hl,de 
0c99			;Sqr16_Skip: 
0c99			;    ccf 
0c99			;    rl d 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    djnz Sqr16_Loop 
0c99			;    ret 
0c99			; 
0c99			; 
0c99			; Divide 8-bit values 
0c99			; In: Divide E by divider C 
0c99			; Out: A = result, B = rest 
0c99			; 
0c99			Div8: 
0c99 af			    xor a 
0c9a 06 08		    ld b,8 
0c9c			Div8_Loop: 
0c9c cb 13		    rl e 
0c9e 17			    rla 
0c9f 91			    sub c 
0ca0 30 01		    jr nc,Div8_NoAdd 
0ca2 81			    add a,c 
0ca3			Div8_NoAdd: 
0ca3 10 f7		    djnz Div8_Loop 
0ca5 47			    ld b,a 
0ca6 7b			    ld a,e 
0ca7 17			    rla 
0ca8 2f			    cpl 
0ca9 c9			    ret 
0caa			 
0caa			; 
0caa			; Multiply 8-bit value with a 16-bit value (unrolled) 
0caa			; In: Multiply A with DE 
0caa			; Out: HL = result 
0caa			; 
0caa			Mult12U: 
0caa 2e 00		    ld l,0 
0cac 87			    add a,a 
0cad 30 01		    jr nc,Mult12U_NoAdd0 
0caf 19			    add hl,de 
0cb0			Mult12U_NoAdd0: 
0cb0 29			    add hl,hl 
0cb1 87			    add a,a 
0cb2 30 01		    jr nc,Mult12U_NoAdd1 
0cb4 19			    add hl,de 
0cb5			Mult12U_NoAdd1: 
0cb5 29			    add hl,hl 
0cb6 87			    add a,a 
0cb7 30 01		    jr nc,Mult12U_NoAdd2 
0cb9 19			    add hl,de 
0cba			Mult12U_NoAdd2: 
0cba 29			    add hl,hl 
0cbb 87			    add a,a 
0cbc 30 01		    jr nc,Mult12U_NoAdd3 
0cbe 19			    add hl,de 
0cbf			Mult12U_NoAdd3: 
0cbf 29			    add hl,hl 
0cc0 87			    add a,a 
0cc1 30 01		    jr nc,Mult12U_NoAdd4 
0cc3 19			    add hl,de 
0cc4			Mult12U_NoAdd4: 
0cc4 29			    add hl,hl 
0cc5 87			    add a,a 
0cc6 30 01		    jr nc,Mult12U_NoAdd5 
0cc8 19			    add hl,de 
0cc9			Mult12U_NoAdd5: 
0cc9 29			    add hl,hl 
0cca 87			    add a,a 
0ccb 30 01		    jr nc,Mult12U_NoAdd6 
0ccd 19			    add hl,de 
0cce			Mult12U_NoAdd6: 
0cce 29			    add hl,hl 
0ccf 87			    add a,a 
0cd0 d0			    ret nc 
0cd1 19			    add hl,de 
0cd2 c9			    ret 
0cd3			 
0cd3			; 
0cd3			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd3			; In: Multiply A with DE 
0cd3			;      Put lowest value in A for most efficient calculation 
0cd3			; Out: HL = result 
0cd3			; 
0cd3			Mult12R: 
0cd3 21 00 00		    ld hl,0 
0cd6			Mult12R_Loop: 
0cd6 cb 3f		    srl a 
0cd8 30 01		    jr nc,Mult12R_NoAdd 
0cda 19			    add hl,de 
0cdb			Mult12R_NoAdd: 
0cdb cb 23		    sla e 
0cdd cb 12		    rl d 
0cdf b7			    or a 
0ce0 c2 d6 0c		    jp nz,Mult12R_Loop 
0ce3 c9			    ret 
0ce4			 
0ce4			; 
0ce4			; Multiply 16-bit values (with 32-bit result) 
0ce4			; In: Multiply BC with DE 
0ce4			; Out: BCHL = result 
0ce4			; 
0ce4			Mult32: 
0ce4 79			    ld a,c 
0ce5 48			    ld c,b 
0ce6 21 00 00		    ld hl,0 
0ce9 06 10		    ld b,16 
0ceb			Mult32_Loop: 
0ceb 29			    add hl,hl 
0cec 17			    rla 
0ced cb 11		    rl c 
0cef 30 07		    jr nc,Mult32_NoAdd 
0cf1 19			    add hl,de 
0cf2 ce 00		    adc a,0 
0cf4 d2 f8 0c		    jp nc,Mult32_NoAdd 
0cf7 0c			    inc c 
0cf8			Mult32_NoAdd: 
0cf8 10 f1		    djnz Mult32_Loop 
0cfa 41			    ld b,c 
0cfb 4f			    ld c,a 
0cfc c9			    ret 
0cfd			 
0cfd			 
0cfd			 
0cfd			; 
0cfd			; Multiply 8-bit values 
0cfd			; In:  Multiply H with E 
0cfd			; Out: HL = result 
0cfd			; 
0cfd			Mult8: 
0cfd 16 00		    ld d,0 
0cff 6a			    ld l,d 
0d00 06 08		    ld b,8 
0d02			Mult8_Loop: 
0d02 29			    add hl,hl 
0d03 30 01		    jr nc,Mult8_NoAdd 
0d05 19			    add hl,de 
0d06			Mult8_NoAdd: 
0d06 10 fa		    djnz Mult8_Loop 
0d08 c9			    ret 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			;;http://z80-heaven.wikidot.com/math 
0d09			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d09			; 
0d09			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d09			;     ld a,16        ;7 
0d09			;     ld hl,0        ;10 
0d09			;     jp $+5         ;10 
0d09			;.DivLoop: 
0d09			;       add hl,bc    ;-- 
0d09			;       dec a        ;64 
0d09			;       jr z,.DivLoopEnd        ;86 
0d09			; 
0d09			;       sla e        ;128 
0d09			;       rl d         ;128 
0d09			;       adc hl,hl    ;240 
0d09			;       sbc hl,bc    ;240 
0d09			;       jr nc,.DivLoop ;23|21 
0d09			;       inc e        ;-- 
0d09			;       jp .DivLoop+1 
0d09			; 
0d09			;.DivLoopEnd: 
0d09			 
0d09			;HL_Div_C: 
0d09			;Inputs: 
0d09			;     HL is the numerator 
0d09			;     C is the denominator 
0d09			;Outputs: 
0d09			;     A is the remainder 
0d09			;     B is 0 
0d09			;     C is not changed 
0d09			;     DE is not changed 
0d09			;     HL is the quotient 
0d09			; 
0d09			;       ld b,16 
0d09			;       xor a 
0d09			;         add hl,hl 
0d09			;         rla 
0d09			;         cp c 
0d09			;         jr c,$+4 
0d09			;           inc l 
0d09			;           sub c 
0d09			;         djnz $-7 
0d09			 
0d09			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d09			 
0d09			addatohl: 
0d09 85			    add   a, l    ; A = A+L 
0d0a 6f			    ld    l, a    ; L = A+L 
0d0b 8c			    adc   a, h    ; A = A+L+H+carry 
0d0c 95			    sub   l       ; A = H+carry 
0d0d 67			    ld    h, a    ; H = H+carry 
0d0e c9			ret 
0d0f			 
0d0f			addatode: 
0d0f 83			    add   a, e    ; A = A+L 
0d10 5f			    ld    e, a    ; L = A+L 
0d11 8a			    adc   a, d    ; A = A+L+H+carry 
0d12 93			    sub   e       ; A = H+carry 
0d13 57			    ld    d, a    ; H = H+carry 
0d14 c9			ret 
0d15			 
0d15			 
0d15			addatobc: 
0d15 81			    add   a, c    ; A = A+L 
0d16 4f			    ld    c, a    ; L = A+L 
0d17 88			    adc   a, b    ; A = A+L+H+carry 
0d18 91			    sub   c       ; A = H+carry 
0d19 47			    ld    b, a    ; H = H+carry 
0d1a c9			ret 
0d1b			 
0d1b			subafromhl: 
0d1b			   ; If A=0 do nothing 
0d1b			    ; Otherwise flip A's sign. Since 
0d1b			    ; the upper byte becomes -1, also 
0d1b			    ; substract 1 from H. 
0d1b ed 44		    neg 
0d1d ca 26 0d		    jp    z, Skip 
0d20 25			    dec   h 
0d21			     
0d21			    ; Now add the low byte as usual 
0d21			    ; Two's complement takes care of 
0d21			    ; ensuring the result is correct 
0d21 85			    add   a, l 
0d22 6f			    ld    l, a 
0d23 8c			    adc   a, h 
0d24 95			    sub   l 
0d25 67			    ld    h, a 
0d26			Skip: 
0d26 c9				ret 
0d27			 
0d27			 
0d27			; compare hl and de 
0d27			; returns:  
0d27			; if hl = de, z=1, s=0, c0=0 
0d27			; if hl > de, z=0, s=0, c=0 
0d27			; if hl < de, z=0, s=1, c=1 
0d27			cmp16:	 
0d27 b7				or a 
0d28 ed 52			sbc hl,de 
0d2a e0				ret po 
0d2b 7c				ld a,h 
0d2c 1f				rra 
0d2d ee 40			xor 01000000B 
0d2f 37				scf 
0d30 8f				adc a,a 
0d31 c9				ret 
0d32			 
0d32			 
0d32			; test if hl contains zero   - A is destroyed 
0d32			 
0d32			ishlzero:    
0d32 b7				or a     ; reset flags 
0d33 7c				ld a, h 
0d34 b5				or l        	 
0d35			 
0d35 c9				ret 
0d36			 
0d36			 
0d36			 
0d36			 
0d36			if FORTH_ENABLE_FLOATMATH 
0d36			;include "float/bbcmath.z80" 
0d36			include "float/lpfpcalc.asm" 
0d36			endif 
0d36			 
0d36			 
0d36			; eof 
0d36			 
# End of file firmware_maths.asm
0d36			include "firmware_strings.asm"   ; string handling  
0d36			 
0d36			 
0d36			; TODO string len 
0d36			; input text string, end on cr with zero term 
0d36			; a offset into frame buffer to start prompt 
0d36			; d is max length 
0d36			; e is display size TODO 
0d36			; c is current cursor position 
0d36			; hl is ptr to where string will be stored 
0d36			 
0d36			 
0d36			; TODO check limit of buffer for new inserts 
0d36			; TODO check insert does not push beyond buffer 
0d36			; TODO scroll in a limited display area 
0d36			; TODO scroll whole screen on page wrap 
0d36			 
0d36			 
0d36			; TODO handle KEY_PREVWORD 
0d36			; TODO handle KEY_NEXTWORD 
0d36			; TODO handle KEY_HOME 
0d36			; TODO handle KEY_END 
0d36			; TODO use LCD cursor? 
0d36			 
0d36 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d39 81					add c 
0d3a 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3d 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0d40 79					ld a, c 
0d41 cd 09 0d				call addatohl 
0d44 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d47 7a					ld a,d 
0d48 32 72 fb			        ld (input_size), a       ; save length of input area 
0d4b 79					ld a, c 
0d4c 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0d4f 7b					ld a,e 
0d50 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d53					 
0d53					 
0d53			 
0d53			;		ld a,(input_ptr) 
0d53			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d53			 
0d53			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d53					; init cursor shape if not set by the cin routines 
0d53 21 d0 f8				ld hl, cursor_shape 
0d56 3e ff				ld a, 255 
0d58 77					ld (hl), a 
0d59 23					inc hl 
0d5a 3e 00				ld a, 0 
0d5c 77					ld (hl), a 
0d5d			 
0d5d 3e 0f				ld a, CUR_BLINK_RATE 
0d5f 32 6c fb				ld (input_cur_flash), a 
0d62 3e 01				ld a, 1 
0d64 32 6b fb				ld (input_cur_onoff),a 
0d67			 
0d67			;	if DEBUG_INPUT 
0d67			;		push af 
0d67			;		ld a, 'I' 
0d67			;		ld (debug_mark),a 
0d67			;		pop af 
0d67			;		CALLMONITOR 
0d67			;	endif 
0d67			.is1:		; main entry loop 
0d67			 
0d67			 
0d67			 
0d67					; pause 1ms 
0d67			 
0d67 3e 01				ld a, 1 
0d69 cd 3a 0a				call aDelayInMS 
0d6c			 
0d6c					; dec flash counter 
0d6c 3a 6c fb				ld a, (input_cur_flash) 
0d6f 3d					dec a 
0d70 32 6c fb				ld (input_cur_flash), a 
0d73 fe 00				cp 0 
0d75 20 0d				jr nz, .nochgstate 
0d77			 
0d77			 
0d77					; change state 
0d77 3a 6b fb				ld a,(input_cur_onoff) 
0d7a ed 44				neg 
0d7c 32 6b fb				ld (input_cur_onoff),a 
0d7f			 
0d7f			 
0d7f					; reset on change of state 
0d7f 3e 0f				ld a, CUR_BLINK_RATE 
0d81 32 6c fb				ld (input_cur_flash), a 
0d84			 
0d84			.nochgstate: 
0d84					 
0d84					 
0d84			 
0d84					; display cursor  
0d84			 
0d84			;		ld hl, (input_start) 
0d84			;		ld a, (input_cursor) 
0d84			;		call addatohl 
0d84			 
0d84					; get char under cursor and replace with cursor 
0d84 2a 75 fb		ld hl, (input_ptr) 
0d87			;		ld a, (hl) 
0d87			;		ld (input_under_cursor),a 
0d87			;		ld a, '_' 
0d87			;		ld (hl), a 
0d87			 
0d87					; display string 
0d87			 
0d87 ed 5b 73 fb			ld de, (input_start) 
0d8b 3a 70 fb				ld a, (input_at_pos) 
0d8e cd e8 0a				call str_at_display 
0d91			;	        call update_display 
0d91			 
0d91					; find place to put the cursor 
0d91			;		add h 
0d91			;		ld l, display_row_1 
0d91			;		sub l 
0d91			; (input_at_pos) 
0d91					;ld c, a 
0d91			;		ld a, (input_cursor) 
0d91			;		ld l, (input_at_pos) 
0d91			;		;ld b, h 
0d91			;		add l 
0d91			;		ld (input_at_cursor),a 
0d91					;ld l,h 
0d91			 
0d91			;		ld h, 0 
0d91			;		ld l,(input_at_pos) 
0d91			;		ld a, (input_cursor) 
0d91			;		call addatohl 
0d91			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d91			;		call subafromhl 
0d91			;		ld a,l 
0d91			;		ld (input_at_cursor), a 
0d91			 
0d91				if DEBUG_INPUT 
0d91					ld a, (hardware_diag) 
0d91					cp 0 
0d91					jr z, .skip_input_diag 
0d91			 
0d91					ld a,(input_at_pos) 
0d91					ld hl, LFSRSeed 
0d91					call hexout 
0d91					ld a, (input_cursor) 
0d91					ld hl, LFSRSeed+2 
0d91					call hexout 
0d91					ld a,(input_at_cursor) 
0d91					ld hl, LFSRSeed+4 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_onoff) 
0d91					ld hl, LFSRSeed+6 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_flash) 
0d91					ld hl, LFSRSeed+8 
0d91					call hexout 
0d91			 
0d91					ld a,(input_len) 
0d91					ld hl, LFSRSeed+10 
0d91					call hexout 
0d91					ld hl, LFSRSeed+12 
0d91					ld a, 0 
0d91					ld (hl),a 
0d91					ld a, display_row_4 
0d91					ld de, LFSRSeed 
0d91					call str_at_display 
0d91					.skip_input_diag: 
0d91				endif 
0d91			 
0d91					; decide on if we are showing the cursor this time round 
0d91			 
0d91 3a 6b fb				ld a, (input_cur_onoff) 
0d94 fe ff				cp 255 
0d96 28 13				jr z, .skipcur 
0d98			 
0d98			 
0d98 3a 6e fb				ld a,(input_at_cursor) 
0d9b 11 d0 f8				ld de, cursor_shape 
0d9e cd e8 0a				call str_at_display 
0da1			 
0da1					; save length of current input string 
0da1 2a 73 fb				ld hl, (input_start) 
0da4 cd 67 11				call strlenz 
0da7 7d					ld a,l 
0da8 32 66 fb				ld (input_len),a 
0dab			 
0dab			.skipcur: 
0dab			 
0dab cd f8 0a			        call update_display 
0dae					 
0dae			 
0dae			 
0dae					; wait 
0dae				 
0dae					; TODO loop without wait to flash the cursor and char under cursor	 
0dae cd 4d 68				call cin    ; _wait 
0db1			 
0db1 fe 00				cp 0 
0db3 ca 67 0d				jp z, .is1 
0db6			 
0db6					; get ptr to char to input into 
0db6			 
0db6 4f					ld c,a 
0db7 2a 73 fb				ld hl, (input_start) 
0dba 3a 61 fb				ld a, (input_cursor) 
0dbd cd 09 0d				call addatohl 
0dc0 22 75 fb				ld (input_ptr), hl 
0dc3 79					ld a,c 
0dc4			 
0dc4					; replace char under cursor 
0dc4			 
0dc4			;		ld hl, (input_ptr) 
0dc4			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc4			;		ld (hl), a 
0dc4			 
0dc4			;	if DEBUG_INPUT 
0dc4			;		push af 
0dc4			;		ld a, 'i' 
0dc4			;		ld (debug_mark),a 
0dc4			;		pop af 
0dc4			;		CALLMONITOR 
0dc4			;	endif 
0dc4 fe 0e				cp KEY_HOME 
0dc6 20 0e				jr nz, .iske 
0dc8			 
0dc8 3a 70 fb				ld a, (input_at_pos) 
0dcb 32 6e fb				ld (input_at_cursor),a 
0dce 3e 00				ld a, 0 
0dd0 32 61 fb				ld (input_cursor), a 
0dd3 c3 67 0d				jp .is1 
0dd6					 
0dd6 fe 0f		.iske:		cp KEY_END 
0dd8 20 03				jr nz, .isknw 
0dda c3 67 0d				jp .is1 
0ddd			 
0ddd fe 06		.isknw:		cp KEY_NEXTWORD 
0ddf 20 1b				jr nz, .iskpw 
0de1			 
0de1 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0de4 7e					ld a,(hl)	 
0de5 fe 00				cp 0 
0de7 ca 67 0d				jp z, .is1    ; end of string 
0dea fe 20				cp ' ' 
0dec ca 67 0d				jp z, .is1    ; end of word 
0def 23					inc hl 
0df0 22 75 fb				ld (input_ptr), hl 
0df3 3a 6e fb				ld a, (input_at_cursor) 
0df6 3c					inc a 
0df7 32 6e fb				ld (input_at_cursor), a 
0dfa 18 e5				jr .isknwm 
0dfc			 
0dfc fe 07		.iskpw:		cp KEY_PREVWORD 
0dfe 20 1b				jr nz, .iskl 
0e00			.iskpwm:	 
0e00 2a 75 fb				ld hl, (input_ptr) 
0e03 7e					ld a,(hl)	 
0e04 fe 00				cp 0  
0e06 ca 67 0d				jp z, .is1    ; end of string 
0e09 fe 20				cp ' ' 
0e0b ca 67 0d				jp z, .is1    ; end of word 
0e0e 2b					dec hl 
0e0f 22 75 fb				ld (input_ptr), hl 
0e12 3a 6e fb				ld a, (input_at_cursor) 
0e15 3d					dec a 
0e16 32 6e fb				ld (input_at_cursor), a 
0e19 18 e5				jr .iskpwm 
0e1b			 
0e1b			 
0e1b fe 0b		.iskl:		cp KEY_LEFT 
0e1d 20 27				jr nz, .isk1 
0e1f			 
0e1f 3a 61 fb				ld a, (input_cursor) 
0e22			 
0e22 fe 00				cp 0 
0e24 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0e27			 
0e27 3d					dec  a 		; TODO check underflow 
0e28 32 61 fb				ld (input_cursor), a 
0e2b			 
0e2b 2a 75 fb				ld hl, (input_ptr) 
0e2e 2b					dec hl 
0e2f 22 75 fb				ld (input_ptr), hl 
0e32					 
0e32 3a 6e fb				ld a, (input_at_cursor) 
0e35 3d					dec a 
0e36 32 6e fb				ld (input_at_cursor), a 
0e39			 
0e39 3e 01				ld a, 1		; show cursor moving 
0e3b 32 6b fb				ld (input_cur_onoff),a 
0e3e 3e 0f				ld a, CUR_BLINK_RATE 
0e40 32 6c fb				ld (input_cur_flash), a 
0e43			 
0e43 c3 67 0d				jp .is1 
0e46			 
0e46 fe 0c		.isk1:		cp KEY_RIGHT 
0e48 20 2a				jr nz, .isk2 
0e4a			 
0e4a 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4d 5f					ld e,a 
0e4e 3a 61 fb				ld a, (input_cursor) 
0e51 bb					cp e 
0e52 ca 67 0d				jp z, .is1		; at the end of string so dont go right 
0e55			 
0e55 3c					inc  a 		; TODO check overflow 
0e56 32 61 fb				ld (input_cursor), a 
0e59			 
0e59 3a 6e fb				ld a, (input_at_cursor) 
0e5c 3c					inc a 
0e5d 32 6e fb				ld (input_at_cursor), a 
0e60			 
0e60 2a 75 fb				ld hl, (input_ptr) 
0e63 23					inc hl 
0e64 22 75 fb				ld (input_ptr), hl 
0e67			 
0e67 3e 01				ld a, 1		; show cursor moving 
0e69 32 6b fb				ld (input_cur_onoff),a 
0e6c 3e 0f				ld a, CUR_BLINK_RATE 
0e6e 32 6c fb				ld (input_cur_flash), a 
0e71			 
0e71 c3 67 0d				jp .is1 
0e74			 
0e74 fe 05		.isk2:		cp KEY_UP 
0e76			 
0e76 20 26				jr nz, .isk3 
0e78			 
0e78					; swap last command with the current on 
0e78			 
0e78					; move cursor to start of string 
0e78 2a 73 fb				ld hl, (input_start) 
0e7b 22 75 fb				ld (input_ptr), hl 
0e7e			 
0e7e 3a 70 fb				ld a, (input_at_pos) 
0e81 32 6e fb				ld (input_at_cursor), a 
0e84			 
0e84 3e 00				ld a, 0 
0e86 32 61 fb				ld (input_cursor), a 
0e89					 
0e89					; swap input and last command buffers 
0e89			 
0e89 21 44 f1				ld hl, os_cli_cmd 
0e8c 11 43 f2				ld de, os_last_cmd 
0e8f 06 ff				ld b, 255 
0e91 7e			.swap1:		ld a, (hl) 
0e92 4f					ld c,a 
0e93 1a					ld a, (de) 
0e94 77					ld (hl), a 
0e95 79					ld a,c 
0e96 12					ld (de),a 
0e97 23					inc hl 
0e98 13					inc de 
0e99 10 f6				djnz .swap1 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b c3 67 0d				jp .is1 
0e9e			 
0e9e fe 08		.isk3:		cp KEY_BS 
0ea0 20 3c				jr nz, .isk4 
0ea2			 
0ea2 3a 61 fb				ld a, (input_cursor) 
0ea5			 
0ea5 fe 00				cp 0 
0ea7 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0eaa			 
0eaa 3d					dec  a 		; TODO check underflow 
0eab 32 61 fb				ld (input_cursor), a 
0eae			 
0eae					; hl is source 
0eae					; de needs to be source - 1 
0eae			 
0eae			;		ld a, 0 
0eae			;		dec hl 
0eae			;		ld (hl), a 
0eae			 
0eae 2a 75 fb				ld hl, (input_ptr) 
0eb1 2b					dec hl 
0eb2 22 75 fb				ld (input_ptr), hl 
0eb5			 
0eb5					; shift all data 
0eb5			 
0eb5 e5					push hl 
0eb6 23					inc hl 
0eb7 d1					pop de 
0eb8 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ebb 4f					ld c,a 
0ebc 06 00				ld b,0 
0ebe ed b0				ldir  
0ec0			 
0ec0			 
0ec0			 
0ec0			 
0ec0 3a 6e fb				ld a, (input_at_cursor) 
0ec3 3d					dec a 
0ec4 32 6e fb				ld (input_at_cursor), a 
0ec7			 
0ec7			 
0ec7 3e 01				ld a, 1		; show cursor moving 
0ec9 32 6b fb				ld (input_cur_onoff),a 
0ecc 3e 0f				ld a, CUR_BLINK_RATE 
0ece 32 6c fb				ld (input_cur_flash), a 
0ed1			 
0ed1					; remove char 
0ed1 3a 6e fb				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 11 5f 0f				ld de,.iblank 
0ed8 cd e8 0a				call str_at_display 
0edb			 
0edb c3 67 0d				jp .is1 
0ede			 
0ede fe 0d		.isk4:		cp KEY_CR 
0ee0 28 6c				jr z, .endinput 
0ee2			 
0ee2					; else add the key press to the end 
0ee2			 
0ee2 4f					ld c, a			; save key pressed 
0ee3			 
0ee3 7e					ld a,(hl)		; get what is currently under char 
0ee4			 
0ee4 fe 00				cp 0			; we are at the end of the string 
0ee6 20 2f				jr nz, .onchar 
0ee8					 
0ee8					; add a char to the end of the string 
0ee8				 
0ee8 71					ld (hl),c 
0ee9 23					inc hl 
0eea			;		ld a,' ' 
0eea			;		ld (hl),a 
0eea			;		inc hl 
0eea 3e 00				ld a,0 
0eec 77					ld (hl),a 
0eed 2b					dec hl 
0eee			 
0eee 3a 61 fb				ld a, (input_cursor) 
0ef1 3c					inc a				; TODO check max string length and scroll  
0ef2 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0ef5							 
0ef5 3a 6e fb				ld a, (input_at_cursor) 
0ef8 3c					inc a 
0ef9 32 6e fb				ld (input_at_cursor), a 
0efc			 
0efc 2a 75 fb				ld hl, (input_ptr) 
0eff 23					inc hl 
0f00 22 75 fb				ld (input_ptr), hl 
0f03			 
0f03 2a 75 fb				ld hl, (input_ptr) 
0f06 23					inc hl 
0f07 22 75 fb				ld (input_ptr), hl 
0f0a			;	if DEBUG_INPUT 
0f0a			;		push af 
0f0a			;		ld a, '+' 
0f0a			;		ld (debug_mark),a 
0f0a			;		pop af 
0f0a			;		CALLMONITOR 
0f0a			;	endif 
0f0a 3e 01				ld a, 1		; show cursor moving 
0f0c 32 6b fb				ld (input_cur_onoff),a 
0f0f 3e 0f				ld a, CUR_BLINK_RATE 
0f11 32 6c fb				ld (input_cur_flash), a 
0f14 c3 67 0d				jp .is1 
0f17					 
0f17			 
0f17			 
0f17					; if on a char then insert 
0f17			.onchar: 
0f17			 
0f17					; TODO over flow check: make sure insert does not blow out buffer 
0f17			 
0f17					; need to do some maths to use lddr 
0f17			 
0f17 e5					push hl   ; save char pos 
0f18 c5					push bc 
0f19			 
0f19 2a 73 fb				ld hl, (input_start) 
0f1c 3a 66 fb				ld a, (input_len) 
0f1f cd 09 0d				call addatohl  		; end of string 
0f22 23					inc hl 
0f23 23					inc hl		; past zero term 
0f24 e5					push hl 
0f25 23					inc hl 
0f26 e5					push hl  
0f27			 
0f27								; start and end of lddr set, now how much to move? 
0f27			 
0f27							 
0f27 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f2a 47					ld b,a 
0f2b 3a 66 fb				ld a,(input_len) 
0f2e 5f					ld e,a 
0f2f 90					sub b 
0f30 3c					inc a		;?? 
0f31 3c					inc a		;?? 
0f32 3c					inc a		;?? 
0f33			 
0f33 06 00				ld b,0 
0f35 4f					ld c,a 
0f36			 
0f36				if DEBUG_INPUT 
0f36					push af 
0f36					ld a, 'i' 
0f36					ld (debug_mark),a 
0f36					pop af 
0f36			;		CALLMONITOR 
0f36				endif 
0f36 d1					pop de 
0f37 e1					pop hl 
0f38				if DEBUG_INPUT 
0f38					push af 
0f38					ld a, 'I' 
0f38					ld (debug_mark),a 
0f38					pop af 
0f38			;		CALLMONITOR 
0f38				endif 
0f38 ed b8				lddr 
0f3a				 
0f3a			 
0f3a			 
0f3a					; TODO have a key for insert/overwrite mode???? 
0f3a c1					pop bc 
0f3b e1					pop hl 
0f3c 71					ld (hl), c		; otherwise overwrite current char 
0f3d					 
0f3d			 
0f3d			 
0f3d			 
0f3d 3a 61 fb				ld a, (input_cursor) 
0f40 3c					inc  a 		; TODO check overflow 
0f41 32 61 fb				ld (input_cursor), a 
0f44			 
0f44 3a 6e fb				ld a, (input_at_cursor) 
0f47 3c					inc a 
0f48 32 6e fb				ld (input_at_cursor), a 
0f4b			 
0f4b c3 67 0d				jp .is1 
0f4e			 
0f4e			.endinput:	; TODO look for end of string 
0f4e			 
0f4e					; add trailing space for end of token 
0f4e			 
0f4e 2a 73 fb				ld hl, (input_start) 
0f51 3a 66 fb				ld a,(input_len) 
0f54 cd 09 0d				call addatohl 
0f57 3e 20				ld a, ' ' 
0f59 77					ld (hl),a 
0f5a					; TODO eof of parse marker 
0f5a			 
0f5a 23					inc hl 
0f5b 3e 00				ld a, 0 
0f5d 77					ld (hl),a 
0f5e			 
0f5e			 
0f5e c9					ret 
0f5f			 
0f5f .. 00		.iblank: db " ",0 
0f61			 
0f61			 
0f61 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0f64 22 73 fb				ld (input_start), hl 
0f67 3e 01				ld a,1			; add cursor 
0f69 77					ld (hl),a 
0f6a 23					inc hl 
0f6b 3e 00				ld a,0 
0f6d 77					ld (hl),a 
0f6e 22 75 fb				ld (input_ptr), hl 
0f71 7a					ld a,d 
0f72 32 72 fb				ld (input_size), a 
0f75 3e 00				ld a,0 
0f77 32 61 fb				ld (input_cursor),a 
0f7a			.instr1:	 
0f7a			 
0f7a					; TODO do block cursor 
0f7a					; TODO switch cursor depending on the modifer key 
0f7a			 
0f7a					; update cursor shape change on key hold 
0f7a			 
0f7a 2a 75 fb				ld hl, (input_ptr) 
0f7d 2b					dec hl 
0f7e 3a d0 f8				ld a,(cursor_shape) 
0f81 77					ld (hl), a 
0f82			 
0f82					; display entered text 
0f82 3a 70 fb				ld a,(input_at_pos) 
0f85 cd 11 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f88 ed 5b 73 fb	            	LD   de, (input_start) 
0f8c cd 33 66		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8f			 
0f8f cd 4d 68				call cin 
0f92 fe 00				cp 0 
0f94 28 e4				jr z, .instr1 
0f96			 
0f96					; proecess keyboard controls first 
0f96			 
0f96 2a 75 fb				ld hl,(input_ptr) 
0f99			 
0f99 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f9b 28 5a				jr z, .instrcr 
0f9d			 
0f9d fe 08				cp KEY_BS 	; back space 
0f9f 20 0f				jr nz, .instr2 
0fa1					; process back space 
0fa1			 
0fa1					; TODO stop back space if at start of string 
0fa1 2b					dec hl 
0fa2 2b					dec hl ; to over write cursor 
0fa3 3a d0 f8				ld a,(cursor_shape) 
0fa6					;ld a,0 
0fa6 77					ld (hl),a 
0fa7 23					inc hl 
0fa8 3e 20				ld a," " 
0faa 77					ld (hl),a 
0fab 22 75 fb				ld (input_ptr),hl 
0fae					 
0fae			 
0fae 18 ca				jr .instr1 
0fb0			 
0fb0 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fb2 20 06				jr nz, .instr3 
0fb4 2b					dec hl 
0fb5 22 75 fb				ld (input_ptr),hl 
0fb8 18 c0				jr .instr1 
0fba				 
0fba fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fbc 20 06				jr nz, .instr4 
0fbe 23					inc hl 
0fbf 22 75 fb				ld (input_ptr),hl 
0fc2 18 b6				jr .instr1 
0fc4			 
0fc4 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc6 20 06				jr nz, .instr5 
0fc8 2b					dec hl 
0fc9 22 75 fb				ld (input_ptr),hl 
0fcc 18 ac				jr .instr1 
0fce			 
0fce fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fd0 20 06				jr nz, .instr6 
0fd2 2b					dec hl 
0fd3 22 75 fb				ld (input_ptr),hl 
0fd6 18 a2				jr .instr1 
0fd8 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fda 20 0b				jr nz, .instrnew 
0fdc			 
0fdc 21 1d ee			ld hl, scratch 
0fdf 11 43 f2			ld de, os_last_cmd 
0fe2 cd 00 10			call strcpy 
0fe5 18 93				jr .instr1 
0fe7			 
0fe7			 
0fe7			.instrnew:	; no special key pressed to see if we have room to store it 
0fe7			 
0fe7					; TODO do string size test 
0fe7			 
0fe7 2b					dec hl ; to over write cursor 
0fe8 77					ld (hl),a 
0fe9 23					inc hl 
0fea 3a d0 f8				ld a,(cursor_shape) 
0fed 77					ld (hl),a 
0fee 23					inc hl 
0fef 3e 00				ld a,0 
0ff1 77					ld (hl),a 
0ff2			 
0ff2 22 75 fb				ld (input_ptr),hl 
0ff5					 
0ff5 18 83				jr .instr1 
0ff7 2b			.instrcr:	dec hl		; remove cursor 
0ff8 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ffa 77					ld (hl),a 
0ffb 23					inc hl 
0ffc 3e 00				ld a,0 
0ffe 77					ld (hl),a 
0fff			 
0fff			 
0fff					; if at end of line scroll up    
0fff					; TODO detecting only end of line 4 for scroll up  
0fff			 
0fff					;ld   
0fff			 
0fff c9					ret 
1000			 
1000			 
1000			; strcpy hl = dest, de source 
1000			 
1000 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1001 b7			            OR   A              ;Null terminator? 
1002 c8			            RET  Z              ;Yes, so finished 
1003 1a					ld a,(de) 
1004 77					ld (hl),a 
1005 13			            INC  DE             ;Point to next character 
1006 23					inc hl 
1007 18 f7		            JR   strcpy       ;Repeat 
1009 c9					ret 
100a			 
100a			 
100a			; TODO string_at  
100a			; pass string which starts with lcd offset address and then null term string 
100a			 
100a			; TODO string to dec 
100a			; TODO string to hex 
100a			; TODO byte to string hex 
100a			; TODO byte to string dec 
100a			 
100a			 
100a			 
100a			; from z80uartmonitor 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
100a			; pass hl for where to put the text 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a c5			hexout:	PUSH BC 
100b f5					PUSH AF 
100c 47					LD B, A 
100d					; Upper nybble 
100d cb 3f				SRL A 
100f cb 3f				SRL A 
1011 cb 3f				SRL A 
1013 cb 3f				SRL A 
1015 cd 25 10				CALL tohex 
1018 77					ld (hl),a 
1019 23					inc hl	 
101a					 
101a					; Lower nybble 
101a 78					LD A, B 
101b e6 0f				AND 0FH 
101d cd 25 10				CALL tohex 
1020 77					ld (hl),a 
1021 23					inc hl	 
1022					 
1022 f1					POP AF 
1023 c1					POP BC 
1024 c9					RET 
1025					 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			tohex: 
1025 e5					PUSH HL 
1026 d5					PUSH DE 
1027 16 00				LD D, 0 
1029 5f					LD E, A 
102a 21 32 10				LD HL, .DATA 
102d 19					ADD HL, DE 
102e 7e					LD A, (HL) 
102f d1					POP DE 
1030 e1					POP HL 
1031 c9					RET 
1032			 
1032			.DATA: 
1032 30					DEFB	30h	; 0 
1033 31					DEFB	31h	; 1 
1034 32					DEFB	32h	; 2 
1035 33					DEFB	33h	; 3 
1036 34					DEFB	34h	; 4 
1037 35					DEFB	35h	; 5 
1038 36					DEFB	36h	; 6 
1039 37					DEFB	37h	; 7 
103a 38					DEFB	38h	; 8 
103b 39					DEFB	39h	; 9 
103c 41					DEFB	41h	; A 
103d 42					DEFB	42h	; B 
103e 43					DEFB	43h	; C 
103f 44					DEFB	44h	; D 
1040 45					DEFB	45h	; E 
1041 46					DEFB	46h	; F 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1042			;;    subtract $30, if result > 9 then subtract $7 more 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			atohex: 
1042 d6 30				SUB $30 
1044 fe 0a				CP 10 
1046 f8					RET M		; If result negative it was 0-9 so we're done 
1047 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1049 c9					RET		 
104a			 
104a			 
104a			 
104a			 
104a			; Get 2 ASCII characters as hex byte from pointer in hl 
104a			 
104a			BYTERD: 
104a 16 00			LD	D,00h		;Set up 
104c cd 54 10			CALL	HEXCON		;Get byte and convert to hex 
104f 87				ADD	A,A		;First nibble so 
1050 87				ADD	A,A		;multiply by 16 
1051 87				ADD	A,A		; 
1052 87				ADD	A,A		; 
1053 57				LD	D,A		;Save hi nibble in D 
1054			HEXCON: 
1054 7e				ld a, (hl)		;Get next chr 
1055 23				inc hl 
1056 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1058 fe 0a			CP	00Ah		;Is it 0-9 ? 
105a 38 02			JR	C,NALPHA	;If so miss next bit 
105c d6 07			SUB	007h		;Else convert alpha 
105e			NALPHA: 
105e b2				OR	D		;Add hi nibble back 
105f c9				RET			; 
1060			 
1060			 
1060			; 
1060			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1060			; Since the routines get_byte and therefore get_nibble are called, only valid 
1060			; characters (0-9a-f) are accepted. 
1060			; 
1060			;get_word        push    af 
1060			;                call    get_byte        ; Get the upper byte 
1060			;                ld      h, a 
1060			;                call    get_byte        ; Get the lower byte 
1060			;                ld      l, a 
1060			;                pop     af 
1060			;                ret 
1060			; 
1060			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1060			; the routine get_nibble is used only valid characters are accepted - the  
1060			; input routine only accepts characters 0-9a-f. 
1060			; 
1060 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1061 7e					ld a,(hl) 
1062 23					inc hl 
1063 cd 88 10		                call    nibble2val      ; Get upper nibble 
1066 cb 07		                rlc     a 
1068 cb 07		                rlc     a 
106a cb 07		                rlc     a 
106c cb 07		                rlc     a 
106e 47			                ld      b, a            ; Save upper four bits 
106f 7e					ld a,(hl) 
1070 cd 88 10		                call    nibble2val      ; Get lower nibble 
1073 b0			                or      b               ; Combine both nibbles 
1074 c1			                pop     bc              ; Restore B (and C) 
1075 c9			                ret 
1076			; 
1076			; Get a hexadecimal digit from the serial line. This routine blocks until 
1076			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1076			; to the serial line interface. The lower 4 bits of A contain the value of  
1076			; that particular digit. 
1076			; 
1076			;get_nibble      ld a,(hl)           ; Read a character 
1076			;                call    to_upper        ; Convert to upper case 
1076			;                call    is_hex          ; Was it a hex digit? 
1076			;                jr      nc, get_nibble  ; No, get another character 
1076			 ;               call    nibble2val      ; Convert nibble to value 
1076			 ;               call    print_nibble 
1076			 ;               ret 
1076			; 
1076			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1076			; A valid hexadecimal digit is denoted by a set C flag. 
1076			; 
1076			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1076			;                ret     nc              ; Yes 
1076			;                cp      '0'             ; Less than '0'? 
1076			;                jr      nc, is_hex_1    ; No, continue 
1076			;                ccf                     ; Complement carry (i.e. clear it) 
1076			;                ret 
1076			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1076			;                ret     c               ; Yes 
1076			;                cp      'A'             ; Less than 'A'? 
1076			;                jr      nc, is_hex_2    ; No, continue 
1076			;                ccf                     ; Yes - clear carry and return 
1076			;                ret 
1076			;is_hex_2        scf                     ; Set carry 
1076			;                ret 
1076			; 
1076			; Convert a single character contained in A to upper case: 
1076			; 
1076 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1078 d8			                ret     c 
1079 fe 7b		                cp      'z' + 1         ; > 'z'? 
107b d0			                ret     nc              ; Nothing to do, either 
107c e6 5f		                and     $5f             ; Convert to upper case 
107e c9			                ret 
107f			 
107f			 
107f			to_lower: 
107f			 
107f			   ; if char is in [A-Z] make it lower case 
107f			 
107f			   ; enter : a = char 
107f			   ; exit  : a = lower case char 
107f			   ; uses  : af 
107f			 
107f fe 41		   cp 'A' 
1081 d8			   ret c 
1082			    
1082 fe 5b		   cp 'Z'+1 
1084 d0			   ret nc 
1085			    
1085 f6 20		   or $20 
1087 c9			   ret 
1088			 
1088			; 
1088			; Expects a hexadecimal digit (upper case!) in A and returns the 
1088			; corresponding value in A. 
1088			; 
1088 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
108a 38 02		                jr      c, nibble2val_1 ; Yes 
108c d6 07		                sub     7               ; Adjust for A-F 
108e d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1090 e6 0f		                and     $f              ; Only return lower 4 bits 
1092 c9			                ret 
1093			; 
1093			; Print_nibble prints a single hex nibble which is contained in the lower  
1093			; four bits of A: 
1093			; 
1093			;print_nibble    push    af              ; We won't destroy the contents of A 
1093			;                and     $f              ; Just in case... 
1093			;                add     a, '0'             ; If we have a digit we are done here. 
1093			;                cp      '9' + 1         ; Is the result > 9? 
1093			;                jr      c, print_nibble_1 
1093			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1093			;print_nibble_1  call    putc            ; Print the nibble and 
1093			;                pop     af              ; restore the original value of A 
1093			;                ret 
1093			;; 
1093			;; Send a CR/LF pair: 
1093			; 
1093			;crlf            push    af 
1093			;                ld      a, cr 
1093			;                call    putc 
1093			;                ld      a, lf 
1093			;                call    putc 
1093			;                pop     af 
1093			;                ret 
1093			; 
1093			; Print_word prints the four hex digits of a word to the serial line. The  
1093			; word is expected to be in HL. 
1093			; 
1093			;print_word      push    hl 
1093			;                push    af 
1093			;                ld      a, h 
1093			;                call    print_byte 
1093			;                ld      a, l 
1093			;                call    print_byte 
1093			;                pop     af 
1093			;                pop     hl 
1093			;                ret 
1093			; 
1093			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1093			; The byte to be printed is expected to be in A. 
1093			; 
1093			;print_byte      push    af              ; Save the contents of the registers 
1093			;                push    bc 
1093			;                ld      b, a 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                call    print_nibble    ; Print high nibble 
1093			;                ld      a, b 
1093			;                call    print_nibble    ; Print low nibble 
1093			;                pop     bc              ; Restore original register contents 
1093			;                pop     af 
1093			;                ret 
1093			 
1093			 
1093			 
1093			 
1093			 
1093			fourehexhl:  
1093 7e				ld a,(hl) 
1094 cd 42 10			call atohex 
1097 cb 3f				SRL A 
1099 cb 3f				SRL A 
109b cb 3f				SRL A 
109d cb 3f				SRL A 
109f 47				ld b, a 
10a0 23				inc hl 
10a1 7e				ld a,(hl) 
10a2 23				inc hl 
10a3 cd 42 10			call atohex 
10a6 80				add b 
10a7 57				ld d,a 
10a8 7e				ld a,(hl) 
10a9 cd 42 10			call atohex 
10ac cb 3f				SRL A 
10ae cb 3f				SRL A 
10b0 cb 3f				SRL A 
10b2 cb 3f				SRL A 
10b4 47				ld b, a 
10b5 23				inc hl 
10b6 7e				ld a,(hl) 
10b7 23				inc hl 
10b8 cd 42 10			call atohex 
10bb 80				add b 
10bc 5f				ld e, a 
10bd d5				push de 
10be e1				pop hl 
10bf c9				ret 
10c0			 
10c0			; pass hl. returns z set if the byte at hl is a digit 
10c0			;isdigithl:  
10c0			;	push bc 
10c0			;	ld a,(hl) 
10c0			;	cp ':' 
10c0			;	jr nc, .isdf 		; > 
10c0			;	cp '0' 
10c0			;	jr c, .isdf		; < 
10c0			; 
10c0			;	; TODO find a better way to set z 
10c0			; 
10c0			;	ld b,a 
10c0			;	cp b 
10c0			;	pop bc 
10c0			;	ret 
10c0			; 
10c0			;.isdf:	; not digit so clear z 
10c0			; 
10c0			;	; TODO find a better way to unset z 
10c0			; 
10c0			;	ld b,a 
10c0			;	inc b 
10c0			;	cp b 
10c0			; 
10c0			;	pop bc 
10c0			;	ret 
10c0				 
10c0				 
10c0			 
10c0			 
10c0			; pass hl as the four byte address to load 
10c0			 
10c0			get_word_hl:  
10c0 e5				push hl 
10c1 cd 60 10			call get_byte 
10c4				 
10c4 47				ld b, a 
10c5			 
10c5 e1				pop hl 
10c6 23				inc hl 
10c7 23				inc hl 
10c8			 
10c8			; TODO not able to handle a-f  
10c8 7e				ld a,(hl) 
10c9			;	;cp ':' 
10c9			;	cp 'g' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp 'G' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp '0' 
10c9			;	jr c, .single_byte_hl		; < 
10c9			 
10c9				;call isdigithl 
10c9 fe 00			cp 0 
10cb 28 06			jr z, .single_byte_hl 
10cd			 
10cd			.getwhln:   ; hex word so get next byte 
10cd			 
10cd cd 60 10			call get_byte 
10d0 6f				ld l, a 
10d1 60				ld h,b 
10d2 c9				ret 
10d3 68			.single_byte_hl:   ld l,b 
10d4 26 00				ld h,0 
10d6 c9					ret 
10d7			 
10d7			 
10d7			 
10d7			 
10d7 21 36 19			ld hl,asc+1 
10da			;	ld a, (hl) 
10da			;	call nibble2val 
10da cd 60 10			call get_byte 
10dd			 
10dd			;	call fourehexhl 
10dd 32 51 ee			ld (scratch+52),a 
10e0				 
10e0 21 4f ee			ld hl,scratch+50 
10e3 22 40 f1			ld (os_cur_ptr),hl 
10e6			 
10e6 c9				ret 
10e7			 
10e7			 
10e7			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e7			 
10e7			; Decimal Unsigned Version 
10e7			 
10e7			;Number in a to decimal ASCII 
10e7			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e7			;Example: display a=56 as "056" 
10e7			;input: a = number 
10e7			;Output: a=0,value of a in the screen 
10e7			;destroys af,bc (don't know about hl and de) 
10e7			DispAToASCII: 
10e7 0e 9c			ld	c,-100 
10e9 cd f3 10			call	.Na1 
10ec 0e f6			ld	c,-10 
10ee cd f3 10			call	.Na1 
10f1 0e ff			ld	c,-1 
10f3 06 2f		.Na1:	ld	b,'0'-1 
10f5 04			.Na2:	inc	b 
10f6 81				add	a,c 
10f7 38 fc			jr	c,.Na2 
10f9 91				sub	c		;works as add 100/10/1 
10fa f5				push af		;safer than ld c,a 
10fb 78				ld	a,b		;char is in b 
10fc			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10fc f1				pop af		;safer than ld a,c 
10fd c9				ret 
10fe			 
10fe			; Decimal Signed Version 
10fe			 
10fe			; DispA 
10fe			; -------------------------------------------------------------- 
10fe			; Converts a signed integer value to a zero-terminated ASCII 
10fe			; string representative of that value (using radix 10). 
10fe			; -------------------------------------------------------------- 
10fe			; INPUTS: 
10fe			;     HL     Value to convert (two's complement integer). 
10fe			;     DE     Base address of string destination. (pointer). 
10fe			; -------------------------------------------------------------- 
10fe			; OUTPUTS: 
10fe			;     None 
10fe			; -------------------------------------------------------------- 
10fe			; REGISTERS/MEMORY DESTROYED 
10fe			; AF HL 
10fe			; -------------------------------------------------------------- 
10fe			 
10fe			;DispHLToASCII: 
10fe			;   push    de 
10fe			;   push    bc 
10fe			; 
10fe			;; Detect sign of HL. 
10fe			;    bit    7, h 
10fe			;    jr     z, ._DoConvert 
10fe			; 
10fe			;; HL is negative. Output '-' to string and negate HL. 
10fe			;    ld     a, '-' 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			; 
10fe			;; Negate HL (using two's complement) 
10fe			;    xor    a 
10fe			;    sub    l 
10fe			;    ld     l, a 
10fe			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fe			;    sbc    a, h 
10fe			;    ld     h, a 
10fe			; 
10fe			;; Convert HL to digit characters 
10fe			;._DoConvert: 
10fe			;    ld     b, 0     ; B will count character length of number 
10fe			;-   ld     a, 10 
10fe			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fe			;    push   af 
10fe			;    inc    b 
10fe			;    ld     a, h 
10fe			;    or     l 
10fe			;    jr     nz, - 
10fe			; 
10fe			;; Retrieve digits from stack 
10fe			;-   pop    af 
10fe			;    or     $30 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			;    djnz   - 
10fe			; 
10fe			;; Terminate string with NULL 
10fe			;    xor    a 
10fe			;    ld     (de), a 
10fe			; 
10fe			;    pop    bc 
10fe			;    pop    de 
10fe			;    ret 
10fe			 
10fe			;Comments 
10fe			; 
10fe			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fe			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fe			;    Note that the output string will not be fixed-width. 
10fe			; 
10fe			;Example Usage 
10fe			; 
10fe			;    ld    hl, -1004 
10fe			;    ld    de, OP1 
10fe			;    call  DispA 
10fe			;    ld    hl, OP1 
10fe			;    syscall  PutS 
10fe			 
10fe			 
10fe			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fe			 
10fe			 
10fe			;Converts an ASCII string to an unsigned 16-bit integer 
10fe			;Quits when it reaches a non-decimal digit 
10fe			 
10fe			string_to_uint16: 
10fe			atoui_16: 
10fe			;Input: 
10fe			;     DE points to the string 
10fe			;Outputs: 
10fe			;     HL is the result 
10fe			;     A is the 8-bit value of the number 
10fe			;     DE points to the byte after the number 
10fe			;Destroys: 
10fe			;     BC 
10fe			;       if the string is non-empty, BC is HL/10 
10fe			;Size:  24 bytes 
10fe			;Speed: 42+d(104+{0,9}) 
10fe			;       d is the number of digits in the number 
10fe			;       max is 640 cycles for a 5 digit number 
10fe			;Assuming no leading zeros: 
10fe			;1 digit:  146cc 
10fe			;2 digit:  250cc 
10fe			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fe			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fe			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fe			;avg: 544.81158447265625cc (544+13297/16384) 
10fe			;=============================================================== 
10fe 21 00 00		  ld hl,0 
1101			.u16a: 
1101 1a			  ld a,(de) 
1102 d6 30		  sub 30h 
1104 fe 0a		  cp 10 
1106 d0			  ret nc 
1107 13			  inc de 
1108 44			  ld b,h 
1109 4d			  ld c,l 
110a 29			  add hl,hl 
110b 29			  add hl,hl 
110c 09			  add hl,bc 
110d 29			  add hl,hl 
110e 85			  add a,l 
110f 6f			  ld l,a 
1110 30 ef		  jr nc,.u16a 
1112 24			  inc h 
1113 c3 01 11		  jp .u16a 
1116			 
1116			 
1116			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1116			 
1116			;written by Zeda 
1116			;Converts a 16-bit unsigned integer to an ASCII string. 
1116			 
1116			uitoa_16: 
1116			;Input: 
1116			;   DE is the number to convert 
1116			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1116			;Output: 
1116			;   HL points to the null-terminated ASCII string 
1116			;      NOTE: This isn't necessarily the same as the input HL. 
1116 d5			  push de 
1117 c5			  push bc 
1118 f5			  push af 
1119 eb			  ex de,hl 
111a			 
111a 01 f0 d8		  ld bc,-10000 
111d 3e 2f		  ld a,'0'-1 
111f 3c			  inc a 
1120 09			  add hl,bc  
1121 38 fc		   jr c,$-2 
1123 12			  ld (de),a 
1124 13			  inc de 
1125			 
1125 01 e8 03		  ld bc,1000 
1128 3e 3a		  ld a,'9'+1 
112a 3d			  dec a  
112b 09			  add hl,bc  
112c 30 fc		   jr nc,$-2 
112e 12			  ld (de),a 
112f 13			  inc de 
1130			 
1130 01 9c ff		  ld bc,-100 
1133 3e 2f		  ld a,'0'-1 
1135 3c			  inc a  
1136 09			  add hl,bc  
1137 38 fc		   jr c,$-2 
1139 12			  ld (de),a 
113a 13			  inc de 
113b			 
113b 7d			  ld a,l 
113c 26 3a		  ld h,'9'+1 
113e 25			  dec h  
113f c6 0a		  add a,10  
1141 30 fb		   jr nc,$-3 
1143 c6 30		  add a,'0' 
1145 eb			  ex de,hl 
1146 72			  ld (hl),d 
1147 23			  inc hl 
1148 77			  ld (hl),a 
1149 23			  inc hl 
114a 36 00		  ld (hl),0 
114c			 
114c			;Now strip the leading zeros 
114c 0e fa		  ld c,-6 
114e 09			  add hl,bc 
114f 3e 30		  ld a,'0' 
1151 23			  inc hl  
1152 be			  cp (hl)  
1153 28 fc		  jr z,$-2 
1155			 
1155			;Make sure that the string is non-empty! 
1155 7e			  ld a,(hl) 
1156 b7			  or a 
1157 20 01		  jr nz,.atoub 
1159 2b			  dec hl 
115a			.atoub: 
115a			 
115a f1			  pop af 
115b c1			  pop bc 
115c d1			  pop de 
115d c9			  ret 
115e			 
115e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115e			 
115e			toUpper: 
115e			;A is the char. 
115e			;If A is a lowercase letter, this sets it to the matching uppercase 
115e			;18cc or 30cc or 41cc 
115e			;avg: 26.75cc 
115e fe 61		  cp 'a' 
1160 d8			  ret c 
1161 fe 7b		  cp 'z'+1 
1163 d0			  ret nc 
1164 d6 20		  sub 'a'-'A' 
1166 c9			  ret 
1167			 
1167			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1167			 
1167			; String Length 
1167			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1167			 
1167			; Get the length of the null-terminated string starting at $8000 hl 
1167			;    LD     HL, $8000 
1167			 
1167			strlenz: 
1167			 
1167 af			    XOR    A               ; Zero is the value we are looking for. 
1168 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1169 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
116a			                           ; 65, 536 bytes (the entire addressable memory space). 
116a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116c			 
116c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116c 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116d 6f			    LD     L, A             ; number of bytes 
116e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1170 2b			    DEC    HL              ; Compensate for null. 
1171 c9				ret 
1172			 
1172			; Get the length of the A terminated string starting at $8000 hl 
1172			;    LD     HL, $8000 
1172			 
1172			strlent: 
1172			 
1172			                  ; A is the value we are looking for. 
1172 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1174 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1176			                           ; 65, 536 bytes (the entire addressable memory space). 
1176 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1178			 
1178			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1178 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
117a 2e 00		    LD     L, 0             ; number of bytes 
117c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117e 2b			    DEC    HL              ; Compensate for null. 
117f c9				ret 
1180			 
1180			 
1180			;Comparing Strings 
1180			 
1180			;IN    HL     Address of string1. 
1180			;      DE     Address of string2. 
1180			 
1180			; doc given but wrong??? 
1180			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1180			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1180			; tested 
1180			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1180			 
1180			strcmp_old: 
1180 e5			    PUSH   HL 
1181 d5			    PUSH   DE 
1182			 
1182 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1183 be			    CP     (HL)            ; (want to minimize work). 
1184 38 01		    JR     C, Str1IsBigger 
1186 7e			    LD     A, (HL) 
1187			 
1187			Str1IsBigger: 
1187 4f			    LD     C, A             ; Put length in BC 
1188 06 00		    LD     B, 0 
118a 13			    INC    DE              ; Increment pointers to meat of string. 
118b 23			    INC    HL 
118c			 
118c			CmpLoop: 
118c 1a			    LD     A, (DE)          ; Compare bytes. 
118d ed a1		    CPI 
118f 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1191 13			    INC    DE              ; Update pointer. 
1192 ea 8c 11		    JP     PE, CmpLoop 
1195			 
1195 d1			    POP    DE 
1196 e1			    POP    HL 
1197 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1198 be			    CP     (HL) 
1199 c9			    RET 
119a			 
119a			NoMatch: 
119a 2b			    DEC    HL 
119b be			    CP     (HL)            ; Compare again to affect carry. 
119c d1			    POP    DE 
119d e1			    POP    HL 
119e c9			    RET 
119f			 
119f			;; test strmp 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr z, .z1 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z1: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr z, .z2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr c, .c1 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c1: 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr c, .c2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;	NEXTW 
119f			;.str1:   db "string1",0 
119f			;.str2:   db "string2",0 
119f			 
119f			; only care about direct match or not 
119f			; hl and de strings 
119f			; zero set if the same 
119f			 
119f			strcmp: 
119f 1a				ld a, (de) 
11a0 be				cp (hl) 
11a1 28 02			jr z, .ssame 
11a3 b7				or a 
11a4 c9				ret 
11a5			 
11a5			.ssame:  
11a5 fe 00			cp 0 
11a7 c8				ret z 
11a8			 
11a8 23				inc hl 
11a9 13				inc de 
11aa 18 f3			jr strcmp 
11ac				 
11ac				 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			; eof 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
# End of file firmware_strings.asm
11ac			include "firmware_memory.asm"   ; malloc and free  
11ac			 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			.mallocsize: db "Wants malloc >256",0 
11ac			.mallocasize: db "MALLOC gives >256",0 
11ac			.malloczero: db "MALLOC gives zero",0 
11ac			 
11ac			malloc_guard_zerolen: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac				ld de, 0 
11ac			        call cmp16 
11ac				jr nz, .lowalloz 
11ac			 
11ac				push hl 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .malloczero 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac			.lowalloz: 
11ac			 
11ac			 
11ac				pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_entry: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowalloc 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocsize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdone 
11ac			.lowalloc: 
11ac			 
11ac			 
11ac				pop hl 
11ac			.lowdone:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_exit: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowallocx 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocasize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdonex 
11ac			.lowallocx: 
11ac			 
11ac				pop hl 
11ac			.lowdonex:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			endif 
11ac			 
11ac			if MALLOC_2 
11ac			; Z80 Malloc and Free Functions 
11ac			 
11ac			; Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc: 
11ac				 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_entry 
11ac			endif 
11ac			 
11ac			 
11ac			 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "mal" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of size into A 
11ac			    or h               ; Check if size is zero 
11ac			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ac			 
11ac			    ; Allocate memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma1" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    call malloc_internal ; Call internal malloc function 
11ac			    pop af             ; Restore AF register 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret                ; Return 
11ac			 
11ac			; Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free: 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of pointer into A 
11ac			    or h               ; Check if pointer is NULL 
11ac			    jp z, free_exit    ; If pointer is NULL, exit 
11ac			 
11ac			    ; Free memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac			    call free_internal  ; Call internal free function 
11ac			    pop af             ; Restore AF register 
11ac			    ret                ; Return 
11ac			 
11ac			; Internal Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc_internal: 
11ac			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to requested size 
11ac			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			 
11ac			    ; Search for free memory block 
11ac			    ld de, (heap_end)  ; Load end of heap into DE 
11ac			    ld bc, 0           ; Initialize counter 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			malloc_search_loop: 
11ac			    ; Check if current block is free 
11ac			    ld a, (hl)         ; Load current block's status (free or used) 
11ac			    cp 0               ; Compare with zero (free) 
11ac			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ac			 
11ac			    ; Check if current block is large enough 
11ac			    ld a, (hl+1)       ; Load high byte of block size 
11ac			    cp l               ; Compare with low byte of requested size 
11ac			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ac			 
11ac			    ld a, (hl+2)       ; Load low byte of block size 
11ac			    cp h               ; Compare with high byte of requested size 
11ac			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ac			 
11ac			    ; Mark block as used 
11ac			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ac			 
11ac			    ; Calculate remaining space in block 
11ac			    ld bc, 0           ; Clear BC 
11ac			    add hl, bc         ; Increment HL to point to start of data block 
11ac			    add hl, de         ; HL = HL + DE (total size) 
11ac			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to start of data block 
11ac			 
11ac			    ; Save pointer to allocated block in HL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma5" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			malloc_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3           ; Size of management overhead 
11ac			    add hl, bc         ; Move to the next block 
11ac			    inc de             ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e            ; Load low byte of heap end address 
11ac			    cp (hl)            ; Compare with low byte of current address 
11ac			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ac			    ld a, d            ; Load high byte of heap end address 
11ac			    cp 0               ; Check if it's zero (end of memory) 
11ac			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, allocation failed 
11ac			    xor a              ; Set result to NULL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma6" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			malloc_exit: 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma7" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			; Internal Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free_internal: 
11ac			    ld de, (heap_start) ; Load start of heap into DE 
11ac			    ld bc, 0            ; Initialize counter 
11ac			 
11ac			free_search_loop: 
11ac			    ; Check if current block contains the pointer 
11ac			    ld a, l             ; Load low byte of pointer 
11ac			    cp (hl+1)           ; Compare with high byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			    ld a, h             ; Load high byte of pointer 
11ac			    cp (hl+2)           ; Compare with low byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			 
11ac			    ; Mark block as free 
11ac			    ld (hl), 0          ; Set status byte to indicate free block 
11ac			    ret                 ; Return 
11ac			 
11ac			free_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3            ; Size of management overhead 
11ac			    add hl, bc          ; Move to the next block 
11ac			    inc de              ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e             ; Load low byte of heap end address 
11ac			    cp (hl)             ; Compare with low byte of current address 
11ac			    jr nz, free_search_loop  ; If not equal, continue searching 
11ac			    ld a, d             ; Load high byte of heap end address 
11ac			    cp 0                ; Check if it's zero (end of memory) 
11ac			    jr nz, free_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, pointer is not found in heap 
11ac			    ret 
11ac			 
11ac			free_exit: 
11ac			    ret                 ; Return 
11ac			 
11ac			; Define heap start and end addresses 
11ac			;heap_start:    .dw 0xC000   ; Start of heap 
11ac			;heap_end:      .dw 0xE000   ; End of heap 
11ac			 
11ac			endif 
11ac			 
11ac			 
11ac			if MALLOC_1 
11ac			 
11ac			 
11ac			 
11ac			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ac			 
11ac			;moved to firmware.asm 
11ac			;heap_start        .equ  0x9000      ; Starting address of heap 
11ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ac			 
11ac			;      .org 0 
11ac			;      jp    main 
11ac			 
11ac			 
11ac			;      .org  0x100 
11ac			;main: 
11ac			;      ld    HL, 0x8100 
11ac			;      ld    SP, HL 
11ac			; 
11ac			;      call  heap_init 
11ac			; 
11ac			;      ; Make some allocations 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9004 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9014 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9024 
11ac			; 
11ac			;      ; Free some allocations 
11ac			;      ld    HL, 0x9014 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9004 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9024 
11ac			;      call  free 
11ac			; 
11ac			; 
11ac			;      halt 
11ac			 
11ac			 
11ac			;------------------------------------------------------------------------------ 
11ac			;     heap_init                                                               : 
11ac			;                                                                             : 
11ac			; Description                                                                 : 
11ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ac			;                                                                             : 
11ac			;     The heap is maintained as a linked list, starting with an initial       : 
11ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ac			;     the first free block in the heap. Each block then points to the next    : 
11ac			;     free block within the heap, and the free list ends at the first block   : 
11ac			;     with a null pointer to the next free block.                             : 
11ac			;                                                                             : 
11ac			; Parameters                                                                  : 
11ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ac			;     address of the heap and its size are required, along with a memory      : 
11ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ac			;     principally stores a pointer to the first free block in the heap.       : 
11ac			;                                                                             : 
11ac			; Returns                                                                     : 
11ac			;     Nothing                                                                 : 
11ac			;------------------------------------------------------------------------------ 
11ac			heap_init: 
11ac e5			      push  HL 
11ad			 
11ad			      ; Initialise free list struct 
11ad 21 0e 80		      ld    HL, heap_start 
11b0 22 0a 80		      ld    (free_list), HL 
11b3 21 00 00		      ld    HL, 0 
11b6 22 0c 80		      ld    (free_list+2), HL 
11b9			 
11b9			      ; Insert first free block at bottom of heap, consumes entire heap 
11b9 21 ff ed		      ld    HL, heap_start+heap_size-4 
11bc 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bf 21 f1 6d		      ld    HL, heap_size-4 
11c2 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c5			 
11c5			      ; Insert end of free list block at top of heap - two null words will 
11c5			      ; terminate the free list 
11c5 21 00 00		      ld    HL, 0 
11c8 22 01 ee		      ld    (heap_start+heap_size-2), HL 
11cb 22 ff ed		      ld    (heap_start+heap_size-4), HL 
11ce			 
11ce e1			      pop   HL 
11cf			 
11cf c9			      ret 
11d0			 
11d0			 
11d0			;------------------------------------------------------------------------------ 
11d0			;     malloc                                                                  : 
11d0			;                                                                             : 
11d0			; Description                                                                 : 
11d0			;     Allocates the wanted space from the heap and returns the address of the : 
11d0			;     first useable byte of the allocation.                                   : 
11d0			;                                                                             : 
11d0			;     Allocations can happen in one of two ways:                              : 
11d0			;                                                                             : 
11d0			;     1. A free block may be found which is the exact size wanted. In this    : 
11d0			;        case the block is removed from the free list and retuedn to the      : 
11d0			;        caller.                                                              : 
11d0			;     2. A free block may be found which is larger than the size wanted. In   : 
11d0			;        this case, the larger block is split into two. The first portion of  : 
11d0			;        this block will become the requested space by the malloc call and    : 
11d0			;        is returned to the caller. The second portion becomes a new free     : 
11d0			;        block, and the free list is adjusted to maintain continuity via this : 
11d0			;        newly created block.                                                 : 
11d0			;                                                                             : 
11d0			;     malloc does not set any initial value in the allocated space, the       : 
11d0			;     caller is required to do this as required.                              : 
11d0			;                                                                             : 
11d0			;     This implementation of malloc uses the stack exclusively, and is        : 
11d0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d0			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d0			;     to avoid the use of malloc inside ISRs in general.                      : 
11d0			;                                                                             : 
11d0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d0			;                                                                             : 
11d0			; Parameters                                                                  : 
11d0			;     HL  Number of bytes wanted                                              : 
11d0			;                                                                             : 
11d0			; Returns                                                                     : 
11d0			;     HL  Address of the first useable byte of the allocation                 : 
11d0			;                                                                             : 
11d0			; Flags                                                                       : 
11d0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d0			;                                                                             : 
11d0			; Stack frame                                                                 : 
11d0			;       |             |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     BC      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     DE      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     IX      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |  prev_free  |                                                       : 
11d0			;   +4  +-------------+                                                       : 
11d0			;       |  this_free  |                                                       : 
11d0			;   +2  +-------------+                                                       : 
11d0			;       |  next_free  |                                                       : 
11d0			;   +0  +-------------+                                                       : 
11d0			;       |             |                                                       : 
11d0			;                                                                             : 
11d0			;------------------------------------------------------------------------------ 
11d0			 
11d0			 
11d0			;malloc: 
11d0			; 
11d0			;	SAVESP ON 1 
11d0			; 
11d0			;	call malloc_code 
11d0			; 
11d0			;	CHECKSP ON 1 
11d0			;	ret 
11d0			 
11d0			 
11d0			malloc: 
11d0 c5			      push  BC 
11d1 d5			      push  DE 
11d2 dd e5		      push  IX 
11d4			if DEBUG_FORTH_MALLOC_HIGH 
11d4			call malloc_guard_entry 
11d4			endif 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "mal" 
11d4						CALLMONITOR 
11d4					endif 
11d4 7c			      ld    A, H                    ; Exit if no space requested 
11d5 b5			      or    L 
11d6 ca 95 12		      jp    Z, malloc_early_exit 
11d9			 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			; 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			 
11d9			 
11d9			 
11d9			 
11d9					if DEBUG_FORTH_MALLOC 
11d9						DMARK "maA" 
11d9						CALLMONITOR 
11d9					endif 
11d9			      ; Set up stack frame 
11d9 eb			      ex    DE, HL 
11da 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11dd 39			      add   HL, SP 
11de f9			      ld    SP, HL 
11df dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e3 dd 39		      add   IX, SP 
11e5			 
11e5			      ; Setup initial state 
11e5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e8 19			      add   HL, DE 
11e9			 
11e9 44			      ld    B, H                    ; Move want to BC 
11ea 4d			      ld    C, L 
11eb			 
11eb 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ee dd 75 04		      ld    (IX+4), L 
11f1 dd 74 05		      ld    (IX+5), H 
11f4			 
11f4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 dd 73 02		      ld    (IX+2), E 
11fa dd 72 03		      ld    (IX+3), D 
11fd eb			      ex    DE, HL                  ; this_free ptr into HL 
11fe			 
11fe					if DEBUG_FORTH_MALLOC 
11fe						DMARK "maB" 
11fe						CALLMONITOR 
11fe					endif 
11fe			      ; Loop through free block list to find some space 
11fe			malloc_find_space: 
11fe 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1202 b3			      or    E 
1203 ca 8f 12		      jp    Z, malloc_no_space 
1206			 
1206 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1209 dd 72 01		      ld    (IX+1), D 
120c			 
120c			      ; Does this block have enough space to make the allocation? 
120c 23			      inc   HL                      ; Load free block size into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 eb			      ex    DE, HL                  ; Check size of block against want 
1211 b7			      or    A                       ; Ensure carry flag clear 
1212 ed 42		      sbc   HL, BC 
1214 e5			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215 ca 64 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1218 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121a			 
121a			      ; this_free block is not big enough, setup ptrs to test next free block 
121a e1			      pop   HL                      ; Discard previous result 
121b			 
121b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121e dd 66 03		      ld    H, (IX+3) 
1221 dd 75 04		      ld    (IX+4), L 
1224 dd 74 05		      ld    (IX+5), H 
1227			 
1227 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122a dd 66 01		      ld    H, (IX+1) 
122d dd 75 02		      ld    (IX+2), L 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MA>" 
1233						CALLMONITOR 
1233					endif 
1233 18 c9		      jr    malloc_find_space 
1235			 
1235			      ; split a bigger block into two - requested size and remaining size 
1235			malloc_alloc_split: 
1235					if DEBUG_FORTH_MALLOC 
1235						DMARK "MAs" 
1235						CALLMONITOR 
1235					endif 
1235 eb			      ex    DE, HL                  ; Calculate address of new free block 
1236 2b			      dec   HL 
1237 2b			      dec   HL 
1238 2b			      dec   HL 
1239 09			      add   HL, BC 
123a			 
123a			      ; Create a new block and point it at next_free 
123a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123d dd 56 01		      ld    D, (IX+1) 
1240			 
1240 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243 d1			      pop   DE                      ; Store size of new block into new block 
1244 23			      inc   HL 
1245 73			      ld    (HL), E 
1246 23			      inc   HL 
1247 72			      ld    (HL), D 
1248			 
1248			      ; Update this_free ptr to point to new block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124e dd 56 03		      ld    D, (IX+3) 
1251			 
1251 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1254 dd 74 03		      ld    (IX+3), H 
1257			 
1257			      ; Modify this_free block to be allocation 
1257 eb			      ex    DE, HL 
1258 af			      xor   A                       ; Null the next block ptr of allocated block 
1259 77			      ld    (HL), A 
125a 23			      inc   HL 
125b 77			      ld    (HL), A 
125c			 
125c 23			      inc   HL                      ; Store want size into allocated block 
125d 71			      ld    (HL), C 
125e 23			      inc   HL 
125f 70			      ld    (HL), B 
1260 23			      inc   HL 
1261 e5			      push  HL                      ; Address of allocation to return 
1262			 
1262 18 19		      jr    malloc_update_links 
1264			 
1264			malloc_alloc_fit: 
1264 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1265			 
1265					if DEBUG_FORTH_MALLOC 
1265						DMARK "MAf" 
1265						CALLMONITOR 
1265					endif 
1265			      ; Modify this_free block to be allocation 
1265 eb			      ex    DE, HL 
1266 2b			      dec   HL 
1267 2b			      dec   HL 
1268 2b			      dec   HL 
1269			 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store address of allocation to return 
126e 23			      inc   HL 
126f 23			      inc   HL 
1270 e5			      push  HL 
1271			 
1271			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1271 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1274 dd 66 01		      ld    H, (IX+1) 
1277			 
1277 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127a dd 74 03		      ld    (IX+3), H 
127d			 
127d			 
127d			malloc_update_links: 
127d			      ; Update prev_free ptr to point to this_free 
127d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1280 dd 66 05		      ld    H, (IX+5) 
1283			 
1283 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1286 dd 56 03		      ld    D, (IX+3) 
1289			 
1289 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128a 23			      inc   HL 
128b 72			      ld    (HL), D 
128c			 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "Mul" 
128c						CALLMONITOR 
128c					endif 
128c			      ; Clear the Z flag to indicate successful allocation 
128c 7a			      ld    A, D 
128d b3			      or    E 
128e			 
128e d1			      pop   DE                      ; Address of allocation 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "MAu" 
128f						CALLMONITOR 
128f					endif 
128f			 
128f			malloc_no_space: 
128f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1292 39			      add   HL, SP 
1293 f9			      ld    SP, HL 
1294			 
1294 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAN" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			malloc_early_exit: 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAx" 
1295						CALLMONITOR 
1295					endif 
1295 dd e1		      pop   IX 
1297 d1			      pop   DE 
1298 c1			      pop   BC 
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299 c9			      ret 
129a			 
129a			 
129a			;------------------------------------------------------------------------------ 
129a			;     free                                                                    : 
129a			;                                                                             : 
129a			; Description                                                                 : 
129a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129a			;     returned by malloc, otherwise the behaviour is undefined.               : 
129a			;                                                                             : 
129a			;     Where possible, directly adjacent free blocks will be merged together   : 
129a			;     into larger blocks to help ensure that the heap does not become         : 
129a			;     excessively fragmented.                                                 : 
129a			;                                                                             : 
129a			;     free does not clear or set any other value into the freed space, and    : 
129a			;     therefore its contents may be visible through subsequent malloc's. The  : 
129a			;     caller should clear the freed space as required.                        : 
129a			;                                                                             : 
129a			;     This implementation of free uses the stack exclusively, and is          : 
129a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129a			;     advisable to disable interrupts before calling free, and recommended    : 
129a			;     to avoid the use of free inside ISRs in general.                        : 
129a			;                                                                             : 
129a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129a			;                                                                             : 
129a			; Parameters                                                                  : 
129a			;     HL  Pointer to address of first byte of allocation to be freed          : 
129a			;                                                                             : 
129a			; Returns                                                                     : 
129a			;     Nothing                                                                 : 
129a			;                                                                             : 
129a			; Stack frame                                                                 : 
129a			;       |             |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     BC      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     DE      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     IX      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |  prev_free  |                                                       : 
129a			;   +2  +-------------+                                                       : 
129a			;       |  next_free  |                                                       : 
129a			;   +0  +-------------+                                                       : 
129a			;       |             |                                                       : 
129a			;                                                                             : 
129a			;------------------------------------------------------------------------------ 
129a			free: 
129a c5			      push  BC 
129b d5			      push  DE 
129c dd e5		      push  IX 
129e			 
129e 7c			      ld    A, H                    ; Exit if ptr is null 
129f b5			      or    L 
12a0 ca 64 13		      jp    Z, free_early_exit 
12a3			 
12a3			      ; Set up stack frame 
12a3 eb			      ex    DE, HL 
12a4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a7 39			      add   HL, SP 
12a8 f9			      ld    SP, HL 
12a9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ad dd 39		      add   IX, SP 
12af			 
12af			      ; The address in HL points to the start of the useable allocated space, 
12af			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12af			      ; address of the block itself. 
12af eb			      ex    DE, HL 
12b0 11 fc ff		      ld    DE, -4 
12b3 19			      add   HL, DE 
12b4			 
12b4			      ; An allocated block must have a null next block pointer in it 
12b4 7e			      ld    A, (HL) 
12b5 23			      inc   HL 
12b6 b6			      or    (HL) 
12b7 c2 5f 13		      jp    NZ, free_done 
12ba			 
12ba 2b			      dec   HL 
12bb			 
12bb 44			      ld    B, H                    ; Copy HL to BC 
12bc 4d			      ld    C, L 
12bd			 
12bd			      ; Loop through the free list to find the first block with an address 
12bd			      ; higher than the block being freed 
12bd 21 0a 80		      ld    HL, free_list 
12c0			 
12c0			free_find_higher_block: 
12c0 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c1 23			      inc   HL 
12c2 56			      ld    D, (HL) 
12c3 2b			      dec   HL 
12c4			 
12c4 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c7 dd 72 01		      ld    (IX+1), D 
12ca dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cd dd 74 03		      ld    (IX+3), H 
12d0			 
12d0 78			      ld    A, B                    ; Check if DE is greater than BC 
12d1 ba			      cp    D                       ; Compare MSB first 
12d2 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d4 30 04		      jr    NC, free_find_higher_block_skip 
12d6 79			      ld    A, C 
12d7 bb			      cp    E                       ; Then compare LSB 
12d8 38 08		      jr    C, free_found_higher_block 
12da			 
12da			free_find_higher_block_skip: 
12da 7a			      ld    A, D                    ; Reached the end of the free list? 
12db b3			      or    E 
12dc ca 5f 13		      jp    Z, free_done 
12df			 
12df eb			      ex    DE, HL 
12e0			 
12e0 18 de		      jr    free_find_higher_block 
12e2			 
12e2			free_found_higher_block: 
12e2			      ; Insert freed block between prev and next free blocks 
12e2 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e3 23			      inc   HL 
12e4 70			      ld    (HL), B 
12e5			 
12e5 60			      ld    H, B                    ; Point freed block at next free block 
12e6 69			      ld    L, C 
12e7 73			      ld    (HL), E 
12e8 23			      inc   HL 
12e9 72			      ld    (HL), D 
12ea			 
12ea			      ; Check if the freed block is adjacent to the next free block 
12ea 23			      inc   HL                      ; Load size of freed block into HL 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee eb			      ex    DE, HL 
12ef			 
12ef 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f0			 
12f0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f3 dd 56 01		      ld    D, (IX+1) 
12f6			 
12f6 b7			      or    A                       ; Clear the carry flag 
12f7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f9 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fb			 
12fb			      ; Freed block is adjacent to next, merge into one bigger block 
12fb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff e5			      push  HL                      ; Save ptr to next block for later 
1300			 
1300 60			      ld    H, B                    ; Store ptr from next block into freed block 
1301 69			      ld    L, C 
1302 73			      ld    (HL), E 
1303 23			      inc   HL 
1304 72			      ld    (HL), D 
1305			 
1305 e1			      pop   HL                      ; Restore ptr to next block 
1306 23			      inc   HL                      ; Load size of next block into DE 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a d5			      push  DE                      ; Save next block size for later 
130b			 
130b 60			      ld    H, B                    ; Load size of freed block into HL 
130c 69			      ld    L, C 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 5e			      ld    E, (HL) 
1310 23			      inc   HL 
1311 56			      ld    D, (HL) 
1312 eb			      ex    DE, HL 
1313			 
1313 d1			      pop   DE                      ; Restore size of next block 
1314 19			      add   HL, DE                  ; Add sizes of both blocks 
1315 eb			      ex    DE, HL 
1316			 
1316 60			      ld    H, B                    ; Store new bigger size into freed block 
1317 69			      ld    L, C 
1318 23			      inc   HL 
1319 23			      inc   HL 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d			free_check_adjacent_to_prev: 
131d			      ; Check if the freed block is adjacent to the prev free block 
131d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1320 dd 66 03		      ld    H, (IX+3) 
1323			 
1323 23			      inc   HL                      ; Size of prev free block into DE 
1324 23			      inc   HL 
1325 5e			      ld    E, (HL) 
1326 23			      inc   HL 
1327 56			      ld    D, (HL) 
1328 2b			      dec   HL 
1329 2b			      dec   HL 
132a 2b			      dec   HL 
132b			 
132b 19			      add   HL, DE                  ; Add prev block addr and size 
132c			 
132c b7			      or    A                       ; Clear the carry flag 
132d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132f 20 2e		      jr    NZ, free_done 
1331			 
1331			      ; Freed block is adjacent to prev, merge into one bigger block 
1331 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1332 69			      ld    L, C 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 e5			      push  HL                      ; Save freed block ptr for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133a dd 66 03		      ld    H, (IX+3) 
133d 73			      ld    (HL), E 
133e 23			      inc   HL 
133f 72			      ld    (HL), D 
1340			 
1340 e1			      pop   HL                      ; Restore freed block ptr 
1341 23			      inc   HL                      ; Load size of freed block into DE 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 d5			      push  DE                      ; Save freed block size for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1349 dd 66 03		      ld    H, (IX+3) 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e 5e			      ld    E, (HL) 
134f 23			      inc   HL 
1350 56			      ld    D, (HL) 
1351			 
1351 e1			      pop   HL                      ; Add sizes of both blocks 
1352 19			      add   HL, DE 
1353 eb			      ex    DE, HL 
1354			 
1354 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1357 dd 66 03		      ld    H, (IX+3) 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_done: 
135f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1362 39			      add   HL, SP 
1363 f9			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364 dd e1		      pop   IX 
1366 d1			      pop   DE 
1367 c1			      pop   BC 
1368			 
1368 c9			      ret 
1369			 
1369			; moved to firmware.asm 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			;                  .dw   0 
1369			 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_3 
1369			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1369			;heap_start        .equ  0x9000      ; Starting address of heap 
1369			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1369			; 
1369			 ;     .org 0 
1369			  ;    jp    main 
1369			; 
1369			; 
1369			 ;     .org  0x100 
1369			;main: 
1369			 ;     ld    HL, 0x8100 
1369			  ;    ld    SP, HL 
1369			; 
1369			;      call  heap_init 
1369			 
1369			      ; Make some allocations 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9004 
1369			; 
1369			 ;     ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9014 
1369			 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9024 
1369			 
1369			      ; Free some allocations 
1369			;      ld    HL, 0x9014 
1369			;      call  free 
1369			 
1369			;      ld    HL, 0x9004 
1369			;      call  free 
1369			; 
1369			;      ld    HL, 0x9024 
1369			;      call  free 
1369			 
1369			 
1369			 ;     halt 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     heap_init                                                               : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Initialise the heap and make it ready for malloc and free operations.   : 
1369			;                                                                             : 
1369			;     The heap is maintained as a linked list, starting with an initial       : 
1369			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1369			;     the first free block in the heap. Each block then points to the next    : 
1369			;     free block within the heap, and the free list ends at the first block   : 
1369			;     with a null pointer to the next free block.                             : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     Inputs are compile-time only. Two defines which specify the starting    : 
1369			;     address of the heap and its size are required, along with a memory      : 
1369			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1369			;     principally stores a pointer to the first free block in the heap.       : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;------------------------------------------------------------------------------ 
1369			heap_init: 
1369			      push  HL 
1369			 
1369			      ; Initialise free list struct 
1369			      ld    HL, heap_start 
1369			      ld    (free_list), HL 
1369			      ld    HL, 0 
1369			      ld    (free_list+2), HL 
1369			 
1369			      ; Insert first free block at bottom of heap, consumes entire heap 
1369			      ld    HL, heap_start+heap_size-4 
1369			      ld    (heap_start), HL        ; Next block (end of free list) 
1369			      ld    HL, heap_size-4 
1369			      ld    (heap_start+2), HL      ; Block size 
1369			 
1369			      ; Insert end of free list block at top of heap - two null words will 
1369			      ; terminate the free list 
1369			      ld    HL, 0 
1369			      ld    (heap_start+heap_size-2), HL 
1369			      ld    (heap_start+heap_size-4), HL 
1369			 
1369			      pop   HL 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     malloc                                                                  : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Allocates the wanted space from the heap and returns the address of the : 
1369			;     first useable byte of the allocation.                                   : 
1369			;                                                                             : 
1369			;     Allocations can happen in one of two ways:                              : 
1369			;                                                                             : 
1369			;     1. A free block may be found which is the exact size wanted. In this    : 
1369			;        case the block is removed from the free list and retuedn to the      : 
1369			;        caller.                                                              : 
1369			;     2. A free block may be found which is larger than the size wanted. In   : 
1369			;        this case, the larger block is split into two. The first portion of  : 
1369			;        this block will become the requested space by the malloc call and    : 
1369			;        is returned to the caller. The second portion becomes a new free     : 
1369			;        block, and the free list is adjusted to maintain continuity via this : 
1369			;        newly created block.                                                 : 
1369			;                                                                             : 
1369			;     malloc does not set any initial value in the allocated space, the       : 
1369			;     caller is required to do this as required.                              : 
1369			;                                                                             : 
1369			;     This implementation of malloc uses the stack exclusively, and is        : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling malloc, and recommended  : 
1369			;     to avoid the use of malloc inside ISRs in general.                      : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Number of bytes wanted                                              : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     HL  Address of the first useable byte of the allocation                 : 
1369			;                                                                             : 
1369			; Flags                                                                       : 
1369			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +4  +-------------+                                                       : 
1369			;       |  this_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			malloc: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if no space requested 
1369			      or    L 
1369			      jp    Z, malloc_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; Setup initial state 
1369			      ld    HL, 4                   ; want must also include space used by block struct 
1369			      add   HL, DE 
1369			 
1369			      ld    B, H                    ; Move want to BC 
1369			      ld    C, L 
1369			 
1369			      ld    HL, free_list           ; Store prev_free ptr to stack 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    E, (HL)                 ; Store this_free ptr to stack 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ld    (IX+2), E 
1369			      ld    (IX+3), D 
1369			      ex    DE, HL                  ; this_free ptr into HL 
1369			 
1369			      ; Loop through free block list to find some space 
1369			malloc_find_space: 
1369			      ld    E, (HL)                 ; Load next_free ptr into DE 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1369			      or    E 
1369			      jp    Z, malloc_no_space 
1369			 
1369			      ld    (IX+0), E               ; Store next_free ptr to stack 
1369			      ld    (IX+1), D 
1369			 
1369			      ; Does this block have enough space to make the allocation? 
1369			      inc   HL                      ; Load free block size into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ex    DE, HL                  ; Check size of block against want 
1369			      or    A                       ; Ensure carry flag clear 
1369			      sbc   HL, BC 
1369			      push  HL                      ; Store the result for later (new block size) 
1369			 
1369			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1369			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1369			 
1369			      ; this_free block is not big enough, setup ptrs to test next free block 
1369			      pop   HL                      ; Discard previous result 
1369			 
1369			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1369			      ld    H, (IX+3) 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1369			      ld    H, (IX+1) 
1369			      ld    (IX+2), L 
1369			      ld    (IX+3), H 
1369			 
1369			      jr    malloc_find_space 
1369			 
1369			      ; split a bigger block into two - requested size and remaining size 
1369			malloc_alloc_split: 
1369			      ex    DE, HL                  ; Calculate address of new free block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      add   HL, BC 
1369			 
1369			      ; Create a new block and point it at next_free 
1369			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      ld    (HL), E                 ; Store next_free ptr into new block 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   DE                      ; Store size of new block into new block 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Update this_free ptr to point to new block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1369			      ld    (IX+3), H 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store want size into allocated block 
1369			      ld    (HL), C 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			      inc   HL 
1369			      push  HL                      ; Address of allocation to return 
1369			 
1369			      jr    malloc_update_links 
1369			 
1369			malloc_alloc_fit: 
1369			      pop   HL                      ; Dont need new block size, want is exact fit 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store address of allocation to return 
1369			      inc   HL 
1369			      inc   HL 
1369			      push  HL 
1369			 
1369			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1369			      ld    L, (IX+0)               ; next_free to HL 
1369			      ld    H, (IX+1) 
1369			 
1369			      ld    (IX+2), L               ; HL to this_free 
1369			      ld    (IX+3), H 
1369			 
1369			 
1369			malloc_update_links: 
1369			      ; Update prev_free ptr to point to this_free 
1369			      ld    L, (IX+4)               ; prev_free ptr to HL 
1369			      ld    H, (IX+5) 
1369			 
1369			      ld    E, (IX+2)               ; this_free ptr to DE 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (HL), E                 ; this_free ptr into prev_free 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Clear the Z flag to indicate successful allocation 
1369			      ld    A, D 
1369			      or    E 
1369			 
1369			      pop   DE                      ; Address of allocation 
1369			 
1369			malloc_no_space: 
1369			      ld    HL, 6                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			      ex    DE, HL                  ; Alloc addr into HL for return 
1369			 
1369			malloc_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     free                                                                    : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1369			;     returned by malloc, otherwise the behaviour is undefined.               : 
1369			;                                                                             : 
1369			;     Where possible, directly adjacent free blocks will be merged together   : 
1369			;     into larger blocks to help ensure that the heap does not become         : 
1369			;     excessively fragmented.                                                 : 
1369			;                                                                             : 
1369			;     free does not clear or set any other value into the freed space, and    : 
1369			;     therefore its contents may be visible through subsequent malloc's. The  : 
1369			;     caller should clear the freed space as required.                        : 
1369			;                                                                             : 
1369			;     This implementation of free uses the stack exclusively, and is          : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling free, and recommended    : 
1369			;     to avoid the use of free inside ISRs in general.                        : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Pointer to address of first byte of allocation to be freed          : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			free: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if ptr is null 
1369			      or    L 
1369			      jp    Z, free_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; The address in HL points to the start of the useable allocated space, 
1369			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1369			      ; address of the block itself. 
1369			      ex    DE, HL 
1369			      ld    DE, -4 
1369			      add   HL, DE 
1369			 
1369			      ; An allocated block must have a null next block pointer in it 
1369			      ld    A, (HL) 
1369			      inc   HL 
1369			      or    (HL) 
1369			      jp    NZ, free_done 
1369			 
1369			      dec   HL 
1369			 
1369			      ld    B, H                    ; Copy HL to BC 
1369			      ld    C, L 
1369			 
1369			      ; Loop through the free list to find the first block with an address 
1369			      ; higher than the block being freed 
1369			      ld    HL, free_list 
1369			 
1369			free_find_higher_block: 
1369			      ld    E, (HL)                 ; Load next ptr from free block 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			 
1369			      ld    (IX+0), E               ; Save ptr to next free block 
1369			      ld    (IX+1), D 
1369			      ld    (IX+2), L               ; Save ptr to prev free block 
1369			      ld    (IX+3), H 
1369			 
1369			      ld    A, B                    ; Check if DE is greater than BC 
1369			      cp    D                       ; Compare MSB first 
1369			      jr    Z, $+4                  ; MSB the same, compare LSB 
1369			      jr    NC, free_find_higher_block_skip 
1369			      ld    A, C 
1369			      cp    E                       ; Then compare LSB 
1369			      jr    C, free_found_higher_block 
1369			 
1369			free_find_higher_block_skip: 
1369			      ld    A, D                    ; Reached the end of the free list? 
1369			      or    E 
1369			      jp    Z, free_done 
1369			 
1369			      ex    DE, HL 
1369			 
1369			      jr    free_find_higher_block 
1369			 
1369			free_found_higher_block: 
1369			      ; Insert freed block between prev and next free blocks 
1369			      ld    (HL), C                 ; Point prev free block to freed block 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			 
1369			      ld    H, B                    ; Point freed block at next free block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Check if the freed block is adjacent to the next free block 
1369			      inc   HL                      ; Load size of freed block into HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      add   HL, BC                  ; Add addr of freed block and its size 
1369			 
1369			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_check_adjacent_to_prev 
1369			 
1369			      ; Freed block is adjacent to next, merge into one bigger block 
1369			      ex    DE, HL                  ; Load next ptr from next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save ptr to next block for later 
1369			 
1369			      ld    H, B                    ; Store ptr from next block into freed block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore ptr to next block 
1369			      inc   HL                      ; Load size of next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save next block size for later 
1369			 
1369			      ld    H, B                    ; Load size of freed block into HL 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      pop   DE                      ; Restore size of next block 
1369			      add   HL, DE                  ; Add sizes of both blocks 
1369			      ex    DE, HL 
1369			 
1369			      ld    H, B                    ; Store new bigger size into freed block 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_check_adjacent_to_prev: 
1369			      ; Check if the freed block is adjacent to the prev free block 
1369			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1369			      ld    H, (IX+3) 
1369			 
1369			      inc   HL                      ; Size of prev free block into DE 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      add   HL, DE                  ; Add prev block addr and size 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_done 
1369			 
1369			      ; Freed block is adjacent to prev, merge into one bigger block 
1369			      ld    H, B                    ; Load next ptr from freed block into DE 
1369			      ld    L, C 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save freed block ptr for later 
1369			 
1369			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1369			      ld    H, (IX+3) 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore freed block ptr 
1369			      inc   HL                      ; Load size of freed block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save freed block size for later 
1369			 
1369			      ld    L, (IX+2)               ; Load size of prev block into DE 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      pop   HL                      ; Add sizes of both blocks 
1369			      add   HL, DE 
1369			      ex    DE, HL 
1369			 
1369			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_done: 
1369			      ld    HL, 4                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			free_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;      .org 0x8000 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			 ;                 .dw   0 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_4 
1369			 
1369			; My memory allocation code. Very very simple.... 
1369			; allocate space under 250 chars 
1369			 
1369			heap_init: 
1369				; init start of heap as zero 
1369				;  
1369			 
1369				ld hl, heap_start 
1369				ld a, 0 
1369				ld (hl), a      ; empty block 
1369				inc hl 
1369				ld a, 0 
1369				ld (hl), a      ; length of block 
1369				; write end of list 
1369				inc hl 
1369				ld a,(hl) 
1369				inc hl 
1369				ld a,(hl) 
1369				 
1369			 
1369				; init some malloc vars 
1369			 
1369				ld hl, 0 
1369				ld (free_list), hl       ; store last malloc location 
1369			 
1369				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1369				ld a, 0 
1369				ld (hl), a 
1369			 
1369			 
1369				ld hl, heap_start 
1369				;  
1369				  
1369				ret 
1369			 
1369			 
1369			;    free block marker 
1369			;    requested size  
1369			;    pointer to next block 
1369			;    .... 
1369			;    next block marker 
1369			 
1369			 
1369			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1369			; 
1369			 
1369			 
1369			malloc:  
1369				push de 
1369				push bc 
1369				push af 
1369			 
1369				; hl space required 
1369				 
1369				ld c, l    ; hold space   (TODO only a max of 255) 
1369			 
1369			;	inc c     ; TODO BUG need to fix memory leak on push str 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			 
1369			 
1369			 
1369				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1369			 
1369				ld a, (free_list+3) 
1369				cp 0 
1369				jr z, .contheap 
1369			 
1369				ld hl, (free_list)     ; get last alloc 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mrs" 
1369						CALLMONITOR 
1369					endif 
1369				jr .startalloc 
1369			 
1369			.contheap: 
1369				ld hl, heap_start 
1369			 
1369			.startalloc: 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mym" 
1369						CALLMONITOR 
1369					endif 
1369			.findblock: 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmf" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369				ld a,(hl)  
1369				; if byte is zero then clear to use 
1369			 
1369				cp 0 
1369				jr z, .foundemptyblock 
1369			 
1369				; if byte is not clear 
1369				;     then byte is offset to next block 
1369			 
1369				inc hl 
1369				ld a, (hl) ; get size 
1369			.nextblock:	inc hl 
1369					ld e, (hl) 
1369					inc hl 
1369					ld d, (hl) 
1369					ex de, hl 
1369			;	inc hl  ; move past the store space 
1369			;	inc hl  ; move past zero index  
1369			 
1369				; TODO detect no more space 
1369			 
1369				push hl 
1369				ld de, heap_end 
1369				call cmp16 
1369				pop hl 
1369				jr nc, .nospace 
1369			 
1369				jr .findblock 
1369			 
1369			.nospace: ld hl, 0 
1369				jp .exit 
1369			 
1369			 
1369			.foundemptyblock:	 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mme" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; TODO has block enough space if reusing??? 
1369			 
1369				;  
1369			 
1369			; see if this block has been previously used 
1369				inc hl 
1369				ld a, (hl) 
1369				dec hl 
1369				cp 0 
1369				jr z, .newblock 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meR" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; no reusing previously allocated block 
1369			 
1369			; is it smaller than previously used? 
1369				 
1369				inc hl    ; move to size 
1369				ld a, c 
1369				sub (hl)        ; we want c < (hl) 
1369				dec hl    ; move back to marker 
1369			        jr z, .findblock 
1369			 
1369				; update with the new size which should be lower 
1369			 
1369			        ;inc  hl   ; negate next move. move back to size  
1369			 
1369			.newblock: 
1369				; need to be at marker here 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			 
1369				ld a, c 
1369			 
1369				ld (free_list+3), a	 ; flag resume from last malloc  
1369				ld (free_list), hl    ; save out last location 
1369			 
1369			 
1369				;inc a     ; space for length byte 
1369				ld (hl), a     ; save block in use marker 
1369			 
1369				inc hl   ; move to space marker 
1369				ld (hl), a    ; save new space 
1369			 
1369				inc hl   ; move to start of allocated area 
1369				 
1369			;	push hl     ; save where we are - 1  
1369			 
1369			;	inc hl  ; move past zero index  
1369				; skip space to set down new marker 
1369			 
1369				; provide some extra space for now 
1369			 
1369				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1369				inc a 
1369				inc a 
1369			 
1369				push hl   ; save where we are in the node block 
1369			 
1369				call addatohl 
1369			 
1369				; write linked list point 
1369			 
1369				pop de     ; get our node position 
1369				ex de, hl 
1369			 
1369				ld (hl), e 
1369				inc hl 
1369				ld (hl), d 
1369			 
1369				inc hl 
1369			 
1369				; now at start of allocated data so save pointer 
1369			 
1369				push hl 
1369			 
1369				; jump to position of next node and setup empty header in DE 
1369			 
1369				ex de, hl 
1369			 
1369			;	inc hl ; move past end of block 
1369			 
1369				ld a, 0 
1369				ld (hl), a   ; empty marker 
1369				inc hl 
1369				ld (hl), a   ; size 
1369				inc hl  
1369				ld (hl), a   ; ptr 
1369				inc hl 
1369				ld (hl), a   ; ptr 
1369			 
1369			 
1369				pop hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmr" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			.exit: 
1369				pop af 
1369				pop bc 
1369				pop de  
1369				ret 
1369			 
1369			 
1369			 
1369			 
1369			free:  
1369				push hl 
1369				push af 
1369				; get address in hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "fre" 
1369						CALLMONITOR 
1369					endif 
1369				; data is at hl - move to block count 
1369				dec hl 
1369				dec hl    ; get past pointer 
1369				dec hl 
1369			 
1369				ld a, (hl)    ; need this for a validation check 
1369			 
1369				dec hl    ; move to block marker 
1369			 
1369				; now check that the block count and block marker are the same  
1369			        ; this checks that we are on a malloc node and not random memory 
1369			        ; OK a faint chance this could be a problem but rare - famous last words! 
1369			 
1369				ld c, a 
1369				ld a, (hl)    
1369			 
1369				cp c 
1369				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1369			 
1369				; yes good chance we are on a malloc node 
1369			 
1369				ld a, 0      
1369				ld (hl), a   ; mark as free 
1369			 
1369				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1369			 
1369			.freeignore:  
1369			 
1369				pop af 
1369				pop hl 
1369			 
1369				ret 
1369			 
1369			 
1369			 
1369			endif 
1369			 
1369			; eof 
# End of file firmware_memory.asm
1369			  
1369			; device C  
1369			if SOUND_ENABLE  
1369				include "firmware_sound.asm"  
1369			; Sound abstraction layer 
1369			 
1369			; support different sound chips through common interface 
1369			 
1369			SOUND_DEVICE_AY: equ 0 
1369			 
1369			SOUND_DEVICE: equ Device_A 
1369			 
1369			 
1369			 
1369			if SOUND_DEVICE_AY 
1369				include "firmware_sound_ay38910.asm" 
1369			else 
1369				include "firmware_sound_sn76489an.asm" 
1369			 
1369			; Device support for SN76489AN sound chip 
1369			 
1369			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1369			; http://danceswithferrets.org/geekblog/?p=93 
1369			; https://www.smspower.org/Development/SN76489 
1369			 
1369			; D0 [ 3] 
1369			; D1 [ 2] 
1369			; D2 [ 1] 
1369			; D3 [15] 
1369			; D4 [13] 
1369			; D5 [12] 
1369			; D6 [11] 
1369			; D7 [10] 
1369			; /WE [ 5] 
1369			; CLK [14] 
1369			; /OE [ 6] 
1369			; AUDIO [ 7] 
1369			; GND 8 
1369			; +5 16 
1369			; 
1369			 
1369			; Write sequence: 
1369			; CE low 
1369			; Data bus 
1369			; WE low then high 
1369			; 32 clock cycles / 8ns write time at 4mhz 
1369			; 
1369			; https://github.com/jblang/SN76489 
1369			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1369			; Tried: 
1369			; 
1369			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1369			; 
1369			; Connected WE to OR too 
1369			;  
1369			; That enabled the clock when required 
1369			; However still random bus corruption. Need further investigation 
1369			 
1369			 
1369			SOUND_LATCH: equ 10000000B 
1369			SOUND_DATA: equ 0B 
1369			SOUND_CH0:  equ 0B    ; Tone 
1369			SOUND_CH1: equ 0100000B        ; Tone 
1369			SOUND_CH2: equ 1000000B   ; Tone 
1369			SOUND_CH3: equ 1100000B    ; Noise 
1369			SOUND_VOL: equ 10000B 
1369			SOUND_TONE: equ 0B 
1369			 
1369			 
1369			sound_init: 
1369 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
136b cd 80 13			call note_send_byte 
136e 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1370 cd 80 13			call note_send_byte 
1373 cd 49 0a			call delay250ms 
1376 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1378 cd 80 13			call note_send_byte 
137b cd 49 0a			call delay250ms 
137e c9				ret 
137f			 
137f			; Play a note 
137f			; h = note 
137f			; l = duration 
137f			; a = channel 
137f			 
137f			 
137f			;  frequ = clock / ( 2 x reg valu x 32 )  
137f			 
137f			note:  
137f				 
137f			 
137f c9				ret 
1380			 
1380			note_send_byte: 
1380				; byte in a 
1380			 
1380				; we high 
1380 d3 40			out (Device_B), a 
1382			;	ld a, 1 
1382			;	call aDelayInMS 
1382 00				nop  
1383 00				nop  
1384 00				nop  
1385 00				nop  
1386				; we low 
1386 d3 40			out (Device_B), a 
1388			;	ld a, 1 
1388			;	call aDelayInMS 
1388 00				nop  
1389 00				nop  
138a 00				nop  
138b 00				nop  
138c				; we high 
138c d3 40			out (Device_B), a 
138e			;	ld a, 1 
138e			;	call aDelayInMS 
138e 00				nop  
138f 00				nop  
1390 00				nop  
1391 00				nop  
1392			 
1392			 
1392 c9				ret 
1393			 
1393			;void SilenceAllChannels() 
1393			;{ 
1393			;  SendByte(0x9f); 
1393			;  SendByte(0xbf); 
1393			;  SendByte(0xdf); 
1393			;  SendByte(0xff); 
1393			;} 
1393			 
1393			 
1393			; eof 
1393			 
# End of file firmware_sound_sn76489an.asm
1393			endif 
1393			 
1393			 
1393			; Abstraction entry points 
1393			 
1393			; init  
1393			 
1393			; sound_init in specific hardware files 
1393			 
1393			; Play a note 
1393			; h = note 
1393			; l = duration 
1393			; a = channel 
1393			 
1393			;note:     
1393			;	ret 
1393			 
1393			 
1393			 
1393			 
1393			; eof 
1393			 
# End of file firmware_sound.asm
1393			endif  
1393			  
1393			include "firmware_diags.asm"  
1393			; Hardware diags menu 
1393			 
1393			 
1393			config: 
1393			 
1393 3e 00			ld a, 0 
1395 21 b9 13			ld hl, .configmn 
1398 cd 06 0b			call menu 
139b			 
139b fe 00			cp 0 
139d c8				ret z 
139e			 
139e fe 01			cp 1 
13a0 cc 79 14			call z, .savetostore 
13a3			 
13a3 fe 02			cp 2 
13a5 cc 3f 14			call z, .selautoload 
13a8 fe 03			cp 3 
13aa cc 77 14			call z, .selbank 
13ad fe 05			cp 5 
13af cc 54 15			call z, .debug_tog 
13b2 fe 06			cp 6 
13b4 cc 7a 15			call z, hardware_diags 
13b7			 
13b7 18 da			jr config 
13b9			 
13b9			.configmn: 
13b9 c7 13			dw .c3 
13bb e3 13			dw .c2 
13bd f8 13			dw .c2b 
13bf 0c 14			dw .c4 
13c1 15 14			dw .m4 
13c3 30 14			dw .c1 
13c5 00 00			dw 0 
13c7				 
13c7			 
13c7 .. 00		.c3: db "Add User Dictionary To File",0 
13e3 .. 00		.c2: db "Select Autoload File",0 
13f8 .. 00		.c2b: db "Select Storage Bank",0 
140c .. 00		.c4: db "Settings",0 
1415 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1430 .. 00		.c1: db "Hardware Diags",0 
143f			 
143f			; Select auto start 
143f			 
143f			.selautoload: 
143f			 
143f				 
143f				if STORAGE_SE 
143f			 
143f cd 9e 14				call config_dir 
1442 21 1d ee			        ld hl, scratch 
1445 3e 00				ld a, 0 
1447 cd 06 0b				call menu 
144a			 
144a					; locate menu option 
144a			 
144a 21 1d ee				ld hl, scratch 
144d cd 2d 0a				call table_lookup 
1450			 
1450					; with the pointer to the menu it, the byte following the zero term is the file id 
1450			 
1450 3e 00				ld a, 0 
1452 01 32 00				ld bc, 50   ; max of bytes to look at 
1455 ed b1				cpir  
1457			 
1457 23					inc hl 
1458			 
1458 7e					ld a, (hl)   ; file id 
1459					 
1459				        ; save bank and file ids 
1459			 
1459 f5					push af 
145a			 
145a cd bd 03				call storage_get_block_0 
145d			 
145d f1					pop af 
145e			 
145e 32 86 f8				ld (store_page+STORE_0_FILERUN),a 
1461					 
1461					; save bank id 
1461			 
1461 3a 48 f8				ld a,(spi_device) 
1464 32 85 f8				ld (store_page+STORE_0_BANKRUN),a 
1467			 
1467					; save buffer 
1467			 
1467 21 00 00				ld hl, 0 
146a 11 62 f8				ld de, store_page 
146d cd 71 03			call storage_write_block	 ; save update 
1470			  
1470			 
1470			 
1470			 
1470 21 1d ee				ld hl, scratch 
1473 cd 8b 14				call config_fdir 
1476			 
1476			 
1476				endif 
1476 c9				ret 
1477			 
1477			 
1477			 
1477			; Select storage bank 
1477			 
1477			.selbank: 
1477			 
1477				if STORAGE_SE 
1477				endif 
1477				 
1477 c9				ret 
1478			 
1478			if STORAGE_SE 
1478			 
1478			.config_ldir:   
1478				; Load storage bank labels into menu array 
1478			 
1478				 
1478			 
1478			 
1478 c9				ret 
1479			 
1479			 
1479			endif 
1479			 
1479			 
1479			; Save user words to storage 
1479			 
1479			.savetostore: 
1479			 
1479				if STORAGE_SE 
1479			 
1479 cd 9e 14				call config_dir 
147c 21 1d ee			        ld hl, scratch 
147f 3e 00				ld a, 0 
1481 cd 06 0b				call menu 
1484					 
1484 21 1d ee				ld hl, scratch 
1487 cd 8b 14				call config_fdir 
148a			 
148a			 
148a				endif 
148a			 
148a c9				ret 
148b			 
148b			 
148b			 
148b			if STORAGE_SE 
148b			 
148b			config_fdir: 
148b				; using the scratch dir go through and release the memory allocated for each string 
148b				 
148b 21 1d ee			ld hl, scratch 
148e 5e			.cfdir:	ld e,(hl) 
148f 23				inc hl 
1490 56				ld d,(hl) 
1491 23				inc hl 
1492			 
1492 eb				ex de, hl 
1493 cd 32 0d			call ishlzero 
1496 c8				ret z     ; return on null pointer 
1497 cd 9a 12			call free 
149a eb				ex de, hl 
149b 18 f1			jr .cfdir 
149d			 
149d			 
149d c9				ret 
149e			 
149e			 
149e			config_dir: 
149e			 
149e				; for the config menus that need to build a directory of storage call this routine 
149e				; it will construct a menu in scratch to pass to menu 
149e			 
149e				; open storage device 
149e			 
149e				; execute DIR to build a list of files and their ids into scratch in menu format 
149e				; once the menu has finished then will need to call config_fdir to release the strings 
149e				 
149e				; c = number items 
149e			 
149e				 
149e cd bd 03			call storage_get_block_0 
14a1			 
14a1 21 62 f8			ld hl, store_page     ; get current id count 
14a4 46				ld b, (hl) 
14a5 0e 00			ld c, 0    ; count of files   
14a7			 
14a7			 
14a7 21 1d ee			ld hl, scratch 
14aa 22 5e f8			ld (store_tmp2), hl    ; location to poke strings 
14ad			 
14ad				; check for empty drive 
14ad			 
14ad 3e 00			ld a, 0 
14af b8				cp b 
14b0 ca 4a 15			jp z, .dirdone 
14b3			 
14b3				 
14b3					if DEBUG_FORTH_WORDS 
14b3						DMARK "Cdc" 
14b3 f5				push af  
14b4 3a c8 14			ld a, (.dmark)  
14b7 32 77 fb			ld (debug_mark),a  
14ba 3a c9 14			ld a, (.dmark+1)  
14bd 32 78 fb			ld (debug_mark+1),a  
14c0 3a ca 14			ld a, (.dmark+2)  
14c3 32 79 fb			ld (debug_mark+2),a  
14c6 18 03			jr .pastdmark  
14c8 ..			.dmark: db "Cdc"  
14cb f1			.pastdmark: pop af  
14cc			endm  
# End of macro DMARK
14cc						CALLMONITOR 
14cc cd 92 16			call break_point_state  
14cf				endm  
# End of macro CALLMONITOR
14cf					endif 
14cf			 
14cf			 
14cf			.diritem:	 
14cf c5				push bc 
14d0				; for each of the current ids do a search for them and if found push to stack 
14d0			 
14d0 21 40 00				ld hl, STORE_BLOCK_PHY 
14d3 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
14d5 58					ld e,b 
14d6			 
14d6 cd 2d 06				call storage_findnextid 
14d9			 
14d9			 
14d9					; if found hl will be non zero 
14d9			 
14d9 cd 32 0d				call ishlzero 
14dc 28 69				jr z, .dirnotfound 
14de			 
14de					; increase count 
14de			 
14de c1					pop bc	 
14df 0c					inc c 
14e0 c5					push bc 
14e1					 
14e1			 
14e1					; get file header and push the file name 
14e1			 
14e1 11 62 f8				ld de, store_page 
14e4 cd 0c 03				call storage_read_block 
14e7			 
14e7					; push file id to stack 
14e7				 
14e7 3a 62 f8				ld a, (store_page) 
14ea 26 00				ld h, 0 
14ec 6f					ld l, a 
14ed			 
14ed					;call forth_push_numhl 
14ed					; TODO store id 
14ed			 
14ed e5					push hl 
14ee			 
14ee					; push extent count to stack  
14ee				 
14ee 21 65 f8				ld hl, store_page+3 
14f1			 
14f1					; get file name length 
14f1			 
14f1 cd 67 11				call strlenz   
14f4			 
14f4 23					inc hl   ; cover zero term 
14f5 23					inc hl  ; stick the id at the end of the area 
14f6			 
14f6 e5					push hl 
14f7 c1					pop bc    ; move length to bc 
14f8			 
14f8 cd d0 11				call malloc 
14fb			 
14fb					; TODO save malloc area to scratch 
14fb			 
14fb eb					ex de, hl 
14fc 2a 5e f8				ld hl, (store_tmp2) 
14ff 73					ld (hl), e 
1500 23					inc hl 
1501 72					ld (hl), d 
1502 23					inc hl 
1503 22 5e f8				ld (store_tmp2), hl 
1506			 
1506					 
1506			 
1506					;pop hl   ; get source 
1506			;		ex de, hl    ; swap aronund	 
1506			 
1506 21 65 f8				ld hl, store_page+3 
1509					if DEBUG_FORTH_WORDS 
1509						DMARK "CFd" 
1509 f5				push af  
150a 3a 1e 15			ld a, (.dmark)  
150d 32 77 fb			ld (debug_mark),a  
1510 3a 1f 15			ld a, (.dmark+1)  
1513 32 78 fb			ld (debug_mark+1),a  
1516 3a 20 15			ld a, (.dmark+2)  
1519 32 79 fb			ld (debug_mark+2),a  
151c 18 03			jr .pastdmark  
151e ..			.dmark: db "CFd"  
1521 f1			.pastdmark: pop af  
1522			endm  
# End of macro DMARK
1522						CALLMONITOR 
1522 cd 92 16			call break_point_state  
1525				endm  
# End of macro CALLMONITOR
1525					endif 
1525 ed b0				ldir 
1527			 
1527					; de is past string, move back one and store id 
1527					 
1527 1b					dec de 
1528			 
1528					; store file id 
1528			 
1528 e1					pop hl 
1529 eb					ex de,hl 
152a 73					ld (hl), e 
152b			 
152b					if DEBUG_FORTH_WORDS 
152b						DMARK "Cdi" 
152b f5				push af  
152c 3a 40 15			ld a, (.dmark)  
152f 32 77 fb			ld (debug_mark),a  
1532 3a 41 15			ld a, (.dmark+1)  
1535 32 78 fb			ld (debug_mark+1),a  
1538 3a 42 15			ld a, (.dmark+2)  
153b 32 79 fb			ld (debug_mark+2),a  
153e 18 03			jr .pastdmark  
1540 ..			.dmark: db "Cdi"  
1543 f1			.pastdmark: pop af  
1544			endm  
# End of macro DMARK
1544						CALLMONITOR 
1544 cd 92 16			call break_point_state  
1547				endm  
# End of macro CALLMONITOR
1547					endif 
1547					 
1547			.dirnotfound: 
1547 c1					pop bc     
1548 10 85				djnz .diritem 
154a				 
154a			.dirdone:	 
154a			 
154a 3e 00				ld a, 0 
154c 2a 5e f8				ld hl, (store_tmp2) 
154f 77					ld (hl), a 
1550 23					inc hl 
1551 77					ld (hl), a 
1552 23					inc hl 
1553					; push a count of the dir items found 
1553			 
1553			;		ld h, 0 
1553			;		ld l, c 
1553			 
1553 c9				ret 
1554			 
1554			endif 
1554			 
1554			 
1554			; Settings 
1554			; Run  
1554			 
1554			 
1554			 
1554			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1554			;;hd_menu2:   db "        2: Editor",0   
1554			;hd_menu2:   db "        2: Editor       6: Menu",0   
1554			;hd_menu3:   db "        3: Storage",0 
1554			;hd_menu4:   db "0=quit  4: Debug",0 
1554			;hd_don:     db "ON",0 
1554			;hd_doff:     db "OFF",0 
1554			; 
1554			; 
1554			; 
1554			;hardware_diags_old:       
1554			; 
1554			;.diagmenu: 
1554			;	call clear_display 
1554			;	ld a, display_row_1 
1554			;	ld de, hd_menu1 
1554			;	call str_at_display 
1554			; 
1554			;	ld a, display_row_2 
1554			;	ld de, hd_menu2 
1554			;	call str_at_display 
1554			; 
1554			;	ld a, display_row_3 
1554			;	ld de, hd_menu3 
1554			;	call str_at_display 
1554			; 
1554			;	ld a,  display_row_4 
1554			;	ld de, hd_menu4 
1554			;	call str_at_display 
1554			; 
1554			;	; display debug state 
1554			; 
1554			;	ld de, hd_don 
1554			;	ld a, (os_view_disable) 
1554			;	cp 0 
1554			;	jr z, .distog 
1554			;	ld de, hd_doff 
1554			;.distog: ld a, display_row_4+17 
1554			;	call str_at_display 
1554			; 
1554			;	call update_display 
1554			; 
1554			;	call cin_wait 
1554			; 
1554			; 
1554			; 
1554			;	cp '4' 
1554			;	jr nz, .diagn1 
1554			; 
1554			;	; debug toggle 
1554			; 
1554			;	ld a, (os_view_disable) 
1554			;	ld b, '*' 
1554			;	cp 0 
1554			;	jr z, .debtog 
1554			;	ld b, 0 
1554			;.debtog:	 
1554			;	ld a,b 
1554			;	ld (os_view_disable),a 
1554			; 
1554			;.diagn1: cp '0' 
1554			;	 ret z 
1554			; 
1554			;;	cp '1' 
1554			;;       jp z, matrix	 
1554			;;   TODO keyboard matrix test 
1554			; 
1554			;	cp '2' 
1554			;	jp z, .diagedit 
1554			; 
1554			;;	cp '6' 
1554			;;	jp z, .menutest 
1554			;;if ENABLE_BASIC 
1554			;;	cp '6' 
1554			;;	jp z, basic 
1554			;;endif 
1554			 ; 
1554			;	jp .diagmenu 
1554			; 
1554			; 
1554			;	ret 
1554			 
1554			 
1554			.debug_tog: 
1554 21 9b 15			ld hl, .menudebug 
1557				 
1557 3a 0e ee			ld a, (os_view_disable) 
155a fe 2a			cp '*' 
155c 20 04			jr nz,.tdon  
155e 3e 01			ld a, 1 
1560 18 02			jr .tog1 
1562 3e 00		.tdon: ld a, 0 
1564			 
1564			.tog1: 
1564 cd 06 0b			call menu 
1567 fe 00			cp 0 
1569 c8				ret z 
156a fe 01			cp 1    ; disable debug 
156c 28 04			jr z, .dtog0 
156e 3e 2a			ld a, '*' 
1570 18 02			jr .dtogset 
1572 3e 00		.dtog0: ld a, 0 
1574 32 0e ee		.dtogset:  ld (os_view_disable), a 
1577 c3 54 15			jp .debug_tog 
157a			 
157a			 
157a			hardware_diags:       
157a			 
157a			.diagm: 
157a 21 8d 15			ld hl, .menuitems 
157d 3e 00			ld a, 0 
157f cd 06 0b			call menu 
1582			 
1582 fe 00		         cp 0 
1584 c8				 ret z 
1585			 
1585 fe 02			cp 2 
1587 ca e6 15			jp z, .diagedit 
158a			 
158a			;	cp '6' 
158a			;	jp z, .menutest 
158a			;if ENABLE_BASIC 
158a			;	cp '6' 
158a			;	jp z, basic 
158a			;endif 
158a			  
158a c3 7a 15			jp .diagm 
158d			 
158d				 
158d a1 15		.menuitems:   	dw .m1 
158f ac 15				dw .m2 
1591 b3 15				dw .m3 
1593 bb 15				dw .m5 
1595 c1 15				dw .m5a 
1597 ca 15				dw .m5b 
1599 00 00				dw 0 
159b			 
159b			.menudebug: 
159b d3 15				dw .m6 
159d dc 15				dw .m7 
159f 00 00				dw 0 
15a1			 
15a1 .. 00		.m1:   db "Key Matrix",0 
15ac .. 00		.m2:   db "Editor",0 
15b3 .. 00		.m3:   db "Storage",0 
15bb .. 00		.m5:   db "Sound",0 
15c1 .. 00		.m5a:  db "RAM Test",0 
15ca .. 00		.m5b:  db "LCD Test",0 
15d3			 
15d3 .. 00		.m6:   db "Debug ON",0 
15dc .. 00		.m7:   db "Debug OFF",0 
15e6			 
15e6			; debug editor 
15e6			 
15e6			.diagedit: 
15e6			 
15e6 21 1d ee			ld hl, scratch 
15e9			;	ld bc, 250 
15e9			;	ldir 
15e9				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
15e9 3e 00			ld a, 0 
15eb 77				ld (hl), a 
15ec 23				inc hl 
15ed 77				ld (hl), a 
15ee 23				inc hl 
15ef 77				ld (hl), a 
15f0			 
15f0 cd d5 0a		        call clear_display 
15f3 cd f8 0a			call update_display 
15f6 3e 01			ld a, 1 
15f8 32 7d fb			ld (hardware_diag), a 
15fb			.diloop: 
15fb 3e 00			ld a, display_row_1 
15fd 0e 00			ld c, 0 
15ff 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1601 1e 28			ld e, 40 
1603			 
1603 21 1d ee			ld hl, scratch	 
1606 cd 36 0d			call input_str 
1609			 
1609 3e 28			ld a, display_row_2 
160b 11 1d ee			ld de, scratch 
160e cd e8 0a			call str_at_display 
1611 cd f8 0a			call update_display 
1614			 
1614 c3 fb 15			jp .diloop 
1617			 
1617			 
1617			; pass word in hl 
1617			; a has display location 
1617			display_word_at: 
1617 f5				push af 
1618 e5				push hl 
1619 7c				ld a,h 
161a 21 22 f1			ld hl, os_word_scratch 
161d cd 0a 10			call hexout 
1620 e1				pop hl 
1621 7d				ld a,l 
1622 21 24 f1			ld hl, os_word_scratch+2 
1625 cd 0a 10			call hexout 
1628 21 26 f1			ld hl, os_word_scratch+4 
162b 3e 00			ld a,0 
162d 77				ld (hl),a 
162e 11 22 f1			ld de,os_word_scratch 
1631 f1				pop af 
1632 cd e8 0a				call str_at_display 
1635 c9				ret 
1636			 
1636			display_ptr_state: 
1636			 
1636				; to restore afterwards 
1636			 
1636 d5				push de 
1637 c5				push bc 
1638 e5				push hl 
1639 f5				push af 
163a			 
163a				; for use in here 
163a			 
163a			;	push bc 
163a			;	push de 
163a			;	push hl 
163a			;	push af 
163a			 
163a cd d5 0a			call clear_display 
163d			 
163d 11 10 18			ld de, .ptrstate 
1640 3e 00			ld a, display_row_1 
1642 cd e8 0a			call str_at_display 
1645			 
1645				; display debug step 
1645			 
1645			 
1645 11 77 fb			ld de, debug_mark 
1648 3e 26			ld a, display_row_1+display_cols-2 
164a cd e8 0a			call str_at_display 
164d			 
164d				; display a 
164d 11 1a 18			ld de, .ptrcliptr 
1650 3e 28			ld a, display_row_2 
1652 cd e8 0a			call str_at_display 
1655			 
1655 f1				pop af 
1656 2a 28 f8			ld hl,(cli_ptr) 
1659 3e 30			ld a, display_row_2+8 
165b cd 17 16			call display_word_at 
165e			 
165e			 
165e				; display hl 
165e			 
165e			 
165e 11 22 18			ld de, .ptrclioptr 
1661 3e 32			ld a, display_row_2+10 
1663 cd e8 0a			call str_at_display 
1666			; 
1666			;	pop hl 
1666 3e 35			ld a, display_row_2+13 
1668 2a 26 f8			ld hl,(cli_origptr) 
166b cd 17 16			call display_word_at 
166e			; 
166e			;	 
166e			;	; display de 
166e			 
166e			;	ld de, .regstatede 
166e			;	ld a, display_row_3 
166e			;	call str_at_display 
166e			 
166e			;	pop de 
166e			;	ld h,d 
166e			;	ld l, e 
166e			;	ld a, display_row_3+3 
166e			;	call display_word_at 
166e			 
166e			 
166e				; display bc 
166e			 
166e			;	ld de, .regstatebc 
166e			;	ld a, display_row_3+10 
166e			;	call str_at_display 
166e			 
166e			;	pop bc 
166e			;	ld h,b 
166e			;	ld l, c 
166e			;	ld a, display_row_3+13 
166e			;	call display_word_at 
166e			 
166e			 
166e				; display dsp 
166e			 
166e			;	ld de, .regstatedsp 
166e			;	ld a, display_row_4 
166e			;	call str_at_display 
166e			 
166e				 
166e			;	ld hl,(cli_data_sp) 
166e			;	ld a, display_row_4+4 
166e			;	call display_word_at 
166e			 
166e				; display rsp 
166e			 
166e 11 51 18			ld de, .regstatersp 
1671 3e 82			ld a, display_row_4+10 
1673 cd e8 0a			call str_at_display 
1676			 
1676				 
1676 2a 0e f8			ld hl,(cli_ret_sp) 
1679 3e 86			ld a, display_row_4+14 
167b cd 17 16			call display_word_at 
167e			 
167e cd f8 0a			call update_display 
1681			 
1681 cd 55 0a			call delay1s 
1684 cd 55 0a			call delay1s 
1687 cd 55 0a			call delay1s 
168a			 
168a			 
168a cd 97 1b			call next_page_prompt 
168d			 
168d				; restore  
168d			 
168d f1				pop af 
168e e1				pop hl 
168f c1				pop bc 
1690 d1				pop de 
1691 c9				ret 
1692			 
1692			break_point_state: 
1692 f5				push af 
1693			 
1693				; see if disabled 
1693			 
1693 3a 0e ee			ld a, (os_view_disable) 
1696 fe 2a			cp '*' 
1698 20 02			jr nz, .bpsgo 
169a f1				pop af 
169b c9				ret 
169c			 
169c			.bpsgo: 
169c f1				pop af 
169d f5				push af 
169e 22 0a ee			ld (os_view_hl), hl 
16a1 ed 53 08 ee		ld (os_view_de), de 
16a5 ed 43 06 ee		ld (os_view_bc), bc 
16a9 e5				push hl 
16aa 6f				ld l, a 
16ab 26 00			ld h, 0 
16ad 22 0c ee			ld (os_view_af),hl 
16b0			 
16b0 21 bd fa				ld hl, display_fb0 
16b3 22 d8 f8				ld (display_fb_active), hl 
16b6 e1				pop hl	 
16b7			 
16b7 3e 31			ld a, '1' 
16b9 fe 2a		.bps1:  cp '*' 
16bb 20 03			jr nz, .bps1b 
16bd 32 0e ee			ld (os_view_disable),a 
16c0 fe 31		.bps1b:  cp '1' 
16c2 20 14			jr nz, .bps2 
16c4			 
16c4				; display reg 
16c4			 
16c4				 
16c4			 
16c4 3a 0c ee			ld a, (os_view_af) 
16c7 2a 0a ee			ld hl, (os_view_hl) 
16ca ed 5b 08 ee		ld de, (os_view_de) 
16ce ed 4b 06 ee		ld bc, (os_view_bc) 
16d2 cd 6c 17			call display_reg_state 
16d5 c3 58 17			jp .bpschk 
16d8			 
16d8 fe 32		.bps2:  cp '2' 
16da 20 08			jr nz, .bps3 
16dc				 
16dc				; display hl 
16dc 2a 0a ee			ld hl, (os_view_hl) 
16df cd 56 18			call display_dump_at_hl 
16e2			 
16e2 18 74			jr .bpschk 
16e4			 
16e4 fe 33		.bps3:  cp '3' 
16e6 20 08			jr nz, .bps4 
16e8			 
16e8			        ; display de 
16e8 2a 08 ee			ld hl, (os_view_de) 
16eb cd 56 18			call display_dump_at_hl 
16ee			 
16ee 18 68			jr .bpschk 
16f0 fe 34		.bps4:  cp '4' 
16f2 20 08			jr nz, .bps5 
16f4			 
16f4			        ; display bc 
16f4 2a 06 ee			ld hl, (os_view_bc) 
16f7 cd 56 18			call display_dump_at_hl 
16fa			 
16fa 18 5c			jr .bpschk 
16fc fe 35		.bps5:  cp '5' 
16fe 20 08		        jr nz, .bps7 
1700			 
1700				; display cur ptr 
1700 2a 28 f8			ld hl, (cli_ptr) 
1703 cd 56 18			call display_dump_at_hl 
1706			 
1706 18 50			jr .bpschk 
1708 fe 36		.bps7:  cp '6' 
170a 20 08			jr nz, .bps8b 
170c				 
170c				; display cur orig ptr 
170c 2a 26 f8			ld hl, (cli_origptr) 
170f cd 56 18			call display_dump_at_hl 
1712 18 44			jr .bpschk 
1714 fe 37		.bps8b:  cp '7' 
1716 20 08			jr nz, .bps9 
1718				 
1718				; display dsp 
1718 2a 0a f8			ld hl, (cli_data_sp) 
171b cd 56 18			call display_dump_at_hl 
171e			 
171e 18 38			jr .bpschk 
1720 fe 39		.bps9:  cp '9' 
1722 20 05			jr nz, .bps8c 
1724				 
1724				; display SP 
1724			;	ld hl, sp 
1724 cd 56 18			call display_dump_at_hl 
1727			 
1727 18 2f			jr .bpschk 
1729 fe 38		.bps8c:  cp '8' 
172b 20 08			jr nz, .bps8d 
172d				 
172d				; display rsp 
172d 2a 0e f8			ld hl, (cli_ret_sp) 
1730 cd 56 18			call display_dump_at_hl 
1733			 
1733 18 23			jr .bpschk 
1735 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1737 20 05			jr nz, .bps8 
1739 cd 8d 19			call monitor 
173c			 
173c 18 1a			jr .bpschk 
173e fe 30		.bps8:  cp '0' 
1740 20 16			jr nz, .bpschk 
1742			 
1742 21 1c fa				ld hl, display_fb1 
1745 22 d8 f8				ld (display_fb_active), hl 
1748 cd f8 0a				call update_display 
174b			 
174b				;ld a, (os_view_af) 
174b 2a 0a ee			ld hl, (os_view_hl) 
174e ed 5b 08 ee		ld de, (os_view_de) 
1752 ed 4b 06 ee		ld bc, (os_view_bc) 
1756 f1				pop af 
1757 c9				ret 
1758			 
1758			.bpschk:   
1758 cd 55 0a			call delay1s 
175b 3e 9f		ld a,display_row_4 + display_cols - 1 
175d 11 95 1b		        ld de, endprg 
1760 cd e8 0a			call str_at_display 
1763 cd f8 0a			call update_display 
1766 cd 3c 68			call cin_wait 
1769			 
1769 c3 b9 16			jp .bps1 
176c			 
176c			 
176c			display_reg_state: 
176c			 
176c				; to restore afterwards 
176c			 
176c d5				push de 
176d c5				push bc 
176e e5				push hl 
176f f5				push af 
1770			 
1770				; for use in here 
1770			 
1770 c5				push bc 
1771 d5				push de 
1772 e5				push hl 
1773 f5				push af 
1774			 
1774 cd d5 0a			call clear_display 
1777			 
1777 11 2c 18			ld de, .regstate 
177a 3e 00			ld a, display_row_1 
177c cd e8 0a			call str_at_display 
177f			 
177f				; display debug step 
177f			 
177f			 
177f 11 77 fb			ld de, debug_mark 
1782 3e 25			ld a, display_row_1+display_cols-3 
1784 cd e8 0a			call str_at_display 
1787			 
1787				; display a 
1787 11 48 18			ld de, .regstatea 
178a 3e 28			ld a, display_row_2 
178c cd e8 0a			call str_at_display 
178f			 
178f e1				pop hl 
1790			;	ld h,0 
1790			;	ld l, a 
1790 3e 2b			ld a, display_row_2+3 
1792 cd 17 16			call display_word_at 
1795			 
1795			 
1795				; display hl 
1795			 
1795			 
1795 11 3c 18			ld de, .regstatehl 
1798 3e 32			ld a, display_row_2+10 
179a cd e8 0a			call str_at_display 
179d			 
179d e1				pop hl 
179e 3e 35			ld a, display_row_2+13 
17a0 cd 17 16			call display_word_at 
17a3			 
17a3				 
17a3				; display de 
17a3			 
17a3 11 40 18			ld de, .regstatede 
17a6 3e 50			ld a, display_row_3 
17a8 cd e8 0a			call str_at_display 
17ab			 
17ab e1				pop hl 
17ac			;	ld h,d 
17ac			;	ld l, e 
17ac 3e 53			ld a, display_row_3+3 
17ae cd 17 16			call display_word_at 
17b1			 
17b1			 
17b1				; display bc 
17b1			 
17b1 11 44 18			ld de, .regstatebc 
17b4 3e 5a			ld a, display_row_3+10 
17b6 cd e8 0a			call str_at_display 
17b9			 
17b9 e1				pop hl 
17ba			;	ld h,b 
17ba			;	ld l, c 
17ba 3e 5d			ld a, display_row_3+13 
17bc cd 17 16			call display_word_at 
17bf			 
17bf			 
17bf				; display dsp 
17bf			 
17bf 11 4c 18			ld de, .regstatedsp 
17c2 3e 78			ld a, display_row_4 
17c4 cd e8 0a			call str_at_display 
17c7			 
17c7				 
17c7 2a 0a f8			ld hl,(cli_data_sp) 
17ca 3e 7c			ld a, display_row_4+4 
17cc cd 17 16			call display_word_at 
17cf			 
17cf				; display rsp 
17cf			 
17cf 11 51 18			ld de, .regstatersp 
17d2 3e 82			ld a, display_row_4+10 
17d4 cd e8 0a			call str_at_display 
17d7			 
17d7				 
17d7 2a 0e f8			ld hl,(cli_ret_sp) 
17da 3e 86			ld a, display_row_4+14 
17dc cd 17 16			call display_word_at 
17df			 
17df cd f8 0a			call update_display 
17e2			 
17e2			;	call delay1s 
17e2			;	call delay1s 
17e2			;	call delay1s 
17e2			 
17e2			 
17e2			;	call next_page_prompt 
17e2			 
17e2				; restore  
17e2			 
17e2 f1				pop af 
17e3 e1				pop hl 
17e4 c1				pop bc 
17e5 d1				pop de 
17e6 c9				ret 
17e7			 
17e7 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
17fb .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1810 .. 00		.ptrstate:	db "Ptr State",0 
181a .. 00		.ptrcliptr:     db "cli_ptr",0 
1822 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
182c .. 00		.regstate:	db "Reg State (1/0)",0 
183c .. 00		.regstatehl:	db "HL:",0 
1840 .. 00		.regstatede:	db "DE:",0 
1844 .. 00		.regstatebc:	db "BC:",0 
1848 .. 00		.regstatea:	db "A :",0 
184c .. 00		.regstatedsp:	db "DSP:",0 
1851 .. 00		.regstatersp:	db "RSP:",0 
1856			 
1856			display_dump_at_hl: 
1856 e5				push hl 
1857 d5				push de 
1858 c5				push bc 
1859 f5				push af 
185a			 
185a 22 40 f1			ld (os_cur_ptr),hl	 
185d cd d5 0a			call clear_display 
1860 cd 9f 1a			call dumpcont 
1863			;	call delay1s 
1863			;	call next_page_prompt 
1863			 
1863			 
1863 f1				pop af 
1864 c1				pop bc 
1865 d1				pop de 
1866 e1				pop hl 
1867 c9				ret 
1868			 
1868			;if ENABLE_BASIC 
1868			;	include "nascombasic.asm" 
1868			;	basic: 
1868			;	include "forth/FORTH.ASM" 
1868			;endif 
1868			 
1868			; eof 
1868			 
1868			 
# End of file firmware_diags.asm
1868			  
1868			  
1868			  
1868			  
1868			; eof  
1868			  
# End of file firmware.asm
1868			 
1868			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1868			;if BASE_KEV  
1868			;baseram: equ 08000h 
1868			;endif 
1868			 
1868			;if BASE_SC114 
1868			;baseram:     equ    endofcode 
1868			;endif 
1868			 
1868			 
1868			; start system 
1868			 
1868			coldstart: 
1868				; set sp 
1868				; di/ei 
1868			 
1868 f3				di 
1869 31 fd ff			ld sp, tos 
186c			;	ei 
186c			 
186c			 
186c				; disable breakpoint by default 
186c			 
186c 3e 2a			ld a,'*' 
186e 32 0e ee			ld (os_view_disable),a 
1871			 
1871				; init hardware 
1871			 
1871				; init keyboard and screen hardware 
1871			 
1871 cd 03 00			call hardware_init 
1874			 
1874			 
1874				; detect if any keys are held down to enable breakpoints at start up 
1874			 
1874 cd 4d 68			call cin  
1877 fe 00			cp 0 
1879 28 03			jr z, .nokeys 
187b			 
187b				;call hardware_diags 
187b cd 93 13			call config 
187e			 
187e			;	ld de, .bpen 
187e			;	ld a, display_row_4 
187e			;	call str_at_display 
187e			;	call update_display 
187e			; 
187e			;	ld a,0 
187e			;	ld (os_view_disable),a 
187e			; 
187e			;.bpwait: 
187e			;	call cin 
187e			;	cp 0 
187e			;	jr z, .bpwait 
187e			;	jr .nokeys 
187e			; 
187e			; 
187e			;.bpen:  db "Break points enabled!",0 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			.nokeys: 
187e			 
187e			 
187e				 
187e			 
187e			;jp  testkey 
187e			 
187e			;call storage_get_block_0 
187e			; 
187e			;ld hl, 0 
187e			;ld de, store_page 
187e			;call storage_read_block 
187e			 
187e				 
187e			;ld hl, 10 
187e			;ld de, store_page 
187e			;call storage_read_block 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			;stop:	nop 
187e			;	jp stop 
187e			 
187e			 
187e			 
187e			main: 
187e cd d5 0a			call clear_display 
1881 cd f8 0a			call update_display 
1884			 
1884			 
1884			 
1884			;	call testlcd 
1884			 
1884			 
1884			 
1884 cd 5d 1f			call forth_init 
1887			 
1887			 
1887			warmstart: 
1887 cd 33 1f			call forth_warmstart 
188a			 
188a				; run startup word load 
188a			        ; TODO prevent this running at warmstart after crash  
188a			 
188a				if STARTUP_ENABLE 
188a cd 13 62				call forth_startup 
188d				endif 
188d			 
188d				; show free memory after boot 
188d 11 27 19			ld de, freeram 
1890 3e 00			ld a, display_row_1 
1892 cd e8 0a			call str_at_display 
1895			 
1895			; Or use heap_size word???? 
1895 21 03 ee			ld hl, heap_end 
1898 11 0e 80			ld de, heap_start 
189b ed 52			sbc hl, de 
189d e5				push hl 
189e 7c				ld a,h	         	 
189f 21 22 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18a2 cd 0a 10			call hexout 
18a5 e1			   	pop hl 
18a6			 
18a6 7d				ld a,l 
18a7 21 24 f1			ld hl, os_word_scratch+2 
18aa cd 0a 10			call hexout 
18ad 21 26 f1			ld hl, os_word_scratch+4 
18b0 3e 00			ld a, 0 
18b2 77				ld (hl),a 
18b3 11 22 f1			ld de, os_word_scratch 
18b6 3e 0d			ld a, display_row_1 + 13 
18b8 cd e8 0a			call str_at_display 
18bb cd f8 0a			call update_display 
18be			 
18be			 
18be				;call demo 
18be			 
18be			 
18be				; init scratch input area for cli commands 
18be			 
18be 21 44 f1			ld hl, os_cli_cmd 
18c1 3e 00			ld a,0 
18c3 77				ld (hl),a 
18c4 23				inc hl 
18c5 77				ld (hl),a 
18c6			 
18c6 3e 00			ld a,0 
18c8 32 43 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18cb			 
18cb 32 40 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18ce 32 41 f1			ld (os_cur_ptr+1),a	 
18d1			 
18d1 32 22 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18d4 32 23 f1			ld (os_word_scratch+1),a	 
18d7				 
18d7			 
18d7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d7 21 44 f1			ld hl, os_cli_cmd 
18da			 
18da 3e 00			ld a, 0		 ; init cli input 
18dc 77				ld (hl), a 
18dd 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18df			cli: 
18df				; show cli prompt 
18df				;push af 
18df				;ld a, 0 
18df				;ld de, prompt 
18df				;call str_at_display 
18df			 
18df				;call update_display 
18df				;pop af 
18df				;inc a 
18df				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18df 0e 00			ld c, 0 
18e1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18e3 1e 28			ld e, 40 
18e5			 
18e5 21 44 f1			ld hl, os_cli_cmd 
18e8			 
18e8				STACKFRAME OFF $fefe $9f9f 
18e8				if DEBUG_STACK_IMB 
18e8					if OFF 
18e8						exx 
18e8						ld de, $fefe 
18e8						ld a, d 
18e8						ld hl, curframe 
18e8						call hexout 
18e8						ld a, e 
18e8						ld hl, curframe+2 
18e8						call hexout 
18e8						ld hl, $fefe 
18e8						push hl 
18e8						ld hl, $9f9f 
18e8						push hl 
18e8						exx 
18e8					endif 
18e8				endif 
18e8			endm 
# End of macro STACKFRAME
18e8			 
18e8 cd 36 0d			call input_str 
18eb			 
18eb				STACKFRAMECHK OFF $fefe $9f9f 
18eb				if DEBUG_STACK_IMB 
18eb					if OFF 
18eb						exx 
18eb						ld hl, $9f9f 
18eb						pop de   ; $9f9f 
18eb						call cmp16 
18eb						jr nz, .spnosame 
18eb						ld hl, $fefe 
18eb						pop de   ; $fefe 
18eb						call cmp16 
18eb						jr z, .spfrsame 
18eb						.spnosame: call showsperror 
18eb						.spfrsame: nop 
18eb						exx 
18eb					endif 
18eb				endif 
18eb			endm 
# End of macro STACKFRAMECHK
18eb			 
18eb				; copy input to last command 
18eb			 
18eb 21 44 f1			ld hl, os_cli_cmd 
18ee 11 43 f2			ld de, os_last_cmd 
18f1 01 ff 00			ld bc, 255 
18f4 ed b0			ldir 
18f6			 
18f6				; wipe current buffer 
18f6			 
18f6			;	ld a, 0 
18f6			;	ld hl, os_cli_cmd 
18f6			;	ld de, os_cli_cmd+1 
18f6			;	ld bc, 254 
18f6			;	ldir 
18f6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18f6			;	call strcpy 
18f6			;	ld a, 0 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			 
18f6				; switch frame buffer to program  
18f6			 
18f6 21 1c fa				ld hl, display_fb1 
18f9 22 d8 f8				ld (display_fb_active), hl 
18fc			 
18fc			;	nop 
18fc				STACKFRAME ON $fbfe $8f9f 
18fc				if DEBUG_STACK_IMB 
18fc					if ON 
18fc						exx 
18fc						ld de, $fbfe 
18fc						ld a, d 
18fc						ld hl, curframe 
18fc						call hexout 
18fc						ld a, e 
18fc						ld hl, curframe+2 
18fc						call hexout 
18fc						ld hl, $fbfe 
18fc						push hl 
18fc						ld hl, $8f9f 
18fc						push hl 
18fc						exx 
18fc					endif 
18fc				endif 
18fc			endm 
# End of macro STACKFRAME
18fc				; first time into the parser so pass over the current scratch pad 
18fc 21 44 f1			ld hl,os_cli_cmd 
18ff				; tokenise the entered statement(s) in HL 
18ff cd d6 1f			call forthparse 
1902			        ; exec forth statements in top of return stack 
1902 cd 16 20			call forthexec 
1905				;call forthexec_cleanup 
1905			;	call parsenext 
1905			 
1905				STACKFRAMECHK ON $fbfe $8f9f 
1905				if DEBUG_STACK_IMB 
1905					if ON 
1905						exx 
1905						ld hl, $8f9f 
1905						pop de   ; $8f9f 
1905						call cmp16 
1905						jr nz, .spnosame 
1905						ld hl, $fbfe 
1905						pop de   ; $fbfe 
1905						call cmp16 
1905						jr z, .spfrsame 
1905						.spnosame: call showsperror 
1905						.spfrsame: nop 
1905						exx 
1905					endif 
1905				endif 
1905			endm 
# End of macro STACKFRAMECHK
1905				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1905			 
1905 3e 78			ld a, display_row_4 
1907 11 39 19			ld de, endprog 
190a			 
190a cd f8 0a			call update_display		 
190d			 
190d cd 97 1b			call next_page_prompt 
1910			 
1910				; switch frame buffer to cli 
1910			 
1910 21 bd fa				ld hl, display_fb0 
1913 22 d8 f8				ld (display_fb_active), hl 
1916			 
1916			 
1916 cd d5 0a		        call clear_display 
1919 cd f8 0a			call update_display		 
191c			 
191c 21 44 f1			ld hl, os_cli_cmd 
191f			 
191f 3e 00			ld a, 0		 ; init cli input 
1921 77				ld (hl), a 
1922			 
1922				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1922			 
1922				; now on last line 
1922			 
1922				; TODO scroll screen up 
1922			 
1922				; TODO instead just clear screen and place at top of screen 
1922			 
1922			;	ld a, 0 
1922			;	ld (f_cursor_ptr),a 
1922			 
1922				;call clear_display 
1922				;call update_display 
1922			 
1922				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1922 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1924 c3 df 18			jp cli 
1927			 
1927 .. 00		freeram: db "Free bytes: $",0 
1935 ..			asc: db "1A2F" 
1939 .. 00		endprog: db "End prog...",0 
1945			 
1945			testenter2:   
1945 21 4f ee			ld hl,scratch+50 
1948 22 40 f1			ld (os_cur_ptr),hl 
194b c3 df 18			jp cli 
194e			 
194e			testenter:  
194e			 
194e 21 35 19			ld hl,asc 
1951			;	ld a,(hl) 
1951			;	call nibble2val 
1951 cd 60 10			call get_byte 
1954			 
1954			 
1954			;	ld a,(hl) 
1954			;	call atohex 
1954			 
1954			;	call fourehexhl 
1954 32 4f ee			ld (scratch+50),a 
1957			 
1957			 
1957			 
1957 21 37 19			ld hl,asc+2 
195a			;	ld a, (hl) 
195a			;	call nibble2val 
195a cd 60 10			call get_byte 
195d			 
195d			;	call fourehexhl 
195d 32 51 ee			ld (scratch+52),a 
1960				 
1960 21 4f ee			ld hl,scratch+50 
1963 22 40 f1			ld (os_cur_ptr),hl 
1966 c3 df 18			jp cli 
1969			 
1969			enter:	 
1969 3a 21 ee			ld a,(scratch+4) 
196c fe 00			cp 0 
196e 28 0c			jr z, .entercont 
1970				; no, not a null term line so has an address to work out.... 
1970			 
1970 21 1f ee			ld hl,scratch+2 
1973 cd c0 10			call get_word_hl 
1976			 
1976 22 40 f1			ld (os_cur_ptr),hl	 
1979 c3 df 18			jp cli 
197c			 
197c			 
197c			.entercont:  
197c			 
197c 21 1f ee			ld hl, scratch+2 
197f cd 60 10			call get_byte 
1982			 
1982 2a 40 f1		   	ld hl,(os_cur_ptr) 
1985 77					ld (hl),a 
1986 23					inc hl 
1987 22 40 f1				ld (os_cur_ptr),hl 
198a				 
198a			; get byte  
198a			 
198a			 
198a c3 df 18			jp cli 
198d			 
198d			 
198d			; basic monitor support 
198d			 
198d			monitor: 
198d				;  
198d cd d5 0a			call clear_display 
1990 3e 00			ld a, 0 
1992 11 da 19			ld de, .monprompt 
1995 cd e8 0a			call str_at_display 
1998 cd f8 0a			call update_display 
199b			 
199b				; get a monitor command 
199b			 
199b 0e 00			ld c, 0     ; entry at top left 
199d 16 64			ld d, 100   ; max buffer size 
199f 1e 0f			ld e, 15    ; input scroll area 
19a1 3e 00			ld a, 0     ; init string 
19a3 21 1b f0			ld hl, os_input 
19a6 77				ld (hl), a 
19a7 23				inc hl 
19a8 77				ld (hl), a 
19a9 21 1b f0			ld hl, os_input 
19ac 3e 01			ld a, 1     ; init string 
19ae cd 36 0d			call input_str 
19b1			 
19b1 cd d5 0a		        call clear_display 
19b4 cd f8 0a			call update_display		 
19b7			 
19b7 3a 1b f0			ld a, (os_input) 
19ba cd 5e 11			call toUpper 
19bd fe 48		        cp 'H' 
19bf 28 6f		        jr z, .monhelp 
19c1 fe 44			cp 'D'		; dump 
19c3 ca 51 1a			jp z, .mondump	 
19c6 fe 43			cp 'C'		; dump 
19c8 ca 6b 1a			jp z, .moncdump	 
19cb fe 4d			cp 'M'		; dump 
19cd ca dc 19			jp z, .moneditstart 
19d0 fe 55			cp 'U'		; dump 
19d2 28 14			jr z, .monedit	 
19d4 fe 51			cp 'Q'		; dump 
19d6 c8				ret z	 
19d7			 
19d7			 
19d7				; TODO "S" to access symbol by name and not need the address 
19d7				; TODO "F" to find a string in memory 
19d7			 
19d7 c3 8d 19			jp monitor 
19da			 
19da .. 00		.monprompt: db ">", 0 
19dc			 
19dc			.moneditstart: 
19dc				; get starting address 
19dc			 
19dc 21 1d f0			ld hl,os_input+2 
19df cd c0 10			call get_word_hl 
19e2			 
19e2 22 40 f1			ld (os_cur_ptr),hl	 
19e5			 
19e5 c3 8d 19			jp monitor 
19e8			 
19e8			.monedit: 
19e8				; get byte to load 
19e8			 
19e8 21 1d f0			ld hl,os_input+2 
19eb cd 60 10			call get_byte 
19ee			 
19ee				; get address to update 
19ee 2a 40 f1			ld hl, (os_cur_ptr) 
19f1			 
19f1				; update byte 
19f1			 
19f1 77				ld (hl), a 
19f2			 
19f2				; move to next address and save it 
19f2			 
19f2 23				inc hl 
19f3 22 40 f1			ld (os_cur_ptr),hl	 
19f6			 
19f6 c3 8d 19			jp monitor 
19f9			 
19f9			 
19f9 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a0d .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a29 .. 00		.monhelptext3:  db "Q-Quit",0 
1a30			        
1a30			.monhelp: 
1a30 3e 00			ld a, display_row_1 
1a32 11 f9 19		        ld de, .monhelptext1 
1a35			 
1a35 cd e8 0a			call str_at_display 
1a38 3e 28			ld a, display_row_2 
1a3a 11 0d 1a		        ld de, .monhelptext2 
1a3d					 
1a3d cd e8 0a			call str_at_display 
1a40 3e 50			ld a, display_row_3 
1a42 11 29 1a		        ld de, .monhelptext3 
1a45					 
1a45 cd e8 0a			call str_at_display 
1a48 cd f8 0a			call update_display		 
1a4b			 
1a4b cd 97 1b			call next_page_prompt 
1a4e c3 8d 19			jp monitor 
1a51			 
1a51			.mondump:    
1a51 21 1d f0			ld hl,os_input+2 
1a54 cd c0 10			call get_word_hl 
1a57			 
1a57 22 40 f1			ld (os_cur_ptr),hl	 
1a5a cd 9f 1a			call dumpcont 
1a5d 3e 78			ld a, display_row_4 
1a5f 11 39 19			ld de, endprog 
1a62			 
1a62 cd f8 0a			call update_display		 
1a65			 
1a65 cd 97 1b			call next_page_prompt 
1a68 c3 8d 19			jp monitor 
1a6b			.moncdump: 
1a6b cd 9f 1a			call dumpcont 
1a6e 3e 78			ld a, display_row_4 
1a70 11 39 19			ld de, endprog 
1a73			 
1a73 cd f8 0a			call update_display		 
1a76			 
1a76 cd 97 1b			call next_page_prompt 
1a79 c3 8d 19			jp monitor 
1a7c			 
1a7c			 
1a7c			; TODO symbol access  
1a7c			 
1a7c			.symbols:     ;; A list of symbols that can be called up  
1a7c bd fa			dw display_fb0 
1a7e .. 00			db "fb0",0  
1a82 62 f8		     	dw store_page 
1a84 .. 00			db "store_page",0 
1a8f			 
1a8f			 
1a8f			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a8f			 
1a8f 3a 1e ee			ld a,(scratch+1) 
1a92 fe 00			cp 0 
1a94 28 09			jr z, dumpcont 
1a96			 
1a96				; no, not a null term line so has an address to work out.... 
1a96			 
1a96 21 1f ee			ld hl,scratch+2 
1a99 cd c0 10			call get_word_hl 
1a9c			 
1a9c 22 40 f1			ld (os_cur_ptr),hl	 
1a9f			 
1a9f			 
1a9f			 
1a9f			dumpcont: 
1a9f			 
1a9f				; dump bytes at ptr 
1a9f			 
1a9f			 
1a9f 3e 00			ld a, display_row_1 
1aa1 2a d8 f8			ld hl, (display_fb_active) 
1aa4 cd 09 0d			call addatohl 
1aa7 cd cf 1a			call .dumpbyterow 
1aaa			 
1aaa 3e 28			ld a, display_row_2 
1aac 2a d8 f8			ld hl, (display_fb_active) 
1aaf cd 09 0d			call addatohl 
1ab2 cd cf 1a			call .dumpbyterow 
1ab5			 
1ab5			 
1ab5 3e 50			ld a, display_row_3 
1ab7 2a d8 f8			ld hl, (display_fb_active) 
1aba cd 09 0d			call addatohl 
1abd cd cf 1a			call .dumpbyterow 
1ac0			 
1ac0 3e 78			ld a, display_row_4 
1ac2 2a d8 f8			ld hl, (display_fb_active) 
1ac5 cd 09 0d			call addatohl 
1ac8 cd cf 1a			call .dumpbyterow 
1acb			 
1acb cd f8 0a			call update_display 
1ace			;		jp cli 
1ace c9				ret 
1acf			 
1acf			.dumpbyterow: 
1acf			 
1acf				;push af 
1acf			 
1acf e5				push hl 
1ad0			 
1ad0				; calc where to poke the ascii 
1ad0			if display_cols == 20 
1ad0				ld a, 16 
1ad0			else 
1ad0 3e 1f			ld a, 31 
1ad2			endif 
1ad2			 
1ad2 cd 09 0d			call addatohl 
1ad5 22 22 f1			ld (os_word_scratch),hl  		; save pos for later 
1ad8			 
1ad8			 
1ad8			; display decoding address 
1ad8 2a 40 f1		   	ld hl,(os_cur_ptr) 
1adb			 
1adb 7c				ld a,h 
1adc e1				pop hl 
1add e5				push hl 
1ade			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ade cd 0a 10			call hexout 
1ae1 2a 40 f1		   	ld hl,(os_cur_ptr) 
1ae4			 
1ae4 7d				ld a,l 
1ae5 e1				pop hl 
1ae6 23				inc hl 
1ae7 23				inc hl 
1ae8 e5				push hl 
1ae9			;	ld hl, os_word_scratch+2 
1ae9 cd 0a 10			call hexout 
1aec e1				pop hl 
1aed 23				inc hl 
1aee 23				inc hl 
1aef				;ld hl, os_word_scratch+4 
1aef 3e 3a			ld a, ':' 
1af1 77				ld (hl),a 
1af2 23				inc hl 
1af3				;ld a, 0 
1af3				;ld (hl),a 
1af3				;ld de, os_word_scratch 
1af3				;pop af 
1af3				;push af 
1af3			;		ld a, display_row_2 
1af3			;		call str_at_display 
1af3			;		call update_display 
1af3			 
1af3			 
1af3			;pop af 
1af3			;	add 5 
1af3			 
1af3			if display_cols == 20 
1af3				ld b, 4 
1af3			else 
1af3 06 08			ld b, 8 
1af5			endif	 
1af5			 
1af5			.dumpbyte: 
1af5 c5				push bc 
1af6 e5				push hl 
1af7			 
1af7			 
1af7 2a 40 f1		   	ld hl,(os_cur_ptr) 
1afa 7e					ld a,(hl) 
1afb			 
1afb					; poke the ascii to display 
1afb 2a 22 f1				ld hl,(os_word_scratch) 
1afe 77					ld (hl),a 
1aff 23					inc hl 
1b00 22 22 f1				ld (os_word_scratch),hl 
1b03			 
1b03					 
1b03			 
1b03			 
1b03 e1					pop hl 
1b04 e5					push hl 
1b05			 
1b05 cd 0a 10				call hexout 
1b08			 
1b08					 
1b08 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b0b 23				inc hl 
1b0c 22 40 f1		   	ld (os_cur_ptr),hl 
1b0f			 
1b0f e1					pop hl 
1b10 23					inc hl 
1b11 23					inc hl 
1b12 23					inc hl 
1b13			 
1b13			 
1b13			 
1b13					;ld a,0 
1b13					;ld (os_word_scratch+2),a 
1b13					;pop af 
1b13					;push af 
1b13			 
1b13					;ld de, os_word_scratch 
1b13					;call str_at_display 
1b13			;		call update_display 
1b13			;		pop af 
1b13 c1					pop bc 
1b14 c6 03				add 3 
1b16 10 dd			djnz .dumpbyte 
1b18			 
1b18				 
1b18			 
1b18 c9				ret 
1b19			 
1b19			jump:	 
1b19			 
1b19 21 1f ee			ld hl,scratch+2 
1b1c cd c0 10			call get_word_hl 
1b1f				;ld hl,(scratch+2) 
1b1f				;call fourehexhl 
1b1f			 
1b1f 22 40 f1			ld (os_cur_ptr),hl	 
1b22			 
1b22 e9				jp (hl) 
1b23			 
1b23			 
1b23			 
1b23			; TODO implement a basic monitor mode to start with 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			; testing and demo code during development 
1b23			 
1b23			 
1b23 .. 00		str1: db "Enter some text...",0 
1b36 .. 00		clear: db "                    ",0 
1b4b			 
1b4b			demo: 
1b4b			 
1b4b			 
1b4b			 
1b4b			;	call update_display 
1b4b			 
1b4b				; init scratch input area for testing 
1b4b 21 1d ee			ld hl, scratch	 
1b4e 3e 00			ld a,0 
1b50 77				ld (hl),a 
1b51			 
1b51			 
1b51 3e 28		            LD   A, display_row_2 
1b53			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b53 11 23 1b		            LD   DE, str1 
1b56 cd e8 0a			call str_at_display 
1b59			 
1b59			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b59			cloop:	 
1b59 3e 50		            LD   A, display_row_3 
1b5b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b5b 11 36 1b		            LD   DE, clear 
1b5e			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b5e cd e8 0a				call str_at_display 
1b61 3e 78			ld a, display_row_4 
1b63 11 93 1b			ld de, prompt 
1b66			 
1b66 cd e8 0a				call str_at_display 
1b69 cd f8 0a			call update_display 
1b6c			 
1b6c 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b6e 16 0a			ld d, 10 
1b70 21 1d ee			ld hl, scratch	 
1b73 cd 36 0d			call input_str 
1b76			 
1b76			;	call clear_display 
1b76			;'	call update_display 
1b76			 
1b76 3e 00		            LD   A, display_row_1 
1b78			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b78 11 36 1b		            LD   DE, clear 
1b7b cd e8 0a				call str_at_display 
1b7e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b7e 3e 00		            LD   A, display_row_1 
1b80			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b80 11 1d ee		            LD   DE, scratch 
1b83			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b83 cd e8 0a				call str_at_display 
1b86 cd f8 0a			call update_display 
1b89			 
1b89 3e 00				ld a,0 
1b8b 21 1d ee			ld hl, scratch 
1b8e 77				ld (hl),a 
1b8f			 
1b8f 00				nop 
1b90 c3 59 1b			jp cloop 
1b93			 
1b93			 
1b93			 
1b93			; OS Prompt 
1b93			 
1b93 .. 00		prompt: db ">",0 
1b95 .. 00		endprg: db "?",0 
1b97			 
1b97			 
1b97			; handy next page prompt 
1b97			next_page_prompt: 
1b97 e5				push hl 
1b98 d5				push de 
1b99 f5				push af 
1b9a c5				push bc 
1b9b			 
1b9b 3e 9f			ld a,display_row_4 + display_cols - 1 
1b9d 11 95 1b		        ld de, endprg 
1ba0 cd e8 0a			call str_at_display 
1ba3 cd f8 0a			call update_display 
1ba6 cd 3c 68			call cin_wait 
1ba9 c1				pop bc 
1baa f1				pop af 
1bab d1				pop de 
1bac e1				pop hl 
1bad			 
1bad			 
1bad c9				ret 
1bae			 
1bae			 
1bae			; forth parser 
1bae			 
1bae			; My forth kernel 
1bae			include "forth_kernel.asm" 
1bae			; 
1bae			; kernel to the forth OS 
1bae			 
1bae			DS_TYPE_STR: equ 1     ; string type 
1bae			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bae			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bae			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bae			 
1bae			FORTH_PARSEV1: equ 0 
1bae			FORTH_PARSEV2: equ 0 
1bae			FORTH_PARSEV3: equ 0 
1bae			FORTH_PARSEV4: equ 0 
1bae			FORTH_PARSEV5: equ 1 
1bae			 
1bae			;if FORTH_PARSEV5 
1bae			;	FORTH_END_BUFFER: equ 0 
1bae			;else 
1bae			FORTH_END_BUFFER: equ 127 
1bae			;endif 
1bae			 
1bae			FORTH_TRUE: equ 1 
1bae			FORTH_FALSE: equ 0 
1bae			 
1bae			if FORTH_PARSEV4 
1bae			include "forth_stackops.asm" 
1bae			endif 
1bae			 
1bae			if FORTH_PARSEV5 
1bae			include "forth_stackopsv5.asm" 
1bae			 
1bae			; Stack operations for v5 parser on wards 
1bae			; * DATA stack 
1bae			; * LOOP stack 
1bae			; * RETURN stack 
1bae			 
1bae			 
1bae			 
1bae			FORTH_CHK_DSP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_data_sp) 
1bae				ld de, cli_data_stack 
1bae				call cmp16 
1bae				jp c, fault_dsp_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			 
1bae			FORTH_CHK_RSP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_ret_sp) 
1bae				ld de, cli_ret_stack 
1bae				call cmp16 
1bae				jp c, fault_rsp_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			FORTH_CHK_LOOP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_loop_sp) 
1bae				ld de, cli_loop_stack 
1bae				call cmp16 
1bae				jp c, fault_loop_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			FORTH_ERR_TOS_NOTSTR: macro 
1bae				; TOSO might need more for checks when used 
1bae				push af 
1bae				ld a,(hl) 
1bae				cp DS_TYPE_STR 
1bae				jp nz, type_faultn   
1bae				pop af 
1bae				endm 
1bae			 
1bae			FORTH_ERR_TOS_NOTNUM: macro 
1bae				push af 
1bae				ld a,(hl) 
1bae				cp DS_TYPE_INUM 
1bae				jp nz, type_faultn   
1bae				pop af 
1bae				endm 
1bae			 
1bae			 
1bae			; increase data stack pointer and save hl to it 
1bae				 
1bae			FORTH_DSP_NEXT: macro 
1bae				call macro_forth_dsp_next 
1bae				endm 
1bae			 
1bae			 
1bae			macro_forth_dsp_next: 
1bae				if DEBUG_FORTH_STACK_GUARD 
1bae cd dd 62				call check_stacks 
1bb1				endif 
1bb1 e5				push hl 
1bb2 d5				push de 
1bb3 eb				ex de,hl 
1bb4 2a 0a f8			ld hl,(cli_data_sp) 
1bb7 23				inc hl 
1bb8 23				inc hl 
1bb9			 
1bb9			; PARSEV5 
1bb9 23				inc hl 
1bba 22 0a f8			ld (cli_data_sp),hl 
1bbd 73				ld (hl), e 
1bbe 23				inc hl 
1bbf 72				ld (hl), d 
1bc0 d1				pop de 
1bc1 e1				pop hl 
1bc2				if DEBUG_FORTH_STACK_GUARD 
1bc2 cd dd 62				call check_stacks 
1bc5				endif 
1bc5 c9				ret 
1bc6			 
1bc6			 
1bc6			; increase ret stack pointer and save hl to it 
1bc6				 
1bc6			FORTH_RSP_NEXT: macro 
1bc6				call macro_forth_rsp_next 
1bc6				endm 
1bc6			 
1bc6			macro_forth_rsp_next: 
1bc6				if DEBUG_FORTH_STACK_GUARD 
1bc6 cd dd 62				call check_stacks 
1bc9				endif 
1bc9 e5				push hl 
1bca d5				push de 
1bcb eb				ex de,hl 
1bcc 2a 0e f8			ld hl,(cli_ret_sp) 
1bcf 23				inc hl 
1bd0 23				inc hl 
1bd1 22 0e f8			ld (cli_ret_sp),hl 
1bd4 73				ld (hl), e 
1bd5 23				inc hl 
1bd6 72				ld (hl), d 
1bd7 d1				pop de 
1bd8 e1				pop hl 
1bd9				if DEBUG_FORTH_STACK_GUARD 
1bd9 cd dd 62				call check_stacks 
1bdc				endif 
1bdc c9				ret 
1bdd			 
1bdd			; get current ret stack pointer and save to hl  
1bdd				 
1bdd			FORTH_RSP_TOS: macro 
1bdd				call macro_forth_rsp_tos 
1bdd				endm 
1bdd			 
1bdd			macro_forth_rsp_tos: 
1bdd				;push de 
1bdd 2a 0e f8			ld hl,(cli_ret_sp) 
1be0 cd 18 1c			call loadhlptrtohl 
1be3				;ld e, (hl) 
1be3				;inc hl 
1be3				;ld d, (hl) 
1be3				;ex de, hl 
1be3					if DEBUG_FORTH_WORDS 
1be3			;			DMARK "RST" 
1be3						CALLMONITOR 
1be3 cd 92 16			call break_point_state  
1be6				endm  
# End of macro CALLMONITOR
1be6					endif 
1be6				;pop de 
1be6 c9				ret 
1be7			 
1be7			; pop ret stack pointer 
1be7				 
1be7			FORTH_RSP_POP: macro 
1be7				call macro_forth_rsp_pop 
1be7				endm 
1be7			 
1be7			 
1be7			macro_forth_rsp_pop: 
1be7				if DEBUG_FORTH_STACK_GUARD 
1be7			;		DMARK "RPP" 
1be7 cd dd 62				call check_stacks 
1bea					FORTH_CHK_RSP_UNDER 
1bea e5				push hl 
1beb d5				push de 
1bec 2a 0e f8			ld hl,(cli_ret_sp) 
1bef 11 88 f7			ld de, cli_ret_stack 
1bf2 cd 27 0d			call cmp16 
1bf5 da f1 63			jp c, fault_rsp_under 
1bf8 d1				pop de 
1bf9 e1				pop hl 
1bfa				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bfa				endif 
1bfa e5				push hl 
1bfb 2a 0e f8			ld hl,(cli_ret_sp) 
1bfe			 
1bfe			 
1bfe				if FORTH_ENABLE_FREE 
1bfe			 
1bfe					; get pointer 
1bfe			 
1bfe					push de 
1bfe					push hl 
1bfe			 
1bfe					ld e, (hl) 
1bfe					inc hl 
1bfe					ld d, (hl) 
1bfe			 
1bfe					ex de, hl 
1bfe					call free 
1bfe			 
1bfe					pop hl 
1bfe					pop de 
1bfe			 
1bfe			 
1bfe				endif 
1bfe			 
1bfe			 
1bfe 2b				dec hl 
1bff 2b				dec hl 
1c00 22 0e f8			ld (cli_ret_sp), hl 
1c03				; do stack underflow checks 
1c03 e1				pop hl 
1c04				if DEBUG_FORTH_STACK_GUARD 
1c04 cd dd 62				call check_stacks 
1c07					FORTH_CHK_RSP_UNDER 
1c07 e5				push hl 
1c08 d5				push de 
1c09 2a 0e f8			ld hl,(cli_ret_sp) 
1c0c 11 88 f7			ld de, cli_ret_stack 
1c0f cd 27 0d			call cmp16 
1c12 da f1 63			jp c, fault_rsp_under 
1c15 d1				pop de 
1c16 e1				pop hl 
1c17				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c17				endif 
1c17 c9				ret 
1c18			 
1c18			 
1c18			 
1c18			; routine to load word pointed to by hl into hl 
1c18			 
1c18			loadhlptrtohl: 
1c18			 
1c18 d5				push de 
1c19 5e				ld e, (hl) 
1c1a 23				inc hl 
1c1b 56				ld d, (hl) 
1c1c eb				ex de, hl 
1c1d d1				pop de 
1c1e			 
1c1e c9				ret 
1c1f			 
1c1f			 
1c1f			 
1c1f			 
1c1f			 
1c1f			; push a number held in HL onto the data stack 
1c1f			; entry point for pushing a value when already in hl used in function above 
1c1f			 
1c1f			forth_push_numhl: 
1c1f			 
1c1f e5				push hl    ; save value to push 
1c20			 
1c20			if DEBUG_FORTH_PUSH 
1c20				; see if disabled 
1c20			 
1c20			 
1c20 f5				push af 
1c21 3a 0e ee			ld a, (os_view_disable) 
1c24 fe 2a			cp '*' 
1c26 28 34			jr z, .pskip2 
1c28 e5				push hl 
1c29 e5			push hl 
1c2a cd d5 0a			call clear_display 
1c2d e1			pop hl 
1c2e 7c				ld a,h 
1c2f 21 22 f1			ld hl, os_word_scratch 
1c32 cd 0a 10			call hexout 
1c35 e1				pop hl 
1c36 7d				ld a,l 
1c37 21 24 f1			ld hl, os_word_scratch+2 
1c3a cd 0a 10			call hexout 
1c3d			 
1c3d 21 26 f1			ld hl, os_word_scratch+4 
1c40 3e 00			ld a,0 
1c42 77				ld (hl),a 
1c43 11 22 f1			ld de,os_word_scratch 
1c46 3e 28				ld a, display_row_2 
1c48 cd e8 0a				call str_at_display 
1c4b 11 eb 51			ld de, .push_num 
1c4e 3e 00			ld a, display_row_1 
1c50			 
1c50 cd e8 0a				call str_at_display 
1c53			 
1c53			 
1c53 cd f8 0a			call update_display 
1c56 cd 55 0a			call delay1s 
1c59 cd 55 0a			call delay1s 
1c5c			.pskip2:  
1c5c			 
1c5c f1				pop af 
1c5d			endif	 
1c5d			 
1c5d			 
1c5d				FORTH_DSP_NEXT 
1c5d cd ae 1b			call macro_forth_dsp_next 
1c60				endm 
# End of macro FORTH_DSP_NEXT
1c60			 
1c60 2a 0a f8			ld hl, (cli_data_sp) 
1c63			 
1c63				; save item type 
1c63 3e 02			ld a,  DS_TYPE_INUM 
1c65 77				ld (hl), a 
1c66 23				inc hl 
1c67			 
1c67				; get word off stack 
1c67 d1				pop de 
1c68 7b				ld a,e 
1c69 77				ld (hl), a 
1c6a 23				inc hl 
1c6b 7a				ld a,d 
1c6c 77				ld (hl), a 
1c6d			 
1c6d			if DEBUG_FORTH_PUSH 
1c6d 2b				dec hl 
1c6e 2b				dec hl 
1c6f 2b				dec hl 
1c70						DMARK "PH5" 
1c70 f5				push af  
1c71 3a 85 1c			ld a, (.dmark)  
1c74 32 77 fb			ld (debug_mark),a  
1c77 3a 86 1c			ld a, (.dmark+1)  
1c7a 32 78 fb			ld (debug_mark+1),a  
1c7d 3a 87 1c			ld a, (.dmark+2)  
1c80 32 79 fb			ld (debug_mark+2),a  
1c83 18 03			jr .pastdmark  
1c85 ..			.dmark: db "PH5"  
1c88 f1			.pastdmark: pop af  
1c89			endm  
# End of macro DMARK
1c89				CALLMONITOR 
1c89 cd 92 16			call break_point_state  
1c8c				endm  
# End of macro CALLMONITOR
1c8c			endif	 
1c8c			 
1c8c c9				ret 
1c8d			 
1c8d			 
1c8d			; Push a string to stack pointed to by hl 
1c8d			 
1c8d			forth_push_str: 
1c8d			 
1c8d			if DEBUG_FORTH_PUSH 
1c8d						DMARK "PSQ" 
1c8d f5				push af  
1c8e 3a a2 1c			ld a, (.dmark)  
1c91 32 77 fb			ld (debug_mark),a  
1c94 3a a3 1c			ld a, (.dmark+1)  
1c97 32 78 fb			ld (debug_mark+1),a  
1c9a 3a a4 1c			ld a, (.dmark+2)  
1c9d 32 79 fb			ld (debug_mark+2),a  
1ca0 18 03			jr .pastdmark  
1ca2 ..			.dmark: db "PSQ"  
1ca5 f1			.pastdmark: pop af  
1ca6			endm  
# End of macro DMARK
1ca6				CALLMONITOR 
1ca6 cd 92 16			call break_point_state  
1ca9				endm  
# End of macro CALLMONITOR
1ca9			endif	 
1ca9			    
1ca9 e5				push hl 
1caa e5				push hl 
1cab			 
1cab			;	ld a, 0   ; find end of string 
1cab cd 67 11			call strlenz 
1cae			if DEBUG_FORTH_PUSH 
1cae						DMARK "PQ2" 
1cae f5				push af  
1caf 3a c3 1c			ld a, (.dmark)  
1cb2 32 77 fb			ld (debug_mark),a  
1cb5 3a c4 1c			ld a, (.dmark+1)  
1cb8 32 78 fb			ld (debug_mark+1),a  
1cbb 3a c5 1c			ld a, (.dmark+2)  
1cbe 32 79 fb			ld (debug_mark+2),a  
1cc1 18 03			jr .pastdmark  
1cc3 ..			.dmark: db "PQ2"  
1cc6 f1			.pastdmark: pop af  
1cc7			endm  
# End of macro DMARK
1cc7				CALLMONITOR 
1cc7 cd 92 16			call break_point_state  
1cca				endm  
# End of macro CALLMONITOR
1cca			endif	 
1cca eb				ex de, hl 
1ccb e1				pop hl   ; get ptr to start of string 
1ccc			if DEBUG_FORTH_PUSH 
1ccc						DMARK "PQ3" 
1ccc f5				push af  
1ccd 3a e1 1c			ld a, (.dmark)  
1cd0 32 77 fb			ld (debug_mark),a  
1cd3 3a e2 1c			ld a, (.dmark+1)  
1cd6 32 78 fb			ld (debug_mark+1),a  
1cd9 3a e3 1c			ld a, (.dmark+2)  
1cdc 32 79 fb			ld (debug_mark+2),a  
1cdf 18 03			jr .pastdmark  
1ce1 ..			.dmark: db "PQ3"  
1ce4 f1			.pastdmark: pop af  
1ce5			endm  
# End of macro DMARK
1ce5				CALLMONITOR 
1ce5 cd 92 16			call break_point_state  
1ce8				endm  
# End of macro CALLMONITOR
1ce8			endif	 
1ce8 19				add hl,de 
1ce9			if DEBUG_FORTH_PUSH 
1ce9						DMARK "PQE" 
1ce9 f5				push af  
1cea 3a fe 1c			ld a, (.dmark)  
1ced 32 77 fb			ld (debug_mark),a  
1cf0 3a ff 1c			ld a, (.dmark+1)  
1cf3 32 78 fb			ld (debug_mark+1),a  
1cf6 3a 00 1d			ld a, (.dmark+2)  
1cf9 32 79 fb			ld (debug_mark+2),a  
1cfc 18 03			jr .pastdmark  
1cfe ..			.dmark: db "PQE"  
1d01 f1			.pastdmark: pop af  
1d02			endm  
# End of macro DMARK
1d02				CALLMONITOR 
1d02 cd 92 16			call break_point_state  
1d05				endm  
# End of macro CALLMONITOR
1d05			endif	 
1d05			 
1d05 2b				dec hl    ; see if there is an optional trailing double quote 
1d06 7e				ld a,(hl) 
1d07 fe 22			cp '"' 
1d09 20 03			jr nz, .strnoq 
1d0b 3e 00			ld a, 0      ; get rid of double quote 
1d0d 77				ld (hl), a 
1d0e 23			.strnoq: inc hl 
1d0f			 
1d0f 3e 00			ld a, 0 
1d11 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d12			 
1d12 13				inc de ; add one for the type string 
1d13 13				inc de ; add one for null term??? 
1d14			 
1d14				; tos is get string pointer again 
1d14				; de contains space to allocate 
1d14				 
1d14 d5				push de 
1d15			 
1d15 eb				ex de, hl 
1d16			 
1d16				;push af 
1d16			 
1d16			if DEBUG_FORTH_PUSH 
1d16						DMARK "PHm" 
1d16 f5				push af  
1d17 3a 2b 1d			ld a, (.dmark)  
1d1a 32 77 fb			ld (debug_mark),a  
1d1d 3a 2c 1d			ld a, (.dmark+1)  
1d20 32 78 fb			ld (debug_mark+1),a  
1d23 3a 2d 1d			ld a, (.dmark+2)  
1d26 32 79 fb			ld (debug_mark+2),a  
1d29 18 03			jr .pastdmark  
1d2b ..			.dmark: db "PHm"  
1d2e f1			.pastdmark: pop af  
1d2f			endm  
# End of macro DMARK
1d2f				CALLMONITOR 
1d2f cd 92 16			call break_point_state  
1d32				endm  
# End of macro CALLMONITOR
1d32			endif	 
1d32 cd d0 11			call malloc	; on ret hl now contains allocated memory 
1d35				if DEBUG_FORTH_MALLOC_GUARD 
1d35 cc 43 52				call z,malloc_error 
1d38				endif 
1d38			 
1d38				 
1d38 c1				pop bc    ; get length 
1d39 d1				pop de   ;  get string start    
1d3a			 
1d3a				; hl has destination from malloc 
1d3a			 
1d3a eb				ex de, hl    ; prep for ldir 
1d3b			 
1d3b d5				push de   ; save malloc area for DSP later 
1d3c				;push hl   ; save malloc area for DSP later 
1d3c			 
1d3c			if DEBUG_FORTH_PUSH 
1d3c						DMARK "PHc" 
1d3c f5				push af  
1d3d 3a 51 1d			ld a, (.dmark)  
1d40 32 77 fb			ld (debug_mark),a  
1d43 3a 52 1d			ld a, (.dmark+1)  
1d46 32 78 fb			ld (debug_mark+1),a  
1d49 3a 53 1d			ld a, (.dmark+2)  
1d4c 32 79 fb			ld (debug_mark+2),a  
1d4f 18 03			jr .pastdmark  
1d51 ..			.dmark: db "PHc"  
1d54 f1			.pastdmark: pop af  
1d55			endm  
# End of macro DMARK
1d55				CALLMONITOR 
1d55 cd 92 16			call break_point_state  
1d58				endm  
# End of macro CALLMONITOR
1d58			endif	 
1d58			 
1d58			 
1d58 ed b0			ldir 
1d5a			 
1d5a			 
1d5a				; push malloc to data stack     macro?????  
1d5a			 
1d5a				FORTH_DSP_NEXT 
1d5a cd ae 1b			call macro_forth_dsp_next 
1d5d				endm 
# End of macro FORTH_DSP_NEXT
1d5d			 
1d5d				; save value and type 
1d5d			 
1d5d 2a 0a f8			ld hl, (cli_data_sp) 
1d60			 
1d60				; save item type 
1d60 3e 01			ld a,  DS_TYPE_STR 
1d62 77				ld (hl), a 
1d63 23				inc hl 
1d64			 
1d64				; get malloc word off stack 
1d64 d1				pop de 
1d65 73				ld (hl), e 
1d66 23				inc hl 
1d67 72				ld (hl), d 
1d68			 
1d68			 
1d68			 
1d68			if DEBUG_FORTH_PUSH 
1d68 2a 0a f8			ld hl, (cli_data_sp) 
1d6b						DMARK "PHS" 
1d6b f5				push af  
1d6c 3a 80 1d			ld a, (.dmark)  
1d6f 32 77 fb			ld (debug_mark),a  
1d72 3a 81 1d			ld a, (.dmark+1)  
1d75 32 78 fb			ld (debug_mark+1),a  
1d78 3a 82 1d			ld a, (.dmark+2)  
1d7b 32 79 fb			ld (debug_mark+2),a  
1d7e 18 03			jr .pastdmark  
1d80 ..			.dmark: db "PHS"  
1d83 f1			.pastdmark: pop af  
1d84			endm  
# End of macro DMARK
1d84				CALLMONITOR 
1d84 cd 92 16			call break_point_state  
1d87				endm  
# End of macro CALLMONITOR
1d87			;	ex de,hl 
1d87			endif	 
1d87				; in case of spaces, skip the ptr past the copied string 
1d87				;pop af 
1d87				;ld (cli_origptr),hl 
1d87			 
1d87 c9				ret 
1d88			 
1d88			 
1d88			 
1d88			; TODO ascii push input onto stack given hl to start of input 
1d88			 
1d88			; identify type 
1d88			; if starts with a " then a string 
1d88			; otherwise it is a number 
1d88			;  
1d88			; if a string 
1d88			;     scan for ending " to get length of string to malloc for + 1 
1d88			;     malloc 
1d88			;     put pointer to string on stack first byte flags as string 
1d88			; 
1d88			; else a number 
1d88			;    look for number format identifier 
1d88			;    $xx hex 
1d88			;    %xxxxx bin 
1d88			;    xxxxx decimal 
1d88			;    convert number to 16bit word.  
1d88			;    malloc word + 1 with flag to identiy as num 
1d88			;    put pointer to number on stack 
1d88			;   
1d88			;  
1d88			  
1d88			forth_apush: 
1d88				; kernel push 
1d88			 
1d88			if DEBUG_FORTH_PUSH 
1d88						DMARK "PSH" 
1d88 f5				push af  
1d89 3a 9d 1d			ld a, (.dmark)  
1d8c 32 77 fb			ld (debug_mark),a  
1d8f 3a 9e 1d			ld a, (.dmark+1)  
1d92 32 78 fb			ld (debug_mark+1),a  
1d95 3a 9f 1d			ld a, (.dmark+2)  
1d98 32 79 fb			ld (debug_mark+2),a  
1d9b 18 03			jr .pastdmark  
1d9d ..			.dmark: db "PSH"  
1da0 f1			.pastdmark: pop af  
1da1			endm  
# End of macro DMARK
1da1				CALLMONITOR 
1da1 cd 92 16			call break_point_state  
1da4				endm  
# End of macro CALLMONITOR
1da4			endif	 
1da4				; identify input type 
1da4			 
1da4 7e				ld a,(hl) 
1da5 fe 22			cp '"' 
1da7 28 0a			jr z, .fapstr 
1da9 fe 24			cp '$' 
1dab ca d3 1d			jp z, .faphex 
1dae fe 25			cp '%' 
1db0 ca bb 1d			jp z, .fapbin 
1db3			;	cp 'b' 
1db3			;	jp z, .fabin 
1db3				; else decimal 
1db3			 
1db3				; TODO do decimal conversion 
1db3				; decimal is stored as a 16bit word 
1db3			 
1db3				; by default everything is a string if type is not detected 
1db3			.fapstr: ; 
1db3 fe 22			cp '"' 
1db5 20 01			jr nz, .strnoqu 
1db7 23				inc hl 
1db8			.strnoqu: 
1db8 c3 8d 1c			jp forth_push_str 
1dbb			 
1dbb			 
1dbb			 
1dbb			.fapbin:    ; push a binary string.  
1dbb 11 00 00			ld de, 0   ; hold a 16bit value 
1dbe			 
1dbe 23			.fapbinshift:	inc hl  
1dbf 7e				ld a,(hl) 
1dc0 fe 00			cp 0     ; done scanning  
1dc2 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dc4			 
1dc4				; left shift de 
1dc4 eb				ex de, hl	 
1dc5 29				add hl, hl 
1dc6			 
1dc6				; is 1 
1dc6 fe 31			cp '1' 
1dc8 20 02			jr nz, .binzero 
1dca cb 4d			bit 1, l 
1dcc			.binzero: 
1dcc eb				ex de, hl	 ; save current de 
1dcd 18 ef			jr .fapbinshift 
1dcf			 
1dcf			.fapbdone: 
1dcf eb				ex de, hl 
1dd0 c3 1f 1c			jp forth_push_numhl 
1dd3			 
1dd3			 
1dd3			.faphex:   ; hex is always stored as a 16bit word 
1dd3				; skip number prefix 
1dd3 23				inc hl 
1dd4				; turn ascii into number 
1dd4 cd c0 10			call get_word_hl	; ret 16bit word in hl 
1dd7			 
1dd7 c3 1f 1c			jp forth_push_numhl 
1dda			 
1dda 00				 nop 
1ddb			 
1ddb			.fabin:   ; TODO bin conversion 
1ddb			 
1ddb			 
1ddb c9				ret 
1ddc			 
1ddc			 
1ddc			; get either a string ptr or a 16bit word from the data stack 
1ddc			 
1ddc			FORTH_DSP: macro 
1ddc				call macro_forth_dsp 
1ddc				endm 
1ddc			 
1ddc			macro_forth_dsp: 
1ddc				; data stack pointer points to current word on tos 
1ddc			 
1ddc 2a 0a f8			ld hl,(cli_data_sp) 
1ddf			 
1ddf				if DEBUG_FORTH_PUSH 
1ddf						DMARK "DSP" 
1ddf f5				push af  
1de0 3a f4 1d			ld a, (.dmark)  
1de3 32 77 fb			ld (debug_mark),a  
1de6 3a f5 1d			ld a, (.dmark+1)  
1de9 32 78 fb			ld (debug_mark+1),a  
1dec 3a f6 1d			ld a, (.dmark+2)  
1def 32 79 fb			ld (debug_mark+2),a  
1df2 18 03			jr .pastdmark  
1df4 ..			.dmark: db "DSP"  
1df7 f1			.pastdmark: pop af  
1df8			endm  
# End of macro DMARK
1df8			 
1df8 cd 78 52				call display_data_sp 
1dfb				;call break_point_state 
1dfb				;rst 030h 
1dfb				CALLMONITOR 
1dfb cd 92 16			call break_point_state  
1dfe				endm  
# End of macro CALLMONITOR
1dfe				endif 
1dfe			 
1dfe c9				ret 
1dff			 
1dff			; return hl to start of value on stack 
1dff			 
1dff			FORTH_DSP_VALUE: macro 
1dff				call macro_forth_dsp_value 
1dff				endm 
1dff			 
1dff			macro_forth_dsp_value: 
1dff			 
1dff				FORTH_DSP 
1dff cd dc 1d			call macro_forth_dsp 
1e02				endm 
# End of macro FORTH_DSP
1e02			 
1e02 d5				push de 
1e03			 
1e03 23				inc hl ; skip type 
1e04			 
1e04 5e				ld e, (hl) 
1e05 23				inc hl 
1e06 56				ld d, (hl) 
1e07 eb				ex de,hl  
1e08			 
1e08 d1				pop de 
1e09			 
1e09 c9				ret 
1e0a			 
1e0a			; return hl to start of value to second item on stack 
1e0a			 
1e0a			FORTH_DSP_VALUEM1: macro 
1e0a				call macro_forth_dsp_value_m1 
1e0a				endm 
1e0a			 
1e0a			macro_forth_dsp_value_m1: 
1e0a			 
1e0a				FORTH_DSP 
1e0a cd dc 1d			call macro_forth_dsp 
1e0d				endm 
# End of macro FORTH_DSP
1e0d			 
1e0d 2b				dec hl 
1e0e 2b				dec hl 
1e0f			;	dec hl 
1e0f			 
1e0f d5				push de 
1e10			 
1e10 5e				ld e, (hl) 
1e11 23				inc hl 
1e12 56				ld d, (hl) 
1e13 eb				ex de,hl  
1e14			 
1e14 d1				pop de 
1e15			 
1e15 c9				ret 
1e16			 
1e16				 
1e16			 
1e16			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e16			 
1e16			FORTH_DSP_POP: macro 
1e16				call macro_forth_dsp_pop 
1e16				endm 
1e16			 
1e16			 
1e16			; get the tos data type 
1e16			 
1e16			FORTH_DSP_TYPE:   macro 
1e16			 
1e16				;FORTH_DSP_VALUE 
1e16				FORTH_DSP 
1e16				 
1e16				; hl points to value 
1e16				; check type 
1e16			 
1e16				ld a,(hl) 
1e16			 
1e16				endm 
1e16			 
1e16			; load the tos value into hl 
1e16			 
1e16			 
1e16			FORTH_DSP_VALUEHL:  macro 
1e16				call macro_dsp_valuehl 
1e16				endm 
1e16			 
1e16			 
1e16			 
1e16			macro_dsp_valuehl: 
1e16				FORTH_DSP_VALUE 
1e16 cd ff 1d			call macro_forth_dsp_value 
1e19				endm 
# End of macro FORTH_DSP_VALUE
1e19			 
1e19				;FORTH_ERR_TOS_NOTNUM 
1e19			 
1e19				;inc hl   ; skip type id 
1e19			 
1e19			;	push de 
1e19			; 
1e19			;	ld e, (hl) 
1e19			;	inc hl 
1e19			;	ld d, (hl) 
1e19			;	ex de,hl  
1e19			 
1e19			;	pop de 
1e19			 
1e19				if DEBUG_FORTH_PUSH 
1e19						DMARK "DVL" 
1e19 f5				push af  
1e1a 3a 2e 1e			ld a, (.dmark)  
1e1d 32 77 fb			ld (debug_mark),a  
1e20 3a 2f 1e			ld a, (.dmark+1)  
1e23 32 78 fb			ld (debug_mark+1),a  
1e26 3a 30 1e			ld a, (.dmark+2)  
1e29 32 79 fb			ld (debug_mark+2),a  
1e2c 18 03			jr .pastdmark  
1e2e ..			.dmark: db "DVL"  
1e31 f1			.pastdmark: pop af  
1e32			endm  
# End of macro DMARK
1e32				CALLMONITOR 
1e32 cd 92 16			call break_point_state  
1e35				endm  
# End of macro CALLMONITOR
1e35				endif 
1e35 c9				ret 
1e36			 
1e36			forth_apushstrhl:      
1e36				; push of string requires use of cli_origptr 
1e36				; bodge use 
1e36			 
1e36				; get current cli_origptr, save, update with temp pointer  
1e36 ed 5b 26 f8		ld de, (cli_origptr) 
1e3a 22 26 f8			ld (cli_origptr), hl 
1e3d d5				push de 
1e3e cd 88 1d			call forth_apush 
1e41 d1				pop de 
1e42 ed 53 26 f8		ld (cli_origptr), de 
1e46 c9			        ret	 
1e47			 
1e47			 
1e47			; increase loop stack pointer and save hl to it 
1e47				 
1e47			FORTH_LOOP_NEXT: macro 
1e47				call macro_forth_loop_next 
1e47				;nop 
1e47				endm 
1e47			 
1e47			macro_forth_loop_next: 
1e47				if DEBUG_FORTH_STACK_GUARD 
1e47 cd dd 62				call check_stacks 
1e4a				endif 
1e4a e5				push hl 
1e4b d5				push de 
1e4c eb				ex de,hl 
1e4d 2a 0c f8			ld hl,(cli_loop_sp) 
1e50 23				inc hl 
1e51 23				inc hl 
1e52					if DEBUG_FORTH_WORDS 
1e52						DMARK "LNX" 
1e52 f5				push af  
1e53 3a 67 1e			ld a, (.dmark)  
1e56 32 77 fb			ld (debug_mark),a  
1e59 3a 68 1e			ld a, (.dmark+1)  
1e5c 32 78 fb			ld (debug_mark+1),a  
1e5f 3a 69 1e			ld a, (.dmark+2)  
1e62 32 79 fb			ld (debug_mark+2),a  
1e65 18 03			jr .pastdmark  
1e67 ..			.dmark: db "LNX"  
1e6a f1			.pastdmark: pop af  
1e6b			endm  
# End of macro DMARK
1e6b						CALLMONITOR 
1e6b cd 92 16			call break_point_state  
1e6e				endm  
# End of macro CALLMONITOR
1e6e					endif 
1e6e 22 0c f8			ld (cli_loop_sp),hl 
1e71 73				ld (hl), e 
1e72 23				inc hl 
1e73 72				ld (hl), d 
1e74 d1				pop de    ; been reversed so save a swap on restore 
1e75 e1				pop hl 
1e76				if DEBUG_FORTH_STACK_GUARD 
1e76 cd dd 62				call check_stacks 
1e79				endif 
1e79 c9				ret 
1e7a			 
1e7a			; get current ret stack pointer and save to hl  
1e7a				 
1e7a			FORTH_LOOP_TOS: macro 
1e7a				call macro_forth_loop_tos 
1e7a				endm 
1e7a			 
1e7a			macro_forth_loop_tos: 
1e7a d5				push de 
1e7b 2a 0c f8			ld hl,(cli_loop_sp) 
1e7e 5e				ld e, (hl) 
1e7f 23				inc hl 
1e80 56				ld d, (hl) 
1e81 eb				ex de, hl 
1e82 d1				pop de 
1e83 c9				ret 
1e84			 
1e84			; pop loop stack pointer 
1e84				 
1e84			FORTH_LOOP_POP: macro 
1e84				call macro_forth_loop_pop 
1e84				endm 
1e84			 
1e84			 
1e84			macro_forth_loop_pop: 
1e84				if DEBUG_FORTH_STACK_GUARD 
1e84					DMARK "LPP" 
1e84 f5				push af  
1e85 3a 99 1e			ld a, (.dmark)  
1e88 32 77 fb			ld (debug_mark),a  
1e8b 3a 9a 1e			ld a, (.dmark+1)  
1e8e 32 78 fb			ld (debug_mark+1),a  
1e91 3a 9b 1e			ld a, (.dmark+2)  
1e94 32 79 fb			ld (debug_mark+2),a  
1e97 18 03			jr .pastdmark  
1e99 ..			.dmark: db "LPP"  
1e9c f1			.pastdmark: pop af  
1e9d			endm  
# End of macro DMARK
1e9d cd dd 62				call check_stacks 
1ea0					FORTH_CHK_LOOP_UNDER 
1ea0 e5				push hl 
1ea1 d5				push de 
1ea2 2a 0c f8			ld hl,(cli_loop_sp) 
1ea5 11 86 f5			ld de, cli_loop_stack 
1ea8 cd 27 0d			call cmp16 
1eab da f7 63			jp c, fault_loop_under 
1eae d1				pop de 
1eaf e1				pop hl 
1eb0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1eb0				endif 
1eb0 e5				push hl 
1eb1 2a 0c f8			ld hl,(cli_loop_sp) 
1eb4 2b				dec hl 
1eb5 2b				dec hl 
1eb6 22 0c f8			ld (cli_loop_sp), hl 
1eb9				; TODO do stack underflow checks 
1eb9 e1				pop hl 
1eba				if DEBUG_FORTH_STACK_GUARD 
1eba cd dd 62				call check_stacks 
1ebd					FORTH_CHK_LOOP_UNDER 
1ebd e5				push hl 
1ebe d5				push de 
1ebf 2a 0c f8			ld hl,(cli_loop_sp) 
1ec2 11 86 f5			ld de, cli_loop_stack 
1ec5 cd 27 0d			call cmp16 
1ec8 da f7 63			jp c, fault_loop_under 
1ecb d1				pop de 
1ecc e1				pop hl 
1ecd				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ecd				endif 
1ecd c9				ret 
1ece			 
1ece			macro_forth_dsp_pop: 
1ece			 
1ece e5				push hl 
1ecf			 
1ecf				; release malloc data 
1ecf			 
1ecf				if DEBUG_FORTH_STACK_GUARD 
1ecf cd dd 62				call check_stacks 
1ed2					FORTH_CHK_DSP_UNDER 
1ed2 e5				push hl 
1ed3 d5				push de 
1ed4 2a 0a f8			ld hl,(cli_data_sp) 
1ed7 11 84 f3			ld de, cli_data_stack 
1eda cd 27 0d			call cmp16 
1edd da eb 63			jp c, fault_dsp_under 
1ee0 d1				pop de 
1ee1 e1				pop hl 
1ee2				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ee2				endif 
1ee2				;ld hl,(cli_data_sp) 
1ee2			if DEBUG_FORTH_DOT 
1ee2				DMARK "DPP" 
1ee2				CALLMONITOR 
1ee2			endif	 
1ee2			 
1ee2			 
1ee2			if FORTH_ENABLE_DSPPOPFREE 
1ee2			 
1ee2				FORTH_DSP 
1ee2 cd dc 1d			call macro_forth_dsp 
1ee5				endm 
# End of macro FORTH_DSP
1ee5			 
1ee5 7e				ld a, (hl) 
1ee6 fe 01			cp DS_TYPE_STR 
1ee8 20 07			jr nz, .skippopfree 
1eea			 
1eea				FORTH_DSP_VALUEHL 
1eea cd 16 1e			call macro_dsp_valuehl 
1eed				endm 
# End of macro FORTH_DSP_VALUEHL
1eed 00				nop 
1eee			if DEBUG_FORTH_DOT 
1eee				DMARK "DPf" 
1eee				CALLMONITOR 
1eee			endif	 
1eee cd 9a 12			call free 
1ef1			.skippopfree: 
1ef1				 
1ef1			 
1ef1			endif 
1ef1			 
1ef1			if DEBUG_FORTH_DOT_KEY 
1ef1				DMARK "DP2" 
1ef1				CALLMONITOR 
1ef1			endif	 
1ef1			 
1ef1				; move pointer down 
1ef1			 
1ef1 2a 0a f8			ld hl,(cli_data_sp) 
1ef4 2b				dec hl 
1ef5 2b				dec hl 
1ef6			; PARSEV5 
1ef6 2b				dec hl 
1ef7 22 0a f8			ld (cli_data_sp), hl 
1efa			 
1efa				if DEBUG_FORTH_STACK_GUARD 
1efa cd dd 62				call check_stacks 
1efd					FORTH_CHK_DSP_UNDER 
1efd e5				push hl 
1efe d5				push de 
1eff 2a 0a f8			ld hl,(cli_data_sp) 
1f02 11 84 f3			ld de, cli_data_stack 
1f05 cd 27 0d			call cmp16 
1f08 da eb 63			jp c, fault_dsp_under 
1f0b d1				pop de 
1f0c e1				pop hl 
1f0d				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f0d				endif 
1f0d			 
1f0d e1				pop hl 
1f0e			 
1f0e c9				ret 
1f0f			 
1f0f			getwordathl: 
1f0f				; hl points to an address 
1f0f				; load hl with the word at that address 
1f0f			 
1f0f d5				push de 
1f10			 
1f10 5e				ld e, (hl) 
1f11 23				inc hl 
1f12 56				ld d, (hl) 
1f13 eb				ex de, hl 
1f14			 
1f14 d1				pop de 
1f15 c9				ret 
1f16			 
1f16			 
1f16			 
1f16			 
1f16			 
1f16			; eof 
1f16			 
# End of file forth_stackopsv5.asm
1f16			endif 
1f16			 
1f16			user_word_eol:  
1f16				; hl contains the pointer to where to create a linked list item from the end 
1f16				; of the user dict to continue on at the system word dict 
1f16				 
1f16				; poke the stub of the word list linked list to repoint to rom words 
1f16			 
1f16				; stub format 
1f16				; db   word id 
1f16				; dw    link to next word 
1f16			        ; db char length of token 
1f16				; db string + 0 term 
1f16				; db exec code....  
1f16			 
1f16 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f18 77				ld (hl), a		; word id 
1f19 23				inc hl 
1f1a			 
1f1a 11 e0 20			ld de, sysdict 
1f1d 73				ld (hl), e		; next word link ie system dict 
1f1e 23				inc hl 
1f1f 72				ld (hl), d		; next word link ie system dict 
1f20 23				inc hl	 
1f21			 
1f21			;	ld (hl), sysdict		; next word link ie system dict 
1f21			;	inc hl 
1f21			;	inc hl 
1f21			 
1f21			;	inc hl 
1f21			;	inc hl 
1f21			 
1f21 3e 02			ld a, 2			; word length is 0 
1f23 77				ld (hl), a	 
1f24 23				inc hl 
1f25			 
1f25 3e 7e			ld a, '~'			; word length is 0 
1f27 77				ld (hl), a	 
1f28 23				inc hl 
1f29 3e 00			ld a, 0			; save empty word 
1f2b 77				ld (hl), a 
1f2c			 
1f2c c9				ret 
1f2d			 
1f2d				 
1f2d			 
1f2d			forthexec_cleanup: 
1f2d				FORTH_RSP_POP 
1f2d cd e7 1b			call macro_forth_rsp_pop 
1f30				endm 
# End of macro FORTH_RSP_POP
1f30 c9				ret 
1f31			 
1f31			forth_call_hl: 
1f31				; taking hl 
1f31 e5				push hl 
1f32 c9				ret 
1f33			 
1f33			; this is called to reset Forth system but keep existing uwords etc 
1f33			 
1f33			forth_warmstart: 
1f33				; setup stack over/under flow checks 
1f33				if DEBUG_FORTH_STACK_GUARD 
1f33 cd c3 62				call chk_stk_init 
1f36				endif 
1f36			 
1f36				; init stack pointers  - * these stacks go upwards *  
1f36 21 88 f7			ld hl, cli_ret_stack 
1f39 22 0e f8			ld (cli_ret_sp), hl	 
1f3c				; set bottom of stack 
1f3c 3e 00			ld a,0 
1f3e 77				ld (hl),a 
1f3f 23				inc hl 
1f40 77				ld (hl),a 
1f41			 
1f41 21 84 f3			ld hl, cli_data_stack 
1f44 22 0a f8			ld (cli_data_sp), hl	 
1f47				; set bottom of stack 
1f47 3e 00			ld a,0 
1f49 77				ld (hl),a 
1f4a 23				inc hl 
1f4b 77				ld (hl),a 
1f4c			 
1f4c 21 86 f5			ld hl, cli_loop_stack 
1f4f 22 0c f8			ld (cli_loop_sp), hl	 
1f52				; set bottom of stack 
1f52 3e 00			ld a,0 
1f54 77				ld (hl),a 
1f55 23				inc hl 
1f56 77				ld (hl),a 
1f57			 
1f57				; init extent of current open file 
1f57			 
1f57 3e 00			ld a, 0 
1f59 32 59 f8			ld (store_openext), a 
1f5c			 
1f5c c9				ret 
1f5d			 
1f5d			 
1f5d			; Cold Start - this is called to setup the whole Forth system 
1f5d			 
1f5d			forth_init: 
1f5d			 
1f5d				; setup stack over/under flow checks 
1f5d			 
1f5d			;	if DEBUG_FORTH_STACK_GUARD 
1f5d			;		call chk_stk_init 
1f5d			;	endif 
1f5d			 
1f5d				; enable auto display updates (slow.....) 
1f5d			 
1f5d 3e 01			ld a, 1 
1f5f 32 24 f8			ld (cli_autodisplay), a 
1f62			 
1f62			 
1f62			 
1f62				; show start up screen 
1f62			 
1f62 cd d5 0a			call clear_display 
1f65			 
1f65 3e 00			ld a,0 
1f67 32 46 f8			ld (f_cursor_ptr), a 
1f6a			 
1f6a				; set start of word list in start of ram - for use when creating user words 
1f6a			 
1f6a 21 00 80			ld hl, baseram 
1f6d 22 1a f1			ld (os_last_new_uword), hl 
1f70 cd 16 1f			call user_word_eol 
1f73				 
1f73			;		call display_data_sp 
1f73			;		call next_page_prompt 
1f73			 
1f73			 
1f73			 
1f73			 
1f73 c9				ret 
1f74			 
1f74 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f88			 
1f88			; TODO push to stack 
1f88			 
1f88			;  
1f88			 
1f88			if FORTH_PARSEV2 
1f88			 
1f88			 
1f88				include "forth_parserv2.asm" 
1f88			 
1f88			endif 
1f88			 
1f88			 
1f88			; parse cli version 1 
1f88			 
1f88			if FORTH_PARSEV1 
1f88			 
1f88			 
1f88			 
1f88			      include "forth_parserv1.asm" 
1f88			endif 
1f88				 
1f88			if FORTH_PARSEV3 
1f88			 
1f88			 
1f88			 
1f88			      include "forth_parserv3.asm" 
1f88				include "forth_wordsv3.asm" 
1f88			endif 
1f88			 
1f88			if FORTH_PARSEV4 
1f88			 
1f88			 
1f88			 
1f88			      include "forth_parserv4.asm" 
1f88				include "forth_wordsv4.asm" 
1f88			endif 
1f88			 
1f88			if FORTH_PARSEV5 
1f88			 
1f88			 
1f88			 
1f88			      include "forth_parserv5.asm" 
1f88			 
1f88			 
1f88			; A better parser without using malloc and string copies all over the place.  
1f88			; Exec in situ should be faster 
1f88			 
1f88			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f88			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f88			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f88			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f88			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f88			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f88			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f88			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f88			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f88			 
1f88			; Core word preamble macro 
1f88			 
1f88			CWHEAD:   macro nxtword opcode lit len opflags 
1f88				db WORD_SYS_CORE+opcode             
1f88				; internal op code number 
1f88				dw nxtword            
1f88				; link to next dict word block 
1f88				db len + 1 
1f88				; literal length of dict word inc zero term 
1f88				db lit,0              
1f88				; literal dict word 
1f88			        ; TODO db opflags        
1f88				endm 
1f88			 
1f88			 
1f88			NEXTW: macro  
1f88				jp macro_next 
1f88				endm 
1f88			 
1f88			macro_next: 
1f88			if DEBUG_FORTH_PARSE_KEY 
1f88				DMARK "NXT" 
1f88				CALLMONITOR 
1f88			endif	 
1f88			;	inc hl  ; skip token null term  
1f88 ed 4b 28 f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f8c ed 5b 26 f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f90 2a 1e f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f93			if DEBUG_FORTH_PARSE_KEY 
1f93				DMARK "}AA" 
1f93				CALLMONITOR 
1f93			endif	 
1f93 c3 96 20			jp execnext 
1f96				;jp exec1 
1f96			       
1f96			 
1f96			 
1f96			; Another go at the parser to compile  
1f96			 
1f96			 
1f96			; TODO rework parser to change all of the string words to byte tokens 
1f96			; TODO do a search for  
1f96			 
1f96			; TODO first run normal parser to zero term sections 
1f96			; TODO for each word do a token look up to get the op code 
1f96			; TODO need some means to flag to the exec that this is a byte code form    
1f96			 
1f96			 
1f96			forthcompile: 
1f96			 
1f96			; 
1f96			; line parse: 
1f96			;       parse raw input buffer 
1f96			;       tokenise the words 
1f96			;       malloc new copy (for looping etc) 
1f96			;       copy to malloc + current pc in line to start of string and add line term 
1f96			;       save on new rsp 
1f96			; 
1f96			 
1f96			; hl to point to the line to tokenise 
1f96			 
1f96			;	push hl 
1f96 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
1f99			 
1f99			;	ld a,0		; string term on input 
1f99			;	call strlent 
1f99			 
1f99			;	ld (os_tok_len), hl	 ; save string length 
1f99			 
1f99			;if DEBUG_FORTH_TOK 
1f99			;	ex de,hl		 
1f99			;endif 
1f99			 
1f99			;	pop hl 		; get back string pointer 
1f99			 
1f99			if DEBUG_FORTH_TOK 
1f99						DMARK "TOc" 
1f99				CALLMONITOR 
1f99			endif 
1f99 7e			.cptoken2:    ld a,(hl) 
1f9a 23				inc hl 
1f9b fe 7f			cp FORTH_END_BUFFER 
1f9d 28 29			jr z, .cptokendone2 
1f9f fe 00			cp 0 
1fa1 28 25			jr z, .cptokendone2 
1fa3 fe 22			cp '"' 
1fa5 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1fa7 fe 20			cp ' ' 
1fa9 20 ee			jr nz,  .cptoken2 
1fab			 
1fab			; TODO consume comments held between ( and ) 
1fab			 
1fab				; we have a space so change to zero term for dict match later 
1fab 2b				dec hl 
1fac 3e 00			ld a,0 
1fae 77				ld (hl), a 
1faf 23				inc hl 
1fb0 18 e7			jr .cptoken2 
1fb2				 
1fb2			 
1fb2			.cptokenstr2: 
1fb2				; skip all white space until either eol (because forgot to term) or end double quote 
1fb2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fb2				;inc hl ; skip current double quote 
1fb2 7e				ld a,(hl) 
1fb3 23				inc hl 
1fb4 fe 22			cp '"' 
1fb6 28 e1			jr z, .cptoken2 
1fb8 fe 7f			cp FORTH_END_BUFFER 
1fba 28 0c			jr z, .cptokendone2 
1fbc fe 00			cp 0 
1fbe 28 08			jr z, .cptokendone2 
1fc0 fe 20			cp ' ' 
1fc2 28 02			jr z, .cptmp2 
1fc4 18 ec			jr .cptokenstr2 
1fc6			 
1fc6			.cptmp2:	; we have a space so change to zero term for dict match later 
1fc6				;dec hl 
1fc6				;ld a,"-"	; TODO remove this when working 
1fc6				;ld (hl), a 
1fc6				;inc hl 
1fc6 18 ea			jr .cptokenstr2 
1fc8			 
1fc8			.cptokendone2: 
1fc8				;inc hl 
1fc8 3e 7f			ld a, FORTH_END_BUFFER 
1fca 77				ld (hl),a 
1fcb 23				inc hl 
1fcc 3e 21			ld a, '!' 
1fce 77				ld (hl),a 
1fcf			 
1fcf 2a 1e f1			ld hl,(os_tok_ptr) 
1fd2			         
1fd2			if DEBUG_FORTH_TOK 
1fd2						DMARK "Tc1" 
1fd2				CALLMONITOR 
1fd2			endif 
1fd2			 
1fd2				; push exec string to top of return stack 
1fd2				FORTH_RSP_NEXT 
1fd2 cd c6 1b			call macro_forth_rsp_next 
1fd5				endm 
# End of macro FORTH_RSP_NEXT
1fd5 c9				ret 
1fd6			 
1fd6			; Another go at the parser need to simplify the process 
1fd6			 
1fd6			forthparse: 
1fd6			 
1fd6			; 
1fd6			; line parse: 
1fd6			;       parse raw input buffer 
1fd6			;       tokenise the words 
1fd6			;       malloc new copy (for looping etc) 
1fd6			;       copy to malloc + current pc in line to start of string and add line term 
1fd6			;       save on new rsp 
1fd6			; 
1fd6			 
1fd6			; hl to point to the line to tokenise 
1fd6			 
1fd6			;	push hl 
1fd6 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
1fd9			 
1fd9			;	ld a,0		; string term on input 
1fd9			;	call strlent 
1fd9			 
1fd9			;	ld (os_tok_len), hl	 ; save string length 
1fd9			 
1fd9			;if DEBUG_FORTH_TOK 
1fd9			;	ex de,hl		 
1fd9			;endif 
1fd9			 
1fd9			;	pop hl 		; get back string pointer 
1fd9			 
1fd9			if DEBUG_FORTH_TOK 
1fd9						DMARK "TOK" 
1fd9				CALLMONITOR 
1fd9			endif 
1fd9 7e			.ptoken2:    ld a,(hl) 
1fda 23				inc hl 
1fdb fe 7f			cp FORTH_END_BUFFER 
1fdd 28 29			jr z, .ptokendone2 
1fdf fe 00			cp 0 
1fe1 28 25			jr z, .ptokendone2 
1fe3 fe 22			cp '"' 
1fe5 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fe7 fe 20			cp ' ' 
1fe9 20 ee			jr nz,  .ptoken2 
1feb			 
1feb			; TODO consume comments held between ( and ) 
1feb			 
1feb				; we have a space so change to zero term for dict match later 
1feb 2b				dec hl 
1fec 3e 00			ld a,0 
1fee 77				ld (hl), a 
1fef 23				inc hl 
1ff0 18 e7			jr .ptoken2 
1ff2				 
1ff2			 
1ff2			.ptokenstr2: 
1ff2				; skip all white space until either eol (because forgot to term) or end double quote 
1ff2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ff2				;inc hl ; skip current double quote 
1ff2 7e				ld a,(hl) 
1ff3 23				inc hl 
1ff4 fe 22			cp '"' 
1ff6 28 e1			jr z, .ptoken2 
1ff8 fe 7f			cp FORTH_END_BUFFER 
1ffa 28 0c			jr z, .ptokendone2 
1ffc fe 00			cp 0 
1ffe 28 08			jr z, .ptokendone2 
2000 fe 20			cp ' ' 
2002 28 02			jr z, .ptmp2 
2004 18 ec			jr .ptokenstr2 
2006			 
2006			.ptmp2:	; we have a space so change to zero term for dict match later 
2006				;dec hl 
2006				;ld a,"-"	; TODO remove this when working 
2006				;ld (hl), a 
2006				;inc hl 
2006 18 ea			jr .ptokenstr2 
2008			 
2008			.ptokendone2: 
2008				;inc hl 
2008 3e 7f			ld a, FORTH_END_BUFFER 
200a 77				ld (hl),a 
200b 23				inc hl 
200c 3e 21			ld a, '!' 
200e 77				ld (hl),a 
200f			 
200f 2a 1e f1			ld hl,(os_tok_ptr) 
2012			         
2012			if DEBUG_FORTH_TOK 
2012						DMARK "TK1" 
2012				CALLMONITOR 
2012			endif 
2012			 
2012				; push exec string to top of return stack 
2012				FORTH_RSP_NEXT 
2012 cd c6 1b			call macro_forth_rsp_next 
2015				endm 
# End of macro FORTH_RSP_NEXT
2015 c9				ret 
2016			 
2016			; 
2016			;	; malloc size + buffer pointer + if is loop flag 
2016			;	ld hl,(os_tok_len) 		 ; get string length 
2016			; 
2016			;	ld a,l 
2016			; 
2016			;	cp 0			; we dont want to use a null string 
2016			;	ret z 
2016			; 
2016			;;	add 3    ; prefix malloc with buffer for current word ptr 
2016			; 
2016			;	add 5     ; TODO when certain not over writing memory remove 
2016			; 
2016			;		 
2016			; 
2016			;if DEBUG_FORTH_TOK 
2016			;			DMARK "TKE" 
2016			;	CALLMONITOR 
2016			;endif 
2016			; 
2016			;	ld l,a 
2016			;	ld h,0 
2016			;;	push hl   ; save required space for the copy later 
2016			;	call malloc 
2016			;if DEBUG_FORTH_TOK 
2016			;			DMARK "TKM" 
2016			;	CALLMONITOR 
2016			;endif 
2016			;	if DEBUG_FORTH_MALLOC_GUARD 
2016			;		push af 
2016			;		call ishlzero 
2016			;;		ld a, l 
2016			;;		add h 
2016			;;		cp 0 
2016			;		pop af 
2016			;		 
2016			;		call z,malloc_error 
2016			;	endif 
2016			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2016			; 
2016			; 
2016			;if DEBUG_FORTH_TOK 
2016			;			DMARK "TKR" 
2016			;	CALLMONITOR 
2016			;endif 
2016			; 
2016			;	FORTH_RSP_NEXT 
2016			; 
2016			;	;inc hl	 ; go past current buffer pointer 
2016			;	;inc hl 
2016			;	;inc hl   ; and past if loop flag 
2016			;		; TODO Need to set flag  
2016			; 
2016			;	 
2016			;	 
2016			;	ex de,hl	; malloc is dest 
2016			;	ld hl, (os_tok_len) 
2016			;;	pop bc 
2016			;	ld c, l                
2016			;	ld b,0 
2016			;	ld hl, (os_tok_ptr) 
2016			; 
2016			;if DEBUG_FORTH_TOK 
2016			;			DMARK "TKT" 
2016			;	CALLMONITOR 
2016			;endif 
2016			; 
2016			;	; do str cpy 
2016			; 
2016			;	ldir      ; copy byte in hl to de 
2016			; 
2016			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2016			; 
2016			;if DEBUG_FORTH_TOK 
2016			; 
2016			;			DMARK "TKY" 
2016			;	CALLMONITOR 
2016			;endif 
2016			;	;ld a,0 
2016			;	;ld a,FORTH_END_BUFFER 
2016			;	ex de, hl 
2016			;	;dec hl			 ; go back over the space delim at the end of word 
2016			;	;ld (hl),a 
2016			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2016			;	ld a,FORTH_END_BUFFER 
2016			;	ld (hl),a 
2016			;	inc hl 
2016			;	ld a,FORTH_END_BUFFER 
2016			;	ld (hl),a 
2016			; 
2016			;	; init the malloc area data 
2016			;	; set pc for in current area 
2016			;	;ld hl, (os_tok_malloc) 
2016			;	;inc hl 
2016			;	;inc hl 
2016			;	;inc hl 
2016			;	;ex de,hl 
2016			;	;ld hl, (os_tok_malloc) 
2016			;	;ld (hl),e 
2016			;	;inc hl 
2016			;	;ld (hl),d 
2016			; 
2016			; 
2016			;	ld hl,(os_tok_malloc) 
2016			;if DEBUG_FORTH_PARSE_KEY 
2016			;			DMARK "TKU" 
2016			;	CALLMONITOR 
2016			;endif 
2016			; 
2016			;	ret 
2016			 
2016			forthexec: 
2016			 
2016			; line exec: 
2016			; forth parser 
2016			 
2016			; 
2016			;       get current exec line on rsp 
2016			 
2016				FORTH_RSP_TOS 
2016 cd dd 1b			call macro_forth_rsp_tos 
2019				endm 
# End of macro FORTH_RSP_TOS
2019			 
2019			;       restore current pc - hl points to malloc of data 
2019			 
2019				;ld e, (hl) 
2019				;inc hl 
2019				;ld d, (hl) 
2019				;ex de,hl 
2019			 
2019			 
2019			exec1: 
2019 22 1e f1			ld (os_tok_ptr), hl 
201c			 
201c				; copy our PC to working vars  
201c 22 28 f8			ld (cli_ptr), hl 
201f 22 26 f8			ld (cli_origptr), hl 
2022			 
2022 7e				ld a,(hl) 
2023 fe 7f			cp FORTH_END_BUFFER 
2025 c8				ret z 
2026			 
2026				; skip any nulls 
2026			 
2026 fe 00			cp 0 
2028 20 03			jr nz, .execword 
202a 23				inc hl 
202b 18 ec			jr exec1 
202d			 
202d			 
202d			.execword: 
202d			 
202d			 
202d			 
202d			if DEBUG_FORTH_PARSE_KEY 
202d						DMARK "KYQ" 
202d				CALLMONITOR 
202d			endif 
202d			;       while at start of word: 
202d			; get start of dict (in user area first) 
202d			 
202d 21 00 80		ld hl, baseram 
2030			;ld hl, sysdict 
2030 22 2a f8		ld (cli_nextword),hl 
2033			;           match word at pc 
2033			;           exec word 
2033			;           or push to dsp 
2033			;           forward to next token 
2033			;           if line term pop rsp and exit 
2033			;        
2033			 
2033			if DEBUG_FORTH_PARSE_KEY 
2033						DMARK "KYq" 
2033				CALLMONITOR 
2033			endif 
2033			 
2033			; 
2033			; word comp 
2033			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2033			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2033			;    move to start of word  
2033			;    compare word to cli_token 
2033			 
2033			.execpnword:	; HL at start of a word in the dictionary to check 
2033			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2033			;	ld (cli_ptr), hl 
2033			 
2033 2a 2a f8			ld hl,(cli_nextword) 
2036			 
2036 cd d9 20			call forth_tok_next 
2039			; tok next start here 
2039			;	; TODO skip compiled symbol for now 
2039			;	inc hl 
2039			; 
2039			;	; save pointer to next word 
2039			; 
2039			;	; hl now points to the address of the next word pointer  
2039			;	ld e, (hl) 
2039			;	inc hl 
2039			;	ld d, (hl) 
2039			;	inc l 
2039			; 
2039			;	ex de,hl 
2039			;if DEBUG_FORTH_PARSE_NEXTWORD 
2039			;	push bc 
2039			;	ld bc, (cli_nextword) 
2039			;			DMARK "NXW" 
2039			;	CALLMONITOR 
2039			;	pop bc 
2039			;endif 
2039			; tok next end here 
2039 22 2a f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
203c eb				ex de, hl 
203d			 
203d			 
203d				; save the pointer of the current token - 1 to check against 
203d				 
203d 22 2e f8			ld (cli_token), hl   
2040				; TODO maybe remove below save if no debug 
2040				; save token string ptr for any debug later 
2040 23				inc hl  
2041 22 30 f8			ld (cli_origtoken), hl 
2044 2b				dec hl 
2045				; save pointer to the start of the next dictionay word 
2045 7e				ld a,(hl)   ; get string length 
2046 47				ld b,a 
2047			.execpnwordinc:  
2047 23				inc hl 
2048 10 fd			djnz .execpnwordinc 
204a 22 2c f8			ld (cli_execword), hl      ; save start of this words code 
204d			 
204d				; now check the word token against the string being parsed 
204d			 
204d 2a 2e f8			ld hl,(cli_token) 
2050 23				inc hl     ; skip string length (use zero term instead to end) 
2051 22 2e f8			ld (cli_token), hl 
2054			 
2054			if DEBUG_FORTH_PARSE_KEY 
2054						DMARK "KY2" 
2054			endif 
2054			if DEBUG_FORTH_PARSE_EXEC 
2054				; see if disabled 
2054			 
2054				ld a, (os_view_disable) 
2054				cp '*' 
2054				jr z, .skip 
2054			 
2054				push hl 
2054				push hl 
2054				call clear_display 
2054				ld de, .compword 
2054				ld a, display_row_1 
2054				call str_at_display 
2054				pop de 
2054				ld a, display_row_2 
2054				call str_at_display 
2054				ld hl,(cli_ptr) 
2054				ld a,(hl) 
2054			        ld hl, os_word_scratch 
2054				ld (hl),a 
2054				ld a,0 
2054				inc hl 
2054				ld (hl),a 	 
2054				ld de, os_word_scratch 
2054				ld a, display_row_2+10 
2054				call str_at_display 
2054				call update_display 
2054				ld a, 100 
2054				call aDelayInMS 
2054				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2054				call delay250ms 
2054				endif 
2054				pop hl 
2054			.skip:  
2054			endif	 
2054			.execpnchar:    ; compare char between token and string to parse 
2054			 
2054			if DEBUG_FORTH_PARSE_KEY 
2054						DMARK "Ky3" 
2054			endif 
2054			if DEBUG_FORTH_PARSE_EXEC 
2054				; see if disabled 
2054			 
2054				ld a, (os_view_disable) 
2054				cp '*' 
2054				jr z, .skip2 
2054			 
2054			;	call clear_display 
2054			ld hl,(cli_token) 
2054			ld a,(hl) 
2054			ld (os_word_scratch),a 
2054				ld hl,(cli_ptr) 
2054			ld a,(hl) 
2054				ld (os_word_scratch+1),a 
2054				ld a,0 
2054				ld (os_word_scratch+2),a 
2054				ld de,os_word_scratch 
2054				ld a,display_row_4 
2054				call str_at_display 
2054				call update_display 
2054			.skip2:  
2054			endif 
2054 2a 2e f8			ld hl,(cli_token) 
2057 7e				ld a, (hl)	 ; char in word token 
2058 23				inc hl 		; move to next char 
2059 22 2e f8			ld (cli_token), hl ; and save it 
205c 47				ld b,a 
205d			 
205d 2a 28 f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
2060 7e				ld a,(hl) 
2061 23				inc hl 
2062 22 28 f8			ld (cli_ptr), hl		; move to next char 
2065 cd 5e 11			call toUpper 		; make sure the input string matches case 
2068			 
2068			if DEBUG_FORTH_PARSE 
2068			endif 
2068			 
2068				; input stream end of token is a space so get rid of it 
2068			 
2068			;	cp ' ' 
2068			;	jr nz, .pnskipspace 
2068			; 
2068			;	ld a, 0		; make same term as word token term 
2068			; 
2068			;.pnskipspace: 
2068			 
2068			if DEBUG_FORTH_PARSE_KEY 
2068						DMARK "KY7" 
2068			endif 
2068 b8				cp b 
2069 c2 7f 20			jp nz, .execpnskipword	 ; no match so move to next word 
206c				 
206c			;    if same 
206c			;       scan for string terms 0 for token and 32 for input 
206c			 
206c				 
206c			if DEBUG_FORTH_PARSE_KEY 
206c						DMARK "KY8" 
206c			endif 
206c			 
206c 80				add b			 
206d fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
206f							; TODO need to make sure last word in zero term string is accounted for 
206f 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2071			 
2071			 
2071				; at end of both strings so both are exact match 
2071			 
2071			;       skip ptr for next word 
2071			 
2071 2a 28 f8			ld hl,(cli_ptr) 	; at input string term 
2074 23				inc hl			 ; at next char 
2075 22 28 f8			ld (cli_ptr), hl     ; save for next round of the parser 
2078 22 26 f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
207b				 
207b				 
207b			if DEBUG_FORTH_PARSE_KEY 
207b						DMARK "KY3" 
207b			endif 
207b			 
207b			 
207b			 
207b			;       exec code block 
207b			if DEBUG_FORTH_JP 
207b				call clear_display 
207b				call update_display 
207b				call delay1s 
207b				ld hl, (cli_execword)     ; save for next check if no match on this word 
207b				ld a,h 
207b				ld hl, os_word_scratch 
207b				call hexout 
207b				ld hl, (cli_execword)     ; save for next check if no match on this word 
207b				ld a,l 
207b				ld hl, os_word_scratch+2 
207b				call hexout 
207b				ld hl, os_word_scratch+4 
207b				ld a,0 
207b				ld (hl),a 
207b				ld de,os_word_scratch 
207b				call str_at_display 
207b					ld a, display_row_2 
207b					call str_at_display 
207b				ld de, (cli_origtoken) 
207b				ld a, display_row_1+10 
207b					call str_at_display 
207b			 
207b				ld a,display_row_1 
207b				ld de, .foundword 
207b				ld a, display_row_3 
207b				call str_at_display 
207b				call update_display 
207b				call delay1s 
207b				call delay1s 
207b				call delay1s 
207b			endif 
207b			 
207b			if DEBUG_FORTH_PARSE_KEY 
207b						DMARK "KYj" 
207b			endif 
207b				; TODO save the word pointer in this exec 
207b			 
207b 2a 2c f8			ld hl,(cli_execword) 
207e e9				jp (hl) 
207f			 
207f			 
207f			;    if not same 
207f			;	scan for zero term 
207f			;	get ptr for next word 
207f			;	goto word comp 
207f			 
207f			.execpnskipword:	; get pointer to next word 
207f 2a 2a f8			ld hl,(cli_nextword) 
2082			 
2082 7e				ld a,(hl) 
2083 fe 00			cp WORD_SYS_END 
2085			;	cp 0 
2085 28 09			jr z, .execendofdict			 ; at end of words 
2087			 
2087			if DEBUG_FORTH_PARSE_KEY 
2087						DMARK "KY4" 
2087			endif 
2087			if DEBUG_FORTH_PARSE_EXEC 
2087			 
2087				; see if disabled 
2087			 
2087				ld a, (os_view_disable) 
2087				cp '*' 
2087				jr z, .noskip 
2087			 
2087			 
2087				ld de, .nowordfound 
2087				ld a, display_row_3 
2087				call str_at_display 
2087				call update_display 
2087				ld a, 100 
2087				call aDelayInMS 
2087				 
2087				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2087					call delay250ms 
2087				endif 
2087			.noskip:  
2087			 
2087			endif	 
2087			 
2087 2a 26 f8			ld hl,(cli_origptr) 
208a 22 28 f8			ld (cli_ptr),hl 
208d			 
208d			if DEBUG_FORTH_PARSE_KEY 
208d						DMARK "KY5" 
208d			endif 
208d c3 33 20			jp .execpnword			; else go to next word 
2090			 
2090			.execendofdict:  
2090			 
2090			if DEBUG_FORTH_PARSE_KEY 
2090						DMARK "KYe" 
2090			endif 
2090			if DEBUG_FORTH_PARSE_EXEC 
2090				; see if disabled 
2090			 
2090				ld a, (os_view_disable) 
2090				cp '*' 
2090				jr z, .ispskip 
2090			 
2090				call clear_display 
2090				call update_display 
2090				call delay1s 
2090				ld de, (cli_origptr) 
2090				ld a, display_row_1 
2090				call str_at_display 
2090				 
2090				ld de, .enddict 
2090				ld a, display_row_3 
2090				call str_at_display 
2090				call update_display 
2090				ld a, 100 
2090				call aDelayInMS 
2090				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2090				call delay1s 
2090				call delay1s 
2090				call delay1s 
2090				endif 
2090			.ispskip:  
2090				 
2090			endif	 
2090			 
2090			 
2090			 
2090				; if the word is not a keyword then must be a literal so push it to stack 
2090			 
2090			; push token to stack to end of word 
2090			 
2090				STACKFRAME ON $1efe $2f9f 
2090				if DEBUG_STACK_IMB 
2090					if ON 
2090						exx 
2090						ld de, $1efe 
2090						ld a, d 
2090						ld hl, curframe 
2090						call hexout 
2090						ld a, e 
2090						ld hl, curframe+2 
2090						call hexout 
2090						ld hl, $1efe 
2090						push hl 
2090						ld hl, $2f9f 
2090						push hl 
2090						exx 
2090					endif 
2090				endif 
2090			endm 
# End of macro STACKFRAME
2090			 
2090 2a 1e f1		ld hl,(os_tok_ptr) 
2093 cd 88 1d		call forth_apush 
2096			 
2096				STACKFRAMECHK ON $1efe $2f9f 
2096				if DEBUG_STACK_IMB 
2096					if ON 
2096						exx 
2096						ld hl, $2f9f 
2096						pop de   ; $2f9f 
2096						call cmp16 
2096						jr nz, .spnosame 
2096						ld hl, $1efe 
2096						pop de   ; $1efe 
2096						call cmp16 
2096						jr z, .spfrsame 
2096						.spnosame: call showsperror 
2096						.spfrsame: nop 
2096						exx 
2096					endif 
2096				endif 
2096			endm 
# End of macro STACKFRAMECHK
2096			 
2096			execnext: 
2096			 
2096			if DEBUG_FORTH_PARSE_KEY 
2096						DMARK "KY>" 
2096			endif 
2096			; move past token to next word 
2096			 
2096 2a 1e f1		ld hl, (os_tok_ptr) 
2099 3e 00		ld a, 0 
209b 01 ff 00		ld bc, 255     ; input buffer size 
209e ed b1		cpir 
20a0			 
20a0			if DEBUG_FORTH_PARSE_KEY 
20a0						DMARK "KY!" 
20a0				CALLMONITOR 
20a0			endif	 
20a0			; TODO this might place hl on the null, so will need to forward on??? 
20a0			;inc hl   ; see if this gets onto the next item 
20a0			 
20a0			 
20a0			; TODO pass a pointer to the buffer to push 
20a0			; TODO call function to push 
20a0			 
20a0			; look for end of input 
20a0			 
20a0			;inc hl 
20a0			;ld a,(hl) 
20a0			;cp FORTH_END_BUFFER 
20a0			;ret z 
20a0			 
20a0			 
20a0 c3 19 20		jp exec1 
20a3			 
20a3			 
20a3			 
20a3			 
20a3			 
20a3			 
20a3			 
20a3			 
20a3			 
20a3			findnexttok: 
20a3			 
20a3				; hl is pointer to move 
20a3				; de is the token to locate 
20a3			 
20a3					if DEBUG_FORTH 
20a3						DMARK "NTK" 
20a3						CALLMONITOR 
20a3					endif 
20a3 d5				push de 
20a4			 
20a4			.fnt1:	 
20a4				; find first char of token to locate 
20a4			 
20a4 1a				ld a, (de) 
20a5 4f				ld c,a 
20a6 7e				ld a,(hl) 
20a7 cd 5e 11			call toUpper 
20aa					if DEBUG_FORTH 
20aa						DMARK "NT1" 
20aa						CALLMONITOR 
20aa					endif 
20aa b9				cp c 
20ab			 
20ab 28 03			jr z, .fnt2cmpmorefirst	 
20ad			 
20ad				; first char not found move to next char 
20ad			 
20ad 23				inc hl 
20ae 18 f4			jr .fnt1 
20b0			 
20b0			.fnt2cmpmorefirst:	 
20b0				; first char of token found.  
20b0			 
20b0 e5				push hl     ; save start of token just in case it is the right one 
20b1 d9				exx 
20b2 e1				pop hl        ; save it to hl' 
20b3 d9				exx 
20b4			 
20b4			 
20b4			.fnt2cmpmore:	 
20b4				; compare the rest 
20b4				 
20b4 23				inc hl 
20b5 13				inc de 
20b6				 
20b6 1a				ld a, (de) 
20b7 4f				ld c,a 
20b8 7e				ld a,(hl) 
20b9 cd 5e 11			call toUpper 
20bc			 
20bc					if DEBUG_FORTH 
20bc						DMARK "NT2" 
20bc						CALLMONITOR 
20bc					endif 
20bc				; c has the token to find char 
20bc				; a has the mem to scan char 
20bc			 
20bc b9				cp c 
20bd 28 04			jr z,.fntmatch1 
20bf			 
20bf				; they are not the same 
20bf			 
20bf					if DEBUG_FORTH 
20bf						DMARK "NT3" 
20bf						CALLMONITOR 
20bf					endif 
20bf d1				pop de	; reset de token to look for 
20c0 d5				push de 
20c1 18 e1			jr .fnt1 
20c3				 
20c3			.fntmatch1: 
20c3			 
20c3				; is the same char a null which means we might have a full hit? 
20c3					if DEBUG_FORTH 
20c3						DMARK "NT4" 
20c3						CALLMONITOR 
20c3					endif 
20c3			 
20c3 fe 00			cp 0 
20c5 28 0b			jr z, .fntmatchyes 
20c7			 
20c7				; are we at the end of the token to find? 
20c7			 
20c7					if DEBUG_FORTH 
20c7						DMARK "NT5" 
20c7						CALLMONITOR 
20c7					endif 
20c7 3e 00			ld a, 0 
20c9 b9				cp c 
20ca			 
20ca c2 b4 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20cd			 
20cd					if DEBUG_FORTH 
20cd						DMARK "NT6" 
20cd						CALLMONITOR 
20cd					endif 
20cd				; token to find is exhusted but no match to stream 
20cd			 
20cd				; restore tok pointer and continue on 
20cd d1				pop de 
20ce d5				push de 
20cf c3 a4 20			jp .fnt1 
20d2			 
20d2			 
20d2			.fntmatchyes: 
20d2			 
20d2				; hl now contains the end of the found token 
20d2			 
20d2				; get rid of saved token pointer to find 
20d2			 
20d2 d1				pop de 
20d3			 
20d3					if DEBUG_FORTH 
20d3						DMARK "NT9" 
20d3						CALLMONITOR 
20d3					endif 
20d3			 
20d3				; hl will be on the null term so forward on 
20d3			 
20d3				; get back the saved start of the token 
20d3			 
20d3 d9				exx 
20d4 e5				push hl     ; save start of token just in case it is the right one 
20d5 d9				exx 
20d6 e1				pop hl        ; save it to hl 
20d7			 
20d7 c9				ret 
20d8			 
20d8			 
20d8			; LIST needs to find a specific token   
20d8			; FORGET needs to find a spefici token 
20d8			 
20d8			; SAVE needs to find all tokens by flag 
20d8			; WORDS just needs to scan through all  by flag 
20d8			; UWORDS needs to scan through all by flag 
20d8			 
20d8			 
20d8			; given hl as pointer to start of dict look up string 
20d8			; return hl as pointer to start of word block 
20d8			; or 0 if not found 
20d8			 
20d8			forth_find_tok: 
20d8 c9				ret 
20d9			 
20d9			; given hl as pointer to dict structure 
20d9			; move to the next dict block structure 
20d9			 
20d9			forth_tok_next: 
20d9				; hl now points to the address of the next word pointer  
20d9				; TODO skip compiled symbol for now 
20d9			;	push de 
20d9 23				inc hl 
20da 5e				ld e, (hl) 
20db 23				inc hl 
20dc 56				ld d, (hl) 
20dd 23				inc hl 
20de			 
20de eb				ex de,hl 
20df			if DEBUG_FORTH_PARSE_NEXTWORD 
20df				push bc 
20df				ld bc, (cli_nextword) 
20df						DMARK "NXW" 
20df				CALLMONITOR 
20df				pop bc 
20df			endif 
20df			;	pop de	 
20df c9				ret 
20e0			 
20e0			 
20e0			 
20e0			; eof 
# End of file forth_parserv5.asm
20e0				include "forth_wordsv4.asm" 
20e0			 
20e0			; the core word dictionary v4 
20e0			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20e0			 
20e0			; this is a linked list for each of the system words used 
20e0			; user defined words will follow the same format but will be in ram 
20e0			 
20e0			 
20e0			; 
20e0			; 
20e0			; define linked list: 
20e0			; 
20e0			; 1. compiled byte op code 
20e0			; 2. len of text word 
20e0			; 3. text word 
20e0			; 4. ptr to next dictionary word 
20e0			; 5. asm, calls etc for the word 
20e0			; 
20e0			;  if 1 == 0 then last word in dict  
20e0			;   
20e0			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20e0			;  
20e0			;  
20e0			; create basic standard set of words 
20e0			; 
20e0			;  
20e0			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20e0			; 2DUP 2DROP 2SWAP  
20e0			; @ C@ - get byte  
20e0			; ! C! - store byte 
20e0			; 0< true if less than zero 
20e0			; 0= true if zero 
20e0			; < >  
20e0			; = true if same 
20e0			; variables 
20e0			 
20e0			 
20e0			; Hardware specific words I may need 
20e0			; 
20e0			; IN OUT  
20e0			; calls to key util functions 
20e0			; calls to hardward abstraction stuff 
20e0			; easy control of frame buffers and lcd i/o 
20e0			; keyboard  
20e0			 
20e0			 
20e0			;DICT: macro 
20e0			; op_code, len, word, next 
20e0			;    word: 
20e0			;    db op_code 
20e0			;    ds word zero term 
20e0			;    dw next 
20e0			;    endm 
20e0			 
20e0			 
20e0			 
20e0			 
20e0			; op code 1 is a flag for user define words which are to be handled differently 
20e0			 
20e0			 
20e0			; 
20e0			; 
20e0			;    TODO on entry to a word this should be the expected environment 
20e0			;    hl - tos value if number then held, if string this is the ptr 
20e0			;    de -  
20e0			 
20e0			 
20e0			; opcode ranges 
20e0			; 0 - end of word dict 
20e0			; 255 - user define words 
20e0			 
20e0			sysdict: 
20e0			include "forth_opcodes.asm" 
20e0			; op codes for forth keywords 
20e0			; free to use code 0  
20e0				OPCODE_HEAP: equ  1 
20e0				OPCODE_EXEC: equ 2 
20e0				OPCODE_DUP: equ 3 
20e0				OPCODE_SWAP: equ 4 
20e0				OPCODE_COLN: equ 5 
20e0				OPCODE_SCOLN: equ 6 
20e0				OPCODE_DROP: equ 7 
20e0				OPCODE_DUP2: equ 8 
20e0				OPCODE_DROP2: equ 9 
20e0				OPCODE_SWAP2: equ 10 
20e0				OPCODE_AT: equ 11 
20e0				OPCODE_CAT: equ 12 
20e0				OPCODE_BANG: equ 13 
20e0				OPCODE_CBANG: equ 14 
20e0				OPCODE_SCALL: equ 15 
20e0				OPCODE_DEPTH: equ 16 
20e0				OPCODE_OVER: equ 17 
20e0				OPCODE_PAUSE: equ 18 
20e0				OPCODE_PAUSES: equ 19 
20e0				OPCODE_ROT: equ 20 
20e0			;free to reuse	OPCODE_WORDS: equ 21 
20e0			        OPCODE_NOT: equ 21 
20e0				OPCODE_UWORDS: equ 22 
20e0				OPCODE_BP: equ 23 
20e0				OPCODE_MONITOR: equ 24  
20e0				OPCODE_MALLOC: equ 25 
20e0				OPCODE_FREE: equ 26 
20e0				OPCODE_LIST: equ 27 
20e0				OPCODE_FORGET: equ 28 
20e0				OPCODE_NOP: equ 29 
20e0				OPCODE_COMO: equ 30 
20e0				OPCODE_COMC: equ 31 
20e0			;free to reuse	OPCODE_ENDCORE: equ 32 
20e0				OPCODE_AFTERSOUND: equ 33 
20e0				OPCODE_GP2: equ 34 
20e0				OPCODE_GP3: equ 35 
20e0				OPCODE_GP4: equ 36 
20e0				OPCODE_SIN: equ 37 
20e0				OPCODE_SOUT: equ 38 
20e0				OPCODE_SPIO: equ 39 
20e0				OPCODE_SPICEH: equ 40 
20e0				OPCODE_SPIOb: equ 41 
20e0				OPCODE_SPII: equ 42 
20e0				OPCODE_SESEL: equ 43 
20e0				OPCODE_CARTDEV: equ 44 
20e0			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20e0				OPCODE_FB: equ 46 
20e0				OPCODE_EMIT: equ 47 
20e0				OPCODE_DOTH: equ 48 
20e0				OPCODE_DOTF: equ 49 
20e0				OPCODE_DOT: equ 50 
20e0				OPCODE_CLS: equ 51 
20e0				OPCODE_DRAW: equ 52 
20e0				OPCODE_DUMP: equ 53 
20e0				OPCODE_CDUMP: equ 54 
20e0				OPCODE_DAT: equ 55 
20e0				OPCODE_HOME: equ 56 
20e0				OPCODE_SPACE: equ 57 
20e0				OPCODE_SPACES: equ 58 
20e0				OPCODE_SCROLL: equ 59 
20e0				OPCODE_ATQ: equ 60 
20e0				OPCODE_AUTODSP: equ 61 
20e0				OPCODE_MENU: equ 62 
20e0			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20e0				OPCODE_THEN: equ 64 
20e0				OPCODE_ELSE: equ 65 
20e0				OPCODE_DO: equ 66 
20e0				OPCODE_LOOP: equ 67 
20e0				OPCODE_I: equ 68 
20e0				OPCODE_DLOOP: equ 69  
20e0				OPCODE_REPEAT: equ 70  
20e0				OPCODE_UNTIL: equ 71 
20e0				OPCODE_ENDFLOW: equ 72 
20e0				OPCODE_WAITK: equ 73 
20e0				OPCODE_ACCEPT: equ 74 
20e0				OPCODE_EDIT: equ 75 
20e0			;free to reuse	OPCODE_ENDKEY: equ 76 
20e0				OPCODE_LZERO: equ 77 
20e0				OPCODE_TZERO: equ 78 
20e0				OPCODE_LESS: equ 79 
20e0				OPCODE_GT: equ 80 
20e0				OPCODE_EQUAL: equ 81  
20e0			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20e0				OPCODE_NEG: equ 83 
20e0				OPCODE_DIV: equ 84 
20e0				OPCODE_MUL: equ 85 
20e0				OPCODE_MIN: equ 86 
20e0				OPCODE_MAX: equ 87 
20e0				OPCODE_RND16: equ 88 
20e0				OPCODE_RND8: equ 89 
20e0				OPCODE_RND: equ 90 
20e0			;free to reuse	OPCODE_ENDMATHS: equ 91  
20e0				OPCODE_BYNAME: equ 92 
20e0				OPCODE_DIR: equ 93 
20e0				OPCODE_SAVE: equ 94 
20e0				OPCODE_LOAD: equ 95 
20e0				OPCODE_BSAVE: equ 96 
20e0				OPCODE_BLOAD: equ 97 
20e0				OPCODE_SEO: equ 98  
20e0				OPCODE_SEI: equ 99 
20e0				OPCODE_SFREE: equ 100 
20e0				OPCODE_SIZE: equ 101 
20e0				OPCODE_CREATE: equ 102 
20e0				OPCODE_APPEND: equ 103 
20e0				OPCODE_SDEL: equ 104 
20e0				OPCODE_OPEN: equ 105 
20e0				OPCODE_READ: equ 106 
20e0				OPCODE_EOF: equ 106 
20e0				OPCODE_FORMAT: equ 107 
20e0				OPCODE_LABEL: equ 108 
20e0				OPCODE_LABELS: equ 109 
20e0			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20e0				OPCODE_UPPER: equ 111 
20e0				OPCODE_LOWER: equ 112 
20e0				OPCODE_SUBSTR: equ 113 
20e0				OPCODE_LEFT: equ 114 
20e0				OPCODE_RIGHT: equ 115 
20e0				OPCODE_STR2NUM: equ 116 
20e0				OPCODE_NUM2STR: equ 117 
20e0				OPCODE_CONCAT: equ 118 
20e0				OPCODE_FIND: equ 119 
20e0				OPCODE_LEN: equ 120 
20e0				OPCODE_CHAR: equ 121 
20e0			; free to reuse	OPCODE_STRLEN: equ 122 
20e0			; free to reuse	OPCODE_ENDSTR: equ 123 
20e0				OPCODE_V0S: equ 124 
20e0				OPCODE_V0Q: equ 125 
20e0				OPCODE_V1S: equ 126 
20e0				OPCODE_V1Q: equ 127 
20e0				OPCODE_V2S: equ 128 
20e0				OPCODE_V2Q: equ 129 
20e0				OPCODE_V3S: equ 130 
20e0				OPCODE_V3Q: equ 131 
20e0			;free to reuse	OPCODE_END: equ 132 
20e0				OPCODE_ZDUP: equ 133 
20e0			 
20e0			; eof 
# End of file forth_opcodes.asm
20e0			 
20e0			include "forth_words_core.asm" 
20e0			 
20e0			; | ## Core Words 
20e0			 
20e0			;if MALLOC_4 
20e0			 
20e0			.HEAP: 
20e0				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20e0 15				db WORD_SYS_CORE+OPCODE_HEAP             
20e1 1f 21			dw .EXEC            
20e3 05				db 4 + 1 
20e4 .. 00			db "HEAP",0              
20e9				endm 
# End of macro CWHEAD
20e9			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20e9			; | | u1 - Current number of bytes in the heap 
20e9			; | | u2 - Remaining bytes left on the heap 
20e9			; | |  
20e9			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20e9			 
20e9			 
20e9					if DEBUG_FORTH_WORDS_KEY 
20e9						DMARK "HEP" 
20e9 f5				push af  
20ea 3a fe 20			ld a, (.dmark)  
20ed 32 77 fb			ld (debug_mark),a  
20f0 3a ff 20			ld a, (.dmark+1)  
20f3 32 78 fb			ld (debug_mark+1),a  
20f6 3a 00 21			ld a, (.dmark+2)  
20f9 32 79 fb			ld (debug_mark+2),a  
20fc 18 03			jr .pastdmark  
20fe ..			.dmark: db "HEP"  
2101 f1			.pastdmark: pop af  
2102			endm  
# End of macro DMARK
2102						CALLMONITOR 
2102 cd 92 16			call break_point_state  
2105				endm  
# End of macro CALLMONITOR
2105					endif 
2105 2a 0a 80				ld hl, (free_list )      
2108 11 0e 80				ld de, heap_start 
210b			 
210b ed 52				sbc hl, de  
210d			 
210d cd 1f 1c				call forth_push_numhl 
2110			 
2110			 
2110 ed 5b 0a 80			ld de, (free_list )      
2114 21 03 ee				ld hl, heap_end 
2117			 
2117 ed 52				sbc hl, de 
2119			 
2119 cd 1f 1c				call forth_push_numhl 
211c					 
211c			 
211c					 
211c			 
211c			 
211c			 
211c					NEXTW 
211c c3 88 1f			jp macro_next 
211f				endm 
# End of macro NEXTW
211f			;endif 
211f			 
211f			.EXEC: 
211f				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
211f 16				db WORD_SYS_CORE+OPCODE_EXEC             
2120 bb 21			dw .STKEXEC            
2122 05				db 4 + 1 
2123 .. 00			db "EXEC",0              
2128				endm 
# End of macro CWHEAD
2128			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
2128			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2128			; | | 
2128			; | |   
2128				STACKFRAME OFF $5efe $5f9f 
2128				if DEBUG_STACK_IMB 
2128					if OFF 
2128						exx 
2128						ld de, $5efe 
2128						ld a, d 
2128						ld hl, curframe 
2128						call hexout 
2128						ld a, e 
2128						ld hl, curframe+2 
2128						call hexout 
2128						ld hl, $5efe 
2128						push hl 
2128						ld hl, $5f9f 
2128						push hl 
2128						exx 
2128					endif 
2128				endif 
2128			endm 
# End of macro STACKFRAME
2128			 
2128					if DEBUG_FORTH_WORDS_KEY 
2128						DMARK "EXE" 
2128 f5				push af  
2129 3a 3d 21			ld a, (.dmark)  
212c 32 77 fb			ld (debug_mark),a  
212f 3a 3e 21			ld a, (.dmark+1)  
2132 32 78 fb			ld (debug_mark+1),a  
2135 3a 3f 21			ld a, (.dmark+2)  
2138 32 79 fb			ld (debug_mark+2),a  
213b 18 03			jr .pastdmark  
213d ..			.dmark: db "EXE"  
2140 f1			.pastdmark: pop af  
2141			endm  
# End of macro DMARK
2141						CALLMONITOR 
2141 cd 92 16			call break_point_state  
2144				endm  
# End of macro CALLMONITOR
2144					endif 
2144			 
2144				FORTH_DSP_VALUEHL 
2144 cd 16 1e			call macro_dsp_valuehl 
2147				endm 
# End of macro FORTH_DSP_VALUEHL
2147			 
2147				FORTH_DSP_POP 
2147 cd ce 1e			call macro_forth_dsp_pop 
214a				endm 
# End of macro FORTH_DSP_POP
214a			 
214a					if DEBUG_FORTH_WORDS 
214a						DMARK "EX1" 
214a f5				push af  
214b 3a 5f 21			ld a, (.dmark)  
214e 32 77 fb			ld (debug_mark),a  
2151 3a 60 21			ld a, (.dmark+1)  
2154 32 78 fb			ld (debug_mark+1),a  
2157 3a 61 21			ld a, (.dmark+2)  
215a 32 79 fb			ld (debug_mark+2),a  
215d 18 03			jr .pastdmark  
215f ..			.dmark: db "EX1"  
2162 f1			.pastdmark: pop af  
2163			endm  
# End of macro DMARK
2163						CALLMONITOR 
2163 cd 92 16			call break_point_state  
2166				endm  
# End of macro CALLMONITOR
2166					endif 
2166			;	ld e,(hl) 
2166			;	inc hl 
2166			;	ld d,(hl) 
2166			;	ex de,hl 
2166			 
2166			;		if DEBUG_FORTH_WORDS 
2166			;			DMARK "EX2" 
2166			;			CALLMONITOR 
2166			;		endif 
2166 e5				push hl 
2167			 
2167				;ld a, 0 
2167				;ld a, FORTH_END_BUFFER 
2167 cd 67 11			call strlenz 
216a 23				inc hl   ; include zero term to copy 
216b 23				inc hl   ; include term 
216c 23				inc hl   ; include term 
216d 06 00			ld b,0 
216f 4d				ld c,l 
2170 e1				pop hl 
2171 11 1c ef			ld de, execscratch 
2174					if DEBUG_FORTH_WORDS 
2174						DMARK "EX3" 
2174 f5				push af  
2175 3a 89 21			ld a, (.dmark)  
2178 32 77 fb			ld (debug_mark),a  
217b 3a 8a 21			ld a, (.dmark+1)  
217e 32 78 fb			ld (debug_mark+1),a  
2181 3a 8b 21			ld a, (.dmark+2)  
2184 32 79 fb			ld (debug_mark+2),a  
2187 18 03			jr .pastdmark  
2189 ..			.dmark: db "EX3"  
218c f1			.pastdmark: pop af  
218d			endm  
# End of macro DMARK
218d						CALLMONITOR 
218d cd 92 16			call break_point_state  
2190				endm  
# End of macro CALLMONITOR
2190					endif 
2190 ed b0			ldir 
2192			 
2192			 
2192 21 1c ef			ld hl, execscratch 
2195			 
2195					if DEBUG_FORTH_WORDS 
2195						DMARK "EXe" 
2195 f5				push af  
2196 3a aa 21			ld a, (.dmark)  
2199 32 77 fb			ld (debug_mark),a  
219c 3a ab 21			ld a, (.dmark+1)  
219f 32 78 fb			ld (debug_mark+1),a  
21a2 3a ac 21			ld a, (.dmark+2)  
21a5 32 79 fb			ld (debug_mark+2),a  
21a8 18 03			jr .pastdmark  
21aa ..			.dmark: db "EXe"  
21ad f1			.pastdmark: pop af  
21ae			endm  
# End of macro DMARK
21ae						CALLMONITOR 
21ae cd 92 16			call break_point_state  
21b1				endm  
# End of macro CALLMONITOR
21b1					endif 
21b1			 
21b1 cd d6 1f			call forthparse 
21b4 cd 16 20			call forthexec 
21b7			;	call forthexec_cleanup 
21b7			;	call forthparse 
21b7			;	call forthexec 
21b7			 
21b7				STACKFRAMECHK OFF $5efe $5f9f 
21b7				if DEBUG_STACK_IMB 
21b7					if OFF 
21b7						exx 
21b7						ld hl, $5f9f 
21b7						pop de   ; $5f9f 
21b7						call cmp16 
21b7						jr nz, .spnosame 
21b7						ld hl, $5efe 
21b7						pop de   ; $5efe 
21b7						call cmp16 
21b7						jr z, .spfrsame 
21b7						.spnosame: call showsperror 
21b7						.spfrsame: nop 
21b7						exx 
21b7					endif 
21b7				endif 
21b7			endm 
# End of macro STACKFRAMECHK
21b7			 
21b7				; an immediate word so no need to process any more words 
21b7 c9				ret 
21b8				NEXTW 
21b8 c3 88 1f			jp macro_next 
21bb				endm 
# End of macro NEXTW
21bb			 
21bb			; dead code - old version  
21bb			;	FORTH_RSP_NEXT 
21bb			 
21bb			;  
21bb			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21bb			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21bb			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21bb			;	push hl 
21bb			;	push de 
21bb			;	push bc 
21bb			; 
21bb			; 
21bb			;		if DEBUG_FORTH_WORDS_KEY 
21bb			;			DMARK "EXR" 
21bb			;			CALLMONITOR 
21bb			;		endif 
21bb			; 
21bb			; 
21bb			; 
21bb			;	;v5 FORTH_DSP_VALUE 
21bb			;	FORTH_DSP_VALUEHL 
21bb			; 
21bb			;	; TODO do string type checks 
21bb			; 
21bb			;;v5	inc hl   ; skip type 
21bb			; 
21bb			;	push hl  ; source code  
21bb			;		if DEBUG_FORTH_WORDS 
21bb			;			DMARK "EX1" 
21bb			;			CALLMONITOR 
21bb			;		endif 
21bb			;	ld a, 0 
21bb			;	call strlent 
21bb			; 
21bb			;	inc hl 
21bb			;	inc hl 
21bb			;	inc hl 
21bb			;	inc hl 
21bb			; 
21bb			;	push hl    ; size 
21bb			; 
21bb			;		if DEBUG_FORTH_WORDS 
21bb			;			DMARK "EX2" 
21bb			;			CALLMONITOR 
21bb			;		endif 
21bb			;	call malloc 
21bb			; 
21bb			;	ex de, hl    ; de now contains malloc area 
21bb			;	pop bc   	; get byte count 
21bb			;	pop hl      ; get string to copy 
21bb			; 
21bb			;	push de     ; save malloc for free later 
21bb			; 
21bb			;		if DEBUG_FORTH_WORDS 
21bb			;			DMARK "EX3" 
21bb			;			CALLMONITOR 
21bb			;		endif 
21bb			;	ldir       ; duplicate string 
21bb			; 
21bb			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21bb			;	 
21bb			;	; TODO fix the parse would be better than this...  
21bb			;	ex de, hl 
21bb			;	dec hl 
21bb			;	ld a, 0 
21bb			;	ld (hl), a 
21bb			;	dec hl 
21bb			;	ld a, ' ' 
21bb			;	ld (hl), a 
21bb			;	dec hl 
21bb			;	ld (hl), a 
21bb			; 
21bb			;	dec hl 
21bb			;	ld (hl), a 
21bb			; 
21bb			; 
21bb			;	FORTH_DSP_POP  
21bb			; 
21bb			;	pop hl     
21bb			;	push hl    ; save malloc area 
21bb			; 
21bb			;		if DEBUG_FORTH_WORDS 
21bb			;			DMARK "EX4" 
21bb			;			CALLMONITOR 
21bb			;		endif 
21bb			; 
21bb			;	call forthparse 
21bb			;	call forthexec 
21bb			;	 
21bb			;	pop hl 
21bb			;	if DEBUG_FORTH_WORDS 
21bb			;		DMARK "EX5" 
21bb			;		CALLMONITOR 
21bb			;	endif 
21bb			; 
21bb			;	if FORTH_ENABLE_FREE 
21bb			;	call free 
21bb			;	endif 
21bb			; 
21bb			;	if DEBUG_FORTH_WORDS 
21bb			;		DMARK "EX6" 
21bb			;		CALLMONITOR 
21bb			;	endif 
21bb			; 
21bb			;	pop bc 
21bb			;	pop de 
21bb			;	pop hl 
21bb			;;	FORTH_RSP_POP	  
21bb			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21bb			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21bb			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21bb			; 
21bb			;	if DEBUG_FORTH_WORDS 
21bb			;		DMARK "EX7" 
21bb			;		CALLMONITOR 
21bb			;	endif 
21bb			;	NEXTW 
21bb			 
21bb			.STKEXEC: 
21bb				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21bb 3f				db WORD_SYS_CORE+43             
21bc 03 23			dw .ZDUP            
21be 08				db 7 + 1 
21bf .. 00			db "STKEXEC",0              
21c7				endm 
# End of macro CWHEAD
21c7			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
21c7			 
21c7			 
21c7					if DEBUG_FORTH_WORDS_KEY 
21c7						DMARK "STX" 
21c7 f5				push af  
21c8 3a dc 21			ld a, (.dmark)  
21cb 32 77 fb			ld (debug_mark),a  
21ce 3a dd 21			ld a, (.dmark+1)  
21d1 32 78 fb			ld (debug_mark+1),a  
21d4 3a de 21			ld a, (.dmark+2)  
21d7 32 79 fb			ld (debug_mark+2),a  
21da 18 03			jr .pastdmark  
21dc ..			.dmark: db "STX"  
21df f1			.pastdmark: pop af  
21e0			endm  
# End of macro DMARK
21e0						CALLMONITOR 
21e0 cd 92 16			call break_point_state  
21e3				endm  
# End of macro CALLMONITOR
21e3					endif 
21e3			 
21e3				FORTH_DSP_VALUEHL 
21e3 cd 16 1e			call macro_dsp_valuehl 
21e6				endm 
# End of macro FORTH_DSP_VALUEHL
21e6			 
21e6 22 60 f8			ld (store_tmp1), hl    ; count 
21e9			 
21e9				FORTH_DSP_POP 
21e9 cd ce 1e			call macro_forth_dsp_pop 
21ec				endm 
# End of macro FORTH_DSP_POP
21ec			.stkexec1: 
21ec 2a 60 f8			ld hl, (store_tmp1)   ; count 
21ef 3e 00			ld a, 0 
21f1 bd				cp l 
21f2 c8				ret z 
21f3			 
21f3 2b				dec hl 
21f4 22 60 f8			ld (store_tmp1), hl    ; count 
21f7				 
21f7				FORTH_DSP_VALUEHL 
21f7 cd 16 1e			call macro_dsp_valuehl 
21fa				endm 
# End of macro FORTH_DSP_VALUEHL
21fa e5				push hl 
21fb				 
21fb					if DEBUG_FORTH_WORDS 
21fb						DMARK "EXp" 
21fb f5				push af  
21fc 3a 10 22			ld a, (.dmark)  
21ff 32 77 fb			ld (debug_mark),a  
2202 3a 11 22			ld a, (.dmark+1)  
2205 32 78 fb			ld (debug_mark+1),a  
2208 3a 12 22			ld a, (.dmark+2)  
220b 32 79 fb			ld (debug_mark+2),a  
220e 18 03			jr .pastdmark  
2210 ..			.dmark: db "EXp"  
2213 f1			.pastdmark: pop af  
2214			endm  
# End of macro DMARK
2214						CALLMONITOR 
2214 cd 92 16			call break_point_state  
2217				endm  
# End of macro CALLMONITOR
2217					endif 
2217				FORTH_DSP_POP 
2217 cd ce 1e			call macro_forth_dsp_pop 
221a				endm 
# End of macro FORTH_DSP_POP
221a			 
221a cd 67 11			call strlenz 
221d 23				inc hl   ; include zero term to copy 
221e 23				inc hl   ; include zero term to copy 
221f 23				inc hl   ; include zero term to copy 
2220 06 00			ld b,0 
2222 4d				ld c,l 
2223 e1				pop hl 
2224 11 1c ef			ld de, execscratch 
2227					if DEBUG_FORTH_WORDS 
2227						DMARK "EX3" 
2227 f5				push af  
2228 3a 3c 22			ld a, (.dmark)  
222b 32 77 fb			ld (debug_mark),a  
222e 3a 3d 22			ld a, (.dmark+1)  
2231 32 78 fb			ld (debug_mark+1),a  
2234 3a 3e 22			ld a, (.dmark+2)  
2237 32 79 fb			ld (debug_mark+2),a  
223a 18 03			jr .pastdmark  
223c ..			.dmark: db "EX3"  
223f f1			.pastdmark: pop af  
2240			endm  
# End of macro DMARK
2240						CALLMONITOR 
2240 cd 92 16			call break_point_state  
2243				endm  
# End of macro CALLMONITOR
2243					endif 
2243 ed b0			ldir 
2245			 
2245			 
2245 21 1c ef			ld hl, execscratch 
2248			 
2248					if DEBUG_FORTH_WORDS 
2248						DMARK "EXP" 
2248 f5				push af  
2249 3a 5d 22			ld a, (.dmark)  
224c 32 77 fb			ld (debug_mark),a  
224f 3a 5e 22			ld a, (.dmark+1)  
2252 32 78 fb			ld (debug_mark+1),a  
2255 3a 5f 22			ld a, (.dmark+2)  
2258 32 79 fb			ld (debug_mark+2),a  
225b 18 03			jr .pastdmark  
225d ..			.dmark: db "EXP"  
2260 f1			.pastdmark: pop af  
2261			endm  
# End of macro DMARK
2261						CALLMONITOR 
2261 cd 92 16			call break_point_state  
2264				endm  
# End of macro CALLMONITOR
2264					endif 
2264			 
2264 cd d6 1f			call forthparse 
2267 21 1c ef			ld hl, execscratch 
226a					if DEBUG_FORTH_WORDS 
226a						DMARK "EXx" 
226a f5				push af  
226b 3a 7f 22			ld a, (.dmark)  
226e 32 77 fb			ld (debug_mark),a  
2271 3a 80 22			ld a, (.dmark+1)  
2274 32 78 fb			ld (debug_mark+1),a  
2277 3a 81 22			ld a, (.dmark+2)  
227a 32 79 fb			ld (debug_mark+2),a  
227d 18 03			jr .pastdmark  
227f ..			.dmark: db "EXx"  
2282 f1			.pastdmark: pop af  
2283			endm  
# End of macro DMARK
2283						CALLMONITOR 
2283 cd 92 16			call break_point_state  
2286				endm  
# End of macro CALLMONITOR
2286					endif 
2286 cd 16 20			call forthexec 
2289			 
2289 c3 ec 21			jp .stkexec1 
228c			 
228c c9				ret 
228d			 
228d			 
228d			.DUP: 
228d				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
228d 17				db WORD_SYS_CORE+OPCODE_DUP             
228e 03 23			dw .ZDUP            
2290 04				db 3 + 1 
2291 .. 00			db "DUP",0              
2295				endm 
# End of macro CWHEAD
2295			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2295			 
2295					if DEBUG_FORTH_WORDS_KEY 
2295						DMARK "DUP" 
2295 f5				push af  
2296 3a aa 22			ld a, (.dmark)  
2299 32 77 fb			ld (debug_mark),a  
229c 3a ab 22			ld a, (.dmark+1)  
229f 32 78 fb			ld (debug_mark+1),a  
22a2 3a ac 22			ld a, (.dmark+2)  
22a5 32 79 fb			ld (debug_mark+2),a  
22a8 18 03			jr .pastdmark  
22aa ..			.dmark: db "DUP"  
22ad f1			.pastdmark: pop af  
22ae			endm  
# End of macro DMARK
22ae						CALLMONITOR 
22ae cd 92 16			call break_point_state  
22b1				endm  
# End of macro CALLMONITOR
22b1					endif 
22b1			 
22b1					FORTH_DSP 
22b1 cd dc 1d			call macro_forth_dsp 
22b4				endm 
# End of macro FORTH_DSP
22b4			 
22b4 7e					ld a, (HL) 
22b5 fe 01				cp DS_TYPE_STR 
22b7 20 25				jr nz, .dupinum 
22b9			 
22b9					; push another string 
22b9			 
22b9					FORTH_DSP_VALUEHL     		 
22b9 cd 16 1e			call macro_dsp_valuehl 
22bc				endm 
# End of macro FORTH_DSP_VALUEHL
22bc			 
22bc				if DEBUG_FORTH_WORDS 
22bc					DMARK "DUs" 
22bc f5				push af  
22bd 3a d1 22			ld a, (.dmark)  
22c0 32 77 fb			ld (debug_mark),a  
22c3 3a d2 22			ld a, (.dmark+1)  
22c6 32 78 fb			ld (debug_mark+1),a  
22c9 3a d3 22			ld a, (.dmark+2)  
22cc 32 79 fb			ld (debug_mark+2),a  
22cf 18 03			jr .pastdmark  
22d1 ..			.dmark: db "DUs"  
22d4 f1			.pastdmark: pop af  
22d5			endm  
# End of macro DMARK
22d5					CALLMONITOR 
22d5 cd 92 16			call break_point_state  
22d8				endm  
# End of macro CALLMONITOR
22d8				endif 
22d8 cd 8d 1c				call forth_push_str 
22db			 
22db					NEXTW 
22db c3 88 1f			jp macro_next 
22de				endm 
# End of macro NEXTW
22de			 
22de			 
22de			.dupinum: 
22de					 
22de			 
22de			 
22de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22de cd 16 1e			call macro_dsp_valuehl 
22e1				endm 
# End of macro FORTH_DSP_VALUEHL
22e1			 
22e1				; TODO add floating point number detection 
22e1			 
22e1				if DEBUG_FORTH_WORDS 
22e1					DMARK "DUi" 
22e1 f5				push af  
22e2 3a f6 22			ld a, (.dmark)  
22e5 32 77 fb			ld (debug_mark),a  
22e8 3a f7 22			ld a, (.dmark+1)  
22eb 32 78 fb			ld (debug_mark+1),a  
22ee 3a f8 22			ld a, (.dmark+2)  
22f1 32 79 fb			ld (debug_mark+2),a  
22f4 18 03			jr .pastdmark  
22f6 ..			.dmark: db "DUi"  
22f9 f1			.pastdmark: pop af  
22fa			endm  
# End of macro DMARK
22fa					CALLMONITOR 
22fa cd 92 16			call break_point_state  
22fd				endm  
# End of macro CALLMONITOR
22fd				endif 
22fd			 
22fd cd 1f 1c				call forth_push_numhl 
2300					NEXTW 
2300 c3 88 1f			jp macro_next 
2303				endm 
# End of macro NEXTW
2303			.ZDUP: 
2303				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2303 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2304 3b 23			dw .SWAP            
2306 05				db 4 + 1 
2307 .. 00			db "?DUP",0              
230c				endm 
# End of macro CWHEAD
230c			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
230c			 
230c					if DEBUG_FORTH_WORDS_KEY 
230c						DMARK "qDU" 
230c f5				push af  
230d 3a 21 23			ld a, (.dmark)  
2310 32 77 fb			ld (debug_mark),a  
2313 3a 22 23			ld a, (.dmark+1)  
2316 32 78 fb			ld (debug_mark+1),a  
2319 3a 23 23			ld a, (.dmark+2)  
231c 32 79 fb			ld (debug_mark+2),a  
231f 18 03			jr .pastdmark  
2321 ..			.dmark: db "qDU"  
2324 f1			.pastdmark: pop af  
2325			endm  
# End of macro DMARK
2325						CALLMONITOR 
2325 cd 92 16			call break_point_state  
2328				endm  
# End of macro CALLMONITOR
2328					endif 
2328					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2328 cd 16 1e			call macro_dsp_valuehl 
232b				endm 
# End of macro FORTH_DSP_VALUEHL
232b			 
232b e5					push hl 
232c			 
232c					; is it a zero? 
232c			 
232c 3e 00				ld a, 0 
232e 84					add h 
232f 85					add l 
2330			 
2330 e1					pop hl 
2331			 
2331 fe 00				cp 0 
2333 28 03				jr z, .dup2orig 
2335			 
2335			 
2335 cd 1f 1c				call forth_push_numhl 
2338			 
2338			 
2338				; TODO add floating point number detection 
2338			 
2338			.dup2orig: 
2338			 
2338					NEXTW 
2338 c3 88 1f			jp macro_next 
233b				endm 
# End of macro NEXTW
233b			.SWAP: 
233b				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
233b 18				db WORD_SYS_CORE+OPCODE_SWAP             
233c 7a 23			dw .COLN            
233e 05				db 4 + 1 
233f .. 00			db "SWAP",0              
2344				endm 
# End of macro CWHEAD
2344			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2344					if DEBUG_FORTH_WORDS_KEY 
2344						DMARK "SWP" 
2344 f5				push af  
2345 3a 59 23			ld a, (.dmark)  
2348 32 77 fb			ld (debug_mark),a  
234b 3a 5a 23			ld a, (.dmark+1)  
234e 32 78 fb			ld (debug_mark+1),a  
2351 3a 5b 23			ld a, (.dmark+2)  
2354 32 79 fb			ld (debug_mark+2),a  
2357 18 03			jr .pastdmark  
2359 ..			.dmark: db "SWP"  
235c f1			.pastdmark: pop af  
235d			endm  
# End of macro DMARK
235d						CALLMONITOR 
235d cd 92 16			call break_point_state  
2360				endm  
# End of macro CALLMONITOR
2360					endif 
2360			 
2360					FORTH_DSP_VALUEHL 
2360 cd 16 1e			call macro_dsp_valuehl 
2363				endm 
# End of macro FORTH_DSP_VALUEHL
2363 e5					push hl     ; w2 
2364			 
2364					FORTH_DSP_POP 
2364 cd ce 1e			call macro_forth_dsp_pop 
2367				endm 
# End of macro FORTH_DSP_POP
2367			 
2367					FORTH_DSP_VALUEHL 
2367 cd 16 1e			call macro_dsp_valuehl 
236a				endm 
# End of macro FORTH_DSP_VALUEHL
236a			 
236a					FORTH_DSP_POP 
236a cd ce 1e			call macro_forth_dsp_pop 
236d				endm 
# End of macro FORTH_DSP_POP
236d			 
236d d1					pop de     ; w2	, hl = w1 
236e			 
236e eb					ex de, hl 
236f d5					push de 
2370			 
2370 cd 1f 1c				call forth_push_numhl 
2373			 
2373 e1					pop hl 
2374			 
2374 cd 1f 1c				call forth_push_numhl 
2377					 
2377			 
2377					NEXTW 
2377 c3 88 1f			jp macro_next 
237a				endm 
# End of macro NEXTW
237a			.COLN: 
237a				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
237a 19				db WORD_SYS_CORE+OPCODE_COLN             
237b 06 25			dw .SCOLN            
237d 02				db 1 + 1 
237e .. 00			db ":",0              
2380				endm 
# End of macro CWHEAD
2380			; | : ( -- )         Create new word | DONE 
2380			 
2380					if DEBUG_FORTH_WORDS_KEY 
2380						DMARK "CLN" 
2380 f5				push af  
2381 3a 95 23			ld a, (.dmark)  
2384 32 77 fb			ld (debug_mark),a  
2387 3a 96 23			ld a, (.dmark+1)  
238a 32 78 fb			ld (debug_mark+1),a  
238d 3a 97 23			ld a, (.dmark+2)  
2390 32 79 fb			ld (debug_mark+2),a  
2393 18 03			jr .pastdmark  
2395 ..			.dmark: db "CLN"  
2398 f1			.pastdmark: pop af  
2399			endm  
# End of macro DMARK
2399						CALLMONITOR 
2399 cd 92 16			call break_point_state  
239c				endm  
# End of macro CALLMONITOR
239c					endif 
239c				STACKFRAME OFF $8efe $989f 
239c				if DEBUG_STACK_IMB 
239c					if OFF 
239c						exx 
239c						ld de, $8efe 
239c						ld a, d 
239c						ld hl, curframe 
239c						call hexout 
239c						ld a, e 
239c						ld hl, curframe+2 
239c						call hexout 
239c						ld hl, $8efe 
239c						push hl 
239c						ld hl, $989f 
239c						push hl 
239c						exx 
239c					endif 
239c				endif 
239c			endm 
# End of macro STACKFRAME
239c				; get parser buffer length  of new word 
239c			 
239c				 
239c			 
239c					; move tok past this to start of name defintition 
239c					; TODO get word to define 
239c					; TODO Move past word token 
239c					; TODO get length of string up to the ';' 
239c			 
239c 2a 1e f1			ld hl, (os_tok_ptr) 
239f 23				inc hl 
23a0 23				inc hl 
23a1			 
23a1 3e 3b			ld a, ';' 
23a3 cd 72 11			call strlent 
23a6			 
23a6 7d				ld a,l 
23a7 32 19 ee			ld (os_new_parse_len), a 
23aa			 
23aa			 
23aa			if DEBUG_FORTH_UWORD 
23aa ed 5b 1e f1		ld de, (os_tok_ptr) 
23ae						DMARK ":01" 
23ae f5				push af  
23af 3a c3 23			ld a, (.dmark)  
23b2 32 77 fb			ld (debug_mark),a  
23b5 3a c4 23			ld a, (.dmark+1)  
23b8 32 78 fb			ld (debug_mark+1),a  
23bb 3a c5 23			ld a, (.dmark+2)  
23be 32 79 fb			ld (debug_mark+2),a  
23c1 18 03			jr .pastdmark  
23c3 ..			.dmark: db ":01"  
23c6 f1			.pastdmark: pop af  
23c7			endm  
# End of macro DMARK
23c7				CALLMONITOR 
23c7 cd 92 16			call break_point_state  
23ca				endm  
# End of macro CALLMONITOR
23ca			endif 
23ca			 
23ca			; 
23ca			;  new word memory layout: 
23ca			;  
23ca			;    : adg 6666 ;  
23ca			; 
23ca			;    db   1     ; user defined word  
23ca 23				inc hl    
23cb			;    dw   sysdict 
23cb 23				inc hl 
23cc 23				inc hl 
23cd			;    db <word len>+1 (for null) 
23cd 23				inc hl 
23ce			;    db .... <word> 
23ce			; 
23ce			 
23ce 23				inc hl    ; some extras for the word preamble before the above 
23cf 23				inc hl 
23d0 23				inc hl 
23d1 23				inc hl 
23d2 23				inc hl 
23d3 23				inc hl 
23d4 23				inc hl  
23d5 23				inc hl 
23d6 23				inc hl 
23d7 23				inc hl 
23d8 23				inc hl 
23d9 23				inc hl 
23da 23				inc hl 
23db 23				inc hl     ; TODO how many do we really need?     maybe only 6 
23dc			;       exec word buffer 
23dc			;	<ptr word>   
23dc 23				inc hl 
23dd 23				inc hl 
23de			;       <word list><null term> 7F final term 
23de			 
23de			 
23de			if DEBUG_FORTH_UWORD 
23de						DMARK ":02" 
23de f5				push af  
23df 3a f3 23			ld a, (.dmark)  
23e2 32 77 fb			ld (debug_mark),a  
23e5 3a f4 23			ld a, (.dmark+1)  
23e8 32 78 fb			ld (debug_mark+1),a  
23eb 3a f5 23			ld a, (.dmark+2)  
23ee 32 79 fb			ld (debug_mark+2),a  
23f1 18 03			jr .pastdmark  
23f3 ..			.dmark: db ":02"  
23f6 f1			.pastdmark: pop af  
23f7			endm  
# End of macro DMARK
23f7				CALLMONITOR 
23f7 cd 92 16			call break_point_state  
23fa				endm  
# End of macro CALLMONITOR
23fa			endif 
23fa			 
23fa				 
23fa					; malloc the size 
23fa			 
23fa cd d0 11				call malloc 
23fd 22 1b ee				ld (os_new_malloc), hl     ; save malloc start 
2400			 
2400			;    db   1     ; user defined word  
2400 3e 01				ld a, WORD_SYS_UWORD  
2402 77					ld (hl), a 
2403				 
2403 23				inc hl    
2404			;    dw   sysdict 
2404 11 e0 20			ld de, sysdict       ; continue on with the scan to the system dict 
2407 73				ld (hl), e 
2408 23				inc hl 
2409 72				ld (hl), d 
240a 23				inc hl 
240b			 
240b			 
240b			;    Setup dict word 
240b			 
240b 23				inc hl 
240c 22 15 ee			ld (os_new_work_ptr), hl     ; save start of dict word  
240f			 
240f				; 1. get length of dict word 
240f			 
240f			 
240f 2a 1e f1			ld hl, (os_tok_ptr) 
2412 23				inc hl 
2413 23				inc hl    ; position to start of dict word 
2414 3e 00			ld a, 0 
2416 cd 72 11			call strlent 
2419			 
2419			 
2419 23				inc hl    ; to include null??? 
241a			 
241a				; write length of dict word 
241a			 
241a ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
241e 1b				dec de 
241f eb				ex de, hl 
2420 73				ld (hl), e 
2421 eb				ex de, hl 
2422			 
2422				 
2422			 
2422				; copy  
2422 4d				ld c, l 
2423 06 00			ld b, 0 
2425 ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2429 2a 1e f1			ld hl, (os_tok_ptr) 
242c 23				inc hl 
242d 23				inc hl    ; position to start of dict word 
242e				 
242e			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
242e				 
242e				; TODO need to convert word to upper case 
242e			 
242e			ucasetok:	 
242e 7e				ld a,(hl) 
242f cd 5e 11			call toUpper 
2432 77				ld (hl),a 
2433 ed a0			ldi 
2435 f2 2e 24		 	jp p, ucasetok 
2438			 
2438			 
2438			 
2438				; de now points to start of where the word body code should be placed 
2438 ed 53 15 ee		ld (os_new_work_ptr), de 
243c				; hl now points to the words to throw at forthexec which needs to be copied 
243c 22 13 ee			ld (os_new_src_ptr), hl 
243f			 
243f				; TODO add 'call to forthexec' 
243f			 
243f			if DEBUG_FORTH_UWORD 
243f c5				push bc 
2440 ed 4b 1b ee		ld bc, (os_new_malloc) 
2444						DMARK ":0x" 
2444 f5				push af  
2445 3a 59 24			ld a, (.dmark)  
2448 32 77 fb			ld (debug_mark),a  
244b 3a 5a 24			ld a, (.dmark+1)  
244e 32 78 fb			ld (debug_mark+1),a  
2451 3a 5b 24			ld a, (.dmark+2)  
2454 32 79 fb			ld (debug_mark+2),a  
2457 18 03			jr .pastdmark  
2459 ..			.dmark: db ":0x"  
245c f1			.pastdmark: pop af  
245d			endm  
# End of macro DMARK
245d				CALLMONITOR 
245d cd 92 16			call break_point_state  
2460				endm  
# End of macro CALLMONITOR
2460 c1				pop bc 
2461			endif 
2461			 
2461			 
2461				; create word preamble which should be: 
2461			 
2461			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2461			 
2461				;    ld hl, <word code> 
2461				;    jp user_exec 
2461			        ;    <word code bytes> 
2461			 
2461			 
2461			;	inc de     ; TODO ??? or are we already past the word's null 
2461 eb				ex de, hl 
2462			 
2462 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2464			 
2464 23				inc hl 
2465 22 0f ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2468 23				inc hl 
2469			 
2469 23				inc hl 
246a 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
246c			 
246c 01 71 51			ld bc, user_exec 
246f 23				inc hl 
2470 71				ld (hl), c     ; poke address of user_exec 
2471 23				inc hl 
2472 70				ld (hl), b     
2473			 ; 
2473			;	inc hl 
2473			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2473			; 
2473			; 
2473			;	ld bc, macro_forth_rsp_next 
2473			;	inc hl 
2473			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2473			;	inc hl 
2473			;	ld (hl), b     
2473			 ; 
2473			;	inc hl 
2473			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2473			; 
2473			; 
2473			;	inc hl 
2473			;	ld bc, forthexec 
2473			;	ld (hl), c     ; poke address of forthexec 
2473			;	inc hl 
2473			;	ld (hl), b      
2473			; 
2473			;	inc hl 
2473			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2473			; 
2473			;	ld bc, user_dict_next 
2473			;	inc hl 
2473			;	ld (hl), c     ; poke address of forthexec 
2473			;	inc hl 
2473			;	ld (hl), b      
2473			 
2473				; hl is now where we need to copy the word byte data to save this 
2473			 
2473 23				inc hl 
2474 22 11 ee			ld (os_new_exec), hl 
2477				 
2477				; copy definition 
2477			 
2477 eb				ex de, hl 
2478			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2478			;	inc de    ; skip the PC for this parse 
2478 3a 19 ee			ld a, (os_new_parse_len) 
247b 4f				ld c, a 
247c 06 00			ld b, 0 
247e ed b0			ldir		 ; copy defintion 
2480			 
2480			 
2480				; poke the address of where the new word bytes live for forthexec 
2480			 
2480 2a 0f ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2483			 
2483 ed 5b 11 ee		ld de, (os_new_exec)      
2487				 
2487 73				ld (hl), e 
2488 23				inc hl 
2489 72				ld (hl), d 
248a			 
248a					; TODO copy last user dict word next link to this word 
248a					; TODO update last user dict word to point to this word 
248a			; 
248a			; hl f923 de 812a ; bc 811a 
248a			 
248a			if DEBUG_FORTH_UWORD 
248a c5				push bc 
248b ed 4b 1b ee		ld bc, (os_new_malloc) 
248f						DMARK ":0A" 
248f f5				push af  
2490 3a a4 24			ld a, (.dmark)  
2493 32 77 fb			ld (debug_mark),a  
2496 3a a5 24			ld a, (.dmark+1)  
2499 32 78 fb			ld (debug_mark+1),a  
249c 3a a6 24			ld a, (.dmark+2)  
249f 32 79 fb			ld (debug_mark+2),a  
24a2 18 03			jr .pastdmark  
24a4 ..			.dmark: db ":0A"  
24a7 f1			.pastdmark: pop af  
24a8			endm  
# End of macro DMARK
24a8				CALLMONITOR 
24a8 cd 92 16			call break_point_state  
24ab				endm  
# End of macro CALLMONITOR
24ab c1				pop bc 
24ac			endif 
24ac			if DEBUG_FORTH_UWORD 
24ac c5				push bc 
24ad ed 4b 1b ee		ld bc, (os_new_malloc) 
24b1 03				inc bc 
24b2 03				inc bc 
24b3 03				inc bc 
24b4 03				inc bc 
24b5 03				inc bc 
24b6 03				inc bc 
24b7 03				inc bc 
24b8 03				inc bc 
24b9			 
24b9						DMARK ":0B" 
24b9 f5				push af  
24ba 3a ce 24			ld a, (.dmark)  
24bd 32 77 fb			ld (debug_mark),a  
24c0 3a cf 24			ld a, (.dmark+1)  
24c3 32 78 fb			ld (debug_mark+1),a  
24c6 3a d0 24			ld a, (.dmark+2)  
24c9 32 79 fb			ld (debug_mark+2),a  
24cc 18 03			jr .pastdmark  
24ce ..			.dmark: db ":0B"  
24d1 f1			.pastdmark: pop af  
24d2			endm  
# End of macro DMARK
24d2				CALLMONITOR 
24d2 cd 92 16			call break_point_state  
24d5				endm  
# End of macro CALLMONITOR
24d5 c1				pop bc 
24d6			endif 
24d6			 
24d6			; update word dict linked list for new word 
24d6			 
24d6			 
24d6 2a 1a f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
24d9 23			inc hl     ; move to next work linked list ptr 
24da			 
24da ed 5b 1b ee	ld de, (os_new_malloc)		 ; new next word 
24de 73			ld (hl), e 
24df 23			inc hl 
24e0 72			ld (hl), d 
24e1			 
24e1			if DEBUG_FORTH_UWORD 
24e1 ed 4b 1a f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
24e5			endif 
24e5			 
24e5 ed 53 1a f1	ld (os_last_new_uword), de      ; update last new uword ptr 
24e9			 
24e9			 
24e9			if DEBUG_FORTH_UWORD 
24e9						DMARK ":0+" 
24e9 f5				push af  
24ea 3a fe 24			ld a, (.dmark)  
24ed 32 77 fb			ld (debug_mark),a  
24f0 3a ff 24			ld a, (.dmark+1)  
24f3 32 78 fb			ld (debug_mark+1),a  
24f6 3a 00 25			ld a, (.dmark+2)  
24f9 32 79 fb			ld (debug_mark+2),a  
24fc 18 03			jr .pastdmark  
24fe ..			.dmark: db ":0+"  
2501 f1			.pastdmark: pop af  
2502			endm  
# End of macro DMARK
2502				CALLMONITOR 
2502 cd 92 16			call break_point_state  
2505				endm  
# End of macro CALLMONITOR
2505			endif 
2505			 
2505				STACKFRAMECHK OFF $8efe $989f 
2505				if DEBUG_STACK_IMB 
2505					if OFF 
2505						exx 
2505						ld hl, $989f 
2505						pop de   ; $989f 
2505						call cmp16 
2505						jr nz, .spnosame 
2505						ld hl, $8efe 
2505						pop de   ; $8efe 
2505						call cmp16 
2505						jr z, .spfrsame 
2505						.spnosame: call showsperror 
2505						.spfrsame: nop 
2505						exx 
2505					endif 
2505				endif 
2505			endm 
# End of macro STACKFRAMECHK
2505			 
2505 c9			ret    ; dont process any remaining parser tokens as they form new word 
2506			 
2506			 
2506			 
2506			 
2506			;		NEXT 
2506			.SCOLN: 
2506			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2506 06				db OPCODE_SCOLN 
2507 52 25			dw .DROP 
2509 02				db 2 
250a .. 00			db ";",0           
250c			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
250c					if DEBUG_FORTH_WORDS_KEY 
250c						DMARK "SCN" 
250c f5				push af  
250d 3a 21 25			ld a, (.dmark)  
2510 32 77 fb			ld (debug_mark),a  
2513 3a 22 25			ld a, (.dmark+1)  
2516 32 78 fb			ld (debug_mark+1),a  
2519 3a 23 25			ld a, (.dmark+2)  
251c 32 79 fb			ld (debug_mark+2),a  
251f 18 03			jr .pastdmark  
2521 ..			.dmark: db "SCN"  
2524 f1			.pastdmark: pop af  
2525			endm  
# End of macro DMARK
2525						CALLMONITOR 
2525 cd 92 16			call break_point_state  
2528				endm  
# End of macro CALLMONITOR
2528					endif 
2528					FORTH_RSP_TOS 
2528 cd dd 1b			call macro_forth_rsp_tos 
252b				endm 
# End of macro FORTH_RSP_TOS
252b e5					push hl 
252c					FORTH_RSP_POP 
252c cd e7 1b			call macro_forth_rsp_pop 
252f				endm 
# End of macro FORTH_RSP_POP
252f e1					pop hl 
2530			;		ex de,hl 
2530 22 1e f1				ld (os_tok_ptr),hl 
2533			 
2533			if DEBUG_FORTH_UWORD 
2533						DMARK "SCL" 
2533 f5				push af  
2534 3a 48 25			ld a, (.dmark)  
2537 32 77 fb			ld (debug_mark),a  
253a 3a 49 25			ld a, (.dmark+1)  
253d 32 78 fb			ld (debug_mark+1),a  
2540 3a 4a 25			ld a, (.dmark+2)  
2543 32 79 fb			ld (debug_mark+2),a  
2546 18 03			jr .pastdmark  
2548 ..			.dmark: db "SCL"  
254b f1			.pastdmark: pop af  
254c			endm  
# End of macro DMARK
254c				CALLMONITOR 
254c cd 92 16			call break_point_state  
254f				endm  
# End of macro CALLMONITOR
254f			endif 
254f					NEXTW 
254f c3 88 1f			jp macro_next 
2552				endm 
# End of macro NEXTW
2552			 
2552			.DROP: 
2552				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2552 1b				db WORD_SYS_CORE+OPCODE_DROP             
2553 7d 25			dw .DUP2            
2555 05				db 4 + 1 
2556 .. 00			db "DROP",0              
255b				endm 
# End of macro CWHEAD
255b			; | DROP ( w -- )   drop the TOS item   | DONE 
255b					if DEBUG_FORTH_WORDS_KEY 
255b						DMARK "DRP" 
255b f5				push af  
255c 3a 70 25			ld a, (.dmark)  
255f 32 77 fb			ld (debug_mark),a  
2562 3a 71 25			ld a, (.dmark+1)  
2565 32 78 fb			ld (debug_mark+1),a  
2568 3a 72 25			ld a, (.dmark+2)  
256b 32 79 fb			ld (debug_mark+2),a  
256e 18 03			jr .pastdmark  
2570 ..			.dmark: db "DRP"  
2573 f1			.pastdmark: pop af  
2574			endm  
# End of macro DMARK
2574						CALLMONITOR 
2574 cd 92 16			call break_point_state  
2577				endm  
# End of macro CALLMONITOR
2577					endif 
2577					FORTH_DSP_POP 
2577 cd ce 1e			call macro_forth_dsp_pop 
257a				endm 
# End of macro FORTH_DSP_POP
257a					NEXTW 
257a c3 88 1f			jp macro_next 
257d				endm 
# End of macro NEXTW
257d			.DUP2: 
257d				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
257d 1c				db WORD_SYS_CORE+OPCODE_DUP2             
257e c2 25			dw .DROP2            
2580 05				db 4 + 1 
2581 .. 00			db "2DUP",0              
2586				endm 
# End of macro CWHEAD
2586			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2586					if DEBUG_FORTH_WORDS_KEY 
2586						DMARK "2DU" 
2586 f5				push af  
2587 3a 9b 25			ld a, (.dmark)  
258a 32 77 fb			ld (debug_mark),a  
258d 3a 9c 25			ld a, (.dmark+1)  
2590 32 78 fb			ld (debug_mark+1),a  
2593 3a 9d 25			ld a, (.dmark+2)  
2596 32 79 fb			ld (debug_mark+2),a  
2599 18 03			jr .pastdmark  
259b ..			.dmark: db "2DU"  
259e f1			.pastdmark: pop af  
259f			endm  
# End of macro DMARK
259f						CALLMONITOR 
259f cd 92 16			call break_point_state  
25a2				endm  
# End of macro CALLMONITOR
25a2					endif 
25a2					FORTH_DSP_VALUEHL 
25a2 cd 16 1e			call macro_dsp_valuehl 
25a5				endm 
# End of macro FORTH_DSP_VALUEHL
25a5 e5					push hl      ; 2 
25a6			 
25a6					FORTH_DSP_POP 
25a6 cd ce 1e			call macro_forth_dsp_pop 
25a9				endm 
# End of macro FORTH_DSP_POP
25a9					 
25a9					FORTH_DSP_VALUEHL 
25a9 cd 16 1e			call macro_dsp_valuehl 
25ac				endm 
# End of macro FORTH_DSP_VALUEHL
25ac			;		push hl      ; 1 
25ac			 
25ac					FORTH_DSP_POP 
25ac cd ce 1e			call macro_forth_dsp_pop 
25af				endm 
# End of macro FORTH_DSP_POP
25af			 
25af			;		pop hl       ; 1 
25af d1					pop de       ; 2 
25b0			 
25b0 cd 1f 1c				call forth_push_numhl 
25b3 eb					ex de, hl 
25b4 cd 1f 1c				call forth_push_numhl 
25b7			 
25b7					 
25b7 eb					ex de, hl 
25b8			 
25b8 cd 1f 1c				call forth_push_numhl 
25bb eb					ex de, hl 
25bc cd 1f 1c				call forth_push_numhl 
25bf			 
25bf			 
25bf					NEXTW 
25bf c3 88 1f			jp macro_next 
25c2				endm 
# End of macro NEXTW
25c2			.DROP2: 
25c2				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
25c2 1d				db WORD_SYS_CORE+OPCODE_DROP2             
25c3 f1 25			dw .SWAP2            
25c5 06				db 5 + 1 
25c6 .. 00			db "2DROP",0              
25cc				endm 
# End of macro CWHEAD
25cc			; | 2DROP ( w w -- )    Double drop | DONE 
25cc					if DEBUG_FORTH_WORDS_KEY 
25cc						DMARK "2DR" 
25cc f5				push af  
25cd 3a e1 25			ld a, (.dmark)  
25d0 32 77 fb			ld (debug_mark),a  
25d3 3a e2 25			ld a, (.dmark+1)  
25d6 32 78 fb			ld (debug_mark+1),a  
25d9 3a e3 25			ld a, (.dmark+2)  
25dc 32 79 fb			ld (debug_mark+2),a  
25df 18 03			jr .pastdmark  
25e1 ..			.dmark: db "2DR"  
25e4 f1			.pastdmark: pop af  
25e5			endm  
# End of macro DMARK
25e5						CALLMONITOR 
25e5 cd 92 16			call break_point_state  
25e8				endm  
# End of macro CALLMONITOR
25e8					endif 
25e8					FORTH_DSP_POP 
25e8 cd ce 1e			call macro_forth_dsp_pop 
25eb				endm 
# End of macro FORTH_DSP_POP
25eb					FORTH_DSP_POP 
25eb cd ce 1e			call macro_forth_dsp_pop 
25ee				endm 
# End of macro FORTH_DSP_POP
25ee					NEXTW 
25ee c3 88 1f			jp macro_next 
25f1				endm 
# End of macro NEXTW
25f1			.SWAP2: 
25f1				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
25f1 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
25f2 1a 26			dw .AT            
25f4 06				db 5 + 1 
25f5 .. 00			db "2SWAP",0              
25fb				endm 
# End of macro CWHEAD
25fb			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
25fb					if DEBUG_FORTH_WORDS_KEY 
25fb						DMARK "2SW" 
25fb f5				push af  
25fc 3a 10 26			ld a, (.dmark)  
25ff 32 77 fb			ld (debug_mark),a  
2602 3a 11 26			ld a, (.dmark+1)  
2605 32 78 fb			ld (debug_mark+1),a  
2608 3a 12 26			ld a, (.dmark+2)  
260b 32 79 fb			ld (debug_mark+2),a  
260e 18 03			jr .pastdmark  
2610 ..			.dmark: db "2SW"  
2613 f1			.pastdmark: pop af  
2614			endm  
# End of macro DMARK
2614						CALLMONITOR 
2614 cd 92 16			call break_point_state  
2617				endm  
# End of macro CALLMONITOR
2617					endif 
2617					NEXTW 
2617 c3 88 1f			jp macro_next 
261a				endm 
# End of macro NEXTW
261a			.AT: 
261a				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
261a 1f				db WORD_SYS_CORE+OPCODE_AT             
261b 4c 26			dw .CAT            
261d 02				db 1 + 1 
261e .. 00			db "@",0              
2620				endm 
# End of macro CWHEAD
2620			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2620			 
2620					if DEBUG_FORTH_WORDS_KEY 
2620						DMARK "AT." 
2620 f5				push af  
2621 3a 35 26			ld a, (.dmark)  
2624 32 77 fb			ld (debug_mark),a  
2627 3a 36 26			ld a, (.dmark+1)  
262a 32 78 fb			ld (debug_mark+1),a  
262d 3a 37 26			ld a, (.dmark+2)  
2630 32 79 fb			ld (debug_mark+2),a  
2633 18 03			jr .pastdmark  
2635 ..			.dmark: db "AT."  
2638 f1			.pastdmark: pop af  
2639			endm  
# End of macro DMARK
2639						CALLMONITOR 
2639 cd 92 16			call break_point_state  
263c				endm  
# End of macro CALLMONITOR
263c					endif 
263c			.getbyteat:	 
263c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
263c cd 16 1e			call macro_dsp_valuehl 
263f				endm 
# End of macro FORTH_DSP_VALUEHL
263f					 
263f			;		push hl 
263f				 
263f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
263f cd ce 1e			call macro_forth_dsp_pop 
2642				endm 
# End of macro FORTH_DSP_POP
2642			 
2642			;		pop hl 
2642			 
2642 7e					ld a, (hl) 
2643			 
2643 6f					ld l, a 
2644 26 00				ld h, 0 
2646 cd 1f 1c				call forth_push_numhl 
2649			 
2649					NEXTW 
2649 c3 88 1f			jp macro_next 
264c				endm 
# End of macro NEXTW
264c			.CAT: 
264c				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
264c 20				db WORD_SYS_CORE+OPCODE_CAT             
264d 75 26			dw .BANG            
264f 03				db 2 + 1 
2650 .. 00			db "C@",0              
2653				endm 
# End of macro CWHEAD
2653			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2653					if DEBUG_FORTH_WORDS_KEY 
2653						DMARK "CAA" 
2653 f5				push af  
2654 3a 68 26			ld a, (.dmark)  
2657 32 77 fb			ld (debug_mark),a  
265a 3a 69 26			ld a, (.dmark+1)  
265d 32 78 fb			ld (debug_mark+1),a  
2660 3a 6a 26			ld a, (.dmark+2)  
2663 32 79 fb			ld (debug_mark+2),a  
2666 18 03			jr .pastdmark  
2668 ..			.dmark: db "CAA"  
266b f1			.pastdmark: pop af  
266c			endm  
# End of macro DMARK
266c						CALLMONITOR 
266c cd 92 16			call break_point_state  
266f				endm  
# End of macro CALLMONITOR
266f					endif 
266f c3 3c 26				jp .getbyteat 
2672					NEXTW 
2672 c3 88 1f			jp macro_next 
2675				endm 
# End of macro NEXTW
2675			.BANG: 
2675				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2675 21				db WORD_SYS_CORE+OPCODE_BANG             
2676 ab 26			dw .CBANG            
2678 02				db 1 + 1 
2679 .. 00			db "!",0              
267b				endm 
# End of macro CWHEAD
267b			; | ! ( x w -- ) Store x at address w      | DONE 
267b					if DEBUG_FORTH_WORDS_KEY 
267b						DMARK "BNG" 
267b f5				push af  
267c 3a 90 26			ld a, (.dmark)  
267f 32 77 fb			ld (debug_mark),a  
2682 3a 91 26			ld a, (.dmark+1)  
2685 32 78 fb			ld (debug_mark+1),a  
2688 3a 92 26			ld a, (.dmark+2)  
268b 32 79 fb			ld (debug_mark+2),a  
268e 18 03			jr .pastdmark  
2690 ..			.dmark: db "BNG"  
2693 f1			.pastdmark: pop af  
2694			endm  
# End of macro DMARK
2694						CALLMONITOR 
2694 cd 92 16			call break_point_state  
2697				endm  
# End of macro CALLMONITOR
2697					endif 
2697			 
2697			.storebyteat:		 
2697					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2697 cd 16 1e			call macro_dsp_valuehl 
269a				endm 
# End of macro FORTH_DSP_VALUEHL
269a					 
269a e5					push hl 
269b				 
269b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
269b cd ce 1e			call macro_forth_dsp_pop 
269e				endm 
# End of macro FORTH_DSP_POP
269e			 
269e					; get byte to poke 
269e			 
269e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
269e cd 16 1e			call macro_dsp_valuehl 
26a1				endm 
# End of macro FORTH_DSP_VALUEHL
26a1 e5					push hl 
26a2			 
26a2			 
26a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26a2 cd ce 1e			call macro_forth_dsp_pop 
26a5				endm 
# End of macro FORTH_DSP_POP
26a5			 
26a5			 
26a5 d1					pop de 
26a6 e1					pop hl 
26a7			 
26a7 73					ld (hl),e 
26a8			 
26a8			 
26a8					NEXTW 
26a8 c3 88 1f			jp macro_next 
26ab				endm 
# End of macro NEXTW
26ab			.CBANG: 
26ab				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
26ab 22				db WORD_SYS_CORE+OPCODE_CBANG             
26ac d4 26			dw .SCALL            
26ae 03				db 2 + 1 
26af .. 00			db "C!",0              
26b2				endm 
# End of macro CWHEAD
26b2			; | C!  ( x w -- ) Store x at address w  | DONE 
26b2					if DEBUG_FORTH_WORDS_KEY 
26b2						DMARK "CBA" 
26b2 f5				push af  
26b3 3a c7 26			ld a, (.dmark)  
26b6 32 77 fb			ld (debug_mark),a  
26b9 3a c8 26			ld a, (.dmark+1)  
26bc 32 78 fb			ld (debug_mark+1),a  
26bf 3a c9 26			ld a, (.dmark+2)  
26c2 32 79 fb			ld (debug_mark+2),a  
26c5 18 03			jr .pastdmark  
26c7 ..			.dmark: db "CBA"  
26ca f1			.pastdmark: pop af  
26cb			endm  
# End of macro DMARK
26cb						CALLMONITOR 
26cb cd 92 16			call break_point_state  
26ce				endm  
# End of macro CALLMONITOR
26ce					endif 
26ce c3 97 26				jp .storebyteat 
26d1					NEXTW 
26d1 c3 88 1f			jp macro_next 
26d4				endm 
# End of macro NEXTW
26d4			.SCALL: 
26d4				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
26d4 23				db WORD_SYS_CORE+OPCODE_SCALL             
26d5 08 27			dw .DEPTH            
26d7 05				db 4 + 1 
26d8 .. 00			db "CALL",0              
26dd				endm 
# End of macro CWHEAD
26dd			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
26dd					if DEBUG_FORTH_WORDS_KEY 
26dd						DMARK "CLL" 
26dd f5				push af  
26de 3a f2 26			ld a, (.dmark)  
26e1 32 77 fb			ld (debug_mark),a  
26e4 3a f3 26			ld a, (.dmark+1)  
26e7 32 78 fb			ld (debug_mark+1),a  
26ea 3a f4 26			ld a, (.dmark+2)  
26ed 32 79 fb			ld (debug_mark+2),a  
26f0 18 03			jr .pastdmark  
26f2 ..			.dmark: db "CLL"  
26f5 f1			.pastdmark: pop af  
26f6			endm  
# End of macro DMARK
26f6						CALLMONITOR 
26f6 cd 92 16			call break_point_state  
26f9				endm  
# End of macro CALLMONITOR
26f9					endif 
26f9			 
26f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f9 cd 16 1e			call macro_dsp_valuehl 
26fc				endm 
# End of macro FORTH_DSP_VALUEHL
26fc			 
26fc			;		push hl 
26fc			 
26fc					; destroy value TOS 
26fc			 
26fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26fc cd ce 1e			call macro_forth_dsp_pop 
26ff				endm 
# End of macro FORTH_DSP_POP
26ff			 
26ff						 
26ff			;		pop hl 
26ff			 
26ff					; how to do a call with hl???? save SP? 
26ff cd 31 1f				call forth_call_hl 
2702			 
2702			 
2702					; TODO push value back onto stack for another op etc 
2702			 
2702 cd 1f 1c				call forth_push_numhl 
2705					NEXTW 
2705 c3 88 1f			jp macro_next 
2708				endm 
# End of macro NEXTW
2708			.DEPTH: 
2708				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2708 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2709 45 27			dw .OVER            
270b 06				db 5 + 1 
270c .. 00			db "DEPTH",0              
2712				endm 
# End of macro CWHEAD
2712			; | DEPTH ( -- u ) Push count of stack | DONE 
2712					; take current TOS and remove from base value div by two to get count 
2712					if DEBUG_FORTH_WORDS_KEY 
2712						DMARK "DEP" 
2712 f5				push af  
2713 3a 27 27			ld a, (.dmark)  
2716 32 77 fb			ld (debug_mark),a  
2719 3a 28 27			ld a, (.dmark+1)  
271c 32 78 fb			ld (debug_mark+1),a  
271f 3a 29 27			ld a, (.dmark+2)  
2722 32 79 fb			ld (debug_mark+2),a  
2725 18 03			jr .pastdmark  
2727 ..			.dmark: db "DEP"  
272a f1			.pastdmark: pop af  
272b			endm  
# End of macro DMARK
272b						CALLMONITOR 
272b cd 92 16			call break_point_state  
272e				endm  
# End of macro CALLMONITOR
272e					endif 
272e			 
272e			 
272e 2a 0a f8			ld hl, (cli_data_sp) 
2731 11 84 f3			ld de, cli_data_stack 
2734 ed 52			sbc hl,de 
2736				 
2736				; div by size of stack item 
2736			 
2736 5d				ld e,l 
2737 0e 03			ld c, 3 
2739 cd 99 0c			call Div8 
273c			 
273c 6f				ld l,a 
273d 26 00			ld h,0 
273f			 
273f				;srl h 
273f				;rr l 
273f			 
273f cd 1f 1c				call forth_push_numhl 
2742					NEXTW 
2742 c3 88 1f			jp macro_next 
2745				endm 
# End of macro NEXTW
2745			.OVER: 
2745				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2745 42				db WORD_SYS_CORE+46             
2746 8c 27			dw .PAUSE            
2748 05				db 4 + 1 
2749 .. 00			db "OVER",0              
274e				endm 
# End of macro CWHEAD
274e			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
274e					if DEBUG_FORTH_WORDS_KEY 
274e						DMARK "OVR" 
274e f5				push af  
274f 3a 63 27			ld a, (.dmark)  
2752 32 77 fb			ld (debug_mark),a  
2755 3a 64 27			ld a, (.dmark+1)  
2758 32 78 fb			ld (debug_mark+1),a  
275b 3a 65 27			ld a, (.dmark+2)  
275e 32 79 fb			ld (debug_mark+2),a  
2761 18 03			jr .pastdmark  
2763 ..			.dmark: db "OVR"  
2766 f1			.pastdmark: pop af  
2767			endm  
# End of macro DMARK
2767						CALLMONITOR 
2767 cd 92 16			call break_point_state  
276a				endm  
# End of macro CALLMONITOR
276a					endif 
276a			 
276a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
276a cd 16 1e			call macro_dsp_valuehl 
276d				endm 
# End of macro FORTH_DSP_VALUEHL
276d e5					push hl    ; n2 
276e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
276e cd ce 1e			call macro_forth_dsp_pop 
2771				endm 
# End of macro FORTH_DSP_POP
2771			 
2771					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2771 cd 16 1e			call macro_dsp_valuehl 
2774				endm 
# End of macro FORTH_DSP_VALUEHL
2774 e5					push hl    ; n1 
2775					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2775 cd ce 1e			call macro_forth_dsp_pop 
2778				endm 
# End of macro FORTH_DSP_POP
2778			 
2778 d1					pop de     ; n1 
2779 e1					pop hl     ; n2 
277a			 
277a d5					push de 
277b e5					push hl 
277c d5					push de 
277d			 
277d					; push back  
277d			 
277d e1					pop hl 
277e cd 1f 1c				call forth_push_numhl 
2781 e1					pop hl 
2782 cd 1f 1c				call forth_push_numhl 
2785 e1					pop hl 
2786 cd 1f 1c				call forth_push_numhl 
2789					NEXTW 
2789 c3 88 1f			jp macro_next 
278c				endm 
# End of macro NEXTW
278c			 
278c			.PAUSE: 
278c				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
278c 43				db WORD_SYS_CORE+47             
278d c1 27			dw .PAUSES            
278f 08				db 7 + 1 
2790 .. 00			db "PAUSEMS",0              
2798				endm 
# End of macro CWHEAD
2798			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2798					if DEBUG_FORTH_WORDS_KEY 
2798						DMARK "PMS" 
2798 f5				push af  
2799 3a ad 27			ld a, (.dmark)  
279c 32 77 fb			ld (debug_mark),a  
279f 3a ae 27			ld a, (.dmark+1)  
27a2 32 78 fb			ld (debug_mark+1),a  
27a5 3a af 27			ld a, (.dmark+2)  
27a8 32 79 fb			ld (debug_mark+2),a  
27ab 18 03			jr .pastdmark  
27ad ..			.dmark: db "PMS"  
27b0 f1			.pastdmark: pop af  
27b1			endm  
# End of macro DMARK
27b1						CALLMONITOR 
27b1 cd 92 16			call break_point_state  
27b4				endm  
# End of macro CALLMONITOR
27b4					endif 
27b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27b4 cd 16 1e			call macro_dsp_valuehl 
27b7				endm 
# End of macro FORTH_DSP_VALUEHL
27b7			;		push hl    ; n2 
27b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27b7 cd ce 1e			call macro_forth_dsp_pop 
27ba				endm 
# End of macro FORTH_DSP_POP
27ba			;		pop hl 
27ba			 
27ba 7d					ld a, l 
27bb cd 3a 0a				call aDelayInMS 
27be				       NEXTW 
27be c3 88 1f			jp macro_next 
27c1				endm 
# End of macro NEXTW
27c1			.PAUSES:  
27c1				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
27c1 44				db WORD_SYS_CORE+48             
27c2 30 28			dw .ROT            
27c4 06				db 5 + 1 
27c5 .. 00			db "PAUSE",0              
27cb				endm 
# End of macro CWHEAD
27cb			; | PAUSE ( n -- )  Pause for n seconds | DONE 
27cb					if DEBUG_FORTH_WORDS_KEY 
27cb						DMARK "PAU" 
27cb f5				push af  
27cc 3a e0 27			ld a, (.dmark)  
27cf 32 77 fb			ld (debug_mark),a  
27d2 3a e1 27			ld a, (.dmark+1)  
27d5 32 78 fb			ld (debug_mark+1),a  
27d8 3a e2 27			ld a, (.dmark+2)  
27db 32 79 fb			ld (debug_mark+2),a  
27de 18 03			jr .pastdmark  
27e0 ..			.dmark: db "PAU"  
27e3 f1			.pastdmark: pop af  
27e4			endm  
# End of macro DMARK
27e4						CALLMONITOR 
27e4 cd 92 16			call break_point_state  
27e7				endm  
# End of macro CALLMONITOR
27e7					endif 
27e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27e7 cd 16 1e			call macro_dsp_valuehl 
27ea				endm 
# End of macro FORTH_DSP_VALUEHL
27ea			;		push hl    ; n2 
27ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27ea cd ce 1e			call macro_forth_dsp_pop 
27ed				endm 
# End of macro FORTH_DSP_POP
27ed			;		pop hl 
27ed 45					ld b, l 
27ee					if DEBUG_FORTH_WORDS 
27ee						DMARK "PAU" 
27ee f5				push af  
27ef 3a 03 28			ld a, (.dmark)  
27f2 32 77 fb			ld (debug_mark),a  
27f5 3a 04 28			ld a, (.dmark+1)  
27f8 32 78 fb			ld (debug_mark+1),a  
27fb 3a 05 28			ld a, (.dmark+2)  
27fe 32 79 fb			ld (debug_mark+2),a  
2801 18 03			jr .pastdmark  
2803 ..			.dmark: db "PAU"  
2806 f1			.pastdmark: pop af  
2807			endm  
# End of macro DMARK
2807						CALLMONITOR 
2807 cd 92 16			call break_point_state  
280a				endm  
# End of macro CALLMONITOR
280a					endif 
280a c5			.pauses1:	push bc 
280b cd 55 0a				call delay1s 
280e c1					pop bc 
280f					if DEBUG_FORTH_WORDS 
280f						DMARK "PA1" 
280f f5				push af  
2810 3a 24 28			ld a, (.dmark)  
2813 32 77 fb			ld (debug_mark),a  
2816 3a 25 28			ld a, (.dmark+1)  
2819 32 78 fb			ld (debug_mark+1),a  
281c 3a 26 28			ld a, (.dmark+2)  
281f 32 79 fb			ld (debug_mark+2),a  
2822 18 03			jr .pastdmark  
2824 ..			.dmark: db "PA1"  
2827 f1			.pastdmark: pop af  
2828			endm  
# End of macro DMARK
2828						CALLMONITOR 
2828 cd 92 16			call break_point_state  
282b				endm  
# End of macro CALLMONITOR
282b					endif 
282b 10 dd				djnz .pauses1 
282d			 
282d				       NEXTW 
282d c3 88 1f			jp macro_next 
2830				endm 
# End of macro NEXTW
2830			.ROT: 
2830				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2830 45				db WORD_SYS_CORE+49             
2831 7e 28			dw .UWORDS            
2833 04				db 3 + 1 
2834 .. 00			db "ROT",0              
2838				endm 
# End of macro CWHEAD
2838			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2838					if DEBUG_FORTH_WORDS_KEY 
2838						DMARK "ROT" 
2838 f5				push af  
2839 3a 4d 28			ld a, (.dmark)  
283c 32 77 fb			ld (debug_mark),a  
283f 3a 4e 28			ld a, (.dmark+1)  
2842 32 78 fb			ld (debug_mark+1),a  
2845 3a 4f 28			ld a, (.dmark+2)  
2848 32 79 fb			ld (debug_mark+2),a  
284b 18 03			jr .pastdmark  
284d ..			.dmark: db "ROT"  
2850 f1			.pastdmark: pop af  
2851			endm  
# End of macro DMARK
2851						CALLMONITOR 
2851 cd 92 16			call break_point_state  
2854				endm  
# End of macro CALLMONITOR
2854					endif 
2854			 
2854					FORTH_DSP_VALUEHL 
2854 cd 16 1e			call macro_dsp_valuehl 
2857				endm 
# End of macro FORTH_DSP_VALUEHL
2857 e5					push hl    ; u3  
2858			 
2858					FORTH_DSP_POP 
2858 cd ce 1e			call macro_forth_dsp_pop 
285b				endm 
# End of macro FORTH_DSP_POP
285b			   
285b					FORTH_DSP_VALUEHL 
285b cd 16 1e			call macro_dsp_valuehl 
285e				endm 
# End of macro FORTH_DSP_VALUEHL
285e e5					push hl     ; u2 
285f			 
285f					FORTH_DSP_POP 
285f cd ce 1e			call macro_forth_dsp_pop 
2862				endm 
# End of macro FORTH_DSP_POP
2862			 
2862					FORTH_DSP_VALUEHL 
2862 cd 16 1e			call macro_dsp_valuehl 
2865				endm 
# End of macro FORTH_DSP_VALUEHL
2865 e5					push hl     ; u1 
2866			 
2866					FORTH_DSP_POP 
2866 cd ce 1e			call macro_forth_dsp_pop 
2869				endm 
# End of macro FORTH_DSP_POP
2869			 
2869 c1					pop bc      ; u1 
286a e1					pop hl      ; u2 
286b d1					pop de      ; u3 
286c			 
286c			 
286c c5					push bc 
286d d5					push de 
286e e5					push hl 
286f			 
286f			 
286f e1					pop hl 
2870 cd 1f 1c				call forth_push_numhl 
2873			 
2873 e1					pop hl 
2874 cd 1f 1c				call forth_push_numhl 
2877			 
2877 e1					pop hl 
2878 cd 1f 1c				call forth_push_numhl 
287b					 
287b			 
287b			 
287b			 
287b			 
287b			 
287b				       NEXTW 
287b c3 88 1f			jp macro_next 
287e				endm 
# End of macro NEXTW
287e			 
287e			.UWORDS: 
287e				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
287e 50				db WORD_SYS_CORE+60             
287f 40 29			dw .BP            
2881 07				db 6 + 1 
2882 .. 00			db "UWORDS",0              
2889				endm 
# End of macro CWHEAD
2889			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2889			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2889			; | | Following the count are the individual words. 
2889			; | | 
2889			; | | e.g. UWORDS 
2889			; | | BOX DIRLIST 2 
2889			; | |  
2889			; | | Can be used to save the words to storage via: 
2889			; | | UWORDS $01 DO $01 APPEND LOOP 
2889				if DEBUG_FORTH_WORDS_KEY 
2889					DMARK "UWR" 
2889 f5				push af  
288a 3a 9e 28			ld a, (.dmark)  
288d 32 77 fb			ld (debug_mark),a  
2890 3a 9f 28			ld a, (.dmark+1)  
2893 32 78 fb			ld (debug_mark+1),a  
2896 3a a0 28			ld a, (.dmark+2)  
2899 32 79 fb			ld (debug_mark+2),a  
289c 18 03			jr .pastdmark  
289e ..			.dmark: db "UWR"  
28a1 f1			.pastdmark: pop af  
28a2			endm  
# End of macro DMARK
28a2					CALLMONITOR 
28a2 cd 92 16			call break_point_state  
28a5				endm  
# End of macro CALLMONITOR
28a5				endif 
28a5 21 00 80				ld hl, baseram 
28a8					;ld hl, baseusermem 
28a8 01 00 00				ld bc, 0    ; start a counter 
28ab			 
28ab				; skip dict stub 
28ab			 
28ab cd d9 20				call forth_tok_next 
28ae			 
28ae			 
28ae			; while we have words to look for 
28ae			 
28ae 7e			.douscan:	ld a, (hl)      
28af				if DEBUG_FORTH_WORDS 
28af					DMARK "UWs" 
28af f5				push af  
28b0 3a c4 28			ld a, (.dmark)  
28b3 32 77 fb			ld (debug_mark),a  
28b6 3a c5 28			ld a, (.dmark+1)  
28b9 32 78 fb			ld (debug_mark+1),a  
28bc 3a c6 28			ld a, (.dmark+2)  
28bf 32 79 fb			ld (debug_mark+2),a  
28c2 18 03			jr .pastdmark  
28c4 ..			.dmark: db "UWs"  
28c7 f1			.pastdmark: pop af  
28c8			endm  
# End of macro DMARK
28c8					CALLMONITOR 
28c8 cd 92 16			call break_point_state  
28cb				endm  
# End of macro CALLMONITOR
28cb				endif 
28cb fe 00				cp WORD_SYS_END 
28cd 28 4d				jr z, .udone 
28cf fe 01				cp WORD_SYS_UWORD 
28d1 20 44				jr nz, .nuword 
28d3			 
28d3				if DEBUG_FORTH_WORDS 
28d3					DMARK "UWu" 
28d3 f5				push af  
28d4 3a e8 28			ld a, (.dmark)  
28d7 32 77 fb			ld (debug_mark),a  
28da 3a e9 28			ld a, (.dmark+1)  
28dd 32 78 fb			ld (debug_mark+1),a  
28e0 3a ea 28			ld a, (.dmark+2)  
28e3 32 79 fb			ld (debug_mark+2),a  
28e6 18 03			jr .pastdmark  
28e8 ..			.dmark: db "UWu"  
28eb f1			.pastdmark: pop af  
28ec			endm  
# End of macro DMARK
28ec					CALLMONITOR 
28ec cd 92 16			call break_point_state  
28ef				endm  
# End of macro CALLMONITOR
28ef				endif 
28ef					; we have a uword so push its name to the stack 
28ef			 
28ef e5				   	push hl  ; save so we can move to next dict block 
28f0			 
28f0					; skip opcode 
28f0 23					inc hl  
28f1					; skip next ptr 
28f1 23					inc hl  
28f2 23					inc hl 
28f3					; skip len 
28f3 23					inc hl 
28f4				if DEBUG_FORTH_WORDS 
28f4					DMARK "UWt" 
28f4 f5				push af  
28f5 3a 09 29			ld a, (.dmark)  
28f8 32 77 fb			ld (debug_mark),a  
28fb 3a 0a 29			ld a, (.dmark+1)  
28fe 32 78 fb			ld (debug_mark+1),a  
2901 3a 0b 29			ld a, (.dmark+2)  
2904 32 79 fb			ld (debug_mark+2),a  
2907 18 03			jr .pastdmark  
2909 ..			.dmark: db "UWt"  
290c f1			.pastdmark: pop af  
290d			endm  
# End of macro DMARK
290d					CALLMONITOR 
290d cd 92 16			call break_point_state  
2910				endm  
# End of macro CALLMONITOR
2910				endif 
2910 03					inc bc 
2911			 
2911 c5					push bc 
2912 cd 8d 1c				call forth_push_str 
2915 c1					pop bc 
2916			 
2916 e1					pop hl 	 
2917			 
2917 cd d9 20		.nuword:	call forth_tok_next 
291a 18 92				jr .douscan  
291c			 
291c			.udone:		 ; push count of uwords found 
291c c5					push bc 
291d e1					pop hl 
291e			 
291e				if DEBUG_FORTH_WORDS 
291e					DMARK "UWc" 
291e f5				push af  
291f 3a 33 29			ld a, (.dmark)  
2922 32 77 fb			ld (debug_mark),a  
2925 3a 34 29			ld a, (.dmark+1)  
2928 32 78 fb			ld (debug_mark+1),a  
292b 3a 35 29			ld a, (.dmark+2)  
292e 32 79 fb			ld (debug_mark+2),a  
2931 18 03			jr .pastdmark  
2933 ..			.dmark: db "UWc"  
2936 f1			.pastdmark: pop af  
2937			endm  
# End of macro DMARK
2937					CALLMONITOR 
2937 cd 92 16			call break_point_state  
293a				endm  
# End of macro CALLMONITOR
293a				endif 
293a cd 1f 1c				call forth_push_numhl 
293d			 
293d			 
293d				       NEXTW 
293d c3 88 1f			jp macro_next 
2940				endm 
# End of macro NEXTW
2940			 
2940			.BP: 
2940				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2940 54				db WORD_SYS_CORE+64             
2941 76 29			dw .MONITOR            
2943 03				db 2 + 1 
2944 .. 00			db "BP",0              
2947				endm 
# End of macro CWHEAD
2947			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2947			; | | $00 Will enable the break points within specific code paths 
2947			; | | $01 Will disable break points 
2947			; | |  
2947			; | | By default break points are off. Either the above can be used to enable them 
2947			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2947			; | | and on release of the pressed key a message will be disaplayed to notify 
2947			; | | that break points are enabled. Pressing any key will then continue boot process. 
2947					; get byte count 
2947					if DEBUG_FORTH_WORDS_KEY 
2947						DMARK "BP." 
2947 f5				push af  
2948 3a 5c 29			ld a, (.dmark)  
294b 32 77 fb			ld (debug_mark),a  
294e 3a 5d 29			ld a, (.dmark+1)  
2951 32 78 fb			ld (debug_mark+1),a  
2954 3a 5e 29			ld a, (.dmark+2)  
2957 32 79 fb			ld (debug_mark+2),a  
295a 18 03			jr .pastdmark  
295c ..			.dmark: db "BP."  
295f f1			.pastdmark: pop af  
2960			endm  
# End of macro DMARK
2960						CALLMONITOR 
2960 cd 92 16			call break_point_state  
2963				endm  
# End of macro CALLMONITOR
2963					endif 
2963			 
2963					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2963 cd 16 1e			call macro_dsp_valuehl 
2966				endm 
# End of macro FORTH_DSP_VALUEHL
2966			 
2966			;		push hl 
2966			 
2966					; destroy value TOS 
2966			 
2966					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2966 cd ce 1e			call macro_forth_dsp_pop 
2969				endm 
# End of macro FORTH_DSP_POP
2969			 
2969			;		pop hl 
2969			 
2969 3e 00				ld a,0 
296b bd					cp l 
296c 28 02				jr z, .bpset 
296e 3e 2a				ld a, '*' 
2970			 
2970 32 0e ee		.bpset:		ld (os_view_disable), a 
2973			 
2973			 
2973					NEXTW 
2973 c3 88 1f			jp macro_next 
2976				endm 
# End of macro NEXTW
2976			 
2976			 
2976			.MONITOR: 
2976				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2976 55				db WORD_SYS_CORE+65             
2977 a9 29			dw .MALLOC            
2979 08				db 7 + 1 
297a .. 00			db "MONITOR",0              
2982				endm 
# End of macro CWHEAD
2982			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2982			; | | At start the current various registers will be displayed with contents. 
2982			; | | Top right corner will show the most recent debug marker seen. 
2982			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2982			; | | and the return stack pointer (RSP). 
2982			; | | Pressing: 
2982			; | |    1 - Initial screen 
2982			; | |    2 - Display a data dump of HL 
2982			; | |    3 - Display a data dump of DE 
2982			; | |    4 - Display a data dump of BC 
2982			; | |    5 - Display a data dump of HL 
2982			; | |    6 - Display a data dump of DSP 
2982			; | |    7 - Display a data dump of RSP 
2982			; | |    8 - Display a data dump of what is at DSP 
2982			; | |    9 - Display a data dump of what is at RSP 
2982			; | |    0 - Exit monitor and continue running. This will also enable break points 
2982			; | |    * - Disable break points 
2982			; | |    # - Enter traditional monitor mode 
2982			; | | 
2982			; | | Monitor Mode 
2982			; | | ------------ 
2982			; | | A prompt of '>' will be shown for various commands: 
2982			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2982			; | |    C - Continue display a data dump from the last set address 
2982			; | |    M xxxx - Set start of memory edit at address xx 
2982			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2982			; | |    Q - Return to previous 
2982					if DEBUG_FORTH_WORDS_KEY 
2982						DMARK "MON" 
2982 f5				push af  
2983 3a 97 29			ld a, (.dmark)  
2986 32 77 fb			ld (debug_mark),a  
2989 3a 98 29			ld a, (.dmark+1)  
298c 32 78 fb			ld (debug_mark+1),a  
298f 3a 99 29			ld a, (.dmark+2)  
2992 32 79 fb			ld (debug_mark+2),a  
2995 18 03			jr .pastdmark  
2997 ..			.dmark: db "MON"  
299a f1			.pastdmark: pop af  
299b			endm  
# End of macro DMARK
299b						CALLMONITOR 
299b cd 92 16			call break_point_state  
299e				endm  
# End of macro CALLMONITOR
299e					endif 
299e 3e 00				ld a, 0 
29a0 32 0e ee				ld (os_view_disable), a 
29a3			 
29a3					CALLMONITOR 
29a3 cd 92 16			call break_point_state  
29a6				endm  
# End of macro CALLMONITOR
29a6			 
29a6			;	call monitor 
29a6			 
29a6					NEXTW 
29a6 c3 88 1f			jp macro_next 
29a9				endm 
# End of macro NEXTW
29a9			 
29a9			 
29a9			.MALLOC: 
29a9				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
29a9 56				db WORD_SYS_CORE+66             
29aa d2 29			dw .MALLOC2            
29ac 06				db 5 + 1 
29ad .. 00			db "ALLOT",0              
29b3				endm 
# End of macro CWHEAD
29b3			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29b3					if DEBUG_FORTH_WORDS_KEY 
29b3						DMARK "ALL" 
29b3 f5				push af  
29b4 3a c8 29			ld a, (.dmark)  
29b7 32 77 fb			ld (debug_mark),a  
29ba 3a c9 29			ld a, (.dmark+1)  
29bd 32 78 fb			ld (debug_mark+1),a  
29c0 3a ca 29			ld a, (.dmark+2)  
29c3 32 79 fb			ld (debug_mark+2),a  
29c6 18 03			jr .pastdmark  
29c8 ..			.dmark: db "ALL"  
29cb f1			.pastdmark: pop af  
29cc			endm  
# End of macro DMARK
29cc						CALLMONITOR 
29cc cd 92 16			call break_point_state  
29cf				endm  
# End of macro CALLMONITOR
29cf					endif 
29cf c3 f9 29				jp .mallocc 
29d2			.MALLOC2: 
29d2				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
29d2 56				db WORD_SYS_CORE+66             
29d3 10 2a			dw .FREE            
29d5 07				db 6 + 1 
29d6 .. 00			db "MALLOC",0              
29dd				endm 
# End of macro CWHEAD
29dd			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29dd					; get byte count 
29dd					if DEBUG_FORTH_WORDS_KEY 
29dd						DMARK "MAL" 
29dd f5				push af  
29de 3a f2 29			ld a, (.dmark)  
29e1 32 77 fb			ld (debug_mark),a  
29e4 3a f3 29			ld a, (.dmark+1)  
29e7 32 78 fb			ld (debug_mark+1),a  
29ea 3a f4 29			ld a, (.dmark+2)  
29ed 32 79 fb			ld (debug_mark+2),a  
29f0 18 03			jr .pastdmark  
29f2 ..			.dmark: db "MAL"  
29f5 f1			.pastdmark: pop af  
29f6			endm  
# End of macro DMARK
29f6						CALLMONITOR 
29f6 cd 92 16			call break_point_state  
29f9				endm  
# End of macro CALLMONITOR
29f9					endif 
29f9			.mallocc: 
29f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29f9 cd 16 1e			call macro_dsp_valuehl 
29fc				endm 
# End of macro FORTH_DSP_VALUEHL
29fc			 
29fc			;		push hl 
29fc			 
29fc					; destroy value TOS 
29fc			 
29fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29fc cd ce 1e			call macro_forth_dsp_pop 
29ff				endm 
# End of macro FORTH_DSP_POP
29ff			 
29ff			;		pop hl 
29ff cd d0 11				call malloc 
2a02				if DEBUG_FORTH_MALLOC_GUARD 
2a02 f5					push af 
2a03 cd 32 0d				call ishlzero 
2a06			;		ld a, l 
2a06			;		add h 
2a06			;		cp 0 
2a06 f1					pop af 
2a07					 
2a07 cc 43 52				call z,malloc_error 
2a0a				endif 
2a0a			 
2a0a cd 1f 1c				call forth_push_numhl 
2a0d					NEXTW 
2a0d c3 88 1f			jp macro_next 
2a10				endm 
# End of macro NEXTW
2a10			 
2a10			.FREE: 
2a10				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2a10 57				db WORD_SYS_CORE+67             
2a11 41 2a			dw .LIST            
2a13 05				db 4 + 1 
2a14 .. 00			db "FREE",0              
2a19				endm 
# End of macro CWHEAD
2a19			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a19					if DEBUG_FORTH_WORDS_KEY 
2a19						DMARK "FRE" 
2a19 f5				push af  
2a1a 3a 2e 2a			ld a, (.dmark)  
2a1d 32 77 fb			ld (debug_mark),a  
2a20 3a 2f 2a			ld a, (.dmark+1)  
2a23 32 78 fb			ld (debug_mark+1),a  
2a26 3a 30 2a			ld a, (.dmark+2)  
2a29 32 79 fb			ld (debug_mark+2),a  
2a2c 18 03			jr .pastdmark  
2a2e ..			.dmark: db "FRE"  
2a31 f1			.pastdmark: pop af  
2a32			endm  
# End of macro DMARK
2a32						CALLMONITOR 
2a32 cd 92 16			call break_point_state  
2a35				endm  
# End of macro CALLMONITOR
2a35					endif 
2a35					; get address 
2a35			 
2a35					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a35 cd 16 1e			call macro_dsp_valuehl 
2a38				endm 
# End of macro FORTH_DSP_VALUEHL
2a38			 
2a38			;		push hl 
2a38			 
2a38					; destroy value TOS 
2a38			 
2a38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a38 cd ce 1e			call macro_forth_dsp_pop 
2a3b				endm 
# End of macro FORTH_DSP_POP
2a3b			 
2a3b			;		pop hl 
2a3b			if FORTH_ENABLE_MALLOCFREE 
2a3b cd 9a 12				call free 
2a3e			endif 
2a3e					NEXTW 
2a3e c3 88 1f			jp macro_next 
2a41				endm 
# End of macro NEXTW
2a41			.LIST: 
2a41				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2a41 5c				db WORD_SYS_CORE+72             
2a42 04 2c			dw .FORGET            
2a44 05				db 4 + 1 
2a45 .. 00			db "LIST",0              
2a4a				endm 
# End of macro CWHEAD
2a4a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2a4a			; | | The quoted word must be in upper case. 
2a4a				if DEBUG_FORTH_WORDS_KEY 
2a4a					DMARK "LST" 
2a4a f5				push af  
2a4b 3a 5f 2a			ld a, (.dmark)  
2a4e 32 77 fb			ld (debug_mark),a  
2a51 3a 60 2a			ld a, (.dmark+1)  
2a54 32 78 fb			ld (debug_mark+1),a  
2a57 3a 61 2a			ld a, (.dmark+2)  
2a5a 32 79 fb			ld (debug_mark+2),a  
2a5d 18 03			jr .pastdmark  
2a5f ..			.dmark: db "LST"  
2a62 f1			.pastdmark: pop af  
2a63			endm  
# End of macro DMARK
2a63					CALLMONITOR 
2a63 cd 92 16			call break_point_state  
2a66				endm  
# End of macro CALLMONITOR
2a66				endif 
2a66			 
2a66					FORTH_DSP_VALUEHL 
2a66 cd 16 1e			call macro_dsp_valuehl 
2a69				endm 
# End of macro FORTH_DSP_VALUEHL
2a69			 
2a69 e5					push hl 
2a6a c1					pop bc 
2a6b			 
2a6b			; Start format of scratch string 
2a6b			 
2a6b 21 1d ee				ld hl, scratch 
2a6e			 
2a6e 3e 3a				ld a, ':' 
2a70 77					ld (hl),a 
2a71 23					inc hl 
2a72 3e 20				ld a, ' ' 
2a74 77					ld (hl), a 
2a75			 
2a75					; Get ptr to the word we need to look up 
2a75			 
2a75			;		FORTH_DSP_VALUEHL 
2a75					;v5 FORTH_DSP_VALUE 
2a75				; TODO type check 
2a75			;		inc hl    ; Skip type check  
2a75			;		push hl 
2a75			;		ex de, hl    ; put into DE 
2a75			 
2a75			 
2a75 21 00 80				ld hl, baseram 
2a78					;ld hl, baseusermem 
2a78			 
2a78 e5			push hl   ; sacreifical push 
2a79			 
2a79			.ldouscanm: 
2a79 e1				pop hl 
2a7a			.ldouscan: 
2a7a				if DEBUG_FORTH_WORDS 
2a7a					DMARK "LSs" 
2a7a f5				push af  
2a7b 3a 8f 2a			ld a, (.dmark)  
2a7e 32 77 fb			ld (debug_mark),a  
2a81 3a 90 2a			ld a, (.dmark+1)  
2a84 32 78 fb			ld (debug_mark+1),a  
2a87 3a 91 2a			ld a, (.dmark+2)  
2a8a 32 79 fb			ld (debug_mark+2),a  
2a8d 18 03			jr .pastdmark  
2a8f ..			.dmark: db "LSs"  
2a92 f1			.pastdmark: pop af  
2a93			endm  
# End of macro DMARK
2a93					CALLMONITOR 
2a93 cd 92 16			call break_point_state  
2a96				endm  
# End of macro CALLMONITOR
2a96				endif 
2a96				; skip dict stub 
2a96 cd d9 20				call forth_tok_next 
2a99			 
2a99			 
2a99			; while we have words to look for 
2a99			 
2a99 7e				ld a, (hl)      
2a9a				if DEBUG_FORTH_WORDS 
2a9a					DMARK "LSk" 
2a9a f5				push af  
2a9b 3a af 2a			ld a, (.dmark)  
2a9e 32 77 fb			ld (debug_mark),a  
2aa1 3a b0 2a			ld a, (.dmark+1)  
2aa4 32 78 fb			ld (debug_mark+1),a  
2aa7 3a b1 2a			ld a, (.dmark+2)  
2aaa 32 79 fb			ld (debug_mark+2),a  
2aad 18 03			jr .pastdmark  
2aaf ..			.dmark: db "LSk"  
2ab2 f1			.pastdmark: pop af  
2ab3			endm  
# End of macro DMARK
2ab3					CALLMONITOR 
2ab3 cd 92 16			call break_point_state  
2ab6				endm  
# End of macro CALLMONITOR
2ab6				endif 
2ab6 fe 00				cp WORD_SYS_END 
2ab8 ca eb 2b				jp z, .lunotfound 
2abb fe 01				cp WORD_SYS_UWORD 
2abd c2 7a 2a				jp nz, .ldouscan 
2ac0			 
2ac0				if DEBUG_FORTH_WORDS 
2ac0					DMARK "LSu" 
2ac0 f5				push af  
2ac1 3a d5 2a			ld a, (.dmark)  
2ac4 32 77 fb			ld (debug_mark),a  
2ac7 3a d6 2a			ld a, (.dmark+1)  
2aca 32 78 fb			ld (debug_mark+1),a  
2acd 3a d7 2a			ld a, (.dmark+2)  
2ad0 32 79 fb			ld (debug_mark+2),a  
2ad3 18 03			jr .pastdmark  
2ad5 ..			.dmark: db "LSu"  
2ad8 f1			.pastdmark: pop af  
2ad9			endm  
# End of macro DMARK
2ad9					CALLMONITOR 
2ad9 cd 92 16			call break_point_state  
2adc				endm  
# End of macro CALLMONITOR
2adc				endif 
2adc			 
2adc					; found a uword but is it the one we want... 
2adc			 
2adc c5					push bc     ; uword to find is on bc 
2add d1					pop de 
2ade			 
2ade e5					push hl  ; to save the ptr 
2adf			 
2adf					; skip opcode 
2adf 23					inc hl  
2ae0					; skip next ptr 
2ae0 23					inc hl  
2ae1 23					inc hl 
2ae2					; skip len 
2ae2 23					inc hl 
2ae3			 
2ae3				if DEBUG_FORTH_WORDS 
2ae3					DMARK "LSc" 
2ae3 f5				push af  
2ae4 3a f8 2a			ld a, (.dmark)  
2ae7 32 77 fb			ld (debug_mark),a  
2aea 3a f9 2a			ld a, (.dmark+1)  
2aed 32 78 fb			ld (debug_mark+1),a  
2af0 3a fa 2a			ld a, (.dmark+2)  
2af3 32 79 fb			ld (debug_mark+2),a  
2af6 18 03			jr .pastdmark  
2af8 ..			.dmark: db "LSc"  
2afb f1			.pastdmark: pop af  
2afc			endm  
# End of macro DMARK
2afc					CALLMONITOR 
2afc cd 92 16			call break_point_state  
2aff				endm  
# End of macro CALLMONITOR
2aff				endif 
2aff cd 9f 11				call strcmp 
2b02 c2 79 2a				jp nz, .ldouscanm 
2b05				 
2b05			 
2b05			 
2b05					; we have a uword so push its name to the stack 
2b05			 
2b05			;	   	push hl  ; save so we can move to next dict block 
2b05 e1			pop hl 
2b06			 
2b06				if DEBUG_FORTH_WORDS 
2b06					DMARK "LSm" 
2b06 f5				push af  
2b07 3a 1b 2b			ld a, (.dmark)  
2b0a 32 77 fb			ld (debug_mark),a  
2b0d 3a 1c 2b			ld a, (.dmark+1)  
2b10 32 78 fb			ld (debug_mark+1),a  
2b13 3a 1d 2b			ld a, (.dmark+2)  
2b16 32 79 fb			ld (debug_mark+2),a  
2b19 18 03			jr .pastdmark  
2b1b ..			.dmark: db "LSm"  
2b1e f1			.pastdmark: pop af  
2b1f			endm  
# End of macro DMARK
2b1f					CALLMONITOR 
2b1f cd 92 16			call break_point_state  
2b22				endm  
# End of macro CALLMONITOR
2b22				endif 
2b22			 
2b22					; skip opcode 
2b22 23					inc hl  
2b23					; skip next ptr 
2b23 23					inc hl  
2b24 23					inc hl 
2b25					; skip len 
2b25 7e					ld a, (hl)   ; save length to add 
2b26				if DEBUG_FORTH_WORDS 
2b26					DMARK "LS2" 
2b26 f5				push af  
2b27 3a 3b 2b			ld a, (.dmark)  
2b2a 32 77 fb			ld (debug_mark),a  
2b2d 3a 3c 2b			ld a, (.dmark+1)  
2b30 32 78 fb			ld (debug_mark+1),a  
2b33 3a 3d 2b			ld a, (.dmark+2)  
2b36 32 79 fb			ld (debug_mark+2),a  
2b39 18 03			jr .pastdmark  
2b3b ..			.dmark: db "LS2"  
2b3e f1			.pastdmark: pop af  
2b3f			endm  
# End of macro DMARK
2b3f					CALLMONITOR 
2b3f cd 92 16			call break_point_state  
2b42				endm  
# End of macro CALLMONITOR
2b42				endif 
2b42			 
2b42					; save this location 
2b42				 
2b42 e5					push hl 
2b43			 
2b43 23					inc hl 
2b44 11 1f ee				ld de, scratch+2 
2b47 4f					ld c, a 
2b48 06 00				ld b, 0 
2b4a			 
2b4a				if DEBUG_FORTH_WORDS 
2b4a					DMARK "LSn" 
2b4a f5				push af  
2b4b 3a 5f 2b			ld a, (.dmark)  
2b4e 32 77 fb			ld (debug_mark),a  
2b51 3a 60 2b			ld a, (.dmark+1)  
2b54 32 78 fb			ld (debug_mark+1),a  
2b57 3a 61 2b			ld a, (.dmark+2)  
2b5a 32 79 fb			ld (debug_mark+2),a  
2b5d 18 03			jr .pastdmark  
2b5f ..			.dmark: db "LSn"  
2b62 f1			.pastdmark: pop af  
2b63			endm  
# End of macro DMARK
2b63					CALLMONITOR 
2b63 cd 92 16			call break_point_state  
2b66				endm  
# End of macro CALLMONITOR
2b66				endif 
2b66			 
2b66					; copy uword name to scratch 
2b66			 
2b66 ed b0				ldir 
2b68			 
2b68 1b					dec de 
2b69 3e 20				ld a, ' '    ; change null to space 
2b6b 12					ld (de), a 
2b6c			 
2b6c 13					inc de 
2b6d			 
2b6d d5					push de 
2b6e c1					pop bc     ; move scratch pointer to end of word name and save it 
2b6f			 
2b6f e1					pop hl 
2b70 7e					ld a, (hl) 
2b71					;inc hl 
2b71					; skip word string 
2b71 cd 09 0d				call addatohl 
2b74			 
2b74 23					inc hl 
2b75			 
2b75				if DEBUG_FORTH_WORDS 
2b75					DMARK "LS3" 
2b75 f5				push af  
2b76 3a 8a 2b			ld a, (.dmark)  
2b79 32 77 fb			ld (debug_mark),a  
2b7c 3a 8b 2b			ld a, (.dmark+1)  
2b7f 32 78 fb			ld (debug_mark+1),a  
2b82 3a 8c 2b			ld a, (.dmark+2)  
2b85 32 79 fb			ld (debug_mark+2),a  
2b88 18 03			jr .pastdmark  
2b8a ..			.dmark: db "LS3"  
2b8d f1			.pastdmark: pop af  
2b8e			endm  
# End of macro DMARK
2b8e					CALLMONITOR 
2b8e cd 92 16			call break_point_state  
2b91				endm  
# End of macro CALLMONITOR
2b91				endif 
2b91					; should now be at the start of the machine code to setup the eval of the uword 
2b91					; now locate the ptr to the string defintion 
2b91			 
2b91					; skip ld hl, 
2b91					; then load the ptr 
2b91			 
2b91 23					inc hl 
2b92 5e					ld e, (hl) 
2b93 23					inc hl 
2b94 56					ld d, (hl) 
2b95 eb					ex de, hl 
2b96			 
2b96			 
2b96				if DEBUG_FORTH_WORDS 
2b96					DMARK "LSt" 
2b96 f5				push af  
2b97 3a ab 2b			ld a, (.dmark)  
2b9a 32 77 fb			ld (debug_mark),a  
2b9d 3a ac 2b			ld a, (.dmark+1)  
2ba0 32 78 fb			ld (debug_mark+1),a  
2ba3 3a ad 2b			ld a, (.dmark+2)  
2ba6 32 79 fb			ld (debug_mark+2),a  
2ba9 18 03			jr .pastdmark  
2bab ..			.dmark: db "LSt"  
2bae f1			.pastdmark: pop af  
2baf			endm  
# End of macro DMARK
2baf					CALLMONITOR 
2baf cd 92 16			call break_point_state  
2bb2				endm  
# End of macro CALLMONITOR
2bb2				endif 
2bb2			 
2bb2			; cant push right now due to tokenised strings  
2bb2			 
2bb2			; get the destination of where to copy this definition to. 
2bb2			 
2bb2 c5					push bc 
2bb3 d1					pop de 
2bb4			 
2bb4 7e			.listl:         ld a,(hl) 
2bb5 fe 00				cp 0 
2bb7 28 09				jr z, .lreplsp     ; replace zero with space 
2bb9 fe 7f				cp FORTH_END_BUFFER 
2bbb 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2bbd				 
2bbd					; just copy this char as is then 
2bbd			 
2bbd 12					ld (de), a 
2bbe			 
2bbe 23			.listnxt:	inc hl 
2bbf 13					inc de 
2bc0 18 f2				jr .listl 
2bc2			 
2bc2 3e 20		.lreplsp:	ld a,' ' 
2bc4 12					ld (de), a 
2bc5 18 f7				jr .listnxt 
2bc7			 
2bc7			; close up uword def 
2bc7			 
2bc7			.listdone: 
2bc7 3e 00				ld a, 0 
2bc9 12					ld (de), a 
2bca			 
2bca			; now have def so clean up and push to stack 
2bca			 
2bca 21 1d ee				ld hl, scratch 
2bcd				if DEBUG_FORTH_WORDS 
2bcd					DMARK "Ltp" 
2bcd f5				push af  
2bce 3a e2 2b			ld a, (.dmark)  
2bd1 32 77 fb			ld (debug_mark),a  
2bd4 3a e3 2b			ld a, (.dmark+1)  
2bd7 32 78 fb			ld (debug_mark+1),a  
2bda 3a e4 2b			ld a, (.dmark+2)  
2bdd 32 79 fb			ld (debug_mark+2),a  
2be0 18 03			jr .pastdmark  
2be2 ..			.dmark: db "Ltp"  
2be5 f1			.pastdmark: pop af  
2be6			endm  
# End of macro DMARK
2be6					CALLMONITOR 
2be6 cd 92 16			call break_point_state  
2be9				endm  
# End of macro CALLMONITOR
2be9				endif 
2be9			 
2be9 18 06			jr .listpush 
2beb			 
2beb			;.lnuword:	pop hl 
2beb			;		call forth_tok_next 
2beb			;		jp .ldouscan  
2beb			 
2beb			.lunotfound:		  
2beb			 
2beb			 
2beb					 
2beb					FORTH_DSP_POP 
2beb cd ce 1e			call macro_forth_dsp_pop 
2bee				endm 
# End of macro FORTH_DSP_POP
2bee 21 f7 2b				ld hl, .luno 
2bf1						 
2bf1			 
2bf1			.listpush: 
2bf1 cd 8d 1c				call forth_push_str 
2bf4			 
2bf4			 
2bf4			 
2bf4					NEXTW 
2bf4 c3 88 1f			jp macro_next 
2bf7				endm 
# End of macro NEXTW
2bf7			 
2bf7 .. 00		.luno:    db "Not found",0 
2c01			 
2c01			 
2c01			 
2c01			 
2c01			 
2c01			;		push hl   ; save pointer to start of uword def string 
2c01			; 
2c01			;; look for FORTH_EOL_LINE 
2c01			;		ld a, FORTH_END_BUFFER 
2c01			;		call strlent 
2c01			; 
2c01			;		inc hl		 ; space for coln def 
2c01			;		inc hl 
2c01			;		inc hl          ; space for terms 
2c01			;		inc hl 
2c01			; 
2c01			;		ld a, 20   ; TODO get actual length 
2c01			;		call addatohl    ; include a random amount of room for the uword name 
2c01			; 
2c01			;		 
2c01			;	if DEBUG_FORTH_WORDS 
2c01			;		DMARK "Lt1" 
2c01			;		CALLMONITOR 
2c01			;	endif 
2c01			;		 
2c01			; 
2c01			;; malloc space for the string because we cant change it 
2c01			; 
2c01			;		call malloc 
2c01			;	if DEBUG_FORTH_MALLOC_GUARD 
2c01			;		push af 
2c01			;		call ishlzero 
2c01			;		pop af 
2c01			;		 
2c01			;		call z,malloc_error 
2c01			;	endif 
2c01			; 
2c01			;	if DEBUG_FORTH_WORDS 
2c01			;		DMARK "Lt2" 
2c01			;		CALLMONITOR 
2c01			;	endif 
2c01			;		pop de 
2c01			;		push hl    ; push the malloc to release later 
2c01			;		push hl   ;  push back a copy for the later stack push 
2c01			;		 
2c01			;; copy the string swapping out the zero terms for spaces 
2c01			; 
2c01			;		; de has our source 
2c01			;		; hl has our dest 
2c01			; 
2c01			;; add the coln def 
2c01			; 
2c01			;		ld a, ':' 
2c01			;		ld (hl), a 
2c01			;		inc hl 
2c01			;		ld a, ' ' 
2c01			;		ld (hl), a 
2c01			;		inc hl 
2c01			; 
2c01			;; add the uname word 
2c01			;		push de   ; save our string for now 
2c01			;		ex de, hl 
2c01			; 
2c01			;		FORTH_DSP_VALUE 
2c01			;		;v5 FORTH_DSP_VALUE 
2c01			; 
2c01			;		inc hl   ; skip type but we know by now this is OK 
2c01			; 
2c01			;.luword:	ld a,(hl) 
2c01			;		cp 0 
2c01			;		jr z, .luword2 
2c01			;		ld (de), a 
2c01			;		inc de 
2c01			;		inc hl 
2c01			;		jr .luword 
2c01			; 
2c01			;.luword2:	ld a, ' ' 
2c01			;		ld (de), a 
2c01			;;		inc hl 
2c01			;;		inc de 
2c01			;;		ld (de), a 
2c01			;;		inc hl 
2c01			;		inc de 
2c01			; 
2c01			;		ex de, hl 
2c01			;		pop de 
2c01			;		 
2c01			;		 
2c01			; 
2c01			;; detoken that string and copy it 
2c01			; 
2c01			;	if DEBUG_FORTH_WORDS 
2c01			;		DMARK "Lt2" 
2c01			;		CALLMONITOR 
2c01			;	endif 
2c01			;.ldetok:	ld a, (de) 
2c01			;		cp FORTH_END_BUFFER 
2c01			;		jr z, .ldetokend 
2c01			;		; swap out any zero term for space 
2c01			;		cp 0 
2c01			;		jr nz, .ldetoknext 
2c01			;		ld a, ' ' 
2c01			; 
2c01			;	if DEBUG_FORTH_WORDS 
2c01			;		DMARK "LtS" 
2c01			;		CALLMONITOR 
2c01			;	endif 
2c01			;.ldetoknext:	ld (hl), a 
2c01			;		inc de 
2c01			;		inc hl 
2c01			;		jr .ldetok 
2c01			; 
2c01			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2c01			;		ld (hl), a  
2c01			; 
2c01			;; free that temp malloc 
2c01			; 
2c01			;		pop hl    
2c01			; 
2c01			;	if DEBUG_FORTH_WORDS 
2c01			;		DMARK "Lt4" 
2c01			;		CALLMONITOR 
2c01			;	endif 
2c01			;		call forth_apushstrhl 
2c01			; 
2c01			;		; get rid of temp malloc area 
2c01			; 
2c01			;		pop hl 
2c01			;		call free 
2c01			; 
2c01			;		jr .ludone 
2c01			; 
2c01			;.lnuword:	pop hl 
2c01			;		call forth_tok_next 
2c01			;		jp .ldouscan  
2c01			; 
2c01			;.ludone:		 pop hl 
2c01			; 
2c01					NEXTW 
2c01 c3 88 1f			jp macro_next 
2c04				endm 
# End of macro NEXTW
2c04			 
2c04			.FORGET: 
2c04				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2c04 5d				db WORD_SYS_CORE+73             
2c05 7d 2c			dw .NOP            
2c07 07				db 6 + 1 
2c08 .. 00			db "FORGET",0              
2c0f				endm 
# End of macro CWHEAD
2c0f			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2c0f			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2c0f			; | |  
2c0f			; | | e.g. "MORE" forget 
2c0f					if DEBUG_FORTH_WORDS_KEY 
2c0f						DMARK "FRG" 
2c0f f5				push af  
2c10 3a 24 2c			ld a, (.dmark)  
2c13 32 77 fb			ld (debug_mark),a  
2c16 3a 25 2c			ld a, (.dmark+1)  
2c19 32 78 fb			ld (debug_mark+1),a  
2c1c 3a 26 2c			ld a, (.dmark+2)  
2c1f 32 79 fb			ld (debug_mark+2),a  
2c22 18 03			jr .pastdmark  
2c24 ..			.dmark: db "FRG"  
2c27 f1			.pastdmark: pop af  
2c28			endm  
# End of macro DMARK
2c28						CALLMONITOR 
2c28 cd 92 16			call break_point_state  
2c2b				endm  
# End of macro CALLMONITOR
2c2b					endif 
2c2b			 
2c2b				; find uword 
2c2b			        ; update start of word with "_" 
2c2b				; replace uword with deleted flag 
2c2b			 
2c2b			 
2c2b			;	if DEBUG_FORTH_WORDS 
2c2b			;		DMARK "FOG" 
2c2b			;		CALLMONITOR 
2c2b			;	endif 
2c2b			 
2c2b			 
2c2b					; Get ptr to the word we need to look up 
2c2b			 
2c2b					FORTH_DSP_VALUEHL 
2c2b cd 16 1e			call macro_dsp_valuehl 
2c2e				endm 
# End of macro FORTH_DSP_VALUEHL
2c2e					;v5 FORTH_DSP_VALUE 
2c2e				; TODO type check 
2c2e			;		inc hl    ; Skip type check  
2c2e e5					push hl 
2c2f c1					pop bc 
2c30			;		ex de, hl    ; put into DE 
2c30			 
2c30			 
2c30 21 00 80				ld hl, baseram 
2c33					;ld hl, baseusermem 
2c33			 
2c33				; skip dict stub 
2c33			;	call forth_tok_next 
2c33 e5			push hl   ; sacreifical push 
2c34			 
2c34			.fldouscanm: 
2c34 e1				pop hl 
2c35			.fldouscan: 
2c35			;	if DEBUG_FORTH_WORDS 
2c35			;		DMARK "LSs" 
2c35			;		CALLMONITOR 
2c35			;	endif 
2c35				; skip dict stub 
2c35 cd d9 20				call forth_tok_next 
2c38			 
2c38			 
2c38			; while we have words to look for 
2c38			 
2c38 7e				ld a, (hl)      
2c39			;	if DEBUG_FORTH_WORDS 
2c39			;		DMARK "LSk" 
2c39			;		CALLMONITOR 
2c39			;	endif 
2c39 fe 00				cp WORD_SYS_END 
2c3b ca 77 2c				jp z, .flunotfound 
2c3e fe 01				cp WORD_SYS_UWORD 
2c40 c2 35 2c				jp nz, .fldouscan 
2c43			 
2c43			;	if DEBUG_FORTH_WORDS 
2c43			;		DMARK "LSu" 
2c43			;		CALLMONITOR 
2c43			;	endif 
2c43			 
2c43					; found a uword but is it the one we want... 
2c43			 
2c43 c5					push bc     ; uword to find is on bc 
2c44 d1					pop de 
2c45			 
2c45 e5					push hl  ; to save the ptr 
2c46			 
2c46					; skip opcode 
2c46 23					inc hl  
2c47					; skip next ptr 
2c47 23					inc hl  
2c48 23					inc hl 
2c49					; skip len 
2c49 23					inc hl 
2c4a			 
2c4a			;	if DEBUG_FORTH_WORDS 
2c4a			;		DMARK "LSc" 
2c4a			;		CALLMONITOR 
2c4a			;	endif 
2c4a cd 9f 11				call strcmp 
2c4d c2 34 2c				jp nz, .fldouscanm 
2c50			; 
2c50			; 
2c50			;; while we have words to look for 
2c50			; 
2c50			;.fdouscan:	ld a, (hl)      
2c50			;	if DEBUG_FORTH_WORDS 
2c50			;		DMARK "LSs" 
2c50			;		CALLMONITOR 
2c50			;	endif 
2c50			;		cp WORD_SYS_END 
2c50			;		jp z, .fudone 
2c50			;		cp WORD_SYS_UWORD 
2c50			;		jp nz, .fnuword 
2c50			; 
2c50			;	if DEBUG_FORTH_WORDS 
2c50			;		DMARK "FGu" 
2c50			;		CALLMONITOR 
2c50			;	endif 
2c50			; 
2c50			;		; found a uword but is it the one we want... 
2c50			; 
2c50			; 
2c50			;	        pop de   ; get back the dsp name 
2c50			;		push de 
2c50			; 
2c50			;		push hl  ; to save the ptr 
2c50			; 
2c50			;		; skip opcode 
2c50			;		inc hl  
2c50			;		; skip next ptr 
2c50			;		inc hl  
2c50			;		inc hl 
2c50			;		; skip len 
2c50			;		inc hl 
2c50			; 
2c50			;	if DEBUG_FORTH_WORDS 
2c50			;		DMARK "FGc" 
2c50			;		CALLMONITOR 
2c50			;	endif 
2c50			;		call strcmp 
2c50			;		jp nz, .fnuword 
2c50			 
2c50			 
2c50 e1			pop hl 
2c51			 
2c51				 
2c51				if DEBUG_FORTH_WORDS 
2c51					DMARK "FGm" 
2c51 f5				push af  
2c52 3a 66 2c			ld a, (.dmark)  
2c55 32 77 fb			ld (debug_mark),a  
2c58 3a 67 2c			ld a, (.dmark+1)  
2c5b 32 78 fb			ld (debug_mark+1),a  
2c5e 3a 68 2c			ld a, (.dmark+2)  
2c61 32 79 fb			ld (debug_mark+2),a  
2c64 18 03			jr .pastdmark  
2c66 ..			.dmark: db "FGm"  
2c69 f1			.pastdmark: pop af  
2c6a			endm  
# End of macro DMARK
2c6a					CALLMONITOR 
2c6a cd 92 16			call break_point_state  
2c6d				endm  
# End of macro CALLMONITOR
2c6d				endif 
2c6d			 
2c6d			 
2c6d			 
2c6d					; we have a uword so push its name to the stack 
2c6d			 
2c6d			;	   	push hl  ; save so we can move to next dict block 
2c6d			;pop hl 
2c6d			 
2c6d					; update opcode to deleted 
2c6d 3e 03				ld a, WORD_SYS_DELETED 
2c6f 77					ld (hl), a 
2c70			 
2c70 23					inc hl  
2c71					; skip next ptr 
2c71 23					inc hl  
2c72 23					inc hl 
2c73					; skip len 
2c73 23					inc hl 
2c74			 
2c74					; TODO change parser to skip deleted words but for now mark it out 
2c74 3e 5f				ld a, "_" 
2c76 77					ld  (hl),a 
2c77			 
2c77			;		jr .fudone 
2c77			; 
2c77			;.fnuword:	pop hl 
2c77			;		call forth_tok_next 
2c77			;		jp .fdouscan  
2c77			 
2c77			.flunotfound:		  
2c77			 
2c77			 
2c77					 
2c77					FORTH_DSP_POP 
2c77 cd ce 1e			call macro_forth_dsp_pop 
2c7a				endm 
# End of macro FORTH_DSP_POP
2c7a			;		ld hl, .luno 
2c7a			;.fudone:		 pop hl 
2c7a					NEXTW 
2c7a c3 88 1f			jp macro_next 
2c7d				endm 
# End of macro NEXTW
2c7d			.NOP: 
2c7d				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c7d 61				db WORD_SYS_CORE+77             
2c7e a4 2c			dw .COMO            
2c80 04				db 3 + 1 
2c81 .. 00			db "NOP",0              
2c85				endm 
# End of macro CWHEAD
2c85			; | NOP (  --  ) Do nothing | DONE 
2c85					if DEBUG_FORTH_WORDS_KEY 
2c85						DMARK "NOP" 
2c85 f5				push af  
2c86 3a 9a 2c			ld a, (.dmark)  
2c89 32 77 fb			ld (debug_mark),a  
2c8c 3a 9b 2c			ld a, (.dmark+1)  
2c8f 32 78 fb			ld (debug_mark+1),a  
2c92 3a 9c 2c			ld a, (.dmark+2)  
2c95 32 79 fb			ld (debug_mark+2),a  
2c98 18 03			jr .pastdmark  
2c9a ..			.dmark: db "NOP"  
2c9d f1			.pastdmark: pop af  
2c9e			endm  
# End of macro DMARK
2c9e						CALLMONITOR 
2c9e cd 92 16			call break_point_state  
2ca1				endm  
# End of macro CALLMONITOR
2ca1					endif 
2ca1				       NEXTW 
2ca1 c3 88 1f			jp macro_next 
2ca4				endm 
# End of macro NEXTW
2ca4			.COMO: 
2ca4				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2ca4 6e				db WORD_SYS_CORE+90             
2ca5 f6 2c			dw .COMC            
2ca7 02				db 1 + 1 
2ca8 .. 00			db "(",0              
2caa				endm 
# End of macro CWHEAD
2caa			; | ( ( -- )  Start of comment | DONE 
2caa			 
2caa			 
2caa 2a 1e f1				ld hl, ( os_tok_ptr) 
2cad 11 f1 2c			ld de, .closepar 
2cb0					 
2cb0					if DEBUG_FORTH_WORDS 
2cb0						DMARK ").." 
2cb0 f5				push af  
2cb1 3a c5 2c			ld a, (.dmark)  
2cb4 32 77 fb			ld (debug_mark),a  
2cb7 3a c6 2c			ld a, (.dmark+1)  
2cba 32 78 fb			ld (debug_mark+1),a  
2cbd 3a c7 2c			ld a, (.dmark+2)  
2cc0 32 79 fb			ld (debug_mark+2),a  
2cc3 18 03			jr .pastdmark  
2cc5 ..			.dmark: db ").."  
2cc8 f1			.pastdmark: pop af  
2cc9			endm  
# End of macro DMARK
2cc9						CALLMONITOR 
2cc9 cd 92 16			call break_point_state  
2ccc				endm  
# End of macro CALLMONITOR
2ccc					endif 
2ccc cd a3 20			call findnexttok  
2ccf			 
2ccf					if DEBUG_FORTH_WORDS 
2ccf						DMARK "IF5" 
2ccf f5				push af  
2cd0 3a e4 2c			ld a, (.dmark)  
2cd3 32 77 fb			ld (debug_mark),a  
2cd6 3a e5 2c			ld a, (.dmark+1)  
2cd9 32 78 fb			ld (debug_mark+1),a  
2cdc 3a e6 2c			ld a, (.dmark+2)  
2cdf 32 79 fb			ld (debug_mark+2),a  
2ce2 18 03			jr .pastdmark  
2ce4 ..			.dmark: db "IF5"  
2ce7 f1			.pastdmark: pop af  
2ce8			endm  
# End of macro DMARK
2ce8						CALLMONITOR 
2ce8 cd 92 16			call break_point_state  
2ceb				endm  
# End of macro CALLMONITOR
2ceb					endif 
2ceb				; replace below with ) exec using tok_ptr 
2ceb 22 1e f1			ld (os_tok_ptr), hl 
2cee c3 19 20			jp exec1 
2cf1			 
2cf1 .. 00			.closepar:   db ")",0 
2cf3			 
2cf3				       NEXTW 
2cf3 c3 88 1f			jp macro_next 
2cf6				endm 
# End of macro NEXTW
2cf6			.COMC: 
2cf6				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2cf6 6f				db WORD_SYS_CORE+91             
2cf7 ff 2c			dw .SCRATCH            
2cf9 02				db 1 + 1 
2cfa .. 00			db ")",0              
2cfc				endm 
# End of macro CWHEAD
2cfc			; | ) ( -- )  End of comment |  DONE  
2cfc				       NEXTW 
2cfc c3 88 1f			jp macro_next 
2cff				endm 
# End of macro NEXTW
2cff			 
2cff			.SCRATCH: 
2cff				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2cff 6f				db WORD_SYS_CORE+91             
2d00 3a 2d			dw .INC            
2d02 08				db 7 + 1 
2d03 .. 00			db "SCRATCH",0              
2d0b				endm 
# End of macro CWHEAD
2d0b			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2d0b			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2d0b			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2d0b			; | |  
2d0b			; | | e.g.    : score $00 scratch ; 
2d0b			; | |  
2d0b			; | | $00 score ! 
2d0b			; | | $01 score +! 
2d0b			; | |  
2d0b			; | | e.g.   : varword $0a scratch ;  
2d0b			; | | 
2d0b			; | | $8000 varword ! 
2d0b					if DEBUG_FORTH_WORDS_KEY 
2d0b						DMARK "SCR" 
2d0b f5				push af  
2d0c 3a 20 2d			ld a, (.dmark)  
2d0f 32 77 fb			ld (debug_mark),a  
2d12 3a 21 2d			ld a, (.dmark+1)  
2d15 32 78 fb			ld (debug_mark+1),a  
2d18 3a 22 2d			ld a, (.dmark+2)  
2d1b 32 79 fb			ld (debug_mark+2),a  
2d1e 18 03			jr .pastdmark  
2d20 ..			.dmark: db "SCR"  
2d23 f1			.pastdmark: pop af  
2d24			endm  
# End of macro DMARK
2d24						CALLMONITOR 
2d24 cd 92 16			call break_point_state  
2d27				endm  
# End of macro CALLMONITOR
2d27					endif 
2d27			 
2d27					FORTH_DSP_VALUEHL 
2d27 cd 16 1e			call macro_dsp_valuehl 
2d2a				endm 
# End of macro FORTH_DSP_VALUEHL
2d2a				 
2d2a					FORTH_DSP_POP 
2d2a cd ce 1e			call macro_forth_dsp_pop 
2d2d				endm 
# End of macro FORTH_DSP_POP
2d2d			 
2d2d 7d					ld a, l 
2d2e 21 42 f3				ld hl, os_var_array 
2d31 cd 09 0d				call addatohl 
2d34			 
2d34 cd 1f 1c				call forth_push_numhl 
2d37			 
2d37				       NEXTW 
2d37 c3 88 1f			jp macro_next 
2d3a				endm 
# End of macro NEXTW
2d3a			 
2d3a			.INC: 
2d3a				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2d3a 6f				db WORD_SYS_CORE+91             
2d3b 8e 2d			dw .DEC            
2d3d 03				db 2 + 1 
2d3e .. 00			db "+!",0              
2d41				endm 
# End of macro CWHEAD
2d41			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2d41					if DEBUG_FORTH_WORDS_KEY 
2d41						DMARK "+s_" 
2d41 f5				push af  
2d42 3a 56 2d			ld a, (.dmark)  
2d45 32 77 fb			ld (debug_mark),a  
2d48 3a 57 2d			ld a, (.dmark+1)  
2d4b 32 78 fb			ld (debug_mark+1),a  
2d4e 3a 58 2d			ld a, (.dmark+2)  
2d51 32 79 fb			ld (debug_mark+2),a  
2d54 18 03			jr .pastdmark  
2d56 ..			.dmark: db "+s_"  
2d59 f1			.pastdmark: pop af  
2d5a			endm  
# End of macro DMARK
2d5a						CALLMONITOR 
2d5a cd 92 16			call break_point_state  
2d5d				endm  
# End of macro CALLMONITOR
2d5d					endif 
2d5d			 
2d5d					FORTH_DSP_VALUEHL 
2d5d cd 16 1e			call macro_dsp_valuehl 
2d60				endm 
# End of macro FORTH_DSP_VALUEHL
2d60			 
2d60 e5					push hl   ; save address 
2d61			 
2d61					FORTH_DSP_POP 
2d61 cd ce 1e			call macro_forth_dsp_pop 
2d64				endm 
# End of macro FORTH_DSP_POP
2d64			 
2d64					FORTH_DSP_VALUEHL 
2d64 cd 16 1e			call macro_dsp_valuehl 
2d67				endm 
# End of macro FORTH_DSP_VALUEHL
2d67			 
2d67					FORTH_DSP_POP 
2d67 cd ce 1e			call macro_forth_dsp_pop 
2d6a				endm 
# End of macro FORTH_DSP_POP
2d6a			 
2d6a					; hl contains value to add to byte at a 
2d6a				 
2d6a eb					ex de, hl 
2d6b			 
2d6b e1					pop hl 
2d6c			 
2d6c					if DEBUG_FORTH_WORDS 
2d6c						DMARK "INC" 
2d6c f5				push af  
2d6d 3a 81 2d			ld a, (.dmark)  
2d70 32 77 fb			ld (debug_mark),a  
2d73 3a 82 2d			ld a, (.dmark+1)  
2d76 32 78 fb			ld (debug_mark+1),a  
2d79 3a 83 2d			ld a, (.dmark+2)  
2d7c 32 79 fb			ld (debug_mark+2),a  
2d7f 18 03			jr .pastdmark  
2d81 ..			.dmark: db "INC"  
2d84 f1			.pastdmark: pop af  
2d85			endm  
# End of macro DMARK
2d85						CALLMONITOR 
2d85 cd 92 16			call break_point_state  
2d88				endm  
# End of macro CALLMONITOR
2d88					endif 
2d88			 
2d88 7e					ld a,(hl) 
2d89 83					add e 
2d8a 77					ld (hl),a 
2d8b			 
2d8b			 
2d8b			 
2d8b				       NEXTW 
2d8b c3 88 1f			jp macro_next 
2d8e				endm 
# End of macro NEXTW
2d8e			 
2d8e			.DEC: 
2d8e				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d8e 6f				db WORD_SYS_CORE+91             
2d8f df 2d			dw .INC2            
2d91 03				db 2 + 1 
2d92 .. 00			db "-!",0              
2d95				endm 
# End of macro CWHEAD
2d95			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d95					if DEBUG_FORTH_WORDS_KEY 
2d95						DMARK "-s_" 
2d95 f5				push af  
2d96 3a aa 2d			ld a, (.dmark)  
2d99 32 77 fb			ld (debug_mark),a  
2d9c 3a ab 2d			ld a, (.dmark+1)  
2d9f 32 78 fb			ld (debug_mark+1),a  
2da2 3a ac 2d			ld a, (.dmark+2)  
2da5 32 79 fb			ld (debug_mark+2),a  
2da8 18 03			jr .pastdmark  
2daa ..			.dmark: db "-s_"  
2dad f1			.pastdmark: pop af  
2dae			endm  
# End of macro DMARK
2dae						CALLMONITOR 
2dae cd 92 16			call break_point_state  
2db1				endm  
# End of macro CALLMONITOR
2db1					endif 
2db1			 
2db1					FORTH_DSP_VALUEHL 
2db1 cd 16 1e			call macro_dsp_valuehl 
2db4				endm 
# End of macro FORTH_DSP_VALUEHL
2db4			 
2db4 e5					push hl   ; save address 
2db5			 
2db5					FORTH_DSP_POP 
2db5 cd ce 1e			call macro_forth_dsp_pop 
2db8				endm 
# End of macro FORTH_DSP_POP
2db8			 
2db8					FORTH_DSP_VALUEHL 
2db8 cd 16 1e			call macro_dsp_valuehl 
2dbb				endm 
# End of macro FORTH_DSP_VALUEHL
2dbb			 
2dbb					; hl contains value to add to byte at a 
2dbb				 
2dbb eb					ex de, hl 
2dbc			 
2dbc e1					pop hl 
2dbd			 
2dbd					if DEBUG_FORTH_WORDS 
2dbd						DMARK "DEC" 
2dbd f5				push af  
2dbe 3a d2 2d			ld a, (.dmark)  
2dc1 32 77 fb			ld (debug_mark),a  
2dc4 3a d3 2d			ld a, (.dmark+1)  
2dc7 32 78 fb			ld (debug_mark+1),a  
2dca 3a d4 2d			ld a, (.dmark+2)  
2dcd 32 79 fb			ld (debug_mark+2),a  
2dd0 18 03			jr .pastdmark  
2dd2 ..			.dmark: db "DEC"  
2dd5 f1			.pastdmark: pop af  
2dd6			endm  
# End of macro DMARK
2dd6						CALLMONITOR 
2dd6 cd 92 16			call break_point_state  
2dd9				endm  
# End of macro CALLMONITOR
2dd9					endif 
2dd9			 
2dd9 7e					ld a,(hl) 
2dda 93					sub e 
2ddb 77					ld (hl),a 
2ddc			 
2ddc			 
2ddc			 
2ddc				       NEXTW 
2ddc c3 88 1f			jp macro_next 
2ddf				endm 
# End of macro NEXTW
2ddf			 
2ddf			.INC2: 
2ddf				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2ddf 6f				db WORD_SYS_CORE+91             
2de0 89 2e			dw .DEC2            
2de2 04				db 3 + 1 
2de3 .. 00			db "+2!",0              
2de7				endm 
# End of macro CWHEAD
2de7			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2de7			 
2de7					if DEBUG_FORTH_WORDS_KEY 
2de7						DMARK "+2s" 
2de7 f5				push af  
2de8 3a fc 2d			ld a, (.dmark)  
2deb 32 77 fb			ld (debug_mark),a  
2dee 3a fd 2d			ld a, (.dmark+1)  
2df1 32 78 fb			ld (debug_mark+1),a  
2df4 3a fe 2d			ld a, (.dmark+2)  
2df7 32 79 fb			ld (debug_mark+2),a  
2dfa 18 03			jr .pastdmark  
2dfc ..			.dmark: db "+2s"  
2dff f1			.pastdmark: pop af  
2e00			endm  
# End of macro DMARK
2e00						CALLMONITOR 
2e00 cd 92 16			call break_point_state  
2e03				endm  
# End of macro CALLMONITOR
2e03					endif 
2e03			 
2e03					; Address 
2e03			 
2e03					FORTH_DSP_VALUEHL 
2e03 cd 16 1e			call macro_dsp_valuehl 
2e06				endm 
# End of macro FORTH_DSP_VALUEHL
2e06			 
2e06 e5					push hl    ; save address 
2e07			 
2e07					; load content into de 
2e07			 
2e07 5e					ld e,(hl) 
2e08 23					inc hl 
2e09 56					ld d, (hl) 
2e0a			 
2e0a					if DEBUG_FORTH_WORDS 
2e0a						DMARK "+2a" 
2e0a f5				push af  
2e0b 3a 1f 2e			ld a, (.dmark)  
2e0e 32 77 fb			ld (debug_mark),a  
2e11 3a 20 2e			ld a, (.dmark+1)  
2e14 32 78 fb			ld (debug_mark+1),a  
2e17 3a 21 2e			ld a, (.dmark+2)  
2e1a 32 79 fb			ld (debug_mark+2),a  
2e1d 18 03			jr .pastdmark  
2e1f ..			.dmark: db "+2a"  
2e22 f1			.pastdmark: pop af  
2e23			endm  
# End of macro DMARK
2e23						CALLMONITOR 
2e23 cd 92 16			call break_point_state  
2e26				endm  
# End of macro CALLMONITOR
2e26					endif 
2e26			 
2e26					FORTH_DSP_POP 
2e26 cd ce 1e			call macro_forth_dsp_pop 
2e29				endm 
# End of macro FORTH_DSP_POP
2e29			 
2e29					; Get value to add 
2e29			 
2e29					FORTH_DSP_VALUE 
2e29 cd ff 1d			call macro_forth_dsp_value 
2e2c				endm 
# End of macro FORTH_DSP_VALUE
2e2c			 
2e2c					if DEBUG_FORTH_WORDS 
2e2c						DMARK "+2v" 
2e2c f5				push af  
2e2d 3a 41 2e			ld a, (.dmark)  
2e30 32 77 fb			ld (debug_mark),a  
2e33 3a 42 2e			ld a, (.dmark+1)  
2e36 32 78 fb			ld (debug_mark+1),a  
2e39 3a 43 2e			ld a, (.dmark+2)  
2e3c 32 79 fb			ld (debug_mark+2),a  
2e3f 18 03			jr .pastdmark  
2e41 ..			.dmark: db "+2v"  
2e44 f1			.pastdmark: pop af  
2e45			endm  
# End of macro DMARK
2e45						CALLMONITOR 
2e45 cd 92 16			call break_point_state  
2e48				endm  
# End of macro CALLMONITOR
2e48					endif 
2e48			 
2e48 19					add hl, de 
2e49			 
2e49					if DEBUG_FORTH_WORDS 
2e49						DMARK "+2+" 
2e49 f5				push af  
2e4a 3a 5e 2e			ld a, (.dmark)  
2e4d 32 77 fb			ld (debug_mark),a  
2e50 3a 5f 2e			ld a, (.dmark+1)  
2e53 32 78 fb			ld (debug_mark+1),a  
2e56 3a 60 2e			ld a, (.dmark+2)  
2e59 32 79 fb			ld (debug_mark+2),a  
2e5c 18 03			jr .pastdmark  
2e5e ..			.dmark: db "+2+"  
2e61 f1			.pastdmark: pop af  
2e62			endm  
# End of macro DMARK
2e62						CALLMONITOR 
2e62 cd 92 16			call break_point_state  
2e65				endm  
# End of macro CALLMONITOR
2e65					endif 
2e65			 
2e65					; move result to de 
2e65			 
2e65 eb					ex de, hl 
2e66			 
2e66					; Address 
2e66			 
2e66 e1					pop hl 
2e67			 
2e67					; save it back 
2e67			 
2e67 73					ld (hl), e 
2e68 23					inc hl 
2e69 72					ld (hl), d 
2e6a			 
2e6a					if DEBUG_FORTH_WORDS 
2e6a						DMARK "+2e" 
2e6a f5				push af  
2e6b 3a 7f 2e			ld a, (.dmark)  
2e6e 32 77 fb			ld (debug_mark),a  
2e71 3a 80 2e			ld a, (.dmark+1)  
2e74 32 78 fb			ld (debug_mark+1),a  
2e77 3a 81 2e			ld a, (.dmark+2)  
2e7a 32 79 fb			ld (debug_mark+2),a  
2e7d 18 03			jr .pastdmark  
2e7f ..			.dmark: db "+2e"  
2e82 f1			.pastdmark: pop af  
2e83			endm  
# End of macro DMARK
2e83						CALLMONITOR 
2e83 cd 92 16			call break_point_state  
2e86				endm  
# End of macro CALLMONITOR
2e86					endif 
2e86			 
2e86			 
2e86			 
2e86			 
2e86			 
2e86				       NEXTW 
2e86 c3 88 1f			jp macro_next 
2e89				endm 
# End of macro NEXTW
2e89			 
2e89			.DEC2: 
2e89				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e89 6f				db WORD_SYS_CORE+91             
2e8a 35 2f			dw .GET2            
2e8c 04				db 3 + 1 
2e8d .. 00			db "-2!",0              
2e91				endm 
# End of macro CWHEAD
2e91			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e91			 
2e91			 
2e91					if DEBUG_FORTH_WORDS_KEY 
2e91						DMARK "-2s" 
2e91 f5				push af  
2e92 3a a6 2e			ld a, (.dmark)  
2e95 32 77 fb			ld (debug_mark),a  
2e98 3a a7 2e			ld a, (.dmark+1)  
2e9b 32 78 fb			ld (debug_mark+1),a  
2e9e 3a a8 2e			ld a, (.dmark+2)  
2ea1 32 79 fb			ld (debug_mark+2),a  
2ea4 18 03			jr .pastdmark  
2ea6 ..			.dmark: db "-2s"  
2ea9 f1			.pastdmark: pop af  
2eaa			endm  
# End of macro DMARK
2eaa						CALLMONITOR 
2eaa cd 92 16			call break_point_state  
2ead				endm  
# End of macro CALLMONITOR
2ead					endif 
2ead			 
2ead					; Address 
2ead			 
2ead					FORTH_DSP_VALUEHL 
2ead cd 16 1e			call macro_dsp_valuehl 
2eb0				endm 
# End of macro FORTH_DSP_VALUEHL
2eb0			 
2eb0 e5					push hl    ; save address 
2eb1			 
2eb1					; load content into de 
2eb1			 
2eb1 5e					ld e,(hl) 
2eb2 23					inc hl 
2eb3 56					ld d, (hl) 
2eb4			 
2eb4					if DEBUG_FORTH_WORDS 
2eb4						DMARK "-2a" 
2eb4 f5				push af  
2eb5 3a c9 2e			ld a, (.dmark)  
2eb8 32 77 fb			ld (debug_mark),a  
2ebb 3a ca 2e			ld a, (.dmark+1)  
2ebe 32 78 fb			ld (debug_mark+1),a  
2ec1 3a cb 2e			ld a, (.dmark+2)  
2ec4 32 79 fb			ld (debug_mark+2),a  
2ec7 18 03			jr .pastdmark  
2ec9 ..			.dmark: db "-2a"  
2ecc f1			.pastdmark: pop af  
2ecd			endm  
# End of macro DMARK
2ecd						CALLMONITOR 
2ecd cd 92 16			call break_point_state  
2ed0				endm  
# End of macro CALLMONITOR
2ed0					endif 
2ed0			 
2ed0					FORTH_DSP_POP 
2ed0 cd ce 1e			call macro_forth_dsp_pop 
2ed3				endm 
# End of macro FORTH_DSP_POP
2ed3			 
2ed3					; Get value to remove 
2ed3			 
2ed3					FORTH_DSP_VALUE 
2ed3 cd ff 1d			call macro_forth_dsp_value 
2ed6				endm 
# End of macro FORTH_DSP_VALUE
2ed6			 
2ed6					if DEBUG_FORTH_WORDS 
2ed6						DMARK "-2v" 
2ed6 f5				push af  
2ed7 3a eb 2e			ld a, (.dmark)  
2eda 32 77 fb			ld (debug_mark),a  
2edd 3a ec 2e			ld a, (.dmark+1)  
2ee0 32 78 fb			ld (debug_mark+1),a  
2ee3 3a ed 2e			ld a, (.dmark+2)  
2ee6 32 79 fb			ld (debug_mark+2),a  
2ee9 18 03			jr .pastdmark  
2eeb ..			.dmark: db "-2v"  
2eee f1			.pastdmark: pop af  
2eef			endm  
# End of macro DMARK
2eef						CALLMONITOR 
2eef cd 92 16			call break_point_state  
2ef2				endm  
# End of macro CALLMONITOR
2ef2					endif 
2ef2			 
2ef2 eb					ex de, hl 
2ef3 ed 52				sbc hl, de 
2ef5			 
2ef5					if DEBUG_FORTH_WORDS 
2ef5						DMARK "-2d" 
2ef5 f5				push af  
2ef6 3a 0a 2f			ld a, (.dmark)  
2ef9 32 77 fb			ld (debug_mark),a  
2efc 3a 0b 2f			ld a, (.dmark+1)  
2eff 32 78 fb			ld (debug_mark+1),a  
2f02 3a 0c 2f			ld a, (.dmark+2)  
2f05 32 79 fb			ld (debug_mark+2),a  
2f08 18 03			jr .pastdmark  
2f0a ..			.dmark: db "-2d"  
2f0d f1			.pastdmark: pop af  
2f0e			endm  
# End of macro DMARK
2f0e						CALLMONITOR 
2f0e cd 92 16			call break_point_state  
2f11				endm  
# End of macro CALLMONITOR
2f11					endif 
2f11			 
2f11					; move result to de 
2f11			 
2f11 eb					ex de, hl 
2f12			 
2f12					; Address 
2f12			 
2f12 e1					pop hl 
2f13			 
2f13					; save it back 
2f13			 
2f13 73					ld (hl), e 
2f14 23					inc hl 
2f15 72					ld (hl), d 
2f16			 
2f16					if DEBUG_FORTH_WORDS 
2f16						DMARK "-2e" 
2f16 f5				push af  
2f17 3a 2b 2f			ld a, (.dmark)  
2f1a 32 77 fb			ld (debug_mark),a  
2f1d 3a 2c 2f			ld a, (.dmark+1)  
2f20 32 78 fb			ld (debug_mark+1),a  
2f23 3a 2d 2f			ld a, (.dmark+2)  
2f26 32 79 fb			ld (debug_mark+2),a  
2f29 18 03			jr .pastdmark  
2f2b ..			.dmark: db "-2e"  
2f2e f1			.pastdmark: pop af  
2f2f			endm  
# End of macro DMARK
2f2f						CALLMONITOR 
2f2f cd 92 16			call break_point_state  
2f32				endm  
# End of macro CALLMONITOR
2f32					endif 
2f32			 
2f32			 
2f32			 
2f32			 
2f32			 
2f32				       NEXTW 
2f32 c3 88 1f			jp macro_next 
2f35				endm 
# End of macro NEXTW
2f35			.GET2: 
2f35				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2f35 6f				db WORD_SYS_CORE+91             
2f36 65 2f			dw .BANG2            
2f38 03				db 2 + 1 
2f39 .. 00			db "2@",0              
2f3c				endm 
# End of macro CWHEAD
2f3c			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2f3c					if DEBUG_FORTH_WORDS_KEY 
2f3c						DMARK "2A_" 
2f3c f5				push af  
2f3d 3a 51 2f			ld a, (.dmark)  
2f40 32 77 fb			ld (debug_mark),a  
2f43 3a 52 2f			ld a, (.dmark+1)  
2f46 32 78 fb			ld (debug_mark+1),a  
2f49 3a 53 2f			ld a, (.dmark+2)  
2f4c 32 79 fb			ld (debug_mark+2),a  
2f4f 18 03			jr .pastdmark  
2f51 ..			.dmark: db "2A_"  
2f54 f1			.pastdmark: pop af  
2f55			endm  
# End of macro DMARK
2f55						CALLMONITOR 
2f55 cd 92 16			call break_point_state  
2f58				endm  
# End of macro CALLMONITOR
2f58					endif 
2f58			 
2f58					FORTH_DSP_VALUEHL 
2f58 cd 16 1e			call macro_dsp_valuehl 
2f5b				endm 
# End of macro FORTH_DSP_VALUEHL
2f5b			 
2f5b 5e					ld e, (hl) 
2f5c 23					inc hl 
2f5d 56					ld d, (hl) 
2f5e			 
2f5e eb					ex de, hl 
2f5f			 
2f5f cd 1f 1c				call forth_push_numhl 
2f62			 
2f62				       NEXTW 
2f62 c3 88 1f			jp macro_next 
2f65				endm 
# End of macro NEXTW
2f65			.BANG2: 
2f65				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2f65 6f				db WORD_SYS_CORE+91             
2f66 9d 2f			dw .CONFIG            
2f68 03				db 2 + 1 
2f69 .. 00			db "2!",0              
2f6c				endm 
# End of macro CWHEAD
2f6c			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2f6c					if DEBUG_FORTH_WORDS_KEY 
2f6c						DMARK "2S_" 
2f6c f5				push af  
2f6d 3a 81 2f			ld a, (.dmark)  
2f70 32 77 fb			ld (debug_mark),a  
2f73 3a 82 2f			ld a, (.dmark+1)  
2f76 32 78 fb			ld (debug_mark+1),a  
2f79 3a 83 2f			ld a, (.dmark+2)  
2f7c 32 79 fb			ld (debug_mark+2),a  
2f7f 18 03			jr .pastdmark  
2f81 ..			.dmark: db "2S_"  
2f84 f1			.pastdmark: pop af  
2f85			endm  
# End of macro DMARK
2f85						CALLMONITOR 
2f85 cd 92 16			call break_point_state  
2f88				endm  
# End of macro CALLMONITOR
2f88					endif 
2f88			 
2f88					FORTH_DSP_VALUEHL 
2f88 cd 16 1e			call macro_dsp_valuehl 
2f8b				endm 
# End of macro FORTH_DSP_VALUEHL
2f8b			 
2f8b e5					push hl   ; save address 
2f8c			 
2f8c			 
2f8c					FORTH_DSP_POP 
2f8c cd ce 1e			call macro_forth_dsp_pop 
2f8f				endm 
# End of macro FORTH_DSP_POP
2f8f			 
2f8f					 
2f8f					FORTH_DSP_VALUEHL 
2f8f cd 16 1e			call macro_dsp_valuehl 
2f92				endm 
# End of macro FORTH_DSP_VALUEHL
2f92			 
2f92					FORTH_DSP_POP 
2f92 cd ce 1e			call macro_forth_dsp_pop 
2f95				endm 
# End of macro FORTH_DSP_POP
2f95			 
2f95 eb					ex de, hl    ; value now in de 
2f96			 
2f96 e1					pop hl 
2f97			 
2f97 73					ld (hl), e 
2f98			 
2f98 23					inc hl 
2f99			 
2f99 72					ld (hl), d 
2f9a			 
2f9a			 
2f9a				       NEXTW 
2f9a c3 88 1f			jp macro_next 
2f9d				endm 
# End of macro NEXTW
2f9d			.CONFIG: 
2f9d				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f9d 6f				db WORD_SYS_CORE+91             
2f9e ae 2f			dw .ENDCORE            
2fa0 07				db 6 + 1 
2fa1 .. 00			db "CONFIG",0              
2fa8				endm 
# End of macro CWHEAD
2fa8			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2fa8			 
2fa8 cd 93 13				call config 
2fab					NEXTW 
2fab c3 88 1f			jp macro_next 
2fae				endm 
# End of macro NEXTW
2fae			.ENDCORE: 
2fae			 
2fae			; eof 
2fae			 
2fae			 
# End of file forth_words_core.asm
2fae			include "forth_words_flow.asm" 
2fae			 
2fae			; | ## Program Flow Words 
2fae			 
2fae			.IF: 
2fae				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2fae 1e				db WORD_SYS_CORE+10             
2faf a3 30			dw .THEN            
2fb1 03				db 2 + 1 
2fb2 .. 00			db "IF",0              
2fb5				endm 
# End of macro CWHEAD
2fb5			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2fb5			; 
2fb5					if DEBUG_FORTH_WORDS_KEY 
2fb5						DMARK "IF." 
2fb5 f5				push af  
2fb6 3a ca 2f			ld a, (.dmark)  
2fb9 32 77 fb			ld (debug_mark),a  
2fbc 3a cb 2f			ld a, (.dmark+1)  
2fbf 32 78 fb			ld (debug_mark+1),a  
2fc2 3a cc 2f			ld a, (.dmark+2)  
2fc5 32 79 fb			ld (debug_mark+2),a  
2fc8 18 03			jr .pastdmark  
2fca ..			.dmark: db "IF."  
2fcd f1			.pastdmark: pop af  
2fce			endm  
# End of macro DMARK
2fce						CALLMONITOR 
2fce cd 92 16			call break_point_state  
2fd1				endm  
# End of macro CALLMONITOR
2fd1					endif 
2fd1			; eval TOS 
2fd1			 
2fd1				FORTH_DSP_VALUEHL 
2fd1 cd 16 1e			call macro_dsp_valuehl 
2fd4				endm 
# End of macro FORTH_DSP_VALUEHL
2fd4			 
2fd4			;	push hl 
2fd4				FORTH_DSP_POP 
2fd4 cd ce 1e			call macro_forth_dsp_pop 
2fd7				endm 
# End of macro FORTH_DSP_POP
2fd7			;	pop hl 
2fd7			 
2fd7					if DEBUG_FORTH_WORDS 
2fd7						DMARK "IF1" 
2fd7 f5				push af  
2fd8 3a ec 2f			ld a, (.dmark)  
2fdb 32 77 fb			ld (debug_mark),a  
2fde 3a ed 2f			ld a, (.dmark+1)  
2fe1 32 78 fb			ld (debug_mark+1),a  
2fe4 3a ee 2f			ld a, (.dmark+2)  
2fe7 32 79 fb			ld (debug_mark+2),a  
2fea 18 03			jr .pastdmark  
2fec ..			.dmark: db "IF1"  
2fef f1			.pastdmark: pop af  
2ff0			endm  
# End of macro DMARK
2ff0						CALLMONITOR 
2ff0 cd 92 16			call break_point_state  
2ff3				endm  
# End of macro CALLMONITOR
2ff3					endif 
2ff3 b7				or a        ; clear carry flag 
2ff4 11 00 00			ld de, 0 
2ff7 eb				ex de,hl 
2ff8 ed 52			sbc hl, de 
2ffa c2 84 30			jp nz, .iftrue 
2ffd			 
2ffd					if DEBUG_FORTH_WORDS 
2ffd						DMARK "IF2" 
2ffd f5				push af  
2ffe 3a 12 30			ld a, (.dmark)  
3001 32 77 fb			ld (debug_mark),a  
3004 3a 13 30			ld a, (.dmark+1)  
3007 32 78 fb			ld (debug_mark+1),a  
300a 3a 14 30			ld a, (.dmark+2)  
300d 32 79 fb			ld (debug_mark+2),a  
3010 18 03			jr .pastdmark  
3012 ..			.dmark: db "IF2"  
3015 f1			.pastdmark: pop af  
3016			endm  
# End of macro DMARK
3016						CALLMONITOR 
3016 cd 92 16			call break_point_state  
3019				endm  
# End of macro CALLMONITOR
3019					endif 
3019			 
3019			; if not true then skip to THEN 
3019			 
3019				; TODO get tok_ptr 
3019				; TODO consume toks until we get to THEN 
3019			 
3019 2a 1e f1			ld hl, (os_tok_ptr) 
301c					if DEBUG_FORTH_WORDS 
301c						DMARK "IF3" 
301c f5				push af  
301d 3a 31 30			ld a, (.dmark)  
3020 32 77 fb			ld (debug_mark),a  
3023 3a 32 30			ld a, (.dmark+1)  
3026 32 78 fb			ld (debug_mark+1),a  
3029 3a 33 30			ld a, (.dmark+2)  
302c 32 79 fb			ld (debug_mark+2),a  
302f 18 03			jr .pastdmark  
3031 ..			.dmark: db "IF3"  
3034 f1			.pastdmark: pop af  
3035			endm  
# End of macro DMARK
3035						CALLMONITOR 
3035 cd 92 16			call break_point_state  
3038				endm  
# End of macro CALLMONITOR
3038						 
3038					endif 
3038 11 7f 30			ld de, .ifthen 
303b					if DEBUG_FORTH_WORDS 
303b						DMARK "IF4" 
303b f5				push af  
303c 3a 50 30			ld a, (.dmark)  
303f 32 77 fb			ld (debug_mark),a  
3042 3a 51 30			ld a, (.dmark+1)  
3045 32 78 fb			ld (debug_mark+1),a  
3048 3a 52 30			ld a, (.dmark+2)  
304b 32 79 fb			ld (debug_mark+2),a  
304e 18 03			jr .pastdmark  
3050 ..			.dmark: db "IF4"  
3053 f1			.pastdmark: pop af  
3054			endm  
# End of macro DMARK
3054						CALLMONITOR 
3054 cd 92 16			call break_point_state  
3057				endm  
# End of macro CALLMONITOR
3057					endif 
3057 cd a3 20			call findnexttok  
305a			 
305a					if DEBUG_FORTH_WORDS 
305a						DMARK "IF5" 
305a f5				push af  
305b 3a 6f 30			ld a, (.dmark)  
305e 32 77 fb			ld (debug_mark),a  
3061 3a 70 30			ld a, (.dmark+1)  
3064 32 78 fb			ld (debug_mark+1),a  
3067 3a 71 30			ld a, (.dmark+2)  
306a 32 79 fb			ld (debug_mark+2),a  
306d 18 03			jr .pastdmark  
306f ..			.dmark: db "IF5"  
3072 f1			.pastdmark: pop af  
3073			endm  
# End of macro DMARK
3073						CALLMONITOR 
3073 cd 92 16			call break_point_state  
3076				endm  
# End of macro CALLMONITOR
3076					endif 
3076				; TODO replace below with ; exec using tok_ptr 
3076 22 1e f1			ld (os_tok_ptr), hl 
3079 c3 19 20			jp exec1 
307c				NEXTW 
307c c3 88 1f			jp macro_next 
307f				endm 
# End of macro NEXTW
307f			 
307f .. 00		.ifthen:  db "THEN",0 
3084			 
3084			.iftrue:		 
3084				; Exec next words normally 
3084			 
3084				; if true then exec following IF as normal 
3084					if DEBUG_FORTH_WORDS 
3084						DMARK "IFT" 
3084 f5				push af  
3085 3a 99 30			ld a, (.dmark)  
3088 32 77 fb			ld (debug_mark),a  
308b 3a 9a 30			ld a, (.dmark+1)  
308e 32 78 fb			ld (debug_mark+1),a  
3091 3a 9b 30			ld a, (.dmark+2)  
3094 32 79 fb			ld (debug_mark+2),a  
3097 18 03			jr .pastdmark  
3099 ..			.dmark: db "IFT"  
309c f1			.pastdmark: pop af  
309d			endm  
# End of macro DMARK
309d						CALLMONITOR 
309d cd 92 16			call break_point_state  
30a0				endm  
# End of macro CALLMONITOR
30a0					endif 
30a0			 
30a0					NEXTW 
30a0 c3 88 1f			jp macro_next 
30a3				endm 
# End of macro NEXTW
30a3			.THEN: 
30a3				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
30a3 1f				db WORD_SYS_CORE+11             
30a4 cb 30			dw .ELSE            
30a6 05				db 4 + 1 
30a7 .. 00			db "THEN",0              
30ac				endm 
# End of macro CWHEAD
30ac			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
30ac					if DEBUG_FORTH_WORDS_KEY 
30ac						DMARK "THN" 
30ac f5				push af  
30ad 3a c1 30			ld a, (.dmark)  
30b0 32 77 fb			ld (debug_mark),a  
30b3 3a c2 30			ld a, (.dmark+1)  
30b6 32 78 fb			ld (debug_mark+1),a  
30b9 3a c3 30			ld a, (.dmark+2)  
30bc 32 79 fb			ld (debug_mark+2),a  
30bf 18 03			jr .pastdmark  
30c1 ..			.dmark: db "THN"  
30c4 f1			.pastdmark: pop af  
30c5			endm  
# End of macro DMARK
30c5						CALLMONITOR 
30c5 cd 92 16			call break_point_state  
30c8				endm  
# End of macro CALLMONITOR
30c8					endif 
30c8					NEXTW 
30c8 c3 88 1f			jp macro_next 
30cb				endm 
# End of macro NEXTW
30cb			.ELSE: 
30cb				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
30cb 20				db WORD_SYS_CORE+12             
30cc f3 30			dw .DO            
30ce 03				db 2 + 1 
30cf .. 00			db "ELSE",0              
30d4				endm 
# End of macro CWHEAD
30d4			; | ELSE ( -- ) Not supported - does nothing | TODO 
30d4			 
30d4					if DEBUG_FORTH_WORDS_KEY 
30d4						DMARK "ELS" 
30d4 f5				push af  
30d5 3a e9 30			ld a, (.dmark)  
30d8 32 77 fb			ld (debug_mark),a  
30db 3a ea 30			ld a, (.dmark+1)  
30de 32 78 fb			ld (debug_mark+1),a  
30e1 3a eb 30			ld a, (.dmark+2)  
30e4 32 79 fb			ld (debug_mark+2),a  
30e7 18 03			jr .pastdmark  
30e9 ..			.dmark: db "ELS"  
30ec f1			.pastdmark: pop af  
30ed			endm  
# End of macro DMARK
30ed						CALLMONITOR 
30ed cd 92 16			call break_point_state  
30f0				endm  
# End of macro CALLMONITOR
30f0					endif 
30f0			 
30f0			 
30f0					NEXTW 
30f0 c3 88 1f			jp macro_next 
30f3				endm 
# End of macro NEXTW
30f3			.DO: 
30f3				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
30f3 21				db WORD_SYS_CORE+13             
30f4 1a 32			dw .LOOP            
30f6 03				db 2 + 1 
30f7 .. 00			db "DO",0              
30fa				endm 
# End of macro CWHEAD
30fa			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
30fa			 
30fa					if DEBUG_FORTH_WORDS_KEY 
30fa						DMARK "DO." 
30fa f5				push af  
30fb 3a 0f 31			ld a, (.dmark)  
30fe 32 77 fb			ld (debug_mark),a  
3101 3a 10 31			ld a, (.dmark+1)  
3104 32 78 fb			ld (debug_mark+1),a  
3107 3a 11 31			ld a, (.dmark+2)  
310a 32 79 fb			ld (debug_mark+2),a  
310d 18 03			jr .pastdmark  
310f ..			.dmark: db "DO."  
3112 f1			.pastdmark: pop af  
3113			endm  
# End of macro DMARK
3113						CALLMONITOR 
3113 cd 92 16			call break_point_state  
3116				endm  
# End of macro CALLMONITOR
3116					endif 
3116			;  push pc to rsp stack past the DO 
3116			 
3116 2a 1e f1				ld hl, (os_tok_ptr) 
3119 23					inc hl   ; D 
311a 23					inc hl  ; O 
311b 23					inc hl   ; null 
311c					if DEBUG_FORTH_WORDS 
311c						DMARK "DO2" 
311c f5				push af  
311d 3a 31 31			ld a, (.dmark)  
3120 32 77 fb			ld (debug_mark),a  
3123 3a 32 31			ld a, (.dmark+1)  
3126 32 78 fb			ld (debug_mark+1),a  
3129 3a 33 31			ld a, (.dmark+2)  
312c 32 79 fb			ld (debug_mark+2),a  
312f 18 03			jr .pastdmark  
3131 ..			.dmark: db "DO2"  
3134 f1			.pastdmark: pop af  
3135			endm  
# End of macro DMARK
3135						CALLMONITOR 
3135 cd 92 16			call break_point_state  
3138				endm  
# End of macro CALLMONITOR
3138					endif 
3138					FORTH_RSP_NEXT 
3138 cd c6 1b			call macro_forth_rsp_next 
313b				endm 
# End of macro FORTH_RSP_NEXT
313b					if DEBUG_FORTH_WORDS 
313b						DMARK "DO3" 
313b f5				push af  
313c 3a 50 31			ld a, (.dmark)  
313f 32 77 fb			ld (debug_mark),a  
3142 3a 51 31			ld a, (.dmark+1)  
3145 32 78 fb			ld (debug_mark+1),a  
3148 3a 52 31			ld a, (.dmark+2)  
314b 32 79 fb			ld (debug_mark+2),a  
314e 18 03			jr .pastdmark  
3150 ..			.dmark: db "DO3"  
3153 f1			.pastdmark: pop af  
3154			endm  
# End of macro DMARK
3154						CALLMONITOR 
3154 cd 92 16			call break_point_state  
3157				endm  
# End of macro CALLMONITOR
3157					endif 
3157			 
3157					;if DEBUG_FORTH_WORDS 
3157				;		push hl 
3157			;		endif  
3157			 
3157			; get counters from data stack 
3157			 
3157			 
3157					FORTH_DSP_VALUEHL 
3157 cd 16 1e			call macro_dsp_valuehl 
315a				endm 
# End of macro FORTH_DSP_VALUEHL
315a e5					push hl		 ; hl now has starting counter which needs to be tos 
315b			 
315b					if DEBUG_FORTH_WORDS 
315b						DMARK "DO4" 
315b f5				push af  
315c 3a 70 31			ld a, (.dmark)  
315f 32 77 fb			ld (debug_mark),a  
3162 3a 71 31			ld a, (.dmark+1)  
3165 32 78 fb			ld (debug_mark+1),a  
3168 3a 72 31			ld a, (.dmark+2)  
316b 32 79 fb			ld (debug_mark+2),a  
316e 18 03			jr .pastdmark  
3170 ..			.dmark: db "DO4"  
3173 f1			.pastdmark: pop af  
3174			endm  
# End of macro DMARK
3174						CALLMONITOR 
3174 cd 92 16			call break_point_state  
3177				endm  
# End of macro CALLMONITOR
3177					endif 
3177					FORTH_DSP_POP 
3177 cd ce 1e			call macro_forth_dsp_pop 
317a				endm 
# End of macro FORTH_DSP_POP
317a			 
317a					if DEBUG_FORTH_WORDS 
317a						DMARK "DO5" 
317a f5				push af  
317b 3a 8f 31			ld a, (.dmark)  
317e 32 77 fb			ld (debug_mark),a  
3181 3a 90 31			ld a, (.dmark+1)  
3184 32 78 fb			ld (debug_mark+1),a  
3187 3a 91 31			ld a, (.dmark+2)  
318a 32 79 fb			ld (debug_mark+2),a  
318d 18 03			jr .pastdmark  
318f ..			.dmark: db "DO5"  
3192 f1			.pastdmark: pop af  
3193			endm  
# End of macro DMARK
3193						CALLMONITOR 
3193 cd 92 16			call break_point_state  
3196				endm  
# End of macro CALLMONITOR
3196					endif 
3196			 
3196					FORTH_DSP_VALUEHL 
3196 cd 16 1e			call macro_dsp_valuehl 
3199				endm 
# End of macro FORTH_DSP_VALUEHL
3199			;		push hl		 ; hl now has starting limit counter 
3199			 
3199					if DEBUG_FORTH_WORDS 
3199						DMARK "DO6" 
3199 f5				push af  
319a 3a ae 31			ld a, (.dmark)  
319d 32 77 fb			ld (debug_mark),a  
31a0 3a af 31			ld a, (.dmark+1)  
31a3 32 78 fb			ld (debug_mark+1),a  
31a6 3a b0 31			ld a, (.dmark+2)  
31a9 32 79 fb			ld (debug_mark+2),a  
31ac 18 03			jr .pastdmark  
31ae ..			.dmark: db "DO6"  
31b1 f1			.pastdmark: pop af  
31b2			endm  
# End of macro DMARK
31b2						CALLMONITOR 
31b2 cd 92 16			call break_point_state  
31b5				endm  
# End of macro CALLMONITOR
31b5					endif 
31b5					FORTH_DSP_POP 
31b5 cd ce 1e			call macro_forth_dsp_pop 
31b8				endm 
# End of macro FORTH_DSP_POP
31b8			 
31b8			; put counters on the loop stack 
31b8			 
31b8			;		pop hl			 ; limit counter 
31b8 d1					pop de			; start counter 
31b9			 
31b9					; push limit counter 
31b9			 
31b9					if DEBUG_FORTH_WORDS 
31b9						DMARK "DO7" 
31b9 f5				push af  
31ba 3a ce 31			ld a, (.dmark)  
31bd 32 77 fb			ld (debug_mark),a  
31c0 3a cf 31			ld a, (.dmark+1)  
31c3 32 78 fb			ld (debug_mark+1),a  
31c6 3a d0 31			ld a, (.dmark+2)  
31c9 32 79 fb			ld (debug_mark+2),a  
31cc 18 03			jr .pastdmark  
31ce ..			.dmark: db "DO7"  
31d1 f1			.pastdmark: pop af  
31d2			endm  
# End of macro DMARK
31d2						CALLMONITOR 
31d2 cd 92 16			call break_point_state  
31d5				endm  
# End of macro CALLMONITOR
31d5					endif 
31d5					FORTH_LOOP_NEXT 
31d5 cd 47 1e			call macro_forth_loop_next 
31d8				endm 
# End of macro FORTH_LOOP_NEXT
31d8			 
31d8					; push start counter 
31d8			 
31d8 eb					ex de, hl 
31d9					if DEBUG_FORTH_WORDS 
31d9						DMARK "DO7" 
31d9 f5				push af  
31da 3a ee 31			ld a, (.dmark)  
31dd 32 77 fb			ld (debug_mark),a  
31e0 3a ef 31			ld a, (.dmark+1)  
31e3 32 78 fb			ld (debug_mark+1),a  
31e6 3a f0 31			ld a, (.dmark+2)  
31e9 32 79 fb			ld (debug_mark+2),a  
31ec 18 03			jr .pastdmark  
31ee ..			.dmark: db "DO7"  
31f1 f1			.pastdmark: pop af  
31f2			endm  
# End of macro DMARK
31f2						CALLMONITOR 
31f2 cd 92 16			call break_point_state  
31f5				endm  
# End of macro CALLMONITOR
31f5					endif 
31f5					FORTH_LOOP_NEXT 
31f5 cd 47 1e			call macro_forth_loop_next 
31f8				endm 
# End of macro FORTH_LOOP_NEXT
31f8			 
31f8			 
31f8					; init first round of I counter 
31f8			 
31f8 22 42 f1				ld (os_current_i), hl 
31fb			 
31fb					if DEBUG_FORTH_WORDS 
31fb						DMARK "DO8" 
31fb f5				push af  
31fc 3a 10 32			ld a, (.dmark)  
31ff 32 77 fb			ld (debug_mark),a  
3202 3a 11 32			ld a, (.dmark+1)  
3205 32 78 fb			ld (debug_mark+1),a  
3208 3a 12 32			ld a, (.dmark+2)  
320b 32 79 fb			ld (debug_mark+2),a  
320e 18 03			jr .pastdmark  
3210 ..			.dmark: db "DO8"  
3213 f1			.pastdmark: pop af  
3214			endm  
# End of macro DMARK
3214						CALLMONITOR 
3214 cd 92 16			call break_point_state  
3217				endm  
# End of macro CALLMONITOR
3217					endif 
3217			 
3217					NEXTW 
3217 c3 88 1f			jp macro_next 
321a				endm 
# End of macro NEXTW
321a			.LOOP: 
321a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
321a 22				db WORD_SYS_CORE+14             
321b 32 33			dw .I            
321d 05				db 4 + 1 
321e .. 00			db "LOOP",0              
3223				endm 
# End of macro CWHEAD
3223			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3223			 
3223				; pop tos as current loop count to hl 
3223			 
3223				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3223			 
3223				FORTH_LOOP_TOS 
3223 cd 7a 1e			call macro_forth_loop_tos 
3226				endm 
# End of macro FORTH_LOOP_TOS
3226 e5				push hl 
3227			 
3227					if DEBUG_FORTH_WORDS_KEY 
3227						DMARK "LOP" 
3227 f5				push af  
3228 3a 3c 32			ld a, (.dmark)  
322b 32 77 fb			ld (debug_mark),a  
322e 3a 3d 32			ld a, (.dmark+1)  
3231 32 78 fb			ld (debug_mark+1),a  
3234 3a 3e 32			ld a, (.dmark+2)  
3237 32 79 fb			ld (debug_mark+2),a  
323a 18 03			jr .pastdmark  
323c ..			.dmark: db "LOP"  
323f f1			.pastdmark: pop af  
3240			endm  
# End of macro DMARK
3240						CALLMONITOR 
3240 cd 92 16			call break_point_state  
3243				endm  
# End of macro CALLMONITOR
3243					endif 
3243				; next item on the stack is the limit. get it 
3243			 
3243			 
3243				FORTH_LOOP_POP 
3243 cd 84 1e			call macro_forth_loop_pop 
3246				endm 
# End of macro FORTH_LOOP_POP
3246			 
3246				FORTH_LOOP_TOS 
3246 cd 7a 1e			call macro_forth_loop_tos 
3249				endm 
# End of macro FORTH_LOOP_TOS
3249			 
3249 d1				pop de		 ; de = i, hl = limit 
324a			 
324a					if DEBUG_FORTH_WORDS 
324a						DMARK "LP1" 
324a f5				push af  
324b 3a 5f 32			ld a, (.dmark)  
324e 32 77 fb			ld (debug_mark),a  
3251 3a 60 32			ld a, (.dmark+1)  
3254 32 78 fb			ld (debug_mark+1),a  
3257 3a 61 32			ld a, (.dmark+2)  
325a 32 79 fb			ld (debug_mark+2),a  
325d 18 03			jr .pastdmark  
325f ..			.dmark: db "LP1"  
3262 f1			.pastdmark: pop af  
3263			endm  
# End of macro DMARK
3263						CALLMONITOR 
3263 cd 92 16			call break_point_state  
3266				endm  
# End of macro CALLMONITOR
3266					endif 
3266			 
3266				; go back to previous word 
3266			 
3266 d5				push de    ; save I for inc later 
3267			 
3267			 
3267				; get limit 
3267				;  is I at limit? 
3267			 
3267			 
3267					if DEBUG_FORTH_WORDS 
3267						DMARK "LP1" 
3267 f5				push af  
3268 3a 7c 32			ld a, (.dmark)  
326b 32 77 fb			ld (debug_mark),a  
326e 3a 7d 32			ld a, (.dmark+1)  
3271 32 78 fb			ld (debug_mark+1),a  
3274 3a 7e 32			ld a, (.dmark+2)  
3277 32 79 fb			ld (debug_mark+2),a  
327a 18 03			jr .pastdmark  
327c ..			.dmark: db "LP1"  
327f f1			.pastdmark: pop af  
3280			endm  
# End of macro DMARK
3280						CALLMONITOR 
3280 cd 92 16			call break_point_state  
3283				endm  
# End of macro CALLMONITOR
3283					endif 
3283			 
3283 ed 52			sbc hl, de 
3285			 
3285			 
3285				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3285			 
3285 20 26				jr nz, .loopnotdone 
3287			 
3287 e1				pop hl   ; get rid of saved I 
3288				FORTH_LOOP_POP     ; get rid of limit 
3288 cd 84 1e			call macro_forth_loop_pop 
328b				endm 
# End of macro FORTH_LOOP_POP
328b			 
328b				FORTH_RSP_POP     ; get rid of DO ptr 
328b cd e7 1b			call macro_forth_rsp_pop 
328e				endm 
# End of macro FORTH_RSP_POP
328e			 
328e			if DEBUG_FORTH_WORDS 
328e						DMARK "LP>" 
328e f5				push af  
328f 3a a3 32			ld a, (.dmark)  
3292 32 77 fb			ld (debug_mark),a  
3295 3a a4 32			ld a, (.dmark+1)  
3298 32 78 fb			ld (debug_mark+1),a  
329b 3a a5 32			ld a, (.dmark+2)  
329e 32 79 fb			ld (debug_mark+2),a  
32a1 18 03			jr .pastdmark  
32a3 ..			.dmark: db "LP>"  
32a6 f1			.pastdmark: pop af  
32a7			endm  
# End of macro DMARK
32a7				CALLMONITOR 
32a7 cd 92 16			call break_point_state  
32aa				endm  
# End of macro CALLMONITOR
32aa			endif 
32aa			 
32aa					NEXTW 
32aa c3 88 1f			jp macro_next 
32ad				endm 
# End of macro NEXTW
32ad				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
32ad			 
32ad			.loopnotdone: 
32ad			 
32ad e1				pop hl    ; get I 
32ae 23				inc hl 
32af			 
32af			   	; save new I 
32af			 
32af			 
32af					; set I counter 
32af			 
32af 22 42 f1				ld (os_current_i), hl 
32b2			 
32b2					if DEBUG_FORTH_WORDS 
32b2						DMARK "LPN" 
32b2 f5				push af  
32b3 3a c7 32			ld a, (.dmark)  
32b6 32 77 fb			ld (debug_mark),a  
32b9 3a c8 32			ld a, (.dmark+1)  
32bc 32 78 fb			ld (debug_mark+1),a  
32bf 3a c9 32			ld a, (.dmark+2)  
32c2 32 79 fb			ld (debug_mark+2),a  
32c5 18 03			jr .pastdmark  
32c7 ..			.dmark: db "LPN"  
32ca f1			.pastdmark: pop af  
32cb			endm  
# End of macro DMARK
32cb					CALLMONITOR 
32cb cd 92 16			call break_point_state  
32ce				endm  
# End of macro CALLMONITOR
32ce					endif 
32ce					 
32ce				FORTH_LOOP_NEXT 
32ce cd 47 1e			call macro_forth_loop_next 
32d1				endm 
# End of macro FORTH_LOOP_NEXT
32d1			 
32d1			 
32d1					if DEBUG_FORTH_WORDS 
32d1 eb						ex de,hl 
32d2					endif 
32d2			 
32d2			;	; get DO ptr 
32d2			; 
32d2					if DEBUG_FORTH_WORDS 
32d2						DMARK "LP7" 
32d2 f5				push af  
32d3 3a e7 32			ld a, (.dmark)  
32d6 32 77 fb			ld (debug_mark),a  
32d9 3a e8 32			ld a, (.dmark+1)  
32dc 32 78 fb			ld (debug_mark+1),a  
32df 3a e9 32			ld a, (.dmark+2)  
32e2 32 79 fb			ld (debug_mark+2),a  
32e5 18 03			jr .pastdmark  
32e7 ..			.dmark: db "LP7"  
32ea f1			.pastdmark: pop af  
32eb			endm  
# End of macro DMARK
32eb					CALLMONITOR 
32eb cd 92 16			call break_point_state  
32ee				endm  
# End of macro CALLMONITOR
32ee					endif 
32ee				FORTH_RSP_TOS 
32ee cd dd 1b			call macro_forth_rsp_tos 
32f1				endm 
# End of macro FORTH_RSP_TOS
32f1			 
32f1					if DEBUG_FORTH_WORDS 
32f1						DMARK "LP8" 
32f1 f5				push af  
32f2 3a 06 33			ld a, (.dmark)  
32f5 32 77 fb			ld (debug_mark),a  
32f8 3a 07 33			ld a, (.dmark+1)  
32fb 32 78 fb			ld (debug_mark+1),a  
32fe 3a 08 33			ld a, (.dmark+2)  
3301 32 79 fb			ld (debug_mark+2),a  
3304 18 03			jr .pastdmark  
3306 ..			.dmark: db "LP8"  
3309 f1			.pastdmark: pop af  
330a			endm  
# End of macro DMARK
330a					CALLMONITOR 
330a cd 92 16			call break_point_state  
330d				endm  
# End of macro CALLMONITOR
330d					endif 
330d				;push hl 
330d			 
330d				; not going to DO any more 
330d				; get rid of the RSP pointer as DO will add it back in 
330d				;FORTH_RSP_POP 
330d				;pop hl 
330d			 
330d				;ld hl,(cli_ret_sp) 
330d				;ld e, (hl) 
330d				;inc hl 
330d				;ld d, (hl) 
330d				;ex de,hl 
330d 22 1e f1			ld (os_tok_ptr), hl 
3310					if DEBUG_FORTH_WORDS 
3310						DMARK "LP<" 
3310 f5				push af  
3311 3a 25 33			ld a, (.dmark)  
3314 32 77 fb			ld (debug_mark),a  
3317 3a 26 33			ld a, (.dmark+1)  
331a 32 78 fb			ld (debug_mark+1),a  
331d 3a 27 33			ld a, (.dmark+2)  
3320 32 79 fb			ld (debug_mark+2),a  
3323 18 03			jr .pastdmark  
3325 ..			.dmark: db "LP<"  
3328 f1			.pastdmark: pop af  
3329			endm  
# End of macro DMARK
3329					CALLMONITOR 
3329 cd 92 16			call break_point_state  
332c				endm  
# End of macro CALLMONITOR
332c				endif 
332c c3 19 20			jp exec1 
332f			 
332f					 
332f			 
332f			 
332f					NEXTW 
332f c3 88 1f			jp macro_next 
3332				endm 
# End of macro NEXTW
3332			.I:  
3332			 
3332				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3332 5e				db WORD_SYS_CORE+74             
3333 5d 33			dw .DLOOP            
3335 02				db 1 + 1 
3336 .. 00			db "I",0              
3338				endm 
# End of macro CWHEAD
3338			; | I ( -- ) Current loop counter | DONE 
3338					if DEBUG_FORTH_WORDS_KEY 
3338						DMARK "I.." 
3338 f5				push af  
3339 3a 4d 33			ld a, (.dmark)  
333c 32 77 fb			ld (debug_mark),a  
333f 3a 4e 33			ld a, (.dmark+1)  
3342 32 78 fb			ld (debug_mark+1),a  
3345 3a 4f 33			ld a, (.dmark+2)  
3348 32 79 fb			ld (debug_mark+2),a  
334b 18 03			jr .pastdmark  
334d ..			.dmark: db "I.."  
3350 f1			.pastdmark: pop af  
3351			endm  
# End of macro DMARK
3351						CALLMONITOR 
3351 cd 92 16			call break_point_state  
3354				endm  
# End of macro CALLMONITOR
3354					endif 
3354			 
3354 2a 42 f1				ld hl,(os_current_i) 
3357 cd 1f 1c				call forth_push_numhl 
335a			 
335a					NEXTW 
335a c3 88 1f			jp macro_next 
335d				endm 
# End of macro NEXTW
335d			.DLOOP: 
335d				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
335d 5f				db WORD_SYS_CORE+75             
335e 3e 34			dw .REPEAT            
3360 06				db 5 + 1 
3361 .. 00			db "-LOOP",0              
3367				endm 
# End of macro CWHEAD
3367			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3367				; pop tos as current loop count to hl 
3367					if DEBUG_FORTH_WORDS_KEY 
3367						DMARK "-LP" 
3367 f5				push af  
3368 3a 7c 33			ld a, (.dmark)  
336b 32 77 fb			ld (debug_mark),a  
336e 3a 7d 33			ld a, (.dmark+1)  
3371 32 78 fb			ld (debug_mark+1),a  
3374 3a 7e 33			ld a, (.dmark+2)  
3377 32 79 fb			ld (debug_mark+2),a  
337a 18 03			jr .pastdmark  
337c ..			.dmark: db "-LP"  
337f f1			.pastdmark: pop af  
3380			endm  
# End of macro DMARK
3380						CALLMONITOR 
3380 cd 92 16			call break_point_state  
3383				endm  
# End of macro CALLMONITOR
3383					endif 
3383			 
3383				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3383			 
3383				FORTH_LOOP_TOS 
3383 cd 7a 1e			call macro_forth_loop_tos 
3386				endm 
# End of macro FORTH_LOOP_TOS
3386 e5				push hl 
3387			 
3387					if DEBUG_FORTH_WORDS 
3387						DMARK "-LP" 
3387 f5				push af  
3388 3a 9c 33			ld a, (.dmark)  
338b 32 77 fb			ld (debug_mark),a  
338e 3a 9d 33			ld a, (.dmark+1)  
3391 32 78 fb			ld (debug_mark+1),a  
3394 3a 9e 33			ld a, (.dmark+2)  
3397 32 79 fb			ld (debug_mark+2),a  
339a 18 03			jr .pastdmark  
339c ..			.dmark: db "-LP"  
339f f1			.pastdmark: pop af  
33a0			endm  
# End of macro DMARK
33a0						CALLMONITOR 
33a0 cd 92 16			call break_point_state  
33a3				endm  
# End of macro CALLMONITOR
33a3					endif 
33a3				; next item on the stack is the limit. get it 
33a3			 
33a3			 
33a3				FORTH_LOOP_POP 
33a3 cd 84 1e			call macro_forth_loop_pop 
33a6				endm 
# End of macro FORTH_LOOP_POP
33a6			 
33a6				FORTH_LOOP_TOS 
33a6 cd 7a 1e			call macro_forth_loop_tos 
33a9				endm 
# End of macro FORTH_LOOP_TOS
33a9			 
33a9 d1				pop de		 ; de = i, hl = limit 
33aa			 
33aa					if DEBUG_FORTH_WORDS 
33aa						DMARK "-L1" 
33aa f5				push af  
33ab 3a bf 33			ld a, (.dmark)  
33ae 32 77 fb			ld (debug_mark),a  
33b1 3a c0 33			ld a, (.dmark+1)  
33b4 32 78 fb			ld (debug_mark+1),a  
33b7 3a c1 33			ld a, (.dmark+2)  
33ba 32 79 fb			ld (debug_mark+2),a  
33bd 18 03			jr .pastdmark  
33bf ..			.dmark: db "-L1"  
33c2 f1			.pastdmark: pop af  
33c3			endm  
# End of macro DMARK
33c3						CALLMONITOR 
33c3 cd 92 16			call break_point_state  
33c6				endm  
# End of macro CALLMONITOR
33c6					endif 
33c6			 
33c6				; go back to previous word 
33c6			 
33c6 d5				push de    ; save I for inc later 
33c7			 
33c7			 
33c7				; get limit 
33c7				;  is I at limit? 
33c7			 
33c7			 
33c7					if DEBUG_FORTH_WORDS 
33c7						DMARK "-L1" 
33c7 f5				push af  
33c8 3a dc 33			ld a, (.dmark)  
33cb 32 77 fb			ld (debug_mark),a  
33ce 3a dd 33			ld a, (.dmark+1)  
33d1 32 78 fb			ld (debug_mark+1),a  
33d4 3a de 33			ld a, (.dmark+2)  
33d7 32 79 fb			ld (debug_mark+2),a  
33da 18 03			jr .pastdmark  
33dc ..			.dmark: db "-L1"  
33df f1			.pastdmark: pop af  
33e0			endm  
# End of macro DMARK
33e0						CALLMONITOR 
33e0 cd 92 16			call break_point_state  
33e3				endm  
# End of macro CALLMONITOR
33e3					endif 
33e3			 
33e3 ed 52			sbc hl, de 
33e5			 
33e5			 
33e5				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33e5			 
33e5 20 26				jr nz, .mloopnotdone 
33e7			 
33e7 e1				pop hl   ; get rid of saved I 
33e8				FORTH_LOOP_POP     ; get rid of limit 
33e8 cd 84 1e			call macro_forth_loop_pop 
33eb				endm 
# End of macro FORTH_LOOP_POP
33eb			 
33eb				FORTH_RSP_POP     ; get rid of DO ptr 
33eb cd e7 1b			call macro_forth_rsp_pop 
33ee				endm 
# End of macro FORTH_RSP_POP
33ee			 
33ee			if DEBUG_FORTH_WORDS 
33ee						DMARK "-L>" 
33ee f5				push af  
33ef 3a 03 34			ld a, (.dmark)  
33f2 32 77 fb			ld (debug_mark),a  
33f5 3a 04 34			ld a, (.dmark+1)  
33f8 32 78 fb			ld (debug_mark+1),a  
33fb 3a 05 34			ld a, (.dmark+2)  
33fe 32 79 fb			ld (debug_mark+2),a  
3401 18 03			jr .pastdmark  
3403 ..			.dmark: db "-L>"  
3406 f1			.pastdmark: pop af  
3407			endm  
# End of macro DMARK
3407				CALLMONITOR 
3407 cd 92 16			call break_point_state  
340a				endm  
# End of macro CALLMONITOR
340a			endif 
340a			 
340a					NEXTW 
340a c3 88 1f			jp macro_next 
340d				endm 
# End of macro NEXTW
340d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
340d			 
340d			.mloopnotdone: 
340d			 
340d e1				pop hl    ; get I 
340e 2b				dec hl 
340f			 
340f			   	; save new I 
340f			 
340f			 
340f					; set I counter 
340f			 
340f 22 42 f1				ld (os_current_i), hl 
3412			 
3412					 
3412				FORTH_LOOP_NEXT 
3412 cd 47 1e			call macro_forth_loop_next 
3415				endm 
# End of macro FORTH_LOOP_NEXT
3415			 
3415			 
3415					if DEBUG_FORTH_WORDS 
3415 eb						ex de,hl 
3416					endif 
3416			 
3416			;	; get DO ptr 
3416			; 
3416				FORTH_RSP_TOS 
3416 cd dd 1b			call macro_forth_rsp_tos 
3419				endm 
# End of macro FORTH_RSP_TOS
3419			 
3419				;push hl 
3419			 
3419				; not going to DO any more 
3419				; get rid of the RSP pointer as DO will add it back in 
3419				;FORTH_RSP_POP 
3419				;pop hl 
3419			 
3419			 
3419 22 1e f1			ld (os_tok_ptr), hl 
341c					if DEBUG_FORTH_WORDS 
341c						DMARK "-L<" 
341c f5				push af  
341d 3a 31 34			ld a, (.dmark)  
3420 32 77 fb			ld (debug_mark),a  
3423 3a 32 34			ld a, (.dmark+1)  
3426 32 78 fb			ld (debug_mark+1),a  
3429 3a 33 34			ld a, (.dmark+2)  
342c 32 79 fb			ld (debug_mark+2),a  
342f 18 03			jr .pastdmark  
3431 ..			.dmark: db "-L<"  
3434 f1			.pastdmark: pop af  
3435			endm  
# End of macro DMARK
3435					CALLMONITOR 
3435 cd 92 16			call break_point_state  
3438				endm  
# End of macro CALLMONITOR
3438				endif 
3438 c3 19 20			jp exec1 
343b			 
343b					 
343b			 
343b			 
343b			 
343b				NEXTW 
343b c3 88 1f			jp macro_next 
343e				endm 
# End of macro NEXTW
343e			 
343e			 
343e			 
343e			 
343e			.REPEAT: 
343e				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
343e 71				db WORD_SYS_CORE+93             
343f 91 34			dw .UNTIL            
3441 06				db 5 + 1 
3442 .. 00			db "REPEAT",0              
3449				endm 
# End of macro CWHEAD
3449			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3449			;  push pc to rsp stack past the REPEAT 
3449					if DEBUG_FORTH_WORDS_KEY 
3449						DMARK "REP" 
3449 f5				push af  
344a 3a 5e 34			ld a, (.dmark)  
344d 32 77 fb			ld (debug_mark),a  
3450 3a 5f 34			ld a, (.dmark+1)  
3453 32 78 fb			ld (debug_mark+1),a  
3456 3a 60 34			ld a, (.dmark+2)  
3459 32 79 fb			ld (debug_mark+2),a  
345c 18 03			jr .pastdmark  
345e ..			.dmark: db "REP"  
3461 f1			.pastdmark: pop af  
3462			endm  
# End of macro DMARK
3462						CALLMONITOR 
3462 cd 92 16			call break_point_state  
3465				endm  
# End of macro CALLMONITOR
3465					endif 
3465			 
3465 2a 1e f1				ld hl, (os_tok_ptr) 
3468 23					inc hl   ; R 
3469 23					inc hl  ; E 
346a 23					inc hl   ; P 
346b 23					inc hl   ; E 
346c 23					inc hl   ; A 
346d 23					inc hl   ; T 
346e 23					inc hl   ; zero 
346f					FORTH_RSP_NEXT 
346f cd c6 1b			call macro_forth_rsp_next 
3472				endm 
# End of macro FORTH_RSP_NEXT
3472			 
3472			 
3472					if DEBUG_FORTH_WORDS 
3472						DMARK "REP" 
3472 f5				push af  
3473 3a 87 34			ld a, (.dmark)  
3476 32 77 fb			ld (debug_mark),a  
3479 3a 88 34			ld a, (.dmark+1)  
347c 32 78 fb			ld (debug_mark+1),a  
347f 3a 89 34			ld a, (.dmark+2)  
3482 32 79 fb			ld (debug_mark+2),a  
3485 18 03			jr .pastdmark  
3487 ..			.dmark: db "REP"  
348a f1			.pastdmark: pop af  
348b			endm  
# End of macro DMARK
348b						;pop bc    ; TODO BUG ?????? what is this for???? 
348b						CALLMONITOR 
348b cd 92 16			call break_point_state  
348e				endm  
# End of macro CALLMONITOR
348e					endif 
348e			 
348e					NEXTW 
348e c3 88 1f			jp macro_next 
3491				endm 
# End of macro NEXTW
3491			;	       NEXTW 
3491			 
3491			.UNTIL: 
3491				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3491 72				db WORD_SYS_CORE+94             
3492 28 35			dw .ENDFLOW            
3494 06				db 5 + 1 
3495 .. 00			db "UNTIL",0              
349b				endm 
# End of macro CWHEAD
349b			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
349b			 
349b				; pop tos as check 
349b			 
349b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
349b			 
349b				FORTH_DSP_VALUEHL 
349b cd 16 1e			call macro_dsp_valuehl 
349e				endm 
# End of macro FORTH_DSP_VALUEHL
349e			 
349e					if DEBUG_FORTH_WORDS_KEY 
349e						DMARK "UNT" 
349e f5				push af  
349f 3a b3 34			ld a, (.dmark)  
34a2 32 77 fb			ld (debug_mark),a  
34a5 3a b4 34			ld a, (.dmark+1)  
34a8 32 78 fb			ld (debug_mark+1),a  
34ab 3a b5 34			ld a, (.dmark+2)  
34ae 32 79 fb			ld (debug_mark+2),a  
34b1 18 03			jr .pastdmark  
34b3 ..			.dmark: db "UNT"  
34b6 f1			.pastdmark: pop af  
34b7			endm  
# End of macro DMARK
34b7						CALLMONITOR 
34b7 cd 92 16			call break_point_state  
34ba				endm  
# End of macro CALLMONITOR
34ba					endif 
34ba			 
34ba			;	push hl 
34ba				FORTH_DSP_POP 
34ba cd ce 1e			call macro_forth_dsp_pop 
34bd				endm 
# End of macro FORTH_DSP_POP
34bd			 
34bd			;	pop hl 
34bd			 
34bd				; test if true 
34bd			 
34bd cd 32 0d			call ishlzero 
34c0			;	ld a,l 
34c0			;	add h 
34c0			; 
34c0			;	cp 0 
34c0			 
34c0 20 3e			jr nz, .untilnotdone 
34c2			 
34c2					if DEBUG_FORTH_WORDS 
34c2						DMARK "UNf" 
34c2 f5				push af  
34c3 3a d7 34			ld a, (.dmark)  
34c6 32 77 fb			ld (debug_mark),a  
34c9 3a d8 34			ld a, (.dmark+1)  
34cc 32 78 fb			ld (debug_mark+1),a  
34cf 3a d9 34			ld a, (.dmark+2)  
34d2 32 79 fb			ld (debug_mark+2),a  
34d5 18 03			jr .pastdmark  
34d7 ..			.dmark: db "UNf"  
34da f1			.pastdmark: pop af  
34db			endm  
# End of macro DMARK
34db						CALLMONITOR 
34db cd 92 16			call break_point_state  
34de				endm  
# End of macro CALLMONITOR
34de					endif 
34de			 
34de			 
34de			 
34de				FORTH_RSP_POP     ; get rid of DO ptr 
34de cd e7 1b			call macro_forth_rsp_pop 
34e1				endm 
# End of macro FORTH_RSP_POP
34e1			 
34e1			if DEBUG_FORTH_WORDS 
34e1						DMARK "UN>" 
34e1 f5				push af  
34e2 3a f6 34			ld a, (.dmark)  
34e5 32 77 fb			ld (debug_mark),a  
34e8 3a f7 34			ld a, (.dmark+1)  
34eb 32 78 fb			ld (debug_mark+1),a  
34ee 3a f8 34			ld a, (.dmark+2)  
34f1 32 79 fb			ld (debug_mark+2),a  
34f4 18 03			jr .pastdmark  
34f6 ..			.dmark: db "UN>"  
34f9 f1			.pastdmark: pop af  
34fa			endm  
# End of macro DMARK
34fa				CALLMONITOR 
34fa cd 92 16			call break_point_state  
34fd				endm  
# End of macro CALLMONITOR
34fd			endif 
34fd			 
34fd					NEXTW 
34fd c3 88 1f			jp macro_next 
3500				endm 
# End of macro NEXTW
3500				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3500			 
3500			.untilnotdone: 
3500			 
3500			 
3500			;	; get DO ptr 
3500			; 
3500				FORTH_RSP_TOS 
3500 cd dd 1b			call macro_forth_rsp_tos 
3503				endm 
# End of macro FORTH_RSP_TOS
3503			 
3503				;push hl 
3503			 
3503				; not going to DO any more 
3503				; get rid of the RSP pointer as DO will add it back in 
3503				;FORTH_RSP_POP 
3503				;pop hl 
3503			 
3503			 
3503 22 1e f1			ld (os_tok_ptr), hl 
3506					if DEBUG_FORTH_WORDS 
3506						DMARK "UN<" 
3506 f5				push af  
3507 3a 1b 35			ld a, (.dmark)  
350a 32 77 fb			ld (debug_mark),a  
350d 3a 1c 35			ld a, (.dmark+1)  
3510 32 78 fb			ld (debug_mark+1),a  
3513 3a 1d 35			ld a, (.dmark+2)  
3516 32 79 fb			ld (debug_mark+2),a  
3519 18 03			jr .pastdmark  
351b ..			.dmark: db "UN<"  
351e f1			.pastdmark: pop af  
351f			endm  
# End of macro DMARK
351f					CALLMONITOR 
351f cd 92 16			call break_point_state  
3522				endm  
# End of macro CALLMONITOR
3522				endif 
3522 c3 19 20			jp exec1 
3525			 
3525					 
3525			 
3525			 
3525					NEXTW 
3525 c3 88 1f			jp macro_next 
3528				endm 
# End of macro NEXTW
3528			 
3528			 
3528			.ENDFLOW: 
3528			 
3528			; eof 
3528			 
# End of file forth_words_flow.asm
3528			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3528			include "forth_words_logic.asm" 
3528			 
3528			; | ## Logic Words 
3528			 
3528			.NOT: 
3528				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3528 2d				db WORD_SYS_CORE+25             
3529 70 35			dw .IS            
352b 04				db 3 + 1 
352c .. 00			db "NOT",0              
3530				endm 
# End of macro CWHEAD
3530			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3530					if DEBUG_FORTH_WORDS_KEY 
3530						DMARK "NOT" 
3530 f5				push af  
3531 3a 45 35			ld a, (.dmark)  
3534 32 77 fb			ld (debug_mark),a  
3537 3a 46 35			ld a, (.dmark+1)  
353a 32 78 fb			ld (debug_mark+1),a  
353d 3a 47 35			ld a, (.dmark+2)  
3540 32 79 fb			ld (debug_mark+2),a  
3543 18 03			jr .pastdmark  
3545 ..			.dmark: db "NOT"  
3548 f1			.pastdmark: pop af  
3549			endm  
# End of macro DMARK
3549						CALLMONITOR 
3549 cd 92 16			call break_point_state  
354c				endm  
# End of macro CALLMONITOR
354c					endif 
354c					FORTH_DSP 
354c cd dc 1d			call macro_forth_dsp 
354f				endm 
# End of macro FORTH_DSP
354f 7e					ld a,(hl)	; get type of value on TOS 
3550 fe 02				cp DS_TYPE_INUM  
3552 28 03				jr z, .noti 
3554					NEXTW 
3554 c3 88 1f			jp macro_next 
3557				endm 
# End of macro NEXTW
3557			.noti:          FORTH_DSP_VALUEHL 
3557 cd 16 1e			call macro_dsp_valuehl 
355a				endm 
# End of macro FORTH_DSP_VALUEHL
355a			;		push hl 
355a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
355a cd ce 1e			call macro_forth_dsp_pop 
355d				endm 
# End of macro FORTH_DSP_POP
355d			;		pop hl 
355d 3e 00				ld a,0 
355f bd					cp l 
3560 28 04				jr z, .not2t 
3562 2e 00				ld l, 0 
3564 18 02				jr .notip 
3566			 
3566 2e ff		.not2t:		ld l, 255 
3568			 
3568 26 00		.notip:		ld h, 0	 
356a			 
356a cd 1f 1c				call forth_push_numhl 
356d					NEXTW 
356d c3 88 1f			jp macro_next 
3570				endm 
# End of macro NEXTW
3570			 
3570			.IS: 
3570				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3570 2d				db WORD_SYS_CORE+25             
3571 96 35			dw .LZERO            
3573 03				db 2 + 1 
3574 .. 00			db "IS",0              
3577				endm 
# End of macro CWHEAD
3577			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3577					if DEBUG_FORTH_WORDS_KEY 
3577						DMARK "IS." 
3577 f5				push af  
3578 3a 8c 35			ld a, (.dmark)  
357b 32 77 fb			ld (debug_mark),a  
357e 3a 8d 35			ld a, (.dmark+1)  
3581 32 78 fb			ld (debug_mark+1),a  
3584 3a 8e 35			ld a, (.dmark+2)  
3587 32 79 fb			ld (debug_mark+2),a  
358a 18 03			jr .pastdmark  
358c ..			.dmark: db "IS."  
358f f1			.pastdmark: pop af  
3590			endm  
# End of macro DMARK
3590						CALLMONITOR 
3590 cd 92 16			call break_point_state  
3593				endm  
# End of macro CALLMONITOR
3593					endif 
3593					NEXTW 
3593 c3 88 1f			jp macro_next 
3596				endm 
# End of macro NEXTW
3596			.LZERO: 
3596				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3596 2d				db WORD_SYS_CORE+25             
3597 a0 35			dw .TZERO            
3599 03				db 2 + 1 
359a .. 00			db "0<",0              
359d				endm 
# End of macro CWHEAD
359d			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
359d					NEXTW 
359d c3 88 1f			jp macro_next 
35a0				endm 
# End of macro NEXTW
35a0			.TZERO: 
35a0				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
35a0 2e				db WORD_SYS_CORE+26             
35a1 e7 35			dw .LESS            
35a3 03				db 2 + 1 
35a4 .. 00			db "0=",0              
35a7				endm 
# End of macro CWHEAD
35a7			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
35a7				; TODO add floating point number detection 
35a7					;v5 FORTH_DSP_VALUE 
35a7					if DEBUG_FORTH_WORDS_KEY 
35a7						DMARK "0=." 
35a7 f5				push af  
35a8 3a bc 35			ld a, (.dmark)  
35ab 32 77 fb			ld (debug_mark),a  
35ae 3a bd 35			ld a, (.dmark+1)  
35b1 32 78 fb			ld (debug_mark+1),a  
35b4 3a be 35			ld a, (.dmark+2)  
35b7 32 79 fb			ld (debug_mark+2),a  
35ba 18 03			jr .pastdmark  
35bc ..			.dmark: db "0=."  
35bf f1			.pastdmark: pop af  
35c0			endm  
# End of macro DMARK
35c0						CALLMONITOR 
35c0 cd 92 16			call break_point_state  
35c3				endm  
# End of macro CALLMONITOR
35c3					endif 
35c3					FORTH_DSP 
35c3 cd dc 1d			call macro_forth_dsp 
35c6				endm 
# End of macro FORTH_DSP
35c6 7e					ld a,(hl)	; get type of value on TOS 
35c7 fe 02				cp DS_TYPE_INUM  
35c9 28 00				jr z, .tz_inum 
35cb			 
35cb				if FORTH_ENABLE_FLOATMATH 
35cb					jr .tz_done 
35cb			 
35cb				endif 
35cb					 
35cb			 
35cb			.tz_inum: 
35cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35cb cd 16 1e			call macro_dsp_valuehl 
35ce				endm 
# End of macro FORTH_DSP_VALUEHL
35ce			 
35ce			;		push hl 
35ce			 
35ce					; destroy value TOS 
35ce			 
35ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ce cd ce 1e			call macro_forth_dsp_pop 
35d1				endm 
# End of macro FORTH_DSP_POP
35d1			 
35d1			;		pop hl 
35d1			 
35d1 3e 00				ld a,0 
35d3			 
35d3 bd					cp l 
35d4 20 08				jr nz, .tz_notzero 
35d6			 
35d6 bc					cp h 
35d7			 
35d7 20 05				jr nz, .tz_notzero 
35d9			 
35d9			 
35d9 21 01 00				ld hl, FORTH_TRUE 
35dc 18 03				jr .tz_done 
35de			 
35de 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
35e1			 
35e1					; push value back onto stack for another op etc 
35e1			 
35e1			.tz_done: 
35e1 cd 1f 1c				call forth_push_numhl 
35e4			 
35e4					NEXTW 
35e4 c3 88 1f			jp macro_next 
35e7				endm 
# End of macro NEXTW
35e7			.LESS: 
35e7				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
35e7 2f				db WORD_SYS_CORE+27             
35e8 50 36			dw .GT            
35ea 02				db 1 + 1 
35eb .. 00			db "<",0              
35ed				endm 
# End of macro CWHEAD
35ed			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
35ed				; TODO add floating point number detection 
35ed					if DEBUG_FORTH_WORDS_KEY 
35ed						DMARK "LES" 
35ed f5				push af  
35ee 3a 02 36			ld a, (.dmark)  
35f1 32 77 fb			ld (debug_mark),a  
35f4 3a 03 36			ld a, (.dmark+1)  
35f7 32 78 fb			ld (debug_mark+1),a  
35fa 3a 04 36			ld a, (.dmark+2)  
35fd 32 79 fb			ld (debug_mark+2),a  
3600 18 03			jr .pastdmark  
3602 ..			.dmark: db "LES"  
3605 f1			.pastdmark: pop af  
3606			endm  
# End of macro DMARK
3606						CALLMONITOR 
3606 cd 92 16			call break_point_state  
3609				endm  
# End of macro CALLMONITOR
3609					endif 
3609					FORTH_DSP 
3609 cd dc 1d			call macro_forth_dsp 
360c				endm 
# End of macro FORTH_DSP
360c					;v5 FORTH_DSP_VALUE 
360c 7e					ld a,(hl)	; get type of value on TOS 
360d fe 02				cp DS_TYPE_INUM  
360f 28 00				jr z, .less_inum 
3611			 
3611				if FORTH_ENABLE_FLOATMATH 
3611					jr .less_done 
3611			 
3611				endif 
3611					 
3611			 
3611			.less_inum: 
3611					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3611 cd 16 1e			call macro_dsp_valuehl 
3614				endm 
# End of macro FORTH_DSP_VALUEHL
3614			 
3614 e5					push hl  ; u2 
3615			 
3615					; destroy value TOS 
3615			 
3615					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3615 cd ce 1e			call macro_forth_dsp_pop 
3618				endm 
# End of macro FORTH_DSP_POP
3618			 
3618			 
3618					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3618 cd 16 1e			call macro_dsp_valuehl 
361b				endm 
# End of macro FORTH_DSP_VALUEHL
361b			 
361b e5					push hl    ; u1 
361c			 
361c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
361c cd ce 1e			call macro_forth_dsp_pop 
361f				endm 
# End of macro FORTH_DSP_POP
361f			 
361f			 
361f b7			 or a      ;clear carry flag 
3620 01 00 00		 ld bc, FORTH_FALSE 
3623 e1			  pop hl    ; u1 
3624 d1			  pop de    ; u2 
3625 ed 52		  sbc hl,de 
3627 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3629			 
3629 01 01 00		 ld bc, FORTH_TRUE 
362c			.lscont:  
362c c5					push bc 
362d e1					pop hl 
362e			 
362e					if DEBUG_FORTH_WORDS 
362e						DMARK "LT1" 
362e f5				push af  
362f 3a 43 36			ld a, (.dmark)  
3632 32 77 fb			ld (debug_mark),a  
3635 3a 44 36			ld a, (.dmark+1)  
3638 32 78 fb			ld (debug_mark+1),a  
363b 3a 45 36			ld a, (.dmark+2)  
363e 32 79 fb			ld (debug_mark+2),a  
3641 18 03			jr .pastdmark  
3643 ..			.dmark: db "LT1"  
3646 f1			.pastdmark: pop af  
3647			endm  
# End of macro DMARK
3647						CALLMONITOR 
3647 cd 92 16			call break_point_state  
364a				endm  
# End of macro CALLMONITOR
364a					endif 
364a cd 1f 1c				call forth_push_numhl 
364d			 
364d					NEXTW 
364d c3 88 1f			jp macro_next 
3650				endm 
# End of macro NEXTW
3650			.GT: 
3650				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3650 30				db WORD_SYS_CORE+28             
3651 b9 36			dw .EQUAL            
3653 02				db 1 + 1 
3654 .. 00			db ">",0              
3656				endm 
# End of macro CWHEAD
3656			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3656				; TODO add floating point number detection 
3656					if DEBUG_FORTH_WORDS_KEY 
3656						DMARK "GRT" 
3656 f5				push af  
3657 3a 6b 36			ld a, (.dmark)  
365a 32 77 fb			ld (debug_mark),a  
365d 3a 6c 36			ld a, (.dmark+1)  
3660 32 78 fb			ld (debug_mark+1),a  
3663 3a 6d 36			ld a, (.dmark+2)  
3666 32 79 fb			ld (debug_mark+2),a  
3669 18 03			jr .pastdmark  
366b ..			.dmark: db "GRT"  
366e f1			.pastdmark: pop af  
366f			endm  
# End of macro DMARK
366f						CALLMONITOR 
366f cd 92 16			call break_point_state  
3672				endm  
# End of macro CALLMONITOR
3672					endif 
3672					FORTH_DSP 
3672 cd dc 1d			call macro_forth_dsp 
3675				endm 
# End of macro FORTH_DSP
3675					;FORTH_DSP_VALUE 
3675 7e					ld a,(hl)	; get type of value on TOS 
3676 fe 02				cp DS_TYPE_INUM  
3678 28 00				jr z, .gt_inum 
367a			 
367a				if FORTH_ENABLE_FLOATMATH 
367a					jr .gt_done 
367a			 
367a				endif 
367a					 
367a			 
367a			.gt_inum: 
367a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
367a cd 16 1e			call macro_dsp_valuehl 
367d				endm 
# End of macro FORTH_DSP_VALUEHL
367d			 
367d e5					push hl  ; u2 
367e			 
367e					; destroy value TOS 
367e			 
367e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
367e cd ce 1e			call macro_forth_dsp_pop 
3681				endm 
# End of macro FORTH_DSP_POP
3681			 
3681			 
3681					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3681 cd 16 1e			call macro_dsp_valuehl 
3684				endm 
# End of macro FORTH_DSP_VALUEHL
3684			 
3684 e5					push hl    ; u1 
3685			 
3685					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3685 cd ce 1e			call macro_forth_dsp_pop 
3688				endm 
# End of macro FORTH_DSP_POP
3688			 
3688			 
3688 b7			 or a      ;clear carry flag 
3689 01 00 00		 ld bc, FORTH_FALSE 
368c e1			  pop hl    ; u1 
368d d1			  pop de    ; u2 
368e ed 52		  sbc hl,de 
3690 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3692			 
3692 01 01 00		 ld bc, FORTH_TRUE 
3695			.gtcont:  
3695 c5					push bc 
3696 e1					pop hl 
3697			 
3697					if DEBUG_FORTH_WORDS 
3697						DMARK "GT1" 
3697 f5				push af  
3698 3a ac 36			ld a, (.dmark)  
369b 32 77 fb			ld (debug_mark),a  
369e 3a ad 36			ld a, (.dmark+1)  
36a1 32 78 fb			ld (debug_mark+1),a  
36a4 3a ae 36			ld a, (.dmark+2)  
36a7 32 79 fb			ld (debug_mark+2),a  
36aa 18 03			jr .pastdmark  
36ac ..			.dmark: db "GT1"  
36af f1			.pastdmark: pop af  
36b0			endm  
# End of macro DMARK
36b0						CALLMONITOR 
36b0 cd 92 16			call break_point_state  
36b3				endm  
# End of macro CALLMONITOR
36b3					endif 
36b3 cd 1f 1c				call forth_push_numhl 
36b6			 
36b6					NEXTW 
36b6 c3 88 1f			jp macro_next 
36b9				endm 
# End of macro NEXTW
36b9			.EQUAL: 
36b9				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
36b9 31				db WORD_SYS_CORE+29             
36ba 24 37			dw .ENDLOGIC            
36bc 02				db 1 + 1 
36bd .. 00			db "=",0              
36bf				endm 
# End of macro CWHEAD
36bf			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
36bf				; TODO add floating point number detection 
36bf					if DEBUG_FORTH_WORDS_KEY 
36bf						DMARK "EQ." 
36bf f5				push af  
36c0 3a d4 36			ld a, (.dmark)  
36c3 32 77 fb			ld (debug_mark),a  
36c6 3a d5 36			ld a, (.dmark+1)  
36c9 32 78 fb			ld (debug_mark+1),a  
36cc 3a d6 36			ld a, (.dmark+2)  
36cf 32 79 fb			ld (debug_mark+2),a  
36d2 18 03			jr .pastdmark  
36d4 ..			.dmark: db "EQ."  
36d7 f1			.pastdmark: pop af  
36d8			endm  
# End of macro DMARK
36d8						CALLMONITOR 
36d8 cd 92 16			call break_point_state  
36db				endm  
# End of macro CALLMONITOR
36db					endif 
36db					FORTH_DSP 
36db cd dc 1d			call macro_forth_dsp 
36de				endm 
# End of macro FORTH_DSP
36de					;v5 FORTH_DSP_VALUE 
36de 7e					ld a,(hl)	; get type of value on TOS 
36df fe 02				cp DS_TYPE_INUM  
36e1 28 00				jr z, .eq_inum 
36e3			 
36e3				if FORTH_ENABLE_FLOATMATH 
36e3					jr .eq_done 
36e3			 
36e3				endif 
36e3					 
36e3			 
36e3			.eq_inum: 
36e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e3 cd 16 1e			call macro_dsp_valuehl 
36e6				endm 
# End of macro FORTH_DSP_VALUEHL
36e6			 
36e6 e5					push hl 
36e7			 
36e7					; destroy value TOS 
36e7			 
36e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e7 cd ce 1e			call macro_forth_dsp_pop 
36ea				endm 
# End of macro FORTH_DSP_POP
36ea			 
36ea			 
36ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ea cd 16 1e			call macro_dsp_valuehl 
36ed				endm 
# End of macro FORTH_DSP_VALUEHL
36ed			 
36ed					; one value on hl get other one back 
36ed			 
36ed e5					push hl 
36ee			 
36ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ee cd ce 1e			call macro_forth_dsp_pop 
36f1				endm 
# End of macro FORTH_DSP_POP
36f1			 
36f1 0e 00				ld c, FORTH_FALSE 
36f3			 
36f3 e1					pop hl 
36f4 d1					pop de 
36f5			 
36f5 7b					ld a, e 
36f6 bd					cp l 
36f7			 
36f7 20 06				jr nz, .eq_done 
36f9			 
36f9 7a					ld a, d 
36fa bc					cp h 
36fb			 
36fb 20 02				jr nz, .eq_done 
36fd			 
36fd 0e 01				ld c, FORTH_TRUE 
36ff					 
36ff			 
36ff			 
36ff			.eq_done: 
36ff			 
36ff					; TODO push value back onto stack for another op etc 
36ff			 
36ff 26 00				ld h, 0 
3701 69					ld l, c 
3702					if DEBUG_FORTH_WORDS 
3702						DMARK "EQ1" 
3702 f5				push af  
3703 3a 17 37			ld a, (.dmark)  
3706 32 77 fb			ld (debug_mark),a  
3709 3a 18 37			ld a, (.dmark+1)  
370c 32 78 fb			ld (debug_mark+1),a  
370f 3a 19 37			ld a, (.dmark+2)  
3712 32 79 fb			ld (debug_mark+2),a  
3715 18 03			jr .pastdmark  
3717 ..			.dmark: db "EQ1"  
371a f1			.pastdmark: pop af  
371b			endm  
# End of macro DMARK
371b						CALLMONITOR 
371b cd 92 16			call break_point_state  
371e				endm  
# End of macro CALLMONITOR
371e					endif 
371e cd 1f 1c				call forth_push_numhl 
3721			 
3721					NEXTW 
3721 c3 88 1f			jp macro_next 
3724				endm 
# End of macro NEXTW
3724			 
3724			 
3724			.ENDLOGIC: 
3724			; eof 
3724			 
3724			 
# End of file forth_words_logic.asm
3724			include "forth_words_maths.asm" 
3724			 
3724			; | ## Maths Words 
3724			 
3724			.PLUS:	 
3724				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3724 15				db WORD_SYS_CORE+1             
3725 66 37			dw .NEG            
3727 02				db 1 + 1 
3728 .. 00			db "+",0              
372a				endm 
# End of macro CWHEAD
372a			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
372a					if DEBUG_FORTH_WORDS_KEY 
372a						DMARK "PLU" 
372a f5				push af  
372b 3a 3f 37			ld a, (.dmark)  
372e 32 77 fb			ld (debug_mark),a  
3731 3a 40 37			ld a, (.dmark+1)  
3734 32 78 fb			ld (debug_mark+1),a  
3737 3a 41 37			ld a, (.dmark+2)  
373a 32 79 fb			ld (debug_mark+2),a  
373d 18 03			jr .pastdmark  
373f ..			.dmark: db "PLU"  
3742 f1			.pastdmark: pop af  
3743			endm  
# End of macro DMARK
3743						CALLMONITOR 
3743 cd 92 16			call break_point_state  
3746				endm  
# End of macro CALLMONITOR
3746					endif 
3746					; add top two values and push back result 
3746			 
3746					;for v5 FORTH_DSP_VALUE 
3746					FORTH_DSP 
3746 cd dc 1d			call macro_forth_dsp 
3749				endm 
# End of macro FORTH_DSP
3749 7e					ld a,(hl)	; get type of value on TOS 
374a fe 02				cp DS_TYPE_INUM  
374c 28 03				jr z, .dot_inum 
374e			 
374e					NEXTW 
374e c3 88 1f			jp macro_next 
3751				endm 
# End of macro NEXTW
3751			 
3751			; float maths 
3751			 
3751				if FORTH_ENABLE_FLOATMATH 
3751						inc hl      ; now at start of numeric as string 
3751			 
3751					if DEBUG_FORTH_MATHS 
3751						DMARK "ADD" 
3751				CALLMONITOR 
3751					endif 
3751			 
3751					;ld ix, hl 
3751					call CON 
3751			 
3751			 
3751					push hl 
3751					 
3751					 
3751			 
3751						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3751			 
3751					; get next number 
3751			 
3751						FORTH_DSP_VALUE 
3751			 
3751						inc hl      ; now at start of numeric as string 
3751			 
3751					;ld ix, hl 
3751					call CON 
3751			 
3751					push hl 
3751			 
3751			 
3751						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3751			 
3751						; TODO do add 
3751			 
3751						call IADD 
3751			 
3751						; TODO get result back as ascii 
3751			 
3751						; TODO push result  
3751			 
3751			 
3751			 
3751						jr .dot_done 
3751				endif 
3751			 
3751			.dot_inum: 
3751			 
3751			 
3751					if DEBUG_FORTH_DOT 
3751						DMARK "+IT" 
3751				CALLMONITOR 
3751					endif 
3751			 
3751					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3751 cd 16 1e			call macro_dsp_valuehl 
3754				endm 
# End of macro FORTH_DSP_VALUEHL
3754			 
3754				; TODO add floating point number detection 
3754			 
3754 e5					push hl 
3755			 
3755					; destroy value TOS 
3755			 
3755					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3755 cd ce 1e			call macro_forth_dsp_pop 
3758				endm 
# End of macro FORTH_DSP_POP
3758			 
3758			 
3758					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3758 cd 16 1e			call macro_dsp_valuehl 
375b				endm 
# End of macro FORTH_DSP_VALUEHL
375b			 
375b					; one value on hl get other one back 
375b			 
375b d1					pop de 
375c			 
375c					; do the add 
375c			 
375c 19					add hl,de 
375d			 
375d					; save it 
375d			 
375d			;		push hl	 
375d			 
375d					; 
375d			 
375d					; destroy value TOS 
375d			 
375d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
375d cd ce 1e			call macro_forth_dsp_pop 
3760				endm 
# End of macro FORTH_DSP_POP
3760			 
3760					; TODO push value back onto stack for another op etc 
3760			 
3760			;		pop hl 
3760			 
3760			.dot_done: 
3760 cd 1f 1c				call forth_push_numhl 
3763			 
3763					NEXTW 
3763 c3 88 1f			jp macro_next 
3766				endm 
# End of macro NEXTW
3766			.NEG: 
3766			 
3766				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3766 17				db WORD_SYS_CORE+3             
3767 a9 37			dw .DIV            
3769 02				db 1 + 1 
376a .. 00			db "-",0              
376c				endm 
# End of macro CWHEAD
376c			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
376c					if DEBUG_FORTH_WORDS_KEY 
376c						DMARK "SUB" 
376c f5				push af  
376d 3a 81 37			ld a, (.dmark)  
3770 32 77 fb			ld (debug_mark),a  
3773 3a 82 37			ld a, (.dmark+1)  
3776 32 78 fb			ld (debug_mark+1),a  
3779 3a 83 37			ld a, (.dmark+2)  
377c 32 79 fb			ld (debug_mark+2),a  
377f 18 03			jr .pastdmark  
3781 ..			.dmark: db "SUB"  
3784 f1			.pastdmark: pop af  
3785			endm  
# End of macro DMARK
3785						CALLMONITOR 
3785 cd 92 16			call break_point_state  
3788				endm  
# End of macro CALLMONITOR
3788					endif 
3788			 
3788			 
3788				; TODO add floating point number detection 
3788					; v5 FORTH_DSP_VALUE 
3788					FORTH_DSP 
3788 cd dc 1d			call macro_forth_dsp 
378b				endm 
# End of macro FORTH_DSP
378b 7e					ld a,(hl)	; get type of value on TOS 
378c fe 02				cp DS_TYPE_INUM  
378e 28 03				jr z, .neg_inum 
3790			 
3790					NEXTW 
3790 c3 88 1f			jp macro_next 
3793				endm 
# End of macro NEXTW
3793			 
3793			; float maths 
3793			 
3793				if FORTH_ENABLE_FLOATMATH 
3793					jr .neg_done 
3793			 
3793				endif 
3793					 
3793			 
3793			.neg_inum: 
3793					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3793 cd 16 1e			call macro_dsp_valuehl 
3796				endm 
# End of macro FORTH_DSP_VALUEHL
3796			 
3796 e5					push hl 
3797			 
3797					; destroy value TOS 
3797			 
3797					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3797 cd ce 1e			call macro_forth_dsp_pop 
379a				endm 
# End of macro FORTH_DSP_POP
379a			 
379a			 
379a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
379a cd 16 1e			call macro_dsp_valuehl 
379d				endm 
# End of macro FORTH_DSP_VALUEHL
379d			 
379d					; one value on hl get other one back 
379d			 
379d d1					pop de 
379e			 
379e					; do the sub 
379e			;		ex de, hl 
379e			 
379e ed 52				sbc hl,de 
37a0			 
37a0					; save it 
37a0			 
37a0			;		push hl	 
37a0			 
37a0					; 
37a0			 
37a0					; destroy value TOS 
37a0			 
37a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a0 cd ce 1e			call macro_forth_dsp_pop 
37a3				endm 
# End of macro FORTH_DSP_POP
37a3			 
37a3					; TODO push value back onto stack for another op etc 
37a3			 
37a3			;		pop hl 
37a3			 
37a3 cd 1f 1c				call forth_push_numhl 
37a6			.neg_done: 
37a6			 
37a6					NEXTW 
37a6 c3 88 1f			jp macro_next 
37a9				endm 
# End of macro NEXTW
37a9			.DIV: 
37a9				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
37a9 18				db WORD_SYS_CORE+4             
37aa f6 37			dw .MUL            
37ac 02				db 1 + 1 
37ad .. 00			db "/",0              
37af				endm 
# End of macro CWHEAD
37af			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
37af					if DEBUG_FORTH_WORDS_KEY 
37af						DMARK "DIV" 
37af f5				push af  
37b0 3a c4 37			ld a, (.dmark)  
37b3 32 77 fb			ld (debug_mark),a  
37b6 3a c5 37			ld a, (.dmark+1)  
37b9 32 78 fb			ld (debug_mark+1),a  
37bc 3a c6 37			ld a, (.dmark+2)  
37bf 32 79 fb			ld (debug_mark+2),a  
37c2 18 03			jr .pastdmark  
37c4 ..			.dmark: db "DIV"  
37c7 f1			.pastdmark: pop af  
37c8			endm  
# End of macro DMARK
37c8						CALLMONITOR 
37c8 cd 92 16			call break_point_state  
37cb				endm  
# End of macro CALLMONITOR
37cb					endif 
37cb				; TODO add floating point number detection 
37cb					; v5 FORTH_DSP_VALUE 
37cb					FORTH_DSP 
37cb cd dc 1d			call macro_forth_dsp 
37ce				endm 
# End of macro FORTH_DSP
37ce 7e					ld a,(hl)	; get type of value on TOS 
37cf fe 02				cp DS_TYPE_INUM  
37d1 28 03				jr z, .div_inum 
37d3			 
37d3				if FORTH_ENABLE_FLOATMATH 
37d3					jr .div_done 
37d3			 
37d3				endif 
37d3					NEXTW 
37d3 c3 88 1f			jp macro_next 
37d6				endm 
# End of macro NEXTW
37d6			.div_inum: 
37d6			 
37d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d6 cd 16 1e			call macro_dsp_valuehl 
37d9				endm 
# End of macro FORTH_DSP_VALUEHL
37d9			 
37d9 e5					push hl    ; to go to bc 
37da			 
37da					; destroy value TOS 
37da			 
37da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37da cd ce 1e			call macro_forth_dsp_pop 
37dd				endm 
# End of macro FORTH_DSP_POP
37dd			 
37dd			 
37dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37dd cd 16 1e			call macro_dsp_valuehl 
37e0				endm 
# End of macro FORTH_DSP_VALUEHL
37e0			 
37e0					; hl to go to de 
37e0			 
37e0 e5					push hl 
37e1			 
37e1 c1					pop bc 
37e2 d1					pop de		 
37e3			 
37e3			 
37e3					if DEBUG_FORTH_MATHS 
37e3						DMARK "DIV" 
37e3				CALLMONITOR 
37e3					endif 
37e3					; one value on hl but move to a get other one back 
37e3			 
37e3			        
37e3 cd 66 0c			call Div16 
37e6			 
37e6			;	push af	 
37e6 e5				push hl 
37e7 c5				push bc 
37e8			 
37e8					if DEBUG_FORTH_MATHS 
37e8						DMARK "DI1" 
37e8				CALLMONITOR 
37e8					endif 
37e8			 
37e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e8 cd ce 1e			call macro_forth_dsp_pop 
37eb				endm 
# End of macro FORTH_DSP_POP
37eb			 
37eb			 
37eb			 
37eb e1					pop hl    ; result 
37ec			 
37ec cd 1f 1c				call forth_push_numhl 
37ef			 
37ef e1					pop hl    ; reminder 
37f0			;		ld h,0 
37f0			;		ld l,d 
37f0			 
37f0 cd 1f 1c				call forth_push_numhl 
37f3			.div_done: 
37f3					NEXTW 
37f3 c3 88 1f			jp macro_next 
37f6				endm 
# End of macro NEXTW
37f6			.MUL: 
37f6				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37f6 19				db WORD_SYS_CORE+5             
37f7 3b 38			dw .MIN            
37f9 02				db 1 + 1 
37fa .. 00			db "*",0              
37fc				endm 
# End of macro CWHEAD
37fc			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37fc				; TODO add floating point number detection 
37fc					if DEBUG_FORTH_WORDS_KEY 
37fc						DMARK "MUL" 
37fc f5				push af  
37fd 3a 11 38			ld a, (.dmark)  
3800 32 77 fb			ld (debug_mark),a  
3803 3a 12 38			ld a, (.dmark+1)  
3806 32 78 fb			ld (debug_mark+1),a  
3809 3a 13 38			ld a, (.dmark+2)  
380c 32 79 fb			ld (debug_mark+2),a  
380f 18 03			jr .pastdmark  
3811 ..			.dmark: db "MUL"  
3814 f1			.pastdmark: pop af  
3815			endm  
# End of macro DMARK
3815						CALLMONITOR 
3815 cd 92 16			call break_point_state  
3818				endm  
# End of macro CALLMONITOR
3818					endif 
3818					FORTH_DSP 
3818 cd dc 1d			call macro_forth_dsp 
381b				endm 
# End of macro FORTH_DSP
381b					; v5 FORTH_DSP_VALUE 
381b 7e					ld a,(hl)	; get type of value on TOS 
381c fe 02				cp DS_TYPE_INUM  
381e 28 03				jr z, .mul_inum 
3820			 
3820				if FORTH_ENABLE_FLOATMATH 
3820					jr .mul_done 
3820			 
3820				endif 
3820			 
3820					NEXTW 
3820 c3 88 1f			jp macro_next 
3823				endm 
# End of macro NEXTW
3823			.mul_inum:	 
3823			 
3823					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3823 cd 16 1e			call macro_dsp_valuehl 
3826				endm 
# End of macro FORTH_DSP_VALUEHL
3826			 
3826 e5					push hl 
3827			 
3827					; destroy value TOS 
3827			 
3827					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3827 cd ce 1e			call macro_forth_dsp_pop 
382a				endm 
# End of macro FORTH_DSP_POP
382a			 
382a			 
382a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
382a cd 16 1e			call macro_dsp_valuehl 
382d				endm 
# End of macro FORTH_DSP_VALUEHL
382d			 
382d					; one value on hl but move to a get other one back 
382d			 
382d 7d					ld a, l 
382e			 
382e d1					pop de 
382f			 
382f					; do the mull 
382f			;		ex de, hl 
382f			 
382f cd 8c 0c				call Mult16 
3832					; save it 
3832			 
3832			;		push hl	 
3832			 
3832					; 
3832			 
3832					; destroy value TOS 
3832			 
3832					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3832 cd ce 1e			call macro_forth_dsp_pop 
3835				endm 
# End of macro FORTH_DSP_POP
3835			 
3835					; TODO push value back onto stack for another op etc 
3835			 
3835			;		pop hl 
3835			 
3835 cd 1f 1c				call forth_push_numhl 
3838			 
3838			.mul_done: 
3838					NEXTW 
3838 c3 88 1f			jp macro_next 
383b				endm 
# End of macro NEXTW
383b			 
383b			 
383b			 
383b			 
383b			.MIN: 
383b				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
383b 49				db WORD_SYS_CORE+53             
383c bc 38			dw .MAX            
383e 04				db 3 + 1 
383f .. 00			db "MIN",0              
3843				endm 
# End of macro CWHEAD
3843			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3843					if DEBUG_FORTH_WORDS_KEY 
3843						DMARK "MIN" 
3843 f5				push af  
3844 3a 58 38			ld a, (.dmark)  
3847 32 77 fb			ld (debug_mark),a  
384a 3a 59 38			ld a, (.dmark+1)  
384d 32 78 fb			ld (debug_mark+1),a  
3850 3a 5a 38			ld a, (.dmark+2)  
3853 32 79 fb			ld (debug_mark+2),a  
3856 18 03			jr .pastdmark  
3858 ..			.dmark: db "MIN"  
385b f1			.pastdmark: pop af  
385c			endm  
# End of macro DMARK
385c						CALLMONITOR 
385c cd 92 16			call break_point_state  
385f				endm  
# End of macro CALLMONITOR
385f					endif 
385f					; get u2 
385f			 
385f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
385f cd 16 1e			call macro_dsp_valuehl 
3862				endm 
# End of macro FORTH_DSP_VALUEHL
3862			 
3862 e5					push hl   ; u2 
3863			 
3863					; destroy value TOS 
3863			 
3863					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3863 cd ce 1e			call macro_forth_dsp_pop 
3866				endm 
# End of macro FORTH_DSP_POP
3866			 
3866					; get u1 
3866			 
3866					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3866 cd 16 1e			call macro_dsp_valuehl 
3869				endm 
# End of macro FORTH_DSP_VALUEHL
3869			 
3869 e5					push hl  ; u1 
386a			 
386a					; destroy value TOS 
386a			 
386a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
386a cd ce 1e			call macro_forth_dsp_pop 
386d				endm 
# End of macro FORTH_DSP_POP
386d			 
386d b7			 or a      ;clear carry flag 
386e e1			  pop hl    ; u1 
386f d1			  pop de    ; u2 
3870 e5				push hl   ; saved in case hl is lowest 
3871 ed 52		  sbc hl,de 
3873 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3875			 
3875 e1				pop hl 
3876					if DEBUG_FORTH_WORDS 
3876						DMARK "MIN" 
3876 f5				push af  
3877 3a 8b 38			ld a, (.dmark)  
387a 32 77 fb			ld (debug_mark),a  
387d 3a 8c 38			ld a, (.dmark+1)  
3880 32 78 fb			ld (debug_mark+1),a  
3883 3a 8d 38			ld a, (.dmark+2)  
3886 32 79 fb			ld (debug_mark+2),a  
3889 18 03			jr .pastdmark  
388b ..			.dmark: db "MIN"  
388e f1			.pastdmark: pop af  
388f			endm  
# End of macro DMARK
388f						CALLMONITOR 
388f cd 92 16			call break_point_state  
3892				endm  
# End of macro CALLMONITOR
3892					endif 
3892 cd 1f 1c				call forth_push_numhl 
3895			 
3895				       NEXTW 
3895 c3 88 1f			jp macro_next 
3898				endm 
# End of macro NEXTW
3898			 
3898			.mincont:  
3898 c1				pop bc   ; tidy up 
3899 eb				ex de , hl  
389a					if DEBUG_FORTH_WORDS 
389a						DMARK "MI1" 
389a f5				push af  
389b 3a af 38			ld a, (.dmark)  
389e 32 77 fb			ld (debug_mark),a  
38a1 3a b0 38			ld a, (.dmark+1)  
38a4 32 78 fb			ld (debug_mark+1),a  
38a7 3a b1 38			ld a, (.dmark+2)  
38aa 32 79 fb			ld (debug_mark+2),a  
38ad 18 03			jr .pastdmark  
38af ..			.dmark: db "MI1"  
38b2 f1			.pastdmark: pop af  
38b3			endm  
# End of macro DMARK
38b3						CALLMONITOR 
38b3 cd 92 16			call break_point_state  
38b6				endm  
# End of macro CALLMONITOR
38b6					endif 
38b6 cd 1f 1c				call forth_push_numhl 
38b9			 
38b9				       NEXTW 
38b9 c3 88 1f			jp macro_next 
38bc				endm 
# End of macro NEXTW
38bc			.MAX: 
38bc				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
38bc 4a				db WORD_SYS_CORE+54             
38bd 3d 39			dw .RND16            
38bf 04				db 3 + 1 
38c0 .. 00			db "MAX",0              
38c4				endm 
# End of macro CWHEAD
38c4			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
38c4					if DEBUG_FORTH_WORDS_KEY 
38c4						DMARK "MAX" 
38c4 f5				push af  
38c5 3a d9 38			ld a, (.dmark)  
38c8 32 77 fb			ld (debug_mark),a  
38cb 3a da 38			ld a, (.dmark+1)  
38ce 32 78 fb			ld (debug_mark+1),a  
38d1 3a db 38			ld a, (.dmark+2)  
38d4 32 79 fb			ld (debug_mark+2),a  
38d7 18 03			jr .pastdmark  
38d9 ..			.dmark: db "MAX"  
38dc f1			.pastdmark: pop af  
38dd			endm  
# End of macro DMARK
38dd						CALLMONITOR 
38dd cd 92 16			call break_point_state  
38e0				endm  
# End of macro CALLMONITOR
38e0					endif 
38e0					; get u2 
38e0			 
38e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e0 cd 16 1e			call macro_dsp_valuehl 
38e3				endm 
# End of macro FORTH_DSP_VALUEHL
38e3			 
38e3 e5					push hl   ; u2 
38e4			 
38e4					; destroy value TOS 
38e4			 
38e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e4 cd ce 1e			call macro_forth_dsp_pop 
38e7				endm 
# End of macro FORTH_DSP_POP
38e7			 
38e7					; get u1 
38e7			 
38e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e7 cd 16 1e			call macro_dsp_valuehl 
38ea				endm 
# End of macro FORTH_DSP_VALUEHL
38ea			 
38ea e5					push hl  ; u1 
38eb			 
38eb					; destroy value TOS 
38eb			 
38eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38eb cd ce 1e			call macro_forth_dsp_pop 
38ee				endm 
# End of macro FORTH_DSP_POP
38ee			 
38ee b7			 or a      ;clear carry flag 
38ef e1			  pop hl    ; u1 
38f0 d1			  pop de    ; u2 
38f1 e5				push hl   ; saved in case hl is lowest 
38f2 ed 52		  sbc hl,de 
38f4 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38f6			 
38f6 e1				pop hl 
38f7					if DEBUG_FORTH_WORDS 
38f7						DMARK "MAX" 
38f7 f5				push af  
38f8 3a 0c 39			ld a, (.dmark)  
38fb 32 77 fb			ld (debug_mark),a  
38fe 3a 0d 39			ld a, (.dmark+1)  
3901 32 78 fb			ld (debug_mark+1),a  
3904 3a 0e 39			ld a, (.dmark+2)  
3907 32 79 fb			ld (debug_mark+2),a  
390a 18 03			jr .pastdmark  
390c ..			.dmark: db "MAX"  
390f f1			.pastdmark: pop af  
3910			endm  
# End of macro DMARK
3910						CALLMONITOR 
3910 cd 92 16			call break_point_state  
3913				endm  
# End of macro CALLMONITOR
3913					endif 
3913 cd 1f 1c				call forth_push_numhl 
3916			 
3916				       NEXTW 
3916 c3 88 1f			jp macro_next 
3919				endm 
# End of macro NEXTW
3919			 
3919			.maxcont:  
3919 c1				pop bc   ; tidy up 
391a eb				ex de , hl  
391b					if DEBUG_FORTH_WORDS 
391b						DMARK "MA1" 
391b f5				push af  
391c 3a 30 39			ld a, (.dmark)  
391f 32 77 fb			ld (debug_mark),a  
3922 3a 31 39			ld a, (.dmark+1)  
3925 32 78 fb			ld (debug_mark+1),a  
3928 3a 32 39			ld a, (.dmark+2)  
392b 32 79 fb			ld (debug_mark+2),a  
392e 18 03			jr .pastdmark  
3930 ..			.dmark: db "MA1"  
3933 f1			.pastdmark: pop af  
3934			endm  
# End of macro DMARK
3934						CALLMONITOR 
3934 cd 92 16			call break_point_state  
3937				endm  
# End of macro CALLMONITOR
3937					endif 
3937 cd 1f 1c				call forth_push_numhl 
393a				       NEXTW 
393a c3 88 1f			jp macro_next 
393d				endm 
# End of macro NEXTW
393d			 
393d			.RND16: 
393d				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
393d 4e				db WORD_SYS_CORE+58             
393e 6c 39			dw .RND8            
3940 06				db 5 + 1 
3941 .. 00			db "RND16",0              
3947				endm 
# End of macro CWHEAD
3947			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3947					if DEBUG_FORTH_WORDS_KEY 
3947						DMARK "R16" 
3947 f5				push af  
3948 3a 5c 39			ld a, (.dmark)  
394b 32 77 fb			ld (debug_mark),a  
394e 3a 5d 39			ld a, (.dmark+1)  
3951 32 78 fb			ld (debug_mark+1),a  
3954 3a 5e 39			ld a, (.dmark+2)  
3957 32 79 fb			ld (debug_mark+2),a  
395a 18 03			jr .pastdmark  
395c ..			.dmark: db "R16"  
395f f1			.pastdmark: pop af  
3960			endm  
# End of macro DMARK
3960						CALLMONITOR 
3960 cd 92 16			call break_point_state  
3963				endm  
# End of macro CALLMONITOR
3963					endif 
3963 cd 30 0c				call prng16  
3966 cd 1f 1c				call forth_push_numhl 
3969				       NEXTW 
3969 c3 88 1f			jp macro_next 
396c				endm 
# End of macro NEXTW
396c			.RND8: 
396c				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
396c 60				db WORD_SYS_CORE+76             
396d a1 39			dw .RND            
396f 05				db 4 + 1 
3970 .. 00			db "RND8",0              
3975				endm 
# End of macro CWHEAD
3975			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3975					if DEBUG_FORTH_WORDS_KEY 
3975						DMARK "RN8" 
3975 f5				push af  
3976 3a 8a 39			ld a, (.dmark)  
3979 32 77 fb			ld (debug_mark),a  
397c 3a 8b 39			ld a, (.dmark+1)  
397f 32 78 fb			ld (debug_mark+1),a  
3982 3a 8c 39			ld a, (.dmark+2)  
3985 32 79 fb			ld (debug_mark+2),a  
3988 18 03			jr .pastdmark  
398a ..			.dmark: db "RN8"  
398d f1			.pastdmark: pop af  
398e			endm  
# End of macro DMARK
398e						CALLMONITOR 
398e cd 92 16			call break_point_state  
3991				endm  
# End of macro CALLMONITOR
3991					endif 
3991 2a b8 f8				ld hl,(xrandc) 
3994 23					inc hl 
3995 cd 4a 0c				call xrnd 
3998 6f					ld l,a	 
3999 26 00				ld h,0 
399b cd 1f 1c				call forth_push_numhl 
399e				       NEXTW 
399e c3 88 1f			jp macro_next 
39a1				endm 
# End of macro NEXTW
39a1			.RND: 
39a1				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
39a1 60				db WORD_SYS_CORE+76             
39a2 a7 3a			dw .ENDMATHS            
39a4 04				db 3 + 1 
39a5 .. 00			db "RND",0              
39a9				endm 
# End of macro CWHEAD
39a9			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
39a9			 
39a9					if DEBUG_FORTH_WORDS_KEY 
39a9						DMARK "RND" 
39a9 f5				push af  
39aa 3a be 39			ld a, (.dmark)  
39ad 32 77 fb			ld (debug_mark),a  
39b0 3a bf 39			ld a, (.dmark+1)  
39b3 32 78 fb			ld (debug_mark+1),a  
39b6 3a c0 39			ld a, (.dmark+2)  
39b9 32 79 fb			ld (debug_mark+2),a  
39bc 18 03			jr .pastdmark  
39be ..			.dmark: db "RND"  
39c1 f1			.pastdmark: pop af  
39c2			endm  
# End of macro DMARK
39c2						CALLMONITOR 
39c2 cd 92 16			call break_point_state  
39c5				endm  
# End of macro CALLMONITOR
39c5					endif 
39c5					 
39c5					FORTH_DSP_VALUEHL    ; upper range 
39c5 cd 16 1e			call macro_dsp_valuehl 
39c8				endm 
# End of macro FORTH_DSP_VALUEHL
39c8			 
39c8 22 bc f8				ld (LFSRSeed), hl	 
39cb			 
39cb					if DEBUG_FORTH_WORDS 
39cb						DMARK "RN1" 
39cb f5				push af  
39cc 3a e0 39			ld a, (.dmark)  
39cf 32 77 fb			ld (debug_mark),a  
39d2 3a e1 39			ld a, (.dmark+1)  
39d5 32 78 fb			ld (debug_mark+1),a  
39d8 3a e2 39			ld a, (.dmark+2)  
39db 32 79 fb			ld (debug_mark+2),a  
39de 18 03			jr .pastdmark  
39e0 ..			.dmark: db "RN1"  
39e3 f1			.pastdmark: pop af  
39e4			endm  
# End of macro DMARK
39e4						CALLMONITOR 
39e4 cd 92 16			call break_point_state  
39e7				endm  
# End of macro CALLMONITOR
39e7					endif 
39e7					FORTH_DSP_POP 
39e7 cd ce 1e			call macro_forth_dsp_pop 
39ea				endm 
# End of macro FORTH_DSP_POP
39ea			 
39ea					FORTH_DSP_VALUEHL    ; low range 
39ea cd 16 1e			call macro_dsp_valuehl 
39ed				endm 
# End of macro FORTH_DSP_VALUEHL
39ed			 
39ed					if DEBUG_FORTH_WORDS 
39ed						DMARK "RN2" 
39ed f5				push af  
39ee 3a 02 3a			ld a, (.dmark)  
39f1 32 77 fb			ld (debug_mark),a  
39f4 3a 03 3a			ld a, (.dmark+1)  
39f7 32 78 fb			ld (debug_mark+1),a  
39fa 3a 04 3a			ld a, (.dmark+2)  
39fd 32 79 fb			ld (debug_mark+2),a  
3a00 18 03			jr .pastdmark  
3a02 ..			.dmark: db "RN2"  
3a05 f1			.pastdmark: pop af  
3a06			endm  
# End of macro DMARK
3a06						CALLMONITOR 
3a06 cd 92 16			call break_point_state  
3a09				endm  
# End of macro CALLMONITOR
3a09					endif 
3a09 22 be f8				ld (LFSRSeed+2), hl 
3a0c			 
3a0c					FORTH_DSP_POP 
3a0c cd ce 1e			call macro_forth_dsp_pop 
3a0f				endm 
# End of macro FORTH_DSP_POP
3a0f			 
3a0f e5					push hl 
3a10			 
3a10 e1			.inrange:	pop hl 
3a11 cd 30 0c				call prng16  
3a14					if DEBUG_FORTH_WORDS 
3a14						DMARK "RN3" 
3a14 f5				push af  
3a15 3a 29 3a			ld a, (.dmark)  
3a18 32 77 fb			ld (debug_mark),a  
3a1b 3a 2a 3a			ld a, (.dmark+1)  
3a1e 32 78 fb			ld (debug_mark+1),a  
3a21 3a 2b 3a			ld a, (.dmark+2)  
3a24 32 79 fb			ld (debug_mark+2),a  
3a27 18 03			jr .pastdmark  
3a29 ..			.dmark: db "RN3"  
3a2c f1			.pastdmark: pop af  
3a2d			endm  
# End of macro DMARK
3a2d						CALLMONITOR 
3a2d cd 92 16			call break_point_state  
3a30				endm  
# End of macro CALLMONITOR
3a30					endif 
3a30					 
3a30					; if the range is 8bit knock out the high byte 
3a30			 
3a30 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
3a34			 
3a34 3e 00				ld a, 0 
3a36 ba					cp d  
3a37 20 1e				jr nz, .hirange 
3a39 26 00				ld h, 0   ; knock it down to 8bit 
3a3b			 
3a3b					if DEBUG_FORTH_WORDS 
3a3b						DMARK "RNk" 
3a3b f5				push af  
3a3c 3a 50 3a			ld a, (.dmark)  
3a3f 32 77 fb			ld (debug_mark),a  
3a42 3a 51 3a			ld a, (.dmark+1)  
3a45 32 78 fb			ld (debug_mark+1),a  
3a48 3a 52 3a			ld a, (.dmark+2)  
3a4b 32 79 fb			ld (debug_mark+2),a  
3a4e 18 03			jr .pastdmark  
3a50 ..			.dmark: db "RNk"  
3a53 f1			.pastdmark: pop af  
3a54			endm  
# End of macro DMARK
3a54						CALLMONITOR 
3a54 cd 92 16			call break_point_state  
3a57				endm  
# End of macro CALLMONITOR
3a57					endif 
3a57			.hirange:   
3a57 e5					push hl  
3a58 b7					or a  
3a59 ed 52		                sbc hl, de 
3a5b			 
3a5b					;call cmp16 
3a5b			 
3a5b 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a5d e1					pop hl 
3a5e e5					push hl 
3a5f			 
3a5f					if DEBUG_FORTH_WORDS 
3a5f						DMARK "RN4" 
3a5f f5				push af  
3a60 3a 74 3a			ld a, (.dmark)  
3a63 32 77 fb			ld (debug_mark),a  
3a66 3a 75 3a			ld a, (.dmark+1)  
3a69 32 78 fb			ld (debug_mark+1),a  
3a6c 3a 76 3a			ld a, (.dmark+2)  
3a6f 32 79 fb			ld (debug_mark+2),a  
3a72 18 03			jr .pastdmark  
3a74 ..			.dmark: db "RN4"  
3a77 f1			.pastdmark: pop af  
3a78			endm  
# End of macro DMARK
3a78						CALLMONITOR 
3a78 cd 92 16			call break_point_state  
3a7b				endm  
# End of macro CALLMONITOR
3a7b					endif 
3a7b ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3a7f					;call cmp16 
3a7f				 
3a7f b7					or a  
3a80 ed 52		                sbc hl, de 
3a82 38 8c				jr c, .inrange 
3a84			 
3a84 e1					pop hl 
3a85					 
3a85					if DEBUG_FORTH_WORDS 
3a85						DMARK "RNd" 
3a85 f5				push af  
3a86 3a 9a 3a			ld a, (.dmark)  
3a89 32 77 fb			ld (debug_mark),a  
3a8c 3a 9b 3a			ld a, (.dmark+1)  
3a8f 32 78 fb			ld (debug_mark+1),a  
3a92 3a 9c 3a			ld a, (.dmark+2)  
3a95 32 79 fb			ld (debug_mark+2),a  
3a98 18 03			jr .pastdmark  
3a9a ..			.dmark: db "RNd"  
3a9d f1			.pastdmark: pop af  
3a9e			endm  
# End of macro DMARK
3a9e						CALLMONITOR 
3a9e cd 92 16			call break_point_state  
3aa1				endm  
# End of macro CALLMONITOR
3aa1					endif 
3aa1			 
3aa1			 
3aa1 cd 1f 1c				call forth_push_numhl 
3aa4				       NEXTW 
3aa4 c3 88 1f			jp macro_next 
3aa7				endm 
# End of macro NEXTW
3aa7			 
3aa7			.ENDMATHS: 
3aa7			 
3aa7			; eof 
3aa7			 
# End of file forth_words_maths.asm
3aa7			include "forth_words_display.asm" 
3aa7			 
3aa7			; | ## Display Words 
3aa7			 
3aa7			.ATP: 
3aa7				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3aa7 62				db WORD_SYS_CORE+78             
3aa8 1e 3b			dw .FB            
3aaa 04				db 3 + 1 
3aab .. 00			db "AT?",0              
3aaf				endm 
# End of macro CWHEAD
3aaf			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3aaf					if DEBUG_FORTH_WORDS_KEY 
3aaf						DMARK "AT?" 
3aaf f5				push af  
3ab0 3a c4 3a			ld a, (.dmark)  
3ab3 32 77 fb			ld (debug_mark),a  
3ab6 3a c5 3a			ld a, (.dmark+1)  
3ab9 32 78 fb			ld (debug_mark+1),a  
3abc 3a c6 3a			ld a, (.dmark+2)  
3abf 32 79 fb			ld (debug_mark+2),a  
3ac2 18 03			jr .pastdmark  
3ac4 ..			.dmark: db "AT?"  
3ac7 f1			.pastdmark: pop af  
3ac8			endm  
# End of macro DMARK
3ac8						CALLMONITOR 
3ac8 cd 92 16			call break_point_state  
3acb				endm  
# End of macro CALLMONITOR
3acb					endif 
3acb 3a 46 f8				ld a, (f_cursor_ptr) 
3ace			 
3ace			if DEBUG_FORTH_WORDS 
3ace				DMARK "AT?" 
3ace f5				push af  
3acf 3a e3 3a			ld a, (.dmark)  
3ad2 32 77 fb			ld (debug_mark),a  
3ad5 3a e4 3a			ld a, (.dmark+1)  
3ad8 32 78 fb			ld (debug_mark+1),a  
3adb 3a e5 3a			ld a, (.dmark+2)  
3ade 32 79 fb			ld (debug_mark+2),a  
3ae1 18 03			jr .pastdmark  
3ae3 ..			.dmark: db "AT?"  
3ae6 f1			.pastdmark: pop af  
3ae7			endm  
# End of macro DMARK
3ae7				CALLMONITOR 
3ae7 cd 92 16			call break_point_state  
3aea				endm  
# End of macro CALLMONITOR
3aea			endif	 
3aea					; count the number of rows 
3aea			 
3aea 06 00				ld b, 0 
3aec 4f			.atpr:		ld c, a    ; save in case we go below zero 
3aed d6 28				sub display_cols 
3aef f2 f5 3a				jp p, .atprunder 
3af2 04					inc b 
3af3 18 f7				jr .atpr 
3af5			.atprunder:	 
3af5			if DEBUG_FORTH_WORDS 
3af5				DMARK "A?2" 
3af5 f5				push af  
3af6 3a 0a 3b			ld a, (.dmark)  
3af9 32 77 fb			ld (debug_mark),a  
3afc 3a 0b 3b			ld a, (.dmark+1)  
3aff 32 78 fb			ld (debug_mark+1),a  
3b02 3a 0c 3b			ld a, (.dmark+2)  
3b05 32 79 fb			ld (debug_mark+2),a  
3b08 18 03			jr .pastdmark  
3b0a ..			.dmark: db "A?2"  
3b0d f1			.pastdmark: pop af  
3b0e			endm  
# End of macro DMARK
3b0e				CALLMONITOR 
3b0e cd 92 16			call break_point_state  
3b11				endm  
# End of macro CALLMONITOR
3b11			endif	 
3b11 26 00				ld h, 0 
3b13 69					ld l, c 
3b14 cd 1f 1c				call forth_push_numhl 
3b17 68					ld l, b  
3b18 cd 1f 1c				call forth_push_numhl 
3b1b			 
3b1b			 
3b1b				NEXTW 
3b1b c3 88 1f			jp macro_next 
3b1e				endm 
# End of macro NEXTW
3b1e			 
3b1e			.FB: 
3b1e				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b1e 1b				db WORD_SYS_CORE+7             
3b1f 6c 3b			dw .EMIT            
3b21 03				db 2 + 1 
3b22 .. 00			db "FB",0              
3b25				endm 
# End of macro CWHEAD
3b25			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b25			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b25			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b25			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b25					if DEBUG_FORTH_WORDS_KEY 
3b25						DMARK "FB." 
3b25 f5				push af  
3b26 3a 3a 3b			ld a, (.dmark)  
3b29 32 77 fb			ld (debug_mark),a  
3b2c 3a 3b 3b			ld a, (.dmark+1)  
3b2f 32 78 fb			ld (debug_mark+1),a  
3b32 3a 3c 3b			ld a, (.dmark+2)  
3b35 32 79 fb			ld (debug_mark+2),a  
3b38 18 03			jr .pastdmark  
3b3a ..			.dmark: db "FB."  
3b3d f1			.pastdmark: pop af  
3b3e			endm  
# End of macro DMARK
3b3e						CALLMONITOR 
3b3e cd 92 16			call break_point_state  
3b41				endm  
# End of macro CALLMONITOR
3b41					endif 
3b41			 
3b41					FORTH_DSP_VALUEHL 
3b41 cd 16 1e			call macro_dsp_valuehl 
3b44				endm 
# End of macro FORTH_DSP_VALUEHL
3b44			 
3b44 7d					ld a, l 
3b45 fe 01				cp 1 
3b47 20 05				jr nz, .fbn1 
3b49 21 1c fa				ld hl, display_fb1 
3b4c 18 15				jr .fbset 
3b4e fe 02		.fbn1:		cp 2 
3b50 20 05				jr nz, .fbn2 
3b52 21 da f8				ld hl, display_fb2 
3b55 18 0c				jr .fbset 
3b57 fe 03		.fbn2:		cp 3 
3b59 20 05				jr nz, .fbn3 
3b5b 21 7b f9				ld hl, display_fb3 
3b5e 18 03				jr .fbset 
3b60			.fbn3:		 ; if invalid number select first 
3b60 21 1c fa				ld hl, display_fb1 
3b63 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3b66			 
3b66					FORTH_DSP_POP 
3b66 cd ce 1e			call macro_forth_dsp_pop 
3b69				endm 
# End of macro FORTH_DSP_POP
3b69			 
3b69					NEXTW 
3b69 c3 88 1f			jp macro_next 
3b6c				endm 
# End of macro NEXTW
3b6c			 
3b6c			 
3b6c			.EMIT: 
3b6c				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b6c 1b				db WORD_SYS_CORE+7             
3b6d bd 3b			dw .DOTH            
3b6f 05				db 4 + 1 
3b70 .. 00			db "EMIT",0              
3b75				endm 
# End of macro CWHEAD
3b75			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b75					; get value off TOS and display it 
3b75			 
3b75					if DEBUG_FORTH_WORDS_KEY 
3b75						DMARK "EMT" 
3b75 f5				push af  
3b76 3a 8a 3b			ld a, (.dmark)  
3b79 32 77 fb			ld (debug_mark),a  
3b7c 3a 8b 3b			ld a, (.dmark+1)  
3b7f 32 78 fb			ld (debug_mark+1),a  
3b82 3a 8c 3b			ld a, (.dmark+2)  
3b85 32 79 fb			ld (debug_mark+2),a  
3b88 18 03			jr .pastdmark  
3b8a ..			.dmark: db "EMT"  
3b8d f1			.pastdmark: pop af  
3b8e			endm  
# End of macro DMARK
3b8e						CALLMONITOR 
3b8e cd 92 16			call break_point_state  
3b91				endm  
# End of macro CALLMONITOR
3b91					endif 
3b91			 
3b91					FORTH_DSP_VALUEHL 
3b91 cd 16 1e			call macro_dsp_valuehl 
3b94				endm 
# End of macro FORTH_DSP_VALUEHL
3b94			 
3b94 7d					ld a,l 
3b95			 
3b95					; TODO write to display 
3b95			 
3b95 32 1b f0				ld (os_input), a 
3b98 3e 00				ld a, 0 
3b9a 32 1c f0				ld (os_input+1), a 
3b9d					 
3b9d 3a 46 f8				ld a, (f_cursor_ptr) 
3ba0 11 1b f0				ld de, os_input 
3ba3 cd e8 0a				call str_at_display 
3ba6			 
3ba6			 
3ba6 3a 24 f8				ld a,(cli_autodisplay) 
3ba9 fe 00				cp 0 
3bab 28 03				jr z, .enoupdate 
3bad cd f8 0a						call update_display 
3bb0					.enoupdate: 
3bb0			 
3bb0 3a 46 f8				ld a, (f_cursor_ptr) 
3bb3 3c					inc a 
3bb4 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3bb7			 
3bb7			 
3bb7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb7 cd ce 1e			call macro_forth_dsp_pop 
3bba				endm 
# End of macro FORTH_DSP_POP
3bba			  
3bba			 
3bba					NEXTW 
3bba c3 88 1f			jp macro_next 
3bbd				endm 
# End of macro NEXTW
3bbd			.DOTH: 
3bbd				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3bbd 1c				db WORD_SYS_CORE+8             
3bbe ed 3b			dw .DOTF            
3bc0 03				db 2 + 1 
3bc1 .. 00			db ".-",0              
3bc4				endm 
# End of macro CWHEAD
3bc4			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3bc4					; get value off TOS and display it 
3bc4					if DEBUG_FORTH_WORDS_KEY 
3bc4						DMARK "DTD" 
3bc4 f5				push af  
3bc5 3a d9 3b			ld a, (.dmark)  
3bc8 32 77 fb			ld (debug_mark),a  
3bcb 3a da 3b			ld a, (.dmark+1)  
3bce 32 78 fb			ld (debug_mark+1),a  
3bd1 3a db 3b			ld a, (.dmark+2)  
3bd4 32 79 fb			ld (debug_mark+2),a  
3bd7 18 03			jr .pastdmark  
3bd9 ..			.dmark: db "DTD"  
3bdc f1			.pastdmark: pop af  
3bdd			endm  
# End of macro DMARK
3bdd						CALLMONITOR 
3bdd cd 92 16			call break_point_state  
3be0				endm  
# End of macro CALLMONITOR
3be0					endif 
3be0 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3be2 3e 00			ld a, 0 
3be4 32 25 f8			ld (cli_mvdot), a 
3be7 c3 44 3c			jp .dotgo 
3bea				NEXTW 
3bea c3 88 1f			jp macro_next 
3bed				endm 
# End of macro NEXTW
3bed			.DOTF: 
3bed				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bed 1c				db WORD_SYS_CORE+8             
3bee 1b 3c			dw .DOT            
3bf0 03				db 2 + 1 
3bf1 .. 00			db ".>",0              
3bf4				endm 
# End of macro CWHEAD
3bf4			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bf4					; get value off TOS and display it 
3bf4			        ; TODO BUG adds extra spaces 
3bf4			        ; TODO BUG handle numerics? 
3bf4					if DEBUG_FORTH_WORDS_KEY 
3bf4						DMARK "DTC" 
3bf4 f5				push af  
3bf5 3a 09 3c			ld a, (.dmark)  
3bf8 32 77 fb			ld (debug_mark),a  
3bfb 3a 0a 3c			ld a, (.dmark+1)  
3bfe 32 78 fb			ld (debug_mark+1),a  
3c01 3a 0b 3c			ld a, (.dmark+2)  
3c04 32 79 fb			ld (debug_mark+2),a  
3c07 18 03			jr .pastdmark  
3c09 ..			.dmark: db "DTC"  
3c0c f1			.pastdmark: pop af  
3c0d			endm  
# End of macro DMARK
3c0d						CALLMONITOR 
3c0d cd 92 16			call break_point_state  
3c10				endm  
# End of macro CALLMONITOR
3c10					endif 
3c10 3e 01			ld a, 1 
3c12 32 25 f8			ld (cli_mvdot), a 
3c15 c3 44 3c			jp .dotgo 
3c18				NEXTW 
3c18 c3 88 1f			jp macro_next 
3c1b				endm 
# End of macro NEXTW
3c1b			 
3c1b			.DOT: 
3c1b				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c1b 1c				db WORD_SYS_CORE+8             
3c1c a7 3c			dw .CLS            
3c1e 02				db 1 + 1 
3c1f .. 00			db ".",0              
3c21				endm 
# End of macro CWHEAD
3c21			        ; | . ( u -- ) Display TOS | DONE 
3c21					; get value off TOS and display it 
3c21			 
3c21					if DEBUG_FORTH_WORDS_KEY 
3c21						DMARK "DOT" 
3c21 f5				push af  
3c22 3a 36 3c			ld a, (.dmark)  
3c25 32 77 fb			ld (debug_mark),a  
3c28 3a 37 3c			ld a, (.dmark+1)  
3c2b 32 78 fb			ld (debug_mark+1),a  
3c2e 3a 38 3c			ld a, (.dmark+2)  
3c31 32 79 fb			ld (debug_mark+2),a  
3c34 18 03			jr .pastdmark  
3c36 ..			.dmark: db "DOT"  
3c39 f1			.pastdmark: pop af  
3c3a			endm  
# End of macro DMARK
3c3a						CALLMONITOR 
3c3a cd 92 16			call break_point_state  
3c3d				endm  
# End of macro CALLMONITOR
3c3d					endif 
3c3d 3e 00			ld a, 0 
3c3f 32 25 f8			ld (cli_mvdot), a 
3c42 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c44				 
3c44			 
3c44			.dotgo: 
3c44			 
3c44			; move up type to on stack for parserv5 
3c44					FORTH_DSP 
3c44 cd dc 1d			call macro_forth_dsp 
3c47				endm 
# End of macro FORTH_DSP
3c47				;FORTH_DSP_VALUE  
3c47			 
3c47			if DEBUG_FORTH_DOT 
3c47				DMARK "DOT" 
3c47				CALLMONITOR 
3c47			endif	 
3c47			;		.print: 
3c47			 
3c47 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c48 23				inc hl   ; position to the actual value 
3c49 fe 01			cp DS_TYPE_STR 
3c4b 20 06			jr nz, .dotnum1  
3c4d			 
3c4d			; display string 
3c4d				FORTH_DSP_VALUE  
3c4d cd ff 1d			call macro_forth_dsp_value 
3c50				endm 
# End of macro FORTH_DSP_VALUE
3c50 eb				ex de,hl 
3c51 18 11			jr .dotwrite 
3c53			 
3c53			.dotnum1: 
3c53 fe 02			cp DS_TYPE_INUM 
3c55 20 0c			jr nz, .dotflot 
3c57			 
3c57			 
3c57			; display number 
3c57			 
3c57			;	push hl 
3c57			;	call clear_display 
3c57			;	pop hl 
3c57			 
3c57 5e				ld e, (hl) 
3c58 23				inc hl 
3c59 56				ld d, (hl) 
3c5a 21 1d ee			ld hl, scratch 
3c5d			if DEBUG_FORTH_DOT 
3c5d				DMARK "DT1" 
3c5d				CALLMONITOR 
3c5d			endif	 
3c5d			 
3c5d cd 16 11			call uitoa_16 
3c60 eb				ex de,hl 
3c61			 
3c61			if DEBUG_FORTH_DOT 
3c61				DMARK "DT2" 
3c61				CALLMONITOR 
3c61			endif	 
3c61			 
3c61			;	ld de, os_word_scratch 
3c61 18 01			jr .dotwrite 
3c63			 
3c63 00			.dotflot:   nop 
3c64			; TODO print floating point number 
3c64			 
3c64			.dotwrite:		 
3c64			 
3c64					; if c is set then set all '-' to spaces 
3c64					; need to also take into account .>  
3c64			 
3c64 3e 01				ld a, 1 
3c66 b9					cp c 
3c67 20 13				jr nz, .nodashswap 
3c69			 
3c69					; DE has the string to write, working with HL 
3c69			 
3c69 06 ff				ld b, 255 
3c6b d5					push de 
3c6c e1					pop hl 
3c6d			 
3c6d			if DEBUG_FORTH_DOT 
3c6d				DMARK "DT-" 
3c6d				CALLMONITOR 
3c6d			endif	 
3c6d 7e			.dashscan:	ld a, (hl) 
3c6e fe 00				cp 0 
3c70 28 0a				jr z, .nodashswap 
3c72 fe 2d				cp '-' 
3c74 20 03				jr nz, .dashskip 
3c76 3e 20				ld a, ' ' 
3c78 77					ld (hl), a 
3c79 23			.dashskip:	inc hl 
3c7a			if DEBUG_FORTH_DOT 
3c7a				DMARK "D-2" 
3c7a				CALLMONITOR 
3c7a			endif	 
3c7a 10 f1				djnz .dashscan 
3c7c			 
3c7c			if DEBUG_FORTH_DOT 
3c7c				DMARK "D-1" 
3c7c				CALLMONITOR 
3c7c			endif	 
3c7c			 
3c7c			.nodashswap: 
3c7c			 
3c7c e5					push hl   ; save string start in case we need to advance print 
3c7d			 
3c7d 3a 46 f8				ld a, (f_cursor_ptr) 
3c80 cd e8 0a				call str_at_display 
3c83 3a 24 f8				ld a,(cli_autodisplay) 
3c86 fe 00				cp 0 
3c88 28 03				jr z, .noupdate 
3c8a cd f8 0a						call update_display 
3c8d					.noupdate: 
3c8d			 
3c8d			 
3c8d					; see if we need to advance the print position 
3c8d			 
3c8d e1					pop hl   ; get back string 
3c8e			 
3c8e 3a 25 f8				ld a, (cli_mvdot) 
3c91			if DEBUG_FORTH_DOT 
3c91					ld e,a 
3c91				DMARK "D>1" 
3c91				CALLMONITOR 
3c91			endif	 
3c91 fe 00				cp 0 
3c93 28 0c				jr z, .noadv 
3c95					; yes, lets advance the print position 
3c95 3e 00				ld a, 0 
3c97 cd 72 11				call strlent 
3c9a 3a 46 f8				ld a, (f_cursor_ptr) 
3c9d 85					add a,l 
3c9e					;call addatohl 
3c9e					;ld a, l 
3c9e 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3ca1			 
3ca1			if DEBUG_FORTH_DOT 
3ca1				DMARK "D->" 
3ca1				CALLMONITOR 
3ca1			endif	 
3ca1			 
3ca1			.noadv:	 
3ca1			 
3ca1					if DEBUG_FORTH_DOT_WAIT 
3ca1							call next_page_prompt 
3ca1					endif	 
3ca1			; TODO this pop off the stack causes a crash. i dont know why 
3ca1			 
3ca1			 
3ca1			if DEBUG_FORTH_DOT 
3ca1				DMARK "DTh" 
3ca1				CALLMONITOR 
3ca1			endif	 
3ca1			 
3ca1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca1 cd ce 1e			call macro_forth_dsp_pop 
3ca4				endm 
# End of macro FORTH_DSP_POP
3ca4			 
3ca4			if DEBUG_FORTH_DOT 
3ca4				DMARK "DTi" 
3ca4				CALLMONITOR 
3ca4			endif	 
3ca4			 
3ca4			 
3ca4					NEXTW 
3ca4 c3 88 1f			jp macro_next 
3ca7				endm 
# End of macro NEXTW
3ca7			 
3ca7			.CLS: 
3ca7				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3ca7 35				db WORD_SYS_CORE+33             
3ca8 d4 3c			dw .DRAW            
3caa 04				db 3 + 1 
3cab .. 00			db "CLS",0              
3caf				endm 
# End of macro CWHEAD
3caf			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3caf					if DEBUG_FORTH_WORDS_KEY 
3caf						DMARK "CLS" 
3caf f5				push af  
3cb0 3a c4 3c			ld a, (.dmark)  
3cb3 32 77 fb			ld (debug_mark),a  
3cb6 3a c5 3c			ld a, (.dmark+1)  
3cb9 32 78 fb			ld (debug_mark+1),a  
3cbc 3a c6 3c			ld a, (.dmark+2)  
3cbf 32 79 fb			ld (debug_mark+2),a  
3cc2 18 03			jr .pastdmark  
3cc4 ..			.dmark: db "CLS"  
3cc7 f1			.pastdmark: pop af  
3cc8			endm  
# End of macro DMARK
3cc8						CALLMONITOR 
3cc8 cd 92 16			call break_point_state  
3ccb				endm  
# End of macro CALLMONITOR
3ccb					endif 
3ccb cd d5 0a				call clear_display 
3cce c3 e2 3d				jp .home		; and home cursor 
3cd1					NEXTW 
3cd1 c3 88 1f			jp macro_next 
3cd4				endm 
# End of macro NEXTW
3cd4			 
3cd4			.DRAW: 
3cd4				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3cd4 36				db WORD_SYS_CORE+34             
3cd5 ff 3c			dw .DUMP            
3cd7 05				db 4 + 1 
3cd8 .. 00			db "DRAW",0              
3cdd				endm 
# End of macro CWHEAD
3cdd			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3cdd					if DEBUG_FORTH_WORDS_KEY 
3cdd						DMARK "DRW" 
3cdd f5				push af  
3cde 3a f2 3c			ld a, (.dmark)  
3ce1 32 77 fb			ld (debug_mark),a  
3ce4 3a f3 3c			ld a, (.dmark+1)  
3ce7 32 78 fb			ld (debug_mark+1),a  
3cea 3a f4 3c			ld a, (.dmark+2)  
3ced 32 79 fb			ld (debug_mark+2),a  
3cf0 18 03			jr .pastdmark  
3cf2 ..			.dmark: db "DRW"  
3cf5 f1			.pastdmark: pop af  
3cf6			endm  
# End of macro DMARK
3cf6						CALLMONITOR 
3cf6 cd 92 16			call break_point_state  
3cf9				endm  
# End of macro CALLMONITOR
3cf9					endif 
3cf9 cd f8 0a				call update_display 
3cfc					NEXTW 
3cfc c3 88 1f			jp macro_next 
3cff				endm 
# End of macro NEXTW
3cff			 
3cff			.DUMP: 
3cff				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3cff 37				db WORD_SYS_CORE+35             
3d00 37 3d			dw .CDUMP            
3d02 05				db 4 + 1 
3d03 .. 00			db "DUMP",0              
3d08				endm 
# End of macro CWHEAD
3d08			; | DUMP ( x -- ) With address x display dump   | DONE 
3d08			; TODO pop address to use off of the stack 
3d08					if DEBUG_FORTH_WORDS_KEY 
3d08						DMARK "DUM" 
3d08 f5				push af  
3d09 3a 1d 3d			ld a, (.dmark)  
3d0c 32 77 fb			ld (debug_mark),a  
3d0f 3a 1e 3d			ld a, (.dmark+1)  
3d12 32 78 fb			ld (debug_mark+1),a  
3d15 3a 1f 3d			ld a, (.dmark+2)  
3d18 32 79 fb			ld (debug_mark+2),a  
3d1b 18 03			jr .pastdmark  
3d1d ..			.dmark: db "DUM"  
3d20 f1			.pastdmark: pop af  
3d21			endm  
# End of macro DMARK
3d21						CALLMONITOR 
3d21 cd 92 16			call break_point_state  
3d24				endm  
# End of macro CALLMONITOR
3d24					endif 
3d24 cd d5 0a				call clear_display 
3d27			 
3d27					; get address 
3d27			 
3d27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d27 cd 16 1e			call macro_dsp_valuehl 
3d2a				endm 
# End of macro FORTH_DSP_VALUEHL
3d2a				 
3d2a					; save it for cdump 
3d2a			 
3d2a 22 40 f1				ld (os_cur_ptr),hl 
3d2d			 
3d2d					; destroy value TOS 
3d2d			 
3d2d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d2d cd ce 1e			call macro_forth_dsp_pop 
3d30				endm 
# End of macro FORTH_DSP_POP
3d30			 
3d30 cd 9f 1a				call dumpcont	; skip old style of param parsing	 
3d33 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3d34					NEXTW 
3d34 c3 88 1f			jp macro_next 
3d37				endm 
# End of macro NEXTW
3d37			.CDUMP: 
3d37				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3d37 38				db WORD_SYS_CORE+36             
3d38 67 3d			dw .DAT            
3d3a 06				db 5 + 1 
3d3b .. 00			db "CDUMP",0              
3d41				endm 
# End of macro CWHEAD
3d41			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3d41					if DEBUG_FORTH_WORDS_KEY 
3d41						DMARK "CDP" 
3d41 f5				push af  
3d42 3a 56 3d			ld a, (.dmark)  
3d45 32 77 fb			ld (debug_mark),a  
3d48 3a 57 3d			ld a, (.dmark+1)  
3d4b 32 78 fb			ld (debug_mark+1),a  
3d4e 3a 58 3d			ld a, (.dmark+2)  
3d51 32 79 fb			ld (debug_mark+2),a  
3d54 18 03			jr .pastdmark  
3d56 ..			.dmark: db "CDP"  
3d59 f1			.pastdmark: pop af  
3d5a			endm  
# End of macro DMARK
3d5a						CALLMONITOR 
3d5a cd 92 16			call break_point_state  
3d5d				endm  
# End of macro CALLMONITOR
3d5d					endif 
3d5d cd d5 0a				call clear_display 
3d60 cd 9f 1a				call dumpcont	 
3d63 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3d64					NEXTW 
3d64 c3 88 1f			jp macro_next 
3d67				endm 
# End of macro NEXTW
3d67			 
3d67			 
3d67			 
3d67			 
3d67			.DAT: 
3d67				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3d67 3d				db WORD_SYS_CORE+41             
3d68 bd 3d			dw .HOME            
3d6a 03				db 2 + 1 
3d6b .. 00			db "AT",0              
3d6e				endm 
# End of macro CWHEAD
3d6e			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d6e					if DEBUG_FORTH_WORDS_KEY 
3d6e						DMARK "AT." 
3d6e f5				push af  
3d6f 3a 83 3d			ld a, (.dmark)  
3d72 32 77 fb			ld (debug_mark),a  
3d75 3a 84 3d			ld a, (.dmark+1)  
3d78 32 78 fb			ld (debug_mark+1),a  
3d7b 3a 85 3d			ld a, (.dmark+2)  
3d7e 32 79 fb			ld (debug_mark+2),a  
3d81 18 03			jr .pastdmark  
3d83 ..			.dmark: db "AT."  
3d86 f1			.pastdmark: pop af  
3d87			endm  
# End of macro DMARK
3d87						CALLMONITOR 
3d87 cd 92 16			call break_point_state  
3d8a				endm  
# End of macro CALLMONITOR
3d8a					endif 
3d8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d8a cd 16 1e			call macro_dsp_valuehl 
3d8d				endm 
# End of macro FORTH_DSP_VALUEHL
3d8d			 
3d8d			 
3d8d					; TODO save cursor row 
3d8d 7d					ld a,l 
3d8e fe 02				cp 2 
3d90 20 04				jr nz, .crow3 
3d92 3e 28				ld a, display_row_2 
3d94 18 12				jr .ccol1 
3d96 fe 03		.crow3:		cp 3 
3d98 20 04				jr nz, .crow4 
3d9a 3e 50				ld a, display_row_3 
3d9c 18 0a				jr .ccol1 
3d9e fe 04		.crow4:		cp 4 
3da0 20 04				jr nz, .crow1 
3da2 3e 78				ld a, display_row_4 
3da4 18 02				jr .ccol1 
3da6 3e 00		.crow1:		ld a,display_row_1 
3da8 f5			.ccol1:		push af			; got row offset 
3da9 6f					ld l,a 
3daa 26 00				ld h,0 
3dac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dac cd ce 1e			call macro_forth_dsp_pop 
3daf				endm 
# End of macro FORTH_DSP_POP
3daf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3daf cd 16 1e			call macro_dsp_valuehl 
3db2				endm 
# End of macro FORTH_DSP_VALUEHL
3db2					; TODO save cursor col 
3db2 f1					pop af 
3db3 85					add l		; add col offset 
3db4 32 46 f8				ld (f_cursor_ptr), a 
3db7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db7 cd ce 1e			call macro_forth_dsp_pop 
3dba				endm 
# End of macro FORTH_DSP_POP
3dba			 
3dba					; calculate  
3dba			 
3dba					NEXTW 
3dba c3 88 1f			jp macro_next 
3dbd				endm 
# End of macro NEXTW
3dbd			 
3dbd			 
3dbd			.HOME: 
3dbd				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3dbd 41				db WORD_SYS_CORE+45             
3dbe ea 3d			dw .SPACE            
3dc0 05				db 4 + 1 
3dc1 .. 00			db "HOME",0              
3dc6				endm 
# End of macro CWHEAD
3dc6			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3dc6					if DEBUG_FORTH_WORDS_KEY 
3dc6						DMARK "HOM" 
3dc6 f5				push af  
3dc7 3a db 3d			ld a, (.dmark)  
3dca 32 77 fb			ld (debug_mark),a  
3dcd 3a dc 3d			ld a, (.dmark+1)  
3dd0 32 78 fb			ld (debug_mark+1),a  
3dd3 3a dd 3d			ld a, (.dmark+2)  
3dd6 32 79 fb			ld (debug_mark+2),a  
3dd9 18 03			jr .pastdmark  
3ddb ..			.dmark: db "HOM"  
3dde f1			.pastdmark: pop af  
3ddf			endm  
# End of macro DMARK
3ddf						CALLMONITOR 
3ddf cd 92 16			call break_point_state  
3de2				endm  
# End of macro CALLMONITOR
3de2					endif 
3de2 3e 00		.home:		ld a, 0		; and home cursor 
3de4 32 46 f8				ld (f_cursor_ptr), a 
3de7					NEXTW 
3de7 c3 88 1f			jp macro_next 
3dea				endm 
# End of macro NEXTW
3dea			 
3dea			 
3dea			.SPACE: 
3dea				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3dea 46				db WORD_SYS_CORE+50             
3deb 18 3e			dw .SPACES            
3ded 03				db 2 + 1 
3dee .. 00			db "BL",0              
3df1				endm 
# End of macro CWHEAD
3df1			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3df1					if DEBUG_FORTH_WORDS_KEY 
3df1						DMARK "BL." 
3df1 f5				push af  
3df2 3a 06 3e			ld a, (.dmark)  
3df5 32 77 fb			ld (debug_mark),a  
3df8 3a 07 3e			ld a, (.dmark+1)  
3dfb 32 78 fb			ld (debug_mark+1),a  
3dfe 3a 08 3e			ld a, (.dmark+2)  
3e01 32 79 fb			ld (debug_mark+2),a  
3e04 18 03			jr .pastdmark  
3e06 ..			.dmark: db "BL."  
3e09 f1			.pastdmark: pop af  
3e0a			endm  
# End of macro DMARK
3e0a						CALLMONITOR 
3e0a cd 92 16			call break_point_state  
3e0d				endm  
# End of macro CALLMONITOR
3e0d					endif 
3e0d 21 16 3e				ld hl, .blstr 
3e10 cd 8d 1c				call forth_push_str 
3e13					 
3e13				       NEXTW 
3e13 c3 88 1f			jp macro_next 
3e16				endm 
# End of macro NEXTW
3e16			 
3e16 .. 00		.blstr: db " ", 0 
3e18			 
3e18			.SPACES: 
3e18				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3e18 47				db WORD_SYS_CORE+51             
3e19 b3 3e			dw .SCROLL            
3e1b 07				db 6 + 1 
3e1c .. 00			db "SPACES",0              
3e23				endm 
# End of macro CWHEAD
3e23			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3e23					if DEBUG_FORTH_WORDS_KEY 
3e23						DMARK "SPS" 
3e23 f5				push af  
3e24 3a 38 3e			ld a, (.dmark)  
3e27 32 77 fb			ld (debug_mark),a  
3e2a 3a 39 3e			ld a, (.dmark+1)  
3e2d 32 78 fb			ld (debug_mark+1),a  
3e30 3a 3a 3e			ld a, (.dmark+2)  
3e33 32 79 fb			ld (debug_mark+2),a  
3e36 18 03			jr .pastdmark  
3e38 ..			.dmark: db "SPS"  
3e3b f1			.pastdmark: pop af  
3e3c			endm  
# End of macro DMARK
3e3c						CALLMONITOR 
3e3c cd 92 16			call break_point_state  
3e3f				endm  
# End of macro CALLMONITOR
3e3f					endif 
3e3f			 
3e3f			 
3e3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e3f cd 16 1e			call macro_dsp_valuehl 
3e42				endm 
# End of macro FORTH_DSP_VALUEHL
3e42			 
3e42			;		push hl    ; u 
3e42					if DEBUG_FORTH_WORDS 
3e42						DMARK "SPA" 
3e42 f5				push af  
3e43 3a 57 3e			ld a, (.dmark)  
3e46 32 77 fb			ld (debug_mark),a  
3e49 3a 58 3e			ld a, (.dmark+1)  
3e4c 32 78 fb			ld (debug_mark+1),a  
3e4f 3a 59 3e			ld a, (.dmark+2)  
3e52 32 79 fb			ld (debug_mark+2),a  
3e55 18 03			jr .pastdmark  
3e57 ..			.dmark: db "SPA"  
3e5a f1			.pastdmark: pop af  
3e5b			endm  
# End of macro DMARK
3e5b						CALLMONITOR 
3e5b cd 92 16			call break_point_state  
3e5e				endm  
# End of macro CALLMONITOR
3e5e					endif 
3e5e			 
3e5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e5e cd ce 1e			call macro_forth_dsp_pop 
3e61				endm 
# End of macro FORTH_DSP_POP
3e61			;		pop hl 
3e61 4d					ld c, l 
3e62 06 00				ld b, 0 
3e64 21 1d ee				ld hl, scratch  
3e67			 
3e67					if DEBUG_FORTH_WORDS 
3e67						DMARK "SP2" 
3e67 f5				push af  
3e68 3a 7c 3e			ld a, (.dmark)  
3e6b 32 77 fb			ld (debug_mark),a  
3e6e 3a 7d 3e			ld a, (.dmark+1)  
3e71 32 78 fb			ld (debug_mark+1),a  
3e74 3a 7e 3e			ld a, (.dmark+2)  
3e77 32 79 fb			ld (debug_mark+2),a  
3e7a 18 03			jr .pastdmark  
3e7c ..			.dmark: db "SP2"  
3e7f f1			.pastdmark: pop af  
3e80			endm  
# End of macro DMARK
3e80						CALLMONITOR 
3e80 cd 92 16			call break_point_state  
3e83				endm  
# End of macro CALLMONITOR
3e83					endif 
3e83 3e 20				ld a, ' ' 
3e85 c5			.spaces1:	push bc 
3e86 77					ld (hl),a 
3e87 23					inc hl 
3e88 c1					pop bc 
3e89 10 fa				djnz .spaces1 
3e8b 3e 00				ld a,0 
3e8d 77					ld (hl),a 
3e8e 21 1d ee				ld hl, scratch 
3e91					if DEBUG_FORTH_WORDS 
3e91						DMARK "SP3" 
3e91 f5				push af  
3e92 3a a6 3e			ld a, (.dmark)  
3e95 32 77 fb			ld (debug_mark),a  
3e98 3a a7 3e			ld a, (.dmark+1)  
3e9b 32 78 fb			ld (debug_mark+1),a  
3e9e 3a a8 3e			ld a, (.dmark+2)  
3ea1 32 79 fb			ld (debug_mark+2),a  
3ea4 18 03			jr .pastdmark  
3ea6 ..			.dmark: db "SP3"  
3ea9 f1			.pastdmark: pop af  
3eaa			endm  
# End of macro DMARK
3eaa						CALLMONITOR 
3eaa cd 92 16			call break_point_state  
3ead				endm  
# End of macro CALLMONITOR
3ead					endif 
3ead cd 88 1d				call forth_apush 
3eb0			 
3eb0				       NEXTW 
3eb0 c3 88 1f			jp macro_next 
3eb3				endm 
# End of macro NEXTW
3eb3			 
3eb3			 
3eb3			 
3eb3			.SCROLL: 
3eb3				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3eb3 53				db WORD_SYS_CORE+63             
3eb4 e0 3e			dw .SCROLLD            
3eb6 07				db 6 + 1 
3eb7 .. 00			db "SCROLL",0              
3ebe				endm 
# End of macro CWHEAD
3ebe			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3ebe					if DEBUG_FORTH_WORDS_KEY 
3ebe						DMARK "SCR" 
3ebe f5				push af  
3ebf 3a d3 3e			ld a, (.dmark)  
3ec2 32 77 fb			ld (debug_mark),a  
3ec5 3a d4 3e			ld a, (.dmark+1)  
3ec8 32 78 fb			ld (debug_mark+1),a  
3ecb 3a d5 3e			ld a, (.dmark+2)  
3ece 32 79 fb			ld (debug_mark+2),a  
3ed1 18 03			jr .pastdmark  
3ed3 ..			.dmark: db "SCR"  
3ed6 f1			.pastdmark: pop af  
3ed7			endm  
# End of macro DMARK
3ed7						CALLMONITOR 
3ed7 cd 92 16			call break_point_state  
3eda				endm  
# End of macro CALLMONITOR
3eda					endif 
3eda			 
3eda cd 97 0a			call scroll_up 
3edd			;	call update_display 
3edd			 
3edd					NEXTW 
3edd c3 88 1f			jp macro_next 
3ee0				endm 
# End of macro NEXTW
3ee0			 
3ee0			 
3ee0			 
3ee0			;		; get dir 
3ee0			; 
3ee0			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee0			; 
3ee0			;		push hl 
3ee0			; 
3ee0			;		; destroy value TOS 
3ee0			; 
3ee0			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee0			; 
3ee0			;		; get count 
3ee0			; 
3ee0			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee0			; 
3ee0			;		push hl 
3ee0			; 
3ee0			;		; destroy value TOS 
3ee0			; 
3ee0			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee0			; 
3ee0			;		; one value on hl get other one back 
3ee0			; 
3ee0			;		pop bc    ; count 
3ee0			; 
3ee0			;		pop de   ; dir 
3ee0			; 
3ee0			; 
3ee0			;		ld b, c 
3ee0			; 
3ee0			;.scrolldir:     push bc 
3ee0			;		push de 
3ee0			; 
3ee0			;		ld a, 0 
3ee0			;		cp e 
3ee0			;		jr z, .scrollup  
3ee0			;		call scroll_down 
3ee0			;		jr .scrollnext 
3ee0			;.scrollup:	call scroll_up 
3ee0			; 
3ee0			;		 
3ee0			;.scrollnext: 
3ee0			;		pop de 
3ee0			;		pop bc 
3ee0			;		djnz .scrolldir 
3ee0			; 
3ee0			; 
3ee0			; 
3ee0			; 
3ee0			; 
3ee0			;		NEXTW 
3ee0			 
3ee0			.SCROLLD: 
3ee0				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ee0 53				db WORD_SYS_CORE+63             
3ee1 0e 3f			dw .ATQ            
3ee3 08				db 7 + 1 
3ee4 .. 00			db "SCROLLD",0              
3eec				endm 
# End of macro CWHEAD
3eec			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3eec					if DEBUG_FORTH_WORDS_KEY 
3eec						DMARK "SCD" 
3eec f5				push af  
3eed 3a 01 3f			ld a, (.dmark)  
3ef0 32 77 fb			ld (debug_mark),a  
3ef3 3a 02 3f			ld a, (.dmark+1)  
3ef6 32 78 fb			ld (debug_mark+1),a  
3ef9 3a 03 3f			ld a, (.dmark+2)  
3efc 32 79 fb			ld (debug_mark+2),a  
3eff 18 03			jr .pastdmark  
3f01 ..			.dmark: db "SCD"  
3f04 f1			.pastdmark: pop af  
3f05			endm  
# End of macro DMARK
3f05						CALLMONITOR 
3f05 cd 92 16			call break_point_state  
3f08				endm  
# End of macro CALLMONITOR
3f08					endif 
3f08			 
3f08 cd bb 0a			call scroll_down 
3f0b			;	call update_display 
3f0b			 
3f0b					NEXTW 
3f0b c3 88 1f			jp macro_next 
3f0e				endm 
# End of macro NEXTW
3f0e			 
3f0e			 
3f0e			.ATQ: 
3f0e				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3f0e 62				db WORD_SYS_CORE+78             
3f0f 6c 3f			dw .AUTODSP            
3f11 04				db 3 + 1 
3f12 .. 00			db "AT@",0              
3f16				endm 
# End of macro CWHEAD
3f16			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3f16					if DEBUG_FORTH_WORDS_KEY 
3f16						DMARK "ATA" 
3f16 f5				push af  
3f17 3a 2b 3f			ld a, (.dmark)  
3f1a 32 77 fb			ld (debug_mark),a  
3f1d 3a 2c 3f			ld a, (.dmark+1)  
3f20 32 78 fb			ld (debug_mark+1),a  
3f23 3a 2d 3f			ld a, (.dmark+2)  
3f26 32 79 fb			ld (debug_mark+2),a  
3f29 18 03			jr .pastdmark  
3f2b ..			.dmark: db "ATA"  
3f2e f1			.pastdmark: pop af  
3f2f			endm  
# End of macro DMARK
3f2f						CALLMONITOR 
3f2f cd 92 16			call break_point_state  
3f32				endm  
# End of macro CALLMONITOR
3f32					endif 
3f32			 
3f32			 
3f32					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f32 cd 16 1e			call macro_dsp_valuehl 
3f35				endm 
# End of macro FORTH_DSP_VALUEHL
3f35			 
3f35					; TODO save cursor row 
3f35 7d					ld a,l 
3f36 fe 02				cp 2 
3f38 20 04				jr nz, .crow3aq 
3f3a 3e 28				ld a, display_row_2 
3f3c 18 12				jr .ccol1aq 
3f3e fe 03		.crow3aq:		cp 3 
3f40 20 04				jr nz, .crow4aq 
3f42 3e 50				ld a, display_row_3 
3f44 18 0a				jr .ccol1aq 
3f46 fe 04		.crow4aq:		cp 4 
3f48 20 04				jr nz, .crow1aq 
3f4a 3e 78				ld a, display_row_4 
3f4c 18 02				jr .ccol1aq 
3f4e 3e 00		.crow1aq:		ld a,display_row_1 
3f50 f5			.ccol1aq:		push af			; got row offset 
3f51 6f					ld l,a 
3f52 26 00				ld h,0 
3f54					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f54 cd ce 1e			call macro_forth_dsp_pop 
3f57				endm 
# End of macro FORTH_DSP_POP
3f57					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f57 cd 16 1e			call macro_dsp_valuehl 
3f5a				endm 
# End of macro FORTH_DSP_VALUEHL
3f5a					; TODO save cursor col 
3f5a f1					pop af 
3f5b 85					add l		; add col offset 
3f5c			 
3f5c					; add current frame buffer address 
3f5c 2a d8 f8				ld hl, (display_fb_active) 
3f5f cd 09 0d				call addatohl 
3f62			 
3f62			 
3f62			 
3f62			 
3f62					; get char frame buffer location offset in hl 
3f62			 
3f62 7e					ld a,(hl) 
3f63 26 00				ld h, 0 
3f65 6f					ld l, a 
3f66			 
3f66 cd 1f 1c				call forth_push_numhl 
3f69			 
3f69			 
3f69					NEXTW 
3f69 c3 88 1f			jp macro_next 
3f6c				endm 
# End of macro NEXTW
3f6c			 
3f6c			.AUTODSP: 
3f6c				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3f6c 63				db WORD_SYS_CORE+79             
3f6d 82 3f			dw .MENU            
3f6f 05				db 4 + 1 
3f70 .. 00			db "ADSP",0              
3f75				endm 
# End of macro CWHEAD
3f75			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f75			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f75			 
3f75					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f75 cd 16 1e			call macro_dsp_valuehl 
3f78				endm 
# End of macro FORTH_DSP_VALUEHL
3f78			 
3f78			;		push hl 
3f78			 
3f78					; destroy value TOS 
3f78			 
3f78					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f78 cd ce 1e			call macro_forth_dsp_pop 
3f7b				endm 
# End of macro FORTH_DSP_POP
3f7b			 
3f7b			;		pop hl 
3f7b			 
3f7b 7d					ld a,l 
3f7c 32 24 f8				ld (cli_autodisplay), a 
3f7f				       NEXTW 
3f7f c3 88 1f			jp macro_next 
3f82				endm 
# End of macro NEXTW
3f82			 
3f82			.MENU: 
3f82				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f82 70				db WORD_SYS_CORE+92             
3f83 2b 40			dw .ENDDISPLAY            
3f85 05				db 4 + 1 
3f86 .. 00			db "MENU",0              
3f8b				endm 
# End of macro CWHEAD
3f8b			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f8b			 
3f8b			;		; get number of items on the stack 
3f8b			; 
3f8b				 
3f8b					FORTH_DSP_VALUEHL 
3f8b cd 16 1e			call macro_dsp_valuehl 
3f8e				endm 
# End of macro FORTH_DSP_VALUEHL
3f8e				 
3f8e					if DEBUG_FORTH_WORDS_KEY 
3f8e						DMARK "MNU" 
3f8e f5				push af  
3f8f 3a a3 3f			ld a, (.dmark)  
3f92 32 77 fb			ld (debug_mark),a  
3f95 3a a4 3f			ld a, (.dmark+1)  
3f98 32 78 fb			ld (debug_mark+1),a  
3f9b 3a a5 3f			ld a, (.dmark+2)  
3f9e 32 79 fb			ld (debug_mark+2),a  
3fa1 18 03			jr .pastdmark  
3fa3 ..			.dmark: db "MNU"  
3fa6 f1			.pastdmark: pop af  
3fa7			endm  
# End of macro DMARK
3fa7						CALLMONITOR 
3fa7 cd 92 16			call break_point_state  
3faa				endm  
# End of macro CALLMONITOR
3faa					endif 
3faa			 
3faa 45					ld b, l	 
3fab 05					dec b 
3fac			 
3fac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fac cd ce 1e			call macro_forth_dsp_pop 
3faf				endm 
# End of macro FORTH_DSP_POP
3faf			 
3faf			 
3faf					; go directly through the stack to pluck out the string pointers and build an array 
3faf			 
3faf			;		FORTH_DSP 
3faf			 
3faf					; hl contains top most stack item 
3faf				 
3faf 11 1d ee				ld de, scratch 
3fb2			 
3fb2			.mbuild: 
3fb2			 
3fb2					FORTH_DSP_VALUEHL 
3fb2 cd 16 1e			call macro_dsp_valuehl 
3fb5				endm 
# End of macro FORTH_DSP_VALUEHL
3fb5			 
3fb5					if DEBUG_FORTH_WORDS 
3fb5						DMARK "MN3" 
3fb5 f5				push af  
3fb6 3a ca 3f			ld a, (.dmark)  
3fb9 32 77 fb			ld (debug_mark),a  
3fbc 3a cb 3f			ld a, (.dmark+1)  
3fbf 32 78 fb			ld (debug_mark+1),a  
3fc2 3a cc 3f			ld a, (.dmark+2)  
3fc5 32 79 fb			ld (debug_mark+2),a  
3fc8 18 03			jr .pastdmark  
3fca ..			.dmark: db "MN3"  
3fcd f1			.pastdmark: pop af  
3fce			endm  
# End of macro DMARK
3fce						CALLMONITOR 
3fce cd 92 16			call break_point_state  
3fd1				endm  
# End of macro CALLMONITOR
3fd1					endif 
3fd1 eb					ex de, hl 
3fd2 73					ld (hl), e 
3fd3 23					inc hl 
3fd4 72					ld (hl), d 
3fd5 23					inc hl 
3fd6 eb					ex de, hl 
3fd7			 
3fd7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fd7 cd ce 1e			call macro_forth_dsp_pop 
3fda				endm 
# End of macro FORTH_DSP_POP
3fda			 
3fda 10 d6				djnz .mbuild 
3fdc			 
3fdc					; done add term 
3fdc			 
3fdc eb					ex de, hl 
3fdd 36 00				ld (hl), 0 
3fdf 23					inc hl 
3fe0 36 00				ld (hl), 0 
3fe2			 
3fe2				 
3fe2					 
3fe2 21 1d ee				ld hl, scratch 
3fe5			 
3fe5					if DEBUG_FORTH_WORDS 
3fe5						DMARK "MNx" 
3fe5 f5				push af  
3fe6 3a fa 3f			ld a, (.dmark)  
3fe9 32 77 fb			ld (debug_mark),a  
3fec 3a fb 3f			ld a, (.dmark+1)  
3fef 32 78 fb			ld (debug_mark+1),a  
3ff2 3a fc 3f			ld a, (.dmark+2)  
3ff5 32 79 fb			ld (debug_mark+2),a  
3ff8 18 03			jr .pastdmark  
3ffa ..			.dmark: db "MNx"  
3ffd f1			.pastdmark: pop af  
3ffe			endm  
# End of macro DMARK
3ffe						CALLMONITOR 
3ffe cd 92 16			call break_point_state  
4001				endm  
# End of macro CALLMONITOR
4001					endif 
4001			 
4001			 
4001			 
4001 3e 00				ld a, 0 
4003 cd 06 0b				call menu 
4006			 
4006			 
4006 6f					ld l, a 
4007 26 00				ld h, 0 
4009			 
4009					if DEBUG_FORTH_WORDS 
4009						DMARK "MNr" 
4009 f5				push af  
400a 3a 1e 40			ld a, (.dmark)  
400d 32 77 fb			ld (debug_mark),a  
4010 3a 1f 40			ld a, (.dmark+1)  
4013 32 78 fb			ld (debug_mark+1),a  
4016 3a 20 40			ld a, (.dmark+2)  
4019 32 79 fb			ld (debug_mark+2),a  
401c 18 03			jr .pastdmark  
401e ..			.dmark: db "MNr"  
4021 f1			.pastdmark: pop af  
4022			endm  
# End of macro DMARK
4022						CALLMONITOR 
4022 cd 92 16			call break_point_state  
4025				endm  
# End of macro CALLMONITOR
4025					endif 
4025			 
4025 cd 1f 1c				call forth_push_numhl 
4028			 
4028			 
4028			 
4028			 
4028				       NEXTW 
4028 c3 88 1f			jp macro_next 
402b				endm 
# End of macro NEXTW
402b			 
402b			 
402b			.ENDDISPLAY: 
402b			 
402b			; eof 
# End of file forth_words_display.asm
402b			include "forth_words_str.asm" 
402b			 
402b			; | ## String Words 
402b			 
402b			.PTR:   
402b			 
402b				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
402b 48				db WORD_SYS_CORE+52             
402c 58 40			dw .STYPE            
402e 04				db 3 + 1 
402f .. 00			db "PTR",0              
4033				endm 
# End of macro CWHEAD
4033			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4033			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4033			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4033			 
4033					if DEBUG_FORTH_WORDS_KEY 
4033						DMARK "PTR" 
4033 f5				push af  
4034 3a 48 40			ld a, (.dmark)  
4037 32 77 fb			ld (debug_mark),a  
403a 3a 49 40			ld a, (.dmark+1)  
403d 32 78 fb			ld (debug_mark+1),a  
4040 3a 4a 40			ld a, (.dmark+2)  
4043 32 79 fb			ld (debug_mark+2),a  
4046 18 03			jr .pastdmark  
4048 ..			.dmark: db "PTR"  
404b f1			.pastdmark: pop af  
404c			endm  
# End of macro DMARK
404c						CALLMONITOR 
404c cd 92 16			call break_point_state  
404f				endm  
# End of macro CALLMONITOR
404f					endif 
404f					FORTH_DSP_VALUEHL 
404f cd 16 1e			call macro_dsp_valuehl 
4052				endm 
# End of macro FORTH_DSP_VALUEHL
4052 cd 1f 1c				call forth_push_numhl 
4055			 
4055			 
4055					NEXTW 
4055 c3 88 1f			jp macro_next 
4058				endm 
# End of macro NEXTW
4058			.STYPE: 
4058				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4058 48				db WORD_SYS_CORE+52             
4059 a7 40			dw .UPPER            
405b 06				db 5 + 1 
405c .. 00			db "STYPE",0              
4062				endm 
# End of macro CWHEAD
4062			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4062					if DEBUG_FORTH_WORDS_KEY 
4062						DMARK "STY" 
4062 f5				push af  
4063 3a 77 40			ld a, (.dmark)  
4066 32 77 fb			ld (debug_mark),a  
4069 3a 78 40			ld a, (.dmark+1)  
406c 32 78 fb			ld (debug_mark+1),a  
406f 3a 79 40			ld a, (.dmark+2)  
4072 32 79 fb			ld (debug_mark+2),a  
4075 18 03			jr .pastdmark  
4077 ..			.dmark: db "STY"  
407a f1			.pastdmark: pop af  
407b			endm  
# End of macro DMARK
407b						CALLMONITOR 
407b cd 92 16			call break_point_state  
407e				endm  
# End of macro CALLMONITOR
407e					endif 
407e					FORTH_DSP 
407e cd dc 1d			call macro_forth_dsp 
4081				endm 
# End of macro FORTH_DSP
4081					;v5 FORTH_DSP_VALUE 
4081			 
4081 7e					ld a, (hl) 
4082			 
4082 f5					push af 
4083			 
4083			; Dont destroy TOS		FORTH_DSP_POP 
4083			 
4083 f1					pop af 
4084			 
4084 fe 01				cp DS_TYPE_STR 
4086 28 09				jr z, .typestr 
4088			 
4088 fe 02				cp DS_TYPE_INUM 
408a 28 0a				jr z, .typeinum 
408c			 
408c 21 a5 40				ld hl, .tna 
408f 18 0a				jr .tpush 
4091			 
4091 21 a1 40		.typestr:	ld hl, .tstr 
4094 18 05				jr .tpush 
4096 21 a3 40		.typeinum:	ld hl, .tinum 
4099 18 00				jr .tpush 
409b			 
409b			.tpush: 
409b			 
409b cd 8d 1c				call forth_push_str 
409e			 
409e					NEXTW 
409e c3 88 1f			jp macro_next 
40a1				endm 
# End of macro NEXTW
40a1 .. 00		.tstr:	db "s",0 
40a3 .. 00		.tinum:  db "i",0 
40a5 .. 00		.tna:   db "?", 0 
40a7			 
40a7			 
40a7			.UPPER: 
40a7				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
40a7 48				db WORD_SYS_CORE+52             
40a8 e2 40			dw .LOWER            
40aa 06				db 5 + 1 
40ab .. 00			db "UPPER",0              
40b1				endm 
# End of macro CWHEAD
40b1			; | UPPER ( s -- s ) Upper case string s  | DONE 
40b1					if DEBUG_FORTH_WORDS_KEY 
40b1						DMARK "UPR" 
40b1 f5				push af  
40b2 3a c6 40			ld a, (.dmark)  
40b5 32 77 fb			ld (debug_mark),a  
40b8 3a c7 40			ld a, (.dmark+1)  
40bb 32 78 fb			ld (debug_mark+1),a  
40be 3a c8 40			ld a, (.dmark+2)  
40c1 32 79 fb			ld (debug_mark+2),a  
40c4 18 03			jr .pastdmark  
40c6 ..			.dmark: db "UPR"  
40c9 f1			.pastdmark: pop af  
40ca			endm  
# End of macro DMARK
40ca						CALLMONITOR 
40ca cd 92 16			call break_point_state  
40cd				endm  
# End of macro CALLMONITOR
40cd					endif 
40cd			 
40cd					FORTH_DSP 
40cd cd dc 1d			call macro_forth_dsp 
40d0				endm 
# End of macro FORTH_DSP
40d0					 
40d0			; TODO check is string type 
40d0			 
40d0					FORTH_DSP_VALUEHL 
40d0 cd 16 1e			call macro_dsp_valuehl 
40d3				endm 
# End of macro FORTH_DSP_VALUEHL
40d3			; get pointer to string in hl 
40d3			 
40d3 7e			.toup:		ld a, (hl) 
40d4 fe 00				cp 0 
40d6 28 07				jr z, .toupdone 
40d8			 
40d8 cd 76 10				call to_upper 
40db			 
40db 77					ld (hl), a 
40dc 23					inc hl 
40dd 18 f4				jr .toup 
40df			 
40df					 
40df			 
40df			 
40df			; for each char convert to upper 
40df					 
40df			.toupdone: 
40df			 
40df			 
40df					NEXTW 
40df c3 88 1f			jp macro_next 
40e2				endm 
# End of macro NEXTW
40e2			.LOWER: 
40e2				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
40e2 48				db WORD_SYS_CORE+52             
40e3 1d 41			dw .TCASE            
40e5 06				db 5 + 1 
40e6 .. 00			db "LOWER",0              
40ec				endm 
# End of macro CWHEAD
40ec			; | LOWER ( s -- s ) Lower case string s  | DONE 
40ec					if DEBUG_FORTH_WORDS_KEY 
40ec						DMARK "LWR" 
40ec f5				push af  
40ed 3a 01 41			ld a, (.dmark)  
40f0 32 77 fb			ld (debug_mark),a  
40f3 3a 02 41			ld a, (.dmark+1)  
40f6 32 78 fb			ld (debug_mark+1),a  
40f9 3a 03 41			ld a, (.dmark+2)  
40fc 32 79 fb			ld (debug_mark+2),a  
40ff 18 03			jr .pastdmark  
4101 ..			.dmark: db "LWR"  
4104 f1			.pastdmark: pop af  
4105			endm  
# End of macro DMARK
4105						CALLMONITOR 
4105 cd 92 16			call break_point_state  
4108				endm  
# End of macro CALLMONITOR
4108					endif 
4108			 
4108					FORTH_DSP 
4108 cd dc 1d			call macro_forth_dsp 
410b				endm 
# End of macro FORTH_DSP
410b					 
410b			; TODO check is string type 
410b			 
410b					FORTH_DSP_VALUEHL 
410b cd 16 1e			call macro_dsp_valuehl 
410e				endm 
# End of macro FORTH_DSP_VALUEHL
410e			; get pointer to string in hl 
410e			 
410e 7e			.tolow:		ld a, (hl) 
410f fe 00				cp 0 
4111 28 07				jr z, .tolowdone 
4113			 
4113 cd 7f 10				call to_lower 
4116			 
4116 77					ld (hl), a 
4117 23					inc hl 
4118 18 f4				jr .tolow 
411a			 
411a					 
411a			 
411a			 
411a			; for each char convert to low 
411a					 
411a			.tolowdone: 
411a					NEXTW 
411a c3 88 1f			jp macro_next 
411d				endm 
# End of macro NEXTW
411d			.TCASE: 
411d				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
411d 48				db WORD_SYS_CORE+52             
411e 53 42			dw .SUBSTR            
4120 06				db 5 + 1 
4121 .. 00			db "TCASE",0              
4127				endm 
# End of macro CWHEAD
4127			; | TCASE ( s -- s ) Title case string s  | DONE 
4127					if DEBUG_FORTH_WORDS_KEY 
4127						DMARK "TCS" 
4127 f5				push af  
4128 3a 3c 41			ld a, (.dmark)  
412b 32 77 fb			ld (debug_mark),a  
412e 3a 3d 41			ld a, (.dmark+1)  
4131 32 78 fb			ld (debug_mark+1),a  
4134 3a 3e 41			ld a, (.dmark+2)  
4137 32 79 fb			ld (debug_mark+2),a  
413a 18 03			jr .pastdmark  
413c ..			.dmark: db "TCS"  
413f f1			.pastdmark: pop af  
4140			endm  
# End of macro DMARK
4140						CALLMONITOR 
4140 cd 92 16			call break_point_state  
4143				endm  
# End of macro CALLMONITOR
4143					endif 
4143			 
4143					FORTH_DSP 
4143 cd dc 1d			call macro_forth_dsp 
4146				endm 
# End of macro FORTH_DSP
4146					 
4146			; TODO check is string type 
4146			 
4146					FORTH_DSP_VALUEHL 
4146 cd 16 1e			call macro_dsp_valuehl 
4149				endm 
# End of macro FORTH_DSP_VALUEHL
4149			; get pointer to string in hl 
4149			 
4149					if DEBUG_FORTH_WORDS 
4149						DMARK "TC1" 
4149 f5				push af  
414a 3a 5e 41			ld a, (.dmark)  
414d 32 77 fb			ld (debug_mark),a  
4150 3a 5f 41			ld a, (.dmark+1)  
4153 32 78 fb			ld (debug_mark+1),a  
4156 3a 60 41			ld a, (.dmark+2)  
4159 32 79 fb			ld (debug_mark+2),a  
415c 18 03			jr .pastdmark  
415e ..			.dmark: db "TC1"  
4161 f1			.pastdmark: pop af  
4162			endm  
# End of macro DMARK
4162						CALLMONITOR 
4162 cd 92 16			call break_point_state  
4165				endm  
# End of macro CALLMONITOR
4165					endif 
4165			 
4165					; first time in turn to upper case first char 
4165			 
4165 7e					ld a, (hl) 
4166 c3 f0 41				jp .totsiptou 
4169			 
4169			 
4169 7e			.tot:		ld a, (hl) 
416a fe 00				cp 0 
416c ca 34 42				jp z, .totdone 
416f			 
416f					if DEBUG_FORTH_WORDS 
416f						DMARK "TC2" 
416f f5				push af  
4170 3a 84 41			ld a, (.dmark)  
4173 32 77 fb			ld (debug_mark),a  
4176 3a 85 41			ld a, (.dmark+1)  
4179 32 78 fb			ld (debug_mark+1),a  
417c 3a 86 41			ld a, (.dmark+2)  
417f 32 79 fb			ld (debug_mark+2),a  
4182 18 03			jr .pastdmark  
4184 ..			.dmark: db "TC2"  
4187 f1			.pastdmark: pop af  
4188			endm  
# End of macro DMARK
4188						CALLMONITOR 
4188 cd 92 16			call break_point_state  
418b				endm  
# End of macro CALLMONITOR
418b					endif 
418b					; check to see if current char is a space 
418b			 
418b fe 20				cp ' ' 
418d 28 21				jr z, .totsp 
418f cd 7f 10				call to_lower 
4192					if DEBUG_FORTH_WORDS 
4192						DMARK "TC3" 
4192 f5				push af  
4193 3a a7 41			ld a, (.dmark)  
4196 32 77 fb			ld (debug_mark),a  
4199 3a a8 41			ld a, (.dmark+1)  
419c 32 78 fb			ld (debug_mark+1),a  
419f 3a a9 41			ld a, (.dmark+2)  
41a2 32 79 fb			ld (debug_mark+2),a  
41a5 18 03			jr .pastdmark  
41a7 ..			.dmark: db "TC3"  
41aa f1			.pastdmark: pop af  
41ab			endm  
# End of macro DMARK
41ab						CALLMONITOR 
41ab cd 92 16			call break_point_state  
41ae				endm  
# End of macro CALLMONITOR
41ae					endif 
41ae 18 63				jr .totnxt 
41b0			 
41b0			.totsp:         ; on a space, find next char which should be upper 
41b0			 
41b0					if DEBUG_FORTH_WORDS 
41b0						DMARK "TC4" 
41b0 f5				push af  
41b1 3a c5 41			ld a, (.dmark)  
41b4 32 77 fb			ld (debug_mark),a  
41b7 3a c6 41			ld a, (.dmark+1)  
41ba 32 78 fb			ld (debug_mark+1),a  
41bd 3a c7 41			ld a, (.dmark+2)  
41c0 32 79 fb			ld (debug_mark+2),a  
41c3 18 03			jr .pastdmark  
41c5 ..			.dmark: db "TC4"  
41c8 f1			.pastdmark: pop af  
41c9			endm  
# End of macro DMARK
41c9						CALLMONITOR 
41c9 cd 92 16			call break_point_state  
41cc				endm  
# End of macro CALLMONITOR
41cc					endif 
41cc					;; 
41cc			 
41cc fe 20				cp ' ' 
41ce 20 20				jr nz, .totsiptou 
41d0 23					inc hl 
41d1 7e					ld a, (hl) 
41d2					if DEBUG_FORTH_WORDS 
41d2						DMARK "TC5" 
41d2 f5				push af  
41d3 3a e7 41			ld a, (.dmark)  
41d6 32 77 fb			ld (debug_mark),a  
41d9 3a e8 41			ld a, (.dmark+1)  
41dc 32 78 fb			ld (debug_mark+1),a  
41df 3a e9 41			ld a, (.dmark+2)  
41e2 32 79 fb			ld (debug_mark+2),a  
41e5 18 03			jr .pastdmark  
41e7 ..			.dmark: db "TC5"  
41ea f1			.pastdmark: pop af  
41eb			endm  
# End of macro DMARK
41eb						CALLMONITOR 
41eb cd 92 16			call break_point_state  
41ee				endm  
# End of macro CALLMONITOR
41ee					endif 
41ee 18 c0				jr .totsp 
41f0 fe 00		.totsiptou:    cp 0 
41f2 28 40				jr z, .totdone 
41f4					; not space and not zero term so upper case it 
41f4 cd 76 10				call to_upper 
41f7			 
41f7					if DEBUG_FORTH_WORDS 
41f7						DMARK "TC6" 
41f7 f5				push af  
41f8 3a 0c 42			ld a, (.dmark)  
41fb 32 77 fb			ld (debug_mark),a  
41fe 3a 0d 42			ld a, (.dmark+1)  
4201 32 78 fb			ld (debug_mark+1),a  
4204 3a 0e 42			ld a, (.dmark+2)  
4207 32 79 fb			ld (debug_mark+2),a  
420a 18 03			jr .pastdmark  
420c ..			.dmark: db "TC6"  
420f f1			.pastdmark: pop af  
4210			endm  
# End of macro DMARK
4210						CALLMONITOR 
4210 cd 92 16			call break_point_state  
4213				endm  
# End of macro CALLMONITOR
4213					endif 
4213			 
4213			 
4213			.totnxt: 
4213			 
4213 77					ld (hl), a 
4214 23					inc hl 
4215					if DEBUG_FORTH_WORDS 
4215						DMARK "TC7" 
4215 f5				push af  
4216 3a 2a 42			ld a, (.dmark)  
4219 32 77 fb			ld (debug_mark),a  
421c 3a 2b 42			ld a, (.dmark+1)  
421f 32 78 fb			ld (debug_mark+1),a  
4222 3a 2c 42			ld a, (.dmark+2)  
4225 32 79 fb			ld (debug_mark+2),a  
4228 18 03			jr .pastdmark  
422a ..			.dmark: db "TC7"  
422d f1			.pastdmark: pop af  
422e			endm  
# End of macro DMARK
422e						CALLMONITOR 
422e cd 92 16			call break_point_state  
4231				endm  
# End of macro CALLMONITOR
4231					endif 
4231 c3 69 41				jp .tot 
4234			 
4234					 
4234			 
4234			 
4234			; for each char convert to low 
4234					 
4234			.totdone: 
4234					if DEBUG_FORTH_WORDS 
4234						DMARK "TCd" 
4234 f5				push af  
4235 3a 49 42			ld a, (.dmark)  
4238 32 77 fb			ld (debug_mark),a  
423b 3a 4a 42			ld a, (.dmark+1)  
423e 32 78 fb			ld (debug_mark+1),a  
4241 3a 4b 42			ld a, (.dmark+2)  
4244 32 79 fb			ld (debug_mark+2),a  
4247 18 03			jr .pastdmark  
4249 ..			.dmark: db "TCd"  
424c f1			.pastdmark: pop af  
424d			endm  
# End of macro DMARK
424d						CALLMONITOR 
424d cd 92 16			call break_point_state  
4250				endm  
# End of macro CALLMONITOR
4250					endif 
4250					NEXTW 
4250 c3 88 1f			jp macro_next 
4253				endm 
# End of macro NEXTW
4253			 
4253			.SUBSTR: 
4253				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4253 48				db WORD_SYS_CORE+52             
4254 b1 42			dw .LEFT            
4256 07				db 6 + 1 
4257 .. 00			db "SUBSTR",0              
425e				endm 
# End of macro CWHEAD
425e			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
425e			 
425e					if DEBUG_FORTH_WORDS_KEY 
425e						DMARK "SST" 
425e f5				push af  
425f 3a 73 42			ld a, (.dmark)  
4262 32 77 fb			ld (debug_mark),a  
4265 3a 74 42			ld a, (.dmark+1)  
4268 32 78 fb			ld (debug_mark+1),a  
426b 3a 75 42			ld a, (.dmark+2)  
426e 32 79 fb			ld (debug_mark+2),a  
4271 18 03			jr .pastdmark  
4273 ..			.dmark: db "SST"  
4276 f1			.pastdmark: pop af  
4277			endm  
# End of macro DMARK
4277						CALLMONITOR 
4277 cd 92 16			call break_point_state  
427a				endm  
# End of macro CALLMONITOR
427a					endif 
427a			; TODO check string type 
427a					FORTH_DSP_VALUEHL 
427a cd 16 1e			call macro_dsp_valuehl 
427d				endm 
# End of macro FORTH_DSP_VALUEHL
427d			 
427d e5					push hl      ; string length 
427e			 
427e					FORTH_DSP_POP 
427e cd ce 1e			call macro_forth_dsp_pop 
4281				endm 
# End of macro FORTH_DSP_POP
4281			 
4281					FORTH_DSP_VALUEHL 
4281 cd 16 1e			call macro_dsp_valuehl 
4284				endm 
# End of macro FORTH_DSP_VALUEHL
4284			 
4284 e5					push hl     ; start char 
4285			 
4285					FORTH_DSP_POP 
4285 cd ce 1e			call macro_forth_dsp_pop 
4288				endm 
# End of macro FORTH_DSP_POP
4288			 
4288			 
4288					FORTH_DSP_VALUE 
4288 cd ff 1d			call macro_forth_dsp_value 
428b				endm 
# End of macro FORTH_DSP_VALUE
428b			 
428b d1					pop de    ; get start post offset 
428c			 
428c 19					add hl, de    ; starting offset 
428d			 
428d c1					pop bc 
428e c5					push bc      ; grab size of string 
428f			 
428f e5					push hl    ; save string start  
4290			 
4290 26 00				ld h, 0 
4292 69					ld l, c 
4293 23					inc hl 
4294 23					inc hl 
4295			 
4295 cd d0 11				call malloc 
4298				if DEBUG_FORTH_MALLOC_GUARD 
4298 cc 43 52				call z,malloc_error 
429b				endif 
429b			 
429b eb					ex de, hl      ; save malloc area for string copy 
429c e1					pop hl    ; get back source 
429d c1					pop bc    ; get length of string back 
429e			 
429e d5					push de    ; save malloc area for after we push 
429f ed b0				ldir     ; copy substr 
42a1			 
42a1			 
42a1 eb					ex de, hl 
42a2 3e 00				ld a, 0 
42a4 77					ld (hl), a   ; term substr 
42a5			 
42a5					 
42a5 e1					pop hl    ; get malloc so we can push it 
42a6 e5					push hl   ; save so we can free it afterwards 
42a7			 
42a7 cd 8d 1c				call forth_push_str 
42aa			 
42aa e1					pop hl 
42ab cd 9a 12				call free 
42ae			 
42ae					 
42ae					 
42ae			 
42ae			 
42ae					NEXTW 
42ae c3 88 1f			jp macro_next 
42b1				endm 
# End of macro NEXTW
42b1			 
42b1			.LEFT: 
42b1				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
42b1 48				db WORD_SYS_CORE+52             
42b2 d9 42			dw .RIGHT            
42b4 05				db 4 + 1 
42b5 .. 00			db "LEFT",0              
42ba				endm 
# End of macro CWHEAD
42ba			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
42ba					if DEBUG_FORTH_WORDS_KEY 
42ba						DMARK "LEF" 
42ba f5				push af  
42bb 3a cf 42			ld a, (.dmark)  
42be 32 77 fb			ld (debug_mark),a  
42c1 3a d0 42			ld a, (.dmark+1)  
42c4 32 78 fb			ld (debug_mark+1),a  
42c7 3a d1 42			ld a, (.dmark+2)  
42ca 32 79 fb			ld (debug_mark+2),a  
42cd 18 03			jr .pastdmark  
42cf ..			.dmark: db "LEF"  
42d2 f1			.pastdmark: pop af  
42d3			endm  
# End of macro DMARK
42d3						CALLMONITOR 
42d3 cd 92 16			call break_point_state  
42d6				endm  
# End of macro CALLMONITOR
42d6					endif 
42d6			 
42d6					NEXTW 
42d6 c3 88 1f			jp macro_next 
42d9				endm 
# End of macro NEXTW
42d9			.RIGHT: 
42d9				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
42d9 48				db WORD_SYS_CORE+52             
42da 02 43			dw .STR2NUM            
42dc 06				db 5 + 1 
42dd .. 00			db "RIGHT",0              
42e3				endm 
# End of macro CWHEAD
42e3			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
42e3					if DEBUG_FORTH_WORDS_KEY 
42e3						DMARK "RIG" 
42e3 f5				push af  
42e4 3a f8 42			ld a, (.dmark)  
42e7 32 77 fb			ld (debug_mark),a  
42ea 3a f9 42			ld a, (.dmark+1)  
42ed 32 78 fb			ld (debug_mark+1),a  
42f0 3a fa 42			ld a, (.dmark+2)  
42f3 32 79 fb			ld (debug_mark+2),a  
42f6 18 03			jr .pastdmark  
42f8 ..			.dmark: db "RIG"  
42fb f1			.pastdmark: pop af  
42fc			endm  
# End of macro DMARK
42fc						CALLMONITOR 
42fc cd 92 16			call break_point_state  
42ff				endm  
# End of macro CALLMONITOR
42ff					endif 
42ff			 
42ff					NEXTW 
42ff c3 88 1f			jp macro_next 
4302				endm 
# End of macro NEXTW
4302			 
4302			 
4302			.STR2NUM: 
4302				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4302 48				db WORD_SYS_CORE+52             
4303 8e 43			dw .NUM2STR            
4305 08				db 7 + 1 
4306 .. 00			db "STR2NUM",0              
430e				endm 
# End of macro CWHEAD
430e			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
430e			 
430e			 
430e			; TODO STR type check to do 
430e					if DEBUG_FORTH_WORDS_KEY 
430e						DMARK "S2N" 
430e f5				push af  
430f 3a 23 43			ld a, (.dmark)  
4312 32 77 fb			ld (debug_mark),a  
4315 3a 24 43			ld a, (.dmark+1)  
4318 32 78 fb			ld (debug_mark+1),a  
431b 3a 25 43			ld a, (.dmark+2)  
431e 32 79 fb			ld (debug_mark+2),a  
4321 18 03			jr .pastdmark  
4323 ..			.dmark: db "S2N"  
4326 f1			.pastdmark: pop af  
4327			endm  
# End of macro DMARK
4327						CALLMONITOR 
4327 cd 92 16			call break_point_state  
432a				endm  
# End of macro CALLMONITOR
432a					endif 
432a			 
432a					;FORTH_DSP 
432a					FORTH_DSP_VALUE 
432a cd ff 1d			call macro_forth_dsp_value 
432d				endm 
# End of macro FORTH_DSP_VALUE
432d					;inc hl 
432d			 
432d eb					ex de, hl 
432e					if DEBUG_FORTH_WORDS 
432e						DMARK "S2a" 
432e f5				push af  
432f 3a 43 43			ld a, (.dmark)  
4332 32 77 fb			ld (debug_mark),a  
4335 3a 44 43			ld a, (.dmark+1)  
4338 32 78 fb			ld (debug_mark+1),a  
433b 3a 45 43			ld a, (.dmark+2)  
433e 32 79 fb			ld (debug_mark+2),a  
4341 18 03			jr .pastdmark  
4343 ..			.dmark: db "S2a"  
4346 f1			.pastdmark: pop af  
4347			endm  
# End of macro DMARK
4347						CALLMONITOR 
4347 cd 92 16			call break_point_state  
434a				endm  
# End of macro CALLMONITOR
434a					endif 
434a cd fe 10				call string_to_uint16 
434d			 
434d					if DEBUG_FORTH_WORDS 
434d						DMARK "S2b" 
434d f5				push af  
434e 3a 62 43			ld a, (.dmark)  
4351 32 77 fb			ld (debug_mark),a  
4354 3a 63 43			ld a, (.dmark+1)  
4357 32 78 fb			ld (debug_mark+1),a  
435a 3a 64 43			ld a, (.dmark+2)  
435d 32 79 fb			ld (debug_mark+2),a  
4360 18 03			jr .pastdmark  
4362 ..			.dmark: db "S2b"  
4365 f1			.pastdmark: pop af  
4366			endm  
# End of macro DMARK
4366						CALLMONITOR 
4366 cd 92 16			call break_point_state  
4369				endm  
# End of macro CALLMONITOR
4369					endif 
4369			;		push hl 
4369					FORTH_DSP_POP 
4369 cd ce 1e			call macro_forth_dsp_pop 
436c				endm 
# End of macro FORTH_DSP_POP
436c			;		pop hl 
436c					 
436c					if DEBUG_FORTH_WORDS 
436c						DMARK "S2b" 
436c f5				push af  
436d 3a 81 43			ld a, (.dmark)  
4370 32 77 fb			ld (debug_mark),a  
4373 3a 82 43			ld a, (.dmark+1)  
4376 32 78 fb			ld (debug_mark+1),a  
4379 3a 83 43			ld a, (.dmark+2)  
437c 32 79 fb			ld (debug_mark+2),a  
437f 18 03			jr .pastdmark  
4381 ..			.dmark: db "S2b"  
4384 f1			.pastdmark: pop af  
4385			endm  
# End of macro DMARK
4385						CALLMONITOR 
4385 cd 92 16			call break_point_state  
4388				endm  
# End of macro CALLMONITOR
4388					endif 
4388 cd 1f 1c				call forth_push_numhl	 
438b			 
438b				 
438b				       NEXTW 
438b c3 88 1f			jp macro_next 
438e				endm 
# End of macro NEXTW
438e			.NUM2STR: 
438e				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
438e 48				db WORD_SYS_CORE+52             
438f 9d 43			dw .CONCAT            
4391 08				db 7 + 1 
4392 .. 00			db "NUM2STR",0              
439a				endm 
# End of macro CWHEAD
439a			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
439a			 
439a			;		; malloc a string to target 
439a			;		ld hl, 10     ; TODO max string size should be fine 
439a			;		call malloc 
439a			;		push hl    ; save malloc location 
439a			; 
439a			; 
439a			;; TODO check int type 
439a			;		FORTH_DSP_VALUEHL 
439a			;		ld a, l 
439a			;		call DispAToASCII   
439a			;;TODO need to chage above call to dump into string 
439a			; 
439a			; 
439a			 
439a				       NEXTW 
439a c3 88 1f			jp macro_next 
439d				endm 
# End of macro NEXTW
439d			 
439d			.CONCAT: 
439d				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
439d 48				db WORD_SYS_CORE+52             
439e 50 44			dw .FIND            
43a0 07				db 6 + 1 
43a1 .. 00			db "CONCAT",0              
43a8				endm 
# End of macro CWHEAD
43a8			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
43a8			 
43a8			; TODO check string type 
43a8			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
43a8			 
43a8					if DEBUG_FORTH_WORDS_KEY 
43a8						DMARK "CON" 
43a8 f5				push af  
43a9 3a bd 43			ld a, (.dmark)  
43ac 32 77 fb			ld (debug_mark),a  
43af 3a be 43			ld a, (.dmark+1)  
43b2 32 78 fb			ld (debug_mark+1),a  
43b5 3a bf 43			ld a, (.dmark+2)  
43b8 32 79 fb			ld (debug_mark+2),a  
43bb 18 03			jr .pastdmark  
43bd ..			.dmark: db "CON"  
43c0 f1			.pastdmark: pop af  
43c1			endm  
# End of macro DMARK
43c1						CALLMONITOR 
43c1 cd 92 16			call break_point_state  
43c4				endm  
# End of macro CALLMONITOR
43c4					endif 
43c4			 
43c4			 
43c4					FORTH_DSP_VALUE 
43c4 cd ff 1d			call macro_forth_dsp_value 
43c7				endm 
# End of macro FORTH_DSP_VALUE
43c7 e5					push hl   ; s2 
43c8			 
43c8					FORTH_DSP_POP 
43c8 cd ce 1e			call macro_forth_dsp_pop 
43cb				endm 
# End of macro FORTH_DSP_POP
43cb			 
43cb					FORTH_DSP_VALUE 
43cb cd ff 1d			call macro_forth_dsp_value 
43ce				endm 
# End of macro FORTH_DSP_VALUE
43ce			 
43ce e5					push hl   ; s1 
43cf			 
43cf					FORTH_DSP_POP 
43cf cd ce 1e			call macro_forth_dsp_pop 
43d2				endm 
# End of macro FORTH_DSP_POP
43d2					 
43d2			 
43d2					; copy s1 
43d2			 
43d2				 
43d2					; save ptr 
43d2 e1					pop hl  
43d3 e5					push hl 
43d4 3e 00				ld a, 0 
43d6 cd 72 11				call strlent 
43d9					;inc hl    ; zer0 
43d9 06 00				ld b, 0 
43db 4d					ld c, l 
43dc e1					pop hl		 
43dd 11 1d ee				ld de, scratch	 
43e0					if DEBUG_FORTH_WORDS 
43e0						DMARK "CO1" 
43e0 f5				push af  
43e1 3a f5 43			ld a, (.dmark)  
43e4 32 77 fb			ld (debug_mark),a  
43e7 3a f6 43			ld a, (.dmark+1)  
43ea 32 78 fb			ld (debug_mark+1),a  
43ed 3a f7 43			ld a, (.dmark+2)  
43f0 32 79 fb			ld (debug_mark+2),a  
43f3 18 03			jr .pastdmark  
43f5 ..			.dmark: db "CO1"  
43f8 f1			.pastdmark: pop af  
43f9			endm  
# End of macro DMARK
43f9						CALLMONITOR 
43f9 cd 92 16			call break_point_state  
43fc				endm  
# End of macro CALLMONITOR
43fc					endif 
43fc ed b0				ldir 
43fe			 
43fe e1					pop hl 
43ff e5					push hl 
4400 d5					push de 
4401			 
4401			 
4401 3e 00				ld a, 0 
4403 cd 72 11				call strlent 
4406 23					inc hl    ; zer0 
4407 23					inc hl 
4408 06 00				ld b, 0 
440a 4d					ld c, l 
440b d1					pop de 
440c e1					pop hl		 
440d					if DEBUG_FORTH_WORDS 
440d						DMARK "CO2" 
440d f5				push af  
440e 3a 22 44			ld a, (.dmark)  
4411 32 77 fb			ld (debug_mark),a  
4414 3a 23 44			ld a, (.dmark+1)  
4417 32 78 fb			ld (debug_mark+1),a  
441a 3a 24 44			ld a, (.dmark+2)  
441d 32 79 fb			ld (debug_mark+2),a  
4420 18 03			jr .pastdmark  
4422 ..			.dmark: db "CO2"  
4425 f1			.pastdmark: pop af  
4426			endm  
# End of macro DMARK
4426						CALLMONITOR 
4426 cd 92 16			call break_point_state  
4429				endm  
# End of macro CALLMONITOR
4429					endif 
4429 ed b0				ldir 
442b			 
442b			 
442b			 
442b 21 1d ee				ld hl, scratch 
442e					if DEBUG_FORTH_WORDS 
442e						DMARK "CO5" 
442e f5				push af  
442f 3a 43 44			ld a, (.dmark)  
4432 32 77 fb			ld (debug_mark),a  
4435 3a 44 44			ld a, (.dmark+1)  
4438 32 78 fb			ld (debug_mark+1),a  
443b 3a 45 44			ld a, (.dmark+2)  
443e 32 79 fb			ld (debug_mark+2),a  
4441 18 03			jr .pastdmark  
4443 ..			.dmark: db "CO5"  
4446 f1			.pastdmark: pop af  
4447			endm  
# End of macro DMARK
4447						CALLMONITOR 
4447 cd 92 16			call break_point_state  
444a				endm  
# End of macro CALLMONITOR
444a					endif 
444a			 
444a cd 8d 1c				call forth_push_str 
444d			 
444d			 
444d			 
444d			 
444d				       NEXTW 
444d c3 88 1f			jp macro_next 
4450				endm 
# End of macro NEXTW
4450			 
4450			 
4450			.FIND: 
4450				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4450 4b				db WORD_SYS_CORE+55             
4451 0e 45			dw .LEN            
4453 05				db 4 + 1 
4454 .. 00			db "FIND",0              
4459				endm 
# End of macro CWHEAD
4459			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4459			 
4459					if DEBUG_FORTH_WORDS_KEY 
4459						DMARK "FND" 
4459 f5				push af  
445a 3a 6e 44			ld a, (.dmark)  
445d 32 77 fb			ld (debug_mark),a  
4460 3a 6f 44			ld a, (.dmark+1)  
4463 32 78 fb			ld (debug_mark+1),a  
4466 3a 70 44			ld a, (.dmark+2)  
4469 32 79 fb			ld (debug_mark+2),a  
446c 18 03			jr .pastdmark  
446e ..			.dmark: db "FND"  
4471 f1			.pastdmark: pop af  
4472			endm  
# End of macro DMARK
4472						CALLMONITOR 
4472 cd 92 16			call break_point_state  
4475				endm  
# End of macro CALLMONITOR
4475					endif 
4475			 
4475			; TODO check string type 
4475					FORTH_DSP_VALUE 
4475 cd ff 1d			call macro_forth_dsp_value 
4478				endm 
# End of macro FORTH_DSP_VALUE
4478			 
4478 e5					push hl    
4479 7e					ld a,(hl)    ; char to find   
447a			; TODO change char to substr 
447a			 
447a f5					push af 
447b					 
447b			 
447b			 
447b					if DEBUG_FORTH_WORDS 
447b						DMARK "FN1" 
447b f5				push af  
447c 3a 90 44			ld a, (.dmark)  
447f 32 77 fb			ld (debug_mark),a  
4482 3a 91 44			ld a, (.dmark+1)  
4485 32 78 fb			ld (debug_mark+1),a  
4488 3a 92 44			ld a, (.dmark+2)  
448b 32 79 fb			ld (debug_mark+2),a  
448e 18 03			jr .pastdmark  
4490 ..			.dmark: db "FN1"  
4493 f1			.pastdmark: pop af  
4494			endm  
# End of macro DMARK
4494						CALLMONITOR 
4494 cd 92 16			call break_point_state  
4497				endm  
# End of macro CALLMONITOR
4497					endif 
4497			 
4497					FORTH_DSP_POP 
4497 cd ce 1e			call macro_forth_dsp_pop 
449a				endm 
# End of macro FORTH_DSP_POP
449a			 
449a					; string to search 
449a			 
449a					FORTH_DSP_VALUE 
449a cd ff 1d			call macro_forth_dsp_value 
449d				endm 
# End of macro FORTH_DSP_VALUE
449d			 
449d d1					pop de  ; d is char to find  
449e			 
449e					if DEBUG_FORTH_WORDS 
449e						DMARK "FN2" 
449e f5				push af  
449f 3a b3 44			ld a, (.dmark)  
44a2 32 77 fb			ld (debug_mark),a  
44a5 3a b4 44			ld a, (.dmark+1)  
44a8 32 78 fb			ld (debug_mark+1),a  
44ab 3a b5 44			ld a, (.dmark+2)  
44ae 32 79 fb			ld (debug_mark+2),a  
44b1 18 03			jr .pastdmark  
44b3 ..			.dmark: db "FN2"  
44b6 f1			.pastdmark: pop af  
44b7			endm  
# End of macro DMARK
44b7						CALLMONITOR 
44b7 cd 92 16			call break_point_state  
44ba				endm  
# End of macro CALLMONITOR
44ba					endif 
44ba					 
44ba 01 00 00				ld bc, 0 
44bd 7e			.findchar:      ld a,(hl) 
44be fe 00				cp 0   		 
44c0 28 27				jr z, .finddone     
44c2 ba					cp d 
44c3 28 20				jr z, .foundchar 
44c5 03					inc bc 
44c6 23					inc hl 
44c7					if DEBUG_FORTH_WORDS 
44c7						DMARK "FN3" 
44c7 f5				push af  
44c8 3a dc 44			ld a, (.dmark)  
44cb 32 77 fb			ld (debug_mark),a  
44ce 3a dd 44			ld a, (.dmark+1)  
44d1 32 78 fb			ld (debug_mark+1),a  
44d4 3a de 44			ld a, (.dmark+2)  
44d7 32 79 fb			ld (debug_mark+2),a  
44da 18 03			jr .pastdmark  
44dc ..			.dmark: db "FN3"  
44df f1			.pastdmark: pop af  
44e0			endm  
# End of macro DMARK
44e0						CALLMONITOR 
44e0 cd 92 16			call break_point_state  
44e3				endm  
# End of macro CALLMONITOR
44e3					endif 
44e3 18 d8				jr .findchar 
44e5			 
44e5			 
44e5 c5			.foundchar:	push bc 
44e6 e1					pop hl 
44e7 18 03				jr .findexit 
44e9			 
44e9			 
44e9							 
44e9			 
44e9			.finddone:     ; got to end of string with no find 
44e9 21 00 00				ld hl, 0 
44ec			.findexit: 
44ec			 
44ec					if DEBUG_FORTH_WORDS 
44ec						DMARK "FNd" 
44ec f5				push af  
44ed 3a 01 45			ld a, (.dmark)  
44f0 32 77 fb			ld (debug_mark),a  
44f3 3a 02 45			ld a, (.dmark+1)  
44f6 32 78 fb			ld (debug_mark+1),a  
44f9 3a 03 45			ld a, (.dmark+2)  
44fc 32 79 fb			ld (debug_mark+2),a  
44ff 18 03			jr .pastdmark  
4501 ..			.dmark: db "FNd"  
4504 f1			.pastdmark: pop af  
4505			endm  
# End of macro DMARK
4505						CALLMONITOR 
4505 cd 92 16			call break_point_state  
4508				endm  
# End of macro CALLMONITOR
4508					endif 
4508 cd 1f 1c			call forth_push_numhl 
450b			 
450b				       NEXTW 
450b c3 88 1f			jp macro_next 
450e				endm 
# End of macro NEXTW
450e			 
450e			.LEN: 
450e				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
450e 4c				db WORD_SYS_CORE+56             
450f 43 45			dw .CHAR            
4511 06				db 5 + 1 
4512 .. 00			db "COUNT",0              
4518				endm 
# End of macro CWHEAD
4518			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4518			 
4518					if DEBUG_FORTH_WORDS_KEY 
4518						DMARK "CNT" 
4518 f5				push af  
4519 3a 2d 45			ld a, (.dmark)  
451c 32 77 fb			ld (debug_mark),a  
451f 3a 2e 45			ld a, (.dmark+1)  
4522 32 78 fb			ld (debug_mark+1),a  
4525 3a 2f 45			ld a, (.dmark+2)  
4528 32 79 fb			ld (debug_mark+2),a  
452b 18 03			jr .pastdmark  
452d ..			.dmark: db "CNT"  
4530 f1			.pastdmark: pop af  
4531			endm  
# End of macro DMARK
4531						CALLMONITOR 
4531 cd 92 16			call break_point_state  
4534				endm  
# End of macro CALLMONITOR
4534					endif 
4534			; TODO check string type 
4534					FORTH_DSP 
4534 cd dc 1d			call macro_forth_dsp 
4537				endm 
# End of macro FORTH_DSP
4537					;v5FORTH_DSP_VALUE 
4537			 
4537 23					inc hl 
4538			 
4538 3e 00				ld a, 0 
453a cd 72 11				call strlent 
453d			 
453d cd 1f 1c				call forth_push_numhl 
4540			 
4540			 
4540			 
4540				       NEXTW 
4540 c3 88 1f			jp macro_next 
4543				endm 
# End of macro NEXTW
4543			.CHAR: 
4543				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4543 4d				db WORD_SYS_CORE+57             
4544 79 45			dw .ENDSTR            
4546 05				db 4 + 1 
4547 .. 00			db "CHAR",0              
454c				endm 
# End of macro CWHEAD
454c			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
454c					if DEBUG_FORTH_WORDS_KEY 
454c						DMARK "CHR" 
454c f5				push af  
454d 3a 61 45			ld a, (.dmark)  
4550 32 77 fb			ld (debug_mark),a  
4553 3a 62 45			ld a, (.dmark+1)  
4556 32 78 fb			ld (debug_mark+1),a  
4559 3a 63 45			ld a, (.dmark+2)  
455c 32 79 fb			ld (debug_mark+2),a  
455f 18 03			jr .pastdmark  
4561 ..			.dmark: db "CHR"  
4564 f1			.pastdmark: pop af  
4565			endm  
# End of macro DMARK
4565						CALLMONITOR 
4565 cd 92 16			call break_point_state  
4568				endm  
# End of macro CALLMONITOR
4568					endif 
4568					FORTH_DSP 
4568 cd dc 1d			call macro_forth_dsp 
456b				endm 
# End of macro FORTH_DSP
456b					;v5 FORTH_DSP_VALUE 
456b 23					inc hl      ; now at start of numeric as string 
456c			 
456c			;		push hl 
456c			 
456c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
456c cd ce 1e			call macro_forth_dsp_pop 
456f				endm 
# End of macro FORTH_DSP_POP
456f			 
456f			;		pop hl 
456f			 
456f					; push the content of a onto the stack as a value 
456f			 
456f 7e					ld a,(hl)   ; get char 
4570 26 00				ld h,0 
4572 6f					ld l,a 
4573 cd 1f 1c				call forth_push_numhl 
4576			 
4576				       NEXTW 
4576 c3 88 1f			jp macro_next 
4579				endm 
# End of macro NEXTW
4579			 
4579			 
4579			 
4579			 
4579			.ENDSTR: 
4579			; eof 
4579			 
# End of file forth_words_str.asm
4579			include "forth_words_key.asm" 
4579			 
4579			; | ## Keyboard Words 
4579			 
4579			.KEY: 
4579				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4579 3e				db WORD_SYS_CORE+42             
457a a9 45			dw .WAITK            
457c 04				db 3 + 1 
457d .. 00			db "KEY",0              
4581				endm 
# End of macro CWHEAD
4581			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4581			 
4581					if DEBUG_FORTH_WORDS_KEY 
4581						DMARK "KEY" 
4581 f5				push af  
4582 3a 96 45			ld a, (.dmark)  
4585 32 77 fb			ld (debug_mark),a  
4588 3a 97 45			ld a, (.dmark+1)  
458b 32 78 fb			ld (debug_mark+1),a  
458e 3a 98 45			ld a, (.dmark+2)  
4591 32 79 fb			ld (debug_mark+2),a  
4594 18 03			jr .pastdmark  
4596 ..			.dmark: db "KEY"  
4599 f1			.pastdmark: pop af  
459a			endm  
# End of macro DMARK
459a						CALLMONITOR 
459a cd 92 16			call break_point_state  
459d				endm  
# End of macro CALLMONITOR
459d					endif 
459d			; TODO currently waits 
459d cd 4d 68				call cin 
45a0					;call cin_wait 
45a0 6f					ld l, a 
45a1 26 00				ld h, 0 
45a3 cd 1f 1c				call forth_push_numhl 
45a6					NEXTW 
45a6 c3 88 1f			jp macro_next 
45a9				endm 
# End of macro NEXTW
45a9			.WAITK: 
45a9				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
45a9 3f				db WORD_SYS_CORE+43             
45aa db 45			dw .ACCEPT            
45ac 06				db 5 + 1 
45ad .. 00			db "WAITK",0              
45b3				endm 
# End of macro CWHEAD
45b3			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
45b3					if DEBUG_FORTH_WORDS_KEY 
45b3						DMARK "WAI" 
45b3 f5				push af  
45b4 3a c8 45			ld a, (.dmark)  
45b7 32 77 fb			ld (debug_mark),a  
45ba 3a c9 45			ld a, (.dmark+1)  
45bd 32 78 fb			ld (debug_mark+1),a  
45c0 3a ca 45			ld a, (.dmark+2)  
45c3 32 79 fb			ld (debug_mark+2),a  
45c6 18 03			jr .pastdmark  
45c8 ..			.dmark: db "WAI"  
45cb f1			.pastdmark: pop af  
45cc			endm  
# End of macro DMARK
45cc						CALLMONITOR 
45cc cd 92 16			call break_point_state  
45cf				endm  
# End of macro CALLMONITOR
45cf					endif 
45cf cd 3c 68				call cin_wait 
45d2 6f					ld l, a 
45d3 26 00				ld h, 0 
45d5 cd 1f 1c				call forth_push_numhl 
45d8					NEXTW 
45d8 c3 88 1f			jp macro_next 
45db				endm 
# End of macro NEXTW
45db			.ACCEPT: 
45db				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
45db 40				db WORD_SYS_CORE+44             
45dc 39 46			dw .EDIT            
45de 07				db 6 + 1 
45df .. 00			db "ACCEPT",0              
45e6				endm 
# End of macro CWHEAD
45e6			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
45e6					; TODO crashes on push 
45e6					if DEBUG_FORTH_WORDS_KEY 
45e6						DMARK "ACC" 
45e6 f5				push af  
45e7 3a fb 45			ld a, (.dmark)  
45ea 32 77 fb			ld (debug_mark),a  
45ed 3a fc 45			ld a, (.dmark+1)  
45f0 32 78 fb			ld (debug_mark+1),a  
45f3 3a fd 45			ld a, (.dmark+2)  
45f6 32 79 fb			ld (debug_mark+2),a  
45f9 18 03			jr .pastdmark  
45fb ..			.dmark: db "ACC"  
45fe f1			.pastdmark: pop af  
45ff			endm  
# End of macro DMARK
45ff						CALLMONITOR 
45ff cd 92 16			call break_point_state  
4602				endm  
# End of macro CALLMONITOR
4602					endif 
4602 21 1b f0				ld hl, os_input 
4605 3e 00				ld a, 0 
4607 77					ld (hl),a 
4608 3a 46 f8				ld a,(f_cursor_ptr) 
460b 16 64				ld d, 100 
460d 0e 00				ld c, 0 
460f 1e 28				ld e, 40 
4611 cd 36 0d				call input_str 
4614					; TODO perhaps do a type check and wrap in quotes if not a number 
4614 21 1b f0				ld hl, os_input 
4617					if DEBUG_FORTH_WORDS 
4617						DMARK "AC1" 
4617 f5				push af  
4618 3a 2c 46			ld a, (.dmark)  
461b 32 77 fb			ld (debug_mark),a  
461e 3a 2d 46			ld a, (.dmark+1)  
4621 32 78 fb			ld (debug_mark+1),a  
4624 3a 2e 46			ld a, (.dmark+2)  
4627 32 79 fb			ld (debug_mark+2),a  
462a 18 03			jr .pastdmark  
462c ..			.dmark: db "AC1"  
462f f1			.pastdmark: pop af  
4630			endm  
# End of macro DMARK
4630						CALLMONITOR 
4630 cd 92 16			call break_point_state  
4633				endm  
# End of macro CALLMONITOR
4633					endif 
4633 cd 8d 1c				call forth_push_str 
4636					NEXTW 
4636 c3 88 1f			jp macro_next 
4639				endm 
# End of macro NEXTW
4639			 
4639			.EDIT: 
4639				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4639 40				db WORD_SYS_CORE+44             
463a c2 46			dw .ENDKEY            
463c 05				db 4 + 1 
463d .. 00			db "EDIT",0              
4642				endm 
# End of macro CWHEAD
4642			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4642			 
4642					; TODO does not copy from stack 
4642					if DEBUG_FORTH_WORDS_KEY 
4642						DMARK "EDT" 
4642 f5				push af  
4643 3a 57 46			ld a, (.dmark)  
4646 32 77 fb			ld (debug_mark),a  
4649 3a 58 46			ld a, (.dmark+1)  
464c 32 78 fb			ld (debug_mark+1),a  
464f 3a 59 46			ld a, (.dmark+2)  
4652 32 79 fb			ld (debug_mark+2),a  
4655 18 03			jr .pastdmark  
4657 ..			.dmark: db "EDT"  
465a f1			.pastdmark: pop af  
465b			endm  
# End of macro DMARK
465b						CALLMONITOR 
465b cd 92 16			call break_point_state  
465e				endm  
# End of macro CALLMONITOR
465e					endif 
465e			 
465e					FORTH_DSP 
465e cd dc 1d			call macro_forth_dsp 
4661				endm 
# End of macro FORTH_DSP
4661					;v5 FORTH_DSP_VALUE 
4661 23					inc hl    ; TODO do type check 
4662			 
4662 e5					push hl 
4663 3e 00				ld a, 0 
4665 cd 72 11				call strlent 
4668 23					inc hl 
4669			 
4669 06 00				ld b, 0 
466b 4d					ld c, l 
466c			 
466c e1					pop hl 
466d 11 1b f0				ld de, os_input 
4670					if DEBUG_FORTH_WORDS_KEY 
4670						DMARK "EDc" 
4670 f5				push af  
4671 3a 85 46			ld a, (.dmark)  
4674 32 77 fb			ld (debug_mark),a  
4677 3a 86 46			ld a, (.dmark+1)  
467a 32 78 fb			ld (debug_mark+1),a  
467d 3a 87 46			ld a, (.dmark+2)  
4680 32 79 fb			ld (debug_mark+2),a  
4683 18 03			jr .pastdmark  
4685 ..			.dmark: db "EDc"  
4688 f1			.pastdmark: pop af  
4689			endm  
# End of macro DMARK
4689						CALLMONITOR 
4689 cd 92 16			call break_point_state  
468c				endm  
# End of macro CALLMONITOR
468c					endif 
468c ed b0				ldir 
468e			 
468e			 
468e 21 1b f0				ld hl, os_input 
4691					;ld a, 0 
4691					;ld (hl),a 
4691 3a 46 f8				ld a,(f_cursor_ptr) 
4694 16 64				ld d, 100 
4696 0e 00				ld c, 0 
4698 1e 28				ld e, 40 
469a cd 36 0d				call input_str 
469d					; TODO perhaps do a type check and wrap in quotes if not a number 
469d 21 1b f0				ld hl, os_input 
46a0					if DEBUG_FORTH_WORDS 
46a0						DMARK "ED1" 
46a0 f5				push af  
46a1 3a b5 46			ld a, (.dmark)  
46a4 32 77 fb			ld (debug_mark),a  
46a7 3a b6 46			ld a, (.dmark+1)  
46aa 32 78 fb			ld (debug_mark+1),a  
46ad 3a b7 46			ld a, (.dmark+2)  
46b0 32 79 fb			ld (debug_mark+2),a  
46b3 18 03			jr .pastdmark  
46b5 ..			.dmark: db "ED1"  
46b8 f1			.pastdmark: pop af  
46b9			endm  
# End of macro DMARK
46b9						CALLMONITOR 
46b9 cd 92 16			call break_point_state  
46bc				endm  
# End of macro CALLMONITOR
46bc					endif 
46bc cd 8d 1c				call forth_push_str 
46bf					NEXTW 
46bf c3 88 1f			jp macro_next 
46c2				endm 
# End of macro NEXTW
46c2			 
46c2			 
46c2			 
46c2			.ENDKEY: 
46c2			; eof 
46c2			 
# End of file forth_words_key.asm
46c2			 
46c2			if STORAGE_SE 
46c2			   	include "forth_words_storage.asm" 
46c2			 
46c2			; | ## Fixed Storage Words 
46c2			 
46c2			 
46c2			.BREAD: 
46c2			  
46c2				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
46c2 3a				db WORD_SYS_CORE+38             
46c3 3b 47			dw .BWRITE            
46c5 06				db 5 + 1 
46c6 .. 00			db "BREAD",0              
46cc				endm 
# End of macro CWHEAD
46cc			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
46cc				 
46cc					if DEBUG_FORTH_WORDS_KEY 
46cc						DMARK "BRD" 
46cc f5				push af  
46cd 3a e1 46			ld a, (.dmark)  
46d0 32 77 fb			ld (debug_mark),a  
46d3 3a e2 46			ld a, (.dmark+1)  
46d6 32 78 fb			ld (debug_mark+1),a  
46d9 3a e3 46			ld a, (.dmark+2)  
46dc 32 79 fb			ld (debug_mark+2),a  
46df 18 03			jr .pastdmark  
46e1 ..			.dmark: db "BRD"  
46e4 f1			.pastdmark: pop af  
46e5			endm  
# End of macro DMARK
46e5						CALLMONITOR 
46e5 cd 92 16			call break_point_state  
46e8				endm  
# End of macro CALLMONITOR
46e8					endif 
46e8			 
46e8				FORTH_DSP_VALUEHL 
46e8 cd 16 1e			call macro_dsp_valuehl 
46eb				endm 
# End of macro FORTH_DSP_VALUEHL
46eb			 
46eb				FORTH_DSP_POP 
46eb cd ce 1e			call macro_forth_dsp_pop 
46ee				endm 
# End of macro FORTH_DSP_POP
46ee			 
46ee				; calc block address 
46ee			 
46ee eb				ex de, hl 
46ef 3e 40			ld a, STORE_BLOCK_PHY 
46f1 cd 8c 0c			call Mult16 
46f4			 
46f4			 
46f4 11 62 f8			ld de, store_page 
46f7			 
46f7					if DEBUG_FORTH_WORDS 
46f7						DMARK "BR1" 
46f7 f5				push af  
46f8 3a 0c 47			ld a, (.dmark)  
46fb 32 77 fb			ld (debug_mark),a  
46fe 3a 0d 47			ld a, (.dmark+1)  
4701 32 78 fb			ld (debug_mark+1),a  
4704 3a 0e 47			ld a, (.dmark+2)  
4707 32 79 fb			ld (debug_mark+2),a  
470a 18 03			jr .pastdmark  
470c ..			.dmark: db "BR1"  
470f f1			.pastdmark: pop af  
4710			endm  
# End of macro DMARK
4710						CALLMONITOR 
4710 cd 92 16			call break_point_state  
4713				endm  
# End of macro CALLMONITOR
4713					endif 
4713			 
4713 cd 0c 03			call storage_read_block 
4716			 
4716 21 64 f8		        ld hl, store_page+2 
4719					if DEBUG_FORTH_WORDS 
4719						DMARK "BR2" 
4719 f5				push af  
471a 3a 2e 47			ld a, (.dmark)  
471d 32 77 fb			ld (debug_mark),a  
4720 3a 2f 47			ld a, (.dmark+1)  
4723 32 78 fb			ld (debug_mark+1),a  
4726 3a 30 47			ld a, (.dmark+2)  
4729 32 79 fb			ld (debug_mark+2),a  
472c 18 03			jr .pastdmark  
472e ..			.dmark: db "BR2"  
4731 f1			.pastdmark: pop af  
4732			endm  
# End of macro DMARK
4732						CALLMONITOR 
4732 cd 92 16			call break_point_state  
4735				endm  
# End of macro CALLMONITOR
4735					endif 
4735 cd 8d 1c			call forth_push_str 
4738			 
4738			 
4738					NEXTW 
4738 c3 88 1f			jp macro_next 
473b				endm 
# End of macro NEXTW
473b			.BWRITE: 
473b				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
473b 3a				db WORD_SYS_CORE+38             
473c d0 47			dw .BUPD            
473e 07				db 6 + 1 
473f .. 00			db "BWRITE",0              
4746				endm 
# End of macro CWHEAD
4746			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
4746			 
4746					if DEBUG_FORTH_WORDS_KEY 
4746						DMARK "BWR" 
4746 f5				push af  
4747 3a 5b 47			ld a, (.dmark)  
474a 32 77 fb			ld (debug_mark),a  
474d 3a 5c 47			ld a, (.dmark+1)  
4750 32 78 fb			ld (debug_mark+1),a  
4753 3a 5d 47			ld a, (.dmark+2)  
4756 32 79 fb			ld (debug_mark+2),a  
4759 18 03			jr .pastdmark  
475b ..			.dmark: db "BWR"  
475e f1			.pastdmark: pop af  
475f			endm  
# End of macro DMARK
475f						CALLMONITOR 
475f cd 92 16			call break_point_state  
4762				endm  
# End of macro CALLMONITOR
4762					endif 
4762			 
4762				FORTH_DSP_VALUEHL 
4762 cd 16 1e			call macro_dsp_valuehl 
4765				endm 
# End of macro FORTH_DSP_VALUEHL
4765			 
4765				; calc block address 
4765			 
4765 eb				ex de, hl 
4766 3e 40			ld a, STORE_BLOCK_PHY 
4768 cd 8c 0c			call Mult16 
476b			 
476b e5				push hl         ; address 
476c			 
476c				FORTH_DSP_POP 
476c cd ce 1e			call macro_forth_dsp_pop 
476f				endm 
# End of macro FORTH_DSP_POP
476f			 
476f				FORTH_DSP_VALUEHL 
476f cd 16 1e			call macro_dsp_valuehl 
4772				endm 
# End of macro FORTH_DSP_VALUEHL
4772			 
4772				FORTH_DSP_POP 
4772 cd ce 1e			call macro_forth_dsp_pop 
4775				endm 
# End of macro FORTH_DSP_POP
4775			 
4775 cd 18 0a			call storage_clear_page 
4778			 
4778				; copy string to store page 
4778			 
4778 e5				push hl     ; save string address 
4779			 
4779 3e 00			ld a, 0 
477b cd 72 11			call strlent 
477e			 
477e 23				inc hl 
477f			 
477f 4d				ld c, l 
4780 06 00			ld b, 0 
4782			 
4782 e1				pop hl 
4783 11 64 f8			ld de, store_page + 2 
4786					if DEBUG_FORTH_WORDS 
4786						DMARK "BW1" 
4786 f5				push af  
4787 3a 9b 47			ld a, (.dmark)  
478a 32 77 fb			ld (debug_mark),a  
478d 3a 9c 47			ld a, (.dmark+1)  
4790 32 78 fb			ld (debug_mark+1),a  
4793 3a 9d 47			ld a, (.dmark+2)  
4796 32 79 fb			ld (debug_mark+2),a  
4799 18 03			jr .pastdmark  
479b ..			.dmark: db "BW1"  
479e f1			.pastdmark: pop af  
479f			endm  
# End of macro DMARK
479f						CALLMONITOR 
479f cd 92 16			call break_point_state  
47a2				endm  
# End of macro CALLMONITOR
47a2					endif 
47a2 ed b0			ldir 
47a4			 
47a4			 
47a4				; poke the start of the block with flags to prevent high level file ops hitting the block 
47a4			 
47a4 21 ff ff			ld hl, $ffff 
47a7			 
47a7 22 62 f8			ld (store_page), hl	 
47aa				 
47aa e1				pop hl    ; get address 
47ab 11 62 f8			ld de, store_page 
47ae			 
47ae					if DEBUG_FORTH_WORDS 
47ae						DMARK "BW2" 
47ae f5				push af  
47af 3a c3 47			ld a, (.dmark)  
47b2 32 77 fb			ld (debug_mark),a  
47b5 3a c4 47			ld a, (.dmark+1)  
47b8 32 78 fb			ld (debug_mark+1),a  
47bb 3a c5 47			ld a, (.dmark+2)  
47be 32 79 fb			ld (debug_mark+2),a  
47c1 18 03			jr .pastdmark  
47c3 ..			.dmark: db "BW2"  
47c6 f1			.pastdmark: pop af  
47c7			endm  
# End of macro DMARK
47c7						CALLMONITOR 
47c7 cd 92 16			call break_point_state  
47ca				endm  
# End of macro CALLMONITOR
47ca					endif 
47ca			 
47ca cd 71 03			call storage_write_block 
47cd			 
47cd					NEXTW 
47cd c3 88 1f			jp macro_next 
47d0				endm 
# End of macro NEXTW
47d0			 
47d0			.BUPD: 
47d0				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
47d0 3a				db WORD_SYS_CORE+38             
47d1 26 48			dw .BYID            
47d3 05				db 4 + 1 
47d4 .. 00			db "BUPD",0              
47d9				endm 
# End of macro CWHEAD
47d9			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
47d9			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
47d9			; | | or completely different file system structure. 
47d9			 
47d9					if DEBUG_FORTH_WORDS_KEY 
47d9						DMARK "BUD" 
47d9 f5				push af  
47da 3a ee 47			ld a, (.dmark)  
47dd 32 77 fb			ld (debug_mark),a  
47e0 3a ef 47			ld a, (.dmark+1)  
47e3 32 78 fb			ld (debug_mark+1),a  
47e6 3a f0 47			ld a, (.dmark+2)  
47e9 32 79 fb			ld (debug_mark+2),a  
47ec 18 03			jr .pastdmark  
47ee ..			.dmark: db "BUD"  
47f1 f1			.pastdmark: pop af  
47f2			endm  
# End of macro DMARK
47f2						CALLMONITOR 
47f2 cd 92 16			call break_point_state  
47f5				endm  
# End of macro CALLMONITOR
47f5					endif 
47f5			 
47f5				FORTH_DSP_VALUEHL 
47f5 cd 16 1e			call macro_dsp_valuehl 
47f8				endm 
# End of macro FORTH_DSP_VALUEHL
47f8			 
47f8				; calc block address 
47f8			 
47f8 eb				ex de, hl 
47f9 3e 40			ld a, STORE_BLOCK_PHY 
47fb cd 8c 0c			call Mult16 
47fe			 
47fe				FORTH_DSP_POP 
47fe cd ce 1e			call macro_forth_dsp_pop 
4801				endm 
# End of macro FORTH_DSP_POP
4801			 
4801			 
4801 11 62 f8			ld de, store_page 
4804			 
4804					if DEBUG_FORTH_WORDS 
4804						DMARK "BUe" 
4804 f5				push af  
4805 3a 19 48			ld a, (.dmark)  
4808 32 77 fb			ld (debug_mark),a  
480b 3a 1a 48			ld a, (.dmark+1)  
480e 32 78 fb			ld (debug_mark+1),a  
4811 3a 1b 48			ld a, (.dmark+2)  
4814 32 79 fb			ld (debug_mark+2),a  
4817 18 03			jr .pastdmark  
4819 ..			.dmark: db "BUe"  
481c f1			.pastdmark: pop af  
481d			endm  
# End of macro DMARK
481d						CALLMONITOR 
481d cd 92 16			call break_point_state  
4820				endm  
# End of macro CALLMONITOR
4820					endif 
4820			 
4820 cd 71 03			call storage_write_block 
4823			 
4823					NEXTW 
4823 c3 88 1f			jp macro_next 
4826				endm 
# End of macro NEXTW
4826			 
4826			.BYID: 
4826			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4826			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4826			; 
4826			;		 
4826			;		if DEBUG_FORTH_WORDS_KEY 
4826			;			DMARK "BYID" 
4826			;			CALLMONITOR 
4826			;		endif 
4826			; 
4826			;		; get direct address 
4826			; 
4826			;		FORTH_DSP_VALUEHL 
4826			; 
4826			;		FORTH_DSP_POP 
4826			; 
4826			;	; calc block address 
4826			; 
4826			;	ex de, hl 
4826			;	ld a, STORE_BLOCK_PHY 
4826			;	call Mult16 
4826			;	;	do BREAD with number as param 
4826			;	; push the file name	 
4826			;	ld de, store_page 
4826			;	call storage_read_block 
4826			 ;       ld hl, store_page+2 
4826			; 
4826			; 
4826			;		NEXTW 
4826			;.BYNAME: 
4826			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
4826			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
4826			;		NEXTW 
4826			; 
4826			.DIR: 
4826				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4826 3a				db WORD_SYS_CORE+38             
4827 2a 49			dw .SAVE            
4829 04				db 3 + 1 
482a .. 00			db "DIR",0              
482e				endm 
# End of macro CWHEAD
482e			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
482e			 
482e					if DEBUG_FORTH_WORDS_KEY 
482e						DMARK "DIR" 
482e f5				push af  
482f 3a 43 48			ld a, (.dmark)  
4832 32 77 fb			ld (debug_mark),a  
4835 3a 44 48			ld a, (.dmark+1)  
4838 32 78 fb			ld (debug_mark+1),a  
483b 3a 45 48			ld a, (.dmark+2)  
483e 32 79 fb			ld (debug_mark+2),a  
4841 18 03			jr .pastdmark  
4843 ..			.dmark: db "DIR"  
4846 f1			.pastdmark: pop af  
4847			endm  
# End of macro DMARK
4847						CALLMONITOR 
4847 cd 92 16			call break_point_state  
484a				endm  
# End of macro CALLMONITOR
484a					endif 
484a cd bd 03			call storage_get_block_0 
484d			 
484d 21 62 f8			ld hl, store_page     ; get current id count 
4850 46				ld b, (hl) 
4851 0e 00			ld c, 0    ; count of files   
4853					if DEBUG_FORTH_WORDS 
4853						DMARK "DI1" 
4853 f5				push af  
4854 3a 68 48			ld a, (.dmark)  
4857 32 77 fb			ld (debug_mark),a  
485a 3a 69 48			ld a, (.dmark+1)  
485d 32 78 fb			ld (debug_mark+1),a  
4860 3a 6a 48			ld a, (.dmark+2)  
4863 32 79 fb			ld (debug_mark+2),a  
4866 18 03			jr .pastdmark  
4868 ..			.dmark: db "DI1"  
486b f1			.pastdmark: pop af  
486c			endm  
# End of macro DMARK
486c						CALLMONITOR 
486c cd 92 16			call break_point_state  
486f				endm  
# End of macro CALLMONITOR
486f					endif 
486f			 
486f				; check for empty drive 
486f			 
486f 3e 00			ld a, 0 
4871 b8				cp b 
4872 ca e0 48			jp z, .dirdone 
4875			 
4875				; for each of the current ids do a search for them and if found push to stack 
4875			 
4875 c5			.diritem:	push bc 
4876 21 40 00				ld hl, STORE_BLOCK_PHY 
4879 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
487b 58					ld e,b 
487c			 
487c			;		if DEBUG_FORTH_WORDS 
487c			;			DMARK "DI2" 
487c			;			CALLMONITOR 
487c			;		endif 
487c			 
487c cd 2d 06				call storage_findnextid 
487f			 
487f			;		if DEBUG_FORTH_WORDS 
487f			;			DMARK "DI3" 
487f			;			CALLMONITOR 
487f			;		endif 
487f			 
487f					; if found hl will be non zero 
487f			 
487f cd 32 0d				call ishlzero 
4882			;		ld a, l 
4882			;		add h 
4882			; 
4882			;		cp 0 
4882 28 59				jr z, .dirnotfound 
4884			 
4884					; increase count 
4884			 
4884 c1					pop bc	 
4885 0c					inc c 
4886 c5					push bc 
4887					 
4887			 
4887					; get file header and push the file name 
4887			 
4887 11 62 f8				ld de, store_page 
488a cd 0c 03				call storage_read_block 
488d			 
488d					; push file id to stack 
488d				 
488d 3a 62 f8				ld a, (store_page) 
4890 26 00				ld h, 0 
4892 6f					ld l, a 
4893 cd 1f 1c				call forth_push_numhl 
4896			 
4896					; push extent count to stack  
4896				 
4896 3a 64 f8				ld a, (store_page+2) 
4899 26 00				ld h, 0 
489b 6f					ld l, a 
489c cd 1f 1c				call forth_push_numhl 
489f			 
489f					; push file name 
489f			 
489f 21 65 f8				ld hl, store_page+3 
48a2					if DEBUG_FORTH_WORDS 
48a2						DMARK "DI5" 
48a2 f5				push af  
48a3 3a b7 48			ld a, (.dmark)  
48a6 32 77 fb			ld (debug_mark),a  
48a9 3a b8 48			ld a, (.dmark+1)  
48ac 32 78 fb			ld (debug_mark+1),a  
48af 3a b9 48			ld a, (.dmark+2)  
48b2 32 79 fb			ld (debug_mark+2),a  
48b5 18 03			jr .pastdmark  
48b7 ..			.dmark: db "DI5"  
48ba f1			.pastdmark: pop af  
48bb			endm  
# End of macro DMARK
48bb						CALLMONITOR 
48bb cd 92 16			call break_point_state  
48be				endm  
# End of macro CALLMONITOR
48be					endif 
48be cd 8d 1c				call forth_push_str 
48c1					if DEBUG_FORTH_WORDS 
48c1						DMARK "DI6" 
48c1 f5				push af  
48c2 3a d6 48			ld a, (.dmark)  
48c5 32 77 fb			ld (debug_mark),a  
48c8 3a d7 48			ld a, (.dmark+1)  
48cb 32 78 fb			ld (debug_mark+1),a  
48ce 3a d8 48			ld a, (.dmark+2)  
48d1 32 79 fb			ld (debug_mark+2),a  
48d4 18 03			jr .pastdmark  
48d6 ..			.dmark: db "DI6"  
48d9 f1			.pastdmark: pop af  
48da			endm  
# End of macro DMARK
48da						CALLMONITOR 
48da cd 92 16			call break_point_state  
48dd				endm  
# End of macro CALLMONITOR
48dd					endif 
48dd			.dirnotfound: 
48dd c1					pop bc     
48de 10 95				djnz .diritem 
48e0				 
48e0			.dirdone:	 
48e0					if DEBUG_FORTH_WORDS 
48e0						DMARK "DI7" 
48e0 f5				push af  
48e1 3a f5 48			ld a, (.dmark)  
48e4 32 77 fb			ld (debug_mark),a  
48e7 3a f6 48			ld a, (.dmark+1)  
48ea 32 78 fb			ld (debug_mark+1),a  
48ed 3a f7 48			ld a, (.dmark+2)  
48f0 32 79 fb			ld (debug_mark+2),a  
48f3 18 03			jr .pastdmark  
48f5 ..			.dmark: db "DI7"  
48f8 f1			.pastdmark: pop af  
48f9			endm  
# End of macro DMARK
48f9						CALLMONITOR 
48f9 cd 92 16			call break_point_state  
48fc				endm  
# End of macro CALLMONITOR
48fc					endif 
48fc			 
48fc					; push a count of the dir items found 
48fc			 
48fc 26 00				ld h, 0 
48fe 69					ld l, c 
48ff cd 1f 1c				call forth_push_numhl 
4902			 
4902					; push the bank label 
4902			 
4902 cd bd 03				call storage_get_block_0 
4905			 
4905				 
4905 21 65 f8		 		ld hl, store_page+3 
4908			 
4908					if DEBUG_FORTH_WORDS 
4908						DMARK "DI8" 
4908 f5				push af  
4909 3a 1d 49			ld a, (.dmark)  
490c 32 77 fb			ld (debug_mark),a  
490f 3a 1e 49			ld a, (.dmark+1)  
4912 32 78 fb			ld (debug_mark+1),a  
4915 3a 1f 49			ld a, (.dmark+2)  
4918 32 79 fb			ld (debug_mark+2),a  
491b 18 03			jr .pastdmark  
491d ..			.dmark: db "DI8"  
4920 f1			.pastdmark: pop af  
4921			endm  
# End of macro DMARK
4921						CALLMONITOR 
4921 cd 92 16			call break_point_state  
4924				endm  
# End of macro CALLMONITOR
4924					endif 
4924 cd 8d 1c				call forth_push_str 
4927			 
4927			 
4927				 
4927					NEXTW 
4927 c3 88 1f			jp macro_next 
492a				endm 
# End of macro NEXTW
492a			.SAVE: 
492a			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
492a			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
492a			;		NEXTW 
492a			;.LOAD: 
492a			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
492a			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
492a			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
492a			;; > > The LOAD command can not be used in any user words or compound lines. 
492a			; 
492a			;		; store_openext use it. If zero it is EOF 
492a			; 
492a			;		; read block from current stream id 
492a			;		; if the block does not contain zero term keep reading blocks until zero found 
492a			;		; push the block to stack 
492a			;		; save the block id to stream 
492a			; 
492a			; 
492a			;		FORTH_DSP_VALUEHL 
492a			; 
492a			;;		push hl 
492a			; 
492a			;	if DEBUG_STORESE 
492a			;		DMARK "LOA" 
492a			;		CALLMONITOR 
492a			;	endif 
492a			;		FORTH_DSP_POP 
492a			; 
492a			;;		pop hl 
492a			; 
492a			;		ld h, l 
492a			;		ld l, 0 
492a			; 
492a			;		push hl     ; stack holds current file id and extent to work with 
492a			; 
492a			; 
492a			;		ld de, store_page      ; get block zero of file 
492a			;	if DEBUG_STORESE 
492a			;		DMARK "LO0" 
492a			;		CALLMONITOR 
492a			;	endif 
492a			;		call storage_read 
492a			; 
492a			;		ld a, (store_page+2)    ; max extents for this file 
492a			;		ld  (store_openmaxext),a   ; get our limit 
492a			; 
492a			;	if DEBUG_STORESE 
492a			;		DMARK "LOE" 
492a			;		CALLMONITOR 
492a			;	endif 
492a			; 
492a			;; TODO dont know why max extents are not present 
492a			;;		cp 0 
492a			;;		jp z, .loadeof     ; dont read past eof 
492a			; 
492a			;;		ld a, 1   ; start from the head of the file 
492a			; 
492a			;.loadline:	pop hl 
492a			;		inc hl 
492a			;		ld  a, (store_openmaxext)   ; get our limit 
492a			;	if DEBUG_STORESE 
492a			;		DMARK "LOx" 
492a			;		CALLMONITOR 
492a			;	endif 
492a			;		inc a 
492a			;		cp l 
492a			;		jp z, .loadeof 
492a			;		push hl    ; save current extent 
492a			; 
492a			;		ld de, store_page 
492a			; 
492a			;	if DEBUG_STORESE 
492a			;		DMARK "LO1" 
492a			;		CALLMONITOR 
492a			;	endif 
492a			;		call storage_read 
492a			; 
492a			;	if DEBUG_STORESE 
492a			;		DMARK "LO2" 
492a			;		CALLMONITOR 
492a			;	endif 
492a			;	call ishlzero 
492a			;	ld a, l 
492a			;	add h 
492a			;	cp 0 
492a			;	jr z, .loadeof 
492a			; 
492a			;	; not eof so hl should point to data to exec 
492a			; 
492a			;	; will need to add the FORTH_END_BUFFER flag 
492a			 ; 
492a			;	ld hl, store_page+2 
492a			;	ld bc, 255 
492a			;	ld a, 0 
492a			;	cpir 
492a			;	if DEBUG_STORESE 
492a			;		DMARK "LOt" 
492a			;		CALLMONITOR 
492a			;	endif 
492a			;	dec hl 
492a			;	ld a, ' ' 
492a			;	ld (hl), a 
492a			;	inc hl 
492a			;	ld (hl), a 
492a			;	inc hl 
492a			;	ld (hl), a 
492a			;	inc hl 
492a			;	ld a, FORTH_END_BUFFER 
492a			;	ld (hl), a 
492a			; 
492a			;	; TODO handle more than a single block read 
492a			; 
492a			; 
492a			;	ld hl, store_page+2 
492a			; 
492a			;	ld (os_tok_ptr), hl 
492a			; 
492a			;	if DEBUG_STORESE 
492a			;		DMARK "LO3" 
492a			;		CALLMONITOR 
492a			;	endif 
492a			; 
492a			;	call forthparse 
492a			;	call forthexec 
492a			;	call forthexec_cleanup 
492a			; 
492a			;	; go to next extent 
492a			; 
492a			;	; get next block  or mark as eof 
492a			;	jp .loadline 
492a			; 
492a			; 
492a			; 
492a			;	       NEXTW 
492a			;.loadeof:	ld a, 0 
492a			;		ld (store_openext), a 
492a			; 
492a			;	if DEBUG_STORESE 
492a			;		DMARK "LOF" 
492a			;		CALLMONITOR 
492a			;	endif 
492a			;		ret 
492a			;		;NEXTW 
492a			;.BSAVE:   
492a			; 
492a			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
492a			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
492a			;		NEXTW 
492a			;.BLOAD: 
492a			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
492a			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
492a			;		NEXTW 
492a			;;;; counter gap 
492a			 
492a			 
492a			.SEO: 
492a				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
492a 64				db WORD_SYS_CORE+80             
492b 49 49			dw .SEI            
492d 04				db 3 + 1 
492e .. 00			db "SEO",0              
4932				endm 
# End of macro CWHEAD
4932			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4932			 
4932					; get port 
4932			 
4932					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4932 cd 16 1e			call macro_dsp_valuehl 
4935				endm 
# End of macro FORTH_DSP_VALUEHL
4935			 
4935 e5					push hl    ; u2 - byte 
4936			 
4936					; destroy value TOS 
4936			 
4936					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4936 cd ce 1e			call macro_forth_dsp_pop 
4939				endm 
# End of macro FORTH_DSP_POP
4939			 
4939					; get byte to send 
4939			 
4939					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4939 cd 16 1e			call macro_dsp_valuehl 
493c				endm 
# End of macro FORTH_DSP_VALUEHL
493c			 
493c e5					push hl    ; u1 - addr 
493d			 
493d					; destroy value TOS 
493d			 
493d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
493d cd ce 1e			call macro_forth_dsp_pop 
4940				endm 
# End of macro FORTH_DSP_POP
4940			 
4940					; one value on hl get other one back 
4940			 
4940 d1					pop de   ; u1 - byte 
4941			 
4941 e1					pop hl   ; u2 - addr 
4942			 
4942					; TODO Send SPI byte 
4942			 
4942			 
4942 7b					ld a, e 
4943 cd ea 01				call se_writebyte 
4946			 
4946					 
4946			 
4946					NEXTW 
4946 c3 88 1f			jp macro_next 
4949				endm 
# End of macro NEXTW
4949			 
4949			.SEI: 
4949				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4949 65				db WORD_SYS_CORE+81             
494a 63 49			dw .SFREE            
494c 04				db 3 + 1 
494d .. 00			db "SEI",0              
4951				endm 
# End of macro CWHEAD
4951			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4951			 
4951					; get port 
4951			 
4951					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4951 cd 16 1e			call macro_dsp_valuehl 
4954				endm 
# End of macro FORTH_DSP_VALUEHL
4954			 
4954			;		push hl 
4954			 
4954					; destroy value TOS 
4954			 
4954					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4954 cd ce 1e			call macro_forth_dsp_pop 
4957				endm 
# End of macro FORTH_DSP_POP
4957			 
4957					; one value on hl get other one back 
4957			 
4957			;		pop hl 
4957			 
4957			 
4957					; TODO Get SPI byte 
4957			 
4957 cd 8c 02				call se_readbyte 
495a			 
495a 26 00				ld h, 0 
495c 6f					ld l, a 
495d cd 1f 1c				call forth_push_numhl 
4960			 
4960					NEXTW 
4960 c3 88 1f			jp macro_next 
4963				endm 
# End of macro NEXTW
4963			 
4963			.SFREE: 
4963				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4963 67				db WORD_SYS_CORE+83             
4964 92 49			dw .SIZE            
4966 06				db 5 + 1 
4967 .. 00			db "FFREE",0              
496d				endm 
# End of macro CWHEAD
496d			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
496d					if DEBUG_FORTH_WORDS_KEY 
496d						DMARK "FFR" 
496d f5				push af  
496e 3a 82 49			ld a, (.dmark)  
4971 32 77 fb			ld (debug_mark),a  
4974 3a 83 49			ld a, (.dmark+1)  
4977 32 78 fb			ld (debug_mark+1),a  
497a 3a 84 49			ld a, (.dmark+2)  
497d 32 79 fb			ld (debug_mark+2),a  
4980 18 03			jr .pastdmark  
4982 ..			.dmark: db "FFR"  
4985 f1			.pastdmark: pop af  
4986			endm  
# End of macro DMARK
4986						CALLMONITOR 
4986 cd 92 16			call break_point_state  
4989				endm  
# End of macro CALLMONITOR
4989					endif 
4989			 
4989 cd c7 06				call storage_freeblocks 
498c			 
498c cd 1f 1c				call forth_push_numhl 
498f			 
498f				       NEXTW 
498f c3 88 1f			jp macro_next 
4992				endm 
# End of macro NEXTW
4992			.SIZE: 
4992				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4992 67				db WORD_SYS_CORE+83             
4993 c6 49			dw .CREATE            
4995 05				db 4 + 1 
4996 .. 00			db "SIZE",0              
499b				endm 
# End of macro CWHEAD
499b			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
499b					if DEBUG_FORTH_WORDS_KEY 
499b						DMARK "SIZ" 
499b f5				push af  
499c 3a b0 49			ld a, (.dmark)  
499f 32 77 fb			ld (debug_mark),a  
49a2 3a b1 49			ld a, (.dmark+1)  
49a5 32 78 fb			ld (debug_mark+1),a  
49a8 3a b2 49			ld a, (.dmark+2)  
49ab 32 79 fb			ld (debug_mark+2),a  
49ae 18 03			jr .pastdmark  
49b0 ..			.dmark: db "SIZ"  
49b3 f1			.pastdmark: pop af  
49b4			endm  
# End of macro DMARK
49b4						CALLMONITOR 
49b4 cd 92 16			call break_point_state  
49b7				endm  
# End of macro CALLMONITOR
49b7					endif 
49b7			 
49b7					FORTH_DSP_VALUEHL 
49b7 cd 16 1e			call macro_dsp_valuehl 
49ba				endm 
# End of macro FORTH_DSP_VALUEHL
49ba			;		push hl 
49ba					FORTH_DSP_POP 
49ba cd ce 1e			call macro_forth_dsp_pop 
49bd				endm 
# End of macro FORTH_DSP_POP
49bd			;		pop hl 
49bd cd 3b 03				call storage_file_size 
49c0			 
49c0 cd 1f 1c				call forth_push_numhl 
49c3			  
49c3			 
49c3				       NEXTW 
49c3 c3 88 1f			jp macro_next 
49c6				endm 
# End of macro NEXTW
49c6			 
49c6			.CREATE: 
49c6				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
49c6 68				db WORD_SYS_CORE+84             
49c7 34 4a			dw .APPEND            
49c9 07				db 6 + 1 
49ca .. 00			db "CREATE",0              
49d1				endm 
# End of macro CWHEAD
49d1			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
49d1			; | | e.g.  
49d1			; | | TestProgram CREATE 
49d1			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
49d1			; | |  
49d1			; | | Max file IDs are 255. 
49d1			; | |  
49d1					 
49d1					if DEBUG_FORTH_WORDS_KEY 
49d1						DMARK "CRT" 
49d1 f5				push af  
49d2 3a e6 49			ld a, (.dmark)  
49d5 32 77 fb			ld (debug_mark),a  
49d8 3a e7 49			ld a, (.dmark+1)  
49db 32 78 fb			ld (debug_mark+1),a  
49de 3a e8 49			ld a, (.dmark+2)  
49e1 32 79 fb			ld (debug_mark+2),a  
49e4 18 03			jr .pastdmark  
49e6 ..			.dmark: db "CRT"  
49e9 f1			.pastdmark: pop af  
49ea			endm  
# End of macro DMARK
49ea						CALLMONITOR 
49ea cd 92 16			call break_point_state  
49ed				endm  
# End of macro CALLMONITOR
49ed					endif 
49ed			;		call storage_get_block_0 
49ed			 
49ed					; TODO pop hl 
49ed			 
49ed					;v5 FORTH_DSP_VALUE 
49ed					FORTH_DSP_VALUE 
49ed cd ff 1d			call macro_forth_dsp_value 
49f0				endm 
# End of macro FORTH_DSP_VALUE
49f0			 
49f0				if DEBUG_STORESE 
49f0					DMARK "CR1" 
49f0 f5				push af  
49f1 3a 05 4a			ld a, (.dmark)  
49f4 32 77 fb			ld (debug_mark),a  
49f7 3a 06 4a			ld a, (.dmark+1)  
49fa 32 78 fb			ld (debug_mark+1),a  
49fd 3a 07 4a			ld a, (.dmark+2)  
4a00 32 79 fb			ld (debug_mark+2),a  
4a03 18 03			jr .pastdmark  
4a05 ..			.dmark: db "CR1"  
4a08 f1			.pastdmark: pop af  
4a09			endm  
# End of macro DMARK
4a09					CALLMONITOR 
4a09 cd 92 16			call break_point_state  
4a0c				endm  
# End of macro CALLMONITOR
4a0c				endif 
4a0c			;		push hl 
4a0c			;		FORTH_DSP_POP 
4a0c			;		pop hl 
4a0c			 
4a0c			;		inc hl   ; move past the type marker 
4a0c			 
4a0c cd fd 06				call storage_create 
4a0f			 
4a0f				if DEBUG_STORESE 
4a0f					DMARK "CT1" 
4a0f f5				push af  
4a10 3a 24 4a			ld a, (.dmark)  
4a13 32 77 fb			ld (debug_mark),a  
4a16 3a 25 4a			ld a, (.dmark+1)  
4a19 32 78 fb			ld (debug_mark+1),a  
4a1c 3a 26 4a			ld a, (.dmark+2)  
4a1f 32 79 fb			ld (debug_mark+2),a  
4a22 18 03			jr .pastdmark  
4a24 ..			.dmark: db "CT1"  
4a27 f1			.pastdmark: pop af  
4a28			endm  
# End of macro DMARK
4a28					CALLMONITOR 
4a28 cd 92 16			call break_point_state  
4a2b				endm  
# End of macro CALLMONITOR
4a2b				endif 
4a2b			;		push hl 
4a2b					FORTH_DSP_POP 
4a2b cd ce 1e			call macro_forth_dsp_pop 
4a2e				endm 
# End of macro FORTH_DSP_POP
4a2e			;		pop hl 
4a2e					; push file id to stack 
4a2e cd 1f 1c				call forth_push_numhl 
4a31			 
4a31			 
4a31			 
4a31				       NEXTW 
4a31 c3 88 1f			jp macro_next 
4a34				endm 
# End of macro NEXTW
4a34			 
4a34			.APPEND: 
4a34				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4a34 69				db WORD_SYS_CORE+85             
4a35 c5 4a			dw .SDEL            
4a37 07				db 6 + 1 
4a38 .. 00			db "APPEND",0              
4a3f				endm 
# End of macro CWHEAD
4a3f			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4a3f			; | | e.g. 
4a3f			; | | Test CREATE      -> $01 
4a3f			; | | "A string to add to file" $01 APPEND 
4a3f			; | |  
4a3f			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4a3f					if DEBUG_FORTH_WORDS_KEY 
4a3f						DMARK "APP" 
4a3f f5				push af  
4a40 3a 54 4a			ld a, (.dmark)  
4a43 32 77 fb			ld (debug_mark),a  
4a46 3a 55 4a			ld a, (.dmark+1)  
4a49 32 78 fb			ld (debug_mark+1),a  
4a4c 3a 56 4a			ld a, (.dmark+2)  
4a4f 32 79 fb			ld (debug_mark+2),a  
4a52 18 03			jr .pastdmark  
4a54 ..			.dmark: db "APP"  
4a57 f1			.pastdmark: pop af  
4a58			endm  
# End of macro DMARK
4a58						CALLMONITOR 
4a58 cd 92 16			call break_point_state  
4a5b				endm  
# End of macro CALLMONITOR
4a5b					endif 
4a5b			 
4a5b					FORTH_DSP_VALUEHL 
4a5b cd 16 1e			call macro_dsp_valuehl 
4a5e				endm 
# End of macro FORTH_DSP_VALUEHL
4a5e e5					push hl 	; save file id 
4a5f			 
4a5f				if DEBUG_STORESE 
4a5f					DMARK "AP1" 
4a5f f5				push af  
4a60 3a 74 4a			ld a, (.dmark)  
4a63 32 77 fb			ld (debug_mark),a  
4a66 3a 75 4a			ld a, (.dmark+1)  
4a69 32 78 fb			ld (debug_mark+1),a  
4a6c 3a 76 4a			ld a, (.dmark+2)  
4a6f 32 79 fb			ld (debug_mark+2),a  
4a72 18 03			jr .pastdmark  
4a74 ..			.dmark: db "AP1"  
4a77 f1			.pastdmark: pop af  
4a78			endm  
# End of macro DMARK
4a78					CALLMONITOR 
4a78 cd 92 16			call break_point_state  
4a7b				endm  
# End of macro CALLMONITOR
4a7b				endif 
4a7b					FORTH_DSP_POP 
4a7b cd ce 1e			call macro_forth_dsp_pop 
4a7e				endm 
# End of macro FORTH_DSP_POP
4a7e			 
4a7e					FORTH_DSP_VALUEHL 
4a7e cd 16 1e			call macro_dsp_valuehl 
4a81				endm 
# End of macro FORTH_DSP_VALUEHL
4a81					;v5 FORTH_DSP_VALUE 
4a81 e5					push hl 	; save ptr to string to save 
4a82			 
4a82				if DEBUG_STORESE 
4a82					DMARK "AP1" 
4a82 f5				push af  
4a83 3a 97 4a			ld a, (.dmark)  
4a86 32 77 fb			ld (debug_mark),a  
4a89 3a 98 4a			ld a, (.dmark+1)  
4a8c 32 78 fb			ld (debug_mark+1),a  
4a8f 3a 99 4a			ld a, (.dmark+2)  
4a92 32 79 fb			ld (debug_mark+2),a  
4a95 18 03			jr .pastdmark  
4a97 ..			.dmark: db "AP1"  
4a9a f1			.pastdmark: pop af  
4a9b			endm  
# End of macro DMARK
4a9b					CALLMONITOR 
4a9b cd 92 16			call break_point_state  
4a9e				endm  
# End of macro CALLMONITOR
4a9e				endif 
4a9e					FORTH_DSP_POP 
4a9e cd ce 1e			call macro_forth_dsp_pop 
4aa1				endm 
# End of macro FORTH_DSP_POP
4aa1			 
4aa1 d1					pop de 
4aa2 e1					pop hl 
4aa3				if DEBUG_STORESE 
4aa3					DMARK "AP2" 
4aa3 f5				push af  
4aa4 3a b8 4a			ld a, (.dmark)  
4aa7 32 77 fb			ld (debug_mark),a  
4aaa 3a b9 4a			ld a, (.dmark+1)  
4aad 32 78 fb			ld (debug_mark+1),a  
4ab0 3a ba 4a			ld a, (.dmark+2)  
4ab3 32 79 fb			ld (debug_mark+2),a  
4ab6 18 03			jr .pastdmark  
4ab8 ..			.dmark: db "AP2"  
4abb f1			.pastdmark: pop af  
4abc			endm  
# End of macro DMARK
4abc					CALLMONITOR 
4abc cd 92 16			call break_point_state  
4abf				endm  
# End of macro CALLMONITOR
4abf				endif 
4abf					;inc de ; skip var type indicator 
4abf			 
4abf					; TODO how to append numerics???? 
4abf			 
4abf cd d7 08				call storage_append		 
4ac2			 
4ac2				       NEXTW 
4ac2 c3 88 1f			jp macro_next 
4ac5				endm 
# End of macro NEXTW
4ac5			.SDEL: 
4ac5				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4ac5 6a				db WORD_SYS_CORE+86             
4ac6 11 4b			dw .OPEN            
4ac8 05				db 4 + 1 
4ac9 .. 00			db "ERA",0              
4acd				endm 
# End of macro CWHEAD
4acd			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4acd					FORTH_DSP_VALUEHL 
4acd cd 16 1e			call macro_dsp_valuehl 
4ad0				endm 
# End of macro FORTH_DSP_VALUEHL
4ad0			;		push hl 	; save file id 
4ad0			 
4ad0					if DEBUG_FORTH_WORDS_KEY 
4ad0						DMARK "ERA" 
4ad0 f5				push af  
4ad1 3a e5 4a			ld a, (.dmark)  
4ad4 32 77 fb			ld (debug_mark),a  
4ad7 3a e6 4a			ld a, (.dmark+1)  
4ada 32 78 fb			ld (debug_mark+1),a  
4add 3a e7 4a			ld a, (.dmark+2)  
4ae0 32 79 fb			ld (debug_mark+2),a  
4ae3 18 03			jr .pastdmark  
4ae5 ..			.dmark: db "ERA"  
4ae8 f1			.pastdmark: pop af  
4ae9			endm  
# End of macro DMARK
4ae9						CALLMONITOR 
4ae9 cd 92 16			call break_point_state  
4aec				endm  
# End of macro CALLMONITOR
4aec					endif 
4aec				if DEBUG_STORESE 
4aec					DMARK "ER1" 
4aec f5				push af  
4aed 3a 01 4b			ld a, (.dmark)  
4af0 32 77 fb			ld (debug_mark),a  
4af3 3a 02 4b			ld a, (.dmark+1)  
4af6 32 78 fb			ld (debug_mark+1),a  
4af9 3a 03 4b			ld a, (.dmark+2)  
4afc 32 79 fb			ld (debug_mark+2),a  
4aff 18 03			jr .pastdmark  
4b01 ..			.dmark: db "ER1"  
4b04 f1			.pastdmark: pop af  
4b05			endm  
# End of macro DMARK
4b05					CALLMONITOR 
4b05 cd 92 16			call break_point_state  
4b08				endm  
# End of macro CALLMONITOR
4b08				endif 
4b08					FORTH_DSP_POP 
4b08 cd ce 1e			call macro_forth_dsp_pop 
4b0b				endm 
# End of macro FORTH_DSP_POP
4b0b			 
4b0b			;		pop hl 
4b0b			 
4b0b cd 4c 05				call storage_erase 
4b0e				       NEXTW 
4b0e c3 88 1f			jp macro_next 
4b11				endm 
# End of macro NEXTW
4b11			 
4b11			.OPEN: 
4b11				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4b11 6b				db WORD_SYS_CORE+87             
4b12 98 4b			dw .READ            
4b14 05				db 4 + 1 
4b15 .. 00			db "OPEN",0              
4b1a				endm 
# End of macro CWHEAD
4b1a			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4b1a			; | | e.g. 
4b1a			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b1a			 
4b1a					if DEBUG_FORTH_WORDS_KEY 
4b1a						DMARK "OPN" 
4b1a f5				push af  
4b1b 3a 2f 4b			ld a, (.dmark)  
4b1e 32 77 fb			ld (debug_mark),a  
4b21 3a 30 4b			ld a, (.dmark+1)  
4b24 32 78 fb			ld (debug_mark+1),a  
4b27 3a 31 4b			ld a, (.dmark+2)  
4b2a 32 79 fb			ld (debug_mark+2),a  
4b2d 18 03			jr .pastdmark  
4b2f ..			.dmark: db "OPN"  
4b32 f1			.pastdmark: pop af  
4b33			endm  
# End of macro DMARK
4b33						CALLMONITOR 
4b33 cd 92 16			call break_point_state  
4b36				endm  
# End of macro CALLMONITOR
4b36					endif 
4b36					; TODO handle multiple file opens 
4b36			 
4b36 3e 01			       	ld a, 1 
4b38 32 59 f8				ld (store_openext), a 
4b3b			 
4b3b					; get max extents for this file 
4b3b				 
4b3b								 
4b3b					FORTH_DSP_VALUEHL 
4b3b cd 16 1e			call macro_dsp_valuehl 
4b3e				endm 
# End of macro FORTH_DSP_VALUEHL
4b3e			 
4b3e 65					ld h, l 
4b3f 2e 00				ld l, 0 
4b41			 
4b41				if DEBUG_STORESE 
4b41					DMARK "OPN" 
4b41 f5				push af  
4b42 3a 56 4b			ld a, (.dmark)  
4b45 32 77 fb			ld (debug_mark),a  
4b48 3a 57 4b			ld a, (.dmark+1)  
4b4b 32 78 fb			ld (debug_mark+1),a  
4b4e 3a 58 4b			ld a, (.dmark+2)  
4b51 32 79 fb			ld (debug_mark+2),a  
4b54 18 03			jr .pastdmark  
4b56 ..			.dmark: db "OPN"  
4b59 f1			.pastdmark: pop af  
4b5a			endm  
# End of macro DMARK
4b5a					CALLMONITOR 
4b5a cd 92 16			call break_point_state  
4b5d				endm  
# End of macro CALLMONITOR
4b5d				endif 
4b5d			;		push hl 
4b5d					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b5d cd ce 1e			call macro_forth_dsp_pop 
4b60				endm 
# End of macro FORTH_DSP_POP
4b60			;		pop hl 
4b60						 
4b60 11 62 f8				ld de, store_page      ; get block zero of file 
4b63 cd 51 08				call storage_read 
4b66			 
4b66			 
4b66 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4b69 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4b6c					 
4b6c				if DEBUG_STORESE 
4b6c					DMARK "OPx" 
4b6c f5				push af  
4b6d 3a 81 4b			ld a, (.dmark)  
4b70 32 77 fb			ld (debug_mark),a  
4b73 3a 82 4b			ld a, (.dmark+1)  
4b76 32 78 fb			ld (debug_mark+1),a  
4b79 3a 83 4b			ld a, (.dmark+2)  
4b7c 32 79 fb			ld (debug_mark+2),a  
4b7f 18 03			jr .pastdmark  
4b81 ..			.dmark: db "OPx"  
4b84 f1			.pastdmark: pop af  
4b85			endm  
# End of macro DMARK
4b85					CALLMONITOR 
4b85 cd 92 16			call break_point_state  
4b88				endm  
# End of macro CALLMONITOR
4b88				endif 
4b88 fe 00				cp 0 
4b8a 20 03				jr nz, .skipopeneof 
4b8c					; have opened an empty file 
4b8c					 
4b8c 32 59 f8				ld (store_openext), a 
4b8f			 
4b8f			.skipopeneof: 
4b8f			 
4b8f 6f					ld l, a 
4b90 26 00				ld h, 0 
4b92 cd 1f 1c				call forth_push_numhl 
4b95			 
4b95			 
4b95				       NEXTW 
4b95 c3 88 1f			jp macro_next 
4b98				endm 
# End of macro NEXTW
4b98			.READ: 
4b98				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b98 6c				db WORD_SYS_CORE+88             
4b99 df 4c			dw .EOF            
4b9b 05				db 4 + 1 
4b9c .. 00			db "READ",0              
4ba1				endm 
# End of macro CWHEAD
4ba1			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4ba1			; | | e.g. 
4ba1			; | | $01 OPEN $01 DO $01 READ . LOOP 
4ba1			 
4ba1					if DEBUG_FORTH_WORDS_KEY 
4ba1						DMARK "REA" 
4ba1 f5				push af  
4ba2 3a b6 4b			ld a, (.dmark)  
4ba5 32 77 fb			ld (debug_mark),a  
4ba8 3a b7 4b			ld a, (.dmark+1)  
4bab 32 78 fb			ld (debug_mark+1),a  
4bae 3a b8 4b			ld a, (.dmark+2)  
4bb1 32 79 fb			ld (debug_mark+2),a  
4bb4 18 03			jr .pastdmark  
4bb6 ..			.dmark: db "REA"  
4bb9 f1			.pastdmark: pop af  
4bba			endm  
# End of macro DMARK
4bba						CALLMONITOR 
4bba cd 92 16			call break_point_state  
4bbd				endm  
# End of macro CALLMONITOR
4bbd					endif 
4bbd					; store_openext use it. If zero it is EOF 
4bbd			 
4bbd					; read block from current stream id 
4bbd					; if the block does not contain zero term keep reading blocks until zero found 
4bbd					; push the block to stack 
4bbd					; save the block id to stream 
4bbd			 
4bbd			 
4bbd					FORTH_DSP_VALUEHL 
4bbd cd 16 1e			call macro_dsp_valuehl 
4bc0				endm 
# End of macro FORTH_DSP_VALUEHL
4bc0			 
4bc0			;		push hl 
4bc0			 
4bc0				if DEBUG_STORESE 
4bc0					DMARK "REA" 
4bc0 f5				push af  
4bc1 3a d5 4b			ld a, (.dmark)  
4bc4 32 77 fb			ld (debug_mark),a  
4bc7 3a d6 4b			ld a, (.dmark+1)  
4bca 32 78 fb			ld (debug_mark+1),a  
4bcd 3a d7 4b			ld a, (.dmark+2)  
4bd0 32 79 fb			ld (debug_mark+2),a  
4bd3 18 03			jr .pastdmark  
4bd5 ..			.dmark: db "REA"  
4bd8 f1			.pastdmark: pop af  
4bd9			endm  
# End of macro DMARK
4bd9					CALLMONITOR 
4bd9 cd 92 16			call break_point_state  
4bdc				endm  
# End of macro CALLMONITOR
4bdc				endif 
4bdc					FORTH_DSP_POP 
4bdc cd ce 1e			call macro_forth_dsp_pop 
4bdf				endm 
# End of macro FORTH_DSP_POP
4bdf			 
4bdf			;		pop hl 
4bdf				 
4bdf 65					ld h,l 
4be0			 
4be0 3a 59 f8				ld a, (store_openext) 
4be3 6f					ld l, a 
4be4					 
4be4 fe 00				cp 0 
4be6 ca b1 4c				jp z, .ateof     ; dont read past eof 
4be9			 
4be9			 
4be9 11 62 f8				ld de, store_page 
4bec				if DEBUG_STORESE 
4bec					DMARK "RE1" 
4bec f5				push af  
4bed 3a 01 4c			ld a, (.dmark)  
4bf0 32 77 fb			ld (debug_mark),a  
4bf3 3a 02 4c			ld a, (.dmark+1)  
4bf6 32 78 fb			ld (debug_mark+1),a  
4bf9 3a 03 4c			ld a, (.dmark+2)  
4bfc 32 79 fb			ld (debug_mark+2),a  
4bff 18 03			jr .pastdmark  
4c01 ..			.dmark: db "RE1"  
4c04 f1			.pastdmark: pop af  
4c05			endm  
# End of macro DMARK
4c05					CALLMONITOR 
4c05 cd 92 16			call break_point_state  
4c08				endm  
# End of macro CALLMONITOR
4c08				endif 
4c08 cd 51 08				call storage_read 
4c0b			 
4c0b				if DEBUG_STORESE 
4c0b					DMARK "RE2" 
4c0b f5				push af  
4c0c 3a 20 4c			ld a, (.dmark)  
4c0f 32 77 fb			ld (debug_mark),a  
4c12 3a 21 4c			ld a, (.dmark+1)  
4c15 32 78 fb			ld (debug_mark+1),a  
4c18 3a 22 4c			ld a, (.dmark+2)  
4c1b 32 79 fb			ld (debug_mark+2),a  
4c1e 18 03			jr .pastdmark  
4c20 ..			.dmark: db "RE2"  
4c23 f1			.pastdmark: pop af  
4c24			endm  
# End of macro DMARK
4c24					CALLMONITOR 
4c24 cd 92 16			call break_point_state  
4c27				endm  
# End of macro CALLMONITOR
4c27				endif 
4c27 cd 32 0d			call ishlzero 
4c2a			;	ld a, l 
4c2a			;	add h 
4c2a			;	cp 0 
4c2a ca b7 4c			jp z, .readeof 
4c2d			 
4c2d				; not eof so hl should point to data to push to stack 
4c2d			 
4c2d				if DEBUG_STORESE 
4c2d					DMARK "RE3" 
4c2d f5				push af  
4c2e 3a 42 4c			ld a, (.dmark)  
4c31 32 77 fb			ld (debug_mark),a  
4c34 3a 43 4c			ld a, (.dmark+1)  
4c37 32 78 fb			ld (debug_mark+1),a  
4c3a 3a 44 4c			ld a, (.dmark+2)  
4c3d 32 79 fb			ld (debug_mark+2),a  
4c40 18 03			jr .pastdmark  
4c42 ..			.dmark: db "RE3"  
4c45 f1			.pastdmark: pop af  
4c46			endm  
# End of macro DMARK
4c46					CALLMONITOR 
4c46 cd 92 16			call break_point_state  
4c49				endm  
# End of macro CALLMONITOR
4c49				endif 
4c49 cd 8d 1c			call forth_push_str 
4c4c			 
4c4c				if DEBUG_STORESE 
4c4c					DMARK "RE4" 
4c4c f5				push af  
4c4d 3a 61 4c			ld a, (.dmark)  
4c50 32 77 fb			ld (debug_mark),a  
4c53 3a 62 4c			ld a, (.dmark+1)  
4c56 32 78 fb			ld (debug_mark+1),a  
4c59 3a 63 4c			ld a, (.dmark+2)  
4c5c 32 79 fb			ld (debug_mark+2),a  
4c5f 18 03			jr .pastdmark  
4c61 ..			.dmark: db "RE4"  
4c64 f1			.pastdmark: pop af  
4c65			endm  
# End of macro DMARK
4c65					CALLMONITOR 
4c65 cd 92 16			call break_point_state  
4c68				endm  
# End of macro CALLMONITOR
4c68				endif 
4c68				; get next block  or mark as eof 
4c68			 
4c68 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4c6b 4f				ld c, a	 
4c6c 3a 59 f8			ld a, (store_openext) 
4c6f			 
4c6f				if DEBUG_STORESE 
4c6f					DMARK "RE5" 
4c6f f5				push af  
4c70 3a 84 4c			ld a, (.dmark)  
4c73 32 77 fb			ld (debug_mark),a  
4c76 3a 85 4c			ld a, (.dmark+1)  
4c79 32 78 fb			ld (debug_mark+1),a  
4c7c 3a 86 4c			ld a, (.dmark+2)  
4c7f 32 79 fb			ld (debug_mark+2),a  
4c82 18 03			jr .pastdmark  
4c84 ..			.dmark: db "RE5"  
4c87 f1			.pastdmark: pop af  
4c88			endm  
# End of macro DMARK
4c88					CALLMONITOR 
4c88 cd 92 16			call break_point_state  
4c8b				endm  
# End of macro CALLMONITOR
4c8b				endif 
4c8b b9				cp c 
4c8c 28 29			jr z, .readeof     ; at last extent 
4c8e			 
4c8e 3c					inc a 
4c8f 32 59 f8				ld (store_openext), a 
4c92			 
4c92				if DEBUG_STORESE 
4c92					DMARK "RE6" 
4c92 f5				push af  
4c93 3a a7 4c			ld a, (.dmark)  
4c96 32 77 fb			ld (debug_mark),a  
4c99 3a a8 4c			ld a, (.dmark+1)  
4c9c 32 78 fb			ld (debug_mark+1),a  
4c9f 3a a9 4c			ld a, (.dmark+2)  
4ca2 32 79 fb			ld (debug_mark+2),a  
4ca5 18 03			jr .pastdmark  
4ca7 ..			.dmark: db "RE6"  
4caa f1			.pastdmark: pop af  
4cab			endm  
# End of macro DMARK
4cab					CALLMONITOR 
4cab cd 92 16			call break_point_state  
4cae				endm  
# End of macro CALLMONITOR
4cae				endif 
4cae			 
4cae			 
4cae				       NEXTW 
4cae c3 88 1f			jp macro_next 
4cb1				endm 
# End of macro NEXTW
4cb1			.ateof: 
4cb1 21 db 4c				ld hl, .showeof 
4cb4 cd 8d 1c				call forth_push_str 
4cb7 3e 00		.readeof:	ld a, 0 
4cb9 32 59 f8				ld (store_openext), a 
4cbc			 
4cbc					 
4cbc				if DEBUG_STORESE 
4cbc					DMARK "REF" 
4cbc f5				push af  
4cbd 3a d1 4c			ld a, (.dmark)  
4cc0 32 77 fb			ld (debug_mark),a  
4cc3 3a d2 4c			ld a, (.dmark+1)  
4cc6 32 78 fb			ld (debug_mark+1),a  
4cc9 3a d3 4c			ld a, (.dmark+2)  
4ccc 32 79 fb			ld (debug_mark+2),a  
4ccf 18 03			jr .pastdmark  
4cd1 ..			.dmark: db "REF"  
4cd4 f1			.pastdmark: pop af  
4cd5			endm  
# End of macro DMARK
4cd5					CALLMONITOR 
4cd5 cd 92 16			call break_point_state  
4cd8				endm  
# End of macro CALLMONITOR
4cd8				endif 
4cd8				       NEXTW 
4cd8 c3 88 1f			jp macro_next 
4cdb				endm 
# End of macro NEXTW
4cdb			 
4cdb .. 00		.showeof:   db "eof", 0 
4cdf			 
4cdf			 
4cdf			.EOF: 
4cdf				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4cdf 6d				db WORD_SYS_CORE+89             
4ce0 20 4d			dw .FORMAT            
4ce2 04				db 3 + 1 
4ce3 .. 00			db "EOF",0              
4ce7				endm 
# End of macro CWHEAD
4ce7			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4ce7			; | | e.g. 
4ce7			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4ce7					; TODO if current block id for stream is zero then push true else false 
4ce7			 
4ce7					if DEBUG_FORTH_WORDS_KEY 
4ce7						DMARK "EOF" 
4ce7 f5				push af  
4ce8 3a fc 4c			ld a, (.dmark)  
4ceb 32 77 fb			ld (debug_mark),a  
4cee 3a fd 4c			ld a, (.dmark+1)  
4cf1 32 78 fb			ld (debug_mark+1),a  
4cf4 3a fe 4c			ld a, (.dmark+2)  
4cf7 32 79 fb			ld (debug_mark+2),a  
4cfa 18 03			jr .pastdmark  
4cfc ..			.dmark: db "EOF"  
4cff f1			.pastdmark: pop af  
4d00			endm  
# End of macro DMARK
4d00						CALLMONITOR 
4d00 cd 92 16			call break_point_state  
4d03				endm  
# End of macro CALLMONITOR
4d03					endif 
4d03			 
4d03					; TODO handlue multiple file streams 
4d03			 
4d03					FORTH_DSP_POP     ; for now just get rid of stream id 
4d03 cd ce 1e			call macro_forth_dsp_pop 
4d06				endm 
# End of macro FORTH_DSP_POP
4d06			 
4d06 2e 01				ld l, 1 
4d08 3a 58 f8				ld a, (store_openmaxext) 
4d0b fe 00				cp 0 
4d0d 28 09				jr  z, .eofdone   ; empty file 
4d0f 3a 59 f8				ld a, (store_openext) 
4d12 fe 00				cp 0 
4d14 28 02				jr  z, .eofdone 
4d16 2e 00				ld l, 0 
4d18 26 00		.eofdone:	ld h, 0 
4d1a cd 1f 1c				call forth_push_numhl 
4d1d			 
4d1d			 
4d1d				       NEXTW 
4d1d c3 88 1f			jp macro_next 
4d20				endm 
# End of macro NEXTW
4d20			 
4d20			.FORMAT: 
4d20				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4d20 6d				db WORD_SYS_CORE+89             
4d21 71 4d			dw .LABEL            
4d23 07				db 6 + 1 
4d24 .. 00			db "FORMAT",0              
4d2b				endm 
# End of macro CWHEAD
4d2b			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4d2b					; TODO if current block id for stream is zero then push true else false 
4d2b				 
4d2b				if DEBUG_STORESE 
4d2b					DMARK "FOR" 
4d2b f5				push af  
4d2c 3a 40 4d			ld a, (.dmark)  
4d2f 32 77 fb			ld (debug_mark),a  
4d32 3a 41 4d			ld a, (.dmark+1)  
4d35 32 78 fb			ld (debug_mark+1),a  
4d38 3a 42 4d			ld a, (.dmark+2)  
4d3b 32 79 fb			ld (debug_mark+2),a  
4d3e 18 03			jr .pastdmark  
4d40 ..			.dmark: db "FOR"  
4d43 f1			.pastdmark: pop af  
4d44			endm  
# End of macro DMARK
4d44					CALLMONITOR 
4d44 cd 92 16			call break_point_state  
4d47				endm  
# End of macro CALLMONITOR
4d47				endif 
4d47					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d47			 
4d47 21 01 00				ld hl, 1 
4d4a 3e 00				ld a, 0 
4d4c cd ea 01				call se_writebyte 
4d4f			 
4d4f				if DEBUG_STORESE 
4d4f					DMARK "FO0" 
4d4f f5				push af  
4d50 3a 64 4d			ld a, (.dmark)  
4d53 32 77 fb			ld (debug_mark),a  
4d56 3a 65 4d			ld a, (.dmark+1)  
4d59 32 78 fb			ld (debug_mark+1),a  
4d5c 3a 66 4d			ld a, (.dmark+2)  
4d5f 32 79 fb			ld (debug_mark+2),a  
4d62 18 03			jr .pastdmark  
4d64 ..			.dmark: db "FO0"  
4d67 f1			.pastdmark: pop af  
4d68			endm  
# End of macro DMARK
4d68					CALLMONITOR 
4d68 cd 92 16			call break_point_state  
4d6b				endm  
# End of macro CALLMONITOR
4d6b				endif 
4d6b					; force bank init 
4d6b			 
4d6b cd bd 03				call storage_get_block_0 
4d6e					 
4d6e				       NEXTW 
4d6e c3 88 1f			jp macro_next 
4d71				endm 
# End of macro NEXTW
4d71			.LABEL: 
4d71				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d71 6d				db WORD_SYS_CORE+89             
4d72 bf 4d			dw .STOREPAGE            
4d74 06				db 5 + 1 
4d75 .. 00			db "LABEL",0              
4d7b				endm 
# End of macro CWHEAD
4d7b			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d7b					; TODO test to see if bank is selected 
4d7b				 
4d7b					if DEBUG_FORTH_WORDS_KEY 
4d7b						DMARK "LBL" 
4d7b f5				push af  
4d7c 3a 90 4d			ld a, (.dmark)  
4d7f 32 77 fb			ld (debug_mark),a  
4d82 3a 91 4d			ld a, (.dmark+1)  
4d85 32 78 fb			ld (debug_mark+1),a  
4d88 3a 92 4d			ld a, (.dmark+2)  
4d8b 32 79 fb			ld (debug_mark+2),a  
4d8e 18 03			jr .pastdmark  
4d90 ..			.dmark: db "LBL"  
4d93 f1			.pastdmark: pop af  
4d94			endm  
# End of macro DMARK
4d94						CALLMONITOR 
4d94 cd 92 16			call break_point_state  
4d97				endm  
# End of macro CALLMONITOR
4d97					endif 
4d97			;	if DEBUG_STORESE 
4d97			;		DMARK "LBL" 
4d97			;		CALLMONITOR 
4d97			;	endif 
4d97					FORTH_DSP_VALUEHL 
4d97 cd 16 1e			call macro_dsp_valuehl 
4d9a				endm 
# End of macro FORTH_DSP_VALUEHL
4d9a					;v5FORTH_DSP_VALUE 
4d9a					 
4d9a			;		push hl 
4d9a					FORTH_DSP_POP 
4d9a cd ce 1e			call macro_forth_dsp_pop 
4d9d				endm 
# End of macro FORTH_DSP_POP
4d9d			;		pop hl 
4d9d			 
4d9d			;v5		inc hl   ; move past the type marker 
4d9d			 
4d9d				if DEBUG_STORESE 
4d9d					DMARK "LBl" 
4d9d f5				push af  
4d9e 3a b2 4d			ld a, (.dmark)  
4da1 32 77 fb			ld (debug_mark),a  
4da4 3a b3 4d			ld a, (.dmark+1)  
4da7 32 78 fb			ld (debug_mark+1),a  
4daa 3a b4 4d			ld a, (.dmark+2)  
4dad 32 79 fb			ld (debug_mark+2),a  
4db0 18 03			jr .pastdmark  
4db2 ..			.dmark: db "LBl"  
4db5 f1			.pastdmark: pop af  
4db6			endm  
# End of macro DMARK
4db6					CALLMONITOR 
4db6 cd 92 16			call break_point_state  
4db9				endm  
# End of macro CALLMONITOR
4db9				endif 
4db9 cd e1 04				call storage_label 
4dbc			 
4dbc				       NEXTW 
4dbc c3 88 1f			jp macro_next 
4dbf				endm 
# End of macro NEXTW
4dbf			.STOREPAGE: 
4dbf				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4dbf 6d				db WORD_SYS_CORE+89             
4dc0 f2 4d			dw .LABELS            
4dc2 0a				db 9 + 1 
4dc3 .. 00			db "STOREPAGE",0              
4dcd				endm 
# End of macro CWHEAD
4dcd			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4dcd					; TODO test to see if bank is selected 
4dcd				 
4dcd					if DEBUG_FORTH_WORDS_KEY 
4dcd						DMARK "STP" 
4dcd f5				push af  
4dce 3a e2 4d			ld a, (.dmark)  
4dd1 32 77 fb			ld (debug_mark),a  
4dd4 3a e3 4d			ld a, (.dmark+1)  
4dd7 32 78 fb			ld (debug_mark+1),a  
4dda 3a e4 4d			ld a, (.dmark+2)  
4ddd 32 79 fb			ld (debug_mark+2),a  
4de0 18 03			jr .pastdmark  
4de2 ..			.dmark: db "STP"  
4de5 f1			.pastdmark: pop af  
4de6			endm  
# End of macro DMARK
4de6						CALLMONITOR 
4de6 cd 92 16			call break_point_state  
4de9				endm  
# End of macro CALLMONITOR
4de9					endif 
4de9			;	if DEBUG_STORESE 
4de9			;		DMARK "STP" 
4de9			;		CALLMONITOR 
4de9			;	endif 
4de9			 
4de9 21 62 f8			ld hl, store_page 
4dec cd 1f 1c			call forth_push_numhl 
4def			 
4def			 
4def				       NEXTW 
4def c3 88 1f			jp macro_next 
4df2				endm 
# End of macro NEXTW
4df2			.LABELS: 
4df2				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4df2 6d				db WORD_SYS_CORE+89             
4df3 7c 4e			dw .ENDSTORAGE            
4df5 07				db 6 + 1 
4df6 .. 00			db "LABELS",0              
4dfd				endm 
# End of macro CWHEAD
4dfd			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4dfd					;  
4dfd			 
4dfd					; save the current device selected to restore afterwards 
4dfd				 
4dfd 3a 48 f8				ld a, (spi_device) 
4e00 f5					push af 
4e01			 
4e01			 
4e01					; run through each of the banks 
4e01			 
4e01 21 01 00				ld hl, 1 
4e04 cd 1f 1c				call forth_push_numhl 
4e07 3e ff				ld a, SPI_CE_HIGH 
4e09 cb 87				res SPI_CE0, a 
4e0b 32 48 f8				ld (spi_device), a 
4e0e cd bd 03				call storage_get_block_0 
4e11 21 65 f8				ld hl, store_page+3 
4e14 cd 8d 1c				call forth_push_str 
4e17			 
4e17					 
4e17 21 02 00				ld hl, 2 
4e1a cd 1f 1c				call forth_push_numhl 
4e1d 3e ff				ld a, SPI_CE_HIGH 
4e1f cb 8f				res SPI_CE1, a 
4e21 32 48 f8				ld (spi_device), a 
4e24 cd bd 03				call storage_get_block_0 
4e27 21 65 f8				ld hl, store_page+3 
4e2a cd 8d 1c				call forth_push_str 
4e2d			 
4e2d					 
4e2d 21 03 00				ld hl, 3 
4e30 cd 1f 1c				call forth_push_numhl 
4e33 3e ff				ld a, SPI_CE_HIGH 
4e35 cb 97				res SPI_CE2, a 
4e37 32 48 f8				ld (spi_device), a 
4e3a cd bd 03				call storage_get_block_0 
4e3d 21 65 f8				ld hl, store_page+3 
4e40 cd 8d 1c				call forth_push_str 
4e43			 
4e43			 
4e43 21 04 00				ld hl, 4 
4e46 cd 1f 1c				call forth_push_numhl 
4e49 3e ff				ld a, SPI_CE_HIGH 
4e4b cb 9f				res SPI_CE3, a 
4e4d 32 48 f8				ld (spi_device), a 
4e50 cd bd 03				call storage_get_block_0 
4e53 21 65 f8				ld hl, store_page+3 
4e56 cd 8d 1c				call forth_push_str 
4e59			 
4e59					 
4e59			 
4e59 21 05 00				ld hl, 5 
4e5c cd 1f 1c				call forth_push_numhl 
4e5f 3e ff				ld a, SPI_CE_HIGH 
4e61 cb a7				res SPI_CE4, a 
4e63 32 48 f8				ld (spi_device), a 
4e66 cd bd 03				call storage_get_block_0 
4e69 21 65 f8				ld hl, store_page+3 
4e6c cd 8d 1c				call forth_push_str 
4e6f			 
4e6f					 
4e6f					; push fixed count of storage devices (on board) for now 
4e6f			 
4e6f 21 05 00				ld hl, 5 
4e72 cd 1f 1c				call forth_push_numhl 
4e75			 
4e75					; restore selected device  
4e75				 
4e75 f1					pop af 
4e76 32 48 f8				ld (spi_device), a 
4e79			 
4e79				       NEXTW 
4e79 c3 88 1f			jp macro_next 
4e7c				endm 
# End of macro NEXTW
4e7c			 
4e7c			.ENDSTORAGE: 
4e7c			; eof 
# End of file forth_words_storage.asm
4e7c			endif 
4e7c				include "forth_words_device.asm" 
4e7c			; Device related words 
4e7c			 
4e7c			; | ## Device Words 
4e7c			 
4e7c			if SOUND_ENABLE 
4e7c			.NOTE: 
4e7c				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e7c 33				db WORD_SYS_CORE+31             
4e7d a4 4e			dw .AFTERSOUND            
4e7f 05				db 4 + 1 
4e80 .. 00			db "NOTE",0              
4e85				endm 
# End of macro CWHEAD
4e85			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e85					if DEBUG_FORTH_WORDS_KEY 
4e85						DMARK "NTE" 
4e85 f5				push af  
4e86 3a 9a 4e			ld a, (.dmark)  
4e89 32 77 fb			ld (debug_mark),a  
4e8c 3a 9b 4e			ld a, (.dmark+1)  
4e8f 32 78 fb			ld (debug_mark+1),a  
4e92 3a 9c 4e			ld a, (.dmark+2)  
4e95 32 79 fb			ld (debug_mark+2),a  
4e98 18 03			jr .pastdmark  
4e9a ..			.dmark: db "NTE"  
4e9d f1			.pastdmark: pop af  
4e9e			endm  
# End of macro DMARK
4e9e						CALLMONITOR 
4e9e cd 92 16			call break_point_state  
4ea1				endm  
# End of macro CALLMONITOR
4ea1					endif 
4ea1			 
4ea1				 
4ea1			 
4ea1					NEXTW 
4ea1 c3 88 1f			jp macro_next 
4ea4				endm 
# End of macro NEXTW
4ea4			.AFTERSOUND: 
4ea4			endif 
4ea4			 
4ea4			 
4ea4			USE_GPIO: equ 0 
4ea4			 
4ea4			if USE_GPIO 
4ea4			.GP1: 
4ea4				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4ea4			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4ea4					NEXTW 
4ea4			.GP2: 
4ea4				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4ea4			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4ea4			 
4ea4					NEXTW 
4ea4			 
4ea4			.GP3: 
4ea4				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4ea4			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4ea4			 
4ea4					NEXTW 
4ea4			 
4ea4			.GP4: 
4ea4				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4ea4			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4ea4			 
4ea4					NEXTW 
4ea4			.SIN: 
4ea4			 
4ea4			 
4ea4			endif 
4ea4			 
4ea4			 
4ea4				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4ea4 33				db WORD_SYS_CORE+31             
4ea5 d9 4e			dw .SOUT            
4ea7 03				db 2 + 1 
4ea8 .. 00			db "IN",0              
4eab				endm 
# End of macro CWHEAD
4eab			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4eab					if DEBUG_FORTH_WORDS_KEY 
4eab						DMARK "IN." 
4eab f5				push af  
4eac 3a c0 4e			ld a, (.dmark)  
4eaf 32 77 fb			ld (debug_mark),a  
4eb2 3a c1 4e			ld a, (.dmark+1)  
4eb5 32 78 fb			ld (debug_mark+1),a  
4eb8 3a c2 4e			ld a, (.dmark+2)  
4ebb 32 79 fb			ld (debug_mark+2),a  
4ebe 18 03			jr .pastdmark  
4ec0 ..			.dmark: db "IN."  
4ec3 f1			.pastdmark: pop af  
4ec4			endm  
# End of macro DMARK
4ec4						CALLMONITOR 
4ec4 cd 92 16			call break_point_state  
4ec7				endm  
# End of macro CALLMONITOR
4ec7					endif 
4ec7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ec7 cd 16 1e			call macro_dsp_valuehl 
4eca				endm 
# End of macro FORTH_DSP_VALUEHL
4eca			 
4eca e5					push hl 
4ecb			 
4ecb					; destroy value TOS 
4ecb			 
4ecb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ecb cd ce 1e			call macro_forth_dsp_pop 
4ece				endm 
# End of macro FORTH_DSP_POP
4ece			 
4ece					; one value on hl get other one back 
4ece			 
4ece c1					pop bc 
4ecf			 
4ecf					; do the sub 
4ecf			;		ex de, hl 
4ecf			 
4ecf ed 68				in l,(c) 
4ed1			 
4ed1					; save it 
4ed1			 
4ed1 26 00				ld h,0 
4ed3			 
4ed3					; TODO push value back onto stack for another op etc 
4ed3			 
4ed3 cd 1f 1c				call forth_push_numhl 
4ed6					NEXTW 
4ed6 c3 88 1f			jp macro_next 
4ed9				endm 
# End of macro NEXTW
4ed9			.SOUT: 
4ed9				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ed9 34				db WORD_SYS_CORE+32             
4eda 2c 4f			dw .SPIO            
4edc 04				db 3 + 1 
4edd .. 00			db "OUT",0              
4ee1				endm 
# End of macro CWHEAD
4ee1			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ee1					if DEBUG_FORTH_WORDS_KEY 
4ee1						DMARK "OUT" 
4ee1 f5				push af  
4ee2 3a f6 4e			ld a, (.dmark)  
4ee5 32 77 fb			ld (debug_mark),a  
4ee8 3a f7 4e			ld a, (.dmark+1)  
4eeb 32 78 fb			ld (debug_mark+1),a  
4eee 3a f8 4e			ld a, (.dmark+2)  
4ef1 32 79 fb			ld (debug_mark+2),a  
4ef4 18 03			jr .pastdmark  
4ef6 ..			.dmark: db "OUT"  
4ef9 f1			.pastdmark: pop af  
4efa			endm  
# End of macro DMARK
4efa						CALLMONITOR 
4efa cd 92 16			call break_point_state  
4efd				endm  
# End of macro CALLMONITOR
4efd					endif 
4efd			 
4efd					; get port 
4efd			 
4efd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4efd cd 16 1e			call macro_dsp_valuehl 
4f00				endm 
# End of macro FORTH_DSP_VALUEHL
4f00			 
4f00 e5					push hl 
4f01			 
4f01					; destroy value TOS 
4f01			 
4f01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f01 cd ce 1e			call macro_forth_dsp_pop 
4f04				endm 
# End of macro FORTH_DSP_POP
4f04			 
4f04					; get byte to send 
4f04			 
4f04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f04 cd 16 1e			call macro_dsp_valuehl 
4f07				endm 
# End of macro FORTH_DSP_VALUEHL
4f07			 
4f07			;		push hl 
4f07			 
4f07					; destroy value TOS 
4f07			 
4f07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f07 cd ce 1e			call macro_forth_dsp_pop 
4f0a				endm 
# End of macro FORTH_DSP_POP
4f0a			 
4f0a					; one value on hl get other one back 
4f0a			 
4f0a			;		pop hl 
4f0a			 
4f0a c1					pop bc 
4f0b			 
4f0b					if DEBUG_FORTH_WORDS 
4f0b						DMARK "OUT" 
4f0b f5				push af  
4f0c 3a 20 4f			ld a, (.dmark)  
4f0f 32 77 fb			ld (debug_mark),a  
4f12 3a 21 4f			ld a, (.dmark+1)  
4f15 32 78 fb			ld (debug_mark+1),a  
4f18 3a 22 4f			ld a, (.dmark+2)  
4f1b 32 79 fb			ld (debug_mark+2),a  
4f1e 18 03			jr .pastdmark  
4f20 ..			.dmark: db "OUT"  
4f23 f1			.pastdmark: pop af  
4f24			endm  
# End of macro DMARK
4f24						CALLMONITOR 
4f24 cd 92 16			call break_point_state  
4f27				endm  
# End of macro CALLMONITOR
4f27					endif 
4f27			 
4f27 ed 69				out (c), l 
4f29			 
4f29					NEXTW 
4f29 c3 88 1f			jp macro_next 
4f2c				endm 
# End of macro NEXTW
4f2c			 
4f2c			 
4f2c			.SPIO: 
4f2c			 
4f2c			if STORAGE_SE 
4f2c				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4f2c 51				db WORD_SYS_CORE+61             
4f2d 3d 4f			dw .SPICEH            
4f2f 07				db 6 + 1 
4f30 .. 00			db "SPICEL",0              
4f37				endm 
# End of macro CWHEAD
4f37			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4f37			 
4f37 cd 98 01				call spi_ce_low 
4f3a			    NEXTW 
4f3a c3 88 1f			jp macro_next 
4f3d				endm 
# End of macro NEXTW
4f3d			 
4f3d			.SPICEH: 
4f3d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4f3d 51				db WORD_SYS_CORE+61             
4f3e 4e 4f			dw .SPIOb            
4f40 07				db 6 + 1 
4f41 .. 00			db "SPICEH",0              
4f48				endm 
# End of macro CWHEAD
4f48			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4f48			 
4f48 cd 87 01				call spi_ce_high 
4f4b			    NEXTW 
4f4b c3 88 1f			jp macro_next 
4f4e				endm 
# End of macro NEXTW
4f4e			 
4f4e			 
4f4e			.SPIOb: 
4f4e			 
4f4e				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4f4e 51				db WORD_SYS_CORE+61             
4f4f 64 4f			dw .SPII            
4f51 05				db 4 + 1 
4f52 .. 00			db "SPIO",0              
4f57				endm 
# End of macro CWHEAD
4f57			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f57			 
4f57					; get port 
4f57			 
4f57			 
4f57					; get byte to send 
4f57			 
4f57					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f57 cd 16 1e			call macro_dsp_valuehl 
4f5a				endm 
# End of macro FORTH_DSP_VALUEHL
4f5a			 
4f5a			;		push hl    ; u1  
4f5a			 
4f5a					; destroy value TOS 
4f5a			 
4f5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f5a cd ce 1e			call macro_forth_dsp_pop 
4f5d				endm 
# End of macro FORTH_DSP_POP
4f5d			 
4f5d					; one value on hl get other one back 
4f5d			 
4f5d			;		pop hl   ; u2 - addr 
4f5d			 
4f5d					; TODO Send SPI byte 
4f5d			 
4f5d 7d					ld a, l 
4f5e cd bc 00				call spi_send_byte 
4f61			 
4f61					NEXTW 
4f61 c3 88 1f			jp macro_next 
4f64				endm 
# End of macro NEXTW
4f64			 
4f64			.SPII: 
4f64				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f64 52				db WORD_SYS_CORE+62             
4f65 79 4f			dw .SESEL            
4f67 06				db 5 + 1 
4f68 .. 00			db "SPII",0              
4f6d				endm 
# End of macro CWHEAD
4f6d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f6d			 
4f6d					; TODO Get SPI byte 
4f6d			 
4f6d cd dd 00				call spi_read_byte 
4f70			 
4f70 26 00				ld h, 0 
4f72 6f					ld l, a 
4f73 cd 1f 1c				call forth_push_numhl 
4f76			 
4f76					NEXTW 
4f76 c3 88 1f			jp macro_next 
4f79				endm 
# End of macro NEXTW
4f79			 
4f79			 
4f79			 
4f79			.SESEL: 
4f79				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f79 66				db WORD_SYS_CORE+82             
4f7a 1d 50			dw .CARTDEV            
4f7c 05				db 4 + 1 
4f7d .. 00			db "BANK",0              
4f82				endm 
# End of macro CWHEAD
4f82			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f82					if DEBUG_FORTH_WORDS_KEY 
4f82						DMARK "BNK" 
4f82 f5				push af  
4f83 3a 97 4f			ld a, (.dmark)  
4f86 32 77 fb			ld (debug_mark),a  
4f89 3a 98 4f			ld a, (.dmark+1)  
4f8c 32 78 fb			ld (debug_mark+1),a  
4f8f 3a 99 4f			ld a, (.dmark+2)  
4f92 32 79 fb			ld (debug_mark+2),a  
4f95 18 03			jr .pastdmark  
4f97 ..			.dmark: db "BNK"  
4f9a f1			.pastdmark: pop af  
4f9b			endm  
# End of macro DMARK
4f9b						CALLMONITOR 
4f9b cd 92 16			call break_point_state  
4f9e				endm  
# End of macro CALLMONITOR
4f9e					endif 
4f9e			 
4f9e 3e ff				ld a, 255 
4fa0 32 4b f8				ld (spi_cartdev), a 
4fa3			 
4fa3					; get bank 
4fa3			 
4fa3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fa3 cd 16 1e			call macro_dsp_valuehl 
4fa6				endm 
# End of macro FORTH_DSP_VALUEHL
4fa6			 
4fa6			;		push hl 
4fa6			 
4fa6					; destroy value TOS 
4fa6			 
4fa6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fa6 cd ce 1e			call macro_forth_dsp_pop 
4fa9				endm 
# End of macro FORTH_DSP_POP
4fa9			 
4fa9					; one value on hl get other one back 
4fa9			 
4fa9			;		pop hl 
4fa9			 
4fa9			 
4fa9 0e ff				ld c, SPI_CE_HIGH 
4fab 06 30				ld b, '0'    ; human readable bank number 
4fad			 
4fad 7d					ld a, l 
4fae			 
4fae					if DEBUG_FORTH_WORDS 
4fae						DMARK "BNK" 
4fae f5				push af  
4faf 3a c3 4f			ld a, (.dmark)  
4fb2 32 77 fb			ld (debug_mark),a  
4fb5 3a c4 4f			ld a, (.dmark+1)  
4fb8 32 78 fb			ld (debug_mark+1),a  
4fbb 3a c5 4f			ld a, (.dmark+2)  
4fbe 32 79 fb			ld (debug_mark+2),a  
4fc1 18 03			jr .pastdmark  
4fc3 ..			.dmark: db "BNK"  
4fc6 f1			.pastdmark: pop af  
4fc7			endm  
# End of macro DMARK
4fc7						CALLMONITOR 
4fc7 cd 92 16			call break_point_state  
4fca				endm  
# End of macro CALLMONITOR
4fca					endif 
4fca			 
4fca					; active low 
4fca			 
4fca fe 00				cp 0 
4fcc 28 28				jr z, .bset 
4fce fe 01				cp 1 
4fd0 20 04				jr nz, .b2 
4fd2 cb 81				res 0, c 
4fd4 06 31				ld b, '1'    ; human readable bank number 
4fd6 fe 02		.b2:		cp 2 
4fd8 20 04				jr nz, .b3 
4fda cb 89				res 1, c 
4fdc 06 32				ld b, '2'    ; human readable bank number 
4fde fe 03		.b3:		cp 3 
4fe0 20 04				jr nz, .b4 
4fe2 cb 91				res 2, c 
4fe4 06 33				ld b, '3'    ; human readable bank number 
4fe6 fe 04		.b4:		cp 4 
4fe8 20 04				jr nz, .b5 
4fea cb 99				res 3, c 
4fec 06 34				ld b, '4'    ; human readable bank number 
4fee fe 05		.b5:		cp 5 
4ff0 20 04				jr nz, .bset 
4ff2 cb a1				res 4, c 
4ff4 06 35				ld b, '5'    ; human readable bank number 
4ff6			 
4ff6			.bset: 
4ff6 79					ld a, c 
4ff7 32 48 f8				ld (spi_device),a 
4ffa 78					ld a, b 
4ffb 32 47 f8				ld (spi_device_id),a 
4ffe					if DEBUG_FORTH_WORDS 
4ffe						DMARK "BN2" 
4ffe f5				push af  
4fff 3a 13 50			ld a, (.dmark)  
5002 32 77 fb			ld (debug_mark),a  
5005 3a 14 50			ld a, (.dmark+1)  
5008 32 78 fb			ld (debug_mark+1),a  
500b 3a 15 50			ld a, (.dmark+2)  
500e 32 79 fb			ld (debug_mark+2),a  
5011 18 03			jr .pastdmark  
5013 ..			.dmark: db "BN2"  
5016 f1			.pastdmark: pop af  
5017			endm  
# End of macro DMARK
5017						CALLMONITOR 
5017 cd 92 16			call break_point_state  
501a				endm  
# End of macro CALLMONITOR
501a					endif 
501a			 
501a					NEXTW 
501a c3 88 1f			jp macro_next 
501d				endm 
# End of macro NEXTW
501d			 
501d			.CARTDEV: 
501d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
501d 66				db WORD_SYS_CORE+82             
501e c6 50			dw .ENDDEVICE            
5020 08				db 7 + 1 
5021 .. 00			db "CARTDEV",0              
5029				endm 
# End of macro CWHEAD
5029			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5029					if DEBUG_FORTH_WORDS_KEY 
5029						DMARK "CDV" 
5029 f5				push af  
502a 3a 3e 50			ld a, (.dmark)  
502d 32 77 fb			ld (debug_mark),a  
5030 3a 3f 50			ld a, (.dmark+1)  
5033 32 78 fb			ld (debug_mark+1),a  
5036 3a 40 50			ld a, (.dmark+2)  
5039 32 79 fb			ld (debug_mark+2),a  
503c 18 03			jr .pastdmark  
503e ..			.dmark: db "CDV"  
5041 f1			.pastdmark: pop af  
5042			endm  
# End of macro DMARK
5042						CALLMONITOR 
5042 cd 92 16			call break_point_state  
5045				endm  
# End of macro CALLMONITOR
5045					endif 
5045			 
5045					; disable se storage bank selection 
5045			 
5045 3e ff				ld a, SPI_CE_HIGH		; ce high 
5047 32 48 f8				ld (spi_device), a 
504a			 
504a					; get bank 
504a			 
504a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
504a cd 16 1e			call macro_dsp_valuehl 
504d				endm 
# End of macro FORTH_DSP_VALUEHL
504d			 
504d			;		push hl 
504d			 
504d					; destroy value TOS 
504d			 
504d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
504d cd ce 1e			call macro_forth_dsp_pop 
5050				endm 
# End of macro FORTH_DSP_POP
5050			 
5050					; one value on hl get other one back 
5050			 
5050			;		pop hl 
5050			 
5050					; active low 
5050			 
5050 0e ff				ld c, 255 
5052			 
5052 7d					ld a, l 
5053					if DEBUG_FORTH_WORDS 
5053						DMARK "CDV" 
5053 f5				push af  
5054 3a 68 50			ld a, (.dmark)  
5057 32 77 fb			ld (debug_mark),a  
505a 3a 69 50			ld a, (.dmark+1)  
505d 32 78 fb			ld (debug_mark+1),a  
5060 3a 6a 50			ld a, (.dmark+2)  
5063 32 79 fb			ld (debug_mark+2),a  
5066 18 03			jr .pastdmark  
5068 ..			.dmark: db "CDV"  
506b f1			.pastdmark: pop af  
506c			endm  
# End of macro DMARK
506c						CALLMONITOR 
506c cd 92 16			call break_point_state  
506f				endm  
# End of macro CALLMONITOR
506f					endif 
506f fe 00				cp 0 
5071 28 30				jr z, .cset 
5073 fe 01				cp 1 
5075 20 02				jr nz, .c2 
5077 cb 81				res 0, c 
5079 fe 02		.c2:		cp 2 
507b 20 02				jr nz, .c3 
507d cb 89				res 1, c 
507f fe 03		.c3:		cp 3 
5081 20 02				jr nz, .c4 
5083 cb 91				res 2, c 
5085 fe 04		.c4:		cp 4 
5087 20 02				jr nz, .c5 
5089 cb 99				res 3, c 
508b fe 05		.c5:		cp 5 
508d 20 02				jr nz, .c6 
508f cb a1				res 4, c 
5091 fe 06		.c6:		cp 6 
5093 20 02				jr nz, .c7 
5095 cb a9				res 5, c 
5097 fe 07		.c7:		cp 7 
5099 20 02				jr nz, .c8 
509b cb b1				res 6, c 
509d fe 08		.c8:		cp 8 
509f 20 02				jr nz, .cset 
50a1 cb b9				res 7, c 
50a3 79			.cset:		ld a, c 
50a4 32 4b f8				ld (spi_cartdev),a 
50a7			 
50a7					if DEBUG_FORTH_WORDS 
50a7						DMARK "CD2" 
50a7 f5				push af  
50a8 3a bc 50			ld a, (.dmark)  
50ab 32 77 fb			ld (debug_mark),a  
50ae 3a bd 50			ld a, (.dmark+1)  
50b1 32 78 fb			ld (debug_mark+1),a  
50b4 3a be 50			ld a, (.dmark+2)  
50b7 32 79 fb			ld (debug_mark+2),a  
50ba 18 03			jr .pastdmark  
50bc ..			.dmark: db "CD2"  
50bf f1			.pastdmark: pop af  
50c0			endm  
# End of macro DMARK
50c0						CALLMONITOR 
50c0 cd 92 16			call break_point_state  
50c3				endm  
# End of macro CALLMONITOR
50c3					endif 
50c3					NEXTW 
50c3 c3 88 1f			jp macro_next 
50c6				endm 
# End of macro NEXTW
50c6			endif 
50c6			 
50c6			.ENDDEVICE: 
50c6			; eof 
50c6			 
# End of file forth_words_device.asm
50c6			 
50c6			; var handler 
50c6			 
50c6			 
50c6			.VARS: 
50c6				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
50c6 78				db WORD_SYS_CORE+100             
50c7 de 50			dw .V0Q            
50c9 04				db 3 + 1 
50ca .. 00			db "V0!",0              
50ce				endm 
# End of macro CWHEAD
50ce			;| V0! ( u1 -- )  Store value to v0  | DONE 
50ce			 
50ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50ce cd 16 1e			call macro_dsp_valuehl 
50d1				endm 
# End of macro FORTH_DSP_VALUEHL
50d1			 
50d1 11 10 f8				ld de, cli_var_array 
50d4			 
50d4 eb					ex de, hl 
50d5 73					ld (hl), e 
50d6 23					inc hl 
50d7 72					ld (hl), d 
50d8			 
50d8					; destroy value TOS 
50d8			 
50d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50d8 cd ce 1e			call macro_forth_dsp_pop 
50db				endm 
# End of macro FORTH_DSP_POP
50db			 
50db				       NEXTW 
50db c3 88 1f			jp macro_next 
50de				endm 
# End of macro NEXTW
50de			.V0Q: 
50de				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
50de 79				db WORD_SYS_CORE+101             
50df ef 50			dw .V1S            
50e1 04				db 3 + 1 
50e2 .. 00			db "V0@",0              
50e6				endm 
# End of macro CWHEAD
50e6			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
50e6 2a 10 f8				ld hl, (cli_var_array) 
50e9 cd 1f 1c				call forth_push_numhl 
50ec			 
50ec				       NEXTW 
50ec c3 88 1f			jp macro_next 
50ef				endm 
# End of macro NEXTW
50ef			.V1S: 
50ef				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
50ef 7a				db WORD_SYS_CORE+102             
50f0 07 51			dw .V1Q            
50f2 04				db 3 + 1 
50f3 .. 00			db "V1!",0              
50f7				endm 
# End of macro CWHEAD
50f7			;| V1! ( u1 -- )  Store value to v1 | DONE 
50f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50f7 cd 16 1e			call macro_dsp_valuehl 
50fa				endm 
# End of macro FORTH_DSP_VALUEHL
50fa			 
50fa 11 12 f8				ld de, cli_var_array+2 
50fd				 
50fd eb					ex de, hl 
50fe 73					ld (hl), e 
50ff 23					inc hl 
5100 72					ld (hl), d 
5101			 
5101					; destroy value TOS 
5101			 
5101					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5101 cd ce 1e			call macro_forth_dsp_pop 
5104				endm 
# End of macro FORTH_DSP_POP
5104				       NEXTW 
5104 c3 88 1f			jp macro_next 
5107				endm 
# End of macro NEXTW
5107			.V1Q: 
5107				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5107 7b				db WORD_SYS_CORE+103             
5108 18 51			dw .V2S            
510a 04				db 3 + 1 
510b .. 00			db "V1@",0              
510f				endm 
# End of macro CWHEAD
510f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
510f 2a 12 f8				ld hl, (cli_var_array+2) 
5112 cd 1f 1c				call forth_push_numhl 
5115				       NEXTW 
5115 c3 88 1f			jp macro_next 
5118				endm 
# End of macro NEXTW
5118			.V2S: 
5118				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5118 7c				db WORD_SYS_CORE+104             
5119 30 51			dw .V2Q            
511b 04				db 3 + 1 
511c .. 00			db "V2!",0              
5120				endm 
# End of macro CWHEAD
5120			;| V2! ( u1 -- )  Store value to v2 | DONE 
5120					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5120 cd 16 1e			call macro_dsp_valuehl 
5123				endm 
# End of macro FORTH_DSP_VALUEHL
5123			 
5123 11 14 f8				ld de, cli_var_array+4 
5126				 
5126 eb					ex de, hl 
5127 73					ld (hl), e 
5128 23					inc hl 
5129 72					ld (hl), d 
512a			 
512a					; destroy value TOS 
512a			 
512a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
512a cd ce 1e			call macro_forth_dsp_pop 
512d				endm 
# End of macro FORTH_DSP_POP
512d				       NEXTW 
512d c3 88 1f			jp macro_next 
5130				endm 
# End of macro NEXTW
5130			.V2Q: 
5130				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5130 7d				db WORD_SYS_CORE+105             
5131 41 51			dw .V3S            
5133 04				db 3 + 1 
5134 .. 00			db "V2@",0              
5138				endm 
# End of macro CWHEAD
5138			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5138 2a 14 f8				ld hl, (cli_var_array+4) 
513b cd 1f 1c				call forth_push_numhl 
513e				       NEXTW 
513e c3 88 1f			jp macro_next 
5141				endm 
# End of macro NEXTW
5141			.V3S: 
5141				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5141 7c				db WORD_SYS_CORE+104             
5142 59 51			dw .V3Q            
5144 04				db 3 + 1 
5145 .. 00			db "V3!",0              
5149				endm 
# End of macro CWHEAD
5149			;| V3! ( u1 -- )  Store value to v3 | DONE 
5149					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5149 cd 16 1e			call macro_dsp_valuehl 
514c				endm 
# End of macro FORTH_DSP_VALUEHL
514c			 
514c 11 16 f8				ld de, cli_var_array+6 
514f				 
514f eb					ex de, hl 
5150 73					ld (hl), e 
5151 23					inc hl 
5152 72					ld (hl), d 
5153			 
5153					; destroy value TOS 
5153			 
5153					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5153 cd ce 1e			call macro_forth_dsp_pop 
5156				endm 
# End of macro FORTH_DSP_POP
5156				       NEXTW 
5156 c3 88 1f			jp macro_next 
5159				endm 
# End of macro NEXTW
5159			.V3Q: 
5159				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5159 7d				db WORD_SYS_CORE+105             
515a 6a 51			dw .END            
515c 04				db 3 + 1 
515d .. 00			db "V3@",0              
5161				endm 
# End of macro CWHEAD
5161			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5161 2a 16 f8				ld hl, (cli_var_array+6) 
5164 cd 1f 1c				call forth_push_numhl 
5167				       NEXTW 
5167 c3 88 1f			jp macro_next 
516a				endm 
# End of macro NEXTW
516a			 
516a			 
516a			 
516a			 
516a			 
516a			; end of dict marker 
516a			 
516a 00			.END:    db WORD_SYS_END 
516b 00 00			dw 0 
516d 00				db 0 
516e			 
516e			; use to jp here for user dict words to save on macro expansion  
516e			 
516e			user_dict_next: 
516e				NEXTW 
516e c3 88 1f			jp macro_next 
5171				endm 
# End of macro NEXTW
5171			 
5171			 
5171			user_exec: 
5171				;    ld hl, <word code> 
5171				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5171				;    call forthexec 
5171				;    jp user_dict_next   (NEXT) 
5171			        ;    <word code bytes> 
5171 eb				ex de, hl 
5172 2a 1e f1			ld hl,(os_tok_ptr) 
5175				 
5175				FORTH_RSP_NEXT 
5175 cd c6 1b			call macro_forth_rsp_next 
5178				endm 
# End of macro FORTH_RSP_NEXT
5178			 
5178			if DEBUG_FORTH_UWORD 
5178						DMARK "UEX" 
5178 f5				push af  
5179 3a 8d 51			ld a, (.dmark)  
517c 32 77 fb			ld (debug_mark),a  
517f 3a 8e 51			ld a, (.dmark+1)  
5182 32 78 fb			ld (debug_mark+1),a  
5185 3a 8f 51			ld a, (.dmark+2)  
5188 32 79 fb			ld (debug_mark+2),a  
518b 18 03			jr .pastdmark  
518d ..			.dmark: db "UEX"  
5190 f1			.pastdmark: pop af  
5191			endm  
# End of macro DMARK
5191				CALLMONITOR 
5191 cd 92 16			call break_point_state  
5194				endm  
# End of macro CALLMONITOR
5194			endif 
5194			 
5194			 
5194			 
5194 eb				ex de, hl 
5195 22 1e f1			ld (os_tok_ptr), hl 
5198				 
5198				; Don't use next - Skips the first word in uword. 
5198			 
5198 c3 19 20			jp exec1 
519b			;	NEXT 
519b			 
519b			 
519b			; eof 
# End of file forth_wordsv4.asm
519b			endif 
519b			;;;;;;;;;;;;;; Debug code 
519b			 
519b			 
519b			;if DEBUG_FORTH_PARSE 
519b .. 00		.nowordfound: db "No match",0 
51a4 .. 00		.compword:	db "Comparing word ",0 
51b4 .. 00		.nextwordat:	db "Next word at",0 
51c1 .. 00		.charmatch:	db "Char match",0 
51cc			;endif 
51cc			if DEBUG_FORTH_JP 
51cc			.foundword:	db "Word match. Exec..",0 
51cc			endif 
51cc			;if DEBUG_FORTH_PUSH 
51cc .. 00		.enddict:	db "Dict end. Push.",0 
51dc .. 00		.push_str:	db "Pushing string",0 
51eb .. 00		.push_num:	db "Pushing number",0 
51fa .. 00		.data_sp:	db "SP:",0 
51fe .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5210 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5222 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5234			;endif 
5234			;if DEBUG_FORTH_MALLOC 
5234 .. 00		.push_malloc:	db "Malloc address",0 
5243			;endif 
5243			 
5243			 
5243			 
5243			; display malloc address and current data stack pointer  
5243			 
5243			malloc_error: 
5243 d5				push de 
5244 f5				push af 
5245 e5				push hl 
5246 cd d5 0a			call clear_display 
5249 11 6b 52			ld de, .mallocerr 
524c 3e 00			ld a,0 
524e			;	ld de,os_word_scratch 
524e cd e8 0a			call str_at_display 
5251 3e 11			ld a, display_row_1+17 
5253 11 77 fb			ld de, debug_mark 
5256 cd e8 0a			call str_at_display 
5259 cd f8 0a			call update_display 
525c				;call break_point_state 
525c cd 3c 68			call cin_wait 
525f			 
525f 3e 20			ld a, ' ' 
5261 32 0e ee			ld (os_view_disable), a 
5264 e1				pop hl 
5265 f1				pop af 
5266 d1				pop de	 
5267				CALLMONITOR 
5267 cd 92 16			call break_point_state  
526a				endm  
# End of macro CALLMONITOR
526a c9				ret 
526b			 
526b .. 00		.mallocerr: 	db "Malloc Error",0 
5278			;if DEBUG_FORTH_PUSH 
5278			display_data_sp: 
5278 f5				push af 
5279			 
5279				; see if disabled 
5279			 
5279 3a 0e ee			ld a, (os_view_disable) 
527c fe 2a			cp '*' 
527e 28 67			jr z, .skipdsp 
5280			 
5280 e5				push hl 
5281 e5				push hl 
5282 e5			push hl 
5283 cd d5 0a			call clear_display 
5286 e1			pop hl 
5287 7c				ld a,h 
5288 21 22 f1			ld hl, os_word_scratch 
528b cd 0a 10			call hexout 
528e e1				pop hl 
528f 7d				ld a,l 
5290 21 24 f1			ld hl, os_word_scratch+2 
5293 cd 0a 10			call hexout 
5296 21 26 f1			ld hl, os_word_scratch+4 
5299 3e 00			ld a,0 
529b 77				ld (hl),a 
529c 11 22 f1			ld de,os_word_scratch 
529f 3e 28				ld a, display_row_2 
52a1 cd e8 0a				call str_at_display 
52a4 11 fe 51			ld de, .wordinhl 
52a7 3e 00			ld a, display_row_1 
52a9			 
52a9 cd e8 0a				call str_at_display 
52ac 11 77 fb			ld de, debug_mark 
52af 3e 11			ld a, display_row_1+17 
52b1			 
52b1 cd e8 0a				call str_at_display 
52b4			 
52b4				; display current data stack pointer 
52b4 11 fa 51			ld de,.data_sp 
52b7 3e 30				ld a, display_row_2 + 8 
52b9 cd e8 0a				call str_at_display 
52bc			 
52bc 2a 0a f8			ld hl,(cli_data_sp) 
52bf e5				push hl 
52c0 7c				ld a,h 
52c1 21 22 f1			ld hl, os_word_scratch 
52c4 cd 0a 10			call hexout 
52c7 e1				pop hl 
52c8 7d				ld a,l 
52c9 21 24 f1			ld hl, os_word_scratch+2 
52cc cd 0a 10			call hexout 
52cf 21 26 f1			ld hl, os_word_scratch+4 
52d2 3e 00			ld a,0 
52d4 77				ld (hl),a 
52d5 11 22 f1			ld de,os_word_scratch 
52d8 3e 33				ld a, display_row_2 + 11 
52da cd e8 0a				call str_at_display 
52dd			 
52dd			 
52dd cd f8 0a			call update_display 
52e0 cd 55 0a			call delay1s 
52e3 cd 55 0a			call delay1s 
52e6 e1				pop hl 
52e7			.skipdsp: 
52e7 f1				pop af 
52e8 c9				ret 
52e9			 
52e9			display_data_malloc: 
52e9			 
52e9 f5				push af 
52ea e5				push hl 
52eb e5				push hl 
52ec e5			push hl 
52ed cd d5 0a			call clear_display 
52f0 e1			pop hl 
52f1 7c				ld a,h 
52f2 21 22 f1			ld hl, os_word_scratch 
52f5 cd 0a 10			call hexout 
52f8 e1				pop hl 
52f9 7d				ld a,l 
52fa 21 24 f1			ld hl, os_word_scratch+2 
52fd cd 0a 10			call hexout 
5300 21 26 f1			ld hl, os_word_scratch+4 
5303 3e 00			ld a,0 
5305 77				ld (hl),a 
5306 11 22 f1			ld de,os_word_scratch 
5309 3e 28				ld a, display_row_2 
530b cd e8 0a				call str_at_display 
530e 11 34 52			ld de, .push_malloc 
5311 3e 00			ld a, display_row_1 
5313			 
5313 cd e8 0a				call str_at_display 
5316			 
5316				; display current data stack pointer 
5316 11 fa 51			ld de,.data_sp 
5319 3e 30				ld a, display_row_2 + 8 
531b cd e8 0a				call str_at_display 
531e			 
531e 2a 0a f8			ld hl,(cli_data_sp) 
5321 e5				push hl 
5322 7c				ld a,h 
5323 21 22 f1			ld hl, os_word_scratch 
5326 cd 0a 10			call hexout 
5329 e1				pop hl 
532a 7d				ld a,l 
532b 21 24 f1			ld hl, os_word_scratch+2 
532e cd 0a 10			call hexout 
5331 21 26 f1			ld hl, os_word_scratch+4 
5334 3e 00			ld a,0 
5336 77				ld (hl),a 
5337 11 22 f1			ld de,os_word_scratch 
533a 3e 33				ld a, display_row_2 + 11 
533c cd e8 0a				call str_at_display 
533f			 
533f cd f8 0a			call update_display 
5342 cd 55 0a			call delay1s 
5345 cd 55 0a			call delay1s 
5348 e1				pop hl 
5349 f1				pop af 
534a c9				ret 
534b			;endif 
534b			 
534b			include "forth_autostart.asm" 
534b			; list of commands to perform at system start up 
534b			 
534b			startcmds: 
534b			;	dw test11 
534b			;	dw test12 
534b			;	dw test13 
534b			;	dw test14 
534b			;	dw test15 
534b			;	dw test16 
534b			;	dw test17 
534b			;	dw ifthtest1 
534b			;	dw ifthtest2 
534b			;	dw ifthtest3 
534b			;	dw mmtest1 
534b			;	dw mmtest2 
534b			;	dw mmtest3 
534b			;	dw mmtest4 
534b			;	dw mmtest5 
534b			;	dw mmtest6 
534b			;	dw iftest1 
534b			;	dw iftest2 
534b			;	dw iftest3 
534b			;	dw looptest1 
534b			;	dw looptest2 
534b			;	dw test1 
534b			;	dw test2 
534b			;	dw test3 
534b			;	dw test4 
534b			;	dw game2r 
534b			;	dw game2b1 
534b			;	dw game2b2 
534b			 
534b				; start up words that are actually useful 
534b			 
534b a9 53			dw clrstack 
534d dc 53			dw type 
534f 9d 55			dw stest 
5351 00 54			dw strncpy 
5353 3e 55			dw list 
5355 61 54			dw start1 
5357 73 54			dw start2 
5359			;	dw start3 
5359 86 54			dw start3b 
535b de 54			dw start3c 
535d			 
535d				; (unit) testing words 
535d			 
535d 14 56			dw mtesta 
535f c9 56			dw mtestb 
5361 6c 57			dw mtestc 
5363 21 58			dw mtestd 
5365 c5 58			dw mteste 
5367			 
5367				; demo/game words 
5367			 
5367 d1 5f		        dw game3w 
5369 ff 5f		        dw game3p 
536b 1d 60		        dw game3sc 
536d 4e 60		        dw game3vsi 
536f 7a 60		        dw game3vs 
5371				 
5371 c4 5d			dw game2b 
5373 32 5e			dw game2bf 
5375 7c 5e			dw game2mba 
5377 12 5f			dw game2mbas 
5379 54 5f			dw game2mb 
537b			 
537b 85 5a			dw game1 
537d 96 5a			dw game1a 
537f f8 5a			dw game1b 
5381 2d 5b			dw game1c 
5383 63 5b			dw game1d 
5385 94 5b			dw game1s 
5387 a8 5b			dw game1t 
5389 bd 5b			dw game1f 
538b f1 5b			dw game1z 
538d 35 5c			dw game1zz 
538f			 
538f 7b 59			dw test5 
5391 b3 59			dw test6 
5393 eb 59			dw test7 
5395 ff 59			dw test8 
5397 2b 5a			dw test9 
5399 41 5a			dw test10 
539b				 
539b 0c 5d		        dw ssv5 
539d f0 5c		        dw ssv4 
539f d4 5c		        dw ssv3 
53a1 9e 5c		        dw ssv2 
53a3 25 5d		        dw ssv1 
53a5 6d 5d		        dw ssv1cpm 
53a7			;	dw keyup 
53a7			;	dw keydown 
53a7			;	dw keyleft 
53a7			;	dw keyright 
53a7			;	dw 	keyf1 
53a7			;	dw keyf2 
53a7			;	dw keyf3 
53a7			;	dw keyf4 
53a7			;	dw keyf5 
53a7			;	dw keyf6 
53a7			;	dw keyf7 
53a7			;	dw keyf8 
53a7			;	dw keyf9 
53a7			;	dw keyf10 
53a7			;	dw keyf11 
53a7			;	dw keyf12 
53a7			;	dw keytab 
53a7			;	dw keycr 
53a7			;	dw keyhome 
53a7			;	dw keyend 
53a7			;	dw keybs 
53a7 00 00			db 0, 0	 
53a9			 
53a9			 
53a9			; clear stack  
53a9			 
53a9 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
53dc			 
53dc			; type ( addr count - ) 
53dc .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5400			 
5400			; some direct memory words 
5400			; strncpy ( len t f -- t ) 
5400			 
5400 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5461			 
5461 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5473 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5486			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5486 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
54de .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
553e			 
553e			 
553e			; a handy word to list items on the stack 
553e			 
553e .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
559d			 
559d			 
559d			; test stack  
559d			; rnd8 stest 
559d			 
559d .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5614			 
5614			; random malloc and free cycles 
5614			 
5614 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56c9			 
56c9			; fixed malloc and free cycles 
56c9			 
56c9 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
576c			 
576c			; fixed double string push and drop cycle  
576c			 
576c .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5821			 
5821			; consistent fixed string push and drop cycle  
5821			 
5821 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58c5			 
58c5 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
597b			 
597b			;test1:		db ": aa 1 2 3 ;", 0 
597b			;test2:     	db "111 aa 888 999",0 
597b			;test3:     	db ": bb 77 ;",0 
597b			;test4:     	db "$02 $01 do i . loop bb",0 
597b			 
597b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
59b3 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
59eb .. 00		test7:     	db ": box hline vline ;",0 
59ff .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5a2b .. 00		test9:     	db ": sw $01 adsp world ;",0 
5a41 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a66 .. 00		test11:     	db "hello create .",0 
5a75 .. 00		test12:     	db "hello2 create .",0 
5a85			 
5a85			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a85			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a85			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a85			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a85			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a85			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a85			 
5a85			;iftest1:     	db "$0001 IF cls .",0 
5a85			;iftest2:     	db "$0000 IF cls .",0 
5a85			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a85			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a85			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a85			 
5a85			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a85			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a85			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a85			 
5a85			 
5a85			 
5a85			; a small guess the number game 
5a85			 
5a85 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a96 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5af8			 
5af8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5b2d .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b63 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b94 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5ba8 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5bbd .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5bf1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5c35			 
5c35			; Using 'ga' save a high score across multiple runs using external storage 
5c35			 
5c35 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c9e			 
5c9e			 
5c9e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c9e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c9e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c9e			 
5c9e			; simple screen saver to test code memory reuse to destruction 
5c9e			 
5c9e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5cd4 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5cf0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5d0c .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5d25 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d6d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5dc4			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5dc4			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5dc4			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5dc4			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5dc4			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5dc4			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5dc4			 
5dc4			 
5dc4			 
5dc4			; minesweeper/battleship finding game 
5dc4			; draws a game board of random ship/mine positions 
5dc4			; user enters coords to see if it hits on 
5dc4			; game ends when all are hit 
5dc4			; when hit or miss says how many may be in the area 
5dc4			 
5dc4			; setup the game board and then hide it 
5dc4 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5e32 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e7c			; prompt for where to target 
5e7c .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5f12 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5f37			; TODO see if the entered coords hits or misses pushes char hit of miss 
5f37 .. 00		game2mbht:      db ": mbckht nop ;",0 
5f46 .. 00		game2mbms:      db ": mbcms nop ;",0 
5f54			; TODO how many might be near by 
5f54 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5fd1			 
5fd1			; Game 3 
5fd1			 
5fd1			; Vert scroller ski game - avoid the trees! 
5fd1			 
5fd1			; v0 score (ie turns) 
5fd1			; v1 player pos 
5fd1			; v2 left wall 
5fd1			; v3 right wall 
5fd1			 
5fd1			; Draw side walls randomly 
5fd1			 
5fd1 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5fff			 
5fff			; Draw player 
5fff .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
601d			 
601d			; TODO Get Key 
601d			 
601d			; TODO Move left right 
601d			 
601d			; scroll and move walls a bit 
601d			 
601d .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
604e			 
604e			; main game loop 
604e			 
604e .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
607a .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
60b9			 
60b9			; key board defs 
60b9			 
60b9 .. 00		keyup:       db ": keyup $05 ;",0 
60c7 .. 00		keydown:       db ": keydown $0a ;",0 
60d7 .. 00		keyleft:       db ": keyleft $0b ;",0 
60e7 .. 00		keyright:       db ": keyright $0c ;",0 
60f8 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6106 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6114 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6122 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6130 .. 00		keyf5:       db ": keyf5 $14 ;",0 
613e .. 00		keyf6:       db ": keyf6 $15 ;",0 
614c .. 00		keyf7:       db ": keyf7 $16 ;",0 
615a .. 00		keyf8:       db ": keyf8 $17 ;",0 
6168 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6176 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6185 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6194 .. 00		keyf12:       db ": keyf12 $1b ;",0 
61a3			 
61a3 .. 00		keytab:       db ": keytab $09 ;",0 
61b2 .. 00		keycr:       db ": keycr $0d ;",0 
61c0 .. 00		keyhome:       db ": keyhome $0e ;",0 
61d0 .. 00		keyend:       db ": keyend $0f ;",0 
61df .. 00		keybs:       db ": keybs $08 ;",0 
61ed			 
61ed			   
61ed			 
61ed			 
61ed			 
61ed			; eof 
# End of file forth_autostart.asm
61ed			 
61ed .. 00		sprompt1: db "Startup load...",0 
61fd .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6213			 
6213			forth_startup: 
6213 21 4b 53			ld hl, startcmds 
6216 3e 00			ld a, 0 
6218 32 43 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
621b			 
621b e5			.start1:	push hl 
621c cd d5 0a			call clear_display 
621f 11 ed 61			ld de, sprompt1 
6222 3e 00		        ld a, display_row_1 
6224 cd e8 0a			call str_at_display 
6227 11 fd 61			ld de, sprompt2 
622a 3e 28		        ld a, display_row_2 
622c cd e8 0a			call str_at_display 
622f e1				pop hl 
6230 e5				push hl 
6231 5e				ld e,(hl) 
6232 23				inc hl 
6233 56				ld d,(hl) 
6234 3e 50		        ld a, display_row_3 
6236 cd e8 0a			call str_at_display 
6239 cd f8 0a			call update_display 
623c			 
623c			 
623c 3a 43 f2			ld a, (os_last_cmd) 
623f fe 00			cp 0 
6241 28 05			jr z, .startprompt 
6243 cd 49 0a			call delay250ms 
6246 18 24			jr .startdo 
6248				 
6248				 
6248			 
6248			.startprompt: 
6248			 
6248 3e 9f			ld a,display_row_4 + display_cols - 1 
624a 11 95 1b		        ld de, endprg 
624d cd e8 0a			call str_at_display 
6250 cd f8 0a			call update_display 
6253 cd 55 0a			call delay1s 
6256 cd 3c 68			call cin_wait 
6259						 
6259 fe 2a			cp '*' 
625b 28 5e			jr z, .startupend1 
625d fe 23			cp '#' 
625f 20 07			jr nz, .startno 
6261 3e 01			ld a, 1 
6263 32 43 f2			ld (os_last_cmd),a 
6266 18 04			jr .startdo 
6268 fe 31		.startno:	cp '1' 
626a 28 3a			jr z,.startnxt  
626c			 
626c				; exec startup line 
626c			.startdo:	 
626c e1				pop hl 
626d e5				push hl 
626e				 
626e 5e				ld e,(hl) 
626f 23				inc hl 
6270 56				ld d,(hl) 
6271 eb				ex de,hl 
6272			 
6272 e5				push hl 
6273			 
6273 3e 00			ld a, 0 
6275				;ld a, FORTH_END_BUFFER 
6275 cd 72 11			call strlent 
6278 23				inc hl   ; include zero term to copy 
6279 06 00			ld b,0 
627b 4d				ld c,l 
627c e1				pop hl 
627d 11 1d ee			ld de, scratch 
6280 ed b0			ldir 
6282			 
6282			 
6282 21 1d ee			ld hl, scratch 
6285 cd d6 1f			call forthparse 
6288 cd 16 20			call forthexec 
628b cd 2d 1f			call forthexec_cleanup 
628e			 
628e 3e 78			ld a, display_row_4 
6290 11 39 19			ld de, endprog 
6293			 
6293 cd f8 0a			call update_display		 
6296			 
6296 3a 43 f2			ld a, (os_last_cmd) 
6299 fe 00			cp 0 
629b 20 09			jr nz, .startnxt 
629d cd 97 1b			call next_page_prompt 
62a0 cd d5 0a		        call clear_display 
62a3 cd f8 0a			call update_display		 
62a6			 
62a6				; move onto next startup line? 
62a6			.startnxt: 
62a6			 
62a6 cd 49 0a			call delay250ms 
62a9 e1				pop hl 
62aa			 
62aa 23				inc hl 
62ab 23				inc hl 
62ac			 
62ac e5				push hl 
62ad 5e				ld e, (hl) 
62ae 23				inc hl 
62af 56				ld d, (hl) 
62b0 e1				pop hl 
62b1				; TODO replace 0 test 
62b1			 
62b1 eb				ex de, hl 
62b2 cd 32 0d			call ishlzero 
62b5			;	ld a,e 
62b5			;	add d 
62b5			;	cp 0    ; any left to do? 
62b5 eb				ex de, hl 
62b6 c2 1b 62			jp nz, .start1 
62b9 18 01			jr .startupend 
62bb			 
62bb e1			.startupend1: pop hl 
62bc			.startupend: 
62bc			 
62bc cd d5 0a			call clear_display 
62bf cd f8 0a			call update_display 
62c2 c9				ret 
62c3			 
62c3			 
62c3			; stack over and underflow checks 
62c3			 
62c3			; init the words to detect the under/overflow 
62c3			 
62c3			chk_stk_init: 
62c3				; a vague random number to check so we dont get any "lucky" hits 
62c3 3e 2d			ld a, 45 
62c5 6f				ld l, a 
62c6 00				nop 
62c7 3e 17			ld a, 23 
62c9 67				ld h, a 
62ca			 
62ca 22 04 ee			ld (chk_word), hl     ; the word we need to check against 
62cd			 
62cd			;	ld (chk_stund), hl	; stack points.... 
62cd 22 fd fb			ld (chk_stovr), hl 
62d0 22 08 f8			ld (chk_ret_und), hl 
62d3 22 86 f7			ld (chk_ret_ovr), hl 
62d6 22 84 f5			ld (chk_loop_ovr), hl 
62d9 22 82 f3			ld (chk_data_ovr), hl 
62dc c9				ret 
62dd				 
62dd			check_stacks: 
62dd				; check all stack words 
62dd			 
62dd e5				push hl 
62de d5				push de 
62df			 
62df			;	ld de,(chk_word) 
62df			;	ld hl, (chk_stund)	; stack points.... 
62df			;	if DEBUG_STK_FAULT 
62df			;		DMARK "FAa" 
62df			;		CALLMONITOR 
62df			;	endif 
62df			;	call cmp16 
62df			;	jp z, .chk_faulta 
62df			; 
62df			;	ld de, sfaultsu 
62df			;	jp .chk_fault 
62df			 
62df 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
62e2 ed 5b 04 ee		ld de,(chk_word) 
62e6				if DEBUG_STK_FAULT 
62e6					DMARK "FAb" 
62e6					CALLMONITOR 
62e6				endif 
62e6 cd 27 0d			call cmp16 
62e9 28 06			jr z, .chk_fault1 
62eb 11 8c 63			ld de, sfaultso 
62ee c3 40 63			jp .chk_fault 
62f1			.chk_fault1:  
62f1 2a 08 f8			ld hl, (chk_ret_und) 
62f4 ed 5b 04 ee		ld de,(chk_word) 
62f8				if DEBUG_STK_FAULT 
62f8					DMARK "FAU" 
62f8					CALLMONITOR 
62f8				endif 
62f8 cd 27 0d			call cmp16 
62fb ca 04 63			jp z, .chk_fault2 
62fe 11 9c 63			ld de, sfaultru 
6301 c3 40 63			jp .chk_fault 
6304			.chk_fault2:  
6304 2a 86 f7			ld hl, (chk_ret_ovr) 
6307 ed 5b 04 ee		ld de,(chk_word) 
630b				if DEBUG_STK_FAULT 
630b					DMARK "FA1" 
630b					CALLMONITOR 
630b				endif 
630b cd 27 0d			call cmp16 
630e ca 17 63			jp z, .chk_fault3 
6311 11 aa 63			ld de, sfaultro 
6314 c3 40 63			jp .chk_fault 
6317			.chk_fault3:  
6317 2a 84 f5			ld hl, (chk_loop_ovr) 
631a ed 5b 04 ee		ld de,(chk_word) 
631e				if DEBUG_STK_FAULT 
631e					DMARK "FA2" 
631e					CALLMONITOR 
631e				endif 
631e cd 27 0d			call cmp16 
6321 ca 2a 63			jp z, .chk_fault4 
6324 11 c4 63			ld de, sfaultlo 
6327 c3 40 63			jp .chk_fault 
632a			.chk_fault4:  
632a 2a 82 f3			ld hl, (chk_data_ovr) 
632d ed 5b 04 ee		ld de,(chk_word) 
6331				if DEBUG_STK_FAULT 
6331					DMARK "FA3" 
6331					CALLMONITOR 
6331				endif 
6331 cd 27 0d			call cmp16 
6334 ca 3d 63			jp z, .chk_fault5 
6337 11 de 63			ld de, sfaultdo 
633a c3 40 63			jp .chk_fault 
633d			 
633d			 
633d			.chk_fault5:  
633d d1				pop de 
633e e1				pop hl 
633f			 
633f c9				ret 
6340			 
6340 cd d5 0a		.chk_fault: 	call clear_display 
6343 3e 28				ld a, display_row_2 
6345 cd e8 0a				call str_at_display 
6348 11 6e 63				   ld de, .stackfault 
634b 3e 00				ld a, display_row_1 
634d cd e8 0a				call str_at_display 
6350 11 77 fb				    ld de, debug_mark 
6353 3e 11				ld a, display_row_1+17 
6355 cd e8 0a				call str_at_display 
6358 cd f8 0a				call update_display 
635b			 
635b				; prompt before entering montior for investigating issue 
635b			 
635b 3e 78			ld a, display_row_4 
635d 11 39 19			ld de, endprog 
6360			 
6360 cd f8 0a			call update_display		 
6363			 
6363 cd 97 1b			call next_page_prompt 
6366			 
6366 d1				pop de 
6367 e1				pop hl 
6368 cd 8d 19				call monitor 
636b c3 87 18				jp warmstart 
636e					;jp 0 
636e					;halt 
636e			 
636e			 
636e			 
636e .. 00		.stackfault: 	db "Stack fault:",0 
637b			 
637b .. 00		sfaultsu: 	db	"Stack under flow",0 
638c .. 00		sfaultso: 	db	"Stack over flow",0 
639c .. 00		sfaultru:	db "RTS underflow",0 
63aa .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
63c4 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
63de .. 00		sfaultdo:	db "DTS overflow", 0 
63eb			 
63eb			 
63eb			fault_dsp_under: 
63eb 11 fd 63			ld de, .dsp_under 
63ee c3 ad 64			jp .show_fault 
63f1			 
63f1			fault_rsp_under: 
63f1 11 0b 64			ld de, .rsp_under 
63f4 c3 ad 64			jp .show_fault 
63f7			fault_loop_under: 
63f7 11 19 64			ld de, .loop_under 
63fa c3 ad 64			jp .show_fault 
63fd			 
63fd .. 00		.dsp_under: db "DSP Underflow",0 
640b .. 00		.rsp_under: db "RSP Underflow",0 
6419 .. 00		.loop_under: db "LOOP Underflow",0 
6428			 
6428			 
6428 d5			type_faultn: 	push de 
6429 e5					push hl 
642a cd d5 0a				call clear_display 
642d 11 54 64				   ld de, .typefaultn 
6430 3e 00				ld a, display_row_1 
6432 cd e8 0a				call str_at_display 
6435 11 77 fb				    ld de, debug_mark 
6438 3e 11				ld a, display_row_1+17 
643a cd e8 0a				call str_at_display 
643d cd f8 0a				call update_display 
6440			 
6440				; prompt before entering montior for investigating issue 
6440			 
6440 3e 78			ld a, display_row_4 
6442 11 39 19			ld de, endprog 
6445			 
6445 cd f8 0a			call update_display		 
6448			 
6448 cd 97 1b			call next_page_prompt 
644b			 
644b e5					push hl 
644c d5					push de 
644d cd 8d 19				call monitor 
6450 c3 87 18				jp warmstart 
6453 76					halt 
6454			 
6454			 
6454 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
646b			 
646b d5			type_faults: 	push de 
646c e5					push hl 
646d cd d5 0a				call clear_display 
6470 11 96 64				   ld de, .typefaults 
6473 3e 00				ld a, display_row_1 
6475 cd e8 0a				call str_at_display 
6478 11 77 fb				    ld de, debug_mark 
647b 3e 11				ld a, display_row_1+17 
647d cd e8 0a				call str_at_display 
6480 cd f8 0a				call update_display 
6483			 
6483				; prompt before entering montior for investigating issue 
6483			 
6483 3e 78			ld a, display_row_4 
6485 11 39 19			ld de, endprog 
6488			 
6488 cd f8 0a			call update_display		 
648b			 
648b cd 97 1b			call next_page_prompt 
648e			 
648e e1					pop hl 
648f d1					pop de 
6490 cd 8d 19				call monitor 
6493 c3 87 18				jp warmstart 
6496			 
6496			 
6496 .. 00		.typefaults: db "STR Type Expected TOS!",0 
64ad			 
64ad			.show_fault: 	 
64ad d5					push de 
64ae cd d5 0a				call clear_display 
64b1 d1					pop de 
64b2 3e 00				ld a, display_row_1 
64b4 cd e8 0a				call str_at_display 
64b7 11 77 fb				    ld de, debug_mark 
64ba 3e 11				ld a, display_row_1+17 
64bc cd e8 0a				call str_at_display 
64bf cd f8 0a				call update_display 
64c2			 
64c2				; prompt before entering montior for investigating issue 
64c2			 
64c2 3e 78			ld a, display_row_4 
64c4 11 39 19			ld de, endprog 
64c7			 
64c7 cd f8 0a			call update_display		 
64ca			 
64ca cd 97 1b			call next_page_prompt 
64cd			 
64cd e1					pop hl 
64ce d1					pop de 
64cf cd 8d 19				call monitor 
64d2			; do a dump to cli and not warmstart so we preserve all of the uwords.  
64d2			; TODO Make optional fault restart to cli or warm boot? 
64d2					;jp warmstart 
64d2 c3 df 18				jp cli 
64d5 76					halt 
64d6			; eof 
# End of file forth_kernel.asm
64d6			;include "nascombasic.asm" 
64d6			 
64d6			 
64d6			; find out where the code ends if loaded into RAM (for SC114) 
64d6			;endofcode:  
64d6			;	nop 
64d6			 
64d6			 
64d6			; eof 
64d6			 
# End of file main.asm
64d6			include "firmware_lcd_4x40.asm" 
64d6			; **********************************************************************  
64d6			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
64d6			; **********************************************************************  
64d6			;  
64d6			; **  Written as a Small Computer Monitor App  
64d6			; **  www.scc.me.uk  
64d6			;  
64d6			; History  
64d6			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
64d6			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
64d6			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
64d6			;  
64d6			; **********************************************************************  
64d6			;  
64d6			; This program is an example of one of the methods of interfacing an   
64d6			; alphanumeric LCD module.   
64d6			;  
64d6			; In this example the display is connected to either a Z80 PIO or a   
64d6			; simple 8-bit output port.   
64d6			;  
64d6			; This interfacing method uses 4-bit data mode and uses time delays  
64d6			; rather than polling the display's ready status. As a result the   
64d6			; interface only requires 6 simple output lines:  
64d6			;   Output bit 0 = not used  
64d6			;   Output bit 1 = not used  
64d6			;   Output bit 2 = RS         High = data, Low = instruction  
64d6			;   Output bit 3 = E          Active high  
64d6			;   Output bit 4 = DB4  
64d6			;   Output bit 5 = DB5  
64d6			;   Output bit 6 = DB6  
64d6			;   Output bit 7 = DB7  
64d6			; Display's R/W is connected to 0v so it is always in write mode  
64d6			;  
64d6			; This set up should work with any system supporting the RC2014 bus  
64d6			  
64d6			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
64d6			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
64d6			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
64d6			;  
64d6			; **********************************************************************  
64d6			  
64d6			; Additonal for 4x40. E1 and E2 instead of just E   
64d6			; TODO swipe vidout signal on port a to activate E2  
64d6			  
64d6			; **********************************************************************  
64d6			; **  Constants  
64d6			; **********************************************************************  
64d6			; LCD constants required by LCD support module  
64d6			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
64d6			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
64d6			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
64d6			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
64d6			; TODO Decide which E is being set  
64d6			kLCDWidth:  EQU display_cols             ;Width in characters  
64d6			  
64d6			; **********************************************************************  
64d6			; **  Code library usage  
64d6			; **********************************************************************  
64d6			  
64d6			; send character to current cursor position  
64d6			; wraps and/or scrolls screen automatically  
64d6			  
64d6			  
64d6			  
64d6			lcd_init:  
64d6			  
64d6			; SCMonAPI functions used  
64d6			  
64d6			; Alphanumeric LCD functions used  
64d6			; no need to specify specific functions for this module  
64d6			  
64d6 3e cf		            LD   A, 11001111b  
64d8 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
64da 3e 00		            LD   A, 00000000b  
64dc d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
64de			  
64de			; Initialise alphanumeric LCD module  
64de 3e 00				ld a, 0  
64e0 32 d7 f8				ld (display_lcde1e2), a  
64e3 cd 64 65		            CALL fLCD_Init      ;Initialise LCD module  
64e6 3e 01				ld a, 1  
64e8 32 d7 f8				ld (display_lcde1e2), a  
64eb cd 64 65		            CALL fLCD_Init      ;Initialise LCD module  
64ee			  
64ee c9				ret  
64ef			  
64ef			;  
64ef			;;  
64ef			; lcd functions  
64ef			;  
64ef			;  
64ef			  
64ef			; what is at cursor position   
64ef			  
64ef			;get_cursor:	ld de, (cursor_row)   ;  row + col  
64ef			;		call curptr  
64ef			;		ret  
64ef			  
64ef			  
64ef			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
64ef			  
64ef			curptr:  
64ef c5				push bc  
64f0 21 bd fa			ld hl, display_fb0  
64f3			cpr:	  
64f3				; loop for cursor whole row  
64f3 0e 28			ld c, display_cols  
64f5 23			cpr1:	inc hl  
64f6 0d				dec c  
64f7 20 fc			jr nz, cpr1  
64f9 05				dec b  
64fa 20 f7			jr nz, cpr  
64fc			  
64fc				; add col	  
64fc			  
64fc 23			cpr2:	inc hl  
64fd 1d				dec e  
64fe 20 fc			jr nz, cpr2  
6500			  
6500 c1				pop bc  
6501 c9				ret  
6502				  
6502			  
6502			  
6502			  
6502			  
6502			; write the frame buffer given in hl to hardware   
6502 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
6505 3e 00			ld a, kLCD_Line1  
6507 cd 11 66		            CALL fLCD_Pos       ;Position cursor to location in A  
650a 06 28			ld b, display_cols  
650c ed 5b d5 f8		ld de, (display_write_tmp)  
6510 cd 5c 65			call write_len_string  
6513				  
6513				  
6513 2a d5 f8			ld hl, (display_write_tmp)  
6516 11 28 00			ld de, display_cols  
6519 19				add hl,de  
651a 22 d5 f8			ld (display_write_tmp),hl  
651d			  
651d				  
651d 3e 28			ld a, kLCD_Line2  
651f cd 11 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6522 06 28			ld b, display_cols  
6524 ed 5b d5 f8		ld de, (display_write_tmp)  
6528 cd 5c 65			call write_len_string  
652b				  
652b 2a d5 f8			ld hl, (display_write_tmp)  
652e 11 28 00			ld de, display_cols  
6531 19				add hl,de  
6532 22 d5 f8			ld (display_write_tmp),hl  
6535			  
6535				  
6535 3e 50			ld a, kLCD_Line3  
6537 cd 11 66		            CALL fLCD_Pos       ;Position cursor to location in A  
653a 06 28			ld b, display_cols  
653c ed 5b d5 f8		ld de, (display_write_tmp)  
6540 cd 5c 65			call write_len_string  
6543				  
6543 2a d5 f8			ld hl, (display_write_tmp)  
6546 11 28 00			ld de, display_cols  
6549 19				add hl,de  
654a 22 d5 f8			ld (display_write_tmp),hl  
654d			  
654d				  
654d 3e 78			ld a, kLCD_Line4  
654f cd 11 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6552 06 28			ld b, display_cols  
6554 ed 5b d5 f8		ld de, (display_write_tmp)  
6558 cd 5c 65			call write_len_string  
655b c9					ret  
655c				  
655c				; write out a fixed length string given in b from de  
655c			  
655c 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
655d cd c9 65		            CALL fLCD_Data      ;Write character to display  
6560 13				inc de  
6561 10 f9			djnz write_len_string  
6563 c9				ret  
6564			  
6564			; Some other things to do  
6564			;            LD   A, kLCD_Clear ;Display clear  
6564			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6564			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6564			;            LD   A, kLCD_On     ;Display on with no cursor  
6564			;            ;LD   A, kLCD_Off   ;Display off  
6564			;            CALL fLCD_Inst      ;Send instruction to display  
6564			;  
6564			;  
6564			;            halt  
6564			;  
6564			;  
6564			;MsgHello:   DB  "Hello World!",0  
6564			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6564			  
6564			; Custom characters 5 pixels wide by 8 pixels high  
6564			; Up to 8 custom characters can be defined  
6564			;BitMaps:      
6564			;; Character 0x00 = Battery icon  
6564			;            DB  01110b  
6564			;            DB  11011b  
6564			;            DB  10001b  
6564			;            DB  10001b  
6564			;            DB  11111b  
6564			;            DB  11111b  
6564			;            DB  11111b  
6564			;            DB  11111b  
6564			;; Character 0x01 = Bluetooth icon  
6564			;            DB  01100b  
6564			;            DB  01010b  
6564			;            DB  11100b  
6564			;            DB  01000b  
6564			;            DB  11100b  
6564			;            DB  01010b  
6564			;            DB  01100b  
6564			;            DB  00000b  
6564			;  
6564			  
6564			  
6564			; **********************************************************************  
6564			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6564			; **********************************************************************  
6564			;  
6564			; **  Written as a Small Computer Monitor App   
6564			; **  Version 0.1 SCC 2018-05-16  
6564			; **  www.scc.me.uk  
6564			;  
6564			; **********************************************************************  
6564			;  
6564			; This module provides support for alphanumeric LCD modules using with  
6564			; *  HD44780 (or compatible) controller  
6564			; *  5 x 7 pixel fonts  
6564			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6564			; *  Interface via six digital outputs to the display (see below)  
6564			;  
6564			; LCD module pinout:  
6564			;   1  Vss   0v supply  
6564			;   2  Vdd   5v supply  
6564			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6564			;   4  RS    High = data, Low = instruction  
6564			;   5  R/W   High = Read, Low = Write  
6564			;   6  E     Enable signal (active high)  
6564			;   7  DB0   Data bit 0  
6564			;   8  DB1   Data bit 1  
6564			;   9  DB2   Data bit 2  
6564			;  10  DB3   Data bit 3  
6564			;  11  DB4   Data bit 4  
6564			;  12  DB5   Data bit 5  
6564			;  13  DB6   Data bit 6  
6564			;  14  DB7   Data bit 7  
6564			;  15  A     Backlight anode (+)  
6564			;  16  K     Backlight cathode (-)  
6564			;  
6564			; This interfacing method uses 4-bit data mode and uses time delays  
6564			; rather than polling the display's ready status. As a result the   
6564			; interface only requires 6 simple output lines:  
6564			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6564			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6564			;   LCD DB4 = Microcomputer output port bit 4  
6564			;   LCD DB5 = Microcomputer output port bit 5  
6564			;   LCD DB6 = Microcomputer output port bit 6  
6564			;   LCD DB7 = Microcomputer output port bit 7  
6564			; Display's R/W is connected to 0v so it is always in write mode  
6564			; All 6 connections must be on the same port address <kLCDPrt>  
6564			; This method also allows a decent length of cable from micro to LCD  
6564			;  
6564			; **********************************************************************  
6564			;  
6564			; To include the code for any given function provided by this module,   
6564			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6564			; the parent source file.  
6564			; For example:  #REQUIRES   uHexPrefix  
6564			;  
6564			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6564			; in the parent source file.  
6564			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6564			;  
6564			; These are the function names provided by this module:  
6564			; fLCD_Init                     ;Initialise LCD  
6564			; fLCD_Inst                     ;Send instruction to LCD  
6564			; fLCD_Data                     ;Send data byte to LCD  
6564			; fLCD_Pos                      ;Position cursor  
6564			; fLCD_Str                      ;Display string  
6564			; fLCD_Def                      ;Define custom character  
6564			;  
6564			; **********************************************************************  
6564			;  
6564			; Requires SCMonAPI.asm to also be included in the project  
6564			;  
6564			  
6564			  
6564			; **********************************************************************  
6564			; **  Constants  
6564			; **********************************************************************  
6564			  
6564			; Constants that must be defined externally  
6564			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6564			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6564			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6564			;kLCDWidth: EQU 20             ;Width in characters  
6564			  
6564			; general line offsets in any frame buffer  
6564			  
6564			  
6564			display_row_1: equ 0  
6564			display_row_2: equ display_row_1+display_cols  
6564			display_row_3: equ display_row_2 + display_cols  
6564			display_row_4: equ display_row_3 + display_cols  
6564			;display_row_4_eol:   
6564			  
6564			  
6564			; Cursor position values for the start of each line  
6564			  
6564			; E  
6564			kLCD_Line1: EQU 0x00   
6564			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6564			; E1  
6564			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6564			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6564			  
6564			; Instructions to send as A register to fLCD_Inst  
6564			kLCD_Clear: EQU 00000001b     ;LCD clear  
6564			kLCD_Off:   EQU 00001000b     ;LCD off  
6564			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6564			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6564			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6564			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6564			  
6564			; Constants used by this code module  
6564			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6564			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6564			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6564			  
6564			  
6564			  
6564			; **********************************************************************  
6564			; **  LCD support functions  
6564			; **********************************************************************  
6564			  
6564			; Initialise alphanumeric LCD module  
6564			; LCD control register codes:  
6564			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6564			;   N    0 = 1-line mode       1 = 2-line mode  
6564			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6564			;   D    0 = Display off       1 = Display on  
6564			;   C    0 = Cursor off        1 = Cursor on  
6564			;   B    0 = Blinking off      1 = Blinking on  
6564			;   ID   0 = Decrement mode    1 = Increment mode  
6564			;   SH   0 = Entire shift off  1 = Entire shift on  
6564 3e 28		fLCD_Init:  LD   A, 40  
6566 cd 8b 66		            CALL LCDDelay       ;Delay 40ms after power up  
6569			; For reliable reset set 8-bit mode - 3 times  
6569 cd 5b 66		            CALL WrFn8bit       ;Function = 8-bit mode  
656c cd 5b 66		            CALL WrFn8bit       ;Function = 8-bit mode  
656f cd 5b 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6572			; Set 4-bit mode  
6572 cd 57 66		            CALL WrFn4bit       ;Function = 4-bit mode  
6575 cd 89 66		            CALL LCDDelay1      ;Delay 37 us or more  
6578			; Function set  
6578 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
657a cd 8d 65		            CALL fLCD_Inst      ;2 line, display on  
657d			; Display On/Off control  
657d 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
657f cd 8d 65		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6582			; Display Clear  
6582 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6584 cd 8d 65		            CALL fLCD_Inst      ;Clear display  
6587			; Entry mode  
6587 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6589 cd 8d 65		            CALL fLCD_Inst      ;Increment mode, shift off  
658c			; Display module now initialised  
658c c9			            RET  
658d			; ok to here  
658d			  
658d			; Write instruction to LCD  
658d			;   On entry: A = Instruction byte to be written  
658d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
658d f5			fLCD_Inst:  PUSH AF  
658e f5			            PUSH AF  
658f cd a1 65		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6592 f1			            POP  AF  
6593 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6594 17			            RLA  
6595 17			            RLA  
6596 17			            RLA  
6597 cd a1 65		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
659a 3e 02		            LD   A, 2  
659c cd 8b 66		            CALL LCDDelay       ;Delay 2 ms to complete   
659f f1			            POP  AF  
65a0 c9			            RET  
65a1			Wr4bits:   
65a1 f5					push af  
65a2 3a d7 f8				ld a, (display_lcde1e2)  
65a5 fe 00				cp 0     ; e  
65a7 20 10				jr nz, .wea2	  
65a9 f1					pop af  
65aa e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
65ac d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65ae cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
65b0 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
65b2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
65b4 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
65b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65b8 c9			            RET  
65b9 f1			.wea2:		pop af  
65ba e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
65bc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65be cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
65c0 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
65c2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
65c4 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
65c6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65c8 c9			            RET  
65c9			  
65c9			  
65c9			; Write data to LCD  
65c9			;   On entry: A = Data byte to be written  
65c9			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65c9 f5			fLCD_Data:  PUSH AF  
65ca f5			            PUSH AF  
65cb cd dd 65		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
65ce f1			            POP  AF  
65cf 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
65d0 17			            RLA  
65d1 17			            RLA  
65d2 17			            RLA  
65d3 cd dd 65		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
65d6 3e 96		            LD   A, 150  
65d8 3d			Wait:      DEC  A              ;Wait a while to allow data   
65d9 20 fd		            JR   NZ, Wait      ;  write to complete  
65db f1			            POP  AF  
65dc c9			            RET  
65dd			Wr4bitsa:     
65dd f5					push af  
65de 3a d7 f8				ld a, (display_lcde1e2)  
65e1 fe 00				cp 0     ; e1  
65e3 20 16				jr nz, .we2	  
65e5 f1					pop af  
65e6 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
65e8 cb d7		            SET  kLCDBitRS, A  
65ea d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
65ec cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
65ee cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
65f0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
65f2 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
65f4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
65f6 cb 97		            RES  kLCDBitRS, A  
65f8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65fa c9			            RET  
65fb f1			.we2:		pop af  
65fc e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
65fe cb d7		            SET  kLCDBitRS, A  
6600 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6602 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
6604 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
6606 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6608 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
660a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
660c cb 97		            RES  kLCDBitRS, A  
660e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6610 c9			            RET  
6611			  
6611			  
6611			; Position cursor to specified location  
6611			;   On entry: A = Cursor position  
6611			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6611 f5			fLCD_Pos:   PUSH AF  
6612					; at this point set the E1 or E2 flag depending on position  
6612			  
6612 c5					push bc  
6613			;		push af  
6613 06 00				ld b, 0  
6615 4f					ld c, a  
6616 3e 4f				ld a, kLCD_Line3-1  
6618 b7			 		or a      ;clear carry flag  
6619 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
661a 38 04				jr c, .pe1  
661c			  
661c					; E selection  
661c cb 80				res 0, b         ; bit 0 unset e  
661e			;		pop af    ; before line 3 so recover orig pos  
661e			;		ld c, a    ; save for poking back  
661e 18 06				jr .peset	          
6620			.pe1:          	; E2 selection  
6620 cb c0				set 0, b         ; bit 0 set e1  
6622 79					ld a, c  
6623 de 4f				sbc a, kLCD_Line3-1  
6625 4f					ld c, a	         ; save caculated offset  
6626			;		pop af     ; bin this original value now we have calculated form  
6626			  
6626			.peset:		; set bit  
6626 78					ld a, b  
6627 32 d7 f8				ld (display_lcde1e2), a 	  
662a 79					ld a, c  
662b c1					pop bc  
662c			  
662c f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
662e cd 8d 65		            CALL fLCD_Inst      ;Write instruction to LCD  
6631 f1			            POP  AF  
6632 c9			            RET  
6633			  
6633			  
6633			; Output text string to LCD  
6633			;   On entry: DE = Pointer to null terminated text string  
6633			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6633 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6634 b7			            OR   A              ;Null terminator?  
6635 c8			            RET  Z              ;Yes, so finished  
6636 cd c9 65		            CALL fLCD_Data      ;Write character to display  
6639 13			            INC  DE             ;Point to next character  
663a 18 f7		            JR   fLCD_Str       ;Repeat  
663c c9					ret  
663d			  
663d			; Define custom character  
663d			;   On entry: A = Character number (0 to 7)  
663d			;             DE = Pointer to character bitmap data  
663d			;   On exit:  A = Next character number  
663d			;             DE = Next location following bitmap  
663d			;             BC HL IX IY I AF' BC' DE' HL' preserved  
663d			; Character is   
663d c5			fLCD_Def:   PUSH BC  
663e f5			            PUSH AF  
663f 07			            RLCA                ;Calculate location  
6640 07			            RLCA                ;  for bitmap data  
6641 07			            RLCA                ;  = 8 x CharacterNumber  
6642 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6644 cd 8d 65		            CALL fLCD_Inst      ;Write instruction to LCD  
6647 06 00		            LD   B, 0  
6649 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
664a cd c9 65		            CALL fLCD_Data      ;Write byte to display  
664d 13			            INC  DE             ;Point to next byte  
664e 04			            INC  B              ;Count bytes  
664f cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6651 28 f6		            JR   Z, Loop       ;No, so repeat  
6653 f1			            POP  AF  
6654 3c			            INC  A              ;Increment character number  
6655 c1			            POP  BC  
6656 c9			            RET  
6657			  
6657			  
6657			; **********************************************************************  
6657			; **  Private functions  
6657			; **********************************************************************  
6657			  
6657			; Write function to LCD  
6657			;   On entry: A = Function byte to be written  
6657			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6657 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6659 18 02		            JR   WrFunc  
665b 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
665d f5			WrFunc:     PUSH AF  
665e f5					push af  
665f 3a d7 f8				ld a, (display_lcde1e2)  
6662 fe 00				cp 0     ; e1  
6664 20 0f				jr nz, .wfea2	  
6666 f1					pop af  
6667 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6669 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
666b cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
666d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
666f cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6671 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6673 18 0d			jr .wfskip  
6675 f1			.wfea2:		pop af  
6676 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6678 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
667a cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
667c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
667e cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6680 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6682 3e 05		.wfskip:            LD  A, 5  
6684 cd 8b 66		            CALL LCDDelay       ;Delay 5 ms to complete  
6687 f1			            POP  AF  
6688 c9			            RET  
6689			  
6689			  
6689			; Delay in milliseconds  
6689			;   On entry: A = Number of milliseconds delay  
6689			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6689 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
668b d5			LCDDelay:   PUSH DE  
668c 5f			            LD   E, A           ;Delay by 'A' ms  
668d 16 00		            LD   D, 0  
668f cd 3a 0a		            CALL aDelayInMS  
6692 d1			            POP  DE  
6693 c9			            RET  
6694			  
6694			  
6694			testlcd:  
6694 3e 00			ld a, kLCD_Line1  
6696 cd 11 66			call fLCD_Pos  
6699 06 28			ld b, 40  
669b 11 c9 66			ld de, .ttext1  
669e cd 5c 65			call write_len_string  
66a1			  
66a1 3e 28			ld a, kLCD_Line2  
66a3 cd 11 66			call fLCD_Pos  
66a6 06 28			ld b, 40  
66a8 11 f2 66			ld de, .ttext2  
66ab cd 5c 65			call write_len_string  
66ae 3e 50			ld a, kLCD_Line3  
66b0 cd 11 66			call fLCD_Pos  
66b3 06 28			ld b, 40  
66b5 11 1b 67			ld de, .ttext3  
66b8 cd 5c 65			call write_len_string  
66bb 3e 78			ld a, kLCD_Line4  
66bd cd 11 66			call fLCD_Pos  
66c0 06 28			ld b, 40  
66c2 11 44 67			ld de, .ttext4  
66c5 cd 5c 65			call write_len_string  
66c8			  
66c8 76				halt  
66c9			  
66c9			  
66c9 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
66f2 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
671b .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
6744 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
676d			   
676d			  
676d			  
676d			; eof  
676d			  
# End of file firmware_lcd_4x40.asm
676d			;include "firmware_lcd_4x20.asm" 
676d			include "firmware_key_5x10.asm" 
676d			; 5 x 10 decade counter scanner  
676d			  
676d			  
676d			; TODO do cursor shape change for shift keys  
676d			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
676d			  
676d			  
676d			; bit mask for each scan column and row for teing the matrix  
676d			  
676d			  
676d			key_init:  
676d			  
676d			; SCMonAPI functions used  
676d			  
676d			; Alphanumeric LCD functions used  
676d			; no need to specify specific functions for this module  
676d			  
676d			  
676d 3e cf		            LD   A, 11001111b  
676f d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6771			;            LD   A, 00000000b  
6771 3e 1f		            LD   A, 00011111b  
6773 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6775			  
6775			  
6775				; TODO Configure cursor shapes  
6775			  
6775				; Load cursor shapes   
6775 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6777 11 87 67		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
677a 06 02		            LD   B, 2           ;Number of characters to define  
677c cd 3d 66		.DefLoop:   CALL fLCD_Def       ;Define custom character  
677f 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6781			  
6781 3e 01				ld a, 1  
6783 32 d0 f8			ld (cursor_shape),a  
6786 c9				ret  
6787			  
6787			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6787			; Up to 8 custom characters can be defined  
6787			.cursor_shapes:      
6787			;; Character 0x00 = Normal  
6787 1f			            DB  11111b  
6788 1f			            DB  11111b  
6789 1f			            DB  11111b  
678a 1f			            DB  11111b  
678b 1f			            DB  11111b  
678c 1f			            DB  11111b  
678d 1f			            DB  11111b  
678e 1f			            DB  11111b  
678f			;; Character 0x01 = Modifier  
678f 1f			            DB  11111b  
6790 1b			            DB  11011b  
6791 1b			            DB  11011b  
6792 1b			            DB  11011b  
6793 1b			            DB  11011b  
6794 1f			            DB  11111b  
6795 1b			            DB  11011b  
6796 1f			            DB  11111b  
6797			  
6797			  
6797			  
6797			  
6797			; Display custom character 0  
6797			;            LD   A, kLCD_Line1+14  
6797			;            CALL fLCD_Pos       ;Position cursor to location in A  
6797			;            LD   A, 0  
6797			;            CALL fLCD_Data      ;Write character in A at cursor  
6797			  
6797			; Display custom character 1  
6797			;            LD   A, kLCD_Line2+14  
6797			;            CALL fLCD_Pos      ;Position cursor to location in A  
6797			;            LD   A, 1  
6797			;            CALL fLCD_Data     ;Write character in A at cursor  
6797			  
6797			; keyboard scanning   
6797			  
6797			; character in from keyboard  
6797			  
6797			; mapping for the pcb layout  
6797			  
6797			.matrix_to_char:  
6797 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
67a2 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
67ad 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
67b8 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
67c3 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
67ce			.matrix_to_shift:  
67ce			  
67ce .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
67d9 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
67e4 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
67ef 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
67fa .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
6805			  
6805			.matrix_to_symbolshift:  
6805			  
6805 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6810 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
681b 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
6826			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6826 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6831 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
683c			  
683c			  
683c			  
683c			; mapping for a simple straight through breadboard layout  
683c			  
683c			;.matrix_to_char:  
683c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
683c			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
683c			;		db "asdfghjkl",KEY_CR,0  
683c			;		db "qwertyuiop",0  
683c			;		 db "1234567890",0  
683c			;.matrix_to_shift:  
683c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
683c			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
683c			;		db "ASDFGHJKL",KEY_CR,0  
683c			;		db "QWERTYUIOP",0  
683c			;		 db "!",'"',"#$%^&*()",0  
683c			;.matrix_to_symbolshift:  
683c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
683c			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
683c			;		db "_?*fghjk=",KEY_CR,0  
683c			;		db "-/+*[]{}@#",0  
683c			;		 db "1234567890",0  
683c			  
683c			;.matrix_to_char: db "D#0*C987B654A321"  
683c			  
683c			  
683c				  
683c			  
683c			; add cin and cin_wait  
683c			  
683c cd 4d 68		cin_wait: 	call cin  
683f						if DEBUG_KEYCINWAIT  
683f							push af  
683f							  
683f							ld hl,key_repeat_ct  
683f							ld (hl),a  
683f							inc hl  
683f							call hexout  
683f							ld hl,key_repeat_ct+3  
683f							ld a,0  
683f							ld (hl),a  
683f			  
683f							    LD   A, kLCD_Line1+11  
683f							    CALL fLCD_Pos       ;Position cursor to location in A  
683f							    LD   DE, key_repeat_ct  
683f							    ;LD   DE, MsgHello  
683f							    CALL fLCD_Str       ;Display string pointed to by DE  
683f			  
683f			  
683f			  
683f							pop af  
683f						endif  
683f fe 00			cp 0  
6841 28 f9			jr z, cin_wait   ; block until key press  
6843			  
6843							if DEBUG_KEYCINWAIT  
6843								push af  
6843			  
6843								ld a, 'A'	  
6843								ld hl,key_repeat_ct  
6843								ld (hl),a  
6843								inc hl  
6843								ld a,0  
6843								ld (hl),a  
6843			  
6843								    LD   A, kLCD_Line2+11  
6843								    CALL fLCD_Pos       ;Position cursor to location in A  
6843								    LD   DE, key_repeat_ct  
6843								    ;LD   DE, MsgHello  
6843								    CALL fLCD_Str       ;Display string pointed to by DE  
6843			  
6843							call delay500ms  
6843			  
6843								pop af  
6843							endif  
6843 f5				push af   ; save key pressed  
6844			  
6844			.cin_wait1:	  
6844							if DEBUG_KEYCINWAIT  
6844								push af  
6844			  
6844								ld a, 'b'	  
6844								ld hl,key_repeat_ct  
6844								ld (hl),a  
6844								inc hl  
6844								ld a,0  
6844								ld (hl),a  
6844			  
6844								    LD   A, kLCD_Line2+11  
6844								    CALL fLCD_Pos       ;Position cursor to location in A  
6844								    LD   DE, key_repeat_ct  
6844								    ;LD   DE, MsgHello  
6844								    CALL fLCD_Str       ;Display string pointed to by DE  
6844			  
6844			  
6844							call delay500ms  
6844			  
6844								pop af  
6844							endif  
6844			  
6844 cd 4d 68		call cin  
6847 fe 00			cp 0  
6849 20 f9			jr nz, .cin_wait1  	; wait for key release  
684b			if DEBUG_KEYCINWAIT  
684b				push af  
684b			  
684b				ld a, '3'	  
684b				ld hl,key_repeat_ct  
684b				ld (hl),a  
684b				inc hl  
684b				ld a,0  
684b				ld (hl),a  
684b			  
684b			            LD   A, kLCD_Line2+11  
684b			            CALL fLCD_Pos       ;Position cursor to location in A  
684b			            LD   DE, key_repeat_ct  
684b			            ;LD   DE, MsgHello  
684b			            CALL fLCD_Str       ;Display string pointed to by DE  
684b			  
684b			  
684b			call delay500ms  
684b			  
684b				pop af  
684b			endif  
684b			  
684b f1				pop af   ; get key  
684c c9				ret  
684d			  
684d			  
684d cd 61 68		cin: 	call .mtoc  
6850			  
6850			if DEBUG_KEYCIN  
6850				push af  
6850				  
6850				ld hl,key_repeat_ct  
6850				ld (hl),a  
6850				inc hl  
6850				call hexout  
6850				ld hl,key_repeat_ct+3  
6850				ld a,0  
6850				ld (hl),a  
6850			  
6850			            LD   A, kLCD_Line3+15  
6850			            CALL fLCD_Pos       ;Position cursor to location in A  
6850			            LD   DE, key_repeat_ct  
6850			            ;LD   DE, MsgHello  
6850			            CALL fLCD_Str       ;Display string pointed to by DE  
6850			  
6850			  
6850			call delay500ms  
6850			  
6850				pop af  
6850			endif  
6850			  
6850			  
6850				; no key held  
6850 fe 00			cp 0  
6852 c8				ret z  
6853			  
6853			if DEBUG_KEYCIN  
6853				push af  
6853			  
6853				ld a, '1'	  
6853				ld hl,key_repeat_ct  
6853				ld (hl),a  
6853				inc hl  
6853				ld a,0  
6853				ld (hl),a  
6853			  
6853			            LD   A, kLCD_Line4+15  
6853			            CALL fLCD_Pos       ;Position cursor to location in A  
6853			            LD   DE, key_repeat_ct  
6853			            ;LD   DE, MsgHello  
6853			            CALL fLCD_Str       ;Display string pointed to by DE  
6853			  
6853			  
6853			call delay500ms  
6853			  
6853				pop af  
6853			endif  
6853			  
6853				; stop key bounce  
6853			  
6853 32 88 fb			ld (key_held),a		 ; save it  
6856 47				ld b, a  
6857			  
6857 c5			.cina1:	push bc  
6858			if DEBUG_KEYCIN  
6858				push af  
6858			  
6858				ld hl,key_repeat_ct  
6858				inc hl  
6858				call hexout  
6858				ld hl,key_repeat_ct+3  
6858				ld a,0  
6858				ld (hl),a  
6858				ld hl,key_repeat_ct  
6858				ld a, '2'	  
6858				ld (hl),a  
6858			  
6858			            LD   A, kLCD_Line4+15  
6858			            CALL fLCD_Pos       ;Position cursor to location in A  
6858			            LD   DE, key_repeat_ct  
6858			            ;LD   DE, MsgHello  
6858			            CALL fLCD_Str       ;Display string pointed to by DE  
6858			  
6858				pop af  
6858			endif  
6858 cd 61 68			call .mtoc  
685b c1				pop bc  
685c b8				cp b  
685d 28 f8			jr z, .cina1  
685f 78				ld a,b		  
6860			if DEBUG_KEYCIN  
6860				push af  
6860			  
6860				ld hl,key_repeat_ct  
6860				inc hl  
6860				call hexout  
6860				ld hl,key_repeat_ct+3  
6860				ld a,0  
6860				ld (hl),a  
6860				ld hl,key_repeat_ct  
6860				ld a, '3'	  
6860				ld (hl),a  
6860			  
6860			            LD   A, kLCD_Line4+15  
6860			            CALL fLCD_Pos       ;Position cursor to location in A  
6860			            LD   DE, key_repeat_ct  
6860			            ;LD   DE, MsgHello  
6860			            CALL fLCD_Str       ;Display string pointed to by DE  
6860			  
6860				pop af  
6860			endif  
6860 c9				ret  
6861			  
6861			; detect keyboard modifier key press and apply new overlay to the face key held  
6861			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6861			  
6861			;.cin_map_modifier:   
6861			;	ld a, (hl)  
6861			;	and 255  
6861			;	ret NZ		; modifier key not flagged  
6861			;  
6861			;	; get key face  
6861			;  
6861			;	ld b,(key_face_held)  
6861			;  
6861			;	ld b, key_cols * key_rows  
6861			;  
6861			;	push de  
6861			;	pop hl  
6861			;  
6861			;.mmod1: ld a,(hl)   ; get map test  
6861			;	cp b  
6861			;	jr z, .mmod2  
6861			;  
6861			;  
6861			;  
6861			;.mmod2: inc hl    ;   
6861			;  
6861			;	  
6861			;  
6861			;	  
6861			;  
6861			;	ld hl,key_actual_pressed  
6861			;	ld (hl),a,  
6861			;	ret  
6861			  
6861			; map matrix key held to char on face of key  
6861			  
6861			.mtoc:  
6861			  
6861			; test decade counter strobes  
6861			  
6861			;.decadetest1:  
6861			  
6861			; reset counter  
6861			;ld a, 128  
6861			;out (portbdata),a  
6861			  
6861			  
6861			;ld b, 5  
6861			;.dec1:  
6861			;ld a, 0  
6861			;out (portbdata),a  
6861			;call delay1s  
6861			  
6861			;ld a, 32  
6861			;out (portbdata),a  
6861			;call delay1s  
6861			;call delay1s  
6861			;call delay1s  
6861			;  
6861			;ld a, 64+32  
6861			;out (portbdata),a  
6861			;call delay1s  
6861			;;djnz .dec1  
6861			;  
6861			;jp .decadetest1  
6861			  
6861			  
6861			  
6861			  
6861			  
6861			  
6861			  
6861			  
6861			  
6861			  
6861				; scan keyboard matrix and generate raw scan map  
6861 cd f4 68			call matrix  
6864			  
6864				; reuse c bit 0 left modifer button - ie shift  
6864			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6864				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6864			  
6864 0e 00			ld c, 0  
6866			  
6866				; TODO set flags for modifer key presses   
6866				; TODO do a search for modifer key...  
6866			  
6866				;ld hl,keyscan_table_row4  
6866 21 e7 fb			ld hl,keyscan_table_row2  
6869			  
6869 7e				ld a, (hl)  
686a fe 23			cp '#'  
686c 20 07			jr nz, .nextmodcheck  
686e cb c1			set 0, c  
6870 21 ce 67			ld hl, .matrix_to_shift  
6873 18 21			jr .dokeymap  
6875				; TODO for now igonre  
6875			.nextmodcheck:  
6875 21 dc fb			ld hl,keyscan_table_row3  
6878			  
6878 7e				ld a, (hl)  
6879 fe 23			cp '#'  
687b 20 07			jr nz, .nextmodcheck2  
687d cb c9			set 1, c   
687f 21 05 68			ld hl, .matrix_to_symbolshift  
6882 18 12			jr .dokeymap  
6884			.nextmodcheck2:  
6884 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
6887			  
6887 7e				ld a, (hl)  
6888 fe 23			cp '#'  
688a 20 07			jr nz, .donemodcheck  
688c cb c9			set 1, c   
688e 21 ce 67			ld hl, .matrix_to_shift  
6891 18 03			jr .dokeymap  
6893			  
6893				; no modifer found so just map to normal keys  
6893				; get mtoc map matrix to respective keys  
6893			;	ld hl, .matrix_to_char  
6893			;	ld hl, .matrix_to_char  
6893			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6893			;	ld a, KEY_SHIFT  
6893			;	call findchar  
6893			;  
6893			;	; got offset to key modifer in b  
6893			;  
6893			;	ld hl,keyscan_table_row5  
6893			;  
6893			;	ld a,b  
6893			;	call addatohl  
6893			;	ld a,(hl)  
6893			;  
6893			;	cp '#'  
6893			;	jr nz, .nextmodcheck  
6893			;	set 0, c  
6893			;	ld hl, .matrix_to_char  
6893			;	jr .dokeymap  
6893			;	; TODO for now igonre  
6893			;.nextmodcheck:  
6893			;	ld hl, .matrix_to_symbolshift  
6893			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6893			;	ld a, KEY_SYMBOLSHIFT  
6893			;	call findchar  
6893			;  
6893			;  
6893			;	; got offset to key modifer in b  
6893			;  
6893			;	ld hl,keyscan_table_row5  
6893			;  
6893			;	ld a,b  
6893			;	call addatohl  
6893			;	ld a,(hl)  
6893			;  
6893			;	cp '#'  
6893			;	jr nz, .donemodcheck  
6893			;	set 1, c   
6893			;	ld hl, .matrix_to_symbolshift  
6893			;	jr .dokeymap  
6893			  
6893			  
6893			  
6893			.donemodcheck:  
6893				; no modifer found so just map to normal keys  
6893				; get mtoc map matrix to respective keys  
6893 21 97 67			ld hl, .matrix_to_char  
6896			  
6896			.dokeymap:  
6896				;ld (key_fa), c   
6896 cd af 68			call .mapkeys  
6899			  
6899			  
6899			if DEBUG_KEY  
6899			  
6899			; Display text on first line  
6899			            LD   A, kLCD_Line1  
6899			            CALL fLCD_Pos       ;Position cursor to location in A  
6899			            LD   DE, keyscan_table_row1  
6899			            ;LD   DE, MsgHello  
6899			            CALL fLCD_Str       ;Display string pointed to by DE  
6899			  
6899			; Display text on second line  
6899			            LD   A, kLCD_Line2  
6899			            CALL fLCD_Pos       ;Position cursor to location in A  
6899			            LD   DE, keyscan_table_row2  
6899			            CALL fLCD_Str       ;Display string pointed to by DE  
6899			            LD   A, kLCD_Line3  
6899			            CALL fLCD_Pos       ;Position cursor to location in A  
6899			            LD   DE, keyscan_table_row3  
6899			            CALL fLCD_Str       ;Display string pointed to by DE  
6899			            LD   A, kLCD_Line4  
6899			            CALL fLCD_Pos       ;Position cursor to location in A  
6899			            LD   DE, keyscan_table_row4  
6899			            CALL fLCD_Str       ;Display string pointed to by DE  
6899			            LD   A, kLCD_Line1+10  
6899			            CALL fLCD_Pos       ;Position cursor to location in A  
6899			            LD   DE, keyscan_table_row5  
6899			            CALL fLCD_Str       ;Display string pointed to by DE  
6899			  
6899				;call delay250ms  
6899			endif  
6899			;	jp testkey  
6899			  
6899			; get first char reported  
6899			  
6899 21 c6 fb			ld hl,keyscan_table_row5  
689c			  
689c				;ld b, 46   ; 30 keys to remap + 8 nulls   
689c 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
689e			.findkey:  
689e 7e				ld a,(hl)  
689f fe 00			cp 0  
68a1 28 04			jr z, .nextkey  
68a3 fe 7e			cp KEY_MATRIX_NO_PRESS  
68a5 20 06			jr nz, .foundkey  
68a7			.nextkey:  
68a7 23				inc hl  
68a8 10 f4			djnz .findkey  
68aa 3e 00			ld a,0  
68ac c9				ret  
68ad			.foundkey:  
68ad 7e				ld a,(hl)  
68ae c9				ret  
68af				  
68af			  
68af			; convert the raw key map given hl for destination key  
68af			.mapkeys:  
68af 11 c6 fb			ld de,keyscan_table_row5  
68b2			  
68b2 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
68b4			.remap:  
68b4 1a				ld a,(de)  
68b5 fe 23			cp '#'  
68b7 20 02			jr nz, .remapnext  
68b9				;CALLMONITOR  
68b9 7e				ld a,(hl)  
68ba 12				ld (de),a  
68bb			  
68bb			  
68bb			  
68bb			.remapnext:  
68bb 23				inc hl  
68bc 13				inc de  
68bd 10 f5			djnz .remap  
68bf				  
68bf c9				ret  
68c0			  
68c0			  
68c0			  
68c0			.mtocold2:  
68c0			  
68c0			;	; flag if key D is held down and remove from reporting  
68c0			;	ld bc, .key_map_fd    
68c0			;	ld hl, keyscan_table  
68c0			;	ld de, key_fd  
68c0			;	call .key_shift_hold  
68c0			;	cp 255  
68c0			;	jr z, .cinmap  
68c0			;	; flag if key C is held down and remove from reporting  
68c0			;	ld bc, .key_map_fc    
68c0			;	ld hl, keyscan_table+key_cols  
68c0			;	ld de, key_fc  
68c0			;	call .key_shift_hold  
68c0			;	cp 255  
68c0			;	jr z, .cinmap  
68c0			;	; flag if key B is held down and remove from reporting  
68c0			;	ld bc, .key_map_fb    
68c0			;	ld hl, keyscan_table+(key_cols*2)  
68c0			;	ld de, key_fb  
68c0			;	call .key_shift_hold  
68c0			;	cp 255  
68c0			;	jr z, .cinmap  
68c0			;	; flag if key A is held down and remove from reporting  
68c0			;	ld bc, .key_map_fa    
68c0			;	ld hl, keyscan_table+(key_cols*3)  
68c0			;	ld de, key_fa  
68c0			;	call .key_shift_hold  
68c0			;	cp 255  
68c0			;	jr z, .cinmap  
68c0			  
68c0 11 97 67			ld de, .matrix_to_char  
68c3			  
68c3			  
68c3			.cinmap1:   
68c3				if DEBUG_KEY  
68c3			            LD   A, kLCD_Line4  
68c3			            CALL fLCD_Pos       ;Position cursor to location in A  
68c3					push de  
68c3			            LD   DE, keyscan_table  
68c3			            CALL fLCD_Str       ;Display string pointed to by DE  
68c3					pop de  
68c3				endif  
68c3			  
68c3				; scan key matrix table for any held key  
68c3			  
68c3				; de holds either the default matrix or one selected above  
68c3			  
68c3 21 93 fb			ld hl, keyscan_table  
68c6 06 32			ld b,key_cols*key_rows  
68c8			  
68c8 7e			.cin11:	ld a,(hl)  
68c9 fe 23			cp '#'  
68cb 28 08			jr z, .cinhit1  
68cd 23				inc hl  
68ce 13				inc de  
68cf 05				dec b  
68d0 20 f6			jr nz, .cin11  
68d2				; no key found held  
68d2 3e 00			ld a,0  
68d4 c9				ret  
68d5 d5			.cinhit1: push de  
68d6 e1				pop hl  
68d7 7e				ld a,(hl)  
68d8 c9				ret  
68d9			  
68d9			; flag a control key is held   
68d9			; hl is key pin, de is flag indicator  
68d9			  
68d9			.key_shift_hold1:  
68d9 c5				push bc  
68da 3e 01			ld a, 1  
68dc 32 d0 f8			ld (cursor_shape),a  
68df 06 00			ld b, 0  
68e1 7e				ld a, (hl)  
68e2 fe 2e			cp '.'  
68e4 28 0a			jr z, .key_shift11  
68e6 06 ff			ld b, 255  
68e8 3e 2b			ld a, '+'    ; hide key from later scans  
68ea 77				ld (hl),a  
68eb 3e 02			ld a, 2  
68ed 32 d0 f8			ld (cursor_shape),a  
68f0			.key_shift11:  
68f0				; write flag indicator  
68f0 78				ld a,b  
68f1 12				ld (de),a  
68f2			  
68f2 d1				pop de    ; de now holds the key map ptr  
68f3 c9				ret  
68f4			  
68f4				  
68f4			  
68f4			; scans keyboard matrix and flags key press in memory array	  
68f4				  
68f4			matrix:  
68f4				;call matrix  
68f4				; TODO optimise the code....  
68f4			  
68f4			  
68f4			;ld hl, keyscan_table_row1  
68f4			;ld de, keyscan_table_row1+1  
68f4			;ld bc,46  
68f4			;ld a,KEY_MATRIX_NO_PRESS  
68f4			;ldir  
68f4			  
68f4			  
68f4			  
68f4			; reset counter  
68f4 3e 80		ld a, 128  
68f6 d3 c1		out (portbdata),a  
68f8			  
68f8 06 0a		ld b, 10  
68fa 0e 00		ld c, 0       ; current clock toggle  
68fc			  
68fc			.colscan:  
68fc			  
68fc			; set current column  
68fc			; disable clock enable and set clock low  
68fc			  
68fc			;ld a, 0  
68fc			;out (portbdata),a  
68fc			  
68fc			; For each column scan for switches  
68fc			  
68fc c5			push bc  
68fd 21 89 fb		ld hl, keyscan_scancol  
6900 cd 09 6a		call .rowscan  
6903 c1			pop bc  
6904			  
6904			  
6904			; get back current column  
6904			  
6904			; translate the row scan  
6904			  
6904			;   
6904			; row 1  
6904			  
6904 78			ld a,b  
6905			  
6905 21 fc fb		LD   hl, keyscan_table_row1+10  
6908			  
6908 cd 1b 0d		call subafromhl  
690b			;call addatohl  
690b			  
690b 11 89 fb		ld de, keyscan_scancol  
690e			  
690e 1a			ld a,(de)  
690f 77			ld (hl),a  
6910			  
6910			  
6910			  
6910			  
6910			; row 2  
6910			  
6910 78			ld a,b  
6911			  
6911 21 f1 fb		LD   hl, keyscan_table_row2+10  
6914			  
6914			;call addatohl  
6914 cd 1b 0d		call subafromhl  
6917			  
6917			  
6917 11 8a fb		ld de, keyscan_scancol+1  
691a			  
691a 1a			ld a,(de)  
691b 77			ld (hl),a  
691c			  
691c			  
691c			; row 3  
691c			  
691c 78			ld a,b  
691d			  
691d 21 e6 fb		LD   hl, keyscan_table_row3+10  
6920			  
6920			;call addatohl  
6920 cd 1b 0d		call subafromhl  
6923			  
6923 11 8b fb		ld de, keyscan_scancol+2  
6926			  
6926 1a			ld a,(de)  
6927 77			ld (hl),a  
6928			  
6928			  
6928			  
6928			; row 4  
6928			  
6928 78			ld a,b  
6929			  
6929 21 db fb		LD   hl, keyscan_table_row4+10  
692c			  
692c			;call addatohl  
692c cd 1b 0d		call subafromhl  
692f			  
692f 11 8c fb		ld de, keyscan_scancol+3  
6932			  
6932 1a			ld a,(de)  
6933 77			ld (hl),a  
6934			  
6934			; row 5  
6934			  
6934 78			ld a,b  
6935			  
6935 21 d0 fb		LD   hl, keyscan_table_row5+10  
6938			  
6938			;call addatohl  
6938 cd 1b 0d		call subafromhl  
693b			  
693b 11 8d fb		ld de, keyscan_scancol+4  
693e			  
693e 1a			ld a,(de)  
693f 77			ld (hl),a  
6940			  
6940			; handshake next column  
6940			  
6940			  
6940 3e 40		ld a, 64  
6942 d3 c1		out (portbdata),a  
6944			  
6944 3e 00		ld a, 0  
6946 d3 c1		out (portbdata),a  
6948			  
6948			; toggle clk and move to next column  
6948			;ld a, 64  
6948			;cp c  
6948			;  
6948			;jr z, .coltoglow  
6948			;ld c, a  
6948			;jr .coltog  
6948			;.coltoglow:  
6948			;ld c, 0  
6948			;.coltog:  
6948			;ld a, c  
6948			;out (portbdata),a  
6948			  
6948 10 b2		djnz .colscan  
694a			  
694a 3e 0a		ld a,10  
694c 21 f2 fb		LD   hl, keyscan_table_row1  
694f cd 09 0d		call addatohl  
6952 3e 00		ld a, 0  
6954 77			ld (hl), a  
6955			  
6955			  
6955 3e 0a		ld a,10  
6957 21 e7 fb		LD   hl, keyscan_table_row2  
695a cd 09 0d		call addatohl  
695d 3e 00		ld a, 0  
695f 77			ld (hl), a  
6960			  
6960 3e 0a		ld a,10  
6962 21 dc fb		LD   hl, keyscan_table_row3  
6965 cd 09 0d		call addatohl  
6968 3e 00		ld a, 0  
696a 77			ld (hl), a  
696b			  
696b 3e 0a		ld a,10  
696d 21 d1 fb		LD   hl, keyscan_table_row4  
6970 cd 09 0d		call addatohl  
6973 3e 00		ld a, 0  
6975 77			ld (hl), a  
6976			  
6976 3e 0a		ld a,10  
6978 21 c6 fb		LD   hl, keyscan_table_row5  
697b cd 09 0d		call addatohl  
697e 3e 00		ld a, 0  
6980 77			ld (hl), a  
6981			  
6981			if DEBUG_KEY_MATRIX  
6981			  
6981			; Display text on first line  
6981			            LD   A, kLCD_Line1  
6981			            CALL fLCD_Pos       ;Position cursor to location in A  
6981			            LD   DE, keyscan_table_row1  
6981			            ;LD   DE, MsgHello  
6981			            CALL fLCD_Str       ;Display string pointed to by DE  
6981			  
6981			; Display text on second line  
6981			            LD   A, kLCD_Line2  
6981			            CALL fLCD_Pos       ;Position cursor to location in A  
6981			            LD   DE, keyscan_table_row2  
6981			            CALL fLCD_Str       ;Display string pointed to by DE  
6981			            LD   A, kLCD_Line3  
6981			            CALL fLCD_Pos       ;Position cursor to location in A  
6981			            LD   DE, keyscan_table_row3  
6981			            CALL fLCD_Str       ;Display string pointed to by DE  
6981			            LD   A, kLCD_Line4  
6981			            CALL fLCD_Pos       ;Position cursor to location in A  
6981			            LD   DE, keyscan_table_row4  
6981			            CALL fLCD_Str       ;Display string pointed to by DE  
6981			            LD   A, kLCD_Line4+10  
6981			            CALL fLCD_Pos       ;Position cursor to location in A  
6981			            LD   DE, keyscan_table_row5  
6981			            CALL fLCD_Str       ;Display string pointed to by DE  
6981			  
6981			;call delay250ms  
6981				jp matrix  
6981			endif  
6981 c9			ret  
6982			  
6982			; using decade counter....  
6982			  
6982			  
6982			; TODO reset decade counter to start of scan  
6982			  
6982			; reset 15  
6982			; clock 14  
6982			; ce 13  
6982			  
6982			; 1 - q5  
6982			; 2 - q1  
6982			; 3 - q0  
6982			; 4 - q2  
6982			; 5 - q6  
6982			; 6 - q7  
6982			; 7 - q3  
6982			; 8 - vss  
6982			; 9 - q8  
6982			; 10 - q4  
6982			; 11 - q9  
6982			; 12 - cout  
6982			; 16 - vdd  
6982			  
6982			; clock      ce       reset     output  
6982			; 0          x        0         n  
6982			; x          1        0         n  
6982			; x          x        1         q0  
6982			; rising     0        0         n+1  
6982			; falling    x        0         n  
6982			; x          rising   0         n  
6982			; 1          falling  0         x+1  
6982			;  
6982			; x = dont care, if n < 5 carry = 1 otherwise 0  
6982			  
6982			;   
6982			; reset   
6982			; 13=0, 14=0, 15=1 .. 15=0  
6982			;  
6982			; handshake line  
6982			; 14=1.... read line 14=0  
6982			  
6982			  
6982			  
6982			  
6982			  
6982			; TODO hand shake clock for next column scan  
6982			; TODO detect each row  
6982			  
6982			  
6982			  
6982			  
6982			; reset 128  
6982			; clock 64  
6982			; ce 32  
6982			  
6982			  
6982			.cyclestart:  
6982			  
6982			; reset counter  
6982 3e 80		ld a, 128  
6984 d3 c1		out (portbdata),a  
6986			  
6986			; loop leds  
6986 06 0a		ld b,10  
6988			  
6988			.cycle1:  
6988 c5			push bc  
6989 3e 00		ld a, 0  
698b d3 c1		out (portbdata),a  
698d cd 49 0a		call delay250ms  
6990			  
6990 3e 40		ld a, 64  
6992 d3 c1		out (portbdata),a  
6994 cd 49 0a		call delay250ms  
6997			  
6997 3e 00		ld a, 0  
6999 d3 c1		out (portbdata),a  
699b cd 49 0a		call delay250ms  
699e			  
699e c1			pop bc  
699f 10 e7		djnz .cycle1  
69a1			  
69a1			  
69a1 18 df		jr .cyclestart  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			; map matrix key held to char on face of key  
69a3			  
69a3			;.mtocold:  
69a3			;  
69a3			;  
69a3			;; reset counter  
69a3			;ld a, 128  
69a3			;out (portbdata),a  
69a3			;  
69a3			;  
69a3			;; scan keyboard row 1  
69a3			;ld a, 0  
69a3			;out (portbdata),a  
69a3			;;ld a, 64  
69a3			;;out (portbdata),a  
69a3			;  
69a3			;  
69a3			;	ld a, 128  
69a3			;	ld hl, keyscan_table  
69a3			;	call .rowscan  
69a3			;  
69a3			;;ld a, 0  
69a3			;;out (portbdata),a  
69a3			;ld a, 64  
69a3			;out (portbdata),a  
69a3			;  
69a3			;	ld a, 64  
69a3			;	ld hl, keyscan_table+key_cols  
69a3			;	call .rowscan  
69a3			;  
69a3			;ld a, 0  
69a3			;out (portbdata),a  
69a3			;;ld a, 64  
69a3			;;out (portbdata),a  
69a3			;	ld a, 32  
69a3			;	ld hl, keyscan_table+(key_cols*2)  
69a3			;	call .rowscan  
69a3			;  
69a3			;  
69a3			;;ld a, 0  
69a3			;;out (portbdata),a  
69a3			;ld a, 64  
69a3			;out (portbdata),a  
69a3			;  
69a3			;	ld a, 16  
69a3			;	ld hl, keyscan_table+(key_cols*3)  
69a3			;	call .rowscan  
69a3			;  
69a3			;  
69a3			;	; flag if key D is held down and remove from reporting  
69a3			;	ld bc, .key_map_fd    
69a3			;	ld hl, keyscan_table  
69a3			;	ld de, key_fd  
69a3			;	call .key_shift_hold  
69a3			;	cp 255  
69a3			;	jr z, .cinmap  
69a3			;	; flag if key C is held down and remove from reporting  
69a3			;	ld bc, .key_map_fc    
69a3			;	ld hl, keyscan_table+key_cols  
69a3			;	ld de, key_fc  
69a3			;	call .key_shift_hold  
69a3			;	cp 255  
69a3			;	jr z, .cinmap  
69a3			;	; flag if key B is held down and remove from reporting  
69a3			;	ld bc, .key_map_fb    
69a3			;	ld hl, keyscan_table+(key_cols*2)  
69a3			;	ld de, key_fb  
69a3			;	call .key_shift_hold  
69a3			;	cp 255  
69a3			;	jr z, .cinmap  
69a3			;	; flag if key A is held down and remove from reporting  
69a3			;	ld bc, .key_map_fa    
69a3			;	ld hl, keyscan_table+(key_cols*3)  
69a3			;	ld de, key_fa  
69a3			;	call .key_shift_hold  
69a3			;	cp 255  
69a3			;	jr z, .cinmap  
69a3			;  
69a3			;	ld de, .matrix_to_char  
69a3			;  
69a3			;  
69a3			;.cinmap:   
69a3			;	if DEBUG_KEY  
69a3			;            LD   A, kLCD_Line4  
69a3			;            CALL fLCD_Pos       ;Position cursor to location in A  
69a3			;		push de  
69a3			;            LD   DE, keyscan_table  
69a3			;            CALL fLCD_Str       ;Display string pointed to by DE  
69a3			;		pop de  
69a3			;	endif  
69a3			  
69a3				; scan key matrix table for any held key  
69a3			  
69a3				; de holds either the default matrix or one selected above  
69a3			  
69a3			;	ld hl, keyscan_table  
69a3			;	ld b,key_cols*key_rows  
69a3			;  
69a3			;.cin1:	ld a,(hl)  
69a3			;	cp '#'  
69a3			;	jr z, .cinhit  
69a3			;	inc hl  
69a3			;	inc de  
69a3			;	dec b  
69a3			;	jr nz, .cin1  
69a3			;	; no key found held  
69a3			;	ld a,0  
69a3			;	ret  
69a3			;.cinhit: push de  
69a3			;	pop hl  
69a3			;	ld a,(hl)  
69a3			;	ret  
69a3			  
69a3			; flag a control key is held   
69a3			; hl is key pin, de is flag indicator  
69a3			  
69a3			;.key_shift_hold:  
69a3			;	push bc  
69a3			;	ld a, 1  
69a3			;	ld (cursor_shape),a  
69a3			;	ld b, 0  
69a3			;	ld a, (hl)  
69a3			;	cp '.'  
69a3			;	jr z, .key_shift1  
69a3			;	ld b, 255  
69a3			;	ld a, '+'    ; hide key from later scans  
69a3			;	ld (hl),a  
69a3			;	ld a, 2  
69a3			;	ld (cursor_shape),a  
69a3			;.key_shift1:  
69a3			;	; write flag indicator  
69a3			;	ld a,b  
69a3			;	ld (de),a  
69a3			;  
69a3			;	pop de    ; de now holds the key map ptr  
69a3			;	ret  
69a3			  
69a3				  
69a3				  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			;	push hl  
69a3			;	push de  
69a3			;	push bc  
69a3			;	call keyscan  
69a3			;	; map key matrix to ascii value of key face  
69a3			;  
69a3			;	ld hl, key_face_map  
69a3			;	ld de, keyscan_table  
69a3			;  
69a3			;	; get how many keys to look at  
69a3			;	ld b, keyscan_table_len  
69a3			;	  
69a3			;  
69a3			;	; at this stage fall out on first key hit  
69a3			;	; TODO handle multiple key press  
69a3			;  
69a3			;map1:	ld a,(hl)  
69a3			;	cp '#'  
69a3			;	jr z, keyhit  
69a3			;	inc hl  
69a3			;	inc de  
69a3			;	dec b  
69a3			;	jr nz, map1  
69a3			;nohit:	ld a, 0  
69a3			;	jr keydone  
69a3			;keyhit: push de  
69a3			;	pop hl  
69a3			;	ld a,(hl)  
69a3			;keydone:  
69a3			;	push bc  
69a3			;	push de  
69a3			; 	push hl  
69a3			;	ret   
69a3			;  
69a3			  
69a3			  
69a3			  
69a3			  
69a3			; scan physical key matrix  
69a3			  
69a3			  
69a3			;keyscan:  
69a3			;  
69a3			;; for each key_row use keyscanr bit mask for out  
69a3			;; then read in for keyscanc bitmask  
69a3			;; save result of row scan to keyscantable  
69a3			;  
69a3			;; scan keyboard row 1  
69a3			;  
69a3			;	ld b, key_rows  
69a3			;	ld hl, key_scanr  
69a3			;	ld de, keyscan_table  
69a3			;  
69a3			;rowloop:  
69a3			;  
69a3			;	ld a,(hl)		; out bit mask to energise keyboard row  
69a3			;	call rowscan  
69a3			;	inc hl  
69a3			;	dec b  
69a3			;	jr nz, rowloop  
69a3			;  
69a3			;	ret  
69a3			;  
69a3			;  
69a3			;; pass a out bitmask, b row number  
69a3			;arowscan:   
69a3			;	push bc  
69a3			;  
69a3			;	ld d, b  
69a3			;  
69a3			;	; calculate buffer location for this row  
69a3			;  
69a3			;	ld hl, keyscan_table	  
69a3			;kbufr:  ld e, key_cols  
69a3			;kbufc:	inc hl  
69a3			;	dec e  
69a3			;	jr nz, kbufc  
69a3			;	dec d  
69a3			;	jr nz, kbufr  
69a3			;  
69a3			;	; energise row and read columns  
69a3			;  
69a3			;	out (portbdata),a  
69a3			;	in a,(portbdata)  
69a3			;	ld c,a  
69a3			;  
69a3			;  
69a3			;	; save buffer loc  
69a3			;  
69a3			;	ld (keybufptr), hl  
69a3			;  
69a3			;	ld hl, key_scanc  
69a3			;	ld d, key_cols  
69a3			;  
69a3			;	; for each column check each bit mask  
69a3			;  
69a3			;colloop:  
69a3			;	  
69a3			;  
69a3			;	; reset flags for the row   
69a3			;  
69a3			;	ld b,'.'  
69a3			;	and (hl)  
69a3			;	jr z, maskskip  
69a3			;	ld b,'#'  
69a3			;maskskip:  
69a3			;	; save  key state  
69a3			;	push hl  
69a3			;	ld hl, (keybufptr)  
69a3			;	ld (hl), b  
69a3			;	inc hl  
69a3			;	ld (keybufptr), hl  
69a3			;  
69a3			;	; move to next bit mask  
69a3			;	pop hl  
69a3			;	inc hl  
69a3			;  
69a3			;	dec d  
69a3			;	jr nz, colloop  
69a3			;  
69a3			;	ret  
69a3			;  
69a3			;  
69a3			;;  
69a3			; lcd functions  
69a3			;  
69a3			;  
69a3			  
69a3			;if DEBUG_KEY_MATRIX  
69a3			  
69a3			; test function to display hardware view of matrix state  
69a3			  
69a3			matrixold:  
69a3			  
69a3			  
69a3			  
69a3			; reset counter  
69a3 3e 80		ld a, 128  
69a5 d3 c1		out (portbdata),a  
69a7			; scan keyboard row 1  
69a7 3e 00		ld a, 0  
69a9 d3 c1		out (portbdata),a  
69ab			;ld a, 64  
69ab			;out (portbdata),a  
69ab 3e 80			ld a, 128  
69ad 21 f2 fb			ld hl, keyscan_table_row1  
69b0 cd 09 6a			call .rowscan  
69b3			  
69b3			;ld a, 0  
69b3			;out (portbdata),a  
69b3 3e 40		ld a, 64  
69b5 d3 c1		out (portbdata),a  
69b7 3e 40			ld a, 64  
69b9 21 e7 fb			ld hl, keyscan_table_row2  
69bc cd 09 6a			call .rowscan  
69bf			  
69bf 3e 00		ld a, 0  
69c1 d3 c1		out (portbdata),a  
69c3			;ld a, 64  
69c3			;out (portbdata),a  
69c3 3e 20			ld a, 32  
69c5 21 dc fb			ld hl, keyscan_table_row3  
69c8 cd 09 6a			call .rowscan  
69cb			  
69cb			;ld a, 0  
69cb			;out (portbdata),a  
69cb 3e 40		ld a, 64  
69cd d3 c1		out (portbdata),a  
69cf 3e 10			ld a, 16  
69d1 21 d1 fb			ld hl, keyscan_table_row4  
69d4 cd 09 6a			call .rowscan  
69d7			  
69d7			; Display text on first line  
69d7 3e 00		            LD   A, kLCD_Line1  
69d9 cd 11 66		            CALL fLCD_Pos       ;Position cursor to location in A  
69dc 11 f2 fb		            LD   DE, keyscan_table_row1  
69df			            ;LD   DE, MsgHello  
69df cd 33 66		            CALL fLCD_Str       ;Display string pointed to by DE  
69e2			  
69e2			; Display text on second line  
69e2 3e 28		            LD   A, kLCD_Line2  
69e4 cd 11 66		            CALL fLCD_Pos       ;Position cursor to location in A  
69e7 11 e7 fb		            LD   DE, keyscan_table_row2  
69ea cd 33 66		            CALL fLCD_Str       ;Display string pointed to by DE  
69ed 3e 50		            LD   A, kLCD_Line3  
69ef cd 11 66		            CALL fLCD_Pos       ;Position cursor to location in A  
69f2 11 dc fb		            LD   DE, keyscan_table_row3  
69f5 cd 33 66		            CALL fLCD_Str       ;Display string pointed to by DE  
69f8 3e 78		            LD   A, kLCD_Line4  
69fa cd 11 66		            CALL fLCD_Pos       ;Position cursor to location in A  
69fd 11 d1 fb		            LD   DE, keyscan_table_row4  
6a00 cd 33 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a03			  
6a03 cd 49 0a			call delay250ms  
6a06 c3 f4 68			jp matrix  
6a09			  
6a09			; pass de as row display flags  
6a09			.rowscan:   
6a09			;	out (portbdata),a  
6a09 db c1			in a,(portbdata)  
6a0b 4f				ld c,a  
6a0c				; reset flags for the row   
6a0c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a0e e6 01			and 1  
6a10 28 02			jr z, .p1on  
6a12 06 23			ld b,'#'  
6a14			.p1on:  
6a14 70				ld (hl), b  
6a15 23				inc hl  
6a16			  
6a16 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a18 79				ld a,c  
6a19 e6 02			and 2  
6a1b			;	bit 0,a  
6a1b 28 02			jr z, .p2on  
6a1d 06 23			ld b,'#'  
6a1f			.p2on:  
6a1f 70				ld (hl), b  
6a20 23				inc hl  
6a21			;  
6a21 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a23 79				ld a,c  
6a24 e6 04			and 4  
6a26			;;	bit 0,a  
6a26 28 02			jr z, .p3on  
6a28 06 23			ld b,'#'  
6a2a			.p3on:  
6a2a 70				ld (hl), b  
6a2b 23				inc hl  
6a2c			;;  
6a2c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a2e			;;	bit 0,a  
6a2e 79				ld a,c  
6a2f e6 08			and 8  
6a31 28 02			jr z, .p4on  
6a33 06 23			ld b,'#'  
6a35			.p4on:  
6a35 70				ld (hl), b  
6a36 23				inc hl  
6a37			  
6a37 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a39			;;	bit 0,a  
6a39 79				ld a,c  
6a3a e6 10			and 16  
6a3c 28 02			jr z, .p5on  
6a3e 06 23			ld b,'#'  
6a40			.p5on:  
6a40 70				ld (hl), b  
6a41 23				inc hl  
6a42			; zero term  
6a42 06 00			ld b,0  
6a44 70				ld (hl), b  
6a45			  
6a45 c9			.rscandone: ret  
6a46			  
6a46			;addatohl:  
6a46			;  
6a46			 ;add   a, l    ; A = A+L  
6a46			  ;  ld    l, a    ; L = A+L  
6a46			   ; adc   a, h    ; A = A+L+H+carry  
6a46			   ; sub   l       ; A = H+carry  
6a46			   ; ld    h, a    ; H = H+carry  
6a46			  
6a46			;ret  
6a46			; eof  
# End of file firmware_key_5x10.asm
6a46			;include "firmware_key_4x10.asm" 
6a46			 
6a46			heap_size:    equ heap_end - heap_start 
6a46			;eof 
# End of file os_mega.asm
6a46
