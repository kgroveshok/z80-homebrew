# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 d5 15			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $3c holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOEFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 85 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 85 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 85 09				call clear_display  
0123			  
0123			  
0123 cd c7 58				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd b5 59			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 55 10				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd a8 09			call update_display  
0132 cd fa 08			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 8a 09			call fill_display  
013a cd a8 09			call update_display  
013d cd fa 08			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 8a 09			call fill_display  
0145 cd a8 09			call update_display  
0148 cd fa 08			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 8a 09			call fill_display  
0150 cd a8 09			call update_display  
0153 cd fa 08			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd 98 09			call str_at_display  
015e cd a8 09			call update_display  
0161			  
0161			  
0161 cd fa 08			call delay1s  
0164 cd fa 08			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd 98 09			call str_at_display  
016f cd a8 09			call update_display  
0172 cd fa 08			call delay1s  
0175 cd fa 08			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd ff 13			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd ff 13			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd d2 04			call storage_findnextid 
0205			 
0205 cd db 0b			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd ff 13			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd ff 13			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd ff 13			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd ff 13			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd ff 13			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 cd bd 08			call storage_clear_page 
02d3			 
02d3 21 65 eb			ld hl, store_page 
02d6 3e 00			ld a, 0 
02d8				 
02d8 77				ld (hl),a   ; reset file counter 
02d9			 
02d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02dc 22 66 eb		 	ld (store_page+1), hl	 
02df			 
02df				; set default label 
02df			 
02df 21 7b 03			ld hl, .defaultbanklabl 
02e2 11 68 eb		 	ld de, store_page+3 
02e5 01 0f 00			ld bc, 15 
02e8 ed b0			ldir 
02ea			 
02ea				; Append the current bank id 
02ea 21 71 eb			ld hl, store_page+3+9 
02ed 3a 4a eb			ld a, (spi_device_id) 
02f0 77				ld (hl), a 
02f1			 
02f1				; save default page 0 
02f1			 
02f1 21 00 00			ld hl, 0 
02f4 11 65 eb			ld de, store_page 
02f7				if DEBUG_STORESE 
02f7					DMARK "SB3" 
02f7 f5				push af  
02f8 3a 0c 03			ld a, (.dmark)  
02fb 32 7a ee			ld (debug_mark),a  
02fe 3a 0d 03			ld a, (.dmark+1)  
0301 32 7b ee			ld (debug_mark+1),a  
0304 3a 0e 03			ld a, (.dmark+2)  
0307 32 7c ee			ld (debug_mark+2),a  
030a 18 03			jr .pastdmark  
030c ..			.dmark: db "SB3"  
030f f1			.pastdmark: pop af  
0310			endm  
# End of macro DMARK
0310			;		push af 
0310			;		ld a, 'F' 
0310			;		ld (debug_mark),a 
0310			;		pop af 
0310					CALLMONITOR 
0310 cd ff 13			call break_point_state  
0313				endm  
# End of macro CALLMONITOR
0313				endif 
0313 cd 16 02			call storage_write_block 
0316				if DEBUG_STORESE 
0316					DMARK "SB4" 
0316 f5				push af  
0317 3a 2b 03			ld a, (.dmark)  
031a 32 7a ee			ld (debug_mark),a  
031d 3a 2c 03			ld a, (.dmark+1)  
0320 32 7b ee			ld (debug_mark+1),a  
0323 3a 2d 03			ld a, (.dmark+2)  
0326 32 7c ee			ld (debug_mark+2),a  
0329 18 03			jr .pastdmark  
032b ..			.dmark: db "SB4"  
032e f1			.pastdmark: pop af  
032f			endm  
# End of macro DMARK
032f			;		push af 
032f			;		ld a, '>' 
032f			;		ld (debug_mark),a 
032f			;		pop af 
032f					CALLMONITOR 
032f cd ff 13			call break_point_state  
0332				endm  
# End of macro CALLMONITOR
0332				endif 
0332			 
0332 00				nop 
0333 00				nop 
0334 00				nop 
0335			 
0335				; now set 0 in every page to mark as a free block 
0335			 
0335 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0337 21 40 00			ld hl, STORE_BLOCK_PHY 
033a			 
033a 3e 00		.setmark1:   	ld a,0 
033c e5					push hl 
033d c5					push bc 
033e cd af 01				call se_writebyte 
0341 3e 0a			ld a, 10 
0343 cd df 08			call aDelayInMS 
0346 23				inc hl 
0347 cd af 01				call se_writebyte 
034a 3e 0a			ld a, 10 
034c cd df 08			call aDelayInMS 
034f 2b				dec hl 
0350 c1					pop bc 
0351 e1					pop hl 
0352 3e 40				ld a, STORE_BLOCK_PHY 
0354 cd b2 0b				call addatohl 
0357 10 e1				djnz .setmark1 
0359			 
0359 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
035b 3e 00		.setmark2:   	ld a,0 
035d e5					push hl 
035e c5					push bc 
035f cd af 01				call se_writebyte 
0362 3e 0a			ld a, 10 
0364 cd df 08			call aDelayInMS 
0367 23				inc hl 
0368 cd af 01				call se_writebyte 
036b 3e 0a			ld a, 10 
036d cd df 08			call aDelayInMS 
0370 2b				dec hl 
0371 c1					pop bc 
0372 e1					pop hl 
0373 3e 40				ld a, STORE_BLOCK_PHY 
0375 cd b2 0b				call addatohl 
0378 10 e1				djnz .setmark2 
037a			 
037a					 
037a			 
037a			 
037a c9				ret 
037b			 
037b			 
037b			 
037b			 
037b .. 00		.defaultbanklabl:   db "BankLabel_",0 
0386			 
0386			 
0386			 
0386			; Label Bank 
0386			; ---------- 
0386			; 
0386			; With current bank 
0386			; Read block 0 
0386			; Set label 
0386			; Write block 0 
0386			 
0386			; label str pointer in hl 
0386			 
0386			storage_label:     
0386			 
0386				if DEBUG_STORESE 
0386					DMARK "LBL" 
0386 f5				push af  
0387 3a 9b 03			ld a, (.dmark)  
038a 32 7a ee			ld (debug_mark),a  
038d 3a 9c 03			ld a, (.dmark+1)  
0390 32 7b ee			ld (debug_mark+1),a  
0393 3a 9d 03			ld a, (.dmark+2)  
0396 32 7c ee			ld (debug_mark+2),a  
0399 18 03			jr .pastdmark  
039b ..			.dmark: db "LBL"  
039e f1			.pastdmark: pop af  
039f			endm  
# End of macro DMARK
039f					CALLMONITOR 
039f cd ff 13			call break_point_state  
03a2				endm  
# End of macro CALLMONITOR
03a2				endif 
03a2			 
03a2 e5				push hl 
03a3			 
03a3 cd 62 02			call storage_get_block_0 
03a6			 
03a6				; set default label 
03a6			 
03a6 e1				pop hl 
03a7			 
03a7 11 68 eb		 	ld de, store_page+3 
03aa 01 0f 00			ld bc, 15 
03ad				if DEBUG_STORESE 
03ad					DMARK "LB3" 
03ad f5				push af  
03ae 3a c2 03			ld a, (.dmark)  
03b1 32 7a ee			ld (debug_mark),a  
03b4 3a c3 03			ld a, (.dmark+1)  
03b7 32 7b ee			ld (debug_mark+1),a  
03ba 3a c4 03			ld a, (.dmark+2)  
03bd 32 7c ee			ld (debug_mark+2),a  
03c0 18 03			jr .pastdmark  
03c2 ..			.dmark: db "LB3"  
03c5 f1			.pastdmark: pop af  
03c6			endm  
# End of macro DMARK
03c6					CALLMONITOR 
03c6 cd ff 13			call break_point_state  
03c9				endm  
# End of macro CALLMONITOR
03c9				endif 
03c9 ed b0			ldir 
03cb				; save default page 0 
03cb			 
03cb 21 00 00			ld hl, 0 
03ce 11 65 eb			ld de, store_page 
03d1				if DEBUG_STORESE 
03d1					DMARK "LBW" 
03d1 f5				push af  
03d2 3a e6 03			ld a, (.dmark)  
03d5 32 7a ee			ld (debug_mark),a  
03d8 3a e7 03			ld a, (.dmark+1)  
03db 32 7b ee			ld (debug_mark+1),a  
03de 3a e8 03			ld a, (.dmark+2)  
03e1 32 7c ee			ld (debug_mark+2),a  
03e4 18 03			jr .pastdmark  
03e6 ..			.dmark: db "LBW"  
03e9 f1			.pastdmark: pop af  
03ea			endm  
# End of macro DMARK
03ea					CALLMONITOR 
03ea cd ff 13			call break_point_state  
03ed				endm  
# End of macro CALLMONITOR
03ed				endif 
03ed cd 16 02			call storage_write_block 
03f0			 
03f0 c9				ret 
03f1			 
03f1			 
03f1			 
03f1			; Read Block 0 - Config 
03f1			; --------------------- 
03f1			; 
03f1			; With current bank 
03f1			; Call presence test 
03f1			;    If not present format/init bank  
03f1			; Read block 0  
03f1			;  
03f1			 
03f1			 
03f1			; Dir 
03f1			; --- 
03f1			; 
03f1			; With current bank 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block read byte 2 
03f1			;      if first block of file 
03f1			;         Display file name 
03f1			;         Display type flags for file 
03f1			;        
03f1			 
03f1			; moving to words as this requires stack control 
03f1			 
03f1			 
03f1			; Delete File 
03f1			; ----------- 
03f1			; 
03f1			; With current bank 
03f1			; 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block file id 
03f1			;      If first block of file and dont have file id 
03f1			;         if file to delete 
03f1			;         Save file id 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			;      If file id is one saved 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			 
03f1			storage_erase: 
03f1			 
03f1				; hl contains the file id 
03f1			 
03f1 5d				ld e, l 
03f2 16 00			ld d, 0 
03f4 21 40 00			ld hl, STORE_BLOCK_PHY 
03f7					if DEBUG_FORTH_WORDS 
03f7						DMARK "ERA" 
03f7 f5				push af  
03f8 3a 0c 04			ld a, (.dmark)  
03fb 32 7a ee			ld (debug_mark),a  
03fe 3a 0d 04			ld a, (.dmark+1)  
0401 32 7b ee			ld (debug_mark+1),a  
0404 3a 0e 04			ld a, (.dmark+2)  
0407 32 7c ee			ld (debug_mark+2),a  
040a 18 03			jr .pastdmark  
040c ..			.dmark: db "ERA"  
040f f1			.pastdmark: pop af  
0410			endm  
# End of macro DMARK
0410						CALLMONITOR 
0410 cd ff 13			call break_point_state  
0413				endm  
# End of macro CALLMONITOR
0413					endif 
0413 cd d2 04			call storage_findnextid 
0416			 
0416 e5				push hl 
0417			 
0417				; TODO check file not found 
0417			 
0417 11 65 eb			ld de, store_page 
041a cd b1 01			call storage_read_block 
041d			 
041d					if DEBUG_FORTH_WORDS 
041d						DMARK "ER1" 
041d f5				push af  
041e 3a 32 04			ld a, (.dmark)  
0421 32 7a ee			ld (debug_mark),a  
0424 3a 33 04			ld a, (.dmark+1)  
0427 32 7b ee			ld (debug_mark+1),a  
042a 3a 34 04			ld a, (.dmark+2)  
042d 32 7c ee			ld (debug_mark+2),a  
0430 18 03			jr .pastdmark  
0432 ..			.dmark: db "ER1"  
0435 f1			.pastdmark: pop af  
0436			endm  
# End of macro DMARK
0436						CALLMONITOR 
0436 cd ff 13			call break_point_state  
0439				endm  
# End of macro CALLMONITOR
0439					endif 
0439 3a 65 eb			ld a, (store_page)	; get file id 
043c 32 5e eb			ld (store_tmpid), a 
043f			 
043f 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0442 32 5d eb			ld (store_tmpext), a 
0445			 
0445				; wipe file header 
0445			 
0445 e1				pop hl 
0446 3e 00			ld a, 0 
0448 32 65 eb			ld (store_page), a 
044b 32 66 eb			ld (store_page+1),a 
044e 11 65 eb			ld de, store_page 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "ER2" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 7a ee			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 7b ee			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 7c ee			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "ER2"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd ff 13			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 16 02			call storage_write_block 
0470			 
0470			 
0470				; wipe file extents 
0470			 
0470 3a 5d eb			ld a, (store_tmpext) 
0473 47				ld b, a 
0474			 
0474			.eraext:	  
0474 c5				push bc 
0475			 
0475 21 40 00			ld hl, STORE_BLOCK_PHY 
0478 3a 5e eb			ld a,(store_tmpid) 
047b 5f				ld e, a 
047c 50				ld d, b	 
047d					if DEBUG_FORTH_WORDS 
047d						DMARK "ER3" 
047d f5				push af  
047e 3a 92 04			ld a, (.dmark)  
0481 32 7a ee			ld (debug_mark),a  
0484 3a 93 04			ld a, (.dmark+1)  
0487 32 7b ee			ld (debug_mark+1),a  
048a 3a 94 04			ld a, (.dmark+2)  
048d 32 7c ee			ld (debug_mark+2),a  
0490 18 03			jr .pastdmark  
0492 ..			.dmark: db "ER3"  
0495 f1			.pastdmark: pop af  
0496			endm  
# End of macro DMARK
0496						CALLMONITOR 
0496 cd ff 13			call break_point_state  
0499				endm  
# End of macro CALLMONITOR
0499					endif 
0499 cd d2 04			call storage_findnextid 
049c			 
049c e5				push hl 
049d 11 65 eb			ld de, store_page 
04a0 cd b1 01			call storage_read_block 
04a3			 
04a3				; free block	 
04a3			 
04a3 3e 00			ld a, 0 
04a5 32 65 eb			ld (store_page), a 
04a8 32 66 eb			ld (store_page+1),a 
04ab 11 65 eb			ld de, store_page 
04ae e1				pop hl 
04af					if DEBUG_FORTH_WORDS 
04af						DMARK "ER4" 
04af f5				push af  
04b0 3a c4 04			ld a, (.dmark)  
04b3 32 7a ee			ld (debug_mark),a  
04b6 3a c5 04			ld a, (.dmark+1)  
04b9 32 7b ee			ld (debug_mark+1),a  
04bc 3a c6 04			ld a, (.dmark+2)  
04bf 32 7c ee			ld (debug_mark+2),a  
04c2 18 03			jr .pastdmark  
04c4 ..			.dmark: db "ER4"  
04c7 f1			.pastdmark: pop af  
04c8			endm  
# End of macro DMARK
04c8						CALLMONITOR 
04c8 cd ff 13			call break_point_state  
04cb				endm  
# End of macro CALLMONITOR
04cb					endif 
04cb cd 16 02			call storage_write_block 
04ce			 
04ce c1				pop bc 
04cf 10 a3			djnz .eraext 
04d1			 
04d1 c9				ret 
04d2			 
04d2			 
04d2			; Find Free Block 
04d2			; --------------- 
04d2			; 
04d2			; With current bank 
04d2			;  
04d2			; From given starting logical block 
04d2			;    Read block  
04d2			;    If no file id 
04d2			;         Return block id 
04d2			 
04d2			 
04d2			; hl starting page number 
04d2			; hl contains free page number or zero if no pages free 
04d2			; e contains the file id to locate 
04d2			; d contains the block number 
04d2			 
04d2			; TODO change to find file id and use zero for free block 
04d2			 
04d2			storage_findnextid: 
04d2			 
04d2				; now locate first 0 page to mark as a free block 
04d2			 
04d2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04d4			;	ld hl, STORE_BLOCK_PHY 
04d4			 
04d4					if DEBUG_FORTH_WORDS 
04d4					DMARK "FNI" 
04d4 f5				push af  
04d5 3a e9 04			ld a, (.dmark)  
04d8 32 7a ee			ld (debug_mark),a  
04db 3a ea 04			ld a, (.dmark+1)  
04de 32 7b ee			ld (debug_mark+1),a  
04e1 3a eb 04			ld a, (.dmark+2)  
04e4 32 7c ee			ld (debug_mark+2),a  
04e7 18 03			jr .pastdmark  
04e9 ..			.dmark: db "FNI"  
04ec f1			.pastdmark: pop af  
04ed			endm  
# End of macro DMARK
04ed						CALLMONITOR 
04ed cd ff 13			call break_point_state  
04f0				endm  
# End of macro CALLMONITOR
04f0					endif 
04f0			.ff1:   	 
04f0 e5					push hl 
04f1 c5					push bc 
04f2 d5					push de 
04f3 cd ae 01				call se_readbyte 
04f6 5f					ld e,a 
04f7 23					inc hl 
04f8 cd ae 01				call se_readbyte 
04fb 57					ld d, a 
04fc e1					pop hl 
04fd e5					push hl 
04fe cd d0 0b				call cmp16 
0501 28 49				jr z, .fffound 
0503			 
0503 d1					pop de 
0504 c1					pop bc 
0505 e1					pop hl 
0506			 
0506					; is found? 
0506					;cp e 
0506					;ret z 
0506			 
0506 3e 40				ld a, STORE_BLOCK_PHY 
0508 cd b2 0b				call addatohl 
050b 10 e3				djnz .ff1 
050d			 
050d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
050f			.ff2:   	 
050f			 
050f e5					push hl 
0510 c5					push bc 
0511 d5					push de 
0512 cd ae 01				call se_readbyte 
0515 5f					ld e,a 
0516 23					inc hl 
0517 cd ae 01				call se_readbyte 
051a 57					ld d, a 
051b			 
051b e1					pop hl 
051c e5					push hl 
051d cd d0 0b				call cmp16 
0520 28 2a				jr z, .fffound 
0522			 
0522 d1					pop de 
0523 c1					pop bc 
0524 e1					pop hl 
0525					; is found? 
0525					;cp e 
0525					;ret z 
0525			 
0525 3e 40				ld a, STORE_BLOCK_PHY 
0527 cd b2 0b				call addatohl 
052a 10 e3				djnz .ff2 
052c			 
052c			 
052c					if DEBUG_FORTH_WORDS 
052c					DMARK "FN-" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 7a ee			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 7b ee			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 7c ee			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "FN-"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					;	push af 
0545					;	ld a, 'n' 
0545					;	ld (debug_mark),a 
0545					;	pop af 
0545						CALLMONITOR 
0545 cd ff 13			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548					endif 
0548				; no free marks! 
0548 21 00 00				ld hl, 0 
054b c9				ret 
054c			.fffound: 
054c				 
054c			 
054c d1					pop de 
054d c1					pop bc 
054e e1					pop hl 
054f					if DEBUG_FORTH_WORDS 
054f					DMARK "FNF" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 7a ee			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 7b ee			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 7c ee			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "FNF"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568					;	push af 
0568					;	ld a, 'n' 
0568					;	ld (debug_mark),a 
0568					;	pop af 
0568						CALLMONITOR 
0568 cd ff 13			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b c9				ret 
056c			 
056c			 
056c			 
056c			; Free Space 
056c			; ---------- 
056c			; 
056c			; With current bank 
056c			; 
056c			; Set block count to zero 
056c			; Starting with first logical block 
056c			;      Find free block  
056c			;      If block id given, increment block count 
056c			; 
056c			;  
056c			 
056c			 
056c			; hl contains count of free blocks 
056c			 
056c			storage_freeblocks: 
056c			 
056c				; now locate first 0 page to mark as a free block 
056c			 
056c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
056e 21 40 00			ld hl, STORE_BLOCK_PHY 
0571 11 00 00			ld de, 0 
0574			 
0574			.fb1:   	 
0574 e5					push hl 
0575 c5					push bc 
0576 d5					push de 
0577 cd ae 01				call se_readbyte 
057a d1					pop de 
057b c1					pop bc 
057c e1					pop hl 
057d			 
057d					; is free? 
057d fe 00				cp 0 
057f 20 01				jr nz, .ff1cont 
0581 13					inc de 
0582			 
0582			.ff1cont: 
0582			 
0582			 
0582 3e 40				ld a, STORE_BLOCK_PHY 
0584 cd b2 0b				call addatohl 
0587 10 eb				djnz .fb1 
0589			 
0589 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
058b			.fb2:   	 
058b e5					push hl 
058c c5					push bc 
058d d5					push de 
058e cd ae 01				call se_readbyte 
0591 d1					pop de 
0592 c1					pop bc 
0593 e1					pop hl 
0594			 
0594					; is free? 
0594 fe 00				cp 0 
0596 20 01				jr nz, .ff2cont 
0598 13					inc de 
0599			 
0599			.ff2cont: 
0599			 
0599 3e 40				ld a, STORE_BLOCK_PHY 
059b cd b2 0b				call addatohl 
059e 10 eb				djnz .fb2 
05a0			 
05a0 eb				ex de, hl 
05a1 c9				ret 
05a2			 
05a2			; Get File ID 
05a2			; ----------- 
05a2			; 
05a2			; With current bank 
05a2			;  
05a2			; Load Block 0 Config 
05a2			; Get max file id number 
05a2			; For each logical block 
05a2			;    Read block file id 
05a2			;      If first block of file and dont have file id 
05a2			;         if file get id and exit 
05a2			 
05a2			 
05a2			 
05a2			 
05a2			; Create File 
05a2			; ----------- 
05a2			; 
05a2			; With current bank  
05a2			; Load Block 0 Config 
05a2			; Get max file id number 
05a2			; Increment file id number 
05a2			; Save Config 
05a2			; Find free block 
05a2			; Set buffer with file name and file id 
05a2			; Write buffer to free block  
05a2			 
05a2			 
05a2			; hl point to file name 
05a2			; hl returns file id 
05a2			 
05a2			; file format: 
05a2			; byte 0 - file id 
05a2			; byte 1 - extent number 
05a2			; byte 2-> data 
05a2			 
05a2			; format for extent number 0: 
05a2			; 
05a2			; byte 0 - file id 
05a2			; byte 1 - extent 0 
05a2			; byte 2 - extent count 
05a2			; byte 3 -> file name and meta data 
05a2			 
05a2			 
05a2			storage_create: 
05a2				if DEBUG_STORESE 
05a2					DMARK "SCR" 
05a2 f5				push af  
05a3 3a b7 05			ld a, (.dmark)  
05a6 32 7a ee			ld (debug_mark),a  
05a9 3a b8 05			ld a, (.dmark+1)  
05ac 32 7b ee			ld (debug_mark+1),a  
05af 3a b9 05			ld a, (.dmark+2)  
05b2 32 7c ee			ld (debug_mark+2),a  
05b5 18 03			jr .pastdmark  
05b7 ..			.dmark: db "SCR"  
05ba f1			.pastdmark: pop af  
05bb			endm  
# End of macro DMARK
05bb					CALLMONITOR 
05bb cd ff 13			call break_point_state  
05be				endm  
# End of macro CALLMONITOR
05be				endif 
05be			 
05be e5				push hl		; save file name pointer 
05bf			 
05bf cd 62 02			call storage_get_block_0 
05c2			 
05c2 3a 65 eb			ld a,(store_page)	; get current file id 
05c5 3c				inc a 
05c6 32 65 eb			ld (store_page),a 
05c9				 
05c9 32 5e eb			ld (store_tmpid),a			; save id 
05cc			 
05cc 21 00 00			ld hl, 0 
05cf 11 65 eb			ld de, store_page 
05d2				if DEBUG_STORESE 
05d2					DMARK "SCw" 
05d2 f5				push af  
05d3 3a e7 05			ld a, (.dmark)  
05d6 32 7a ee			ld (debug_mark),a  
05d9 3a e8 05			ld a, (.dmark+1)  
05dc 32 7b ee			ld (debug_mark+1),a  
05df 3a e9 05			ld a, (.dmark+2)  
05e2 32 7c ee			ld (debug_mark+2),a  
05e5 18 03			jr .pastdmark  
05e7 ..			.dmark: db "SCw"  
05ea f1			.pastdmark: pop af  
05eb			endm  
# End of macro DMARK
05eb					CALLMONITOR 
05eb cd ff 13			call break_point_state  
05ee				endm  
# End of macro CALLMONITOR
05ee				endif 
05ee cd 16 02			call storage_write_block	 ; save update 
05f1			 
05f1				if DEBUG_STORESE 
05f1 11 65 eb				ld de, store_page 
05f4					DMARK "SCC" 
05f4 f5				push af  
05f5 3a 09 06			ld a, (.dmark)  
05f8 32 7a ee			ld (debug_mark),a  
05fb 3a 0a 06			ld a, (.dmark+1)  
05fe 32 7b ee			ld (debug_mark+1),a  
0601 3a 0b 06			ld a, (.dmark+2)  
0604 32 7c ee			ld (debug_mark+2),a  
0607 18 03			jr .pastdmark  
0609 ..			.dmark: db "SCC"  
060c f1			.pastdmark: pop af  
060d			endm  
# End of macro DMARK
060d					CALLMONITOR 
060d cd ff 13			call break_point_state  
0610				endm  
# End of macro CALLMONITOR
0610				endif 
0610				;  
0610				 
0610 21 40 00			ld hl, STORE_BLOCK_PHY 
0613 11 00 00			ld de, 0 
0616 cd d2 04			call storage_findnextid 
0619			 
0619 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
061c			 
061c				; TODO detect 0 = no spare blocks 
061c			 
061c				; hl now contains the free page to use for the file header page 
061c			 
061c				if DEBUG_STORESE 
061c				DMARK "SCF" 
061c f5				push af  
061d 3a 31 06			ld a, (.dmark)  
0620 32 7a ee			ld (debug_mark),a  
0623 3a 32 06			ld a, (.dmark+1)  
0626 32 7b ee			ld (debug_mark+1),a  
0629 3a 33 06			ld a, (.dmark+2)  
062c 32 7c ee			ld (debug_mark+2),a  
062f 18 03			jr .pastdmark  
0631 ..			.dmark: db "SCF"  
0634 f1			.pastdmark: pop af  
0635			endm  
# End of macro DMARK
0635					CALLMONITOR 
0635 cd ff 13			call break_point_state  
0638				endm  
# End of macro CALLMONITOR
0638				endif 
0638			 
0638 22 4f eb			ld (store_tmppageid), hl 
063b				 
063b 3a 5e eb			ld a,(store_tmpid)    ; get file id 
063e			;	ld a, (store_filecache)			; save to cache 
063e			 
063e 32 65 eb			ld (store_page),a    ; set page id 
0641 3e 00			ld a, 0			 ; extent 0 is file header 
0643 32 66 eb			ld (store_page+1), a   ; set file extent 
0646			 
0646 32 67 eb			ld (store_page+2), a   ; extent count for the file 
0649			 
0649			;	inc hl 		; init block 0 of file 
0649			;	inc hl   		; skip file and extent id 
0649			 ;       ld a, 0 
0649			;	ld (hl),a 
0649			;	ld a, (store_filecache+1)  	; save to cache 
0649			 
0649			;	inc hl    ; file name 
0649				 
0649				 
0649 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
064c				if DEBUG_STORESE 
064c					DMARK "SCc" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 7a ee			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 7b ee			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 7c ee			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "SCc"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665					CALLMONITOR 
0665 cd ff 13			call break_point_state  
0668				endm  
# End of macro CALLMONITOR
0668				endif 
0668 e1				pop hl    ; get zero term string 
0669 e5				push hl 
066a 3e 00			ld a, 0 
066c cd 1b 10			call strlent 
066f 23				inc hl   ; cover zero term 
0670 06 00			ld b,0 
0672 4d				ld c,l 
0673 e1				pop hl 
0674				;ex de, hl 
0674				if DEBUG_STORESE 
0674					DMARK "SCa" 
0674 f5				push af  
0675 3a 89 06			ld a, (.dmark)  
0678 32 7a ee			ld (debug_mark),a  
067b 3a 8a 06			ld a, (.dmark+1)  
067e 32 7b ee			ld (debug_mark+1),a  
0681 3a 8b 06			ld a, (.dmark+2)  
0684 32 7c ee			ld (debug_mark+2),a  
0687 18 03			jr .pastdmark  
0689 ..			.dmark: db "SCa"  
068c f1			.pastdmark: pop af  
068d			endm  
# End of macro DMARK
068d					;push af 
068d					;ld a, 'a' 
068d					;ld (debug_mark),a 
068d					;pop af 
068d					CALLMONITOR 
068d cd ff 13			call break_point_state  
0690				endm  
# End of macro CALLMONITOR
0690				endif 
0690 ed b0			ldir    ; copy zero term string 
0692				if DEBUG_STORESE 
0692					DMARK "SCA" 
0692 f5				push af  
0693 3a a7 06			ld a, (.dmark)  
0696 32 7a ee			ld (debug_mark),a  
0699 3a a8 06			ld a, (.dmark+1)  
069c 32 7b ee			ld (debug_mark+1),a  
069f 3a a9 06			ld a, (.dmark+2)  
06a2 32 7c ee			ld (debug_mark+2),a  
06a5 18 03			jr .pastdmark  
06a7 ..			.dmark: db "SCA"  
06aa f1			.pastdmark: pop af  
06ab			endm  
# End of macro DMARK
06ab					CALLMONITOR 
06ab cd ff 13			call break_point_state  
06ae				endm  
# End of macro CALLMONITOR
06ae				endif 
06ae			 
06ae				; write file header page 
06ae			 
06ae 2a 4f eb			ld hl,(store_tmppageid) 
06b1 11 65 eb			ld de, store_page 
06b4				if DEBUG_STORESE 
06b4					DMARK "SCb" 
06b4 f5				push af  
06b5 3a c9 06			ld a, (.dmark)  
06b8 32 7a ee			ld (debug_mark),a  
06bb 3a ca 06			ld a, (.dmark+1)  
06be 32 7b ee			ld (debug_mark+1),a  
06c1 3a cb 06			ld a, (.dmark+2)  
06c4 32 7c ee			ld (debug_mark+2),a  
06c7 18 03			jr .pastdmark  
06c9 ..			.dmark: db "SCb"  
06cc f1			.pastdmark: pop af  
06cd			endm  
# End of macro DMARK
06cd					;push af 
06cd					;ld a, 'b' 
06cd					;ld (debug_mark),a 
06cd					;pop af 
06cd					CALLMONITOR 
06cd cd ff 13			call break_point_state  
06d0				endm  
# End of macro CALLMONITOR
06d0				endif 
06d0 cd 16 02			call storage_write_block 
06d3			 
06d3 3a 5e eb			ld a, (store_tmpid) 
06d6 6f				ld l, a 
06d7 26 00			ld h,0 
06d9				if DEBUG_STORESE 
06d9					DMARK "SCz" 
06d9 f5				push af  
06da 3a ee 06			ld a, (.dmark)  
06dd 32 7a ee			ld (debug_mark),a  
06e0 3a ef 06			ld a, (.dmark+1)  
06e3 32 7b ee			ld (debug_mark+1),a  
06e6 3a f0 06			ld a, (.dmark+2)  
06e9 32 7c ee			ld (debug_mark+2),a  
06ec 18 03			jr .pastdmark  
06ee ..			.dmark: db "SCz"  
06f1 f1			.pastdmark: pop af  
06f2			endm  
# End of macro DMARK
06f2					CALLMONITOR 
06f2 cd ff 13			call break_point_state  
06f5				endm  
# End of macro CALLMONITOR
06f5				endif 
06f5 c9				ret 
06f6				 
06f6			 
06f6			 
06f6			; 
06f6			; Read File 
06f6			; 
06f6			; h - file id to locate 
06f6			; l - extent to locate 
06f6			; de - pointer to string to read into 
06f6			; 
06f6			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06f6			storage_read: 
06f6 d5				push de 
06f7			 
06f7			; TODO BUG the above push is it popped before the RET Z? 
06f7			 
06f7			; TODO how to handle multiple part blocks 
06f7			 
06f7				; locate file extent to read 
06f7			 
06f7 5c				ld e, h 
06f8 55				ld d, l 
06f9 21 40 00			ld hl, STORE_BLOCK_PHY 
06fc				if DEBUG_STORESE 
06fc					DMARK "SRE" 
06fc f5				push af  
06fd 3a 11 07			ld a, (.dmark)  
0700 32 7a ee			ld (debug_mark),a  
0703 3a 12 07			ld a, (.dmark+1)  
0706 32 7b ee			ld (debug_mark+1),a  
0709 3a 13 07			ld a, (.dmark+2)  
070c 32 7c ee			ld (debug_mark+2),a  
070f 18 03			jr .pastdmark  
0711 ..			.dmark: db "SRE"  
0714 f1			.pastdmark: pop af  
0715			endm  
# End of macro DMARK
0715					CALLMONITOR 
0715 cd ff 13			call break_point_state  
0718				endm  
# End of macro CALLMONITOR
0718				endif 
0718 cd d2 04			call storage_findnextid 
071b			 
071b				if DEBUG_STORESE 
071b					DMARK "SRf" 
071b f5				push af  
071c 3a 30 07			ld a, (.dmark)  
071f 32 7a ee			ld (debug_mark),a  
0722 3a 31 07			ld a, (.dmark+1)  
0725 32 7b ee			ld (debug_mark+1),a  
0728 3a 32 07			ld a, (.dmark+2)  
072b 32 7c ee			ld (debug_mark+2),a  
072e 18 03			jr .pastdmark  
0730 ..			.dmark: db "SRf"  
0733 f1			.pastdmark: pop af  
0734			endm  
# End of macro DMARK
0734					CALLMONITOR 
0734 cd ff 13			call break_point_state  
0737				endm  
# End of macro CALLMONITOR
0737				endif 
0737 cd db 0b			call ishlzero 
073a			;	ld a, l 
073a			;	add h 
073a			;	cp 0 
073a c8				ret z			; block not found so EOF 
073b			 
073b				; hl contains page number to load 
073b d1				pop de   ; get storage 
073c d5				push de 
073d				if DEBUG_STORESE 
073d					DMARK "SRg" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 7a ee			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 7b ee			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 7c ee			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "SRg"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756					CALLMONITOR 
0756 cd ff 13			call break_point_state  
0759				endm  
# End of macro CALLMONITOR
0759				endif 
0759 cd b1 01			call storage_read_block 
075c			 
075c			 
075c			; TODO if block has no zeros then need to read next block  
075c			 
075c			 
075c					 
075c e1				pop hl 		 ; return start of data to show as not EOF 
075d 23				inc hl   ; past file id 
075e 23				inc hl   ; past ext 
075f				if DEBUG_STORESE 
075f					DMARK "SRe" 
075f f5				push af  
0760 3a 74 07			ld a, (.dmark)  
0763 32 7a ee			ld (debug_mark),a  
0766 3a 75 07			ld a, (.dmark+1)  
0769 32 7b ee			ld (debug_mark+1),a  
076c 3a 76 07			ld a, (.dmark+2)  
076f 32 7c ee			ld (debug_mark+2),a  
0772 18 03			jr .pastdmark  
0774 ..			.dmark: db "SRe"  
0777 f1			.pastdmark: pop af  
0778			endm  
# End of macro DMARK
0778					CALLMONITOR 
0778 cd ff 13			call break_point_state  
077b				endm  
# End of macro CALLMONITOR
077b				endif 
077b c9					ret 
077c			 
077c			 
077c			 
077c			; 
077c			; Append File 
077c			; 
077c			; hl - file id to locate 
077c			; de - pointer to (multi block) string to write 
077c			 
077c			 
077c			storage_append: 
077c				; hl -  file id to append to 
077c				; de - string to append 
077c			 
077c d5				push de 
077d				 
077d				if DEBUG_STORESE 
077d					DMARK "AP1" 
077d f5				push af  
077e 3a 92 07			ld a, (.dmark)  
0781 32 7a ee			ld (debug_mark),a  
0784 3a 93 07			ld a, (.dmark+1)  
0787 32 7b ee			ld (debug_mark+1),a  
078a 3a 94 07			ld a, (.dmark+2)  
078d 32 7c ee			ld (debug_mark+2),a  
0790 18 03			jr .pastdmark  
0792 ..			.dmark: db "AP1"  
0795 f1			.pastdmark: pop af  
0796			endm  
# End of macro DMARK
0796					CALLMONITOR 
0796 cd ff 13			call break_point_state  
0799				endm  
# End of macro CALLMONITOR
0799				endif 
0799			 
0799 7d				ld a, l 
079a 32 5e eb			ld (store_tmpid), a 
079d			 
079d				; get file header  
079d			 
079d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
079f 3a 5e eb			ld a, (store_tmpid) 
07a2 5f				ld e, a 
07a3			 
07a3 21 40 00				ld hl, STORE_BLOCK_PHY 
07a6 cd d2 04				call storage_findnextid 
07a9			 
07a9 22 4f eb			ld (store_tmppageid), hl 
07ac			 
07ac				; TODO handle file id not found 
07ac			 
07ac				if DEBUG_STORESE 
07ac					DMARK "AP2" 
07ac f5				push af  
07ad 3a c1 07			ld a, (.dmark)  
07b0 32 7a ee			ld (debug_mark),a  
07b3 3a c2 07			ld a, (.dmark+1)  
07b6 32 7b ee			ld (debug_mark+1),a  
07b9 3a c3 07			ld a, (.dmark+2)  
07bc 32 7c ee			ld (debug_mark+2),a  
07bf 18 03			jr .pastdmark  
07c1 ..			.dmark: db "AP2"  
07c4 f1			.pastdmark: pop af  
07c5			endm  
# End of macro DMARK
07c5					CALLMONITOR 
07c5 cd ff 13			call break_point_state  
07c8				endm  
# End of macro CALLMONITOR
07c8				endif 
07c8			 
07c8				; update file extent count 
07c8			 
07c8 11 65 eb			ld de, store_page 
07cb			 
07cb cd b1 01			call storage_read_block 
07ce			 
07ce				if DEBUG_STORESE 
07ce					DMARK "AP3" 
07ce f5				push af  
07cf 3a e3 07			ld a, (.dmark)  
07d2 32 7a ee			ld (debug_mark),a  
07d5 3a e4 07			ld a, (.dmark+1)  
07d8 32 7b ee			ld (debug_mark+1),a  
07db 3a e5 07			ld a, (.dmark+2)  
07de 32 7c ee			ld (debug_mark+2),a  
07e1 18 03			jr .pastdmark  
07e3 ..			.dmark: db "AP3"  
07e6 f1			.pastdmark: pop af  
07e7			endm  
# End of macro DMARK
07e7					CALLMONITOR 
07e7 cd ff 13			call break_point_state  
07ea				endm  
# End of macro CALLMONITOR
07ea				endif 
07ea			;	ld (store_tmppageid), hl 
07ea			 
07ea 3a 67 eb			ld a, (store_page+2) 
07ed 3c				inc a 
07ee 32 67 eb			ld (store_page+2), a 
07f1 32 5d eb			ld (store_tmpext), a 
07f4				 
07f4				if DEBUG_STORESE 
07f4					DMARK "AP3" 
07f4 f5				push af  
07f5 3a 09 08			ld a, (.dmark)  
07f8 32 7a ee			ld (debug_mark),a  
07fb 3a 0a 08			ld a, (.dmark+1)  
07fe 32 7b ee			ld (debug_mark+1),a  
0801 3a 0b 08			ld a, (.dmark+2)  
0804 32 7c ee			ld (debug_mark+2),a  
0807 18 03			jr .pastdmark  
0809 ..			.dmark: db "AP3"  
080c f1			.pastdmark: pop af  
080d			endm  
# End of macro DMARK
080d					CALLMONITOR 
080d cd ff 13			call break_point_state  
0810				endm  
# End of macro CALLMONITOR
0810				endif 
0810 2a 4f eb			ld hl, (store_tmppageid) 
0813 11 65 eb			ld de, store_page 
0816 cd 16 02			call storage_write_block 
0819			 
0819				; find free block 
0819			 
0819 11 00 00			ld de, 0			 ; file extent to locate 
081c			 
081c 21 40 00				ld hl, STORE_BLOCK_PHY 
081f cd d2 04				call storage_findnextid 
0822			 
0822					; TODO handle no space left 
0822					 
0822 22 4f eb				ld (store_tmppageid), hl 
0825			 
0825				if DEBUG_STORESE 
0825					DMARK "AP4" 
0825 f5				push af  
0826 3a 3a 08			ld a, (.dmark)  
0829 32 7a ee			ld (debug_mark),a  
082c 3a 3b 08			ld a, (.dmark+1)  
082f 32 7b ee			ld (debug_mark+1),a  
0832 3a 3c 08			ld a, (.dmark+2)  
0835 32 7c ee			ld (debug_mark+2),a  
0838 18 03			jr .pastdmark  
083a ..			.dmark: db "AP4"  
083d f1			.pastdmark: pop af  
083e			endm  
# End of macro DMARK
083e					CALLMONITOR 
083e cd ff 13			call break_point_state  
0841				endm  
# End of macro CALLMONITOR
0841				endif 
0841					; init the buffer with zeros so we can id if the buffer is full or not 
0841			 
0841 e5					push hl 
0842 c5					push bc 
0843			 
0843 21 65 eb				ld hl, store_page 
0846 06 40				ld b, STORE_BLOCK_PHY 
0848 3e 00				ld a, 0 
084a 77			.zeroblock:	ld (hl), a 
084b 23					inc hl 
084c 10 fc				djnz .zeroblock 
084e			 
084e c1					pop bc 
084f e1					pop hl 
0850			 
0850					; construct block 
0850			 
0850 3a 5e eb				ld a, (store_tmpid) 
0853 32 65 eb				ld (store_page), a   ; file id 
0856 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
0859 32 66 eb				ld (store_page+1), a 
085c			 
085c e1					pop hl    ; get string to write 
085d 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
085f 11 67 eb				ld de, store_page+2 
0862			 
0862				if DEBUG_STORESE 
0862					DMARK "AP5" 
0862 f5				push af  
0863 3a 77 08			ld a, (.dmark)  
0866 32 7a ee			ld (debug_mark),a  
0869 3a 78 08			ld a, (.dmark+1)  
086c 32 7b ee			ld (debug_mark+1),a  
086f 3a 79 08			ld a, (.dmark+2)  
0872 32 7c ee			ld (debug_mark+2),a  
0875 18 03			jr .pastdmark  
0877 ..			.dmark: db "AP5"  
087a f1			.pastdmark: pop af  
087b			endm  
# End of macro DMARK
087b					CALLMONITOR 
087b cd ff 13			call break_point_state  
087e				endm  
# End of macro CALLMONITOR
087e				endif 
087e			 
087e			 
087e			 
087e					; fill buffer with data until end of string or full block 
087e			 
087e 7e			.appd:		ld a, (hl) 
087f 12					ld (de), a 
0880 fe 00				cp 0 
0882 28 04				jr z, .appdone 
0884 23					inc hl 
0885 13					inc de 
0886 10 f6				djnz .appd 
0888			 
0888 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0889 f5					push af   		; save last byte dumped 
088a			 
088a			 
088a 2a 4f eb			ld hl, (store_tmppageid) 
088d 11 65 eb			ld de, store_page 
0890				if DEBUG_STORESE 
0890					DMARK "AP6" 
0890 f5				push af  
0891 3a a5 08			ld a, (.dmark)  
0894 32 7a ee			ld (debug_mark),a  
0897 3a a6 08			ld a, (.dmark+1)  
089a 32 7b ee			ld (debug_mark+1),a  
089d 3a a7 08			ld a, (.dmark+2)  
08a0 32 7c ee			ld (debug_mark+2),a  
08a3 18 03			jr .pastdmark  
08a5 ..			.dmark: db "AP6"  
08a8 f1			.pastdmark: pop af  
08a9			endm  
# End of macro DMARK
08a9					CALLMONITOR 
08a9 cd ff 13			call break_point_state  
08ac				endm  
# End of macro CALLMONITOR
08ac				endif 
08ac cd 16 02				call storage_write_block 
08af			 
08af			 
08af				; was that a full block of data written? 
08af				; any more to write out? 
08af			 
08af				; if yes then set vars and jump to start of function again 
08af			 
08af f1					pop af 
08b0 d1					pop de 
08b1			 
08b1 fe 00				cp 0		 ; no, string was fully written 
08b3 c8					ret z 
08b4			 
08b4					; setup vars for next cycle 
08b4			 
08b4 3a 5e eb				ld a, (store_tmpid) 
08b7 6f					ld l, a 
08b8 26 00				ld h, 0 
08ba			 
08ba c3 7c 07			 	jp storage_append	 ; yes, need to write out some more 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			if DEBUG_STORECF 
08bd			storageput:	 
08bd					ret 
08bd			storageread: 
08bd					ld hl, store_page 
08bd					ld b, 200 
08bd					ld a,0 
08bd			.src:		ld (hl),a 
08bd					inc hl 
08bd					djnz .src 
08bd					 
08bd			 
08bd					ld de, 0 
08bd					ld bc, 1 
08bd					ld hl, store_page 
08bd					call cfRead 
08bd			 
08bd				call cfGetError 
08bd				ld hl,scratch 
08bd				call hexout 
08bd				ld hl, scratch+2 
08bd				ld a, 0 
08bd				ld (hl),a 
08bd				ld de, scratch 
08bd				ld a,display_row_1 
08bd				call str_at_display 
08bd				call update_display 
08bd			 
08bd					ld hl, store_page 
08bd					ld (os_cur_ptr),hl 
08bd			 
08bd					ret 
08bd			endif 
08bd			 
08bd			 
08bd			; Clear out the main buffer store (used to remove junk before writing a new block) 
08bd			 
08bd			storage_clear_page: 
08bd e5				push hl 
08be d5				push de 
08bf c5				push bc 
08c0 21 65 eb			ld hl, store_page 
08c3 3e 00			ld a, 0 
08c5 77				ld (hl), a 
08c6			 
08c6 11 66 eb			ld de, store_page+1 
08c9 01 40 00			ld bc, STORE_BLOCK_PHY 
08cc			 
08cc ed b0			ldir 
08ce				 
08ce c1				pop bc 
08cf d1				pop de 
08d0 e1				pop hl 
08d1 c9				ret 
08d2			 
08d2			; eof 
# End of file firmware_storage.asm
08d2			  
08d2			; support routines for above hardware abstraction layer  
08d2			  
08d2			include "firmware_general.asm"        ; general support functions  
08d2			 
08d2			; word look up 
08d2			 
08d2			; in 
08d2			; a is the index 
08d2			; hl is pointer start of array 
08d2			; 
08d2			; returns 
08d2			; hl to the word 
08d2			; 
08d2			 
08d2			table_lookup:  
08d2 d5					push de 
08d3 eb					ex de, hl 
08d4			 
08d4 6f					ld l, a 
08d5 26 00				ld h, 0 
08d7 29					add hl, hl 
08d8 19					add hl, de 
08d9 7e					ld a, (hl) 
08da 23					inc hl 
08db 66					ld h,(hl) 
08dc 6f					ld l, a 
08dd			 
08dd d1					pop de 
08de c9					ret 
08df			 
08df			; Delay loops 
08df			 
08df			 
08df			 
08df			aDelayInMS: 
08df c5				push bc 
08e0 47				ld b,a 
08e1			msdelay: 
08e1 c5				push bc 
08e2				 
08e2			 
08e2 01 41 00			ld bc,041h 
08e5 cd fd 08			call delayloop 
08e8 c1				pop bc 
08e9 05				dec b 
08ea 20 f5			jr nz,msdelay 
08ec			 
08ec			;if CPU_CLOCK_8MHZ 
08ec			;msdelay8: 
08ec			;	push bc 
08ec			;	 
08ec			; 
08ec			;	ld bc,041h 
08ec			;	call delayloop 
08ec			;	pop bc 
08ec			;	dec b 
08ec			;	jr nz,msdelay8 
08ec			;endif 
08ec			 
08ec			 
08ec c1				pop bc 
08ed c9				ret 
08ee			 
08ee			 
08ee			delay250ms: 
08ee				;push de 
08ee 01 00 40			ld bc, 04000h 
08f1 c3 fd 08			jp delayloop 
08f4			delay500ms: 
08f4				;push de 
08f4 01 00 80			ld bc, 08000h 
08f7 c3 fd 08			jp delayloop 
08fa			delay1s: 
08fa				;push bc 
08fa			   ; Clobbers A, d and e 
08fa 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
08fd			delayloop: 
08fd c5			    push bc 
08fe			 
08fe			if BASE_CPM 
08fe 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0901			.cpmloop: 
0901 c5				push bc 
0902			 
0902			endif 
0902			 
0902			 
0902			 
0902			delayloopi: 
0902			;	push bc 
0902			;.dl: 
0902 cb 47		    bit     0,a    	; 8 
0904 cb 47		    bit     0,a    	; 8 
0906 cb 47		    bit     0,a    	; 8 
0908 e6 ff		    and     255  	; 7 
090a 0b			    dec     bc      	; 6 
090b 79			    ld      a,c     	; 4 
090c b0			    or      b     	; 4 
090d c2 02 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0910			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0910				;pop de 
0910			;pop bc 
0910			 
0910			if BASE_CPM 
0910 c1				pop bc 
0911				 
0911 0b			    dec     bc      	; 6 
0912 79			    ld      a,c     	; 4 
0913 b0			    or      b     	; 4 
0914 c2 01 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0917				 
0917			 
0917			endif 
0917			;if CPU_CLOCK_8MHZ 
0917			;    pop bc 
0917			;    push bc 
0917			;.dl8: 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    and     255  	; 7 
0917			;    dec     bc      	; 6 
0917			;    ld      a,c     	; 4 
0917			;    or      b     	; 4 
0917			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0917			;endif 
0917			 
0917			;if CPU_CLOCK_10MHZ 
0917			;    pop bc 
0917			;    push bc 
0917			;.dl8: 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    and     255  	; 7 
0917			;    dec     bc      	; 6 
0917			;    ld      a,c     	; 4 
0917			;    or      b     	; 4 
0917			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0917			;endif 
0917 c1			    pop bc 
0918			 
0918 c9				ret 
0919			 
0919			 
0919			 
0919			; eof 
# End of file firmware_general.asm
0919			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0919			; display routines that use the physical hardware abstraction layer 
0919			 
0919			 
0919			; information window 
0919			 
0919			; pass hl with 1st string to display 
0919			; pass de with 2nd string to display 
0919			 
0919			info_panel: 
0919 e5				push hl 
091a			 
091a 2a db eb			ld hl, (display_fb_active) 
091d e5				push hl    ; future de destination 
091e 21 c0 ed				ld hl, display_fb0 
0921 22 db eb				ld (display_fb_active), hl 
0924			 
0924 cd 85 09			call clear_display 
0927			 
0927			 
0927 3e 55			ld a, display_row_3 + 5 
0929 cd 98 09			call str_at_display 
092c			 
092c e1				pop hl 
092d d1				pop de 
092e			 
092e e5				push hl 
092f			 
092f			 
092f 3e 2d			ld a, display_row_2 + 5 
0931 cd 98 09			call str_at_display 
0934			 
0934			 
0934 cd a8 09			call update_display 
0937 cd 04 19			call next_page_prompt 
093a cd 85 09			call clear_display 
093d			 
093d				 
093d 21 1f ed				ld hl, display_fb1 
0940 22 db eb				ld (display_fb_active), hl 
0943 cd a8 09			call update_display 
0946			 
0946			 
0946 c9				ret 
0947			 
0947			 
0947			 
0947			 
0947			; TODO windowing? 
0947			 
0947			; TODO scroll line up 
0947			 
0947			scroll_up: 
0947			 
0947 e5				push hl 
0948 d5				push de 
0949 c5				push bc 
094a			 
094a				; get frame buffer  
094a			 
094a 2a db eb			ld hl, (display_fb_active) 
094d e5				push hl    ; future de destination 
094e			 
094e 11 28 00			ld  de, display_cols 
0951 19				add hl, de 
0952			 
0952 d1				pop de 
0953			 
0953				;ex de, hl 
0953 01 9f 00			ld bc, display_fb_len -1  
0956			;if DEBUG_FORTH_WORDS 
0956			;	DMARK "SCL" 
0956			;	CALLMONITOR 
0956			;endif	 
0956 ed b0			ldir 
0958			 
0958				; wipe bottom row 
0958			 
0958			 
0958 2a db eb			ld hl, (display_fb_active) 
095b 11 a0 00			ld de, display_cols*display_rows 
095e 19				add hl, de 
095f 06 28			ld b, display_cols 
0961 3e 20			ld a, ' ' 
0963			.scwipe: 
0963 77				ld (hl), a 
0964 2b				dec hl 
0965 10 fc			djnz .scwipe 
0967			 
0967				;pop hl 
0967			 
0967 c1				pop bc 
0968 d1				pop de 
0969 e1				pop hl 
096a			 
096a c9				ret 
096b			 
096b			 
096b			;scroll_upo: 
096b			;	ld de, display_row_1 
096b			 ;	ld hl, display_row_2 
096b			;	ld bc, display_cols 
096b			;	ldir 
096b			;	ld de, display_row_2 
096b			 ;	ld hl, display_row_3 
096b			;	ld bc, display_cols 
096b			;	ldir 
096b			;	ld de, display_row_3 
096b			 ;	ld hl, display_row_4 
096b			;	ld bc, display_cols 
096b			;	ldir 
096b			 
096b			; TODO clear row 4 
096b			 
096b			;	ret 
096b			 
096b				 
096b			scroll_down: 
096b			 
096b e5				push hl 
096c d5				push de 
096d c5				push bc 
096e			 
096e				; get frame buffer  
096e			 
096e 2a db eb			ld hl, (display_fb_active) 
0971			 
0971 11 9f 00			ld de, display_fb_len - 1 
0974 19				add hl, de 
0975			 
0975 e5			push hl    ; future de destination 
0976			 
0976 11 28 00			ld  de, display_cols 
0979 ed 52			sbc hl, de 
097b			 
097b			 
097b d1				pop de 
097c			 
097c			;	ex de, hl 
097c 01 9f 00			ld bc, display_fb_len -1  
097f			 
097f			 
097f				 
097f			 
097f ed b0			ldir 
0981			 
0981				; wipe bottom row 
0981			 
0981			 
0981			;	ld hl, (display_fb_active) 
0981			;;	ld de, display_cols*display_rows 
0981			;;	add hl, de 
0981			;	ld b, display_cols 
0981			;	ld a, ' ' 
0981			;.scwiped: 
0981			;	ld (hl), a 
0981			;	dec hl 
0981			;	djnz .scwiped 
0981			 
0981				;pop hl 
0981			 
0981 c1				pop bc 
0982 d1				pop de 
0983 e1				pop hl 
0984			 
0984 c9				ret 
0985			;scroll_down: 
0985			;	ld de, display_row_4 
0985			;	ld hl, display_row_3 
0985			;	ld bc, display_cols 
0985			;	ldir 
0985			;	ld de, display_row_3 
0985			; 	ld hl, display_row_2 
0985			;	ld bc, display_cols 
0985			;	ldir 
0985			;	ld de, display_row_2 
0985			;	ld hl, display_row_1 
0985			;	ld bc, display_cols 
0985			;	ldir 
0985			;;; TODO clear row 1 
0985			;	ret 
0985			 
0985			 
0985			 
0985			 
0985			 
0985			; clear active frame buffer 
0985			 
0985			clear_display: 
0985 3e 20			ld a, ' ' 
0987 c3 8a 09			jp fill_display 
098a			 
098a			; fill active frame buffer with a char in A 
098a			 
098a			fill_display: 
098a 06 a0			ld b,display_fb_len 
098c 2a db eb			ld hl, (display_fb_active) 
098f 77			.fd1:	ld (hl),a 
0990 23				inc hl 
0991 10 fc			djnz .fd1 
0993 23				inc hl 
0994 3e 00			ld a,0 
0996 77				ld (hl),a 
0997			 
0997			 
0997 c9				ret 
0998			; Write string (DE) at pos (A) to active frame buffer 
0998			 
0998 2a db eb		str_at_display:    ld hl,(display_fb_active) 
099b 06 00					ld b,0 
099d 4f					ld c,a 
099e 09					add hl,bc 
099f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09a0 b7			            OR   A              ;Null terminator? 
09a1 c8			            RET  Z              ;Yes, so finished 
09a2 77					ld (hl),a 
09a3 23				inc hl 
09a4 13			            INC  DE             ;Point to next character 
09a5 18 f8		            JR   .sad1     ;Repeat 
09a7 c9					ret 
09a8			 
09a8			; using current frame buffer write to physical display 
09a8			 
09a8			update_display: 
09a8 e5				push hl 
09a9 2a db eb			ld hl, (display_fb_active) 
09ac cd 04 59			call write_display 
09af e1				pop hl 
09b0 c9				ret 
09b1			 
09b1			; TODO scrolling 
09b1			 
09b1			 
09b1			; move cursor right one char 
09b1			cursor_right: 
09b1			 
09b1				; TODO shift right 
09b1				; TODO if beyond max col 
09b1				; TODO       cursor_next_line 
09b1			 
09b1 c9				ret 
09b2			 
09b2			 
09b2			cursor_next_line: 
09b2				; TODO first char 
09b2				; TODO line down 
09b2				; TODO if past last row 
09b2				; TODO    scroll up 
09b2			 
09b2 c9				ret 
09b3			 
09b3			cursor_left: 
09b3				; TODO shift left 
09b3				; TODO if beyond left  
09b3				; TODO     cursor prev line 
09b3				 
09b3 c9				ret 
09b4			 
09b4			cursor_prev_line: 
09b4				; TODO last char 
09b4				; TODO line up 
09b4				; TODO if past first row 
09b4				; TODO   scroll down 
09b4			 
09b4 c9				ret 
09b5			 
09b5			 
09b5			cout: 
09b5				; A - char 
09b5 c9				ret 
09b6			 
09b6			 
09b6			; Display a menu and allow item selection (optional toggle items) 
09b6			; 
09b6			; format: 
09b6			; hl pointer to word array with zero term for items 
09b6			; e.g.    db item1 
09b6			;         db .... 
09b6			;         db 0 
09b6			; 
09b6			; a = starting menu item  
09b6			; 
09b6			; de = pointer item toggle array   (todo) 
09b6			; 
09b6			; returns item selected in a 1-... 
09b6			; returns 0 if back button pressed 
09b6			; 
09b6			; NOTE: Uses system frame buffer to display 
09b6			; 
09b6			; LEFT, Q = go back 
09b6			; RIGHT, SPACE, CR = select 
09b6			; UP, A - Up 
09b6			; DOWN, Z - Down 
09b6			 
09b6			 
09b6			 
09b6			 
09b6			 
09b6			menu: 
09b6			 
09b6					; keep array pointer 
09b6			 
09b6 22 63 eb				ld (store_tmp1), hl 
09b9 32 61 eb				ld (store_tmp2), a 
09bc			 
09bc					; check for key bounce 
09bc			 
09bc			if BASE_KEV 
09bc			 
09bc			.mbounce:	call cin 
09bc					cp 0 
09bc					jr nz, .mbounce 
09bc			endif 
09bc					; for ease use ex 
09bc			 
09bc					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
09bc 21 c0 ed				ld hl, display_fb0 
09bf 22 db eb				ld (display_fb_active), hl 
09c2			 
09c2 cd 85 09		.mloop:		call clear_display 
09c5 cd a8 09				call update_display 
09c8			 
09c8					; draw selection id '>' at 1 
09c8			 
09c8					; init start of list display 
09c8			 
09c8 3e 05				ld a, 5 
09ca 32 5f eb				ld (store_tmp3), a   ; display row count 
09cd 3a 61 eb				ld a,( store_tmp2) 
09d0 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09d3			 
09d3					 
09d3			.mitem:	 
09d3			 
09d3			 
09d3 3a 62 eb				ld a,(store_tmp2+1) 
09d6 6f					ld l, a 
09d7 26 00				ld h, 0 
09d9 29					add hl, hl 
09da ed 5b 63 eb			ld de, (store_tmp1) 
09de 19					add hl, de 
09df 7e					ld a, (hl) 
09e0 23					inc hl 
09e1 66					ld h,(hl) 
09e2 6f					ld l, a 
09e3			 
09e3 cd db 0b				call ishlzero 
09e6 28 1a				jr z, .mdone 
09e8			 
09e8 eb					ex de, hl 
09e9 3a 5f eb				ld a, (store_tmp3) 
09ec cd 98 09				call str_at_display 
09ef					 
09ef			 
09ef					; next item 
09ef 3a 62 eb				ld a, (store_tmp2+1) 
09f2 3c					inc a 
09f3 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09f6			 
09f6			 		; next row 
09f6			 
09f6 3a 5f eb				ld a, (store_tmp3) 
09f9 c6 28				add display_cols 
09fb 32 5f eb				ld (store_tmp3), a 
09fe			 
09fe					; at end of screen? 
09fe			 
09fe fe 10				cp display_rows*4 
0a00 20 d1				jr nz, .mitem 
0a02			 
0a02			 
0a02			.mdone: 
0a02 cd db 0b				call ishlzero 
0a05 28 08				jr z, .nodn 
0a07			 
0a07 3e 78				ld a, display_row_4 
0a09 11 88 0a				ld de, .mdown 
0a0c cd 98 09				call str_at_display 
0a0f			 
0a0f					; draw options to fill the screens with active item on line 1 
0a0f					; if current option is 2 or more then display ^ in top 
0a0f			 
0a0f 3a 61 eb		.nodn:		ld a, (store_tmp2) 
0a12 fe 00				cp 0 
0a14 28 08				jr z, .noup 
0a16			 
0a16 3e 00				ld a, 0 
0a18 11 86 0a				ld de, .mup 
0a1b cd 98 09				call str_at_display 
0a1e			 
0a1e 3e 02		.noup:		ld a, 2 
0a20 11 84 0a				ld de, .msel 
0a23 cd 98 09				call str_at_display 
0a26			 
0a26					; if current option + 1 is not null then display V in bottom 
0a26					; get key 
0a26 cd a8 09				call update_display 
0a29			 
0a29			 
0a29					; handle key 
0a29			 
0a29 cd b6 59				call cin_wait 
0a2c			 
0a2c fe 05				cp KEY_UP 
0a2e 28 2b				jr z, .mgoup 
0a30 fe 61				cp 'a' 
0a32 28 27				jr z, .mgoup 
0a34 fe 0a				cp KEY_DOWN 
0a36 28 32				jr z, .mgod 
0a38 fe 7a				cp 'z' 
0a3a 28 2e				jr z, .mgod 
0a3c fe 20				cp ' ' 
0a3e 28 34				jr z, .goend 
0a40 fe 0c				cp KEY_RIGHT 
0a42 28 30				jr z, .goend 
0a44 fe 0d				cp KEY_CR 
0a46 28 2c				jr z, .goend 
0a48 fe 71				cp 'q' 
0a4a 28 0b				jr z, .goback 
0a4c			 
0a4c fe 0b				cp KEY_LEFT 
0a4e 28 07				jr z, .goback 
0a50 fe 08				cp KEY_BS 
0a52 28 03				jr z, .goback 
0a54 c3 c2 09				jp .mloop 
0a57			 
0a57			.goback: 
0a57 3e 00			ld a, 0 
0a59 18 1d			jr .goend2 
0a5b			 
0a5b				; move up one 
0a5b			.mgoup: 
0a5b 3a 61 eb				ld a, (store_tmp2) 
0a5e fe 00				cp 0 
0a60 ca c2 09				jp z, .mloop 
0a63 3d					dec a 
0a64 32 61 eb				ld (store_tmp2), a 
0a67 c3 c2 09				jp .mloop 
0a6a			 
0a6a				; move down one 
0a6a			.mgod: 
0a6a 3a 61 eb				ld a, (store_tmp2) 
0a6d 3c					inc a 
0a6e 32 61 eb				ld (store_tmp2), a 
0a71 c3 c2 09				jp .mloop 
0a74			 
0a74			 
0a74			.goend: 
0a74					; get selected item number 
0a74			 
0a74 3a 61 eb				ld a, (store_tmp2) 
0a77 3c					inc a 
0a78			 
0a78			.goend2: 
0a78 f5					push af 
0a79			 
0a79					; restore active fb 
0a79					; TODO BUG assumes fb1 
0a79			 
0a79 21 1f ed				ld hl, display_fb1 
0a7c 22 db eb				ld (display_fb_active), hl 
0a7f			 
0a7f					; restore main regs 
0a7f			 
0a7f			 
0a7f cd a8 09				call update_display 
0a82			 
0a82 f1					pop af 
0a83			 
0a83 c9				ret 
0a84			 
0a84 .. 00		.msel:   db ">",0 
0a86 .. 00		.mup:   db "^",0 
0a88 .. 00		.mdown:   db "v",0 
0a8a			 
0a8a			 
0a8a			; eof 
0a8a			 
# End of file firmware_display.asm
0a8a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a8a			; random number generators 
0a8a			 
0a8a			 
0a8a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a8a			 
0a8a			 
0a8a			;-----> Generate a random number 
0a8a			; output a=answer 0<=a<=255 
0a8a			; all registers are preserved except: af 
0a8a			random: 
0a8a e5			        push    hl 
0a8b d5			        push    de 
0a8c 2a bd eb		        ld      hl,(randData) 
0a8f ed 5f		        ld      a,r 
0a91 57			        ld      d,a 
0a92 5e			        ld      e,(hl) 
0a93 19			        add     hl,de 
0a94 85			        add     a,l 
0a95 ac			        xor     h 
0a96 22 bd eb		        ld      (randData),hl 
0a99 d1			        pop     de 
0a9a e1			        pop     hl 
0a9b c9			        ret 
0a9c			 
0a9c			 
0a9c			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0a9c			 
0a9c			 
0a9c			 
0a9c			;------LFSR------ 
0a9c			;James Montelongo 
0a9c			;optimized by Spencer Putt 
0a9c			;out: 
0a9c			; a = 8 bit random number 
0a9c			RandLFSR: 
0a9c 21 c3 eb		        ld hl,LFSRSeed+4 
0a9f 5e			        ld e,(hl) 
0aa0 23			        inc hl 
0aa1 56			        ld d,(hl) 
0aa2 23			        inc hl 
0aa3 4e			        ld c,(hl) 
0aa4 23			        inc hl 
0aa5 7e			        ld a,(hl) 
0aa6 47			        ld b,a 
0aa7 cb 13		        rl e  
0aa9 cb 12			rl d 
0aab cb 11		        rl c  
0aad 17				rla 
0aae cb 13		        rl e  
0ab0 cb 12			rl d 
0ab2 cb 11		        rl c  
0ab4 17				rla 
0ab5 cb 13		        rl e  
0ab7 cb 12			rl d 
0ab9 cb 11		        rl c  
0abb 17				rla 
0abc 67			        ld h,a 
0abd cb 13		        rl e  
0abf cb 12			rl d 
0ac1 cb 11		        rl c  
0ac3 17				rla 
0ac4 a8			        xor b 
0ac5 cb 13		        rl e  
0ac7 cb 12			rl d 
0ac9 ac			        xor h 
0aca a9			        xor c 
0acb aa			        xor d 
0acc 21 c5 eb		        ld hl,LFSRSeed+6 
0acf 11 c6 eb		        ld de,LFSRSeed+7 
0ad2 01 07 00		        ld bc,7 
0ad5 ed b8		        lddr 
0ad7 12			        ld (de),a 
0ad8 c9			        ret 
0ad9			 
0ad9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ad9			 
0ad9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ad9			 
0ad9			 
0ad9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ad9			 
0ad9			prng16: 
0ad9			;Inputs: 
0ad9			;   (seed1) contains a 16-bit seed value 
0ad9			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ad9			;Outputs: 
0ad9			;   HL is the result 
0ad9			;   BC is the result of the LCG, so not that great of quality 
0ad9			;   DE is preserved 
0ad9			;Destroys: 
0ad9			;   AF 
0ad9			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ad9			;160cc 
0ad9			;26 bytes 
0ad9 2a b7 eb		    ld hl,(seed1) 
0adc 44			    ld b,h 
0add 4d			    ld c,l 
0ade 29			    add hl,hl 
0adf 29			    add hl,hl 
0ae0 2c			    inc l 
0ae1 09			    add hl,bc 
0ae2 22 b7 eb		    ld (seed1),hl 
0ae5 2a b5 eb		    ld hl,(seed2) 
0ae8 29			    add hl,hl 
0ae9 9f			    sbc a,a 
0aea e6 2d		    and %00101101 
0aec ad			    xor l 
0aed 6f			    ld l,a 
0aee 22 b5 eb		    ld (seed2),hl 
0af1 09			    add hl,bc 
0af2 c9			    ret 
0af3			 
0af3			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0af3			 
0af3			rand32: 
0af3			;Inputs: 
0af3			;   (seed1_0) holds the lower 16 bits of the first seed 
0af3			;   (seed1_1) holds the upper 16 bits of the first seed 
0af3			;   (seed2_0) holds the lower 16 bits of the second seed 
0af3			;   (seed2_1) holds the upper 16 bits of the second seed 
0af3			;   **NOTE: seed2 must be non-zero 
0af3			;Outputs: 
0af3			;   HL is the result 
0af3			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0af3			;Destroys: 
0af3			;   AF 
0af3			;Tested and passes all CAcert tests 
0af3			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0af3			;it has a period of 18,446,744,069,414,584,320 
0af3			;roughly 18.4 quintillion. 
0af3			;LFSR taps: 0,2,6,7  = 11000101 
0af3			;291cc 
0af3			;seed1_0=$+1 
0af3			;    ld hl,12345 
0af3			;seed1_1=$+1 
0af3			;    ld de,6789 
0af3			;    ld b,h 
0af3			;    ld c,l 
0af3			;    add hl,hl \ rl e \ rl d 
0af3			;    add hl,hl \ rl e \ rl d 
0af3			;    inc l 
0af3			;    add hl,bc 
0af3			;    ld (seed1_0),hl 
0af3			;    ld hl,(seed1_1) 
0af3			;    adc hl,de 
0af3			;    ld (seed1_1),hl 
0af3			;    ex de,hl 
0af3			;seed2_0=$+1 
0af3			;    ld hl,9876 
0af3			;seed2_1=$+1 
0af3			;    ld bc,54321 
0af3			;    add hl,hl \ rl c \ rl b 
0af3			;    ld (seed2_1),bc 
0af3			;    sbc a,a 
0af3			;    and %11000101 
0af3			;    xor l 
0af3			;    ld l,a 
0af3			;    ld (seed2_0),hl 
0af3			;    ex de,hl 
0af3			;    add hl,bc 
0af3			;    ret 
0af3			; 
0af3			 
0af3			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0af3			; 20 bytes, 86 cycles (excluding ret) 
0af3			 
0af3			; returns   hl = pseudorandom number 
0af3			; corrupts   a 
0af3			 
0af3			; generates 16-bit pseudorandom numbers with a period of 65535 
0af3			; using the xorshift method: 
0af3			 
0af3			; hl ^= hl << 7 
0af3			; hl ^= hl >> 9 
0af3			; hl ^= hl << 8 
0af3			 
0af3			; some alternative shift triplets which also perform well are: 
0af3			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0af3			 
0af3			;  org 32768 
0af3			 
0af3			xrnd: 
0af3 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0af6 3e 00		  ld a,0 
0af8 bd			  cp l 
0af9 20 02		  jr nz, .xrnd1 
0afb 2e 01		  ld l, 1 
0afd			.xrnd1: 
0afd			 
0afd 7c			  ld a,h 
0afe 1f			  rra 
0aff 7d			  ld a,l 
0b00 1f			  rra 
0b01 ac			  xor h 
0b02 67			  ld h,a 
0b03 7d			  ld a,l 
0b04 1f			  rra 
0b05 7c			  ld a,h 
0b06 1f			  rra 
0b07 ad			  xor l 
0b08 6f			  ld l,a 
0b09 ac			  xor h 
0b0a 67			  ld h,a 
0b0b			 
0b0b 22 bb eb		  ld (xrandc),hl 
0b0e			 
0b0e c9			  ret 
0b0f			;  
0b0f			 
0b0f			 
0b0f			;;;; int maths 
0b0f			 
0b0f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b0f			; Divide 16-bit values (with 16-bit result) 
0b0f			; In: Divide BC by divider DE 
0b0f			; Out: BC = result, HL = rest 
0b0f			; 
0b0f			Div16: 
0b0f 21 00 00		    ld hl,0 
0b12 78			    ld a,b 
0b13 06 08		    ld b,8 
0b15			Div16_Loop1: 
0b15 17			    rla 
0b16 ed 6a		    adc hl,hl 
0b18 ed 52		    sbc hl,de 
0b1a 30 01		    jr nc,Div16_NoAdd1 
0b1c 19			    add hl,de 
0b1d			Div16_NoAdd1: 
0b1d 10 f6		    djnz Div16_Loop1 
0b1f 17			    rla 
0b20 2f			    cpl 
0b21 47			    ld b,a 
0b22 79			    ld a,c 
0b23 48			    ld c,b 
0b24 06 08		    ld b,8 
0b26			Div16_Loop2: 
0b26 17			    rla 
0b27 ed 6a		    adc hl,hl 
0b29 ed 52		    sbc hl,de 
0b2b 30 01		    jr nc,Div16_NoAdd2 
0b2d 19			    add hl,de 
0b2e			Div16_NoAdd2: 
0b2e 10 f6		    djnz Div16_Loop2 
0b30 17			    rla 
0b31 2f			    cpl 
0b32 41			    ld b,c 
0b33 4f			    ld c,a 
0b34 c9			ret 
0b35			 
0b35			 
0b35			;http://z80-heaven.wikidot.com/math 
0b35			; 
0b35			;Inputs: 
0b35			;     DE and A are factors 
0b35			;Outputs: 
0b35			;     A is not changed 
0b35			;     B is 0 
0b35			;     C is not changed 
0b35			;     DE is not changed 
0b35			;     HL is the product 
0b35			;Time: 
0b35			;     342+6x 
0b35			; 
0b35			Mult16: 
0b35			 
0b35 06 08		     ld b,8          ;7           7 
0b37 21 00 00		     ld hl,0         ;10         10 
0b3a 29			       add hl,hl     ;11*8       88 
0b3b 07			       rlca          ;4*8        32 
0b3c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b3e 19			         add hl,de   ;--         -- 
0b3f 10 f9		       djnz $-5      ;13*7+8     99 
0b41 c9			ret 
0b42			 
0b42			; 
0b42			; Square root of 16-bit value 
0b42			; In:  HL = value 
0b42			; Out:  D = result (rounded down) 
0b42			; 
0b42			;Sqr16: 
0b42			;    ld de,#0040 
0b42			;    ld a,l 
0b42			;    ld l,h 
0b42			;    ld h,d 
0b42			;    or a 
0b42			;    ld b,8 
0b42			;Sqr16_Loop: 
0b42			;    sbc hl,de 
0b42			;    jr nc,Sqr16_Skip 
0b42			;    add hl,de 
0b42			;Sqr16_Skip: 
0b42			;    ccf 
0b42			;    rl d 
0b42			;    add a,a 
0b42			;    adc hl,hl 
0b42			;    add a,a 
0b42			;    adc hl,hl 
0b42			;    djnz Sqr16_Loop 
0b42			;    ret 
0b42			; 
0b42			; 
0b42			; Divide 8-bit values 
0b42			; In: Divide E by divider C 
0b42			; Out: A = result, B = rest 
0b42			; 
0b42			Div8: 
0b42 af			    xor a 
0b43 06 08		    ld b,8 
0b45			Div8_Loop: 
0b45 cb 13		    rl e 
0b47 17			    rla 
0b48 91			    sub c 
0b49 30 01		    jr nc,Div8_NoAdd 
0b4b 81			    add a,c 
0b4c			Div8_NoAdd: 
0b4c 10 f7		    djnz Div8_Loop 
0b4e 47			    ld b,a 
0b4f 7b			    ld a,e 
0b50 17			    rla 
0b51 2f			    cpl 
0b52 c9			    ret 
0b53			 
0b53			; 
0b53			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b53			; In: Multiply A with DE 
0b53			; Out: HL = result 
0b53			; 
0b53			Mult12U: 
0b53 2e 00		    ld l,0 
0b55 87			    add a,a 
0b56 30 01		    jr nc,Mult12U_NoAdd0 
0b58 19			    add hl,de 
0b59			Mult12U_NoAdd0: 
0b59 29			    add hl,hl 
0b5a 87			    add a,a 
0b5b 30 01		    jr nc,Mult12U_NoAdd1 
0b5d 19			    add hl,de 
0b5e			Mult12U_NoAdd1: 
0b5e 29			    add hl,hl 
0b5f 87			    add a,a 
0b60 30 01		    jr nc,Mult12U_NoAdd2 
0b62 19			    add hl,de 
0b63			Mult12U_NoAdd2: 
0b63 29			    add hl,hl 
0b64 87			    add a,a 
0b65 30 01		    jr nc,Mult12U_NoAdd3 
0b67 19			    add hl,de 
0b68			Mult12U_NoAdd3: 
0b68 29			    add hl,hl 
0b69 87			    add a,a 
0b6a 30 01		    jr nc,Mult12U_NoAdd4 
0b6c 19			    add hl,de 
0b6d			Mult12U_NoAdd4: 
0b6d 29			    add hl,hl 
0b6e 87			    add a,a 
0b6f 30 01		    jr nc,Mult12U_NoAdd5 
0b71 19			    add hl,de 
0b72			Mult12U_NoAdd5: 
0b72 29			    add hl,hl 
0b73 87			    add a,a 
0b74 30 01		    jr nc,Mult12U_NoAdd6 
0b76 19			    add hl,de 
0b77			Mult12U_NoAdd6: 
0b77 29			    add hl,hl 
0b78 87			    add a,a 
0b79 d0			    ret nc 
0b7a 19			    add hl,de 
0b7b c9			    ret 
0b7c			 
0b7c			; 
0b7c			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b7c			; In: Multiply A with DE 
0b7c			;      Put lowest value in A for most efficient calculation 
0b7c			; Out: HL = result 
0b7c			; 
0b7c			Mult12R: 
0b7c 21 00 00		    ld hl,0 
0b7f			Mult12R_Loop: 
0b7f cb 3f		    srl a 
0b81 30 01		    jr nc,Mult12R_NoAdd 
0b83 19			    add hl,de 
0b84			Mult12R_NoAdd: 
0b84 cb 23		    sla e 
0b86 cb 12		    rl d 
0b88 b7			    or a 
0b89 c2 7f 0b		    jp nz,Mult12R_Loop 
0b8c c9			    ret 
0b8d			 
0b8d			; 
0b8d			; Multiply 16-bit values (with 32-bit result) 
0b8d			; In: Multiply BC with DE 
0b8d			; Out: BCHL = result 
0b8d			; 
0b8d			Mult32: 
0b8d 79			    ld a,c 
0b8e 48			    ld c,b 
0b8f 21 00 00		    ld hl,0 
0b92 06 10		    ld b,16 
0b94			Mult32_Loop: 
0b94 29			    add hl,hl 
0b95 17			    rla 
0b96 cb 11		    rl c 
0b98 30 07		    jr nc,Mult32_NoAdd 
0b9a 19			    add hl,de 
0b9b ce 00		    adc a,0 
0b9d d2 a1 0b		    jp nc,Mult32_NoAdd 
0ba0 0c			    inc c 
0ba1			Mult32_NoAdd: 
0ba1 10 f1		    djnz Mult32_Loop 
0ba3 41			    ld b,c 
0ba4 4f			    ld c,a 
0ba5 c9			    ret 
0ba6			 
0ba6			 
0ba6			 
0ba6			; 
0ba6			; Multiply 8-bit values 
0ba6			; In:  Multiply H with E 
0ba6			; Out: HL = result 
0ba6			; 
0ba6			Mult8: 
0ba6 16 00		    ld d,0 
0ba8 6a			    ld l,d 
0ba9 06 08		    ld b,8 
0bab			Mult8_Loop: 
0bab 29			    add hl,hl 
0bac 30 01		    jr nc,Mult8_NoAdd 
0bae 19			    add hl,de 
0baf			Mult8_NoAdd: 
0baf 10 fa		    djnz Mult8_Loop 
0bb1 c9			    ret 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			;;http://z80-heaven.wikidot.com/math 
0bb2			;;This divides DE by BC, storing the result in DE, remainder in HL 
0bb2			; 
0bb2			;DE_Div_BC:          ;1281-2x, x is at most 16 
0bb2			;     ld a,16        ;7 
0bb2			;     ld hl,0        ;10 
0bb2			;     jp $+5         ;10 
0bb2			;.DivLoop: 
0bb2			;       add hl,bc    ;-- 
0bb2			;       dec a        ;64 
0bb2			;       jr z,.DivLoopEnd        ;86 
0bb2			; 
0bb2			;       sla e        ;128 
0bb2			;       rl d         ;128 
0bb2			;       adc hl,hl    ;240 
0bb2			;       sbc hl,bc    ;240 
0bb2			;       jr nc,.DivLoop ;23|21 
0bb2			;       inc e        ;-- 
0bb2			;       jp .DivLoop+1 
0bb2			; 
0bb2			;.DivLoopEnd: 
0bb2			 
0bb2			;HL_Div_C: 
0bb2			;Inputs: 
0bb2			;     HL is the numerator 
0bb2			;     C is the denominator 
0bb2			;Outputs: 
0bb2			;     A is the remainder 
0bb2			;     B is 0 
0bb2			;     C is not changed 
0bb2			;     DE is not changed 
0bb2			;     HL is the quotient 
0bb2			; 
0bb2			;       ld b,16 
0bb2			;       xor a 
0bb2			;         add hl,hl 
0bb2			;         rla 
0bb2			;         cp c 
0bb2			;         jr c,$+4 
0bb2			;           inc l 
0bb2			;           sub c 
0bb2			;         djnz $-7 
0bb2			 
0bb2			; https://plutiedev.com/z80-add-8bit-to-16bit 
0bb2			 
0bb2			addatohl: 
0bb2 85			    add   a, l    ; A = A+L 
0bb3 6f			    ld    l, a    ; L = A+L 
0bb4 8c			    adc   a, h    ; A = A+L+H+carry 
0bb5 95			    sub   l       ; A = H+carry 
0bb6 67			    ld    h, a    ; H = H+carry 
0bb7 c9			ret 
0bb8			 
0bb8			addatode: 
0bb8 83			    add   a, e    ; A = A+L 
0bb9 5f			    ld    e, a    ; L = A+L 
0bba 8a			    adc   a, d    ; A = A+L+H+carry 
0bbb 93			    sub   e       ; A = H+carry 
0bbc 57			    ld    d, a    ; H = H+carry 
0bbd c9			ret 
0bbe			 
0bbe			 
0bbe			addatobc: 
0bbe 81			    add   a, c    ; A = A+L 
0bbf 4f			    ld    c, a    ; L = A+L 
0bc0 88			    adc   a, b    ; A = A+L+H+carry 
0bc1 91			    sub   c       ; A = H+carry 
0bc2 47			    ld    b, a    ; H = H+carry 
0bc3 c9			ret 
0bc4			 
0bc4			subafromhl: 
0bc4			   ; If A=0 do nothing 
0bc4			    ; Otherwise flip A's sign. Since 
0bc4			    ; the upper byte becomes -1, also 
0bc4			    ; substract 1 from H. 
0bc4 ed 44		    neg 
0bc6 ca cf 0b		    jp    z, Skip 
0bc9 25			    dec   h 
0bca			     
0bca			    ; Now add the low byte as usual 
0bca			    ; Two's complement takes care of 
0bca			    ; ensuring the result is correct 
0bca 85			    add   a, l 
0bcb 6f			    ld    l, a 
0bcc 8c			    adc   a, h 
0bcd 95			    sub   l 
0bce 67			    ld    h, a 
0bcf			Skip: 
0bcf c9				ret 
0bd0			 
0bd0			 
0bd0			; compare hl and de 
0bd0			; returns:  
0bd0			; if hl = de, z=1, s=0, c0=0 
0bd0			; if hl > de, z=0, s=0, c=0 
0bd0			; if hl < de, z=0, s=1, c=1 
0bd0			cmp16:	 
0bd0 b7				or a 
0bd1 ed 52			sbc hl,de 
0bd3 e0				ret po 
0bd4 7c				ld a,h 
0bd5 1f				rra 
0bd6 ee 40			xor 01000000B 
0bd8 37				scf 
0bd9 8f				adc a,a 
0bda c9				ret 
0bdb			 
0bdb			 
0bdb			; test if hl contains zero   - A is destroyed 
0bdb			 
0bdb			ishlzero:    
0bdb b7				or a     ; reset flags 
0bdc 7c				ld a, h 
0bdd b5				or l        	 
0bde			 
0bde c9				ret 
0bdf			 
0bdf			 
0bdf			 
0bdf			 
0bdf			if FORTH_ENABLE_FLOATMATH 
0bdf			;include "float/bbcmath.z80" 
0bdf			include "float/lpfpcalc.asm" 
0bdf			endif 
0bdf			 
0bdf			 
0bdf			; eof 
0bdf			 
# End of file firmware_maths.asm
0bdf			include "firmware_strings.asm"   ; string handling  
0bdf			 
0bdf			 
0bdf			; TODO string len 
0bdf			; input text string, end on cr with zero term 
0bdf			; a offset into frame buffer to start prompt 
0bdf			; d is max length 
0bdf			; e is display size TODO 
0bdf			; c is current cursor position 
0bdf			; hl is ptr to where string will be stored 
0bdf			 
0bdf			 
0bdf			; TODO check limit of buffer for new inserts 
0bdf			; TODO check insert does not push beyond buffer 
0bdf			; TODO scroll in a limited display area 
0bdf			; TODO scroll whole screen on page wrap 
0bdf			 
0bdf			 
0bdf			; TODO handle KEY_PREVWORD 
0bdf			; TODO handle KEY_NEXTWORD 
0bdf			; TODO handle KEY_HOME 
0bdf			; TODO handle KEY_END 
0bdf			; TODO use LCD cursor? 
0bdf			 
0bdf 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0be2 81					add c 
0be3 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0be6 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0be9 79					ld a, c 
0bea cd b2 0b				call addatohl 
0bed 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0bf0 7a					ld a,d 
0bf1 32 75 ee			        ld (input_size), a       ; save length of input area 
0bf4 79					ld a, c 
0bf5 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0bf8 7b					ld a,e 
0bf9 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0bfc					 
0bfc					 
0bfc			 
0bfc			;		ld a,(input_ptr) 
0bfc			;		ld (input_under_cursor),a 	; save what is under the cursor 
0bfc			 
0bfc			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0bfc					; init cursor shape if not set by the cin routines 
0bfc 21 d3 eb				ld hl, cursor_shape 
0bff 3e ff				ld a, 255 
0c01 77					ld (hl), a 
0c02 23					inc hl 
0c03 3e 00				ld a, 0 
0c05 77					ld (hl), a 
0c06			 
0c06 3e 0f				ld a, CUR_BLINK_RATE 
0c08 32 6f ee				ld (input_cur_flash), a 
0c0b 3e 01				ld a, 1 
0c0d 32 6e ee				ld (input_cur_onoff),a 
0c10			 
0c10			;	if DEBUG_INPUT 
0c10			;		push af 
0c10			;		ld a, 'I' 
0c10			;		ld (debug_mark),a 
0c10			;		pop af 
0c10			;		CALLMONITOR 
0c10			;	endif 
0c10			.is1:		; main entry loop 
0c10			 
0c10			 
0c10			 
0c10					; pause 1ms 
0c10			 
0c10 3e 01				ld a, 1 
0c12 cd df 08				call aDelayInMS 
0c15			 
0c15					; dec flash counter 
0c15 3a 6f ee				ld a, (input_cur_flash) 
0c18 3d					dec a 
0c19 32 6f ee				ld (input_cur_flash), a 
0c1c fe 00				cp 0 
0c1e 20 0d				jr nz, .nochgstate 
0c20			 
0c20			 
0c20					; change state 
0c20 3a 6e ee				ld a,(input_cur_onoff) 
0c23 ed 44				neg 
0c25 32 6e ee				ld (input_cur_onoff),a 
0c28			 
0c28			 
0c28					; reset on change of state 
0c28 3e 0f				ld a, CUR_BLINK_RATE 
0c2a 32 6f ee				ld (input_cur_flash), a 
0c2d			 
0c2d			.nochgstate: 
0c2d					 
0c2d					 
0c2d			 
0c2d					; display cursor  
0c2d			 
0c2d			;		ld hl, (input_start) 
0c2d			;		ld a, (input_cursor) 
0c2d			;		call addatohl 
0c2d			 
0c2d					; get char under cursor and replace with cursor 
0c2d 2a 78 ee		ld hl, (input_ptr) 
0c30			;		ld a, (hl) 
0c30			;		ld (input_under_cursor),a 
0c30			;		ld a, '_' 
0c30			;		ld (hl), a 
0c30			 
0c30					; display string 
0c30			 
0c30 ed 5b 76 ee			ld de, (input_start) 
0c34 3a 73 ee				ld a, (input_at_pos) 
0c37 cd 98 09				call str_at_display 
0c3a			;	        call update_display 
0c3a			 
0c3a					; find place to put the cursor 
0c3a			;		add h 
0c3a			;		ld l, display_row_1 
0c3a			;		sub l 
0c3a			; (input_at_pos) 
0c3a					;ld c, a 
0c3a			;		ld a, (input_cursor) 
0c3a			;		ld l, (input_at_pos) 
0c3a			;		;ld b, h 
0c3a			;		add l 
0c3a			;		ld (input_at_cursor),a 
0c3a					;ld l,h 
0c3a			 
0c3a			;		ld h, 0 
0c3a			;		ld l,(input_at_pos) 
0c3a			;		ld a, (input_cursor) 
0c3a			;		call addatohl 
0c3a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c3a			;		call subafromhl 
0c3a			;		ld a,l 
0c3a			;		ld (input_at_cursor), a 
0c3a			 
0c3a				if DEBUG_INPUT 
0c3a					ld a, (hardware_diag) 
0c3a					cp 0 
0c3a					jr z, .skip_input_diag 
0c3a			 
0c3a					ld a,(input_at_pos) 
0c3a					ld hl, LFSRSeed 
0c3a					call hexout 
0c3a					ld a, (input_cursor) 
0c3a					ld hl, LFSRSeed+2 
0c3a					call hexout 
0c3a					ld a,(input_at_cursor) 
0c3a					ld hl, LFSRSeed+4 
0c3a					call hexout 
0c3a			 
0c3a					ld a,(input_cur_onoff) 
0c3a					ld hl, LFSRSeed+6 
0c3a					call hexout 
0c3a			 
0c3a					ld a,(input_cur_flash) 
0c3a					ld hl, LFSRSeed+8 
0c3a					call hexout 
0c3a			 
0c3a					ld a,(input_len) 
0c3a					ld hl, LFSRSeed+10 
0c3a					call hexout 
0c3a					ld hl, LFSRSeed+12 
0c3a					ld a, 0 
0c3a					ld (hl),a 
0c3a					ld a, display_row_4 
0c3a					ld de, LFSRSeed 
0c3a					call str_at_display 
0c3a					.skip_input_diag: 
0c3a				endif 
0c3a			 
0c3a					; decide on if we are showing the cursor this time round 
0c3a			 
0c3a 3a 6e ee				ld a, (input_cur_onoff) 
0c3d fe ff				cp 255 
0c3f 28 13				jr z, .skipcur 
0c41			 
0c41			 
0c41 3a 71 ee				ld a,(input_at_cursor) 
0c44 11 d3 eb				ld de, cursor_shape 
0c47 cd 98 09				call str_at_display 
0c4a			 
0c4a					; save length of current input string 
0c4a 2a 76 ee				ld hl, (input_start) 
0c4d cd 10 10				call strlenz 
0c50 7d					ld a,l 
0c51 32 69 ee				ld (input_len),a 
0c54			 
0c54			.skipcur: 
0c54			 
0c54 cd a8 09			        call update_display 
0c57					 
0c57			 
0c57			 
0c57					; wait 
0c57				 
0c57					; TODO loop without wait to flash the cursor and char under cursor	 
0c57 cd be 59				call cin    ; _wait 
0c5a			 
0c5a fe 00				cp 0 
0c5c ca 10 0c				jp z, .is1 
0c5f			 
0c5f					; get ptr to char to input into 
0c5f			 
0c5f 4f					ld c,a 
0c60 2a 76 ee				ld hl, (input_start) 
0c63 3a 64 ee				ld a, (input_cursor) 
0c66 cd b2 0b				call addatohl 
0c69 22 78 ee				ld (input_ptr), hl 
0c6c 79					ld a,c 
0c6d			 
0c6d					; replace char under cursor 
0c6d			 
0c6d			;		ld hl, (input_ptr) 
0c6d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c6d			;		ld (hl), a 
0c6d			 
0c6d			;	if DEBUG_INPUT 
0c6d			;		push af 
0c6d			;		ld a, 'i' 
0c6d			;		ld (debug_mark),a 
0c6d			;		pop af 
0c6d			;		CALLMONITOR 
0c6d			;	endif 
0c6d fe 0e				cp KEY_HOME 
0c6f 20 0e				jr nz, .iske 
0c71			 
0c71 3a 73 ee				ld a, (input_at_pos) 
0c74 32 71 ee				ld (input_at_cursor),a 
0c77 3e 00				ld a, 0 
0c79 32 64 ee				ld (input_cursor), a 
0c7c c3 10 0c				jp .is1 
0c7f					 
0c7f fe 0f		.iske:		cp KEY_END 
0c81 20 03				jr nz, .isknw 
0c83 c3 10 0c				jp .is1 
0c86			 
0c86 fe 06		.isknw:		cp KEY_NEXTWORD 
0c88 20 1b				jr nz, .iskpw 
0c8a			 
0c8a 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0c8d 7e					ld a,(hl)	 
0c8e fe 00				cp 0 
0c90 ca 10 0c				jp z, .is1    ; end of string 
0c93 fe 20				cp ' ' 
0c95 ca 10 0c				jp z, .is1    ; end of word 
0c98 23					inc hl 
0c99 22 78 ee				ld (input_ptr), hl 
0c9c 3a 71 ee				ld a, (input_at_cursor) 
0c9f 3c					inc a 
0ca0 32 71 ee				ld (input_at_cursor), a 
0ca3 18 e5				jr .isknwm 
0ca5			 
0ca5 fe 07		.iskpw:		cp KEY_PREVWORD 
0ca7 20 1b				jr nz, .iskl 
0ca9			.iskpwm:	 
0ca9 2a 78 ee				ld hl, (input_ptr) 
0cac 7e					ld a,(hl)	 
0cad fe 00				cp 0  
0caf ca 10 0c				jp z, .is1    ; end of string 
0cb2 fe 20				cp ' ' 
0cb4 ca 10 0c				jp z, .is1    ; end of word 
0cb7 2b					dec hl 
0cb8 22 78 ee				ld (input_ptr), hl 
0cbb 3a 71 ee				ld a, (input_at_cursor) 
0cbe 3d					dec a 
0cbf 32 71 ee				ld (input_at_cursor), a 
0cc2 18 e5				jr .iskpwm 
0cc4			 
0cc4			 
0cc4 fe 0b		.iskl:		cp KEY_LEFT 
0cc6 20 27				jr nz, .isk1 
0cc8			 
0cc8 3a 64 ee				ld a, (input_cursor) 
0ccb			 
0ccb fe 00				cp 0 
0ccd ca 10 0c				jp z, .is1 		; at start of line to ignore  
0cd0			 
0cd0 3d					dec  a 		; TODO check underflow 
0cd1 32 64 ee				ld (input_cursor), a 
0cd4			 
0cd4 2a 78 ee				ld hl, (input_ptr) 
0cd7 2b					dec hl 
0cd8 22 78 ee				ld (input_ptr), hl 
0cdb					 
0cdb 3a 71 ee				ld a, (input_at_cursor) 
0cde 3d					dec a 
0cdf 32 71 ee				ld (input_at_cursor), a 
0ce2			 
0ce2 3e 01				ld a, 1		; show cursor moving 
0ce4 32 6e ee				ld (input_cur_onoff),a 
0ce7 3e 0f				ld a, CUR_BLINK_RATE 
0ce9 32 6f ee				ld (input_cur_flash), a 
0cec			 
0cec c3 10 0c				jp .is1 
0cef			 
0cef fe 0c		.isk1:		cp KEY_RIGHT 
0cf1 20 2a				jr nz, .isk2 
0cf3			 
0cf3 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0cf6 5f					ld e,a 
0cf7 3a 64 ee				ld a, (input_cursor) 
0cfa bb					cp e 
0cfb ca 10 0c				jp z, .is1		; at the end of string so dont go right 
0cfe			 
0cfe 3c					inc  a 		; TODO check overflow 
0cff 32 64 ee				ld (input_cursor), a 
0d02			 
0d02 3a 71 ee				ld a, (input_at_cursor) 
0d05 3c					inc a 
0d06 32 71 ee				ld (input_at_cursor), a 
0d09			 
0d09 2a 78 ee				ld hl, (input_ptr) 
0d0c 23					inc hl 
0d0d 22 78 ee				ld (input_ptr), hl 
0d10			 
0d10 3e 01				ld a, 1		; show cursor moving 
0d12 32 6e ee				ld (input_cur_onoff),a 
0d15 3e 0f				ld a, CUR_BLINK_RATE 
0d17 32 6f ee				ld (input_cur_flash), a 
0d1a			 
0d1a c3 10 0c				jp .is1 
0d1d			 
0d1d fe 05		.isk2:		cp KEY_UP 
0d1f			 
0d1f 20 26				jr nz, .isk3 
0d21			 
0d21					; swap last command with the current on 
0d21			 
0d21					; move cursor to start of string 
0d21 2a 76 ee				ld hl, (input_start) 
0d24 22 78 ee				ld (input_ptr), hl 
0d27			 
0d27 3a 73 ee				ld a, (input_at_pos) 
0d2a 32 71 ee				ld (input_at_cursor), a 
0d2d			 
0d2d 3e 00				ld a, 0 
0d2f 32 64 ee				ld (input_cursor), a 
0d32					 
0d32					; swap input and last command buffers 
0d32			 
0d32 21 87 e6				ld hl, os_cli_cmd 
0d35 11 86 e7				ld de, os_last_cmd 
0d38 06 ff				ld b, 255 
0d3a 7e			.swap1:		ld a, (hl) 
0d3b 4f					ld c,a 
0d3c 1a					ld a, (de) 
0d3d 77					ld (hl), a 
0d3e 79					ld a,c 
0d3f 12					ld (de),a 
0d40 23					inc hl 
0d41 13					inc de 
0d42 10 f6				djnz .swap1 
0d44			 
0d44			 
0d44			 
0d44			 
0d44			 
0d44 c3 10 0c				jp .is1 
0d47			 
0d47 fe 08		.isk3:		cp KEY_BS 
0d49 20 3c				jr nz, .isk4 
0d4b			 
0d4b 3a 64 ee				ld a, (input_cursor) 
0d4e			 
0d4e fe 00				cp 0 
0d50 ca 10 0c				jp z, .is1 		; at start of line to ignore  
0d53			 
0d53 3d					dec  a 		; TODO check underflow 
0d54 32 64 ee				ld (input_cursor), a 
0d57			 
0d57					; hl is source 
0d57					; de needs to be source - 1 
0d57			 
0d57			;		ld a, 0 
0d57			;		dec hl 
0d57			;		ld (hl), a 
0d57			 
0d57 2a 78 ee				ld hl, (input_ptr) 
0d5a 2b					dec hl 
0d5b 22 78 ee				ld (input_ptr), hl 
0d5e			 
0d5e					; shift all data 
0d5e			 
0d5e e5					push hl 
0d5f 23					inc hl 
0d60 d1					pop de 
0d61 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d64 4f					ld c,a 
0d65 06 00				ld b,0 
0d67 ed b0				ldir  
0d69			 
0d69			 
0d69			 
0d69			 
0d69 3a 71 ee				ld a, (input_at_cursor) 
0d6c 3d					dec a 
0d6d 32 71 ee				ld (input_at_cursor), a 
0d70			 
0d70			 
0d70 3e 01				ld a, 1		; show cursor moving 
0d72 32 6e ee				ld (input_cur_onoff),a 
0d75 3e 0f				ld a, CUR_BLINK_RATE 
0d77 32 6f ee				ld (input_cur_flash), a 
0d7a			 
0d7a					; remove char 
0d7a 3a 71 ee				ld a, (input_at_cursor) 
0d7d 3c					inc a 
0d7e 11 08 0e				ld de,.iblank 
0d81 cd 98 09				call str_at_display 
0d84			 
0d84 c3 10 0c				jp .is1 
0d87			 
0d87 fe 0d		.isk4:		cp KEY_CR 
0d89 28 6c				jr z, .endinput 
0d8b			 
0d8b					; else add the key press to the end 
0d8b			 
0d8b 4f					ld c, a			; save key pressed 
0d8c			 
0d8c 7e					ld a,(hl)		; get what is currently under char 
0d8d			 
0d8d fe 00				cp 0			; we are at the end of the string 
0d8f 20 2f				jr nz, .onchar 
0d91					 
0d91					; add a char to the end of the string 
0d91				 
0d91 71					ld (hl),c 
0d92 23					inc hl 
0d93			;		ld a,' ' 
0d93			;		ld (hl),a 
0d93			;		inc hl 
0d93 3e 00				ld a,0 
0d95 77					ld (hl),a 
0d96 2b					dec hl 
0d97			 
0d97 3a 64 ee				ld a, (input_cursor) 
0d9a 3c					inc a				; TODO check max string length and scroll  
0d9b 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0d9e							 
0d9e 3a 71 ee				ld a, (input_at_cursor) 
0da1 3c					inc a 
0da2 32 71 ee				ld (input_at_cursor), a 
0da5			 
0da5 2a 78 ee				ld hl, (input_ptr) 
0da8 23					inc hl 
0da9 22 78 ee				ld (input_ptr), hl 
0dac			 
0dac 2a 78 ee				ld hl, (input_ptr) 
0daf 23					inc hl 
0db0 22 78 ee				ld (input_ptr), hl 
0db3			;	if DEBUG_INPUT 
0db3			;		push af 
0db3			;		ld a, '+' 
0db3			;		ld (debug_mark),a 
0db3			;		pop af 
0db3			;		CALLMONITOR 
0db3			;	endif 
0db3 3e 01				ld a, 1		; show cursor moving 
0db5 32 6e ee				ld (input_cur_onoff),a 
0db8 3e 0f				ld a, CUR_BLINK_RATE 
0dba 32 6f ee				ld (input_cur_flash), a 
0dbd c3 10 0c				jp .is1 
0dc0					 
0dc0			 
0dc0			 
0dc0					; if on a char then insert 
0dc0			.onchar: 
0dc0			 
0dc0					; TODO over flow check: make sure insert does not blow out buffer 
0dc0			 
0dc0					; need to do some maths to use lddr 
0dc0			 
0dc0 e5					push hl   ; save char pos 
0dc1 c5					push bc 
0dc2			 
0dc2 2a 76 ee				ld hl, (input_start) 
0dc5 3a 69 ee				ld a, (input_len) 
0dc8 cd b2 0b				call addatohl  		; end of string 
0dcb 23					inc hl 
0dcc 23					inc hl		; past zero term 
0dcd e5					push hl 
0dce 23					inc hl 
0dcf e5					push hl  
0dd0			 
0dd0								; start and end of lddr set, now how much to move? 
0dd0			 
0dd0							 
0dd0 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0dd3 47					ld b,a 
0dd4 3a 69 ee				ld a,(input_len) 
0dd7 5f					ld e,a 
0dd8 90					sub b 
0dd9 3c					inc a		;?? 
0dda 3c					inc a		;?? 
0ddb 3c					inc a		;?? 
0ddc			 
0ddc 06 00				ld b,0 
0dde 4f					ld c,a 
0ddf			 
0ddf				if DEBUG_INPUT 
0ddf					push af 
0ddf					ld a, 'i' 
0ddf					ld (debug_mark),a 
0ddf					pop af 
0ddf			;		CALLMONITOR 
0ddf				endif 
0ddf d1					pop de 
0de0 e1					pop hl 
0de1				if DEBUG_INPUT 
0de1					push af 
0de1					ld a, 'I' 
0de1					ld (debug_mark),a 
0de1					pop af 
0de1			;		CALLMONITOR 
0de1				endif 
0de1 ed b8				lddr 
0de3				 
0de3			 
0de3			 
0de3					; TODO have a key for insert/overwrite mode???? 
0de3 c1					pop bc 
0de4 e1					pop hl 
0de5 71					ld (hl), c		; otherwise overwrite current char 
0de6					 
0de6			 
0de6			 
0de6			 
0de6 3a 64 ee				ld a, (input_cursor) 
0de9 3c					inc  a 		; TODO check overflow 
0dea 32 64 ee				ld (input_cursor), a 
0ded			 
0ded 3a 71 ee				ld a, (input_at_cursor) 
0df0 3c					inc a 
0df1 32 71 ee				ld (input_at_cursor), a 
0df4			 
0df4 c3 10 0c				jp .is1 
0df7			 
0df7			.endinput:	; TODO look for end of string 
0df7			 
0df7					; add trailing space for end of token 
0df7			 
0df7 2a 76 ee				ld hl, (input_start) 
0dfa 3a 69 ee				ld a,(input_len) 
0dfd cd b2 0b				call addatohl 
0e00 3e 20				ld a, ' ' 
0e02 77					ld (hl),a 
0e03					; TODO eof of parse marker 
0e03			 
0e03 23					inc hl 
0e04 3e 00				ld a, 0 
0e06 77					ld (hl),a 
0e07			 
0e07			 
0e07 c9					ret 
0e08			 
0e08 .. 00		.iblank: db " ",0 
0e0a			 
0e0a			 
0e0a 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0e0d 22 76 ee				ld (input_start), hl 
0e10 3e 01				ld a,1			; add cursor 
0e12 77					ld (hl),a 
0e13 23					inc hl 
0e14 3e 00				ld a,0 
0e16 77					ld (hl),a 
0e17 22 78 ee				ld (input_ptr), hl 
0e1a 7a					ld a,d 
0e1b 32 75 ee				ld (input_size), a 
0e1e 3e 00				ld a,0 
0e20 32 64 ee				ld (input_cursor),a 
0e23			.instr1:	 
0e23			 
0e23					; TODO do block cursor 
0e23					; TODO switch cursor depending on the modifer key 
0e23			 
0e23					; update cursor shape change on key hold 
0e23			 
0e23 2a 78 ee				ld hl, (input_ptr) 
0e26 2b					dec hl 
0e27 3a d3 eb				ld a,(cursor_shape) 
0e2a 77					ld (hl), a 
0e2b			 
0e2b					; display entered text 
0e2b 3a 73 ee				ld a,(input_at_pos) 
0e2e cd d3 58		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e31 ed 5b 76 ee	            	LD   de, (input_start) 
0e35 cd c8 58		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e38			 
0e38 cd be 59				call cin 
0e3b fe 00				cp 0 
0e3d 28 e4				jr z, .instr1 
0e3f			 
0e3f					; proecess keyboard controls first 
0e3f			 
0e3f 2a 78 ee				ld hl,(input_ptr) 
0e42			 
0e42 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e44 28 5a				jr z, .instrcr 
0e46			 
0e46 fe 08				cp KEY_BS 	; back space 
0e48 20 0f				jr nz, .instr2 
0e4a					; process back space 
0e4a			 
0e4a					; TODO stop back space if at start of string 
0e4a 2b					dec hl 
0e4b 2b					dec hl ; to over write cursor 
0e4c 3a d3 eb				ld a,(cursor_shape) 
0e4f					;ld a,0 
0e4f 77					ld (hl),a 
0e50 23					inc hl 
0e51 3e 20				ld a," " 
0e53 77					ld (hl),a 
0e54 22 78 ee				ld (input_ptr),hl 
0e57					 
0e57			 
0e57 18 ca				jr .instr1 
0e59			 
0e59 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e5b 20 06				jr nz, .instr3 
0e5d 2b					dec hl 
0e5e 22 78 ee				ld (input_ptr),hl 
0e61 18 c0				jr .instr1 
0e63				 
0e63 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e65 20 06				jr nz, .instr4 
0e67 23					inc hl 
0e68 22 78 ee				ld (input_ptr),hl 
0e6b 18 b6				jr .instr1 
0e6d			 
0e6d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e6f 20 06				jr nz, .instr5 
0e71 2b					dec hl 
0e72 22 78 ee				ld (input_ptr),hl 
0e75 18 ac				jr .instr1 
0e77			 
0e77 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e79 20 06				jr nz, .instr6 
0e7b 2b					dec hl 
0e7c 22 78 ee				ld (input_ptr),hl 
0e7f 18 a2				jr .instr1 
0e81 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e83 20 0b				jr nz, .instrnew 
0e85			 
0e85 21 60 e3			ld hl, scratch 
0e88 11 86 e7			ld de, os_last_cmd 
0e8b cd a9 0e			call strcpy 
0e8e 18 93				jr .instr1 
0e90			 
0e90			 
0e90			.instrnew:	; no special key pressed to see if we have room to store it 
0e90			 
0e90					; TODO do string size test 
0e90			 
0e90 2b					dec hl ; to over write cursor 
0e91 77					ld (hl),a 
0e92 23					inc hl 
0e93 3a d3 eb				ld a,(cursor_shape) 
0e96 77					ld (hl),a 
0e97 23					inc hl 
0e98 3e 00				ld a,0 
0e9a 77					ld (hl),a 
0e9b			 
0e9b 22 78 ee				ld (input_ptr),hl 
0e9e					 
0e9e 18 83				jr .instr1 
0ea0 2b			.instrcr:	dec hl		; remove cursor 
0ea1 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ea3 77					ld (hl),a 
0ea4 23					inc hl 
0ea5 3e 00				ld a,0 
0ea7 77					ld (hl),a 
0ea8			 
0ea8			 
0ea8					; if at end of line scroll up    
0ea8					; TODO detecting only end of line 4 for scroll up  
0ea8			 
0ea8					;ld   
0ea8			 
0ea8 c9					ret 
0ea9			 
0ea9			 
0ea9			; strcpy hl = dest, de source 
0ea9			 
0ea9 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0eaa b7			            OR   A              ;Null terminator? 
0eab c8			            RET  Z              ;Yes, so finished 
0eac 1a					ld a,(de) 
0ead 77					ld (hl),a 
0eae 13			            INC  DE             ;Point to next character 
0eaf 23					inc hl 
0eb0 18 f7		            JR   strcpy       ;Repeat 
0eb2 c9					ret 
0eb3			 
0eb3			 
0eb3			; TODO string_at  
0eb3			; pass string which starts with lcd offset address and then null term string 
0eb3			 
0eb3			; TODO string to dec 
0eb3			; TODO string to hex 
0eb3			; TODO byte to string hex 
0eb3			; TODO byte to string dec 
0eb3			 
0eb3			 
0eb3			 
0eb3			; from z80uartmonitor 
0eb3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eb3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0eb3			; pass hl for where to put the text 
0eb3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eb3 c5			hexout:	PUSH BC 
0eb4 f5					PUSH AF 
0eb5 47					LD B, A 
0eb6					; Upper nybble 
0eb6 cb 3f				SRL A 
0eb8 cb 3f				SRL A 
0eba cb 3f				SRL A 
0ebc cb 3f				SRL A 
0ebe cd ce 0e				CALL tohex 
0ec1 77					ld (hl),a 
0ec2 23					inc hl	 
0ec3					 
0ec3					; Lower nybble 
0ec3 78					LD A, B 
0ec4 e6 0f				AND 0FH 
0ec6 cd ce 0e				CALL tohex 
0ec9 77					ld (hl),a 
0eca 23					inc hl	 
0ecb					 
0ecb f1					POP AF 
0ecc c1					POP BC 
0ecd c9					RET 
0ece					 
0ece			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ece			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ece			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ece			tohex: 
0ece e5					PUSH HL 
0ecf d5					PUSH DE 
0ed0 16 00				LD D, 0 
0ed2 5f					LD E, A 
0ed3 21 db 0e				LD HL, .DATA 
0ed6 19					ADD HL, DE 
0ed7 7e					LD A, (HL) 
0ed8 d1					POP DE 
0ed9 e1					POP HL 
0eda c9					RET 
0edb			 
0edb			.DATA: 
0edb 30					DEFB	30h	; 0 
0edc 31					DEFB	31h	; 1 
0edd 32					DEFB	32h	; 2 
0ede 33					DEFB	33h	; 3 
0edf 34					DEFB	34h	; 4 
0ee0 35					DEFB	35h	; 5 
0ee1 36					DEFB	36h	; 6 
0ee2 37					DEFB	37h	; 7 
0ee3 38					DEFB	38h	; 8 
0ee4 39					DEFB	39h	; 9 
0ee5 41					DEFB	41h	; A 
0ee6 42					DEFB	42h	; B 
0ee7 43					DEFB	43h	; C 
0ee8 44					DEFB	44h	; D 
0ee9 45					DEFB	45h	; E 
0eea 46					DEFB	46h	; F 
0eeb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eeb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0eeb			;;    subtract $30, if result > 9 then subtract $7 more 
0eeb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eeb			atohex: 
0eeb d6 30				SUB $30 
0eed fe 0a				CP 10 
0eef f8					RET M		; If result negative it was 0-9 so we're done 
0ef0 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0ef2 c9					RET		 
0ef3			 
0ef3			 
0ef3			 
0ef3			 
0ef3			; Get 2 ASCII characters as hex byte from pointer in hl 
0ef3			 
0ef3			BYTERD: 
0ef3 16 00			LD	D,00h		;Set up 
0ef5 cd fd 0e			CALL	HEXCON		;Get byte and convert to hex 
0ef8 87				ADD	A,A		;First nibble so 
0ef9 87				ADD	A,A		;multiply by 16 
0efa 87				ADD	A,A		; 
0efb 87				ADD	A,A		; 
0efc 57				LD	D,A		;Save hi nibble in D 
0efd			HEXCON: 
0efd 7e				ld a, (hl)		;Get next chr 
0efe 23				inc hl 
0eff d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f01 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f03 38 02			JR	C,NALPHA	;If so miss next bit 
0f05 d6 07			SUB	007h		;Else convert alpha 
0f07			NALPHA: 
0f07 b2				OR	D		;Add hi nibble back 
0f08 c9				RET			; 
0f09			 
0f09			 
0f09			; 
0f09			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f09			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f09			; characters (0-9a-f) are accepted. 
0f09			; 
0f09			;get_word        push    af 
0f09			;                call    get_byte        ; Get the upper byte 
0f09			;                ld      h, a 
0f09			;                call    get_byte        ; Get the lower byte 
0f09			;                ld      l, a 
0f09			;                pop     af 
0f09			;                ret 
0f09			; 
0f09			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f09			; the routine get_nibble is used only valid characters are accepted - the  
0f09			; input routine only accepts characters 0-9a-f. 
0f09			; 
0f09 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f0a 7e					ld a,(hl) 
0f0b 23					inc hl 
0f0c cd 31 0f		                call    nibble2val      ; Get upper nibble 
0f0f cb 07		                rlc     a 
0f11 cb 07		                rlc     a 
0f13 cb 07		                rlc     a 
0f15 cb 07		                rlc     a 
0f17 47			                ld      b, a            ; Save upper four bits 
0f18 7e					ld a,(hl) 
0f19 cd 31 0f		                call    nibble2val      ; Get lower nibble 
0f1c b0			                or      b               ; Combine both nibbles 
0f1d c1			                pop     bc              ; Restore B (and C) 
0f1e c9			                ret 
0f1f			; 
0f1f			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f1f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f1f			; to the serial line interface. The lower 4 bits of A contain the value of  
0f1f			; that particular digit. 
0f1f			; 
0f1f			;get_nibble      ld a,(hl)           ; Read a character 
0f1f			;                call    to_upper        ; Convert to upper case 
0f1f			;                call    is_hex          ; Was it a hex digit? 
0f1f			;                jr      nc, get_nibble  ; No, get another character 
0f1f			 ;               call    nibble2val      ; Convert nibble to value 
0f1f			 ;               call    print_nibble 
0f1f			 ;               ret 
0f1f			; 
0f1f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f1f			; A valid hexadecimal digit is denoted by a set C flag. 
0f1f			; 
0f1f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f1f			;                ret     nc              ; Yes 
0f1f			;                cp      '0'             ; Less than '0'? 
0f1f			;                jr      nc, is_hex_1    ; No, continue 
0f1f			;                ccf                     ; Complement carry (i.e. clear it) 
0f1f			;                ret 
0f1f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f1f			;                ret     c               ; Yes 
0f1f			;                cp      'A'             ; Less than 'A'? 
0f1f			;                jr      nc, is_hex_2    ; No, continue 
0f1f			;                ccf                     ; Yes - clear carry and return 
0f1f			;                ret 
0f1f			;is_hex_2        scf                     ; Set carry 
0f1f			;                ret 
0f1f			; 
0f1f			; Convert a single character contained in A to upper case: 
0f1f			; 
0f1f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f21 d8			                ret     c 
0f22 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f24 d0			                ret     nc              ; Nothing to do, either 
0f25 e6 5f		                and     $5f             ; Convert to upper case 
0f27 c9			                ret 
0f28			 
0f28			 
0f28			to_lower: 
0f28			 
0f28			   ; if char is in [A-Z] make it lower case 
0f28			 
0f28			   ; enter : a = char 
0f28			   ; exit  : a = lower case char 
0f28			   ; uses  : af 
0f28			 
0f28 fe 41		   cp 'A' 
0f2a d8			   ret c 
0f2b			    
0f2b fe 5b		   cp 'Z'+1 
0f2d d0			   ret nc 
0f2e			    
0f2e f6 20		   or $20 
0f30 c9			   ret 
0f31			 
0f31			; 
0f31			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f31			; corresponding value in A. 
0f31			; 
0f31 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f33 38 02		                jr      c, nibble2val_1 ; Yes 
0f35 d6 07		                sub     7               ; Adjust for A-F 
0f37 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f39 e6 0f		                and     $f              ; Only return lower 4 bits 
0f3b c9			                ret 
0f3c			; 
0f3c			; Print_nibble prints a single hex nibble which is contained in the lower  
0f3c			; four bits of A: 
0f3c			; 
0f3c			;print_nibble    push    af              ; We won't destroy the contents of A 
0f3c			;                and     $f              ; Just in case... 
0f3c			;                add     a, '0'             ; If we have a digit we are done here. 
0f3c			;                cp      '9' + 1         ; Is the result > 9? 
0f3c			;                jr      c, print_nibble_1 
0f3c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f3c			;print_nibble_1  call    putc            ; Print the nibble and 
0f3c			;                pop     af              ; restore the original value of A 
0f3c			;                ret 
0f3c			;; 
0f3c			;; Send a CR/LF pair: 
0f3c			; 
0f3c			;crlf            push    af 
0f3c			;                ld      a, cr 
0f3c			;                call    putc 
0f3c			;                ld      a, lf 
0f3c			;                call    putc 
0f3c			;                pop     af 
0f3c			;                ret 
0f3c			; 
0f3c			; Print_word prints the four hex digits of a word to the serial line. The  
0f3c			; word is expected to be in HL. 
0f3c			; 
0f3c			;print_word      push    hl 
0f3c			;                push    af 
0f3c			;                ld      a, h 
0f3c			;                call    print_byte 
0f3c			;                ld      a, l 
0f3c			;                call    print_byte 
0f3c			;                pop     af 
0f3c			;                pop     hl 
0f3c			;                ret 
0f3c			; 
0f3c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f3c			; The byte to be printed is expected to be in A. 
0f3c			; 
0f3c			;print_byte      push    af              ; Save the contents of the registers 
0f3c			;                push    bc 
0f3c			;                ld      b, a 
0f3c			;                rrca 
0f3c			;                rrca 
0f3c			;                rrca 
0f3c			;                rrca 
0f3c			;                call    print_nibble    ; Print high nibble 
0f3c			;                ld      a, b 
0f3c			;                call    print_nibble    ; Print low nibble 
0f3c			;                pop     bc              ; Restore original register contents 
0f3c			;                pop     af 
0f3c			;                ret 
0f3c			 
0f3c			 
0f3c			 
0f3c			 
0f3c			 
0f3c			fourehexhl:  
0f3c 7e				ld a,(hl) 
0f3d cd eb 0e			call atohex 
0f40 cb 3f				SRL A 
0f42 cb 3f				SRL A 
0f44 cb 3f				SRL A 
0f46 cb 3f				SRL A 
0f48 47				ld b, a 
0f49 23				inc hl 
0f4a 7e				ld a,(hl) 
0f4b 23				inc hl 
0f4c cd eb 0e			call atohex 
0f4f 80				add b 
0f50 57				ld d,a 
0f51 7e				ld a,(hl) 
0f52 cd eb 0e			call atohex 
0f55 cb 3f				SRL A 
0f57 cb 3f				SRL A 
0f59 cb 3f				SRL A 
0f5b cb 3f				SRL A 
0f5d 47				ld b, a 
0f5e 23				inc hl 
0f5f 7e				ld a,(hl) 
0f60 23				inc hl 
0f61 cd eb 0e			call atohex 
0f64 80				add b 
0f65 5f				ld e, a 
0f66 d5				push de 
0f67 e1				pop hl 
0f68 c9				ret 
0f69			 
0f69			; pass hl. returns z set if the byte at hl is a digit 
0f69			;isdigithl:  
0f69			;	push bc 
0f69			;	ld a,(hl) 
0f69			;	cp ':' 
0f69			;	jr nc, .isdf 		; > 
0f69			;	cp '0' 
0f69			;	jr c, .isdf		; < 
0f69			; 
0f69			;	; TODO find a better way to set z 
0f69			; 
0f69			;	ld b,a 
0f69			;	cp b 
0f69			;	pop bc 
0f69			;	ret 
0f69			; 
0f69			;.isdf:	; not digit so clear z 
0f69			; 
0f69			;	; TODO find a better way to unset z 
0f69			; 
0f69			;	ld b,a 
0f69			;	inc b 
0f69			;	cp b 
0f69			; 
0f69			;	pop bc 
0f69			;	ret 
0f69				 
0f69				 
0f69			 
0f69			 
0f69			; pass hl as the four byte address to load 
0f69			 
0f69			get_word_hl:  
0f69 e5				push hl 
0f6a cd 09 0f			call get_byte 
0f6d				 
0f6d 47				ld b, a 
0f6e			 
0f6e e1				pop hl 
0f6f 23				inc hl 
0f70 23				inc hl 
0f71			 
0f71			; TODO not able to handle a-f  
0f71 7e				ld a,(hl) 
0f72			;	;cp ':' 
0f72			;	cp 'g' 
0f72			;	jr nc, .single_byte_hl 		; > 
0f72			;	cp 'G' 
0f72			;	jr nc, .single_byte_hl 		; > 
0f72			;	cp '0' 
0f72			;	jr c, .single_byte_hl		; < 
0f72			 
0f72				;call isdigithl 
0f72 fe 00			cp 0 
0f74 28 06			jr z, .single_byte_hl 
0f76			 
0f76			.getwhln:   ; hex word so get next byte 
0f76			 
0f76 cd 09 0f			call get_byte 
0f79 6f				ld l, a 
0f7a 60				ld h,b 
0f7b c9				ret 
0f7c 68			.single_byte_hl:   ld l,b 
0f7d 26 00				ld h,0 
0f7f c9					ret 
0f80			 
0f80			 
0f80			 
0f80			 
0f80 21 a3 16			ld hl,asc+1 
0f83			;	ld a, (hl) 
0f83			;	call nibble2val 
0f83 cd 09 0f			call get_byte 
0f86			 
0f86			;	call fourehexhl 
0f86 32 94 e3			ld (scratch+52),a 
0f89				 
0f89 21 92 e3			ld hl,scratch+50 
0f8c 22 83 e6			ld (os_cur_ptr),hl 
0f8f			 
0f8f c9				ret 
0f90			 
0f90			 
0f90			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0f90			 
0f90			; Decimal Unsigned Version 
0f90			 
0f90			;Number in a to decimal ASCII 
0f90			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0f90			;Example: display a=56 as "056" 
0f90			;input: a = number 
0f90			;Output: a=0,value of a in the screen 
0f90			;destroys af,bc (don't know about hl and de) 
0f90			DispAToASCII: 
0f90 0e 9c			ld	c,-100 
0f92 cd 9c 0f			call	.Na1 
0f95 0e f6			ld	c,-10 
0f97 cd 9c 0f			call	.Na1 
0f9a 0e ff			ld	c,-1 
0f9c 06 2f		.Na1:	ld	b,'0'-1 
0f9e 04			.Na2:	inc	b 
0f9f 81				add	a,c 
0fa0 38 fc			jr	c,.Na2 
0fa2 91				sub	c		;works as add 100/10/1 
0fa3 f5				push af		;safer than ld c,a 
0fa4 78				ld	a,b		;char is in b 
0fa5			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0fa5 f1				pop af		;safer than ld a,c 
0fa6 c9				ret 
0fa7			 
0fa7			; Decimal Signed Version 
0fa7			 
0fa7			; DispA 
0fa7			; -------------------------------------------------------------- 
0fa7			; Converts a signed integer value to a zero-terminated ASCII 
0fa7			; string representative of that value (using radix 10). 
0fa7			; -------------------------------------------------------------- 
0fa7			; INPUTS: 
0fa7			;     HL     Value to convert (two's complement integer). 
0fa7			;     DE     Base address of string destination. (pointer). 
0fa7			; -------------------------------------------------------------- 
0fa7			; OUTPUTS: 
0fa7			;     None 
0fa7			; -------------------------------------------------------------- 
0fa7			; REGISTERS/MEMORY DESTROYED 
0fa7			; AF HL 
0fa7			; -------------------------------------------------------------- 
0fa7			 
0fa7			;DispHLToASCII: 
0fa7			;   push    de 
0fa7			;   push    bc 
0fa7			; 
0fa7			;; Detect sign of HL. 
0fa7			;    bit    7, h 
0fa7			;    jr     z, ._DoConvert 
0fa7			; 
0fa7			;; HL is negative. Output '-' to string and negate HL. 
0fa7			;    ld     a, '-' 
0fa7			;    ld     (de), a 
0fa7			;    inc    de 
0fa7			; 
0fa7			;; Negate HL (using two's complement) 
0fa7			;    xor    a 
0fa7			;    sub    l 
0fa7			;    ld     l, a 
0fa7			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0fa7			;    sbc    a, h 
0fa7			;    ld     h, a 
0fa7			; 
0fa7			;; Convert HL to digit characters 
0fa7			;._DoConvert: 
0fa7			;    ld     b, 0     ; B will count character length of number 
0fa7			;-   ld     a, 10 
0fa7			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0fa7			;    push   af 
0fa7			;    inc    b 
0fa7			;    ld     a, h 
0fa7			;    or     l 
0fa7			;    jr     nz, - 
0fa7			; 
0fa7			;; Retrieve digits from stack 
0fa7			;-   pop    af 
0fa7			;    or     $30 
0fa7			;    ld     (de), a 
0fa7			;    inc    de 
0fa7			;    djnz   - 
0fa7			; 
0fa7			;; Terminate string with NULL 
0fa7			;    xor    a 
0fa7			;    ld     (de), a 
0fa7			; 
0fa7			;    pop    bc 
0fa7			;    pop    de 
0fa7			;    ret 
0fa7			 
0fa7			;Comments 
0fa7			; 
0fa7			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0fa7			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0fa7			;    Note that the output string will not be fixed-width. 
0fa7			; 
0fa7			;Example Usage 
0fa7			; 
0fa7			;    ld    hl, -1004 
0fa7			;    ld    de, OP1 
0fa7			;    call  DispA 
0fa7			;    ld    hl, OP1 
0fa7			;    syscall  PutS 
0fa7			 
0fa7			 
0fa7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fa7			 
0fa7			 
0fa7			;Converts an ASCII string to an unsigned 16-bit integer 
0fa7			;Quits when it reaches a non-decimal digit 
0fa7			 
0fa7			string_to_uint16: 
0fa7			atoui_16: 
0fa7			;Input: 
0fa7			;     DE points to the string 
0fa7			;Outputs: 
0fa7			;     HL is the result 
0fa7			;     A is the 8-bit value of the number 
0fa7			;     DE points to the byte after the number 
0fa7			;Destroys: 
0fa7			;     BC 
0fa7			;       if the string is non-empty, BC is HL/10 
0fa7			;Size:  24 bytes 
0fa7			;Speed: 42+d(104+{0,9}) 
0fa7			;       d is the number of digits in the number 
0fa7			;       max is 640 cycles for a 5 digit number 
0fa7			;Assuming no leading zeros: 
0fa7			;1 digit:  146cc 
0fa7			;2 digit:  250cc 
0fa7			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0fa7			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0fa7			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0fa7			;avg: 544.81158447265625cc (544+13297/16384) 
0fa7			;=============================================================== 
0fa7 21 00 00		  ld hl,0 
0faa			.u16a: 
0faa 1a			  ld a,(de) 
0fab d6 30		  sub 30h 
0fad fe 0a		  cp 10 
0faf d0			  ret nc 
0fb0 13			  inc de 
0fb1 44			  ld b,h 
0fb2 4d			  ld c,l 
0fb3 29			  add hl,hl 
0fb4 29			  add hl,hl 
0fb5 09			  add hl,bc 
0fb6 29			  add hl,hl 
0fb7 85			  add a,l 
0fb8 6f			  ld l,a 
0fb9 30 ef		  jr nc,.u16a 
0fbb 24			  inc h 
0fbc c3 aa 0f		  jp .u16a 
0fbf			 
0fbf			 
0fbf			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fbf			 
0fbf			;written by Zeda 
0fbf			;Converts a 16-bit unsigned integer to an ASCII string. 
0fbf			 
0fbf			uitoa_16: 
0fbf			;Input: 
0fbf			;   DE is the number to convert 
0fbf			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0fbf			;Output: 
0fbf			;   HL points to the null-terminated ASCII string 
0fbf			;      NOTE: This isn't necessarily the same as the input HL. 
0fbf d5			  push de 
0fc0 c5			  push bc 
0fc1 f5			  push af 
0fc2 eb			  ex de,hl 
0fc3			 
0fc3 01 f0 d8		  ld bc,-10000 
0fc6 3e 2f		  ld a,'0'-1 
0fc8 3c			  inc a 
0fc9 09			  add hl,bc  
0fca 38 fc		   jr c,$-2 
0fcc 12			  ld (de),a 
0fcd 13			  inc de 
0fce			 
0fce 01 e8 03		  ld bc,1000 
0fd1 3e 3a		  ld a,'9'+1 
0fd3 3d			  dec a  
0fd4 09			  add hl,bc  
0fd5 30 fc		   jr nc,$-2 
0fd7 12			  ld (de),a 
0fd8 13			  inc de 
0fd9			 
0fd9 01 9c ff		  ld bc,-100 
0fdc 3e 2f		  ld a,'0'-1 
0fde 3c			  inc a  
0fdf 09			  add hl,bc  
0fe0 38 fc		   jr c,$-2 
0fe2 12			  ld (de),a 
0fe3 13			  inc de 
0fe4			 
0fe4 7d			  ld a,l 
0fe5 26 3a		  ld h,'9'+1 
0fe7 25			  dec h  
0fe8 c6 0a		  add a,10  
0fea 30 fb		   jr nc,$-3 
0fec c6 30		  add a,'0' 
0fee eb			  ex de,hl 
0fef 72			  ld (hl),d 
0ff0 23			  inc hl 
0ff1 77			  ld (hl),a 
0ff2 23			  inc hl 
0ff3 36 00		  ld (hl),0 
0ff5			 
0ff5			;Now strip the leading zeros 
0ff5 0e fa		  ld c,-6 
0ff7 09			  add hl,bc 
0ff8 3e 30		  ld a,'0' 
0ffa 23			  inc hl  
0ffb be			  cp (hl)  
0ffc 28 fc		  jr z,$-2 
0ffe			 
0ffe			;Make sure that the string is non-empty! 
0ffe 7e			  ld a,(hl) 
0fff b7			  or a 
1000 20 01		  jr nz,.atoub 
1002 2b			  dec hl 
1003			.atoub: 
1003			 
1003 f1			  pop af 
1004 c1			  pop bc 
1005 d1			  pop de 
1006 c9			  ret 
1007			 
1007			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1007			 
1007			toUpper: 
1007			;A is the char. 
1007			;If A is a lowercase letter, this sets it to the matching uppercase 
1007			;18cc or 30cc or 41cc 
1007			;avg: 26.75cc 
1007 fe 61		  cp 'a' 
1009 d8			  ret c 
100a fe 7b		  cp 'z'+1 
100c d0			  ret nc 
100d d6 20		  sub 'a'-'A' 
100f c9			  ret 
1010			 
1010			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1010			 
1010			; String Length 
1010			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1010			 
1010			; Get the length of the null-terminated string starting at $8000 hl 
1010			;    LD     HL, $8000 
1010			 
1010			strlenz: 
1010			 
1010 af			    XOR    A               ; Zero is the value we are looking for. 
1011 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1012 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1013			                           ; 65, 536 bytes (the entire addressable memory space). 
1013 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1015			 
1015			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1015 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1016 6f			    LD     L, A             ; number of bytes 
1017 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1019 2b			    DEC    HL              ; Compensate for null. 
101a c9				ret 
101b			 
101b			; Get the length of the A terminated string starting at $8000 hl 
101b			;    LD     HL, $8000 
101b			 
101b			strlent: 
101b			 
101b			                  ; A is the value we are looking for. 
101b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
101d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
101f			                           ; 65, 536 bytes (the entire addressable memory space). 
101f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1021			 
1021			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1021 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1023 2e 00		    LD     L, 0             ; number of bytes 
1025 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1027 2b			    DEC    HL              ; Compensate for null. 
1028 c9				ret 
1029			 
1029			 
1029			;Comparing Strings 
1029			 
1029			;IN    HL     Address of string1. 
1029			;      DE     Address of string2. 
1029			 
1029			; doc given but wrong??? 
1029			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1029			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1029			; tested 
1029			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1029			 
1029			strcmp_old: 
1029 e5			    PUSH   HL 
102a d5			    PUSH   DE 
102b			 
102b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
102c be			    CP     (HL)            ; (want to minimize work). 
102d 38 01		    JR     C, Str1IsBigger 
102f 7e			    LD     A, (HL) 
1030			 
1030			Str1IsBigger: 
1030 4f			    LD     C, A             ; Put length in BC 
1031 06 00		    LD     B, 0 
1033 13			    INC    DE              ; Increment pointers to meat of string. 
1034 23			    INC    HL 
1035			 
1035			CmpLoop: 
1035 1a			    LD     A, (DE)          ; Compare bytes. 
1036 ed a1		    CPI 
1038 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
103a 13			    INC    DE              ; Update pointer. 
103b ea 35 10		    JP     PE, CmpLoop 
103e			 
103e d1			    POP    DE 
103f e1			    POP    HL 
1040 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1041 be			    CP     (HL) 
1042 c9			    RET 
1043			 
1043			NoMatch: 
1043 2b			    DEC    HL 
1044 be			    CP     (HL)            ; Compare again to affect carry. 
1045 d1			    POP    DE 
1046 e1			    POP    HL 
1047 c9			    RET 
1048			 
1048			;; test strmp 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str2 
1048			;call strcmp 
1048			;jr z, .z1 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "NZ1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.z1: 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "ZZ1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str1 
1048			;call strcmp 
1048			;jr z, .z2 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "NZ2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.z2: 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "ZZ2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str2 
1048			;call strcmp 
1048			;jr c, .c1 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "Nc1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.c1: 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "cc1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str1 
1048			;call strcmp 
1048			;jr c, .c2 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "Nc2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.c2: 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "cc2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;	NEXTW 
1048			;.str1:   db "string1",0 
1048			;.str2:   db "string2",0 
1048			 
1048			; only care about direct match or not 
1048			; hl and de strings 
1048			; zero set if the same 
1048			 
1048			strcmp: 
1048 1a				ld a, (de) 
1049 be				cp (hl) 
104a 28 02			jr z, .ssame 
104c b7				or a 
104d c9				ret 
104e			 
104e			.ssame:  
104e fe 00			cp 0 
1050 c8				ret z 
1051			 
1051 23				inc hl 
1052 13				inc de 
1053 18 f3			jr strcmp 
1055				 
1055				 
1055			 
1055			 
1055			 
1055			 
1055			; eof 
1055			 
1055			 
1055			 
1055			 
1055			 
1055			 
# End of file firmware_strings.asm
1055			include "firmware_memory.asm"   ; malloc and free  
1055			 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055			.mallocsize: db "Wants malloc >256",0 
1055			.mallocasize: db "MALLOC gives >256",0 
1055			.malloczero: db "MALLOC gives zero",0 
1055			 
1055			malloc_guard_zerolen: 
1055				push hl 
1055				push de 
1055				push af 
1055			 
1055				ld de, 0 
1055			        call cmp16 
1055				jr nz, .lowalloz 
1055			 
1055				push hl 
1055				push de 
1055					ld hl, display_fb0 
1055					ld (display_fb_active), hl 
1055				call clear_display 
1055				ld a, 0 
1055				ld de, .malloczero 
1055				call str_at_display 
1055				call update_display 
1055				call delay1s 
1055				call delay1s 
1055				ld a, 0 
1055				ld (os_view_disable), a 
1055			 
1055				pop de 
1055				pop hl 
1055			 
1055				 
1055			 
1055				CALLMONITOR 
1055			.lowalloz: 
1055			 
1055			 
1055				pop af 
1055				pop de 
1055				pop hl 
1055			ret 
1055			 
1055			malloc_guard_entry: 
1055				push hl 
1055				push de 
1055				push af 
1055			 
1055			 	or a      ;clear carry flag 
1055				push hl 
1055				ld de, 255 
1055				sbc hl, de 
1055				jr c, .lowalloc 
1055			 
1055				push de 
1055					ld hl, display_fb0 
1055					ld (display_fb_active), hl 
1055				call clear_display 
1055				ld a, 0 
1055				ld de, .mallocsize 
1055				call str_at_display 
1055				call update_display 
1055				call delay1s 
1055				call delay1s 
1055				ld a, 0 
1055				ld (os_view_disable), a 
1055			 
1055				pop de 
1055				pop hl 
1055			 
1055				 
1055			 
1055				CALLMONITOR 
1055				jr .lowdone 
1055			.lowalloc: 
1055			 
1055			 
1055				pop hl 
1055			.lowdone:	pop af 
1055				pop de 
1055				pop hl 
1055			ret 
1055			 
1055			malloc_guard_exit: 
1055				push hl 
1055				push de 
1055				push af 
1055			 
1055			 	or a      ;clear carry flag 
1055				push hl 
1055				ld de, 255 
1055				sbc hl, de 
1055				jr c, .lowallocx 
1055			 
1055				push de 
1055					ld hl, display_fb0 
1055					ld (display_fb_active), hl 
1055				call clear_display 
1055				ld a, 0 
1055				ld de, .mallocasize 
1055				call str_at_display 
1055				call update_display 
1055				call delay1s 
1055				call delay1s 
1055				ld a, 0 
1055				ld (os_view_disable), a 
1055				pop de 
1055				pop hl 
1055			 
1055				CALLMONITOR 
1055				jr .lowdonex 
1055			.lowallocx: 
1055			 
1055				pop hl 
1055			.lowdonex:	pop af 
1055				pop de 
1055				pop hl 
1055			ret 
1055			endif 
1055			 
1055			if MALLOC_2 
1055			; Z80 Malloc and Free Functions 
1055			 
1055			; Malloc Function: 
1055			; Input: 
1055			;   HL: Size of block to allocate 
1055			; Output: 
1055			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1055			 
1055			malloc: 
1055				 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055			call malloc_guard_entry 
1055			endif 
1055			 
1055			 
1055			 
1055			 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "mal" 
1055						CALLMONITOR 
1055					endif 
1055			    push af            ; Save AF register 
1055			    ld a, l            ; Load low byte of size into A 
1055			    or h               ; Check if size is zero 
1055			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1055			 
1055			    ; Allocate memory 
1055			    ld hl, (heap_start) ; Load start of heap into HL 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "ma1" 
1055						CALLMONITOR 
1055					endif 
1055			    call malloc_internal ; Call internal malloc function 
1055			    pop af             ; Restore AF register 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret                ; Return 
1055			 
1055			; Free Function: 
1055			; Input: 
1055			;   HL: Pointer to memory block to free 
1055			; Output: 
1055			;   None 
1055			 
1055			free: 
1055			    push af            ; Save AF register 
1055			    ld a, l            ; Load low byte of pointer into A 
1055			    or h               ; Check if pointer is NULL 
1055			    jp z, free_exit    ; If pointer is NULL, exit 
1055			 
1055			    ; Free memory 
1055			    ld hl, (heap_start) ; Load start of heap into HL 
1055			    call free_internal  ; Call internal free function 
1055			    pop af             ; Restore AF register 
1055			    ret                ; Return 
1055			 
1055			; Internal Malloc Function: 
1055			; Input: 
1055			;   HL: Size of block to allocate 
1055			; Output: 
1055			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1055			 
1055			malloc_internal: 
1055			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1055			    add hl, bc         ; Add management overhead to requested size 
1055			    ex de, hl          ; Save total size in DE, and keep it in HL 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "ma2" 
1055						CALLMONITOR 
1055					endif 
1055			 
1055			    ; Search for free memory block 
1055			    ld de, (heap_end)  ; Load end of heap into DE 
1055			    ld bc, 0           ; Initialize counter 
1055			 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "ma2" 
1055						CALLMONITOR 
1055					endif 
1055			malloc_search_loop: 
1055			    ; Check if current block is free 
1055			    ld a, (hl)         ; Load current block's status (free or used) 
1055			    cp 0               ; Compare with zero (free) 
1055			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1055			 
1055			    ; Check if current block is large enough 
1055			    ld a, (hl+1)       ; Load high byte of block size 
1055			    cp l               ; Compare with low byte of requested size 
1055			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1055			 
1055			    ld a, (hl+2)       ; Load low byte of block size 
1055			    cp h               ; Compare with high byte of requested size 
1055			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1055			 
1055			    ; Mark block as used 
1055			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1055			 
1055			    ; Calculate remaining space in block 
1055			    ld bc, 0           ; Clear BC 
1055			    add hl, bc         ; Increment HL to point to start of data block 
1055			    add hl, de         ; HL = HL + DE (total size) 
1055			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1055			    add hl, bc         ; Add management overhead to start of data block 
1055			 
1055			    ; Save pointer to allocated block in HL 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055						DMARK "ma5" 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret 
1055			 
1055			malloc_skip_block_check: 
1055			    ; Move to the next block 
1055			    ld bc, 3           ; Size of management overhead 
1055			    add hl, bc         ; Move to the next block 
1055			    inc de             ; Increment counter 
1055			 
1055			    ; Check if we have reached the end of heap 
1055			    ld a, e            ; Load low byte of heap end address 
1055			    cp (hl)            ; Compare with low byte of current address 
1055			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1055			    ld a, d            ; Load high byte of heap end address 
1055			    cp 0               ; Check if it's zero (end of memory) 
1055			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1055			 
1055			    ; If we reached here, allocation failed 
1055			    xor a              ; Set result to NULL 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055						DMARK "ma6" 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret 
1055			malloc_exit: 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055						DMARK "ma7" 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret 
1055			 
1055			; Internal Free Function: 
1055			; Input: 
1055			;   HL: Pointer to memory block to free 
1055			; Output: 
1055			;   None 
1055			 
1055			free_internal: 
1055			    ld de, (heap_start) ; Load start of heap into DE 
1055			    ld bc, 0            ; Initialize counter 
1055			 
1055			free_search_loop: 
1055			    ; Check if current block contains the pointer 
1055			    ld a, l             ; Load low byte of pointer 
1055			    cp (hl+1)           ; Compare with high byte of current block's address 
1055			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1055			    ld a, h             ; Load high byte of pointer 
1055			    cp (hl+2)           ; Compare with low byte of current block's address 
1055			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1055			 
1055			    ; Mark block as free 
1055			    ld (hl), 0          ; Set status byte to indicate free block 
1055			    ret                 ; Return 
1055			 
1055			free_skip_block_check: 
1055			    ; Move to the next block 
1055			    ld bc, 3            ; Size of management overhead 
1055			    add hl, bc          ; Move to the next block 
1055			    inc de              ; Increment counter 
1055			 
1055			    ; Check if we have reached the end of heap 
1055			    ld a, e             ; Load low byte of heap end address 
1055			    cp (hl)             ; Compare with low byte of current address 
1055			    jr nz, free_search_loop  ; If not equal, continue searching 
1055			    ld a, d             ; Load high byte of heap end address 
1055			    cp 0                ; Check if it's zero (end of memory) 
1055			    jr nz, free_search_loop  ; If not zero, continue searching 
1055			 
1055			    ; If we reached here, pointer is not found in heap 
1055			    ret 
1055			 
1055			free_exit: 
1055			    ret                 ; Return 
1055			 
1055			; Define heap start and end addresses 
1055			;heap_start:    .dw 0xC000   ; Start of heap 
1055			;heap_end:      .dw 0xE000   ; End of heap 
1055			 
1055			endif 
1055			 
1055			 
1055			if MALLOC_1 
1055			 
1055			 
1055			 
1055			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1055			 
1055			;moved to firmware.asm 
1055			;heap_start        .equ  0x9000      ; Starting address of heap 
1055			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1055			 
1055			;      .org 0 
1055			;      jp    main 
1055			 
1055			 
1055			;      .org  0x100 
1055			;main: 
1055			;      ld    HL, 0x8100 
1055			;      ld    SP, HL 
1055			; 
1055			;      call  heap_init 
1055			; 
1055			;      ; Make some allocations 
1055			;      ld    HL, 12 
1055			;      call  malloc            ; Allocates 0x9004 
1055			; 
1055			;      ld    HL, 12 
1055			;      call  malloc            ; Allocates 0x9014 
1055			; 
1055			;      ld    HL, 12 
1055			;      call  malloc            ; Allocates 0x9024 
1055			; 
1055			;      ; Free some allocations 
1055			;      ld    HL, 0x9014 
1055			;      call  free 
1055			; 
1055			;      ld    HL, 0x9004 
1055			;      call  free 
1055			; 
1055			;      ld    HL, 0x9024 
1055			;      call  free 
1055			; 
1055			; 
1055			;      halt 
1055			 
1055			 
1055			;------------------------------------------------------------------------------ 
1055			;     heap_init                                                               : 
1055			;                                                                             : 
1055			; Description                                                                 : 
1055			;     Initialise the heap and make it ready for malloc and free operations.   : 
1055			;                                                                             : 
1055			;     The heap is maintained as a linked list, starting with an initial       : 
1055			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1055			;     the first free block in the heap. Each block then points to the next    : 
1055			;     free block within the heap, and the free list ends at the first block   : 
1055			;     with a null pointer to the next free block.                             : 
1055			;                                                                             : 
1055			; Parameters                                                                  : 
1055			;     Inputs are compile-time only. Two defines which specify the starting    : 
1055			;     address of the heap and its size are required, along with a memory      : 
1055			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1055			;     principally stores a pointer to the first free block in the heap.       : 
1055			;                                                                             : 
1055			; Returns                                                                     : 
1055			;     Nothing                                                                 : 
1055			;------------------------------------------------------------------------------ 
1055			heap_init: 
1055 e5			      push  HL 
1056			 
1056			      ; Initialise free list struct 
1056 21 e6 59		      ld    HL, heap_start 
1059 22 e1 59		      ld    (free_list), HL 
105c 21 00 00		      ld    HL, 0 
105f 22 e3 59		      ld    (free_list+2), HL 
1062			 
1062			      ; Insert first free block at bottom of heap, consumes entire heap 
1062 21 42 e3		      ld    HL, heap_start+heap_size-4 
1065 22 e6 59		      ld    (heap_start), HL        ; Next block (end of free list) 
1068 21 5c 89		      ld    HL, heap_size-4 
106b 22 e8 59		      ld    (heap_start+2), HL      ; Block size 
106e			 
106e			      ; Insert end of free list block at top of heap - two null words will 
106e			      ; terminate the free list 
106e 21 00 00		      ld    HL, 0 
1071 22 44 e3		      ld    (heap_start+heap_size-2), HL 
1074 22 42 e3		      ld    (heap_start+heap_size-4), HL 
1077			 
1077 e1			      pop   HL 
1078			 
1078 c9			      ret 
1079			 
1079			 
1079			;------------------------------------------------------------------------------ 
1079			;     malloc                                                                  : 
1079			;                                                                             : 
1079			; Description                                                                 : 
1079			;     Allocates the wanted space from the heap and returns the address of the : 
1079			;     first useable byte of the allocation.                                   : 
1079			;                                                                             : 
1079			;     Allocations can happen in one of two ways:                              : 
1079			;                                                                             : 
1079			;     1. A free block may be found which is the exact size wanted. In this    : 
1079			;        case the block is removed from the free list and retuedn to the      : 
1079			;        caller.                                                              : 
1079			;     2. A free block may be found which is larger than the size wanted. In   : 
1079			;        this case, the larger block is split into two. The first portion of  : 
1079			;        this block will become the requested space by the malloc call and    : 
1079			;        is returned to the caller. The second portion becomes a new free     : 
1079			;        block, and the free list is adjusted to maintain continuity via this : 
1079			;        newly created block.                                                 : 
1079			;                                                                             : 
1079			;     malloc does not set any initial value in the allocated space, the       : 
1079			;     caller is required to do this as required.                              : 
1079			;                                                                             : 
1079			;     This implementation of malloc uses the stack exclusively, and is        : 
1079			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1079			;     advisable to disable interrupts before calling malloc, and recommended  : 
1079			;     to avoid the use of malloc inside ISRs in general.                      : 
1079			;                                                                             : 
1079			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1079			;                                                                             : 
1079			; Parameters                                                                  : 
1079			;     HL  Number of bytes wanted                                              : 
1079			;                                                                             : 
1079			; Returns                                                                     : 
1079			;     HL  Address of the first useable byte of the allocation                 : 
1079			;                                                                             : 
1079			; Flags                                                                       : 
1079			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1079			;                                                                             : 
1079			; Stack frame                                                                 : 
1079			;       |             |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |     BC      |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |     DE      |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |     IX      |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |  prev_free  |                                                       : 
1079			;   +4  +-------------+                                                       : 
1079			;       |  this_free  |                                                       : 
1079			;   +2  +-------------+                                                       : 
1079			;       |  next_free  |                                                       : 
1079			;   +0  +-------------+                                                       : 
1079			;       |             |                                                       : 
1079			;                                                                             : 
1079			;------------------------------------------------------------------------------ 
1079			 
1079			 
1079			;malloc: 
1079			; 
1079			;	SAVESP ON 1 
1079			; 
1079			;	call malloc_code 
1079			; 
1079			;	CHECKSP ON 1 
1079			;	ret 
1079			 
1079			 
1079			malloc: 
1079 c5			      push  BC 
107a d5			      push  DE 
107b dd e5		      push  IX 
107d			if DEBUG_FORTH_MALLOC_HIGH 
107d			call malloc_guard_entry 
107d			endif 
107d			 
107d					if DEBUG_FORTH_MALLOC 
107d						DMARK "mal" 
107d						CALLMONITOR 
107d					endif 
107d 7c			      ld    A, H                    ; Exit if no space requested 
107e b5			      or    L 
107f ca 3e 11		      jp    Z, malloc_early_exit 
1082			 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			; 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			 
1082			 
1082			 
1082			 
1082					if DEBUG_FORTH_MALLOC 
1082						DMARK "maA" 
1082						CALLMONITOR 
1082					endif 
1082			      ; Set up stack frame 
1082 eb			      ex    DE, HL 
1083 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1086 39			      add   HL, SP 
1087 f9			      ld    SP, HL 
1088 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
108c dd 39		      add   IX, SP 
108e			 
108e			      ; Setup initial state 
108e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1091 19			      add   HL, DE 
1092			 
1092 44			      ld    B, H                    ; Move want to BC 
1093 4d			      ld    C, L 
1094			 
1094 21 e1 59		      ld    HL, free_list           ; Store prev_free ptr to stack 
1097 dd 75 04		      ld    (IX+4), L 
109a dd 74 05		      ld    (IX+5), H 
109d			 
109d 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
109e 23			      inc   HL 
109f 56			      ld    D, (HL) 
10a0 dd 73 02		      ld    (IX+2), E 
10a3 dd 72 03		      ld    (IX+3), D 
10a6 eb			      ex    DE, HL                  ; this_free ptr into HL 
10a7			 
10a7					if DEBUG_FORTH_MALLOC 
10a7						DMARK "maB" 
10a7						CALLMONITOR 
10a7					endif 
10a7			      ; Loop through free block list to find some space 
10a7			malloc_find_space: 
10a7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
10a8 23			      inc   HL 
10a9 56			      ld    D, (HL) 
10aa			 
10aa 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
10ab b3			      or    E 
10ac ca 38 11		      jp    Z, malloc_no_space 
10af			 
10af dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
10b2 dd 72 01		      ld    (IX+1), D 
10b5			 
10b5			      ; Does this block have enough space to make the allocation? 
10b5 23			      inc   HL                      ; Load free block size into DE 
10b6 5e			      ld    E, (HL) 
10b7 23			      inc   HL 
10b8 56			      ld    D, (HL) 
10b9			 
10b9 eb			      ex    DE, HL                  ; Check size of block against want 
10ba b7			      or    A                       ; Ensure carry flag clear 
10bb ed 42		      sbc   HL, BC 
10bd e5			      push  HL                      ; Store the result for later (new block size) 
10be			 
10be ca 0d 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
10c1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
10c3			 
10c3			      ; this_free block is not big enough, setup ptrs to test next free block 
10c3 e1			      pop   HL                      ; Discard previous result 
10c4			 
10c4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
10c7 dd 66 03		      ld    H, (IX+3) 
10ca dd 75 04		      ld    (IX+4), L 
10cd dd 74 05		      ld    (IX+5), H 
10d0			 
10d0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
10d3 dd 66 01		      ld    H, (IX+1) 
10d6 dd 75 02		      ld    (IX+2), L 
10d9 dd 74 03		      ld    (IX+3), H 
10dc			 
10dc					if DEBUG_FORTH_MALLOC 
10dc						DMARK "MA>" 
10dc						CALLMONITOR 
10dc					endif 
10dc 18 c9		      jr    malloc_find_space 
10de			 
10de			      ; split a bigger block into two - requested size and remaining size 
10de			malloc_alloc_split: 
10de					if DEBUG_FORTH_MALLOC 
10de						DMARK "MAs" 
10de						CALLMONITOR 
10de					endif 
10de eb			      ex    DE, HL                  ; Calculate address of new free block 
10df 2b			      dec   HL 
10e0 2b			      dec   HL 
10e1 2b			      dec   HL 
10e2 09			      add   HL, BC 
10e3			 
10e3			      ; Create a new block and point it at next_free 
10e3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10e6 dd 56 01		      ld    D, (IX+1) 
10e9			 
10e9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10ea 23			      inc   HL 
10eb 72			      ld    (HL), D 
10ec			 
10ec d1			      pop   DE                      ; Store size of new block into new block 
10ed 23			      inc   HL 
10ee 73			      ld    (HL), E 
10ef 23			      inc   HL 
10f0 72			      ld    (HL), D 
10f1			 
10f1			      ; Update this_free ptr to point to new block 
10f1 2b			      dec   HL 
10f2 2b			      dec   HL 
10f3 2b			      dec   HL 
10f4			 
10f4 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
10f7 dd 56 03		      ld    D, (IX+3) 
10fa			 
10fa dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
10fd dd 74 03		      ld    (IX+3), H 
1100			 
1100			      ; Modify this_free block to be allocation 
1100 eb			      ex    DE, HL 
1101 af			      xor   A                       ; Null the next block ptr of allocated block 
1102 77			      ld    (HL), A 
1103 23			      inc   HL 
1104 77			      ld    (HL), A 
1105			 
1105 23			      inc   HL                      ; Store want size into allocated block 
1106 71			      ld    (HL), C 
1107 23			      inc   HL 
1108 70			      ld    (HL), B 
1109 23			      inc   HL 
110a e5			      push  HL                      ; Address of allocation to return 
110b			 
110b 18 19		      jr    malloc_update_links 
110d			 
110d			malloc_alloc_fit: 
110d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
110e			 
110e					if DEBUG_FORTH_MALLOC 
110e						DMARK "MAf" 
110e						CALLMONITOR 
110e					endif 
110e			      ; Modify this_free block to be allocation 
110e eb			      ex    DE, HL 
110f 2b			      dec   HL 
1110 2b			      dec   HL 
1111 2b			      dec   HL 
1112			 
1112 af			      xor   A                       ; Null the next block ptr of allocated block 
1113 77			      ld    (HL), A 
1114 23			      inc   HL 
1115 77			      ld    (HL), A 
1116			 
1116 23			      inc   HL                      ; Store address of allocation to return 
1117 23			      inc   HL 
1118 23			      inc   HL 
1119 e5			      push  HL 
111a			 
111a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
111a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
111d dd 66 01		      ld    H, (IX+1) 
1120			 
1120 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1123 dd 74 03		      ld    (IX+3), H 
1126			 
1126			 
1126			malloc_update_links: 
1126			      ; Update prev_free ptr to point to this_free 
1126 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1129 dd 66 05		      ld    H, (IX+5) 
112c			 
112c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
112f dd 56 03		      ld    D, (IX+3) 
1132			 
1132 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1133 23			      inc   HL 
1134 72			      ld    (HL), D 
1135			 
1135					if DEBUG_FORTH_MALLOC 
1135						DMARK "Mul" 
1135						CALLMONITOR 
1135					endif 
1135			      ; Clear the Z flag to indicate successful allocation 
1135 7a			      ld    A, D 
1136 b3			      or    E 
1137			 
1137 d1			      pop   DE                      ; Address of allocation 
1138					if DEBUG_FORTH_MALLOC 
1138						DMARK "MAu" 
1138						CALLMONITOR 
1138					endif 
1138			 
1138			malloc_no_space: 
1138 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
113b 39			      add   HL, SP 
113c f9			      ld    SP, HL 
113d			 
113d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
113e					if DEBUG_FORTH_MALLOC 
113e						DMARK "MAN" 
113e						CALLMONITOR 
113e					endif 
113e			 
113e			malloc_early_exit: 
113e					if DEBUG_FORTH_MALLOC 
113e						DMARK "MAx" 
113e						CALLMONITOR 
113e					endif 
113e dd e1		      pop   IX 
1140 d1			      pop   DE 
1141 c1			      pop   BC 
1142			 
1142			if DEBUG_FORTH_MALLOC_HIGH 
1142			call malloc_guard_exit 
1142			call malloc_guard_zerolen 
1142			endif 
1142 c9			      ret 
1143			 
1143			 
1143			;------------------------------------------------------------------------------ 
1143			;     free                                                                    : 
1143			;                                                                             : 
1143			; Description                                                                 : 
1143			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1143			;     returned by malloc, otherwise the behaviour is undefined.               : 
1143			;                                                                             : 
1143			;     Where possible, directly adjacent free blocks will be merged together   : 
1143			;     into larger blocks to help ensure that the heap does not become         : 
1143			;     excessively fragmented.                                                 : 
1143			;                                                                             : 
1143			;     free does not clear or set any other value into the freed space, and    : 
1143			;     therefore its contents may be visible through subsequent malloc's. The  : 
1143			;     caller should clear the freed space as required.                        : 
1143			;                                                                             : 
1143			;     This implementation of free uses the stack exclusively, and is          : 
1143			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1143			;     advisable to disable interrupts before calling free, and recommended    : 
1143			;     to avoid the use of free inside ISRs in general.                        : 
1143			;                                                                             : 
1143			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1143			;                                                                             : 
1143			; Parameters                                                                  : 
1143			;     HL  Pointer to address of first byte of allocation to be freed          : 
1143			;                                                                             : 
1143			; Returns                                                                     : 
1143			;     Nothing                                                                 : 
1143			;                                                                             : 
1143			; Stack frame                                                                 : 
1143			;       |             |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |     BC      |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |     DE      |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |     IX      |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |  prev_free  |                                                       : 
1143			;   +2  +-------------+                                                       : 
1143			;       |  next_free  |                                                       : 
1143			;   +0  +-------------+                                                       : 
1143			;       |             |                                                       : 
1143			;                                                                             : 
1143			;------------------------------------------------------------------------------ 
1143			free: 
1143 c5			      push  BC 
1144 d5			      push  DE 
1145 dd e5		      push  IX 
1147			 
1147 7c			      ld    A, H                    ; Exit if ptr is null 
1148 b5			      or    L 
1149 ca 0d 12		      jp    Z, free_early_exit 
114c			 
114c			      ; Set up stack frame 
114c eb			      ex    DE, HL 
114d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1150 39			      add   HL, SP 
1151 f9			      ld    SP, HL 
1152 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1156 dd 39		      add   IX, SP 
1158			 
1158			      ; The address in HL points to the start of the useable allocated space, 
1158			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1158			      ; address of the block itself. 
1158 eb			      ex    DE, HL 
1159 11 fc ff		      ld    DE, -4 
115c 19			      add   HL, DE 
115d			 
115d			      ; An allocated block must have a null next block pointer in it 
115d 7e			      ld    A, (HL) 
115e 23			      inc   HL 
115f b6			      or    (HL) 
1160 c2 08 12		      jp    NZ, free_done 
1163			 
1163 2b			      dec   HL 
1164			 
1164 44			      ld    B, H                    ; Copy HL to BC 
1165 4d			      ld    C, L 
1166			 
1166			      ; Loop through the free list to find the first block with an address 
1166			      ; higher than the block being freed 
1166 21 e1 59		      ld    HL, free_list 
1169			 
1169			free_find_higher_block: 
1169 5e			      ld    E, (HL)                 ; Load next ptr from free block 
116a 23			      inc   HL 
116b 56			      ld    D, (HL) 
116c 2b			      dec   HL 
116d			 
116d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1170 dd 72 01		      ld    (IX+1), D 
1173 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1176 dd 74 03		      ld    (IX+3), H 
1179			 
1179 78			      ld    A, B                    ; Check if DE is greater than BC 
117a ba			      cp    D                       ; Compare MSB first 
117b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
117d 30 04		      jr    NC, free_find_higher_block_skip 
117f 79			      ld    A, C 
1180 bb			      cp    E                       ; Then compare LSB 
1181 38 08		      jr    C, free_found_higher_block 
1183			 
1183			free_find_higher_block_skip: 
1183 7a			      ld    A, D                    ; Reached the end of the free list? 
1184 b3			      or    E 
1185 ca 08 12		      jp    Z, free_done 
1188			 
1188 eb			      ex    DE, HL 
1189			 
1189 18 de		      jr    free_find_higher_block 
118b			 
118b			free_found_higher_block: 
118b			      ; Insert freed block between prev and next free blocks 
118b 71			      ld    (HL), C                 ; Point prev free block to freed block 
118c 23			      inc   HL 
118d 70			      ld    (HL), B 
118e			 
118e 60			      ld    H, B                    ; Point freed block at next free block 
118f 69			      ld    L, C 
1190 73			      ld    (HL), E 
1191 23			      inc   HL 
1192 72			      ld    (HL), D 
1193			 
1193			      ; Check if the freed block is adjacent to the next free block 
1193 23			      inc   HL                      ; Load size of freed block into HL 
1194 5e			      ld    E, (HL) 
1195 23			      inc   HL 
1196 56			      ld    D, (HL) 
1197 eb			      ex    DE, HL 
1198			 
1198 09			      add   HL, BC                  ; Add addr of freed block and its size 
1199			 
1199 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
119c dd 56 01		      ld    D, (IX+1) 
119f			 
119f b7			      or    A                       ; Clear the carry flag 
11a0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11a2 20 22		      jr    NZ, free_check_adjacent_to_prev 
11a4			 
11a4			      ; Freed block is adjacent to next, merge into one bigger block 
11a4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
11a5 5e			      ld    E, (HL) 
11a6 23			      inc   HL 
11a7 56			      ld    D, (HL) 
11a8 e5			      push  HL                      ; Save ptr to next block for later 
11a9			 
11a9 60			      ld    H, B                    ; Store ptr from next block into freed block 
11aa 69			      ld    L, C 
11ab 73			      ld    (HL), E 
11ac 23			      inc   HL 
11ad 72			      ld    (HL), D 
11ae			 
11ae e1			      pop   HL                      ; Restore ptr to next block 
11af 23			      inc   HL                      ; Load size of next block into DE 
11b0 5e			      ld    E, (HL) 
11b1 23			      inc   HL 
11b2 56			      ld    D, (HL) 
11b3 d5			      push  DE                      ; Save next block size for later 
11b4			 
11b4 60			      ld    H, B                    ; Load size of freed block into HL 
11b5 69			      ld    L, C 
11b6 23			      inc   HL 
11b7 23			      inc   HL 
11b8 5e			      ld    E, (HL) 
11b9 23			      inc   HL 
11ba 56			      ld    D, (HL) 
11bb eb			      ex    DE, HL 
11bc			 
11bc d1			      pop   DE                      ; Restore size of next block 
11bd 19			      add   HL, DE                  ; Add sizes of both blocks 
11be eb			      ex    DE, HL 
11bf			 
11bf 60			      ld    H, B                    ; Store new bigger size into freed block 
11c0 69			      ld    L, C 
11c1 23			      inc   HL 
11c2 23			      inc   HL 
11c3 73			      ld    (HL), E 
11c4 23			      inc   HL 
11c5 72			      ld    (HL), D 
11c6			 
11c6			free_check_adjacent_to_prev: 
11c6			      ; Check if the freed block is adjacent to the prev free block 
11c6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
11c9 dd 66 03		      ld    H, (IX+3) 
11cc			 
11cc 23			      inc   HL                      ; Size of prev free block into DE 
11cd 23			      inc   HL 
11ce 5e			      ld    E, (HL) 
11cf 23			      inc   HL 
11d0 56			      ld    D, (HL) 
11d1 2b			      dec   HL 
11d2 2b			      dec   HL 
11d3 2b			      dec   HL 
11d4			 
11d4 19			      add   HL, DE                  ; Add prev block addr and size 
11d5			 
11d5 b7			      or    A                       ; Clear the carry flag 
11d6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11d8 20 2e		      jr    NZ, free_done 
11da			 
11da			      ; Freed block is adjacent to prev, merge into one bigger block 
11da 60			      ld    H, B                    ; Load next ptr from freed block into DE 
11db 69			      ld    L, C 
11dc 5e			      ld    E, (HL) 
11dd 23			      inc   HL 
11de 56			      ld    D, (HL) 
11df e5			      push  HL                      ; Save freed block ptr for later 
11e0			 
11e0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11e3 dd 66 03		      ld    H, (IX+3) 
11e6 73			      ld    (HL), E 
11e7 23			      inc   HL 
11e8 72			      ld    (HL), D 
11e9			 
11e9 e1			      pop   HL                      ; Restore freed block ptr 
11ea 23			      inc   HL                      ; Load size of freed block into DE 
11eb 5e			      ld    E, (HL) 
11ec 23			      inc   HL 
11ed 56			      ld    D, (HL) 
11ee d5			      push  DE                      ; Save freed block size for later 
11ef			 
11ef dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
11f2 dd 66 03		      ld    H, (IX+3) 
11f5 23			      inc   HL 
11f6 23			      inc   HL 
11f7 5e			      ld    E, (HL) 
11f8 23			      inc   HL 
11f9 56			      ld    D, (HL) 
11fa			 
11fa e1			      pop   HL                      ; Add sizes of both blocks 
11fb 19			      add   HL, DE 
11fc eb			      ex    DE, HL 
11fd			 
11fd dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1200 dd 66 03		      ld    H, (IX+3) 
1203 23			      inc   HL 
1204 23			      inc   HL 
1205 73			      ld    (HL), E 
1206 23			      inc   HL 
1207 72			      ld    (HL), D 
1208			 
1208			free_done: 
1208 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
120b 39			      add   HL, SP 
120c f9			      ld    SP, HL 
120d			 
120d			free_early_exit: 
120d dd e1		      pop   IX 
120f d1			      pop   DE 
1210 c1			      pop   BC 
1211			 
1211 c9			      ret 
1212			 
1212			; moved to firmware.asm 
1212			; 
1212			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1212			;                  .dw   0 
1212			 
1212			 
1212			endif 
1212			 
1212			 
1212			if MALLOC_3 
1212			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1212			;heap_start        .equ  0x9000      ; Starting address of heap 
1212			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1212			; 
1212			 ;     .org 0 
1212			  ;    jp    main 
1212			; 
1212			; 
1212			 ;     .org  0x100 
1212			;main: 
1212			 ;     ld    HL, 0x8100 
1212			  ;    ld    SP, HL 
1212			; 
1212			;      call  heap_init 
1212			 
1212			      ; Make some allocations 
1212			;      ld    HL, 12 
1212			;      call  malloc            ; Allocates 0x9004 
1212			; 
1212			 ;     ld    HL, 12 
1212			;      call  malloc            ; Allocates 0x9014 
1212			 
1212			;      ld    HL, 12 
1212			;      call  malloc            ; Allocates 0x9024 
1212			 
1212			      ; Free some allocations 
1212			;      ld    HL, 0x9014 
1212			;      call  free 
1212			 
1212			;      ld    HL, 0x9004 
1212			;      call  free 
1212			; 
1212			;      ld    HL, 0x9024 
1212			;      call  free 
1212			 
1212			 
1212			 ;     halt 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     heap_init                                                               : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Initialise the heap and make it ready for malloc and free operations.   : 
1212			;                                                                             : 
1212			;     The heap is maintained as a linked list, starting with an initial       : 
1212			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1212			;     the first free block in the heap. Each block then points to the next    : 
1212			;     free block within the heap, and the free list ends at the first block   : 
1212			;     with a null pointer to the next free block.                             : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     Inputs are compile-time only. Two defines which specify the starting    : 
1212			;     address of the heap and its size are required, along with a memory      : 
1212			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1212			;     principally stores a pointer to the first free block in the heap.       : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     Nothing                                                                 : 
1212			;------------------------------------------------------------------------------ 
1212			heap_init: 
1212			      push  HL 
1212			 
1212			      ; Initialise free list struct 
1212			      ld    HL, heap_start 
1212			      ld    (free_list), HL 
1212			      ld    HL, 0 
1212			      ld    (free_list+2), HL 
1212			 
1212			      ; Insert first free block at bottom of heap, consumes entire heap 
1212			      ld    HL, heap_start+heap_size-4 
1212			      ld    (heap_start), HL        ; Next block (end of free list) 
1212			      ld    HL, heap_size-4 
1212			      ld    (heap_start+2), HL      ; Block size 
1212			 
1212			      ; Insert end of free list block at top of heap - two null words will 
1212			      ; terminate the free list 
1212			      ld    HL, 0 
1212			      ld    (heap_start+heap_size-2), HL 
1212			      ld    (heap_start+heap_size-4), HL 
1212			 
1212			      pop   HL 
1212			 
1212			      ret 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     malloc                                                                  : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Allocates the wanted space from the heap and returns the address of the : 
1212			;     first useable byte of the allocation.                                   : 
1212			;                                                                             : 
1212			;     Allocations can happen in one of two ways:                              : 
1212			;                                                                             : 
1212			;     1. A free block may be found which is the exact size wanted. In this    : 
1212			;        case the block is removed from the free list and retuedn to the      : 
1212			;        caller.                                                              : 
1212			;     2. A free block may be found which is larger than the size wanted. In   : 
1212			;        this case, the larger block is split into two. The first portion of  : 
1212			;        this block will become the requested space by the malloc call and    : 
1212			;        is returned to the caller. The second portion becomes a new free     : 
1212			;        block, and the free list is adjusted to maintain continuity via this : 
1212			;        newly created block.                                                 : 
1212			;                                                                             : 
1212			;     malloc does not set any initial value in the allocated space, the       : 
1212			;     caller is required to do this as required.                              : 
1212			;                                                                             : 
1212			;     This implementation of malloc uses the stack exclusively, and is        : 
1212			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1212			;     advisable to disable interrupts before calling malloc, and recommended  : 
1212			;     to avoid the use of malloc inside ISRs in general.                      : 
1212			;                                                                             : 
1212			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     HL  Number of bytes wanted                                              : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     HL  Address of the first useable byte of the allocation                 : 
1212			;                                                                             : 
1212			; Flags                                                                       : 
1212			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1212			;                                                                             : 
1212			; Stack frame                                                                 : 
1212			;       |             |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     BC      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     DE      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     IX      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |  prev_free  |                                                       : 
1212			;   +4  +-------------+                                                       : 
1212			;       |  this_free  |                                                       : 
1212			;   +2  +-------------+                                                       : 
1212			;       |  next_free  |                                                       : 
1212			;   +0  +-------------+                                                       : 
1212			;       |             |                                                       : 
1212			;                                                                             : 
1212			;------------------------------------------------------------------------------ 
1212			malloc: 
1212			      push  BC 
1212			      push  DE 
1212			      push  IX 
1212			 
1212			      ld    A, H                    ; Exit if no space requested 
1212			      or    L 
1212			      jp    Z, malloc_early_exit 
1212			 
1212			      ; Set up stack frame 
1212			      ex    DE, HL 
1212			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			      ld    IX, 0                   ; Use IX as a frame pointer 
1212			      add   IX, SP 
1212			 
1212			      ; Setup initial state 
1212			      ld    HL, 4                   ; want must also include space used by block struct 
1212			      add   HL, DE 
1212			 
1212			      ld    B, H                    ; Move want to BC 
1212			      ld    C, L 
1212			 
1212			      ld    HL, free_list           ; Store prev_free ptr to stack 
1212			      ld    (IX+4), L 
1212			      ld    (IX+5), H 
1212			 
1212			      ld    E, (HL)                 ; Store this_free ptr to stack 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      ld    (IX+2), E 
1212			      ld    (IX+3), D 
1212			      ex    DE, HL                  ; this_free ptr into HL 
1212			 
1212			      ; Loop through free block list to find some space 
1212			malloc_find_space: 
1212			      ld    E, (HL)                 ; Load next_free ptr into DE 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			 
1212			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1212			      or    E 
1212			      jp    Z, malloc_no_space 
1212			 
1212			      ld    (IX+0), E               ; Store next_free ptr to stack 
1212			      ld    (IX+1), D 
1212			 
1212			      ; Does this block have enough space to make the allocation? 
1212			      inc   HL                      ; Load free block size into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			 
1212			      ex    DE, HL                  ; Check size of block against want 
1212			      or    A                       ; Ensure carry flag clear 
1212			      sbc   HL, BC 
1212			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1212			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1212			 
1212			      ; this_free block is not big enough, setup ptrs to test next free block 
1212			      pop   HL                      ; Discard previous result 
1212			 
1212			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1212			      ld    H, (IX+3) 
1212			      ld    (IX+4), L 
1212			      ld    (IX+5), H 
1212			 
1212			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1212			      ld    H, (IX+1) 
1212			      ld    (IX+2), L 
1212			      ld    (IX+3), H 
1212			 
1212			      jr    malloc_find_space 
1212			 
1212			      ; split a bigger block into two - requested size and remaining size 
1212			malloc_alloc_split: 
1212			      ex    DE, HL                  ; Calculate address of new free block 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			      add   HL, BC 
1212			 
1212			      ; Create a new block and point it at next_free 
1212			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1212			      ld    D, (IX+1) 
1212			 
1212			      ld    (HL), E                 ; Store next_free ptr into new block 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      pop   DE                      ; Store size of new block into new block 
1212			      inc   HL 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      ; Update this_free ptr to point to new block 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			 
1212			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1212			      ld    D, (IX+3) 
1212			 
1212			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1212			      ld    (IX+3), H 
1212			 
1212			      ; Modify this_free block to be allocation 
1212			      ex    DE, HL 
1212			      xor   A                       ; Null the next block ptr of allocated block 
1212			      ld    (HL), A 
1212			      inc   HL 
1212			      ld    (HL), A 
1212			 
1212			      inc   HL                      ; Store want size into allocated block 
1212			      ld    (HL), C 
1212			      inc   HL 
1212			      ld    (HL), B 
1212			      inc   HL 
1212			      push  HL                      ; Address of allocation to return 
1212			 
1212			      jr    malloc_update_links 
1212			 
1212			malloc_alloc_fit: 
1212			      pop   HL                      ; Dont need new block size, want is exact fit 
1212			 
1212			      ; Modify this_free block to be allocation 
1212			      ex    DE, HL 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			 
1212			      xor   A                       ; Null the next block ptr of allocated block 
1212			      ld    (HL), A 
1212			      inc   HL 
1212			      ld    (HL), A 
1212			 
1212			      inc   HL                      ; Store address of allocation to return 
1212			      inc   HL 
1212			      inc   HL 
1212			      push  HL 
1212			 
1212			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1212			      ld    L, (IX+0)               ; next_free to HL 
1212			      ld    H, (IX+1) 
1212			 
1212			      ld    (IX+2), L               ; HL to this_free 
1212			      ld    (IX+3), H 
1212			 
1212			 
1212			malloc_update_links: 
1212			      ; Update prev_free ptr to point to this_free 
1212			      ld    L, (IX+4)               ; prev_free ptr to HL 
1212			      ld    H, (IX+5) 
1212			 
1212			      ld    E, (IX+2)               ; this_free ptr to DE 
1212			      ld    D, (IX+3) 
1212			 
1212			      ld    (HL), E                 ; this_free ptr into prev_free 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      ; Clear the Z flag to indicate successful allocation 
1212			      ld    A, D 
1212			      or    E 
1212			 
1212			      pop   DE                      ; Address of allocation 
1212			 
1212			malloc_no_space: 
1212			      ld    HL, 6                   ; Clean up stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			 
1212			      ex    DE, HL                  ; Alloc addr into HL for return 
1212			 
1212			malloc_early_exit: 
1212			      pop   IX 
1212			      pop   DE 
1212			      pop   BC 
1212			 
1212			      ret 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     free                                                                    : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1212			;     returned by malloc, otherwise the behaviour is undefined.               : 
1212			;                                                                             : 
1212			;     Where possible, directly adjacent free blocks will be merged together   : 
1212			;     into larger blocks to help ensure that the heap does not become         : 
1212			;     excessively fragmented.                                                 : 
1212			;                                                                             : 
1212			;     free does not clear or set any other value into the freed space, and    : 
1212			;     therefore its contents may be visible through subsequent malloc's. The  : 
1212			;     caller should clear the freed space as required.                        : 
1212			;                                                                             : 
1212			;     This implementation of free uses the stack exclusively, and is          : 
1212			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1212			;     advisable to disable interrupts before calling free, and recommended    : 
1212			;     to avoid the use of free inside ISRs in general.                        : 
1212			;                                                                             : 
1212			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     HL  Pointer to address of first byte of allocation to be freed          : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     Nothing                                                                 : 
1212			;                                                                             : 
1212			; Stack frame                                                                 : 
1212			;       |             |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     BC      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     DE      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     IX      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |  prev_free  |                                                       : 
1212			;   +2  +-------------+                                                       : 
1212			;       |  next_free  |                                                       : 
1212			;   +0  +-------------+                                                       : 
1212			;       |             |                                                       : 
1212			;                                                                             : 
1212			;------------------------------------------------------------------------------ 
1212			free: 
1212			      push  BC 
1212			      push  DE 
1212			      push  IX 
1212			 
1212			      ld    A, H                    ; Exit if ptr is null 
1212			      or    L 
1212			      jp    Z, free_early_exit 
1212			 
1212			      ; Set up stack frame 
1212			      ex    DE, HL 
1212			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			      ld    IX, 0                   ; Use IX as a frame pointer 
1212			      add   IX, SP 
1212			 
1212			      ; The address in HL points to the start of the useable allocated space, 
1212			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1212			      ; address of the block itself. 
1212			      ex    DE, HL 
1212			      ld    DE, -4 
1212			      add   HL, DE 
1212			 
1212			      ; An allocated block must have a null next block pointer in it 
1212			      ld    A, (HL) 
1212			      inc   HL 
1212			      or    (HL) 
1212			      jp    NZ, free_done 
1212			 
1212			      dec   HL 
1212			 
1212			      ld    B, H                    ; Copy HL to BC 
1212			      ld    C, L 
1212			 
1212			      ; Loop through the free list to find the first block with an address 
1212			      ; higher than the block being freed 
1212			      ld    HL, free_list 
1212			 
1212			free_find_higher_block: 
1212			      ld    E, (HL)                 ; Load next ptr from free block 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      dec   HL 
1212			 
1212			      ld    (IX+0), E               ; Save ptr to next free block 
1212			      ld    (IX+1), D 
1212			      ld    (IX+2), L               ; Save ptr to prev free block 
1212			      ld    (IX+3), H 
1212			 
1212			      ld    A, B                    ; Check if DE is greater than BC 
1212			      cp    D                       ; Compare MSB first 
1212			      jr    Z, $+4                  ; MSB the same, compare LSB 
1212			      jr    NC, free_find_higher_block_skip 
1212			      ld    A, C 
1212			      cp    E                       ; Then compare LSB 
1212			      jr    C, free_found_higher_block 
1212			 
1212			free_find_higher_block_skip: 
1212			      ld    A, D                    ; Reached the end of the free list? 
1212			      or    E 
1212			      jp    Z, free_done 
1212			 
1212			      ex    DE, HL 
1212			 
1212			      jr    free_find_higher_block 
1212			 
1212			free_found_higher_block: 
1212			      ; Insert freed block between prev and next free blocks 
1212			      ld    (HL), C                 ; Point prev free block to freed block 
1212			      inc   HL 
1212			      ld    (HL), B 
1212			 
1212			      ld    H, B                    ; Point freed block at next free block 
1212			      ld    L, C 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      ; Check if the freed block is adjacent to the next free block 
1212			      inc   HL                      ; Load size of freed block into HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      ex    DE, HL 
1212			 
1212			      add   HL, BC                  ; Add addr of freed block and its size 
1212			 
1212			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1212			      ld    D, (IX+1) 
1212			 
1212			      or    A                       ; Clear the carry flag 
1212			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1212			      jr    NZ, free_check_adjacent_to_prev 
1212			 
1212			      ; Freed block is adjacent to next, merge into one bigger block 
1212			      ex    DE, HL                  ; Load next ptr from next block into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  HL                      ; Save ptr to next block for later 
1212			 
1212			      ld    H, B                    ; Store ptr from next block into freed block 
1212			      ld    L, C 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      pop   HL                      ; Restore ptr to next block 
1212			      inc   HL                      ; Load size of next block into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  DE                      ; Save next block size for later 
1212			 
1212			      ld    H, B                    ; Load size of freed block into HL 
1212			      ld    L, C 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      ex    DE, HL 
1212			 
1212			      pop   DE                      ; Restore size of next block 
1212			      add   HL, DE                  ; Add sizes of both blocks 
1212			      ex    DE, HL 
1212			 
1212			      ld    H, B                    ; Store new bigger size into freed block 
1212			      ld    L, C 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			free_check_adjacent_to_prev: 
1212			      ; Check if the freed block is adjacent to the prev free block 
1212			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1212			      ld    H, (IX+3) 
1212			 
1212			      inc   HL                      ; Size of prev free block into DE 
1212			      inc   HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			 
1212			      add   HL, DE                  ; Add prev block addr and size 
1212			 
1212			      or    A                       ; Clear the carry flag 
1212			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1212			      jr    NZ, free_done 
1212			 
1212			      ; Freed block is adjacent to prev, merge into one bigger block 
1212			      ld    H, B                    ; Load next ptr from freed block into DE 
1212			      ld    L, C 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  HL                      ; Save freed block ptr for later 
1212			 
1212			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1212			      ld    H, (IX+3) 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      pop   HL                      ; Restore freed block ptr 
1212			      inc   HL                      ; Load size of freed block into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  DE                      ; Save freed block size for later 
1212			 
1212			      ld    L, (IX+2)               ; Load size of prev block into DE 
1212			      ld    H, (IX+3) 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			 
1212			      pop   HL                      ; Add sizes of both blocks 
1212			      add   HL, DE 
1212			      ex    DE, HL 
1212			 
1212			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1212			      ld    H, (IX+3) 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			free_done: 
1212			      ld    HL, 4                   ; Clean up stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			 
1212			free_early_exit: 
1212			      pop   IX 
1212			      pop   DE 
1212			      pop   BC 
1212			 
1212			      ret 
1212			 
1212			 
1212			;      .org 0x8000 
1212			; 
1212			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1212			 ;                 .dw   0 
1212			 
1212			endif 
1212			 
1212			 
1212			if MALLOC_4 
1212			 
1212			; My memory allocation code. Very very simple.... 
1212			; allocate space under 250 chars 
1212			 
1212			heap_init: 
1212				; init start of heap as zero 
1212				;  
1212			 
1212				ld hl, heap_start 
1212				ld a, 0 
1212				ld (hl), a      ; empty block 
1212				inc hl 
1212				ld a, 0 
1212				ld (hl), a      ; length of block 
1212				; write end of list 
1212				inc hl 
1212				ld a,(hl) 
1212				inc hl 
1212				ld a,(hl) 
1212				 
1212			 
1212				; init some malloc vars 
1212			 
1212				ld hl, 0 
1212				ld (free_list), hl       ; store last malloc location 
1212			 
1212				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1212				ld a, 0 
1212				ld (hl), a 
1212			 
1212			 
1212				ld hl, heap_start 
1212				;  
1212				  
1212				ret 
1212			 
1212			 
1212			;    free block marker 
1212			;    requested size  
1212			;    pointer to next block 
1212			;    .... 
1212			;    next block marker 
1212			 
1212			 
1212			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1212			; 
1212			 
1212			 
1212			malloc:  
1212				push de 
1212				push bc 
1212				push af 
1212			 
1212				; hl space required 
1212				 
1212				ld c, l    ; hold space   (TODO only a max of 255) 
1212			 
1212			;	inc c     ; TODO BUG need to fix memory leak on push str 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			 
1212			 
1212			 
1212				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1212			 
1212				ld a, (free_list+3) 
1212				cp 0 
1212				jr z, .contheap 
1212			 
1212				ld hl, (free_list)     ; get last alloc 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mrs" 
1212						CALLMONITOR 
1212					endif 
1212				jr .startalloc 
1212			 
1212			.contheap: 
1212				ld hl, heap_start 
1212			 
1212			.startalloc: 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mym" 
1212						CALLMONITOR 
1212					endif 
1212			.findblock: 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mmf" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212				ld a,(hl)  
1212				; if byte is zero then clear to use 
1212			 
1212				cp 0 
1212				jr z, .foundemptyblock 
1212			 
1212				; if byte is not clear 
1212				;     then byte is offset to next block 
1212			 
1212				inc hl 
1212				ld a, (hl) ; get size 
1212			.nextblock:	inc hl 
1212					ld e, (hl) 
1212					inc hl 
1212					ld d, (hl) 
1212					ex de, hl 
1212			;	inc hl  ; move past the store space 
1212			;	inc hl  ; move past zero index  
1212			 
1212				; TODO detect no more space 
1212			 
1212				push hl 
1212				ld de, heap_end 
1212				call cmp16 
1212				pop hl 
1212				jr nc, .nospace 
1212			 
1212				jr .findblock 
1212			 
1212			.nospace: ld hl, 0 
1212				jp .exit 
1212			 
1212			 
1212			.foundemptyblock:	 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mme" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			; TODO has block enough space if reusing??? 
1212			 
1212				;  
1212			 
1212			; see if this block has been previously used 
1212				inc hl 
1212				ld a, (hl) 
1212				dec hl 
1212				cp 0 
1212				jr z, .newblock 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "meR" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			; no reusing previously allocated block 
1212			 
1212			; is it smaller than previously used? 
1212				 
1212				inc hl    ; move to size 
1212				ld a, c 
1212				sub (hl)        ; we want c < (hl) 
1212				dec hl    ; move back to marker 
1212			        jr z, .findblock 
1212			 
1212				; update with the new size which should be lower 
1212			 
1212			        ;inc  hl   ; negate next move. move back to size  
1212			 
1212			.newblock: 
1212				; need to be at marker here 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "meN" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			 
1212				ld a, c 
1212			 
1212				ld (free_list+3), a	 ; flag resume from last malloc  
1212				ld (free_list), hl    ; save out last location 
1212			 
1212			 
1212				;inc a     ; space for length byte 
1212				ld (hl), a     ; save block in use marker 
1212			 
1212				inc hl   ; move to space marker 
1212				ld (hl), a    ; save new space 
1212			 
1212				inc hl   ; move to start of allocated area 
1212				 
1212			;	push hl     ; save where we are - 1  
1212			 
1212			;	inc hl  ; move past zero index  
1212				; skip space to set down new marker 
1212			 
1212				; provide some extra space for now 
1212			 
1212				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1212				inc a 
1212				inc a 
1212			 
1212				push hl   ; save where we are in the node block 
1212			 
1212				call addatohl 
1212			 
1212				; write linked list point 
1212			 
1212				pop de     ; get our node position 
1212				ex de, hl 
1212			 
1212				ld (hl), e 
1212				inc hl 
1212				ld (hl), d 
1212			 
1212				inc hl 
1212			 
1212				; now at start of allocated data so save pointer 
1212			 
1212				push hl 
1212			 
1212				; jump to position of next node and setup empty header in DE 
1212			 
1212				ex de, hl 
1212			 
1212			;	inc hl ; move past end of block 
1212			 
1212				ld a, 0 
1212				ld (hl), a   ; empty marker 
1212				inc hl 
1212				ld (hl), a   ; size 
1212				inc hl  
1212				ld (hl), a   ; ptr 
1212				inc hl 
1212				ld (hl), a   ; ptr 
1212			 
1212			 
1212				pop hl 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mmr" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			.exit: 
1212				pop af 
1212				pop bc 
1212				pop de  
1212				ret 
1212			 
1212			 
1212			 
1212			 
1212			free:  
1212				push hl 
1212				push af 
1212				; get address in hl 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "fre" 
1212						CALLMONITOR 
1212					endif 
1212				; data is at hl - move to block count 
1212				dec hl 
1212				dec hl    ; get past pointer 
1212				dec hl 
1212			 
1212				ld a, (hl)    ; need this for a validation check 
1212			 
1212				dec hl    ; move to block marker 
1212			 
1212				; now check that the block count and block marker are the same  
1212			        ; this checks that we are on a malloc node and not random memory 
1212			        ; OK a faint chance this could be a problem but rare - famous last words! 
1212			 
1212				ld c, a 
1212				ld a, (hl)    
1212			 
1212				cp c 
1212				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1212			 
1212				; yes good chance we are on a malloc node 
1212			 
1212				ld a, 0      
1212				ld (hl), a   ; mark as free 
1212			 
1212				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1212			 
1212			.freeignore:  
1212			 
1212				pop af 
1212				pop hl 
1212			 
1212				ret 
1212			 
1212			 
1212			 
1212			endif 
1212			 
1212			; eof 
# End of file firmware_memory.asm
1212			  
1212			; device C  
1212			if SOUND_ENABLE  
1212				include "firmware_sound.asm"  
1212			endif  
1212			  
1212			include "firmware_diags.asm"  
1212			; Hardware diags menu 
1212			 
1212			 
1212			config: 
1212			 
1212 3e 00			ld a, 0 
1214 21 38 12			ld hl, .configmn 
1217 cd b6 09			call menu 
121a			 
121a fe 00			cp 0 
121c c8				ret z 
121d			 
121d fe 01			cp 1 
121f cc c0 12			call z, .savetostore 
1222			 
1222 fe 02			cp 2 
1224 cc be 12			call z, .selautoload 
1227 fe 03			cp 3 
1229 cc bf 12			call z, .selbank 
122c fe 05			cp 5 
122e cc c1 12			call z, .debug_tog 
1231 fe 06			cp 6 
1233 cc e7 12			call z, hardware_diags 
1236			 
1236 18 da			jr config 
1238			 
1238			.configmn: 
1238 46 12			dw .c3 
123a 62 12			dw .c2 
123c 77 12			dw .c2b 
123e 8b 12			dw .c4 
1240 94 12			dw .m4 
1242 af 12			dw .c1 
1244 00 00			dw 0 
1246				 
1246			 
1246 .. 00		.c3: db "Add User Dictionary To File",0 
1262 .. 00		.c2: db "Select Autoload File",0 
1277 .. 00		.c2b: db "Select Storage Bank",0 
128b .. 00		.c4: db "Settings",0 
1294 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
12af .. 00		.c1: db "Hardware Diags",0 
12be			 
12be			; Select auto start 
12be			 
12be			.selautoload: 
12be			 
12be				 
12be				if STORAGE_SE 
12be			 
12be					call config_dir 
12be				        ld hl, scratch 
12be					ld a, 0 
12be					call menu 
12be			 
12be					; locate menu option 
12be			 
12be					ld hl, scratch 
12be					call table_lookup 
12be			 
12be					; with the pointer to the menu it, the byte following the zero term is the file id 
12be			 
12be					ld a, 0 
12be					ld bc, 50   ; max of bytes to look at 
12be					cpir  
12be			 
12be					inc hl 
12be			 
12be					ld a, (hl)   ; file id 
12be					 
12be				        ; save bank and file ids 
12be			 
12be					push af 
12be			 
12be					call storage_get_block_0 
12be			 
12be					pop af 
12be			 
12be					ld (store_page+STORE_0_FILERUN),a 
12be					 
12be					; save bank id 
12be			 
12be					ld a,(spi_device) 
12be					ld (store_page+STORE_0_BANKRUN),a 
12be			 
12be					; save buffer 
12be			 
12be					ld hl, 0 
12be					ld de, store_page 
12be				call storage_write_block	 ; save update 
12be			  
12be			 
12be			 
12be			 
12be					ld hl, scratch 
12be					call config_fdir 
12be			 
12be			 
12be				endif 
12be c9				ret 
12bf			 
12bf			 
12bf			 
12bf			; Select storage bank 
12bf			 
12bf			.selbank: 
12bf			 
12bf				if STORAGE_SE 
12bf				endif 
12bf				 
12bf c9				ret 
12c0			 
12c0			if STORAGE_SE 
12c0			 
12c0			.config_ldir:   
12c0				; Load storage bank labels into menu array 
12c0			 
12c0				 
12c0			 
12c0			 
12c0				ret 
12c0			 
12c0			 
12c0			endif 
12c0			 
12c0			 
12c0			; Save user words to storage 
12c0			 
12c0			.savetostore: 
12c0			 
12c0				if STORAGE_SE 
12c0			 
12c0					call config_dir 
12c0				        ld hl, scratch 
12c0					ld a, 0 
12c0					call menu 
12c0					 
12c0					ld hl, scratch 
12c0					call config_fdir 
12c0			 
12c0			 
12c0				endif 
12c0			 
12c0 c9				ret 
12c1			 
12c1			 
12c1			 
12c1			if STORAGE_SE 
12c1			 
12c1			config_fdir: 
12c1				; using the scratch dir go through and release the memory allocated for each string 
12c1				 
12c1				ld hl, scratch 
12c1			.cfdir:	ld e,(hl) 
12c1				inc hl 
12c1				ld d,(hl) 
12c1				inc hl 
12c1			 
12c1				ex de, hl 
12c1				call ishlzero 
12c1				ret z     ; return on null pointer 
12c1				call free 
12c1				ex de, hl 
12c1				jr .cfdir 
12c1			 
12c1			 
12c1				ret 
12c1			 
12c1			 
12c1			config_dir: 
12c1			 
12c1				; for the config menus that need to build a directory of storage call this routine 
12c1				; it will construct a menu in scratch to pass to menu 
12c1			 
12c1				; open storage device 
12c1			 
12c1				; execute DIR to build a list of files and their ids into scratch in menu format 
12c1				; once the menu has finished then will need to call config_fdir to release the strings 
12c1				 
12c1				; c = number items 
12c1			 
12c1				 
12c1				call storage_get_block_0 
12c1			 
12c1				ld hl, store_page     ; get current id count 
12c1				ld b, (hl) 
12c1				ld c, 0    ; count of files   
12c1			 
12c1			 
12c1				ld hl, scratch 
12c1				ld (store_tmp2), hl    ; location to poke strings 
12c1			 
12c1				; check for empty drive 
12c1			 
12c1				ld a, 0 
12c1				cp b 
12c1				jp z, .dirdone 
12c1			 
12c1				 
12c1					if DEBUG_FORTH_WORDS 
12c1						DMARK "Cdc" 
12c1						CALLMONITOR 
12c1					endif 
12c1			 
12c1			 
12c1			.diritem:	 
12c1				push bc 
12c1				; for each of the current ids do a search for them and if found push to stack 
12c1			 
12c1					ld hl, STORE_BLOCK_PHY 
12c1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
12c1					ld e,b 
12c1			 
12c1					call storage_findnextid 
12c1			 
12c1			 
12c1					; if found hl will be non zero 
12c1			 
12c1					call ishlzero 
12c1					jr z, .dirnotfound 
12c1			 
12c1					; increase count 
12c1			 
12c1					pop bc	 
12c1					inc c 
12c1					push bc 
12c1					 
12c1			 
12c1					; get file header and push the file name 
12c1			 
12c1					ld de, store_page 
12c1					call storage_read_block 
12c1			 
12c1					; push file id to stack 
12c1				 
12c1					ld a, (store_page) 
12c1					ld h, 0 
12c1					ld l, a 
12c1			 
12c1					;call forth_push_numhl 
12c1					; TODO store id 
12c1			 
12c1					push hl 
12c1			 
12c1					; push extent count to stack  
12c1				 
12c1					ld hl, store_page+3 
12c1			 
12c1					; get file name length 
12c1			 
12c1					call strlenz   
12c1			 
12c1					inc hl   ; cover zero term 
12c1					inc hl  ; stick the id at the end of the area 
12c1			 
12c1					push hl 
12c1					pop bc    ; move length to bc 
12c1			 
12c1					call malloc 
12c1			 
12c1					; TODO save malloc area to scratch 
12c1			 
12c1					ex de, hl 
12c1					ld hl, (store_tmp2) 
12c1					ld (hl), e 
12c1					inc hl 
12c1					ld (hl), d 
12c1					inc hl 
12c1					ld (store_tmp2), hl 
12c1			 
12c1					 
12c1			 
12c1					;pop hl   ; get source 
12c1			;		ex de, hl    ; swap aronund	 
12c1			 
12c1					ld hl, store_page+3 
12c1					if DEBUG_FORTH_WORDS 
12c1						DMARK "CFd" 
12c1						CALLMONITOR 
12c1					endif 
12c1					ldir 
12c1			 
12c1					; de is past string, move back one and store id 
12c1					 
12c1					dec de 
12c1			 
12c1					; store file id 
12c1			 
12c1					pop hl 
12c1					ex de,hl 
12c1					ld (hl), e 
12c1			 
12c1					if DEBUG_FORTH_WORDS 
12c1						DMARK "Cdi" 
12c1						CALLMONITOR 
12c1					endif 
12c1					 
12c1			.dirnotfound: 
12c1					pop bc     
12c1					djnz .diritem 
12c1				 
12c1			.dirdone:	 
12c1			 
12c1					ld a, 0 
12c1					ld hl, (store_tmp2) 
12c1					ld (hl), a 
12c1					inc hl 
12c1					ld (hl), a 
12c1					inc hl 
12c1					; push a count of the dir items found 
12c1			 
12c1			;		ld h, 0 
12c1			;		ld l, c 
12c1			 
12c1				ret 
12c1			 
12c1			endif 
12c1			 
12c1			 
12c1			; Settings 
12c1			; Run  
12c1			 
12c1			 
12c1			 
12c1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
12c1			;;hd_menu2:   db "        2: Editor",0   
12c1			;hd_menu2:   db "        2: Editor       6: Menu",0   
12c1			;hd_menu3:   db "        3: Storage",0 
12c1			;hd_menu4:   db "0=quit  4: Debug",0 
12c1			;hd_don:     db "ON",0 
12c1			;hd_doff:     db "OFF",0 
12c1			; 
12c1			; 
12c1			; 
12c1			;hardware_diags_old:       
12c1			; 
12c1			;.diagmenu: 
12c1			;	call clear_display 
12c1			;	ld a, display_row_1 
12c1			;	ld de, hd_menu1 
12c1			;	call str_at_display 
12c1			; 
12c1			;	ld a, display_row_2 
12c1			;	ld de, hd_menu2 
12c1			;	call str_at_display 
12c1			; 
12c1			;	ld a, display_row_3 
12c1			;	ld de, hd_menu3 
12c1			;	call str_at_display 
12c1			; 
12c1			;	ld a,  display_row_4 
12c1			;	ld de, hd_menu4 
12c1			;	call str_at_display 
12c1			; 
12c1			;	; display debug state 
12c1			; 
12c1			;	ld de, hd_don 
12c1			;	ld a, (os_view_disable) 
12c1			;	cp 0 
12c1			;	jr z, .distog 
12c1			;	ld de, hd_doff 
12c1			;.distog: ld a, display_row_4+17 
12c1			;	call str_at_display 
12c1			; 
12c1			;	call update_display 
12c1			; 
12c1			;	call cin_wait 
12c1			; 
12c1			; 
12c1			; 
12c1			;	cp '4' 
12c1			;	jr nz, .diagn1 
12c1			; 
12c1			;	; debug toggle 
12c1			; 
12c1			;	ld a, (os_view_disable) 
12c1			;	ld b, '*' 
12c1			;	cp 0 
12c1			;	jr z, .debtog 
12c1			;	ld b, 0 
12c1			;.debtog:	 
12c1			;	ld a,b 
12c1			;	ld (os_view_disable),a 
12c1			; 
12c1			;.diagn1: cp '0' 
12c1			;	 ret z 
12c1			; 
12c1			;;	cp '1' 
12c1			;;       jp z, matrix	 
12c1			;;   TODO keyboard matrix test 
12c1			; 
12c1			;	cp '2' 
12c1			;	jp z, .diagedit 
12c1			; 
12c1			;;	cp '6' 
12c1			;;	jp z, .menutest 
12c1			;;if ENABLE_BASIC 
12c1			;;	cp '6' 
12c1			;;	jp z, basic 
12c1			;;endif 
12c1			 ; 
12c1			;	jp .diagmenu 
12c1			; 
12c1			; 
12c1			;	ret 
12c1			 
12c1			 
12c1			.debug_tog: 
12c1 21 08 13			ld hl, .menudebug 
12c4				 
12c4 3a 51 e3			ld a, (os_view_disable) 
12c7 fe 2a			cp '*' 
12c9 20 04			jr nz,.tdon  
12cb 3e 01			ld a, 1 
12cd 18 02			jr .tog1 
12cf 3e 00		.tdon: ld a, 0 
12d1			 
12d1			.tog1: 
12d1 cd b6 09			call menu 
12d4 fe 00			cp 0 
12d6 c8				ret z 
12d7 fe 01			cp 1    ; disable debug 
12d9 28 04			jr z, .dtog0 
12db 3e 2a			ld a, '*' 
12dd 18 02			jr .dtogset 
12df 3e 00		.dtog0: ld a, 0 
12e1 32 51 e3		.dtogset:  ld (os_view_disable), a 
12e4 c3 c1 12			jp .debug_tog 
12e7			 
12e7			 
12e7			hardware_diags:       
12e7			 
12e7			.diagm: 
12e7 21 fa 12			ld hl, .menuitems 
12ea 3e 00			ld a, 0 
12ec cd b6 09			call menu 
12ef			 
12ef fe 00		         cp 0 
12f1 c8				 ret z 
12f2			 
12f2 fe 02			cp 2 
12f4 ca 53 13			jp z, .diagedit 
12f7			 
12f7			;	cp '6' 
12f7			;	jp z, .menutest 
12f7			;if ENABLE_BASIC 
12f7			;	cp '6' 
12f7			;	jp z, basic 
12f7			;endif 
12f7			  
12f7 c3 e7 12			jp .diagm 
12fa			 
12fa				 
12fa 0e 13		.menuitems:   	dw .m1 
12fc 19 13				dw .m2 
12fe 20 13				dw .m3 
1300 28 13				dw .m5 
1302 2e 13				dw .m5a 
1304 37 13				dw .m5b 
1306 00 00				dw 0 
1308			 
1308			.menudebug: 
1308 40 13				dw .m6 
130a 49 13				dw .m7 
130c 00 00				dw 0 
130e			 
130e .. 00		.m1:   db "Key Matrix",0 
1319 .. 00		.m2:   db "Editor",0 
1320 .. 00		.m3:   db "Storage",0 
1328 .. 00		.m5:   db "Sound",0 
132e .. 00		.m5a:  db "RAM Test",0 
1337 .. 00		.m5b:  db "LCD Test",0 
1340			 
1340 .. 00		.m6:   db "Debug ON",0 
1349 .. 00		.m7:   db "Debug OFF",0 
1353			 
1353			; debug editor 
1353			 
1353			.diagedit: 
1353			 
1353 21 60 e3			ld hl, scratch 
1356			;	ld bc, 250 
1356			;	ldir 
1356				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1356 3e 00			ld a, 0 
1358 77				ld (hl), a 
1359 23				inc hl 
135a 77				ld (hl), a 
135b 23				inc hl 
135c 77				ld (hl), a 
135d			 
135d cd 85 09		        call clear_display 
1360 cd a8 09			call update_display 
1363 3e 01			ld a, 1 
1365 32 80 ee			ld (hardware_diag), a 
1368			.diloop: 
1368 3e 00			ld a, display_row_1 
136a 0e 00			ld c, 0 
136c 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
136e 1e 28			ld e, 40 
1370			 
1370 21 60 e3			ld hl, scratch	 
1373 cd df 0b			call input_str 
1376			 
1376 3e 28			ld a, display_row_2 
1378 11 60 e3			ld de, scratch 
137b cd 98 09			call str_at_display 
137e cd a8 09			call update_display 
1381			 
1381 c3 68 13			jp .diloop 
1384			 
1384			 
1384			; pass word in hl 
1384			; a has display location 
1384			display_word_at: 
1384 f5				push af 
1385 e5				push hl 
1386 7c				ld a,h 
1387 21 65 e6			ld hl, os_word_scratch 
138a cd b3 0e			call hexout 
138d e1				pop hl 
138e 7d				ld a,l 
138f 21 67 e6			ld hl, os_word_scratch+2 
1392 cd b3 0e			call hexout 
1395 21 69 e6			ld hl, os_word_scratch+4 
1398 3e 00			ld a,0 
139a 77				ld (hl),a 
139b 11 65 e6			ld de,os_word_scratch 
139e f1				pop af 
139f cd 98 09				call str_at_display 
13a2 c9				ret 
13a3			 
13a3			display_ptr_state: 
13a3			 
13a3				; to restore afterwards 
13a3			 
13a3 d5				push de 
13a4 c5				push bc 
13a5 e5				push hl 
13a6 f5				push af 
13a7			 
13a7				; for use in here 
13a7			 
13a7			;	push bc 
13a7			;	push de 
13a7			;	push hl 
13a7			;	push af 
13a7			 
13a7 cd 85 09			call clear_display 
13aa			 
13aa 11 7d 15			ld de, .ptrstate 
13ad 3e 00			ld a, display_row_1 
13af cd 98 09			call str_at_display 
13b2			 
13b2				; display debug step 
13b2			 
13b2			 
13b2 11 7a ee			ld de, debug_mark 
13b5 3e 26			ld a, display_row_1+display_cols-2 
13b7 cd 98 09			call str_at_display 
13ba			 
13ba				; display a 
13ba 11 87 15			ld de, .ptrcliptr 
13bd 3e 28			ld a, display_row_2 
13bf cd 98 09			call str_at_display 
13c2			 
13c2 f1				pop af 
13c3 2a 2b eb			ld hl,(cli_ptr) 
13c6 3e 30			ld a, display_row_2+8 
13c8 cd 84 13			call display_word_at 
13cb			 
13cb			 
13cb				; display hl 
13cb			 
13cb			 
13cb 11 8f 15			ld de, .ptrclioptr 
13ce 3e 32			ld a, display_row_2+10 
13d0 cd 98 09			call str_at_display 
13d3			; 
13d3			;	pop hl 
13d3 3e 35			ld a, display_row_2+13 
13d5 2a 29 eb			ld hl,(cli_origptr) 
13d8 cd 84 13			call display_word_at 
13db			; 
13db			;	 
13db			;	; display de 
13db			 
13db			;	ld de, .regstatede 
13db			;	ld a, display_row_3 
13db			;	call str_at_display 
13db			 
13db			;	pop de 
13db			;	ld h,d 
13db			;	ld l, e 
13db			;	ld a, display_row_3+3 
13db			;	call display_word_at 
13db			 
13db			 
13db				; display bc 
13db			 
13db			;	ld de, .regstatebc 
13db			;	ld a, display_row_3+10 
13db			;	call str_at_display 
13db			 
13db			;	pop bc 
13db			;	ld h,b 
13db			;	ld l, c 
13db			;	ld a, display_row_3+13 
13db			;	call display_word_at 
13db			 
13db			 
13db				; display dsp 
13db			 
13db			;	ld de, .regstatedsp 
13db			;	ld a, display_row_4 
13db			;	call str_at_display 
13db			 
13db				 
13db			;	ld hl,(cli_data_sp) 
13db			;	ld a, display_row_4+4 
13db			;	call display_word_at 
13db			 
13db				; display rsp 
13db			 
13db 11 be 15			ld de, .regstatersp 
13de 3e 82			ld a, display_row_4+10 
13e0 cd 98 09			call str_at_display 
13e3			 
13e3				 
13e3 2a 11 eb			ld hl,(cli_ret_sp) 
13e6 3e 86			ld a, display_row_4+14 
13e8 cd 84 13			call display_word_at 
13eb			 
13eb cd a8 09			call update_display 
13ee			 
13ee cd fa 08			call delay1s 
13f1 cd fa 08			call delay1s 
13f4 cd fa 08			call delay1s 
13f7			 
13f7			 
13f7 cd 04 19			call next_page_prompt 
13fa			 
13fa				; restore  
13fa			 
13fa f1				pop af 
13fb e1				pop hl 
13fc c1				pop bc 
13fd d1				pop de 
13fe c9				ret 
13ff			 
13ff			break_point_state: 
13ff f5				push af 
1400			 
1400				; see if disabled 
1400			 
1400 3a 51 e3			ld a, (os_view_disable) 
1403 fe 2a			cp '*' 
1405 20 02			jr nz, .bpsgo 
1407 f1				pop af 
1408 c9				ret 
1409			 
1409			.bpsgo: 
1409 f1				pop af 
140a f5				push af 
140b 22 4d e3			ld (os_view_hl), hl 
140e ed 53 4b e3		ld (os_view_de), de 
1412 ed 43 49 e3		ld (os_view_bc), bc 
1416 e5				push hl 
1417 6f				ld l, a 
1418 26 00			ld h, 0 
141a 22 4f e3			ld (os_view_af),hl 
141d			 
141d 21 c0 ed				ld hl, display_fb0 
1420 22 db eb				ld (display_fb_active), hl 
1423 e1				pop hl	 
1424			 
1424 3e 31			ld a, '1' 
1426 fe 2a		.bps1:  cp '*' 
1428 20 03			jr nz, .bps1b 
142a 32 51 e3			ld (os_view_disable),a 
142d fe 31		.bps1b:  cp '1' 
142f 20 14			jr nz, .bps2 
1431			 
1431				; display reg 
1431			 
1431				 
1431			 
1431 3a 4f e3			ld a, (os_view_af) 
1434 2a 4d e3			ld hl, (os_view_hl) 
1437 ed 5b 4b e3		ld de, (os_view_de) 
143b ed 4b 49 e3		ld bc, (os_view_bc) 
143f cd d9 14			call display_reg_state 
1442 c3 c5 14			jp .bpschk 
1445			 
1445 fe 32		.bps2:  cp '2' 
1447 20 08			jr nz, .bps3 
1449				 
1449				; display hl 
1449 2a 4d e3			ld hl, (os_view_hl) 
144c cd c3 15			call display_dump_at_hl 
144f			 
144f 18 74			jr .bpschk 
1451			 
1451 fe 33		.bps3:  cp '3' 
1453 20 08			jr nz, .bps4 
1455			 
1455			        ; display de 
1455 2a 4b e3			ld hl, (os_view_de) 
1458 cd c3 15			call display_dump_at_hl 
145b			 
145b 18 68			jr .bpschk 
145d fe 34		.bps4:  cp '4' 
145f 20 08			jr nz, .bps5 
1461			 
1461			        ; display bc 
1461 2a 49 e3			ld hl, (os_view_bc) 
1464 cd c3 15			call display_dump_at_hl 
1467			 
1467 18 5c			jr .bpschk 
1469 fe 35		.bps5:  cp '5' 
146b 20 08		        jr nz, .bps7 
146d			 
146d				; display cur ptr 
146d 2a 2b eb			ld hl, (cli_ptr) 
1470 cd c3 15			call display_dump_at_hl 
1473			 
1473 18 50			jr .bpschk 
1475 fe 36		.bps7:  cp '6' 
1477 20 08			jr nz, .bps8b 
1479				 
1479				; display cur orig ptr 
1479 2a 29 eb			ld hl, (cli_origptr) 
147c cd c3 15			call display_dump_at_hl 
147f 18 44			jr .bpschk 
1481 fe 37		.bps8b:  cp '7' 
1483 20 08			jr nz, .bps9 
1485				 
1485				; display dsp 
1485 2a 0d eb			ld hl, (cli_data_sp) 
1488 cd c3 15			call display_dump_at_hl 
148b			 
148b 18 38			jr .bpschk 
148d fe 39		.bps9:  cp '9' 
148f 20 05			jr nz, .bps8c 
1491				 
1491				; display SP 
1491			;	ld hl, sp 
1491 cd c3 15			call display_dump_at_hl 
1494			 
1494 18 2f			jr .bpschk 
1496 fe 38		.bps8c:  cp '8' 
1498 20 08			jr nz, .bps8d 
149a				 
149a				; display rsp 
149a 2a 11 eb			ld hl, (cli_ret_sp) 
149d cd c3 15			call display_dump_at_hl 
14a0			 
14a0 18 23			jr .bpschk 
14a2 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14a4 20 05			jr nz, .bps8 
14a6 cd fa 16			call monitor 
14a9			 
14a9 18 1a			jr .bpschk 
14ab fe 30		.bps8:  cp '0' 
14ad 20 16			jr nz, .bpschk 
14af			 
14af 21 1f ed				ld hl, display_fb1 
14b2 22 db eb				ld (display_fb_active), hl 
14b5 cd a8 09				call update_display 
14b8			 
14b8				;ld a, (os_view_af) 
14b8 2a 4d e3			ld hl, (os_view_hl) 
14bb ed 5b 4b e3		ld de, (os_view_de) 
14bf ed 4b 49 e3		ld bc, (os_view_bc) 
14c3 f1				pop af 
14c4 c9				ret 
14c5			 
14c5			.bpschk:   
14c5 cd fa 08			call delay1s 
14c8 3e 9f		ld a,display_row_4 + display_cols - 1 
14ca 11 02 19		        ld de, endprg 
14cd cd 98 09			call str_at_display 
14d0 cd a8 09			call update_display 
14d3 cd b6 59			call cin_wait 
14d6			 
14d6 c3 26 14			jp .bps1 
14d9			 
14d9			 
14d9			display_reg_state: 
14d9			 
14d9				; to restore afterwards 
14d9			 
14d9 d5				push de 
14da c5				push bc 
14db e5				push hl 
14dc f5				push af 
14dd			 
14dd				; for use in here 
14dd			 
14dd c5				push bc 
14de d5				push de 
14df e5				push hl 
14e0 f5				push af 
14e1			 
14e1 cd 85 09			call clear_display 
14e4			 
14e4 11 99 15			ld de, .regstate 
14e7 3e 00			ld a, display_row_1 
14e9 cd 98 09			call str_at_display 
14ec			 
14ec				; display debug step 
14ec			 
14ec			 
14ec 11 7a ee			ld de, debug_mark 
14ef 3e 25			ld a, display_row_1+display_cols-3 
14f1 cd 98 09			call str_at_display 
14f4			 
14f4				; display a 
14f4 11 b5 15			ld de, .regstatea 
14f7 3e 28			ld a, display_row_2 
14f9 cd 98 09			call str_at_display 
14fc			 
14fc e1				pop hl 
14fd			;	ld h,0 
14fd			;	ld l, a 
14fd 3e 2b			ld a, display_row_2+3 
14ff cd 84 13			call display_word_at 
1502			 
1502			 
1502				; display hl 
1502			 
1502			 
1502 11 a9 15			ld de, .regstatehl 
1505 3e 32			ld a, display_row_2+10 
1507 cd 98 09			call str_at_display 
150a			 
150a e1				pop hl 
150b 3e 35			ld a, display_row_2+13 
150d cd 84 13			call display_word_at 
1510			 
1510				 
1510				; display de 
1510			 
1510 11 ad 15			ld de, .regstatede 
1513 3e 50			ld a, display_row_3 
1515 cd 98 09			call str_at_display 
1518			 
1518 e1				pop hl 
1519			;	ld h,d 
1519			;	ld l, e 
1519 3e 53			ld a, display_row_3+3 
151b cd 84 13			call display_word_at 
151e			 
151e			 
151e				; display bc 
151e			 
151e 11 b1 15			ld de, .regstatebc 
1521 3e 5a			ld a, display_row_3+10 
1523 cd 98 09			call str_at_display 
1526			 
1526 e1				pop hl 
1527			;	ld h,b 
1527			;	ld l, c 
1527 3e 5d			ld a, display_row_3+13 
1529 cd 84 13			call display_word_at 
152c			 
152c			 
152c				; display dsp 
152c			 
152c 11 b9 15			ld de, .regstatedsp 
152f 3e 78			ld a, display_row_4 
1531 cd 98 09			call str_at_display 
1534			 
1534				 
1534 2a 0d eb			ld hl,(cli_data_sp) 
1537 3e 7c			ld a, display_row_4+4 
1539 cd 84 13			call display_word_at 
153c			 
153c				; display rsp 
153c			 
153c 11 be 15			ld de, .regstatersp 
153f 3e 82			ld a, display_row_4+10 
1541 cd 98 09			call str_at_display 
1544			 
1544				 
1544 2a 11 eb			ld hl,(cli_ret_sp) 
1547 3e 86			ld a, display_row_4+14 
1549 cd 84 13			call display_word_at 
154c			 
154c cd a8 09			call update_display 
154f			 
154f			;	call delay1s 
154f			;	call delay1s 
154f			;	call delay1s 
154f			 
154f			 
154f			;	call next_page_prompt 
154f			 
154f				; restore  
154f			 
154f f1				pop af 
1550 e1				pop hl 
1551 c1				pop bc 
1552 d1				pop de 
1553 c9				ret 
1554			 
1554 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1568 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
157d .. 00		.ptrstate:	db "Ptr State",0 
1587 .. 00		.ptrcliptr:     db "cli_ptr",0 
158f .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1599 .. 00		.regstate:	db "Reg State (1/0)",0 
15a9 .. 00		.regstatehl:	db "HL:",0 
15ad .. 00		.regstatede:	db "DE:",0 
15b1 .. 00		.regstatebc:	db "BC:",0 
15b5 .. 00		.regstatea:	db "A :",0 
15b9 .. 00		.regstatedsp:	db "DSP:",0 
15be .. 00		.regstatersp:	db "RSP:",0 
15c3			 
15c3			display_dump_at_hl: 
15c3 e5				push hl 
15c4 d5				push de 
15c5 c5				push bc 
15c6 f5				push af 
15c7			 
15c7 22 83 e6			ld (os_cur_ptr),hl	 
15ca cd 85 09			call clear_display 
15cd cd 0c 18			call dumpcont 
15d0			;	call delay1s 
15d0			;	call next_page_prompt 
15d0			 
15d0			 
15d0 f1				pop af 
15d1 c1				pop bc 
15d2 d1				pop de 
15d3 e1				pop hl 
15d4 c9				ret 
15d5			 
15d5			;if ENABLE_BASIC 
15d5			;	include "nascombasic.asm" 
15d5			;	basic: 
15d5			;	include "forth/FORTH.ASM" 
15d5			;endif 
15d5			 
15d5			; eof 
15d5			 
15d5			 
# End of file firmware_diags.asm
15d5			  
15d5			  
15d5			  
15d5			  
15d5			; eof  
15d5			  
# End of file firmware.asm
15d5			 
15d5			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
15d5			;if BASE_KEV  
15d5			;baseram: equ 08000h 
15d5			;endif 
15d5			 
15d5			;if BASE_SC114 
15d5			;baseram:     equ    endofcode 
15d5			;endif 
15d5			 
15d5			 
15d5			; start system 
15d5			 
15d5			coldstart: 
15d5				; set sp 
15d5				; di/ei 
15d5			 
15d5 f3				di 
15d6 31 00 f0			ld sp, tos 
15d9			;	ei 
15d9			 
15d9			 
15d9				; disable breakpoint by default 
15d9			 
15d9 3e 2a			ld a,'*' 
15db 32 51 e3			ld (os_view_disable),a 
15de			 
15de				; init hardware 
15de			 
15de				; init keyboard and screen hardware 
15de			 
15de cd 03 01			call hardware_init 
15e1			 
15e1			 
15e1				; detect if any keys are held down to enable breakpoints at start up 
15e1			 
15e1 cd be 59			call cin  
15e4 fe 00			cp 0 
15e6 28 03			jr z, .nokeys 
15e8			 
15e8				;call hardware_diags 
15e8 cd 12 12			call config 
15eb			 
15eb			;	ld de, .bpen 
15eb			;	ld a, display_row_4 
15eb			;	call str_at_display 
15eb			;	call update_display 
15eb			; 
15eb			;	ld a,0 
15eb			;	ld (os_view_disable),a 
15eb			; 
15eb			;.bpwait: 
15eb			;	call cin 
15eb			;	cp 0 
15eb			;	jr z, .bpwait 
15eb			;	jr .nokeys 
15eb			; 
15eb			; 
15eb			;.bpen:  db "Break points enabled!",0 
15eb			 
15eb			 
15eb			 
15eb			 
15eb			 
15eb			 
15eb			.nokeys: 
15eb			 
15eb			 
15eb				 
15eb			 
15eb			;jp  testkey 
15eb			 
15eb			;call storage_get_block_0 
15eb			; 
15eb			;ld hl, 0 
15eb			;ld de, store_page 
15eb			;call storage_read_block 
15eb			 
15eb				 
15eb			;ld hl, 10 
15eb			;ld de, store_page 
15eb			;call storage_read_block 
15eb			 
15eb			 
15eb			 
15eb			 
15eb			 
15eb			;stop:	nop 
15eb			;	jp stop 
15eb			 
15eb			 
15eb			 
15eb			main: 
15eb cd 85 09			call clear_display 
15ee cd a8 09			call update_display 
15f1			 
15f1			 
15f1			 
15f1			;	call testlcd 
15f1			 
15f1			 
15f1			 
15f1 cd ca 1c			call forth_init 
15f4			 
15f4			 
15f4			warmstart: 
15f4 cd a0 1c			call forth_warmstart 
15f7			 
15f7				; run startup word load 
15f7			        ; TODO prevent this running at warmstart after crash  
15f7			 
15f7				if STARTUP_ENABLE 
15f7 cd 04 56				call forth_startup 
15fa				endif 
15fa			 
15fa				; show free memory after boot 
15fa 11 94 16			ld de, freeram 
15fd 3e 00			ld a, display_row_1 
15ff cd 98 09			call str_at_display 
1602			 
1602			; Or use heap_size word???? 
1602 21 46 e3			ld hl, heap_end 
1605 11 e6 59			ld de, heap_start 
1608 ed 52			sbc hl, de 
160a e5				push hl 
160b 7c				ld a,h	         	 
160c 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
160f cd b3 0e			call hexout 
1612 e1			   	pop hl 
1613			 
1613 7d				ld a,l 
1614 21 67 e6			ld hl, os_word_scratch+2 
1617 cd b3 0e			call hexout 
161a 21 69 e6			ld hl, os_word_scratch+4 
161d 3e 00			ld a, 0 
161f 77				ld (hl),a 
1620 11 65 e6			ld de, os_word_scratch 
1623 3e 0d			ld a, display_row_1 + 13 
1625 cd 98 09			call str_at_display 
1628 cd a8 09			call update_display 
162b			 
162b			 
162b				;call demo 
162b			 
162b			 
162b				; init scratch input area for cli commands 
162b			 
162b 21 87 e6			ld hl, os_cli_cmd 
162e 3e 00			ld a,0 
1630 77				ld (hl),a 
1631 23				inc hl 
1632 77				ld (hl),a 
1633			 
1633 3e 00			ld a,0 
1635 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1638			 
1638 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
163b 32 84 e6			ld (os_cur_ptr+1),a	 
163e			 
163e 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1641 32 66 e6			ld (os_word_scratch+1),a	 
1644				 
1644			 
1644				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1644 21 87 e6			ld hl, os_cli_cmd 
1647			 
1647 3e 00			ld a, 0		 ; init cli input 
1649 77				ld (hl), a 
164a 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
164c			cli: 
164c				; show cli prompt 
164c				;push af 
164c				;ld a, 0 
164c				;ld de, prompt 
164c				;call str_at_display 
164c			 
164c				;call update_display 
164c				;pop af 
164c				;inc a 
164c				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
164c 0e 00			ld c, 0 
164e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1650 1e 28			ld e, 40 
1652			 
1652 21 87 e6			ld hl, os_cli_cmd 
1655			 
1655				STACKFRAME OFF $fefe $9f9f 
1655				if DEBUG_STACK_IMB 
1655					if OFF 
1655						exx 
1655						ld de, $fefe 
1655						ld a, d 
1655						ld hl, curframe 
1655						call hexout 
1655						ld a, e 
1655						ld hl, curframe+2 
1655						call hexout 
1655						ld hl, $fefe 
1655						push hl 
1655						ld hl, $9f9f 
1655						push hl 
1655						exx 
1655					endif 
1655				endif 
1655			endm 
# End of macro STACKFRAME
1655			 
1655 cd df 0b			call input_str 
1658			 
1658				STACKFRAMECHK OFF $fefe $9f9f 
1658				if DEBUG_STACK_IMB 
1658					if OFF 
1658						exx 
1658						ld hl, $9f9f 
1658						pop de   ; $9f9f 
1658						call cmp16 
1658						jr nz, .spnosame 
1658						ld hl, $fefe 
1658						pop de   ; $fefe 
1658						call cmp16 
1658						jr z, .spfrsame 
1658						.spnosame: call showsperror 
1658						.spfrsame: nop 
1658						exx 
1658					endif 
1658				endif 
1658			endm 
# End of macro STACKFRAMECHK
1658			 
1658				; copy input to last command 
1658			 
1658 21 87 e6			ld hl, os_cli_cmd 
165b 11 86 e7			ld de, os_last_cmd 
165e 01 ff 00			ld bc, 255 
1661 ed b0			ldir 
1663			 
1663				; wipe current buffer 
1663			 
1663			;	ld a, 0 
1663			;	ld hl, os_cli_cmd 
1663			;	ld de, os_cli_cmd+1 
1663			;	ld bc, 254 
1663			;	ldir 
1663				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1663			;	call strcpy 
1663			;	ld a, 0 
1663			;	ld (hl), a 
1663			;	inc hl 
1663			;	ld (hl), a 
1663			;	inc hl 
1663			;	ld (hl), a 
1663			 
1663				; switch frame buffer to program  
1663			 
1663 21 1f ed				ld hl, display_fb1 
1666 22 db eb				ld (display_fb_active), hl 
1669			 
1669			;	nop 
1669				STACKFRAME ON $fbfe $8f9f 
1669				if DEBUG_STACK_IMB 
1669					if ON 
1669						exx 
1669						ld de, $fbfe 
1669						ld a, d 
1669						ld hl, curframe 
1669						call hexout 
1669						ld a, e 
1669						ld hl, curframe+2 
1669						call hexout 
1669						ld hl, $fbfe 
1669						push hl 
1669						ld hl, $8f9f 
1669						push hl 
1669						exx 
1669					endif 
1669				endif 
1669			endm 
# End of macro STACKFRAME
1669				; first time into the parser so pass over the current scratch pad 
1669 21 87 e6			ld hl,os_cli_cmd 
166c				; tokenise the entered statement(s) in HL 
166c cd 43 1d			call forthparse 
166f			        ; exec forth statements in top of return stack 
166f cd 83 1d			call forthexec 
1672				;call forthexec_cleanup 
1672			;	call parsenext 
1672			 
1672				STACKFRAMECHK ON $fbfe $8f9f 
1672				if DEBUG_STACK_IMB 
1672					if ON 
1672						exx 
1672						ld hl, $8f9f 
1672						pop de   ; $8f9f 
1672						call cmp16 
1672						jr nz, .spnosame 
1672						ld hl, $fbfe 
1672						pop de   ; $fbfe 
1672						call cmp16 
1672						jr z, .spfrsame 
1672						.spnosame: call showsperror 
1672						.spfrsame: nop 
1672						exx 
1672					endif 
1672				endif 
1672			endm 
# End of macro STACKFRAMECHK
1672				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1672			 
1672 3e 78			ld a, display_row_4 
1674 11 a6 16			ld de, endprog 
1677			 
1677 cd a8 09			call update_display		 
167a			 
167a cd 04 19			call next_page_prompt 
167d			 
167d				; switch frame buffer to cli 
167d			 
167d 21 c0 ed				ld hl, display_fb0 
1680 22 db eb				ld (display_fb_active), hl 
1683			 
1683			 
1683 cd 85 09		        call clear_display 
1686 cd a8 09			call update_display		 
1689			 
1689 21 87 e6			ld hl, os_cli_cmd 
168c			 
168c 3e 00			ld a, 0		 ; init cli input 
168e 77				ld (hl), a 
168f			 
168f				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
168f			 
168f				; now on last line 
168f			 
168f				; TODO scroll screen up 
168f			 
168f				; TODO instead just clear screen and place at top of screen 
168f			 
168f			;	ld a, 0 
168f			;	ld (f_cursor_ptr),a 
168f			 
168f				;call clear_display 
168f				;call update_display 
168f			 
168f				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
168f 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1691 c3 4c 16			jp cli 
1694			 
1694 .. 00		freeram: db "Free bytes: $",0 
16a2 ..			asc: db "1A2F" 
16a6 .. 00		endprog: db "End prog...",0 
16b2			 
16b2			testenter2:   
16b2 21 92 e3			ld hl,scratch+50 
16b5 22 83 e6			ld (os_cur_ptr),hl 
16b8 c3 4c 16			jp cli 
16bb			 
16bb			testenter:  
16bb			 
16bb 21 a2 16			ld hl,asc 
16be			;	ld a,(hl) 
16be			;	call nibble2val 
16be cd 09 0f			call get_byte 
16c1			 
16c1			 
16c1			;	ld a,(hl) 
16c1			;	call atohex 
16c1			 
16c1			;	call fourehexhl 
16c1 32 92 e3			ld (scratch+50),a 
16c4			 
16c4			 
16c4			 
16c4 21 a4 16			ld hl,asc+2 
16c7			;	ld a, (hl) 
16c7			;	call nibble2val 
16c7 cd 09 0f			call get_byte 
16ca			 
16ca			;	call fourehexhl 
16ca 32 94 e3			ld (scratch+52),a 
16cd				 
16cd 21 92 e3			ld hl,scratch+50 
16d0 22 83 e6			ld (os_cur_ptr),hl 
16d3 c3 4c 16			jp cli 
16d6			 
16d6			enter:	 
16d6 3a 64 e3			ld a,(scratch+4) 
16d9 fe 00			cp 0 
16db 28 0c			jr z, .entercont 
16dd				; no, not a null term line so has an address to work out.... 
16dd			 
16dd 21 62 e3			ld hl,scratch+2 
16e0 cd 69 0f			call get_word_hl 
16e3			 
16e3 22 83 e6			ld (os_cur_ptr),hl	 
16e6 c3 4c 16			jp cli 
16e9			 
16e9			 
16e9			.entercont:  
16e9			 
16e9 21 62 e3			ld hl, scratch+2 
16ec cd 09 0f			call get_byte 
16ef			 
16ef 2a 83 e6		   	ld hl,(os_cur_ptr) 
16f2 77					ld (hl),a 
16f3 23					inc hl 
16f4 22 83 e6				ld (os_cur_ptr),hl 
16f7				 
16f7			; get byte  
16f7			 
16f7			 
16f7 c3 4c 16			jp cli 
16fa			 
16fa			 
16fa			; basic monitor support 
16fa			 
16fa			monitor: 
16fa				;  
16fa cd 85 09			call clear_display 
16fd 3e 00			ld a, 0 
16ff 11 47 17			ld de, .monprompt 
1702 cd 98 09			call str_at_display 
1705 cd a8 09			call update_display 
1708			 
1708				; get a monitor command 
1708			 
1708 0e 00			ld c, 0     ; entry at top left 
170a 16 64			ld d, 100   ; max buffer size 
170c 1e 0f			ld e, 15    ; input scroll area 
170e 3e 00			ld a, 0     ; init string 
1710 21 5e e5			ld hl, os_input 
1713 77				ld (hl), a 
1714 23				inc hl 
1715 77				ld (hl), a 
1716 21 5e e5			ld hl, os_input 
1719 3e 01			ld a, 1     ; init string 
171b cd df 0b			call input_str 
171e			 
171e cd 85 09		        call clear_display 
1721 cd a8 09			call update_display		 
1724			 
1724 3a 5e e5			ld a, (os_input) 
1727 cd 07 10			call toUpper 
172a fe 48		        cp 'H' 
172c 28 6f		        jr z, .monhelp 
172e fe 44			cp 'D'		; dump 
1730 ca be 17			jp z, .mondump	 
1733 fe 43			cp 'C'		; dump 
1735 ca d8 17			jp z, .moncdump	 
1738 fe 4d			cp 'M'		; dump 
173a ca 49 17			jp z, .moneditstart 
173d fe 55			cp 'U'		; dump 
173f 28 14			jr z, .monedit	 
1741 fe 51			cp 'Q'		; dump 
1743 c8				ret z	 
1744			 
1744			 
1744				; TODO "S" to access symbol by name and not need the address 
1744				; TODO "F" to find a string in memory 
1744			 
1744 c3 fa 16			jp monitor 
1747			 
1747 .. 00		.monprompt: db ">", 0 
1749			 
1749			.moneditstart: 
1749				; get starting address 
1749			 
1749 21 60 e5			ld hl,os_input+2 
174c cd 69 0f			call get_word_hl 
174f			 
174f 22 83 e6			ld (os_cur_ptr),hl	 
1752			 
1752 c3 fa 16			jp monitor 
1755			 
1755			.monedit: 
1755				; get byte to load 
1755			 
1755 21 60 e5			ld hl,os_input+2 
1758 cd 09 0f			call get_byte 
175b			 
175b				; get address to update 
175b 2a 83 e6			ld hl, (os_cur_ptr) 
175e			 
175e				; update byte 
175e			 
175e 77				ld (hl), a 
175f			 
175f				; move to next address and save it 
175f			 
175f 23				inc hl 
1760 22 83 e6			ld (os_cur_ptr),hl	 
1763			 
1763 c3 fa 16			jp monitor 
1766			 
1766			 
1766 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
177a .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1796 .. 00		.monhelptext3:  db "Q-Quit",0 
179d			        
179d			.monhelp: 
179d 3e 00			ld a, display_row_1 
179f 11 66 17		        ld de, .monhelptext1 
17a2			 
17a2 cd 98 09			call str_at_display 
17a5 3e 28			ld a, display_row_2 
17a7 11 7a 17		        ld de, .monhelptext2 
17aa					 
17aa cd 98 09			call str_at_display 
17ad 3e 50			ld a, display_row_3 
17af 11 96 17		        ld de, .monhelptext3 
17b2					 
17b2 cd 98 09			call str_at_display 
17b5 cd a8 09			call update_display		 
17b8			 
17b8 cd 04 19			call next_page_prompt 
17bb c3 fa 16			jp monitor 
17be			 
17be			.mondump:    
17be 21 60 e5			ld hl,os_input+2 
17c1 cd 69 0f			call get_word_hl 
17c4			 
17c4 22 83 e6			ld (os_cur_ptr),hl	 
17c7 cd 0c 18			call dumpcont 
17ca 3e 78			ld a, display_row_4 
17cc 11 a6 16			ld de, endprog 
17cf			 
17cf cd a8 09			call update_display		 
17d2			 
17d2 cd 04 19			call next_page_prompt 
17d5 c3 fa 16			jp monitor 
17d8			.moncdump: 
17d8 cd 0c 18			call dumpcont 
17db 3e 78			ld a, display_row_4 
17dd 11 a6 16			ld de, endprog 
17e0			 
17e0 cd a8 09			call update_display		 
17e3			 
17e3 cd 04 19			call next_page_prompt 
17e6 c3 fa 16			jp monitor 
17e9			 
17e9			 
17e9			; TODO symbol access  
17e9			 
17e9			.symbols:     ;; A list of symbols that can be called up  
17e9 c0 ed			dw display_fb0 
17eb .. 00			db "fb0",0  
17ef 65 eb		     	dw store_page 
17f1 .. 00			db "store_page",0 
17fc			 
17fc			 
17fc			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
17fc			 
17fc 3a 61 e3			ld a,(scratch+1) 
17ff fe 00			cp 0 
1801 28 09			jr z, dumpcont 
1803			 
1803				; no, not a null term line so has an address to work out.... 
1803			 
1803 21 62 e3			ld hl,scratch+2 
1806 cd 69 0f			call get_word_hl 
1809			 
1809 22 83 e6			ld (os_cur_ptr),hl	 
180c			 
180c			 
180c			 
180c			dumpcont: 
180c			 
180c				; dump bytes at ptr 
180c			 
180c			 
180c 3e 00			ld a, display_row_1 
180e 2a db eb			ld hl, (display_fb_active) 
1811 cd b2 0b			call addatohl 
1814 cd 3c 18			call .dumpbyterow 
1817			 
1817 3e 28			ld a, display_row_2 
1819 2a db eb			ld hl, (display_fb_active) 
181c cd b2 0b			call addatohl 
181f cd 3c 18			call .dumpbyterow 
1822			 
1822			 
1822 3e 50			ld a, display_row_3 
1824 2a db eb			ld hl, (display_fb_active) 
1827 cd b2 0b			call addatohl 
182a cd 3c 18			call .dumpbyterow 
182d			 
182d 3e 78			ld a, display_row_4 
182f 2a db eb			ld hl, (display_fb_active) 
1832 cd b2 0b			call addatohl 
1835 cd 3c 18			call .dumpbyterow 
1838			 
1838 cd a8 09			call update_display 
183b			;		jp cli 
183b c9				ret 
183c			 
183c			.dumpbyterow: 
183c			 
183c				;push af 
183c			 
183c e5				push hl 
183d			 
183d				; calc where to poke the ascii 
183d			if display_cols == 20 
183d				ld a, 16 
183d			else 
183d 3e 1f			ld a, 31 
183f			endif 
183f			 
183f cd b2 0b			call addatohl 
1842 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
1845			 
1845			 
1845			; display decoding address 
1845 2a 83 e6		   	ld hl,(os_cur_ptr) 
1848			 
1848 7c				ld a,h 
1849 e1				pop hl 
184a e5				push hl 
184b			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
184b cd b3 0e			call hexout 
184e 2a 83 e6		   	ld hl,(os_cur_ptr) 
1851			 
1851 7d				ld a,l 
1852 e1				pop hl 
1853 23				inc hl 
1854 23				inc hl 
1855 e5				push hl 
1856			;	ld hl, os_word_scratch+2 
1856 cd b3 0e			call hexout 
1859 e1				pop hl 
185a 23				inc hl 
185b 23				inc hl 
185c				;ld hl, os_word_scratch+4 
185c 3e 3a			ld a, ':' 
185e 77				ld (hl),a 
185f 23				inc hl 
1860				;ld a, 0 
1860				;ld (hl),a 
1860				;ld de, os_word_scratch 
1860				;pop af 
1860				;push af 
1860			;		ld a, display_row_2 
1860			;		call str_at_display 
1860			;		call update_display 
1860			 
1860			 
1860			;pop af 
1860			;	add 5 
1860			 
1860			if display_cols == 20 
1860				ld b, 4 
1860			else 
1860 06 08			ld b, 8 
1862			endif	 
1862			 
1862			.dumpbyte: 
1862 c5				push bc 
1863 e5				push hl 
1864			 
1864			 
1864 2a 83 e6		   	ld hl,(os_cur_ptr) 
1867 7e					ld a,(hl) 
1868			 
1868					; poke the ascii to display 
1868 2a 65 e6				ld hl,(os_word_scratch) 
186b 77					ld (hl),a 
186c 23					inc hl 
186d 22 65 e6				ld (os_word_scratch),hl 
1870			 
1870					 
1870			 
1870			 
1870 e1					pop hl 
1871 e5					push hl 
1872			 
1872 cd b3 0e				call hexout 
1875			 
1875					 
1875 2a 83 e6		   	ld hl,(os_cur_ptr) 
1878 23				inc hl 
1879 22 83 e6		   	ld (os_cur_ptr),hl 
187c			 
187c e1					pop hl 
187d 23					inc hl 
187e 23					inc hl 
187f 23					inc hl 
1880			 
1880			 
1880			 
1880					;ld a,0 
1880					;ld (os_word_scratch+2),a 
1880					;pop af 
1880					;push af 
1880			 
1880					;ld de, os_word_scratch 
1880					;call str_at_display 
1880			;		call update_display 
1880			;		pop af 
1880 c1					pop bc 
1881 c6 03				add 3 
1883 10 dd			djnz .dumpbyte 
1885			 
1885				 
1885			 
1885 c9				ret 
1886			 
1886			jump:	 
1886			 
1886 21 62 e3			ld hl,scratch+2 
1889 cd 69 0f			call get_word_hl 
188c				;ld hl,(scratch+2) 
188c				;call fourehexhl 
188c			 
188c 22 83 e6			ld (os_cur_ptr),hl	 
188f			 
188f e9				jp (hl) 
1890			 
1890			 
1890			 
1890			; TODO implement a basic monitor mode to start with 
1890			 
1890			 
1890			 
1890			 
1890			 
1890			 
1890			 
1890			 
1890			 
1890			; testing and demo code during development 
1890			 
1890			 
1890 .. 00		str1: db "Enter some text...",0 
18a3 .. 00		clear: db "                    ",0 
18b8			 
18b8			demo: 
18b8			 
18b8			 
18b8			 
18b8			;	call update_display 
18b8			 
18b8				; init scratch input area for testing 
18b8 21 60 e3			ld hl, scratch	 
18bb 3e 00			ld a,0 
18bd 77				ld (hl),a 
18be			 
18be			 
18be 3e 28		            LD   A, display_row_2 
18c0			;            CALL fLCD_Pos       ;Position cursor to location in A 
18c0 11 90 18		            LD   DE, str1 
18c3 cd 98 09			call str_at_display 
18c6			 
18c6			;            CALL fLCD_Str       ;Display string pointed to by DE 
18c6			cloop:	 
18c6 3e 50		            LD   A, display_row_3 
18c8			;            CALL fLCD_Pos       ;Position cursor to location in A 
18c8 11 a3 18		            LD   DE, clear 
18cb			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
18cb cd 98 09				call str_at_display 
18ce 3e 78			ld a, display_row_4 
18d0 11 00 19			ld de, prompt 
18d3			 
18d3 cd 98 09				call str_at_display 
18d6 cd a8 09			call update_display 
18d9			 
18d9 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18db 16 0a			ld d, 10 
18dd 21 60 e3			ld hl, scratch	 
18e0 cd df 0b			call input_str 
18e3			 
18e3			;	call clear_display 
18e3			;'	call update_display 
18e3			 
18e3 3e 00		            LD   A, display_row_1 
18e5			;            CALL fLCD_Pos       ;Position cursor to location in A 
18e5 11 a3 18		            LD   DE, clear 
18e8 cd 98 09				call str_at_display 
18eb			;            CALL fLCD_Str       ;Display string pointed to by DE 
18eb 3e 00		            LD   A, display_row_1 
18ed			;            CALL fLCD_Pos       ;Position cursor to location in A 
18ed 11 60 e3		            LD   DE, scratch 
18f0			;            CALL fLCD_Str       ;Display string pointed to by DE 
18f0 cd 98 09				call str_at_display 
18f3 cd a8 09			call update_display 
18f6			 
18f6 3e 00				ld a,0 
18f8 21 60 e3			ld hl, scratch 
18fb 77				ld (hl),a 
18fc			 
18fc 00				nop 
18fd c3 c6 18			jp cloop 
1900			 
1900			 
1900			 
1900			; OS Prompt 
1900			 
1900 .. 00		prompt: db ">",0 
1902 .. 00		endprg: db "?",0 
1904			 
1904			 
1904			; handy next page prompt 
1904			next_page_prompt: 
1904 e5				push hl 
1905 d5				push de 
1906 f5				push af 
1907 c5				push bc 
1908			 
1908 3e 9f			ld a,display_row_4 + display_cols - 1 
190a 11 02 19		        ld de, endprg 
190d cd 98 09			call str_at_display 
1910 cd a8 09			call update_display 
1913 cd b6 59			call cin_wait 
1916 c1				pop bc 
1917 f1				pop af 
1918 d1				pop de 
1919 e1				pop hl 
191a			 
191a			 
191a c9				ret 
191b			 
191b			 
191b			; forth parser 
191b			 
191b			; My forth kernel 
191b			include "forth_kernel.asm" 
191b			; 
191b			; kernel to the forth OS 
191b			 
191b			DS_TYPE_STR: equ 1     ; string type 
191b			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
191b			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
191b			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
191b			 
191b			FORTH_PARSEV1: equ 0 
191b			FORTH_PARSEV2: equ 0 
191b			FORTH_PARSEV3: equ 0 
191b			FORTH_PARSEV4: equ 0 
191b			FORTH_PARSEV5: equ 1 
191b			 
191b			;if FORTH_PARSEV5 
191b			;	FORTH_END_BUFFER: equ 0 
191b			;else 
191b			FORTH_END_BUFFER: equ 127 
191b			;endif 
191b			 
191b			FORTH_TRUE: equ 1 
191b			FORTH_FALSE: equ 0 
191b			 
191b			if FORTH_PARSEV4 
191b			include "forth_stackops.asm" 
191b			endif 
191b			 
191b			if FORTH_PARSEV5 
191b			include "forth_stackopsv5.asm" 
191b			 
191b			; Stack operations for v5 parser on wards 
191b			; * DATA stack 
191b			; * LOOP stack 
191b			; * RETURN stack 
191b			 
191b			 
191b			 
191b			FORTH_CHK_DSP_UNDER: macro 
191b				push hl 
191b				push de 
191b				ld hl,(cli_data_sp) 
191b				ld de, cli_data_stack 
191b				call cmp16 
191b				jp c, fault_dsp_under 
191b				pop de 
191b				pop hl 
191b				endm 
191b			 
191b			 
191b			FORTH_CHK_RSP_UNDER: macro 
191b				push hl 
191b				push de 
191b				ld hl,(cli_ret_sp) 
191b				ld de, cli_ret_stack 
191b				call cmp16 
191b				jp c, fault_rsp_under 
191b				pop de 
191b				pop hl 
191b				endm 
191b			 
191b			FORTH_CHK_LOOP_UNDER: macro 
191b				push hl 
191b				push de 
191b				ld hl,(cli_loop_sp) 
191b				ld de, cli_loop_stack 
191b				call cmp16 
191b				jp c, fault_loop_under 
191b				pop de 
191b				pop hl 
191b				endm 
191b			 
191b			FORTH_ERR_TOS_NOTSTR: macro 
191b				; TOSO might need more for checks when used 
191b				push af 
191b				ld a,(hl) 
191b				cp DS_TYPE_STR 
191b				jp nz, type_faultn   
191b				pop af 
191b				endm 
191b			 
191b			FORTH_ERR_TOS_NOTNUM: macro 
191b				push af 
191b				ld a,(hl) 
191b				cp DS_TYPE_INUM 
191b				jp nz, type_faultn   
191b				pop af 
191b				endm 
191b			 
191b			 
191b			; increase data stack pointer and save hl to it 
191b				 
191b			FORTH_DSP_NEXT: macro 
191b				call macro_forth_dsp_next 
191b				endm 
191b			 
191b			 
191b			macro_forth_dsp_next: 
191b				if DEBUG_FORTH_STACK_GUARD 
191b cd ce 56				call check_stacks 
191e				endif 
191e e5				push hl 
191f d5				push de 
1920 eb				ex de,hl 
1921 2a 0d eb			ld hl,(cli_data_sp) 
1924 23				inc hl 
1925 23				inc hl 
1926			 
1926			; PARSEV5 
1926 23				inc hl 
1927 22 0d eb			ld (cli_data_sp),hl 
192a 73				ld (hl), e 
192b 23				inc hl 
192c 72				ld (hl), d 
192d d1				pop de 
192e e1				pop hl 
192f				if DEBUG_FORTH_STACK_GUARD 
192f cd ce 56				call check_stacks 
1932				endif 
1932 c9				ret 
1933			 
1933			 
1933			; increase ret stack pointer and save hl to it 
1933				 
1933			FORTH_RSP_NEXT: macro 
1933				call macro_forth_rsp_next 
1933				endm 
1933			 
1933			macro_forth_rsp_next: 
1933				if DEBUG_FORTH_STACK_GUARD 
1933 cd ce 56				call check_stacks 
1936				endif 
1936 e5				push hl 
1937 d5				push de 
1938 eb				ex de,hl 
1939 2a 11 eb			ld hl,(cli_ret_sp) 
193c 23				inc hl 
193d 23				inc hl 
193e 22 11 eb			ld (cli_ret_sp),hl 
1941 73				ld (hl), e 
1942 23				inc hl 
1943 72				ld (hl), d 
1944 d1				pop de 
1945 e1				pop hl 
1946				if DEBUG_FORTH_STACK_GUARD 
1946 cd ce 56				call check_stacks 
1949				endif 
1949 c9				ret 
194a			 
194a			; get current ret stack pointer and save to hl  
194a				 
194a			FORTH_RSP_TOS: macro 
194a				call macro_forth_rsp_tos 
194a				endm 
194a			 
194a			macro_forth_rsp_tos: 
194a				;push de 
194a 2a 11 eb			ld hl,(cli_ret_sp) 
194d cd 85 19			call loadhlptrtohl 
1950				;ld e, (hl) 
1950				;inc hl 
1950				;ld d, (hl) 
1950				;ex de, hl 
1950					if DEBUG_FORTH_WORDS 
1950			;			DMARK "RST" 
1950						CALLMONITOR 
1950 cd ff 13			call break_point_state  
1953				endm  
# End of macro CALLMONITOR
1953					endif 
1953				;pop de 
1953 c9				ret 
1954			 
1954			; pop ret stack pointer 
1954				 
1954			FORTH_RSP_POP: macro 
1954				call macro_forth_rsp_pop 
1954				endm 
1954			 
1954			 
1954			macro_forth_rsp_pop: 
1954				if DEBUG_FORTH_STACK_GUARD 
1954			;		DMARK "RPP" 
1954 cd ce 56				call check_stacks 
1957					FORTH_CHK_RSP_UNDER 
1957 e5				push hl 
1958 d5				push de 
1959 2a 11 eb			ld hl,(cli_ret_sp) 
195c 11 cb ea			ld de, cli_ret_stack 
195f cd d0 0b			call cmp16 
1962 da e2 57			jp c, fault_rsp_under 
1965 d1				pop de 
1966 e1				pop hl 
1967				endm 
# End of macro FORTH_CHK_RSP_UNDER
1967				endif 
1967 e5				push hl 
1968 2a 11 eb			ld hl,(cli_ret_sp) 
196b			 
196b			 
196b				if FORTH_ENABLE_FREE 
196b			 
196b					; get pointer 
196b			 
196b					push de 
196b					push hl 
196b			 
196b					ld e, (hl) 
196b					inc hl 
196b					ld d, (hl) 
196b			 
196b					ex de, hl 
196b					call free 
196b			 
196b					pop hl 
196b					pop de 
196b			 
196b			 
196b				endif 
196b			 
196b			 
196b 2b				dec hl 
196c 2b				dec hl 
196d 22 11 eb			ld (cli_ret_sp), hl 
1970				; do stack underflow checks 
1970 e1				pop hl 
1971				if DEBUG_FORTH_STACK_GUARD 
1971 cd ce 56				call check_stacks 
1974					FORTH_CHK_RSP_UNDER 
1974 e5				push hl 
1975 d5				push de 
1976 2a 11 eb			ld hl,(cli_ret_sp) 
1979 11 cb ea			ld de, cli_ret_stack 
197c cd d0 0b			call cmp16 
197f da e2 57			jp c, fault_rsp_under 
1982 d1				pop de 
1983 e1				pop hl 
1984				endm 
# End of macro FORTH_CHK_RSP_UNDER
1984				endif 
1984 c9				ret 
1985			 
1985			 
1985			 
1985			; routine to load word pointed to by hl into hl 
1985			 
1985			loadhlptrtohl: 
1985			 
1985 d5				push de 
1986 5e				ld e, (hl) 
1987 23				inc hl 
1988 56				ld d, (hl) 
1989 eb				ex de, hl 
198a d1				pop de 
198b			 
198b c9				ret 
198c			 
198c			 
198c			 
198c			 
198c			 
198c			; push a number held in HL onto the data stack 
198c			; entry point for pushing a value when already in hl used in function above 
198c			 
198c			forth_push_numhl: 
198c			 
198c e5				push hl    ; save value to push 
198d			 
198d			if DEBUG_FORTH_PUSH 
198d				; see if disabled 
198d			 
198d			 
198d f5				push af 
198e 3a 51 e3			ld a, (os_view_disable) 
1991 fe 2a			cp '*' 
1993 28 34			jr z, .pskip2 
1995 e5				push hl 
1996 e5			push hl 
1997 cd 85 09			call clear_display 
199a e1			pop hl 
199b 7c				ld a,h 
199c 21 65 e6			ld hl, os_word_scratch 
199f cd b3 0e			call hexout 
19a2 e1				pop hl 
19a3 7d				ld a,l 
19a4 21 67 e6			ld hl, os_word_scratch+2 
19a7 cd b3 0e			call hexout 
19aa			 
19aa 21 69 e6			ld hl, os_word_scratch+4 
19ad 3e 00			ld a,0 
19af 77				ld (hl),a 
19b0 11 65 e6			ld de,os_word_scratch 
19b3 3e 28				ld a, display_row_2 
19b5 cd 98 09				call str_at_display 
19b8 11 dc 45			ld de, .push_num 
19bb 3e 00			ld a, display_row_1 
19bd			 
19bd cd 98 09				call str_at_display 
19c0			 
19c0			 
19c0 cd a8 09			call update_display 
19c3 cd fa 08			call delay1s 
19c6 cd fa 08			call delay1s 
19c9			.pskip2:  
19c9			 
19c9 f1				pop af 
19ca			endif	 
19ca			 
19ca			 
19ca				FORTH_DSP_NEXT 
19ca cd 1b 19			call macro_forth_dsp_next 
19cd				endm 
# End of macro FORTH_DSP_NEXT
19cd			 
19cd 2a 0d eb			ld hl, (cli_data_sp) 
19d0			 
19d0				; save item type 
19d0 3e 02			ld a,  DS_TYPE_INUM 
19d2 77				ld (hl), a 
19d3 23				inc hl 
19d4			 
19d4				; get word off stack 
19d4 d1				pop de 
19d5 7b				ld a,e 
19d6 77				ld (hl), a 
19d7 23				inc hl 
19d8 7a				ld a,d 
19d9 77				ld (hl), a 
19da			 
19da			if DEBUG_FORTH_PUSH 
19da 2b				dec hl 
19db 2b				dec hl 
19dc 2b				dec hl 
19dd						DMARK "PH5" 
19dd f5				push af  
19de 3a f2 19			ld a, (.dmark)  
19e1 32 7a ee			ld (debug_mark),a  
19e4 3a f3 19			ld a, (.dmark+1)  
19e7 32 7b ee			ld (debug_mark+1),a  
19ea 3a f4 19			ld a, (.dmark+2)  
19ed 32 7c ee			ld (debug_mark+2),a  
19f0 18 03			jr .pastdmark  
19f2 ..			.dmark: db "PH5"  
19f5 f1			.pastdmark: pop af  
19f6			endm  
# End of macro DMARK
19f6				CALLMONITOR 
19f6 cd ff 13			call break_point_state  
19f9				endm  
# End of macro CALLMONITOR
19f9			endif	 
19f9			 
19f9 c9				ret 
19fa			 
19fa			 
19fa			; Push a string to stack pointed to by hl 
19fa			 
19fa			forth_push_str: 
19fa			 
19fa			if DEBUG_FORTH_PUSH 
19fa						DMARK "PSQ" 
19fa f5				push af  
19fb 3a 0f 1a			ld a, (.dmark)  
19fe 32 7a ee			ld (debug_mark),a  
1a01 3a 10 1a			ld a, (.dmark+1)  
1a04 32 7b ee			ld (debug_mark+1),a  
1a07 3a 11 1a			ld a, (.dmark+2)  
1a0a 32 7c ee			ld (debug_mark+2),a  
1a0d 18 03			jr .pastdmark  
1a0f ..			.dmark: db "PSQ"  
1a12 f1			.pastdmark: pop af  
1a13			endm  
# End of macro DMARK
1a13				CALLMONITOR 
1a13 cd ff 13			call break_point_state  
1a16				endm  
# End of macro CALLMONITOR
1a16			endif	 
1a16			    
1a16 e5				push hl 
1a17 e5				push hl 
1a18			 
1a18			;	ld a, 0   ; find end of string 
1a18 cd 10 10			call strlenz 
1a1b			if DEBUG_FORTH_PUSH 
1a1b						DMARK "PQ2" 
1a1b f5				push af  
1a1c 3a 30 1a			ld a, (.dmark)  
1a1f 32 7a ee			ld (debug_mark),a  
1a22 3a 31 1a			ld a, (.dmark+1)  
1a25 32 7b ee			ld (debug_mark+1),a  
1a28 3a 32 1a			ld a, (.dmark+2)  
1a2b 32 7c ee			ld (debug_mark+2),a  
1a2e 18 03			jr .pastdmark  
1a30 ..			.dmark: db "PQ2"  
1a33 f1			.pastdmark: pop af  
1a34			endm  
# End of macro DMARK
1a34				CALLMONITOR 
1a34 cd ff 13			call break_point_state  
1a37				endm  
# End of macro CALLMONITOR
1a37			endif	 
1a37 eb				ex de, hl 
1a38 e1				pop hl   ; get ptr to start of string 
1a39			if DEBUG_FORTH_PUSH 
1a39						DMARK "PQ3" 
1a39 f5				push af  
1a3a 3a 4e 1a			ld a, (.dmark)  
1a3d 32 7a ee			ld (debug_mark),a  
1a40 3a 4f 1a			ld a, (.dmark+1)  
1a43 32 7b ee			ld (debug_mark+1),a  
1a46 3a 50 1a			ld a, (.dmark+2)  
1a49 32 7c ee			ld (debug_mark+2),a  
1a4c 18 03			jr .pastdmark  
1a4e ..			.dmark: db "PQ3"  
1a51 f1			.pastdmark: pop af  
1a52			endm  
# End of macro DMARK
1a52				CALLMONITOR 
1a52 cd ff 13			call break_point_state  
1a55				endm  
# End of macro CALLMONITOR
1a55			endif	 
1a55 19				add hl,de 
1a56			if DEBUG_FORTH_PUSH 
1a56						DMARK "PQE" 
1a56 f5				push af  
1a57 3a 6b 1a			ld a, (.dmark)  
1a5a 32 7a ee			ld (debug_mark),a  
1a5d 3a 6c 1a			ld a, (.dmark+1)  
1a60 32 7b ee			ld (debug_mark+1),a  
1a63 3a 6d 1a			ld a, (.dmark+2)  
1a66 32 7c ee			ld (debug_mark+2),a  
1a69 18 03			jr .pastdmark  
1a6b ..			.dmark: db "PQE"  
1a6e f1			.pastdmark: pop af  
1a6f			endm  
# End of macro DMARK
1a6f				CALLMONITOR 
1a6f cd ff 13			call break_point_state  
1a72				endm  
# End of macro CALLMONITOR
1a72			endif	 
1a72			 
1a72 2b				dec hl    ; see if there is an optional trailing double quote 
1a73 7e				ld a,(hl) 
1a74 fe 22			cp '"' 
1a76 20 03			jr nz, .strnoq 
1a78 3e 00			ld a, 0      ; get rid of double quote 
1a7a 77				ld (hl), a 
1a7b 23			.strnoq: inc hl 
1a7c			 
1a7c 3e 00			ld a, 0 
1a7e 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1a7f			 
1a7f 13				inc de ; add one for the type string 
1a80 13				inc de ; add one for null term??? 
1a81			 
1a81				; tos is get string pointer again 
1a81				; de contains space to allocate 
1a81				 
1a81 d5				push de 
1a82			 
1a82 eb				ex de, hl 
1a83			 
1a83				;push af 
1a83			 
1a83			if DEBUG_FORTH_PUSH 
1a83						DMARK "PHm" 
1a83 f5				push af  
1a84 3a 98 1a			ld a, (.dmark)  
1a87 32 7a ee			ld (debug_mark),a  
1a8a 3a 99 1a			ld a, (.dmark+1)  
1a8d 32 7b ee			ld (debug_mark+1),a  
1a90 3a 9a 1a			ld a, (.dmark+2)  
1a93 32 7c ee			ld (debug_mark+2),a  
1a96 18 03			jr .pastdmark  
1a98 ..			.dmark: db "PHm"  
1a9b f1			.pastdmark: pop af  
1a9c			endm  
# End of macro DMARK
1a9c				CALLMONITOR 
1a9c cd ff 13			call break_point_state  
1a9f				endm  
# End of macro CALLMONITOR
1a9f			endif	 
1a9f cd 79 10			call malloc	; on ret hl now contains allocated memory 
1aa2				if DEBUG_FORTH_MALLOC_GUARD 
1aa2 cc 34 46				call z,malloc_error 
1aa5				endif 
1aa5			 
1aa5				 
1aa5 c1				pop bc    ; get length 
1aa6 d1				pop de   ;  get string start    
1aa7			 
1aa7				; hl has destination from malloc 
1aa7			 
1aa7 eb				ex de, hl    ; prep for ldir 
1aa8			 
1aa8 d5				push de   ; save malloc area for DSP later 
1aa9				;push hl   ; save malloc area for DSP later 
1aa9			 
1aa9			if DEBUG_FORTH_PUSH 
1aa9						DMARK "PHc" 
1aa9 f5				push af  
1aaa 3a be 1a			ld a, (.dmark)  
1aad 32 7a ee			ld (debug_mark),a  
1ab0 3a bf 1a			ld a, (.dmark+1)  
1ab3 32 7b ee			ld (debug_mark+1),a  
1ab6 3a c0 1a			ld a, (.dmark+2)  
1ab9 32 7c ee			ld (debug_mark+2),a  
1abc 18 03			jr .pastdmark  
1abe ..			.dmark: db "PHc"  
1ac1 f1			.pastdmark: pop af  
1ac2			endm  
# End of macro DMARK
1ac2				CALLMONITOR 
1ac2 cd ff 13			call break_point_state  
1ac5				endm  
# End of macro CALLMONITOR
1ac5			endif	 
1ac5			 
1ac5			 
1ac5 ed b0			ldir 
1ac7			 
1ac7			 
1ac7				; push malloc to data stack     macro?????  
1ac7			 
1ac7				FORTH_DSP_NEXT 
1ac7 cd 1b 19			call macro_forth_dsp_next 
1aca				endm 
# End of macro FORTH_DSP_NEXT
1aca			 
1aca				; save value and type 
1aca			 
1aca 2a 0d eb			ld hl, (cli_data_sp) 
1acd			 
1acd				; save item type 
1acd 3e 01			ld a,  DS_TYPE_STR 
1acf 77				ld (hl), a 
1ad0 23				inc hl 
1ad1			 
1ad1				; get malloc word off stack 
1ad1 d1				pop de 
1ad2 73				ld (hl), e 
1ad3 23				inc hl 
1ad4 72				ld (hl), d 
1ad5			 
1ad5			 
1ad5			 
1ad5			if DEBUG_FORTH_PUSH 
1ad5 2a 0d eb			ld hl, (cli_data_sp) 
1ad8						DMARK "PHS" 
1ad8 f5				push af  
1ad9 3a ed 1a			ld a, (.dmark)  
1adc 32 7a ee			ld (debug_mark),a  
1adf 3a ee 1a			ld a, (.dmark+1)  
1ae2 32 7b ee			ld (debug_mark+1),a  
1ae5 3a ef 1a			ld a, (.dmark+2)  
1ae8 32 7c ee			ld (debug_mark+2),a  
1aeb 18 03			jr .pastdmark  
1aed ..			.dmark: db "PHS"  
1af0 f1			.pastdmark: pop af  
1af1			endm  
# End of macro DMARK
1af1				CALLMONITOR 
1af1 cd ff 13			call break_point_state  
1af4				endm  
# End of macro CALLMONITOR
1af4			;	ex de,hl 
1af4			endif	 
1af4				; in case of spaces, skip the ptr past the copied string 
1af4				;pop af 
1af4				;ld (cli_origptr),hl 
1af4			 
1af4 c9				ret 
1af5			 
1af5			 
1af5			 
1af5			; TODO ascii push input onto stack given hl to start of input 
1af5			 
1af5			; identify type 
1af5			; if starts with a " then a string 
1af5			; otherwise it is a number 
1af5			;  
1af5			; if a string 
1af5			;     scan for ending " to get length of string to malloc for + 1 
1af5			;     malloc 
1af5			;     put pointer to string on stack first byte flags as string 
1af5			; 
1af5			; else a number 
1af5			;    look for number format identifier 
1af5			;    $xx hex 
1af5			;    %xxxxx bin 
1af5			;    xxxxx decimal 
1af5			;    convert number to 16bit word.  
1af5			;    malloc word + 1 with flag to identiy as num 
1af5			;    put pointer to number on stack 
1af5			;   
1af5			;  
1af5			  
1af5			forth_apush: 
1af5				; kernel push 
1af5			 
1af5			if DEBUG_FORTH_PUSH 
1af5						DMARK "PSH" 
1af5 f5				push af  
1af6 3a 0a 1b			ld a, (.dmark)  
1af9 32 7a ee			ld (debug_mark),a  
1afc 3a 0b 1b			ld a, (.dmark+1)  
1aff 32 7b ee			ld (debug_mark+1),a  
1b02 3a 0c 1b			ld a, (.dmark+2)  
1b05 32 7c ee			ld (debug_mark+2),a  
1b08 18 03			jr .pastdmark  
1b0a ..			.dmark: db "PSH"  
1b0d f1			.pastdmark: pop af  
1b0e			endm  
# End of macro DMARK
1b0e				CALLMONITOR 
1b0e cd ff 13			call break_point_state  
1b11				endm  
# End of macro CALLMONITOR
1b11			endif	 
1b11				; identify input type 
1b11			 
1b11 7e				ld a,(hl) 
1b12 fe 22			cp '"' 
1b14 28 0a			jr z, .fapstr 
1b16 fe 24			cp '$' 
1b18 ca 40 1b			jp z, .faphex 
1b1b fe 25			cp '%' 
1b1d ca 28 1b			jp z, .fapbin 
1b20			;	cp 'b' 
1b20			;	jp z, .fabin 
1b20				; else decimal 
1b20			 
1b20				; TODO do decimal conversion 
1b20				; decimal is stored as a 16bit word 
1b20			 
1b20				; by default everything is a string if type is not detected 
1b20			.fapstr: ; 
1b20 fe 22			cp '"' 
1b22 20 01			jr nz, .strnoqu 
1b24 23				inc hl 
1b25			.strnoqu: 
1b25 c3 fa 19			jp forth_push_str 
1b28			 
1b28			 
1b28			 
1b28			.fapbin:    ; push a binary string.  
1b28 11 00 00			ld de, 0   ; hold a 16bit value 
1b2b			 
1b2b 23			.fapbinshift:	inc hl  
1b2c 7e				ld a,(hl) 
1b2d fe 00			cp 0     ; done scanning  
1b2f 28 0b			jr z, .fapbdone  	; got it in HL so push  
1b31			 
1b31				; left shift de 
1b31 eb				ex de, hl	 
1b32 29				add hl, hl 
1b33			 
1b33				; is 1 
1b33 fe 31			cp '1' 
1b35 20 02			jr nz, .binzero 
1b37 cb 4d			bit 1, l 
1b39			.binzero: 
1b39 eb				ex de, hl	 ; save current de 
1b3a 18 ef			jr .fapbinshift 
1b3c			 
1b3c			.fapbdone: 
1b3c eb				ex de, hl 
1b3d c3 8c 19			jp forth_push_numhl 
1b40			 
1b40			 
1b40			.faphex:   ; hex is always stored as a 16bit word 
1b40				; skip number prefix 
1b40 23				inc hl 
1b41				; turn ascii into number 
1b41 cd 69 0f			call get_word_hl	; ret 16bit word in hl 
1b44			 
1b44 c3 8c 19			jp forth_push_numhl 
1b47			 
1b47 00				 nop 
1b48			 
1b48			.fabin:   ; TODO bin conversion 
1b48			 
1b48			 
1b48 c9				ret 
1b49			 
1b49			 
1b49			; get either a string ptr or a 16bit word from the data stack 
1b49			 
1b49			FORTH_DSP: macro 
1b49				call macro_forth_dsp 
1b49				endm 
1b49			 
1b49			macro_forth_dsp: 
1b49				; data stack pointer points to current word on tos 
1b49			 
1b49 2a 0d eb			ld hl,(cli_data_sp) 
1b4c			 
1b4c				if DEBUG_FORTH_PUSH 
1b4c						DMARK "DSP" 
1b4c f5				push af  
1b4d 3a 61 1b			ld a, (.dmark)  
1b50 32 7a ee			ld (debug_mark),a  
1b53 3a 62 1b			ld a, (.dmark+1)  
1b56 32 7b ee			ld (debug_mark+1),a  
1b59 3a 63 1b			ld a, (.dmark+2)  
1b5c 32 7c ee			ld (debug_mark+2),a  
1b5f 18 03			jr .pastdmark  
1b61 ..			.dmark: db "DSP"  
1b64 f1			.pastdmark: pop af  
1b65			endm  
# End of macro DMARK
1b65			 
1b65 cd 69 46				call display_data_sp 
1b68				;call break_point_state 
1b68				;rst 030h 
1b68				CALLMONITOR 
1b68 cd ff 13			call break_point_state  
1b6b				endm  
# End of macro CALLMONITOR
1b6b				endif 
1b6b			 
1b6b c9				ret 
1b6c			 
1b6c			; return hl to start of value on stack 
1b6c			 
1b6c			FORTH_DSP_VALUE: macro 
1b6c				call macro_forth_dsp_value 
1b6c				endm 
1b6c			 
1b6c			macro_forth_dsp_value: 
1b6c			 
1b6c				FORTH_DSP 
1b6c cd 49 1b			call macro_forth_dsp 
1b6f				endm 
# End of macro FORTH_DSP
1b6f			 
1b6f d5				push de 
1b70			 
1b70 23				inc hl ; skip type 
1b71			 
1b71 5e				ld e, (hl) 
1b72 23				inc hl 
1b73 56				ld d, (hl) 
1b74 eb				ex de,hl  
1b75			 
1b75 d1				pop de 
1b76			 
1b76 c9				ret 
1b77			 
1b77			; return hl to start of value to second item on stack 
1b77			 
1b77			FORTH_DSP_VALUEM1: macro 
1b77				call macro_forth_dsp_value_m1 
1b77				endm 
1b77			 
1b77			macro_forth_dsp_value_m1: 
1b77			 
1b77				FORTH_DSP 
1b77 cd 49 1b			call macro_forth_dsp 
1b7a				endm 
# End of macro FORTH_DSP
1b7a			 
1b7a 2b				dec hl 
1b7b 2b				dec hl 
1b7c			;	dec hl 
1b7c			 
1b7c d5				push de 
1b7d			 
1b7d 5e				ld e, (hl) 
1b7e 23				inc hl 
1b7f 56				ld d, (hl) 
1b80 eb				ex de,hl  
1b81			 
1b81 d1				pop de 
1b82			 
1b82 c9				ret 
1b83			 
1b83				 
1b83			 
1b83			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1b83			 
1b83			FORTH_DSP_POP: macro 
1b83				call macro_forth_dsp_pop 
1b83				endm 
1b83			 
1b83			 
1b83			; get the tos data type 
1b83			 
1b83			FORTH_DSP_TYPE:   macro 
1b83			 
1b83				;FORTH_DSP_VALUE 
1b83				FORTH_DSP 
1b83				 
1b83				; hl points to value 
1b83				; check type 
1b83			 
1b83				ld a,(hl) 
1b83			 
1b83				endm 
1b83			 
1b83			; load the tos value into hl 
1b83			 
1b83			 
1b83			FORTH_DSP_VALUEHL:  macro 
1b83				call macro_dsp_valuehl 
1b83				endm 
1b83			 
1b83			 
1b83			 
1b83			macro_dsp_valuehl: 
1b83				FORTH_DSP_VALUE 
1b83 cd 6c 1b			call macro_forth_dsp_value 
1b86				endm 
# End of macro FORTH_DSP_VALUE
1b86			 
1b86				;FORTH_ERR_TOS_NOTNUM 
1b86			 
1b86				;inc hl   ; skip type id 
1b86			 
1b86			;	push de 
1b86			; 
1b86			;	ld e, (hl) 
1b86			;	inc hl 
1b86			;	ld d, (hl) 
1b86			;	ex de,hl  
1b86			 
1b86			;	pop de 
1b86			 
1b86				if DEBUG_FORTH_PUSH 
1b86						DMARK "DVL" 
1b86 f5				push af  
1b87 3a 9b 1b			ld a, (.dmark)  
1b8a 32 7a ee			ld (debug_mark),a  
1b8d 3a 9c 1b			ld a, (.dmark+1)  
1b90 32 7b ee			ld (debug_mark+1),a  
1b93 3a 9d 1b			ld a, (.dmark+2)  
1b96 32 7c ee			ld (debug_mark+2),a  
1b99 18 03			jr .pastdmark  
1b9b ..			.dmark: db "DVL"  
1b9e f1			.pastdmark: pop af  
1b9f			endm  
# End of macro DMARK
1b9f				CALLMONITOR 
1b9f cd ff 13			call break_point_state  
1ba2				endm  
# End of macro CALLMONITOR
1ba2				endif 
1ba2 c9				ret 
1ba3			 
1ba3			forth_apushstrhl:      
1ba3				; push of string requires use of cli_origptr 
1ba3				; bodge use 
1ba3			 
1ba3				; get current cli_origptr, save, update with temp pointer  
1ba3 ed 5b 29 eb		ld de, (cli_origptr) 
1ba7 22 29 eb			ld (cli_origptr), hl 
1baa d5				push de 
1bab cd f5 1a			call forth_apush 
1bae d1				pop de 
1baf ed 53 29 eb		ld (cli_origptr), de 
1bb3 c9			        ret	 
1bb4			 
1bb4			 
1bb4			; increase loop stack pointer and save hl to it 
1bb4				 
1bb4			FORTH_LOOP_NEXT: macro 
1bb4				call macro_forth_loop_next 
1bb4				;nop 
1bb4				endm 
1bb4			 
1bb4			macro_forth_loop_next: 
1bb4				if DEBUG_FORTH_STACK_GUARD 
1bb4 cd ce 56				call check_stacks 
1bb7				endif 
1bb7 e5				push hl 
1bb8 d5				push de 
1bb9 eb				ex de,hl 
1bba 2a 0f eb			ld hl,(cli_loop_sp) 
1bbd 23				inc hl 
1bbe 23				inc hl 
1bbf					if DEBUG_FORTH_WORDS 
1bbf						DMARK "LNX" 
1bbf f5				push af  
1bc0 3a d4 1b			ld a, (.dmark)  
1bc3 32 7a ee			ld (debug_mark),a  
1bc6 3a d5 1b			ld a, (.dmark+1)  
1bc9 32 7b ee			ld (debug_mark+1),a  
1bcc 3a d6 1b			ld a, (.dmark+2)  
1bcf 32 7c ee			ld (debug_mark+2),a  
1bd2 18 03			jr .pastdmark  
1bd4 ..			.dmark: db "LNX"  
1bd7 f1			.pastdmark: pop af  
1bd8			endm  
# End of macro DMARK
1bd8						CALLMONITOR 
1bd8 cd ff 13			call break_point_state  
1bdb				endm  
# End of macro CALLMONITOR
1bdb					endif 
1bdb 22 0f eb			ld (cli_loop_sp),hl 
1bde 73				ld (hl), e 
1bdf 23				inc hl 
1be0 72				ld (hl), d 
1be1 d1				pop de    ; been reversed so save a swap on restore 
1be2 e1				pop hl 
1be3				if DEBUG_FORTH_STACK_GUARD 
1be3 cd ce 56				call check_stacks 
1be6				endif 
1be6 c9				ret 
1be7			 
1be7			; get current ret stack pointer and save to hl  
1be7				 
1be7			FORTH_LOOP_TOS: macro 
1be7				call macro_forth_loop_tos 
1be7				endm 
1be7			 
1be7			macro_forth_loop_tos: 
1be7 d5				push de 
1be8 2a 0f eb			ld hl,(cli_loop_sp) 
1beb 5e				ld e, (hl) 
1bec 23				inc hl 
1bed 56				ld d, (hl) 
1bee eb				ex de, hl 
1bef d1				pop de 
1bf0 c9				ret 
1bf1			 
1bf1			; pop loop stack pointer 
1bf1				 
1bf1			FORTH_LOOP_POP: macro 
1bf1				call macro_forth_loop_pop 
1bf1				endm 
1bf1			 
1bf1			 
1bf1			macro_forth_loop_pop: 
1bf1				if DEBUG_FORTH_STACK_GUARD 
1bf1					DMARK "LPP" 
1bf1 f5				push af  
1bf2 3a 06 1c			ld a, (.dmark)  
1bf5 32 7a ee			ld (debug_mark),a  
1bf8 3a 07 1c			ld a, (.dmark+1)  
1bfb 32 7b ee			ld (debug_mark+1),a  
1bfe 3a 08 1c			ld a, (.dmark+2)  
1c01 32 7c ee			ld (debug_mark+2),a  
1c04 18 03			jr .pastdmark  
1c06 ..			.dmark: db "LPP"  
1c09 f1			.pastdmark: pop af  
1c0a			endm  
# End of macro DMARK
1c0a cd ce 56				call check_stacks 
1c0d					FORTH_CHK_LOOP_UNDER 
1c0d e5				push hl 
1c0e d5				push de 
1c0f 2a 0f eb			ld hl,(cli_loop_sp) 
1c12 11 c9 e9			ld de, cli_loop_stack 
1c15 cd d0 0b			call cmp16 
1c18 da e8 57			jp c, fault_loop_under 
1c1b d1				pop de 
1c1c e1				pop hl 
1c1d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c1d				endif 
1c1d e5				push hl 
1c1e 2a 0f eb			ld hl,(cli_loop_sp) 
1c21 2b				dec hl 
1c22 2b				dec hl 
1c23 22 0f eb			ld (cli_loop_sp), hl 
1c26				; TODO do stack underflow checks 
1c26 e1				pop hl 
1c27				if DEBUG_FORTH_STACK_GUARD 
1c27 cd ce 56				call check_stacks 
1c2a					FORTH_CHK_LOOP_UNDER 
1c2a e5				push hl 
1c2b d5				push de 
1c2c 2a 0f eb			ld hl,(cli_loop_sp) 
1c2f 11 c9 e9			ld de, cli_loop_stack 
1c32 cd d0 0b			call cmp16 
1c35 da e8 57			jp c, fault_loop_under 
1c38 d1				pop de 
1c39 e1				pop hl 
1c3a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c3a				endif 
1c3a c9				ret 
1c3b			 
1c3b			macro_forth_dsp_pop: 
1c3b			 
1c3b e5				push hl 
1c3c			 
1c3c				; release malloc data 
1c3c			 
1c3c				if DEBUG_FORTH_STACK_GUARD 
1c3c cd ce 56				call check_stacks 
1c3f					FORTH_CHK_DSP_UNDER 
1c3f e5				push hl 
1c40 d5				push de 
1c41 2a 0d eb			ld hl,(cli_data_sp) 
1c44 11 c7 e8			ld de, cli_data_stack 
1c47 cd d0 0b			call cmp16 
1c4a da dc 57			jp c, fault_dsp_under 
1c4d d1				pop de 
1c4e e1				pop hl 
1c4f				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c4f				endif 
1c4f				;ld hl,(cli_data_sp) 
1c4f			if DEBUG_FORTH_DOT 
1c4f				DMARK "DPP" 
1c4f				CALLMONITOR 
1c4f			endif	 
1c4f			 
1c4f			 
1c4f			if FORTH_ENABLE_DSPPOPFREE 
1c4f			 
1c4f				FORTH_DSP 
1c4f cd 49 1b			call macro_forth_dsp 
1c52				endm 
# End of macro FORTH_DSP
1c52			 
1c52 7e				ld a, (hl) 
1c53 fe 01			cp DS_TYPE_STR 
1c55 20 07			jr nz, .skippopfree 
1c57			 
1c57				FORTH_DSP_VALUEHL 
1c57 cd 83 1b			call macro_dsp_valuehl 
1c5a				endm 
# End of macro FORTH_DSP_VALUEHL
1c5a 00				nop 
1c5b			if DEBUG_FORTH_DOT 
1c5b				DMARK "DPf" 
1c5b				CALLMONITOR 
1c5b			endif	 
1c5b cd 43 11			call free 
1c5e			.skippopfree: 
1c5e				 
1c5e			 
1c5e			endif 
1c5e			 
1c5e			if DEBUG_FORTH_DOT_KEY 
1c5e				DMARK "DP2" 
1c5e				CALLMONITOR 
1c5e			endif	 
1c5e			 
1c5e				; move pointer down 
1c5e			 
1c5e 2a 0d eb			ld hl,(cli_data_sp) 
1c61 2b				dec hl 
1c62 2b				dec hl 
1c63			; PARSEV5 
1c63 2b				dec hl 
1c64 22 0d eb			ld (cli_data_sp), hl 
1c67			 
1c67				if DEBUG_FORTH_STACK_GUARD 
1c67 cd ce 56				call check_stacks 
1c6a					FORTH_CHK_DSP_UNDER 
1c6a e5				push hl 
1c6b d5				push de 
1c6c 2a 0d eb			ld hl,(cli_data_sp) 
1c6f 11 c7 e8			ld de, cli_data_stack 
1c72 cd d0 0b			call cmp16 
1c75 da dc 57			jp c, fault_dsp_under 
1c78 d1				pop de 
1c79 e1				pop hl 
1c7a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c7a				endif 
1c7a			 
1c7a e1				pop hl 
1c7b			 
1c7b c9				ret 
1c7c			 
1c7c			getwordathl: 
1c7c				; hl points to an address 
1c7c				; load hl with the word at that address 
1c7c			 
1c7c d5				push de 
1c7d			 
1c7d 5e				ld e, (hl) 
1c7e 23				inc hl 
1c7f 56				ld d, (hl) 
1c80 eb				ex de, hl 
1c81			 
1c81 d1				pop de 
1c82 c9				ret 
1c83			 
1c83			 
1c83			 
1c83			 
1c83			 
1c83			; eof 
1c83			 
# End of file forth_stackopsv5.asm
1c83			endif 
1c83			 
1c83			user_word_eol:  
1c83				; hl contains the pointer to where to create a linked list item from the end 
1c83				; of the user dict to continue on at the system word dict 
1c83				 
1c83				; poke the stub of the word list linked list to repoint to rom words 
1c83			 
1c83				; stub format 
1c83				; db   word id 
1c83				; dw    link to next word 
1c83			        ; db char length of token 
1c83				; db string + 0 term 
1c83				; db exec code....  
1c83			 
1c83 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1c85 77				ld (hl), a		; word id 
1c86 23				inc hl 
1c87			 
1c87 11 4d 1e			ld de, sysdict 
1c8a 73				ld (hl), e		; next word link ie system dict 
1c8b 23				inc hl 
1c8c 72				ld (hl), d		; next word link ie system dict 
1c8d 23				inc hl	 
1c8e			 
1c8e			;	ld (hl), sysdict		; next word link ie system dict 
1c8e			;	inc hl 
1c8e			;	inc hl 
1c8e			 
1c8e			;	inc hl 
1c8e			;	inc hl 
1c8e			 
1c8e 3e 02			ld a, 2			; word length is 0 
1c90 77				ld (hl), a	 
1c91 23				inc hl 
1c92			 
1c92 3e 7e			ld a, '~'			; word length is 0 
1c94 77				ld (hl), a	 
1c95 23				inc hl 
1c96 3e 00			ld a, 0			; save empty word 
1c98 77				ld (hl), a 
1c99			 
1c99 c9				ret 
1c9a			 
1c9a				 
1c9a			 
1c9a			forthexec_cleanup: 
1c9a				FORTH_RSP_POP 
1c9a cd 54 19			call macro_forth_rsp_pop 
1c9d				endm 
# End of macro FORTH_RSP_POP
1c9d c9				ret 
1c9e			 
1c9e			forth_call_hl: 
1c9e				; taking hl 
1c9e e5				push hl 
1c9f c9				ret 
1ca0			 
1ca0			; this is called to reset Forth system but keep existing uwords etc 
1ca0			 
1ca0			forth_warmstart: 
1ca0				; setup stack over/under flow checks 
1ca0				if DEBUG_FORTH_STACK_GUARD 
1ca0 cd b4 56				call chk_stk_init 
1ca3				endif 
1ca3			 
1ca3				; init stack pointers  - * these stacks go upwards *  
1ca3 21 cb ea			ld hl, cli_ret_stack 
1ca6 22 11 eb			ld (cli_ret_sp), hl	 
1ca9				; set bottom of stack 
1ca9 3e 00			ld a,0 
1cab 77				ld (hl),a 
1cac 23				inc hl 
1cad 77				ld (hl),a 
1cae			 
1cae 21 c7 e8			ld hl, cli_data_stack 
1cb1 22 0d eb			ld (cli_data_sp), hl	 
1cb4				; set bottom of stack 
1cb4 3e 00			ld a,0 
1cb6 77				ld (hl),a 
1cb7 23				inc hl 
1cb8 77				ld (hl),a 
1cb9			 
1cb9 21 c9 e9			ld hl, cli_loop_stack 
1cbc 22 0f eb			ld (cli_loop_sp), hl	 
1cbf				; set bottom of stack 
1cbf 3e 00			ld a,0 
1cc1 77				ld (hl),a 
1cc2 23				inc hl 
1cc3 77				ld (hl),a 
1cc4			 
1cc4				; init extent of current open file 
1cc4			 
1cc4 3e 00			ld a, 0 
1cc6 32 5c eb			ld (store_openext), a 
1cc9			 
1cc9 c9				ret 
1cca			 
1cca			 
1cca			; Cold Start - this is called to setup the whole Forth system 
1cca			 
1cca			forth_init: 
1cca			 
1cca				; setup stack over/under flow checks 
1cca			 
1cca			;	if DEBUG_FORTH_STACK_GUARD 
1cca			;		call chk_stk_init 
1cca			;	endif 
1cca			 
1cca				; enable auto display updates (slow.....) 
1cca			 
1cca 3e 01			ld a, 1 
1ccc 32 27 eb			ld (cli_autodisplay), a 
1ccf			 
1ccf			 
1ccf			 
1ccf				; show start up screen 
1ccf			 
1ccf cd 85 09			call clear_display 
1cd2			 
1cd2 3e 00			ld a,0 
1cd4 32 49 eb			ld (f_cursor_ptr), a 
1cd7			 
1cd7				; set start of word list in start of ram - for use when creating user words 
1cd7			 
1cd7 21 d7 59			ld hl, baseram 
1cda 22 5d e6			ld (os_last_new_uword), hl 
1cdd cd 83 1c			call user_word_eol 
1ce0				 
1ce0			;		call display_data_sp 
1ce0			;		call next_page_prompt 
1ce0			 
1ce0			 
1ce0			 
1ce0			 
1ce0 c9				ret 
1ce1			 
1ce1 .. 00		.bootforth: db " Forth Kernel Init ",0 
1cf5			 
1cf5			; TODO push to stack 
1cf5			 
1cf5			;  
1cf5			 
1cf5			if FORTH_PARSEV2 
1cf5			 
1cf5			 
1cf5				include "forth_parserv2.asm" 
1cf5			 
1cf5			endif 
1cf5			 
1cf5			 
1cf5			; parse cli version 1 
1cf5			 
1cf5			if FORTH_PARSEV1 
1cf5			 
1cf5			 
1cf5			 
1cf5			      include "forth_parserv1.asm" 
1cf5			endif 
1cf5				 
1cf5			if FORTH_PARSEV3 
1cf5			 
1cf5			 
1cf5			 
1cf5			      include "forth_parserv3.asm" 
1cf5				include "forth_wordsv3.asm" 
1cf5			endif 
1cf5			 
1cf5			if FORTH_PARSEV4 
1cf5			 
1cf5			 
1cf5			 
1cf5			      include "forth_parserv4.asm" 
1cf5				include "forth_wordsv4.asm" 
1cf5			endif 
1cf5			 
1cf5			if FORTH_PARSEV5 
1cf5			 
1cf5			 
1cf5			 
1cf5			      include "forth_parserv5.asm" 
1cf5			 
1cf5			 
1cf5			; A better parser without using malloc and string copies all over the place.  
1cf5			; Exec in situ should be faster 
1cf5			 
1cf5			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1cf5			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1cf5			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1cf5			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1cf5			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1cf5			WORD_SYS_END: equ 0   ; Opcode for all user words 
1cf5			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1cf5			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1cf5			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1cf5			 
1cf5			; Core word preamble macro 
1cf5			 
1cf5			CWHEAD:   macro nxtword opcode lit len opflags 
1cf5				db WORD_SYS_CORE+opcode             
1cf5				; internal op code number 
1cf5				dw nxtword            
1cf5				; link to next dict word block 
1cf5				db len + 1 
1cf5				; literal length of dict word inc zero term 
1cf5				db lit,0              
1cf5				; literal dict word 
1cf5			        ; TODO db opflags        
1cf5				endm 
1cf5			 
1cf5			 
1cf5			NEXTW: macro  
1cf5				jp macro_next 
1cf5				endm 
1cf5			 
1cf5			macro_next: 
1cf5			if DEBUG_FORTH_PARSE_KEY 
1cf5				DMARK "NXT" 
1cf5				CALLMONITOR 
1cf5			endif	 
1cf5			;	inc hl  ; skip token null term  
1cf5 ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1cf9 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1cfd 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d00			if DEBUG_FORTH_PARSE_KEY 
1d00				DMARK "}AA" 
1d00				CALLMONITOR 
1d00			endif	 
1d00 c3 03 1e			jp execnext 
1d03				;jp exec1 
1d03			       
1d03			 
1d03			 
1d03			; Another go at the parser to compile  
1d03			 
1d03			 
1d03			; TODO rework parser to change all of the string words to byte tokens 
1d03			; TODO do a search for  
1d03			 
1d03			; TODO first run normal parser to zero term sections 
1d03			; TODO for each word do a token look up to get the op code 
1d03			; TODO need some means to flag to the exec that this is a byte code form    
1d03			 
1d03			 
1d03			forthcompile: 
1d03			 
1d03			; 
1d03			; line parse: 
1d03			;       parse raw input buffer 
1d03			;       tokenise the words 
1d03			;       malloc new copy (for looping etc) 
1d03			;       copy to malloc + current pc in line to start of string and add line term 
1d03			;       save on new rsp 
1d03			; 
1d03			 
1d03			; hl to point to the line to tokenise 
1d03			 
1d03			;	push hl 
1d03 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d06			 
1d06			;	ld a,0		; string term on input 
1d06			;	call strlent 
1d06			 
1d06			;	ld (os_tok_len), hl	 ; save string length 
1d06			 
1d06			;if DEBUG_FORTH_TOK 
1d06			;	ex de,hl		 
1d06			;endif 
1d06			 
1d06			;	pop hl 		; get back string pointer 
1d06			 
1d06			if DEBUG_FORTH_TOK 
1d06						DMARK "TOc" 
1d06				CALLMONITOR 
1d06			endif 
1d06 7e			.cptoken2:    ld a,(hl) 
1d07 23				inc hl 
1d08 fe 7f			cp FORTH_END_BUFFER 
1d0a 28 29			jr z, .cptokendone2 
1d0c fe 00			cp 0 
1d0e 28 25			jr z, .cptokendone2 
1d10 fe 22			cp '"' 
1d12 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1d14 fe 20			cp ' ' 
1d16 20 ee			jr nz,  .cptoken2 
1d18			 
1d18			; TODO consume comments held between ( and ) 
1d18			 
1d18				; we have a space so change to zero term for dict match later 
1d18 2b				dec hl 
1d19 3e 00			ld a,0 
1d1b 77				ld (hl), a 
1d1c 23				inc hl 
1d1d 18 e7			jr .cptoken2 
1d1f				 
1d1f			 
1d1f			.cptokenstr2: 
1d1f				; skip all white space until either eol (because forgot to term) or end double quote 
1d1f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d1f				;inc hl ; skip current double quote 
1d1f 7e				ld a,(hl) 
1d20 23				inc hl 
1d21 fe 22			cp '"' 
1d23 28 e1			jr z, .cptoken2 
1d25 fe 7f			cp FORTH_END_BUFFER 
1d27 28 0c			jr z, .cptokendone2 
1d29 fe 00			cp 0 
1d2b 28 08			jr z, .cptokendone2 
1d2d fe 20			cp ' ' 
1d2f 28 02			jr z, .cptmp2 
1d31 18 ec			jr .cptokenstr2 
1d33			 
1d33			.cptmp2:	; we have a space so change to zero term for dict match later 
1d33				;dec hl 
1d33				;ld a,"-"	; TODO remove this when working 
1d33				;ld (hl), a 
1d33				;inc hl 
1d33 18 ea			jr .cptokenstr2 
1d35			 
1d35			.cptokendone2: 
1d35				;inc hl 
1d35 3e 7f			ld a, FORTH_END_BUFFER 
1d37 77				ld (hl),a 
1d38 23				inc hl 
1d39 3e 21			ld a, '!' 
1d3b 77				ld (hl),a 
1d3c			 
1d3c 2a 61 e6			ld hl,(os_tok_ptr) 
1d3f			         
1d3f			if DEBUG_FORTH_TOK 
1d3f						DMARK "Tc1" 
1d3f				CALLMONITOR 
1d3f			endif 
1d3f			 
1d3f				; push exec string to top of return stack 
1d3f				FORTH_RSP_NEXT 
1d3f cd 33 19			call macro_forth_rsp_next 
1d42				endm 
# End of macro FORTH_RSP_NEXT
1d42 c9				ret 
1d43			 
1d43			; Another go at the parser need to simplify the process 
1d43			 
1d43			forthparse: 
1d43			 
1d43			; 
1d43			; line parse: 
1d43			;       parse raw input buffer 
1d43			;       tokenise the words 
1d43			;       malloc new copy (for looping etc) 
1d43			;       copy to malloc + current pc in line to start of string and add line term 
1d43			;       save on new rsp 
1d43			; 
1d43			 
1d43			; hl to point to the line to tokenise 
1d43			 
1d43			;	push hl 
1d43 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d46			 
1d46			;	ld a,0		; string term on input 
1d46			;	call strlent 
1d46			 
1d46			;	ld (os_tok_len), hl	 ; save string length 
1d46			 
1d46			;if DEBUG_FORTH_TOK 
1d46			;	ex de,hl		 
1d46			;endif 
1d46			 
1d46			;	pop hl 		; get back string pointer 
1d46			 
1d46			if DEBUG_FORTH_TOK 
1d46						DMARK "TOK" 
1d46				CALLMONITOR 
1d46			endif 
1d46 7e			.ptoken2:    ld a,(hl) 
1d47 23				inc hl 
1d48 fe 7f			cp FORTH_END_BUFFER 
1d4a 28 29			jr z, .ptokendone2 
1d4c fe 00			cp 0 
1d4e 28 25			jr z, .ptokendone2 
1d50 fe 22			cp '"' 
1d52 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1d54 fe 20			cp ' ' 
1d56 20 ee			jr nz,  .ptoken2 
1d58			 
1d58			; TODO consume comments held between ( and ) 
1d58			 
1d58				; we have a space so change to zero term for dict match later 
1d58 2b				dec hl 
1d59 3e 00			ld a,0 
1d5b 77				ld (hl), a 
1d5c 23				inc hl 
1d5d 18 e7			jr .ptoken2 
1d5f				 
1d5f			 
1d5f			.ptokenstr2: 
1d5f				; skip all white space until either eol (because forgot to term) or end double quote 
1d5f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d5f				;inc hl ; skip current double quote 
1d5f 7e				ld a,(hl) 
1d60 23				inc hl 
1d61 fe 22			cp '"' 
1d63 28 e1			jr z, .ptoken2 
1d65 fe 7f			cp FORTH_END_BUFFER 
1d67 28 0c			jr z, .ptokendone2 
1d69 fe 00			cp 0 
1d6b 28 08			jr z, .ptokendone2 
1d6d fe 20			cp ' ' 
1d6f 28 02			jr z, .ptmp2 
1d71 18 ec			jr .ptokenstr2 
1d73			 
1d73			.ptmp2:	; we have a space so change to zero term for dict match later 
1d73				;dec hl 
1d73				;ld a,"-"	; TODO remove this when working 
1d73				;ld (hl), a 
1d73				;inc hl 
1d73 18 ea			jr .ptokenstr2 
1d75			 
1d75			.ptokendone2: 
1d75				;inc hl 
1d75 3e 7f			ld a, FORTH_END_BUFFER 
1d77 77				ld (hl),a 
1d78 23				inc hl 
1d79 3e 21			ld a, '!' 
1d7b 77				ld (hl),a 
1d7c			 
1d7c 2a 61 e6			ld hl,(os_tok_ptr) 
1d7f			         
1d7f			if DEBUG_FORTH_TOK 
1d7f						DMARK "TK1" 
1d7f				CALLMONITOR 
1d7f			endif 
1d7f			 
1d7f				; push exec string to top of return stack 
1d7f				FORTH_RSP_NEXT 
1d7f cd 33 19			call macro_forth_rsp_next 
1d82				endm 
# End of macro FORTH_RSP_NEXT
1d82 c9				ret 
1d83			 
1d83			; 
1d83			;	; malloc size + buffer pointer + if is loop flag 
1d83			;	ld hl,(os_tok_len) 		 ; get string length 
1d83			; 
1d83			;	ld a,l 
1d83			; 
1d83			;	cp 0			; we dont want to use a null string 
1d83			;	ret z 
1d83			; 
1d83			;;	add 3    ; prefix malloc with buffer for current word ptr 
1d83			; 
1d83			;	add 5     ; TODO when certain not over writing memory remove 
1d83			; 
1d83			;		 
1d83			; 
1d83			;if DEBUG_FORTH_TOK 
1d83			;			DMARK "TKE" 
1d83			;	CALLMONITOR 
1d83			;endif 
1d83			; 
1d83			;	ld l,a 
1d83			;	ld h,0 
1d83			;;	push hl   ; save required space for the copy later 
1d83			;	call malloc 
1d83			;if DEBUG_FORTH_TOK 
1d83			;			DMARK "TKM" 
1d83			;	CALLMONITOR 
1d83			;endif 
1d83			;	if DEBUG_FORTH_MALLOC_GUARD 
1d83			;		push af 
1d83			;		call ishlzero 
1d83			;;		ld a, l 
1d83			;;		add h 
1d83			;;		cp 0 
1d83			;		pop af 
1d83			;		 
1d83			;		call z,malloc_error 
1d83			;	endif 
1d83			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1d83			; 
1d83			; 
1d83			;if DEBUG_FORTH_TOK 
1d83			;			DMARK "TKR" 
1d83			;	CALLMONITOR 
1d83			;endif 
1d83			; 
1d83			;	FORTH_RSP_NEXT 
1d83			; 
1d83			;	;inc hl	 ; go past current buffer pointer 
1d83			;	;inc hl 
1d83			;	;inc hl   ; and past if loop flag 
1d83			;		; TODO Need to set flag  
1d83			; 
1d83			;	 
1d83			;	 
1d83			;	ex de,hl	; malloc is dest 
1d83			;	ld hl, (os_tok_len) 
1d83			;;	pop bc 
1d83			;	ld c, l                
1d83			;	ld b,0 
1d83			;	ld hl, (os_tok_ptr) 
1d83			; 
1d83			;if DEBUG_FORTH_TOK 
1d83			;			DMARK "TKT" 
1d83			;	CALLMONITOR 
1d83			;endif 
1d83			; 
1d83			;	; do str cpy 
1d83			; 
1d83			;	ldir      ; copy byte in hl to de 
1d83			; 
1d83			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1d83			; 
1d83			;if DEBUG_FORTH_TOK 
1d83			; 
1d83			;			DMARK "TKY" 
1d83			;	CALLMONITOR 
1d83			;endif 
1d83			;	;ld a,0 
1d83			;	;ld a,FORTH_END_BUFFER 
1d83			;	ex de, hl 
1d83			;	;dec hl			 ; go back over the space delim at the end of word 
1d83			;	;ld (hl),a 
1d83			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1d83			;	ld a,FORTH_END_BUFFER 
1d83			;	ld (hl),a 
1d83			;	inc hl 
1d83			;	ld a,FORTH_END_BUFFER 
1d83			;	ld (hl),a 
1d83			; 
1d83			;	; init the malloc area data 
1d83			;	; set pc for in current area 
1d83			;	;ld hl, (os_tok_malloc) 
1d83			;	;inc hl 
1d83			;	;inc hl 
1d83			;	;inc hl 
1d83			;	;ex de,hl 
1d83			;	;ld hl, (os_tok_malloc) 
1d83			;	;ld (hl),e 
1d83			;	;inc hl 
1d83			;	;ld (hl),d 
1d83			; 
1d83			; 
1d83			;	ld hl,(os_tok_malloc) 
1d83			;if DEBUG_FORTH_PARSE_KEY 
1d83			;			DMARK "TKU" 
1d83			;	CALLMONITOR 
1d83			;endif 
1d83			; 
1d83			;	ret 
1d83			 
1d83			forthexec: 
1d83			 
1d83			; line exec: 
1d83			; forth parser 
1d83			 
1d83			; 
1d83			;       get current exec line on rsp 
1d83			 
1d83				FORTH_RSP_TOS 
1d83 cd 4a 19			call macro_forth_rsp_tos 
1d86				endm 
# End of macro FORTH_RSP_TOS
1d86			 
1d86			;       restore current pc - hl points to malloc of data 
1d86			 
1d86				;ld e, (hl) 
1d86				;inc hl 
1d86				;ld d, (hl) 
1d86				;ex de,hl 
1d86			 
1d86			 
1d86			exec1: 
1d86 22 61 e6			ld (os_tok_ptr), hl 
1d89			 
1d89				; copy our PC to working vars  
1d89 22 2b eb			ld (cli_ptr), hl 
1d8c 22 29 eb			ld (cli_origptr), hl 
1d8f			 
1d8f 7e				ld a,(hl) 
1d90 fe 7f			cp FORTH_END_BUFFER 
1d92 c8				ret z 
1d93			 
1d93				; skip any nulls 
1d93			 
1d93 fe 00			cp 0 
1d95 20 03			jr nz, .execword 
1d97 23				inc hl 
1d98 18 ec			jr exec1 
1d9a			 
1d9a			 
1d9a			.execword: 
1d9a			 
1d9a			 
1d9a			 
1d9a			if DEBUG_FORTH_PARSE_KEY 
1d9a						DMARK "KYQ" 
1d9a				CALLMONITOR 
1d9a			endif 
1d9a			;       while at start of word: 
1d9a			; get start of dict (in user area first) 
1d9a			 
1d9a 21 d7 59		ld hl, baseram 
1d9d			;ld hl, sysdict 
1d9d 22 2d eb		ld (cli_nextword),hl 
1da0			;           match word at pc 
1da0			;           exec word 
1da0			;           or push to dsp 
1da0			;           forward to next token 
1da0			;           if line term pop rsp and exit 
1da0			;        
1da0			 
1da0			if DEBUG_FORTH_PARSE_KEY 
1da0						DMARK "KYq" 
1da0				CALLMONITOR 
1da0			endif 
1da0			 
1da0			; 
1da0			; word comp 
1da0			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1da0			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1da0			;    move to start of word  
1da0			;    compare word to cli_token 
1da0			 
1da0			.execpnword:	; HL at start of a word in the dictionary to check 
1da0			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1da0			;	ld (cli_ptr), hl 
1da0			 
1da0 2a 2d eb			ld hl,(cli_nextword) 
1da3			 
1da3 cd 46 1e			call forth_tok_next 
1da6			; tok next start here 
1da6			;	; TODO skip compiled symbol for now 
1da6			;	inc hl 
1da6			; 
1da6			;	; save pointer to next word 
1da6			; 
1da6			;	; hl now points to the address of the next word pointer  
1da6			;	ld e, (hl) 
1da6			;	inc hl 
1da6			;	ld d, (hl) 
1da6			;	inc l 
1da6			; 
1da6			;	ex de,hl 
1da6			;if DEBUG_FORTH_PARSE_NEXTWORD 
1da6			;	push bc 
1da6			;	ld bc, (cli_nextword) 
1da6			;			DMARK "NXW" 
1da6			;	CALLMONITOR 
1da6			;	pop bc 
1da6			;endif 
1da6			; tok next end here 
1da6 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1da9 eb				ex de, hl 
1daa			 
1daa			 
1daa				; save the pointer of the current token - 1 to check against 
1daa				 
1daa 22 31 eb			ld (cli_token), hl   
1dad				; TODO maybe remove below save if no debug 
1dad				; save token string ptr for any debug later 
1dad 23				inc hl  
1dae 22 33 eb			ld (cli_origtoken), hl 
1db1 2b				dec hl 
1db2				; save pointer to the start of the next dictionay word 
1db2 7e				ld a,(hl)   ; get string length 
1db3 47				ld b,a 
1db4			.execpnwordinc:  
1db4 23				inc hl 
1db5 10 fd			djnz .execpnwordinc 
1db7 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
1dba			 
1dba				; now check the word token against the string being parsed 
1dba			 
1dba 2a 31 eb			ld hl,(cli_token) 
1dbd 23				inc hl     ; skip string length (use zero term instead to end) 
1dbe 22 31 eb			ld (cli_token), hl 
1dc1			 
1dc1			if DEBUG_FORTH_PARSE_KEY 
1dc1						DMARK "KY2" 
1dc1			endif 
1dc1			if DEBUG_FORTH_PARSE_EXEC 
1dc1				; see if disabled 
1dc1			 
1dc1				ld a, (os_view_disable) 
1dc1				cp '*' 
1dc1				jr z, .skip 
1dc1			 
1dc1				push hl 
1dc1				push hl 
1dc1				call clear_display 
1dc1				ld de, .compword 
1dc1				ld a, display_row_1 
1dc1				call str_at_display 
1dc1				pop de 
1dc1				ld a, display_row_2 
1dc1				call str_at_display 
1dc1				ld hl,(cli_ptr) 
1dc1				ld a,(hl) 
1dc1			        ld hl, os_word_scratch 
1dc1				ld (hl),a 
1dc1				ld a,0 
1dc1				inc hl 
1dc1				ld (hl),a 	 
1dc1				ld de, os_word_scratch 
1dc1				ld a, display_row_2+10 
1dc1				call str_at_display 
1dc1				call update_display 
1dc1				ld a, 100 
1dc1				call aDelayInMS 
1dc1				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1dc1				call delay250ms 
1dc1				endif 
1dc1				pop hl 
1dc1			.skip:  
1dc1			endif	 
1dc1			.execpnchar:    ; compare char between token and string to parse 
1dc1			 
1dc1			if DEBUG_FORTH_PARSE_KEY 
1dc1						DMARK "Ky3" 
1dc1			endif 
1dc1			if DEBUG_FORTH_PARSE_EXEC 
1dc1				; see if disabled 
1dc1			 
1dc1				ld a, (os_view_disable) 
1dc1				cp '*' 
1dc1				jr z, .skip2 
1dc1			 
1dc1			;	call clear_display 
1dc1			ld hl,(cli_token) 
1dc1			ld a,(hl) 
1dc1			ld (os_word_scratch),a 
1dc1				ld hl,(cli_ptr) 
1dc1			ld a,(hl) 
1dc1				ld (os_word_scratch+1),a 
1dc1				ld a,0 
1dc1				ld (os_word_scratch+2),a 
1dc1				ld de,os_word_scratch 
1dc1				ld a,display_row_4 
1dc1				call str_at_display 
1dc1				call update_display 
1dc1			.skip2:  
1dc1			endif 
1dc1 2a 31 eb			ld hl,(cli_token) 
1dc4 7e				ld a, (hl)	 ; char in word token 
1dc5 23				inc hl 		; move to next char 
1dc6 22 31 eb			ld (cli_token), hl ; and save it 
1dc9 47				ld b,a 
1dca			 
1dca 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1dcd 7e				ld a,(hl) 
1dce 23				inc hl 
1dcf 22 2b eb			ld (cli_ptr), hl		; move to next char 
1dd2 cd 07 10			call toUpper 		; make sure the input string matches case 
1dd5			 
1dd5			if DEBUG_FORTH_PARSE 
1dd5			endif 
1dd5			 
1dd5				; input stream end of token is a space so get rid of it 
1dd5			 
1dd5			;	cp ' ' 
1dd5			;	jr nz, .pnskipspace 
1dd5			; 
1dd5			;	ld a, 0		; make same term as word token term 
1dd5			; 
1dd5			;.pnskipspace: 
1dd5			 
1dd5			if DEBUG_FORTH_PARSE_KEY 
1dd5						DMARK "KY7" 
1dd5			endif 
1dd5 b8				cp b 
1dd6 c2 ec 1d			jp nz, .execpnskipword	 ; no match so move to next word 
1dd9				 
1dd9			;    if same 
1dd9			;       scan for string terms 0 for token and 32 for input 
1dd9			 
1dd9				 
1dd9			if DEBUG_FORTH_PARSE_KEY 
1dd9						DMARK "KY8" 
1dd9			endif 
1dd9			 
1dd9 80				add b			 
1dda fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1ddc							; TODO need to make sure last word in zero term string is accounted for 
1ddc 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1dde			 
1dde			 
1dde				; at end of both strings so both are exact match 
1dde			 
1dde			;       skip ptr for next word 
1dde			 
1dde 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
1de1 23				inc hl			 ; at next char 
1de2 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
1de5 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1de8				 
1de8				 
1de8			if DEBUG_FORTH_PARSE_KEY 
1de8						DMARK "KY3" 
1de8			endif 
1de8			 
1de8			 
1de8			 
1de8			;       exec code block 
1de8			if DEBUG_FORTH_JP 
1de8				call clear_display 
1de8				call update_display 
1de8				call delay1s 
1de8				ld hl, (cli_execword)     ; save for next check if no match on this word 
1de8				ld a,h 
1de8				ld hl, os_word_scratch 
1de8				call hexout 
1de8				ld hl, (cli_execword)     ; save for next check if no match on this word 
1de8				ld a,l 
1de8				ld hl, os_word_scratch+2 
1de8				call hexout 
1de8				ld hl, os_word_scratch+4 
1de8				ld a,0 
1de8				ld (hl),a 
1de8				ld de,os_word_scratch 
1de8				call str_at_display 
1de8					ld a, display_row_2 
1de8					call str_at_display 
1de8				ld de, (cli_origtoken) 
1de8				ld a, display_row_1+10 
1de8					call str_at_display 
1de8			 
1de8				ld a,display_row_1 
1de8				ld de, .foundword 
1de8				ld a, display_row_3 
1de8				call str_at_display 
1de8				call update_display 
1de8				call delay1s 
1de8				call delay1s 
1de8				call delay1s 
1de8			endif 
1de8			 
1de8			if DEBUG_FORTH_PARSE_KEY 
1de8						DMARK "KYj" 
1de8			endif 
1de8				; TODO save the word pointer in this exec 
1de8			 
1de8 2a 2f eb			ld hl,(cli_execword) 
1deb e9				jp (hl) 
1dec			 
1dec			 
1dec			;    if not same 
1dec			;	scan for zero term 
1dec			;	get ptr for next word 
1dec			;	goto word comp 
1dec			 
1dec			.execpnskipword:	; get pointer to next word 
1dec 2a 2d eb			ld hl,(cli_nextword) 
1def			 
1def 7e				ld a,(hl) 
1df0 fe 00			cp WORD_SYS_END 
1df2			;	cp 0 
1df2 28 09			jr z, .execendofdict			 ; at end of words 
1df4			 
1df4			if DEBUG_FORTH_PARSE_KEY 
1df4						DMARK "KY4" 
1df4			endif 
1df4			if DEBUG_FORTH_PARSE_EXEC 
1df4			 
1df4				; see if disabled 
1df4			 
1df4				ld a, (os_view_disable) 
1df4				cp '*' 
1df4				jr z, .noskip 
1df4			 
1df4			 
1df4				ld de, .nowordfound 
1df4				ld a, display_row_3 
1df4				call str_at_display 
1df4				call update_display 
1df4				ld a, 100 
1df4				call aDelayInMS 
1df4				 
1df4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1df4					call delay250ms 
1df4				endif 
1df4			.noskip:  
1df4			 
1df4			endif	 
1df4			 
1df4 2a 29 eb			ld hl,(cli_origptr) 
1df7 22 2b eb			ld (cli_ptr),hl 
1dfa			 
1dfa			if DEBUG_FORTH_PARSE_KEY 
1dfa						DMARK "KY5" 
1dfa			endif 
1dfa c3 a0 1d			jp .execpnword			; else go to next word 
1dfd			 
1dfd			.execendofdict:  
1dfd			 
1dfd			if DEBUG_FORTH_PARSE_KEY 
1dfd						DMARK "KYe" 
1dfd			endif 
1dfd			if DEBUG_FORTH_PARSE_EXEC 
1dfd				; see if disabled 
1dfd			 
1dfd				ld a, (os_view_disable) 
1dfd				cp '*' 
1dfd				jr z, .ispskip 
1dfd			 
1dfd				call clear_display 
1dfd				call update_display 
1dfd				call delay1s 
1dfd				ld de, (cli_origptr) 
1dfd				ld a, display_row_1 
1dfd				call str_at_display 
1dfd				 
1dfd				ld de, .enddict 
1dfd				ld a, display_row_3 
1dfd				call str_at_display 
1dfd				call update_display 
1dfd				ld a, 100 
1dfd				call aDelayInMS 
1dfd				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1dfd				call delay1s 
1dfd				call delay1s 
1dfd				call delay1s 
1dfd				endif 
1dfd			.ispskip:  
1dfd				 
1dfd			endif	 
1dfd			 
1dfd			 
1dfd			 
1dfd				; if the word is not a keyword then must be a literal so push it to stack 
1dfd			 
1dfd			; push token to stack to end of word 
1dfd			 
1dfd				STACKFRAME ON $1efe $2f9f 
1dfd				if DEBUG_STACK_IMB 
1dfd					if ON 
1dfd						exx 
1dfd						ld de, $1efe 
1dfd						ld a, d 
1dfd						ld hl, curframe 
1dfd						call hexout 
1dfd						ld a, e 
1dfd						ld hl, curframe+2 
1dfd						call hexout 
1dfd						ld hl, $1efe 
1dfd						push hl 
1dfd						ld hl, $2f9f 
1dfd						push hl 
1dfd						exx 
1dfd					endif 
1dfd				endif 
1dfd			endm 
# End of macro STACKFRAME
1dfd			 
1dfd 2a 61 e6		ld hl,(os_tok_ptr) 
1e00 cd f5 1a		call forth_apush 
1e03			 
1e03				STACKFRAMECHK ON $1efe $2f9f 
1e03				if DEBUG_STACK_IMB 
1e03					if ON 
1e03						exx 
1e03						ld hl, $2f9f 
1e03						pop de   ; $2f9f 
1e03						call cmp16 
1e03						jr nz, .spnosame 
1e03						ld hl, $1efe 
1e03						pop de   ; $1efe 
1e03						call cmp16 
1e03						jr z, .spfrsame 
1e03						.spnosame: call showsperror 
1e03						.spfrsame: nop 
1e03						exx 
1e03					endif 
1e03				endif 
1e03			endm 
# End of macro STACKFRAMECHK
1e03			 
1e03			execnext: 
1e03			 
1e03			if DEBUG_FORTH_PARSE_KEY 
1e03						DMARK "KY>" 
1e03			endif 
1e03			; move past token to next word 
1e03			 
1e03 2a 61 e6		ld hl, (os_tok_ptr) 
1e06 3e 00		ld a, 0 
1e08 01 ff 00		ld bc, 255     ; input buffer size 
1e0b ed b1		cpir 
1e0d			 
1e0d			if DEBUG_FORTH_PARSE_KEY 
1e0d						DMARK "KY!" 
1e0d				CALLMONITOR 
1e0d			endif	 
1e0d			; TODO this might place hl on the null, so will need to forward on??? 
1e0d			;inc hl   ; see if this gets onto the next item 
1e0d			 
1e0d			 
1e0d			; TODO pass a pointer to the buffer to push 
1e0d			; TODO call function to push 
1e0d			 
1e0d			; look for end of input 
1e0d			 
1e0d			;inc hl 
1e0d			;ld a,(hl) 
1e0d			;cp FORTH_END_BUFFER 
1e0d			;ret z 
1e0d			 
1e0d			 
1e0d c3 86 1d		jp exec1 
1e10			 
1e10			 
1e10			 
1e10			 
1e10			 
1e10			 
1e10			 
1e10			 
1e10			 
1e10			findnexttok: 
1e10			 
1e10				; hl is pointer to move 
1e10				; de is the token to locate 
1e10			 
1e10					if DEBUG_FORTH 
1e10						DMARK "NTK" 
1e10						CALLMONITOR 
1e10					endif 
1e10 d5				push de 
1e11			 
1e11			.fnt1:	 
1e11				; find first char of token to locate 
1e11			 
1e11 1a				ld a, (de) 
1e12 4f				ld c,a 
1e13 7e				ld a,(hl) 
1e14 cd 07 10			call toUpper 
1e17					if DEBUG_FORTH 
1e17						DMARK "NT1" 
1e17						CALLMONITOR 
1e17					endif 
1e17 b9				cp c 
1e18			 
1e18 28 03			jr z, .fnt2cmpmorefirst	 
1e1a			 
1e1a				; first char not found move to next char 
1e1a			 
1e1a 23				inc hl 
1e1b 18 f4			jr .fnt1 
1e1d			 
1e1d			.fnt2cmpmorefirst:	 
1e1d				; first char of token found.  
1e1d			 
1e1d e5				push hl     ; save start of token just in case it is the right one 
1e1e d9				exx 
1e1f e1				pop hl        ; save it to hl' 
1e20 d9				exx 
1e21			 
1e21			 
1e21			.fnt2cmpmore:	 
1e21				; compare the rest 
1e21				 
1e21 23				inc hl 
1e22 13				inc de 
1e23				 
1e23 1a				ld a, (de) 
1e24 4f				ld c,a 
1e25 7e				ld a,(hl) 
1e26 cd 07 10			call toUpper 
1e29			 
1e29					if DEBUG_FORTH 
1e29						DMARK "NT2" 
1e29						CALLMONITOR 
1e29					endif 
1e29				; c has the token to find char 
1e29				; a has the mem to scan char 
1e29			 
1e29 b9				cp c 
1e2a 28 04			jr z,.fntmatch1 
1e2c			 
1e2c				; they are not the same 
1e2c			 
1e2c					if DEBUG_FORTH 
1e2c						DMARK "NT3" 
1e2c						CALLMONITOR 
1e2c					endif 
1e2c d1				pop de	; reset de token to look for 
1e2d d5				push de 
1e2e 18 e1			jr .fnt1 
1e30				 
1e30			.fntmatch1: 
1e30			 
1e30				; is the same char a null which means we might have a full hit? 
1e30					if DEBUG_FORTH 
1e30						DMARK "NT4" 
1e30						CALLMONITOR 
1e30					endif 
1e30			 
1e30 fe 00			cp 0 
1e32 28 0b			jr z, .fntmatchyes 
1e34			 
1e34				; are we at the end of the token to find? 
1e34			 
1e34					if DEBUG_FORTH 
1e34						DMARK "NT5" 
1e34						CALLMONITOR 
1e34					endif 
1e34 3e 00			ld a, 0 
1e36 b9				cp c 
1e37			 
1e37 c2 21 1e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1e3a			 
1e3a					if DEBUG_FORTH 
1e3a						DMARK "NT6" 
1e3a						CALLMONITOR 
1e3a					endif 
1e3a				; token to find is exhusted but no match to stream 
1e3a			 
1e3a				; restore tok pointer and continue on 
1e3a d1				pop de 
1e3b d5				push de 
1e3c c3 11 1e			jp .fnt1 
1e3f			 
1e3f			 
1e3f			.fntmatchyes: 
1e3f			 
1e3f				; hl now contains the end of the found token 
1e3f			 
1e3f				; get rid of saved token pointer to find 
1e3f			 
1e3f d1				pop de 
1e40			 
1e40					if DEBUG_FORTH 
1e40						DMARK "NT9" 
1e40						CALLMONITOR 
1e40					endif 
1e40			 
1e40				; hl will be on the null term so forward on 
1e40			 
1e40				; get back the saved start of the token 
1e40			 
1e40 d9				exx 
1e41 e5				push hl     ; save start of token just in case it is the right one 
1e42 d9				exx 
1e43 e1				pop hl        ; save it to hl 
1e44			 
1e44 c9				ret 
1e45			 
1e45			 
1e45			; LIST needs to find a specific token   
1e45			; FORGET needs to find a spefici token 
1e45			 
1e45			; SAVE needs to find all tokens by flag 
1e45			; WORDS just needs to scan through all  by flag 
1e45			; UWORDS needs to scan through all by flag 
1e45			 
1e45			 
1e45			; given hl as pointer to start of dict look up string 
1e45			; return hl as pointer to start of word block 
1e45			; or 0 if not found 
1e45			 
1e45			forth_find_tok: 
1e45 c9				ret 
1e46			 
1e46			; given hl as pointer to dict structure 
1e46			; move to the next dict block structure 
1e46			 
1e46			forth_tok_next: 
1e46				; hl now points to the address of the next word pointer  
1e46				; TODO skip compiled symbol for now 
1e46			;	push de 
1e46 23				inc hl 
1e47 5e				ld e, (hl) 
1e48 23				inc hl 
1e49 56				ld d, (hl) 
1e4a 23				inc hl 
1e4b			 
1e4b eb				ex de,hl 
1e4c			if DEBUG_FORTH_PARSE_NEXTWORD 
1e4c				push bc 
1e4c				ld bc, (cli_nextword) 
1e4c						DMARK "NXW" 
1e4c				CALLMONITOR 
1e4c				pop bc 
1e4c			endif 
1e4c			;	pop de	 
1e4c c9				ret 
1e4d			 
1e4d			 
1e4d			 
1e4d			; eof 
# End of file forth_parserv5.asm
1e4d				include "forth_wordsv4.asm" 
1e4d			 
1e4d			; the core word dictionary v4 
1e4d			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1e4d			 
1e4d			; this is a linked list for each of the system words used 
1e4d			; user defined words will follow the same format but will be in ram 
1e4d			 
1e4d			 
1e4d			; 
1e4d			; 
1e4d			; define linked list: 
1e4d			; 
1e4d			; 1. compiled byte op code 
1e4d			; 2. len of text word 
1e4d			; 3. text word 
1e4d			; 4. ptr to next dictionary word 
1e4d			; 5. asm, calls etc for the word 
1e4d			; 
1e4d			;  if 1 == 0 then last word in dict  
1e4d			;   
1e4d			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1e4d			;  
1e4d			;  
1e4d			; create basic standard set of words 
1e4d			; 
1e4d			;  
1e4d			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1e4d			; 2DUP 2DROP 2SWAP  
1e4d			; @ C@ - get byte  
1e4d			; ! C! - store byte 
1e4d			; 0< true if less than zero 
1e4d			; 0= true if zero 
1e4d			; < >  
1e4d			; = true if same 
1e4d			; variables 
1e4d			 
1e4d			 
1e4d			; Hardware specific words I may need 
1e4d			; 
1e4d			; IN OUT  
1e4d			; calls to key util functions 
1e4d			; calls to hardward abstraction stuff 
1e4d			; easy control of frame buffers and lcd i/o 
1e4d			; keyboard  
1e4d			 
1e4d			 
1e4d			;DICT: macro 
1e4d			; op_code, len, word, next 
1e4d			;    word: 
1e4d			;    db op_code 
1e4d			;    ds word zero term 
1e4d			;    dw next 
1e4d			;    endm 
1e4d			 
1e4d			 
1e4d			 
1e4d			 
1e4d			; op code 1 is a flag for user define words which are to be handled differently 
1e4d			 
1e4d			 
1e4d			; 
1e4d			; 
1e4d			;    TODO on entry to a word this should be the expected environment 
1e4d			;    hl - tos value if number then held, if string this is the ptr 
1e4d			;    de -  
1e4d			 
1e4d			 
1e4d			; opcode ranges 
1e4d			; 0 - end of word dict 
1e4d			; 255 - user define words 
1e4d			 
1e4d			sysdict: 
1e4d			include "forth_opcodes.asm" 
1e4d			; op codes for forth keywords 
1e4d			; free to use code 0  
1e4d				OPCODE_HEAP: equ  1 
1e4d				OPCODE_EXEC: equ 2 
1e4d				OPCODE_DUP: equ 3 
1e4d				OPCODE_SWAP: equ 4 
1e4d				OPCODE_COLN: equ 5 
1e4d				OPCODE_SCOLN: equ 6 
1e4d				OPCODE_DROP: equ 7 
1e4d				OPCODE_DUP2: equ 8 
1e4d				OPCODE_DROP2: equ 9 
1e4d				OPCODE_SWAP2: equ 10 
1e4d				OPCODE_AT: equ 11 
1e4d				OPCODE_CAT: equ 12 
1e4d				OPCODE_BANG: equ 13 
1e4d				OPCODE_CBANG: equ 14 
1e4d				OPCODE_SCALL: equ 15 
1e4d				OPCODE_DEPTH: equ 16 
1e4d				OPCODE_OVER: equ 17 
1e4d				OPCODE_PAUSE: equ 18 
1e4d				OPCODE_PAUSES: equ 19 
1e4d				OPCODE_ROT: equ 20 
1e4d			;free to reuse	OPCODE_WORDS: equ 21 
1e4d			        OPCODE_NOT: equ 21 
1e4d				OPCODE_UWORDS: equ 22 
1e4d				OPCODE_BP: equ 23 
1e4d				OPCODE_MONITOR: equ 24  
1e4d				OPCODE_MALLOC: equ 25 
1e4d				OPCODE_FREE: equ 26 
1e4d				OPCODE_LIST: equ 27 
1e4d				OPCODE_FORGET: equ 28 
1e4d				OPCODE_NOP: equ 29 
1e4d				OPCODE_COMO: equ 30 
1e4d				OPCODE_COMC: equ 31 
1e4d			;free to reuse	OPCODE_ENDCORE: equ 32 
1e4d				OPCODE_AFTERSOUND: equ 33 
1e4d				OPCODE_GP2: equ 34 
1e4d				OPCODE_GP3: equ 35 
1e4d				OPCODE_GP4: equ 36 
1e4d				OPCODE_SIN: equ 37 
1e4d				OPCODE_SOUT: equ 38 
1e4d				OPCODE_SPIO: equ 39 
1e4d				OPCODE_SPICEH: equ 40 
1e4d				OPCODE_SPIOb: equ 41 
1e4d				OPCODE_SPII: equ 42 
1e4d				OPCODE_SESEL: equ 43 
1e4d				OPCODE_CARTDEV: equ 44 
1e4d			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1e4d				OPCODE_FB: equ 46 
1e4d				OPCODE_EMIT: equ 47 
1e4d				OPCODE_DOTH: equ 48 
1e4d				OPCODE_DOTF: equ 49 
1e4d				OPCODE_DOT: equ 50 
1e4d				OPCODE_CLS: equ 51 
1e4d				OPCODE_DRAW: equ 52 
1e4d				OPCODE_DUMP: equ 53 
1e4d				OPCODE_CDUMP: equ 54 
1e4d				OPCODE_DAT: equ 55 
1e4d				OPCODE_HOME: equ 56 
1e4d				OPCODE_SPACE: equ 57 
1e4d				OPCODE_SPACES: equ 58 
1e4d				OPCODE_SCROLL: equ 59 
1e4d				OPCODE_ATQ: equ 60 
1e4d				OPCODE_AUTODSP: equ 61 
1e4d				OPCODE_MENU: equ 62 
1e4d			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1e4d				OPCODE_THEN: equ 64 
1e4d				OPCODE_ELSE: equ 65 
1e4d				OPCODE_DO: equ 66 
1e4d				OPCODE_LOOP: equ 67 
1e4d				OPCODE_I: equ 68 
1e4d				OPCODE_DLOOP: equ 69  
1e4d				OPCODE_REPEAT: equ 70  
1e4d				OPCODE_UNTIL: equ 71 
1e4d				OPCODE_ENDFLOW: equ 72 
1e4d				OPCODE_WAITK: equ 73 
1e4d				OPCODE_ACCEPT: equ 74 
1e4d				OPCODE_EDIT: equ 75 
1e4d			;free to reuse	OPCODE_ENDKEY: equ 76 
1e4d				OPCODE_LZERO: equ 77 
1e4d				OPCODE_TZERO: equ 78 
1e4d				OPCODE_LESS: equ 79 
1e4d				OPCODE_GT: equ 80 
1e4d				OPCODE_EQUAL: equ 81  
1e4d			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1e4d				OPCODE_NEG: equ 83 
1e4d				OPCODE_DIV: equ 84 
1e4d				OPCODE_MUL: equ 85 
1e4d				OPCODE_MIN: equ 86 
1e4d				OPCODE_MAX: equ 87 
1e4d				OPCODE_RND16: equ 88 
1e4d				OPCODE_RND8: equ 89 
1e4d				OPCODE_RND: equ 90 
1e4d			;free to reuse	OPCODE_ENDMATHS: equ 91  
1e4d				OPCODE_BYNAME: equ 92 
1e4d				OPCODE_DIR: equ 93 
1e4d				OPCODE_SAVE: equ 94 
1e4d				OPCODE_LOAD: equ 95 
1e4d				OPCODE_BSAVE: equ 96 
1e4d				OPCODE_BLOAD: equ 97 
1e4d				OPCODE_SEO: equ 98  
1e4d				OPCODE_SEI: equ 99 
1e4d				OPCODE_SFREE: equ 100 
1e4d				OPCODE_SIZE: equ 101 
1e4d				OPCODE_CREATE: equ 102 
1e4d				OPCODE_APPEND: equ 103 
1e4d				OPCODE_SDEL: equ 104 
1e4d				OPCODE_OPEN: equ 105 
1e4d				OPCODE_READ: equ 106 
1e4d				OPCODE_EOF: equ 106 
1e4d				OPCODE_FORMAT: equ 107 
1e4d				OPCODE_LABEL: equ 108 
1e4d				OPCODE_LABELS: equ 109 
1e4d			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1e4d				OPCODE_UPPER: equ 111 
1e4d				OPCODE_LOWER: equ 112 
1e4d				OPCODE_SUBSTR: equ 113 
1e4d				OPCODE_LEFT: equ 114 
1e4d				OPCODE_RIGHT: equ 115 
1e4d				OPCODE_STR2NUM: equ 116 
1e4d				OPCODE_NUM2STR: equ 117 
1e4d				OPCODE_CONCAT: equ 118 
1e4d				OPCODE_FIND: equ 119 
1e4d				OPCODE_LEN: equ 120 
1e4d				OPCODE_CHAR: equ 121 
1e4d			; free to reuse	OPCODE_STRLEN: equ 122 
1e4d			; free to reuse	OPCODE_ENDSTR: equ 123 
1e4d				OPCODE_V0S: equ 124 
1e4d				OPCODE_V0Q: equ 125 
1e4d				OPCODE_V1S: equ 126 
1e4d				OPCODE_V1Q: equ 127 
1e4d				OPCODE_V2S: equ 128 
1e4d				OPCODE_V2Q: equ 129 
1e4d				OPCODE_V3S: equ 130 
1e4d				OPCODE_V3Q: equ 131 
1e4d			;free to reuse	OPCODE_END: equ 132 
1e4d				OPCODE_ZDUP: equ 133 
1e4d			 
1e4d			; eof 
# End of file forth_opcodes.asm
1e4d			 
1e4d			include "forth_words_core.asm" 
1e4d			 
1e4d			; | ## Core Words 
1e4d			 
1e4d			;if MALLOC_4 
1e4d			 
1e4d			.HEAP: 
1e4d				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1e4d 15				db WORD_SYS_CORE+OPCODE_HEAP             
1e4e 8c 1e			dw .EXEC            
1e50 05				db 4 + 1 
1e51 .. 00			db "HEAP",0              
1e56				endm 
# End of macro CWHEAD
1e56			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1e56			; | | u1 - Current number of bytes in the heap 
1e56			; | | u2 - Remaining bytes left on the heap 
1e56			; | |  
1e56			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1e56			 
1e56			 
1e56					if DEBUG_FORTH_WORDS_KEY 
1e56						DMARK "HEP" 
1e56 f5				push af  
1e57 3a 6b 1e			ld a, (.dmark)  
1e5a 32 7a ee			ld (debug_mark),a  
1e5d 3a 6c 1e			ld a, (.dmark+1)  
1e60 32 7b ee			ld (debug_mark+1),a  
1e63 3a 6d 1e			ld a, (.dmark+2)  
1e66 32 7c ee			ld (debug_mark+2),a  
1e69 18 03			jr .pastdmark  
1e6b ..			.dmark: db "HEP"  
1e6e f1			.pastdmark: pop af  
1e6f			endm  
# End of macro DMARK
1e6f						CALLMONITOR 
1e6f cd ff 13			call break_point_state  
1e72				endm  
# End of macro CALLMONITOR
1e72					endif 
1e72 2a e1 59				ld hl, (free_list )      
1e75 11 e6 59				ld de, heap_start 
1e78			 
1e78 ed 52				sbc hl, de  
1e7a			 
1e7a cd 8c 19				call forth_push_numhl 
1e7d			 
1e7d			 
1e7d ed 5b e1 59			ld de, (free_list )      
1e81 21 46 e3				ld hl, heap_end 
1e84			 
1e84 ed 52				sbc hl, de 
1e86			 
1e86 cd 8c 19				call forth_push_numhl 
1e89					 
1e89			 
1e89					 
1e89			 
1e89			 
1e89			 
1e89					NEXTW 
1e89 c3 f5 1c			jp macro_next 
1e8c				endm 
# End of macro NEXTW
1e8c			;endif 
1e8c			 
1e8c			.EXEC: 
1e8c				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1e8c 16				db WORD_SYS_CORE+OPCODE_EXEC             
1e8d 28 1f			dw .STKEXEC            
1e8f 05				db 4 + 1 
1e90 .. 00			db "EXEC",0              
1e95				endm 
# End of macro CWHEAD
1e95			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1e95			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1e95			; | | 
1e95			; | |   
1e95				STACKFRAME OFF $5efe $5f9f 
1e95				if DEBUG_STACK_IMB 
1e95					if OFF 
1e95						exx 
1e95						ld de, $5efe 
1e95						ld a, d 
1e95						ld hl, curframe 
1e95						call hexout 
1e95						ld a, e 
1e95						ld hl, curframe+2 
1e95						call hexout 
1e95						ld hl, $5efe 
1e95						push hl 
1e95						ld hl, $5f9f 
1e95						push hl 
1e95						exx 
1e95					endif 
1e95				endif 
1e95			endm 
# End of macro STACKFRAME
1e95			 
1e95					if DEBUG_FORTH_WORDS_KEY 
1e95						DMARK "EXE" 
1e95 f5				push af  
1e96 3a aa 1e			ld a, (.dmark)  
1e99 32 7a ee			ld (debug_mark),a  
1e9c 3a ab 1e			ld a, (.dmark+1)  
1e9f 32 7b ee			ld (debug_mark+1),a  
1ea2 3a ac 1e			ld a, (.dmark+2)  
1ea5 32 7c ee			ld (debug_mark+2),a  
1ea8 18 03			jr .pastdmark  
1eaa ..			.dmark: db "EXE"  
1ead f1			.pastdmark: pop af  
1eae			endm  
# End of macro DMARK
1eae						CALLMONITOR 
1eae cd ff 13			call break_point_state  
1eb1				endm  
# End of macro CALLMONITOR
1eb1					endif 
1eb1			 
1eb1				FORTH_DSP_VALUEHL 
1eb1 cd 83 1b			call macro_dsp_valuehl 
1eb4				endm 
# End of macro FORTH_DSP_VALUEHL
1eb4			 
1eb4				FORTH_DSP_POP 
1eb4 cd 3b 1c			call macro_forth_dsp_pop 
1eb7				endm 
# End of macro FORTH_DSP_POP
1eb7			 
1eb7					if DEBUG_FORTH_WORDS 
1eb7						DMARK "EX1" 
1eb7 f5				push af  
1eb8 3a cc 1e			ld a, (.dmark)  
1ebb 32 7a ee			ld (debug_mark),a  
1ebe 3a cd 1e			ld a, (.dmark+1)  
1ec1 32 7b ee			ld (debug_mark+1),a  
1ec4 3a ce 1e			ld a, (.dmark+2)  
1ec7 32 7c ee			ld (debug_mark+2),a  
1eca 18 03			jr .pastdmark  
1ecc ..			.dmark: db "EX1"  
1ecf f1			.pastdmark: pop af  
1ed0			endm  
# End of macro DMARK
1ed0						CALLMONITOR 
1ed0 cd ff 13			call break_point_state  
1ed3				endm  
# End of macro CALLMONITOR
1ed3					endif 
1ed3			;	ld e,(hl) 
1ed3			;	inc hl 
1ed3			;	ld d,(hl) 
1ed3			;	ex de,hl 
1ed3			 
1ed3			;		if DEBUG_FORTH_WORDS 
1ed3			;			DMARK "EX2" 
1ed3			;			CALLMONITOR 
1ed3			;		endif 
1ed3 e5				push hl 
1ed4			 
1ed4				;ld a, 0 
1ed4				;ld a, FORTH_END_BUFFER 
1ed4 cd 10 10			call strlenz 
1ed7 23				inc hl   ; include zero term to copy 
1ed8 23				inc hl   ; include term 
1ed9 23				inc hl   ; include term 
1eda 06 00			ld b,0 
1edc 4d				ld c,l 
1edd e1				pop hl 
1ede 11 5f e4			ld de, execscratch 
1ee1					if DEBUG_FORTH_WORDS 
1ee1						DMARK "EX3" 
1ee1 f5				push af  
1ee2 3a f6 1e			ld a, (.dmark)  
1ee5 32 7a ee			ld (debug_mark),a  
1ee8 3a f7 1e			ld a, (.dmark+1)  
1eeb 32 7b ee			ld (debug_mark+1),a  
1eee 3a f8 1e			ld a, (.dmark+2)  
1ef1 32 7c ee			ld (debug_mark+2),a  
1ef4 18 03			jr .pastdmark  
1ef6 ..			.dmark: db "EX3"  
1ef9 f1			.pastdmark: pop af  
1efa			endm  
# End of macro DMARK
1efa						CALLMONITOR 
1efa cd ff 13			call break_point_state  
1efd				endm  
# End of macro CALLMONITOR
1efd					endif 
1efd ed b0			ldir 
1eff			 
1eff			 
1eff 21 5f e4			ld hl, execscratch 
1f02			 
1f02					if DEBUG_FORTH_WORDS 
1f02						DMARK "EXe" 
1f02 f5				push af  
1f03 3a 17 1f			ld a, (.dmark)  
1f06 32 7a ee			ld (debug_mark),a  
1f09 3a 18 1f			ld a, (.dmark+1)  
1f0c 32 7b ee			ld (debug_mark+1),a  
1f0f 3a 19 1f			ld a, (.dmark+2)  
1f12 32 7c ee			ld (debug_mark+2),a  
1f15 18 03			jr .pastdmark  
1f17 ..			.dmark: db "EXe"  
1f1a f1			.pastdmark: pop af  
1f1b			endm  
# End of macro DMARK
1f1b						CALLMONITOR 
1f1b cd ff 13			call break_point_state  
1f1e				endm  
# End of macro CALLMONITOR
1f1e					endif 
1f1e			 
1f1e cd 43 1d			call forthparse 
1f21 cd 83 1d			call forthexec 
1f24			;	call forthexec_cleanup 
1f24			;	call forthparse 
1f24			;	call forthexec 
1f24			 
1f24				STACKFRAMECHK OFF $5efe $5f9f 
1f24				if DEBUG_STACK_IMB 
1f24					if OFF 
1f24						exx 
1f24						ld hl, $5f9f 
1f24						pop de   ; $5f9f 
1f24						call cmp16 
1f24						jr nz, .spnosame 
1f24						ld hl, $5efe 
1f24						pop de   ; $5efe 
1f24						call cmp16 
1f24						jr z, .spfrsame 
1f24						.spnosame: call showsperror 
1f24						.spfrsame: nop 
1f24						exx 
1f24					endif 
1f24				endif 
1f24			endm 
# End of macro STACKFRAMECHK
1f24			 
1f24				; an immediate word so no need to process any more words 
1f24 c9				ret 
1f25				NEXTW 
1f25 c3 f5 1c			jp macro_next 
1f28				endm 
# End of macro NEXTW
1f28			 
1f28			; dead code - old version  
1f28			;	FORTH_RSP_NEXT 
1f28			 
1f28			;  
1f28			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f28			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f28			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f28			;	push hl 
1f28			;	push de 
1f28			;	push bc 
1f28			; 
1f28			; 
1f28			;		if DEBUG_FORTH_WORDS_KEY 
1f28			;			DMARK "EXR" 
1f28			;			CALLMONITOR 
1f28			;		endif 
1f28			; 
1f28			; 
1f28			; 
1f28			;	;v5 FORTH_DSP_VALUE 
1f28			;	FORTH_DSP_VALUEHL 
1f28			; 
1f28			;	; TODO do string type checks 
1f28			; 
1f28			;;v5	inc hl   ; skip type 
1f28			; 
1f28			;	push hl  ; source code  
1f28			;		if DEBUG_FORTH_WORDS 
1f28			;			DMARK "EX1" 
1f28			;			CALLMONITOR 
1f28			;		endif 
1f28			;	ld a, 0 
1f28			;	call strlent 
1f28			; 
1f28			;	inc hl 
1f28			;	inc hl 
1f28			;	inc hl 
1f28			;	inc hl 
1f28			; 
1f28			;	push hl    ; size 
1f28			; 
1f28			;		if DEBUG_FORTH_WORDS 
1f28			;			DMARK "EX2" 
1f28			;			CALLMONITOR 
1f28			;		endif 
1f28			;	call malloc 
1f28			; 
1f28			;	ex de, hl    ; de now contains malloc area 
1f28			;	pop bc   	; get byte count 
1f28			;	pop hl      ; get string to copy 
1f28			; 
1f28			;	push de     ; save malloc for free later 
1f28			; 
1f28			;		if DEBUG_FORTH_WORDS 
1f28			;			DMARK "EX3" 
1f28			;			CALLMONITOR 
1f28			;		endif 
1f28			;	ldir       ; duplicate string 
1f28			; 
1f28			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1f28			;	 
1f28			;	; TODO fix the parse would be better than this...  
1f28			;	ex de, hl 
1f28			;	dec hl 
1f28			;	ld a, 0 
1f28			;	ld (hl), a 
1f28			;	dec hl 
1f28			;	ld a, ' ' 
1f28			;	ld (hl), a 
1f28			;	dec hl 
1f28			;	ld (hl), a 
1f28			; 
1f28			;	dec hl 
1f28			;	ld (hl), a 
1f28			; 
1f28			; 
1f28			;	FORTH_DSP_POP  
1f28			; 
1f28			;	pop hl     
1f28			;	push hl    ; save malloc area 
1f28			; 
1f28			;		if DEBUG_FORTH_WORDS 
1f28			;			DMARK "EX4" 
1f28			;			CALLMONITOR 
1f28			;		endif 
1f28			; 
1f28			;	call forthparse 
1f28			;	call forthexec 
1f28			;	 
1f28			;	pop hl 
1f28			;	if DEBUG_FORTH_WORDS 
1f28			;		DMARK "EX5" 
1f28			;		CALLMONITOR 
1f28			;	endif 
1f28			; 
1f28			;	if FORTH_ENABLE_FREE 
1f28			;	call free 
1f28			;	endif 
1f28			; 
1f28			;	if DEBUG_FORTH_WORDS 
1f28			;		DMARK "EX6" 
1f28			;		CALLMONITOR 
1f28			;	endif 
1f28			; 
1f28			;	pop bc 
1f28			;	pop de 
1f28			;	pop hl 
1f28			;;	FORTH_RSP_POP	  
1f28			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1f28			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1f28			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1f28			; 
1f28			;	if DEBUG_FORTH_WORDS 
1f28			;		DMARK "EX7" 
1f28			;		CALLMONITOR 
1f28			;	endif 
1f28			;	NEXTW 
1f28			 
1f28			.STKEXEC: 
1f28				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1f28 3f				db WORD_SYS_CORE+43             
1f29 70 20			dw .ZDUP            
1f2b 08				db 7 + 1 
1f2c .. 00			db "STKEXEC",0              
1f34				endm 
# End of macro CWHEAD
1f34			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1f34			 
1f34			 
1f34					if DEBUG_FORTH_WORDS_KEY 
1f34						DMARK "STX" 
1f34 f5				push af  
1f35 3a 49 1f			ld a, (.dmark)  
1f38 32 7a ee			ld (debug_mark),a  
1f3b 3a 4a 1f			ld a, (.dmark+1)  
1f3e 32 7b ee			ld (debug_mark+1),a  
1f41 3a 4b 1f			ld a, (.dmark+2)  
1f44 32 7c ee			ld (debug_mark+2),a  
1f47 18 03			jr .pastdmark  
1f49 ..			.dmark: db "STX"  
1f4c f1			.pastdmark: pop af  
1f4d			endm  
# End of macro DMARK
1f4d						CALLMONITOR 
1f4d cd ff 13			call break_point_state  
1f50				endm  
# End of macro CALLMONITOR
1f50					endif 
1f50			 
1f50				FORTH_DSP_VALUEHL 
1f50 cd 83 1b			call macro_dsp_valuehl 
1f53				endm 
# End of macro FORTH_DSP_VALUEHL
1f53			 
1f53 22 63 eb			ld (store_tmp1), hl    ; count 
1f56			 
1f56				FORTH_DSP_POP 
1f56 cd 3b 1c			call macro_forth_dsp_pop 
1f59				endm 
# End of macro FORTH_DSP_POP
1f59			.stkexec1: 
1f59 2a 63 eb			ld hl, (store_tmp1)   ; count 
1f5c 3e 00			ld a, 0 
1f5e bd				cp l 
1f5f c8				ret z 
1f60			 
1f60 2b				dec hl 
1f61 22 63 eb			ld (store_tmp1), hl    ; count 
1f64				 
1f64				FORTH_DSP_VALUEHL 
1f64 cd 83 1b			call macro_dsp_valuehl 
1f67				endm 
# End of macro FORTH_DSP_VALUEHL
1f67 e5				push hl 
1f68				 
1f68					if DEBUG_FORTH_WORDS 
1f68						DMARK "EXp" 
1f68 f5				push af  
1f69 3a 7d 1f			ld a, (.dmark)  
1f6c 32 7a ee			ld (debug_mark),a  
1f6f 3a 7e 1f			ld a, (.dmark+1)  
1f72 32 7b ee			ld (debug_mark+1),a  
1f75 3a 7f 1f			ld a, (.dmark+2)  
1f78 32 7c ee			ld (debug_mark+2),a  
1f7b 18 03			jr .pastdmark  
1f7d ..			.dmark: db "EXp"  
1f80 f1			.pastdmark: pop af  
1f81			endm  
# End of macro DMARK
1f81						CALLMONITOR 
1f81 cd ff 13			call break_point_state  
1f84				endm  
# End of macro CALLMONITOR
1f84					endif 
1f84				FORTH_DSP_POP 
1f84 cd 3b 1c			call macro_forth_dsp_pop 
1f87				endm 
# End of macro FORTH_DSP_POP
1f87			 
1f87 cd 10 10			call strlenz 
1f8a 23				inc hl   ; include zero term to copy 
1f8b 23				inc hl   ; include zero term to copy 
1f8c 23				inc hl   ; include zero term to copy 
1f8d 06 00			ld b,0 
1f8f 4d				ld c,l 
1f90 e1				pop hl 
1f91 11 5f e4			ld de, execscratch 
1f94					if DEBUG_FORTH_WORDS 
1f94						DMARK "EX3" 
1f94 f5				push af  
1f95 3a a9 1f			ld a, (.dmark)  
1f98 32 7a ee			ld (debug_mark),a  
1f9b 3a aa 1f			ld a, (.dmark+1)  
1f9e 32 7b ee			ld (debug_mark+1),a  
1fa1 3a ab 1f			ld a, (.dmark+2)  
1fa4 32 7c ee			ld (debug_mark+2),a  
1fa7 18 03			jr .pastdmark  
1fa9 ..			.dmark: db "EX3"  
1fac f1			.pastdmark: pop af  
1fad			endm  
# End of macro DMARK
1fad						CALLMONITOR 
1fad cd ff 13			call break_point_state  
1fb0				endm  
# End of macro CALLMONITOR
1fb0					endif 
1fb0 ed b0			ldir 
1fb2			 
1fb2			 
1fb2 21 5f e4			ld hl, execscratch 
1fb5			 
1fb5					if DEBUG_FORTH_WORDS 
1fb5						DMARK "EXP" 
1fb5 f5				push af  
1fb6 3a ca 1f			ld a, (.dmark)  
1fb9 32 7a ee			ld (debug_mark),a  
1fbc 3a cb 1f			ld a, (.dmark+1)  
1fbf 32 7b ee			ld (debug_mark+1),a  
1fc2 3a cc 1f			ld a, (.dmark+2)  
1fc5 32 7c ee			ld (debug_mark+2),a  
1fc8 18 03			jr .pastdmark  
1fca ..			.dmark: db "EXP"  
1fcd f1			.pastdmark: pop af  
1fce			endm  
# End of macro DMARK
1fce						CALLMONITOR 
1fce cd ff 13			call break_point_state  
1fd1				endm  
# End of macro CALLMONITOR
1fd1					endif 
1fd1			 
1fd1 cd 43 1d			call forthparse 
1fd4 21 5f e4			ld hl, execscratch 
1fd7					if DEBUG_FORTH_WORDS 
1fd7						DMARK "EXx" 
1fd7 f5				push af  
1fd8 3a ec 1f			ld a, (.dmark)  
1fdb 32 7a ee			ld (debug_mark),a  
1fde 3a ed 1f			ld a, (.dmark+1)  
1fe1 32 7b ee			ld (debug_mark+1),a  
1fe4 3a ee 1f			ld a, (.dmark+2)  
1fe7 32 7c ee			ld (debug_mark+2),a  
1fea 18 03			jr .pastdmark  
1fec ..			.dmark: db "EXx"  
1fef f1			.pastdmark: pop af  
1ff0			endm  
# End of macro DMARK
1ff0						CALLMONITOR 
1ff0 cd ff 13			call break_point_state  
1ff3				endm  
# End of macro CALLMONITOR
1ff3					endif 
1ff3 cd 83 1d			call forthexec 
1ff6			 
1ff6 c3 59 1f			jp .stkexec1 
1ff9			 
1ff9 c9				ret 
1ffa			 
1ffa			 
1ffa			.DUP: 
1ffa				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1ffa 17				db WORD_SYS_CORE+OPCODE_DUP             
1ffb 70 20			dw .ZDUP            
1ffd 04				db 3 + 1 
1ffe .. 00			db "DUP",0              
2002				endm 
# End of macro CWHEAD
2002			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2002			 
2002					if DEBUG_FORTH_WORDS_KEY 
2002						DMARK "DUP" 
2002 f5				push af  
2003 3a 17 20			ld a, (.dmark)  
2006 32 7a ee			ld (debug_mark),a  
2009 3a 18 20			ld a, (.dmark+1)  
200c 32 7b ee			ld (debug_mark+1),a  
200f 3a 19 20			ld a, (.dmark+2)  
2012 32 7c ee			ld (debug_mark+2),a  
2015 18 03			jr .pastdmark  
2017 ..			.dmark: db "DUP"  
201a f1			.pastdmark: pop af  
201b			endm  
# End of macro DMARK
201b						CALLMONITOR 
201b cd ff 13			call break_point_state  
201e				endm  
# End of macro CALLMONITOR
201e					endif 
201e			 
201e					FORTH_DSP 
201e cd 49 1b			call macro_forth_dsp 
2021				endm 
# End of macro FORTH_DSP
2021			 
2021 7e					ld a, (HL) 
2022 fe 01				cp DS_TYPE_STR 
2024 20 25				jr nz, .dupinum 
2026			 
2026					; push another string 
2026			 
2026					FORTH_DSP_VALUEHL     		 
2026 cd 83 1b			call macro_dsp_valuehl 
2029				endm 
# End of macro FORTH_DSP_VALUEHL
2029			 
2029				if DEBUG_FORTH_WORDS 
2029					DMARK "DUs" 
2029 f5				push af  
202a 3a 3e 20			ld a, (.dmark)  
202d 32 7a ee			ld (debug_mark),a  
2030 3a 3f 20			ld a, (.dmark+1)  
2033 32 7b ee			ld (debug_mark+1),a  
2036 3a 40 20			ld a, (.dmark+2)  
2039 32 7c ee			ld (debug_mark+2),a  
203c 18 03			jr .pastdmark  
203e ..			.dmark: db "DUs"  
2041 f1			.pastdmark: pop af  
2042			endm  
# End of macro DMARK
2042					CALLMONITOR 
2042 cd ff 13			call break_point_state  
2045				endm  
# End of macro CALLMONITOR
2045				endif 
2045 cd fa 19				call forth_push_str 
2048			 
2048					NEXTW 
2048 c3 f5 1c			jp macro_next 
204b				endm 
# End of macro NEXTW
204b			 
204b			 
204b			.dupinum: 
204b					 
204b			 
204b			 
204b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
204b cd 83 1b			call macro_dsp_valuehl 
204e				endm 
# End of macro FORTH_DSP_VALUEHL
204e			 
204e				; TODO add floating point number detection 
204e			 
204e				if DEBUG_FORTH_WORDS 
204e					DMARK "DUi" 
204e f5				push af  
204f 3a 63 20			ld a, (.dmark)  
2052 32 7a ee			ld (debug_mark),a  
2055 3a 64 20			ld a, (.dmark+1)  
2058 32 7b ee			ld (debug_mark+1),a  
205b 3a 65 20			ld a, (.dmark+2)  
205e 32 7c ee			ld (debug_mark+2),a  
2061 18 03			jr .pastdmark  
2063 ..			.dmark: db "DUi"  
2066 f1			.pastdmark: pop af  
2067			endm  
# End of macro DMARK
2067					CALLMONITOR 
2067 cd ff 13			call break_point_state  
206a				endm  
# End of macro CALLMONITOR
206a				endif 
206a			 
206a cd 8c 19				call forth_push_numhl 
206d					NEXTW 
206d c3 f5 1c			jp macro_next 
2070				endm 
# End of macro NEXTW
2070			.ZDUP: 
2070				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2070 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2071 a8 20			dw .SWAP            
2073 05				db 4 + 1 
2074 .. 00			db "?DUP",0              
2079				endm 
# End of macro CWHEAD
2079			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2079			 
2079					if DEBUG_FORTH_WORDS_KEY 
2079						DMARK "qDU" 
2079 f5				push af  
207a 3a 8e 20			ld a, (.dmark)  
207d 32 7a ee			ld (debug_mark),a  
2080 3a 8f 20			ld a, (.dmark+1)  
2083 32 7b ee			ld (debug_mark+1),a  
2086 3a 90 20			ld a, (.dmark+2)  
2089 32 7c ee			ld (debug_mark+2),a  
208c 18 03			jr .pastdmark  
208e ..			.dmark: db "qDU"  
2091 f1			.pastdmark: pop af  
2092			endm  
# End of macro DMARK
2092						CALLMONITOR 
2092 cd ff 13			call break_point_state  
2095				endm  
# End of macro CALLMONITOR
2095					endif 
2095					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2095 cd 83 1b			call macro_dsp_valuehl 
2098				endm 
# End of macro FORTH_DSP_VALUEHL
2098			 
2098 e5					push hl 
2099			 
2099					; is it a zero? 
2099			 
2099 3e 00				ld a, 0 
209b 84					add h 
209c 85					add l 
209d			 
209d e1					pop hl 
209e			 
209e fe 00				cp 0 
20a0 28 03				jr z, .dup2orig 
20a2			 
20a2			 
20a2 cd 8c 19				call forth_push_numhl 
20a5			 
20a5			 
20a5				; TODO add floating point number detection 
20a5			 
20a5			.dup2orig: 
20a5			 
20a5					NEXTW 
20a5 c3 f5 1c			jp macro_next 
20a8				endm 
# End of macro NEXTW
20a8			.SWAP: 
20a8				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
20a8 18				db WORD_SYS_CORE+OPCODE_SWAP             
20a9 e7 20			dw .COLN            
20ab 05				db 4 + 1 
20ac .. 00			db "SWAP",0              
20b1				endm 
# End of macro CWHEAD
20b1			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
20b1					if DEBUG_FORTH_WORDS_KEY 
20b1						DMARK "SWP" 
20b1 f5				push af  
20b2 3a c6 20			ld a, (.dmark)  
20b5 32 7a ee			ld (debug_mark),a  
20b8 3a c7 20			ld a, (.dmark+1)  
20bb 32 7b ee			ld (debug_mark+1),a  
20be 3a c8 20			ld a, (.dmark+2)  
20c1 32 7c ee			ld (debug_mark+2),a  
20c4 18 03			jr .pastdmark  
20c6 ..			.dmark: db "SWP"  
20c9 f1			.pastdmark: pop af  
20ca			endm  
# End of macro DMARK
20ca						CALLMONITOR 
20ca cd ff 13			call break_point_state  
20cd				endm  
# End of macro CALLMONITOR
20cd					endif 
20cd			 
20cd					FORTH_DSP_VALUEHL 
20cd cd 83 1b			call macro_dsp_valuehl 
20d0				endm 
# End of macro FORTH_DSP_VALUEHL
20d0 e5					push hl     ; w2 
20d1			 
20d1					FORTH_DSP_POP 
20d1 cd 3b 1c			call macro_forth_dsp_pop 
20d4				endm 
# End of macro FORTH_DSP_POP
20d4			 
20d4					FORTH_DSP_VALUEHL 
20d4 cd 83 1b			call macro_dsp_valuehl 
20d7				endm 
# End of macro FORTH_DSP_VALUEHL
20d7			 
20d7					FORTH_DSP_POP 
20d7 cd 3b 1c			call macro_forth_dsp_pop 
20da				endm 
# End of macro FORTH_DSP_POP
20da			 
20da d1					pop de     ; w2	, hl = w1 
20db			 
20db eb					ex de, hl 
20dc d5					push de 
20dd			 
20dd cd 8c 19				call forth_push_numhl 
20e0			 
20e0 e1					pop hl 
20e1			 
20e1 cd 8c 19				call forth_push_numhl 
20e4					 
20e4			 
20e4					NEXTW 
20e4 c3 f5 1c			jp macro_next 
20e7				endm 
# End of macro NEXTW
20e7			.COLN: 
20e7				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
20e7 19				db WORD_SYS_CORE+OPCODE_COLN             
20e8 73 22			dw .SCOLN            
20ea 02				db 1 + 1 
20eb .. 00			db ":",0              
20ed				endm 
# End of macro CWHEAD
20ed			; | : ( -- )         Create new word | DONE 
20ed			 
20ed					if DEBUG_FORTH_WORDS_KEY 
20ed						DMARK "CLN" 
20ed f5				push af  
20ee 3a 02 21			ld a, (.dmark)  
20f1 32 7a ee			ld (debug_mark),a  
20f4 3a 03 21			ld a, (.dmark+1)  
20f7 32 7b ee			ld (debug_mark+1),a  
20fa 3a 04 21			ld a, (.dmark+2)  
20fd 32 7c ee			ld (debug_mark+2),a  
2100 18 03			jr .pastdmark  
2102 ..			.dmark: db "CLN"  
2105 f1			.pastdmark: pop af  
2106			endm  
# End of macro DMARK
2106						CALLMONITOR 
2106 cd ff 13			call break_point_state  
2109				endm  
# End of macro CALLMONITOR
2109					endif 
2109				STACKFRAME OFF $8efe $989f 
2109				if DEBUG_STACK_IMB 
2109					if OFF 
2109						exx 
2109						ld de, $8efe 
2109						ld a, d 
2109						ld hl, curframe 
2109						call hexout 
2109						ld a, e 
2109						ld hl, curframe+2 
2109						call hexout 
2109						ld hl, $8efe 
2109						push hl 
2109						ld hl, $989f 
2109						push hl 
2109						exx 
2109					endif 
2109				endif 
2109			endm 
# End of macro STACKFRAME
2109				; get parser buffer length  of new word 
2109			 
2109				 
2109			 
2109					; move tok past this to start of name defintition 
2109					; TODO get word to define 
2109					; TODO Move past word token 
2109					; TODO get length of string up to the ';' 
2109			 
2109 2a 61 e6			ld hl, (os_tok_ptr) 
210c 23				inc hl 
210d 23				inc hl 
210e			 
210e 3e 3b			ld a, ';' 
2110 cd 1b 10			call strlent 
2113			 
2113 7d				ld a,l 
2114 32 5c e3			ld (os_new_parse_len), a 
2117			 
2117			 
2117			if DEBUG_FORTH_UWORD 
2117 ed 5b 61 e6		ld de, (os_tok_ptr) 
211b						DMARK ":01" 
211b f5				push af  
211c 3a 30 21			ld a, (.dmark)  
211f 32 7a ee			ld (debug_mark),a  
2122 3a 31 21			ld a, (.dmark+1)  
2125 32 7b ee			ld (debug_mark+1),a  
2128 3a 32 21			ld a, (.dmark+2)  
212b 32 7c ee			ld (debug_mark+2),a  
212e 18 03			jr .pastdmark  
2130 ..			.dmark: db ":01"  
2133 f1			.pastdmark: pop af  
2134			endm  
# End of macro DMARK
2134				CALLMONITOR 
2134 cd ff 13			call break_point_state  
2137				endm  
# End of macro CALLMONITOR
2137			endif 
2137			 
2137			; 
2137			;  new word memory layout: 
2137			;  
2137			;    : adg 6666 ;  
2137			; 
2137			;    db   1     ; user defined word  
2137 23				inc hl    
2138			;    dw   sysdict 
2138 23				inc hl 
2139 23				inc hl 
213a			;    db <word len>+1 (for null) 
213a 23				inc hl 
213b			;    db .... <word> 
213b			; 
213b			 
213b 23				inc hl    ; some extras for the word preamble before the above 
213c 23				inc hl 
213d 23				inc hl 
213e 23				inc hl 
213f 23				inc hl 
2140 23				inc hl 
2141 23				inc hl  
2142 23				inc hl 
2143 23				inc hl 
2144 23				inc hl 
2145 23				inc hl 
2146 23				inc hl 
2147 23				inc hl 
2148 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2149			;       exec word buffer 
2149			;	<ptr word>   
2149 23				inc hl 
214a 23				inc hl 
214b			;       <word list><null term> 7F final term 
214b			 
214b			 
214b			if DEBUG_FORTH_UWORD 
214b						DMARK ":02" 
214b f5				push af  
214c 3a 60 21			ld a, (.dmark)  
214f 32 7a ee			ld (debug_mark),a  
2152 3a 61 21			ld a, (.dmark+1)  
2155 32 7b ee			ld (debug_mark+1),a  
2158 3a 62 21			ld a, (.dmark+2)  
215b 32 7c ee			ld (debug_mark+2),a  
215e 18 03			jr .pastdmark  
2160 ..			.dmark: db ":02"  
2163 f1			.pastdmark: pop af  
2164			endm  
# End of macro DMARK
2164				CALLMONITOR 
2164 cd ff 13			call break_point_state  
2167				endm  
# End of macro CALLMONITOR
2167			endif 
2167			 
2167				 
2167					; malloc the size 
2167			 
2167 cd 79 10				call malloc 
216a 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
216d			 
216d			;    db   1     ; user defined word  
216d 3e 01				ld a, WORD_SYS_UWORD  
216f 77					ld (hl), a 
2170				 
2170 23				inc hl    
2171			;    dw   sysdict 
2171 11 4d 1e			ld de, sysdict       ; continue on with the scan to the system dict 
2174 73				ld (hl), e 
2175 23				inc hl 
2176 72				ld (hl), d 
2177 23				inc hl 
2178			 
2178			 
2178			;    Setup dict word 
2178			 
2178 23				inc hl 
2179 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
217c			 
217c				; 1. get length of dict word 
217c			 
217c			 
217c 2a 61 e6			ld hl, (os_tok_ptr) 
217f 23				inc hl 
2180 23				inc hl    ; position to start of dict word 
2181 3e 00			ld a, 0 
2183 cd 1b 10			call strlent 
2186			 
2186			 
2186 23				inc hl    ; to include null??? 
2187			 
2187				; write length of dict word 
2187			 
2187 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
218b 1b				dec de 
218c eb				ex de, hl 
218d 73				ld (hl), e 
218e eb				ex de, hl 
218f			 
218f				 
218f			 
218f				; copy  
218f 4d				ld c, l 
2190 06 00			ld b, 0 
2192 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2196 2a 61 e6			ld hl, (os_tok_ptr) 
2199 23				inc hl 
219a 23				inc hl    ; position to start of dict word 
219b				 
219b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
219b				 
219b				; TODO need to convert word to upper case 
219b			 
219b			ucasetok:	 
219b 7e				ld a,(hl) 
219c cd 07 10			call toUpper 
219f 77				ld (hl),a 
21a0 ed a0			ldi 
21a2 f2 9b 21		 	jp p, ucasetok 
21a5			 
21a5			 
21a5			 
21a5				; de now points to start of where the word body code should be placed 
21a5 ed 53 58 e3		ld (os_new_work_ptr), de 
21a9				; hl now points to the words to throw at forthexec which needs to be copied 
21a9 22 56 e3			ld (os_new_src_ptr), hl 
21ac			 
21ac				; TODO add 'call to forthexec' 
21ac			 
21ac			if DEBUG_FORTH_UWORD 
21ac c5				push bc 
21ad ed 4b 5e e3		ld bc, (os_new_malloc) 
21b1						DMARK ":0x" 
21b1 f5				push af  
21b2 3a c6 21			ld a, (.dmark)  
21b5 32 7a ee			ld (debug_mark),a  
21b8 3a c7 21			ld a, (.dmark+1)  
21bb 32 7b ee			ld (debug_mark+1),a  
21be 3a c8 21			ld a, (.dmark+2)  
21c1 32 7c ee			ld (debug_mark+2),a  
21c4 18 03			jr .pastdmark  
21c6 ..			.dmark: db ":0x"  
21c9 f1			.pastdmark: pop af  
21ca			endm  
# End of macro DMARK
21ca				CALLMONITOR 
21ca cd ff 13			call break_point_state  
21cd				endm  
# End of macro CALLMONITOR
21cd c1				pop bc 
21ce			endif 
21ce			 
21ce			 
21ce				; create word preamble which should be: 
21ce			 
21ce			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
21ce			 
21ce				;    ld hl, <word code> 
21ce				;    jp user_exec 
21ce			        ;    <word code bytes> 
21ce			 
21ce			 
21ce			;	inc de     ; TODO ??? or are we already past the word's null 
21ce eb				ex de, hl 
21cf			 
21cf 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
21d1			 
21d1 23				inc hl 
21d2 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
21d5 23				inc hl 
21d6			 
21d6 23				inc hl 
21d7 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
21d9			 
21d9 01 62 45			ld bc, user_exec 
21dc 23				inc hl 
21dd 71				ld (hl), c     ; poke address of user_exec 
21de 23				inc hl 
21df 70				ld (hl), b     
21e0			 ; 
21e0			;	inc hl 
21e0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
21e0			; 
21e0			; 
21e0			;	ld bc, macro_forth_rsp_next 
21e0			;	inc hl 
21e0			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
21e0			;	inc hl 
21e0			;	ld (hl), b     
21e0			 ; 
21e0			;	inc hl 
21e0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
21e0			; 
21e0			; 
21e0			;	inc hl 
21e0			;	ld bc, forthexec 
21e0			;	ld (hl), c     ; poke address of forthexec 
21e0			;	inc hl 
21e0			;	ld (hl), b      
21e0			; 
21e0			;	inc hl 
21e0			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
21e0			; 
21e0			;	ld bc, user_dict_next 
21e0			;	inc hl 
21e0			;	ld (hl), c     ; poke address of forthexec 
21e0			;	inc hl 
21e0			;	ld (hl), b      
21e0			 
21e0				; hl is now where we need to copy the word byte data to save this 
21e0			 
21e0 23				inc hl 
21e1 22 54 e3			ld (os_new_exec), hl 
21e4				 
21e4				; copy definition 
21e4			 
21e4 eb				ex de, hl 
21e5			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
21e5			;	inc de    ; skip the PC for this parse 
21e5 3a 5c e3			ld a, (os_new_parse_len) 
21e8 4f				ld c, a 
21e9 06 00			ld b, 0 
21eb ed b0			ldir		 ; copy defintion 
21ed			 
21ed			 
21ed				; poke the address of where the new word bytes live for forthexec 
21ed			 
21ed 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
21f0			 
21f0 ed 5b 54 e3		ld de, (os_new_exec)      
21f4				 
21f4 73				ld (hl), e 
21f5 23				inc hl 
21f6 72				ld (hl), d 
21f7			 
21f7					; TODO copy last user dict word next link to this word 
21f7					; TODO update last user dict word to point to this word 
21f7			; 
21f7			; hl f923 de 812a ; bc 811a 
21f7			 
21f7			if DEBUG_FORTH_UWORD 
21f7 c5				push bc 
21f8 ed 4b 5e e3		ld bc, (os_new_malloc) 
21fc						DMARK ":0A" 
21fc f5				push af  
21fd 3a 11 22			ld a, (.dmark)  
2200 32 7a ee			ld (debug_mark),a  
2203 3a 12 22			ld a, (.dmark+1)  
2206 32 7b ee			ld (debug_mark+1),a  
2209 3a 13 22			ld a, (.dmark+2)  
220c 32 7c ee			ld (debug_mark+2),a  
220f 18 03			jr .pastdmark  
2211 ..			.dmark: db ":0A"  
2214 f1			.pastdmark: pop af  
2215			endm  
# End of macro DMARK
2215				CALLMONITOR 
2215 cd ff 13			call break_point_state  
2218				endm  
# End of macro CALLMONITOR
2218 c1				pop bc 
2219			endif 
2219			if DEBUG_FORTH_UWORD 
2219 c5				push bc 
221a ed 4b 5e e3		ld bc, (os_new_malloc) 
221e 03				inc bc 
221f 03				inc bc 
2220 03				inc bc 
2221 03				inc bc 
2222 03				inc bc 
2223 03				inc bc 
2224 03				inc bc 
2225 03				inc bc 
2226			 
2226						DMARK ":0B" 
2226 f5				push af  
2227 3a 3b 22			ld a, (.dmark)  
222a 32 7a ee			ld (debug_mark),a  
222d 3a 3c 22			ld a, (.dmark+1)  
2230 32 7b ee			ld (debug_mark+1),a  
2233 3a 3d 22			ld a, (.dmark+2)  
2236 32 7c ee			ld (debug_mark+2),a  
2239 18 03			jr .pastdmark  
223b ..			.dmark: db ":0B"  
223e f1			.pastdmark: pop af  
223f			endm  
# End of macro DMARK
223f				CALLMONITOR 
223f cd ff 13			call break_point_state  
2242				endm  
# End of macro CALLMONITOR
2242 c1				pop bc 
2243			endif 
2243			 
2243			; update word dict linked list for new word 
2243			 
2243			 
2243 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2246 23			inc hl     ; move to next work linked list ptr 
2247			 
2247 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
224b 73			ld (hl), e 
224c 23			inc hl 
224d 72			ld (hl), d 
224e			 
224e			if DEBUG_FORTH_UWORD 
224e ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2252			endif 
2252			 
2252 ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2256			 
2256			 
2256			if DEBUG_FORTH_UWORD 
2256						DMARK ":0+" 
2256 f5				push af  
2257 3a 6b 22			ld a, (.dmark)  
225a 32 7a ee			ld (debug_mark),a  
225d 3a 6c 22			ld a, (.dmark+1)  
2260 32 7b ee			ld (debug_mark+1),a  
2263 3a 6d 22			ld a, (.dmark+2)  
2266 32 7c ee			ld (debug_mark+2),a  
2269 18 03			jr .pastdmark  
226b ..			.dmark: db ":0+"  
226e f1			.pastdmark: pop af  
226f			endm  
# End of macro DMARK
226f				CALLMONITOR 
226f cd ff 13			call break_point_state  
2272				endm  
# End of macro CALLMONITOR
2272			endif 
2272			 
2272				STACKFRAMECHK OFF $8efe $989f 
2272				if DEBUG_STACK_IMB 
2272					if OFF 
2272						exx 
2272						ld hl, $989f 
2272						pop de   ; $989f 
2272						call cmp16 
2272						jr nz, .spnosame 
2272						ld hl, $8efe 
2272						pop de   ; $8efe 
2272						call cmp16 
2272						jr z, .spfrsame 
2272						.spnosame: call showsperror 
2272						.spfrsame: nop 
2272						exx 
2272					endif 
2272				endif 
2272			endm 
# End of macro STACKFRAMECHK
2272			 
2272 c9			ret    ; dont process any remaining parser tokens as they form new word 
2273			 
2273			 
2273			 
2273			 
2273			;		NEXT 
2273			.SCOLN: 
2273			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2273 06				db OPCODE_SCOLN 
2274 bf 22			dw .DROP 
2276 02				db 2 
2277 .. 00			db ";",0           
2279			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2279					if DEBUG_FORTH_WORDS_KEY 
2279						DMARK "SCN" 
2279 f5				push af  
227a 3a 8e 22			ld a, (.dmark)  
227d 32 7a ee			ld (debug_mark),a  
2280 3a 8f 22			ld a, (.dmark+1)  
2283 32 7b ee			ld (debug_mark+1),a  
2286 3a 90 22			ld a, (.dmark+2)  
2289 32 7c ee			ld (debug_mark+2),a  
228c 18 03			jr .pastdmark  
228e ..			.dmark: db "SCN"  
2291 f1			.pastdmark: pop af  
2292			endm  
# End of macro DMARK
2292						CALLMONITOR 
2292 cd ff 13			call break_point_state  
2295				endm  
# End of macro CALLMONITOR
2295					endif 
2295					FORTH_RSP_TOS 
2295 cd 4a 19			call macro_forth_rsp_tos 
2298				endm 
# End of macro FORTH_RSP_TOS
2298 e5					push hl 
2299					FORTH_RSP_POP 
2299 cd 54 19			call macro_forth_rsp_pop 
229c				endm 
# End of macro FORTH_RSP_POP
229c e1					pop hl 
229d			;		ex de,hl 
229d 22 61 e6				ld (os_tok_ptr),hl 
22a0			 
22a0			if DEBUG_FORTH_UWORD 
22a0						DMARK "SCL" 
22a0 f5				push af  
22a1 3a b5 22			ld a, (.dmark)  
22a4 32 7a ee			ld (debug_mark),a  
22a7 3a b6 22			ld a, (.dmark+1)  
22aa 32 7b ee			ld (debug_mark+1),a  
22ad 3a b7 22			ld a, (.dmark+2)  
22b0 32 7c ee			ld (debug_mark+2),a  
22b3 18 03			jr .pastdmark  
22b5 ..			.dmark: db "SCL"  
22b8 f1			.pastdmark: pop af  
22b9			endm  
# End of macro DMARK
22b9				CALLMONITOR 
22b9 cd ff 13			call break_point_state  
22bc				endm  
# End of macro CALLMONITOR
22bc			endif 
22bc					NEXTW 
22bc c3 f5 1c			jp macro_next 
22bf				endm 
# End of macro NEXTW
22bf			 
22bf			.DROP: 
22bf				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
22bf 1b				db WORD_SYS_CORE+OPCODE_DROP             
22c0 ea 22			dw .DUP2            
22c2 05				db 4 + 1 
22c3 .. 00			db "DROP",0              
22c8				endm 
# End of macro CWHEAD
22c8			; | DROP ( w -- )   drop the TOS item   | DONE 
22c8					if DEBUG_FORTH_WORDS_KEY 
22c8						DMARK "DRP" 
22c8 f5				push af  
22c9 3a dd 22			ld a, (.dmark)  
22cc 32 7a ee			ld (debug_mark),a  
22cf 3a de 22			ld a, (.dmark+1)  
22d2 32 7b ee			ld (debug_mark+1),a  
22d5 3a df 22			ld a, (.dmark+2)  
22d8 32 7c ee			ld (debug_mark+2),a  
22db 18 03			jr .pastdmark  
22dd ..			.dmark: db "DRP"  
22e0 f1			.pastdmark: pop af  
22e1			endm  
# End of macro DMARK
22e1						CALLMONITOR 
22e1 cd ff 13			call break_point_state  
22e4				endm  
# End of macro CALLMONITOR
22e4					endif 
22e4					FORTH_DSP_POP 
22e4 cd 3b 1c			call macro_forth_dsp_pop 
22e7				endm 
# End of macro FORTH_DSP_POP
22e7					NEXTW 
22e7 c3 f5 1c			jp macro_next 
22ea				endm 
# End of macro NEXTW
22ea			.DUP2: 
22ea				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
22ea 1c				db WORD_SYS_CORE+OPCODE_DUP2             
22eb 2f 23			dw .DROP2            
22ed 05				db 4 + 1 
22ee .. 00			db "2DUP",0              
22f3				endm 
# End of macro CWHEAD
22f3			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
22f3					if DEBUG_FORTH_WORDS_KEY 
22f3						DMARK "2DU" 
22f3 f5				push af  
22f4 3a 08 23			ld a, (.dmark)  
22f7 32 7a ee			ld (debug_mark),a  
22fa 3a 09 23			ld a, (.dmark+1)  
22fd 32 7b ee			ld (debug_mark+1),a  
2300 3a 0a 23			ld a, (.dmark+2)  
2303 32 7c ee			ld (debug_mark+2),a  
2306 18 03			jr .pastdmark  
2308 ..			.dmark: db "2DU"  
230b f1			.pastdmark: pop af  
230c			endm  
# End of macro DMARK
230c						CALLMONITOR 
230c cd ff 13			call break_point_state  
230f				endm  
# End of macro CALLMONITOR
230f					endif 
230f					FORTH_DSP_VALUEHL 
230f cd 83 1b			call macro_dsp_valuehl 
2312				endm 
# End of macro FORTH_DSP_VALUEHL
2312 e5					push hl      ; 2 
2313			 
2313					FORTH_DSP_POP 
2313 cd 3b 1c			call macro_forth_dsp_pop 
2316				endm 
# End of macro FORTH_DSP_POP
2316					 
2316					FORTH_DSP_VALUEHL 
2316 cd 83 1b			call macro_dsp_valuehl 
2319				endm 
# End of macro FORTH_DSP_VALUEHL
2319			;		push hl      ; 1 
2319			 
2319					FORTH_DSP_POP 
2319 cd 3b 1c			call macro_forth_dsp_pop 
231c				endm 
# End of macro FORTH_DSP_POP
231c			 
231c			;		pop hl       ; 1 
231c d1					pop de       ; 2 
231d			 
231d cd 8c 19				call forth_push_numhl 
2320 eb					ex de, hl 
2321 cd 8c 19				call forth_push_numhl 
2324			 
2324					 
2324 eb					ex de, hl 
2325			 
2325 cd 8c 19				call forth_push_numhl 
2328 eb					ex de, hl 
2329 cd 8c 19				call forth_push_numhl 
232c			 
232c			 
232c					NEXTW 
232c c3 f5 1c			jp macro_next 
232f				endm 
# End of macro NEXTW
232f			.DROP2: 
232f				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
232f 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2330 5e 23			dw .SWAP2            
2332 06				db 5 + 1 
2333 .. 00			db "2DROP",0              
2339				endm 
# End of macro CWHEAD
2339			; | 2DROP ( w w -- )    Double drop | DONE 
2339					if DEBUG_FORTH_WORDS_KEY 
2339						DMARK "2DR" 
2339 f5				push af  
233a 3a 4e 23			ld a, (.dmark)  
233d 32 7a ee			ld (debug_mark),a  
2340 3a 4f 23			ld a, (.dmark+1)  
2343 32 7b ee			ld (debug_mark+1),a  
2346 3a 50 23			ld a, (.dmark+2)  
2349 32 7c ee			ld (debug_mark+2),a  
234c 18 03			jr .pastdmark  
234e ..			.dmark: db "2DR"  
2351 f1			.pastdmark: pop af  
2352			endm  
# End of macro DMARK
2352						CALLMONITOR 
2352 cd ff 13			call break_point_state  
2355				endm  
# End of macro CALLMONITOR
2355					endif 
2355					FORTH_DSP_POP 
2355 cd 3b 1c			call macro_forth_dsp_pop 
2358				endm 
# End of macro FORTH_DSP_POP
2358					FORTH_DSP_POP 
2358 cd 3b 1c			call macro_forth_dsp_pop 
235b				endm 
# End of macro FORTH_DSP_POP
235b					NEXTW 
235b c3 f5 1c			jp macro_next 
235e				endm 
# End of macro NEXTW
235e			.SWAP2: 
235e				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
235e 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
235f 87 23			dw .AT            
2361 06				db 5 + 1 
2362 .. 00			db "2SWAP",0              
2368				endm 
# End of macro CWHEAD
2368			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2368					if DEBUG_FORTH_WORDS_KEY 
2368						DMARK "2SW" 
2368 f5				push af  
2369 3a 7d 23			ld a, (.dmark)  
236c 32 7a ee			ld (debug_mark),a  
236f 3a 7e 23			ld a, (.dmark+1)  
2372 32 7b ee			ld (debug_mark+1),a  
2375 3a 7f 23			ld a, (.dmark+2)  
2378 32 7c ee			ld (debug_mark+2),a  
237b 18 03			jr .pastdmark  
237d ..			.dmark: db "2SW"  
2380 f1			.pastdmark: pop af  
2381			endm  
# End of macro DMARK
2381						CALLMONITOR 
2381 cd ff 13			call break_point_state  
2384				endm  
# End of macro CALLMONITOR
2384					endif 
2384					NEXTW 
2384 c3 f5 1c			jp macro_next 
2387				endm 
# End of macro NEXTW
2387			.AT: 
2387				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2387 1f				db WORD_SYS_CORE+OPCODE_AT             
2388 b9 23			dw .CAT            
238a 02				db 1 + 1 
238b .. 00			db "@",0              
238d				endm 
# End of macro CWHEAD
238d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
238d			 
238d					if DEBUG_FORTH_WORDS_KEY 
238d						DMARK "AT." 
238d f5				push af  
238e 3a a2 23			ld a, (.dmark)  
2391 32 7a ee			ld (debug_mark),a  
2394 3a a3 23			ld a, (.dmark+1)  
2397 32 7b ee			ld (debug_mark+1),a  
239a 3a a4 23			ld a, (.dmark+2)  
239d 32 7c ee			ld (debug_mark+2),a  
23a0 18 03			jr .pastdmark  
23a2 ..			.dmark: db "AT."  
23a5 f1			.pastdmark: pop af  
23a6			endm  
# End of macro DMARK
23a6						CALLMONITOR 
23a6 cd ff 13			call break_point_state  
23a9				endm  
# End of macro CALLMONITOR
23a9					endif 
23a9			.getbyteat:	 
23a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23a9 cd 83 1b			call macro_dsp_valuehl 
23ac				endm 
# End of macro FORTH_DSP_VALUEHL
23ac					 
23ac			;		push hl 
23ac				 
23ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ac cd 3b 1c			call macro_forth_dsp_pop 
23af				endm 
# End of macro FORTH_DSP_POP
23af			 
23af			;		pop hl 
23af			 
23af 7e					ld a, (hl) 
23b0			 
23b0 6f					ld l, a 
23b1 26 00				ld h, 0 
23b3 cd 8c 19				call forth_push_numhl 
23b6			 
23b6					NEXTW 
23b6 c3 f5 1c			jp macro_next 
23b9				endm 
# End of macro NEXTW
23b9			.CAT: 
23b9				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
23b9 20				db WORD_SYS_CORE+OPCODE_CAT             
23ba e2 23			dw .BANG            
23bc 03				db 2 + 1 
23bd .. 00			db "C@",0              
23c0				endm 
# End of macro CWHEAD
23c0			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
23c0					if DEBUG_FORTH_WORDS_KEY 
23c0						DMARK "CAA" 
23c0 f5				push af  
23c1 3a d5 23			ld a, (.dmark)  
23c4 32 7a ee			ld (debug_mark),a  
23c7 3a d6 23			ld a, (.dmark+1)  
23ca 32 7b ee			ld (debug_mark+1),a  
23cd 3a d7 23			ld a, (.dmark+2)  
23d0 32 7c ee			ld (debug_mark+2),a  
23d3 18 03			jr .pastdmark  
23d5 ..			.dmark: db "CAA"  
23d8 f1			.pastdmark: pop af  
23d9			endm  
# End of macro DMARK
23d9						CALLMONITOR 
23d9 cd ff 13			call break_point_state  
23dc				endm  
# End of macro CALLMONITOR
23dc					endif 
23dc c3 a9 23				jp .getbyteat 
23df					NEXTW 
23df c3 f5 1c			jp macro_next 
23e2				endm 
# End of macro NEXTW
23e2			.BANG: 
23e2				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
23e2 21				db WORD_SYS_CORE+OPCODE_BANG             
23e3 18 24			dw .CBANG            
23e5 02				db 1 + 1 
23e6 .. 00			db "!",0              
23e8				endm 
# End of macro CWHEAD
23e8			; | ! ( x w -- ) Store x at address w      | DONE 
23e8					if DEBUG_FORTH_WORDS_KEY 
23e8						DMARK "BNG" 
23e8 f5				push af  
23e9 3a fd 23			ld a, (.dmark)  
23ec 32 7a ee			ld (debug_mark),a  
23ef 3a fe 23			ld a, (.dmark+1)  
23f2 32 7b ee			ld (debug_mark+1),a  
23f5 3a ff 23			ld a, (.dmark+2)  
23f8 32 7c ee			ld (debug_mark+2),a  
23fb 18 03			jr .pastdmark  
23fd ..			.dmark: db "BNG"  
2400 f1			.pastdmark: pop af  
2401			endm  
# End of macro DMARK
2401						CALLMONITOR 
2401 cd ff 13			call break_point_state  
2404				endm  
# End of macro CALLMONITOR
2404					endif 
2404			 
2404			.storebyteat:		 
2404					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2404 cd 83 1b			call macro_dsp_valuehl 
2407				endm 
# End of macro FORTH_DSP_VALUEHL
2407					 
2407 e5					push hl 
2408				 
2408					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2408 cd 3b 1c			call macro_forth_dsp_pop 
240b				endm 
# End of macro FORTH_DSP_POP
240b			 
240b					; get byte to poke 
240b			 
240b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
240b cd 83 1b			call macro_dsp_valuehl 
240e				endm 
# End of macro FORTH_DSP_VALUEHL
240e e5					push hl 
240f			 
240f			 
240f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
240f cd 3b 1c			call macro_forth_dsp_pop 
2412				endm 
# End of macro FORTH_DSP_POP
2412			 
2412			 
2412 d1					pop de 
2413 e1					pop hl 
2414			 
2414 73					ld (hl),e 
2415			 
2415			 
2415					NEXTW 
2415 c3 f5 1c			jp macro_next 
2418				endm 
# End of macro NEXTW
2418			.CBANG: 
2418				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2418 22				db WORD_SYS_CORE+OPCODE_CBANG             
2419 41 24			dw .SCALL            
241b 03				db 2 + 1 
241c .. 00			db "C!",0              
241f				endm 
# End of macro CWHEAD
241f			; | C!  ( x w -- ) Store x at address w  | DONE 
241f					if DEBUG_FORTH_WORDS_KEY 
241f						DMARK "CBA" 
241f f5				push af  
2420 3a 34 24			ld a, (.dmark)  
2423 32 7a ee			ld (debug_mark),a  
2426 3a 35 24			ld a, (.dmark+1)  
2429 32 7b ee			ld (debug_mark+1),a  
242c 3a 36 24			ld a, (.dmark+2)  
242f 32 7c ee			ld (debug_mark+2),a  
2432 18 03			jr .pastdmark  
2434 ..			.dmark: db "CBA"  
2437 f1			.pastdmark: pop af  
2438			endm  
# End of macro DMARK
2438						CALLMONITOR 
2438 cd ff 13			call break_point_state  
243b				endm  
# End of macro CALLMONITOR
243b					endif 
243b c3 04 24				jp .storebyteat 
243e					NEXTW 
243e c3 f5 1c			jp macro_next 
2441				endm 
# End of macro NEXTW
2441			.SCALL: 
2441				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2441 23				db WORD_SYS_CORE+OPCODE_SCALL             
2442 75 24			dw .DEPTH            
2444 05				db 4 + 1 
2445 .. 00			db "CALL",0              
244a				endm 
# End of macro CWHEAD
244a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
244a					if DEBUG_FORTH_WORDS_KEY 
244a						DMARK "CLL" 
244a f5				push af  
244b 3a 5f 24			ld a, (.dmark)  
244e 32 7a ee			ld (debug_mark),a  
2451 3a 60 24			ld a, (.dmark+1)  
2454 32 7b ee			ld (debug_mark+1),a  
2457 3a 61 24			ld a, (.dmark+2)  
245a 32 7c ee			ld (debug_mark+2),a  
245d 18 03			jr .pastdmark  
245f ..			.dmark: db "CLL"  
2462 f1			.pastdmark: pop af  
2463			endm  
# End of macro DMARK
2463						CALLMONITOR 
2463 cd ff 13			call break_point_state  
2466				endm  
# End of macro CALLMONITOR
2466					endif 
2466			 
2466					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2466 cd 83 1b			call macro_dsp_valuehl 
2469				endm 
# End of macro FORTH_DSP_VALUEHL
2469			 
2469			;		push hl 
2469			 
2469					; destroy value TOS 
2469			 
2469					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2469 cd 3b 1c			call macro_forth_dsp_pop 
246c				endm 
# End of macro FORTH_DSP_POP
246c			 
246c						 
246c			;		pop hl 
246c			 
246c					; how to do a call with hl???? save SP? 
246c cd 9e 1c				call forth_call_hl 
246f			 
246f			 
246f					; TODO push value back onto stack for another op etc 
246f			 
246f cd 8c 19				call forth_push_numhl 
2472					NEXTW 
2472 c3 f5 1c			jp macro_next 
2475				endm 
# End of macro NEXTW
2475			.DEPTH: 
2475				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2475 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2476 b2 24			dw .OVER            
2478 06				db 5 + 1 
2479 .. 00			db "DEPTH",0              
247f				endm 
# End of macro CWHEAD
247f			; | DEPTH ( -- u ) Push count of stack | DONE 
247f					; take current TOS and remove from base value div by two to get count 
247f					if DEBUG_FORTH_WORDS_KEY 
247f						DMARK "DEP" 
247f f5				push af  
2480 3a 94 24			ld a, (.dmark)  
2483 32 7a ee			ld (debug_mark),a  
2486 3a 95 24			ld a, (.dmark+1)  
2489 32 7b ee			ld (debug_mark+1),a  
248c 3a 96 24			ld a, (.dmark+2)  
248f 32 7c ee			ld (debug_mark+2),a  
2492 18 03			jr .pastdmark  
2494 ..			.dmark: db "DEP"  
2497 f1			.pastdmark: pop af  
2498			endm  
# End of macro DMARK
2498						CALLMONITOR 
2498 cd ff 13			call break_point_state  
249b				endm  
# End of macro CALLMONITOR
249b					endif 
249b			 
249b			 
249b 2a 0d eb			ld hl, (cli_data_sp) 
249e 11 c7 e8			ld de, cli_data_stack 
24a1 ed 52			sbc hl,de 
24a3				 
24a3				; div by size of stack item 
24a3			 
24a3 5d				ld e,l 
24a4 0e 03			ld c, 3 
24a6 cd 42 0b			call Div8 
24a9			 
24a9 6f				ld l,a 
24aa 26 00			ld h,0 
24ac			 
24ac				;srl h 
24ac				;rr l 
24ac			 
24ac cd 8c 19				call forth_push_numhl 
24af					NEXTW 
24af c3 f5 1c			jp macro_next 
24b2				endm 
# End of macro NEXTW
24b2			.OVER: 
24b2				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
24b2 42				db WORD_SYS_CORE+46             
24b3 f9 24			dw .PAUSE            
24b5 05				db 4 + 1 
24b6 .. 00			db "OVER",0              
24bb				endm 
# End of macro CWHEAD
24bb			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
24bb					if DEBUG_FORTH_WORDS_KEY 
24bb						DMARK "OVR" 
24bb f5				push af  
24bc 3a d0 24			ld a, (.dmark)  
24bf 32 7a ee			ld (debug_mark),a  
24c2 3a d1 24			ld a, (.dmark+1)  
24c5 32 7b ee			ld (debug_mark+1),a  
24c8 3a d2 24			ld a, (.dmark+2)  
24cb 32 7c ee			ld (debug_mark+2),a  
24ce 18 03			jr .pastdmark  
24d0 ..			.dmark: db "OVR"  
24d3 f1			.pastdmark: pop af  
24d4			endm  
# End of macro DMARK
24d4						CALLMONITOR 
24d4 cd ff 13			call break_point_state  
24d7				endm  
# End of macro CALLMONITOR
24d7					endif 
24d7			 
24d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24d7 cd 83 1b			call macro_dsp_valuehl 
24da				endm 
# End of macro FORTH_DSP_VALUEHL
24da e5					push hl    ; n2 
24db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24db cd 3b 1c			call macro_forth_dsp_pop 
24de				endm 
# End of macro FORTH_DSP_POP
24de			 
24de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24de cd 83 1b			call macro_dsp_valuehl 
24e1				endm 
# End of macro FORTH_DSP_VALUEHL
24e1 e5					push hl    ; n1 
24e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24e2 cd 3b 1c			call macro_forth_dsp_pop 
24e5				endm 
# End of macro FORTH_DSP_POP
24e5			 
24e5 d1					pop de     ; n1 
24e6 e1					pop hl     ; n2 
24e7			 
24e7 d5					push de 
24e8 e5					push hl 
24e9 d5					push de 
24ea			 
24ea					; push back  
24ea			 
24ea e1					pop hl 
24eb cd 8c 19				call forth_push_numhl 
24ee e1					pop hl 
24ef cd 8c 19				call forth_push_numhl 
24f2 e1					pop hl 
24f3 cd 8c 19				call forth_push_numhl 
24f6					NEXTW 
24f6 c3 f5 1c			jp macro_next 
24f9				endm 
# End of macro NEXTW
24f9			 
24f9			.PAUSE: 
24f9				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
24f9 43				db WORD_SYS_CORE+47             
24fa 2e 25			dw .PAUSES            
24fc 08				db 7 + 1 
24fd .. 00			db "PAUSEMS",0              
2505				endm 
# End of macro CWHEAD
2505			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2505					if DEBUG_FORTH_WORDS_KEY 
2505						DMARK "PMS" 
2505 f5				push af  
2506 3a 1a 25			ld a, (.dmark)  
2509 32 7a ee			ld (debug_mark),a  
250c 3a 1b 25			ld a, (.dmark+1)  
250f 32 7b ee			ld (debug_mark+1),a  
2512 3a 1c 25			ld a, (.dmark+2)  
2515 32 7c ee			ld (debug_mark+2),a  
2518 18 03			jr .pastdmark  
251a ..			.dmark: db "PMS"  
251d f1			.pastdmark: pop af  
251e			endm  
# End of macro DMARK
251e						CALLMONITOR 
251e cd ff 13			call break_point_state  
2521				endm  
# End of macro CALLMONITOR
2521					endif 
2521					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2521 cd 83 1b			call macro_dsp_valuehl 
2524				endm 
# End of macro FORTH_DSP_VALUEHL
2524			;		push hl    ; n2 
2524					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2524 cd 3b 1c			call macro_forth_dsp_pop 
2527				endm 
# End of macro FORTH_DSP_POP
2527			;		pop hl 
2527			 
2527 7d					ld a, l 
2528 cd df 08				call aDelayInMS 
252b				       NEXTW 
252b c3 f5 1c			jp macro_next 
252e				endm 
# End of macro NEXTW
252e			.PAUSES:  
252e				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
252e 44				db WORD_SYS_CORE+48             
252f 9d 25			dw .ROT            
2531 06				db 5 + 1 
2532 .. 00			db "PAUSE",0              
2538				endm 
# End of macro CWHEAD
2538			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2538					if DEBUG_FORTH_WORDS_KEY 
2538						DMARK "PAU" 
2538 f5				push af  
2539 3a 4d 25			ld a, (.dmark)  
253c 32 7a ee			ld (debug_mark),a  
253f 3a 4e 25			ld a, (.dmark+1)  
2542 32 7b ee			ld (debug_mark+1),a  
2545 3a 4f 25			ld a, (.dmark+2)  
2548 32 7c ee			ld (debug_mark+2),a  
254b 18 03			jr .pastdmark  
254d ..			.dmark: db "PAU"  
2550 f1			.pastdmark: pop af  
2551			endm  
# End of macro DMARK
2551						CALLMONITOR 
2551 cd ff 13			call break_point_state  
2554				endm  
# End of macro CALLMONITOR
2554					endif 
2554					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2554 cd 83 1b			call macro_dsp_valuehl 
2557				endm 
# End of macro FORTH_DSP_VALUEHL
2557			;		push hl    ; n2 
2557					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2557 cd 3b 1c			call macro_forth_dsp_pop 
255a				endm 
# End of macro FORTH_DSP_POP
255a			;		pop hl 
255a 45					ld b, l 
255b					if DEBUG_FORTH_WORDS 
255b						DMARK "PAU" 
255b f5				push af  
255c 3a 70 25			ld a, (.dmark)  
255f 32 7a ee			ld (debug_mark),a  
2562 3a 71 25			ld a, (.dmark+1)  
2565 32 7b ee			ld (debug_mark+1),a  
2568 3a 72 25			ld a, (.dmark+2)  
256b 32 7c ee			ld (debug_mark+2),a  
256e 18 03			jr .pastdmark  
2570 ..			.dmark: db "PAU"  
2573 f1			.pastdmark: pop af  
2574			endm  
# End of macro DMARK
2574						CALLMONITOR 
2574 cd ff 13			call break_point_state  
2577				endm  
# End of macro CALLMONITOR
2577					endif 
2577 c5			.pauses1:	push bc 
2578 cd fa 08				call delay1s 
257b c1					pop bc 
257c					if DEBUG_FORTH_WORDS 
257c						DMARK "PA1" 
257c f5				push af  
257d 3a 91 25			ld a, (.dmark)  
2580 32 7a ee			ld (debug_mark),a  
2583 3a 92 25			ld a, (.dmark+1)  
2586 32 7b ee			ld (debug_mark+1),a  
2589 3a 93 25			ld a, (.dmark+2)  
258c 32 7c ee			ld (debug_mark+2),a  
258f 18 03			jr .pastdmark  
2591 ..			.dmark: db "PA1"  
2594 f1			.pastdmark: pop af  
2595			endm  
# End of macro DMARK
2595						CALLMONITOR 
2595 cd ff 13			call break_point_state  
2598				endm  
# End of macro CALLMONITOR
2598					endif 
2598 10 dd				djnz .pauses1 
259a			 
259a				       NEXTW 
259a c3 f5 1c			jp macro_next 
259d				endm 
# End of macro NEXTW
259d			.ROT: 
259d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
259d 45				db WORD_SYS_CORE+49             
259e eb 25			dw .UWORDS            
25a0 04				db 3 + 1 
25a1 .. 00			db "ROT",0              
25a5				endm 
# End of macro CWHEAD
25a5			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
25a5					if DEBUG_FORTH_WORDS_KEY 
25a5						DMARK "ROT" 
25a5 f5				push af  
25a6 3a ba 25			ld a, (.dmark)  
25a9 32 7a ee			ld (debug_mark),a  
25ac 3a bb 25			ld a, (.dmark+1)  
25af 32 7b ee			ld (debug_mark+1),a  
25b2 3a bc 25			ld a, (.dmark+2)  
25b5 32 7c ee			ld (debug_mark+2),a  
25b8 18 03			jr .pastdmark  
25ba ..			.dmark: db "ROT"  
25bd f1			.pastdmark: pop af  
25be			endm  
# End of macro DMARK
25be						CALLMONITOR 
25be cd ff 13			call break_point_state  
25c1				endm  
# End of macro CALLMONITOR
25c1					endif 
25c1			 
25c1					FORTH_DSP_VALUEHL 
25c1 cd 83 1b			call macro_dsp_valuehl 
25c4				endm 
# End of macro FORTH_DSP_VALUEHL
25c4 e5					push hl    ; u3  
25c5			 
25c5					FORTH_DSP_POP 
25c5 cd 3b 1c			call macro_forth_dsp_pop 
25c8				endm 
# End of macro FORTH_DSP_POP
25c8			   
25c8					FORTH_DSP_VALUEHL 
25c8 cd 83 1b			call macro_dsp_valuehl 
25cb				endm 
# End of macro FORTH_DSP_VALUEHL
25cb e5					push hl     ; u2 
25cc			 
25cc					FORTH_DSP_POP 
25cc cd 3b 1c			call macro_forth_dsp_pop 
25cf				endm 
# End of macro FORTH_DSP_POP
25cf			 
25cf					FORTH_DSP_VALUEHL 
25cf cd 83 1b			call macro_dsp_valuehl 
25d2				endm 
# End of macro FORTH_DSP_VALUEHL
25d2 e5					push hl     ; u1 
25d3			 
25d3					FORTH_DSP_POP 
25d3 cd 3b 1c			call macro_forth_dsp_pop 
25d6				endm 
# End of macro FORTH_DSP_POP
25d6			 
25d6 c1					pop bc      ; u1 
25d7 e1					pop hl      ; u2 
25d8 d1					pop de      ; u3 
25d9			 
25d9			 
25d9 c5					push bc 
25da d5					push de 
25db e5					push hl 
25dc			 
25dc			 
25dc e1					pop hl 
25dd cd 8c 19				call forth_push_numhl 
25e0			 
25e0 e1					pop hl 
25e1 cd 8c 19				call forth_push_numhl 
25e4			 
25e4 e1					pop hl 
25e5 cd 8c 19				call forth_push_numhl 
25e8					 
25e8			 
25e8			 
25e8			 
25e8			 
25e8			 
25e8				       NEXTW 
25e8 c3 f5 1c			jp macro_next 
25eb				endm 
# End of macro NEXTW
25eb			 
25eb			.UWORDS: 
25eb				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
25eb 50				db WORD_SYS_CORE+60             
25ec ad 26			dw .BP            
25ee 07				db 6 + 1 
25ef .. 00			db "UWORDS",0              
25f6				endm 
# End of macro CWHEAD
25f6			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
25f6			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
25f6			; | | Following the count are the individual words. 
25f6			; | | 
25f6			; | | e.g. UWORDS 
25f6			; | | BOX DIRLIST 2 
25f6			; | |  
25f6			; | | Can be used to save the words to storage via: 
25f6			; | | UWORDS $01 DO $01 APPEND LOOP 
25f6				if DEBUG_FORTH_WORDS_KEY 
25f6					DMARK "UWR" 
25f6 f5				push af  
25f7 3a 0b 26			ld a, (.dmark)  
25fa 32 7a ee			ld (debug_mark),a  
25fd 3a 0c 26			ld a, (.dmark+1)  
2600 32 7b ee			ld (debug_mark+1),a  
2603 3a 0d 26			ld a, (.dmark+2)  
2606 32 7c ee			ld (debug_mark+2),a  
2609 18 03			jr .pastdmark  
260b ..			.dmark: db "UWR"  
260e f1			.pastdmark: pop af  
260f			endm  
# End of macro DMARK
260f					CALLMONITOR 
260f cd ff 13			call break_point_state  
2612				endm  
# End of macro CALLMONITOR
2612				endif 
2612 21 d7 59				ld hl, baseram 
2615					;ld hl, baseusermem 
2615 01 00 00				ld bc, 0    ; start a counter 
2618			 
2618				; skip dict stub 
2618			 
2618 cd 46 1e				call forth_tok_next 
261b			 
261b			 
261b			; while we have words to look for 
261b			 
261b 7e			.douscan:	ld a, (hl)      
261c				if DEBUG_FORTH_WORDS 
261c					DMARK "UWs" 
261c f5				push af  
261d 3a 31 26			ld a, (.dmark)  
2620 32 7a ee			ld (debug_mark),a  
2623 3a 32 26			ld a, (.dmark+1)  
2626 32 7b ee			ld (debug_mark+1),a  
2629 3a 33 26			ld a, (.dmark+2)  
262c 32 7c ee			ld (debug_mark+2),a  
262f 18 03			jr .pastdmark  
2631 ..			.dmark: db "UWs"  
2634 f1			.pastdmark: pop af  
2635			endm  
# End of macro DMARK
2635					CALLMONITOR 
2635 cd ff 13			call break_point_state  
2638				endm  
# End of macro CALLMONITOR
2638				endif 
2638 fe 00				cp WORD_SYS_END 
263a 28 4d				jr z, .udone 
263c fe 01				cp WORD_SYS_UWORD 
263e 20 44				jr nz, .nuword 
2640			 
2640				if DEBUG_FORTH_WORDS 
2640					DMARK "UWu" 
2640 f5				push af  
2641 3a 55 26			ld a, (.dmark)  
2644 32 7a ee			ld (debug_mark),a  
2647 3a 56 26			ld a, (.dmark+1)  
264a 32 7b ee			ld (debug_mark+1),a  
264d 3a 57 26			ld a, (.dmark+2)  
2650 32 7c ee			ld (debug_mark+2),a  
2653 18 03			jr .pastdmark  
2655 ..			.dmark: db "UWu"  
2658 f1			.pastdmark: pop af  
2659			endm  
# End of macro DMARK
2659					CALLMONITOR 
2659 cd ff 13			call break_point_state  
265c				endm  
# End of macro CALLMONITOR
265c				endif 
265c					; we have a uword so push its name to the stack 
265c			 
265c e5				   	push hl  ; save so we can move to next dict block 
265d			 
265d					; skip opcode 
265d 23					inc hl  
265e					; skip next ptr 
265e 23					inc hl  
265f 23					inc hl 
2660					; skip len 
2660 23					inc hl 
2661				if DEBUG_FORTH_WORDS 
2661					DMARK "UWt" 
2661 f5				push af  
2662 3a 76 26			ld a, (.dmark)  
2665 32 7a ee			ld (debug_mark),a  
2668 3a 77 26			ld a, (.dmark+1)  
266b 32 7b ee			ld (debug_mark+1),a  
266e 3a 78 26			ld a, (.dmark+2)  
2671 32 7c ee			ld (debug_mark+2),a  
2674 18 03			jr .pastdmark  
2676 ..			.dmark: db "UWt"  
2679 f1			.pastdmark: pop af  
267a			endm  
# End of macro DMARK
267a					CALLMONITOR 
267a cd ff 13			call break_point_state  
267d				endm  
# End of macro CALLMONITOR
267d				endif 
267d 03					inc bc 
267e			 
267e c5					push bc 
267f cd fa 19				call forth_push_str 
2682 c1					pop bc 
2683			 
2683 e1					pop hl 	 
2684			 
2684 cd 46 1e		.nuword:	call forth_tok_next 
2687 18 92				jr .douscan  
2689			 
2689			.udone:		 ; push count of uwords found 
2689 c5					push bc 
268a e1					pop hl 
268b			 
268b				if DEBUG_FORTH_WORDS 
268b					DMARK "UWc" 
268b f5				push af  
268c 3a a0 26			ld a, (.dmark)  
268f 32 7a ee			ld (debug_mark),a  
2692 3a a1 26			ld a, (.dmark+1)  
2695 32 7b ee			ld (debug_mark+1),a  
2698 3a a2 26			ld a, (.dmark+2)  
269b 32 7c ee			ld (debug_mark+2),a  
269e 18 03			jr .pastdmark  
26a0 ..			.dmark: db "UWc"  
26a3 f1			.pastdmark: pop af  
26a4			endm  
# End of macro DMARK
26a4					CALLMONITOR 
26a4 cd ff 13			call break_point_state  
26a7				endm  
# End of macro CALLMONITOR
26a7				endif 
26a7 cd 8c 19				call forth_push_numhl 
26aa			 
26aa			 
26aa				       NEXTW 
26aa c3 f5 1c			jp macro_next 
26ad				endm 
# End of macro NEXTW
26ad			 
26ad			.BP: 
26ad				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
26ad 54				db WORD_SYS_CORE+64             
26ae e3 26			dw .MONITOR            
26b0 03				db 2 + 1 
26b1 .. 00			db "BP",0              
26b4				endm 
# End of macro CWHEAD
26b4			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
26b4			; | | $00 Will enable the break points within specific code paths 
26b4			; | | $01 Will disable break points 
26b4			; | |  
26b4			; | | By default break points are off. Either the above can be used to enable them 
26b4			; | | or if a key is held down during start up the spashscreen will appear to freeze 
26b4			; | | and on release of the pressed key a message will be disaplayed to notify 
26b4			; | | that break points are enabled. Pressing any key will then continue boot process. 
26b4					; get byte count 
26b4					if DEBUG_FORTH_WORDS_KEY 
26b4						DMARK "BP." 
26b4 f5				push af  
26b5 3a c9 26			ld a, (.dmark)  
26b8 32 7a ee			ld (debug_mark),a  
26bb 3a ca 26			ld a, (.dmark+1)  
26be 32 7b ee			ld (debug_mark+1),a  
26c1 3a cb 26			ld a, (.dmark+2)  
26c4 32 7c ee			ld (debug_mark+2),a  
26c7 18 03			jr .pastdmark  
26c9 ..			.dmark: db "BP."  
26cc f1			.pastdmark: pop af  
26cd			endm  
# End of macro DMARK
26cd						CALLMONITOR 
26cd cd ff 13			call break_point_state  
26d0				endm  
# End of macro CALLMONITOR
26d0					endif 
26d0			 
26d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26d0 cd 83 1b			call macro_dsp_valuehl 
26d3				endm 
# End of macro FORTH_DSP_VALUEHL
26d3			 
26d3			;		push hl 
26d3			 
26d3					; destroy value TOS 
26d3			 
26d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26d3 cd 3b 1c			call macro_forth_dsp_pop 
26d6				endm 
# End of macro FORTH_DSP_POP
26d6			 
26d6			;		pop hl 
26d6			 
26d6 3e 00				ld a,0 
26d8 bd					cp l 
26d9 28 02				jr z, .bpset 
26db 3e 2a				ld a, '*' 
26dd			 
26dd 32 51 e3		.bpset:		ld (os_view_disable), a 
26e0			 
26e0			 
26e0					NEXTW 
26e0 c3 f5 1c			jp macro_next 
26e3				endm 
# End of macro NEXTW
26e3			 
26e3			 
26e3			.MONITOR: 
26e3				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
26e3 55				db WORD_SYS_CORE+65             
26e4 16 27			dw .MALLOC            
26e6 08				db 7 + 1 
26e7 .. 00			db "MONITOR",0              
26ef				endm 
# End of macro CWHEAD
26ef			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
26ef			; | | At start the current various registers will be displayed with contents. 
26ef			; | | Top right corner will show the most recent debug marker seen. 
26ef			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
26ef			; | | and the return stack pointer (RSP). 
26ef			; | | Pressing: 
26ef			; | |    1 - Initial screen 
26ef			; | |    2 - Display a data dump of HL 
26ef			; | |    3 - Display a data dump of DE 
26ef			; | |    4 - Display a data dump of BC 
26ef			; | |    5 - Display a data dump of HL 
26ef			; | |    6 - Display a data dump of DSP 
26ef			; | |    7 - Display a data dump of RSP 
26ef			; | |    8 - Display a data dump of what is at DSP 
26ef			; | |    9 - Display a data dump of what is at RSP 
26ef			; | |    0 - Exit monitor and continue running. This will also enable break points 
26ef			; | |    * - Disable break points 
26ef			; | |    # - Enter traditional monitor mode 
26ef			; | | 
26ef			; | | Monitor Mode 
26ef			; | | ------------ 
26ef			; | | A prompt of '>' will be shown for various commands: 
26ef			; | |    D xxxx - Display a data dump starting from hex address xxxx 
26ef			; | |    C - Continue display a data dump from the last set address 
26ef			; | |    M xxxx - Set start of memory edit at address xx 
26ef			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
26ef			; | |    Q - Return to previous 
26ef					if DEBUG_FORTH_WORDS_KEY 
26ef						DMARK "MON" 
26ef f5				push af  
26f0 3a 04 27			ld a, (.dmark)  
26f3 32 7a ee			ld (debug_mark),a  
26f6 3a 05 27			ld a, (.dmark+1)  
26f9 32 7b ee			ld (debug_mark+1),a  
26fc 3a 06 27			ld a, (.dmark+2)  
26ff 32 7c ee			ld (debug_mark+2),a  
2702 18 03			jr .pastdmark  
2704 ..			.dmark: db "MON"  
2707 f1			.pastdmark: pop af  
2708			endm  
# End of macro DMARK
2708						CALLMONITOR 
2708 cd ff 13			call break_point_state  
270b				endm  
# End of macro CALLMONITOR
270b					endif 
270b 3e 00				ld a, 0 
270d 32 51 e3				ld (os_view_disable), a 
2710			 
2710					CALLMONITOR 
2710 cd ff 13			call break_point_state  
2713				endm  
# End of macro CALLMONITOR
2713			 
2713			;	call monitor 
2713			 
2713					NEXTW 
2713 c3 f5 1c			jp macro_next 
2716				endm 
# End of macro NEXTW
2716			 
2716			 
2716			.MALLOC: 
2716				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2716 56				db WORD_SYS_CORE+66             
2717 3f 27			dw .MALLOC2            
2719 06				db 5 + 1 
271a .. 00			db "ALLOT",0              
2720				endm 
# End of macro CWHEAD
2720			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2720					if DEBUG_FORTH_WORDS_KEY 
2720						DMARK "ALL" 
2720 f5				push af  
2721 3a 35 27			ld a, (.dmark)  
2724 32 7a ee			ld (debug_mark),a  
2727 3a 36 27			ld a, (.dmark+1)  
272a 32 7b ee			ld (debug_mark+1),a  
272d 3a 37 27			ld a, (.dmark+2)  
2730 32 7c ee			ld (debug_mark+2),a  
2733 18 03			jr .pastdmark  
2735 ..			.dmark: db "ALL"  
2738 f1			.pastdmark: pop af  
2739			endm  
# End of macro DMARK
2739						CALLMONITOR 
2739 cd ff 13			call break_point_state  
273c				endm  
# End of macro CALLMONITOR
273c					endif 
273c c3 66 27				jp .mallocc 
273f			.MALLOC2: 
273f				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
273f 56				db WORD_SYS_CORE+66             
2740 7d 27			dw .FREE            
2742 07				db 6 + 1 
2743 .. 00			db "MALLOC",0              
274a				endm 
# End of macro CWHEAD
274a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
274a					; get byte count 
274a					if DEBUG_FORTH_WORDS_KEY 
274a						DMARK "MAL" 
274a f5				push af  
274b 3a 5f 27			ld a, (.dmark)  
274e 32 7a ee			ld (debug_mark),a  
2751 3a 60 27			ld a, (.dmark+1)  
2754 32 7b ee			ld (debug_mark+1),a  
2757 3a 61 27			ld a, (.dmark+2)  
275a 32 7c ee			ld (debug_mark+2),a  
275d 18 03			jr .pastdmark  
275f ..			.dmark: db "MAL"  
2762 f1			.pastdmark: pop af  
2763			endm  
# End of macro DMARK
2763						CALLMONITOR 
2763 cd ff 13			call break_point_state  
2766				endm  
# End of macro CALLMONITOR
2766					endif 
2766			.mallocc: 
2766					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2766 cd 83 1b			call macro_dsp_valuehl 
2769				endm 
# End of macro FORTH_DSP_VALUEHL
2769			 
2769			;		push hl 
2769			 
2769					; destroy value TOS 
2769			 
2769					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2769 cd 3b 1c			call macro_forth_dsp_pop 
276c				endm 
# End of macro FORTH_DSP_POP
276c			 
276c			;		pop hl 
276c cd 79 10				call malloc 
276f				if DEBUG_FORTH_MALLOC_GUARD 
276f f5					push af 
2770 cd db 0b				call ishlzero 
2773			;		ld a, l 
2773			;		add h 
2773			;		cp 0 
2773 f1					pop af 
2774					 
2774 cc 34 46				call z,malloc_error 
2777				endif 
2777			 
2777 cd 8c 19				call forth_push_numhl 
277a					NEXTW 
277a c3 f5 1c			jp macro_next 
277d				endm 
# End of macro NEXTW
277d			 
277d			.FREE: 
277d				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
277d 57				db WORD_SYS_CORE+67             
277e ae 27			dw .LIST            
2780 05				db 4 + 1 
2781 .. 00			db "FREE",0              
2786				endm 
# End of macro CWHEAD
2786			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2786					if DEBUG_FORTH_WORDS_KEY 
2786						DMARK "FRE" 
2786 f5				push af  
2787 3a 9b 27			ld a, (.dmark)  
278a 32 7a ee			ld (debug_mark),a  
278d 3a 9c 27			ld a, (.dmark+1)  
2790 32 7b ee			ld (debug_mark+1),a  
2793 3a 9d 27			ld a, (.dmark+2)  
2796 32 7c ee			ld (debug_mark+2),a  
2799 18 03			jr .pastdmark  
279b ..			.dmark: db "FRE"  
279e f1			.pastdmark: pop af  
279f			endm  
# End of macro DMARK
279f						CALLMONITOR 
279f cd ff 13			call break_point_state  
27a2				endm  
# End of macro CALLMONITOR
27a2					endif 
27a2					; get address 
27a2			 
27a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27a2 cd 83 1b			call macro_dsp_valuehl 
27a5				endm 
# End of macro FORTH_DSP_VALUEHL
27a5			 
27a5			;		push hl 
27a5			 
27a5					; destroy value TOS 
27a5			 
27a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27a5 cd 3b 1c			call macro_forth_dsp_pop 
27a8				endm 
# End of macro FORTH_DSP_POP
27a8			 
27a8			;		pop hl 
27a8			if FORTH_ENABLE_MALLOCFREE 
27a8 cd 43 11				call free 
27ab			endif 
27ab					NEXTW 
27ab c3 f5 1c			jp macro_next 
27ae				endm 
# End of macro NEXTW
27ae			.LIST: 
27ae				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
27ae 5c				db WORD_SYS_CORE+72             
27af 71 29			dw .FORGET            
27b1 05				db 4 + 1 
27b2 .. 00			db "LIST",0              
27b7				endm 
# End of macro CWHEAD
27b7			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
27b7			; | | The quoted word must be in upper case. 
27b7				if DEBUG_FORTH_WORDS_KEY 
27b7					DMARK "LST" 
27b7 f5				push af  
27b8 3a cc 27			ld a, (.dmark)  
27bb 32 7a ee			ld (debug_mark),a  
27be 3a cd 27			ld a, (.dmark+1)  
27c1 32 7b ee			ld (debug_mark+1),a  
27c4 3a ce 27			ld a, (.dmark+2)  
27c7 32 7c ee			ld (debug_mark+2),a  
27ca 18 03			jr .pastdmark  
27cc ..			.dmark: db "LST"  
27cf f1			.pastdmark: pop af  
27d0			endm  
# End of macro DMARK
27d0					CALLMONITOR 
27d0 cd ff 13			call break_point_state  
27d3				endm  
# End of macro CALLMONITOR
27d3				endif 
27d3			 
27d3					FORTH_DSP_VALUEHL 
27d3 cd 83 1b			call macro_dsp_valuehl 
27d6				endm 
# End of macro FORTH_DSP_VALUEHL
27d6			 
27d6 e5					push hl 
27d7 c1					pop bc 
27d8			 
27d8			; Start format of scratch string 
27d8			 
27d8 21 60 e3				ld hl, scratch 
27db			 
27db 3e 3a				ld a, ':' 
27dd 77					ld (hl),a 
27de 23					inc hl 
27df 3e 20				ld a, ' ' 
27e1 77					ld (hl), a 
27e2			 
27e2					; Get ptr to the word we need to look up 
27e2			 
27e2			;		FORTH_DSP_VALUEHL 
27e2					;v5 FORTH_DSP_VALUE 
27e2				; TODO type check 
27e2			;		inc hl    ; Skip type check  
27e2			;		push hl 
27e2			;		ex de, hl    ; put into DE 
27e2			 
27e2			 
27e2 21 d7 59				ld hl, baseram 
27e5					;ld hl, baseusermem 
27e5			 
27e5 e5			push hl   ; sacreifical push 
27e6			 
27e6			.ldouscanm: 
27e6 e1				pop hl 
27e7			.ldouscan: 
27e7				if DEBUG_FORTH_WORDS 
27e7					DMARK "LSs" 
27e7 f5				push af  
27e8 3a fc 27			ld a, (.dmark)  
27eb 32 7a ee			ld (debug_mark),a  
27ee 3a fd 27			ld a, (.dmark+1)  
27f1 32 7b ee			ld (debug_mark+1),a  
27f4 3a fe 27			ld a, (.dmark+2)  
27f7 32 7c ee			ld (debug_mark+2),a  
27fa 18 03			jr .pastdmark  
27fc ..			.dmark: db "LSs"  
27ff f1			.pastdmark: pop af  
2800			endm  
# End of macro DMARK
2800					CALLMONITOR 
2800 cd ff 13			call break_point_state  
2803				endm  
# End of macro CALLMONITOR
2803				endif 
2803				; skip dict stub 
2803 cd 46 1e				call forth_tok_next 
2806			 
2806			 
2806			; while we have words to look for 
2806			 
2806 7e				ld a, (hl)      
2807				if DEBUG_FORTH_WORDS 
2807					DMARK "LSk" 
2807 f5				push af  
2808 3a 1c 28			ld a, (.dmark)  
280b 32 7a ee			ld (debug_mark),a  
280e 3a 1d 28			ld a, (.dmark+1)  
2811 32 7b ee			ld (debug_mark+1),a  
2814 3a 1e 28			ld a, (.dmark+2)  
2817 32 7c ee			ld (debug_mark+2),a  
281a 18 03			jr .pastdmark  
281c ..			.dmark: db "LSk"  
281f f1			.pastdmark: pop af  
2820			endm  
# End of macro DMARK
2820					CALLMONITOR 
2820 cd ff 13			call break_point_state  
2823				endm  
# End of macro CALLMONITOR
2823				endif 
2823 fe 00				cp WORD_SYS_END 
2825 ca 58 29				jp z, .lunotfound 
2828 fe 01				cp WORD_SYS_UWORD 
282a c2 e7 27				jp nz, .ldouscan 
282d			 
282d				if DEBUG_FORTH_WORDS 
282d					DMARK "LSu" 
282d f5				push af  
282e 3a 42 28			ld a, (.dmark)  
2831 32 7a ee			ld (debug_mark),a  
2834 3a 43 28			ld a, (.dmark+1)  
2837 32 7b ee			ld (debug_mark+1),a  
283a 3a 44 28			ld a, (.dmark+2)  
283d 32 7c ee			ld (debug_mark+2),a  
2840 18 03			jr .pastdmark  
2842 ..			.dmark: db "LSu"  
2845 f1			.pastdmark: pop af  
2846			endm  
# End of macro DMARK
2846					CALLMONITOR 
2846 cd ff 13			call break_point_state  
2849				endm  
# End of macro CALLMONITOR
2849				endif 
2849			 
2849					; found a uword but is it the one we want... 
2849			 
2849 c5					push bc     ; uword to find is on bc 
284a d1					pop de 
284b			 
284b e5					push hl  ; to save the ptr 
284c			 
284c					; skip opcode 
284c 23					inc hl  
284d					; skip next ptr 
284d 23					inc hl  
284e 23					inc hl 
284f					; skip len 
284f 23					inc hl 
2850			 
2850				if DEBUG_FORTH_WORDS 
2850					DMARK "LSc" 
2850 f5				push af  
2851 3a 65 28			ld a, (.dmark)  
2854 32 7a ee			ld (debug_mark),a  
2857 3a 66 28			ld a, (.dmark+1)  
285a 32 7b ee			ld (debug_mark+1),a  
285d 3a 67 28			ld a, (.dmark+2)  
2860 32 7c ee			ld (debug_mark+2),a  
2863 18 03			jr .pastdmark  
2865 ..			.dmark: db "LSc"  
2868 f1			.pastdmark: pop af  
2869			endm  
# End of macro DMARK
2869					CALLMONITOR 
2869 cd ff 13			call break_point_state  
286c				endm  
# End of macro CALLMONITOR
286c				endif 
286c cd 48 10				call strcmp 
286f c2 e6 27				jp nz, .ldouscanm 
2872				 
2872			 
2872			 
2872					; we have a uword so push its name to the stack 
2872			 
2872			;	   	push hl  ; save so we can move to next dict block 
2872 e1			pop hl 
2873			 
2873				if DEBUG_FORTH_WORDS 
2873					DMARK "LSm" 
2873 f5				push af  
2874 3a 88 28			ld a, (.dmark)  
2877 32 7a ee			ld (debug_mark),a  
287a 3a 89 28			ld a, (.dmark+1)  
287d 32 7b ee			ld (debug_mark+1),a  
2880 3a 8a 28			ld a, (.dmark+2)  
2883 32 7c ee			ld (debug_mark+2),a  
2886 18 03			jr .pastdmark  
2888 ..			.dmark: db "LSm"  
288b f1			.pastdmark: pop af  
288c			endm  
# End of macro DMARK
288c					CALLMONITOR 
288c cd ff 13			call break_point_state  
288f				endm  
# End of macro CALLMONITOR
288f				endif 
288f			 
288f					; skip opcode 
288f 23					inc hl  
2890					; skip next ptr 
2890 23					inc hl  
2891 23					inc hl 
2892					; skip len 
2892 7e					ld a, (hl)   ; save length to add 
2893				if DEBUG_FORTH_WORDS 
2893					DMARK "LS2" 
2893 f5				push af  
2894 3a a8 28			ld a, (.dmark)  
2897 32 7a ee			ld (debug_mark),a  
289a 3a a9 28			ld a, (.dmark+1)  
289d 32 7b ee			ld (debug_mark+1),a  
28a0 3a aa 28			ld a, (.dmark+2)  
28a3 32 7c ee			ld (debug_mark+2),a  
28a6 18 03			jr .pastdmark  
28a8 ..			.dmark: db "LS2"  
28ab f1			.pastdmark: pop af  
28ac			endm  
# End of macro DMARK
28ac					CALLMONITOR 
28ac cd ff 13			call break_point_state  
28af				endm  
# End of macro CALLMONITOR
28af				endif 
28af			 
28af					; save this location 
28af				 
28af e5					push hl 
28b0			 
28b0 23					inc hl 
28b1 11 62 e3				ld de, scratch+2 
28b4 4f					ld c, a 
28b5 06 00				ld b, 0 
28b7			 
28b7				if DEBUG_FORTH_WORDS 
28b7					DMARK "LSn" 
28b7 f5				push af  
28b8 3a cc 28			ld a, (.dmark)  
28bb 32 7a ee			ld (debug_mark),a  
28be 3a cd 28			ld a, (.dmark+1)  
28c1 32 7b ee			ld (debug_mark+1),a  
28c4 3a ce 28			ld a, (.dmark+2)  
28c7 32 7c ee			ld (debug_mark+2),a  
28ca 18 03			jr .pastdmark  
28cc ..			.dmark: db "LSn"  
28cf f1			.pastdmark: pop af  
28d0			endm  
# End of macro DMARK
28d0					CALLMONITOR 
28d0 cd ff 13			call break_point_state  
28d3				endm  
# End of macro CALLMONITOR
28d3				endif 
28d3			 
28d3					; copy uword name to scratch 
28d3			 
28d3 ed b0				ldir 
28d5			 
28d5 1b					dec de 
28d6 3e 20				ld a, ' '    ; change null to space 
28d8 12					ld (de), a 
28d9			 
28d9 13					inc de 
28da			 
28da d5					push de 
28db c1					pop bc     ; move scratch pointer to end of word name and save it 
28dc			 
28dc e1					pop hl 
28dd 7e					ld a, (hl) 
28de					;inc hl 
28de					; skip word string 
28de cd b2 0b				call addatohl 
28e1			 
28e1 23					inc hl 
28e2			 
28e2				if DEBUG_FORTH_WORDS 
28e2					DMARK "LS3" 
28e2 f5				push af  
28e3 3a f7 28			ld a, (.dmark)  
28e6 32 7a ee			ld (debug_mark),a  
28e9 3a f8 28			ld a, (.dmark+1)  
28ec 32 7b ee			ld (debug_mark+1),a  
28ef 3a f9 28			ld a, (.dmark+2)  
28f2 32 7c ee			ld (debug_mark+2),a  
28f5 18 03			jr .pastdmark  
28f7 ..			.dmark: db "LS3"  
28fa f1			.pastdmark: pop af  
28fb			endm  
# End of macro DMARK
28fb					CALLMONITOR 
28fb cd ff 13			call break_point_state  
28fe				endm  
# End of macro CALLMONITOR
28fe				endif 
28fe					; should now be at the start of the machine code to setup the eval of the uword 
28fe					; now locate the ptr to the string defintion 
28fe			 
28fe					; skip ld hl, 
28fe					; then load the ptr 
28fe			 
28fe 23					inc hl 
28ff 5e					ld e, (hl) 
2900 23					inc hl 
2901 56					ld d, (hl) 
2902 eb					ex de, hl 
2903			 
2903			 
2903				if DEBUG_FORTH_WORDS 
2903					DMARK "LSt" 
2903 f5				push af  
2904 3a 18 29			ld a, (.dmark)  
2907 32 7a ee			ld (debug_mark),a  
290a 3a 19 29			ld a, (.dmark+1)  
290d 32 7b ee			ld (debug_mark+1),a  
2910 3a 1a 29			ld a, (.dmark+2)  
2913 32 7c ee			ld (debug_mark+2),a  
2916 18 03			jr .pastdmark  
2918 ..			.dmark: db "LSt"  
291b f1			.pastdmark: pop af  
291c			endm  
# End of macro DMARK
291c					CALLMONITOR 
291c cd ff 13			call break_point_state  
291f				endm  
# End of macro CALLMONITOR
291f				endif 
291f			 
291f			; cant push right now due to tokenised strings  
291f			 
291f			; get the destination of where to copy this definition to. 
291f			 
291f c5					push bc 
2920 d1					pop de 
2921			 
2921 7e			.listl:         ld a,(hl) 
2922 fe 00				cp 0 
2924 28 09				jr z, .lreplsp     ; replace zero with space 
2926 fe 7f				cp FORTH_END_BUFFER 
2928 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
292a				 
292a					; just copy this char as is then 
292a			 
292a 12					ld (de), a 
292b			 
292b 23			.listnxt:	inc hl 
292c 13					inc de 
292d 18 f2				jr .listl 
292f			 
292f 3e 20		.lreplsp:	ld a,' ' 
2931 12					ld (de), a 
2932 18 f7				jr .listnxt 
2934			 
2934			; close up uword def 
2934			 
2934			.listdone: 
2934 3e 00				ld a, 0 
2936 12					ld (de), a 
2937			 
2937			; now have def so clean up and push to stack 
2937			 
2937 21 60 e3				ld hl, scratch 
293a				if DEBUG_FORTH_WORDS 
293a					DMARK "Ltp" 
293a f5				push af  
293b 3a 4f 29			ld a, (.dmark)  
293e 32 7a ee			ld (debug_mark),a  
2941 3a 50 29			ld a, (.dmark+1)  
2944 32 7b ee			ld (debug_mark+1),a  
2947 3a 51 29			ld a, (.dmark+2)  
294a 32 7c ee			ld (debug_mark+2),a  
294d 18 03			jr .pastdmark  
294f ..			.dmark: db "Ltp"  
2952 f1			.pastdmark: pop af  
2953			endm  
# End of macro DMARK
2953					CALLMONITOR 
2953 cd ff 13			call break_point_state  
2956				endm  
# End of macro CALLMONITOR
2956				endif 
2956			 
2956 18 06			jr .listpush 
2958			 
2958			;.lnuword:	pop hl 
2958			;		call forth_tok_next 
2958			;		jp .ldouscan  
2958			 
2958			.lunotfound:		  
2958			 
2958			 
2958					 
2958					FORTH_DSP_POP 
2958 cd 3b 1c			call macro_forth_dsp_pop 
295b				endm 
# End of macro FORTH_DSP_POP
295b 21 64 29				ld hl, .luno 
295e						 
295e			 
295e			.listpush: 
295e cd fa 19				call forth_push_str 
2961			 
2961			 
2961			 
2961					NEXTW 
2961 c3 f5 1c			jp macro_next 
2964				endm 
# End of macro NEXTW
2964			 
2964 .. 00		.luno:    db "Not found",0 
296e			 
296e			 
296e			 
296e			 
296e			 
296e			;		push hl   ; save pointer to start of uword def string 
296e			; 
296e			;; look for FORTH_EOL_LINE 
296e			;		ld a, FORTH_END_BUFFER 
296e			;		call strlent 
296e			; 
296e			;		inc hl		 ; space for coln def 
296e			;		inc hl 
296e			;		inc hl          ; space for terms 
296e			;		inc hl 
296e			; 
296e			;		ld a, 20   ; TODO get actual length 
296e			;		call addatohl    ; include a random amount of room for the uword name 
296e			; 
296e			;		 
296e			;	if DEBUG_FORTH_WORDS 
296e			;		DMARK "Lt1" 
296e			;		CALLMONITOR 
296e			;	endif 
296e			;		 
296e			; 
296e			;; malloc space for the string because we cant change it 
296e			; 
296e			;		call malloc 
296e			;	if DEBUG_FORTH_MALLOC_GUARD 
296e			;		push af 
296e			;		call ishlzero 
296e			;		pop af 
296e			;		 
296e			;		call z,malloc_error 
296e			;	endif 
296e			; 
296e			;	if DEBUG_FORTH_WORDS 
296e			;		DMARK "Lt2" 
296e			;		CALLMONITOR 
296e			;	endif 
296e			;		pop de 
296e			;		push hl    ; push the malloc to release later 
296e			;		push hl   ;  push back a copy for the later stack push 
296e			;		 
296e			;; copy the string swapping out the zero terms for spaces 
296e			; 
296e			;		; de has our source 
296e			;		; hl has our dest 
296e			; 
296e			;; add the coln def 
296e			; 
296e			;		ld a, ':' 
296e			;		ld (hl), a 
296e			;		inc hl 
296e			;		ld a, ' ' 
296e			;		ld (hl), a 
296e			;		inc hl 
296e			; 
296e			;; add the uname word 
296e			;		push de   ; save our string for now 
296e			;		ex de, hl 
296e			; 
296e			;		FORTH_DSP_VALUE 
296e			;		;v5 FORTH_DSP_VALUE 
296e			; 
296e			;		inc hl   ; skip type but we know by now this is OK 
296e			; 
296e			;.luword:	ld a,(hl) 
296e			;		cp 0 
296e			;		jr z, .luword2 
296e			;		ld (de), a 
296e			;		inc de 
296e			;		inc hl 
296e			;		jr .luword 
296e			; 
296e			;.luword2:	ld a, ' ' 
296e			;		ld (de), a 
296e			;;		inc hl 
296e			;;		inc de 
296e			;;		ld (de), a 
296e			;;		inc hl 
296e			;		inc de 
296e			; 
296e			;		ex de, hl 
296e			;		pop de 
296e			;		 
296e			;		 
296e			; 
296e			;; detoken that string and copy it 
296e			; 
296e			;	if DEBUG_FORTH_WORDS 
296e			;		DMARK "Lt2" 
296e			;		CALLMONITOR 
296e			;	endif 
296e			;.ldetok:	ld a, (de) 
296e			;		cp FORTH_END_BUFFER 
296e			;		jr z, .ldetokend 
296e			;		; swap out any zero term for space 
296e			;		cp 0 
296e			;		jr nz, .ldetoknext 
296e			;		ld a, ' ' 
296e			; 
296e			;	if DEBUG_FORTH_WORDS 
296e			;		DMARK "LtS" 
296e			;		CALLMONITOR 
296e			;	endif 
296e			;.ldetoknext:	ld (hl), a 
296e			;		inc de 
296e			;		inc hl 
296e			;		jr .ldetok 
296e			; 
296e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
296e			;		ld (hl), a  
296e			; 
296e			;; free that temp malloc 
296e			; 
296e			;		pop hl    
296e			; 
296e			;	if DEBUG_FORTH_WORDS 
296e			;		DMARK "Lt4" 
296e			;		CALLMONITOR 
296e			;	endif 
296e			;		call forth_apushstrhl 
296e			; 
296e			;		; get rid of temp malloc area 
296e			; 
296e			;		pop hl 
296e			;		call free 
296e			; 
296e			;		jr .ludone 
296e			; 
296e			;.lnuword:	pop hl 
296e			;		call forth_tok_next 
296e			;		jp .ldouscan  
296e			; 
296e			;.ludone:		 pop hl 
296e			; 
296e					NEXTW 
296e c3 f5 1c			jp macro_next 
2971				endm 
# End of macro NEXTW
2971			 
2971			.FORGET: 
2971				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2971 5d				db WORD_SYS_CORE+73             
2972 ea 29			dw .NOP            
2974 07				db 6 + 1 
2975 .. 00			db "FORGET",0              
297c				endm 
# End of macro CWHEAD
297c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
297c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
297c			; | |  
297c			; | | e.g. "MORE" forget 
297c					if DEBUG_FORTH_WORDS_KEY 
297c						DMARK "FRG" 
297c f5				push af  
297d 3a 91 29			ld a, (.dmark)  
2980 32 7a ee			ld (debug_mark),a  
2983 3a 92 29			ld a, (.dmark+1)  
2986 32 7b ee			ld (debug_mark+1),a  
2989 3a 93 29			ld a, (.dmark+2)  
298c 32 7c ee			ld (debug_mark+2),a  
298f 18 03			jr .pastdmark  
2991 ..			.dmark: db "FRG"  
2994 f1			.pastdmark: pop af  
2995			endm  
# End of macro DMARK
2995						CALLMONITOR 
2995 cd ff 13			call break_point_state  
2998				endm  
# End of macro CALLMONITOR
2998					endif 
2998			 
2998				; find uword 
2998			        ; update start of word with "_" 
2998				; replace uword with deleted flag 
2998			 
2998			 
2998			;	if DEBUG_FORTH_WORDS 
2998			;		DMARK "FOG" 
2998			;		CALLMONITOR 
2998			;	endif 
2998			 
2998			 
2998					; Get ptr to the word we need to look up 
2998			 
2998					FORTH_DSP_VALUEHL 
2998 cd 83 1b			call macro_dsp_valuehl 
299b				endm 
# End of macro FORTH_DSP_VALUEHL
299b					;v5 FORTH_DSP_VALUE 
299b				; TODO type check 
299b			;		inc hl    ; Skip type check  
299b e5					push hl 
299c c1					pop bc 
299d			;		ex de, hl    ; put into DE 
299d			 
299d			 
299d 21 d7 59				ld hl, baseram 
29a0					;ld hl, baseusermem 
29a0			 
29a0				; skip dict stub 
29a0			;	call forth_tok_next 
29a0 e5			push hl   ; sacreifical push 
29a1			 
29a1			.fldouscanm: 
29a1 e1				pop hl 
29a2			.fldouscan: 
29a2			;	if DEBUG_FORTH_WORDS 
29a2			;		DMARK "LSs" 
29a2			;		CALLMONITOR 
29a2			;	endif 
29a2				; skip dict stub 
29a2 cd 46 1e				call forth_tok_next 
29a5			 
29a5			 
29a5			; while we have words to look for 
29a5			 
29a5 7e				ld a, (hl)      
29a6			;	if DEBUG_FORTH_WORDS 
29a6			;		DMARK "LSk" 
29a6			;		CALLMONITOR 
29a6			;	endif 
29a6 fe 00				cp WORD_SYS_END 
29a8 ca e4 29				jp z, .flunotfound 
29ab fe 01				cp WORD_SYS_UWORD 
29ad c2 a2 29				jp nz, .fldouscan 
29b0			 
29b0			;	if DEBUG_FORTH_WORDS 
29b0			;		DMARK "LSu" 
29b0			;		CALLMONITOR 
29b0			;	endif 
29b0			 
29b0					; found a uword but is it the one we want... 
29b0			 
29b0 c5					push bc     ; uword to find is on bc 
29b1 d1					pop de 
29b2			 
29b2 e5					push hl  ; to save the ptr 
29b3			 
29b3					; skip opcode 
29b3 23					inc hl  
29b4					; skip next ptr 
29b4 23					inc hl  
29b5 23					inc hl 
29b6					; skip len 
29b6 23					inc hl 
29b7			 
29b7			;	if DEBUG_FORTH_WORDS 
29b7			;		DMARK "LSc" 
29b7			;		CALLMONITOR 
29b7			;	endif 
29b7 cd 48 10				call strcmp 
29ba c2 a1 29				jp nz, .fldouscanm 
29bd			; 
29bd			; 
29bd			;; while we have words to look for 
29bd			; 
29bd			;.fdouscan:	ld a, (hl)      
29bd			;	if DEBUG_FORTH_WORDS 
29bd			;		DMARK "LSs" 
29bd			;		CALLMONITOR 
29bd			;	endif 
29bd			;		cp WORD_SYS_END 
29bd			;		jp z, .fudone 
29bd			;		cp WORD_SYS_UWORD 
29bd			;		jp nz, .fnuword 
29bd			; 
29bd			;	if DEBUG_FORTH_WORDS 
29bd			;		DMARK "FGu" 
29bd			;		CALLMONITOR 
29bd			;	endif 
29bd			; 
29bd			;		; found a uword but is it the one we want... 
29bd			; 
29bd			; 
29bd			;	        pop de   ; get back the dsp name 
29bd			;		push de 
29bd			; 
29bd			;		push hl  ; to save the ptr 
29bd			; 
29bd			;		; skip opcode 
29bd			;		inc hl  
29bd			;		; skip next ptr 
29bd			;		inc hl  
29bd			;		inc hl 
29bd			;		; skip len 
29bd			;		inc hl 
29bd			; 
29bd			;	if DEBUG_FORTH_WORDS 
29bd			;		DMARK "FGc" 
29bd			;		CALLMONITOR 
29bd			;	endif 
29bd			;		call strcmp 
29bd			;		jp nz, .fnuword 
29bd			 
29bd			 
29bd e1			pop hl 
29be			 
29be				 
29be				if DEBUG_FORTH_WORDS 
29be					DMARK "FGm" 
29be f5				push af  
29bf 3a d3 29			ld a, (.dmark)  
29c2 32 7a ee			ld (debug_mark),a  
29c5 3a d4 29			ld a, (.dmark+1)  
29c8 32 7b ee			ld (debug_mark+1),a  
29cb 3a d5 29			ld a, (.dmark+2)  
29ce 32 7c ee			ld (debug_mark+2),a  
29d1 18 03			jr .pastdmark  
29d3 ..			.dmark: db "FGm"  
29d6 f1			.pastdmark: pop af  
29d7			endm  
# End of macro DMARK
29d7					CALLMONITOR 
29d7 cd ff 13			call break_point_state  
29da				endm  
# End of macro CALLMONITOR
29da				endif 
29da			 
29da			 
29da			 
29da					; we have a uword so push its name to the stack 
29da			 
29da			;	   	push hl  ; save so we can move to next dict block 
29da			;pop hl 
29da			 
29da					; update opcode to deleted 
29da 3e 03				ld a, WORD_SYS_DELETED 
29dc 77					ld (hl), a 
29dd			 
29dd 23					inc hl  
29de					; skip next ptr 
29de 23					inc hl  
29df 23					inc hl 
29e0					; skip len 
29e0 23					inc hl 
29e1			 
29e1					; TODO change parser to skip deleted words but for now mark it out 
29e1 3e 5f				ld a, "_" 
29e3 77					ld  (hl),a 
29e4			 
29e4			;		jr .fudone 
29e4			; 
29e4			;.fnuword:	pop hl 
29e4			;		call forth_tok_next 
29e4			;		jp .fdouscan  
29e4			 
29e4			.flunotfound:		  
29e4			 
29e4			 
29e4					 
29e4					FORTH_DSP_POP 
29e4 cd 3b 1c			call macro_forth_dsp_pop 
29e7				endm 
# End of macro FORTH_DSP_POP
29e7			;		ld hl, .luno 
29e7			;.fudone:		 pop hl 
29e7					NEXTW 
29e7 c3 f5 1c			jp macro_next 
29ea				endm 
# End of macro NEXTW
29ea			.NOP: 
29ea				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
29ea 61				db WORD_SYS_CORE+77             
29eb 11 2a			dw .COMO            
29ed 04				db 3 + 1 
29ee .. 00			db "NOP",0              
29f2				endm 
# End of macro CWHEAD
29f2			; | NOP (  --  ) Do nothing | DONE 
29f2					if DEBUG_FORTH_WORDS_KEY 
29f2						DMARK "NOP" 
29f2 f5				push af  
29f3 3a 07 2a			ld a, (.dmark)  
29f6 32 7a ee			ld (debug_mark),a  
29f9 3a 08 2a			ld a, (.dmark+1)  
29fc 32 7b ee			ld (debug_mark+1),a  
29ff 3a 09 2a			ld a, (.dmark+2)  
2a02 32 7c ee			ld (debug_mark+2),a  
2a05 18 03			jr .pastdmark  
2a07 ..			.dmark: db "NOP"  
2a0a f1			.pastdmark: pop af  
2a0b			endm  
# End of macro DMARK
2a0b						CALLMONITOR 
2a0b cd ff 13			call break_point_state  
2a0e				endm  
# End of macro CALLMONITOR
2a0e					endif 
2a0e				       NEXTW 
2a0e c3 f5 1c			jp macro_next 
2a11				endm 
# End of macro NEXTW
2a11			.COMO: 
2a11				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2a11 6e				db WORD_SYS_CORE+90             
2a12 63 2a			dw .COMC            
2a14 02				db 1 + 1 
2a15 .. 00			db "(",0              
2a17				endm 
# End of macro CWHEAD
2a17			; | ( ( -- )  Start of comment | DONE 
2a17			 
2a17			 
2a17 2a 61 e6				ld hl, ( os_tok_ptr) 
2a1a 11 5e 2a			ld de, .closepar 
2a1d					 
2a1d					if DEBUG_FORTH_WORDS 
2a1d						DMARK ").." 
2a1d f5				push af  
2a1e 3a 32 2a			ld a, (.dmark)  
2a21 32 7a ee			ld (debug_mark),a  
2a24 3a 33 2a			ld a, (.dmark+1)  
2a27 32 7b ee			ld (debug_mark+1),a  
2a2a 3a 34 2a			ld a, (.dmark+2)  
2a2d 32 7c ee			ld (debug_mark+2),a  
2a30 18 03			jr .pastdmark  
2a32 ..			.dmark: db ").."  
2a35 f1			.pastdmark: pop af  
2a36			endm  
# End of macro DMARK
2a36						CALLMONITOR 
2a36 cd ff 13			call break_point_state  
2a39				endm  
# End of macro CALLMONITOR
2a39					endif 
2a39 cd 10 1e			call findnexttok  
2a3c			 
2a3c					if DEBUG_FORTH_WORDS 
2a3c						DMARK "IF5" 
2a3c f5				push af  
2a3d 3a 51 2a			ld a, (.dmark)  
2a40 32 7a ee			ld (debug_mark),a  
2a43 3a 52 2a			ld a, (.dmark+1)  
2a46 32 7b ee			ld (debug_mark+1),a  
2a49 3a 53 2a			ld a, (.dmark+2)  
2a4c 32 7c ee			ld (debug_mark+2),a  
2a4f 18 03			jr .pastdmark  
2a51 ..			.dmark: db "IF5"  
2a54 f1			.pastdmark: pop af  
2a55			endm  
# End of macro DMARK
2a55						CALLMONITOR 
2a55 cd ff 13			call break_point_state  
2a58				endm  
# End of macro CALLMONITOR
2a58					endif 
2a58				; replace below with ) exec using tok_ptr 
2a58 22 61 e6			ld (os_tok_ptr), hl 
2a5b c3 86 1d			jp exec1 
2a5e			 
2a5e .. 00			.closepar:   db ")",0 
2a60			 
2a60				       NEXTW 
2a60 c3 f5 1c			jp macro_next 
2a63				endm 
# End of macro NEXTW
2a63			.COMC: 
2a63				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2a63 6f				db WORD_SYS_CORE+91             
2a64 6c 2a			dw .SCRATCH            
2a66 02				db 1 + 1 
2a67 .. 00			db ")",0              
2a69				endm 
# End of macro CWHEAD
2a69			; | ) ( -- )  End of comment |  DONE  
2a69				       NEXTW 
2a69 c3 f5 1c			jp macro_next 
2a6c				endm 
# End of macro NEXTW
2a6c			 
2a6c			.SCRATCH: 
2a6c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2a6c 6f				db WORD_SYS_CORE+91             
2a6d a7 2a			dw .INC            
2a6f 08				db 7 + 1 
2a70 .. 00			db "SCRATCH",0              
2a78				endm 
# End of macro CWHEAD
2a78			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2a78			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2a78			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2a78			; | |  
2a78			; | | e.g.    : score $00 scratch ; 
2a78			; | |  
2a78			; | | $00 score ! 
2a78			; | | $01 score +! 
2a78			; | |  
2a78			; | | e.g.   : varword $0a scratch ;  
2a78			; | | 
2a78			; | | $8000 varword ! 
2a78					if DEBUG_FORTH_WORDS_KEY 
2a78						DMARK "SCR" 
2a78 f5				push af  
2a79 3a 8d 2a			ld a, (.dmark)  
2a7c 32 7a ee			ld (debug_mark),a  
2a7f 3a 8e 2a			ld a, (.dmark+1)  
2a82 32 7b ee			ld (debug_mark+1),a  
2a85 3a 8f 2a			ld a, (.dmark+2)  
2a88 32 7c ee			ld (debug_mark+2),a  
2a8b 18 03			jr .pastdmark  
2a8d ..			.dmark: db "SCR"  
2a90 f1			.pastdmark: pop af  
2a91			endm  
# End of macro DMARK
2a91						CALLMONITOR 
2a91 cd ff 13			call break_point_state  
2a94				endm  
# End of macro CALLMONITOR
2a94					endif 
2a94			 
2a94					FORTH_DSP_VALUEHL 
2a94 cd 83 1b			call macro_dsp_valuehl 
2a97				endm 
# End of macro FORTH_DSP_VALUEHL
2a97				 
2a97					FORTH_DSP_POP 
2a97 cd 3b 1c			call macro_forth_dsp_pop 
2a9a				endm 
# End of macro FORTH_DSP_POP
2a9a			 
2a9a 7d					ld a, l 
2a9b 21 85 e8				ld hl, os_var_array 
2a9e cd b2 0b				call addatohl 
2aa1			 
2aa1 cd 8c 19				call forth_push_numhl 
2aa4			 
2aa4				       NEXTW 
2aa4 c3 f5 1c			jp macro_next 
2aa7				endm 
# End of macro NEXTW
2aa7			 
2aa7			.INC: 
2aa7				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2aa7 6f				db WORD_SYS_CORE+91             
2aa8 fb 2a			dw .DEC            
2aaa 03				db 2 + 1 
2aab .. 00			db "+!",0              
2aae				endm 
# End of macro CWHEAD
2aae			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2aae					if DEBUG_FORTH_WORDS_KEY 
2aae						DMARK "+s_" 
2aae f5				push af  
2aaf 3a c3 2a			ld a, (.dmark)  
2ab2 32 7a ee			ld (debug_mark),a  
2ab5 3a c4 2a			ld a, (.dmark+1)  
2ab8 32 7b ee			ld (debug_mark+1),a  
2abb 3a c5 2a			ld a, (.dmark+2)  
2abe 32 7c ee			ld (debug_mark+2),a  
2ac1 18 03			jr .pastdmark  
2ac3 ..			.dmark: db "+s_"  
2ac6 f1			.pastdmark: pop af  
2ac7			endm  
# End of macro DMARK
2ac7						CALLMONITOR 
2ac7 cd ff 13			call break_point_state  
2aca				endm  
# End of macro CALLMONITOR
2aca					endif 
2aca			 
2aca					FORTH_DSP_VALUEHL 
2aca cd 83 1b			call macro_dsp_valuehl 
2acd				endm 
# End of macro FORTH_DSP_VALUEHL
2acd			 
2acd e5					push hl   ; save address 
2ace			 
2ace					FORTH_DSP_POP 
2ace cd 3b 1c			call macro_forth_dsp_pop 
2ad1				endm 
# End of macro FORTH_DSP_POP
2ad1			 
2ad1					FORTH_DSP_VALUEHL 
2ad1 cd 83 1b			call macro_dsp_valuehl 
2ad4				endm 
# End of macro FORTH_DSP_VALUEHL
2ad4			 
2ad4					FORTH_DSP_POP 
2ad4 cd 3b 1c			call macro_forth_dsp_pop 
2ad7				endm 
# End of macro FORTH_DSP_POP
2ad7			 
2ad7					; hl contains value to add to byte at a 
2ad7				 
2ad7 eb					ex de, hl 
2ad8			 
2ad8 e1					pop hl 
2ad9			 
2ad9					if DEBUG_FORTH_WORDS 
2ad9						DMARK "INC" 
2ad9 f5				push af  
2ada 3a ee 2a			ld a, (.dmark)  
2add 32 7a ee			ld (debug_mark),a  
2ae0 3a ef 2a			ld a, (.dmark+1)  
2ae3 32 7b ee			ld (debug_mark+1),a  
2ae6 3a f0 2a			ld a, (.dmark+2)  
2ae9 32 7c ee			ld (debug_mark+2),a  
2aec 18 03			jr .pastdmark  
2aee ..			.dmark: db "INC"  
2af1 f1			.pastdmark: pop af  
2af2			endm  
# End of macro DMARK
2af2						CALLMONITOR 
2af2 cd ff 13			call break_point_state  
2af5				endm  
# End of macro CALLMONITOR
2af5					endif 
2af5			 
2af5 7e					ld a,(hl) 
2af6 83					add e 
2af7 77					ld (hl),a 
2af8			 
2af8			 
2af8			 
2af8				       NEXTW 
2af8 c3 f5 1c			jp macro_next 
2afb				endm 
# End of macro NEXTW
2afb			 
2afb			.DEC: 
2afb				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2afb 6f				db WORD_SYS_CORE+91             
2afc 4c 2b			dw .INC2            
2afe 03				db 2 + 1 
2aff .. 00			db "-!",0              
2b02				endm 
# End of macro CWHEAD
2b02			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2b02					if DEBUG_FORTH_WORDS_KEY 
2b02						DMARK "-s_" 
2b02 f5				push af  
2b03 3a 17 2b			ld a, (.dmark)  
2b06 32 7a ee			ld (debug_mark),a  
2b09 3a 18 2b			ld a, (.dmark+1)  
2b0c 32 7b ee			ld (debug_mark+1),a  
2b0f 3a 19 2b			ld a, (.dmark+2)  
2b12 32 7c ee			ld (debug_mark+2),a  
2b15 18 03			jr .pastdmark  
2b17 ..			.dmark: db "-s_"  
2b1a f1			.pastdmark: pop af  
2b1b			endm  
# End of macro DMARK
2b1b						CALLMONITOR 
2b1b cd ff 13			call break_point_state  
2b1e				endm  
# End of macro CALLMONITOR
2b1e					endif 
2b1e			 
2b1e					FORTH_DSP_VALUEHL 
2b1e cd 83 1b			call macro_dsp_valuehl 
2b21				endm 
# End of macro FORTH_DSP_VALUEHL
2b21			 
2b21 e5					push hl   ; save address 
2b22			 
2b22					FORTH_DSP_POP 
2b22 cd 3b 1c			call macro_forth_dsp_pop 
2b25				endm 
# End of macro FORTH_DSP_POP
2b25			 
2b25					FORTH_DSP_VALUEHL 
2b25 cd 83 1b			call macro_dsp_valuehl 
2b28				endm 
# End of macro FORTH_DSP_VALUEHL
2b28			 
2b28					; hl contains value to add to byte at a 
2b28				 
2b28 eb					ex de, hl 
2b29			 
2b29 e1					pop hl 
2b2a			 
2b2a					if DEBUG_FORTH_WORDS 
2b2a						DMARK "DEC" 
2b2a f5				push af  
2b2b 3a 3f 2b			ld a, (.dmark)  
2b2e 32 7a ee			ld (debug_mark),a  
2b31 3a 40 2b			ld a, (.dmark+1)  
2b34 32 7b ee			ld (debug_mark+1),a  
2b37 3a 41 2b			ld a, (.dmark+2)  
2b3a 32 7c ee			ld (debug_mark+2),a  
2b3d 18 03			jr .pastdmark  
2b3f ..			.dmark: db "DEC"  
2b42 f1			.pastdmark: pop af  
2b43			endm  
# End of macro DMARK
2b43						CALLMONITOR 
2b43 cd ff 13			call break_point_state  
2b46				endm  
# End of macro CALLMONITOR
2b46					endif 
2b46			 
2b46 7e					ld a,(hl) 
2b47 93					sub e 
2b48 77					ld (hl),a 
2b49			 
2b49			 
2b49			 
2b49				       NEXTW 
2b49 c3 f5 1c			jp macro_next 
2b4c				endm 
# End of macro NEXTW
2b4c			 
2b4c			.INC2: 
2b4c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2b4c 6f				db WORD_SYS_CORE+91             
2b4d f6 2b			dw .DEC2            
2b4f 04				db 3 + 1 
2b50 .. 00			db "+2!",0              
2b54				endm 
# End of macro CWHEAD
2b54			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2b54			 
2b54					if DEBUG_FORTH_WORDS_KEY 
2b54						DMARK "+2s" 
2b54 f5				push af  
2b55 3a 69 2b			ld a, (.dmark)  
2b58 32 7a ee			ld (debug_mark),a  
2b5b 3a 6a 2b			ld a, (.dmark+1)  
2b5e 32 7b ee			ld (debug_mark+1),a  
2b61 3a 6b 2b			ld a, (.dmark+2)  
2b64 32 7c ee			ld (debug_mark+2),a  
2b67 18 03			jr .pastdmark  
2b69 ..			.dmark: db "+2s"  
2b6c f1			.pastdmark: pop af  
2b6d			endm  
# End of macro DMARK
2b6d						CALLMONITOR 
2b6d cd ff 13			call break_point_state  
2b70				endm  
# End of macro CALLMONITOR
2b70					endif 
2b70			 
2b70					; Address 
2b70			 
2b70					FORTH_DSP_VALUEHL 
2b70 cd 83 1b			call macro_dsp_valuehl 
2b73				endm 
# End of macro FORTH_DSP_VALUEHL
2b73			 
2b73 e5					push hl    ; save address 
2b74			 
2b74					; load content into de 
2b74			 
2b74 5e					ld e,(hl) 
2b75 23					inc hl 
2b76 56					ld d, (hl) 
2b77			 
2b77					if DEBUG_FORTH_WORDS 
2b77						DMARK "+2a" 
2b77 f5				push af  
2b78 3a 8c 2b			ld a, (.dmark)  
2b7b 32 7a ee			ld (debug_mark),a  
2b7e 3a 8d 2b			ld a, (.dmark+1)  
2b81 32 7b ee			ld (debug_mark+1),a  
2b84 3a 8e 2b			ld a, (.dmark+2)  
2b87 32 7c ee			ld (debug_mark+2),a  
2b8a 18 03			jr .pastdmark  
2b8c ..			.dmark: db "+2a"  
2b8f f1			.pastdmark: pop af  
2b90			endm  
# End of macro DMARK
2b90						CALLMONITOR 
2b90 cd ff 13			call break_point_state  
2b93				endm  
# End of macro CALLMONITOR
2b93					endif 
2b93			 
2b93					FORTH_DSP_POP 
2b93 cd 3b 1c			call macro_forth_dsp_pop 
2b96				endm 
# End of macro FORTH_DSP_POP
2b96			 
2b96					; Get value to add 
2b96			 
2b96					FORTH_DSP_VALUE 
2b96 cd 6c 1b			call macro_forth_dsp_value 
2b99				endm 
# End of macro FORTH_DSP_VALUE
2b99			 
2b99					if DEBUG_FORTH_WORDS 
2b99						DMARK "+2v" 
2b99 f5				push af  
2b9a 3a ae 2b			ld a, (.dmark)  
2b9d 32 7a ee			ld (debug_mark),a  
2ba0 3a af 2b			ld a, (.dmark+1)  
2ba3 32 7b ee			ld (debug_mark+1),a  
2ba6 3a b0 2b			ld a, (.dmark+2)  
2ba9 32 7c ee			ld (debug_mark+2),a  
2bac 18 03			jr .pastdmark  
2bae ..			.dmark: db "+2v"  
2bb1 f1			.pastdmark: pop af  
2bb2			endm  
# End of macro DMARK
2bb2						CALLMONITOR 
2bb2 cd ff 13			call break_point_state  
2bb5				endm  
# End of macro CALLMONITOR
2bb5					endif 
2bb5			 
2bb5 19					add hl, de 
2bb6			 
2bb6					if DEBUG_FORTH_WORDS 
2bb6						DMARK "+2+" 
2bb6 f5				push af  
2bb7 3a cb 2b			ld a, (.dmark)  
2bba 32 7a ee			ld (debug_mark),a  
2bbd 3a cc 2b			ld a, (.dmark+1)  
2bc0 32 7b ee			ld (debug_mark+1),a  
2bc3 3a cd 2b			ld a, (.dmark+2)  
2bc6 32 7c ee			ld (debug_mark+2),a  
2bc9 18 03			jr .pastdmark  
2bcb ..			.dmark: db "+2+"  
2bce f1			.pastdmark: pop af  
2bcf			endm  
# End of macro DMARK
2bcf						CALLMONITOR 
2bcf cd ff 13			call break_point_state  
2bd2				endm  
# End of macro CALLMONITOR
2bd2					endif 
2bd2			 
2bd2					; move result to de 
2bd2			 
2bd2 eb					ex de, hl 
2bd3			 
2bd3					; Address 
2bd3			 
2bd3 e1					pop hl 
2bd4			 
2bd4					; save it back 
2bd4			 
2bd4 73					ld (hl), e 
2bd5 23					inc hl 
2bd6 72					ld (hl), d 
2bd7			 
2bd7					if DEBUG_FORTH_WORDS 
2bd7						DMARK "+2e" 
2bd7 f5				push af  
2bd8 3a ec 2b			ld a, (.dmark)  
2bdb 32 7a ee			ld (debug_mark),a  
2bde 3a ed 2b			ld a, (.dmark+1)  
2be1 32 7b ee			ld (debug_mark+1),a  
2be4 3a ee 2b			ld a, (.dmark+2)  
2be7 32 7c ee			ld (debug_mark+2),a  
2bea 18 03			jr .pastdmark  
2bec ..			.dmark: db "+2e"  
2bef f1			.pastdmark: pop af  
2bf0			endm  
# End of macro DMARK
2bf0						CALLMONITOR 
2bf0 cd ff 13			call break_point_state  
2bf3				endm  
# End of macro CALLMONITOR
2bf3					endif 
2bf3			 
2bf3			 
2bf3			 
2bf3			 
2bf3			 
2bf3				       NEXTW 
2bf3 c3 f5 1c			jp macro_next 
2bf6				endm 
# End of macro NEXTW
2bf6			 
2bf6			.DEC2: 
2bf6				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2bf6 6f				db WORD_SYS_CORE+91             
2bf7 a2 2c			dw .GET2            
2bf9 04				db 3 + 1 
2bfa .. 00			db "-2!",0              
2bfe				endm 
# End of macro CWHEAD
2bfe			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2bfe			 
2bfe			 
2bfe					if DEBUG_FORTH_WORDS_KEY 
2bfe						DMARK "-2s" 
2bfe f5				push af  
2bff 3a 13 2c			ld a, (.dmark)  
2c02 32 7a ee			ld (debug_mark),a  
2c05 3a 14 2c			ld a, (.dmark+1)  
2c08 32 7b ee			ld (debug_mark+1),a  
2c0b 3a 15 2c			ld a, (.dmark+2)  
2c0e 32 7c ee			ld (debug_mark+2),a  
2c11 18 03			jr .pastdmark  
2c13 ..			.dmark: db "-2s"  
2c16 f1			.pastdmark: pop af  
2c17			endm  
# End of macro DMARK
2c17						CALLMONITOR 
2c17 cd ff 13			call break_point_state  
2c1a				endm  
# End of macro CALLMONITOR
2c1a					endif 
2c1a			 
2c1a					; Address 
2c1a			 
2c1a					FORTH_DSP_VALUEHL 
2c1a cd 83 1b			call macro_dsp_valuehl 
2c1d				endm 
# End of macro FORTH_DSP_VALUEHL
2c1d			 
2c1d e5					push hl    ; save address 
2c1e			 
2c1e					; load content into de 
2c1e			 
2c1e 5e					ld e,(hl) 
2c1f 23					inc hl 
2c20 56					ld d, (hl) 
2c21			 
2c21					if DEBUG_FORTH_WORDS 
2c21						DMARK "-2a" 
2c21 f5				push af  
2c22 3a 36 2c			ld a, (.dmark)  
2c25 32 7a ee			ld (debug_mark),a  
2c28 3a 37 2c			ld a, (.dmark+1)  
2c2b 32 7b ee			ld (debug_mark+1),a  
2c2e 3a 38 2c			ld a, (.dmark+2)  
2c31 32 7c ee			ld (debug_mark+2),a  
2c34 18 03			jr .pastdmark  
2c36 ..			.dmark: db "-2a"  
2c39 f1			.pastdmark: pop af  
2c3a			endm  
# End of macro DMARK
2c3a						CALLMONITOR 
2c3a cd ff 13			call break_point_state  
2c3d				endm  
# End of macro CALLMONITOR
2c3d					endif 
2c3d			 
2c3d					FORTH_DSP_POP 
2c3d cd 3b 1c			call macro_forth_dsp_pop 
2c40				endm 
# End of macro FORTH_DSP_POP
2c40			 
2c40					; Get value to remove 
2c40			 
2c40					FORTH_DSP_VALUE 
2c40 cd 6c 1b			call macro_forth_dsp_value 
2c43				endm 
# End of macro FORTH_DSP_VALUE
2c43			 
2c43					if DEBUG_FORTH_WORDS 
2c43						DMARK "-2v" 
2c43 f5				push af  
2c44 3a 58 2c			ld a, (.dmark)  
2c47 32 7a ee			ld (debug_mark),a  
2c4a 3a 59 2c			ld a, (.dmark+1)  
2c4d 32 7b ee			ld (debug_mark+1),a  
2c50 3a 5a 2c			ld a, (.dmark+2)  
2c53 32 7c ee			ld (debug_mark+2),a  
2c56 18 03			jr .pastdmark  
2c58 ..			.dmark: db "-2v"  
2c5b f1			.pastdmark: pop af  
2c5c			endm  
# End of macro DMARK
2c5c						CALLMONITOR 
2c5c cd ff 13			call break_point_state  
2c5f				endm  
# End of macro CALLMONITOR
2c5f					endif 
2c5f			 
2c5f eb					ex de, hl 
2c60 ed 52				sbc hl, de 
2c62			 
2c62					if DEBUG_FORTH_WORDS 
2c62						DMARK "-2d" 
2c62 f5				push af  
2c63 3a 77 2c			ld a, (.dmark)  
2c66 32 7a ee			ld (debug_mark),a  
2c69 3a 78 2c			ld a, (.dmark+1)  
2c6c 32 7b ee			ld (debug_mark+1),a  
2c6f 3a 79 2c			ld a, (.dmark+2)  
2c72 32 7c ee			ld (debug_mark+2),a  
2c75 18 03			jr .pastdmark  
2c77 ..			.dmark: db "-2d"  
2c7a f1			.pastdmark: pop af  
2c7b			endm  
# End of macro DMARK
2c7b						CALLMONITOR 
2c7b cd ff 13			call break_point_state  
2c7e				endm  
# End of macro CALLMONITOR
2c7e					endif 
2c7e			 
2c7e					; move result to de 
2c7e			 
2c7e eb					ex de, hl 
2c7f			 
2c7f					; Address 
2c7f			 
2c7f e1					pop hl 
2c80			 
2c80					; save it back 
2c80			 
2c80 73					ld (hl), e 
2c81 23					inc hl 
2c82 72					ld (hl), d 
2c83			 
2c83					if DEBUG_FORTH_WORDS 
2c83						DMARK "-2e" 
2c83 f5				push af  
2c84 3a 98 2c			ld a, (.dmark)  
2c87 32 7a ee			ld (debug_mark),a  
2c8a 3a 99 2c			ld a, (.dmark+1)  
2c8d 32 7b ee			ld (debug_mark+1),a  
2c90 3a 9a 2c			ld a, (.dmark+2)  
2c93 32 7c ee			ld (debug_mark+2),a  
2c96 18 03			jr .pastdmark  
2c98 ..			.dmark: db "-2e"  
2c9b f1			.pastdmark: pop af  
2c9c			endm  
# End of macro DMARK
2c9c						CALLMONITOR 
2c9c cd ff 13			call break_point_state  
2c9f				endm  
# End of macro CALLMONITOR
2c9f					endif 
2c9f			 
2c9f			 
2c9f			 
2c9f			 
2c9f			 
2c9f				       NEXTW 
2c9f c3 f5 1c			jp macro_next 
2ca2				endm 
# End of macro NEXTW
2ca2			.GET2: 
2ca2				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2ca2 6f				db WORD_SYS_CORE+91             
2ca3 d2 2c			dw .BANG2            
2ca5 03				db 2 + 1 
2ca6 .. 00			db "2@",0              
2ca9				endm 
# End of macro CWHEAD
2ca9			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ca9					if DEBUG_FORTH_WORDS_KEY 
2ca9						DMARK "2A_" 
2ca9 f5				push af  
2caa 3a be 2c			ld a, (.dmark)  
2cad 32 7a ee			ld (debug_mark),a  
2cb0 3a bf 2c			ld a, (.dmark+1)  
2cb3 32 7b ee			ld (debug_mark+1),a  
2cb6 3a c0 2c			ld a, (.dmark+2)  
2cb9 32 7c ee			ld (debug_mark+2),a  
2cbc 18 03			jr .pastdmark  
2cbe ..			.dmark: db "2A_"  
2cc1 f1			.pastdmark: pop af  
2cc2			endm  
# End of macro DMARK
2cc2						CALLMONITOR 
2cc2 cd ff 13			call break_point_state  
2cc5				endm  
# End of macro CALLMONITOR
2cc5					endif 
2cc5			 
2cc5					FORTH_DSP_VALUEHL 
2cc5 cd 83 1b			call macro_dsp_valuehl 
2cc8				endm 
# End of macro FORTH_DSP_VALUEHL
2cc8			 
2cc8 5e					ld e, (hl) 
2cc9 23					inc hl 
2cca 56					ld d, (hl) 
2ccb			 
2ccb eb					ex de, hl 
2ccc			 
2ccc cd 8c 19				call forth_push_numhl 
2ccf			 
2ccf				       NEXTW 
2ccf c3 f5 1c			jp macro_next 
2cd2				endm 
# End of macro NEXTW
2cd2			.BANG2: 
2cd2				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2cd2 6f				db WORD_SYS_CORE+91             
2cd3 0a 2d			dw .CONFIG            
2cd5 03				db 2 + 1 
2cd6 .. 00			db "2!",0              
2cd9				endm 
# End of macro CWHEAD
2cd9			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2cd9					if DEBUG_FORTH_WORDS_KEY 
2cd9						DMARK "2S_" 
2cd9 f5				push af  
2cda 3a ee 2c			ld a, (.dmark)  
2cdd 32 7a ee			ld (debug_mark),a  
2ce0 3a ef 2c			ld a, (.dmark+1)  
2ce3 32 7b ee			ld (debug_mark+1),a  
2ce6 3a f0 2c			ld a, (.dmark+2)  
2ce9 32 7c ee			ld (debug_mark+2),a  
2cec 18 03			jr .pastdmark  
2cee ..			.dmark: db "2S_"  
2cf1 f1			.pastdmark: pop af  
2cf2			endm  
# End of macro DMARK
2cf2						CALLMONITOR 
2cf2 cd ff 13			call break_point_state  
2cf5				endm  
# End of macro CALLMONITOR
2cf5					endif 
2cf5			 
2cf5					FORTH_DSP_VALUEHL 
2cf5 cd 83 1b			call macro_dsp_valuehl 
2cf8				endm 
# End of macro FORTH_DSP_VALUEHL
2cf8			 
2cf8 e5					push hl   ; save address 
2cf9			 
2cf9			 
2cf9					FORTH_DSP_POP 
2cf9 cd 3b 1c			call macro_forth_dsp_pop 
2cfc				endm 
# End of macro FORTH_DSP_POP
2cfc			 
2cfc					 
2cfc					FORTH_DSP_VALUEHL 
2cfc cd 83 1b			call macro_dsp_valuehl 
2cff				endm 
# End of macro FORTH_DSP_VALUEHL
2cff			 
2cff					FORTH_DSP_POP 
2cff cd 3b 1c			call macro_forth_dsp_pop 
2d02				endm 
# End of macro FORTH_DSP_POP
2d02			 
2d02 eb					ex de, hl    ; value now in de 
2d03			 
2d03 e1					pop hl 
2d04			 
2d04 73					ld (hl), e 
2d05			 
2d05 23					inc hl 
2d06			 
2d06 72					ld (hl), d 
2d07			 
2d07			 
2d07				       NEXTW 
2d07 c3 f5 1c			jp macro_next 
2d0a				endm 
# End of macro NEXTW
2d0a			.CONFIG: 
2d0a				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2d0a 6f				db WORD_SYS_CORE+91             
2d0b 1b 2d			dw .ENDCORE            
2d0d 07				db 6 + 1 
2d0e .. 00			db "CONFIG",0              
2d15				endm 
# End of macro CWHEAD
2d15			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2d15			 
2d15 cd 12 12				call config 
2d18					NEXTW 
2d18 c3 f5 1c			jp macro_next 
2d1b				endm 
# End of macro NEXTW
2d1b			.ENDCORE: 
2d1b			 
2d1b			; eof 
2d1b			 
2d1b			 
# End of file forth_words_core.asm
2d1b			include "forth_words_flow.asm" 
2d1b			 
2d1b			; | ## Program Flow Words 
2d1b			 
2d1b			.IF: 
2d1b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2d1b 1e				db WORD_SYS_CORE+10             
2d1c 10 2e			dw .THEN            
2d1e 03				db 2 + 1 
2d1f .. 00			db "IF",0              
2d22				endm 
# End of macro CWHEAD
2d22			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2d22			; 
2d22					if DEBUG_FORTH_WORDS_KEY 
2d22						DMARK "IF." 
2d22 f5				push af  
2d23 3a 37 2d			ld a, (.dmark)  
2d26 32 7a ee			ld (debug_mark),a  
2d29 3a 38 2d			ld a, (.dmark+1)  
2d2c 32 7b ee			ld (debug_mark+1),a  
2d2f 3a 39 2d			ld a, (.dmark+2)  
2d32 32 7c ee			ld (debug_mark+2),a  
2d35 18 03			jr .pastdmark  
2d37 ..			.dmark: db "IF."  
2d3a f1			.pastdmark: pop af  
2d3b			endm  
# End of macro DMARK
2d3b						CALLMONITOR 
2d3b cd ff 13			call break_point_state  
2d3e				endm  
# End of macro CALLMONITOR
2d3e					endif 
2d3e			; eval TOS 
2d3e			 
2d3e				FORTH_DSP_VALUEHL 
2d3e cd 83 1b			call macro_dsp_valuehl 
2d41				endm 
# End of macro FORTH_DSP_VALUEHL
2d41			 
2d41			;	push hl 
2d41				FORTH_DSP_POP 
2d41 cd 3b 1c			call macro_forth_dsp_pop 
2d44				endm 
# End of macro FORTH_DSP_POP
2d44			;	pop hl 
2d44			 
2d44					if DEBUG_FORTH_WORDS 
2d44						DMARK "IF1" 
2d44 f5				push af  
2d45 3a 59 2d			ld a, (.dmark)  
2d48 32 7a ee			ld (debug_mark),a  
2d4b 3a 5a 2d			ld a, (.dmark+1)  
2d4e 32 7b ee			ld (debug_mark+1),a  
2d51 3a 5b 2d			ld a, (.dmark+2)  
2d54 32 7c ee			ld (debug_mark+2),a  
2d57 18 03			jr .pastdmark  
2d59 ..			.dmark: db "IF1"  
2d5c f1			.pastdmark: pop af  
2d5d			endm  
# End of macro DMARK
2d5d						CALLMONITOR 
2d5d cd ff 13			call break_point_state  
2d60				endm  
# End of macro CALLMONITOR
2d60					endif 
2d60 b7				or a        ; clear carry flag 
2d61 11 00 00			ld de, 0 
2d64 eb				ex de,hl 
2d65 ed 52			sbc hl, de 
2d67 c2 f1 2d			jp nz, .iftrue 
2d6a			 
2d6a					if DEBUG_FORTH_WORDS 
2d6a						DMARK "IF2" 
2d6a f5				push af  
2d6b 3a 7f 2d			ld a, (.dmark)  
2d6e 32 7a ee			ld (debug_mark),a  
2d71 3a 80 2d			ld a, (.dmark+1)  
2d74 32 7b ee			ld (debug_mark+1),a  
2d77 3a 81 2d			ld a, (.dmark+2)  
2d7a 32 7c ee			ld (debug_mark+2),a  
2d7d 18 03			jr .pastdmark  
2d7f ..			.dmark: db "IF2"  
2d82 f1			.pastdmark: pop af  
2d83			endm  
# End of macro DMARK
2d83						CALLMONITOR 
2d83 cd ff 13			call break_point_state  
2d86				endm  
# End of macro CALLMONITOR
2d86					endif 
2d86			 
2d86			; if not true then skip to THEN 
2d86			 
2d86				; TODO get tok_ptr 
2d86				; TODO consume toks until we get to THEN 
2d86			 
2d86 2a 61 e6			ld hl, (os_tok_ptr) 
2d89					if DEBUG_FORTH_WORDS 
2d89						DMARK "IF3" 
2d89 f5				push af  
2d8a 3a 9e 2d			ld a, (.dmark)  
2d8d 32 7a ee			ld (debug_mark),a  
2d90 3a 9f 2d			ld a, (.dmark+1)  
2d93 32 7b ee			ld (debug_mark+1),a  
2d96 3a a0 2d			ld a, (.dmark+2)  
2d99 32 7c ee			ld (debug_mark+2),a  
2d9c 18 03			jr .pastdmark  
2d9e ..			.dmark: db "IF3"  
2da1 f1			.pastdmark: pop af  
2da2			endm  
# End of macro DMARK
2da2						CALLMONITOR 
2da2 cd ff 13			call break_point_state  
2da5				endm  
# End of macro CALLMONITOR
2da5						 
2da5					endif 
2da5 11 ec 2d			ld de, .ifthen 
2da8					if DEBUG_FORTH_WORDS 
2da8						DMARK "IF4" 
2da8 f5				push af  
2da9 3a bd 2d			ld a, (.dmark)  
2dac 32 7a ee			ld (debug_mark),a  
2daf 3a be 2d			ld a, (.dmark+1)  
2db2 32 7b ee			ld (debug_mark+1),a  
2db5 3a bf 2d			ld a, (.dmark+2)  
2db8 32 7c ee			ld (debug_mark+2),a  
2dbb 18 03			jr .pastdmark  
2dbd ..			.dmark: db "IF4"  
2dc0 f1			.pastdmark: pop af  
2dc1			endm  
# End of macro DMARK
2dc1						CALLMONITOR 
2dc1 cd ff 13			call break_point_state  
2dc4				endm  
# End of macro CALLMONITOR
2dc4					endif 
2dc4 cd 10 1e			call findnexttok  
2dc7			 
2dc7					if DEBUG_FORTH_WORDS 
2dc7						DMARK "IF5" 
2dc7 f5				push af  
2dc8 3a dc 2d			ld a, (.dmark)  
2dcb 32 7a ee			ld (debug_mark),a  
2dce 3a dd 2d			ld a, (.dmark+1)  
2dd1 32 7b ee			ld (debug_mark+1),a  
2dd4 3a de 2d			ld a, (.dmark+2)  
2dd7 32 7c ee			ld (debug_mark+2),a  
2dda 18 03			jr .pastdmark  
2ddc ..			.dmark: db "IF5"  
2ddf f1			.pastdmark: pop af  
2de0			endm  
# End of macro DMARK
2de0						CALLMONITOR 
2de0 cd ff 13			call break_point_state  
2de3				endm  
# End of macro CALLMONITOR
2de3					endif 
2de3				; TODO replace below with ; exec using tok_ptr 
2de3 22 61 e6			ld (os_tok_ptr), hl 
2de6 c3 86 1d			jp exec1 
2de9				NEXTW 
2de9 c3 f5 1c			jp macro_next 
2dec				endm 
# End of macro NEXTW
2dec			 
2dec .. 00		.ifthen:  db "THEN",0 
2df1			 
2df1			.iftrue:		 
2df1				; Exec next words normally 
2df1			 
2df1				; if true then exec following IF as normal 
2df1					if DEBUG_FORTH_WORDS 
2df1						DMARK "IFT" 
2df1 f5				push af  
2df2 3a 06 2e			ld a, (.dmark)  
2df5 32 7a ee			ld (debug_mark),a  
2df8 3a 07 2e			ld a, (.dmark+1)  
2dfb 32 7b ee			ld (debug_mark+1),a  
2dfe 3a 08 2e			ld a, (.dmark+2)  
2e01 32 7c ee			ld (debug_mark+2),a  
2e04 18 03			jr .pastdmark  
2e06 ..			.dmark: db "IFT"  
2e09 f1			.pastdmark: pop af  
2e0a			endm  
# End of macro DMARK
2e0a						CALLMONITOR 
2e0a cd ff 13			call break_point_state  
2e0d				endm  
# End of macro CALLMONITOR
2e0d					endif 
2e0d			 
2e0d					NEXTW 
2e0d c3 f5 1c			jp macro_next 
2e10				endm 
# End of macro NEXTW
2e10			.THEN: 
2e10				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2e10 1f				db WORD_SYS_CORE+11             
2e11 38 2e			dw .ELSE            
2e13 05				db 4 + 1 
2e14 .. 00			db "THEN",0              
2e19				endm 
# End of macro CWHEAD
2e19			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2e19					if DEBUG_FORTH_WORDS_KEY 
2e19						DMARK "THN" 
2e19 f5				push af  
2e1a 3a 2e 2e			ld a, (.dmark)  
2e1d 32 7a ee			ld (debug_mark),a  
2e20 3a 2f 2e			ld a, (.dmark+1)  
2e23 32 7b ee			ld (debug_mark+1),a  
2e26 3a 30 2e			ld a, (.dmark+2)  
2e29 32 7c ee			ld (debug_mark+2),a  
2e2c 18 03			jr .pastdmark  
2e2e ..			.dmark: db "THN"  
2e31 f1			.pastdmark: pop af  
2e32			endm  
# End of macro DMARK
2e32						CALLMONITOR 
2e32 cd ff 13			call break_point_state  
2e35				endm  
# End of macro CALLMONITOR
2e35					endif 
2e35					NEXTW 
2e35 c3 f5 1c			jp macro_next 
2e38				endm 
# End of macro NEXTW
2e38			.ELSE: 
2e38				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2e38 20				db WORD_SYS_CORE+12             
2e39 60 2e			dw .DO            
2e3b 03				db 2 + 1 
2e3c .. 00			db "ELSE",0              
2e41				endm 
# End of macro CWHEAD
2e41			; | ELSE ( -- ) Not supported - does nothing | TODO 
2e41			 
2e41					if DEBUG_FORTH_WORDS_KEY 
2e41						DMARK "ELS" 
2e41 f5				push af  
2e42 3a 56 2e			ld a, (.dmark)  
2e45 32 7a ee			ld (debug_mark),a  
2e48 3a 57 2e			ld a, (.dmark+1)  
2e4b 32 7b ee			ld (debug_mark+1),a  
2e4e 3a 58 2e			ld a, (.dmark+2)  
2e51 32 7c ee			ld (debug_mark+2),a  
2e54 18 03			jr .pastdmark  
2e56 ..			.dmark: db "ELS"  
2e59 f1			.pastdmark: pop af  
2e5a			endm  
# End of macro DMARK
2e5a						CALLMONITOR 
2e5a cd ff 13			call break_point_state  
2e5d				endm  
# End of macro CALLMONITOR
2e5d					endif 
2e5d			 
2e5d			 
2e5d					NEXTW 
2e5d c3 f5 1c			jp macro_next 
2e60				endm 
# End of macro NEXTW
2e60			.DO: 
2e60				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2e60 21				db WORD_SYS_CORE+13             
2e61 87 2f			dw .LOOP            
2e63 03				db 2 + 1 
2e64 .. 00			db "DO",0              
2e67				endm 
# End of macro CWHEAD
2e67			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2e67			 
2e67					if DEBUG_FORTH_WORDS_KEY 
2e67						DMARK "DO." 
2e67 f5				push af  
2e68 3a 7c 2e			ld a, (.dmark)  
2e6b 32 7a ee			ld (debug_mark),a  
2e6e 3a 7d 2e			ld a, (.dmark+1)  
2e71 32 7b ee			ld (debug_mark+1),a  
2e74 3a 7e 2e			ld a, (.dmark+2)  
2e77 32 7c ee			ld (debug_mark+2),a  
2e7a 18 03			jr .pastdmark  
2e7c ..			.dmark: db "DO."  
2e7f f1			.pastdmark: pop af  
2e80			endm  
# End of macro DMARK
2e80						CALLMONITOR 
2e80 cd ff 13			call break_point_state  
2e83				endm  
# End of macro CALLMONITOR
2e83					endif 
2e83			;  push pc to rsp stack past the DO 
2e83			 
2e83 2a 61 e6				ld hl, (os_tok_ptr) 
2e86 23					inc hl   ; D 
2e87 23					inc hl  ; O 
2e88 23					inc hl   ; null 
2e89					if DEBUG_FORTH_WORDS 
2e89						DMARK "DO2" 
2e89 f5				push af  
2e8a 3a 9e 2e			ld a, (.dmark)  
2e8d 32 7a ee			ld (debug_mark),a  
2e90 3a 9f 2e			ld a, (.dmark+1)  
2e93 32 7b ee			ld (debug_mark+1),a  
2e96 3a a0 2e			ld a, (.dmark+2)  
2e99 32 7c ee			ld (debug_mark+2),a  
2e9c 18 03			jr .pastdmark  
2e9e ..			.dmark: db "DO2"  
2ea1 f1			.pastdmark: pop af  
2ea2			endm  
# End of macro DMARK
2ea2						CALLMONITOR 
2ea2 cd ff 13			call break_point_state  
2ea5				endm  
# End of macro CALLMONITOR
2ea5					endif 
2ea5					FORTH_RSP_NEXT 
2ea5 cd 33 19			call macro_forth_rsp_next 
2ea8				endm 
# End of macro FORTH_RSP_NEXT
2ea8					if DEBUG_FORTH_WORDS 
2ea8						DMARK "DO3" 
2ea8 f5				push af  
2ea9 3a bd 2e			ld a, (.dmark)  
2eac 32 7a ee			ld (debug_mark),a  
2eaf 3a be 2e			ld a, (.dmark+1)  
2eb2 32 7b ee			ld (debug_mark+1),a  
2eb5 3a bf 2e			ld a, (.dmark+2)  
2eb8 32 7c ee			ld (debug_mark+2),a  
2ebb 18 03			jr .pastdmark  
2ebd ..			.dmark: db "DO3"  
2ec0 f1			.pastdmark: pop af  
2ec1			endm  
# End of macro DMARK
2ec1						CALLMONITOR 
2ec1 cd ff 13			call break_point_state  
2ec4				endm  
# End of macro CALLMONITOR
2ec4					endif 
2ec4			 
2ec4					;if DEBUG_FORTH_WORDS 
2ec4				;		push hl 
2ec4			;		endif  
2ec4			 
2ec4			; get counters from data stack 
2ec4			 
2ec4			 
2ec4					FORTH_DSP_VALUEHL 
2ec4 cd 83 1b			call macro_dsp_valuehl 
2ec7				endm 
# End of macro FORTH_DSP_VALUEHL
2ec7 e5					push hl		 ; hl now has starting counter which needs to be tos 
2ec8			 
2ec8					if DEBUG_FORTH_WORDS 
2ec8						DMARK "DO4" 
2ec8 f5				push af  
2ec9 3a dd 2e			ld a, (.dmark)  
2ecc 32 7a ee			ld (debug_mark),a  
2ecf 3a de 2e			ld a, (.dmark+1)  
2ed2 32 7b ee			ld (debug_mark+1),a  
2ed5 3a df 2e			ld a, (.dmark+2)  
2ed8 32 7c ee			ld (debug_mark+2),a  
2edb 18 03			jr .pastdmark  
2edd ..			.dmark: db "DO4"  
2ee0 f1			.pastdmark: pop af  
2ee1			endm  
# End of macro DMARK
2ee1						CALLMONITOR 
2ee1 cd ff 13			call break_point_state  
2ee4				endm  
# End of macro CALLMONITOR
2ee4					endif 
2ee4					FORTH_DSP_POP 
2ee4 cd 3b 1c			call macro_forth_dsp_pop 
2ee7				endm 
# End of macro FORTH_DSP_POP
2ee7			 
2ee7					if DEBUG_FORTH_WORDS 
2ee7						DMARK "DO5" 
2ee7 f5				push af  
2ee8 3a fc 2e			ld a, (.dmark)  
2eeb 32 7a ee			ld (debug_mark),a  
2eee 3a fd 2e			ld a, (.dmark+1)  
2ef1 32 7b ee			ld (debug_mark+1),a  
2ef4 3a fe 2e			ld a, (.dmark+2)  
2ef7 32 7c ee			ld (debug_mark+2),a  
2efa 18 03			jr .pastdmark  
2efc ..			.dmark: db "DO5"  
2eff f1			.pastdmark: pop af  
2f00			endm  
# End of macro DMARK
2f00						CALLMONITOR 
2f00 cd ff 13			call break_point_state  
2f03				endm  
# End of macro CALLMONITOR
2f03					endif 
2f03			 
2f03					FORTH_DSP_VALUEHL 
2f03 cd 83 1b			call macro_dsp_valuehl 
2f06				endm 
# End of macro FORTH_DSP_VALUEHL
2f06			;		push hl		 ; hl now has starting limit counter 
2f06			 
2f06					if DEBUG_FORTH_WORDS 
2f06						DMARK "DO6" 
2f06 f5				push af  
2f07 3a 1b 2f			ld a, (.dmark)  
2f0a 32 7a ee			ld (debug_mark),a  
2f0d 3a 1c 2f			ld a, (.dmark+1)  
2f10 32 7b ee			ld (debug_mark+1),a  
2f13 3a 1d 2f			ld a, (.dmark+2)  
2f16 32 7c ee			ld (debug_mark+2),a  
2f19 18 03			jr .pastdmark  
2f1b ..			.dmark: db "DO6"  
2f1e f1			.pastdmark: pop af  
2f1f			endm  
# End of macro DMARK
2f1f						CALLMONITOR 
2f1f cd ff 13			call break_point_state  
2f22				endm  
# End of macro CALLMONITOR
2f22					endif 
2f22					FORTH_DSP_POP 
2f22 cd 3b 1c			call macro_forth_dsp_pop 
2f25				endm 
# End of macro FORTH_DSP_POP
2f25			 
2f25			; put counters on the loop stack 
2f25			 
2f25			;		pop hl			 ; limit counter 
2f25 d1					pop de			; start counter 
2f26			 
2f26					; push limit counter 
2f26			 
2f26					if DEBUG_FORTH_WORDS 
2f26						DMARK "DO7" 
2f26 f5				push af  
2f27 3a 3b 2f			ld a, (.dmark)  
2f2a 32 7a ee			ld (debug_mark),a  
2f2d 3a 3c 2f			ld a, (.dmark+1)  
2f30 32 7b ee			ld (debug_mark+1),a  
2f33 3a 3d 2f			ld a, (.dmark+2)  
2f36 32 7c ee			ld (debug_mark+2),a  
2f39 18 03			jr .pastdmark  
2f3b ..			.dmark: db "DO7"  
2f3e f1			.pastdmark: pop af  
2f3f			endm  
# End of macro DMARK
2f3f						CALLMONITOR 
2f3f cd ff 13			call break_point_state  
2f42				endm  
# End of macro CALLMONITOR
2f42					endif 
2f42					FORTH_LOOP_NEXT 
2f42 cd b4 1b			call macro_forth_loop_next 
2f45				endm 
# End of macro FORTH_LOOP_NEXT
2f45			 
2f45					; push start counter 
2f45			 
2f45 eb					ex de, hl 
2f46					if DEBUG_FORTH_WORDS 
2f46						DMARK "DO7" 
2f46 f5				push af  
2f47 3a 5b 2f			ld a, (.dmark)  
2f4a 32 7a ee			ld (debug_mark),a  
2f4d 3a 5c 2f			ld a, (.dmark+1)  
2f50 32 7b ee			ld (debug_mark+1),a  
2f53 3a 5d 2f			ld a, (.dmark+2)  
2f56 32 7c ee			ld (debug_mark+2),a  
2f59 18 03			jr .pastdmark  
2f5b ..			.dmark: db "DO7"  
2f5e f1			.pastdmark: pop af  
2f5f			endm  
# End of macro DMARK
2f5f						CALLMONITOR 
2f5f cd ff 13			call break_point_state  
2f62				endm  
# End of macro CALLMONITOR
2f62					endif 
2f62					FORTH_LOOP_NEXT 
2f62 cd b4 1b			call macro_forth_loop_next 
2f65				endm 
# End of macro FORTH_LOOP_NEXT
2f65			 
2f65			 
2f65					; init first round of I counter 
2f65			 
2f65 22 85 e6				ld (os_current_i), hl 
2f68			 
2f68					if DEBUG_FORTH_WORDS 
2f68						DMARK "DO8" 
2f68 f5				push af  
2f69 3a 7d 2f			ld a, (.dmark)  
2f6c 32 7a ee			ld (debug_mark),a  
2f6f 3a 7e 2f			ld a, (.dmark+1)  
2f72 32 7b ee			ld (debug_mark+1),a  
2f75 3a 7f 2f			ld a, (.dmark+2)  
2f78 32 7c ee			ld (debug_mark+2),a  
2f7b 18 03			jr .pastdmark  
2f7d ..			.dmark: db "DO8"  
2f80 f1			.pastdmark: pop af  
2f81			endm  
# End of macro DMARK
2f81						CALLMONITOR 
2f81 cd ff 13			call break_point_state  
2f84				endm  
# End of macro CALLMONITOR
2f84					endif 
2f84			 
2f84					NEXTW 
2f84 c3 f5 1c			jp macro_next 
2f87				endm 
# End of macro NEXTW
2f87			.LOOP: 
2f87				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2f87 22				db WORD_SYS_CORE+14             
2f88 9f 30			dw .I            
2f8a 05				db 4 + 1 
2f8b .. 00			db "LOOP",0              
2f90				endm 
# End of macro CWHEAD
2f90			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2f90			 
2f90				; pop tos as current loop count to hl 
2f90			 
2f90				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f90			 
2f90				FORTH_LOOP_TOS 
2f90 cd e7 1b			call macro_forth_loop_tos 
2f93				endm 
# End of macro FORTH_LOOP_TOS
2f93 e5				push hl 
2f94			 
2f94					if DEBUG_FORTH_WORDS_KEY 
2f94						DMARK "LOP" 
2f94 f5				push af  
2f95 3a a9 2f			ld a, (.dmark)  
2f98 32 7a ee			ld (debug_mark),a  
2f9b 3a aa 2f			ld a, (.dmark+1)  
2f9e 32 7b ee			ld (debug_mark+1),a  
2fa1 3a ab 2f			ld a, (.dmark+2)  
2fa4 32 7c ee			ld (debug_mark+2),a  
2fa7 18 03			jr .pastdmark  
2fa9 ..			.dmark: db "LOP"  
2fac f1			.pastdmark: pop af  
2fad			endm  
# End of macro DMARK
2fad						CALLMONITOR 
2fad cd ff 13			call break_point_state  
2fb0				endm  
# End of macro CALLMONITOR
2fb0					endif 
2fb0				; next item on the stack is the limit. get it 
2fb0			 
2fb0			 
2fb0				FORTH_LOOP_POP 
2fb0 cd f1 1b			call macro_forth_loop_pop 
2fb3				endm 
# End of macro FORTH_LOOP_POP
2fb3			 
2fb3				FORTH_LOOP_TOS 
2fb3 cd e7 1b			call macro_forth_loop_tos 
2fb6				endm 
# End of macro FORTH_LOOP_TOS
2fb6			 
2fb6 d1				pop de		 ; de = i, hl = limit 
2fb7			 
2fb7					if DEBUG_FORTH_WORDS 
2fb7						DMARK "LP1" 
2fb7 f5				push af  
2fb8 3a cc 2f			ld a, (.dmark)  
2fbb 32 7a ee			ld (debug_mark),a  
2fbe 3a cd 2f			ld a, (.dmark+1)  
2fc1 32 7b ee			ld (debug_mark+1),a  
2fc4 3a ce 2f			ld a, (.dmark+2)  
2fc7 32 7c ee			ld (debug_mark+2),a  
2fca 18 03			jr .pastdmark  
2fcc ..			.dmark: db "LP1"  
2fcf f1			.pastdmark: pop af  
2fd0			endm  
# End of macro DMARK
2fd0						CALLMONITOR 
2fd0 cd ff 13			call break_point_state  
2fd3				endm  
# End of macro CALLMONITOR
2fd3					endif 
2fd3			 
2fd3				; go back to previous word 
2fd3			 
2fd3 d5				push de    ; save I for inc later 
2fd4			 
2fd4			 
2fd4				; get limit 
2fd4				;  is I at limit? 
2fd4			 
2fd4			 
2fd4					if DEBUG_FORTH_WORDS 
2fd4						DMARK "LP1" 
2fd4 f5				push af  
2fd5 3a e9 2f			ld a, (.dmark)  
2fd8 32 7a ee			ld (debug_mark),a  
2fdb 3a ea 2f			ld a, (.dmark+1)  
2fde 32 7b ee			ld (debug_mark+1),a  
2fe1 3a eb 2f			ld a, (.dmark+2)  
2fe4 32 7c ee			ld (debug_mark+2),a  
2fe7 18 03			jr .pastdmark  
2fe9 ..			.dmark: db "LP1"  
2fec f1			.pastdmark: pop af  
2fed			endm  
# End of macro DMARK
2fed						CALLMONITOR 
2fed cd ff 13			call break_point_state  
2ff0				endm  
# End of macro CALLMONITOR
2ff0					endif 
2ff0			 
2ff0 ed 52			sbc hl, de 
2ff2			 
2ff2			 
2ff2				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2ff2			 
2ff2 20 26				jr nz, .loopnotdone 
2ff4			 
2ff4 e1				pop hl   ; get rid of saved I 
2ff5				FORTH_LOOP_POP     ; get rid of limit 
2ff5 cd f1 1b			call macro_forth_loop_pop 
2ff8				endm 
# End of macro FORTH_LOOP_POP
2ff8			 
2ff8				FORTH_RSP_POP     ; get rid of DO ptr 
2ff8 cd 54 19			call macro_forth_rsp_pop 
2ffb				endm 
# End of macro FORTH_RSP_POP
2ffb			 
2ffb			if DEBUG_FORTH_WORDS 
2ffb						DMARK "LP>" 
2ffb f5				push af  
2ffc 3a 10 30			ld a, (.dmark)  
2fff 32 7a ee			ld (debug_mark),a  
3002 3a 11 30			ld a, (.dmark+1)  
3005 32 7b ee			ld (debug_mark+1),a  
3008 3a 12 30			ld a, (.dmark+2)  
300b 32 7c ee			ld (debug_mark+2),a  
300e 18 03			jr .pastdmark  
3010 ..			.dmark: db "LP>"  
3013 f1			.pastdmark: pop af  
3014			endm  
# End of macro DMARK
3014				CALLMONITOR 
3014 cd ff 13			call break_point_state  
3017				endm  
# End of macro CALLMONITOR
3017			endif 
3017			 
3017					NEXTW 
3017 c3 f5 1c			jp macro_next 
301a				endm 
# End of macro NEXTW
301a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
301a			 
301a			.loopnotdone: 
301a			 
301a e1				pop hl    ; get I 
301b 23				inc hl 
301c			 
301c			   	; save new I 
301c			 
301c			 
301c					; set I counter 
301c			 
301c 22 85 e6				ld (os_current_i), hl 
301f			 
301f					if DEBUG_FORTH_WORDS 
301f						DMARK "LPN" 
301f f5				push af  
3020 3a 34 30			ld a, (.dmark)  
3023 32 7a ee			ld (debug_mark),a  
3026 3a 35 30			ld a, (.dmark+1)  
3029 32 7b ee			ld (debug_mark+1),a  
302c 3a 36 30			ld a, (.dmark+2)  
302f 32 7c ee			ld (debug_mark+2),a  
3032 18 03			jr .pastdmark  
3034 ..			.dmark: db "LPN"  
3037 f1			.pastdmark: pop af  
3038			endm  
# End of macro DMARK
3038					CALLMONITOR 
3038 cd ff 13			call break_point_state  
303b				endm  
# End of macro CALLMONITOR
303b					endif 
303b					 
303b				FORTH_LOOP_NEXT 
303b cd b4 1b			call macro_forth_loop_next 
303e				endm 
# End of macro FORTH_LOOP_NEXT
303e			 
303e			 
303e					if DEBUG_FORTH_WORDS 
303e eb						ex de,hl 
303f					endif 
303f			 
303f			;	; get DO ptr 
303f			; 
303f					if DEBUG_FORTH_WORDS 
303f						DMARK "LP7" 
303f f5				push af  
3040 3a 54 30			ld a, (.dmark)  
3043 32 7a ee			ld (debug_mark),a  
3046 3a 55 30			ld a, (.dmark+1)  
3049 32 7b ee			ld (debug_mark+1),a  
304c 3a 56 30			ld a, (.dmark+2)  
304f 32 7c ee			ld (debug_mark+2),a  
3052 18 03			jr .pastdmark  
3054 ..			.dmark: db "LP7"  
3057 f1			.pastdmark: pop af  
3058			endm  
# End of macro DMARK
3058					CALLMONITOR 
3058 cd ff 13			call break_point_state  
305b				endm  
# End of macro CALLMONITOR
305b					endif 
305b				FORTH_RSP_TOS 
305b cd 4a 19			call macro_forth_rsp_tos 
305e				endm 
# End of macro FORTH_RSP_TOS
305e			 
305e					if DEBUG_FORTH_WORDS 
305e						DMARK "LP8" 
305e f5				push af  
305f 3a 73 30			ld a, (.dmark)  
3062 32 7a ee			ld (debug_mark),a  
3065 3a 74 30			ld a, (.dmark+1)  
3068 32 7b ee			ld (debug_mark+1),a  
306b 3a 75 30			ld a, (.dmark+2)  
306e 32 7c ee			ld (debug_mark+2),a  
3071 18 03			jr .pastdmark  
3073 ..			.dmark: db "LP8"  
3076 f1			.pastdmark: pop af  
3077			endm  
# End of macro DMARK
3077					CALLMONITOR 
3077 cd ff 13			call break_point_state  
307a				endm  
# End of macro CALLMONITOR
307a					endif 
307a				;push hl 
307a			 
307a				; not going to DO any more 
307a				; get rid of the RSP pointer as DO will add it back in 
307a				;FORTH_RSP_POP 
307a				;pop hl 
307a			 
307a				;ld hl,(cli_ret_sp) 
307a				;ld e, (hl) 
307a				;inc hl 
307a				;ld d, (hl) 
307a				;ex de,hl 
307a 22 61 e6			ld (os_tok_ptr), hl 
307d					if DEBUG_FORTH_WORDS 
307d						DMARK "LP<" 
307d f5				push af  
307e 3a 92 30			ld a, (.dmark)  
3081 32 7a ee			ld (debug_mark),a  
3084 3a 93 30			ld a, (.dmark+1)  
3087 32 7b ee			ld (debug_mark+1),a  
308a 3a 94 30			ld a, (.dmark+2)  
308d 32 7c ee			ld (debug_mark+2),a  
3090 18 03			jr .pastdmark  
3092 ..			.dmark: db "LP<"  
3095 f1			.pastdmark: pop af  
3096			endm  
# End of macro DMARK
3096					CALLMONITOR 
3096 cd ff 13			call break_point_state  
3099				endm  
# End of macro CALLMONITOR
3099				endif 
3099 c3 86 1d			jp exec1 
309c			 
309c					 
309c			 
309c			 
309c					NEXTW 
309c c3 f5 1c			jp macro_next 
309f				endm 
# End of macro NEXTW
309f			.I:  
309f			 
309f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
309f 5e				db WORD_SYS_CORE+74             
30a0 ca 30			dw .DLOOP            
30a2 02				db 1 + 1 
30a3 .. 00			db "I",0              
30a5				endm 
# End of macro CWHEAD
30a5			; | I ( -- ) Current loop counter | DONE 
30a5					if DEBUG_FORTH_WORDS_KEY 
30a5						DMARK "I.." 
30a5 f5				push af  
30a6 3a ba 30			ld a, (.dmark)  
30a9 32 7a ee			ld (debug_mark),a  
30ac 3a bb 30			ld a, (.dmark+1)  
30af 32 7b ee			ld (debug_mark+1),a  
30b2 3a bc 30			ld a, (.dmark+2)  
30b5 32 7c ee			ld (debug_mark+2),a  
30b8 18 03			jr .pastdmark  
30ba ..			.dmark: db "I.."  
30bd f1			.pastdmark: pop af  
30be			endm  
# End of macro DMARK
30be						CALLMONITOR 
30be cd ff 13			call break_point_state  
30c1				endm  
# End of macro CALLMONITOR
30c1					endif 
30c1			 
30c1 2a 85 e6				ld hl,(os_current_i) 
30c4 cd 8c 19				call forth_push_numhl 
30c7			 
30c7					NEXTW 
30c7 c3 f5 1c			jp macro_next 
30ca				endm 
# End of macro NEXTW
30ca			.DLOOP: 
30ca				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
30ca 5f				db WORD_SYS_CORE+75             
30cb ab 31			dw .REPEAT            
30cd 06				db 5 + 1 
30ce .. 00			db "-LOOP",0              
30d4				endm 
# End of macro CWHEAD
30d4			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
30d4				; pop tos as current loop count to hl 
30d4					if DEBUG_FORTH_WORDS_KEY 
30d4						DMARK "-LP" 
30d4 f5				push af  
30d5 3a e9 30			ld a, (.dmark)  
30d8 32 7a ee			ld (debug_mark),a  
30db 3a ea 30			ld a, (.dmark+1)  
30de 32 7b ee			ld (debug_mark+1),a  
30e1 3a eb 30			ld a, (.dmark+2)  
30e4 32 7c ee			ld (debug_mark+2),a  
30e7 18 03			jr .pastdmark  
30e9 ..			.dmark: db "-LP"  
30ec f1			.pastdmark: pop af  
30ed			endm  
# End of macro DMARK
30ed						CALLMONITOR 
30ed cd ff 13			call break_point_state  
30f0				endm  
# End of macro CALLMONITOR
30f0					endif 
30f0			 
30f0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30f0			 
30f0				FORTH_LOOP_TOS 
30f0 cd e7 1b			call macro_forth_loop_tos 
30f3				endm 
# End of macro FORTH_LOOP_TOS
30f3 e5				push hl 
30f4			 
30f4					if DEBUG_FORTH_WORDS 
30f4						DMARK "-LP" 
30f4 f5				push af  
30f5 3a 09 31			ld a, (.dmark)  
30f8 32 7a ee			ld (debug_mark),a  
30fb 3a 0a 31			ld a, (.dmark+1)  
30fe 32 7b ee			ld (debug_mark+1),a  
3101 3a 0b 31			ld a, (.dmark+2)  
3104 32 7c ee			ld (debug_mark+2),a  
3107 18 03			jr .pastdmark  
3109 ..			.dmark: db "-LP"  
310c f1			.pastdmark: pop af  
310d			endm  
# End of macro DMARK
310d						CALLMONITOR 
310d cd ff 13			call break_point_state  
3110				endm  
# End of macro CALLMONITOR
3110					endif 
3110				; next item on the stack is the limit. get it 
3110			 
3110			 
3110				FORTH_LOOP_POP 
3110 cd f1 1b			call macro_forth_loop_pop 
3113				endm 
# End of macro FORTH_LOOP_POP
3113			 
3113				FORTH_LOOP_TOS 
3113 cd e7 1b			call macro_forth_loop_tos 
3116				endm 
# End of macro FORTH_LOOP_TOS
3116			 
3116 d1				pop de		 ; de = i, hl = limit 
3117			 
3117					if DEBUG_FORTH_WORDS 
3117						DMARK "-L1" 
3117 f5				push af  
3118 3a 2c 31			ld a, (.dmark)  
311b 32 7a ee			ld (debug_mark),a  
311e 3a 2d 31			ld a, (.dmark+1)  
3121 32 7b ee			ld (debug_mark+1),a  
3124 3a 2e 31			ld a, (.dmark+2)  
3127 32 7c ee			ld (debug_mark+2),a  
312a 18 03			jr .pastdmark  
312c ..			.dmark: db "-L1"  
312f f1			.pastdmark: pop af  
3130			endm  
# End of macro DMARK
3130						CALLMONITOR 
3130 cd ff 13			call break_point_state  
3133				endm  
# End of macro CALLMONITOR
3133					endif 
3133			 
3133				; go back to previous word 
3133			 
3133 d5				push de    ; save I for inc later 
3134			 
3134			 
3134				; get limit 
3134				;  is I at limit? 
3134			 
3134			 
3134					if DEBUG_FORTH_WORDS 
3134						DMARK "-L1" 
3134 f5				push af  
3135 3a 49 31			ld a, (.dmark)  
3138 32 7a ee			ld (debug_mark),a  
313b 3a 4a 31			ld a, (.dmark+1)  
313e 32 7b ee			ld (debug_mark+1),a  
3141 3a 4b 31			ld a, (.dmark+2)  
3144 32 7c ee			ld (debug_mark+2),a  
3147 18 03			jr .pastdmark  
3149 ..			.dmark: db "-L1"  
314c f1			.pastdmark: pop af  
314d			endm  
# End of macro DMARK
314d						CALLMONITOR 
314d cd ff 13			call break_point_state  
3150				endm  
# End of macro CALLMONITOR
3150					endif 
3150			 
3150 ed 52			sbc hl, de 
3152			 
3152			 
3152				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3152			 
3152 20 26				jr nz, .mloopnotdone 
3154			 
3154 e1				pop hl   ; get rid of saved I 
3155				FORTH_LOOP_POP     ; get rid of limit 
3155 cd f1 1b			call macro_forth_loop_pop 
3158				endm 
# End of macro FORTH_LOOP_POP
3158			 
3158				FORTH_RSP_POP     ; get rid of DO ptr 
3158 cd 54 19			call macro_forth_rsp_pop 
315b				endm 
# End of macro FORTH_RSP_POP
315b			 
315b			if DEBUG_FORTH_WORDS 
315b						DMARK "-L>" 
315b f5				push af  
315c 3a 70 31			ld a, (.dmark)  
315f 32 7a ee			ld (debug_mark),a  
3162 3a 71 31			ld a, (.dmark+1)  
3165 32 7b ee			ld (debug_mark+1),a  
3168 3a 72 31			ld a, (.dmark+2)  
316b 32 7c ee			ld (debug_mark+2),a  
316e 18 03			jr .pastdmark  
3170 ..			.dmark: db "-L>"  
3173 f1			.pastdmark: pop af  
3174			endm  
# End of macro DMARK
3174				CALLMONITOR 
3174 cd ff 13			call break_point_state  
3177				endm  
# End of macro CALLMONITOR
3177			endif 
3177			 
3177					NEXTW 
3177 c3 f5 1c			jp macro_next 
317a				endm 
# End of macro NEXTW
317a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
317a			 
317a			.mloopnotdone: 
317a			 
317a e1				pop hl    ; get I 
317b 2b				dec hl 
317c			 
317c			   	; save new I 
317c			 
317c			 
317c					; set I counter 
317c			 
317c 22 85 e6				ld (os_current_i), hl 
317f			 
317f					 
317f				FORTH_LOOP_NEXT 
317f cd b4 1b			call macro_forth_loop_next 
3182				endm 
# End of macro FORTH_LOOP_NEXT
3182			 
3182			 
3182					if DEBUG_FORTH_WORDS 
3182 eb						ex de,hl 
3183					endif 
3183			 
3183			;	; get DO ptr 
3183			; 
3183				FORTH_RSP_TOS 
3183 cd 4a 19			call macro_forth_rsp_tos 
3186				endm 
# End of macro FORTH_RSP_TOS
3186			 
3186				;push hl 
3186			 
3186				; not going to DO any more 
3186				; get rid of the RSP pointer as DO will add it back in 
3186				;FORTH_RSP_POP 
3186				;pop hl 
3186			 
3186			 
3186 22 61 e6			ld (os_tok_ptr), hl 
3189					if DEBUG_FORTH_WORDS 
3189						DMARK "-L<" 
3189 f5				push af  
318a 3a 9e 31			ld a, (.dmark)  
318d 32 7a ee			ld (debug_mark),a  
3190 3a 9f 31			ld a, (.dmark+1)  
3193 32 7b ee			ld (debug_mark+1),a  
3196 3a a0 31			ld a, (.dmark+2)  
3199 32 7c ee			ld (debug_mark+2),a  
319c 18 03			jr .pastdmark  
319e ..			.dmark: db "-L<"  
31a1 f1			.pastdmark: pop af  
31a2			endm  
# End of macro DMARK
31a2					CALLMONITOR 
31a2 cd ff 13			call break_point_state  
31a5				endm  
# End of macro CALLMONITOR
31a5				endif 
31a5 c3 86 1d			jp exec1 
31a8			 
31a8					 
31a8			 
31a8			 
31a8			 
31a8				NEXTW 
31a8 c3 f5 1c			jp macro_next 
31ab				endm 
# End of macro NEXTW
31ab			 
31ab			 
31ab			 
31ab			 
31ab			.REPEAT: 
31ab				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
31ab 71				db WORD_SYS_CORE+93             
31ac fe 31			dw .UNTIL            
31ae 06				db 5 + 1 
31af .. 00			db "REPEAT",0              
31b6				endm 
# End of macro CWHEAD
31b6			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
31b6			;  push pc to rsp stack past the REPEAT 
31b6					if DEBUG_FORTH_WORDS_KEY 
31b6						DMARK "REP" 
31b6 f5				push af  
31b7 3a cb 31			ld a, (.dmark)  
31ba 32 7a ee			ld (debug_mark),a  
31bd 3a cc 31			ld a, (.dmark+1)  
31c0 32 7b ee			ld (debug_mark+1),a  
31c3 3a cd 31			ld a, (.dmark+2)  
31c6 32 7c ee			ld (debug_mark+2),a  
31c9 18 03			jr .pastdmark  
31cb ..			.dmark: db "REP"  
31ce f1			.pastdmark: pop af  
31cf			endm  
# End of macro DMARK
31cf						CALLMONITOR 
31cf cd ff 13			call break_point_state  
31d2				endm  
# End of macro CALLMONITOR
31d2					endif 
31d2			 
31d2 2a 61 e6				ld hl, (os_tok_ptr) 
31d5 23					inc hl   ; R 
31d6 23					inc hl  ; E 
31d7 23					inc hl   ; P 
31d8 23					inc hl   ; E 
31d9 23					inc hl   ; A 
31da 23					inc hl   ; T 
31db 23					inc hl   ; zero 
31dc					FORTH_RSP_NEXT 
31dc cd 33 19			call macro_forth_rsp_next 
31df				endm 
# End of macro FORTH_RSP_NEXT
31df			 
31df			 
31df					if DEBUG_FORTH_WORDS 
31df						DMARK "REP" 
31df f5				push af  
31e0 3a f4 31			ld a, (.dmark)  
31e3 32 7a ee			ld (debug_mark),a  
31e6 3a f5 31			ld a, (.dmark+1)  
31e9 32 7b ee			ld (debug_mark+1),a  
31ec 3a f6 31			ld a, (.dmark+2)  
31ef 32 7c ee			ld (debug_mark+2),a  
31f2 18 03			jr .pastdmark  
31f4 ..			.dmark: db "REP"  
31f7 f1			.pastdmark: pop af  
31f8			endm  
# End of macro DMARK
31f8						;pop bc    ; TODO BUG ?????? what is this for???? 
31f8						CALLMONITOR 
31f8 cd ff 13			call break_point_state  
31fb				endm  
# End of macro CALLMONITOR
31fb					endif 
31fb			 
31fb					NEXTW 
31fb c3 f5 1c			jp macro_next 
31fe				endm 
# End of macro NEXTW
31fe			;	       NEXTW 
31fe			 
31fe			.UNTIL: 
31fe				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
31fe 72				db WORD_SYS_CORE+94             
31ff 95 32			dw .ENDFLOW            
3201 06				db 5 + 1 
3202 .. 00			db "UNTIL",0              
3208				endm 
# End of macro CWHEAD
3208			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3208			 
3208				; pop tos as check 
3208			 
3208				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3208			 
3208				FORTH_DSP_VALUEHL 
3208 cd 83 1b			call macro_dsp_valuehl 
320b				endm 
# End of macro FORTH_DSP_VALUEHL
320b			 
320b					if DEBUG_FORTH_WORDS_KEY 
320b						DMARK "UNT" 
320b f5				push af  
320c 3a 20 32			ld a, (.dmark)  
320f 32 7a ee			ld (debug_mark),a  
3212 3a 21 32			ld a, (.dmark+1)  
3215 32 7b ee			ld (debug_mark+1),a  
3218 3a 22 32			ld a, (.dmark+2)  
321b 32 7c ee			ld (debug_mark+2),a  
321e 18 03			jr .pastdmark  
3220 ..			.dmark: db "UNT"  
3223 f1			.pastdmark: pop af  
3224			endm  
# End of macro DMARK
3224						CALLMONITOR 
3224 cd ff 13			call break_point_state  
3227				endm  
# End of macro CALLMONITOR
3227					endif 
3227			 
3227			;	push hl 
3227				FORTH_DSP_POP 
3227 cd 3b 1c			call macro_forth_dsp_pop 
322a				endm 
# End of macro FORTH_DSP_POP
322a			 
322a			;	pop hl 
322a			 
322a				; test if true 
322a			 
322a cd db 0b			call ishlzero 
322d			;	ld a,l 
322d			;	add h 
322d			; 
322d			;	cp 0 
322d			 
322d 20 3e			jr nz, .untilnotdone 
322f			 
322f					if DEBUG_FORTH_WORDS 
322f						DMARK "UNf" 
322f f5				push af  
3230 3a 44 32			ld a, (.dmark)  
3233 32 7a ee			ld (debug_mark),a  
3236 3a 45 32			ld a, (.dmark+1)  
3239 32 7b ee			ld (debug_mark+1),a  
323c 3a 46 32			ld a, (.dmark+2)  
323f 32 7c ee			ld (debug_mark+2),a  
3242 18 03			jr .pastdmark  
3244 ..			.dmark: db "UNf"  
3247 f1			.pastdmark: pop af  
3248			endm  
# End of macro DMARK
3248						CALLMONITOR 
3248 cd ff 13			call break_point_state  
324b				endm  
# End of macro CALLMONITOR
324b					endif 
324b			 
324b			 
324b			 
324b				FORTH_RSP_POP     ; get rid of DO ptr 
324b cd 54 19			call macro_forth_rsp_pop 
324e				endm 
# End of macro FORTH_RSP_POP
324e			 
324e			if DEBUG_FORTH_WORDS 
324e						DMARK "UN>" 
324e f5				push af  
324f 3a 63 32			ld a, (.dmark)  
3252 32 7a ee			ld (debug_mark),a  
3255 3a 64 32			ld a, (.dmark+1)  
3258 32 7b ee			ld (debug_mark+1),a  
325b 3a 65 32			ld a, (.dmark+2)  
325e 32 7c ee			ld (debug_mark+2),a  
3261 18 03			jr .pastdmark  
3263 ..			.dmark: db "UN>"  
3266 f1			.pastdmark: pop af  
3267			endm  
# End of macro DMARK
3267				CALLMONITOR 
3267 cd ff 13			call break_point_state  
326a				endm  
# End of macro CALLMONITOR
326a			endif 
326a			 
326a					NEXTW 
326a c3 f5 1c			jp macro_next 
326d				endm 
# End of macro NEXTW
326d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
326d			 
326d			.untilnotdone: 
326d			 
326d			 
326d			;	; get DO ptr 
326d			; 
326d				FORTH_RSP_TOS 
326d cd 4a 19			call macro_forth_rsp_tos 
3270				endm 
# End of macro FORTH_RSP_TOS
3270			 
3270				;push hl 
3270			 
3270				; not going to DO any more 
3270				; get rid of the RSP pointer as DO will add it back in 
3270				;FORTH_RSP_POP 
3270				;pop hl 
3270			 
3270			 
3270 22 61 e6			ld (os_tok_ptr), hl 
3273					if DEBUG_FORTH_WORDS 
3273						DMARK "UN<" 
3273 f5				push af  
3274 3a 88 32			ld a, (.dmark)  
3277 32 7a ee			ld (debug_mark),a  
327a 3a 89 32			ld a, (.dmark+1)  
327d 32 7b ee			ld (debug_mark+1),a  
3280 3a 8a 32			ld a, (.dmark+2)  
3283 32 7c ee			ld (debug_mark+2),a  
3286 18 03			jr .pastdmark  
3288 ..			.dmark: db "UN<"  
328b f1			.pastdmark: pop af  
328c			endm  
# End of macro DMARK
328c					CALLMONITOR 
328c cd ff 13			call break_point_state  
328f				endm  
# End of macro CALLMONITOR
328f				endif 
328f c3 86 1d			jp exec1 
3292			 
3292					 
3292			 
3292			 
3292					NEXTW 
3292 c3 f5 1c			jp macro_next 
3295				endm 
# End of macro NEXTW
3295			 
3295			 
3295			.ENDFLOW: 
3295			 
3295			; eof 
3295			 
# End of file forth_words_flow.asm
3295			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3295			include "forth_words_logic.asm" 
3295			 
3295			; | ## Logic Words 
3295			 
3295			.NOT: 
3295				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3295 2d				db WORD_SYS_CORE+25             
3296 dd 32			dw .IS            
3298 04				db 3 + 1 
3299 .. 00			db "NOT",0              
329d				endm 
# End of macro CWHEAD
329d			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
329d					if DEBUG_FORTH_WORDS_KEY 
329d						DMARK "NOT" 
329d f5				push af  
329e 3a b2 32			ld a, (.dmark)  
32a1 32 7a ee			ld (debug_mark),a  
32a4 3a b3 32			ld a, (.dmark+1)  
32a7 32 7b ee			ld (debug_mark+1),a  
32aa 3a b4 32			ld a, (.dmark+2)  
32ad 32 7c ee			ld (debug_mark+2),a  
32b0 18 03			jr .pastdmark  
32b2 ..			.dmark: db "NOT"  
32b5 f1			.pastdmark: pop af  
32b6			endm  
# End of macro DMARK
32b6						CALLMONITOR 
32b6 cd ff 13			call break_point_state  
32b9				endm  
# End of macro CALLMONITOR
32b9					endif 
32b9					FORTH_DSP 
32b9 cd 49 1b			call macro_forth_dsp 
32bc				endm 
# End of macro FORTH_DSP
32bc 7e					ld a,(hl)	; get type of value on TOS 
32bd fe 02				cp DS_TYPE_INUM  
32bf 28 03				jr z, .noti 
32c1					NEXTW 
32c1 c3 f5 1c			jp macro_next 
32c4				endm 
# End of macro NEXTW
32c4			.noti:          FORTH_DSP_VALUEHL 
32c4 cd 83 1b			call macro_dsp_valuehl 
32c7				endm 
# End of macro FORTH_DSP_VALUEHL
32c7			;		push hl 
32c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32c7 cd 3b 1c			call macro_forth_dsp_pop 
32ca				endm 
# End of macro FORTH_DSP_POP
32ca			;		pop hl 
32ca 3e 00				ld a,0 
32cc bd					cp l 
32cd 28 04				jr z, .not2t 
32cf 2e 00				ld l, 0 
32d1 18 02				jr .notip 
32d3			 
32d3 2e ff		.not2t:		ld l, 255 
32d5			 
32d5 26 00		.notip:		ld h, 0	 
32d7			 
32d7 cd 8c 19				call forth_push_numhl 
32da					NEXTW 
32da c3 f5 1c			jp macro_next 
32dd				endm 
# End of macro NEXTW
32dd			 
32dd			.IS: 
32dd				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
32dd 2d				db WORD_SYS_CORE+25             
32de 03 33			dw .LZERO            
32e0 03				db 2 + 1 
32e1 .. 00			db "IS",0              
32e4				endm 
# End of macro CWHEAD
32e4			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
32e4					if DEBUG_FORTH_WORDS_KEY 
32e4						DMARK "IS." 
32e4 f5				push af  
32e5 3a f9 32			ld a, (.dmark)  
32e8 32 7a ee			ld (debug_mark),a  
32eb 3a fa 32			ld a, (.dmark+1)  
32ee 32 7b ee			ld (debug_mark+1),a  
32f1 3a fb 32			ld a, (.dmark+2)  
32f4 32 7c ee			ld (debug_mark+2),a  
32f7 18 03			jr .pastdmark  
32f9 ..			.dmark: db "IS."  
32fc f1			.pastdmark: pop af  
32fd			endm  
# End of macro DMARK
32fd						CALLMONITOR 
32fd cd ff 13			call break_point_state  
3300				endm  
# End of macro CALLMONITOR
3300					endif 
3300					NEXTW 
3300 c3 f5 1c			jp macro_next 
3303				endm 
# End of macro NEXTW
3303			.LZERO: 
3303				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3303 2d				db WORD_SYS_CORE+25             
3304 0d 33			dw .TZERO            
3306 03				db 2 + 1 
3307 .. 00			db "0<",0              
330a				endm 
# End of macro CWHEAD
330a			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
330a					NEXTW 
330a c3 f5 1c			jp macro_next 
330d				endm 
# End of macro NEXTW
330d			.TZERO: 
330d				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
330d 2e				db WORD_SYS_CORE+26             
330e 54 33			dw .LESS            
3310 03				db 2 + 1 
3311 .. 00			db "0=",0              
3314				endm 
# End of macro CWHEAD
3314			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3314				; TODO add floating point number detection 
3314					;v5 FORTH_DSP_VALUE 
3314					if DEBUG_FORTH_WORDS_KEY 
3314						DMARK "0=." 
3314 f5				push af  
3315 3a 29 33			ld a, (.dmark)  
3318 32 7a ee			ld (debug_mark),a  
331b 3a 2a 33			ld a, (.dmark+1)  
331e 32 7b ee			ld (debug_mark+1),a  
3321 3a 2b 33			ld a, (.dmark+2)  
3324 32 7c ee			ld (debug_mark+2),a  
3327 18 03			jr .pastdmark  
3329 ..			.dmark: db "0=."  
332c f1			.pastdmark: pop af  
332d			endm  
# End of macro DMARK
332d						CALLMONITOR 
332d cd ff 13			call break_point_state  
3330				endm  
# End of macro CALLMONITOR
3330					endif 
3330					FORTH_DSP 
3330 cd 49 1b			call macro_forth_dsp 
3333				endm 
# End of macro FORTH_DSP
3333 7e					ld a,(hl)	; get type of value on TOS 
3334 fe 02				cp DS_TYPE_INUM  
3336 28 00				jr z, .tz_inum 
3338			 
3338				if FORTH_ENABLE_FLOATMATH 
3338					jr .tz_done 
3338			 
3338				endif 
3338					 
3338			 
3338			.tz_inum: 
3338					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3338 cd 83 1b			call macro_dsp_valuehl 
333b				endm 
# End of macro FORTH_DSP_VALUEHL
333b			 
333b			;		push hl 
333b			 
333b					; destroy value TOS 
333b			 
333b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
333b cd 3b 1c			call macro_forth_dsp_pop 
333e				endm 
# End of macro FORTH_DSP_POP
333e			 
333e			;		pop hl 
333e			 
333e 3e 00				ld a,0 
3340			 
3340 bd					cp l 
3341 20 08				jr nz, .tz_notzero 
3343			 
3343 bc					cp h 
3344			 
3344 20 05				jr nz, .tz_notzero 
3346			 
3346			 
3346 21 01 00				ld hl, FORTH_TRUE 
3349 18 03				jr .tz_done 
334b			 
334b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
334e			 
334e					; push value back onto stack for another op etc 
334e			 
334e			.tz_done: 
334e cd 8c 19				call forth_push_numhl 
3351			 
3351					NEXTW 
3351 c3 f5 1c			jp macro_next 
3354				endm 
# End of macro NEXTW
3354			.LESS: 
3354				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3354 2f				db WORD_SYS_CORE+27             
3355 bd 33			dw .GT            
3357 02				db 1 + 1 
3358 .. 00			db "<",0              
335a				endm 
# End of macro CWHEAD
335a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
335a				; TODO add floating point number detection 
335a					if DEBUG_FORTH_WORDS_KEY 
335a						DMARK "LES" 
335a f5				push af  
335b 3a 6f 33			ld a, (.dmark)  
335e 32 7a ee			ld (debug_mark),a  
3361 3a 70 33			ld a, (.dmark+1)  
3364 32 7b ee			ld (debug_mark+1),a  
3367 3a 71 33			ld a, (.dmark+2)  
336a 32 7c ee			ld (debug_mark+2),a  
336d 18 03			jr .pastdmark  
336f ..			.dmark: db "LES"  
3372 f1			.pastdmark: pop af  
3373			endm  
# End of macro DMARK
3373						CALLMONITOR 
3373 cd ff 13			call break_point_state  
3376				endm  
# End of macro CALLMONITOR
3376					endif 
3376					FORTH_DSP 
3376 cd 49 1b			call macro_forth_dsp 
3379				endm 
# End of macro FORTH_DSP
3379					;v5 FORTH_DSP_VALUE 
3379 7e					ld a,(hl)	; get type of value on TOS 
337a fe 02				cp DS_TYPE_INUM  
337c 28 00				jr z, .less_inum 
337e			 
337e				if FORTH_ENABLE_FLOATMATH 
337e					jr .less_done 
337e			 
337e				endif 
337e					 
337e			 
337e			.less_inum: 
337e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
337e cd 83 1b			call macro_dsp_valuehl 
3381				endm 
# End of macro FORTH_DSP_VALUEHL
3381			 
3381 e5					push hl  ; u2 
3382			 
3382					; destroy value TOS 
3382			 
3382					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3382 cd 3b 1c			call macro_forth_dsp_pop 
3385				endm 
# End of macro FORTH_DSP_POP
3385			 
3385			 
3385					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3385 cd 83 1b			call macro_dsp_valuehl 
3388				endm 
# End of macro FORTH_DSP_VALUEHL
3388			 
3388 e5					push hl    ; u1 
3389			 
3389					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3389 cd 3b 1c			call macro_forth_dsp_pop 
338c				endm 
# End of macro FORTH_DSP_POP
338c			 
338c			 
338c b7			 or a      ;clear carry flag 
338d 01 00 00		 ld bc, FORTH_FALSE 
3390 e1			  pop hl    ; u1 
3391 d1			  pop de    ; u2 
3392 ed 52		  sbc hl,de 
3394 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3396			 
3396 01 01 00		 ld bc, FORTH_TRUE 
3399			.lscont:  
3399 c5					push bc 
339a e1					pop hl 
339b			 
339b					if DEBUG_FORTH_WORDS 
339b						DMARK "LT1" 
339b f5				push af  
339c 3a b0 33			ld a, (.dmark)  
339f 32 7a ee			ld (debug_mark),a  
33a2 3a b1 33			ld a, (.dmark+1)  
33a5 32 7b ee			ld (debug_mark+1),a  
33a8 3a b2 33			ld a, (.dmark+2)  
33ab 32 7c ee			ld (debug_mark+2),a  
33ae 18 03			jr .pastdmark  
33b0 ..			.dmark: db "LT1"  
33b3 f1			.pastdmark: pop af  
33b4			endm  
# End of macro DMARK
33b4						CALLMONITOR 
33b4 cd ff 13			call break_point_state  
33b7				endm  
# End of macro CALLMONITOR
33b7					endif 
33b7 cd 8c 19				call forth_push_numhl 
33ba			 
33ba					NEXTW 
33ba c3 f5 1c			jp macro_next 
33bd				endm 
# End of macro NEXTW
33bd			.GT: 
33bd				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
33bd 30				db WORD_SYS_CORE+28             
33be 26 34			dw .EQUAL            
33c0 02				db 1 + 1 
33c1 .. 00			db ">",0              
33c3				endm 
# End of macro CWHEAD
33c3			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
33c3				; TODO add floating point number detection 
33c3					if DEBUG_FORTH_WORDS_KEY 
33c3						DMARK "GRT" 
33c3 f5				push af  
33c4 3a d8 33			ld a, (.dmark)  
33c7 32 7a ee			ld (debug_mark),a  
33ca 3a d9 33			ld a, (.dmark+1)  
33cd 32 7b ee			ld (debug_mark+1),a  
33d0 3a da 33			ld a, (.dmark+2)  
33d3 32 7c ee			ld (debug_mark+2),a  
33d6 18 03			jr .pastdmark  
33d8 ..			.dmark: db "GRT"  
33db f1			.pastdmark: pop af  
33dc			endm  
# End of macro DMARK
33dc						CALLMONITOR 
33dc cd ff 13			call break_point_state  
33df				endm  
# End of macro CALLMONITOR
33df					endif 
33df					FORTH_DSP 
33df cd 49 1b			call macro_forth_dsp 
33e2				endm 
# End of macro FORTH_DSP
33e2					;FORTH_DSP_VALUE 
33e2 7e					ld a,(hl)	; get type of value on TOS 
33e3 fe 02				cp DS_TYPE_INUM  
33e5 28 00				jr z, .gt_inum 
33e7			 
33e7				if FORTH_ENABLE_FLOATMATH 
33e7					jr .gt_done 
33e7			 
33e7				endif 
33e7					 
33e7			 
33e7			.gt_inum: 
33e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33e7 cd 83 1b			call macro_dsp_valuehl 
33ea				endm 
# End of macro FORTH_DSP_VALUEHL
33ea			 
33ea e5					push hl  ; u2 
33eb			 
33eb					; destroy value TOS 
33eb			 
33eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33eb cd 3b 1c			call macro_forth_dsp_pop 
33ee				endm 
# End of macro FORTH_DSP_POP
33ee			 
33ee			 
33ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33ee cd 83 1b			call macro_dsp_valuehl 
33f1				endm 
# End of macro FORTH_DSP_VALUEHL
33f1			 
33f1 e5					push hl    ; u1 
33f2			 
33f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33f2 cd 3b 1c			call macro_forth_dsp_pop 
33f5				endm 
# End of macro FORTH_DSP_POP
33f5			 
33f5			 
33f5 b7			 or a      ;clear carry flag 
33f6 01 00 00		 ld bc, FORTH_FALSE 
33f9 e1			  pop hl    ; u1 
33fa d1			  pop de    ; u2 
33fb ed 52		  sbc hl,de 
33fd 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
33ff			 
33ff 01 01 00		 ld bc, FORTH_TRUE 
3402			.gtcont:  
3402 c5					push bc 
3403 e1					pop hl 
3404			 
3404					if DEBUG_FORTH_WORDS 
3404						DMARK "GT1" 
3404 f5				push af  
3405 3a 19 34			ld a, (.dmark)  
3408 32 7a ee			ld (debug_mark),a  
340b 3a 1a 34			ld a, (.dmark+1)  
340e 32 7b ee			ld (debug_mark+1),a  
3411 3a 1b 34			ld a, (.dmark+2)  
3414 32 7c ee			ld (debug_mark+2),a  
3417 18 03			jr .pastdmark  
3419 ..			.dmark: db "GT1"  
341c f1			.pastdmark: pop af  
341d			endm  
# End of macro DMARK
341d						CALLMONITOR 
341d cd ff 13			call break_point_state  
3420				endm  
# End of macro CALLMONITOR
3420					endif 
3420 cd 8c 19				call forth_push_numhl 
3423			 
3423					NEXTW 
3423 c3 f5 1c			jp macro_next 
3426				endm 
# End of macro NEXTW
3426			.EQUAL: 
3426				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3426 31				db WORD_SYS_CORE+29             
3427 91 34			dw .ENDLOGIC            
3429 02				db 1 + 1 
342a .. 00			db "=",0              
342c				endm 
# End of macro CWHEAD
342c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
342c				; TODO add floating point number detection 
342c					if DEBUG_FORTH_WORDS_KEY 
342c						DMARK "EQ." 
342c f5				push af  
342d 3a 41 34			ld a, (.dmark)  
3430 32 7a ee			ld (debug_mark),a  
3433 3a 42 34			ld a, (.dmark+1)  
3436 32 7b ee			ld (debug_mark+1),a  
3439 3a 43 34			ld a, (.dmark+2)  
343c 32 7c ee			ld (debug_mark+2),a  
343f 18 03			jr .pastdmark  
3441 ..			.dmark: db "EQ."  
3444 f1			.pastdmark: pop af  
3445			endm  
# End of macro DMARK
3445						CALLMONITOR 
3445 cd ff 13			call break_point_state  
3448				endm  
# End of macro CALLMONITOR
3448					endif 
3448					FORTH_DSP 
3448 cd 49 1b			call macro_forth_dsp 
344b				endm 
# End of macro FORTH_DSP
344b					;v5 FORTH_DSP_VALUE 
344b 7e					ld a,(hl)	; get type of value on TOS 
344c fe 02				cp DS_TYPE_INUM  
344e 28 00				jr z, .eq_inum 
3450			 
3450				if FORTH_ENABLE_FLOATMATH 
3450					jr .eq_done 
3450			 
3450				endif 
3450					 
3450			 
3450			.eq_inum: 
3450					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3450 cd 83 1b			call macro_dsp_valuehl 
3453				endm 
# End of macro FORTH_DSP_VALUEHL
3453			 
3453 e5					push hl 
3454			 
3454					; destroy value TOS 
3454			 
3454					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3454 cd 3b 1c			call macro_forth_dsp_pop 
3457				endm 
# End of macro FORTH_DSP_POP
3457			 
3457			 
3457					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3457 cd 83 1b			call macro_dsp_valuehl 
345a				endm 
# End of macro FORTH_DSP_VALUEHL
345a			 
345a					; one value on hl get other one back 
345a			 
345a e5					push hl 
345b			 
345b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
345b cd 3b 1c			call macro_forth_dsp_pop 
345e				endm 
# End of macro FORTH_DSP_POP
345e			 
345e 0e 00				ld c, FORTH_FALSE 
3460			 
3460 e1					pop hl 
3461 d1					pop de 
3462			 
3462 7b					ld a, e 
3463 bd					cp l 
3464			 
3464 20 06				jr nz, .eq_done 
3466			 
3466 7a					ld a, d 
3467 bc					cp h 
3468			 
3468 20 02				jr nz, .eq_done 
346a			 
346a 0e 01				ld c, FORTH_TRUE 
346c					 
346c			 
346c			 
346c			.eq_done: 
346c			 
346c					; TODO push value back onto stack for another op etc 
346c			 
346c 26 00				ld h, 0 
346e 69					ld l, c 
346f					if DEBUG_FORTH_WORDS 
346f						DMARK "EQ1" 
346f f5				push af  
3470 3a 84 34			ld a, (.dmark)  
3473 32 7a ee			ld (debug_mark),a  
3476 3a 85 34			ld a, (.dmark+1)  
3479 32 7b ee			ld (debug_mark+1),a  
347c 3a 86 34			ld a, (.dmark+2)  
347f 32 7c ee			ld (debug_mark+2),a  
3482 18 03			jr .pastdmark  
3484 ..			.dmark: db "EQ1"  
3487 f1			.pastdmark: pop af  
3488			endm  
# End of macro DMARK
3488						CALLMONITOR 
3488 cd ff 13			call break_point_state  
348b				endm  
# End of macro CALLMONITOR
348b					endif 
348b cd 8c 19				call forth_push_numhl 
348e			 
348e					NEXTW 
348e c3 f5 1c			jp macro_next 
3491				endm 
# End of macro NEXTW
3491			 
3491			 
3491			.ENDLOGIC: 
3491			; eof 
3491			 
3491			 
# End of file forth_words_logic.asm
3491			include "forth_words_maths.asm" 
3491			 
3491			; | ## Maths Words 
3491			 
3491			.PLUS:	 
3491				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3491 15				db WORD_SYS_CORE+1             
3492 d3 34			dw .NEG            
3494 02				db 1 + 1 
3495 .. 00			db "+",0              
3497				endm 
# End of macro CWHEAD
3497			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3497					if DEBUG_FORTH_WORDS_KEY 
3497						DMARK "PLU" 
3497 f5				push af  
3498 3a ac 34			ld a, (.dmark)  
349b 32 7a ee			ld (debug_mark),a  
349e 3a ad 34			ld a, (.dmark+1)  
34a1 32 7b ee			ld (debug_mark+1),a  
34a4 3a ae 34			ld a, (.dmark+2)  
34a7 32 7c ee			ld (debug_mark+2),a  
34aa 18 03			jr .pastdmark  
34ac ..			.dmark: db "PLU"  
34af f1			.pastdmark: pop af  
34b0			endm  
# End of macro DMARK
34b0						CALLMONITOR 
34b0 cd ff 13			call break_point_state  
34b3				endm  
# End of macro CALLMONITOR
34b3					endif 
34b3					; add top two values and push back result 
34b3			 
34b3					;for v5 FORTH_DSP_VALUE 
34b3					FORTH_DSP 
34b3 cd 49 1b			call macro_forth_dsp 
34b6				endm 
# End of macro FORTH_DSP
34b6 7e					ld a,(hl)	; get type of value on TOS 
34b7 fe 02				cp DS_TYPE_INUM  
34b9 28 03				jr z, .dot_inum 
34bb			 
34bb					NEXTW 
34bb c3 f5 1c			jp macro_next 
34be				endm 
# End of macro NEXTW
34be			 
34be			; float maths 
34be			 
34be				if FORTH_ENABLE_FLOATMATH 
34be						inc hl      ; now at start of numeric as string 
34be			 
34be					if DEBUG_FORTH_MATHS 
34be						DMARK "ADD" 
34be				CALLMONITOR 
34be					endif 
34be			 
34be					;ld ix, hl 
34be					call CON 
34be			 
34be			 
34be					push hl 
34be					 
34be					 
34be			 
34be						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
34be			 
34be					; get next number 
34be			 
34be						FORTH_DSP_VALUE 
34be			 
34be						inc hl      ; now at start of numeric as string 
34be			 
34be					;ld ix, hl 
34be					call CON 
34be			 
34be					push hl 
34be			 
34be			 
34be						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34be			 
34be						; TODO do add 
34be			 
34be						call IADD 
34be			 
34be						; TODO get result back as ascii 
34be			 
34be						; TODO push result  
34be			 
34be			 
34be			 
34be						jr .dot_done 
34be				endif 
34be			 
34be			.dot_inum: 
34be			 
34be			 
34be					if DEBUG_FORTH_DOT 
34be						DMARK "+IT" 
34be				CALLMONITOR 
34be					endif 
34be			 
34be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34be cd 83 1b			call macro_dsp_valuehl 
34c1				endm 
# End of macro FORTH_DSP_VALUEHL
34c1			 
34c1				; TODO add floating point number detection 
34c1			 
34c1 e5					push hl 
34c2			 
34c2					; destroy value TOS 
34c2			 
34c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c2 cd 3b 1c			call macro_forth_dsp_pop 
34c5				endm 
# End of macro FORTH_DSP_POP
34c5			 
34c5			 
34c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34c5 cd 83 1b			call macro_dsp_valuehl 
34c8				endm 
# End of macro FORTH_DSP_VALUEHL
34c8			 
34c8					; one value on hl get other one back 
34c8			 
34c8 d1					pop de 
34c9			 
34c9					; do the add 
34c9			 
34c9 19					add hl,de 
34ca			 
34ca					; save it 
34ca			 
34ca			;		push hl	 
34ca			 
34ca					; 
34ca			 
34ca					; destroy value TOS 
34ca			 
34ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34ca cd 3b 1c			call macro_forth_dsp_pop 
34cd				endm 
# End of macro FORTH_DSP_POP
34cd			 
34cd					; TODO push value back onto stack for another op etc 
34cd			 
34cd			;		pop hl 
34cd			 
34cd			.dot_done: 
34cd cd 8c 19				call forth_push_numhl 
34d0			 
34d0					NEXTW 
34d0 c3 f5 1c			jp macro_next 
34d3				endm 
# End of macro NEXTW
34d3			.NEG: 
34d3			 
34d3				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
34d3 17				db WORD_SYS_CORE+3             
34d4 16 35			dw .DIV            
34d6 02				db 1 + 1 
34d7 .. 00			db "-",0              
34d9				endm 
# End of macro CWHEAD
34d9			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
34d9					if DEBUG_FORTH_WORDS_KEY 
34d9						DMARK "SUB" 
34d9 f5				push af  
34da 3a ee 34			ld a, (.dmark)  
34dd 32 7a ee			ld (debug_mark),a  
34e0 3a ef 34			ld a, (.dmark+1)  
34e3 32 7b ee			ld (debug_mark+1),a  
34e6 3a f0 34			ld a, (.dmark+2)  
34e9 32 7c ee			ld (debug_mark+2),a  
34ec 18 03			jr .pastdmark  
34ee ..			.dmark: db "SUB"  
34f1 f1			.pastdmark: pop af  
34f2			endm  
# End of macro DMARK
34f2						CALLMONITOR 
34f2 cd ff 13			call break_point_state  
34f5				endm  
# End of macro CALLMONITOR
34f5					endif 
34f5			 
34f5			 
34f5				; TODO add floating point number detection 
34f5					; v5 FORTH_DSP_VALUE 
34f5					FORTH_DSP 
34f5 cd 49 1b			call macro_forth_dsp 
34f8				endm 
# End of macro FORTH_DSP
34f8 7e					ld a,(hl)	; get type of value on TOS 
34f9 fe 02				cp DS_TYPE_INUM  
34fb 28 03				jr z, .neg_inum 
34fd			 
34fd					NEXTW 
34fd c3 f5 1c			jp macro_next 
3500				endm 
# End of macro NEXTW
3500			 
3500			; float maths 
3500			 
3500				if FORTH_ENABLE_FLOATMATH 
3500					jr .neg_done 
3500			 
3500				endif 
3500					 
3500			 
3500			.neg_inum: 
3500					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3500 cd 83 1b			call macro_dsp_valuehl 
3503				endm 
# End of macro FORTH_DSP_VALUEHL
3503			 
3503 e5					push hl 
3504			 
3504					; destroy value TOS 
3504			 
3504					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3504 cd 3b 1c			call macro_forth_dsp_pop 
3507				endm 
# End of macro FORTH_DSP_POP
3507			 
3507			 
3507					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3507 cd 83 1b			call macro_dsp_valuehl 
350a				endm 
# End of macro FORTH_DSP_VALUEHL
350a			 
350a					; one value on hl get other one back 
350a			 
350a d1					pop de 
350b			 
350b					; do the sub 
350b			;		ex de, hl 
350b			 
350b ed 52				sbc hl,de 
350d			 
350d					; save it 
350d			 
350d			;		push hl	 
350d			 
350d					; 
350d			 
350d					; destroy value TOS 
350d			 
350d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
350d cd 3b 1c			call macro_forth_dsp_pop 
3510				endm 
# End of macro FORTH_DSP_POP
3510			 
3510					; TODO push value back onto stack for another op etc 
3510			 
3510			;		pop hl 
3510			 
3510 cd 8c 19				call forth_push_numhl 
3513			.neg_done: 
3513			 
3513					NEXTW 
3513 c3 f5 1c			jp macro_next 
3516				endm 
# End of macro NEXTW
3516			.DIV: 
3516				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3516 18				db WORD_SYS_CORE+4             
3517 63 35			dw .MUL            
3519 02				db 1 + 1 
351a .. 00			db "/",0              
351c				endm 
# End of macro CWHEAD
351c			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
351c					if DEBUG_FORTH_WORDS_KEY 
351c						DMARK "DIV" 
351c f5				push af  
351d 3a 31 35			ld a, (.dmark)  
3520 32 7a ee			ld (debug_mark),a  
3523 3a 32 35			ld a, (.dmark+1)  
3526 32 7b ee			ld (debug_mark+1),a  
3529 3a 33 35			ld a, (.dmark+2)  
352c 32 7c ee			ld (debug_mark+2),a  
352f 18 03			jr .pastdmark  
3531 ..			.dmark: db "DIV"  
3534 f1			.pastdmark: pop af  
3535			endm  
# End of macro DMARK
3535						CALLMONITOR 
3535 cd ff 13			call break_point_state  
3538				endm  
# End of macro CALLMONITOR
3538					endif 
3538				; TODO add floating point number detection 
3538					; v5 FORTH_DSP_VALUE 
3538					FORTH_DSP 
3538 cd 49 1b			call macro_forth_dsp 
353b				endm 
# End of macro FORTH_DSP
353b 7e					ld a,(hl)	; get type of value on TOS 
353c fe 02				cp DS_TYPE_INUM  
353e 28 03				jr z, .div_inum 
3540			 
3540				if FORTH_ENABLE_FLOATMATH 
3540					jr .div_done 
3540			 
3540				endif 
3540					NEXTW 
3540 c3 f5 1c			jp macro_next 
3543				endm 
# End of macro NEXTW
3543			.div_inum: 
3543			 
3543					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3543 cd 83 1b			call macro_dsp_valuehl 
3546				endm 
# End of macro FORTH_DSP_VALUEHL
3546			 
3546 e5					push hl    ; to go to bc 
3547			 
3547					; destroy value TOS 
3547			 
3547					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3547 cd 3b 1c			call macro_forth_dsp_pop 
354a				endm 
# End of macro FORTH_DSP_POP
354a			 
354a			 
354a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
354a cd 83 1b			call macro_dsp_valuehl 
354d				endm 
# End of macro FORTH_DSP_VALUEHL
354d			 
354d					; hl to go to de 
354d			 
354d e5					push hl 
354e			 
354e c1					pop bc 
354f d1					pop de		 
3550			 
3550			 
3550					if DEBUG_FORTH_MATHS 
3550						DMARK "DIV" 
3550				CALLMONITOR 
3550					endif 
3550					; one value on hl but move to a get other one back 
3550			 
3550			        
3550 cd 0f 0b			call Div16 
3553			 
3553			;	push af	 
3553 e5				push hl 
3554 c5				push bc 
3555			 
3555					if DEBUG_FORTH_MATHS 
3555						DMARK "DI1" 
3555				CALLMONITOR 
3555					endif 
3555			 
3555					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3555 cd 3b 1c			call macro_forth_dsp_pop 
3558				endm 
# End of macro FORTH_DSP_POP
3558			 
3558			 
3558			 
3558 e1					pop hl    ; result 
3559			 
3559 cd 8c 19				call forth_push_numhl 
355c			 
355c e1					pop hl    ; reminder 
355d			;		ld h,0 
355d			;		ld l,d 
355d			 
355d cd 8c 19				call forth_push_numhl 
3560			.div_done: 
3560					NEXTW 
3560 c3 f5 1c			jp macro_next 
3563				endm 
# End of macro NEXTW
3563			.MUL: 
3563				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3563 19				db WORD_SYS_CORE+5             
3564 a8 35			dw .MIN            
3566 02				db 1 + 1 
3567 .. 00			db "*",0              
3569				endm 
# End of macro CWHEAD
3569			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3569				; TODO add floating point number detection 
3569					if DEBUG_FORTH_WORDS_KEY 
3569						DMARK "MUL" 
3569 f5				push af  
356a 3a 7e 35			ld a, (.dmark)  
356d 32 7a ee			ld (debug_mark),a  
3570 3a 7f 35			ld a, (.dmark+1)  
3573 32 7b ee			ld (debug_mark+1),a  
3576 3a 80 35			ld a, (.dmark+2)  
3579 32 7c ee			ld (debug_mark+2),a  
357c 18 03			jr .pastdmark  
357e ..			.dmark: db "MUL"  
3581 f1			.pastdmark: pop af  
3582			endm  
# End of macro DMARK
3582						CALLMONITOR 
3582 cd ff 13			call break_point_state  
3585				endm  
# End of macro CALLMONITOR
3585					endif 
3585					FORTH_DSP 
3585 cd 49 1b			call macro_forth_dsp 
3588				endm 
# End of macro FORTH_DSP
3588					; v5 FORTH_DSP_VALUE 
3588 7e					ld a,(hl)	; get type of value on TOS 
3589 fe 02				cp DS_TYPE_INUM  
358b 28 03				jr z, .mul_inum 
358d			 
358d				if FORTH_ENABLE_FLOATMATH 
358d					jr .mul_done 
358d			 
358d				endif 
358d			 
358d					NEXTW 
358d c3 f5 1c			jp macro_next 
3590				endm 
# End of macro NEXTW
3590			.mul_inum:	 
3590			 
3590					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3590 cd 83 1b			call macro_dsp_valuehl 
3593				endm 
# End of macro FORTH_DSP_VALUEHL
3593			 
3593 e5					push hl 
3594			 
3594					; destroy value TOS 
3594			 
3594					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3594 cd 3b 1c			call macro_forth_dsp_pop 
3597				endm 
# End of macro FORTH_DSP_POP
3597			 
3597			 
3597					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3597 cd 83 1b			call macro_dsp_valuehl 
359a				endm 
# End of macro FORTH_DSP_VALUEHL
359a			 
359a					; one value on hl but move to a get other one back 
359a			 
359a 7d					ld a, l 
359b			 
359b d1					pop de 
359c			 
359c					; do the mull 
359c			;		ex de, hl 
359c			 
359c cd 35 0b				call Mult16 
359f					; save it 
359f			 
359f			;		push hl	 
359f			 
359f					; 
359f			 
359f					; destroy value TOS 
359f			 
359f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
359f cd 3b 1c			call macro_forth_dsp_pop 
35a2				endm 
# End of macro FORTH_DSP_POP
35a2			 
35a2					; TODO push value back onto stack for another op etc 
35a2			 
35a2			;		pop hl 
35a2			 
35a2 cd 8c 19				call forth_push_numhl 
35a5			 
35a5			.mul_done: 
35a5					NEXTW 
35a5 c3 f5 1c			jp macro_next 
35a8				endm 
# End of macro NEXTW
35a8			 
35a8			 
35a8			 
35a8			 
35a8			.MIN: 
35a8				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
35a8 49				db WORD_SYS_CORE+53             
35a9 29 36			dw .MAX            
35ab 04				db 3 + 1 
35ac .. 00			db "MIN",0              
35b0				endm 
# End of macro CWHEAD
35b0			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
35b0					if DEBUG_FORTH_WORDS_KEY 
35b0						DMARK "MIN" 
35b0 f5				push af  
35b1 3a c5 35			ld a, (.dmark)  
35b4 32 7a ee			ld (debug_mark),a  
35b7 3a c6 35			ld a, (.dmark+1)  
35ba 32 7b ee			ld (debug_mark+1),a  
35bd 3a c7 35			ld a, (.dmark+2)  
35c0 32 7c ee			ld (debug_mark+2),a  
35c3 18 03			jr .pastdmark  
35c5 ..			.dmark: db "MIN"  
35c8 f1			.pastdmark: pop af  
35c9			endm  
# End of macro DMARK
35c9						CALLMONITOR 
35c9 cd ff 13			call break_point_state  
35cc				endm  
# End of macro CALLMONITOR
35cc					endif 
35cc					; get u2 
35cc			 
35cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35cc cd 83 1b			call macro_dsp_valuehl 
35cf				endm 
# End of macro FORTH_DSP_VALUEHL
35cf			 
35cf e5					push hl   ; u2 
35d0			 
35d0					; destroy value TOS 
35d0			 
35d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d0 cd 3b 1c			call macro_forth_dsp_pop 
35d3				endm 
# End of macro FORTH_DSP_POP
35d3			 
35d3					; get u1 
35d3			 
35d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35d3 cd 83 1b			call macro_dsp_valuehl 
35d6				endm 
# End of macro FORTH_DSP_VALUEHL
35d6			 
35d6 e5					push hl  ; u1 
35d7			 
35d7					; destroy value TOS 
35d7			 
35d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d7 cd 3b 1c			call macro_forth_dsp_pop 
35da				endm 
# End of macro FORTH_DSP_POP
35da			 
35da b7			 or a      ;clear carry flag 
35db e1			  pop hl    ; u1 
35dc d1			  pop de    ; u2 
35dd e5				push hl   ; saved in case hl is lowest 
35de ed 52		  sbc hl,de 
35e0 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
35e2			 
35e2 e1				pop hl 
35e3					if DEBUG_FORTH_WORDS 
35e3						DMARK "MIN" 
35e3 f5				push af  
35e4 3a f8 35			ld a, (.dmark)  
35e7 32 7a ee			ld (debug_mark),a  
35ea 3a f9 35			ld a, (.dmark+1)  
35ed 32 7b ee			ld (debug_mark+1),a  
35f0 3a fa 35			ld a, (.dmark+2)  
35f3 32 7c ee			ld (debug_mark+2),a  
35f6 18 03			jr .pastdmark  
35f8 ..			.dmark: db "MIN"  
35fb f1			.pastdmark: pop af  
35fc			endm  
# End of macro DMARK
35fc						CALLMONITOR 
35fc cd ff 13			call break_point_state  
35ff				endm  
# End of macro CALLMONITOR
35ff					endif 
35ff cd 8c 19				call forth_push_numhl 
3602			 
3602				       NEXTW 
3602 c3 f5 1c			jp macro_next 
3605				endm 
# End of macro NEXTW
3605			 
3605			.mincont:  
3605 c1				pop bc   ; tidy up 
3606 eb				ex de , hl  
3607					if DEBUG_FORTH_WORDS 
3607						DMARK "MI1" 
3607 f5				push af  
3608 3a 1c 36			ld a, (.dmark)  
360b 32 7a ee			ld (debug_mark),a  
360e 3a 1d 36			ld a, (.dmark+1)  
3611 32 7b ee			ld (debug_mark+1),a  
3614 3a 1e 36			ld a, (.dmark+2)  
3617 32 7c ee			ld (debug_mark+2),a  
361a 18 03			jr .pastdmark  
361c ..			.dmark: db "MI1"  
361f f1			.pastdmark: pop af  
3620			endm  
# End of macro DMARK
3620						CALLMONITOR 
3620 cd ff 13			call break_point_state  
3623				endm  
# End of macro CALLMONITOR
3623					endif 
3623 cd 8c 19				call forth_push_numhl 
3626			 
3626				       NEXTW 
3626 c3 f5 1c			jp macro_next 
3629				endm 
# End of macro NEXTW
3629			.MAX: 
3629				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3629 4a				db WORD_SYS_CORE+54             
362a aa 36			dw .RND16            
362c 04				db 3 + 1 
362d .. 00			db "MAX",0              
3631				endm 
# End of macro CWHEAD
3631			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3631					if DEBUG_FORTH_WORDS_KEY 
3631						DMARK "MAX" 
3631 f5				push af  
3632 3a 46 36			ld a, (.dmark)  
3635 32 7a ee			ld (debug_mark),a  
3638 3a 47 36			ld a, (.dmark+1)  
363b 32 7b ee			ld (debug_mark+1),a  
363e 3a 48 36			ld a, (.dmark+2)  
3641 32 7c ee			ld (debug_mark+2),a  
3644 18 03			jr .pastdmark  
3646 ..			.dmark: db "MAX"  
3649 f1			.pastdmark: pop af  
364a			endm  
# End of macro DMARK
364a						CALLMONITOR 
364a cd ff 13			call break_point_state  
364d				endm  
# End of macro CALLMONITOR
364d					endif 
364d					; get u2 
364d			 
364d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
364d cd 83 1b			call macro_dsp_valuehl 
3650				endm 
# End of macro FORTH_DSP_VALUEHL
3650			 
3650 e5					push hl   ; u2 
3651			 
3651					; destroy value TOS 
3651			 
3651					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3651 cd 3b 1c			call macro_forth_dsp_pop 
3654				endm 
# End of macro FORTH_DSP_POP
3654			 
3654					; get u1 
3654			 
3654					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3654 cd 83 1b			call macro_dsp_valuehl 
3657				endm 
# End of macro FORTH_DSP_VALUEHL
3657			 
3657 e5					push hl  ; u1 
3658			 
3658					; destroy value TOS 
3658			 
3658					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3658 cd 3b 1c			call macro_forth_dsp_pop 
365b				endm 
# End of macro FORTH_DSP_POP
365b			 
365b b7			 or a      ;clear carry flag 
365c e1			  pop hl    ; u1 
365d d1			  pop de    ; u2 
365e e5				push hl   ; saved in case hl is lowest 
365f ed 52		  sbc hl,de 
3661 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3663			 
3663 e1				pop hl 
3664					if DEBUG_FORTH_WORDS 
3664						DMARK "MAX" 
3664 f5				push af  
3665 3a 79 36			ld a, (.dmark)  
3668 32 7a ee			ld (debug_mark),a  
366b 3a 7a 36			ld a, (.dmark+1)  
366e 32 7b ee			ld (debug_mark+1),a  
3671 3a 7b 36			ld a, (.dmark+2)  
3674 32 7c ee			ld (debug_mark+2),a  
3677 18 03			jr .pastdmark  
3679 ..			.dmark: db "MAX"  
367c f1			.pastdmark: pop af  
367d			endm  
# End of macro DMARK
367d						CALLMONITOR 
367d cd ff 13			call break_point_state  
3680				endm  
# End of macro CALLMONITOR
3680					endif 
3680 cd 8c 19				call forth_push_numhl 
3683			 
3683				       NEXTW 
3683 c3 f5 1c			jp macro_next 
3686				endm 
# End of macro NEXTW
3686			 
3686			.maxcont:  
3686 c1				pop bc   ; tidy up 
3687 eb				ex de , hl  
3688					if DEBUG_FORTH_WORDS 
3688						DMARK "MA1" 
3688 f5				push af  
3689 3a 9d 36			ld a, (.dmark)  
368c 32 7a ee			ld (debug_mark),a  
368f 3a 9e 36			ld a, (.dmark+1)  
3692 32 7b ee			ld (debug_mark+1),a  
3695 3a 9f 36			ld a, (.dmark+2)  
3698 32 7c ee			ld (debug_mark+2),a  
369b 18 03			jr .pastdmark  
369d ..			.dmark: db "MA1"  
36a0 f1			.pastdmark: pop af  
36a1			endm  
# End of macro DMARK
36a1						CALLMONITOR 
36a1 cd ff 13			call break_point_state  
36a4				endm  
# End of macro CALLMONITOR
36a4					endif 
36a4 cd 8c 19				call forth_push_numhl 
36a7				       NEXTW 
36a7 c3 f5 1c			jp macro_next 
36aa				endm 
# End of macro NEXTW
36aa			 
36aa			.RND16: 
36aa				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
36aa 4e				db WORD_SYS_CORE+58             
36ab d9 36			dw .RND8            
36ad 06				db 5 + 1 
36ae .. 00			db "RND16",0              
36b4				endm 
# End of macro CWHEAD
36b4			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
36b4					if DEBUG_FORTH_WORDS_KEY 
36b4						DMARK "R16" 
36b4 f5				push af  
36b5 3a c9 36			ld a, (.dmark)  
36b8 32 7a ee			ld (debug_mark),a  
36bb 3a ca 36			ld a, (.dmark+1)  
36be 32 7b ee			ld (debug_mark+1),a  
36c1 3a cb 36			ld a, (.dmark+2)  
36c4 32 7c ee			ld (debug_mark+2),a  
36c7 18 03			jr .pastdmark  
36c9 ..			.dmark: db "R16"  
36cc f1			.pastdmark: pop af  
36cd			endm  
# End of macro DMARK
36cd						CALLMONITOR 
36cd cd ff 13			call break_point_state  
36d0				endm  
# End of macro CALLMONITOR
36d0					endif 
36d0 cd d9 0a				call prng16  
36d3 cd 8c 19				call forth_push_numhl 
36d6				       NEXTW 
36d6 c3 f5 1c			jp macro_next 
36d9				endm 
# End of macro NEXTW
36d9			.RND8: 
36d9				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
36d9 60				db WORD_SYS_CORE+76             
36da 0e 37			dw .RND            
36dc 05				db 4 + 1 
36dd .. 00			db "RND8",0              
36e2				endm 
# End of macro CWHEAD
36e2			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
36e2					if DEBUG_FORTH_WORDS_KEY 
36e2						DMARK "RN8" 
36e2 f5				push af  
36e3 3a f7 36			ld a, (.dmark)  
36e6 32 7a ee			ld (debug_mark),a  
36e9 3a f8 36			ld a, (.dmark+1)  
36ec 32 7b ee			ld (debug_mark+1),a  
36ef 3a f9 36			ld a, (.dmark+2)  
36f2 32 7c ee			ld (debug_mark+2),a  
36f5 18 03			jr .pastdmark  
36f7 ..			.dmark: db "RN8"  
36fa f1			.pastdmark: pop af  
36fb			endm  
# End of macro DMARK
36fb						CALLMONITOR 
36fb cd ff 13			call break_point_state  
36fe				endm  
# End of macro CALLMONITOR
36fe					endif 
36fe 2a bb eb				ld hl,(xrandc) 
3701 23					inc hl 
3702 cd f3 0a				call xrnd 
3705 6f					ld l,a	 
3706 26 00				ld h,0 
3708 cd 8c 19				call forth_push_numhl 
370b				       NEXTW 
370b c3 f5 1c			jp macro_next 
370e				endm 
# End of macro NEXTW
370e			.RND: 
370e				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
370e 60				db WORD_SYS_CORE+76             
370f 14 38			dw .ENDMATHS            
3711 04				db 3 + 1 
3712 .. 00			db "RND",0              
3716				endm 
# End of macro CWHEAD
3716			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3716			 
3716					if DEBUG_FORTH_WORDS_KEY 
3716						DMARK "RND" 
3716 f5				push af  
3717 3a 2b 37			ld a, (.dmark)  
371a 32 7a ee			ld (debug_mark),a  
371d 3a 2c 37			ld a, (.dmark+1)  
3720 32 7b ee			ld (debug_mark+1),a  
3723 3a 2d 37			ld a, (.dmark+2)  
3726 32 7c ee			ld (debug_mark+2),a  
3729 18 03			jr .pastdmark  
372b ..			.dmark: db "RND"  
372e f1			.pastdmark: pop af  
372f			endm  
# End of macro DMARK
372f						CALLMONITOR 
372f cd ff 13			call break_point_state  
3732				endm  
# End of macro CALLMONITOR
3732					endif 
3732					 
3732					FORTH_DSP_VALUEHL    ; upper range 
3732 cd 83 1b			call macro_dsp_valuehl 
3735				endm 
# End of macro FORTH_DSP_VALUEHL
3735			 
3735 22 bf eb				ld (LFSRSeed), hl	 
3738			 
3738					if DEBUG_FORTH_WORDS 
3738						DMARK "RN1" 
3738 f5				push af  
3739 3a 4d 37			ld a, (.dmark)  
373c 32 7a ee			ld (debug_mark),a  
373f 3a 4e 37			ld a, (.dmark+1)  
3742 32 7b ee			ld (debug_mark+1),a  
3745 3a 4f 37			ld a, (.dmark+2)  
3748 32 7c ee			ld (debug_mark+2),a  
374b 18 03			jr .pastdmark  
374d ..			.dmark: db "RN1"  
3750 f1			.pastdmark: pop af  
3751			endm  
# End of macro DMARK
3751						CALLMONITOR 
3751 cd ff 13			call break_point_state  
3754				endm  
# End of macro CALLMONITOR
3754					endif 
3754					FORTH_DSP_POP 
3754 cd 3b 1c			call macro_forth_dsp_pop 
3757				endm 
# End of macro FORTH_DSP_POP
3757			 
3757					FORTH_DSP_VALUEHL    ; low range 
3757 cd 83 1b			call macro_dsp_valuehl 
375a				endm 
# End of macro FORTH_DSP_VALUEHL
375a			 
375a					if DEBUG_FORTH_WORDS 
375a						DMARK "RN2" 
375a f5				push af  
375b 3a 6f 37			ld a, (.dmark)  
375e 32 7a ee			ld (debug_mark),a  
3761 3a 70 37			ld a, (.dmark+1)  
3764 32 7b ee			ld (debug_mark+1),a  
3767 3a 71 37			ld a, (.dmark+2)  
376a 32 7c ee			ld (debug_mark+2),a  
376d 18 03			jr .pastdmark  
376f ..			.dmark: db "RN2"  
3772 f1			.pastdmark: pop af  
3773			endm  
# End of macro DMARK
3773						CALLMONITOR 
3773 cd ff 13			call break_point_state  
3776				endm  
# End of macro CALLMONITOR
3776					endif 
3776 22 c1 eb				ld (LFSRSeed+2), hl 
3779			 
3779					FORTH_DSP_POP 
3779 cd 3b 1c			call macro_forth_dsp_pop 
377c				endm 
# End of macro FORTH_DSP_POP
377c			 
377c e5					push hl 
377d			 
377d e1			.inrange:	pop hl 
377e cd d9 0a				call prng16  
3781					if DEBUG_FORTH_WORDS 
3781						DMARK "RN3" 
3781 f5				push af  
3782 3a 96 37			ld a, (.dmark)  
3785 32 7a ee			ld (debug_mark),a  
3788 3a 97 37			ld a, (.dmark+1)  
378b 32 7b ee			ld (debug_mark+1),a  
378e 3a 98 37			ld a, (.dmark+2)  
3791 32 7c ee			ld (debug_mark+2),a  
3794 18 03			jr .pastdmark  
3796 ..			.dmark: db "RN3"  
3799 f1			.pastdmark: pop af  
379a			endm  
# End of macro DMARK
379a						CALLMONITOR 
379a cd ff 13			call break_point_state  
379d				endm  
# End of macro CALLMONITOR
379d					endif 
379d					 
379d					; if the range is 8bit knock out the high byte 
379d			 
379d ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
37a1			 
37a1 3e 00				ld a, 0 
37a3 ba					cp d  
37a4 20 1e				jr nz, .hirange 
37a6 26 00				ld h, 0   ; knock it down to 8bit 
37a8			 
37a8					if DEBUG_FORTH_WORDS 
37a8						DMARK "RNk" 
37a8 f5				push af  
37a9 3a bd 37			ld a, (.dmark)  
37ac 32 7a ee			ld (debug_mark),a  
37af 3a be 37			ld a, (.dmark+1)  
37b2 32 7b ee			ld (debug_mark+1),a  
37b5 3a bf 37			ld a, (.dmark+2)  
37b8 32 7c ee			ld (debug_mark+2),a  
37bb 18 03			jr .pastdmark  
37bd ..			.dmark: db "RNk"  
37c0 f1			.pastdmark: pop af  
37c1			endm  
# End of macro DMARK
37c1						CALLMONITOR 
37c1 cd ff 13			call break_point_state  
37c4				endm  
# End of macro CALLMONITOR
37c4					endif 
37c4			.hirange:   
37c4 e5					push hl  
37c5 b7					or a  
37c6 ed 52		                sbc hl, de 
37c8			 
37c8					;call cmp16 
37c8			 
37c8 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
37ca e1					pop hl 
37cb e5					push hl 
37cc			 
37cc					if DEBUG_FORTH_WORDS 
37cc						DMARK "RN4" 
37cc f5				push af  
37cd 3a e1 37			ld a, (.dmark)  
37d0 32 7a ee			ld (debug_mark),a  
37d3 3a e2 37			ld a, (.dmark+1)  
37d6 32 7b ee			ld (debug_mark+1),a  
37d9 3a e3 37			ld a, (.dmark+2)  
37dc 32 7c ee			ld (debug_mark+2),a  
37df 18 03			jr .pastdmark  
37e1 ..			.dmark: db "RN4"  
37e4 f1			.pastdmark: pop af  
37e5			endm  
# End of macro DMARK
37e5						CALLMONITOR 
37e5 cd ff 13			call break_point_state  
37e8				endm  
# End of macro CALLMONITOR
37e8					endif 
37e8 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
37ec					;call cmp16 
37ec				 
37ec b7					or a  
37ed ed 52		                sbc hl, de 
37ef 38 8c				jr c, .inrange 
37f1			 
37f1 e1					pop hl 
37f2					 
37f2					if DEBUG_FORTH_WORDS 
37f2						DMARK "RNd" 
37f2 f5				push af  
37f3 3a 07 38			ld a, (.dmark)  
37f6 32 7a ee			ld (debug_mark),a  
37f9 3a 08 38			ld a, (.dmark+1)  
37fc 32 7b ee			ld (debug_mark+1),a  
37ff 3a 09 38			ld a, (.dmark+2)  
3802 32 7c ee			ld (debug_mark+2),a  
3805 18 03			jr .pastdmark  
3807 ..			.dmark: db "RNd"  
380a f1			.pastdmark: pop af  
380b			endm  
# End of macro DMARK
380b						CALLMONITOR 
380b cd ff 13			call break_point_state  
380e				endm  
# End of macro CALLMONITOR
380e					endif 
380e			 
380e			 
380e cd 8c 19				call forth_push_numhl 
3811				       NEXTW 
3811 c3 f5 1c			jp macro_next 
3814				endm 
# End of macro NEXTW
3814			 
3814			.ENDMATHS: 
3814			 
3814			; eof 
3814			 
# End of file forth_words_maths.asm
3814			include "forth_words_display.asm" 
3814			 
3814			; | ## Display Words 
3814			 
3814			.ATP: 
3814				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3814 62				db WORD_SYS_CORE+78             
3815 8b 38			dw .FB            
3817 04				db 3 + 1 
3818 .. 00			db "AT?",0              
381c				endm 
# End of macro CWHEAD
381c			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
381c					if DEBUG_FORTH_WORDS_KEY 
381c						DMARK "AT?" 
381c f5				push af  
381d 3a 31 38			ld a, (.dmark)  
3820 32 7a ee			ld (debug_mark),a  
3823 3a 32 38			ld a, (.dmark+1)  
3826 32 7b ee			ld (debug_mark+1),a  
3829 3a 33 38			ld a, (.dmark+2)  
382c 32 7c ee			ld (debug_mark+2),a  
382f 18 03			jr .pastdmark  
3831 ..			.dmark: db "AT?"  
3834 f1			.pastdmark: pop af  
3835			endm  
# End of macro DMARK
3835						CALLMONITOR 
3835 cd ff 13			call break_point_state  
3838				endm  
# End of macro CALLMONITOR
3838					endif 
3838 3a 49 eb				ld a, (f_cursor_ptr) 
383b			 
383b			if DEBUG_FORTH_WORDS 
383b				DMARK "AT?" 
383b f5				push af  
383c 3a 50 38			ld a, (.dmark)  
383f 32 7a ee			ld (debug_mark),a  
3842 3a 51 38			ld a, (.dmark+1)  
3845 32 7b ee			ld (debug_mark+1),a  
3848 3a 52 38			ld a, (.dmark+2)  
384b 32 7c ee			ld (debug_mark+2),a  
384e 18 03			jr .pastdmark  
3850 ..			.dmark: db "AT?"  
3853 f1			.pastdmark: pop af  
3854			endm  
# End of macro DMARK
3854				CALLMONITOR 
3854 cd ff 13			call break_point_state  
3857				endm  
# End of macro CALLMONITOR
3857			endif	 
3857					; count the number of rows 
3857			 
3857 06 00				ld b, 0 
3859 4f			.atpr:		ld c, a    ; save in case we go below zero 
385a d6 28				sub display_cols 
385c f2 62 38				jp p, .atprunder 
385f 04					inc b 
3860 18 f7				jr .atpr 
3862			.atprunder:	 
3862			if DEBUG_FORTH_WORDS 
3862				DMARK "A?2" 
3862 f5				push af  
3863 3a 77 38			ld a, (.dmark)  
3866 32 7a ee			ld (debug_mark),a  
3869 3a 78 38			ld a, (.dmark+1)  
386c 32 7b ee			ld (debug_mark+1),a  
386f 3a 79 38			ld a, (.dmark+2)  
3872 32 7c ee			ld (debug_mark+2),a  
3875 18 03			jr .pastdmark  
3877 ..			.dmark: db "A?2"  
387a f1			.pastdmark: pop af  
387b			endm  
# End of macro DMARK
387b				CALLMONITOR 
387b cd ff 13			call break_point_state  
387e				endm  
# End of macro CALLMONITOR
387e			endif	 
387e 26 00				ld h, 0 
3880 69					ld l, c 
3881 cd 8c 19				call forth_push_numhl 
3884 68					ld l, b  
3885 cd 8c 19				call forth_push_numhl 
3888			 
3888			 
3888				NEXTW 
3888 c3 f5 1c			jp macro_next 
388b				endm 
# End of macro NEXTW
388b			 
388b			.FB: 
388b				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
388b 1b				db WORD_SYS_CORE+7             
388c d9 38			dw .EMIT            
388e 03				db 2 + 1 
388f .. 00			db "FB",0              
3892				endm 
# End of macro CWHEAD
3892			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3892			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3892			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3892			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3892					if DEBUG_FORTH_WORDS_KEY 
3892						DMARK "FB." 
3892 f5				push af  
3893 3a a7 38			ld a, (.dmark)  
3896 32 7a ee			ld (debug_mark),a  
3899 3a a8 38			ld a, (.dmark+1)  
389c 32 7b ee			ld (debug_mark+1),a  
389f 3a a9 38			ld a, (.dmark+2)  
38a2 32 7c ee			ld (debug_mark+2),a  
38a5 18 03			jr .pastdmark  
38a7 ..			.dmark: db "FB."  
38aa f1			.pastdmark: pop af  
38ab			endm  
# End of macro DMARK
38ab						CALLMONITOR 
38ab cd ff 13			call break_point_state  
38ae				endm  
# End of macro CALLMONITOR
38ae					endif 
38ae			 
38ae					FORTH_DSP_VALUEHL 
38ae cd 83 1b			call macro_dsp_valuehl 
38b1				endm 
# End of macro FORTH_DSP_VALUEHL
38b1			 
38b1 7d					ld a, l 
38b2 fe 01				cp 1 
38b4 20 05				jr nz, .fbn1 
38b6 21 1f ed				ld hl, display_fb1 
38b9 18 15				jr .fbset 
38bb fe 02		.fbn1:		cp 2 
38bd 20 05				jr nz, .fbn2 
38bf 21 dd eb				ld hl, display_fb2 
38c2 18 0c				jr .fbset 
38c4 fe 03		.fbn2:		cp 3 
38c6 20 05				jr nz, .fbn3 
38c8 21 7e ec				ld hl, display_fb3 
38cb 18 03				jr .fbset 
38cd			.fbn3:		 ; if invalid number select first 
38cd 21 1f ed				ld hl, display_fb1 
38d0 22 db eb		.fbset:		ld (display_fb_active), hl 
38d3			 
38d3					FORTH_DSP_POP 
38d3 cd 3b 1c			call macro_forth_dsp_pop 
38d6				endm 
# End of macro FORTH_DSP_POP
38d6			 
38d6					NEXTW 
38d6 c3 f5 1c			jp macro_next 
38d9				endm 
# End of macro NEXTW
38d9			 
38d9			 
38d9			.EMIT: 
38d9				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
38d9 1b				db WORD_SYS_CORE+7             
38da 2a 39			dw .DOTH            
38dc 05				db 4 + 1 
38dd .. 00			db "EMIT",0              
38e2				endm 
# End of macro CWHEAD
38e2			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
38e2					; get value off TOS and display it 
38e2			 
38e2					if DEBUG_FORTH_WORDS_KEY 
38e2						DMARK "EMT" 
38e2 f5				push af  
38e3 3a f7 38			ld a, (.dmark)  
38e6 32 7a ee			ld (debug_mark),a  
38e9 3a f8 38			ld a, (.dmark+1)  
38ec 32 7b ee			ld (debug_mark+1),a  
38ef 3a f9 38			ld a, (.dmark+2)  
38f2 32 7c ee			ld (debug_mark+2),a  
38f5 18 03			jr .pastdmark  
38f7 ..			.dmark: db "EMT"  
38fa f1			.pastdmark: pop af  
38fb			endm  
# End of macro DMARK
38fb						CALLMONITOR 
38fb cd ff 13			call break_point_state  
38fe				endm  
# End of macro CALLMONITOR
38fe					endif 
38fe			 
38fe					FORTH_DSP_VALUEHL 
38fe cd 83 1b			call macro_dsp_valuehl 
3901				endm 
# End of macro FORTH_DSP_VALUEHL
3901			 
3901 7d					ld a,l 
3902			 
3902					; TODO write to display 
3902			 
3902 32 5e e5				ld (os_input), a 
3905 3e 00				ld a, 0 
3907 32 5f e5				ld (os_input+1), a 
390a					 
390a 3a 49 eb				ld a, (f_cursor_ptr) 
390d 11 5e e5				ld de, os_input 
3910 cd 98 09				call str_at_display 
3913			 
3913			 
3913 3a 27 eb				ld a,(cli_autodisplay) 
3916 fe 00				cp 0 
3918 28 03				jr z, .enoupdate 
391a cd a8 09						call update_display 
391d					.enoupdate: 
391d			 
391d 3a 49 eb				ld a, (f_cursor_ptr) 
3920 3c					inc a 
3921 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
3924			 
3924			 
3924					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3924 cd 3b 1c			call macro_forth_dsp_pop 
3927				endm 
# End of macro FORTH_DSP_POP
3927			  
3927			 
3927					NEXTW 
3927 c3 f5 1c			jp macro_next 
392a				endm 
# End of macro NEXTW
392a			.DOTH: 
392a				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
392a 1c				db WORD_SYS_CORE+8             
392b 5a 39			dw .DOTF            
392d 03				db 2 + 1 
392e .. 00			db ".-",0              
3931				endm 
# End of macro CWHEAD
3931			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3931					; get value off TOS and display it 
3931					if DEBUG_FORTH_WORDS_KEY 
3931						DMARK "DTD" 
3931 f5				push af  
3932 3a 46 39			ld a, (.dmark)  
3935 32 7a ee			ld (debug_mark),a  
3938 3a 47 39			ld a, (.dmark+1)  
393b 32 7b ee			ld (debug_mark+1),a  
393e 3a 48 39			ld a, (.dmark+2)  
3941 32 7c ee			ld (debug_mark+2),a  
3944 18 03			jr .pastdmark  
3946 ..			.dmark: db "DTD"  
3949 f1			.pastdmark: pop af  
394a			endm  
# End of macro DMARK
394a						CALLMONITOR 
394a cd ff 13			call break_point_state  
394d				endm  
# End of macro CALLMONITOR
394d					endif 
394d 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
394f 3e 00			ld a, 0 
3951 32 28 eb			ld (cli_mvdot), a 
3954 c3 b1 39			jp .dotgo 
3957				NEXTW 
3957 c3 f5 1c			jp macro_next 
395a				endm 
# End of macro NEXTW
395a			.DOTF: 
395a				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
395a 1c				db WORD_SYS_CORE+8             
395b 88 39			dw .DOT            
395d 03				db 2 + 1 
395e .. 00			db ".>",0              
3961				endm 
# End of macro CWHEAD
3961			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3961					; get value off TOS and display it 
3961			        ; TODO BUG adds extra spaces 
3961			        ; TODO BUG handle numerics? 
3961					if DEBUG_FORTH_WORDS_KEY 
3961						DMARK "DTC" 
3961 f5				push af  
3962 3a 76 39			ld a, (.dmark)  
3965 32 7a ee			ld (debug_mark),a  
3968 3a 77 39			ld a, (.dmark+1)  
396b 32 7b ee			ld (debug_mark+1),a  
396e 3a 78 39			ld a, (.dmark+2)  
3971 32 7c ee			ld (debug_mark+2),a  
3974 18 03			jr .pastdmark  
3976 ..			.dmark: db "DTC"  
3979 f1			.pastdmark: pop af  
397a			endm  
# End of macro DMARK
397a						CALLMONITOR 
397a cd ff 13			call break_point_state  
397d				endm  
# End of macro CALLMONITOR
397d					endif 
397d 3e 01			ld a, 1 
397f 32 28 eb			ld (cli_mvdot), a 
3982 c3 b1 39			jp .dotgo 
3985				NEXTW 
3985 c3 f5 1c			jp macro_next 
3988				endm 
# End of macro NEXTW
3988			 
3988			.DOT: 
3988				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3988 1c				db WORD_SYS_CORE+8             
3989 14 3a			dw .CLS            
398b 02				db 1 + 1 
398c .. 00			db ".",0              
398e				endm 
# End of macro CWHEAD
398e			        ; | . ( u -- ) Display TOS | DONE 
398e					; get value off TOS and display it 
398e			 
398e					if DEBUG_FORTH_WORDS_KEY 
398e						DMARK "DOT" 
398e f5				push af  
398f 3a a3 39			ld a, (.dmark)  
3992 32 7a ee			ld (debug_mark),a  
3995 3a a4 39			ld a, (.dmark+1)  
3998 32 7b ee			ld (debug_mark+1),a  
399b 3a a5 39			ld a, (.dmark+2)  
399e 32 7c ee			ld (debug_mark+2),a  
39a1 18 03			jr .pastdmark  
39a3 ..			.dmark: db "DOT"  
39a6 f1			.pastdmark: pop af  
39a7			endm  
# End of macro DMARK
39a7						CALLMONITOR 
39a7 cd ff 13			call break_point_state  
39aa				endm  
# End of macro CALLMONITOR
39aa					endif 
39aa 3e 00			ld a, 0 
39ac 32 28 eb			ld (cli_mvdot), a 
39af 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
39b1				 
39b1			 
39b1			.dotgo: 
39b1			 
39b1			; move up type to on stack for parserv5 
39b1					FORTH_DSP 
39b1 cd 49 1b			call macro_forth_dsp 
39b4				endm 
# End of macro FORTH_DSP
39b4				;FORTH_DSP_VALUE  
39b4			 
39b4			if DEBUG_FORTH_DOT 
39b4				DMARK "DOT" 
39b4				CALLMONITOR 
39b4			endif	 
39b4			;		.print: 
39b4			 
39b4 7e				ld a,(hl)  ; work out what type of value is on the TOS 
39b5 23				inc hl   ; position to the actual value 
39b6 fe 01			cp DS_TYPE_STR 
39b8 20 06			jr nz, .dotnum1  
39ba			 
39ba			; display string 
39ba				FORTH_DSP_VALUE  
39ba cd 6c 1b			call macro_forth_dsp_value 
39bd				endm 
# End of macro FORTH_DSP_VALUE
39bd eb				ex de,hl 
39be 18 11			jr .dotwrite 
39c0			 
39c0			.dotnum1: 
39c0 fe 02			cp DS_TYPE_INUM 
39c2 20 0c			jr nz, .dotflot 
39c4			 
39c4			 
39c4			; display number 
39c4			 
39c4			;	push hl 
39c4			;	call clear_display 
39c4			;	pop hl 
39c4			 
39c4 5e				ld e, (hl) 
39c5 23				inc hl 
39c6 56				ld d, (hl) 
39c7 21 60 e3			ld hl, scratch 
39ca			if DEBUG_FORTH_DOT 
39ca				DMARK "DT1" 
39ca				CALLMONITOR 
39ca			endif	 
39ca			 
39ca cd bf 0f			call uitoa_16 
39cd eb				ex de,hl 
39ce			 
39ce			if DEBUG_FORTH_DOT 
39ce				DMARK "DT2" 
39ce				CALLMONITOR 
39ce			endif	 
39ce			 
39ce			;	ld de, os_word_scratch 
39ce 18 01			jr .dotwrite 
39d0			 
39d0 00			.dotflot:   nop 
39d1			; TODO print floating point number 
39d1			 
39d1			.dotwrite:		 
39d1			 
39d1					; if c is set then set all '-' to spaces 
39d1					; need to also take into account .>  
39d1			 
39d1 3e 01				ld a, 1 
39d3 b9					cp c 
39d4 20 13				jr nz, .nodashswap 
39d6			 
39d6					; DE has the string to write, working with HL 
39d6			 
39d6 06 ff				ld b, 255 
39d8 d5					push de 
39d9 e1					pop hl 
39da			 
39da			if DEBUG_FORTH_DOT 
39da				DMARK "DT-" 
39da				CALLMONITOR 
39da			endif	 
39da 7e			.dashscan:	ld a, (hl) 
39db fe 00				cp 0 
39dd 28 0a				jr z, .nodashswap 
39df fe 2d				cp '-' 
39e1 20 03				jr nz, .dashskip 
39e3 3e 20				ld a, ' ' 
39e5 77					ld (hl), a 
39e6 23			.dashskip:	inc hl 
39e7			if DEBUG_FORTH_DOT 
39e7				DMARK "D-2" 
39e7				CALLMONITOR 
39e7			endif	 
39e7 10 f1				djnz .dashscan 
39e9			 
39e9			if DEBUG_FORTH_DOT 
39e9				DMARK "D-1" 
39e9				CALLMONITOR 
39e9			endif	 
39e9			 
39e9			.nodashswap: 
39e9			 
39e9 e5					push hl   ; save string start in case we need to advance print 
39ea			 
39ea 3a 49 eb				ld a, (f_cursor_ptr) 
39ed cd 98 09				call str_at_display 
39f0 3a 27 eb				ld a,(cli_autodisplay) 
39f3 fe 00				cp 0 
39f5 28 03				jr z, .noupdate 
39f7 cd a8 09						call update_display 
39fa					.noupdate: 
39fa			 
39fa			 
39fa					; see if we need to advance the print position 
39fa			 
39fa e1					pop hl   ; get back string 
39fb			 
39fb 3a 28 eb				ld a, (cli_mvdot) 
39fe			if DEBUG_FORTH_DOT 
39fe					ld e,a 
39fe				DMARK "D>1" 
39fe				CALLMONITOR 
39fe			endif	 
39fe fe 00				cp 0 
3a00 28 0c				jr z, .noadv 
3a02					; yes, lets advance the print position 
3a02 3e 00				ld a, 0 
3a04 cd 1b 10				call strlent 
3a07 3a 49 eb				ld a, (f_cursor_ptr) 
3a0a 85					add a,l 
3a0b					;call addatohl 
3a0b					;ld a, l 
3a0b 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
3a0e			 
3a0e			if DEBUG_FORTH_DOT 
3a0e				DMARK "D->" 
3a0e				CALLMONITOR 
3a0e			endif	 
3a0e			 
3a0e			.noadv:	 
3a0e			 
3a0e					if DEBUG_FORTH_DOT_WAIT 
3a0e							call next_page_prompt 
3a0e					endif	 
3a0e			; TODO this pop off the stack causes a crash. i dont know why 
3a0e			 
3a0e			 
3a0e			if DEBUG_FORTH_DOT 
3a0e				DMARK "DTh" 
3a0e				CALLMONITOR 
3a0e			endif	 
3a0e			 
3a0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a0e cd 3b 1c			call macro_forth_dsp_pop 
3a11				endm 
# End of macro FORTH_DSP_POP
3a11			 
3a11			if DEBUG_FORTH_DOT 
3a11				DMARK "DTi" 
3a11				CALLMONITOR 
3a11			endif	 
3a11			 
3a11			 
3a11					NEXTW 
3a11 c3 f5 1c			jp macro_next 
3a14				endm 
# End of macro NEXTW
3a14			 
3a14			.CLS: 
3a14				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3a14 35				db WORD_SYS_CORE+33             
3a15 41 3a			dw .DRAW            
3a17 04				db 3 + 1 
3a18 .. 00			db "CLS",0              
3a1c				endm 
# End of macro CWHEAD
3a1c			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3a1c					if DEBUG_FORTH_WORDS_KEY 
3a1c						DMARK "CLS" 
3a1c f5				push af  
3a1d 3a 31 3a			ld a, (.dmark)  
3a20 32 7a ee			ld (debug_mark),a  
3a23 3a 32 3a			ld a, (.dmark+1)  
3a26 32 7b ee			ld (debug_mark+1),a  
3a29 3a 33 3a			ld a, (.dmark+2)  
3a2c 32 7c ee			ld (debug_mark+2),a  
3a2f 18 03			jr .pastdmark  
3a31 ..			.dmark: db "CLS"  
3a34 f1			.pastdmark: pop af  
3a35			endm  
# End of macro DMARK
3a35						CALLMONITOR 
3a35 cd ff 13			call break_point_state  
3a38				endm  
# End of macro CALLMONITOR
3a38					endif 
3a38 cd 85 09				call clear_display 
3a3b c3 4f 3b				jp .home		; and home cursor 
3a3e					NEXTW 
3a3e c3 f5 1c			jp macro_next 
3a41				endm 
# End of macro NEXTW
3a41			 
3a41			.DRAW: 
3a41				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3a41 36				db WORD_SYS_CORE+34             
3a42 6c 3a			dw .DUMP            
3a44 05				db 4 + 1 
3a45 .. 00			db "DRAW",0              
3a4a				endm 
# End of macro CWHEAD
3a4a			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3a4a					if DEBUG_FORTH_WORDS_KEY 
3a4a						DMARK "DRW" 
3a4a f5				push af  
3a4b 3a 5f 3a			ld a, (.dmark)  
3a4e 32 7a ee			ld (debug_mark),a  
3a51 3a 60 3a			ld a, (.dmark+1)  
3a54 32 7b ee			ld (debug_mark+1),a  
3a57 3a 61 3a			ld a, (.dmark+2)  
3a5a 32 7c ee			ld (debug_mark+2),a  
3a5d 18 03			jr .pastdmark  
3a5f ..			.dmark: db "DRW"  
3a62 f1			.pastdmark: pop af  
3a63			endm  
# End of macro DMARK
3a63						CALLMONITOR 
3a63 cd ff 13			call break_point_state  
3a66				endm  
# End of macro CALLMONITOR
3a66					endif 
3a66 cd a8 09				call update_display 
3a69					NEXTW 
3a69 c3 f5 1c			jp macro_next 
3a6c				endm 
# End of macro NEXTW
3a6c			 
3a6c			.DUMP: 
3a6c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3a6c 37				db WORD_SYS_CORE+35             
3a6d a4 3a			dw .CDUMP            
3a6f 05				db 4 + 1 
3a70 .. 00			db "DUMP",0              
3a75				endm 
# End of macro CWHEAD
3a75			; | DUMP ( x -- ) With address x display dump   | DONE 
3a75			; TODO pop address to use off of the stack 
3a75					if DEBUG_FORTH_WORDS_KEY 
3a75						DMARK "DUM" 
3a75 f5				push af  
3a76 3a 8a 3a			ld a, (.dmark)  
3a79 32 7a ee			ld (debug_mark),a  
3a7c 3a 8b 3a			ld a, (.dmark+1)  
3a7f 32 7b ee			ld (debug_mark+1),a  
3a82 3a 8c 3a			ld a, (.dmark+2)  
3a85 32 7c ee			ld (debug_mark+2),a  
3a88 18 03			jr .pastdmark  
3a8a ..			.dmark: db "DUM"  
3a8d f1			.pastdmark: pop af  
3a8e			endm  
# End of macro DMARK
3a8e						CALLMONITOR 
3a8e cd ff 13			call break_point_state  
3a91				endm  
# End of macro CALLMONITOR
3a91					endif 
3a91 cd 85 09				call clear_display 
3a94			 
3a94					; get address 
3a94			 
3a94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a94 cd 83 1b			call macro_dsp_valuehl 
3a97				endm 
# End of macro FORTH_DSP_VALUEHL
3a97				 
3a97					; save it for cdump 
3a97			 
3a97 22 83 e6				ld (os_cur_ptr),hl 
3a9a			 
3a9a					; destroy value TOS 
3a9a			 
3a9a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9a cd 3b 1c			call macro_forth_dsp_pop 
3a9d				endm 
# End of macro FORTH_DSP_POP
3a9d			 
3a9d cd 0c 18				call dumpcont	; skip old style of param parsing	 
3aa0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3aa1					NEXTW 
3aa1 c3 f5 1c			jp macro_next 
3aa4				endm 
# End of macro NEXTW
3aa4			.CDUMP: 
3aa4				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3aa4 38				db WORD_SYS_CORE+36             
3aa5 d4 3a			dw .DAT            
3aa7 06				db 5 + 1 
3aa8 .. 00			db "CDUMP",0              
3aae				endm 
# End of macro CWHEAD
3aae			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3aae					if DEBUG_FORTH_WORDS_KEY 
3aae						DMARK "CDP" 
3aae f5				push af  
3aaf 3a c3 3a			ld a, (.dmark)  
3ab2 32 7a ee			ld (debug_mark),a  
3ab5 3a c4 3a			ld a, (.dmark+1)  
3ab8 32 7b ee			ld (debug_mark+1),a  
3abb 3a c5 3a			ld a, (.dmark+2)  
3abe 32 7c ee			ld (debug_mark+2),a  
3ac1 18 03			jr .pastdmark  
3ac3 ..			.dmark: db "CDP"  
3ac6 f1			.pastdmark: pop af  
3ac7			endm  
# End of macro DMARK
3ac7						CALLMONITOR 
3ac7 cd ff 13			call break_point_state  
3aca				endm  
# End of macro CALLMONITOR
3aca					endif 
3aca cd 85 09				call clear_display 
3acd cd 0c 18				call dumpcont	 
3ad0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ad1					NEXTW 
3ad1 c3 f5 1c			jp macro_next 
3ad4				endm 
# End of macro NEXTW
3ad4			 
3ad4			 
3ad4			 
3ad4			 
3ad4			.DAT: 
3ad4				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3ad4 3d				db WORD_SYS_CORE+41             
3ad5 2a 3b			dw .HOME            
3ad7 03				db 2 + 1 
3ad8 .. 00			db "AT",0              
3adb				endm 
# End of macro CWHEAD
3adb			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3adb					if DEBUG_FORTH_WORDS_KEY 
3adb						DMARK "AT." 
3adb f5				push af  
3adc 3a f0 3a			ld a, (.dmark)  
3adf 32 7a ee			ld (debug_mark),a  
3ae2 3a f1 3a			ld a, (.dmark+1)  
3ae5 32 7b ee			ld (debug_mark+1),a  
3ae8 3a f2 3a			ld a, (.dmark+2)  
3aeb 32 7c ee			ld (debug_mark+2),a  
3aee 18 03			jr .pastdmark  
3af0 ..			.dmark: db "AT."  
3af3 f1			.pastdmark: pop af  
3af4			endm  
# End of macro DMARK
3af4						CALLMONITOR 
3af4 cd ff 13			call break_point_state  
3af7				endm  
# End of macro CALLMONITOR
3af7					endif 
3af7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3af7 cd 83 1b			call macro_dsp_valuehl 
3afa				endm 
# End of macro FORTH_DSP_VALUEHL
3afa			 
3afa			 
3afa					; TODO save cursor row 
3afa 7d					ld a,l 
3afb fe 02				cp 2 
3afd 20 04				jr nz, .crow3 
3aff 3e 28				ld a, display_row_2 
3b01 18 12				jr .ccol1 
3b03 fe 03		.crow3:		cp 3 
3b05 20 04				jr nz, .crow4 
3b07 3e 50				ld a, display_row_3 
3b09 18 0a				jr .ccol1 
3b0b fe 04		.crow4:		cp 4 
3b0d 20 04				jr nz, .crow1 
3b0f 3e 78				ld a, display_row_4 
3b11 18 02				jr .ccol1 
3b13 3e 00		.crow1:		ld a,display_row_1 
3b15 f5			.ccol1:		push af			; got row offset 
3b16 6f					ld l,a 
3b17 26 00				ld h,0 
3b19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b19 cd 3b 1c			call macro_forth_dsp_pop 
3b1c				endm 
# End of macro FORTH_DSP_POP
3b1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b1c cd 83 1b			call macro_dsp_valuehl 
3b1f				endm 
# End of macro FORTH_DSP_VALUEHL
3b1f					; TODO save cursor col 
3b1f f1					pop af 
3b20 85					add l		; add col offset 
3b21 32 49 eb				ld (f_cursor_ptr), a 
3b24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b24 cd 3b 1c			call macro_forth_dsp_pop 
3b27				endm 
# End of macro FORTH_DSP_POP
3b27			 
3b27					; calculate  
3b27			 
3b27					NEXTW 
3b27 c3 f5 1c			jp macro_next 
3b2a				endm 
# End of macro NEXTW
3b2a			 
3b2a			 
3b2a			.HOME: 
3b2a				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3b2a 41				db WORD_SYS_CORE+45             
3b2b 57 3b			dw .SPACE            
3b2d 05				db 4 + 1 
3b2e .. 00			db "HOME",0              
3b33				endm 
# End of macro CWHEAD
3b33			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3b33					if DEBUG_FORTH_WORDS_KEY 
3b33						DMARK "HOM" 
3b33 f5				push af  
3b34 3a 48 3b			ld a, (.dmark)  
3b37 32 7a ee			ld (debug_mark),a  
3b3a 3a 49 3b			ld a, (.dmark+1)  
3b3d 32 7b ee			ld (debug_mark+1),a  
3b40 3a 4a 3b			ld a, (.dmark+2)  
3b43 32 7c ee			ld (debug_mark+2),a  
3b46 18 03			jr .pastdmark  
3b48 ..			.dmark: db "HOM"  
3b4b f1			.pastdmark: pop af  
3b4c			endm  
# End of macro DMARK
3b4c						CALLMONITOR 
3b4c cd ff 13			call break_point_state  
3b4f				endm  
# End of macro CALLMONITOR
3b4f					endif 
3b4f 3e 00		.home:		ld a, 0		; and home cursor 
3b51 32 49 eb				ld (f_cursor_ptr), a 
3b54					NEXTW 
3b54 c3 f5 1c			jp macro_next 
3b57				endm 
# End of macro NEXTW
3b57			 
3b57			 
3b57			.SPACE: 
3b57				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3b57 46				db WORD_SYS_CORE+50             
3b58 85 3b			dw .SPACES            
3b5a 03				db 2 + 1 
3b5b .. 00			db "BL",0              
3b5e				endm 
# End of macro CWHEAD
3b5e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3b5e					if DEBUG_FORTH_WORDS_KEY 
3b5e						DMARK "BL." 
3b5e f5				push af  
3b5f 3a 73 3b			ld a, (.dmark)  
3b62 32 7a ee			ld (debug_mark),a  
3b65 3a 74 3b			ld a, (.dmark+1)  
3b68 32 7b ee			ld (debug_mark+1),a  
3b6b 3a 75 3b			ld a, (.dmark+2)  
3b6e 32 7c ee			ld (debug_mark+2),a  
3b71 18 03			jr .pastdmark  
3b73 ..			.dmark: db "BL."  
3b76 f1			.pastdmark: pop af  
3b77			endm  
# End of macro DMARK
3b77						CALLMONITOR 
3b77 cd ff 13			call break_point_state  
3b7a				endm  
# End of macro CALLMONITOR
3b7a					endif 
3b7a 21 83 3b				ld hl, .blstr 
3b7d cd fa 19				call forth_push_str 
3b80					 
3b80				       NEXTW 
3b80 c3 f5 1c			jp macro_next 
3b83				endm 
# End of macro NEXTW
3b83			 
3b83 .. 00		.blstr: db " ", 0 
3b85			 
3b85			.SPACES: 
3b85				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3b85 47				db WORD_SYS_CORE+51             
3b86 20 3c			dw .SCROLL            
3b88 07				db 6 + 1 
3b89 .. 00			db "SPACES",0              
3b90				endm 
# End of macro CWHEAD
3b90			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3b90					if DEBUG_FORTH_WORDS_KEY 
3b90						DMARK "SPS" 
3b90 f5				push af  
3b91 3a a5 3b			ld a, (.dmark)  
3b94 32 7a ee			ld (debug_mark),a  
3b97 3a a6 3b			ld a, (.dmark+1)  
3b9a 32 7b ee			ld (debug_mark+1),a  
3b9d 3a a7 3b			ld a, (.dmark+2)  
3ba0 32 7c ee			ld (debug_mark+2),a  
3ba3 18 03			jr .pastdmark  
3ba5 ..			.dmark: db "SPS"  
3ba8 f1			.pastdmark: pop af  
3ba9			endm  
# End of macro DMARK
3ba9						CALLMONITOR 
3ba9 cd ff 13			call break_point_state  
3bac				endm  
# End of macro CALLMONITOR
3bac					endif 
3bac			 
3bac			 
3bac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bac cd 83 1b			call macro_dsp_valuehl 
3baf				endm 
# End of macro FORTH_DSP_VALUEHL
3baf			 
3baf			;		push hl    ; u 
3baf					if DEBUG_FORTH_WORDS 
3baf						DMARK "SPA" 
3baf f5				push af  
3bb0 3a c4 3b			ld a, (.dmark)  
3bb3 32 7a ee			ld (debug_mark),a  
3bb6 3a c5 3b			ld a, (.dmark+1)  
3bb9 32 7b ee			ld (debug_mark+1),a  
3bbc 3a c6 3b			ld a, (.dmark+2)  
3bbf 32 7c ee			ld (debug_mark+2),a  
3bc2 18 03			jr .pastdmark  
3bc4 ..			.dmark: db "SPA"  
3bc7 f1			.pastdmark: pop af  
3bc8			endm  
# End of macro DMARK
3bc8						CALLMONITOR 
3bc8 cd ff 13			call break_point_state  
3bcb				endm  
# End of macro CALLMONITOR
3bcb					endif 
3bcb			 
3bcb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bcb cd 3b 1c			call macro_forth_dsp_pop 
3bce				endm 
# End of macro FORTH_DSP_POP
3bce			;		pop hl 
3bce 4d					ld c, l 
3bcf 06 00				ld b, 0 
3bd1 21 60 e3				ld hl, scratch  
3bd4			 
3bd4					if DEBUG_FORTH_WORDS 
3bd4						DMARK "SP2" 
3bd4 f5				push af  
3bd5 3a e9 3b			ld a, (.dmark)  
3bd8 32 7a ee			ld (debug_mark),a  
3bdb 3a ea 3b			ld a, (.dmark+1)  
3bde 32 7b ee			ld (debug_mark+1),a  
3be1 3a eb 3b			ld a, (.dmark+2)  
3be4 32 7c ee			ld (debug_mark+2),a  
3be7 18 03			jr .pastdmark  
3be9 ..			.dmark: db "SP2"  
3bec f1			.pastdmark: pop af  
3bed			endm  
# End of macro DMARK
3bed						CALLMONITOR 
3bed cd ff 13			call break_point_state  
3bf0				endm  
# End of macro CALLMONITOR
3bf0					endif 
3bf0 3e 20				ld a, ' ' 
3bf2 c5			.spaces1:	push bc 
3bf3 77					ld (hl),a 
3bf4 23					inc hl 
3bf5 c1					pop bc 
3bf6 10 fa				djnz .spaces1 
3bf8 3e 00				ld a,0 
3bfa 77					ld (hl),a 
3bfb 21 60 e3				ld hl, scratch 
3bfe					if DEBUG_FORTH_WORDS 
3bfe						DMARK "SP3" 
3bfe f5				push af  
3bff 3a 13 3c			ld a, (.dmark)  
3c02 32 7a ee			ld (debug_mark),a  
3c05 3a 14 3c			ld a, (.dmark+1)  
3c08 32 7b ee			ld (debug_mark+1),a  
3c0b 3a 15 3c			ld a, (.dmark+2)  
3c0e 32 7c ee			ld (debug_mark+2),a  
3c11 18 03			jr .pastdmark  
3c13 ..			.dmark: db "SP3"  
3c16 f1			.pastdmark: pop af  
3c17			endm  
# End of macro DMARK
3c17						CALLMONITOR 
3c17 cd ff 13			call break_point_state  
3c1a				endm  
# End of macro CALLMONITOR
3c1a					endif 
3c1a cd f5 1a				call forth_apush 
3c1d			 
3c1d				       NEXTW 
3c1d c3 f5 1c			jp macro_next 
3c20				endm 
# End of macro NEXTW
3c20			 
3c20			 
3c20			 
3c20			.SCROLL: 
3c20				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3c20 53				db WORD_SYS_CORE+63             
3c21 4d 3c			dw .SCROLLD            
3c23 07				db 6 + 1 
3c24 .. 00			db "SCROLL",0              
3c2b				endm 
# End of macro CWHEAD
3c2b			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3c2b					if DEBUG_FORTH_WORDS_KEY 
3c2b						DMARK "SCR" 
3c2b f5				push af  
3c2c 3a 40 3c			ld a, (.dmark)  
3c2f 32 7a ee			ld (debug_mark),a  
3c32 3a 41 3c			ld a, (.dmark+1)  
3c35 32 7b ee			ld (debug_mark+1),a  
3c38 3a 42 3c			ld a, (.dmark+2)  
3c3b 32 7c ee			ld (debug_mark+2),a  
3c3e 18 03			jr .pastdmark  
3c40 ..			.dmark: db "SCR"  
3c43 f1			.pastdmark: pop af  
3c44			endm  
# End of macro DMARK
3c44						CALLMONITOR 
3c44 cd ff 13			call break_point_state  
3c47				endm  
# End of macro CALLMONITOR
3c47					endif 
3c47			 
3c47 cd 47 09			call scroll_up 
3c4a			;	call update_display 
3c4a			 
3c4a					NEXTW 
3c4a c3 f5 1c			jp macro_next 
3c4d				endm 
# End of macro NEXTW
3c4d			 
3c4d			 
3c4d			 
3c4d			;		; get dir 
3c4d			; 
3c4d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c4d			; 
3c4d			;		push hl 
3c4d			; 
3c4d			;		; destroy value TOS 
3c4d			; 
3c4d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4d			; 
3c4d			;		; get count 
3c4d			; 
3c4d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c4d			; 
3c4d			;		push hl 
3c4d			; 
3c4d			;		; destroy value TOS 
3c4d			; 
3c4d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4d			; 
3c4d			;		; one value on hl get other one back 
3c4d			; 
3c4d			;		pop bc    ; count 
3c4d			; 
3c4d			;		pop de   ; dir 
3c4d			; 
3c4d			; 
3c4d			;		ld b, c 
3c4d			; 
3c4d			;.scrolldir:     push bc 
3c4d			;		push de 
3c4d			; 
3c4d			;		ld a, 0 
3c4d			;		cp e 
3c4d			;		jr z, .scrollup  
3c4d			;		call scroll_down 
3c4d			;		jr .scrollnext 
3c4d			;.scrollup:	call scroll_up 
3c4d			; 
3c4d			;		 
3c4d			;.scrollnext: 
3c4d			;		pop de 
3c4d			;		pop bc 
3c4d			;		djnz .scrolldir 
3c4d			; 
3c4d			; 
3c4d			; 
3c4d			; 
3c4d			; 
3c4d			;		NEXTW 
3c4d			 
3c4d			.SCROLLD: 
3c4d				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3c4d 53				db WORD_SYS_CORE+63             
3c4e 7b 3c			dw .ATQ            
3c50 08				db 7 + 1 
3c51 .. 00			db "SCROLLD",0              
3c59				endm 
# End of macro CWHEAD
3c59			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3c59					if DEBUG_FORTH_WORDS_KEY 
3c59						DMARK "SCD" 
3c59 f5				push af  
3c5a 3a 6e 3c			ld a, (.dmark)  
3c5d 32 7a ee			ld (debug_mark),a  
3c60 3a 6f 3c			ld a, (.dmark+1)  
3c63 32 7b ee			ld (debug_mark+1),a  
3c66 3a 70 3c			ld a, (.dmark+2)  
3c69 32 7c ee			ld (debug_mark+2),a  
3c6c 18 03			jr .pastdmark  
3c6e ..			.dmark: db "SCD"  
3c71 f1			.pastdmark: pop af  
3c72			endm  
# End of macro DMARK
3c72						CALLMONITOR 
3c72 cd ff 13			call break_point_state  
3c75				endm  
# End of macro CALLMONITOR
3c75					endif 
3c75			 
3c75 cd 6b 09			call scroll_down 
3c78			;	call update_display 
3c78			 
3c78					NEXTW 
3c78 c3 f5 1c			jp macro_next 
3c7b				endm 
# End of macro NEXTW
3c7b			 
3c7b			 
3c7b			.ATQ: 
3c7b				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3c7b 62				db WORD_SYS_CORE+78             
3c7c d9 3c			dw .AUTODSP            
3c7e 04				db 3 + 1 
3c7f .. 00			db "AT@",0              
3c83				endm 
# End of macro CWHEAD
3c83			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3c83					if DEBUG_FORTH_WORDS_KEY 
3c83						DMARK "ATA" 
3c83 f5				push af  
3c84 3a 98 3c			ld a, (.dmark)  
3c87 32 7a ee			ld (debug_mark),a  
3c8a 3a 99 3c			ld a, (.dmark+1)  
3c8d 32 7b ee			ld (debug_mark+1),a  
3c90 3a 9a 3c			ld a, (.dmark+2)  
3c93 32 7c ee			ld (debug_mark+2),a  
3c96 18 03			jr .pastdmark  
3c98 ..			.dmark: db "ATA"  
3c9b f1			.pastdmark: pop af  
3c9c			endm  
# End of macro DMARK
3c9c						CALLMONITOR 
3c9c cd ff 13			call break_point_state  
3c9f				endm  
# End of macro CALLMONITOR
3c9f					endif 
3c9f			 
3c9f			 
3c9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c9f cd 83 1b			call macro_dsp_valuehl 
3ca2				endm 
# End of macro FORTH_DSP_VALUEHL
3ca2			 
3ca2					; TODO save cursor row 
3ca2 7d					ld a,l 
3ca3 fe 02				cp 2 
3ca5 20 04				jr nz, .crow3aq 
3ca7 3e 28				ld a, display_row_2 
3ca9 18 12				jr .ccol1aq 
3cab fe 03		.crow3aq:		cp 3 
3cad 20 04				jr nz, .crow4aq 
3caf 3e 50				ld a, display_row_3 
3cb1 18 0a				jr .ccol1aq 
3cb3 fe 04		.crow4aq:		cp 4 
3cb5 20 04				jr nz, .crow1aq 
3cb7 3e 78				ld a, display_row_4 
3cb9 18 02				jr .ccol1aq 
3cbb 3e 00		.crow1aq:		ld a,display_row_1 
3cbd f5			.ccol1aq:		push af			; got row offset 
3cbe 6f					ld l,a 
3cbf 26 00				ld h,0 
3cc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cc1 cd 3b 1c			call macro_forth_dsp_pop 
3cc4				endm 
# End of macro FORTH_DSP_POP
3cc4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cc4 cd 83 1b			call macro_dsp_valuehl 
3cc7				endm 
# End of macro FORTH_DSP_VALUEHL
3cc7					; TODO save cursor col 
3cc7 f1					pop af 
3cc8 85					add l		; add col offset 
3cc9			 
3cc9					; add current frame buffer address 
3cc9 2a db eb				ld hl, (display_fb_active) 
3ccc cd b2 0b				call addatohl 
3ccf			 
3ccf			 
3ccf			 
3ccf			 
3ccf					; get char frame buffer location offset in hl 
3ccf			 
3ccf 7e					ld a,(hl) 
3cd0 26 00				ld h, 0 
3cd2 6f					ld l, a 
3cd3			 
3cd3 cd 8c 19				call forth_push_numhl 
3cd6			 
3cd6			 
3cd6					NEXTW 
3cd6 c3 f5 1c			jp macro_next 
3cd9				endm 
# End of macro NEXTW
3cd9			 
3cd9			.AUTODSP: 
3cd9				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3cd9 63				db WORD_SYS_CORE+79             
3cda ef 3c			dw .MENU            
3cdc 05				db 4 + 1 
3cdd .. 00			db "ADSP",0              
3ce2				endm 
# End of macro CWHEAD
3ce2			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3ce2			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3ce2			 
3ce2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ce2 cd 83 1b			call macro_dsp_valuehl 
3ce5				endm 
# End of macro FORTH_DSP_VALUEHL
3ce5			 
3ce5			;		push hl 
3ce5			 
3ce5					; destroy value TOS 
3ce5			 
3ce5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ce5 cd 3b 1c			call macro_forth_dsp_pop 
3ce8				endm 
# End of macro FORTH_DSP_POP
3ce8			 
3ce8			;		pop hl 
3ce8			 
3ce8 7d					ld a,l 
3ce9 32 27 eb				ld (cli_autodisplay), a 
3cec				       NEXTW 
3cec c3 f5 1c			jp macro_next 
3cef				endm 
# End of macro NEXTW
3cef			 
3cef			.MENU: 
3cef				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3cef 70				db WORD_SYS_CORE+92             
3cf0 98 3d			dw .ENDDISPLAY            
3cf2 05				db 4 + 1 
3cf3 .. 00			db "MENU",0              
3cf8				endm 
# End of macro CWHEAD
3cf8			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3cf8			 
3cf8			;		; get number of items on the stack 
3cf8			; 
3cf8				 
3cf8					FORTH_DSP_VALUEHL 
3cf8 cd 83 1b			call macro_dsp_valuehl 
3cfb				endm 
# End of macro FORTH_DSP_VALUEHL
3cfb				 
3cfb					if DEBUG_FORTH_WORDS_KEY 
3cfb						DMARK "MNU" 
3cfb f5				push af  
3cfc 3a 10 3d			ld a, (.dmark)  
3cff 32 7a ee			ld (debug_mark),a  
3d02 3a 11 3d			ld a, (.dmark+1)  
3d05 32 7b ee			ld (debug_mark+1),a  
3d08 3a 12 3d			ld a, (.dmark+2)  
3d0b 32 7c ee			ld (debug_mark+2),a  
3d0e 18 03			jr .pastdmark  
3d10 ..			.dmark: db "MNU"  
3d13 f1			.pastdmark: pop af  
3d14			endm  
# End of macro DMARK
3d14						CALLMONITOR 
3d14 cd ff 13			call break_point_state  
3d17				endm  
# End of macro CALLMONITOR
3d17					endif 
3d17			 
3d17 45					ld b, l	 
3d18 05					dec b 
3d19			 
3d19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d19 cd 3b 1c			call macro_forth_dsp_pop 
3d1c				endm 
# End of macro FORTH_DSP_POP
3d1c			 
3d1c			 
3d1c					; go directly through the stack to pluck out the string pointers and build an array 
3d1c			 
3d1c			;		FORTH_DSP 
3d1c			 
3d1c					; hl contains top most stack item 
3d1c				 
3d1c 11 60 e3				ld de, scratch 
3d1f			 
3d1f			.mbuild: 
3d1f			 
3d1f					FORTH_DSP_VALUEHL 
3d1f cd 83 1b			call macro_dsp_valuehl 
3d22				endm 
# End of macro FORTH_DSP_VALUEHL
3d22			 
3d22					if DEBUG_FORTH_WORDS 
3d22						DMARK "MN3" 
3d22 f5				push af  
3d23 3a 37 3d			ld a, (.dmark)  
3d26 32 7a ee			ld (debug_mark),a  
3d29 3a 38 3d			ld a, (.dmark+1)  
3d2c 32 7b ee			ld (debug_mark+1),a  
3d2f 3a 39 3d			ld a, (.dmark+2)  
3d32 32 7c ee			ld (debug_mark+2),a  
3d35 18 03			jr .pastdmark  
3d37 ..			.dmark: db "MN3"  
3d3a f1			.pastdmark: pop af  
3d3b			endm  
# End of macro DMARK
3d3b						CALLMONITOR 
3d3b cd ff 13			call break_point_state  
3d3e				endm  
# End of macro CALLMONITOR
3d3e					endif 
3d3e eb					ex de, hl 
3d3f 73					ld (hl), e 
3d40 23					inc hl 
3d41 72					ld (hl), d 
3d42 23					inc hl 
3d43 eb					ex de, hl 
3d44			 
3d44					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d44 cd 3b 1c			call macro_forth_dsp_pop 
3d47				endm 
# End of macro FORTH_DSP_POP
3d47			 
3d47 10 d6				djnz .mbuild 
3d49			 
3d49					; done add term 
3d49			 
3d49 eb					ex de, hl 
3d4a 36 00				ld (hl), 0 
3d4c 23					inc hl 
3d4d 36 00				ld (hl), 0 
3d4f			 
3d4f				 
3d4f					 
3d4f 21 60 e3				ld hl, scratch 
3d52			 
3d52					if DEBUG_FORTH_WORDS 
3d52						DMARK "MNx" 
3d52 f5				push af  
3d53 3a 67 3d			ld a, (.dmark)  
3d56 32 7a ee			ld (debug_mark),a  
3d59 3a 68 3d			ld a, (.dmark+1)  
3d5c 32 7b ee			ld (debug_mark+1),a  
3d5f 3a 69 3d			ld a, (.dmark+2)  
3d62 32 7c ee			ld (debug_mark+2),a  
3d65 18 03			jr .pastdmark  
3d67 ..			.dmark: db "MNx"  
3d6a f1			.pastdmark: pop af  
3d6b			endm  
# End of macro DMARK
3d6b						CALLMONITOR 
3d6b cd ff 13			call break_point_state  
3d6e				endm  
# End of macro CALLMONITOR
3d6e					endif 
3d6e			 
3d6e			 
3d6e			 
3d6e 3e 00				ld a, 0 
3d70 cd b6 09				call menu 
3d73			 
3d73			 
3d73 6f					ld l, a 
3d74 26 00				ld h, 0 
3d76			 
3d76					if DEBUG_FORTH_WORDS 
3d76						DMARK "MNr" 
3d76 f5				push af  
3d77 3a 8b 3d			ld a, (.dmark)  
3d7a 32 7a ee			ld (debug_mark),a  
3d7d 3a 8c 3d			ld a, (.dmark+1)  
3d80 32 7b ee			ld (debug_mark+1),a  
3d83 3a 8d 3d			ld a, (.dmark+2)  
3d86 32 7c ee			ld (debug_mark+2),a  
3d89 18 03			jr .pastdmark  
3d8b ..			.dmark: db "MNr"  
3d8e f1			.pastdmark: pop af  
3d8f			endm  
# End of macro DMARK
3d8f						CALLMONITOR 
3d8f cd ff 13			call break_point_state  
3d92				endm  
# End of macro CALLMONITOR
3d92					endif 
3d92			 
3d92 cd 8c 19				call forth_push_numhl 
3d95			 
3d95			 
3d95			 
3d95			 
3d95				       NEXTW 
3d95 c3 f5 1c			jp macro_next 
3d98				endm 
# End of macro NEXTW
3d98			 
3d98			 
3d98			.ENDDISPLAY: 
3d98			 
3d98			; eof 
# End of file forth_words_display.asm
3d98			include "forth_words_str.asm" 
3d98			 
3d98			; | ## String Words 
3d98			 
3d98			.PTR:   
3d98			 
3d98				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3d98 48				db WORD_SYS_CORE+52             
3d99 c5 3d			dw .STYPE            
3d9b 04				db 3 + 1 
3d9c .. 00			db "PTR",0              
3da0				endm 
# End of macro CWHEAD
3da0			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3da0			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3da0			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3da0			 
3da0					if DEBUG_FORTH_WORDS_KEY 
3da0						DMARK "PTR" 
3da0 f5				push af  
3da1 3a b5 3d			ld a, (.dmark)  
3da4 32 7a ee			ld (debug_mark),a  
3da7 3a b6 3d			ld a, (.dmark+1)  
3daa 32 7b ee			ld (debug_mark+1),a  
3dad 3a b7 3d			ld a, (.dmark+2)  
3db0 32 7c ee			ld (debug_mark+2),a  
3db3 18 03			jr .pastdmark  
3db5 ..			.dmark: db "PTR"  
3db8 f1			.pastdmark: pop af  
3db9			endm  
# End of macro DMARK
3db9						CALLMONITOR 
3db9 cd ff 13			call break_point_state  
3dbc				endm  
# End of macro CALLMONITOR
3dbc					endif 
3dbc					FORTH_DSP_VALUEHL 
3dbc cd 83 1b			call macro_dsp_valuehl 
3dbf				endm 
# End of macro FORTH_DSP_VALUEHL
3dbf cd 8c 19				call forth_push_numhl 
3dc2			 
3dc2			 
3dc2					NEXTW 
3dc2 c3 f5 1c			jp macro_next 
3dc5				endm 
# End of macro NEXTW
3dc5			.STYPE: 
3dc5				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3dc5 48				db WORD_SYS_CORE+52             
3dc6 14 3e			dw .UPPER            
3dc8 06				db 5 + 1 
3dc9 .. 00			db "STYPE",0              
3dcf				endm 
# End of macro CWHEAD
3dcf			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3dcf					if DEBUG_FORTH_WORDS_KEY 
3dcf						DMARK "STY" 
3dcf f5				push af  
3dd0 3a e4 3d			ld a, (.dmark)  
3dd3 32 7a ee			ld (debug_mark),a  
3dd6 3a e5 3d			ld a, (.dmark+1)  
3dd9 32 7b ee			ld (debug_mark+1),a  
3ddc 3a e6 3d			ld a, (.dmark+2)  
3ddf 32 7c ee			ld (debug_mark+2),a  
3de2 18 03			jr .pastdmark  
3de4 ..			.dmark: db "STY"  
3de7 f1			.pastdmark: pop af  
3de8			endm  
# End of macro DMARK
3de8						CALLMONITOR 
3de8 cd ff 13			call break_point_state  
3deb				endm  
# End of macro CALLMONITOR
3deb					endif 
3deb					FORTH_DSP 
3deb cd 49 1b			call macro_forth_dsp 
3dee				endm 
# End of macro FORTH_DSP
3dee					;v5 FORTH_DSP_VALUE 
3dee			 
3dee 7e					ld a, (hl) 
3def			 
3def f5					push af 
3df0			 
3df0			; Dont destroy TOS		FORTH_DSP_POP 
3df0			 
3df0 f1					pop af 
3df1			 
3df1 fe 01				cp DS_TYPE_STR 
3df3 28 09				jr z, .typestr 
3df5			 
3df5 fe 02				cp DS_TYPE_INUM 
3df7 28 0a				jr z, .typeinum 
3df9			 
3df9 21 12 3e				ld hl, .tna 
3dfc 18 0a				jr .tpush 
3dfe			 
3dfe 21 0e 3e		.typestr:	ld hl, .tstr 
3e01 18 05				jr .tpush 
3e03 21 10 3e		.typeinum:	ld hl, .tinum 
3e06 18 00				jr .tpush 
3e08			 
3e08			.tpush: 
3e08			 
3e08 cd fa 19				call forth_push_str 
3e0b			 
3e0b					NEXTW 
3e0b c3 f5 1c			jp macro_next 
3e0e				endm 
# End of macro NEXTW
3e0e .. 00		.tstr:	db "s",0 
3e10 .. 00		.tinum:  db "i",0 
3e12 .. 00		.tna:   db "?", 0 
3e14			 
3e14			 
3e14			.UPPER: 
3e14				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3e14 48				db WORD_SYS_CORE+52             
3e15 4f 3e			dw .LOWER            
3e17 06				db 5 + 1 
3e18 .. 00			db "UPPER",0              
3e1e				endm 
# End of macro CWHEAD
3e1e			; | UPPER ( s -- s ) Upper case string s  | DONE 
3e1e					if DEBUG_FORTH_WORDS_KEY 
3e1e						DMARK "UPR" 
3e1e f5				push af  
3e1f 3a 33 3e			ld a, (.dmark)  
3e22 32 7a ee			ld (debug_mark),a  
3e25 3a 34 3e			ld a, (.dmark+1)  
3e28 32 7b ee			ld (debug_mark+1),a  
3e2b 3a 35 3e			ld a, (.dmark+2)  
3e2e 32 7c ee			ld (debug_mark+2),a  
3e31 18 03			jr .pastdmark  
3e33 ..			.dmark: db "UPR"  
3e36 f1			.pastdmark: pop af  
3e37			endm  
# End of macro DMARK
3e37						CALLMONITOR 
3e37 cd ff 13			call break_point_state  
3e3a				endm  
# End of macro CALLMONITOR
3e3a					endif 
3e3a			 
3e3a					FORTH_DSP 
3e3a cd 49 1b			call macro_forth_dsp 
3e3d				endm 
# End of macro FORTH_DSP
3e3d					 
3e3d			; TODO check is string type 
3e3d			 
3e3d					FORTH_DSP_VALUEHL 
3e3d cd 83 1b			call macro_dsp_valuehl 
3e40				endm 
# End of macro FORTH_DSP_VALUEHL
3e40			; get pointer to string in hl 
3e40			 
3e40 7e			.toup:		ld a, (hl) 
3e41 fe 00				cp 0 
3e43 28 07				jr z, .toupdone 
3e45			 
3e45 cd 1f 0f				call to_upper 
3e48			 
3e48 77					ld (hl), a 
3e49 23					inc hl 
3e4a 18 f4				jr .toup 
3e4c			 
3e4c					 
3e4c			 
3e4c			 
3e4c			; for each char convert to upper 
3e4c					 
3e4c			.toupdone: 
3e4c			 
3e4c			 
3e4c					NEXTW 
3e4c c3 f5 1c			jp macro_next 
3e4f				endm 
# End of macro NEXTW
3e4f			.LOWER: 
3e4f				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3e4f 48				db WORD_SYS_CORE+52             
3e50 8a 3e			dw .TCASE            
3e52 06				db 5 + 1 
3e53 .. 00			db "LOWER",0              
3e59				endm 
# End of macro CWHEAD
3e59			; | LOWER ( s -- s ) Lower case string s  | DONE 
3e59					if DEBUG_FORTH_WORDS_KEY 
3e59						DMARK "LWR" 
3e59 f5				push af  
3e5a 3a 6e 3e			ld a, (.dmark)  
3e5d 32 7a ee			ld (debug_mark),a  
3e60 3a 6f 3e			ld a, (.dmark+1)  
3e63 32 7b ee			ld (debug_mark+1),a  
3e66 3a 70 3e			ld a, (.dmark+2)  
3e69 32 7c ee			ld (debug_mark+2),a  
3e6c 18 03			jr .pastdmark  
3e6e ..			.dmark: db "LWR"  
3e71 f1			.pastdmark: pop af  
3e72			endm  
# End of macro DMARK
3e72						CALLMONITOR 
3e72 cd ff 13			call break_point_state  
3e75				endm  
# End of macro CALLMONITOR
3e75					endif 
3e75			 
3e75					FORTH_DSP 
3e75 cd 49 1b			call macro_forth_dsp 
3e78				endm 
# End of macro FORTH_DSP
3e78					 
3e78			; TODO check is string type 
3e78			 
3e78					FORTH_DSP_VALUEHL 
3e78 cd 83 1b			call macro_dsp_valuehl 
3e7b				endm 
# End of macro FORTH_DSP_VALUEHL
3e7b			; get pointer to string in hl 
3e7b			 
3e7b 7e			.tolow:		ld a, (hl) 
3e7c fe 00				cp 0 
3e7e 28 07				jr z, .tolowdone 
3e80			 
3e80 cd 28 0f				call to_lower 
3e83			 
3e83 77					ld (hl), a 
3e84 23					inc hl 
3e85 18 f4				jr .tolow 
3e87			 
3e87					 
3e87			 
3e87			 
3e87			; for each char convert to low 
3e87					 
3e87			.tolowdone: 
3e87					NEXTW 
3e87 c3 f5 1c			jp macro_next 
3e8a				endm 
# End of macro NEXTW
3e8a			.TCASE: 
3e8a				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3e8a 48				db WORD_SYS_CORE+52             
3e8b c0 3f			dw .SUBSTR            
3e8d 06				db 5 + 1 
3e8e .. 00			db "TCASE",0              
3e94				endm 
# End of macro CWHEAD
3e94			; | TCASE ( s -- s ) Title case string s  | DONE 
3e94					if DEBUG_FORTH_WORDS_KEY 
3e94						DMARK "TCS" 
3e94 f5				push af  
3e95 3a a9 3e			ld a, (.dmark)  
3e98 32 7a ee			ld (debug_mark),a  
3e9b 3a aa 3e			ld a, (.dmark+1)  
3e9e 32 7b ee			ld (debug_mark+1),a  
3ea1 3a ab 3e			ld a, (.dmark+2)  
3ea4 32 7c ee			ld (debug_mark+2),a  
3ea7 18 03			jr .pastdmark  
3ea9 ..			.dmark: db "TCS"  
3eac f1			.pastdmark: pop af  
3ead			endm  
# End of macro DMARK
3ead						CALLMONITOR 
3ead cd ff 13			call break_point_state  
3eb0				endm  
# End of macro CALLMONITOR
3eb0					endif 
3eb0			 
3eb0					FORTH_DSP 
3eb0 cd 49 1b			call macro_forth_dsp 
3eb3				endm 
# End of macro FORTH_DSP
3eb3					 
3eb3			; TODO check is string type 
3eb3			 
3eb3					FORTH_DSP_VALUEHL 
3eb3 cd 83 1b			call macro_dsp_valuehl 
3eb6				endm 
# End of macro FORTH_DSP_VALUEHL
3eb6			; get pointer to string in hl 
3eb6			 
3eb6					if DEBUG_FORTH_WORDS 
3eb6						DMARK "TC1" 
3eb6 f5				push af  
3eb7 3a cb 3e			ld a, (.dmark)  
3eba 32 7a ee			ld (debug_mark),a  
3ebd 3a cc 3e			ld a, (.dmark+1)  
3ec0 32 7b ee			ld (debug_mark+1),a  
3ec3 3a cd 3e			ld a, (.dmark+2)  
3ec6 32 7c ee			ld (debug_mark+2),a  
3ec9 18 03			jr .pastdmark  
3ecb ..			.dmark: db "TC1"  
3ece f1			.pastdmark: pop af  
3ecf			endm  
# End of macro DMARK
3ecf						CALLMONITOR 
3ecf cd ff 13			call break_point_state  
3ed2				endm  
# End of macro CALLMONITOR
3ed2					endif 
3ed2			 
3ed2					; first time in turn to upper case first char 
3ed2			 
3ed2 7e					ld a, (hl) 
3ed3 c3 5d 3f				jp .totsiptou 
3ed6			 
3ed6			 
3ed6 7e			.tot:		ld a, (hl) 
3ed7 fe 00				cp 0 
3ed9 ca a1 3f				jp z, .totdone 
3edc			 
3edc					if DEBUG_FORTH_WORDS 
3edc						DMARK "TC2" 
3edc f5				push af  
3edd 3a f1 3e			ld a, (.dmark)  
3ee0 32 7a ee			ld (debug_mark),a  
3ee3 3a f2 3e			ld a, (.dmark+1)  
3ee6 32 7b ee			ld (debug_mark+1),a  
3ee9 3a f3 3e			ld a, (.dmark+2)  
3eec 32 7c ee			ld (debug_mark+2),a  
3eef 18 03			jr .pastdmark  
3ef1 ..			.dmark: db "TC2"  
3ef4 f1			.pastdmark: pop af  
3ef5			endm  
# End of macro DMARK
3ef5						CALLMONITOR 
3ef5 cd ff 13			call break_point_state  
3ef8				endm  
# End of macro CALLMONITOR
3ef8					endif 
3ef8					; check to see if current char is a space 
3ef8			 
3ef8 fe 20				cp ' ' 
3efa 28 21				jr z, .totsp 
3efc cd 28 0f				call to_lower 
3eff					if DEBUG_FORTH_WORDS 
3eff						DMARK "TC3" 
3eff f5				push af  
3f00 3a 14 3f			ld a, (.dmark)  
3f03 32 7a ee			ld (debug_mark),a  
3f06 3a 15 3f			ld a, (.dmark+1)  
3f09 32 7b ee			ld (debug_mark+1),a  
3f0c 3a 16 3f			ld a, (.dmark+2)  
3f0f 32 7c ee			ld (debug_mark+2),a  
3f12 18 03			jr .pastdmark  
3f14 ..			.dmark: db "TC3"  
3f17 f1			.pastdmark: pop af  
3f18			endm  
# End of macro DMARK
3f18						CALLMONITOR 
3f18 cd ff 13			call break_point_state  
3f1b				endm  
# End of macro CALLMONITOR
3f1b					endif 
3f1b 18 63				jr .totnxt 
3f1d			 
3f1d			.totsp:         ; on a space, find next char which should be upper 
3f1d			 
3f1d					if DEBUG_FORTH_WORDS 
3f1d						DMARK "TC4" 
3f1d f5				push af  
3f1e 3a 32 3f			ld a, (.dmark)  
3f21 32 7a ee			ld (debug_mark),a  
3f24 3a 33 3f			ld a, (.dmark+1)  
3f27 32 7b ee			ld (debug_mark+1),a  
3f2a 3a 34 3f			ld a, (.dmark+2)  
3f2d 32 7c ee			ld (debug_mark+2),a  
3f30 18 03			jr .pastdmark  
3f32 ..			.dmark: db "TC4"  
3f35 f1			.pastdmark: pop af  
3f36			endm  
# End of macro DMARK
3f36						CALLMONITOR 
3f36 cd ff 13			call break_point_state  
3f39				endm  
# End of macro CALLMONITOR
3f39					endif 
3f39					;; 
3f39			 
3f39 fe 20				cp ' ' 
3f3b 20 20				jr nz, .totsiptou 
3f3d 23					inc hl 
3f3e 7e					ld a, (hl) 
3f3f					if DEBUG_FORTH_WORDS 
3f3f						DMARK "TC5" 
3f3f f5				push af  
3f40 3a 54 3f			ld a, (.dmark)  
3f43 32 7a ee			ld (debug_mark),a  
3f46 3a 55 3f			ld a, (.dmark+1)  
3f49 32 7b ee			ld (debug_mark+1),a  
3f4c 3a 56 3f			ld a, (.dmark+2)  
3f4f 32 7c ee			ld (debug_mark+2),a  
3f52 18 03			jr .pastdmark  
3f54 ..			.dmark: db "TC5"  
3f57 f1			.pastdmark: pop af  
3f58			endm  
# End of macro DMARK
3f58						CALLMONITOR 
3f58 cd ff 13			call break_point_state  
3f5b				endm  
# End of macro CALLMONITOR
3f5b					endif 
3f5b 18 c0				jr .totsp 
3f5d fe 00		.totsiptou:    cp 0 
3f5f 28 40				jr z, .totdone 
3f61					; not space and not zero term so upper case it 
3f61 cd 1f 0f				call to_upper 
3f64			 
3f64					if DEBUG_FORTH_WORDS 
3f64						DMARK "TC6" 
3f64 f5				push af  
3f65 3a 79 3f			ld a, (.dmark)  
3f68 32 7a ee			ld (debug_mark),a  
3f6b 3a 7a 3f			ld a, (.dmark+1)  
3f6e 32 7b ee			ld (debug_mark+1),a  
3f71 3a 7b 3f			ld a, (.dmark+2)  
3f74 32 7c ee			ld (debug_mark+2),a  
3f77 18 03			jr .pastdmark  
3f79 ..			.dmark: db "TC6"  
3f7c f1			.pastdmark: pop af  
3f7d			endm  
# End of macro DMARK
3f7d						CALLMONITOR 
3f7d cd ff 13			call break_point_state  
3f80				endm  
# End of macro CALLMONITOR
3f80					endif 
3f80			 
3f80			 
3f80			.totnxt: 
3f80			 
3f80 77					ld (hl), a 
3f81 23					inc hl 
3f82					if DEBUG_FORTH_WORDS 
3f82						DMARK "TC7" 
3f82 f5				push af  
3f83 3a 97 3f			ld a, (.dmark)  
3f86 32 7a ee			ld (debug_mark),a  
3f89 3a 98 3f			ld a, (.dmark+1)  
3f8c 32 7b ee			ld (debug_mark+1),a  
3f8f 3a 99 3f			ld a, (.dmark+2)  
3f92 32 7c ee			ld (debug_mark+2),a  
3f95 18 03			jr .pastdmark  
3f97 ..			.dmark: db "TC7"  
3f9a f1			.pastdmark: pop af  
3f9b			endm  
# End of macro DMARK
3f9b						CALLMONITOR 
3f9b cd ff 13			call break_point_state  
3f9e				endm  
# End of macro CALLMONITOR
3f9e					endif 
3f9e c3 d6 3e				jp .tot 
3fa1			 
3fa1					 
3fa1			 
3fa1			 
3fa1			; for each char convert to low 
3fa1					 
3fa1			.totdone: 
3fa1					if DEBUG_FORTH_WORDS 
3fa1						DMARK "TCd" 
3fa1 f5				push af  
3fa2 3a b6 3f			ld a, (.dmark)  
3fa5 32 7a ee			ld (debug_mark),a  
3fa8 3a b7 3f			ld a, (.dmark+1)  
3fab 32 7b ee			ld (debug_mark+1),a  
3fae 3a b8 3f			ld a, (.dmark+2)  
3fb1 32 7c ee			ld (debug_mark+2),a  
3fb4 18 03			jr .pastdmark  
3fb6 ..			.dmark: db "TCd"  
3fb9 f1			.pastdmark: pop af  
3fba			endm  
# End of macro DMARK
3fba						CALLMONITOR 
3fba cd ff 13			call break_point_state  
3fbd				endm  
# End of macro CALLMONITOR
3fbd					endif 
3fbd					NEXTW 
3fbd c3 f5 1c			jp macro_next 
3fc0				endm 
# End of macro NEXTW
3fc0			 
3fc0			.SUBSTR: 
3fc0				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3fc0 48				db WORD_SYS_CORE+52             
3fc1 1e 40			dw .LEFT            
3fc3 07				db 6 + 1 
3fc4 .. 00			db "SUBSTR",0              
3fcb				endm 
# End of macro CWHEAD
3fcb			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3fcb			 
3fcb					if DEBUG_FORTH_WORDS_KEY 
3fcb						DMARK "SST" 
3fcb f5				push af  
3fcc 3a e0 3f			ld a, (.dmark)  
3fcf 32 7a ee			ld (debug_mark),a  
3fd2 3a e1 3f			ld a, (.dmark+1)  
3fd5 32 7b ee			ld (debug_mark+1),a  
3fd8 3a e2 3f			ld a, (.dmark+2)  
3fdb 32 7c ee			ld (debug_mark+2),a  
3fde 18 03			jr .pastdmark  
3fe0 ..			.dmark: db "SST"  
3fe3 f1			.pastdmark: pop af  
3fe4			endm  
# End of macro DMARK
3fe4						CALLMONITOR 
3fe4 cd ff 13			call break_point_state  
3fe7				endm  
# End of macro CALLMONITOR
3fe7					endif 
3fe7			; TODO check string type 
3fe7					FORTH_DSP_VALUEHL 
3fe7 cd 83 1b			call macro_dsp_valuehl 
3fea				endm 
# End of macro FORTH_DSP_VALUEHL
3fea			 
3fea e5					push hl      ; string length 
3feb			 
3feb					FORTH_DSP_POP 
3feb cd 3b 1c			call macro_forth_dsp_pop 
3fee				endm 
# End of macro FORTH_DSP_POP
3fee			 
3fee					FORTH_DSP_VALUEHL 
3fee cd 83 1b			call macro_dsp_valuehl 
3ff1				endm 
# End of macro FORTH_DSP_VALUEHL
3ff1			 
3ff1 e5					push hl     ; start char 
3ff2			 
3ff2					FORTH_DSP_POP 
3ff2 cd 3b 1c			call macro_forth_dsp_pop 
3ff5				endm 
# End of macro FORTH_DSP_POP
3ff5			 
3ff5			 
3ff5					FORTH_DSP_VALUE 
3ff5 cd 6c 1b			call macro_forth_dsp_value 
3ff8				endm 
# End of macro FORTH_DSP_VALUE
3ff8			 
3ff8 d1					pop de    ; get start post offset 
3ff9			 
3ff9 19					add hl, de    ; starting offset 
3ffa			 
3ffa c1					pop bc 
3ffb c5					push bc      ; grab size of string 
3ffc			 
3ffc e5					push hl    ; save string start  
3ffd			 
3ffd 26 00				ld h, 0 
3fff 69					ld l, c 
4000 23					inc hl 
4001 23					inc hl 
4002			 
4002 cd 79 10				call malloc 
4005				if DEBUG_FORTH_MALLOC_GUARD 
4005 cc 34 46				call z,malloc_error 
4008				endif 
4008			 
4008 eb					ex de, hl      ; save malloc area for string copy 
4009 e1					pop hl    ; get back source 
400a c1					pop bc    ; get length of string back 
400b			 
400b d5					push de    ; save malloc area for after we push 
400c ed b0				ldir     ; copy substr 
400e			 
400e			 
400e eb					ex de, hl 
400f 3e 00				ld a, 0 
4011 77					ld (hl), a   ; term substr 
4012			 
4012					 
4012 e1					pop hl    ; get malloc so we can push it 
4013 e5					push hl   ; save so we can free it afterwards 
4014			 
4014 cd fa 19				call forth_push_str 
4017			 
4017 e1					pop hl 
4018 cd 43 11				call free 
401b			 
401b					 
401b					 
401b			 
401b			 
401b					NEXTW 
401b c3 f5 1c			jp macro_next 
401e				endm 
# End of macro NEXTW
401e			 
401e			.LEFT: 
401e				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
401e 48				db WORD_SYS_CORE+52             
401f 46 40			dw .RIGHT            
4021 05				db 4 + 1 
4022 .. 00			db "LEFT",0              
4027				endm 
# End of macro CWHEAD
4027			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4027					if DEBUG_FORTH_WORDS_KEY 
4027						DMARK "LEF" 
4027 f5				push af  
4028 3a 3c 40			ld a, (.dmark)  
402b 32 7a ee			ld (debug_mark),a  
402e 3a 3d 40			ld a, (.dmark+1)  
4031 32 7b ee			ld (debug_mark+1),a  
4034 3a 3e 40			ld a, (.dmark+2)  
4037 32 7c ee			ld (debug_mark+2),a  
403a 18 03			jr .pastdmark  
403c ..			.dmark: db "LEF"  
403f f1			.pastdmark: pop af  
4040			endm  
# End of macro DMARK
4040						CALLMONITOR 
4040 cd ff 13			call break_point_state  
4043				endm  
# End of macro CALLMONITOR
4043					endif 
4043			 
4043					NEXTW 
4043 c3 f5 1c			jp macro_next 
4046				endm 
# End of macro NEXTW
4046			.RIGHT: 
4046				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4046 48				db WORD_SYS_CORE+52             
4047 6f 40			dw .STR2NUM            
4049 06				db 5 + 1 
404a .. 00			db "RIGHT",0              
4050				endm 
# End of macro CWHEAD
4050			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4050					if DEBUG_FORTH_WORDS_KEY 
4050						DMARK "RIG" 
4050 f5				push af  
4051 3a 65 40			ld a, (.dmark)  
4054 32 7a ee			ld (debug_mark),a  
4057 3a 66 40			ld a, (.dmark+1)  
405a 32 7b ee			ld (debug_mark+1),a  
405d 3a 67 40			ld a, (.dmark+2)  
4060 32 7c ee			ld (debug_mark+2),a  
4063 18 03			jr .pastdmark  
4065 ..			.dmark: db "RIG"  
4068 f1			.pastdmark: pop af  
4069			endm  
# End of macro DMARK
4069						CALLMONITOR 
4069 cd ff 13			call break_point_state  
406c				endm  
# End of macro CALLMONITOR
406c					endif 
406c			 
406c					NEXTW 
406c c3 f5 1c			jp macro_next 
406f				endm 
# End of macro NEXTW
406f			 
406f			 
406f			.STR2NUM: 
406f				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
406f 48				db WORD_SYS_CORE+52             
4070 fb 40			dw .NUM2STR            
4072 08				db 7 + 1 
4073 .. 00			db "STR2NUM",0              
407b				endm 
# End of macro CWHEAD
407b			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
407b			 
407b			 
407b			; TODO STR type check to do 
407b					if DEBUG_FORTH_WORDS_KEY 
407b						DMARK "S2N" 
407b f5				push af  
407c 3a 90 40			ld a, (.dmark)  
407f 32 7a ee			ld (debug_mark),a  
4082 3a 91 40			ld a, (.dmark+1)  
4085 32 7b ee			ld (debug_mark+1),a  
4088 3a 92 40			ld a, (.dmark+2)  
408b 32 7c ee			ld (debug_mark+2),a  
408e 18 03			jr .pastdmark  
4090 ..			.dmark: db "S2N"  
4093 f1			.pastdmark: pop af  
4094			endm  
# End of macro DMARK
4094						CALLMONITOR 
4094 cd ff 13			call break_point_state  
4097				endm  
# End of macro CALLMONITOR
4097					endif 
4097			 
4097					;FORTH_DSP 
4097					FORTH_DSP_VALUE 
4097 cd 6c 1b			call macro_forth_dsp_value 
409a				endm 
# End of macro FORTH_DSP_VALUE
409a					;inc hl 
409a			 
409a eb					ex de, hl 
409b					if DEBUG_FORTH_WORDS 
409b						DMARK "S2a" 
409b f5				push af  
409c 3a b0 40			ld a, (.dmark)  
409f 32 7a ee			ld (debug_mark),a  
40a2 3a b1 40			ld a, (.dmark+1)  
40a5 32 7b ee			ld (debug_mark+1),a  
40a8 3a b2 40			ld a, (.dmark+2)  
40ab 32 7c ee			ld (debug_mark+2),a  
40ae 18 03			jr .pastdmark  
40b0 ..			.dmark: db "S2a"  
40b3 f1			.pastdmark: pop af  
40b4			endm  
# End of macro DMARK
40b4						CALLMONITOR 
40b4 cd ff 13			call break_point_state  
40b7				endm  
# End of macro CALLMONITOR
40b7					endif 
40b7 cd a7 0f				call string_to_uint16 
40ba			 
40ba					if DEBUG_FORTH_WORDS 
40ba						DMARK "S2b" 
40ba f5				push af  
40bb 3a cf 40			ld a, (.dmark)  
40be 32 7a ee			ld (debug_mark),a  
40c1 3a d0 40			ld a, (.dmark+1)  
40c4 32 7b ee			ld (debug_mark+1),a  
40c7 3a d1 40			ld a, (.dmark+2)  
40ca 32 7c ee			ld (debug_mark+2),a  
40cd 18 03			jr .pastdmark  
40cf ..			.dmark: db "S2b"  
40d2 f1			.pastdmark: pop af  
40d3			endm  
# End of macro DMARK
40d3						CALLMONITOR 
40d3 cd ff 13			call break_point_state  
40d6				endm  
# End of macro CALLMONITOR
40d6					endif 
40d6			;		push hl 
40d6					FORTH_DSP_POP 
40d6 cd 3b 1c			call macro_forth_dsp_pop 
40d9				endm 
# End of macro FORTH_DSP_POP
40d9			;		pop hl 
40d9					 
40d9					if DEBUG_FORTH_WORDS 
40d9						DMARK "S2b" 
40d9 f5				push af  
40da 3a ee 40			ld a, (.dmark)  
40dd 32 7a ee			ld (debug_mark),a  
40e0 3a ef 40			ld a, (.dmark+1)  
40e3 32 7b ee			ld (debug_mark+1),a  
40e6 3a f0 40			ld a, (.dmark+2)  
40e9 32 7c ee			ld (debug_mark+2),a  
40ec 18 03			jr .pastdmark  
40ee ..			.dmark: db "S2b"  
40f1 f1			.pastdmark: pop af  
40f2			endm  
# End of macro DMARK
40f2						CALLMONITOR 
40f2 cd ff 13			call break_point_state  
40f5				endm  
# End of macro CALLMONITOR
40f5					endif 
40f5 cd 8c 19				call forth_push_numhl	 
40f8			 
40f8				 
40f8				       NEXTW 
40f8 c3 f5 1c			jp macro_next 
40fb				endm 
# End of macro NEXTW
40fb			.NUM2STR: 
40fb				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
40fb 48				db WORD_SYS_CORE+52             
40fc 0a 41			dw .CONCAT            
40fe 08				db 7 + 1 
40ff .. 00			db "NUM2STR",0              
4107				endm 
# End of macro CWHEAD
4107			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4107			 
4107			;		; malloc a string to target 
4107			;		ld hl, 10     ; TODO max string size should be fine 
4107			;		call malloc 
4107			;		push hl    ; save malloc location 
4107			; 
4107			; 
4107			;; TODO check int type 
4107			;		FORTH_DSP_VALUEHL 
4107			;		ld a, l 
4107			;		call DispAToASCII   
4107			;;TODO need to chage above call to dump into string 
4107			; 
4107			; 
4107			 
4107				       NEXTW 
4107 c3 f5 1c			jp macro_next 
410a				endm 
# End of macro NEXTW
410a			 
410a			.CONCAT: 
410a				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
410a 48				db WORD_SYS_CORE+52             
410b bd 41			dw .FIND            
410d 07				db 6 + 1 
410e .. 00			db "CONCAT",0              
4115				endm 
# End of macro CWHEAD
4115			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4115			 
4115			; TODO check string type 
4115			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4115			 
4115					if DEBUG_FORTH_WORDS_KEY 
4115						DMARK "CON" 
4115 f5				push af  
4116 3a 2a 41			ld a, (.dmark)  
4119 32 7a ee			ld (debug_mark),a  
411c 3a 2b 41			ld a, (.dmark+1)  
411f 32 7b ee			ld (debug_mark+1),a  
4122 3a 2c 41			ld a, (.dmark+2)  
4125 32 7c ee			ld (debug_mark+2),a  
4128 18 03			jr .pastdmark  
412a ..			.dmark: db "CON"  
412d f1			.pastdmark: pop af  
412e			endm  
# End of macro DMARK
412e						CALLMONITOR 
412e cd ff 13			call break_point_state  
4131				endm  
# End of macro CALLMONITOR
4131					endif 
4131			 
4131			 
4131					FORTH_DSP_VALUE 
4131 cd 6c 1b			call macro_forth_dsp_value 
4134				endm 
# End of macro FORTH_DSP_VALUE
4134 e5					push hl   ; s2 
4135			 
4135					FORTH_DSP_POP 
4135 cd 3b 1c			call macro_forth_dsp_pop 
4138				endm 
# End of macro FORTH_DSP_POP
4138			 
4138					FORTH_DSP_VALUE 
4138 cd 6c 1b			call macro_forth_dsp_value 
413b				endm 
# End of macro FORTH_DSP_VALUE
413b			 
413b e5					push hl   ; s1 
413c			 
413c					FORTH_DSP_POP 
413c cd 3b 1c			call macro_forth_dsp_pop 
413f				endm 
# End of macro FORTH_DSP_POP
413f					 
413f			 
413f					; copy s1 
413f			 
413f				 
413f					; save ptr 
413f e1					pop hl  
4140 e5					push hl 
4141 3e 00				ld a, 0 
4143 cd 1b 10				call strlent 
4146					;inc hl    ; zer0 
4146 06 00				ld b, 0 
4148 4d					ld c, l 
4149 e1					pop hl		 
414a 11 60 e3				ld de, scratch	 
414d					if DEBUG_FORTH_WORDS 
414d						DMARK "CO1" 
414d f5				push af  
414e 3a 62 41			ld a, (.dmark)  
4151 32 7a ee			ld (debug_mark),a  
4154 3a 63 41			ld a, (.dmark+1)  
4157 32 7b ee			ld (debug_mark+1),a  
415a 3a 64 41			ld a, (.dmark+2)  
415d 32 7c ee			ld (debug_mark+2),a  
4160 18 03			jr .pastdmark  
4162 ..			.dmark: db "CO1"  
4165 f1			.pastdmark: pop af  
4166			endm  
# End of macro DMARK
4166						CALLMONITOR 
4166 cd ff 13			call break_point_state  
4169				endm  
# End of macro CALLMONITOR
4169					endif 
4169 ed b0				ldir 
416b			 
416b e1					pop hl 
416c e5					push hl 
416d d5					push de 
416e			 
416e			 
416e 3e 00				ld a, 0 
4170 cd 1b 10				call strlent 
4173 23					inc hl    ; zer0 
4174 23					inc hl 
4175 06 00				ld b, 0 
4177 4d					ld c, l 
4178 d1					pop de 
4179 e1					pop hl		 
417a					if DEBUG_FORTH_WORDS 
417a						DMARK "CO2" 
417a f5				push af  
417b 3a 8f 41			ld a, (.dmark)  
417e 32 7a ee			ld (debug_mark),a  
4181 3a 90 41			ld a, (.dmark+1)  
4184 32 7b ee			ld (debug_mark+1),a  
4187 3a 91 41			ld a, (.dmark+2)  
418a 32 7c ee			ld (debug_mark+2),a  
418d 18 03			jr .pastdmark  
418f ..			.dmark: db "CO2"  
4192 f1			.pastdmark: pop af  
4193			endm  
# End of macro DMARK
4193						CALLMONITOR 
4193 cd ff 13			call break_point_state  
4196				endm  
# End of macro CALLMONITOR
4196					endif 
4196 ed b0				ldir 
4198			 
4198			 
4198			 
4198 21 60 e3				ld hl, scratch 
419b					if DEBUG_FORTH_WORDS 
419b						DMARK "CO5" 
419b f5				push af  
419c 3a b0 41			ld a, (.dmark)  
419f 32 7a ee			ld (debug_mark),a  
41a2 3a b1 41			ld a, (.dmark+1)  
41a5 32 7b ee			ld (debug_mark+1),a  
41a8 3a b2 41			ld a, (.dmark+2)  
41ab 32 7c ee			ld (debug_mark+2),a  
41ae 18 03			jr .pastdmark  
41b0 ..			.dmark: db "CO5"  
41b3 f1			.pastdmark: pop af  
41b4			endm  
# End of macro DMARK
41b4						CALLMONITOR 
41b4 cd ff 13			call break_point_state  
41b7				endm  
# End of macro CALLMONITOR
41b7					endif 
41b7			 
41b7 cd fa 19				call forth_push_str 
41ba			 
41ba			 
41ba			 
41ba			 
41ba				       NEXTW 
41ba c3 f5 1c			jp macro_next 
41bd				endm 
# End of macro NEXTW
41bd			 
41bd			 
41bd			.FIND: 
41bd				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
41bd 4b				db WORD_SYS_CORE+55             
41be 7b 42			dw .LEN            
41c0 05				db 4 + 1 
41c1 .. 00			db "FIND",0              
41c6				endm 
# End of macro CWHEAD
41c6			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
41c6			 
41c6					if DEBUG_FORTH_WORDS_KEY 
41c6						DMARK "FND" 
41c6 f5				push af  
41c7 3a db 41			ld a, (.dmark)  
41ca 32 7a ee			ld (debug_mark),a  
41cd 3a dc 41			ld a, (.dmark+1)  
41d0 32 7b ee			ld (debug_mark+1),a  
41d3 3a dd 41			ld a, (.dmark+2)  
41d6 32 7c ee			ld (debug_mark+2),a  
41d9 18 03			jr .pastdmark  
41db ..			.dmark: db "FND"  
41de f1			.pastdmark: pop af  
41df			endm  
# End of macro DMARK
41df						CALLMONITOR 
41df cd ff 13			call break_point_state  
41e2				endm  
# End of macro CALLMONITOR
41e2					endif 
41e2			 
41e2			; TODO check string type 
41e2					FORTH_DSP_VALUE 
41e2 cd 6c 1b			call macro_forth_dsp_value 
41e5				endm 
# End of macro FORTH_DSP_VALUE
41e5			 
41e5 e5					push hl    
41e6 7e					ld a,(hl)    ; char to find   
41e7			; TODO change char to substr 
41e7			 
41e7 f5					push af 
41e8					 
41e8			 
41e8			 
41e8					if DEBUG_FORTH_WORDS 
41e8						DMARK "FN1" 
41e8 f5				push af  
41e9 3a fd 41			ld a, (.dmark)  
41ec 32 7a ee			ld (debug_mark),a  
41ef 3a fe 41			ld a, (.dmark+1)  
41f2 32 7b ee			ld (debug_mark+1),a  
41f5 3a ff 41			ld a, (.dmark+2)  
41f8 32 7c ee			ld (debug_mark+2),a  
41fb 18 03			jr .pastdmark  
41fd ..			.dmark: db "FN1"  
4200 f1			.pastdmark: pop af  
4201			endm  
# End of macro DMARK
4201						CALLMONITOR 
4201 cd ff 13			call break_point_state  
4204				endm  
# End of macro CALLMONITOR
4204					endif 
4204			 
4204					FORTH_DSP_POP 
4204 cd 3b 1c			call macro_forth_dsp_pop 
4207				endm 
# End of macro FORTH_DSP_POP
4207			 
4207					; string to search 
4207			 
4207					FORTH_DSP_VALUE 
4207 cd 6c 1b			call macro_forth_dsp_value 
420a				endm 
# End of macro FORTH_DSP_VALUE
420a			 
420a d1					pop de  ; d is char to find  
420b			 
420b					if DEBUG_FORTH_WORDS 
420b						DMARK "FN2" 
420b f5				push af  
420c 3a 20 42			ld a, (.dmark)  
420f 32 7a ee			ld (debug_mark),a  
4212 3a 21 42			ld a, (.dmark+1)  
4215 32 7b ee			ld (debug_mark+1),a  
4218 3a 22 42			ld a, (.dmark+2)  
421b 32 7c ee			ld (debug_mark+2),a  
421e 18 03			jr .pastdmark  
4220 ..			.dmark: db "FN2"  
4223 f1			.pastdmark: pop af  
4224			endm  
# End of macro DMARK
4224						CALLMONITOR 
4224 cd ff 13			call break_point_state  
4227				endm  
# End of macro CALLMONITOR
4227					endif 
4227					 
4227 01 00 00				ld bc, 0 
422a 7e			.findchar:      ld a,(hl) 
422b fe 00				cp 0   		 
422d 28 27				jr z, .finddone     
422f ba					cp d 
4230 28 20				jr z, .foundchar 
4232 03					inc bc 
4233 23					inc hl 
4234					if DEBUG_FORTH_WORDS 
4234						DMARK "FN3" 
4234 f5				push af  
4235 3a 49 42			ld a, (.dmark)  
4238 32 7a ee			ld (debug_mark),a  
423b 3a 4a 42			ld a, (.dmark+1)  
423e 32 7b ee			ld (debug_mark+1),a  
4241 3a 4b 42			ld a, (.dmark+2)  
4244 32 7c ee			ld (debug_mark+2),a  
4247 18 03			jr .pastdmark  
4249 ..			.dmark: db "FN3"  
424c f1			.pastdmark: pop af  
424d			endm  
# End of macro DMARK
424d						CALLMONITOR 
424d cd ff 13			call break_point_state  
4250				endm  
# End of macro CALLMONITOR
4250					endif 
4250 18 d8				jr .findchar 
4252			 
4252			 
4252 c5			.foundchar:	push bc 
4253 e1					pop hl 
4254 18 03				jr .findexit 
4256			 
4256			 
4256							 
4256			 
4256			.finddone:     ; got to end of string with no find 
4256 21 00 00				ld hl, 0 
4259			.findexit: 
4259			 
4259					if DEBUG_FORTH_WORDS 
4259						DMARK "FNd" 
4259 f5				push af  
425a 3a 6e 42			ld a, (.dmark)  
425d 32 7a ee			ld (debug_mark),a  
4260 3a 6f 42			ld a, (.dmark+1)  
4263 32 7b ee			ld (debug_mark+1),a  
4266 3a 70 42			ld a, (.dmark+2)  
4269 32 7c ee			ld (debug_mark+2),a  
426c 18 03			jr .pastdmark  
426e ..			.dmark: db "FNd"  
4271 f1			.pastdmark: pop af  
4272			endm  
# End of macro DMARK
4272						CALLMONITOR 
4272 cd ff 13			call break_point_state  
4275				endm  
# End of macro CALLMONITOR
4275					endif 
4275 cd 8c 19			call forth_push_numhl 
4278			 
4278				       NEXTW 
4278 c3 f5 1c			jp macro_next 
427b				endm 
# End of macro NEXTW
427b			 
427b			.LEN: 
427b				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
427b 4c				db WORD_SYS_CORE+56             
427c b0 42			dw .CHAR            
427e 06				db 5 + 1 
427f .. 00			db "COUNT",0              
4285				endm 
# End of macro CWHEAD
4285			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4285			 
4285					if DEBUG_FORTH_WORDS_KEY 
4285						DMARK "CNT" 
4285 f5				push af  
4286 3a 9a 42			ld a, (.dmark)  
4289 32 7a ee			ld (debug_mark),a  
428c 3a 9b 42			ld a, (.dmark+1)  
428f 32 7b ee			ld (debug_mark+1),a  
4292 3a 9c 42			ld a, (.dmark+2)  
4295 32 7c ee			ld (debug_mark+2),a  
4298 18 03			jr .pastdmark  
429a ..			.dmark: db "CNT"  
429d f1			.pastdmark: pop af  
429e			endm  
# End of macro DMARK
429e						CALLMONITOR 
429e cd ff 13			call break_point_state  
42a1				endm  
# End of macro CALLMONITOR
42a1					endif 
42a1			; TODO check string type 
42a1					FORTH_DSP 
42a1 cd 49 1b			call macro_forth_dsp 
42a4				endm 
# End of macro FORTH_DSP
42a4					;v5FORTH_DSP_VALUE 
42a4			 
42a4 23					inc hl 
42a5			 
42a5 3e 00				ld a, 0 
42a7 cd 1b 10				call strlent 
42aa			 
42aa cd 8c 19				call forth_push_numhl 
42ad			 
42ad			 
42ad			 
42ad				       NEXTW 
42ad c3 f5 1c			jp macro_next 
42b0				endm 
# End of macro NEXTW
42b0			.CHAR: 
42b0				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
42b0 4d				db WORD_SYS_CORE+57             
42b1 e6 42			dw .ENDSTR            
42b3 05				db 4 + 1 
42b4 .. 00			db "CHAR",0              
42b9				endm 
# End of macro CWHEAD
42b9			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
42b9					if DEBUG_FORTH_WORDS_KEY 
42b9						DMARK "CHR" 
42b9 f5				push af  
42ba 3a ce 42			ld a, (.dmark)  
42bd 32 7a ee			ld (debug_mark),a  
42c0 3a cf 42			ld a, (.dmark+1)  
42c3 32 7b ee			ld (debug_mark+1),a  
42c6 3a d0 42			ld a, (.dmark+2)  
42c9 32 7c ee			ld (debug_mark+2),a  
42cc 18 03			jr .pastdmark  
42ce ..			.dmark: db "CHR"  
42d1 f1			.pastdmark: pop af  
42d2			endm  
# End of macro DMARK
42d2						CALLMONITOR 
42d2 cd ff 13			call break_point_state  
42d5				endm  
# End of macro CALLMONITOR
42d5					endif 
42d5					FORTH_DSP 
42d5 cd 49 1b			call macro_forth_dsp 
42d8				endm 
# End of macro FORTH_DSP
42d8					;v5 FORTH_DSP_VALUE 
42d8 23					inc hl      ; now at start of numeric as string 
42d9			 
42d9			;		push hl 
42d9			 
42d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42d9 cd 3b 1c			call macro_forth_dsp_pop 
42dc				endm 
# End of macro FORTH_DSP_POP
42dc			 
42dc			;		pop hl 
42dc			 
42dc					; push the content of a onto the stack as a value 
42dc			 
42dc 7e					ld a,(hl)   ; get char 
42dd 26 00				ld h,0 
42df 6f					ld l,a 
42e0 cd 8c 19				call forth_push_numhl 
42e3			 
42e3				       NEXTW 
42e3 c3 f5 1c			jp macro_next 
42e6				endm 
# End of macro NEXTW
42e6			 
42e6			 
42e6			 
42e6			 
42e6			.ENDSTR: 
42e6			; eof 
42e6			 
# End of file forth_words_str.asm
42e6			include "forth_words_key.asm" 
42e6			 
42e6			; | ## Keyboard Words 
42e6			 
42e6			.KEY: 
42e6				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
42e6 3e				db WORD_SYS_CORE+42             
42e7 16 43			dw .WAITK            
42e9 04				db 3 + 1 
42ea .. 00			db "KEY",0              
42ee				endm 
# End of macro CWHEAD
42ee			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
42ee			 
42ee					if DEBUG_FORTH_WORDS_KEY 
42ee						DMARK "KEY" 
42ee f5				push af  
42ef 3a 03 43			ld a, (.dmark)  
42f2 32 7a ee			ld (debug_mark),a  
42f5 3a 04 43			ld a, (.dmark+1)  
42f8 32 7b ee			ld (debug_mark+1),a  
42fb 3a 05 43			ld a, (.dmark+2)  
42fe 32 7c ee			ld (debug_mark+2),a  
4301 18 03			jr .pastdmark  
4303 ..			.dmark: db "KEY"  
4306 f1			.pastdmark: pop af  
4307			endm  
# End of macro DMARK
4307						CALLMONITOR 
4307 cd ff 13			call break_point_state  
430a				endm  
# End of macro CALLMONITOR
430a					endif 
430a			; TODO currently waits 
430a cd be 59				call cin 
430d					;call cin_wait 
430d 6f					ld l, a 
430e 26 00				ld h, 0 
4310 cd 8c 19				call forth_push_numhl 
4313					NEXTW 
4313 c3 f5 1c			jp macro_next 
4316				endm 
# End of macro NEXTW
4316			.WAITK: 
4316				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4316 3f				db WORD_SYS_CORE+43             
4317 48 43			dw .ACCEPT            
4319 06				db 5 + 1 
431a .. 00			db "WAITK",0              
4320				endm 
# End of macro CWHEAD
4320			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4320					if DEBUG_FORTH_WORDS_KEY 
4320						DMARK "WAI" 
4320 f5				push af  
4321 3a 35 43			ld a, (.dmark)  
4324 32 7a ee			ld (debug_mark),a  
4327 3a 36 43			ld a, (.dmark+1)  
432a 32 7b ee			ld (debug_mark+1),a  
432d 3a 37 43			ld a, (.dmark+2)  
4330 32 7c ee			ld (debug_mark+2),a  
4333 18 03			jr .pastdmark  
4335 ..			.dmark: db "WAI"  
4338 f1			.pastdmark: pop af  
4339			endm  
# End of macro DMARK
4339						CALLMONITOR 
4339 cd ff 13			call break_point_state  
433c				endm  
# End of macro CALLMONITOR
433c					endif 
433c cd b6 59				call cin_wait 
433f 6f					ld l, a 
4340 26 00				ld h, 0 
4342 cd 8c 19				call forth_push_numhl 
4345					NEXTW 
4345 c3 f5 1c			jp macro_next 
4348				endm 
# End of macro NEXTW
4348			.ACCEPT: 
4348				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4348 40				db WORD_SYS_CORE+44             
4349 a6 43			dw .EDIT            
434b 07				db 6 + 1 
434c .. 00			db "ACCEPT",0              
4353				endm 
# End of macro CWHEAD
4353			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4353					; TODO crashes on push 
4353					if DEBUG_FORTH_WORDS_KEY 
4353						DMARK "ACC" 
4353 f5				push af  
4354 3a 68 43			ld a, (.dmark)  
4357 32 7a ee			ld (debug_mark),a  
435a 3a 69 43			ld a, (.dmark+1)  
435d 32 7b ee			ld (debug_mark+1),a  
4360 3a 6a 43			ld a, (.dmark+2)  
4363 32 7c ee			ld (debug_mark+2),a  
4366 18 03			jr .pastdmark  
4368 ..			.dmark: db "ACC"  
436b f1			.pastdmark: pop af  
436c			endm  
# End of macro DMARK
436c						CALLMONITOR 
436c cd ff 13			call break_point_state  
436f				endm  
# End of macro CALLMONITOR
436f					endif 
436f 21 5e e5				ld hl, os_input 
4372 3e 00				ld a, 0 
4374 77					ld (hl),a 
4375 3a 49 eb				ld a,(f_cursor_ptr) 
4378 16 64				ld d, 100 
437a 0e 00				ld c, 0 
437c 1e 28				ld e, 40 
437e cd df 0b				call input_str 
4381					; TODO perhaps do a type check and wrap in quotes if not a number 
4381 21 5e e5				ld hl, os_input 
4384					if DEBUG_FORTH_WORDS 
4384						DMARK "AC1" 
4384 f5				push af  
4385 3a 99 43			ld a, (.dmark)  
4388 32 7a ee			ld (debug_mark),a  
438b 3a 9a 43			ld a, (.dmark+1)  
438e 32 7b ee			ld (debug_mark+1),a  
4391 3a 9b 43			ld a, (.dmark+2)  
4394 32 7c ee			ld (debug_mark+2),a  
4397 18 03			jr .pastdmark  
4399 ..			.dmark: db "AC1"  
439c f1			.pastdmark: pop af  
439d			endm  
# End of macro DMARK
439d						CALLMONITOR 
439d cd ff 13			call break_point_state  
43a0				endm  
# End of macro CALLMONITOR
43a0					endif 
43a0 cd fa 19				call forth_push_str 
43a3					NEXTW 
43a3 c3 f5 1c			jp macro_next 
43a6				endm 
# End of macro NEXTW
43a6			 
43a6			.EDIT: 
43a6				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
43a6 40				db WORD_SYS_CORE+44             
43a7 2f 44			dw .ENDKEY            
43a9 05				db 4 + 1 
43aa .. 00			db "EDIT",0              
43af				endm 
# End of macro CWHEAD
43af			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
43af			 
43af					; TODO does not copy from stack 
43af					if DEBUG_FORTH_WORDS_KEY 
43af						DMARK "EDT" 
43af f5				push af  
43b0 3a c4 43			ld a, (.dmark)  
43b3 32 7a ee			ld (debug_mark),a  
43b6 3a c5 43			ld a, (.dmark+1)  
43b9 32 7b ee			ld (debug_mark+1),a  
43bc 3a c6 43			ld a, (.dmark+2)  
43bf 32 7c ee			ld (debug_mark+2),a  
43c2 18 03			jr .pastdmark  
43c4 ..			.dmark: db "EDT"  
43c7 f1			.pastdmark: pop af  
43c8			endm  
# End of macro DMARK
43c8						CALLMONITOR 
43c8 cd ff 13			call break_point_state  
43cb				endm  
# End of macro CALLMONITOR
43cb					endif 
43cb			 
43cb					FORTH_DSP 
43cb cd 49 1b			call macro_forth_dsp 
43ce				endm 
# End of macro FORTH_DSP
43ce					;v5 FORTH_DSP_VALUE 
43ce 23					inc hl    ; TODO do type check 
43cf			 
43cf e5					push hl 
43d0 3e 00				ld a, 0 
43d2 cd 1b 10				call strlent 
43d5 23					inc hl 
43d6			 
43d6 06 00				ld b, 0 
43d8 4d					ld c, l 
43d9			 
43d9 e1					pop hl 
43da 11 5e e5				ld de, os_input 
43dd					if DEBUG_FORTH_WORDS_KEY 
43dd						DMARK "EDc" 
43dd f5				push af  
43de 3a f2 43			ld a, (.dmark)  
43e1 32 7a ee			ld (debug_mark),a  
43e4 3a f3 43			ld a, (.dmark+1)  
43e7 32 7b ee			ld (debug_mark+1),a  
43ea 3a f4 43			ld a, (.dmark+2)  
43ed 32 7c ee			ld (debug_mark+2),a  
43f0 18 03			jr .pastdmark  
43f2 ..			.dmark: db "EDc"  
43f5 f1			.pastdmark: pop af  
43f6			endm  
# End of macro DMARK
43f6						CALLMONITOR 
43f6 cd ff 13			call break_point_state  
43f9				endm  
# End of macro CALLMONITOR
43f9					endif 
43f9 ed b0				ldir 
43fb			 
43fb			 
43fb 21 5e e5				ld hl, os_input 
43fe					;ld a, 0 
43fe					;ld (hl),a 
43fe 3a 49 eb				ld a,(f_cursor_ptr) 
4401 16 64				ld d, 100 
4403 0e 00				ld c, 0 
4405 1e 28				ld e, 40 
4407 cd df 0b				call input_str 
440a					; TODO perhaps do a type check and wrap in quotes if not a number 
440a 21 5e e5				ld hl, os_input 
440d					if DEBUG_FORTH_WORDS 
440d						DMARK "ED1" 
440d f5				push af  
440e 3a 22 44			ld a, (.dmark)  
4411 32 7a ee			ld (debug_mark),a  
4414 3a 23 44			ld a, (.dmark+1)  
4417 32 7b ee			ld (debug_mark+1),a  
441a 3a 24 44			ld a, (.dmark+2)  
441d 32 7c ee			ld (debug_mark+2),a  
4420 18 03			jr .pastdmark  
4422 ..			.dmark: db "ED1"  
4425 f1			.pastdmark: pop af  
4426			endm  
# End of macro DMARK
4426						CALLMONITOR 
4426 cd ff 13			call break_point_state  
4429				endm  
# End of macro CALLMONITOR
4429					endif 
4429 cd fa 19				call forth_push_str 
442c					NEXTW 
442c c3 f5 1c			jp macro_next 
442f				endm 
# End of macro NEXTW
442f			 
442f			 
442f			 
442f			.ENDKEY: 
442f			; eof 
442f			 
# End of file forth_words_key.asm
442f			 
442f			if STORAGE_SE 
442f			   	include "forth_words_storage.asm" 
442f			endif 
442f				include "forth_words_device.asm" 
442f			; Device related words 
442f			 
442f			; | ## Device Words 
442f			 
442f			if SOUND_ENABLE 
442f			.NOTE: 
442f				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
442f			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
442f					if DEBUG_FORTH_WORDS_KEY 
442f						DMARK "NTE" 
442f						CALLMONITOR 
442f					endif 
442f			 
442f				 
442f			 
442f					NEXTW 
442f			.AFTERSOUND: 
442f			endif 
442f			 
442f			 
442f			USE_GPIO: equ 0 
442f			 
442f			if USE_GPIO 
442f			.GP1: 
442f				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
442f			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
442f					NEXTW 
442f			.GP2: 
442f				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
442f			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
442f			 
442f					NEXTW 
442f			 
442f			.GP3: 
442f				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
442f			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
442f			 
442f					NEXTW 
442f			 
442f			.GP4: 
442f				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
442f			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
442f			 
442f					NEXTW 
442f			.SIN: 
442f			 
442f			 
442f			endif 
442f			 
442f			 
442f				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
442f 33				db WORD_SYS_CORE+31             
4430 64 44			dw .SOUT            
4432 03				db 2 + 1 
4433 .. 00			db "IN",0              
4436				endm 
# End of macro CWHEAD
4436			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4436					if DEBUG_FORTH_WORDS_KEY 
4436						DMARK "IN." 
4436 f5				push af  
4437 3a 4b 44			ld a, (.dmark)  
443a 32 7a ee			ld (debug_mark),a  
443d 3a 4c 44			ld a, (.dmark+1)  
4440 32 7b ee			ld (debug_mark+1),a  
4443 3a 4d 44			ld a, (.dmark+2)  
4446 32 7c ee			ld (debug_mark+2),a  
4449 18 03			jr .pastdmark  
444b ..			.dmark: db "IN."  
444e f1			.pastdmark: pop af  
444f			endm  
# End of macro DMARK
444f						CALLMONITOR 
444f cd ff 13			call break_point_state  
4452				endm  
# End of macro CALLMONITOR
4452					endif 
4452					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4452 cd 83 1b			call macro_dsp_valuehl 
4455				endm 
# End of macro FORTH_DSP_VALUEHL
4455			 
4455 e5					push hl 
4456			 
4456					; destroy value TOS 
4456			 
4456					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4456 cd 3b 1c			call macro_forth_dsp_pop 
4459				endm 
# End of macro FORTH_DSP_POP
4459			 
4459					; one value on hl get other one back 
4459			 
4459 c1					pop bc 
445a			 
445a					; do the sub 
445a			;		ex de, hl 
445a			 
445a ed 68				in l,(c) 
445c			 
445c					; save it 
445c			 
445c 26 00				ld h,0 
445e			 
445e					; TODO push value back onto stack for another op etc 
445e			 
445e cd 8c 19				call forth_push_numhl 
4461					NEXTW 
4461 c3 f5 1c			jp macro_next 
4464				endm 
# End of macro NEXTW
4464			.SOUT: 
4464				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4464 34				db WORD_SYS_CORE+32             
4465 b7 44			dw .SPIO            
4467 04				db 3 + 1 
4468 .. 00			db "OUT",0              
446c				endm 
# End of macro CWHEAD
446c			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
446c					if DEBUG_FORTH_WORDS_KEY 
446c						DMARK "OUT" 
446c f5				push af  
446d 3a 81 44			ld a, (.dmark)  
4470 32 7a ee			ld (debug_mark),a  
4473 3a 82 44			ld a, (.dmark+1)  
4476 32 7b ee			ld (debug_mark+1),a  
4479 3a 83 44			ld a, (.dmark+2)  
447c 32 7c ee			ld (debug_mark+2),a  
447f 18 03			jr .pastdmark  
4481 ..			.dmark: db "OUT"  
4484 f1			.pastdmark: pop af  
4485			endm  
# End of macro DMARK
4485						CALLMONITOR 
4485 cd ff 13			call break_point_state  
4488				endm  
# End of macro CALLMONITOR
4488					endif 
4488			 
4488					; get port 
4488			 
4488					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4488 cd 83 1b			call macro_dsp_valuehl 
448b				endm 
# End of macro FORTH_DSP_VALUEHL
448b			 
448b e5					push hl 
448c			 
448c					; destroy value TOS 
448c			 
448c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
448c cd 3b 1c			call macro_forth_dsp_pop 
448f				endm 
# End of macro FORTH_DSP_POP
448f			 
448f					; get byte to send 
448f			 
448f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
448f cd 83 1b			call macro_dsp_valuehl 
4492				endm 
# End of macro FORTH_DSP_VALUEHL
4492			 
4492			;		push hl 
4492			 
4492					; destroy value TOS 
4492			 
4492					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4492 cd 3b 1c			call macro_forth_dsp_pop 
4495				endm 
# End of macro FORTH_DSP_POP
4495			 
4495					; one value on hl get other one back 
4495			 
4495			;		pop hl 
4495			 
4495 c1					pop bc 
4496			 
4496					if DEBUG_FORTH_WORDS 
4496						DMARK "OUT" 
4496 f5				push af  
4497 3a ab 44			ld a, (.dmark)  
449a 32 7a ee			ld (debug_mark),a  
449d 3a ac 44			ld a, (.dmark+1)  
44a0 32 7b ee			ld (debug_mark+1),a  
44a3 3a ad 44			ld a, (.dmark+2)  
44a6 32 7c ee			ld (debug_mark+2),a  
44a9 18 03			jr .pastdmark  
44ab ..			.dmark: db "OUT"  
44ae f1			.pastdmark: pop af  
44af			endm  
# End of macro DMARK
44af						CALLMONITOR 
44af cd ff 13			call break_point_state  
44b2				endm  
# End of macro CALLMONITOR
44b2					endif 
44b2			 
44b2 ed 69				out (c), l 
44b4			 
44b4					NEXTW 
44b4 c3 f5 1c			jp macro_next 
44b7				endm 
# End of macro NEXTW
44b7			 
44b7			 
44b7			.SPIO: 
44b7			 
44b7			if STORAGE_SE 
44b7				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
44b7			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
44b7			 
44b7					call spi_ce_low 
44b7			    NEXTW 
44b7			 
44b7			.SPICEH: 
44b7				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
44b7			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
44b7			 
44b7					call spi_ce_high 
44b7			    NEXTW 
44b7			 
44b7			 
44b7			.SPIOb: 
44b7			 
44b7				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
44b7			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
44b7			 
44b7					; get port 
44b7			 
44b7			 
44b7					; get byte to send 
44b7			 
44b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44b7			 
44b7			;		push hl    ; u1  
44b7			 
44b7					; destroy value TOS 
44b7			 
44b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b7			 
44b7					; one value on hl get other one back 
44b7			 
44b7			;		pop hl   ; u2 - addr 
44b7			 
44b7					; TODO Send SPI byte 
44b7			 
44b7					ld a, l 
44b7					call spi_send_byte 
44b7			 
44b7					NEXTW 
44b7			 
44b7			.SPII: 
44b7				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
44b7			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
44b7			 
44b7					; TODO Get SPI byte 
44b7			 
44b7					call spi_read_byte 
44b7			 
44b7					ld h, 0 
44b7					ld l, a 
44b7					call forth_push_numhl 
44b7			 
44b7					NEXTW 
44b7			 
44b7			 
44b7			 
44b7			.SESEL: 
44b7				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
44b7			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
44b7					if DEBUG_FORTH_WORDS_KEY 
44b7						DMARK "BNK" 
44b7						CALLMONITOR 
44b7					endif 
44b7			 
44b7					ld a, 255 
44b7					ld (spi_cartdev), a 
44b7			 
44b7					; get bank 
44b7			 
44b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44b7			 
44b7			;		push hl 
44b7			 
44b7					; destroy value TOS 
44b7			 
44b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b7			 
44b7					; one value on hl get other one back 
44b7			 
44b7			;		pop hl 
44b7			 
44b7			 
44b7					ld c, SPI_CE_HIGH 
44b7					ld b, '0'    ; human readable bank number 
44b7			 
44b7					ld a, l 
44b7			 
44b7					if DEBUG_FORTH_WORDS 
44b7						DMARK "BNK" 
44b7						CALLMONITOR 
44b7					endif 
44b7			 
44b7					; active low 
44b7			 
44b7					cp 0 
44b7					jr z, .bset 
44b7					cp 1 
44b7					jr nz, .b2 
44b7					res 0, c 
44b7					ld b, '1'    ; human readable bank number 
44b7			.b2:		cp 2 
44b7					jr nz, .b3 
44b7					res 1, c 
44b7					ld b, '2'    ; human readable bank number 
44b7			.b3:		cp 3 
44b7					jr nz, .b4 
44b7					res 2, c 
44b7					ld b, '3'    ; human readable bank number 
44b7			.b4:		cp 4 
44b7					jr nz, .b5 
44b7					res 3, c 
44b7					ld b, '4'    ; human readable bank number 
44b7			.b5:		cp 5 
44b7					jr nz, .bset 
44b7					res 4, c 
44b7					ld b, '5'    ; human readable bank number 
44b7			 
44b7			.bset: 
44b7					ld a, c 
44b7					ld (spi_device),a 
44b7					ld a, b 
44b7					ld (spi_device_id),a 
44b7					if DEBUG_FORTH_WORDS 
44b7						DMARK "BN2" 
44b7						CALLMONITOR 
44b7					endif 
44b7			 
44b7					NEXTW 
44b7			 
44b7			.CARTDEV: 
44b7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
44b7			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
44b7					if DEBUG_FORTH_WORDS_KEY 
44b7						DMARK "CDV" 
44b7						CALLMONITOR 
44b7					endif 
44b7			 
44b7					; disable se storage bank selection 
44b7			 
44b7					ld a, SPI_CE_HIGH		; ce high 
44b7					ld (spi_device), a 
44b7			 
44b7					; get bank 
44b7			 
44b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44b7			 
44b7			;		push hl 
44b7			 
44b7					; destroy value TOS 
44b7			 
44b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b7			 
44b7					; one value on hl get other one back 
44b7			 
44b7			;		pop hl 
44b7			 
44b7					; active low 
44b7			 
44b7					ld c, 255 
44b7			 
44b7					ld a, l 
44b7					if DEBUG_FORTH_WORDS 
44b7						DMARK "CDV" 
44b7						CALLMONITOR 
44b7					endif 
44b7					cp 0 
44b7					jr z, .cset 
44b7					cp 1 
44b7					jr nz, .c2 
44b7					res 0, c 
44b7			.c2:		cp 2 
44b7					jr nz, .c3 
44b7					res 1, c 
44b7			.c3:		cp 3 
44b7					jr nz, .c4 
44b7					res 2, c 
44b7			.c4:		cp 4 
44b7					jr nz, .c5 
44b7					res 3, c 
44b7			.c5:		cp 5 
44b7					jr nz, .c6 
44b7					res 4, c 
44b7			.c6:		cp 6 
44b7					jr nz, .c7 
44b7					res 5, c 
44b7			.c7:		cp 7 
44b7					jr nz, .c8 
44b7					res 6, c 
44b7			.c8:		cp 8 
44b7					jr nz, .cset 
44b7					res 7, c 
44b7			.cset:		ld a, c 
44b7					ld (spi_cartdev),a 
44b7			 
44b7					if DEBUG_FORTH_WORDS 
44b7						DMARK "CD2" 
44b7						CALLMONITOR 
44b7					endif 
44b7					NEXTW 
44b7			endif 
44b7			 
44b7			.ENDDEVICE: 
44b7			; eof 
44b7			 
# End of file forth_words_device.asm
44b7			 
44b7			; var handler 
44b7			 
44b7			 
44b7			.VARS: 
44b7				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
44b7 78				db WORD_SYS_CORE+100             
44b8 cf 44			dw .V0Q            
44ba 04				db 3 + 1 
44bb .. 00			db "V0!",0              
44bf				endm 
# End of macro CWHEAD
44bf			;| V0! ( u1 -- )  Store value to v0  | DONE 
44bf			 
44bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44bf cd 83 1b			call macro_dsp_valuehl 
44c2				endm 
# End of macro FORTH_DSP_VALUEHL
44c2			 
44c2 11 13 eb				ld de, cli_var_array 
44c5			 
44c5 eb					ex de, hl 
44c6 73					ld (hl), e 
44c7 23					inc hl 
44c8 72					ld (hl), d 
44c9			 
44c9					; destroy value TOS 
44c9			 
44c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44c9 cd 3b 1c			call macro_forth_dsp_pop 
44cc				endm 
# End of macro FORTH_DSP_POP
44cc			 
44cc				       NEXTW 
44cc c3 f5 1c			jp macro_next 
44cf				endm 
# End of macro NEXTW
44cf			.V0Q: 
44cf				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
44cf 79				db WORD_SYS_CORE+101             
44d0 e0 44			dw .V1S            
44d2 04				db 3 + 1 
44d3 .. 00			db "V0@",0              
44d7				endm 
# End of macro CWHEAD
44d7			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
44d7 2a 13 eb				ld hl, (cli_var_array) 
44da cd 8c 19				call forth_push_numhl 
44dd			 
44dd				       NEXTW 
44dd c3 f5 1c			jp macro_next 
44e0				endm 
# End of macro NEXTW
44e0			.V1S: 
44e0				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
44e0 7a				db WORD_SYS_CORE+102             
44e1 f8 44			dw .V1Q            
44e3 04				db 3 + 1 
44e4 .. 00			db "V1!",0              
44e8				endm 
# End of macro CWHEAD
44e8			;| V1! ( u1 -- )  Store value to v1 | DONE 
44e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44e8 cd 83 1b			call macro_dsp_valuehl 
44eb				endm 
# End of macro FORTH_DSP_VALUEHL
44eb			 
44eb 11 15 eb				ld de, cli_var_array+2 
44ee				 
44ee eb					ex de, hl 
44ef 73					ld (hl), e 
44f0 23					inc hl 
44f1 72					ld (hl), d 
44f2			 
44f2					; destroy value TOS 
44f2			 
44f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44f2 cd 3b 1c			call macro_forth_dsp_pop 
44f5				endm 
# End of macro FORTH_DSP_POP
44f5				       NEXTW 
44f5 c3 f5 1c			jp macro_next 
44f8				endm 
# End of macro NEXTW
44f8			.V1Q: 
44f8				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
44f8 7b				db WORD_SYS_CORE+103             
44f9 09 45			dw .V2S            
44fb 04				db 3 + 1 
44fc .. 00			db "V1@",0              
4500				endm 
# End of macro CWHEAD
4500			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4500 2a 15 eb				ld hl, (cli_var_array+2) 
4503 cd 8c 19				call forth_push_numhl 
4506				       NEXTW 
4506 c3 f5 1c			jp macro_next 
4509				endm 
# End of macro NEXTW
4509			.V2S: 
4509				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4509 7c				db WORD_SYS_CORE+104             
450a 21 45			dw .V2Q            
450c 04				db 3 + 1 
450d .. 00			db "V2!",0              
4511				endm 
# End of macro CWHEAD
4511			;| V2! ( u1 -- )  Store value to v2 | DONE 
4511					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4511 cd 83 1b			call macro_dsp_valuehl 
4514				endm 
# End of macro FORTH_DSP_VALUEHL
4514			 
4514 11 17 eb				ld de, cli_var_array+4 
4517				 
4517 eb					ex de, hl 
4518 73					ld (hl), e 
4519 23					inc hl 
451a 72					ld (hl), d 
451b			 
451b					; destroy value TOS 
451b			 
451b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
451b cd 3b 1c			call macro_forth_dsp_pop 
451e				endm 
# End of macro FORTH_DSP_POP
451e				       NEXTW 
451e c3 f5 1c			jp macro_next 
4521				endm 
# End of macro NEXTW
4521			.V2Q: 
4521				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4521 7d				db WORD_SYS_CORE+105             
4522 32 45			dw .V3S            
4524 04				db 3 + 1 
4525 .. 00			db "V2@",0              
4529				endm 
# End of macro CWHEAD
4529			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4529 2a 17 eb				ld hl, (cli_var_array+4) 
452c cd 8c 19				call forth_push_numhl 
452f				       NEXTW 
452f c3 f5 1c			jp macro_next 
4532				endm 
# End of macro NEXTW
4532			.V3S: 
4532				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4532 7c				db WORD_SYS_CORE+104             
4533 4a 45			dw .V3Q            
4535 04				db 3 + 1 
4536 .. 00			db "V3!",0              
453a				endm 
# End of macro CWHEAD
453a			;| V3! ( u1 -- )  Store value to v3 | DONE 
453a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
453a cd 83 1b			call macro_dsp_valuehl 
453d				endm 
# End of macro FORTH_DSP_VALUEHL
453d			 
453d 11 19 eb				ld de, cli_var_array+6 
4540				 
4540 eb					ex de, hl 
4541 73					ld (hl), e 
4542 23					inc hl 
4543 72					ld (hl), d 
4544			 
4544					; destroy value TOS 
4544			 
4544					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4544 cd 3b 1c			call macro_forth_dsp_pop 
4547				endm 
# End of macro FORTH_DSP_POP
4547				       NEXTW 
4547 c3 f5 1c			jp macro_next 
454a				endm 
# End of macro NEXTW
454a			.V3Q: 
454a				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
454a 7d				db WORD_SYS_CORE+105             
454b 5b 45			dw .END            
454d 04				db 3 + 1 
454e .. 00			db "V3@",0              
4552				endm 
# End of macro CWHEAD
4552			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4552 2a 19 eb				ld hl, (cli_var_array+6) 
4555 cd 8c 19				call forth_push_numhl 
4558				       NEXTW 
4558 c3 f5 1c			jp macro_next 
455b				endm 
# End of macro NEXTW
455b			 
455b			 
455b			 
455b			 
455b			 
455b			; end of dict marker 
455b			 
455b 00			.END:    db WORD_SYS_END 
455c 00 00			dw 0 
455e 00				db 0 
455f			 
455f			; use to jp here for user dict words to save on macro expansion  
455f			 
455f			user_dict_next: 
455f				NEXTW 
455f c3 f5 1c			jp macro_next 
4562				endm 
# End of macro NEXTW
4562			 
4562			 
4562			user_exec: 
4562				;    ld hl, <word code> 
4562				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4562				;    call forthexec 
4562				;    jp user_dict_next   (NEXT) 
4562			        ;    <word code bytes> 
4562 eb				ex de, hl 
4563 2a 61 e6			ld hl,(os_tok_ptr) 
4566				 
4566				FORTH_RSP_NEXT 
4566 cd 33 19			call macro_forth_rsp_next 
4569				endm 
# End of macro FORTH_RSP_NEXT
4569			 
4569			if DEBUG_FORTH_UWORD 
4569						DMARK "UEX" 
4569 f5				push af  
456a 3a 7e 45			ld a, (.dmark)  
456d 32 7a ee			ld (debug_mark),a  
4570 3a 7f 45			ld a, (.dmark+1)  
4573 32 7b ee			ld (debug_mark+1),a  
4576 3a 80 45			ld a, (.dmark+2)  
4579 32 7c ee			ld (debug_mark+2),a  
457c 18 03			jr .pastdmark  
457e ..			.dmark: db "UEX"  
4581 f1			.pastdmark: pop af  
4582			endm  
# End of macro DMARK
4582				CALLMONITOR 
4582 cd ff 13			call break_point_state  
4585				endm  
# End of macro CALLMONITOR
4585			endif 
4585			 
4585			 
4585			 
4585 eb				ex de, hl 
4586 22 61 e6			ld (os_tok_ptr), hl 
4589				 
4589				; Don't use next - Skips the first word in uword. 
4589			 
4589 c3 86 1d			jp exec1 
458c			;	NEXT 
458c			 
458c			 
458c			; eof 
# End of file forth_wordsv4.asm
458c			endif 
458c			;;;;;;;;;;;;;; Debug code 
458c			 
458c			 
458c			;if DEBUG_FORTH_PARSE 
458c .. 00		.nowordfound: db "No match",0 
4595 .. 00		.compword:	db "Comparing word ",0 
45a5 .. 00		.nextwordat:	db "Next word at",0 
45b2 .. 00		.charmatch:	db "Char match",0 
45bd			;endif 
45bd			if DEBUG_FORTH_JP 
45bd			.foundword:	db "Word match. Exec..",0 
45bd			endif 
45bd			;if DEBUG_FORTH_PUSH 
45bd .. 00		.enddict:	db "Dict end. Push.",0 
45cd .. 00		.push_str:	db "Pushing string",0 
45dc .. 00		.push_num:	db "Pushing number",0 
45eb .. 00		.data_sp:	db "SP:",0 
45ef .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4601 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4613 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4625			;endif 
4625			;if DEBUG_FORTH_MALLOC 
4625 .. 00		.push_malloc:	db "Malloc address",0 
4634			;endif 
4634			 
4634			 
4634			 
4634			; display malloc address and current data stack pointer  
4634			 
4634			malloc_error: 
4634 d5				push de 
4635 f5				push af 
4636 e5				push hl 
4637 cd 85 09			call clear_display 
463a 11 5c 46			ld de, .mallocerr 
463d 3e 00			ld a,0 
463f			;	ld de,os_word_scratch 
463f cd 98 09			call str_at_display 
4642 3e 11			ld a, display_row_1+17 
4644 11 7a ee			ld de, debug_mark 
4647 cd 98 09			call str_at_display 
464a cd a8 09			call update_display 
464d				;call break_point_state 
464d cd b6 59			call cin_wait 
4650			 
4650 3e 20			ld a, ' ' 
4652 32 51 e3			ld (os_view_disable), a 
4655 e1				pop hl 
4656 f1				pop af 
4657 d1				pop de	 
4658				CALLMONITOR 
4658 cd ff 13			call break_point_state  
465b				endm  
# End of macro CALLMONITOR
465b c9				ret 
465c			 
465c .. 00		.mallocerr: 	db "Malloc Error",0 
4669			;if DEBUG_FORTH_PUSH 
4669			display_data_sp: 
4669 f5				push af 
466a			 
466a				; see if disabled 
466a			 
466a 3a 51 e3			ld a, (os_view_disable) 
466d fe 2a			cp '*' 
466f 28 67			jr z, .skipdsp 
4671			 
4671 e5				push hl 
4672 e5				push hl 
4673 e5			push hl 
4674 cd 85 09			call clear_display 
4677 e1			pop hl 
4678 7c				ld a,h 
4679 21 65 e6			ld hl, os_word_scratch 
467c cd b3 0e			call hexout 
467f e1				pop hl 
4680 7d				ld a,l 
4681 21 67 e6			ld hl, os_word_scratch+2 
4684 cd b3 0e			call hexout 
4687 21 69 e6			ld hl, os_word_scratch+4 
468a 3e 00			ld a,0 
468c 77				ld (hl),a 
468d 11 65 e6			ld de,os_word_scratch 
4690 3e 28				ld a, display_row_2 
4692 cd 98 09				call str_at_display 
4695 11 ef 45			ld de, .wordinhl 
4698 3e 00			ld a, display_row_1 
469a			 
469a cd 98 09				call str_at_display 
469d 11 7a ee			ld de, debug_mark 
46a0 3e 11			ld a, display_row_1+17 
46a2			 
46a2 cd 98 09				call str_at_display 
46a5			 
46a5				; display current data stack pointer 
46a5 11 eb 45			ld de,.data_sp 
46a8 3e 30				ld a, display_row_2 + 8 
46aa cd 98 09				call str_at_display 
46ad			 
46ad 2a 0d eb			ld hl,(cli_data_sp) 
46b0 e5				push hl 
46b1 7c				ld a,h 
46b2 21 65 e6			ld hl, os_word_scratch 
46b5 cd b3 0e			call hexout 
46b8 e1				pop hl 
46b9 7d				ld a,l 
46ba 21 67 e6			ld hl, os_word_scratch+2 
46bd cd b3 0e			call hexout 
46c0 21 69 e6			ld hl, os_word_scratch+4 
46c3 3e 00			ld a,0 
46c5 77				ld (hl),a 
46c6 11 65 e6			ld de,os_word_scratch 
46c9 3e 33				ld a, display_row_2 + 11 
46cb cd 98 09				call str_at_display 
46ce			 
46ce			 
46ce cd a8 09			call update_display 
46d1 cd fa 08			call delay1s 
46d4 cd fa 08			call delay1s 
46d7 e1				pop hl 
46d8			.skipdsp: 
46d8 f1				pop af 
46d9 c9				ret 
46da			 
46da			display_data_malloc: 
46da			 
46da f5				push af 
46db e5				push hl 
46dc e5				push hl 
46dd e5			push hl 
46de cd 85 09			call clear_display 
46e1 e1			pop hl 
46e2 7c				ld a,h 
46e3 21 65 e6			ld hl, os_word_scratch 
46e6 cd b3 0e			call hexout 
46e9 e1				pop hl 
46ea 7d				ld a,l 
46eb 21 67 e6			ld hl, os_word_scratch+2 
46ee cd b3 0e			call hexout 
46f1 21 69 e6			ld hl, os_word_scratch+4 
46f4 3e 00			ld a,0 
46f6 77				ld (hl),a 
46f7 11 65 e6			ld de,os_word_scratch 
46fa 3e 28				ld a, display_row_2 
46fc cd 98 09				call str_at_display 
46ff 11 25 46			ld de, .push_malloc 
4702 3e 00			ld a, display_row_1 
4704			 
4704 cd 98 09				call str_at_display 
4707			 
4707				; display current data stack pointer 
4707 11 eb 45			ld de,.data_sp 
470a 3e 30				ld a, display_row_2 + 8 
470c cd 98 09				call str_at_display 
470f			 
470f 2a 0d eb			ld hl,(cli_data_sp) 
4712 e5				push hl 
4713 7c				ld a,h 
4714 21 65 e6			ld hl, os_word_scratch 
4717 cd b3 0e			call hexout 
471a e1				pop hl 
471b 7d				ld a,l 
471c 21 67 e6			ld hl, os_word_scratch+2 
471f cd b3 0e			call hexout 
4722 21 69 e6			ld hl, os_word_scratch+4 
4725 3e 00			ld a,0 
4727 77				ld (hl),a 
4728 11 65 e6			ld de,os_word_scratch 
472b 3e 33				ld a, display_row_2 + 11 
472d cd 98 09				call str_at_display 
4730			 
4730 cd a8 09			call update_display 
4733 cd fa 08			call delay1s 
4736 cd fa 08			call delay1s 
4739 e1				pop hl 
473a f1				pop af 
473b c9				ret 
473c			;endif 
473c			 
473c			include "forth_autostart.asm" 
473c			; list of commands to perform at system start up 
473c			 
473c			startcmds: 
473c			;	dw test11 
473c			;	dw test12 
473c			;	dw test13 
473c			;	dw test14 
473c			;	dw test15 
473c			;	dw test16 
473c			;	dw test17 
473c			;	dw ifthtest1 
473c			;	dw ifthtest2 
473c			;	dw ifthtest3 
473c			;	dw mmtest1 
473c			;	dw mmtest2 
473c			;	dw mmtest3 
473c			;	dw mmtest4 
473c			;	dw mmtest5 
473c			;	dw mmtest6 
473c			;	dw iftest1 
473c			;	dw iftest2 
473c			;	dw iftest3 
473c			;	dw looptest1 
473c			;	dw looptest2 
473c			;	dw test1 
473c			;	dw test2 
473c			;	dw test3 
473c			;	dw test4 
473c			;	dw game2r 
473c			;	dw game2b1 
473c			;	dw game2b2 
473c			 
473c				; start up words that are actually useful 
473c			 
473c 9a 47			dw clrstack 
473e cd 47			dw type 
4740 8e 49			dw stest 
4742 f1 47			dw strncpy 
4744 2f 49			dw list 
4746 52 48			dw start1 
4748 64 48			dw start2 
474a			;	dw start3 
474a 77 48			dw start3b 
474c cf 48			dw start3c 
474e			 
474e				; (unit) testing words 
474e			 
474e 05 4a			dw mtesta 
4750 ba 4a			dw mtestb 
4752 5d 4b			dw mtestc 
4754 12 4c			dw mtestd 
4756 b6 4c			dw mteste 
4758			 
4758				; demo/game words 
4758			 
4758 c2 53		        dw game3w 
475a f0 53		        dw game3p 
475c 0e 54		        dw game3sc 
475e 3f 54		        dw game3vsi 
4760 6b 54		        dw game3vs 
4762				 
4762 b5 51			dw game2b 
4764 23 52			dw game2bf 
4766 6d 52			dw game2mba 
4768 03 53			dw game2mbas 
476a 45 53			dw game2mb 
476c			 
476c 76 4e			dw game1 
476e 87 4e			dw game1a 
4770 e9 4e			dw game1b 
4772 1e 4f			dw game1c 
4774 54 4f			dw game1d 
4776 85 4f			dw game1s 
4778 99 4f			dw game1t 
477a ae 4f			dw game1f 
477c e2 4f			dw game1z 
477e 26 50			dw game1zz 
4780			 
4780 6c 4d			dw test5 
4782 a4 4d			dw test6 
4784 dc 4d			dw test7 
4786 f0 4d			dw test8 
4788 1c 4e			dw test9 
478a 32 4e			dw test10 
478c				 
478c fd 50		        dw ssv5 
478e e1 50		        dw ssv4 
4790 c5 50		        dw ssv3 
4792 8f 50		        dw ssv2 
4794 16 51		        dw ssv1 
4796 5e 51		        dw ssv1cpm 
4798			;	dw keyup 
4798			;	dw keydown 
4798			;	dw keyleft 
4798			;	dw keyright 
4798			;	dw 	keyf1 
4798			;	dw keyf2 
4798			;	dw keyf3 
4798			;	dw keyf4 
4798			;	dw keyf5 
4798			;	dw keyf6 
4798			;	dw keyf7 
4798			;	dw keyf8 
4798			;	dw keyf9 
4798			;	dw keyf10 
4798			;	dw keyf11 
4798			;	dw keyf12 
4798			;	dw keytab 
4798			;	dw keycr 
4798			;	dw keyhome 
4798			;	dw keyend 
4798			;	dw keybs 
4798 00 00			db 0, 0	 
479a			 
479a			 
479a			; clear stack  
479a			 
479a .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
47cd			 
47cd			; type ( addr count - ) 
47cd .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
47f1			 
47f1			; some direct memory words 
47f1			; strncpy ( len t f -- t ) 
47f1			 
47f1 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4852			 
4852 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4864 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4877			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
4877 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
48cf .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
492f			 
492f			 
492f			; a handy word to list items on the stack 
492f			 
492f .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
498e			 
498e			 
498e			; test stack  
498e			; rnd8 stest 
498e			 
498e .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4a05			 
4a05			; random malloc and free cycles 
4a05			 
4a05 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4aba			 
4aba			; fixed malloc and free cycles 
4aba			 
4aba .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4b5d			 
4b5d			; fixed double string push and drop cycle  
4b5d			 
4b5d .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4c12			 
4c12			; consistent fixed string push and drop cycle  
4c12			 
4c12 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4cb6			 
4cb6 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4d6c			 
4d6c			;test1:		db ": aa 1 2 3 ;", 0 
4d6c			;test2:     	db "111 aa 888 999",0 
4d6c			;test3:     	db ": bb 77 ;",0 
4d6c			;test4:     	db "$02 $01 do i . loop bb",0 
4d6c			 
4d6c .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4da4 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4ddc .. 00		test7:     	db ": box hline vline ;",0 
4df0 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4e1c .. 00		test9:     	db ": sw $01 adsp world ;",0 
4e32 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4e57 .. 00		test11:     	db "hello create .",0 
4e66 .. 00		test12:     	db "hello2 create .",0 
4e76			 
4e76			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4e76			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4e76			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4e76			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4e76			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4e76			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4e76			 
4e76			;iftest1:     	db "$0001 IF cls .",0 
4e76			;iftest2:     	db "$0000 IF cls .",0 
4e76			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4e76			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4e76			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4e76			 
4e76			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4e76			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4e76			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4e76			 
4e76			 
4e76			 
4e76			; a small guess the number game 
4e76			 
4e76 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4e87 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4ee9			 
4ee9 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4f1e .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4f54 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4f85 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4f99 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4fae .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4fe2 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5026			 
5026			; Using 'ga' save a high score across multiple runs using external storage 
5026			 
5026 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
508f			 
508f			 
508f			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
508f			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
508f			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
508f			 
508f			; simple screen saver to test code memory reuse to destruction 
508f			 
508f .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
50c5 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
50e1 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
50fd .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5116 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
515e .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
51b5			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
51b5			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
51b5			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
51b5			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
51b5			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
51b5			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
51b5			 
51b5			 
51b5			 
51b5			; minesweeper/battleship finding game 
51b5			; draws a game board of random ship/mine positions 
51b5			; user enters coords to see if it hits on 
51b5			; game ends when all are hit 
51b5			; when hit or miss says how many may be in the area 
51b5			 
51b5			; setup the game board and then hide it 
51b5 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5223 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
526d			; prompt for where to target 
526d .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5303 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5328			; TODO see if the entered coords hits or misses pushes char hit of miss 
5328 .. 00		game2mbht:      db ": mbckht nop ;",0 
5337 .. 00		game2mbms:      db ": mbcms nop ;",0 
5345			; TODO how many might be near by 
5345 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
53c2			 
53c2			; Game 3 
53c2			 
53c2			; Vert scroller ski game - avoid the trees! 
53c2			 
53c2			; v0 score (ie turns) 
53c2			; v1 player pos 
53c2			; v2 left wall 
53c2			; v3 right wall 
53c2			 
53c2			; Draw side walls randomly 
53c2			 
53c2 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
53f0			 
53f0			; Draw player 
53f0 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
540e			 
540e			; TODO Get Key 
540e			 
540e			; TODO Move left right 
540e			 
540e			; scroll and move walls a bit 
540e			 
540e .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
543f			 
543f			; main game loop 
543f			 
543f .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
546b .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
54aa			 
54aa			; key board defs 
54aa			 
54aa .. 00		keyup:       db ": keyup $05 ;",0 
54b8 .. 00		keydown:       db ": keydown $0a ;",0 
54c8 .. 00		keyleft:       db ": keyleft $0b ;",0 
54d8 .. 00		keyright:       db ": keyright $0c ;",0 
54e9 .. 00		keyf1:       db ": keyf1 $10 ;",0 
54f7 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5505 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5513 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5521 .. 00		keyf5:       db ": keyf5 $14 ;",0 
552f .. 00		keyf6:       db ": keyf6 $15 ;",0 
553d .. 00		keyf7:       db ": keyf7 $16 ;",0 
554b .. 00		keyf8:       db ": keyf8 $17 ;",0 
5559 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5567 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5576 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5585 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5594			 
5594 .. 00		keytab:       db ": keytab $09 ;",0 
55a3 .. 00		keycr:       db ": keycr $0d ;",0 
55b1 .. 00		keyhome:       db ": keyhome $0e ;",0 
55c1 .. 00		keyend:       db ": keyend $0f ;",0 
55d0 .. 00		keybs:       db ": keybs $08 ;",0 
55de			 
55de			   
55de			 
55de			 
55de			 
55de			; eof 
# End of file forth_autostart.asm
55de			 
55de .. 00		sprompt1: db "Startup load...",0 
55ee .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5604			 
5604			forth_startup: 
5604 21 3c 47			ld hl, startcmds 
5607 3e 00			ld a, 0 
5609 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
560c			 
560c e5			.start1:	push hl 
560d cd 85 09			call clear_display 
5610 11 de 55			ld de, sprompt1 
5613 3e 00		        ld a, display_row_1 
5615 cd 98 09			call str_at_display 
5618 11 ee 55			ld de, sprompt2 
561b 3e 28		        ld a, display_row_2 
561d cd 98 09			call str_at_display 
5620 e1				pop hl 
5621 e5				push hl 
5622 5e				ld e,(hl) 
5623 23				inc hl 
5624 56				ld d,(hl) 
5625 3e 50		        ld a, display_row_3 
5627 cd 98 09			call str_at_display 
562a cd a8 09			call update_display 
562d			 
562d			 
562d 3a 86 e7			ld a, (os_last_cmd) 
5630 fe 00			cp 0 
5632 28 05			jr z, .startprompt 
5634 cd ee 08			call delay250ms 
5637 18 24			jr .startdo 
5639				 
5639				 
5639			 
5639			.startprompt: 
5639			 
5639 3e 9f			ld a,display_row_4 + display_cols - 1 
563b 11 02 19		        ld de, endprg 
563e cd 98 09			call str_at_display 
5641 cd a8 09			call update_display 
5644 cd fa 08			call delay1s 
5647 cd b6 59			call cin_wait 
564a						 
564a fe 2a			cp '*' 
564c 28 5e			jr z, .startupend1 
564e fe 23			cp '#' 
5650 20 07			jr nz, .startno 
5652 3e 01			ld a, 1 
5654 32 86 e7			ld (os_last_cmd),a 
5657 18 04			jr .startdo 
5659 fe 31		.startno:	cp '1' 
565b 28 3a			jr z,.startnxt  
565d			 
565d				; exec startup line 
565d			.startdo:	 
565d e1				pop hl 
565e e5				push hl 
565f				 
565f 5e				ld e,(hl) 
5660 23				inc hl 
5661 56				ld d,(hl) 
5662 eb				ex de,hl 
5663			 
5663 e5				push hl 
5664			 
5664 3e 00			ld a, 0 
5666				;ld a, FORTH_END_BUFFER 
5666 cd 1b 10			call strlent 
5669 23				inc hl   ; include zero term to copy 
566a 06 00			ld b,0 
566c 4d				ld c,l 
566d e1				pop hl 
566e 11 60 e3			ld de, scratch 
5671 ed b0			ldir 
5673			 
5673			 
5673 21 60 e3			ld hl, scratch 
5676 cd 43 1d			call forthparse 
5679 cd 83 1d			call forthexec 
567c cd 9a 1c			call forthexec_cleanup 
567f			 
567f 3e 78			ld a, display_row_4 
5681 11 a6 16			ld de, endprog 
5684			 
5684 cd a8 09			call update_display		 
5687			 
5687 3a 86 e7			ld a, (os_last_cmd) 
568a fe 00			cp 0 
568c 20 09			jr nz, .startnxt 
568e cd 04 19			call next_page_prompt 
5691 cd 85 09		        call clear_display 
5694 cd a8 09			call update_display		 
5697			 
5697				; move onto next startup line? 
5697			.startnxt: 
5697			 
5697 cd ee 08			call delay250ms 
569a e1				pop hl 
569b			 
569b 23				inc hl 
569c 23				inc hl 
569d			 
569d e5				push hl 
569e 5e				ld e, (hl) 
569f 23				inc hl 
56a0 56				ld d, (hl) 
56a1 e1				pop hl 
56a2				; TODO replace 0 test 
56a2			 
56a2 eb				ex de, hl 
56a3 cd db 0b			call ishlzero 
56a6			;	ld a,e 
56a6			;	add d 
56a6			;	cp 0    ; any left to do? 
56a6 eb				ex de, hl 
56a7 c2 0c 56			jp nz, .start1 
56aa 18 01			jr .startupend 
56ac			 
56ac e1			.startupend1: pop hl 
56ad			.startupend: 
56ad			 
56ad cd 85 09			call clear_display 
56b0 cd a8 09			call update_display 
56b3 c9				ret 
56b4			 
56b4			 
56b4			; stack over and underflow checks 
56b4			 
56b4			; init the words to detect the under/overflow 
56b4			 
56b4			chk_stk_init: 
56b4				; a vague random number to check so we dont get any "lucky" hits 
56b4 3e 2d			ld a, 45 
56b6 6f				ld l, a 
56b7 00				nop 
56b8 3e 17			ld a, 23 
56ba 67				ld h, a 
56bb			 
56bb 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
56be			 
56be			;	ld (chk_stund), hl	; stack points.... 
56be 22 00 ef			ld (chk_stovr), hl 
56c1 22 0b eb			ld (chk_ret_und), hl 
56c4 22 c9 ea			ld (chk_ret_ovr), hl 
56c7 22 c7 e9			ld (chk_loop_ovr), hl 
56ca 22 c5 e8			ld (chk_data_ovr), hl 
56cd c9				ret 
56ce				 
56ce			check_stacks: 
56ce				; check all stack words 
56ce			 
56ce e5				push hl 
56cf d5				push de 
56d0			 
56d0			;	ld de,(chk_word) 
56d0			;	ld hl, (chk_stund)	; stack points.... 
56d0			;	if DEBUG_STK_FAULT 
56d0			;		DMARK "FAa" 
56d0			;		CALLMONITOR 
56d0			;	endif 
56d0			;	call cmp16 
56d0			;	jp z, .chk_faulta 
56d0			; 
56d0			;	ld de, sfaultsu 
56d0			;	jp .chk_fault 
56d0			 
56d0 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
56d3 ed 5b 47 e3		ld de,(chk_word) 
56d7				if DEBUG_STK_FAULT 
56d7					DMARK "FAb" 
56d7					CALLMONITOR 
56d7				endif 
56d7 cd d0 0b			call cmp16 
56da 28 06			jr z, .chk_fault1 
56dc 11 7d 57			ld de, sfaultso 
56df c3 31 57			jp .chk_fault 
56e2			.chk_fault1:  
56e2 2a 0b eb			ld hl, (chk_ret_und) 
56e5 ed 5b 47 e3		ld de,(chk_word) 
56e9				if DEBUG_STK_FAULT 
56e9					DMARK "FAU" 
56e9					CALLMONITOR 
56e9				endif 
56e9 cd d0 0b			call cmp16 
56ec ca f5 56			jp z, .chk_fault2 
56ef 11 8d 57			ld de, sfaultru 
56f2 c3 31 57			jp .chk_fault 
56f5			.chk_fault2:  
56f5 2a c9 ea			ld hl, (chk_ret_ovr) 
56f8 ed 5b 47 e3		ld de,(chk_word) 
56fc				if DEBUG_STK_FAULT 
56fc					DMARK "FA1" 
56fc					CALLMONITOR 
56fc				endif 
56fc cd d0 0b			call cmp16 
56ff ca 08 57			jp z, .chk_fault3 
5702 11 9b 57			ld de, sfaultro 
5705 c3 31 57			jp .chk_fault 
5708			.chk_fault3:  
5708 2a c7 e9			ld hl, (chk_loop_ovr) 
570b ed 5b 47 e3		ld de,(chk_word) 
570f				if DEBUG_STK_FAULT 
570f					DMARK "FA2" 
570f					CALLMONITOR 
570f				endif 
570f cd d0 0b			call cmp16 
5712 ca 1b 57			jp z, .chk_fault4 
5715 11 b5 57			ld de, sfaultlo 
5718 c3 31 57			jp .chk_fault 
571b			.chk_fault4:  
571b 2a c5 e8			ld hl, (chk_data_ovr) 
571e ed 5b 47 e3		ld de,(chk_word) 
5722				if DEBUG_STK_FAULT 
5722					DMARK "FA3" 
5722					CALLMONITOR 
5722				endif 
5722 cd d0 0b			call cmp16 
5725 ca 2e 57			jp z, .chk_fault5 
5728 11 cf 57			ld de, sfaultdo 
572b c3 31 57			jp .chk_fault 
572e			 
572e			 
572e			.chk_fault5:  
572e d1				pop de 
572f e1				pop hl 
5730			 
5730 c9				ret 
5731			 
5731 cd 85 09		.chk_fault: 	call clear_display 
5734 3e 28				ld a, display_row_2 
5736 cd 98 09				call str_at_display 
5739 11 5f 57				   ld de, .stackfault 
573c 3e 00				ld a, display_row_1 
573e cd 98 09				call str_at_display 
5741 11 7a ee				    ld de, debug_mark 
5744 3e 11				ld a, display_row_1+17 
5746 cd 98 09				call str_at_display 
5749 cd a8 09				call update_display 
574c			 
574c				; prompt before entering montior for investigating issue 
574c			 
574c 3e 78			ld a, display_row_4 
574e 11 a6 16			ld de, endprog 
5751			 
5751 cd a8 09			call update_display		 
5754			 
5754 cd 04 19			call next_page_prompt 
5757			 
5757 d1				pop de 
5758 e1				pop hl 
5759 cd fa 16				call monitor 
575c c3 f4 15				jp warmstart 
575f					;jp 0 
575f					;halt 
575f			 
575f			 
575f			 
575f .. 00		.stackfault: 	db "Stack fault:",0 
576c			 
576c .. 00		sfaultsu: 	db	"Stack under flow",0 
577d .. 00		sfaultso: 	db	"Stack over flow",0 
578d .. 00		sfaultru:	db "RTS underflow",0 
579b .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
57b5 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
57cf .. 00		sfaultdo:	db "DTS overflow", 0 
57dc			 
57dc			 
57dc			fault_dsp_under: 
57dc 11 ee 57			ld de, .dsp_under 
57df c3 9e 58			jp .show_fault 
57e2			 
57e2			fault_rsp_under: 
57e2 11 fc 57			ld de, .rsp_under 
57e5 c3 9e 58			jp .show_fault 
57e8			fault_loop_under: 
57e8 11 0a 58			ld de, .loop_under 
57eb c3 9e 58			jp .show_fault 
57ee			 
57ee .. 00		.dsp_under: db "DSP Underflow",0 
57fc .. 00		.rsp_under: db "RSP Underflow",0 
580a .. 00		.loop_under: db "LOOP Underflow",0 
5819			 
5819			 
5819 d5			type_faultn: 	push de 
581a e5					push hl 
581b cd 85 09				call clear_display 
581e 11 45 58				   ld de, .typefaultn 
5821 3e 00				ld a, display_row_1 
5823 cd 98 09				call str_at_display 
5826 11 7a ee				    ld de, debug_mark 
5829 3e 11				ld a, display_row_1+17 
582b cd 98 09				call str_at_display 
582e cd a8 09				call update_display 
5831			 
5831				; prompt before entering montior for investigating issue 
5831			 
5831 3e 78			ld a, display_row_4 
5833 11 a6 16			ld de, endprog 
5836			 
5836 cd a8 09			call update_display		 
5839			 
5839 cd 04 19			call next_page_prompt 
583c			 
583c e5					push hl 
583d d5					push de 
583e cd fa 16				call monitor 
5841 c3 f4 15				jp warmstart 
5844 76					halt 
5845			 
5845			 
5845 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
585c			 
585c d5			type_faults: 	push de 
585d e5					push hl 
585e cd 85 09				call clear_display 
5861 11 87 58				   ld de, .typefaults 
5864 3e 00				ld a, display_row_1 
5866 cd 98 09				call str_at_display 
5869 11 7a ee				    ld de, debug_mark 
586c 3e 11				ld a, display_row_1+17 
586e cd 98 09				call str_at_display 
5871 cd a8 09				call update_display 
5874			 
5874				; prompt before entering montior for investigating issue 
5874			 
5874 3e 78			ld a, display_row_4 
5876 11 a6 16			ld de, endprog 
5879			 
5879 cd a8 09			call update_display		 
587c			 
587c cd 04 19			call next_page_prompt 
587f			 
587f e1					pop hl 
5880 d1					pop de 
5881 cd fa 16				call monitor 
5884 c3 f4 15				jp warmstart 
5887			 
5887			 
5887 .. 00		.typefaults: db "STR Type Expected TOS!",0 
589e			 
589e			.show_fault: 	 
589e d5					push de 
589f cd 85 09				call clear_display 
58a2 d1					pop de 
58a3 3e 00				ld a, display_row_1 
58a5 cd 98 09				call str_at_display 
58a8 11 7a ee				    ld de, debug_mark 
58ab 3e 11				ld a, display_row_1+17 
58ad cd 98 09				call str_at_display 
58b0 cd a8 09				call update_display 
58b3			 
58b3				; prompt before entering montior for investigating issue 
58b3			 
58b3 3e 78			ld a, display_row_4 
58b5 11 a6 16			ld de, endprog 
58b8			 
58b8 cd a8 09			call update_display		 
58bb			 
58bb cd 04 19			call next_page_prompt 
58be			 
58be e1					pop hl 
58bf d1					pop de 
58c0 cd fa 16				call monitor 
58c3			; do a dump to cli and not warmstart so we preserve all of the uwords.  
58c3			; TODO Make optional fault restart to cli or warm boot? 
58c3					;jp warmstart 
58c3 c3 4c 16				jp cli 
58c6 76					halt 
58c7			; eof 
# End of file forth_kernel.asm
58c7			;include "nascombasic.asm" 
58c7			 
58c7			 
58c7			; find out where the code ends if loaded into RAM (for SC114) 
58c7			;endofcode:  
58c7			;	nop 
58c7			 
58c7			 
58c7			; eof 
58c7			 
# End of file main.asm
58c7			;include "firmware_lcd_4x40.asm" 
58c7			;;include "firmware_lcd_4x20.asm" 
58c7			include "firmware_cpm_display.asm" 
58c7			 
58c7			; Serial display interface for SC114 
58c7			 
58c7			 
58c7			display_row_1: equ 0 
58c7			display_row_2: equ display_row_1+display_cols 
58c7			display_row_3: equ display_row_2 + display_cols 
58c7			display_row_4: equ display_row_3 + display_cols 
58c7			 
58c7			kLCDWidth:  EQU display_cols             ;Width in characters 
58c7			kLCD_Line1: EQU 0x00  
58c7			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
58c7			; E1 
58c7			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
58c7			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
58c7			 
58c7			lcd_init: 
58c7				; no init as handled by the SCM bios 
58c7 c9				ret 
58c8			 
58c8			 
58c8			; low level functions for direct screen writes 
58c8			 
58c8			; output char at pos? 
58c8			fLCD_Str: 
58c8			        ;out (SC114_SIO_1_OUT),a 
58c8 c5				push bc 
58c9 d5				push de 
58ca 5f				ld e, a 
58cb			; TODO Replace with CP/M BIOS call 
58cb 0e 02			ld c, $02 
58cd cd 05 00			call 5 
58d0 d1				pop de 
58d1 c1				pop bc 
58d2 c9				ret 
58d3			 
58d3			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
58d3			fLCD_Pos: 
58d3				; use ASCII escape to position 
58d3			        ;out (SC114_SIO_1_OUT),a 
58d3 c5				push bc 
58d4 d5				push de 
58d5 5f				ld e, a 
58d6 0e 02			ld c, $02 
58d8			; TODO Replace with CP/M BIOS call 
58d8 cd 05 00			call 5 
58db d1				pop de 
58dc c1				pop bc 
58dd			 
58dd c9				ret 
58de			 
58de			; output char at pos 
58de			fLCD_Data: 
58de			      ;  out (SC114_SIO_1_OUT),a 
58de c5				push bc 
58df d5				push de 
58e0 0e 02			ld c, $02 
58e2 5f				ld e, a 
58e3			; TODO Replace with CP/M BIOS call 
58e3 cd 05 00			call 5 
58e6 d1				pop de 
58e7 c1				pop bc 
58e8			 
58e8 c9				ret 
58e9			 
58e9			; ascii cls  
58e9			 
58e9 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
58ed			 
58ed 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5904			;.clscpm: db 3, $3c,"$" 
5904			 
5904			; write the frame buffer given in hl to hardware  
5904			write_display: 
5904			 
5904			API: equ 0 
5904			 
5904			if API 
5904				push bc 
5904				ld b, 4 
5904			 
5904			        ld (display_write_tmp), hl 	  
5904			 
5904				; clear and home cursor 
5904			 
5904				ld c, 9 
5904				ld de, .cls 
5904			; TODO Replace with CP/M BIOS call 
5904				call 5 
5904			 
5904			 
5904			.writeln: 
5904			 
5904				ld de, (display_write_tmp) 
5904				ld c, 6 
5904			; TODO Replace with CP/M BIOS call 
5904				rst $30 
5904				ld c, 7 
5904				rst $30 
5904			 
5904				ld hl, (display_write_tmp) 
5904				ld de, display_cols 
5904				add hl,de 
5904				ld (display_write_tmp),hl 
5904			 
5904				djnz  .writeln 
5904			 
5904				pop bc 
5904			 
5904			 
5904				ret 
5904			endif 
5904 e5				push hl 
5905 c5				push bc 
5906 d5				push de 
5907			 
5907			;	ld c, 2 
5907			;	;ld de, .cls 
5907			;	ld a, 27 
5907			;	rst $30 
5907			;	ld c, 2 
5907			;	;ld de, .cls 
5907			;	ld a, '[' 
5907			;	rst $30 
5907			; 
5907			;	ld c, 2 
5907			;	;ld de, .cls 
5907			;	ld a, 'H' 
5907			;	rst $30 
5907			; 
5907			 
5907			 
5907			; lots of CR/LF 
5907			;	ld c, 9 
5907			;	ld de, .clscpm 
5907			;	call 5 
5907			 
5907			; xterm cls 
5907 0e 02			ld c, 2 
5909 1e 1b			ld e, 27 
590b cd 05 00			call 5 
590e			; cls causes too much flicker 
590e			;	ld c, 2 
590e			;	ld e, 'c' 
590e			;	call 5 
590e			 
590e			; use xterm home instead 
590e 0e 02			ld c, 2 
5910 1e 5b			ld e, '[' 
5912 cd 05 00			call 5 
5915 0e 02			ld c, 2 
5917 1e 48			ld e, 'H' 
5919 cd 05 00			call 5 
591c			LLL: equ 0 
591c			 
591c			if LLL 
591c			 
591c				ld c, 2 
591c				;ld de, .cls 
591c				ld e, 27 
591c			; TODO Replace with CP/M BIOS call 
591c				call 5 
591c			 
591c			 
591c				ld c, 2 
591c				;ld de, .cls 
591c				ld e, '[' 
591c			; TODO Replace with CP/M BIOS call 
591c				call 5 
591c				ld c, 2 
591c				;ld de, .cls 
591c				ld e, '2' 
591c			; TODO Replace with CP/M BIOS call 
591c				call 5 
591c				ld c, 2 
591c				;ld de, .cls 
591c				ld e, 'J' 
591c			; TODO Replace with CP/M BIOS call 
591c				call 5 
591c			 
591c			endif 
591c			 
591c d1				pop de 
591d c1				pop bc 
591e e1				pop hl 
591f			 
591f			 
591f 22 d8 eb		        ld (display_write_tmp), hl 	  
5922 3e 00			ld a, kLCD_Line1 
5924			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5924 06 28			ld b, display_cols 
5926 ed 5b d8 eb		ld de, (display_write_tmp) 
592a cd ad 59			call write_len_string 
592d				 
592d			 
592d e5			push hl 
592e d5			push de 
592f c5			push bc 
5930 0e 02			ld c, 2 
5932 1e 0a			ld e, 10 
5934 cd 05 00			call 5 
5937 0e 02			ld c, 2 
5939 1e 0d			ld e, 13 
593b cd 05 00			call 5 
593e			; TODO Replace with CP/M BIOS call 
593e				;rst $30 
593e c1			pop bc 
593f d1			pop de 
5940 e1			pop hl 
5941			 
5941				 
5941 2a d8 eb			ld hl, (display_write_tmp) 
5944 11 28 00			ld de, display_cols 
5947 19				add hl,de 
5948 22 d8 eb			ld (display_write_tmp),hl 
594b			 
594b				 
594b 3e 28			ld a, kLCD_Line2 
594d			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
594d 06 28			ld b, display_cols 
594f ed 5b d8 eb		ld de, (display_write_tmp) 
5953 cd ad 59			call write_len_string 
5956				 
5956 2a d8 eb			ld hl, (display_write_tmp) 
5959 11 28 00			ld de, display_cols 
595c 19				add hl,de 
595d 22 d8 eb			ld (display_write_tmp),hl 
5960			 
5960 e5			push hl 
5961 d5			push de 
5962 c5			push bc 
5963 0e 07			ld c, 7 
5965			; TODO Replace with CP/M BIOS call 
5965				;rst $30 
5965 0e 02			ld c, 2 
5967 1e 0a			ld e, 10 
5969 cd 05 00			call 5 
596c 0e 02			ld c, 2 
596e 1e 0d			ld e, 13 
5970 cd 05 00			call 5 
5973 c1			pop bc 
5974 d1			pop de 
5975 e1			pop hl 
5976			 
5976				 
5976 3e 50			ld a, kLCD_Line3 
5978			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5978 06 28			ld b, display_cols 
597a ed 5b d8 eb		ld de, (display_write_tmp) 
597e cd ad 59			call write_len_string 
5981				 
5981 2a d8 eb			ld hl, (display_write_tmp) 
5984 11 28 00			ld de, display_cols 
5987 19				add hl,de 
5988 22 d8 eb			ld (display_write_tmp),hl 
598b			 
598b e5			push hl 
598c d5			push de 
598d c5			push bc 
598e 0e 07			ld c, 7 
5990			; TODO Replace with CP/M BIOS call 
5990				;rst $30 
5990 0e 02			ld c, 2 
5992 1e 0a			ld e, 10 
5994 cd 05 00			call 5 
5997 0e 02			ld c, 2 
5999 1e 0d			ld e, 13 
599b cd 05 00			call 5 
599e c1			pop bc 
599f d1			pop de 
59a0 e1			pop hl 
59a1			 
59a1				 
59a1 3e 78			ld a, kLCD_Line4 
59a3			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
59a3 06 28			ld b, display_cols 
59a5 ed 5b d8 eb		ld de, (display_write_tmp) 
59a9 cd ad 59			call write_len_string 
59ac c9					ret 
59ad			 
59ad			 
59ad				; write out a fixed length string given in b from de 
59ad			 
59ad 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
59ae cd de 58		            CALL fLCD_Data      ;Write character to display 
59b1 13				inc de 
59b2 10 f9			djnz write_len_string 
59b4 c9				ret 
59b5			 
59b5			 
59b5			; eof 
# End of file firmware_cpm_display.asm
59b5			;include "firmware_key_5x10.asm" 
59b5			;;include "firmware_key_4x10.asm" 
59b5			include "firmware_key_cpm.asm" 
59b5			; Serial keyboard interface for SC114 
59b5			 
59b5			 
59b5			key_init: 
59b5				; no init as handled by the SCM bios 
59b5 c9				ret 
59b6			 
59b6			 
59b6			cin_wait: 
59b6			;	ld a, 0 
59b6			;	ret 
59b6			 
59b6				;in a,(SC114_SIO_1_IN) 
59b6			        ; Use SCM API to get from whatever console device we are using 
59b6			 
59b6			; TODO Replace with CP/M BIOS call 
59b6 c5				push bc 
59b7 0e 01			ld c, $01 
59b9 cd 05 00			call 5 
59bc c1				pop bc 
59bd c9				ret 
59be			 
59be			cin: 
59be			 
59be			 
59be c5				push bc 
59bf			 
59bf				; any key waiting to process? 
59bf			; TODO Replace with CP/M BIOS call 
59bf 0e 06			ld c, $06 
59c1 cd 05 00			call 5 
59c4 28 0d			jr z, .cin_skip 
59c6			 
59c6				; yep, get it 
59c6			 
59c6 0e 01			ld c, $01 
59c8			; TODO Replace with CP/M BIOS call 
59c8 cd 05 00			call 5 
59cb			 
59cb fe 7f			cp $7f     ; back space 
59cd 20 02			jr nz, .skipbs 
59cf 3e 08			ld a, KEY_BS 
59d1			.skipbs: 
59d1			 
59d1 c1				pop bc 
59d2 c9				ret 
59d3			.cin_skip: 
59d3 3e 00			ld a, 0 
59d5 c1				pop bc 
59d6 c9				ret 
59d7			 
59d7			 
59d7			 
59d7			 
# End of file firmware_key_cpm.asm
59d7			endofcode:  
59d7			baseram:  
59d7 00				nop 
59d8			 
59d8			heap_start: equ baseram+15  ; Starting address of heap 
59d8			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
59d8			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
59d8			;VDU:  EQU     endofcode           ; BASIC Work space 
59d8			; eof 
59d8			 
# End of file os_mega_cpm.asm
59d8
