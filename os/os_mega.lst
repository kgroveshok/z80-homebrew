# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 5d 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-09-10 20:01' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 c9 76			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
006c			  
006c			debug_umark: equ parse_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 42 fc				ld hl, display_fb1  
006f 22 fe fa				ld (display_fb_active), hl  
0072			  
0072 cd 7c 0d				call clear_display  
0075			  
0075 21 00 fb				ld hl, display_fb2  
0078 22 fe fa				ld (display_fb_active), hl  
007b			  
007b cd 7c 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 e3 fc				ld hl, display_fb0  
0081 22 fe fa				ld (display_fb_active), hl  
0084			  
0084 cd 7c 0d				call clear_display  
0087			  
0087			  
0087 cd d6 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd 6d 79			call key_init  
008d cd 42 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 54 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd 9e 0d			call update_display  
0096 cd c0 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd 81 0d			call fill_display  
009e cd 9e 0d			call update_display  
00a1 cd c0 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd 81 0d			call fill_display  
00a9 cd 9e 0d			call update_display  
00ac cd c0 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd 81 0d			call fill_display  
00b4 cd 9e 0d			call update_display  
00b7 cd c0 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 5c 1a			ld de, prom_bootmsg  
00bf cd 8e 0d			call str_at_display  
00c2 cd 9e 0d			call update_display  
00c5			  
00c5			  
00c5 cd c0 0c			call delay1s  
00c8 cd c0 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 71 1a			ld de, prom_bootmsg1  
00d0 cd 8e 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd 8e 0d			call str_at_display  
00db			  
00db cd 9e 0d			call update_display  
00de cd c0 0c			call delay1s  
00e1 cd c0 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 9d fd		ld (debug_mark),a  
00e9 32 9e fd		ld (debug_mark+1),a  
00ec 32 9f fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a0 fd		ld (debug_mark+3),a  
00f4 32 a1 fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 96 f9			ld a, (spi_clktime) 
00fc			;	cp 0 
00fc b7				or a 
00fd 28 03			jr z, .scskip 
00ff cd a5 0c			call aDelayInMS 
0102			.scskip: 
0102 f1				pop af 
0103 c9				ret 
0104			 
0104			 
0104			 
0104			; TODO store port id for spi device ie dev c 
0104			; TODO store pin for SO 
0104			; TODO store pin for SI 
0104			; TODO store pin for SCLK 
0104			 
0104			; 
0104			 
0104			; ensure that spi bus is in a stable state with default pins  
0104			 
0104			se_stable_spi:   
0104			 
0104				 ; set DI high, CE high , SCLK low 
0104				;ld a, SPI_DI | SPI_CE0 
0104 3e 07			ld a, SPI_DI  
0106 cd fd 01			call spi_ce_high 
0109 d3 80			 out (storage_adata),a 
010b 32 93 f9			ld (spi_portbyte),a 
010e			 
010e				if DEBUG_SPI 
010e					push hl 
010e					ld l, a 
010e					DMARK "SPI" 
010e					CALLMONITOR 
010e					pop hl 
010e				endif 
010e c9				ret 
010f			 
010f			; byte to send in a 
010f			 
010f			spi_send_byte: 
010f				; save byte to send for bit mask shift out 
010f 4f			        ld c,a 
0110 3a 93 f9			ld a,(spi_portbyte) 
0113				  
0113				; clock out	each bit of the byte msb first 
0113			 
0113 06 08			ld b, 8 
0115			.ssb1: 
0115				; clear so bit  
0115 cb bf			res SPI_DI, a 
0117 cb 11			rl c 
0119				; if bit 7 is set then carry is set 
0119 30 02			jr nc, .ssb2 
011b cb ff			set SPI_DI,a 
011d			.ssb2:  ; output bit to ensure it is stable 
011d d3 80			out (storage_adata),a 
011f			;	nop 
011f				; clock bit high 
011f cb ef			set SPI_SCLK,a 
0121 d3 80			out (storage_adata),a 
0123			;	nop 
0123 cd f8 00			call spi_clk 
0126				; then low 
0126 cb af			res SPI_SCLK,a 
0128 d3 80			out (storage_adata),a 
012a			;	nop 
012a cd f8 00			call spi_clk 
012d 10 e6			djnz .ssb1 
012f			 
012f 32 93 f9			ld (spi_portbyte),a 
0132 c9				ret 
0133			 
0133			; TODO low level get byte into A on spi 
0133			 
0133			spi_read_byte:  
0133			 
0133				; save byte to send for bit mask shift out 
0133 0e 00		    ld c,0 
0135 3a 93 f9			ld a,(spi_portbyte) 
0138				  
0138				; clock out	each bit of the byte msb first 
0138			 
0138			 
0138				; clock bit high 
0138 cb ef			set SPI_SCLK,a 
013a d3 80			out (storage_adata),a 
013c			;	nop 
013c cd f8 00			call spi_clk 
013f			 
013f			    ; read DO  
013f			 
013f cb f9		    set 7,c 
0141 db 80			in a,(storage_adata) 
0143 cb 77		    bit SPI_DO,a 
0145 20 02		    jr nz, .b7 
0147 cb b9		    res 7,c 
0149			.b7: 
0149				; then low 
0149 cb af			res SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d			;	nop 
014d cd f8 00			call spi_clk 
0150			     
0150			 
0150				; clock bit high 
0150 cb ef			set SPI_SCLK,a 
0152 d3 80			out (storage_adata),a 
0154			;	nop 
0154 cd f8 00			call spi_clk 
0157			 
0157			    ; read DO  
0157			 
0157 cb f1		    set 6,c 
0159 db 80			in a,(storage_adata) 
015b cb 77		    bit SPI_DO,a 
015d 20 02		    jr nz, .b6 
015f cb b1		    res 6,c 
0161			.b6: 
0161				; then low 
0161 cb af			res SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165			;	nop 
0165 cd f8 00			call spi_clk 
0168			 
0168				; clock bit high 
0168 cb ef			set SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c			;	nop 
016c cd f8 00			call spi_clk 
016f			 
016f			 
016f			    ; read DO  
016f			 
016f cb e9		    set 5,c 
0171 db 80			in a,(storage_adata) 
0173 cb 77		    bit SPI_DO,a 
0175 20 02		    jr nz, .b5 
0177 cb a9		    res 5,c 
0179			.b5: 
0179				; then low 
0179 cb af			res SPI_SCLK,a 
017b d3 80			out (storage_adata),a 
017d			;	nop 
017d cd f8 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184			;	nop 
0184 cd f8 00			call spi_clk 
0187			 
0187			    ; read DO  
0187			 
0187 cb e1		    set 4,c 
0189 db 80			in a,(storage_adata) 
018b cb 77		    bit SPI_DO,a 
018d 20 02		    jr nz, .b4 
018f cb a1		    res 4,c 
0191			.b4: 
0191				; then low 
0191 cb af			res SPI_SCLK,a 
0193 d3 80			out (storage_adata),a 
0195			;	nop 
0195 cd f8 00			call spi_clk 
0198				; clock bit high 
0198 cb ef			set SPI_SCLK,a 
019a d3 80			out (storage_adata),a 
019c			;	nop 
019c cd f8 00			call spi_clk 
019f			 
019f			    ; read DO  
019f			 
019f cb d9		    set 3,c 
01a1 db 80			in a,(storage_adata) 
01a3 cb 77		    bit SPI_DO,a 
01a5 20 02		    jr nz, .b3 
01a7 cb 99		    res 3,c 
01a9			.b3: 
01a9				; then low 
01a9 cb af			res SPI_SCLK,a 
01ab d3 80			out (storage_adata),a 
01ad			;	nop 
01ad cd f8 00			call spi_clk 
01b0				; clock bit high 
01b0 cb ef			set SPI_SCLK,a 
01b2 d3 80			out (storage_adata),a 
01b4			;	nop 
01b4 cd f8 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5			;	nop 
01c5 cd f8 00			call spi_clk 
01c8				; clock bit high 
01c8 cb ef			set SPI_SCLK,a 
01ca d3 80			out (storage_adata),a 
01cc			;	nop 
01cc cd f8 00			call spi_clk 
01cf			 
01cf			    ; read DO  
01cf			 
01cf cb c9		    set 1,c 
01d1 db 80			in a,(storage_adata) 
01d3 cb 77		    bit SPI_DO,a 
01d5 20 02		    jr nz, .b1 
01d7 cb 89		    res 1,c 
01d9			.b1: 
01d9				; then low 
01d9 cb af			res SPI_SCLK,a 
01db d3 80			out (storage_adata),a 
01dd			;	nop 
01dd cd f8 00			call spi_clk 
01e0				; clock bit high 
01e0 cb ef			set SPI_SCLK,a 
01e2 d3 80			out (storage_adata),a 
01e4			;	nop 
01e4 cd f8 00			call spi_clk 
01e7			 
01e7			    ; read DO  
01e7			 
01e7 cb c1		    set 0,c 
01e9 db 80			in a,(storage_adata) 
01eb cb 77		    bit SPI_DO,a 
01ed 20 02		    jr nz, .b0 
01ef cb 81		    res 0,c 
01f1			.b0: 
01f1				; then low 
01f1 cb af			res SPI_SCLK,a 
01f3 d3 80			out (storage_adata),a 
01f5			;	nop 
01f5 cd f8 00			call spi_clk 
01f8			 
01f8			 
01f8 32 93 f9			ld (spi_portbyte),a 
01fb			 
01fb			    ; return byte 
01fb 79			    ld a,c 
01fc			 
01fc			 
01fc c9				ret 
01fd			 
01fd			 
01fd			 
01fd			spi_ce_high: 
01fd			 
01fd				if DEBUG_SPI_HARD_CE0 
01fd			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fd					ret 
01fd			 
01fd				endif 
01fd			 
01fd			 
01fd f5				push af 
01fe			 
01fe				; send direct ce to port b 
01fe 3e ff			ld a, 255 
0200 d3 81			out (storage_bdata), a 
0202			 
0202 f1				pop af 
0203			 
0203				; for port a that shares with spi lines AND the mask 
0203			  
0203				if DEBUG_SPI 
0203					push hl 
0203					ld h, a 
0203				endif 
0203			;	ld c, SPI_CE_HIGH 
0203			;	and c 
0203 cb c7			set SPI_CE0, a 
0205 cb cf			set SPI_CE1, a 
0207 cb d7			set SPI_CE2, a 
0209 cb df			set SPI_CE3, a 
020b cb e7			set SPI_CE4, a 
020d			 
020d				if DEBUG_SPI 
020d					ld l, a 
020d					DMARK "CEh" 
020d					CALLMONITOR 
020d					pop hl 
020d				endif 
020d c9				ret 
020e			 
020e			 
020e			spi_ce_low: 
020e			 
020e				if DEBUG_SPI_HARD_CE0 
020e			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e					ret 
020e			 
020e				endif 
020e			 
020e c5				push bc 
020f f5				push af 
0210			 
0210				; send direct ce to port b 
0210 3a 95 f9			ld a, (spi_cartdev) 
0213 d3 81			out (storage_bdata), a 
0215			 
0215			 
0215			 
0215				; for port a that shares with spi lines AND the mask 
0215			 
0215 3a 92 f9			ld a, (spi_device)  
0218 4f				ld c, a 
0219			 
0219 f1				pop af 
021a			 
021a				; detect CEx 
021a			 
021a				if DEBUG_SPI 
021a					push hl 
021a					ld h, a 
021a				endif 
021a			 
021a cb 41			bit SPI_CE0, c 
021c 20 04			jr nz, .cel1 
021e cb 87			res SPI_CE0, a 
0220 18 1e			jr .celn 
0222			.cel1: 
0222 cb 49			bit SPI_CE1, c 
0224 20 04			jr nz, .cel2 
0226 cb 8f			res SPI_CE1, a 
0228 18 16			jr .celn 
022a			.cel2: 
022a cb 51			bit SPI_CE2, c 
022c 20 04			jr nz, .cel3 
022e cb 97			res SPI_CE2, a 
0230 18 0e			jr .celn 
0232			.cel3: 
0232 cb 59			bit SPI_CE3, c 
0234 20 04			jr nz, .cel4 
0236 cb 9f			res SPI_CE3, a 
0238 18 06			jr .celn 
023a			.cel4: 
023a cb 61			bit SPI_CE4, c 
023c 20 02			jr nz, .celn 
023e cb a7			res SPI_CE4, a 
0240			.celn: 
0240			 
0240			 
0240			 
0240			;	add c 
0240			 
0240				if DEBUG_SPI 
0240					ld l, a 
0240					DMARK "CEl" 
0240					CALLMONITOR 
0240					pop hl 
0240				endif 
0240 c1				pop bc 
0241 c9				ret 
0242			 
0242			 
0242			 
0242			; eof 
0242			 
0242			 
0242			 
0242			 
0242			 
# End of file firmware_spi.asm
0242				include "firmware_seeprom.asm"  
0242			; 
0242			; persisent storage interface via microchip serial eeprom 
0242			 
0242			; port a pio 2 
0242			; pa 7 - si 
0242			; pa 6 - sclk  
0242			; pa 5 - so 
0242			; pa 4 - cs 
0242			; pa 3 - cs 
0242			; pa 2 - cs 
0242			; pa 1 - cs 
0242			; pa 0 - cs 
0242			; 
0242			; TODO get block 
0242			; TODO save block 
0242			; TODO load file 
0242			; TODO save file 
0242			; TODO get dir  
0242			 
0242			;  
0242			storage_adata: equ Device_C    ; device c port a - onboard storage 
0242			storage_actl: equ Device_C+2     ; device c port a 
0242			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0242			storage_bctl: equ Device_C+3     ; device c port b 
0242			 
0242			 
0242			; TODO move these to hardware driver file 
0242			 
0242			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0242			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0242			; storage bank file system format 
0242			; 
0242			; first page of bank: 
0242			; 	addr 0 - status check 
0242			;       addr 1 - write protect flag 
0242			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0242			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0242			;         TODO see if scanning whole of for available next file id is fast enough 
0242			;	addr 4 > zero term string of bank label 
0242			; 
0242			;        
0242			;  
0242			; first page of any file: 
0242			;      byte 0 - file id  
0242			;      byte 1-17 - fixed file name  
0242			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0242			; 
0242			; other pages of any file: 
0242			;      byte 0 - file id 
0242			;      byte 1> - file data 
0242			; 
0242			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0242			;  
0242			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0242			 
0242			 
0242			;storage_so_bit: 5 
0242			;storage_si_bit: 7 
0242			;storage_sclk_bit: 6 
0242			  
0242			 
0242			; init storage pio 
0242			 
0242			storage_init: 
0242			 
0242			 
0242					; set default SPI clk pulse time as disabled 
0242			 
0242 3e 00				ld a, 0 
0244 32 96 f9				ld (spi_clktime), a 
0247			 
0247					; init hardware 
0247			 
0247 3e cf		            LD   A, 11001111b 
0249 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
024b 3e 00		            LD   A, 00000000b 
024d cb f7			set SPI_DO,a 
024f			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
024f d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0251			 
0251 3e cf		            LD   A, 11001111b 
0253 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0255 3e 00		            LD   A, 00000000b 
0257 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0259			 
0259				; set all external spi devices off  
0259 3e ff			ld a, 255 
025b 32 92 f9			ld (spi_device), a 
025e 32 95 f9			ld (spi_cartdev), a 
0261			 
0261					; ensure the spi bus is in a default stable state 
0261 cd 04 01				call se_stable_spi 
0264			 
0264			; TODO scan spi bus and gather which storage banks are present 
0264			 
0264			; populate store_bank_active  
0264			; for each ce line activate and attempt to write first byte of bank and read back 
0264			; if zero is returned then bank is empty 
0264			;   
0264			; 
0264			 
0264					; init file extent cache to save on slow reads 
0264			 
0264			;	ld hl, store_filecache 
0264			;	ld de, 0 
0264			;	ld hl,(de)	 
0264			 
0264			 
0264 c9			    ret 
0265			 
0265			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0265			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0265			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0265			 
0265			; INSTRUCTION SET 
0265			; READ 0000 0011 Read data from memory array beginning at selected address 
0265			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0265			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0265			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0265			; RDSR 0000 0101 Read STATUS register 
0265			; WRSR 0000 0001 Write STATUS register 
0265			; PE 0100 0010 Page Erase – erase one page in memory array 
0265			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0265			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0265			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0265			 
0265			; TODO send byte steam for page without setting the address for every single byte 
0265			; TODO read byte  
0265			 
0265			; byte in a 
0265			; address in hl  
0265			se_writebyte: 
0265			        
0265			    ;   ld c, a 
0265 f5			        push af 
0266 e5			        push hl 
0267			 
0267			    ; initi write mode 
0267			    ; 
0267			    ;CS low 
0267			 
0267 3a 93 f9		       ld a,(spi_portbyte) 
026a cd 0e 02			call spi_ce_low 
026d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
026d d3 80		       out (storage_adata),a 
026f 32 93 f9		       ld (spi_portbyte), a 
0272			 
0272			    ;clock out wren instruction 
0272			 
0272 3e 06		    ld a, store_wren_ins 
0274 cd 0f 01		    call spi_send_byte  
0277			 
0277			    ;cs high to enable write latch 
0277			 
0277 3a 93 f9		       ld a,(spi_portbyte) 
027a cd fd 01			call spi_ce_high 
027d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
027d d3 80		       out (storage_adata),a 
027f 32 93 f9		       ld (spi_portbyte), a 
0282			 
0282			;	nop 
0282			    ; 
0282			    ; intial write data 
0282			    ; 
0282			    ; cs low 
0282			     
0282			;       ld a,(spi_portbyte) 
0282 cd 0e 02			call spi_ce_low 
0285			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 93 f9		       ld (spi_portbyte), a 
028a			 
028a			    ; clock out write instruction 
028a			     
028a 3e 02		    ld a, store_write_ins  
028c cd 0f 01		    call spi_send_byte  
028f			 
028f			    ; clock out address (depending on address size) 
028f			     
028f e1			    pop hl 
0290 7c			    ld a,h    ; address out msb first 
0291 cd 0f 01		    call spi_send_byte  
0294 7d			    ld a,l 
0295 cd 0f 01		    call spi_send_byte  
0298			 
0298			    ; clock out byte(s) for page 
0298			 
0298 f1			    pop af 
0299 cd 0f 01		    call spi_send_byte  
029c			 
029c			    ; end write with ce high 
029c 3a 93 f9		       ld a,(spi_portbyte) 
029f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029f cd fd 01			call spi_ce_high 
02a2 d3 80		       out (storage_adata),a 
02a4 32 93 f9		       ld (spi_portbyte), a 
02a7			 
02a7				; pause for internal write cycle 
02a7 3e 0a			ld a, 10 
02a9 cd a5 0c			call aDelayInMS 
02ac c9			    ret 
02ad			 
02ad			; buffer to write in de 
02ad			; address in hl  
02ad			se_writepage: 
02ad			        
02ad			    ;   ld c, a 
02ad d5				push de 
02ae e5			        push hl 
02af			 
02af			    ; initi write mode 
02af			    ; 
02af			    ;CS low 
02af			 
02af 3a 93 f9		       ld a,(spi_portbyte) 
02b2 cd 0e 02			call spi_ce_low 
02b5			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02b5 d3 80		       out (storage_adata),a 
02b7 32 93 f9		       ld (spi_portbyte), a 
02ba			 
02ba			    ;clock out wren instruction 
02ba			 
02ba 3e 06		    ld a, store_wren_ins 
02bc cd 0f 01		    call spi_send_byte  
02bf			 
02bf			    ;cs high to enable write latch 
02bf			 
02bf 3a 93 f9		       ld a,(spi_portbyte) 
02c2 cd fd 01			call spi_ce_high 
02c5			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02c5 d3 80		       out (storage_adata),a 
02c7 32 93 f9		       ld (spi_portbyte), a 
02ca			 
02ca			;	nop 
02ca			    ; 
02ca			    ; intial write data 
02ca			    ; 
02ca			    ; cs low 
02ca			     
02ca			;       ld a,(spi_portbyte) 
02ca			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ca cd 0e 02			call spi_ce_low 
02cd d3 80		       out (storage_adata),a 
02cf 32 93 f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ; clock out write instruction 
02d2			     
02d2 3e 02		    ld a, store_write_ins  
02d4 cd 0f 01		    call spi_send_byte  
02d7			 
02d7			    ; clock out address (depending on address size) 
02d7			     
02d7 e1			    pop hl 
02d8 7c			    ld a,h    ; address out msb first 
02d9 cd 0f 01		    call spi_send_byte  
02dc 7d			    ld a,l 
02dd cd 0f 01		    call spi_send_byte  
02e0			 
02e0			    ; clock out byte(s) for page 
02e0			 
02e0 e1				pop hl 
02e1 06 40			ld b, STORE_BLOCK_PHY 
02e3			.bytewrite: 
02e3			 
02e3 7e				ld a,(hl) 
02e4 e5			    push hl 
02e5 c5				push bc 
02e6 cd 0f 01		    call spi_send_byte  
02e9 c1				pop bc 
02ea e1				pop hl 
02eb			 
02eb			    ; end write with ce high 
02eb 3a 93 f9		       ld a,(spi_portbyte) 
02ee cd fd 01			call spi_ce_high 
02f1			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02f1 d3 80		       out (storage_adata),a 
02f3 32 93 f9		       ld (spi_portbyte), a 
02f6			 
02f6 23				inc hl 
02f7 10 ea			djnz .bytewrite 
02f9			 
02f9				; pause for internal write cycle 
02f9 3e 64			ld a, 100 
02fb cd a5 0c			call aDelayInMS 
02fe c9			    ret 
02ff			; returns byte in a 
02ff			; address in hl  
02ff			se_readbyte: 
02ff d5				push de 
0300 c5				push bc 
0301			 
0301			    ;   ld c, a 
0301 e5			        push hl 
0302			 
0302			    ; initi write mode 
0302			    ; 
0302			    ;CS low 
0302			 
0302 3a 93 f9		       ld a,(spi_portbyte) 
0305 cd 0e 02			call spi_ce_low 
0308			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0308 d3 80		       out (storage_adata),a 
030a 32 93 f9		       ld (spi_portbyte), a 
030d			 
030d			    ;clock out wren instruction 
030d			 
030d 3e 03		    ld a, store_read_ins 
030f cd 0f 01		    call spi_send_byte  
0312			 
0312			 
0312			    ; clock out address (depending on address size) 
0312			     
0312 e1			    pop hl 
0313 7c			    ld a,h    ; address out msb first 
0314 cd 0f 01		    call spi_send_byte  
0317 7d			    ld a,l 
0318 cd 0f 01		    call spi_send_byte  
031b			 
031b			    ; clock in byte(s) for page 
031b			 
031b cd 33 01		    call spi_read_byte  
031e f5				push af 
031f			 
031f			    ; end write with ce high 
031f 3a 93 f9		       ld a,(spi_portbyte) 
0322			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0322 cd fd 01			call spi_ce_high 
0325 d3 80		       out (storage_adata),a 
0327 32 93 f9		       ld (spi_portbyte), a 
032a			 
032a f1				pop af 
032b			 
032b c1				pop bc 
032c d1				pop de 
032d			 
032d c9			    ret 
032e			 
032e			if DEBUG_STORESE 
032e			 
032e			storageput:  
032e			 
032e			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
032e			 
032e 21 f5 f0			ld hl,scratch+2 
0331 cd 5e 12			call get_word_hl 
0334			 
0334				; stuff it here for the moment as it will be overwritten later anyway 
0334			 
0334 22 16 f4			ld (os_cur_ptr),hl	 
0337			 
0337			 
0337			; get pointer to start of string 
0337			 
0337 21 fa f0			ld hl, scratch+7 
033a			 
033a			; loop writing char of string to eeprom 
033a			 
033a 7e			.writestr:	ld a,(hl) 
033b			;		cp 0 
033b b7					or a 
033c 28 12				jr z, .wsdone		; done writing 
033e e5					push hl 
033f 2a 16 f4				ld hl,(os_cur_ptr) 
0342 cd 65 02				call se_writebyte 
0345			 
0345 2a 16 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0348 23					inc hl 
0349 22 16 f4				ld (os_cur_ptr),hl 
034c			 
034c					; restore string pointer and get next char 
034c			 
034c e1					pop hl 
034d 23					inc hl 
034e 18 ea				jr .writestr 
0350			 
0350			 
0350			 
0350			.wsdone: 
0350			 
0350			 
0350			; when done load first page into a buffer  
0350			 
0350 21 00 80				ld hl,08000h		; start in ram 
0353 22 16 f4				ld (os_cur_ptr),hl 
0356 21 00 00				ld hl, 0		 ; start of page 
0359 22 1b f1				ld (scratch+40),hl	; hang on to it 
035c			 
035c 06 80				ld b, 128		; actually get more then one page 
035e c5			.wsload:	push bc 
035f 2a 1b f1				ld hl,(scratch+40) 
0362 e5					push hl 
0363 cd ff 02				call se_readbyte 
0366			 
0366					; a now as the byte 
0366			 
0366 2a 16 f4				ld hl,(os_cur_ptr) 
0369 77					ld (hl),a 
036a					; inc next buffer area 
036a 23					inc hl 
036b 22 16 f4				ld (os_cur_ptr),hl 
036e			 
036e					; get eeprom position, inc and save for next round 
036e e1					pop hl		 
036f 23					inc hl 
0370 22 1b f1				ld (scratch+40),hl 
0373 c1					pop bc 
0374 10 e8				djnz .wsload 
0376			 
0376			; set 'd' pointer to start of buffer 
0376			 
0376 21 00 80				ld hl,08000h 
0379 22 16 f4				ld (os_cur_ptr),hl 
037c			 
037c			 
037c c9			ret 
037d			 
037d			 
037d c9			storageread: ret 
037e			 
037e			 
037e			 
037e			 
037e			 
037e			 
037e			endif 
037e			 
037e			 
037e			 
# End of file firmware_seeprom.asm
037e			else  
037e			   ; create some stubs for the labels  
037e			se_readbyte: ret  
037e			se_writebyte: ret  
037e			storage_init: ret  
037e			  
037e			endif  
037e			  
037e			; use cf card for storage - throwing timeout errors. Hardware or software?????  
037e			;include "firmware_cf.asm"  
037e			  
037e			; load up high level storage hardward abstractions  
037e			include "firmware_storage.asm"  
037e			 
037e			; persisent storage hardware abstraction layer  
037e			 
037e			 
037e			 
037e			; Block 0 on storage is a config state 
037e			 
037e			 
037e			 
037e			; TODO add read phy block and write phy block functions 
037e			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
037e			 
037e			; Abstraction layer  
037e			 
037e			; Logocial block size is same size as physical size - using tape concept 
037e			 
037e			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
037e			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
037e			 
037e			 
037e			 
037e			; Filesystem layout (Logical layout) 
037e			; 
037e			; Block 0 - Bank config  
037e			; 
037e			;      Byte - 0 file id counter 
037e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
037e			;      Byte - 3-20 zero terminated bank label 
037e			; 
037e			; Block 1 > File storage 
037e			; 
037e			;      Byte 0 file id    - block 0 file details 
037e			;      Byte 1 block id - block 0 is file  
037e			;            Byte 2-15 - File name 
037e			; 
037e			;       - to end of block data 
037e			; 
037e			 
037e			; Get ID for the file named in pointer held HL 
037e			; Returns ID in HL = 255 if no file found 
037e			 
037e			storage_getid: 
037e			 
037e 22 a5 f9			ld (store_tmp1), hl 
0381			 
0381				if DEBUG_STORESE 
0381					DMARK "SGI" 
0381 f5				push af  
0382 3a 96 03			ld a, (.dmark)  
0385 32 9d fd			ld (debug_mark),a  
0388 3a 97 03			ld a, (.dmark+1)  
038b 32 9e fd			ld (debug_mark+1),a  
038e 3a 98 03			ld a, (.dmark+2)  
0391 32 9f fd			ld (debug_mark+2),a  
0394 18 03			jr .pastdmark  
0396 ..			.dmark: db "SGI"  
0399 f1			.pastdmark: pop af  
039a			endm  
# End of macro DMARK
039a					CALLMONITOR 
039a cd aa fd			call debug_vector  
039d				endm  
# End of macro CALLMONITOR
039d				endif 
039d				; get block 0 and set counter for number of files to scan 
039d			 
039d cd 05 05			call storage_get_block_0 
03a0			 
03a0 3a ac f9			ld a, (store_page) 
03a3 47				ld b, a 
03a4			 
03a4				; get extent 0 of each file id 
03a4			 
03a4				if DEBUG_STORESE 
03a4					DMARK "SGc" 
03a4 f5				push af  
03a5 3a b9 03			ld a, (.dmark)  
03a8 32 9d fd			ld (debug_mark),a  
03ab 3a ba 03			ld a, (.dmark+1)  
03ae 32 9e fd			ld (debug_mark+1),a  
03b1 3a bb 03			ld a, (.dmark+2)  
03b4 32 9f fd			ld (debug_mark+2),a  
03b7 18 03			jr .pastdmark  
03b9 ..			.dmark: db "SGc"  
03bc f1			.pastdmark: pop af  
03bd			endm  
# End of macro DMARK
03bd					CALLMONITOR 
03bd cd aa fd			call debug_vector  
03c0				endm  
# End of macro CALLMONITOR
03c0				endif 
03c0 60			.getloop:	ld h, b 
03c1 2e 00				ld l, 0 
03c3 c5					push bc 
03c4			 
03c4 11 ac f9				ld de, store_page 
03c7				if DEBUG_STORESE 
03c7					DMARK "SGr" 
03c7 f5				push af  
03c8 3a dc 03			ld a, (.dmark)  
03cb 32 9d fd			ld (debug_mark),a  
03ce 3a dd 03			ld a, (.dmark+1)  
03d1 32 9e fd			ld (debug_mark+1),a  
03d4 3a de 03			ld a, (.dmark+2)  
03d7 32 9f fd			ld (debug_mark+2),a  
03da 18 03			jr .pastdmark  
03dc ..			.dmark: db "SGr"  
03df f1			.pastdmark: pop af  
03e0			endm  
# End of macro DMARK
03e0					CALLMONITOR 
03e0 cd aa fd			call debug_vector  
03e3				endm  
# End of macro CALLMONITOR
03e3				endif 
03e3 cd a7 09				call storage_read 
03e6 cd d5 0f				call ishlzero 
03e9 28 2d				jr z, .gap 
03eb					 
03eb					; have a file name read. Is it one we want. 
03eb			 
03eb 2a a5 f9				ld hl, (store_tmp1) 
03ee 11 af f9				ld de, store_page+3   ; file name 
03f1			 
03f1				if DEBUG_STORESE 
03f1					DMARK "SGc" 
03f1 f5				push af  
03f2 3a 06 04			ld a, (.dmark)  
03f5 32 9d fd			ld (debug_mark),a  
03f8 3a 07 04			ld a, (.dmark+1)  
03fb 32 9e fd			ld (debug_mark+1),a  
03fe 3a 08 04			ld a, (.dmark+2)  
0401 32 9f fd			ld (debug_mark+2),a  
0404 18 03			jr .pastdmark  
0406 ..			.dmark: db "SGc"  
0409 f1			.pastdmark: pop af  
040a			endm  
# End of macro DMARK
040a					CALLMONITOR 
040a cd aa fd			call debug_vector  
040d				endm  
# End of macro CALLMONITOR
040d				endif 
040d cd 3c 13				call strcmp 
0410 20 06				jr nz, .gap   ; not this one 
0412			 
0412 c1				        pop bc 
0413			 
0413 26 00				ld h, 0 
0415 68					ld l, b 
0416 18 22				jr .getdone 
0418						 
0418			 
0418			 
0418			 
0418			.gap: 
0418				if DEBUG_STORESE 
0418					DMARK "SGg" 
0418 f5				push af  
0419 3a 2d 04			ld a, (.dmark)  
041c 32 9d fd			ld (debug_mark),a  
041f 3a 2e 04			ld a, (.dmark+1)  
0422 32 9e fd			ld (debug_mark+1),a  
0425 3a 2f 04			ld a, (.dmark+2)  
0428 32 9f fd			ld (debug_mark+2),a  
042b 18 03			jr .pastdmark  
042d ..			.dmark: db "SGg"  
0430 f1			.pastdmark: pop af  
0431			endm  
# End of macro DMARK
0431					CALLMONITOR 
0431 cd aa fd			call debug_vector  
0434				endm  
# End of macro CALLMONITOR
0434				endif 
0434			 
0434 c1					pop bc 
0435 10 89				djnz .getloop 
0437 21 ff 00				ld hl, 255 
043a			.getdone: 
043a			 
043a				if DEBUG_STORESE 
043a					DMARK "SGe" 
043a f5				push af  
043b 3a 4f 04			ld a, (.dmark)  
043e 32 9d fd			ld (debug_mark),a  
0441 3a 50 04			ld a, (.dmark+1)  
0444 32 9e fd			ld (debug_mark+1),a  
0447 3a 51 04			ld a, (.dmark+2)  
044a 32 9f fd			ld (debug_mark+2),a  
044d 18 03			jr .pastdmark  
044f ..			.dmark: db "SGe"  
0452 f1			.pastdmark: pop af  
0453			endm  
# End of macro DMARK
0453					CALLMONITOR 
0453 cd aa fd			call debug_vector  
0456				endm  
# End of macro CALLMONITOR
0456				endif 
0456			 
0456 c9				ret 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			; Read Block 
0457			; ---------- 
0457			; 
0457			; With current bank 
0457			;  
0457			; Get block number to read 
0457			; Load physical blocks starting at start block into buffer 
0457			 
0457			; de points to buffer to use 
0457			; hl holds logical block number  
0457			 
0457			storage_read_block: 
0457			 
0457				; TODO bank selection 
0457			 
0457				; for each of the physical blocks read it into the buffer 
0457 06 40			ld b, STORE_BLOCK_PHY 
0459			 
0459				if DEBUG_STORESE 
0459 d5					push de 
045a				endif 
045a				 
045a			.rl1:    
045a			 
045a				; read physical block at hl into de 
045a			        ; increment hl and de to next read position on exit 
045a			 
045a e5				push hl 
045b d5				push de	 
045c c5				push bc 
045d			;	if DEBUG_STORESE 
045d			;		push af 
045d			;		ld a, 'R' 
045d			;		ld (debug_mark),a 
045d			;		pop af 
045d			;		CALLMONITOR 
045d			;	endif 
045d cd ff 02			call se_readbyte 
0460			;	if DEBUG_STORESE 
0460			;		ld a,(spi_portbyte) 
0460			;		ld l, a 
0460			;		push af 
0460			;		ld a, '1' 
0460			;		ld (debug_mark),a 
0460			;		pop af 
0460			;		CALLMONITOR 
0460			;	endif 
0460 c1				pop bc 
0461 d1				pop de 
0462 e1				pop hl 
0463 12				ld (de),a 
0464 23				inc hl 
0465 13				inc de 
0466			 
0466			;	if DEBUG_STORESE 
0466			;		push af 
0466			;		ld a, 'r' 
0466			;		ld (debug_mark),a 
0466			;		pop af 
0466			;		CALLMONITOR 
0466			;	endif 
0466			 
0466 10 f2			djnz .rl1 
0468			 
0468				if DEBUG_STORESE 
0468					DMARK "SRB" 
0468 f5				push af  
0469 3a 7d 04			ld a, (.dmark)  
046c 32 9d fd			ld (debug_mark),a  
046f 3a 7e 04			ld a, (.dmark+1)  
0472 32 9e fd			ld (debug_mark+1),a  
0475 3a 7f 04			ld a, (.dmark+2)  
0478 32 9f fd			ld (debug_mark+2),a  
047b 18 03			jr .pastdmark  
047d ..			.dmark: db "SRB"  
0480 f1			.pastdmark: pop af  
0481			endm  
# End of macro DMARK
0481 d1					pop de 
0482			; 
0482			;		push af 
0482			;		ld a, 'R' 
0482			;		ld (debug_mark),a 
0482			;		pop af 
0482					CALLMONITOR 
0482 cd aa fd			call debug_vector  
0485				endm  
# End of macro CALLMONITOR
0485				endif 
0485 c9				ret	 
0486				 
0486			 
0486			; File Size 
0486			; --------- 
0486			; 
0486			;   hl file id 
0486			; 
0486			;  returns in hl the number of blocks 
0486			 
0486			storage_file_size: 
0486 5d				ld e, l 
0487 16 00			ld d, 0 
0489 21 40 00			ld hl, STORE_BLOCK_PHY 
048c					if DEBUG_FORTH_WORDS 
048c						DMARK "SIZ" 
048c f5				push af  
048d 3a a1 04			ld a, (.dmark)  
0490 32 9d fd			ld (debug_mark),a  
0493 3a a2 04			ld a, (.dmark+1)  
0496 32 9e fd			ld (debug_mark+1),a  
0499 3a a3 04			ld a, (.dmark+2)  
049c 32 9f fd			ld (debug_mark+2),a  
049f 18 03			jr .pastdmark  
04a1 ..			.dmark: db "SIZ"  
04a4 f1			.pastdmark: pop af  
04a5			endm  
# End of macro DMARK
04a5						CALLMONITOR 
04a5 cd aa fd			call debug_vector  
04a8				endm  
# End of macro CALLMONITOR
04a8					endif 
04a8 cd 83 07			call storage_findnextid 
04ab			 
04ab cd d5 0f			call ishlzero 
04ae			;	ld a, l 
04ae			;	add h 
04ae			;	cp 0 
04ae c8				ret z			; block not found so EOF 
04af			 
04af 11 ac f9			ld de, store_page 
04b2 cd 57 04			call storage_read_block 
04b5			 
04b5 3a ae f9			ld a, (store_page+2)	 ; get extent count 
04b8 6f				ld l, a 
04b9 26 00			ld h, 0 
04bb c9			 	ret 
04bc			 
04bc			 
04bc			; Write Block 
04bc			; ----------- 
04bc			; 
04bc			; With current bank 
04bc			;  
04bc			; Get block number to write 
04bc			; Write physical blocks starting at start block from buffer 
04bc			  
04bc			storage_write_block: 
04bc				; TODO bank selection 
04bc			 
04bc				; for each of the physical blocks read it into the buffer 
04bc 06 40			ld b, STORE_BLOCK_PHY 
04be			 
04be				if DEBUG_STORESE 
04be					DMARK "SWB" 
04be f5				push af  
04bf 3a d3 04			ld a, (.dmark)  
04c2 32 9d fd			ld (debug_mark),a  
04c5 3a d4 04			ld a, (.dmark+1)  
04c8 32 9e fd			ld (debug_mark+1),a  
04cb 3a d5 04			ld a, (.dmark+2)  
04ce 32 9f fd			ld (debug_mark+2),a  
04d1 18 03			jr .pastdmark  
04d3 ..			.dmark: db "SWB"  
04d6 f1			.pastdmark: pop af  
04d7			endm  
# End of macro DMARK
04d7			 
04d7					;push af 
04d7					;ld a, 'W' 
04d7					;ld (debug_mark),a 
04d7					;pop af 
04d7					CALLMONITOR 
04d7 cd aa fd			call debug_vector  
04da				endm  
# End of macro CALLMONITOR
04da				endif 
04da			 
04da			; might not be working 
04da			;	call se_writepage 
04da			 
04da			;	ret 
04da			; 
04da			 
04da			 
04da			 
04da			.wl1:    
04da			 
04da				; read physical block at hl into de 
04da			        ; increment hl and de to next read position on exit 
04da			 
04da e5				push hl 
04db d5				push de	 
04dc c5				push bc 
04dd 1a				ld a,(de) 
04de				;if DEBUG_STORESE 
04de			;		push af 
04de			;		ld a, 'W' 
04de			;		ld (debug_mark),a 
04de			;		pop af 
04de			;		CALLMONITOR 
04de			;	endif 
04de cd 65 02			call se_writebyte 
04e1			;	call delay250ms 
04e1			;	nop 
04e1			;	nop 
04e1			;	nop 
04e1			;	if DEBUG_STORESE 
04e1			;		push af 
04e1			;		ld a, 'w' 
04e1			;		ld (debug_mark),a 
04e1			;		pop af 
04e1			;		CALLMONITOR 
04e1			;	endif 
04e1 c1				pop bc 
04e2 d1				pop de 
04e3 e1				pop hl 
04e4 23				inc hl 
04e5 13				inc de 
04e6			 
04e6			 
04e6 10 f2			djnz .wl1 
04e8			 
04e8				if DEBUG_STORESE 
04e8					DMARK "SW2" 
04e8 f5				push af  
04e9 3a fd 04			ld a, (.dmark)  
04ec 32 9d fd			ld (debug_mark),a  
04ef 3a fe 04			ld a, (.dmark+1)  
04f2 32 9e fd			ld (debug_mark+1),a  
04f5 3a ff 04			ld a, (.dmark+2)  
04f8 32 9f fd			ld (debug_mark+2),a  
04fb 18 03			jr .pastdmark  
04fd ..			.dmark: db "SW2"  
0500 f1			.pastdmark: pop af  
0501			endm  
# End of macro DMARK
0501			 
0501					;push af 
0501					;ld a, 'W' 
0501					;ld (debug_mark),a 
0501					;pop af 
0501					CALLMONITOR 
0501 cd aa fd			call debug_vector  
0504				endm  
# End of macro CALLMONITOR
0504				endif 
0504 c9				ret	 
0505			 
0505			; Init bank 
0505			; --------- 
0505			; 
0505			; With current bank 
0505			; 
0505			; Setup block 0 config 
0505			;     Set 0 file id counter 
0505			;     Set formatted byte pattern 
0505			;     Zero out bank label 
0505			;      
0505			; For every logical block write 0-1 byte as null 
0505			 
0505			storage_get_block_0: 
0505			 
0505				; TODO check presence 
0505			 
0505				; get block 0 config 
0505			 
0505 21 00 00			ld hl, 0 
0508 11 ac f9			ld de, store_page 
050b cd 57 04			call storage_read_block 
050e			 
050e				if DEBUG_STORESE 
050e					DMARK "SB0" 
050e f5				push af  
050f 3a 23 05			ld a, (.dmark)  
0512 32 9d fd			ld (debug_mark),a  
0515 3a 24 05			ld a, (.dmark+1)  
0518 32 9e fd			ld (debug_mark+1),a  
051b 3a 25 05			ld a, (.dmark+2)  
051e 32 9f fd			ld (debug_mark+2),a  
0521 18 03			jr .pastdmark  
0523 ..			.dmark: db "SB0"  
0526 f1			.pastdmark: pop af  
0527			endm  
# End of macro DMARK
0527 11 ac f9				ld de, store_page 
052a			;		push af 
052a			;		ld a, 'i' 
052a			;		ld (debug_mark),a 
052a			;		pop af 
052a					CALLMONITOR 
052a cd aa fd			call debug_vector  
052d				endm  
# End of macro CALLMONITOR
052d				endif 
052d			 
052d				; is this area formatted? 
052d			 
052d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
052d 2a ad f9			ld hl, (store_page+1) 
0530 3e 80			ld a,0x80 
0532 bd				cp l 
0533 20 22			jr nz, .ininotformatted 
0535				; do a double check 
0535 3e 27			ld a, 0x27 
0537 bc				cp h 
0538 20 1d			jr nz, .ininotformatted 
053a			 
053a				; formatted then 
053a			 
053a				if DEBUG_STORESE 
053a					DMARK "SB1" 
053a f5				push af  
053b 3a 4f 05			ld a, (.dmark)  
053e 32 9d fd			ld (debug_mark),a  
0541 3a 50 05			ld a, (.dmark+1)  
0544 32 9e fd			ld (debug_mark+1),a  
0547 3a 51 05			ld a, (.dmark+2)  
054a 32 9f fd			ld (debug_mark+2),a  
054d 18 03			jr .pastdmark  
054f ..			.dmark: db "SB1"  
0552 f1			.pastdmark: pop af  
0553			endm  
# End of macro DMARK
0553					;push af 
0553					;ld a, 'I' 
0553					;ld (debug_mark),a 
0553					;pop af 
0553					CALLMONITOR 
0553 cd aa fd			call debug_vector  
0556				endm  
# End of macro CALLMONITOR
0556				endif 
0556 c9				ret 
0557			 
0557			.ininotformatted: 
0557				; bank not formatted so poke various bits to make sure 
0557			 
0557				if DEBUG_STORESE 
0557					DMARK "SB2" 
0557 f5				push af  
0558 3a 6c 05			ld a, (.dmark)  
055b 32 9d fd			ld (debug_mark),a  
055e 3a 6d 05			ld a, (.dmark+1)  
0561 32 9e fd			ld (debug_mark+1),a  
0564 3a 6e 05			ld a, (.dmark+2)  
0567 32 9f fd			ld (debug_mark+2),a  
056a 18 03			jr .pastdmark  
056c ..			.dmark: db "SB2"  
056f f1			.pastdmark: pop af  
0570			endm  
# End of macro DMARK
0570					;push af 
0570					;ld a, 'f' 
0570					;ld (debug_mark),a 
0570					;pop af 
0570					CALLMONITOR 
0570 cd aa fd			call debug_vector  
0573				endm  
# End of macro CALLMONITOR
0573				endif 
0573			 
0573 cd 84 0c			call storage_clear_page 
0576			 
0576 21 ac f9			ld hl, store_page 
0579			;	ld a, 0 
0579				 
0579 36 00			ld (hl),0   ; reset file counter 
057b			 
057b 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
057e 22 ad f9		 	ld (store_page+1), hl	 
0581			 
0581				; set default label 
0581			 
0581 21 1a 06			ld hl, .defaultbanklabl 
0584 11 af f9		 	ld de, store_page+3 
0587 01 0f 00			ld bc, 15 
058a ed b0			ldir 
058c			 
058c				; Append the current bank id 
058c 21 b8 f9			ld hl, store_page+3+9 
058f 3a 91 f9			ld a, (spi_device_id) 
0592 77				ld (hl), a 
0593			 
0593				; save default page 0 
0593			 
0593 21 00 00			ld hl, 0 
0596 11 ac f9			ld de, store_page 
0599				if DEBUG_STORESE 
0599					DMARK "SB3" 
0599 f5				push af  
059a 3a ae 05			ld a, (.dmark)  
059d 32 9d fd			ld (debug_mark),a  
05a0 3a af 05			ld a, (.dmark+1)  
05a3 32 9e fd			ld (debug_mark+1),a  
05a6 3a b0 05			ld a, (.dmark+2)  
05a9 32 9f fd			ld (debug_mark+2),a  
05ac 18 03			jr .pastdmark  
05ae ..			.dmark: db "SB3"  
05b1 f1			.pastdmark: pop af  
05b2			endm  
# End of macro DMARK
05b2			;		push af 
05b2			;		ld a, 'F' 
05b2			;		ld (debug_mark),a 
05b2			;		pop af 
05b2					CALLMONITOR 
05b2 cd aa fd			call debug_vector  
05b5				endm  
# End of macro CALLMONITOR
05b5				endif 
05b5 cd bc 04			call storage_write_block 
05b8				if DEBUG_STORESE 
05b8					DMARK "SB4" 
05b8 f5				push af  
05b9 3a cd 05			ld a, (.dmark)  
05bc 32 9d fd			ld (debug_mark),a  
05bf 3a ce 05			ld a, (.dmark+1)  
05c2 32 9e fd			ld (debug_mark+1),a  
05c5 3a cf 05			ld a, (.dmark+2)  
05c8 32 9f fd			ld (debug_mark+2),a  
05cb 18 03			jr .pastdmark  
05cd ..			.dmark: db "SB4"  
05d0 f1			.pastdmark: pop af  
05d1			endm  
# End of macro DMARK
05d1			;		push af 
05d1			;		ld a, '>' 
05d1			;		ld (debug_mark),a 
05d1			;		pop af 
05d1					CALLMONITOR 
05d1 cd aa fd			call debug_vector  
05d4				endm  
# End of macro CALLMONITOR
05d4				endif 
05d4			 
05d4			;	nop 
05d4			;	nop 
05d4			;	nop 
05d4			 
05d4				; now set 0 in every page to mark as a free block 
05d4			 
05d4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05d6 21 40 00			ld hl, STORE_BLOCK_PHY 
05d9			 
05d9 3e 00		.setmark1:   	ld a,0 
05db e5					push hl 
05dc c5					push bc 
05dd cd 65 02				call se_writebyte 
05e0 3e 0a			ld a, 10 
05e2 cd a5 0c			call aDelayInMS 
05e5 23				inc hl 
05e6 cd 65 02				call se_writebyte 
05e9 3e 0a			ld a, 10 
05eb cd a5 0c			call aDelayInMS 
05ee 2b				dec hl 
05ef c1					pop bc 
05f0 e1					pop hl 
05f1 3e 40				ld a, STORE_BLOCK_PHY 
05f3 cd ac 0f				call addatohl 
05f6 10 e1				djnz .setmark1 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 3e 00		.setmark2:   	ld a,0 
05fc e5					push hl 
05fd c5					push bc 
05fe cd 65 02				call se_writebyte 
0601 3e 0a			ld a, 10 
0603 cd a5 0c			call aDelayInMS 
0606 23				inc hl 
0607 cd 65 02				call se_writebyte 
060a 3e 0a			ld a, 10 
060c cd a5 0c			call aDelayInMS 
060f 2b				dec hl 
0610 c1					pop bc 
0611 e1					pop hl 
0612 3e 40				ld a, STORE_BLOCK_PHY 
0614 cd ac 0f				call addatohl 
0617 10 e1				djnz .setmark2 
0619			 
0619					 
0619			 
0619			 
0619 c9				ret 
061a			 
061a			 
061a			 
061a			 
061a .. 00		.defaultbanklabl:   db "BankLabel_",0 
0625			 
0625			 
0625			 
0625			; Label Bank 
0625			; ---------- 
0625			; 
0625			; With current bank 
0625			; Read block 0 
0625			; Set label 
0625			; Write block 0 
0625			 
0625			; label str pointer in hl 
0625			 
0625			storage_label:     
0625			 
0625				if DEBUG_STORESE 
0625					DMARK "LBL" 
0625 f5				push af  
0626 3a 3a 06			ld a, (.dmark)  
0629 32 9d fd			ld (debug_mark),a  
062c 3a 3b 06			ld a, (.dmark+1)  
062f 32 9e fd			ld (debug_mark+1),a  
0632 3a 3c 06			ld a, (.dmark+2)  
0635 32 9f fd			ld (debug_mark+2),a  
0638 18 03			jr .pastdmark  
063a ..			.dmark: db "LBL"  
063d f1			.pastdmark: pop af  
063e			endm  
# End of macro DMARK
063e					CALLMONITOR 
063e cd aa fd			call debug_vector  
0641				endm  
# End of macro CALLMONITOR
0641				endif 
0641			 
0641 e5				push hl 
0642			 
0642 cd 05 05			call storage_get_block_0 
0645			 
0645				; set default label 
0645			 
0645 e1				pop hl 
0646			 
0646 11 af f9		 	ld de, store_page+3 
0649 01 0f 00			ld bc, 15 
064c				if DEBUG_STORESE 
064c					DMARK "LB3" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 9d fd			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 9e fd			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 9f fd			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "LB3"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665					CALLMONITOR 
0665 cd aa fd			call debug_vector  
0668				endm  
# End of macro CALLMONITOR
0668				endif 
0668 ed b0			ldir 
066a				; save default page 0 
066a			 
066a 21 00 00			ld hl, 0 
066d 11 ac f9			ld de, store_page 
0670				if DEBUG_STORESE 
0670					DMARK "LBW" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 9d fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 9e fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 9f fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LBW"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd aa fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c cd bc 04			call storage_write_block 
068f			 
068f c9				ret 
0690			 
0690			 
0690			 
0690			; Read Block 0 - Config 
0690			; --------------------- 
0690			; 
0690			; With current bank 
0690			; Call presence test 
0690			;    If not present format/init bank  
0690			; Read block 0  
0690			;  
0690			 
0690			 
0690			; Dir 
0690			; --- 
0690			; 
0690			; With current bank 
0690			; Load Block 0 Config 
0690			; Get max file id number 
0690			; For each logical block 
0690			;    Read block read byte 2 
0690			;      if first block of file 
0690			;         Display file name 
0690			;         Display type flags for file 
0690			;        
0690			 
0690			; moving to words as this requires stack control 
0690			 
0690			 
0690			; Delete File 
0690			; ----------- 
0690			; 
0690			; With current bank 
0690			; 
0690			; Load Block 0 Config 
0690			; Get max file id number 
0690			; For each logical block 
0690			;    Read block file id 
0690			;      If first block of file and dont have file id 
0690			;         if file to delete 
0690			;         Save file id 
0690			;         Null file id 
0690			;         Write this block back 
0690			;      If file id is one saved 
0690			;         Null file id 
0690			;         Write this block back 
0690			 
0690			 
0690			.se_done: 
0690 e1				pop hl 
0691 c9				ret 
0692			 
0692			storage_erase: 
0692			 
0692				; hl contains the file id 
0692			 
0692 5d				ld e, l 
0693 16 00			ld d, 0 
0695 21 40 00			ld hl, STORE_BLOCK_PHY 
0698					if DEBUG_FORTH_WORDS 
0698						DMARK "ERA" 
0698 f5				push af  
0699 3a ad 06			ld a, (.dmark)  
069c 32 9d fd			ld (debug_mark),a  
069f 3a ae 06			ld a, (.dmark+1)  
06a2 32 9e fd			ld (debug_mark+1),a  
06a5 3a af 06			ld a, (.dmark+2)  
06a8 32 9f fd			ld (debug_mark+2),a  
06ab 18 03			jr .pastdmark  
06ad ..			.dmark: db "ERA"  
06b0 f1			.pastdmark: pop af  
06b1			endm  
# End of macro DMARK
06b1						CALLMONITOR 
06b1 cd aa fd			call debug_vector  
06b4				endm  
# End of macro CALLMONITOR
06b4					endif 
06b4 cd 83 07			call storage_findnextid 
06b7 cd d5 0f			call ishlzero 
06ba c8				ret z 
06bb			 
06bb e5				push hl 
06bc			 
06bc				; TODO check file not found 
06bc			 
06bc 11 ac f9			ld de, store_page 
06bf cd 57 04			call storage_read_block 
06c2			 
06c2 cd d5 0f			call ishlzero 
06c5 ca 90 06			jp z,.se_done 
06c8			 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER1" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 9d fd			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 9e fd			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 9f fd			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER1"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd aa fd			call debug_vector  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 3a ac f9			ld a, (store_page)	; get file id 
06e7 32 a0 f9			ld (store_tmpid), a 
06ea			 
06ea 3a ae f9			ld a, (store_page+2)    ; get count of extends 
06ed 32 9f f9			ld (store_tmpext), a 
06f0			 
06f0				; wipe file header 
06f0			 
06f0 e1				pop hl 
06f1 3e 00			ld a, 0 
06f3 32 ac f9			ld (store_page), a 
06f6 32 ad f9			ld (store_page+1),a 
06f9 11 ac f9			ld de, store_page 
06fc					if DEBUG_FORTH_WORDS 
06fc						DMARK "ER2" 
06fc f5				push af  
06fd 3a 11 07			ld a, (.dmark)  
0700 32 9d fd			ld (debug_mark),a  
0703 3a 12 07			ld a, (.dmark+1)  
0706 32 9e fd			ld (debug_mark+1),a  
0709 3a 13 07			ld a, (.dmark+2)  
070c 32 9f fd			ld (debug_mark+2),a  
070f 18 03			jr .pastdmark  
0711 ..			.dmark: db "ER2"  
0714 f1			.pastdmark: pop af  
0715			endm  
# End of macro DMARK
0715						CALLMONITOR 
0715 cd aa fd			call debug_vector  
0718				endm  
# End of macro CALLMONITOR
0718					endif 
0718 cd bc 04			call storage_write_block 
071b			 
071b			 
071b				; wipe file extents 
071b			 
071b 3a 9f f9			ld a, (store_tmpext) 
071e 47				ld b, a 
071f			 
071f			.eraext:	  
071f c5				push bc 
0720			 
0720 21 40 00			ld hl, STORE_BLOCK_PHY 
0723 3a a0 f9			ld a,(store_tmpid) 
0726 5f				ld e, a 
0727 50				ld d, b	 
0728					if DEBUG_FORTH_WORDS 
0728						DMARK "ER3" 
0728 f5				push af  
0729 3a 3d 07			ld a, (.dmark)  
072c 32 9d fd			ld (debug_mark),a  
072f 3a 3e 07			ld a, (.dmark+1)  
0732 32 9e fd			ld (debug_mark+1),a  
0735 3a 3f 07			ld a, (.dmark+2)  
0738 32 9f fd			ld (debug_mark+2),a  
073b 18 03			jr .pastdmark  
073d ..			.dmark: db "ER3"  
0740 f1			.pastdmark: pop af  
0741			endm  
# End of macro DMARK
0741						CALLMONITOR 
0741 cd aa fd			call debug_vector  
0744				endm  
# End of macro CALLMONITOR
0744					endif 
0744 cd 83 07			call storage_findnextid 
0747 cd d5 0f			call ishlzero 
074a ca 90 06			jp z,.se_done 
074d			 
074d e5				push hl 
074e 11 ac f9			ld de, store_page 
0751 cd 57 04			call storage_read_block 
0754			 
0754				; free block	 
0754			 
0754 3e 00			ld a, 0 
0756 32 ac f9			ld (store_page), a 
0759 32 ad f9			ld (store_page+1),a 
075c 11 ac f9			ld de, store_page 
075f e1				pop hl 
0760					if DEBUG_FORTH_WORDS 
0760						DMARK "ER4" 
0760 f5				push af  
0761 3a 75 07			ld a, (.dmark)  
0764 32 9d fd			ld (debug_mark),a  
0767 3a 76 07			ld a, (.dmark+1)  
076a 32 9e fd			ld (debug_mark+1),a  
076d 3a 77 07			ld a, (.dmark+2)  
0770 32 9f fd			ld (debug_mark+2),a  
0773 18 03			jr .pastdmark  
0775 ..			.dmark: db "ER4"  
0778 f1			.pastdmark: pop af  
0779			endm  
# End of macro DMARK
0779						CALLMONITOR 
0779 cd aa fd			call debug_vector  
077c				endm  
# End of macro CALLMONITOR
077c					endif 
077c cd bc 04			call storage_write_block 
077f			 
077f c1				pop bc 
0780 10 9d			djnz .eraext 
0782			 
0782 c9				ret 
0783			 
0783			 
0783			; Find Free Block 
0783			; --------------- 
0783			; 
0783			; With current bank 
0783			;  
0783			; From given starting logical block 
0783			;    Read block  
0783			;    If no file id 
0783			;         Return block id 
0783			 
0783			 
0783			; hl starting page number 
0783			; hl contains free page number or zero if no pages free 
0783			; e contains the file id to locate 
0783			; d contains the block number 
0783			 
0783			; TODO change to find file id and use zero for free block 
0783			 
0783			storage_findnextid: 
0783			 
0783				; now locate first 0 page to mark as a free block 
0783			 
0783 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0785			;	ld hl, STORE_BLOCK_PHY 
0785			 
0785					if DEBUG_FORTH_WORDS 
0785					DMARK "FNI" 
0785 f5				push af  
0786 3a 9a 07			ld a, (.dmark)  
0789 32 9d fd			ld (debug_mark),a  
078c 3a 9b 07			ld a, (.dmark+1)  
078f 32 9e fd			ld (debug_mark+1),a  
0792 3a 9c 07			ld a, (.dmark+2)  
0795 32 9f fd			ld (debug_mark+2),a  
0798 18 03			jr .pastdmark  
079a ..			.dmark: db "FNI"  
079d f1			.pastdmark: pop af  
079e			endm  
# End of macro DMARK
079e						CALLMONITOR 
079e cd aa fd			call debug_vector  
07a1				endm  
# End of macro CALLMONITOR
07a1					endif 
07a1			.ff1:   	 
07a1 e5					push hl 
07a2 c5					push bc 
07a3 d5					push de 
07a4 cd ff 02				call se_readbyte 
07a7 5f					ld e,a 
07a8 23					inc hl 
07a9 cd ff 02				call se_readbyte 
07ac 57					ld d, a 
07ad e1					pop hl 
07ae e5					push hl 
07af cd ca 0f				call cmp16 
07b2 28 49				jr z, .fffound 
07b4			 
07b4 d1					pop de 
07b5 c1					pop bc 
07b6 e1					pop hl 
07b7			 
07b7					; is found? 
07b7					;cp e 
07b7					;ret z 
07b7			 
07b7 3e 40				ld a, STORE_BLOCK_PHY 
07b9 cd ac 0f				call addatohl 
07bc 10 e3				djnz .ff1 
07be			 
07be 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07c0			.ff2:   	 
07c0			 
07c0 e5					push hl 
07c1 c5					push bc 
07c2 d5					push de 
07c3 cd ff 02				call se_readbyte 
07c6 5f					ld e,a 
07c7 23					inc hl 
07c8 cd ff 02				call se_readbyte 
07cb 57					ld d, a 
07cc			 
07cc e1					pop hl 
07cd e5					push hl 
07ce cd ca 0f				call cmp16 
07d1 28 2a				jr z, .fffound 
07d3			 
07d3 d1					pop de 
07d4 c1					pop bc 
07d5 e1					pop hl 
07d6					; is found? 
07d6					;cp e 
07d6					;ret z 
07d6			 
07d6 3e 40				ld a, STORE_BLOCK_PHY 
07d8 cd ac 0f				call addatohl 
07db 10 e3				djnz .ff2 
07dd			 
07dd			 
07dd					if DEBUG_FORTH_WORDS 
07dd					DMARK "FN-" 
07dd f5				push af  
07de 3a f2 07			ld a, (.dmark)  
07e1 32 9d fd			ld (debug_mark),a  
07e4 3a f3 07			ld a, (.dmark+1)  
07e7 32 9e fd			ld (debug_mark+1),a  
07ea 3a f4 07			ld a, (.dmark+2)  
07ed 32 9f fd			ld (debug_mark+2),a  
07f0 18 03			jr .pastdmark  
07f2 ..			.dmark: db "FN-"  
07f5 f1			.pastdmark: pop af  
07f6			endm  
# End of macro DMARK
07f6					;	push af 
07f6					;	ld a, 'n' 
07f6					;	ld (debug_mark),a 
07f6					;	pop af 
07f6						CALLMONITOR 
07f6 cd aa fd			call debug_vector  
07f9				endm  
# End of macro CALLMONITOR
07f9					endif 
07f9				; no free marks! 
07f9 21 00 00				ld hl, 0 
07fc c9				ret 
07fd			.fffound: 
07fd				 
07fd			 
07fd d1					pop de 
07fe c1					pop bc 
07ff e1					pop hl 
0800					if DEBUG_FORTH_WORDS 
0800					DMARK "FNF" 
0800 f5				push af  
0801 3a 15 08			ld a, (.dmark)  
0804 32 9d fd			ld (debug_mark),a  
0807 3a 16 08			ld a, (.dmark+1)  
080a 32 9e fd			ld (debug_mark+1),a  
080d 3a 17 08			ld a, (.dmark+2)  
0810 32 9f fd			ld (debug_mark+2),a  
0813 18 03			jr .pastdmark  
0815 ..			.dmark: db "FNF"  
0818 f1			.pastdmark: pop af  
0819			endm  
# End of macro DMARK
0819					;	push af 
0819					;	ld a, 'n' 
0819					;	ld (debug_mark),a 
0819					;	pop af 
0819						CALLMONITOR 
0819 cd aa fd			call debug_vector  
081c				endm  
# End of macro CALLMONITOR
081c					endif 
081c c9				ret 
081d			 
081d			 
081d			 
081d			; Free Space 
081d			; ---------- 
081d			; 
081d			; With current bank 
081d			; 
081d			; Set block count to zero 
081d			; Starting with first logical block 
081d			;      Find free block  
081d			;      If block id given, increment block count 
081d			; 
081d			;  
081d			 
081d			 
081d			; hl contains count of free blocks 
081d			 
081d			storage_freeblocks: 
081d			 
081d				; now locate first 0 page to mark as a free block 
081d			 
081d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
081f 21 40 00			ld hl, STORE_BLOCK_PHY 
0822 11 00 00			ld de, 0 
0825			 
0825			.fb1:   	 
0825 e5					push hl 
0826 c5					push bc 
0827 d5					push de 
0828 cd ff 02				call se_readbyte 
082b d1					pop de 
082c c1					pop bc 
082d e1					pop hl 
082e			 
082e					; is free? 
082e			;		cp 0 
082e b7					or a 
082f 20 01				jr nz, .ff1cont 
0831 13					inc de 
0832			 
0832			.ff1cont: 
0832			 
0832			 
0832 3e 40				ld a, STORE_BLOCK_PHY 
0834 cd ac 0f				call addatohl 
0837 10 ec				djnz .fb1 
0839			 
0839 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
083b			.fb2:   	 
083b e5					push hl 
083c c5					push bc 
083d d5					push de 
083e cd ff 02				call se_readbyte 
0841 d1					pop de 
0842 c1					pop bc 
0843 e1					pop hl 
0844			 
0844					; is free? 
0844			;		cp 0 
0844 b7					or a 
0845 20 01				jr nz, .ff2cont 
0847 13					inc de 
0848			 
0848			.ff2cont: 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd ac 0f				call addatohl 
084d 10 ec				djnz .fb2 
084f			 
084f eb				ex de, hl 
0850 c9				ret 
0851			 
0851			; Get File ID 
0851			; ----------- 
0851			; 
0851			; With current bank 
0851			;  
0851			; Load Block 0 Config 
0851			; Get max file id number 
0851			; For each logical block 
0851			;    Read block file id 
0851			;      If first block of file and dont have file id 
0851			;         if file get id and exit 
0851			 
0851			 
0851			 
0851			 
0851			; Create File 
0851			; ----------- 
0851			; 
0851			; With current bank  
0851			; Load Block 0 Config 
0851			; Get max file id number 
0851			; Increment file id number 
0851			; Save Config 
0851			; Find free block 
0851			; Set buffer with file name and file id 
0851			; Write buffer to free block  
0851			 
0851			 
0851			; hl point to file name 
0851			; hl returns file id 
0851			 
0851			; file format: 
0851			; byte 0 - file id 
0851			; byte 1 - extent number 
0851			; byte 2-> data 
0851			 
0851			; format for extent number 0: 
0851			; 
0851			; byte 0 - file id 
0851			; byte 1 - extent 0 
0851			; byte 2 - extent count 
0851			; byte 3 -> file name and meta data 
0851			 
0851			 
0851			storage_create: 
0851				if DEBUG_STORESE 
0851					DMARK "SCR" 
0851 f5				push af  
0852 3a 66 08			ld a, (.dmark)  
0855 32 9d fd			ld (debug_mark),a  
0858 3a 67 08			ld a, (.dmark+1)  
085b 32 9e fd			ld (debug_mark+1),a  
085e 3a 68 08			ld a, (.dmark+2)  
0861 32 9f fd			ld (debug_mark+2),a  
0864 18 03			jr .pastdmark  
0866 ..			.dmark: db "SCR"  
0869 f1			.pastdmark: pop af  
086a			endm  
# End of macro DMARK
086a					CALLMONITOR 
086a cd aa fd			call debug_vector  
086d				endm  
# End of macro CALLMONITOR
086d				endif 
086d			 
086d e5				push hl		; save file name pointer 
086e			 
086e cd 05 05			call storage_get_block_0 
0871			 
0871 3a ac f9			ld a,(store_page)	; get current file id 
0874 3c				inc a 
0875 32 ac f9			ld (store_page),a 
0878				 
0878 32 a0 f9			ld (store_tmpid),a			; save id 
087b			 
087b 21 00 00			ld hl, 0 
087e 11 ac f9			ld de, store_page 
0881				if DEBUG_STORESE 
0881					DMARK "SCw" 
0881 f5				push af  
0882 3a 96 08			ld a, (.dmark)  
0885 32 9d fd			ld (debug_mark),a  
0888 3a 97 08			ld a, (.dmark+1)  
088b 32 9e fd			ld (debug_mark+1),a  
088e 3a 98 08			ld a, (.dmark+2)  
0891 32 9f fd			ld (debug_mark+2),a  
0894 18 03			jr .pastdmark  
0896 ..			.dmark: db "SCw"  
0899 f1			.pastdmark: pop af  
089a			endm  
# End of macro DMARK
089a					CALLMONITOR 
089a cd aa fd			call debug_vector  
089d				endm  
# End of macro CALLMONITOR
089d				endif 
089d cd bc 04			call storage_write_block	 ; save update 
08a0			 
08a0				if DEBUG_STORESE 
08a0 11 ac f9				ld de, store_page 
08a3					DMARK "SCC" 
08a3 f5				push af  
08a4 3a b8 08			ld a, (.dmark)  
08a7 32 9d fd			ld (debug_mark),a  
08aa 3a b9 08			ld a, (.dmark+1)  
08ad 32 9e fd			ld (debug_mark+1),a  
08b0 3a ba 08			ld a, (.dmark+2)  
08b3 32 9f fd			ld (debug_mark+2),a  
08b6 18 03			jr .pastdmark  
08b8 ..			.dmark: db "SCC"  
08bb f1			.pastdmark: pop af  
08bc			endm  
# End of macro DMARK
08bc					CALLMONITOR 
08bc cd aa fd			call debug_vector  
08bf				endm  
# End of macro CALLMONITOR
08bf				endif 
08bf				;  
08bf				 
08bf 21 40 00			ld hl, STORE_BLOCK_PHY 
08c2 11 00 00			ld de, 0 
08c5 cd 83 07			call storage_findnextid 
08c8			 
08c8 22 97 f9			ld (store_tmppageid), hl    ; save page to use  
08cb			 
08cb				; TODO detect 0 = no spare blocks 
08cb			 
08cb				; hl now contains the free page to use for the file header page 
08cb			 
08cb				if DEBUG_STORESE 
08cb				DMARK "SCF" 
08cb f5				push af  
08cc 3a e0 08			ld a, (.dmark)  
08cf 32 9d fd			ld (debug_mark),a  
08d2 3a e1 08			ld a, (.dmark+1)  
08d5 32 9e fd			ld (debug_mark+1),a  
08d8 3a e2 08			ld a, (.dmark+2)  
08db 32 9f fd			ld (debug_mark+2),a  
08de 18 03			jr .pastdmark  
08e0 ..			.dmark: db "SCF"  
08e3 f1			.pastdmark: pop af  
08e4			endm  
# End of macro DMARK
08e4					CALLMONITOR 
08e4 cd aa fd			call debug_vector  
08e7				endm  
# End of macro CALLMONITOR
08e7				endif 
08e7			 
08e7 22 97 f9			ld (store_tmppageid), hl 
08ea				 
08ea 3a a0 f9			ld a,(store_tmpid)    ; get file id 
08ed			;	ld a, (store_filecache)			; save to cache 
08ed			 
08ed 32 ac f9			ld (store_page),a    ; set page id 
08f0 3e 00			ld a, 0			 ; extent 0 is file header 
08f2 32 ad f9			ld (store_page+1), a   ; set file extent 
08f5			 
08f5 32 ae f9			ld (store_page+2), a   ; extent count for the file 
08f8			 
08f8			;	inc hl 		; init block 0 of file 
08f8			;	inc hl   		; skip file and extent id 
08f8			 ;       ld a, 0 
08f8			;	ld (hl),a 
08f8			;	ld a, (store_filecache+1)  	; save to cache 
08f8			 
08f8			;	inc hl    ; file name 
08f8				 
08f8				 
08f8 11 af f9			ld de, store_page+3    ; get buffer for term string to use as file name 
08fb				if DEBUG_STORESE 
08fb					DMARK "SCc" 
08fb f5				push af  
08fc 3a 10 09			ld a, (.dmark)  
08ff 32 9d fd			ld (debug_mark),a  
0902 3a 11 09			ld a, (.dmark+1)  
0905 32 9e fd			ld (debug_mark+1),a  
0908 3a 12 09			ld a, (.dmark+2)  
090b 32 9f fd			ld (debug_mark+2),a  
090e 18 03			jr .pastdmark  
0910 ..			.dmark: db "SCc"  
0913 f1			.pastdmark: pop af  
0914			endm  
# End of macro DMARK
0914					CALLMONITOR 
0914 cd aa fd			call debug_vector  
0917				endm  
# End of macro CALLMONITOR
0917				endif 
0917 e1				pop hl    ; get zero term string 
0918 e5				push hl 
0919 3e 00			ld a, 0 
091b cd 0f 13			call strlent 
091e 23				inc hl   ; cover zero term 
091f 06 00			ld b,0 
0921 4d				ld c,l 
0922 e1				pop hl 
0923				;ex de, hl 
0923				if DEBUG_STORESE 
0923					DMARK "SCa" 
0923 f5				push af  
0924 3a 38 09			ld a, (.dmark)  
0927 32 9d fd			ld (debug_mark),a  
092a 3a 39 09			ld a, (.dmark+1)  
092d 32 9e fd			ld (debug_mark+1),a  
0930 3a 3a 09			ld a, (.dmark+2)  
0933 32 9f fd			ld (debug_mark+2),a  
0936 18 03			jr .pastdmark  
0938 ..			.dmark: db "SCa"  
093b f1			.pastdmark: pop af  
093c			endm  
# End of macro DMARK
093c					;push af 
093c					;ld a, 'a' 
093c					;ld (debug_mark),a 
093c					;pop af 
093c					CALLMONITOR 
093c cd aa fd			call debug_vector  
093f				endm  
# End of macro CALLMONITOR
093f				endif 
093f ed b0			ldir    ; copy zero term string 
0941				if DEBUG_STORESE 
0941					DMARK "SCA" 
0941 f5				push af  
0942 3a 56 09			ld a, (.dmark)  
0945 32 9d fd			ld (debug_mark),a  
0948 3a 57 09			ld a, (.dmark+1)  
094b 32 9e fd			ld (debug_mark+1),a  
094e 3a 58 09			ld a, (.dmark+2)  
0951 32 9f fd			ld (debug_mark+2),a  
0954 18 03			jr .pastdmark  
0956 ..			.dmark: db "SCA"  
0959 f1			.pastdmark: pop af  
095a			endm  
# End of macro DMARK
095a					CALLMONITOR 
095a cd aa fd			call debug_vector  
095d				endm  
# End of macro CALLMONITOR
095d				endif 
095d			 
095d				; write file header page 
095d			 
095d 2a 97 f9			ld hl,(store_tmppageid) 
0960 11 ac f9			ld de, store_page 
0963				if DEBUG_STORESE 
0963					DMARK "SCb" 
0963 f5				push af  
0964 3a 78 09			ld a, (.dmark)  
0967 32 9d fd			ld (debug_mark),a  
096a 3a 79 09			ld a, (.dmark+1)  
096d 32 9e fd			ld (debug_mark+1),a  
0970 3a 7a 09			ld a, (.dmark+2)  
0973 32 9f fd			ld (debug_mark+2),a  
0976 18 03			jr .pastdmark  
0978 ..			.dmark: db "SCb"  
097b f1			.pastdmark: pop af  
097c			endm  
# End of macro DMARK
097c					;push af 
097c					;ld a, 'b' 
097c					;ld (debug_mark),a 
097c					;pop af 
097c					CALLMONITOR 
097c cd aa fd			call debug_vector  
097f				endm  
# End of macro CALLMONITOR
097f				endif 
097f cd bc 04			call storage_write_block 
0982			 
0982 3a a0 f9			ld a, (store_tmpid) 
0985 6f				ld l, a 
0986 26 00			ld h,0 
0988				if DEBUG_STORESE 
0988					DMARK "SCz" 
0988 f5				push af  
0989 3a 9d 09			ld a, (.dmark)  
098c 32 9d fd			ld (debug_mark),a  
098f 3a 9e 09			ld a, (.dmark+1)  
0992 32 9e fd			ld (debug_mark+1),a  
0995 3a 9f 09			ld a, (.dmark+2)  
0998 32 9f fd			ld (debug_mark+2),a  
099b 18 03			jr .pastdmark  
099d ..			.dmark: db "SCz"  
09a0 f1			.pastdmark: pop af  
09a1			endm  
# End of macro DMARK
09a1					CALLMONITOR 
09a1 cd aa fd			call debug_vector  
09a4				endm  
# End of macro CALLMONITOR
09a4				endif 
09a4 c9				ret 
09a5				 
09a5			 
09a5			 
09a5			; 
09a5			; Read File 
09a5			; 
09a5			; h - file id to locate 
09a5			; l - extent to locate 
09a5			; de - pointer to string to read into 
09a5			; 
09a5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09a5			 
09a5			.sr_fail: 
09a5 d1				pop de 
09a6 c9				ret 
09a7			 
09a7			storage_read: 
09a7			 
09a7			 
09a7 d5				push de 
09a8			 
09a8			; TODO BUG the above push is it popped before the RET Z? 
09a8			 
09a8			; TODO how to handle multiple part blocks 
09a8			 
09a8				; locate file extent to read 
09a8			 
09a8 5c				ld e, h 
09a9 55				ld d, l 
09aa			 
09aa			.srext: 
09aa 22 aa f9			ld (store_readptr), hl     ; save the current extent to load 
09ad ed 53 a8 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09b1			 
09b1 21 40 00			ld hl, STORE_BLOCK_PHY 
09b4				if DEBUG_STORESE 
09b4					DMARK "sre" 
09b4 f5				push af  
09b5 3a c9 09			ld a, (.dmark)  
09b8 32 9d fd			ld (debug_mark),a  
09bb 3a ca 09			ld a, (.dmark+1)  
09be 32 9e fd			ld (debug_mark+1),a  
09c1 3a cb 09			ld a, (.dmark+2)  
09c4 32 9f fd			ld (debug_mark+2),a  
09c7 18 03			jr .pastdmark  
09c9 ..			.dmark: db "sre"  
09cc f1			.pastdmark: pop af  
09cd			endm  
# End of macro DMARK
09cd					CALLMONITOR 
09cd cd aa fd			call debug_vector  
09d0				endm  
# End of macro CALLMONITOR
09d0				endif 
09d0 cd 83 07			call storage_findnextid 
09d3			 
09d3				if DEBUG_STORESE 
09d3					DMARK "srf" 
09d3 f5				push af  
09d4 3a e8 09			ld a, (.dmark)  
09d7 32 9d fd			ld (debug_mark),a  
09da 3a e9 09			ld a, (.dmark+1)  
09dd 32 9e fd			ld (debug_mark+1),a  
09e0 3a ea 09			ld a, (.dmark+2)  
09e3 32 9f fd			ld (debug_mark+2),a  
09e6 18 03			jr .pastdmark  
09e8 ..			.dmark: db "srf"  
09eb f1			.pastdmark: pop af  
09ec			endm  
# End of macro DMARK
09ec					CALLMONITOR 
09ec cd aa fd			call debug_vector  
09ef				endm  
# End of macro CALLMONITOR
09ef				endif 
09ef cd d5 0f			call ishlzero 
09f2			;	ld a, l 
09f2			;	add h 
09f2			;	cp 0 
09f2 28 b1			jr z,.sr_fail			; block not found so EOF 
09f4			 
09f4				; save current address for use by higher level words etc 
09f4			 
09f4 22 9d f9			ld (store_openaddr),hl 
09f7			 
09f7			 
09f7				; hl contains page number to load 
09f7 d1				pop de   ; get storage 
09f8 ed 53 a8 f9		ld (store_readbuf), de     ; current buffer to load in to 
09fc d5				push de 
09fd				if DEBUG_STORESE 
09fd					DMARK "srg" 
09fd f5				push af  
09fe 3a 12 0a			ld a, (.dmark)  
0a01 32 9d fd			ld (debug_mark),a  
0a04 3a 13 0a			ld a, (.dmark+1)  
0a07 32 9e fd			ld (debug_mark+1),a  
0a0a 3a 14 0a			ld a, (.dmark+2)  
0a0d 32 9f fd			ld (debug_mark+2),a  
0a10 18 03			jr .pastdmark  
0a12 ..			.dmark: db "srg"  
0a15 f1			.pastdmark: pop af  
0a16			endm  
# End of macro DMARK
0a16					CALLMONITOR 
0a16 cd aa fd			call debug_vector  
0a19				endm  
# End of macro CALLMONITOR
0a19				endif 
0a19 cd 57 04			call storage_read_block 
0a1c			 
0a1c				; if this a continuation read??? 
0a1c			 
0a1c 2a a8 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a1f			 
0a1f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a21 cd ac 0f			call addatohl 
0a24 7e				ld a,(hl) 
0a25			;	cp 0 
0a25 b7				or a 
0a26 28 02			jr z, .markiscont 
0a28 3e ff			ld a, 255 
0a2a			 
0a2a			.markiscont: 
0a2a 32 9f f9			ld (store_readcont), a 
0a2d			 
0a2d				if DEBUG_STORESE 
0a2d					DMARK "srC" 
0a2d f5				push af  
0a2e 3a 42 0a			ld a, (.dmark)  
0a31 32 9d fd			ld (debug_mark),a  
0a34 3a 43 0a			ld a, (.dmark+1)  
0a37 32 9e fd			ld (debug_mark+1),a  
0a3a 3a 44 0a			ld a, (.dmark+2)  
0a3d 32 9f fd			ld (debug_mark+2),a  
0a40 18 03			jr .pastdmark  
0a42 ..			.dmark: db "srC"  
0a45 f1			.pastdmark: pop af  
0a46			endm  
# End of macro DMARK
0a46					CALLMONITOR 
0a46 cd aa fd			call debug_vector  
0a49				endm  
# End of macro CALLMONITOR
0a49				endif 
0a49				; only short reads enabled 
0a49			 
0a49 3a a7 f9			ld a, (store_longread) 
0a4c			;	cp 0 
0a4c b7				or a 
0a4d ca 19 0b			jp z, .readdone 
0a50			 
0a50			; TODO if block has no zeros then need to read next block  
0a50			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a50			; check last byte of physical block. 
0a50			; if not zero then the next block needs to be loaded 
0a50			 
0a50			 
0a50 2a a8 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a53			 
0a53 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a55 cd ac 0f			call addatohl 
0a58				;dec hl 
0a58 7e				ld a,(hl) 
0a59				if DEBUG_STORESE 
0a59					DMARK "sr?" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 9d fd			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 9e fd			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 9f fd			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "sr?"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd aa fd			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			;	cp 0 
0a75 b7				or a 
0a76 ca 19 0b			jp z, .readdone 
0a79			 
0a79				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a79			 
0a79 23				inc hl 
0a7a			 
0a7a 22 a8 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a7d			 
0a7d ed 5b aa f9		ld de, (store_readptr)     ; save the current extent to load 
0a81			 
0a81 eb				ex de, hl 
0a82			 
0a82				; next ext 
0a82			 
0a82 23				inc hl 
0a83 22 aa f9			ld  (store_readptr), hl     ; save the current extent to load 
0a86			 
0a86				if DEBUG_STORESE 
0a86					DMARK "sF2" 
0a86 f5				push af  
0a87 3a 9b 0a			ld a, (.dmark)  
0a8a 32 9d fd			ld (debug_mark),a  
0a8d 3a 9c 0a			ld a, (.dmark+1)  
0a90 32 9e fd			ld (debug_mark+1),a  
0a93 3a 9d 0a			ld a, (.dmark+2)  
0a96 32 9f fd			ld (debug_mark+2),a  
0a99 18 03			jr .pastdmark  
0a9b ..			.dmark: db "sF2"  
0a9e f1			.pastdmark: pop af  
0a9f			endm  
# End of macro DMARK
0a9f					CALLMONITOR 
0a9f cd aa fd			call debug_vector  
0aa2				endm  
# End of macro CALLMONITOR
0aa2				endif 
0aa2			 
0aa2				; get and load block 
0aa2			 
0aa2 cd 83 07			call storage_findnextid 
0aa5			 
0aa5				if DEBUG_STORESE 
0aa5					DMARK "sf2" 
0aa5 f5				push af  
0aa6 3a ba 0a			ld a, (.dmark)  
0aa9 32 9d fd			ld (debug_mark),a  
0aac 3a bb 0a			ld a, (.dmark+1)  
0aaf 32 9e fd			ld (debug_mark+1),a  
0ab2 3a bc 0a			ld a, (.dmark+2)  
0ab5 32 9f fd			ld (debug_mark+2),a  
0ab8 18 03			jr .pastdmark  
0aba ..			.dmark: db "sf2"  
0abd f1			.pastdmark: pop af  
0abe			endm  
# End of macro DMARK
0abe					CALLMONITOR 
0abe cd aa fd			call debug_vector  
0ac1				endm  
# End of macro CALLMONITOR
0ac1				endif 
0ac1 cd d5 0f			call ishlzero 
0ac4			;	ld a, l 
0ac4			;	add h 
0ac4			;	cp 0 
0ac4 ca a5 09			jp z,.sr_fail			; block not found so EOF 
0ac7				 
0ac7				; save current address for use by higher level words etc 
0ac7			 
0ac7 22 9d f9			ld (store_openaddr),hl 
0aca			 
0aca cd 57 04			call storage_read_block 
0acd			 
0acd				; on a continuation block, we now have the file id and ext in the middle of the block 
0acd				; we need to pull everything back  
0acd			 
0acd ed 5b a8 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0ad1 2a a8 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0ad4 23				inc hl 
0ad5 23				inc hl     ; skip id and ext 
0ad6 01 40 00			ld bc, STORE_BLOCK_PHY 
0ad9				if DEBUG_STORESE 
0ad9					DMARK "SR<" 
0ad9 f5				push af  
0ada 3a ee 0a			ld a, (.dmark)  
0add 32 9d fd			ld (debug_mark),a  
0ae0 3a ef 0a			ld a, (.dmark+1)  
0ae3 32 9e fd			ld (debug_mark+1),a  
0ae6 3a f0 0a			ld a, (.dmark+2)  
0ae9 32 9f fd			ld (debug_mark+2),a  
0aec 18 03			jr .pastdmark  
0aee ..			.dmark: db "SR<"  
0af1 f1			.pastdmark: pop af  
0af2			endm  
# End of macro DMARK
0af2					CALLMONITOR 
0af2 cd aa fd			call debug_vector  
0af5				endm  
# End of macro CALLMONITOR
0af5				endif 
0af5 ed b0			ldir     ; copy data 
0af7			 
0af7				; move the pointer back and pretend we have a full buffer for next recheck 
0af7			 
0af7 1b				dec de 
0af8 1b				dec de 
0af9			 
0af9			; TODO do pop below now short circuit loop????? 
0af9 c1				pop bc     ; get rid of spare de on stack 
0afa				if DEBUG_STORESE 
0afa					DMARK "SR>" 
0afa f5				push af  
0afb 3a 0f 0b			ld a, (.dmark)  
0afe 32 9d fd			ld (debug_mark),a  
0b01 3a 10 0b			ld a, (.dmark+1)  
0b04 32 9e fd			ld (debug_mark+1),a  
0b07 3a 11 0b			ld a, (.dmark+2)  
0b0a 32 9f fd			ld (debug_mark+2),a  
0b0d 18 03			jr .pastdmark  
0b0f ..			.dmark: db "SR>"  
0b12 f1			.pastdmark: pop af  
0b13			endm  
# End of macro DMARK
0b13					CALLMONITOR 
0b13 cd aa fd			call debug_vector  
0b16				endm  
# End of macro CALLMONITOR
0b16				endif 
0b16 c3 aa 09			jp .srext 
0b19			 
0b19			 
0b19			 
0b19			 
0b19			 
0b19			.readdone:		 
0b19 e1				pop hl 		 ; return start of data to show as not EOF 
0b1a 23				inc hl   ; past file id 
0b1b 23				inc hl   ; past ext 
0b1c				if DEBUG_STORESE 
0b1c					DMARK "SRe" 
0b1c f5				push af  
0b1d 3a 31 0b			ld a, (.dmark)  
0b20 32 9d fd			ld (debug_mark),a  
0b23 3a 32 0b			ld a, (.dmark+1)  
0b26 32 9e fd			ld (debug_mark+1),a  
0b29 3a 33 0b			ld a, (.dmark+2)  
0b2c 32 9f fd			ld (debug_mark+2),a  
0b2f 18 03			jr .pastdmark  
0b31 ..			.dmark: db "SRe"  
0b34 f1			.pastdmark: pop af  
0b35			endm  
# End of macro DMARK
0b35					CALLMONITOR 
0b35 cd aa fd			call debug_vector  
0b38				endm  
# End of macro CALLMONITOR
0b38				endif 
0b38 c9					ret 
0b39			 
0b39			 
0b39			 
0b39			; 
0b39			; Append File 
0b39			; 
0b39			; hl - file id to locate 
0b39			; de - pointer to (multi block) string to write 
0b39			 
0b39			.sa_notfound: 
0b39 d1				pop de 
0b3a c9				ret 
0b3b			 
0b3b			 
0b3b			storage_append: 
0b3b				; hl -  file id to append to 
0b3b				; de - string to append 
0b3b			 
0b3b d5				push de 
0b3c				 
0b3c				if DEBUG_STORESE 
0b3c					DMARK "AP1" 
0b3c f5				push af  
0b3d 3a 51 0b			ld a, (.dmark)  
0b40 32 9d fd			ld (debug_mark),a  
0b43 3a 52 0b			ld a, (.dmark+1)  
0b46 32 9e fd			ld (debug_mark+1),a  
0b49 3a 53 0b			ld a, (.dmark+2)  
0b4c 32 9f fd			ld (debug_mark+2),a  
0b4f 18 03			jr .pastdmark  
0b51 ..			.dmark: db "AP1"  
0b54 f1			.pastdmark: pop af  
0b55			endm  
# End of macro DMARK
0b55					CALLMONITOR 
0b55 cd aa fd			call debug_vector  
0b58				endm  
# End of macro CALLMONITOR
0b58				endif 
0b58			 
0b58 7d				ld a, l 
0b59 32 a0 f9			ld (store_tmpid), a 
0b5c			 
0b5c				; get file header  
0b5c			 
0b5c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b5e 3a a0 f9			ld a, (store_tmpid) 
0b61 5f				ld e, a 
0b62			 
0b62 21 40 00				ld hl, STORE_BLOCK_PHY 
0b65 cd 83 07				call storage_findnextid 
0b68			 
0b68 cd d5 0f			call ishlzero 
0b6b 28 cc			jr z, .sa_notfound 
0b6d			 
0b6d 22 97 f9			ld (store_tmppageid), hl 
0b70			 
0b70				; TODO handle file id not found 
0b70			 
0b70				if DEBUG_STORESE 
0b70					DMARK "AP2" 
0b70 f5				push af  
0b71 3a 85 0b			ld a, (.dmark)  
0b74 32 9d fd			ld (debug_mark),a  
0b77 3a 86 0b			ld a, (.dmark+1)  
0b7a 32 9e fd			ld (debug_mark+1),a  
0b7d 3a 87 0b			ld a, (.dmark+2)  
0b80 32 9f fd			ld (debug_mark+2),a  
0b83 18 03			jr .pastdmark  
0b85 ..			.dmark: db "AP2"  
0b88 f1			.pastdmark: pop af  
0b89			endm  
# End of macro DMARK
0b89					CALLMONITOR 
0b89 cd aa fd			call debug_vector  
0b8c				endm  
# End of macro CALLMONITOR
0b8c				endif 
0b8c			 
0b8c				; update file extent count 
0b8c			 
0b8c 11 ac f9			ld de, store_page 
0b8f			 
0b8f cd 57 04			call storage_read_block 
0b92			 
0b92				if DEBUG_STORESE 
0b92					DMARK "AP3" 
0b92 f5				push af  
0b93 3a a7 0b			ld a, (.dmark)  
0b96 32 9d fd			ld (debug_mark),a  
0b99 3a a8 0b			ld a, (.dmark+1)  
0b9c 32 9e fd			ld (debug_mark+1),a  
0b9f 3a a9 0b			ld a, (.dmark+2)  
0ba2 32 9f fd			ld (debug_mark+2),a  
0ba5 18 03			jr .pastdmark  
0ba7 ..			.dmark: db "AP3"  
0baa f1			.pastdmark: pop af  
0bab			endm  
# End of macro DMARK
0bab					CALLMONITOR 
0bab cd aa fd			call debug_vector  
0bae				endm  
# End of macro CALLMONITOR
0bae				endif 
0bae			;	ld (store_tmppageid), hl 
0bae			 
0bae 3a ae f9			ld a, (store_page+2) 
0bb1 3c				inc a 
0bb2 32 ae f9			ld (store_page+2), a 
0bb5 32 9f f9			ld (store_tmpext), a 
0bb8				 
0bb8				if DEBUG_STORESE 
0bb8					DMARK "AP3" 
0bb8 f5				push af  
0bb9 3a cd 0b			ld a, (.dmark)  
0bbc 32 9d fd			ld (debug_mark),a  
0bbf 3a ce 0b			ld a, (.dmark+1)  
0bc2 32 9e fd			ld (debug_mark+1),a  
0bc5 3a cf 0b			ld a, (.dmark+2)  
0bc8 32 9f fd			ld (debug_mark+2),a  
0bcb 18 03			jr .pastdmark  
0bcd ..			.dmark: db "AP3"  
0bd0 f1			.pastdmark: pop af  
0bd1			endm  
# End of macro DMARK
0bd1					CALLMONITOR 
0bd1 cd aa fd			call debug_vector  
0bd4				endm  
# End of macro CALLMONITOR
0bd4				endif 
0bd4 2a 97 f9			ld hl, (store_tmppageid) 
0bd7 11 ac f9			ld de, store_page 
0bda cd bc 04			call storage_write_block 
0bdd			 
0bdd				; find free block 
0bdd			 
0bdd 11 00 00			ld de, 0			 ; file extent to locate 
0be0			 
0be0 21 40 00				ld hl, STORE_BLOCK_PHY 
0be3 cd 83 07				call storage_findnextid 
0be6 cd d5 0f			call ishlzero 
0be9 ca 39 0b			jp z, .sa_notfound 
0bec			 
0bec					; TODO handle no space left 
0bec					 
0bec 22 97 f9				ld (store_tmppageid), hl 
0bef			 
0bef				if DEBUG_STORESE 
0bef					DMARK "AP4" 
0bef f5				push af  
0bf0 3a 04 0c			ld a, (.dmark)  
0bf3 32 9d fd			ld (debug_mark),a  
0bf6 3a 05 0c			ld a, (.dmark+1)  
0bf9 32 9e fd			ld (debug_mark+1),a  
0bfc 3a 06 0c			ld a, (.dmark+2)  
0bff 32 9f fd			ld (debug_mark+2),a  
0c02 18 03			jr .pastdmark  
0c04 ..			.dmark: db "AP4"  
0c07 f1			.pastdmark: pop af  
0c08			endm  
# End of macro DMARK
0c08					CALLMONITOR 
0c08 cd aa fd			call debug_vector  
0c0b				endm  
# End of macro CALLMONITOR
0c0b				endif 
0c0b					; init the buffer with zeros so we can id if the buffer is full or not 
0c0b			 
0c0b e5					push hl 
0c0c c5					push bc 
0c0d			 
0c0d 21 ac f9				ld hl, store_page 
0c10 06 40				ld b, STORE_BLOCK_PHY 
0c12			;		ld a, 0 
0c12 36 00		.zeroblock:	ld (hl), 0 
0c14 23					inc hl 
0c15 10 fb				djnz .zeroblock 
0c17			 
0c17 c1					pop bc 
0c18 e1					pop hl 
0c19			 
0c19					; construct block 
0c19			 
0c19 3a a0 f9				ld a, (store_tmpid) 
0c1c 32 ac f9				ld (store_page), a   ; file id 
0c1f 3a 9f f9				ld a, (store_tmpext)   ; extent for this block 
0c22 32 ad f9				ld (store_page+1), a 
0c25			 
0c25 e1					pop hl    ; get string to write 
0c26 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c28 11 ae f9				ld de, store_page+2 
0c2b			 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP5" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 9d fd			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 9e fd			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 9f fd			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP5"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd aa fd			call debug_vector  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47			 
0c47			 
0c47			 
0c47					; fill buffer with data until end of string or full block 
0c47			 
0c47 7e			.appd:		ld a, (hl) 
0c48 12					ld (de), a 
0c49			;		cp 0 
0c49 b7					or a 
0c4a 28 04				jr z, .appdone 
0c4c 23					inc hl 
0c4d 13					inc de 
0c4e 10 f7				djnz .appd 
0c50			 
0c50 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c51 f5					push af   		; save last byte dumped 
0c52			 
0c52			 
0c52 2a 97 f9			ld hl, (store_tmppageid) 
0c55 11 ac f9			ld de, store_page 
0c58				if DEBUG_STORESE 
0c58					DMARK "AP6" 
0c58 f5				push af  
0c59 3a 6d 0c			ld a, (.dmark)  
0c5c 32 9d fd			ld (debug_mark),a  
0c5f 3a 6e 0c			ld a, (.dmark+1)  
0c62 32 9e fd			ld (debug_mark+1),a  
0c65 3a 6f 0c			ld a, (.dmark+2)  
0c68 32 9f fd			ld (debug_mark+2),a  
0c6b 18 03			jr .pastdmark  
0c6d ..			.dmark: db "AP6"  
0c70 f1			.pastdmark: pop af  
0c71			endm  
# End of macro DMARK
0c71					CALLMONITOR 
0c71 cd aa fd			call debug_vector  
0c74				endm  
# End of macro CALLMONITOR
0c74				endif 
0c74 cd bc 04				call storage_write_block 
0c77			 
0c77			 
0c77				; was that a full block of data written? 
0c77				; any more to write out? 
0c77			 
0c77				; if yes then set vars and jump to start of function again 
0c77			 
0c77 f1					pop af 
0c78 d1					pop de 
0c79			 
0c79					;cp 0		 ; no, string was fully written 
0c79 b7					or a 
0c7a c8					ret z 
0c7b			 
0c7b					; setup vars for next cycle 
0c7b			 
0c7b 3a a0 f9				ld a, (store_tmpid) 
0c7e 6f					ld l, a 
0c7f 26 00				ld h, 0 
0c81			 
0c81 c3 3b 0b			 	jp storage_append	 ; yes, need to write out some more 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			if DEBUG_STORECF 
0c84			storageput:	 
0c84					ret 
0c84			storageread: 
0c84					ld hl, store_page 
0c84					ld b, 200 
0c84			;		ld a,0 
0c84			.src:		ld (hl),0 
0c84					inc hl 
0c84					djnz .src 
0c84					 
0c84			 
0c84					ld de, 0 
0c84					ld bc, 1 
0c84					ld hl, store_page 
0c84					call cfRead 
0c84			 
0c84				call cfGetError 
0c84				ld hl,scratch 
0c84				call hexout 
0c84				ld hl, scratch+2 
0c84			;	ld a, 0 
0c84				ld (hl),0 
0c84				ld de, scratch 
0c84				ld a,display_row_1 
0c84				call str_at_display 
0c84				call update_display 
0c84			 
0c84					ld hl, store_page 
0c84					ld (os_cur_ptr),hl 
0c84			 
0c84					ret 
0c84			endif 
0c84			 
0c84			 
0c84			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c84			 
0c84			storage_clear_page: 
0c84 e5				push hl 
0c85 d5				push de 
0c86 c5				push bc 
0c87 21 ac f9			ld hl, store_page 
0c8a			;	ld a, 0 
0c8a 36 00			ld (hl), 0 
0c8c			 
0c8c 11 ad f9			ld de, store_page+1 
0c8f 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0c92			 
0c92 ed b0			ldir 
0c94				 
0c94 c1				pop bc 
0c95 d1				pop de 
0c96 e1				pop hl 
0c97 c9				ret 
0c98			 
0c98			; eof 
# End of file firmware_storage.asm
0c98			  
0c98			; support routines for above hardware abstraction layer  
0c98			  
0c98			include "firmware_general.asm"        ; general support functions  
0c98			 
0c98			; word look up 
0c98			 
0c98			; in 
0c98			; a is the index 
0c98			; hl is pointer start of array 
0c98			; 
0c98			; returns 
0c98			; hl to the word 
0c98			; 
0c98			 
0c98			table_lookup:  
0c98 d5					push de 
0c99 eb					ex de, hl 
0c9a			 
0c9a 6f					ld l, a 
0c9b 26 00				ld h, 0 
0c9d 29					add hl, hl 
0c9e 19					add hl, de 
0c9f 7e					ld a, (hl) 
0ca0 23					inc hl 
0ca1 66					ld h,(hl) 
0ca2 6f					ld l, a 
0ca3			 
0ca3 d1					pop de 
0ca4 c9					ret 
0ca5			 
0ca5			; Delay loops 
0ca5			 
0ca5			 
0ca5			 
0ca5			aDelayInMS: 
0ca5 c5				push bc 
0ca6 47				ld b,a 
0ca7			msdelay: 
0ca7 c5				push bc 
0ca8				 
0ca8			 
0ca8 01 41 00			ld bc,041h 
0cab cd c3 0c			call delayloop 
0cae c1				pop bc 
0caf 05				dec b 
0cb0 20 f5			jr nz,msdelay 
0cb2			 
0cb2			;if CPU_CLOCK_8MHZ 
0cb2			;msdelay8: 
0cb2			;	push bc 
0cb2			;	 
0cb2			; 
0cb2			;	ld bc,041h 
0cb2			;	call delayloop 
0cb2			;	pop bc 
0cb2			;	dec b 
0cb2			;	jr nz,msdelay8 
0cb2			;endif 
0cb2			 
0cb2			 
0cb2 c1				pop bc 
0cb3 c9				ret 
0cb4			 
0cb4			 
0cb4			delay250ms: 
0cb4				;push de 
0cb4 01 00 40			ld bc, 04000h 
0cb7 c3 c3 0c			jp delayloop 
0cba			delay500ms: 
0cba				;push de 
0cba 01 00 80			ld bc, 08000h 
0cbd c3 c3 0c			jp delayloop 
0cc0			delay1s: 
0cc0				;push bc 
0cc0			   ; Clobbers A, d and e 
0cc0 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cc3			delayloop: 
0cc3 c5			    push bc 
0cc4			 
0cc4			if BASE_CPM 
0cc4				ld bc, CPM_DELAY_TUNE 
0cc4			.cpmloop: 
0cc4				push bc 
0cc4			 
0cc4			endif 
0cc4			 
0cc4			 
0cc4			 
0cc4			delayloopi: 
0cc4			;	push bc 
0cc4			;.dl: 
0cc4 cb 47		    bit     0,a    	; 8 
0cc6 cb 47		    bit     0,a    	; 8 
0cc8 cb 47		    bit     0,a    	; 8 
0cca e6 ff		    and     255  	; 7 
0ccc 0b			    dec     bc      	; 6 
0ccd 79			    ld      a,c     	; 4 
0cce b0			    or      b     	; 4 
0ccf c2 c4 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cd2			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cd2				;pop de 
0cd2			;pop bc 
0cd2			 
0cd2			if BASE_CPM 
0cd2				pop bc 
0cd2				 
0cd2			    dec     bc      	; 6 
0cd2			    ld      a,c     	; 4 
0cd2			    or      b     	; 4 
0cd2			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cd2				 
0cd2			 
0cd2			endif 
0cd2			;if CPU_CLOCK_8MHZ 
0cd2			;    pop bc 
0cd2			;    push bc 
0cd2			;.dl8: 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    and     255  	; 7 
0cd2			;    dec     bc      	; 6 
0cd2			;    ld      a,c     	; 4 
0cd2			;    or      b     	; 4 
0cd2			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cd2			;endif 
0cd2			 
0cd2			;if CPU_CLOCK_10MHZ 
0cd2			;    pop bc 
0cd2			;    push bc 
0cd2			;.dl8: 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    and     255  	; 7 
0cd2			;    dec     bc      	; 6 
0cd2			;    ld      a,c     	; 4 
0cd2			;    or      b     	; 4 
0cd2			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cd2			;endif 
0cd2 c1			    pop bc 
0cd3			 
0cd3 c9				ret 
0cd4			 
0cd4			 
0cd4			 
0cd4			; eof 
# End of file firmware_general.asm
0cd4			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cd4			; display routines that use the physical hardware abstraction layer 
0cd4			 
0cd4			 
0cd4			; Display an activity indicator 
0cd4			; Each call returns the new char pointed to in hl 
0cd4			 
0cd4			active: 
0cd4 3a f8 fa			ld a, (display_active) 
0cd7 fe 06			cp 6 
0cd9			 
0cd9 20 02			jr nz, .sne 
0cdb				; gone past the last one reset sequence 
0cdb 3e ff			ld a, 255 
0cdd			 
0cdd			.sne:   
0cdd				; get the next char in seq 
0cdd 3c				inc a 
0cde 32 f8 fa			ld (display_active), a 
0ce1			 
0ce1				; look up the string in the table 
0ce1 21 f8 0c			ld hl, actseq 
0ce4 cb 27			sla a 
0ce6 cd ac 0f			call addatohl 
0ce9 cd d9 22			call loadwordinhl 
0cec			 
0cec				; forth will write the to string when pushing so move from rom to ram 
0cec			 
0cec 11 f9 fa			ld de, display_active+1 
0cef 01 02 00			ld bc, 2 
0cf2 ed b0			ldir 
0cf4			 
0cf4 21 f9 fa			ld hl, display_active+1 
0cf7 c9				ret 
0cf8				 
0cf8				 
0cf8			 
0cf8			 
0cf8			;db "|/-\|-\" 
0cf8			 
0cf8			actseq: 
0cf8			 
0cf8 06 0d		dw spin0 
0cfa 08 0d		dw spin1 
0cfc 0a 0d		dw spin2 
0cfe 0c 0d		dw spin3 
0d00 0a 0d		dw spin2 
0d02 08 0d		dw spin1 
0d04 06 0d		dw spin0 
0d06			 
0d06 .. 00		spin0: db " ", 0 
0d08 .. 00		spin1: db "-", 0 
0d0a .. 00		spin2: db "+", 0 
0d0c .. 00		spin3: db "#", 0 
0d0e			 
0d0e			 
0d0e			; information window 
0d0e			 
0d0e			; pass hl with 1st string to display 
0d0e			; pass de with 2nd string to display 
0d0e			 
0d0e			info_panel: 
0d0e e5				push hl 
0d0f			 
0d0f 2a fe fa			ld hl, (display_fb_active) 
0d12 e5				push hl    ; future de destination 
0d13 21 e3 fc				ld hl, display_fb0 
0d16 22 fe fa				ld (display_fb_active), hl 
0d19			 
0d19			;	call clear_display 
0d19			 
0d19				if BASE_CPM 
0d19				ld a, '.' 
0d19				else 
0d19 3e a5			ld a, 165 
0d1b				endif 
0d1b cd 81 0d			call fill_display 
0d1e			 
0d1e			 
0d1e 3e 55			ld a, display_row_3 + 5 
0d20 cd 8e 0d			call str_at_display 
0d23			 
0d23 e1				pop hl 
0d24 d1				pop de 
0d25			 
0d25 e5				push hl 
0d26			 
0d26			 
0d26 3e 2d			ld a, display_row_2 + 5 
0d28 cd 8e 0d			call str_at_display 
0d2b			 
0d2b			 
0d2b cd 9e 0d			call update_display 
0d2e cd e8 1e			call next_page_prompt 
0d31 cd 7c 0d			call clear_display 
0d34			 
0d34				 
0d34 21 42 fc				ld hl, display_fb1 
0d37 22 fe fa				ld (display_fb_active), hl 
0d3a cd 9e 0d			call update_display 
0d3d			 
0d3d e1				pop hl 
0d3e			 
0d3e c9				ret 
0d3f			 
0d3f			 
0d3f			 
0d3f			 
0d3f			; TODO windowing? 
0d3f			 
0d3f			; TODO scroll line up 
0d3f			 
0d3f			scroll_up: 
0d3f			 
0d3f e5				push hl 
0d40 d5				push de 
0d41 c5				push bc 
0d42			 
0d42				; get frame buffer  
0d42			 
0d42 2a fe fa			ld hl, (display_fb_active) 
0d45 e5				push hl    ; future de destination 
0d46			 
0d46 11 28 00			ld  de, display_cols 
0d49 19				add hl, de 
0d4a			 
0d4a d1				pop de 
0d4b			 
0d4b				;ex de, hl 
0d4b 01 9f 00			ld bc, display_fb_len -1  
0d4e			;if DEBUG_FORTH_WORDS 
0d4e			;	DMARK "SCL" 
0d4e			;	CALLMONITOR 
0d4e			;endif	 
0d4e ed b0			ldir 
0d50			 
0d50				; wipe bottom row 
0d50			 
0d50			 
0d50 2a fe fa			ld hl, (display_fb_active) 
0d53 11 a0 00			ld de, display_cols*display_rows 
0d56 19				add hl, de 
0d57 06 28			ld b, display_cols 
0d59			;	ld a, ' ' 
0d59			.scwipe: 
0d59 36 20			ld (hl), ' ' 
0d5b 2b				dec hl 
0d5c 10 fb			djnz .scwipe 
0d5e			 
0d5e				;pop hl 
0d5e			 
0d5e c1				pop bc 
0d5f d1				pop de 
0d60 e1				pop hl 
0d61			 
0d61 c9				ret 
0d62			 
0d62			 
0d62			;scroll_upo: 
0d62			;	ld de, display_row_1 
0d62			 ;	ld hl, display_row_2 
0d62			;	ld bc, display_cols 
0d62			;	ldir 
0d62			;	ld de, display_row_2 
0d62			 ;	ld hl, display_row_3 
0d62			;	ld bc, display_cols 
0d62			;	ldir 
0d62			;	ld de, display_row_3 
0d62			 ;	ld hl, display_row_4 
0d62			;	ld bc, display_cols 
0d62			;	ldir 
0d62			 
0d62			; TODO clear row 4 
0d62			 
0d62			;	ret 
0d62			 
0d62				 
0d62			scroll_down: 
0d62			 
0d62 e5				push hl 
0d63 d5				push de 
0d64 c5				push bc 
0d65			 
0d65				; get frame buffer  
0d65			 
0d65 2a fe fa			ld hl, (display_fb_active) 
0d68			 
0d68 11 9f 00			ld de, display_fb_len - 1 
0d6b 19				add hl, de 
0d6c			 
0d6c e5			push hl    ; future de destination 
0d6d			 
0d6d 11 28 00			ld  de, display_cols 
0d70 ed 52			sbc hl, de 
0d72			 
0d72			 
0d72 d1				pop de 
0d73			 
0d73			;	ex de, hl 
0d73 01 9f 00			ld bc, display_fb_len -1  
0d76			 
0d76			 
0d76				 
0d76			 
0d76 ed b0			ldir 
0d78			 
0d78				; wipe bottom row 
0d78			 
0d78			 
0d78			;	ld hl, (display_fb_active) 
0d78			;;	ld de, display_cols*display_rows 
0d78			;;	add hl, de 
0d78			;	ld b, display_cols 
0d78			;	ld a, ' ' 
0d78			;.scwiped: 
0d78			;	ld (hl), a 
0d78			;	dec hl 
0d78			;	djnz .scwiped 
0d78			 
0d78				;pop hl 
0d78			 
0d78 c1				pop bc 
0d79 d1				pop de 
0d7a e1				pop hl 
0d7b			 
0d7b c9				ret 
0d7c			;scroll_down: 
0d7c			;	ld de, display_row_4 
0d7c			;	ld hl, display_row_3 
0d7c			;	ld bc, display_cols 
0d7c			;	ldir 
0d7c			;	ld de, display_row_3 
0d7c			; 	ld hl, display_row_2 
0d7c			;	ld bc, display_cols 
0d7c			;	ldir 
0d7c			;	ld de, display_row_2 
0d7c			;	ld hl, display_row_1 
0d7c			;	ld bc, display_cols 
0d7c			;	ldir 
0d7c			;;; TODO clear row 1 
0d7c			;	ret 
0d7c			 
0d7c			 
0d7c			 
0d7c			 
0d7c			 
0d7c			; clear active frame buffer 
0d7c			 
0d7c			clear_display: 
0d7c 3e 20			ld a, ' ' 
0d7e c3 81 0d			jp fill_display 
0d81			 
0d81			; fill active frame buffer with a char in A 
0d81			 
0d81			fill_display: 
0d81 06 a0			ld b,display_fb_len 
0d83 2a fe fa			ld hl, (display_fb_active) 
0d86 77			.fd1:	ld (hl),a 
0d87 23				inc hl 
0d88 10 fc			djnz .fd1 
0d8a 23				inc hl 
0d8b			;	ld a,0 
0d8b 36 00			ld (hl),0 
0d8d			 
0d8d			 
0d8d c9				ret 
0d8e			; Write string (DE) at pos (A) to active frame buffer 
0d8e			 
0d8e 2a fe fa		str_at_display:    ld hl,(display_fb_active) 
0d91 06 00					ld b,0 
0d93 4f					ld c,a 
0d94 09					add hl,bc 
0d95 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d96 b7			            OR   A              ;Null terminator? 
0d97 c8			            RET  Z              ;Yes, so finished 
0d98 77					ld (hl),a 
0d99 23				inc hl 
0d9a 13			            INC  DE             ;Point to next character 
0d9b 18 f8		            JR   .sad1     ;Repeat 
0d9d c9					ret 
0d9e			 
0d9e			; using current frame buffer write to physical display 
0d9e			 
0d9e			update_display: 
0d9e e5				push hl 
0d9f 2a fe fa			ld hl, (display_fb_active) 
0da2 cd 02 77			call write_display 
0da5 e1				pop hl 
0da6 c9				ret 
0da7			 
0da7			; TODO scrolling 
0da7			 
0da7			 
0da7			; move cursor right one char 
0da7			cursor_right: 
0da7			 
0da7				; TODO shift right 
0da7				; TODO if beyond max col 
0da7				; TODO       cursor_next_line 
0da7			 
0da7 c9				ret 
0da8			 
0da8			 
0da8			cursor_next_line: 
0da8				; TODO first char 
0da8				; TODO line down 
0da8				; TODO if past last row 
0da8				; TODO    scroll up 
0da8			 
0da8 c9				ret 
0da9			 
0da9			cursor_left: 
0da9				; TODO shift left 
0da9				; TODO if beyond left  
0da9				; TODO     cursor prev line 
0da9				 
0da9 c9				ret 
0daa			 
0daa			cursor_prev_line: 
0daa				; TODO last char 
0daa				; TODO line up 
0daa				; TODO if past first row 
0daa				; TODO   scroll down 
0daa			 
0daa c9				ret 
0dab			 
0dab			 
0dab			cout: 
0dab				; A - char 
0dab c9				ret 
0dac			 
0dac			 
0dac			; Display a menu and allow item selection (optional toggle items) 
0dac			; 
0dac			; format: 
0dac			; hl pointer to word array with zero term for items 
0dac			; e.g.    db item1 
0dac			;         db .... 
0dac			;         db 0 
0dac			; 
0dac			; a = starting menu item  
0dac			; 
0dac			; de = pointer item toggle array   (todo) 
0dac			; 
0dac			; returns item selected in a 1-... 
0dac			; returns 0 if back button pressed 
0dac			; 
0dac			; NOTE: Uses system frame buffer to display 
0dac			; 
0dac			; LEFT, Q = go back 
0dac			; RIGHT, SPACE, CR = select 
0dac			; UP, A - Up 
0dac			; DOWN, Z - Down 
0dac			 
0dac			 
0dac			 
0dac			 
0dac			 
0dac			menu: 
0dac			 
0dac					; keep array pointer 
0dac			 
0dac 22 a5 f9				ld (store_tmp1), hl 
0daf 32 a3 f9				ld (store_tmp2), a 
0db2			 
0db2					; check for key bounce 
0db2			 
0db2			if BASE_KEV 
0db2			 
0db2 cd 4b 7a		.mbounce:	call cin 
0db5			;		cp 0 
0db5 b7					or a 
0db6 20 fa				jr nz, .mbounce 
0db8			endif 
0db8					; for ease use ex 
0db8			 
0db8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0db8 21 e3 fc				ld hl, display_fb0 
0dbb 22 fe fa				ld (display_fb_active), hl 
0dbe			 
0dbe cd 7c 0d		.mloop:		call clear_display 
0dc1 cd 9e 0d				call update_display 
0dc4			 
0dc4					; draw selection id '>' at 1 
0dc4			 
0dc4					; init start of list display 
0dc4			 
0dc4 3e 05				ld a, 5 
0dc6 32 a1 f9				ld (store_tmp3), a   ; display row count 
0dc9 3a a3 f9				ld a,( store_tmp2) 
0dcc 32 a4 f9				ld (store_tmp2+1), a   ; display item count 
0dcf			 
0dcf					 
0dcf			.mitem:	 
0dcf			 
0dcf			 
0dcf 3a a4 f9				ld a,(store_tmp2+1) 
0dd2 6f					ld l, a 
0dd3 26 00				ld h, 0 
0dd5 29					add hl, hl 
0dd6 ed 5b a5 f9			ld de, (store_tmp1) 
0dda 19					add hl, de 
0ddb 7e					ld a, (hl) 
0ddc 23					inc hl 
0ddd 66					ld h,(hl) 
0dde 6f					ld l, a 
0ddf			 
0ddf cd d5 0f				call ishlzero 
0de2 28 1a				jr z, .mdone 
0de4			 
0de4 eb					ex de, hl 
0de5 3a a1 f9				ld a, (store_tmp3) 
0de8 cd 8e 0d				call str_at_display 
0deb					 
0deb			 
0deb					; next item 
0deb 3a a4 f9				ld a, (store_tmp2+1) 
0dee 3c					inc a 
0def 32 a4 f9				ld (store_tmp2+1), a   ; display item count 
0df2			 
0df2			 		; next row 
0df2			 
0df2 3a a1 f9				ld a, (store_tmp3) 
0df5 c6 28				add display_cols 
0df7 32 a1 f9				ld (store_tmp3), a 
0dfa			 
0dfa					; at end of screen? 
0dfa			 
0dfa fe 10				cp display_rows*4 
0dfc 20 d1				jr nz, .mitem 
0dfe			 
0dfe			 
0dfe			.mdone: 
0dfe cd d5 0f				call ishlzero 
0e01 28 08				jr z, .nodn 
0e03			 
0e03 3e 78				ld a, display_row_4 
0e05 11 82 0e				ld de, .mdown 
0e08 cd 8e 0d				call str_at_display 
0e0b			 
0e0b					; draw options to fill the screens with active item on line 1 
0e0b					; if current option is 2 or more then display ^ in top 
0e0b			 
0e0b 3a a3 f9		.nodn:		ld a, (store_tmp2) 
0e0e			;		cp 0 
0e0e b7					or a 
0e0f 28 08				jr z, .noup 
0e11			 
0e11 3e 00				ld a, 0 
0e13 11 80 0e				ld de, .mup 
0e16 cd 8e 0d				call str_at_display 
0e19			 
0e19 3e 02		.noup:		ld a, 2 
0e1b 11 7e 0e				ld de, .msel 
0e1e cd 8e 0d				call str_at_display 
0e21			 
0e21					; if current option + 1 is not null then display V in bottom 
0e21					; get key 
0e21 cd 9e 0d				call update_display 
0e24			 
0e24			 
0e24					; handle key 
0e24			 
0e24 cd 3c 7a				call cin_wait 
0e27			 
0e27 fe 05				cp KEY_UP 
0e29 28 2b				jr z, .mgoup 
0e2b fe 61				cp 'a' 
0e2d 28 27				jr z, .mgoup 
0e2f fe 0a				cp KEY_DOWN 
0e31 28 31				jr z, .mgod 
0e33 fe 7a				cp 'z' 
0e35 28 2d				jr z, .mgod 
0e37 fe 20				cp ' ' 
0e39 28 33				jr z, .goend 
0e3b fe 0c				cp KEY_RIGHT 
0e3d 28 2f				jr z, .goend 
0e3f fe 0d				cp KEY_CR 
0e41 28 2b				jr z, .goend 
0e43 fe 71				cp 'q' 
0e45 28 0b				jr z, .goback 
0e47			 
0e47 fe 0b				cp KEY_LEFT 
0e49 28 07				jr z, .goback 
0e4b fe 08				cp KEY_BS 
0e4d 28 03				jr z, .goback 
0e4f c3 be 0d				jp .mloop 
0e52			 
0e52			.goback: 
0e52 3e 00			ld a, 0 
0e54 18 1c			jr .goend2 
0e56			 
0e56				; move up one 
0e56			.mgoup: 
0e56 3a a3 f9				ld a, (store_tmp2) 
0e59			;		cp 0 
0e59 b7					or a 
0e5a ca be 0d				jp z, .mloop 
0e5d 3d					dec a 
0e5e 32 a3 f9				ld (store_tmp2), a 
0e61 c3 be 0d				jp .mloop 
0e64			 
0e64				; move down one 
0e64			.mgod: 
0e64 3a a3 f9				ld a, (store_tmp2) 
0e67 3c					inc a 
0e68 32 a3 f9				ld (store_tmp2), a 
0e6b c3 be 0d				jp .mloop 
0e6e			 
0e6e			 
0e6e			.goend: 
0e6e					; get selected item number 
0e6e			 
0e6e 3a a3 f9				ld a, (store_tmp2) 
0e71 3c					inc a 
0e72			 
0e72			.goend2: 
0e72 f5					push af 
0e73			 
0e73					; restore active fb 
0e73					; TODO BUG assumes fb1 
0e73			 
0e73 21 42 fc				ld hl, display_fb1 
0e76 22 fe fa				ld (display_fb_active), hl 
0e79			 
0e79					; restore main regs 
0e79			 
0e79			 
0e79 cd 9e 0d				call update_display 
0e7c			 
0e7c f1					pop af 
0e7d			 
0e7d c9				ret 
0e7e			 
0e7e .. 00		.msel:   db ">",0 
0e80 .. 00		.mup:   db "^",0 
0e82 .. 00		.mdown:   db "v",0 
0e84			 
0e84			 
0e84			; eof 
0e84			 
# End of file firmware_display.asm
0e84			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e84			; random number generators 
0e84			 
0e84			 
0e84			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e84			 
0e84			 
0e84			;-----> Generate a random number 
0e84			; output a=answer 0<=a<=255 
0e84			; all registers are preserved except: af 
0e84			random: 
0e84 e5			        push    hl 
0e85 d5			        push    de 
0e86 2a dd fa		        ld      hl,(randData) 
0e89 ed 5f		        ld      a,r 
0e8b 57			        ld      d,a 
0e8c 5e			        ld      e,(hl) 
0e8d 19			        add     hl,de 
0e8e 85			        add     a,l 
0e8f ac			        xor     h 
0e90 22 dd fa		        ld      (randData),hl 
0e93 d1			        pop     de 
0e94 e1			        pop     hl 
0e95 c9			        ret 
0e96			 
0e96			 
0e96			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e96			 
0e96			 
0e96			 
0e96			;------LFSR------ 
0e96			;James Montelongo 
0e96			;optimized by Spencer Putt 
0e96			;out: 
0e96			; a = 8 bit random number 
0e96			RandLFSR: 
0e96 21 e3 fa		        ld hl,LFSRSeed+4 
0e99 5e			        ld e,(hl) 
0e9a 23			        inc hl 
0e9b 56			        ld d,(hl) 
0e9c 23			        inc hl 
0e9d 4e			        ld c,(hl) 
0e9e 23			        inc hl 
0e9f 7e			        ld a,(hl) 
0ea0 47			        ld b,a 
0ea1 cb 13		        rl e  
0ea3 cb 12			rl d 
0ea5 cb 11		        rl c  
0ea7 17				rla 
0ea8 cb 13		        rl e  
0eaa cb 12			rl d 
0eac cb 11		        rl c  
0eae 17				rla 
0eaf cb 13		        rl e  
0eb1 cb 12			rl d 
0eb3 cb 11		        rl c  
0eb5 17				rla 
0eb6 67			        ld h,a 
0eb7 cb 13		        rl e  
0eb9 cb 12			rl d 
0ebb cb 11		        rl c  
0ebd 17				rla 
0ebe a8			        xor b 
0ebf cb 13		        rl e  
0ec1 cb 12			rl d 
0ec3 ac			        xor h 
0ec4 a9			        xor c 
0ec5 aa			        xor d 
0ec6 21 e5 fa		        ld hl,LFSRSeed+6 
0ec9 11 e6 fa		        ld de,LFSRSeed+7 
0ecc 01 07 00		        ld bc,7 
0ecf ed b8		        lddr 
0ed1 12			        ld (de),a 
0ed2 c9			        ret 
0ed3			 
0ed3			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ed3			 
0ed3			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ed3			 
0ed3			 
0ed3			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ed3			 
0ed3			prng16: 
0ed3			;Inputs: 
0ed3			;   (seed1) contains a 16-bit seed value 
0ed3			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ed3			;Outputs: 
0ed3			;   HL is the result 
0ed3			;   BC is the result of the LCG, so not that great of quality 
0ed3			;   DE is preserved 
0ed3			;Destroys: 
0ed3			;   AF 
0ed3			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ed3			;160cc 
0ed3			;26 bytes 
0ed3 2a d7 fa		    ld hl,(seed1) 
0ed6 44			    ld b,h 
0ed7 4d			    ld c,l 
0ed8 29			    add hl,hl 
0ed9 29			    add hl,hl 
0eda 2c			    inc l 
0edb 09			    add hl,bc 
0edc 22 d7 fa		    ld (seed1),hl 
0edf 2a d5 fa		    ld hl,(seed2) 
0ee2 29			    add hl,hl 
0ee3 9f			    sbc a,a 
0ee4 e6 2d		    and %00101101 
0ee6 ad			    xor l 
0ee7 6f			    ld l,a 
0ee8 22 d5 fa		    ld (seed2),hl 
0eeb 09			    add hl,bc 
0eec c9			    ret 
0eed			 
0eed			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0eed			 
0eed			rand32: 
0eed			;Inputs: 
0eed			;   (seed1_0) holds the lower 16 bits of the first seed 
0eed			;   (seed1_1) holds the upper 16 bits of the first seed 
0eed			;   (seed2_0) holds the lower 16 bits of the second seed 
0eed			;   (seed2_1) holds the upper 16 bits of the second seed 
0eed			;   **NOTE: seed2 must be non-zero 
0eed			;Outputs: 
0eed			;   HL is the result 
0eed			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0eed			;Destroys: 
0eed			;   AF 
0eed			;Tested and passes all CAcert tests 
0eed			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0eed			;it has a period of 18,446,744,069,414,584,320 
0eed			;roughly 18.4 quintillion. 
0eed			;LFSR taps: 0,2,6,7  = 11000101 
0eed			;291cc 
0eed			;seed1_0=$+1 
0eed			;    ld hl,12345 
0eed			;seed1_1=$+1 
0eed			;    ld de,6789 
0eed			;    ld b,h 
0eed			;    ld c,l 
0eed			;    add hl,hl \ rl e \ rl d 
0eed			;    add hl,hl \ rl e \ rl d 
0eed			;    inc l 
0eed			;    add hl,bc 
0eed			;    ld (seed1_0),hl 
0eed			;    ld hl,(seed1_1) 
0eed			;    adc hl,de 
0eed			;    ld (seed1_1),hl 
0eed			;    ex de,hl 
0eed			;seed2_0=$+1 
0eed			;    ld hl,9876 
0eed			;seed2_1=$+1 
0eed			;    ld bc,54321 
0eed			;    add hl,hl \ rl c \ rl b 
0eed			;    ld (seed2_1),bc 
0eed			;    sbc a,a 
0eed			;    and %11000101 
0eed			;    xor l 
0eed			;    ld l,a 
0eed			;    ld (seed2_0),hl 
0eed			;    ex de,hl 
0eed			;    add hl,bc 
0eed			;    ret 
0eed			; 
0eed			 
0eed			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0eed			; 20 bytes, 86 cycles (excluding ret) 
0eed			 
0eed			; returns   hl = pseudorandom number 
0eed			; corrupts   a 
0eed			 
0eed			; generates 16-bit pseudorandom numbers with a period of 65535 
0eed			; using the xorshift method: 
0eed			 
0eed			; hl ^= hl << 7 
0eed			; hl ^= hl >> 9 
0eed			; hl ^= hl << 8 
0eed			 
0eed			; some alternative shift triplets which also perform well are: 
0eed			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0eed			 
0eed			;  org 32768 
0eed			 
0eed			xrnd: 
0eed 2a db fa		  ld hl,(xrandc)       ; seed must not be 0 
0ef0 3e 00		  ld a,0 
0ef2 bd			  cp l 
0ef3 20 02		  jr nz, .xrnd1 
0ef5 2e 01		  ld l, 1 
0ef7			.xrnd1: 
0ef7			 
0ef7 7c			  ld a,h 
0ef8 1f			  rra 
0ef9 7d			  ld a,l 
0efa 1f			  rra 
0efb ac			  xor h 
0efc 67			  ld h,a 
0efd 7d			  ld a,l 
0efe 1f			  rra 
0eff 7c			  ld a,h 
0f00 1f			  rra 
0f01 ad			  xor l 
0f02 6f			  ld l,a 
0f03 ac			  xor h 
0f04 67			  ld h,a 
0f05			 
0f05 22 db fa		  ld (xrandc),hl 
0f08			 
0f08 c9			  ret 
0f09			;  
0f09			 
0f09			 
0f09			;;;; int maths 
0f09			 
0f09			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f09			; Divide 16-bit values (with 16-bit result) 
0f09			; In: Divide BC by divider DE 
0f09			; Out: BC = result, HL = rest 
0f09			; 
0f09			Div16: 
0f09 21 00 00		    ld hl,0 
0f0c 78			    ld a,b 
0f0d 06 08		    ld b,8 
0f0f			Div16_Loop1: 
0f0f 17			    rla 
0f10 ed 6a		    adc hl,hl 
0f12 ed 52		    sbc hl,de 
0f14 30 01		    jr nc,Div16_NoAdd1 
0f16 19			    add hl,de 
0f17			Div16_NoAdd1: 
0f17 10 f6		    djnz Div16_Loop1 
0f19 17			    rla 
0f1a 2f			    cpl 
0f1b 47			    ld b,a 
0f1c 79			    ld a,c 
0f1d 48			    ld c,b 
0f1e 06 08		    ld b,8 
0f20			Div16_Loop2: 
0f20 17			    rla 
0f21 ed 6a		    adc hl,hl 
0f23 ed 52		    sbc hl,de 
0f25 30 01		    jr nc,Div16_NoAdd2 
0f27 19			    add hl,de 
0f28			Div16_NoAdd2: 
0f28 10 f6		    djnz Div16_Loop2 
0f2a 17			    rla 
0f2b 2f			    cpl 
0f2c 41			    ld b,c 
0f2d 4f			    ld c,a 
0f2e c9			ret 
0f2f			 
0f2f			 
0f2f			;http://z80-heaven.wikidot.com/math 
0f2f			; 
0f2f			;Inputs: 
0f2f			;     DE and A are factors 
0f2f			;Outputs: 
0f2f			;     A is not changed 
0f2f			;     B is 0 
0f2f			;     C is not changed 
0f2f			;     DE is not changed 
0f2f			;     HL is the product 
0f2f			;Time: 
0f2f			;     342+6x 
0f2f			; 
0f2f			Mult16: 
0f2f			 
0f2f 06 08		     ld b,8          ;7           7 
0f31 21 00 00		     ld hl,0         ;10         10 
0f34 29			       add hl,hl     ;11*8       88 
0f35 07			       rlca          ;4*8        32 
0f36 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f38 19			         add hl,de   ;--         -- 
0f39 10 f9		       djnz $-5      ;13*7+8     99 
0f3b c9			ret 
0f3c			 
0f3c			; 
0f3c			; Square root of 16-bit value 
0f3c			; In:  HL = value 
0f3c			; Out:  D = result (rounded down) 
0f3c			; 
0f3c			;Sqr16: 
0f3c			;    ld de,#0040 
0f3c			;    ld a,l 
0f3c			;    ld l,h 
0f3c			;    ld h,d 
0f3c			;    or a 
0f3c			;    ld b,8 
0f3c			;Sqr16_Loop: 
0f3c			;    sbc hl,de 
0f3c			;    jr nc,Sqr16_Skip 
0f3c			;    add hl,de 
0f3c			;Sqr16_Skip: 
0f3c			;    ccf 
0f3c			;    rl d 
0f3c			;    add a,a 
0f3c			;    adc hl,hl 
0f3c			;    add a,a 
0f3c			;    adc hl,hl 
0f3c			;    djnz Sqr16_Loop 
0f3c			;    ret 
0f3c			; 
0f3c			; 
0f3c			; Divide 8-bit values 
0f3c			; In: Divide E by divider C 
0f3c			; Out: A = result, B = rest 
0f3c			; 
0f3c			Div8: 
0f3c af			    xor a 
0f3d 06 08		    ld b,8 
0f3f			Div8_Loop: 
0f3f cb 13		    rl e 
0f41 17			    rla 
0f42 91			    sub c 
0f43 30 01		    jr nc,Div8_NoAdd 
0f45 81			    add a,c 
0f46			Div8_NoAdd: 
0f46 10 f7		    djnz Div8_Loop 
0f48 47			    ld b,a 
0f49 7b			    ld a,e 
0f4a 17			    rla 
0f4b 2f			    cpl 
0f4c c9			    ret 
0f4d			 
0f4d			; 
0f4d			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f4d			; In: Multiply A with DE 
0f4d			; Out: HL = result 
0f4d			; 
0f4d			Mult12U: 
0f4d 2e 00		    ld l,0 
0f4f 87			    add a,a 
0f50 30 01		    jr nc,Mult12U_NoAdd0 
0f52 19			    add hl,de 
0f53			Mult12U_NoAdd0: 
0f53 29			    add hl,hl 
0f54 87			    add a,a 
0f55 30 01		    jr nc,Mult12U_NoAdd1 
0f57 19			    add hl,de 
0f58			Mult12U_NoAdd1: 
0f58 29			    add hl,hl 
0f59 87			    add a,a 
0f5a 30 01		    jr nc,Mult12U_NoAdd2 
0f5c 19			    add hl,de 
0f5d			Mult12U_NoAdd2: 
0f5d 29			    add hl,hl 
0f5e 87			    add a,a 
0f5f 30 01		    jr nc,Mult12U_NoAdd3 
0f61 19			    add hl,de 
0f62			Mult12U_NoAdd3: 
0f62 29			    add hl,hl 
0f63 87			    add a,a 
0f64 30 01		    jr nc,Mult12U_NoAdd4 
0f66 19			    add hl,de 
0f67			Mult12U_NoAdd4: 
0f67 29			    add hl,hl 
0f68 87			    add a,a 
0f69 30 01		    jr nc,Mult12U_NoAdd5 
0f6b 19			    add hl,de 
0f6c			Mult12U_NoAdd5: 
0f6c 29			    add hl,hl 
0f6d 87			    add a,a 
0f6e 30 01		    jr nc,Mult12U_NoAdd6 
0f70 19			    add hl,de 
0f71			Mult12U_NoAdd6: 
0f71 29			    add hl,hl 
0f72 87			    add a,a 
0f73 d0			    ret nc 
0f74 19			    add hl,de 
0f75 c9			    ret 
0f76			 
0f76			; 
0f76			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f76			; In: Multiply A with DE 
0f76			;      Put lowest value in A for most efficient calculation 
0f76			; Out: HL = result 
0f76			; 
0f76			Mult12R: 
0f76 21 00 00		    ld hl,0 
0f79			Mult12R_Loop: 
0f79 cb 3f		    srl a 
0f7b 30 01		    jr nc,Mult12R_NoAdd 
0f7d 19			    add hl,de 
0f7e			Mult12R_NoAdd: 
0f7e cb 23		    sla e 
0f80 cb 12		    rl d 
0f82 b7			    or a 
0f83 c2 79 0f		    jp nz,Mult12R_Loop 
0f86 c9			    ret 
0f87			 
0f87			; 
0f87			; Multiply 16-bit values (with 32-bit result) 
0f87			; In: Multiply BC with DE 
0f87			; Out: BCHL = result 
0f87			; 
0f87			Mult32: 
0f87 79			    ld a,c 
0f88 48			    ld c,b 
0f89 21 00 00		    ld hl,0 
0f8c 06 10		    ld b,16 
0f8e			Mult32_Loop: 
0f8e 29			    add hl,hl 
0f8f 17			    rla 
0f90 cb 11		    rl c 
0f92 30 07		    jr nc,Mult32_NoAdd 
0f94 19			    add hl,de 
0f95 ce 00		    adc a,0 
0f97 d2 9b 0f		    jp nc,Mult32_NoAdd 
0f9a 0c			    inc c 
0f9b			Mult32_NoAdd: 
0f9b 10 f1		    djnz Mult32_Loop 
0f9d 41			    ld b,c 
0f9e 4f			    ld c,a 
0f9f c9			    ret 
0fa0			 
0fa0			 
0fa0			 
0fa0			; 
0fa0			; Multiply 8-bit values 
0fa0			; In:  Multiply H with E 
0fa0			; Out: HL = result 
0fa0			; 
0fa0			Mult8: 
0fa0 16 00		    ld d,0 
0fa2 6a			    ld l,d 
0fa3 06 08		    ld b,8 
0fa5			Mult8_Loop: 
0fa5 29			    add hl,hl 
0fa6 30 01		    jr nc,Mult8_NoAdd 
0fa8 19			    add hl,de 
0fa9			Mult8_NoAdd: 
0fa9 10 fa		    djnz Mult8_Loop 
0fab c9			    ret 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			;;http://z80-heaven.wikidot.com/math 
0fac			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fac			; 
0fac			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fac			;     ld a,16        ;7 
0fac			;     ld hl,0        ;10 
0fac			;     jp $+5         ;10 
0fac			;.DivLoop: 
0fac			;       add hl,bc    ;-- 
0fac			;       dec a        ;64 
0fac			;       jr z,.DivLoopEnd        ;86 
0fac			; 
0fac			;       sla e        ;128 
0fac			;       rl d         ;128 
0fac			;       adc hl,hl    ;240 
0fac			;       sbc hl,bc    ;240 
0fac			;       jr nc,.DivLoop ;23|21 
0fac			;       inc e        ;-- 
0fac			;       jp .DivLoop+1 
0fac			; 
0fac			;.DivLoopEnd: 
0fac			 
0fac			;HL_Div_C: 
0fac			;Inputs: 
0fac			;     HL is the numerator 
0fac			;     C is the denominator 
0fac			;Outputs: 
0fac			;     A is the remainder 
0fac			;     B is 0 
0fac			;     C is not changed 
0fac			;     DE is not changed 
0fac			;     HL is the quotient 
0fac			; 
0fac			;       ld b,16 
0fac			;       xor a 
0fac			;         add hl,hl 
0fac			;         rla 
0fac			;         cp c 
0fac			;         jr c,$+4 
0fac			;           inc l 
0fac			;           sub c 
0fac			;         djnz $-7 
0fac			 
0fac			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fac			 
0fac			addatohl: 
0fac 85			    add   a, l    ; A = A+L 
0fad 6f			    ld    l, a    ; L = A+L 
0fae 8c			    adc   a, h    ; A = A+L+H+carry 
0faf 95			    sub   l       ; A = H+carry 
0fb0 67			    ld    h, a    ; H = H+carry 
0fb1 c9			ret 
0fb2			 
0fb2			addatode: 
0fb2 83			    add   a, e    ; A = A+L 
0fb3 5f			    ld    e, a    ; L = A+L 
0fb4 8a			    adc   a, d    ; A = A+L+H+carry 
0fb5 93			    sub   e       ; A = H+carry 
0fb6 57			    ld    d, a    ; H = H+carry 
0fb7 c9			ret 
0fb8			 
0fb8			 
0fb8			addatobc: 
0fb8 81			    add   a, c    ; A = A+L 
0fb9 4f			    ld    c, a    ; L = A+L 
0fba 88			    adc   a, b    ; A = A+L+H+carry 
0fbb 91			    sub   c       ; A = H+carry 
0fbc 47			    ld    b, a    ; H = H+carry 
0fbd c9			ret 
0fbe			 
0fbe			subafromhl: 
0fbe			   ; If A=0 do nothing 
0fbe			    ; Otherwise flip A's sign. Since 
0fbe			    ; the upper byte becomes -1, also 
0fbe			    ; substract 1 from H. 
0fbe ed 44		    neg 
0fc0 ca c9 0f		    jp    z, Skip 
0fc3 25			    dec   h 
0fc4			     
0fc4			    ; Now add the low byte as usual 
0fc4			    ; Two's complement takes care of 
0fc4			    ; ensuring the result is correct 
0fc4 85			    add   a, l 
0fc5 6f			    ld    l, a 
0fc6 8c			    adc   a, h 
0fc7 95			    sub   l 
0fc8 67			    ld    h, a 
0fc9			Skip: 
0fc9 c9				ret 
0fca			 
0fca			 
0fca			; compare hl and de 
0fca			; returns:  
0fca			; if hl = de, z=1, s=0, c0=0 
0fca			; if hl > de, z=0, s=0, c=0 
0fca			; if hl < de, z=0, s=1, c=1 
0fca			cmp16:	 
0fca b7				or a 
0fcb ed 52			sbc hl,de 
0fcd e0				ret po 
0fce 7c				ld a,h 
0fcf 1f				rra 
0fd0 ee 40			xor 01000000B 
0fd2 37				scf 
0fd3 8f				adc a,a 
0fd4 c9				ret 
0fd5			 
0fd5			 
0fd5			; test if hl contains zero   - A is destroyed 
0fd5			 
0fd5			ishlzero:    
0fd5 b7				or a     ; reset flags 
0fd6 7c				ld a, h 
0fd7 b5				or l        	 
0fd8			 
0fd8 c9				ret 
0fd9			 
0fd9			 
0fd9			 
0fd9			 
0fd9			if FORTH_ENABLE_FLOATMATH 
0fd9			;include "float/bbcmath.z80" 
0fd9			include "float/lpfpcalc.asm" 
0fd9			endif 
0fd9			 
0fd9			 
0fd9			; eof 
0fd9			 
# End of file firmware_maths.asm
0fd9			include "firmware_strings.asm"   ; string handling  
0fd9			 
0fd9			 
0fd9			; TODO string len 
0fd9			; input text string, end on cr with zero term 
0fd9			; a offset into frame buffer to start prompt 
0fd9			; d is max length 
0fd9			; e is display size TODO 
0fd9			; c is current cursor position 
0fd9			; hl is ptr to where string will be stored and edited directly 
0fd9			 
0fd9			 
0fd9			; TODO check limit of buffer for new inserts 
0fd9			; TODO check insert does not push beyond buffer 
0fd9			; TODO scroll in a limited display area 
0fd9			; TODO scroll whole screen on page wrap 
0fd9			 
0fd9			 
0fd9			; TODO use LCD cursor? 
0fd9			 
0fd9			EDIT_V1: equ 0 
0fd9			EDIT_V2: equ 1 
0fd9			 
0fd9			 
0fd9			 
0fd9			if EDIT_V2 
0fd9			input_str: 
0fd9			 
0fd9 32 96 fd			    	ld (input_at_pos),a      ; save display position to start 
0fdc			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0fdc 22 99 fd				ld (input_start), hl     ; save ptr to buffer 
0fdf			;		ld a, c 
0fdf			;		call addatohl 
0fdf			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0fdf 7a					ld a,d 
0fe0 32 98 fd			        ld (input_size), a       ; save length of input area 
0fe3 79					ld a, c 
0fe4 32 87 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
0fe7 7b					ld a,e 
0fe8 32 97 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0feb			 
0feb			 
0feb					; add a trailing space to make screen refresh nicer 
0feb			 
0feb					;ld hl, (input_start) 
0feb					;push hl 
0feb					;ld a, 0 
0feb					;call strlent 
0feb					;ld a, l 
0feb					;pop hl 
0feb					;call addatohl 
0feb					;dec hl 
0feb					;ld a, ' ' 
0feb					;ld (hl), a 
0feb					;inc hl 
0feb					;ld (hl), a 
0feb					;inc hl 
0feb					;ld a, 0 
0feb					;ld (hl), a 
0feb			 
0feb			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0feb					; init cursor shape if not set by the cin routines 
0feb 21 f3 fa				ld hl, cursor_shape 
0fee			if BASE_KEV 
0fee			;		ld a, 255 
0fee 36 ff				ld (hl), 255 
0ff0			else 
0ff0					;ld a, '#' 
0ff0					ld (hl), '#' 
0ff0			endif 
0ff0 23					inc hl 
0ff1			;		ld a, 0 
0ff1 36 00				ld (hl), 0 
0ff3			 
0ff3 3e 09				ld a, CUR_BLINK_RATE 
0ff5 32 92 fd				ld (input_cur_flash), a 
0ff8 3e 01				ld a, 1 
0ffa 32 91 fd				ld (input_cur_onoff),a 
0ffd			.inmain:	 
0ffd			 
0ffd cd 1e 11				call input_disp_ref 
1000			 
1000					; save current length of string 
1000			 
1000 2a 99 fd				ld hl, (input_start) 
1003 3e 00				ld a, 0 
1005 cd 0f 13				call strlent 
1008 7d					ld a,l 
1009 32 8c fd				ld (input_len), a 
100c			 
100c					;call input_disp_oncur 
100c			 
100c					; display current state of input buffer 
100c			 
100c					; clean any backspace chars 
100c			 
100c 3e 20				ld a, " " 
100e 32 f3 f0				ld (scratch),a 
1011 3e 00				ld a, 0 
1013 32 f4 f0				ld (scratch+1),a 
1016 3a 96 fd				ld a,(input_at_pos) 
1019 85					add l 
101a 11 f3 f0				ld de, scratch 
101d cd 8e 0d				call str_at_display 
1020			 
1020					; pause 1ms 
1020			 
1020 3e 01				ld a, 1 
1022 cd a5 0c				call aDelayInMS 
1025			 
1025			; display cursor if visible on this cycle 
1025			 
1025					; dec flash counter 
1025 3a 92 fd				ld a, (input_cur_flash) 
1028 3d					dec a 
1029 32 92 fd				ld (input_cur_flash), a 
102c			;		cp 0 
102c b7					or a 
102d 20 0d				jr nz, .inochgstate 
102f			 
102f			 
102f					; reset on change of state 
102f 3e 09				ld a, CUR_BLINK_RATE 
1031 32 92 fd				ld (input_cur_flash), a 
1034			 
1034					; change state 
1034 3a 91 fd				ld a,(input_cur_onoff) 
1037 ed 44				neg 
1039 32 91 fd				ld (input_cur_onoff),a 
103c			 
103c			 
103c			 
103c			 
103c					; TODO is cursor visible? 
103c					; TODO if so then over write the char at curspos pos with the cursor shape 
103c			 
103c								 
103c			 
103c			.inochgstate: 
103c 3a 91 fd				ld a,(input_cur_onoff) 
103f fe ff				cp 255 
1041 28 0e				jr z, .skipcursor 
1043 3a 96 fd				ld a, (input_at_pos) 
1046 47					ld b, a 
1047 3a 87 fd				ld a, (input_cursor) 
104a 80					add b 
104b 11 f3 fa				ld de, cursor_shape 
104e					 
104e cd 8e 0d				call str_at_display 
1051			 
1051			.skipcursor: 
1051				if DEBUG_INPUTV2 
1051			 
1051					ld a,(input_at_pos) 
1051					ld hl, LFSRSeed 
1051					call hexout 
1051					ld a, (input_cursor) 
1051					ld hl, LFSRSeed+2 
1051					call hexout 
1051					ld a,(input_size) 
1051					ld hl, LFSRSeed+4 
1051					call hexout 
1051			 
1051					ld a,(input_cur_onoff) 
1051					ld hl, LFSRSeed+6 
1051					call hexout 
1051			 
1051					ld a,(input_cur_flash) 
1051					ld hl, LFSRSeed+8 
1051					call hexout 
1051			 
1051					ld a,(input_len) 
1051					ld hl, LFSRSeed+10 
1051					call hexout 
1051					ld hl, LFSRSeed+12 
1051			;		ld a, 0 
1051					ld (hl),0 
1051					ld a, display_row_4 
1051					ld de, LFSRSeed 
1051					call str_at_display 
1051				endif 
1051 cd 9e 0d				call update_display 
1054			 
1054					; TODO keyboard processing 
1054			 
1054			if BASE_CPM 
1054					call cin_wait 
1054			else 
1054 cd 4b 7a				call cin    ; _wait 
1057			endif 
1057			;		cp 0 
1057 b7					or a 
1058 ca fd 0f				jp z, .inmain 
105b			 
105b fe 0b				cp KEY_LEFT    ; cursor left 
105d ca 10 11				jp z, input_left 
1060				 
1060 fe 0c				cp KEY_RIGHT      ; cursor right 
1062 ca 17 11				jp z, input_right 
1065			 
1065 fe 0d				cp KEY_CR 
1067 c8					ret z 
1068			 
1068 fe 08				cp KEY_BS 
106a ca 82 11				jp z, input_delchar 
106d			 
106d fe 06				cp KEY_NEXTWORD 
106f ca 96 10				jp z, input_nxtword 
1072			 
1072 fe 07				cp KEY_PREVWORD 
1074 ca bb 10				jp z, input_prvword 
1077			 
1077 fe 0e				cp KEY_HOME    ; jump to start of line 
1079 20 08				jr nz, .ikh 
107b 3e 00				ld a, 0 
107d 32 87 fd				ld (input_cursor), a 
1080 ca fd 0f				jp z, .inmain 
1083			.ikh: 
1083			 
1083 fe 0f				cp KEY_END     ; jump to end of line 
1085 20 09				jr nz, .ike 
1087 3a 8c fd				ld a, (input_len) 
108a 32 87 fd				ld (input_cursor),a 
108d ca fd 0f				jp z, .inmain 
1090			.ike: 
1090 fe 05			        cp KEY_UP      ; recall last command 
1092 c8					ret z 
1093			;jr nz, .irec 
1093			; TODO next word 
1093			; TODO prev word 
1093			;  
1093			; 
1093			;	ld hl, scratch 
1093			;	ld de, os_last_cmd 
1093			;	call strcpy 
1093			;		jp  .inmain 
1093			.irec: 
1093			;		jr .instr1 
1093			 
1093			 
1093			 
1093					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
1093			 
1093			; TODO return if any special keys are given 
1093			;		ld l, a 
1093			;		ld a, 28 ; KEY_F12   ; 27 
1093			;		sub l 
1093			;		ret m 
1093			;		ld a, l 
1093					; if no special key then insert as a char 
1093			 
1093 c3 57 11				jp input_inschr 
1096			 
1096				 
1096			input_nxtword: 
1096				; jump to start next word after the cursor 
1096			 
1096			.insknwn:	 
1096 cd 4d 11				call input_curptr	 
1099 7e					ld a,(hl)	 
109a			;		cp 0 
109a b7					or a 
109b ca fd 0f				jp z, .inmain    ; end of string 
109e			 
109e			; if we are on a word, then move off of it 
109e			 
109e fe 20				cp ' ' 
10a0 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10a2 21 87 fd				ld hl, input_cursor 
10a5 34					inc (hl) 
10a6 18 ee				jr .insknwn 
10a8			 
10a8			.inspace: 
10a8			 
10a8 cd 4d 11				call input_curptr	 
10ab 7e					ld a,(hl)	 
10ac			;		cp 0 
10ac b7					or a 
10ad ca fd 0f				jp z, .inmain    ; end of string 
10b0			 
10b0			; if we are on a word, then move off of it 
10b0			 
10b0 fe 20				cp ' ' 
10b2 c2 fd 0f				jp nz, .inmain     ; we are on non space so at next word 
10b5 21 87 fd				ld hl, input_cursor 
10b8 34					inc (hl) 
10b9 18 ed				jr .inspace 
10bb			 
10bb			 
10bb			 
10bb			 
10bb			input_prvword: 
10bb				; jump to the start of previous word before the cursor 
10bb			 
10bb			; where are we to start with currently? 
10bb			 
10bb cd 4d 11				call input_curptr	 
10be 7e					ld a, (hl) 
10bf fe 20				cp ' ' 
10c1 28 1c				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10c3			 
10c3			 
10c3			 
10c3			.inskpwn:	 
10c3 3a 87 fd				ld a,(input_cursor) 
10c6			;		cp 0 
10c6 b7					or a 
10c7 ca fd 0f				jp z, .inmain    ; start of string 
10ca			 
10ca			;if we are on a word, then move off of it 
10ca			 
10ca cd 4d 11				call input_curptr	 
10cd 7e					ld a, (hl) 
10ce fe 20				cp ' ' 
10d0 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
10d2					;jp z, .inmain    ; start of string 
10d2 21 87 fd				ld hl, input_cursor 
10d5 35					dec (hl) 
10d6 18 eb				jr .inskpwn 
10d8			.iwstart: 
10d8 21 87 fd				ld hl, input_cursor 
10db 34					inc (hl) 
10dc c3 fd 0f				jp .inmain 
10df					 
10df			 
10df			.inspacep: 
10df			 
10df					;jp .inmain    ; start of string 
10df			 
10df			 
10df			 
10df 3a 87 fd				ld a,(input_cursor) 
10e2			;		cp 0 
10e2 b7					or a 
10e3 ca fd 0f				jp z, .inmain    ; start of string 
10e6			 
10e6			; if we are on a word, then move off of it 
10e6			 
10e6 cd 4d 11				call input_curptr	 
10e9 7e					ld a, (hl) 
10ea fe 20				cp ' ' 
10ec c2 f5 10				jp nz, .incharp     ; we are on non space so at end of prev word 
10ef 21 87 fd				ld hl, input_cursor 
10f2 35					dec (hl) 
10f3 18 ea				jr .inspacep 
10f5			 
10f5			 
10f5			.incharp:	 
10f5					; eat the word to get to the start 
10f5 3a 87 fd				ld a,(input_cursor) 
10f8			;		cp 0 
10f8 b7					or a 
10f9 ca fd 0f				jp z, .inmain    ; start of string 
10fc			 
10fc			; if we are on a word, then move off of it 
10fc			 
10fc cd 4d 11				call input_curptr	 
10ff 7e					ld a, (hl) 
1100 fe 20				cp ' ' 
1102 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
1104 21 87 fd				ld hl, input_cursor 
1107 35					dec (hl) 
1108 18 eb				jr .incharp 
110a			.ipwordst: 
110a					; at space before the prev word so reposition over it 
110a 21 87 fd				ld hl, input_cursor 
110d 34					inc (hl) 
110e 18 b3				jr .inskpwn 
1110					 
1110			 
1110			 
1110			input_left: 
1110				; move cursor left 
1110 21 87 fd			ld hl, input_cursor 
1113 35				dec (hl) 
1114			;	cp 0 
1114			;	jp z, .inmain    ; ignore left as at the start of the string 
1114 c3 fd 0f			jp .inmain 
1117			 
1117			input_right: 
1117				; move cursor right 
1117				 
1117				;ld a, (input_size) 
1117				;ld b, a 
1117 21 87 fd			ld hl, input_cursor 
111a 34				inc (hl) 
111b				;dec b 
111b				;cp 0 
111b				;jp z, .inmain   ; ignore as at end of the string buffer 
111b				;ld a, b 
111b				;inc a 
111b				;ld (input_cursor), a 
111b c3 fd 0f			jp .inmain 
111e			 
111e			 
111e			 
111e			input_disp_ref: 
111e				; display the text from start of buffer (ie full refresh) 
111e 3a 96 fd			ld a, (input_at_pos) 
1121 2a 99 fd			ld hl,(input_start) 
1124 eb				ex de, hl 
1125 cd 8e 0d			call str_at_display  
1128 c9				ret 
1129			input_disp_oncur: 
1129				; display the text from cursor position to end of buffer 
1129				; TODO position start of string at cursor position on screen 
1129				; TODO draw from that point on 
1129 3a 87 fd			ld a, (input_cursor) 
112c 47				ld b, a 
112d 3a 96 fd			ld a, (input_at_pos) 
1130 80				add b 
1131 48				ld c, b     ; save a 
1132 78				ld a, b     ; inc string start for cursor 
1133 2a 99 fd			ld hl,(input_start) 
1136 cd ac 0f			call addatohl 
1139 eb				ex de, hl 
113a 79				ld a, c 
113b cd 8e 0d			call str_at_display  
113e c9				ret 
113f			 
113f			input_nxtw: 
113f				; Find next word 
113f c9				ret 
1140			 
1140			input_prvw: 
1140				; Find previous word 
1140 c9				ret 
1141			 
1141			input_lenrem:   
1141				; Calculate the length of string remaining from current cursor 
1141				; position to end of buffer (exc null term) 
1141				 
1141 3a 87 fd			ld a, (input_cursor) 
1144 4f				ld c, a 
1145 3a 98 fd			ld a, (input_size) 
1148 91				sub c 
1149 06 00			ld b, 0 
114b 0d				dec c 
114c c9				ret	 
114d			 
114d			input_curptr: 
114d				; calc address of the character under the cursor 
114d				 
114d 2a 99 fd			ld hl, (input_start) 
1150 3a 87 fd			ld a, (input_cursor) 
1153 cd ac 0f			call addatohl 
1156 c9				ret 
1157			 
1157			input_inschr: 
1157				; Insert char at cursor position 
1157 f5				push af   ; save char 
1158				;call input_lenrem    ; get bc length of remaining string 
1158			 
1158				 
1158 cd 4d 11			call input_curptr 
115b			;	ld hl, (input_start) 
115b			;	ld a, (input_cursor) 
115b			;	call addatohl 
115b				;push hl   ; save to come back to 
115b			 
115b				; shift everything up one to end of buffer 
115b			 
115b				;push hl 
115b				;dec de 
115b				;inc de 
115b			;	ldir 
115b				 
115b				;pop hl 
115b			 
115b				; are we adding to the end of line? 
115b			 
115b 3a 87 fd			ld a, (input_cursor) 
115e 47				ld b, a 
115f 3a 8c fd			ld a, (input_len) 
1162 b8				cp b 
1163 20 08			jr nz, .insmid   ; no, insert in middle of text 
1165			 
1165				; tack on the end of the line 
1165 f1				pop af 
1166 77				ld (hl), a   ; save new char 
1167 23				inc hl 
1168			;	ld a, 0 
1168 36 00			ld (hl), 0 
116a c3 17 11			jp input_right 
116d				 
116d			.insmid: 
116d				; hl has insertion point so move everything up one to allow for insertion 
116d				;call input_shiftright 
116d f1				pop af 
116e			 
116e			.shufinsmid: 
116e 47				ld b, a     ; b contains new char, c prev char at this position  
116f 7e				ld a, (hl) 
1170			 
1170			;	cp 0    ; at end of string need to then dump new char and add term 
1170 b7				or a 
1171 28 07			jr z, .endinsmid 
1173 4f				ld c, a 
1174 78				ld a, b 
1175 77				ld (hl), a 
1176 23				inc hl 
1177 79				ld a, c 
1178 18 f4			jr .shufinsmid 
117a				 
117a			 
117a			 
117a			 
117a			.endinsmid: 
117a 78				ld a, b 
117b 77				ld (hl), a 
117c 23				inc hl 
117d			;	ld a, 0 
117d 36 00			ld (hl), 0 
117f			 
117f			 
117f			;	ld (hl), a   ; save new char 
117f			 
117f c3 17 11			jp input_right 
1182			 
1182			;input_shiftright: 
1182			;	; shift text right at cursor, hl has shift start 
1182			;	push hl 
1182			;	push de 
1182			;	push bc 
1182			; 
1182			; 
1182			;	; move to end of string past zero term 
1182			;	ld hl,(input_start) 
1182			;	ld a, (input_len) 
1182			;	call addatohl 
1182			;	inc hl 
1182			;;	inc hl 
1182			;;	inc hl 
1182			;	ld a, 0 
1182			;	ld (hl), a 
1182			;;	dec hl 
1182			;	 
1182			;;	ld (hl), a 
1182			;;	dec hl 
1182			; 
1182			;	push hl 
1182			;	pop de 
1182			;	inc de 
1182			;	 
1182			; 
1182			;;	ld hl,(input_start) 
1182			;;	ld a, (input_cursor) 
1182			;;	call addatohl 
1182			; 
1182			; 
1182			;	; calc how many bytes from cursor pos to end of string we need to shift 
1182			;	call input_lenrem    ; get bc length of remaining string 
1182			;	;ld a, (input_cursor) 
1182			;	;ld c, a 
1182			;	ld a, (input_len) 
1182			;	cp 2 
1182			;	jr z, .iskipzero	 
1182			;	;sub c 
1182			;	;inc a 
1182			;	;ld c, a 
1182			;	;ld b, 0 
1182			;	inc c 
1182			;	inc c 
1182			;	; move data 
1182			;	lddr 
1182			;.iskipzero: 
1182			; 
1182			;	pop bc 
1182			;	pop de 
1182			;	pop hl 
1182			;	ret	 
1182			 
1182			input_delchar: 
1182				; Delete char at cursor position 
1182 cd 41 11			call input_lenrem    ; get bc length of remaining string 
1185 2a 99 fd			ld hl, (input_start) 
1188 3a 87 fd			ld a, (input_cursor) 
118b cd ac 0f			call addatohl 
118e			 
118e e5				push hl 
118f d1				pop de 
1190 1b				dec de 
1191			 
1191			.dl:	 
1191 ed a0			ldi  
1193 7e				ld a, (hl) 
1194			;	cp 0 
1194 b7				or a 
1195 28 02			jr z, .dldone 
1197 18 f8			jr .dl 
1199			.dldone: 
1199 ed a0			ldi 
119b			 
119b c3 10 11			jp input_left 
119e			 
119e			 
119e			endif 
119e			 
119e			 
119e			 
119e			if EDIT_V1 
119e			input_str: 
119e			 
119e				    	ld (input_at_pos),a      ; save display position to start 
119e					add c 
119e					ld (input_at_cursor),a	; save draw pos of cursor 
119e					ld (input_start), hl     ; save ptr to buffer 
119e					ld a, c 
119e					call addatohl 
119e					ld (input_ptr), hl     ; save ptr to point under the cursor 
119e					ld a,d 
119e				        ld (input_size), a       ; save length of input area 
119e					ld a, c 
119e					ld (input_cursor),a      ; init cursor start position  
119e					ld a,e 
119e				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
119e					 
119e					 
119e			 
119e			;		ld a,(input_ptr) 
119e			;		ld (input_under_cursor),a 	; save what is under the cursor 
119e			 
119e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
119e					; init cursor shape if not set by the cin routines 
119e					ld hl, cursor_shape 
119e			if BASE_KEV 
119e					ld a, 255 
119e			else 
119e					ld a, '#' 
119e			endif 
119e					ld (hl), a 
119e					inc hl 
119e					ld a, 0 
119e					ld (hl), a 
119e			 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e					ld a, 1 
119e					ld (input_cur_onoff),a 
119e			 
119e			;	if DEBUG_INPUT 
119e			;		push af 
119e			;		ld a, 'I' 
119e			;		ld (debug_mark),a 
119e			;		pop af 
119e			;		CALLMONITOR 
119e			;	endif 
119e			.is1:		; main entry loop 
119e			 
119e			 
119e			 
119e					; pause 1ms 
119e			 
119e					ld a, 1 
119e					call aDelayInMS 
119e			 
119e					; dec flash counter 
119e					ld a, (input_cur_flash) 
119e					dec a 
119e					ld (input_cur_flash), a 
119e			;		cp 0 
119e					or a 
119e					jr nz, .nochgstate 
119e			 
119e			 
119e					; change state 
119e					ld a,(input_cur_onoff) 
119e					neg 
119e					ld (input_cur_onoff),a 
119e			 
119e			 
119e					; reset on change of state 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e			 
119e			.nochgstate: 
119e					 
119e					 
119e			 
119e					; display cursor  
119e			 
119e			;		ld hl, (input_start) 
119e			;		ld a, (input_cursor) 
119e			;		call addatohl 
119e			 
119e					; get char under cursor and replace with cursor 
119e			ld hl, (input_ptr) 
119e			;		ld a, (hl) 
119e			;		ld (input_under_cursor),a 
119e			;		ld a, '_' 
119e			;		ld (hl), a 
119e			 
119e					; display string 
119e			 
119e					ld de, (input_start) 
119e					ld a, (input_at_pos) 
119e					call str_at_display 
119e			;	        call update_display 
119e			 
119e					; find place to put the cursor 
119e			;		add h 
119e			;		ld l, display_row_1 
119e			;		sub l 
119e			; (input_at_pos) 
119e					;ld c, a 
119e			;		ld a, (input_cursor) 
119e			;		ld l, (input_at_pos) 
119e			;		;ld b, h 
119e			;		add l 
119e			;		ld (input_at_cursor),a 
119e					;ld l,h 
119e			 
119e			;		ld h, 0 
119e			;		ld l,(input_at_pos) 
119e			;		ld a, (input_cursor) 
119e			;		call addatohl 
119e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
119e			;		call subafromhl 
119e			;		ld a,l 
119e			;		ld (input_at_cursor), a 
119e			 
119e				if DEBUG_INPUT 
119e					ld a, (hardware_diag) 
119e			;		cp 0 
119e					or a 
119e					jr z, .skip_input_diag 
119e			 
119e					ld a,(input_at_pos) 
119e					ld hl, LFSRSeed 
119e					call hexout 
119e					ld a, (input_cursor) 
119e					ld hl, LFSRSeed+2 
119e					call hexout 
119e					ld a,(input_at_cursor) 
119e					ld hl, LFSRSeed+4 
119e					call hexout 
119e			 
119e					ld a,(input_cur_onoff) 
119e					ld hl, LFSRSeed+6 
119e					call hexout 
119e			 
119e					ld a,(input_cur_flash) 
119e					ld hl, LFSRSeed+8 
119e					call hexout 
119e			 
119e					ld a,(input_len) 
119e					ld hl, LFSRSeed+10 
119e					call hexout 
119e					ld hl, LFSRSeed+12 
119e					ld a, 0 
119e					ld (hl),a 
119e					ld a, display_row_4 
119e					ld de, LFSRSeed 
119e					call str_at_display 
119e					.skip_input_diag: 
119e				endif 
119e			 
119e					; decide on if we are showing the cursor this time round 
119e			 
119e					ld a, (input_cur_onoff) 
119e					cp 255 
119e					jr z, .skipcur 
119e			 
119e			 
119e					ld a,(input_at_cursor) 
119e					ld de, cursor_shape 
119e					call str_at_display 
119e			 
119e					; save length of current input string 
119e					ld hl, (input_start) 
119e					ld a, 0 
119e					call strlent 
119e					ld a,l 
119e					ld (input_len),a 
119e			 
119e			.skipcur: 
119e			 
119e				        call update_display 
119e					 
119e			 
119e			 
119e					; wait 
119e				 
119e					; TODO loop without wait to flash the cursor and char under cursor	 
119e					call cin    ; _wait 
119e			 
119e			;		cp 0 
119e					or a 
119e					jp z, .is1 
119e			 
119e					; get ptr to char to input into 
119e			 
119e					ld c,a 
119e					ld hl, (input_start) 
119e					ld a, (input_cursor) 
119e					call addatohl 
119e					ld (input_ptr), hl 
119e					ld a,c 
119e			 
119e					; replace char under cursor 
119e			 
119e			;		ld hl, (input_ptr) 
119e			;		ld a, (input_under_cursor) 	; get what is under the cursor 
119e			;		ld (hl), a 
119e			 
119e			;	if DEBUG_INPUT 
119e			;		push af 
119e			;		ld a, 'i' 
119e			;		ld (debug_mark),a 
119e			;		pop af 
119e			;		CALLMONITOR 
119e			;	endif 
119e					cp KEY_HOME 
119e					jr nz, .iske 
119e			 
119e					ld a, (input_at_pos) 
119e					ld (input_at_cursor),a 
119e					ld a, 0 
119e					ld (input_cursor), a 
119e					jp .is1 
119e					 
119e			.iske:		cp KEY_END 
119e					jr nz, .isknw 
119e					jp .is1 
119e			 
119e			.isknw:		cp KEY_NEXTWORD 
119e					jr nz, .iskpw 
119e			 
119e			.isknwm:	ld hl, (input_ptr) 
119e					ld a,(hl)	 
119e			;		cp 0 
119e					or a 
119e					jp z, .is1    ; end of string 
119e					cp ' ' 
119e					jp z, .is1    ; end of word 
119e					inc hl 
119e					ld (input_ptr), hl 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld (input_at_cursor), a 
119e					jr .isknwm 
119e			 
119e			.iskpw:		cp KEY_PREVWORD 
119e					jr nz, .iskl 
119e			.iskpwm:	 
119e					ld hl, (input_ptr) 
119e					ld a,(hl)	 
119e			;		cp 0  
119e					or a 
119e					jp z, .is1    ; end of string 
119e					cp ' ' 
119e					jp z, .is1    ; end of word 
119e					dec hl 
119e					ld (input_ptr), hl 
119e					ld a, (input_at_cursor) 
119e					dec a 
119e					ld (input_at_cursor), a 
119e					jr .iskpwm 
119e			 
119e			 
119e			.iskl:		cp KEY_LEFT 
119e					jr nz, .isk1 
119e			 
119e					ld a, (input_cursor) 
119e			 
119e			;		cp 0 
119e					or a 
119e					jp z, .is1 		; at start of line to ignore  
119e			 
119e					dec  a 		; TODO check underflow 
119e					ld (input_cursor), a 
119e			 
119e					ld hl, (input_ptr) 
119e					dec hl 
119e					ld (input_ptr), hl 
119e					 
119e					ld a, (input_at_cursor) 
119e					dec a 
119e					ld (input_at_cursor), a 
119e			 
119e					ld a, 1		; show cursor moving 
119e					ld (input_cur_onoff),a 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e			 
119e					jp .is1 
119e			 
119e			.isk1:		cp KEY_RIGHT 
119e					jr nz, .isk2 
119e			 
119e					ld a,(input_len)		; TODO BUG why cant i load e direct? 
119e					ld e,a 
119e					ld a, (input_cursor) 
119e					cp e 
119e					jp z, .is1		; at the end of string so dont go right 
119e			 
119e					inc  a 		; TODO check overflow 
119e					ld (input_cursor), a 
119e			 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld (input_at_cursor), a 
119e			 
119e					ld hl, (input_ptr) 
119e					inc hl 
119e					ld (input_ptr), hl 
119e			 
119e					ld a, 1		; show cursor moving 
119e					ld (input_cur_onoff),a 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e			 
119e					jp .is1 
119e			 
119e			.isk2:		cp KEY_UP 
119e			 
119e					jr nz, .isk3 
119e			 
119e					; swap last command with the current on 
119e			 
119e					; move cursor to start of string 
119e					ld hl, (input_start) 
119e					ld (input_ptr), hl 
119e			 
119e					ld a, (input_at_pos) 
119e					ld (input_at_cursor), a 
119e			 
119e					ld a, 0 
119e					ld (input_cursor), a 
119e					 
119e					; swap input and last command buffers 
119e			 
119e					ld hl, os_cli_cmd 
119e					ld de, os_last_cmd 
119e					ld b, 255 
119e			.swap1:		ld a, (hl) 
119e					ld c,a 
119e					ld a, (de) 
119e					ld (hl), a 
119e					ld a,c 
119e					ld (de),a 
119e					inc hl 
119e					inc de 
119e					djnz .swap1 
119e			 
119e			 
119e			 
119e			 
119e			 
119e					jp .is1 
119e			 
119e			.isk3:		cp KEY_BS 
119e					jr nz, .isk4 
119e			 
119e					ld a, (input_cursor) 
119e			 
119e			;		cp 0 
119e					or a 
119e					jp z, .is1 		; at start of line to ignore  
119e			 
119e					dec  a 		; TODO check underflow 
119e					ld (input_cursor), a 
119e			 
119e					; hl is source 
119e					; de needs to be source - 1 
119e			 
119e			;		ld a, 0 
119e			;		dec hl 
119e			;		ld (hl), a 
119e			 
119e					ld hl, (input_ptr) 
119e					dec hl 
119e					ld (input_ptr), hl 
119e			 
119e					; shift all data 
119e			 
119e					push hl 
119e					inc hl 
119e					pop de 
119e					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
119e					ld c,a 
119e					ld b,0 
119e					ldir  
119e			 
119e			 
119e			 
119e			 
119e					ld a, (input_at_cursor) 
119e					dec a 
119e					ld (input_at_cursor), a 
119e			 
119e			 
119e					ld a, 1		; show cursor moving 
119e					ld (input_cur_onoff),a 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e			 
119e					; remove char 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld de,.iblank 
119e					call str_at_display 
119e			 
119e					jp .is1 
119e			 
119e			.isk4:		cp KEY_CR 
119e					jr z, .endinput 
119e			 
119e					; else add the key press to the end 
119e			 
119e					ld c, a			; save key pressed 
119e			 
119e					ld a,(hl)		; get what is currently under char 
119e			 
119e			;		cp 0			; we are at the end of the string 
119e					or a 
119e					jr nz, .onchar 
119e					 
119e					; add a char to the end of the string 
119e				 
119e					ld (hl),c 
119e					inc hl 
119e			;		ld a,' ' 
119e			;		ld (hl),a 
119e			;		inc hl 
119e					ld a,0 
119e					ld (hl),a 
119e					dec hl 
119e			 
119e					ld a, (input_cursor) 
119e					inc a				; TODO check max string length and scroll  
119e					ld (input_cursor), a		; inc cursor pos 
119e							 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld (input_at_cursor), a 
119e			 
119e					ld hl, (input_ptr) 
119e					inc hl 
119e					ld (input_ptr), hl 
119e			 
119e					ld hl, (input_ptr) 
119e					inc hl 
119e					ld (input_ptr), hl 
119e			;	if DEBUG_INPUT 
119e			;		push af 
119e			;		ld a, '+' 
119e			;		ld (debug_mark),a 
119e			;		pop af 
119e			;		CALLMONITOR 
119e			;	endif 
119e					ld a, 1		; show cursor moving 
119e					ld (input_cur_onoff),a 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e					jp .is1 
119e					 
119e			 
119e			 
119e					; if on a char then insert 
119e			.onchar: 
119e			 
119e					; TODO over flow check: make sure insert does not blow out buffer 
119e			 
119e					; need to do some maths to use lddr 
119e			 
119e					push hl   ; save char pos 
119e					push bc 
119e			 
119e					ld hl, (input_start) 
119e					ld a, (input_len) 
119e					call addatohl  		; end of string 
119e					inc hl 
119e					inc hl		; past zero term 
119e					push hl 
119e					inc hl 
119e					push hl  
119e			 
119e								; start and end of lddr set, now how much to move? 
119e			 
119e							 
119e					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
119e					ld b,a 
119e					ld a,(input_len) 
119e					ld e,a 
119e					sub b 
119e					inc a		;?? 
119e					inc a		;?? 
119e					inc a		;?? 
119e			 
119e					ld b,0 
119e					ld c,a 
119e			 
119e				if DEBUG_INPUT 
119e					push af 
119e					ld a, 'i' 
119e					ld (debug_mark),a 
119e					pop af 
119e			;		CALLMONITOR 
119e				endif 
119e					pop de 
119e					pop hl 
119e				if DEBUG_INPUT 
119e					push af 
119e					ld a, 'I' 
119e					ld (debug_mark),a 
119e					pop af 
119e			;		CALLMONITOR 
119e				endif 
119e					lddr 
119e				 
119e			 
119e			 
119e					; TODO have a key for insert/overwrite mode???? 
119e					pop bc 
119e					pop hl 
119e					ld (hl), c		; otherwise overwrite current char 
119e					 
119e			 
119e			 
119e			 
119e					ld a, (input_cursor) 
119e					inc  a 		; TODO check overflow 
119e					ld (input_cursor), a 
119e			 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld (input_at_cursor), a 
119e			 
119e					jp .is1 
119e			 
119e			.endinput:	; TODO look for end of string 
119e			 
119e					; add trailing space for end of token 
119e			 
119e					ld hl, (input_start) 
119e					ld a,(input_len) 
119e					call addatohl 
119e					ld a, ' ' 
119e					ld (hl),a 
119e					; TODO eof of parse marker 
119e			 
119e					inc hl 
119e					ld a, 0 
119e					ld (hl),a 
119e			 
119e			 
119e					ret 
119e			 
119e			.iblank: db " ",0 
119e			 
119e			 
119e			input_str_prev:	ld (input_at_pos), a 
119e					ld (input_start), hl 
119e					ld a,1			; add cursor 
119e					ld (hl),a 
119e					inc hl 
119e					ld a,0 
119e					ld (hl),a 
119e					ld (input_ptr), hl 
119e					ld a,d 
119e					ld (input_size), a 
119e					ld a,0 
119e					ld (input_cursor),a 
119e			.instr1:	 
119e			 
119e					; TODO do block cursor 
119e					; TODO switch cursor depending on the modifer key 
119e			 
119e					; update cursor shape change on key hold 
119e			 
119e					ld hl, (input_ptr) 
119e					dec hl 
119e					ld a,(cursor_shape) 
119e					ld (hl), a 
119e			 
119e					; display entered text 
119e					ld a,(input_at_pos) 
119e			            	CALL fLCD_Pos       ;Position cursor to location in A 
119e			            	LD   de, (input_start) 
119e			            	CALL fLCD_Str       ;Display string pointed to by DE 
119e			 
119e					call cin 
119e			;		cp 0 
119e					or a 
119e					jr z, .instr1 
119e			 
119e					; proecess keyboard controls first 
119e			 
119e					ld hl,(input_ptr) 
119e			 
119e					cp KEY_CR	 ; pressing enter ends input 
119e					jr z, .instrcr 
119e			 
119e					cp KEY_BS 	; back space 
119e					jr nz, .instr2 
119e					; process back space 
119e			 
119e					; TODO stop back space if at start of string 
119e					dec hl 
119e					dec hl ; to over write cursor 
119e					ld a,(cursor_shape) 
119e					;ld a,0 
119e					ld (hl),a 
119e					inc hl 
119e					ld a," " 
119e					ld (hl),a 
119e					ld (input_ptr),hl 
119e					 
119e			 
119e					jr .instr1 
119e			 
119e			.instr2:	cp KEY_LEFT    ; cursor left 
119e					jr nz, .instr3 
119e					dec hl 
119e					ld (input_ptr),hl 
119e					jr .instr1 
119e				 
119e			.instr3:	cp KEY_RIGHT      ; cursor right 
119e					jr nz, .instr4 
119e					inc hl 
119e					ld (input_ptr),hl 
119e					jr .instr1 
119e			 
119e			.instr4:	cp KEY_HOME    ; jump to start of line 
119e					jr nz, .instr5 
119e					dec hl 
119e					ld (input_ptr),hl 
119e					jr .instr1 
119e			 
119e			.instr5:	cp KEY_END     ; jump to end of line 
119e					jr nz, .instr6 
119e					dec hl 
119e					ld (input_ptr),hl 
119e					jr .instr1 
119e			.instr6:        cp KEY_UP      ; recall last command 
119e					jr nz, .instrnew 
119e			 
119e				ld hl, scratch 
119e				ld de, os_last_cmd 
119e				call strcpy 
119e					jr .instr1 
119e			 
119e			 
119e			.instrnew:	; no special key pressed to see if we have room to store it 
119e			 
119e					; TODO do string size test 
119e			 
119e					dec hl ; to over write cursor 
119e					ld (hl),a 
119e					inc hl 
119e					ld a,(cursor_shape) 
119e					ld (hl),a 
119e					inc hl 
119e					ld a,0 
119e					ld (hl),a 
119e			 
119e					ld (input_ptr),hl 
119e					 
119e					jr .instr1 
119e			.instrcr:	dec hl		; remove cursor 
119e					ld a,' '	; TODO add a trailing space for safety 
119e					ld (hl),a 
119e					inc hl 
119e					ld a,0 
119e					ld (hl),a 
119e			 
119e			 
119e					; if at end of line scroll up    
119e					; TODO detecting only end of line 4 for scroll up  
119e			 
119e					;ld   
119e			 
119e					ret 
119e			 
119e			 
119e			endif 
119e			; strcpy hl = dest, de source 
119e			 
119e 1a			strcpy:   LD   A, (DE)        ;Get character from string 
119f b7			            OR   A              ;Null terminator? 
11a0 c8			            RET  Z              ;Yes, so finished 
11a1 1a					ld a,(de) 
11a2 77					ld (hl),a 
11a3 13			            INC  DE             ;Point to next character 
11a4 23					inc hl 
11a5 18 f7		            JR   strcpy       ;Repeat 
11a7 c9					ret 
11a8			 
11a8			 
11a8			; TODO string_at  
11a8			; pass string which starts with lcd offset address and then null term string 
11a8			 
11a8			; TODO string to dec 
11a8			; TODO string to hex 
11a8			; TODO byte to string hex 
11a8			; TODO byte to string dec 
11a8			 
11a8			 
11a8			 
11a8			; from z80uartmonitor 
11a8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11a8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11a8			; pass hl for where to put the text 
11a8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11a8 c5			hexout:	PUSH BC 
11a9 f5					PUSH AF 
11aa 47					LD B, A 
11ab					; Upper nybble 
11ab cb 3f				SRL A 
11ad cb 3f				SRL A 
11af cb 3f				SRL A 
11b1 cb 3f				SRL A 
11b3 cd c3 11				CALL tohex 
11b6 77					ld (hl),a 
11b7 23					inc hl	 
11b8					 
11b8					; Lower nybble 
11b8 78					LD A, B 
11b9 e6 0f				AND 0FH 
11bb cd c3 11				CALL tohex 
11be 77					ld (hl),a 
11bf 23					inc hl	 
11c0					 
11c0 f1					POP AF 
11c1 c1					POP BC 
11c2 c9					RET 
11c3					 
11c3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11c3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
11c3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11c3			tohex: 
11c3 e5					PUSH HL 
11c4 d5					PUSH DE 
11c5 16 00				LD D, 0 
11c7 5f					LD E, A 
11c8 21 d0 11				LD HL, .DATA 
11cb 19					ADD HL, DE 
11cc 7e					LD A, (HL) 
11cd d1					POP DE 
11ce e1					POP HL 
11cf c9					RET 
11d0			 
11d0			.DATA: 
11d0 30					DEFB	30h	; 0 
11d1 31					DEFB	31h	; 1 
11d2 32					DEFB	32h	; 2 
11d3 33					DEFB	33h	; 3 
11d4 34					DEFB	34h	; 4 
11d5 35					DEFB	35h	; 5 
11d6 36					DEFB	36h	; 6 
11d7 37					DEFB	37h	; 7 
11d8 38					DEFB	38h	; 8 
11d9 39					DEFB	39h	; 9 
11da 41					DEFB	41h	; A 
11db 42					DEFB	42h	; B 
11dc 43					DEFB	43h	; C 
11dd 44					DEFB	44h	; D 
11de 45					DEFB	45h	; E 
11df 46					DEFB	46h	; F 
11e0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
11e0			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
11e0			;;    subtract $30, if result > 9 then subtract $7 more 
11e0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
11e0			atohex: 
11e0 d6 30				SUB $30 
11e2 fe 0a				CP 10 
11e4 f8					RET M		; If result negative it was 0-9 so we're done 
11e5 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
11e7 c9					RET		 
11e8			 
11e8			 
11e8			 
11e8			 
11e8			; Get 2 ASCII characters as hex byte from pointer in hl 
11e8			 
11e8			BYTERD: 
11e8 16 00			LD	D,00h		;Set up 
11ea cd f2 11			CALL	HEXCON		;Get byte and convert to hex 
11ed 87				ADD	A,A		;First nibble so 
11ee 87				ADD	A,A		;multiply by 16 
11ef 87				ADD	A,A		; 
11f0 87				ADD	A,A		; 
11f1 57				LD	D,A		;Save hi nibble in D 
11f2			HEXCON: 
11f2 7e				ld a, (hl)		;Get next chr 
11f3 23				inc hl 
11f4 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
11f6 fe 0a			CP	00Ah		;Is it 0-9 ? 
11f8 38 02			JR	C,NALPHA	;If so miss next bit 
11fa d6 07			SUB	007h		;Else convert alpha 
11fc			NALPHA: 
11fc b2				OR	D		;Add hi nibble back 
11fd c9				RET			; 
11fe			 
11fe			 
11fe			; 
11fe			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
11fe			; Since the routines get_byte and therefore get_nibble are called, only valid 
11fe			; characters (0-9a-f) are accepted. 
11fe			; 
11fe			;get_word        push    af 
11fe			;                call    get_byte        ; Get the upper byte 
11fe			;                ld      h, a 
11fe			;                call    get_byte        ; Get the lower byte 
11fe			;                ld      l, a 
11fe			;                pop     af 
11fe			;                ret 
11fe			; 
11fe			; Get a byte in hexadecimal notation. The result is returned in A. Since 
11fe			; the routine get_nibble is used only valid characters are accepted - the  
11fe			; input routine only accepts characters 0-9a-f. 
11fe			; 
11fe c5			get_byte:        push    bc              ; Save contents of B (and C) 
11ff 7e					ld a,(hl) 
1200 23					inc hl 
1201 cd 26 12		                call    nibble2val      ; Get upper nibble 
1204 cb 07		                rlc     a 
1206 cb 07		                rlc     a 
1208 cb 07		                rlc     a 
120a cb 07		                rlc     a 
120c 47			                ld      b, a            ; Save upper four bits 
120d 7e					ld a,(hl) 
120e cd 26 12		                call    nibble2val      ; Get lower nibble 
1211 b0			                or      b               ; Combine both nibbles 
1212 c1			                pop     bc              ; Restore B (and C) 
1213 c9			                ret 
1214			; 
1214			; Get a hexadecimal digit from the serial line. This routine blocks until 
1214			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1214			; to the serial line interface. The lower 4 bits of A contain the value of  
1214			; that particular digit. 
1214			; 
1214			;get_nibble      ld a,(hl)           ; Read a character 
1214			;                call    to_upper        ; Convert to upper case 
1214			;                call    is_hex          ; Was it a hex digit? 
1214			;                jr      nc, get_nibble  ; No, get another character 
1214			 ;               call    nibble2val      ; Convert nibble to value 
1214			 ;               call    print_nibble 
1214			 ;               ret 
1214			; 
1214			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1214			; A valid hexadecimal digit is denoted by a set C flag. 
1214			; 
1214			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1214			;                ret     nc              ; Yes 
1214			;                cp      '0'             ; Less than '0'? 
1214			;                jr      nc, is_hex_1    ; No, continue 
1214			;                ccf                     ; Complement carry (i.e. clear it) 
1214			;                ret 
1214			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1214			;                ret     c               ; Yes 
1214			;                cp      'A'             ; Less than 'A'? 
1214			;                jr      nc, is_hex_2    ; No, continue 
1214			;                ccf                     ; Yes - clear carry and return 
1214			;                ret 
1214			;is_hex_2        scf                     ; Set carry 
1214			;                ret 
1214			; 
1214			; Convert a single character contained in A to upper case: 
1214			; 
1214 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1216 d8			                ret     c 
1217 fe 7b		                cp      'z' + 1         ; > 'z'? 
1219 d0			                ret     nc              ; Nothing to do, either 
121a e6 5f		                and     $5f             ; Convert to upper case 
121c c9			                ret 
121d			 
121d			 
121d			to_lower: 
121d			 
121d			   ; if char is in [A-Z] make it lower case 
121d			 
121d			   ; enter : a = char 
121d			   ; exit  : a = lower case char 
121d			   ; uses  : af 
121d			 
121d fe 41		   cp 'A' 
121f d8			   ret c 
1220			    
1220 fe 5b		   cp 'Z'+1 
1222 d0			   ret nc 
1223			    
1223 f6 20		   or $20 
1225 c9			   ret 
1226			 
1226			; 
1226			; Expects a hexadecimal digit (upper case!) in A and returns the 
1226			; corresponding value in A. 
1226			; 
1226 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1228 38 02		                jr      c, nibble2val_1 ; Yes 
122a d6 07		                sub     7               ; Adjust for A-F 
122c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
122e e6 0f		                and     $f              ; Only return lower 4 bits 
1230 c9			                ret 
1231			; 
1231			; Print_nibble prints a single hex nibble which is contained in the lower  
1231			; four bits of A: 
1231			; 
1231			;print_nibble    push    af              ; We won't destroy the contents of A 
1231			;                and     $f              ; Just in case... 
1231			;                add     a, '0'             ; If we have a digit we are done here. 
1231			;                cp      '9' + 1         ; Is the result > 9? 
1231			;                jr      c, print_nibble_1 
1231			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1231			;print_nibble_1  call    putc            ; Print the nibble and 
1231			;                pop     af              ; restore the original value of A 
1231			;                ret 
1231			;; 
1231			;; Send a CR/LF pair: 
1231			; 
1231			;crlf            push    af 
1231			;                ld      a, cr 
1231			;                call    putc 
1231			;                ld      a, lf 
1231			;                call    putc 
1231			;                pop     af 
1231			;                ret 
1231			; 
1231			; Print_word prints the four hex digits of a word to the serial line. The  
1231			; word is expected to be in HL. 
1231			; 
1231			;print_word      push    hl 
1231			;                push    af 
1231			;                ld      a, h 
1231			;                call    print_byte 
1231			;                ld      a, l 
1231			;                call    print_byte 
1231			;                pop     af 
1231			;                pop     hl 
1231			;                ret 
1231			; 
1231			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1231			; The byte to be printed is expected to be in A. 
1231			; 
1231			;print_byte      push    af              ; Save the contents of the registers 
1231			;                push    bc 
1231			;                ld      b, a 
1231			;                rrca 
1231			;                rrca 
1231			;                rrca 
1231			;                rrca 
1231			;                call    print_nibble    ; Print high nibble 
1231			;                ld      a, b 
1231			;                call    print_nibble    ; Print low nibble 
1231			;                pop     bc              ; Restore original register contents 
1231			;                pop     af 
1231			;                ret 
1231			 
1231			 
1231			 
1231			 
1231			 
1231			fourehexhl:  
1231 7e				ld a,(hl) 
1232 cd e0 11			call atohex 
1235 cb 3f				SRL A 
1237 cb 3f				SRL A 
1239 cb 3f				SRL A 
123b cb 3f				SRL A 
123d 47				ld b, a 
123e 23				inc hl 
123f 7e				ld a,(hl) 
1240 23				inc hl 
1241 cd e0 11			call atohex 
1244 80				add b 
1245 57				ld d,a 
1246 7e				ld a,(hl) 
1247 cd e0 11			call atohex 
124a cb 3f				SRL A 
124c cb 3f				SRL A 
124e cb 3f				SRL A 
1250 cb 3f				SRL A 
1252 47				ld b, a 
1253 23				inc hl 
1254 7e				ld a,(hl) 
1255 23				inc hl 
1256 cd e0 11			call atohex 
1259 80				add b 
125a 5f				ld e, a 
125b d5				push de 
125c e1				pop hl 
125d c9				ret 
125e			 
125e			; pass hl. returns z set if the byte at hl is a digit 
125e			;isdigithl:  
125e			;	push bc 
125e			;	ld a,(hl) 
125e			;	cp ':' 
125e			;	jr nc, .isdf 		; > 
125e			;	cp '0' 
125e			;	jr c, .isdf		; < 
125e			; 
125e			;	; TODO find a better way to set z 
125e			; 
125e			;	ld b,a 
125e			;	cp b 
125e			;	pop bc 
125e			;	ret 
125e			; 
125e			;.isdf:	; not digit so clear z 
125e			; 
125e			;	; TODO find a better way to unset z 
125e			; 
125e			;	ld b,a 
125e			;	inc b 
125e			;	cp b 
125e			; 
125e			;	pop bc 
125e			;	ret 
125e				 
125e				 
125e			 
125e			 
125e			; pass hl as the four byte address to load 
125e			 
125e			get_word_hl:  
125e e5				push hl 
125f cd fe 11			call get_byte 
1262				 
1262 47				ld b, a 
1263			 
1263 e1				pop hl 
1264 23				inc hl 
1265 23				inc hl 
1266			 
1266			; TODO not able to handle a-f  
1266 7e				ld a,(hl) 
1267			;	;cp ':' 
1267			;	cp 'g' 
1267			;	jr nc, .single_byte_hl 		; > 
1267			;	cp 'G' 
1267			;	jr nc, .single_byte_hl 		; > 
1267			;	cp '0' 
1267			;	jr c, .single_byte_hl		; < 
1267			 
1267				;call isdigithl 
1267			;	cp 0 
1267 b7				or a 
1268 28 06			jr z, .single_byte_hl 
126a			 
126a			.getwhln:   ; hex word so get next byte 
126a			 
126a cd fe 11			call get_byte 
126d 6f				ld l, a 
126e 60				ld h,b 
126f c9				ret 
1270 68			.single_byte_hl:   ld l,b 
1271 26 00				ld h,0 
1273 c9					ret 
1274			 
1274			 
1274			 
1274			 
1274 21 4f 1c			ld hl,asc+1 
1277			;	ld a, (hl) 
1277			;	call nibble2val 
1277 cd fe 11			call get_byte 
127a			 
127a			;	call fourehexhl 
127a 32 27 f1			ld (scratch+52),a 
127d				 
127d 21 25 f1			ld hl,scratch+50 
1280 22 16 f4			ld (os_cur_ptr),hl 
1283			 
1283 c9				ret 
1284			 
1284			 
1284			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1284			 
1284			; Decimal Unsigned Version 
1284			 
1284			;Number in a to decimal ASCII 
1284			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1284			;Example: display a=56 as "056" 
1284			;input: a = number 
1284			;Output: a=0,value of a in the screen 
1284			;destroys af,bc (don't know about hl and de) 
1284			DispAToASCII: 
1284 0e 9c			ld	c,-100 
1286 cd 90 12			call	.Na1 
1289 0e f6			ld	c,-10 
128b cd 90 12			call	.Na1 
128e 0e ff			ld	c,-1 
1290 06 2f		.Na1:	ld	b,'0'-1 
1292 04			.Na2:	inc	b 
1293 81				add	a,c 
1294 38 fc			jr	c,.Na2 
1296 91				sub	c		;works as add 100/10/1 
1297 f5				push af		;safer than ld c,a 
1298 78				ld	a,b		;char is in b 
1299			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1299 f1				pop af		;safer than ld a,c 
129a c9				ret 
129b			 
129b			; Decimal Signed Version 
129b			 
129b			; DispA 
129b			; -------------------------------------------------------------- 
129b			; Converts a signed integer value to a zero-terminated ASCII 
129b			; string representative of that value (using radix 10). 
129b			; -------------------------------------------------------------- 
129b			; INPUTS: 
129b			;     HL     Value to convert (two's complement integer). 
129b			;     DE     Base address of string destination. (pointer). 
129b			; -------------------------------------------------------------- 
129b			; OUTPUTS: 
129b			;     None 
129b			; -------------------------------------------------------------- 
129b			; REGISTERS/MEMORY DESTROYED 
129b			; AF HL 
129b			; -------------------------------------------------------------- 
129b			 
129b			;DispHLToASCII: 
129b			;   push    de 
129b			;   push    bc 
129b			; 
129b			;; Detect sign of HL. 
129b			;    bit    7, h 
129b			;    jr     z, ._DoConvert 
129b			; 
129b			;; HL is negative. Output '-' to string and negate HL. 
129b			;    ld     a, '-' 
129b			;    ld     (de), a 
129b			;    inc    de 
129b			; 
129b			;; Negate HL (using two's complement) 
129b			;    xor    a 
129b			;    sub    l 
129b			;    ld     l, a 
129b			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
129b			;    sbc    a, h 
129b			;    ld     h, a 
129b			; 
129b			;; Convert HL to digit characters 
129b			;._DoConvert: 
129b			;    ld     b, 0     ; B will count character length of number 
129b			;-   ld     a, 10 
129b			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
129b			;    push   af 
129b			;    inc    b 
129b			;    ld     a, h 
129b			;    or     l 
129b			;    jr     nz, - 
129b			; 
129b			;; Retrieve digits from stack 
129b			;-   pop    af 
129b			;    or     $30 
129b			;    ld     (de), a 
129b			;    inc    de 
129b			;    djnz   - 
129b			; 
129b			;; Terminate string with NULL 
129b			;    xor    a 
129b			;    ld     (de), a 
129b			; 
129b			;    pop    bc 
129b			;    pop    de 
129b			;    ret 
129b			 
129b			;Comments 
129b			; 
129b			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
129b			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
129b			;    Note that the output string will not be fixed-width. 
129b			; 
129b			;Example Usage 
129b			; 
129b			;    ld    hl, -1004 
129b			;    ld    de, OP1 
129b			;    call  DispA 
129b			;    ld    hl, OP1 
129b			;    syscall  PutS 
129b			 
129b			 
129b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
129b			 
129b			 
129b			;Converts an ASCII string to an unsigned 16-bit integer 
129b			;Quits when it reaches a non-decimal digit 
129b			 
129b			string_to_uint16: 
129b			atoui_16: 
129b			;Input: 
129b			;     DE points to the string 
129b			;Outputs: 
129b			;     HL is the result 
129b			;     A is the 8-bit value of the number 
129b			;     DE points to the byte after the number 
129b			;Destroys: 
129b			;     BC 
129b			;       if the string is non-empty, BC is HL/10 
129b			;Size:  24 bytes 
129b			;Speed: 42+d(104+{0,9}) 
129b			;       d is the number of digits in the number 
129b			;       max is 640 cycles for a 5 digit number 
129b			;Assuming no leading zeros: 
129b			;1 digit:  146cc 
129b			;2 digit:  250cc 
129b			;3 digit:  354cc or 363cc (avg: 354.126cc) 
129b			;4 digit:  458cc or 467cc (avg: 458.27cc) 
129b			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
129b			;avg: 544.81158447265625cc (544+13297/16384) 
129b			;=============================================================== 
129b 21 00 00		  ld hl,0 
129e			.u16a: 
129e 1a			  ld a,(de) 
129f d6 30		  sub 30h 
12a1 fe 0a		  cp 10 
12a3 d0			  ret nc 
12a4 13			  inc de 
12a5 44			  ld b,h 
12a6 4d			  ld c,l 
12a7 29			  add hl,hl 
12a8 29			  add hl,hl 
12a9 09			  add hl,bc 
12aa 29			  add hl,hl 
12ab 85			  add a,l 
12ac 6f			  ld l,a 
12ad 30 ef		  jr nc,.u16a 
12af 24			  inc h 
12b0 c3 9e 12		  jp .u16a 
12b3			 
12b3			 
12b3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12b3			 
12b3			;written by Zeda 
12b3			;Converts a 16-bit unsigned integer to an ASCII string. 
12b3			 
12b3			uitoa_16: 
12b3			;Input: 
12b3			;   DE is the number to convert 
12b3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12b3			;Output: 
12b3			;   HL points to the null-terminated ASCII string 
12b3			;      NOTE: This isn't necessarily the same as the input HL. 
12b3 d5			  push de 
12b4 c5			  push bc 
12b5 f5			  push af 
12b6 eb			  ex de,hl 
12b7			 
12b7 01 f0 d8		  ld bc,-10000 
12ba 3e 2f		  ld a,'0'-1 
12bc 3c			  inc a 
12bd 09			  add hl,bc  
12be 38 fc		   jr c,$-2 
12c0 12			  ld (de),a 
12c1 13			  inc de 
12c2			 
12c2 01 e8 03		  ld bc,1000 
12c5 3e 3a		  ld a,'9'+1 
12c7 3d			  dec a  
12c8 09			  add hl,bc  
12c9 30 fc		   jr nc,$-2 
12cb 12			  ld (de),a 
12cc 13			  inc de 
12cd			 
12cd 01 9c ff		  ld bc,-100 
12d0 3e 2f		  ld a,'0'-1 
12d2 3c			  inc a  
12d3 09			  add hl,bc  
12d4 38 fc		   jr c,$-2 
12d6 12			  ld (de),a 
12d7 13			  inc de 
12d8			 
12d8 7d			  ld a,l 
12d9 26 3a		  ld h,'9'+1 
12db 25			  dec h  
12dc c6 0a		  add a,10  
12de 30 fb		   jr nc,$-3 
12e0 c6 30		  add a,'0' 
12e2 eb			  ex de,hl 
12e3 72			  ld (hl),d 
12e4 23			  inc hl 
12e5 77			  ld (hl),a 
12e6 23			  inc hl 
12e7 36 00		  ld (hl),0 
12e9			 
12e9			;Now strip the leading zeros 
12e9 0e fa		  ld c,-6 
12eb 09			  add hl,bc 
12ec 3e 30		  ld a,'0' 
12ee 23			  inc hl  
12ef be			  cp (hl)  
12f0 28 fc		  jr z,$-2 
12f2			 
12f2			;Make sure that the string is non-empty! 
12f2 7e			  ld a,(hl) 
12f3 b7			  or a 
12f4 20 01		  jr nz,.atoub 
12f6 2b			  dec hl 
12f7			.atoub: 
12f7			 
12f7 f1			  pop af 
12f8 c1			  pop bc 
12f9 d1			  pop de 
12fa c9			  ret 
12fb			 
12fb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
12fb			 
12fb			toUpper: 
12fb			;A is the char. 
12fb			;If A is a lowercase letter, this sets it to the matching uppercase 
12fb			;18cc or 30cc or 41cc 
12fb			;avg: 26.75cc 
12fb fe 61		  cp 'a' 
12fd d8			  ret c 
12fe fe 7b		  cp 'z'+1 
1300 d0			  ret nc 
1301 d6 20		  sub 'a'-'A' 
1303 c9			  ret 
1304			 
1304			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1304			 
1304			; String Length 
1304			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1304			 
1304			; Get the length of the null-terminated string starting at $8000 hl 
1304			;    LD     HL, $8000 
1304			 
1304			strlenz: 
1304			 
1304 af			    XOR    A               ; Zero is the value we are looking for. 
1305 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1306 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1307			                           ; 65, 536 bytes (the entire addressable memory space). 
1307 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1309			 
1309			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1309 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
130a 6f			    LD     L, A             ; number of bytes 
130b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
130d 2b			    DEC    HL              ; Compensate for null. 
130e c9				ret 
130f			 
130f			; Get the length of the A terminated string starting at $8000 hl 
130f			;    LD     HL, $8000 
130f			 
130f			strlent: 
130f			 
130f			                  ; A is the value we are looking for. 
130f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1311 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1313			                           ; 65, 536 bytes (the entire addressable memory space). 
1313 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1315			 
1315			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1315 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1317 2e 00		    LD     L, 0             ; number of bytes 
1319 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
131b 2b			    DEC    HL              ; Compensate for null. 
131c c9				ret 
131d			 
131d			 
131d			;Comparing Strings 
131d			 
131d			;IN    HL     Address of string1. 
131d			;      DE     Address of string2. 
131d			 
131d			; doc given but wrong??? 
131d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
131d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
131d			; tested 
131d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
131d			 
131d			strcmp_old: 
131d e5			    PUSH   HL 
131e d5			    PUSH   DE 
131f			 
131f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1320 be			    CP     (HL)            ; (want to minimize work). 
1321 38 01		    JR     C, Str1IsBigger 
1323 7e			    LD     A, (HL) 
1324			 
1324			Str1IsBigger: 
1324 4f			    LD     C, A             ; Put length in BC 
1325 06 00		    LD     B, 0 
1327 13			    INC    DE              ; Increment pointers to meat of string. 
1328 23			    INC    HL 
1329			 
1329			CmpLoop: 
1329 1a			    LD     A, (DE)          ; Compare bytes. 
132a ed a1		    CPI 
132c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
132e 13			    INC    DE              ; Update pointer. 
132f ea 29 13		    JP     PE, CmpLoop 
1332			 
1332 d1			    POP    DE 
1333 e1			    POP    HL 
1334 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1335 be			    CP     (HL) 
1336 c9			    RET 
1337			 
1337			NoMatch: 
1337 2b			    DEC    HL 
1338 be			    CP     (HL)            ; Compare again to affect carry. 
1339 d1			    POP    DE 
133a e1			    POP    HL 
133b c9			    RET 
133c			 
133c			;; test strmp 
133c			; 
133c			;ld de, .str1 
133c			;ld hl, .str2 
133c			;call strcmp 
133c			;jr z, .z1 
133c			;;this 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "NZ1" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;.z1: 
133c			; 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "ZZ1" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			; 
133c			;ld de, .str1 
133c			;ld hl, .str1 
133c			;call strcmp 
133c			;jr z, .z2 
133c			;;this 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "NZ2" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;.z2: 
133c			; 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "ZZ2" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			; 
133c			;ld de, .str1 
133c			;ld hl, .str2 
133c			;call strcmp 
133c			;jr c, .c1 
133c			; 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "Nc1" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;.c1: 
133c			;;this 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "cc1" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			; 
133c			;ld de, .str1 
133c			;ld hl, .str1 
133c			;call strcmp 
133c			;jr c, .c2 
133c			;;this 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "Nc2" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;.c2: 
133c			; 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "cc2" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;	NEXTW 
133c			;.str1:   db "string1",0 
133c			;.str2:   db "string2",0 
133c			 
133c			; only care about direct match or not 
133c			; hl and de strings 
133c			; zero set if the same 
133c			 
133c			strcmp: 
133c 1a				ld a, (de) 
133d be				cp (hl) 
133e 28 02			jr z, .ssame 
1340 b7				or a 
1341 c9				ret 
1342			 
1342			.ssame:  
1342			;	cp 0 
1342 b7				or a 
1343 c8				ret z 
1344			 
1344 23				inc hl 
1345 13				inc de 
1346 18 f4			jr strcmp 
1348				 
1348				 
1348			 
1348			;Copyright (c) 2014, Luke Maurits 
1348			;All rights reserved. 
1348			; 
1348			;Redistribution and use in source and binary forms, with or without 
1348			;modification, are permitted provided that the following conditions are met: 
1348			; 
1348			;* Redistributions of source code must retain the above copyright notice, this 
1348			;  list of conditions and the following disclaimer. 
1348			; 
1348			;* Redistributions in binary form must reproduce the above copyright notice, 
1348			;  this list of conditions and the following disclaimer in the documentation 
1348			;  and/or other materials provided with the distribution. 
1348			; 
1348			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1348			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1348			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1348			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1348			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1348			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1348			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1348			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1348			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1348			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1348			 
1348			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1348			 
1348			StrictStrCmp: 
1348				; Load next chars of each string 
1348 1a				ld a, (de) 
1349 47				ld b, a 
134a 7e				ld a, (hl) 
134b				; Compare 
134b b8				cp b 
134c				; Return non-zero if chars don't match 
134c c0				ret nz 
134d				; Check for end of both strings 
134d fe 00			cp "\0" 
134f				; Return if strings have ended 
134f c8				ret z 
1350				; Otherwise, advance to next chars 
1350 23				inc hl 
1351 13				inc de 
1352 18 f4			jr StrictStrCmp 
1354			 
1354			;end 
1354			; eof 
1354			 
1354			 
1354			 
1354			 
1354			 
1354			 
# End of file firmware_strings.asm
1354			include "firmware_memory.asm"   ; malloc and free  
1354			 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354			.mallocsize: db "Wants malloc >256",0 
1354			.mallocasize: db "MALLOC gives >256",0 
1354			.malloczero: db "MALLOC gives zero",0 
1354			 
1354			malloc_guard_zerolen: 
1354				push hl 
1354				push de 
1354				push af 
1354			 
1354				ld de, 0 
1354			        call cmp16 
1354				jr nz, .lowalloz 
1354			 
1354				push hl 
1354				push de 
1354					ld hl, display_fb0 
1354					ld (display_fb_active), hl 
1354				call clear_display 
1354				ld a, 0 
1354				ld de, .malloczero 
1354				call str_at_display 
1354				call update_display 
1354				call delay1s 
1354				call delay1s 
1354				call bp_on 
1354			;	ld a, 0 
1354			;	ld (os_view_disable), a 
1354			 
1354				pop de 
1354				pop hl 
1354			 
1354				 
1354			 
1354				CALLMONITOR 
1354			.lowalloz: 
1354			 
1354			 
1354				pop af 
1354				pop de 
1354				pop hl 
1354			ret 
1354			 
1354			malloc_guard_entry: 
1354				push hl 
1354				push de 
1354				push af 
1354			 
1354			 	or a      ;clear carry flag 
1354				push hl 
1354				ld de, 255 
1354				sbc hl, de 
1354				jr c, .lowalloc 
1354			 
1354				push de 
1354					ld hl, display_fb0 
1354					ld (display_fb_active), hl 
1354				call clear_display 
1354				ld a, 0 
1354				ld de, .mallocsize 
1354				call str_at_display 
1354				call update_display 
1354				call delay1s 
1354				call delay1s 
1354			;	ld a, 0 
1354			;	ld (os_view_disable), a 
1354				call bp_on 
1354			 
1354				pop de 
1354				pop hl 
1354			 
1354				 
1354			 
1354				CALLMONITOR 
1354				jr .lowdone 
1354			.lowalloc: 
1354			 
1354			 
1354				pop hl 
1354			.lowdone:	pop af 
1354				pop de 
1354				pop hl 
1354			ret 
1354			 
1354			malloc_guard_exit: 
1354				push hl 
1354				push de 
1354				push af 
1354			 
1354			 	or a      ;clear carry flag 
1354				push hl 
1354				ld de, 255 
1354				sbc hl, de 
1354				jr c, .lowallocx 
1354			 
1354				push de 
1354					ld hl, display_fb0 
1354					ld (display_fb_active), hl 
1354				call clear_display 
1354				ld a, 0 
1354				ld de, .mallocasize 
1354				call str_at_display 
1354				call update_display 
1354				call delay1s 
1354				call delay1s 
1354			;	ld a, 0 
1354			;	ld (os_view_disable), a 
1354				call bp_on 
1354				pop de 
1354				pop hl 
1354			 
1354				CALLMONITOR 
1354				jr .lowdonex 
1354			.lowallocx: 
1354			 
1354				pop hl 
1354			.lowdonex:	pop af 
1354				pop de 
1354				pop hl 
1354			ret 
1354			endif 
1354			 
1354			if MALLOC_2 
1354			; Z80 Malloc and Free Functions 
1354			 
1354			; Malloc Function: 
1354			; Input: 
1354			;   HL: Size of block to allocate 
1354			; Output: 
1354			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1354			 
1354			malloc: 
1354				 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354			call malloc_guard_entry 
1354			endif 
1354			 
1354			 
1354			 
1354			 
1354					if DEBUG_FORTH_MALLOC 
1354						DMARK "mal" 
1354						CALLMONITOR 
1354					endif 
1354			    push af            ; Save AF register 
1354			    ld a, l            ; Load low byte of size into A 
1354			    or h               ; Check if size is zero 
1354			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1354			 
1354			    ; Allocate memory 
1354			    ld hl, (heap_start) ; Load start of heap into HL 
1354					if DEBUG_FORTH_MALLOC 
1354						DMARK "ma1" 
1354						CALLMONITOR 
1354					endif 
1354			    call malloc_internal ; Call internal malloc function 
1354			    pop af             ; Restore AF register 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354			call malloc_guard_exit 
1354			call malloc_guard_zerolen 
1354			endif 
1354			    ret                ; Return 
1354			 
1354			; Free Function: 
1354			; Input: 
1354			;   HL: Pointer to memory block to free 
1354			; Output: 
1354			;   None 
1354			 
1354			free: 
1354			    push af            ; Save AF register 
1354			    ld a, l            ; Load low byte of pointer into A 
1354			    or h               ; Check if pointer is NULL 
1354			    jp z, free_exit    ; If pointer is NULL, exit 
1354			 
1354			    ; Free memory 
1354			    ld hl, (heap_start) ; Load start of heap into HL 
1354			    call free_internal  ; Call internal free function 
1354			    pop af             ; Restore AF register 
1354			    ret                ; Return 
1354			 
1354			; Internal Malloc Function: 
1354			; Input: 
1354			;   HL: Size of block to allocate 
1354			; Output: 
1354			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1354			 
1354			malloc_internal: 
1354			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1354			    add hl, bc         ; Add management overhead to requested size 
1354			    ex de, hl          ; Save total size in DE, and keep it in HL 
1354					if DEBUG_FORTH_MALLOC 
1354						DMARK "ma2" 
1354						CALLMONITOR 
1354					endif 
1354			 
1354			    ; Search for free memory block 
1354			    ld de, (heap_end)  ; Load end of heap into DE 
1354			    ld bc, 0           ; Initialize counter 
1354			 
1354					if DEBUG_FORTH_MALLOC 
1354						DMARK "ma2" 
1354						CALLMONITOR 
1354					endif 
1354			malloc_search_loop: 
1354			    ; Check if current block is free 
1354			    ld a, (hl)         ; Load current block's status (free or used) 
1354			;    cp 0               ; Compare with zero (free) 
1354				or a 
1354			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1354			 
1354			    ; Check if current block is large enough 
1354			    ld a, (hl+1)       ; Load high byte of block size 
1354			    cp l               ; Compare with low byte of requested size 
1354			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1354			 
1354			    ld a, (hl+2)       ; Load low byte of block size 
1354			    cp h               ; Compare with high byte of requested size 
1354			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1354			 
1354			    ; Mark block as used 
1354			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1354			 
1354			    ; Calculate remaining space in block 
1354			    ld bc, 0           ; Clear BC 
1354			    add hl, bc         ; Increment HL to point to start of data block 
1354			    add hl, de         ; HL = HL + DE (total size) 
1354			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1354			    add hl, bc         ; Add management overhead to start of data block 
1354			 
1354			    ; Save pointer to allocated block in HL 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354						DMARK "ma5" 
1354			call malloc_guard_exit 
1354			call malloc_guard_zerolen 
1354			endif 
1354			    ret 
1354			 
1354			malloc_skip_block_check: 
1354			    ; Move to the next block 
1354			    ld bc, 3           ; Size of management overhead 
1354			    add hl, bc         ; Move to the next block 
1354			    inc de             ; Increment counter 
1354			 
1354			    ; Check if we have reached the end of heap 
1354			    ld a, e            ; Load low byte of heap end address 
1354			    cp (hl)            ; Compare with low byte of current address 
1354			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1354			    ld a, d            ; Load high byte of heap end address 
1354			;    cp 0               ; Check if it's zero (end of memory) 
1354				or a 
1354			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1354			 
1354			    ; If we reached here, allocation failed 
1354			    xor a              ; Set result to NULL 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354						DMARK "ma6" 
1354			call malloc_guard_exit 
1354			call malloc_guard_zerolen 
1354			endif 
1354			    ret 
1354			malloc_exit: 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354						DMARK "ma7" 
1354			call malloc_guard_exit 
1354			call malloc_guard_zerolen 
1354			endif 
1354			    ret 
1354			 
1354			; Internal Free Function: 
1354			; Input: 
1354			;   HL: Pointer to memory block to free 
1354			; Output: 
1354			;   None 
1354			 
1354			free_internal: 
1354			    ld de, (heap_start) ; Load start of heap into DE 
1354			    ld bc, 0            ; Initialize counter 
1354			 
1354			free_search_loop: 
1354			    ; Check if current block contains the pointer 
1354			    ld a, l             ; Load low byte of pointer 
1354			    cp (hl+1)           ; Compare with high byte of current block's address 
1354			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1354			    ld a, h             ; Load high byte of pointer 
1354			    cp (hl+2)           ; Compare with low byte of current block's address 
1354			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1354			 
1354			    ; Mark block as free 
1354			    ld (hl), 0          ; Set status byte to indicate free block 
1354			    ret                 ; Return 
1354			 
1354			free_skip_block_check: 
1354			    ; Move to the next block 
1354			    ld bc, 3            ; Size of management overhead 
1354			    add hl, bc          ; Move to the next block 
1354			    inc de              ; Increment counter 
1354			 
1354			    ; Check if we have reached the end of heap 
1354			    ld a, e             ; Load low byte of heap end address 
1354			    cp (hl)             ; Compare with low byte of current address 
1354			    jr nz, free_search_loop  ; If not equal, continue searching 
1354			    ld a, d             ; Load high byte of heap end address 
1354			;    cp 0                ; Check if it's zero (end of memory) 
1354				or a 
1354			    jr nz, free_search_loop  ; If not zero, continue searching 
1354			 
1354			    ; If we reached here, pointer is not found in heap 
1354			    ret 
1354			 
1354			free_exit: 
1354			    ret                 ; Return 
1354			 
1354			; Define heap start and end addresses 
1354			;heap_start:    .dw 0xC000   ; Start of heap 
1354			;heap_end:      .dw 0xE000   ; End of heap 
1354			 
1354			endif 
1354			 
1354			 
1354			if MALLOC_1 
1354			 
1354			 
1354			 
1354			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1354			 
1354			;moved to firmware.asm 
1354			;heap_start        .equ  0x9000      ; Starting address of heap 
1354			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1354			 
1354			;      .org 0 
1354			;      jp    main 
1354			 
1354			 
1354			;      .org  0x100 
1354			;main: 
1354			;      ld    HL, 0x8100 
1354			;      ld    SP, HL 
1354			; 
1354			;      call  heap_init 
1354			; 
1354			;      ; Make some allocations 
1354			;      ld    HL, 12 
1354			;      call  malloc            ; Allocates 0x9004 
1354			; 
1354			;      ld    HL, 12 
1354			;      call  malloc            ; Allocates 0x9014 
1354			; 
1354			;      ld    HL, 12 
1354			;      call  malloc            ; Allocates 0x9024 
1354			; 
1354			;      ; Free some allocations 
1354			;      ld    HL, 0x9014 
1354			;      call  free 
1354			; 
1354			;      ld    HL, 0x9004 
1354			;      call  free 
1354			; 
1354			;      ld    HL, 0x9024 
1354			;      call  free 
1354			; 
1354			; 
1354			;      halt 
1354			 
1354			 
1354			;------------------------------------------------------------------------------ 
1354			;     heap_init                                                               : 
1354			;                                                                             : 
1354			; Description                                                                 : 
1354			;     Initialise the heap and make it ready for malloc and free operations.   : 
1354			;                                                                             : 
1354			;     The heap is maintained as a linked list, starting with an initial       : 
1354			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1354			;     the first free block in the heap. Each block then points to the next    : 
1354			;     free block within the heap, and the free list ends at the first block   : 
1354			;     with a null pointer to the next free block.                             : 
1354			;                                                                             : 
1354			; Parameters                                                                  : 
1354			;     Inputs are compile-time only. Two defines which specify the starting    : 
1354			;     address of the heap and its size are required, along with a memory      : 
1354			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1354			;     principally stores a pointer to the first free block in the heap.       : 
1354			;                                                                             : 
1354			; Returns                                                                     : 
1354			;     Nothing                                                                 : 
1354			;------------------------------------------------------------------------------ 
1354			heap_init: 
1354 e5			      push  HL 
1355			 
1355			      ; Initialise free list struct 
1355 21 0e 80		      ld    HL, heap_start 
1358 22 0a 80		      ld    (free_list), HL 
135b 21 00 00		      ld    HL, 0 
135e 22 0c 80		      ld    (free_list+2), HL 
1361			 
1361			      ; Insert first free block at bottom of heap, consumes entire heap 
1361 21 ca f0		      ld    HL, heap_start+heap_size-4 
1364 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1367 21 bc 70		      ld    HL, heap_size-4 
136a 22 10 80		      ld    (heap_start+2), HL      ; Block size 
136d			 
136d			      ; Insert end of free list block at top of heap - two null words will 
136d			      ; terminate the free list 
136d 21 00 00		      ld    HL, 0 
1370 22 cc f0		      ld    (heap_start+heap_size-2), HL 
1373 22 ca f0		      ld    (heap_start+heap_size-4), HL 
1376			 
1376 e1			      pop   HL 
1377			 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     malloc                                                                  : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Allocates the wanted space from the heap and returns the address of the : 
1378			;     first useable byte of the allocation.                                   : 
1378			;                                                                             : 
1378			;     Allocations can happen in one of two ways:                              : 
1378			;                                                                             : 
1378			;     1. A free block may be found which is the exact size wanted. In this    : 
1378			;        case the block is removed from the free list and retuedn to the      : 
1378			;        caller.                                                              : 
1378			;     2. A free block may be found which is larger than the size wanted. In   : 
1378			;        this case, the larger block is split into two. The first portion of  : 
1378			;        this block will become the requested space by the malloc call and    : 
1378			;        is returned to the caller. The second portion becomes a new free     : 
1378			;        block, and the free list is adjusted to maintain continuity via this : 
1378			;        newly created block.                                                 : 
1378			;                                                                             : 
1378			;     malloc does not set any initial value in the allocated space, the       : 
1378			;     caller is required to do this as required.                              : 
1378			;                                                                             : 
1378			;     This implementation of malloc uses the stack exclusively, and is        : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling malloc, and recommended  : 
1378			;     to avoid the use of malloc inside ISRs in general.                      : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Number of bytes wanted                                              : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     HL  Address of the first useable byte of the allocation                 : 
1378			;                                                                             : 
1378			; Flags                                                                       : 
1378			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +4  +-------------+                                                       : 
1378			;       |  this_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			 
1378			 
1378			;malloc: 
1378			; 
1378			;	SAVESP ON 1 
1378			; 
1378			;	call malloc_code 
1378			; 
1378			;	CHECKSP ON 1 
1378			;	ret 
1378			 
1378			 
1378			malloc: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			if DEBUG_FORTH_MALLOC_HIGH 
137c			call malloc_guard_entry 
137c			endif 
137c			 
137c					if DEBUG_FORTH_MALLOC 
137c						DMARK "mal" 
137c						CALLMONITOR 
137c					endif 
137c 7c			      ld    A, H                    ; Exit if no space requested 
137d b5			      or    L 
137e ca 3d 14		      jp    Z, malloc_early_exit 
1381			 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			; 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			 
1381			 
1381			 
1381			 
1381					if DEBUG_FORTH_MALLOC 
1381						DMARK "maA" 
1381						CALLMONITOR 
1381					endif 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; Setup initial state 
138d 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1390 19			      add   HL, DE 
1391			 
1391 44			      ld    B, H                    ; Move want to BC 
1392 4d			      ld    C, L 
1393			 
1393 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1396 dd 75 04		      ld    (IX+4), L 
1399 dd 74 05		      ld    (IX+5), H 
139c			 
139c 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
139d 23			      inc   HL 
139e 56			      ld    D, (HL) 
139f dd 73 02		      ld    (IX+2), E 
13a2 dd 72 03		      ld    (IX+3), D 
13a5 eb			      ex    DE, HL                  ; this_free ptr into HL 
13a6			 
13a6					if DEBUG_FORTH_MALLOC 
13a6						DMARK "maB" 
13a6						CALLMONITOR 
13a6					endif 
13a6			      ; Loop through free block list to find some space 
13a6			malloc_find_space: 
13a6 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13a7 23			      inc   HL 
13a8 56			      ld    D, (HL) 
13a9			 
13a9 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13aa b3			      or    E 
13ab ca 37 14		      jp    Z, malloc_no_space 
13ae			 
13ae dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13b1 dd 72 01		      ld    (IX+1), D 
13b4			 
13b4			      ; Does this block have enough space to make the allocation? 
13b4 23			      inc   HL                      ; Load free block size into DE 
13b5 5e			      ld    E, (HL) 
13b6 23			      inc   HL 
13b7 56			      ld    D, (HL) 
13b8			 
13b8 eb			      ex    DE, HL                  ; Check size of block against want 
13b9 b7			      or    A                       ; Ensure carry flag clear 
13ba ed 42		      sbc   HL, BC 
13bc e5			      push  HL                      ; Store the result for later (new block size) 
13bd			 
13bd ca 0c 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13c0 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
13c2			 
13c2			      ; this_free block is not big enough, setup ptrs to test next free block 
13c2 e1			      pop   HL                      ; Discard previous result 
13c3			 
13c3 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
13c6 dd 66 03		      ld    H, (IX+3) 
13c9 dd 75 04		      ld    (IX+4), L 
13cc dd 74 05		      ld    (IX+5), H 
13cf			 
13cf dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
13d2 dd 66 01		      ld    H, (IX+1) 
13d5 dd 75 02		      ld    (IX+2), L 
13d8 dd 74 03		      ld    (IX+3), H 
13db			 
13db					if DEBUG_FORTH_MALLOC 
13db						DMARK "MA>" 
13db						CALLMONITOR 
13db					endif 
13db 18 c9		      jr    malloc_find_space 
13dd			 
13dd			      ; split a bigger block into two - requested size and remaining size 
13dd			malloc_alloc_split: 
13dd					if DEBUG_FORTH_MALLOC 
13dd						DMARK "MAs" 
13dd						CALLMONITOR 
13dd					endif 
13dd eb			      ex    DE, HL                  ; Calculate address of new free block 
13de 2b			      dec   HL 
13df 2b			      dec   HL 
13e0 2b			      dec   HL 
13e1 09			      add   HL, BC 
13e2			 
13e2			      ; Create a new block and point it at next_free 
13e2 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
13e5 dd 56 01		      ld    D, (IX+1) 
13e8			 
13e8 73			      ld    (HL), E                 ; Store next_free ptr into new block 
13e9 23			      inc   HL 
13ea 72			      ld    (HL), D 
13eb			 
13eb d1			      pop   DE                      ; Store size of new block into new block 
13ec 23			      inc   HL 
13ed 73			      ld    (HL), E 
13ee 23			      inc   HL 
13ef 72			      ld    (HL), D 
13f0			 
13f0			      ; Update this_free ptr to point to new block 
13f0 2b			      dec   HL 
13f1 2b			      dec   HL 
13f2 2b			      dec   HL 
13f3			 
13f3 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
13f6 dd 56 03		      ld    D, (IX+3) 
13f9			 
13f9 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
13fc dd 74 03		      ld    (IX+3), H 
13ff			 
13ff			      ; Modify this_free block to be allocation 
13ff eb			      ex    DE, HL 
1400 af			      xor   A                       ; Null the next block ptr of allocated block 
1401 77			      ld    (HL), A 
1402 23			      inc   HL 
1403 77			      ld    (HL), A 
1404			 
1404 23			      inc   HL                      ; Store want size into allocated block 
1405 71			      ld    (HL), C 
1406 23			      inc   HL 
1407 70			      ld    (HL), B 
1408 23			      inc   HL 
1409 e5			      push  HL                      ; Address of allocation to return 
140a			 
140a 18 19		      jr    malloc_update_links 
140c			 
140c			malloc_alloc_fit: 
140c e1			      pop   HL                      ; Dont need new block size, want is exact fit 
140d			 
140d					if DEBUG_FORTH_MALLOC 
140d						DMARK "MAf" 
140d						CALLMONITOR 
140d					endif 
140d			      ; Modify this_free block to be allocation 
140d eb			      ex    DE, HL 
140e 2b			      dec   HL 
140f 2b			      dec   HL 
1410 2b			      dec   HL 
1411			 
1411 af			      xor   A                       ; Null the next block ptr of allocated block 
1412 77			      ld    (HL), A 
1413 23			      inc   HL 
1414 77			      ld    (HL), A 
1415			 
1415 23			      inc   HL                      ; Store address of allocation to return 
1416 23			      inc   HL 
1417 23			      inc   HL 
1418 e5			      push  HL 
1419			 
1419			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1419 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
141c dd 66 01		      ld    H, (IX+1) 
141f			 
141f dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1422 dd 74 03		      ld    (IX+3), H 
1425			 
1425			 
1425			malloc_update_links: 
1425			      ; Update prev_free ptr to point to this_free 
1425 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1428 dd 66 05		      ld    H, (IX+5) 
142b			 
142b dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
142e dd 56 03		      ld    D, (IX+3) 
1431			 
1431 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1432 23			      inc   HL 
1433 72			      ld    (HL), D 
1434			 
1434					if DEBUG_FORTH_MALLOC 
1434						DMARK "Mul" 
1434						CALLMONITOR 
1434					endif 
1434			      ; Clear the Z flag to indicate successful allocation 
1434 7a			      ld    A, D 
1435 b3			      or    E 
1436			 
1436 d1			      pop   DE                      ; Address of allocation 
1437					if DEBUG_FORTH_MALLOC 
1437						DMARK "MAu" 
1437						CALLMONITOR 
1437					endif 
1437			 
1437			malloc_no_space: 
1437 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
143a 39			      add   HL, SP 
143b f9			      ld    SP, HL 
143c			 
143c eb			      ex    DE, HL                  ; Alloc addr into HL for return 
143d					if DEBUG_FORTH_MALLOC 
143d						DMARK "MAN" 
143d						CALLMONITOR 
143d					endif 
143d			 
143d			malloc_early_exit: 
143d					if DEBUG_FORTH_MALLOC 
143d						DMARK "MAx" 
143d						CALLMONITOR 
143d					endif 
143d dd e1		      pop   IX 
143f d1			      pop   DE 
1440 c1			      pop   BC 
1441			 
1441			if DEBUG_FORTH_MALLOC_HIGH 
1441			call malloc_guard_exit 
1441			call malloc_guard_zerolen 
1441			endif 
1441 c9			      ret 
1442			 
1442			 
1442			;------------------------------------------------------------------------------ 
1442			;     free                                                                    : 
1442			;                                                                             : 
1442			; Description                                                                 : 
1442			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1442			;     returned by malloc, otherwise the behaviour is undefined.               : 
1442			;                                                                             : 
1442			;     Where possible, directly adjacent free blocks will be merged together   : 
1442			;     into larger blocks to help ensure that the heap does not become         : 
1442			;     excessively fragmented.                                                 : 
1442			;                                                                             : 
1442			;     free does not clear or set any other value into the freed space, and    : 
1442			;     therefore its contents may be visible through subsequent malloc's. The  : 
1442			;     caller should clear the freed space as required.                        : 
1442			;                                                                             : 
1442			;     This implementation of free uses the stack exclusively, and is          : 
1442			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1442			;     advisable to disable interrupts before calling free, and recommended    : 
1442			;     to avoid the use of free inside ISRs in general.                        : 
1442			;                                                                             : 
1442			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1442			;                                                                             : 
1442			; Parameters                                                                  : 
1442			;     HL  Pointer to address of first byte of allocation to be freed          : 
1442			;                                                                             : 
1442			; Returns                                                                     : 
1442			;     Nothing                                                                 : 
1442			;                                                                             : 
1442			; Stack frame                                                                 : 
1442			;       |             |                                                       : 
1442			;       +-------------+                                                       : 
1442			;       |     BC      |                                                       : 
1442			;       +-------------+                                                       : 
1442			;       |     DE      |                                                       : 
1442			;       +-------------+                                                       : 
1442			;       |     IX      |                                                       : 
1442			;       +-------------+                                                       : 
1442			;       |  prev_free  |                                                       : 
1442			;   +2  +-------------+                                                       : 
1442			;       |  next_free  |                                                       : 
1442			;   +0  +-------------+                                                       : 
1442			;       |             |                                                       : 
1442			;                                                                             : 
1442			;------------------------------------------------------------------------------ 
1442			free: 
1442 c5			      push  BC 
1443 d5			      push  DE 
1444 dd e5		      push  IX 
1446			 
1446 7c			      ld    A, H                    ; Exit if ptr is null 
1447 b5			      or    L 
1448 ca 0c 15		      jp    Z, free_early_exit 
144b			 
144b			      ; Set up stack frame 
144b eb			      ex    DE, HL 
144c 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
144f 39			      add   HL, SP 
1450 f9			      ld    SP, HL 
1451 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1455 dd 39		      add   IX, SP 
1457			 
1457			      ; The address in HL points to the start of the useable allocated space, 
1457			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1457			      ; address of the block itself. 
1457 eb			      ex    DE, HL 
1458 11 fc ff		      ld    DE, -4 
145b 19			      add   HL, DE 
145c			 
145c			      ; An allocated block must have a null next block pointer in it 
145c 7e			      ld    A, (HL) 
145d 23			      inc   HL 
145e b6			      or    (HL) 
145f c2 07 15		      jp    NZ, free_done 
1462			 
1462 2b			      dec   HL 
1463			 
1463 44			      ld    B, H                    ; Copy HL to BC 
1464 4d			      ld    C, L 
1465			 
1465			      ; Loop through the free list to find the first block with an address 
1465			      ; higher than the block being freed 
1465 21 0a 80		      ld    HL, free_list 
1468			 
1468			free_find_higher_block: 
1468 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1469 23			      inc   HL 
146a 56			      ld    D, (HL) 
146b 2b			      dec   HL 
146c			 
146c dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
146f dd 72 01		      ld    (IX+1), D 
1472 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1475 dd 74 03		      ld    (IX+3), H 
1478			 
1478 78			      ld    A, B                    ; Check if DE is greater than BC 
1479 ba			      cp    D                       ; Compare MSB first 
147a 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
147c 30 04		      jr    NC, free_find_higher_block_skip 
147e 79			      ld    A, C 
147f bb			      cp    E                       ; Then compare LSB 
1480 38 08		      jr    C, free_found_higher_block 
1482			 
1482			free_find_higher_block_skip: 
1482 7a			      ld    A, D                    ; Reached the end of the free list? 
1483 b3			      or    E 
1484 ca 07 15		      jp    Z, free_done 
1487			 
1487 eb			      ex    DE, HL 
1488			 
1488 18 de		      jr    free_find_higher_block 
148a			 
148a			free_found_higher_block: 
148a			      ; Insert freed block between prev and next free blocks 
148a 71			      ld    (HL), C                 ; Point prev free block to freed block 
148b 23			      inc   HL 
148c 70			      ld    (HL), B 
148d			 
148d 60			      ld    H, B                    ; Point freed block at next free block 
148e 69			      ld    L, C 
148f 73			      ld    (HL), E 
1490 23			      inc   HL 
1491 72			      ld    (HL), D 
1492			 
1492			      ; Check if the freed block is adjacent to the next free block 
1492 23			      inc   HL                      ; Load size of freed block into HL 
1493 5e			      ld    E, (HL) 
1494 23			      inc   HL 
1495 56			      ld    D, (HL) 
1496 eb			      ex    DE, HL 
1497			 
1497 09			      add   HL, BC                  ; Add addr of freed block and its size 
1498			 
1498 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
149b dd 56 01		      ld    D, (IX+1) 
149e			 
149e b7			      or    A                       ; Clear the carry flag 
149f ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14a1 20 22		      jr    NZ, free_check_adjacent_to_prev 
14a3			 
14a3			      ; Freed block is adjacent to next, merge into one bigger block 
14a3 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14a4 5e			      ld    E, (HL) 
14a5 23			      inc   HL 
14a6 56			      ld    D, (HL) 
14a7 e5			      push  HL                      ; Save ptr to next block for later 
14a8			 
14a8 60			      ld    H, B                    ; Store ptr from next block into freed block 
14a9 69			      ld    L, C 
14aa 73			      ld    (HL), E 
14ab 23			      inc   HL 
14ac 72			      ld    (HL), D 
14ad			 
14ad e1			      pop   HL                      ; Restore ptr to next block 
14ae 23			      inc   HL                      ; Load size of next block into DE 
14af 5e			      ld    E, (HL) 
14b0 23			      inc   HL 
14b1 56			      ld    D, (HL) 
14b2 d5			      push  DE                      ; Save next block size for later 
14b3			 
14b3 60			      ld    H, B                    ; Load size of freed block into HL 
14b4 69			      ld    L, C 
14b5 23			      inc   HL 
14b6 23			      inc   HL 
14b7 5e			      ld    E, (HL) 
14b8 23			      inc   HL 
14b9 56			      ld    D, (HL) 
14ba eb			      ex    DE, HL 
14bb			 
14bb d1			      pop   DE                      ; Restore size of next block 
14bc 19			      add   HL, DE                  ; Add sizes of both blocks 
14bd eb			      ex    DE, HL 
14be			 
14be 60			      ld    H, B                    ; Store new bigger size into freed block 
14bf 69			      ld    L, C 
14c0 23			      inc   HL 
14c1 23			      inc   HL 
14c2 73			      ld    (HL), E 
14c3 23			      inc   HL 
14c4 72			      ld    (HL), D 
14c5			 
14c5			free_check_adjacent_to_prev: 
14c5			      ; Check if the freed block is adjacent to the prev free block 
14c5 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
14c8 dd 66 03		      ld    H, (IX+3) 
14cb			 
14cb 23			      inc   HL                      ; Size of prev free block into DE 
14cc 23			      inc   HL 
14cd 5e			      ld    E, (HL) 
14ce 23			      inc   HL 
14cf 56			      ld    D, (HL) 
14d0 2b			      dec   HL 
14d1 2b			      dec   HL 
14d2 2b			      dec   HL 
14d3			 
14d3 19			      add   HL, DE                  ; Add prev block addr and size 
14d4			 
14d4 b7			      or    A                       ; Clear the carry flag 
14d5 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
14d7 20 2e		      jr    NZ, free_done 
14d9			 
14d9			      ; Freed block is adjacent to prev, merge into one bigger block 
14d9 60			      ld    H, B                    ; Load next ptr from freed block into DE 
14da 69			      ld    L, C 
14db 5e			      ld    E, (HL) 
14dc 23			      inc   HL 
14dd 56			      ld    D, (HL) 
14de e5			      push  HL                      ; Save freed block ptr for later 
14df			 
14df dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
14e2 dd 66 03		      ld    H, (IX+3) 
14e5 73			      ld    (HL), E 
14e6 23			      inc   HL 
14e7 72			      ld    (HL), D 
14e8			 
14e8 e1			      pop   HL                      ; Restore freed block ptr 
14e9 23			      inc   HL                      ; Load size of freed block into DE 
14ea 5e			      ld    E, (HL) 
14eb 23			      inc   HL 
14ec 56			      ld    D, (HL) 
14ed d5			      push  DE                      ; Save freed block size for later 
14ee			 
14ee dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
14f1 dd 66 03		      ld    H, (IX+3) 
14f4 23			      inc   HL 
14f5 23			      inc   HL 
14f6 5e			      ld    E, (HL) 
14f7 23			      inc   HL 
14f8 56			      ld    D, (HL) 
14f9			 
14f9 e1			      pop   HL                      ; Add sizes of both blocks 
14fa 19			      add   HL, DE 
14fb eb			      ex    DE, HL 
14fc			 
14fc dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
14ff dd 66 03		      ld    H, (IX+3) 
1502 23			      inc   HL 
1503 23			      inc   HL 
1504 73			      ld    (HL), E 
1505 23			      inc   HL 
1506 72			      ld    (HL), D 
1507			 
1507			free_done: 
1507 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
150a 39			      add   HL, SP 
150b f9			      ld    SP, HL 
150c			 
150c			free_early_exit: 
150c dd e1		      pop   IX 
150e d1			      pop   DE 
150f c1			      pop   BC 
1510			 
1510 c9			      ret 
1511			 
1511			; moved to firmware.asm 
1511			; 
1511			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1511			;                  .dw   0 
1511			 
1511			 
1511			endif 
1511			 
1511			 
1511			if MALLOC_3 
1511			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1511			;heap_start        .equ  0x9000      ; Starting address of heap 
1511			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1511			; 
1511			 ;     .org 0 
1511			  ;    jp    main 
1511			; 
1511			; 
1511			 ;     .org  0x100 
1511			;main: 
1511			 ;     ld    HL, 0x8100 
1511			  ;    ld    SP, HL 
1511			; 
1511			;      call  heap_init 
1511			 
1511			      ; Make some allocations 
1511			;      ld    HL, 12 
1511			;      call  malloc            ; Allocates 0x9004 
1511			; 
1511			 ;     ld    HL, 12 
1511			;      call  malloc            ; Allocates 0x9014 
1511			 
1511			;      ld    HL, 12 
1511			;      call  malloc            ; Allocates 0x9024 
1511			 
1511			      ; Free some allocations 
1511			;      ld    HL, 0x9014 
1511			;      call  free 
1511			 
1511			;      ld    HL, 0x9004 
1511			;      call  free 
1511			; 
1511			;      ld    HL, 0x9024 
1511			;      call  free 
1511			 
1511			 
1511			 ;     halt 
1511			 
1511			 
1511			;------------------------------------------------------------------------------ 
1511			;     heap_init                                                               : 
1511			;                                                                             : 
1511			; Description                                                                 : 
1511			;     Initialise the heap and make it ready for malloc and free operations.   : 
1511			;                                                                             : 
1511			;     The heap is maintained as a linked list, starting with an initial       : 
1511			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1511			;     the first free block in the heap. Each block then points to the next    : 
1511			;     free block within the heap, and the free list ends at the first block   : 
1511			;     with a null pointer to the next free block.                             : 
1511			;                                                                             : 
1511			; Parameters                                                                  : 
1511			;     Inputs are compile-time only. Two defines which specify the starting    : 
1511			;     address of the heap and its size are required, along with a memory      : 
1511			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1511			;     principally stores a pointer to the first free block in the heap.       : 
1511			;                                                                             : 
1511			; Returns                                                                     : 
1511			;     Nothing                                                                 : 
1511			;------------------------------------------------------------------------------ 
1511			heap_init: 
1511			      push  HL 
1511			 
1511			      ; Initialise free list struct 
1511			      ld    HL, heap_start 
1511			      ld    (free_list), HL 
1511			      ld    HL, 0 
1511			      ld    (free_list+2), HL 
1511			 
1511			      ; Insert first free block at bottom of heap, consumes entire heap 
1511			      ld    HL, heap_start+heap_size-4 
1511			      ld    (heap_start), HL        ; Next block (end of free list) 
1511			      ld    HL, heap_size-4 
1511			      ld    (heap_start+2), HL      ; Block size 
1511			 
1511			      ; Insert end of free list block at top of heap - two null words will 
1511			      ; terminate the free list 
1511			      ld    HL, 0 
1511			      ld    (heap_start+heap_size-2), HL 
1511			      ld    (heap_start+heap_size-4), HL 
1511			 
1511			      pop   HL 
1511			 
1511			      ret 
1511			 
1511			 
1511			;------------------------------------------------------------------------------ 
1511			;     malloc                                                                  : 
1511			;                                                                             : 
1511			; Description                                                                 : 
1511			;     Allocates the wanted space from the heap and returns the address of the : 
1511			;     first useable byte of the allocation.                                   : 
1511			;                                                                             : 
1511			;     Allocations can happen in one of two ways:                              : 
1511			;                                                                             : 
1511			;     1. A free block may be found which is the exact size wanted. In this    : 
1511			;        case the block is removed from the free list and retuedn to the      : 
1511			;        caller.                                                              : 
1511			;     2. A free block may be found which is larger than the size wanted. In   : 
1511			;        this case, the larger block is split into two. The first portion of  : 
1511			;        this block will become the requested space by the malloc call and    : 
1511			;        is returned to the caller. The second portion becomes a new free     : 
1511			;        block, and the free list is adjusted to maintain continuity via this : 
1511			;        newly created block.                                                 : 
1511			;                                                                             : 
1511			;     malloc does not set any initial value in the allocated space, the       : 
1511			;     caller is required to do this as required.                              : 
1511			;                                                                             : 
1511			;     This implementation of malloc uses the stack exclusively, and is        : 
1511			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1511			;     advisable to disable interrupts before calling malloc, and recommended  : 
1511			;     to avoid the use of malloc inside ISRs in general.                      : 
1511			;                                                                             : 
1511			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1511			;                                                                             : 
1511			; Parameters                                                                  : 
1511			;     HL  Number of bytes wanted                                              : 
1511			;                                                                             : 
1511			; Returns                                                                     : 
1511			;     HL  Address of the first useable byte of the allocation                 : 
1511			;                                                                             : 
1511			; Flags                                                                       : 
1511			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1511			;                                                                             : 
1511			; Stack frame                                                                 : 
1511			;       |             |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     BC      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     DE      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     IX      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |  prev_free  |                                                       : 
1511			;   +4  +-------------+                                                       : 
1511			;       |  this_free  |                                                       : 
1511			;   +2  +-------------+                                                       : 
1511			;       |  next_free  |                                                       : 
1511			;   +0  +-------------+                                                       : 
1511			;       |             |                                                       : 
1511			;                                                                             : 
1511			;------------------------------------------------------------------------------ 
1511			malloc: 
1511			      push  BC 
1511			      push  DE 
1511			      push  IX 
1511			 
1511			      ld    A, H                    ; Exit if no space requested 
1511			      or    L 
1511			      jp    Z, malloc_early_exit 
1511			 
1511			      ; Set up stack frame 
1511			      ex    DE, HL 
1511			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1511			      add   HL, SP 
1511			      ld    SP, HL 
1511			      ld    IX, 0                   ; Use IX as a frame pointer 
1511			      add   IX, SP 
1511			 
1511			      ; Setup initial state 
1511			      ld    HL, 4                   ; want must also include space used by block struct 
1511			      add   HL, DE 
1511			 
1511			      ld    B, H                    ; Move want to BC 
1511			      ld    C, L 
1511			 
1511			      ld    HL, free_list           ; Store prev_free ptr to stack 
1511			      ld    (IX+4), L 
1511			      ld    (IX+5), H 
1511			 
1511			      ld    E, (HL)                 ; Store this_free ptr to stack 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      ld    (IX+2), E 
1511			      ld    (IX+3), D 
1511			      ex    DE, HL                  ; this_free ptr into HL 
1511			 
1511			      ; Loop through free block list to find some space 
1511			malloc_find_space: 
1511			      ld    E, (HL)                 ; Load next_free ptr into DE 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			 
1511			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1511			      or    E 
1511			      jp    Z, malloc_no_space 
1511			 
1511			      ld    (IX+0), E               ; Store next_free ptr to stack 
1511			      ld    (IX+1), D 
1511			 
1511			      ; Does this block have enough space to make the allocation? 
1511			      inc   HL                      ; Load free block size into DE 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			 
1511			      ex    DE, HL                  ; Check size of block against want 
1511			      or    A                       ; Ensure carry flag clear 
1511			      sbc   HL, BC 
1511			      push  HL                      ; Store the result for later (new block size) 
1511			 
1511			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1511			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1511			 
1511			      ; this_free block is not big enough, setup ptrs to test next free block 
1511			      pop   HL                      ; Discard previous result 
1511			 
1511			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1511			      ld    H, (IX+3) 
1511			      ld    (IX+4), L 
1511			      ld    (IX+5), H 
1511			 
1511			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1511			      ld    H, (IX+1) 
1511			      ld    (IX+2), L 
1511			      ld    (IX+3), H 
1511			 
1511			      jr    malloc_find_space 
1511			 
1511			      ; split a bigger block into two - requested size and remaining size 
1511			malloc_alloc_split: 
1511			      ex    DE, HL                  ; Calculate address of new free block 
1511			      dec   HL 
1511			      dec   HL 
1511			      dec   HL 
1511			      add   HL, BC 
1511			 
1511			      ; Create a new block and point it at next_free 
1511			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1511			      ld    D, (IX+1) 
1511			 
1511			      ld    (HL), E                 ; Store next_free ptr into new block 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      pop   DE                      ; Store size of new block into new block 
1511			      inc   HL 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      ; Update this_free ptr to point to new block 
1511			      dec   HL 
1511			      dec   HL 
1511			      dec   HL 
1511			 
1511			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1511			      ld    D, (IX+3) 
1511			 
1511			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1511			      ld    (IX+3), H 
1511			 
1511			      ; Modify this_free block to be allocation 
1511			      ex    DE, HL 
1511			      xor   A                       ; Null the next block ptr of allocated block 
1511			      ld    (HL), A 
1511			      inc   HL 
1511			      ld    (HL), A 
1511			 
1511			      inc   HL                      ; Store want size into allocated block 
1511			      ld    (HL), C 
1511			      inc   HL 
1511			      ld    (HL), B 
1511			      inc   HL 
1511			      push  HL                      ; Address of allocation to return 
1511			 
1511			      jr    malloc_update_links 
1511			 
1511			malloc_alloc_fit: 
1511			      pop   HL                      ; Dont need new block size, want is exact fit 
1511			 
1511			      ; Modify this_free block to be allocation 
1511			      ex    DE, HL 
1511			      dec   HL 
1511			      dec   HL 
1511			      dec   HL 
1511			 
1511			      xor   A                       ; Null the next block ptr of allocated block 
1511			      ld    (HL), A 
1511			      inc   HL 
1511			      ld    (HL), A 
1511			 
1511			      inc   HL                      ; Store address of allocation to return 
1511			      inc   HL 
1511			      inc   HL 
1511			      push  HL 
1511			 
1511			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1511			      ld    L, (IX+0)               ; next_free to HL 
1511			      ld    H, (IX+1) 
1511			 
1511			      ld    (IX+2), L               ; HL to this_free 
1511			      ld    (IX+3), H 
1511			 
1511			 
1511			malloc_update_links: 
1511			      ; Update prev_free ptr to point to this_free 
1511			      ld    L, (IX+4)               ; prev_free ptr to HL 
1511			      ld    H, (IX+5) 
1511			 
1511			      ld    E, (IX+2)               ; this_free ptr to DE 
1511			      ld    D, (IX+3) 
1511			 
1511			      ld    (HL), E                 ; this_free ptr into prev_free 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      ; Clear the Z flag to indicate successful allocation 
1511			      ld    A, D 
1511			      or    E 
1511			 
1511			      pop   DE                      ; Address of allocation 
1511			 
1511			malloc_no_space: 
1511			      ld    HL, 6                   ; Clean up stack frame 
1511			      add   HL, SP 
1511			      ld    SP, HL 
1511			 
1511			      ex    DE, HL                  ; Alloc addr into HL for return 
1511			 
1511			malloc_early_exit: 
1511			      pop   IX 
1511			      pop   DE 
1511			      pop   BC 
1511			 
1511			      ret 
1511			 
1511			 
1511			;------------------------------------------------------------------------------ 
1511			;     free                                                                    : 
1511			;                                                                             : 
1511			; Description                                                                 : 
1511			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1511			;     returned by malloc, otherwise the behaviour is undefined.               : 
1511			;                                                                             : 
1511			;     Where possible, directly adjacent free blocks will be merged together   : 
1511			;     into larger blocks to help ensure that the heap does not become         : 
1511			;     excessively fragmented.                                                 : 
1511			;                                                                             : 
1511			;     free does not clear or set any other value into the freed space, and    : 
1511			;     therefore its contents may be visible through subsequent malloc's. The  : 
1511			;     caller should clear the freed space as required.                        : 
1511			;                                                                             : 
1511			;     This implementation of free uses the stack exclusively, and is          : 
1511			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1511			;     advisable to disable interrupts before calling free, and recommended    : 
1511			;     to avoid the use of free inside ISRs in general.                        : 
1511			;                                                                             : 
1511			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1511			;                                                                             : 
1511			; Parameters                                                                  : 
1511			;     HL  Pointer to address of first byte of allocation to be freed          : 
1511			;                                                                             : 
1511			; Returns                                                                     : 
1511			;     Nothing                                                                 : 
1511			;                                                                             : 
1511			; Stack frame                                                                 : 
1511			;       |             |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     BC      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     DE      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     IX      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |  prev_free  |                                                       : 
1511			;   +2  +-------------+                                                       : 
1511			;       |  next_free  |                                                       : 
1511			;   +0  +-------------+                                                       : 
1511			;       |             |                                                       : 
1511			;                                                                             : 
1511			;------------------------------------------------------------------------------ 
1511			free: 
1511			      push  BC 
1511			      push  DE 
1511			      push  IX 
1511			 
1511			      ld    A, H                    ; Exit if ptr is null 
1511			      or    L 
1511			      jp    Z, free_early_exit 
1511			 
1511			      ; Set up stack frame 
1511			      ex    DE, HL 
1511			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1511			      add   HL, SP 
1511			      ld    SP, HL 
1511			      ld    IX, 0                   ; Use IX as a frame pointer 
1511			      add   IX, SP 
1511			 
1511			      ; The address in HL points to the start of the useable allocated space, 
1511			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1511			      ; address of the block itself. 
1511			      ex    DE, HL 
1511			      ld    DE, -4 
1511			      add   HL, DE 
1511			 
1511			      ; An allocated block must have a null next block pointer in it 
1511			      ld    A, (HL) 
1511			      inc   HL 
1511			      or    (HL) 
1511			      jp    NZ, free_done 
1511			 
1511			      dec   HL 
1511			 
1511			      ld    B, H                    ; Copy HL to BC 
1511			      ld    C, L 
1511			 
1511			      ; Loop through the free list to find the first block with an address 
1511			      ; higher than the block being freed 
1511			      ld    HL, free_list 
1511			 
1511			free_find_higher_block: 
1511			      ld    E, (HL)                 ; Load next ptr from free block 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      dec   HL 
1511			 
1511			      ld    (IX+0), E               ; Save ptr to next free block 
1511			      ld    (IX+1), D 
1511			      ld    (IX+2), L               ; Save ptr to prev free block 
1511			      ld    (IX+3), H 
1511			 
1511			      ld    A, B                    ; Check if DE is greater than BC 
1511			      cp    D                       ; Compare MSB first 
1511			      jr    Z, $+4                  ; MSB the same, compare LSB 
1511			      jr    NC, free_find_higher_block_skip 
1511			      ld    A, C 
1511			      cp    E                       ; Then compare LSB 
1511			      jr    C, free_found_higher_block 
1511			 
1511			free_find_higher_block_skip: 
1511			      ld    A, D                    ; Reached the end of the free list? 
1511			      or    E 
1511			      jp    Z, free_done 
1511			 
1511			      ex    DE, HL 
1511			 
1511			      jr    free_find_higher_block 
1511			 
1511			free_found_higher_block: 
1511			      ; Insert freed block between prev and next free blocks 
1511			      ld    (HL), C                 ; Point prev free block to freed block 
1511			      inc   HL 
1511			      ld    (HL), B 
1511			 
1511			      ld    H, B                    ; Point freed block at next free block 
1511			      ld    L, C 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      ; Check if the freed block is adjacent to the next free block 
1511			      inc   HL                      ; Load size of freed block into HL 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      ex    DE, HL 
1511			 
1511			      add   HL, BC                  ; Add addr of freed block and its size 
1511			 
1511			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1511			      ld    D, (IX+1) 
1511			 
1511			      or    A                       ; Clear the carry flag 
1511			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1511			      jr    NZ, free_check_adjacent_to_prev 
1511			 
1511			      ; Freed block is adjacent to next, merge into one bigger block 
1511			      ex    DE, HL                  ; Load next ptr from next block into DE 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      push  HL                      ; Save ptr to next block for later 
1511			 
1511			      ld    H, B                    ; Store ptr from next block into freed block 
1511			      ld    L, C 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      pop   HL                      ; Restore ptr to next block 
1511			      inc   HL                      ; Load size of next block into DE 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      push  DE                      ; Save next block size for later 
1511			 
1511			      ld    H, B                    ; Load size of freed block into HL 
1511			      ld    L, C 
1511			      inc   HL 
1511			      inc   HL 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      ex    DE, HL 
1511			 
1511			      pop   DE                      ; Restore size of next block 
1511			      add   HL, DE                  ; Add sizes of both blocks 
1511			      ex    DE, HL 
1511			 
1511			      ld    H, B                    ; Store new bigger size into freed block 
1511			      ld    L, C 
1511			      inc   HL 
1511			      inc   HL 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			free_check_adjacent_to_prev: 
1511			      ; Check if the freed block is adjacent to the prev free block 
1511			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1511			      ld    H, (IX+3) 
1511			 
1511			      inc   HL                      ; Size of prev free block into DE 
1511			      inc   HL 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      dec   HL 
1511			      dec   HL 
1511			      dec   HL 
1511			 
1511			      add   HL, DE                  ; Add prev block addr and size 
1511			 
1511			      or    A                       ; Clear the carry flag 
1511			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1511			      jr    NZ, free_done 
1511			 
1511			      ; Freed block is adjacent to prev, merge into one bigger block 
1511			      ld    H, B                    ; Load next ptr from freed block into DE 
1511			      ld    L, C 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      push  HL                      ; Save freed block ptr for later 
1511			 
1511			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1511			      ld    H, (IX+3) 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      pop   HL                      ; Restore freed block ptr 
1511			      inc   HL                      ; Load size of freed block into DE 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      push  DE                      ; Save freed block size for later 
1511			 
1511			      ld    L, (IX+2)               ; Load size of prev block into DE 
1511			      ld    H, (IX+3) 
1511			      inc   HL 
1511			      inc   HL 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			 
1511			      pop   HL                      ; Add sizes of both blocks 
1511			      add   HL, DE 
1511			      ex    DE, HL 
1511			 
1511			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1511			      ld    H, (IX+3) 
1511			      inc   HL 
1511			      inc   HL 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			free_done: 
1511			      ld    HL, 4                   ; Clean up stack frame 
1511			      add   HL, SP 
1511			      ld    SP, HL 
1511			 
1511			free_early_exit: 
1511			      pop   IX 
1511			      pop   DE 
1511			      pop   BC 
1511			 
1511			      ret 
1511			 
1511			 
1511			;      .org 0x8000 
1511			; 
1511			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1511			 ;                 .dw   0 
1511			 
1511			endif 
1511			 
1511			 
1511			if MALLOC_4 
1511			 
1511			; My memory allocation code. Very very simple.... 
1511			; allocate space under 250 chars 
1511			 
1511			heap_init: 
1511				; init start of heap as zero 
1511				;  
1511			 
1511				ld hl, heap_start 
1511			;	ld a, 0 
1511				ld (hl), 0      ; empty block 
1511				inc hl 
1511			;	ld a, 0 
1511				ld (hl), 0      ; length of block 
1511				; write end of list 
1511				inc hl 
1511				ld a,(hl) 
1511				inc hl 
1511				ld a,(hl) 
1511				 
1511			 
1511				; init some malloc vars 
1511			 
1511				ld hl, 0 
1511				ld (free_list), hl       ; store last malloc location 
1511			 
1511				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1511			;	ld a, 0 
1511				ld (hl), 0 
1511			 
1511			 
1511				ld hl, heap_start 
1511				;  
1511				  
1511				ret 
1511			 
1511			 
1511			;    free block marker 
1511			;    requested size  
1511			;    pointer to next block 
1511			;    .... 
1511			;    next block marker 
1511			 
1511			 
1511			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1511			; 
1511			 
1511			 
1511			malloc:  
1511				push de 
1511				push bc 
1511				push af 
1511			 
1511				; hl space required 
1511				 
1511				ld c, l    ; hold space   (TODO only a max of 255) 
1511			 
1511			;	inc c     ; TODO BUG need to fix memory leak on push str 
1511			;	inc c 
1511			;	inc c 
1511			;	inc c 
1511			;	inc c 
1511			;	inc c 
1511			;	inc c 
1511			 
1511			 
1511			 
1511				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1511			 
1511				ld a, (free_list+3) 
1511			;	cp 0 
1511				or a 
1511				jr z, .contheap 
1511			 
1511				ld hl, (free_list)     ; get last alloc 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mrs" 
1511						CALLMONITOR 
1511					endif 
1511				jr .startalloc 
1511			 
1511			.contheap: 
1511				ld hl, heap_start 
1511			 
1511			.startalloc: 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mym" 
1511						CALLMONITOR 
1511					endif 
1511			.findblock: 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mmf" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511				ld a,(hl)  
1511				; if byte is zero then clear to use 
1511			 
1511			;	cp 0 
1511				or a 
1511				jr z, .foundemptyblock 
1511			 
1511				; if byte is not clear 
1511				;     then byte is offset to next block 
1511			 
1511				inc hl 
1511				ld a, (hl) ; get size 
1511			.nextblock:	inc hl 
1511					ld e, (hl) 
1511					inc hl 
1511					ld d, (hl) 
1511					ex de, hl 
1511			;	inc hl  ; move past the store space 
1511			;	inc hl  ; move past zero index  
1511			 
1511				; TODO detect no more space 
1511			 
1511				push hl 
1511				ld de, heap_end 
1511				call cmp16 
1511				pop hl 
1511				jr nc, .nospace 
1511			 
1511				jr .findblock 
1511			 
1511			.nospace: ld hl, 0 
1511				jp .exit 
1511			 
1511			 
1511			.foundemptyblock:	 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mme" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511			; TODO has block enough space if reusing??? 
1511			 
1511				;  
1511			 
1511			; see if this block has been previously used 
1511				inc hl 
1511				ld a, (hl) 
1511				dec hl 
1511			;	cp 0 
1511				or a 
1511				jr z, .newblock 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "meR" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511			; no reusing previously allocated block 
1511			 
1511			; is it smaller than previously used? 
1511				 
1511				inc hl    ; move to size 
1511				ld a, c 
1511				sub (hl)        ; we want c < (hl) 
1511				dec hl    ; move back to marker 
1511			        jr z, .findblock 
1511			 
1511				; update with the new size which should be lower 
1511			 
1511			        ;inc  hl   ; negate next move. move back to size  
1511			 
1511			.newblock: 
1511				; need to be at marker here 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "meN" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511			 
1511				ld a, c 
1511			 
1511				ld (free_list+3), a	 ; flag resume from last malloc  
1511				ld (free_list), hl    ; save out last location 
1511			 
1511			 
1511				;inc a     ; space for length byte 
1511				ld (hl), a     ; save block in use marker 
1511			 
1511				inc hl   ; move to space marker 
1511				ld (hl), a    ; save new space 
1511			 
1511				inc hl   ; move to start of allocated area 
1511				 
1511			;	push hl     ; save where we are - 1  
1511			 
1511			;	inc hl  ; move past zero index  
1511				; skip space to set down new marker 
1511			 
1511				; provide some extra space for now 
1511			 
1511				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1511				inc a 
1511				inc a 
1511			 
1511				push hl   ; save where we are in the node block 
1511			 
1511				call addatohl 
1511			 
1511				; write linked list point 
1511			 
1511				pop de     ; get our node position 
1511				ex de, hl 
1511			 
1511				ld (hl), e 
1511				inc hl 
1511				ld (hl), d 
1511			 
1511				inc hl 
1511			 
1511				; now at start of allocated data so save pointer 
1511			 
1511				push hl 
1511			 
1511				; jump to position of next node and setup empty header in DE 
1511			 
1511				ex de, hl 
1511			 
1511			;	inc hl ; move past end of block 
1511			 
1511			;	ld a, 0 
1511				ld (hl), 0   ; empty marker 
1511				inc hl 
1511				ld (hl), 0   ; size 
1511				inc hl  
1511				ld (hl), 0   ; ptr 
1511				inc hl 
1511				ld (hl), 0   ; ptr 
1511			 
1511			 
1511				pop hl 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mmr" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511			.exit: 
1511				pop af 
1511				pop bc 
1511				pop de  
1511				ret 
1511			 
1511			 
1511			 
1511			 
1511			free:  
1511				push hl 
1511				push af 
1511				; get address in hl 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "fre" 
1511						CALLMONITOR 
1511					endif 
1511				; data is at hl - move to block count 
1511				dec hl 
1511				dec hl    ; get past pointer 
1511				dec hl 
1511			 
1511				ld a, (hl)    ; need this for a validation check 
1511			 
1511				dec hl    ; move to block marker 
1511			 
1511				; now check that the block count and block marker are the same  
1511			        ; this checks that we are on a malloc node and not random memory 
1511			        ; OK a faint chance this could be a problem but rare - famous last words! 
1511			 
1511				ld c, a 
1511				ld a, (hl)    
1511			 
1511				cp c 
1511				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1511			 
1511				; yes good chance we are on a malloc node 
1511			 
1511			;	ld a, 0      
1511				ld (hl), 0   ; mark as free 
1511			 
1511				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1511			 
1511			.freeignore:  
1511			 
1511				pop af 
1511				pop hl 
1511			 
1511				ret 
1511			 
1511			 
1511			 
1511			endif 
1511			 
1511			; eof 
# End of file firmware_memory.asm
1511			  
1511			; device C  
1511			; Now handled by SPI  
1511			;if SOUND_ENABLE  
1511			;	include "firmware_sound.asm"  
1511			;endif  
1511			  
1511			include "firmware_diags.asm"  
1511			; Hardware diags menu 
1511			 
1511			 
1511			config: 
1511			 
1511 3e 00			ld a, 0 
1513 21 37 15			ld hl, .configmn 
1516 cd ac 0d			call menu 
1519			 
1519 fe 00			cp 0 
151b c8				ret z 
151c			 
151c			;	cp 1 
151c			;	call z, .savetostore 
151c			 
151c fe 01			cp 1 
151e			if STARTUP_V1 
151e				call z, .selautoload 
151e			endif 
151e			 
151e			if STARTUP_V2 
151e cc 43 15			call z, .enautoload 
1521			endif 
1521 fe 02			cp 2 
1523 cc 5a 15			call z, .disautoload 
1526			;	cp 3 
1526			;	call z, .selbank 
1526 fe 03			cp 3 
1528 cc c5 17			call z, .debug_tog 
152b fe 04			cp 4 
152d cc 93 18			call z, .bpsgo 
1530			;	cp 5 
1530			;	call z, hardware_diags 
1530			if STARTUP_V2 
1530 fe 05			cp 5 
1532 cc 86 15			call z, create_startup 
1535			endif 
1535 18 da			jr config 
1537			 
1537			.configmn: 
1537			;	dw prom_c3 
1537 81 1a			dw prom_c2 
1539 97 1a			dw prom_c2a 
153b			;	dw prom_c2b 
153b			;	dw prom_c4 
153b 0e 1b			dw prom_m4 
153d 29 1b			dw prom_m4b 
153f			;	dw prom_c1 
153f			if STARTUP_V2 
153f 31 1b			dw prom_c9 
1541			endif 
1541 00 00			dw 0 
1543				 
1543			 
1543			if STARTUP_V2 
1543			.enautoload: 
1543				if STORAGE_SE 
1543 3e fe			ld a, $fe      ; bit 0 clear 
1545 32 92 f9			ld (spi_device), a 
1548			 
1548 cd 05 05			call storage_get_block_0 
154b			 
154b 3e 01			ld a, 1 
154d 32 cd f9			ld (store_page+STORE_0_AUTOFILE), a 
1550			 
1550 21 00 00				ld hl, 0 
1553 11 ac f9				ld de, store_page 
1556 cd bc 04			call storage_write_block	 ; save update 
1559				else 
1559			 
1559				ld hl, prom_notav 
1559				ld de, prom_empty 
1559				call info_panel 
1559				endif 
1559			 
1559			 
1559 c9				ret 
155a			endif 
155a			 
155a			.disautoload: 
155a				if STORAGE_SE 
155a 3e fe			ld a, $fe      ; bit 0 clear 
155c 32 92 f9			ld (spi_device), a 
155f			 
155f cd 05 05			call storage_get_block_0 
1562			 
1562 3e 00			ld a, 0 
1564 32 cd f9			ld (store_page+STORE_0_AUTOFILE), a 
1567			 
1567 21 00 00				ld hl, 0 
156a 11 ac f9				ld de, store_page 
156d cd bc 04			call storage_write_block	 ; save update 
1570				else 
1570			 
1570				ld hl, prom_notav 
1570				ld de, prom_empty 
1570				call info_panel 
1570				endif 
1570			 
1570			 
1570 c9				ret 
1571			 
1571			if STARTUP_V1 
1571			 
1571			; Select auto start 
1571			 
1571			.selautoload: 
1571			 
1571				 
1571				if STORAGE_SE 
1571			 
1571					call config_dir 
1571				        ld hl, scratch 
1571					ld a, 0 
1571					call menu 
1571			 
1571					cp 0 
1571					ret z 
1571			 
1571					dec a 
1571			 
1571			 
1571					; locate menu option 
1571			 
1571					ld hl, scratch 
1571					call table_lookup 
1571			 
1571					if DEBUG_FORTH_WORDS 
1571						DMARK "ALl" 
1571						CALLMONITOR 
1571					endif 
1571					; with the pointer to the menu it, the byte following the zero term is the file id 
1571			 
1571					ld a, 0 
1571					ld bc, 50   ; max of bytes to look at 
1571					cpir  
1571			 
1571					if DEBUG_FORTH_WORDS 
1571						DMARK "ALb" 
1571						CALLMONITOR 
1571					endif 
1571					;inc hl 
1571			 
1571					ld a, (hl)   ; file id 
1571					 
1571				        ; save bank and file ids 
1571			 
1571					push af 
1571			 
1571			; TODO need to save to block 0 on bank 1	 
1571			 
1571					call storage_get_block_0 
1571			 
1571					if DEBUG_FORTH_WORDS 
1571						DMARK "AL0" 
1571						CALLMONITOR 
1571					endif 
1571					pop af 
1571			 
1571					ld (store_page+STORE_0_FILERUN),a 
1571					 
1571					; save bank id 
1571			 
1571					ld a,(spi_device) 
1571					ld (store_page+STORE_0_BANKRUN),a 
1571			 
1571					; enable auto run of store file 
1571			 
1571					ld a, 1 
1571					ld (store_page+STORE_0_AUTOFILE),a 
1571			 
1571					; save buffer 
1571			 
1571					ld hl, 0 
1571					ld de, store_page 
1571					if DEBUG_FORTH_WORDS 
1571						DMARK "ALw" 
1571						CALLMONITOR 
1571					endif 
1571				call storage_write_block	 ; save update 
1571			  
1571			 
1571			 
1571			 
1571					ld hl, scratch 
1571					call config_fdir 
1571			 
1571				else 
1571			 
1571				ld hl, prom_notav 
1571				ld de, prom_empty 
1571				call info_panel 
1571			 
1571				endif 
1571				ret 
1571			endif 
1571			 
1571			 
1571			; Select storage bank 
1571			 
1571			.selbank: 
1571			 
1571			;	if STORAGE_SE 
1571			;	else 
1571			 
1571 21 46 1b			ld hl, prom_notav 
1574 11 5c 1b			ld de, prom_empty 
1577 cd 0e 0d			call info_panel 
157a			;	endif 
157a				 
157a c9				ret 
157b			 
157b			if STORAGE_SE 
157b			 
157b			.config_ldir:   
157b				; Load storage bank labels into menu array 
157b			 
157b				 
157b			 
157b			 
157b c9				ret 
157c			 
157c			 
157c			endif 
157c			 
157c			 
157c			; Save user words to storage 
157c			 
157c			.savetostore: 
157c			 
157c			;	if STORAGE_SE 
157c			; 
157c			;		call config_dir 
157c			;	        ld hl, scratch 
157c			;		ld a, 0 
157c			;		call menu 
157c			;		 
157c			;		ld hl, scratch 
157c			;		call config_fdir 
157c			; 
157c			;	else 
157c			 
157c 21 46 1b			ld hl, prom_notav 
157f 11 5c 1b			ld de, prom_empty 
1582 cd 0e 0d			call info_panel 
1585			 
1585			;	endif 
1585			 
1585 c9				ret 
1586			 
1586			if STARTUP_V2 
1586			 
1586			create_startup: 
1586			 
1586 3e 00			ld a, 0 
1588 21 ea 16			ld hl, .crstart 
158b cd ac 0d			call menu 
158e			 
158e fe 00			cp 0 
1590 c8				ret z 
1591			 
1591 fe 01			cp 1 
1593 cc cf 15			call z, .genlsword 
1596 fe 02			cp 2 
1598 cc d9 15			call z, .genedword 
159b			 
159b fe 03			cp 3 
159d cc e3 15			call z, .gendemword 
15a0			 
15a0 fe 04			cp 4 
15a2 cc ed 15			call z, .genutlword 
15a5 fe 05			cp 5 
15a7 cc f7 15			call z, .genspiword 
15aa fe 06			cp 6 
15ac cc 01 16			call z, .genkeyword 
15af fe 07			cp 7 
15b1 cc c5 15			call z, .gensoundword 
15b4 fe 08			cp 8 
15b6 cc bb 15			call z, .genhwword 
15b9 18 cb			jr create_startup 
15bb			 
15bb			.genhwword: 
15bb 21 f8 1a			ld hl, crs_hw 
15be 11 4e 16			ld de, .hwworddef 
15c1 cd 0b 16			call .genfile 
15c4 c9				ret 
15c5			.gensoundword: 
15c5 21 ec 1a			ld hl, crs_sound 
15c8 11 5c 16			ld de, .soundworddef 
15cb cd 0b 16			call .genfile 
15ce c9				ret 
15cf			.genlsword: 
15cf 21 ae 1a			ld hl, crs_s1 
15d2 11 82 16			ld de, .lsworddef 
15d5 cd 0b 16			call .genfile 
15d8 c9				ret 
15d9			 
15d9			.genedword: 
15d9 11 86 16			ld de, .edworddef 
15dc 21 b7 1a			ld hl, crs_s2 
15df cd 0b 16			call .genfile 
15e2 c9				ret 
15e3			 
15e3			.gendemword: 
15e3 11 8e 16			ld de, .demoworddef 
15e6 21 c0 1a			ld hl, crs_s3 
15e9 cd 0b 16			call .genfile 
15ec c9				ret 
15ed			 
15ed			.genutlword: 
15ed 21 cc 1a			ld hl, crs_s4 
15f0 11 70 16			ld de, .utilwordef 
15f3 cd 0b 16			call .genfile 
15f6 c9				ret 
15f7			.genspiword: 
15f7 21 d3 1a			ld hl, crs_s5 
15fa 11 b0 16			ld de, .spiworddef 
15fd cd 0b 16			call .genfile 
1600 c9				ret 
1601			.genkeyword: 
1601 21 dd 1a			ld hl, crs_s6 
1604 11 be 16			ld de, .keyworddef 
1607 cd 0b 16			call .genfile 
160a c9				ret 
160b			 
160b			; hl - points to file name 
160b			; de - points to strings to add to file 
160b			 
160b			.genfile: 
160b e5				push hl 
160c d5				push de 
160d			 
160d cd 7c 0d			call clear_display 
1610 3e 00			ld a, display_row_1 
1612 11 3d 16			ld de, .genfiletxt 
1615 cd 8e 0d			call str_at_display 
1618 cd 9e 0d			call update_display 
161b			 
161b d1				pop de 
161c e1				pop hl 
161d			 
161d			 
161d d5				push de 
161e cd 51 08			call storage_create 
1621				; id in hl 
1621 d1				pop de   ; table of strings to add 
1622			 
1622			.genloop: 
1622			 
1622 e5				push hl ; save id for next time around 
1623 d5				push de ; save de for next time around 
1624			 
1624 eb				ex de, hl 
1625 cd d9 22			call loadwordinhl 
1628 eb				ex de, hl 
1629			 
1629				; need hl to be the id 
1629				; need de to be the string ptr 
1629				 
1629 cd 3b 0b			call storage_append 
162c			 
162c d1				pop de 
162d e1				pop hl 
162e			 
162e 13				inc de 
162f 13				inc de 
1630			 
1630 1a				ld a,(de) 
1631 fe 00			cp 0 
1633 20 ed			jr nz, .genloop 
1635 13				inc de 
1636 1a				ld a, (de) 
1637 1b				dec de 
1638 fe 00			cp 0 
163a 20 e6			jr nz, .genloop	 
163c			 
163c c9				ret 
163d			 
163d .. 00		.genfiletxt:  db "Creating file...",0 
164e			 
164e			.hwworddef: 
164e 8e 6c			dw test5 
1650 c6 6c			dw test6 
1652 fe 6c			dw test7 
1654 12 6d			dw test8 
1656 3e 6d			dw test9 
1658 54 6d			dw test10 
165a 00 00			dw 0 
165c			 
165c			.soundworddef: 
165c 79 6d			dw sound1 
165e 9d 6d			dw sound2 
1660 cd 6d			dw sound3 
1662 f2 6d			dw sound4 
1664 ff 6d			dw sound5 
1666 0c 6e			dw sound6 
1668 19 6e			dw sound7 
166a 26 6e			dw sound8 
166c 3e 6e			dw sound9 
166e 00 00			dw 0 
1670			 
1670			.utilwordef: 
1670 b4 6a			dw strncpy 
1672 8f 6a			dw type 
1674 11 6c			dw tuck 
1676 5b 6a			dw clrstack 
1678 14 6a			dw longread 
167a 15 6b			dw start1 
167c 25 6b			dw start2 
167e			; duplicated 
167e			;	dw start3b 
167e			;	dw start3c 
167e 24 6c			dw list 
1680 00 00			dw 0 
1682			 
1682			.lsworddef: 
1682 36 6b			dw start3b 
1684 00 00			dw 0 
1686			 
1686			.edworddef: 
1686 73 66			dw edit1 
1688 94 66			dw edit2 
168a c9 66			dw edit3 
168c 00 00			dw 0 
168e			 
168e			.demoworddef: 
168e 55 6e			dw game1 
1690 66 6e			dw game1a 
1692 c8 6e			dw game1b 
1694 fd 6e			dw game1c 
1696 33 6f			dw game1d 
1698 64 6f			dw game1s 
169a 78 6f			dw game1t 
169c 8d 6f			dw game1f 
169e c1 6f			dw game1z 
16a0 05 70			dw game1zz 
16a2 6e 70			dw ssv2 
16a4 a4 70			dw ssv3 
16a6 c0 70			dw ssv4 
16a8 dc 70			dw ssv5 
16aa f5 70			dw ssv1 
16ac 3d 71			dw ssv1cpm	 
16ae			;	dw game2b 
16ae			;	dw game2bf 
16ae			;	dw game2mba 
16ae			;	dw game2mbas	 
16ae			;	dw game2mbht 
16ae			;	dw game2mbms 
16ae			;	dw game2mb 
16ae			;	dw game3w 
16ae			;	dw game3p 
16ae			;	dw game3sc 
16ae			;	dw game3vsi 
16ae			;	dw game3vs 
16ae 00 00			dw 0 
16b0			 
16b0			 
16b0			.spiworddef: 
16b0			 
16b0 01 67		    dw spi1 
16b2 5a 67		    dw spi2 
16b4 8e 67		    dw spi2b 
16b6 12 68		    dw spi3 
16b8 bc 67		    dw spi4 
16ba e5 67		    dw spi5 
16bc			;    dw spi6 
16bc			;    dw spi7 
16bc			 
16bc			;    dw spi8 
16bc			;    dw spi9 
16bc			;    dw spi10 
16bc 00 00		    dw 0 
16be			 
16be			.keyworddef: 
16be			 
16be 94 71			dw keyup 
16c0 a2 71			dw keydown 
16c2 b2 71			dw keyleft 
16c4 c2 71			dw keyright 
16c6 d3 71			dw 	keyf1 
16c8 e1 71			dw keyf2 
16ca ef 71			dw keyf3 
16cc fd 71			dw keyf4 
16ce 0b 72			dw keyf5 
16d0 19 72			dw keyf6 
16d2 27 72			dw keyf7 
16d4 35 72			dw keyf8 
16d6 43 72			dw keyf9 
16d8 51 72			dw keyf10 
16da 60 72			dw keyf11 
16dc 6f 72			dw keyf12 
16de 7e 72			dw keytab 
16e0 8d 72			dw keycr 
16e2 9b 72			dw keyhome 
16e4 ab 72			dw keyend 
16e6 ba 72			dw keybs 
16e8 00 00			dw 0 
16ea			 
16ea			.crstart: 
16ea ae 1a			dw crs_s1 
16ec b7 1a			dw crs_s2 
16ee c0 1a			dw crs_s3 
16f0 cc 1a			dw crs_s4 
16f2 d3 1a			dw crs_s5 
16f4 dd 1a			dw crs_s6 
16f6 ec 1a			dw crs_sound 
16f8 f8 1a			dw crs_hw 
16fa 00 00			dw 0 
16fc			 
16fc			endif 
16fc			 
16fc			 
16fc			if STORAGE_SE 
16fc			 
16fc			config_fdir: 
16fc				; using the scratch dir go through and release the memory allocated for each string 
16fc				 
16fc 21 f3 f0			ld hl, scratch 
16ff 5e			.cfdir:	ld e,(hl) 
1700 23				inc hl 
1701 56				ld d,(hl) 
1702 23				inc hl 
1703			 
1703 eb				ex de, hl 
1704 cd d5 0f			call ishlzero 
1707 c8				ret z     ; return on null pointer 
1708 cd 42 14			call free 
170b eb				ex de, hl 
170c 18 f1			jr .cfdir 
170e			 
170e			 
170e c9				ret 
170f			 
170f			 
170f			config_dir: 
170f			 
170f				; for the config menus that need to build a directory of storage call this routine 
170f				; it will construct a menu in scratch to pass to menu 
170f			 
170f				; open storage device 
170f			 
170f				; execute DIR to build a list of files and their ids into scratch in menu format 
170f				; once the menu has finished then will need to call config_fdir to release the strings 
170f				 
170f				; c = number items 
170f			 
170f				 
170f cd 05 05			call storage_get_block_0 
1712			 
1712 21 ac f9			ld hl, store_page     ; get current id count 
1715 46				ld b, (hl) 
1716 0e 00			ld c, 0    ; count of files   
1718			 
1718			 
1718 21 f3 f0			ld hl, scratch 
171b 22 a3 f9			ld (store_tmp2), hl    ; location to poke strings 
171e			 
171e				; check for empty drive 
171e			 
171e 3e 00			ld a, 0 
1720 b8				cp b 
1721 ca bb 17			jp z, .dirdone 
1724			 
1724				 
1724					if DEBUG_FORTH_WORDS 
1724						DMARK "Cdc" 
1724 f5				push af  
1725 3a 39 17			ld a, (.dmark)  
1728 32 9d fd			ld (debug_mark),a  
172b 3a 3a 17			ld a, (.dmark+1)  
172e 32 9e fd			ld (debug_mark+1),a  
1731 3a 3b 17			ld a, (.dmark+2)  
1734 32 9f fd			ld (debug_mark+2),a  
1737 18 03			jr .pastdmark  
1739 ..			.dmark: db "Cdc"  
173c f1			.pastdmark: pop af  
173d			endm  
# End of macro DMARK
173d						CALLMONITOR 
173d cd aa fd			call debug_vector  
1740				endm  
# End of macro CALLMONITOR
1740					endif 
1740			 
1740			 
1740			.diritem:	 
1740 c5				push bc 
1741				; for each of the current ids do a search for them and if found push to stack 
1741			 
1741 21 40 00				ld hl, STORE_BLOCK_PHY 
1744 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1746 58					ld e,b 
1747			 
1747 cd 83 07				call storage_findnextid 
174a			 
174a			 
174a					; if found hl will be non zero 
174a			 
174a cd d5 0f				call ishlzero 
174d 28 69				jr z, .dirnotfound 
174f			 
174f					; increase count 
174f			 
174f c1					pop bc	 
1750 0c					inc c 
1751 c5					push bc 
1752					 
1752			 
1752					; get file header and push the file name 
1752			 
1752 11 ac f9				ld de, store_page 
1755 cd 57 04				call storage_read_block 
1758			 
1758					; push file id to stack 
1758				 
1758 3a ac f9				ld a, (store_page) 
175b 26 00				ld h, 0 
175d 6f					ld l, a 
175e			 
175e					;call forth_push_numhl 
175e					; TODO store id 
175e			 
175e e5					push hl 
175f			 
175f					; push extent count to stack  
175f				 
175f 21 af f9				ld hl, store_page+3 
1762			 
1762					; get file name length 
1762			 
1762 cd 04 13				call strlenz   
1765			 
1765 23					inc hl   ; cover zero term 
1766 23					inc hl  ; stick the id at the end of the area 
1767			 
1767 e5					push hl 
1768 c1					pop bc    ; move length to bc 
1769			 
1769 cd 78 13				call malloc 
176c			 
176c					; TODO save malloc area to scratch 
176c			 
176c eb					ex de, hl 
176d 2a a3 f9				ld hl, (store_tmp2) 
1770 73					ld (hl), e 
1771 23					inc hl 
1772 72					ld (hl), d 
1773 23					inc hl 
1774 22 a3 f9				ld (store_tmp2), hl 
1777			 
1777					 
1777			 
1777					;pop hl   ; get source 
1777			;		ex de, hl    ; swap aronund	 
1777			 
1777 21 af f9				ld hl, store_page+3 
177a					if DEBUG_FORTH_WORDS 
177a						DMARK "CFd" 
177a f5				push af  
177b 3a 8f 17			ld a, (.dmark)  
177e 32 9d fd			ld (debug_mark),a  
1781 3a 90 17			ld a, (.dmark+1)  
1784 32 9e fd			ld (debug_mark+1),a  
1787 3a 91 17			ld a, (.dmark+2)  
178a 32 9f fd			ld (debug_mark+2),a  
178d 18 03			jr .pastdmark  
178f ..			.dmark: db "CFd"  
1792 f1			.pastdmark: pop af  
1793			endm  
# End of macro DMARK
1793						CALLMONITOR 
1793 cd aa fd			call debug_vector  
1796				endm  
# End of macro CALLMONITOR
1796					endif 
1796 ed b0				ldir 
1798			 
1798					; de is past string, move back one and store id 
1798					 
1798 1b					dec de 
1799			 
1799					; store file id 
1799			 
1799 e1					pop hl 
179a eb					ex de,hl 
179b 73					ld (hl), e 
179c			 
179c					if DEBUG_FORTH_WORDS 
179c						DMARK "Cdi" 
179c f5				push af  
179d 3a b1 17			ld a, (.dmark)  
17a0 32 9d fd			ld (debug_mark),a  
17a3 3a b2 17			ld a, (.dmark+1)  
17a6 32 9e fd			ld (debug_mark+1),a  
17a9 3a b3 17			ld a, (.dmark+2)  
17ac 32 9f fd			ld (debug_mark+2),a  
17af 18 03			jr .pastdmark  
17b1 ..			.dmark: db "Cdi"  
17b4 f1			.pastdmark: pop af  
17b5			endm  
# End of macro DMARK
17b5						CALLMONITOR 
17b5 cd aa fd			call debug_vector  
17b8				endm  
# End of macro CALLMONITOR
17b8					endif 
17b8					 
17b8			.dirnotfound: 
17b8 c1					pop bc     
17b9 10 85				djnz .diritem 
17bb				 
17bb			.dirdone:	 
17bb			 
17bb			;		ld a, 0 
17bb 2a a3 f9				ld hl, (store_tmp2) 
17be 36 00				ld (hl), 0 
17c0 23					inc hl 
17c1 36 00				ld (hl), 0 
17c3 23					inc hl 
17c4					; push a count of the dir items found 
17c4			 
17c4			;		ld h, 0 
17c4			;		ld l, c 
17c4			 
17c4 c9				ret 
17c5			 
17c5			endif 
17c5			 
17c5			 
17c5			; Settings 
17c5			; Run  
17c5			 
17c5			 
17c5			 
17c5			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
17c5			;;hd_menu2:   db "        2: Editor",0   
17c5			;hd_menu2:   db "        2: Editor       6: Menu",0   
17c5			;hd_menu3:   db "        3: Storage",0 
17c5			;hd_menu4:   db "0=quit  4: Debug",0 
17c5			;hd_don:     db "ON",0 
17c5			;hd_doff:     db "OFF",0 
17c5			; 
17c5			; 
17c5			; 
17c5			;hardware_diags_old:       
17c5			; 
17c5			;.diagmenu: 
17c5			;	call clear_display 
17c5			;	ld a, display_row_1 
17c5			;	ld de, hd_menu1 
17c5			;	call str_at_display 
17c5			; 
17c5			;	ld a, display_row_2 
17c5			;	ld de, hd_menu2 
17c5			;	call str_at_display 
17c5			; 
17c5			;	ld a, display_row_3 
17c5			;	ld de, hd_menu3 
17c5			;	call str_at_display 
17c5			; 
17c5			;	ld a,  display_row_4 
17c5			;	ld de, hd_menu4 
17c5			;	call str_at_display 
17c5			; 
17c5			;	; display debug state 
17c5			; 
17c5			;	ld de, hd_don 
17c5			;	ld a, (os_view_disable) 
17c5			;	cp 0 
17c5			;	jr z, .distog 
17c5			;	ld de, hd_doff 
17c5			;.distog: ld a, display_row_4+17 
17c5			;	call str_at_display 
17c5			; 
17c5			;	call update_display 
17c5			; 
17c5			;	call cin_wait 
17c5			; 
17c5			; 
17c5			; 
17c5			;	cp '4' 
17c5			;	jr nz, .diagn1 
17c5			; 
17c5			;	; debug toggle 
17c5			; 
17c5			;	ld a, (os_view_disable) 
17c5			;	ld b, '*' 
17c5			;	cp 0 
17c5			;	jr z, .debtog 
17c5			;	ld b, 0 
17c5			;.debtog:	 
17c5			;	ld a,b 
17c5			;	ld (os_view_disable),a 
17c5			; 
17c5			;.diagn1: cp '0' 
17c5			;	 ret z 
17c5			; 
17c5			;;	cp '1' 
17c5			;;       jp z, matrix	 
17c5			;;   TODO keyboard matrix test 
17c5			; 
17c5			;	cp '2' 
17c5			;	jp z, .diagedit 
17c5			; 
17c5			;;	cp '6' 
17c5			;;	jp z, .menutest 
17c5			;;if ENABLE_BASIC 
17c5			;;	cp '6' 
17c5			;;	jp z, basic 
17c5			;;endif 
17c5			 ; 
17c5			;	jp .diagmenu 
17c5			; 
17c5			; 
17c5			;	ret 
17c5			 
17c5			 
17c5			.debug_tog: 
17c5 21 ee 17			ld hl, .menudebug 
17c8				 
17c8			;	ld a, (os_view_disable) 
17c8			;	cp '*' 
17c8 3a aa fd			ld a,(debug_vector) 
17cb fe c9			cp $C9   ; RET 
17cd 20 04			jr nz,.tdon  
17cf 3e 01			ld a, 1 
17d1 18 02			jr .tog1 
17d3 3e 00		.tdon: ld a, 0 
17d5			 
17d5			.tog1: 
17d5 cd ac 0d			call menu 
17d8 fe 00			cp 0 
17da c8				ret z 
17db fe 01			cp 1    ; disable debug 
17dd 28 04			jr z, .dtog0 
17df 3e 2a			ld a, '*' 
17e1 18 05			jr .dtogset 
17e3			.dtog0:  
17e3				;ld a, 0 
17e3 cd 81 18			call bp_on 
17e6 18 dd			jr .debug_tog 
17e8			.dtogset:  
17e8				; ld (os_view_disable), a 
17e8 cd 8d 18			call bp_off 
17eb c3 c5 17			jp .debug_tog 
17ee			 
17ee			 
17ee			.menudebug: 
17ee f4 17				dw .m6 
17f0 fd 17				dw .m7 
17f2 00 00				dw 0 
17f4 .. 00		.m6:   db "Debug ON",0 
17fd .. 00		.m7:   db "Debug OFF",0 
1807			;hardware_diags:       
1807			 
1807			ENABLE_HDIAGS: equ 0 
1807			 
1807			if ENABLE_HDIAGS 
1807			.diagm: 
1807				ld hl, .menuitems 
1807				ld a, 0 
1807				call menu 
1807			 
1807			         cp 0 
1807				 ret z 
1807			 
1807				cp 2 
1807				jp z, .diagedit 
1807			 
1807			;	cp '6' 
1807			;	jp z, .menutest 
1807			;if ENABLE_BASIC 
1807			;	cp '6' 
1807			;	jp z, basic 
1807			;endif 
1807			  
1807				jp .diagm 
1807			 
1807				 
1807			.menuitems:   	dw .m1 
1807					dw .m2 
1807					dw .m3 
1807					dw .m5 
1807					dw .m5a 
1807					dw .m5b 
1807					dw 0 
1807			 
1807			 
1807			.m1:   db "Key Matrix",0 
1807			.m2:   db "Editor",0 
1807			.m3:   db "Storage",0 
1807			.m5:   db "Sound",0 
1807			.m5a:  db "RAM Test",0 
1807			.m5b:  db "LCD Test",0 
1807			 
1807			 
1807			; debug editor 
1807			 
1807			.diagedit: 
1807			 
1807				ld hl, scratch 
1807			;	ld bc, 250 
1807			;	ldir 
1807				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1807			;	ld a, 0 
1807				ld (hl), 0 
1807				inc hl 
1807				ld (hl), 0 
1807				inc hl 
1807				ld (hl), 0 
1807			 
1807			        call clear_display 
1807				call update_display 
1807				;ld a, 1 
1807				;ld (hardware_diag), a 
1807			.diloop: 
1807				ld a, display_row_1 
1807				ld c, 0 
1807				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1807				ld e, 40 
1807			 
1807				ld hl, scratch	 
1807				call input_str 
1807			 
1807				ld a, display_row_2 
1807				ld de, scratch 
1807				call str_at_display 
1807				call update_display 
1807			 
1807				jp .diloop 
1807			endif 
1807			 
1807			; pass word in hl 
1807			; a has display location 
1807			display_word_at: 
1807 f5				push af 
1808 e5				push hl 
1809 7c				ld a,h 
180a 21 f8 f3			ld hl, os_word_scratch 
180d cd a8 11			call hexout 
1810 e1				pop hl 
1811 7d				ld a,l 
1812 21 fa f3			ld hl, os_word_scratch+2 
1815 cd a8 11			call hexout 
1818 21 fc f3			ld hl, os_word_scratch+4 
181b			;	ld a,0 
181b 36 00			ld (hl),0 
181d 11 f8 f3			ld de,os_word_scratch 
1820 f1				pop af 
1821 cd 8e 0d				call str_at_display 
1824 c9				ret 
1825			 
1825			display_ptr_state: 
1825			 
1825				; to restore afterwards 
1825			 
1825 d5				push de 
1826 c5				push bc 
1827 e5				push hl 
1828 f5				push af 
1829			 
1829				; for use in here 
1829			 
1829			;	push bc 
1829			;	push de 
1829			;	push hl 
1829			;	push af 
1829			 
1829 cd 7c 0d			call clear_display 
182c			 
182c 11 04 1a			ld de, .ptrstate 
182f 3e 00			ld a, display_row_1 
1831 cd 8e 0d			call str_at_display 
1834			 
1834				; display debug step 
1834			 
1834			 
1834 11 9d fd			ld de, debug_mark 
1837 3e 26			ld a, display_row_1+display_cols-2 
1839 cd 8e 0d			call str_at_display 
183c			 
183c				; display a 
183c 11 0e 1a			ld de, .ptrcliptr 
183f 3e 28			ld a, display_row_2 
1841 cd 8e 0d			call str_at_display 
1844			 
1844 f1				pop af 
1845 2a 72 f9			ld hl,(cli_ptr) 
1848 3e 30			ld a, display_row_2+8 
184a cd 07 18			call display_word_at 
184d			 
184d			 
184d				; display hl 
184d			 
184d			 
184d 11 16 1a			ld de, .ptrclioptr 
1850 3e 32			ld a, display_row_2+10 
1852 cd 8e 0d			call str_at_display 
1855			; 
1855			;	pop hl 
1855 3e 35			ld a, display_row_2+13 
1857 2a 70 f9			ld hl,(cli_origptr) 
185a cd 07 18			call display_word_at 
185d			; 
185d			;	 
185d			;	; display de 
185d			 
185d			;	ld de, .regstatede 
185d			;	ld a, display_row_3 
185d			;	call str_at_display 
185d			 
185d			;	pop de 
185d			;	ld h,d 
185d			;	ld l, e 
185d			;	ld a, display_row_3+3 
185d			;	call display_word_at 
185d			 
185d			 
185d				; display bc 
185d			 
185d			;	ld de, .regstatebc 
185d			;	ld a, display_row_3+10 
185d			;	call str_at_display 
185d			 
185d			;	pop bc 
185d			;	ld h,b 
185d			;	ld l, c 
185d			;	ld a, display_row_3+13 
185d			;	call display_word_at 
185d			 
185d			 
185d				; display dsp 
185d			 
185d			;	ld de, .regstatedsp 
185d			;	ld a, display_row_4 
185d			;	call str_at_display 
185d			 
185d				 
185d			;	ld hl,(cli_data_sp) 
185d			;	ld a, display_row_4+4 
185d			;	call display_word_at 
185d			 
185d				; display rsp 
185d			 
185d 11 45 1a			ld de, .regstatersp 
1860 3e 82			ld a, display_row_4+10 
1862 cd 8e 0d			call str_at_display 
1865			 
1865				 
1865 2a 24 f9			ld hl,(cli_ret_sp) 
1868 3e 86			ld a, display_row_4+14 
186a cd 07 18			call display_word_at 
186d			 
186d cd 9e 0d			call update_display 
1870			 
1870 cd c0 0c			call delay1s 
1873 cd c0 0c			call delay1s 
1876 cd c0 0c			call delay1s 
1879			 
1879			 
1879 cd e8 1e			call next_page_prompt 
187c			 
187c				; restore  
187c			 
187c f1				pop af 
187d e1				pop hl 
187e c1				pop bc 
187f d1				pop de 
1880 c9				ret 
1881			 
1881			; Update the break point vector so that the user can hook a new routine 
1881			 
1881			bp_on: 
1881 3e c3			ld a, $c3    ; JP 
1883 32 aa fd			ld (debug_vector), a 
1886 21 93 18			ld hl, break_point_state 
1889 22 ab fd			ld (debug_vector+1), hl 
188c c9				ret 
188d			 
188d			bp_off: 
188d 3e c9			ld a, $c9    ; RET 
188f 32 aa fd			ld (debug_vector), a 
1892 c9				ret 
1893			 
1893			 
1893			break_point_state: 
1893			;	push af 
1893			; 
1893			;	; see if disabled 
1893			; 
1893			;	ld a, (os_view_disable) 
1893			;	cp '*' 
1893			;	jr nz, .bpsgo 
1893			;	pop af 
1893			;	ret 
1893			 
1893			.bpsgo: 
1893			;	pop af 
1893 f5				push af 
1894 22 d5 f0			ld (os_view_hl), hl 
1897 ed 53 d3 f0		ld (os_view_de), de 
189b ed 43 d1 f0		ld (os_view_bc), bc 
189f e5				push hl 
18a0 6f				ld l, a 
18a1 26 00			ld h, 0 
18a3 22 d7 f0			ld (os_view_af),hl 
18a6			 
18a6 21 e3 fc				ld hl, display_fb0 
18a9 22 fe fa				ld (display_fb_active), hl 
18ac e1				pop hl	 
18ad			 
18ad 3e 31			ld a, '1' 
18af fe 2a		.bps1:  cp '*' 
18b1 cc 8d 18			call z, bp_off 
18b4			;	jr nz, .bps1b 
18b4			;	ld (os_view_disable),a 
18b4 fe 31		.bps1b:  cp '1' 
18b6 20 14			jr nz, .bps2 
18b8			 
18b8				; display reg 
18b8			 
18b8				 
18b8			 
18b8 3a d7 f0			ld a, (os_view_af) 
18bb 2a d5 f0			ld hl, (os_view_hl) 
18be ed 5b d3 f0		ld de, (os_view_de) 
18c2 ed 4b d1 f0		ld bc, (os_view_bc) 
18c6 cd 60 19			call display_reg_state 
18c9 c3 4c 19			jp .bpschk 
18cc			 
18cc fe 32		.bps2:  cp '2' 
18ce 20 08			jr nz, .bps3 
18d0				 
18d0				; display hl 
18d0 2a d5 f0			ld hl, (os_view_hl) 
18d3 cd 4a 1a			call display_dump_at_hl 
18d6			 
18d6 18 74			jr .bpschk 
18d8			 
18d8 fe 33		.bps3:  cp '3' 
18da 20 08			jr nz, .bps4 
18dc			 
18dc			        ; display de 
18dc 2a d3 f0			ld hl, (os_view_de) 
18df cd 4a 1a			call display_dump_at_hl 
18e2			 
18e2 18 68			jr .bpschk 
18e4 fe 34		.bps4:  cp '4' 
18e6 20 08			jr nz, .bps5 
18e8			 
18e8			        ; display bc 
18e8 2a d1 f0			ld hl, (os_view_bc) 
18eb cd 4a 1a			call display_dump_at_hl 
18ee			 
18ee 18 5c			jr .bpschk 
18f0 fe 35		.bps5:  cp '5' 
18f2 20 08		        jr nz, .bps7 
18f4			 
18f4				; display cur ptr 
18f4 2a 72 f9			ld hl, (cli_ptr) 
18f7 cd 4a 1a			call display_dump_at_hl 
18fa			 
18fa 18 50			jr .bpschk 
18fc fe 36		.bps7:  cp '6' 
18fe 20 08			jr nz, .bps8b 
1900				 
1900				; display cur orig ptr 
1900 2a 70 f9			ld hl, (cli_origptr) 
1903 cd 4a 1a			call display_dump_at_hl 
1906 18 44			jr .bpschk 
1908 fe 37		.bps8b:  cp '7' 
190a 20 08			jr nz, .bps9 
190c				 
190c				; display dsp 
190c 2a 20 f9			ld hl, (cli_data_sp) 
190f cd 4a 1a			call display_dump_at_hl 
1912			 
1912 18 38			jr .bpschk 
1914 fe 39		.bps9:  cp '9' 
1916 20 05			jr nz, .bps8c 
1918				 
1918				; display SP 
1918			;	ld hl, sp 
1918 cd 4a 1a			call display_dump_at_hl 
191b			 
191b 18 2f			jr .bpschk 
191d fe 38		.bps8c:  cp '8' 
191f 20 08			jr nz, .bps8d 
1921				 
1921				; display rsp 
1921 2a 24 f9			ld hl, (cli_ret_sp) 
1924 cd 4a 1a			call display_dump_at_hl 
1927			 
1927 18 23			jr .bpschk 
1929 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
192b 20 05			jr nz, .bps8 
192d cd a6 1c			call monitor 
1930			 
1930 18 1a			jr .bpschk 
1932 fe 30		.bps8:  cp '0' 
1934 20 16			jr nz, .bpschk 
1936			 
1936 21 42 fc				ld hl, display_fb1 
1939 22 fe fa				ld (display_fb_active), hl 
193c cd 9e 0d				call update_display 
193f			 
193f				;ld a, (os_view_af) 
193f 2a d5 f0			ld hl, (os_view_hl) 
1942 ed 5b d3 f0		ld de, (os_view_de) 
1946 ed 4b d1 f0		ld bc, (os_view_bc) 
194a f1				pop af 
194b c9				ret 
194c			 
194c			.bpschk:   
194c cd c0 0c			call delay1s 
194f 3e 9f		ld a,display_row_4 + display_cols - 1 
1951 11 e6 1e		        ld de, endprg 
1954 cd 8e 0d			call str_at_display 
1957 cd 9e 0d			call update_display 
195a cd 3c 7a			call cin_wait 
195d			 
195d c3 af 18			jp .bps1 
1960			 
1960			 
1960			display_reg_state: 
1960			 
1960				; to restore afterwards 
1960			 
1960 d5				push de 
1961 c5				push bc 
1962 e5				push hl 
1963 f5				push af 
1964			 
1964				; for use in here 
1964			 
1964 c5				push bc 
1965 d5				push de 
1966 e5				push hl 
1967 f5				push af 
1968			 
1968 cd 7c 0d			call clear_display 
196b			 
196b 11 20 1a			ld de, .regstate 
196e 3e 00			ld a, display_row_1 
1970 cd 8e 0d			call str_at_display 
1973			 
1973				; display debug step 
1973			 
1973			 
1973 11 9d fd			ld de, debug_mark 
1976 3e 25			ld a, display_row_1+display_cols-3 
1978 cd 8e 0d			call str_at_display 
197b			 
197b				; display a 
197b 11 3c 1a			ld de, .regstatea 
197e 3e 28			ld a, display_row_2 
1980 cd 8e 0d			call str_at_display 
1983			 
1983 e1				pop hl 
1984			;	ld h,0 
1984			;	ld l, a 
1984 3e 2b			ld a, display_row_2+3 
1986 cd 07 18			call display_word_at 
1989			 
1989			 
1989				; display hl 
1989			 
1989			 
1989 11 30 1a			ld de, .regstatehl 
198c 3e 32			ld a, display_row_2+10 
198e cd 8e 0d			call str_at_display 
1991			 
1991 e1				pop hl 
1992 3e 35			ld a, display_row_2+13 
1994 cd 07 18			call display_word_at 
1997			 
1997				 
1997				; display de 
1997			 
1997 11 34 1a			ld de, .regstatede 
199a 3e 50			ld a, display_row_3 
199c cd 8e 0d			call str_at_display 
199f			 
199f e1				pop hl 
19a0			;	ld h,d 
19a0			;	ld l, e 
19a0 3e 53			ld a, display_row_3+3 
19a2 cd 07 18			call display_word_at 
19a5			 
19a5			 
19a5				; display bc 
19a5			 
19a5 11 38 1a			ld de, .regstatebc 
19a8 3e 5a			ld a, display_row_3+10 
19aa cd 8e 0d			call str_at_display 
19ad			 
19ad e1				pop hl 
19ae			;	ld h,b 
19ae			;	ld l, c 
19ae 3e 5d			ld a, display_row_3+13 
19b0 cd 07 18			call display_word_at 
19b3			 
19b3			 
19b3				; display dsp 
19b3			 
19b3 11 40 1a			ld de, .regstatedsp 
19b6 3e 78			ld a, display_row_4 
19b8 cd 8e 0d			call str_at_display 
19bb			 
19bb				 
19bb 2a 20 f9			ld hl,(cli_data_sp) 
19be 3e 7c			ld a, display_row_4+4 
19c0 cd 07 18			call display_word_at 
19c3			 
19c3				; display rsp 
19c3			 
19c3 11 45 1a			ld de, .regstatersp 
19c6 3e 82			ld a, display_row_4+10 
19c8 cd 8e 0d			call str_at_display 
19cb			 
19cb				 
19cb 2a 24 f9			ld hl,(cli_ret_sp) 
19ce 3e 86			ld a, display_row_4+14 
19d0 cd 07 18			call display_word_at 
19d3			 
19d3 cd 9e 0d			call update_display 
19d6			 
19d6			;	call delay1s 
19d6			;	call delay1s 
19d6			;	call delay1s 
19d6			 
19d6			 
19d6			;	call next_page_prompt 
19d6			 
19d6				; restore  
19d6			 
19d6 f1				pop af 
19d7 e1				pop hl 
19d8 c1				pop bc 
19d9 d1				pop de 
19da c9				ret 
19db			 
19db .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
19ef .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a04 .. 00		.ptrstate:	db "Ptr State",0 
1a0e .. 00		.ptrcliptr:     db "cli_ptr",0 
1a16 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a20 .. 00		.regstate:	db "Reg State (1/0)",0 
1a30 .. 00		.regstatehl:	db "HL:",0 
1a34 .. 00		.regstatede:	db "DE:",0 
1a38 .. 00		.regstatebc:	db "BC:",0 
1a3c .. 00		.regstatea:	db "A :",0 
1a40 .. 00		.regstatedsp:	db "DSP:",0 
1a45 .. 00		.regstatersp:	db "RSP:",0 
1a4a			 
1a4a			display_dump_at_hl: 
1a4a e5				push hl 
1a4b d5				push de 
1a4c c5				push bc 
1a4d f5				push af 
1a4e			 
1a4e 22 16 f4			ld (os_cur_ptr),hl	 
1a51 cd 7c 0d			call clear_display 
1a54 cd f4 1d			call dumpcont 
1a57			;	call delay1s 
1a57			;	call next_page_prompt 
1a57			 
1a57			 
1a57 f1				pop af 
1a58 c1				pop bc 
1a59 d1				pop de 
1a5a e1				pop hl 
1a5b c9				ret 
1a5c			 
1a5c			;if ENABLE_BASIC 
1a5c			;	include "nascombasic.asm" 
1a5c			;	basic: 
1a5c			;	include "forth/FORTH.ASM" 
1a5c			;endif 
1a5c			 
1a5c			; eof 
1a5c			 
1a5c			 
# End of file firmware_diags.asm
1a5c			  
1a5c			include "firmware_prompts.asm"  
1a5c			; Prompts  
1a5c			 
1a5c			; boot messages 
1a5c			 
1a5c .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1a71 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1a81			 
1a81			 
1a81			; config menus 
1a81			 
1a81			;prom_c3: db "Add Dictionary To File",0 
1a81			 
1a81			if STARTUP_V1 
1a81			prom_c2: db "Select Autoload File",0 
1a81			prom_c2a: db "Disable Autoload File", 0 
1a81			endif 
1a81			 
1a81			if STARTUP_V2 
1a81 .. 00		prom_c2: db "Enable Autoload Files",0 
1a97 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1aae			 
1aae .. 00		crs_s1: db "*ls-word", 0 
1ab7 .. 00		crs_s2: db "*ed-word", 0 
1ac0 .. 00		crs_s3: db "*Demo-Games", 0 
1acc .. 00		crs_s4: db "*Utils", 0 
1ad3 .. 00		crs_s5: db "*SPI-Util", 0 
1add .. 00		crs_s6: db "*Key-Constants", 0 
1aec .. 00		crs_sound: db "*Sound-Util", 0 
1af8 .. 00		crs_hw: db "*Hello-World",0 
1b05			 
1b05			 
1b05			 
1b05			endif 
1b05			;prom_c2b: db "Select Storage Bank",0 
1b05 .. 00		prom_c4: db "Settings",0 
1b0e .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b29 .. 00		prom_m4b:   db "Monitor",0 
1b31			;prom_c1: db "Hardware Diags",0 
1b31			 
1b31			 
1b31			if STARTUP_V2 
1b31 .. 00		prom_c9: db "Create Startup Files",0 
1b46			endif 
1b46			 
1b46 .. 00		prom_notav:    db "Feature not available",0 
1b5c .. 00		prom_empty:    db "",0 
1b5d			 
1b5d			; eof 
1b5d			 
# End of file firmware_prompts.asm
1b5d			  
1b5d			; eof  
1b5d			  
# End of file firmware.asm
1b5d			 
1b5d			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b5d			;if BASE_KEV  
1b5d			;baseram: equ 08000h 
1b5d			;endif 
1b5d			 
1b5d			;if BASE_SC114 
1b5d			;baseram:     equ    endofcode 
1b5d			;endif 
1b5d			 
1b5d			 
1b5d			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1b5d			 
1b5d			; start system 
1b5d			 
1b5d			coldstart: 
1b5d				; set sp 
1b5d				; di/ei 
1b5d			 
1b5d f3				di 
1b5e 31 fd ff			ld sp, tos 
1b61 cd c3 76			call init_nmi 
1b64			;	ei 
1b64			 
1b64				; init spinner 
1b64 3e 00			ld a,0 
1b66 32 f8 fa			ld (display_active), a 
1b69			 
1b69				; disable breakpoint by default 
1b69			 
1b69				;ld a,'*' 
1b69			;	ld a,' ' 
1b69			;	ld (os_view_disable),a 
1b69			 
1b69				; set break point vector as new break point on or off 
1b69 cd 8d 18			call bp_off 
1b6c			 
1b6c			 
1b6c				; default the parse vector to just a RET 
1b6c 3e c9			ld a, $c9 
1b6e 32 a7 fd			ld (parse_vector), a 
1b71			 
1b71				; init hardware 
1b71			 
1b71				; init keyboard and screen hardware 
1b71			 
1b71 cd 6c 00			call hardware_init 
1b74			 
1b74			 
1b74 cd c0 0c			call delay1s 
1b77 3e 58			ld a, display_row_3+8 
1b79 11 03 00			ld de, buildtime 
1b7c cd 8e 0d			call str_at_display 
1b7f cd 9e 0d			call update_display 
1b82			 
1b82 cd c0 0c			call delay1s 
1b85 cd c0 0c			call delay1s 
1b88 cd c0 0c			call delay1s 
1b8b			 
1b8b				; detect if any keys are held down to enable breakpoints at start up 
1b8b			 
1b8b cd 4b 7a			call cin  
1b8e fe 00			cp 0 
1b90 28 03			jr z, .nokeys 
1b92			 
1b92				;call hardware_diags 
1b92 cd 11 15			call config 
1b95			 
1b95			;	ld de, .bpen 
1b95			;	ld a, display_row_4 
1b95			;	call str_at_display 
1b95			;	call update_display 
1b95			; 
1b95			;	ld a,0 
1b95			;	ld (os_view_disable),a 
1b95			; 
1b95			;.bpwait: 
1b95			;	call cin 
1b95			;	cp 0 
1b95			;	jr z, .bpwait 
1b95			;	jr .nokeys 
1b95			; 
1b95			; 
1b95			;.bpen:  db "Break points enabled!",0 
1b95			 
1b95			 
1b95			 
1b95			 
1b95			 
1b95			 
1b95			.nokeys: 
1b95			 
1b95			 
1b95				 
1b95			 
1b95			;jp  testkey 
1b95			 
1b95			;call storage_get_block_0 
1b95			; 
1b95			;ld hl, 0 
1b95			;ld de, store_page 
1b95			;call storage_read_block 
1b95			 
1b95				 
1b95			;ld hl, 10 
1b95			;ld de, store_page 
1b95			;call storage_read_block 
1b95			 
1b95			 
1b95			 
1b95			 
1b95			 
1b95			;stop:	nop 
1b95			;	jp stop 
1b95			 
1b95			 
1b95			 
1b95			main: 
1b95 cd 7c 0d			call clear_display 
1b98 cd 9e 0d			call update_display 
1b9b			 
1b9b			 
1b9b			 
1b9b			;	call testlcd 
1b9b			 
1b9b			 
1b9b			 
1b9b cd 23 23			call forth_init 
1b9e			 
1b9e			 
1b9e			warmstart: 
1b9e cd f9 22			call forth_warmstart 
1ba1			 
1ba1				; run startup word load 
1ba1			        ; TODO prevent this running at warmstart after crash  
1ba1			 
1ba1				if STARTUP_ENABLE 
1ba1			 
1ba1					if STARTUP_V1 
1ba1			 
1ba1						if STORAGE_SE 
1ba1							call forth_autoload 
1ba1						endif 
1ba1						call forth_startup 
1ba1					endif 
1ba1			 
1ba1					if STARTUP_V2 
1ba1			 
1ba1						if STORAGE_SE 
1ba1 cd f3 74						call forth_autoload 
1ba4						else 
1ba4							call forth_startup 
1ba4						endif 
1ba4			 
1ba4			 
1ba4					endif 
1ba4			 
1ba4				endif 
1ba4			 
1ba4			warmstart_afterauto: 
1ba4			 
1ba4				; show free memory after boot 
1ba4 11 41 1c			ld de, freeram 
1ba7 3e 00			ld a, display_row_1 
1ba9 cd 8e 0d			call str_at_display 
1bac			 
1bac				; get current heap start after loading any uwords 
1bac			 
1bac				;ld de, (os_last_new_uword) 
1bac				;ex de, hl 
1bac			 
1bac			; Or use heap_size word???? 
1bac				;ld hl, heap_end 
1bac				;ld hl, heap_size 
1bac				;ld de, topusermem 
1bac				;ld de, heap_start 
1bac ed 5b 0a 80			ld de, (free_list )      
1bb0 21 ce f0				ld hl, heap_end 
1bb3 ed 52			sbc hl, de 
1bb5				;push hl 
1bb5				;ld a,h	         	 
1bb5				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bb5				;call hexout 
1bb5			   	;pop hl 
1bb5			; 
1bb5			;	ld a,l 
1bb5			;	ld hl, os_word_scratch+2 
1bb5			;	call hexout 
1bb5			;	ld hl, os_word_scratch+4 
1bb5			;	ld a, 0 
1bb5			;	ld (hl),a 
1bb5 eb				ex de, hl 
1bb6 21 f8 f3			ld hl, os_word_scratch 
1bb9 cd b3 12			call uitoa_16 
1bbc			 
1bbc			 
1bbc 11 f8 f3			ld de, os_word_scratch 
1bbf 3e 0d			ld a, display_row_1 + 13 
1bc1 cd 8e 0d			call str_at_display 
1bc4 cd 9e 0d			call update_display 
1bc7			 
1bc7			 
1bc7				;call demo 
1bc7			 
1bc7			 
1bc7				; init scratch input area for cli commands 
1bc7			 
1bc7 21 1a f4			ld hl, os_cli_cmd 
1bca			;	ld a,0 
1bca 36 00			ld (hl),0 
1bcc 23				inc hl 
1bcd 36 00			ld (hl),0 
1bcf			 
1bcf 3e 00			ld a,0 
1bd1 32 19 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1bd4			 
1bd4 32 16 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1bd7 32 17 f4			ld (os_cur_ptr+1),a	 
1bda			 
1bda 32 f8 f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1bdd 32 f9 f3			ld (os_word_scratch+1),a	 
1be0				 
1be0			 
1be0				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1be0 21 1a f4			ld hl, os_cli_cmd 
1be3			 
1be3			;	ld a, 0		 ; init cli input 
1be3 36 00			ld (hl), 0 
1be5 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1be7			cli: 
1be7				; show cli prompt 
1be7				;push af 
1be7				;ld a, 0 
1be7				;ld de, prompt 
1be7				;call str_at_display 
1be7			 
1be7				;call update_display 
1be7				;pop af 
1be7				;inc a 
1be7				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1be7			 
1be7			.lastrecall: 
1be7			 
1be7 0e 00			ld c, 0 
1be9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1beb 1e 28			ld e, 40 
1bed			 
1bed 21 1a f4			ld hl, os_cli_cmd 
1bf0			 
1bf0				STACKFRAME OFF $fefe $9f9f 
1bf0				if DEBUG_STACK_IMB 
1bf0					if OFF 
1bf0						exx 
1bf0						ld de, $fefe 
1bf0						ld a, d 
1bf0						ld hl, curframe 
1bf0						call hexout 
1bf0						ld a, e 
1bf0						ld hl, curframe+2 
1bf0						call hexout 
1bf0						ld hl, $fefe 
1bf0						push hl 
1bf0						ld hl, $9f9f 
1bf0						push hl 
1bf0						exx 
1bf0					endif 
1bf0				endif 
1bf0			endm 
# End of macro STACKFRAME
1bf0			 
1bf0 cd d9 0f			call input_str 
1bf3			 
1bf3				STACKFRAMECHK OFF $fefe $9f9f 
1bf3				if DEBUG_STACK_IMB 
1bf3					if OFF 
1bf3						exx 
1bf3						ld hl, $9f9f 
1bf3						pop de   ; $9f9f 
1bf3						call cmp16 
1bf3						jr nz, .spnosame 
1bf3						ld hl, $fefe 
1bf3						pop de   ; $fefe 
1bf3						call cmp16 
1bf3						jr z, .spfrsame 
1bf3						.spnosame: call showsperror 
1bf3						.spfrsame: nop 
1bf3						exx 
1bf3					endif 
1bf3				endif 
1bf3			endm 
# End of macro STACKFRAMECHK
1bf3			 
1bf3			 
1bf3				; check to see if last line recall has been requested 
1bf3			 
1bf3			if EDIT_V2 
1bf3 fe 05			cp KEY_UP 
1bf5 20 0f			jr nz, .noexecline 
1bf7			 
1bf7 11 1a f4			ld de, os_cli_cmd 
1bfa 21 19 f5			ld hl, os_last_cmd 
1bfd 01 ff 00			ld bc, 255 
1c00 ed b0			ldir 
1c02 3e 00			ld a, 0 
1c04 18 e1			jr .lastrecall 
1c06			endif 
1c06			 
1c06			.noexecline: 
1c06				; no so exec the line		 
1c06			 
1c06				; copy input to last command 
1c06			 
1c06 21 1a f4			ld hl, os_cli_cmd 
1c09 11 19 f5			ld de, os_last_cmd 
1c0c 01 ff 00			ld bc, 255 
1c0f ed b0			ldir 
1c11			 
1c11				; wipe current buffer 
1c11			 
1c11			;	ld a, 0 
1c11			;	ld hl, os_cli_cmd 
1c11			;	ld de, os_cli_cmd+1 
1c11			;	ld bc, 254 
1c11			;	ldir 
1c11				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c11			;	call strcpy 
1c11			;	ld a, 0 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			 
1c11				; switch frame buffer to program  
1c11			 
1c11 21 42 fc				ld hl, display_fb1 
1c14 22 fe fa				ld (display_fb_active), hl 
1c17			 
1c17			;	nop 
1c17				STACKFRAME ON $fbfe $8f9f 
1c17				if DEBUG_STACK_IMB 
1c17					if ON 
1c17						exx 
1c17						ld de, $fbfe 
1c17						ld a, d 
1c17						ld hl, curframe 
1c17						call hexout 
1c17						ld a, e 
1c17						ld hl, curframe+2 
1c17						call hexout 
1c17						ld hl, $fbfe 
1c17						push hl 
1c17						ld hl, $8f9f 
1c17						push hl 
1c17						exx 
1c17					endif 
1c17				endif 
1c17			endm 
# End of macro STACKFRAME
1c17				; first time into the parser so pass over the current scratch pad 
1c17 21 1a f4			ld hl,os_cli_cmd 
1c1a				; tokenise the entered statement(s) in HL 
1c1a cd 99 23			call forthparse 
1c1d			        ; exec forth statements in top of return stack 
1c1d cd d1 23			call forthexec 
1c20				;call forthexec_cleanup 
1c20			;	call parsenext 
1c20			 
1c20				STACKFRAMECHK ON $fbfe $8f9f 
1c20				if DEBUG_STACK_IMB 
1c20					if ON 
1c20						exx 
1c20						ld hl, $8f9f 
1c20						pop de   ; $8f9f 
1c20						call cmp16 
1c20						jr nz, .spnosame 
1c20						ld hl, $fbfe 
1c20						pop de   ; $fbfe 
1c20						call cmp16 
1c20						jr z, .spfrsame 
1c20						.spnosame: call showsperror 
1c20						.spfrsame: nop 
1c20						exx 
1c20					endif 
1c20				endif 
1c20			endm 
# End of macro STACKFRAMECHK
1c20				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c20			 
1c20 3e 78			ld a, display_row_4 
1c22 11 52 1c			ld de, endprog 
1c25			 
1c25 cd 9e 0d			call update_display		 
1c28			 
1c28 cd e8 1e			call next_page_prompt 
1c2b			 
1c2b				; switch frame buffer to cli 
1c2b			 
1c2b 21 e3 fc				ld hl, display_fb0 
1c2e 22 fe fa				ld (display_fb_active), hl 
1c31			 
1c31			 
1c31 cd 7c 0d		        call clear_display 
1c34 cd 9e 0d			call update_display		 
1c37			 
1c37 21 1a f4			ld hl, os_cli_cmd 
1c3a			 
1c3a			;	ld a, 0		 ; init cli input 
1c3a 36 00			ld (hl), 0 
1c3c			 
1c3c				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c3c			 
1c3c				; now on last line 
1c3c			 
1c3c				; TODO scroll screen up 
1c3c			 
1c3c				; TODO instead just clear screen and place at top of screen 
1c3c			 
1c3c			;	ld a, 0 
1c3c			;	ld (f_cursor_ptr),a 
1c3c			 
1c3c				;call clear_display 
1c3c				;call update_display 
1c3c			 
1c3c				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3c 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3e c3 e7 1b			jp cli 
1c41			 
1c41 .. 00		freeram: db "Free bytes: ",0 
1c4e ..			asc: db "1A2F" 
1c52 .. 00		endprog: db "End prog...",0 
1c5e			 
1c5e			testenter2:   
1c5e 21 25 f1			ld hl,scratch+50 
1c61 22 16 f4			ld (os_cur_ptr),hl 
1c64 c3 e7 1b			jp cli 
1c67			 
1c67			testenter:  
1c67			 
1c67 21 4e 1c			ld hl,asc 
1c6a			;	ld a,(hl) 
1c6a			;	call nibble2val 
1c6a cd fe 11			call get_byte 
1c6d			 
1c6d			 
1c6d			;	ld a,(hl) 
1c6d			;	call atohex 
1c6d			 
1c6d			;	call fourehexhl 
1c6d 32 25 f1			ld (scratch+50),a 
1c70			 
1c70			 
1c70			 
1c70 21 50 1c			ld hl,asc+2 
1c73			;	ld a, (hl) 
1c73			;	call nibble2val 
1c73 cd fe 11			call get_byte 
1c76			 
1c76			;	call fourehexhl 
1c76 32 27 f1			ld (scratch+52),a 
1c79				 
1c79 21 25 f1			ld hl,scratch+50 
1c7c 22 16 f4			ld (os_cur_ptr),hl 
1c7f c3 e7 1b			jp cli 
1c82			 
1c82			enter:	 
1c82 3a f7 f0			ld a,(scratch+4) 
1c85 fe 00			cp 0 
1c87 28 0c			jr z, .entercont 
1c89				; no, not a null term line so has an address to work out.... 
1c89			 
1c89 21 f5 f0			ld hl,scratch+2 
1c8c cd 5e 12			call get_word_hl 
1c8f			 
1c8f 22 16 f4			ld (os_cur_ptr),hl	 
1c92 c3 e7 1b			jp cli 
1c95			 
1c95			 
1c95			.entercont:  
1c95			 
1c95 21 f5 f0			ld hl, scratch+2 
1c98 cd fe 11			call get_byte 
1c9b			 
1c9b 2a 16 f4		   	ld hl,(os_cur_ptr) 
1c9e 77					ld (hl),a 
1c9f 23					inc hl 
1ca0 22 16 f4				ld (os_cur_ptr),hl 
1ca3				 
1ca3			; get byte  
1ca3			 
1ca3			 
1ca3 c3 e7 1b			jp cli 
1ca6			 
1ca6			 
1ca6			; basic monitor support 
1ca6			 
1ca6			monitor: 
1ca6				;  
1ca6 cd 7c 0d			call clear_display 
1ca9 3e 00			ld a, 0 
1cab 11 ff 1c			ld de, .monprompt 
1cae cd 8e 0d			call str_at_display 
1cb1 cd 9e 0d			call update_display 
1cb4			 
1cb4				; get a monitor command 
1cb4			 
1cb4 0e 00			ld c, 0     ; entry at top left 
1cb6 16 64			ld d, 100   ; max buffer size 
1cb8 1e 0f			ld e, 15    ; input scroll area 
1cba			;	ld a, 0     ; init string 
1cba 21 f1 f2			ld hl, os_input 
1cbd 36 00			ld (hl), 0 
1cbf 23				inc hl 
1cc0 36 00			ld (hl), 0 
1cc2 21 f1 f2			ld hl, os_input 
1cc5 3e 01			ld a, 1     ; init string 
1cc7 cd d9 0f			call input_str 
1cca			 
1cca cd 7c 0d		        call clear_display 
1ccd cd 9e 0d			call update_display		 
1cd0			 
1cd0 3a f1 f2			ld a, (os_input) 
1cd3 cd fb 12			call toUpper 
1cd6 fe 48		        cp 'H' 
1cd8 ca 73 1d		        jp z, .monhelp 
1cdb fe 44			cp 'D'		; dump 
1cdd ca a6 1d			jp z, .mondump	 
1ce0 fe 43			cp 'C'		; dump 
1ce2 ca c0 1d			jp z, .moncdump	 
1ce5 fe 4d			cp 'M'		; dump 
1ce7 ca 01 1d			jp z, .moneditstart 
1cea fe 55			cp 'U'		; dump 
1cec ca 0d 1d			jp z, .monedit	 
1cef fe 47			cp 'G'		; dump 
1cf1 ca 9c 1d			jp z, .monjump 
1cf4 fe 42			cp 'B'		; forth breakpoint 
1cf6 cc 93 18			call z, break_point_state 
1cf9 fe 51			cp 'Q'		; dump 
1cfb c8				ret z	 
1cfc			 
1cfc			 
1cfc				; TODO "S" to access symbol by name and not need the address 
1cfc				; TODO "F" to find a string in memory 
1cfc			 
1cfc c3 a6 1c			jp monitor 
1cff			 
1cff .. 00		.monprompt: db ">", 0 
1d01			 
1d01			.moneditstart: 
1d01				; get starting address 
1d01			 
1d01 21 f3 f2			ld hl,os_input+2 
1d04 cd 5e 12			call get_word_hl 
1d07			 
1d07 22 16 f4			ld (os_cur_ptr),hl	 
1d0a			 
1d0a c3 a6 1c			jp monitor 
1d0d			 
1d0d			.monedit: 
1d0d				; get byte to load 
1d0d			 
1d0d 21 f3 f2			ld hl,os_input+2 
1d10 cd fe 11			call get_byte 
1d13			 
1d13				; get address to update 
1d13 2a 16 f4			ld hl, (os_cur_ptr) 
1d16			 
1d16				; update byte 
1d16			 
1d16 77				ld (hl), a 
1d17			 
1d17				; move to next address and save it 
1d17			 
1d17 23				inc hl 
1d18 22 16 f4			ld (os_cur_ptr),hl	 
1d1b			 
1d1b c3 a6 1c			jp monitor 
1d1e			 
1d1e			 
1d1e .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d32 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d4e .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1d6c .. 00		.monhelptext4:  db "Q-Quit",0 
1d73			        
1d73			.monhelp: 
1d73 3e 00			ld a, display_row_1 
1d75 11 1e 1d		        ld de, .monhelptext1 
1d78			 
1d78 cd 8e 0d			call str_at_display 
1d7b 3e 28			ld a, display_row_2 
1d7d 11 32 1d		        ld de, .monhelptext2 
1d80					 
1d80 cd 8e 0d			call str_at_display 
1d83 3e 50			ld a, display_row_3 
1d85 11 4e 1d		        ld de, .monhelptext3 
1d88					 
1d88 cd 8e 0d			call str_at_display 
1d8b 3e 78			ld a, display_row_4 
1d8d 11 6c 1d		        ld de, .monhelptext4 
1d90 cd 8e 0d			call str_at_display 
1d93			 
1d93 cd 9e 0d			call update_display		 
1d96			 
1d96 cd e8 1e			call next_page_prompt 
1d99 c3 a6 1c			jp monitor 
1d9c			 
1d9c			.monjump:    
1d9c 21 f3 f2			ld hl,os_input+2 
1d9f cd 5e 12			call get_word_hl 
1da2			 
1da2 e9				jp (hl) 
1da3 c3 a6 1c			jp monitor 
1da6			 
1da6			.mondump:    
1da6 21 f3 f2			ld hl,os_input+2 
1da9 cd 5e 12			call get_word_hl 
1dac			 
1dac 22 16 f4			ld (os_cur_ptr),hl	 
1daf cd f4 1d			call dumpcont 
1db2 3e 78			ld a, display_row_4 
1db4 11 52 1c			ld de, endprog 
1db7			 
1db7 cd 9e 0d			call update_display		 
1dba			 
1dba cd e8 1e			call next_page_prompt 
1dbd c3 a6 1c			jp monitor 
1dc0			.moncdump: 
1dc0 cd f4 1d			call dumpcont 
1dc3 3e 78			ld a, display_row_4 
1dc5 11 52 1c			ld de, endprog 
1dc8			 
1dc8 cd 9e 0d			call update_display		 
1dcb			 
1dcb cd e8 1e			call next_page_prompt 
1dce c3 a6 1c			jp monitor 
1dd1			 
1dd1			 
1dd1			; TODO symbol access  
1dd1			 
1dd1			.symbols:     ;; A list of symbols that can be called up  
1dd1 e3 fc			dw display_fb0 
1dd3 .. 00			db "fb0",0  
1dd7 ac f9		     	dw store_page 
1dd9 .. 00			db "store_page",0 
1de4			 
1de4			 
1de4			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1de4			 
1de4 3a f4 f0			ld a,(scratch+1) 
1de7 fe 00			cp 0 
1de9 28 09			jr z, dumpcont 
1deb			 
1deb				; no, not a null term line so has an address to work out.... 
1deb			 
1deb 21 f5 f0			ld hl,scratch+2 
1dee cd 5e 12			call get_word_hl 
1df1			 
1df1 22 16 f4			ld (os_cur_ptr),hl	 
1df4			 
1df4			 
1df4			 
1df4			dumpcont: 
1df4			 
1df4				; dump bytes at ptr 
1df4			 
1df4			 
1df4 3e 00			ld a, display_row_1 
1df6 2a fe fa			ld hl, (display_fb_active) 
1df9 cd ac 0f			call addatohl 
1dfc cd 24 1e			call .dumpbyterow 
1dff			 
1dff 3e 28			ld a, display_row_2 
1e01 2a fe fa			ld hl, (display_fb_active) 
1e04 cd ac 0f			call addatohl 
1e07 cd 24 1e			call .dumpbyterow 
1e0a			 
1e0a			 
1e0a 3e 50			ld a, display_row_3 
1e0c 2a fe fa			ld hl, (display_fb_active) 
1e0f cd ac 0f			call addatohl 
1e12 cd 24 1e			call .dumpbyterow 
1e15			 
1e15 3e 78			ld a, display_row_4 
1e17 2a fe fa			ld hl, (display_fb_active) 
1e1a cd ac 0f			call addatohl 
1e1d cd 24 1e			call .dumpbyterow 
1e20			 
1e20 cd 9e 0d			call update_display 
1e23			;		jp cli 
1e23 c9				ret 
1e24			 
1e24			.dumpbyterow: 
1e24			 
1e24				;push af 
1e24			 
1e24 e5				push hl 
1e25			 
1e25				; calc where to poke the ascii 
1e25			if display_cols == 20 
1e25				ld a, 16 
1e25			else 
1e25 3e 1f			ld a, 31 
1e27			endif 
1e27			 
1e27 cd ac 0f			call addatohl 
1e2a 22 f8 f3			ld (os_word_scratch),hl  		; save pos for later 
1e2d			 
1e2d			 
1e2d			; display decoding address 
1e2d 2a 16 f4		   	ld hl,(os_cur_ptr) 
1e30			 
1e30 7c				ld a,h 
1e31 e1				pop hl 
1e32 e5				push hl 
1e33			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1e33 cd a8 11			call hexout 
1e36 2a 16 f4		   	ld hl,(os_cur_ptr) 
1e39			 
1e39 7d				ld a,l 
1e3a e1				pop hl 
1e3b 23				inc hl 
1e3c 23				inc hl 
1e3d e5				push hl 
1e3e			;	ld hl, os_word_scratch+2 
1e3e cd a8 11			call hexout 
1e41 e1				pop hl 
1e42 23				inc hl 
1e43 23				inc hl 
1e44				;ld hl, os_word_scratch+4 
1e44			;	ld a, ':' 
1e44 36 3a			ld (hl),':' 
1e46 23				inc hl 
1e47				;ld a, 0 
1e47				;ld (hl),a 
1e47				;ld de, os_word_scratch 
1e47				;pop af 
1e47				;push af 
1e47			;		ld a, display_row_2 
1e47			;		call str_at_display 
1e47			;		call update_display 
1e47			 
1e47			 
1e47			;pop af 
1e47			;	add 5 
1e47			 
1e47			if display_cols == 20 
1e47				ld b, 4 
1e47			else 
1e47 06 08			ld b, 8 
1e49			endif	 
1e49			 
1e49			.dumpbyte: 
1e49 c5				push bc 
1e4a e5				push hl 
1e4b			 
1e4b			 
1e4b 2a 16 f4		   	ld hl,(os_cur_ptr) 
1e4e 7e					ld a,(hl) 
1e4f			 
1e4f					; poke the ascii to display 
1e4f 2a f8 f3				ld hl,(os_word_scratch) 
1e52 77					ld (hl),a 
1e53 23					inc hl 
1e54 22 f8 f3				ld (os_word_scratch),hl 
1e57			 
1e57					 
1e57			 
1e57			 
1e57 e1					pop hl 
1e58 e5					push hl 
1e59			 
1e59 cd a8 11				call hexout 
1e5c			 
1e5c					 
1e5c 2a 16 f4		   	ld hl,(os_cur_ptr) 
1e5f 23				inc hl 
1e60 22 16 f4		   	ld (os_cur_ptr),hl 
1e63			 
1e63 e1					pop hl 
1e64 23					inc hl 
1e65 23					inc hl 
1e66 23					inc hl 
1e67			 
1e67			 
1e67			 
1e67					;ld a,0 
1e67					;ld (os_word_scratch+2),a 
1e67					;pop af 
1e67					;push af 
1e67			 
1e67					;ld de, os_word_scratch 
1e67					;call str_at_display 
1e67			;		call update_display 
1e67			;		pop af 
1e67 c1					pop bc 
1e68 c6 03				add 3 
1e6a 10 dd			djnz .dumpbyte 
1e6c			 
1e6c				 
1e6c			 
1e6c c9				ret 
1e6d			 
1e6d			jump:	 
1e6d			 
1e6d 21 f5 f0			ld hl,scratch+2 
1e70 cd 5e 12			call get_word_hl 
1e73				;ld hl,(scratch+2) 
1e73				;call fourehexhl 
1e73			 
1e73 22 16 f4			ld (os_cur_ptr),hl	 
1e76			 
1e76 e9				jp (hl) 
1e77			 
1e77			 
1e77			 
1e77			; TODO implement a basic monitor mode to start with 
1e77			 
1e77			 
1e77			 
1e77			 
1e77			 
1e77			 
1e77			 
1e77			 
1e77			 
1e77			; testing and demo code during development 
1e77			 
1e77			 
1e77 .. 00		str1: db "Enter some text...",0 
1e8a .. 00		clear: db "                    ",0 
1e9f			 
1e9f			demo: 
1e9f			 
1e9f			 
1e9f			 
1e9f			;	call update_display 
1e9f			 
1e9f				; init scratch input area for testing 
1e9f 21 f3 f0			ld hl, scratch	 
1ea2			;	ld a,0 
1ea2 36 00			ld (hl),0 
1ea4			 
1ea4			 
1ea4 3e 28		            LD   A, display_row_2 
1ea6			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ea6 11 77 1e		            LD   DE, str1 
1ea9 cd 8e 0d			call str_at_display 
1eac			 
1eac			;            CALL fLCD_Str       ;Display string pointed to by DE 
1eac			cloop:	 
1eac 3e 50		            LD   A, display_row_3 
1eae			;            CALL fLCD_Pos       ;Position cursor to location in A 
1eae 11 8a 1e		            LD   DE, clear 
1eb1			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1eb1 cd 8e 0d				call str_at_display 
1eb4 3e 78			ld a, display_row_4 
1eb6 11 e4 1e			ld de, prompt 
1eb9			 
1eb9 cd 8e 0d				call str_at_display 
1ebc cd 9e 0d			call update_display 
1ebf			 
1ebf 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ec1 16 0a			ld d, 10 
1ec3 21 f3 f0			ld hl, scratch	 
1ec6 cd d9 0f			call input_str 
1ec9			 
1ec9			;	call clear_display 
1ec9			;'	call update_display 
1ec9			 
1ec9 3e 00		            LD   A, display_row_1 
1ecb			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ecb 11 8a 1e		            LD   DE, clear 
1ece cd 8e 0d				call str_at_display 
1ed1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ed1 3e 00		            LD   A, display_row_1 
1ed3			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ed3 11 f3 f0		            LD   DE, scratch 
1ed6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ed6 cd 8e 0d				call str_at_display 
1ed9 cd 9e 0d			call update_display 
1edc			 
1edc			;		ld a,0 
1edc 21 f3 f0			ld hl, scratch 
1edf 36 00			ld (hl),0 
1ee1			 
1ee1			;	nop 
1ee1 c3 ac 1e			jp cloop 
1ee4			 
1ee4			 
1ee4			 
1ee4			; OS Prompt 
1ee4			 
1ee4 .. 00		prompt: db ">",0 
1ee6 .. 00		endprg: db "?",0 
1ee8			 
1ee8			 
1ee8			; handy next page prompt 
1ee8			next_page_prompt: 
1ee8 e5				push hl 
1ee9 d5				push de 
1eea f5				push af 
1eeb c5				push bc 
1eec			 
1eec 3e 9f			ld a,display_row_4 + display_cols - 1 
1eee 11 e6 1e		        ld de, endprg 
1ef1 cd 8e 0d			call str_at_display 
1ef4 cd 9e 0d			call update_display 
1ef7 cd 3c 7a			call cin_wait 
1efa c1				pop bc 
1efb f1				pop af 
1efc d1				pop de 
1efd e1				pop hl 
1efe			 
1efe			 
1efe c9				ret 
1eff			 
1eff			 
1eff			; forth parser 
1eff			 
1eff			; My forth kernel 
1eff			include "forth_kernel.asm" 
1eff			; 
1eff			; kernel to the forth OS 
1eff			 
1eff			DS_TYPE_STR: equ 1     ; string type 
1eff			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1eff			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1eff			DS_TYPE_CONST: equ 4     ; string type that won't be freed on a POP 
1eff			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1eff			 
1eff			FORTH_PARSEV1: equ 0 
1eff			FORTH_PARSEV2: equ 0 
1eff			FORTH_PARSEV3: equ 0 
1eff			FORTH_PARSEV4: equ 0 
1eff			FORTH_PARSEV5: equ 0 
1eff			FORTH_PARSEV6: equ 1 
1eff			 
1eff			;if FORTH_PARSEV5 
1eff			;	FORTH_END_BUFFER: equ 0 
1eff			;else 
1eff			FORTH_END_BUFFER: equ 127 
1eff			;endif 
1eff			 
1eff			FORTH_TRUE: equ 1 
1eff			FORTH_FALSE: equ 0 
1eff			 
1eff			if FORTH_PARSEV4 
1eff			include "forth_stackops.asm" 
1eff			endif 
1eff			 
1eff			if FORTH_PARSEV5 
1eff			include "forth_stackopsv5.asm" 
1eff			endif 
1eff			 
1eff			if FORTH_PARSEV6 
1eff			include "forth_stackopsv5.asm" 
1eff			 
1eff			; Stack operations for v5 parser on wards 
1eff			; * DATA stack 
1eff			; * LOOP stack 
1eff			; * RETURN stack 
1eff			 
1eff			 
1eff			 
1eff			FORTH_CHK_DSP_UNDER: macro 
1eff				push hl 
1eff				push de 
1eff				ld hl,(cli_data_sp) 
1eff				ld de, cli_data_stack 
1eff				call cmp16 
1eff				jp c, fault_dsp_under 
1eff				pop de 
1eff				pop hl 
1eff				endm 
1eff			 
1eff			 
1eff			FORTH_CHK_RSP_UNDER: macro 
1eff				push hl 
1eff				push de 
1eff				ld hl,(cli_ret_sp) 
1eff				ld de, cli_ret_stack 
1eff				call cmp16 
1eff				jp c, fault_rsp_under 
1eff				pop de 
1eff				pop hl 
1eff				endm 
1eff			 
1eff			FORTH_CHK_LOOP_UNDER: macro 
1eff				push hl 
1eff				push de 
1eff				ld hl,(cli_loop_sp) 
1eff				ld de, cli_loop_stack 
1eff				call cmp16 
1eff				jp c, fault_loop_under 
1eff				pop de 
1eff				pop hl 
1eff				endm 
1eff			 
1eff			FORTH_ERR_TOS_NOTSTR: macro 
1eff				; TOSO might need more for checks when used 
1eff				push af 
1eff				ld a,(hl) 
1eff				cp DS_TYPE_STR 
1eff				jp nz, type_faultn   
1eff				pop af 
1eff				endm 
1eff			 
1eff			FORTH_ERR_TOS_NOTNUM: macro 
1eff				push af 
1eff				ld a,(hl) 
1eff				cp DS_TYPE_INUM 
1eff				jp nz, type_faultn   
1eff				pop af 
1eff				endm 
1eff			 
1eff			 
1eff			; increase data stack pointer and save hl to it 
1eff				 
1eff			FORTH_DSP_NEXT: macro 
1eff				call macro_forth_dsp_next 
1eff				endm 
1eff			 
1eff			 
1eff			macro_forth_dsp_next: 
1eff				if DEBUG_FORTH_STACK_GUARD 
1eff cd e2 72				call check_stacks 
1f02				endif 
1f02 e5				push hl 
1f03 d5				push de 
1f04 eb				ex de,hl 
1f05 2a 20 f9			ld hl,(cli_data_sp) 
1f08 23				inc hl 
1f09 23				inc hl 
1f0a			 
1f0a			; PARSEV5 
1f0a 23				inc hl 
1f0b 22 20 f9			ld (cli_data_sp),hl 
1f0e 73				ld (hl), e 
1f0f 23				inc hl 
1f10 72				ld (hl), d 
1f11 d1				pop de 
1f12 e1				pop hl 
1f13				if DEBUG_FORTH_STACK_GUARD 
1f13 cd e2 72				call check_stacks 
1f16				endif 
1f16 c9				ret 
1f17			 
1f17			 
1f17			; increase ret stack pointer and save hl to it 
1f17				 
1f17			FORTH_RSP_NEXT: macro 
1f17				call macro_forth_rsp_next 
1f17				endm 
1f17			 
1f17			macro_forth_rsp_next: 
1f17				if DEBUG_FORTH_STACK_GUARD 
1f17 cd e2 72				call check_stacks 
1f1a				endif 
1f1a e5				push hl 
1f1b d5				push de 
1f1c eb				ex de,hl 
1f1d 2a 24 f9			ld hl,(cli_ret_sp) 
1f20 23				inc hl 
1f21 23				inc hl 
1f22 22 24 f9			ld (cli_ret_sp),hl 
1f25 73				ld (hl), e 
1f26 23				inc hl 
1f27 72				ld (hl), d 
1f28 d1				pop de 
1f29 e1				pop hl 
1f2a				if DEBUG_FORTH_STACK_GUARD 
1f2a cd e2 72				call check_stacks 
1f2d				endif 
1f2d c9				ret 
1f2e			 
1f2e			; get current ret stack pointer and save to hl  
1f2e				 
1f2e			FORTH_RSP_TOS: macro 
1f2e				call macro_forth_rsp_tos 
1f2e				endm 
1f2e			 
1f2e			macro_forth_rsp_tos: 
1f2e				;push de 
1f2e 2a 24 f9			ld hl,(cli_ret_sp) 
1f31 cd 69 1f			call loadhlptrtohl 
1f34				;ld e, (hl) 
1f34				;inc hl 
1f34				;ld d, (hl) 
1f34				;ex de, hl 
1f34					if DEBUG_FORTH_WORDS 
1f34			;			DMARK "RST" 
1f34						CALLMONITOR 
1f34 cd aa fd			call debug_vector  
1f37				endm  
# End of macro CALLMONITOR
1f37					endif 
1f37				;pop de 
1f37 c9				ret 
1f38			 
1f38			; pop ret stack pointer 
1f38				 
1f38			FORTH_RSP_POP: macro 
1f38				call macro_forth_rsp_pop 
1f38				endm 
1f38			 
1f38			 
1f38			macro_forth_rsp_pop: 
1f38				if DEBUG_FORTH_STACK_GUARD 
1f38			;		DMARK "RPP" 
1f38 cd e2 72				call check_stacks 
1f3b					FORTH_CHK_RSP_UNDER 
1f3b e5				push hl 
1f3c d5				push de 
1f3d 2a 24 f9			ld hl,(cli_ret_sp) 
1f40 11 de f8			ld de, cli_ret_stack 
1f43 cd ca 0f			call cmp16 
1f46 da f9 73			jp c, fault_rsp_under 
1f49 d1				pop de 
1f4a e1				pop hl 
1f4b				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f4b				endif 
1f4b e5				push hl 
1f4c 2a 24 f9			ld hl,(cli_ret_sp) 
1f4f			 
1f4f			 
1f4f				if FORTH_ENABLE_FREE 
1f4f			 
1f4f					; get pointer 
1f4f			 
1f4f					push de 
1f4f					push hl 
1f4f			 
1f4f					ld e, (hl) 
1f4f					inc hl 
1f4f					ld d, (hl) 
1f4f			 
1f4f					ex de, hl 
1f4f					call free 
1f4f			 
1f4f					pop hl 
1f4f					pop de 
1f4f			 
1f4f			 
1f4f				endif 
1f4f			 
1f4f			 
1f4f 2b				dec hl 
1f50 2b				dec hl 
1f51 22 24 f9			ld (cli_ret_sp), hl 
1f54				; do stack underflow checks 
1f54 e1				pop hl 
1f55				if DEBUG_FORTH_STACK_GUARD 
1f55 cd e2 72				call check_stacks 
1f58					FORTH_CHK_RSP_UNDER 
1f58 e5				push hl 
1f59 d5				push de 
1f5a 2a 24 f9			ld hl,(cli_ret_sp) 
1f5d 11 de f8			ld de, cli_ret_stack 
1f60 cd ca 0f			call cmp16 
1f63 da f9 73			jp c, fault_rsp_under 
1f66 d1				pop de 
1f67 e1				pop hl 
1f68				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f68				endif 
1f68 c9				ret 
1f69			 
1f69			 
1f69			 
1f69			; routine to load word pointed to by hl into hl 
1f69			 
1f69			loadhlptrtohl: 
1f69			 
1f69 d5				push de 
1f6a 5e				ld e, (hl) 
1f6b 23				inc hl 
1f6c 56				ld d, (hl) 
1f6d eb				ex de, hl 
1f6e d1				pop de 
1f6f			 
1f6f c9				ret 
1f70			 
1f70			 
1f70			 
1f70			 
1f70			 
1f70			; push a number held in HL onto the data stack 
1f70			; entry point for pushing a value when already in hl used in function above 
1f70			 
1f70			forth_push_numhl: 
1f70			 
1f70 e5				push hl    ; save value to push 
1f71			 
1f71			if DEBUG_FORTH_PUSH 
1f71				; see if disabled 
1f71			 
1f71			 
1f71 f5				push af 
1f72 3a aa fd			ld a,(debug_vector) 
1f75 fe c9			cp $c9   ; ret 
1f77			;	ld a, (os_view_disable) 
1f77			;	cp '*' 
1f77 28 33			jr z, .pskip2 
1f79 e5				push hl 
1f7a e5			push hl 
1f7b cd 7c 0d			call clear_display 
1f7e e1			pop hl 
1f7f 7c				ld a,h 
1f80 21 f8 f3			ld hl, os_word_scratch 
1f83 cd a8 11			call hexout 
1f86 e1				pop hl 
1f87 7d				ld a,l 
1f88 21 fa f3			ld hl, os_word_scratch+2 
1f8b cd a8 11			call hexout 
1f8e			 
1f8e 21 fc f3			ld hl, os_word_scratch+4 
1f91			;	ld a,0 
1f91 36 00			ld (hl),0 
1f93 11 f8 f3			ld de,os_word_scratch 
1f96 3e 28				ld a, display_row_2 
1f98 cd 8e 0d				call str_at_display 
1f9b 11 df 64			ld de, .push_num 
1f9e 3e 00			ld a, display_row_1 
1fa0			 
1fa0 cd 8e 0d				call str_at_display 
1fa3			 
1fa3			 
1fa3 cd 9e 0d			call update_display 
1fa6 cd c0 0c			call delay1s 
1fa9 cd c0 0c			call delay1s 
1fac			.pskip2:  
1fac			 
1fac f1				pop af 
1fad			endif	 
1fad			 
1fad			 
1fad				FORTH_DSP_NEXT 
1fad cd ff 1e			call macro_forth_dsp_next 
1fb0				endm 
# End of macro FORTH_DSP_NEXT
1fb0			 
1fb0 2a 20 f9			ld hl, (cli_data_sp) 
1fb3			 
1fb3				; save item type 
1fb3			;	ld a,  DS_TYPE_INUM 
1fb3 36 02			ld (hl), DS_TYPE_INUM 
1fb5 23				inc hl 
1fb6			 
1fb6				; get word off stack 
1fb6 d1				pop de 
1fb7				;ld a,e 
1fb7 73				ld (hl), e 
1fb8 23				inc hl 
1fb9			;	ld a,d 
1fb9 72				ld (hl), d 
1fba			 
1fba			if DEBUG_FORTH_PUSH 
1fba 2b				dec hl 
1fbb 2b				dec hl 
1fbc 2b				dec hl 
1fbd						DMARK "PH5" 
1fbd f5				push af  
1fbe 3a d2 1f			ld a, (.dmark)  
1fc1 32 9d fd			ld (debug_mark),a  
1fc4 3a d3 1f			ld a, (.dmark+1)  
1fc7 32 9e fd			ld (debug_mark+1),a  
1fca 3a d4 1f			ld a, (.dmark+2)  
1fcd 32 9f fd			ld (debug_mark+2),a  
1fd0 18 03			jr .pastdmark  
1fd2 ..			.dmark: db "PH5"  
1fd5 f1			.pastdmark: pop af  
1fd6			endm  
# End of macro DMARK
1fd6				CALLMONITOR 
1fd6 cd aa fd			call debug_vector  
1fd9				endm  
# End of macro CALLMONITOR
1fd9			endif	 
1fd9			 
1fd9 c9				ret 
1fda			 
1fda			 
1fda			; Push a string to stack pointed to by hl 
1fda			 
1fda			forth_push_str: 
1fda			 
1fda			if DEBUG_FORTH_PUSH 
1fda						DMARK "PSQ" 
1fda f5				push af  
1fdb 3a ef 1f			ld a, (.dmark)  
1fde 32 9d fd			ld (debug_mark),a  
1fe1 3a f0 1f			ld a, (.dmark+1)  
1fe4 32 9e fd			ld (debug_mark+1),a  
1fe7 3a f1 1f			ld a, (.dmark+2)  
1fea 32 9f fd			ld (debug_mark+2),a  
1fed 18 03			jr .pastdmark  
1fef ..			.dmark: db "PSQ"  
1ff2 f1			.pastdmark: pop af  
1ff3			endm  
# End of macro DMARK
1ff3				CALLMONITOR 
1ff3 cd aa fd			call debug_vector  
1ff6				endm  
# End of macro CALLMONITOR
1ff6			endif	 
1ff6			 
1ff6			 
1ff6			    
1ff6 e5				push hl 
1ff7 e5				push hl 
1ff8			 
1ff8			;	ld a, 0   ; find end of string 
1ff8 cd 04 13			call strlenz 
1ffb			if DEBUG_FORTH_PUSH 
1ffb						DMARK "PQ2" 
1ffb f5				push af  
1ffc 3a 10 20			ld a, (.dmark)  
1fff 32 9d fd			ld (debug_mark),a  
2002 3a 11 20			ld a, (.dmark+1)  
2005 32 9e fd			ld (debug_mark+1),a  
2008 3a 12 20			ld a, (.dmark+2)  
200b 32 9f fd			ld (debug_mark+2),a  
200e 18 03			jr .pastdmark  
2010 ..			.dmark: db "PQ2"  
2013 f1			.pastdmark: pop af  
2014			endm  
# End of macro DMARK
2014				CALLMONITOR 
2014 cd aa fd			call debug_vector  
2017				endm  
# End of macro CALLMONITOR
2017			endif	 
2017 eb				ex de, hl 
2018 e1				pop hl   ; get ptr to start of string 
2019			if DEBUG_FORTH_PUSH 
2019						DMARK "PQ3" 
2019 f5				push af  
201a 3a 2e 20			ld a, (.dmark)  
201d 32 9d fd			ld (debug_mark),a  
2020 3a 2f 20			ld a, (.dmark+1)  
2023 32 9e fd			ld (debug_mark+1),a  
2026 3a 30 20			ld a, (.dmark+2)  
2029 32 9f fd			ld (debug_mark+2),a  
202c 18 03			jr .pastdmark  
202e ..			.dmark: db "PQ3"  
2031 f1			.pastdmark: pop af  
2032			endm  
# End of macro DMARK
2032				CALLMONITOR 
2032 cd aa fd			call debug_vector  
2035				endm  
# End of macro CALLMONITOR
2035			endif	 
2035 19				add hl,de 
2036			if DEBUG_FORTH_PUSH 
2036						DMARK "PQE" 
2036 f5				push af  
2037 3a 4b 20			ld a, (.dmark)  
203a 32 9d fd			ld (debug_mark),a  
203d 3a 4c 20			ld a, (.dmark+1)  
2040 32 9e fd			ld (debug_mark+1),a  
2043 3a 4d 20			ld a, (.dmark+2)  
2046 32 9f fd			ld (debug_mark+2),a  
2049 18 03			jr .pastdmark  
204b ..			.dmark: db "PQE"  
204e f1			.pastdmark: pop af  
204f			endm  
# End of macro DMARK
204f				CALLMONITOR 
204f cd aa fd			call debug_vector  
2052				endm  
# End of macro CALLMONITOR
2052			endif	 
2052			 
2052 2b				dec hl    ; see if there is an optional trailing double quote 
2053 7e				ld a,(hl) 
2054 fe 22			cp '"' 
2056 20 02			jr nz, .strnoq 
2058			;	ld a, 0      ; get rid of double quote 
2058 36 00			ld (hl), 0 
205a 23			.strnoq: inc hl 
205b			 
205b			;	ld a, 0 
205b 36 00			ld (hl), 0     ; add null term and get rid of trailing double quote 
205d			 
205d 13				inc de ; add one for the type string 
205e 13				inc de ; add one for null term??? 
205f			 
205f				; tos is get string pointer again 
205f				; de contains space to allocate 
205f				 
205f d5				push de 
2060			 
2060 eb				ex de, hl 
2061			 
2061				;push af 
2061			 
2061			if DEBUG_FORTH_PUSH 
2061						DMARK "PHm" 
2061 f5				push af  
2062 3a 76 20			ld a, (.dmark)  
2065 32 9d fd			ld (debug_mark),a  
2068 3a 77 20			ld a, (.dmark+1)  
206b 32 9e fd			ld (debug_mark+1),a  
206e 3a 78 20			ld a, (.dmark+2)  
2071 32 9f fd			ld (debug_mark+2),a  
2074 18 03			jr .pastdmark  
2076 ..			.dmark: db "PHm"  
2079 f1			.pastdmark: pop af  
207a			endm  
# End of macro DMARK
207a				CALLMONITOR 
207a cd aa fd			call debug_vector  
207d				endm  
# End of macro CALLMONITOR
207d			endif	 
207d cd 78 13			call malloc	; on ret hl now contains allocated memory 
2080				if DEBUG_FORTH_MALLOC_GUARD 
2080 cc 37 65				call z,malloc_error 
2083				endif 
2083			 
2083				 
2083 c1				pop bc    ; get length 
2084 d1				pop de   ;  get string start    
2085			 
2085				; hl has destination from malloc 
2085			 
2085 eb				ex de, hl    ; prep for ldir 
2086			 
2086 d5				push de   ; save malloc area for DSP later 
2087				;push hl   ; save malloc area for DSP later 
2087			 
2087			if DEBUG_FORTH_PUSH 
2087						DMARK "PHc" 
2087 f5				push af  
2088 3a 9c 20			ld a, (.dmark)  
208b 32 9d fd			ld (debug_mark),a  
208e 3a 9d 20			ld a, (.dmark+1)  
2091 32 9e fd			ld (debug_mark+1),a  
2094 3a 9e 20			ld a, (.dmark+2)  
2097 32 9f fd			ld (debug_mark+2),a  
209a 18 03			jr .pastdmark  
209c ..			.dmark: db "PHc"  
209f f1			.pastdmark: pop af  
20a0			endm  
# End of macro DMARK
20a0				CALLMONITOR 
20a0 cd aa fd			call debug_vector  
20a3				endm  
# End of macro CALLMONITOR
20a3			endif	 
20a3			 
20a3			 
20a3 ed b0			ldir 
20a5			 
20a5			 
20a5				; push malloc to data stack     macro?????  
20a5			 
20a5				FORTH_DSP_NEXT 
20a5 cd ff 1e			call macro_forth_dsp_next 
20a8				endm 
# End of macro FORTH_DSP_NEXT
20a8			 
20a8				; save value and type 
20a8			 
20a8 2a 20 f9			ld hl, (cli_data_sp) 
20ab			 
20ab				; save item type 
20ab			;	ld a,  DS_TYPE_STR 
20ab 36 01			ld (hl), DS_TYPE_STR 
20ad 23				inc hl 
20ae			 
20ae				; get malloc word off stack 
20ae d1				pop de 
20af 73				ld (hl), e 
20b0 23				inc hl 
20b1 72				ld (hl), d 
20b2			 
20b2			 
20b2			 
20b2			if DEBUG_FORTH_PUSH 
20b2 2a 20 f9			ld hl, (cli_data_sp) 
20b5						DMARK "PHS" 
20b5 f5				push af  
20b6 3a ca 20			ld a, (.dmark)  
20b9 32 9d fd			ld (debug_mark),a  
20bc 3a cb 20			ld a, (.dmark+1)  
20bf 32 9e fd			ld (debug_mark+1),a  
20c2 3a cc 20			ld a, (.dmark+2)  
20c5 32 9f fd			ld (debug_mark+2),a  
20c8 18 03			jr .pastdmark  
20ca ..			.dmark: db "PHS"  
20cd f1			.pastdmark: pop af  
20ce			endm  
# End of macro DMARK
20ce				CALLMONITOR 
20ce cd aa fd			call debug_vector  
20d1				endm  
# End of macro CALLMONITOR
20d1			;	ex de,hl 
20d1			endif	 
20d1				; in case of spaces, skip the ptr past the copied string 
20d1				;pop af 
20d1				;ld (cli_origptr),hl 
20d1			 
20d1 c9				ret 
20d2			 
20d2			 
20d2			 
20d2			; TODO ascii push input onto stack given hl to start of input 
20d2			 
20d2			; identify type 
20d2			; if starts with a " then a string 
20d2			; otherwise it is a number 
20d2			;  
20d2			; if a string 
20d2			;     scan for ending " to get length of string to malloc for + 1 
20d2			;     malloc 
20d2			;     put pointer to string on stack first byte flags as string 
20d2			; 
20d2			; else a number 
20d2			;    look for number format identifier 
20d2			;    $xx hex 
20d2			;    %xxxxx bin 
20d2			;    xxxxx decimal 
20d2			;    convert number to 16bit word.  
20d2			;    malloc word + 1 with flag to identiy as num 
20d2			;    put pointer to number on stack 
20d2			;   
20d2			;  
20d2			  
20d2			forth_apush: 
20d2				; kernel push 
20d2			 
20d2			if DEBUG_FORTH_PUSH 
20d2						DMARK "PSH" 
20d2 f5				push af  
20d3 3a e7 20			ld a, (.dmark)  
20d6 32 9d fd			ld (debug_mark),a  
20d9 3a e8 20			ld a, (.dmark+1)  
20dc 32 9e fd			ld (debug_mark+1),a  
20df 3a e9 20			ld a, (.dmark+2)  
20e2 32 9f fd			ld (debug_mark+2),a  
20e5 18 03			jr .pastdmark  
20e7 ..			.dmark: db "PSH"  
20ea f1			.pastdmark: pop af  
20eb			endm  
# End of macro DMARK
20eb				CALLMONITOR 
20eb cd aa fd			call debug_vector  
20ee				endm  
# End of macro CALLMONITOR
20ee			endif	 
20ee				; identify input type 
20ee			 
20ee 7e				ld a,(hl) 
20ef			 
20ef fe 23			cp '#' 
20f1 ca 29 21			jp z, .fapdec 
20f4			 
20f4			 
20f4 fe 22			cp '"' 
20f6 28 0a			jr z, .fapstr 
20f8 fe 24			cp '$' 
20fa ca 21 21			jp z, .faphex 
20fd fe 25			cp '%' 
20ff ca 0a 21			jp z, .fapbin 
2102			;	cp 'b' 
2102			;	jp z, .fabin 
2102				; else decimal 
2102			 
2102				; TODO do decimal conversion 
2102				; decimal is stored as a 16bit word 
2102			 
2102				; by default everything is a string if type is not detected 
2102			.fapstr: ; 
2102 fe 22			cp '"' 
2104 20 01			jr nz, .strnoqu 
2106 23				inc hl 
2107			.strnoqu: 
2107 c3 da 1f			jp forth_push_str 
210a			 
210a			 
210a			 
210a			.fapbin:    ; push a binary string.  
210a 11 00 00			ld de, 0   ; hold a 16bit value 
210d			 
210d 23			.fapbinshift:	inc hl  
210e 7e				ld a,(hl) 
210f			;	cp 0     ; done scanning  
210f b7				or a 
2110 28 0b			jr z, .fapbdone  	; got it in HL so push  
2112			 
2112				; left shift de 
2112 eb				ex de, hl	 
2113 29				add hl, hl 
2114			 
2114				; is 1 
2114 fe 31			cp '1' 
2116 20 02			jr nz, .binzero 
2118 cb 4d			bit 1, l 
211a			.binzero: 
211a eb				ex de, hl	 ; save current de 
211b 18 f0			jr .fapbinshift 
211d			 
211d			.fapbdone: 
211d eb				ex de, hl 
211e c3 70 1f			jp forth_push_numhl 
2121			 
2121			 
2121			.faphex:   ; hex is always stored as a 16bit word 
2121				; skip number prefix 
2121 23				inc hl 
2122				; turn ascii into number 
2122 cd 5e 12			call get_word_hl	; ret 16bit word in hl 
2125			 
2125 c3 70 1f			jp forth_push_numhl 
2128			 
2128			;	 nop 
2128			 
2128			.fabin:   ; TODO bin conversion 
2128			 
2128			 
2128 c9				ret 
2129			.fapdec:	 
2129				; string to dec conversion 
2129 23				inc hl 
212a eb				ex de, hl 
212b cd 9b 12			call string_to_uint16 
212e c3 70 1f			jp forth_push_numhl 
2131 c9				ret 
2132				 
2132			;atoui_16: 
2132			 
2132			; get either a string ptr or a 16bit word from the data stack 
2132			 
2132			FORTH_DSP: macro 
2132				call macro_forth_dsp 
2132				endm 
2132			 
2132			macro_forth_dsp: 
2132				; data stack pointer points to current word on tos 
2132			 
2132 2a 20 f9			ld hl,(cli_data_sp) 
2135			 
2135				if DEBUG_FORTH_PUSH 
2135						DMARK "DSP" 
2135 f5				push af  
2136 3a 4a 21			ld a, (.dmark)  
2139 32 9d fd			ld (debug_mark),a  
213c 3a 4b 21			ld a, (.dmark+1)  
213f 32 9e fd			ld (debug_mark+1),a  
2142 3a 4c 21			ld a, (.dmark+2)  
2145 32 9f fd			ld (debug_mark+2),a  
2148 18 03			jr .pastdmark  
214a ..			.dmark: db "DSP"  
214d f1			.pastdmark: pop af  
214e			endm  
# End of macro DMARK
214e			 
214e cd 6a 65				call display_data_sp 
2151				;call break_point_state 
2151				;rst 030h 
2151				CALLMONITOR 
2151 cd aa fd			call debug_vector  
2154				endm  
# End of macro CALLMONITOR
2154				endif 
2154			 
2154 c9				ret 
2155			 
2155			; return hl to start of value on stack 
2155			 
2155			FORTH_DSP_VALUE: macro 
2155				call macro_forth_dsp_value 
2155				endm 
2155			 
2155			macro_forth_dsp_value: 
2155			 
2155				FORTH_DSP 
2155 cd 32 21			call macro_forth_dsp 
2158				endm 
# End of macro FORTH_DSP
2158			 
2158 d5				push de 
2159			 
2159 23				inc hl ; skip type 
215a			 
215a 5e				ld e, (hl) 
215b 23				inc hl 
215c 56				ld d, (hl) 
215d eb				ex de,hl  
215e			 
215e d1				pop de 
215f			 
215f c9				ret 
2160			 
2160			; return hl to start of value to second item on stack 
2160			 
2160			FORTH_DSP_VALUEM1: macro 
2160				call macro_forth_dsp_value_m1 
2160				endm 
2160			 
2160			macro_forth_dsp_value_m1: 
2160			 
2160				FORTH_DSP 
2160 cd 32 21			call macro_forth_dsp 
2163				endm 
# End of macro FORTH_DSP
2163			 
2163 2b				dec hl 
2164 2b				dec hl 
2165			;	dec hl 
2165			 
2165 d5				push de 
2166			 
2166 5e				ld e, (hl) 
2167 23				inc hl 
2168 56				ld d, (hl) 
2169 eb				ex de,hl  
216a			 
216a d1				pop de 
216b			 
216b c9				ret 
216c			 
216c				 
216c			 
216c			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
216c			 
216c			FORTH_DSP_POP: macro 
216c				call macro_forth_dsp_pop 
216c				endm 
216c			 
216c			 
216c			; get the tos data type 
216c			 
216c			FORTH_DSP_TYPE:   macro 
216c			 
216c				;FORTH_DSP_VALUE 
216c				FORTH_DSP 
216c				 
216c				; hl points to value 
216c				; check type 
216c			 
216c				ld a,(hl) 
216c			 
216c				endm 
216c			 
216c			; load the tos value into hl 
216c			 
216c			 
216c			FORTH_DSP_VALUEHL:  macro 
216c				call macro_dsp_valuehl 
216c				endm 
216c			 
216c			 
216c			 
216c			macro_dsp_valuehl: 
216c				FORTH_DSP_VALUE 
216c cd 55 21			call macro_forth_dsp_value 
216f				endm 
# End of macro FORTH_DSP_VALUE
216f			 
216f				;FORTH_ERR_TOS_NOTNUM 
216f			 
216f				;inc hl   ; skip type id 
216f			 
216f			;	push de 
216f			; 
216f			;	ld e, (hl) 
216f			;	inc hl 
216f			;	ld d, (hl) 
216f			;	ex de,hl  
216f			 
216f			;	pop de 
216f			 
216f				if DEBUG_FORTH_PUSH 
216f						DMARK "DVL" 
216f f5				push af  
2170 3a 84 21			ld a, (.dmark)  
2173 32 9d fd			ld (debug_mark),a  
2176 3a 85 21			ld a, (.dmark+1)  
2179 32 9e fd			ld (debug_mark+1),a  
217c 3a 86 21			ld a, (.dmark+2)  
217f 32 9f fd			ld (debug_mark+2),a  
2182 18 03			jr .pastdmark  
2184 ..			.dmark: db "DVL"  
2187 f1			.pastdmark: pop af  
2188			endm  
# End of macro DMARK
2188				CALLMONITOR 
2188 cd aa fd			call debug_vector  
218b				endm  
# End of macro CALLMONITOR
218b				endif 
218b c9				ret 
218c			 
218c			forth_apushstrhl:      
218c				; push of string requires use of cli_origptr 
218c				; bodge use 
218c			 
218c				; get current cli_origptr, save, update with temp pointer  
218c ed 5b 70 f9		ld de, (cli_origptr) 
2190 22 70 f9			ld (cli_origptr), hl 
2193 d5				push de 
2194 cd d2 20			call forth_apush 
2197 d1				pop de 
2198 ed 53 70 f9		ld (cli_origptr), de 
219c c9			        ret	 
219d			 
219d			 
219d			; increase loop stack pointer and save hl to it 
219d				 
219d			FORTH_LOOP_NEXT: macro 
219d				call macro_forth_loop_next 
219d				;nop 
219d				endm 
219d			 
219d			macro_forth_loop_next: 
219d				if DEBUG_FORTH_STACK_GUARD 
219d cd e2 72				call check_stacks 
21a0				endif 
21a0 e5				push hl 
21a1 d5				push de 
21a2 eb				ex de,hl 
21a3 2a 22 f9			ld hl,(cli_loop_sp) 
21a6 23				inc hl 
21a7 23				inc hl 
21a8					if DEBUG_FORTH_WORDS 
21a8						DMARK "LNX" 
21a8 f5				push af  
21a9 3a bd 21			ld a, (.dmark)  
21ac 32 9d fd			ld (debug_mark),a  
21af 3a be 21			ld a, (.dmark+1)  
21b2 32 9e fd			ld (debug_mark+1),a  
21b5 3a bf 21			ld a, (.dmark+2)  
21b8 32 9f fd			ld (debug_mark+2),a  
21bb 18 03			jr .pastdmark  
21bd ..			.dmark: db "LNX"  
21c0 f1			.pastdmark: pop af  
21c1			endm  
# End of macro DMARK
21c1						CALLMONITOR 
21c1 cd aa fd			call debug_vector  
21c4				endm  
# End of macro CALLMONITOR
21c4					endif 
21c4 22 22 f9			ld (cli_loop_sp),hl 
21c7 73				ld (hl), e 
21c8 23				inc hl 
21c9 72				ld (hl), d 
21ca d1				pop de    ; been reversed so save a swap on restore 
21cb e1				pop hl 
21cc				if DEBUG_FORTH_STACK_GUARD 
21cc cd e2 72				call check_stacks 
21cf				endif 
21cf c9				ret 
21d0			 
21d0			; get current ret stack pointer and save to hl  
21d0				 
21d0			FORTH_LOOP_TOS: macro 
21d0				call macro_forth_loop_tos 
21d0				endm 
21d0			 
21d0			macro_forth_loop_tos: 
21d0 d5				push de 
21d1 2a 22 f9			ld hl,(cli_loop_sp) 
21d4 5e				ld e, (hl) 
21d5 23				inc hl 
21d6 56				ld d, (hl) 
21d7 eb				ex de, hl 
21d8 d1				pop de 
21d9 c9				ret 
21da			 
21da			; pop loop stack pointer 
21da				 
21da			FORTH_LOOP_POP: macro 
21da				call macro_forth_loop_pop 
21da				endm 
21da			 
21da			 
21da			macro_forth_loop_pop: 
21da				if DEBUG_FORTH_STACK_GUARD 
21da					DMARK "LPP" 
21da f5				push af  
21db 3a ef 21			ld a, (.dmark)  
21de 32 9d fd			ld (debug_mark),a  
21e1 3a f0 21			ld a, (.dmark+1)  
21e4 32 9e fd			ld (debug_mark+1),a  
21e7 3a f1 21			ld a, (.dmark+2)  
21ea 32 9f fd			ld (debug_mark+2),a  
21ed 18 03			jr .pastdmark  
21ef ..			.dmark: db "LPP"  
21f2 f1			.pastdmark: pop af  
21f3			endm  
# End of macro DMARK
21f3 cd e2 72				call check_stacks 
21f6					FORTH_CHK_LOOP_UNDER 
21f6 e5				push hl 
21f7 d5				push de 
21f8 2a 22 f9			ld hl,(cli_loop_sp) 
21fb 11 5c f8			ld de, cli_loop_stack 
21fe cd ca 0f			call cmp16 
2201 da ff 73			jp c, fault_loop_under 
2204 d1				pop de 
2205 e1				pop hl 
2206				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2206				endif 
2206 e5				push hl 
2207 2a 22 f9			ld hl,(cli_loop_sp) 
220a 2b				dec hl 
220b 2b				dec hl 
220c 22 22 f9			ld (cli_loop_sp), hl 
220f				; TODO do stack underflow checks 
220f e1				pop hl 
2210				if DEBUG_FORTH_STACK_GUARD 
2210 cd e2 72				call check_stacks 
2213					FORTH_CHK_LOOP_UNDER 
2213 e5				push hl 
2214 d5				push de 
2215 2a 22 f9			ld hl,(cli_loop_sp) 
2218 11 5c f8			ld de, cli_loop_stack 
221b cd ca 0f			call cmp16 
221e da ff 73			jp c, fault_loop_under 
2221 d1				pop de 
2222 e1				pop hl 
2223				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2223				endif 
2223 c9				ret 
2224			 
2224			macro_forth_dsp_pop: 
2224			 
2224 e5				push hl 
2225			 
2225				; release malloc data 
2225			 
2225				if DEBUG_FORTH_STACK_GUARD 
2225 cd e2 72				call check_stacks 
2228					FORTH_CHK_DSP_UNDER 
2228 e5				push hl 
2229 d5				push de 
222a 2a 20 f9			ld hl,(cli_data_sp) 
222d 11 5a f6			ld de, cli_data_stack 
2230 cd ca 0f			call cmp16 
2233 da f3 73			jp c, fault_dsp_under 
2236 d1				pop de 
2237 e1				pop hl 
2238				endm 
# End of macro FORTH_CHK_DSP_UNDER
2238				endif 
2238				;ld hl,(cli_data_sp) 
2238			if DEBUG_FORTH_DOT 
2238				DMARK "DPP" 
2238 f5				push af  
2239 3a 4d 22			ld a, (.dmark)  
223c 32 9d fd			ld (debug_mark),a  
223f 3a 4e 22			ld a, (.dmark+1)  
2242 32 9e fd			ld (debug_mark+1),a  
2245 3a 4f 22			ld a, (.dmark+2)  
2248 32 9f fd			ld (debug_mark+2),a  
224b 18 03			jr .pastdmark  
224d ..			.dmark: db "DPP"  
2250 f1			.pastdmark: pop af  
2251			endm  
# End of macro DMARK
2251				CALLMONITOR 
2251 cd aa fd			call debug_vector  
2254				endm  
# End of macro CALLMONITOR
2254			endif	 
2254			 
2254			 
2254			if FORTH_ENABLE_DSPPOPFREE 
2254			 
2254				FORTH_DSP 
2254 cd 32 21			call macro_forth_dsp 
2257				endm 
# End of macro FORTH_DSP
2257			 
2257 7e				ld a, (hl) 
2258 fe 01			cp DS_TYPE_STR             ; implies that DS_TYPE_CONST *WONT* be freed 
225a 20 22			jr nz, .skippopfree 
225c			 
225c				FORTH_DSP_VALUEHL 
225c cd 6c 21			call macro_dsp_valuehl 
225f				endm 
# End of macro FORTH_DSP_VALUEHL
225f			;	nop 
225f			if DEBUG_FORTH_DOT 
225f				DMARK "DPf" 
225f f5				push af  
2260 3a 74 22			ld a, (.dmark)  
2263 32 9d fd			ld (debug_mark),a  
2266 3a 75 22			ld a, (.dmark+1)  
2269 32 9e fd			ld (debug_mark+1),a  
226c 3a 76 22			ld a, (.dmark+2)  
226f 32 9f fd			ld (debug_mark+2),a  
2272 18 03			jr .pastdmark  
2274 ..			.dmark: db "DPf"  
2277 f1			.pastdmark: pop af  
2278			endm  
# End of macro DMARK
2278				CALLMONITOR 
2278 cd aa fd			call debug_vector  
227b				endm  
# End of macro CALLMONITOR
227b			endif	 
227b cd 42 14			call free 
227e			.skippopfree: 
227e				 
227e			 
227e			endif 
227e			 
227e			if DEBUG_FORTH_DOT_KEY 
227e				DMARK "DP2" 
227e				CALLMONITOR 
227e			endif	 
227e			 
227e				; move pointer down 
227e			 
227e 2a 20 f9			ld hl,(cli_data_sp) 
2281 2b				dec hl 
2282 2b				dec hl 
2283			; PARSEV5 
2283 2b				dec hl 
2284 22 20 f9			ld (cli_data_sp), hl 
2287			 
2287				if DEBUG_FORTH_STACK_GUARD 
2287 cd e2 72				call check_stacks 
228a					FORTH_CHK_DSP_UNDER 
228a e5				push hl 
228b d5				push de 
228c 2a 20 f9			ld hl,(cli_data_sp) 
228f 11 5a f6			ld de, cli_data_stack 
2292 cd ca 0f			call cmp16 
2295 da f3 73			jp c, fault_dsp_under 
2298 d1				pop de 
2299 e1				pop hl 
229a				endm 
# End of macro FORTH_CHK_DSP_UNDER
229a				endif 
229a			 
229a e1				pop hl 
229b			 
229b c9				ret 
229c			 
229c			getwordathl: 
229c				; hl points to an address 
229c				; load hl with the word at that address 
229c			 
229c d5				push de 
229d			 
229d 5e				ld e, (hl) 
229e 23				inc hl 
229f 56				ld d, (hl) 
22a0 eb				ex de, hl 
22a1			 
22a1 d1				pop de 
22a2 c9				ret 
22a3			 
22a3			 
22a3			; functions to manuplite stack pointers 
22a3			 
22a3			; generate fragment to set hl to be pointer to a stack item 
22a3			 
22a3			FORTH_DSP_PTR: macro  x 
22a3				ld hl,(cli_data_sp) 
22a3				ld de, x * 3 
22a3				sbc hl, de 
22a3				endm 
22a3			 
22a3			 
22a3			 
22a3			; copy point in hl to stack tmp storage slots 1-4 
22a3			hltostack1: 
22a3 11 f0 f0			ld de, os_stack_1  
22a6 c3 d1 22			jp hltostackmv 
22a9			 
22a9			hltostack2:  
22a9 11 ed f0			ld de, os_stack_2 
22ac c3 d1 22			jp hltostackmv 
22af			 
22af			hltostack3:  
22af 11 ea f0			ld de, os_stack_3 
22b2 c3 d1 22			jp hltostackmv 
22b5			 
22b5			hltostack4:  
22b5 11 e7 f0			ld de, os_stack_4  
22b8 c3 d1 22			jp hltostackmv 
22bb			 
22bb			; copy to point in hl from stack tmp storage slots 1-4 
22bb			hlfromstack1: 
22bb 11 f0 f0			ld de, os_stack_1 
22be c3 d0 22			jp hlfromsttackmv 
22c1			 
22c1			hlfromstack2:  
22c1 11 ed f0			ld de, os_stack_2 
22c4 c3 d0 22			jp hlfromsttackmv 
22c7			 
22c7			hlfromstack3:  
22c7 11 ea f0			ld de, os_stack_3 
22ca c3 d0 22			jp hlfromsttackmv 
22cd			 
22cd			hlfromstack4:  
22cd 11 e7 f0			ld de, os_stack_4 
22d0			 
22d0			hlfromsttackmv: 
22d0 eb				ex de, hl 
22d1			 
22d1			hltostackmv: 
22d1			 
22d1				; do stack move 
22d1 c5				push bc 
22d2 01 03 00			ld bc, 3 
22d5 ed b0			ldir  
22d7 c1				pop bc	 
22d8 c9				ret 
22d9			 
22d9			; eof 
22d9			 
# End of file forth_stackopsv5.asm
22d9			endif 
22d9			loadwordinhl:	 
22d9			 
22d9 d5				push de 
22da			 
22da 5e				ld e, (hl) 
22db 23				inc hl 
22dc 56				ld d, (hl) 
22dd eb				ex de,hl  
22de			 
22de d1				pop de 
22df			 
22df c9				ret 
22e0			 
22e0			user_word_eol:  
22e0				; hl contains the pointer to where to create a linked list item from the end 
22e0				; of the user dict to continue on at the system word dict 
22e0				 
22e0				; poke the stub of the word list linked list to repoint to rom words 
22e0			 
22e0				; stub format 
22e0				; db   word id 
22e0				; dw    link to next word 
22e0			        ; db char length of token 
22e0				; db string + 0 term 
22e0				; db exec code....  
22e0			 
22e0			;	ld a, WORD_SYS_ROOT     ; root word 
22e0 36 00			ld (hl), WORD_SYS_ROOT		; word id 
22e2 23				inc hl 
22e3			 
22e3 11 8c 24			ld de, sysdict 
22e6 73				ld (hl), e		; next word link ie system dict 
22e7 23				inc hl 
22e8 72				ld (hl), d		; next word link ie system dict 
22e9 23				inc hl	 
22ea			 
22ea			;	ld (hl), sysdict		; next word link ie system dict 
22ea			;	inc hl 
22ea			;	inc hl 
22ea			 
22ea			;	inc hl 
22ea			;	inc hl 
22ea			 
22ea			;	ld a, 2			; word length is 0 
22ea 36 02			ld (hl), 2 
22ec 23				inc hl 
22ed			 
22ed			;	ld a, '~'			; word length is 0 
22ed 36 7e			ld (hl), '~' 
22ef 23				inc hl 
22f0			;	ld a, 0			; save empty word 
22f0 36 00			ld (hl), 0 
22f2			 
22f2 c9				ret 
22f3			 
22f3				 
22f3			 
22f3			forthexec_cleanup: 
22f3				FORTH_RSP_POP 
22f3 cd 38 1f			call macro_forth_rsp_pop 
22f6				endm 
# End of macro FORTH_RSP_POP
22f6 c9				ret 
22f7			 
22f7			forth_call_hl: 
22f7				; taking hl 
22f7 e5				push hl 
22f8 c9				ret 
22f9			 
22f9			; this is called to reset Forth system but keep existing uwords etc 
22f9			 
22f9			forth_warmstart: 
22f9				; setup stack over/under flow checks 
22f9				if DEBUG_FORTH_STACK_GUARD 
22f9 cd c8 72				call chk_stk_init 
22fc				endif 
22fc			 
22fc				; init stack pointers  - * these stacks go upwards *  
22fc 21 de f8			ld hl, cli_ret_stack 
22ff 22 24 f9			ld (cli_ret_sp), hl	 
2302				; set bottom of stack 
2302			;	ld a,0 
2302 36 00			ld (hl),0 
2304 23				inc hl 
2305 36 00			ld (hl),0 
2307			 
2307 21 5a f6			ld hl, cli_data_stack 
230a 22 20 f9			ld (cli_data_sp), hl	 
230d				; set bottom of stack 
230d			;	ld a,0 
230d 36 00			ld (hl),0 
230f 23				inc hl 
2310 36 00			ld (hl),0 
2312			 
2312 21 5c f8			ld hl, cli_loop_stack 
2315 22 22 f9			ld (cli_loop_sp), hl	 
2318				; set bottom of stack 
2318			;	ld a,0 
2318 36 00			ld (hl),0 
231a 23				inc hl 
231b 36 00			ld (hl),0 
231d			 
231d				; init extent of current open file 
231d			 
231d 3e 00			ld a, 0 
231f 32 9c f9			ld (store_openext), a 
2322			 
2322 c9				ret 
2323			 
2323			 
2323			 
2323			; Cold Start - this is called to setup the whole Forth system 
2323			 
2323			forth_init: 
2323			 
2323				; setup stack over/under flow checks 
2323			 
2323			;	if DEBUG_FORTH_STACK_GUARD 
2323			;		call chk_stk_init 
2323			;	endif 
2323			 
2323				; enable auto display updates (slow.....) 
2323			 
2323 3e 01			ld a, 1 
2325 32 6e f9			ld (cli_autodisplay), a 
2328			 
2328				; if storage is in use disable long reads for now 
2328 3e 00			ld a, 0 
232a 32 a7 f9			ld (store_longread), a 
232d			 
232d			 
232d				; show start up screen 
232d			 
232d cd 7c 0d			call clear_display 
2330			 
2330 3e 00			ld a,0 
2332 32 90 f9			ld (f_cursor_ptr), a 
2335			 
2335				; set start of word list in start of ram - for use when creating user words 
2335			 
2335 21 00 80			ld hl, baseram 
2338 22 f0 f3			ld (os_last_new_uword), hl 
233b cd e0 22			call user_word_eol 
233e				 
233e			;		call display_data_sp 
233e			;		call next_page_prompt 
233e			 
233e			 
233e			 
233e			 
233e c9				ret 
233f			 
233f .. 00		.bootforth: db " Forth Kernel Init ",0 
2353			 
2353			; TODO push to stack 
2353			 
2353			;  
2353			 
2353			if FORTH_PARSEV2 
2353			 
2353			 
2353				include "forth_parserv2.asm" 
2353			 
2353			endif 
2353			 
2353			 
2353			; parse cli version 1 
2353			 
2353			if FORTH_PARSEV1 
2353			 
2353			 
2353			 
2353			      include "forth_parserv1.asm" 
2353			endif 
2353				 
2353			if FORTH_PARSEV3 
2353			      include "forth_parserv3.asm" 
2353				include "forth_wordsv3.asm" 
2353			endif 
2353			 
2353			if FORTH_PARSEV4 
2353			      include "forth_parserv4.asm" 
2353				include "forth_wordsv4.asm" 
2353			endif 
2353			 
2353			if FORTH_PARSEV5 
2353			      include "forth_parserv5.asm" 
2353				include "forth_wordsv4.asm" 
2353			endif 
2353			 
2353			if FORTH_PARSEV6 
2353			      include "forth_parserv6.asm" 
2353			 
2353			 
2353			; A better parser without using malloc and string copies all over the place.  
2353			; Exec in situ should be faster 
2353			 
2353			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2353			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2353			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2353			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2353			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2353			WORD_SYS_END: equ 0   ; Opcode for all user words 
2353			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2353			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2353			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2353			 
2353			; Core word preamble macro 
2353			 
2353			CWHEAD:   macro nxtword opcode lit len opflags 
2353				db WORD_SYS_CORE+opcode             
2353				; internal op code number 
2353				dw nxtword            
2353				; link to next dict word block 
2353				db len + 1 
2353				; literal length of dict word inc zero term 
2353				db lit,0              
2353				; literal dict word 
2353			        ; TODO db opflags        
2353				endm 
2353			 
2353			 
2353			NEXTW: macro  
2353				call parse_vector 
2353				jp macro_next 
2353				endm 
2353			 
2353			macro_next: 
2353			if DEBUG_FORTH_PARSE_EXEC 
2353				DMARK "NXT" 
2353				CALLMONITOR 
2353			endif	 
2353			;	inc hl  ; skip token null term  
2353 ed 4b 72 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2357 ed 5b 70 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
235b 2a f4 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
235e			if DEBUG_FORTH_PARSE_EXEC 
235e				DMARK "}AA" 
235e				CALLMONITOR 
235e			endif	 
235e c3 43 24			jp execnext 
2361				;jp exec1 
2361			       
2361			 
2361			 
2361			; Another go at the parser to compile  
2361			 
2361			 
2361			; TODO rework parser to change all of the string words to byte tokens 
2361			; TODO do a search for  
2361			 
2361			; TODO first run normal parser to zero term sections 
2361			; TODO for each word do a token look up to get the op code 
2361			; TODO need some means to flag to the exec that this is a byte code form    
2361			 
2361			 
2361			forthcompile: 
2361			 
2361			; 
2361			; line parse: 
2361			;       parse raw input buffer 
2361			;       tokenise the words 
2361			;       malloc new copy (for looping etc) 
2361			;       copy to malloc + current pc in line to start of string and add line term 
2361			;       save on new rsp 
2361			; 
2361			 
2361			; hl to point to the line to tokenise 
2361			 
2361			;	push hl 
2361 22 f4 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2364			 
2364			;	ld a,0		; string term on input 
2364			;	call strlent 
2364			 
2364			;	ld (os_tok_len), hl	 ; save string length 
2364			 
2364			;if DEBUG_FORTH_TOK 
2364			;	ex de,hl		 
2364			;endif 
2364			 
2364			;	pop hl 		; get back string pointer 
2364			 
2364			if DEBUG_FORTH_TOK 
2364						DMARK "TOc" 
2364				CALLMONITOR 
2364			endif 
2364 7e			.cptoken2:    ld a,(hl) 
2365 23				inc hl 
2366 fe 7f			cp FORTH_END_BUFFER 
2368 28 26			jr z, .cptokendone2 
236a			;	cp 0 
236a b7				or a 
236b 28 23			jr z, .cptokendone2 
236d fe 22			cp '"' 
236f 28 0a			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2371 fe 20			cp ' ' 
2373 20 ef			jr nz,  .cptoken2 
2375			 
2375			; TODO consume comments held between ( and ) 
2375			 
2375				; we have a space so change to zero term for dict match later 
2375 2b				dec hl 
2376			;	ld a,0 
2376 36 00			ld (hl), 0 
2378 23				inc hl 
2379 18 e9			jr .cptoken2 
237b				 
237b			 
237b			.cptokenstr2: 
237b				; skip all white space until either eol (because forgot to term) or end double quote 
237b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
237b				;inc hl ; skip current double quote 
237b 7e				ld a,(hl) 
237c 23				inc hl 
237d fe 22			cp '"' 
237f 28 e3			jr z, .cptoken2 
2381 fe 7f			cp FORTH_END_BUFFER 
2383 28 0b			jr z, .cptokendone2 
2385			;	cp 0 
2385 b7				or a 
2386 28 08			jr z, .cptokendone2 
2388 fe 20			cp ' ' 
238a 28 02			jr z, .cptmp2 
238c 18 ed			jr .cptokenstr2 
238e			 
238e			.cptmp2:	; we have a space so change to zero term for dict match later 
238e				;dec hl 
238e				;ld a,"-"	; TODO remove this when working 
238e				;ld (hl), a 
238e				;inc hl 
238e 18 eb			jr .cptokenstr2 
2390			 
2390			.cptokendone2: 
2390				;inc hl 
2390			;	ld a, FORTH_END_BUFFER 
2390 36 7f			ld (hl),FORTH_END_BUFFER 
2392			;	inc hl 
2392			;	ld a, '!' 
2392			;	ld (hl),a 
2392			 
2392 2a f4 f3			ld hl,(os_tok_ptr) 
2395			         
2395			if DEBUG_FORTH_TOK 
2395						DMARK "Tc1" 
2395				CALLMONITOR 
2395			endif 
2395			 
2395				; push exec string to top of return stack 
2395				FORTH_RSP_NEXT 
2395 cd 17 1f			call macro_forth_rsp_next 
2398				endm 
# End of macro FORTH_RSP_NEXT
2398 c9				ret 
2399			 
2399			; Another go at the parser need to simplify the process 
2399			 
2399			forthparse: 
2399			 
2399			; 
2399			; line parse: 
2399			;       parse raw input buffer 
2399			;       tokenise the words 
2399			;       malloc new copy (for looping etc) 
2399			;       copy to malloc + current pc in line to start of string and add line term 
2399			;       save on new rsp 
2399			; 
2399			 
2399			; hl to point to the line to tokenise 
2399			 
2399			;	push hl 
2399 22 f4 f3			ld (os_tok_ptr), hl  ; save ptr to string 
239c			 
239c			;	ld a,0		; string term on input 
239c			;	call strlent 
239c			 
239c			;	ld (os_tok_len), hl	 ; save string length 
239c			 
239c			;if DEBUG_FORTH_TOK 
239c			;	ex de,hl		 
239c			;endif 
239c			 
239c			;	pop hl 		; get back string pointer 
239c			 
239c			if DEBUG_FORTH_TOK 
239c						DMARK "TOK" 
239c				CALLMONITOR 
239c			endif 
239c 7e			.ptoken2:    ld a,(hl) 
239d 23				inc hl 
239e fe 7f			cp FORTH_END_BUFFER 
23a0 28 26			jr z, .ptokendone2 
23a2			;	cp 0 
23a2 b7				or a 
23a3 28 23			jr z, .ptokendone2 
23a5 fe 22			cp '"' 
23a7 28 0a			jr z, .ptokenstr2     ; will want to skip until end of string delim 
23a9 fe 20			cp ' ' 
23ab 20 ef			jr nz,  .ptoken2 
23ad			 
23ad			; TODO consume comments held between ( and ) 
23ad			 
23ad				; we have a space so change to zero term for dict match later 
23ad 2b				dec hl 
23ae			;	ld a,0 
23ae 36 00			ld (hl), 0 
23b0 23				inc hl 
23b1 18 e9			jr .ptoken2 
23b3				 
23b3			 
23b3			.ptokenstr2: 
23b3				; skip all white space until either eol (because forgot to term) or end double quote 
23b3			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
23b3				;inc hl ; skip current double quote 
23b3 7e				ld a,(hl) 
23b4 23				inc hl 
23b5 fe 22			cp '"' 
23b7 28 e3			jr z, .ptoken2 
23b9 fe 7f			cp FORTH_END_BUFFER 
23bb 28 0b			jr z, .ptokendone2 
23bd			;	cp 0 
23bd b7				or a 
23be 28 08			jr z, .ptokendone2 
23c0 fe 20			cp ' ' 
23c2 28 02			jr z, .ptmp2 
23c4 18 ed			jr .ptokenstr2 
23c6			 
23c6			.ptmp2:	; we have a space so change to zero term for dict match later 
23c6				;dec hl 
23c6				;ld a,"-"	; TODO remove this when working 
23c6				;ld (hl), a 
23c6				;inc hl 
23c6 18 eb			jr .ptokenstr2 
23c8			 
23c8			.ptokendone2: 
23c8				;inc hl 
23c8			;	ld a, FORTH_END_BUFFER 
23c8 36 7f			ld (hl),FORTH_END_BUFFER 
23ca			;	inc hl 
23ca			;	ld a, '!' 
23ca			;	ld (hl),a 
23ca			 
23ca 2a f4 f3			ld hl,(os_tok_ptr) 
23cd			         
23cd			if DEBUG_FORTH_TOK 
23cd						DMARK "TK1" 
23cd				CALLMONITOR 
23cd			endif 
23cd			 
23cd				; push exec string to top of return stack 
23cd				FORTH_RSP_NEXT 
23cd cd 17 1f			call macro_forth_rsp_next 
23d0				endm 
# End of macro FORTH_RSP_NEXT
23d0 c9				ret 
23d1			 
23d1			; 
23d1			;	; malloc size + buffer pointer + if is loop flag 
23d1			;	ld hl,(os_tok_len) 		 ; get string length 
23d1			; 
23d1			;	ld a,l 
23d1			; 
23d1			;	cp 0			; we dont want to use a null string 
23d1			;	ret z 
23d1			; 
23d1			;;	add 3    ; prefix malloc with buffer for current word ptr 
23d1			; 
23d1			;	add 5     ; TODO when certain not over writing memory remove 
23d1			; 
23d1			;		 
23d1			; 
23d1			;if DEBUG_FORTH_TOK 
23d1			;			DMARK "TKE" 
23d1			;	CALLMONITOR 
23d1			;endif 
23d1			; 
23d1			;	ld l,a 
23d1			;	ld h,0 
23d1			;;	push hl   ; save required space for the copy later 
23d1			;	call malloc 
23d1			;if DEBUG_FORTH_TOK 
23d1			;			DMARK "TKM" 
23d1			;	CALLMONITOR 
23d1			;endif 
23d1			;	if DEBUG_FORTH_MALLOC_GUARD 
23d1			;		push af 
23d1			;		call ishlzero 
23d1			;;		ld a, l 
23d1			;;		add h 
23d1			;;		cp 0 
23d1			;		pop af 
23d1			;		 
23d1			;		call z,malloc_error 
23d1			;	endif 
23d1			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
23d1			; 
23d1			; 
23d1			;if DEBUG_FORTH_TOK 
23d1			;			DMARK "TKR" 
23d1			;	CALLMONITOR 
23d1			;endif 
23d1			; 
23d1			;	FORTH_RSP_NEXT 
23d1			; 
23d1			;	;inc hl	 ; go past current buffer pointer 
23d1			;	;inc hl 
23d1			;	;inc hl   ; and past if loop flag 
23d1			;		; TODO Need to set flag  
23d1			; 
23d1			;	 
23d1			;	 
23d1			;	ex de,hl	; malloc is dest 
23d1			;	ld hl, (os_tok_len) 
23d1			;;	pop bc 
23d1			;	ld c, l                
23d1			;	ld b,0 
23d1			;	ld hl, (os_tok_ptr) 
23d1			; 
23d1			;if DEBUG_FORTH_TOK 
23d1			;			DMARK "TKT" 
23d1			;	CALLMONITOR 
23d1			;endif 
23d1			; 
23d1			;	; do str cpy 
23d1			; 
23d1			;	ldir      ; copy byte in hl to de 
23d1			; 
23d1			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
23d1			; 
23d1			;if DEBUG_FORTH_TOK 
23d1			; 
23d1			;			DMARK "TKY" 
23d1			;	CALLMONITOR 
23d1			;endif 
23d1			;	;ld a,0 
23d1			;	;ld a,FORTH_END_BUFFER 
23d1			;	ex de, hl 
23d1			;	;dec hl			 ; go back over the space delim at the end of word 
23d1			;	;ld (hl),a 
23d1			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
23d1			;	ld a,FORTH_END_BUFFER 
23d1			;	ld (hl),a 
23d1			;	inc hl 
23d1			;	ld a,FORTH_END_BUFFER 
23d1			;	ld (hl),a 
23d1			; 
23d1			;	; init the malloc area data 
23d1			;	; set pc for in current area 
23d1			;	;ld hl, (os_tok_malloc) 
23d1			;	;inc hl 
23d1			;	;inc hl 
23d1			;	;inc hl 
23d1			;	;ex de,hl 
23d1			;	;ld hl, (os_tok_malloc) 
23d1			;	;ld (hl),e 
23d1			;	;inc hl 
23d1			;	;ld (hl),d 
23d1			; 
23d1			; 
23d1			;	ld hl,(os_tok_malloc) 
23d1			;if DEBUG_FORTH_PARSE_KEY 
23d1			;			DMARK "TKU" 
23d1			;	CALLMONITOR 
23d1			;endif 
23d1			; 
23d1			;	ret 
23d1			 
23d1			forthexec: 
23d1			 
23d1			; line exec: 
23d1			; forth parser 
23d1			 
23d1			; 
23d1			;       get current exec line on rsp 
23d1			 
23d1				FORTH_RSP_TOS 
23d1 cd 2e 1f			call macro_forth_rsp_tos 
23d4				endm 
# End of macro FORTH_RSP_TOS
23d4			 
23d4			;       restore current pc - hl points to malloc of data 
23d4			 
23d4				;ld e, (hl) 
23d4				;inc hl 
23d4				;ld d, (hl) 
23d4				;ex de,hl 
23d4			 
23d4			 
23d4			exec1: 
23d4 22 f4 f3			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
23d7			 
23d7				; copy our PC to working vars  
23d7 22 72 f9			ld (cli_ptr), hl                    ; here 
23da 22 70 f9			ld (cli_origptr), hl                ; here 
23dd			 
23dd 7e				ld a,(hl)                           ; here make hl be the ram ptr 
23de fe 7f			cp FORTH_END_BUFFER 
23e0 c8				ret z 
23e1			 
23e1				; skip any nulls 
23e1			 
23e1			;	cp 0 
23e1 b7				or a 
23e2 20 03			jr nz, .execword 
23e4 23				inc hl 
23e5 18 ed			jr exec1 
23e7			 
23e7			 
23e7			.execword: 
23e7			 
23e7			 
23e7			 
23e7			if DEBUG_FORTH_PARSE_EXEC 
23e7						DMARK "KYQ" 
23e7				CALLMONITOR 
23e7			endif 
23e7			;       while at start of word: 
23e7			; get start of dict (in user area first) 
23e7			 
23e7 21 00 80		ld hl, baseram 
23ea			;ld hl, sysdict 
23ea 22 74 f9		ld (cli_nextword),hl                            ; here do we need to do this? 
23ed			;           match word at pc 
23ed			;           exec word 
23ed			;           or push to dsp 
23ed			;           forward to next token 
23ed			;           if line term pop rsp and exit 
23ed			;        
23ed			 
23ed			if DEBUG_FORTH_PARSE_EXEC 
23ed						DMARK "KYq" 
23ed				CALLMONITOR 
23ed			endif 
23ed			 
23ed			; 
23ed			; word comp 
23ed			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
23ed			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
23ed			;    move to start of word  
23ed			;    compare word to cli_token 
23ed			 
23ed			.execpnword:	; HL at start of a word in the dictionary to check 
23ed			 
23ed 2a 74 f9			ld hl,(cli_nextword)                  ; here remove the need to store???? 
23f0			 
23f0 cd 85 24			call forth_tok_next 
23f3			; tok next end here 
23f3 22 74 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
23f6 eb				ex de, hl 
23f7			 
23f7			 
23f7				; save the pointer of the current token - 1 to check against 
23f7				 
23f7 22 78 f9			ld (cli_token), hl   
23fa				; TODO maybe remove below save if no debug 
23fa				; save token string ptr for any debug later 
23fa 23				inc hl  
23fb 22 7a f9			ld (cli_origtoken), hl 
23fe 2b				dec hl 
23ff				; save pointer to the start of the next dictionay word 
23ff 7e				ld a,(hl)   ; get string length 
2400 47				ld b,a 
2401			.execpnwordinc:  
2401 23				inc hl 
2402 10 fd			djnz .execpnwordinc 
2404 22 76 f9			ld (cli_execword), hl      ; save start of this words code 
2407			 
2407				; now check the word token against the string being parsed 
2407			 
2407 2a 78 f9			ld hl,(cli_token) 
240a 23				inc hl     ; skip string length (use zero term instead to end) 
240b				;ld (cli_token), hl 
240b			 
240b			.execpnchar:    ; compare char between token and string to parse 
240b			 
240b			 
240b				;ld hl, (cli_token)     ; the dict word  
240b ed 5b 72 f9		ld de, (cli_ptr)     ; cli to parse 
240f			 
240f			 
240f			.execpncharl:    ; compare char between token and string to parse (loop) 
240f			 
240f 1a				ld a,(de) 
2410 cd fb 12			call toUpper 		; make sure the input string matches case 
2413 be				cp (hl) 
2414			 
2414 c2 2c 24			jp nz, .execpnskipword	 ; no match so move to next word 
2417				 
2417			;    if same 
2417			;       scan for string terms 0 for token and 32 for input 
2417 46				ld b,(hl) 
2418 80				add b			 
2419 23				inc hl 
241a 13				inc de 
241b b7				or a 
241c			;	cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
241c							; TODO need to make sure last word in zero term string is accounted for 
241c 20 f1			jr nz, .execpncharl 		 ; not at end of strings yet 
241e			 
241e			 
241e				; at end of both strings so both are exact match 
241e			 
241e			;       skip ptr for next word 
241e			 
241e 2a 72 f9			ld hl,(cli_ptr) 	; at input string term 
2421 23				inc hl			 ; at next char 
2422 22 72 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2425 22 70 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2428				 
2428				 
2428			 
2428			 
2428			 
2428			;       exec code block 
2428			if DEBUG_FORTH_JP 
2428				call clear_display 
2428				call update_display 
2428				call delay1s 
2428				ld hl, (cli_execword)     ; save for next check if no match on this word 
2428				ld a,h 
2428				ld hl, os_word_scratch 
2428				call hexout 
2428				ld hl, (cli_execword)     ; save for next check if no match on this word 
2428				ld a,l 
2428				ld hl, os_word_scratch+2 
2428				call hexout 
2428				ld hl, os_word_scratch+4 
2428			;	ld a,0 
2428				ld (hl),0 
2428				ld de,os_word_scratch 
2428				call str_at_display 
2428					ld a, display_row_2 
2428					call str_at_display 
2428				ld de, (cli_origtoken) 
2428				ld a, display_row_1+10 
2428					call str_at_display 
2428			 
2428				ld a,display_row_1 
2428				ld de, .foundword 
2428				ld a, display_row_3 
2428				call str_at_display 
2428				call update_display 
2428				call delay1s 
2428				call delay1s 
2428				call delay1s 
2428			endif 
2428			 
2428			if DEBUG_FORTH_PARSE_EXEC 
2428						DMARK "KYj" 
2428			endif 
2428				; TODO save the word pointer in this exec 
2428			 
2428 2a 76 f9			ld hl,(cli_execword) 
242b e9				jp (hl) 
242c			 
242c			 
242c			;    if not same 
242c			;	scan for zero term 
242c			;	get ptr for next word 
242c			;	goto word comp 
242c			 
242c			.execpnskipword:	; get pointer to next word 
242c 2a 74 f9			ld hl,(cli_nextword) 
242f			 
242f 7e				ld a,(hl) 
2430 fe 00			cp WORD_SYS_END 
2432			;	cp 0 
2432 28 09			jr z, .execendofdict			 ; at end of words 
2434			 
2434			if DEBUG_FORTH_PARSE_EXEC 
2434						DMARK "KY4" 
2434			endif 
2434			if DEBUG_FORTH_PARSE_EXEC 
2434			 
2434				; see if disabled 
2434			 
2434			;	ld a, (os_view_disable) 
2434			;	cp '*' 
2434				ld a,(debug_vector) 
2434				cp $c9   ; RET 
2434				jr z, .noskip 
2434			 
2434			 
2434				ld de, .nowordfound 
2434				ld a, display_row_3 
2434				call str_at_display 
2434				call update_display 
2434				ld a, 100 
2434				call aDelayInMS 
2434				 
2434				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2434					call delay250ms 
2434				endif 
2434			.noskip:  
2434			 
2434			endif	 
2434			 
2434 2a 70 f9			ld hl,(cli_origptr) 
2437 22 72 f9			ld (cli_ptr),hl 
243a			 
243a			if DEBUG_FORTH_PARSE_EXEC 
243a						DMARK "KY5" 
243a			endif 
243a c3 ed 23			jp .execpnword			; else go to next word 
243d			 
243d			.execendofdict:  
243d			 
243d			if DEBUG_FORTH_PARSE_EXEC 
243d						DMARK "KYe" 
243d			endif 
243d			if DEBUG_FORTH_PARSE_EXEC 
243d				; see if disabled 
243d			 
243d			;	ld a, (os_view_disable) 
243d			;	cp '*' 
243d				ld a,(debug_vector) 
243d				cp $c9   ; ret 
243d				jr z, .ispskip 
243d			 
243d				call clear_display 
243d				call update_display 
243d				call delay1s 
243d				ld de, (cli_origptr) 
243d				ld a, display_row_1 
243d				call str_at_display 
243d				 
243d				ld de, .enddict 
243d				ld a, display_row_3 
243d				call str_at_display 
243d				call update_display 
243d				ld a, 100 
243d				call aDelayInMS 
243d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
243d				call delay1s 
243d				call delay1s 
243d				call delay1s 
243d				endif 
243d			.ispskip:  
243d				 
243d			endif	 
243d			 
243d			 
243d			 
243d				; if the word is not a keyword then must be a literal so push it to stack 
243d			 
243d			; push token to stack to end of word 
243d			 
243d				STACKFRAME ON $1efe $2f9f 
243d				if DEBUG_STACK_IMB 
243d					if ON 
243d						exx 
243d						ld de, $1efe 
243d						ld a, d 
243d						ld hl, curframe 
243d						call hexout 
243d						ld a, e 
243d						ld hl, curframe+2 
243d						call hexout 
243d						ld hl, $1efe 
243d						push hl 
243d						ld hl, $2f9f 
243d						push hl 
243d						exx 
243d					endif 
243d				endif 
243d			endm 
# End of macro STACKFRAME
243d			 
243d 2a f4 f3		ld hl,(os_tok_ptr) 
2440 cd d2 20		call forth_apush 
2443			 
2443				STACKFRAMECHK ON $1efe $2f9f 
2443				if DEBUG_STACK_IMB 
2443					if ON 
2443						exx 
2443						ld hl, $2f9f 
2443						pop de   ; $2f9f 
2443						call cmp16 
2443						jr nz, .spnosame 
2443						ld hl, $1efe 
2443						pop de   ; $1efe 
2443						call cmp16 
2443						jr z, .spfrsame 
2443						.spnosame: call showsperror 
2443						.spfrsame: nop 
2443						exx 
2443					endif 
2443				endif 
2443			endm 
# End of macro STACKFRAMECHK
2443			 
2443			execnext: 
2443			 
2443			if DEBUG_FORTH_PARSE_EXEC 
2443						DMARK "KY>" 
2443			endif 
2443			; move past token to next word 
2443			 
2443 2a f4 f3		ld hl, (os_tok_ptr) 
2446 3e 00		ld a, 0 
2448 01 ff 00		ld bc, 255     ; input buffer size 
244b ed b1		cpir 
244d			 
244d			if DEBUG_FORTH_PARSE_EXEC 
244d						DMARK "KY!" 
244d				CALLMONITOR 
244d			endif	 
244d			; TODO this might place hl on the null, so will need to forward on??? 
244d			;inc hl   ; see if this gets onto the next item 
244d			 
244d			 
244d			; TODO pass a pointer to the buffer to push 
244d			; TODO call function to push 
244d			 
244d			; look for end of input 
244d			 
244d			;inc hl 
244d			;ld a,(hl) 
244d			;cp FORTH_END_BUFFER 
244d			;ret z 
244d			 
244d			 
244d c3 d4 23		jp exec1 
2450			 
2450			 
2450			 
2450			 
2450			 
2450			 
2450			 
2450			 
2450			 
2450			findnexttok: 
2450			 
2450				; hl is pointer to move 
2450				; de is the token to locate 
2450			 
2450					if DEBUG_FORTH 
2450						DMARK "NTK" 
2450						CALLMONITOR 
2450					endif 
2450 d5				push de 
2451			 
2451			.fnt1:	 
2451				; find first char of token to locate 
2451			 
2451 1a				ld a, (de) 
2452 4f				ld c,a 
2453 7e				ld a,(hl) 
2454 cd fb 12			call toUpper 
2457					if DEBUG_FORTH 
2457						DMARK "NT1" 
2457						CALLMONITOR 
2457					endif 
2457 b9				cp c 
2458			 
2458 28 03			jr z, .fnt2cmpmorefirst	 
245a			 
245a				; first char not found move to next char 
245a			 
245a 23				inc hl 
245b 18 f4			jr .fnt1 
245d			 
245d			.fnt2cmpmorefirst:	 
245d				; first char of token found.  
245d			 
245d e5				push hl     ; save start of token just in case it is the right one 
245e d9				exx 
245f e1				pop hl        ; save it to hl' 
2460 d9				exx 
2461			 
2461			 
2461			.fnt2cmpmore:	 
2461				; compare the rest 
2461				 
2461 23				inc hl 
2462 13				inc de 
2463				 
2463 1a				ld a, (de) 
2464 4f				ld c,a 
2465 7e				ld a,(hl) 
2466 cd fb 12			call toUpper 
2469			 
2469					if DEBUG_FORTH 
2469						DMARK "NT2" 
2469						CALLMONITOR 
2469					endif 
2469				; c has the token to find char 
2469				; a has the mem to scan char 
2469			 
2469 b9				cp c 
246a 28 04			jr z,.fntmatch1 
246c			 
246c				; they are not the same 
246c			 
246c					if DEBUG_FORTH 
246c						DMARK "NT3" 
246c						CALLMONITOR 
246c					endif 
246c d1				pop de	; reset de token to look for 
246d d5				push de 
246e 18 e1			jr .fnt1 
2470				 
2470			.fntmatch1: 
2470			 
2470				; is the same char a null which means we might have a full hit? 
2470					if DEBUG_FORTH 
2470						DMARK "NT4" 
2470						CALLMONITOR 
2470					endif 
2470			 
2470			;	cp 0 
2470 b7				or a 
2471 28 0b			jr z, .fntmatchyes 
2473			 
2473				; are we at the end of the token to find? 
2473			 
2473					if DEBUG_FORTH 
2473						DMARK "NT5" 
2473						CALLMONITOR 
2473					endif 
2473 3e 00			ld a, 0 
2475 b9				cp c 
2476			 
2476 c2 61 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2479			 
2479					if DEBUG_FORTH 
2479						DMARK "NT6" 
2479						CALLMONITOR 
2479					endif 
2479				; token to find is exhusted but no match to stream 
2479			 
2479				; restore tok pointer and continue on 
2479 d1				pop de 
247a d5				push de 
247b c3 51 24			jp .fnt1 
247e			 
247e			 
247e			.fntmatchyes: 
247e			 
247e				; hl now contains the end of the found token 
247e			 
247e				; get rid of saved token pointer to find 
247e			 
247e d1				pop de 
247f			 
247f					if DEBUG_FORTH 
247f						DMARK "NT9" 
247f						CALLMONITOR 
247f					endif 
247f			 
247f				; hl will be on the null term so forward on 
247f			 
247f				; get back the saved start of the token 
247f			 
247f d9				exx 
2480 e5				push hl     ; save start of token just in case it is the right one 
2481 d9				exx 
2482 e1				pop hl        ; save it to hl 
2483			 
2483 c9				ret 
2484			 
2484			 
2484			; LIST needs to find a specific token   
2484			; FORGET needs to find a spefici token 
2484			 
2484			; SAVE needs to find all tokens by flag 
2484			; WORDS just needs to scan through all  by flag 
2484			; UWORDS needs to scan through all by flag 
2484			 
2484			 
2484			; given hl as pointer to start of dict look up string 
2484			; return hl as pointer to start of word block 
2484			; or 0 if not found 
2484			 
2484			forth_find_tok: 
2484 c9				ret 
2485			 
2485			; given hl as pointer to dict structure 
2485			; move to the next dict block structure 
2485			 
2485			forth_tok_next: 
2485				; hl now points to the address of the next word pointer  
2485				; TODO skip compiled symbol for now 
2485			;	push de 
2485 23				inc hl 
2486 5e				ld e, (hl) 
2487 23				inc hl 
2488 56				ld d, (hl) 
2489 23				inc hl 
248a			 
248a eb				ex de,hl 
248b			if DEBUG_FORTH_PARSE_NEXTWORD 
248b				push bc 
248b				ld bc, (cli_nextword) 
248b						DMARK "NXW" 
248b				CALLMONITOR 
248b				pop bc 
248b			endif 
248b			;	pop de	 
248b c9				ret 
248c			 
248c			 
248c			 
248c			; eof 
# End of file forth_parserv6.asm
248c				include "forth_wordsv4.asm" 
248c			 
248c			; the core word dictionary v4 
248c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
248c			 
248c			; this is a linked list for each of the system words used 
248c			; user defined words will follow the same format but will be in ram 
248c			 
248c			 
248c			; 
248c			; 
248c			; define linked list: 
248c			; 
248c			; 1. compiled byte op code 
248c			; 2. len of text word 
248c			; 3. text word 
248c			; 4. ptr to next dictionary word 
248c			; 5. asm, calls etc for the word 
248c			; 
248c			;  if 1 == 0 then last word in dict  
248c			;   
248c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
248c			;  
248c			;  
248c			; create basic standard set of words 
248c			; 
248c			;  
248c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
248c			; 2DUP 2DROP 2SWAP  
248c			; @ C@ - get byte  
248c			; ! C! - store byte 
248c			; 0< true if less than zero 
248c			; 0= true if zero 
248c			; < >  
248c			; = true if same 
248c			; variables 
248c			 
248c			 
248c			; Hardware specific words I may need 
248c			; 
248c			; IN OUT  
248c			; calls to key util functions 
248c			; calls to hardward abstraction stuff 
248c			; easy control of frame buffers and lcd i/o 
248c			; keyboard  
248c			 
248c			 
248c			;DICT: macro 
248c			; op_code, len, word, next 
248c			;    word: 
248c			;    db op_code 
248c			;    ds word zero term 
248c			;    dw next 
248c			;    endm 
248c			 
248c			 
248c			 
248c			 
248c			; op code 1 is a flag for user define words which are to be handled differently 
248c			 
248c			 
248c			; 
248c			; 
248c			;    TODO on entry to a word this should be the expected environment 
248c			;    hl - tos value if number then held, if string this is the ptr 
248c			;    de -  
248c			 
248c			 
248c			; opcode ranges 
248c			; 0 - end of word dict 
248c			; 255 - user define words 
248c			 
248c			sysdict: 
248c			include "forth_opcodes.asm" 
248c			; op codes for forth keywords 
248c			 
248c			; Changing use of opcodes to flag is the word exists in compiled form or not.  
248c			; This provides a means to compile uwords if required for higher performance 
248c			; by avoiding the use of the keyword parser and just jumping directly to the code 
248c			; Actually there is already a flag for if the code exists as binary thinking about it... 
248c			 
248c			 
248c			 
248c			 
248c			 
248c			; free to use code 0  
248c				OPCODE_HEAP: equ  1 
248c				OPCODE_EXEC: equ 2 
248c				OPCODE_DUP: equ 3 
248c				OPCODE_SWAP: equ 4 
248c				OPCODE_COLN: equ 5 
248c				OPCODE_SCOLN: equ 6 
248c				OPCODE_DROP: equ 7 
248c				OPCODE_DUP2: equ 8 
248c				OPCODE_DROP2: equ 9 
248c				OPCODE_SWAP2: equ 10 
248c				OPCODE_AT: equ 11 
248c				OPCODE_CAT: equ 12 
248c				OPCODE_BANG: equ 13 
248c				OPCODE_CBANG: equ 14 
248c				OPCODE_SCALL: equ 15 
248c				OPCODE_DEPTH: equ 16 
248c				OPCODE_OVER: equ 17 
248c				OPCODE_PAUSE: equ 18 
248c				OPCODE_PAUSES: equ 19 
248c				OPCODE_ROT: equ 20 
248c			;free to reuse	OPCODE_WORDS: equ 21 
248c			        OPCODE_NOT: equ 21 
248c				OPCODE_UWORDS: equ 22 
248c				OPCODE_BP: equ 23 
248c				OPCODE_MONITOR: equ 24  
248c				OPCODE_MALLOC: equ 25 
248c				OPCODE_FREE: equ 26 
248c				OPCODE_LIST: equ 27 
248c				OPCODE_FORGET: equ 28 
248c				OPCODE_NOP: equ 29 
248c				OPCODE_COMO: equ 30 
248c				OPCODE_COMC: equ 31 
248c			;free to reuse	OPCODE_ENDCORE: equ 32 
248c				OPCODE_AFTERSOUND: equ 33 
248c				OPCODE_GP2: equ 34 
248c				OPCODE_GP3: equ 35 
248c				OPCODE_GP4: equ 36 
248c				OPCODE_SIN: equ 37 
248c				OPCODE_SOUT: equ 38 
248c				OPCODE_SPIO: equ 39 
248c				OPCODE_SPICEH: equ 40 
248c				OPCODE_SPIOb: equ 41 
248c				OPCODE_SPII: equ 42 
248c				OPCODE_SESEL: equ 43 
248c				OPCODE_CARTDEV: equ 44 
248c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
248c				OPCODE_FB: equ 46 
248c				OPCODE_EMIT: equ 47 
248c				OPCODE_DOTH: equ 48 
248c				OPCODE_DOTF: equ 49 
248c				OPCODE_DOT: equ 50 
248c				OPCODE_CLS: equ 51 
248c				OPCODE_DRAW: equ 52 
248c				OPCODE_DUMP: equ 53 
248c				OPCODE_CDUMP: equ 54 
248c				OPCODE_DAT: equ 55 
248c				OPCODE_HOME: equ 56 
248c				OPCODE_SPACE: equ 57 
248c				OPCODE_SPACES: equ 58 
248c				OPCODE_SCROLL: equ 59 
248c				OPCODE_ATQ: equ 60 
248c				OPCODE_AUTODSP: equ 61 
248c				OPCODE_MENU: equ 62 
248c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
248c				OPCODE_THEN: equ 64 
248c				OPCODE_ELSE: equ 65 
248c				OPCODE_DO: equ 66 
248c				OPCODE_LOOP: equ 67 
248c				OPCODE_I: equ 68 
248c				OPCODE_DLOOP: equ 69  
248c				OPCODE_REPEAT: equ 70  
248c				OPCODE_UNTIL: equ 71 
248c				OPCODE_ENDFLOW: equ 72 
248c				OPCODE_WAITK: equ 73 
248c				OPCODE_ACCEPT: equ 74 
248c				OPCODE_EDIT: equ 75 
248c			;free to reuse	OPCODE_ENDKEY: equ 76 
248c				OPCODE_LZERO: equ 77 
248c				OPCODE_TZERO: equ 78 
248c				OPCODE_LESS: equ 79 
248c				OPCODE_GT: equ 80 
248c				OPCODE_EQUAL: equ 81  
248c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
248c				OPCODE_NEG: equ 83 
248c				OPCODE_DIV: equ 84 
248c				OPCODE_MUL: equ 85 
248c				OPCODE_MIN: equ 86 
248c				OPCODE_MAX: equ 87 
248c				OPCODE_RND16: equ 88 
248c				OPCODE_RND8: equ 89 
248c				OPCODE_RND: equ 90 
248c			;free to reuse	OPCODE_ENDMATHS: equ 91  
248c				OPCODE_BYNAME: equ 92 
248c				OPCODE_DIR: equ 93 
248c				OPCODE_SAVE: equ 94 
248c				OPCODE_LOAD: equ 95 
248c				OPCODE_BSAVE: equ 96 
248c				OPCODE_BLOAD: equ 97 
248c				OPCODE_SEO: equ 98  
248c				OPCODE_SEI: equ 99 
248c				OPCODE_SFREE: equ 100 
248c				OPCODE_SIZE: equ 101 
248c				OPCODE_CREATE: equ 102 
248c				OPCODE_APPEND: equ 103 
248c				OPCODE_SDEL: equ 104 
248c				OPCODE_OPEN: equ 105 
248c				OPCODE_READ: equ 106 
248c				OPCODE_EOF: equ 106 
248c				OPCODE_FORMAT: equ 107 
248c				OPCODE_LABEL: equ 108 
248c				OPCODE_LABELS: equ 109 
248c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
248c				OPCODE_UPPER: equ 111 
248c				OPCODE_LOWER: equ 112 
248c				OPCODE_SUBSTR: equ 113 
248c				OPCODE_LEFT: equ 114 
248c				OPCODE_RIGHT: equ 115 
248c				OPCODE_STR2NUM: equ 116 
248c				OPCODE_NUM2STR: equ 117 
248c				OPCODE_CONCAT: equ 118 
248c				OPCODE_FIND: equ 119 
248c				OPCODE_LEN: equ 120 
248c				OPCODE_CHAR: equ 121 
248c			; free to reuse	OPCODE_STRLEN: equ 122 
248c			; free to reuse	OPCODE_ENDSTR: equ 123 
248c				OPCODE_V0S: equ 124 
248c				OPCODE_V0Q: equ 125 
248c				OPCODE_V1S: equ 126 
248c				OPCODE_V1Q: equ 127 
248c				OPCODE_V2S: equ 128 
248c				OPCODE_V2Q: equ 129 
248c				OPCODE_V3S: equ 130 
248c				OPCODE_V3Q: equ 131 
248c			;free to reuse	OPCODE_END: equ 132 
248c				OPCODE_ZDUP: equ 133 
248c			 
248c			; eof 
# End of file forth_opcodes.asm
248c			 
248c			include "forth_words_core.asm" 
248c			 
248c			; | ## Core Words 
248c			 
248c			;if MALLOC_4 
248c			 
248c			.HEAP: 
248c			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
248c 15				db WORD_SYS_CORE+OPCODE_HEAP             
248d ce 24			dw .EXEC            
248f 05				db 4 + 1 
2490 .. 00			db "HEAP",0              
2495				endm 
# End of macro CWHEAD
2495			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2495			; | | u1 - Current number of bytes in the heap 
2495			; | | u2 - Remaining bytes left on the heap 
2495			; | |  
2495			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2495			 
2495			 
2495				if DEBUG_FORTH_WORDS_KEY 
2495					DMARK "HEP" 
2495 f5				push af  
2496 3a aa 24			ld a, (.dmark)  
2499 32 9d fd			ld (debug_mark),a  
249c 3a ab 24			ld a, (.dmark+1)  
249f 32 9e fd			ld (debug_mark+1),a  
24a2 3a ac 24			ld a, (.dmark+2)  
24a5 32 9f fd			ld (debug_mark+2),a  
24a8 18 03			jr .pastdmark  
24aa ..			.dmark: db "HEP"  
24ad f1			.pastdmark: pop af  
24ae			endm  
# End of macro DMARK
24ae					CALLMONITOR 
24ae cd aa fd			call debug_vector  
24b1				endm  
# End of macro CALLMONITOR
24b1				endif 
24b1 2a 0a 80			ld hl, (free_list )      
24b4 11 0e 80			ld de, heap_start 
24b7			 
24b7 ed 52			sbc hl, de  
24b9			 
24b9 cd 70 1f			call forth_push_numhl 
24bc			 
24bc			 
24bc ed 5b 0a 80		ld de, (free_list )      
24c0 21 ce f0			ld hl, heap_end 
24c3			 
24c3 ed 52			sbc hl, de 
24c5			 
24c5 cd 70 1f			call forth_push_numhl 
24c8				 
24c8			 
24c8				 
24c8			 
24c8			 
24c8			 
24c8				NEXTW 
24c8 cd a7 fd			call parse_vector 
24cb c3 53 23			jp macro_next 
24ce				endm 
# End of macro NEXTW
24ce			;endif 
24ce			 
24ce			.EXEC: 
24ce			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
24ce			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
24ce			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
24ce			;; > > 
24ce			;; > >   
24ce			;	STACKFRAME OFF $5efe $5f9f 
24ce			; 
24ce			;		if DEBUG_FORTH_WORDS_KEY 
24ce			;			DMARK "EXE" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			; 
24ce			;	FORTH_DSP_VALUEHL 
24ce			; 
24ce			;	FORTH_DSP_POP 
24ce			; 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EX1" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			;;	ld e,(hl) 
24ce			;;	inc hl 
24ce			;;	ld d,(hl) 
24ce			;;	ex de,hl 
24ce			; 
24ce			;;		if DEBUG_FORTH_WORDS 
24ce			;;			DMARK "EX2" 
24ce			;;			CALLMONITOR 
24ce			;;		endif 
24ce			;	push hl 
24ce			; 
24ce			;	;ld a, 0 
24ce			;	;ld a, FORTH_END_BUFFER 
24ce			;	call strlenz 
24ce			;	inc hl   ; include zero term to copy 
24ce			;	inc hl   ; include term 
24ce			;	inc hl   ; include term 
24ce			;	ld b,0 
24ce			;	ld c,l 
24ce			;	pop hl 
24ce			;	ld de, execscratch 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EX3" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			;	ldir 
24ce			; 
24ce			; 
24ce			;	ld hl, execscratch 
24ce			; 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EXe" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			; 
24ce			;	call forthparse 
24ce			;	call forthexec 
24ce			;;	call forthexec_cleanup 
24ce			;;	call forthparse 
24ce			;;	call forthexec 
24ce			; 
24ce			;	STACKFRAMECHK OFF $5efe $5f9f 
24ce			; 
24ce			;	; an immediate word so no need to process any more words 
24ce			;	ret 
24ce			;	NEXTW 
24ce			 
24ce			; dead code - old version  
24ce			;	FORTH_RSP_NEXT 
24ce			 
24ce			;  
24ce			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24ce			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24ce			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24ce			;	push hl 
24ce			;	push de 
24ce			;	push bc 
24ce			; 
24ce			; 
24ce			;		if DEBUG_FORTH_WORDS_KEY 
24ce			;			DMARK "EXR" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			; 
24ce			; 
24ce			; 
24ce			;	;v5 FORTH_DSP_VALUE 
24ce			;	FORTH_DSP_VALUEHL 
24ce			; 
24ce			;	; TODO do string type checks 
24ce			; 
24ce			;;v5	inc hl   ; skip type 
24ce			; 
24ce			;	push hl  ; source code  
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EX1" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			;	ld a, 0 
24ce			;	call strlent 
24ce			; 
24ce			;	inc hl 
24ce			;	inc hl 
24ce			;	inc hl 
24ce			;	inc hl 
24ce			; 
24ce			;	push hl    ; size 
24ce			; 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EX2" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			;	call malloc 
24ce			; 
24ce			;	ex de, hl    ; de now contains malloc area 
24ce			;	pop bc   	; get byte count 
24ce			;	pop hl      ; get string to copy 
24ce			; 
24ce			;	push de     ; save malloc for free later 
24ce			; 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EX3" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			;	ldir       ; duplicate string 
24ce			; 
24ce			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
24ce			;	 
24ce			;	; TODO fix the parse would be better than this...  
24ce			;	ex de, hl 
24ce			;	dec hl 
24ce			;	ld a, 0 
24ce			;	ld (hl), a 
24ce			;	dec hl 
24ce			;	ld a, ' ' 
24ce			;	ld (hl), a 
24ce			;	dec hl 
24ce			;	ld (hl), a 
24ce			; 
24ce			;	dec hl 
24ce			;	ld (hl), a 
24ce			; 
24ce			; 
24ce			;	FORTH_DSP_POP  
24ce			; 
24ce			;	pop hl     
24ce			;	push hl    ; save malloc area 
24ce			; 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EX4" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			; 
24ce			;	call forthparse 
24ce			;	call forthexec 
24ce			;	 
24ce			;	pop hl 
24ce			;	if DEBUG_FORTH_WORDS 
24ce			;		DMARK "EX5" 
24ce			;		CALLMONITOR 
24ce			;	endif 
24ce			; 
24ce			;	if FORTH_ENABLE_FREE 
24ce			;	call free 
24ce			;	endif 
24ce			; 
24ce			;	if DEBUG_FORTH_WORDS 
24ce			;		DMARK "EX6" 
24ce			;		CALLMONITOR 
24ce			;	endif 
24ce			; 
24ce			;	pop bc 
24ce			;	pop de 
24ce			;	pop hl 
24ce			;;	FORTH_RSP_POP	  
24ce			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
24ce			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
24ce			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
24ce			; 
24ce			;	if DEBUG_FORTH_WORDS 
24ce			;		DMARK "EX7" 
24ce			;		CALLMONITOR 
24ce			;	endif 
24ce			;	NEXTW 
24ce			 
24ce			;.STKEXEC: 
24ce			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
24ce			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
24ce			; 
24ce			; 
24ce			;		if DEBUG_FORTH_WORDS_KEY 
24ce			;			DMARK "STX" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			; 
24ce			;	FORTH_DSP_VALUEHL 
24ce			; 
24ce			;	ld (store_tmp1), hl    ; count 
24ce			; 
24ce			;	FORTH_DSP_POP 
24ce			;.stkexec1: 
24ce			;	ld hl, (store_tmp1)   ; count 
24ce			;	ld a, 0 
24ce			;	cp l 
24ce			;	ret z 
24ce			; 
24ce			;	dec hl 
24ce			;	ld (store_tmp1), hl    ; count 
24ce			;	 
24ce			;	FORTH_DSP_VALUEHL 
24ce			;	push hl 
24ce			;	 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EXp" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			;	FORTH_DSP_POP 
24ce			; 
24ce			;	call strlenz 
24ce			;	inc hl   ; include zero term to copy 
24ce			;	inc hl   ; include zero term to copy 
24ce			;	inc hl   ; include zero term to copy 
24ce			;	ld b,0 
24ce			;	ld c,l 
24ce			;	pop hl 
24ce			;	ld de, execscratch 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EX3" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			;	ldir 
24ce			; 
24ce			; 
24ce			;	ld hl, execscratch 
24ce			; 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EXP" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			; 
24ce			;	call forthparse 
24ce			;	ld hl, execscratch 
24ce			;		if DEBUG_FORTH_WORDS 
24ce			;			DMARK "EXx" 
24ce			;			CALLMONITOR 
24ce			;		endif 
24ce			;	call forthexec 
24ce			; 
24ce			;	jp .stkexec1 
24ce			; 
24ce			;	ret 
24ce			 
24ce			 
24ce			.DUP: 
24ce			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
24ce 17				db WORD_SYS_CORE+OPCODE_DUP             
24cf 4a 25			dw .ZDUP            
24d1 04				db 3 + 1 
24d2 .. 00			db "DUP",0              
24d6				endm 
# End of macro CWHEAD
24d6			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
24d6			; | | >[!NOTE] 
24d6			; | | > If the duplicated item is a string it is safely duplicated 
24d6			 
24d6				if DEBUG_FORTH_WORDS_KEY 
24d6					DMARK "DUP" 
24d6 f5				push af  
24d7 3a eb 24			ld a, (.dmark)  
24da 32 9d fd			ld (debug_mark),a  
24dd 3a ec 24			ld a, (.dmark+1)  
24e0 32 9e fd			ld (debug_mark+1),a  
24e3 3a ed 24			ld a, (.dmark+2)  
24e6 32 9f fd			ld (debug_mark+2),a  
24e9 18 03			jr .pastdmark  
24eb ..			.dmark: db "DUP"  
24ee f1			.pastdmark: pop af  
24ef			endm  
# End of macro DMARK
24ef					CALLMONITOR 
24ef cd aa fd			call debug_vector  
24f2				endm  
# End of macro CALLMONITOR
24f2				endif 
24f2			 
24f2				FORTH_DSP 
24f2 cd 32 21			call macro_forth_dsp 
24f5				endm 
# End of macro FORTH_DSP
24f5			 
24f5 7e				ld a, (HL) 
24f6 fe 01			cp DS_TYPE_STR 
24f8 20 28			jr nz, .dupinum 
24fa			 
24fa				; push another string 
24fa			 
24fa				FORTH_DSP_VALUEHL     		 
24fa cd 6c 21			call macro_dsp_valuehl 
24fd				endm 
# End of macro FORTH_DSP_VALUEHL
24fd			 
24fd			if DEBUG_FORTH_WORDS 
24fd				DMARK "DUs" 
24fd f5				push af  
24fe 3a 12 25			ld a, (.dmark)  
2501 32 9d fd			ld (debug_mark),a  
2504 3a 13 25			ld a, (.dmark+1)  
2507 32 9e fd			ld (debug_mark+1),a  
250a 3a 14 25			ld a, (.dmark+2)  
250d 32 9f fd			ld (debug_mark+2),a  
2510 18 03			jr .pastdmark  
2512 ..			.dmark: db "DUs"  
2515 f1			.pastdmark: pop af  
2516			endm  
# End of macro DMARK
2516				CALLMONITOR 
2516 cd aa fd			call debug_vector  
2519				endm  
# End of macro CALLMONITOR
2519			endif 
2519 cd da 1f			call forth_push_str 
251c			 
251c				NEXTW 
251c cd a7 fd			call parse_vector 
251f c3 53 23			jp macro_next 
2522				endm 
# End of macro NEXTW
2522			 
2522			 
2522			.dupinum: 
2522				 
2522			 
2522			 
2522				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2522 cd 6c 21			call macro_dsp_valuehl 
2525				endm 
# End of macro FORTH_DSP_VALUEHL
2525			 
2525			; TODO add floating point number detection 
2525			 
2525			if DEBUG_FORTH_WORDS 
2525				DMARK "DUi" 
2525 f5				push af  
2526 3a 3a 25			ld a, (.dmark)  
2529 32 9d fd			ld (debug_mark),a  
252c 3a 3b 25			ld a, (.dmark+1)  
252f 32 9e fd			ld (debug_mark+1),a  
2532 3a 3c 25			ld a, (.dmark+2)  
2535 32 9f fd			ld (debug_mark+2),a  
2538 18 03			jr .pastdmark  
253a ..			.dmark: db "DUi"  
253d f1			.pastdmark: pop af  
253e			endm  
# End of macro DMARK
253e				CALLMONITOR 
253e cd aa fd			call debug_vector  
2541				endm  
# End of macro CALLMONITOR
2541			endif 
2541			 
2541 cd 70 1f			call forth_push_numhl 
2544				NEXTW 
2544 cd a7 fd			call parse_vector 
2547 c3 53 23			jp macro_next 
254a				endm 
# End of macro NEXTW
254a			.ZDUP: 
254a			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
254a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
254b 84 25			dw .DMRK            
254d 05				db 4 + 1 
254e .. 00			db "?DUP",0              
2553				endm 
# End of macro CWHEAD
2553			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
2553			; | | >[!NOTE] 
2553			; | | > If the duplicated item is a string it is not safely duplicated and remain as pointer to the origin 
2553			 
2553				if DEBUG_FORTH_WORDS_KEY 
2553					DMARK "qDU" 
2553 f5				push af  
2554 3a 68 25			ld a, (.dmark)  
2557 32 9d fd			ld (debug_mark),a  
255a 3a 69 25			ld a, (.dmark+1)  
255d 32 9e fd			ld (debug_mark+1),a  
2560 3a 6a 25			ld a, (.dmark+2)  
2563 32 9f fd			ld (debug_mark+2),a  
2566 18 03			jr .pastdmark  
2568 ..			.dmark: db "qDU"  
256b f1			.pastdmark: pop af  
256c			endm  
# End of macro DMARK
256c					CALLMONITOR 
256c cd aa fd			call debug_vector  
256f				endm  
# End of macro CALLMONITOR
256f				endif 
256f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
256f cd 6c 21			call macro_dsp_valuehl 
2572				endm 
# End of macro FORTH_DSP_VALUEHL
2572			 
2572 e5				push hl 
2573			 
2573				; is it a zero? 
2573			 
2573 3e 00			ld a, 0 
2575 84				add h 
2576 85				add l 
2577			 
2577 e1				pop hl 
2578			 
2578			;	cp 0 
2578 b7				or a 
2579 28 03			jr z, .dup2orig 
257b			 
257b			 
257b cd 70 1f			call forth_push_numhl 
257e			 
257e			 
257e			; TODO add floating point number detection 
257e			 
257e			.dup2orig: 
257e			 
257e				NEXTW 
257e cd a7 fd			call parse_vector 
2581 c3 53 23			jp macro_next 
2584				endm 
# End of macro NEXTW
2584			.DMRK: 
2584			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
2584 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2585 c4 25			dw .LSHIFT            
2587 06				db 5 + 1 
2588 .. 00			db "DMARK",0              
258e				endm 
# End of macro CWHEAD
258e			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
258e			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
258e				if DEBUG_FORTH_WORDS_KEY 
258e					DMARK "DMK" 
258e f5				push af  
258f 3a a3 25			ld a, (.dmark)  
2592 32 9d fd			ld (debug_mark),a  
2595 3a a4 25			ld a, (.dmark+1)  
2598 32 9e fd			ld (debug_mark+1),a  
259b 3a a5 25			ld a, (.dmark+2)  
259e 32 9f fd			ld (debug_mark+2),a  
25a1 18 03			jr .pastdmark  
25a3 ..			.dmark: db "DMK"  
25a6 f1			.pastdmark: pop af  
25a7			endm  
# End of macro DMARK
25a7					CALLMONITOR 
25a7 cd aa fd			call debug_vector  
25aa				endm  
# End of macro CALLMONITOR
25aa				endif 
25aa				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25aa cd 6c 21			call macro_dsp_valuehl 
25ad				endm 
# End of macro FORTH_DSP_VALUEHL
25ad			 
25ad 7e				ld a, (hl) 
25ae 32 9d fd			ld (debug_mark),a 
25b1 23				inc hl 
25b2 7e				ld a, (hl) 
25b3 32 9e fd			ld (debug_mark+1),a 
25b6 23				inc hl 
25b7 7e				ld a, (hl) 
25b8 32 9f fd			ld (debug_mark+2),a 
25bb			 
25bb			 
25bb				FORTH_DSP_POP 
25bb cd 24 22			call macro_forth_dsp_pop 
25be				endm 
# End of macro FORTH_DSP_POP
25be				NEXTW 
25be cd a7 fd			call parse_vector 
25c1 c3 53 23			jp macro_next 
25c4				endm 
# End of macro NEXTW
25c4			.LSHIFT: 
25c4			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
25c4 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25c5 fb 25			dw .RSHIFT            
25c7 07				db 6 + 1 
25c8 .. 00			db "LSHIFT",0              
25cf				endm 
# End of macro CWHEAD
25cf			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
25cf				if DEBUG_FORTH_WORDS_KEY 
25cf					DMARK "LSH" 
25cf f5				push af  
25d0 3a e4 25			ld a, (.dmark)  
25d3 32 9d fd			ld (debug_mark),a  
25d6 3a e5 25			ld a, (.dmark+1)  
25d9 32 9e fd			ld (debug_mark+1),a  
25dc 3a e6 25			ld a, (.dmark+2)  
25df 32 9f fd			ld (debug_mark+2),a  
25e2 18 03			jr .pastdmark  
25e4 ..			.dmark: db "LSH"  
25e7 f1			.pastdmark: pop af  
25e8			endm  
# End of macro DMARK
25e8					CALLMONITOR 
25e8 cd aa fd			call debug_vector  
25eb				endm  
# End of macro CALLMONITOR
25eb				endif 
25eb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25eb cd 6c 21			call macro_dsp_valuehl 
25ee				endm 
# End of macro FORTH_DSP_VALUEHL
25ee				FORTH_DSP_POP 
25ee cd 24 22			call macro_forth_dsp_pop 
25f1				endm 
# End of macro FORTH_DSP_POP
25f1			 
25f1 29				add hl, hl 
25f2 cd 70 1f			call forth_push_numhl 
25f5				NEXTW 
25f5 cd a7 fd			call parse_vector 
25f8 c3 53 23			jp macro_next 
25fb				endm 
# End of macro NEXTW
25fb			.RSHIFT: 
25fb			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
25fb 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25fc 35 26			dw .SWAP            
25fe 07				db 6 + 1 
25ff .. 00			db "RSHIFT",0              
2606				endm 
# End of macro CWHEAD
2606			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
2606				if DEBUG_FORTH_WORDS_KEY 
2606					DMARK "RSH" 
2606 f5				push af  
2607 3a 1b 26			ld a, (.dmark)  
260a 32 9d fd			ld (debug_mark),a  
260d 3a 1c 26			ld a, (.dmark+1)  
2610 32 9e fd			ld (debug_mark+1),a  
2613 3a 1d 26			ld a, (.dmark+2)  
2616 32 9f fd			ld (debug_mark+2),a  
2619 18 03			jr .pastdmark  
261b ..			.dmark: db "RSH"  
261e f1			.pastdmark: pop af  
261f			endm  
# End of macro DMARK
261f					CALLMONITOR 
261f cd aa fd			call debug_vector  
2622				endm  
# End of macro CALLMONITOR
2622				endif 
2622				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2622 cd 6c 21			call macro_dsp_valuehl 
2625				endm 
# End of macro FORTH_DSP_VALUEHL
2625				FORTH_DSP_POP 
2625 cd 24 22			call macro_forth_dsp_pop 
2628				endm 
# End of macro FORTH_DSP_POP
2628 cb 3c			srl h 
262a cb 1d			rr l 
262c cd 70 1f			call forth_push_numhl 
262f				NEXTW 
262f cd a7 fd			call parse_vector 
2632 c3 53 23			jp macro_next 
2635				endm 
# End of macro NEXTW
2635			.SWAP: 
2635			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2635 18				db WORD_SYS_CORE+OPCODE_SWAP             
2636 8c 26			dw .COLN            
2638 05				db 4 + 1 
2639 .. 00			db "SWAP",0              
263e				endm 
# End of macro CWHEAD
263e			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
263e				if DEBUG_FORTH_WORDS_KEY 
263e					DMARK "SWP" 
263e f5				push af  
263f 3a 53 26			ld a, (.dmark)  
2642 32 9d fd			ld (debug_mark),a  
2645 3a 54 26			ld a, (.dmark+1)  
2648 32 9e fd			ld (debug_mark+1),a  
264b 3a 55 26			ld a, (.dmark+2)  
264e 32 9f fd			ld (debug_mark+2),a  
2651 18 03			jr .pastdmark  
2653 ..			.dmark: db "SWP"  
2656 f1			.pastdmark: pop af  
2657			endm  
# End of macro DMARK
2657					CALLMONITOR 
2657 cd aa fd			call debug_vector  
265a				endm  
# End of macro CALLMONITOR
265a				endif 
265a			 
265a			; DONE Use os stack swap memory 
265a			 
265a				FORTH_DSP_PTR 0     ; TOS 
265a 2a 20 f9			ld hl,(cli_data_sp) 
265d 11 00 00			ld de, 0 * 3 
2660 ed 52			sbc hl, de 
2662				endm 
# End of macro FORTH_DSP_PTR
2662 cd a3 22			call hltostack1 
2665			  
2665				FORTH_DSP_PTR 1     ; TOS 
2665 2a 20 f9			ld hl,(cli_data_sp) 
2668 11 03 00			ld de, 1 * 3 
266b ed 52			sbc hl, de 
266d				endm 
# End of macro FORTH_DSP_PTR
266d cd a9 22			call hltostack2 
2670			 
2670				FORTH_DSP_PTR 0     ; TOS 
2670 2a 20 f9			ld hl,(cli_data_sp) 
2673 11 00 00			ld de, 0 * 3 
2676 ed 52			sbc hl, de 
2678				endm 
# End of macro FORTH_DSP_PTR
2678 cd c1 22			call hlfromstack2 
267b			 
267b				FORTH_DSP_PTR 1     ; TOS 
267b 2a 20 f9			ld hl,(cli_data_sp) 
267e 11 03 00			ld de, 1 * 3 
2681 ed 52			sbc hl, de 
2683				endm 
# End of macro FORTH_DSP_PTR
2683 cd bb 22			call hlfromstack1 
2686			;	FORTH_DSP_VALUEHL 
2686			;	push hl     ; w2 
2686			; 
2686			;	FORTH_DSP_POP 
2686			; 
2686			;	FORTH_DSP_VALUEHL 
2686			; 
2686			;	FORTH_DSP_POP 
2686			; 
2686			;	pop de     ; w2	, hl = w1 
2686			; 
2686			;	ex de, hl 
2686			;	push de 
2686			; 
2686			;	call forth_push_numhl 
2686			; 
2686			;	pop hl 
2686			; 
2686			;	call forth_push_numhl 
2686				 
2686			 
2686				NEXTW 
2686 cd a7 fd			call parse_vector 
2689 c3 53 23			jp macro_next 
268c				endm 
# End of macro NEXTW
268c			.COLN: 
268c			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
268c 19				db WORD_SYS_CORE+OPCODE_COLN             
268d 17 28			dw .SCOLN            
268f 02				db 1 + 1 
2690 .. 00			db ":",0              
2692				endm 
# End of macro CWHEAD
2692			; | : ( -- )         Create new word | DONE 
2692			 
2692				if DEBUG_FORTH_WORDS_KEY 
2692					DMARK "CLN" 
2692 f5				push af  
2693 3a a7 26			ld a, (.dmark)  
2696 32 9d fd			ld (debug_mark),a  
2699 3a a8 26			ld a, (.dmark+1)  
269c 32 9e fd			ld (debug_mark+1),a  
269f 3a a9 26			ld a, (.dmark+2)  
26a2 32 9f fd			ld (debug_mark+2),a  
26a5 18 03			jr .pastdmark  
26a7 ..			.dmark: db "CLN"  
26aa f1			.pastdmark: pop af  
26ab			endm  
# End of macro DMARK
26ab					CALLMONITOR 
26ab cd aa fd			call debug_vector  
26ae				endm  
# End of macro CALLMONITOR
26ae				endif 
26ae			STACKFRAME OFF $8efe $989f 
26ae				if DEBUG_STACK_IMB 
26ae					if OFF 
26ae						exx 
26ae						ld de, $8efe 
26ae						ld a, d 
26ae						ld hl, curframe 
26ae						call hexout 
26ae						ld a, e 
26ae						ld hl, curframe+2 
26ae						call hexout 
26ae						ld hl, $8efe 
26ae						push hl 
26ae						ld hl, $989f 
26ae						push hl 
26ae						exx 
26ae					endif 
26ae				endif 
26ae			endm 
# End of macro STACKFRAME
26ae			; get parser buffer length  of new word 
26ae			 
26ae			 
26ae			 
26ae				; move tok past this to start of name defintition 
26ae				; TODO get word to define 
26ae				; TODO Move past word token 
26ae				; TODO get length of string up to the ';' 
26ae			 
26ae 2a f4 f3		ld hl, (os_tok_ptr) 
26b1 23			inc hl 
26b2 23			inc hl 
26b3			 
26b3 3e 3b		ld a, ';' 
26b5 cd 0f 13		call strlent 
26b8			 
26b8 7d			ld a,l 
26b9 32 e3 f0		ld (os_new_parse_len), a 
26bc			 
26bc			 
26bc			if DEBUG_FORTH_UWORD 
26bc ed 5b f4 f3	ld de, (os_tok_ptr) 
26c0					DMARK ":01" 
26c0 f5				push af  
26c1 3a d5 26			ld a, (.dmark)  
26c4 32 9d fd			ld (debug_mark),a  
26c7 3a d6 26			ld a, (.dmark+1)  
26ca 32 9e fd			ld (debug_mark+1),a  
26cd 3a d7 26			ld a, (.dmark+2)  
26d0 32 9f fd			ld (debug_mark+2),a  
26d3 18 03			jr .pastdmark  
26d5 ..			.dmark: db ":01"  
26d8 f1			.pastdmark: pop af  
26d9			endm  
# End of macro DMARK
26d9			CALLMONITOR 
26d9 cd aa fd			call debug_vector  
26dc				endm  
# End of macro CALLMONITOR
26dc			endif 
26dc			 
26dc			; 
26dc			;  new word memory layout: 
26dc			;  
26dc			;    : adg 6666 ;  
26dc			; 
26dc			;    db   1     ; user defined word  
26dc 23			inc hl    
26dd			;    dw   sysdict 
26dd 23			inc hl 
26de 23			inc hl 
26df			;    db <word len>+1 (for null) 
26df 23			inc hl 
26e0			;    db .... <word> 
26e0			; 
26e0			 
26e0 23			inc hl    ; some extras for the word preamble before the above 
26e1 23			inc hl 
26e2 23			inc hl 
26e3 23			inc hl 
26e4 23			inc hl 
26e5 23			inc hl 
26e6 23			inc hl  
26e7 23			inc hl 
26e8 23			inc hl 
26e9 23			inc hl 
26ea 23			inc hl 
26eb 23			inc hl 
26ec 23			inc hl 
26ed 23			inc hl     ; TODO how many do we really need?     maybe only 6 
26ee			;       exec word buffer 
26ee			;	<ptr word>   
26ee 23			inc hl 
26ef 23			inc hl 
26f0			;       <word list><null term> 7F final term 
26f0			 
26f0			 
26f0			if DEBUG_FORTH_UWORD 
26f0					DMARK ":02" 
26f0 f5				push af  
26f1 3a 05 27			ld a, (.dmark)  
26f4 32 9d fd			ld (debug_mark),a  
26f7 3a 06 27			ld a, (.dmark+1)  
26fa 32 9e fd			ld (debug_mark+1),a  
26fd 3a 07 27			ld a, (.dmark+2)  
2700 32 9f fd			ld (debug_mark+2),a  
2703 18 03			jr .pastdmark  
2705 ..			.dmark: db ":02"  
2708 f1			.pastdmark: pop af  
2709			endm  
# End of macro DMARK
2709			CALLMONITOR 
2709 cd aa fd			call debug_vector  
270c				endm  
# End of macro CALLMONITOR
270c			endif 
270c			 
270c			 
270c				; malloc the size 
270c			 
270c cd 78 13			call malloc 
270f 22 e5 f0			ld (os_new_malloc), hl     ; save malloc start 
2712			 
2712			;    db   1     ; user defined word  
2712			;	ld a, WORD_SYS_UWORD  
2712 36 01			ld (hl), WORD_SYS_UWORD 
2714			 
2714 23			inc hl    
2715			;    dw   sysdict 
2715 11 8c 24		ld de, sysdict       ; continue on with the scan to the system dict 
2718 73			ld (hl), e 
2719 23			inc hl 
271a 72			ld (hl), d 
271b 23			inc hl 
271c			 
271c			 
271c			;    Setup dict word 
271c			 
271c 23			inc hl 
271d 22 df f0		ld (os_new_work_ptr), hl     ; save start of dict word  
2720			 
2720			; 1. get length of dict word 
2720			 
2720			 
2720 2a f4 f3		ld hl, (os_tok_ptr) 
2723 23			inc hl 
2724 23			inc hl    ; position to start of dict word 
2725 3e 00		ld a, 0 
2727 cd 0f 13		call strlent 
272a			 
272a			 
272a 23			inc hl    ; to include null??? 
272b			 
272b			; write length of dict word 
272b			 
272b ed 5b df f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
272f 1b			dec de 
2730 eb			ex de, hl 
2731 73			ld (hl), e 
2732 eb			ex de, hl 
2733			 
2733			 
2733			 
2733			; copy  
2733 4d			ld c, l 
2734 06 00		ld b, 0 
2736 ed 5b df f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
273a 2a f4 f3		ld hl, (os_tok_ptr) 
273d 23			inc hl 
273e 23			inc hl    ; position to start of dict word 
273f			 
273f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
273f			 
273f			; TODO need to convert word to upper case 
273f			 
273f			ucasetok:	 
273f 7e			ld a,(hl) 
2740 cd fb 12		call toUpper 
2743 77			ld (hl),a 
2744 ed a0		ldi 
2746 f2 3f 27		jp p, ucasetok 
2749			 
2749			 
2749			 
2749			; de now points to start of where the word body code should be placed 
2749 ed 53 df f0	ld (os_new_work_ptr), de 
274d			; hl now points to the words to throw at forthexec which needs to be copied 
274d 22 dd f0		ld (os_new_src_ptr), hl 
2750			 
2750			; TODO add 'call to forthexec' 
2750			 
2750			if DEBUG_FORTH_UWORD 
2750 c5			push bc 
2751 ed 4b e5 f0	ld bc, (os_new_malloc) 
2755					DMARK ":0x" 
2755 f5				push af  
2756 3a 6a 27			ld a, (.dmark)  
2759 32 9d fd			ld (debug_mark),a  
275c 3a 6b 27			ld a, (.dmark+1)  
275f 32 9e fd			ld (debug_mark+1),a  
2762 3a 6c 27			ld a, (.dmark+2)  
2765 32 9f fd			ld (debug_mark+2),a  
2768 18 03			jr .pastdmark  
276a ..			.dmark: db ":0x"  
276d f1			.pastdmark: pop af  
276e			endm  
# End of macro DMARK
276e			CALLMONITOR 
276e cd aa fd			call debug_vector  
2771				endm  
# End of macro CALLMONITOR
2771 c1			pop bc 
2772			endif 
2772			 
2772			 
2772			; create word preamble which should be: 
2772			 
2772			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2772			 
2772			;    ld hl, <word code> 
2772			;    jp user_exec 
2772			;    <word code bytes> 
2772			 
2772			 
2772			;	inc de     ; TODO ??? or are we already past the word's null 
2772 eb			ex de, hl 
2773			 
2773 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2775			 
2775 23			inc hl 
2776 22 d9 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2779 23			inc hl 
277a			 
277a 23			inc hl 
277b 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
277d			 
277d 01 65 64		ld bc, user_exec 
2780 23			inc hl 
2781 71			ld (hl), c     ; poke address of user_exec 
2782 23			inc hl 
2783 70			ld (hl), b     
2784			; 
2784			;	inc hl 
2784			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2784			; 
2784			; 
2784			;	ld bc, macro_forth_rsp_next 
2784			;	inc hl 
2784			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2784			;	inc hl 
2784			;	ld (hl), b     
2784			; 
2784			;	inc hl 
2784			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2784			; 
2784			; 
2784			;	inc hl 
2784			;	ld bc, forthexec 
2784			;	ld (hl), c     ; poke address of forthexec 
2784			;	inc hl 
2784			;	ld (hl), b      
2784			; 
2784			;	inc hl 
2784			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2784			; 
2784			;	ld bc, user_dict_next 
2784			;	inc hl 
2784			;	ld (hl), c     ; poke address of forthexec 
2784			;	inc hl 
2784			;	ld (hl), b      
2784			 
2784			; hl is now where we need to copy the word byte data to save this 
2784			 
2784 23			inc hl 
2785 22 db f0		ld (os_new_exec), hl 
2788			 
2788			; copy definition 
2788			 
2788 eb			ex de, hl 
2789			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2789			;	inc de    ; skip the PC for this parse 
2789 3a e3 f0		ld a, (os_new_parse_len) 
278c 4f			ld c, a 
278d 06 00		ld b, 0 
278f ed b0		ldir		 ; copy defintion 
2791			 
2791			 
2791			; poke the address of where the new word bytes live for forthexec 
2791			 
2791 2a d9 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2794			 
2794 ed 5b db f0	ld de, (os_new_exec)      
2798			 
2798 73			ld (hl), e 
2799 23			inc hl 
279a 72			ld (hl), d 
279b			 
279b				; TODO copy last user dict word next link to this word 
279b				; TODO update last user dict word to point to this word 
279b			; 
279b			; hl f923 de 812a ; bc 811a 
279b			 
279b			if DEBUG_FORTH_UWORD 
279b c5			push bc 
279c ed 4b e5 f0	ld bc, (os_new_malloc) 
27a0					DMARK ":0A" 
27a0 f5				push af  
27a1 3a b5 27			ld a, (.dmark)  
27a4 32 9d fd			ld (debug_mark),a  
27a7 3a b6 27			ld a, (.dmark+1)  
27aa 32 9e fd			ld (debug_mark+1),a  
27ad 3a b7 27			ld a, (.dmark+2)  
27b0 32 9f fd			ld (debug_mark+2),a  
27b3 18 03			jr .pastdmark  
27b5 ..			.dmark: db ":0A"  
27b8 f1			.pastdmark: pop af  
27b9			endm  
# End of macro DMARK
27b9			CALLMONITOR 
27b9 cd aa fd			call debug_vector  
27bc				endm  
# End of macro CALLMONITOR
27bc c1			pop bc 
27bd			endif 
27bd			if DEBUG_FORTH_UWORD 
27bd c5			push bc 
27be ed 4b e5 f0	ld bc, (os_new_malloc) 
27c2 03			inc bc 
27c3 03			inc bc 
27c4 03			inc bc 
27c5 03			inc bc 
27c6 03			inc bc 
27c7 03			inc bc 
27c8 03			inc bc 
27c9 03			inc bc 
27ca			 
27ca					DMARK ":0B" 
27ca f5				push af  
27cb 3a df 27			ld a, (.dmark)  
27ce 32 9d fd			ld (debug_mark),a  
27d1 3a e0 27			ld a, (.dmark+1)  
27d4 32 9e fd			ld (debug_mark+1),a  
27d7 3a e1 27			ld a, (.dmark+2)  
27da 32 9f fd			ld (debug_mark+2),a  
27dd 18 03			jr .pastdmark  
27df ..			.dmark: db ":0B"  
27e2 f1			.pastdmark: pop af  
27e3			endm  
# End of macro DMARK
27e3			CALLMONITOR 
27e3 cd aa fd			call debug_vector  
27e6				endm  
# End of macro CALLMONITOR
27e6 c1			pop bc 
27e7			endif 
27e7			 
27e7			; update word dict linked list for new word 
27e7			 
27e7			 
27e7 2a f0 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
27ea 23			inc hl     ; move to next work linked list ptr 
27eb			 
27eb ed 5b e5 f0	ld de, (os_new_malloc)		 ; new next word 
27ef 73			ld (hl), e 
27f0 23			inc hl 
27f1 72			ld (hl), d 
27f2			 
27f2			if DEBUG_FORTH_UWORD 
27f2 ed 4b f0 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
27f6			endif 
27f6			 
27f6 ed 53 f0 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
27fa			 
27fa			 
27fa			if DEBUG_FORTH_UWORD 
27fa					DMARK ":0+" 
27fa f5				push af  
27fb 3a 0f 28			ld a, (.dmark)  
27fe 32 9d fd			ld (debug_mark),a  
2801 3a 10 28			ld a, (.dmark+1)  
2804 32 9e fd			ld (debug_mark+1),a  
2807 3a 11 28			ld a, (.dmark+2)  
280a 32 9f fd			ld (debug_mark+2),a  
280d 18 03			jr .pastdmark  
280f ..			.dmark: db ":0+"  
2812 f1			.pastdmark: pop af  
2813			endm  
# End of macro DMARK
2813			CALLMONITOR 
2813 cd aa fd			call debug_vector  
2816				endm  
# End of macro CALLMONITOR
2816			endif 
2816			 
2816			STACKFRAMECHK OFF $8efe $989f 
2816				if DEBUG_STACK_IMB 
2816					if OFF 
2816						exx 
2816						ld hl, $989f 
2816						pop de   ; $989f 
2816						call cmp16 
2816						jr nz, .spnosame 
2816						ld hl, $8efe 
2816						pop de   ; $8efe 
2816						call cmp16 
2816						jr z, .spfrsame 
2816						.spnosame: call showsperror 
2816						.spfrsame: nop 
2816						exx 
2816					endif 
2816				endif 
2816			endm 
# End of macro STACKFRAMECHK
2816			 
2816 c9			ret    ; dont process any remaining parser tokens as they form new word 
2817			 
2817			 
2817			 
2817			 
2817			;		NEXT 
2817			.SCOLN: 
2817			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2817 06			db OPCODE_SCOLN 
2818 66 28		dw .DROP 
281a 02			db 2 
281b .. 00		db ";",0           
281d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
281d				if DEBUG_FORTH_WORDS_KEY 
281d					DMARK "SCN" 
281d f5				push af  
281e 3a 32 28			ld a, (.dmark)  
2821 32 9d fd			ld (debug_mark),a  
2824 3a 33 28			ld a, (.dmark+1)  
2827 32 9e fd			ld (debug_mark+1),a  
282a 3a 34 28			ld a, (.dmark+2)  
282d 32 9f fd			ld (debug_mark+2),a  
2830 18 03			jr .pastdmark  
2832 ..			.dmark: db "SCN"  
2835 f1			.pastdmark: pop af  
2836			endm  
# End of macro DMARK
2836					CALLMONITOR 
2836 cd aa fd			call debug_vector  
2839				endm  
# End of macro CALLMONITOR
2839				endif 
2839				FORTH_RSP_TOS 
2839 cd 2e 1f			call macro_forth_rsp_tos 
283c				endm 
# End of macro FORTH_RSP_TOS
283c e5				push hl 
283d				FORTH_RSP_POP 
283d cd 38 1f			call macro_forth_rsp_pop 
2840				endm 
# End of macro FORTH_RSP_POP
2840 e1				pop hl 
2841			;		ex de,hl 
2841 22 f4 f3			ld (os_tok_ptr),hl 
2844			 
2844			if DEBUG_FORTH_UWORD 
2844					DMARK "SCL" 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 9d fd			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 9e fd			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 9f fd			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "SCL"  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d			CALLMONITOR 
285d cd aa fd			call debug_vector  
2860				endm  
# End of macro CALLMONITOR
2860			endif 
2860				NEXTW 
2860 cd a7 fd			call parse_vector 
2863 c3 53 23			jp macro_next 
2866				endm 
# End of macro NEXTW
2866			 
2866			.DROP: 
2866			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2866 1b				db WORD_SYS_CORE+OPCODE_DROP             
2867 94 28			dw .DUP2            
2869 05				db 4 + 1 
286a .. 00			db "DROP",0              
286f				endm 
# End of macro CWHEAD
286f			; | DROP ( w -- )   drop the TOS item   | DONE 
286f				if DEBUG_FORTH_WORDS_KEY 
286f					DMARK "DRP" 
286f f5				push af  
2870 3a 84 28			ld a, (.dmark)  
2873 32 9d fd			ld (debug_mark),a  
2876 3a 85 28			ld a, (.dmark+1)  
2879 32 9e fd			ld (debug_mark+1),a  
287c 3a 86 28			ld a, (.dmark+2)  
287f 32 9f fd			ld (debug_mark+2),a  
2882 18 03			jr .pastdmark  
2884 ..			.dmark: db "DRP"  
2887 f1			.pastdmark: pop af  
2888			endm  
# End of macro DMARK
2888					CALLMONITOR 
2888 cd aa fd			call debug_vector  
288b				endm  
# End of macro CALLMONITOR
288b				endif 
288b				FORTH_DSP_POP 
288b cd 24 22			call macro_forth_dsp_pop 
288e				endm 
# End of macro FORTH_DSP_POP
288e				NEXTW 
288e cd a7 fd			call parse_vector 
2891 c3 53 23			jp macro_next 
2894				endm 
# End of macro NEXTW
2894			.DUP2: 
2894			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2894 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2895 dc 28			dw .DROP2            
2897 05				db 4 + 1 
2898 .. 00			db "2DUP",0              
289d				endm 
# End of macro CWHEAD
289d			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
289d			; | | >[!NOTE] 
289d			; | | > If the duplicated items are string pointers, string are not safely duplicated and remain as pointers to the origin 
289d				if DEBUG_FORTH_WORDS_KEY 
289d					DMARK "2DU" 
289d f5				push af  
289e 3a b2 28			ld a, (.dmark)  
28a1 32 9d fd			ld (debug_mark),a  
28a4 3a b3 28			ld a, (.dmark+1)  
28a7 32 9e fd			ld (debug_mark+1),a  
28aa 3a b4 28			ld a, (.dmark+2)  
28ad 32 9f fd			ld (debug_mark+2),a  
28b0 18 03			jr .pastdmark  
28b2 ..			.dmark: db "2DU"  
28b5 f1			.pastdmark: pop af  
28b6			endm  
# End of macro DMARK
28b6					CALLMONITOR 
28b6 cd aa fd			call debug_vector  
28b9				endm  
# End of macro CALLMONITOR
28b9				endif 
28b9				FORTH_DSP_VALUEHL 
28b9 cd 6c 21			call macro_dsp_valuehl 
28bc				endm 
# End of macro FORTH_DSP_VALUEHL
28bc e5				push hl      ; 2 
28bd			 
28bd				FORTH_DSP_POP 
28bd cd 24 22			call macro_forth_dsp_pop 
28c0				endm 
# End of macro FORTH_DSP_POP
28c0				 
28c0				FORTH_DSP_VALUEHL 
28c0 cd 6c 21			call macro_dsp_valuehl 
28c3				endm 
# End of macro FORTH_DSP_VALUEHL
28c3			;		push hl      ; 1 
28c3			 
28c3				FORTH_DSP_POP 
28c3 cd 24 22			call macro_forth_dsp_pop 
28c6				endm 
# End of macro FORTH_DSP_POP
28c6			 
28c6			;		pop hl       ; 1 
28c6 d1				pop de       ; 2 
28c7			 
28c7 cd 70 1f			call forth_push_numhl 
28ca eb				ex de, hl 
28cb cd 70 1f			call forth_push_numhl 
28ce			 
28ce				 
28ce eb				ex de, hl 
28cf			 
28cf cd 70 1f			call forth_push_numhl 
28d2 eb				ex de, hl 
28d3 cd 70 1f			call forth_push_numhl 
28d6			 
28d6			 
28d6				NEXTW 
28d6 cd a7 fd			call parse_vector 
28d9 c3 53 23			jp macro_next 
28dc				endm 
# End of macro NEXTW
28dc			.DROP2: 
28dc			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
28dc 1d				db WORD_SYS_CORE+OPCODE_DROP2             
28dd 0e 29			dw .PICK            
28df 06				db 5 + 1 
28e0 .. 00			db "2DROP",0              
28e6				endm 
# End of macro CWHEAD
28e6			; | 2DROP ( w w -- )    Double drop | DONE 
28e6				if DEBUG_FORTH_WORDS_KEY 
28e6					DMARK "2DR" 
28e6 f5				push af  
28e7 3a fb 28			ld a, (.dmark)  
28ea 32 9d fd			ld (debug_mark),a  
28ed 3a fc 28			ld a, (.dmark+1)  
28f0 32 9e fd			ld (debug_mark+1),a  
28f3 3a fd 28			ld a, (.dmark+2)  
28f6 32 9f fd			ld (debug_mark+2),a  
28f9 18 03			jr .pastdmark  
28fb ..			.dmark: db "2DR"  
28fe f1			.pastdmark: pop af  
28ff			endm  
# End of macro DMARK
28ff					CALLMONITOR 
28ff cd aa fd			call debug_vector  
2902				endm  
# End of macro CALLMONITOR
2902				endif 
2902				FORTH_DSP_POP 
2902 cd 24 22			call macro_forth_dsp_pop 
2905				endm 
# End of macro FORTH_DSP_POP
2905				FORTH_DSP_POP 
2905 cd 24 22			call macro_forth_dsp_pop 
2908				endm 
# End of macro FORTH_DSP_POP
2908				NEXTW 
2908 cd a7 fd			call parse_vector 
290b c3 53 23			jp macro_next 
290e				endm 
# End of macro NEXTW
290e			.PICK: 
290e			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
290e 77				db WORD_SYS_CORE+99             
290f ab 29			dw .SWAP2            
2911 05				db 4 + 1 
2912 .. 00			db "PICK",0              
2917				endm 
# End of macro CWHEAD
2917			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
2917			; | | >[!NOTE] 
2917			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
2917				if DEBUG_FORTH_WORDS_KEY 
2917					DMARK "PIK" 
2917 f5				push af  
2918 3a 2c 29			ld a, (.dmark)  
291b 32 9d fd			ld (debug_mark),a  
291e 3a 2d 29			ld a, (.dmark+1)  
2921 32 9e fd			ld (debug_mark+1),a  
2924 3a 2e 29			ld a, (.dmark+2)  
2927 32 9f fd			ld (debug_mark+2),a  
292a 18 03			jr .pastdmark  
292c ..			.dmark: db "PIK"  
292f f1			.pastdmark: pop af  
2930			endm  
# End of macro DMARK
2930					CALLMONITOR 
2930 cd aa fd			call debug_vector  
2933				endm  
# End of macro CALLMONITOR
2933				endif 
2933			 
2933				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2933 cd 6c 21			call macro_dsp_valuehl 
2936				endm 
# End of macro FORTH_DSP_VALUEHL
2936				 
2936				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2936 cd 24 22			call macro_forth_dsp_pop 
2939				endm 
# End of macro FORTH_DSP_POP
2939			 
2939				; init from TOS 
2939 e5				push hl 
293a				FORTH_DSP 
293a cd 32 21			call macro_forth_dsp 
293d				endm 
# End of macro FORTH_DSP
293d			;	ld hl, cli_data_sp 
293d				if DEBUG_FORTH_WORDS 
293d					DMARK "PK1" 
293d f5				push af  
293e 3a 52 29			ld a, (.dmark)  
2941 32 9d fd			ld (debug_mark),a  
2944 3a 53 29			ld a, (.dmark+1)  
2947 32 9e fd			ld (debug_mark+1),a  
294a 3a 54 29			ld a, (.dmark+2)  
294d 32 9f fd			ld (debug_mark+2),a  
2950 18 03			jr .pastdmark  
2952 ..			.dmark: db "PK1"  
2955 f1			.pastdmark: pop af  
2956			endm  
# End of macro DMARK
2956					CALLMONITOR 
2956 cd aa fd			call debug_vector  
2959				endm  
# End of macro CALLMONITOR
2959				endif 
2959 c1				pop bc 
295a 41				ld b,c 
295b 3e 00			ld a, 0 
295d b8				cp b 
295e 28 21			jr z, .pdone	 
2960			.pkl: 
2960 2b				dec hl 
2961 2b				dec hl 
2962 2b				dec hl 
2963			 
2963				if DEBUG_FORTH_WORDS 
2963					DMARK "PKl" 
2963 f5				push af  
2964 3a 78 29			ld a, (.dmark)  
2967 32 9d fd			ld (debug_mark),a  
296a 3a 79 29			ld a, (.dmark+1)  
296d 32 9e fd			ld (debug_mark+1),a  
2970 3a 7a 29			ld a, (.dmark+2)  
2973 32 9f fd			ld (debug_mark+2),a  
2976 18 03			jr .pastdmark  
2978 ..			.dmark: db "PKl"  
297b f1			.pastdmark: pop af  
297c			endm  
# End of macro DMARK
297c					CALLMONITOR 
297c cd aa fd			call debug_vector  
297f				endm  
# End of macro CALLMONITOR
297f				endif 
297f 10 df			djnz .pkl 
2981			.pdone: 
2981				 
2981				; TODO do type check with correct push 
2981			 
2981 23				inc hl 
2982				;call loadwordinhl 
2982 5e				ld e, (hl) 
2983 23				inc hl 
2984 56				ld d, (hl) 
2985 eb				ex de,hl 
2986				if DEBUG_FORTH_WORDS 
2986					DMARK "PKp" 
2986 f5				push af  
2987 3a 9b 29			ld a, (.dmark)  
298a 32 9d fd			ld (debug_mark),a  
298d 3a 9c 29			ld a, (.dmark+1)  
2990 32 9e fd			ld (debug_mark+1),a  
2993 3a 9d 29			ld a, (.dmark+2)  
2996 32 9f fd			ld (debug_mark+2),a  
2999 18 03			jr .pastdmark  
299b ..			.dmark: db "PKp"  
299e f1			.pastdmark: pop af  
299f			endm  
# End of macro DMARK
299f					CALLMONITOR 
299f cd aa fd			call debug_vector  
29a2				endm  
# End of macro CALLMONITOR
29a2				endif 
29a2 cd 70 1f			call forth_push_numhl 
29a5			 
29a5				NEXTW 
29a5 cd a7 fd			call parse_vector 
29a8 c3 53 23			jp macro_next 
29ab				endm 
# End of macro NEXTW
29ab			.SWAP2: 
29ab			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
29ab 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
29ac 2f 2a			dw .AT            
29ae 06				db 5 + 1 
29af .. 00			db "2SWAP",0              
29b5				endm 
# End of macro CWHEAD
29b5			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | DONE 
29b5				if DEBUG_FORTH_WORDS_KEY 
29b5					DMARK "2SW" 
29b5 f5				push af  
29b6 3a ca 29			ld a, (.dmark)  
29b9 32 9d fd			ld (debug_mark),a  
29bc 3a cb 29			ld a, (.dmark+1)  
29bf 32 9e fd			ld (debug_mark+1),a  
29c2 3a cc 29			ld a, (.dmark+2)  
29c5 32 9f fd			ld (debug_mark+2),a  
29c8 18 03			jr .pastdmark  
29ca ..			.dmark: db "2SW"  
29cd f1			.pastdmark: pop af  
29ce			endm  
# End of macro DMARK
29ce					CALLMONITOR 
29ce cd aa fd			call debug_vector  
29d1				endm  
# End of macro CALLMONITOR
29d1				endif 
29d1			; TODO Use os stack swap memory 
29d1			 
29d1				FORTH_DSP_PTR 0     ; TOS    w4 
29d1 2a 20 f9			ld hl,(cli_data_sp) 
29d4 11 00 00			ld de, 0 * 3 
29d7 ed 52			sbc hl, de 
29d9				endm 
# End of macro FORTH_DSP_PTR
29d9 cd a3 22			call hltostack1 
29dc			  
29dc				FORTH_DSP_PTR 1     ; TOS    w3 
29dc 2a 20 f9			ld hl,(cli_data_sp) 
29df 11 03 00			ld de, 1 * 3 
29e2 ed 52			sbc hl, de 
29e4				endm 
# End of macro FORTH_DSP_PTR
29e4 cd a9 22			call hltostack2 
29e7			 
29e7			 
29e7			 
29e7				FORTH_DSP_PTR 2     ; TOS    w2 
29e7 2a 20 f9			ld hl,(cli_data_sp) 
29ea 11 06 00			ld de, 2 * 3 
29ed ed 52			sbc hl, de 
29ef				endm 
# End of macro FORTH_DSP_PTR
29ef cd af 22			call hltostack3 
29f2			 
29f2				FORTH_DSP_PTR 3     ; TOS   w1 
29f2 2a 20 f9			ld hl,(cli_data_sp) 
29f5 11 09 00			ld de, 3 * 3 
29f8 ed 52			sbc hl, de 
29fa				endm 
# End of macro FORTH_DSP_PTR
29fa cd b5 22			call hltostack4 
29fd			 
29fd			 
29fd			 
29fd			 
29fd				FORTH_DSP_PTR 0     ; TOS 
29fd 2a 20 f9			ld hl,(cli_data_sp) 
2a00 11 00 00			ld de, 0 * 3 
2a03 ed 52			sbc hl, de 
2a05				endm 
# End of macro FORTH_DSP_PTR
2a05 cd c7 22			call hlfromstack3 
2a08			 
2a08				FORTH_DSP_PTR 1     ; TOS 
2a08 2a 20 f9			ld hl,(cli_data_sp) 
2a0b 11 03 00			ld de, 1 * 3 
2a0e ed 52			sbc hl, de 
2a10				endm 
# End of macro FORTH_DSP_PTR
2a10 cd cd 22			call hlfromstack4 
2a13			 
2a13			 
2a13			 
2a13				FORTH_DSP_PTR 2     ; TOS 
2a13 2a 20 f9			ld hl,(cli_data_sp) 
2a16 11 06 00			ld de, 2 * 3 
2a19 ed 52			sbc hl, de 
2a1b				endm 
# End of macro FORTH_DSP_PTR
2a1b cd bb 22			call hlfromstack1 
2a1e			 
2a1e				FORTH_DSP_PTR 3     ; TOS 
2a1e 2a 20 f9			ld hl,(cli_data_sp) 
2a21 11 09 00			ld de, 3 * 3 
2a24 ed 52			sbc hl, de 
2a26				endm 
# End of macro FORTH_DSP_PTR
2a26 cd c1 22			call hlfromstack2 
2a29			 
2a29				NEXTW 
2a29 cd a7 fd			call parse_vector 
2a2c c3 53 23			jp macro_next 
2a2f				endm 
# End of macro NEXTW
2a2f			.AT: 
2a2f			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2a2f 1f				db WORD_SYS_CORE+OPCODE_AT             
2a30 64 2a			dw .CAT            
2a32 02				db 1 + 1 
2a33 .. 00			db "@",0              
2a35				endm 
# End of macro CWHEAD
2a35			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2a35			 
2a35				if DEBUG_FORTH_WORDS_KEY 
2a35					DMARK "AT." 
2a35 f5				push af  
2a36 3a 4a 2a			ld a, (.dmark)  
2a39 32 9d fd			ld (debug_mark),a  
2a3c 3a 4b 2a			ld a, (.dmark+1)  
2a3f 32 9e fd			ld (debug_mark+1),a  
2a42 3a 4c 2a			ld a, (.dmark+2)  
2a45 32 9f fd			ld (debug_mark+2),a  
2a48 18 03			jr .pastdmark  
2a4a ..			.dmark: db "AT."  
2a4d f1			.pastdmark: pop af  
2a4e			endm  
# End of macro DMARK
2a4e					CALLMONITOR 
2a4e cd aa fd			call debug_vector  
2a51				endm  
# End of macro CALLMONITOR
2a51				endif 
2a51			.getbyteat:	 
2a51				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a51 cd 6c 21			call macro_dsp_valuehl 
2a54				endm 
# End of macro FORTH_DSP_VALUEHL
2a54				 
2a54			;		push hl 
2a54			 
2a54				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a54 cd 24 22			call macro_forth_dsp_pop 
2a57				endm 
# End of macro FORTH_DSP_POP
2a57			 
2a57			;		pop hl 
2a57			 
2a57 7e				ld a, (hl) 
2a58			 
2a58 6f				ld l, a 
2a59 26 00			ld h, 0 
2a5b cd 70 1f			call forth_push_numhl 
2a5e			 
2a5e				NEXTW 
2a5e cd a7 fd			call parse_vector 
2a61 c3 53 23			jp macro_next 
2a64				endm 
# End of macro NEXTW
2a64			.CAT: 
2a64			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2a64 20				db WORD_SYS_CORE+OPCODE_CAT             
2a65 90 2a			dw .BANG            
2a67 03				db 2 + 1 
2a68 .. 00			db "C@",0              
2a6b				endm 
# End of macro CWHEAD
2a6b			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2a6b				if DEBUG_FORTH_WORDS_KEY 
2a6b					DMARK "CAA" 
2a6b f5				push af  
2a6c 3a 80 2a			ld a, (.dmark)  
2a6f 32 9d fd			ld (debug_mark),a  
2a72 3a 81 2a			ld a, (.dmark+1)  
2a75 32 9e fd			ld (debug_mark+1),a  
2a78 3a 82 2a			ld a, (.dmark+2)  
2a7b 32 9f fd			ld (debug_mark+2),a  
2a7e 18 03			jr .pastdmark  
2a80 ..			.dmark: db "CAA"  
2a83 f1			.pastdmark: pop af  
2a84			endm  
# End of macro DMARK
2a84					CALLMONITOR 
2a84 cd aa fd			call debug_vector  
2a87				endm  
# End of macro CALLMONITOR
2a87				endif 
2a87 c3 51 2a			jp .getbyteat 
2a8a				NEXTW 
2a8a cd a7 fd			call parse_vector 
2a8d c3 53 23			jp macro_next 
2a90				endm 
# End of macro NEXTW
2a90			.BANG: 
2a90			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a90 21				db WORD_SYS_CORE+OPCODE_BANG             
2a91 c9 2a			dw .CBANG            
2a93 02				db 1 + 1 
2a94 .. 00			db "!",0              
2a96				endm 
# End of macro CWHEAD
2a96			; | ! ( x w -- ) Store x at address w      | DONE 
2a96				if DEBUG_FORTH_WORDS_KEY 
2a96					DMARK "BNG" 
2a96 f5				push af  
2a97 3a ab 2a			ld a, (.dmark)  
2a9a 32 9d fd			ld (debug_mark),a  
2a9d 3a ac 2a			ld a, (.dmark+1)  
2aa0 32 9e fd			ld (debug_mark+1),a  
2aa3 3a ad 2a			ld a, (.dmark+2)  
2aa6 32 9f fd			ld (debug_mark+2),a  
2aa9 18 03			jr .pastdmark  
2aab ..			.dmark: db "BNG"  
2aae f1			.pastdmark: pop af  
2aaf			endm  
# End of macro DMARK
2aaf					CALLMONITOR 
2aaf cd aa fd			call debug_vector  
2ab2				endm  
# End of macro CALLMONITOR
2ab2				endif 
2ab2			 
2ab2			.storebyteat:		 
2ab2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab2 cd 6c 21			call macro_dsp_valuehl 
2ab5				endm 
# End of macro FORTH_DSP_VALUEHL
2ab5				 
2ab5 e5				push hl 
2ab6			 
2ab6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab6 cd 24 22			call macro_forth_dsp_pop 
2ab9				endm 
# End of macro FORTH_DSP_POP
2ab9			 
2ab9				; get byte to poke 
2ab9			 
2ab9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab9 cd 6c 21			call macro_dsp_valuehl 
2abc				endm 
# End of macro FORTH_DSP_VALUEHL
2abc e5				push hl 
2abd			 
2abd			 
2abd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2abd cd 24 22			call macro_forth_dsp_pop 
2ac0				endm 
# End of macro FORTH_DSP_POP
2ac0			 
2ac0			 
2ac0 d1				pop de 
2ac1 e1				pop hl 
2ac2			 
2ac2 73				ld (hl),e 
2ac3			 
2ac3			 
2ac3				NEXTW 
2ac3 cd a7 fd			call parse_vector 
2ac6 c3 53 23			jp macro_next 
2ac9				endm 
# End of macro NEXTW
2ac9			.CBANG: 
2ac9			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2ac9 22				db WORD_SYS_CORE+OPCODE_CBANG             
2aca f5 2a			dw .SCALL            
2acc 03				db 2 + 1 
2acd .. 00			db "C!",0              
2ad0				endm 
# End of macro CWHEAD
2ad0			; | C!  ( x w -- ) Store x at address w  | DONE 
2ad0				if DEBUG_FORTH_WORDS_KEY 
2ad0					DMARK "CBA" 
2ad0 f5				push af  
2ad1 3a e5 2a			ld a, (.dmark)  
2ad4 32 9d fd			ld (debug_mark),a  
2ad7 3a e6 2a			ld a, (.dmark+1)  
2ada 32 9e fd			ld (debug_mark+1),a  
2add 3a e7 2a			ld a, (.dmark+2)  
2ae0 32 9f fd			ld (debug_mark+2),a  
2ae3 18 03			jr .pastdmark  
2ae5 ..			.dmark: db "CBA"  
2ae8 f1			.pastdmark: pop af  
2ae9			endm  
# End of macro DMARK
2ae9					CALLMONITOR 
2ae9 cd aa fd			call debug_vector  
2aec				endm  
# End of macro CALLMONITOR
2aec				endif 
2aec c3 b2 2a			jp .storebyteat 
2aef				NEXTW 
2aef cd a7 fd			call parse_vector 
2af2 c3 53 23			jp macro_next 
2af5				endm 
# End of macro NEXTW
2af5			.SCALL: 
2af5			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2af5 23				db WORD_SYS_CORE+OPCODE_SCALL             
2af6 2c 2b			dw .DEPTH            
2af8 05				db 4 + 1 
2af9 .. 00			db "CALL",0              
2afe				endm 
# End of macro CWHEAD
2afe			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2afe				if DEBUG_FORTH_WORDS_KEY 
2afe					DMARK "CLL" 
2afe f5				push af  
2aff 3a 13 2b			ld a, (.dmark)  
2b02 32 9d fd			ld (debug_mark),a  
2b05 3a 14 2b			ld a, (.dmark+1)  
2b08 32 9e fd			ld (debug_mark+1),a  
2b0b 3a 15 2b			ld a, (.dmark+2)  
2b0e 32 9f fd			ld (debug_mark+2),a  
2b11 18 03			jr .pastdmark  
2b13 ..			.dmark: db "CLL"  
2b16 f1			.pastdmark: pop af  
2b17			endm  
# End of macro DMARK
2b17					CALLMONITOR 
2b17 cd aa fd			call debug_vector  
2b1a				endm  
# End of macro CALLMONITOR
2b1a				endif 
2b1a			 
2b1a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b1a cd 6c 21			call macro_dsp_valuehl 
2b1d				endm 
# End of macro FORTH_DSP_VALUEHL
2b1d			 
2b1d			;		push hl 
2b1d			 
2b1d				; destroy value TOS 
2b1d			 
2b1d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b1d cd 24 22			call macro_forth_dsp_pop 
2b20				endm 
# End of macro FORTH_DSP_POP
2b20			 
2b20					 
2b20			;		pop hl 
2b20			 
2b20				; how to do a call with hl???? save SP? 
2b20 cd f7 22			call forth_call_hl 
2b23			 
2b23			 
2b23				; TODO push value back onto stack for another op etc 
2b23			 
2b23 cd 70 1f			call forth_push_numhl 
2b26				NEXTW 
2b26 cd a7 fd			call parse_vector 
2b29 c3 53 23			jp macro_next 
2b2c				endm 
# End of macro NEXTW
2b2c			.DEPTH: 
2b2c			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2b2c 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2b2d 6c 2b			dw .OVER            
2b2f 06				db 5 + 1 
2b30 .. 00			db "DEPTH",0              
2b36				endm 
# End of macro CWHEAD
2b36			; | DEPTH ( -- u ) Push count of stack | DONE 
2b36				; take current TOS and remove from base value div by two to get count 
2b36				if DEBUG_FORTH_WORDS_KEY 
2b36					DMARK "DEP" 
2b36 f5				push af  
2b37 3a 4b 2b			ld a, (.dmark)  
2b3a 32 9d fd			ld (debug_mark),a  
2b3d 3a 4c 2b			ld a, (.dmark+1)  
2b40 32 9e fd			ld (debug_mark+1),a  
2b43 3a 4d 2b			ld a, (.dmark+2)  
2b46 32 9f fd			ld (debug_mark+2),a  
2b49 18 03			jr .pastdmark  
2b4b ..			.dmark: db "DEP"  
2b4e f1			.pastdmark: pop af  
2b4f			endm  
# End of macro DMARK
2b4f					CALLMONITOR 
2b4f cd aa fd			call debug_vector  
2b52				endm  
# End of macro CALLMONITOR
2b52				endif 
2b52			 
2b52			 
2b52 2a 20 f9		ld hl, (cli_data_sp) 
2b55 11 5a f6		ld de, cli_data_stack 
2b58 ed 52		sbc hl,de 
2b5a			 
2b5a			; div by size of stack item 
2b5a			 
2b5a 5d			ld e,l 
2b5b 0e 03		ld c, 3 
2b5d cd 3c 0f		call Div8 
2b60			 
2b60 6f			ld l,a 
2b61 26 00		ld h,0 
2b63			 
2b63			;srl h 
2b63			;rr l 
2b63			 
2b63 cd 70 1f			call forth_push_numhl 
2b66				NEXTW 
2b66 cd a7 fd			call parse_vector 
2b69 c3 53 23			jp macro_next 
2b6c				endm 
# End of macro NEXTW
2b6c			.OVER: 
2b6c			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2b6c 42				db WORD_SYS_CORE+46             
2b6d bc 2b			dw .PAUSE            
2b6f 05				db 4 + 1 
2b70 .. 00			db "OVER",0              
2b75				endm 
# End of macro CWHEAD
2b75			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2b75			; | | >[!NOTE] 
2b75			; | | > If the copied item is a string it is properly duplicated allowing for a safe release after use.  
2b75				if DEBUG_FORTH_WORDS_KEY 
2b75					DMARK "OVR" 
2b75 f5				push af  
2b76 3a 8a 2b			ld a, (.dmark)  
2b79 32 9d fd			ld (debug_mark),a  
2b7c 3a 8b 2b			ld a, (.dmark+1)  
2b7f 32 9e fd			ld (debug_mark+1),a  
2b82 3a 8c 2b			ld a, (.dmark+2)  
2b85 32 9f fd			ld (debug_mark+2),a  
2b88 18 03			jr .pastdmark  
2b8a ..			.dmark: db "OVR"  
2b8d f1			.pastdmark: pop af  
2b8e			endm  
# End of macro DMARK
2b8e					CALLMONITOR 
2b8e cd aa fd			call debug_vector  
2b91				endm  
# End of macro CALLMONITOR
2b91				endif 
2b91			 
2b91			; TODO Use os stack swap memory 
2b91			 
2b91				; work out what type we are looking at 
2b91			 
2b91				FORTH_DSP_PTR 1 
2b91 2a 20 f9			ld hl,(cli_data_sp) 
2b94 11 03 00			ld de, 1 * 3 
2b97 ed 52			sbc hl, de 
2b99				endm 
# End of macro FORTH_DSP_PTR
2b99			 
2b99 7e				ld a, (hl) 
2b9a				 
2b9a f5				push af 
2b9b				; whatever the type lets get the pointer or word 
2b9b 23				inc hl 
2b9c			;; 
2b9c			 
2b9c				; type check now to decide on how to push  
2b9c			 
2b9c cd d9 22			call loadwordinhl 
2b9f f1				pop af 
2ba0 fe 01			cp DS_TYPE_STR 
2ba2 28 09			jr z, .ovstr 
2ba4			 
2ba4				; we have a numeric so load the word and push 
2ba4			;	ld e, (hl) 
2ba4			;	inc hl 
2ba4			;	ld d, (hl) 
2ba4			;	ex de, hl 
2ba4 cd 70 1f			call forth_push_numhl 
2ba7				NEXTW 
2ba7 cd a7 fd			call parse_vector 
2baa c3 53 23			jp macro_next 
2bad				endm 
# End of macro NEXTW
2bad			 
2bad			.ovstr: 
2bad				; ok, a string so get the pointer and push as a string 
2bad			 
2bad			;	call loadwordinhl 
2bad cd da 1f			call forth_push_str 
2bb0				NEXTW 
2bb0 cd a7 fd			call parse_vector 
2bb3 c3 53 23			jp macro_next 
2bb6				endm 
# End of macro NEXTW
2bb6			 
2bb6			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bb6			;	push hl    ; n2 
2bb6			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bb6			; 
2bb6			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bb6			;	push hl    ; n1 
2bb6			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bb6			; 
2bb6			;	pop de     ; n1 
2bb6			;	pop hl     ; n2 
2bb6			; 
2bb6			;	push de 
2bb6			;	push hl 
2bb6			;	push de 
2bb6			 
2bb6				; push back  
2bb6			 
2bb6			;	pop hl 
2bb6			;	call forth_push_numhl 
2bb6			;	pop hl 
2bb6			;	call forth_push_numhl 
2bb6			;	pop hl 
2bb6			;	call forth_push_numhl 
2bb6				NEXTW 
2bb6 cd a7 fd			call parse_vector 
2bb9 c3 53 23			jp macro_next 
2bbc				endm 
# End of macro NEXTW
2bbc			 
2bbc			.PAUSE: 
2bbc			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2bbc 43				db WORD_SYS_CORE+47             
2bbd f4 2b			dw .PAUSES            
2bbf 08				db 7 + 1 
2bc0 .. 00			db "PAUSEMS",0              
2bc8				endm 
# End of macro CWHEAD
2bc8			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2bc8				if DEBUG_FORTH_WORDS_KEY 
2bc8					DMARK "PMS" 
2bc8 f5				push af  
2bc9 3a dd 2b			ld a, (.dmark)  
2bcc 32 9d fd			ld (debug_mark),a  
2bcf 3a de 2b			ld a, (.dmark+1)  
2bd2 32 9e fd			ld (debug_mark+1),a  
2bd5 3a df 2b			ld a, (.dmark+2)  
2bd8 32 9f fd			ld (debug_mark+2),a  
2bdb 18 03			jr .pastdmark  
2bdd ..			.dmark: db "PMS"  
2be0 f1			.pastdmark: pop af  
2be1			endm  
# End of macro DMARK
2be1					CALLMONITOR 
2be1 cd aa fd			call debug_vector  
2be4				endm  
# End of macro CALLMONITOR
2be4				endif 
2be4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2be4 cd 6c 21			call macro_dsp_valuehl 
2be7				endm 
# End of macro FORTH_DSP_VALUEHL
2be7			;		push hl    ; n2 
2be7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2be7 cd 24 22			call macro_forth_dsp_pop 
2bea				endm 
# End of macro FORTH_DSP_POP
2bea			;		pop hl 
2bea			 
2bea 7d				ld a, l 
2beb cd a5 0c			call aDelayInMS 
2bee			       NEXTW 
2bee cd a7 fd			call parse_vector 
2bf1 c3 53 23			jp macro_next 
2bf4				endm 
# End of macro NEXTW
2bf4			.PAUSES:  
2bf4			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2bf4 44				db WORD_SYS_CORE+48             
2bf5 66 2c			dw .ROT            
2bf7 06				db 5 + 1 
2bf8 .. 00			db "PAUSE",0              
2bfe				endm 
# End of macro CWHEAD
2bfe			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2bfe				if DEBUG_FORTH_WORDS_KEY 
2bfe					DMARK "PAU" 
2bfe f5				push af  
2bff 3a 13 2c			ld a, (.dmark)  
2c02 32 9d fd			ld (debug_mark),a  
2c05 3a 14 2c			ld a, (.dmark+1)  
2c08 32 9e fd			ld (debug_mark+1),a  
2c0b 3a 15 2c			ld a, (.dmark+2)  
2c0e 32 9f fd			ld (debug_mark+2),a  
2c11 18 03			jr .pastdmark  
2c13 ..			.dmark: db "PAU"  
2c16 f1			.pastdmark: pop af  
2c17			endm  
# End of macro DMARK
2c17					CALLMONITOR 
2c17 cd aa fd			call debug_vector  
2c1a				endm  
# End of macro CALLMONITOR
2c1a				endif 
2c1a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c1a cd 6c 21			call macro_dsp_valuehl 
2c1d				endm 
# End of macro FORTH_DSP_VALUEHL
2c1d			;		push hl    ; n2 
2c1d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c1d cd 24 22			call macro_forth_dsp_pop 
2c20				endm 
# End of macro FORTH_DSP_POP
2c20			;		pop hl 
2c20 45				ld b, l 
2c21				if DEBUG_FORTH_WORDS 
2c21					DMARK "PAU" 
2c21 f5				push af  
2c22 3a 36 2c			ld a, (.dmark)  
2c25 32 9d fd			ld (debug_mark),a  
2c28 3a 37 2c			ld a, (.dmark+1)  
2c2b 32 9e fd			ld (debug_mark+1),a  
2c2e 3a 38 2c			ld a, (.dmark+2)  
2c31 32 9f fd			ld (debug_mark+2),a  
2c34 18 03			jr .pastdmark  
2c36 ..			.dmark: db "PAU"  
2c39 f1			.pastdmark: pop af  
2c3a			endm  
# End of macro DMARK
2c3a					CALLMONITOR 
2c3a cd aa fd			call debug_vector  
2c3d				endm  
# End of macro CALLMONITOR
2c3d				endif 
2c3d c5			.pauses1:	push bc 
2c3e cd c0 0c			call delay1s 
2c41 c1				pop bc 
2c42				if DEBUG_FORTH_WORDS 
2c42					DMARK "PA1" 
2c42 f5				push af  
2c43 3a 57 2c			ld a, (.dmark)  
2c46 32 9d fd			ld (debug_mark),a  
2c49 3a 58 2c			ld a, (.dmark+1)  
2c4c 32 9e fd			ld (debug_mark+1),a  
2c4f 3a 59 2c			ld a, (.dmark+2)  
2c52 32 9f fd			ld (debug_mark+2),a  
2c55 18 03			jr .pastdmark  
2c57 ..			.dmark: db "PA1"  
2c5a f1			.pastdmark: pop af  
2c5b			endm  
# End of macro DMARK
2c5b					CALLMONITOR 
2c5b cd aa fd			call debug_vector  
2c5e				endm  
# End of macro CALLMONITOR
2c5e				endif 
2c5e 10 dd			djnz .pauses1 
2c60			 
2c60			       NEXTW 
2c60 cd a7 fd			call parse_vector 
2c63 c3 53 23			jp macro_next 
2c66				endm 
# End of macro NEXTW
2c66			.ROT: 
2c66			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2c66 45				db WORD_SYS_CORE+49             
2c67 d2 2c			dw .UWORDS            
2c69 04				db 3 + 1 
2c6a .. 00			db "ROT",0              
2c6e				endm 
# End of macro CWHEAD
2c6e			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2c6e				if DEBUG_FORTH_WORDS_KEY 
2c6e					DMARK "ROT" 
2c6e f5				push af  
2c6f 3a 83 2c			ld a, (.dmark)  
2c72 32 9d fd			ld (debug_mark),a  
2c75 3a 84 2c			ld a, (.dmark+1)  
2c78 32 9e fd			ld (debug_mark+1),a  
2c7b 3a 85 2c			ld a, (.dmark+2)  
2c7e 32 9f fd			ld (debug_mark+2),a  
2c81 18 03			jr .pastdmark  
2c83 ..			.dmark: db "ROT"  
2c86 f1			.pastdmark: pop af  
2c87			endm  
# End of macro DMARK
2c87					CALLMONITOR 
2c87 cd aa fd			call debug_vector  
2c8a				endm  
# End of macro CALLMONITOR
2c8a				endif 
2c8a			 
2c8a			; DONE Use os stack swap memory 
2c8a			 
2c8a				FORTH_DSP_PTR 0     ; u3 
2c8a 2a 20 f9			ld hl,(cli_data_sp) 
2c8d 11 00 00			ld de, 0 * 3 
2c90 ed 52			sbc hl, de 
2c92				endm 
# End of macro FORTH_DSP_PTR
2c92 cd a3 22			call hltostack1     
2c95			  
2c95				FORTH_DSP_PTR 1     ; u2 
2c95 2a 20 f9			ld hl,(cli_data_sp) 
2c98 11 03 00			ld de, 1 * 3 
2c9b ed 52			sbc hl, de 
2c9d				endm 
# End of macro FORTH_DSP_PTR
2c9d cd a9 22			call hltostack2      
2ca0			 
2ca0				FORTH_DSP_PTR 2     ; u1 
2ca0 2a 20 f9			ld hl,(cli_data_sp) 
2ca3 11 06 00			ld de, 2 * 3 
2ca6 ed 52			sbc hl, de 
2ca8				endm 
# End of macro FORTH_DSP_PTR
2ca8 cd af 22			call hltostack3 
2cab			 
2cab			 
2cab				FORTH_DSP_PTR 0     ;  
2cab 2a 20 f9			ld hl,(cli_data_sp) 
2cae 11 00 00			ld de, 0 * 3 
2cb1 ed 52			sbc hl, de 
2cb3				endm 
# End of macro FORTH_DSP_PTR
2cb3 cd c7 22			call hlfromstack3 
2cb6			 
2cb6				FORTH_DSP_PTR 1     ; TOS 
2cb6 2a 20 f9			ld hl,(cli_data_sp) 
2cb9 11 03 00			ld de, 1 * 3 
2cbc ed 52			sbc hl, de 
2cbe				endm 
# End of macro FORTH_DSP_PTR
2cbe cd bb 22			call hlfromstack1 
2cc1			 
2cc1				FORTH_DSP_PTR 2     ; TOS 
2cc1 2a 20 f9			ld hl,(cli_data_sp) 
2cc4 11 06 00			ld de, 2 * 3 
2cc7 ed 52			sbc hl, de 
2cc9				endm 
# End of macro FORTH_DSP_PTR
2cc9 cd c1 22			call hlfromstack2 
2ccc			 
2ccc			 
2ccc			;	FORTH_DSP_VALUEHL 
2ccc			;	push hl    ; u3  
2ccc			; 
2ccc			;	FORTH_DSP_POP 
2ccc			; 
2ccc			;	FORTH_DSP_VALUEHL 
2ccc			;	push hl     ; u2 
2ccc			; 
2ccc			;	FORTH_DSP_POP 
2ccc			; 
2ccc			;	FORTH_DSP_VALUEHL 
2ccc			;	push hl     ; u1 
2ccc			; 
2ccc			;	FORTH_DSP_POP 
2ccc			; 
2ccc			;	pop bc      ; u1 
2ccc			;	pop hl      ; u2 
2ccc			;	pop de      ; u3 
2ccc			; 
2ccc			; 
2ccc			;	push bc 
2ccc			;	push de 
2ccc			;	push hl 
2ccc			; 
2ccc			; 
2ccc			;	pop hl 
2ccc			;	call forth_push_numhl 
2ccc			; 
2ccc			;	pop hl 
2ccc			;	call forth_push_numhl 
2ccc			; 
2ccc			;	pop hl 
2ccc			;	call forth_push_numhl 
2ccc				 
2ccc			 
2ccc			 
2ccc			 
2ccc			 
2ccc			 
2ccc			       NEXTW 
2ccc cd a7 fd			call parse_vector 
2ccf c3 53 23			jp macro_next 
2cd2				endm 
# End of macro NEXTW
2cd2			 
2cd2			.UWORDS: 
2cd2			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2cd2 50				db WORD_SYS_CORE+60             
2cd3 97 2d			dw .BP            
2cd5 07				db 6 + 1 
2cd6 .. 00			db "UWORDS",0              
2cdd				endm 
# End of macro CWHEAD
2cdd			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2cdd			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2cdd			; | | Following the count are the individual words. 
2cdd			; | | 
2cdd			; | | e.g. UWORDS 
2cdd			; | | BOX DIRLIST 2 
2cdd			; | |  
2cdd			; | | Can be used to save the words to storage via: 
2cdd			; | | UWORDS $01 DO $01 APPEND LOOP 
2cdd			if DEBUG_FORTH_WORDS_KEY 
2cdd				DMARK "UWR" 
2cdd f5				push af  
2cde 3a f2 2c			ld a, (.dmark)  
2ce1 32 9d fd			ld (debug_mark),a  
2ce4 3a f3 2c			ld a, (.dmark+1)  
2ce7 32 9e fd			ld (debug_mark+1),a  
2cea 3a f4 2c			ld a, (.dmark+2)  
2ced 32 9f fd			ld (debug_mark+2),a  
2cf0 18 03			jr .pastdmark  
2cf2 ..			.dmark: db "UWR"  
2cf5 f1			.pastdmark: pop af  
2cf6			endm  
# End of macro DMARK
2cf6				CALLMONITOR 
2cf6 cd aa fd			call debug_vector  
2cf9				endm  
# End of macro CALLMONITOR
2cf9			endif 
2cf9 21 00 80			ld hl, baseram 
2cfc				;ld hl, baseusermem 
2cfc 01 00 00			ld bc, 0    ; start a counter 
2cff			 
2cff			; skip dict stub 
2cff			 
2cff cd 85 24			call forth_tok_next 
2d02			 
2d02			 
2d02			; while we have words to look for 
2d02			 
2d02 7e			.douscan:	ld a, (hl)      
2d03			if DEBUG_FORTH_WORDS 
2d03				DMARK "UWs" 
2d03 f5				push af  
2d04 3a 18 2d			ld a, (.dmark)  
2d07 32 9d fd			ld (debug_mark),a  
2d0a 3a 19 2d			ld a, (.dmark+1)  
2d0d 32 9e fd			ld (debug_mark+1),a  
2d10 3a 1a 2d			ld a, (.dmark+2)  
2d13 32 9f fd			ld (debug_mark+2),a  
2d16 18 03			jr .pastdmark  
2d18 ..			.dmark: db "UWs"  
2d1b f1			.pastdmark: pop af  
2d1c			endm  
# End of macro DMARK
2d1c				CALLMONITOR 
2d1c cd aa fd			call debug_vector  
2d1f				endm  
# End of macro CALLMONITOR
2d1f			endif 
2d1f fe 00			cp WORD_SYS_END 
2d21 28 4d			jr z, .udone 
2d23 fe 01			cp WORD_SYS_UWORD 
2d25 20 44			jr nz, .nuword 
2d27			 
2d27			if DEBUG_FORTH_WORDS 
2d27				DMARK "UWu" 
2d27 f5				push af  
2d28 3a 3c 2d			ld a, (.dmark)  
2d2b 32 9d fd			ld (debug_mark),a  
2d2e 3a 3d 2d			ld a, (.dmark+1)  
2d31 32 9e fd			ld (debug_mark+1),a  
2d34 3a 3e 2d			ld a, (.dmark+2)  
2d37 32 9f fd			ld (debug_mark+2),a  
2d3a 18 03			jr .pastdmark  
2d3c ..			.dmark: db "UWu"  
2d3f f1			.pastdmark: pop af  
2d40			endm  
# End of macro DMARK
2d40				CALLMONITOR 
2d40 cd aa fd			call debug_vector  
2d43				endm  
# End of macro CALLMONITOR
2d43			endif 
2d43				; we have a uword so push its name to the stack 
2d43			 
2d43 e5				push hl  ; save so we can move to next dict block 
2d44			 
2d44				; skip opcode 
2d44 23				inc hl  
2d45				; skip next ptr 
2d45 23				inc hl  
2d46 23				inc hl 
2d47				; skip len 
2d47 23				inc hl 
2d48			if DEBUG_FORTH_WORDS 
2d48				DMARK "UWt" 
2d48 f5				push af  
2d49 3a 5d 2d			ld a, (.dmark)  
2d4c 32 9d fd			ld (debug_mark),a  
2d4f 3a 5e 2d			ld a, (.dmark+1)  
2d52 32 9e fd			ld (debug_mark+1),a  
2d55 3a 5f 2d			ld a, (.dmark+2)  
2d58 32 9f fd			ld (debug_mark+2),a  
2d5b 18 03			jr .pastdmark  
2d5d ..			.dmark: db "UWt"  
2d60 f1			.pastdmark: pop af  
2d61			endm  
# End of macro DMARK
2d61				CALLMONITOR 
2d61 cd aa fd			call debug_vector  
2d64				endm  
# End of macro CALLMONITOR
2d64			endif 
2d64 03				inc bc 
2d65			 
2d65 c5				push bc 
2d66 cd da 1f			call forth_push_str 
2d69 c1				pop bc 
2d6a			 
2d6a e1				pop hl 	 
2d6b			 
2d6b cd 85 24		.nuword:	call forth_tok_next 
2d6e 18 92			jr .douscan  
2d70			 
2d70			.udone:		 ; push count of uwords found 
2d70 c5				push bc 
2d71 e1				pop hl 
2d72			 
2d72			if DEBUG_FORTH_WORDS 
2d72				DMARK "UWc" 
2d72 f5				push af  
2d73 3a 87 2d			ld a, (.dmark)  
2d76 32 9d fd			ld (debug_mark),a  
2d79 3a 88 2d			ld a, (.dmark+1)  
2d7c 32 9e fd			ld (debug_mark+1),a  
2d7f 3a 89 2d			ld a, (.dmark+2)  
2d82 32 9f fd			ld (debug_mark+2),a  
2d85 18 03			jr .pastdmark  
2d87 ..			.dmark: db "UWc"  
2d8a f1			.pastdmark: pop af  
2d8b			endm  
# End of macro DMARK
2d8b				CALLMONITOR 
2d8b cd aa fd			call debug_vector  
2d8e				endm  
# End of macro CALLMONITOR
2d8e			endif 
2d8e cd 70 1f			call forth_push_numhl 
2d91			 
2d91			 
2d91			       NEXTW 
2d91 cd a7 fd			call parse_vector 
2d94 c3 53 23			jp macro_next 
2d97				endm 
# End of macro NEXTW
2d97			 
2d97			.BP: 
2d97			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2d97 54				db WORD_SYS_CORE+64             
2d98 d7 2d			dw .MONITOR            
2d9a 03				db 2 + 1 
2d9b .. 00			db "BP",0              
2d9e				endm 
# End of macro CWHEAD
2d9e			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2d9e			; | | $00 Will enable the break points within specific code paths 
2d9e			; | | $01 Will disable break points 
2d9e			; | |  
2d9e			; | | By default break points are off. Either the above can be used to enable them 
2d9e			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2d9e			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2d9e			; | | can disable break points. Exiting will then continue boot process. 
2d9e				; get byte count 
2d9e				if DEBUG_FORTH_WORDS_KEY 
2d9e					DMARK "BP." 
2d9e f5				push af  
2d9f 3a b3 2d			ld a, (.dmark)  
2da2 32 9d fd			ld (debug_mark),a  
2da5 3a b4 2d			ld a, (.dmark+1)  
2da8 32 9e fd			ld (debug_mark+1),a  
2dab 3a b5 2d			ld a, (.dmark+2)  
2dae 32 9f fd			ld (debug_mark+2),a  
2db1 18 03			jr .pastdmark  
2db3 ..			.dmark: db "BP."  
2db6 f1			.pastdmark: pop af  
2db7			endm  
# End of macro DMARK
2db7					CALLMONITOR 
2db7 cd aa fd			call debug_vector  
2dba				endm  
# End of macro CALLMONITOR
2dba				endif 
2dba			 
2dba				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dba cd 6c 21			call macro_dsp_valuehl 
2dbd				endm 
# End of macro FORTH_DSP_VALUEHL
2dbd			 
2dbd			;		push hl 
2dbd			 
2dbd				; destroy value TOS 
2dbd			 
2dbd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dbd cd 24 22			call macro_forth_dsp_pop 
2dc0				endm 
# End of macro FORTH_DSP_POP
2dc0			 
2dc0			;		pop hl 
2dc0			 
2dc0 3e 00			ld a,0 
2dc2 bd				cp l 
2dc3 28 09			jr z, .bpset 
2dc5			;		ld a, '*' 
2dc5 cd 8d 18			call bp_off 
2dc8				NEXTW 
2dc8 cd a7 fd			call parse_vector 
2dcb c3 53 23			jp macro_next 
2dce				endm 
# End of macro NEXTW
2dce			 
2dce			.bpset:	 
2dce				;	ld (os_view_disable), a 
2dce cd 81 18			call bp_on 
2dd1			 
2dd1			 
2dd1				NEXTW 
2dd1 cd a7 fd			call parse_vector 
2dd4 c3 53 23			jp macro_next 
2dd7				endm 
# End of macro NEXTW
2dd7			 
2dd7			 
2dd7			.MONITOR: 
2dd7			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2dd7 55				db WORD_SYS_CORE+65             
2dd8 0b 2e			dw .MALLOC            
2dda 08				db 7 + 1 
2ddb .. 00			db "MONITOR",0              
2de3				endm 
# End of macro CWHEAD
2de3			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2de3			; | | At start the current various registers will be displayed with contents. 
2de3			; | | Top right corner will show the most recent debug marker seen. 
2de3			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2de3			; | | and the return stack pointer (RSP). 
2de3			; | | Pressing: 
2de3			; | |  
2de3			; | |    1 - Initial screen 
2de3			; | |  
2de3			; | |    2 - Display a data dump of HL 
2de3			; | |  
2de3			; | |    3 - Display a data dump of DE 
2de3			; | |  
2de3			; | |    4 - Display a data dump of BC 
2de3			; | |  
2de3			; | |    5 - Display a data dump of HL 
2de3			; | |  
2de3			; | |    6 - Display a data dump of DSP 
2de3			; | |  
2de3			; | |    7 - Display a data dump of RSP 
2de3			; | |  
2de3			; | |    8 - Display a data dump of what is at DSP 
2de3			; | |  
2de3			; | |    9 - Display a data dump of what is at RSP 
2de3			; | |  
2de3			; | |    0 - Exit monitor and continue running. This will also enable break points 
2de3			; | |  
2de3			; | |    * - Disable break points 
2de3			; | |  
2de3			; | |    # - Enter traditional monitor mode 
2de3			; | |  
2de3			; | | 
2de3			; | | Monitor Mode 
2de3			; | | ------------ 
2de3			; | | A prompt of '>' will be shown for various commands: 
2de3			; | |  
2de3			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2de3			; | |  
2de3			; | |    C - Continue display a data dump from the last set address 
2de3			; | |  
2de3			; | |    M xxxx - Set start of memory edit at address xx 
2de3			; | |  
2de3			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2de3			; | |  
2de3			; | |    G xxxx - Exec code at specific address 
2de3			; | |  
2de3			; | |    Q - Return to previous 
2de3				if DEBUG_FORTH_WORDS_KEY 
2de3					DMARK "MON" 
2de3 f5				push af  
2de4 3a f8 2d			ld a, (.dmark)  
2de7 32 9d fd			ld (debug_mark),a  
2dea 3a f9 2d			ld a, (.dmark+1)  
2ded 32 9e fd			ld (debug_mark+1),a  
2df0 3a fa 2d			ld a, (.dmark+2)  
2df3 32 9f fd			ld (debug_mark+2),a  
2df6 18 03			jr .pastdmark  
2df8 ..			.dmark: db "MON"  
2dfb f1			.pastdmark: pop af  
2dfc			endm  
# End of macro DMARK
2dfc					CALLMONITOR 
2dfc cd aa fd			call debug_vector  
2dff				endm  
# End of macro CALLMONITOR
2dff				endif 
2dff			;		ld a, 0 
2dff			;		ld (os_view_disable), a 
2dff cd 81 18			call bp_on 
2e02			 
2e02				CALLMONITOR 
2e02 cd aa fd			call debug_vector  
2e05				endm  
# End of macro CALLMONITOR
2e05			 
2e05			;	call monitor 
2e05			 
2e05				NEXTW 
2e05 cd a7 fd			call parse_vector 
2e08 c3 53 23			jp macro_next 
2e0b				endm 
# End of macro NEXTW
2e0b			 
2e0b			 
2e0b			.MALLOC: 
2e0b			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2e0b 56				db WORD_SYS_CORE+66             
2e0c 34 2e			dw .MALLOC2            
2e0e 06				db 5 + 1 
2e0f .. 00			db "ALLOT",0              
2e15				endm 
# End of macro CWHEAD
2e15			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2e15				if DEBUG_FORTH_WORDS_KEY 
2e15					DMARK "ALL" 
2e15 f5				push af  
2e16 3a 2a 2e			ld a, (.dmark)  
2e19 32 9d fd			ld (debug_mark),a  
2e1c 3a 2b 2e			ld a, (.dmark+1)  
2e1f 32 9e fd			ld (debug_mark+1),a  
2e22 3a 2c 2e			ld a, (.dmark+2)  
2e25 32 9f fd			ld (debug_mark+2),a  
2e28 18 03			jr .pastdmark  
2e2a ..			.dmark: db "ALL"  
2e2d f1			.pastdmark: pop af  
2e2e			endm  
# End of macro DMARK
2e2e					CALLMONITOR 
2e2e cd aa fd			call debug_vector  
2e31				endm  
# End of macro CALLMONITOR
2e31				endif 
2e31 c3 5b 2e			jp .mallocc 
2e34			.MALLOC2: 
2e34			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2e34 56				db WORD_SYS_CORE+66             
2e35 75 2e			dw .FREE            
2e37 07				db 6 + 1 
2e38 .. 00			db "MALLOC",0              
2e3f				endm 
# End of macro CWHEAD
2e3f			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2e3f				; get byte count 
2e3f				if DEBUG_FORTH_WORDS_KEY 
2e3f					DMARK "MAL" 
2e3f f5				push af  
2e40 3a 54 2e			ld a, (.dmark)  
2e43 32 9d fd			ld (debug_mark),a  
2e46 3a 55 2e			ld a, (.dmark+1)  
2e49 32 9e fd			ld (debug_mark+1),a  
2e4c 3a 56 2e			ld a, (.dmark+2)  
2e4f 32 9f fd			ld (debug_mark+2),a  
2e52 18 03			jr .pastdmark  
2e54 ..			.dmark: db "MAL"  
2e57 f1			.pastdmark: pop af  
2e58			endm  
# End of macro DMARK
2e58					CALLMONITOR 
2e58 cd aa fd			call debug_vector  
2e5b				endm  
# End of macro CALLMONITOR
2e5b				endif 
2e5b			.mallocc: 
2e5b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e5b cd 6c 21			call macro_dsp_valuehl 
2e5e				endm 
# End of macro FORTH_DSP_VALUEHL
2e5e			 
2e5e			;		push hl 
2e5e			 
2e5e				; destroy value TOS 
2e5e			 
2e5e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e5e cd 24 22			call macro_forth_dsp_pop 
2e61				endm 
# End of macro FORTH_DSP_POP
2e61			 
2e61			;		pop hl 
2e61 cd 78 13			call malloc 
2e64			if DEBUG_FORTH_MALLOC_GUARD 
2e64 f5				push af 
2e65 cd d5 0f			call ishlzero 
2e68			;		ld a, l 
2e68			;		add h 
2e68			;		cp 0 
2e68 f1				pop af 
2e69				 
2e69 cc 37 65			call z,malloc_error 
2e6c			endif 
2e6c			 
2e6c cd 70 1f			call forth_push_numhl 
2e6f				NEXTW 
2e6f cd a7 fd			call parse_vector 
2e72 c3 53 23			jp macro_next 
2e75				endm 
# End of macro NEXTW
2e75			 
2e75			.FREE: 
2e75			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
2e75 57				db WORD_SYS_CORE+67             
2e76 a9 2e			dw .UPTR            
2e78 05				db 4 + 1 
2e79 .. 00			db "FREE",0              
2e7e				endm 
# End of macro CWHEAD
2e7e			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2e7e				if DEBUG_FORTH_WORDS_KEY 
2e7e					DMARK "FRE" 
2e7e f5				push af  
2e7f 3a 93 2e			ld a, (.dmark)  
2e82 32 9d fd			ld (debug_mark),a  
2e85 3a 94 2e			ld a, (.dmark+1)  
2e88 32 9e fd			ld (debug_mark+1),a  
2e8b 3a 95 2e			ld a, (.dmark+2)  
2e8e 32 9f fd			ld (debug_mark+2),a  
2e91 18 03			jr .pastdmark  
2e93 ..			.dmark: db "FRE"  
2e96 f1			.pastdmark: pop af  
2e97			endm  
# End of macro DMARK
2e97					CALLMONITOR 
2e97 cd aa fd			call debug_vector  
2e9a				endm  
# End of macro CALLMONITOR
2e9a				endif 
2e9a				; get address 
2e9a			 
2e9a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e9a cd 6c 21			call macro_dsp_valuehl 
2e9d				endm 
# End of macro FORTH_DSP_VALUEHL
2e9d			 
2e9d			;		push hl 
2e9d			 
2e9d				; destroy value TOS 
2e9d			 
2e9d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e9d cd 24 22			call macro_forth_dsp_pop 
2ea0				endm 
# End of macro FORTH_DSP_POP
2ea0			 
2ea0			;		pop hl 
2ea0			if FORTH_ENABLE_MALLOCFREE 
2ea0 cd 42 14			call free 
2ea3			endif 
2ea3				NEXTW 
2ea3 cd a7 fd			call parse_vector 
2ea6 c3 53 23			jp macro_next 
2ea9				endm 
# End of macro NEXTW
2ea9			.UPTR: 
2ea9			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2ea9 57				db WORD_SYS_CORE+67             
2eaa af 2f			dw .LIST            
2eac 05				db 4 + 1 
2ead .. 00			db "UPTR",0              
2eb2				endm 
# End of macro CWHEAD
2eb2			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2eb2				if DEBUG_FORTH_WORDS_KEY 
2eb2					DMARK "UPT" 
2eb2 f5				push af  
2eb3 3a c7 2e			ld a, (.dmark)  
2eb6 32 9d fd			ld (debug_mark),a  
2eb9 3a c8 2e			ld a, (.dmark+1)  
2ebc 32 9e fd			ld (debug_mark+1),a  
2ebf 3a c9 2e			ld a, (.dmark+2)  
2ec2 32 9f fd			ld (debug_mark+2),a  
2ec5 18 03			jr .pastdmark  
2ec7 ..			.dmark: db "UPT"  
2eca f1			.pastdmark: pop af  
2ecb			endm  
# End of macro DMARK
2ecb					CALLMONITOR 
2ecb cd aa fd			call debug_vector  
2ece				endm  
# End of macro CALLMONITOR
2ece				endif 
2ece				FORTH_DSP_VALUEHL 
2ece cd 6c 21			call macro_dsp_valuehl 
2ed1				endm 
# End of macro FORTH_DSP_VALUEHL
2ed1			 
2ed1 e5				push hl 
2ed2				FORTH_DSP_POP 
2ed2 cd 24 22			call macro_forth_dsp_pop 
2ed5				endm 
# End of macro FORTH_DSP_POP
2ed5 c1				pop bc 
2ed6			 
2ed6			 
2ed6				; Get ptr to the word we need to look up 
2ed6			 
2ed6			;		FORTH_DSP_VALUEHL 
2ed6				;v5 FORTH_DSP_VALUE 
2ed6			; TODO type check 
2ed6			;		inc hl    ; Skip type check  
2ed6			;		push hl 
2ed6			;		ex de, hl    ; put into DE 
2ed6			 
2ed6			 
2ed6 21 00 80			ld hl, baseram 
2ed9				;ld hl, baseusermem 
2ed9			 
2ed9 e5			push hl   ; sacreifical push 
2eda			 
2eda			.uldouscanm: 
2eda e1			pop hl 
2edb			.uldouscan: 
2edb			if DEBUG_FORTH_WORDS 
2edb				DMARK "LSs" 
2edb f5				push af  
2edc 3a f0 2e			ld a, (.dmark)  
2edf 32 9d fd			ld (debug_mark),a  
2ee2 3a f1 2e			ld a, (.dmark+1)  
2ee5 32 9e fd			ld (debug_mark+1),a  
2ee8 3a f2 2e			ld a, (.dmark+2)  
2eeb 32 9f fd			ld (debug_mark+2),a  
2eee 18 03			jr .pastdmark  
2ef0 ..			.dmark: db "LSs"  
2ef3 f1			.pastdmark: pop af  
2ef4			endm  
# End of macro DMARK
2ef4				CALLMONITOR 
2ef4 cd aa fd			call debug_vector  
2ef7				endm  
# End of macro CALLMONITOR
2ef7			endif 
2ef7			; skip dict stub 
2ef7 cd 85 24			call forth_tok_next 
2efa			 
2efa			 
2efa			; while we have words to look for 
2efa			 
2efa 7e			ld a, (hl)      
2efb			if DEBUG_FORTH_WORDS 
2efb				DMARK "LSk" 
2efb f5				push af  
2efc 3a 10 2f			ld a, (.dmark)  
2eff 32 9d fd			ld (debug_mark),a  
2f02 3a 11 2f			ld a, (.dmark+1)  
2f05 32 9e fd			ld (debug_mark+1),a  
2f08 3a 12 2f			ld a, (.dmark+2)  
2f0b 32 9f fd			ld (debug_mark+2),a  
2f0e 18 03			jr .pastdmark  
2f10 ..			.dmark: db "LSk"  
2f13 f1			.pastdmark: pop af  
2f14			endm  
# End of macro DMARK
2f14				CALLMONITOR 
2f14 cd aa fd			call debug_vector  
2f17				endm  
# End of macro CALLMONITOR
2f17			endif 
2f17				;cp WORD_SYS_END 
2f17				;jp z, .lunotfound 
2f17			 
2f17					; if we hit non uwords then gone too far 
2f17 fe 01				cp WORD_SYS_UWORD 
2f19 c2 a6 2f				jp nz, .ulunotfound 
2f1c			 
2f1c				if DEBUG_FORTH_WORDS 
2f1c					DMARK "LSu" 
2f1c f5				push af  
2f1d 3a 31 2f			ld a, (.dmark)  
2f20 32 9d fd			ld (debug_mark),a  
2f23 3a 32 2f			ld a, (.dmark+1)  
2f26 32 9e fd			ld (debug_mark+1),a  
2f29 3a 33 2f			ld a, (.dmark+2)  
2f2c 32 9f fd			ld (debug_mark+2),a  
2f2f 18 03			jr .pastdmark  
2f31 ..			.dmark: db "LSu"  
2f34 f1			.pastdmark: pop af  
2f35			endm  
# End of macro DMARK
2f35					CALLMONITOR 
2f35 cd aa fd			call debug_vector  
2f38				endm  
# End of macro CALLMONITOR
2f38				endif 
2f38			 
2f38					; found a uword but is it the one we want... 
2f38			 
2f38 c5					push bc     ; uword to find is on bc 
2f39 d1					pop de 
2f3a			 
2f3a e5					push hl  ; to save the ptr 
2f3b			 
2f3b					; skip opcode 
2f3b 23					inc hl  
2f3c					; skip next ptr 
2f3c 23					inc hl  
2f3d 23					inc hl 
2f3e					; skip len 
2f3e 23					inc hl 
2f3f			 
2f3f				if DEBUG_FORTH_WORDS 
2f3f					DMARK "LSc" 
2f3f f5				push af  
2f40 3a 54 2f			ld a, (.dmark)  
2f43 32 9d fd			ld (debug_mark),a  
2f46 3a 55 2f			ld a, (.dmark+1)  
2f49 32 9e fd			ld (debug_mark+1),a  
2f4c 3a 56 2f			ld a, (.dmark+2)  
2f4f 32 9f fd			ld (debug_mark+2),a  
2f52 18 03			jr .pastdmark  
2f54 ..			.dmark: db "LSc"  
2f57 f1			.pastdmark: pop af  
2f58			endm  
# End of macro DMARK
2f58					CALLMONITOR 
2f58 cd aa fd			call debug_vector  
2f5b				endm  
# End of macro CALLMONITOR
2f5b				endif 
2f5b			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2f5b			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2f5b			; Nope that has gone the other way. It needs to be exact not on first zero 
2f5b			;		call strcmp 
2f5b c5					push bc 
2f5c cd 48 13				call StrictStrCmp 
2f5f c1					pop bc 
2f60 c2 da 2e				jp nz, .uldouscanm 
2f63				 
2f63			 
2f63			 
2f63					; we have a uword so push its name to the stack 
2f63			 
2f63			;	   	push hl  ; save so we can move to next dict block 
2f63 e1			pop hl 
2f64			 
2f64				if DEBUG_FORTH_WORDS 
2f64					DMARK "LSm" 
2f64 f5				push af  
2f65 3a 79 2f			ld a, (.dmark)  
2f68 32 9d fd			ld (debug_mark),a  
2f6b 3a 7a 2f			ld a, (.dmark+1)  
2f6e 32 9e fd			ld (debug_mark+1),a  
2f71 3a 7b 2f			ld a, (.dmark+2)  
2f74 32 9f fd			ld (debug_mark+2),a  
2f77 18 03			jr .pastdmark  
2f79 ..			.dmark: db "LSm"  
2f7c f1			.pastdmark: pop af  
2f7d			endm  
# End of macro DMARK
2f7d					CALLMONITOR 
2f7d cd aa fd			call debug_vector  
2f80				endm  
# End of macro CALLMONITOR
2f80				endif 
2f80			 
2f80					; skip opcode 
2f80 23					inc hl  
2f81					; skip next ptr 
2f81 23					inc hl  
2f82 23					inc hl 
2f83					; skip len 
2f83 7e					ld a, (hl)   ; save length to add 
2f84				if DEBUG_FORTH_WORDS 
2f84					DMARK "LS2" 
2f84 f5				push af  
2f85 3a 99 2f			ld a, (.dmark)  
2f88 32 9d fd			ld (debug_mark),a  
2f8b 3a 9a 2f			ld a, (.dmark+1)  
2f8e 32 9e fd			ld (debug_mark+1),a  
2f91 3a 9b 2f			ld a, (.dmark+2)  
2f94 32 9f fd			ld (debug_mark+2),a  
2f97 18 03			jr .pastdmark  
2f99 ..			.dmark: db "LS2"  
2f9c f1			.pastdmark: pop af  
2f9d			endm  
# End of macro DMARK
2f9d					CALLMONITOR 
2f9d cd aa fd			call debug_vector  
2fa0				endm  
# End of macro CALLMONITOR
2fa0				endif 
2fa0			 
2fa0				; skip zero term and other uword defs to position right at the exec code 
2fa0 06 04			ld b, 4 
2fa2 80				add a,b 
2fa3			 
2fa3 cd ac 0f			call addatohl 
2fa6					; save this location 
2fa6				 
2fa6			.ulunotfound: 
2fa6 cd 70 1f			call forth_push_numhl 
2fa9						 
2fa9				NEXTW 
2fa9 cd a7 fd			call parse_vector 
2fac c3 53 23			jp macro_next 
2faf				endm 
# End of macro NEXTW
2faf			.LIST: 
2faf			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2faf 5c				db WORD_SYS_CORE+72             
2fb0 b1 31			dw .FORGET            
2fb2 05				db 4 + 1 
2fb3 .. 00			db "LIST",0              
2fb8				endm 
# End of macro CWHEAD
2fb8			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2fb8			; | | The quoted word must be in upper case. 
2fb8			if DEBUG_FORTH_WORDS_KEY 
2fb8				DMARK "LST" 
2fb8 f5				push af  
2fb9 3a cd 2f			ld a, (.dmark)  
2fbc 32 9d fd			ld (debug_mark),a  
2fbf 3a ce 2f			ld a, (.dmark+1)  
2fc2 32 9e fd			ld (debug_mark+1),a  
2fc5 3a cf 2f			ld a, (.dmark+2)  
2fc8 32 9f fd			ld (debug_mark+2),a  
2fcb 18 03			jr .pastdmark  
2fcd ..			.dmark: db "LST"  
2fd0 f1			.pastdmark: pop af  
2fd1			endm  
# End of macro DMARK
2fd1				CALLMONITOR 
2fd1 cd aa fd			call debug_vector  
2fd4				endm  
# End of macro CALLMONITOR
2fd4			endif 
2fd4			 
2fd4				FORTH_DSP_VALUEHL 
2fd4 cd 6c 21			call macro_dsp_valuehl 
2fd7				endm 
# End of macro FORTH_DSP_VALUEHL
2fd7			 
2fd7 e5				push hl 
2fd8				FORTH_DSP_POP 
2fd8 cd 24 22			call macro_forth_dsp_pop 
2fdb				endm 
# End of macro FORTH_DSP_POP
2fdb c1				pop bc 
2fdc			 
2fdc			; Start format of scratch string 
2fdc			 
2fdc 21 f3 f0			ld hl, scratch 
2fdf			 
2fdf			;	ld a, ':' 
2fdf 36 3a			ld (hl),':' 
2fe1 23				inc hl 
2fe2			;	ld a, ' ' 
2fe2 36 20			ld (hl), ' ' 
2fe4			 
2fe4				; Get ptr to the word we need to look up 
2fe4			 
2fe4			;		FORTH_DSP_VALUEHL 
2fe4				;v5 FORTH_DSP_VALUE 
2fe4			; TODO type check 
2fe4			;		inc hl    ; Skip type check  
2fe4			;		push hl 
2fe4			;		ex de, hl    ; put into DE 
2fe4			 
2fe4			 
2fe4 21 00 80			ld hl, baseram 
2fe7				;ld hl, baseusermem 
2fe7			 
2fe7 e5			push hl   ; sacreifical push 
2fe8			 
2fe8			.ldouscanm: 
2fe8 e1			pop hl 
2fe9			.ldouscan: 
2fe9			if DEBUG_FORTH_WORDS 
2fe9				DMARK "LSs" 
2fe9 f5				push af  
2fea 3a fe 2f			ld a, (.dmark)  
2fed 32 9d fd			ld (debug_mark),a  
2ff0 3a ff 2f			ld a, (.dmark+1)  
2ff3 32 9e fd			ld (debug_mark+1),a  
2ff6 3a 00 30			ld a, (.dmark+2)  
2ff9 32 9f fd			ld (debug_mark+2),a  
2ffc 18 03			jr .pastdmark  
2ffe ..			.dmark: db "LSs"  
3001 f1			.pastdmark: pop af  
3002			endm  
# End of macro DMARK
3002				CALLMONITOR 
3002 cd aa fd			call debug_vector  
3005				endm  
# End of macro CALLMONITOR
3005			endif 
3005			; skip dict stub 
3005 cd 85 24			call forth_tok_next 
3008			 
3008			 
3008			; while we have words to look for 
3008			 
3008 7e			ld a, (hl)      
3009			if DEBUG_FORTH_WORDS 
3009				DMARK "LSk" 
3009 f5				push af  
300a 3a 1e 30			ld a, (.dmark)  
300d 32 9d fd			ld (debug_mark),a  
3010 3a 1f 30			ld a, (.dmark+1)  
3013 32 9e fd			ld (debug_mark+1),a  
3016 3a 20 30			ld a, (.dmark+2)  
3019 32 9f fd			ld (debug_mark+2),a  
301c 18 03			jr .pastdmark  
301e ..			.dmark: db "LSk"  
3021 f1			.pastdmark: pop af  
3022			endm  
# End of macro DMARK
3022				CALLMONITOR 
3022 cd aa fd			call debug_vector  
3025				endm  
# End of macro CALLMONITOR
3025			endif 
3025				;cp WORD_SYS_END 
3025				;jp z, .lunotfound 
3025			 
3025					; if we hit non uwords then gone too far 
3025 fe 01				cp WORD_SYS_UWORD 
3027 c2 64 31				jp nz, .lunotfound 
302a			 
302a				if DEBUG_FORTH_WORDS 
302a					DMARK "LSu" 
302a f5				push af  
302b 3a 3f 30			ld a, (.dmark)  
302e 32 9d fd			ld (debug_mark),a  
3031 3a 40 30			ld a, (.dmark+1)  
3034 32 9e fd			ld (debug_mark+1),a  
3037 3a 41 30			ld a, (.dmark+2)  
303a 32 9f fd			ld (debug_mark+2),a  
303d 18 03			jr .pastdmark  
303f ..			.dmark: db "LSu"  
3042 f1			.pastdmark: pop af  
3043			endm  
# End of macro DMARK
3043					CALLMONITOR 
3043 cd aa fd			call debug_vector  
3046				endm  
# End of macro CALLMONITOR
3046				endif 
3046			 
3046					; found a uword but is it the one we want... 
3046			 
3046 c5					push bc     ; uword to find is on bc 
3047 d1					pop de 
3048			 
3048 e5					push hl  ; to save the ptr 
3049			 
3049					; skip opcode 
3049 23					inc hl  
304a					; skip next ptr 
304a 23					inc hl  
304b 23					inc hl 
304c					; skip len 
304c 23					inc hl 
304d			 
304d				if DEBUG_FORTH_WORDS 
304d					DMARK "LSc" 
304d f5				push af  
304e 3a 62 30			ld a, (.dmark)  
3051 32 9d fd			ld (debug_mark),a  
3054 3a 63 30			ld a, (.dmark+1)  
3057 32 9e fd			ld (debug_mark+1),a  
305a 3a 64 30			ld a, (.dmark+2)  
305d 32 9f fd			ld (debug_mark+2),a  
3060 18 03			jr .pastdmark  
3062 ..			.dmark: db "LSc"  
3065 f1			.pastdmark: pop af  
3066			endm  
# End of macro DMARK
3066					CALLMONITOR 
3066 cd aa fd			call debug_vector  
3069				endm  
# End of macro CALLMONITOR
3069				endif 
3069			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
3069			; ie. If WOO is defined first and then WO. Couldnt list WO. 
3069			; Nope that has gone the other way. It needs to be exact not on first zero 
3069			;		call strcmp 
3069 c5					push bc 
306a cd 48 13				call StrictStrCmp 
306d c1					pop bc 
306e c2 e8 2f				jp nz, .ldouscanm 
3071				 
3071			 
3071			 
3071					; we have a uword so push its name to the stack 
3071			 
3071			;	   	push hl  ; save so we can move to next dict block 
3071 e1			pop hl 
3072			 
3072				if DEBUG_FORTH_WORDS 
3072					DMARK "LSm" 
3072 f5				push af  
3073 3a 87 30			ld a, (.dmark)  
3076 32 9d fd			ld (debug_mark),a  
3079 3a 88 30			ld a, (.dmark+1)  
307c 32 9e fd			ld (debug_mark+1),a  
307f 3a 89 30			ld a, (.dmark+2)  
3082 32 9f fd			ld (debug_mark+2),a  
3085 18 03			jr .pastdmark  
3087 ..			.dmark: db "LSm"  
308a f1			.pastdmark: pop af  
308b			endm  
# End of macro DMARK
308b					CALLMONITOR 
308b cd aa fd			call debug_vector  
308e				endm  
# End of macro CALLMONITOR
308e				endif 
308e			 
308e					; skip opcode 
308e 23					inc hl  
308f					; skip next ptr 
308f 23					inc hl  
3090 23					inc hl 
3091					; skip len 
3091 7e					ld a, (hl)   ; save length to add 
3092				if DEBUG_FORTH_WORDS 
3092					DMARK "LS2" 
3092 f5				push af  
3093 3a a7 30			ld a, (.dmark)  
3096 32 9d fd			ld (debug_mark),a  
3099 3a a8 30			ld a, (.dmark+1)  
309c 32 9e fd			ld (debug_mark+1),a  
309f 3a a9 30			ld a, (.dmark+2)  
30a2 32 9f fd			ld (debug_mark+2),a  
30a5 18 03			jr .pastdmark  
30a7 ..			.dmark: db "LS2"  
30aa f1			.pastdmark: pop af  
30ab			endm  
# End of macro DMARK
30ab					CALLMONITOR 
30ab cd aa fd			call debug_vector  
30ae				endm  
# End of macro CALLMONITOR
30ae				endif 
30ae			 
30ae					; save this location 
30ae				 
30ae e5					push hl 
30af			 
30af 23					inc hl 
30b0 11 f5 f0				ld de, scratch+2 
30b3 4f					ld c, a 
30b4 06 00				ld b, 0 
30b6			 
30b6				if DEBUG_FORTH_WORDS 
30b6					DMARK "LSn" 
30b6 f5				push af  
30b7 3a cb 30			ld a, (.dmark)  
30ba 32 9d fd			ld (debug_mark),a  
30bd 3a cc 30			ld a, (.dmark+1)  
30c0 32 9e fd			ld (debug_mark+1),a  
30c3 3a cd 30			ld a, (.dmark+2)  
30c6 32 9f fd			ld (debug_mark+2),a  
30c9 18 03			jr .pastdmark  
30cb ..			.dmark: db "LSn"  
30ce f1			.pastdmark: pop af  
30cf			endm  
# End of macro DMARK
30cf					CALLMONITOR 
30cf cd aa fd			call debug_vector  
30d2				endm  
# End of macro CALLMONITOR
30d2				endif 
30d2			 
30d2					; copy uword name to scratch 
30d2			 
30d2			;		ldir 
30d2			.licplw:	; copy uword name to scratch converting to lower case as we go 
30d2 ed a0				ldi 
30d4 1b					dec de 
30d5 1a					ld a, (de) 
30d6 cd 1d 12				call to_lower 
30d9 12					ld (de),a 
30da 13					inc de 
30db 3e 00				ld a, 0 
30dd b9					cp c 
30de 20 f2				jr nz, .licplw 
30e0			 
30e0			 
30e0			 
30e0 1b					dec de 
30e1 3e 20				ld a, ' '    ; change null to space 
30e3 12					ld (de), a 
30e4			 
30e4 13					inc de 
30e5			 
30e5 d5					push de 
30e6 c1					pop bc     ; move scratch pointer to end of word name and save it 
30e7			 
30e7 e1					pop hl 
30e8 7e					ld a, (hl) 
30e9					;inc hl 
30e9					; skip word string 
30e9 cd ac 0f				call addatohl 
30ec			 
30ec 23					inc hl 
30ed			 
30ed				if DEBUG_FORTH_WORDS 
30ed					DMARK "LS3" 
30ed f5				push af  
30ee 3a 02 31			ld a, (.dmark)  
30f1 32 9d fd			ld (debug_mark),a  
30f4 3a 03 31			ld a, (.dmark+1)  
30f7 32 9e fd			ld (debug_mark+1),a  
30fa 3a 04 31			ld a, (.dmark+2)  
30fd 32 9f fd			ld (debug_mark+2),a  
3100 18 03			jr .pastdmark  
3102 ..			.dmark: db "LS3"  
3105 f1			.pastdmark: pop af  
3106			endm  
# End of macro DMARK
3106					CALLMONITOR 
3106 cd aa fd			call debug_vector  
3109				endm  
# End of macro CALLMONITOR
3109				endif 
3109					; should now be at the start of the machine code to setup the eval of the uword 
3109					; now locate the ptr to the string defintion 
3109			 
3109					; skip ld hl, 
3109					; then load the ptr 
3109			; TODO use get from hl ptr 
3109 23					inc hl 
310a 5e					ld e, (hl) 
310b 23					inc hl 
310c 56					ld d, (hl) 
310d eb					ex de, hl 
310e			 
310e			 
310e				if DEBUG_FORTH_WORDS 
310e					DMARK "LSt" 
310e f5				push af  
310f 3a 23 31			ld a, (.dmark)  
3112 32 9d fd			ld (debug_mark),a  
3115 3a 24 31			ld a, (.dmark+1)  
3118 32 9e fd			ld (debug_mark+1),a  
311b 3a 25 31			ld a, (.dmark+2)  
311e 32 9f fd			ld (debug_mark+2),a  
3121 18 03			jr .pastdmark  
3123 ..			.dmark: db "LSt"  
3126 f1			.pastdmark: pop af  
3127			endm  
# End of macro DMARK
3127					CALLMONITOR 
3127 cd aa fd			call debug_vector  
312a				endm  
# End of macro CALLMONITOR
312a				endif 
312a			 
312a			; cant push right now due to tokenised strings  
312a			 
312a			; get the destination of where to copy this definition to. 
312a			 
312a c5					push bc 
312b d1					pop de 
312c			 
312c 7e			.listl:         ld a,(hl) 
312d			;		cp 0 
312d b7					or a 
312e 28 09				jr z, .lreplsp     ; replace zero with space 
3130					;cp FORTH_END_BUFFER 
3130 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
3132 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
3134				 
3134					; just copy this char as is then 
3134			 
3134 12					ld (de), a 
3135			 
3135 23			.listnxt:	inc hl 
3136 13					inc de 
3137 18 f3				jr .listl 
3139			 
3139 3e 20		.lreplsp:	ld a,' ' 
313b 12					ld (de), a 
313c 18 f7				jr .listnxt 
313e			 
313e			; close up uword def 
313e			 
313e			.listdone: 
313e 12					ld (de), a 
313f 13					inc de 
3140 3e 00				ld a, 0 
3142 12					ld (de), a 
3143			 
3143			; now have def so clean up and push to stack 
3143			 
3143 21 f3 f0				ld hl, scratch 
3146				if DEBUG_FORTH_WORDS 
3146					DMARK "Ltp" 
3146 f5				push af  
3147 3a 5b 31			ld a, (.dmark)  
314a 32 9d fd			ld (debug_mark),a  
314d 3a 5c 31			ld a, (.dmark+1)  
3150 32 9e fd			ld (debug_mark+1),a  
3153 3a 5d 31			ld a, (.dmark+2)  
3156 32 9f fd			ld (debug_mark+2),a  
3159 18 03			jr .pastdmark  
315b ..			.dmark: db "Ltp"  
315e f1			.pastdmark: pop af  
315f			endm  
# End of macro DMARK
315f					CALLMONITOR 
315f cd aa fd			call debug_vector  
3162				endm  
# End of macro CALLMONITOR
3162				endif 
3162			 
3162 18 22			jr .listpush 
3164			 
3164			;.lnuword:	pop hl 
3164			;		call forth_tok_next 
3164			;		jp .ldouscan  
3164			 
3164			.lunotfound:		  
3164			 
3164				if DEBUG_FORTH_WORDS 
3164					DMARK "LSn" 
3164 f5				push af  
3165 3a 79 31			ld a, (.dmark)  
3168 32 9d fd			ld (debug_mark),a  
316b 3a 7a 31			ld a, (.dmark+1)  
316e 32 9e fd			ld (debug_mark+1),a  
3171 3a 7b 31			ld a, (.dmark+2)  
3174 32 9f fd			ld (debug_mark+2),a  
3177 18 03			jr .pastdmark  
3179 ..			.dmark: db "LSn"  
317c f1			.pastdmark: pop af  
317d			endm  
# End of macro DMARK
317d					CALLMONITOR 
317d cd aa fd			call debug_vector  
3180				endm  
# End of macro CALLMONITOR
3180				endif 
3180			 
3180					 
3180			;		FORTH_DSP_POP 
3180			;		ld hl, .luno 
3180			 
3180					NEXTW			 
3180 cd a7 fd			call parse_vector 
3183 c3 53 23			jp macro_next 
3186				endm 
# End of macro NEXTW
3186			 
3186			.listpush: 
3186				if DEBUG_FORTH_WORDS 
3186					DMARK "LS>" 
3186 f5				push af  
3187 3a 9b 31			ld a, (.dmark)  
318a 32 9d fd			ld (debug_mark),a  
318d 3a 9c 31			ld a, (.dmark+1)  
3190 32 9e fd			ld (debug_mark+1),a  
3193 3a 9d 31			ld a, (.dmark+2)  
3196 32 9f fd			ld (debug_mark+2),a  
3199 18 03			jr .pastdmark  
319b ..			.dmark: db "LS>"  
319e f1			.pastdmark: pop af  
319f			endm  
# End of macro DMARK
319f					CALLMONITOR 
319f cd aa fd			call debug_vector  
31a2				endm  
# End of macro CALLMONITOR
31a2				endif 
31a2 cd da 1f				call forth_push_str 
31a5			 
31a5			 
31a5			 
31a5					NEXTW 
31a5 cd a7 fd			call parse_vector 
31a8 c3 53 23			jp macro_next 
31ab				endm 
# End of macro NEXTW
31ab			 
31ab			;.luno:    db "Word not found",0 
31ab			 
31ab			 
31ab			 
31ab			 
31ab			 
31ab			;		push hl   ; save pointer to start of uword def string 
31ab			; 
31ab			;; look for FORTH_EOL_LINE 
31ab			;		ld a, FORTH_END_BUFFER 
31ab			;		call strlent 
31ab			; 
31ab			;		inc hl		 ; space for coln def 
31ab			;		inc hl 
31ab			;		inc hl          ; space for terms 
31ab			;		inc hl 
31ab			; 
31ab			;		ld a, 20   ; TODO get actual length 
31ab			;		call addatohl    ; include a random amount of room for the uword name 
31ab			; 
31ab			;		 
31ab			;	if DEBUG_FORTH_WORDS 
31ab			;		DMARK "Lt1" 
31ab			;		CALLMONITOR 
31ab			;	endif 
31ab			;		 
31ab			; 
31ab			;; malloc space for the string because we cant change it 
31ab			; 
31ab			;		call malloc 
31ab			;	if DEBUG_FORTH_MALLOC_GUARD 
31ab			;		push af 
31ab			;		call ishlzero 
31ab			;		pop af 
31ab			;		 
31ab			;		call z,malloc_error 
31ab			;	endif 
31ab			; 
31ab			;	if DEBUG_FORTH_WORDS 
31ab			;		DMARK "Lt2" 
31ab			;		CALLMONITOR 
31ab			;	endif 
31ab			;		pop de 
31ab			;		push hl    ; push the malloc to release later 
31ab			;		push hl   ;  push back a copy for the later stack push 
31ab			;		 
31ab			;; copy the string swapping out the zero terms for spaces 
31ab			; 
31ab			;		; de has our source 
31ab			;		; hl has our dest 
31ab			; 
31ab			;; add the coln def 
31ab			; 
31ab			;		ld a, ':' 
31ab			;		ld (hl), a 
31ab			;		inc hl 
31ab			;		ld a, ' ' 
31ab			;		ld (hl), a 
31ab			;		inc hl 
31ab			; 
31ab			;; add the uname word 
31ab			;		push de   ; save our string for now 
31ab			;		ex de, hl 
31ab			; 
31ab			;		FORTH_DSP_VALUE 
31ab			;		;v5 FORTH_DSP_VALUE 
31ab			; 
31ab			;		inc hl   ; skip type but we know by now this is OK 
31ab			; 
31ab			;.luword:	ld a,(hl) 
31ab			;		cp 0 
31ab			;		jr z, .luword2 
31ab			;		ld (de), a 
31ab			;		inc de 
31ab			;		inc hl 
31ab			;		jr .luword 
31ab			; 
31ab			;.luword2:	ld a, ' ' 
31ab			;		ld (de), a 
31ab			;;		inc hl 
31ab			;;		inc de 
31ab			;;		ld (de), a 
31ab			;;		inc hl 
31ab			;		inc de 
31ab			; 
31ab			;		ex de, hl 
31ab			;		pop de 
31ab			;		 
31ab			;		 
31ab			; 
31ab			;; detoken that string and copy it 
31ab			; 
31ab			;	if DEBUG_FORTH_WORDS 
31ab			;		DMARK "Lt2" 
31ab			;		CALLMONITOR 
31ab			;	endif 
31ab			;.ldetok:	ld a, (de) 
31ab			;		cp FORTH_END_BUFFER 
31ab			;		jr z, .ldetokend 
31ab			;		; swap out any zero term for space 
31ab			;		cp 0 
31ab			;		jr nz, .ldetoknext 
31ab			;		ld a, ' ' 
31ab			; 
31ab			;	if DEBUG_FORTH_WORDS 
31ab			;		DMARK "LtS" 
31ab			;		CALLMONITOR 
31ab			;	endif 
31ab			;.ldetoknext:	ld (hl), a 
31ab			;		inc de 
31ab			;		inc hl 
31ab			;		jr .ldetok 
31ab			; 
31ab			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
31ab			;		ld (hl), a  
31ab			; 
31ab			;; free that temp malloc 
31ab			; 
31ab			;		pop hl    
31ab			; 
31ab			;	if DEBUG_FORTH_WORDS 
31ab			;		DMARK "Lt4" 
31ab			;		CALLMONITOR 
31ab			;	endif 
31ab			;		call forth_apushstrhl 
31ab			; 
31ab			;		; get rid of temp malloc area 
31ab			; 
31ab			;		pop hl 
31ab			;		call free 
31ab			; 
31ab			;		jr .ludone 
31ab			; 
31ab			;.lnuword:	pop hl 
31ab			;		call forth_tok_next 
31ab			;		jp .ldouscan  
31ab			; 
31ab			;.ludone:		 pop hl 
31ab			; 
31ab					NEXTW 
31ab cd a7 fd			call parse_vector 
31ae c3 53 23			jp macro_next 
31b1				endm 
# End of macro NEXTW
31b1			 
31b1			.FORGET: 
31b1				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
31b1 5d				db WORD_SYS_CORE+73             
31b2 2c 32			dw .NOP            
31b4 07				db 6 + 1 
31b5 .. 00			db "FORGET",0              
31bc				endm 
# End of macro CWHEAD
31bc			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
31bc			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
31bc			; | |  
31bc			; | | e.g. "MORE" forget 
31bc					if DEBUG_FORTH_WORDS_KEY 
31bc						DMARK "FRG" 
31bc f5				push af  
31bd 3a d1 31			ld a, (.dmark)  
31c0 32 9d fd			ld (debug_mark),a  
31c3 3a d2 31			ld a, (.dmark+1)  
31c6 32 9e fd			ld (debug_mark+1),a  
31c9 3a d3 31			ld a, (.dmark+2)  
31cc 32 9f fd			ld (debug_mark+2),a  
31cf 18 03			jr .pastdmark  
31d1 ..			.dmark: db "FRG"  
31d4 f1			.pastdmark: pop af  
31d5			endm  
# End of macro DMARK
31d5						CALLMONITOR 
31d5 cd aa fd			call debug_vector  
31d8				endm  
# End of macro CALLMONITOR
31d8					endif 
31d8			 
31d8				; find uword 
31d8			        ; update start of word with "_" 
31d8				; replace uword with deleted flag 
31d8			 
31d8			 
31d8			;	if DEBUG_FORTH_WORDS 
31d8			;		DMARK "FOG" 
31d8			;		CALLMONITOR 
31d8			;	endif 
31d8			 
31d8			 
31d8					; Get ptr to the word we need to look up 
31d8			 
31d8					FORTH_DSP_VALUEHL 
31d8 cd 6c 21			call macro_dsp_valuehl 
31db				endm 
# End of macro FORTH_DSP_VALUEHL
31db					;v5 FORTH_DSP_VALUE 
31db				; TODO type check 
31db			;		inc hl    ; Skip type check  
31db e5					push hl 
31dc c1					pop bc 
31dd			;		ex de, hl    ; put into DE 
31dd			 
31dd			 
31dd 21 00 80				ld hl, baseram 
31e0					;ld hl, baseusermem 
31e0			 
31e0				; skip dict stub 
31e0			;	call forth_tok_next 
31e0 e5			push hl   ; sacreifical push 
31e1			 
31e1			.fldouscanm: 
31e1 e1				pop hl 
31e2			.fldouscan: 
31e2			;	if DEBUG_FORTH_WORDS 
31e2			;		DMARK "LSs" 
31e2			;		CALLMONITOR 
31e2			;	endif 
31e2				; skip dict stub 
31e2 cd 85 24				call forth_tok_next 
31e5			 
31e5			 
31e5			; while we have words to look for 
31e5			 
31e5 7e				ld a, (hl)      
31e6			;	if DEBUG_FORTH_WORDS 
31e6			;		DMARK "LSk" 
31e6			;		CALLMONITOR 
31e6			;	endif 
31e6 fe 00				cp WORD_SYS_END 
31e8 ca 23 32				jp z, .flunotfound 
31eb fe 01				cp WORD_SYS_UWORD 
31ed c2 e2 31				jp nz, .fldouscan 
31f0			 
31f0			;	if DEBUG_FORTH_WORDS 
31f0			;		DMARK "LSu" 
31f0			;		CALLMONITOR 
31f0			;	endif 
31f0			 
31f0					; found a uword but is it the one we want... 
31f0			 
31f0 c5					push bc     ; uword to find is on bc 
31f1 d1					pop de 
31f2			 
31f2 e5					push hl  ; to save the ptr 
31f3			 
31f3					; skip opcode 
31f3 23					inc hl  
31f4					; skip next ptr 
31f4 23					inc hl  
31f5 23					inc hl 
31f6					; skip len 
31f6 23					inc hl 
31f7			 
31f7			;	if DEBUG_FORTH_WORDS 
31f7			;		DMARK "LSc" 
31f7			;		CALLMONITOR 
31f7			;	endif 
31f7 cd 3c 13				call strcmp 
31fa c2 e1 31				jp nz, .fldouscanm 
31fd			; 
31fd			; 
31fd			;; while we have words to look for 
31fd			; 
31fd			;.fdouscan:	ld a, (hl)      
31fd			;	if DEBUG_FORTH_WORDS 
31fd			;		DMARK "LSs" 
31fd			;		CALLMONITOR 
31fd			;	endif 
31fd			;		cp WORD_SYS_END 
31fd			;		jp z, .fudone 
31fd			;		cp WORD_SYS_UWORD 
31fd			;		jp nz, .fnuword 
31fd			; 
31fd			;	if DEBUG_FORTH_WORDS 
31fd			;		DMARK "FGu" 
31fd			;		CALLMONITOR 
31fd			;	endif 
31fd			; 
31fd			;		; found a uword but is it the one we want... 
31fd			; 
31fd			; 
31fd			;	        pop de   ; get back the dsp name 
31fd			;		push de 
31fd			; 
31fd			;		push hl  ; to save the ptr 
31fd			; 
31fd			;		; skip opcode 
31fd			;		inc hl  
31fd			;		; skip next ptr 
31fd			;		inc hl  
31fd			;		inc hl 
31fd			;		; skip len 
31fd			;		inc hl 
31fd			; 
31fd			;	if DEBUG_FORTH_WORDS 
31fd			;		DMARK "FGc" 
31fd			;		CALLMONITOR 
31fd			;	endif 
31fd			;		call strcmp 
31fd			;		jp nz, .fnuword 
31fd			 
31fd			 
31fd e1			pop hl 
31fe			 
31fe				 
31fe				if DEBUG_FORTH_WORDS 
31fe					DMARK "FGm" 
31fe f5				push af  
31ff 3a 13 32			ld a, (.dmark)  
3202 32 9d fd			ld (debug_mark),a  
3205 3a 14 32			ld a, (.dmark+1)  
3208 32 9e fd			ld (debug_mark+1),a  
320b 3a 15 32			ld a, (.dmark+2)  
320e 32 9f fd			ld (debug_mark+2),a  
3211 18 03			jr .pastdmark  
3213 ..			.dmark: db "FGm"  
3216 f1			.pastdmark: pop af  
3217			endm  
# End of macro DMARK
3217					CALLMONITOR 
3217 cd aa fd			call debug_vector  
321a				endm  
# End of macro CALLMONITOR
321a				endif 
321a			 
321a			 
321a			 
321a					; we have a uword so push its name to the stack 
321a			 
321a			;	   	push hl  ; save so we can move to next dict block 
321a			;pop hl 
321a			 
321a					; update opcode to deleted 
321a			;		ld a, WORD_SYS_DELETED 
321a 36 03				ld (hl), WORD_SYS_DELETED 
321c			 
321c 23					inc hl  
321d					; skip next ptr 
321d 23					inc hl  
321e 23					inc hl 
321f					; skip len 
321f 23					inc hl 
3220			 
3220					; TODO change parser to skip deleted words but for now mark it out 
3220 3e 5f				ld a, "_" 
3222 77					ld  (hl),a 
3223			 
3223			;		jr .fudone 
3223			; 
3223			;.fnuword:	pop hl 
3223			;		call forth_tok_next 
3223			;		jp .fdouscan  
3223			 
3223			.flunotfound:		  
3223			 
3223			 
3223					 
3223					FORTH_DSP_POP 
3223 cd 24 22			call macro_forth_dsp_pop 
3226				endm 
# End of macro FORTH_DSP_POP
3226			;		ld hl, .luno 
3226			;.fudone:		 pop hl 
3226					NEXTW 
3226 cd a7 fd			call parse_vector 
3229 c3 53 23			jp macro_next 
322c				endm 
# End of macro NEXTW
322c			.NOP: 
322c				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
322c 61				db WORD_SYS_CORE+77             
322d 56 32			dw .COMO            
322f 04				db 3 + 1 
3230 .. 00			db "NOP",0              
3234				endm 
# End of macro CWHEAD
3234			; | NOP (  --  ) Do nothing | DONE 
3234					if DEBUG_FORTH_WORDS_KEY 
3234						DMARK "NOP" 
3234 f5				push af  
3235 3a 49 32			ld a, (.dmark)  
3238 32 9d fd			ld (debug_mark),a  
323b 3a 4a 32			ld a, (.dmark+1)  
323e 32 9e fd			ld (debug_mark+1),a  
3241 3a 4b 32			ld a, (.dmark+2)  
3244 32 9f fd			ld (debug_mark+2),a  
3247 18 03			jr .pastdmark  
3249 ..			.dmark: db "NOP"  
324c f1			.pastdmark: pop af  
324d			endm  
# End of macro DMARK
324d						CALLMONITOR 
324d cd aa fd			call debug_vector  
3250				endm  
# End of macro CALLMONITOR
3250					endif 
3250				       NEXTW 
3250 cd a7 fd			call parse_vector 
3253 c3 53 23			jp macro_next 
3256				endm 
# End of macro NEXTW
3256			.COMO: 
3256				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
3256 6e				db WORD_SYS_CORE+90             
3257 ab 32			dw .COMC            
3259 02				db 1 + 1 
325a .. 00			db "(",0              
325c				endm 
# End of macro CWHEAD
325c			; | ( ( -- )  Start of comment | DONE 
325c			 
325c			 
325c 2a f4 f3				ld hl, ( os_tok_ptr) 
325f 11 a3 32			ld de, .closepar 
3262					 
3262					if DEBUG_FORTH_WORDS 
3262						DMARK ").." 
3262 f5				push af  
3263 3a 77 32			ld a, (.dmark)  
3266 32 9d fd			ld (debug_mark),a  
3269 3a 78 32			ld a, (.dmark+1)  
326c 32 9e fd			ld (debug_mark+1),a  
326f 3a 79 32			ld a, (.dmark+2)  
3272 32 9f fd			ld (debug_mark+2),a  
3275 18 03			jr .pastdmark  
3277 ..			.dmark: db ").."  
327a f1			.pastdmark: pop af  
327b			endm  
# End of macro DMARK
327b						CALLMONITOR 
327b cd aa fd			call debug_vector  
327e				endm  
# End of macro CALLMONITOR
327e					endif 
327e cd 50 24			call findnexttok  
3281			 
3281					if DEBUG_FORTH_WORDS 
3281						DMARK "IF5" 
3281 f5				push af  
3282 3a 96 32			ld a, (.dmark)  
3285 32 9d fd			ld (debug_mark),a  
3288 3a 97 32			ld a, (.dmark+1)  
328b 32 9e fd			ld (debug_mark+1),a  
328e 3a 98 32			ld a, (.dmark+2)  
3291 32 9f fd			ld (debug_mark+2),a  
3294 18 03			jr .pastdmark  
3296 ..			.dmark: db "IF5"  
3299 f1			.pastdmark: pop af  
329a			endm  
# End of macro DMARK
329a						CALLMONITOR 
329a cd aa fd			call debug_vector  
329d				endm  
# End of macro CALLMONITOR
329d					endif 
329d				; replace below with ) exec using tok_ptr 
329d 22 f4 f3			ld (os_tok_ptr), hl 
32a0 c3 d4 23			jp exec1 
32a3			 
32a3 .. 00			.closepar:   db ")",0 
32a5			 
32a5				       NEXTW 
32a5 cd a7 fd			call parse_vector 
32a8 c3 53 23			jp macro_next 
32ab				endm 
# End of macro NEXTW
32ab			.COMC: 
32ab				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
32ab 6f				db WORD_SYS_CORE+91             
32ac b7 32			dw .SCRATCH            
32ae 02				db 1 + 1 
32af .. 00			db ")",0              
32b1				endm 
# End of macro CWHEAD
32b1			; | ) ( -- )  End of comment |  DONE  
32b1				       NEXTW 
32b1 cd a7 fd			call parse_vector 
32b4 c3 53 23			jp macro_next 
32b7				endm 
# End of macro NEXTW
32b7			 
32b7			.SCRATCH: 
32b7				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
32b7 6f				db WORD_SYS_CORE+91             
32b8 f5 32			dw .INC            
32ba 08				db 7 + 1 
32bb .. 00			db "SCRATCH",0              
32c3				endm 
# End of macro CWHEAD
32c3			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
32c3			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
32c3			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
32c3			; | |  
32c3			; | | e.g.    : score $00 scratch ; 
32c3			; | |  
32c3			; | | $00 score ! 
32c3			; | | $01 score +! 
32c3			; | |  
32c3			; | | e.g.   : varword $0a scratch ;  
32c3			; | | 
32c3			; | | $8000 varword ! 
32c3					if DEBUG_FORTH_WORDS_KEY 
32c3						DMARK "SCR" 
32c3 f5				push af  
32c4 3a d8 32			ld a, (.dmark)  
32c7 32 9d fd			ld (debug_mark),a  
32ca 3a d9 32			ld a, (.dmark+1)  
32cd 32 9e fd			ld (debug_mark+1),a  
32d0 3a da 32			ld a, (.dmark+2)  
32d3 32 9f fd			ld (debug_mark+2),a  
32d6 18 03			jr .pastdmark  
32d8 ..			.dmark: db "SCR"  
32db f1			.pastdmark: pop af  
32dc			endm  
# End of macro DMARK
32dc						CALLMONITOR 
32dc cd aa fd			call debug_vector  
32df				endm  
# End of macro CALLMONITOR
32df					endif 
32df			 
32df					FORTH_DSP_VALUEHL 
32df cd 6c 21			call macro_dsp_valuehl 
32e2				endm 
# End of macro FORTH_DSP_VALUEHL
32e2				 
32e2					FORTH_DSP_POP 
32e2 cd 24 22			call macro_forth_dsp_pop 
32e5				endm 
# End of macro FORTH_DSP_POP
32e5			 
32e5 7d					ld a, l 
32e6 21 18 f6				ld hl, os_var_array 
32e9 cd ac 0f				call addatohl 
32ec			 
32ec cd 70 1f				call forth_push_numhl 
32ef			 
32ef				       NEXTW 
32ef cd a7 fd			call parse_vector 
32f2 c3 53 23			jp macro_next 
32f5				endm 
# End of macro NEXTW
32f5			 
32f5			.INC: 
32f5				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
32f5 6f				db WORD_SYS_CORE+91             
32f6 4e 33			dw .DEC            
32f8 03				db 2 + 1 
32f9 .. 00			db "+!",0              
32fc				endm 
# End of macro CWHEAD
32fc			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
32fc					if DEBUG_FORTH_WORDS_KEY 
32fc						DMARK "+s_" 
32fc f5				push af  
32fd 3a 11 33			ld a, (.dmark)  
3300 32 9d fd			ld (debug_mark),a  
3303 3a 12 33			ld a, (.dmark+1)  
3306 32 9e fd			ld (debug_mark+1),a  
3309 3a 13 33			ld a, (.dmark+2)  
330c 32 9f fd			ld (debug_mark+2),a  
330f 18 03			jr .pastdmark  
3311 ..			.dmark: db "+s_"  
3314 f1			.pastdmark: pop af  
3315			endm  
# End of macro DMARK
3315						CALLMONITOR 
3315 cd aa fd			call debug_vector  
3318				endm  
# End of macro CALLMONITOR
3318					endif 
3318			 
3318					FORTH_DSP_VALUEHL 
3318 cd 6c 21			call macro_dsp_valuehl 
331b				endm 
# End of macro FORTH_DSP_VALUEHL
331b			 
331b e5					push hl   ; save address 
331c			 
331c					FORTH_DSP_POP 
331c cd 24 22			call macro_forth_dsp_pop 
331f				endm 
# End of macro FORTH_DSP_POP
331f			 
331f					FORTH_DSP_VALUEHL 
331f cd 6c 21			call macro_dsp_valuehl 
3322				endm 
# End of macro FORTH_DSP_VALUEHL
3322			 
3322 e5					push hl 
3323					FORTH_DSP_POP 
3323 cd 24 22			call macro_forth_dsp_pop 
3326				endm 
# End of macro FORTH_DSP_POP
3326 e1					pop hl 
3327			 
3327					; hl contains value to add to byte at a 
3327				 
3327 eb					ex de, hl 
3328			 
3328 e1					pop hl 
3329			 
3329					if DEBUG_FORTH_WORDS 
3329						DMARK "INC" 
3329 f5				push af  
332a 3a 3e 33			ld a, (.dmark)  
332d 32 9d fd			ld (debug_mark),a  
3330 3a 3f 33			ld a, (.dmark+1)  
3333 32 9e fd			ld (debug_mark+1),a  
3336 3a 40 33			ld a, (.dmark+2)  
3339 32 9f fd			ld (debug_mark+2),a  
333c 18 03			jr .pastdmark  
333e ..			.dmark: db "INC"  
3341 f1			.pastdmark: pop af  
3342			endm  
# End of macro DMARK
3342						CALLMONITOR 
3342 cd aa fd			call debug_vector  
3345				endm  
# End of macro CALLMONITOR
3345					endif 
3345			 
3345 7e					ld a,(hl) 
3346 83					add e 
3347 77					ld (hl),a 
3348			 
3348			 
3348			 
3348				       NEXTW 
3348 cd a7 fd			call parse_vector 
334b c3 53 23			jp macro_next 
334e				endm 
# End of macro NEXTW
334e			 
334e			.DEC: 
334e				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
334e 6f				db WORD_SYS_CORE+91             
334f a5 33			dw .INC2            
3351 03				db 2 + 1 
3352 .. 00			db "-!",0              
3355				endm 
# End of macro CWHEAD
3355			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3355					if DEBUG_FORTH_WORDS_KEY 
3355						DMARK "-s_" 
3355 f5				push af  
3356 3a 6a 33			ld a, (.dmark)  
3359 32 9d fd			ld (debug_mark),a  
335c 3a 6b 33			ld a, (.dmark+1)  
335f 32 9e fd			ld (debug_mark+1),a  
3362 3a 6c 33			ld a, (.dmark+2)  
3365 32 9f fd			ld (debug_mark+2),a  
3368 18 03			jr .pastdmark  
336a ..			.dmark: db "-s_"  
336d f1			.pastdmark: pop af  
336e			endm  
# End of macro DMARK
336e						CALLMONITOR 
336e cd aa fd			call debug_vector  
3371				endm  
# End of macro CALLMONITOR
3371					endif 
3371			 
3371					FORTH_DSP_VALUEHL 
3371 cd 6c 21			call macro_dsp_valuehl 
3374				endm 
# End of macro FORTH_DSP_VALUEHL
3374			 
3374 e5					push hl   ; save address 
3375			 
3375					FORTH_DSP_POP 
3375 cd 24 22			call macro_forth_dsp_pop 
3378				endm 
# End of macro FORTH_DSP_POP
3378			 
3378					FORTH_DSP_VALUEHL 
3378 cd 6c 21			call macro_dsp_valuehl 
337b				endm 
# End of macro FORTH_DSP_VALUEHL
337b			 
337b					; hl contains value to add to byte at a 
337b				 
337b eb					ex de, hl 
337c			 
337c e1					pop hl 
337d			 
337d					if DEBUG_FORTH_WORDS 
337d						DMARK "DEC" 
337d f5				push af  
337e 3a 92 33			ld a, (.dmark)  
3381 32 9d fd			ld (debug_mark),a  
3384 3a 93 33			ld a, (.dmark+1)  
3387 32 9e fd			ld (debug_mark+1),a  
338a 3a 94 33			ld a, (.dmark+2)  
338d 32 9f fd			ld (debug_mark+2),a  
3390 18 03			jr .pastdmark  
3392 ..			.dmark: db "DEC"  
3395 f1			.pastdmark: pop af  
3396			endm  
# End of macro DMARK
3396						CALLMONITOR 
3396 cd aa fd			call debug_vector  
3399				endm  
# End of macro CALLMONITOR
3399					endif 
3399			 
3399 7e					ld a,(hl) 
339a 93					sub e 
339b 77					ld (hl),a 
339c			 
339c			 
339c					FORTH_DSP_POP 
339c cd 24 22			call macro_forth_dsp_pop 
339f				endm 
# End of macro FORTH_DSP_POP
339f			 
339f				       NEXTW 
339f cd a7 fd			call parse_vector 
33a2 c3 53 23			jp macro_next 
33a5				endm 
# End of macro NEXTW
33a5			 
33a5			.INC2: 
33a5				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
33a5 6f				db WORD_SYS_CORE+91             
33a6 55 34			dw .DEC2            
33a8 04				db 3 + 1 
33a9 .. 00			db "+2!",0              
33ad				endm 
# End of macro CWHEAD
33ad			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
33ad			 
33ad					if DEBUG_FORTH_WORDS_KEY 
33ad						DMARK "+2s" 
33ad f5				push af  
33ae 3a c2 33			ld a, (.dmark)  
33b1 32 9d fd			ld (debug_mark),a  
33b4 3a c3 33			ld a, (.dmark+1)  
33b7 32 9e fd			ld (debug_mark+1),a  
33ba 3a c4 33			ld a, (.dmark+2)  
33bd 32 9f fd			ld (debug_mark+2),a  
33c0 18 03			jr .pastdmark  
33c2 ..			.dmark: db "+2s"  
33c5 f1			.pastdmark: pop af  
33c6			endm  
# End of macro DMARK
33c6						CALLMONITOR 
33c6 cd aa fd			call debug_vector  
33c9				endm  
# End of macro CALLMONITOR
33c9					endif 
33c9			 
33c9					; Address 
33c9			 
33c9					FORTH_DSP_VALUEHL 
33c9 cd 6c 21			call macro_dsp_valuehl 
33cc				endm 
# End of macro FORTH_DSP_VALUEHL
33cc			 
33cc e5					push hl    ; save address 
33cd			 
33cd					; load content into de 
33cd			 
33cd 5e					ld e,(hl) 
33ce 23					inc hl 
33cf 56					ld d, (hl) 
33d0			 
33d0					if DEBUG_FORTH_WORDS 
33d0						DMARK "+2a" 
33d0 f5				push af  
33d1 3a e5 33			ld a, (.dmark)  
33d4 32 9d fd			ld (debug_mark),a  
33d7 3a e6 33			ld a, (.dmark+1)  
33da 32 9e fd			ld (debug_mark+1),a  
33dd 3a e7 33			ld a, (.dmark+2)  
33e0 32 9f fd			ld (debug_mark+2),a  
33e3 18 03			jr .pastdmark  
33e5 ..			.dmark: db "+2a"  
33e8 f1			.pastdmark: pop af  
33e9			endm  
# End of macro DMARK
33e9						CALLMONITOR 
33e9 cd aa fd			call debug_vector  
33ec				endm  
# End of macro CALLMONITOR
33ec					endif 
33ec			 
33ec					FORTH_DSP_POP 
33ec cd 24 22			call macro_forth_dsp_pop 
33ef				endm 
# End of macro FORTH_DSP_POP
33ef			 
33ef					; Get value to add 
33ef			 
33ef					FORTH_DSP_VALUE 
33ef cd 55 21			call macro_forth_dsp_value 
33f2				endm 
# End of macro FORTH_DSP_VALUE
33f2			 
33f2					if DEBUG_FORTH_WORDS 
33f2						DMARK "+2v" 
33f2 f5				push af  
33f3 3a 07 34			ld a, (.dmark)  
33f6 32 9d fd			ld (debug_mark),a  
33f9 3a 08 34			ld a, (.dmark+1)  
33fc 32 9e fd			ld (debug_mark+1),a  
33ff 3a 09 34			ld a, (.dmark+2)  
3402 32 9f fd			ld (debug_mark+2),a  
3405 18 03			jr .pastdmark  
3407 ..			.dmark: db "+2v"  
340a f1			.pastdmark: pop af  
340b			endm  
# End of macro DMARK
340b						CALLMONITOR 
340b cd aa fd			call debug_vector  
340e				endm  
# End of macro CALLMONITOR
340e					endif 
340e			 
340e 19					add hl, de 
340f			 
340f					if DEBUG_FORTH_WORDS 
340f						DMARK "+2+" 
340f f5				push af  
3410 3a 24 34			ld a, (.dmark)  
3413 32 9d fd			ld (debug_mark),a  
3416 3a 25 34			ld a, (.dmark+1)  
3419 32 9e fd			ld (debug_mark+1),a  
341c 3a 26 34			ld a, (.dmark+2)  
341f 32 9f fd			ld (debug_mark+2),a  
3422 18 03			jr .pastdmark  
3424 ..			.dmark: db "+2+"  
3427 f1			.pastdmark: pop af  
3428			endm  
# End of macro DMARK
3428						CALLMONITOR 
3428 cd aa fd			call debug_vector  
342b				endm  
# End of macro CALLMONITOR
342b					endif 
342b			 
342b					; move result to de 
342b			 
342b eb					ex de, hl 
342c			 
342c					; Address 
342c			 
342c e1					pop hl 
342d			 
342d					; save it back 
342d			 
342d 73					ld (hl), e 
342e 23					inc hl 
342f 72					ld (hl), d 
3430			 
3430					if DEBUG_FORTH_WORDS 
3430						DMARK "+2e" 
3430 f5				push af  
3431 3a 45 34			ld a, (.dmark)  
3434 32 9d fd			ld (debug_mark),a  
3437 3a 46 34			ld a, (.dmark+1)  
343a 32 9e fd			ld (debug_mark+1),a  
343d 3a 47 34			ld a, (.dmark+2)  
3440 32 9f fd			ld (debug_mark+2),a  
3443 18 03			jr .pastdmark  
3445 ..			.dmark: db "+2e"  
3448 f1			.pastdmark: pop af  
3449			endm  
# End of macro DMARK
3449						CALLMONITOR 
3449 cd aa fd			call debug_vector  
344c				endm  
# End of macro CALLMONITOR
344c					endif 
344c			 
344c			 
344c			 
344c					FORTH_DSP_POP 
344c cd 24 22			call macro_forth_dsp_pop 
344f				endm 
# End of macro FORTH_DSP_POP
344f			 
344f			 
344f				       NEXTW 
344f cd a7 fd			call parse_vector 
3452 c3 53 23			jp macro_next 
3455				endm 
# End of macro NEXTW
3455			 
3455			.DEC2: 
3455				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3455 6f				db WORD_SYS_CORE+91             
3456 07 35			dw .GET2            
3458 04				db 3 + 1 
3459 .. 00			db "-2!",0              
345d				endm 
# End of macro CWHEAD
345d			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
345d			 
345d			 
345d					if DEBUG_FORTH_WORDS_KEY 
345d						DMARK "-2s" 
345d f5				push af  
345e 3a 72 34			ld a, (.dmark)  
3461 32 9d fd			ld (debug_mark),a  
3464 3a 73 34			ld a, (.dmark+1)  
3467 32 9e fd			ld (debug_mark+1),a  
346a 3a 74 34			ld a, (.dmark+2)  
346d 32 9f fd			ld (debug_mark+2),a  
3470 18 03			jr .pastdmark  
3472 ..			.dmark: db "-2s"  
3475 f1			.pastdmark: pop af  
3476			endm  
# End of macro DMARK
3476						CALLMONITOR 
3476 cd aa fd			call debug_vector  
3479				endm  
# End of macro CALLMONITOR
3479					endif 
3479			 
3479					; Address 
3479			 
3479					FORTH_DSP_VALUEHL 
3479 cd 6c 21			call macro_dsp_valuehl 
347c				endm 
# End of macro FORTH_DSP_VALUEHL
347c			 
347c e5					push hl    ; save address 
347d			 
347d					; load content into de 
347d			 
347d 5e					ld e,(hl) 
347e 23					inc hl 
347f 56					ld d, (hl) 
3480			 
3480					if DEBUG_FORTH_WORDS 
3480						DMARK "-2a" 
3480 f5				push af  
3481 3a 95 34			ld a, (.dmark)  
3484 32 9d fd			ld (debug_mark),a  
3487 3a 96 34			ld a, (.dmark+1)  
348a 32 9e fd			ld (debug_mark+1),a  
348d 3a 97 34			ld a, (.dmark+2)  
3490 32 9f fd			ld (debug_mark+2),a  
3493 18 03			jr .pastdmark  
3495 ..			.dmark: db "-2a"  
3498 f1			.pastdmark: pop af  
3499			endm  
# End of macro DMARK
3499						CALLMONITOR 
3499 cd aa fd			call debug_vector  
349c				endm  
# End of macro CALLMONITOR
349c					endif 
349c			 
349c					FORTH_DSP_POP 
349c cd 24 22			call macro_forth_dsp_pop 
349f				endm 
# End of macro FORTH_DSP_POP
349f			 
349f					; Get value to remove 
349f			 
349f					FORTH_DSP_VALUE 
349f cd 55 21			call macro_forth_dsp_value 
34a2				endm 
# End of macro FORTH_DSP_VALUE
34a2			 
34a2					if DEBUG_FORTH_WORDS 
34a2						DMARK "-2v" 
34a2 f5				push af  
34a3 3a b7 34			ld a, (.dmark)  
34a6 32 9d fd			ld (debug_mark),a  
34a9 3a b8 34			ld a, (.dmark+1)  
34ac 32 9e fd			ld (debug_mark+1),a  
34af 3a b9 34			ld a, (.dmark+2)  
34b2 32 9f fd			ld (debug_mark+2),a  
34b5 18 03			jr .pastdmark  
34b7 ..			.dmark: db "-2v"  
34ba f1			.pastdmark: pop af  
34bb			endm  
# End of macro DMARK
34bb						CALLMONITOR 
34bb cd aa fd			call debug_vector  
34be				endm  
# End of macro CALLMONITOR
34be					endif 
34be			 
34be eb					ex de, hl 
34bf ed 52				sbc hl, de 
34c1			 
34c1					if DEBUG_FORTH_WORDS 
34c1						DMARK "-2d" 
34c1 f5				push af  
34c2 3a d6 34			ld a, (.dmark)  
34c5 32 9d fd			ld (debug_mark),a  
34c8 3a d7 34			ld a, (.dmark+1)  
34cb 32 9e fd			ld (debug_mark+1),a  
34ce 3a d8 34			ld a, (.dmark+2)  
34d1 32 9f fd			ld (debug_mark+2),a  
34d4 18 03			jr .pastdmark  
34d6 ..			.dmark: db "-2d"  
34d9 f1			.pastdmark: pop af  
34da			endm  
# End of macro DMARK
34da						CALLMONITOR 
34da cd aa fd			call debug_vector  
34dd				endm  
# End of macro CALLMONITOR
34dd					endif 
34dd			 
34dd					; move result to de 
34dd			 
34dd eb					ex de, hl 
34de			 
34de					; Address 
34de			 
34de e1					pop hl 
34df			 
34df					; save it back 
34df			 
34df 73					ld (hl), e 
34e0 23					inc hl 
34e1 72					ld (hl), d 
34e2			 
34e2					if DEBUG_FORTH_WORDS 
34e2						DMARK "-2e" 
34e2 f5				push af  
34e3 3a f7 34			ld a, (.dmark)  
34e6 32 9d fd			ld (debug_mark),a  
34e9 3a f8 34			ld a, (.dmark+1)  
34ec 32 9e fd			ld (debug_mark+1),a  
34ef 3a f9 34			ld a, (.dmark+2)  
34f2 32 9f fd			ld (debug_mark+2),a  
34f5 18 03			jr .pastdmark  
34f7 ..			.dmark: db "-2e"  
34fa f1			.pastdmark: pop af  
34fb			endm  
# End of macro DMARK
34fb						CALLMONITOR 
34fb cd aa fd			call debug_vector  
34fe				endm  
# End of macro CALLMONITOR
34fe					endif 
34fe			 
34fe			 
34fe					FORTH_DSP_POP 
34fe cd 24 22			call macro_forth_dsp_pop 
3501				endm 
# End of macro FORTH_DSP_POP
3501			 
3501			 
3501			 
3501				       NEXTW 
3501 cd a7 fd			call parse_vector 
3504 c3 53 23			jp macro_next 
3507				endm 
# End of macro NEXTW
3507			.GET2: 
3507				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3507 6f				db WORD_SYS_CORE+91             
3508 3f 35			dw .BANG2            
350a 03				db 2 + 1 
350b .. 00			db "2@",0              
350e				endm 
# End of macro CWHEAD
350e			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
350e					if DEBUG_FORTH_WORDS_KEY 
350e						DMARK "2A_" 
350e f5				push af  
350f 3a 23 35			ld a, (.dmark)  
3512 32 9d fd			ld (debug_mark),a  
3515 3a 24 35			ld a, (.dmark+1)  
3518 32 9e fd			ld (debug_mark+1),a  
351b 3a 25 35			ld a, (.dmark+2)  
351e 32 9f fd			ld (debug_mark+2),a  
3521 18 03			jr .pastdmark  
3523 ..			.dmark: db "2A_"  
3526 f1			.pastdmark: pop af  
3527			endm  
# End of macro DMARK
3527						CALLMONITOR 
3527 cd aa fd			call debug_vector  
352a				endm  
# End of macro CALLMONITOR
352a					endif 
352a			 
352a					FORTH_DSP_VALUEHL 
352a cd 6c 21			call macro_dsp_valuehl 
352d				endm 
# End of macro FORTH_DSP_VALUEHL
352d			 
352d e5					push hl   ; save address 
352e			 
352e					FORTH_DSP_POP 
352e cd 24 22			call macro_forth_dsp_pop 
3531				endm 
# End of macro FORTH_DSP_POP
3531			 
3531 e1					pop hl 
3532			 
3532 5e					ld e, (hl) 
3533 23					inc hl 
3534 56					ld d, (hl) 
3535			 
3535 eb					ex de, hl 
3536			 
3536 cd 70 1f				call forth_push_numhl 
3539			 
3539				       NEXTW 
3539 cd a7 fd			call parse_vector 
353c c3 53 23			jp macro_next 
353f				endm 
# End of macro NEXTW
353f			.BANG2: 
353f				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
353f 6f				db WORD_SYS_CORE+91             
3540 7a 35			dw .CONFIG            
3542 03				db 2 + 1 
3543 .. 00			db "2!",0              
3546				endm 
# End of macro CWHEAD
3546			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3546					if DEBUG_FORTH_WORDS_KEY 
3546						DMARK "2S_" 
3546 f5				push af  
3547 3a 5b 35			ld a, (.dmark)  
354a 32 9d fd			ld (debug_mark),a  
354d 3a 5c 35			ld a, (.dmark+1)  
3550 32 9e fd			ld (debug_mark+1),a  
3553 3a 5d 35			ld a, (.dmark+2)  
3556 32 9f fd			ld (debug_mark+2),a  
3559 18 03			jr .pastdmark  
355b ..			.dmark: db "2S_"  
355e f1			.pastdmark: pop af  
355f			endm  
# End of macro DMARK
355f						CALLMONITOR 
355f cd aa fd			call debug_vector  
3562				endm  
# End of macro CALLMONITOR
3562					endif 
3562			 
3562					FORTH_DSP_VALUEHL 
3562 cd 6c 21			call macro_dsp_valuehl 
3565				endm 
# End of macro FORTH_DSP_VALUEHL
3565			 
3565 e5					push hl   ; save address 
3566			 
3566			 
3566					FORTH_DSP_POP 
3566 cd 24 22			call macro_forth_dsp_pop 
3569				endm 
# End of macro FORTH_DSP_POP
3569			 
3569					 
3569					FORTH_DSP_VALUEHL 
3569 cd 6c 21			call macro_dsp_valuehl 
356c				endm 
# End of macro FORTH_DSP_VALUEHL
356c			 
356c					FORTH_DSP_POP 
356c cd 24 22			call macro_forth_dsp_pop 
356f				endm 
# End of macro FORTH_DSP_POP
356f			 
356f eb					ex de, hl    ; value now in de 
3570			 
3570 e1					pop hl 
3571			 
3571 73					ld (hl), e 
3572			 
3572 23					inc hl 
3573			 
3573 72					ld (hl), d 
3574			 
3574			 
3574				       NEXTW 
3574 cd a7 fd			call parse_vector 
3577 c3 53 23			jp macro_next 
357a				endm 
# End of macro NEXTW
357a			.CONFIG: 
357a				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
357a 6f				db WORD_SYS_CORE+91             
357b 8e 35			dw .ADTOS            
357d 07				db 6 + 1 
357e .. 00			db "CONFIG",0              
3585				endm 
# End of macro CWHEAD
3585			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3585			 
3585 cd 11 15				call config 
3588					NEXTW 
3588 cd a7 fd			call parse_vector 
358b c3 53 23			jp macro_next 
358e				endm 
# End of macro NEXTW
358e			 
358e			.ADTOS: 
358e				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
358e 6f				db WORD_SYS_CORE+91             
358f a7 35			dw .SBTOS            
3591 03				db 2 + 1 
3592 .. 00			db "1+",0              
3595				endm 
# End of macro CWHEAD
3595			; | 1+ ( u -- u )  Increment value on TOS | DONE 
3595			 
3595					FORTH_DSP_VALUEHL 
3595 cd 6c 21			call macro_dsp_valuehl 
3598				endm 
# End of macro FORTH_DSP_VALUEHL
3598 e5					push hl 
3599			 
3599					FORTH_DSP_POP 
3599 cd 24 22			call macro_forth_dsp_pop 
359c				endm 
# End of macro FORTH_DSP_POP
359c e1					pop hl 
359d			 
359d 23					inc hl 
359e cd 70 1f				call forth_push_numhl 
35a1					 
35a1					NEXTW 
35a1 cd a7 fd			call parse_vector 
35a4 c3 53 23			jp macro_next 
35a7				endm 
# End of macro NEXTW
35a7			.SBTOS: 
35a7				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
35a7 6f				db WORD_SYS_CORE+91             
35a8 c0 35			dw .ADSTORE            
35aa 03				db 2 + 1 
35ab .. 00			db "1-",0              
35ae				endm 
# End of macro CWHEAD
35ae			; | 1- ( u -- u )  Decrement value on TOS | DONE 
35ae			 
35ae					FORTH_DSP_VALUEHL 
35ae cd 6c 21			call macro_dsp_valuehl 
35b1				endm 
# End of macro FORTH_DSP_VALUEHL
35b1 e5					push hl 
35b2			 
35b2					FORTH_DSP_POP 
35b2 cd 24 22			call macro_forth_dsp_pop 
35b5				endm 
# End of macro FORTH_DSP_POP
35b5 e1					pop hl 
35b6			 
35b6 2b					dec hl 
35b7 cd 70 1f				call forth_push_numhl 
35ba					 
35ba					NEXTW 
35ba cd a7 fd			call parse_vector 
35bd c3 53 23			jp macro_next 
35c0				endm 
# End of macro NEXTW
35c0			.ADSTORE: 
35c0				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
35c0 6f				db WORD_SYS_CORE+91             
35c1 d9 35			dw .ADWSTORE            
35c3 04				db 3 + 1 
35c4 .. 00			db "1+!",0              
35c8				endm 
# End of macro CWHEAD
35c8			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
35c8			 
35c8					FORTH_DSP_VALUEHL 
35c8 cd 6c 21			call macro_dsp_valuehl 
35cb				endm 
# End of macro FORTH_DSP_VALUEHL
35cb e5					push hl 
35cc			 
35cc					FORTH_DSP_POP 
35cc cd 24 22			call macro_forth_dsp_pop 
35cf				endm 
# End of macro FORTH_DSP_POP
35cf e1					pop hl 
35d0			 
35d0 7e					ld a, (hl) 
35d1 3c					inc a 
35d2 77					ld (hl), a 
35d3					 
35d3					NEXTW 
35d3 cd a7 fd			call parse_vector 
35d6 c3 53 23			jp macro_next 
35d9				endm 
# End of macro NEXTW
35d9			.ADWSTORE: 
35d9				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
35d9 6f				db WORD_SYS_CORE+91             
35da fa 35			dw .SBSTORE            
35dc 05				db 4 + 1 
35dd .. 00			db "1+2!",0              
35e2				endm 
# End of macro CWHEAD
35e2			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
35e2			 
35e2					FORTH_DSP_VALUEHL 
35e2 cd 6c 21			call macro_dsp_valuehl 
35e5				endm 
# End of macro FORTH_DSP_VALUEHL
35e5 e5					push hl 
35e6			 
35e6					FORTH_DSP_POP 
35e6 cd 24 22			call macro_forth_dsp_pop 
35e9				endm 
# End of macro FORTH_DSP_POP
35e9 e1					pop hl 
35ea			 
35ea e5					push hl 
35eb			 
35eb cd d9 22				call loadwordinhl 
35ee 23					inc hl 
35ef			 
35ef d1					pop de 
35f0 eb					ex de, hl 
35f1 73					ld (hl), e 
35f2 23					inc hl 
35f3 72					ld (hl), d 
35f4					 
35f4					NEXTW 
35f4 cd a7 fd			call parse_vector 
35f7 c3 53 23			jp macro_next 
35fa				endm 
# End of macro NEXTW
35fa			.SBSTORE: 
35fa				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
35fa 6f				db WORD_SYS_CORE+91             
35fb 13 36			dw .SBWSTORE            
35fd 04				db 3 + 1 
35fe .. 00			db "1-!",0              
3602				endm 
# End of macro CWHEAD
3602			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3602			 
3602					FORTH_DSP_VALUEHL 
3602 cd 6c 21			call macro_dsp_valuehl 
3605				endm 
# End of macro FORTH_DSP_VALUEHL
3605 e5					push hl 
3606			 
3606					FORTH_DSP_POP 
3606 cd 24 22			call macro_forth_dsp_pop 
3609				endm 
# End of macro FORTH_DSP_POP
3609 e1					pop hl 
360a			 
360a 7e					ld a, (hl) 
360b 3d					dec a 
360c 77					ld (hl), a 
360d					 
360d					NEXTW 
360d cd a7 fd			call parse_vector 
3610 c3 53 23			jp macro_next 
3613				endm 
# End of macro NEXTW
3613			.SBWSTORE: 
3613				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3613 6f				db WORD_SYS_CORE+91             
3614 34 36			dw .ENDCORE            
3616 05				db 4 + 1 
3617 .. 00			db "1-2!",0              
361c				endm 
# End of macro CWHEAD
361c			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
361c			 
361c					FORTH_DSP_VALUEHL 
361c cd 6c 21			call macro_dsp_valuehl 
361f				endm 
# End of macro FORTH_DSP_VALUEHL
361f e5					push hl 
3620			 
3620					FORTH_DSP_POP 
3620 cd 24 22			call macro_forth_dsp_pop 
3623				endm 
# End of macro FORTH_DSP_POP
3623 e1					pop hl 
3624			 
3624 e5					push hl 
3625			 
3625 cd d9 22				call loadwordinhl 
3628 2b					dec hl 
3629			 
3629 d1					pop de 
362a eb					ex de, hl 
362b 73					ld (hl), e 
362c 23					inc hl 
362d 72					ld (hl), d 
362e					 
362e					NEXTW 
362e cd a7 fd			call parse_vector 
3631 c3 53 23			jp macro_next 
3634				endm 
# End of macro NEXTW
3634			.ENDCORE: 
3634			 
3634			; eof 
3634			 
3634			 
# End of file forth_words_core.asm
3634			include "forth_words_flow.asm" 
3634			 
3634			; | ## Program Flow Words 
3634			 
3634			.IF: 
3634				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3634 1e				db WORD_SYS_CORE+10             
3635 2f 37			dw .THEN            
3637 03				db 2 + 1 
3638 .. 00			db "IF",0              
363b				endm 
# End of macro CWHEAD
363b			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
363b			; | | Note: currently not supporting ELSE or nested IF 
363b			; 
363b					if DEBUG_FORTH_WORDS_KEY 
363b						DMARK "IF." 
363b f5				push af  
363c 3a 50 36			ld a, (.dmark)  
363f 32 9d fd			ld (debug_mark),a  
3642 3a 51 36			ld a, (.dmark+1)  
3645 32 9e fd			ld (debug_mark+1),a  
3648 3a 52 36			ld a, (.dmark+2)  
364b 32 9f fd			ld (debug_mark+2),a  
364e 18 03			jr .pastdmark  
3650 ..			.dmark: db "IF."  
3653 f1			.pastdmark: pop af  
3654			endm  
# End of macro DMARK
3654						CALLMONITOR 
3654 cd aa fd			call debug_vector  
3657				endm  
# End of macro CALLMONITOR
3657					endif 
3657			; eval TOS 
3657			 
3657				FORTH_DSP_VALUEHL 
3657 cd 6c 21			call macro_dsp_valuehl 
365a				endm 
# End of macro FORTH_DSP_VALUEHL
365a			 
365a			;	push hl 
365a				FORTH_DSP_POP 
365a cd 24 22			call macro_forth_dsp_pop 
365d				endm 
# End of macro FORTH_DSP_POP
365d			;	pop hl 
365d			 
365d					if DEBUG_FORTH_WORDS 
365d						DMARK "IF1" 
365d f5				push af  
365e 3a 72 36			ld a, (.dmark)  
3661 32 9d fd			ld (debug_mark),a  
3664 3a 73 36			ld a, (.dmark+1)  
3667 32 9e fd			ld (debug_mark+1),a  
366a 3a 74 36			ld a, (.dmark+2)  
366d 32 9f fd			ld (debug_mark+2),a  
3670 18 03			jr .pastdmark  
3672 ..			.dmark: db "IF1"  
3675 f1			.pastdmark: pop af  
3676			endm  
# End of macro DMARK
3676						CALLMONITOR 
3676 cd aa fd			call debug_vector  
3679				endm  
# End of macro CALLMONITOR
3679					endif 
3679 b7				or a        ; clear carry flag 
367a 11 00 00			ld de, 0 
367d eb				ex de,hl 
367e ed 52			sbc hl, de 
3680 c2 0d 37			jp nz, .iftrue 
3683			 
3683					if DEBUG_FORTH_WORDS 
3683						DMARK "IF2" 
3683 f5				push af  
3684 3a 98 36			ld a, (.dmark)  
3687 32 9d fd			ld (debug_mark),a  
368a 3a 99 36			ld a, (.dmark+1)  
368d 32 9e fd			ld (debug_mark+1),a  
3690 3a 9a 36			ld a, (.dmark+2)  
3693 32 9f fd			ld (debug_mark+2),a  
3696 18 03			jr .pastdmark  
3698 ..			.dmark: db "IF2"  
369b f1			.pastdmark: pop af  
369c			endm  
# End of macro DMARK
369c						CALLMONITOR 
369c cd aa fd			call debug_vector  
369f				endm  
# End of macro CALLMONITOR
369f					endif 
369f			 
369f			; if not true then skip to THEN 
369f			 
369f				; TODO get tok_ptr 
369f				; TODO consume toks until we get to THEN 
369f			 
369f 2a f4 f3			ld hl, (os_tok_ptr) 
36a2					if DEBUG_FORTH_WORDS 
36a2						DMARK "IF3" 
36a2 f5				push af  
36a3 3a b7 36			ld a, (.dmark)  
36a6 32 9d fd			ld (debug_mark),a  
36a9 3a b8 36			ld a, (.dmark+1)  
36ac 32 9e fd			ld (debug_mark+1),a  
36af 3a b9 36			ld a, (.dmark+2)  
36b2 32 9f fd			ld (debug_mark+2),a  
36b5 18 03			jr .pastdmark  
36b7 ..			.dmark: db "IF3"  
36ba f1			.pastdmark: pop af  
36bb			endm  
# End of macro DMARK
36bb						CALLMONITOR 
36bb cd aa fd			call debug_vector  
36be				endm  
# End of macro CALLMONITOR
36be						 
36be					endif 
36be 11 08 37			ld de, .ifthen 
36c1					if DEBUG_FORTH_WORDS 
36c1						DMARK "IF4" 
36c1 f5				push af  
36c2 3a d6 36			ld a, (.dmark)  
36c5 32 9d fd			ld (debug_mark),a  
36c8 3a d7 36			ld a, (.dmark+1)  
36cb 32 9e fd			ld (debug_mark+1),a  
36ce 3a d8 36			ld a, (.dmark+2)  
36d1 32 9f fd			ld (debug_mark+2),a  
36d4 18 03			jr .pastdmark  
36d6 ..			.dmark: db "IF4"  
36d9 f1			.pastdmark: pop af  
36da			endm  
# End of macro DMARK
36da						CALLMONITOR 
36da cd aa fd			call debug_vector  
36dd				endm  
# End of macro CALLMONITOR
36dd					endif 
36dd cd 50 24			call findnexttok  
36e0			 
36e0					if DEBUG_FORTH_WORDS 
36e0						DMARK "IF5" 
36e0 f5				push af  
36e1 3a f5 36			ld a, (.dmark)  
36e4 32 9d fd			ld (debug_mark),a  
36e7 3a f6 36			ld a, (.dmark+1)  
36ea 32 9e fd			ld (debug_mark+1),a  
36ed 3a f7 36			ld a, (.dmark+2)  
36f0 32 9f fd			ld (debug_mark+2),a  
36f3 18 03			jr .pastdmark  
36f5 ..			.dmark: db "IF5"  
36f8 f1			.pastdmark: pop af  
36f9			endm  
# End of macro DMARK
36f9						CALLMONITOR 
36f9 cd aa fd			call debug_vector  
36fc				endm  
# End of macro CALLMONITOR
36fc					endif 
36fc				; TODO replace below with ; exec using tok_ptr 
36fc 22 f4 f3			ld (os_tok_ptr), hl 
36ff c3 d4 23			jp exec1 
3702				NEXTW 
3702 cd a7 fd			call parse_vector 
3705 c3 53 23			jp macro_next 
3708				endm 
# End of macro NEXTW
3708			 
3708 .. 00		.ifthen:  db "THEN",0 
370d			 
370d			.iftrue:		 
370d				; Exec next words normally 
370d			 
370d				; if true then exec following IF as normal 
370d					if DEBUG_FORTH_WORDS 
370d						DMARK "IFT" 
370d f5				push af  
370e 3a 22 37			ld a, (.dmark)  
3711 32 9d fd			ld (debug_mark),a  
3714 3a 23 37			ld a, (.dmark+1)  
3717 32 9e fd			ld (debug_mark+1),a  
371a 3a 24 37			ld a, (.dmark+2)  
371d 32 9f fd			ld (debug_mark+2),a  
3720 18 03			jr .pastdmark  
3722 ..			.dmark: db "IFT"  
3725 f1			.pastdmark: pop af  
3726			endm  
# End of macro DMARK
3726						CALLMONITOR 
3726 cd aa fd			call debug_vector  
3729				endm  
# End of macro CALLMONITOR
3729					endif 
3729			 
3729					NEXTW 
3729 cd a7 fd			call parse_vector 
372c c3 53 23			jp macro_next 
372f				endm 
# End of macro NEXTW
372f			.THEN: 
372f				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
372f 1f				db WORD_SYS_CORE+11             
3730 5a 37			dw .ELSE            
3732 05				db 4 + 1 
3733 .. 00			db "THEN",0              
3738				endm 
# End of macro CWHEAD
3738			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3738					if DEBUG_FORTH_WORDS_KEY 
3738						DMARK "THN" 
3738 f5				push af  
3739 3a 4d 37			ld a, (.dmark)  
373c 32 9d fd			ld (debug_mark),a  
373f 3a 4e 37			ld a, (.dmark+1)  
3742 32 9e fd			ld (debug_mark+1),a  
3745 3a 4f 37			ld a, (.dmark+2)  
3748 32 9f fd			ld (debug_mark+2),a  
374b 18 03			jr .pastdmark  
374d ..			.dmark: db "THN"  
3750 f1			.pastdmark: pop af  
3751			endm  
# End of macro DMARK
3751						CALLMONITOR 
3751 cd aa fd			call debug_vector  
3754				endm  
# End of macro CALLMONITOR
3754					endif 
3754					NEXTW 
3754 cd a7 fd			call parse_vector 
3757 c3 53 23			jp macro_next 
375a				endm 
# End of macro NEXTW
375a			.ELSE: 
375a				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
375a 20				db WORD_SYS_CORE+12             
375b 85 37			dw .DO            
375d 03				db 2 + 1 
375e .. 00			db "ELSE",0              
3763				endm 
# End of macro CWHEAD
3763			; | ELSE ( -- ) Not supported - does nothing | TODO 
3763			 
3763					if DEBUG_FORTH_WORDS_KEY 
3763						DMARK "ELS" 
3763 f5				push af  
3764 3a 78 37			ld a, (.dmark)  
3767 32 9d fd			ld (debug_mark),a  
376a 3a 79 37			ld a, (.dmark+1)  
376d 32 9e fd			ld (debug_mark+1),a  
3770 3a 7a 37			ld a, (.dmark+2)  
3773 32 9f fd			ld (debug_mark+2),a  
3776 18 03			jr .pastdmark  
3778 ..			.dmark: db "ELS"  
377b f1			.pastdmark: pop af  
377c			endm  
# End of macro DMARK
377c						CALLMONITOR 
377c cd aa fd			call debug_vector  
377f				endm  
# End of macro CALLMONITOR
377f					endif 
377f			 
377f			 
377f					NEXTW 
377f cd a7 fd			call parse_vector 
3782 c3 53 23			jp macro_next 
3785				endm 
# End of macro NEXTW
3785			.DO: 
3785				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3785 21				db WORD_SYS_CORE+13             
3786 af 38			dw .LOOP            
3788 03				db 2 + 1 
3789 .. 00			db "DO",0              
378c				endm 
# End of macro CWHEAD
378c			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
378c			 
378c					if DEBUG_FORTH_WORDS_KEY 
378c						DMARK "DO." 
378c f5				push af  
378d 3a a1 37			ld a, (.dmark)  
3790 32 9d fd			ld (debug_mark),a  
3793 3a a2 37			ld a, (.dmark+1)  
3796 32 9e fd			ld (debug_mark+1),a  
3799 3a a3 37			ld a, (.dmark+2)  
379c 32 9f fd			ld (debug_mark+2),a  
379f 18 03			jr .pastdmark  
37a1 ..			.dmark: db "DO."  
37a4 f1			.pastdmark: pop af  
37a5			endm  
# End of macro DMARK
37a5						CALLMONITOR 
37a5 cd aa fd			call debug_vector  
37a8				endm  
# End of macro CALLMONITOR
37a8					endif 
37a8			;  push pc to rsp stack past the DO 
37a8			 
37a8 2a f4 f3				ld hl, (os_tok_ptr) 
37ab 23					inc hl   ; D 
37ac 23					inc hl  ; O 
37ad 23					inc hl   ; null 
37ae					if DEBUG_FORTH_WORDS 
37ae						DMARK "DO2" 
37ae f5				push af  
37af 3a c3 37			ld a, (.dmark)  
37b2 32 9d fd			ld (debug_mark),a  
37b5 3a c4 37			ld a, (.dmark+1)  
37b8 32 9e fd			ld (debug_mark+1),a  
37bb 3a c5 37			ld a, (.dmark+2)  
37be 32 9f fd			ld (debug_mark+2),a  
37c1 18 03			jr .pastdmark  
37c3 ..			.dmark: db "DO2"  
37c6 f1			.pastdmark: pop af  
37c7			endm  
# End of macro DMARK
37c7						CALLMONITOR 
37c7 cd aa fd			call debug_vector  
37ca				endm  
# End of macro CALLMONITOR
37ca					endif 
37ca					FORTH_RSP_NEXT 
37ca cd 17 1f			call macro_forth_rsp_next 
37cd				endm 
# End of macro FORTH_RSP_NEXT
37cd					if DEBUG_FORTH_WORDS 
37cd						DMARK "DO3" 
37cd f5				push af  
37ce 3a e2 37			ld a, (.dmark)  
37d1 32 9d fd			ld (debug_mark),a  
37d4 3a e3 37			ld a, (.dmark+1)  
37d7 32 9e fd			ld (debug_mark+1),a  
37da 3a e4 37			ld a, (.dmark+2)  
37dd 32 9f fd			ld (debug_mark+2),a  
37e0 18 03			jr .pastdmark  
37e2 ..			.dmark: db "DO3"  
37e5 f1			.pastdmark: pop af  
37e6			endm  
# End of macro DMARK
37e6						CALLMONITOR 
37e6 cd aa fd			call debug_vector  
37e9				endm  
# End of macro CALLMONITOR
37e9					endif 
37e9			 
37e9					;if DEBUG_FORTH_WORDS 
37e9				;		push hl 
37e9			;		endif  
37e9			 
37e9			; get counters from data stack 
37e9			 
37e9			 
37e9					FORTH_DSP_VALUEHL 
37e9 cd 6c 21			call macro_dsp_valuehl 
37ec				endm 
# End of macro FORTH_DSP_VALUEHL
37ec e5					push hl		 ; hl now has starting counter which needs to be tos 
37ed			 
37ed					if DEBUG_FORTH_WORDS 
37ed						DMARK "DO4" 
37ed f5				push af  
37ee 3a 02 38			ld a, (.dmark)  
37f1 32 9d fd			ld (debug_mark),a  
37f4 3a 03 38			ld a, (.dmark+1)  
37f7 32 9e fd			ld (debug_mark+1),a  
37fa 3a 04 38			ld a, (.dmark+2)  
37fd 32 9f fd			ld (debug_mark+2),a  
3800 18 03			jr .pastdmark  
3802 ..			.dmark: db "DO4"  
3805 f1			.pastdmark: pop af  
3806			endm  
# End of macro DMARK
3806						CALLMONITOR 
3806 cd aa fd			call debug_vector  
3809				endm  
# End of macro CALLMONITOR
3809					endif 
3809					FORTH_DSP_POP 
3809 cd 24 22			call macro_forth_dsp_pop 
380c				endm 
# End of macro FORTH_DSP_POP
380c			 
380c					if DEBUG_FORTH_WORDS 
380c						DMARK "DO5" 
380c f5				push af  
380d 3a 21 38			ld a, (.dmark)  
3810 32 9d fd			ld (debug_mark),a  
3813 3a 22 38			ld a, (.dmark+1)  
3816 32 9e fd			ld (debug_mark+1),a  
3819 3a 23 38			ld a, (.dmark+2)  
381c 32 9f fd			ld (debug_mark+2),a  
381f 18 03			jr .pastdmark  
3821 ..			.dmark: db "DO5"  
3824 f1			.pastdmark: pop af  
3825			endm  
# End of macro DMARK
3825						CALLMONITOR 
3825 cd aa fd			call debug_vector  
3828				endm  
# End of macro CALLMONITOR
3828					endif 
3828			 
3828					FORTH_DSP_VALUEHL 
3828 cd 6c 21			call macro_dsp_valuehl 
382b				endm 
# End of macro FORTH_DSP_VALUEHL
382b			;		push hl		 ; hl now has starting limit counter 
382b			 
382b					if DEBUG_FORTH_WORDS 
382b						DMARK "DO6" 
382b f5				push af  
382c 3a 40 38			ld a, (.dmark)  
382f 32 9d fd			ld (debug_mark),a  
3832 3a 41 38			ld a, (.dmark+1)  
3835 32 9e fd			ld (debug_mark+1),a  
3838 3a 42 38			ld a, (.dmark+2)  
383b 32 9f fd			ld (debug_mark+2),a  
383e 18 03			jr .pastdmark  
3840 ..			.dmark: db "DO6"  
3843 f1			.pastdmark: pop af  
3844			endm  
# End of macro DMARK
3844						CALLMONITOR 
3844 cd aa fd			call debug_vector  
3847				endm  
# End of macro CALLMONITOR
3847					endif 
3847					FORTH_DSP_POP 
3847 cd 24 22			call macro_forth_dsp_pop 
384a				endm 
# End of macro FORTH_DSP_POP
384a			 
384a			; put counters on the loop stack 
384a			 
384a			;		pop hl			 ; limit counter 
384a d1					pop de			; start counter 
384b			 
384b					; push limit counter 
384b			 
384b					if DEBUG_FORTH_WORDS 
384b						DMARK "DO7" 
384b f5				push af  
384c 3a 60 38			ld a, (.dmark)  
384f 32 9d fd			ld (debug_mark),a  
3852 3a 61 38			ld a, (.dmark+1)  
3855 32 9e fd			ld (debug_mark+1),a  
3858 3a 62 38			ld a, (.dmark+2)  
385b 32 9f fd			ld (debug_mark+2),a  
385e 18 03			jr .pastdmark  
3860 ..			.dmark: db "DO7"  
3863 f1			.pastdmark: pop af  
3864			endm  
# End of macro DMARK
3864						CALLMONITOR 
3864 cd aa fd			call debug_vector  
3867				endm  
# End of macro CALLMONITOR
3867					endif 
3867					FORTH_LOOP_NEXT 
3867 cd 9d 21			call macro_forth_loop_next 
386a				endm 
# End of macro FORTH_LOOP_NEXT
386a			 
386a					; push start counter 
386a			 
386a eb					ex de, hl 
386b					if DEBUG_FORTH_WORDS 
386b						DMARK "DO7" 
386b f5				push af  
386c 3a 80 38			ld a, (.dmark)  
386f 32 9d fd			ld (debug_mark),a  
3872 3a 81 38			ld a, (.dmark+1)  
3875 32 9e fd			ld (debug_mark+1),a  
3878 3a 82 38			ld a, (.dmark+2)  
387b 32 9f fd			ld (debug_mark+2),a  
387e 18 03			jr .pastdmark  
3880 ..			.dmark: db "DO7"  
3883 f1			.pastdmark: pop af  
3884			endm  
# End of macro DMARK
3884						CALLMONITOR 
3884 cd aa fd			call debug_vector  
3887				endm  
# End of macro CALLMONITOR
3887					endif 
3887					FORTH_LOOP_NEXT 
3887 cd 9d 21			call macro_forth_loop_next 
388a				endm 
# End of macro FORTH_LOOP_NEXT
388a			 
388a			 
388a					; init first round of I counter 
388a			 
388a 22 18 f4				ld (os_current_i), hl 
388d			 
388d					if DEBUG_FORTH_WORDS 
388d						DMARK "DO8" 
388d f5				push af  
388e 3a a2 38			ld a, (.dmark)  
3891 32 9d fd			ld (debug_mark),a  
3894 3a a3 38			ld a, (.dmark+1)  
3897 32 9e fd			ld (debug_mark+1),a  
389a 3a a4 38			ld a, (.dmark+2)  
389d 32 9f fd			ld (debug_mark+2),a  
38a0 18 03			jr .pastdmark  
38a2 ..			.dmark: db "DO8"  
38a5 f1			.pastdmark: pop af  
38a6			endm  
# End of macro DMARK
38a6						CALLMONITOR 
38a6 cd aa fd			call debug_vector  
38a9				endm  
# End of macro CALLMONITOR
38a9					endif 
38a9			 
38a9					NEXTW 
38a9 cd a7 fd			call parse_vector 
38ac c3 53 23			jp macro_next 
38af				endm 
# End of macro NEXTW
38af			.LOOP: 
38af				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
38af 22				db WORD_SYS_CORE+14             
38b0 cd 39			dw .I            
38b2 05				db 4 + 1 
38b3 .. 00			db "LOOP",0              
38b8				endm 
# End of macro CWHEAD
38b8			; | LOOP ( -- ) Increment and test loop counter  | DONE 
38b8			 
38b8				; pop tos as current loop count to hl 
38b8			 
38b8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
38b8			 
38b8				FORTH_LOOP_TOS 
38b8 cd d0 21			call macro_forth_loop_tos 
38bb				endm 
# End of macro FORTH_LOOP_TOS
38bb e5				push hl 
38bc			 
38bc					if DEBUG_FORTH_WORDS_KEY 
38bc						DMARK "LOP" 
38bc f5				push af  
38bd 3a d1 38			ld a, (.dmark)  
38c0 32 9d fd			ld (debug_mark),a  
38c3 3a d2 38			ld a, (.dmark+1)  
38c6 32 9e fd			ld (debug_mark+1),a  
38c9 3a d3 38			ld a, (.dmark+2)  
38cc 32 9f fd			ld (debug_mark+2),a  
38cf 18 03			jr .pastdmark  
38d1 ..			.dmark: db "LOP"  
38d4 f1			.pastdmark: pop af  
38d5			endm  
# End of macro DMARK
38d5						CALLMONITOR 
38d5 cd aa fd			call debug_vector  
38d8				endm  
# End of macro CALLMONITOR
38d8					endif 
38d8				; next item on the stack is the limit. get it 
38d8			 
38d8			 
38d8				FORTH_LOOP_POP 
38d8 cd da 21			call macro_forth_loop_pop 
38db				endm 
# End of macro FORTH_LOOP_POP
38db			 
38db				FORTH_LOOP_TOS 
38db cd d0 21			call macro_forth_loop_tos 
38de				endm 
# End of macro FORTH_LOOP_TOS
38de			 
38de d1				pop de		 ; de = i, hl = limit 
38df			 
38df					if DEBUG_FORTH_WORDS 
38df						DMARK "LP1" 
38df f5				push af  
38e0 3a f4 38			ld a, (.dmark)  
38e3 32 9d fd			ld (debug_mark),a  
38e6 3a f5 38			ld a, (.dmark+1)  
38e9 32 9e fd			ld (debug_mark+1),a  
38ec 3a f6 38			ld a, (.dmark+2)  
38ef 32 9f fd			ld (debug_mark+2),a  
38f2 18 03			jr .pastdmark  
38f4 ..			.dmark: db "LP1"  
38f7 f1			.pastdmark: pop af  
38f8			endm  
# End of macro DMARK
38f8						CALLMONITOR 
38f8 cd aa fd			call debug_vector  
38fb				endm  
# End of macro CALLMONITOR
38fb					endif 
38fb			 
38fb				; go back to previous word 
38fb			 
38fb d5				push de    ; save I for inc later 
38fc			 
38fc			 
38fc				; get limit 
38fc				;  is I at limit? 
38fc			 
38fc			 
38fc					if DEBUG_FORTH_WORDS 
38fc						DMARK "LP1" 
38fc f5				push af  
38fd 3a 11 39			ld a, (.dmark)  
3900 32 9d fd			ld (debug_mark),a  
3903 3a 12 39			ld a, (.dmark+1)  
3906 32 9e fd			ld (debug_mark+1),a  
3909 3a 13 39			ld a, (.dmark+2)  
390c 32 9f fd			ld (debug_mark+2),a  
390f 18 03			jr .pastdmark  
3911 ..			.dmark: db "LP1"  
3914 f1			.pastdmark: pop af  
3915			endm  
# End of macro DMARK
3915						CALLMONITOR 
3915 cd aa fd			call debug_vector  
3918				endm  
# End of macro CALLMONITOR
3918					endif 
3918			 
3918 ed 52			sbc hl, de 
391a			 
391a			 
391a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
391a			 
391a 20 29				jr nz, .loopnotdone 
391c			 
391c e1				pop hl   ; get rid of saved I 
391d				FORTH_LOOP_POP     ; get rid of limit 
391d cd da 21			call macro_forth_loop_pop 
3920				endm 
# End of macro FORTH_LOOP_POP
3920			 
3920				FORTH_RSP_POP     ; get rid of DO ptr 
3920 cd 38 1f			call macro_forth_rsp_pop 
3923				endm 
# End of macro FORTH_RSP_POP
3923			 
3923			if DEBUG_FORTH_WORDS 
3923						DMARK "LP>" 
3923 f5				push af  
3924 3a 38 39			ld a, (.dmark)  
3927 32 9d fd			ld (debug_mark),a  
392a 3a 39 39			ld a, (.dmark+1)  
392d 32 9e fd			ld (debug_mark+1),a  
3930 3a 3a 39			ld a, (.dmark+2)  
3933 32 9f fd			ld (debug_mark+2),a  
3936 18 03			jr .pastdmark  
3938 ..			.dmark: db "LP>"  
393b f1			.pastdmark: pop af  
393c			endm  
# End of macro DMARK
393c				CALLMONITOR 
393c cd aa fd			call debug_vector  
393f				endm  
# End of macro CALLMONITOR
393f			endif 
393f			 
393f					NEXTW 
393f cd a7 fd			call parse_vector 
3942 c3 53 23			jp macro_next 
3945				endm 
# End of macro NEXTW
3945				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3945			 
3945			.loopnotdone: 
3945			 
3945 e1				pop hl    ; get I 
3946 23				inc hl 
3947			 
3947			   	; save new I 
3947			 
3947			 
3947					; set I counter 
3947			 
3947 22 18 f4				ld (os_current_i), hl 
394a			 
394a					if DEBUG_FORTH_WORDS 
394a						DMARK "LPN" 
394a f5				push af  
394b 3a 5f 39			ld a, (.dmark)  
394e 32 9d fd			ld (debug_mark),a  
3951 3a 60 39			ld a, (.dmark+1)  
3954 32 9e fd			ld (debug_mark+1),a  
3957 3a 61 39			ld a, (.dmark+2)  
395a 32 9f fd			ld (debug_mark+2),a  
395d 18 03			jr .pastdmark  
395f ..			.dmark: db "LPN"  
3962 f1			.pastdmark: pop af  
3963			endm  
# End of macro DMARK
3963					CALLMONITOR 
3963 cd aa fd			call debug_vector  
3966				endm  
# End of macro CALLMONITOR
3966					endif 
3966					 
3966				FORTH_LOOP_NEXT 
3966 cd 9d 21			call macro_forth_loop_next 
3969				endm 
# End of macro FORTH_LOOP_NEXT
3969			 
3969			 
3969					if DEBUG_FORTH_WORDS 
3969 eb						ex de,hl 
396a					endif 
396a			 
396a			;	; get DO ptr 
396a			; 
396a					if DEBUG_FORTH_WORDS 
396a						DMARK "LP7" 
396a f5				push af  
396b 3a 7f 39			ld a, (.dmark)  
396e 32 9d fd			ld (debug_mark),a  
3971 3a 80 39			ld a, (.dmark+1)  
3974 32 9e fd			ld (debug_mark+1),a  
3977 3a 81 39			ld a, (.dmark+2)  
397a 32 9f fd			ld (debug_mark+2),a  
397d 18 03			jr .pastdmark  
397f ..			.dmark: db "LP7"  
3982 f1			.pastdmark: pop af  
3983			endm  
# End of macro DMARK
3983					CALLMONITOR 
3983 cd aa fd			call debug_vector  
3986				endm  
# End of macro CALLMONITOR
3986					endif 
3986				FORTH_RSP_TOS 
3986 cd 2e 1f			call macro_forth_rsp_tos 
3989				endm 
# End of macro FORTH_RSP_TOS
3989			 
3989					if DEBUG_FORTH_WORDS 
3989						DMARK "LP8" 
3989 f5				push af  
398a 3a 9e 39			ld a, (.dmark)  
398d 32 9d fd			ld (debug_mark),a  
3990 3a 9f 39			ld a, (.dmark+1)  
3993 32 9e fd			ld (debug_mark+1),a  
3996 3a a0 39			ld a, (.dmark+2)  
3999 32 9f fd			ld (debug_mark+2),a  
399c 18 03			jr .pastdmark  
399e ..			.dmark: db "LP8"  
39a1 f1			.pastdmark: pop af  
39a2			endm  
# End of macro DMARK
39a2					CALLMONITOR 
39a2 cd aa fd			call debug_vector  
39a5				endm  
# End of macro CALLMONITOR
39a5					endif 
39a5				;push hl 
39a5			 
39a5				; not going to DO any more 
39a5				; get rid of the RSP pointer as DO will add it back in 
39a5				;FORTH_RSP_POP 
39a5				;pop hl 
39a5			 
39a5				;ld hl,(cli_ret_sp) 
39a5				;ld e, (hl) 
39a5				;inc hl 
39a5				;ld d, (hl) 
39a5				;ex de,hl 
39a5 22 f4 f3			ld (os_tok_ptr), hl 
39a8					if DEBUG_FORTH_WORDS 
39a8						DMARK "LP<" 
39a8 f5				push af  
39a9 3a bd 39			ld a, (.dmark)  
39ac 32 9d fd			ld (debug_mark),a  
39af 3a be 39			ld a, (.dmark+1)  
39b2 32 9e fd			ld (debug_mark+1),a  
39b5 3a bf 39			ld a, (.dmark+2)  
39b8 32 9f fd			ld (debug_mark+2),a  
39bb 18 03			jr .pastdmark  
39bd ..			.dmark: db "LP<"  
39c0 f1			.pastdmark: pop af  
39c1			endm  
# End of macro DMARK
39c1					CALLMONITOR 
39c1 cd aa fd			call debug_vector  
39c4				endm  
# End of macro CALLMONITOR
39c4				endif 
39c4 c3 d4 23			jp exec1 
39c7			 
39c7					 
39c7			 
39c7			 
39c7					NEXTW 
39c7 cd a7 fd			call parse_vector 
39ca c3 53 23			jp macro_next 
39cd				endm 
# End of macro NEXTW
39cd			.I:  
39cd			 
39cd				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
39cd 5e				db WORD_SYS_CORE+74             
39ce fb 39			dw .DLOOP            
39d0 02				db 1 + 1 
39d1 .. 00			db "I",0              
39d3				endm 
# End of macro CWHEAD
39d3			; | I ( -- ) Current loop counter | DONE 
39d3					if DEBUG_FORTH_WORDS_KEY 
39d3						DMARK "I.." 
39d3 f5				push af  
39d4 3a e8 39			ld a, (.dmark)  
39d7 32 9d fd			ld (debug_mark),a  
39da 3a e9 39			ld a, (.dmark+1)  
39dd 32 9e fd			ld (debug_mark+1),a  
39e0 3a ea 39			ld a, (.dmark+2)  
39e3 32 9f fd			ld (debug_mark+2),a  
39e6 18 03			jr .pastdmark  
39e8 ..			.dmark: db "I.."  
39eb f1			.pastdmark: pop af  
39ec			endm  
# End of macro DMARK
39ec						CALLMONITOR 
39ec cd aa fd			call debug_vector  
39ef				endm  
# End of macro CALLMONITOR
39ef					endif 
39ef			 
39ef 2a 18 f4				ld hl,(os_current_i) 
39f2 cd 70 1f				call forth_push_numhl 
39f5			 
39f5					NEXTW 
39f5 cd a7 fd			call parse_vector 
39f8 c3 53 23			jp macro_next 
39fb				endm 
# End of macro NEXTW
39fb			.DLOOP: 
39fb				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
39fb 5f				db WORD_SYS_CORE+75             
39fc e2 3a			dw .REPEAT            
39fe 06				db 5 + 1 
39ff .. 00			db "-LOOP",0              
3a05				endm 
# End of macro CWHEAD
3a05			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3a05				; pop tos as current loop count to hl 
3a05					if DEBUG_FORTH_WORDS_KEY 
3a05						DMARK "-LP" 
3a05 f5				push af  
3a06 3a 1a 3a			ld a, (.dmark)  
3a09 32 9d fd			ld (debug_mark),a  
3a0c 3a 1b 3a			ld a, (.dmark+1)  
3a0f 32 9e fd			ld (debug_mark+1),a  
3a12 3a 1c 3a			ld a, (.dmark+2)  
3a15 32 9f fd			ld (debug_mark+2),a  
3a18 18 03			jr .pastdmark  
3a1a ..			.dmark: db "-LP"  
3a1d f1			.pastdmark: pop af  
3a1e			endm  
# End of macro DMARK
3a1e						CALLMONITOR 
3a1e cd aa fd			call debug_vector  
3a21				endm  
# End of macro CALLMONITOR
3a21					endif 
3a21			 
3a21				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3a21			 
3a21				FORTH_LOOP_TOS 
3a21 cd d0 21			call macro_forth_loop_tos 
3a24				endm 
# End of macro FORTH_LOOP_TOS
3a24 e5				push hl 
3a25			 
3a25					if DEBUG_FORTH_WORDS 
3a25						DMARK "-LP" 
3a25 f5				push af  
3a26 3a 3a 3a			ld a, (.dmark)  
3a29 32 9d fd			ld (debug_mark),a  
3a2c 3a 3b 3a			ld a, (.dmark+1)  
3a2f 32 9e fd			ld (debug_mark+1),a  
3a32 3a 3c 3a			ld a, (.dmark+2)  
3a35 32 9f fd			ld (debug_mark+2),a  
3a38 18 03			jr .pastdmark  
3a3a ..			.dmark: db "-LP"  
3a3d f1			.pastdmark: pop af  
3a3e			endm  
# End of macro DMARK
3a3e						CALLMONITOR 
3a3e cd aa fd			call debug_vector  
3a41				endm  
# End of macro CALLMONITOR
3a41					endif 
3a41				; next item on the stack is the limit. get it 
3a41			 
3a41			 
3a41				FORTH_LOOP_POP 
3a41 cd da 21			call macro_forth_loop_pop 
3a44				endm 
# End of macro FORTH_LOOP_POP
3a44			 
3a44				FORTH_LOOP_TOS 
3a44 cd d0 21			call macro_forth_loop_tos 
3a47				endm 
# End of macro FORTH_LOOP_TOS
3a47			 
3a47 d1				pop de		 ; de = i, hl = limit 
3a48			 
3a48					if DEBUG_FORTH_WORDS 
3a48						DMARK "-L1" 
3a48 f5				push af  
3a49 3a 5d 3a			ld a, (.dmark)  
3a4c 32 9d fd			ld (debug_mark),a  
3a4f 3a 5e 3a			ld a, (.dmark+1)  
3a52 32 9e fd			ld (debug_mark+1),a  
3a55 3a 5f 3a			ld a, (.dmark+2)  
3a58 32 9f fd			ld (debug_mark+2),a  
3a5b 18 03			jr .pastdmark  
3a5d ..			.dmark: db "-L1"  
3a60 f1			.pastdmark: pop af  
3a61			endm  
# End of macro DMARK
3a61						CALLMONITOR 
3a61 cd aa fd			call debug_vector  
3a64				endm  
# End of macro CALLMONITOR
3a64					endif 
3a64			 
3a64				; go back to previous word 
3a64			 
3a64 d5				push de    ; save I for inc later 
3a65			 
3a65			 
3a65				; get limit 
3a65				;  is I at limit? 
3a65			 
3a65			 
3a65					if DEBUG_FORTH_WORDS 
3a65						DMARK "-L1" 
3a65 f5				push af  
3a66 3a 7a 3a			ld a, (.dmark)  
3a69 32 9d fd			ld (debug_mark),a  
3a6c 3a 7b 3a			ld a, (.dmark+1)  
3a6f 32 9e fd			ld (debug_mark+1),a  
3a72 3a 7c 3a			ld a, (.dmark+2)  
3a75 32 9f fd			ld (debug_mark+2),a  
3a78 18 03			jr .pastdmark  
3a7a ..			.dmark: db "-L1"  
3a7d f1			.pastdmark: pop af  
3a7e			endm  
# End of macro DMARK
3a7e						CALLMONITOR 
3a7e cd aa fd			call debug_vector  
3a81				endm  
# End of macro CALLMONITOR
3a81					endif 
3a81			 
3a81 ed 52			sbc hl, de 
3a83			 
3a83			 
3a83				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3a83			 
3a83 20 29				jr nz, .mloopnotdone 
3a85			 
3a85 e1				pop hl   ; get rid of saved I 
3a86				FORTH_LOOP_POP     ; get rid of limit 
3a86 cd da 21			call macro_forth_loop_pop 
3a89				endm 
# End of macro FORTH_LOOP_POP
3a89			 
3a89				FORTH_RSP_POP     ; get rid of DO ptr 
3a89 cd 38 1f			call macro_forth_rsp_pop 
3a8c				endm 
# End of macro FORTH_RSP_POP
3a8c			 
3a8c			if DEBUG_FORTH_WORDS 
3a8c						DMARK "-L>" 
3a8c f5				push af  
3a8d 3a a1 3a			ld a, (.dmark)  
3a90 32 9d fd			ld (debug_mark),a  
3a93 3a a2 3a			ld a, (.dmark+1)  
3a96 32 9e fd			ld (debug_mark+1),a  
3a99 3a a3 3a			ld a, (.dmark+2)  
3a9c 32 9f fd			ld (debug_mark+2),a  
3a9f 18 03			jr .pastdmark  
3aa1 ..			.dmark: db "-L>"  
3aa4 f1			.pastdmark: pop af  
3aa5			endm  
# End of macro DMARK
3aa5				CALLMONITOR 
3aa5 cd aa fd			call debug_vector  
3aa8				endm  
# End of macro CALLMONITOR
3aa8			endif 
3aa8			 
3aa8					NEXTW 
3aa8 cd a7 fd			call parse_vector 
3aab c3 53 23			jp macro_next 
3aae				endm 
# End of macro NEXTW
3aae				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3aae			 
3aae			.mloopnotdone: 
3aae			 
3aae e1				pop hl    ; get I 
3aaf 2b				dec hl 
3ab0			 
3ab0			   	; save new I 
3ab0			 
3ab0			 
3ab0					; set I counter 
3ab0			 
3ab0 22 18 f4				ld (os_current_i), hl 
3ab3			 
3ab3					 
3ab3				FORTH_LOOP_NEXT 
3ab3 cd 9d 21			call macro_forth_loop_next 
3ab6				endm 
# End of macro FORTH_LOOP_NEXT
3ab6			 
3ab6			 
3ab6					if DEBUG_FORTH_WORDS 
3ab6 eb						ex de,hl 
3ab7					endif 
3ab7			 
3ab7			;	; get DO ptr 
3ab7			; 
3ab7				FORTH_RSP_TOS 
3ab7 cd 2e 1f			call macro_forth_rsp_tos 
3aba				endm 
# End of macro FORTH_RSP_TOS
3aba			 
3aba				;push hl 
3aba			 
3aba				; not going to DO any more 
3aba				; get rid of the RSP pointer as DO will add it back in 
3aba				;FORTH_RSP_POP 
3aba				;pop hl 
3aba			 
3aba			 
3aba 22 f4 f3			ld (os_tok_ptr), hl 
3abd					if DEBUG_FORTH_WORDS 
3abd						DMARK "-L<" 
3abd f5				push af  
3abe 3a d2 3a			ld a, (.dmark)  
3ac1 32 9d fd			ld (debug_mark),a  
3ac4 3a d3 3a			ld a, (.dmark+1)  
3ac7 32 9e fd			ld (debug_mark+1),a  
3aca 3a d4 3a			ld a, (.dmark+2)  
3acd 32 9f fd			ld (debug_mark+2),a  
3ad0 18 03			jr .pastdmark  
3ad2 ..			.dmark: db "-L<"  
3ad5 f1			.pastdmark: pop af  
3ad6			endm  
# End of macro DMARK
3ad6					CALLMONITOR 
3ad6 cd aa fd			call debug_vector  
3ad9				endm  
# End of macro CALLMONITOR
3ad9				endif 
3ad9 c3 d4 23			jp exec1 
3adc			 
3adc					 
3adc			 
3adc			 
3adc			 
3adc				NEXTW 
3adc cd a7 fd			call parse_vector 
3adf c3 53 23			jp macro_next 
3ae2				endm 
# End of macro NEXTW
3ae2			 
3ae2			 
3ae2			 
3ae2			 
3ae2			.REPEAT: 
3ae2				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3ae2 71				db WORD_SYS_CORE+93             
3ae3 38 3b			dw .UNTIL            
3ae5 06				db 5 + 1 
3ae6 .. 00			db "REPEAT",0              
3aed				endm 
# End of macro CWHEAD
3aed			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3aed			;  push pc to rsp stack past the REPEAT 
3aed					if DEBUG_FORTH_WORDS_KEY 
3aed						DMARK "REP" 
3aed f5				push af  
3aee 3a 02 3b			ld a, (.dmark)  
3af1 32 9d fd			ld (debug_mark),a  
3af4 3a 03 3b			ld a, (.dmark+1)  
3af7 32 9e fd			ld (debug_mark+1),a  
3afa 3a 04 3b			ld a, (.dmark+2)  
3afd 32 9f fd			ld (debug_mark+2),a  
3b00 18 03			jr .pastdmark  
3b02 ..			.dmark: db "REP"  
3b05 f1			.pastdmark: pop af  
3b06			endm  
# End of macro DMARK
3b06						CALLMONITOR 
3b06 cd aa fd			call debug_vector  
3b09				endm  
# End of macro CALLMONITOR
3b09					endif 
3b09			 
3b09 2a f4 f3				ld hl, (os_tok_ptr) 
3b0c 23					inc hl   ; R 
3b0d 23					inc hl  ; E 
3b0e 23					inc hl   ; P 
3b0f 23					inc hl   ; E 
3b10 23					inc hl   ; A 
3b11 23					inc hl   ; T 
3b12 23					inc hl   ; zero 
3b13					FORTH_RSP_NEXT 
3b13 cd 17 1f			call macro_forth_rsp_next 
3b16				endm 
# End of macro FORTH_RSP_NEXT
3b16			 
3b16			 
3b16					if DEBUG_FORTH_WORDS 
3b16						DMARK "REP" 
3b16 f5				push af  
3b17 3a 2b 3b			ld a, (.dmark)  
3b1a 32 9d fd			ld (debug_mark),a  
3b1d 3a 2c 3b			ld a, (.dmark+1)  
3b20 32 9e fd			ld (debug_mark+1),a  
3b23 3a 2d 3b			ld a, (.dmark+2)  
3b26 32 9f fd			ld (debug_mark+2),a  
3b29 18 03			jr .pastdmark  
3b2b ..			.dmark: db "REP"  
3b2e f1			.pastdmark: pop af  
3b2f			endm  
# End of macro DMARK
3b2f						;pop bc    ; TODO BUG ?????? what is this for???? 
3b2f						CALLMONITOR 
3b2f cd aa fd			call debug_vector  
3b32				endm  
# End of macro CALLMONITOR
3b32					endif 
3b32			 
3b32					NEXTW 
3b32 cd a7 fd			call parse_vector 
3b35 c3 53 23			jp macro_next 
3b38				endm 
# End of macro NEXTW
3b38			;	       NEXTW 
3b38			 
3b38			.UNTIL: 
3b38				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3b38 72				db WORD_SYS_CORE+94             
3b39 d5 3b			dw .ENDFLOW            
3b3b 06				db 5 + 1 
3b3c .. 00			db "UNTIL",0              
3b42				endm 
# End of macro CWHEAD
3b42			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3b42			 
3b42				; pop tos as check 
3b42			 
3b42				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3b42			 
3b42				FORTH_DSP_VALUEHL 
3b42 cd 6c 21			call macro_dsp_valuehl 
3b45				endm 
# End of macro FORTH_DSP_VALUEHL
3b45			 
3b45					if DEBUG_FORTH_WORDS_KEY 
3b45						DMARK "UNT" 
3b45 f5				push af  
3b46 3a 5a 3b			ld a, (.dmark)  
3b49 32 9d fd			ld (debug_mark),a  
3b4c 3a 5b 3b			ld a, (.dmark+1)  
3b4f 32 9e fd			ld (debug_mark+1),a  
3b52 3a 5c 3b			ld a, (.dmark+2)  
3b55 32 9f fd			ld (debug_mark+2),a  
3b58 18 03			jr .pastdmark  
3b5a ..			.dmark: db "UNT"  
3b5d f1			.pastdmark: pop af  
3b5e			endm  
# End of macro DMARK
3b5e						CALLMONITOR 
3b5e cd aa fd			call debug_vector  
3b61				endm  
# End of macro CALLMONITOR
3b61					endif 
3b61			 
3b61			;	push hl 
3b61				FORTH_DSP_POP 
3b61 cd 24 22			call macro_forth_dsp_pop 
3b64				endm 
# End of macro FORTH_DSP_POP
3b64			 
3b64			;	pop hl 
3b64			 
3b64				; test if true 
3b64			 
3b64 cd d5 0f			call ishlzero 
3b67			;	ld a,l 
3b67			;	add h 
3b67			; 
3b67			;	cp 0 
3b67			 
3b67 20 41			jr nz, .untilnotdone 
3b69			 
3b69					if DEBUG_FORTH_WORDS 
3b69						DMARK "UNf" 
3b69 f5				push af  
3b6a 3a 7e 3b			ld a, (.dmark)  
3b6d 32 9d fd			ld (debug_mark),a  
3b70 3a 7f 3b			ld a, (.dmark+1)  
3b73 32 9e fd			ld (debug_mark+1),a  
3b76 3a 80 3b			ld a, (.dmark+2)  
3b79 32 9f fd			ld (debug_mark+2),a  
3b7c 18 03			jr .pastdmark  
3b7e ..			.dmark: db "UNf"  
3b81 f1			.pastdmark: pop af  
3b82			endm  
# End of macro DMARK
3b82						CALLMONITOR 
3b82 cd aa fd			call debug_vector  
3b85				endm  
# End of macro CALLMONITOR
3b85					endif 
3b85			 
3b85			 
3b85			 
3b85				FORTH_RSP_POP     ; get rid of DO ptr 
3b85 cd 38 1f			call macro_forth_rsp_pop 
3b88				endm 
# End of macro FORTH_RSP_POP
3b88			 
3b88			if DEBUG_FORTH_WORDS 
3b88						DMARK "UN>" 
3b88 f5				push af  
3b89 3a 9d 3b			ld a, (.dmark)  
3b8c 32 9d fd			ld (debug_mark),a  
3b8f 3a 9e 3b			ld a, (.dmark+1)  
3b92 32 9e fd			ld (debug_mark+1),a  
3b95 3a 9f 3b			ld a, (.dmark+2)  
3b98 32 9f fd			ld (debug_mark+2),a  
3b9b 18 03			jr .pastdmark  
3b9d ..			.dmark: db "UN>"  
3ba0 f1			.pastdmark: pop af  
3ba1			endm  
# End of macro DMARK
3ba1				CALLMONITOR 
3ba1 cd aa fd			call debug_vector  
3ba4				endm  
# End of macro CALLMONITOR
3ba4			endif 
3ba4			 
3ba4					NEXTW 
3ba4 cd a7 fd			call parse_vector 
3ba7 c3 53 23			jp macro_next 
3baa				endm 
# End of macro NEXTW
3baa				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3baa			 
3baa			.untilnotdone: 
3baa			 
3baa			 
3baa			;	; get DO ptr 
3baa			; 
3baa				FORTH_RSP_TOS 
3baa cd 2e 1f			call macro_forth_rsp_tos 
3bad				endm 
# End of macro FORTH_RSP_TOS
3bad			 
3bad				;push hl 
3bad			 
3bad				; not going to DO any more 
3bad				; get rid of the RSP pointer as DO will add it back in 
3bad				;FORTH_RSP_POP 
3bad				;pop hl 
3bad			 
3bad			 
3bad 22 f4 f3			ld (os_tok_ptr), hl 
3bb0					if DEBUG_FORTH_WORDS 
3bb0						DMARK "UN<" 
3bb0 f5				push af  
3bb1 3a c5 3b			ld a, (.dmark)  
3bb4 32 9d fd			ld (debug_mark),a  
3bb7 3a c6 3b			ld a, (.dmark+1)  
3bba 32 9e fd			ld (debug_mark+1),a  
3bbd 3a c7 3b			ld a, (.dmark+2)  
3bc0 32 9f fd			ld (debug_mark+2),a  
3bc3 18 03			jr .pastdmark  
3bc5 ..			.dmark: db "UN<"  
3bc8 f1			.pastdmark: pop af  
3bc9			endm  
# End of macro DMARK
3bc9					CALLMONITOR 
3bc9 cd aa fd			call debug_vector  
3bcc				endm  
# End of macro CALLMONITOR
3bcc				endif 
3bcc c3 d4 23			jp exec1 
3bcf			 
3bcf					 
3bcf			 
3bcf			 
3bcf					NEXTW 
3bcf cd a7 fd			call parse_vector 
3bd2 c3 53 23			jp macro_next 
3bd5				endm 
# End of macro NEXTW
3bd5			 
3bd5			 
3bd5			.ENDFLOW: 
3bd5			 
3bd5			; eof 
3bd5			 
# End of file forth_words_flow.asm
3bd5			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3bd5			include "forth_words_logic.asm" 
3bd5			 
3bd5			; | ## Logic Words 
3bd5			 
3bd5			.NOT: 
3bd5				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3bd5 2d				db WORD_SYS_CORE+25             
3bd6 23 3c			dw .IS            
3bd8 04				db 3 + 1 
3bd9 .. 00			db "NOT",0              
3bdd				endm 
# End of macro CWHEAD
3bdd			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3bdd					if DEBUG_FORTH_WORDS_KEY 
3bdd						DMARK "NOT" 
3bdd f5				push af  
3bde 3a f2 3b			ld a, (.dmark)  
3be1 32 9d fd			ld (debug_mark),a  
3be4 3a f3 3b			ld a, (.dmark+1)  
3be7 32 9e fd			ld (debug_mark+1),a  
3bea 3a f4 3b			ld a, (.dmark+2)  
3bed 32 9f fd			ld (debug_mark+2),a  
3bf0 18 03			jr .pastdmark  
3bf2 ..			.dmark: db "NOT"  
3bf5 f1			.pastdmark: pop af  
3bf6			endm  
# End of macro DMARK
3bf6						CALLMONITOR 
3bf6 cd aa fd			call debug_vector  
3bf9				endm  
# End of macro CALLMONITOR
3bf9					endif 
3bf9					FORTH_DSP 
3bf9 cd 32 21			call macro_forth_dsp 
3bfc				endm 
# End of macro FORTH_DSP
3bfc 7e					ld a,(hl)	; get type of value on TOS 
3bfd fe 02				cp DS_TYPE_INUM  
3bff 28 06				jr z, .noti 
3c01					NEXTW 
3c01 cd a7 fd			call parse_vector 
3c04 c3 53 23			jp macro_next 
3c07				endm 
# End of macro NEXTW
3c07			.noti:          FORTH_DSP_VALUEHL 
3c07 cd 6c 21			call macro_dsp_valuehl 
3c0a				endm 
# End of macro FORTH_DSP_VALUEHL
3c0a			;		push hl 
3c0a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c0a cd 24 22			call macro_forth_dsp_pop 
3c0d				endm 
# End of macro FORTH_DSP_POP
3c0d			;		pop hl 
3c0d 3e 00				ld a,0 
3c0f bd					cp l 
3c10 28 04				jr z, .not2t 
3c12 2e 00				ld l, 0 
3c14 18 02				jr .notip 
3c16			 
3c16 2e ff		.not2t:		ld l, 255 
3c18			 
3c18 26 00		.notip:		ld h, 0	 
3c1a			 
3c1a cd 70 1f				call forth_push_numhl 
3c1d					NEXTW 
3c1d cd a7 fd			call parse_vector 
3c20 c3 53 23			jp macro_next 
3c23				endm 
# End of macro NEXTW
3c23			 
3c23			.IS: 
3c23				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
3c23 2d				db WORD_SYS_CORE+25             
3c24 67 3c			dw .LZERO            
3c26 08				db 7 + 1 
3c27 .. 00			db "COMPARE",0              
3c2f				endm 
# End of macro CWHEAD
3c2f			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
3c2f					if DEBUG_FORTH_WORDS_KEY 
3c2f						DMARK "CMP" 
3c2f f5				push af  
3c30 3a 44 3c			ld a, (.dmark)  
3c33 32 9d fd			ld (debug_mark),a  
3c36 3a 45 3c			ld a, (.dmark+1)  
3c39 32 9e fd			ld (debug_mark+1),a  
3c3c 3a 46 3c			ld a, (.dmark+2)  
3c3f 32 9f fd			ld (debug_mark+2),a  
3c42 18 03			jr .pastdmark  
3c44 ..			.dmark: db "CMP"  
3c47 f1			.pastdmark: pop af  
3c48			endm  
# End of macro DMARK
3c48						CALLMONITOR 
3c48 cd aa fd			call debug_vector  
3c4b				endm  
# End of macro CALLMONITOR
3c4b					endif 
3c4b			 
3c4b					FORTH_DSP_VALUEHL 
3c4b cd 6c 21			call macro_dsp_valuehl 
3c4e				endm 
# End of macro FORTH_DSP_VALUEHL
3c4e			 
3c4e e5					push hl 
3c4f			 
3c4f					FORTH_DSP_VALUEM1 
3c4f cd 60 21			call macro_forth_dsp_value_m1 
3c52				endm 
# End of macro FORTH_DSP_VALUEM1
3c52			 
3c52 d1					pop de 
3c53			 
3c53					; got pointers to both. Now check. 
3c53			 
3c53 cd 3c 13				call strcmp 
3c56				 
3c56 26 00				ld h, 0 
3c58 2e 00				ld l, 0 
3c5a 20 02				jr nz, .compnsame 
3c5c 2e 01				ld l, 1	 
3c5e			.compnsame: 
3c5e cd 70 1f				call forth_push_numhl 
3c61			 
3c61					NEXTW 
3c61 cd a7 fd			call parse_vector 
3c64 c3 53 23			jp macro_next 
3c67				endm 
# End of macro NEXTW
3c67			.LZERO: 
3c67				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3c67 2d				db WORD_SYS_CORE+25             
3c68 74 3c			dw .TZERO            
3c6a 03				db 2 + 1 
3c6b .. 00			db "0<",0              
3c6e				endm 
# End of macro CWHEAD
3c6e			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3c6e					NEXTW 
3c6e cd a7 fd			call parse_vector 
3c71 c3 53 23			jp macro_next 
3c74				endm 
# End of macro NEXTW
3c74			.TZERO: 
3c74				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3c74 2e				db WORD_SYS_CORE+26             
3c75 be 3c			dw .LESS            
3c77 03				db 2 + 1 
3c78 .. 00			db "0=",0              
3c7b				endm 
# End of macro CWHEAD
3c7b			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3c7b				; TODO add floating point number detection 
3c7b					;v5 FORTH_DSP_VALUE 
3c7b					if DEBUG_FORTH_WORDS_KEY 
3c7b						DMARK "0=." 
3c7b f5				push af  
3c7c 3a 90 3c			ld a, (.dmark)  
3c7f 32 9d fd			ld (debug_mark),a  
3c82 3a 91 3c			ld a, (.dmark+1)  
3c85 32 9e fd			ld (debug_mark+1),a  
3c88 3a 92 3c			ld a, (.dmark+2)  
3c8b 32 9f fd			ld (debug_mark+2),a  
3c8e 18 03			jr .pastdmark  
3c90 ..			.dmark: db "0=."  
3c93 f1			.pastdmark: pop af  
3c94			endm  
# End of macro DMARK
3c94						CALLMONITOR 
3c94 cd aa fd			call debug_vector  
3c97				endm  
# End of macro CALLMONITOR
3c97					endif 
3c97					FORTH_DSP 
3c97 cd 32 21			call macro_forth_dsp 
3c9a				endm 
# End of macro FORTH_DSP
3c9a 7e					ld a,(hl)	; get type of value on TOS 
3c9b fe 02				cp DS_TYPE_INUM  
3c9d 28 00				jr z, .tz_inum 
3c9f			 
3c9f				if FORTH_ENABLE_FLOATMATH 
3c9f					jr .tz_done 
3c9f			 
3c9f				endif 
3c9f					 
3c9f			 
3c9f			.tz_inum: 
3c9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c9f cd 6c 21			call macro_dsp_valuehl 
3ca2				endm 
# End of macro FORTH_DSP_VALUEHL
3ca2			 
3ca2			;		push hl 
3ca2			 
3ca2					; destroy value TOS 
3ca2			 
3ca2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca2 cd 24 22			call macro_forth_dsp_pop 
3ca5				endm 
# End of macro FORTH_DSP_POP
3ca5			 
3ca5			;		pop hl 
3ca5			 
3ca5 3e 00				ld a,0 
3ca7			 
3ca7 bd					cp l 
3ca8 20 08				jr nz, .tz_notzero 
3caa			 
3caa bc					cp h 
3cab			 
3cab 20 05				jr nz, .tz_notzero 
3cad			 
3cad			 
3cad 21 01 00				ld hl, FORTH_TRUE 
3cb0 18 03				jr .tz_done 
3cb2			 
3cb2 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3cb5			 
3cb5					; push value back onto stack for another op etc 
3cb5			 
3cb5			.tz_done: 
3cb5 cd 70 1f				call forth_push_numhl 
3cb8			 
3cb8					NEXTW 
3cb8 cd a7 fd			call parse_vector 
3cbb c3 53 23			jp macro_next 
3cbe				endm 
# End of macro NEXTW
3cbe			.LESS: 
3cbe				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3cbe 2f				db WORD_SYS_CORE+27             
3cbf 2a 3d			dw .GT            
3cc1 02				db 1 + 1 
3cc2 .. 00			db "<",0              
3cc4				endm 
# End of macro CWHEAD
3cc4			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3cc4				; TODO add floating point number detection 
3cc4					if DEBUG_FORTH_WORDS_KEY 
3cc4						DMARK "LES" 
3cc4 f5				push af  
3cc5 3a d9 3c			ld a, (.dmark)  
3cc8 32 9d fd			ld (debug_mark),a  
3ccb 3a da 3c			ld a, (.dmark+1)  
3cce 32 9e fd			ld (debug_mark+1),a  
3cd1 3a db 3c			ld a, (.dmark+2)  
3cd4 32 9f fd			ld (debug_mark+2),a  
3cd7 18 03			jr .pastdmark  
3cd9 ..			.dmark: db "LES"  
3cdc f1			.pastdmark: pop af  
3cdd			endm  
# End of macro DMARK
3cdd						CALLMONITOR 
3cdd cd aa fd			call debug_vector  
3ce0				endm  
# End of macro CALLMONITOR
3ce0					endif 
3ce0					FORTH_DSP 
3ce0 cd 32 21			call macro_forth_dsp 
3ce3				endm 
# End of macro FORTH_DSP
3ce3					;v5 FORTH_DSP_VALUE 
3ce3 7e					ld a,(hl)	; get type of value on TOS 
3ce4 fe 02				cp DS_TYPE_INUM  
3ce6 28 00				jr z, .less_inum 
3ce8			 
3ce8				if FORTH_ENABLE_FLOATMATH 
3ce8					jr .less_done 
3ce8			 
3ce8				endif 
3ce8					 
3ce8			 
3ce8			.less_inum: 
3ce8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ce8 cd 6c 21			call macro_dsp_valuehl 
3ceb				endm 
# End of macro FORTH_DSP_VALUEHL
3ceb			 
3ceb e5					push hl  ; u2 
3cec			 
3cec					; destroy value TOS 
3cec			 
3cec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cec cd 24 22			call macro_forth_dsp_pop 
3cef				endm 
# End of macro FORTH_DSP_POP
3cef			 
3cef			 
3cef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cef cd 6c 21			call macro_dsp_valuehl 
3cf2				endm 
# End of macro FORTH_DSP_VALUEHL
3cf2			 
3cf2 e5					push hl    ; u1 
3cf3			 
3cf3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cf3 cd 24 22			call macro_forth_dsp_pop 
3cf6				endm 
# End of macro FORTH_DSP_POP
3cf6			 
3cf6			 
3cf6 b7			 or a      ;clear carry flag 
3cf7 01 00 00		 ld bc, FORTH_FALSE 
3cfa e1			  pop hl    ; u1 
3cfb d1			  pop de    ; u2 
3cfc ed 52		  sbc hl,de 
3cfe 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3d00			 
3d00 01 01 00		 ld bc, FORTH_TRUE 
3d03			.lscont:  
3d03 c5					push bc 
3d04 e1					pop hl 
3d05			 
3d05					if DEBUG_FORTH_WORDS 
3d05						DMARK "LT1" 
3d05 f5				push af  
3d06 3a 1a 3d			ld a, (.dmark)  
3d09 32 9d fd			ld (debug_mark),a  
3d0c 3a 1b 3d			ld a, (.dmark+1)  
3d0f 32 9e fd			ld (debug_mark+1),a  
3d12 3a 1c 3d			ld a, (.dmark+2)  
3d15 32 9f fd			ld (debug_mark+2),a  
3d18 18 03			jr .pastdmark  
3d1a ..			.dmark: db "LT1"  
3d1d f1			.pastdmark: pop af  
3d1e			endm  
# End of macro DMARK
3d1e						CALLMONITOR 
3d1e cd aa fd			call debug_vector  
3d21				endm  
# End of macro CALLMONITOR
3d21					endif 
3d21 cd 70 1f				call forth_push_numhl 
3d24			 
3d24					NEXTW 
3d24 cd a7 fd			call parse_vector 
3d27 c3 53 23			jp macro_next 
3d2a				endm 
# End of macro NEXTW
3d2a			.GT: 
3d2a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3d2a 30				db WORD_SYS_CORE+28             
3d2b 96 3d			dw .EQUAL            
3d2d 02				db 1 + 1 
3d2e .. 00			db ">",0              
3d30				endm 
# End of macro CWHEAD
3d30			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3d30				; TODO add floating point number detection 
3d30					if DEBUG_FORTH_WORDS_KEY 
3d30						DMARK "GRT" 
3d30 f5				push af  
3d31 3a 45 3d			ld a, (.dmark)  
3d34 32 9d fd			ld (debug_mark),a  
3d37 3a 46 3d			ld a, (.dmark+1)  
3d3a 32 9e fd			ld (debug_mark+1),a  
3d3d 3a 47 3d			ld a, (.dmark+2)  
3d40 32 9f fd			ld (debug_mark+2),a  
3d43 18 03			jr .pastdmark  
3d45 ..			.dmark: db "GRT"  
3d48 f1			.pastdmark: pop af  
3d49			endm  
# End of macro DMARK
3d49						CALLMONITOR 
3d49 cd aa fd			call debug_vector  
3d4c				endm  
# End of macro CALLMONITOR
3d4c					endif 
3d4c					FORTH_DSP 
3d4c cd 32 21			call macro_forth_dsp 
3d4f				endm 
# End of macro FORTH_DSP
3d4f					;FORTH_DSP_VALUE 
3d4f 7e					ld a,(hl)	; get type of value on TOS 
3d50 fe 02				cp DS_TYPE_INUM  
3d52 28 00				jr z, .gt_inum 
3d54			 
3d54				if FORTH_ENABLE_FLOATMATH 
3d54					jr .gt_done 
3d54			 
3d54				endif 
3d54					 
3d54			 
3d54			.gt_inum: 
3d54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d54 cd 6c 21			call macro_dsp_valuehl 
3d57				endm 
# End of macro FORTH_DSP_VALUEHL
3d57			 
3d57 e5					push hl  ; u2 
3d58			 
3d58					; destroy value TOS 
3d58			 
3d58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d58 cd 24 22			call macro_forth_dsp_pop 
3d5b				endm 
# End of macro FORTH_DSP_POP
3d5b			 
3d5b			 
3d5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d5b cd 6c 21			call macro_dsp_valuehl 
3d5e				endm 
# End of macro FORTH_DSP_VALUEHL
3d5e			 
3d5e e5					push hl    ; u1 
3d5f			 
3d5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d5f cd 24 22			call macro_forth_dsp_pop 
3d62				endm 
# End of macro FORTH_DSP_POP
3d62			 
3d62			 
3d62 b7			 or a      ;clear carry flag 
3d63 01 00 00		 ld bc, FORTH_FALSE 
3d66 e1			  pop hl    ; u1 
3d67 d1			  pop de    ; u2 
3d68 ed 52		  sbc hl,de 
3d6a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3d6c			 
3d6c 01 01 00		 ld bc, FORTH_TRUE 
3d6f			.gtcont:  
3d6f c5					push bc 
3d70 e1					pop hl 
3d71			 
3d71					if DEBUG_FORTH_WORDS 
3d71						DMARK "GT1" 
3d71 f5				push af  
3d72 3a 86 3d			ld a, (.dmark)  
3d75 32 9d fd			ld (debug_mark),a  
3d78 3a 87 3d			ld a, (.dmark+1)  
3d7b 32 9e fd			ld (debug_mark+1),a  
3d7e 3a 88 3d			ld a, (.dmark+2)  
3d81 32 9f fd			ld (debug_mark+2),a  
3d84 18 03			jr .pastdmark  
3d86 ..			.dmark: db "GT1"  
3d89 f1			.pastdmark: pop af  
3d8a			endm  
# End of macro DMARK
3d8a						CALLMONITOR 
3d8a cd aa fd			call debug_vector  
3d8d				endm  
# End of macro CALLMONITOR
3d8d					endif 
3d8d cd 70 1f				call forth_push_numhl 
3d90			 
3d90					NEXTW 
3d90 cd a7 fd			call parse_vector 
3d93 c3 53 23			jp macro_next 
3d96				endm 
# End of macro NEXTW
3d96			.EQUAL: 
3d96				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3d96 31				db WORD_SYS_CORE+29             
3d97 04 3e			dw .ENDLOGIC            
3d99 02				db 1 + 1 
3d9a .. 00			db "=",0              
3d9c				endm 
# End of macro CWHEAD
3d9c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3d9c				; TODO add floating point number detection 
3d9c					if DEBUG_FORTH_WORDS_KEY 
3d9c						DMARK "EQ." 
3d9c f5				push af  
3d9d 3a b1 3d			ld a, (.dmark)  
3da0 32 9d fd			ld (debug_mark),a  
3da3 3a b2 3d			ld a, (.dmark+1)  
3da6 32 9e fd			ld (debug_mark+1),a  
3da9 3a b3 3d			ld a, (.dmark+2)  
3dac 32 9f fd			ld (debug_mark+2),a  
3daf 18 03			jr .pastdmark  
3db1 ..			.dmark: db "EQ."  
3db4 f1			.pastdmark: pop af  
3db5			endm  
# End of macro DMARK
3db5						CALLMONITOR 
3db5 cd aa fd			call debug_vector  
3db8				endm  
# End of macro CALLMONITOR
3db8					endif 
3db8					FORTH_DSP 
3db8 cd 32 21			call macro_forth_dsp 
3dbb				endm 
# End of macro FORTH_DSP
3dbb					;v5 FORTH_DSP_VALUE 
3dbb 7e					ld a,(hl)	; get type of value on TOS 
3dbc fe 02				cp DS_TYPE_INUM  
3dbe 28 00				jr z, .eq_inum 
3dc0			 
3dc0				if FORTH_ENABLE_FLOATMATH 
3dc0					jr .eq_done 
3dc0			 
3dc0				endif 
3dc0					 
3dc0			 
3dc0			.eq_inum: 
3dc0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dc0 cd 6c 21			call macro_dsp_valuehl 
3dc3				endm 
# End of macro FORTH_DSP_VALUEHL
3dc3			 
3dc3 e5					push hl 
3dc4			 
3dc4					; destroy value TOS 
3dc4			 
3dc4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dc4 cd 24 22			call macro_forth_dsp_pop 
3dc7				endm 
# End of macro FORTH_DSP_POP
3dc7			 
3dc7			 
3dc7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dc7 cd 6c 21			call macro_dsp_valuehl 
3dca				endm 
# End of macro FORTH_DSP_VALUEHL
3dca			 
3dca					; one value on hl get other one back 
3dca			 
3dca e5					push hl 
3dcb			 
3dcb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dcb cd 24 22			call macro_forth_dsp_pop 
3dce				endm 
# End of macro FORTH_DSP_POP
3dce			 
3dce 0e 00				ld c, FORTH_FALSE 
3dd0			 
3dd0 e1					pop hl 
3dd1 d1					pop de 
3dd2			 
3dd2 7b					ld a, e 
3dd3 bd					cp l 
3dd4			 
3dd4 20 06				jr nz, .eq_done 
3dd6			 
3dd6 7a					ld a, d 
3dd7 bc					cp h 
3dd8			 
3dd8 20 02				jr nz, .eq_done 
3dda			 
3dda 0e 01				ld c, FORTH_TRUE 
3ddc					 
3ddc			 
3ddc			 
3ddc			.eq_done: 
3ddc			 
3ddc					; TODO push value back onto stack for another op etc 
3ddc			 
3ddc 26 00				ld h, 0 
3dde 69					ld l, c 
3ddf					if DEBUG_FORTH_WORDS 
3ddf						DMARK "EQ1" 
3ddf f5				push af  
3de0 3a f4 3d			ld a, (.dmark)  
3de3 32 9d fd			ld (debug_mark),a  
3de6 3a f5 3d			ld a, (.dmark+1)  
3de9 32 9e fd			ld (debug_mark+1),a  
3dec 3a f6 3d			ld a, (.dmark+2)  
3def 32 9f fd			ld (debug_mark+2),a  
3df2 18 03			jr .pastdmark  
3df4 ..			.dmark: db "EQ1"  
3df7 f1			.pastdmark: pop af  
3df8			endm  
# End of macro DMARK
3df8						CALLMONITOR 
3df8 cd aa fd			call debug_vector  
3dfb				endm  
# End of macro CALLMONITOR
3dfb					endif 
3dfb cd 70 1f				call forth_push_numhl 
3dfe			 
3dfe					NEXTW 
3dfe cd a7 fd			call parse_vector 
3e01 c3 53 23			jp macro_next 
3e04				endm 
# End of macro NEXTW
3e04			 
3e04			 
3e04			.ENDLOGIC: 
3e04			; eof 
3e04			 
3e04			 
# End of file forth_words_logic.asm
3e04			include "forth_words_maths.asm" 
3e04			 
3e04			; | ## Maths Words 
3e04			 
3e04			.PLUS:	 
3e04				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3e04 15				db WORD_SYS_CORE+1             
3e05 68 3e			dw .NEG            
3e07 02				db 1 + 1 
3e08 .. 00			db "+",0              
3e0a				endm 
# End of macro CWHEAD
3e0a			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3e0a					if DEBUG_FORTH_WORDS_KEY 
3e0a						DMARK "PLU" 
3e0a f5				push af  
3e0b 3a 1f 3e			ld a, (.dmark)  
3e0e 32 9d fd			ld (debug_mark),a  
3e11 3a 20 3e			ld a, (.dmark+1)  
3e14 32 9e fd			ld (debug_mark+1),a  
3e17 3a 21 3e			ld a, (.dmark+2)  
3e1a 32 9f fd			ld (debug_mark+2),a  
3e1d 18 03			jr .pastdmark  
3e1f ..			.dmark: db "PLU"  
3e22 f1			.pastdmark: pop af  
3e23			endm  
# End of macro DMARK
3e23						CALLMONITOR 
3e23 cd aa fd			call debug_vector  
3e26				endm  
# End of macro CALLMONITOR
3e26					endif 
3e26					; add top two values and push back result 
3e26			 
3e26					;for v5 FORTH_DSP_VALUE 
3e26					FORTH_DSP 
3e26 cd 32 21			call macro_forth_dsp 
3e29				endm 
# End of macro FORTH_DSP
3e29 7e					ld a,(hl)	; get type of value on TOS 
3e2a fe 02				cp DS_TYPE_INUM  
3e2c 28 06				jr z, .dot_inum 
3e2e			 
3e2e					NEXTW 
3e2e cd a7 fd			call parse_vector 
3e31 c3 53 23			jp macro_next 
3e34				endm 
# End of macro NEXTW
3e34			 
3e34			; float maths 
3e34			 
3e34				if FORTH_ENABLE_FLOATMATH 
3e34						inc hl      ; now at start of numeric as string 
3e34			 
3e34					if DEBUG_FORTH_MATHS 
3e34						DMARK "ADD" 
3e34				CALLMONITOR 
3e34					endif 
3e34			 
3e34					;ld ix, hl 
3e34					call CON 
3e34			 
3e34			 
3e34					push hl 
3e34					 
3e34					 
3e34			 
3e34						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3e34			 
3e34					; get next number 
3e34			 
3e34						FORTH_DSP_VALUE 
3e34			 
3e34						inc hl      ; now at start of numeric as string 
3e34			 
3e34					;ld ix, hl 
3e34					call CON 
3e34			 
3e34					push hl 
3e34			 
3e34			 
3e34						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e34			 
3e34						; TODO do add 
3e34			 
3e34						call IADD 
3e34			 
3e34						; TODO get result back as ascii 
3e34			 
3e34						; TODO push result  
3e34			 
3e34			 
3e34			 
3e34						jr .dot_done 
3e34				endif 
3e34			 
3e34			.dot_inum: 
3e34			 
3e34			 
3e34					if DEBUG_FORTH_DOT 
3e34						DMARK "+IT" 
3e34 f5				push af  
3e35 3a 49 3e			ld a, (.dmark)  
3e38 32 9d fd			ld (debug_mark),a  
3e3b 3a 4a 3e			ld a, (.dmark+1)  
3e3e 32 9e fd			ld (debug_mark+1),a  
3e41 3a 4b 3e			ld a, (.dmark+2)  
3e44 32 9f fd			ld (debug_mark+2),a  
3e47 18 03			jr .pastdmark  
3e49 ..			.dmark: db "+IT"  
3e4c f1			.pastdmark: pop af  
3e4d			endm  
# End of macro DMARK
3e4d				CALLMONITOR 
3e4d cd aa fd			call debug_vector  
3e50				endm  
# End of macro CALLMONITOR
3e50					endif 
3e50			 
3e50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e50 cd 6c 21			call macro_dsp_valuehl 
3e53				endm 
# End of macro FORTH_DSP_VALUEHL
3e53			 
3e53				; TODO add floating point number detection 
3e53			 
3e53 e5					push hl 
3e54			 
3e54					; destroy value TOS 
3e54			 
3e54					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e54 cd 24 22			call macro_forth_dsp_pop 
3e57				endm 
# End of macro FORTH_DSP_POP
3e57			 
3e57			 
3e57					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e57 cd 6c 21			call macro_dsp_valuehl 
3e5a				endm 
# End of macro FORTH_DSP_VALUEHL
3e5a			 
3e5a					; one value on hl get other one back 
3e5a			 
3e5a d1					pop de 
3e5b			 
3e5b					; do the add 
3e5b			 
3e5b 19					add hl,de 
3e5c			 
3e5c					; save it 
3e5c			 
3e5c			;		push hl	 
3e5c			 
3e5c					; 
3e5c			 
3e5c					; destroy value TOS 
3e5c			 
3e5c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e5c cd 24 22			call macro_forth_dsp_pop 
3e5f				endm 
# End of macro FORTH_DSP_POP
3e5f			 
3e5f					; TODO push value back onto stack for another op etc 
3e5f			 
3e5f			;		pop hl 
3e5f			 
3e5f			.dot_done: 
3e5f cd 70 1f				call forth_push_numhl 
3e62			 
3e62					NEXTW 
3e62 cd a7 fd			call parse_vector 
3e65 c3 53 23			jp macro_next 
3e68				endm 
# End of macro NEXTW
3e68			.NEG: 
3e68			 
3e68				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3e68 17				db WORD_SYS_CORE+3             
3e69 b1 3e			dw .DIV            
3e6b 02				db 1 + 1 
3e6c .. 00			db "-",0              
3e6e				endm 
# End of macro CWHEAD
3e6e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3e6e					if DEBUG_FORTH_WORDS_KEY 
3e6e						DMARK "SUB" 
3e6e f5				push af  
3e6f 3a 83 3e			ld a, (.dmark)  
3e72 32 9d fd			ld (debug_mark),a  
3e75 3a 84 3e			ld a, (.dmark+1)  
3e78 32 9e fd			ld (debug_mark+1),a  
3e7b 3a 85 3e			ld a, (.dmark+2)  
3e7e 32 9f fd			ld (debug_mark+2),a  
3e81 18 03			jr .pastdmark  
3e83 ..			.dmark: db "SUB"  
3e86 f1			.pastdmark: pop af  
3e87			endm  
# End of macro DMARK
3e87						CALLMONITOR 
3e87 cd aa fd			call debug_vector  
3e8a				endm  
# End of macro CALLMONITOR
3e8a					endif 
3e8a			 
3e8a			 
3e8a				; TODO add floating point number detection 
3e8a					; v5 FORTH_DSP_VALUE 
3e8a					FORTH_DSP 
3e8a cd 32 21			call macro_forth_dsp 
3e8d				endm 
# End of macro FORTH_DSP
3e8d 7e					ld a,(hl)	; get type of value on TOS 
3e8e fe 02				cp DS_TYPE_INUM  
3e90 28 06				jr z, .neg_inum 
3e92			 
3e92					NEXTW 
3e92 cd a7 fd			call parse_vector 
3e95 c3 53 23			jp macro_next 
3e98				endm 
# End of macro NEXTW
3e98			 
3e98			; float maths 
3e98			 
3e98				if FORTH_ENABLE_FLOATMATH 
3e98					jr .neg_done 
3e98			 
3e98				endif 
3e98					 
3e98			 
3e98			.neg_inum: 
3e98					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e98 cd 6c 21			call macro_dsp_valuehl 
3e9b				endm 
# End of macro FORTH_DSP_VALUEHL
3e9b			 
3e9b e5					push hl 
3e9c			 
3e9c					; destroy value TOS 
3e9c			 
3e9c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9c cd 24 22			call macro_forth_dsp_pop 
3e9f				endm 
# End of macro FORTH_DSP_POP
3e9f			 
3e9f			 
3e9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e9f cd 6c 21			call macro_dsp_valuehl 
3ea2				endm 
# End of macro FORTH_DSP_VALUEHL
3ea2			 
3ea2					; one value on hl get other one back 
3ea2			 
3ea2 d1					pop de 
3ea3			 
3ea3					; do the sub 
3ea3			;		ex de, hl 
3ea3			 
3ea3 ed 52				sbc hl,de 
3ea5			 
3ea5					; save it 
3ea5			 
3ea5			;		push hl	 
3ea5			 
3ea5					; 
3ea5			 
3ea5					; destroy value TOS 
3ea5			 
3ea5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea5 cd 24 22			call macro_forth_dsp_pop 
3ea8				endm 
# End of macro FORTH_DSP_POP
3ea8			 
3ea8					; TODO push value back onto stack for another op etc 
3ea8			 
3ea8			;		pop hl 
3ea8			 
3ea8 cd 70 1f				call forth_push_numhl 
3eab			.neg_done: 
3eab			 
3eab					NEXTW 
3eab cd a7 fd			call parse_vector 
3eae c3 53 23			jp macro_next 
3eb1				endm 
# End of macro NEXTW
3eb1			.DIV: 
3eb1				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3eb1 18				db WORD_SYS_CORE+4             
3eb2 04 3f			dw .MUL            
3eb4 02				db 1 + 1 
3eb5 .. 00			db "/",0              
3eb7				endm 
# End of macro CWHEAD
3eb7			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3eb7					if DEBUG_FORTH_WORDS_KEY 
3eb7						DMARK "DIV" 
3eb7 f5				push af  
3eb8 3a cc 3e			ld a, (.dmark)  
3ebb 32 9d fd			ld (debug_mark),a  
3ebe 3a cd 3e			ld a, (.dmark+1)  
3ec1 32 9e fd			ld (debug_mark+1),a  
3ec4 3a ce 3e			ld a, (.dmark+2)  
3ec7 32 9f fd			ld (debug_mark+2),a  
3eca 18 03			jr .pastdmark  
3ecc ..			.dmark: db "DIV"  
3ecf f1			.pastdmark: pop af  
3ed0			endm  
# End of macro DMARK
3ed0						CALLMONITOR 
3ed0 cd aa fd			call debug_vector  
3ed3				endm  
# End of macro CALLMONITOR
3ed3					endif 
3ed3				; TODO add floating point number detection 
3ed3					; v5 FORTH_DSP_VALUE 
3ed3					FORTH_DSP 
3ed3 cd 32 21			call macro_forth_dsp 
3ed6				endm 
# End of macro FORTH_DSP
3ed6 7e					ld a,(hl)	; get type of value on TOS 
3ed7 fe 02				cp DS_TYPE_INUM  
3ed9 28 06				jr z, .div_inum 
3edb			 
3edb				if FORTH_ENABLE_FLOATMATH 
3edb					jr .div_done 
3edb			 
3edb				endif 
3edb					NEXTW 
3edb cd a7 fd			call parse_vector 
3ede c3 53 23			jp macro_next 
3ee1				endm 
# End of macro NEXTW
3ee1			.div_inum: 
3ee1			 
3ee1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee1 cd 6c 21			call macro_dsp_valuehl 
3ee4				endm 
# End of macro FORTH_DSP_VALUEHL
3ee4			 
3ee4 e5					push hl    ; to go to bc 
3ee5			 
3ee5					; destroy value TOS 
3ee5			 
3ee5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee5 cd 24 22			call macro_forth_dsp_pop 
3ee8				endm 
# End of macro FORTH_DSP_POP
3ee8			 
3ee8			 
3ee8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee8 cd 6c 21			call macro_dsp_valuehl 
3eeb				endm 
# End of macro FORTH_DSP_VALUEHL
3eeb			 
3eeb					; hl to go to de 
3eeb			 
3eeb e5					push hl 
3eec			 
3eec c1					pop bc 
3eed d1					pop de		 
3eee			 
3eee			 
3eee					if DEBUG_FORTH_MATHS 
3eee						DMARK "DIV" 
3eee				CALLMONITOR 
3eee					endif 
3eee					; one value on hl but move to a get other one back 
3eee			 
3eee			        
3eee cd 09 0f			call Div16 
3ef1			 
3ef1			;	push af	 
3ef1 e5				push hl 
3ef2 c5				push bc 
3ef3			 
3ef3					if DEBUG_FORTH_MATHS 
3ef3						DMARK "DI1" 
3ef3				CALLMONITOR 
3ef3					endif 
3ef3			 
3ef3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef3 cd 24 22			call macro_forth_dsp_pop 
3ef6				endm 
# End of macro FORTH_DSP_POP
3ef6			 
3ef6			 
3ef6			 
3ef6 e1					pop hl    ; result 
3ef7			 
3ef7 cd 70 1f				call forth_push_numhl 
3efa			 
3efa e1					pop hl    ; reminder 
3efb			;		ld h,0 
3efb			;		ld l,d 
3efb			 
3efb cd 70 1f				call forth_push_numhl 
3efe			.div_done: 
3efe					NEXTW 
3efe cd a7 fd			call parse_vector 
3f01 c3 53 23			jp macro_next 
3f04				endm 
# End of macro NEXTW
3f04			.MUL: 
3f04				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3f04 19				db WORD_SYS_CORE+5             
3f05 4f 3f			dw .MIN            
3f07 02				db 1 + 1 
3f08 .. 00			db "*",0              
3f0a				endm 
# End of macro CWHEAD
3f0a			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3f0a				; TODO add floating point number detection 
3f0a					if DEBUG_FORTH_WORDS_KEY 
3f0a						DMARK "MUL" 
3f0a f5				push af  
3f0b 3a 1f 3f			ld a, (.dmark)  
3f0e 32 9d fd			ld (debug_mark),a  
3f11 3a 20 3f			ld a, (.dmark+1)  
3f14 32 9e fd			ld (debug_mark+1),a  
3f17 3a 21 3f			ld a, (.dmark+2)  
3f1a 32 9f fd			ld (debug_mark+2),a  
3f1d 18 03			jr .pastdmark  
3f1f ..			.dmark: db "MUL"  
3f22 f1			.pastdmark: pop af  
3f23			endm  
# End of macro DMARK
3f23						CALLMONITOR 
3f23 cd aa fd			call debug_vector  
3f26				endm  
# End of macro CALLMONITOR
3f26					endif 
3f26					FORTH_DSP 
3f26 cd 32 21			call macro_forth_dsp 
3f29				endm 
# End of macro FORTH_DSP
3f29					; v5 FORTH_DSP_VALUE 
3f29 7e					ld a,(hl)	; get type of value on TOS 
3f2a fe 02				cp DS_TYPE_INUM  
3f2c 28 06				jr z, .mul_inum 
3f2e			 
3f2e				if FORTH_ENABLE_FLOATMATH 
3f2e					jr .mul_done 
3f2e			 
3f2e				endif 
3f2e			 
3f2e					NEXTW 
3f2e cd a7 fd			call parse_vector 
3f31 c3 53 23			jp macro_next 
3f34				endm 
# End of macro NEXTW
3f34			.mul_inum:	 
3f34			 
3f34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f34 cd 6c 21			call macro_dsp_valuehl 
3f37				endm 
# End of macro FORTH_DSP_VALUEHL
3f37			 
3f37 e5					push hl 
3f38			 
3f38					; destroy value TOS 
3f38			 
3f38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f38 cd 24 22			call macro_forth_dsp_pop 
3f3b				endm 
# End of macro FORTH_DSP_POP
3f3b			 
3f3b			 
3f3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f3b cd 6c 21			call macro_dsp_valuehl 
3f3e				endm 
# End of macro FORTH_DSP_VALUEHL
3f3e			 
3f3e					; one value on hl but move to a get other one back 
3f3e			 
3f3e 7d					ld a, l 
3f3f			 
3f3f d1					pop de 
3f40			 
3f40					; do the mull 
3f40			;		ex de, hl 
3f40			 
3f40 cd 2f 0f				call Mult16 
3f43					; save it 
3f43			 
3f43			;		push hl	 
3f43			 
3f43					; 
3f43			 
3f43					; destroy value TOS 
3f43			 
3f43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f43 cd 24 22			call macro_forth_dsp_pop 
3f46				endm 
# End of macro FORTH_DSP_POP
3f46			 
3f46					; TODO push value back onto stack for another op etc 
3f46			 
3f46			;		pop hl 
3f46			 
3f46 cd 70 1f				call forth_push_numhl 
3f49			 
3f49			.mul_done: 
3f49					NEXTW 
3f49 cd a7 fd			call parse_vector 
3f4c c3 53 23			jp macro_next 
3f4f				endm 
# End of macro NEXTW
3f4f			 
3f4f			 
3f4f			 
3f4f			 
3f4f			.MIN: 
3f4f				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3f4f 49				db WORD_SYS_CORE+53             
3f50 d6 3f			dw .MAX            
3f52 04				db 3 + 1 
3f53 .. 00			db "MIN",0              
3f57				endm 
# End of macro CWHEAD
3f57			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3f57					if DEBUG_FORTH_WORDS_KEY 
3f57						DMARK "MIN" 
3f57 f5				push af  
3f58 3a 6c 3f			ld a, (.dmark)  
3f5b 32 9d fd			ld (debug_mark),a  
3f5e 3a 6d 3f			ld a, (.dmark+1)  
3f61 32 9e fd			ld (debug_mark+1),a  
3f64 3a 6e 3f			ld a, (.dmark+2)  
3f67 32 9f fd			ld (debug_mark+2),a  
3f6a 18 03			jr .pastdmark  
3f6c ..			.dmark: db "MIN"  
3f6f f1			.pastdmark: pop af  
3f70			endm  
# End of macro DMARK
3f70						CALLMONITOR 
3f70 cd aa fd			call debug_vector  
3f73				endm  
# End of macro CALLMONITOR
3f73					endif 
3f73					; get u2 
3f73			 
3f73					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f73 cd 6c 21			call macro_dsp_valuehl 
3f76				endm 
# End of macro FORTH_DSP_VALUEHL
3f76			 
3f76 e5					push hl   ; u2 
3f77			 
3f77					; destroy value TOS 
3f77			 
3f77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f77 cd 24 22			call macro_forth_dsp_pop 
3f7a				endm 
# End of macro FORTH_DSP_POP
3f7a			 
3f7a					; get u1 
3f7a			 
3f7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f7a cd 6c 21			call macro_dsp_valuehl 
3f7d				endm 
# End of macro FORTH_DSP_VALUEHL
3f7d			 
3f7d e5					push hl  ; u1 
3f7e			 
3f7e					; destroy value TOS 
3f7e			 
3f7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f7e cd 24 22			call macro_forth_dsp_pop 
3f81				endm 
# End of macro FORTH_DSP_POP
3f81			 
3f81 b7			 or a      ;clear carry flag 
3f82 e1			  pop hl    ; u1 
3f83 d1			  pop de    ; u2 
3f84 e5				push hl   ; saved in case hl is lowest 
3f85 ed 52		  sbc hl,de 
3f87 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3f89			 
3f89 e1				pop hl 
3f8a					if DEBUG_FORTH_WORDS 
3f8a						DMARK "MIN" 
3f8a f5				push af  
3f8b 3a 9f 3f			ld a, (.dmark)  
3f8e 32 9d fd			ld (debug_mark),a  
3f91 3a a0 3f			ld a, (.dmark+1)  
3f94 32 9e fd			ld (debug_mark+1),a  
3f97 3a a1 3f			ld a, (.dmark+2)  
3f9a 32 9f fd			ld (debug_mark+2),a  
3f9d 18 03			jr .pastdmark  
3f9f ..			.dmark: db "MIN"  
3fa2 f1			.pastdmark: pop af  
3fa3			endm  
# End of macro DMARK
3fa3						CALLMONITOR 
3fa3 cd aa fd			call debug_vector  
3fa6				endm  
# End of macro CALLMONITOR
3fa6					endif 
3fa6 cd 70 1f				call forth_push_numhl 
3fa9			 
3fa9				       NEXTW 
3fa9 cd a7 fd			call parse_vector 
3fac c3 53 23			jp macro_next 
3faf				endm 
# End of macro NEXTW
3faf			 
3faf			.mincont:  
3faf c1				pop bc   ; tidy up 
3fb0 eb				ex de , hl  
3fb1					if DEBUG_FORTH_WORDS 
3fb1						DMARK "MI1" 
3fb1 f5				push af  
3fb2 3a c6 3f			ld a, (.dmark)  
3fb5 32 9d fd			ld (debug_mark),a  
3fb8 3a c7 3f			ld a, (.dmark+1)  
3fbb 32 9e fd			ld (debug_mark+1),a  
3fbe 3a c8 3f			ld a, (.dmark+2)  
3fc1 32 9f fd			ld (debug_mark+2),a  
3fc4 18 03			jr .pastdmark  
3fc6 ..			.dmark: db "MI1"  
3fc9 f1			.pastdmark: pop af  
3fca			endm  
# End of macro DMARK
3fca						CALLMONITOR 
3fca cd aa fd			call debug_vector  
3fcd				endm  
# End of macro CALLMONITOR
3fcd					endif 
3fcd cd 70 1f				call forth_push_numhl 
3fd0			 
3fd0				       NEXTW 
3fd0 cd a7 fd			call parse_vector 
3fd3 c3 53 23			jp macro_next 
3fd6				endm 
# End of macro NEXTW
3fd6			.MAX: 
3fd6				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3fd6 4a				db WORD_SYS_CORE+54             
3fd7 5d 40			dw .RND16            
3fd9 04				db 3 + 1 
3fda .. 00			db "MAX",0              
3fde				endm 
# End of macro CWHEAD
3fde			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3fde					if DEBUG_FORTH_WORDS_KEY 
3fde						DMARK "MAX" 
3fde f5				push af  
3fdf 3a f3 3f			ld a, (.dmark)  
3fe2 32 9d fd			ld (debug_mark),a  
3fe5 3a f4 3f			ld a, (.dmark+1)  
3fe8 32 9e fd			ld (debug_mark+1),a  
3feb 3a f5 3f			ld a, (.dmark+2)  
3fee 32 9f fd			ld (debug_mark+2),a  
3ff1 18 03			jr .pastdmark  
3ff3 ..			.dmark: db "MAX"  
3ff6 f1			.pastdmark: pop af  
3ff7			endm  
# End of macro DMARK
3ff7						CALLMONITOR 
3ff7 cd aa fd			call debug_vector  
3ffa				endm  
# End of macro CALLMONITOR
3ffa					endif 
3ffa					; get u2 
3ffa			 
3ffa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ffa cd 6c 21			call macro_dsp_valuehl 
3ffd				endm 
# End of macro FORTH_DSP_VALUEHL
3ffd			 
3ffd e5					push hl   ; u2 
3ffe			 
3ffe					; destroy value TOS 
3ffe			 
3ffe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ffe cd 24 22			call macro_forth_dsp_pop 
4001				endm 
# End of macro FORTH_DSP_POP
4001			 
4001					; get u1 
4001			 
4001					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4001 cd 6c 21			call macro_dsp_valuehl 
4004				endm 
# End of macro FORTH_DSP_VALUEHL
4004			 
4004 e5					push hl  ; u1 
4005			 
4005					; destroy value TOS 
4005			 
4005					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4005 cd 24 22			call macro_forth_dsp_pop 
4008				endm 
# End of macro FORTH_DSP_POP
4008			 
4008 b7			 or a      ;clear carry flag 
4009 e1			  pop hl    ; u1 
400a d1			  pop de    ; u2 
400b e5				push hl   ; saved in case hl is lowest 
400c ed 52		  sbc hl,de 
400e 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
4010			 
4010 e1				pop hl 
4011					if DEBUG_FORTH_WORDS 
4011						DMARK "MAX" 
4011 f5				push af  
4012 3a 26 40			ld a, (.dmark)  
4015 32 9d fd			ld (debug_mark),a  
4018 3a 27 40			ld a, (.dmark+1)  
401b 32 9e fd			ld (debug_mark+1),a  
401e 3a 28 40			ld a, (.dmark+2)  
4021 32 9f fd			ld (debug_mark+2),a  
4024 18 03			jr .pastdmark  
4026 ..			.dmark: db "MAX"  
4029 f1			.pastdmark: pop af  
402a			endm  
# End of macro DMARK
402a						CALLMONITOR 
402a cd aa fd			call debug_vector  
402d				endm  
# End of macro CALLMONITOR
402d					endif 
402d cd 70 1f				call forth_push_numhl 
4030			 
4030				       NEXTW 
4030 cd a7 fd			call parse_vector 
4033 c3 53 23			jp macro_next 
4036				endm 
# End of macro NEXTW
4036			 
4036			.maxcont:  
4036 c1				pop bc   ; tidy up 
4037 eb				ex de , hl  
4038					if DEBUG_FORTH_WORDS 
4038						DMARK "MA1" 
4038 f5				push af  
4039 3a 4d 40			ld a, (.dmark)  
403c 32 9d fd			ld (debug_mark),a  
403f 3a 4e 40			ld a, (.dmark+1)  
4042 32 9e fd			ld (debug_mark+1),a  
4045 3a 4f 40			ld a, (.dmark+2)  
4048 32 9f fd			ld (debug_mark+2),a  
404b 18 03			jr .pastdmark  
404d ..			.dmark: db "MA1"  
4050 f1			.pastdmark: pop af  
4051			endm  
# End of macro DMARK
4051						CALLMONITOR 
4051 cd aa fd			call debug_vector  
4054				endm  
# End of macro CALLMONITOR
4054					endif 
4054 cd 70 1f				call forth_push_numhl 
4057				       NEXTW 
4057 cd a7 fd			call parse_vector 
405a c3 53 23			jp macro_next 
405d				endm 
# End of macro NEXTW
405d			 
405d			.RND16: 
405d				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
405d 4e				db WORD_SYS_CORE+58             
405e 8f 40			dw .RND8            
4060 06				db 5 + 1 
4061 .. 00			db "RND16",0              
4067				endm 
# End of macro CWHEAD
4067			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
4067					if DEBUG_FORTH_WORDS_KEY 
4067						DMARK "R16" 
4067 f5				push af  
4068 3a 7c 40			ld a, (.dmark)  
406b 32 9d fd			ld (debug_mark),a  
406e 3a 7d 40			ld a, (.dmark+1)  
4071 32 9e fd			ld (debug_mark+1),a  
4074 3a 7e 40			ld a, (.dmark+2)  
4077 32 9f fd			ld (debug_mark+2),a  
407a 18 03			jr .pastdmark  
407c ..			.dmark: db "R16"  
407f f1			.pastdmark: pop af  
4080			endm  
# End of macro DMARK
4080						CALLMONITOR 
4080 cd aa fd			call debug_vector  
4083				endm  
# End of macro CALLMONITOR
4083					endif 
4083 cd d3 0e				call prng16  
4086 cd 70 1f				call forth_push_numhl 
4089				       NEXTW 
4089 cd a7 fd			call parse_vector 
408c c3 53 23			jp macro_next 
408f				endm 
# End of macro NEXTW
408f			.RND8: 
408f				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
408f 60				db WORD_SYS_CORE+76             
4090 c7 40			dw .RND            
4092 05				db 4 + 1 
4093 .. 00			db "RND8",0              
4098				endm 
# End of macro CWHEAD
4098			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
4098					if DEBUG_FORTH_WORDS_KEY 
4098						DMARK "RN8" 
4098 f5				push af  
4099 3a ad 40			ld a, (.dmark)  
409c 32 9d fd			ld (debug_mark),a  
409f 3a ae 40			ld a, (.dmark+1)  
40a2 32 9e fd			ld (debug_mark+1),a  
40a5 3a af 40			ld a, (.dmark+2)  
40a8 32 9f fd			ld (debug_mark+2),a  
40ab 18 03			jr .pastdmark  
40ad ..			.dmark: db "RN8"  
40b0 f1			.pastdmark: pop af  
40b1			endm  
# End of macro DMARK
40b1						CALLMONITOR 
40b1 cd aa fd			call debug_vector  
40b4				endm  
# End of macro CALLMONITOR
40b4					endif 
40b4 2a db fa				ld hl,(xrandc) 
40b7 23					inc hl 
40b8 cd ed 0e				call xrnd 
40bb 6f					ld l,a	 
40bc 26 00				ld h,0 
40be cd 70 1f				call forth_push_numhl 
40c1				       NEXTW 
40c1 cd a7 fd			call parse_vector 
40c4 c3 53 23			jp macro_next 
40c7				endm 
# End of macro NEXTW
40c7			.RND: 
40c7				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
40c7 60				db WORD_SYS_CORE+76             
40c8 d0 41			dw .ENDMATHS            
40ca 04				db 3 + 1 
40cb .. 00			db "RND",0              
40cf				endm 
# End of macro CWHEAD
40cf			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
40cf			 
40cf					if DEBUG_FORTH_WORDS_KEY 
40cf						DMARK "RND" 
40cf f5				push af  
40d0 3a e4 40			ld a, (.dmark)  
40d3 32 9d fd			ld (debug_mark),a  
40d6 3a e5 40			ld a, (.dmark+1)  
40d9 32 9e fd			ld (debug_mark+1),a  
40dc 3a e6 40			ld a, (.dmark+2)  
40df 32 9f fd			ld (debug_mark+2),a  
40e2 18 03			jr .pastdmark  
40e4 ..			.dmark: db "RND"  
40e7 f1			.pastdmark: pop af  
40e8			endm  
# End of macro DMARK
40e8						CALLMONITOR 
40e8 cd aa fd			call debug_vector  
40eb				endm  
# End of macro CALLMONITOR
40eb					endif 
40eb					 
40eb					FORTH_DSP_VALUEHL    ; upper range 
40eb cd 6c 21			call macro_dsp_valuehl 
40ee				endm 
# End of macro FORTH_DSP_VALUEHL
40ee			 
40ee 22 df fa				ld (LFSRSeed), hl	 
40f1			 
40f1					if DEBUG_FORTH_WORDS 
40f1						DMARK "RN1" 
40f1 f5				push af  
40f2 3a 06 41			ld a, (.dmark)  
40f5 32 9d fd			ld (debug_mark),a  
40f8 3a 07 41			ld a, (.dmark+1)  
40fb 32 9e fd			ld (debug_mark+1),a  
40fe 3a 08 41			ld a, (.dmark+2)  
4101 32 9f fd			ld (debug_mark+2),a  
4104 18 03			jr .pastdmark  
4106 ..			.dmark: db "RN1"  
4109 f1			.pastdmark: pop af  
410a			endm  
# End of macro DMARK
410a						CALLMONITOR 
410a cd aa fd			call debug_vector  
410d				endm  
# End of macro CALLMONITOR
410d					endif 
410d					FORTH_DSP_POP 
410d cd 24 22			call macro_forth_dsp_pop 
4110				endm 
# End of macro FORTH_DSP_POP
4110			 
4110					FORTH_DSP_VALUEHL    ; low range 
4110 cd 6c 21			call macro_dsp_valuehl 
4113				endm 
# End of macro FORTH_DSP_VALUEHL
4113			 
4113					if DEBUG_FORTH_WORDS 
4113						DMARK "RN2" 
4113 f5				push af  
4114 3a 28 41			ld a, (.dmark)  
4117 32 9d fd			ld (debug_mark),a  
411a 3a 29 41			ld a, (.dmark+1)  
411d 32 9e fd			ld (debug_mark+1),a  
4120 3a 2a 41			ld a, (.dmark+2)  
4123 32 9f fd			ld (debug_mark+2),a  
4126 18 03			jr .pastdmark  
4128 ..			.dmark: db "RN2"  
412b f1			.pastdmark: pop af  
412c			endm  
# End of macro DMARK
412c						CALLMONITOR 
412c cd aa fd			call debug_vector  
412f				endm  
# End of macro CALLMONITOR
412f					endif 
412f 22 e1 fa				ld (LFSRSeed+2), hl 
4132			 
4132					FORTH_DSP_POP 
4132 cd 24 22			call macro_forth_dsp_pop 
4135				endm 
# End of macro FORTH_DSP_POP
4135			 
4135 e5					push hl 
4136			 
4136 e1			.inrange:	pop hl 
4137 cd d3 0e				call prng16  
413a					if DEBUG_FORTH_WORDS 
413a						DMARK "RN3" 
413a f5				push af  
413b 3a 4f 41			ld a, (.dmark)  
413e 32 9d fd			ld (debug_mark),a  
4141 3a 50 41			ld a, (.dmark+1)  
4144 32 9e fd			ld (debug_mark+1),a  
4147 3a 51 41			ld a, (.dmark+2)  
414a 32 9f fd			ld (debug_mark+2),a  
414d 18 03			jr .pastdmark  
414f ..			.dmark: db "RN3"  
4152 f1			.pastdmark: pop af  
4153			endm  
# End of macro DMARK
4153						CALLMONITOR 
4153 cd aa fd			call debug_vector  
4156				endm  
# End of macro CALLMONITOR
4156					endif 
4156					 
4156					; if the range is 8bit knock out the high byte 
4156			 
4156 ed 5b df fa			ld de, (LFSRSeed)     ; check high level 
415a			 
415a 3e 00				ld a, 0 
415c ba					cp d  
415d 20 1e				jr nz, .hirange 
415f 26 00				ld h, 0   ; knock it down to 8bit 
4161			 
4161					if DEBUG_FORTH_WORDS 
4161						DMARK "RNk" 
4161 f5				push af  
4162 3a 76 41			ld a, (.dmark)  
4165 32 9d fd			ld (debug_mark),a  
4168 3a 77 41			ld a, (.dmark+1)  
416b 32 9e fd			ld (debug_mark+1),a  
416e 3a 78 41			ld a, (.dmark+2)  
4171 32 9f fd			ld (debug_mark+2),a  
4174 18 03			jr .pastdmark  
4176 ..			.dmark: db "RNk"  
4179 f1			.pastdmark: pop af  
417a			endm  
# End of macro DMARK
417a						CALLMONITOR 
417a cd aa fd			call debug_vector  
417d				endm  
# End of macro CALLMONITOR
417d					endif 
417d			.hirange:   
417d e5					push hl  
417e b7					or a  
417f ed 52		                sbc hl, de 
4181			 
4181					;call cmp16 
4181			 
4181 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
4183 e1					pop hl 
4184 e5					push hl 
4185			 
4185					if DEBUG_FORTH_WORDS 
4185						DMARK "RN4" 
4185 f5				push af  
4186 3a 9a 41			ld a, (.dmark)  
4189 32 9d fd			ld (debug_mark),a  
418c 3a 9b 41			ld a, (.dmark+1)  
418f 32 9e fd			ld (debug_mark+1),a  
4192 3a 9c 41			ld a, (.dmark+2)  
4195 32 9f fd			ld (debug_mark+2),a  
4198 18 03			jr .pastdmark  
419a ..			.dmark: db "RN4"  
419d f1			.pastdmark: pop af  
419e			endm  
# End of macro DMARK
419e						CALLMONITOR 
419e cd aa fd			call debug_vector  
41a1				endm  
# End of macro CALLMONITOR
41a1					endif 
41a1 ed 5b e1 fa			ld de, (LFSRSeed+2)   ; check low range 
41a5					;call cmp16 
41a5				 
41a5 b7					or a  
41a6 ed 52		                sbc hl, de 
41a8 38 8c				jr c, .inrange 
41aa			 
41aa e1					pop hl 
41ab					 
41ab					if DEBUG_FORTH_WORDS 
41ab						DMARK "RNd" 
41ab f5				push af  
41ac 3a c0 41			ld a, (.dmark)  
41af 32 9d fd			ld (debug_mark),a  
41b2 3a c1 41			ld a, (.dmark+1)  
41b5 32 9e fd			ld (debug_mark+1),a  
41b8 3a c2 41			ld a, (.dmark+2)  
41bb 32 9f fd			ld (debug_mark+2),a  
41be 18 03			jr .pastdmark  
41c0 ..			.dmark: db "RNd"  
41c3 f1			.pastdmark: pop af  
41c4			endm  
# End of macro DMARK
41c4						CALLMONITOR 
41c4 cd aa fd			call debug_vector  
41c7				endm  
# End of macro CALLMONITOR
41c7					endif 
41c7			 
41c7			 
41c7 cd 70 1f				call forth_push_numhl 
41ca				       NEXTW 
41ca cd a7 fd			call parse_vector 
41cd c3 53 23			jp macro_next 
41d0				endm 
# End of macro NEXTW
41d0			 
41d0			.ENDMATHS: 
41d0			 
41d0			; eof 
41d0			 
# End of file forth_words_maths.asm
41d0			include "forth_words_display.asm" 
41d0			 
41d0			; | ## Display Words 
41d0			 
41d0			.ACT: 
41d0			 
41d0				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
41d0 62				db WORD_SYS_CORE+78             
41d1 1f 42			dw .INFO            
41d3 07				db 6 + 1 
41d4 .. 00			db "ACTIVE",0              
41db				endm 
# End of macro CWHEAD
41db			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
41db			;  
41db			; | | To display a pulsing activity indicator in a processing loop do this... 
41db			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
41db			 
41db					if DEBUG_FORTH_WORDS_KEY 
41db						DMARK "ACT" 
41db f5				push af  
41dc 3a f0 41			ld a, (.dmark)  
41df 32 9d fd			ld (debug_mark),a  
41e2 3a f1 41			ld a, (.dmark+1)  
41e5 32 9e fd			ld (debug_mark+1),a  
41e8 3a f2 41			ld a, (.dmark+2)  
41eb 32 9f fd			ld (debug_mark+2),a  
41ee 18 03			jr .pastdmark  
41f0 ..			.dmark: db "ACT"  
41f3 f1			.pastdmark: pop af  
41f4			endm  
# End of macro DMARK
41f4						CALLMONITOR 
41f4 cd aa fd			call debug_vector  
41f7				endm  
# End of macro CALLMONITOR
41f7					endif 
41f7 cd d4 0c				call active 
41fa					if DEBUG_FORTH_WORDS 
41fa						DMARK "ACp" 
41fa f5				push af  
41fb 3a 0f 42			ld a, (.dmark)  
41fe 32 9d fd			ld (debug_mark),a  
4201 3a 10 42			ld a, (.dmark+1)  
4204 32 9e fd			ld (debug_mark+1),a  
4207 3a 11 42			ld a, (.dmark+2)  
420a 32 9f fd			ld (debug_mark+2),a  
420d 18 03			jr .pastdmark  
420f ..			.dmark: db "ACp"  
4212 f1			.pastdmark: pop af  
4213			endm  
# End of macro DMARK
4213						CALLMONITOR 
4213 cd aa fd			call debug_vector  
4216				endm  
# End of macro CALLMONITOR
4216					endif 
4216 cd da 1f				call forth_push_str 
4219			 
4219					NEXTW 
4219 cd a7 fd			call parse_vector 
421c c3 53 23			jp macro_next 
421f				endm 
# End of macro NEXTW
421f			.INFO: 
421f			 
421f				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
421f 62				db WORD_SYS_CORE+78             
4220 3f 42			dw .ATP            
4222 05				db 4 + 1 
4223 .. 00			db "INFO",0              
4228				endm 
# End of macro CWHEAD
4228			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
4228					FORTH_DSP_VALUEHL 
4228 cd 6c 21			call macro_dsp_valuehl 
422b				endm 
# End of macro FORTH_DSP_VALUEHL
422b			 
422b					FORTH_DSP_POP 
422b cd 24 22			call macro_forth_dsp_pop 
422e				endm 
# End of macro FORTH_DSP_POP
422e			 
422e e5					push hl 
422f			 
422f					FORTH_DSP_VALUEHL 
422f cd 6c 21			call macro_dsp_valuehl 
4232				endm 
# End of macro FORTH_DSP_VALUEHL
4232			 
4232					FORTH_DSP_POP 
4232 cd 24 22			call macro_forth_dsp_pop 
4235				endm 
# End of macro FORTH_DSP_POP
4235			 
4235 d1					pop de 
4236			 
4236 cd 0e 0d				call info_panel 
4239			 
4239			 
4239					NEXTW 
4239 cd a7 fd			call parse_vector 
423c c3 53 23			jp macro_next 
423f				endm 
# End of macro NEXTW
423f			.ATP: 
423f				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
423f 62				db WORD_SYS_CORE+78             
4240 b9 42			dw .FB            
4242 04				db 3 + 1 
4243 .. 00			db "AT?",0              
4247				endm 
# End of macro CWHEAD
4247			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
4247					if DEBUG_FORTH_WORDS_KEY 
4247						DMARK "AT?" 
4247 f5				push af  
4248 3a 5c 42			ld a, (.dmark)  
424b 32 9d fd			ld (debug_mark),a  
424e 3a 5d 42			ld a, (.dmark+1)  
4251 32 9e fd			ld (debug_mark+1),a  
4254 3a 5e 42			ld a, (.dmark+2)  
4257 32 9f fd			ld (debug_mark+2),a  
425a 18 03			jr .pastdmark  
425c ..			.dmark: db "AT?"  
425f f1			.pastdmark: pop af  
4260			endm  
# End of macro DMARK
4260						CALLMONITOR 
4260 cd aa fd			call debug_vector  
4263				endm  
# End of macro CALLMONITOR
4263					endif 
4263 3a 90 f9				ld a, (f_cursor_ptr) 
4266			 
4266			if DEBUG_FORTH_WORDS 
4266				DMARK "AT?" 
4266 f5				push af  
4267 3a 7b 42			ld a, (.dmark)  
426a 32 9d fd			ld (debug_mark),a  
426d 3a 7c 42			ld a, (.dmark+1)  
4270 32 9e fd			ld (debug_mark+1),a  
4273 3a 7d 42			ld a, (.dmark+2)  
4276 32 9f fd			ld (debug_mark+2),a  
4279 18 03			jr .pastdmark  
427b ..			.dmark: db "AT?"  
427e f1			.pastdmark: pop af  
427f			endm  
# End of macro DMARK
427f				CALLMONITOR 
427f cd aa fd			call debug_vector  
4282				endm  
# End of macro CALLMONITOR
4282			endif	 
4282					; count the number of rows 
4282			 
4282 06 00				ld b, 0 
4284 4f			.atpr:		ld c, a    ; save in case we go below zero 
4285 d6 28				sub display_cols 
4287 f2 8d 42				jp p, .atprunder 
428a 04					inc b 
428b 18 f7				jr .atpr 
428d			.atprunder:	 
428d			if DEBUG_FORTH_WORDS 
428d				DMARK "A?2" 
428d f5				push af  
428e 3a a2 42			ld a, (.dmark)  
4291 32 9d fd			ld (debug_mark),a  
4294 3a a3 42			ld a, (.dmark+1)  
4297 32 9e fd			ld (debug_mark+1),a  
429a 3a a4 42			ld a, (.dmark+2)  
429d 32 9f fd			ld (debug_mark+2),a  
42a0 18 03			jr .pastdmark  
42a2 ..			.dmark: db "A?2"  
42a5 f1			.pastdmark: pop af  
42a6			endm  
# End of macro DMARK
42a6				CALLMONITOR 
42a6 cd aa fd			call debug_vector  
42a9				endm  
# End of macro CALLMONITOR
42a9			endif	 
42a9 26 00				ld h, 0 
42ab 69					ld l, c 
42ac cd 70 1f				call forth_push_numhl 
42af 68					ld l, b  
42b0 cd 70 1f				call forth_push_numhl 
42b3			 
42b3			 
42b3				NEXTW 
42b3 cd a7 fd			call parse_vector 
42b6 c3 53 23			jp macro_next 
42b9				endm 
# End of macro NEXTW
42b9			 
42b9			.FB: 
42b9				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
42b9 1b				db WORD_SYS_CORE+7             
42ba 0a 43			dw .EMIT            
42bc 03				db 2 + 1 
42bd .. 00			db "FB",0              
42c0				endm 
# End of macro CWHEAD
42c0			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
42c0			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
42c0			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
42c0			; | | If automatic display is off then updates will not be shown until DRAW is used. 
42c0					if DEBUG_FORTH_WORDS_KEY 
42c0						DMARK "FB." 
42c0 f5				push af  
42c1 3a d5 42			ld a, (.dmark)  
42c4 32 9d fd			ld (debug_mark),a  
42c7 3a d6 42			ld a, (.dmark+1)  
42ca 32 9e fd			ld (debug_mark+1),a  
42cd 3a d7 42			ld a, (.dmark+2)  
42d0 32 9f fd			ld (debug_mark+2),a  
42d3 18 03			jr .pastdmark  
42d5 ..			.dmark: db "FB."  
42d8 f1			.pastdmark: pop af  
42d9			endm  
# End of macro DMARK
42d9						CALLMONITOR 
42d9 cd aa fd			call debug_vector  
42dc				endm  
# End of macro CALLMONITOR
42dc					endif 
42dc			 
42dc					FORTH_DSP_VALUEHL 
42dc cd 6c 21			call macro_dsp_valuehl 
42df				endm 
# End of macro FORTH_DSP_VALUEHL
42df			 
42df 7d					ld a, l 
42e0 fe 01				cp 1 
42e2 20 05				jr nz, .fbn1 
42e4 21 42 fc				ld hl, display_fb1 
42e7 18 15				jr .fbset 
42e9 fe 02		.fbn1:		cp 2 
42eb 20 05				jr nz, .fbn2 
42ed 21 00 fb				ld hl, display_fb2 
42f0 18 0c				jr .fbset 
42f2 fe 03		.fbn2:		cp 3 
42f4 20 05				jr nz, .fbn3 
42f6 21 a1 fb				ld hl, display_fb3 
42f9 18 03				jr .fbset 
42fb			.fbn3:		 ; if invalid number select first 
42fb 21 42 fc				ld hl, display_fb1 
42fe 22 fe fa		.fbset:		ld (display_fb_active), hl 
4301			 
4301					FORTH_DSP_POP 
4301 cd 24 22			call macro_forth_dsp_pop 
4304				endm 
# End of macro FORTH_DSP_POP
4304			 
4304					NEXTW 
4304 cd a7 fd			call parse_vector 
4307 c3 53 23			jp macro_next 
430a				endm 
# End of macro NEXTW
430a			 
430a			 
430a			.EMIT: 
430a				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
430a 1b				db WORD_SYS_CORE+7             
430b 5d 43			dw .DOTH            
430d 05				db 4 + 1 
430e .. 00			db "EMIT",0              
4313				endm 
# End of macro CWHEAD
4313			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
4313					; get value off TOS and display it 
4313			 
4313					if DEBUG_FORTH_WORDS_KEY 
4313						DMARK "EMT" 
4313 f5				push af  
4314 3a 28 43			ld a, (.dmark)  
4317 32 9d fd			ld (debug_mark),a  
431a 3a 29 43			ld a, (.dmark+1)  
431d 32 9e fd			ld (debug_mark+1),a  
4320 3a 2a 43			ld a, (.dmark+2)  
4323 32 9f fd			ld (debug_mark+2),a  
4326 18 03			jr .pastdmark  
4328 ..			.dmark: db "EMT"  
432b f1			.pastdmark: pop af  
432c			endm  
# End of macro DMARK
432c						CALLMONITOR 
432c cd aa fd			call debug_vector  
432f				endm  
# End of macro CALLMONITOR
432f					endif 
432f			 
432f					FORTH_DSP_VALUEHL 
432f cd 6c 21			call macro_dsp_valuehl 
4332				endm 
# End of macro FORTH_DSP_VALUEHL
4332			 
4332 7d					ld a,l 
4333			 
4333					; TODO write to display 
4333			 
4333 32 f1 f2				ld (os_input), a 
4336 3e 00				ld a, 0 
4338 32 f2 f2				ld (os_input+1), a 
433b					 
433b 3a 90 f9				ld a, (f_cursor_ptr) 
433e 11 f1 f2				ld de, os_input 
4341 cd 8e 0d				call str_at_display 
4344			 
4344			 
4344 3a 6e f9				ld a,(cli_autodisplay) 
4347			;		cp 0 
4347 b7					or a 
4348 28 03				jr z, .enoupdate 
434a cd 9e 0d						call update_display 
434d					.enoupdate: 
434d			 
434d 3a 90 f9				ld a, (f_cursor_ptr) 
4350 3c					inc a 
4351 32 90 f9				ld (f_cursor_ptr), a   ; save new pos 
4354			 
4354			 
4354					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4354 cd 24 22			call macro_forth_dsp_pop 
4357				endm 
# End of macro FORTH_DSP_POP
4357			  
4357			 
4357					NEXTW 
4357 cd a7 fd			call parse_vector 
435a c3 53 23			jp macro_next 
435d				endm 
# End of macro NEXTW
435d			.DOTH: 
435d				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
435d 1c				db WORD_SYS_CORE+8             
435e 90 43			dw .DOTF            
4360 03				db 2 + 1 
4361 .. 00			db ".-",0              
4364				endm 
# End of macro CWHEAD
4364			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4364					; get value off TOS and display it 
4364					if DEBUG_FORTH_WORDS_KEY 
4364						DMARK "DTD" 
4364 f5				push af  
4365 3a 79 43			ld a, (.dmark)  
4368 32 9d fd			ld (debug_mark),a  
436b 3a 7a 43			ld a, (.dmark+1)  
436e 32 9e fd			ld (debug_mark+1),a  
4371 3a 7b 43			ld a, (.dmark+2)  
4374 32 9f fd			ld (debug_mark+2),a  
4377 18 03			jr .pastdmark  
4379 ..			.dmark: db "DTD"  
437c f1			.pastdmark: pop af  
437d			endm  
# End of macro DMARK
437d						CALLMONITOR 
437d cd aa fd			call debug_vector  
4380				endm  
# End of macro CALLMONITOR
4380					endif 
4380 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4382 3e 00			ld a, 0 
4384 32 6f f9			ld (cli_mvdot), a 
4387 c3 ea 43			jp .dotgo 
438a				NEXTW 
438a cd a7 fd			call parse_vector 
438d c3 53 23			jp macro_next 
4390				endm 
# End of macro NEXTW
4390			.DOTF: 
4390				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4390 1c				db WORD_SYS_CORE+8             
4391 c1 43			dw .DOT            
4393 03				db 2 + 1 
4394 .. 00			db ".>",0              
4397				endm 
# End of macro CWHEAD
4397			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4397					; get value off TOS and display it 
4397			        ; TODO BUG adds extra spaces 
4397			        ; TODO BUG handle numerics? 
4397					if DEBUG_FORTH_WORDS_KEY 
4397						DMARK "DTC" 
4397 f5				push af  
4398 3a ac 43			ld a, (.dmark)  
439b 32 9d fd			ld (debug_mark),a  
439e 3a ad 43			ld a, (.dmark+1)  
43a1 32 9e fd			ld (debug_mark+1),a  
43a4 3a ae 43			ld a, (.dmark+2)  
43a7 32 9f fd			ld (debug_mark+2),a  
43aa 18 03			jr .pastdmark  
43ac ..			.dmark: db "DTC"  
43af f1			.pastdmark: pop af  
43b0			endm  
# End of macro DMARK
43b0						CALLMONITOR 
43b0 cd aa fd			call debug_vector  
43b3				endm  
# End of macro CALLMONITOR
43b3					endif 
43b3 3e 01			ld a, 1 
43b5 32 6f f9			ld (cli_mvdot), a 
43b8 c3 ea 43			jp .dotgo 
43bb				NEXTW 
43bb cd a7 fd			call parse_vector 
43be c3 53 23			jp macro_next 
43c1				endm 
# End of macro NEXTW
43c1			 
43c1			.DOT: 
43c1				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
43c1 1c				db WORD_SYS_CORE+8             
43c2 9c 45			dw .CLS            
43c4 02				db 1 + 1 
43c5 .. 00			db ".",0              
43c7				endm 
# End of macro CWHEAD
43c7			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
43c7					; get value off TOS and display it 
43c7			 
43c7					if DEBUG_FORTH_WORDS_KEY 
43c7						DMARK "DOT" 
43c7 f5				push af  
43c8 3a dc 43			ld a, (.dmark)  
43cb 32 9d fd			ld (debug_mark),a  
43ce 3a dd 43			ld a, (.dmark+1)  
43d1 32 9e fd			ld (debug_mark+1),a  
43d4 3a de 43			ld a, (.dmark+2)  
43d7 32 9f fd			ld (debug_mark+2),a  
43da 18 03			jr .pastdmark  
43dc ..			.dmark: db "DOT"  
43df f1			.pastdmark: pop af  
43e0			endm  
# End of macro DMARK
43e0						CALLMONITOR 
43e0 cd aa fd			call debug_vector  
43e3				endm  
# End of macro CALLMONITOR
43e3					endif 
43e3 3e 00			ld a, 0 
43e5 32 6f f9			ld (cli_mvdot), a 
43e8 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
43ea				 
43ea			 
43ea			.dotgo: 
43ea			 
43ea			; move up type to on stack for parserv5 
43ea					FORTH_DSP 
43ea cd 32 21			call macro_forth_dsp 
43ed				endm 
# End of macro FORTH_DSP
43ed				;FORTH_DSP_VALUE  
43ed			 
43ed			if DEBUG_FORTH_DOT 
43ed				DMARK "DOT" 
43ed f5				push af  
43ee 3a 02 44			ld a, (.dmark)  
43f1 32 9d fd			ld (debug_mark),a  
43f4 3a 03 44			ld a, (.dmark+1)  
43f7 32 9e fd			ld (debug_mark+1),a  
43fa 3a 04 44			ld a, (.dmark+2)  
43fd 32 9f fd			ld (debug_mark+2),a  
4400 18 03			jr .pastdmark  
4402 ..			.dmark: db "DOT"  
4405 f1			.pastdmark: pop af  
4406			endm  
# End of macro DMARK
4406				CALLMONITOR 
4406 cd aa fd			call debug_vector  
4409				endm  
# End of macro CALLMONITOR
4409			endif	 
4409			;		.print: 
4409			 
4409 7e				ld a,(hl)  ; work out what type of value is on the TOS 
440a 23				inc hl   ; position to the actual value 
440b fe 01			cp DS_TYPE_STR 
440d 20 06			jr nz, .dotnum1  
440f			 
440f			; display string 
440f				FORTH_DSP_VALUE  
440f cd 55 21			call macro_forth_dsp_value 
4412				endm 
# End of macro FORTH_DSP_VALUE
4412 eb				ex de,hl 
4413 18 49			jr .dotwrite 
4415			 
4415			.dotnum1: 
4415 fe 02			cp DS_TYPE_INUM 
4417 20 44			jr nz, .dotflot 
4419			 
4419			 
4419			; display number 
4419			 
4419			;	push hl 
4419			;	call clear_display 
4419			;	pop hl 
4419			 
4419 5e				ld e, (hl) 
441a 23				inc hl 
441b 56				ld d, (hl) 
441c 21 f3 f0			ld hl, scratch 
441f			if DEBUG_FORTH_DOT 
441f				DMARK "DT1" 
441f f5				push af  
4420 3a 34 44			ld a, (.dmark)  
4423 32 9d fd			ld (debug_mark),a  
4426 3a 35 44			ld a, (.dmark+1)  
4429 32 9e fd			ld (debug_mark+1),a  
442c 3a 36 44			ld a, (.dmark+2)  
442f 32 9f fd			ld (debug_mark+2),a  
4432 18 03			jr .pastdmark  
4434 ..			.dmark: db "DT1"  
4437 f1			.pastdmark: pop af  
4438			endm  
# End of macro DMARK
4438				CALLMONITOR 
4438 cd aa fd			call debug_vector  
443b				endm  
# End of macro CALLMONITOR
443b			endif	 
443b			 
443b cd b3 12			call uitoa_16 
443e eb				ex de,hl 
443f			 
443f			if DEBUG_FORTH_DOT 
443f				DMARK "DT2" 
443f f5				push af  
4440 3a 54 44			ld a, (.dmark)  
4443 32 9d fd			ld (debug_mark),a  
4446 3a 55 44			ld a, (.dmark+1)  
4449 32 9e fd			ld (debug_mark+1),a  
444c 3a 56 44			ld a, (.dmark+2)  
444f 32 9f fd			ld (debug_mark+2),a  
4452 18 03			jr .pastdmark  
4454 ..			.dmark: db "DT2"  
4457 f1			.pastdmark: pop af  
4458			endm  
# End of macro DMARK
4458				CALLMONITOR 
4458 cd aa fd			call debug_vector  
445b				endm  
# End of macro CALLMONITOR
445b			endif	 
445b			 
445b			;	ld de, os_word_scratch 
445b 18 01			jr .dotwrite 
445d			 
445d 00			.dotflot:   nop 
445e			; TODO print floating point number 
445e			 
445e			.dotwrite:		 
445e			 
445e					; if c is set then set all '-' to spaces 
445e					; need to also take into account .>  
445e			 
445e 3e 01				ld a, 1 
4460 b9					cp c 
4461 20 65				jr nz, .nodashswap 
4463			 
4463					; DE has the string to write, working with HL 
4463			 
4463 06 ff				ld b, 255 
4465 d5					push de 
4466 e1					pop hl 
4467			 
4467			if DEBUG_FORTH_DOT 
4467				DMARK "DT-" 
4467 f5				push af  
4468 3a 7c 44			ld a, (.dmark)  
446b 32 9d fd			ld (debug_mark),a  
446e 3a 7d 44			ld a, (.dmark+1)  
4471 32 9e fd			ld (debug_mark+1),a  
4474 3a 7e 44			ld a, (.dmark+2)  
4477 32 9f fd			ld (debug_mark+2),a  
447a 18 03			jr .pastdmark  
447c ..			.dmark: db "DT-"  
447f f1			.pastdmark: pop af  
4480			endm  
# End of macro DMARK
4480				CALLMONITOR 
4480 cd aa fd			call debug_vector  
4483				endm  
# End of macro CALLMONITOR
4483			endif	 
4483 7e			.dashscan:	ld a, (hl) 
4484			;		cp 0 
4484 b7					or a 
4485 28 41				jr z, .nodashswap 
4487 fe 2d				cp '-' 
4489 20 02				jr nz, .dashskip 
448b			;		ld a, ' ' 
448b 36 20				ld (hl), ' ' 
448d 23			.dashskip:	inc hl 
448e			if DEBUG_FORTH_DOT 
448e				DMARK "D-2" 
448e f5				push af  
448f 3a a3 44			ld a, (.dmark)  
4492 32 9d fd			ld (debug_mark),a  
4495 3a a4 44			ld a, (.dmark+1)  
4498 32 9e fd			ld (debug_mark+1),a  
449b 3a a5 44			ld a, (.dmark+2)  
449e 32 9f fd			ld (debug_mark+2),a  
44a1 18 03			jr .pastdmark  
44a3 ..			.dmark: db "D-2"  
44a6 f1			.pastdmark: pop af  
44a7			endm  
# End of macro DMARK
44a7				CALLMONITOR 
44a7 cd aa fd			call debug_vector  
44aa				endm  
# End of macro CALLMONITOR
44aa			endif	 
44aa 10 d7				djnz .dashscan 
44ac			 
44ac			if DEBUG_FORTH_DOT 
44ac				DMARK "D-1" 
44ac f5				push af  
44ad 3a c1 44			ld a, (.dmark)  
44b0 32 9d fd			ld (debug_mark),a  
44b3 3a c2 44			ld a, (.dmark+1)  
44b6 32 9e fd			ld (debug_mark+1),a  
44b9 3a c3 44			ld a, (.dmark+2)  
44bc 32 9f fd			ld (debug_mark+2),a  
44bf 18 03			jr .pastdmark  
44c1 ..			.dmark: db "D-1"  
44c4 f1			.pastdmark: pop af  
44c5			endm  
# End of macro DMARK
44c5				CALLMONITOR 
44c5 cd aa fd			call debug_vector  
44c8				endm  
# End of macro CALLMONITOR
44c8			endif	 
44c8			 
44c8			.nodashswap: 
44c8			 
44c8			if DEBUG_FORTH_DOT 
44c8				DMARK "D-o" 
44c8 f5				push af  
44c9 3a dd 44			ld a, (.dmark)  
44cc 32 9d fd			ld (debug_mark),a  
44cf 3a de 44			ld a, (.dmark+1)  
44d2 32 9e fd			ld (debug_mark+1),a  
44d5 3a df 44			ld a, (.dmark+2)  
44d8 32 9f fd			ld (debug_mark+2),a  
44db 18 03			jr .pastdmark  
44dd ..			.dmark: db "D-o"  
44e0 f1			.pastdmark: pop af  
44e1			endm  
# End of macro DMARK
44e1				CALLMONITOR 
44e1 cd aa fd			call debug_vector  
44e4				endm  
# End of macro CALLMONITOR
44e4			endif	 
44e4			 
44e4 d5					push de   ; save string start in case we need to advance print 
44e5			 
44e5 3a 90 f9				ld a, (f_cursor_ptr) 
44e8 cd 8e 0d				call str_at_display 
44eb 3a 6e f9				ld a,(cli_autodisplay) 
44ee			;		cp 0 
44ee b7					or a 
44ef 28 03				jr z, .noupdate 
44f1 cd 9e 0d						call update_display 
44f4					.noupdate: 
44f4			 
44f4			 
44f4					; see if we need to advance the print position 
44f4			 
44f4 e1					pop hl   ; get back string 
44f5			;		ex de,hl 
44f5			 
44f5 3a 6f f9				ld a, (cli_mvdot) 
44f8			if DEBUG_FORTH_DOT 
44f8			;		ld e,a 
44f8				DMARK "D>1" 
44f8 f5				push af  
44f9 3a 0d 45			ld a, (.dmark)  
44fc 32 9d fd			ld (debug_mark),a  
44ff 3a 0e 45			ld a, (.dmark+1)  
4502 32 9e fd			ld (debug_mark+1),a  
4505 3a 0f 45			ld a, (.dmark+2)  
4508 32 9f fd			ld (debug_mark+2),a  
450b 18 03			jr .pastdmark  
450d ..			.dmark: db "D>1"  
4510 f1			.pastdmark: pop af  
4511			endm  
# End of macro DMARK
4511				CALLMONITOR 
4511 cd aa fd			call debug_vector  
4514				endm  
# End of macro CALLMONITOR
4514			endif	 
4514			;		cp 0 
4514 b7					or a 
4515 28 44				jr z, .noadv 
4517					; yes, lets advance the print position 
4517 3e 00				ld a, 0 
4519 cd 0f 13				call strlent 
451c			if DEBUG_FORTH_DOT 
451c				DMARK "D-?" 
451c f5				push af  
451d 3a 31 45			ld a, (.dmark)  
4520 32 9d fd			ld (debug_mark),a  
4523 3a 32 45			ld a, (.dmark+1)  
4526 32 9e fd			ld (debug_mark+1),a  
4529 3a 33 45			ld a, (.dmark+2)  
452c 32 9f fd			ld (debug_mark+2),a  
452f 18 03			jr .pastdmark  
4531 ..			.dmark: db "D-?"  
4534 f1			.pastdmark: pop af  
4535			endm  
# End of macro DMARK
4535				CALLMONITOR 
4535 cd aa fd			call debug_vector  
4538				endm  
# End of macro CALLMONITOR
4538			endif	 
4538 3a 90 f9				ld a, (f_cursor_ptr) 
453b 85					add a,l 
453c					;call addatohl 
453c					;ld a, l 
453c 32 90 f9				ld (f_cursor_ptr), a   ; save new pos 
453f			 
453f			if DEBUG_FORTH_DOT 
453f				DMARK "D->" 
453f f5				push af  
4540 3a 54 45			ld a, (.dmark)  
4543 32 9d fd			ld (debug_mark),a  
4546 3a 55 45			ld a, (.dmark+1)  
4549 32 9e fd			ld (debug_mark+1),a  
454c 3a 56 45			ld a, (.dmark+2)  
454f 32 9f fd			ld (debug_mark+2),a  
4552 18 03			jr .pastdmark  
4554 ..			.dmark: db "D->"  
4557 f1			.pastdmark: pop af  
4558			endm  
# End of macro DMARK
4558				CALLMONITOR 
4558 cd aa fd			call debug_vector  
455b				endm  
# End of macro CALLMONITOR
455b			endif	 
455b			 
455b			.noadv:	 
455b			 
455b					if DEBUG_FORTH_DOT_WAIT 
455b							call next_page_prompt 
455b					endif	 
455b			; TODO this pop off the stack causes a crash. i dont know why 
455b			 
455b			 
455b			if DEBUG_FORTH_DOT 
455b				DMARK "DTh" 
455b f5				push af  
455c 3a 70 45			ld a, (.dmark)  
455f 32 9d fd			ld (debug_mark),a  
4562 3a 71 45			ld a, (.dmark+1)  
4565 32 9e fd			ld (debug_mark+1),a  
4568 3a 72 45			ld a, (.dmark+2)  
456b 32 9f fd			ld (debug_mark+2),a  
456e 18 03			jr .pastdmark  
4570 ..			.dmark: db "DTh"  
4573 f1			.pastdmark: pop af  
4574			endm  
# End of macro DMARK
4574				CALLMONITOR 
4574 cd aa fd			call debug_vector  
4577				endm  
# End of macro CALLMONITOR
4577			endif	 
4577			 
4577					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4577 cd 24 22			call macro_forth_dsp_pop 
457a				endm 
# End of macro FORTH_DSP_POP
457a			 
457a			if DEBUG_FORTH_DOT 
457a				DMARK "DTi" 
457a f5				push af  
457b 3a 8f 45			ld a, (.dmark)  
457e 32 9d fd			ld (debug_mark),a  
4581 3a 90 45			ld a, (.dmark+1)  
4584 32 9e fd			ld (debug_mark+1),a  
4587 3a 91 45			ld a, (.dmark+2)  
458a 32 9f fd			ld (debug_mark+2),a  
458d 18 03			jr .pastdmark  
458f ..			.dmark: db "DTi"  
4592 f1			.pastdmark: pop af  
4593			endm  
# End of macro DMARK
4593				CALLMONITOR 
4593 cd aa fd			call debug_vector  
4596				endm  
# End of macro CALLMONITOR
4596			endif	 
4596			 
4596			 
4596					NEXTW 
4596 cd a7 fd			call parse_vector 
4599 c3 53 23			jp macro_next 
459c				endm 
# End of macro NEXTW
459c			 
459c			.CLS: 
459c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
459c 35				db WORD_SYS_CORE+33             
459d cc 45			dw .DRAW            
459f 04				db 3 + 1 
45a0 .. 00			db "CLS",0              
45a4				endm 
# End of macro CWHEAD
45a4			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
45a4					if DEBUG_FORTH_WORDS_KEY 
45a4						DMARK "CLS" 
45a4 f5				push af  
45a5 3a b9 45			ld a, (.dmark)  
45a8 32 9d fd			ld (debug_mark),a  
45ab 3a ba 45			ld a, (.dmark+1)  
45ae 32 9e fd			ld (debug_mark+1),a  
45b1 3a bb 45			ld a, (.dmark+2)  
45b4 32 9f fd			ld (debug_mark+2),a  
45b7 18 03			jr .pastdmark  
45b9 ..			.dmark: db "CLS"  
45bc f1			.pastdmark: pop af  
45bd			endm  
# End of macro DMARK
45bd						CALLMONITOR 
45bd cd aa fd			call debug_vector  
45c0				endm  
# End of macro CALLMONITOR
45c0					endif 
45c0 cd 7c 0d				call clear_display 
45c3 c3 e6 46				jp .home		; and home cursor 
45c6					NEXTW 
45c6 cd a7 fd			call parse_vector 
45c9 c3 53 23			jp macro_next 
45cc				endm 
# End of macro NEXTW
45cc			 
45cc			.DRAW: 
45cc				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
45cc 36				db WORD_SYS_CORE+34             
45cd fa 45			dw .DUMP            
45cf 05				db 4 + 1 
45d0 .. 00			db "DRAW",0              
45d5				endm 
# End of macro CWHEAD
45d5			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
45d5					if DEBUG_FORTH_WORDS_KEY 
45d5						DMARK "DRW" 
45d5 f5				push af  
45d6 3a ea 45			ld a, (.dmark)  
45d9 32 9d fd			ld (debug_mark),a  
45dc 3a eb 45			ld a, (.dmark+1)  
45df 32 9e fd			ld (debug_mark+1),a  
45e2 3a ec 45			ld a, (.dmark+2)  
45e5 32 9f fd			ld (debug_mark+2),a  
45e8 18 03			jr .pastdmark  
45ea ..			.dmark: db "DRW"  
45ed f1			.pastdmark: pop af  
45ee			endm  
# End of macro DMARK
45ee						CALLMONITOR 
45ee cd aa fd			call debug_vector  
45f1				endm  
# End of macro CALLMONITOR
45f1					endif 
45f1 cd 9e 0d				call update_display 
45f4					NEXTW 
45f4 cd a7 fd			call parse_vector 
45f7 c3 53 23			jp macro_next 
45fa				endm 
# End of macro NEXTW
45fa			 
45fa			.DUMP: 
45fa				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
45fa 37				db WORD_SYS_CORE+35             
45fb 35 46			dw .CDUMP            
45fd 05				db 4 + 1 
45fe .. 00			db "DUMP",0              
4603				endm 
# End of macro CWHEAD
4603			; | DUMP ( x -- ) With address x display dump   | DONE 
4603			; TODO pop address to use off of the stack 
4603					if DEBUG_FORTH_WORDS_KEY 
4603						DMARK "DUM" 
4603 f5				push af  
4604 3a 18 46			ld a, (.dmark)  
4607 32 9d fd			ld (debug_mark),a  
460a 3a 19 46			ld a, (.dmark+1)  
460d 32 9e fd			ld (debug_mark+1),a  
4610 3a 1a 46			ld a, (.dmark+2)  
4613 32 9f fd			ld (debug_mark+2),a  
4616 18 03			jr .pastdmark  
4618 ..			.dmark: db "DUM"  
461b f1			.pastdmark: pop af  
461c			endm  
# End of macro DMARK
461c						CALLMONITOR 
461c cd aa fd			call debug_vector  
461f				endm  
# End of macro CALLMONITOR
461f					endif 
461f cd 7c 0d				call clear_display 
4622			 
4622					; get address 
4622			 
4622					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4622 cd 6c 21			call macro_dsp_valuehl 
4625				endm 
# End of macro FORTH_DSP_VALUEHL
4625				 
4625					; save it for cdump 
4625			 
4625 22 16 f4				ld (os_cur_ptr),hl 
4628			 
4628					; destroy value TOS 
4628			 
4628					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4628 cd 24 22			call macro_forth_dsp_pop 
462b				endm 
# End of macro FORTH_DSP_POP
462b			 
462b cd f4 1d				call dumpcont	; skip old style of param parsing	 
462e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
462f					NEXTW 
462f cd a7 fd			call parse_vector 
4632 c3 53 23			jp macro_next 
4635				endm 
# End of macro NEXTW
4635			.CDUMP: 
4635				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4635 38				db WORD_SYS_CORE+36             
4636 68 46			dw .DAT            
4638 06				db 5 + 1 
4639 .. 00			db "CDUMP",0              
463f				endm 
# End of macro CWHEAD
463f			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
463f					if DEBUG_FORTH_WORDS_KEY 
463f						DMARK "CDP" 
463f f5				push af  
4640 3a 54 46			ld a, (.dmark)  
4643 32 9d fd			ld (debug_mark),a  
4646 3a 55 46			ld a, (.dmark+1)  
4649 32 9e fd			ld (debug_mark+1),a  
464c 3a 56 46			ld a, (.dmark+2)  
464f 32 9f fd			ld (debug_mark+2),a  
4652 18 03			jr .pastdmark  
4654 ..			.dmark: db "CDP"  
4657 f1			.pastdmark: pop af  
4658			endm  
# End of macro DMARK
4658						CALLMONITOR 
4658 cd aa fd			call debug_vector  
465b				endm  
# End of macro CALLMONITOR
465b					endif 
465b cd 7c 0d				call clear_display 
465e cd f4 1d				call dumpcont	 
4661 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4662					NEXTW 
4662 cd a7 fd			call parse_vector 
4665 c3 53 23			jp macro_next 
4668				endm 
# End of macro NEXTW
4668			 
4668			 
4668			 
4668			 
4668			.DAT: 
4668				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4668 3d				db WORD_SYS_CORE+41             
4669 c1 46			dw .HOME            
466b 03				db 2 + 1 
466c .. 00			db "AT",0              
466f				endm 
# End of macro CWHEAD
466f			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
466f					if DEBUG_FORTH_WORDS_KEY 
466f						DMARK "AT." 
466f f5				push af  
4670 3a 84 46			ld a, (.dmark)  
4673 32 9d fd			ld (debug_mark),a  
4676 3a 85 46			ld a, (.dmark+1)  
4679 32 9e fd			ld (debug_mark+1),a  
467c 3a 86 46			ld a, (.dmark+2)  
467f 32 9f fd			ld (debug_mark+2),a  
4682 18 03			jr .pastdmark  
4684 ..			.dmark: db "AT."  
4687 f1			.pastdmark: pop af  
4688			endm  
# End of macro DMARK
4688						CALLMONITOR 
4688 cd aa fd			call debug_vector  
468b				endm  
# End of macro CALLMONITOR
468b					endif 
468b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
468b cd 6c 21			call macro_dsp_valuehl 
468e				endm 
# End of macro FORTH_DSP_VALUEHL
468e			 
468e			 
468e					; TODO save cursor row 
468e 7d					ld a,l 
468f fe 02				cp 2 
4691 20 04				jr nz, .crow3 
4693 3e 28				ld a, display_row_2 
4695 18 12				jr .ccol1 
4697 fe 03		.crow3:		cp 3 
4699 20 04				jr nz, .crow4 
469b 3e 50				ld a, display_row_3 
469d 18 0a				jr .ccol1 
469f fe 04		.crow4:		cp 4 
46a1 20 04				jr nz, .crow1 
46a3 3e 78				ld a, display_row_4 
46a5 18 02				jr .ccol1 
46a7 3e 00		.crow1:		ld a,display_row_1 
46a9 f5			.ccol1:		push af			; got row offset 
46aa 6f					ld l,a 
46ab 26 00				ld h,0 
46ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46ad cd 24 22			call macro_forth_dsp_pop 
46b0				endm 
# End of macro FORTH_DSP_POP
46b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46b0 cd 6c 21			call macro_dsp_valuehl 
46b3				endm 
# End of macro FORTH_DSP_VALUEHL
46b3					; TODO save cursor col 
46b3 f1					pop af 
46b4 85					add l		; add col offset 
46b5 32 90 f9				ld (f_cursor_ptr), a 
46b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46b8 cd 24 22			call macro_forth_dsp_pop 
46bb				endm 
# End of macro FORTH_DSP_POP
46bb			 
46bb					; calculate  
46bb			 
46bb					NEXTW 
46bb cd a7 fd			call parse_vector 
46be c3 53 23			jp macro_next 
46c1				endm 
# End of macro NEXTW
46c1			 
46c1			 
46c1			.HOME: 
46c1				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
46c1 41				db WORD_SYS_CORE+45             
46c2 f1 46			dw .CR            
46c4 05				db 4 + 1 
46c5 .. 00			db "HOME",0              
46ca				endm 
# End of macro CWHEAD
46ca			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
46ca					if DEBUG_FORTH_WORDS_KEY 
46ca						DMARK "HOM" 
46ca f5				push af  
46cb 3a df 46			ld a, (.dmark)  
46ce 32 9d fd			ld (debug_mark),a  
46d1 3a e0 46			ld a, (.dmark+1)  
46d4 32 9e fd			ld (debug_mark+1),a  
46d7 3a e1 46			ld a, (.dmark+2)  
46da 32 9f fd			ld (debug_mark+2),a  
46dd 18 03			jr .pastdmark  
46df ..			.dmark: db "HOM"  
46e2 f1			.pastdmark: pop af  
46e3			endm  
# End of macro DMARK
46e3						CALLMONITOR 
46e3 cd aa fd			call debug_vector  
46e6				endm  
# End of macro CALLMONITOR
46e6					endif 
46e6 3e 00		.home:		ld a, 0		; and home cursor 
46e8 32 90 f9				ld (f_cursor_ptr), a 
46eb					NEXTW 
46eb cd a7 fd			call parse_vector 
46ee c3 53 23			jp macro_next 
46f1				endm 
# End of macro NEXTW
46f1			 
46f1			 
46f1			.CR: 
46f1				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
46f1 46				db WORD_SYS_CORE+50             
46f2 2f 47			dw .SPACE            
46f4 03				db 2 + 1 
46f5 .. 00			db "CR",0              
46f8				endm 
# End of macro CWHEAD
46f8			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
46f8					if DEBUG_FORTH_WORDS_KEY 
46f8						DMARK "CR." 
46f8 f5				push af  
46f9 3a 0d 47			ld a, (.dmark)  
46fc 32 9d fd			ld (debug_mark),a  
46ff 3a 0e 47			ld a, (.dmark+1)  
4702 32 9e fd			ld (debug_mark+1),a  
4705 3a 0f 47			ld a, (.dmark+2)  
4708 32 9f fd			ld (debug_mark+2),a  
470b 18 03			jr .pastdmark  
470d ..			.dmark: db "CR."  
4710 f1			.pastdmark: pop af  
4711			endm  
# End of macro DMARK
4711						CALLMONITOR 
4711 cd aa fd			call debug_vector  
4714				endm  
# End of macro CALLMONITOR
4714					endif 
4714 3e 0d				ld a, 13 
4716 32 f3 f0				ld (scratch),a 
4719 3e 0a				ld a, 10 
471b 32 f4 f0				ld (scratch+1),a 
471e 3e 00				ld a, 0 
4720 32 f5 f0				ld (scratch+2),a 
4723 21 f3 f0				ld hl, scratch 
4726 cd da 1f				call forth_push_str 
4729					 
4729				       NEXTW 
4729 cd a7 fd			call parse_vector 
472c c3 53 23			jp macro_next 
472f				endm 
# End of macro NEXTW
472f			.SPACE: 
472f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
472f 46				db WORD_SYS_CORE+50             
4730 68 47			dw .SPACES            
4732 03				db 2 + 1 
4733 .. 00			db "BL",0              
4736				endm 
# End of macro CWHEAD
4736			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4736					if DEBUG_FORTH_WORDS_KEY 
4736						DMARK "BL." 
4736 f5				push af  
4737 3a 4b 47			ld a, (.dmark)  
473a 32 9d fd			ld (debug_mark),a  
473d 3a 4c 47			ld a, (.dmark+1)  
4740 32 9e fd			ld (debug_mark+1),a  
4743 3a 4d 47			ld a, (.dmark+2)  
4746 32 9f fd			ld (debug_mark+2),a  
4749 18 03			jr .pastdmark  
474b ..			.dmark: db "BL."  
474e f1			.pastdmark: pop af  
474f			endm  
# End of macro DMARK
474f						CALLMONITOR 
474f cd aa fd			call debug_vector  
4752				endm  
# End of macro CALLMONITOR
4752					endif 
4752 3e 20				ld a, " " 
4754 32 f3 f0				ld (scratch),a 
4757 3e 00				ld a, 0 
4759 32 f4 f0				ld (scratch+1),a 
475c 21 f3 f0				ld hl, scratch 
475f cd da 1f				call forth_push_str 
4762					 
4762				       NEXTW 
4762 cd a7 fd			call parse_vector 
4765 c3 53 23			jp macro_next 
4768				endm 
# End of macro NEXTW
4768			 
4768			;.blstr: db " ", 0 
4768			 
4768			.SPACES: 
4768				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4768 47				db WORD_SYS_CORE+51             
4769 04 48			dw .SCROLL            
476b 07				db 6 + 1 
476c .. 00			db "SPACES",0              
4773				endm 
# End of macro CWHEAD
4773			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4773					if DEBUG_FORTH_WORDS_KEY 
4773						DMARK "SPS" 
4773 f5				push af  
4774 3a 88 47			ld a, (.dmark)  
4777 32 9d fd			ld (debug_mark),a  
477a 3a 89 47			ld a, (.dmark+1)  
477d 32 9e fd			ld (debug_mark+1),a  
4780 3a 8a 47			ld a, (.dmark+2)  
4783 32 9f fd			ld (debug_mark+2),a  
4786 18 03			jr .pastdmark  
4788 ..			.dmark: db "SPS"  
478b f1			.pastdmark: pop af  
478c			endm  
# End of macro DMARK
478c						CALLMONITOR 
478c cd aa fd			call debug_vector  
478f				endm  
# End of macro CALLMONITOR
478f					endif 
478f			 
478f			 
478f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
478f cd 6c 21			call macro_dsp_valuehl 
4792				endm 
# End of macro FORTH_DSP_VALUEHL
4792			 
4792 e5					push hl    ; u 
4793					if DEBUG_FORTH_WORDS 
4793						DMARK "SPA" 
4793 f5				push af  
4794 3a a8 47			ld a, (.dmark)  
4797 32 9d fd			ld (debug_mark),a  
479a 3a a9 47			ld a, (.dmark+1)  
479d 32 9e fd			ld (debug_mark+1),a  
47a0 3a aa 47			ld a, (.dmark+2)  
47a3 32 9f fd			ld (debug_mark+2),a  
47a6 18 03			jr .pastdmark  
47a8 ..			.dmark: db "SPA"  
47ab f1			.pastdmark: pop af  
47ac			endm  
# End of macro DMARK
47ac						CALLMONITOR 
47ac cd aa fd			call debug_vector  
47af				endm  
# End of macro CALLMONITOR
47af					endif 
47af			 
47af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47af cd 24 22			call macro_forth_dsp_pop 
47b2				endm 
# End of macro FORTH_DSP_POP
47b2 e1					pop hl 
47b3 0e 00				ld c, 0 
47b5 45					ld b, l 
47b6 21 f3 f0				ld hl, scratch  
47b9			 
47b9					if DEBUG_FORTH_WORDS 
47b9						DMARK "SP2" 
47b9 f5				push af  
47ba 3a ce 47			ld a, (.dmark)  
47bd 32 9d fd			ld (debug_mark),a  
47c0 3a cf 47			ld a, (.dmark+1)  
47c3 32 9e fd			ld (debug_mark+1),a  
47c6 3a d0 47			ld a, (.dmark+2)  
47c9 32 9f fd			ld (debug_mark+2),a  
47cc 18 03			jr .pastdmark  
47ce ..			.dmark: db "SP2"  
47d1 f1			.pastdmark: pop af  
47d2			endm  
# End of macro DMARK
47d2						CALLMONITOR 
47d2 cd aa fd			call debug_vector  
47d5				endm  
# End of macro CALLMONITOR
47d5					endif 
47d5			;		ld a, ' ' 
47d5			.spaces1:	 
47d5 36 20				ld (hl),' ' 
47d7 23					inc hl 
47d8					 
47d8 10 fb				djnz .spaces1 
47da			;		ld a,0 
47da 36 00				ld (hl),0 
47dc 21 f3 f0				ld hl, scratch 
47df					if DEBUG_FORTH_WORDS 
47df						DMARK "SP3" 
47df f5				push af  
47e0 3a f4 47			ld a, (.dmark)  
47e3 32 9d fd			ld (debug_mark),a  
47e6 3a f5 47			ld a, (.dmark+1)  
47e9 32 9e fd			ld (debug_mark+1),a  
47ec 3a f6 47			ld a, (.dmark+2)  
47ef 32 9f fd			ld (debug_mark+2),a  
47f2 18 03			jr .pastdmark  
47f4 ..			.dmark: db "SP3"  
47f7 f1			.pastdmark: pop af  
47f8			endm  
# End of macro DMARK
47f8						CALLMONITOR 
47f8 cd aa fd			call debug_vector  
47fb				endm  
# End of macro CALLMONITOR
47fb					endif 
47fb cd da 1f				call forth_push_str 
47fe			 
47fe				       NEXTW 
47fe cd a7 fd			call parse_vector 
4801 c3 53 23			jp macro_next 
4804				endm 
# End of macro NEXTW
4804			 
4804			 
4804			 
4804			.SCROLL: 
4804				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4804 53				db WORD_SYS_CORE+63             
4805 34 48			dw .SCROLLD            
4807 07				db 6 + 1 
4808 .. 00			db "SCROLL",0              
480f				endm 
# End of macro CWHEAD
480f			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
480f					if DEBUG_FORTH_WORDS_KEY 
480f						DMARK "SCR" 
480f f5				push af  
4810 3a 24 48			ld a, (.dmark)  
4813 32 9d fd			ld (debug_mark),a  
4816 3a 25 48			ld a, (.dmark+1)  
4819 32 9e fd			ld (debug_mark+1),a  
481c 3a 26 48			ld a, (.dmark+2)  
481f 32 9f fd			ld (debug_mark+2),a  
4822 18 03			jr .pastdmark  
4824 ..			.dmark: db "SCR"  
4827 f1			.pastdmark: pop af  
4828			endm  
# End of macro DMARK
4828						CALLMONITOR 
4828 cd aa fd			call debug_vector  
482b				endm  
# End of macro CALLMONITOR
482b					endif 
482b			 
482b cd 3f 0d			call scroll_up 
482e			;	call update_display 
482e			 
482e					NEXTW 
482e cd a7 fd			call parse_vector 
4831 c3 53 23			jp macro_next 
4834				endm 
# End of macro NEXTW
4834			 
4834			 
4834			 
4834			;		; get dir 
4834			; 
4834			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4834			; 
4834			;		push hl 
4834			; 
4834			;		; destroy value TOS 
4834			; 
4834			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4834			; 
4834			;		; get count 
4834			; 
4834			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4834			; 
4834			;		push hl 
4834			; 
4834			;		; destroy value TOS 
4834			; 
4834			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4834			; 
4834			;		; one value on hl get other one back 
4834			; 
4834			;		pop bc    ; count 
4834			; 
4834			;		pop de   ; dir 
4834			; 
4834			; 
4834			;		ld b, c 
4834			; 
4834			;.scrolldir:     push bc 
4834			;		push de 
4834			; 
4834			;		ld a, 0 
4834			;		cp e 
4834			;		jr z, .scrollup  
4834			;		call scroll_down 
4834			;		jr .scrollnext 
4834			;.scrollup:	call scroll_up 
4834			; 
4834			;		 
4834			;.scrollnext: 
4834			;		pop de 
4834			;		pop bc 
4834			;		djnz .scrolldir 
4834			; 
4834			; 
4834			; 
4834			; 
4834			; 
4834			;		NEXTW 
4834			 
4834			.SCROLLD: 
4834				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4834 53				db WORD_SYS_CORE+63             
4835 65 48			dw .ATQ            
4837 08				db 7 + 1 
4838 .. 00			db "SCROLLD",0              
4840				endm 
# End of macro CWHEAD
4840			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4840					if DEBUG_FORTH_WORDS_KEY 
4840						DMARK "SCD" 
4840 f5				push af  
4841 3a 55 48			ld a, (.dmark)  
4844 32 9d fd			ld (debug_mark),a  
4847 3a 56 48			ld a, (.dmark+1)  
484a 32 9e fd			ld (debug_mark+1),a  
484d 3a 57 48			ld a, (.dmark+2)  
4850 32 9f fd			ld (debug_mark+2),a  
4853 18 03			jr .pastdmark  
4855 ..			.dmark: db "SCD"  
4858 f1			.pastdmark: pop af  
4859			endm  
# End of macro DMARK
4859						CALLMONITOR 
4859 cd aa fd			call debug_vector  
485c				endm  
# End of macro CALLMONITOR
485c					endif 
485c			 
485c cd 62 0d			call scroll_down 
485f			;	call update_display 
485f			 
485f					NEXTW 
485f cd a7 fd			call parse_vector 
4862 c3 53 23			jp macro_next 
4865				endm 
# End of macro NEXTW
4865			 
4865			 
4865			.ATQ: 
4865				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4865 62				db WORD_SYS_CORE+78             
4866 c6 48			dw .AUTODSP            
4868 04				db 3 + 1 
4869 .. 00			db "AT@",0              
486d				endm 
# End of macro CWHEAD
486d			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
486d					if DEBUG_FORTH_WORDS_KEY 
486d						DMARK "ATA" 
486d f5				push af  
486e 3a 82 48			ld a, (.dmark)  
4871 32 9d fd			ld (debug_mark),a  
4874 3a 83 48			ld a, (.dmark+1)  
4877 32 9e fd			ld (debug_mark+1),a  
487a 3a 84 48			ld a, (.dmark+2)  
487d 32 9f fd			ld (debug_mark+2),a  
4880 18 03			jr .pastdmark  
4882 ..			.dmark: db "ATA"  
4885 f1			.pastdmark: pop af  
4886			endm  
# End of macro DMARK
4886						CALLMONITOR 
4886 cd aa fd			call debug_vector  
4889				endm  
# End of macro CALLMONITOR
4889					endif 
4889			 
4889			 
4889					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4889 cd 6c 21			call macro_dsp_valuehl 
488c				endm 
# End of macro FORTH_DSP_VALUEHL
488c			 
488c					; TODO save cursor row 
488c 7d					ld a,l 
488d fe 02				cp 2 
488f 20 04				jr nz, .crow3aq 
4891 3e 28				ld a, display_row_2 
4893 18 12				jr .ccol1aq 
4895 fe 03		.crow3aq:		cp 3 
4897 20 04				jr nz, .crow4aq 
4899 3e 50				ld a, display_row_3 
489b 18 0a				jr .ccol1aq 
489d fe 04		.crow4aq:		cp 4 
489f 20 04				jr nz, .crow1aq 
48a1 3e 78				ld a, display_row_4 
48a3 18 02				jr .ccol1aq 
48a5 3e 00		.crow1aq:		ld a,display_row_1 
48a7 f5			.ccol1aq:		push af			; got row offset 
48a8 6f					ld l,a 
48a9 26 00				ld h,0 
48ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48ab cd 24 22			call macro_forth_dsp_pop 
48ae				endm 
# End of macro FORTH_DSP_POP
48ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48ae cd 6c 21			call macro_dsp_valuehl 
48b1				endm 
# End of macro FORTH_DSP_VALUEHL
48b1					; TODO save cursor col 
48b1 f1					pop af 
48b2 85					add l		; add col offset 
48b3			 
48b3					; add current frame buffer address 
48b3 2a fe fa				ld hl, (display_fb_active) 
48b6 cd ac 0f				call addatohl 
48b9			 
48b9			 
48b9			 
48b9			 
48b9					; get char frame buffer location offset in hl 
48b9			 
48b9 7e					ld a,(hl) 
48ba 26 00				ld h, 0 
48bc 6f					ld l, a 
48bd			 
48bd cd 70 1f				call forth_push_numhl 
48c0			 
48c0			 
48c0					NEXTW 
48c0 cd a7 fd			call parse_vector 
48c3 c3 53 23			jp macro_next 
48c6				endm 
# End of macro NEXTW
48c6			 
48c6			.AUTODSP: 
48c6				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
48c6 63				db WORD_SYS_CORE+79             
48c7 df 48			dw .MENU            
48c9 05				db 4 + 1 
48ca .. 00			db "ADSP",0              
48cf				endm 
# End of macro CWHEAD
48cf			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
48cf			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
48cf			 
48cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48cf cd 6c 21			call macro_dsp_valuehl 
48d2				endm 
# End of macro FORTH_DSP_VALUEHL
48d2			 
48d2			;		push hl 
48d2			 
48d2					; destroy value TOS 
48d2			 
48d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48d2 cd 24 22			call macro_forth_dsp_pop 
48d5				endm 
# End of macro FORTH_DSP_POP
48d5			 
48d5			;		pop hl 
48d5			 
48d5 7d					ld a,l 
48d6 32 6e f9				ld (cli_autodisplay), a 
48d9				       NEXTW 
48d9 cd a7 fd			call parse_vector 
48dc c3 53 23			jp macro_next 
48df				endm 
# End of macro NEXTW
48df			 
48df			.MENU: 
48df				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
48df 70				db WORD_SYS_CORE+92             
48e0 8b 49			dw .ENDDISPLAY            
48e2 05				db 4 + 1 
48e3 .. 00			db "MENU",0              
48e8				endm 
# End of macro CWHEAD
48e8			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
48e8			 
48e8			;		; get number of items on the stack 
48e8			; 
48e8				 
48e8					FORTH_DSP_VALUEHL 
48e8 cd 6c 21			call macro_dsp_valuehl 
48eb				endm 
# End of macro FORTH_DSP_VALUEHL
48eb				 
48eb					if DEBUG_FORTH_WORDS_KEY 
48eb						DMARK "MNU" 
48eb f5				push af  
48ec 3a 00 49			ld a, (.dmark)  
48ef 32 9d fd			ld (debug_mark),a  
48f2 3a 01 49			ld a, (.dmark+1)  
48f5 32 9e fd			ld (debug_mark+1),a  
48f8 3a 02 49			ld a, (.dmark+2)  
48fb 32 9f fd			ld (debug_mark+2),a  
48fe 18 03			jr .pastdmark  
4900 ..			.dmark: db "MNU"  
4903 f1			.pastdmark: pop af  
4904			endm  
# End of macro DMARK
4904						CALLMONITOR 
4904 cd aa fd			call debug_vector  
4907				endm  
# End of macro CALLMONITOR
4907					endif 
4907			 
4907 45					ld b, l	 
4908 05					dec b 
4909			 
4909					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4909 cd 24 22			call macro_forth_dsp_pop 
490c				endm 
# End of macro FORTH_DSP_POP
490c			 
490c			 
490c					; go directly through the stack to pluck out the string pointers and build an array 
490c			 
490c			;		FORTH_DSP 
490c			 
490c					; hl contains top most stack item 
490c				 
490c 11 f3 f0				ld de, scratch 
490f			 
490f			.mbuild: 
490f			 
490f					FORTH_DSP_VALUEHL 
490f cd 6c 21			call macro_dsp_valuehl 
4912				endm 
# End of macro FORTH_DSP_VALUEHL
4912			 
4912					if DEBUG_FORTH_WORDS 
4912						DMARK "MN3" 
4912 f5				push af  
4913 3a 27 49			ld a, (.dmark)  
4916 32 9d fd			ld (debug_mark),a  
4919 3a 28 49			ld a, (.dmark+1)  
491c 32 9e fd			ld (debug_mark+1),a  
491f 3a 29 49			ld a, (.dmark+2)  
4922 32 9f fd			ld (debug_mark+2),a  
4925 18 03			jr .pastdmark  
4927 ..			.dmark: db "MN3"  
492a f1			.pastdmark: pop af  
492b			endm  
# End of macro DMARK
492b						CALLMONITOR 
492b cd aa fd			call debug_vector  
492e				endm  
# End of macro CALLMONITOR
492e					endif 
492e eb					ex de, hl 
492f 73					ld (hl), e 
4930 23					inc hl 
4931 72					ld (hl), d 
4932 23					inc hl 
4933 eb					ex de, hl 
4934			 
4934					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4934 cd 24 22			call macro_forth_dsp_pop 
4937				endm 
# End of macro FORTH_DSP_POP
4937			 
4937 10 d6				djnz .mbuild 
4939			 
4939					; done add term 
4939			 
4939 eb					ex de, hl 
493a 36 00				ld (hl), 0 
493c 23					inc hl 
493d 36 00				ld (hl), 0 
493f			 
493f				 
493f					 
493f 21 f3 f0				ld hl, scratch 
4942			 
4942					if DEBUG_FORTH_WORDS 
4942						DMARK "MNx" 
4942 f5				push af  
4943 3a 57 49			ld a, (.dmark)  
4946 32 9d fd			ld (debug_mark),a  
4949 3a 58 49			ld a, (.dmark+1)  
494c 32 9e fd			ld (debug_mark+1),a  
494f 3a 59 49			ld a, (.dmark+2)  
4952 32 9f fd			ld (debug_mark+2),a  
4955 18 03			jr .pastdmark  
4957 ..			.dmark: db "MNx"  
495a f1			.pastdmark: pop af  
495b			endm  
# End of macro DMARK
495b						CALLMONITOR 
495b cd aa fd			call debug_vector  
495e				endm  
# End of macro CALLMONITOR
495e					endif 
495e			 
495e			 
495e			 
495e 3e 00				ld a, 0 
4960 cd ac 0d				call menu 
4963			 
4963			 
4963 6f					ld l, a 
4964 26 00				ld h, 0 
4966			 
4966					if DEBUG_FORTH_WORDS 
4966						DMARK "MNr" 
4966 f5				push af  
4967 3a 7b 49			ld a, (.dmark)  
496a 32 9d fd			ld (debug_mark),a  
496d 3a 7c 49			ld a, (.dmark+1)  
4970 32 9e fd			ld (debug_mark+1),a  
4973 3a 7d 49			ld a, (.dmark+2)  
4976 32 9f fd			ld (debug_mark+2),a  
4979 18 03			jr .pastdmark  
497b ..			.dmark: db "MNr"  
497e f1			.pastdmark: pop af  
497f			endm  
# End of macro DMARK
497f						CALLMONITOR 
497f cd aa fd			call debug_vector  
4982				endm  
# End of macro CALLMONITOR
4982					endif 
4982			 
4982 cd 70 1f				call forth_push_numhl 
4985			 
4985			 
4985			 
4985			 
4985				       NEXTW 
4985 cd a7 fd			call parse_vector 
4988 c3 53 23			jp macro_next 
498b				endm 
# End of macro NEXTW
498b			 
498b			 
498b			.ENDDISPLAY: 
498b			 
498b			; eof 
# End of file forth_words_display.asm
498b			include "forth_words_str.asm" 
498b			 
498b			; | ## String Words 
498b			 
498b			.CONST: 
498b				 
498b				CWHEAD .MOVE 52 "CONST" 5 WORD_FLAG_CODE 
498b 48				db WORD_SYS_CORE+52             
498c a0 49			dw .MOVE            
498e 06				db 5 + 1 
498f .. 00			db "CONST",0              
4995				endm 
# End of macro CWHEAD
4995			; | CONST ( u -- u ) Change the type of var on TOS to a constant. i.e. if a string it won't be freed on consuption, | TODO 
4995					FORTH_DSP 
4995 cd 32 21			call macro_forth_dsp 
4998				endm 
# End of macro FORTH_DSP
4998 36 04				ld (hl), DS_TYPE_CONST 
499a					NEXTW 
499a cd a7 fd			call parse_vector 
499d c3 53 23			jp macro_next 
49a0				endm 
# End of macro NEXTW
49a0			 
49a0			.MOVE:   
49a0			 
49a0				CWHEAD .ZMOVE 52 "MOVE" 4 WORD_FLAG_CODE 
49a0 48				db WORD_SYS_CORE+52             
49a1 c7 49			dw .ZMOVE            
49a3 05				db 4 + 1 
49a4 .. 00			db "MOVE",0              
49a9				endm 
# End of macro CWHEAD
49a9			; | MOVE ( a1 a2 c -- ) Copy from address a1 to address a2 for the length of c | DONE 
49a9			 
49a9					FORTH_DSP_VALUEHL 
49a9 cd 6c 21			call macro_dsp_valuehl 
49ac				endm 
# End of macro FORTH_DSP_VALUEHL
49ac e5					push hl    ; push count 
49ad			 
49ad					FORTH_DSP_POP 
49ad cd 24 22			call macro_forth_dsp_pop 
49b0				endm 
# End of macro FORTH_DSP_POP
49b0			 
49b0					FORTH_DSP_VALUEHL 
49b0 cd 6c 21			call macro_dsp_valuehl 
49b3				endm 
# End of macro FORTH_DSP_VALUEHL
49b3 e5					push hl    ; dest 
49b4			 
49b4					FORTH_DSP_POP 
49b4 cd 24 22			call macro_forth_dsp_pop 
49b7				endm 
# End of macro FORTH_DSP_POP
49b7			 
49b7					FORTH_DSP_VALUEHL 
49b7 cd 6c 21			call macro_dsp_valuehl 
49ba				endm 
# End of macro FORTH_DSP_VALUEHL
49ba			 
49ba					FORTH_DSP_POP 
49ba cd 24 22			call macro_forth_dsp_pop 
49bd				endm 
# End of macro FORTH_DSP_POP
49bd			 
49bd d1					pop de 
49be c1					pop bc 
49bf				 
49bf ed b0				ldir 
49c1				NEXTW 
49c1 cd a7 fd			call parse_vector 
49c4 c3 53 23			jp macro_next 
49c7				endm 
# End of macro NEXTW
49c7			.ZMOVE:   
49c7			 
49c7				CWHEAD .TABLE 52 "ZMOVE" 5 WORD_FLAG_CODE 
49c7 48				db WORD_SYS_CORE+52             
49c8 f0 49			dw .TABLE            
49ca 06				db 5 + 1 
49cb .. 00			db "ZMOVE",0              
49d1				endm 
# End of macro CWHEAD
49d1					 
49d1			; | ZMOVE ( a1 a2 -- ) Copy from address a1 to address a2 until a1 hits zero term string | DONE 
49d1			; | | Ensure you have enough space! 
49d1			 
49d1			 
49d1					FORTH_DSP_VALUEHL 
49d1 cd 6c 21			call macro_dsp_valuehl 
49d4				endm 
# End of macro FORTH_DSP_VALUEHL
49d4 e5					push hl    ; dest 
49d5			 
49d5					FORTH_DSP_POP 
49d5 cd 24 22			call macro_forth_dsp_pop 
49d8				endm 
# End of macro FORTH_DSP_POP
49d8			 
49d8					FORTH_DSP_VALUEHL 
49d8 cd 6c 21			call macro_dsp_valuehl 
49db				endm 
# End of macro FORTH_DSP_VALUEHL
49db			 
49db					FORTH_DSP_POP 
49db cd 24 22			call macro_forth_dsp_pop 
49de				endm 
# End of macro FORTH_DSP_POP
49de			 
49de d1					pop de 
49df			 
49df 01 ff 00				ld bc, 255 
49e2 ed a0		.zmovel:	ldi 
49e4 2b					dec hl 
49e5 7e					ld a,(hl) 
49e6 23					inc hl 
49e7 b7					or a  
49e8 20 f8				jr nz, .zmovel    
49ea					 
49ea			 
49ea				NEXTW 
49ea cd a7 fd			call parse_vector 
49ed c3 53 23			jp macro_next 
49f0				endm 
# End of macro NEXTW
49f0			 
49f0			.TABLE:   
49f0			 
49f0				CWHEAD .SPLIT 52 "TABLE" 5 WORD_FLAG_CODE 
49f0 48				db WORD_SYS_CORE+52             
49f1 55 4a			dw .SPLIT            
49f3 06				db 5 + 1 
49f4 .. 00			db "TABLE",0              
49fa				endm 
# End of macro CWHEAD
49fa					 
49fa			; | TABLE ( s .. sx c -- a) For the number c of strings s on the stack. Generate a look up table array a | DONE 
49fa			; | | Takes a list of strings and creates a block of pointers to each string which can then be used 
49fa			; | | in any kind of lookup or iteration.  
49fa			; | | Last item in the array will be a zero pointer for ease of iteration 
49fa			 
49fa			 
49fa				; get the count of strings 
49fa			 
49fa					FORTH_DSP_VALUEHL 
49fa cd 6c 21			call macro_dsp_valuehl 
49fd				endm 
# End of macro FORTH_DSP_VALUEHL
49fd			 
49fd					FORTH_DSP_POP 
49fd cd 24 22			call macro_forth_dsp_pop 
4a00				endm 
# End of macro FORTH_DSP_POP
4a00			 
4a00				; allocate memory for (count + 1 ) * 2 for word array plus zero pointer 
4a00			 
4a00					; l contains count 
4a00			 
4a00 7d					ld a,l 
4a01 32 f3 f0				ld (scratch), a     ; save it for the loading loop 
4a04			 
4a04 2c					inc l  ; for zero pointer 
4a05 eb					ex de, hl 
4a06 3e 02				ld a, 2 
4a08 cd 2f 0f				call Mult16 
4a0b			 
4a0b					; hl is the size of block to allocate 
4a0b			 
4a0b cd 78 13				call malloc 
4a0e				if DEBUG_FORTH_MALLOC_GUARD 
4a0e cc 37 65				call z,malloc_error 
4a11				endif 
4a11					; hl is the pointer to the array block 
4a11						 
4a11 22 f4 f0				ld (scratch+1), hl    ; save the base for later push to stack 
4a14 22 f6 f0				ld (scratch+3), hl    ; save the base for current string to push 
4a17			 
4a17 3a f3 f0				ld a, (scratch) 
4a1a 47					ld b, a 
4a1b			 
4a1b				; for each string 
4a1b			 
4a1b			.tablelop: 
4a1b			 
4a1b c5					push bc 
4a1c			 
4a1c				;     get string pointer 
4a1c			 
4a1c					FORTH_DSP_VALUEHL 
4a1c cd 6c 21			call macro_dsp_valuehl 
4a1f				endm 
# End of macro FORTH_DSP_VALUEHL
4a1f			 
4a1f e5					push hl 
4a20			 
4a20				;     get string length 
4a20			 
4a20 3e 00				ld a,0 
4a22 cd 0f 13				call strlent 
4a25			 
4a25 23					inc hl 
4a26 e5					push hl 
4a27			 
4a27				;     allocate string length 
4a27			 
4a27 cd 78 13				call malloc 
4a2a			 
4a2a			        ;     copy string to block 
4a2a			 
4a2a c1					pop bc 
4a2b eb					ex de, hl 
4a2c e1					pop hl 
4a2d d5					push de 
4a2e			 
4a2e ed b0				ldir 
4a30			 
4a30			 
4a30			        ;     add pointer to string to array block 
4a30			 
4a30 2a f6 f0				ld hl, (scratch+3)    ; save the base for current string to push 
4a33			 
4a33 d1					pop de     ; the pointer to the newly copied string to add to the array 
4a34 73					ld (hl), e 
4a35 23					inc hl 
4a36 72					ld (hl), d	 
4a37 23					inc hl 
4a38				 
4a38 22 f6 f0				ld (scratch+3), hl    ; save the base for current string to push 
4a3b			 
4a3b					FORTH_DSP_POP 
4a3b cd 24 22			call macro_forth_dsp_pop 
4a3e				endm 
# End of macro FORTH_DSP_POP
4a3e			 
4a3e c1					pop bc 
4a3f 10 da				djnz .tablelop 
4a41			 
4a41			        ;  push array block pointer 
4a41			 
4a41 2a f6 f0				ld hl, (scratch+3)    ; save the base for current string to push 
4a44 36 00				ld (hl), 0 
4a46 23					inc hl 
4a47 36 00				ld (hl), 0 
4a49			 
4a49			 
4a49				 
4a49 2a f4 f0				ld hl, (scratch+1)    ; save the base for current string to push 
4a4c cd 70 1f				call forth_push_numhl 
4a4f			 
4a4f				NEXTW 
4a4f cd a7 fd			call parse_vector 
4a52 c3 53 23			jp macro_next 
4a55				endm 
# End of macro NEXTW
4a55			 
4a55			.SPLIT:   
4a55			 
4a55				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
4a55 48				db WORD_SYS_CORE+52             
4a56 4c 4b			dw .PTR            
4a58 06				db 5 + 1 
4a59 .. 00			db "SPLIT",0              
4a5f				endm 
# End of macro CWHEAD
4a5f			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
4a5f					if DEBUG_FORTH_WORDS_KEY 
4a5f						DMARK "SPT" 
4a5f f5				push af  
4a60 3a 74 4a			ld a, (.dmark)  
4a63 32 9d fd			ld (debug_mark),a  
4a66 3a 75 4a			ld a, (.dmark+1)  
4a69 32 9e fd			ld (debug_mark+1),a  
4a6c 3a 76 4a			ld a, (.dmark+2)  
4a6f 32 9f fd			ld (debug_mark+2),a  
4a72 18 03			jr .pastdmark  
4a74 ..			.dmark: db "SPT"  
4a77 f1			.pastdmark: pop af  
4a78			endm  
# End of macro DMARK
4a78						CALLMONITOR 
4a78 cd aa fd			call debug_vector  
4a7b				endm  
# End of macro CALLMONITOR
4a7b					endif 
4a7b			 
4a7b					; get delim 
4a7b					FORTH_DSP_VALUEHL 
4a7b cd 6c 21			call macro_dsp_valuehl 
4a7e				endm 
# End of macro FORTH_DSP_VALUEHL
4a7e			 
4a7e					FORTH_DSP_POP 
4a7e cd 24 22			call macro_forth_dsp_pop 
4a81				endm 
# End of macro FORTH_DSP_POP
4a81					 
4a81			 
4a81 45					ld b, l    ; move delim to b 
4a82 0e 01				ld c, 1   ; count of poritions 
4a84			 
4a84 c5					push bc 
4a85			 
4a85					if DEBUG_FORTH_WORDS 
4a85						DMARK "SPa" 
4a85 f5				push af  
4a86 3a 9a 4a			ld a, (.dmark)  
4a89 32 9d fd			ld (debug_mark),a  
4a8c 3a 9b 4a			ld a, (.dmark+1)  
4a8f 32 9e fd			ld (debug_mark+1),a  
4a92 3a 9c 4a			ld a, (.dmark+2)  
4a95 32 9f fd			ld (debug_mark+2),a  
4a98 18 03			jr .pastdmark  
4a9a ..			.dmark: db "SPa"  
4a9d f1			.pastdmark: pop af  
4a9e			endm  
# End of macro DMARK
4a9e						CALLMONITOR 
4a9e cd aa fd			call debug_vector  
4aa1				endm  
# End of macro CALLMONITOR
4aa1					endif 
4aa1					; get pointer to string to chop up 
4aa1					FORTH_DSP_VALUEHL 
4aa1 cd 6c 21			call macro_dsp_valuehl 
4aa4				endm 
# End of macro FORTH_DSP_VALUEHL
4aa4			 
4aa4			;		push hl 
4aa4 11 f3 f0				ld de, scratch 
4aa7			.spllop: 
4aa7 c1					pop bc 
4aa8 c5					push bc 
4aa9			;		pop hl 
4aa9					if DEBUG_FORTH_WORDS 
4aa9						DMARK "SPl" 
4aa9 f5				push af  
4aaa 3a be 4a			ld a, (.dmark)  
4aad 32 9d fd			ld (debug_mark),a  
4ab0 3a bf 4a			ld a, (.dmark+1)  
4ab3 32 9e fd			ld (debug_mark+1),a  
4ab6 3a c0 4a			ld a, (.dmark+2)  
4ab9 32 9f fd			ld (debug_mark+2),a  
4abc 18 03			jr .pastdmark  
4abe ..			.dmark: db "SPl"  
4ac1 f1			.pastdmark: pop af  
4ac2			endm  
# End of macro DMARK
4ac2						CALLMONITOR 
4ac2 cd aa fd			call debug_vector  
4ac5				endm  
# End of macro CALLMONITOR
4ac5					endif 
4ac5 7e					ld a, (hl) 
4ac6 b8					cp b 
4ac7 28 07				jr z, .splnxt 
4ac9			;		cp 0 
4ac9 b7					or a 
4aca 28 34				jr z, .splend 
4acc ed a0				ldi 
4ace 18 d7				jr .spllop 
4ad0			 
4ad0					; hit dlim 
4ad0			 
4ad0			.splnxt: 
4ad0					if DEBUG_FORTH_WORDS 
4ad0						DMARK "SPx" 
4ad0 f5				push af  
4ad1 3a e5 4a			ld a, (.dmark)  
4ad4 32 9d fd			ld (debug_mark),a  
4ad7 3a e6 4a			ld a, (.dmark+1)  
4ada 32 9e fd			ld (debug_mark+1),a  
4add 3a e7 4a			ld a, (.dmark+2)  
4ae0 32 9f fd			ld (debug_mark+2),a  
4ae3 18 03			jr .pastdmark  
4ae5 ..			.dmark: db "SPx"  
4ae8 f1			.pastdmark: pop af  
4ae9			endm  
# End of macro DMARK
4ae9						CALLMONITOR 
4ae9 cd aa fd			call debug_vector  
4aec				endm  
# End of macro CALLMONITOR
4aec					endif 
4aec 3e 00				ld a, 0 
4aee 12					ld (de), a 
4aef					;ex de, hl 
4aef e5					push hl 
4af0 21 f3 f0				ld hl, scratch 
4af3 cd da 1f				call forth_push_str 
4af6 e1					pop hl 
4af7					;ex de, hl 
4af7 23					inc hl 
4af8 c1					pop bc 
4af9 0c					inc c 
4afa c5					push bc 
4afb 11 f3 f0				ld de, scratch 
4afe 18 a7				jr .spllop 
4b00			 
4b00			.splend:		 
4b00					if DEBUG_FORTH_WORDS 
4b00						DMARK "SPe" 
4b00 f5				push af  
4b01 3a 15 4b			ld a, (.dmark)  
4b04 32 9d fd			ld (debug_mark),a  
4b07 3a 16 4b			ld a, (.dmark+1)  
4b0a 32 9e fd			ld (debug_mark+1),a  
4b0d 3a 17 4b			ld a, (.dmark+2)  
4b10 32 9f fd			ld (debug_mark+2),a  
4b13 18 03			jr .pastdmark  
4b15 ..			.dmark: db "SPe"  
4b18 f1			.pastdmark: pop af  
4b19			endm  
# End of macro DMARK
4b19						CALLMONITOR 
4b19 cd aa fd			call debug_vector  
4b1c				endm  
# End of macro CALLMONITOR
4b1c					endif 
4b1c 12					ld (de), a 
4b1d eb					ex de, hl 
4b1e			;		push hl 
4b1e 21 f3 f0				ld hl, scratch 
4b21 cd da 1f				call forth_push_str 
4b24					 
4b24					if DEBUG_FORTH_WORDS 
4b24						DMARK "SPc" 
4b24 f5				push af  
4b25 3a 39 4b			ld a, (.dmark)  
4b28 32 9d fd			ld (debug_mark),a  
4b2b 3a 3a 4b			ld a, (.dmark+1)  
4b2e 32 9e fd			ld (debug_mark+1),a  
4b31 3a 3b 4b			ld a, (.dmark+2)  
4b34 32 9f fd			ld (debug_mark+2),a  
4b37 18 03			jr .pastdmark  
4b39 ..			.dmark: db "SPc"  
4b3c f1			.pastdmark: pop af  
4b3d			endm  
# End of macro DMARK
4b3d						CALLMONITOR 
4b3d cd aa fd			call debug_vector  
4b40				endm  
# End of macro CALLMONITOR
4b40					endif 
4b40			 
4b40 e1					pop hl    ; get counter from bc which has been push 
4b41 26 00				ld h, 0 
4b43			;		ld l, c 
4b43 cd 70 1f				call forth_push_numhl 
4b46			 
4b46			 
4b46				NEXTW 
4b46 cd a7 fd			call parse_vector 
4b49 c3 53 23			jp macro_next 
4b4c				endm 
# End of macro NEXTW
4b4c			.PTR:   
4b4c			 
4b4c				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4b4c 48				db WORD_SYS_CORE+52             
4b4d 7c 4b			dw .STYPE            
4b4f 04				db 3 + 1 
4b50 .. 00			db "PTR",0              
4b54				endm 
# End of macro CWHEAD
4b54			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4b54			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4b54			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4b54			 
4b54					if DEBUG_FORTH_WORDS_KEY 
4b54						DMARK "PTR" 
4b54 f5				push af  
4b55 3a 69 4b			ld a, (.dmark)  
4b58 32 9d fd			ld (debug_mark),a  
4b5b 3a 6a 4b			ld a, (.dmark+1)  
4b5e 32 9e fd			ld (debug_mark+1),a  
4b61 3a 6b 4b			ld a, (.dmark+2)  
4b64 32 9f fd			ld (debug_mark+2),a  
4b67 18 03			jr .pastdmark  
4b69 ..			.dmark: db "PTR"  
4b6c f1			.pastdmark: pop af  
4b6d			endm  
# End of macro DMARK
4b6d						CALLMONITOR 
4b6d cd aa fd			call debug_vector  
4b70				endm  
# End of macro CALLMONITOR
4b70					endif 
4b70					FORTH_DSP_VALUEHL 
4b70 cd 6c 21			call macro_dsp_valuehl 
4b73				endm 
# End of macro FORTH_DSP_VALUEHL
4b73 cd 70 1f				call forth_push_numhl 
4b76			 
4b76			 
4b76					NEXTW 
4b76 cd a7 fd			call parse_vector 
4b79 c3 53 23			jp macro_next 
4b7c				endm 
# End of macro NEXTW
4b7c			.STYPE: 
4b7c				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4b7c 48				db WORD_SYS_CORE+52             
4b7d d9 4b			dw .UPPER            
4b7f 06				db 5 + 1 
4b80 .. 00			db "STYPE",0              
4b86				endm 
# End of macro CWHEAD
4b86			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
4b86			; | | 's' string or 'i' integer or 'c' const 
4b86					if DEBUG_FORTH_WORDS_KEY 
4b86						DMARK "STY" 
4b86 f5				push af  
4b87 3a 9b 4b			ld a, (.dmark)  
4b8a 32 9d fd			ld (debug_mark),a  
4b8d 3a 9c 4b			ld a, (.dmark+1)  
4b90 32 9e fd			ld (debug_mark+1),a  
4b93 3a 9d 4b			ld a, (.dmark+2)  
4b96 32 9f fd			ld (debug_mark+2),a  
4b99 18 03			jr .pastdmark  
4b9b ..			.dmark: db "STY"  
4b9e f1			.pastdmark: pop af  
4b9f			endm  
# End of macro DMARK
4b9f						CALLMONITOR 
4b9f cd aa fd			call debug_vector  
4ba2				endm  
# End of macro CALLMONITOR
4ba2					endif 
4ba2					FORTH_DSP 
4ba2 cd 32 21			call macro_forth_dsp 
4ba5				endm 
# End of macro FORTH_DSP
4ba5					;v5 FORTH_DSP_VALUE 
4ba5			 
4ba5 7e					ld a, (hl) 
4ba6			 
4ba6 f5					push af 
4ba7			 
4ba7			; Dont destroy TOS		FORTH_DSP_POP 
4ba7			 
4ba7 f1					pop af 
4ba8			 
4ba8 fe 01				cp DS_TYPE_STR 
4baa 28 12				jr z, .typestr 
4bac fe 04				cp DS_TYPE_CONST 
4bae 28 09				jr z, .typeconst 
4bb0			 
4bb0 fe 02				cp DS_TYPE_INUM 
4bb2 28 0f				jr z, .typeinum 
4bb4			 
4bb4 21 d7 4b				ld hl, .tna 
4bb7 18 0f				jr .tpush 
4bb9			 
4bb9 21 d3 4b		.typeconst:	ld hl, .tconst 
4bbc 18 0a				jr .tpush 
4bbe 21 d1 4b		.typestr:	ld hl, .tstr 
4bc1 18 05				jr .tpush 
4bc3 21 d5 4b		.typeinum:	ld hl, .tinum 
4bc6 18 00				jr .tpush 
4bc8			 
4bc8			.tpush: 
4bc8			 
4bc8 cd da 1f				call forth_push_str 
4bcb			 
4bcb					NEXTW 
4bcb cd a7 fd			call parse_vector 
4bce c3 53 23			jp macro_next 
4bd1				endm 
# End of macro NEXTW
4bd1 .. 00		.tstr:	db "s",0 
4bd3 .. 00		.tconst:	db "c",0 
4bd5 .. 00		.tinum:  db "i",0 
4bd7 .. 00		.tna:   db "?", 0 
4bd9			 
4bd9			 
4bd9			.UPPER: 
4bd9				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4bd9 48				db WORD_SYS_CORE+52             
4bda 16 4c			dw .LOWER            
4bdc 06				db 5 + 1 
4bdd .. 00			db "UPPER",0              
4be3				endm 
# End of macro CWHEAD
4be3			; | UPPER ( s -- s ) Upper case string s  | DONE 
4be3					if DEBUG_FORTH_WORDS_KEY 
4be3						DMARK "UPR" 
4be3 f5				push af  
4be4 3a f8 4b			ld a, (.dmark)  
4be7 32 9d fd			ld (debug_mark),a  
4bea 3a f9 4b			ld a, (.dmark+1)  
4bed 32 9e fd			ld (debug_mark+1),a  
4bf0 3a fa 4b			ld a, (.dmark+2)  
4bf3 32 9f fd			ld (debug_mark+2),a  
4bf6 18 03			jr .pastdmark  
4bf8 ..			.dmark: db "UPR"  
4bfb f1			.pastdmark: pop af  
4bfc			endm  
# End of macro DMARK
4bfc						CALLMONITOR 
4bfc cd aa fd			call debug_vector  
4bff				endm  
# End of macro CALLMONITOR
4bff					endif 
4bff			 
4bff					FORTH_DSP 
4bff cd 32 21			call macro_forth_dsp 
4c02				endm 
# End of macro FORTH_DSP
4c02					 
4c02			; TODO check is string type 
4c02			 
4c02					FORTH_DSP_VALUEHL 
4c02 cd 6c 21			call macro_dsp_valuehl 
4c05				endm 
# End of macro FORTH_DSP_VALUEHL
4c05			; get pointer to string in hl 
4c05			 
4c05 7e			.toup:		ld a, (hl) 
4c06			;		cp 0 
4c06 b7					or a 
4c07 28 07				jr z, .toupdone 
4c09			 
4c09 cd 14 12				call to_upper 
4c0c			 
4c0c 77					ld (hl), a 
4c0d 23					inc hl 
4c0e 18 f5				jr .toup 
4c10			 
4c10					 
4c10			 
4c10			 
4c10			; for each char convert to upper 
4c10					 
4c10			.toupdone: 
4c10			 
4c10			 
4c10					NEXTW 
4c10 cd a7 fd			call parse_vector 
4c13 c3 53 23			jp macro_next 
4c16				endm 
# End of macro NEXTW
4c16			.LOWER: 
4c16				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4c16 48				db WORD_SYS_CORE+52             
4c17 53 4c			dw .TCASE            
4c19 06				db 5 + 1 
4c1a .. 00			db "LOWER",0              
4c20				endm 
# End of macro CWHEAD
4c20			; | LOWER ( s -- s ) Lower case string s  | DONE 
4c20					if DEBUG_FORTH_WORDS_KEY 
4c20						DMARK "LWR" 
4c20 f5				push af  
4c21 3a 35 4c			ld a, (.dmark)  
4c24 32 9d fd			ld (debug_mark),a  
4c27 3a 36 4c			ld a, (.dmark+1)  
4c2a 32 9e fd			ld (debug_mark+1),a  
4c2d 3a 37 4c			ld a, (.dmark+2)  
4c30 32 9f fd			ld (debug_mark+2),a  
4c33 18 03			jr .pastdmark  
4c35 ..			.dmark: db "LWR"  
4c38 f1			.pastdmark: pop af  
4c39			endm  
# End of macro DMARK
4c39						CALLMONITOR 
4c39 cd aa fd			call debug_vector  
4c3c				endm  
# End of macro CALLMONITOR
4c3c					endif 
4c3c			 
4c3c					FORTH_DSP 
4c3c cd 32 21			call macro_forth_dsp 
4c3f				endm 
# End of macro FORTH_DSP
4c3f					 
4c3f			; TODO check is string type 
4c3f			 
4c3f					FORTH_DSP_VALUEHL 
4c3f cd 6c 21			call macro_dsp_valuehl 
4c42				endm 
# End of macro FORTH_DSP_VALUEHL
4c42			; get pointer to string in hl 
4c42			 
4c42 7e			.tolow:		ld a, (hl) 
4c43			;		cp 0 
4c43 b7					or a 
4c44 28 07				jr z, .tolowdone 
4c46			 
4c46 cd 1d 12				call to_lower 
4c49			 
4c49 77					ld (hl), a 
4c4a 23					inc hl 
4c4b 18 f5				jr .tolow 
4c4d			 
4c4d					 
4c4d			 
4c4d			 
4c4d			; for each char convert to low 
4c4d					 
4c4d			.tolowdone: 
4c4d					NEXTW 
4c4d cd a7 fd			call parse_vector 
4c50 c3 53 23			jp macro_next 
4c53				endm 
# End of macro NEXTW
4c53			.TCASE: 
4c53				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4c53 48				db WORD_SYS_CORE+52             
4c54 8a 4d			dw .SUBSTR            
4c56 06				db 5 + 1 
4c57 .. 00			db "TCASE",0              
4c5d				endm 
# End of macro CWHEAD
4c5d			; | TCASE ( s -- s ) Title case string s  | DONE 
4c5d					if DEBUG_FORTH_WORDS_KEY 
4c5d						DMARK "TCS" 
4c5d f5				push af  
4c5e 3a 72 4c			ld a, (.dmark)  
4c61 32 9d fd			ld (debug_mark),a  
4c64 3a 73 4c			ld a, (.dmark+1)  
4c67 32 9e fd			ld (debug_mark+1),a  
4c6a 3a 74 4c			ld a, (.dmark+2)  
4c6d 32 9f fd			ld (debug_mark+2),a  
4c70 18 03			jr .pastdmark  
4c72 ..			.dmark: db "TCS"  
4c75 f1			.pastdmark: pop af  
4c76			endm  
# End of macro DMARK
4c76						CALLMONITOR 
4c76 cd aa fd			call debug_vector  
4c79				endm  
# End of macro CALLMONITOR
4c79					endif 
4c79			 
4c79					FORTH_DSP 
4c79 cd 32 21			call macro_forth_dsp 
4c7c				endm 
# End of macro FORTH_DSP
4c7c					 
4c7c			; TODO check is string type 
4c7c			 
4c7c					FORTH_DSP_VALUEHL 
4c7c cd 6c 21			call macro_dsp_valuehl 
4c7f				endm 
# End of macro FORTH_DSP_VALUEHL
4c7f			; get pointer to string in hl 
4c7f			 
4c7f					if DEBUG_FORTH_WORDS 
4c7f						DMARK "TC1" 
4c7f f5				push af  
4c80 3a 94 4c			ld a, (.dmark)  
4c83 32 9d fd			ld (debug_mark),a  
4c86 3a 95 4c			ld a, (.dmark+1)  
4c89 32 9e fd			ld (debug_mark+1),a  
4c8c 3a 96 4c			ld a, (.dmark+2)  
4c8f 32 9f fd			ld (debug_mark+2),a  
4c92 18 03			jr .pastdmark  
4c94 ..			.dmark: db "TC1"  
4c97 f1			.pastdmark: pop af  
4c98			endm  
# End of macro DMARK
4c98						CALLMONITOR 
4c98 cd aa fd			call debug_vector  
4c9b				endm  
# End of macro CALLMONITOR
4c9b					endif 
4c9b			 
4c9b					; first time in turn to upper case first char 
4c9b			 
4c9b 7e					ld a, (hl) 
4c9c c3 25 4d				jp .totsiptou 
4c9f			 
4c9f			 
4c9f 7e			.tot:		ld a, (hl) 
4ca0			;		cp 0 
4ca0 b7					or a 
4ca1 ca 68 4d				jp z, .totdone 
4ca4			 
4ca4					if DEBUG_FORTH_WORDS 
4ca4						DMARK "TC2" 
4ca4 f5				push af  
4ca5 3a b9 4c			ld a, (.dmark)  
4ca8 32 9d fd			ld (debug_mark),a  
4cab 3a ba 4c			ld a, (.dmark+1)  
4cae 32 9e fd			ld (debug_mark+1),a  
4cb1 3a bb 4c			ld a, (.dmark+2)  
4cb4 32 9f fd			ld (debug_mark+2),a  
4cb7 18 03			jr .pastdmark  
4cb9 ..			.dmark: db "TC2"  
4cbc f1			.pastdmark: pop af  
4cbd			endm  
# End of macro DMARK
4cbd						CALLMONITOR 
4cbd cd aa fd			call debug_vector  
4cc0				endm  
# End of macro CALLMONITOR
4cc0					endif 
4cc0					; check to see if current char is a space 
4cc0			 
4cc0 fe 20				cp ' ' 
4cc2 28 21				jr z, .totsp 
4cc4 cd 1d 12				call to_lower 
4cc7					if DEBUG_FORTH_WORDS 
4cc7						DMARK "TC3" 
4cc7 f5				push af  
4cc8 3a dc 4c			ld a, (.dmark)  
4ccb 32 9d fd			ld (debug_mark),a  
4cce 3a dd 4c			ld a, (.dmark+1)  
4cd1 32 9e fd			ld (debug_mark+1),a  
4cd4 3a de 4c			ld a, (.dmark+2)  
4cd7 32 9f fd			ld (debug_mark+2),a  
4cda 18 03			jr .pastdmark  
4cdc ..			.dmark: db "TC3"  
4cdf f1			.pastdmark: pop af  
4ce0			endm  
# End of macro DMARK
4ce0						CALLMONITOR 
4ce0 cd aa fd			call debug_vector  
4ce3				endm  
# End of macro CALLMONITOR
4ce3					endif 
4ce3 18 62				jr .totnxt 
4ce5			 
4ce5			.totsp:         ; on a space, find next char which should be upper 
4ce5			 
4ce5					if DEBUG_FORTH_WORDS 
4ce5						DMARK "TC4" 
4ce5 f5				push af  
4ce6 3a fa 4c			ld a, (.dmark)  
4ce9 32 9d fd			ld (debug_mark),a  
4cec 3a fb 4c			ld a, (.dmark+1)  
4cef 32 9e fd			ld (debug_mark+1),a  
4cf2 3a fc 4c			ld a, (.dmark+2)  
4cf5 32 9f fd			ld (debug_mark+2),a  
4cf8 18 03			jr .pastdmark  
4cfa ..			.dmark: db "TC4"  
4cfd f1			.pastdmark: pop af  
4cfe			endm  
# End of macro DMARK
4cfe						CALLMONITOR 
4cfe cd aa fd			call debug_vector  
4d01				endm  
# End of macro CALLMONITOR
4d01					endif 
4d01					;; 
4d01			 
4d01 fe 20				cp ' ' 
4d03 20 20				jr nz, .totsiptou 
4d05 23					inc hl 
4d06 7e					ld a, (hl) 
4d07					if DEBUG_FORTH_WORDS 
4d07						DMARK "TC5" 
4d07 f5				push af  
4d08 3a 1c 4d			ld a, (.dmark)  
4d0b 32 9d fd			ld (debug_mark),a  
4d0e 3a 1d 4d			ld a, (.dmark+1)  
4d11 32 9e fd			ld (debug_mark+1),a  
4d14 3a 1e 4d			ld a, (.dmark+2)  
4d17 32 9f fd			ld (debug_mark+2),a  
4d1a 18 03			jr .pastdmark  
4d1c ..			.dmark: db "TC5"  
4d1f f1			.pastdmark: pop af  
4d20			endm  
# End of macro DMARK
4d20						CALLMONITOR 
4d20 cd aa fd			call debug_vector  
4d23				endm  
# End of macro CALLMONITOR
4d23					endif 
4d23 18 c0				jr .totsp 
4d25			.totsiptou:     
4d25					;cp 0 
4d25 b7					or a 
4d26 28 40				jr z, .totdone 
4d28					; not space and not zero term so upper case it 
4d28 cd 14 12				call to_upper 
4d2b			 
4d2b					if DEBUG_FORTH_WORDS 
4d2b						DMARK "TC6" 
4d2b f5				push af  
4d2c 3a 40 4d			ld a, (.dmark)  
4d2f 32 9d fd			ld (debug_mark),a  
4d32 3a 41 4d			ld a, (.dmark+1)  
4d35 32 9e fd			ld (debug_mark+1),a  
4d38 3a 42 4d			ld a, (.dmark+2)  
4d3b 32 9f fd			ld (debug_mark+2),a  
4d3e 18 03			jr .pastdmark  
4d40 ..			.dmark: db "TC6"  
4d43 f1			.pastdmark: pop af  
4d44			endm  
# End of macro DMARK
4d44						CALLMONITOR 
4d44 cd aa fd			call debug_vector  
4d47				endm  
# End of macro CALLMONITOR
4d47					endif 
4d47			 
4d47			 
4d47			.totnxt: 
4d47			 
4d47 77					ld (hl), a 
4d48 23					inc hl 
4d49					if DEBUG_FORTH_WORDS 
4d49						DMARK "TC7" 
4d49 f5				push af  
4d4a 3a 5e 4d			ld a, (.dmark)  
4d4d 32 9d fd			ld (debug_mark),a  
4d50 3a 5f 4d			ld a, (.dmark+1)  
4d53 32 9e fd			ld (debug_mark+1),a  
4d56 3a 60 4d			ld a, (.dmark+2)  
4d59 32 9f fd			ld (debug_mark+2),a  
4d5c 18 03			jr .pastdmark  
4d5e ..			.dmark: db "TC7"  
4d61 f1			.pastdmark: pop af  
4d62			endm  
# End of macro DMARK
4d62						CALLMONITOR 
4d62 cd aa fd			call debug_vector  
4d65				endm  
# End of macro CALLMONITOR
4d65					endif 
4d65 c3 9f 4c				jp .tot 
4d68			 
4d68					 
4d68			 
4d68			 
4d68			; for each char convert to low 
4d68					 
4d68			.totdone: 
4d68					if DEBUG_FORTH_WORDS 
4d68						DMARK "TCd" 
4d68 f5				push af  
4d69 3a 7d 4d			ld a, (.dmark)  
4d6c 32 9d fd			ld (debug_mark),a  
4d6f 3a 7e 4d			ld a, (.dmark+1)  
4d72 32 9e fd			ld (debug_mark+1),a  
4d75 3a 7f 4d			ld a, (.dmark+2)  
4d78 32 9f fd			ld (debug_mark+2),a  
4d7b 18 03			jr .pastdmark  
4d7d ..			.dmark: db "TCd"  
4d80 f1			.pastdmark: pop af  
4d81			endm  
# End of macro DMARK
4d81						CALLMONITOR 
4d81 cd aa fd			call debug_vector  
4d84				endm  
# End of macro CALLMONITOR
4d84					endif 
4d84					NEXTW 
4d84 cd a7 fd			call parse_vector 
4d87 c3 53 23			jp macro_next 
4d8a				endm 
# End of macro NEXTW
4d8a			 
4d8a			.SUBSTR: 
4d8a				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4d8a 48				db WORD_SYS_CORE+52             
4d8b ea 4d			dw .LEFT            
4d8d 07				db 6 + 1 
4d8e .. 00			db "SUBSTR",0              
4d95				endm 
# End of macro CWHEAD
4d95			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4d95			 
4d95					if DEBUG_FORTH_WORDS_KEY 
4d95						DMARK "SST" 
4d95 f5				push af  
4d96 3a aa 4d			ld a, (.dmark)  
4d99 32 9d fd			ld (debug_mark),a  
4d9c 3a ab 4d			ld a, (.dmark+1)  
4d9f 32 9e fd			ld (debug_mark+1),a  
4da2 3a ac 4d			ld a, (.dmark+2)  
4da5 32 9f fd			ld (debug_mark+2),a  
4da8 18 03			jr .pastdmark  
4daa ..			.dmark: db "SST"  
4dad f1			.pastdmark: pop af  
4dae			endm  
# End of macro DMARK
4dae						CALLMONITOR 
4dae cd aa fd			call debug_vector  
4db1				endm  
# End of macro CALLMONITOR
4db1					endif 
4db1			; TODO check string type 
4db1					FORTH_DSP_VALUEHL 
4db1 cd 6c 21			call macro_dsp_valuehl 
4db4				endm 
# End of macro FORTH_DSP_VALUEHL
4db4			 
4db4 e5					push hl      ; string length 
4db5			 
4db5					FORTH_DSP_POP 
4db5 cd 24 22			call macro_forth_dsp_pop 
4db8				endm 
# End of macro FORTH_DSP_POP
4db8			 
4db8					FORTH_DSP_VALUEHL 
4db8 cd 6c 21			call macro_dsp_valuehl 
4dbb				endm 
# End of macro FORTH_DSP_VALUEHL
4dbb			 
4dbb e5					push hl     ; start char 
4dbc			 
4dbc					FORTH_DSP_POP 
4dbc cd 24 22			call macro_forth_dsp_pop 
4dbf				endm 
# End of macro FORTH_DSP_POP
4dbf			 
4dbf			 
4dbf					FORTH_DSP_VALUE 
4dbf cd 55 21			call macro_forth_dsp_value 
4dc2				endm 
# End of macro FORTH_DSP_VALUE
4dc2			 
4dc2 d1					pop de    ; get start post offset 
4dc3			 
4dc3 19					add hl, de    ; starting offset 
4dc4			 
4dc4 c1					pop bc 
4dc5 c5					push bc      ; grab size of string 
4dc6			 
4dc6 e5					push hl    ; save string start  
4dc7			 
4dc7 26 00				ld h, 0 
4dc9 69					ld l, c 
4dca 23					inc hl 
4dcb 23					inc hl 
4dcc			 
4dcc cd 78 13				call malloc 
4dcf				if DEBUG_FORTH_MALLOC_GUARD 
4dcf cc 37 65				call z,malloc_error 
4dd2				endif 
4dd2			 
4dd2 eb					ex de, hl      ; save malloc area for string copy 
4dd3 e1					pop hl    ; get back source 
4dd4 c1					pop bc    ; get length of string back 
4dd5			 
4dd5 d5					push de    ; save malloc area for after we push 
4dd6 ed b0				ldir     ; copy substr 
4dd8			 
4dd8			 
4dd8 eb					ex de, hl 
4dd9			;		ld a, 0 
4dd9 36 00				ld (hl), 0   ; term substr 
4ddb			 
4ddb					 
4ddb e1					pop hl    ; get malloc so we can push it 
4ddc e5					push hl   ; save so we can free it afterwards 
4ddd			 
4ddd cd da 1f				call forth_push_str 
4de0			 
4de0 e1					pop hl 
4de1 cd 42 14				call free 
4de4			 
4de4					 
4de4					 
4de4			 
4de4			 
4de4					NEXTW 
4de4 cd a7 fd			call parse_vector 
4de7 c3 53 23			jp macro_next 
4dea				endm 
# End of macro NEXTW
4dea			 
4dea			.LEFT: 
4dea				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4dea 48				db WORD_SYS_CORE+52             
4deb 2e 4e			dw .RIGHT            
4ded 05				db 4 + 1 
4dee .. 00			db "LEFT",0              
4df3				endm 
# End of macro CWHEAD
4df3			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
4df3					if DEBUG_FORTH_WORDS_KEY 
4df3						DMARK "LEF" 
4df3 f5				push af  
4df4 3a 08 4e			ld a, (.dmark)  
4df7 32 9d fd			ld (debug_mark),a  
4dfa 3a 09 4e			ld a, (.dmark+1)  
4dfd 32 9e fd			ld (debug_mark+1),a  
4e00 3a 0a 4e			ld a, (.dmark+2)  
4e03 32 9f fd			ld (debug_mark+2),a  
4e06 18 03			jr .pastdmark  
4e08 ..			.dmark: db "LEF"  
4e0b f1			.pastdmark: pop af  
4e0c			endm  
# End of macro DMARK
4e0c						CALLMONITOR 
4e0c cd aa fd			call debug_vector  
4e0f				endm  
# End of macro CALLMONITOR
4e0f					endif 
4e0f			 
4e0f					 
4e0f			; TODO check string type 
4e0f					FORTH_DSP_VALUEHL 
4e0f cd 6c 21			call macro_dsp_valuehl 
4e12				endm 
# End of macro FORTH_DSP_VALUEHL
4e12			 
4e12 e5					push hl      ; string length 
4e13			 
4e13					FORTH_DSP_POP 
4e13 cd 24 22			call macro_forth_dsp_pop 
4e16				endm 
# End of macro FORTH_DSP_POP
4e16			 
4e16					FORTH_DSP_VALUEHL 
4e16 cd 6c 21			call macro_dsp_valuehl 
4e19				endm 
# End of macro FORTH_DSP_VALUEHL
4e19			 
4e19 c1					pop bc 
4e1a			 
4e1a 11 f3 f0				ld de, scratch 
4e1d ed b0				ldir 
4e1f 3e 00				ld a, 0 
4e21 12					ld (de), a 
4e22					 
4e22 21 f3 f0				ld hl, scratch 
4e25 cd da 1f				call forth_push_str 
4e28			 
4e28					NEXTW 
4e28 cd a7 fd			call parse_vector 
4e2b c3 53 23			jp macro_next 
4e2e				endm 
# End of macro NEXTW
4e2e			.RIGHT: 
4e2e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4e2e 48				db WORD_SYS_CORE+52             
4e2f ef 4e			dw .STR2NUM            
4e31 06				db 5 + 1 
4e32 .. 00			db "RIGHT",0              
4e38				endm 
# End of macro CWHEAD
4e38			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
4e38					if DEBUG_FORTH_WORDS_KEY 
4e38						DMARK "RIG" 
4e38 f5				push af  
4e39 3a 4d 4e			ld a, (.dmark)  
4e3c 32 9d fd			ld (debug_mark),a  
4e3f 3a 4e 4e			ld a, (.dmark+1)  
4e42 32 9e fd			ld (debug_mark+1),a  
4e45 3a 4f 4e			ld a, (.dmark+2)  
4e48 32 9f fd			ld (debug_mark+2),a  
4e4b 18 03			jr .pastdmark  
4e4d ..			.dmark: db "RIG"  
4e50 f1			.pastdmark: pop af  
4e51			endm  
# End of macro DMARK
4e51						CALLMONITOR 
4e51 cd aa fd			call debug_vector  
4e54				endm  
# End of macro CALLMONITOR
4e54					endif 
4e54			 
4e54			; TODO check string type 
4e54					FORTH_DSP_VALUEHL 
4e54 cd 6c 21			call macro_dsp_valuehl 
4e57				endm 
# End of macro FORTH_DSP_VALUEHL
4e57			 
4e57 e5					push hl      ; string length 
4e58			 
4e58					FORTH_DSP_POP 
4e58 cd 24 22			call macro_forth_dsp_pop 
4e5b				endm 
# End of macro FORTH_DSP_POP
4e5b			 
4e5b					FORTH_DSP_VALUEHL 
4e5b cd 6c 21			call macro_dsp_valuehl 
4e5e				endm 
# End of macro FORTH_DSP_VALUEHL
4e5e			 
4e5e					if DEBUG_FORTH_WORDS 
4e5e						DMARK "RI1" 
4e5e f5				push af  
4e5f 3a 73 4e			ld a, (.dmark)  
4e62 32 9d fd			ld (debug_mark),a  
4e65 3a 74 4e			ld a, (.dmark+1)  
4e68 32 9e fd			ld (debug_mark+1),a  
4e6b 3a 75 4e			ld a, (.dmark+2)  
4e6e 32 9f fd			ld (debug_mark+2),a  
4e71 18 03			jr .pastdmark  
4e73 ..			.dmark: db "RI1"  
4e76 f1			.pastdmark: pop af  
4e77			endm  
# End of macro DMARK
4e77						CALLMONITOR 
4e77 cd aa fd			call debug_vector  
4e7a				endm  
# End of macro CALLMONITOR
4e7a					endif 
4e7a					; from the pointer to string get to the end of string 
4e7a			 
4e7a 01 ff 00				ld bc, 255 
4e7d 3e 00				ld a, 0 
4e7f ed b1				cpir 
4e81 2b					dec hl 
4e82			 
4e82					;  
4e82			 
4e82					if DEBUG_FORTH_WORDS 
4e82						DMARK "RI2" 
4e82 f5				push af  
4e83 3a 97 4e			ld a, (.dmark)  
4e86 32 9d fd			ld (debug_mark),a  
4e89 3a 98 4e			ld a, (.dmark+1)  
4e8c 32 9e fd			ld (debug_mark+1),a  
4e8f 3a 99 4e			ld a, (.dmark+2)  
4e92 32 9f fd			ld (debug_mark+2),a  
4e95 18 03			jr .pastdmark  
4e97 ..			.dmark: db "RI2"  
4e9a f1			.pastdmark: pop af  
4e9b			endm  
# End of macro DMARK
4e9b						CALLMONITOR 
4e9b cd aa fd			call debug_vector  
4e9e				endm  
# End of macro CALLMONITOR
4e9e					endif 
4e9e			 
4e9e c1					pop bc    ;  length of string to copy 
4e9f			 
4e9f 79					ld a, c 
4ea0 eb					ex de, hl 
4ea1 21 f3 f0				ld hl, scratch  
4ea4 cd ac 0f				call addatohl 
4ea7			 
4ea7 eb					ex de, hl 
4ea8			 
4ea8					if DEBUG_FORTH_WORDS 
4ea8						DMARK "RI3" 
4ea8 f5				push af  
4ea9 3a bd 4e			ld a, (.dmark)  
4eac 32 9d fd			ld (debug_mark),a  
4eaf 3a be 4e			ld a, (.dmark+1)  
4eb2 32 9e fd			ld (debug_mark+1),a  
4eb5 3a bf 4e			ld a, (.dmark+2)  
4eb8 32 9f fd			ld (debug_mark+2),a  
4ebb 18 03			jr .pastdmark  
4ebd ..			.dmark: db "RI3"  
4ec0 f1			.pastdmark: pop af  
4ec1			endm  
# End of macro DMARK
4ec1						CALLMONITOR 
4ec1 cd aa fd			call debug_vector  
4ec4				endm  
# End of macro CALLMONITOR
4ec4					endif 
4ec4			 
4ec4 03					inc bc 
4ec5 ed b8				lddr 
4ec7					 
4ec7 21 f3 f0				ld hl, scratch 
4eca					if DEBUG_FORTH_WORDS 
4eca						DMARK "RI4" 
4eca f5				push af  
4ecb 3a df 4e			ld a, (.dmark)  
4ece 32 9d fd			ld (debug_mark),a  
4ed1 3a e0 4e			ld a, (.dmark+1)  
4ed4 32 9e fd			ld (debug_mark+1),a  
4ed7 3a e1 4e			ld a, (.dmark+2)  
4eda 32 9f fd			ld (debug_mark+2),a  
4edd 18 03			jr .pastdmark  
4edf ..			.dmark: db "RI4"  
4ee2 f1			.pastdmark: pop af  
4ee3			endm  
# End of macro DMARK
4ee3						CALLMONITOR 
4ee3 cd aa fd			call debug_vector  
4ee6				endm  
# End of macro CALLMONITOR
4ee6					endif 
4ee6 cd da 1f				call forth_push_str 
4ee9			 
4ee9			 
4ee9					NEXTW 
4ee9 cd a7 fd			call parse_vector 
4eec c3 53 23			jp macro_next 
4eef				endm 
# End of macro NEXTW
4eef			 
4eef			 
4eef			.STR2NUM: 
4eef				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4eef 48				db WORD_SYS_CORE+52             
4ef0 7e 4f			dw .NUM2STR            
4ef2 08				db 7 + 1 
4ef3 .. 00			db "STR2NUM",0              
4efb				endm 
# End of macro CWHEAD
4efb			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4efb			 
4efb			 
4efb			; TODO STR type check to do 
4efb					if DEBUG_FORTH_WORDS_KEY 
4efb						DMARK "S2N" 
4efb f5				push af  
4efc 3a 10 4f			ld a, (.dmark)  
4eff 32 9d fd			ld (debug_mark),a  
4f02 3a 11 4f			ld a, (.dmark+1)  
4f05 32 9e fd			ld (debug_mark+1),a  
4f08 3a 12 4f			ld a, (.dmark+2)  
4f0b 32 9f fd			ld (debug_mark+2),a  
4f0e 18 03			jr .pastdmark  
4f10 ..			.dmark: db "S2N"  
4f13 f1			.pastdmark: pop af  
4f14			endm  
# End of macro DMARK
4f14						CALLMONITOR 
4f14 cd aa fd			call debug_vector  
4f17				endm  
# End of macro CALLMONITOR
4f17					endif 
4f17			 
4f17					;FORTH_DSP 
4f17					FORTH_DSP_VALUE 
4f17 cd 55 21			call macro_forth_dsp_value 
4f1a				endm 
# End of macro FORTH_DSP_VALUE
4f1a					;inc hl 
4f1a			 
4f1a eb					ex de, hl 
4f1b					if DEBUG_FORTH_WORDS 
4f1b						DMARK "S2a" 
4f1b f5				push af  
4f1c 3a 30 4f			ld a, (.dmark)  
4f1f 32 9d fd			ld (debug_mark),a  
4f22 3a 31 4f			ld a, (.dmark+1)  
4f25 32 9e fd			ld (debug_mark+1),a  
4f28 3a 32 4f			ld a, (.dmark+2)  
4f2b 32 9f fd			ld (debug_mark+2),a  
4f2e 18 03			jr .pastdmark  
4f30 ..			.dmark: db "S2a"  
4f33 f1			.pastdmark: pop af  
4f34			endm  
# End of macro DMARK
4f34						CALLMONITOR 
4f34 cd aa fd			call debug_vector  
4f37				endm  
# End of macro CALLMONITOR
4f37					endif 
4f37 cd 9b 12				call string_to_uint16 
4f3a			 
4f3a					if DEBUG_FORTH_WORDS 
4f3a						DMARK "S2b" 
4f3a f5				push af  
4f3b 3a 4f 4f			ld a, (.dmark)  
4f3e 32 9d fd			ld (debug_mark),a  
4f41 3a 50 4f			ld a, (.dmark+1)  
4f44 32 9e fd			ld (debug_mark+1),a  
4f47 3a 51 4f			ld a, (.dmark+2)  
4f4a 32 9f fd			ld (debug_mark+2),a  
4f4d 18 03			jr .pastdmark  
4f4f ..			.dmark: db "S2b"  
4f52 f1			.pastdmark: pop af  
4f53			endm  
# End of macro DMARK
4f53						CALLMONITOR 
4f53 cd aa fd			call debug_vector  
4f56				endm  
# End of macro CALLMONITOR
4f56					endif 
4f56			;		push hl 
4f56					FORTH_DSP_POP 
4f56 cd 24 22			call macro_forth_dsp_pop 
4f59				endm 
# End of macro FORTH_DSP_POP
4f59			;		pop hl 
4f59					 
4f59					if DEBUG_FORTH_WORDS 
4f59						DMARK "S2b" 
4f59 f5				push af  
4f5a 3a 6e 4f			ld a, (.dmark)  
4f5d 32 9d fd			ld (debug_mark),a  
4f60 3a 6f 4f			ld a, (.dmark+1)  
4f63 32 9e fd			ld (debug_mark+1),a  
4f66 3a 70 4f			ld a, (.dmark+2)  
4f69 32 9f fd			ld (debug_mark+2),a  
4f6c 18 03			jr .pastdmark  
4f6e ..			.dmark: db "S2b"  
4f71 f1			.pastdmark: pop af  
4f72			endm  
# End of macro DMARK
4f72						CALLMONITOR 
4f72 cd aa fd			call debug_vector  
4f75				endm  
# End of macro CALLMONITOR
4f75					endif 
4f75 cd 70 1f				call forth_push_numhl	 
4f78			 
4f78				 
4f78				       NEXTW 
4f78 cd a7 fd			call parse_vector 
4f7b c3 53 23			jp macro_next 
4f7e				endm 
# End of macro NEXTW
4f7e			.NUM2STR: 
4f7e				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4f7e 48				db WORD_SYS_CORE+52             
4f7f 13 50			dw .CONCAT            
4f81 08				db 7 + 1 
4f82 .. 00			db "NUM2STR",0              
4f8a				endm 
# End of macro CWHEAD
4f8a			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4f8a			 
4f8a			;		; malloc a string to target 
4f8a			;		ld hl, 10     ; TODO max string size should be fine 
4f8a			;		call malloc 
4f8a			;		push hl    ; save malloc location 
4f8a			; 
4f8a			; 
4f8a			;; TODO check int type 
4f8a					if DEBUG_FORTH_WORDS_KEY 
4f8a						DMARK "N2S" 
4f8a f5				push af  
4f8b 3a 9f 4f			ld a, (.dmark)  
4f8e 32 9d fd			ld (debug_mark),a  
4f91 3a a0 4f			ld a, (.dmark+1)  
4f94 32 9e fd			ld (debug_mark+1),a  
4f97 3a a1 4f			ld a, (.dmark+2)  
4f9a 32 9f fd			ld (debug_mark+2),a  
4f9d 18 03			jr .pastdmark  
4f9f ..			.dmark: db "N2S"  
4fa2 f1			.pastdmark: pop af  
4fa3			endm  
# End of macro DMARK
4fa3						CALLMONITOR 
4fa3 cd aa fd			call debug_vector  
4fa6				endm  
# End of macro CALLMONITOR
4fa6					endif 
4fa6			 
4fa6					FORTH_DSP_VALUEHL 
4fa6 cd 6c 21			call macro_dsp_valuehl 
4fa9				endm 
# End of macro FORTH_DSP_VALUEHL
4fa9			 
4fa9					if DEBUG_FORTH_WORDS 
4fa9						DMARK "NS1" 
4fa9 f5				push af  
4faa 3a be 4f			ld a, (.dmark)  
4fad 32 9d fd			ld (debug_mark),a  
4fb0 3a bf 4f			ld a, (.dmark+1)  
4fb3 32 9e fd			ld (debug_mark+1),a  
4fb6 3a c0 4f			ld a, (.dmark+2)  
4fb9 32 9f fd			ld (debug_mark+2),a  
4fbc 18 03			jr .pastdmark  
4fbe ..			.dmark: db "NS1"  
4fc1 f1			.pastdmark: pop af  
4fc2			endm  
# End of macro DMARK
4fc2						CALLMONITOR 
4fc2 cd aa fd			call debug_vector  
4fc5				endm  
# End of macro CALLMONITOR
4fc5					endif 
4fc5					FORTH_DSP_POP 
4fc5 cd 24 22			call macro_forth_dsp_pop 
4fc8				endm 
# End of macro FORTH_DSP_POP
4fc8			 
4fc8 eb					ex de, hl 
4fc9 21 f3 f0				ld hl, scratch 
4fcc					if DEBUG_FORTH_WORDS 
4fcc						DMARK "NS2" 
4fcc f5				push af  
4fcd 3a e1 4f			ld a, (.dmark)  
4fd0 32 9d fd			ld (debug_mark),a  
4fd3 3a e2 4f			ld a, (.dmark+1)  
4fd6 32 9e fd			ld (debug_mark+1),a  
4fd9 3a e3 4f			ld a, (.dmark+2)  
4fdc 32 9f fd			ld (debug_mark+2),a  
4fdf 18 03			jr .pastdmark  
4fe1 ..			.dmark: db "NS2"  
4fe4 f1			.pastdmark: pop af  
4fe5			endm  
# End of macro DMARK
4fe5						CALLMONITOR 
4fe5 cd aa fd			call debug_vector  
4fe8				endm  
# End of macro CALLMONITOR
4fe8					endif 
4fe8 cd b3 12				call uitoa_16 
4feb 21 f3 f0				ld hl, scratch 
4fee					if DEBUG_FORTH_WORDS 
4fee						DMARK "NS3" 
4fee f5				push af  
4fef 3a 03 50			ld a, (.dmark)  
4ff2 32 9d fd			ld (debug_mark),a  
4ff5 3a 04 50			ld a, (.dmark+1)  
4ff8 32 9e fd			ld (debug_mark+1),a  
4ffb 3a 05 50			ld a, (.dmark+2)  
4ffe 32 9f fd			ld (debug_mark+2),a  
5001 18 03			jr .pastdmark  
5003 ..			.dmark: db "NS3"  
5006 f1			.pastdmark: pop af  
5007			endm  
# End of macro DMARK
5007						CALLMONITOR 
5007 cd aa fd			call debug_vector  
500a				endm  
# End of macro CALLMONITOR
500a					endif 
500a cd da 1f				call forth_push_str 
500d			;		ld a, l 
500d			;		call DispAToASCII   
500d			;;TODO need to chage above call to dump into string 
500d			; 
500d			; 
500d			 
500d				       NEXTW 
500d cd a7 fd			call parse_vector 
5010 c3 53 23			jp macro_next 
5013				endm 
# End of macro NEXTW
5013			 
5013			.CONCAT: 
5013				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
5013 48				db WORD_SYS_CORE+52             
5014 c9 50			dw .FIND            
5016 07				db 6 + 1 
5017 .. 00			db "CONCAT",0              
501e				endm 
# End of macro CWHEAD
501e			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
501e			 
501e			; TODO check string type 
501e			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
501e			 
501e					if DEBUG_FORTH_WORDS_KEY 
501e						DMARK "CON" 
501e f5				push af  
501f 3a 33 50			ld a, (.dmark)  
5022 32 9d fd			ld (debug_mark),a  
5025 3a 34 50			ld a, (.dmark+1)  
5028 32 9e fd			ld (debug_mark+1),a  
502b 3a 35 50			ld a, (.dmark+2)  
502e 32 9f fd			ld (debug_mark+2),a  
5031 18 03			jr .pastdmark  
5033 ..			.dmark: db "CON"  
5036 f1			.pastdmark: pop af  
5037			endm  
# End of macro DMARK
5037						CALLMONITOR 
5037 cd aa fd			call debug_vector  
503a				endm  
# End of macro CALLMONITOR
503a					endif 
503a			 
503a			 
503a					FORTH_DSP_VALUE 
503a cd 55 21			call macro_forth_dsp_value 
503d				endm 
# End of macro FORTH_DSP_VALUE
503d e5					push hl   ; s2 
503e			 
503e					FORTH_DSP_POP 
503e cd 24 22			call macro_forth_dsp_pop 
5041				endm 
# End of macro FORTH_DSP_POP
5041			 
5041					FORTH_DSP_VALUE 
5041 cd 55 21			call macro_forth_dsp_value 
5044				endm 
# End of macro FORTH_DSP_VALUE
5044			 
5044 e5					push hl   ; s1 
5045			 
5045					FORTH_DSP_POP 
5045 cd 24 22			call macro_forth_dsp_pop 
5048				endm 
# End of macro FORTH_DSP_POP
5048					 
5048			 
5048					; copy s1 
5048			 
5048				 
5048					; save ptr 
5048 e1					pop hl  
5049 e5					push hl 
504a 3e 00				ld a, 0 
504c cd 0f 13				call strlent 
504f					;inc hl    ; zer0 
504f 06 00				ld b, 0 
5051 4d					ld c, l 
5052 e1					pop hl		 
5053 11 f3 f0				ld de, scratch	 
5056					if DEBUG_FORTH_WORDS 
5056						DMARK "CO1" 
5056 f5				push af  
5057 3a 6b 50			ld a, (.dmark)  
505a 32 9d fd			ld (debug_mark),a  
505d 3a 6c 50			ld a, (.dmark+1)  
5060 32 9e fd			ld (debug_mark+1),a  
5063 3a 6d 50			ld a, (.dmark+2)  
5066 32 9f fd			ld (debug_mark+2),a  
5069 18 03			jr .pastdmark  
506b ..			.dmark: db "CO1"  
506e f1			.pastdmark: pop af  
506f			endm  
# End of macro DMARK
506f						CALLMONITOR 
506f cd aa fd			call debug_vector  
5072				endm  
# End of macro CALLMONITOR
5072					endif 
5072 ed b0				ldir 
5074			 
5074 e1					pop hl 
5075 e5					push hl 
5076 d5					push de 
5077			 
5077			 
5077 3e 00				ld a, 0 
5079 cd 0f 13				call strlent 
507c 23					inc hl    ; zer0 
507d 23					inc hl 
507e 06 00				ld b, 0 
5080 4d					ld c, l 
5081 d1					pop de 
5082 e1					pop hl		 
5083					if DEBUG_FORTH_WORDS 
5083						DMARK "CO2" 
5083 f5				push af  
5084 3a 98 50			ld a, (.dmark)  
5087 32 9d fd			ld (debug_mark),a  
508a 3a 99 50			ld a, (.dmark+1)  
508d 32 9e fd			ld (debug_mark+1),a  
5090 3a 9a 50			ld a, (.dmark+2)  
5093 32 9f fd			ld (debug_mark+2),a  
5096 18 03			jr .pastdmark  
5098 ..			.dmark: db "CO2"  
509b f1			.pastdmark: pop af  
509c			endm  
# End of macro DMARK
509c						CALLMONITOR 
509c cd aa fd			call debug_vector  
509f				endm  
# End of macro CALLMONITOR
509f					endif 
509f ed b0				ldir 
50a1			 
50a1			 
50a1			 
50a1 21 f3 f0				ld hl, scratch 
50a4					if DEBUG_FORTH_WORDS 
50a4						DMARK "CO5" 
50a4 f5				push af  
50a5 3a b9 50			ld a, (.dmark)  
50a8 32 9d fd			ld (debug_mark),a  
50ab 3a ba 50			ld a, (.dmark+1)  
50ae 32 9e fd			ld (debug_mark+1),a  
50b1 3a bb 50			ld a, (.dmark+2)  
50b4 32 9f fd			ld (debug_mark+2),a  
50b7 18 03			jr .pastdmark  
50b9 ..			.dmark: db "CO5"  
50bc f1			.pastdmark: pop af  
50bd			endm  
# End of macro DMARK
50bd						CALLMONITOR 
50bd cd aa fd			call debug_vector  
50c0				endm  
# End of macro CALLMONITOR
50c0					endif 
50c0			 
50c0 cd da 1f				call forth_push_str 
50c3			 
50c3			 
50c3			 
50c3			 
50c3				       NEXTW 
50c3 cd a7 fd			call parse_vector 
50c6 c3 53 23			jp macro_next 
50c9				endm 
# End of macro NEXTW
50c9			 
50c9			 
50c9			.FIND: 
50c9				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
50c9 4b				db WORD_SYS_CORE+55             
50ca 89 51			dw .LEN            
50cc 05				db 4 + 1 
50cd .. 00			db "FIND",0              
50d2				endm 
# End of macro CWHEAD
50d2			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
50d2			 
50d2					if DEBUG_FORTH_WORDS_KEY 
50d2						DMARK "FND" 
50d2 f5				push af  
50d3 3a e7 50			ld a, (.dmark)  
50d6 32 9d fd			ld (debug_mark),a  
50d9 3a e8 50			ld a, (.dmark+1)  
50dc 32 9e fd			ld (debug_mark+1),a  
50df 3a e9 50			ld a, (.dmark+2)  
50e2 32 9f fd			ld (debug_mark+2),a  
50e5 18 03			jr .pastdmark  
50e7 ..			.dmark: db "FND"  
50ea f1			.pastdmark: pop af  
50eb			endm  
# End of macro DMARK
50eb						CALLMONITOR 
50eb cd aa fd			call debug_vector  
50ee				endm  
# End of macro CALLMONITOR
50ee					endif 
50ee			 
50ee			; TODO check string type 
50ee					FORTH_DSP_VALUE 
50ee cd 55 21			call macro_forth_dsp_value 
50f1				endm 
# End of macro FORTH_DSP_VALUE
50f1			 
50f1 e5					push hl    
50f2 7e					ld a,(hl)    ; char to find   
50f3			; TODO change char to substr 
50f3			 
50f3 f5					push af 
50f4					 
50f4			 
50f4			 
50f4					if DEBUG_FORTH_WORDS 
50f4						DMARK "FN1" 
50f4 f5				push af  
50f5 3a 09 51			ld a, (.dmark)  
50f8 32 9d fd			ld (debug_mark),a  
50fb 3a 0a 51			ld a, (.dmark+1)  
50fe 32 9e fd			ld (debug_mark+1),a  
5101 3a 0b 51			ld a, (.dmark+2)  
5104 32 9f fd			ld (debug_mark+2),a  
5107 18 03			jr .pastdmark  
5109 ..			.dmark: db "FN1"  
510c f1			.pastdmark: pop af  
510d			endm  
# End of macro DMARK
510d						CALLMONITOR 
510d cd aa fd			call debug_vector  
5110				endm  
# End of macro CALLMONITOR
5110					endif 
5110			 
5110					FORTH_DSP_POP 
5110 cd 24 22			call macro_forth_dsp_pop 
5113				endm 
# End of macro FORTH_DSP_POP
5113			 
5113					; string to search 
5113			 
5113					FORTH_DSP_VALUE 
5113 cd 55 21			call macro_forth_dsp_value 
5116				endm 
# End of macro FORTH_DSP_VALUE
5116			 
5116 d1					pop de  ; d is char to find  
5117			 
5117					if DEBUG_FORTH_WORDS 
5117						DMARK "FN2" 
5117 f5				push af  
5118 3a 2c 51			ld a, (.dmark)  
511b 32 9d fd			ld (debug_mark),a  
511e 3a 2d 51			ld a, (.dmark+1)  
5121 32 9e fd			ld (debug_mark+1),a  
5124 3a 2e 51			ld a, (.dmark+2)  
5127 32 9f fd			ld (debug_mark+2),a  
512a 18 03			jr .pastdmark  
512c ..			.dmark: db "FN2"  
512f f1			.pastdmark: pop af  
5130			endm  
# End of macro DMARK
5130						CALLMONITOR 
5130 cd aa fd			call debug_vector  
5133				endm  
# End of macro CALLMONITOR
5133					endif 
5133					 
5133 01 00 00				ld bc, 0 
5136 7e			.findchar:      ld a,(hl) 
5137			;		cp 0   		 
5137 b7					or a 
5138 28 27				jr z, .finddone     
513a ba					cp d 
513b 28 20				jr z, .foundchar 
513d 03					inc bc 
513e 23					inc hl 
513f					if DEBUG_FORTH_WORDS 
513f						DMARK "FN3" 
513f f5				push af  
5140 3a 54 51			ld a, (.dmark)  
5143 32 9d fd			ld (debug_mark),a  
5146 3a 55 51			ld a, (.dmark+1)  
5149 32 9e fd			ld (debug_mark+1),a  
514c 3a 56 51			ld a, (.dmark+2)  
514f 32 9f fd			ld (debug_mark+2),a  
5152 18 03			jr .pastdmark  
5154 ..			.dmark: db "FN3"  
5157 f1			.pastdmark: pop af  
5158			endm  
# End of macro DMARK
5158						CALLMONITOR 
5158 cd aa fd			call debug_vector  
515b				endm  
# End of macro CALLMONITOR
515b					endif 
515b 18 d9				jr .findchar 
515d			 
515d			 
515d c5			.foundchar:	push bc 
515e e1					pop hl 
515f 18 03				jr .findexit 
5161			 
5161			 
5161							 
5161			 
5161			.finddone:     ; got to end of string with no find 
5161 21 00 00				ld hl, 0 
5164			.findexit: 
5164			 
5164					if DEBUG_FORTH_WORDS 
5164						DMARK "FNd" 
5164 f5				push af  
5165 3a 79 51			ld a, (.dmark)  
5168 32 9d fd			ld (debug_mark),a  
516b 3a 7a 51			ld a, (.dmark+1)  
516e 32 9e fd			ld (debug_mark+1),a  
5171 3a 7b 51			ld a, (.dmark+2)  
5174 32 9f fd			ld (debug_mark+2),a  
5177 18 03			jr .pastdmark  
5179 ..			.dmark: db "FNd"  
517c f1			.pastdmark: pop af  
517d			endm  
# End of macro DMARK
517d						CALLMONITOR 
517d cd aa fd			call debug_vector  
5180				endm  
# End of macro CALLMONITOR
5180					endif 
5180 cd 70 1f			call forth_push_numhl 
5183			 
5183				       NEXTW 
5183 cd a7 fd			call parse_vector 
5186 c3 53 23			jp macro_next 
5189				endm 
# End of macro NEXTW
5189			 
5189			.LEN: 
5189				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
5189 4c				db WORD_SYS_CORE+56             
518a f6 51			dw .ASC            
518c 06				db 5 + 1 
518d .. 00			db "COUNT",0              
5193				endm 
# End of macro CWHEAD
5193			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
5193			 
5193					if DEBUG_FORTH_WORDS_KEY 
5193						DMARK "CNT" 
5193 f5				push af  
5194 3a a8 51			ld a, (.dmark)  
5197 32 9d fd			ld (debug_mark),a  
519a 3a a9 51			ld a, (.dmark+1)  
519d 32 9e fd			ld (debug_mark+1),a  
51a0 3a aa 51			ld a, (.dmark+2)  
51a3 32 9f fd			ld (debug_mark+2),a  
51a6 18 03			jr .pastdmark  
51a8 ..			.dmark: db "CNT"  
51ab f1			.pastdmark: pop af  
51ac			endm  
# End of macro DMARK
51ac						CALLMONITOR 
51ac cd aa fd			call debug_vector  
51af				endm  
# End of macro CALLMONITOR
51af					endif 
51af			; TODO check string type 
51af					FORTH_DSP_VALUE 
51af cd 55 21			call macro_forth_dsp_value 
51b2				endm 
# End of macro FORTH_DSP_VALUE
51b2			 
51b2			 
51b2					if DEBUG_FORTH_WORDS 
51b2						DMARK "CN?" 
51b2 f5				push af  
51b3 3a c7 51			ld a, (.dmark)  
51b6 32 9d fd			ld (debug_mark),a  
51b9 3a c8 51			ld a, (.dmark+1)  
51bc 32 9e fd			ld (debug_mark+1),a  
51bf 3a c9 51			ld a, (.dmark+2)  
51c2 32 9f fd			ld (debug_mark+2),a  
51c5 18 03			jr .pastdmark  
51c7 ..			.dmark: db "CN?"  
51ca f1			.pastdmark: pop af  
51cb			endm  
# End of macro DMARK
51cb						CALLMONITOR 
51cb cd aa fd			call debug_vector  
51ce				endm  
# End of macro CALLMONITOR
51ce					endif 
51ce cd 04 13				call strlenz 
51d1					if DEBUG_FORTH_WORDS 
51d1						DMARK "CNl" 
51d1 f5				push af  
51d2 3a e6 51			ld a, (.dmark)  
51d5 32 9d fd			ld (debug_mark),a  
51d8 3a e7 51			ld a, (.dmark+1)  
51db 32 9e fd			ld (debug_mark+1),a  
51de 3a e8 51			ld a, (.dmark+2)  
51e1 32 9f fd			ld (debug_mark+2),a  
51e4 18 03			jr .pastdmark  
51e6 ..			.dmark: db "CNl"  
51e9 f1			.pastdmark: pop af  
51ea			endm  
# End of macro DMARK
51ea						CALLMONITOR 
51ea cd aa fd			call debug_vector  
51ed				endm  
# End of macro CALLMONITOR
51ed					endif 
51ed			 
51ed cd 70 1f				call forth_push_numhl 
51f0			 
51f0			 
51f0			 
51f0				       NEXTW 
51f0 cd a7 fd			call parse_vector 
51f3 c3 53 23			jp macro_next 
51f6				endm 
# End of macro NEXTW
51f6			.ASC: 
51f6				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
51f6 4d				db WORD_SYS_CORE+57             
51f7 67 52			dw .CHR            
51f9 04				db 3 + 1 
51fa .. 00			db "ASC",0              
51fe				endm 
# End of macro CWHEAD
51fe			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
51fe					if DEBUG_FORTH_WORDS_KEY 
51fe						DMARK "ASC" 
51fe f5				push af  
51ff 3a 13 52			ld a, (.dmark)  
5202 32 9d fd			ld (debug_mark),a  
5205 3a 14 52			ld a, (.dmark+1)  
5208 32 9e fd			ld (debug_mark+1),a  
520b 3a 15 52			ld a, (.dmark+2)  
520e 32 9f fd			ld (debug_mark+2),a  
5211 18 03			jr .pastdmark  
5213 ..			.dmark: db "ASC"  
5216 f1			.pastdmark: pop af  
5217			endm  
# End of macro DMARK
5217						CALLMONITOR 
5217 cd aa fd			call debug_vector  
521a				endm  
# End of macro CALLMONITOR
521a					endif 
521a					FORTH_DSP_VALUE 
521a cd 55 21			call macro_forth_dsp_value 
521d				endm 
# End of macro FORTH_DSP_VALUE
521d					;v5 FORTH_DSP_VALUE 
521d			;		inc hl      ; now at start of numeric as string 
521d			 
521d e5					push hl 
521e			 
521e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
521e cd 24 22			call macro_forth_dsp_pop 
5221				endm 
# End of macro FORTH_DSP_POP
5221			 
5221 e1					pop hl 
5222			 
5222					if DEBUG_FORTH_WORDS 
5222						DMARK "AS1" 
5222 f5				push af  
5223 3a 37 52			ld a, (.dmark)  
5226 32 9d fd			ld (debug_mark),a  
5229 3a 38 52			ld a, (.dmark+1)  
522c 32 9e fd			ld (debug_mark+1),a  
522f 3a 39 52			ld a, (.dmark+2)  
5232 32 9f fd			ld (debug_mark+2),a  
5235 18 03			jr .pastdmark  
5237 ..			.dmark: db "AS1"  
523a f1			.pastdmark: pop af  
523b			endm  
# End of macro DMARK
523b						CALLMONITOR 
523b cd aa fd			call debug_vector  
523e				endm  
# End of macro CALLMONITOR
523e					endif 
523e					; push the content of a onto the stack as a value 
523e			 
523e 7e					ld a,(hl)   ; get char 
523f 26 00				ld h,0 
5241 6f					ld l,a 
5242					if DEBUG_FORTH_WORDS 
5242						DMARK "AS2" 
5242 f5				push af  
5243 3a 57 52			ld a, (.dmark)  
5246 32 9d fd			ld (debug_mark),a  
5249 3a 58 52			ld a, (.dmark+1)  
524c 32 9e fd			ld (debug_mark+1),a  
524f 3a 59 52			ld a, (.dmark+2)  
5252 32 9f fd			ld (debug_mark+2),a  
5255 18 03			jr .pastdmark  
5257 ..			.dmark: db "AS2"  
525a f1			.pastdmark: pop af  
525b			endm  
# End of macro DMARK
525b						CALLMONITOR 
525b cd aa fd			call debug_vector  
525e				endm  
# End of macro CALLMONITOR
525e					endif 
525e cd 70 1f				call forth_push_numhl 
5261			 
5261				       NEXTW 
5261 cd a7 fd			call parse_vector 
5264 c3 53 23			jp macro_next 
5267				endm 
# End of macro NEXTW
5267			 
5267			.CHR: 
5267				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
5267 4d				db WORD_SYS_CORE+57             
5268 a6 52			dw .ENDSTR            
526a 04				db 3 + 1 
526b .. 00			db "CHR",0              
526f				endm 
# End of macro CWHEAD
526f			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
526f					if DEBUG_FORTH_WORDS_KEY 
526f						DMARK "CHR" 
526f f5				push af  
5270 3a 84 52			ld a, (.dmark)  
5273 32 9d fd			ld (debug_mark),a  
5276 3a 85 52			ld a, (.dmark+1)  
5279 32 9e fd			ld (debug_mark+1),a  
527c 3a 86 52			ld a, (.dmark+2)  
527f 32 9f fd			ld (debug_mark+2),a  
5282 18 03			jr .pastdmark  
5284 ..			.dmark: db "CHR"  
5287 f1			.pastdmark: pop af  
5288			endm  
# End of macro DMARK
5288						CALLMONITOR 
5288 cd aa fd			call debug_vector  
528b				endm  
# End of macro CALLMONITOR
528b					endif 
528b					FORTH_DSP_VALUEHL 
528b cd 6c 21			call macro_dsp_valuehl 
528e				endm 
# End of macro FORTH_DSP_VALUEHL
528e			 
528e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
528e cd 24 22			call macro_forth_dsp_pop 
5291				endm 
# End of macro FORTH_DSP_POP
5291			 
5291					; save asci byte as a zero term string and push string 
5291			 
5291 7d					ld a,l 
5292 32 f3 f0				ld (scratch), a 
5295			 
5295 3e 00				ld a, 0 
5297 32 f4 f0				ld (scratch+1), a 
529a			 
529a 21 f3 f0				ld hl, scratch 
529d cd da 1f				call forth_push_str 
52a0			 
52a0			 
52a0				       NEXTW 
52a0 cd a7 fd			call parse_vector 
52a3 c3 53 23			jp macro_next 
52a6				endm 
# End of macro NEXTW
52a6			 
52a6			 
52a6			 
52a6			 
52a6			.ENDSTR: 
52a6			; eof 
52a6			 
# End of file forth_words_str.asm
52a6			include "forth_words_key.asm" 
52a6			 
52a6			; | ## Keyboard Words 
52a6			 
52a6			.KEY: 
52a6				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
52a6 3e				db WORD_SYS_CORE+42             
52a7 d9 52			dw .KEYDB            
52a9 04				db 3 + 1 
52aa .. 00			db "KEY",0              
52ae				endm 
# End of macro CWHEAD
52ae			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
52ae			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
52ae			; | | Can use something like this to process: 
52ae			; | | > repeat active . key ?dup if emit then #1 until  
52ae			 
52ae					if DEBUG_FORTH_WORDS_KEY 
52ae						DMARK "KEY" 
52ae f5				push af  
52af 3a c3 52			ld a, (.dmark)  
52b2 32 9d fd			ld (debug_mark),a  
52b5 3a c4 52			ld a, (.dmark+1)  
52b8 32 9e fd			ld (debug_mark+1),a  
52bb 3a c5 52			ld a, (.dmark+2)  
52be 32 9f fd			ld (debug_mark+2),a  
52c1 18 03			jr .pastdmark  
52c3 ..			.dmark: db "KEY"  
52c6 f1			.pastdmark: pop af  
52c7			endm  
# End of macro DMARK
52c7						CALLMONITOR 
52c7 cd aa fd			call debug_vector  
52ca				endm  
# End of macro CALLMONITOR
52ca					endif 
52ca			; TODO currently waits 
52ca cd 5e 7a				call cinndb 
52cd					;call cin_wait 
52cd 6f					ld l, a 
52ce 26 00				ld h, 0 
52d0 cd 70 1f				call forth_push_numhl 
52d3					NEXTW 
52d3 cd a7 fd			call parse_vector 
52d6 c3 53 23			jp macro_next 
52d9				endm 
# End of macro NEXTW
52d9			.KEYDB: 
52d9				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
52d9 3e				db WORD_SYS_CORE+42             
52da 0e 53			dw .WAITK            
52dc 06				db 5 + 1 
52dd .. 00			db "KEYDB",0              
52e3				endm 
# End of macro CWHEAD
52e3			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
52e3			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
52e3			; | | Can use something like this to process: 
52e3			; | | > repeat active . key ?dup if emit then #1 until  
52e3			 
52e3					if DEBUG_FORTH_WORDS_KEY 
52e3						DMARK "KEB" 
52e3 f5				push af  
52e4 3a f8 52			ld a, (.dmark)  
52e7 32 9d fd			ld (debug_mark),a  
52ea 3a f9 52			ld a, (.dmark+1)  
52ed 32 9e fd			ld (debug_mark+1),a  
52f0 3a fa 52			ld a, (.dmark+2)  
52f3 32 9f fd			ld (debug_mark+2),a  
52f6 18 03			jr .pastdmark  
52f8 ..			.dmark: db "KEB"  
52fb f1			.pastdmark: pop af  
52fc			endm  
# End of macro DMARK
52fc						CALLMONITOR 
52fc cd aa fd			call debug_vector  
52ff				endm  
# End of macro CALLMONITOR
52ff					endif 
52ff			; TODO currently waits 
52ff cd 4b 7a				call cin 
5302					;call cin_wait 
5302 6f					ld l, a 
5303 26 00				ld h, 0 
5305 cd 70 1f				call forth_push_numhl 
5308					NEXTW 
5308 cd a7 fd			call parse_vector 
530b c3 53 23			jp macro_next 
530e				endm 
# End of macro NEXTW
530e			.WAITK: 
530e				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
530e 3f				db WORD_SYS_CORE+43             
530f 43 53			dw .ACCEPT            
5311 06				db 5 + 1 
5312 .. 00			db "WAITK",0              
5318				endm 
# End of macro CWHEAD
5318			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
5318					if DEBUG_FORTH_WORDS_KEY 
5318						DMARK "WAI" 
5318 f5				push af  
5319 3a 2d 53			ld a, (.dmark)  
531c 32 9d fd			ld (debug_mark),a  
531f 3a 2e 53			ld a, (.dmark+1)  
5322 32 9e fd			ld (debug_mark+1),a  
5325 3a 2f 53			ld a, (.dmark+2)  
5328 32 9f fd			ld (debug_mark+2),a  
532b 18 03			jr .pastdmark  
532d ..			.dmark: db "WAI"  
5330 f1			.pastdmark: pop af  
5331			endm  
# End of macro DMARK
5331						CALLMONITOR 
5331 cd aa fd			call debug_vector  
5334				endm  
# End of macro CALLMONITOR
5334					endif 
5334 cd 3c 7a				call cin_wait 
5337 6f					ld l, a 
5338 26 00				ld h, 0 
533a cd 70 1f				call forth_push_numhl 
533d					NEXTW 
533d cd a7 fd			call parse_vector 
5340 c3 53 23			jp macro_next 
5343				endm 
# End of macro NEXTW
5343			.ACCEPT: 
5343				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
5343 40				db WORD_SYS_CORE+44             
5344 a3 53			dw .EDIT            
5346 07				db 6 + 1 
5347 .. 00			db "ACCEPT",0              
534e				endm 
# End of macro CWHEAD
534e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
534e					; TODO crashes on push 
534e					if DEBUG_FORTH_WORDS_KEY 
534e						DMARK "ACC" 
534e f5				push af  
534f 3a 63 53			ld a, (.dmark)  
5352 32 9d fd			ld (debug_mark),a  
5355 3a 64 53			ld a, (.dmark+1)  
5358 32 9e fd			ld (debug_mark+1),a  
535b 3a 65 53			ld a, (.dmark+2)  
535e 32 9f fd			ld (debug_mark+2),a  
5361 18 03			jr .pastdmark  
5363 ..			.dmark: db "ACC"  
5366 f1			.pastdmark: pop af  
5367			endm  
# End of macro DMARK
5367						CALLMONITOR 
5367 cd aa fd			call debug_vector  
536a				endm  
# End of macro CALLMONITOR
536a					endif 
536a 21 f1 f2				ld hl, os_input 
536d			;		ld a, 0 
536d 36 00				ld (hl),0 
536f 3a 90 f9				ld a,(f_cursor_ptr) 
5372 16 64				ld d, 100 
5374 0e 00				ld c, 0 
5376 1e 28				ld e, 40 
5378 cd d9 0f				call input_str 
537b					; TODO perhaps do a type check and wrap in quotes if not a number 
537b 21 f1 f2				ld hl, os_input 
537e					if DEBUG_FORTH_WORDS 
537e						DMARK "AC1" 
537e f5				push af  
537f 3a 93 53			ld a, (.dmark)  
5382 32 9d fd			ld (debug_mark),a  
5385 3a 94 53			ld a, (.dmark+1)  
5388 32 9e fd			ld (debug_mark+1),a  
538b 3a 95 53			ld a, (.dmark+2)  
538e 32 9f fd			ld (debug_mark+2),a  
5391 18 03			jr .pastdmark  
5393 ..			.dmark: db "AC1"  
5396 f1			.pastdmark: pop af  
5397			endm  
# End of macro DMARK
5397						CALLMONITOR 
5397 cd aa fd			call debug_vector  
539a				endm  
# End of macro CALLMONITOR
539a					endif 
539a cd da 1f				call forth_push_str 
539d					NEXTW 
539d cd a7 fd			call parse_vector 
53a0 c3 53 23			jp macro_next 
53a3				endm 
# End of macro NEXTW
53a3			 
53a3			.EDIT: 
53a3				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
53a3 40				db WORD_SYS_CORE+44             
53a4 48 54			dw .DEDIT            
53a6 05				db 4 + 1 
53a7 .. 00			db "EDIT",0              
53ac				endm 
# End of macro CWHEAD
53ac			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
53ac			 
53ac					; TODO does not copy from stack 
53ac					if DEBUG_FORTH_WORDS_KEY 
53ac						DMARK "EDT" 
53ac f5				push af  
53ad 3a c1 53			ld a, (.dmark)  
53b0 32 9d fd			ld (debug_mark),a  
53b3 3a c2 53			ld a, (.dmark+1)  
53b6 32 9e fd			ld (debug_mark+1),a  
53b9 3a c3 53			ld a, (.dmark+2)  
53bc 32 9f fd			ld (debug_mark+2),a  
53bf 18 03			jr .pastdmark  
53c1 ..			.dmark: db "EDT"  
53c4 f1			.pastdmark: pop af  
53c5			endm  
# End of macro DMARK
53c5						CALLMONITOR 
53c5 cd aa fd			call debug_vector  
53c8				endm  
# End of macro CALLMONITOR
53c8					endif 
53c8			 
53c8					;FORTH_DSP 
53c8					FORTH_DSP_VALUEHL 
53c8 cd 6c 21			call macro_dsp_valuehl 
53cb				endm 
# End of macro FORTH_DSP_VALUEHL
53cb			;		inc hl    ; TODO do type check 
53cb			 
53cb			;		call get_word_hl 
53cb e5					push hl 
53cc					if DEBUG_FORTH_WORDS 
53cc						DMARK "EDp" 
53cc f5				push af  
53cd 3a e1 53			ld a, (.dmark)  
53d0 32 9d fd			ld (debug_mark),a  
53d3 3a e2 53			ld a, (.dmark+1)  
53d6 32 9e fd			ld (debug_mark+1),a  
53d9 3a e3 53			ld a, (.dmark+2)  
53dc 32 9f fd			ld (debug_mark+2),a  
53df 18 03			jr .pastdmark  
53e1 ..			.dmark: db "EDp"  
53e4 f1			.pastdmark: pop af  
53e5			endm  
# End of macro DMARK
53e5						CALLMONITOR 
53e5 cd aa fd			call debug_vector  
53e8				endm  
# End of macro CALLMONITOR
53e8					endif 
53e8				;	ld a, 0 
53e8 cd 04 13				call strlenz 
53eb 23					inc hl 
53ec			 
53ec 06 00				ld b, 0 
53ee 4d					ld c, l 
53ef			 
53ef e1					pop hl 
53f0 11 f1 f2				ld de, os_input 
53f3					if DEBUG_FORTH_WORDS_KEY 
53f3						DMARK "EDc" 
53f3 f5				push af  
53f4 3a 08 54			ld a, (.dmark)  
53f7 32 9d fd			ld (debug_mark),a  
53fa 3a 09 54			ld a, (.dmark+1)  
53fd 32 9e fd			ld (debug_mark+1),a  
5400 3a 0a 54			ld a, (.dmark+2)  
5403 32 9f fd			ld (debug_mark+2),a  
5406 18 03			jr .pastdmark  
5408 ..			.dmark: db "EDc"  
540b f1			.pastdmark: pop af  
540c			endm  
# End of macro DMARK
540c						CALLMONITOR 
540c cd aa fd			call debug_vector  
540f				endm  
# End of macro CALLMONITOR
540f					endif 
540f ed b0				ldir 
5411			 
5411			 
5411 21 f1 f2				ld hl, os_input 
5414					;ld a, 0 
5414					;ld (hl),a 
5414 3a 90 f9				ld a,(f_cursor_ptr) 
5417 16 64				ld d, 100 
5419 0e 00				ld c, 0 
541b 1e 28				ld e, 40 
541d cd d9 0f				call input_str 
5420					; TODO perhaps do a type check and wrap in quotes if not a number 
5420 21 f1 f2				ld hl, os_input 
5423					if DEBUG_FORTH_WORDS 
5423						DMARK "ED1" 
5423 f5				push af  
5424 3a 38 54			ld a, (.dmark)  
5427 32 9d fd			ld (debug_mark),a  
542a 3a 39 54			ld a, (.dmark+1)  
542d 32 9e fd			ld (debug_mark+1),a  
5430 3a 3a 54			ld a, (.dmark+2)  
5433 32 9f fd			ld (debug_mark+2),a  
5436 18 03			jr .pastdmark  
5438 ..			.dmark: db "ED1"  
543b f1			.pastdmark: pop af  
543c			endm  
# End of macro DMARK
543c						CALLMONITOR 
543c cd aa fd			call debug_vector  
543f				endm  
# End of macro CALLMONITOR
543f					endif 
543f cd da 1f				call forth_push_str 
5442					NEXTW 
5442 cd a7 fd			call parse_vector 
5445 c3 53 23			jp macro_next 
5448				endm 
# End of macro NEXTW
5448			 
5448			.DEDIT: 
5448				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
5448 40				db WORD_SYS_CORE+44             
5449 ad 54			dw .ENDKEY            
544b 06				db 5 + 1 
544c .. 00			db "DEDIT",0              
5452				endm 
# End of macro CWHEAD
5452			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
5452			 
5452					; TODO does not copy from stack 
5452					if DEBUG_FORTH_WORDS_KEY 
5452						DMARK "DED" 
5452 f5				push af  
5453 3a 67 54			ld a, (.dmark)  
5456 32 9d fd			ld (debug_mark),a  
5459 3a 68 54			ld a, (.dmark+1)  
545c 32 9e fd			ld (debug_mark+1),a  
545f 3a 69 54			ld a, (.dmark+2)  
5462 32 9f fd			ld (debug_mark+2),a  
5465 18 03			jr .pastdmark  
5467 ..			.dmark: db "DED"  
546a f1			.pastdmark: pop af  
546b			endm  
# End of macro DMARK
546b						CALLMONITOR 
546b cd aa fd			call debug_vector  
546e				endm  
# End of macro CALLMONITOR
546e					endif 
546e			 
546e					;FORTH_DSP 
546e					FORTH_DSP_VALUEHL 
546e cd 6c 21			call macro_dsp_valuehl 
5471				endm 
# End of macro FORTH_DSP_VALUEHL
5471			;		inc hl    ; TODO do type check 
5471			 
5471			;		call get_word_hl 
5471 e5					push hl 
5472 e5					push hl 
5473					FORTH_DSP_POP 
5473 cd 24 22			call macro_forth_dsp_pop 
5476				endm 
# End of macro FORTH_DSP_POP
5476 e1					pop hl 
5477					if DEBUG_FORTH_WORDS 
5477						DMARK "EDp" 
5477 f5				push af  
5478 3a 8c 54			ld a, (.dmark)  
547b 32 9d fd			ld (debug_mark),a  
547e 3a 8d 54			ld a, (.dmark+1)  
5481 32 9e fd			ld (debug_mark+1),a  
5484 3a 8e 54			ld a, (.dmark+2)  
5487 32 9f fd			ld (debug_mark+2),a  
548a 18 03			jr .pastdmark  
548c ..			.dmark: db "EDp"  
548f f1			.pastdmark: pop af  
5490			endm  
# End of macro DMARK
5490						CALLMONITOR 
5490 cd aa fd			call debug_vector  
5493				endm  
# End of macro CALLMONITOR
5493					endif 
5493				;	ld a, 0 
5493 cd 04 13				call strlenz 
5496 23					inc hl 
5497			 
5497 06 00				ld b, 0 
5499 4d					ld c, l 
549a			 
549a e1					pop hl 
549b			 
549b					;ld a, 0 
549b					;ld (hl),a 
549b 3a 90 f9				ld a,(f_cursor_ptr) 
549e 16 64				ld d, 100 
54a0 0e 00				ld c, 0 
54a2 1e 28				ld e, 40 
54a4 cd d9 0f				call input_str 
54a7					; TODO perhaps do a type check and wrap in quotes if not a number 
54a7					NEXTW 
54a7 cd a7 fd			call parse_vector 
54aa c3 53 23			jp macro_next 
54ad				endm 
# End of macro NEXTW
54ad			 
54ad			 
54ad			.ENDKEY: 
54ad			; eof 
54ad			 
# End of file forth_words_key.asm
54ad			include "forth_words_const.asm" 
54ad			 
54ad			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
54ad			 
54ad			 
54ad			.SPITIME: 
54ad				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
54ad 77				db WORD_SYS_CORE+99             
54ae c5 54			dw .VA            
54b0 08				db 7 + 1 
54b1 .. 00			db "SPITIME",0              
54b9				endm 
# End of macro CWHEAD
54b9			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
54b9			; 
54b9			; | | If using BANK devices then leave as is. 
54b9			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
54b9			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
54b9			 
54b9 21 96 f9				ld hl, spi_clktime  
54bc cd 70 1f				call forth_push_numhl 
54bf			 
54bf					NEXTW 
54bf cd a7 fd			call parse_vector 
54c2 c3 53 23			jp macro_next 
54c5				endm 
# End of macro NEXTW
54c5			 
54c5			 
54c5			.VA: 
54c5				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
54c5 77				db WORD_SYS_CORE+99             
54c6 d8 54			dw .SYMBOL            
54c8 03				db 2 + 1 
54c9 .. 00			db "VA",0              
54cc				endm 
# End of macro CWHEAD
54cc			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
54cc 21 5a f9				ld hl, cli_var_array 
54cf cd 70 1f				call forth_push_numhl 
54d2			 
54d2					NEXTW 
54d2 cd a7 fd			call parse_vector 
54d5 c3 53 23			jp macro_next 
54d8				endm 
# End of macro NEXTW
54d8			 
54d8			.SYMBOL: 
54d8				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
54d8 77				db WORD_SYS_CORE+99             
54d9 e7 55			dw .ENDCONST            
54db 07				db 6 + 1 
54dc .. 00			db "SYMBOL",0              
54e3				endm 
# End of macro CWHEAD
54e3			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
54e3			; | 
54e3			; | | The value is the number reference and the final address is pushed to stack 
54e3			 
54e3			; | | ``` 
54e3			; | | dw sym_table 
54e3			; | | dw nmi_vector 
54e3			; | | dw cli_autodisplay 
54e3			; | | dw cli_data_sp 
54e3			; | | dw cli_data_stack 
54e3			; | | dw cli_loop_sp 
54e3			; | | dw cli_loop_stack 
54e3			; | | dw cli_var_array 
54e3			; | | dw cursor_col 
54e3			; | | dw cursor_ptr 
54e3			; | | ; 10 
54e3			; | | dw cursor_row 
54e3			; | | dw debug_mark 
54e3			; | | dw display_fb0 
54e3			; | | dw display_fb1 
54e3			; | | dw display_fb2 
54e3			; | | dw display_fb3 
54e3			; | | dw display_fb_active 
54e3			; | | dw execscratch 
54e3			; | | dw f_cursor_ptr 
54e3			; | | dw hardware_word 
54e3			; | | ;20 
54e3			; | | dw input_at_cursor 
54e3			; | | dw input_at_pos 
54e3			; | | dw input_cur_flash 
54e3			; | | dw input_cur_onoff 
54e3			; | | dw input_cursor 
54e3			; | | dw input_display_size 
54e3			; | | dw input_len 
54e3			; | | dw input_ptr 
54e3			; | | dw input_size 
54e3			; | | dw input_start 
54e3			; | | ; 30 
54e3			; | | dw input_str 
54e3			; | | dw input_under_cursor 
54e3			; | | dw os_cli_cmd 
54e3			; | | dw os_cur_ptr 
54e3			; | | dw os_current_i 
54e3			; | | dw os_input 
54e3			; | | dw os_last_cmd 
54e3			; | | dw os_last_new_uword 
54e3			; | | dw debug_vector 
54e3			; | | dw os_view_hl 
54e3			; | | ;40 
54e3			; | | dw os_word_scratch 
54e3			; | | dw portbctl 
54e3			; | | dw portbdata 
54e3			; | | dw spi_cartdev 
54e3			; | | dw spi_cartdev2 
54e3			; | | dw spi_clktime 
54e3			; | | dw spi_device 
54e3			; | | dw spi_device_id 
54e3			; | | dw spi_portbyte 
54e3			; | | dw stackstore 
54e3			; | | ; 50 
54e3			; | | if STORAGE_SE 
54e3			; | | dw storage_actl 
54e3			; | | dw storage_adata 
54e3			; | | else 
54e3			; | | dw 0 
54e3			; | | dw 0 
54e3			; | | endif 
54e3			; | | dw storage_append 
54e3			; | | if STORAGE_SE 
54e3			; | | dw storage_bctl 
54e3			; | | else 
54e3			; | | dw 0 
54e3			; | | endif 
54e3			; | | dw store_bank_active 
54e3			; | | dw store_filecache 
54e3			; | | dw store_longread 
54e3			; | | dw store_openaddr 
54e3			; | | dw store_openext 
54e3			; | | dw store_openmaxext 
54e3			; | | ; 60 
54e3			; | | dw store_page 
54e3			; | | dw store_readbuf 
54e3			; | | dw store_readcont 
54e3			; | | dw store_readptr 
54e3			; | | dw store_tmpext 
54e3			; | | dw store_tmpid 
54e3			; | | dw store_tmppageid 
54e3			; | | dw malloc 
54e3			; | | dw free 
54e3			; | | dw cin 
54e3			; | | ; 70 
54e3			; | | dw cin_wait 
54e3			; | | dw forth_push_numhl 
54e3			; | | dw forth_push_str 
54e3			; | | dw parse_vector 
54e3			; | | ``` 
54e3			 
54e3					if DEBUG_FORTH_WORDS_KEY 
54e3						DMARK "SYM" 
54e3 f5				push af  
54e4 3a f8 54			ld a, (.dmark)  
54e7 32 9d fd			ld (debug_mark),a  
54ea 3a f9 54			ld a, (.dmark+1)  
54ed 32 9e fd			ld (debug_mark+1),a  
54f0 3a fa 54			ld a, (.dmark+2)  
54f3 32 9f fd			ld (debug_mark+2),a  
54f6 18 03			jr .pastdmark  
54f8 ..			.dmark: db "SYM"  
54fb f1			.pastdmark: pop af  
54fc			endm  
# End of macro DMARK
54fc						CALLMONITOR 
54fc cd aa fd			call debug_vector  
54ff				endm  
# End of macro CALLMONITOR
54ff					endif 
54ff			 
54ff					FORTH_DSP_VALUEHL 
54ff cd 6c 21			call macro_dsp_valuehl 
5502				endm 
# End of macro FORTH_DSP_VALUEHL
5502			 
5502 7d					ld a, l     
5503			 
5503			 
5503					if DEBUG_FORTH_WORDS 
5503						DMARK "SY1" 
5503 f5				push af  
5504 3a 18 55			ld a, (.dmark)  
5507 32 9d fd			ld (debug_mark),a  
550a 3a 19 55			ld a, (.dmark+1)  
550d 32 9e fd			ld (debug_mark+1),a  
5510 3a 1a 55			ld a, (.dmark+2)  
5513 32 9f fd			ld (debug_mark+2),a  
5516 18 03			jr .pastdmark  
5518 ..			.dmark: db "SY1"  
551b f1			.pastdmark: pop af  
551c			endm  
# End of macro DMARK
551c						CALLMONITOR 
551c cd aa fd			call debug_vector  
551f				endm  
# End of macro CALLMONITOR
551f					endif 
551f					 
551f f5					push af	 
5520					FORTH_DSP_POP 
5520 cd 24 22			call macro_forth_dsp_pop 
5523				endm 
# End of macro FORTH_DSP_POP
5523 f1					pop af 
5524			 
5524 cb 27				sla a  
5526				 
5526					 
5526					if DEBUG_FORTH_WORDS 
5526						DMARK "SY" 
5526 f5				push af  
5527 3a 3b 55			ld a, (.dmark)  
552a 32 9d fd			ld (debug_mark),a  
552d 3a 3c 55			ld a, (.dmark+1)  
5530 32 9e fd			ld (debug_mark+1),a  
5533 3a 3d 55			ld a, (.dmark+2)  
5536 32 9f fd			ld (debug_mark+2),a  
5539 18 02			jr .pastdmark  
553b ..			.dmark: db "SY"  
553d f1			.pastdmark: pop af  
553e			endm  
# End of macro DMARK
553e						CALLMONITOR 
553e cd aa fd			call debug_vector  
5541				endm  
# End of macro CALLMONITOR
5541					endif 
5541			 
5541 21 53 55				ld hl, sym_table 
5544 cd ac 0f				call addatohl 
5547 cd d9 22				call loadwordinhl 
554a cd 70 1f				call forth_push_numhl 
554d			 
554d			 
554d				       NEXTW 
554d cd a7 fd			call parse_vector 
5550 c3 53 23			jp macro_next 
5553				endm 
# End of macro NEXTW
5553			 
5553			sym_table: 
5553			 
5553			; 0 
5553 53 55		dw sym_table 
5555 ad fd		dw nmi_vector 
5557 6e f9		dw cli_autodisplay 
5559 20 f9		dw cli_data_sp 
555b 5a f6		dw cli_data_stack 
555d 22 f9		dw cli_loop_sp 
555f 5c f8		dw cli_loop_stack 
5561 5a f9		dw cli_var_array 
5563 f7 fa		dw cursor_col 
5565 f5 fa		dw cursor_ptr 
5567			; 10 
5567 f6 fa		dw cursor_row 
5569 9d fd		dw debug_mark 
556b e3 fc		dw display_fb0 
556d 42 fc		dw display_fb1 
556f 00 fb		dw display_fb2 
5571 a1 fb		dw display_fb3 
5573 fe fa		dw display_fb_active 
5575 f2 f1		dw execscratch 
5577 90 f9		dw f_cursor_ptr 
5579 b0 fd		dw hardware_word 
557b			;20 
557b 94 fd		dw input_at_cursor 
557d 96 fd		dw input_at_pos 
557f 92 fd		dw input_cur_flash 
5581 91 fd		dw input_cur_onoff 
5583 87 fd		dw input_cursor 
5585 97 fd		dw input_display_size 
5587 8c fd		dw input_len 
5589 9b fd		dw input_ptr 
558b 98 fd		dw input_size 
558d 99 fd		dw input_start 
558f			; 30 
558f d9 0f		dw input_str 
5591 95 fd		dw input_under_cursor 
5593 1a f4		dw os_cli_cmd 
5595 16 f4		dw os_cur_ptr 
5597 18 f4		dw os_current_i 
5599 f1 f2		dw os_input 
559b 19 f5		dw os_last_cmd 
559d f0 f3		dw os_last_new_uword 
559f aa fd		dw debug_vector 
55a1 d5 f0		dw os_view_hl 
55a3			;40 
55a3 f8 f3		dw os_word_scratch 
55a5 c3 00		dw portbctl 
55a7 c1 00		dw portbdata 
55a9 95 f9		dw spi_cartdev 
55ab 94 f9		dw spi_cartdev2 
55ad 96 f9		dw spi_clktime 
55af 92 f9		dw spi_device 
55b1 91 f9		dw spi_device_id 
55b3 93 f9		dw spi_portbyte 
55b5 d9 fa		dw stackstore 
55b7			; 50 
55b7			if STORAGE_SE 
55b7 82 00		dw storage_actl 
55b9 80 00		dw storage_adata 
55bb			else 
55bb			dw 0 
55bb			dw 0 
55bb			endif 
55bb 3b 0b		dw storage_append 
55bd			if STORAGE_SE 
55bd 83 00		dw storage_bctl 
55bf			else 
55bf			dw 0 
55bf			endif 
55bf c5 fa		dw store_bank_active 
55c1 99 f9		dw store_filecache 
55c3 a7 f9		dw store_longread 
55c5 9d f9		dw store_openaddr 
55c7 9c f9		dw store_openext 
55c9 9b f9		dw store_openmaxext 
55cb			; 60 
55cb ac f9		dw store_page 
55cd a8 f9		dw store_readbuf 
55cf 9f f9		dw store_readcont 
55d1 aa f9		dw store_readptr 
55d3 9f f9		dw store_tmpext 
55d5 a0 f9		dw store_tmpid 
55d7 97 f9		dw store_tmppageid 
55d9 78 13		dw malloc 
55db 42 14		dw free 
55dd 4b 7a		dw cin 
55df			; 70 
55df 3c 7a		dw cin_wait 
55e1 70 1f		dw forth_push_numhl 
55e3 da 1f		dw forth_push_str 
55e5 a7 fd		dw parse_vector 
55e7			 
55e7			.ENDCONST: 
55e7			 
55e7			; eof 
55e7			 
55e7			 
# End of file forth_words_const.asm
55e7			 
55e7			if STORAGE_SE 
55e7			   	include "forth_words_storage.asm" 
55e7			 
55e7			; | ## Fixed Storage Words 
55e7			 
55e7			.RENAME: 
55e7			  
55e7				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
55e7 3a				db WORD_SYS_CORE+38             
55e8 e0 56			dw .RECORD            
55ea 07				db 6 + 1 
55eb .. 00			db "RENAME",0              
55f2				endm 
# End of macro CWHEAD
55f2			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
55f2			; | | > [!NOTE] 
55f2			; | | > Compatible with PicoSPINet  
55f2					if DEBUG_FORTH_WORDS_KEY 
55f2						DMARK "REN" 
55f2 f5				push af  
55f3 3a 07 56			ld a, (.dmark)  
55f6 32 9d fd			ld (debug_mark),a  
55f9 3a 08 56			ld a, (.dmark+1)  
55fc 32 9e fd			ld (debug_mark+1),a  
55ff 3a 09 56			ld a, (.dmark+2)  
5602 32 9f fd			ld (debug_mark+2),a  
5605 18 03			jr .pastdmark  
5607 ..			.dmark: db "REN"  
560a f1			.pastdmark: pop af  
560b			endm  
# End of macro DMARK
560b						CALLMONITOR 
560b cd aa fd			call debug_vector  
560e				endm  
# End of macro CALLMONITOR
560e					endif 
560e			 
560e			 
560e					; preserve some internal vars used by other file handing routines 
560e			 
560e 2a 9d f9				ld hl, (store_openaddr) 
5611 e5					push hl 
5612 3a 9f f9				ld a, (store_readcont) 
5615 f5					push af 
5616			 
5616					FORTH_DSP_VALUEHL 
5616 cd 6c 21			call macro_dsp_valuehl 
5619				endm 
# End of macro FORTH_DSP_VALUEHL
5619			 
5619					; move ext and id around for the file header 
5619			 
5619 65					ld h, l 
561a 2e 00				ld l, 0 
561c			 
561c e5					push hl    ; id 
561d			 
561d					FORTH_DSP_POP 
561d cd 24 22			call macro_forth_dsp_pop 
5620				endm 
# End of macro FORTH_DSP_POP
5620			 
5620					; Locate the file header 
5620			 
5620 e1					pop hl 
5621 e5					push hl 
5622 11 ac f9				ld de, store_page      ; get block zero of file 
5625					if DEBUG_FORTH_WORDS 
5625						DMARK "REr" 
5625 f5				push af  
5626 3a 3a 56			ld a, (.dmark)  
5629 32 9d fd			ld (debug_mark),a  
562c 3a 3b 56			ld a, (.dmark+1)  
562f 32 9e fd			ld (debug_mark+1),a  
5632 3a 3c 56			ld a, (.dmark+2)  
5635 32 9f fd			ld (debug_mark+2),a  
5638 18 03			jr .pastdmark  
563a ..			.dmark: db "REr"  
563d f1			.pastdmark: pop af  
563e			endm  
# End of macro DMARK
563e						CALLMONITOR 
563e cd aa fd			call debug_vector  
5641				endm  
# End of macro CALLMONITOR
5641					endif 
5641 cd a7 09				call storage_read 
5644			 
5644 cd d5 0f			call ishlzero 
5647 20 05			jr nz, .rnfound 
5649			 
5649				; file does not exist so indicate with 255 extents in use 
5649			 
5649 3e ff			ld a, 255 
564b e1				pop hl ; clear dup hl 
564c 18 7b			jr .skiprneof 
564e			 
564e			 
564e			.rnfound: 
564e					; file found so rename 
564e			 
564e					FORTH_DSP_VALUEHL 
564e cd 6c 21			call macro_dsp_valuehl 
5651				endm 
# End of macro FORTH_DSP_VALUEHL
5651			 
5651 e5				push hl 
5652 3e 00			ld a, 0 
5654 cd 0f 13			call strlent 
5657 23				inc hl   ; cover zero term 
5658 06 00			ld b,0 
565a 4d				ld c,l 
565b e1				pop hl 
565c 11 af f9				ld de, store_page + 3 
565f ed b0				ldir 
5661			 
5661 11 ac f9				ld de, store_page 
5664					if DEBUG_FORTH_WORDS 
5664						DMARK "RER" 
5664 f5				push af  
5665 3a 79 56			ld a, (.dmark)  
5668 32 9d fd			ld (debug_mark),a  
566b 3a 7a 56			ld a, (.dmark+1)  
566e 32 9e fd			ld (debug_mark+1),a  
5671 3a 7b 56			ld a, (.dmark+2)  
5674 32 9f fd			ld (debug_mark+2),a  
5677 18 03			jr .pastdmark  
5679 ..			.dmark: db "RER"  
567c f1			.pastdmark: pop af  
567d			endm  
# End of macro DMARK
567d						CALLMONITOR 
567d cd aa fd			call debug_vector  
5680				endm  
# End of macro CALLMONITOR
5680					endif 
5680			 
5680 e1					pop hl    ; get orig file id and mangle it for find id 
5681 55					ld d, l 
5682 5c					ld e, h 
5683			 
5683 21 00 00				ld hl, 0 
5686					if DEBUG_FORTH_WORDS 
5686						DMARK "REf" 
5686 f5				push af  
5687 3a 9b 56			ld a, (.dmark)  
568a 32 9d fd			ld (debug_mark),a  
568d 3a 9c 56			ld a, (.dmark+1)  
5690 32 9e fd			ld (debug_mark+1),a  
5693 3a 9d 56			ld a, (.dmark+2)  
5696 32 9f fd			ld (debug_mark+2),a  
5699 18 03			jr .pastdmark  
569b ..			.dmark: db "REf"  
569e f1			.pastdmark: pop af  
569f			endm  
# End of macro DMARK
569f						CALLMONITOR 
569f cd aa fd			call debug_vector  
56a2				endm  
# End of macro CALLMONITOR
56a2					endif 
56a2 cd 83 07				call storage_findnextid 
56a5 11 ac f9				ld de, store_page 
56a8					if DEBUG_FORTH_WORDS 
56a8						DMARK "REw" 
56a8 f5				push af  
56a9 3a bd 56			ld a, (.dmark)  
56ac 32 9d fd			ld (debug_mark),a  
56af 3a be 56			ld a, (.dmark+1)  
56b2 32 9e fd			ld (debug_mark+1),a  
56b5 3a bf 56			ld a, (.dmark+2)  
56b8 32 9f fd			ld (debug_mark+2),a  
56bb 18 03			jr .pastdmark  
56bd ..			.dmark: db "REw"  
56c0 f1			.pastdmark: pop af  
56c1			endm  
# End of macro DMARK
56c1						CALLMONITOR 
56c1 cd aa fd			call debug_vector  
56c4				endm  
# End of macro CALLMONITOR
56c4					endif 
56c4 cd bc 04				call storage_write_block 
56c7			 
56c7 3e 00				ld a, 0 
56c9			.skiprneof: 
56c9					; drop file name 
56c9					FORTH_DSP_POP 
56c9 cd 24 22			call macro_forth_dsp_pop 
56cc				endm 
# End of macro FORTH_DSP_POP
56cc			 
56cc 6f					ld l, a 
56cd 26 00				ld h, 0 
56cf cd 70 1f				call forth_push_numhl 
56d2			 
56d2			 
56d2 f1					pop af 
56d3 32 9f f9				ld (store_readcont),a 
56d6 e1					pop hl 
56d7 22 9d f9				ld (store_openaddr), hl 
56da						 
56da				NEXTW 
56da cd a7 fd			call parse_vector 
56dd c3 53 23			jp macro_next 
56e0				endm 
# End of macro NEXTW
56e0			.RECORD: 
56e0			  
56e0				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
56e0 3a				db WORD_SYS_CORE+38             
56e1 8a 57			dw .BREAD            
56e3 07				db 6 + 1 
56e4 .. 00			db "RECORD",0              
56eb				endm 
# End of macro CWHEAD
56eb			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
56eb			; | | > [!NOTE] 
56eb			; | | > Compatible with PicoSPINet  
56eb			 
56eb					if DEBUG_FORTH_WORDS_KEY 
56eb						DMARK "REC" 
56eb f5				push af  
56ec 3a 00 57			ld a, (.dmark)  
56ef 32 9d fd			ld (debug_mark),a  
56f2 3a 01 57			ld a, (.dmark+1)  
56f5 32 9e fd			ld (debug_mark+1),a  
56f8 3a 02 57			ld a, (.dmark+2)  
56fb 32 9f fd			ld (debug_mark+2),a  
56fe 18 03			jr .pastdmark  
5700 ..			.dmark: db "REC"  
5703 f1			.pastdmark: pop af  
5704			endm  
# End of macro DMARK
5704						CALLMONITOR 
5704 cd aa fd			call debug_vector  
5707				endm  
# End of macro CALLMONITOR
5707					endif 
5707			 
5707					FORTH_DSP_VALUEHL 
5707 cd 6c 21			call macro_dsp_valuehl 
570a				endm 
# End of macro FORTH_DSP_VALUEHL
570a			 
570a e5					push hl    ; id 
570b			 
570b					FORTH_DSP_POP 
570b cd 24 22			call macro_forth_dsp_pop 
570e				endm 
# End of macro FORTH_DSP_POP
570e			 
570e					FORTH_DSP_VALUEHL 
570e cd 6c 21			call macro_dsp_valuehl 
5711				endm 
# End of macro FORTH_DSP_VALUEHL
5711			 
5711					FORTH_DSP_POP 
5711 cd 24 22			call macro_forth_dsp_pop 
5714				endm 
# End of macro FORTH_DSP_POP
5714			 
5714 d1					pop de     ; get file id 
5715			 
5715					; e = file id 
5715					; l = file extent 
5715			 
5715			 
5715					; construct request to access file extent 
5715			 
5715			;		ld a, e 
5715 63					ld h, e 
5716					 
5716					 
5716					 
5716			 
5716					; e has id 
5716			 
5716 11 ac f9			ld de, store_page 
5719					if DEBUG_FORTH_WORDS 
5719						DMARK "REr" 
5719 f5				push af  
571a 3a 2e 57			ld a, (.dmark)  
571d 32 9d fd			ld (debug_mark),a  
5720 3a 2f 57			ld a, (.dmark+1)  
5723 32 9e fd			ld (debug_mark+1),a  
5726 3a 30 57			ld a, (.dmark+2)  
5729 32 9f fd			ld (debug_mark+2),a  
572c 18 03			jr .pastdmark  
572e ..			.dmark: db "REr"  
5731 f1			.pastdmark: pop af  
5732			endm  
# End of macro DMARK
5732						CALLMONITOR 
5732 cd aa fd			call debug_vector  
5735				endm  
# End of macro CALLMONITOR
5735					endif 
5735 cd a7 09				call storage_read 
5738 cd d5 0f			call ishlzero 
573b 28 25			jr z, .recnotfound 
573d			 
573d			 
573d					if DEBUG_FORTH_WORDS 
573d						DMARK "REe" 
573d f5				push af  
573e 3a 52 57			ld a, (.dmark)  
5741 32 9d fd			ld (debug_mark),a  
5744 3a 53 57			ld a, (.dmark+1)  
5747 32 9e fd			ld (debug_mark+1),a  
574a 3a 54 57			ld a, (.dmark+2)  
574d 32 9f fd			ld (debug_mark+2),a  
5750 18 03			jr .pastdmark  
5752 ..			.dmark: db "REe"  
5755 f1			.pastdmark: pop af  
5756			endm  
# End of macro DMARK
5756						CALLMONITOR 
5756 cd aa fd			call debug_vector  
5759				endm  
# End of macro CALLMONITOR
5759					endif 
5759 cd da 1f			call forth_push_str 
575c			 
575c					NEXTW 
575c cd a7 fd			call parse_vector 
575f c3 53 23			jp macro_next 
5762				endm 
# End of macro NEXTW
5762			 
5762			.recnotfound: 
5762					if DEBUG_FORTH_WORDS 
5762						DMARK "REf" 
5762 f5				push af  
5763 3a 77 57			ld a, (.dmark)  
5766 32 9d fd			ld (debug_mark),a  
5769 3a 78 57			ld a, (.dmark+1)  
576c 32 9e fd			ld (debug_mark+1),a  
576f 3a 79 57			ld a, (.dmark+2)  
5772 32 9f fd			ld (debug_mark+2),a  
5775 18 03			jr .pastdmark  
5777 ..			.dmark: db "REf"  
577a f1			.pastdmark: pop af  
577b			endm  
# End of macro DMARK
577b						CALLMONITOR 
577b cd aa fd			call debug_vector  
577e				endm  
# End of macro CALLMONITOR
577e					endif 
577e 21 ff 00			ld hl, 255 
5781 cd 70 1f			call forth_push_numhl 
5784				NEXTW 
5784 cd a7 fd			call parse_vector 
5787 c3 53 23			jp macro_next 
578a				endm 
# End of macro NEXTW
578a			 
578a			 
578a			.BREAD: 
578a			  
578a				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
578a 3a				db WORD_SYS_CORE+38             
578b 10 58			dw .BWRITE            
578d 06				db 5 + 1 
578e .. 00			db "BREAD",0              
5794				endm 
# End of macro CWHEAD
5794			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5794			; | | > [!NOTE] 
5794			; | | > Compatible with PicoSPINet  
5794				 
5794					if DEBUG_FORTH_WORDS_KEY 
5794						DMARK "BRD" 
5794 f5				push af  
5795 3a a9 57			ld a, (.dmark)  
5798 32 9d fd			ld (debug_mark),a  
579b 3a aa 57			ld a, (.dmark+1)  
579e 32 9e fd			ld (debug_mark+1),a  
57a1 3a ab 57			ld a, (.dmark+2)  
57a4 32 9f fd			ld (debug_mark+2),a  
57a7 18 03			jr .pastdmark  
57a9 ..			.dmark: db "BRD"  
57ac f1			.pastdmark: pop af  
57ad			endm  
# End of macro DMARK
57ad						CALLMONITOR 
57ad cd aa fd			call debug_vector  
57b0				endm  
# End of macro CALLMONITOR
57b0					endif 
57b0			 
57b0				FORTH_DSP_VALUEHL 
57b0 cd 6c 21			call macro_dsp_valuehl 
57b3				endm 
# End of macro FORTH_DSP_VALUEHL
57b3			 
57b3				FORTH_DSP_POP 
57b3 cd 24 22			call macro_forth_dsp_pop 
57b6				endm 
# End of macro FORTH_DSP_POP
57b6			 
57b6				; calc block address 
57b6			 
57b6 eb				ex de, hl 
57b7 3e 40			ld a, STORE_BLOCK_PHY 
57b9 cd 2f 0f			call Mult16 
57bc			 
57bc			 
57bc 11 ac f9			ld de, store_page 
57bf			 
57bf					if DEBUG_FORTH_WORDS 
57bf						DMARK "BR1" 
57bf f5				push af  
57c0 3a d4 57			ld a, (.dmark)  
57c3 32 9d fd			ld (debug_mark),a  
57c6 3a d5 57			ld a, (.dmark+1)  
57c9 32 9e fd			ld (debug_mark+1),a  
57cc 3a d6 57			ld a, (.dmark+2)  
57cf 32 9f fd			ld (debug_mark+2),a  
57d2 18 03			jr .pastdmark  
57d4 ..			.dmark: db "BR1"  
57d7 f1			.pastdmark: pop af  
57d8			endm  
# End of macro DMARK
57d8						CALLMONITOR 
57d8 cd aa fd			call debug_vector  
57db				endm  
# End of macro CALLMONITOR
57db					endif 
57db			 
57db cd 57 04			call storage_read_block 
57de			 
57de cd d5 0f			call ishlzero 
57e1 20 05			jr nz, .brfound 
57e3			 
57e3 cd 70 1f			call forth_push_numhl 
57e6 18 22			jr .brdone 
57e8			 
57e8			 
57e8			.brfound: 
57e8 21 ae f9		        ld hl, store_page+2 
57eb			 
57eb					if DEBUG_FORTH_WORDS 
57eb						DMARK "BR2" 
57eb f5				push af  
57ec 3a 00 58			ld a, (.dmark)  
57ef 32 9d fd			ld (debug_mark),a  
57f2 3a 01 58			ld a, (.dmark+1)  
57f5 32 9e fd			ld (debug_mark+1),a  
57f8 3a 02 58			ld a, (.dmark+2)  
57fb 32 9f fd			ld (debug_mark+2),a  
57fe 18 03			jr .pastdmark  
5800 ..			.dmark: db "BR2"  
5803 f1			.pastdmark: pop af  
5804			endm  
# End of macro DMARK
5804						CALLMONITOR 
5804 cd aa fd			call debug_vector  
5807				endm  
# End of macro CALLMONITOR
5807					endif 
5807			 
5807 cd da 1f			call forth_push_str 
580a			 
580a			 
580a			.brdone: 
580a			 
580a					NEXTW 
580a cd a7 fd			call parse_vector 
580d c3 53 23			jp macro_next 
5810				endm 
# End of macro NEXTW
5810			.BWRITE: 
5810				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5810 3a				db WORD_SYS_CORE+38             
5811 a8 58			dw .BUPD            
5813 07				db 6 + 1 
5814 .. 00			db "BWRITE",0              
581b				endm 
# End of macro CWHEAD
581b			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
581b			; | | > [!NOTE] 
581b			; | | > Compatible with PicoSPINet  
581b			 
581b					if DEBUG_FORTH_WORDS_KEY 
581b						DMARK "BWR" 
581b f5				push af  
581c 3a 30 58			ld a, (.dmark)  
581f 32 9d fd			ld (debug_mark),a  
5822 3a 31 58			ld a, (.dmark+1)  
5825 32 9e fd			ld (debug_mark+1),a  
5828 3a 32 58			ld a, (.dmark+2)  
582b 32 9f fd			ld (debug_mark+2),a  
582e 18 03			jr .pastdmark  
5830 ..			.dmark: db "BWR"  
5833 f1			.pastdmark: pop af  
5834			endm  
# End of macro DMARK
5834						CALLMONITOR 
5834 cd aa fd			call debug_vector  
5837				endm  
# End of macro CALLMONITOR
5837					endif 
5837			 
5837				FORTH_DSP_VALUEHL 
5837 cd 6c 21			call macro_dsp_valuehl 
583a				endm 
# End of macro FORTH_DSP_VALUEHL
583a			 
583a				; calc block address 
583a			 
583a eb				ex de, hl 
583b 3e 40			ld a, STORE_BLOCK_PHY 
583d cd 2f 0f			call Mult16 
5840			 
5840 e5				push hl         ; address 
5841			 
5841				FORTH_DSP_POP 
5841 cd 24 22			call macro_forth_dsp_pop 
5844				endm 
# End of macro FORTH_DSP_POP
5844			 
5844				FORTH_DSP_VALUEHL 
5844 cd 6c 21			call macro_dsp_valuehl 
5847				endm 
# End of macro FORTH_DSP_VALUEHL
5847			 
5847				FORTH_DSP_POP 
5847 cd 24 22			call macro_forth_dsp_pop 
584a				endm 
# End of macro FORTH_DSP_POP
584a			 
584a cd 84 0c			call storage_clear_page 
584d			 
584d				; copy string to store page 
584d			 
584d e5				push hl     ; save string address 
584e			 
584e 3e 00			ld a, 0 
5850 cd 0f 13			call strlent 
5853			 
5853 23				inc hl 
5854			 
5854 4d				ld c, l 
5855 06 00			ld b, 0 
5857			 
5857 e1				pop hl 
5858 11 ae f9			ld de, store_page + 2 
585b					if DEBUG_FORTH_WORDS 
585b						DMARK "BW1" 
585b f5				push af  
585c 3a 70 58			ld a, (.dmark)  
585f 32 9d fd			ld (debug_mark),a  
5862 3a 71 58			ld a, (.dmark+1)  
5865 32 9e fd			ld (debug_mark+1),a  
5868 3a 72 58			ld a, (.dmark+2)  
586b 32 9f fd			ld (debug_mark+2),a  
586e 18 03			jr .pastdmark  
5870 ..			.dmark: db "BW1"  
5873 f1			.pastdmark: pop af  
5874			endm  
# End of macro DMARK
5874						CALLMONITOR 
5874 cd aa fd			call debug_vector  
5877				endm  
# End of macro CALLMONITOR
5877					endif 
5877 ed b0			ldir 
5879			 
5879			 
5879				; poke the start of the block with flags to prevent high level file ops hitting the block 
5879			 
5879 21 ff ff			ld hl, $ffff 
587c			 
587c 22 ac f9			ld (store_page), hl	 
587f				 
587f e1				pop hl    ; get address 
5880 11 ac f9			ld de, store_page 
5883			 
5883					if DEBUG_FORTH_WORDS 
5883						DMARK "BW2" 
5883 f5				push af  
5884 3a 98 58			ld a, (.dmark)  
5887 32 9d fd			ld (debug_mark),a  
588a 3a 99 58			ld a, (.dmark+1)  
588d 32 9e fd			ld (debug_mark+1),a  
5890 3a 9a 58			ld a, (.dmark+2)  
5893 32 9f fd			ld (debug_mark+2),a  
5896 18 03			jr .pastdmark  
5898 ..			.dmark: db "BW2"  
589b f1			.pastdmark: pop af  
589c			endm  
# End of macro DMARK
589c						CALLMONITOR 
589c cd aa fd			call debug_vector  
589f				endm  
# End of macro CALLMONITOR
589f					endif 
589f			 
589f cd bc 04			call storage_write_block 
58a2			 
58a2					NEXTW 
58a2 cd a7 fd			call parse_vector 
58a5 c3 53 23			jp macro_next 
58a8				endm 
# End of macro NEXTW
58a8			 
58a8			.BUPD: 
58a8				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
58a8 3a				db WORD_SYS_CORE+38             
58a9 01 59			dw .BYID            
58ab 05				db 4 + 1 
58ac .. 00			db "BUPD",0              
58b1				endm 
# End of macro CWHEAD
58b1			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
58b1			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
58b1			; | | or completely different file system structure. 
58b1			; | | > [!NOTE] 
58b1			; | | > Compatible with PicoSPINet  
58b1			 
58b1					if DEBUG_FORTH_WORDS_KEY 
58b1						DMARK "BUD" 
58b1 f5				push af  
58b2 3a c6 58			ld a, (.dmark)  
58b5 32 9d fd			ld (debug_mark),a  
58b8 3a c7 58			ld a, (.dmark+1)  
58bb 32 9e fd			ld (debug_mark+1),a  
58be 3a c8 58			ld a, (.dmark+2)  
58c1 32 9f fd			ld (debug_mark+2),a  
58c4 18 03			jr .pastdmark  
58c6 ..			.dmark: db "BUD"  
58c9 f1			.pastdmark: pop af  
58ca			endm  
# End of macro DMARK
58ca						CALLMONITOR 
58ca cd aa fd			call debug_vector  
58cd				endm  
# End of macro CALLMONITOR
58cd					endif 
58cd			 
58cd				FORTH_DSP_VALUEHL 
58cd cd 6c 21			call macro_dsp_valuehl 
58d0				endm 
# End of macro FORTH_DSP_VALUEHL
58d0			 
58d0				; calc block address 
58d0			 
58d0 eb				ex de, hl 
58d1 3e 40			ld a, STORE_BLOCK_PHY 
58d3 cd 2f 0f			call Mult16 
58d6			 
58d6				FORTH_DSP_POP 
58d6 cd 24 22			call macro_forth_dsp_pop 
58d9				endm 
# End of macro FORTH_DSP_POP
58d9			 
58d9			 
58d9 11 ac f9			ld de, store_page 
58dc			 
58dc					if DEBUG_FORTH_WORDS 
58dc						DMARK "BUe" 
58dc f5				push af  
58dd 3a f1 58			ld a, (.dmark)  
58e0 32 9d fd			ld (debug_mark),a  
58e3 3a f2 58			ld a, (.dmark+1)  
58e6 32 9e fd			ld (debug_mark+1),a  
58e9 3a f3 58			ld a, (.dmark+2)  
58ec 32 9f fd			ld (debug_mark+2),a  
58ef 18 03			jr .pastdmark  
58f1 ..			.dmark: db "BUe"  
58f4 f1			.pastdmark: pop af  
58f5			endm  
# End of macro DMARK
58f5						CALLMONITOR 
58f5 cd aa fd			call debug_vector  
58f8				endm  
# End of macro CALLMONITOR
58f8					endif 
58f8			 
58f8 cd bc 04			call storage_write_block 
58fb			 
58fb					NEXTW 
58fb cd a7 fd			call parse_vector 
58fe c3 53 23			jp macro_next 
5901				endm 
# End of macro NEXTW
5901			 
5901			.BYID: 
5901			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5901			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5901			; 
5901			;		 
5901			;		if DEBUG_FORTH_WORDS_KEY 
5901			;			DMARK "BYID" 
5901			;			CALLMONITOR 
5901			;		endif 
5901			; 
5901			;		; get direct address 
5901			; 
5901			;		FORTH_DSP_VALUEHL 
5901			; 
5901			;		FORTH_DSP_POP 
5901			; 
5901			;	; calc block address 
5901			; 
5901			;	ex de, hl 
5901			;	ld a, STORE_BLOCK_PHY 
5901			;	call Mult16 
5901			;	;	do BREAD with number as param 
5901			;	; push the file name	 
5901			;	ld de, store_page 
5901			;	call storage_read_block 
5901			 ;       ld hl, store_page+2 
5901			; 
5901			; 
5901			;		NEXTW 
5901			;.BYNAME: 
5901				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5901 3a				db WORD_SYS_CORE+38             
5902 1d 59			dw .DIR            
5904 06				db 5 + 1 
5905 .. 00			db "GETID",0              
590b				endm 
# End of macro CWHEAD
590b			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
590b			; | | > [!NOTE] 
590b			; | | > Compatible with PicoSPINet  
590b			 
590b					; get pointer to file name to seek 
590b			 
590b					FORTH_DSP_VALUEHL 
590b cd 6c 21			call macro_dsp_valuehl 
590e				endm 
# End of macro FORTH_DSP_VALUEHL
590e			 
590e			 
590e cd 7e 03				call storage_getid  
5911			 
5911					FORTH_DSP_POP 
5911 cd 24 22			call macro_forth_dsp_pop 
5914				endm 
# End of macro FORTH_DSP_POP
5914			 
5914 cd 70 1f				call forth_push_numhl 
5917			 
5917					NEXTW 
5917 cd a7 fd			call parse_vector 
591a c3 53 23			jp macro_next 
591d				endm 
# End of macro NEXTW
591d			; 
591d			.DIR: 
591d				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
591d 3a				db WORD_SYS_CORE+38             
591e 24 5a			dw .SAVE            
5920 04				db 3 + 1 
5921 .. 00			db "DIR",0              
5925				endm 
# End of macro CWHEAD
5925			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5925			; | | > [!NOTE] 
5925			; | | > Compatible with PicoSPINet  
5925			 
5925					if DEBUG_FORTH_WORDS_KEY 
5925						DMARK "DIR" 
5925 f5				push af  
5926 3a 3a 59			ld a, (.dmark)  
5929 32 9d fd			ld (debug_mark),a  
592c 3a 3b 59			ld a, (.dmark+1)  
592f 32 9e fd			ld (debug_mark+1),a  
5932 3a 3c 59			ld a, (.dmark+2)  
5935 32 9f fd			ld (debug_mark+2),a  
5938 18 03			jr .pastdmark  
593a ..			.dmark: db "DIR"  
593d f1			.pastdmark: pop af  
593e			endm  
# End of macro DMARK
593e						CALLMONITOR 
593e cd aa fd			call debug_vector  
5941				endm  
# End of macro CALLMONITOR
5941					endif 
5941 cd 05 05			call storage_get_block_0 
5944			 
5944 21 ac f9			ld hl, store_page     ; get current id count 
5947 46				ld b, (hl) 
5948 0e 00			ld c, 0    ; count of files   
594a					if DEBUG_FORTH_WORDS 
594a						DMARK "DI1" 
594a f5				push af  
594b 3a 5f 59			ld a, (.dmark)  
594e 32 9d fd			ld (debug_mark),a  
5951 3a 60 59			ld a, (.dmark+1)  
5954 32 9e fd			ld (debug_mark+1),a  
5957 3a 61 59			ld a, (.dmark+2)  
595a 32 9f fd			ld (debug_mark+2),a  
595d 18 03			jr .pastdmark  
595f ..			.dmark: db "DI1"  
5962 f1			.pastdmark: pop af  
5963			endm  
# End of macro DMARK
5963						CALLMONITOR 
5963 cd aa fd			call debug_vector  
5966				endm  
# End of macro CALLMONITOR
5966					endif 
5966			 
5966				; check for empty drive 
5966			 
5966 3e 00			ld a, 0 
5968 b8				cp b 
5969 ca d7 59			jp z, .dirdone 
596c			 
596c				; for each of the current ids do a search for them and if found push to stack 
596c			 
596c c5			.diritem:	push bc 
596d 21 40 00				ld hl, STORE_BLOCK_PHY 
5970 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5972 58					ld e,b 
5973			 
5973			;		if DEBUG_FORTH_WORDS 
5973			;			DMARK "DI2" 
5973			;			CALLMONITOR 
5973			;		endif 
5973			 
5973 cd 83 07				call storage_findnextid 
5976			 
5976			;		if DEBUG_FORTH_WORDS 
5976			;			DMARK "DI3" 
5976			;			CALLMONITOR 
5976			;		endif 
5976			 
5976					; if found hl will be non zero 
5976			 
5976 cd d5 0f				call ishlzero 
5979			;		ld a, l 
5979			;		add h 
5979			; 
5979			;		cp 0 
5979 28 59				jr z, .dirnotfound 
597b			 
597b					; increase count 
597b			 
597b c1					pop bc	 
597c 0c					inc c 
597d c5					push bc 
597e					 
597e			 
597e					; get file header and push the file name 
597e			 
597e 11 ac f9				ld de, store_page 
5981 cd 57 04				call storage_read_block 
5984			 
5984					; push file id to stack 
5984				 
5984 3a ac f9				ld a, (store_page) 
5987 26 00				ld h, 0 
5989 6f					ld l, a 
598a cd 70 1f				call forth_push_numhl 
598d			 
598d					; push extent count to stack  
598d				 
598d 3a ae f9				ld a, (store_page+2) 
5990 26 00				ld h, 0 
5992 6f					ld l, a 
5993 cd 70 1f				call forth_push_numhl 
5996			 
5996					; push file name 
5996			 
5996 21 af f9				ld hl, store_page+3 
5999					if DEBUG_FORTH_WORDS 
5999						DMARK "DI5" 
5999 f5				push af  
599a 3a ae 59			ld a, (.dmark)  
599d 32 9d fd			ld (debug_mark),a  
59a0 3a af 59			ld a, (.dmark+1)  
59a3 32 9e fd			ld (debug_mark+1),a  
59a6 3a b0 59			ld a, (.dmark+2)  
59a9 32 9f fd			ld (debug_mark+2),a  
59ac 18 03			jr .pastdmark  
59ae ..			.dmark: db "DI5"  
59b1 f1			.pastdmark: pop af  
59b2			endm  
# End of macro DMARK
59b2						CALLMONITOR 
59b2 cd aa fd			call debug_vector  
59b5				endm  
# End of macro CALLMONITOR
59b5					endif 
59b5 cd da 1f				call forth_push_str 
59b8					if DEBUG_FORTH_WORDS 
59b8						DMARK "DI6" 
59b8 f5				push af  
59b9 3a cd 59			ld a, (.dmark)  
59bc 32 9d fd			ld (debug_mark),a  
59bf 3a ce 59			ld a, (.dmark+1)  
59c2 32 9e fd			ld (debug_mark+1),a  
59c5 3a cf 59			ld a, (.dmark+2)  
59c8 32 9f fd			ld (debug_mark+2),a  
59cb 18 03			jr .pastdmark  
59cd ..			.dmark: db "DI6"  
59d0 f1			.pastdmark: pop af  
59d1			endm  
# End of macro DMARK
59d1						CALLMONITOR 
59d1 cd aa fd			call debug_vector  
59d4				endm  
# End of macro CALLMONITOR
59d4					endif 
59d4			.dirnotfound: 
59d4 c1					pop bc     
59d5 10 95				djnz .diritem 
59d7				 
59d7			.dirdone:	 
59d7					if DEBUG_FORTH_WORDS 
59d7						DMARK "DI7" 
59d7 f5				push af  
59d8 3a ec 59			ld a, (.dmark)  
59db 32 9d fd			ld (debug_mark),a  
59de 3a ed 59			ld a, (.dmark+1)  
59e1 32 9e fd			ld (debug_mark+1),a  
59e4 3a ee 59			ld a, (.dmark+2)  
59e7 32 9f fd			ld (debug_mark+2),a  
59ea 18 03			jr .pastdmark  
59ec ..			.dmark: db "DI7"  
59ef f1			.pastdmark: pop af  
59f0			endm  
# End of macro DMARK
59f0						CALLMONITOR 
59f0 cd aa fd			call debug_vector  
59f3				endm  
# End of macro CALLMONITOR
59f3					endif 
59f3			 
59f3					; push a count of the dir items found 
59f3			 
59f3 26 00				ld h, 0 
59f5 69					ld l, c 
59f6 cd 70 1f				call forth_push_numhl 
59f9			 
59f9					; push the bank label 
59f9			 
59f9 cd 05 05				call storage_get_block_0 
59fc			 
59fc				 
59fc 21 af f9		 		ld hl, store_page+3 
59ff			 
59ff					if DEBUG_FORTH_WORDS 
59ff						DMARK "DI8" 
59ff f5				push af  
5a00 3a 14 5a			ld a, (.dmark)  
5a03 32 9d fd			ld (debug_mark),a  
5a06 3a 15 5a			ld a, (.dmark+1)  
5a09 32 9e fd			ld (debug_mark+1),a  
5a0c 3a 16 5a			ld a, (.dmark+2)  
5a0f 32 9f fd			ld (debug_mark+2),a  
5a12 18 03			jr .pastdmark  
5a14 ..			.dmark: db "DI8"  
5a17 f1			.pastdmark: pop af  
5a18			endm  
# End of macro DMARK
5a18						CALLMONITOR 
5a18 cd aa fd			call debug_vector  
5a1b				endm  
# End of macro CALLMONITOR
5a1b					endif 
5a1b cd da 1f				call forth_push_str 
5a1e			 
5a1e			 
5a1e				 
5a1e					NEXTW 
5a1e cd a7 fd			call parse_vector 
5a21 c3 53 23			jp macro_next 
5a24				endm 
# End of macro NEXTW
5a24			.SAVE: 
5a24			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5a24			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5a24			;		NEXTW 
5a24			;.LOAD: 
5a24			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5a24			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5a24			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5a24			;; > > The LOAD command can not be used in any user words or compound lines. 
5a24			; 
5a24			;		; store_openext use it. If zero it is EOF 
5a24			; 
5a24			;		; read block from current stream id 
5a24			;		; if the block does not contain zero term keep reading blocks until zero found 
5a24			;		; push the block to stack 
5a24			;		; save the block id to stream 
5a24			; 
5a24			; 
5a24			;		FORTH_DSP_VALUEHL 
5a24			; 
5a24			;;		push hl 
5a24			; 
5a24			;	if DEBUG_STORESE 
5a24			;		DMARK "LOA" 
5a24			;		CALLMONITOR 
5a24			;	endif 
5a24			;		FORTH_DSP_POP 
5a24			; 
5a24			;;		pop hl 
5a24			; 
5a24			;		ld h, l 
5a24			;		ld l, 0 
5a24			; 
5a24			;		push hl     ; stack holds current file id and extent to work with 
5a24			; 
5a24			; 
5a24			;		ld de, store_page      ; get block zero of file 
5a24			;	if DEBUG_STORESE 
5a24			;		DMARK "LO0" 
5a24			;		CALLMONITOR 
5a24			;	endif 
5a24			;		call storage_read 
5a24			; 
5a24			;		ld a, (store_page+2)    ; max extents for this file 
5a24			;		ld  (store_openmaxext),a   ; get our limit 
5a24			; 
5a24			;	if DEBUG_STORESE 
5a24			;		DMARK "LOE" 
5a24			;		CALLMONITOR 
5a24			;	endif 
5a24			; 
5a24			;; TODO dont know why max extents are not present 
5a24			;;		cp 0 
5a24			;;		jp z, .loadeof     ; dont read past eof 
5a24			; 
5a24			;;		ld a, 1   ; start from the head of the file 
5a24			; 
5a24			;.loadline:	pop hl 
5a24			;		inc hl 
5a24			;		ld  a, (store_openmaxext)   ; get our limit 
5a24			;	if DEBUG_STORESE 
5a24			;		DMARK "LOx" 
5a24			;		CALLMONITOR 
5a24			;	endif 
5a24			;		inc a 
5a24			;		cp l 
5a24			;		jp z, .loadeof 
5a24			;		push hl    ; save current extent 
5a24			; 
5a24			;		ld de, store_page 
5a24			; 
5a24			;	if DEBUG_STORESE 
5a24			;		DMARK "LO1" 
5a24			;		CALLMONITOR 
5a24			;	endif 
5a24			;		call storage_read 
5a24			; 
5a24			;	if DEBUG_STORESE 
5a24			;		DMARK "LO2" 
5a24			;		CALLMONITOR 
5a24			;	endif 
5a24			;	call ishlzero 
5a24			;	ld a, l 
5a24			;	add h 
5a24			;	cp 0 
5a24			;	jr z, .loadeof 
5a24			; 
5a24			;	; not eof so hl should point to data to exec 
5a24			; 
5a24			;	; will need to add the FORTH_END_BUFFER flag 
5a24			 ; 
5a24			;	ld hl, store_page+2 
5a24			;	ld bc, 255 
5a24			;	ld a, 0 
5a24			;	cpir 
5a24			;	if DEBUG_STORESE 
5a24			;		DMARK "LOt" 
5a24			;		CALLMONITOR 
5a24			;	endif 
5a24			;	dec hl 
5a24			;	ld a, ' ' 
5a24			;	ld (hl), a 
5a24			;	inc hl 
5a24			;	ld (hl), a 
5a24			;	inc hl 
5a24			;	ld (hl), a 
5a24			;	inc hl 
5a24			;	ld a, FORTH_END_BUFFER 
5a24			;	ld (hl), a 
5a24			; 
5a24			;	; TODO handle more than a single block read 
5a24			; 
5a24			; 
5a24			;	ld hl, store_page+2 
5a24			; 
5a24			;	ld (os_tok_ptr), hl 
5a24			; 
5a24			;	if DEBUG_STORESE 
5a24			;		DMARK "LO3" 
5a24			;		CALLMONITOR 
5a24			;	endif 
5a24			; 
5a24			;	call forthparse 
5a24			;	call forthexec 
5a24			;	call forthexec_cleanup 
5a24			; 
5a24			;	; go to next extent 
5a24			; 
5a24			;	; get next block  or mark as eof 
5a24			;	jp .loadline 
5a24			; 
5a24			; 
5a24			; 
5a24			;	       NEXTW 
5a24			;.loadeof:	ld a, 0 
5a24			;		ld (store_openext), a 
5a24			; 
5a24			;	if DEBUG_STORESE 
5a24			;		DMARK "LOF" 
5a24			;		CALLMONITOR 
5a24			;	endif 
5a24			;		ret 
5a24			;		;NEXTW 
5a24			;.BSAVE:   
5a24			; 
5a24			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5a24			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5a24			;		NEXTW 
5a24			;.BLOAD: 
5a24			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5a24			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5a24			;		NEXTW 
5a24			;;;; counter gap 
5a24			 
5a24			 
5a24			.SEO: 
5a24				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5a24 64				db WORD_SYS_CORE+80             
5a25 46 5a			dw .SEI            
5a27 04				db 3 + 1 
5a28 .. 00			db "SEO",0              
5a2c				endm 
# End of macro CWHEAD
5a2c			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5a2c			 
5a2c					; get port 
5a2c			 
5a2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a2c cd 6c 21			call macro_dsp_valuehl 
5a2f				endm 
# End of macro FORTH_DSP_VALUEHL
5a2f			 
5a2f e5					push hl    ; u2 - byte 
5a30			 
5a30					; destroy value TOS 
5a30			 
5a30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a30 cd 24 22			call macro_forth_dsp_pop 
5a33				endm 
# End of macro FORTH_DSP_POP
5a33			 
5a33					; get byte to send 
5a33			 
5a33					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a33 cd 6c 21			call macro_dsp_valuehl 
5a36				endm 
# End of macro FORTH_DSP_VALUEHL
5a36			 
5a36 e5					push hl    ; u1 - addr 
5a37			 
5a37					; destroy value TOS 
5a37			 
5a37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a37 cd 24 22			call macro_forth_dsp_pop 
5a3a				endm 
# End of macro FORTH_DSP_POP
5a3a			 
5a3a					; one value on hl get other one back 
5a3a			 
5a3a d1					pop de   ; u1 - byte 
5a3b			 
5a3b e1					pop hl   ; u2 - addr 
5a3c			 
5a3c					; TODO Send SPI byte 
5a3c			 
5a3c			 
5a3c 7b					ld a, e 
5a3d cd 65 02				call se_writebyte 
5a40			 
5a40					 
5a40			 
5a40					NEXTW 
5a40 cd a7 fd			call parse_vector 
5a43 c3 53 23			jp macro_next 
5a46				endm 
# End of macro NEXTW
5a46			 
5a46			.SEI: 
5a46				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5a46 65				db WORD_SYS_CORE+81             
5a47 63 5a			dw .SFREE            
5a49 04				db 3 + 1 
5a4a .. 00			db "SEI",0              
5a4e				endm 
# End of macro CWHEAD
5a4e			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5a4e			 
5a4e					; get port 
5a4e			 
5a4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a4e cd 6c 21			call macro_dsp_valuehl 
5a51				endm 
# End of macro FORTH_DSP_VALUEHL
5a51			 
5a51			;		push hl 
5a51			 
5a51					; destroy value TOS 
5a51			 
5a51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a51 cd 24 22			call macro_forth_dsp_pop 
5a54				endm 
# End of macro FORTH_DSP_POP
5a54			 
5a54					; one value on hl get other one back 
5a54			 
5a54			;		pop hl 
5a54			 
5a54			 
5a54					; TODO Get SPI byte 
5a54			 
5a54 cd ff 02				call se_readbyte 
5a57			 
5a57 26 00				ld h, 0 
5a59 6f					ld l, a 
5a5a cd 70 1f				call forth_push_numhl 
5a5d			 
5a5d					NEXTW 
5a5d cd a7 fd			call parse_vector 
5a60 c3 53 23			jp macro_next 
5a63				endm 
# End of macro NEXTW
5a63			 
5a63			.SFREE: 
5a63				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5a63 67				db WORD_SYS_CORE+83             
5a64 95 5a			dw .SIZE            
5a66 06				db 5 + 1 
5a67 .. 00			db "FFREE",0              
5a6d				endm 
# End of macro CWHEAD
5a6d			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5a6d			; | | > [!NOTE] 
5a6d			; | | > Compatible with PicoSPINet  
5a6d					if DEBUG_FORTH_WORDS_KEY 
5a6d						DMARK "FFR" 
5a6d f5				push af  
5a6e 3a 82 5a			ld a, (.dmark)  
5a71 32 9d fd			ld (debug_mark),a  
5a74 3a 83 5a			ld a, (.dmark+1)  
5a77 32 9e fd			ld (debug_mark+1),a  
5a7a 3a 84 5a			ld a, (.dmark+2)  
5a7d 32 9f fd			ld (debug_mark+2),a  
5a80 18 03			jr .pastdmark  
5a82 ..			.dmark: db "FFR"  
5a85 f1			.pastdmark: pop af  
5a86			endm  
# End of macro DMARK
5a86						CALLMONITOR 
5a86 cd aa fd			call debug_vector  
5a89				endm  
# End of macro CALLMONITOR
5a89					endif 
5a89			 
5a89 cd 1d 08				call storage_freeblocks 
5a8c			 
5a8c cd 70 1f				call forth_push_numhl 
5a8f			 
5a8f				       NEXTW 
5a8f cd a7 fd			call parse_vector 
5a92 c3 53 23			jp macro_next 
5a95				endm 
# End of macro NEXTW
5a95			.SIZE: 
5a95				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5a95 67				db WORD_SYS_CORE+83             
5a96 cc 5a			dw .CREATE            
5a98 05				db 4 + 1 
5a99 .. 00			db "SIZE",0              
5a9e				endm 
# End of macro CWHEAD
5a9e			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5a9e			; | | > [!NOTE] 
5a9e			; | | > Compatible with PicoSPINet  
5a9e					if DEBUG_FORTH_WORDS_KEY 
5a9e						DMARK "SIZ" 
5a9e f5				push af  
5a9f 3a b3 5a			ld a, (.dmark)  
5aa2 32 9d fd			ld (debug_mark),a  
5aa5 3a b4 5a			ld a, (.dmark+1)  
5aa8 32 9e fd			ld (debug_mark+1),a  
5aab 3a b5 5a			ld a, (.dmark+2)  
5aae 32 9f fd			ld (debug_mark+2),a  
5ab1 18 03			jr .pastdmark  
5ab3 ..			.dmark: db "SIZ"  
5ab6 f1			.pastdmark: pop af  
5ab7			endm  
# End of macro DMARK
5ab7						CALLMONITOR 
5ab7 cd aa fd			call debug_vector  
5aba				endm  
# End of macro CALLMONITOR
5aba					endif 
5aba			 
5aba					FORTH_DSP_VALUEHL 
5aba cd 6c 21			call macro_dsp_valuehl 
5abd				endm 
# End of macro FORTH_DSP_VALUEHL
5abd			;		push hl 
5abd					FORTH_DSP_POP 
5abd cd 24 22			call macro_forth_dsp_pop 
5ac0				endm 
# End of macro FORTH_DSP_POP
5ac0			;		pop hl 
5ac0 cd 86 04				call storage_file_size 
5ac3			 
5ac3 cd 70 1f				call forth_push_numhl 
5ac6			  
5ac6			 
5ac6				       NEXTW 
5ac6 cd a7 fd			call parse_vector 
5ac9 c3 53 23			jp macro_next 
5acc				endm 
# End of macro NEXTW
5acc			 
5acc			.CREATE: 
5acc				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5acc 68				db WORD_SYS_CORE+84             
5acd 3d 5b			dw .APPEND            
5acf 07				db 6 + 1 
5ad0 .. 00			db "CREATE",0              
5ad7				endm 
# End of macro CWHEAD
5ad7			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5ad7			; | | e.g.  
5ad7			; | | TestProgram CREATE 
5ad7			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5ad7			; | |  
5ad7			; | | Max file IDs are 255. 
5ad7			; | |  
5ad7			; | | > [!NOTE] 
5ad7			; | | > Compatible with PicoSPINet  
5ad7					 
5ad7					if DEBUG_FORTH_WORDS_KEY 
5ad7						DMARK "CRT" 
5ad7 f5				push af  
5ad8 3a ec 5a			ld a, (.dmark)  
5adb 32 9d fd			ld (debug_mark),a  
5ade 3a ed 5a			ld a, (.dmark+1)  
5ae1 32 9e fd			ld (debug_mark+1),a  
5ae4 3a ee 5a			ld a, (.dmark+2)  
5ae7 32 9f fd			ld (debug_mark+2),a  
5aea 18 03			jr .pastdmark  
5aec ..			.dmark: db "CRT"  
5aef f1			.pastdmark: pop af  
5af0			endm  
# End of macro DMARK
5af0						CALLMONITOR 
5af0 cd aa fd			call debug_vector  
5af3				endm  
# End of macro CALLMONITOR
5af3					endif 
5af3			;		call storage_get_block_0 
5af3			 
5af3					; TODO pop hl 
5af3			 
5af3					;v5 FORTH_DSP_VALUE 
5af3					FORTH_DSP_VALUE 
5af3 cd 55 21			call macro_forth_dsp_value 
5af6				endm 
# End of macro FORTH_DSP_VALUE
5af6			 
5af6				if DEBUG_STORESE 
5af6					DMARK "CR1" 
5af6 f5				push af  
5af7 3a 0b 5b			ld a, (.dmark)  
5afa 32 9d fd			ld (debug_mark),a  
5afd 3a 0c 5b			ld a, (.dmark+1)  
5b00 32 9e fd			ld (debug_mark+1),a  
5b03 3a 0d 5b			ld a, (.dmark+2)  
5b06 32 9f fd			ld (debug_mark+2),a  
5b09 18 03			jr .pastdmark  
5b0b ..			.dmark: db "CR1"  
5b0e f1			.pastdmark: pop af  
5b0f			endm  
# End of macro DMARK
5b0f					CALLMONITOR 
5b0f cd aa fd			call debug_vector  
5b12				endm  
# End of macro CALLMONITOR
5b12				endif 
5b12			;		push hl 
5b12			;		FORTH_DSP_POP 
5b12			;		pop hl 
5b12			 
5b12			;		inc hl   ; move past the type marker 
5b12			 
5b12 cd 51 08				call storage_create 
5b15			 
5b15				if DEBUG_STORESE 
5b15					DMARK "CT1" 
5b15 f5				push af  
5b16 3a 2a 5b			ld a, (.dmark)  
5b19 32 9d fd			ld (debug_mark),a  
5b1c 3a 2b 5b			ld a, (.dmark+1)  
5b1f 32 9e fd			ld (debug_mark+1),a  
5b22 3a 2c 5b			ld a, (.dmark+2)  
5b25 32 9f fd			ld (debug_mark+2),a  
5b28 18 03			jr .pastdmark  
5b2a ..			.dmark: db "CT1"  
5b2d f1			.pastdmark: pop af  
5b2e			endm  
# End of macro DMARK
5b2e					CALLMONITOR 
5b2e cd aa fd			call debug_vector  
5b31				endm  
# End of macro CALLMONITOR
5b31				endif 
5b31			;		push hl 
5b31					FORTH_DSP_POP 
5b31 cd 24 22			call macro_forth_dsp_pop 
5b34				endm 
# End of macro FORTH_DSP_POP
5b34			;		pop hl 
5b34					; push file id to stack 
5b34 cd 70 1f				call forth_push_numhl 
5b37			 
5b37			 
5b37			 
5b37				       NEXTW 
5b37 cd a7 fd			call parse_vector 
5b3a c3 53 23			jp macro_next 
5b3d				endm 
# End of macro NEXTW
5b3d			 
5b3d			.APPEND: 
5b3d				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5b3d 69				db WORD_SYS_CORE+85             
5b3e d1 5b			dw .SDEL            
5b40 07				db 6 + 1 
5b41 .. 00			db "APPEND",0              
5b48				endm 
# End of macro CWHEAD
5b48			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5b48			; | | e.g. 
5b48			; | | Test CREATE      -> $01 
5b48			; | | "A string to add to file" $01 APPEND 
5b48			; | |  
5b48			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5b48			; | | > [!NOTE] 
5b48			; | | > Compatible with PicoSPINet  
5b48					if DEBUG_FORTH_WORDS_KEY 
5b48						DMARK "APP" 
5b48 f5				push af  
5b49 3a 5d 5b			ld a, (.dmark)  
5b4c 32 9d fd			ld (debug_mark),a  
5b4f 3a 5e 5b			ld a, (.dmark+1)  
5b52 32 9e fd			ld (debug_mark+1),a  
5b55 3a 5f 5b			ld a, (.dmark+2)  
5b58 32 9f fd			ld (debug_mark+2),a  
5b5b 18 03			jr .pastdmark  
5b5d ..			.dmark: db "APP"  
5b60 f1			.pastdmark: pop af  
5b61			endm  
# End of macro DMARK
5b61						CALLMONITOR 
5b61 cd aa fd			call debug_vector  
5b64				endm  
# End of macro CALLMONITOR
5b64					endif 
5b64			 
5b64					FORTH_DSP_VALUEHL 
5b64 cd 6c 21			call macro_dsp_valuehl 
5b67				endm 
# End of macro FORTH_DSP_VALUEHL
5b67 e5					push hl 	; save file id 
5b68			 
5b68				if DEBUG_STORESE 
5b68					DMARK "AP1" 
5b68 f5				push af  
5b69 3a 7d 5b			ld a, (.dmark)  
5b6c 32 9d fd			ld (debug_mark),a  
5b6f 3a 7e 5b			ld a, (.dmark+1)  
5b72 32 9e fd			ld (debug_mark+1),a  
5b75 3a 7f 5b			ld a, (.dmark+2)  
5b78 32 9f fd			ld (debug_mark+2),a  
5b7b 18 03			jr .pastdmark  
5b7d ..			.dmark: db "AP1"  
5b80 f1			.pastdmark: pop af  
5b81			endm  
# End of macro DMARK
5b81					CALLMONITOR 
5b81 cd aa fd			call debug_vector  
5b84				endm  
# End of macro CALLMONITOR
5b84				endif 
5b84					FORTH_DSP_POP 
5b84 cd 24 22			call macro_forth_dsp_pop 
5b87				endm 
# End of macro FORTH_DSP_POP
5b87			 
5b87					FORTH_DSP_VALUEHL 
5b87 cd 6c 21			call macro_dsp_valuehl 
5b8a				endm 
# End of macro FORTH_DSP_VALUEHL
5b8a					;v5 FORTH_DSP_VALUE 
5b8a e5					push hl 	; save ptr to string to save 
5b8b			 
5b8b				if DEBUG_STORESE 
5b8b					DMARK "AP1" 
5b8b f5				push af  
5b8c 3a a0 5b			ld a, (.dmark)  
5b8f 32 9d fd			ld (debug_mark),a  
5b92 3a a1 5b			ld a, (.dmark+1)  
5b95 32 9e fd			ld (debug_mark+1),a  
5b98 3a a2 5b			ld a, (.dmark+2)  
5b9b 32 9f fd			ld (debug_mark+2),a  
5b9e 18 03			jr .pastdmark  
5ba0 ..			.dmark: db "AP1"  
5ba3 f1			.pastdmark: pop af  
5ba4			endm  
# End of macro DMARK
5ba4					CALLMONITOR 
5ba4 cd aa fd			call debug_vector  
5ba7				endm  
# End of macro CALLMONITOR
5ba7				endif 
5ba7					FORTH_DSP_POP 
5ba7 cd 24 22			call macro_forth_dsp_pop 
5baa				endm 
# End of macro FORTH_DSP_POP
5baa			 
5baa d1					pop de 
5bab e1					pop hl 
5bac				if DEBUG_STORESE 
5bac					DMARK "AP2" 
5bac f5				push af  
5bad 3a c1 5b			ld a, (.dmark)  
5bb0 32 9d fd			ld (debug_mark),a  
5bb3 3a c2 5b			ld a, (.dmark+1)  
5bb6 32 9e fd			ld (debug_mark+1),a  
5bb9 3a c3 5b			ld a, (.dmark+2)  
5bbc 32 9f fd			ld (debug_mark+2),a  
5bbf 18 03			jr .pastdmark  
5bc1 ..			.dmark: db "AP2"  
5bc4 f1			.pastdmark: pop af  
5bc5			endm  
# End of macro DMARK
5bc5					CALLMONITOR 
5bc5 cd aa fd			call debug_vector  
5bc8				endm  
# End of macro CALLMONITOR
5bc8				endif 
5bc8					;inc de ; skip var type indicator 
5bc8			 
5bc8					; TODO how to append numerics???? 
5bc8			 
5bc8 cd 3b 0b				call storage_append		 
5bcb			 
5bcb				       NEXTW 
5bcb cd a7 fd			call parse_vector 
5bce c3 53 23			jp macro_next 
5bd1				endm 
# End of macro NEXTW
5bd1			.SDEL: 
5bd1				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5bd1 6a				db WORD_SYS_CORE+86             
5bd2 20 5c			dw .OPEN            
5bd4 05				db 4 + 1 
5bd5 .. 00			db "ERA",0              
5bd9				endm 
# End of macro CWHEAD
5bd9			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5bd9			; | | > [!NOTE] 
5bd9			; | | > Compatible with PicoSPINet  
5bd9					FORTH_DSP_VALUEHL 
5bd9 cd 6c 21			call macro_dsp_valuehl 
5bdc				endm 
# End of macro FORTH_DSP_VALUEHL
5bdc			;		push hl 	; save file id 
5bdc			 
5bdc					if DEBUG_FORTH_WORDS_KEY 
5bdc						DMARK "ERA" 
5bdc f5				push af  
5bdd 3a f1 5b			ld a, (.dmark)  
5be0 32 9d fd			ld (debug_mark),a  
5be3 3a f2 5b			ld a, (.dmark+1)  
5be6 32 9e fd			ld (debug_mark+1),a  
5be9 3a f3 5b			ld a, (.dmark+2)  
5bec 32 9f fd			ld (debug_mark+2),a  
5bef 18 03			jr .pastdmark  
5bf1 ..			.dmark: db "ERA"  
5bf4 f1			.pastdmark: pop af  
5bf5			endm  
# End of macro DMARK
5bf5						CALLMONITOR 
5bf5 cd aa fd			call debug_vector  
5bf8				endm  
# End of macro CALLMONITOR
5bf8					endif 
5bf8				if DEBUG_STORESE 
5bf8					DMARK "ER1" 
5bf8 f5				push af  
5bf9 3a 0d 5c			ld a, (.dmark)  
5bfc 32 9d fd			ld (debug_mark),a  
5bff 3a 0e 5c			ld a, (.dmark+1)  
5c02 32 9e fd			ld (debug_mark+1),a  
5c05 3a 0f 5c			ld a, (.dmark+2)  
5c08 32 9f fd			ld (debug_mark+2),a  
5c0b 18 03			jr .pastdmark  
5c0d ..			.dmark: db "ER1"  
5c10 f1			.pastdmark: pop af  
5c11			endm  
# End of macro DMARK
5c11					CALLMONITOR 
5c11 cd aa fd			call debug_vector  
5c14				endm  
# End of macro CALLMONITOR
5c14				endif 
5c14					FORTH_DSP_POP 
5c14 cd 24 22			call macro_forth_dsp_pop 
5c17				endm 
# End of macro FORTH_DSP_POP
5c17			 
5c17			;		pop hl 
5c17			 
5c17 cd 92 06				call storage_erase 
5c1a				       NEXTW 
5c1a cd a7 fd			call parse_vector 
5c1d c3 53 23			jp macro_next 
5c20				endm 
# End of macro NEXTW
5c20			 
5c20			.OPEN: 
5c20				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5c20 6b				db WORD_SYS_CORE+87             
5c21 b6 5c			dw .READ            
5c23 05				db 4 + 1 
5c24 .. 00			db "OPEN",0              
5c29				endm 
# End of macro CWHEAD
5c29			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5c29			; | | e.g. 
5c29			; | | $01 OPEN $01 DO $01 READ . LOOP 
5c29			; | | 
5c29			; | | Will return with 255 blocks if the file does not exist 
5c29			; | | > [!NOTE] 
5c29			; | | > Compatible with PicoSPINet  
5c29			 
5c29					if DEBUG_FORTH_WORDS_KEY 
5c29						DMARK "OPN" 
5c29 f5				push af  
5c2a 3a 3e 5c			ld a, (.dmark)  
5c2d 32 9d fd			ld (debug_mark),a  
5c30 3a 3f 5c			ld a, (.dmark+1)  
5c33 32 9e fd			ld (debug_mark+1),a  
5c36 3a 40 5c			ld a, (.dmark+2)  
5c39 32 9f fd			ld (debug_mark+2),a  
5c3c 18 03			jr .pastdmark  
5c3e ..			.dmark: db "OPN"  
5c41 f1			.pastdmark: pop af  
5c42			endm  
# End of macro DMARK
5c42						CALLMONITOR 
5c42 cd aa fd			call debug_vector  
5c45				endm  
# End of macro CALLMONITOR
5c45					endif 
5c45					; TODO handle multiple file opens 
5c45			 
5c45 3e 01			       	ld a, 1 
5c47 32 9c f9				ld (store_openext), a 
5c4a			 
5c4a					; get max extents for this file 
5c4a				 
5c4a								 
5c4a					FORTH_DSP_VALUEHL 
5c4a cd 6c 21			call macro_dsp_valuehl 
5c4d				endm 
# End of macro FORTH_DSP_VALUEHL
5c4d			 
5c4d 65					ld h, l 
5c4e 2e 00				ld l, 0 
5c50			 
5c50					; store file id 
5c50			 
5c50 7c					ld a, h 
5c51 32 99 f9				ld (store_filecache), a 
5c54			 
5c54				if DEBUG_STORESE 
5c54					DMARK "OPN" 
5c54 f5				push af  
5c55 3a 69 5c			ld a, (.dmark)  
5c58 32 9d fd			ld (debug_mark),a  
5c5b 3a 6a 5c			ld a, (.dmark+1)  
5c5e 32 9e fd			ld (debug_mark+1),a  
5c61 3a 6b 5c			ld a, (.dmark+2)  
5c64 32 9f fd			ld (debug_mark+2),a  
5c67 18 03			jr .pastdmark  
5c69 ..			.dmark: db "OPN"  
5c6c f1			.pastdmark: pop af  
5c6d			endm  
# End of macro DMARK
5c6d					CALLMONITOR 
5c6d cd aa fd			call debug_vector  
5c70				endm  
# End of macro CALLMONITOR
5c70				endif 
5c70			;		push hl 
5c70					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5c70 cd 24 22			call macro_forth_dsp_pop 
5c73				endm 
# End of macro FORTH_DSP_POP
5c73			;		pop hl 
5c73						 
5c73 11 ac f9				ld de, store_page      ; get block zero of file 
5c76 cd a7 09				call storage_read 
5c79 cd d5 0f			call ishlzero 
5c7c 20 04			jr nz, .opfound 
5c7e			 
5c7e				; file does not exist so indicate with 255 extents in use 
5c7e			 
5c7e 3e ff			ld a, 255 
5c80 18 28			jr .skipopeneof 
5c82			 
5c82			 
5c82			.opfound: 
5c82			 
5c82			 
5c82 3a ae f9				ld a, (store_page+2)    ; max extents for this file 
5c85 32 9b f9				ld  (store_openmaxext), a   ; get our limit and push 
5c88					 
5c88				if DEBUG_STORESE 
5c88					DMARK "OPx" 
5c88 f5				push af  
5c89 3a 9d 5c			ld a, (.dmark)  
5c8c 32 9d fd			ld (debug_mark),a  
5c8f 3a 9e 5c			ld a, (.dmark+1)  
5c92 32 9e fd			ld (debug_mark+1),a  
5c95 3a 9f 5c			ld a, (.dmark+2)  
5c98 32 9f fd			ld (debug_mark+2),a  
5c9b 18 03			jr .pastdmark  
5c9d ..			.dmark: db "OPx"  
5ca0 f1			.pastdmark: pop af  
5ca1			endm  
# End of macro DMARK
5ca1					CALLMONITOR 
5ca1 cd aa fd			call debug_vector  
5ca4				endm  
# End of macro CALLMONITOR
5ca4				endif 
5ca4			;		cp 0 
5ca4 b7					or a 
5ca5 20 03				jr nz, .skipopeneof 
5ca7					; have opened an empty file 
5ca7					 
5ca7 32 9c f9				ld (store_openext), a 
5caa			 
5caa			.skipopeneof: 
5caa			 
5caa 6f					ld l, a 
5cab 26 00				ld h, 0 
5cad cd 70 1f				call forth_push_numhl 
5cb0			 
5cb0			 
5cb0				       NEXTW 
5cb0 cd a7 fd			call parse_vector 
5cb3 c3 53 23			jp macro_next 
5cb6				endm 
# End of macro NEXTW
5cb6			.READ: 
5cb6				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5cb6 6c				db WORD_SYS_CORE+88             
5cb7 e5 5d			dw .EOF            
5cb9 05				db 4 + 1 
5cba .. 00			db "READ",0              
5cbf				endm 
# End of macro CWHEAD
5cbf			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5cbf			; | | e.g. 
5cbf			; | | $01 OPEN $01 DO READ . LOOP 
5cbf			; | | 
5cbf			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5cbf			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5cbf			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5cbf			; | | two bytes contain the file id and extent. 
5cbf			; | |  
5cbf			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5cbf			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5cbf			; | | > [!NOTE] 
5cbf			; | | > Compatible with PicoSPINet  
5cbf			 
5cbf					if DEBUG_FORTH_WORDS_KEY 
5cbf						DMARK "REA" 
5cbf f5				push af  
5cc0 3a d4 5c			ld a, (.dmark)  
5cc3 32 9d fd			ld (debug_mark),a  
5cc6 3a d5 5c			ld a, (.dmark+1)  
5cc9 32 9e fd			ld (debug_mark+1),a  
5ccc 3a d6 5c			ld a, (.dmark+2)  
5ccf 32 9f fd			ld (debug_mark+2),a  
5cd2 18 03			jr .pastdmark  
5cd4 ..			.dmark: db "REA"  
5cd7 f1			.pastdmark: pop af  
5cd8			endm  
# End of macro DMARK
5cd8						CALLMONITOR 
5cd8 cd aa fd			call debug_vector  
5cdb				endm  
# End of macro CALLMONITOR
5cdb					endif 
5cdb					; store_openext use it. If zero it is EOF 
5cdb			 
5cdb					; read block from current stream id 
5cdb					; if the block does not contain zero term keep reading blocks until zero found 
5cdb					; push the block to stack 
5cdb					; save the block id to stream 
5cdb			 
5cdb			 
5cdb cd 15 5e				call .testeof 
5cde 3e 01				ld a, 1 
5ce0 bd					cp l 
5ce1 ca be 5d				jp z, .ateof 
5ce4			 
5ce4			 
5ce4			;		FORTH_DSP_VALUEHL 
5ce4			 
5ce4			;		push hl 
5ce4			 
5ce4			;	if DEBUG_STORESE 
5ce4			;		DMARK "REA" 
5ce4			;		CALLMONITOR 
5ce4			;	endif 
5ce4			;		FORTH_DSP_POP 
5ce4			 
5ce4			;		pop hl 
5ce4				 
5ce4 3a 99 f9				ld a, (store_filecache) 
5ce7 67					ld h,a 
5ce8			 
5ce8 3a 9c f9				ld a, (store_openext) 
5ceb 6f					ld l, a 
5cec					 
5cec			;		cp 0 
5cec b7					or a 
5ced ca be 5d				jp z, .ateof     ; dont read past eof 
5cf0			 
5cf0 cd 84 0c				call storage_clear_page 
5cf3			 
5cf3 11 ac f9				ld de, store_page 
5cf6				if DEBUG_STORESE 
5cf6					DMARK "RE1" 
5cf6 f5				push af  
5cf7 3a 0b 5d			ld a, (.dmark)  
5cfa 32 9d fd			ld (debug_mark),a  
5cfd 3a 0c 5d			ld a, (.dmark+1)  
5d00 32 9e fd			ld (debug_mark+1),a  
5d03 3a 0d 5d			ld a, (.dmark+2)  
5d06 32 9f fd			ld (debug_mark+2),a  
5d09 18 03			jr .pastdmark  
5d0b ..			.dmark: db "RE1"  
5d0e f1			.pastdmark: pop af  
5d0f			endm  
# End of macro DMARK
5d0f					CALLMONITOR 
5d0f cd aa fd			call debug_vector  
5d12				endm  
# End of macro CALLMONITOR
5d12				endif 
5d12 cd a7 09				call storage_read 
5d15			 
5d15				if DEBUG_STORESE 
5d15					DMARK "RE2" 
5d15 f5				push af  
5d16 3a 2a 5d			ld a, (.dmark)  
5d19 32 9d fd			ld (debug_mark),a  
5d1c 3a 2b 5d			ld a, (.dmark+1)  
5d1f 32 9e fd			ld (debug_mark+1),a  
5d22 3a 2c 5d			ld a, (.dmark+2)  
5d25 32 9f fd			ld (debug_mark+2),a  
5d28 18 03			jr .pastdmark  
5d2a ..			.dmark: db "RE2"  
5d2d f1			.pastdmark: pop af  
5d2e			endm  
# End of macro DMARK
5d2e					CALLMONITOR 
5d2e cd aa fd			call debug_vector  
5d31				endm  
# End of macro CALLMONITOR
5d31				endif 
5d31 cd d5 0f			call ishlzero 
5d34			;	ld a, l 
5d34			;	add h 
5d34			;	cp 0 
5d34 ca be 5d			jp z, .readeof 
5d37			 
5d37				; not eof so hl should point to data to push to stack 
5d37			 
5d37				if DEBUG_STORESE 
5d37					DMARK "RE3" 
5d37 f5				push af  
5d38 3a 4c 5d			ld a, (.dmark)  
5d3b 32 9d fd			ld (debug_mark),a  
5d3e 3a 4d 5d			ld a, (.dmark+1)  
5d41 32 9e fd			ld (debug_mark+1),a  
5d44 3a 4e 5d			ld a, (.dmark+2)  
5d47 32 9f fd			ld (debug_mark+2),a  
5d4a 18 03			jr .pastdmark  
5d4c ..			.dmark: db "RE3"  
5d4f f1			.pastdmark: pop af  
5d50			endm  
# End of macro DMARK
5d50					CALLMONITOR 
5d50 cd aa fd			call debug_vector  
5d53				endm  
# End of macro CALLMONITOR
5d53				endif 
5d53 cd da 1f			call forth_push_str 
5d56			 
5d56				if DEBUG_STORESE 
5d56					DMARK "RE4" 
5d56 f5				push af  
5d57 3a 6b 5d			ld a, (.dmark)  
5d5a 32 9d fd			ld (debug_mark),a  
5d5d 3a 6c 5d			ld a, (.dmark+1)  
5d60 32 9e fd			ld (debug_mark+1),a  
5d63 3a 6d 5d			ld a, (.dmark+2)  
5d66 32 9f fd			ld (debug_mark+2),a  
5d69 18 03			jr .pastdmark  
5d6b ..			.dmark: db "RE4"  
5d6e f1			.pastdmark: pop af  
5d6f			endm  
# End of macro DMARK
5d6f					CALLMONITOR 
5d6f cd aa fd			call debug_vector  
5d72				endm  
# End of macro CALLMONITOR
5d72				endif 
5d72				; get next block  or mark as eof 
5d72			 
5d72 3a 9b f9			ld a, (store_openmaxext)   ; get our limit 
5d75 4f				ld c, a	 
5d76 3a 9c f9			ld a, (store_openext) 
5d79			 
5d79				if DEBUG_STORESE 
5d79					DMARK "RE5" 
5d79 f5				push af  
5d7a 3a 8e 5d			ld a, (.dmark)  
5d7d 32 9d fd			ld (debug_mark),a  
5d80 3a 8f 5d			ld a, (.dmark+1)  
5d83 32 9e fd			ld (debug_mark+1),a  
5d86 3a 90 5d			ld a, (.dmark+2)  
5d89 32 9f fd			ld (debug_mark+2),a  
5d8c 18 03			jr .pastdmark  
5d8e ..			.dmark: db "RE5"  
5d91 f1			.pastdmark: pop af  
5d92			endm  
# End of macro DMARK
5d92					CALLMONITOR 
5d92 cd aa fd			call debug_vector  
5d95				endm  
# End of macro CALLMONITOR
5d95				endif 
5d95 b9				cp c 
5d96 28 26			jr z, .readeof     ; at last extent 
5d98			 
5d98 3c					inc a 
5d99 32 9c f9				ld (store_openext), a 
5d9c			 
5d9c				if DEBUG_STORESE 
5d9c					DMARK "RE6" 
5d9c f5				push af  
5d9d 3a b1 5d			ld a, (.dmark)  
5da0 32 9d fd			ld (debug_mark),a  
5da3 3a b2 5d			ld a, (.dmark+1)  
5da6 32 9e fd			ld (debug_mark+1),a  
5da9 3a b3 5d			ld a, (.dmark+2)  
5dac 32 9f fd			ld (debug_mark+2),a  
5daf 18 03			jr .pastdmark  
5db1 ..			.dmark: db "RE6"  
5db4 f1			.pastdmark: pop af  
5db5			endm  
# End of macro DMARK
5db5					CALLMONITOR 
5db5 cd aa fd			call debug_vector  
5db8				endm  
# End of macro CALLMONITOR
5db8				endif 
5db8			 
5db8			 
5db8				       NEXTW 
5db8 cd a7 fd			call parse_vector 
5dbb c3 53 23			jp macro_next 
5dbe				endm 
# End of macro NEXTW
5dbe			.ateof: 
5dbe				;	ld hl, .showeof 
5dbe				;	call forth_push_str 
5dbe 3e 00		.readeof:	ld a, 0 
5dc0 32 9c f9				ld (store_openext), a 
5dc3			 
5dc3					 
5dc3				if DEBUG_STORESE 
5dc3					DMARK "REF" 
5dc3 f5				push af  
5dc4 3a d8 5d			ld a, (.dmark)  
5dc7 32 9d fd			ld (debug_mark),a  
5dca 3a d9 5d			ld a, (.dmark+1)  
5dcd 32 9e fd			ld (debug_mark+1),a  
5dd0 3a da 5d			ld a, (.dmark+2)  
5dd3 32 9f fd			ld (debug_mark+2),a  
5dd6 18 03			jr .pastdmark  
5dd8 ..			.dmark: db "REF"  
5ddb f1			.pastdmark: pop af  
5ddc			endm  
# End of macro DMARK
5ddc					CALLMONITOR 
5ddc cd aa fd			call debug_vector  
5ddf				endm  
# End of macro CALLMONITOR
5ddf				endif 
5ddf				       NEXTW 
5ddf cd a7 fd			call parse_vector 
5de2 c3 53 23			jp macro_next 
5de5				endm 
# End of macro NEXTW
5de5			 
5de5			;.showeof:   db "eof", 0 
5de5			 
5de5			 
5de5			.EOF: 
5de5				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5de5 6d				db WORD_SYS_CORE+89             
5de6 28 5e			dw .FORMAT            
5de8 04				db 3 + 1 
5de9 .. 00			db "EOF",0              
5ded				endm 
# End of macro CWHEAD
5ded			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5ded			; | | e.g. 
5ded			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5ded			; | | > [!NOTE] 
5ded			; | | > Compatible with PicoSPINet  
5ded					; TODO if current block id for stream is zero then push true else false 
5ded			 
5ded					if DEBUG_FORTH_WORDS_KEY 
5ded						DMARK "EOF" 
5ded f5				push af  
5dee 3a 02 5e			ld a, (.dmark)  
5df1 32 9d fd			ld (debug_mark),a  
5df4 3a 03 5e			ld a, (.dmark+1)  
5df7 32 9e fd			ld (debug_mark+1),a  
5dfa 3a 04 5e			ld a, (.dmark+2)  
5dfd 32 9f fd			ld (debug_mark+2),a  
5e00 18 03			jr .pastdmark  
5e02 ..			.dmark: db "EOF"  
5e05 f1			.pastdmark: pop af  
5e06			endm  
# End of macro DMARK
5e06						CALLMONITOR 
5e06 cd aa fd			call debug_vector  
5e09				endm  
# End of macro CALLMONITOR
5e09					endif 
5e09			 
5e09					; TODO handlue multiple file streams 
5e09			 
5e09			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5e09 cd 15 5e				call .testeof 
5e0c cd 70 1f				call forth_push_numhl 
5e0f			 
5e0f			 
5e0f				       NEXTW 
5e0f cd a7 fd			call parse_vector 
5e12 c3 53 23			jp macro_next 
5e15				endm 
# End of macro NEXTW
5e15			 
5e15			.testeof: 
5e15 2e 01				ld l, 1 
5e17 3a 9b f9				ld a, (store_openmaxext) 
5e1a			;		cp 0 
5e1a b7					or a 
5e1b 28 08				jr  z, .eofdone   ; empty file 
5e1d 3a 9c f9				ld a, (store_openext) 
5e20			;		cp 0 
5e20 b7					or a 
5e21 28 02				jr  z, .eofdone 
5e23 2e 00				ld l, 0 
5e25 26 00		.eofdone:	ld h, 0 
5e27 c9					ret 
5e28			 
5e28			 
5e28			 
5e28			 
5e28			.FORMAT: 
5e28				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5e28 6d				db WORD_SYS_CORE+89             
5e29 7c 5e			dw .LABEL            
5e2b 07				db 6 + 1 
5e2c .. 00			db "FORMAT",0              
5e33				endm 
# End of macro CWHEAD
5e33			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5e33			; | | > [!NOTE] 
5e33			; | | > Compatible with PicoSPINet  
5e33					; TODO if current block id for stream is zero then push true else false 
5e33				 
5e33				if DEBUG_STORESE 
5e33					DMARK "FOR" 
5e33 f5				push af  
5e34 3a 48 5e			ld a, (.dmark)  
5e37 32 9d fd			ld (debug_mark),a  
5e3a 3a 49 5e			ld a, (.dmark+1)  
5e3d 32 9e fd			ld (debug_mark+1),a  
5e40 3a 4a 5e			ld a, (.dmark+2)  
5e43 32 9f fd			ld (debug_mark+2),a  
5e46 18 03			jr .pastdmark  
5e48 ..			.dmark: db "FOR"  
5e4b f1			.pastdmark: pop af  
5e4c			endm  
# End of macro DMARK
5e4c					CALLMONITOR 
5e4c cd aa fd			call debug_vector  
5e4f				endm  
# End of macro CALLMONITOR
5e4f				endif 
5e4f					; Wipes the bank check flags to cause a reformat on next block 0 read 
5e4f			 
5e4f 21 01 00				ld hl, 1 
5e52 3e 00				ld a, 0 
5e54 cd 65 02				call se_writebyte 
5e57			 
5e57				if DEBUG_STORESE 
5e57					DMARK "FO0" 
5e57 f5				push af  
5e58 3a 6c 5e			ld a, (.dmark)  
5e5b 32 9d fd			ld (debug_mark),a  
5e5e 3a 6d 5e			ld a, (.dmark+1)  
5e61 32 9e fd			ld (debug_mark+1),a  
5e64 3a 6e 5e			ld a, (.dmark+2)  
5e67 32 9f fd			ld (debug_mark+2),a  
5e6a 18 03			jr .pastdmark  
5e6c ..			.dmark: db "FO0"  
5e6f f1			.pastdmark: pop af  
5e70			endm  
# End of macro DMARK
5e70					CALLMONITOR 
5e70 cd aa fd			call debug_vector  
5e73				endm  
# End of macro CALLMONITOR
5e73				endif 
5e73					; force bank init 
5e73			 
5e73 cd 05 05				call storage_get_block_0 
5e76					 
5e76				       NEXTW 
5e76 cd a7 fd			call parse_vector 
5e79 c3 53 23			jp macro_next 
5e7c				endm 
# End of macro NEXTW
5e7c			.LABEL: 
5e7c				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5e7c 6d				db WORD_SYS_CORE+89             
5e7d cd 5e			dw .STOREPAGE            
5e7f 06				db 5 + 1 
5e80 .. 00			db "LABEL",0              
5e86				endm 
# End of macro CWHEAD
5e86			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5e86			; | | > [!NOTE] 
5e86			; | | > Compatible with PicoSPINet  
5e86					; TODO test to see if bank is selected 
5e86				 
5e86					if DEBUG_FORTH_WORDS_KEY 
5e86						DMARK "LBL" 
5e86 f5				push af  
5e87 3a 9b 5e			ld a, (.dmark)  
5e8a 32 9d fd			ld (debug_mark),a  
5e8d 3a 9c 5e			ld a, (.dmark+1)  
5e90 32 9e fd			ld (debug_mark+1),a  
5e93 3a 9d 5e			ld a, (.dmark+2)  
5e96 32 9f fd			ld (debug_mark+2),a  
5e99 18 03			jr .pastdmark  
5e9b ..			.dmark: db "LBL"  
5e9e f1			.pastdmark: pop af  
5e9f			endm  
# End of macro DMARK
5e9f						CALLMONITOR 
5e9f cd aa fd			call debug_vector  
5ea2				endm  
# End of macro CALLMONITOR
5ea2					endif 
5ea2			;	if DEBUG_STORESE 
5ea2			;		DMARK "LBL" 
5ea2			;		CALLMONITOR 
5ea2			;	endif 
5ea2					FORTH_DSP_VALUEHL 
5ea2 cd 6c 21			call macro_dsp_valuehl 
5ea5				endm 
# End of macro FORTH_DSP_VALUEHL
5ea5					;v5FORTH_DSP_VALUE 
5ea5					 
5ea5			;		push hl 
5ea5					FORTH_DSP_POP 
5ea5 cd 24 22			call macro_forth_dsp_pop 
5ea8				endm 
# End of macro FORTH_DSP_POP
5ea8			;		pop hl 
5ea8			 
5ea8			;v5		inc hl   ; move past the type marker 
5ea8			 
5ea8				if DEBUG_STORESE 
5ea8					DMARK "LBl" 
5ea8 f5				push af  
5ea9 3a bd 5e			ld a, (.dmark)  
5eac 32 9d fd			ld (debug_mark),a  
5eaf 3a be 5e			ld a, (.dmark+1)  
5eb2 32 9e fd			ld (debug_mark+1),a  
5eb5 3a bf 5e			ld a, (.dmark+2)  
5eb8 32 9f fd			ld (debug_mark+2),a  
5ebb 18 03			jr .pastdmark  
5ebd ..			.dmark: db "LBl"  
5ec0 f1			.pastdmark: pop af  
5ec1			endm  
# End of macro DMARK
5ec1					CALLMONITOR 
5ec1 cd aa fd			call debug_vector  
5ec4				endm  
# End of macro CALLMONITOR
5ec4				endif 
5ec4 cd 25 06				call storage_label 
5ec7			 
5ec7				       NEXTW 
5ec7 cd a7 fd			call parse_vector 
5eca c3 53 23			jp macro_next 
5ecd				endm 
# End of macro NEXTW
5ecd			.STOREPAGE: 
5ecd				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5ecd 6d				db WORD_SYS_CORE+89             
5ece 03 5f			dw .LABELS            
5ed0 0a				db 9 + 1 
5ed1 .. 00			db "STOREPAGE",0              
5edb				endm 
# End of macro CWHEAD
5edb			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5edb			; | | > [!NOTE] 
5edb			; | | > Compatible with PicoSPINet  
5edb					; TODO test to see if bank is selected 
5edb				 
5edb					if DEBUG_FORTH_WORDS_KEY 
5edb						DMARK "STP" 
5edb f5				push af  
5edc 3a f0 5e			ld a, (.dmark)  
5edf 32 9d fd			ld (debug_mark),a  
5ee2 3a f1 5e			ld a, (.dmark+1)  
5ee5 32 9e fd			ld (debug_mark+1),a  
5ee8 3a f2 5e			ld a, (.dmark+2)  
5eeb 32 9f fd			ld (debug_mark+2),a  
5eee 18 03			jr .pastdmark  
5ef0 ..			.dmark: db "STP"  
5ef3 f1			.pastdmark: pop af  
5ef4			endm  
# End of macro DMARK
5ef4						CALLMONITOR 
5ef4 cd aa fd			call debug_vector  
5ef7				endm  
# End of macro CALLMONITOR
5ef7					endif 
5ef7			;	if DEBUG_STORESE 
5ef7			;		DMARK "STP" 
5ef7			;		CALLMONITOR 
5ef7			;	endif 
5ef7			 
5ef7 21 ac f9			ld hl, store_page 
5efa cd 70 1f			call forth_push_numhl 
5efd			 
5efd			 
5efd				       NEXTW 
5efd cd a7 fd			call parse_vector 
5f00 c3 53 23			jp macro_next 
5f03				endm 
# End of macro NEXTW
5f03			.LABELS: 
5f03				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5f03 6d				db WORD_SYS_CORE+89             
5f04 90 5f			dw .SCONST1            
5f06 07				db 6 + 1 
5f07 .. 00			db "LABELS",0              
5f0e				endm 
# End of macro CWHEAD
5f0e			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5f0e			; | | > [!CAUTION] 
5f0e			; | | > *NOT* Compatible with PicoSPINet  
5f0e					;  
5f0e			 
5f0e					; save the current device selected to restore afterwards 
5f0e				 
5f0e 3a 92 f9				ld a, (spi_device) 
5f11 f5					push af 
5f12			 
5f12			 
5f12					; run through each of the banks 
5f12			 
5f12 21 01 00				ld hl, 1 
5f15 cd 70 1f				call forth_push_numhl 
5f18 3e ff				ld a, SPI_CE_HIGH 
5f1a cb 87				res SPI_CE0, a 
5f1c 32 92 f9				ld (spi_device), a 
5f1f cd 05 05				call storage_get_block_0 
5f22 21 af f9				ld hl, store_page+3 
5f25 cd da 1f				call forth_push_str 
5f28			 
5f28					 
5f28 21 02 00				ld hl, 2 
5f2b cd 70 1f				call forth_push_numhl 
5f2e 3e ff				ld a, SPI_CE_HIGH 
5f30 cb 8f				res SPI_CE1, a 
5f32 32 92 f9				ld (spi_device), a 
5f35 cd 05 05				call storage_get_block_0 
5f38 21 af f9				ld hl, store_page+3 
5f3b cd da 1f				call forth_push_str 
5f3e			 
5f3e					 
5f3e 21 03 00				ld hl, 3 
5f41 cd 70 1f				call forth_push_numhl 
5f44 3e ff				ld a, SPI_CE_HIGH 
5f46 cb 97				res SPI_CE2, a 
5f48 32 92 f9				ld (spi_device), a 
5f4b cd 05 05				call storage_get_block_0 
5f4e 21 af f9				ld hl, store_page+3 
5f51 cd da 1f				call forth_push_str 
5f54			 
5f54			 
5f54 21 04 00				ld hl, 4 
5f57 cd 70 1f				call forth_push_numhl 
5f5a 3e ff				ld a, SPI_CE_HIGH 
5f5c cb 9f				res SPI_CE3, a 
5f5e 32 92 f9				ld (spi_device), a 
5f61 cd 05 05				call storage_get_block_0 
5f64 21 af f9				ld hl, store_page+3 
5f67 cd da 1f				call forth_push_str 
5f6a			 
5f6a					 
5f6a			 
5f6a 21 05 00				ld hl, 5 
5f6d cd 70 1f				call forth_push_numhl 
5f70 3e ff				ld a, SPI_CE_HIGH 
5f72 cb a7				res SPI_CE4, a 
5f74 32 92 f9				ld (spi_device), a 
5f77 cd 05 05				call storage_get_block_0 
5f7a 21 af f9				ld hl, store_page+3 
5f7d cd da 1f				call forth_push_str 
5f80			 
5f80					 
5f80					; push fixed count of storage devices (on board) for now 
5f80			 
5f80 21 05 00				ld hl, 5 
5f83 cd 70 1f				call forth_push_numhl 
5f86			 
5f86					; restore selected device  
5f86				 
5f86 f1					pop af 
5f87 32 92 f9				ld (spi_device), a 
5f8a			 
5f8a				       NEXTW 
5f8a cd a7 fd			call parse_vector 
5f8d c3 53 23			jp macro_next 
5f90				endm 
# End of macro NEXTW
5f90			 
5f90			.SCONST1: 
5f90				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5f90 6d				db WORD_SYS_CORE+89             
5f91 aa 5f			dw .SCONST2            
5f93 07				db 6 + 1 
5f94 .. 00			db "FILEID",0              
5f9b				endm 
# End of macro CWHEAD
5f9b			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5f9b			; | | > [!NOTE] 
5f9b			; | | > Compatible with PicoSPINet  
5f9b 3a 99 f9				ld a, (store_filecache) 
5f9e 26 00				ld h, 0 
5fa0 6f					ld l, a 
5fa1 cd 70 1f				call forth_push_numhl 
5fa4					NEXTW 
5fa4 cd a7 fd			call parse_vector 
5fa7 c3 53 23			jp macro_next 
5faa				endm 
# End of macro NEXTW
5faa			.SCONST2: 
5faa				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5faa 6d				db WORD_SYS_CORE+89             
5fab c5 5f			dw .SCONST3            
5fad 08				db 7 + 1 
5fae .. 00			db "FILEEXT",0              
5fb6				endm 
# End of macro CWHEAD
5fb6			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5fb6			; | | > [!NOTE] 
5fb6			; | | > Compatible with PicoSPINet  
5fb6 3a 9c f9				ld a, (store_openext) 
5fb9 26 00				ld h, 0 
5fbb 6f					ld l, a 
5fbc cd 70 1f				call forth_push_numhl 
5fbf					NEXTW 
5fbf cd a7 fd			call parse_vector 
5fc2 c3 53 23			jp macro_next 
5fc5				endm 
# End of macro NEXTW
5fc5			.SCONST3: 
5fc5				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5fc5 6d				db WORD_SYS_CORE+89             
5fc6 e0 5f			dw .SCONST4            
5fc8 08				db 7 + 1 
5fc9 .. 00			db "FILEMAX",0              
5fd1				endm 
# End of macro CWHEAD
5fd1			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5fd1			; | | > [!NOTE] 
5fd1			; | | > Compatible with PicoSPINet  
5fd1 3a 9b f9				ld a, (store_openmaxext) 
5fd4 26 00				ld h, 0 
5fd6 6f					ld l, a 
5fd7 cd 70 1f				call forth_push_numhl 
5fda					NEXTW 
5fda cd a7 fd			call parse_vector 
5fdd c3 53 23			jp macro_next 
5fe0				endm 
# End of macro NEXTW
5fe0			.SCONST4: 
5fe0				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5fe0 6d				db WORD_SYS_CORE+89             
5fe1 f9 5f			dw .SCONST5            
5fe3 09				db 8 + 1 
5fe4 .. 00			db "FILEADDR",0              
5fed				endm 
# End of macro CWHEAD
5fed			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5fed			; | | > [!NOTE] 
5fed			; | | > Compatible with PicoSPINet  
5fed 2a 9d f9				ld hl, (store_openaddr) 
5ff0 cd 70 1f				call forth_push_numhl 
5ff3					NEXTW 
5ff3 cd a7 fd			call parse_vector 
5ff6 c3 53 23			jp macro_next 
5ff9				endm 
# End of macro NEXTW
5ff9			.SCONST5: 
5ff9				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5ff9 6d				db WORD_SYS_CORE+89             
5ffa 1d 60			dw .SCONST6            
5ffc 09				db 8 + 1 
5ffd .. 00			db "FILEPAGE",0              
6006				endm 
# End of macro CWHEAD
6006			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
6006			; | | > [!NOTE] 
6006			; | | > Compatible with PicoSPINet  
6006 2a 9d f9				ld hl, (store_openaddr) 
6009 e5					push hl 
600a c1					pop bc 
600b 16 00				ld d, 0 
600d 1e 40				ld e, STORE_BLOCK_PHY 
600f cd 09 0f				call Div16 
6012 c5					push bc 
6013 e1					pop hl 
6014 cd 70 1f				call forth_push_numhl 
6017					NEXTW 
6017 cd a7 fd			call parse_vector 
601a c3 53 23			jp macro_next 
601d				endm 
# End of macro NEXTW
601d			.SCONST6: 
601d				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
601d 6d				db WORD_SYS_CORE+89             
601e 39 60			dw .ENDSTORAGE            
6020 09				db 8 + 1 
6021 .. 00			db "READCONT",0              
602a				endm 
# End of macro CWHEAD
602a			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
602a			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
602a			; | | a further read should, if applicable, be CONCAT to the previous read. 
602a			; | | > [!NOTE] 
602a			; | | > Compatible with PicoSPINet  
602a 3a 9f f9				ld a, (store_readcont) 
602d 26 00				ld h, 0 
602f 6f					ld l, a 
6030 cd 70 1f				call forth_push_numhl 
6033					NEXTW 
6033 cd a7 fd			call parse_vector 
6036 c3 53 23			jp macro_next 
6039				endm 
# End of macro NEXTW
6039			.ENDSTORAGE: 
6039			; eof 
# End of file forth_words_storage.asm
6039			endif 
6039				include "forth_words_device.asm" 
6039			; Device related words 
6039			 
6039			; | ## Device Words 
6039			 
6039			;if SOUND_ENABLE 
6039			;.NOTE: 
6039			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
6039			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
6039			;		if DEBUG_FORTH_WORDS_KEY 
6039			;			DMARK "NTE" 
6039			;			CALLMONITOR 
6039			;		endif 
6039			; 
6039			;	 
6039			; 
6039			;		NEXTW 
6039			;.AFTERSOUND: 
6039			;endif 
6039			 
6039			 
6039			USE_GPIO: equ 0 
6039			 
6039			if USE_GPIO 
6039			.GP1: 
6039				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
6039			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
6039					NEXTW 
6039			.GP2: 
6039				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
6039			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
6039			 
6039					NEXTW 
6039			 
6039			.GP3: 
6039				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
6039			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
6039			 
6039					NEXTW 
6039			 
6039			.GP4: 
6039				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
6039			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
6039			 
6039					NEXTW 
6039			.SIN: 
6039			 
6039			 
6039			endif 
6039			 
6039			 
6039				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
6039 33				db WORD_SYS_CORE+31             
603a 71 60			dw .SOUT            
603c 03				db 2 + 1 
603d .. 00			db "IN",0              
6040				endm 
# End of macro CWHEAD
6040			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
6040					if DEBUG_FORTH_WORDS_KEY 
6040						DMARK "IN." 
6040 f5				push af  
6041 3a 55 60			ld a, (.dmark)  
6044 32 9d fd			ld (debug_mark),a  
6047 3a 56 60			ld a, (.dmark+1)  
604a 32 9e fd			ld (debug_mark+1),a  
604d 3a 57 60			ld a, (.dmark+2)  
6050 32 9f fd			ld (debug_mark+2),a  
6053 18 03			jr .pastdmark  
6055 ..			.dmark: db "IN."  
6058 f1			.pastdmark: pop af  
6059			endm  
# End of macro DMARK
6059						CALLMONITOR 
6059 cd aa fd			call debug_vector  
605c				endm  
# End of macro CALLMONITOR
605c					endif 
605c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
605c cd 6c 21			call macro_dsp_valuehl 
605f				endm 
# End of macro FORTH_DSP_VALUEHL
605f			 
605f e5					push hl 
6060			 
6060					; destroy value TOS 
6060			 
6060					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6060 cd 24 22			call macro_forth_dsp_pop 
6063				endm 
# End of macro FORTH_DSP_POP
6063			 
6063					; one value on hl get other one back 
6063			 
6063 c1					pop bc 
6064			 
6064					; do the sub 
6064			;		ex de, hl 
6064			 
6064 ed 68				in l,(c) 
6066			 
6066					; save it 
6066			 
6066 26 00				ld h,0 
6068			 
6068					; TODO push value back onto stack for another op etc 
6068			 
6068 cd 70 1f				call forth_push_numhl 
606b					NEXTW 
606b cd a7 fd			call parse_vector 
606e c3 53 23			jp macro_next 
6071				endm 
# End of macro NEXTW
6071			.SOUT: 
6071				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
6071 34				db WORD_SYS_CORE+32             
6072 c7 60			dw .SPIO            
6074 04				db 3 + 1 
6075 .. 00			db "OUT",0              
6079				endm 
# End of macro CWHEAD
6079			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
6079					if DEBUG_FORTH_WORDS_KEY 
6079						DMARK "OUT" 
6079 f5				push af  
607a 3a 8e 60			ld a, (.dmark)  
607d 32 9d fd			ld (debug_mark),a  
6080 3a 8f 60			ld a, (.dmark+1)  
6083 32 9e fd			ld (debug_mark+1),a  
6086 3a 90 60			ld a, (.dmark+2)  
6089 32 9f fd			ld (debug_mark+2),a  
608c 18 03			jr .pastdmark  
608e ..			.dmark: db "OUT"  
6091 f1			.pastdmark: pop af  
6092			endm  
# End of macro DMARK
6092						CALLMONITOR 
6092 cd aa fd			call debug_vector  
6095				endm  
# End of macro CALLMONITOR
6095					endif 
6095			 
6095					; get port 
6095			 
6095					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6095 cd 6c 21			call macro_dsp_valuehl 
6098				endm 
# End of macro FORTH_DSP_VALUEHL
6098			 
6098 e5					push hl 
6099			 
6099					; destroy value TOS 
6099			 
6099					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6099 cd 24 22			call macro_forth_dsp_pop 
609c				endm 
# End of macro FORTH_DSP_POP
609c			 
609c					; get byte to send 
609c			 
609c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
609c cd 6c 21			call macro_dsp_valuehl 
609f				endm 
# End of macro FORTH_DSP_VALUEHL
609f			 
609f			;		push hl 
609f			 
609f					; destroy value TOS 
609f			 
609f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
609f cd 24 22			call macro_forth_dsp_pop 
60a2				endm 
# End of macro FORTH_DSP_POP
60a2			 
60a2					; one value on hl get other one back 
60a2			 
60a2			;		pop hl 
60a2			 
60a2 c1					pop bc 
60a3			 
60a3					if DEBUG_FORTH_WORDS 
60a3						DMARK "OUT" 
60a3 f5				push af  
60a4 3a b8 60			ld a, (.dmark)  
60a7 32 9d fd			ld (debug_mark),a  
60aa 3a b9 60			ld a, (.dmark+1)  
60ad 32 9e fd			ld (debug_mark+1),a  
60b0 3a ba 60			ld a, (.dmark+2)  
60b3 32 9f fd			ld (debug_mark+2),a  
60b6 18 03			jr .pastdmark  
60b8 ..			.dmark: db "OUT"  
60bb f1			.pastdmark: pop af  
60bc			endm  
# End of macro DMARK
60bc						CALLMONITOR 
60bc cd aa fd			call debug_vector  
60bf				endm  
# End of macro CALLMONITOR
60bf					endif 
60bf			 
60bf ed 69				out (c), l 
60c1			 
60c1					NEXTW 
60c1 cd a7 fd			call parse_vector 
60c4 c3 53 23			jp macro_next 
60c7				endm 
# End of macro NEXTW
60c7			 
60c7			 
60c7			.SPIO: 
60c7			 
60c7			if STORAGE_SE 
60c7				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
60c7 51				db WORD_SYS_CORE+61             
60c8 db 60			dw .SPICEH            
60ca 07				db 6 + 1 
60cb .. 00			db "SPICEL",0              
60d2				endm 
# End of macro CWHEAD
60d2			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
60d2			 
60d2 cd 0e 02				call spi_ce_low 
60d5			    NEXTW 
60d5 cd a7 fd			call parse_vector 
60d8 c3 53 23			jp macro_next 
60db				endm 
# End of macro NEXTW
60db			 
60db			.SPICEH: 
60db				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
60db 51				db WORD_SYS_CORE+61             
60dc ef 60			dw .SPIOb            
60de 07				db 6 + 1 
60df .. 00			db "SPICEH",0              
60e6				endm 
# End of macro CWHEAD
60e6			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
60e6			 
60e6 cd fd 01				call spi_ce_high 
60e9			    NEXTW 
60e9 cd a7 fd			call parse_vector 
60ec c3 53 23			jp macro_next 
60ef				endm 
# End of macro NEXTW
60ef			 
60ef			 
60ef			.SPIOb: 
60ef			 
60ef				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
60ef 51				db WORD_SYS_CORE+61             
60f0 24 61			dw .SPII            
60f2 05				db 4 + 1 
60f3 .. 00			db "SPIO",0              
60f8				endm 
# End of macro CWHEAD
60f8			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
60f8			 
60f8					if DEBUG_FORTH_WORDS_KEY 
60f8						DMARK "SPo" 
60f8 f5				push af  
60f9 3a 0d 61			ld a, (.dmark)  
60fc 32 9d fd			ld (debug_mark),a  
60ff 3a 0e 61			ld a, (.dmark+1)  
6102 32 9e fd			ld (debug_mark+1),a  
6105 3a 0f 61			ld a, (.dmark+2)  
6108 32 9f fd			ld (debug_mark+2),a  
610b 18 03			jr .pastdmark  
610d ..			.dmark: db "SPo"  
6110 f1			.pastdmark: pop af  
6111			endm  
# End of macro DMARK
6111						CALLMONITOR 
6111 cd aa fd			call debug_vector  
6114				endm  
# End of macro CALLMONITOR
6114					endif 
6114					; get port 
6114			 
6114			 
6114					; get byte to send 
6114			 
6114					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6114 cd 6c 21			call macro_dsp_valuehl 
6117				endm 
# End of macro FORTH_DSP_VALUEHL
6117			 
6117			;		push hl    ; u1  
6117			 
6117					; destroy value TOS 
6117			 
6117					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6117 cd 24 22			call macro_forth_dsp_pop 
611a				endm 
# End of macro FORTH_DSP_POP
611a			 
611a					; one value on hl get other one back 
611a			 
611a			;		pop hl   ; u2 - addr 
611a			 
611a					; TODO Send SPI byte 
611a			 
611a			;		push hl 
611a			;		call spi_ce_low 
611a			;		pop hl 
611a 7d					ld a, l 
611b cd 0f 01				call spi_send_byte 
611e			;		call spi_ce_high 
611e			 
611e					NEXTW 
611e cd a7 fd			call parse_vector 
6121 c3 53 23			jp macro_next 
6124				endm 
# End of macro NEXTW
6124			 
6124			.SPII: 
6124				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
6124 52				db WORD_SYS_CORE+62             
6125 90 61			dw .SESEL            
6127 06				db 5 + 1 
6128 .. 00			db "SPII",0              
612d				endm 
# End of macro CWHEAD
612d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
612d					if DEBUG_FORTH_WORDS_KEY 
612d						DMARK "SPi" 
612d f5				push af  
612e 3a 42 61			ld a, (.dmark)  
6131 32 9d fd			ld (debug_mark),a  
6134 3a 43 61			ld a, (.dmark+1)  
6137 32 9e fd			ld (debug_mark+1),a  
613a 3a 44 61			ld a, (.dmark+2)  
613d 32 9f fd			ld (debug_mark+2),a  
6140 18 03			jr .pastdmark  
6142 ..			.dmark: db "SPi"  
6145 f1			.pastdmark: pop af  
6146			endm  
# End of macro DMARK
6146						CALLMONITOR 
6146 cd aa fd			call debug_vector  
6149				endm  
# End of macro CALLMONITOR
6149					endif 
6149			 
6149					; TODO Get SPI byte 
6149			 
6149 cd 33 01				call spi_read_byte 
614c			 
614c					if DEBUG_FORTH_WORDS 
614c						DMARK "Si2" 
614c f5				push af  
614d 3a 61 61			ld a, (.dmark)  
6150 32 9d fd			ld (debug_mark),a  
6153 3a 62 61			ld a, (.dmark+1)  
6156 32 9e fd			ld (debug_mark+1),a  
6159 3a 63 61			ld a, (.dmark+2)  
615c 32 9f fd			ld (debug_mark+2),a  
615f 18 03			jr .pastdmark  
6161 ..			.dmark: db "Si2"  
6164 f1			.pastdmark: pop af  
6165			endm  
# End of macro DMARK
6165						CALLMONITOR 
6165 cd aa fd			call debug_vector  
6168				endm  
# End of macro CALLMONITOR
6168					endif 
6168 26 00				ld h, 0 
616a 6f					ld l, a 
616b					if DEBUG_FORTH_WORDS 
616b						DMARK "Si3" 
616b f5				push af  
616c 3a 80 61			ld a, (.dmark)  
616f 32 9d fd			ld (debug_mark),a  
6172 3a 81 61			ld a, (.dmark+1)  
6175 32 9e fd			ld (debug_mark+1),a  
6178 3a 82 61			ld a, (.dmark+2)  
617b 32 9f fd			ld (debug_mark+2),a  
617e 18 03			jr .pastdmark  
6180 ..			.dmark: db "Si3"  
6183 f1			.pastdmark: pop af  
6184			endm  
# End of macro DMARK
6184						CALLMONITOR 
6184 cd aa fd			call debug_vector  
6187				endm  
# End of macro CALLMONITOR
6187					endif 
6187 cd 70 1f				call forth_push_numhl 
618a			 
618a					NEXTW 
618a cd a7 fd			call parse_vector 
618d c3 53 23			jp macro_next 
6190				endm 
# End of macro NEXTW
6190			 
6190			 
6190			 
6190			.SESEL: 
6190				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
6190 66				db WORD_SYS_CORE+82             
6191 3b 62			dw .CARTDEV            
6193 05				db 4 + 1 
6194 .. 00			db "BANK",0              
6199				endm 
# End of macro CWHEAD
6199			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV).  | DONE 
6199			; | | Set to zero to disable storage. 
6199					if DEBUG_FORTH_WORDS_KEY 
6199						DMARK "BNK" 
6199 f5				push af  
619a 3a ae 61			ld a, (.dmark)  
619d 32 9d fd			ld (debug_mark),a  
61a0 3a af 61			ld a, (.dmark+1)  
61a3 32 9e fd			ld (debug_mark+1),a  
61a6 3a b0 61			ld a, (.dmark+2)  
61a9 32 9f fd			ld (debug_mark+2),a  
61ac 18 03			jr .pastdmark  
61ae ..			.dmark: db "BNK"  
61b1 f1			.pastdmark: pop af  
61b2			endm  
# End of macro DMARK
61b2						CALLMONITOR 
61b2 cd aa fd			call debug_vector  
61b5				endm  
# End of macro CALLMONITOR
61b5					endif 
61b5			 
61b5 3e ff				ld a, 255 
61b7 32 95 f9				ld (spi_cartdev), a 
61ba			 
61ba					; get bank 
61ba			 
61ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
61ba cd 6c 21			call macro_dsp_valuehl 
61bd				endm 
# End of macro FORTH_DSP_VALUEHL
61bd			 
61bd			;		push hl 
61bd			 
61bd					; destroy value TOS 
61bd			 
61bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
61bd cd 24 22			call macro_forth_dsp_pop 
61c0				endm 
# End of macro FORTH_DSP_POP
61c0			 
61c0					; one value on hl get other one back 
61c0			 
61c0			;		pop hl 
61c0			 
61c0			 
61c0 0e ff				ld c, SPI_CE_HIGH 
61c2 06 30				ld b, '0'    ; human readable bank number 
61c4			 
61c4 7d					ld a, l 
61c5			 
61c5					if DEBUG_FORTH_WORDS 
61c5						DMARK "BNK" 
61c5 f5				push af  
61c6 3a da 61			ld a, (.dmark)  
61c9 32 9d fd			ld (debug_mark),a  
61cc 3a db 61			ld a, (.dmark+1)  
61cf 32 9e fd			ld (debug_mark+1),a  
61d2 3a dc 61			ld a, (.dmark+2)  
61d5 32 9f fd			ld (debug_mark+2),a  
61d8 18 03			jr .pastdmark  
61da ..			.dmark: db "BNK"  
61dd f1			.pastdmark: pop af  
61de			endm  
# End of macro DMARK
61de						CALLMONITOR 
61de cd aa fd			call debug_vector  
61e1				endm  
# End of macro CALLMONITOR
61e1					endif 
61e1			 
61e1					; active low 
61e1			 
61e1			;		cp 0 
61e1 b7					or a 
61e2 28 28				jr z, .bset 
61e4 fe 01				cp 1 
61e6 20 04				jr nz, .b2 
61e8 cb 81				res 0, c 
61ea 06 31				ld b, '1'    ; human readable bank number 
61ec fe 02		.b2:		cp 2 
61ee 20 04				jr nz, .b3 
61f0 cb 89				res 1, c 
61f2 06 32				ld b, '2'    ; human readable bank number 
61f4 fe 03		.b3:		cp 3 
61f6 20 04				jr nz, .b4 
61f8 cb 91				res 2, c 
61fa 06 33				ld b, '3'    ; human readable bank number 
61fc fe 04		.b4:		cp 4 
61fe 20 04				jr nz, .b5 
6200 cb 99				res 3, c 
6202 06 34				ld b, '4'    ; human readable bank number 
6204 fe 05		.b5:		cp 5 
6206 20 04				jr nz, .bset 
6208 cb a1				res 4, c 
620a 06 35				ld b, '5'    ; human readable bank number 
620c			 
620c			.bset: 
620c 79					ld a, c 
620d 32 92 f9				ld (spi_device),a 
6210 78					ld a, b 
6211 32 91 f9				ld (spi_device_id),a 
6214					if DEBUG_FORTH_WORDS 
6214						DMARK "BN2" 
6214 f5				push af  
6215 3a 29 62			ld a, (.dmark)  
6218 32 9d fd			ld (debug_mark),a  
621b 3a 2a 62			ld a, (.dmark+1)  
621e 32 9e fd			ld (debug_mark+1),a  
6221 3a 2b 62			ld a, (.dmark+2)  
6224 32 9f fd			ld (debug_mark+2),a  
6227 18 03			jr .pastdmark  
6229 ..			.dmark: db "BN2"  
622c f1			.pastdmark: pop af  
622d			endm  
# End of macro DMARK
622d						CALLMONITOR 
622d cd aa fd			call debug_vector  
6230				endm  
# End of macro CALLMONITOR
6230					endif 
6230			 
6230					; set default SPI clk pulse time as disabled for BANK use 
6230			 
6230 3e 00				ld a, 0 
6232 32 96 f9				ld (spi_clktime), a 
6235			 
6235					NEXTW 
6235 cd a7 fd			call parse_vector 
6238 c3 53 23			jp macro_next 
623b				endm 
# End of macro NEXTW
623b			 
623b			.CARTDEV: 
623b				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
623b 66				db WORD_SYS_CORE+82             
623c eb 62			dw .ENDDEVICE            
623e 08				db 7 + 1 
623f .. 00			db "CARTDEV",0              
6247				endm 
# End of macro CWHEAD
6247			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). | DONE 
6247			; | | Set to zero to disable devices. 
6247					if DEBUG_FORTH_WORDS_KEY 
6247						DMARK "CDV" 
6247 f5				push af  
6248 3a 5c 62			ld a, (.dmark)  
624b 32 9d fd			ld (debug_mark),a  
624e 3a 5d 62			ld a, (.dmark+1)  
6251 32 9e fd			ld (debug_mark+1),a  
6254 3a 5e 62			ld a, (.dmark+2)  
6257 32 9f fd			ld (debug_mark+2),a  
625a 18 03			jr .pastdmark  
625c ..			.dmark: db "CDV"  
625f f1			.pastdmark: pop af  
6260			endm  
# End of macro DMARK
6260						CALLMONITOR 
6260 cd aa fd			call debug_vector  
6263				endm  
# End of macro CALLMONITOR
6263					endif 
6263			 
6263					; disable se storage bank selection 
6263			 
6263 3e ff				ld a, SPI_CE_HIGH		; ce high 
6265 32 92 f9				ld (spi_device), a 
6268			 
6268					; get bank 
6268			 
6268					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6268 cd 6c 21			call macro_dsp_valuehl 
626b				endm 
# End of macro FORTH_DSP_VALUEHL
626b			 
626b			;		push hl 
626b			 
626b					; destroy value TOS 
626b			 
626b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
626b cd 24 22			call macro_forth_dsp_pop 
626e				endm 
# End of macro FORTH_DSP_POP
626e			 
626e					; one value on hl get other one back 
626e			 
626e			;		pop hl 
626e			 
626e					; active low 
626e			 
626e 0e ff				ld c, 255 
6270			 
6270 7d					ld a, l 
6271					if DEBUG_FORTH_WORDS 
6271						DMARK "CDV" 
6271 f5				push af  
6272 3a 86 62			ld a, (.dmark)  
6275 32 9d fd			ld (debug_mark),a  
6278 3a 87 62			ld a, (.dmark+1)  
627b 32 9e fd			ld (debug_mark+1),a  
627e 3a 88 62			ld a, (.dmark+2)  
6281 32 9f fd			ld (debug_mark+2),a  
6284 18 03			jr .pastdmark  
6286 ..			.dmark: db "CDV"  
6289 f1			.pastdmark: pop af  
628a			endm  
# End of macro DMARK
628a						CALLMONITOR 
628a cd aa fd			call debug_vector  
628d				endm  
# End of macro CALLMONITOR
628d					endif 
628d			;		cp 0 
628d b7					or a 
628e 28 30				jr z, .cset 
6290 fe 01				cp 1 
6292 20 02				jr nz, .c2 
6294 cb 81				res 0, c 
6296 fe 02		.c2:		cp 2 
6298 20 02				jr nz, .c3 
629a cb 89				res 1, c 
629c fe 03		.c3:		cp 3 
629e 20 02				jr nz, .c4 
62a0 cb 91				res 2, c 
62a2 fe 04		.c4:		cp 4 
62a4 20 02				jr nz, .c5 
62a6 cb 99				res 3, c 
62a8 fe 05		.c5:		cp 5 
62aa 20 02				jr nz, .c6 
62ac cb a1				res 4, c 
62ae fe 06		.c6:		cp 6 
62b0 20 02				jr nz, .c7 
62b2 cb a9				res 5, c 
62b4 fe 07		.c7:		cp 7 
62b6 20 02				jr nz, .c8 
62b8 cb b1				res 6, c 
62ba fe 08		.c8:		cp 8 
62bc 20 02				jr nz, .cset 
62be cb b9				res 7, c 
62c0 79			.cset:		ld a, c 
62c1 32 95 f9				ld (spi_cartdev),a 
62c4			 
62c4					if DEBUG_FORTH_WORDS 
62c4						DMARK "CD2" 
62c4 f5				push af  
62c5 3a d9 62			ld a, (.dmark)  
62c8 32 9d fd			ld (debug_mark),a  
62cb 3a da 62			ld a, (.dmark+1)  
62ce 32 9e fd			ld (debug_mark+1),a  
62d1 3a db 62			ld a, (.dmark+2)  
62d4 32 9f fd			ld (debug_mark+2),a  
62d7 18 03			jr .pastdmark  
62d9 ..			.dmark: db "CD2"  
62dc f1			.pastdmark: pop af  
62dd			endm  
# End of macro DMARK
62dd						CALLMONITOR 
62dd cd aa fd			call debug_vector  
62e0				endm  
# End of macro CALLMONITOR
62e0					endif 
62e0			 
62e0					; set default SPI clk pulse time as 10ms for CARTDEV use 
62e0			 
62e0 3e 0a				ld a, $0a 
62e2 32 96 f9				ld (spi_clktime), a 
62e5					NEXTW 
62e5 cd a7 fd			call parse_vector 
62e8 c3 53 23			jp macro_next 
62eb				endm 
# End of macro NEXTW
62eb			endif 
62eb			 
62eb			.ENDDEVICE: 
62eb			; eof 
62eb			 
# End of file forth_words_device.asm
62eb			 
62eb			; var handler 
62eb			 
62eb			 
62eb			.VARS: 
62eb				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
62eb 77				db WORD_SYS_CORE+99             
62ec 9f 63			dw .V0            
62ee 04				db 3 + 1 
62ef .. 00			db "VAR",0              
62f3				endm 
# End of macro CWHEAD
62f3			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
62f3			;| 
62f3			;| The variable name should consist of a single letter. e.g. "a" 
62f3			;! If a full string is passed then only the first char is looked at 
62f3			;| Any other char could exceed bounds checks!  
62f3			 
62f3					if DEBUG_FORTH_WORDS_KEY 
62f3						DMARK "VAR" 
62f3 f5				push af  
62f4 3a 08 63			ld a, (.dmark)  
62f7 32 9d fd			ld (debug_mark),a  
62fa 3a 09 63			ld a, (.dmark+1)  
62fd 32 9e fd			ld (debug_mark+1),a  
6300 3a 0a 63			ld a, (.dmark+2)  
6303 32 9f fd			ld (debug_mark+2),a  
6306 18 03			jr .pastdmark  
6308 ..			.dmark: db "VAR"  
630b f1			.pastdmark: pop af  
630c			endm  
# End of macro DMARK
630c						CALLMONITOR 
630c cd aa fd			call debug_vector  
630f				endm  
# End of macro CALLMONITOR
630f					endif 
630f			 
630f					FORTH_DSP_VALUEHL 
630f cd 6c 21			call macro_dsp_valuehl 
6312				endm 
# End of macro FORTH_DSP_VALUEHL
6312			 
6312 7e					ld a, (hl)    ; get first char on of the string 
6313			 
6313			 
6313					if DEBUG_FORTH_WORDS 
6313						DMARK "VR1" 
6313 f5				push af  
6314 3a 28 63			ld a, (.dmark)  
6317 32 9d fd			ld (debug_mark),a  
631a 3a 29 63			ld a, (.dmark+1)  
631d 32 9e fd			ld (debug_mark+1),a  
6320 3a 2a 63			ld a, (.dmark+2)  
6323 32 9f fd			ld (debug_mark+2),a  
6326 18 03			jr .pastdmark  
6328 ..			.dmark: db "VR1"  
632b f1			.pastdmark: pop af  
632c			endm  
# End of macro DMARK
632c						CALLMONITOR 
632c cd aa fd			call debug_vector  
632f				endm  
# End of macro CALLMONITOR
632f					endif 
632f					 
632f f5					push af	 
6330					FORTH_DSP_POP 
6330 cd 24 22			call macro_forth_dsp_pop 
6333				endm 
# End of macro FORTH_DSP_POP
6333 f1					pop af 
6334			 
6334					; convert to upper 
6334			 
6334 cd 14 12				call to_upper 
6337					if DEBUG_FORTH_WORDS 
6337						DMARK "Vaa" 
6337 f5				push af  
6338 3a 4c 63			ld a, (.dmark)  
633b 32 9d fd			ld (debug_mark),a  
633e 3a 4d 63			ld a, (.dmark+1)  
6341 32 9e fd			ld (debug_mark+1),a  
6344 3a 4e 63			ld a, (.dmark+2)  
6347 32 9f fd			ld (debug_mark+2),a  
634a 18 03			jr .pastdmark  
634c ..			.dmark: db "Vaa"  
634f f1			.pastdmark: pop af  
6350			endm  
# End of macro DMARK
6350						CALLMONITOR 
6350 cd aa fd			call debug_vector  
6353				endm  
# End of macro CALLMONITOR
6353					endif 
6353 06 41				ld b, 'A' 
6355 90					sub b			; set offset 
6356					if DEBUG_FORTH_WORDS 
6356						DMARK "Vbb" 
6356 f5				push af  
6357 3a 6b 63			ld a, (.dmark)  
635a 32 9d fd			ld (debug_mark),a  
635d 3a 6c 63			ld a, (.dmark+1)  
6360 32 9e fd			ld (debug_mark+1),a  
6363 3a 6d 63			ld a, (.dmark+2)  
6366 32 9f fd			ld (debug_mark+2),a  
6369 18 03			jr .pastdmark  
636b ..			.dmark: db "Vbb"  
636e f1			.pastdmark: pop af  
636f			endm  
# End of macro DMARK
636f						CALLMONITOR 
636f cd aa fd			call debug_vector  
6372				endm  
# End of macro CALLMONITOR
6372					endif 
6372 cb 27				sla a  
6374				 
6374					 
6374					if DEBUG_FORTH_WORDS 
6374						DMARK "VR2" 
6374 f5				push af  
6375 3a 89 63			ld a, (.dmark)  
6378 32 9d fd			ld (debug_mark),a  
637b 3a 8a 63			ld a, (.dmark+1)  
637e 32 9e fd			ld (debug_mark+1),a  
6381 3a 8b 63			ld a, (.dmark+2)  
6384 32 9f fd			ld (debug_mark+2),a  
6387 18 03			jr .pastdmark  
6389 ..			.dmark: db "VR2"  
638c f1			.pastdmark: pop af  
638d			endm  
# End of macro DMARK
638d						CALLMONITOR 
638d cd aa fd			call debug_vector  
6390				endm  
# End of macro CALLMONITOR
6390					endif 
6390			 
6390 21 26 f9				ld hl, cli_var_array2 
6393 cd ac 0f				call addatohl 
6396 cd 70 1f				call forth_push_numhl 
6399			 
6399			 
6399				       NEXTW 
6399 cd a7 fd			call parse_vector 
639c c3 53 23			jp macro_next 
639f				endm 
# End of macro NEXTW
639f			.V0: 
639f				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
639f 78				db WORD_SYS_CORE+100             
63a0 ba 63			dw .V0Q            
63a2 04				db 3 + 1 
63a3 .. 00			db "V0!",0              
63a7				endm 
# End of macro CWHEAD
63a7			;| V0! ( u1 -- )  Store value to v0  | DONE 
63a7			 
63a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
63a7 cd 6c 21			call macro_dsp_valuehl 
63aa				endm 
# End of macro FORTH_DSP_VALUEHL
63aa			 
63aa 11 5a f9				ld de, cli_var_array 
63ad			 
63ad eb					ex de, hl 
63ae 73					ld (hl), e 
63af 23					inc hl 
63b0 72					ld (hl), d 
63b1			 
63b1					; destroy value TOS 
63b1			 
63b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
63b1 cd 24 22			call macro_forth_dsp_pop 
63b4				endm 
# End of macro FORTH_DSP_POP
63b4			 
63b4				       NEXTW 
63b4 cd a7 fd			call parse_vector 
63b7 c3 53 23			jp macro_next 
63ba				endm 
# End of macro NEXTW
63ba			.V0Q: 
63ba				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
63ba 79				db WORD_SYS_CORE+101             
63bb ce 63			dw .V1S            
63bd 04				db 3 + 1 
63be .. 00			db "V0@",0              
63c2				endm 
# End of macro CWHEAD
63c2			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
63c2 2a 5a f9				ld hl, (cli_var_array) 
63c5 cd 70 1f				call forth_push_numhl 
63c8			 
63c8				       NEXTW 
63c8 cd a7 fd			call parse_vector 
63cb c3 53 23			jp macro_next 
63ce				endm 
# End of macro NEXTW
63ce			.V1S: 
63ce				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
63ce 7a				db WORD_SYS_CORE+102             
63cf e9 63			dw .V1Q            
63d1 04				db 3 + 1 
63d2 .. 00			db "V1!",0              
63d6				endm 
# End of macro CWHEAD
63d6			;| V1! ( u1 -- )  Store value to v1 | DONE 
63d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
63d6 cd 6c 21			call macro_dsp_valuehl 
63d9				endm 
# End of macro FORTH_DSP_VALUEHL
63d9			 
63d9 11 5c f9				ld de, cli_var_array+2 
63dc				 
63dc eb					ex de, hl 
63dd 73					ld (hl), e 
63de 23					inc hl 
63df 72					ld (hl), d 
63e0			 
63e0					; destroy value TOS 
63e0			 
63e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
63e0 cd 24 22			call macro_forth_dsp_pop 
63e3				endm 
# End of macro FORTH_DSP_POP
63e3				       NEXTW 
63e3 cd a7 fd			call parse_vector 
63e6 c3 53 23			jp macro_next 
63e9				endm 
# End of macro NEXTW
63e9			.V1Q: 
63e9				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
63e9 7b				db WORD_SYS_CORE+103             
63ea fd 63			dw .V2S            
63ec 04				db 3 + 1 
63ed .. 00			db "V1@",0              
63f1				endm 
# End of macro CWHEAD
63f1			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
63f1 2a 5c f9				ld hl, (cli_var_array+2) 
63f4 cd 70 1f				call forth_push_numhl 
63f7				       NEXTW 
63f7 cd a7 fd			call parse_vector 
63fa c3 53 23			jp macro_next 
63fd				endm 
# End of macro NEXTW
63fd			.V2S: 
63fd				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
63fd 7c				db WORD_SYS_CORE+104             
63fe 18 64			dw .V2Q            
6400 04				db 3 + 1 
6401 .. 00			db "V2!",0              
6405				endm 
# End of macro CWHEAD
6405			;| V2! ( u1 -- )  Store value to v2 | DONE 
6405					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6405 cd 6c 21			call macro_dsp_valuehl 
6408				endm 
# End of macro FORTH_DSP_VALUEHL
6408			 
6408 11 5e f9				ld de, cli_var_array+4 
640b				 
640b eb					ex de, hl 
640c 73					ld (hl), e 
640d 23					inc hl 
640e 72					ld (hl), d 
640f			 
640f					; destroy value TOS 
640f			 
640f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
640f cd 24 22			call macro_forth_dsp_pop 
6412				endm 
# End of macro FORTH_DSP_POP
6412				       NEXTW 
6412 cd a7 fd			call parse_vector 
6415 c3 53 23			jp macro_next 
6418				endm 
# End of macro NEXTW
6418			.V2Q: 
6418				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
6418 7d				db WORD_SYS_CORE+105             
6419 2c 64			dw .V3S            
641b 04				db 3 + 1 
641c .. 00			db "V2@",0              
6420				endm 
# End of macro CWHEAD
6420			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
6420 2a 5e f9				ld hl, (cli_var_array+4) 
6423 cd 70 1f				call forth_push_numhl 
6426				       NEXTW 
6426 cd a7 fd			call parse_vector 
6429 c3 53 23			jp macro_next 
642c				endm 
# End of macro NEXTW
642c			.V3S: 
642c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
642c 7c				db WORD_SYS_CORE+104             
642d 47 64			dw .V3Q            
642f 04				db 3 + 1 
6430 .. 00			db "V3!",0              
6434				endm 
# End of macro CWHEAD
6434			;| V3! ( u1 -- )  Store value to v3 | DONE 
6434					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6434 cd 6c 21			call macro_dsp_valuehl 
6437				endm 
# End of macro FORTH_DSP_VALUEHL
6437			 
6437 11 60 f9				ld de, cli_var_array+6 
643a				 
643a eb					ex de, hl 
643b 73					ld (hl), e 
643c 23					inc hl 
643d 72					ld (hl), d 
643e			 
643e					; destroy value TOS 
643e			 
643e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
643e cd 24 22			call macro_forth_dsp_pop 
6441				endm 
# End of macro FORTH_DSP_POP
6441				       NEXTW 
6441 cd a7 fd			call parse_vector 
6444 c3 53 23			jp macro_next 
6447				endm 
# End of macro NEXTW
6447			.V3Q: 
6447				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
6447 7d				db WORD_SYS_CORE+105             
6448 5b 64			dw .END            
644a 04				db 3 + 1 
644b .. 00			db "V3@",0              
644f				endm 
# End of macro CWHEAD
644f			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
644f 2a 60 f9				ld hl, (cli_var_array+6) 
6452 cd 70 1f				call forth_push_numhl 
6455				       NEXTW 
6455 cd a7 fd			call parse_vector 
6458 c3 53 23			jp macro_next 
645b				endm 
# End of macro NEXTW
645b			 
645b			 
645b			 
645b			 
645b			 
645b			; end of dict marker 
645b			 
645b 00			.END:    db WORD_SYS_END 
645c 00 00			dw 0 
645e 00				db 0 
645f			 
645f			; use to jp here for user dict words to save on macro expansion  
645f			 
645f			user_dict_next: 
645f				NEXTW 
645f cd a7 fd			call parse_vector 
6462 c3 53 23			jp macro_next 
6465				endm 
# End of macro NEXTW
6465			 
6465			 
6465			user_exec: 
6465				;    ld hl, <word code> 
6465				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
6465				;    call forthexec 
6465				;    jp user_dict_next   (NEXT) 
6465			        ;    <word code bytes> 
6465 eb				ex de, hl 
6466 2a f4 f3			ld hl,(os_tok_ptr) 
6469				 
6469				FORTH_RSP_NEXT 
6469 cd 17 1f			call macro_forth_rsp_next 
646c				endm 
# End of macro FORTH_RSP_NEXT
646c			 
646c			if DEBUG_FORTH_UWORD 
646c						DMARK "UEX" 
646c f5				push af  
646d 3a 81 64			ld a, (.dmark)  
6470 32 9d fd			ld (debug_mark),a  
6473 3a 82 64			ld a, (.dmark+1)  
6476 32 9e fd			ld (debug_mark+1),a  
6479 3a 83 64			ld a, (.dmark+2)  
647c 32 9f fd			ld (debug_mark+2),a  
647f 18 03			jr .pastdmark  
6481 ..			.dmark: db "UEX"  
6484 f1			.pastdmark: pop af  
6485			endm  
# End of macro DMARK
6485				CALLMONITOR 
6485 cd aa fd			call debug_vector  
6488				endm  
# End of macro CALLMONITOR
6488			endif 
6488			 
6488			 
6488			 
6488 eb				ex de, hl 
6489 22 f4 f3			ld (os_tok_ptr), hl 
648c				 
648c				; Don't use next - Skips the first word in uword. 
648c			 
648c c3 d4 23			jp exec1 
648f			;	NEXT 
648f			 
648f			 
648f			; eof 
# End of file forth_wordsv4.asm
648f			endif 
648f			;;;;;;;;;;;;;; Debug code 
648f			 
648f			 
648f			;if DEBUG_FORTH_PARSE 
648f .. 00		.nowordfound: db "No match",0 
6498 .. 00		.compword:	db "Comparing word ",0 
64a8 .. 00		.nextwordat:	db "Next word at",0 
64b5 .. 00		.charmatch:	db "Char match",0 
64c0			;endif 
64c0			if DEBUG_FORTH_JP 
64c0			.foundword:	db "Word match. Exec..",0 
64c0			endif 
64c0			;if DEBUG_FORTH_PUSH 
64c0 .. 00		.enddict:	db "Dict end. Push.",0 
64d0 .. 00		.push_str:	db "Pushing string",0 
64df .. 00		.push_num:	db "Pushing number",0 
64ee .. 00		.data_sp:	db "SP:",0 
64f2 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
6504 .. 00		.wordinde:	db "Word in DE (3/0):",0 
6516 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
6528			;endif 
6528			;if DEBUG_FORTH_MALLOC 
6528 .. 00		.push_malloc:	db "Malloc address",0 
6537			;endif 
6537			 
6537			 
6537			 
6537			; display malloc address and current data stack pointer  
6537			 
6537			malloc_error: 
6537 d5				push de 
6538 f5				push af 
6539 e5				push hl 
653a cd 7c 0d			call clear_display 
653d 11 5d 65			ld de, .mallocerr 
6540 3e 00			ld a,0 
6542			;	ld de,os_word_scratch 
6542 cd 8e 0d			call str_at_display 
6545 3e 11			ld a, display_row_1+17 
6547 11 9d fd			ld de, debug_mark 
654a cd 8e 0d			call str_at_display 
654d cd 9e 0d			call update_display 
6550				;call break_point_state 
6550 cd 3c 7a			call cin_wait 
6553			 
6553			;	ld a, ' ' 
6553			;	ld (os_view_disable), a 
6553 cd 81 18			call bp_on 
6556 e1				pop hl 
6557 f1				pop af 
6558 d1				pop de	 
6559				CALLMONITOR 
6559 cd aa fd			call debug_vector  
655c				endm  
# End of macro CALLMONITOR
655c c9				ret 
655d			 
655d .. 00		.mallocerr: 	db "Malloc Error",0 
656a			;if DEBUG_FORTH_PUSH 
656a			display_data_sp: 
656a f5				push af 
656b			 
656b				; see if disabled 
656b			 
656b			 
656b 3a aa fd			ld a, (debug_vector) 
656e fe c9			cp $C9  ; RET 
6570				;ld a, (os_view_disable) 
6570				;cp '*' 
6570 28 65			jr z, .skipdsp 
6572			 
6572 e5				push hl 
6573 e5				push hl 
6574 e5			push hl 
6575 cd 7c 0d			call clear_display 
6578 e1			pop hl 
6579 7c				ld a,h 
657a 21 f8 f3			ld hl, os_word_scratch 
657d cd a8 11			call hexout 
6580 e1				pop hl 
6581 7d				ld a,l 
6582 21 fa f3			ld hl, os_word_scratch+2 
6585 cd a8 11			call hexout 
6588 21 fc f3			ld hl, os_word_scratch+4 
658b			;	ld a,0 
658b 36 00			ld (hl),0 
658d 11 f8 f3			ld de,os_word_scratch 
6590 3e 28				ld a, display_row_2 
6592 cd 8e 0d				call str_at_display 
6595 11 f2 64			ld de, .wordinhl 
6598 3e 00			ld a, display_row_1 
659a			 
659a cd 8e 0d				call str_at_display 
659d 11 9d fd			ld de, debug_mark 
65a0 3e 11			ld a, display_row_1+17 
65a2			 
65a2 cd 8e 0d				call str_at_display 
65a5			 
65a5				; display current data stack pointer 
65a5 11 ee 64			ld de,.data_sp 
65a8 3e 30				ld a, display_row_2 + 8 
65aa cd 8e 0d				call str_at_display 
65ad			 
65ad 2a 20 f9			ld hl,(cli_data_sp) 
65b0 e5				push hl 
65b1 7c				ld a,h 
65b2 21 f8 f3			ld hl, os_word_scratch 
65b5 cd a8 11			call hexout 
65b8 e1				pop hl 
65b9 7d				ld a,l 
65ba 21 fa f3			ld hl, os_word_scratch+2 
65bd cd a8 11			call hexout 
65c0 21 fc f3			ld hl, os_word_scratch+4 
65c3			;	ld a,0 
65c3 36 00			ld (hl),0 
65c5 11 f8 f3			ld de,os_word_scratch 
65c8 3e 33				ld a, display_row_2 + 11 
65ca cd 8e 0d				call str_at_display 
65cd			 
65cd			 
65cd cd 9e 0d			call update_display 
65d0 cd c0 0c			call delay1s 
65d3 cd c0 0c			call delay1s 
65d6 e1				pop hl 
65d7			.skipdsp: 
65d7 f1				pop af 
65d8 c9				ret 
65d9			 
65d9			display_data_malloc: 
65d9			 
65d9 f5				push af 
65da e5				push hl 
65db e5				push hl 
65dc e5			push hl 
65dd cd 7c 0d			call clear_display 
65e0 e1			pop hl 
65e1 7c				ld a,h 
65e2 21 f8 f3			ld hl, os_word_scratch 
65e5 cd a8 11			call hexout 
65e8 e1				pop hl 
65e9 7d				ld a,l 
65ea 21 fa f3			ld hl, os_word_scratch+2 
65ed cd a8 11			call hexout 
65f0 21 fc f3			ld hl, os_word_scratch+4 
65f3			;	ld a,0 
65f3 36 00			ld (hl),0 
65f5 11 f8 f3			ld de,os_word_scratch 
65f8 3e 28				ld a, display_row_2 
65fa cd 8e 0d				call str_at_display 
65fd 11 28 65			ld de, .push_malloc 
6600 3e 00			ld a, display_row_1 
6602			 
6602 cd 8e 0d				call str_at_display 
6605			 
6605				; display current data stack pointer 
6605 11 ee 64			ld de,.data_sp 
6608 3e 30				ld a, display_row_2 + 8 
660a cd 8e 0d				call str_at_display 
660d			 
660d 2a 20 f9			ld hl,(cli_data_sp) 
6610 e5				push hl 
6611 7c				ld a,h 
6612 21 f8 f3			ld hl, os_word_scratch 
6615 cd a8 11			call hexout 
6618 e1				pop hl 
6619 7d				ld a,l 
661a 21 fa f3			ld hl, os_word_scratch+2 
661d cd a8 11			call hexout 
6620 21 fc f3			ld hl, os_word_scratch+4 
6623			;	ld a,0 
6623 36 00			ld (hl),0 
6625 11 f8 f3			ld de,os_word_scratch 
6628 3e 33				ld a, display_row_2 + 11 
662a cd 8e 0d				call str_at_display 
662d			 
662d cd 9e 0d			call update_display 
6630 cd c0 0c			call delay1s 
6633 cd c0 0c			call delay1s 
6636 e1				pop hl 
6637 f1				pop af 
6638 c9				ret 
6639			;endif 
6639			 
6639			include "forth_autostart.asm" 
6639			; list of commands to perform at system start up 
6639			 
6639			startcmds: 
6639			;	dw test11 
6639			;	dw test12 
6639			;	dw test13 
6639			;	dw test14 
6639			;	dw test15 
6639			;	dw test16 
6639			;	dw test17 
6639			;	dw ifthtest1 
6639			;	dw ifthtest2 
6639			;	dw ifthtest3 
6639			;	dw mmtest1 
6639			;	dw mmtest2 
6639			;	dw mmtest3 
6639			;	dw mmtest4 
6639			;	dw mmtest5 
6639			;	dw mmtest6 
6639			;	dw iftest1 
6639			;	dw iftest2 
6639			;	dw iftest3 
6639			;	dw looptest1 
6639			;	dw looptest2 
6639			;	dw test1 
6639			;	dw test2 
6639			;	dw test3 
6639			;	dw test4 
6639			;	dw game2r 
6639			;	dw game2b1 
6639			;	dw game2b2 
6639			 
6639				; start up words that are actually useful 
6639			 
6639			;    dw spi1 
6639			;    dw spi2 
6639			;    dw spi3 
6639			;    dw spi4 
6639			;    dw spi5 
6639			;    dw spi6 
6639			;    dw spi7 
6639			; 
6639			;    dw spi8 
6639			;    dw spi9 
6639			;    dw spi10 
6639			 
6639			; file editor 
6639			;	dw edit1 
6639			;	dw edit2 
6639			;	dw edit3 
6639			 
6639			;	dw longread 
6639 5b 6a			dw clrstack 
663b 8f 6a			dw type 
663d			;	dw stest 
663d b4 6a			dw strncpy 
663f 24 6c			dw list 
6641 15 6b			dw start1 
6643 25 6b			dw start2 
6645			;	dw start3 
6645			;	dw start3b 
6645			;	dw start3c 
6645			 
6645				; (unit) testing words 
6645			 
6645			;	dw mtesta 
6645			;	dw mtestb 
6645			;	dw mtestc 
6645			;	dw mtestd 
6645			;	dw mteste 
6645			 
6645				; demo/game words 
6645			 
6645			;        dw game3w 
6645			;        dw game3p 
6645			;        dw game3sc 
6645			;        dw game3vsi 
6645			;        dw game3vs 
6645				 
6645			;	dw game2b 
6645			;	dw game2bf 
6645			;	dw game2mba 
6645			;	dw game2mbas 
6645			;	dw game2mb 
6645			 
6645 55 6e			dw game1 
6647 66 6e			dw game1a 
6649 c8 6e			dw game1b 
664b fd 6e			dw game1c 
664d 33 6f			dw game1d 
664f 64 6f			dw game1s 
6651 78 6f			dw game1t 
6653 8d 6f			dw game1f 
6655 c1 6f			dw game1z 
6657 05 70			dw game1zz 
6659			 
6659 8e 6c			dw test5 
665b c6 6c			dw test6 
665d fe 6c			dw test7 
665f 12 6d			dw test8 
6661 3e 6d			dw test9 
6663 54 6d			dw test10 
6665				 
6665 dc 70		        dw ssv5 
6667 c0 70		        dw ssv4 
6669 a4 70		        dw ssv3 
666b 6e 70		        dw ssv2 
666d f5 70		        dw ssv1 
666f 3d 71		        dw ssv1cpm 
6671			;	dw keyup 
6671			;	dw keydown 
6671			;	dw keyleft 
6671			;	dw keyright 
6671			;	dw 	keyf1 
6671			;	dw keyf2 
6671			;	dw keyf3 
6671			;	dw keyf4 
6671			;	dw keyf5 
6671			;	dw keyf6 
6671			;	dw keyf7 
6671			;	dw keyf8 
6671			;	dw keyf9 
6671			;	dw keyf10 
6671			;	dw keyf11 
6671			;	dw keyf12 
6671			;	dw keytab 
6671			;	dw keycr 
6671			;	dw keyhome 
6671			;	dw keyend 
6671			;	dw keybs 
6671 00 00			db 0, 0	 
6673			 
6673			 
6673			; File Editor 
6673			 
6673			; ( id - ) use 'e' to edit the displayed line 
6673 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
6694 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
66c9			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
66c9 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
6701			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
6701			 
6701			; SPI Net support words 
6701			 
6701			; v0! = node to send to 
6701			; ( str count - ) 
6701 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
675a			 
675a			; spiputc ( char node - ) 
675a .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
678e			; spiputc ( u node - ) 
678e .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
67bc			 
67bc			; spigetc ( - n ) 
67bc .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
67e5			 
67e5			; getnode ( - n ) 
67e5 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6812			 
6812			; ( str node - )  
6812 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6878			; store string ( str i - ) 
6878			 
6878			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6878 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
68cd			 
68cd			; get string ( addr i -  )    TO FIX 
68cd			 
68cd .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6925			 
6925			 
6925			; NETCHAT (TODO) 
6925			; Program to allow two nodes to chat with eachother 
6925			; 
6925			; v0 - target node 
6925			;  
6925			; accept input at 0,0 
6925			; if input is string send spitype to target node 
6925			; starting at row 2,0 , while spigetchr is not zero ->  
6925			; 
6925			; 
6925			; TODO add paging of get request 
6925			 
6925			; ( node - ) 
6925 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6944 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
699c .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6a14			 
6a14			 
6a14			; Long read of currently open file 
6a14 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6a5b			 
6a5b			; clear stack  
6a5b			 
6a5b .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
6a8f			 
6a8f			; type ( addr count - ) 
6a8f .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6ab4			 
6ab4			; some direct memory words 
6ab4			; strncpy ( len t f -- t ) 
6ab4			 
6ab4 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6b15			 
6b15 .. 00		start1:     	db ": bpon $00 bp ;",0 
6b25 .. 00		start2:     	db ": bpoff $01 bp ;",0 
6b36 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6bb1 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6c11			 
6c11 .. 00		tuck:         db ": tuck swap over ;", 0 
6c24			 
6c24			; a handy word to list items on the stack 
6c24			 
6c24 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6c8e			 
6c8e			 
6c8e			; test stack  
6c8e			; rnd8 stest 
6c8e			 
6c8e			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6c8e			 
6c8e			; random malloc and free cycles 
6c8e			 
6c8e			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6c8e			 
6c8e			; fixed malloc and free cycles 
6c8e			 
6c8e			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6c8e			 
6c8e			; fixed double string push and drop cycle  
6c8e			 
6c8e			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6c8e			 
6c8e			; consistent fixed string push and drop cycle  
6c8e			 
6c8e			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6c8e			 
6c8e			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6c8e			 
6c8e			;test1:		db ": aa 1 2 3 ;", 0 
6c8e			;test2:     	db "111 aa 888 999",0 
6c8e			;test3:     	db ": bb 77 ;",0 
6c8e			;test4:     	db "$02 $01 do i . loop bb",0 
6c8e			 
6c8e .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6cc6 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6cfe .. 00		test7:     	db ": box hline vline ;",0 
6d12 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6d3e .. 00		test9:     	db ": sw $01 adsp world ;",0 
6d54 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6d79			;test11:     	db "hello create .",0 
6d79			;test12:     	db "hello2 create .",0 
6d79			 
6d79			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6d79			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6d79			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6d79			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6d79			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6d79			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6d79			 
6d79			;iftest1:     	db "$0001 IF cls .",0 
6d79			;iftest2:     	db "$0000 IF cls .",0 
6d79			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6d79			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6d79			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6d79			 
6d79			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6d79			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6d79			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6d79			 
6d79			 
6d79 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6d9d .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6dcd .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6df2 .. 00		sound4: db ": cha $00 ; ",0 
6dff .. 00		sound5: db ": chb $20 ; ",0 
6e0c .. 00		sound6: db ": chc $40 ; ",0 
6e19 .. 00		sound7: db ": chd $60 ; ",0 
6e26 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6e3e .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6e55			 
6e55			 
6e55			 
6e55			 
6e55			; a small guess the number game 
6e55			 
6e55 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6e66 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6ec8			 
6ec8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6efd .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6f33 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6f64 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6f78 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6f8d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6fc1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
7005			 
7005			; Using 'ga' save a high score across multiple runs using external storage 
7005			 
7005 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
706e			 
706e			 
706e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
706e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
706e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
706e			 
706e			; simple screen saver to test code memory reuse to destruction 
706e			 
706e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
70a4 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
70c0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
70dc .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
70f5 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
713d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
7194			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
7194			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
7194			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
7194			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
7194			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
7194			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
7194			 
7194			 
7194			 
7194			; minesweeper/battleship finding game 
7194			; draws a game board of random ship/mine positions 
7194			; user enters coords to see if it hits on 
7194			; game ends when all are hit 
7194			; when hit or miss says how many may be in the area 
7194			 
7194			; setup the game board and then hide it 
7194			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
7194			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
7194			;; prompt for where to target 
7194			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
7194			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
7194			;; TODO see if the entered coords hits or misses pushes char hit of miss 
7194			;game2mbht:      db ": mbckht nop ;",0 
7194			;game2mbms:      db ": mbcms nop ;",0 
7194			; TODO how many might be near by 
7194			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
7194			 
7194			; Game 3 
7194			 
7194			; Vert scroller ski game - avoid the trees! 
7194			 
7194			; v0 score (ie turns) 
7194			; v1 player pos 
7194			; v2 left wall 
7194			; v3 right wall 
7194			 
7194			; Draw side walls randomly 
7194			 
7194			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7194			 
7194			; Draw player 
7194			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7194			 
7194			; TODO Get Key 
7194			 
7194			; TODO Move left right 
7194			 
7194			; scroll and move walls a bit 
7194			 
7194			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
7194			 
7194			; main game loop 
7194			 
7194			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
7194			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7194			 
7194			; key board defs 
7194			 
7194 .. 00		keyup:       db ": keyup $05 ;",0 
71a2 .. 00		keydown:       db ": keydown $0a ;",0 
71b2 .. 00		keyleft:       db ": keyleft $0b ;",0 
71c2 .. 00		keyright:       db ": keyright $0c ;",0 
71d3 .. 00		keyf1:       db ": keyf1 $10 ;",0 
71e1 .. 00		keyf2:       db ": keyf2 $11 ;",0 
71ef .. 00		keyf3:       db ": keyf3 $12 ;",0 
71fd .. 00		keyf4:       db ": keyf4 $13 ;",0 
720b .. 00		keyf5:       db ": keyf5 $14 ;",0 
7219 .. 00		keyf6:       db ": keyf6 $15 ;",0 
7227 .. 00		keyf7:       db ": keyf7 $16 ;",0 
7235 .. 00		keyf8:       db ": keyf8 $17 ;",0 
7243 .. 00		keyf9:       db ": keyf9 $18 ;",0 
7251 .. 00		keyf10:       db ": keyf10 $19 ;",0 
7260 .. 00		keyf11:       db ": keyf11 $1a ;",0 
726f .. 00		keyf12:       db ": keyf12 $1b ;",0 
727e			 
727e .. 00		keytab:       db ": keytab $09 ;",0 
728d .. 00		keycr:       db ": keycr $0d ;",0 
729b .. 00		keyhome:       db ": keyhome $0e ;",0 
72ab .. 00		keyend:       db ": keyend $0f ;",0 
72ba .. 00		keybs:       db ": keybs $08 ;",0 
72c8			 
72c8			   
72c8			 
72c8			 
72c8			 
72c8			; eof 
# End of file forth_autostart.asm
72c8			 
72c8			 
72c8			 
72c8			; stack over and underflow checks 
72c8			 
72c8			; init the words to detect the under/overflow 
72c8			 
72c8			chk_stk_init: 
72c8				; a vague random number to check so we dont get any "lucky" hits 
72c8 3e 2d			ld a, 45 
72ca 6f				ld l, a 
72cb 00				nop 
72cc 3e 17			ld a, 23 
72ce 67				ld h, a 
72cf			 
72cf 22 cf f0			ld (chk_word), hl     ; the word we need to check against 
72d2			 
72d2			;	ld (chk_stund), hl	; stack points.... 
72d2 22 3b fe			ld (chk_stovr), hl 
72d5 22 1e f9			ld (chk_ret_und), hl 
72d8 22 dc f8			ld (chk_ret_ovr), hl 
72db 22 5a f8			ld (chk_loop_ovr), hl 
72de 22 58 f6			ld (chk_data_ovr), hl 
72e1 c9				ret 
72e2				 
72e2			check_stacks: 
72e2				; check all stack words 
72e2			 
72e2 e5				push hl 
72e3 d5				push de 
72e4			 
72e4			;	ld de,(chk_word) 
72e4			;	ld hl, (chk_stund)	; stack points.... 
72e4			;	if DEBUG_STK_FAULT 
72e4			;		DMARK "FAa" 
72e4			;		CALLMONITOR 
72e4			;	endif 
72e4			;	call cmp16 
72e4			;	jp z, .chk_faulta 
72e4			; 
72e4			;	ld de, sfaultsu 
72e4			;	jp .chk_fault 
72e4			 
72e4 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
72e7 ed 5b cf f0		ld de,(chk_word) 
72eb				if DEBUG_STK_FAULT 
72eb					DMARK "FAb" 
72eb					CALLMONITOR 
72eb				endif 
72eb cd ca 0f			call cmp16 
72ee 28 06			jr z, .chk_fault1 
72f0 11 94 73			ld de, sfaultso 
72f3 c3 45 73			jp .chk_fault 
72f6			.chk_fault1:  
72f6 2a 1e f9			ld hl, (chk_ret_und) 
72f9 ed 5b cf f0		ld de,(chk_word) 
72fd				if DEBUG_STK_FAULT 
72fd					DMARK "FAU" 
72fd					CALLMONITOR 
72fd				endif 
72fd cd ca 0f			call cmp16 
7300 ca 09 73			jp z, .chk_fault2 
7303 11 a4 73			ld de, sfaultru 
7306 c3 45 73			jp .chk_fault 
7309			.chk_fault2:  
7309 2a dc f8			ld hl, (chk_ret_ovr) 
730c ed 5b cf f0		ld de,(chk_word) 
7310				if DEBUG_STK_FAULT 
7310					DMARK "FA1" 
7310					CALLMONITOR 
7310				endif 
7310 cd ca 0f			call cmp16 
7313 ca 1c 73			jp z, .chk_fault3 
7316 11 b2 73			ld de, sfaultro 
7319 c3 45 73			jp .chk_fault 
731c			.chk_fault3:  
731c 2a 5a f8			ld hl, (chk_loop_ovr) 
731f ed 5b cf f0		ld de,(chk_word) 
7323				if DEBUG_STK_FAULT 
7323					DMARK "FA2" 
7323					CALLMONITOR 
7323				endif 
7323 cd ca 0f			call cmp16 
7326 ca 2f 73			jp z, .chk_fault4 
7329 11 cc 73			ld de, sfaultlo 
732c c3 45 73			jp .chk_fault 
732f			.chk_fault4:  
732f 2a 58 f6			ld hl, (chk_data_ovr) 
7332 ed 5b cf f0		ld de,(chk_word) 
7336				if DEBUG_STK_FAULT 
7336					DMARK "FA3" 
7336					CALLMONITOR 
7336				endif 
7336 cd ca 0f			call cmp16 
7339 ca 42 73			jp z, .chk_fault5 
733c 11 e6 73			ld de, sfaultdo 
733f c3 45 73			jp .chk_fault 
7342			 
7342			 
7342			.chk_fault5:  
7342 d1				pop de 
7343 e1				pop hl 
7344			 
7344 c9				ret 
7345			 
7345 cd 7c 0d		.chk_fault: 	call clear_display 
7348 3e 28				ld a, display_row_2 
734a cd 8e 0d				call str_at_display 
734d 11 76 73				   ld de, .stackfault 
7350 3e 00				ld a, display_row_1 
7352 cd 8e 0d				call str_at_display 
7355 11 9d fd				    ld de, debug_mark 
7358 3e 11				ld a, display_row_1+17 
735a cd 8e 0d				call str_at_display 
735d cd 9e 0d				call update_display 
7360			 
7360				; prompt before entering montior for investigating issue 
7360			 
7360 3e 78			ld a, display_row_4 
7362 11 52 1c			ld de, endprog 
7365			 
7365 cd 9e 0d			call update_display		 
7368			 
7368 cd e8 1e			call next_page_prompt 
736b			 
736b d1				pop de 
736c e1				pop hl 
736d cd a6 1c				call monitor 
7370 cd f9 22				call forth_warmstart 
7373 c3 a4 1b				jp warmstart_afterauto 
7376					;jp 0 
7376					;halt 
7376			 
7376			 
7376			 
7376 .. 00		.stackfault: 	db "Stack fault:",0 
7383			 
7383 .. 00		sfaultsu: 	db	"Stack under flow",0 
7394 .. 00		sfaultso: 	db	"Stack over flow",0 
73a4 .. 00		sfaultru:	db "RTS underflow",0 
73b2 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
73cc .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
73e6 .. 00		sfaultdo:	db "DTS overflow", 0 
73f3			 
73f3			 
73f3			fault_dsp_under: 
73f3 11 05 74			ld de, .dsp_under 
73f6 c3 bb 74			jp .show_fault 
73f9			 
73f9			fault_rsp_under: 
73f9 11 13 74			ld de, .rsp_under 
73fc c3 bb 74			jp .show_fault 
73ff			fault_loop_under: 
73ff 11 21 74			ld de, .loop_under 
7402 c3 bb 74			jp .show_fault 
7405			 
7405 .. 00		.dsp_under: db "DSP Underflow",0 
7413 .. 00		.rsp_under: db "RSP Underflow",0 
7421 .. 00		.loop_under: db "LOOP Underflow",0 
7430			 
7430			 
7430 d5			type_faultn: 	push de 
7431 e5					push hl 
7432 cd 7c 0d				call clear_display 
7435 11 5f 74				   ld de, .typefaultn 
7438 3e 00				ld a, display_row_1 
743a cd 8e 0d				call str_at_display 
743d 11 9d fd				    ld de, debug_mark 
7440 3e 11				ld a, display_row_1+17 
7442 cd 8e 0d				call str_at_display 
7445 cd 9e 0d				call update_display 
7448			 
7448				; prompt before entering montior for investigating issue 
7448			 
7448 3e 78			ld a, display_row_4 
744a 11 52 1c			ld de, endprog 
744d			 
744d cd 9e 0d			call update_display		 
7450			 
7450 cd e8 1e			call next_page_prompt 
7453			 
7453 e5					push hl 
7454 d5					push de 
7455 cd a6 1c				call monitor 
7458 cd f9 22				call forth_warmstart 
745b c3 a4 1b				jp warmstart_afterauto 
745e 76					halt 
745f			 
745f			 
745f .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7476			 
7476 d5			type_faults: 	push de 
7477 e5					push hl 
7478 cd 7c 0d				call clear_display 
747b 11 a4 74				   ld de, .typefaults 
747e 3e 00				ld a, display_row_1 
7480 cd 8e 0d				call str_at_display 
7483 11 9d fd				    ld de, debug_mark 
7486 3e 11				ld a, display_row_1+17 
7488 cd 8e 0d				call str_at_display 
748b cd 9e 0d				call update_display 
748e			 
748e				; prompt before entering montior for investigating issue 
748e			 
748e 3e 78			ld a, display_row_4 
7490 11 52 1c			ld de, endprog 
7493			 
7493 cd 9e 0d			call update_display		 
7496			 
7496 cd e8 1e			call next_page_prompt 
7499			 
7499 e1					pop hl 
749a d1					pop de 
749b cd a6 1c				call monitor 
749e cd f9 22				call forth_warmstart 
74a1 c3 a4 1b				jp warmstart_afterauto 
74a4			 
74a4			 
74a4 .. 00		.typefaults: db "STR Type Expected TOS!",0 
74bb			 
74bb			.show_fault: 	 
74bb d5					push de 
74bc cd 7c 0d				call clear_display 
74bf d1					pop de 
74c0 3e 00				ld a, display_row_1 
74c2 cd 8e 0d				call str_at_display 
74c5 11 9d fd				    ld de, debug_mark 
74c8 3e 11				ld a, display_row_1+17 
74ca cd 8e 0d				call str_at_display 
74cd cd 9e 0d				call update_display 
74d0			 
74d0				; prompt before entering montior for investigating issue 
74d0			 
74d0 3e 78			ld a, display_row_4 
74d2 11 52 1c			ld de, endprog 
74d5			 
74d5 cd 9e 0d			call update_display		 
74d8			 
74d8 cd e8 1e			call next_page_prompt 
74db			 
74db e1					pop hl 
74dc d1					pop de 
74dd cd a6 1c				call monitor 
74e0			; do a dump to cli and not warmstart so we preserve all of the uwords.  
74e0			; TODO Make optional fault restart to cli or warm boot? 
74e0					;jp warmstart 
74e0 c3 e7 1b				jp cli 
74e3 76					halt 
74e4			 
74e4			 
74e4			; handle the auto run of code from files in storage 
74e4			 
74e4			 
74e4			include "forth_startup.asm" 
74e4			; Which startup method to use? 
74e4			; 
74e4			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
74e4			; followed by loading of a list of scripts in eeprom 
74e4			 
74e4			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
74e4			; from eeprom 
74e4			 
74e4			; Select with define in main stubs 
74e4			 
74e4			if STARTUP_V1 
74e4				include "forth_startupv1.asm" 
74e4			endif 
74e4			if STARTUP_V2 
74e4				include "forth_startupv2.asm" 
74e4			; Version 2 of the startup  
74e4			;  
74e4			; Auto load any files in bank 1 that start with a '*' 
74e4			; If no se storage then revert to using eprom 
74e4			 
74e4			 
74e4			if STORAGE_SE = 0 
74e4			 
74e4			sprompt1: db "Startup load...",0 
74e4			sprompt2: db "Run? 1=No *=End #=All",0 
74e4			 
74e4			 
74e4			 
74e4			 
74e4			forth_startup: 
74e4				ld hl, startcmds 
74e4				ld a, 0 
74e4				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
74e4			 
74e4			.start1:	push hl 
74e4				call clear_display 
74e4				ld de, sprompt1 
74e4			        ld a, display_row_1 
74e4				call str_at_display 
74e4				ld de, sprompt2 
74e4			        ld a, display_row_2 
74e4				call str_at_display 
74e4				pop hl 
74e4				push hl 
74e4				ld e,(hl) 
74e4				inc hl 
74e4				ld d,(hl) 
74e4			        ld a, display_row_3 
74e4				call str_at_display 
74e4				call update_display 
74e4			 
74e4			 
74e4				ld a, (os_last_cmd) 
74e4			;	cp 0 
74e4				or a 
74e4				jr z, .startprompt 
74e4				call delay250ms 
74e4				jr .startdo 
74e4				 
74e4				 
74e4			 
74e4			.startprompt: 
74e4			 
74e4				ld a,display_row_4 + display_cols - 1 
74e4			        ld de, endprg 
74e4				call str_at_display 
74e4				call update_display 
74e4				call delay1s 
74e4				call cin_wait 
74e4						 
74e4				cp '*' 
74e4				jr z, .startupend1 
74e4				cp '#' 
74e4				jr nz, .startno 
74e4				ld a, 1 
74e4				ld (os_last_cmd),a 
74e4				jr .startdo 
74e4			.startno:	cp '1' 
74e4				jr z,.startnxt  
74e4			 
74e4				; exec startup line 
74e4			.startdo:	 
74e4				pop hl 
74e4				push hl 
74e4				 
74e4				ld e,(hl) 
74e4				inc hl 
74e4				ld d,(hl) 
74e4				ex de,hl 
74e4			 
74e4				push hl 
74e4			 
74e4				ld a, 0 
74e4				;ld a, FORTH_END_BUFFER 
74e4				call strlent 
74e4				inc hl   ; include zero term to copy 
74e4				ld b,0 
74e4				ld c,l 
74e4				pop hl 
74e4				ld de, scratch 
74e4				ldir 
74e4			 
74e4			 
74e4				ld hl, scratch 
74e4				call forthparse 
74e4				call forthexec 
74e4				call forthexec_cleanup 
74e4			 
74e4				ld a, display_row_4 
74e4				ld de, endprog 
74e4			 
74e4				call update_display		 
74e4			 
74e4				ld a, (os_last_cmd) 
74e4			;	cp 0 
74e4				or a 
74e4				jr nz, .startnxt 
74e4				call next_page_prompt 
74e4			        call clear_display 
74e4				call update_display		 
74e4			 
74e4				; move onto next startup line? 
74e4			.startnxt: 
74e4			 
74e4				call delay250ms 
74e4				pop hl 
74e4			 
74e4				inc hl 
74e4				inc hl 
74e4			 
74e4				push hl 
74e4				ld e, (hl) 
74e4				inc hl 
74e4				ld d, (hl) 
74e4				pop hl 
74e4				; TODO replace 0 test 
74e4			 
74e4				ex de, hl 
74e4				call ishlzero 
74e4			;	ld a,e 
74e4			;	add d 
74e4			;	cp 0    ; any left to do? 
74e4				ex de, hl 
74e4				jp nz, .start1 
74e4				jr .startupend 
74e4			 
74e4			.startupend1: pop hl 
74e4			.startupend: 
74e4			 
74e4				call clear_display 
74e4				call update_display 
74e4				ret 
74e4			endif 
74e4			 
74e4			 
74e4			if STORAGE_SE 
74e4			 
74e4			;sprompt3: db "Loading from start-up file:",0 
74e4 .. 00		sprompt3: db "  Searching...",0 
74f3			;sprompt4: db "(Any key to stop)",0 
74f3			 
74f3			 
74f3			forth_autoload: 
74f3			 
74f3				; load block 0 of store 1 
74f3				 
74f3 3e fe			ld a, $fe      ; bit 0 clear 
74f5 32 92 f9			ld (spi_device), a 
74f8			 
74f8 cd 05 05			call storage_get_block_0 
74fb			 
74fb 3a cd f9			ld a, (store_page+STORE_0_AUTOFILE) 
74fe			 
74fe			;	cp 0 
74fe b7				or a 
74ff c8				ret z     ; auto start not enabled 
7500			 
7500 cd 7c 0d			call clear_display 
7503			 
7503				; set bank 
7503			 
7503 3a cf f9				ld a, (store_page+STORE_0_BANKRUN) 
7506 32 92 f9				ld (spi_device), a 
7509			 
7509			 
7509				; generate a directory of bank 1 and search for flagged files 
7509			 
7509					if DEBUG_FORTH_WORDS_KEY 
7509						DMARK "DIR" 
7509 f5				push af  
750a 3a 1e 75			ld a, (.dmark)  
750d 32 9d fd			ld (debug_mark),a  
7510 3a 1f 75			ld a, (.dmark+1)  
7513 32 9e fd			ld (debug_mark+1),a  
7516 3a 20 75			ld a, (.dmark+2)  
7519 32 9f fd			ld (debug_mark+2),a  
751c 18 03			jr .pastdmark  
751e ..			.dmark: db "DIR"  
7521 f1			.pastdmark: pop af  
7522			endm  
# End of macro DMARK
7522						CALLMONITOR 
7522 cd aa fd			call debug_vector  
7525				endm  
# End of macro CALLMONITOR
7525					endif 
7525			 
7525 cd 05 05			call storage_get_block_0 
7528			 
7528 21 ac f9			ld hl, store_page     ; get current id count 
752b 46				ld b, (hl) 
752c 0e 00			ld c, 0    ; count of files   
752e					if DEBUG_FORTH_WORDS 
752e						DMARK "DI1" 
752e f5				push af  
752f 3a 43 75			ld a, (.dmark)  
7532 32 9d fd			ld (debug_mark),a  
7535 3a 44 75			ld a, (.dmark+1)  
7538 32 9e fd			ld (debug_mark+1),a  
753b 3a 45 75			ld a, (.dmark+2)  
753e 32 9f fd			ld (debug_mark+2),a  
7541 18 03			jr .pastdmark  
7543 ..			.dmark: db "DI1"  
7546 f1			.pastdmark: pop af  
7547			endm  
# End of macro DMARK
7547						CALLMONITOR 
7547 cd aa fd			call debug_vector  
754a				endm  
# End of macro CALLMONITOR
754a					endif 
754a			 
754a				; check for empty drive 
754a			 
754a 3e 00			ld a, 0 
754c b8				cp b 
754d ca 9a 75			jp z, .dirdone 
7550			 
7550				; for each of the current ids do a search for them and if found push to stack 
7550			 
7550 c5			.diritem:	push bc 
7551 21 40 00				ld hl, STORE_BLOCK_PHY 
7554 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
7556 58					ld e,b 
7557			 
7557 d5					push de 
7558 e5					push hl 
7559 cd 7c 0d			call clear_display 
755c 3e 32			ld a, display_row_2 + 10 
755e 11 e4 74			ld de, sprompt3 
7561 cd 8e 0d			call str_at_display 
7564 cd d4 0c			call active 
7567 eb				ex de, hl 
7568 3e 2f			ld a, display_row_2 + 7 
756a cd 8e 0d			call str_at_display 
756d cd 9e 0d			call update_display 
7570 e1				pop hl 
7571 d1				pop de 
7572			 
7572			;		if DEBUG_FORTH_WORDS 
7572			;			DMARK "DI2" 
7572			;			CALLMONITOR 
7572			;		endif 
7572			 
7572 cd 83 07				call storage_findnextid 
7575			 
7575			;		if DEBUG_FORTH_WORDS 
7575			;			DMARK "DI3" 
7575			;			CALLMONITOR 
7575			;		endif 
7575			 
7575					; if found hl will be non zero 
7575			 
7575 cd d5 0f				call ishlzero 
7578			;		ld a, l 
7578			;		add h 
7578			; 
7578			;		cp 0 
7578 28 1d				jr z, .dirnotfound 
757a			 
757a					; increase count 
757a			 
757a c1					pop bc	 
757b 0c					inc c 
757c c5					push bc 
757d					 
757d			 
757d					; get file header and push the file name 
757d			 
757d 11 ac f9				ld de, store_page 
7580 cd 57 04				call storage_read_block 
7583			 
7583					; push file id to stack 
7583				 
7583			 
7583					; is this a file we want to run? 
7583			 
7583 21 af f9				ld hl, store_page+3 
7586 7e					ld a,(hl) 
7587 fe 2a				cp '*' 
7589 20 0c				jr nz,  .dirnotfound 
758b					 
758b			 
758b			 
758b 3a ac f9				ld a, (store_page) 
758e d5					push de 
758f e5					push hl 
7590 c5					push bc 
7591 cd bd 75				call .autorunf 
7594 c1					pop bc 
7595 e1					pop hl 
7596 d1					pop de 
7597			 
7597			 
7597			 
7597				; save this extent 
7597			 
7597					; push file name 
7597			;display file name to run 
7597			 
7597			;		ld hl, store_page+3 
7597			;		if DEBUG_FORTH_WORDS 
7597			;			DMARK "DI5" 
7597			;			CALLMONITOR 
7597			;		endif 
7597			; 
7597			;		 
7597			; 
7597			;		call forth_push_str 
7597			;		if DEBUG_FORTH_WORDS 
7597			;			DMARK "DI6" 
7597			;			CALLMONITOR 
7597			;		endif 
7597			.dirnotfound: 
7597 c1					pop bc     
7598 10 b6				djnz .diritem 
759a				 
759a			.dirdone:	 
759a					if DEBUG_FORTH_WORDS 
759a						DMARK "DI7" 
759a f5				push af  
759b 3a af 75			ld a, (.dmark)  
759e 32 9d fd			ld (debug_mark),a  
75a1 3a b0 75			ld a, (.dmark+1)  
75a4 32 9e fd			ld (debug_mark+1),a  
75a7 3a b1 75			ld a, (.dmark+2)  
75aa 32 9f fd			ld (debug_mark+2),a  
75ad 18 03			jr .pastdmark  
75af ..			.dmark: db "DI7"  
75b2 f1			.pastdmark: pop af  
75b3			endm  
# End of macro DMARK
75b3						CALLMONITOR 
75b3 cd aa fd			call debug_vector  
75b6				endm  
# End of macro CALLMONITOR
75b6					endif 
75b6			 
75b6 cd 7c 0d				call clear_display 
75b9 cd 9e 0d				call update_display 
75bc			 
75bc c9					ret 
75bd			 
75bd			 
75bd			 
75bd			 
75bd			 
75bd			.autorunf: 
75bd			 
75bd			 
75bd				; get file id to load from and get the file name to display 
75bd			 
75bd			;		ld a, (store_page+STORE_0_FILERUN) 
75bd			 
75bd 2e 00				ld l, 0 
75bf 67					ld h, a 
75c0 11 ac f9				ld de, store_page 
75c3			 
75c3					if DEBUG_FORTH_WORDS 
75c3						DMARK "ASp" 
75c3 f5				push af  
75c4 3a d8 75			ld a, (.dmark)  
75c7 32 9d fd			ld (debug_mark),a  
75ca 3a d9 75			ld a, (.dmark+1)  
75cd 32 9e fd			ld (debug_mark+1),a  
75d0 3a da 75			ld a, (.dmark+2)  
75d3 32 9f fd			ld (debug_mark+2),a  
75d6 18 03			jr .pastdmark  
75d8 ..			.dmark: db "ASp"  
75db f1			.pastdmark: pop af  
75dc			endm  
# End of macro DMARK
75dc						CALLMONITOR 
75dc cd aa fd			call debug_vector  
75df				endm  
# End of macro CALLMONITOR
75df					endif 
75df cd a7 09				call storage_read 
75e2			 
75e2					if DEBUG_FORTH_WORDS 
75e2						DMARK "ASr" 
75e2 f5				push af  
75e3 3a f7 75			ld a, (.dmark)  
75e6 32 9d fd			ld (debug_mark),a  
75e9 3a f8 75			ld a, (.dmark+1)  
75ec 32 9e fd			ld (debug_mark+1),a  
75ef 3a f9 75			ld a, (.dmark+2)  
75f2 32 9f fd			ld (debug_mark+2),a  
75f5 18 03			jr .pastdmark  
75f7 ..			.dmark: db "ASr"  
75fa f1			.pastdmark: pop af  
75fb			endm  
# End of macro DMARK
75fb						CALLMONITOR 
75fb cd aa fd			call debug_vector  
75fe				endm  
# End of macro CALLMONITOR
75fe					endif 
75fe			 
75fe cd d5 0f				call ishlzero 
7601 c8					ret z             ; file not found 
7602			 
7602					; display file name we are loading 
7602			 
7602 cd 7c 0d				call clear_display 
7605			 
7605 3e 32				ld a, display_row_2 + 10 
7607 11 af f9				ld de, store_page+3 
760a cd 8e 0d				call str_at_display 
760d				 
760d			; 
760d			 
760d			;	ld a, display_row_1+5 
760d			;	ld de, sprompt3 
760d			;	call str_at_display 
760d			;	ld a, display_row_2+7 
760d			;	call active 
760d			;	ex de, hl 
760d			;;	ld de, sprompt4 
760d			;	call str_at_display 
760d			; 
760d cd 9e 0d			call update_display 
7610			 
7610			;	call cin_wait 
7610			;	cp 'n' 
7610			;	ret z 
7610			;	cp 'N' 
7610			;	ret z 
7610			 
7610			;	call delay1s 
7610			 
7610 3a ae f9			ld a, (store_page+2) 
7613 32 9b f9			ld (store_openmaxext), a    ; save count of ext 
7616 3e 01			ld a, 1  
7618 32 9c f9			ld (store_openext), a    ; save count of ext 
761b			 
761b			.autof: 
761b				; begin to read a line from file 
761b			 
761b 21 1a f4			ld hl, os_cli_cmd 
761e 22 18 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7621			  
7621			.readext: 
7621 3a 9c f9			ld a, (store_openext) 
7624 6f				ld l , a 
7625				 
7625 3a ac f9			ld a, (store_page) 
7628 67				ld h, a	 
7629 11 ac f9			ld de, store_page 
762c					if DEBUG_FORTH_WORDS 
762c						DMARK "ASl" 
762c f5				push af  
762d 3a 41 76			ld a, (.dmark)  
7630 32 9d fd			ld (debug_mark),a  
7633 3a 42 76			ld a, (.dmark+1)  
7636 32 9e fd			ld (debug_mark+1),a  
7639 3a 43 76			ld a, (.dmark+2)  
763c 32 9f fd			ld (debug_mark+2),a  
763f 18 03			jr .pastdmark  
7641 ..			.dmark: db "ASl"  
7644 f1			.pastdmark: pop af  
7645			endm  
# End of macro DMARK
7645						CALLMONITOR 
7645 cd aa fd			call debug_vector  
7648				endm  
# End of macro CALLMONITOR
7648					endif 
7648 cd a7 09				call storage_read 
764b cd d5 0f			call ishlzero 
764e c8				ret z 
764f			 
764f			; TODO copy to exec buffer 
764f			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
764f			 
764f				; copy the record buffer to the cli buffer 
764f			 
764f ed 5b 18 f6		ld de, (os_var_array) 
7653 21 ae f9			ld hl, store_page+2 
7656			;	ex de, hl 
7656 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
7659 ed b0			ldir 
765b ed 53 18 f6		ld (os_var_array), de 
765f				 
765f 3a 9c f9			ld a, (store_openext) 
7662 3c				inc a 
7663 32 9c f9			ld (store_openext), a    ; save count of ext 
7666			 
7666			 
7666			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7666				 
7666 3a 9f f9			ld a, (store_readcont) 
7669			;	cp 0 
7669 b7				or a 
766a 20 b5			jr nz, .readext 
766c			 
766c			;	jr z, .autoend 
766c			 
766c					if DEBUG_FORTH_WORDS 
766c						DMARK "ASc" 
766c f5				push af  
766d 3a 81 76			ld a, (.dmark)  
7670 32 9d fd			ld (debug_mark),a  
7673 3a 82 76			ld a, (.dmark+1)  
7676 32 9e fd			ld (debug_mark+1),a  
7679 3a 83 76			ld a, (.dmark+2)  
767c 32 9f fd			ld (debug_mark+2),a  
767f 18 03			jr .pastdmark  
7681 ..			.dmark: db "ASc"  
7684 f1			.pastdmark: pop af  
7685			endm  
# End of macro DMARK
7685						CALLMONITOR 
7685 cd aa fd			call debug_vector  
7688				endm  
# End of macro CALLMONITOR
7688					endif 
7688 e5				push hl	 
7689 d5				push de 
768a cd d4 0c			call active 
768d eb				ex de, hl 
768e 3e 2f			ld a, display_row_2 + 7 
7690 cd 8e 0d			call str_at_display 
7693			 
7693 cd 9e 0d			call update_display 
7696 d1				pop de  
7697 e1				pop hl 
7698			;	call delay250ms 
7698			 
7698			 
7698			 
7698			 
7698			.autoexec: 
7698			 
7698			 
7698 21 1a f4			ld hl, os_cli_cmd 
769b					if DEBUG_FORTH_WORDS 
769b						DMARK "ASx" 
769b f5				push af  
769c 3a b0 76			ld a, (.dmark)  
769f 32 9d fd			ld (debug_mark),a  
76a2 3a b1 76			ld a, (.dmark+1)  
76a5 32 9e fd			ld (debug_mark+1),a  
76a8 3a b2 76			ld a, (.dmark+2)  
76ab 32 9f fd			ld (debug_mark+2),a  
76ae 18 03			jr .pastdmark  
76b0 ..			.dmark: db "ASx"  
76b3 f1			.pastdmark: pop af  
76b4			endm  
# End of macro DMARK
76b4						CALLMONITOR 
76b4 cd aa fd			call debug_vector  
76b7				endm  
# End of macro CALLMONITOR
76b7					endif 
76b7 cd 99 23			call forthparse 
76ba cd d1 23			call forthexec 
76bd cd f3 22			call forthexec_cleanup 
76c0			 
76c0			 
76c0			 
76c0 c3 1b 76			jp .autof 
76c3			;.autofdone: 
76c3			; 
76c3			;		if DEBUG_FORTH_WORDS 
76c3			;			DMARK "ASx" 
76c3			;			CALLMONITOR 
76c3			;		endif 
76c3			;;	call clear_display 
76c3			;	ret 
76c3			 
76c3			 
76c3			 
76c3			endif 
# End of file forth_startupv2.asm
76c3			endif 
76c3			 
# End of file forth_startup.asm
76c3			 
76c3			; eof 
# End of file forth_kernel.asm
76c3			;include "nascombasic.asm" 
76c3			 
76c3			 
76c3			; find out where the code ends if loaded into RAM (for SC114) 
76c3			;endofcode:  
76c3			;	nop 
76c3			 
76c3			 
76c3			; jump to nmi vector 
76c3			 
76c3			init_nmi: 
76c3 3e c9			ld a, $c9   ; RET 
76c5 32 ad fd			ld (nmi_vector), a 
76c8 c9				ret 
76c9			nmi: 
76c9 e5				push hl 
76ca d5				push de 
76cb c5				push bc 
76cc f5				push af 
76cd cd ad fd			call nmi_vector 
76d0 f5				push af 
76d1 c5				push bc 
76d2 d5				push de 
76d3 e5				push hl 
76d4 ed 4d			reti 
76d6			 
76d6			 
76d6			; eof 
76d6			 
# End of file main.asm
76d6			include "firmware_lcd_4x40.asm" 
76d6			; **********************************************************************  
76d6			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
76d6			; **********************************************************************  
76d6			;  
76d6			; **  Written as a Small Computer Monitor App  
76d6			; **  www.scc.me.uk  
76d6			;  
76d6			; History  
76d6			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
76d6			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
76d6			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
76d6			;  
76d6			; **********************************************************************  
76d6			;  
76d6			; This program is an example of one of the methods of interfacing an   
76d6			; alphanumeric LCD module.   
76d6			;  
76d6			; In this example the display is connected to either a Z80 PIO or a   
76d6			; simple 8-bit output port.   
76d6			;  
76d6			; This interfacing method uses 4-bit data mode and uses time delays  
76d6			; rather than polling the display's ready status. As a result the   
76d6			; interface only requires 6 simple output lines:  
76d6			;   Output bit 0 = not used  
76d6			;   Output bit 1 = not used  
76d6			;   Output bit 2 = RS         High = data, Low = instruction  
76d6			;   Output bit 3 = E          Active high  
76d6			;   Output bit 4 = DB4  
76d6			;   Output bit 5 = DB5  
76d6			;   Output bit 6 = DB6  
76d6			;   Output bit 7 = DB7  
76d6			; Display's R/W is connected to 0v so it is always in write mode  
76d6			;  
76d6			; This set up should work with any system supporting the RC2014 bus  
76d6			  
76d6			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
76d6			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
76d6			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
76d6			;  
76d6			; **********************************************************************  
76d6			  
76d6			; Additonal for 4x40. E1 and E2 instead of just E   
76d6			; TODO swipe vidout signal on port a to activate E2  
76d6			  
76d6			; **********************************************************************  
76d6			; **  Constants  
76d6			; **********************************************************************  
76d6			; LCD constants required by LCD support module  
76d6			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
76d6			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
76d6			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
76d6			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
76d6			; TODO Decide which E is being set  
76d6			kLCDWidth:  EQU display_cols             ;Width in characters  
76d6			  
76d6			; **********************************************************************  
76d6			; **  Code library usage  
76d6			; **********************************************************************  
76d6			  
76d6			; send character to current cursor position  
76d6			; wraps and/or scrolls screen automatically  
76d6			  
76d6			  
76d6			  
76d6			lcd_init:  
76d6			  
76d6			; SCMonAPI functions used  
76d6			  
76d6			; Alphanumeric LCD functions used  
76d6			; no need to specify specific functions for this module  
76d6			  
76d6 3e cf		            LD   A, 11001111b  
76d8 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
76da 3e 00		            LD   A, 00000000b  
76dc d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
76de			  
76de			; Initialise alphanumeric LCD module  
76de 3e 00				ld a, 0  
76e0 32 fd fa				ld (display_lcde1e2), a  
76e3 cd 64 77		            CALL fLCD_Init      ;Initialise LCD module  
76e6 3e 01				ld a, 1  
76e8 32 fd fa				ld (display_lcde1e2), a  
76eb cd 64 77		            CALL fLCD_Init      ;Initialise LCD module  
76ee			  
76ee c9				ret  
76ef			  
76ef			;  
76ef			;;  
76ef			; lcd functions  
76ef			;  
76ef			;  
76ef			  
76ef			; what is at cursor position   
76ef			  
76ef			;get_cursor:	ld de, (cursor_row)   ;  row + col  
76ef			;		call curptr  
76ef			;		ret  
76ef			  
76ef			  
76ef			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
76ef			  
76ef			curptr:  
76ef c5				push bc  
76f0 21 e3 fc			ld hl, display_fb0  
76f3			cpr:	  
76f3				; loop for cursor whole row  
76f3 0e 28			ld c, display_cols  
76f5 23			cpr1:	inc hl  
76f6 0d				dec c  
76f7 20 fc			jr nz, cpr1  
76f9 05				dec b  
76fa 20 f7			jr nz, cpr  
76fc			  
76fc				; add col	  
76fc			  
76fc 23			cpr2:	inc hl  
76fd 1d				dec e  
76fe 20 fc			jr nz, cpr2  
7700			  
7700 c1				pop bc  
7701 c9				ret  
7702				  
7702			  
7702			  
7702			  
7702			  
7702			; write the frame buffer given in hl to hardware   
7702 22 fb fa		write_display: ld (display_write_tmp), hl 	   
7705 3e 00			ld a, kLCD_Line1  
7707 cd 11 78		            CALL fLCD_Pos       ;Position cursor to location in A  
770a 06 28			ld b, display_cols  
770c ed 5b fb fa		ld de, (display_write_tmp)  
7710 cd 5c 77			call write_len_string  
7713				  
7713				  
7713 2a fb fa			ld hl, (display_write_tmp)  
7716 11 28 00			ld de, display_cols  
7719 19				add hl,de  
771a 22 fb fa			ld (display_write_tmp),hl  
771d			  
771d				  
771d 3e 28			ld a, kLCD_Line2  
771f cd 11 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7722 06 28			ld b, display_cols  
7724 ed 5b fb fa		ld de, (display_write_tmp)  
7728 cd 5c 77			call write_len_string  
772b				  
772b 2a fb fa			ld hl, (display_write_tmp)  
772e 11 28 00			ld de, display_cols  
7731 19				add hl,de  
7732 22 fb fa			ld (display_write_tmp),hl  
7735			  
7735				  
7735 3e 50			ld a, kLCD_Line3  
7737 cd 11 78		            CALL fLCD_Pos       ;Position cursor to location in A  
773a 06 28			ld b, display_cols  
773c ed 5b fb fa		ld de, (display_write_tmp)  
7740 cd 5c 77			call write_len_string  
7743				  
7743 2a fb fa			ld hl, (display_write_tmp)  
7746 11 28 00			ld de, display_cols  
7749 19				add hl,de  
774a 22 fb fa			ld (display_write_tmp),hl  
774d			  
774d				  
774d 3e 78			ld a, kLCD_Line4  
774f cd 11 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7752 06 28			ld b, display_cols  
7754 ed 5b fb fa		ld de, (display_write_tmp)  
7758 cd 5c 77			call write_len_string  
775b c9					ret  
775c				  
775c				; write out a fixed length string given in b from de  
775c			  
775c 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
775d cd c9 77		            CALL fLCD_Data      ;Write character to display  
7760 13				inc de  
7761 10 f9			djnz write_len_string  
7763 c9				ret  
7764			  
7764			; Some other things to do  
7764			;            LD   A, kLCD_Clear ;Display clear  
7764			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7764			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7764			;            LD   A, kLCD_On     ;Display on with no cursor  
7764			;            ;LD   A, kLCD_Off   ;Display off  
7764			;            CALL fLCD_Inst      ;Send instruction to display  
7764			;  
7764			;  
7764			;            halt  
7764			;  
7764			;  
7764			;MsgHello:   DB  "Hello World!",0  
7764			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7764			  
7764			; Custom characters 5 pixels wide by 8 pixels high  
7764			; Up to 8 custom characters can be defined  
7764			;BitMaps:      
7764			;; Character 0x00 = Battery icon  
7764			;            DB  01110b  
7764			;            DB  11011b  
7764			;            DB  10001b  
7764			;            DB  10001b  
7764			;            DB  11111b  
7764			;            DB  11111b  
7764			;            DB  11111b  
7764			;            DB  11111b  
7764			;; Character 0x01 = Bluetooth icon  
7764			;            DB  01100b  
7764			;            DB  01010b  
7764			;            DB  11100b  
7764			;            DB  01000b  
7764			;            DB  11100b  
7764			;            DB  01010b  
7764			;            DB  01100b  
7764			;            DB  00000b  
7764			;  
7764			  
7764			  
7764			; **********************************************************************  
7764			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7764			; **********************************************************************  
7764			;  
7764			; **  Written as a Small Computer Monitor App   
7764			; **  Version 0.1 SCC 2018-05-16  
7764			; **  www.scc.me.uk  
7764			;  
7764			; **********************************************************************  
7764			;  
7764			; This module provides support for alphanumeric LCD modules using with  
7764			; *  HD44780 (or compatible) controller  
7764			; *  5 x 7 pixel fonts  
7764			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7764			; *  Interface via six digital outputs to the display (see below)  
7764			;  
7764			; LCD module pinout:  
7764			;   1  Vss   0v supply  
7764			;   2  Vdd   5v supply  
7764			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7764			;   4  RS    High = data, Low = instruction  
7764			;   5  R/W   High = Read, Low = Write  
7764			;   6  E     Enable signal (active high)  
7764			;   7  DB0   Data bit 0  
7764			;   8  DB1   Data bit 1  
7764			;   9  DB2   Data bit 2  
7764			;  10  DB3   Data bit 3  
7764			;  11  DB4   Data bit 4  
7764			;  12  DB5   Data bit 5  
7764			;  13  DB6   Data bit 6  
7764			;  14  DB7   Data bit 7  
7764			;  15  A     Backlight anode (+)  
7764			;  16  K     Backlight cathode (-)  
7764			;  
7764			; This interfacing method uses 4-bit data mode and uses time delays  
7764			; rather than polling the display's ready status. As a result the   
7764			; interface only requires 6 simple output lines:  
7764			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7764			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7764			;   LCD DB4 = Microcomputer output port bit 4  
7764			;   LCD DB5 = Microcomputer output port bit 5  
7764			;   LCD DB6 = Microcomputer output port bit 6  
7764			;   LCD DB7 = Microcomputer output port bit 7  
7764			; Display's R/W is connected to 0v so it is always in write mode  
7764			; All 6 connections must be on the same port address <kLCDPrt>  
7764			; This method also allows a decent length of cable from micro to LCD  
7764			;  
7764			; **********************************************************************  
7764			;  
7764			; To include the code for any given function provided by this module,   
7764			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7764			; the parent source file.  
7764			; For example:  #REQUIRES   uHexPrefix  
7764			;  
7764			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7764			; in the parent source file.  
7764			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7764			;  
7764			; These are the function names provided by this module:  
7764			; fLCD_Init                     ;Initialise LCD  
7764			; fLCD_Inst                     ;Send instruction to LCD  
7764			; fLCD_Data                     ;Send data byte to LCD  
7764			; fLCD_Pos                      ;Position cursor  
7764			; fLCD_Str                      ;Display string  
7764			; fLCD_Def                      ;Define custom character  
7764			;  
7764			; **********************************************************************  
7764			;  
7764			; Requires SCMonAPI.asm to also be included in the project  
7764			;  
7764			  
7764			  
7764			; **********************************************************************  
7764			; **  Constants  
7764			; **********************************************************************  
7764			  
7764			; Constants that must be defined externally  
7764			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7764			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7764			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7764			;kLCDWidth: EQU 20             ;Width in characters  
7764			  
7764			; general line offsets in any frame buffer  
7764			  
7764			  
7764			display_row_1: equ 0  
7764			display_row_2: equ display_row_1+display_cols  
7764			display_row_3: equ display_row_2 + display_cols  
7764			display_row_4: equ display_row_3 + display_cols  
7764			;display_row_4_eol:   
7764			  
7764			  
7764			; Cursor position values for the start of each line  
7764			  
7764			; E  
7764			kLCD_Line1: EQU 0x00   
7764			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7764			; E1  
7764			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7764			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7764			  
7764			; Instructions to send as A register to fLCD_Inst  
7764			kLCD_Clear: EQU 00000001b     ;LCD clear  
7764			kLCD_Off:   EQU 00001000b     ;LCD off  
7764			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7764			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7764			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7764			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7764			  
7764			; Constants used by this code module  
7764			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7764			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7764			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7764			  
7764			  
7764			  
7764			; **********************************************************************  
7764			; **  LCD support functions  
7764			; **********************************************************************  
7764			  
7764			; Initialise alphanumeric LCD module  
7764			; LCD control register codes:  
7764			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7764			;   N    0 = 1-line mode       1 = 2-line mode  
7764			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7764			;   D    0 = Display off       1 = Display on  
7764			;   C    0 = Cursor off        1 = Cursor on  
7764			;   B    0 = Blinking off      1 = Blinking on  
7764			;   ID   0 = Decrement mode    1 = Increment mode  
7764			;   SH   0 = Entire shift off  1 = Entire shift on  
7764 3e 28		fLCD_Init:  LD   A, 40  
7766 cd 8b 78		            CALL LCDDelay       ;Delay 40ms after power up  
7769			; For reliable reset set 8-bit mode - 3 times  
7769 cd 5b 78		            CALL WrFn8bit       ;Function = 8-bit mode  
776c cd 5b 78		            CALL WrFn8bit       ;Function = 8-bit mode  
776f cd 5b 78		            CALL WrFn8bit       ;Function = 8-bit mode  
7772			; Set 4-bit mode  
7772 cd 57 78		            CALL WrFn4bit       ;Function = 4-bit mode  
7775 cd 89 78		            CALL LCDDelay1      ;Delay 37 us or more  
7778			; Function set  
7778 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
777a cd 8d 77		            CALL fLCD_Inst      ;2 line, display on  
777d			; Display On/Off control  
777d 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
777f cd 8d 77		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7782			; Display Clear  
7782 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7784 cd 8d 77		            CALL fLCD_Inst      ;Clear display  
7787			; Entry mode  
7787 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7789 cd 8d 77		            CALL fLCD_Inst      ;Increment mode, shift off  
778c			; Display module now initialised  
778c c9			            RET  
778d			; ok to here  
778d			  
778d			; Write instruction to LCD  
778d			;   On entry: A = Instruction byte to be written  
778d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
778d f5			fLCD_Inst:  PUSH AF  
778e f5			            PUSH AF  
778f cd a1 77		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7792 f1			            POP  AF  
7793 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7794 17			            RLA  
7795 17			            RLA  
7796 17			            RLA  
7797 cd a1 77		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
779a 3e 02		            LD   A, 2  
779c cd 8b 78		            CALL LCDDelay       ;Delay 2 ms to complete   
779f f1			            POP  AF  
77a0 c9			            RET  
77a1			Wr4bits:   
77a1 f5					push af  
77a2 3a fd fa				ld a, (display_lcde1e2)  
77a5 fe 00				cp 0     ; e  
77a7 20 10				jr nz, .wea2	  
77a9 f1					pop af  
77aa e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77ac d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77ae cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
77b0 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
77b2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77b4 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
77b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77b8 c9			            RET  
77b9 f1			.wea2:		pop af  
77ba e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77bc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77be cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
77c0 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
77c2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77c4 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
77c6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77c8 c9			            RET  
77c9			  
77c9			  
77c9			; Write data to LCD  
77c9			;   On entry: A = Data byte to be written  
77c9			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77c9 f5			fLCD_Data:  PUSH AF  
77ca f5			            PUSH AF  
77cb cd dd 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
77ce f1			            POP  AF  
77cf 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
77d0 17			            RLA  
77d1 17			            RLA  
77d2 17			            RLA  
77d3 cd dd 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
77d6 3e 96		            LD   A, 150  
77d8 3d			Wait:      DEC  A              ;Wait a while to allow data   
77d9 20 fd		            JR   NZ, Wait      ;  write to complete  
77db f1			            POP  AF  
77dc c9			            RET  
77dd			Wr4bitsa:     
77dd f5					push af  
77de 3a fd fa				ld a, (display_lcde1e2)  
77e1 fe 00				cp 0     ; e1  
77e3 20 16				jr nz, .we2	  
77e5 f1					pop af  
77e6 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77e8 cb d7		            SET  kLCDBitRS, A  
77ea d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77ec cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
77ee cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
77f0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
77f2 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
77f4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
77f6 cb 97		            RES  kLCDBitRS, A  
77f8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77fa c9			            RET  
77fb f1			.we2:		pop af  
77fc e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77fe cb d7		            SET  kLCDBitRS, A  
7800 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7802 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7804 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7806 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7808 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
780a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
780c cb 97		            RES  kLCDBitRS, A  
780e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7810 c9			            RET  
7811			  
7811			  
7811			; Position cursor to specified location  
7811			;   On entry: A = Cursor position  
7811			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7811 f5			fLCD_Pos:   PUSH AF  
7812					; at this point set the E1 or E2 flag depending on position  
7812			  
7812 c5					push bc  
7813			;		push af  
7813 06 00				ld b, 0  
7815 4f					ld c, a  
7816 3e 4f				ld a, kLCD_Line3-1  
7818 b7			 		or a      ;clear carry flag  
7819 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
781a 38 04				jr c, .pe1  
781c			  
781c					; E selection  
781c cb 80				res 0, b         ; bit 0 unset e  
781e			;		pop af    ; before line 3 so recover orig pos  
781e			;		ld c, a    ; save for poking back  
781e 18 06				jr .peset	          
7820			.pe1:          	; E2 selection  
7820 cb c0				set 0, b         ; bit 0 set e1  
7822 79					ld a, c  
7823 de 4f				sbc a, kLCD_Line3-1  
7825 4f					ld c, a	         ; save caculated offset  
7826			;		pop af     ; bin this original value now we have calculated form  
7826			  
7826			.peset:		; set bit  
7826 78					ld a, b  
7827 32 fd fa				ld (display_lcde1e2), a 	  
782a 79					ld a, c  
782b c1					pop bc  
782c			  
782c f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
782e cd 8d 77		            CALL fLCD_Inst      ;Write instruction to LCD  
7831 f1			            POP  AF  
7832 c9			            RET  
7833			  
7833			  
7833			; Output text string to LCD  
7833			;   On entry: DE = Pointer to null terminated text string  
7833			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7833 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7834 b7			            OR   A              ;Null terminator?  
7835 c8			            RET  Z              ;Yes, so finished  
7836 cd c9 77		            CALL fLCD_Data      ;Write character to display  
7839 13			            INC  DE             ;Point to next character  
783a 18 f7		            JR   fLCD_Str       ;Repeat  
783c c9					ret  
783d			  
783d			; Define custom character  
783d			;   On entry: A = Character number (0 to 7)  
783d			;             DE = Pointer to character bitmap data  
783d			;   On exit:  A = Next character number  
783d			;             DE = Next location following bitmap  
783d			;             BC HL IX IY I AF' BC' DE' HL' preserved  
783d			; Character is   
783d c5			fLCD_Def:   PUSH BC  
783e f5			            PUSH AF  
783f 07			            RLCA                ;Calculate location  
7840 07			            RLCA                ;  for bitmap data  
7841 07			            RLCA                ;  = 8 x CharacterNumber  
7842 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7844 cd 8d 77		            CALL fLCD_Inst      ;Write instruction to LCD  
7847 06 00		            LD   B, 0  
7849 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
784a cd c9 77		            CALL fLCD_Data      ;Write byte to display  
784d 13			            INC  DE             ;Point to next byte  
784e 04			            INC  B              ;Count bytes  
784f cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7851 28 f6		            JR   Z, Loop       ;No, so repeat  
7853 f1			            POP  AF  
7854 3c			            INC  A              ;Increment character number  
7855 c1			            POP  BC  
7856 c9			            RET  
7857			  
7857			  
7857			; **********************************************************************  
7857			; **  Private functions  
7857			; **********************************************************************  
7857			  
7857			; Write function to LCD  
7857			;   On entry: A = Function byte to be written  
7857			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7857 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7859 18 02		            JR   WrFunc  
785b 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
785d f5			WrFunc:     PUSH AF  
785e f5					push af  
785f 3a fd fa				ld a, (display_lcde1e2)  
7862 fe 00				cp 0     ; e1  
7864 20 0f				jr nz, .wfea2	  
7866 f1					pop af  
7867 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7869 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
786b cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
786d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
786f cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7871 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7873 18 0d			jr .wfskip  
7875 f1			.wfea2:		pop af  
7876 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7878 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
787a cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
787c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
787e cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7880 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7882 3e 05		.wfskip:            LD  A, 5  
7884 cd 8b 78		            CALL LCDDelay       ;Delay 5 ms to complete  
7887 f1			            POP  AF  
7888 c9			            RET  
7889			  
7889			  
7889			; Delay in milliseconds  
7889			;   On entry: A = Number of milliseconds delay  
7889			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7889 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
788b d5			LCDDelay:   PUSH DE  
788c 5f			            LD   E, A           ;Delay by 'A' ms  
788d 16 00		            LD   D, 0  
788f cd a5 0c		            CALL aDelayInMS  
7892 d1			            POP  DE  
7893 c9			            RET  
7894			  
7894			  
7894			testlcd:  
7894 3e 00			ld a, kLCD_Line1  
7896 cd 11 78			call fLCD_Pos  
7899 06 28			ld b, 40  
789b 11 c9 78			ld de, .ttext1  
789e cd 5c 77			call write_len_string  
78a1			  
78a1 3e 28			ld a, kLCD_Line2  
78a3 cd 11 78			call fLCD_Pos  
78a6 06 28			ld b, 40  
78a8 11 f2 78			ld de, .ttext2  
78ab cd 5c 77			call write_len_string  
78ae 3e 50			ld a, kLCD_Line3  
78b0 cd 11 78			call fLCD_Pos  
78b3 06 28			ld b, 40  
78b5 11 1b 79			ld de, .ttext3  
78b8 cd 5c 77			call write_len_string  
78bb 3e 78			ld a, kLCD_Line4  
78bd cd 11 78			call fLCD_Pos  
78c0 06 28			ld b, 40  
78c2 11 44 79			ld de, .ttext4  
78c5 cd 5c 77			call write_len_string  
78c8			  
78c8 76				halt  
78c9			  
78c9			  
78c9 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
78f2 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
791b .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7944 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
796d			   
796d			  
796d			  
796d			; eof  
796d			  
# End of file firmware_lcd_4x40.asm
796d			;include "firmware_lcd_4x20.asm" 
796d			include "firmware_key_5x10.asm" 
796d			; 5 x 10 decade counter scanner  
796d			  
796d			  
796d			; TODO do cursor shape change for shift keys  
796d			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
796d			  
796d			  
796d			; bit mask for each scan column and row for teing the matrix  
796d			  
796d			  
796d			key_init:  
796d			  
796d			; SCMonAPI functions used  
796d			  
796d			; Alphanumeric LCD functions used  
796d			; no need to specify specific functions for this module  
796d			  
796d			  
796d 3e cf		            LD   A, 11001111b  
796f d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7971			;            LD   A, 00000000b  
7971 3e 1f		            LD   A, 00011111b  
7973 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7975			  
7975			  
7975				; TODO Configure cursor shapes  
7975			  
7975				; Load cursor shapes   
7975 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7977 11 87 79		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
797a 06 02		            LD   B, 2           ;Number of characters to define  
797c cd 3d 78		.DefLoop:   CALL fLCD_Def       ;Define custom character  
797f 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7981			  
7981 3e 01				ld a, 1  
7983 32 f3 fa			ld (cursor_shape),a  
7986 c9				ret  
7987			  
7987			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7987			; Up to 8 custom characters can be defined  
7987			.cursor_shapes:      
7987			;; Character 0x00 = Normal  
7987 1f			            DB  11111b  
7988 1f			            DB  11111b  
7989 1f			            DB  11111b  
798a 1f			            DB  11111b  
798b 1f			            DB  11111b  
798c 1f			            DB  11111b  
798d 1f			            DB  11111b  
798e 1f			            DB  11111b  
798f			;; Character 0x01 = Modifier  
798f 1f			            DB  11111b  
7990 1b			            DB  11011b  
7991 1b			            DB  11011b  
7992 1b			            DB  11011b  
7993 1b			            DB  11011b  
7994 1f			            DB  11111b  
7995 1b			            DB  11011b  
7996 1f			            DB  11111b  
7997			  
7997			  
7997			  
7997			  
7997			; Display custom character 0  
7997			;            LD   A, kLCD_Line1+14  
7997			;            CALL fLCD_Pos       ;Position cursor to location in A  
7997			;            LD   A, 0  
7997			;            CALL fLCD_Data      ;Write character in A at cursor  
7997			  
7997			; Display custom character 1  
7997			;            LD   A, kLCD_Line2+14  
7997			;            CALL fLCD_Pos      ;Position cursor to location in A  
7997			;            LD   A, 1  
7997			;            CALL fLCD_Data     ;Write character in A at cursor  
7997			  
7997			; keyboard scanning   
7997			  
7997			; character in from keyboard  
7997			  
7997			; mapping for the pcb layout  
7997			  
7997			.matrix_to_char:  
7997 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
79a2 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
79ad 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
79b8 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
79c3 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
79ce			.matrix_to_shift:  
79ce			  
79ce .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
79d9 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
79e4 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
79ef 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
79fa .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7a05			  
7a05			.matrix_to_symbolshift:  
7a05			  
7a05 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7a10 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7a1b 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7a26			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7a26 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7a31 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7a3c			  
7a3c			  
7a3c			  
7a3c			; mapping for a simple straight through breadboard layout  
7a3c			  
7a3c			;.matrix_to_char:  
7a3c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7a3c			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7a3c			;		db "asdfghjkl",KEY_CR,0  
7a3c			;		db "qwertyuiop",0  
7a3c			;		 db "1234567890",0  
7a3c			;.matrix_to_shift:  
7a3c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7a3c			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7a3c			;		db "ASDFGHJKL",KEY_CR,0  
7a3c			;		db "QWERTYUIOP",0  
7a3c			;		 db "!",'"',"#$%^&*()",0  
7a3c			;.matrix_to_symbolshift:  
7a3c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7a3c			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7a3c			;		db "_?*fghjk=",KEY_CR,0  
7a3c			;		db "-/+*[]{}@#",0  
7a3c			;		 db "1234567890",0  
7a3c			  
7a3c			;.matrix_to_char: db "D#0*C987B654A321"  
7a3c			  
7a3c			  
7a3c				  
7a3c			  
7a3c			; add cin and cin_wait  
7a3c			  
7a3c cd 4b 7a		cin_wait: 	call cin  
7a3f						if DEBUG_KEYCINWAIT  
7a3f							push af  
7a3f							  
7a3f							ld hl,key_repeat_ct  
7a3f							ld (hl),a  
7a3f							inc hl  
7a3f							call hexout  
7a3f							ld hl,key_repeat_ct+3  
7a3f			;				ld a,0  
7a3f							ld (hl),0  
7a3f			  
7a3f							    LD   A, kLCD_Line1+11  
7a3f							    CALL fLCD_Pos       ;Position cursor to location in A  
7a3f							    LD   DE, key_repeat_ct  
7a3f							    ;LD   DE, MsgHello  
7a3f							    CALL fLCD_Str       ;Display string pointed to by DE  
7a3f			  
7a3f			  
7a3f			  
7a3f							pop af  
7a3f						endif  
7a3f			;	cp 0  
7a3f b7				or a  
7a40 28 fa			jr z, cin_wait   ; block until key press  
7a42			  
7a42							if DEBUG_KEYCINWAIT  
7a42								push af  
7a42			  
7a42			;					ld a, 'A'	  
7a42								ld hl,key_repeat_ct  
7a42								ld (hl),'A'  
7a42								inc hl  
7a42			;					ld a,0  
7a42								ld (hl),0  
7a42			  
7a42								    LD   A, kLCD_Line2+11  
7a42								    CALL fLCD_Pos       ;Position cursor to location in A  
7a42								    LD   DE, key_repeat_ct  
7a42								    ;LD   DE, MsgHello  
7a42								    CALL fLCD_Str       ;Display string pointed to by DE  
7a42			  
7a42							call delay500ms  
7a42			  
7a42								pop af  
7a42							endif  
7a42 f5				push af   ; save key pressed  
7a43			  
7a43			.cin_wait1:	  
7a43							if DEBUG_KEYCINWAIT  
7a43								push af  
7a43			  
7a43			;					ld a, 'b'	  
7a43								ld hl,key_repeat_ct  
7a43								ld (hl),'b'  
7a43								inc hl  
7a43			;					ld a,0  
7a43								ld (hl),0  
7a43			  
7a43								    LD   A, kLCD_Line2+11  
7a43								    CALL fLCD_Pos       ;Position cursor to location in A  
7a43								    LD   DE, key_repeat_ct  
7a43								    ;LD   DE, MsgHello  
7a43								    CALL fLCD_Str       ;Display string pointed to by DE  
7a43			  
7a43			  
7a43							call delay500ms  
7a43			  
7a43								pop af  
7a43							endif  
7a43			  
7a43 cd 4b 7a		call cin  
7a46			;	cp 0  
7a46 b7				or a  
7a47 20 fa			jr nz, .cin_wait1  	; wait for key release  
7a49			if DEBUG_KEYCINWAIT  
7a49				push af  
7a49			  
7a49			;	ld a, '3'	  
7a49				ld hl,key_repeat_ct  
7a49				ld (hl),'3'  
7a49				inc hl  
7a49			;	ld a,0  
7a49				ld (hl),0  
7a49			  
7a49			            LD   A, kLCD_Line2+11  
7a49			            CALL fLCD_Pos       ;Position cursor to location in A  
7a49			            LD   DE, key_repeat_ct  
7a49			            ;LD   DE, MsgHello  
7a49			            CALL fLCD_Str       ;Display string pointed to by DE  
7a49			  
7a49			  
7a49			call delay500ms  
7a49			  
7a49				pop af  
7a49			endif  
7a49			  
7a49 f1				pop af   ; get key  
7a4a c9				ret  
7a4b			  
7a4b			  
7a4b			; cin - key non-blocking except for keybounce release  
7a4b			  
7a4b cd 67 7a		cin: 	call .mtoc  
7a4e			  
7a4e			if DEBUG_KEYCIN  
7a4e				push af  
7a4e				  
7a4e				ld hl,key_repeat_ct  
7a4e				ld (hl),a  
7a4e				inc hl  
7a4e				call hexout  
7a4e				ld hl,key_repeat_ct+3  
7a4e			;	ld a,0  
7a4e				ld (hl),0  
7a4e			  
7a4e			            LD   A, kLCD_Line3+15  
7a4e			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4e			            LD   DE, key_repeat_ct  
7a4e			            ;LD   DE, MsgHello  
7a4e			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4e			  
7a4e			  
7a4e			call delay500ms  
7a4e			  
7a4e				pop af  
7a4e			endif  
7a4e			  
7a4e			  
7a4e				; no key held  
7a4e			;	cp 0  
7a4e b7				or a  
7a4f c8				ret z  
7a50			  
7a50			if DEBUG_KEYCIN  
7a50				push af  
7a50			  
7a50			;	ld a, '1'	  
7a50				ld hl,key_repeat_ct  
7a50				ld (hl),'1'  
7a50				inc hl  
7a50			;	ld a,0  
7a50				ld (hl),0  
7a50			  
7a50			            LD   A, kLCD_Line4+15  
7a50			            CALL fLCD_Pos       ;Position cursor to location in A  
7a50			            LD   DE, key_repeat_ct  
7a50			            ;LD   DE, MsgHello  
7a50			            CALL fLCD_Str       ;Display string pointed to by DE  
7a50			  
7a50			  
7a50			call delay500ms  
7a50			  
7a50				pop af  
7a50			endif  
7a50			  
7a50				; stop key bounce  
7a50			  
7a50 32 c6 fd			ld (key_held),a		 ; save it  
7a53 47				ld b, a  
7a54			  
7a54 c5			.cina1:	push bc  
7a55			if DEBUG_KEYCIN  
7a55				push af  
7a55			  
7a55				ld hl,key_repeat_ct  
7a55				inc hl  
7a55				call hexout  
7a55				ld hl,key_repeat_ct+3  
7a55			;	ld a,0  
7a55				ld (hl),0  
7a55				ld hl,key_repeat_ct  
7a55			;	ld a, '2'	  
7a55				ld (hl),'2'  
7a55			  
7a55			            LD   A, kLCD_Line4+15  
7a55			            CALL fLCD_Pos       ;Position cursor to location in A  
7a55			            LD   DE, key_repeat_ct  
7a55			            ;LD   DE, MsgHello  
7a55			            CALL fLCD_Str       ;Display string pointed to by DE  
7a55			  
7a55				pop af  
7a55			endif  
7a55 cd 67 7a			call .mtoc  
7a58 c1				pop bc  
7a59 b8				cp b  
7a5a 28 f8			jr z, .cina1  
7a5c 78				ld a,b		  
7a5d			if DEBUG_KEYCIN  
7a5d				push af  
7a5d			  
7a5d				ld hl,key_repeat_ct  
7a5d				inc hl  
7a5d				call hexout  
7a5d				ld hl,key_repeat_ct+3  
7a5d			;	ld a,0  
7a5d				ld (hl),0  
7a5d				ld hl,key_repeat_ct  
7a5d			;	ld a, '3'	  
7a5d				ld (hl),'3'  
7a5d			  
7a5d			            LD   A, kLCD_Line4+15  
7a5d			            CALL fLCD_Pos       ;Position cursor to location in A  
7a5d			            LD   DE, key_repeat_ct  
7a5d			            ;LD   DE, MsgHello  
7a5d			            CALL fLCD_Str       ;Display string pointed to by DE  
7a5d			  
7a5d				pop af  
7a5d			endif  
7a5d c9				ret  
7a5e			  
7a5e			; cinndb - key non-blocking without keybounce release  
7a5e			  
7a5e cd 67 7a		cinndb: 	call .mtoc  
7a61			  
7a61			if DEBUG_KEYCIN  
7a61				push af  
7a61				  
7a61				ld hl,key_repeat_ct  
7a61				ld (hl),a  
7a61				inc hl  
7a61				call hexout  
7a61				ld hl,key_repeat_ct+3  
7a61			;	ld a,0  
7a61				ld (hl),0  
7a61			  
7a61			            LD   A, kLCD_Line3+15  
7a61			            CALL fLCD_Pos       ;Position cursor to location in A  
7a61			            LD   DE, key_repeat_ct  
7a61			            ;LD   DE, MsgHello  
7a61			            CALL fLCD_Str       ;Display string pointed to by DE  
7a61			  
7a61			  
7a61			call delay500ms  
7a61			  
7a61				pop af  
7a61			endif  
7a61			  
7a61			  
7a61				; no key held  
7a61			;	cp 0  
7a61 b7				or a  
7a62 c8				ret z  
7a63			  
7a63			if DEBUG_KEYCIN  
7a63				push af  
7a63			  
7a63			;	ld a, '1'	  
7a63				ld hl,key_repeat_ct  
7a63				ld (hl),'1'  
7a63				inc hl  
7a63			;	ld a,0  
7a63				ld (hl),0  
7a63			  
7a63			            LD   A, kLCD_Line4+15  
7a63			            CALL fLCD_Pos       ;Position cursor to location in A  
7a63			            LD   DE, key_repeat_ct  
7a63			            ;LD   DE, MsgHello  
7a63			            CALL fLCD_Str       ;Display string pointed to by DE  
7a63			  
7a63			  
7a63			call delay500ms  
7a63			  
7a63				pop af  
7a63			endif  
7a63			  
7a63 32 c6 fd			ld (key_held),a		 ; save it  
7a66			  
7a66			if DEBUG_KEYCIN  
7a66				push af  
7a66			  
7a66				ld hl,key_repeat_ct  
7a66				inc hl  
7a66				call hexout  
7a66				ld hl,key_repeat_ct+3  
7a66			;	ld a,0  
7a66				ld (hl),0  
7a66				ld hl,key_repeat_ct  
7a66			;	ld a, '3'	  
7a66				ld (hl),'3'  
7a66			  
7a66			            LD   A, kLCD_Line4+15  
7a66			            CALL fLCD_Pos       ;Position cursor to location in A  
7a66			            LD   DE, key_repeat_ct  
7a66			            ;LD   DE, MsgHello  
7a66			            CALL fLCD_Str       ;Display string pointed to by DE  
7a66			  
7a66				pop af  
7a66			endif  
7a66 c9				ret  
7a67			; detect keyboard modifier key press and apply new overlay to the face key held  
7a67			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7a67			  
7a67			;.cin_map_modifier:   
7a67			;	ld a, (hl)  
7a67			;	and 255  
7a67			;	ret NZ		; modifier key not flagged  
7a67			;  
7a67			;	; get key face  
7a67			;  
7a67			;	ld b,(key_face_held)  
7a67			;  
7a67			;	ld b, key_cols * key_rows  
7a67			;  
7a67			;	push de  
7a67			;	pop hl  
7a67			;  
7a67			;.mmod1: ld a,(hl)   ; get map test  
7a67			;	cp b  
7a67			;	jr z, .mmod2  
7a67			;  
7a67			;  
7a67			;  
7a67			;.mmod2: inc hl    ;   
7a67			;  
7a67			;	  
7a67			;  
7a67			;	  
7a67			;  
7a67			;	ld hl,key_actual_pressed  
7a67			;	ld (hl),a,  
7a67			;	ret  
7a67			  
7a67			; map matrix key held to char on face of key  
7a67			  
7a67			.mtoc:  
7a67			  
7a67			; test decade counter strobes  
7a67			  
7a67			;.decadetest1:  
7a67			  
7a67			; reset counter  
7a67			;ld a, 128  
7a67			;out (portbdata),a  
7a67			  
7a67			  
7a67			;ld b, 5  
7a67			;.dec1:  
7a67			;ld a, 0  
7a67			;out (portbdata),a  
7a67			;call delay1s  
7a67			  
7a67			;ld a, 32  
7a67			;out (portbdata),a  
7a67			;call delay1s  
7a67			;call delay1s  
7a67			;call delay1s  
7a67			;  
7a67			;ld a, 64+32  
7a67			;out (portbdata),a  
7a67			;call delay1s  
7a67			;;djnz .dec1  
7a67			;  
7a67			;jp .decadetest1  
7a67			  
7a67			  
7a67			  
7a67			  
7a67			  
7a67			  
7a67			  
7a67			  
7a67			  
7a67			  
7a67				; scan keyboard matrix and generate raw scan map  
7a67 cd f8 7a			call matrix  
7a6a			  
7a6a				; reuse c bit 0 left modifer button - ie shift  
7a6a			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7a6a				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7a6a			  
7a6a 0e 00			ld c, 0  
7a6c			  
7a6c				; TODO set flags for modifer key presses   
7a6c				; TODO do a search for modifer key...  
7a6c			  
7a6c				;ld hl,keyscan_table_row4  
7a6c 21 25 fe			ld hl,keyscan_table_row2  
7a6f			  
7a6f 7e				ld a, (hl)  
7a70 fe 23			cp '#'  
7a72 20 07			jr nz, .nextmodcheck  
7a74 cb c1			set 0, c  
7a76 21 ce 79			ld hl, .matrix_to_shift  
7a79 18 21			jr .dokeymap  
7a7b				; TODO for now igonre  
7a7b			.nextmodcheck:  
7a7b 21 1a fe			ld hl,keyscan_table_row3  
7a7e			  
7a7e 7e				ld a, (hl)  
7a7f fe 23			cp '#'  
7a81 20 07			jr nz, .nextmodcheck2  
7a83 cb c9			set 1, c   
7a85 21 05 7a			ld hl, .matrix_to_symbolshift  
7a88 18 12			jr .dokeymap  
7a8a			.nextmodcheck2:  
7a8a 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
7a8d			  
7a8d 7e				ld a, (hl)  
7a8e fe 23			cp '#'  
7a90 20 07			jr nz, .donemodcheck  
7a92 cb c9			set 1, c   
7a94 21 ce 79			ld hl, .matrix_to_shift  
7a97 18 03			jr .dokeymap  
7a99			  
7a99				; no modifer found so just map to normal keys  
7a99				; get mtoc map matrix to respective keys  
7a99			;	ld hl, .matrix_to_char  
7a99			;	ld hl, .matrix_to_char  
7a99			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a99			;	ld a, KEY_SHIFT  
7a99			;	call findchar  
7a99			;  
7a99			;	; got offset to key modifer in b  
7a99			;  
7a99			;	ld hl,keyscan_table_row5  
7a99			;  
7a99			;	ld a,b  
7a99			;	call addatohl  
7a99			;	ld a,(hl)  
7a99			;  
7a99			;	cp '#'  
7a99			;	jr nz, .nextmodcheck  
7a99			;	set 0, c  
7a99			;	ld hl, .matrix_to_char  
7a99			;	jr .dokeymap  
7a99			;	; TODO for now igonre  
7a99			;.nextmodcheck:  
7a99			;	ld hl, .matrix_to_symbolshift  
7a99			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a99			;	ld a, KEY_SYMBOLSHIFT  
7a99			;	call findchar  
7a99			;  
7a99			;  
7a99			;	; got offset to key modifer in b  
7a99			;  
7a99			;	ld hl,keyscan_table_row5  
7a99			;  
7a99			;	ld a,b  
7a99			;	call addatohl  
7a99			;	ld a,(hl)  
7a99			;  
7a99			;	cp '#'  
7a99			;	jr nz, .donemodcheck  
7a99			;	set 1, c   
7a99			;	ld hl, .matrix_to_symbolshift  
7a99			;	jr .dokeymap  
7a99			  
7a99			  
7a99			  
7a99			.donemodcheck:  
7a99				; no modifer found so just map to normal keys  
7a99				; get mtoc map matrix to respective keys  
7a99 21 97 79			ld hl, .matrix_to_char  
7a9c			  
7a9c			.dokeymap:  
7a9c				;ld (key_fa), c   
7a9c cd b4 7a			call .mapkeys  
7a9f			  
7a9f			  
7a9f			if DEBUG_KEY  
7a9f			  
7a9f			; Display text on first line  
7a9f			            LD   A, kLCD_Line1  
7a9f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a9f			            LD   DE, keyscan_table_row1  
7a9f			            ;LD   DE, MsgHello  
7a9f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a9f			  
7a9f			; Display text on second line  
7a9f			            LD   A, kLCD_Line2  
7a9f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a9f			            LD   DE, keyscan_table_row2  
7a9f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a9f			            LD   A, kLCD_Line3  
7a9f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a9f			            LD   DE, keyscan_table_row3  
7a9f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a9f			            LD   A, kLCD_Line4  
7a9f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a9f			            LD   DE, keyscan_table_row4  
7a9f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a9f			            LD   A, kLCD_Line1+10  
7a9f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a9f			            LD   DE, keyscan_table_row5  
7a9f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a9f			  
7a9f				;call delay250ms  
7a9f			endif  
7a9f			;	jp testkey  
7a9f			  
7a9f			; get first char reported  
7a9f			  
7a9f 21 04 fe			ld hl,keyscan_table_row5  
7aa2			  
7aa2				;ld b, 46   ; 30 keys to remap + 8 nulls   
7aa2 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7aa4			.findkey:  
7aa4 7e				ld a,(hl)  
7aa5			;	cp 0  
7aa5 b7				or a  
7aa6 28 04			jr z, .nextkey  
7aa8 fe 7e			cp KEY_MATRIX_NO_PRESS  
7aaa 20 06			jr nz, .foundkey  
7aac			.nextkey:  
7aac 23				inc hl  
7aad 10 f5			djnz .findkey  
7aaf 3e 00			ld a,0  
7ab1 c9				ret  
7ab2			.foundkey:  
7ab2 7e				ld a,(hl)  
7ab3 c9				ret  
7ab4				  
7ab4			  
7ab4			; convert the raw key map given hl for destination key  
7ab4			.mapkeys:  
7ab4 11 04 fe			ld de,keyscan_table_row5  
7ab7			  
7ab7 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7ab9			.remap:  
7ab9 1a				ld a,(de)  
7aba fe 23			cp '#'  
7abc 20 02			jr nz, .remapnext  
7abe				;CALLMONITOR  
7abe 7e				ld a,(hl)  
7abf 12				ld (de),a  
7ac0			  
7ac0			  
7ac0			  
7ac0			.remapnext:  
7ac0 23				inc hl  
7ac1 13				inc de  
7ac2 10 f5			djnz .remap  
7ac4				  
7ac4 c9				ret  
7ac5			  
7ac5			  
7ac5			  
7ac5			.mtocold2:  
7ac5			  
7ac5			;	; flag if key D is held down and remove from reporting  
7ac5			;	ld bc, .key_map_fd    
7ac5			;	ld hl, keyscan_table  
7ac5			;	ld de, key_fd  
7ac5			;	call .key_shift_hold  
7ac5			;	cp 255  
7ac5			;	jr z, .cinmap  
7ac5			;	; flag if key C is held down and remove from reporting  
7ac5			;	ld bc, .key_map_fc    
7ac5			;	ld hl, keyscan_table+key_cols  
7ac5			;	ld de, key_fc  
7ac5			;	call .key_shift_hold  
7ac5			;	cp 255  
7ac5			;	jr z, .cinmap  
7ac5			;	; flag if key B is held down and remove from reporting  
7ac5			;	ld bc, .key_map_fb    
7ac5			;	ld hl, keyscan_table+(key_cols*2)  
7ac5			;	ld de, key_fb  
7ac5			;	call .key_shift_hold  
7ac5			;	cp 255  
7ac5			;	jr z, .cinmap  
7ac5			;	; flag if key A is held down and remove from reporting  
7ac5			;	ld bc, .key_map_fa    
7ac5			;	ld hl, keyscan_table+(key_cols*3)  
7ac5			;	ld de, key_fa  
7ac5			;	call .key_shift_hold  
7ac5			;	cp 255  
7ac5			;	jr z, .cinmap  
7ac5			  
7ac5 11 97 79			ld de, .matrix_to_char  
7ac8			  
7ac8			  
7ac8			.cinmap1:   
7ac8				if DEBUG_KEY  
7ac8			            LD   A, kLCD_Line4  
7ac8			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac8					push de  
7ac8			            LD   DE, keyscan_table  
7ac8			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac8					pop de  
7ac8				endif  
7ac8			  
7ac8				; scan key matrix table for any held key  
7ac8			  
7ac8				; de holds either the default matrix or one selected above  
7ac8			  
7ac8 21 d1 fd			ld hl, keyscan_table  
7acb 06 32			ld b,key_cols*key_rows  
7acd			  
7acd 7e			.cin11:	ld a,(hl)  
7ace fe 23			cp '#'  
7ad0 28 08			jr z, .cinhit1  
7ad2 23				inc hl  
7ad3 13				inc de  
7ad4 05				dec b  
7ad5 20 f6			jr nz, .cin11  
7ad7				; no key found held  
7ad7 3e 00			ld a,0  
7ad9 c9				ret  
7ada d5			.cinhit1: push de  
7adb e1				pop hl  
7adc 7e				ld a,(hl)  
7add c9				ret  
7ade			  
7ade			; flag a control key is held   
7ade			; hl is key pin, de is flag indicator  
7ade			  
7ade			.key_shift_hold1:  
7ade c5				push bc  
7adf 3e 01			ld a, 1  
7ae1 32 f3 fa			ld (cursor_shape),a  
7ae4 06 00			ld b, 0  
7ae6 7e				ld a, (hl)  
7ae7 fe 2e			cp '.'  
7ae9 28 09			jr z, .key_shift11  
7aeb 06 ff			ld b, 255  
7aed			;	ld a, '+'    ; hide key from later scans  
7aed 36 2b			ld (hl),'+'  
7aef 3e 02			ld a, 2  
7af1 32 f3 fa			ld (cursor_shape), a  
7af4			.key_shift11:  
7af4				; write flag indicator  
7af4 78				ld a,b  
7af5 12				ld (de),a  
7af6			  
7af6 d1				pop de    ; de now holds the key map ptr  
7af7 c9				ret  
7af8			  
7af8				  
7af8			  
7af8			; scans keyboard matrix and flags key press in memory array	  
7af8				  
7af8			matrix:  
7af8				;call matrix  
7af8				; TODO optimise the code....  
7af8			  
7af8			  
7af8			;ld hl, keyscan_table_row1  
7af8			;ld de, keyscan_table_row1+1  
7af8			;ld bc,46  
7af8			;ld a,KEY_MATRIX_NO_PRESS  
7af8			;ldir  
7af8			  
7af8			  
7af8			  
7af8			; reset counter  
7af8 3e 80		ld a, 128  
7afa d3 c1		out (portbdata),a  
7afc			  
7afc 06 0a		ld b, 10  
7afe 0e 00		ld c, 0       ; current clock toggle  
7b00			  
7b00			.colscan:  
7b00			  
7b00			; set current column  
7b00			; disable clock enable and set clock low  
7b00			  
7b00			;ld a, 0  
7b00			;out (portbdata),a  
7b00			  
7b00			; For each column scan for switches  
7b00			  
7b00 c5			push bc  
7b01 21 c7 fd		ld hl, keyscan_scancol  
7b04 cd 08 7c		call .rowscan  
7b07 c1			pop bc  
7b08			  
7b08			  
7b08			; get back current column  
7b08			  
7b08			; translate the row scan  
7b08			  
7b08			;   
7b08			; row 1  
7b08			  
7b08 78			ld a,b  
7b09			  
7b09 21 3a fe		LD   hl, keyscan_table_row1+10  
7b0c			  
7b0c cd be 0f		call subafromhl  
7b0f			;call addatohl  
7b0f			  
7b0f 11 c7 fd		ld de, keyscan_scancol  
7b12			  
7b12 1a			ld a,(de)  
7b13 77			ld (hl),a  
7b14			  
7b14			  
7b14			  
7b14			  
7b14			; row 2  
7b14			  
7b14 78			ld a,b  
7b15			  
7b15 21 2f fe		LD   hl, keyscan_table_row2+10  
7b18			  
7b18			;call addatohl  
7b18 cd be 0f		call subafromhl  
7b1b			  
7b1b			  
7b1b 11 c8 fd		ld de, keyscan_scancol+1  
7b1e			  
7b1e 1a			ld a,(de)  
7b1f 77			ld (hl),a  
7b20			  
7b20			  
7b20			; row 3  
7b20			  
7b20 78			ld a,b  
7b21			  
7b21 21 24 fe		LD   hl, keyscan_table_row3+10  
7b24			  
7b24			;call addatohl  
7b24 cd be 0f		call subafromhl  
7b27			  
7b27 11 c9 fd		ld de, keyscan_scancol+2  
7b2a			  
7b2a 1a			ld a,(de)  
7b2b 77			ld (hl),a  
7b2c			  
7b2c			  
7b2c			  
7b2c			; row 4  
7b2c			  
7b2c 78			ld a,b  
7b2d			  
7b2d 21 19 fe		LD   hl, keyscan_table_row4+10  
7b30			  
7b30			;call addatohl  
7b30 cd be 0f		call subafromhl  
7b33			  
7b33 11 ca fd		ld de, keyscan_scancol+3  
7b36			  
7b36 1a			ld a,(de)  
7b37 77			ld (hl),a  
7b38			  
7b38			; row 5  
7b38			  
7b38 78			ld a,b  
7b39			  
7b39 21 0e fe		LD   hl, keyscan_table_row5+10  
7b3c			  
7b3c			;call addatohl  
7b3c cd be 0f		call subafromhl  
7b3f			  
7b3f 11 cb fd		ld de, keyscan_scancol+4  
7b42			  
7b42 1a			ld a,(de)  
7b43 77			ld (hl),a  
7b44			  
7b44			; handshake next column  
7b44			  
7b44			  
7b44 3e 40		ld a, 64  
7b46 d3 c1		out (portbdata),a  
7b48			  
7b48 3e 00		ld a, 0  
7b4a d3 c1		out (portbdata),a  
7b4c			  
7b4c			; toggle clk and move to next column  
7b4c			;ld a, 64  
7b4c			;cp c  
7b4c			;  
7b4c			;jr z, .coltoglow  
7b4c			;ld c, a  
7b4c			;jr .coltog  
7b4c			;.coltoglow:  
7b4c			;ld c, 0  
7b4c			;.coltog:  
7b4c			;ld a, c  
7b4c			;out (portbdata),a  
7b4c			  
7b4c 10 b2		djnz .colscan  
7b4e			  
7b4e 3e 0a		ld a,10  
7b50 21 30 fe		LD   hl, keyscan_table_row1  
7b53 cd ac 0f		call addatohl  
7b56			;ld a, 0  
7b56 36 00		ld (hl), 0  
7b58			  
7b58			  
7b58 3e 0a		ld a,10  
7b5a 21 25 fe		LD   hl, keyscan_table_row2  
7b5d cd ac 0f		call addatohl  
7b60			;ld a, 0  
7b60 36 00		ld (hl), 0  
7b62			  
7b62 3e 0a		ld a,10  
7b64 21 1a fe		LD   hl, keyscan_table_row3  
7b67 cd ac 0f		call addatohl  
7b6a			;ld a, 0  
7b6a 36 00		ld (hl), 0  
7b6c			  
7b6c 3e 0a		ld a,10  
7b6e 21 0f fe		LD   hl, keyscan_table_row4  
7b71 cd ac 0f		call addatohl  
7b74			;ld a, 0  
7b74 36 00		ld (hl), 0  
7b76			  
7b76 3e 0a		ld a,10  
7b78 21 04 fe		LD   hl, keyscan_table_row5  
7b7b cd ac 0f		call addatohl  
7b7e			;ld a, 0  
7b7e 36 00		ld (hl), 0  
7b80			  
7b80			if DEBUG_KEY_MATRIX  
7b80			  
7b80			; Display text on first line  
7b80			            LD   A, kLCD_Line1  
7b80			            CALL fLCD_Pos       ;Position cursor to location in A  
7b80			            LD   DE, keyscan_table_row1  
7b80			            ;LD   DE, MsgHello  
7b80			            CALL fLCD_Str       ;Display string pointed to by DE  
7b80			  
7b80			; Display text on second line  
7b80			            LD   A, kLCD_Line2  
7b80			            CALL fLCD_Pos       ;Position cursor to location in A  
7b80			            LD   DE, keyscan_table_row2  
7b80			            CALL fLCD_Str       ;Display string pointed to by DE  
7b80			            LD   A, kLCD_Line3  
7b80			            CALL fLCD_Pos       ;Position cursor to location in A  
7b80			            LD   DE, keyscan_table_row3  
7b80			            CALL fLCD_Str       ;Display string pointed to by DE  
7b80			            LD   A, kLCD_Line4  
7b80			            CALL fLCD_Pos       ;Position cursor to location in A  
7b80			            LD   DE, keyscan_table_row4  
7b80			            CALL fLCD_Str       ;Display string pointed to by DE  
7b80			            LD   A, kLCD_Line4+10  
7b80			            CALL fLCD_Pos       ;Position cursor to location in A  
7b80			            LD   DE, keyscan_table_row5  
7b80			            CALL fLCD_Str       ;Display string pointed to by DE  
7b80			  
7b80			;call delay250ms  
7b80				jp matrix  
7b80			endif  
7b80 c9			ret  
7b81			  
7b81			; using decade counter....  
7b81			  
7b81			  
7b81			; TODO reset decade counter to start of scan  
7b81			  
7b81			; reset 15  
7b81			; clock 14  
7b81			; ce 13  
7b81			  
7b81			; 1 - q5  
7b81			; 2 - q1  
7b81			; 3 - q0  
7b81			; 4 - q2  
7b81			; 5 - q6  
7b81			; 6 - q7  
7b81			; 7 - q3  
7b81			; 8 - vss  
7b81			; 9 - q8  
7b81			; 10 - q4  
7b81			; 11 - q9  
7b81			; 12 - cout  
7b81			; 16 - vdd  
7b81			  
7b81			; clock      ce       reset     output  
7b81			; 0          x        0         n  
7b81			; x          1        0         n  
7b81			; x          x        1         q0  
7b81			; rising     0        0         n+1  
7b81			; falling    x        0         n  
7b81			; x          rising   0         n  
7b81			; 1          falling  0         x+1  
7b81			;  
7b81			; x = dont care, if n < 5 carry = 1 otherwise 0  
7b81			  
7b81			;   
7b81			; reset   
7b81			; 13=0, 14=0, 15=1 .. 15=0  
7b81			;  
7b81			; handshake line  
7b81			; 14=1.... read line 14=0  
7b81			  
7b81			  
7b81			  
7b81			  
7b81			  
7b81			; TODO hand shake clock for next column scan  
7b81			; TODO detect each row  
7b81			  
7b81			  
7b81			  
7b81			  
7b81			; reset 128  
7b81			; clock 64  
7b81			; ce 32  
7b81			  
7b81			  
7b81			.cyclestart:  
7b81			  
7b81			; reset counter  
7b81 3e 80		ld a, 128  
7b83 d3 c1		out (portbdata),a  
7b85			  
7b85			; loop leds  
7b85 06 0a		ld b,10  
7b87			  
7b87			.cycle1:  
7b87 c5			push bc  
7b88 3e 00		ld a, 0  
7b8a d3 c1		out (portbdata),a  
7b8c cd b4 0c		call delay250ms  
7b8f			  
7b8f 3e 40		ld a, 64  
7b91 d3 c1		out (portbdata),a  
7b93 cd b4 0c		call delay250ms  
7b96			  
7b96 3e 00		ld a, 0  
7b98 d3 c1		out (portbdata),a  
7b9a cd b4 0c		call delay250ms  
7b9d			  
7b9d c1			pop bc  
7b9e 10 e7		djnz .cycle1  
7ba0			  
7ba0			  
7ba0 18 df		jr .cyclestart  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			; map matrix key held to char on face of key  
7ba2			  
7ba2			;.mtocold:  
7ba2			;  
7ba2			;  
7ba2			;; reset counter  
7ba2			;ld a, 128  
7ba2			;out (portbdata),a  
7ba2			;  
7ba2			;  
7ba2			;; scan keyboard row 1  
7ba2			;ld a, 0  
7ba2			;out (portbdata),a  
7ba2			;;ld a, 64  
7ba2			;;out (portbdata),a  
7ba2			;  
7ba2			;  
7ba2			;	ld a, 128  
7ba2			;	ld hl, keyscan_table  
7ba2			;	call .rowscan  
7ba2			;  
7ba2			;;ld a, 0  
7ba2			;;out (portbdata),a  
7ba2			;ld a, 64  
7ba2			;out (portbdata),a  
7ba2			;  
7ba2			;	ld a, 64  
7ba2			;	ld hl, keyscan_table+key_cols  
7ba2			;	call .rowscan  
7ba2			;  
7ba2			;ld a, 0  
7ba2			;out (portbdata),a  
7ba2			;;ld a, 64  
7ba2			;;out (portbdata),a  
7ba2			;	ld a, 32  
7ba2			;	ld hl, keyscan_table+(key_cols*2)  
7ba2			;	call .rowscan  
7ba2			;  
7ba2			;  
7ba2			;;ld a, 0  
7ba2			;;out (portbdata),a  
7ba2			;ld a, 64  
7ba2			;out (portbdata),a  
7ba2			;  
7ba2			;	ld a, 16  
7ba2			;	ld hl, keyscan_table+(key_cols*3)  
7ba2			;	call .rowscan  
7ba2			;  
7ba2			;  
7ba2			;	; flag if key D is held down and remove from reporting  
7ba2			;	ld bc, .key_map_fd    
7ba2			;	ld hl, keyscan_table  
7ba2			;	ld de, key_fd  
7ba2			;	call .key_shift_hold  
7ba2			;	cp 255  
7ba2			;	jr z, .cinmap  
7ba2			;	; flag if key C is held down and remove from reporting  
7ba2			;	ld bc, .key_map_fc    
7ba2			;	ld hl, keyscan_table+key_cols  
7ba2			;	ld de, key_fc  
7ba2			;	call .key_shift_hold  
7ba2			;	cp 255  
7ba2			;	jr z, .cinmap  
7ba2			;	; flag if key B is held down and remove from reporting  
7ba2			;	ld bc, .key_map_fb    
7ba2			;	ld hl, keyscan_table+(key_cols*2)  
7ba2			;	ld de, key_fb  
7ba2			;	call .key_shift_hold  
7ba2			;	cp 255  
7ba2			;	jr z, .cinmap  
7ba2			;	; flag if key A is held down and remove from reporting  
7ba2			;	ld bc, .key_map_fa    
7ba2			;	ld hl, keyscan_table+(key_cols*3)  
7ba2			;	ld de, key_fa  
7ba2			;	call .key_shift_hold  
7ba2			;	cp 255  
7ba2			;	jr z, .cinmap  
7ba2			;  
7ba2			;	ld de, .matrix_to_char  
7ba2			;  
7ba2			;  
7ba2			;.cinmap:   
7ba2			;	if DEBUG_KEY  
7ba2			;            LD   A, kLCD_Line4  
7ba2			;            CALL fLCD_Pos       ;Position cursor to location in A  
7ba2			;		push de  
7ba2			;            LD   DE, keyscan_table  
7ba2			;            CALL fLCD_Str       ;Display string pointed to by DE  
7ba2			;		pop de  
7ba2			;	endif  
7ba2			  
7ba2				; scan key matrix table for any held key  
7ba2			  
7ba2				; de holds either the default matrix or one selected above  
7ba2			  
7ba2			;	ld hl, keyscan_table  
7ba2			;	ld b,key_cols*key_rows  
7ba2			;  
7ba2			;.cin1:	ld a,(hl)  
7ba2			;	cp '#'  
7ba2			;	jr z, .cinhit  
7ba2			;	inc hl  
7ba2			;	inc de  
7ba2			;	dec b  
7ba2			;	jr nz, .cin1  
7ba2			;	; no key found held  
7ba2			;	ld a,0  
7ba2			;	ret  
7ba2			;.cinhit: push de  
7ba2			;	pop hl  
7ba2			;	ld a,(hl)  
7ba2			;	ret  
7ba2			  
7ba2			; flag a control key is held   
7ba2			; hl is key pin, de is flag indicator  
7ba2			  
7ba2			;.key_shift_hold:  
7ba2			;	push bc  
7ba2			;	ld a, 1  
7ba2			;	ld (cursor_shape),a  
7ba2			;	ld b, 0  
7ba2			;	ld a, (hl)  
7ba2			;	cp '.'  
7ba2			;	jr z, .key_shift1  
7ba2			;	ld b, 255  
7ba2			;	ld a, '+'    ; hide key from later scans  
7ba2			;	ld (hl),a  
7ba2			;	ld a, 2  
7ba2			;	ld (cursor_shape),a  
7ba2			;.key_shift1:  
7ba2			;	; write flag indicator  
7ba2			;	ld a,b  
7ba2			;	ld (de),a  
7ba2			;  
7ba2			;	pop de    ; de now holds the key map ptr  
7ba2			;	ret  
7ba2			  
7ba2				  
7ba2				  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			;	push hl  
7ba2			;	push de  
7ba2			;	push bc  
7ba2			;	call keyscan  
7ba2			;	; map key matrix to ascii value of key face  
7ba2			;  
7ba2			;	ld hl, key_face_map  
7ba2			;	ld de, keyscan_table  
7ba2			;  
7ba2			;	; get how many keys to look at  
7ba2			;	ld b, keyscan_table_len  
7ba2			;	  
7ba2			;  
7ba2			;	; at this stage fall out on first key hit  
7ba2			;	; TODO handle multiple key press  
7ba2			;  
7ba2			;map1:	ld a,(hl)  
7ba2			;	cp '#'  
7ba2			;	jr z, keyhit  
7ba2			;	inc hl  
7ba2			;	inc de  
7ba2			;	dec b  
7ba2			;	jr nz, map1  
7ba2			;nohit:	ld a, 0  
7ba2			;	jr keydone  
7ba2			;keyhit: push de  
7ba2			;	pop hl  
7ba2			;	ld a,(hl)  
7ba2			;keydone:  
7ba2			;	push bc  
7ba2			;	push de  
7ba2			; 	push hl  
7ba2			;	ret   
7ba2			;  
7ba2			  
7ba2			  
7ba2			  
7ba2			  
7ba2			; scan physical key matrix  
7ba2			  
7ba2			  
7ba2			;keyscan:  
7ba2			;  
7ba2			;; for each key_row use keyscanr bit mask for out  
7ba2			;; then read in for keyscanc bitmask  
7ba2			;; save result of row scan to keyscantable  
7ba2			;  
7ba2			;; scan keyboard row 1  
7ba2			;  
7ba2			;	ld b, key_rows  
7ba2			;	ld hl, key_scanr  
7ba2			;	ld de, keyscan_table  
7ba2			;  
7ba2			;rowloop:  
7ba2			;  
7ba2			;	ld a,(hl)		; out bit mask to energise keyboard row  
7ba2			;	call rowscan  
7ba2			;	inc hl  
7ba2			;	dec b  
7ba2			;	jr nz, rowloop  
7ba2			;  
7ba2			;	ret  
7ba2			;  
7ba2			;  
7ba2			;; pass a out bitmask, b row number  
7ba2			;arowscan:   
7ba2			;	push bc  
7ba2			;  
7ba2			;	ld d, b  
7ba2			;  
7ba2			;	; calculate buffer location for this row  
7ba2			;  
7ba2			;	ld hl, keyscan_table	  
7ba2			;kbufr:  ld e, key_cols  
7ba2			;kbufc:	inc hl  
7ba2			;	dec e  
7ba2			;	jr nz, kbufc  
7ba2			;	dec d  
7ba2			;	jr nz, kbufr  
7ba2			;  
7ba2			;	; energise row and read columns  
7ba2			;  
7ba2			;	out (portbdata),a  
7ba2			;	in a,(portbdata)  
7ba2			;	ld c,a  
7ba2			;  
7ba2			;  
7ba2			;	; save buffer loc  
7ba2			;  
7ba2			;	ld (keybufptr), hl  
7ba2			;  
7ba2			;	ld hl, key_scanc  
7ba2			;	ld d, key_cols  
7ba2			;  
7ba2			;	; for each column check each bit mask  
7ba2			;  
7ba2			;colloop:  
7ba2			;	  
7ba2			;  
7ba2			;	; reset flags for the row   
7ba2			;  
7ba2			;	ld b,'.'  
7ba2			;	and (hl)  
7ba2			;	jr z, maskskip  
7ba2			;	ld b,'#'  
7ba2			;maskskip:  
7ba2			;	; save  key state  
7ba2			;	push hl  
7ba2			;	ld hl, (keybufptr)  
7ba2			;	ld (hl), b  
7ba2			;	inc hl  
7ba2			;	ld (keybufptr), hl  
7ba2			;  
7ba2			;	; move to next bit mask  
7ba2			;	pop hl  
7ba2			;	inc hl  
7ba2			;  
7ba2			;	dec d  
7ba2			;	jr nz, colloop  
7ba2			;  
7ba2			;	ret  
7ba2			;  
7ba2			;  
7ba2			;;  
7ba2			; lcd functions  
7ba2			;  
7ba2			;  
7ba2			  
7ba2			;if DEBUG_KEY_MATRIX  
7ba2			  
7ba2			; test function to display hardware view of matrix state  
7ba2			  
7ba2			matrixold:  
7ba2			  
7ba2			  
7ba2			  
7ba2			; reset counter  
7ba2 3e 80		ld a, 128  
7ba4 d3 c1		out (portbdata),a  
7ba6			; scan keyboard row 1  
7ba6 3e 00		ld a, 0  
7ba8 d3 c1		out (portbdata),a  
7baa			;ld a, 64  
7baa			;out (portbdata),a  
7baa 3e 80			ld a, 128  
7bac 21 30 fe			ld hl, keyscan_table_row1  
7baf cd 08 7c			call .rowscan  
7bb2			  
7bb2			;ld a, 0  
7bb2			;out (portbdata),a  
7bb2 3e 40		ld a, 64  
7bb4 d3 c1		out (portbdata),a  
7bb6 3e 40			ld a, 64  
7bb8 21 25 fe			ld hl, keyscan_table_row2  
7bbb cd 08 7c			call .rowscan  
7bbe			  
7bbe 3e 00		ld a, 0  
7bc0 d3 c1		out (portbdata),a  
7bc2			;ld a, 64  
7bc2			;out (portbdata),a  
7bc2 3e 20			ld a, 32  
7bc4 21 1a fe			ld hl, keyscan_table_row3  
7bc7 cd 08 7c			call .rowscan  
7bca			  
7bca			;ld a, 0  
7bca			;out (portbdata),a  
7bca 3e 40		ld a, 64  
7bcc d3 c1		out (portbdata),a  
7bce 3e 10			ld a, 16  
7bd0 21 0f fe			ld hl, keyscan_table_row4  
7bd3 cd 08 7c			call .rowscan  
7bd6			  
7bd6			; Display text on first line  
7bd6 3e 00		            LD   A, kLCD_Line1  
7bd8 cd 11 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7bdb 11 30 fe		            LD   DE, keyscan_table_row1  
7bde			            ;LD   DE, MsgHello  
7bde cd 33 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7be1			  
7be1			; Display text on second line  
7be1 3e 28		            LD   A, kLCD_Line2  
7be3 cd 11 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7be6 11 25 fe		            LD   DE, keyscan_table_row2  
7be9 cd 33 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7bec 3e 50		            LD   A, kLCD_Line3  
7bee cd 11 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7bf1 11 1a fe		            LD   DE, keyscan_table_row3  
7bf4 cd 33 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7bf7 3e 78		            LD   A, kLCD_Line4  
7bf9 cd 11 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7bfc 11 0f fe		            LD   DE, keyscan_table_row4  
7bff cd 33 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7c02			  
7c02 cd b4 0c			call delay250ms  
7c05 c3 f8 7a			jp matrix  
7c08			  
7c08			; pass de as row display flags  
7c08			.rowscan:   
7c08			;	out (portbdata),a  
7c08 db c1			in a,(portbdata)  
7c0a 4f				ld c,a  
7c0b				; reset flags for the row   
7c0b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c0d e6 01			and 1  
7c0f 28 02			jr z, .p1on  
7c11 06 23			ld b,'#'  
7c13			.p1on:  
7c13 70				ld (hl), b  
7c14 23				inc hl  
7c15			  
7c15 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c17 79				ld a,c  
7c18 e6 02			and 2  
7c1a			;	bit 0,a  
7c1a 28 02			jr z, .p2on  
7c1c 06 23			ld b,'#'  
7c1e			.p2on:  
7c1e 70				ld (hl), b  
7c1f 23				inc hl  
7c20			;  
7c20 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c22 79				ld a,c  
7c23 e6 04			and 4  
7c25			;;	bit 0,a  
7c25 28 02			jr z, .p3on  
7c27 06 23			ld b,'#'  
7c29			.p3on:  
7c29 70				ld (hl), b  
7c2a 23				inc hl  
7c2b			;;  
7c2b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c2d			;;	bit 0,a  
7c2d 79				ld a,c  
7c2e e6 08			and 8  
7c30 28 02			jr z, .p4on  
7c32 06 23			ld b,'#'  
7c34			.p4on:  
7c34 70				ld (hl), b  
7c35 23				inc hl  
7c36			  
7c36 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c38			;;	bit 0,a  
7c38 79				ld a,c  
7c39 e6 10			and 16  
7c3b 28 02			jr z, .p5on  
7c3d 06 23			ld b,'#'  
7c3f			.p5on:  
7c3f 70				ld (hl), b  
7c40 23				inc hl  
7c41			; zero term  
7c41			;	ld b,0  
7c41 36 00			ld (hl), 0  
7c43			  
7c43 c9			.rscandone: ret  
7c44			  
7c44			;addatohl:  
7c44			;  
7c44			 ;add   a, l    ; A = A+L  
7c44			  ;  ld    l, a    ; L = A+L  
7c44			   ; adc   a, h    ; A = A+L+H+carry  
7c44			   ; sub   l       ; A = H+carry  
7c44			   ; ld    h, a    ; H = H+carry  
7c44			  
7c44			;ret  
7c44			; eof  
# End of file firmware_key_5x10.asm
7c44			;include "firmware_key_4x10.asm" 
7c44			 
7c44			heap_size:    equ heap_end - heap_start 
7c44			;eof 
# End of file os_mega.asm
7c44
