# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 56 15			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 0   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ os_input  
0103			os_new_parse_len: equ os_new_malloc + 2  
0103			os_new_word_len: equ os_new_parse_len + 2  
0103			os_new_work_ptr: equ os_new_word_len + 2  
0103			os_new_src_ptr: equ os_new_work_ptr + 2  
0103			os_new_exec: equ os_new_src_ptr + 2  
0103			os_new_exec_ptr: equ os_new_exec + 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ scratch - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 3f 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 3f 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 3f 09				call clear_display  
0123			  
0123			  
0123 cd dd 56				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd cb 57			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 0b 10				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd 62 09			call update_display  
0132 cd e2 08			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 44 09			call fill_display  
013a cd 62 09			call update_display  
013d cd e2 08			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 44 09			call fill_display  
0145 cd 62 09			call update_display  
0148 cd e2 08			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 44 09			call fill_display  
0150 cd 62 09			call update_display  
0153 cd e2 08			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd 52 09			call str_at_display  
015e cd 62 09			call update_display  
0161			  
0161			  
0161 cd e2 08			call delay1s  
0164 cd e2 08			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd 52 09			call str_at_display  
016f cd 62 09			call update_display  
0172 cd e2 08			call delay1s  
0175 cd e2 08			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 80 13			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd 80 13			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd c7 04			call storage_findnextid 
0205			 
0205 cd 91 0b			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd 80 13			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd 80 13			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd 80 13			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd 80 13			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd 80 13			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 21 65 eb			ld hl, store_page 
02d3 3e 00			ld a, 0 
02d5				 
02d5 77				ld (hl),a   ; reset file counter 
02d6			 
02d6 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02d9 22 66 eb		 	ld (store_page+1), hl	 
02dc			 
02dc				; set default label 
02dc			 
02dc 21 71 03			ld hl, .defaultbanklabl 
02df 11 68 eb		 	ld de, store_page+3 
02e2 01 0f 00			ld bc, 15 
02e5 ed b0			ldir 
02e7			 
02e7				; save default page 0 
02e7			 
02e7 21 00 00			ld hl, 0 
02ea 11 65 eb			ld de, store_page 
02ed				if DEBUG_STORESE 
02ed					DMARK "SB3" 
02ed f5				push af  
02ee 3a 02 03			ld a, (.dmark)  
02f1 32 7a ee			ld (debug_mark),a  
02f4 3a 03 03			ld a, (.dmark+1)  
02f7 32 7b ee			ld (debug_mark+1),a  
02fa 3a 04 03			ld a, (.dmark+2)  
02fd 32 7c ee			ld (debug_mark+2),a  
0300 18 03			jr .pastdmark  
0302 ..			.dmark: db "SB3"  
0305 f1			.pastdmark: pop af  
0306			endm  
# End of macro DMARK
0306			;		push af 
0306			;		ld a, 'F' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306					CALLMONITOR 
0306 cd 80 13			call break_point_state  
0309				endm  
# End of macro CALLMONITOR
0309				endif 
0309 cd 16 02			call storage_write_block 
030c				if DEBUG_STORESE 
030c					DMARK "SB4" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 7a ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 7b ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 7c ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SB4"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			;		push af 
0325			;		ld a, '>' 
0325			;		ld (debug_mark),a 
0325			;		pop af 
0325					CALLMONITOR 
0325 cd 80 13			call break_point_state  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328			 
0328 00				nop 
0329 00				nop 
032a 00				nop 
032b			 
032b				; now set 0 in every page to mark as a free block 
032b			 
032b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
032d 21 40 00			ld hl, STORE_BLOCK_PHY 
0330			 
0330 3e 00		.setmark1:   	ld a,0 
0332 e5					push hl 
0333 c5					push bc 
0334 cd af 01				call se_writebyte 
0337 3e 0a			ld a, 10 
0339 cd c7 08			call aDelayInMS 
033c 23				inc hl 
033d cd af 01				call se_writebyte 
0340 3e 0a			ld a, 10 
0342 cd c7 08			call aDelayInMS 
0345 2b				dec hl 
0346 c1					pop bc 
0347 e1					pop hl 
0348 3e 40				ld a, STORE_BLOCK_PHY 
034a cd 68 0b				call addatohl 
034d 10 e1				djnz .setmark1 
034f			 
034f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0351 3e 00		.setmark2:   	ld a,0 
0353 e5					push hl 
0354 c5					push bc 
0355 cd af 01				call se_writebyte 
0358 3e 0a			ld a, 10 
035a cd c7 08			call aDelayInMS 
035d 23				inc hl 
035e cd af 01				call se_writebyte 
0361 3e 0a			ld a, 10 
0363 cd c7 08			call aDelayInMS 
0366 2b				dec hl 
0367 c1					pop bc 
0368 e1					pop hl 
0369 3e 40				ld a, STORE_BLOCK_PHY 
036b cd 68 0b				call addatohl 
036e 10 e1				djnz .setmark2 
0370			 
0370					 
0370			 
0370			 
0370 c9				ret 
0371			 
0371			 
0371			 
0371			 
0371 .. 00		.defaultbanklabl:   db "BankLabel",0 
037b			 
037b			 
037b			 
037b			; Label Bank 
037b			; ---------- 
037b			; 
037b			; With current bank 
037b			; Read block 0 
037b			; Set label 
037b			; Write block 0 
037b			 
037b			; label str pointer in hl 
037b			 
037b			storage_label:     
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "LBL" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 7a ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 7b ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 7c ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "LBL"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					CALLMONITOR 
0394 cd 80 13			call break_point_state  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 e5				push hl 
0398			 
0398 cd 62 02			call storage_get_block_0 
039b			 
039b				; set default label 
039b			 
039b e1				pop hl 
039c			 
039c 11 68 eb		 	ld de, store_page+3 
039f 01 0f 00			ld bc, 15 
03a2				if DEBUG_STORESE 
03a2					DMARK "LB3" 
03a2 f5				push af  
03a3 3a b7 03			ld a, (.dmark)  
03a6 32 7a ee			ld (debug_mark),a  
03a9 3a b8 03			ld a, (.dmark+1)  
03ac 32 7b ee			ld (debug_mark+1),a  
03af 3a b9 03			ld a, (.dmark+2)  
03b2 32 7c ee			ld (debug_mark+2),a  
03b5 18 03			jr .pastdmark  
03b7 ..			.dmark: db "LB3"  
03ba f1			.pastdmark: pop af  
03bb			endm  
# End of macro DMARK
03bb					CALLMONITOR 
03bb cd 80 13			call break_point_state  
03be				endm  
# End of macro CALLMONITOR
03be				endif 
03be ed b0			ldir 
03c0				; save default page 0 
03c0			 
03c0 21 00 00			ld hl, 0 
03c3 11 65 eb			ld de, store_page 
03c6				if DEBUG_STORESE 
03c6					DMARK "LBW" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 7a ee			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 7b ee			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 7c ee			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "LBW"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df					CALLMONITOR 
03df cd 80 13			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2 cd 16 02			call storage_write_block 
03e5			 
03e5 c9				ret 
03e6			 
03e6			 
03e6			 
03e6			; Read Block 0 - Config 
03e6			; --------------------- 
03e6			; 
03e6			; With current bank 
03e6			; Call presence test 
03e6			;    If not present format/init bank  
03e6			; Read block 0  
03e6			;  
03e6			 
03e6			 
03e6			; Dir 
03e6			; --- 
03e6			; 
03e6			; With current bank 
03e6			; Load Block 0 Config 
03e6			; Get max file id number 
03e6			; For each logical block 
03e6			;    Read block read byte 2 
03e6			;      if first block of file 
03e6			;         Display file name 
03e6			;         Display type flags for file 
03e6			;        
03e6			 
03e6			; moving to words as this requires stack control 
03e6			 
03e6			 
03e6			; Delete File 
03e6			; ----------- 
03e6			; 
03e6			; With current bank 
03e6			; 
03e6			; Load Block 0 Config 
03e6			; Get max file id number 
03e6			; For each logical block 
03e6			;    Read block file id 
03e6			;      If first block of file and dont have file id 
03e6			;         if file to delete 
03e6			;         Save file id 
03e6			;         Null file id 
03e6			;         Write this block back 
03e6			;      If file id is one saved 
03e6			;         Null file id 
03e6			;         Write this block back 
03e6			 
03e6			storage_erase: 
03e6			 
03e6				; hl contains the file id 
03e6			 
03e6 5d				ld e, l 
03e7 16 00			ld d, 0 
03e9 21 40 00			ld hl, STORE_BLOCK_PHY 
03ec					if DEBUG_FORTH_WORDS 
03ec						DMARK "ERA" 
03ec f5				push af  
03ed 3a 01 04			ld a, (.dmark)  
03f0 32 7a ee			ld (debug_mark),a  
03f3 3a 02 04			ld a, (.dmark+1)  
03f6 32 7b ee			ld (debug_mark+1),a  
03f9 3a 03 04			ld a, (.dmark+2)  
03fc 32 7c ee			ld (debug_mark+2),a  
03ff 18 03			jr .pastdmark  
0401 ..			.dmark: db "ERA"  
0404 f1			.pastdmark: pop af  
0405			endm  
# End of macro DMARK
0405						CALLMONITOR 
0405 cd 80 13			call break_point_state  
0408				endm  
# End of macro CALLMONITOR
0408					endif 
0408 cd c7 04			call storage_findnextid 
040b			 
040b e5				push hl 
040c			 
040c				; TODO check file not found 
040c			 
040c 11 65 eb			ld de, store_page 
040f cd b1 01			call storage_read_block 
0412			 
0412					if DEBUG_FORTH_WORDS 
0412						DMARK "ER1" 
0412 f5				push af  
0413 3a 27 04			ld a, (.dmark)  
0416 32 7a ee			ld (debug_mark),a  
0419 3a 28 04			ld a, (.dmark+1)  
041c 32 7b ee			ld (debug_mark+1),a  
041f 3a 29 04			ld a, (.dmark+2)  
0422 32 7c ee			ld (debug_mark+2),a  
0425 18 03			jr .pastdmark  
0427 ..			.dmark: db "ER1"  
042a f1			.pastdmark: pop af  
042b			endm  
# End of macro DMARK
042b						CALLMONITOR 
042b cd 80 13			call break_point_state  
042e				endm  
# End of macro CALLMONITOR
042e					endif 
042e 3a 65 eb			ld a, (store_page)	; get file id 
0431 32 5e eb			ld (store_tmpid), a 
0434			 
0434 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0437 32 5d eb			ld (store_tmpext), a 
043a			 
043a				; wipe file header 
043a			 
043a e1				pop hl 
043b 3e 00			ld a, 0 
043d 32 65 eb			ld (store_page), a 
0440 32 66 eb			ld (store_page+1),a 
0443 11 65 eb			ld de, store_page 
0446					if DEBUG_FORTH_WORDS 
0446						DMARK "ER2" 
0446 f5				push af  
0447 3a 5b 04			ld a, (.dmark)  
044a 32 7a ee			ld (debug_mark),a  
044d 3a 5c 04			ld a, (.dmark+1)  
0450 32 7b ee			ld (debug_mark+1),a  
0453 3a 5d 04			ld a, (.dmark+2)  
0456 32 7c ee			ld (debug_mark+2),a  
0459 18 03			jr .pastdmark  
045b ..			.dmark: db "ER2"  
045e f1			.pastdmark: pop af  
045f			endm  
# End of macro DMARK
045f						CALLMONITOR 
045f cd 80 13			call break_point_state  
0462				endm  
# End of macro CALLMONITOR
0462					endif 
0462 cd 16 02			call storage_write_block 
0465			 
0465			 
0465				; wipe file extents 
0465			 
0465 3a 5d eb			ld a, (store_tmpext) 
0468 47				ld b, a 
0469			 
0469			.eraext:	  
0469 c5				push bc 
046a			 
046a 21 40 00			ld hl, STORE_BLOCK_PHY 
046d 3a 5e eb			ld a,(store_tmpid) 
0470 5f				ld e, a 
0471 50				ld d, b	 
0472					if DEBUG_FORTH_WORDS 
0472						DMARK "ER3" 
0472 f5				push af  
0473 3a 87 04			ld a, (.dmark)  
0476 32 7a ee			ld (debug_mark),a  
0479 3a 88 04			ld a, (.dmark+1)  
047c 32 7b ee			ld (debug_mark+1),a  
047f 3a 89 04			ld a, (.dmark+2)  
0482 32 7c ee			ld (debug_mark+2),a  
0485 18 03			jr .pastdmark  
0487 ..			.dmark: db "ER3"  
048a f1			.pastdmark: pop af  
048b			endm  
# End of macro DMARK
048b						CALLMONITOR 
048b cd 80 13			call break_point_state  
048e				endm  
# End of macro CALLMONITOR
048e					endif 
048e cd c7 04			call storage_findnextid 
0491			 
0491 e5				push hl 
0492 11 65 eb			ld de, store_page 
0495 cd b1 01			call storage_read_block 
0498			 
0498				; free block	 
0498			 
0498 3e 00			ld a, 0 
049a 32 65 eb			ld (store_page), a 
049d 32 66 eb			ld (store_page+1),a 
04a0 11 65 eb			ld de, store_page 
04a3 e1				pop hl 
04a4					if DEBUG_FORTH_WORDS 
04a4						DMARK "ER4" 
04a4 f5				push af  
04a5 3a b9 04			ld a, (.dmark)  
04a8 32 7a ee			ld (debug_mark),a  
04ab 3a ba 04			ld a, (.dmark+1)  
04ae 32 7b ee			ld (debug_mark+1),a  
04b1 3a bb 04			ld a, (.dmark+2)  
04b4 32 7c ee			ld (debug_mark+2),a  
04b7 18 03			jr .pastdmark  
04b9 ..			.dmark: db "ER4"  
04bc f1			.pastdmark: pop af  
04bd			endm  
# End of macro DMARK
04bd						CALLMONITOR 
04bd cd 80 13			call break_point_state  
04c0				endm  
# End of macro CALLMONITOR
04c0					endif 
04c0 cd 16 02			call storage_write_block 
04c3			 
04c3 c1				pop bc 
04c4 10 a3			djnz .eraext 
04c6			 
04c6 c9				ret 
04c7			 
04c7			 
04c7			; Find Free Block 
04c7			; --------------- 
04c7			; 
04c7			; With current bank 
04c7			;  
04c7			; From given starting logical block 
04c7			;    Read block  
04c7			;    If no file id 
04c7			;         Return block id 
04c7			 
04c7			 
04c7			; hl starting page number 
04c7			; hl contains free page number or zero if no pages free 
04c7			; e contains the file id to locate 
04c7			; d contains the block number 
04c7			 
04c7			; TODO change to find file id and use zero for free block 
04c7			 
04c7			storage_findnextid: 
04c7			 
04c7				; now locate first 0 page to mark as a free block 
04c7			 
04c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04c9			;	ld hl, STORE_BLOCK_PHY 
04c9			 
04c9					if DEBUG_FORTH_WORDS 
04c9					DMARK "FNI" 
04c9 f5				push af  
04ca 3a de 04			ld a, (.dmark)  
04cd 32 7a ee			ld (debug_mark),a  
04d0 3a df 04			ld a, (.dmark+1)  
04d3 32 7b ee			ld (debug_mark+1),a  
04d6 3a e0 04			ld a, (.dmark+2)  
04d9 32 7c ee			ld (debug_mark+2),a  
04dc 18 03			jr .pastdmark  
04de ..			.dmark: db "FNI"  
04e1 f1			.pastdmark: pop af  
04e2			endm  
# End of macro DMARK
04e2						CALLMONITOR 
04e2 cd 80 13			call break_point_state  
04e5				endm  
# End of macro CALLMONITOR
04e5					endif 
04e5			.ff1:   	 
04e5 e5					push hl 
04e6 c5					push bc 
04e7 d5					push de 
04e8 cd ae 01				call se_readbyte 
04eb 5f					ld e,a 
04ec 23					inc hl 
04ed cd ae 01				call se_readbyte 
04f0 57					ld d, a 
04f1 e1					pop hl 
04f2 e5					push hl 
04f3 cd 86 0b				call cmp16 
04f6 28 49				jr z, .fffound 
04f8			 
04f8 d1					pop de 
04f9 c1					pop bc 
04fa e1					pop hl 
04fb			 
04fb					; is found? 
04fb					;cp e 
04fb					;ret z 
04fb			 
04fb 3e 40				ld a, STORE_BLOCK_PHY 
04fd cd 68 0b				call addatohl 
0500 10 e3				djnz .ff1 
0502			 
0502 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0504			.ff2:   	 
0504			 
0504 e5					push hl 
0505 c5					push bc 
0506 d5					push de 
0507 cd ae 01				call se_readbyte 
050a 5f					ld e,a 
050b 23					inc hl 
050c cd ae 01				call se_readbyte 
050f 57					ld d, a 
0510			 
0510 e1					pop hl 
0511 e5					push hl 
0512 cd 86 0b				call cmp16 
0515 28 2a				jr z, .fffound 
0517			 
0517 d1					pop de 
0518 c1					pop bc 
0519 e1					pop hl 
051a					; is found? 
051a					;cp e 
051a					;ret z 
051a			 
051a 3e 40				ld a, STORE_BLOCK_PHY 
051c cd 68 0b				call addatohl 
051f 10 e3				djnz .ff2 
0521			 
0521			 
0521					if DEBUG_FORTH_WORDS 
0521					DMARK "FN-" 
0521 f5				push af  
0522 3a 36 05			ld a, (.dmark)  
0525 32 7a ee			ld (debug_mark),a  
0528 3a 37 05			ld a, (.dmark+1)  
052b 32 7b ee			ld (debug_mark+1),a  
052e 3a 38 05			ld a, (.dmark+2)  
0531 32 7c ee			ld (debug_mark+2),a  
0534 18 03			jr .pastdmark  
0536 ..			.dmark: db "FN-"  
0539 f1			.pastdmark: pop af  
053a			endm  
# End of macro DMARK
053a					;	push af 
053a					;	ld a, 'n' 
053a					;	ld (debug_mark),a 
053a					;	pop af 
053a						CALLMONITOR 
053a cd 80 13			call break_point_state  
053d				endm  
# End of macro CALLMONITOR
053d					endif 
053d				; no free marks! 
053d 21 00 00				ld hl, 0 
0540 c9				ret 
0541			.fffound: 
0541				 
0541			 
0541 d1					pop de 
0542 c1					pop bc 
0543 e1					pop hl 
0544					if DEBUG_FORTH_WORDS 
0544					DMARK "FNF" 
0544 f5				push af  
0545 3a 59 05			ld a, (.dmark)  
0548 32 7a ee			ld (debug_mark),a  
054b 3a 5a 05			ld a, (.dmark+1)  
054e 32 7b ee			ld (debug_mark+1),a  
0551 3a 5b 05			ld a, (.dmark+2)  
0554 32 7c ee			ld (debug_mark+2),a  
0557 18 03			jr .pastdmark  
0559 ..			.dmark: db "FNF"  
055c f1			.pastdmark: pop af  
055d			endm  
# End of macro DMARK
055d					;	push af 
055d					;	ld a, 'n' 
055d					;	ld (debug_mark),a 
055d					;	pop af 
055d						CALLMONITOR 
055d cd 80 13			call break_point_state  
0560				endm  
# End of macro CALLMONITOR
0560					endif 
0560 c9				ret 
0561			 
0561			 
0561			 
0561			; Free Space 
0561			; ---------- 
0561			; 
0561			; With current bank 
0561			; 
0561			; Set block count to zero 
0561			; Starting with first logical block 
0561			;      Find free block  
0561			;      If block id given, increment block count 
0561			; 
0561			;  
0561			 
0561			 
0561			; hl contains count of free blocks 
0561			 
0561			storage_freeblocks: 
0561			 
0561				; now locate first 0 page to mark as a free block 
0561			 
0561 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0563 21 40 00			ld hl, STORE_BLOCK_PHY 
0566 11 00 00			ld de, 0 
0569			 
0569			.fb1:   	 
0569 e5					push hl 
056a c5					push bc 
056b d5					push de 
056c cd ae 01				call se_readbyte 
056f d1					pop de 
0570 c1					pop bc 
0571 e1					pop hl 
0572			 
0572					; is free? 
0572 fe 00				cp 0 
0574 20 01				jr nz, .ff1cont 
0576 13					inc de 
0577			 
0577			.ff1cont: 
0577			 
0577			 
0577 3e 40				ld a, STORE_BLOCK_PHY 
0579 cd 68 0b				call addatohl 
057c 10 eb				djnz .fb1 
057e			 
057e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0580			.fb2:   	 
0580 e5					push hl 
0581 c5					push bc 
0582 d5					push de 
0583 cd ae 01				call se_readbyte 
0586 d1					pop de 
0587 c1					pop bc 
0588 e1					pop hl 
0589			 
0589					; is free? 
0589 fe 00				cp 0 
058b 20 01				jr nz, .ff2cont 
058d 13					inc de 
058e			 
058e			.ff2cont: 
058e			 
058e 3e 40				ld a, STORE_BLOCK_PHY 
0590 cd 68 0b				call addatohl 
0593 10 eb				djnz .fb2 
0595			 
0595 eb				ex de, hl 
0596 c9				ret 
0597			 
0597			; Get File ID 
0597			; ----------- 
0597			; 
0597			; With current bank 
0597			;  
0597			; Load Block 0 Config 
0597			; Get max file id number 
0597			; For each logical block 
0597			;    Read block file id 
0597			;      If first block of file and dont have file id 
0597			;         if file get id and exit 
0597			 
0597			 
0597			 
0597			 
0597			; Create File 
0597			; ----------- 
0597			; 
0597			; With current bank  
0597			; Load Block 0 Config 
0597			; Get max file id number 
0597			; Increment file id number 
0597			; Save Config 
0597			; Find free block 
0597			; Set buffer with file name and file id 
0597			; Write buffer to free block  
0597			 
0597			 
0597			; hl point to file name 
0597			; hl returns file id 
0597			 
0597			; file format: 
0597			; byte 0 - file id 
0597			; byte 1 - extent number 
0597			; byte 2-> data 
0597			 
0597			; format for extent number 0: 
0597			; 
0597			; byte 0 - file id 
0597			; byte 1 - extent 0 
0597			; byte 2 - extent count 
0597			; byte 3 -> file name and meta data 
0597			 
0597			 
0597			storage_create: 
0597				if DEBUG_STORESE 
0597					DMARK "SCR" 
0597 f5				push af  
0598 3a ac 05			ld a, (.dmark)  
059b 32 7a ee			ld (debug_mark),a  
059e 3a ad 05			ld a, (.dmark+1)  
05a1 32 7b ee			ld (debug_mark+1),a  
05a4 3a ae 05			ld a, (.dmark+2)  
05a7 32 7c ee			ld (debug_mark+2),a  
05aa 18 03			jr .pastdmark  
05ac ..			.dmark: db "SCR"  
05af f1			.pastdmark: pop af  
05b0			endm  
# End of macro DMARK
05b0					CALLMONITOR 
05b0 cd 80 13			call break_point_state  
05b3				endm  
# End of macro CALLMONITOR
05b3				endif 
05b3			 
05b3 e5				push hl		; save file name pointer 
05b4			 
05b4 cd 62 02			call storage_get_block_0 
05b7			 
05b7 3a 65 eb			ld a,(store_page)	; get current file id 
05ba 3c				inc a 
05bb 32 65 eb			ld (store_page),a 
05be				 
05be 32 5e eb			ld (store_tmpid),a			; save id 
05c1			 
05c1 21 00 00			ld hl, 0 
05c4 11 65 eb			ld de, store_page 
05c7				if DEBUG_STORESE 
05c7					DMARK "SCw" 
05c7 f5				push af  
05c8 3a dc 05			ld a, (.dmark)  
05cb 32 7a ee			ld (debug_mark),a  
05ce 3a dd 05			ld a, (.dmark+1)  
05d1 32 7b ee			ld (debug_mark+1),a  
05d4 3a de 05			ld a, (.dmark+2)  
05d7 32 7c ee			ld (debug_mark+2),a  
05da 18 03			jr .pastdmark  
05dc ..			.dmark: db "SCw"  
05df f1			.pastdmark: pop af  
05e0			endm  
# End of macro DMARK
05e0					CALLMONITOR 
05e0 cd 80 13			call break_point_state  
05e3				endm  
# End of macro CALLMONITOR
05e3				endif 
05e3 cd 16 02			call storage_write_block	 ; save update 
05e6			 
05e6				if DEBUG_STORESE 
05e6 11 65 eb				ld de, store_page 
05e9					DMARK "SCC" 
05e9 f5				push af  
05ea 3a fe 05			ld a, (.dmark)  
05ed 32 7a ee			ld (debug_mark),a  
05f0 3a ff 05			ld a, (.dmark+1)  
05f3 32 7b ee			ld (debug_mark+1),a  
05f6 3a 00 06			ld a, (.dmark+2)  
05f9 32 7c ee			ld (debug_mark+2),a  
05fc 18 03			jr .pastdmark  
05fe ..			.dmark: db "SCC"  
0601 f1			.pastdmark: pop af  
0602			endm  
# End of macro DMARK
0602					CALLMONITOR 
0602 cd 80 13			call break_point_state  
0605				endm  
# End of macro CALLMONITOR
0605				endif 
0605				;  
0605				 
0605 21 40 00			ld hl, STORE_BLOCK_PHY 
0608 11 00 00			ld de, 0 
060b cd c7 04			call storage_findnextid 
060e			 
060e 22 63 eb			ld (store_tmppageid), hl    ; save page to use  
0611			 
0611				; TODO detect 0 = no spare blocks 
0611			 
0611				; hl now contains the free page to use for the file header page 
0611			 
0611				if DEBUG_STORESE 
0611				DMARK "SCF" 
0611 f5				push af  
0612 3a 26 06			ld a, (.dmark)  
0615 32 7a ee			ld (debug_mark),a  
0618 3a 27 06			ld a, (.dmark+1)  
061b 32 7b ee			ld (debug_mark+1),a  
061e 3a 28 06			ld a, (.dmark+2)  
0621 32 7c ee			ld (debug_mark+2),a  
0624 18 03			jr .pastdmark  
0626 ..			.dmark: db "SCF"  
0629 f1			.pastdmark: pop af  
062a			endm  
# End of macro DMARK
062a					CALLMONITOR 
062a cd 80 13			call break_point_state  
062d				endm  
# End of macro CALLMONITOR
062d				endif 
062d			 
062d 22 63 eb			ld (store_tmppageid), hl 
0630				 
0630 3a 5e eb			ld a,(store_tmpid)    ; get file id 
0633			;	ld a, (store_filecache)			; save to cache 
0633			 
0633 32 65 eb			ld (store_page),a    ; set page id 
0636 3e 00			ld a, 0			 ; extent 0 is file header 
0638 32 66 eb			ld (store_page+1), a   ; set file extent 
063b			 
063b 32 67 eb			ld (store_page+2), a   ; extent count for the file 
063e			 
063e			;	inc hl 		; init block 0 of file 
063e			;	inc hl   		; skip file and extent id 
063e			 ;       ld a, 0 
063e			;	ld (hl),a 
063e			;	ld a, (store_filecache+1)  	; save to cache 
063e			 
063e			;	inc hl    ; file name 
063e				 
063e				 
063e 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0641				if DEBUG_STORESE 
0641					DMARK "SCc" 
0641 f5				push af  
0642 3a 56 06			ld a, (.dmark)  
0645 32 7a ee			ld (debug_mark),a  
0648 3a 57 06			ld a, (.dmark+1)  
064b 32 7b ee			ld (debug_mark+1),a  
064e 3a 58 06			ld a, (.dmark+2)  
0651 32 7c ee			ld (debug_mark+2),a  
0654 18 03			jr .pastdmark  
0656 ..			.dmark: db "SCc"  
0659 f1			.pastdmark: pop af  
065a			endm  
# End of macro DMARK
065a					CALLMONITOR 
065a cd 80 13			call break_point_state  
065d				endm  
# End of macro CALLMONITOR
065d				endif 
065d e1				pop hl    ; get zero term string 
065e e5				push hl 
065f 3e 00			ld a, 0 
0661 cd d1 0f			call strlent 
0664 23				inc hl   ; cover zero term 
0665 06 00			ld b,0 
0667 4d				ld c,l 
0668 e1				pop hl 
0669				;ex de, hl 
0669				if DEBUG_STORESE 
0669					DMARK "SCa" 
0669 f5				push af  
066a 3a 7e 06			ld a, (.dmark)  
066d 32 7a ee			ld (debug_mark),a  
0670 3a 7f 06			ld a, (.dmark+1)  
0673 32 7b ee			ld (debug_mark+1),a  
0676 3a 80 06			ld a, (.dmark+2)  
0679 32 7c ee			ld (debug_mark+2),a  
067c 18 03			jr .pastdmark  
067e ..			.dmark: db "SCa"  
0681 f1			.pastdmark: pop af  
0682			endm  
# End of macro DMARK
0682					;push af 
0682					;ld a, 'a' 
0682					;ld (debug_mark),a 
0682					;pop af 
0682					CALLMONITOR 
0682 cd 80 13			call break_point_state  
0685				endm  
# End of macro CALLMONITOR
0685				endif 
0685 ed b0			ldir    ; copy zero term string 
0687				if DEBUG_STORESE 
0687					DMARK "SCA" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 7a ee			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 7b ee			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 7c ee			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "SCA"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					CALLMONITOR 
06a0 cd 80 13			call break_point_state  
06a3				endm  
# End of macro CALLMONITOR
06a3				endif 
06a3			 
06a3				; write file header page 
06a3			 
06a3 2a 63 eb			ld hl,(store_tmppageid) 
06a6 11 65 eb			ld de, store_page 
06a9				if DEBUG_STORESE 
06a9					DMARK "SCb" 
06a9 f5				push af  
06aa 3a be 06			ld a, (.dmark)  
06ad 32 7a ee			ld (debug_mark),a  
06b0 3a bf 06			ld a, (.dmark+1)  
06b3 32 7b ee			ld (debug_mark+1),a  
06b6 3a c0 06			ld a, (.dmark+2)  
06b9 32 7c ee			ld (debug_mark+2),a  
06bc 18 03			jr .pastdmark  
06be ..			.dmark: db "SCb"  
06c1 f1			.pastdmark: pop af  
06c2			endm  
# End of macro DMARK
06c2					;push af 
06c2					;ld a, 'b' 
06c2					;ld (debug_mark),a 
06c2					;pop af 
06c2					CALLMONITOR 
06c2 cd 80 13			call break_point_state  
06c5				endm  
# End of macro CALLMONITOR
06c5				endif 
06c5 cd 16 02			call storage_write_block 
06c8			 
06c8 3a 5e eb			ld a, (store_tmpid) 
06cb 6f				ld l, a 
06cc 26 00			ld h,0 
06ce				if DEBUG_STORESE 
06ce					DMARK "SCz" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 7a ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 7b ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 7c ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCz"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 80 13			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea c9				ret 
06eb				 
06eb			 
06eb			 
06eb			; 
06eb			; Read File 
06eb			; 
06eb			; h - file id to locate 
06eb			; l - extent to locate 
06eb			; de - pointer to string to read into 
06eb			; 
06eb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06eb			storage_read: 
06eb d5				push de 
06ec			 
06ec			; TODO BUG the above push is it popped before the RET Z? 
06ec			 
06ec			; TODO how to handle multiple part blocks 
06ec			 
06ec				; locate file extent to read 
06ec			 
06ec 5c				ld e, h 
06ed 55				ld d, l 
06ee 21 40 00			ld hl, STORE_BLOCK_PHY 
06f1				if DEBUG_STORESE 
06f1					DMARK "SRE" 
06f1 f5				push af  
06f2 3a 06 07			ld a, (.dmark)  
06f5 32 7a ee			ld (debug_mark),a  
06f8 3a 07 07			ld a, (.dmark+1)  
06fb 32 7b ee			ld (debug_mark+1),a  
06fe 3a 08 07			ld a, (.dmark+2)  
0701 32 7c ee			ld (debug_mark+2),a  
0704 18 03			jr .pastdmark  
0706 ..			.dmark: db "SRE"  
0709 f1			.pastdmark: pop af  
070a			endm  
# End of macro DMARK
070a					CALLMONITOR 
070a cd 80 13			call break_point_state  
070d				endm  
# End of macro CALLMONITOR
070d				endif 
070d cd c7 04			call storage_findnextid 
0710			 
0710				if DEBUG_STORESE 
0710					DMARK "SRf" 
0710 f5				push af  
0711 3a 25 07			ld a, (.dmark)  
0714 32 7a ee			ld (debug_mark),a  
0717 3a 26 07			ld a, (.dmark+1)  
071a 32 7b ee			ld (debug_mark+1),a  
071d 3a 27 07			ld a, (.dmark+2)  
0720 32 7c ee			ld (debug_mark+2),a  
0723 18 03			jr .pastdmark  
0725 ..			.dmark: db "SRf"  
0728 f1			.pastdmark: pop af  
0729			endm  
# End of macro DMARK
0729					CALLMONITOR 
0729 cd 80 13			call break_point_state  
072c				endm  
# End of macro CALLMONITOR
072c				endif 
072c cd 91 0b			call ishlzero 
072f			;	ld a, l 
072f			;	add h 
072f			;	cp 0 
072f c8				ret z			; block not found so EOF 
0730			 
0730				; hl contains page number to load 
0730 d1				pop de   ; get storage 
0731 d5				push de 
0732				if DEBUG_STORESE 
0732					DMARK "SRg" 
0732 f5				push af  
0733 3a 47 07			ld a, (.dmark)  
0736 32 7a ee			ld (debug_mark),a  
0739 3a 48 07			ld a, (.dmark+1)  
073c 32 7b ee			ld (debug_mark+1),a  
073f 3a 49 07			ld a, (.dmark+2)  
0742 32 7c ee			ld (debug_mark+2),a  
0745 18 03			jr .pastdmark  
0747 ..			.dmark: db "SRg"  
074a f1			.pastdmark: pop af  
074b			endm  
# End of macro DMARK
074b					CALLMONITOR 
074b cd 80 13			call break_point_state  
074e				endm  
# End of macro CALLMONITOR
074e				endif 
074e cd b1 01			call storage_read_block 
0751			 
0751			 
0751			; TODO if block has no zeros then need to read next block  
0751			 
0751			 
0751					 
0751 e1				pop hl 		 ; return start of data to show as not EOF 
0752 23				inc hl   ; past file id 
0753 23				inc hl   ; past ext 
0754				if DEBUG_STORESE 
0754					DMARK "SRe" 
0754 f5				push af  
0755 3a 69 07			ld a, (.dmark)  
0758 32 7a ee			ld (debug_mark),a  
075b 3a 6a 07			ld a, (.dmark+1)  
075e 32 7b ee			ld (debug_mark+1),a  
0761 3a 6b 07			ld a, (.dmark+2)  
0764 32 7c ee			ld (debug_mark+2),a  
0767 18 03			jr .pastdmark  
0769 ..			.dmark: db "SRe"  
076c f1			.pastdmark: pop af  
076d			endm  
# End of macro DMARK
076d					CALLMONITOR 
076d cd 80 13			call break_point_state  
0770				endm  
# End of macro CALLMONITOR
0770				endif 
0770 c9					ret 
0771			 
0771			 
0771			 
0771			; 
0771			; Append File 
0771			; 
0771			; hl - file id to locate 
0771			; de - pointer to (multi block) string to write 
0771			 
0771			 
0771			storage_append: 
0771				; hl -  file id to append to 
0771				; de - string to append 
0771			 
0771 d5				push de 
0772				 
0772				if DEBUG_STORESE 
0772					DMARK "AP1" 
0772 f5				push af  
0773 3a 87 07			ld a, (.dmark)  
0776 32 7a ee			ld (debug_mark),a  
0779 3a 88 07			ld a, (.dmark+1)  
077c 32 7b ee			ld (debug_mark+1),a  
077f 3a 89 07			ld a, (.dmark+2)  
0782 32 7c ee			ld (debug_mark+2),a  
0785 18 03			jr .pastdmark  
0787 ..			.dmark: db "AP1"  
078a f1			.pastdmark: pop af  
078b			endm  
# End of macro DMARK
078b					CALLMONITOR 
078b cd 80 13			call break_point_state  
078e				endm  
# End of macro CALLMONITOR
078e				endif 
078e			 
078e 7d				ld a, l 
078f 32 5e eb			ld (store_tmpid), a 
0792			 
0792				; get file header  
0792			 
0792 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0794 3a 5e eb			ld a, (store_tmpid) 
0797 5f				ld e, a 
0798			 
0798 21 40 00				ld hl, STORE_BLOCK_PHY 
079b cd c7 04				call storage_findnextid 
079e			 
079e 22 63 eb			ld (store_tmppageid), hl 
07a1			 
07a1				; TODO handle file id not found 
07a1			 
07a1				if DEBUG_STORESE 
07a1					DMARK "AP2" 
07a1 f5				push af  
07a2 3a b6 07			ld a, (.dmark)  
07a5 32 7a ee			ld (debug_mark),a  
07a8 3a b7 07			ld a, (.dmark+1)  
07ab 32 7b ee			ld (debug_mark+1),a  
07ae 3a b8 07			ld a, (.dmark+2)  
07b1 32 7c ee			ld (debug_mark+2),a  
07b4 18 03			jr .pastdmark  
07b6 ..			.dmark: db "AP2"  
07b9 f1			.pastdmark: pop af  
07ba			endm  
# End of macro DMARK
07ba					CALLMONITOR 
07ba cd 80 13			call break_point_state  
07bd				endm  
# End of macro CALLMONITOR
07bd				endif 
07bd			 
07bd				; update file extent count 
07bd			 
07bd 11 65 eb			ld de, store_page 
07c0			 
07c0 cd b1 01			call storage_read_block 
07c3			 
07c3				if DEBUG_STORESE 
07c3					DMARK "AP3" 
07c3 f5				push af  
07c4 3a d8 07			ld a, (.dmark)  
07c7 32 7a ee			ld (debug_mark),a  
07ca 3a d9 07			ld a, (.dmark+1)  
07cd 32 7b ee			ld (debug_mark+1),a  
07d0 3a da 07			ld a, (.dmark+2)  
07d3 32 7c ee			ld (debug_mark+2),a  
07d6 18 03			jr .pastdmark  
07d8 ..			.dmark: db "AP3"  
07db f1			.pastdmark: pop af  
07dc			endm  
# End of macro DMARK
07dc					CALLMONITOR 
07dc cd 80 13			call break_point_state  
07df				endm  
# End of macro CALLMONITOR
07df				endif 
07df			;	ld (store_tmppageid), hl 
07df			 
07df 3a 67 eb			ld a, (store_page+2) 
07e2 3c				inc a 
07e3 32 67 eb			ld (store_page+2), a 
07e6 32 5d eb			ld (store_tmpext), a 
07e9				 
07e9				if DEBUG_STORESE 
07e9					DMARK "AP3" 
07e9 f5				push af  
07ea 3a fe 07			ld a, (.dmark)  
07ed 32 7a ee			ld (debug_mark),a  
07f0 3a ff 07			ld a, (.dmark+1)  
07f3 32 7b ee			ld (debug_mark+1),a  
07f6 3a 00 08			ld a, (.dmark+2)  
07f9 32 7c ee			ld (debug_mark+2),a  
07fc 18 03			jr .pastdmark  
07fe ..			.dmark: db "AP3"  
0801 f1			.pastdmark: pop af  
0802			endm  
# End of macro DMARK
0802					CALLMONITOR 
0802 cd 80 13			call break_point_state  
0805				endm  
# End of macro CALLMONITOR
0805				endif 
0805 2a 63 eb			ld hl, (store_tmppageid) 
0808 11 65 eb			ld de, store_page 
080b cd 16 02			call storage_write_block 
080e			 
080e				; find free block 
080e			 
080e 11 00 00			ld de, 0			 ; file extent to locate 
0811			 
0811 21 40 00				ld hl, STORE_BLOCK_PHY 
0814 cd c7 04				call storage_findnextid 
0817			 
0817					; TODO handle no space left 
0817					 
0817 22 63 eb				ld (store_tmppageid), hl 
081a			 
081a				if DEBUG_STORESE 
081a					DMARK "AP4" 
081a f5				push af  
081b 3a 2f 08			ld a, (.dmark)  
081e 32 7a ee			ld (debug_mark),a  
0821 3a 30 08			ld a, (.dmark+1)  
0824 32 7b ee			ld (debug_mark+1),a  
0827 3a 31 08			ld a, (.dmark+2)  
082a 32 7c ee			ld (debug_mark+2),a  
082d 18 03			jr .pastdmark  
082f ..			.dmark: db "AP4"  
0832 f1			.pastdmark: pop af  
0833			endm  
# End of macro DMARK
0833					CALLMONITOR 
0833 cd 80 13			call break_point_state  
0836				endm  
# End of macro CALLMONITOR
0836				endif 
0836					; init the buffer with zeros so we can id if the buffer is full or not 
0836			 
0836 e5					push hl 
0837 c5					push bc 
0838			 
0838 21 65 eb				ld hl, store_page 
083b 06 40				ld b, STORE_BLOCK_PHY 
083d 3e 00				ld a, 0 
083f 77			.zeroblock:	ld (hl), a 
0840 23					inc hl 
0841 10 fc				djnz .zeroblock 
0843			 
0843 c1					pop bc 
0844 e1					pop hl 
0845			 
0845					; construct block 
0845			 
0845 3a 5e eb				ld a, (store_tmpid) 
0848 32 65 eb				ld (store_page), a   ; file id 
084b 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
084e 32 66 eb				ld (store_page+1), a 
0851			 
0851 e1					pop hl    ; get string to write 
0852 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0854 11 67 eb				ld de, store_page+2 
0857			 
0857				if DEBUG_STORESE 
0857					DMARK "AP5" 
0857 f5				push af  
0858 3a 6c 08			ld a, (.dmark)  
085b 32 7a ee			ld (debug_mark),a  
085e 3a 6d 08			ld a, (.dmark+1)  
0861 32 7b ee			ld (debug_mark+1),a  
0864 3a 6e 08			ld a, (.dmark+2)  
0867 32 7c ee			ld (debug_mark+2),a  
086a 18 03			jr .pastdmark  
086c ..			.dmark: db "AP5"  
086f f1			.pastdmark: pop af  
0870			endm  
# End of macro DMARK
0870					CALLMONITOR 
0870 cd 80 13			call break_point_state  
0873				endm  
# End of macro CALLMONITOR
0873				endif 
0873			 
0873			 
0873			 
0873					; fill buffer with data until end of string or full block 
0873			 
0873 7e			.appd:		ld a, (hl) 
0874 12					ld (de), a 
0875 fe 00				cp 0 
0877 28 04				jr z, .appdone 
0879 23					inc hl 
087a 13					inc de 
087b 10 f6				djnz .appd 
087d			 
087d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
087e f5					push af   		; save last byte dumped 
087f			 
087f			 
087f 2a 63 eb			ld hl, (store_tmppageid) 
0882 11 65 eb			ld de, store_page 
0885				if DEBUG_STORESE 
0885					DMARK "AP6" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 7a ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 7b ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 7c ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "AP6"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 80 13			call break_point_state  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 cd 16 02				call storage_write_block 
08a4			 
08a4			 
08a4				; was that a full block of data written? 
08a4				; any more to write out? 
08a4			 
08a4				; if yes then set vars and jump to start of function again 
08a4			 
08a4 f1					pop af 
08a5 d1					pop de 
08a6			 
08a6 fe 00				cp 0		 ; no, string was fully written 
08a8 c8					ret z 
08a9			 
08a9					; setup vars for next cycle 
08a9			 
08a9 3a 5e eb				ld a, (store_tmpid) 
08ac 6f					ld l, a 
08ad 26 00				ld h, 0 
08af			 
08af c3 71 07			 	jp storage_append	 ; yes, need to write out some more 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			 
08b2			if DEBUG_STORECF 
08b2			storageput:	 
08b2					ret 
08b2			storageread: 
08b2					ld hl, store_page 
08b2					ld b, 200 
08b2					ld a,0 
08b2			.src:		ld (hl),a 
08b2					inc hl 
08b2					djnz .src 
08b2					 
08b2			 
08b2					ld de, 0 
08b2					ld bc, 1 
08b2					ld hl, store_page 
08b2					call cfRead 
08b2			 
08b2				call cfGetError 
08b2				ld hl,scratch 
08b2				call hexout 
08b2				ld hl, scratch+2 
08b2				ld a, 0 
08b2				ld (hl),a 
08b2				ld de, scratch 
08b2				ld a,display_row_1 
08b2				call str_at_display 
08b2				call update_display 
08b2			 
08b2					ld hl, store_page 
08b2					ld (os_cur_ptr),hl 
08b2			 
08b2					ret 
08b2			endif 
08b2			 
08b2			 
08b2			; Clear out the main buffer store (used to remove junk before writing a new block) 
08b2			 
08b2			storage_clear_page: 
08b2 e5				push hl 
08b3 d5				push de 
08b4 c5				push bc 
08b5 21 65 eb			ld hl, store_page 
08b8 3e 00			ld a, 0 
08ba 77				ld (hl), a 
08bb			 
08bb 11 66 eb			ld de, store_page+1 
08be 01 40 00			ld bc, STORE_BLOCK_PHY 
08c1			 
08c1 ed b0			ldir 
08c3				 
08c3 c1				pop bc 
08c4 d1				pop de 
08c5 e1				pop hl 
08c6 c9				ret 
08c7			 
08c7			; eof 
# End of file firmware_storage.asm
08c7			  
08c7			; support routines for above hardware abstraction layer  
08c7			  
08c7			include "firmware_general.asm"        ; general support functions  
08c7			 
08c7			 
08c7			 
08c7			; Delay loops 
08c7			 
08c7			 
08c7			 
08c7			aDelayInMS: 
08c7 c5				push bc 
08c8 47				ld b,a 
08c9			msdelay: 
08c9 c5				push bc 
08ca				 
08ca			 
08ca 01 41 00			ld bc,041h 
08cd cd e5 08			call delayloop 
08d0 c1				pop bc 
08d1 05				dec b 
08d2 20 f5			jr nz,msdelay 
08d4			 
08d4			;if CPU_CLOCK_8MHZ 
08d4			;msdelay8: 
08d4			;	push bc 
08d4			;	 
08d4			; 
08d4			;	ld bc,041h 
08d4			;	call delayloop 
08d4			;	pop bc 
08d4			;	dec b 
08d4			;	jr nz,msdelay8 
08d4			;endif 
08d4			 
08d4			 
08d4 c1				pop bc 
08d5 c9				ret 
08d6			 
08d6			 
08d6			delay250ms: 
08d6				;push de 
08d6 01 00 40			ld bc, 04000h 
08d9 c3 e5 08			jp delayloop 
08dc			delay500ms: 
08dc				;push de 
08dc 01 00 80			ld bc, 08000h 
08df c3 e5 08			jp delayloop 
08e2			delay1s: 
08e2				;push bc 
08e2			   ; Clobbers A, d and e 
08e2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
08e5			delayloop: 
08e5 c5			    push bc 
08e6			 
08e6			if BASE_CPM 
08e6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
08e9			.cpmloop: 
08e9 c5				push bc 
08ea			 
08ea			endif 
08ea			 
08ea			 
08ea			 
08ea			delayloopi: 
08ea			;	push bc 
08ea			;.dl: 
08ea cb 47		    bit     0,a    	; 8 
08ec cb 47		    bit     0,a    	; 8 
08ee cb 47		    bit     0,a    	; 8 
08f0 e6 ff		    and     255  	; 7 
08f2 0b			    dec     bc      	; 6 
08f3 79			    ld      a,c     	; 4 
08f4 b0			    or      b     	; 4 
08f5 c2 ea 08		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
08f8			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
08f8				;pop de 
08f8			;pop bc 
08f8			 
08f8			if BASE_CPM 
08f8 c1				pop bc 
08f9				 
08f9 0b			    dec     bc      	; 6 
08fa 79			    ld      a,c     	; 4 
08fb b0			    or      b     	; 4 
08fc c2 e9 08		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
08ff				 
08ff			 
08ff			endif 
08ff			;if CPU_CLOCK_8MHZ 
08ff			;    pop bc 
08ff			;    push bc 
08ff			;.dl8: 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    and     255  	; 7 
08ff			;    dec     bc      	; 6 
08ff			;    ld      a,c     	; 4 
08ff			;    or      b     	; 4 
08ff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
08ff			;endif 
08ff			 
08ff			;if CPU_CLOCK_10MHZ 
08ff			;    pop bc 
08ff			;    push bc 
08ff			;.dl8: 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    bit     0,a    	; 8 
08ff			;    and     255  	; 7 
08ff			;    dec     bc      	; 6 
08ff			;    ld      a,c     	; 4 
08ff			;    or      b     	; 4 
08ff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
08ff			;endif 
08ff c1			    pop bc 
0900			 
0900 c9				ret 
0901			 
0901			 
0901			 
0901			; eof 
# End of file firmware_general.asm
0901			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0901			; display routines that use the physical hardware abstraction layer 
0901			 
0901			 
0901			; TODO windowing? 
0901			 
0901			; TODO scroll line up 
0901			 
0901			scroll_up: 
0901			 
0901 e5				push hl 
0902 d5				push de 
0903 c5				push bc 
0904			 
0904				; get frame buffer  
0904			 
0904 2a db eb			ld hl, (display_fb_active) 
0907 e5				push hl    ; future de destination 
0908			 
0908 11 28 00			ld  de, display_cols 
090b 19				add hl, de 
090c			 
090c d1				pop de 
090d			 
090d				;ex de, hl 
090d 01 9f 00			ld bc, display_fb_len -1  
0910			;if DEBUG_FORTH_WORDS 
0910			;	DMARK "SCL" 
0910			;	CALLMONITOR 
0910			;endif	 
0910 ed b0			ldir 
0912			 
0912				; wipe bottom row 
0912			 
0912			 
0912 2a db eb			ld hl, (display_fb_active) 
0915 11 a0 00			ld de, display_cols*display_rows 
0918 19				add hl, de 
0919 06 28			ld b, display_cols 
091b 3e 20			ld a, ' ' 
091d			.scwipe: 
091d 77				ld (hl), a 
091e 2b				dec hl 
091f 10 fc			djnz .scwipe 
0921			 
0921				;pop hl 
0921			 
0921 c1				pop bc 
0922 d1				pop de 
0923 e1				pop hl 
0924			 
0924 c9				ret 
0925			 
0925			 
0925			;scroll_upo: 
0925			;	ld de, display_row_1 
0925			 ;	ld hl, display_row_2 
0925			;	ld bc, display_cols 
0925			;	ldir 
0925			;	ld de, display_row_2 
0925			 ;	ld hl, display_row_3 
0925			;	ld bc, display_cols 
0925			;	ldir 
0925			;	ld de, display_row_3 
0925			 ;	ld hl, display_row_4 
0925			;	ld bc, display_cols 
0925			;	ldir 
0925			 
0925			; TODO clear row 4 
0925			 
0925			;	ret 
0925			 
0925				 
0925			scroll_down: 
0925			 
0925 e5				push hl 
0926 d5				push de 
0927 c5				push bc 
0928			 
0928				; get frame buffer  
0928			 
0928 2a db eb			ld hl, (display_fb_active) 
092b			 
092b 11 9f 00			ld de, display_fb_len - 1 
092e 19				add hl, de 
092f			 
092f e5			push hl    ; future de destination 
0930			 
0930 11 28 00			ld  de, display_cols 
0933 ed 52			sbc hl, de 
0935			 
0935			 
0935 d1				pop de 
0936			 
0936			;	ex de, hl 
0936 01 9f 00			ld bc, display_fb_len -1  
0939			 
0939			 
0939				 
0939			 
0939 ed b0			ldir 
093b			 
093b				; wipe bottom row 
093b			 
093b			 
093b			;	ld hl, (display_fb_active) 
093b			;;	ld de, display_cols*display_rows 
093b			;;	add hl, de 
093b			;	ld b, display_cols 
093b			;	ld a, ' ' 
093b			;.scwiped: 
093b			;	ld (hl), a 
093b			;	dec hl 
093b			;	djnz .scwiped 
093b			 
093b				;pop hl 
093b			 
093b c1				pop bc 
093c d1				pop de 
093d e1				pop hl 
093e			 
093e c9				ret 
093f			;scroll_down: 
093f			;	ld de, display_row_4 
093f			;	ld hl, display_row_3 
093f			;	ld bc, display_cols 
093f			;	ldir 
093f			;	ld de, display_row_3 
093f			; 	ld hl, display_row_2 
093f			;	ld bc, display_cols 
093f			;	ldir 
093f			;	ld de, display_row_2 
093f			;	ld hl, display_row_1 
093f			;	ld bc, display_cols 
093f			;	ldir 
093f			;;; TODO clear row 1 
093f			;	ret 
093f			 
093f			 
093f			 
093f			 
093f			 
093f			; clear active frame buffer 
093f			 
093f			clear_display: 
093f 3e 20			ld a, ' ' 
0941 c3 44 09			jp fill_display 
0944			 
0944			; fill active frame buffer with a char in A 
0944			 
0944			fill_display: 
0944 06 a0			ld b,display_fb_len 
0946 2a db eb			ld hl, (display_fb_active) 
0949 77			.fd1:	ld (hl),a 
094a 23				inc hl 
094b 10 fc			djnz .fd1 
094d 23				inc hl 
094e 3e 00			ld a,0 
0950 77				ld (hl),a 
0951			 
0951			 
0951 c9				ret 
0952			; Write string (DE) at pos (A) to active frame buffer 
0952			 
0952 2a db eb		str_at_display:    ld hl,(display_fb_active) 
0955 06 00					ld b,0 
0957 4f					ld c,a 
0958 09					add hl,bc 
0959 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
095a b7			            OR   A              ;Null terminator? 
095b c8			            RET  Z              ;Yes, so finished 
095c 77					ld (hl),a 
095d 23				inc hl 
095e 13			            INC  DE             ;Point to next character 
095f 18 f8		            JR   .sad1     ;Repeat 
0961 c9					ret 
0962			 
0962			; using current frame buffer write to physical display 
0962			 
0962			update_display: 
0962 e5				push hl 
0963 2a db eb			ld hl, (display_fb_active) 
0966 cd 1a 57			call write_display 
0969 e1				pop hl 
096a c9				ret 
096b			 
096b			; TODO scrolling 
096b			 
096b			 
096b			; move cursor right one char 
096b			cursor_right: 
096b			 
096b				; TODO shift right 
096b				; TODO if beyond max col 
096b				; TODO       cursor_next_line 
096b			 
096b c9				ret 
096c			 
096c			 
096c			cursor_next_line: 
096c				; TODO first char 
096c				; TODO line down 
096c				; TODO if past last row 
096c				; TODO    scroll up 
096c			 
096c c9				ret 
096d			 
096d			cursor_left: 
096d				; TODO shift left 
096d				; TODO if beyond left  
096d				; TODO     cursor prev line 
096d				 
096d c9				ret 
096e			 
096e			cursor_prev_line: 
096e				; TODO last char 
096e				; TODO line up 
096e				; TODO if past first row 
096e				; TODO   scroll down 
096e			 
096e c9				ret 
096f			 
096f			 
096f			cout: 
096f				; A - char 
096f c9				ret 
0970			 
0970			 
0970			; Display a menu and allow item selection (optional toggle items) 
0970			; 
0970			; format: 
0970			; hl pointer to word array with zero term for items 
0970			; e.g.    db item1 
0970			;         db .... 
0970			;         db 0 
0970			; 
0970			; a = starting menu item  
0970			; 
0970			; de = pointer item toggle array   (todo) 
0970			; 
0970			; returns item selected in a 1-... 
0970			; returns 0 if back button pressed 
0970			; 
0970			; NOTE: Uses system frame buffer to display 
0970			 
0970			 
0970			 
0970			 
0970			 
0970			 
0970			menu: 
0970			 
0970					; keep array pointer 
0970			 
0970 22 63 eb				ld (store_tmp1), hl 
0973 32 61 eb				ld (store_tmp2), a 
0976			 
0976					; check for key bounce 
0976			 
0976			if BASE_KEV 
0976			 
0976			.mbounce:	call cin 
0976					cp 0 
0976					jr nz, .mbounce 
0976			endif 
0976					; for ease use ex 
0976			 
0976					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0976 21 c0 ed				ld hl, display_fb0 
0979 22 db eb				ld (display_fb_active), hl 
097c			 
097c cd 3f 09		.mloop:		call clear_display 
097f cd 62 09				call update_display 
0982			 
0982					; draw selection id '>' at 1 
0982			 
0982					; init start of list display 
0982			 
0982 3e 05				ld a, 5 
0984 32 5f eb				ld (store_tmp3), a   ; display row count 
0987 3a 61 eb				ld a,( store_tmp2) 
098a 32 62 eb				ld (store_tmp2+1), a   ; display item count 
098d			 
098d					 
098d			.mitem:	 
098d			 
098d			 
098d 3a 62 eb				ld a,(store_tmp2+1) 
0990 6f					ld l, a 
0991 26 00				ld h, 0 
0993 29					add hl, hl 
0994 ed 5b 63 eb			ld de, (store_tmp1) 
0998 19					add hl, de 
0999 7e					ld a, (hl) 
099a 23					inc hl 
099b 66					ld h,(hl) 
099c 6f					ld l, a 
099d			 
099d cd 91 0b				call ishlzero 
09a0 28 1a				jr z, .mdone 
09a2			 
09a2 eb					ex de, hl 
09a3 3a 5f eb				ld a, (store_tmp3) 
09a6 cd 52 09				call str_at_display 
09a9					 
09a9			 
09a9					; next item 
09a9 3a 62 eb				ld a, (store_tmp2+1) 
09ac 3c					inc a 
09ad 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09b0			 
09b0			 		; next row 
09b0			 
09b0 3a 5f eb				ld a, (store_tmp3) 
09b3 c6 28				add display_cols 
09b5 32 5f eb				ld (store_tmp3), a 
09b8			 
09b8					; at end of screen? 
09b8			 
09b8 fe 10				cp display_rows*4 
09ba 20 d1				jr nz, .mitem 
09bc			 
09bc			 
09bc			.mdone: 
09bc cd 91 0b				call ishlzero 
09bf 28 08				jr z, .nodn 
09c1			 
09c1 3e 78				ld a, display_row_4 
09c3 11 3e 0a				ld de, .mdown 
09c6 cd 52 09				call str_at_display 
09c9			 
09c9					; draw options to fill the screens with active item on line 1 
09c9					; if current option is 2 or more then display ^ in top 
09c9			 
09c9 3a 61 eb		.nodn:		ld a, (store_tmp2) 
09cc fe 00				cp 0 
09ce 28 08				jr z, .noup 
09d0			 
09d0 3e 00				ld a, 0 
09d2 11 3c 0a				ld de, .mup 
09d5 cd 52 09				call str_at_display 
09d8			 
09d8 3e 02		.noup:		ld a, 2 
09da 11 3a 0a				ld de, .msel 
09dd cd 52 09				call str_at_display 
09e0			 
09e0					; if current option + 1 is not null then display V in bottom 
09e0					; get key 
09e0 cd 62 09				call update_display 
09e3			 
09e3			 
09e3					; handle key 
09e3			 
09e3 cd cc 57				call cin_wait 
09e6			 
09e6 fe 05				cp KEY_UP 
09e8 28 27				jr z, .mgoup 
09ea fe 61				cp 'a' 
09ec 28 23				jr z, .mgoup 
09ee fe 0a				cp KEY_DOWN 
09f0 28 2e				jr z, .mgod 
09f2 fe 7a				cp 'z' 
09f4 28 2a				jr z, .mgod 
09f6 fe 20				cp ' ' 
09f8 28 30				jr z, .goend 
09fa fe 0d				cp KEY_CR 
09fc 28 2c				jr z, .goend 
09fe fe 71				cp 'q' 
0a00 28 0b				jr z, .goback 
0a02			 
0a02 fe 0b				cp KEY_LEFT 
0a04 28 07				jr z, .goback 
0a06 fe 08				cp KEY_BS 
0a08 28 03				jr z, .goback 
0a0a c3 7c 09				jp .mloop 
0a0d			 
0a0d			.goback: 
0a0d 3e 00			ld a, 0 
0a0f 18 1d			jr .goend2 
0a11			 
0a11				; move up one 
0a11			.mgoup: 
0a11 3a 61 eb				ld a, (store_tmp2) 
0a14 fe 00				cp 0 
0a16 ca 7c 09				jp z, .mloop 
0a19 3d					dec a 
0a1a 32 61 eb				ld (store_tmp2), a 
0a1d c3 7c 09				jp .mloop 
0a20			 
0a20				; move down one 
0a20			.mgod: 
0a20 3a 61 eb				ld a, (store_tmp2) 
0a23 3c					inc a 
0a24 32 61 eb				ld (store_tmp2), a 
0a27 c3 7c 09				jp .mloop 
0a2a			 
0a2a			 
0a2a			.goend: 
0a2a					; get selected item number 
0a2a			 
0a2a 3a 61 eb				ld a, (store_tmp2) 
0a2d 3c					inc a 
0a2e			 
0a2e			.goend2: 
0a2e f5					push af 
0a2f			 
0a2f					; restore active fb 
0a2f					; TODO BUG assumes fb1 
0a2f			 
0a2f 21 1f ed				ld hl, display_fb1 
0a32 22 db eb				ld (display_fb_active), hl 
0a35			 
0a35					; restore main regs 
0a35			 
0a35			 
0a35 cd 62 09				call update_display 
0a38			 
0a38 f1					pop af 
0a39			 
0a39 c9				ret 
0a3a			 
0a3a .. 00		.msel:   db ">",0 
0a3c .. 00		.mup:   db "^",0 
0a3e .. 00		.mdown:   db "v",0 
0a40			 
0a40			 
0a40			; eof 
0a40			 
# End of file firmware_display.asm
0a40			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a40			; random number generators 
0a40			 
0a40			 
0a40			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a40			 
0a40			 
0a40			;-----> Generate a random number 
0a40			; output a=answer 0<=a<=255 
0a40			; all registers are preserved except: af 
0a40			random: 
0a40 e5			        push    hl 
0a41 d5			        push    de 
0a42 2a bd eb		        ld      hl,(randData) 
0a45 ed 5f		        ld      a,r 
0a47 57			        ld      d,a 
0a48 5e			        ld      e,(hl) 
0a49 19			        add     hl,de 
0a4a 85			        add     a,l 
0a4b ac			        xor     h 
0a4c 22 bd eb		        ld      (randData),hl 
0a4f d1			        pop     de 
0a50 e1			        pop     hl 
0a51 c9			        ret 
0a52			 
0a52			 
0a52			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0a52			 
0a52			 
0a52			 
0a52			;------LFSR------ 
0a52			;James Montelongo 
0a52			;optimized by Spencer Putt 
0a52			;out: 
0a52			; a = 8 bit random number 
0a52			RandLFSR: 
0a52 21 c3 eb		        ld hl,LFSRSeed+4 
0a55 5e			        ld e,(hl) 
0a56 23			        inc hl 
0a57 56			        ld d,(hl) 
0a58 23			        inc hl 
0a59 4e			        ld c,(hl) 
0a5a 23			        inc hl 
0a5b 7e			        ld a,(hl) 
0a5c 47			        ld b,a 
0a5d cb 13		        rl e  
0a5f cb 12			rl d 
0a61 cb 11		        rl c  
0a63 17				rla 
0a64 cb 13		        rl e  
0a66 cb 12			rl d 
0a68 cb 11		        rl c  
0a6a 17				rla 
0a6b cb 13		        rl e  
0a6d cb 12			rl d 
0a6f cb 11		        rl c  
0a71 17				rla 
0a72 67			        ld h,a 
0a73 cb 13		        rl e  
0a75 cb 12			rl d 
0a77 cb 11		        rl c  
0a79 17				rla 
0a7a a8			        xor b 
0a7b cb 13		        rl e  
0a7d cb 12			rl d 
0a7f ac			        xor h 
0a80 a9			        xor c 
0a81 aa			        xor d 
0a82 21 c5 eb		        ld hl,LFSRSeed+6 
0a85 11 c6 eb		        ld de,LFSRSeed+7 
0a88 01 07 00		        ld bc,7 
0a8b ed b8		        lddr 
0a8d 12			        ld (de),a 
0a8e c9			        ret 
0a8f			 
0a8f			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0a8f			 
0a8f			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0a8f			 
0a8f			 
0a8f			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0a8f			 
0a8f			prng16: 
0a8f			;Inputs: 
0a8f			;   (seed1) contains a 16-bit seed value 
0a8f			;   (seed2) contains a NON-ZERO 16-bit seed value 
0a8f			;Outputs: 
0a8f			;   HL is the result 
0a8f			;   BC is the result of the LCG, so not that great of quality 
0a8f			;   DE is preserved 
0a8f			;Destroys: 
0a8f			;   AF 
0a8f			;cycle: 4,294,901,760 (almost 4.3 billion) 
0a8f			;160cc 
0a8f			;26 bytes 
0a8f 2a b7 eb		    ld hl,(seed1) 
0a92 44			    ld b,h 
0a93 4d			    ld c,l 
0a94 29			    add hl,hl 
0a95 29			    add hl,hl 
0a96 2c			    inc l 
0a97 09			    add hl,bc 
0a98 22 b7 eb		    ld (seed1),hl 
0a9b 2a b5 eb		    ld hl,(seed2) 
0a9e 29			    add hl,hl 
0a9f 9f			    sbc a,a 
0aa0 e6 2d		    and %00101101 
0aa2 ad			    xor l 
0aa3 6f			    ld l,a 
0aa4 22 b5 eb		    ld (seed2),hl 
0aa7 09			    add hl,bc 
0aa8 c9			    ret 
0aa9			 
0aa9			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0aa9			 
0aa9			rand32: 
0aa9			;Inputs: 
0aa9			;   (seed1_0) holds the lower 16 bits of the first seed 
0aa9			;   (seed1_1) holds the upper 16 bits of the first seed 
0aa9			;   (seed2_0) holds the lower 16 bits of the second seed 
0aa9			;   (seed2_1) holds the upper 16 bits of the second seed 
0aa9			;   **NOTE: seed2 must be non-zero 
0aa9			;Outputs: 
0aa9			;   HL is the result 
0aa9			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0aa9			;Destroys: 
0aa9			;   AF 
0aa9			;Tested and passes all CAcert tests 
0aa9			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0aa9			;it has a period of 18,446,744,069,414,584,320 
0aa9			;roughly 18.4 quintillion. 
0aa9			;LFSR taps: 0,2,6,7  = 11000101 
0aa9			;291cc 
0aa9			;seed1_0=$+1 
0aa9			;    ld hl,12345 
0aa9			;seed1_1=$+1 
0aa9			;    ld de,6789 
0aa9			;    ld b,h 
0aa9			;    ld c,l 
0aa9			;    add hl,hl \ rl e \ rl d 
0aa9			;    add hl,hl \ rl e \ rl d 
0aa9			;    inc l 
0aa9			;    add hl,bc 
0aa9			;    ld (seed1_0),hl 
0aa9			;    ld hl,(seed1_1) 
0aa9			;    adc hl,de 
0aa9			;    ld (seed1_1),hl 
0aa9			;    ex de,hl 
0aa9			;seed2_0=$+1 
0aa9			;    ld hl,9876 
0aa9			;seed2_1=$+1 
0aa9			;    ld bc,54321 
0aa9			;    add hl,hl \ rl c \ rl b 
0aa9			;    ld (seed2_1),bc 
0aa9			;    sbc a,a 
0aa9			;    and %11000101 
0aa9			;    xor l 
0aa9			;    ld l,a 
0aa9			;    ld (seed2_0),hl 
0aa9			;    ex de,hl 
0aa9			;    add hl,bc 
0aa9			;    ret 
0aa9			; 
0aa9			 
0aa9			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0aa9			; 20 bytes, 86 cycles (excluding ret) 
0aa9			 
0aa9			; returns   hl = pseudorandom number 
0aa9			; corrupts   a 
0aa9			 
0aa9			; generates 16-bit pseudorandom numbers with a period of 65535 
0aa9			; using the xorshift method: 
0aa9			 
0aa9			; hl ^= hl << 7 
0aa9			; hl ^= hl >> 9 
0aa9			; hl ^= hl << 8 
0aa9			 
0aa9			; some alternative shift triplets which also perform well are: 
0aa9			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0aa9			 
0aa9			;  org 32768 
0aa9			 
0aa9			xrnd: 
0aa9 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0aac 3e 00		  ld a,0 
0aae bd			  cp l 
0aaf 20 02		  jr nz, .xrnd1 
0ab1 2e 01		  ld l, 1 
0ab3			.xrnd1: 
0ab3			 
0ab3 7c			  ld a,h 
0ab4 1f			  rra 
0ab5 7d			  ld a,l 
0ab6 1f			  rra 
0ab7 ac			  xor h 
0ab8 67			  ld h,a 
0ab9 7d			  ld a,l 
0aba 1f			  rra 
0abb 7c			  ld a,h 
0abc 1f			  rra 
0abd ad			  xor l 
0abe 6f			  ld l,a 
0abf ac			  xor h 
0ac0 67			  ld h,a 
0ac1			 
0ac1 22 bb eb		  ld (xrandc),hl 
0ac4			 
0ac4 c9			  ret 
0ac5			;  
0ac5			 
0ac5			 
0ac5			;;;; int maths 
0ac5			 
0ac5			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ac5			; Divide 16-bit values (with 16-bit result) 
0ac5			; In: Divide BC by divider DE 
0ac5			; Out: BC = result, HL = rest 
0ac5			; 
0ac5			Div16: 
0ac5 21 00 00		    ld hl,0 
0ac8 78			    ld a,b 
0ac9 06 08		    ld b,8 
0acb			Div16_Loop1: 
0acb 17			    rla 
0acc ed 6a		    adc hl,hl 
0ace ed 52		    sbc hl,de 
0ad0 30 01		    jr nc,Div16_NoAdd1 
0ad2 19			    add hl,de 
0ad3			Div16_NoAdd1: 
0ad3 10 f6		    djnz Div16_Loop1 
0ad5 17			    rla 
0ad6 2f			    cpl 
0ad7 47			    ld b,a 
0ad8 79			    ld a,c 
0ad9 48			    ld c,b 
0ada 06 08		    ld b,8 
0adc			Div16_Loop2: 
0adc 17			    rla 
0add ed 6a		    adc hl,hl 
0adf ed 52		    sbc hl,de 
0ae1 30 01		    jr nc,Div16_NoAdd2 
0ae3 19			    add hl,de 
0ae4			Div16_NoAdd2: 
0ae4 10 f6		    djnz Div16_Loop2 
0ae6 17			    rla 
0ae7 2f			    cpl 
0ae8 41			    ld b,c 
0ae9 4f			    ld c,a 
0aea c9			ret 
0aeb			 
0aeb			 
0aeb			;http://z80-heaven.wikidot.com/math 
0aeb			; 
0aeb			;Inputs: 
0aeb			;     DE and A are factors 
0aeb			;Outputs: 
0aeb			;     A is not changed 
0aeb			;     B is 0 
0aeb			;     C is not changed 
0aeb			;     DE is not changed 
0aeb			;     HL is the product 
0aeb			;Time: 
0aeb			;     342+6x 
0aeb			; 
0aeb			Mult16: 
0aeb			 
0aeb 06 08		     ld b,8          ;7           7 
0aed 21 00 00		     ld hl,0         ;10         10 
0af0 29			       add hl,hl     ;11*8       88 
0af1 07			       rlca          ;4*8        32 
0af2 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0af4 19			         add hl,de   ;--         -- 
0af5 10 f9		       djnz $-5      ;13*7+8     99 
0af7 c9			ret 
0af8			 
0af8			; 
0af8			; Square root of 16-bit value 
0af8			; In:  HL = value 
0af8			; Out:  D = result (rounded down) 
0af8			; 
0af8			;Sqr16: 
0af8			;    ld de,#0040 
0af8			;    ld a,l 
0af8			;    ld l,h 
0af8			;    ld h,d 
0af8			;    or a 
0af8			;    ld b,8 
0af8			;Sqr16_Loop: 
0af8			;    sbc hl,de 
0af8			;    jr nc,Sqr16_Skip 
0af8			;    add hl,de 
0af8			;Sqr16_Skip: 
0af8			;    ccf 
0af8			;    rl d 
0af8			;    add a,a 
0af8			;    adc hl,hl 
0af8			;    add a,a 
0af8			;    adc hl,hl 
0af8			;    djnz Sqr16_Loop 
0af8			;    ret 
0af8			; 
0af8			; 
0af8			; Divide 8-bit values 
0af8			; In: Divide E by divider C 
0af8			; Out: A = result, B = rest 
0af8			; 
0af8			Div8: 
0af8 af			    xor a 
0af9 06 08		    ld b,8 
0afb			Div8_Loop: 
0afb cb 13		    rl e 
0afd 17			    rla 
0afe 91			    sub c 
0aff 30 01		    jr nc,Div8_NoAdd 
0b01 81			    add a,c 
0b02			Div8_NoAdd: 
0b02 10 f7		    djnz Div8_Loop 
0b04 47			    ld b,a 
0b05 7b			    ld a,e 
0b06 17			    rla 
0b07 2f			    cpl 
0b08 c9			    ret 
0b09			 
0b09			; 
0b09			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b09			; In: Multiply A with DE 
0b09			; Out: HL = result 
0b09			; 
0b09			Mult12U: 
0b09 2e 00		    ld l,0 
0b0b 87			    add a,a 
0b0c 30 01		    jr nc,Mult12U_NoAdd0 
0b0e 19			    add hl,de 
0b0f			Mult12U_NoAdd0: 
0b0f 29			    add hl,hl 
0b10 87			    add a,a 
0b11 30 01		    jr nc,Mult12U_NoAdd1 
0b13 19			    add hl,de 
0b14			Mult12U_NoAdd1: 
0b14 29			    add hl,hl 
0b15 87			    add a,a 
0b16 30 01		    jr nc,Mult12U_NoAdd2 
0b18 19			    add hl,de 
0b19			Mult12U_NoAdd2: 
0b19 29			    add hl,hl 
0b1a 87			    add a,a 
0b1b 30 01		    jr nc,Mult12U_NoAdd3 
0b1d 19			    add hl,de 
0b1e			Mult12U_NoAdd3: 
0b1e 29			    add hl,hl 
0b1f 87			    add a,a 
0b20 30 01		    jr nc,Mult12U_NoAdd4 
0b22 19			    add hl,de 
0b23			Mult12U_NoAdd4: 
0b23 29			    add hl,hl 
0b24 87			    add a,a 
0b25 30 01		    jr nc,Mult12U_NoAdd5 
0b27 19			    add hl,de 
0b28			Mult12U_NoAdd5: 
0b28 29			    add hl,hl 
0b29 87			    add a,a 
0b2a 30 01		    jr nc,Mult12U_NoAdd6 
0b2c 19			    add hl,de 
0b2d			Mult12U_NoAdd6: 
0b2d 29			    add hl,hl 
0b2e 87			    add a,a 
0b2f d0			    ret nc 
0b30 19			    add hl,de 
0b31 c9			    ret 
0b32			 
0b32			; 
0b32			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b32			; In: Multiply A with DE 
0b32			;      Put lowest value in A for most efficient calculation 
0b32			; Out: HL = result 
0b32			; 
0b32			Mult12R: 
0b32 21 00 00		    ld hl,0 
0b35			Mult12R_Loop: 
0b35 cb 3f		    srl a 
0b37 30 01		    jr nc,Mult12R_NoAdd 
0b39 19			    add hl,de 
0b3a			Mult12R_NoAdd: 
0b3a cb 23		    sla e 
0b3c cb 12		    rl d 
0b3e b7			    or a 
0b3f c2 35 0b		    jp nz,Mult12R_Loop 
0b42 c9			    ret 
0b43			 
0b43			; 
0b43			; Multiply 16-bit values (with 32-bit result) 
0b43			; In: Multiply BC with DE 
0b43			; Out: BCHL = result 
0b43			; 
0b43			Mult32: 
0b43 79			    ld a,c 
0b44 48			    ld c,b 
0b45 21 00 00		    ld hl,0 
0b48 06 10		    ld b,16 
0b4a			Mult32_Loop: 
0b4a 29			    add hl,hl 
0b4b 17			    rla 
0b4c cb 11		    rl c 
0b4e 30 07		    jr nc,Mult32_NoAdd 
0b50 19			    add hl,de 
0b51 ce 00		    adc a,0 
0b53 d2 57 0b		    jp nc,Mult32_NoAdd 
0b56 0c			    inc c 
0b57			Mult32_NoAdd: 
0b57 10 f1		    djnz Mult32_Loop 
0b59 41			    ld b,c 
0b5a 4f			    ld c,a 
0b5b c9			    ret 
0b5c			 
0b5c			 
0b5c			 
0b5c			; 
0b5c			; Multiply 8-bit values 
0b5c			; In:  Multiply H with E 
0b5c			; Out: HL = result 
0b5c			; 
0b5c			Mult8: 
0b5c 16 00		    ld d,0 
0b5e 6a			    ld l,d 
0b5f 06 08		    ld b,8 
0b61			Mult8_Loop: 
0b61 29			    add hl,hl 
0b62 30 01		    jr nc,Mult8_NoAdd 
0b64 19			    add hl,de 
0b65			Mult8_NoAdd: 
0b65 10 fa		    djnz Mult8_Loop 
0b67 c9			    ret 
0b68			 
0b68			 
0b68			 
0b68			 
0b68			 
0b68			 
0b68			 
0b68			 
0b68			;;http://z80-heaven.wikidot.com/math 
0b68			;;This divides DE by BC, storing the result in DE, remainder in HL 
0b68			; 
0b68			;DE_Div_BC:          ;1281-2x, x is at most 16 
0b68			;     ld a,16        ;7 
0b68			;     ld hl,0        ;10 
0b68			;     jp $+5         ;10 
0b68			;.DivLoop: 
0b68			;       add hl,bc    ;-- 
0b68			;       dec a        ;64 
0b68			;       jr z,.DivLoopEnd        ;86 
0b68			; 
0b68			;       sla e        ;128 
0b68			;       rl d         ;128 
0b68			;       adc hl,hl    ;240 
0b68			;       sbc hl,bc    ;240 
0b68			;       jr nc,.DivLoop ;23|21 
0b68			;       inc e        ;-- 
0b68			;       jp .DivLoop+1 
0b68			; 
0b68			;.DivLoopEnd: 
0b68			 
0b68			;HL_Div_C: 
0b68			;Inputs: 
0b68			;     HL is the numerator 
0b68			;     C is the denominator 
0b68			;Outputs: 
0b68			;     A is the remainder 
0b68			;     B is 0 
0b68			;     C is not changed 
0b68			;     DE is not changed 
0b68			;     HL is the quotient 
0b68			; 
0b68			;       ld b,16 
0b68			;       xor a 
0b68			;         add hl,hl 
0b68			;         rla 
0b68			;         cp c 
0b68			;         jr c,$+4 
0b68			;           inc l 
0b68			;           sub c 
0b68			;         djnz $-7 
0b68			 
0b68			; https://plutiedev.com/z80-add-8bit-to-16bit 
0b68			 
0b68			addatohl: 
0b68 85			    add   a, l    ; A = A+L 
0b69 6f			    ld    l, a    ; L = A+L 
0b6a 8c			    adc   a, h    ; A = A+L+H+carry 
0b6b 95			    sub   l       ; A = H+carry 
0b6c 67			    ld    h, a    ; H = H+carry 
0b6d c9			ret 
0b6e			 
0b6e			addatode: 
0b6e 83			    add   a, e    ; A = A+L 
0b6f 5f			    ld    e, a    ; L = A+L 
0b70 8a			    adc   a, d    ; A = A+L+H+carry 
0b71 93			    sub   e       ; A = H+carry 
0b72 57			    ld    d, a    ; H = H+carry 
0b73 c9			ret 
0b74			 
0b74			 
0b74			addatobc: 
0b74 81			    add   a, c    ; A = A+L 
0b75 4f			    ld    c, a    ; L = A+L 
0b76 88			    adc   a, b    ; A = A+L+H+carry 
0b77 91			    sub   c       ; A = H+carry 
0b78 47			    ld    b, a    ; H = H+carry 
0b79 c9			ret 
0b7a			 
0b7a			subafromhl: 
0b7a			   ; If A=0 do nothing 
0b7a			    ; Otherwise flip A's sign. Since 
0b7a			    ; the upper byte becomes -1, also 
0b7a			    ; substract 1 from H. 
0b7a ed 44		    neg 
0b7c ca 85 0b		    jp    z, Skip 
0b7f 25			    dec   h 
0b80			     
0b80			    ; Now add the low byte as usual 
0b80			    ; Two's complement takes care of 
0b80			    ; ensuring the result is correct 
0b80 85			    add   a, l 
0b81 6f			    ld    l, a 
0b82 8c			    adc   a, h 
0b83 95			    sub   l 
0b84 67			    ld    h, a 
0b85			Skip: 
0b85 c9				ret 
0b86			 
0b86			 
0b86			; compare hl and de 
0b86			; returns:  
0b86			; if hl = de, z=1, s=0, c0=0 
0b86			; if hl > de, z=0, s=0, c=0 
0b86			; if hl < de, z=0, s=1, c=1 
0b86			cmp16:	 
0b86 b7				or a 
0b87 ed 52			sbc hl,de 
0b89 e0				ret po 
0b8a 7c				ld a,h 
0b8b 1f				rra 
0b8c ee 40			xor 01000000B 
0b8e 37				scf 
0b8f 8f				adc a,a 
0b90 c9				ret 
0b91			 
0b91			 
0b91			; test if hl contains zero   - A is destroyed 
0b91			 
0b91			ishlzero:    
0b91 b7				or a     ; reset flags 
0b92 7c				ld a, h 
0b93 b5				or l        	 
0b94			 
0b94 c9				ret 
0b95			 
0b95			 
0b95			 
0b95			 
0b95			if FORTH_ENABLE_FLOATMATH 
0b95			;include "float/bbcmath.z80" 
0b95			include "float/lpfpcalc.asm" 
0b95			endif 
0b95			 
0b95			 
0b95			; eof 
0b95			 
# End of file firmware_maths.asm
0b95			include "firmware_strings.asm"   ; string handling  
0b95			 
0b95			 
0b95			; TODO string len 
0b95			; input text string, end on cr with zero term 
0b95			; a offset into frame buffer to start prompt 
0b95			; d is max length 
0b95			; e is display size TODO 
0b95			; c is current cursor position 
0b95			; hl is ptr to where string will be stored 
0b95			 
0b95			 
0b95			; TODO check limit of buffer for new inserts 
0b95			; TODO check insert does not push beyond buffer 
0b95			; TODO scroll in a limited display area 
0b95			; TODO scroll whole screen on page wrap 
0b95			 
0b95			 
0b95			; TODO handle KEY_PREVWORD 
0b95			; TODO handle KEY_NEXTWORD 
0b95			; TODO handle KEY_HOME 
0b95			; TODO handle KEY_END 
0b95			; TODO use LCD cursor? 
0b95			 
0b95 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0b98 81					add c 
0b99 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0b9c 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0b9f 79					ld a, c 
0ba0 cd 68 0b				call addatohl 
0ba3 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0ba6 7a					ld a,d 
0ba7 32 75 ee			        ld (input_size), a       ; save length of input area 
0baa 79					ld a, c 
0bab 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0bae 7b					ld a,e 
0baf 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0bb2					 
0bb2					 
0bb2			 
0bb2			;		ld a,(input_ptr) 
0bb2			;		ld (input_under_cursor),a 	; save what is under the cursor 
0bb2			 
0bb2			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0bb2					; init cursor shape if not set by the cin routines 
0bb2 21 d3 eb				ld hl, cursor_shape 
0bb5 3e ff				ld a, 255 
0bb7 77					ld (hl), a 
0bb8 23					inc hl 
0bb9 3e 00				ld a, 0 
0bbb 77					ld (hl), a 
0bbc			 
0bbc 3e 0f				ld a, CUR_BLINK_RATE 
0bbe 32 6f ee				ld (input_cur_flash), a 
0bc1 3e 01				ld a, 1 
0bc3 32 6e ee				ld (input_cur_onoff),a 
0bc6			 
0bc6			;	if DEBUG_INPUT 
0bc6			;		push af 
0bc6			;		ld a, 'I' 
0bc6			;		ld (debug_mark),a 
0bc6			;		pop af 
0bc6			;		CALLMONITOR 
0bc6			;	endif 
0bc6			.is1:		; main entry loop 
0bc6			 
0bc6			 
0bc6			 
0bc6					; pause 1ms 
0bc6			 
0bc6 3e 01				ld a, 1 
0bc8 cd c7 08				call aDelayInMS 
0bcb			 
0bcb					; dec flash counter 
0bcb 3a 6f ee				ld a, (input_cur_flash) 
0bce 3d					dec a 
0bcf 32 6f ee				ld (input_cur_flash), a 
0bd2 fe 00				cp 0 
0bd4 20 0d				jr nz, .nochgstate 
0bd6			 
0bd6			 
0bd6					; change state 
0bd6 3a 6e ee				ld a,(input_cur_onoff) 
0bd9 ed 44				neg 
0bdb 32 6e ee				ld (input_cur_onoff),a 
0bde			 
0bde			 
0bde					; reset on change of state 
0bde 3e 0f				ld a, CUR_BLINK_RATE 
0be0 32 6f ee				ld (input_cur_flash), a 
0be3			 
0be3			.nochgstate: 
0be3					 
0be3					 
0be3			 
0be3					; display cursor  
0be3			 
0be3			;		ld hl, (input_start) 
0be3			;		ld a, (input_cursor) 
0be3			;		call addatohl 
0be3			 
0be3					; get char under cursor and replace with cursor 
0be3 2a 78 ee		ld hl, (input_ptr) 
0be6			;		ld a, (hl) 
0be6			;		ld (input_under_cursor),a 
0be6			;		ld a, '_' 
0be6			;		ld (hl), a 
0be6			 
0be6					; display string 
0be6			 
0be6 ed 5b 76 ee			ld de, (input_start) 
0bea 3a 73 ee				ld a, (input_at_pos) 
0bed cd 52 09				call str_at_display 
0bf0			;	        call update_display 
0bf0			 
0bf0					; find place to put the cursor 
0bf0			;		add h 
0bf0			;		ld l, display_row_1 
0bf0			;		sub l 
0bf0			; (input_at_pos) 
0bf0					;ld c, a 
0bf0			;		ld a, (input_cursor) 
0bf0			;		ld l, (input_at_pos) 
0bf0			;		;ld b, h 
0bf0			;		add l 
0bf0			;		ld (input_at_cursor),a 
0bf0					;ld l,h 
0bf0			 
0bf0			;		ld h, 0 
0bf0			;		ld l,(input_at_pos) 
0bf0			;		ld a, (input_cursor) 
0bf0			;		call addatohl 
0bf0			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0bf0			;		call subafromhl 
0bf0			;		ld a,l 
0bf0			;		ld (input_at_cursor), a 
0bf0			 
0bf0				if DEBUG_INPUT 
0bf0					ld a, (hardware_diag) 
0bf0					cp 0 
0bf0					jr z, .skip_input_diag 
0bf0			 
0bf0					ld a,(input_at_pos) 
0bf0					ld hl, LFSRSeed 
0bf0					call hexout 
0bf0					ld a, (input_cursor) 
0bf0					ld hl, LFSRSeed+2 
0bf0					call hexout 
0bf0					ld a,(input_at_cursor) 
0bf0					ld hl, LFSRSeed+4 
0bf0					call hexout 
0bf0			 
0bf0					ld a,(input_cur_onoff) 
0bf0					ld hl, LFSRSeed+6 
0bf0					call hexout 
0bf0			 
0bf0					ld a,(input_cur_flash) 
0bf0					ld hl, LFSRSeed+8 
0bf0					call hexout 
0bf0			 
0bf0					ld a,(input_len) 
0bf0					ld hl, LFSRSeed+10 
0bf0					call hexout 
0bf0					ld hl, LFSRSeed+12 
0bf0					ld a, 0 
0bf0					ld (hl),a 
0bf0					ld a, display_row_4 
0bf0					ld de, LFSRSeed 
0bf0					call str_at_display 
0bf0					.skip_input_diag: 
0bf0				endif 
0bf0			 
0bf0					; decide on if we are showing the cursor this time round 
0bf0			 
0bf0 3a 6e ee				ld a, (input_cur_onoff) 
0bf3 fe ff				cp 255 
0bf5 28 13				jr z, .skipcur 
0bf7			 
0bf7			 
0bf7 3a 71 ee				ld a,(input_at_cursor) 
0bfa 11 d3 eb				ld de, cursor_shape 
0bfd cd 52 09				call str_at_display 
0c00			 
0c00					; save length of current input string 
0c00 2a 76 ee				ld hl, (input_start) 
0c03 cd c6 0f				call strlenz 
0c06 7d					ld a,l 
0c07 32 69 ee				ld (input_len),a 
0c0a			 
0c0a			.skipcur: 
0c0a			 
0c0a cd 62 09			        call update_display 
0c0d					 
0c0d			 
0c0d			 
0c0d					; wait 
0c0d				 
0c0d					; TODO loop without wait to flash the cursor and char under cursor	 
0c0d cd d4 57				call cin    ; _wait 
0c10			 
0c10 fe 00				cp 0 
0c12 ca c6 0b				jp z, .is1 
0c15			 
0c15					; get ptr to char to input into 
0c15			 
0c15 4f					ld c,a 
0c16 2a 76 ee				ld hl, (input_start) 
0c19 3a 64 ee				ld a, (input_cursor) 
0c1c cd 68 0b				call addatohl 
0c1f 22 78 ee				ld (input_ptr), hl 
0c22 79					ld a,c 
0c23			 
0c23					; replace char under cursor 
0c23			 
0c23			;		ld hl, (input_ptr) 
0c23			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c23			;		ld (hl), a 
0c23			 
0c23			;	if DEBUG_INPUT 
0c23			;		push af 
0c23			;		ld a, 'i' 
0c23			;		ld (debug_mark),a 
0c23			;		pop af 
0c23			;		CALLMONITOR 
0c23			;	endif 
0c23 fe 0e				cp KEY_HOME 
0c25 20 0e				jr nz, .iske 
0c27			 
0c27 3a 73 ee				ld a, (input_at_pos) 
0c2a 32 71 ee				ld (input_at_cursor),a 
0c2d 3e 00				ld a, 0 
0c2f 32 64 ee				ld (input_cursor), a 
0c32 c3 c6 0b				jp .is1 
0c35					 
0c35 fe 0f		.iske:		cp KEY_END 
0c37 20 03				jr nz, .isknw 
0c39 c3 c6 0b				jp .is1 
0c3c			 
0c3c fe 06		.isknw:		cp KEY_NEXTWORD 
0c3e 20 1b				jr nz, .iskpw 
0c40			 
0c40 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0c43 7e					ld a,(hl)	 
0c44 fe 00				cp 0 
0c46 ca c6 0b				jp z, .is1    ; end of string 
0c49 fe 20				cp ' ' 
0c4b ca c6 0b				jp z, .is1    ; end of word 
0c4e 23					inc hl 
0c4f 22 78 ee				ld (input_ptr), hl 
0c52 3a 71 ee				ld a, (input_at_cursor) 
0c55 3c					inc a 
0c56 32 71 ee				ld (input_at_cursor), a 
0c59 18 e5				jr .isknwm 
0c5b			 
0c5b fe 07		.iskpw:		cp KEY_PREVWORD 
0c5d 20 1b				jr nz, .iskl 
0c5f			.iskpwm:	 
0c5f 2a 78 ee				ld hl, (input_ptr) 
0c62 7e					ld a,(hl)	 
0c63 fe 00				cp 0  
0c65 ca c6 0b				jp z, .is1    ; end of string 
0c68 fe 20				cp ' ' 
0c6a ca c6 0b				jp z, .is1    ; end of word 
0c6d 2b					dec hl 
0c6e 22 78 ee				ld (input_ptr), hl 
0c71 3a 71 ee				ld a, (input_at_cursor) 
0c74 3d					dec a 
0c75 32 71 ee				ld (input_at_cursor), a 
0c78 18 e5				jr .iskpwm 
0c7a			 
0c7a			 
0c7a fe 0b		.iskl:		cp KEY_LEFT 
0c7c 20 27				jr nz, .isk1 
0c7e			 
0c7e 3a 64 ee				ld a, (input_cursor) 
0c81			 
0c81 fe 00				cp 0 
0c83 ca c6 0b				jp z, .is1 		; at start of line to ignore  
0c86			 
0c86 3d					dec  a 		; TODO check underflow 
0c87 32 64 ee				ld (input_cursor), a 
0c8a			 
0c8a 2a 78 ee				ld hl, (input_ptr) 
0c8d 2b					dec hl 
0c8e 22 78 ee				ld (input_ptr), hl 
0c91					 
0c91 3a 71 ee				ld a, (input_at_cursor) 
0c94 3d					dec a 
0c95 32 71 ee				ld (input_at_cursor), a 
0c98			 
0c98 3e 01				ld a, 1		; show cursor moving 
0c9a 32 6e ee				ld (input_cur_onoff),a 
0c9d 3e 0f				ld a, CUR_BLINK_RATE 
0c9f 32 6f ee				ld (input_cur_flash), a 
0ca2			 
0ca2 c3 c6 0b				jp .is1 
0ca5			 
0ca5 fe 0c		.isk1:		cp KEY_RIGHT 
0ca7 20 2a				jr nz, .isk2 
0ca9			 
0ca9 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0cac 5f					ld e,a 
0cad 3a 64 ee				ld a, (input_cursor) 
0cb0 bb					cp e 
0cb1 ca c6 0b				jp z, .is1		; at the end of string so dont go right 
0cb4			 
0cb4 3c					inc  a 		; TODO check overflow 
0cb5 32 64 ee				ld (input_cursor), a 
0cb8			 
0cb8 3a 71 ee				ld a, (input_at_cursor) 
0cbb 3c					inc a 
0cbc 32 71 ee				ld (input_at_cursor), a 
0cbf			 
0cbf 2a 78 ee				ld hl, (input_ptr) 
0cc2 23					inc hl 
0cc3 22 78 ee				ld (input_ptr), hl 
0cc6			 
0cc6 3e 01				ld a, 1		; show cursor moving 
0cc8 32 6e ee				ld (input_cur_onoff),a 
0ccb 3e 0f				ld a, CUR_BLINK_RATE 
0ccd 32 6f ee				ld (input_cur_flash), a 
0cd0			 
0cd0 c3 c6 0b				jp .is1 
0cd3			 
0cd3 fe 05		.isk2:		cp KEY_UP 
0cd5			 
0cd5 20 26				jr nz, .isk3 
0cd7			 
0cd7					; swap last command with the current on 
0cd7			 
0cd7					; move cursor to start of string 
0cd7 2a 76 ee				ld hl, (input_start) 
0cda 22 78 ee				ld (input_ptr), hl 
0cdd			 
0cdd 3a 73 ee				ld a, (input_at_pos) 
0ce0 32 71 ee				ld (input_at_cursor), a 
0ce3			 
0ce3 3e 00				ld a, 0 
0ce5 32 64 ee				ld (input_cursor), a 
0ce8					 
0ce8					; swap input and last command buffers 
0ce8			 
0ce8 21 9c e6				ld hl, os_cli_cmd 
0ceb 11 9b e7				ld de, os_last_cmd 
0cee 06 ff				ld b, 255 
0cf0 7e			.swap1:		ld a, (hl) 
0cf1 4f					ld c,a 
0cf2 1a					ld a, (de) 
0cf3 77					ld (hl), a 
0cf4 79					ld a,c 
0cf5 12					ld (de),a 
0cf6 23					inc hl 
0cf7 13					inc de 
0cf8 10 f6				djnz .swap1 
0cfa			 
0cfa			 
0cfa			 
0cfa			 
0cfa			 
0cfa c3 c6 0b				jp .is1 
0cfd			 
0cfd fe 08		.isk3:		cp KEY_BS 
0cff 20 3c				jr nz, .isk4 
0d01			 
0d01 3a 64 ee				ld a, (input_cursor) 
0d04			 
0d04 fe 00				cp 0 
0d06 ca c6 0b				jp z, .is1 		; at start of line to ignore  
0d09			 
0d09 3d					dec  a 		; TODO check underflow 
0d0a 32 64 ee				ld (input_cursor), a 
0d0d			 
0d0d					; hl is source 
0d0d					; de needs to be source - 1 
0d0d			 
0d0d			;		ld a, 0 
0d0d			;		dec hl 
0d0d			;		ld (hl), a 
0d0d			 
0d0d 2a 78 ee				ld hl, (input_ptr) 
0d10 2b					dec hl 
0d11 22 78 ee				ld (input_ptr), hl 
0d14			 
0d14					; shift all data 
0d14			 
0d14 e5					push hl 
0d15 23					inc hl 
0d16 d1					pop de 
0d17 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d1a 4f					ld c,a 
0d1b 06 00				ld b,0 
0d1d ed b0				ldir  
0d1f			 
0d1f			 
0d1f			 
0d1f			 
0d1f 3a 71 ee				ld a, (input_at_cursor) 
0d22 3d					dec a 
0d23 32 71 ee				ld (input_at_cursor), a 
0d26			 
0d26			 
0d26 3e 01				ld a, 1		; show cursor moving 
0d28 32 6e ee				ld (input_cur_onoff),a 
0d2b 3e 0f				ld a, CUR_BLINK_RATE 
0d2d 32 6f ee				ld (input_cur_flash), a 
0d30			 
0d30					; remove char 
0d30 3a 71 ee				ld a, (input_at_cursor) 
0d33 3c					inc a 
0d34 11 be 0d				ld de,.iblank 
0d37 cd 52 09				call str_at_display 
0d3a			 
0d3a c3 c6 0b				jp .is1 
0d3d			 
0d3d fe 0d		.isk4:		cp KEY_CR 
0d3f 28 6c				jr z, .endinput 
0d41			 
0d41					; else add the key press to the end 
0d41			 
0d41 4f					ld c, a			; save key pressed 
0d42			 
0d42 7e					ld a,(hl)		; get what is currently under char 
0d43			 
0d43 fe 00				cp 0			; we are at the end of the string 
0d45 20 2f				jr nz, .onchar 
0d47					 
0d47					; add a char to the end of the string 
0d47				 
0d47 71					ld (hl),c 
0d48 23					inc hl 
0d49			;		ld a,' ' 
0d49			;		ld (hl),a 
0d49			;		inc hl 
0d49 3e 00				ld a,0 
0d4b 77					ld (hl),a 
0d4c 2b					dec hl 
0d4d			 
0d4d 3a 64 ee				ld a, (input_cursor) 
0d50 3c					inc a				; TODO check max string length and scroll  
0d51 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0d54							 
0d54 3a 71 ee				ld a, (input_at_cursor) 
0d57 3c					inc a 
0d58 32 71 ee				ld (input_at_cursor), a 
0d5b			 
0d5b 2a 78 ee				ld hl, (input_ptr) 
0d5e 23					inc hl 
0d5f 22 78 ee				ld (input_ptr), hl 
0d62			 
0d62 2a 78 ee				ld hl, (input_ptr) 
0d65 23					inc hl 
0d66 22 78 ee				ld (input_ptr), hl 
0d69			;	if DEBUG_INPUT 
0d69			;		push af 
0d69			;		ld a, '+' 
0d69			;		ld (debug_mark),a 
0d69			;		pop af 
0d69			;		CALLMONITOR 
0d69			;	endif 
0d69 3e 01				ld a, 1		; show cursor moving 
0d6b 32 6e ee				ld (input_cur_onoff),a 
0d6e 3e 0f				ld a, CUR_BLINK_RATE 
0d70 32 6f ee				ld (input_cur_flash), a 
0d73 c3 c6 0b				jp .is1 
0d76					 
0d76			 
0d76			 
0d76					; if on a char then insert 
0d76			.onchar: 
0d76			 
0d76					; TODO over flow check: make sure insert does not blow out buffer 
0d76			 
0d76					; need to do some maths to use lddr 
0d76			 
0d76 e5					push hl   ; save char pos 
0d77 c5					push bc 
0d78			 
0d78 2a 76 ee				ld hl, (input_start) 
0d7b 3a 69 ee				ld a, (input_len) 
0d7e cd 68 0b				call addatohl  		; end of string 
0d81 23					inc hl 
0d82 23					inc hl		; past zero term 
0d83 e5					push hl 
0d84 23					inc hl 
0d85 e5					push hl  
0d86			 
0d86								; start and end of lddr set, now how much to move? 
0d86			 
0d86							 
0d86 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0d89 47					ld b,a 
0d8a 3a 69 ee				ld a,(input_len) 
0d8d 5f					ld e,a 
0d8e 90					sub b 
0d8f 3c					inc a		;?? 
0d90 3c					inc a		;?? 
0d91 3c					inc a		;?? 
0d92			 
0d92 06 00				ld b,0 
0d94 4f					ld c,a 
0d95			 
0d95				if DEBUG_INPUT 
0d95					push af 
0d95					ld a, 'i' 
0d95					ld (debug_mark),a 
0d95					pop af 
0d95			;		CALLMONITOR 
0d95				endif 
0d95 d1					pop de 
0d96 e1					pop hl 
0d97				if DEBUG_INPUT 
0d97					push af 
0d97					ld a, 'I' 
0d97					ld (debug_mark),a 
0d97					pop af 
0d97			;		CALLMONITOR 
0d97				endif 
0d97 ed b8				lddr 
0d99				 
0d99			 
0d99			 
0d99					; TODO have a key for insert/overwrite mode???? 
0d99 c1					pop bc 
0d9a e1					pop hl 
0d9b 71					ld (hl), c		; otherwise overwrite current char 
0d9c					 
0d9c			 
0d9c			 
0d9c			 
0d9c 3a 64 ee				ld a, (input_cursor) 
0d9f 3c					inc  a 		; TODO check overflow 
0da0 32 64 ee				ld (input_cursor), a 
0da3			 
0da3 3a 71 ee				ld a, (input_at_cursor) 
0da6 3c					inc a 
0da7 32 71 ee				ld (input_at_cursor), a 
0daa			 
0daa c3 c6 0b				jp .is1 
0dad			 
0dad			.endinput:	; TODO look for end of string 
0dad			 
0dad					; add trailing space for end of token 
0dad			 
0dad 2a 76 ee				ld hl, (input_start) 
0db0 3a 69 ee				ld a,(input_len) 
0db3 cd 68 0b				call addatohl 
0db6 3e 20				ld a, ' ' 
0db8 77					ld (hl),a 
0db9					; TODO eof of parse marker 
0db9			 
0db9 23					inc hl 
0dba 3e 00				ld a, 0 
0dbc 77					ld (hl),a 
0dbd			 
0dbd			 
0dbd c9					ret 
0dbe			 
0dbe .. 00		.iblank: db " ",0 
0dc0			 
0dc0			 
0dc0 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0dc3 22 76 ee				ld (input_start), hl 
0dc6 3e 01				ld a,1			; add cursor 
0dc8 77					ld (hl),a 
0dc9 23					inc hl 
0dca 3e 00				ld a,0 
0dcc 77					ld (hl),a 
0dcd 22 78 ee				ld (input_ptr), hl 
0dd0 7a					ld a,d 
0dd1 32 75 ee				ld (input_size), a 
0dd4 3e 00				ld a,0 
0dd6 32 64 ee				ld (input_cursor),a 
0dd9			.instr1:	 
0dd9			 
0dd9					; TODO do block cursor 
0dd9					; TODO switch cursor depending on the modifer key 
0dd9			 
0dd9					; update cursor shape change on key hold 
0dd9			 
0dd9 2a 78 ee				ld hl, (input_ptr) 
0ddc 2b					dec hl 
0ddd 3a d3 eb				ld a,(cursor_shape) 
0de0 77					ld (hl), a 
0de1			 
0de1					; display entered text 
0de1 3a 73 ee				ld a,(input_at_pos) 
0de4 cd e9 56		            	CALL fLCD_Pos       ;Position cursor to location in A 
0de7 ed 5b 76 ee	            	LD   de, (input_start) 
0deb cd de 56		            	CALL fLCD_Str       ;Display string pointed to by DE 
0dee			 
0dee cd d4 57				call cin 
0df1 fe 00				cp 0 
0df3 28 e4				jr z, .instr1 
0df5			 
0df5					; proecess keyboard controls first 
0df5			 
0df5 2a 78 ee				ld hl,(input_ptr) 
0df8			 
0df8 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0dfa 28 5a				jr z, .instrcr 
0dfc			 
0dfc fe 08				cp KEY_BS 	; back space 
0dfe 20 0f				jr nz, .instr2 
0e00					; process back space 
0e00			 
0e00					; TODO stop back space if at start of string 
0e00 2b					dec hl 
0e01 2b					dec hl ; to over write cursor 
0e02 3a d3 eb				ld a,(cursor_shape) 
0e05					;ld a,0 
0e05 77					ld (hl),a 
0e06 23					inc hl 
0e07 3e 20				ld a," " 
0e09 77					ld (hl),a 
0e0a 22 78 ee				ld (input_ptr),hl 
0e0d					 
0e0d			 
0e0d 18 ca				jr .instr1 
0e0f			 
0e0f fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e11 20 06				jr nz, .instr3 
0e13 2b					dec hl 
0e14 22 78 ee				ld (input_ptr),hl 
0e17 18 c0				jr .instr1 
0e19				 
0e19 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e1b 20 06				jr nz, .instr4 
0e1d 23					inc hl 
0e1e 22 78 ee				ld (input_ptr),hl 
0e21 18 b6				jr .instr1 
0e23			 
0e23 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e25 20 06				jr nz, .instr5 
0e27 2b					dec hl 
0e28 22 78 ee				ld (input_ptr),hl 
0e2b 18 ac				jr .instr1 
0e2d			 
0e2d fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e2f 20 06				jr nz, .instr6 
0e31 2b					dec hl 
0e32 22 78 ee				ld (input_ptr),hl 
0e35 18 a2				jr .instr1 
0e37 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e39 20 0b				jr nz, .instrnew 
0e3b			 
0e3b 21 75 e3			ld hl, scratch 
0e3e 11 9b e7			ld de, os_last_cmd 
0e41 cd 5f 0e			call strcpy 
0e44 18 93				jr .instr1 
0e46			 
0e46			 
0e46			.instrnew:	; no special key pressed to see if we have room to store it 
0e46			 
0e46					; TODO do string size test 
0e46			 
0e46 2b					dec hl ; to over write cursor 
0e47 77					ld (hl),a 
0e48 23					inc hl 
0e49 3a d3 eb				ld a,(cursor_shape) 
0e4c 77					ld (hl),a 
0e4d 23					inc hl 
0e4e 3e 00				ld a,0 
0e50 77					ld (hl),a 
0e51			 
0e51 22 78 ee				ld (input_ptr),hl 
0e54					 
0e54 18 83				jr .instr1 
0e56 2b			.instrcr:	dec hl		; remove cursor 
0e57 3e 20				ld a,' '	; TODO add a trailing space for safety 
0e59 77					ld (hl),a 
0e5a 23					inc hl 
0e5b 3e 00				ld a,0 
0e5d 77					ld (hl),a 
0e5e			 
0e5e			 
0e5e					; if at end of line scroll up    
0e5e					; TODO detecting only end of line 4 for scroll up  
0e5e			 
0e5e					;ld   
0e5e			 
0e5e c9					ret 
0e5f			 
0e5f			 
0e5f			; strcpy hl = dest, de source 
0e5f			 
0e5f 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0e60 b7			            OR   A              ;Null terminator? 
0e61 c8			            RET  Z              ;Yes, so finished 
0e62 1a					ld a,(de) 
0e63 77					ld (hl),a 
0e64 13			            INC  DE             ;Point to next character 
0e65 23					inc hl 
0e66 18 f7		            JR   strcpy       ;Repeat 
0e68 c9					ret 
0e69			 
0e69			 
0e69			; TODO string_at  
0e69			; pass string which starts with lcd offset address and then null term string 
0e69			 
0e69			; TODO string to dec 
0e69			; TODO string to hex 
0e69			; TODO byte to string hex 
0e69			; TODO byte to string dec 
0e69			 
0e69			 
0e69			 
0e69			; from z80uartmonitor 
0e69			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e69			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0e69			; pass hl for where to put the text 
0e69			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e69 c5			hexout:	PUSH BC 
0e6a f5					PUSH AF 
0e6b 47					LD B, A 
0e6c					; Upper nybble 
0e6c cb 3f				SRL A 
0e6e cb 3f				SRL A 
0e70 cb 3f				SRL A 
0e72 cb 3f				SRL A 
0e74 cd 84 0e				CALL tohex 
0e77 77					ld (hl),a 
0e78 23					inc hl	 
0e79					 
0e79					; Lower nybble 
0e79 78					LD A, B 
0e7a e6 0f				AND 0FH 
0e7c cd 84 0e				CALL tohex 
0e7f 77					ld (hl),a 
0e80 23					inc hl	 
0e81					 
0e81 f1					POP AF 
0e82 c1					POP BC 
0e83 c9					RET 
0e84					 
0e84			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e84			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0e84			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e84			tohex: 
0e84 e5					PUSH HL 
0e85 d5					PUSH DE 
0e86 16 00				LD D, 0 
0e88 5f					LD E, A 
0e89 21 91 0e				LD HL, .DATA 
0e8c 19					ADD HL, DE 
0e8d 7e					LD A, (HL) 
0e8e d1					POP DE 
0e8f e1					POP HL 
0e90 c9					RET 
0e91			 
0e91			.DATA: 
0e91 30					DEFB	30h	; 0 
0e92 31					DEFB	31h	; 1 
0e93 32					DEFB	32h	; 2 
0e94 33					DEFB	33h	; 3 
0e95 34					DEFB	34h	; 4 
0e96 35					DEFB	35h	; 5 
0e97 36					DEFB	36h	; 6 
0e98 37					DEFB	37h	; 7 
0e99 38					DEFB	38h	; 8 
0e9a 39					DEFB	39h	; 9 
0e9b 41					DEFB	41h	; A 
0e9c 42					DEFB	42h	; B 
0e9d 43					DEFB	43h	; C 
0e9e 44					DEFB	44h	; D 
0e9f 45					DEFB	45h	; E 
0ea0 46					DEFB	46h	; F 
0ea1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ea1			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0ea1			;;    subtract $30, if result > 9 then subtract $7 more 
0ea1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ea1			atohex: 
0ea1 d6 30				SUB $30 
0ea3 fe 0a				CP 10 
0ea5 f8					RET M		; If result negative it was 0-9 so we're done 
0ea6 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0ea8 c9					RET		 
0ea9			 
0ea9			 
0ea9			 
0ea9			 
0ea9			; Get 2 ASCII characters as hex byte from pointer in hl 
0ea9			 
0ea9			BYTERD: 
0ea9 16 00			LD	D,00h		;Set up 
0eab cd b3 0e			CALL	HEXCON		;Get byte and convert to hex 
0eae 87				ADD	A,A		;First nibble so 
0eaf 87				ADD	A,A		;multiply by 16 
0eb0 87				ADD	A,A		; 
0eb1 87				ADD	A,A		; 
0eb2 57				LD	D,A		;Save hi nibble in D 
0eb3			HEXCON: 
0eb3 7e				ld a, (hl)		;Get next chr 
0eb4 23				inc hl 
0eb5 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0eb7 fe 0a			CP	00Ah		;Is it 0-9 ? 
0eb9 38 02			JR	C,NALPHA	;If so miss next bit 
0ebb d6 07			SUB	007h		;Else convert alpha 
0ebd			NALPHA: 
0ebd b2				OR	D		;Add hi nibble back 
0ebe c9				RET			; 
0ebf			 
0ebf			 
0ebf			; 
0ebf			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0ebf			; Since the routines get_byte and therefore get_nibble are called, only valid 
0ebf			; characters (0-9a-f) are accepted. 
0ebf			; 
0ebf			;get_word        push    af 
0ebf			;                call    get_byte        ; Get the upper byte 
0ebf			;                ld      h, a 
0ebf			;                call    get_byte        ; Get the lower byte 
0ebf			;                ld      l, a 
0ebf			;                pop     af 
0ebf			;                ret 
0ebf			; 
0ebf			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0ebf			; the routine get_nibble is used only valid characters are accepted - the  
0ebf			; input routine only accepts characters 0-9a-f. 
0ebf			; 
0ebf c5			get_byte:        push    bc              ; Save contents of B (and C) 
0ec0 7e					ld a,(hl) 
0ec1 23					inc hl 
0ec2 cd e7 0e		                call    nibble2val      ; Get upper nibble 
0ec5 cb 07		                rlc     a 
0ec7 cb 07		                rlc     a 
0ec9 cb 07		                rlc     a 
0ecb cb 07		                rlc     a 
0ecd 47			                ld      b, a            ; Save upper four bits 
0ece 7e					ld a,(hl) 
0ecf cd e7 0e		                call    nibble2val      ; Get lower nibble 
0ed2 b0			                or      b               ; Combine both nibbles 
0ed3 c1			                pop     bc              ; Restore B (and C) 
0ed4 c9			                ret 
0ed5			; 
0ed5			; Get a hexadecimal digit from the serial line. This routine blocks until 
0ed5			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0ed5			; to the serial line interface. The lower 4 bits of A contain the value of  
0ed5			; that particular digit. 
0ed5			; 
0ed5			;get_nibble      ld a,(hl)           ; Read a character 
0ed5			;                call    to_upper        ; Convert to upper case 
0ed5			;                call    is_hex          ; Was it a hex digit? 
0ed5			;                jr      nc, get_nibble  ; No, get another character 
0ed5			 ;               call    nibble2val      ; Convert nibble to value 
0ed5			 ;               call    print_nibble 
0ed5			 ;               ret 
0ed5			; 
0ed5			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0ed5			; A valid hexadecimal digit is denoted by a set C flag. 
0ed5			; 
0ed5			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0ed5			;                ret     nc              ; Yes 
0ed5			;                cp      '0'             ; Less than '0'? 
0ed5			;                jr      nc, is_hex_1    ; No, continue 
0ed5			;                ccf                     ; Complement carry (i.e. clear it) 
0ed5			;                ret 
0ed5			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0ed5			;                ret     c               ; Yes 
0ed5			;                cp      'A'             ; Less than 'A'? 
0ed5			;                jr      nc, is_hex_2    ; No, continue 
0ed5			;                ccf                     ; Yes - clear carry and return 
0ed5			;                ret 
0ed5			;is_hex_2        scf                     ; Set carry 
0ed5			;                ret 
0ed5			; 
0ed5			; Convert a single character contained in A to upper case: 
0ed5			; 
0ed5 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0ed7 d8			                ret     c 
0ed8 fe 7b		                cp      'z' + 1         ; > 'z'? 
0eda d0			                ret     nc              ; Nothing to do, either 
0edb e6 5f		                and     $5f             ; Convert to upper case 
0edd c9			                ret 
0ede			 
0ede			 
0ede			to_lower: 
0ede			 
0ede			   ; if char is in [A-Z] make it lower case 
0ede			 
0ede			   ; enter : a = char 
0ede			   ; exit  : a = lower case char 
0ede			   ; uses  : af 
0ede			 
0ede fe 41		   cp 'A' 
0ee0 d8			   ret c 
0ee1			    
0ee1 fe 5b		   cp 'Z'+1 
0ee3 d0			   ret nc 
0ee4			    
0ee4 f6 20		   or $20 
0ee6 c9			   ret 
0ee7			 
0ee7			; 
0ee7			; Expects a hexadecimal digit (upper case!) in A and returns the 
0ee7			; corresponding value in A. 
0ee7			; 
0ee7 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0ee9 38 02		                jr      c, nibble2val_1 ; Yes 
0eeb d6 07		                sub     7               ; Adjust for A-F 
0eed d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0eef e6 0f		                and     $f              ; Only return lower 4 bits 
0ef1 c9			                ret 
0ef2			; 
0ef2			; Print_nibble prints a single hex nibble which is contained in the lower  
0ef2			; four bits of A: 
0ef2			; 
0ef2			;print_nibble    push    af              ; We won't destroy the contents of A 
0ef2			;                and     $f              ; Just in case... 
0ef2			;                add     a, '0'             ; If we have a digit we are done here. 
0ef2			;                cp      '9' + 1         ; Is the result > 9? 
0ef2			;                jr      c, print_nibble_1 
0ef2			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0ef2			;print_nibble_1  call    putc            ; Print the nibble and 
0ef2			;                pop     af              ; restore the original value of A 
0ef2			;                ret 
0ef2			;; 
0ef2			;; Send a CR/LF pair: 
0ef2			; 
0ef2			;crlf            push    af 
0ef2			;                ld      a, cr 
0ef2			;                call    putc 
0ef2			;                ld      a, lf 
0ef2			;                call    putc 
0ef2			;                pop     af 
0ef2			;                ret 
0ef2			; 
0ef2			; Print_word prints the four hex digits of a word to the serial line. The  
0ef2			; word is expected to be in HL. 
0ef2			; 
0ef2			;print_word      push    hl 
0ef2			;                push    af 
0ef2			;                ld      a, h 
0ef2			;                call    print_byte 
0ef2			;                ld      a, l 
0ef2			;                call    print_byte 
0ef2			;                pop     af 
0ef2			;                pop     hl 
0ef2			;                ret 
0ef2			; 
0ef2			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0ef2			; The byte to be printed is expected to be in A. 
0ef2			; 
0ef2			;print_byte      push    af              ; Save the contents of the registers 
0ef2			;                push    bc 
0ef2			;                ld      b, a 
0ef2			;                rrca 
0ef2			;                rrca 
0ef2			;                rrca 
0ef2			;                rrca 
0ef2			;                call    print_nibble    ; Print high nibble 
0ef2			;                ld      a, b 
0ef2			;                call    print_nibble    ; Print low nibble 
0ef2			;                pop     bc              ; Restore original register contents 
0ef2			;                pop     af 
0ef2			;                ret 
0ef2			 
0ef2			 
0ef2			 
0ef2			 
0ef2			 
0ef2			fourehexhl:  
0ef2 7e				ld a,(hl) 
0ef3 cd a1 0e			call atohex 
0ef6 cb 3f				SRL A 
0ef8 cb 3f				SRL A 
0efa cb 3f				SRL A 
0efc cb 3f				SRL A 
0efe 47				ld b, a 
0eff 23				inc hl 
0f00 7e				ld a,(hl) 
0f01 23				inc hl 
0f02 cd a1 0e			call atohex 
0f05 80				add b 
0f06 57				ld d,a 
0f07 7e				ld a,(hl) 
0f08 cd a1 0e			call atohex 
0f0b cb 3f				SRL A 
0f0d cb 3f				SRL A 
0f0f cb 3f				SRL A 
0f11 cb 3f				SRL A 
0f13 47				ld b, a 
0f14 23				inc hl 
0f15 7e				ld a,(hl) 
0f16 23				inc hl 
0f17 cd a1 0e			call atohex 
0f1a 80				add b 
0f1b 5f				ld e, a 
0f1c d5				push de 
0f1d e1				pop hl 
0f1e c9				ret 
0f1f			 
0f1f			; pass hl. returns z set if the byte at hl is a digit 
0f1f			;isdigithl:  
0f1f			;	push bc 
0f1f			;	ld a,(hl) 
0f1f			;	cp ':' 
0f1f			;	jr nc, .isdf 		; > 
0f1f			;	cp '0' 
0f1f			;	jr c, .isdf		; < 
0f1f			; 
0f1f			;	; TODO find a better way to set z 
0f1f			; 
0f1f			;	ld b,a 
0f1f			;	cp b 
0f1f			;	pop bc 
0f1f			;	ret 
0f1f			; 
0f1f			;.isdf:	; not digit so clear z 
0f1f			; 
0f1f			;	; TODO find a better way to unset z 
0f1f			; 
0f1f			;	ld b,a 
0f1f			;	inc b 
0f1f			;	cp b 
0f1f			; 
0f1f			;	pop bc 
0f1f			;	ret 
0f1f				 
0f1f				 
0f1f			 
0f1f			 
0f1f			; pass hl as the four byte address to load 
0f1f			 
0f1f			get_word_hl:  
0f1f e5				push hl 
0f20 cd bf 0e			call get_byte 
0f23				 
0f23 47				ld b, a 
0f24			 
0f24 e1				pop hl 
0f25 23				inc hl 
0f26 23				inc hl 
0f27			 
0f27			; TODO not able to handle a-f  
0f27 7e				ld a,(hl) 
0f28			;	;cp ':' 
0f28			;	cp 'g' 
0f28			;	jr nc, .single_byte_hl 		; > 
0f28			;	cp 'G' 
0f28			;	jr nc, .single_byte_hl 		; > 
0f28			;	cp '0' 
0f28			;	jr c, .single_byte_hl		; < 
0f28			 
0f28				;call isdigithl 
0f28 fe 00			cp 0 
0f2a 28 06			jr z, .single_byte_hl 
0f2c			 
0f2c			.getwhln:   ; hex word so get next byte 
0f2c			 
0f2c cd bf 0e			call get_byte 
0f2f 6f				ld l, a 
0f30 60				ld h,b 
0f31 c9				ret 
0f32 68			.single_byte_hl:   ld l,b 
0f33 26 00				ld h,0 
0f35 c9					ret 
0f36			 
0f36			 
0f36			 
0f36			 
0f36 21 31 16			ld hl,asc+1 
0f39			;	ld a, (hl) 
0f39			;	call nibble2val 
0f39 cd bf 0e			call get_byte 
0f3c			 
0f3c			;	call fourehexhl 
0f3c 32 a9 e3			ld (scratch+52),a 
0f3f				 
0f3f 21 a7 e3			ld hl,scratch+50 
0f42 22 98 e6			ld (os_cur_ptr),hl 
0f45			 
0f45 c9				ret 
0f46			 
0f46			 
0f46			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0f46			 
0f46			; Decimal Unsigned Version 
0f46			 
0f46			;Number in a to decimal ASCII 
0f46			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0f46			;Example: display a=56 as "056" 
0f46			;input: a = number 
0f46			;Output: a=0,value of a in the screen 
0f46			;destroys af,bc (don't know about hl and de) 
0f46			DispAToASCII: 
0f46 0e 9c			ld	c,-100 
0f48 cd 52 0f			call	.Na1 
0f4b 0e f6			ld	c,-10 
0f4d cd 52 0f			call	.Na1 
0f50 0e ff			ld	c,-1 
0f52 06 2f		.Na1:	ld	b,'0'-1 
0f54 04			.Na2:	inc	b 
0f55 81				add	a,c 
0f56 38 fc			jr	c,.Na2 
0f58 91				sub	c		;works as add 100/10/1 
0f59 f5				push af		;safer than ld c,a 
0f5a 78				ld	a,b		;char is in b 
0f5b			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0f5b f1				pop af		;safer than ld a,c 
0f5c c9				ret 
0f5d			 
0f5d			; Decimal Signed Version 
0f5d			 
0f5d			; DispA 
0f5d			; -------------------------------------------------------------- 
0f5d			; Converts a signed integer value to a zero-terminated ASCII 
0f5d			; string representative of that value (using radix 10). 
0f5d			; -------------------------------------------------------------- 
0f5d			; INPUTS: 
0f5d			;     HL     Value to convert (two's complement integer). 
0f5d			;     DE     Base address of string destination. (pointer). 
0f5d			; -------------------------------------------------------------- 
0f5d			; OUTPUTS: 
0f5d			;     None 
0f5d			; -------------------------------------------------------------- 
0f5d			; REGISTERS/MEMORY DESTROYED 
0f5d			; AF HL 
0f5d			; -------------------------------------------------------------- 
0f5d			 
0f5d			;DispHLToASCII: 
0f5d			;   push    de 
0f5d			;   push    bc 
0f5d			; 
0f5d			;; Detect sign of HL. 
0f5d			;    bit    7, h 
0f5d			;    jr     z, ._DoConvert 
0f5d			; 
0f5d			;; HL is negative. Output '-' to string and negate HL. 
0f5d			;    ld     a, '-' 
0f5d			;    ld     (de), a 
0f5d			;    inc    de 
0f5d			; 
0f5d			;; Negate HL (using two's complement) 
0f5d			;    xor    a 
0f5d			;    sub    l 
0f5d			;    ld     l, a 
0f5d			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0f5d			;    sbc    a, h 
0f5d			;    ld     h, a 
0f5d			; 
0f5d			;; Convert HL to digit characters 
0f5d			;._DoConvert: 
0f5d			;    ld     b, 0     ; B will count character length of number 
0f5d			;-   ld     a, 10 
0f5d			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0f5d			;    push   af 
0f5d			;    inc    b 
0f5d			;    ld     a, h 
0f5d			;    or     l 
0f5d			;    jr     nz, - 
0f5d			; 
0f5d			;; Retrieve digits from stack 
0f5d			;-   pop    af 
0f5d			;    or     $30 
0f5d			;    ld     (de), a 
0f5d			;    inc    de 
0f5d			;    djnz   - 
0f5d			; 
0f5d			;; Terminate string with NULL 
0f5d			;    xor    a 
0f5d			;    ld     (de), a 
0f5d			; 
0f5d			;    pop    bc 
0f5d			;    pop    de 
0f5d			;    ret 
0f5d			 
0f5d			;Comments 
0f5d			; 
0f5d			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0f5d			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0f5d			;    Note that the output string will not be fixed-width. 
0f5d			; 
0f5d			;Example Usage 
0f5d			; 
0f5d			;    ld    hl, -1004 
0f5d			;    ld    de, OP1 
0f5d			;    call  DispA 
0f5d			;    ld    hl, OP1 
0f5d			;    syscall  PutS 
0f5d			 
0f5d			 
0f5d			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0f5d			 
0f5d			 
0f5d			;Converts an ASCII string to an unsigned 16-bit integer 
0f5d			;Quits when it reaches a non-decimal digit 
0f5d			 
0f5d			string_to_uint16: 
0f5d			atoui_16: 
0f5d			;Input: 
0f5d			;     DE points to the string 
0f5d			;Outputs: 
0f5d			;     HL is the result 
0f5d			;     A is the 8-bit value of the number 
0f5d			;     DE points to the byte after the number 
0f5d			;Destroys: 
0f5d			;     BC 
0f5d			;       if the string is non-empty, BC is HL/10 
0f5d			;Size:  24 bytes 
0f5d			;Speed: 42+d(104+{0,9}) 
0f5d			;       d is the number of digits in the number 
0f5d			;       max is 640 cycles for a 5 digit number 
0f5d			;Assuming no leading zeros: 
0f5d			;1 digit:  146cc 
0f5d			;2 digit:  250cc 
0f5d			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0f5d			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0f5d			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0f5d			;avg: 544.81158447265625cc (544+13297/16384) 
0f5d			;=============================================================== 
0f5d 21 00 00		  ld hl,0 
0f60			.u16a: 
0f60 1a			  ld a,(de) 
0f61 d6 30		  sub 30h 
0f63 fe 0a		  cp 10 
0f65 d0			  ret nc 
0f66 13			  inc de 
0f67 44			  ld b,h 
0f68 4d			  ld c,l 
0f69 29			  add hl,hl 
0f6a 29			  add hl,hl 
0f6b 09			  add hl,bc 
0f6c 29			  add hl,hl 
0f6d 85			  add a,l 
0f6e 6f			  ld l,a 
0f6f 30 ef		  jr nc,.u16a 
0f71 24			  inc h 
0f72 c3 60 0f		  jp .u16a 
0f75			 
0f75			 
0f75			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0f75			 
0f75			;written by Zeda 
0f75			;Converts a 16-bit unsigned integer to an ASCII string. 
0f75			 
0f75			uitoa_16: 
0f75			;Input: 
0f75			;   DE is the number to convert 
0f75			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0f75			;Output: 
0f75			;   HL points to the null-terminated ASCII string 
0f75			;      NOTE: This isn't necessarily the same as the input HL. 
0f75 d5			  push de 
0f76 c5			  push bc 
0f77 f5			  push af 
0f78 eb			  ex de,hl 
0f79			 
0f79 01 f0 d8		  ld bc,-10000 
0f7c 3e 2f		  ld a,'0'-1 
0f7e 3c			  inc a 
0f7f 09			  add hl,bc  
0f80 38 fc		   jr c,$-2 
0f82 12			  ld (de),a 
0f83 13			  inc de 
0f84			 
0f84 01 e8 03		  ld bc,1000 
0f87 3e 3a		  ld a,'9'+1 
0f89 3d			  dec a  
0f8a 09			  add hl,bc  
0f8b 30 fc		   jr nc,$-2 
0f8d 12			  ld (de),a 
0f8e 13			  inc de 
0f8f			 
0f8f 01 9c ff		  ld bc,-100 
0f92 3e 2f		  ld a,'0'-1 
0f94 3c			  inc a  
0f95 09			  add hl,bc  
0f96 38 fc		   jr c,$-2 
0f98 12			  ld (de),a 
0f99 13			  inc de 
0f9a			 
0f9a 7d			  ld a,l 
0f9b 26 3a		  ld h,'9'+1 
0f9d 25			  dec h  
0f9e c6 0a		  add a,10  
0fa0 30 fb		   jr nc,$-3 
0fa2 c6 30		  add a,'0' 
0fa4 eb			  ex de,hl 
0fa5 72			  ld (hl),d 
0fa6 23			  inc hl 
0fa7 77			  ld (hl),a 
0fa8 23			  inc hl 
0fa9 36 00		  ld (hl),0 
0fab			 
0fab			;Now strip the leading zeros 
0fab 0e fa		  ld c,-6 
0fad 09			  add hl,bc 
0fae 3e 30		  ld a,'0' 
0fb0 23			  inc hl  
0fb1 be			  cp (hl)  
0fb2 28 fc		  jr z,$-2 
0fb4			 
0fb4			;Make sure that the string is non-empty! 
0fb4 7e			  ld a,(hl) 
0fb5 b7			  or a 
0fb6 20 01		  jr nz,.atoub 
0fb8 2b			  dec hl 
0fb9			.atoub: 
0fb9			 
0fb9 f1			  pop af 
0fba c1			  pop bc 
0fbb d1			  pop de 
0fbc c9			  ret 
0fbd			 
0fbd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
0fbd			 
0fbd			toUpper: 
0fbd			;A is the char. 
0fbd			;If A is a lowercase letter, this sets it to the matching uppercase 
0fbd			;18cc or 30cc or 41cc 
0fbd			;avg: 26.75cc 
0fbd fe 61		  cp 'a' 
0fbf d8			  ret c 
0fc0 fe 7b		  cp 'z'+1 
0fc2 d0			  ret nc 
0fc3 d6 20		  sub 'a'-'A' 
0fc5 c9			  ret 
0fc6			 
0fc6			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
0fc6			 
0fc6			; String Length 
0fc6			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
0fc6			 
0fc6			; Get the length of the null-terminated string starting at $8000 hl 
0fc6			;    LD     HL, $8000 
0fc6			 
0fc6			strlenz: 
0fc6			 
0fc6 af			    XOR    A               ; Zero is the value we are looking for. 
0fc7 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
0fc8 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
0fc9			                           ; 65, 536 bytes (the entire addressable memory space). 
0fc9 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0fcb			 
0fcb			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0fcb 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
0fcc 6f			    LD     L, A             ; number of bytes 
0fcd ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0fcf 2b			    DEC    HL              ; Compensate for null. 
0fd0 c9				ret 
0fd1			 
0fd1			; Get the length of the A terminated string starting at $8000 hl 
0fd1			;    LD     HL, $8000 
0fd1			 
0fd1			strlent: 
0fd1			 
0fd1			                  ; A is the value we are looking for. 
0fd1 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
0fd3 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
0fd5			                           ; 65, 536 bytes (the entire addressable memory space). 
0fd5 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0fd7			 
0fd7			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0fd7 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
0fd9 2e 00		    LD     L, 0             ; number of bytes 
0fdb ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0fdd 2b			    DEC    HL              ; Compensate for null. 
0fde c9				ret 
0fdf			 
0fdf			 
0fdf			;Comparing Strings 
0fdf			 
0fdf			;IN    HL     Address of string1. 
0fdf			;      DE     Address of string2. 
0fdf			 
0fdf			; doc given but wrong??? 
0fdf			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
0fdf			;      carry  Set if string1 > string2, reset if string1 <= string2. 
0fdf			; tested 
0fdf			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
0fdf			 
0fdf			strcmp_old: 
0fdf e5			    PUSH   HL 
0fe0 d5			    PUSH   DE 
0fe1			 
0fe1 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
0fe2 be			    CP     (HL)            ; (want to minimize work). 
0fe3 38 01		    JR     C, Str1IsBigger 
0fe5 7e			    LD     A, (HL) 
0fe6			 
0fe6			Str1IsBigger: 
0fe6 4f			    LD     C, A             ; Put length in BC 
0fe7 06 00		    LD     B, 0 
0fe9 13			    INC    DE              ; Increment pointers to meat of string. 
0fea 23			    INC    HL 
0feb			 
0feb			CmpLoop: 
0feb 1a			    LD     A, (DE)          ; Compare bytes. 
0fec ed a1		    CPI 
0fee 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
0ff0 13			    INC    DE              ; Update pointer. 
0ff1 ea eb 0f		    JP     PE, CmpLoop 
0ff4			 
0ff4 d1			    POP    DE 
0ff5 e1			    POP    HL 
0ff6 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
0ff7 be			    CP     (HL) 
0ff8 c9			    RET 
0ff9			 
0ff9			NoMatch: 
0ff9 2b			    DEC    HL 
0ffa be			    CP     (HL)            ; Compare again to affect carry. 
0ffb d1			    POP    DE 
0ffc e1			    POP    HL 
0ffd c9			    RET 
0ffe			 
0ffe			;; test strmp 
0ffe			; 
0ffe			;ld de, .str1 
0ffe			;ld hl, .str2 
0ffe			;call strcmp 
0ffe			;jr z, .z1 
0ffe			;;this 
0ffe			;	if DEBUG_FORTH_WORDS 
0ffe			;		DMARK "NZ1" 
0ffe			;		CALLMONITOR 
0ffe			;	endif 
0ffe			;.z1: 
0ffe			; 
0ffe			;	if DEBUG_FORTH_WORDS 
0ffe			;		DMARK "ZZ1" 
0ffe			;		CALLMONITOR 
0ffe			;	endif 
0ffe			; 
0ffe			;ld de, .str1 
0ffe			;ld hl, .str1 
0ffe			;call strcmp 
0ffe			;jr z, .z2 
0ffe			;;this 
0ffe			;	if DEBUG_FORTH_WORDS 
0ffe			;		DMARK "NZ2" 
0ffe			;		CALLMONITOR 
0ffe			;	endif 
0ffe			;.z2: 
0ffe			; 
0ffe			;	if DEBUG_FORTH_WORDS 
0ffe			;		DMARK "ZZ2" 
0ffe			;		CALLMONITOR 
0ffe			;	endif 
0ffe			; 
0ffe			;ld de, .str1 
0ffe			;ld hl, .str2 
0ffe			;call strcmp 
0ffe			;jr c, .c1 
0ffe			; 
0ffe			;	if DEBUG_FORTH_WORDS 
0ffe			;		DMARK "Nc1" 
0ffe			;		CALLMONITOR 
0ffe			;	endif 
0ffe			;.c1: 
0ffe			;;this 
0ffe			;	if DEBUG_FORTH_WORDS 
0ffe			;		DMARK "cc1" 
0ffe			;		CALLMONITOR 
0ffe			;	endif 
0ffe			; 
0ffe			;ld de, .str1 
0ffe			;ld hl, .str1 
0ffe			;call strcmp 
0ffe			;jr c, .c2 
0ffe			;;this 
0ffe			;	if DEBUG_FORTH_WORDS 
0ffe			;		DMARK "Nc2" 
0ffe			;		CALLMONITOR 
0ffe			;	endif 
0ffe			;.c2: 
0ffe			; 
0ffe			;	if DEBUG_FORTH_WORDS 
0ffe			;		DMARK "cc2" 
0ffe			;		CALLMONITOR 
0ffe			;	endif 
0ffe			;	NEXTW 
0ffe			;.str1:   db "string1",0 
0ffe			;.str2:   db "string2",0 
0ffe			 
0ffe			; only care about direct match or not 
0ffe			; hl and de strings 
0ffe			; zero set if the same 
0ffe			 
0ffe			strcmp: 
0ffe 1a				ld a, (de) 
0fff be				cp (hl) 
1000 28 02			jr z, .ssame 
1002 b7				or a 
1003 c9				ret 
1004			 
1004			.ssame:  
1004 fe 00			cp 0 
1006 c8				ret z 
1007			 
1007 23				inc hl 
1008 13				inc de 
1009 18 f3			jr strcmp 
100b				 
100b				 
100b			 
100b			 
100b			 
100b			 
100b			; eof 
100b			 
100b			 
100b			 
100b			 
100b			 
100b			 
# End of file firmware_strings.asm
100b			include "firmware_memory.asm"   ; malloc and free  
100b			 
100b			if DEBUG_FORTH_MALLOC_HIGH 
100b			.mallocsize: db "Wants malloc >256",0 
100b			.mallocasize: db "MALLOC gives >256",0 
100b			.malloczero: db "MALLOC gives zero",0 
100b			 
100b			malloc_guard_zerolen: 
100b				push hl 
100b				push de 
100b				push af 
100b			 
100b				ld de, 0 
100b			        call cmp16 
100b				jr nz, .lowalloz 
100b			 
100b				push hl 
100b				push de 
100b					ld hl, display_fb0 
100b					ld (display_fb_active), hl 
100b				call clear_display 
100b				ld a, 0 
100b				ld de, .malloczero 
100b				call str_at_display 
100b				call update_display 
100b				call delay1s 
100b				call delay1s 
100b				ld a, 0 
100b				ld (os_view_disable), a 
100b			 
100b				pop de 
100b				pop hl 
100b			 
100b				 
100b			 
100b				CALLMONITOR 
100b			.lowalloz: 
100b			 
100b			 
100b				pop af 
100b				pop de 
100b				pop hl 
100b			ret 
100b			 
100b			malloc_guard_entry: 
100b				push hl 
100b				push de 
100b				push af 
100b			 
100b			 	or a      ;clear carry flag 
100b				push hl 
100b				ld de, 255 
100b				sbc hl, de 
100b				jr c, .lowalloc 
100b			 
100b				push de 
100b					ld hl, display_fb0 
100b					ld (display_fb_active), hl 
100b				call clear_display 
100b				ld a, 0 
100b				ld de, .mallocsize 
100b				call str_at_display 
100b				call update_display 
100b				call delay1s 
100b				call delay1s 
100b				ld a, 0 
100b				ld (os_view_disable), a 
100b			 
100b				pop de 
100b				pop hl 
100b			 
100b				 
100b			 
100b				CALLMONITOR 
100b				jr .lowdone 
100b			.lowalloc: 
100b			 
100b			 
100b				pop hl 
100b			.lowdone:	pop af 
100b				pop de 
100b				pop hl 
100b			ret 
100b			 
100b			malloc_guard_exit: 
100b				push hl 
100b				push de 
100b				push af 
100b			 
100b			 	or a      ;clear carry flag 
100b				push hl 
100b				ld de, 255 
100b				sbc hl, de 
100b				jr c, .lowallocx 
100b			 
100b				push de 
100b					ld hl, display_fb0 
100b					ld (display_fb_active), hl 
100b				call clear_display 
100b				ld a, 0 
100b				ld de, .mallocasize 
100b				call str_at_display 
100b				call update_display 
100b				call delay1s 
100b				call delay1s 
100b				ld a, 0 
100b				ld (os_view_disable), a 
100b				pop de 
100b				pop hl 
100b			 
100b				CALLMONITOR 
100b				jr .lowdonex 
100b			.lowallocx: 
100b			 
100b				pop hl 
100b			.lowdonex:	pop af 
100b				pop de 
100b				pop hl 
100b			ret 
100b			endif 
100b			 
100b			if MALLOC_2 
100b			; Z80 Malloc and Free Functions 
100b			 
100b			; Malloc Function: 
100b			; Input: 
100b			;   HL: Size of block to allocate 
100b			; Output: 
100b			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
100b			 
100b			malloc: 
100b				 
100b			if DEBUG_FORTH_MALLOC_HIGH 
100b			call malloc_guard_entry 
100b			endif 
100b			 
100b			 
100b			 
100b			 
100b					if DEBUG_FORTH_MALLOC 
100b						DMARK "mal" 
100b						CALLMONITOR 
100b					endif 
100b			    push af            ; Save AF register 
100b			    ld a, l            ; Load low byte of size into A 
100b			    or h               ; Check if size is zero 
100b			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
100b			 
100b			    ; Allocate memory 
100b			    ld hl, (heap_start) ; Load start of heap into HL 
100b					if DEBUG_FORTH_MALLOC 
100b						DMARK "ma1" 
100b						CALLMONITOR 
100b					endif 
100b			    call malloc_internal ; Call internal malloc function 
100b			    pop af             ; Restore AF register 
100b			if DEBUG_FORTH_MALLOC_HIGH 
100b			call malloc_guard_exit 
100b			call malloc_guard_zerolen 
100b			endif 
100b			    ret                ; Return 
100b			 
100b			; Free Function: 
100b			; Input: 
100b			;   HL: Pointer to memory block to free 
100b			; Output: 
100b			;   None 
100b			 
100b			free: 
100b			    push af            ; Save AF register 
100b			    ld a, l            ; Load low byte of pointer into A 
100b			    or h               ; Check if pointer is NULL 
100b			    jp z, free_exit    ; If pointer is NULL, exit 
100b			 
100b			    ; Free memory 
100b			    ld hl, (heap_start) ; Load start of heap into HL 
100b			    call free_internal  ; Call internal free function 
100b			    pop af             ; Restore AF register 
100b			    ret                ; Return 
100b			 
100b			; Internal Malloc Function: 
100b			; Input: 
100b			;   HL: Size of block to allocate 
100b			; Output: 
100b			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
100b			 
100b			malloc_internal: 
100b			    ld bc, 2           ; Number of bytes to allocate for management overhead 
100b			    add hl, bc         ; Add management overhead to requested size 
100b			    ex de, hl          ; Save total size in DE, and keep it in HL 
100b					if DEBUG_FORTH_MALLOC 
100b						DMARK "ma2" 
100b						CALLMONITOR 
100b					endif 
100b			 
100b			    ; Search for free memory block 
100b			    ld de, (heap_end)  ; Load end of heap into DE 
100b			    ld bc, 0           ; Initialize counter 
100b			 
100b					if DEBUG_FORTH_MALLOC 
100b						DMARK "ma2" 
100b						CALLMONITOR 
100b					endif 
100b			malloc_search_loop: 
100b			    ; Check if current block is free 
100b			    ld a, (hl)         ; Load current block's status (free or used) 
100b			    cp 0               ; Compare with zero (free) 
100b			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
100b			 
100b			    ; Check if current block is large enough 
100b			    ld a, (hl+1)       ; Load high byte of block size 
100b			    cp l               ; Compare with low byte of requested size 
100b			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
100b			 
100b			    ld a, (hl+2)       ; Load low byte of block size 
100b			    cp h               ; Compare with high byte of requested size 
100b			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
100b			 
100b			    ; Mark block as used 
100b			    ld (hl), 0xFF      ; Set status byte to indicate used block 
100b			 
100b			    ; Calculate remaining space in block 
100b			    ld bc, 0           ; Clear BC 
100b			    add hl, bc         ; Increment HL to point to start of data block 
100b			    add hl, de         ; HL = HL + DE (total size) 
100b			    ld bc, 1           ; Number of bytes to allocate for management overhead 
100b			    add hl, bc         ; Add management overhead to start of data block 
100b			 
100b			    ; Save pointer to allocated block in HL 
100b			if DEBUG_FORTH_MALLOC_HIGH 
100b						DMARK "ma5" 
100b			call malloc_guard_exit 
100b			call malloc_guard_zerolen 
100b			endif 
100b			    ret 
100b			 
100b			malloc_skip_block_check: 
100b			    ; Move to the next block 
100b			    ld bc, 3           ; Size of management overhead 
100b			    add hl, bc         ; Move to the next block 
100b			    inc de             ; Increment counter 
100b			 
100b			    ; Check if we have reached the end of heap 
100b			    ld a, e            ; Load low byte of heap end address 
100b			    cp (hl)            ; Compare with low byte of current address 
100b			    jr nz, malloc_search_loop  ; If not equal, continue searching 
100b			    ld a, d            ; Load high byte of heap end address 
100b			    cp 0               ; Check if it's zero (end of memory) 
100b			    jr nz, malloc_search_loop  ; If not zero, continue searching 
100b			 
100b			    ; If we reached here, allocation failed 
100b			    xor a              ; Set result to NULL 
100b			if DEBUG_FORTH_MALLOC_HIGH 
100b						DMARK "ma6" 
100b			call malloc_guard_exit 
100b			call malloc_guard_zerolen 
100b			endif 
100b			    ret 
100b			malloc_exit: 
100b			if DEBUG_FORTH_MALLOC_HIGH 
100b						DMARK "ma7" 
100b			call malloc_guard_exit 
100b			call malloc_guard_zerolen 
100b			endif 
100b			    ret 
100b			 
100b			; Internal Free Function: 
100b			; Input: 
100b			;   HL: Pointer to memory block to free 
100b			; Output: 
100b			;   None 
100b			 
100b			free_internal: 
100b			    ld de, (heap_start) ; Load start of heap into DE 
100b			    ld bc, 0            ; Initialize counter 
100b			 
100b			free_search_loop: 
100b			    ; Check if current block contains the pointer 
100b			    ld a, l             ; Load low byte of pointer 
100b			    cp (hl+1)           ; Compare with high byte of current block's address 
100b			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
100b			    ld a, h             ; Load high byte of pointer 
100b			    cp (hl+2)           ; Compare with low byte of current block's address 
100b			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
100b			 
100b			    ; Mark block as free 
100b			    ld (hl), 0          ; Set status byte to indicate free block 
100b			    ret                 ; Return 
100b			 
100b			free_skip_block_check: 
100b			    ; Move to the next block 
100b			    ld bc, 3            ; Size of management overhead 
100b			    add hl, bc          ; Move to the next block 
100b			    inc de              ; Increment counter 
100b			 
100b			    ; Check if we have reached the end of heap 
100b			    ld a, e             ; Load low byte of heap end address 
100b			    cp (hl)             ; Compare with low byte of current address 
100b			    jr nz, free_search_loop  ; If not equal, continue searching 
100b			    ld a, d             ; Load high byte of heap end address 
100b			    cp 0                ; Check if it's zero (end of memory) 
100b			    jr nz, free_search_loop  ; If not zero, continue searching 
100b			 
100b			    ; If we reached here, pointer is not found in heap 
100b			    ret 
100b			 
100b			free_exit: 
100b			    ret                 ; Return 
100b			 
100b			; Define heap start and end addresses 
100b			;heap_start:    .dw 0xC000   ; Start of heap 
100b			;heap_end:      .dw 0xE000   ; End of heap 
100b			 
100b			endif 
100b			 
100b			 
100b			if MALLOC_1 
100b			 
100b			 
100b			 
100b			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
100b			 
100b			;moved to firmware.asm 
100b			;heap_start        .equ  0x9000      ; Starting address of heap 
100b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
100b			 
100b			;      .org 0 
100b			;      jp    main 
100b			 
100b			 
100b			;      .org  0x100 
100b			;main: 
100b			;      ld    HL, 0x8100 
100b			;      ld    SP, HL 
100b			; 
100b			;      call  heap_init 
100b			; 
100b			;      ; Make some allocations 
100b			;      ld    HL, 12 
100b			;      call  malloc            ; Allocates 0x9004 
100b			; 
100b			;      ld    HL, 12 
100b			;      call  malloc            ; Allocates 0x9014 
100b			; 
100b			;      ld    HL, 12 
100b			;      call  malloc            ; Allocates 0x9024 
100b			; 
100b			;      ; Free some allocations 
100b			;      ld    HL, 0x9014 
100b			;      call  free 
100b			; 
100b			;      ld    HL, 0x9004 
100b			;      call  free 
100b			; 
100b			;      ld    HL, 0x9024 
100b			;      call  free 
100b			; 
100b			; 
100b			;      halt 
100b			 
100b			 
100b			;------------------------------------------------------------------------------ 
100b			;     heap_init                                                               : 
100b			;                                                                             : 
100b			; Description                                                                 : 
100b			;     Initialise the heap and make it ready for malloc and free operations.   : 
100b			;                                                                             : 
100b			;     The heap is maintained as a linked list, starting with an initial       : 
100b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
100b			;     the first free block in the heap. Each block then points to the next    : 
100b			;     free block within the heap, and the free list ends at the first block   : 
100b			;     with a null pointer to the next free block.                             : 
100b			;                                                                             : 
100b			; Parameters                                                                  : 
100b			;     Inputs are compile-time only. Two defines which specify the starting    : 
100b			;     address of the heap and its size are required, along with a memory      : 
100b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
100b			;     principally stores a pointer to the first free block in the heap.       : 
100b			;                                                                             : 
100b			; Returns                                                                     : 
100b			;     Nothing                                                                 : 
100b			;------------------------------------------------------------------------------ 
100b			heap_init: 
100b e5			      push  HL 
100c			 
100c			      ; Initialise free list struct 
100c 21 fc 57		      ld    HL, heap_start 
100f 22 f7 57		      ld    (free_list), HL 
1012 21 00 00		      ld    HL, 0 
1015 22 f9 57		      ld    (free_list+2), HL 
1018			 
1018			      ; Insert first free block at bottom of heap, consumes entire heap 
1018 21 65 e3		      ld    HL, heap_start+heap_size-4 
101b 22 fc 57		      ld    (heap_start), HL        ; Next block (end of free list) 
101e 21 69 8b		      ld    HL, heap_size-4 
1021 22 fe 57		      ld    (heap_start+2), HL      ; Block size 
1024			 
1024			      ; Insert end of free list block at top of heap - two null words will 
1024			      ; terminate the free list 
1024 21 00 00		      ld    HL, 0 
1027 22 67 e3		      ld    (heap_start+heap_size-2), HL 
102a 22 65 e3		      ld    (heap_start+heap_size-4), HL 
102d			 
102d e1			      pop   HL 
102e			 
102e c9			      ret 
102f			 
102f			 
102f			;------------------------------------------------------------------------------ 
102f			;     malloc                                                                  : 
102f			;                                                                             : 
102f			; Description                                                                 : 
102f			;     Allocates the wanted space from the heap and returns the address of the : 
102f			;     first useable byte of the allocation.                                   : 
102f			;                                                                             : 
102f			;     Allocations can happen in one of two ways:                              : 
102f			;                                                                             : 
102f			;     1. A free block may be found which is the exact size wanted. In this    : 
102f			;        case the block is removed from the free list and retuedn to the      : 
102f			;        caller.                                                              : 
102f			;     2. A free block may be found which is larger than the size wanted. In   : 
102f			;        this case, the larger block is split into two. The first portion of  : 
102f			;        this block will become the requested space by the malloc call and    : 
102f			;        is returned to the caller. The second portion becomes a new free     : 
102f			;        block, and the free list is adjusted to maintain continuity via this : 
102f			;        newly created block.                                                 : 
102f			;                                                                             : 
102f			;     malloc does not set any initial value in the allocated space, the       : 
102f			;     caller is required to do this as required.                              : 
102f			;                                                                             : 
102f			;     This implementation of malloc uses the stack exclusively, and is        : 
102f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
102f			;     advisable to disable interrupts before calling malloc, and recommended  : 
102f			;     to avoid the use of malloc inside ISRs in general.                      : 
102f			;                                                                             : 
102f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
102f			;                                                                             : 
102f			; Parameters                                                                  : 
102f			;     HL  Number of bytes wanted                                              : 
102f			;                                                                             : 
102f			; Returns                                                                     : 
102f			;     HL  Address of the first useable byte of the allocation                 : 
102f			;                                                                             : 
102f			; Flags                                                                       : 
102f			;     Z   Set if the allocation did not succeed, clear otherwise              : 
102f			;                                                                             : 
102f			; Stack frame                                                                 : 
102f			;       |             |                                                       : 
102f			;       +-------------+                                                       : 
102f			;       |     BC      |                                                       : 
102f			;       +-------------+                                                       : 
102f			;       |     DE      |                                                       : 
102f			;       +-------------+                                                       : 
102f			;       |     IX      |                                                       : 
102f			;       +-------------+                                                       : 
102f			;       |  prev_free  |                                                       : 
102f			;   +4  +-------------+                                                       : 
102f			;       |  this_free  |                                                       : 
102f			;   +2  +-------------+                                                       : 
102f			;       |  next_free  |                                                       : 
102f			;   +0  +-------------+                                                       : 
102f			;       |             |                                                       : 
102f			;                                                                             : 
102f			;------------------------------------------------------------------------------ 
102f			 
102f			 
102f			;malloc: 
102f			; 
102f			;	SAVESP ON 1 
102f			; 
102f			;	call malloc_code 
102f			; 
102f			;	CHECKSP ON 1 
102f			;	ret 
102f			 
102f			 
102f			malloc: 
102f c5			      push  BC 
1030 d5			      push  DE 
1031 dd e5		      push  IX 
1033			if DEBUG_FORTH_MALLOC_HIGH 
1033			call malloc_guard_entry 
1033			endif 
1033			 
1033					if DEBUG_FORTH_MALLOC 
1033						DMARK "mal" 
1033						CALLMONITOR 
1033					endif 
1033 7c			      ld    A, H                    ; Exit if no space requested 
1034 b5			      or    L 
1035 ca f4 10		      jp    Z, malloc_early_exit 
1038			 
1038			;inc hl 
1038			;inc hl 
1038			;inc hl 
1038			; 
1038			;inc hl 
1038			;inc hl 
1038			;inc hl 
1038			;inc hl 
1038			;inc hl 
1038			;inc hl 
1038			;inc hl 
1038			;inc hl 
1038			;inc hl 
1038			 
1038			 
1038			 
1038			 
1038					if DEBUG_FORTH_MALLOC 
1038						DMARK "maA" 
1038						CALLMONITOR 
1038					endif 
1038			      ; Set up stack frame 
1038 eb			      ex    DE, HL 
1039 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
103c 39			      add   HL, SP 
103d f9			      ld    SP, HL 
103e dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1042 dd 39		      add   IX, SP 
1044			 
1044			      ; Setup initial state 
1044 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1047 19			      add   HL, DE 
1048			 
1048 44			      ld    B, H                    ; Move want to BC 
1049 4d			      ld    C, L 
104a			 
104a 21 f7 57		      ld    HL, free_list           ; Store prev_free ptr to stack 
104d dd 75 04		      ld    (IX+4), L 
1050 dd 74 05		      ld    (IX+5), H 
1053			 
1053 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1054 23			      inc   HL 
1055 56			      ld    D, (HL) 
1056 dd 73 02		      ld    (IX+2), E 
1059 dd 72 03		      ld    (IX+3), D 
105c eb			      ex    DE, HL                  ; this_free ptr into HL 
105d			 
105d					if DEBUG_FORTH_MALLOC 
105d						DMARK "maB" 
105d						CALLMONITOR 
105d					endif 
105d			      ; Loop through free block list to find some space 
105d			malloc_find_space: 
105d 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
105e 23			      inc   HL 
105f 56			      ld    D, (HL) 
1060			 
1060 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1061 b3			      or    E 
1062 ca ee 10		      jp    Z, malloc_no_space 
1065			 
1065 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1068 dd 72 01		      ld    (IX+1), D 
106b			 
106b			      ; Does this block have enough space to make the allocation? 
106b 23			      inc   HL                      ; Load free block size into DE 
106c 5e			      ld    E, (HL) 
106d 23			      inc   HL 
106e 56			      ld    D, (HL) 
106f			 
106f eb			      ex    DE, HL                  ; Check size of block against want 
1070 b7			      or    A                       ; Ensure carry flag clear 
1071 ed 42		      sbc   HL, BC 
1073 e5			      push  HL                      ; Store the result for later (new block size) 
1074			 
1074 ca c3 10		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1077 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1079			 
1079			      ; this_free block is not big enough, setup ptrs to test next free block 
1079 e1			      pop   HL                      ; Discard previous result 
107a			 
107a dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
107d dd 66 03		      ld    H, (IX+3) 
1080 dd 75 04		      ld    (IX+4), L 
1083 dd 74 05		      ld    (IX+5), H 
1086			 
1086 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1089 dd 66 01		      ld    H, (IX+1) 
108c dd 75 02		      ld    (IX+2), L 
108f dd 74 03		      ld    (IX+3), H 
1092			 
1092					if DEBUG_FORTH_MALLOC 
1092						DMARK "MA>" 
1092						CALLMONITOR 
1092					endif 
1092 18 c9		      jr    malloc_find_space 
1094			 
1094			      ; split a bigger block into two - requested size and remaining size 
1094			malloc_alloc_split: 
1094					if DEBUG_FORTH_MALLOC 
1094						DMARK "MAs" 
1094						CALLMONITOR 
1094					endif 
1094 eb			      ex    DE, HL                  ; Calculate address of new free block 
1095 2b			      dec   HL 
1096 2b			      dec   HL 
1097 2b			      dec   HL 
1098 09			      add   HL, BC 
1099			 
1099			      ; Create a new block and point it at next_free 
1099 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
109c dd 56 01		      ld    D, (IX+1) 
109f			 
109f 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10a0 23			      inc   HL 
10a1 72			      ld    (HL), D 
10a2			 
10a2 d1			      pop   DE                      ; Store size of new block into new block 
10a3 23			      inc   HL 
10a4 73			      ld    (HL), E 
10a5 23			      inc   HL 
10a6 72			      ld    (HL), D 
10a7			 
10a7			      ; Update this_free ptr to point to new block 
10a7 2b			      dec   HL 
10a8 2b			      dec   HL 
10a9 2b			      dec   HL 
10aa			 
10aa dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
10ad dd 56 03		      ld    D, (IX+3) 
10b0			 
10b0 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
10b3 dd 74 03		      ld    (IX+3), H 
10b6			 
10b6			      ; Modify this_free block to be allocation 
10b6 eb			      ex    DE, HL 
10b7 af			      xor   A                       ; Null the next block ptr of allocated block 
10b8 77			      ld    (HL), A 
10b9 23			      inc   HL 
10ba 77			      ld    (HL), A 
10bb			 
10bb 23			      inc   HL                      ; Store want size into allocated block 
10bc 71			      ld    (HL), C 
10bd 23			      inc   HL 
10be 70			      ld    (HL), B 
10bf 23			      inc   HL 
10c0 e5			      push  HL                      ; Address of allocation to return 
10c1			 
10c1 18 19		      jr    malloc_update_links 
10c3			 
10c3			malloc_alloc_fit: 
10c3 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
10c4			 
10c4					if DEBUG_FORTH_MALLOC 
10c4						DMARK "MAf" 
10c4						CALLMONITOR 
10c4					endif 
10c4			      ; Modify this_free block to be allocation 
10c4 eb			      ex    DE, HL 
10c5 2b			      dec   HL 
10c6 2b			      dec   HL 
10c7 2b			      dec   HL 
10c8			 
10c8 af			      xor   A                       ; Null the next block ptr of allocated block 
10c9 77			      ld    (HL), A 
10ca 23			      inc   HL 
10cb 77			      ld    (HL), A 
10cc			 
10cc 23			      inc   HL                      ; Store address of allocation to return 
10cd 23			      inc   HL 
10ce 23			      inc   HL 
10cf e5			      push  HL 
10d0			 
10d0			      ; Copy next_free ptr to this_free, remove allocated block from free list 
10d0 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
10d3 dd 66 01		      ld    H, (IX+1) 
10d6			 
10d6 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
10d9 dd 74 03		      ld    (IX+3), H 
10dc			 
10dc			 
10dc			malloc_update_links: 
10dc			      ; Update prev_free ptr to point to this_free 
10dc dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
10df dd 66 05		      ld    H, (IX+5) 
10e2			 
10e2 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
10e5 dd 56 03		      ld    D, (IX+3) 
10e8			 
10e8 73			      ld    (HL), E                 ; this_free ptr into prev_free 
10e9 23			      inc   HL 
10ea 72			      ld    (HL), D 
10eb			 
10eb					if DEBUG_FORTH_MALLOC 
10eb						DMARK "Mul" 
10eb						CALLMONITOR 
10eb					endif 
10eb			      ; Clear the Z flag to indicate successful allocation 
10eb 7a			      ld    A, D 
10ec b3			      or    E 
10ed			 
10ed d1			      pop   DE                      ; Address of allocation 
10ee					if DEBUG_FORTH_MALLOC 
10ee						DMARK "MAu" 
10ee						CALLMONITOR 
10ee					endif 
10ee			 
10ee			malloc_no_space: 
10ee 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
10f1 39			      add   HL, SP 
10f2 f9			      ld    SP, HL 
10f3			 
10f3 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
10f4					if DEBUG_FORTH_MALLOC 
10f4						DMARK "MAN" 
10f4						CALLMONITOR 
10f4					endif 
10f4			 
10f4			malloc_early_exit: 
10f4					if DEBUG_FORTH_MALLOC 
10f4						DMARK "MAx" 
10f4						CALLMONITOR 
10f4					endif 
10f4 dd e1		      pop   IX 
10f6 d1			      pop   DE 
10f7 c1			      pop   BC 
10f8			 
10f8			if DEBUG_FORTH_MALLOC_HIGH 
10f8			call malloc_guard_exit 
10f8			call malloc_guard_zerolen 
10f8			endif 
10f8 c9			      ret 
10f9			 
10f9			 
10f9			;------------------------------------------------------------------------------ 
10f9			;     free                                                                    : 
10f9			;                                                                             : 
10f9			; Description                                                                 : 
10f9			;     Return the space pointed to by HL to the heap. HL must be an address as : 
10f9			;     returned by malloc, otherwise the behaviour is undefined.               : 
10f9			;                                                                             : 
10f9			;     Where possible, directly adjacent free blocks will be merged together   : 
10f9			;     into larger blocks to help ensure that the heap does not become         : 
10f9			;     excessively fragmented.                                                 : 
10f9			;                                                                             : 
10f9			;     free does not clear or set any other value into the freed space, and    : 
10f9			;     therefore its contents may be visible through subsequent malloc's. The  : 
10f9			;     caller should clear the freed space as required.                        : 
10f9			;                                                                             : 
10f9			;     This implementation of free uses the stack exclusively, and is          : 
10f9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
10f9			;     advisable to disable interrupts before calling free, and recommended    : 
10f9			;     to avoid the use of free inside ISRs in general.                        : 
10f9			;                                                                             : 
10f9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
10f9			;                                                                             : 
10f9			; Parameters                                                                  : 
10f9			;     HL  Pointer to address of first byte of allocation to be freed          : 
10f9			;                                                                             : 
10f9			; Returns                                                                     : 
10f9			;     Nothing                                                                 : 
10f9			;                                                                             : 
10f9			; Stack frame                                                                 : 
10f9			;       |             |                                                       : 
10f9			;       +-------------+                                                       : 
10f9			;       |     BC      |                                                       : 
10f9			;       +-------------+                                                       : 
10f9			;       |     DE      |                                                       : 
10f9			;       +-------------+                                                       : 
10f9			;       |     IX      |                                                       : 
10f9			;       +-------------+                                                       : 
10f9			;       |  prev_free  |                                                       : 
10f9			;   +2  +-------------+                                                       : 
10f9			;       |  next_free  |                                                       : 
10f9			;   +0  +-------------+                                                       : 
10f9			;       |             |                                                       : 
10f9			;                                                                             : 
10f9			;------------------------------------------------------------------------------ 
10f9			free: 
10f9 c5			      push  BC 
10fa d5			      push  DE 
10fb dd e5		      push  IX 
10fd			 
10fd 7c			      ld    A, H                    ; Exit if ptr is null 
10fe b5			      or    L 
10ff ca c3 11		      jp    Z, free_early_exit 
1102			 
1102			      ; Set up stack frame 
1102 eb			      ex    DE, HL 
1103 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1106 39			      add   HL, SP 
1107 f9			      ld    SP, HL 
1108 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
110c dd 39		      add   IX, SP 
110e			 
110e			      ; The address in HL points to the start of the useable allocated space, 
110e			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
110e			      ; address of the block itself. 
110e eb			      ex    DE, HL 
110f 11 fc ff		      ld    DE, -4 
1112 19			      add   HL, DE 
1113			 
1113			      ; An allocated block must have a null next block pointer in it 
1113 7e			      ld    A, (HL) 
1114 23			      inc   HL 
1115 b6			      or    (HL) 
1116 c2 be 11		      jp    NZ, free_done 
1119			 
1119 2b			      dec   HL 
111a			 
111a 44			      ld    B, H                    ; Copy HL to BC 
111b 4d			      ld    C, L 
111c			 
111c			      ; Loop through the free list to find the first block with an address 
111c			      ; higher than the block being freed 
111c 21 f7 57		      ld    HL, free_list 
111f			 
111f			free_find_higher_block: 
111f 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1120 23			      inc   HL 
1121 56			      ld    D, (HL) 
1122 2b			      dec   HL 
1123			 
1123 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1126 dd 72 01		      ld    (IX+1), D 
1129 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
112c dd 74 03		      ld    (IX+3), H 
112f			 
112f 78			      ld    A, B                    ; Check if DE is greater than BC 
1130 ba			      cp    D                       ; Compare MSB first 
1131 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1133 30 04		      jr    NC, free_find_higher_block_skip 
1135 79			      ld    A, C 
1136 bb			      cp    E                       ; Then compare LSB 
1137 38 08		      jr    C, free_found_higher_block 
1139			 
1139			free_find_higher_block_skip: 
1139 7a			      ld    A, D                    ; Reached the end of the free list? 
113a b3			      or    E 
113b ca be 11		      jp    Z, free_done 
113e			 
113e eb			      ex    DE, HL 
113f			 
113f 18 de		      jr    free_find_higher_block 
1141			 
1141			free_found_higher_block: 
1141			      ; Insert freed block between prev and next free blocks 
1141 71			      ld    (HL), C                 ; Point prev free block to freed block 
1142 23			      inc   HL 
1143 70			      ld    (HL), B 
1144			 
1144 60			      ld    H, B                    ; Point freed block at next free block 
1145 69			      ld    L, C 
1146 73			      ld    (HL), E 
1147 23			      inc   HL 
1148 72			      ld    (HL), D 
1149			 
1149			      ; Check if the freed block is adjacent to the next free block 
1149 23			      inc   HL                      ; Load size of freed block into HL 
114a 5e			      ld    E, (HL) 
114b 23			      inc   HL 
114c 56			      ld    D, (HL) 
114d eb			      ex    DE, HL 
114e			 
114e 09			      add   HL, BC                  ; Add addr of freed block and its size 
114f			 
114f dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1152 dd 56 01		      ld    D, (IX+1) 
1155			 
1155 b7			      or    A                       ; Clear the carry flag 
1156 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1158 20 22		      jr    NZ, free_check_adjacent_to_prev 
115a			 
115a			      ; Freed block is adjacent to next, merge into one bigger block 
115a eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
115b 5e			      ld    E, (HL) 
115c 23			      inc   HL 
115d 56			      ld    D, (HL) 
115e e5			      push  HL                      ; Save ptr to next block for later 
115f			 
115f 60			      ld    H, B                    ; Store ptr from next block into freed block 
1160 69			      ld    L, C 
1161 73			      ld    (HL), E 
1162 23			      inc   HL 
1163 72			      ld    (HL), D 
1164			 
1164 e1			      pop   HL                      ; Restore ptr to next block 
1165 23			      inc   HL                      ; Load size of next block into DE 
1166 5e			      ld    E, (HL) 
1167 23			      inc   HL 
1168 56			      ld    D, (HL) 
1169 d5			      push  DE                      ; Save next block size for later 
116a			 
116a 60			      ld    H, B                    ; Load size of freed block into HL 
116b 69			      ld    L, C 
116c 23			      inc   HL 
116d 23			      inc   HL 
116e 5e			      ld    E, (HL) 
116f 23			      inc   HL 
1170 56			      ld    D, (HL) 
1171 eb			      ex    DE, HL 
1172			 
1172 d1			      pop   DE                      ; Restore size of next block 
1173 19			      add   HL, DE                  ; Add sizes of both blocks 
1174 eb			      ex    DE, HL 
1175			 
1175 60			      ld    H, B                    ; Store new bigger size into freed block 
1176 69			      ld    L, C 
1177 23			      inc   HL 
1178 23			      inc   HL 
1179 73			      ld    (HL), E 
117a 23			      inc   HL 
117b 72			      ld    (HL), D 
117c			 
117c			free_check_adjacent_to_prev: 
117c			      ; Check if the freed block is adjacent to the prev free block 
117c dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
117f dd 66 03		      ld    H, (IX+3) 
1182			 
1182 23			      inc   HL                      ; Size of prev free block into DE 
1183 23			      inc   HL 
1184 5e			      ld    E, (HL) 
1185 23			      inc   HL 
1186 56			      ld    D, (HL) 
1187 2b			      dec   HL 
1188 2b			      dec   HL 
1189 2b			      dec   HL 
118a			 
118a 19			      add   HL, DE                  ; Add prev block addr and size 
118b			 
118b b7			      or    A                       ; Clear the carry flag 
118c ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
118e 20 2e		      jr    NZ, free_done 
1190			 
1190			      ; Freed block is adjacent to prev, merge into one bigger block 
1190 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1191 69			      ld    L, C 
1192 5e			      ld    E, (HL) 
1193 23			      inc   HL 
1194 56			      ld    D, (HL) 
1195 e5			      push  HL                      ; Save freed block ptr for later 
1196			 
1196 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1199 dd 66 03		      ld    H, (IX+3) 
119c 73			      ld    (HL), E 
119d 23			      inc   HL 
119e 72			      ld    (HL), D 
119f			 
119f e1			      pop   HL                      ; Restore freed block ptr 
11a0 23			      inc   HL                      ; Load size of freed block into DE 
11a1 5e			      ld    E, (HL) 
11a2 23			      inc   HL 
11a3 56			      ld    D, (HL) 
11a4 d5			      push  DE                      ; Save freed block size for later 
11a5			 
11a5 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
11a8 dd 66 03		      ld    H, (IX+3) 
11ab 23			      inc   HL 
11ac 23			      inc   HL 
11ad 5e			      ld    E, (HL) 
11ae 23			      inc   HL 
11af 56			      ld    D, (HL) 
11b0			 
11b0 e1			      pop   HL                      ; Add sizes of both blocks 
11b1 19			      add   HL, DE 
11b2 eb			      ex    DE, HL 
11b3			 
11b3 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
11b6 dd 66 03		      ld    H, (IX+3) 
11b9 23			      inc   HL 
11ba 23			      inc   HL 
11bb 73			      ld    (HL), E 
11bc 23			      inc   HL 
11bd 72			      ld    (HL), D 
11be			 
11be			free_done: 
11be 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
11c1 39			      add   HL, SP 
11c2 f9			      ld    SP, HL 
11c3			 
11c3			free_early_exit: 
11c3 dd e1		      pop   IX 
11c5 d1			      pop   DE 
11c6 c1			      pop   BC 
11c7			 
11c7 c9			      ret 
11c8			 
11c8			; moved to firmware.asm 
11c8			; 
11c8			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
11c8			;                  .dw   0 
11c8			 
11c8			 
11c8			endif 
11c8			 
11c8			 
11c8			if MALLOC_3 
11c8			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
11c8			;heap_start        .equ  0x9000      ; Starting address of heap 
11c8			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11c8			; 
11c8			 ;     .org 0 
11c8			  ;    jp    main 
11c8			; 
11c8			; 
11c8			 ;     .org  0x100 
11c8			;main: 
11c8			 ;     ld    HL, 0x8100 
11c8			  ;    ld    SP, HL 
11c8			; 
11c8			;      call  heap_init 
11c8			 
11c8			      ; Make some allocations 
11c8			;      ld    HL, 12 
11c8			;      call  malloc            ; Allocates 0x9004 
11c8			; 
11c8			 ;     ld    HL, 12 
11c8			;      call  malloc            ; Allocates 0x9014 
11c8			 
11c8			;      ld    HL, 12 
11c8			;      call  malloc            ; Allocates 0x9024 
11c8			 
11c8			      ; Free some allocations 
11c8			;      ld    HL, 0x9014 
11c8			;      call  free 
11c8			 
11c8			;      ld    HL, 0x9004 
11c8			;      call  free 
11c8			; 
11c8			;      ld    HL, 0x9024 
11c8			;      call  free 
11c8			 
11c8			 
11c8			 ;     halt 
11c8			 
11c8			 
11c8			;------------------------------------------------------------------------------ 
11c8			;     heap_init                                                               : 
11c8			;                                                                             : 
11c8			; Description                                                                 : 
11c8			;     Initialise the heap and make it ready for malloc and free operations.   : 
11c8			;                                                                             : 
11c8			;     The heap is maintained as a linked list, starting with an initial       : 
11c8			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11c8			;     the first free block in the heap. Each block then points to the next    : 
11c8			;     free block within the heap, and the free list ends at the first block   : 
11c8			;     with a null pointer to the next free block.                             : 
11c8			;                                                                             : 
11c8			; Parameters                                                                  : 
11c8			;     Inputs are compile-time only. Two defines which specify the starting    : 
11c8			;     address of the heap and its size are required, along with a memory      : 
11c8			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11c8			;     principally stores a pointer to the first free block in the heap.       : 
11c8			;                                                                             : 
11c8			; Returns                                                                     : 
11c8			;     Nothing                                                                 : 
11c8			;------------------------------------------------------------------------------ 
11c8			heap_init: 
11c8			      push  HL 
11c8			 
11c8			      ; Initialise free list struct 
11c8			      ld    HL, heap_start 
11c8			      ld    (free_list), HL 
11c8			      ld    HL, 0 
11c8			      ld    (free_list+2), HL 
11c8			 
11c8			      ; Insert first free block at bottom of heap, consumes entire heap 
11c8			      ld    HL, heap_start+heap_size-4 
11c8			      ld    (heap_start), HL        ; Next block (end of free list) 
11c8			      ld    HL, heap_size-4 
11c8			      ld    (heap_start+2), HL      ; Block size 
11c8			 
11c8			      ; Insert end of free list block at top of heap - two null words will 
11c8			      ; terminate the free list 
11c8			      ld    HL, 0 
11c8			      ld    (heap_start+heap_size-2), HL 
11c8			      ld    (heap_start+heap_size-4), HL 
11c8			 
11c8			      pop   HL 
11c8			 
11c8			      ret 
11c8			 
11c8			 
11c8			;------------------------------------------------------------------------------ 
11c8			;     malloc                                                                  : 
11c8			;                                                                             : 
11c8			; Description                                                                 : 
11c8			;     Allocates the wanted space from the heap and returns the address of the : 
11c8			;     first useable byte of the allocation.                                   : 
11c8			;                                                                             : 
11c8			;     Allocations can happen in one of two ways:                              : 
11c8			;                                                                             : 
11c8			;     1. A free block may be found which is the exact size wanted. In this    : 
11c8			;        case the block is removed from the free list and retuedn to the      : 
11c8			;        caller.                                                              : 
11c8			;     2. A free block may be found which is larger than the size wanted. In   : 
11c8			;        this case, the larger block is split into two. The first portion of  : 
11c8			;        this block will become the requested space by the malloc call and    : 
11c8			;        is returned to the caller. The second portion becomes a new free     : 
11c8			;        block, and the free list is adjusted to maintain continuity via this : 
11c8			;        newly created block.                                                 : 
11c8			;                                                                             : 
11c8			;     malloc does not set any initial value in the allocated space, the       : 
11c8			;     caller is required to do this as required.                              : 
11c8			;                                                                             : 
11c8			;     This implementation of malloc uses the stack exclusively, and is        : 
11c8			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11c8			;     advisable to disable interrupts before calling malloc, and recommended  : 
11c8			;     to avoid the use of malloc inside ISRs in general.                      : 
11c8			;                                                                             : 
11c8			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11c8			;                                                                             : 
11c8			; Parameters                                                                  : 
11c8			;     HL  Number of bytes wanted                                              : 
11c8			;                                                                             : 
11c8			; Returns                                                                     : 
11c8			;     HL  Address of the first useable byte of the allocation                 : 
11c8			;                                                                             : 
11c8			; Flags                                                                       : 
11c8			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11c8			;                                                                             : 
11c8			; Stack frame                                                                 : 
11c8			;       |             |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |     BC      |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |     DE      |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |     IX      |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |  prev_free  |                                                       : 
11c8			;   +4  +-------------+                                                       : 
11c8			;       |  this_free  |                                                       : 
11c8			;   +2  +-------------+                                                       : 
11c8			;       |  next_free  |                                                       : 
11c8			;   +0  +-------------+                                                       : 
11c8			;       |             |                                                       : 
11c8			;                                                                             : 
11c8			;------------------------------------------------------------------------------ 
11c8			malloc: 
11c8			      push  BC 
11c8			      push  DE 
11c8			      push  IX 
11c8			 
11c8			      ld    A, H                    ; Exit if no space requested 
11c8			      or    L 
11c8			      jp    Z, malloc_early_exit 
11c8			 
11c8			      ; Set up stack frame 
11c8			      ex    DE, HL 
11c8			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11c8			      add   HL, SP 
11c8			      ld    SP, HL 
11c8			      ld    IX, 0                   ; Use IX as a frame pointer 
11c8			      add   IX, SP 
11c8			 
11c8			      ; Setup initial state 
11c8			      ld    HL, 4                   ; want must also include space used by block struct 
11c8			      add   HL, DE 
11c8			 
11c8			      ld    B, H                    ; Move want to BC 
11c8			      ld    C, L 
11c8			 
11c8			      ld    HL, free_list           ; Store prev_free ptr to stack 
11c8			      ld    (IX+4), L 
11c8			      ld    (IX+5), H 
11c8			 
11c8			      ld    E, (HL)                 ; Store this_free ptr to stack 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			      ld    (IX+2), E 
11c8			      ld    (IX+3), D 
11c8			      ex    DE, HL                  ; this_free ptr into HL 
11c8			 
11c8			      ; Loop through free block list to find some space 
11c8			malloc_find_space: 
11c8			      ld    E, (HL)                 ; Load next_free ptr into DE 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			 
11c8			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11c8			      or    E 
11c8			      jp    Z, malloc_no_space 
11c8			 
11c8			      ld    (IX+0), E               ; Store next_free ptr to stack 
11c8			      ld    (IX+1), D 
11c8			 
11c8			      ; Does this block have enough space to make the allocation? 
11c8			      inc   HL                      ; Load free block size into DE 
11c8			      ld    E, (HL) 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			 
11c8			      ex    DE, HL                  ; Check size of block against want 
11c8			      or    A                       ; Ensure carry flag clear 
11c8			      sbc   HL, BC 
11c8			      push  HL                      ; Store the result for later (new block size) 
11c8			 
11c8			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11c8			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11c8			 
11c8			      ; this_free block is not big enough, setup ptrs to test next free block 
11c8			      pop   HL                      ; Discard previous result 
11c8			 
11c8			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
11c8			      ld    H, (IX+3) 
11c8			      ld    (IX+4), L 
11c8			      ld    (IX+5), H 
11c8			 
11c8			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
11c8			      ld    H, (IX+1) 
11c8			      ld    (IX+2), L 
11c8			      ld    (IX+3), H 
11c8			 
11c8			      jr    malloc_find_space 
11c8			 
11c8			      ; split a bigger block into two - requested size and remaining size 
11c8			malloc_alloc_split: 
11c8			      ex    DE, HL                  ; Calculate address of new free block 
11c8			      dec   HL 
11c8			      dec   HL 
11c8			      dec   HL 
11c8			      add   HL, BC 
11c8			 
11c8			      ; Create a new block and point it at next_free 
11c8			      ld    E, (IX+0)               ; Load next_free ptr into DE 
11c8			      ld    D, (IX+1) 
11c8			 
11c8			      ld    (HL), E                 ; Store next_free ptr into new block 
11c8			      inc   HL 
11c8			      ld    (HL), D 
11c8			 
11c8			      pop   DE                      ; Store size of new block into new block 
11c8			      inc   HL 
11c8			      ld    (HL), E 
11c8			      inc   HL 
11c8			      ld    (HL), D 
11c8			 
11c8			      ; Update this_free ptr to point to new block 
11c8			      dec   HL 
11c8			      dec   HL 
11c8			      dec   HL 
11c8			 
11c8			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
11c8			      ld    D, (IX+3) 
11c8			 
11c8			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
11c8			      ld    (IX+3), H 
11c8			 
11c8			      ; Modify this_free block to be allocation 
11c8			      ex    DE, HL 
11c8			      xor   A                       ; Null the next block ptr of allocated block 
11c8			      ld    (HL), A 
11c8			      inc   HL 
11c8			      ld    (HL), A 
11c8			 
11c8			      inc   HL                      ; Store want size into allocated block 
11c8			      ld    (HL), C 
11c8			      inc   HL 
11c8			      ld    (HL), B 
11c8			      inc   HL 
11c8			      push  HL                      ; Address of allocation to return 
11c8			 
11c8			      jr    malloc_update_links 
11c8			 
11c8			malloc_alloc_fit: 
11c8			      pop   HL                      ; Dont need new block size, want is exact fit 
11c8			 
11c8			      ; Modify this_free block to be allocation 
11c8			      ex    DE, HL 
11c8			      dec   HL 
11c8			      dec   HL 
11c8			      dec   HL 
11c8			 
11c8			      xor   A                       ; Null the next block ptr of allocated block 
11c8			      ld    (HL), A 
11c8			      inc   HL 
11c8			      ld    (HL), A 
11c8			 
11c8			      inc   HL                      ; Store address of allocation to return 
11c8			      inc   HL 
11c8			      inc   HL 
11c8			      push  HL 
11c8			 
11c8			      ; Copy next_free ptr to this_free, remove allocated block from free list 
11c8			      ld    L, (IX+0)               ; next_free to HL 
11c8			      ld    H, (IX+1) 
11c8			 
11c8			      ld    (IX+2), L               ; HL to this_free 
11c8			      ld    (IX+3), H 
11c8			 
11c8			 
11c8			malloc_update_links: 
11c8			      ; Update prev_free ptr to point to this_free 
11c8			      ld    L, (IX+4)               ; prev_free ptr to HL 
11c8			      ld    H, (IX+5) 
11c8			 
11c8			      ld    E, (IX+2)               ; this_free ptr to DE 
11c8			      ld    D, (IX+3) 
11c8			 
11c8			      ld    (HL), E                 ; this_free ptr into prev_free 
11c8			      inc   HL 
11c8			      ld    (HL), D 
11c8			 
11c8			      ; Clear the Z flag to indicate successful allocation 
11c8			      ld    A, D 
11c8			      or    E 
11c8			 
11c8			      pop   DE                      ; Address of allocation 
11c8			 
11c8			malloc_no_space: 
11c8			      ld    HL, 6                   ; Clean up stack frame 
11c8			      add   HL, SP 
11c8			      ld    SP, HL 
11c8			 
11c8			      ex    DE, HL                  ; Alloc addr into HL for return 
11c8			 
11c8			malloc_early_exit: 
11c8			      pop   IX 
11c8			      pop   DE 
11c8			      pop   BC 
11c8			 
11c8			      ret 
11c8			 
11c8			 
11c8			;------------------------------------------------------------------------------ 
11c8			;     free                                                                    : 
11c8			;                                                                             : 
11c8			; Description                                                                 : 
11c8			;     Return the space pointed to by HL to the heap. HL must be an address as : 
11c8			;     returned by malloc, otherwise the behaviour is undefined.               : 
11c8			;                                                                             : 
11c8			;     Where possible, directly adjacent free blocks will be merged together   : 
11c8			;     into larger blocks to help ensure that the heap does not become         : 
11c8			;     excessively fragmented.                                                 : 
11c8			;                                                                             : 
11c8			;     free does not clear or set any other value into the freed space, and    : 
11c8			;     therefore its contents may be visible through subsequent malloc's. The  : 
11c8			;     caller should clear the freed space as required.                        : 
11c8			;                                                                             : 
11c8			;     This implementation of free uses the stack exclusively, and is          : 
11c8			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11c8			;     advisable to disable interrupts before calling free, and recommended    : 
11c8			;     to avoid the use of free inside ISRs in general.                        : 
11c8			;                                                                             : 
11c8			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11c8			;                                                                             : 
11c8			; Parameters                                                                  : 
11c8			;     HL  Pointer to address of first byte of allocation to be freed          : 
11c8			;                                                                             : 
11c8			; Returns                                                                     : 
11c8			;     Nothing                                                                 : 
11c8			;                                                                             : 
11c8			; Stack frame                                                                 : 
11c8			;       |             |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |     BC      |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |     DE      |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |     IX      |                                                       : 
11c8			;       +-------------+                                                       : 
11c8			;       |  prev_free  |                                                       : 
11c8			;   +2  +-------------+                                                       : 
11c8			;       |  next_free  |                                                       : 
11c8			;   +0  +-------------+                                                       : 
11c8			;       |             |                                                       : 
11c8			;                                                                             : 
11c8			;------------------------------------------------------------------------------ 
11c8			free: 
11c8			      push  BC 
11c8			      push  DE 
11c8			      push  IX 
11c8			 
11c8			      ld    A, H                    ; Exit if ptr is null 
11c8			      or    L 
11c8			      jp    Z, free_early_exit 
11c8			 
11c8			      ; Set up stack frame 
11c8			      ex    DE, HL 
11c8			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
11c8			      add   HL, SP 
11c8			      ld    SP, HL 
11c8			      ld    IX, 0                   ; Use IX as a frame pointer 
11c8			      add   IX, SP 
11c8			 
11c8			      ; The address in HL points to the start of the useable allocated space, 
11c8			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
11c8			      ; address of the block itself. 
11c8			      ex    DE, HL 
11c8			      ld    DE, -4 
11c8			      add   HL, DE 
11c8			 
11c8			      ; An allocated block must have a null next block pointer in it 
11c8			      ld    A, (HL) 
11c8			      inc   HL 
11c8			      or    (HL) 
11c8			      jp    NZ, free_done 
11c8			 
11c8			      dec   HL 
11c8			 
11c8			      ld    B, H                    ; Copy HL to BC 
11c8			      ld    C, L 
11c8			 
11c8			      ; Loop through the free list to find the first block with an address 
11c8			      ; higher than the block being freed 
11c8			      ld    HL, free_list 
11c8			 
11c8			free_find_higher_block: 
11c8			      ld    E, (HL)                 ; Load next ptr from free block 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			      dec   HL 
11c8			 
11c8			      ld    (IX+0), E               ; Save ptr to next free block 
11c8			      ld    (IX+1), D 
11c8			      ld    (IX+2), L               ; Save ptr to prev free block 
11c8			      ld    (IX+3), H 
11c8			 
11c8			      ld    A, B                    ; Check if DE is greater than BC 
11c8			      cp    D                       ; Compare MSB first 
11c8			      jr    Z, $+4                  ; MSB the same, compare LSB 
11c8			      jr    NC, free_find_higher_block_skip 
11c8			      ld    A, C 
11c8			      cp    E                       ; Then compare LSB 
11c8			      jr    C, free_found_higher_block 
11c8			 
11c8			free_find_higher_block_skip: 
11c8			      ld    A, D                    ; Reached the end of the free list? 
11c8			      or    E 
11c8			      jp    Z, free_done 
11c8			 
11c8			      ex    DE, HL 
11c8			 
11c8			      jr    free_find_higher_block 
11c8			 
11c8			free_found_higher_block: 
11c8			      ; Insert freed block between prev and next free blocks 
11c8			      ld    (HL), C                 ; Point prev free block to freed block 
11c8			      inc   HL 
11c8			      ld    (HL), B 
11c8			 
11c8			      ld    H, B                    ; Point freed block at next free block 
11c8			      ld    L, C 
11c8			      ld    (HL), E 
11c8			      inc   HL 
11c8			      ld    (HL), D 
11c8			 
11c8			      ; Check if the freed block is adjacent to the next free block 
11c8			      inc   HL                      ; Load size of freed block into HL 
11c8			      ld    E, (HL) 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			      ex    DE, HL 
11c8			 
11c8			      add   HL, BC                  ; Add addr of freed block and its size 
11c8			 
11c8			      ld    E, (IX+0)               ; Load addr of next free block into DE 
11c8			      ld    D, (IX+1) 
11c8			 
11c8			      or    A                       ; Clear the carry flag 
11c8			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11c8			      jr    NZ, free_check_adjacent_to_prev 
11c8			 
11c8			      ; Freed block is adjacent to next, merge into one bigger block 
11c8			      ex    DE, HL                  ; Load next ptr from next block into DE 
11c8			      ld    E, (HL) 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			      push  HL                      ; Save ptr to next block for later 
11c8			 
11c8			      ld    H, B                    ; Store ptr from next block into freed block 
11c8			      ld    L, C 
11c8			      ld    (HL), E 
11c8			      inc   HL 
11c8			      ld    (HL), D 
11c8			 
11c8			      pop   HL                      ; Restore ptr to next block 
11c8			      inc   HL                      ; Load size of next block into DE 
11c8			      ld    E, (HL) 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			      push  DE                      ; Save next block size for later 
11c8			 
11c8			      ld    H, B                    ; Load size of freed block into HL 
11c8			      ld    L, C 
11c8			      inc   HL 
11c8			      inc   HL 
11c8			      ld    E, (HL) 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			      ex    DE, HL 
11c8			 
11c8			      pop   DE                      ; Restore size of next block 
11c8			      add   HL, DE                  ; Add sizes of both blocks 
11c8			      ex    DE, HL 
11c8			 
11c8			      ld    H, B                    ; Store new bigger size into freed block 
11c8			      ld    L, C 
11c8			      inc   HL 
11c8			      inc   HL 
11c8			      ld    (HL), E 
11c8			      inc   HL 
11c8			      ld    (HL), D 
11c8			 
11c8			free_check_adjacent_to_prev: 
11c8			      ; Check if the freed block is adjacent to the prev free block 
11c8			      ld    L, (IX+2)               ; Prev free block ptr into HL 
11c8			      ld    H, (IX+3) 
11c8			 
11c8			      inc   HL                      ; Size of prev free block into DE 
11c8			      inc   HL 
11c8			      ld    E, (HL) 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			      dec   HL 
11c8			      dec   HL 
11c8			      dec   HL 
11c8			 
11c8			      add   HL, DE                  ; Add prev block addr and size 
11c8			 
11c8			      or    A                       ; Clear the carry flag 
11c8			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11c8			      jr    NZ, free_done 
11c8			 
11c8			      ; Freed block is adjacent to prev, merge into one bigger block 
11c8			      ld    H, B                    ; Load next ptr from freed block into DE 
11c8			      ld    L, C 
11c8			      ld    E, (HL) 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			      push  HL                      ; Save freed block ptr for later 
11c8			 
11c8			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11c8			      ld    H, (IX+3) 
11c8			      ld    (HL), E 
11c8			      inc   HL 
11c8			      ld    (HL), D 
11c8			 
11c8			      pop   HL                      ; Restore freed block ptr 
11c8			      inc   HL                      ; Load size of freed block into DE 
11c8			      ld    E, (HL) 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			      push  DE                      ; Save freed block size for later 
11c8			 
11c8			      ld    L, (IX+2)               ; Load size of prev block into DE 
11c8			      ld    H, (IX+3) 
11c8			      inc   HL 
11c8			      inc   HL 
11c8			      ld    E, (HL) 
11c8			      inc   HL 
11c8			      ld    D, (HL) 
11c8			 
11c8			      pop   HL                      ; Add sizes of both blocks 
11c8			      add   HL, DE 
11c8			      ex    DE, HL 
11c8			 
11c8			      ld    L, (IX+2)               ; Store new bigger size into prev block 
11c8			      ld    H, (IX+3) 
11c8			      inc   HL 
11c8			      inc   HL 
11c8			      ld    (HL), E 
11c8			      inc   HL 
11c8			      ld    (HL), D 
11c8			 
11c8			free_done: 
11c8			      ld    HL, 4                   ; Clean up stack frame 
11c8			      add   HL, SP 
11c8			      ld    SP, HL 
11c8			 
11c8			free_early_exit: 
11c8			      pop   IX 
11c8			      pop   DE 
11c8			      pop   BC 
11c8			 
11c8			      ret 
11c8			 
11c8			 
11c8			;      .org 0x8000 
11c8			; 
11c8			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
11c8			 ;                 .dw   0 
11c8			 
11c8			endif 
11c8			 
11c8			 
11c8			if MALLOC_4 
11c8			 
11c8			; My memory allocation code. Very very simple.... 
11c8			; allocate space under 250 chars 
11c8			 
11c8			heap_init: 
11c8				; init start of heap as zero 
11c8				;  
11c8			 
11c8				ld hl, heap_start 
11c8				ld a, 0 
11c8				ld (hl), a      ; empty block 
11c8				inc hl 
11c8				ld a, 0 
11c8				ld (hl), a      ; length of block 
11c8				; write end of list 
11c8				inc hl 
11c8				ld a,(hl) 
11c8				inc hl 
11c8				ld a,(hl) 
11c8				 
11c8			 
11c8				; init some malloc vars 
11c8			 
11c8				ld hl, 0 
11c8				ld (free_list), hl       ; store last malloc location 
11c8			 
11c8				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
11c8				ld a, 0 
11c8				ld (hl), a 
11c8			 
11c8			 
11c8				ld hl, heap_start 
11c8				;  
11c8				  
11c8				ret 
11c8			 
11c8			 
11c8			;    free block marker 
11c8			;    requested size  
11c8			;    pointer to next block 
11c8			;    .... 
11c8			;    next block marker 
11c8			 
11c8			 
11c8			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
11c8			; 
11c8			 
11c8			 
11c8			malloc:  
11c8				push de 
11c8				push bc 
11c8				push af 
11c8			 
11c8				; hl space required 
11c8				 
11c8				ld c, l    ; hold space   (TODO only a max of 255) 
11c8			 
11c8			;	inc c     ; TODO BUG need to fix memory leak on push str 
11c8			;	inc c 
11c8			;	inc c 
11c8			;	inc c 
11c8			;	inc c 
11c8			;	inc c 
11c8			;	inc c 
11c8			 
11c8			 
11c8			 
11c8				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
11c8			 
11c8				ld a, (free_list+3) 
11c8				cp 0 
11c8				jr z, .contheap 
11c8			 
11c8				ld hl, (free_list)     ; get last alloc 
11c8					if DEBUG_FORTH_MALLOC_INT 
11c8						DMARK "mrs" 
11c8						CALLMONITOR 
11c8					endif 
11c8				jr .startalloc 
11c8			 
11c8			.contheap: 
11c8				ld hl, heap_start 
11c8			 
11c8			.startalloc: 
11c8			 
11c8					if DEBUG_FORTH_MALLOC_INT 
11c8						DMARK "mym" 
11c8						CALLMONITOR 
11c8					endif 
11c8			.findblock: 
11c8					if DEBUG_FORTH_MALLOC_INT 
11c8						DMARK "mmf" 
11c8						CALLMONITOR 
11c8					endif 
11c8			 
11c8				ld a,(hl)  
11c8				; if byte is zero then clear to use 
11c8			 
11c8				cp 0 
11c8				jr z, .foundemptyblock 
11c8			 
11c8				; if byte is not clear 
11c8				;     then byte is offset to next block 
11c8			 
11c8				inc hl 
11c8				ld a, (hl) ; get size 
11c8			.nextblock:	inc hl 
11c8					ld e, (hl) 
11c8					inc hl 
11c8					ld d, (hl) 
11c8					ex de, hl 
11c8			;	inc hl  ; move past the store space 
11c8			;	inc hl  ; move past zero index  
11c8			 
11c8				; TODO detect no more space 
11c8			 
11c8				push hl 
11c8				ld de, heap_end 
11c8				call cmp16 
11c8				pop hl 
11c8				jr nc, .nospace 
11c8			 
11c8				jr .findblock 
11c8			 
11c8			.nospace: ld hl, 0 
11c8				jp .exit 
11c8			 
11c8			 
11c8			.foundemptyblock:	 
11c8					if DEBUG_FORTH_MALLOC_INT 
11c8						DMARK "mme" 
11c8						CALLMONITOR 
11c8					endif 
11c8			 
11c8			; TODO has block enough space if reusing??? 
11c8			 
11c8				;  
11c8			 
11c8			; see if this block has been previously used 
11c8				inc hl 
11c8				ld a, (hl) 
11c8				dec hl 
11c8				cp 0 
11c8				jr z, .newblock 
11c8			 
11c8					if DEBUG_FORTH_MALLOC_INT 
11c8						DMARK "meR" 
11c8						CALLMONITOR 
11c8					endif 
11c8			 
11c8			; no reusing previously allocated block 
11c8			 
11c8			; is it smaller than previously used? 
11c8				 
11c8				inc hl    ; move to size 
11c8				ld a, c 
11c8				sub (hl)        ; we want c < (hl) 
11c8				dec hl    ; move back to marker 
11c8			        jr z, .findblock 
11c8			 
11c8				; update with the new size which should be lower 
11c8			 
11c8			        ;inc  hl   ; negate next move. move back to size  
11c8			 
11c8			.newblock: 
11c8				; need to be at marker here 
11c8			 
11c8					if DEBUG_FORTH_MALLOC_INT 
11c8						DMARK "meN" 
11c8						CALLMONITOR 
11c8					endif 
11c8			 
11c8			 
11c8				ld a, c 
11c8			 
11c8				ld (free_list+3), a	 ; flag resume from last malloc  
11c8				ld (free_list), hl    ; save out last location 
11c8			 
11c8			 
11c8				;inc a     ; space for length byte 
11c8				ld (hl), a     ; save block in use marker 
11c8			 
11c8				inc hl   ; move to space marker 
11c8				ld (hl), a    ; save new space 
11c8			 
11c8				inc hl   ; move to start of allocated area 
11c8				 
11c8			;	push hl     ; save where we are - 1  
11c8			 
11c8			;	inc hl  ; move past zero index  
11c8				; skip space to set down new marker 
11c8			 
11c8				; provide some extra space for now 
11c8			 
11c8				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
11c8				inc a 
11c8				inc a 
11c8			 
11c8				push hl   ; save where we are in the node block 
11c8			 
11c8				call addatohl 
11c8			 
11c8				; write linked list point 
11c8			 
11c8				pop de     ; get our node position 
11c8				ex de, hl 
11c8			 
11c8				ld (hl), e 
11c8				inc hl 
11c8				ld (hl), d 
11c8			 
11c8				inc hl 
11c8			 
11c8				; now at start of allocated data so save pointer 
11c8			 
11c8				push hl 
11c8			 
11c8				; jump to position of next node and setup empty header in DE 
11c8			 
11c8				ex de, hl 
11c8			 
11c8			;	inc hl ; move past end of block 
11c8			 
11c8				ld a, 0 
11c8				ld (hl), a   ; empty marker 
11c8				inc hl 
11c8				ld (hl), a   ; size 
11c8				inc hl  
11c8				ld (hl), a   ; ptr 
11c8				inc hl 
11c8				ld (hl), a   ; ptr 
11c8			 
11c8			 
11c8				pop hl 
11c8			 
11c8					if DEBUG_FORTH_MALLOC_INT 
11c8						DMARK "mmr" 
11c8						CALLMONITOR 
11c8					endif 
11c8			 
11c8			.exit: 
11c8				pop af 
11c8				pop bc 
11c8				pop de  
11c8				ret 
11c8			 
11c8			 
11c8			 
11c8			 
11c8			free:  
11c8				push hl 
11c8				push af 
11c8				; get address in hl 
11c8			 
11c8					if DEBUG_FORTH_MALLOC_INT 
11c8						DMARK "fre" 
11c8						CALLMONITOR 
11c8					endif 
11c8				; data is at hl - move to block count 
11c8				dec hl 
11c8				dec hl    ; get past pointer 
11c8				dec hl 
11c8			 
11c8				ld a, (hl)    ; need this for a validation check 
11c8			 
11c8				dec hl    ; move to block marker 
11c8			 
11c8				; now check that the block count and block marker are the same  
11c8			        ; this checks that we are on a malloc node and not random memory 
11c8			        ; OK a faint chance this could be a problem but rare - famous last words! 
11c8			 
11c8				ld c, a 
11c8				ld a, (hl)    
11c8			 
11c8				cp c 
11c8				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
11c8			 
11c8				; yes good chance we are on a malloc node 
11c8			 
11c8				ld a, 0      
11c8				ld (hl), a   ; mark as free 
11c8			 
11c8				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
11c8			 
11c8			.freeignore:  
11c8			 
11c8				pop af 
11c8				pop hl 
11c8			 
11c8				ret 
11c8			 
11c8			 
11c8			 
11c8			endif 
11c8			 
11c8			; eof 
# End of file firmware_memory.asm
11c8			  
11c8			; device C  
11c8			if SOUND_ENABLE  
11c8				include "firmware_sound.asm"  
11c8			endif  
11c8			  
11c8			include "firmware_diags.asm"  
11c8			; Hardware diags menu 
11c8			 
11c8			 
11c8			config: 
11c8			 
11c8 3e 00			ld a, 0 
11ca 21 da 11			ld hl, .configmn 
11cd cd 70 09			call menu 
11d0			 
11d0 fe 00			cp 0 
11d2 c8				ret z 
11d3			 
11d3 fe 04			cp 4 
11d5 cc 52 12			call z, hardware_diags 
11d8			 
11d8 18 ee			jr config 
11da			 
11da			.configmn: 
11da e4 11			dw .c3 
11dc ff 11			dw .c2 
11de 14 12			dw .c4 
11e0 1d 12			dw .c1 
11e2 00 00			dw 0 
11e4				 
11e4			 
11e4 .. 00		.c3: db "Save User Words To Storage",0 
11ff .. 00		.c2: db "Select Autoload File",0 
1214 .. 00		.c4: db "Settings",0 
121d .. 00		.c1: db "Hardware Diags",0 
122c			 
122c			 
122c			; Settings 
122c			; Run  
122c			 
122c			 
122c			 
122c			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
122c			;;hd_menu2:   db "        2: Editor",0   
122c			;hd_menu2:   db "        2: Editor       6: Menu",0   
122c			;hd_menu3:   db "        3: Storage",0 
122c			;hd_menu4:   db "0=quit  4: Debug",0 
122c			;hd_don:     db "ON",0 
122c			;hd_doff:     db "OFF",0 
122c			; 
122c			; 
122c			; 
122c			;hardware_diags_old:       
122c			; 
122c			;.diagmenu: 
122c			;	call clear_display 
122c			;	ld a, display_row_1 
122c			;	ld de, hd_menu1 
122c			;	call str_at_display 
122c			; 
122c			;	ld a, display_row_2 
122c			;	ld de, hd_menu2 
122c			;	call str_at_display 
122c			; 
122c			;	ld a, display_row_3 
122c			;	ld de, hd_menu3 
122c			;	call str_at_display 
122c			; 
122c			;	ld a,  display_row_4 
122c			;	ld de, hd_menu4 
122c			;	call str_at_display 
122c			; 
122c			;	; display debug state 
122c			; 
122c			;	ld de, hd_don 
122c			;	ld a, (os_view_disable) 
122c			;	cp 0 
122c			;	jr z, .distog 
122c			;	ld de, hd_doff 
122c			;.distog: ld a, display_row_4+17 
122c			;	call str_at_display 
122c			; 
122c			;	call update_display 
122c			; 
122c			;	call cin_wait 
122c			; 
122c			; 
122c			; 
122c			;	cp '4' 
122c			;	jr nz, .diagn1 
122c			; 
122c			;	; debug toggle 
122c			; 
122c			;	ld a, (os_view_disable) 
122c			;	ld b, '*' 
122c			;	cp 0 
122c			;	jr z, .debtog 
122c			;	ld b, 0 
122c			;.debtog:	 
122c			;	ld a,b 
122c			;	ld (os_view_disable),a 
122c			; 
122c			;.diagn1: cp '0' 
122c			;	 ret z 
122c			; 
122c			;;	cp '1' 
122c			;;       jp z, matrix	 
122c			;;   TODO keyboard matrix test 
122c			; 
122c			;	cp '2' 
122c			;	jp z, .diagedit 
122c			; 
122c			;;	cp '6' 
122c			;;	jp z, .menutest 
122c			;;if ENABLE_BASIC 
122c			;;	cp '6' 
122c			;;	jp z, basic 
122c			;;endif 
122c			 ; 
122c			;	jp .diagmenu 
122c			; 
122c			; 
122c			;	ret 
122c			 
122c			 
122c			.debug_tog: 
122c 21 7a 12			ld hl, .menudebug 
122f				 
122f 3a 74 e3			ld a, (os_view_disable) 
1232 fe 2a			cp '*' 
1234 20 04			jr nz,.tdon  
1236 3e 01			ld a, 1 
1238 18 02			jr .tog1 
123a 3e 00		.tdon: ld a, 0 
123c			 
123c			.tog1: 
123c cd 70 09			call menu 
123f fe 00			cp 0 
1241 c8				ret z 
1242 fe 01			cp 1    ; disable debug 
1244 28 04			jr z, .dtog0 
1246 3e 2a			ld a, '*' 
1248 18 02			jr .dtogset 
124a 3e 00		.dtog0: ld a, 0 
124c 32 74 e3		.dtogset:  ld (os_view_disable), a 
124f c3 2c 12			jp .debug_tog 
1252			 
1252			 
1252			hardware_diags:       
1252			 
1252			.diagm: 
1252 21 6a 12			ld hl, .menuitems 
1255 3e 00			ld a, 0 
1257 cd 70 09			call menu 
125a			 
125a fe 00		         cp 0 
125c c8				 ret z 
125d			 
125d fe 02			cp 2 
125f ca d4 12			jp z, .diagedit 
1262 fe 04			cp 4 
1264 cc 2c 12			call z, .debug_tog 
1267			 
1267			;	cp '6' 
1267			;	jp z, .menutest 
1267			;if ENABLE_BASIC 
1267			;	cp '6' 
1267			;	jp z, basic 
1267			;endif 
1267			  
1267 c3 52 12			jp .diagm 
126a			 
126a				 
126a 80 12		.menuitems:   	dw .m1 
126c 8b 12				dw .m2 
126e 92 12				dw .m3 
1270 9a 12				dw .m4 
1272 a9 12				dw .m5 
1274 af 12				dw .m5a 
1276 b8 12				dw .m5b 
1278 00 00				dw 0 
127a			 
127a			.menudebug: 
127a c1 12				dw .m6 
127c ca 12				dw .m7 
127e 00 00				dw 0 
1280			 
1280 .. 00		.m1:   db "Key Matrix",0 
128b .. 00		.m2:   db "Editor",0 
1292 .. 00		.m3:   db "Storage",0 
129a .. 00		.m4:   db "Software Debug",0 
12a9 .. 00		.m5:   db "Sound",0 
12af .. 00		.m5a:  db "RAM Test",0 
12b8 .. 00		.m5b:  db "LCD Test",0 
12c1			 
12c1 .. 00		.m6:   db "Debug ON",0 
12ca .. 00		.m7:   db "Debug OFF",0 
12d4			 
12d4			; debug editor 
12d4			 
12d4			.diagedit: 
12d4			 
12d4 21 75 e3			ld hl, scratch 
12d7			;	ld bc, 250 
12d7			;	ldir 
12d7				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
12d7 3e 00			ld a, 0 
12d9 77				ld (hl), a 
12da 23				inc hl 
12db 77				ld (hl), a 
12dc 23				inc hl 
12dd 77				ld (hl), a 
12de			 
12de cd 3f 09		        call clear_display 
12e1 cd 62 09			call update_display 
12e4 3e 01			ld a, 1 
12e6 32 80 ee			ld (hardware_diag), a 
12e9			.diloop: 
12e9 3e 00			ld a, display_row_1 
12eb 0e 00			ld c, 0 
12ed 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
12ef 1e 28			ld e, 40 
12f1			 
12f1 21 75 e3			ld hl, scratch	 
12f4 cd 95 0b			call input_str 
12f7			 
12f7 3e 28			ld a, display_row_2 
12f9 11 75 e3			ld de, scratch 
12fc cd 52 09			call str_at_display 
12ff cd 62 09			call update_display 
1302			 
1302 c3 e9 12			jp .diloop 
1305			 
1305			 
1305			; pass word in hl 
1305			; a has display location 
1305			display_word_at: 
1305 f5				push af 
1306 e5				push hl 
1307 7c				ld a,h 
1308 21 7a e6			ld hl, os_word_scratch 
130b cd 69 0e			call hexout 
130e e1				pop hl 
130f 7d				ld a,l 
1310 21 7c e6			ld hl, os_word_scratch+2 
1313 cd 69 0e			call hexout 
1316 21 7e e6			ld hl, os_word_scratch+4 
1319 3e 00			ld a,0 
131b 77				ld (hl),a 
131c 11 7a e6			ld de,os_word_scratch 
131f f1				pop af 
1320 cd 52 09				call str_at_display 
1323 c9				ret 
1324			 
1324			display_ptr_state: 
1324			 
1324				; to restore afterwards 
1324			 
1324 d5				push de 
1325 c5				push bc 
1326 e5				push hl 
1327 f5				push af 
1328			 
1328				; for use in here 
1328			 
1328			;	push bc 
1328			;	push de 
1328			;	push hl 
1328			;	push af 
1328			 
1328 cd 3f 09			call clear_display 
132b			 
132b 11 fe 14			ld de, .ptrstate 
132e 3e 00			ld a, display_row_1 
1330 cd 52 09			call str_at_display 
1333			 
1333				; display debug step 
1333			 
1333			 
1333 11 7a ee			ld de, debug_mark 
1336 3e 26			ld a, display_row_1+display_cols-2 
1338 cd 52 09			call str_at_display 
133b			 
133b				; display a 
133b 11 08 15			ld de, .ptrcliptr 
133e 3e 28			ld a, display_row_2 
1340 cd 52 09			call str_at_display 
1343			 
1343 f1				pop af 
1344 2a 40 eb			ld hl,(cli_ptr) 
1347 3e 30			ld a, display_row_2+8 
1349 cd 05 13			call display_word_at 
134c			 
134c			 
134c				; display hl 
134c			 
134c			 
134c 11 10 15			ld de, .ptrclioptr 
134f 3e 32			ld a, display_row_2+10 
1351 cd 52 09			call str_at_display 
1354			; 
1354			;	pop hl 
1354 3e 35			ld a, display_row_2+13 
1356 2a 3e eb			ld hl,(cli_origptr) 
1359 cd 05 13			call display_word_at 
135c			; 
135c			;	 
135c			;	; display de 
135c			 
135c			;	ld de, .regstatede 
135c			;	ld a, display_row_3 
135c			;	call str_at_display 
135c			 
135c			;	pop de 
135c			;	ld h,d 
135c			;	ld l, e 
135c			;	ld a, display_row_3+3 
135c			;	call display_word_at 
135c			 
135c			 
135c				; display bc 
135c			 
135c			;	ld de, .regstatebc 
135c			;	ld a, display_row_3+10 
135c			;	call str_at_display 
135c			 
135c			;	pop bc 
135c			;	ld h,b 
135c			;	ld l, c 
135c			;	ld a, display_row_3+13 
135c			;	call display_word_at 
135c			 
135c			 
135c				; display dsp 
135c			 
135c			;	ld de, .regstatedsp 
135c			;	ld a, display_row_4 
135c			;	call str_at_display 
135c			 
135c				 
135c			;	ld hl,(cli_data_sp) 
135c			;	ld a, display_row_4+4 
135c			;	call display_word_at 
135c			 
135c				; display rsp 
135c			 
135c 11 3f 15			ld de, .regstatersp 
135f 3e 82			ld a, display_row_4+10 
1361 cd 52 09			call str_at_display 
1364			 
1364				 
1364 2a 26 eb			ld hl,(cli_ret_sp) 
1367 3e 86			ld a, display_row_4+14 
1369 cd 05 13			call display_word_at 
136c			 
136c cd 62 09			call update_display 
136f			 
136f cd e2 08			call delay1s 
1372 cd e2 08			call delay1s 
1375 cd e2 08			call delay1s 
1378			 
1378			 
1378 cd 92 18			call next_page_prompt 
137b			 
137b				; restore  
137b			 
137b f1				pop af 
137c e1				pop hl 
137d c1				pop bc 
137e d1				pop de 
137f c9				ret 
1380			 
1380			break_point_state: 
1380 f5				push af 
1381			 
1381				; see if disabled 
1381			 
1381 3a 74 e3			ld a, (os_view_disable) 
1384 fe 2a			cp '*' 
1386 20 02			jr nz, .bpsgo 
1388 f1				pop af 
1389 c9				ret 
138a			 
138a			.bpsgo: 
138a f1				pop af 
138b f5				push af 
138c 22 70 e3			ld (os_view_hl), hl 
138f ed 53 6e e3		ld (os_view_de), de 
1393 ed 43 6c e3		ld (os_view_bc), bc 
1397 e5				push hl 
1398 6f				ld l, a 
1399 26 00			ld h, 0 
139b 22 72 e3			ld (os_view_af),hl 
139e			 
139e 21 c0 ed				ld hl, display_fb0 
13a1 22 db eb				ld (display_fb_active), hl 
13a4 e1				pop hl	 
13a5			 
13a5 3e 31			ld a, '1' 
13a7 fe 2a		.bps1:  cp '*' 
13a9 20 03			jr nz, .bps1b 
13ab 32 74 e3			ld (os_view_disable),a 
13ae fe 31		.bps1b:  cp '1' 
13b0 20 14			jr nz, .bps2 
13b2			 
13b2				; display reg 
13b2			 
13b2				 
13b2			 
13b2 3a 72 e3			ld a, (os_view_af) 
13b5 2a 70 e3			ld hl, (os_view_hl) 
13b8 ed 5b 6e e3		ld de, (os_view_de) 
13bc ed 4b 6c e3		ld bc, (os_view_bc) 
13c0 cd 5a 14			call display_reg_state 
13c3 c3 46 14			jp .bpschk 
13c6			 
13c6 fe 32		.bps2:  cp '2' 
13c8 20 08			jr nz, .bps3 
13ca				 
13ca				; display hl 
13ca 2a 70 e3			ld hl, (os_view_hl) 
13cd cd 44 15			call display_dump_at_hl 
13d0			 
13d0 18 74			jr .bpschk 
13d2			 
13d2 fe 33		.bps3:  cp '3' 
13d4 20 08			jr nz, .bps4 
13d6			 
13d6			        ; display de 
13d6 2a 6e e3			ld hl, (os_view_de) 
13d9 cd 44 15			call display_dump_at_hl 
13dc			 
13dc 18 68			jr .bpschk 
13de fe 34		.bps4:  cp '4' 
13e0 20 08			jr nz, .bps5 
13e2			 
13e2			        ; display bc 
13e2 2a 6c e3			ld hl, (os_view_bc) 
13e5 cd 44 15			call display_dump_at_hl 
13e8			 
13e8 18 5c			jr .bpschk 
13ea fe 35		.bps5:  cp '5' 
13ec 20 08		        jr nz, .bps7 
13ee			 
13ee				; display cur ptr 
13ee 2a 40 eb			ld hl, (cli_ptr) 
13f1 cd 44 15			call display_dump_at_hl 
13f4			 
13f4 18 50			jr .bpschk 
13f6 fe 36		.bps7:  cp '6' 
13f8 20 08			jr nz, .bps8b 
13fa				 
13fa				; display cur orig ptr 
13fa 2a 3e eb			ld hl, (cli_origptr) 
13fd cd 44 15			call display_dump_at_hl 
1400 18 44			jr .bpschk 
1402 fe 37		.bps8b:  cp '7' 
1404 20 08			jr nz, .bps9 
1406				 
1406				; display dsp 
1406 2a 22 eb			ld hl, (cli_data_sp) 
1409 cd 44 15			call display_dump_at_hl 
140c			 
140c 18 38			jr .bpschk 
140e fe 39		.bps9:  cp '9' 
1410 20 05			jr nz, .bps8c 
1412				 
1412				; display SP 
1412			;	ld hl, sp 
1412 cd 44 15			call display_dump_at_hl 
1415			 
1415 18 2f			jr .bpschk 
1417 fe 38		.bps8c:  cp '8' 
1419 20 08			jr nz, .bps8d 
141b				 
141b				; display rsp 
141b 2a 26 eb			ld hl, (cli_ret_sp) 
141e cd 44 15			call display_dump_at_hl 
1421			 
1421 18 23			jr .bpschk 
1423 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1425 20 05			jr nz, .bps8 
1427 cd 88 16			call monitor 
142a			 
142a 18 1a			jr .bpschk 
142c fe 30		.bps8:  cp '0' 
142e 20 16			jr nz, .bpschk 
1430			 
1430 21 1f ed				ld hl, display_fb1 
1433 22 db eb				ld (display_fb_active), hl 
1436 cd 62 09				call update_display 
1439			 
1439				;ld a, (os_view_af) 
1439 2a 70 e3			ld hl, (os_view_hl) 
143c ed 5b 6e e3		ld de, (os_view_de) 
1440 ed 4b 6c e3		ld bc, (os_view_bc) 
1444 f1				pop af 
1445 c9				ret 
1446			 
1446			.bpschk:   
1446 cd e2 08			call delay1s 
1449 3e 9f		ld a,display_row_4 + display_cols - 1 
144b 11 90 18		        ld de, endprg 
144e cd 52 09			call str_at_display 
1451 cd 62 09			call update_display 
1454 cd cc 57			call cin_wait 
1457			 
1457 c3 a7 13			jp .bps1 
145a			 
145a			 
145a			display_reg_state: 
145a			 
145a				; to restore afterwards 
145a			 
145a d5				push de 
145b c5				push bc 
145c e5				push hl 
145d f5				push af 
145e			 
145e				; for use in here 
145e			 
145e c5				push bc 
145f d5				push de 
1460 e5				push hl 
1461 f5				push af 
1462			 
1462 cd 3f 09			call clear_display 
1465			 
1465 11 1a 15			ld de, .regstate 
1468 3e 00			ld a, display_row_1 
146a cd 52 09			call str_at_display 
146d			 
146d				; display debug step 
146d			 
146d			 
146d 11 7a ee			ld de, debug_mark 
1470 3e 25			ld a, display_row_1+display_cols-3 
1472 cd 52 09			call str_at_display 
1475			 
1475				; display a 
1475 11 36 15			ld de, .regstatea 
1478 3e 28			ld a, display_row_2 
147a cd 52 09			call str_at_display 
147d			 
147d e1				pop hl 
147e			;	ld h,0 
147e			;	ld l, a 
147e 3e 2b			ld a, display_row_2+3 
1480 cd 05 13			call display_word_at 
1483			 
1483			 
1483				; display hl 
1483			 
1483			 
1483 11 2a 15			ld de, .regstatehl 
1486 3e 32			ld a, display_row_2+10 
1488 cd 52 09			call str_at_display 
148b			 
148b e1				pop hl 
148c 3e 35			ld a, display_row_2+13 
148e cd 05 13			call display_word_at 
1491			 
1491				 
1491				; display de 
1491			 
1491 11 2e 15			ld de, .regstatede 
1494 3e 50			ld a, display_row_3 
1496 cd 52 09			call str_at_display 
1499			 
1499 e1				pop hl 
149a			;	ld h,d 
149a			;	ld l, e 
149a 3e 53			ld a, display_row_3+3 
149c cd 05 13			call display_word_at 
149f			 
149f			 
149f				; display bc 
149f			 
149f 11 32 15			ld de, .regstatebc 
14a2 3e 5a			ld a, display_row_3+10 
14a4 cd 52 09			call str_at_display 
14a7			 
14a7 e1				pop hl 
14a8			;	ld h,b 
14a8			;	ld l, c 
14a8 3e 5d			ld a, display_row_3+13 
14aa cd 05 13			call display_word_at 
14ad			 
14ad			 
14ad				; display dsp 
14ad			 
14ad 11 3a 15			ld de, .regstatedsp 
14b0 3e 78			ld a, display_row_4 
14b2 cd 52 09			call str_at_display 
14b5			 
14b5				 
14b5 2a 22 eb			ld hl,(cli_data_sp) 
14b8 3e 7c			ld a, display_row_4+4 
14ba cd 05 13			call display_word_at 
14bd			 
14bd				; display rsp 
14bd			 
14bd 11 3f 15			ld de, .regstatersp 
14c0 3e 82			ld a, display_row_4+10 
14c2 cd 52 09			call str_at_display 
14c5			 
14c5				 
14c5 2a 26 eb			ld hl,(cli_ret_sp) 
14c8 3e 86			ld a, display_row_4+14 
14ca cd 05 13			call display_word_at 
14cd			 
14cd cd 62 09			call update_display 
14d0			 
14d0			;	call delay1s 
14d0			;	call delay1s 
14d0			;	call delay1s 
14d0			 
14d0			 
14d0			;	call next_page_prompt 
14d0			 
14d0				; restore  
14d0			 
14d0 f1				pop af 
14d1 e1				pop hl 
14d2 c1				pop bc 
14d3 d1				pop de 
14d4 c9				ret 
14d5			 
14d5 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
14e9 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
14fe .. 00		.ptrstate:	db "Ptr State",0 
1508 .. 00		.ptrcliptr:     db "cli_ptr",0 
1510 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
151a .. 00		.regstate:	db "Reg State (1/0)",0 
152a .. 00		.regstatehl:	db "HL:",0 
152e .. 00		.regstatede:	db "DE:",0 
1532 .. 00		.regstatebc:	db "BC:",0 
1536 .. 00		.regstatea:	db "A :",0 
153a .. 00		.regstatedsp:	db "DSP:",0 
153f .. 00		.regstatersp:	db "RSP:",0 
1544			 
1544			display_dump_at_hl: 
1544 e5				push hl 
1545 d5				push de 
1546 c5				push bc 
1547 f5				push af 
1548			 
1548 22 98 e6			ld (os_cur_ptr),hl	 
154b cd 3f 09			call clear_display 
154e cd 9a 17			call dumpcont 
1551			;	call delay1s 
1551			;	call next_page_prompt 
1551			 
1551			 
1551 f1				pop af 
1552 c1				pop bc 
1553 d1				pop de 
1554 e1				pop hl 
1555 c9				ret 
1556			 
1556			;if ENABLE_BASIC 
1556			;	include "nascombasic.asm" 
1556			;	basic: 
1556			;	include "forth/FORTH.ASM" 
1556			;endif 
1556			 
1556			; eof 
1556			 
1556			 
# End of file firmware_diags.asm
1556			  
1556			  
1556			  
1556			  
1556			; eof  
1556			  
# End of file firmware.asm
1556			 
1556			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1556			;if BASE_KEV  
1556			;baseram: equ 08000h 
1556			;endif 
1556			 
1556			;if BASE_SC114 
1556			;baseram:     equ    endofcode 
1556			;endif 
1556			 
1556			 
1556			; start system 
1556			 
1556			coldstart: 
1556				; set sp 
1556				; di/ei 
1556			 
1556 f3				di 
1557 31 00 f0			ld sp, tos 
155a			;	ei 
155a			 
155a			 
155a				; disable breakpoint by default 
155a			 
155a 3e 2a			ld a,'*' 
155c 32 74 e3			ld (os_view_disable),a 
155f			 
155f				; init hardware 
155f			 
155f				; init keyboard and screen hardware 
155f			 
155f cd 03 01			call hardware_init 
1562			 
1562			 
1562				; detect if any keys are held down to enable breakpoints at start up 
1562			 
1562 cd d4 57			call cin  
1565 fe 00			cp 0 
1567 28 03			jr z, .nokeys 
1569			 
1569				;call hardware_diags 
1569 cd c8 11			call config 
156c			 
156c			;	ld de, .bpen 
156c			;	ld a, display_row_4 
156c			;	call str_at_display 
156c			;	call update_display 
156c			; 
156c			;	ld a,0 
156c			;	ld (os_view_disable),a 
156c			; 
156c			;.bpwait: 
156c			;	call cin 
156c			;	cp 0 
156c			;	jr z, .bpwait 
156c			;	jr .nokeys 
156c			; 
156c			; 
156c			;.bpen:  db "Break points enabled!",0 
156c			 
156c			 
156c			 
156c			 
156c			 
156c			 
156c			.nokeys: 
156c			 
156c			 
156c				 
156c			 
156c			;jp  testkey 
156c			 
156c			;call storage_get_block_0 
156c			; 
156c			;ld hl, 0 
156c			;ld de, store_page 
156c			;call storage_read_block 
156c			 
156c				 
156c			;ld hl, 10 
156c			;ld de, store_page 
156c			;call storage_read_block 
156c			 
156c			 
156c			 
156c			 
156c			 
156c			;stop:	nop 
156c			;	jp stop 
156c			 
156c			 
156c			 
156c			main: 
156c cd 3f 09			call clear_display 
156f cd 62 09			call update_display 
1572			 
1572			 
1572			 
1572			;	call testlcd 
1572			 
1572			 
1572			 
1572 cd e0 1a			call forth_init 
1575			 
1575			 
1575			warmstart: 
1575 cd b6 1a			call forth_warmstart 
1578			 
1578				; run startup word load 
1578			        ; TODO prevent this running at warmstart after crash  
1578			 
1578				if STARTUP_ENABLE 
1578 cd 1a 54				call forth_startup 
157b				endif 
157b			 
157b				; show free memory after boot 
157b 11 22 16			ld de, freeram 
157e 3e 00			ld a, display_row_1 
1580 cd 52 09			call str_at_display 
1583			 
1583			; Or use heap_size word???? 
1583 21 69 e3			ld hl, heap_end 
1586 11 fc 57			ld de, heap_start 
1589 ed 52			sbc hl, de 
158b e5				push hl 
158c 7c				ld a,h	         	 
158d 21 7a e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1590 cd 69 0e			call hexout 
1593 e1			   	pop hl 
1594			 
1594 7d				ld a,l 
1595 21 7c e6			ld hl, os_word_scratch+2 
1598 cd 69 0e			call hexout 
159b 21 7e e6			ld hl, os_word_scratch+4 
159e 3e 00			ld a, 0 
15a0 77				ld (hl),a 
15a1 11 7a e6			ld de, os_word_scratch 
15a4 3e 0d			ld a, display_row_1 + 13 
15a6 cd 52 09			call str_at_display 
15a9 cd 62 09			call update_display 
15ac			 
15ac			 
15ac				;call demo 
15ac			 
15ac			 
15ac				; init scratch input area for cli commands 
15ac			 
15ac 21 9c e6			ld hl, os_cli_cmd 
15af 3e 00			ld a,0 
15b1 77				ld (hl),a 
15b2 23				inc hl 
15b3 77				ld (hl),a 
15b4			 
15b4 3e 00			ld a,0 
15b6 32 9b e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
15b9			 
15b9 32 98 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
15bc 32 99 e6			ld (os_cur_ptr+1),a	 
15bf			 
15bf 32 7a e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
15c2 32 7b e6			ld (os_word_scratch+1),a	 
15c5				 
15c5			 
15c5				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
15c5 21 9c e6			ld hl, os_cli_cmd 
15c8			 
15c8 3e 00			ld a, 0		 ; init cli input 
15ca 77				ld (hl), a 
15cb 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
15cd			cli: 
15cd				; show cli prompt 
15cd				;push af 
15cd				;ld a, 0 
15cd				;ld de, prompt 
15cd				;call str_at_display 
15cd			 
15cd				;call update_display 
15cd				;pop af 
15cd				;inc a 
15cd				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
15cd 0e 00			ld c, 0 
15cf 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
15d1 1e 28			ld e, 40 
15d3			 
15d3 21 9c e6			ld hl, os_cli_cmd 
15d6			 
15d6				STACKFRAME OFF $fefe $9f9f 
15d6				if DEBUG_STACK_IMB 
15d6					if OFF 
15d6						exx 
15d6						ld de, $fefe 
15d6						ld a, d 
15d6						ld hl, curframe 
15d6						call hexout 
15d6						ld a, e 
15d6						ld hl, curframe+2 
15d6						call hexout 
15d6						ld hl, $fefe 
15d6						push hl 
15d6						ld hl, $9f9f 
15d6						push hl 
15d6						exx 
15d6					endif 
15d6				endif 
15d6			endm 
# End of macro STACKFRAME
15d6			 
15d6 cd 95 0b			call input_str 
15d9			 
15d9				STACKFRAMECHK OFF $fefe $9f9f 
15d9				if DEBUG_STACK_IMB 
15d9					if OFF 
15d9						exx 
15d9						ld hl, $9f9f 
15d9						pop de   ; $9f9f 
15d9						call cmp16 
15d9						jr nz, .spnosame 
15d9						ld hl, $fefe 
15d9						pop de   ; $fefe 
15d9						call cmp16 
15d9						jr z, .spfrsame 
15d9						.spnosame: call showsperror 
15d9						.spfrsame: nop 
15d9						exx 
15d9					endif 
15d9				endif 
15d9			endm 
# End of macro STACKFRAMECHK
15d9			 
15d9				; copy input to last command 
15d9			 
15d9 21 9c e6			ld hl, os_cli_cmd 
15dc 11 9b e7			ld de, os_last_cmd 
15df 01 ff 00			ld bc, 255 
15e2 ed b0			ldir 
15e4			 
15e4				; wipe current buffer 
15e4			 
15e4 3e 00			ld a, 0 
15e6 21 9c e6			ld hl, os_cli_cmd 
15e9 11 9d e6			ld de, os_cli_cmd+1 
15ec 01 fe 00			ld bc, 254 
15ef ed b0			ldir 
15f1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
15f1			;	call strcpy 
15f1			;	ld a, 0 
15f1			;	ld (hl), a 
15f1			;	inc hl 
15f1			;	ld (hl), a 
15f1			;	inc hl 
15f1			;	ld (hl), a 
15f1			 
15f1				; switch frame buffer to program  
15f1			 
15f1 21 1f ed				ld hl, display_fb1 
15f4 22 db eb				ld (display_fb_active), hl 
15f7			 
15f7			;	nop 
15f7				STACKFRAME ON $fbfe $8f9f 
15f7				if DEBUG_STACK_IMB 
15f7					if ON 
15f7						exx 
15f7						ld de, $fbfe 
15f7						ld a, d 
15f7						ld hl, curframe 
15f7						call hexout 
15f7						ld a, e 
15f7						ld hl, curframe+2 
15f7						call hexout 
15f7						ld hl, $fbfe 
15f7						push hl 
15f7						ld hl, $8f9f 
15f7						push hl 
15f7						exx 
15f7					endif 
15f7				endif 
15f7			endm 
# End of macro STACKFRAME
15f7				; first time into the parser so pass over the current scratch pad 
15f7 21 9c e6			ld hl,os_cli_cmd 
15fa				; tokenise the entered statement(s) in HL 
15fa cd 59 1b			call forthparse 
15fd			        ; exec forth statements in top of return stack 
15fd cd 99 1b			call forthexec 
1600				;call forthexec_cleanup 
1600			;	call parsenext 
1600			 
1600				STACKFRAMECHK ON $fbfe $8f9f 
1600				if DEBUG_STACK_IMB 
1600					if ON 
1600						exx 
1600						ld hl, $8f9f 
1600						pop de   ; $8f9f 
1600						call cmp16 
1600						jr nz, .spnosame 
1600						ld hl, $fbfe 
1600						pop de   ; $fbfe 
1600						call cmp16 
1600						jr z, .spfrsame 
1600						.spnosame: call showsperror 
1600						.spfrsame: nop 
1600						exx 
1600					endif 
1600				endif 
1600			endm 
# End of macro STACKFRAMECHK
1600				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1600			 
1600 3e 78			ld a, display_row_4 
1602 11 34 16			ld de, endprog 
1605			 
1605 cd 62 09			call update_display		 
1608			 
1608 cd 92 18			call next_page_prompt 
160b			 
160b				; switch frame buffer to cli 
160b			 
160b 21 c0 ed				ld hl, display_fb0 
160e 22 db eb				ld (display_fb_active), hl 
1611			 
1611			 
1611 cd 3f 09		        call clear_display 
1614 cd 62 09			call update_display		 
1617			 
1617 21 9c e6			ld hl, os_cli_cmd 
161a			 
161a 3e 00			ld a, 0		 ; init cli input 
161c 77				ld (hl), a 
161d			 
161d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
161d			 
161d				; now on last line 
161d			 
161d				; TODO scroll screen up 
161d			 
161d				; TODO instead just clear screen and place at top of screen 
161d			 
161d			;	ld a, 0 
161d			;	ld (f_cursor_ptr),a 
161d			 
161d				;call clear_display 
161d				;call update_display 
161d			 
161d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
161d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
161f c3 cd 15			jp cli 
1622			 
1622 .. 00		freeram: db "Free bytes: $",0 
1630 ..			asc: db "1A2F" 
1634 .. 00		endprog: db "End prog...",0 
1640			 
1640			testenter2:   
1640 21 a7 e3			ld hl,scratch+50 
1643 22 98 e6			ld (os_cur_ptr),hl 
1646 c3 cd 15			jp cli 
1649			 
1649			testenter:  
1649			 
1649 21 30 16			ld hl,asc 
164c			;	ld a,(hl) 
164c			;	call nibble2val 
164c cd bf 0e			call get_byte 
164f			 
164f			 
164f			;	ld a,(hl) 
164f			;	call atohex 
164f			 
164f			;	call fourehexhl 
164f 32 a7 e3			ld (scratch+50),a 
1652			 
1652			 
1652			 
1652 21 32 16			ld hl,asc+2 
1655			;	ld a, (hl) 
1655			;	call nibble2val 
1655 cd bf 0e			call get_byte 
1658			 
1658			;	call fourehexhl 
1658 32 a9 e3			ld (scratch+52),a 
165b				 
165b 21 a7 e3			ld hl,scratch+50 
165e 22 98 e6			ld (os_cur_ptr),hl 
1661 c3 cd 15			jp cli 
1664			 
1664			enter:	 
1664 3a 79 e3			ld a,(scratch+4) 
1667 fe 00			cp 0 
1669 28 0c			jr z, .entercont 
166b				; no, not a null term line so has an address to work out.... 
166b			 
166b 21 77 e3			ld hl,scratch+2 
166e cd 1f 0f			call get_word_hl 
1671			 
1671 22 98 e6			ld (os_cur_ptr),hl	 
1674 c3 cd 15			jp cli 
1677			 
1677			 
1677			.entercont:  
1677			 
1677 21 77 e3			ld hl, scratch+2 
167a cd bf 0e			call get_byte 
167d			 
167d 2a 98 e6		   	ld hl,(os_cur_ptr) 
1680 77					ld (hl),a 
1681 23					inc hl 
1682 22 98 e6				ld (os_cur_ptr),hl 
1685				 
1685			; get byte  
1685			 
1685			 
1685 c3 cd 15			jp cli 
1688			 
1688			 
1688			; basic monitor support 
1688			 
1688			monitor: 
1688				;  
1688 cd 3f 09			call clear_display 
168b 3e 00			ld a, 0 
168d 11 d5 16			ld de, .monprompt 
1690 cd 52 09			call str_at_display 
1693 cd 62 09			call update_display 
1696			 
1696				; get a monitor command 
1696			 
1696 0e 00			ld c, 0     ; entry at top left 
1698 16 64			ld d, 100   ; max buffer size 
169a 1e 0f			ld e, 15    ; input scroll area 
169c 3e 00			ld a, 0     ; init string 
169e 21 73 e5			ld hl, os_input 
16a1 77				ld (hl), a 
16a2 23				inc hl 
16a3 77				ld (hl), a 
16a4 21 73 e5			ld hl, os_input 
16a7 3e 01			ld a, 1     ; init string 
16a9 cd 95 0b			call input_str 
16ac			 
16ac cd 3f 09		        call clear_display 
16af cd 62 09			call update_display		 
16b2			 
16b2 3a 73 e5			ld a, (os_input) 
16b5 cd bd 0f			call toUpper 
16b8 fe 48		        cp 'H' 
16ba 28 6f		        jr z, .monhelp 
16bc fe 44			cp 'D'		; dump 
16be ca 4c 17			jp z, .mondump	 
16c1 fe 43			cp 'C'		; dump 
16c3 ca 66 17			jp z, .moncdump	 
16c6 fe 4d			cp 'M'		; dump 
16c8 ca d7 16			jp z, .moneditstart 
16cb fe 55			cp 'U'		; dump 
16cd 28 14			jr z, .monedit	 
16cf fe 51			cp 'Q'		; dump 
16d1 c8				ret z	 
16d2			 
16d2			 
16d2				; TODO "S" to access symbol by name and not need the address 
16d2				; TODO "F" to find a string in memory 
16d2			 
16d2 c3 88 16			jp monitor 
16d5			 
16d5 .. 00		.monprompt: db ">", 0 
16d7			 
16d7			.moneditstart: 
16d7				; get starting address 
16d7			 
16d7 21 75 e5			ld hl,os_input+2 
16da cd 1f 0f			call get_word_hl 
16dd			 
16dd 22 98 e6			ld (os_cur_ptr),hl	 
16e0			 
16e0 c3 88 16			jp monitor 
16e3			 
16e3			.monedit: 
16e3				; get byte to load 
16e3			 
16e3 21 75 e5			ld hl,os_input+2 
16e6 cd bf 0e			call get_byte 
16e9			 
16e9				; get address to update 
16e9 2a 98 e6			ld hl, (os_cur_ptr) 
16ec			 
16ec				; update byte 
16ec			 
16ec 77				ld (hl), a 
16ed			 
16ed				; move to next address and save it 
16ed			 
16ed 23				inc hl 
16ee 22 98 e6			ld (os_cur_ptr),hl	 
16f1			 
16f1 c3 88 16			jp monitor 
16f4			 
16f4			 
16f4 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1708 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1724 .. 00		.monhelptext3:  db "Q-Quit",0 
172b			        
172b			.monhelp: 
172b 3e 00			ld a, display_row_1 
172d 11 f4 16		        ld de, .monhelptext1 
1730			 
1730 cd 52 09			call str_at_display 
1733 3e 28			ld a, display_row_2 
1735 11 08 17		        ld de, .monhelptext2 
1738					 
1738 cd 52 09			call str_at_display 
173b 3e 50			ld a, display_row_3 
173d 11 24 17		        ld de, .monhelptext3 
1740					 
1740 cd 52 09			call str_at_display 
1743 cd 62 09			call update_display		 
1746			 
1746 cd 92 18			call next_page_prompt 
1749 c3 88 16			jp monitor 
174c			 
174c			.mondump:    
174c 21 75 e5			ld hl,os_input+2 
174f cd 1f 0f			call get_word_hl 
1752			 
1752 22 98 e6			ld (os_cur_ptr),hl	 
1755 cd 9a 17			call dumpcont 
1758 3e 78			ld a, display_row_4 
175a 11 34 16			ld de, endprog 
175d			 
175d cd 62 09			call update_display		 
1760			 
1760 cd 92 18			call next_page_prompt 
1763 c3 88 16			jp monitor 
1766			.moncdump: 
1766 cd 9a 17			call dumpcont 
1769 3e 78			ld a, display_row_4 
176b 11 34 16			ld de, endprog 
176e			 
176e cd 62 09			call update_display		 
1771			 
1771 cd 92 18			call next_page_prompt 
1774 c3 88 16			jp monitor 
1777			 
1777			 
1777			; TODO symbol access  
1777			 
1777			.symbols:     ;; A list of symbols that can be called up  
1777 c0 ed			dw display_fb0 
1779 .. 00			db "fb0",0  
177d 65 eb		     	dw store_page 
177f .. 00			db "store_page",0 
178a			 
178a			 
178a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
178a			 
178a 3a 76 e3			ld a,(scratch+1) 
178d fe 00			cp 0 
178f 28 09			jr z, dumpcont 
1791			 
1791				; no, not a null term line so has an address to work out.... 
1791			 
1791 21 77 e3			ld hl,scratch+2 
1794 cd 1f 0f			call get_word_hl 
1797			 
1797 22 98 e6			ld (os_cur_ptr),hl	 
179a			 
179a			 
179a			 
179a			dumpcont: 
179a			 
179a				; dump bytes at ptr 
179a			 
179a			 
179a 3e 00			ld a, display_row_1 
179c 2a db eb			ld hl, (display_fb_active) 
179f cd 68 0b			call addatohl 
17a2 cd ca 17			call .dumpbyterow 
17a5			 
17a5 3e 28			ld a, display_row_2 
17a7 2a db eb			ld hl, (display_fb_active) 
17aa cd 68 0b			call addatohl 
17ad cd ca 17			call .dumpbyterow 
17b0			 
17b0			 
17b0 3e 50			ld a, display_row_3 
17b2 2a db eb			ld hl, (display_fb_active) 
17b5 cd 68 0b			call addatohl 
17b8 cd ca 17			call .dumpbyterow 
17bb			 
17bb 3e 78			ld a, display_row_4 
17bd 2a db eb			ld hl, (display_fb_active) 
17c0 cd 68 0b			call addatohl 
17c3 cd ca 17			call .dumpbyterow 
17c6			 
17c6 cd 62 09			call update_display 
17c9			;		jp cli 
17c9 c9				ret 
17ca			 
17ca			.dumpbyterow: 
17ca			 
17ca				;push af 
17ca			 
17ca e5				push hl 
17cb			 
17cb				; calc where to poke the ascii 
17cb			if display_cols == 20 
17cb				ld a, 16 
17cb			else 
17cb 3e 1f			ld a, 31 
17cd			endif 
17cd			 
17cd cd 68 0b			call addatohl 
17d0 22 7a e6			ld (os_word_scratch),hl  		; save pos for later 
17d3			 
17d3			 
17d3			; display decoding address 
17d3 2a 98 e6		   	ld hl,(os_cur_ptr) 
17d6			 
17d6 7c				ld a,h 
17d7 e1				pop hl 
17d8 e5				push hl 
17d9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17d9 cd 69 0e			call hexout 
17dc 2a 98 e6		   	ld hl,(os_cur_ptr) 
17df			 
17df 7d				ld a,l 
17e0 e1				pop hl 
17e1 23				inc hl 
17e2 23				inc hl 
17e3 e5				push hl 
17e4			;	ld hl, os_word_scratch+2 
17e4 cd 69 0e			call hexout 
17e7 e1				pop hl 
17e8 23				inc hl 
17e9 23				inc hl 
17ea				;ld hl, os_word_scratch+4 
17ea 3e 3a			ld a, ':' 
17ec 77				ld (hl),a 
17ed 23				inc hl 
17ee				;ld a, 0 
17ee				;ld (hl),a 
17ee				;ld de, os_word_scratch 
17ee				;pop af 
17ee				;push af 
17ee			;		ld a, display_row_2 
17ee			;		call str_at_display 
17ee			;		call update_display 
17ee			 
17ee			 
17ee			;pop af 
17ee			;	add 5 
17ee			 
17ee			if display_cols == 20 
17ee				ld b, 4 
17ee			else 
17ee 06 08			ld b, 8 
17f0			endif	 
17f0			 
17f0			.dumpbyte: 
17f0 c5				push bc 
17f1 e5				push hl 
17f2			 
17f2			 
17f2 2a 98 e6		   	ld hl,(os_cur_ptr) 
17f5 7e					ld a,(hl) 
17f6			 
17f6					; poke the ascii to display 
17f6 2a 7a e6				ld hl,(os_word_scratch) 
17f9 77					ld (hl),a 
17fa 23					inc hl 
17fb 22 7a e6				ld (os_word_scratch),hl 
17fe			 
17fe					 
17fe			 
17fe			 
17fe e1					pop hl 
17ff e5					push hl 
1800			 
1800 cd 69 0e				call hexout 
1803			 
1803					 
1803 2a 98 e6		   	ld hl,(os_cur_ptr) 
1806 23				inc hl 
1807 22 98 e6		   	ld (os_cur_ptr),hl 
180a			 
180a e1					pop hl 
180b 23					inc hl 
180c 23					inc hl 
180d 23					inc hl 
180e			 
180e			 
180e			 
180e					;ld a,0 
180e					;ld (os_word_scratch+2),a 
180e					;pop af 
180e					;push af 
180e			 
180e					;ld de, os_word_scratch 
180e					;call str_at_display 
180e			;		call update_display 
180e			;		pop af 
180e c1					pop bc 
180f c6 03				add 3 
1811 10 dd			djnz .dumpbyte 
1813			 
1813				 
1813			 
1813 c9				ret 
1814			 
1814			jump:	 
1814			 
1814 21 77 e3			ld hl,scratch+2 
1817 cd 1f 0f			call get_word_hl 
181a				;ld hl,(scratch+2) 
181a				;call fourehexhl 
181a			 
181a 22 98 e6			ld (os_cur_ptr),hl	 
181d			 
181d e9				jp (hl) 
181e			 
181e			 
181e			 
181e			; TODO implement a basic monitor mode to start with 
181e			 
181e			 
181e			 
181e			 
181e			 
181e			 
181e			 
181e			 
181e			 
181e			; testing and demo code during development 
181e			 
181e			 
181e .. 00		str1: db "Enter some text...",0 
1831 .. 00		clear: db "                    ",0 
1846			 
1846			demo: 
1846			 
1846			 
1846			 
1846			;	call update_display 
1846			 
1846				; init scratch input area for testing 
1846 21 75 e3			ld hl, scratch	 
1849 3e 00			ld a,0 
184b 77				ld (hl),a 
184c			 
184c			 
184c 3e 28		            LD   A, display_row_2 
184e			;            CALL fLCD_Pos       ;Position cursor to location in A 
184e 11 1e 18		            LD   DE, str1 
1851 cd 52 09			call str_at_display 
1854			 
1854			;            CALL fLCD_Str       ;Display string pointed to by DE 
1854			cloop:	 
1854 3e 50		            LD   A, display_row_3 
1856			;            CALL fLCD_Pos       ;Position cursor to location in A 
1856 11 31 18		            LD   DE, clear 
1859			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1859 cd 52 09				call str_at_display 
185c 3e 78			ld a, display_row_4 
185e 11 8e 18			ld de, prompt 
1861			 
1861 cd 52 09				call str_at_display 
1864 cd 62 09			call update_display 
1867			 
1867 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1869 16 0a			ld d, 10 
186b 21 75 e3			ld hl, scratch	 
186e cd 95 0b			call input_str 
1871			 
1871			;	call clear_display 
1871			;'	call update_display 
1871			 
1871 3e 00		            LD   A, display_row_1 
1873			;            CALL fLCD_Pos       ;Position cursor to location in A 
1873 11 31 18		            LD   DE, clear 
1876 cd 52 09				call str_at_display 
1879			;            CALL fLCD_Str       ;Display string pointed to by DE 
1879 3e 00		            LD   A, display_row_1 
187b			;            CALL fLCD_Pos       ;Position cursor to location in A 
187b 11 75 e3		            LD   DE, scratch 
187e			;            CALL fLCD_Str       ;Display string pointed to by DE 
187e cd 52 09				call str_at_display 
1881 cd 62 09			call update_display 
1884			 
1884 3e 00				ld a,0 
1886 21 75 e3			ld hl, scratch 
1889 77				ld (hl),a 
188a			 
188a 00				nop 
188b c3 54 18			jp cloop 
188e			 
188e			 
188e			 
188e			; OS Prompt 
188e			 
188e .. 00		prompt: db ">",0 
1890 .. 00		endprg: db "?",0 
1892			 
1892			 
1892			; handy next page prompt 
1892			next_page_prompt: 
1892 e5				push hl 
1893 d5				push de 
1894 f5				push af 
1895 c5				push bc 
1896			 
1896 3e 9f			ld a,display_row_4 + display_cols - 1 
1898 11 90 18		        ld de, endprg 
189b cd 52 09			call str_at_display 
189e cd 62 09			call update_display 
18a1 cd cc 57			call cin_wait 
18a4 c1				pop bc 
18a5 f1				pop af 
18a6 d1				pop de 
18a7 e1				pop hl 
18a8			 
18a8			 
18a8 c9				ret 
18a9			 
18a9			 
18a9			; forth parser 
18a9			 
18a9			; My forth kernel 
18a9			include "forth_kernel.asm" 
18a9			; 
18a9			; kernel to the forth OS 
18a9			 
18a9			DS_TYPE_STR: equ 1     ; string type 
18a9			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
18a9			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
18a9			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
18a9			 
18a9			FORTH_PARSEV1: equ 0 
18a9			FORTH_PARSEV2: equ 0 
18a9			FORTH_PARSEV3: equ 0 
18a9			FORTH_PARSEV4: equ 0 
18a9			FORTH_PARSEV5: equ 1 
18a9			 
18a9			;if FORTH_PARSEV5 
18a9			;	FORTH_END_BUFFER: equ 0 
18a9			;else 
18a9			FORTH_END_BUFFER: equ 127 
18a9			;endif 
18a9			 
18a9			FORTH_TRUE: equ 1 
18a9			FORTH_FALSE: equ 0 
18a9			 
18a9			if FORTH_PARSEV4 
18a9			include "forth_stackops.asm" 
18a9			endif 
18a9			 
18a9			if FORTH_PARSEV5 
18a9			include "forth_stackopsv5.asm" 
18a9			 
18a9			; Stack operations for v5 parser on wards 
18a9			; * DATA stack 
18a9			; * LOOP stack 
18a9			; * RETURN stack 
18a9			 
18a9			 
18a9			 
18a9			FORTH_CHK_DSP_UNDER: macro 
18a9				push hl 
18a9				push de 
18a9				ld hl,(cli_data_sp) 
18a9				ld de, cli_data_stack 
18a9				call cmp16 
18a9				jp c, fault_dsp_under 
18a9				pop de 
18a9				pop hl 
18a9				endm 
18a9			 
18a9			 
18a9			FORTH_CHK_RSP_UNDER: macro 
18a9				push hl 
18a9				push de 
18a9				ld hl,(cli_ret_sp) 
18a9				ld de, cli_ret_stack 
18a9				call cmp16 
18a9				jp c, fault_rsp_under 
18a9				pop de 
18a9				pop hl 
18a9				endm 
18a9			 
18a9			FORTH_CHK_LOOP_UNDER: macro 
18a9				push hl 
18a9				push de 
18a9				ld hl,(cli_loop_sp) 
18a9				ld de, cli_loop_stack 
18a9				call cmp16 
18a9				jp c, fault_loop_under 
18a9				pop de 
18a9				pop hl 
18a9				endm 
18a9			 
18a9			FORTH_ERR_TOS_NOTSTR: macro 
18a9				; TOSO might need more for checks when used 
18a9				push af 
18a9				ld a,(hl) 
18a9				cp DS_TYPE_STR 
18a9				jp nz, type_faultn   
18a9				pop af 
18a9				endm 
18a9			 
18a9			FORTH_ERR_TOS_NOTNUM: macro 
18a9				push af 
18a9				ld a,(hl) 
18a9				cp DS_TYPE_INUM 
18a9				jp nz, type_faultn   
18a9				pop af 
18a9				endm 
18a9			 
18a9			 
18a9			; increase data stack pointer and save hl to it 
18a9				 
18a9			FORTH_DSP_NEXT: macro 
18a9				call macro_forth_dsp_next 
18a9				endm 
18a9			 
18a9			 
18a9			macro_forth_dsp_next: 
18a9				if DEBUG_FORTH_STACK_GUARD 
18a9 cd e4 54				call check_stacks 
18ac				endif 
18ac e5				push hl 
18ad d5				push de 
18ae eb				ex de,hl 
18af 2a 22 eb			ld hl,(cli_data_sp) 
18b2 23				inc hl 
18b3 23				inc hl 
18b4			 
18b4			; PARSEV5 
18b4 23				inc hl 
18b5 22 22 eb			ld (cli_data_sp),hl 
18b8 73				ld (hl), e 
18b9 23				inc hl 
18ba 72				ld (hl), d 
18bb d1				pop de 
18bc e1				pop hl 
18bd				if DEBUG_FORTH_STACK_GUARD 
18bd cd e4 54				call check_stacks 
18c0				endif 
18c0 c9				ret 
18c1			 
18c1			 
18c1			; increase ret stack pointer and save hl to it 
18c1				 
18c1			FORTH_RSP_NEXT: macro 
18c1				call macro_forth_rsp_next 
18c1				endm 
18c1			 
18c1			macro_forth_rsp_next: 
18c1				if DEBUG_FORTH_STACK_GUARD 
18c1 cd e4 54				call check_stacks 
18c4				endif 
18c4 e5				push hl 
18c5 d5				push de 
18c6 eb				ex de,hl 
18c7 2a 26 eb			ld hl,(cli_ret_sp) 
18ca 23				inc hl 
18cb 23				inc hl 
18cc 22 26 eb			ld (cli_ret_sp),hl 
18cf 73				ld (hl), e 
18d0 23				inc hl 
18d1 72				ld (hl), d 
18d2 d1				pop de 
18d3 e1				pop hl 
18d4				if DEBUG_FORTH_STACK_GUARD 
18d4 cd e4 54				call check_stacks 
18d7				endif 
18d7 c9				ret 
18d8			 
18d8			; get current ret stack pointer and save to hl  
18d8				 
18d8			FORTH_RSP_TOS: macro 
18d8				call macro_forth_rsp_tos 
18d8				endm 
18d8			 
18d8			macro_forth_rsp_tos: 
18d8				;push de 
18d8 2a 26 eb			ld hl,(cli_ret_sp) 
18db cd 13 19			call loadhlptrtohl 
18de				;ld e, (hl) 
18de				;inc hl 
18de				;ld d, (hl) 
18de				;ex de, hl 
18de					if DEBUG_FORTH_WORDS 
18de			;			DMARK "RST" 
18de						CALLMONITOR 
18de cd 80 13			call break_point_state  
18e1				endm  
# End of macro CALLMONITOR
18e1					endif 
18e1				;pop de 
18e1 c9				ret 
18e2			 
18e2			; pop ret stack pointer 
18e2				 
18e2			FORTH_RSP_POP: macro 
18e2				call macro_forth_rsp_pop 
18e2				endm 
18e2			 
18e2			 
18e2			macro_forth_rsp_pop: 
18e2				if DEBUG_FORTH_STACK_GUARD 
18e2			;		DMARK "RPP" 
18e2 cd e4 54				call check_stacks 
18e5					FORTH_CHK_RSP_UNDER 
18e5 e5				push hl 
18e6 d5				push de 
18e7 2a 26 eb			ld hl,(cli_ret_sp) 
18ea 11 e0 ea			ld de, cli_ret_stack 
18ed cd 86 0b			call cmp16 
18f0 da f8 55			jp c, fault_rsp_under 
18f3 d1				pop de 
18f4 e1				pop hl 
18f5				endm 
# End of macro FORTH_CHK_RSP_UNDER
18f5				endif 
18f5 e5				push hl 
18f6 2a 26 eb			ld hl,(cli_ret_sp) 
18f9			 
18f9			 
18f9				if FORTH_ENABLE_FREE 
18f9			 
18f9					; get pointer 
18f9			 
18f9					push de 
18f9					push hl 
18f9			 
18f9					ld e, (hl) 
18f9					inc hl 
18f9					ld d, (hl) 
18f9			 
18f9					ex de, hl 
18f9					call free 
18f9			 
18f9					pop hl 
18f9					pop de 
18f9			 
18f9			 
18f9				endif 
18f9			 
18f9			 
18f9 2b				dec hl 
18fa 2b				dec hl 
18fb 22 26 eb			ld (cli_ret_sp), hl 
18fe				; do stack underflow checks 
18fe e1				pop hl 
18ff				if DEBUG_FORTH_STACK_GUARD 
18ff cd e4 54				call check_stacks 
1902					FORTH_CHK_RSP_UNDER 
1902 e5				push hl 
1903 d5				push de 
1904 2a 26 eb			ld hl,(cli_ret_sp) 
1907 11 e0 ea			ld de, cli_ret_stack 
190a cd 86 0b			call cmp16 
190d da f8 55			jp c, fault_rsp_under 
1910 d1				pop de 
1911 e1				pop hl 
1912				endm 
# End of macro FORTH_CHK_RSP_UNDER
1912				endif 
1912 c9				ret 
1913			 
1913			 
1913			 
1913			; routine to load word pointed to by hl into hl 
1913			 
1913			loadhlptrtohl: 
1913			 
1913 d5				push de 
1914 5e				ld e, (hl) 
1915 23				inc hl 
1916 56				ld d, (hl) 
1917 eb				ex de, hl 
1918 d1				pop de 
1919			 
1919 c9				ret 
191a			 
191a			 
191a			 
191a			 
191a			 
191a			; push a number held in HL onto the data stack 
191a			; entry point for pushing a value when already in hl used in function above 
191a			 
191a			forth_push_numhl: 
191a			 
191a e5				push hl    ; save value to push 
191b			 
191b			if DEBUG_FORTH_PUSH 
191b				; see if disabled 
191b			 
191b			 
191b				push af 
191b				ld a, (os_view_disable) 
191b				cp '*' 
191b				jr z, .pskip2 
191b				push hl 
191b			push hl 
191b				call clear_display 
191b			pop hl 
191b				ld a,h 
191b				ld hl, os_word_scratch 
191b				call hexout 
191b				pop hl 
191b				ld a,l 
191b				ld hl, os_word_scratch+2 
191b				call hexout 
191b			 
191b				ld hl, os_word_scratch+4 
191b				ld a,0 
191b				ld (hl),a 
191b				ld de,os_word_scratch 
191b					ld a, display_row_2 
191b					call str_at_display 
191b				ld de, .push_num 
191b				ld a, display_row_1 
191b			 
191b					call str_at_display 
191b			 
191b			 
191b				call update_display 
191b				call delay1s 
191b				call delay1s 
191b			.pskip2:  
191b			 
191b				pop af 
191b			endif	 
191b			 
191b			 
191b				FORTH_DSP_NEXT 
191b cd a9 18			call macro_forth_dsp_next 
191e				endm 
# End of macro FORTH_DSP_NEXT
191e			 
191e 2a 22 eb			ld hl, (cli_data_sp) 
1921			 
1921				; save item type 
1921 3e 02			ld a,  DS_TYPE_INUM 
1923 77				ld (hl), a 
1924 23				inc hl 
1925			 
1925				; get word off stack 
1925 d1				pop de 
1926 7b				ld a,e 
1927 77				ld (hl), a 
1928 23				inc hl 
1929 7a				ld a,d 
192a 77				ld (hl), a 
192b			 
192b			if DEBUG_FORTH_PUSH 
192b				dec hl 
192b				dec hl 
192b				dec hl 
192b						DMARK "PH5" 
192b				CALLMONITOR 
192b			endif	 
192b			 
192b c9				ret 
192c			 
192c			 
192c			; Push a string to stack pointed to by hl 
192c			 
192c			forth_push_str: 
192c			 
192c			if DEBUG_FORTH_PUSH 
192c						DMARK "PSQ" 
192c				CALLMONITOR 
192c			endif	 
192c			    
192c e5				push hl 
192d e5				push hl 
192e			 
192e 3e 00			ld a, 0   ; find end of string 
1930 cd d1 0f			call strlent       
1933			if DEBUG_FORTH_PUSH 
1933						DMARK "PQ2" 
1933				CALLMONITOR 
1933			endif	 
1933 eb				ex de, hl 
1934 e1				pop hl   ; get ptr to start of string 
1935			if DEBUG_FORTH_PUSH 
1935						DMARK "PQ3" 
1935				CALLMONITOR 
1935			endif	 
1935 19				add hl,de 
1936			if DEBUG_FORTH_PUSH 
1936						DMARK "PQE" 
1936				CALLMONITOR 
1936			endif	 
1936			 
1936 2b				dec hl    ; see if there is an optional trailing double quote 
1937 7e				ld a,(hl) 
1938 fe 22			cp '"' 
193a 20 03			jr nz, .strnoq 
193c 3e 00			ld a, 0      ; get rid of double quote 
193e 77				ld (hl), a 
193f 23			.strnoq: inc hl 
1940			 
1940 3e 00			ld a, 0 
1942 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1943			 
1943 13				inc de ; add one for the type string 
1944 13				inc de ; add one for null term??? 
1945			 
1945				; tos is get string pointer again 
1945				; de contains space to allocate 
1945				 
1945 d5				push de 
1946			 
1946 eb				ex de, hl 
1947			 
1947				;push af 
1947			 
1947			if DEBUG_FORTH_PUSH 
1947						DMARK "PHm" 
1947				CALLMONITOR 
1947			endif	 
1947 cd 2f 10			call malloc	; on ret hl now contains allocated memory 
194a				if DEBUG_FORTH_MALLOC_GUARD 
194a cc 4a 44				call z,malloc_error 
194d				endif 
194d			 
194d				 
194d c1				pop bc    ; get length 
194e d1				pop de   ;  get string start    
194f			 
194f				; hl has destination from malloc 
194f			 
194f eb				ex de, hl    ; prep for ldir 
1950			 
1950 e5				push hl   ; save malloc area for DSP later 
1951			 
1951			if DEBUG_FORTH_PUSH 
1951						DMARK "PHc" 
1951				CALLMONITOR 
1951			endif	 
1951			 
1951			 
1951 ed b0			ldir 
1953			 
1953			 
1953				; push malloc to data stack     macro?????  
1953			 
1953				FORTH_DSP_NEXT 
1953 cd a9 18			call macro_forth_dsp_next 
1956				endm 
# End of macro FORTH_DSP_NEXT
1956			 
1956				; save value and type 
1956			 
1956 2a 22 eb			ld hl, (cli_data_sp) 
1959			 
1959				; save item type 
1959 3e 01			ld a,  DS_TYPE_STR 
195b 77				ld (hl), a 
195c 23				inc hl 
195d			 
195d				; get malloc word off stack 
195d d1				pop de 
195e 73				ld (hl), e 
195f 23				inc hl 
1960 72				ld (hl), d 
1961			 
1961			 
1961			 
1961			if DEBUG_FORTH_PUSH 
1961				ld hl, (cli_data_sp) 
1961						DMARK "PHS" 
1961				CALLMONITOR 
1961			;	ex de,hl 
1961			endif	 
1961				; in case of spaces, skip the ptr past the copied string 
1961				;pop af 
1961				;ld (cli_origptr),hl 
1961			 
1961 c9				ret 
1962			 
1962			 
1962			 
1962			; TODO ascii push input onto stack given hl to start of input 
1962			 
1962			; identify type 
1962			; if starts with a " then a string 
1962			; otherwise it is a number 
1962			;  
1962			; if a string 
1962			;     scan for ending " to get length of string to malloc for + 1 
1962			;     malloc 
1962			;     put pointer to string on stack first byte flags as string 
1962			; 
1962			; else a number 
1962			;    look for number format identifier 
1962			;    $xx hex 
1962			;    %xxxxx bin 
1962			;    xxxxx decimal 
1962			;    convert number to 16bit word.  
1962			;    malloc word + 1 with flag to identiy as num 
1962			;    put pointer to number on stack 
1962			;   
1962			;  
1962			  
1962			forth_apush: 
1962				; kernel push 
1962			 
1962			if DEBUG_FORTH_PUSH 
1962						DMARK "PSH" 
1962				CALLMONITOR 
1962			endif	 
1962				; identify input type 
1962			 
1962 7e				ld a,(hl) 
1963 fe 22			cp '"' 
1965 28 0a			jr z, .fapstr 
1967 fe 24			cp '$' 
1969 ca 91 19			jp z, .faphex 
196c fe 25			cp '%' 
196e ca 79 19			jp z, .fapbin 
1971			;	cp 'b' 
1971			;	jp z, .fabin 
1971				; else decimal 
1971			 
1971				; TODO do decimal conversion 
1971				; decimal is stored as a 16bit word 
1971			 
1971				; by default everything is a string if type is not detected 
1971			.fapstr: ; 
1971 fe 22			cp '"' 
1973 20 01			jr nz, .strnoqu 
1975 23				inc hl 
1976			.strnoqu: 
1976 c3 2c 19			jp forth_push_str 
1979			 
1979			 
1979			 
1979			.fapbin:    ; push a binary string.  
1979 11 00 00			ld de, 0   ; hold a 16bit value 
197c			 
197c 23			.fapbinshift:	inc hl  
197d 7e				ld a,(hl) 
197e fe 00			cp 0     ; done scanning  
1980 28 0b			jr z, .fapbdone  	; got it in HL so push  
1982			 
1982				; left shift de 
1982 eb				ex de, hl	 
1983 29				add hl, hl 
1984			 
1984				; is 1 
1984 fe 31			cp '1' 
1986 20 02			jr nz, .binzero 
1988 cb 4d			bit 1, l 
198a			.binzero: 
198a eb				ex de, hl	 ; save current de 
198b 18 ef			jr .fapbinshift 
198d			 
198d			.fapbdone: 
198d eb				ex de, hl 
198e c3 1a 19			jp forth_push_numhl 
1991			 
1991			 
1991			.faphex:   ; hex is always stored as a 16bit word 
1991				; skip number prefix 
1991 23				inc hl 
1992				; turn ascii into number 
1992 cd 1f 0f			call get_word_hl	; ret 16bit word in hl 
1995			 
1995 c3 1a 19			jp forth_push_numhl 
1998			 
1998 00				 nop 
1999			 
1999			.fabin:   ; TODO bin conversion 
1999			 
1999			 
1999 c9				ret 
199a			 
199a			 
199a			; get either a string ptr or a 16bit word from the data stack 
199a			 
199a			FORTH_DSP: macro 
199a				call macro_forth_dsp 
199a				endm 
199a			 
199a			macro_forth_dsp: 
199a				; data stack pointer points to current word on tos 
199a			 
199a 2a 22 eb			ld hl,(cli_data_sp) 
199d			 
199d				if DEBUG_FORTH_PUSH 
199d						DMARK "DSP" 
199d			 
199d					call display_data_sp 
199d				;call break_point_state 
199d				;rst 030h 
199d				CALLMONITOR 
199d				endif 
199d			 
199d c9				ret 
199e			 
199e			; return hl to start of value on stack 
199e			 
199e			FORTH_DSP_VALUE: macro 
199e				call macro_forth_dsp_value 
199e				endm 
199e			 
199e			macro_forth_dsp_value: 
199e			 
199e				FORTH_DSP 
199e cd 9a 19			call macro_forth_dsp 
19a1				endm 
# End of macro FORTH_DSP
19a1			 
19a1 d5				push de 
19a2			 
19a2 23				inc hl ; skip type 
19a3			 
19a3 5e				ld e, (hl) 
19a4 23				inc hl 
19a5 56				ld d, (hl) 
19a6 eb				ex de,hl  
19a7			 
19a7 d1				pop de 
19a8			 
19a8 c9				ret 
19a9			 
19a9			; return hl to start of value to second item on stack 
19a9			 
19a9			FORTH_DSP_VALUEM1: macro 
19a9				call macro_forth_dsp_value_m1 
19a9				endm 
19a9			 
19a9			macro_forth_dsp_value_m1: 
19a9			 
19a9				FORTH_DSP 
19a9 cd 9a 19			call macro_forth_dsp 
19ac				endm 
# End of macro FORTH_DSP
19ac			 
19ac 2b				dec hl 
19ad 2b				dec hl 
19ae			;	dec hl 
19ae			 
19ae d5				push de 
19af			 
19af 5e				ld e, (hl) 
19b0 23				inc hl 
19b1 56				ld d, (hl) 
19b2 eb				ex de,hl  
19b3			 
19b3 d1				pop de 
19b4			 
19b4 c9				ret 
19b5			 
19b5				 
19b5			 
19b5			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
19b5			 
19b5			FORTH_DSP_POP: macro 
19b5				call macro_forth_dsp_pop 
19b5				endm 
19b5			 
19b5			 
19b5			; get the tos data type 
19b5			 
19b5			FORTH_DSP_TYPE:   macro 
19b5			 
19b5				;FORTH_DSP_VALUE 
19b5				FORTH_DSP 
19b5				 
19b5				; hl points to value 
19b5				; check type 
19b5			 
19b5				ld a,(hl) 
19b5			 
19b5				endm 
19b5			 
19b5			; load the tos value into hl 
19b5			 
19b5			 
19b5			FORTH_DSP_VALUEHL:  macro 
19b5				call macro_dsp_valuehl 
19b5				endm 
19b5			 
19b5			 
19b5			 
19b5			macro_dsp_valuehl: 
19b5				FORTH_DSP_VALUE 
19b5 cd 9e 19			call macro_forth_dsp_value 
19b8				endm 
# End of macro FORTH_DSP_VALUE
19b8			 
19b8				;FORTH_ERR_TOS_NOTNUM 
19b8			 
19b8				;inc hl   ; skip type id 
19b8			 
19b8			;	push de 
19b8			; 
19b8			;	ld e, (hl) 
19b8			;	inc hl 
19b8			;	ld d, (hl) 
19b8			;	ex de,hl  
19b8			 
19b8			;	pop de 
19b8			 
19b8				if DEBUG_FORTH_PUSH 
19b8						DMARK "DVL" 
19b8				CALLMONITOR 
19b8				endif 
19b8 c9				ret 
19b9			 
19b9			forth_apushstrhl:      
19b9				; push of string requires use of cli_origptr 
19b9				; bodge use 
19b9			 
19b9				; get current cli_origptr, save, update with temp pointer  
19b9 ed 5b 3e eb		ld de, (cli_origptr) 
19bd 22 3e eb			ld (cli_origptr), hl 
19c0 d5				push de 
19c1 cd 62 19			call forth_apush 
19c4 d1				pop de 
19c5 ed 53 3e eb		ld (cli_origptr), de 
19c9 c9			        ret	 
19ca			 
19ca			 
19ca			; increase loop stack pointer and save hl to it 
19ca				 
19ca			FORTH_LOOP_NEXT: macro 
19ca				call macro_forth_loop_next 
19ca				;nop 
19ca				endm 
19ca			 
19ca			macro_forth_loop_next: 
19ca				if DEBUG_FORTH_STACK_GUARD 
19ca cd e4 54				call check_stacks 
19cd				endif 
19cd e5				push hl 
19ce d5				push de 
19cf eb				ex de,hl 
19d0 2a 24 eb			ld hl,(cli_loop_sp) 
19d3 23				inc hl 
19d4 23				inc hl 
19d5					if DEBUG_FORTH_WORDS 
19d5						DMARK "LNX" 
19d5 f5				push af  
19d6 3a ea 19			ld a, (.dmark)  
19d9 32 7a ee			ld (debug_mark),a  
19dc 3a eb 19			ld a, (.dmark+1)  
19df 32 7b ee			ld (debug_mark+1),a  
19e2 3a ec 19			ld a, (.dmark+2)  
19e5 32 7c ee			ld (debug_mark+2),a  
19e8 18 03			jr .pastdmark  
19ea ..			.dmark: db "LNX"  
19ed f1			.pastdmark: pop af  
19ee			endm  
# End of macro DMARK
19ee						CALLMONITOR 
19ee cd 80 13			call break_point_state  
19f1				endm  
# End of macro CALLMONITOR
19f1					endif 
19f1 22 24 eb			ld (cli_loop_sp),hl 
19f4 73				ld (hl), e 
19f5 23				inc hl 
19f6 72				ld (hl), d 
19f7 d1				pop de    ; been reversed so save a swap on restore 
19f8 e1				pop hl 
19f9				if DEBUG_FORTH_STACK_GUARD 
19f9 cd e4 54				call check_stacks 
19fc				endif 
19fc c9				ret 
19fd			 
19fd			; get current ret stack pointer and save to hl  
19fd				 
19fd			FORTH_LOOP_TOS: macro 
19fd				call macro_forth_loop_tos 
19fd				endm 
19fd			 
19fd			macro_forth_loop_tos: 
19fd d5				push de 
19fe 2a 24 eb			ld hl,(cli_loop_sp) 
1a01 5e				ld e, (hl) 
1a02 23				inc hl 
1a03 56				ld d, (hl) 
1a04 eb				ex de, hl 
1a05 d1				pop de 
1a06 c9				ret 
1a07			 
1a07			; pop loop stack pointer 
1a07				 
1a07			FORTH_LOOP_POP: macro 
1a07				call macro_forth_loop_pop 
1a07				endm 
1a07			 
1a07			 
1a07			macro_forth_loop_pop: 
1a07				if DEBUG_FORTH_STACK_GUARD 
1a07					DMARK "LPP" 
1a07 f5				push af  
1a08 3a 1c 1a			ld a, (.dmark)  
1a0b 32 7a ee			ld (debug_mark),a  
1a0e 3a 1d 1a			ld a, (.dmark+1)  
1a11 32 7b ee			ld (debug_mark+1),a  
1a14 3a 1e 1a			ld a, (.dmark+2)  
1a17 32 7c ee			ld (debug_mark+2),a  
1a1a 18 03			jr .pastdmark  
1a1c ..			.dmark: db "LPP"  
1a1f f1			.pastdmark: pop af  
1a20			endm  
# End of macro DMARK
1a20 cd e4 54				call check_stacks 
1a23					FORTH_CHK_LOOP_UNDER 
1a23 e5				push hl 
1a24 d5				push de 
1a25 2a 24 eb			ld hl,(cli_loop_sp) 
1a28 11 de e9			ld de, cli_loop_stack 
1a2b cd 86 0b			call cmp16 
1a2e da fe 55			jp c, fault_loop_under 
1a31 d1				pop de 
1a32 e1				pop hl 
1a33				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1a33				endif 
1a33 e5				push hl 
1a34 2a 24 eb			ld hl,(cli_loop_sp) 
1a37 2b				dec hl 
1a38 2b				dec hl 
1a39 22 24 eb			ld (cli_loop_sp), hl 
1a3c				; TODO do stack underflow checks 
1a3c e1				pop hl 
1a3d				if DEBUG_FORTH_STACK_GUARD 
1a3d cd e4 54				call check_stacks 
1a40					FORTH_CHK_LOOP_UNDER 
1a40 e5				push hl 
1a41 d5				push de 
1a42 2a 24 eb			ld hl,(cli_loop_sp) 
1a45 11 de e9			ld de, cli_loop_stack 
1a48 cd 86 0b			call cmp16 
1a4b da fe 55			jp c, fault_loop_under 
1a4e d1				pop de 
1a4f e1				pop hl 
1a50				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1a50				endif 
1a50 c9				ret 
1a51			 
1a51			macro_forth_dsp_pop: 
1a51			 
1a51 e5				push hl 
1a52			 
1a52				; release malloc data 
1a52			 
1a52				if DEBUG_FORTH_STACK_GUARD 
1a52 cd e4 54				call check_stacks 
1a55					FORTH_CHK_DSP_UNDER 
1a55 e5				push hl 
1a56 d5				push de 
1a57 2a 22 eb			ld hl,(cli_data_sp) 
1a5a 11 dc e8			ld de, cli_data_stack 
1a5d cd 86 0b			call cmp16 
1a60 da f2 55			jp c, fault_dsp_under 
1a63 d1				pop de 
1a64 e1				pop hl 
1a65				endm 
# End of macro FORTH_CHK_DSP_UNDER
1a65				endif 
1a65				;ld hl,(cli_data_sp) 
1a65			if DEBUG_FORTH_DOT 
1a65				DMARK "DPP" 
1a65				CALLMONITOR 
1a65			endif	 
1a65			 
1a65			 
1a65			if FORTH_ENABLE_DSPPOPFREE 
1a65			 
1a65				FORTH_DSP 
1a65 cd 9a 19			call macro_forth_dsp 
1a68				endm 
# End of macro FORTH_DSP
1a68			 
1a68 7e				ld a, (hl) 
1a69 fe 01			cp DS_TYPE_STR 
1a6b 20 07			jr nz, .skippopfree 
1a6d			 
1a6d				FORTH_DSP_VALUEHL 
1a6d cd b5 19			call macro_dsp_valuehl 
1a70				endm 
# End of macro FORTH_DSP_VALUEHL
1a70 00				nop 
1a71			if DEBUG_FORTH_DOT 
1a71				DMARK "DPf" 
1a71				CALLMONITOR 
1a71			endif	 
1a71 cd f9 10			call free 
1a74			.skippopfree: 
1a74				 
1a74			 
1a74			endif 
1a74			 
1a74			if DEBUG_FORTH_DOT_KEY 
1a74				DMARK "DP2" 
1a74				CALLMONITOR 
1a74			endif	 
1a74			 
1a74				; move pointer down 
1a74			 
1a74 2a 22 eb			ld hl,(cli_data_sp) 
1a77 2b				dec hl 
1a78 2b				dec hl 
1a79			; PARSEV5 
1a79 2b				dec hl 
1a7a 22 22 eb			ld (cli_data_sp), hl 
1a7d			 
1a7d				if DEBUG_FORTH_STACK_GUARD 
1a7d cd e4 54				call check_stacks 
1a80					FORTH_CHK_DSP_UNDER 
1a80 e5				push hl 
1a81 d5				push de 
1a82 2a 22 eb			ld hl,(cli_data_sp) 
1a85 11 dc e8			ld de, cli_data_stack 
1a88 cd 86 0b			call cmp16 
1a8b da f2 55			jp c, fault_dsp_under 
1a8e d1				pop de 
1a8f e1				pop hl 
1a90				endm 
# End of macro FORTH_CHK_DSP_UNDER
1a90				endif 
1a90			 
1a90 e1				pop hl 
1a91			 
1a91 c9				ret 
1a92			 
1a92			getwordathl: 
1a92				; hl points to an address 
1a92				; load hl with the word at that address 
1a92			 
1a92 d5				push de 
1a93			 
1a93 5e				ld e, (hl) 
1a94 23				inc hl 
1a95 56				ld d, (hl) 
1a96 eb				ex de, hl 
1a97			 
1a97 d1				pop de 
1a98 c9				ret 
1a99			 
1a99			 
1a99			 
1a99			 
1a99			 
1a99			; eof 
1a99			 
# End of file forth_stackopsv5.asm
1a99			endif 
1a99			 
1a99			user_word_eol:  
1a99				; hl contains the pointer to where to create a linked list item from the end 
1a99				; of the user dict to continue on at the system word dict 
1a99				 
1a99				; poke the stub of the word list linked list to repoint to rom words 
1a99			 
1a99				; stub format 
1a99				; db   word id 
1a99				; dw    link to next word 
1a99			        ; db char length of token 
1a99				; db string + 0 term 
1a99				; db exec code....  
1a99			 
1a99 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1a9b 77				ld (hl), a		; word id 
1a9c 23				inc hl 
1a9d			 
1a9d 11 63 1c			ld de, sysdict 
1aa0 73				ld (hl), e		; next word link ie system dict 
1aa1 23				inc hl 
1aa2 72				ld (hl), d		; next word link ie system dict 
1aa3 23				inc hl	 
1aa4			 
1aa4			;	ld (hl), sysdict		; next word link ie system dict 
1aa4			;	inc hl 
1aa4			;	inc hl 
1aa4			 
1aa4			;	inc hl 
1aa4			;	inc hl 
1aa4			 
1aa4 3e 02			ld a, 2			; word length is 0 
1aa6 77				ld (hl), a	 
1aa7 23				inc hl 
1aa8			 
1aa8 3e 7e			ld a, '~'			; word length is 0 
1aaa 77				ld (hl), a	 
1aab 23				inc hl 
1aac 3e 00			ld a, 0			; save empty word 
1aae 77				ld (hl), a 
1aaf			 
1aaf c9				ret 
1ab0			 
1ab0				 
1ab0			 
1ab0			forthexec_cleanup: 
1ab0				FORTH_RSP_POP 
1ab0 cd e2 18			call macro_forth_rsp_pop 
1ab3				endm 
# End of macro FORTH_RSP_POP
1ab3 c9				ret 
1ab4			 
1ab4			forth_call_hl: 
1ab4				; taking hl 
1ab4 e5				push hl 
1ab5 c9				ret 
1ab6			 
1ab6			; this is called to reset Forth system but keep existing uwords etc 
1ab6			 
1ab6			forth_warmstart: 
1ab6				; setup stack over/under flow checks 
1ab6				if DEBUG_FORTH_STACK_GUARD 
1ab6 cd ca 54				call chk_stk_init 
1ab9				endif 
1ab9			 
1ab9				; init stack pointers  - * these stacks go upwards *  
1ab9 21 e0 ea			ld hl, cli_ret_stack 
1abc 22 26 eb			ld (cli_ret_sp), hl	 
1abf				; set bottom of stack 
1abf 3e 00			ld a,0 
1ac1 77				ld (hl),a 
1ac2 23				inc hl 
1ac3 77				ld (hl),a 
1ac4			 
1ac4 21 dc e8			ld hl, cli_data_stack 
1ac7 22 22 eb			ld (cli_data_sp), hl	 
1aca				; set bottom of stack 
1aca 3e 00			ld a,0 
1acc 77				ld (hl),a 
1acd 23				inc hl 
1ace 77				ld (hl),a 
1acf			 
1acf 21 de e9			ld hl, cli_loop_stack 
1ad2 22 24 eb			ld (cli_loop_sp), hl	 
1ad5				; set bottom of stack 
1ad5 3e 00			ld a,0 
1ad7 77				ld (hl),a 
1ad8 23				inc hl 
1ad9 77				ld (hl),a 
1ada			 
1ada				; init extent of current open file 
1ada			 
1ada 3e 00			ld a, 0 
1adc 32 5c eb			ld (store_openext), a 
1adf			 
1adf c9				ret 
1ae0			 
1ae0			 
1ae0			; Cold Start - this is called to setup the whole Forth system 
1ae0			 
1ae0			forth_init: 
1ae0			 
1ae0				; setup stack over/under flow checks 
1ae0			 
1ae0			;	if DEBUG_FORTH_STACK_GUARD 
1ae0			;		call chk_stk_init 
1ae0			;	endif 
1ae0			 
1ae0				; enable auto display updates (slow.....) 
1ae0			 
1ae0 3e 01			ld a, 1 
1ae2 32 3c eb			ld (cli_autodisplay), a 
1ae5			 
1ae5			 
1ae5			 
1ae5				; show start up screen 
1ae5			 
1ae5 cd 3f 09			call clear_display 
1ae8			 
1ae8 3e 00			ld a,0 
1aea 32 5e eb			ld (f_cursor_ptr), a 
1aed			 
1aed				; set start of word list in start of ram - for use when creating user words 
1aed			 
1aed 21 ed 57			ld hl, baseram 
1af0 22 72 e6			ld (os_last_new_uword), hl 
1af3 cd 99 1a			call user_word_eol 
1af6				 
1af6			;		call display_data_sp 
1af6			;		call next_page_prompt 
1af6			 
1af6			 
1af6			 
1af6			 
1af6 c9				ret 
1af7			 
1af7 .. 00		.bootforth: db " Forth Kernel Init ",0 
1b0b			 
1b0b			; TODO push to stack 
1b0b			 
1b0b			;  
1b0b			 
1b0b			if FORTH_PARSEV2 
1b0b			 
1b0b			 
1b0b				include "forth_parserv2.asm" 
1b0b			 
1b0b			endif 
1b0b			 
1b0b			 
1b0b			; parse cli version 1 
1b0b			 
1b0b			if FORTH_PARSEV1 
1b0b			 
1b0b			 
1b0b			 
1b0b			      include "forth_parserv1.asm" 
1b0b			endif 
1b0b				 
1b0b			if FORTH_PARSEV3 
1b0b			 
1b0b			 
1b0b			 
1b0b			      include "forth_parserv3.asm" 
1b0b				include "forth_wordsv3.asm" 
1b0b			endif 
1b0b			 
1b0b			if FORTH_PARSEV4 
1b0b			 
1b0b			 
1b0b			 
1b0b			      include "forth_parserv4.asm" 
1b0b				include "forth_wordsv4.asm" 
1b0b			endif 
1b0b			 
1b0b			if FORTH_PARSEV5 
1b0b			 
1b0b			 
1b0b			 
1b0b			      include "forth_parserv5.asm" 
1b0b			 
1b0b			 
1b0b			; A better parser without using malloc and string copies all over the place.  
1b0b			; Exec in situ should be faster 
1b0b			 
1b0b			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1b0b			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1b0b			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1b0b			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1b0b			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1b0b			WORD_SYS_END: equ 0   ; Opcode for all user words 
1b0b			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1b0b			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1b0b			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1b0b			 
1b0b			; Core word preamble macro 
1b0b			 
1b0b			CWHEAD:   macro nxtword opcode lit len opflags 
1b0b				db WORD_SYS_CORE+opcode             
1b0b				; internal op code number 
1b0b				dw nxtword            
1b0b				; link to next dict word block 
1b0b				db len + 1 
1b0b				; literal length of dict word inc zero term 
1b0b				db lit,0              
1b0b				; literal dict word 
1b0b			        ; TODO db opflags        
1b0b				endm 
1b0b			 
1b0b			 
1b0b			NEXTW: macro  
1b0b				jp macro_next 
1b0b				endm 
1b0b			 
1b0b			macro_next: 
1b0b			if DEBUG_FORTH_PARSE_KEY 
1b0b				DMARK "NXT" 
1b0b				CALLMONITOR 
1b0b			endif	 
1b0b			;	inc hl  ; skip token null term  
1b0b ed 4b 40 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1b0f ed 5b 3e eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1b13 2a 76 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1b16			if DEBUG_FORTH_PARSE_KEY 
1b16				DMARK "}AA" 
1b16				CALLMONITOR 
1b16			endif	 
1b16 c3 19 1c			jp execnext 
1b19				;jp exec1 
1b19			       
1b19			 
1b19			 
1b19			; Another go at the parser to compile  
1b19			 
1b19			 
1b19			; TODO rework parser to change all of the string words to byte tokens 
1b19			; TODO do a search for  
1b19			 
1b19			; TODO first run normal parser to zero term sections 
1b19			; TODO for each word do a token look up to get the op code 
1b19			; TODO need some means to flag to the exec that this is a byte code form    
1b19			 
1b19			 
1b19			forthcompile: 
1b19			 
1b19			; 
1b19			; line parse: 
1b19			;       parse raw input buffer 
1b19			;       tokenise the words 
1b19			;       malloc new copy (for looping etc) 
1b19			;       copy to malloc + current pc in line to start of string and add line term 
1b19			;       save on new rsp 
1b19			; 
1b19			 
1b19			; hl to point to the line to tokenise 
1b19			 
1b19			;	push hl 
1b19 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1b1c			 
1b1c			;	ld a,0		; string term on input 
1b1c			;	call strlent 
1b1c			 
1b1c			;	ld (os_tok_len), hl	 ; save string length 
1b1c			 
1b1c			;if DEBUG_FORTH_TOK 
1b1c			;	ex de,hl		 
1b1c			;endif 
1b1c			 
1b1c			;	pop hl 		; get back string pointer 
1b1c			 
1b1c			if DEBUG_FORTH_TOK 
1b1c						DMARK "TOc" 
1b1c				CALLMONITOR 
1b1c			endif 
1b1c 7e			.cptoken2:    ld a,(hl) 
1b1d 23				inc hl 
1b1e fe 7f			cp FORTH_END_BUFFER 
1b20 28 29			jr z, .cptokendone2 
1b22 fe 00			cp 0 
1b24 28 25			jr z, .cptokendone2 
1b26 fe 22			cp '"' 
1b28 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1b2a fe 20			cp ' ' 
1b2c 20 ee			jr nz,  .cptoken2 
1b2e			 
1b2e			; TODO consume comments held between ( and ) 
1b2e			 
1b2e				; we have a space so change to zero term for dict match later 
1b2e 2b				dec hl 
1b2f 3e 00			ld a,0 
1b31 77				ld (hl), a 
1b32 23				inc hl 
1b33 18 e7			jr .cptoken2 
1b35				 
1b35			 
1b35			.cptokenstr2: 
1b35				; skip all white space until either eol (because forgot to term) or end double quote 
1b35			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1b35				;inc hl ; skip current double quote 
1b35 7e				ld a,(hl) 
1b36 23				inc hl 
1b37 fe 22			cp '"' 
1b39 28 e1			jr z, .cptoken2 
1b3b fe 7f			cp FORTH_END_BUFFER 
1b3d 28 0c			jr z, .cptokendone2 
1b3f fe 00			cp 0 
1b41 28 08			jr z, .cptokendone2 
1b43 fe 20			cp ' ' 
1b45 28 02			jr z, .cptmp2 
1b47 18 ec			jr .cptokenstr2 
1b49			 
1b49			.cptmp2:	; we have a space so change to zero term for dict match later 
1b49				;dec hl 
1b49				;ld a,"-"	; TODO remove this when working 
1b49				;ld (hl), a 
1b49				;inc hl 
1b49 18 ea			jr .cptokenstr2 
1b4b			 
1b4b			.cptokendone2: 
1b4b				;inc hl 
1b4b 3e 7f			ld a, FORTH_END_BUFFER 
1b4d 77				ld (hl),a 
1b4e 23				inc hl 
1b4f 3e 21			ld a, '!' 
1b51 77				ld (hl),a 
1b52			 
1b52 2a 76 e6			ld hl,(os_tok_ptr) 
1b55			         
1b55			if DEBUG_FORTH_TOK 
1b55						DMARK "Tc1" 
1b55				CALLMONITOR 
1b55			endif 
1b55			 
1b55				; push exec string to top of return stack 
1b55				FORTH_RSP_NEXT 
1b55 cd c1 18			call macro_forth_rsp_next 
1b58				endm 
# End of macro FORTH_RSP_NEXT
1b58 c9				ret 
1b59			 
1b59			; Another go at the parser need to simplify the process 
1b59			 
1b59			forthparse: 
1b59			 
1b59			; 
1b59			; line parse: 
1b59			;       parse raw input buffer 
1b59			;       tokenise the words 
1b59			;       malloc new copy (for looping etc) 
1b59			;       copy to malloc + current pc in line to start of string and add line term 
1b59			;       save on new rsp 
1b59			; 
1b59			 
1b59			; hl to point to the line to tokenise 
1b59			 
1b59			;	push hl 
1b59 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1b5c			 
1b5c			;	ld a,0		; string term on input 
1b5c			;	call strlent 
1b5c			 
1b5c			;	ld (os_tok_len), hl	 ; save string length 
1b5c			 
1b5c			;if DEBUG_FORTH_TOK 
1b5c			;	ex de,hl		 
1b5c			;endif 
1b5c			 
1b5c			;	pop hl 		; get back string pointer 
1b5c			 
1b5c			if DEBUG_FORTH_TOK 
1b5c						DMARK "TOK" 
1b5c				CALLMONITOR 
1b5c			endif 
1b5c 7e			.ptoken2:    ld a,(hl) 
1b5d 23				inc hl 
1b5e fe 7f			cp FORTH_END_BUFFER 
1b60 28 29			jr z, .ptokendone2 
1b62 fe 00			cp 0 
1b64 28 25			jr z, .ptokendone2 
1b66 fe 22			cp '"' 
1b68 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1b6a fe 20			cp ' ' 
1b6c 20 ee			jr nz,  .ptoken2 
1b6e			 
1b6e			; TODO consume comments held between ( and ) 
1b6e			 
1b6e				; we have a space so change to zero term for dict match later 
1b6e 2b				dec hl 
1b6f 3e 00			ld a,0 
1b71 77				ld (hl), a 
1b72 23				inc hl 
1b73 18 e7			jr .ptoken2 
1b75				 
1b75			 
1b75			.ptokenstr2: 
1b75				; skip all white space until either eol (because forgot to term) or end double quote 
1b75			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1b75				;inc hl ; skip current double quote 
1b75 7e				ld a,(hl) 
1b76 23				inc hl 
1b77 fe 22			cp '"' 
1b79 28 e1			jr z, .ptoken2 
1b7b fe 7f			cp FORTH_END_BUFFER 
1b7d 28 0c			jr z, .ptokendone2 
1b7f fe 00			cp 0 
1b81 28 08			jr z, .ptokendone2 
1b83 fe 20			cp ' ' 
1b85 28 02			jr z, .ptmp2 
1b87 18 ec			jr .ptokenstr2 
1b89			 
1b89			.ptmp2:	; we have a space so change to zero term for dict match later 
1b89				;dec hl 
1b89				;ld a,"-"	; TODO remove this when working 
1b89				;ld (hl), a 
1b89				;inc hl 
1b89 18 ea			jr .ptokenstr2 
1b8b			 
1b8b			.ptokendone2: 
1b8b				;inc hl 
1b8b 3e 7f			ld a, FORTH_END_BUFFER 
1b8d 77				ld (hl),a 
1b8e 23				inc hl 
1b8f 3e 21			ld a, '!' 
1b91 77				ld (hl),a 
1b92			 
1b92 2a 76 e6			ld hl,(os_tok_ptr) 
1b95			         
1b95			if DEBUG_FORTH_TOK 
1b95						DMARK "TK1" 
1b95				CALLMONITOR 
1b95			endif 
1b95			 
1b95				; push exec string to top of return stack 
1b95				FORTH_RSP_NEXT 
1b95 cd c1 18			call macro_forth_rsp_next 
1b98				endm 
# End of macro FORTH_RSP_NEXT
1b98 c9				ret 
1b99			 
1b99			; 
1b99			;	; malloc size + buffer pointer + if is loop flag 
1b99			;	ld hl,(os_tok_len) 		 ; get string length 
1b99			; 
1b99			;	ld a,l 
1b99			; 
1b99			;	cp 0			; we dont want to use a null string 
1b99			;	ret z 
1b99			; 
1b99			;;	add 3    ; prefix malloc with buffer for current word ptr 
1b99			; 
1b99			;	add 5     ; TODO when certain not over writing memory remove 
1b99			; 
1b99			;		 
1b99			; 
1b99			;if DEBUG_FORTH_TOK 
1b99			;			DMARK "TKE" 
1b99			;	CALLMONITOR 
1b99			;endif 
1b99			; 
1b99			;	ld l,a 
1b99			;	ld h,0 
1b99			;;	push hl   ; save required space for the copy later 
1b99			;	call malloc 
1b99			;if DEBUG_FORTH_TOK 
1b99			;			DMARK "TKM" 
1b99			;	CALLMONITOR 
1b99			;endif 
1b99			;	if DEBUG_FORTH_MALLOC_GUARD 
1b99			;		push af 
1b99			;		call ishlzero 
1b99			;;		ld a, l 
1b99			;;		add h 
1b99			;;		cp 0 
1b99			;		pop af 
1b99			;		 
1b99			;		call z,malloc_error 
1b99			;	endif 
1b99			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1b99			; 
1b99			; 
1b99			;if DEBUG_FORTH_TOK 
1b99			;			DMARK "TKR" 
1b99			;	CALLMONITOR 
1b99			;endif 
1b99			; 
1b99			;	FORTH_RSP_NEXT 
1b99			; 
1b99			;	;inc hl	 ; go past current buffer pointer 
1b99			;	;inc hl 
1b99			;	;inc hl   ; and past if loop flag 
1b99			;		; TODO Need to set flag  
1b99			; 
1b99			;	 
1b99			;	 
1b99			;	ex de,hl	; malloc is dest 
1b99			;	ld hl, (os_tok_len) 
1b99			;;	pop bc 
1b99			;	ld c, l                
1b99			;	ld b,0 
1b99			;	ld hl, (os_tok_ptr) 
1b99			; 
1b99			;if DEBUG_FORTH_TOK 
1b99			;			DMARK "TKT" 
1b99			;	CALLMONITOR 
1b99			;endif 
1b99			; 
1b99			;	; do str cpy 
1b99			; 
1b99			;	ldir      ; copy byte in hl to de 
1b99			; 
1b99			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1b99			; 
1b99			;if DEBUG_FORTH_TOK 
1b99			; 
1b99			;			DMARK "TKY" 
1b99			;	CALLMONITOR 
1b99			;endif 
1b99			;	;ld a,0 
1b99			;	;ld a,FORTH_END_BUFFER 
1b99			;	ex de, hl 
1b99			;	;dec hl			 ; go back over the space delim at the end of word 
1b99			;	;ld (hl),a 
1b99			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1b99			;	ld a,FORTH_END_BUFFER 
1b99			;	ld (hl),a 
1b99			;	inc hl 
1b99			;	ld a,FORTH_END_BUFFER 
1b99			;	ld (hl),a 
1b99			; 
1b99			;	; init the malloc area data 
1b99			;	; set pc for in current area 
1b99			;	;ld hl, (os_tok_malloc) 
1b99			;	;inc hl 
1b99			;	;inc hl 
1b99			;	;inc hl 
1b99			;	;ex de,hl 
1b99			;	;ld hl, (os_tok_malloc) 
1b99			;	;ld (hl),e 
1b99			;	;inc hl 
1b99			;	;ld (hl),d 
1b99			; 
1b99			; 
1b99			;	ld hl,(os_tok_malloc) 
1b99			;if DEBUG_FORTH_PARSE_KEY 
1b99			;			DMARK "TKU" 
1b99			;	CALLMONITOR 
1b99			;endif 
1b99			; 
1b99			;	ret 
1b99			 
1b99			forthexec: 
1b99			 
1b99			; line exec: 
1b99			; forth parser 
1b99			 
1b99			; 
1b99			;       get current exec line on rsp 
1b99			 
1b99				FORTH_RSP_TOS 
1b99 cd d8 18			call macro_forth_rsp_tos 
1b9c				endm 
# End of macro FORTH_RSP_TOS
1b9c			 
1b9c			;       restore current pc - hl points to malloc of data 
1b9c			 
1b9c				;ld e, (hl) 
1b9c				;inc hl 
1b9c				;ld d, (hl) 
1b9c				;ex de,hl 
1b9c			 
1b9c			 
1b9c			exec1: 
1b9c 22 76 e6			ld (os_tok_ptr), hl 
1b9f			 
1b9f				; copy our PC to working vars  
1b9f 22 40 eb			ld (cli_ptr), hl 
1ba2 22 3e eb			ld (cli_origptr), hl 
1ba5			 
1ba5 7e				ld a,(hl) 
1ba6 fe 7f			cp FORTH_END_BUFFER 
1ba8 c8				ret z 
1ba9			 
1ba9				; skip any nulls 
1ba9			 
1ba9 fe 00			cp 0 
1bab 20 03			jr nz, .execword 
1bad 23				inc hl 
1bae 18 ec			jr exec1 
1bb0			 
1bb0			 
1bb0			.execword: 
1bb0			 
1bb0			 
1bb0			 
1bb0			if DEBUG_FORTH_PARSE_KEY 
1bb0						DMARK "KYQ" 
1bb0				CALLMONITOR 
1bb0			endif 
1bb0			;       while at start of word: 
1bb0			; get start of dict (in user area first) 
1bb0			 
1bb0 21 ed 57		ld hl, baseram 
1bb3			;ld hl, sysdict 
1bb3 22 42 eb		ld (cli_nextword),hl 
1bb6			;           match word at pc 
1bb6			;           exec word 
1bb6			;           or push to dsp 
1bb6			;           forward to next token 
1bb6			;           if line term pop rsp and exit 
1bb6			;        
1bb6			 
1bb6			if DEBUG_FORTH_PARSE_KEY 
1bb6						DMARK "KYq" 
1bb6				CALLMONITOR 
1bb6			endif 
1bb6			 
1bb6			; 
1bb6			; word comp 
1bb6			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1bb6			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1bb6			;    move to start of word  
1bb6			;    compare word to cli_token 
1bb6			 
1bb6			.execpnword:	; HL at start of a word in the dictionary to check 
1bb6			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1bb6			;	ld (cli_ptr), hl 
1bb6			 
1bb6 2a 42 eb			ld hl,(cli_nextword) 
1bb9			 
1bb9 cd 5c 1c			call forth_tok_next 
1bbc			; tok next start here 
1bbc			;	; TODO skip compiled symbol for now 
1bbc			;	inc hl 
1bbc			; 
1bbc			;	; save pointer to next word 
1bbc			; 
1bbc			;	; hl now points to the address of the next word pointer  
1bbc			;	ld e, (hl) 
1bbc			;	inc hl 
1bbc			;	ld d, (hl) 
1bbc			;	inc l 
1bbc			; 
1bbc			;	ex de,hl 
1bbc			;if DEBUG_FORTH_PARSE_NEXTWORD 
1bbc			;	push bc 
1bbc			;	ld bc, (cli_nextword) 
1bbc			;			DMARK "NXW" 
1bbc			;	CALLMONITOR 
1bbc			;	pop bc 
1bbc			;endif 
1bbc			; tok next end here 
1bbc 22 42 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1bbf eb				ex de, hl 
1bc0			 
1bc0			 
1bc0				; save the pointer of the current token - 1 to check against 
1bc0				 
1bc0 22 46 eb			ld (cli_token), hl   
1bc3				; TODO maybe remove below save if no debug 
1bc3				; save token string ptr for any debug later 
1bc3 23				inc hl  
1bc4 22 48 eb			ld (cli_origtoken), hl 
1bc7 2b				dec hl 
1bc8				; save pointer to the start of the next dictionay word 
1bc8 7e				ld a,(hl)   ; get string length 
1bc9 47				ld b,a 
1bca			.execpnwordinc:  
1bca 23				inc hl 
1bcb 10 fd			djnz .execpnwordinc 
1bcd 22 44 eb			ld (cli_execword), hl      ; save start of this words code 
1bd0			 
1bd0				; now check the word token against the string being parsed 
1bd0			 
1bd0 2a 46 eb			ld hl,(cli_token) 
1bd3 23				inc hl     ; skip string length (use zero term instead to end) 
1bd4 22 46 eb			ld (cli_token), hl 
1bd7			 
1bd7			if DEBUG_FORTH_PARSE_KEY 
1bd7						DMARK "KY2" 
1bd7			endif 
1bd7			if DEBUG_FORTH_PARSE_EXEC 
1bd7				; see if disabled 
1bd7			 
1bd7				ld a, (os_view_disable) 
1bd7				cp '*' 
1bd7				jr z, .skip 
1bd7			 
1bd7				push hl 
1bd7				push hl 
1bd7				call clear_display 
1bd7				ld de, .compword 
1bd7				ld a, display_row_1 
1bd7				call str_at_display 
1bd7				pop de 
1bd7				ld a, display_row_2 
1bd7				call str_at_display 
1bd7				ld hl,(cli_ptr) 
1bd7				ld a,(hl) 
1bd7			        ld hl, os_word_scratch 
1bd7				ld (hl),a 
1bd7				ld a,0 
1bd7				inc hl 
1bd7				ld (hl),a 	 
1bd7				ld de, os_word_scratch 
1bd7				ld a, display_row_2+10 
1bd7				call str_at_display 
1bd7				call update_display 
1bd7				ld a, 100 
1bd7				call aDelayInMS 
1bd7				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1bd7				call delay250ms 
1bd7				endif 
1bd7				pop hl 
1bd7			.skip:  
1bd7			endif	 
1bd7			.execpnchar:    ; compare char between token and string to parse 
1bd7			 
1bd7			if DEBUG_FORTH_PARSE_KEY 
1bd7						DMARK "Ky3" 
1bd7			endif 
1bd7			if DEBUG_FORTH_PARSE_EXEC 
1bd7				; see if disabled 
1bd7			 
1bd7				ld a, (os_view_disable) 
1bd7				cp '*' 
1bd7				jr z, .skip2 
1bd7			 
1bd7			;	call clear_display 
1bd7			ld hl,(cli_token) 
1bd7			ld a,(hl) 
1bd7			ld (os_word_scratch),a 
1bd7				ld hl,(cli_ptr) 
1bd7			ld a,(hl) 
1bd7				ld (os_word_scratch+1),a 
1bd7				ld a,0 
1bd7				ld (os_word_scratch+2),a 
1bd7				ld de,os_word_scratch 
1bd7				ld a,display_row_4 
1bd7				call str_at_display 
1bd7				call update_display 
1bd7			.skip2:  
1bd7			endif 
1bd7 2a 46 eb			ld hl,(cli_token) 
1bda 7e				ld a, (hl)	 ; char in word token 
1bdb 23				inc hl 		; move to next char 
1bdc 22 46 eb			ld (cli_token), hl ; and save it 
1bdf 47				ld b,a 
1be0			 
1be0 2a 40 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1be3 7e				ld a,(hl) 
1be4 23				inc hl 
1be5 22 40 eb			ld (cli_ptr), hl		; move to next char 
1be8 cd bd 0f			call toUpper 		; make sure the input string matches case 
1beb			 
1beb			if DEBUG_FORTH_PARSE 
1beb			endif 
1beb			 
1beb				; input stream end of token is a space so get rid of it 
1beb			 
1beb			;	cp ' ' 
1beb			;	jr nz, .pnskipspace 
1beb			; 
1beb			;	ld a, 0		; make same term as word token term 
1beb			; 
1beb			;.pnskipspace: 
1beb			 
1beb			if DEBUG_FORTH_PARSE_KEY 
1beb						DMARK "KY7" 
1beb			endif 
1beb b8				cp b 
1bec c2 02 1c			jp nz, .execpnskipword	 ; no match so move to next word 
1bef				 
1bef			;    if same 
1bef			;       scan for string terms 0 for token and 32 for input 
1bef			 
1bef				 
1bef			if DEBUG_FORTH_PARSE_KEY 
1bef						DMARK "KY8" 
1bef			endif 
1bef			 
1bef 80				add b			 
1bf0 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1bf2							; TODO need to make sure last word in zero term string is accounted for 
1bf2 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1bf4			 
1bf4			 
1bf4				; at end of both strings so both are exact match 
1bf4			 
1bf4			;       skip ptr for next word 
1bf4			 
1bf4 2a 40 eb			ld hl,(cli_ptr) 	; at input string term 
1bf7 23				inc hl			 ; at next char 
1bf8 22 40 eb			ld (cli_ptr), hl     ; save for next round of the parser 
1bfb 22 3e eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1bfe				 
1bfe				 
1bfe			if DEBUG_FORTH_PARSE_KEY 
1bfe						DMARK "KY3" 
1bfe			endif 
1bfe			 
1bfe			 
1bfe			 
1bfe			;       exec code block 
1bfe			if DEBUG_FORTH_JP 
1bfe				call clear_display 
1bfe				call update_display 
1bfe				call delay1s 
1bfe				ld hl, (cli_execword)     ; save for next check if no match on this word 
1bfe				ld a,h 
1bfe				ld hl, os_word_scratch 
1bfe				call hexout 
1bfe				ld hl, (cli_execword)     ; save for next check if no match on this word 
1bfe				ld a,l 
1bfe				ld hl, os_word_scratch+2 
1bfe				call hexout 
1bfe				ld hl, os_word_scratch+4 
1bfe				ld a,0 
1bfe				ld (hl),a 
1bfe				ld de,os_word_scratch 
1bfe				call str_at_display 
1bfe					ld a, display_row_2 
1bfe					call str_at_display 
1bfe				ld de, (cli_origtoken) 
1bfe				ld a, display_row_1+10 
1bfe					call str_at_display 
1bfe			 
1bfe				ld a,display_row_1 
1bfe				ld de, .foundword 
1bfe				ld a, display_row_3 
1bfe				call str_at_display 
1bfe				call update_display 
1bfe				call delay1s 
1bfe				call delay1s 
1bfe				call delay1s 
1bfe			endif 
1bfe			 
1bfe			if DEBUG_FORTH_PARSE_KEY 
1bfe						DMARK "KYj" 
1bfe			endif 
1bfe				; TODO save the word pointer in this exec 
1bfe			 
1bfe 2a 44 eb			ld hl,(cli_execword) 
1c01 e9				jp (hl) 
1c02			 
1c02			 
1c02			;    if not same 
1c02			;	scan for zero term 
1c02			;	get ptr for next word 
1c02			;	goto word comp 
1c02			 
1c02			.execpnskipword:	; get pointer to next word 
1c02 2a 42 eb			ld hl,(cli_nextword) 
1c05			 
1c05 7e				ld a,(hl) 
1c06 fe 00			cp WORD_SYS_END 
1c08			;	cp 0 
1c08 28 09			jr z, .execendofdict			 ; at end of words 
1c0a			 
1c0a			if DEBUG_FORTH_PARSE_KEY 
1c0a						DMARK "KY4" 
1c0a			endif 
1c0a			if DEBUG_FORTH_PARSE_EXEC 
1c0a			 
1c0a				; see if disabled 
1c0a			 
1c0a				ld a, (os_view_disable) 
1c0a				cp '*' 
1c0a				jr z, .noskip 
1c0a			 
1c0a			 
1c0a				ld de, .nowordfound 
1c0a				ld a, display_row_3 
1c0a				call str_at_display 
1c0a				call update_display 
1c0a				ld a, 100 
1c0a				call aDelayInMS 
1c0a				 
1c0a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c0a					call delay250ms 
1c0a				endif 
1c0a			.noskip:  
1c0a			 
1c0a			endif	 
1c0a			 
1c0a 2a 3e eb			ld hl,(cli_origptr) 
1c0d 22 40 eb			ld (cli_ptr),hl 
1c10			 
1c10			if DEBUG_FORTH_PARSE_KEY 
1c10						DMARK "KY5" 
1c10			endif 
1c10 c3 b6 1b			jp .execpnword			; else go to next word 
1c13			 
1c13			.execendofdict:  
1c13			 
1c13			if DEBUG_FORTH_PARSE_KEY 
1c13						DMARK "KYe" 
1c13			endif 
1c13			if DEBUG_FORTH_PARSE_EXEC 
1c13				; see if disabled 
1c13			 
1c13				ld a, (os_view_disable) 
1c13				cp '*' 
1c13				jr z, .ispskip 
1c13			 
1c13				call clear_display 
1c13				call update_display 
1c13				call delay1s 
1c13				ld de, (cli_origptr) 
1c13				ld a, display_row_1 
1c13				call str_at_display 
1c13				 
1c13				ld de, .enddict 
1c13				ld a, display_row_3 
1c13				call str_at_display 
1c13				call update_display 
1c13				ld a, 100 
1c13				call aDelayInMS 
1c13				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c13				call delay1s 
1c13				call delay1s 
1c13				call delay1s 
1c13				endif 
1c13			.ispskip:  
1c13				 
1c13			endif	 
1c13			 
1c13			 
1c13			 
1c13				; if the word is not a keyword then must be a literal so push it to stack 
1c13			 
1c13			; push token to stack to end of word 
1c13			 
1c13				STACKFRAME ON $1efe $2f9f 
1c13				if DEBUG_STACK_IMB 
1c13					if ON 
1c13						exx 
1c13						ld de, $1efe 
1c13						ld a, d 
1c13						ld hl, curframe 
1c13						call hexout 
1c13						ld a, e 
1c13						ld hl, curframe+2 
1c13						call hexout 
1c13						ld hl, $1efe 
1c13						push hl 
1c13						ld hl, $2f9f 
1c13						push hl 
1c13						exx 
1c13					endif 
1c13				endif 
1c13			endm 
# End of macro STACKFRAME
1c13			 
1c13 2a 76 e6		ld hl,(os_tok_ptr) 
1c16 cd 62 19		call forth_apush 
1c19			 
1c19				STACKFRAMECHK ON $1efe $2f9f 
1c19				if DEBUG_STACK_IMB 
1c19					if ON 
1c19						exx 
1c19						ld hl, $2f9f 
1c19						pop de   ; $2f9f 
1c19						call cmp16 
1c19						jr nz, .spnosame 
1c19						ld hl, $1efe 
1c19						pop de   ; $1efe 
1c19						call cmp16 
1c19						jr z, .spfrsame 
1c19						.spnosame: call showsperror 
1c19						.spfrsame: nop 
1c19						exx 
1c19					endif 
1c19				endif 
1c19			endm 
# End of macro STACKFRAMECHK
1c19			 
1c19			execnext: 
1c19			 
1c19			if DEBUG_FORTH_PARSE_KEY 
1c19						DMARK "KY>" 
1c19			endif 
1c19			; move past token to next word 
1c19			 
1c19 2a 76 e6		ld hl, (os_tok_ptr) 
1c1c 3e 00		ld a, 0 
1c1e 01 ff 00		ld bc, 255     ; input buffer size 
1c21 ed b1		cpir 
1c23			 
1c23			if DEBUG_FORTH_PARSE_KEY 
1c23						DMARK "KY!" 
1c23				CALLMONITOR 
1c23			endif	 
1c23			; TODO this might place hl on the null, so will need to forward on??? 
1c23			;inc hl   ; see if this gets onto the next item 
1c23			 
1c23			 
1c23			; TODO pass a pointer to the buffer to push 
1c23			; TODO call function to push 
1c23			 
1c23			; look for end of input 
1c23			 
1c23			;inc hl 
1c23			;ld a,(hl) 
1c23			;cp FORTH_END_BUFFER 
1c23			;ret z 
1c23			 
1c23			 
1c23 c3 9c 1b		jp exec1 
1c26			 
1c26			 
1c26			 
1c26			 
1c26			 
1c26			 
1c26			 
1c26			 
1c26			 
1c26			findnexttok: 
1c26			 
1c26				; hl is pointer to move 
1c26				; de is the token to locate 
1c26			 
1c26					if DEBUG_FORTH 
1c26						DMARK "NTK" 
1c26						CALLMONITOR 
1c26					endif 
1c26 d5				push de 
1c27			 
1c27			.fnt1:	 
1c27				; find first char of token to locate 
1c27			 
1c27 1a				ld a, (de) 
1c28 4f				ld c,a 
1c29 7e				ld a,(hl) 
1c2a cd bd 0f			call toUpper 
1c2d					if DEBUG_FORTH 
1c2d						DMARK "NT1" 
1c2d						CALLMONITOR 
1c2d					endif 
1c2d b9				cp c 
1c2e			 
1c2e 28 03			jr z, .fnt2cmpmorefirst	 
1c30			 
1c30				; first char not found move to next char 
1c30			 
1c30 23				inc hl 
1c31 18 f4			jr .fnt1 
1c33			 
1c33			.fnt2cmpmorefirst:	 
1c33				; first char of token found.  
1c33			 
1c33 e5				push hl     ; save start of token just in case it is the right one 
1c34 d9				exx 
1c35 e1				pop hl        ; save it to hl' 
1c36 d9				exx 
1c37			 
1c37			 
1c37			.fnt2cmpmore:	 
1c37				; compare the rest 
1c37				 
1c37 23				inc hl 
1c38 13				inc de 
1c39				 
1c39 1a				ld a, (de) 
1c3a 4f				ld c,a 
1c3b 7e				ld a,(hl) 
1c3c cd bd 0f			call toUpper 
1c3f			 
1c3f					if DEBUG_FORTH 
1c3f						DMARK "NT2" 
1c3f						CALLMONITOR 
1c3f					endif 
1c3f				; c has the token to find char 
1c3f				; a has the mem to scan char 
1c3f			 
1c3f b9				cp c 
1c40 28 04			jr z,.fntmatch1 
1c42			 
1c42				; they are not the same 
1c42			 
1c42					if DEBUG_FORTH 
1c42						DMARK "NT3" 
1c42						CALLMONITOR 
1c42					endif 
1c42 d1				pop de	; reset de token to look for 
1c43 d5				push de 
1c44 18 e1			jr .fnt1 
1c46				 
1c46			.fntmatch1: 
1c46			 
1c46				; is the same char a null which means we might have a full hit? 
1c46					if DEBUG_FORTH 
1c46						DMARK "NT4" 
1c46						CALLMONITOR 
1c46					endif 
1c46			 
1c46 fe 00			cp 0 
1c48 28 0b			jr z, .fntmatchyes 
1c4a			 
1c4a				; are we at the end of the token to find? 
1c4a			 
1c4a					if DEBUG_FORTH 
1c4a						DMARK "NT5" 
1c4a						CALLMONITOR 
1c4a					endif 
1c4a 3e 00			ld a, 0 
1c4c b9				cp c 
1c4d			 
1c4d c2 37 1c			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1c50			 
1c50					if DEBUG_FORTH 
1c50						DMARK "NT6" 
1c50						CALLMONITOR 
1c50					endif 
1c50				; token to find is exhusted but no match to stream 
1c50			 
1c50				; restore tok pointer and continue on 
1c50 d1				pop de 
1c51 d5				push de 
1c52 c3 27 1c			jp .fnt1 
1c55			 
1c55			 
1c55			.fntmatchyes: 
1c55			 
1c55				; hl now contains the end of the found token 
1c55			 
1c55				; get rid of saved token pointer to find 
1c55			 
1c55 d1				pop de 
1c56			 
1c56					if DEBUG_FORTH 
1c56						DMARK "NT9" 
1c56						CALLMONITOR 
1c56					endif 
1c56			 
1c56				; hl will be on the null term so forward on 
1c56			 
1c56				; get back the saved start of the token 
1c56			 
1c56 d9				exx 
1c57 e5				push hl     ; save start of token just in case it is the right one 
1c58 d9				exx 
1c59 e1				pop hl        ; save it to hl 
1c5a			 
1c5a c9				ret 
1c5b			 
1c5b			 
1c5b			; LIST needs to find a specific token   
1c5b			; FORGET needs to find a spefici token 
1c5b			 
1c5b			; SAVE needs to find all tokens by flag 
1c5b			; WORDS just needs to scan through all  by flag 
1c5b			; UWORDS needs to scan through all by flag 
1c5b			 
1c5b			 
1c5b			; given hl as pointer to start of dict look up string 
1c5b			; return hl as pointer to start of word block 
1c5b			; or 0 if not found 
1c5b			 
1c5b			forth_find_tok: 
1c5b c9				ret 
1c5c			 
1c5c			; given hl as pointer to dict structure 
1c5c			; move to the next dict block structure 
1c5c			 
1c5c			forth_tok_next: 
1c5c				; hl now points to the address of the next word pointer  
1c5c				; TODO skip compiled symbol for now 
1c5c			;	push de 
1c5c 23				inc hl 
1c5d 5e				ld e, (hl) 
1c5e 23				inc hl 
1c5f 56				ld d, (hl) 
1c60 23				inc hl 
1c61			 
1c61 eb				ex de,hl 
1c62			if DEBUG_FORTH_PARSE_NEXTWORD 
1c62				push bc 
1c62				ld bc, (cli_nextword) 
1c62						DMARK "NXW" 
1c62				CALLMONITOR 
1c62				pop bc 
1c62			endif 
1c62			;	pop de	 
1c62 c9				ret 
1c63			 
1c63			 
1c63			 
1c63			; eof 
# End of file forth_parserv5.asm
1c63				include "forth_wordsv4.asm" 
1c63			 
1c63			; the core word dictionary v4 
1c63			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1c63			 
1c63			; this is a linked list for each of the system words used 
1c63			; user defined words will follow the same format but will be in ram 
1c63			 
1c63			 
1c63			; 
1c63			; 
1c63			; define linked list: 
1c63			; 
1c63			; 1. compiled byte op code 
1c63			; 2. len of text word 
1c63			; 3. text word 
1c63			; 4. ptr to next dictionary word 
1c63			; 5. asm, calls etc for the word 
1c63			; 
1c63			;  if 1 == 0 then last word in dict  
1c63			;   
1c63			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1c63			;  
1c63			;  
1c63			; create basic standard set of words 
1c63			; 
1c63			;  
1c63			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1c63			; 2DUP 2DROP 2SWAP  
1c63			; @ C@ - get byte  
1c63			; ! C! - store byte 
1c63			; 0< true if less than zero 
1c63			; 0= true if zero 
1c63			; < >  
1c63			; = true if same 
1c63			; variables 
1c63			 
1c63			 
1c63			; Hardware specific words I may need 
1c63			; 
1c63			; IN OUT  
1c63			; calls to key util functions 
1c63			; calls to hardward abstraction stuff 
1c63			; easy control of frame buffers and lcd i/o 
1c63			; keyboard  
1c63			 
1c63			 
1c63			;DICT: macro 
1c63			; op_code, len, word, next 
1c63			;    word: 
1c63			;    db op_code 
1c63			;    ds word zero term 
1c63			;    dw next 
1c63			;    endm 
1c63			 
1c63			 
1c63			 
1c63			 
1c63			; op code 1 is a flag for user define words which are to be handled differently 
1c63			 
1c63			 
1c63			; 
1c63			; 
1c63			;    TODO on entry to a word this should be the expected environment 
1c63			;    hl - tos value if number then held, if string this is the ptr 
1c63			;    de -  
1c63			 
1c63			 
1c63			; opcode ranges 
1c63			; 0 - end of word dict 
1c63			; 255 - user define words 
1c63			 
1c63			sysdict: 
1c63			include "forth_opcodes.asm" 
1c63			; op codes for forth keywords 
1c63			; free to use code 0  
1c63				OPCODE_HEAP: equ  1 
1c63				OPCODE_EXEC: equ 2 
1c63				OPCODE_DUP: equ 3 
1c63				OPCODE_SWAP: equ 4 
1c63				OPCODE_COLN: equ 5 
1c63				OPCODE_SCOLN: equ 6 
1c63				OPCODE_DROP: equ 7 
1c63				OPCODE_DUP2: equ 8 
1c63				OPCODE_DROP2: equ 9 
1c63				OPCODE_SWAP2: equ 10 
1c63				OPCODE_AT: equ 11 
1c63				OPCODE_CAT: equ 12 
1c63				OPCODE_BANG: equ 13 
1c63				OPCODE_CBANG: equ 14 
1c63				OPCODE_SCALL: equ 15 
1c63				OPCODE_DEPTH: equ 16 
1c63				OPCODE_OVER: equ 17 
1c63				OPCODE_PAUSE: equ 18 
1c63				OPCODE_PAUSES: equ 19 
1c63				OPCODE_ROT: equ 20 
1c63			;free to reuse	OPCODE_WORDS: equ 21 
1c63			        OPCODE_NOT: equ 21 
1c63				OPCODE_UWORDS: equ 22 
1c63				OPCODE_BP: equ 23 
1c63				OPCODE_MONITOR: equ 24  
1c63				OPCODE_MALLOC: equ 25 
1c63				OPCODE_FREE: equ 26 
1c63				OPCODE_LIST: equ 27 
1c63				OPCODE_FORGET: equ 28 
1c63				OPCODE_NOP: equ 29 
1c63				OPCODE_COMO: equ 30 
1c63				OPCODE_COMC: equ 31 
1c63			;free to reuse	OPCODE_ENDCORE: equ 32 
1c63				OPCODE_AFTERSOUND: equ 33 
1c63				OPCODE_GP2: equ 34 
1c63				OPCODE_GP3: equ 35 
1c63				OPCODE_GP4: equ 36 
1c63				OPCODE_SIN: equ 37 
1c63				OPCODE_SOUT: equ 38 
1c63				OPCODE_SPIO: equ 39 
1c63				OPCODE_SPICEH: equ 40 
1c63				OPCODE_SPIOb: equ 41 
1c63				OPCODE_SPII: equ 42 
1c63				OPCODE_SESEL: equ 43 
1c63				OPCODE_CARTDEV: equ 44 
1c63			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1c63				OPCODE_FB: equ 46 
1c63				OPCODE_EMIT: equ 47 
1c63				OPCODE_DOTH: equ 48 
1c63				OPCODE_DOTF: equ 49 
1c63				OPCODE_DOT: equ 50 
1c63				OPCODE_CLS: equ 51 
1c63				OPCODE_DRAW: equ 52 
1c63				OPCODE_DUMP: equ 53 
1c63				OPCODE_CDUMP: equ 54 
1c63				OPCODE_DAT: equ 55 
1c63				OPCODE_HOME: equ 56 
1c63				OPCODE_SPACE: equ 57 
1c63				OPCODE_SPACES: equ 58 
1c63				OPCODE_SCROLL: equ 59 
1c63				OPCODE_ATQ: equ 60 
1c63				OPCODE_AUTODSP: equ 61 
1c63				OPCODE_MENU: equ 62 
1c63			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1c63				OPCODE_THEN: equ 64 
1c63				OPCODE_ELSE: equ 65 
1c63				OPCODE_DO: equ 66 
1c63				OPCODE_LOOP: equ 67 
1c63				OPCODE_I: equ 68 
1c63				OPCODE_DLOOP: equ 69  
1c63				OPCODE_REPEAT: equ 70  
1c63				OPCODE_UNTIL: equ 71 
1c63				OPCODE_ENDFLOW: equ 72 
1c63				OPCODE_WAITK: equ 73 
1c63				OPCODE_ACCEPT: equ 74 
1c63				OPCODE_EDIT: equ 75 
1c63			;free to reuse	OPCODE_ENDKEY: equ 76 
1c63				OPCODE_LZERO: equ 77 
1c63				OPCODE_TZERO: equ 78 
1c63				OPCODE_LESS: equ 79 
1c63				OPCODE_GT: equ 80 
1c63				OPCODE_EQUAL: equ 81  
1c63			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1c63				OPCODE_NEG: equ 83 
1c63				OPCODE_DIV: equ 84 
1c63				OPCODE_MUL: equ 85 
1c63				OPCODE_MIN: equ 86 
1c63				OPCODE_MAX: equ 87 
1c63				OPCODE_RND16: equ 88 
1c63				OPCODE_RND8: equ 89 
1c63				OPCODE_RND: equ 90 
1c63			;free to reuse	OPCODE_ENDMATHS: equ 91  
1c63				OPCODE_BYNAME: equ 92 
1c63				OPCODE_DIR: equ 93 
1c63				OPCODE_SAVE: equ 94 
1c63				OPCODE_LOAD: equ 95 
1c63				OPCODE_BSAVE: equ 96 
1c63				OPCODE_BLOAD: equ 97 
1c63				OPCODE_SEO: equ 98  
1c63				OPCODE_SEI: equ 99 
1c63				OPCODE_SFREE: equ 100 
1c63				OPCODE_SIZE: equ 101 
1c63				OPCODE_CREATE: equ 102 
1c63				OPCODE_APPEND: equ 103 
1c63				OPCODE_SDEL: equ 104 
1c63				OPCODE_OPEN: equ 105 
1c63				OPCODE_READ: equ 106 
1c63				OPCODE_EOF: equ 106 
1c63				OPCODE_FORMAT: equ 107 
1c63				OPCODE_LABEL: equ 108 
1c63				OPCODE_LABELS: equ 109 
1c63			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1c63				OPCODE_UPPER: equ 111 
1c63				OPCODE_LOWER: equ 112 
1c63				OPCODE_SUBSTR: equ 113 
1c63				OPCODE_LEFT: equ 114 
1c63				OPCODE_RIGHT: equ 115 
1c63				OPCODE_STR2NUM: equ 116 
1c63				OPCODE_NUM2STR: equ 117 
1c63				OPCODE_CONCAT: equ 118 
1c63				OPCODE_FIND: equ 119 
1c63				OPCODE_LEN: equ 120 
1c63				OPCODE_CHAR: equ 121 
1c63			; free to reuse	OPCODE_STRLEN: equ 122 
1c63			; free to reuse	OPCODE_ENDSTR: equ 123 
1c63				OPCODE_V0S: equ 124 
1c63				OPCODE_V0Q: equ 125 
1c63				OPCODE_V1S: equ 126 
1c63				OPCODE_V1Q: equ 127 
1c63				OPCODE_V2S: equ 128 
1c63				OPCODE_V2Q: equ 129 
1c63				OPCODE_V3S: equ 130 
1c63				OPCODE_V3Q: equ 131 
1c63			;free to reuse	OPCODE_END: equ 132 
1c63				OPCODE_ZDUP: equ 133 
1c63			 
1c63			; eof 
# End of file forth_opcodes.asm
1c63			 
1c63			include "forth_words_core.asm" 
1c63			 
1c63			; | ## Core Words 
1c63			 
1c63			;if MALLOC_4 
1c63			 
1c63			.HEAP: 
1c63				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1c63 15				db WORD_SYS_CORE+OPCODE_HEAP             
1c64 a2 1c			dw .EXEC            
1c66 05				db 4 + 1 
1c67 .. 00			db "HEAP",0              
1c6c				endm 
# End of macro CWHEAD
1c6c			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1c6c			; | | u1 - Current number of bytes in the heap 
1c6c			; | | u2 - Remaining bytes left on the heap 
1c6c			; | |  
1c6c			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1c6c			 
1c6c			 
1c6c					if DEBUG_FORTH_WORDS_KEY 
1c6c						DMARK "HEP" 
1c6c f5				push af  
1c6d 3a 81 1c			ld a, (.dmark)  
1c70 32 7a ee			ld (debug_mark),a  
1c73 3a 82 1c			ld a, (.dmark+1)  
1c76 32 7b ee			ld (debug_mark+1),a  
1c79 3a 83 1c			ld a, (.dmark+2)  
1c7c 32 7c ee			ld (debug_mark+2),a  
1c7f 18 03			jr .pastdmark  
1c81 ..			.dmark: db "HEP"  
1c84 f1			.pastdmark: pop af  
1c85			endm  
# End of macro DMARK
1c85						CALLMONITOR 
1c85 cd 80 13			call break_point_state  
1c88				endm  
# End of macro CALLMONITOR
1c88					endif 
1c88 2a f7 57				ld hl, (free_list )      
1c8b 11 fc 57				ld de, heap_start 
1c8e			 
1c8e ed 52				sbc hl, de  
1c90			 
1c90 cd 1a 19				call forth_push_numhl 
1c93			 
1c93			 
1c93 ed 5b f7 57			ld de, (free_list )      
1c97 21 69 e3				ld hl, heap_end 
1c9a			 
1c9a ed 52				sbc hl, de 
1c9c			 
1c9c cd 1a 19				call forth_push_numhl 
1c9f					 
1c9f			 
1c9f					 
1c9f			 
1c9f			 
1c9f			 
1c9f					NEXTW 
1c9f c3 0b 1b			jp macro_next 
1ca2				endm 
# End of macro NEXTW
1ca2			;endif 
1ca2			 
1ca2			.EXEC: 
1ca2				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1ca2 16				db WORD_SYS_CORE+OPCODE_EXEC             
1ca3 3e 1d			dw .STKEXEC            
1ca5 05				db 4 + 1 
1ca6 .. 00			db "EXEC",0              
1cab				endm 
# End of macro CWHEAD
1cab			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1cab			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1cab			; | | 
1cab			; | |   
1cab				STACKFRAME OFF $5efe $5f9f 
1cab				if DEBUG_STACK_IMB 
1cab					if OFF 
1cab						exx 
1cab						ld de, $5efe 
1cab						ld a, d 
1cab						ld hl, curframe 
1cab						call hexout 
1cab						ld a, e 
1cab						ld hl, curframe+2 
1cab						call hexout 
1cab						ld hl, $5efe 
1cab						push hl 
1cab						ld hl, $5f9f 
1cab						push hl 
1cab						exx 
1cab					endif 
1cab				endif 
1cab			endm 
# End of macro STACKFRAME
1cab			 
1cab					if DEBUG_FORTH_WORDS_KEY 
1cab						DMARK "EXE" 
1cab f5				push af  
1cac 3a c0 1c			ld a, (.dmark)  
1caf 32 7a ee			ld (debug_mark),a  
1cb2 3a c1 1c			ld a, (.dmark+1)  
1cb5 32 7b ee			ld (debug_mark+1),a  
1cb8 3a c2 1c			ld a, (.dmark+2)  
1cbb 32 7c ee			ld (debug_mark+2),a  
1cbe 18 03			jr .pastdmark  
1cc0 ..			.dmark: db "EXE"  
1cc3 f1			.pastdmark: pop af  
1cc4			endm  
# End of macro DMARK
1cc4						CALLMONITOR 
1cc4 cd 80 13			call break_point_state  
1cc7				endm  
# End of macro CALLMONITOR
1cc7					endif 
1cc7			 
1cc7				FORTH_DSP_VALUEHL 
1cc7 cd b5 19			call macro_dsp_valuehl 
1cca				endm 
# End of macro FORTH_DSP_VALUEHL
1cca			 
1cca				FORTH_DSP_POP 
1cca cd 51 1a			call macro_forth_dsp_pop 
1ccd				endm 
# End of macro FORTH_DSP_POP
1ccd			 
1ccd					if DEBUG_FORTH_WORDS 
1ccd						DMARK "EX1" 
1ccd f5				push af  
1cce 3a e2 1c			ld a, (.dmark)  
1cd1 32 7a ee			ld (debug_mark),a  
1cd4 3a e3 1c			ld a, (.dmark+1)  
1cd7 32 7b ee			ld (debug_mark+1),a  
1cda 3a e4 1c			ld a, (.dmark+2)  
1cdd 32 7c ee			ld (debug_mark+2),a  
1ce0 18 03			jr .pastdmark  
1ce2 ..			.dmark: db "EX1"  
1ce5 f1			.pastdmark: pop af  
1ce6			endm  
# End of macro DMARK
1ce6						CALLMONITOR 
1ce6 cd 80 13			call break_point_state  
1ce9				endm  
# End of macro CALLMONITOR
1ce9					endif 
1ce9			;	ld e,(hl) 
1ce9			;	inc hl 
1ce9			;	ld d,(hl) 
1ce9			;	ex de,hl 
1ce9			 
1ce9			;		if DEBUG_FORTH_WORDS 
1ce9			;			DMARK "EX2" 
1ce9			;			CALLMONITOR 
1ce9			;		endif 
1ce9 e5				push hl 
1cea			 
1cea				;ld a, 0 
1cea				;ld a, FORTH_END_BUFFER 
1cea cd c6 0f			call strlenz 
1ced 23				inc hl   ; include zero term to copy 
1cee 23				inc hl   ; include term 
1cef 23				inc hl   ; include term 
1cf0 06 00			ld b,0 
1cf2 4d				ld c,l 
1cf3 e1				pop hl 
1cf4 11 74 e4			ld de, execscratch 
1cf7					if DEBUG_FORTH_WORDS 
1cf7						DMARK "EX3" 
1cf7 f5				push af  
1cf8 3a 0c 1d			ld a, (.dmark)  
1cfb 32 7a ee			ld (debug_mark),a  
1cfe 3a 0d 1d			ld a, (.dmark+1)  
1d01 32 7b ee			ld (debug_mark+1),a  
1d04 3a 0e 1d			ld a, (.dmark+2)  
1d07 32 7c ee			ld (debug_mark+2),a  
1d0a 18 03			jr .pastdmark  
1d0c ..			.dmark: db "EX3"  
1d0f f1			.pastdmark: pop af  
1d10			endm  
# End of macro DMARK
1d10						CALLMONITOR 
1d10 cd 80 13			call break_point_state  
1d13				endm  
# End of macro CALLMONITOR
1d13					endif 
1d13 ed b0			ldir 
1d15			 
1d15			 
1d15 21 74 e4			ld hl, execscratch 
1d18			 
1d18					if DEBUG_FORTH_WORDS 
1d18						DMARK "EXe" 
1d18 f5				push af  
1d19 3a 2d 1d			ld a, (.dmark)  
1d1c 32 7a ee			ld (debug_mark),a  
1d1f 3a 2e 1d			ld a, (.dmark+1)  
1d22 32 7b ee			ld (debug_mark+1),a  
1d25 3a 2f 1d			ld a, (.dmark+2)  
1d28 32 7c ee			ld (debug_mark+2),a  
1d2b 18 03			jr .pastdmark  
1d2d ..			.dmark: db "EXe"  
1d30 f1			.pastdmark: pop af  
1d31			endm  
# End of macro DMARK
1d31						CALLMONITOR 
1d31 cd 80 13			call break_point_state  
1d34				endm  
# End of macro CALLMONITOR
1d34					endif 
1d34			 
1d34 cd 59 1b			call forthparse 
1d37 cd 99 1b			call forthexec 
1d3a			;	call forthexec_cleanup 
1d3a			;	call forthparse 
1d3a			;	call forthexec 
1d3a			 
1d3a				STACKFRAMECHK OFF $5efe $5f9f 
1d3a				if DEBUG_STACK_IMB 
1d3a					if OFF 
1d3a						exx 
1d3a						ld hl, $5f9f 
1d3a						pop de   ; $5f9f 
1d3a						call cmp16 
1d3a						jr nz, .spnosame 
1d3a						ld hl, $5efe 
1d3a						pop de   ; $5efe 
1d3a						call cmp16 
1d3a						jr z, .spfrsame 
1d3a						.spnosame: call showsperror 
1d3a						.spfrsame: nop 
1d3a						exx 
1d3a					endif 
1d3a				endif 
1d3a			endm 
# End of macro STACKFRAMECHK
1d3a			 
1d3a				; an immediate word so no need to process any more words 
1d3a c9				ret 
1d3b				NEXTW 
1d3b c3 0b 1b			jp macro_next 
1d3e				endm 
# End of macro NEXTW
1d3e			 
1d3e			; dead code - old version  
1d3e			;	FORTH_RSP_NEXT 
1d3e			 
1d3e			;  
1d3e			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d3e			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d3e			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d3e			;	push hl 
1d3e			;	push de 
1d3e			;	push bc 
1d3e			; 
1d3e			; 
1d3e			;		if DEBUG_FORTH_WORDS_KEY 
1d3e			;			DMARK "EXR" 
1d3e			;			CALLMONITOR 
1d3e			;		endif 
1d3e			; 
1d3e			; 
1d3e			; 
1d3e			;	;v5 FORTH_DSP_VALUE 
1d3e			;	FORTH_DSP_VALUEHL 
1d3e			; 
1d3e			;	; TODO do string type checks 
1d3e			; 
1d3e			;;v5	inc hl   ; skip type 
1d3e			; 
1d3e			;	push hl  ; source code  
1d3e			;		if DEBUG_FORTH_WORDS 
1d3e			;			DMARK "EX1" 
1d3e			;			CALLMONITOR 
1d3e			;		endif 
1d3e			;	ld a, 0 
1d3e			;	call strlent 
1d3e			; 
1d3e			;	inc hl 
1d3e			;	inc hl 
1d3e			;	inc hl 
1d3e			;	inc hl 
1d3e			; 
1d3e			;	push hl    ; size 
1d3e			; 
1d3e			;		if DEBUG_FORTH_WORDS 
1d3e			;			DMARK "EX2" 
1d3e			;			CALLMONITOR 
1d3e			;		endif 
1d3e			;	call malloc 
1d3e			; 
1d3e			;	ex de, hl    ; de now contains malloc area 
1d3e			;	pop bc   	; get byte count 
1d3e			;	pop hl      ; get string to copy 
1d3e			; 
1d3e			;	push de     ; save malloc for free later 
1d3e			; 
1d3e			;		if DEBUG_FORTH_WORDS 
1d3e			;			DMARK "EX3" 
1d3e			;			CALLMONITOR 
1d3e			;		endif 
1d3e			;	ldir       ; duplicate string 
1d3e			; 
1d3e			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1d3e			;	 
1d3e			;	; TODO fix the parse would be better than this...  
1d3e			;	ex de, hl 
1d3e			;	dec hl 
1d3e			;	ld a, 0 
1d3e			;	ld (hl), a 
1d3e			;	dec hl 
1d3e			;	ld a, ' ' 
1d3e			;	ld (hl), a 
1d3e			;	dec hl 
1d3e			;	ld (hl), a 
1d3e			; 
1d3e			;	dec hl 
1d3e			;	ld (hl), a 
1d3e			; 
1d3e			; 
1d3e			;	FORTH_DSP_POP  
1d3e			; 
1d3e			;	pop hl     
1d3e			;	push hl    ; save malloc area 
1d3e			; 
1d3e			;		if DEBUG_FORTH_WORDS 
1d3e			;			DMARK "EX4" 
1d3e			;			CALLMONITOR 
1d3e			;		endif 
1d3e			; 
1d3e			;	call forthparse 
1d3e			;	call forthexec 
1d3e			;	 
1d3e			;	pop hl 
1d3e			;	if DEBUG_FORTH_WORDS 
1d3e			;		DMARK "EX5" 
1d3e			;		CALLMONITOR 
1d3e			;	endif 
1d3e			; 
1d3e			;	if FORTH_ENABLE_FREE 
1d3e			;	call free 
1d3e			;	endif 
1d3e			; 
1d3e			;	if DEBUG_FORTH_WORDS 
1d3e			;		DMARK "EX6" 
1d3e			;		CALLMONITOR 
1d3e			;	endif 
1d3e			; 
1d3e			;	pop bc 
1d3e			;	pop de 
1d3e			;	pop hl 
1d3e			;;	FORTH_RSP_POP	  
1d3e			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1d3e			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1d3e			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1d3e			; 
1d3e			;	if DEBUG_FORTH_WORDS 
1d3e			;		DMARK "EX7" 
1d3e			;		CALLMONITOR 
1d3e			;	endif 
1d3e			;	NEXTW 
1d3e			 
1d3e			.STKEXEC: 
1d3e				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1d3e 3f				db WORD_SYS_CORE+43             
1d3f 86 1e			dw .ZDUP            
1d41 08				db 7 + 1 
1d42 .. 00			db "STKEXEC",0              
1d4a				endm 
# End of macro CWHEAD
1d4a			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1d4a			 
1d4a			 
1d4a					if DEBUG_FORTH_WORDS_KEY 
1d4a						DMARK "STX" 
1d4a f5				push af  
1d4b 3a 5f 1d			ld a, (.dmark)  
1d4e 32 7a ee			ld (debug_mark),a  
1d51 3a 60 1d			ld a, (.dmark+1)  
1d54 32 7b ee			ld (debug_mark+1),a  
1d57 3a 61 1d			ld a, (.dmark+2)  
1d5a 32 7c ee			ld (debug_mark+2),a  
1d5d 18 03			jr .pastdmark  
1d5f ..			.dmark: db "STX"  
1d62 f1			.pastdmark: pop af  
1d63			endm  
# End of macro DMARK
1d63						CALLMONITOR 
1d63 cd 80 13			call break_point_state  
1d66				endm  
# End of macro CALLMONITOR
1d66					endif 
1d66			 
1d66				FORTH_DSP_VALUEHL 
1d66 cd b5 19			call macro_dsp_valuehl 
1d69				endm 
# End of macro FORTH_DSP_VALUEHL
1d69			 
1d69 22 63 eb			ld (store_tmp1), hl    ; count 
1d6c			 
1d6c				FORTH_DSP_POP 
1d6c cd 51 1a			call macro_forth_dsp_pop 
1d6f				endm 
# End of macro FORTH_DSP_POP
1d6f			.stkexec1: 
1d6f 2a 63 eb			ld hl, (store_tmp1)   ; count 
1d72 3e 00			ld a, 0 
1d74 bd				cp l 
1d75 c8				ret z 
1d76			 
1d76 2b				dec hl 
1d77 22 63 eb			ld (store_tmp1), hl    ; count 
1d7a				 
1d7a				FORTH_DSP_VALUEHL 
1d7a cd b5 19			call macro_dsp_valuehl 
1d7d				endm 
# End of macro FORTH_DSP_VALUEHL
1d7d e5				push hl 
1d7e				 
1d7e					if DEBUG_FORTH_WORDS 
1d7e						DMARK "EXp" 
1d7e f5				push af  
1d7f 3a 93 1d			ld a, (.dmark)  
1d82 32 7a ee			ld (debug_mark),a  
1d85 3a 94 1d			ld a, (.dmark+1)  
1d88 32 7b ee			ld (debug_mark+1),a  
1d8b 3a 95 1d			ld a, (.dmark+2)  
1d8e 32 7c ee			ld (debug_mark+2),a  
1d91 18 03			jr .pastdmark  
1d93 ..			.dmark: db "EXp"  
1d96 f1			.pastdmark: pop af  
1d97			endm  
# End of macro DMARK
1d97						CALLMONITOR 
1d97 cd 80 13			call break_point_state  
1d9a				endm  
# End of macro CALLMONITOR
1d9a					endif 
1d9a				FORTH_DSP_POP 
1d9a cd 51 1a			call macro_forth_dsp_pop 
1d9d				endm 
# End of macro FORTH_DSP_POP
1d9d			 
1d9d cd c6 0f			call strlenz 
1da0 23				inc hl   ; include zero term to copy 
1da1 23				inc hl   ; include zero term to copy 
1da2 23				inc hl   ; include zero term to copy 
1da3 06 00			ld b,0 
1da5 4d				ld c,l 
1da6 e1				pop hl 
1da7 11 74 e4			ld de, execscratch 
1daa					if DEBUG_FORTH_WORDS 
1daa						DMARK "EX3" 
1daa f5				push af  
1dab 3a bf 1d			ld a, (.dmark)  
1dae 32 7a ee			ld (debug_mark),a  
1db1 3a c0 1d			ld a, (.dmark+1)  
1db4 32 7b ee			ld (debug_mark+1),a  
1db7 3a c1 1d			ld a, (.dmark+2)  
1dba 32 7c ee			ld (debug_mark+2),a  
1dbd 18 03			jr .pastdmark  
1dbf ..			.dmark: db "EX3"  
1dc2 f1			.pastdmark: pop af  
1dc3			endm  
# End of macro DMARK
1dc3						CALLMONITOR 
1dc3 cd 80 13			call break_point_state  
1dc6				endm  
# End of macro CALLMONITOR
1dc6					endif 
1dc6 ed b0			ldir 
1dc8			 
1dc8			 
1dc8 21 74 e4			ld hl, execscratch 
1dcb			 
1dcb					if DEBUG_FORTH_WORDS 
1dcb						DMARK "EXP" 
1dcb f5				push af  
1dcc 3a e0 1d			ld a, (.dmark)  
1dcf 32 7a ee			ld (debug_mark),a  
1dd2 3a e1 1d			ld a, (.dmark+1)  
1dd5 32 7b ee			ld (debug_mark+1),a  
1dd8 3a e2 1d			ld a, (.dmark+2)  
1ddb 32 7c ee			ld (debug_mark+2),a  
1dde 18 03			jr .pastdmark  
1de0 ..			.dmark: db "EXP"  
1de3 f1			.pastdmark: pop af  
1de4			endm  
# End of macro DMARK
1de4						CALLMONITOR 
1de4 cd 80 13			call break_point_state  
1de7				endm  
# End of macro CALLMONITOR
1de7					endif 
1de7			 
1de7 cd 59 1b			call forthparse 
1dea 21 74 e4			ld hl, execscratch 
1ded					if DEBUG_FORTH_WORDS 
1ded						DMARK "EXx" 
1ded f5				push af  
1dee 3a 02 1e			ld a, (.dmark)  
1df1 32 7a ee			ld (debug_mark),a  
1df4 3a 03 1e			ld a, (.dmark+1)  
1df7 32 7b ee			ld (debug_mark+1),a  
1dfa 3a 04 1e			ld a, (.dmark+2)  
1dfd 32 7c ee			ld (debug_mark+2),a  
1e00 18 03			jr .pastdmark  
1e02 ..			.dmark: db "EXx"  
1e05 f1			.pastdmark: pop af  
1e06			endm  
# End of macro DMARK
1e06						CALLMONITOR 
1e06 cd 80 13			call break_point_state  
1e09				endm  
# End of macro CALLMONITOR
1e09					endif 
1e09 cd 99 1b			call forthexec 
1e0c			 
1e0c c3 6f 1d			jp .stkexec1 
1e0f			 
1e0f c9				ret 
1e10			 
1e10			 
1e10			.DUP: 
1e10				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1e10 17				db WORD_SYS_CORE+OPCODE_DUP             
1e11 86 1e			dw .ZDUP            
1e13 04				db 3 + 1 
1e14 .. 00			db "DUP",0              
1e18				endm 
# End of macro CWHEAD
1e18			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1e18			 
1e18					if DEBUG_FORTH_WORDS_KEY 
1e18						DMARK "DUP" 
1e18 f5				push af  
1e19 3a 2d 1e			ld a, (.dmark)  
1e1c 32 7a ee			ld (debug_mark),a  
1e1f 3a 2e 1e			ld a, (.dmark+1)  
1e22 32 7b ee			ld (debug_mark+1),a  
1e25 3a 2f 1e			ld a, (.dmark+2)  
1e28 32 7c ee			ld (debug_mark+2),a  
1e2b 18 03			jr .pastdmark  
1e2d ..			.dmark: db "DUP"  
1e30 f1			.pastdmark: pop af  
1e31			endm  
# End of macro DMARK
1e31						CALLMONITOR 
1e31 cd 80 13			call break_point_state  
1e34				endm  
# End of macro CALLMONITOR
1e34					endif 
1e34			 
1e34					FORTH_DSP 
1e34 cd 9a 19			call macro_forth_dsp 
1e37				endm 
# End of macro FORTH_DSP
1e37			 
1e37 7e					ld a, (HL) 
1e38 fe 01				cp DS_TYPE_STR 
1e3a 20 25				jr nz, .dupinum 
1e3c			 
1e3c					; push another string 
1e3c			 
1e3c					FORTH_DSP_VALUEHL     		 
1e3c cd b5 19			call macro_dsp_valuehl 
1e3f				endm 
# End of macro FORTH_DSP_VALUEHL
1e3f			 
1e3f				if DEBUG_FORTH_WORDS 
1e3f					DMARK "DUs" 
1e3f f5				push af  
1e40 3a 54 1e			ld a, (.dmark)  
1e43 32 7a ee			ld (debug_mark),a  
1e46 3a 55 1e			ld a, (.dmark+1)  
1e49 32 7b ee			ld (debug_mark+1),a  
1e4c 3a 56 1e			ld a, (.dmark+2)  
1e4f 32 7c ee			ld (debug_mark+2),a  
1e52 18 03			jr .pastdmark  
1e54 ..			.dmark: db "DUs"  
1e57 f1			.pastdmark: pop af  
1e58			endm  
# End of macro DMARK
1e58					CALLMONITOR 
1e58 cd 80 13			call break_point_state  
1e5b				endm  
# End of macro CALLMONITOR
1e5b				endif 
1e5b cd 2c 19				call forth_push_str 
1e5e			 
1e5e					NEXTW 
1e5e c3 0b 1b			jp macro_next 
1e61				endm 
# End of macro NEXTW
1e61			 
1e61			 
1e61			.dupinum: 
1e61					 
1e61			 
1e61			 
1e61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1e61 cd b5 19			call macro_dsp_valuehl 
1e64				endm 
# End of macro FORTH_DSP_VALUEHL
1e64			 
1e64				; TODO add floating point number detection 
1e64			 
1e64				if DEBUG_FORTH_WORDS 
1e64					DMARK "DUi" 
1e64 f5				push af  
1e65 3a 79 1e			ld a, (.dmark)  
1e68 32 7a ee			ld (debug_mark),a  
1e6b 3a 7a 1e			ld a, (.dmark+1)  
1e6e 32 7b ee			ld (debug_mark+1),a  
1e71 3a 7b 1e			ld a, (.dmark+2)  
1e74 32 7c ee			ld (debug_mark+2),a  
1e77 18 03			jr .pastdmark  
1e79 ..			.dmark: db "DUi"  
1e7c f1			.pastdmark: pop af  
1e7d			endm  
# End of macro DMARK
1e7d					CALLMONITOR 
1e7d cd 80 13			call break_point_state  
1e80				endm  
# End of macro CALLMONITOR
1e80				endif 
1e80			 
1e80 cd 1a 19				call forth_push_numhl 
1e83					NEXTW 
1e83 c3 0b 1b			jp macro_next 
1e86				endm 
# End of macro NEXTW
1e86			.ZDUP: 
1e86				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1e86 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1e87 be 1e			dw .SWAP            
1e89 05				db 4 + 1 
1e8a .. 00			db "?DUP",0              
1e8f				endm 
# End of macro CWHEAD
1e8f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1e8f			 
1e8f					if DEBUG_FORTH_WORDS_KEY 
1e8f						DMARK "qDU" 
1e8f f5				push af  
1e90 3a a4 1e			ld a, (.dmark)  
1e93 32 7a ee			ld (debug_mark),a  
1e96 3a a5 1e			ld a, (.dmark+1)  
1e99 32 7b ee			ld (debug_mark+1),a  
1e9c 3a a6 1e			ld a, (.dmark+2)  
1e9f 32 7c ee			ld (debug_mark+2),a  
1ea2 18 03			jr .pastdmark  
1ea4 ..			.dmark: db "qDU"  
1ea7 f1			.pastdmark: pop af  
1ea8			endm  
# End of macro DMARK
1ea8						CALLMONITOR 
1ea8 cd 80 13			call break_point_state  
1eab				endm  
# End of macro CALLMONITOR
1eab					endif 
1eab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1eab cd b5 19			call macro_dsp_valuehl 
1eae				endm 
# End of macro FORTH_DSP_VALUEHL
1eae			 
1eae e5					push hl 
1eaf			 
1eaf					; is it a zero? 
1eaf			 
1eaf 3e 00				ld a, 0 
1eb1 84					add h 
1eb2 85					add l 
1eb3			 
1eb3 e1					pop hl 
1eb4			 
1eb4 fe 00				cp 0 
1eb6 28 03				jr z, .dup2orig 
1eb8			 
1eb8			 
1eb8 cd 1a 19				call forth_push_numhl 
1ebb			 
1ebb			 
1ebb				; TODO add floating point number detection 
1ebb			 
1ebb			.dup2orig: 
1ebb			 
1ebb					NEXTW 
1ebb c3 0b 1b			jp macro_next 
1ebe				endm 
# End of macro NEXTW
1ebe			.SWAP: 
1ebe				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1ebe 18				db WORD_SYS_CORE+OPCODE_SWAP             
1ebf fd 1e			dw .COLN            
1ec1 05				db 4 + 1 
1ec2 .. 00			db "SWAP",0              
1ec7				endm 
# End of macro CWHEAD
1ec7			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1ec7					if DEBUG_FORTH_WORDS_KEY 
1ec7						DMARK "SWP" 
1ec7 f5				push af  
1ec8 3a dc 1e			ld a, (.dmark)  
1ecb 32 7a ee			ld (debug_mark),a  
1ece 3a dd 1e			ld a, (.dmark+1)  
1ed1 32 7b ee			ld (debug_mark+1),a  
1ed4 3a de 1e			ld a, (.dmark+2)  
1ed7 32 7c ee			ld (debug_mark+2),a  
1eda 18 03			jr .pastdmark  
1edc ..			.dmark: db "SWP"  
1edf f1			.pastdmark: pop af  
1ee0			endm  
# End of macro DMARK
1ee0						CALLMONITOR 
1ee0 cd 80 13			call break_point_state  
1ee3				endm  
# End of macro CALLMONITOR
1ee3					endif 
1ee3			 
1ee3					FORTH_DSP_VALUEHL 
1ee3 cd b5 19			call macro_dsp_valuehl 
1ee6				endm 
# End of macro FORTH_DSP_VALUEHL
1ee6 e5					push hl     ; w2 
1ee7			 
1ee7					FORTH_DSP_POP 
1ee7 cd 51 1a			call macro_forth_dsp_pop 
1eea				endm 
# End of macro FORTH_DSP_POP
1eea			 
1eea					FORTH_DSP_VALUEHL 
1eea cd b5 19			call macro_dsp_valuehl 
1eed				endm 
# End of macro FORTH_DSP_VALUEHL
1eed			 
1eed					FORTH_DSP_POP 
1eed cd 51 1a			call macro_forth_dsp_pop 
1ef0				endm 
# End of macro FORTH_DSP_POP
1ef0			 
1ef0 d1					pop de     ; w2	, hl = w1 
1ef1			 
1ef1 eb					ex de, hl 
1ef2 d5					push de 
1ef3			 
1ef3 cd 1a 19				call forth_push_numhl 
1ef6			 
1ef6 e1					pop hl 
1ef7			 
1ef7 cd 1a 19				call forth_push_numhl 
1efa					 
1efa			 
1efa					NEXTW 
1efa c3 0b 1b			jp macro_next 
1efd				endm 
# End of macro NEXTW
1efd			.COLN: 
1efd				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1efd 19				db WORD_SYS_CORE+OPCODE_COLN             
1efe 89 20			dw .SCOLN            
1f00 02				db 1 + 1 
1f01 .. 00			db ":",0              
1f03				endm 
# End of macro CWHEAD
1f03			; | : ( -- )         Create new word | DONE 
1f03			 
1f03					if DEBUG_FORTH_WORDS_KEY 
1f03						DMARK "CLN" 
1f03 f5				push af  
1f04 3a 18 1f			ld a, (.dmark)  
1f07 32 7a ee			ld (debug_mark),a  
1f0a 3a 19 1f			ld a, (.dmark+1)  
1f0d 32 7b ee			ld (debug_mark+1),a  
1f10 3a 1a 1f			ld a, (.dmark+2)  
1f13 32 7c ee			ld (debug_mark+2),a  
1f16 18 03			jr .pastdmark  
1f18 ..			.dmark: db "CLN"  
1f1b f1			.pastdmark: pop af  
1f1c			endm  
# End of macro DMARK
1f1c						CALLMONITOR 
1f1c cd 80 13			call break_point_state  
1f1f				endm  
# End of macro CALLMONITOR
1f1f					endif 
1f1f				STACKFRAME OFF $8efe $989f 
1f1f				if DEBUG_STACK_IMB 
1f1f					if OFF 
1f1f						exx 
1f1f						ld de, $8efe 
1f1f						ld a, d 
1f1f						ld hl, curframe 
1f1f						call hexout 
1f1f						ld a, e 
1f1f						ld hl, curframe+2 
1f1f						call hexout 
1f1f						ld hl, $8efe 
1f1f						push hl 
1f1f						ld hl, $989f 
1f1f						push hl 
1f1f						exx 
1f1f					endif 
1f1f				endif 
1f1f			endm 
# End of macro STACKFRAME
1f1f				; get parser buffer length  of new word 
1f1f			 
1f1f				 
1f1f			 
1f1f					; move tok past this to start of name defintition 
1f1f					; TODO get word to define 
1f1f					; TODO Move past word token 
1f1f					; TODO get length of string up to the ';' 
1f1f			 
1f1f 2a 76 e6			ld hl, (os_tok_ptr) 
1f22 23				inc hl 
1f23 23				inc hl 
1f24			 
1f24 3e 3b			ld a, ';' 
1f26 cd d1 0f			call strlent 
1f29			 
1f29 7d				ld a,l 
1f2a 32 75 e5			ld (os_new_parse_len), a 
1f2d			 
1f2d			 
1f2d			if DEBUG_FORTH_UWORD 
1f2d ed 5b 76 e6		ld de, (os_tok_ptr) 
1f31						DMARK ":01" 
1f31 f5				push af  
1f32 3a 46 1f			ld a, (.dmark)  
1f35 32 7a ee			ld (debug_mark),a  
1f38 3a 47 1f			ld a, (.dmark+1)  
1f3b 32 7b ee			ld (debug_mark+1),a  
1f3e 3a 48 1f			ld a, (.dmark+2)  
1f41 32 7c ee			ld (debug_mark+2),a  
1f44 18 03			jr .pastdmark  
1f46 ..			.dmark: db ":01"  
1f49 f1			.pastdmark: pop af  
1f4a			endm  
# End of macro DMARK
1f4a				CALLMONITOR 
1f4a cd 80 13			call break_point_state  
1f4d				endm  
# End of macro CALLMONITOR
1f4d			endif 
1f4d			 
1f4d			; 
1f4d			;  new word memory layout: 
1f4d			;  
1f4d			;    : adg 6666 ;  
1f4d			; 
1f4d			;    db   1     ; user defined word  
1f4d 23				inc hl    
1f4e			;    dw   sysdict 
1f4e 23				inc hl 
1f4f 23				inc hl 
1f50			;    db <word len>+1 (for null) 
1f50 23				inc hl 
1f51			;    db .... <word> 
1f51			; 
1f51			 
1f51 23				inc hl    ; some extras for the word preamble before the above 
1f52 23				inc hl 
1f53 23				inc hl 
1f54 23				inc hl 
1f55 23				inc hl 
1f56 23				inc hl 
1f57 23				inc hl  
1f58 23				inc hl 
1f59 23				inc hl 
1f5a 23				inc hl 
1f5b 23				inc hl 
1f5c 23				inc hl 
1f5d 23				inc hl 
1f5e 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1f5f			;       exec word buffer 
1f5f			;	<ptr word>   
1f5f 23				inc hl 
1f60 23				inc hl 
1f61			;       <word list><null term> 7F final term 
1f61			 
1f61			 
1f61			if DEBUG_FORTH_UWORD 
1f61						DMARK ":02" 
1f61 f5				push af  
1f62 3a 76 1f			ld a, (.dmark)  
1f65 32 7a ee			ld (debug_mark),a  
1f68 3a 77 1f			ld a, (.dmark+1)  
1f6b 32 7b ee			ld (debug_mark+1),a  
1f6e 3a 78 1f			ld a, (.dmark+2)  
1f71 32 7c ee			ld (debug_mark+2),a  
1f74 18 03			jr .pastdmark  
1f76 ..			.dmark: db ":02"  
1f79 f1			.pastdmark: pop af  
1f7a			endm  
# End of macro DMARK
1f7a				CALLMONITOR 
1f7a cd 80 13			call break_point_state  
1f7d				endm  
# End of macro CALLMONITOR
1f7d			endif 
1f7d			 
1f7d				 
1f7d					; malloc the size 
1f7d			 
1f7d cd 2f 10				call malloc 
1f80 22 73 e5				ld (os_new_malloc), hl     ; save malloc start 
1f83			 
1f83			;    db   1     ; user defined word  
1f83 3e 01				ld a, WORD_SYS_UWORD  
1f85 77					ld (hl), a 
1f86				 
1f86 23				inc hl    
1f87			;    dw   sysdict 
1f87 11 63 1c			ld de, sysdict       ; continue on with the scan to the system dict 
1f8a 73				ld (hl), e 
1f8b 23				inc hl 
1f8c 72				ld (hl), d 
1f8d 23				inc hl 
1f8e			 
1f8e			 
1f8e			;    Setup dict word 
1f8e			 
1f8e 23				inc hl 
1f8f 22 79 e5			ld (os_new_work_ptr), hl     ; save start of dict word  
1f92			 
1f92				; 1. get length of dict word 
1f92			 
1f92			 
1f92 2a 76 e6			ld hl, (os_tok_ptr) 
1f95 23				inc hl 
1f96 23				inc hl    ; position to start of dict word 
1f97 3e 00			ld a, 0 
1f99 cd d1 0f			call strlent 
1f9c			 
1f9c			 
1f9c 23				inc hl    ; to include null??? 
1f9d			 
1f9d				; write length of dict word 
1f9d			 
1f9d ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1fa1 1b				dec de 
1fa2 eb				ex de, hl 
1fa3 73				ld (hl), e 
1fa4 eb				ex de, hl 
1fa5			 
1fa5				 
1fa5			 
1fa5				; copy  
1fa5 4d				ld c, l 
1fa6 06 00			ld b, 0 
1fa8 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1fac 2a 76 e6			ld hl, (os_tok_ptr) 
1faf 23				inc hl 
1fb0 23				inc hl    ; position to start of dict word 
1fb1				 
1fb1			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
1fb1				 
1fb1				; TODO need to convert word to upper case 
1fb1			 
1fb1			ucasetok:	 
1fb1 7e				ld a,(hl) 
1fb2 cd bd 0f			call toUpper 
1fb5 77				ld (hl),a 
1fb6 ed a0			ldi 
1fb8 f2 b1 1f		 	jp p, ucasetok 
1fbb			 
1fbb			 
1fbb			 
1fbb				; de now points to start of where the word body code should be placed 
1fbb ed 53 79 e5		ld (os_new_work_ptr), de 
1fbf				; hl now points to the words to throw at forthexec which needs to be copied 
1fbf 22 7b e5			ld (os_new_src_ptr), hl 
1fc2			 
1fc2				; TODO add 'call to forthexec' 
1fc2			 
1fc2			if DEBUG_FORTH_UWORD 
1fc2 c5				push bc 
1fc3 ed 4b 73 e5		ld bc, (os_new_malloc) 
1fc7						DMARK ":0x" 
1fc7 f5				push af  
1fc8 3a dc 1f			ld a, (.dmark)  
1fcb 32 7a ee			ld (debug_mark),a  
1fce 3a dd 1f			ld a, (.dmark+1)  
1fd1 32 7b ee			ld (debug_mark+1),a  
1fd4 3a de 1f			ld a, (.dmark+2)  
1fd7 32 7c ee			ld (debug_mark+2),a  
1fda 18 03			jr .pastdmark  
1fdc ..			.dmark: db ":0x"  
1fdf f1			.pastdmark: pop af  
1fe0			endm  
# End of macro DMARK
1fe0				CALLMONITOR 
1fe0 cd 80 13			call break_point_state  
1fe3				endm  
# End of macro CALLMONITOR
1fe3 c1				pop bc 
1fe4			endif 
1fe4			 
1fe4			 
1fe4				; create word preamble which should be: 
1fe4			 
1fe4			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
1fe4			 
1fe4				;    ld hl, <word code> 
1fe4				;    jp user_exec 
1fe4			        ;    <word code bytes> 
1fe4			 
1fe4			 
1fe4			;	inc de     ; TODO ??? or are we already past the word's null 
1fe4 eb				ex de, hl 
1fe5			 
1fe5 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
1fe7			 
1fe7 23				inc hl 
1fe8 22 7f e5			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
1feb 23				inc hl 
1fec			 
1fec 23				inc hl 
1fed 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
1fef			 
1fef 01 78 43			ld bc, user_exec 
1ff2 23				inc hl 
1ff3 71				ld (hl), c     ; poke address of user_exec 
1ff4 23				inc hl 
1ff5 70				ld (hl), b     
1ff6			 ; 
1ff6			;	inc hl 
1ff6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1ff6			; 
1ff6			; 
1ff6			;	ld bc, macro_forth_rsp_next 
1ff6			;	inc hl 
1ff6			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
1ff6			;	inc hl 
1ff6			;	ld (hl), b     
1ff6			 ; 
1ff6			;	inc hl 
1ff6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1ff6			; 
1ff6			; 
1ff6			;	inc hl 
1ff6			;	ld bc, forthexec 
1ff6			;	ld (hl), c     ; poke address of forthexec 
1ff6			;	inc hl 
1ff6			;	ld (hl), b      
1ff6			; 
1ff6			;	inc hl 
1ff6			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
1ff6			; 
1ff6			;	ld bc, user_dict_next 
1ff6			;	inc hl 
1ff6			;	ld (hl), c     ; poke address of forthexec 
1ff6			;	inc hl 
1ff6			;	ld (hl), b      
1ff6			 
1ff6				; hl is now where we need to copy the word byte data to save this 
1ff6			 
1ff6 23				inc hl 
1ff7 22 7d e5			ld (os_new_exec), hl 
1ffa				 
1ffa				; copy definition 
1ffa			 
1ffa eb				ex de, hl 
1ffb			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
1ffb			;	inc de    ; skip the PC for this parse 
1ffb 3a 75 e5			ld a, (os_new_parse_len) 
1ffe 4f				ld c, a 
1fff 06 00			ld b, 0 
2001 ed b0			ldir		 ; copy defintion 
2003			 
2003			 
2003				; poke the address of where the new word bytes live for forthexec 
2003			 
2003 2a 7f e5			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2006			 
2006 ed 5b 7d e5		ld de, (os_new_exec)      
200a				 
200a 73				ld (hl), e 
200b 23				inc hl 
200c 72				ld (hl), d 
200d			 
200d					; TODO copy last user dict word next link to this word 
200d					; TODO update last user dict word to point to this word 
200d			; 
200d			; hl f923 de 812a ; bc 811a 
200d			 
200d			if DEBUG_FORTH_UWORD 
200d c5				push bc 
200e ed 4b 73 e5		ld bc, (os_new_malloc) 
2012						DMARK ":0A" 
2012 f5				push af  
2013 3a 27 20			ld a, (.dmark)  
2016 32 7a ee			ld (debug_mark),a  
2019 3a 28 20			ld a, (.dmark+1)  
201c 32 7b ee			ld (debug_mark+1),a  
201f 3a 29 20			ld a, (.dmark+2)  
2022 32 7c ee			ld (debug_mark+2),a  
2025 18 03			jr .pastdmark  
2027 ..			.dmark: db ":0A"  
202a f1			.pastdmark: pop af  
202b			endm  
# End of macro DMARK
202b				CALLMONITOR 
202b cd 80 13			call break_point_state  
202e				endm  
# End of macro CALLMONITOR
202e c1				pop bc 
202f			endif 
202f			if DEBUG_FORTH_UWORD 
202f c5				push bc 
2030 ed 4b 73 e5		ld bc, (os_new_malloc) 
2034 03				inc bc 
2035 03				inc bc 
2036 03				inc bc 
2037 03				inc bc 
2038 03				inc bc 
2039 03				inc bc 
203a 03				inc bc 
203b 03				inc bc 
203c			 
203c						DMARK ":0B" 
203c f5				push af  
203d 3a 51 20			ld a, (.dmark)  
2040 32 7a ee			ld (debug_mark),a  
2043 3a 52 20			ld a, (.dmark+1)  
2046 32 7b ee			ld (debug_mark+1),a  
2049 3a 53 20			ld a, (.dmark+2)  
204c 32 7c ee			ld (debug_mark+2),a  
204f 18 03			jr .pastdmark  
2051 ..			.dmark: db ":0B"  
2054 f1			.pastdmark: pop af  
2055			endm  
# End of macro DMARK
2055				CALLMONITOR 
2055 cd 80 13			call break_point_state  
2058				endm  
# End of macro CALLMONITOR
2058 c1				pop bc 
2059			endif 
2059			 
2059			; update word dict linked list for new word 
2059			 
2059			 
2059 2a 72 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
205c 23			inc hl     ; move to next work linked list ptr 
205d			 
205d ed 5b 73 e5	ld de, (os_new_malloc)		 ; new next word 
2061 73			ld (hl), e 
2062 23			inc hl 
2063 72			ld (hl), d 
2064			 
2064			if DEBUG_FORTH_UWORD 
2064 ed 4b 72 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2068			endif 
2068			 
2068 ed 53 72 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
206c			 
206c			 
206c			if DEBUG_FORTH_UWORD 
206c						DMARK ":0+" 
206c f5				push af  
206d 3a 81 20			ld a, (.dmark)  
2070 32 7a ee			ld (debug_mark),a  
2073 3a 82 20			ld a, (.dmark+1)  
2076 32 7b ee			ld (debug_mark+1),a  
2079 3a 83 20			ld a, (.dmark+2)  
207c 32 7c ee			ld (debug_mark+2),a  
207f 18 03			jr .pastdmark  
2081 ..			.dmark: db ":0+"  
2084 f1			.pastdmark: pop af  
2085			endm  
# End of macro DMARK
2085				CALLMONITOR 
2085 cd 80 13			call break_point_state  
2088				endm  
# End of macro CALLMONITOR
2088			endif 
2088			 
2088				STACKFRAMECHK OFF $8efe $989f 
2088				if DEBUG_STACK_IMB 
2088					if OFF 
2088						exx 
2088						ld hl, $989f 
2088						pop de   ; $989f 
2088						call cmp16 
2088						jr nz, .spnosame 
2088						ld hl, $8efe 
2088						pop de   ; $8efe 
2088						call cmp16 
2088						jr z, .spfrsame 
2088						.spnosame: call showsperror 
2088						.spfrsame: nop 
2088						exx 
2088					endif 
2088				endif 
2088			endm 
# End of macro STACKFRAMECHK
2088			 
2088 c9			ret    ; dont process any remaining parser tokens as they form new word 
2089			 
2089			 
2089			 
2089			 
2089			;		NEXT 
2089			.SCOLN: 
2089			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2089 06				db OPCODE_SCOLN 
208a d5 20			dw .DROP 
208c 02				db 2 
208d .. 00			db ";",0           
208f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
208f					if DEBUG_FORTH_WORDS_KEY 
208f						DMARK "SCN" 
208f f5				push af  
2090 3a a4 20			ld a, (.dmark)  
2093 32 7a ee			ld (debug_mark),a  
2096 3a a5 20			ld a, (.dmark+1)  
2099 32 7b ee			ld (debug_mark+1),a  
209c 3a a6 20			ld a, (.dmark+2)  
209f 32 7c ee			ld (debug_mark+2),a  
20a2 18 03			jr .pastdmark  
20a4 ..			.dmark: db "SCN"  
20a7 f1			.pastdmark: pop af  
20a8			endm  
# End of macro DMARK
20a8						CALLMONITOR 
20a8 cd 80 13			call break_point_state  
20ab				endm  
# End of macro CALLMONITOR
20ab					endif 
20ab					FORTH_RSP_TOS 
20ab cd d8 18			call macro_forth_rsp_tos 
20ae				endm 
# End of macro FORTH_RSP_TOS
20ae e5					push hl 
20af					FORTH_RSP_POP 
20af cd e2 18			call macro_forth_rsp_pop 
20b2				endm 
# End of macro FORTH_RSP_POP
20b2 e1					pop hl 
20b3			;		ex de,hl 
20b3 22 76 e6				ld (os_tok_ptr),hl 
20b6			 
20b6			if DEBUG_FORTH_UWORD 
20b6						DMARK "SCL" 
20b6 f5				push af  
20b7 3a cb 20			ld a, (.dmark)  
20ba 32 7a ee			ld (debug_mark),a  
20bd 3a cc 20			ld a, (.dmark+1)  
20c0 32 7b ee			ld (debug_mark+1),a  
20c3 3a cd 20			ld a, (.dmark+2)  
20c6 32 7c ee			ld (debug_mark+2),a  
20c9 18 03			jr .pastdmark  
20cb ..			.dmark: db "SCL"  
20ce f1			.pastdmark: pop af  
20cf			endm  
# End of macro DMARK
20cf				CALLMONITOR 
20cf cd 80 13			call break_point_state  
20d2				endm  
# End of macro CALLMONITOR
20d2			endif 
20d2					NEXTW 
20d2 c3 0b 1b			jp macro_next 
20d5				endm 
# End of macro NEXTW
20d5			 
20d5			.DROP: 
20d5				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
20d5 1b				db WORD_SYS_CORE+OPCODE_DROP             
20d6 00 21			dw .DUP2            
20d8 05				db 4 + 1 
20d9 .. 00			db "DROP",0              
20de				endm 
# End of macro CWHEAD
20de			; | DROP ( w -- )   drop the TOS item   | DONE 
20de					if DEBUG_FORTH_WORDS_KEY 
20de						DMARK "DRP" 
20de f5				push af  
20df 3a f3 20			ld a, (.dmark)  
20e2 32 7a ee			ld (debug_mark),a  
20e5 3a f4 20			ld a, (.dmark+1)  
20e8 32 7b ee			ld (debug_mark+1),a  
20eb 3a f5 20			ld a, (.dmark+2)  
20ee 32 7c ee			ld (debug_mark+2),a  
20f1 18 03			jr .pastdmark  
20f3 ..			.dmark: db "DRP"  
20f6 f1			.pastdmark: pop af  
20f7			endm  
# End of macro DMARK
20f7						CALLMONITOR 
20f7 cd 80 13			call break_point_state  
20fa				endm  
# End of macro CALLMONITOR
20fa					endif 
20fa					FORTH_DSP_POP 
20fa cd 51 1a			call macro_forth_dsp_pop 
20fd				endm 
# End of macro FORTH_DSP_POP
20fd					NEXTW 
20fd c3 0b 1b			jp macro_next 
2100				endm 
# End of macro NEXTW
2100			.DUP2: 
2100				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2100 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2101 45 21			dw .DROP2            
2103 05				db 4 + 1 
2104 .. 00			db "2DUP",0              
2109				endm 
# End of macro CWHEAD
2109			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2109					if DEBUG_FORTH_WORDS_KEY 
2109						DMARK "2DU" 
2109 f5				push af  
210a 3a 1e 21			ld a, (.dmark)  
210d 32 7a ee			ld (debug_mark),a  
2110 3a 1f 21			ld a, (.dmark+1)  
2113 32 7b ee			ld (debug_mark+1),a  
2116 3a 20 21			ld a, (.dmark+2)  
2119 32 7c ee			ld (debug_mark+2),a  
211c 18 03			jr .pastdmark  
211e ..			.dmark: db "2DU"  
2121 f1			.pastdmark: pop af  
2122			endm  
# End of macro DMARK
2122						CALLMONITOR 
2122 cd 80 13			call break_point_state  
2125				endm  
# End of macro CALLMONITOR
2125					endif 
2125					FORTH_DSP_VALUEHL 
2125 cd b5 19			call macro_dsp_valuehl 
2128				endm 
# End of macro FORTH_DSP_VALUEHL
2128 e5					push hl      ; 2 
2129			 
2129					FORTH_DSP_POP 
2129 cd 51 1a			call macro_forth_dsp_pop 
212c				endm 
# End of macro FORTH_DSP_POP
212c					 
212c					FORTH_DSP_VALUEHL 
212c cd b5 19			call macro_dsp_valuehl 
212f				endm 
# End of macro FORTH_DSP_VALUEHL
212f			;		push hl      ; 1 
212f			 
212f					FORTH_DSP_POP 
212f cd 51 1a			call macro_forth_dsp_pop 
2132				endm 
# End of macro FORTH_DSP_POP
2132			 
2132			;		pop hl       ; 1 
2132 d1					pop de       ; 2 
2133			 
2133 cd 1a 19				call forth_push_numhl 
2136 eb					ex de, hl 
2137 cd 1a 19				call forth_push_numhl 
213a			 
213a					 
213a eb					ex de, hl 
213b			 
213b cd 1a 19				call forth_push_numhl 
213e eb					ex de, hl 
213f cd 1a 19				call forth_push_numhl 
2142			 
2142			 
2142					NEXTW 
2142 c3 0b 1b			jp macro_next 
2145				endm 
# End of macro NEXTW
2145			.DROP2: 
2145				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2145 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2146 74 21			dw .SWAP2            
2148 06				db 5 + 1 
2149 .. 00			db "2DROP",0              
214f				endm 
# End of macro CWHEAD
214f			; | 2DROP ( w w -- )    Double drop | DONE 
214f					if DEBUG_FORTH_WORDS_KEY 
214f						DMARK "2DR" 
214f f5				push af  
2150 3a 64 21			ld a, (.dmark)  
2153 32 7a ee			ld (debug_mark),a  
2156 3a 65 21			ld a, (.dmark+1)  
2159 32 7b ee			ld (debug_mark+1),a  
215c 3a 66 21			ld a, (.dmark+2)  
215f 32 7c ee			ld (debug_mark+2),a  
2162 18 03			jr .pastdmark  
2164 ..			.dmark: db "2DR"  
2167 f1			.pastdmark: pop af  
2168			endm  
# End of macro DMARK
2168						CALLMONITOR 
2168 cd 80 13			call break_point_state  
216b				endm  
# End of macro CALLMONITOR
216b					endif 
216b					FORTH_DSP_POP 
216b cd 51 1a			call macro_forth_dsp_pop 
216e				endm 
# End of macro FORTH_DSP_POP
216e					FORTH_DSP_POP 
216e cd 51 1a			call macro_forth_dsp_pop 
2171				endm 
# End of macro FORTH_DSP_POP
2171					NEXTW 
2171 c3 0b 1b			jp macro_next 
2174				endm 
# End of macro NEXTW
2174			.SWAP2: 
2174				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2174 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2175 9d 21			dw .AT            
2177 06				db 5 + 1 
2178 .. 00			db "2SWAP",0              
217e				endm 
# End of macro CWHEAD
217e			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
217e					if DEBUG_FORTH_WORDS_KEY 
217e						DMARK "2SW" 
217e f5				push af  
217f 3a 93 21			ld a, (.dmark)  
2182 32 7a ee			ld (debug_mark),a  
2185 3a 94 21			ld a, (.dmark+1)  
2188 32 7b ee			ld (debug_mark+1),a  
218b 3a 95 21			ld a, (.dmark+2)  
218e 32 7c ee			ld (debug_mark+2),a  
2191 18 03			jr .pastdmark  
2193 ..			.dmark: db "2SW"  
2196 f1			.pastdmark: pop af  
2197			endm  
# End of macro DMARK
2197						CALLMONITOR 
2197 cd 80 13			call break_point_state  
219a				endm  
# End of macro CALLMONITOR
219a					endif 
219a					NEXTW 
219a c3 0b 1b			jp macro_next 
219d				endm 
# End of macro NEXTW
219d			.AT: 
219d				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
219d 1f				db WORD_SYS_CORE+OPCODE_AT             
219e cf 21			dw .CAT            
21a0 02				db 1 + 1 
21a1 .. 00			db "@",0              
21a3				endm 
# End of macro CWHEAD
21a3			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
21a3			 
21a3					if DEBUG_FORTH_WORDS_KEY 
21a3						DMARK "AT." 
21a3 f5				push af  
21a4 3a b8 21			ld a, (.dmark)  
21a7 32 7a ee			ld (debug_mark),a  
21aa 3a b9 21			ld a, (.dmark+1)  
21ad 32 7b ee			ld (debug_mark+1),a  
21b0 3a ba 21			ld a, (.dmark+2)  
21b3 32 7c ee			ld (debug_mark+2),a  
21b6 18 03			jr .pastdmark  
21b8 ..			.dmark: db "AT."  
21bb f1			.pastdmark: pop af  
21bc			endm  
# End of macro DMARK
21bc						CALLMONITOR 
21bc cd 80 13			call break_point_state  
21bf				endm  
# End of macro CALLMONITOR
21bf					endif 
21bf			.getbyteat:	 
21bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21bf cd b5 19			call macro_dsp_valuehl 
21c2				endm 
# End of macro FORTH_DSP_VALUEHL
21c2					 
21c2			;		push hl 
21c2				 
21c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
21c2 cd 51 1a			call macro_forth_dsp_pop 
21c5				endm 
# End of macro FORTH_DSP_POP
21c5			 
21c5			;		pop hl 
21c5			 
21c5 7e					ld a, (hl) 
21c6			 
21c6 6f					ld l, a 
21c7 26 00				ld h, 0 
21c9 cd 1a 19				call forth_push_numhl 
21cc			 
21cc					NEXTW 
21cc c3 0b 1b			jp macro_next 
21cf				endm 
# End of macro NEXTW
21cf			.CAT: 
21cf				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
21cf 20				db WORD_SYS_CORE+OPCODE_CAT             
21d0 f8 21			dw .BANG            
21d2 03				db 2 + 1 
21d3 .. 00			db "C@",0              
21d6				endm 
# End of macro CWHEAD
21d6			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
21d6					if DEBUG_FORTH_WORDS_KEY 
21d6						DMARK "CAA" 
21d6 f5				push af  
21d7 3a eb 21			ld a, (.dmark)  
21da 32 7a ee			ld (debug_mark),a  
21dd 3a ec 21			ld a, (.dmark+1)  
21e0 32 7b ee			ld (debug_mark+1),a  
21e3 3a ed 21			ld a, (.dmark+2)  
21e6 32 7c ee			ld (debug_mark+2),a  
21e9 18 03			jr .pastdmark  
21eb ..			.dmark: db "CAA"  
21ee f1			.pastdmark: pop af  
21ef			endm  
# End of macro DMARK
21ef						CALLMONITOR 
21ef cd 80 13			call break_point_state  
21f2				endm  
# End of macro CALLMONITOR
21f2					endif 
21f2 c3 bf 21				jp .getbyteat 
21f5					NEXTW 
21f5 c3 0b 1b			jp macro_next 
21f8				endm 
# End of macro NEXTW
21f8			.BANG: 
21f8				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
21f8 21				db WORD_SYS_CORE+OPCODE_BANG             
21f9 2e 22			dw .CBANG            
21fb 02				db 1 + 1 
21fc .. 00			db "!",0              
21fe				endm 
# End of macro CWHEAD
21fe			; | ! ( x w -- ) Store x at address w      | DONE 
21fe					if DEBUG_FORTH_WORDS_KEY 
21fe						DMARK "BNG" 
21fe f5				push af  
21ff 3a 13 22			ld a, (.dmark)  
2202 32 7a ee			ld (debug_mark),a  
2205 3a 14 22			ld a, (.dmark+1)  
2208 32 7b ee			ld (debug_mark+1),a  
220b 3a 15 22			ld a, (.dmark+2)  
220e 32 7c ee			ld (debug_mark+2),a  
2211 18 03			jr .pastdmark  
2213 ..			.dmark: db "BNG"  
2216 f1			.pastdmark: pop af  
2217			endm  
# End of macro DMARK
2217						CALLMONITOR 
2217 cd 80 13			call break_point_state  
221a				endm  
# End of macro CALLMONITOR
221a					endif 
221a			 
221a			.storebyteat:		 
221a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
221a cd b5 19			call macro_dsp_valuehl 
221d				endm 
# End of macro FORTH_DSP_VALUEHL
221d					 
221d e5					push hl 
221e				 
221e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
221e cd 51 1a			call macro_forth_dsp_pop 
2221				endm 
# End of macro FORTH_DSP_POP
2221			 
2221					; get byte to poke 
2221			 
2221					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2221 cd b5 19			call macro_dsp_valuehl 
2224				endm 
# End of macro FORTH_DSP_VALUEHL
2224 e5					push hl 
2225			 
2225			 
2225					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2225 cd 51 1a			call macro_forth_dsp_pop 
2228				endm 
# End of macro FORTH_DSP_POP
2228			 
2228			 
2228 d1					pop de 
2229 e1					pop hl 
222a			 
222a 73					ld (hl),e 
222b			 
222b			 
222b					NEXTW 
222b c3 0b 1b			jp macro_next 
222e				endm 
# End of macro NEXTW
222e			.CBANG: 
222e				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
222e 22				db WORD_SYS_CORE+OPCODE_CBANG             
222f 57 22			dw .SCALL            
2231 03				db 2 + 1 
2232 .. 00			db "C!",0              
2235				endm 
# End of macro CWHEAD
2235			; | C!  ( x w -- ) Store x at address w  | DONE 
2235					if DEBUG_FORTH_WORDS_KEY 
2235						DMARK "CBA" 
2235 f5				push af  
2236 3a 4a 22			ld a, (.dmark)  
2239 32 7a ee			ld (debug_mark),a  
223c 3a 4b 22			ld a, (.dmark+1)  
223f 32 7b ee			ld (debug_mark+1),a  
2242 3a 4c 22			ld a, (.dmark+2)  
2245 32 7c ee			ld (debug_mark+2),a  
2248 18 03			jr .pastdmark  
224a ..			.dmark: db "CBA"  
224d f1			.pastdmark: pop af  
224e			endm  
# End of macro DMARK
224e						CALLMONITOR 
224e cd 80 13			call break_point_state  
2251				endm  
# End of macro CALLMONITOR
2251					endif 
2251 c3 1a 22				jp .storebyteat 
2254					NEXTW 
2254 c3 0b 1b			jp macro_next 
2257				endm 
# End of macro NEXTW
2257			.SCALL: 
2257				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2257 23				db WORD_SYS_CORE+OPCODE_SCALL             
2258 8b 22			dw .DEPTH            
225a 05				db 4 + 1 
225b .. 00			db "CALL",0              
2260				endm 
# End of macro CWHEAD
2260			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2260					if DEBUG_FORTH_WORDS_KEY 
2260						DMARK "CLL" 
2260 f5				push af  
2261 3a 75 22			ld a, (.dmark)  
2264 32 7a ee			ld (debug_mark),a  
2267 3a 76 22			ld a, (.dmark+1)  
226a 32 7b ee			ld (debug_mark+1),a  
226d 3a 77 22			ld a, (.dmark+2)  
2270 32 7c ee			ld (debug_mark+2),a  
2273 18 03			jr .pastdmark  
2275 ..			.dmark: db "CLL"  
2278 f1			.pastdmark: pop af  
2279			endm  
# End of macro DMARK
2279						CALLMONITOR 
2279 cd 80 13			call break_point_state  
227c				endm  
# End of macro CALLMONITOR
227c					endif 
227c			 
227c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
227c cd b5 19			call macro_dsp_valuehl 
227f				endm 
# End of macro FORTH_DSP_VALUEHL
227f			 
227f			;		push hl 
227f			 
227f					; destroy value TOS 
227f			 
227f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
227f cd 51 1a			call macro_forth_dsp_pop 
2282				endm 
# End of macro FORTH_DSP_POP
2282			 
2282						 
2282			;		pop hl 
2282			 
2282					; how to do a call with hl???? save SP? 
2282 cd b4 1a				call forth_call_hl 
2285			 
2285			 
2285					; TODO push value back onto stack for another op etc 
2285			 
2285 cd 1a 19				call forth_push_numhl 
2288					NEXTW 
2288 c3 0b 1b			jp macro_next 
228b				endm 
# End of macro NEXTW
228b			.DEPTH: 
228b				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
228b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
228c c8 22			dw .OVER            
228e 06				db 5 + 1 
228f .. 00			db "DEPTH",0              
2295				endm 
# End of macro CWHEAD
2295			; | DEPTH ( -- u ) Push count of stack | DONE 
2295					; take current TOS and remove from base value div by two to get count 
2295					if DEBUG_FORTH_WORDS_KEY 
2295						DMARK "DEP" 
2295 f5				push af  
2296 3a aa 22			ld a, (.dmark)  
2299 32 7a ee			ld (debug_mark),a  
229c 3a ab 22			ld a, (.dmark+1)  
229f 32 7b ee			ld (debug_mark+1),a  
22a2 3a ac 22			ld a, (.dmark+2)  
22a5 32 7c ee			ld (debug_mark+2),a  
22a8 18 03			jr .pastdmark  
22aa ..			.dmark: db "DEP"  
22ad f1			.pastdmark: pop af  
22ae			endm  
# End of macro DMARK
22ae						CALLMONITOR 
22ae cd 80 13			call break_point_state  
22b1				endm  
# End of macro CALLMONITOR
22b1					endif 
22b1			 
22b1			 
22b1 2a 22 eb			ld hl, (cli_data_sp) 
22b4 11 dc e8			ld de, cli_data_stack 
22b7 ed 52			sbc hl,de 
22b9				 
22b9				; div by size of stack item 
22b9			 
22b9 5d				ld e,l 
22ba 0e 03			ld c, 3 
22bc cd f8 0a			call Div8 
22bf			 
22bf 6f				ld l,a 
22c0 26 00			ld h,0 
22c2			 
22c2				;srl h 
22c2				;rr l 
22c2			 
22c2 cd 1a 19				call forth_push_numhl 
22c5					NEXTW 
22c5 c3 0b 1b			jp macro_next 
22c8				endm 
# End of macro NEXTW
22c8			.OVER: 
22c8				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
22c8 42				db WORD_SYS_CORE+46             
22c9 0f 23			dw .PAUSE            
22cb 05				db 4 + 1 
22cc .. 00			db "OVER",0              
22d1				endm 
# End of macro CWHEAD
22d1			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
22d1					if DEBUG_FORTH_WORDS_KEY 
22d1						DMARK "OVR" 
22d1 f5				push af  
22d2 3a e6 22			ld a, (.dmark)  
22d5 32 7a ee			ld (debug_mark),a  
22d8 3a e7 22			ld a, (.dmark+1)  
22db 32 7b ee			ld (debug_mark+1),a  
22de 3a e8 22			ld a, (.dmark+2)  
22e1 32 7c ee			ld (debug_mark+2),a  
22e4 18 03			jr .pastdmark  
22e6 ..			.dmark: db "OVR"  
22e9 f1			.pastdmark: pop af  
22ea			endm  
# End of macro DMARK
22ea						CALLMONITOR 
22ea cd 80 13			call break_point_state  
22ed				endm  
# End of macro CALLMONITOR
22ed					endif 
22ed			 
22ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22ed cd b5 19			call macro_dsp_valuehl 
22f0				endm 
# End of macro FORTH_DSP_VALUEHL
22f0 e5					push hl    ; n2 
22f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22f1 cd 51 1a			call macro_forth_dsp_pop 
22f4				endm 
# End of macro FORTH_DSP_POP
22f4			 
22f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22f4 cd b5 19			call macro_dsp_valuehl 
22f7				endm 
# End of macro FORTH_DSP_VALUEHL
22f7 e5					push hl    ; n1 
22f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22f8 cd 51 1a			call macro_forth_dsp_pop 
22fb				endm 
# End of macro FORTH_DSP_POP
22fb			 
22fb d1					pop de     ; n1 
22fc e1					pop hl     ; n2 
22fd			 
22fd d5					push de 
22fe e5					push hl 
22ff d5					push de 
2300			 
2300					; push back  
2300			 
2300 e1					pop hl 
2301 cd 1a 19				call forth_push_numhl 
2304 e1					pop hl 
2305 cd 1a 19				call forth_push_numhl 
2308 e1					pop hl 
2309 cd 1a 19				call forth_push_numhl 
230c					NEXTW 
230c c3 0b 1b			jp macro_next 
230f				endm 
# End of macro NEXTW
230f			 
230f			.PAUSE: 
230f				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
230f 43				db WORD_SYS_CORE+47             
2310 44 23			dw .PAUSES            
2312 08				db 7 + 1 
2313 .. 00			db "PAUSEMS",0              
231b				endm 
# End of macro CWHEAD
231b			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
231b					if DEBUG_FORTH_WORDS_KEY 
231b						DMARK "PMS" 
231b f5				push af  
231c 3a 30 23			ld a, (.dmark)  
231f 32 7a ee			ld (debug_mark),a  
2322 3a 31 23			ld a, (.dmark+1)  
2325 32 7b ee			ld (debug_mark+1),a  
2328 3a 32 23			ld a, (.dmark+2)  
232b 32 7c ee			ld (debug_mark+2),a  
232e 18 03			jr .pastdmark  
2330 ..			.dmark: db "PMS"  
2333 f1			.pastdmark: pop af  
2334			endm  
# End of macro DMARK
2334						CALLMONITOR 
2334 cd 80 13			call break_point_state  
2337				endm  
# End of macro CALLMONITOR
2337					endif 
2337					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2337 cd b5 19			call macro_dsp_valuehl 
233a				endm 
# End of macro FORTH_DSP_VALUEHL
233a			;		push hl    ; n2 
233a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
233a cd 51 1a			call macro_forth_dsp_pop 
233d				endm 
# End of macro FORTH_DSP_POP
233d			;		pop hl 
233d			 
233d 7d					ld a, l 
233e cd c7 08				call aDelayInMS 
2341				       NEXTW 
2341 c3 0b 1b			jp macro_next 
2344				endm 
# End of macro NEXTW
2344			.PAUSES:  
2344				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2344 44				db WORD_SYS_CORE+48             
2345 b3 23			dw .ROT            
2347 06				db 5 + 1 
2348 .. 00			db "PAUSE",0              
234e				endm 
# End of macro CWHEAD
234e			; | PAUSE ( n -- )  Pause for n seconds | DONE 
234e					if DEBUG_FORTH_WORDS_KEY 
234e						DMARK "PAU" 
234e f5				push af  
234f 3a 63 23			ld a, (.dmark)  
2352 32 7a ee			ld (debug_mark),a  
2355 3a 64 23			ld a, (.dmark+1)  
2358 32 7b ee			ld (debug_mark+1),a  
235b 3a 65 23			ld a, (.dmark+2)  
235e 32 7c ee			ld (debug_mark+2),a  
2361 18 03			jr .pastdmark  
2363 ..			.dmark: db "PAU"  
2366 f1			.pastdmark: pop af  
2367			endm  
# End of macro DMARK
2367						CALLMONITOR 
2367 cd 80 13			call break_point_state  
236a				endm  
# End of macro CALLMONITOR
236a					endif 
236a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
236a cd b5 19			call macro_dsp_valuehl 
236d				endm 
# End of macro FORTH_DSP_VALUEHL
236d			;		push hl    ; n2 
236d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
236d cd 51 1a			call macro_forth_dsp_pop 
2370				endm 
# End of macro FORTH_DSP_POP
2370			;		pop hl 
2370 45					ld b, l 
2371					if DEBUG_FORTH_WORDS 
2371						DMARK "PAU" 
2371 f5				push af  
2372 3a 86 23			ld a, (.dmark)  
2375 32 7a ee			ld (debug_mark),a  
2378 3a 87 23			ld a, (.dmark+1)  
237b 32 7b ee			ld (debug_mark+1),a  
237e 3a 88 23			ld a, (.dmark+2)  
2381 32 7c ee			ld (debug_mark+2),a  
2384 18 03			jr .pastdmark  
2386 ..			.dmark: db "PAU"  
2389 f1			.pastdmark: pop af  
238a			endm  
# End of macro DMARK
238a						CALLMONITOR 
238a cd 80 13			call break_point_state  
238d				endm  
# End of macro CALLMONITOR
238d					endif 
238d c5			.pauses1:	push bc 
238e cd e2 08				call delay1s 
2391 c1					pop bc 
2392					if DEBUG_FORTH_WORDS 
2392						DMARK "PA1" 
2392 f5				push af  
2393 3a a7 23			ld a, (.dmark)  
2396 32 7a ee			ld (debug_mark),a  
2399 3a a8 23			ld a, (.dmark+1)  
239c 32 7b ee			ld (debug_mark+1),a  
239f 3a a9 23			ld a, (.dmark+2)  
23a2 32 7c ee			ld (debug_mark+2),a  
23a5 18 03			jr .pastdmark  
23a7 ..			.dmark: db "PA1"  
23aa f1			.pastdmark: pop af  
23ab			endm  
# End of macro DMARK
23ab						CALLMONITOR 
23ab cd 80 13			call break_point_state  
23ae				endm  
# End of macro CALLMONITOR
23ae					endif 
23ae 10 dd				djnz .pauses1 
23b0			 
23b0				       NEXTW 
23b0 c3 0b 1b			jp macro_next 
23b3				endm 
# End of macro NEXTW
23b3			.ROT: 
23b3				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
23b3 45				db WORD_SYS_CORE+49             
23b4 01 24			dw .UWORDS            
23b6 04				db 3 + 1 
23b7 .. 00			db "ROT",0              
23bb				endm 
# End of macro CWHEAD
23bb			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
23bb					if DEBUG_FORTH_WORDS_KEY 
23bb						DMARK "ROT" 
23bb f5				push af  
23bc 3a d0 23			ld a, (.dmark)  
23bf 32 7a ee			ld (debug_mark),a  
23c2 3a d1 23			ld a, (.dmark+1)  
23c5 32 7b ee			ld (debug_mark+1),a  
23c8 3a d2 23			ld a, (.dmark+2)  
23cb 32 7c ee			ld (debug_mark+2),a  
23ce 18 03			jr .pastdmark  
23d0 ..			.dmark: db "ROT"  
23d3 f1			.pastdmark: pop af  
23d4			endm  
# End of macro DMARK
23d4						CALLMONITOR 
23d4 cd 80 13			call break_point_state  
23d7				endm  
# End of macro CALLMONITOR
23d7					endif 
23d7			 
23d7					FORTH_DSP_VALUEHL 
23d7 cd b5 19			call macro_dsp_valuehl 
23da				endm 
# End of macro FORTH_DSP_VALUEHL
23da e5					push hl    ; u3  
23db			 
23db					FORTH_DSP_POP 
23db cd 51 1a			call macro_forth_dsp_pop 
23de				endm 
# End of macro FORTH_DSP_POP
23de			   
23de					FORTH_DSP_VALUEHL 
23de cd b5 19			call macro_dsp_valuehl 
23e1				endm 
# End of macro FORTH_DSP_VALUEHL
23e1 e5					push hl     ; u2 
23e2			 
23e2					FORTH_DSP_POP 
23e2 cd 51 1a			call macro_forth_dsp_pop 
23e5				endm 
# End of macro FORTH_DSP_POP
23e5			 
23e5					FORTH_DSP_VALUEHL 
23e5 cd b5 19			call macro_dsp_valuehl 
23e8				endm 
# End of macro FORTH_DSP_VALUEHL
23e8 e5					push hl     ; u1 
23e9			 
23e9					FORTH_DSP_POP 
23e9 cd 51 1a			call macro_forth_dsp_pop 
23ec				endm 
# End of macro FORTH_DSP_POP
23ec			 
23ec c1					pop bc      ; u1 
23ed e1					pop hl      ; u2 
23ee d1					pop de      ; u3 
23ef			 
23ef			 
23ef c5					push bc 
23f0 d5					push de 
23f1 e5					push hl 
23f2			 
23f2			 
23f2 e1					pop hl 
23f3 cd 1a 19				call forth_push_numhl 
23f6			 
23f6 e1					pop hl 
23f7 cd 1a 19				call forth_push_numhl 
23fa			 
23fa e1					pop hl 
23fb cd 1a 19				call forth_push_numhl 
23fe					 
23fe			 
23fe			 
23fe			 
23fe			 
23fe			 
23fe				       NEXTW 
23fe c3 0b 1b			jp macro_next 
2401				endm 
# End of macro NEXTW
2401			 
2401			.UWORDS: 
2401				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2401 50				db WORD_SYS_CORE+60             
2402 c3 24			dw .BP            
2404 07				db 6 + 1 
2405 .. 00			db "UWORDS",0              
240c				endm 
# End of macro CWHEAD
240c			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
240c			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
240c			; | | Following the count are the individual words. 
240c			; | | 
240c			; | | e.g. UWORDS 
240c			; | | BOX DIRLIST 2 
240c			; | |  
240c			; | | Can be used to save the words to storage via: 
240c			; | | UWORDS $01 DO $01 APPEND LOOP 
240c				if DEBUG_FORTH_WORDS_KEY 
240c					DMARK "UWR" 
240c f5				push af  
240d 3a 21 24			ld a, (.dmark)  
2410 32 7a ee			ld (debug_mark),a  
2413 3a 22 24			ld a, (.dmark+1)  
2416 32 7b ee			ld (debug_mark+1),a  
2419 3a 23 24			ld a, (.dmark+2)  
241c 32 7c ee			ld (debug_mark+2),a  
241f 18 03			jr .pastdmark  
2421 ..			.dmark: db "UWR"  
2424 f1			.pastdmark: pop af  
2425			endm  
# End of macro DMARK
2425					CALLMONITOR 
2425 cd 80 13			call break_point_state  
2428				endm  
# End of macro CALLMONITOR
2428				endif 
2428 21 ed 57				ld hl, baseram 
242b					;ld hl, baseusermem 
242b 01 00 00				ld bc, 0    ; start a counter 
242e			 
242e				; skip dict stub 
242e			 
242e cd 5c 1c				call forth_tok_next 
2431			 
2431			 
2431			; while we have words to look for 
2431			 
2431 7e			.douscan:	ld a, (hl)      
2432				if DEBUG_FORTH_WORDS 
2432					DMARK "UWs" 
2432 f5				push af  
2433 3a 47 24			ld a, (.dmark)  
2436 32 7a ee			ld (debug_mark),a  
2439 3a 48 24			ld a, (.dmark+1)  
243c 32 7b ee			ld (debug_mark+1),a  
243f 3a 49 24			ld a, (.dmark+2)  
2442 32 7c ee			ld (debug_mark+2),a  
2445 18 03			jr .pastdmark  
2447 ..			.dmark: db "UWs"  
244a f1			.pastdmark: pop af  
244b			endm  
# End of macro DMARK
244b					CALLMONITOR 
244b cd 80 13			call break_point_state  
244e				endm  
# End of macro CALLMONITOR
244e				endif 
244e fe 00				cp WORD_SYS_END 
2450 28 4d				jr z, .udone 
2452 fe 01				cp WORD_SYS_UWORD 
2454 20 44				jr nz, .nuword 
2456			 
2456				if DEBUG_FORTH_WORDS 
2456					DMARK "UWu" 
2456 f5				push af  
2457 3a 6b 24			ld a, (.dmark)  
245a 32 7a ee			ld (debug_mark),a  
245d 3a 6c 24			ld a, (.dmark+1)  
2460 32 7b ee			ld (debug_mark+1),a  
2463 3a 6d 24			ld a, (.dmark+2)  
2466 32 7c ee			ld (debug_mark+2),a  
2469 18 03			jr .pastdmark  
246b ..			.dmark: db "UWu"  
246e f1			.pastdmark: pop af  
246f			endm  
# End of macro DMARK
246f					CALLMONITOR 
246f cd 80 13			call break_point_state  
2472				endm  
# End of macro CALLMONITOR
2472				endif 
2472					; we have a uword so push its name to the stack 
2472			 
2472 e5				   	push hl  ; save so we can move to next dict block 
2473			 
2473					; skip opcode 
2473 23					inc hl  
2474					; skip next ptr 
2474 23					inc hl  
2475 23					inc hl 
2476					; skip len 
2476 23					inc hl 
2477				if DEBUG_FORTH_WORDS 
2477					DMARK "UWt" 
2477 f5				push af  
2478 3a 8c 24			ld a, (.dmark)  
247b 32 7a ee			ld (debug_mark),a  
247e 3a 8d 24			ld a, (.dmark+1)  
2481 32 7b ee			ld (debug_mark+1),a  
2484 3a 8e 24			ld a, (.dmark+2)  
2487 32 7c ee			ld (debug_mark+2),a  
248a 18 03			jr .pastdmark  
248c ..			.dmark: db "UWt"  
248f f1			.pastdmark: pop af  
2490			endm  
# End of macro DMARK
2490					CALLMONITOR 
2490 cd 80 13			call break_point_state  
2493				endm  
# End of macro CALLMONITOR
2493				endif 
2493 03					inc bc 
2494			 
2494 c5					push bc 
2495 cd 2c 19				call forth_push_str 
2498 c1					pop bc 
2499			 
2499 e1					pop hl 	 
249a			 
249a cd 5c 1c		.nuword:	call forth_tok_next 
249d 18 92				jr .douscan  
249f			 
249f			.udone:		 ; push count of uwords found 
249f c5					push bc 
24a0 e1					pop hl 
24a1			 
24a1				if DEBUG_FORTH_WORDS 
24a1					DMARK "UWc" 
24a1 f5				push af  
24a2 3a b6 24			ld a, (.dmark)  
24a5 32 7a ee			ld (debug_mark),a  
24a8 3a b7 24			ld a, (.dmark+1)  
24ab 32 7b ee			ld (debug_mark+1),a  
24ae 3a b8 24			ld a, (.dmark+2)  
24b1 32 7c ee			ld (debug_mark+2),a  
24b4 18 03			jr .pastdmark  
24b6 ..			.dmark: db "UWc"  
24b9 f1			.pastdmark: pop af  
24ba			endm  
# End of macro DMARK
24ba					CALLMONITOR 
24ba cd 80 13			call break_point_state  
24bd				endm  
# End of macro CALLMONITOR
24bd				endif 
24bd cd 1a 19				call forth_push_numhl 
24c0			 
24c0			 
24c0				       NEXTW 
24c0 c3 0b 1b			jp macro_next 
24c3				endm 
# End of macro NEXTW
24c3			 
24c3			.BP: 
24c3				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
24c3 54				db WORD_SYS_CORE+64             
24c4 f9 24			dw .MONITOR            
24c6 03				db 2 + 1 
24c7 .. 00			db "BP",0              
24ca				endm 
# End of macro CWHEAD
24ca			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
24ca			; | | $00 Will enable the break points within specific code paths 
24ca			; | | $01 Will disable break points 
24ca			; | |  
24ca			; | | By default break points are off. Either the above can be used to enable them 
24ca			; | | or if a key is held down during start up the spashscreen will appear to freeze 
24ca			; | | and on release of the pressed key a message will be disaplayed to notify 
24ca			; | | that break points are enabled. Pressing any key will then continue boot process. 
24ca					; get byte count 
24ca					if DEBUG_FORTH_WORDS_KEY 
24ca						DMARK "BP." 
24ca f5				push af  
24cb 3a df 24			ld a, (.dmark)  
24ce 32 7a ee			ld (debug_mark),a  
24d1 3a e0 24			ld a, (.dmark+1)  
24d4 32 7b ee			ld (debug_mark+1),a  
24d7 3a e1 24			ld a, (.dmark+2)  
24da 32 7c ee			ld (debug_mark+2),a  
24dd 18 03			jr .pastdmark  
24df ..			.dmark: db "BP."  
24e2 f1			.pastdmark: pop af  
24e3			endm  
# End of macro DMARK
24e3						CALLMONITOR 
24e3 cd 80 13			call break_point_state  
24e6				endm  
# End of macro CALLMONITOR
24e6					endif 
24e6			 
24e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24e6 cd b5 19			call macro_dsp_valuehl 
24e9				endm 
# End of macro FORTH_DSP_VALUEHL
24e9			 
24e9			;		push hl 
24e9			 
24e9					; destroy value TOS 
24e9			 
24e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24e9 cd 51 1a			call macro_forth_dsp_pop 
24ec				endm 
# End of macro FORTH_DSP_POP
24ec			 
24ec			;		pop hl 
24ec			 
24ec 3e 00				ld a,0 
24ee bd					cp l 
24ef 28 02				jr z, .bpset 
24f1 3e 2a				ld a, '*' 
24f3			 
24f3 32 74 e3		.bpset:		ld (os_view_disable), a 
24f6			 
24f6			 
24f6					NEXTW 
24f6 c3 0b 1b			jp macro_next 
24f9				endm 
# End of macro NEXTW
24f9			 
24f9			 
24f9			.MONITOR: 
24f9				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
24f9 55				db WORD_SYS_CORE+65             
24fa 2c 25			dw .MALLOC            
24fc 08				db 7 + 1 
24fd .. 00			db "MONITOR",0              
2505				endm 
# End of macro CWHEAD
2505			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2505			; | | At start the current various registers will be displayed with contents. 
2505			; | | Top right corner will show the most recent debug marker seen. 
2505			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2505			; | | and the return stack pointer (RSP). 
2505			; | | Pressing: 
2505			; | |    1 - Initial screen 
2505			; | |    2 - Display a data dump of HL 
2505			; | |    3 - Display a data dump of DE 
2505			; | |    4 - Display a data dump of BC 
2505			; | |    5 - Display a data dump of HL 
2505			; | |    6 - Display a data dump of DSP 
2505			; | |    7 - Display a data dump of RSP 
2505			; | |    8 - Display a data dump of what is at DSP 
2505			; | |    9 - Display a data dump of what is at RSP 
2505			; | |    0 - Exit monitor and continue running. This will also enable break points 
2505			; | |    * - Disable break points 
2505			; | |    # - Enter traditional monitor mode 
2505			; | | 
2505			; | | Monitor Mode 
2505			; | | ------------ 
2505			; | | A prompt of '>' will be shown for various commands: 
2505			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2505			; | |    C - Continue display a data dump from the last set address 
2505			; | |    M xxxx - Set start of memory edit at address xx 
2505			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2505			; | |    Q - Return to previous 
2505					if DEBUG_FORTH_WORDS_KEY 
2505						DMARK "MON" 
2505 f5				push af  
2506 3a 1a 25			ld a, (.dmark)  
2509 32 7a ee			ld (debug_mark),a  
250c 3a 1b 25			ld a, (.dmark+1)  
250f 32 7b ee			ld (debug_mark+1),a  
2512 3a 1c 25			ld a, (.dmark+2)  
2515 32 7c ee			ld (debug_mark+2),a  
2518 18 03			jr .pastdmark  
251a ..			.dmark: db "MON"  
251d f1			.pastdmark: pop af  
251e			endm  
# End of macro DMARK
251e						CALLMONITOR 
251e cd 80 13			call break_point_state  
2521				endm  
# End of macro CALLMONITOR
2521					endif 
2521 3e 00				ld a, 0 
2523 32 74 e3				ld (os_view_disable), a 
2526			 
2526					CALLMONITOR 
2526 cd 80 13			call break_point_state  
2529				endm  
# End of macro CALLMONITOR
2529			 
2529			;	call monitor 
2529			 
2529					NEXTW 
2529 c3 0b 1b			jp macro_next 
252c				endm 
# End of macro NEXTW
252c			 
252c			 
252c			.MALLOC: 
252c				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
252c 56				db WORD_SYS_CORE+66             
252d 55 25			dw .MALLOC2            
252f 06				db 5 + 1 
2530 .. 00			db "ALLOT",0              
2536				endm 
# End of macro CWHEAD
2536			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2536					if DEBUG_FORTH_WORDS_KEY 
2536						DMARK "ALL" 
2536 f5				push af  
2537 3a 4b 25			ld a, (.dmark)  
253a 32 7a ee			ld (debug_mark),a  
253d 3a 4c 25			ld a, (.dmark+1)  
2540 32 7b ee			ld (debug_mark+1),a  
2543 3a 4d 25			ld a, (.dmark+2)  
2546 32 7c ee			ld (debug_mark+2),a  
2549 18 03			jr .pastdmark  
254b ..			.dmark: db "ALL"  
254e f1			.pastdmark: pop af  
254f			endm  
# End of macro DMARK
254f						CALLMONITOR 
254f cd 80 13			call break_point_state  
2552				endm  
# End of macro CALLMONITOR
2552					endif 
2552 c3 7c 25				jp .mallocc 
2555			.MALLOC2: 
2555				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2555 56				db WORD_SYS_CORE+66             
2556 93 25			dw .FREE            
2558 07				db 6 + 1 
2559 .. 00			db "MALLOC",0              
2560				endm 
# End of macro CWHEAD
2560			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2560					; get byte count 
2560					if DEBUG_FORTH_WORDS_KEY 
2560						DMARK "MAL" 
2560 f5				push af  
2561 3a 75 25			ld a, (.dmark)  
2564 32 7a ee			ld (debug_mark),a  
2567 3a 76 25			ld a, (.dmark+1)  
256a 32 7b ee			ld (debug_mark+1),a  
256d 3a 77 25			ld a, (.dmark+2)  
2570 32 7c ee			ld (debug_mark+2),a  
2573 18 03			jr .pastdmark  
2575 ..			.dmark: db "MAL"  
2578 f1			.pastdmark: pop af  
2579			endm  
# End of macro DMARK
2579						CALLMONITOR 
2579 cd 80 13			call break_point_state  
257c				endm  
# End of macro CALLMONITOR
257c					endif 
257c			.mallocc: 
257c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
257c cd b5 19			call macro_dsp_valuehl 
257f				endm 
# End of macro FORTH_DSP_VALUEHL
257f			 
257f			;		push hl 
257f			 
257f					; destroy value TOS 
257f			 
257f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
257f cd 51 1a			call macro_forth_dsp_pop 
2582				endm 
# End of macro FORTH_DSP_POP
2582			 
2582			;		pop hl 
2582 cd 2f 10				call malloc 
2585				if DEBUG_FORTH_MALLOC_GUARD 
2585 f5					push af 
2586 cd 91 0b				call ishlzero 
2589			;		ld a, l 
2589			;		add h 
2589			;		cp 0 
2589 f1					pop af 
258a					 
258a cc 4a 44				call z,malloc_error 
258d				endif 
258d			 
258d cd 1a 19				call forth_push_numhl 
2590					NEXTW 
2590 c3 0b 1b			jp macro_next 
2593				endm 
# End of macro NEXTW
2593			 
2593			.FREE: 
2593				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2593 57				db WORD_SYS_CORE+67             
2594 c4 25			dw .LIST            
2596 05				db 4 + 1 
2597 .. 00			db "FREE",0              
259c				endm 
# End of macro CWHEAD
259c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
259c					if DEBUG_FORTH_WORDS_KEY 
259c						DMARK "FRE" 
259c f5				push af  
259d 3a b1 25			ld a, (.dmark)  
25a0 32 7a ee			ld (debug_mark),a  
25a3 3a b2 25			ld a, (.dmark+1)  
25a6 32 7b ee			ld (debug_mark+1),a  
25a9 3a b3 25			ld a, (.dmark+2)  
25ac 32 7c ee			ld (debug_mark+2),a  
25af 18 03			jr .pastdmark  
25b1 ..			.dmark: db "FRE"  
25b4 f1			.pastdmark: pop af  
25b5			endm  
# End of macro DMARK
25b5						CALLMONITOR 
25b5 cd 80 13			call break_point_state  
25b8				endm  
# End of macro CALLMONITOR
25b8					endif 
25b8					; get address 
25b8			 
25b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b8 cd b5 19			call macro_dsp_valuehl 
25bb				endm 
# End of macro FORTH_DSP_VALUEHL
25bb			 
25bb			;		push hl 
25bb			 
25bb					; destroy value TOS 
25bb			 
25bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25bb cd 51 1a			call macro_forth_dsp_pop 
25be				endm 
# End of macro FORTH_DSP_POP
25be			 
25be			;		pop hl 
25be			if FORTH_ENABLE_MALLOCFREE 
25be cd f9 10				call free 
25c1			endif 
25c1					NEXTW 
25c1 c3 0b 1b			jp macro_next 
25c4				endm 
# End of macro NEXTW
25c4			.LIST: 
25c4				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
25c4 5c				db WORD_SYS_CORE+72             
25c5 87 27			dw .FORGET            
25c7 05				db 4 + 1 
25c8 .. 00			db "LIST",0              
25cd				endm 
# End of macro CWHEAD
25cd			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
25cd			; | | The quoted word must be in upper case. 
25cd				if DEBUG_FORTH_WORDS_KEY 
25cd					DMARK "LST" 
25cd f5				push af  
25ce 3a e2 25			ld a, (.dmark)  
25d1 32 7a ee			ld (debug_mark),a  
25d4 3a e3 25			ld a, (.dmark+1)  
25d7 32 7b ee			ld (debug_mark+1),a  
25da 3a e4 25			ld a, (.dmark+2)  
25dd 32 7c ee			ld (debug_mark+2),a  
25e0 18 03			jr .pastdmark  
25e2 ..			.dmark: db "LST"  
25e5 f1			.pastdmark: pop af  
25e6			endm  
# End of macro DMARK
25e6					CALLMONITOR 
25e6 cd 80 13			call break_point_state  
25e9				endm  
# End of macro CALLMONITOR
25e9				endif 
25e9			 
25e9					FORTH_DSP_VALUEHL 
25e9 cd b5 19			call macro_dsp_valuehl 
25ec				endm 
# End of macro FORTH_DSP_VALUEHL
25ec			 
25ec e5					push hl 
25ed c1					pop bc 
25ee			 
25ee			; Start format of scratch string 
25ee			 
25ee 21 75 e3				ld hl, scratch 
25f1			 
25f1 3e 3a				ld a, ':' 
25f3 77					ld (hl),a 
25f4 23					inc hl 
25f5 3e 20				ld a, ' ' 
25f7 77					ld (hl), a 
25f8			 
25f8					; Get ptr to the word we need to look up 
25f8			 
25f8			;		FORTH_DSP_VALUEHL 
25f8					;v5 FORTH_DSP_VALUE 
25f8				; TODO type check 
25f8			;		inc hl    ; Skip type check  
25f8			;		push hl 
25f8			;		ex de, hl    ; put into DE 
25f8			 
25f8			 
25f8 21 ed 57				ld hl, baseram 
25fb					;ld hl, baseusermem 
25fb			 
25fb e5			push hl   ; sacreifical push 
25fc			 
25fc			.ldouscanm: 
25fc e1				pop hl 
25fd			.ldouscan: 
25fd				if DEBUG_FORTH_WORDS 
25fd					DMARK "LSs" 
25fd f5				push af  
25fe 3a 12 26			ld a, (.dmark)  
2601 32 7a ee			ld (debug_mark),a  
2604 3a 13 26			ld a, (.dmark+1)  
2607 32 7b ee			ld (debug_mark+1),a  
260a 3a 14 26			ld a, (.dmark+2)  
260d 32 7c ee			ld (debug_mark+2),a  
2610 18 03			jr .pastdmark  
2612 ..			.dmark: db "LSs"  
2615 f1			.pastdmark: pop af  
2616			endm  
# End of macro DMARK
2616					CALLMONITOR 
2616 cd 80 13			call break_point_state  
2619				endm  
# End of macro CALLMONITOR
2619				endif 
2619				; skip dict stub 
2619 cd 5c 1c				call forth_tok_next 
261c			 
261c			 
261c			; while we have words to look for 
261c			 
261c 7e				ld a, (hl)      
261d				if DEBUG_FORTH_WORDS 
261d					DMARK "LSk" 
261d f5				push af  
261e 3a 32 26			ld a, (.dmark)  
2621 32 7a ee			ld (debug_mark),a  
2624 3a 33 26			ld a, (.dmark+1)  
2627 32 7b ee			ld (debug_mark+1),a  
262a 3a 34 26			ld a, (.dmark+2)  
262d 32 7c ee			ld (debug_mark+2),a  
2630 18 03			jr .pastdmark  
2632 ..			.dmark: db "LSk"  
2635 f1			.pastdmark: pop af  
2636			endm  
# End of macro DMARK
2636					CALLMONITOR 
2636 cd 80 13			call break_point_state  
2639				endm  
# End of macro CALLMONITOR
2639				endif 
2639 fe 00				cp WORD_SYS_END 
263b ca 6e 27				jp z, .lunotfound 
263e fe 01				cp WORD_SYS_UWORD 
2640 c2 fd 25				jp nz, .ldouscan 
2643			 
2643				if DEBUG_FORTH_WORDS 
2643					DMARK "LSu" 
2643 f5				push af  
2644 3a 58 26			ld a, (.dmark)  
2647 32 7a ee			ld (debug_mark),a  
264a 3a 59 26			ld a, (.dmark+1)  
264d 32 7b ee			ld (debug_mark+1),a  
2650 3a 5a 26			ld a, (.dmark+2)  
2653 32 7c ee			ld (debug_mark+2),a  
2656 18 03			jr .pastdmark  
2658 ..			.dmark: db "LSu"  
265b f1			.pastdmark: pop af  
265c			endm  
# End of macro DMARK
265c					CALLMONITOR 
265c cd 80 13			call break_point_state  
265f				endm  
# End of macro CALLMONITOR
265f				endif 
265f			 
265f					; found a uword but is it the one we want... 
265f			 
265f c5					push bc     ; uword to find is on bc 
2660 d1					pop de 
2661			 
2661 e5					push hl  ; to save the ptr 
2662			 
2662					; skip opcode 
2662 23					inc hl  
2663					; skip next ptr 
2663 23					inc hl  
2664 23					inc hl 
2665					; skip len 
2665 23					inc hl 
2666			 
2666				if DEBUG_FORTH_WORDS 
2666					DMARK "LSc" 
2666 f5				push af  
2667 3a 7b 26			ld a, (.dmark)  
266a 32 7a ee			ld (debug_mark),a  
266d 3a 7c 26			ld a, (.dmark+1)  
2670 32 7b ee			ld (debug_mark+1),a  
2673 3a 7d 26			ld a, (.dmark+2)  
2676 32 7c ee			ld (debug_mark+2),a  
2679 18 03			jr .pastdmark  
267b ..			.dmark: db "LSc"  
267e f1			.pastdmark: pop af  
267f			endm  
# End of macro DMARK
267f					CALLMONITOR 
267f cd 80 13			call break_point_state  
2682				endm  
# End of macro CALLMONITOR
2682				endif 
2682 cd fe 0f				call strcmp 
2685 c2 fc 25				jp nz, .ldouscanm 
2688				 
2688			 
2688			 
2688					; we have a uword so push its name to the stack 
2688			 
2688			;	   	push hl  ; save so we can move to next dict block 
2688 e1			pop hl 
2689			 
2689				if DEBUG_FORTH_WORDS 
2689					DMARK "LSm" 
2689 f5				push af  
268a 3a 9e 26			ld a, (.dmark)  
268d 32 7a ee			ld (debug_mark),a  
2690 3a 9f 26			ld a, (.dmark+1)  
2693 32 7b ee			ld (debug_mark+1),a  
2696 3a a0 26			ld a, (.dmark+2)  
2699 32 7c ee			ld (debug_mark+2),a  
269c 18 03			jr .pastdmark  
269e ..			.dmark: db "LSm"  
26a1 f1			.pastdmark: pop af  
26a2			endm  
# End of macro DMARK
26a2					CALLMONITOR 
26a2 cd 80 13			call break_point_state  
26a5				endm  
# End of macro CALLMONITOR
26a5				endif 
26a5			 
26a5					; skip opcode 
26a5 23					inc hl  
26a6					; skip next ptr 
26a6 23					inc hl  
26a7 23					inc hl 
26a8					; skip len 
26a8 7e					ld a, (hl)   ; save length to add 
26a9				if DEBUG_FORTH_WORDS 
26a9					DMARK "LS2" 
26a9 f5				push af  
26aa 3a be 26			ld a, (.dmark)  
26ad 32 7a ee			ld (debug_mark),a  
26b0 3a bf 26			ld a, (.dmark+1)  
26b3 32 7b ee			ld (debug_mark+1),a  
26b6 3a c0 26			ld a, (.dmark+2)  
26b9 32 7c ee			ld (debug_mark+2),a  
26bc 18 03			jr .pastdmark  
26be ..			.dmark: db "LS2"  
26c1 f1			.pastdmark: pop af  
26c2			endm  
# End of macro DMARK
26c2					CALLMONITOR 
26c2 cd 80 13			call break_point_state  
26c5				endm  
# End of macro CALLMONITOR
26c5				endif 
26c5			 
26c5					; save this location 
26c5				 
26c5 e5					push hl 
26c6			 
26c6 23					inc hl 
26c7 11 77 e3				ld de, scratch+2 
26ca 4f					ld c, a 
26cb 06 00				ld b, 0 
26cd			 
26cd				if DEBUG_FORTH_WORDS 
26cd					DMARK "LSn" 
26cd f5				push af  
26ce 3a e2 26			ld a, (.dmark)  
26d1 32 7a ee			ld (debug_mark),a  
26d4 3a e3 26			ld a, (.dmark+1)  
26d7 32 7b ee			ld (debug_mark+1),a  
26da 3a e4 26			ld a, (.dmark+2)  
26dd 32 7c ee			ld (debug_mark+2),a  
26e0 18 03			jr .pastdmark  
26e2 ..			.dmark: db "LSn"  
26e5 f1			.pastdmark: pop af  
26e6			endm  
# End of macro DMARK
26e6					CALLMONITOR 
26e6 cd 80 13			call break_point_state  
26e9				endm  
# End of macro CALLMONITOR
26e9				endif 
26e9			 
26e9					; copy uword name to scratch 
26e9			 
26e9 ed b0				ldir 
26eb			 
26eb 1b					dec de 
26ec 3e 20				ld a, ' '    ; change null to space 
26ee 12					ld (de), a 
26ef			 
26ef 13					inc de 
26f0			 
26f0 d5					push de 
26f1 c1					pop bc     ; move scratch pointer to end of word name and save it 
26f2			 
26f2 e1					pop hl 
26f3 7e					ld a, (hl) 
26f4					;inc hl 
26f4					; skip word string 
26f4 cd 68 0b				call addatohl 
26f7			 
26f7 23					inc hl 
26f8			 
26f8				if DEBUG_FORTH_WORDS 
26f8					DMARK "LS3" 
26f8 f5				push af  
26f9 3a 0d 27			ld a, (.dmark)  
26fc 32 7a ee			ld (debug_mark),a  
26ff 3a 0e 27			ld a, (.dmark+1)  
2702 32 7b ee			ld (debug_mark+1),a  
2705 3a 0f 27			ld a, (.dmark+2)  
2708 32 7c ee			ld (debug_mark+2),a  
270b 18 03			jr .pastdmark  
270d ..			.dmark: db "LS3"  
2710 f1			.pastdmark: pop af  
2711			endm  
# End of macro DMARK
2711					CALLMONITOR 
2711 cd 80 13			call break_point_state  
2714				endm  
# End of macro CALLMONITOR
2714				endif 
2714					; should now be at the start of the machine code to setup the eval of the uword 
2714					; now locate the ptr to the string defintion 
2714			 
2714					; skip ld hl, 
2714					; then load the ptr 
2714			 
2714 23					inc hl 
2715 5e					ld e, (hl) 
2716 23					inc hl 
2717 56					ld d, (hl) 
2718 eb					ex de, hl 
2719			 
2719			 
2719				if DEBUG_FORTH_WORDS 
2719					DMARK "LSt" 
2719 f5				push af  
271a 3a 2e 27			ld a, (.dmark)  
271d 32 7a ee			ld (debug_mark),a  
2720 3a 2f 27			ld a, (.dmark+1)  
2723 32 7b ee			ld (debug_mark+1),a  
2726 3a 30 27			ld a, (.dmark+2)  
2729 32 7c ee			ld (debug_mark+2),a  
272c 18 03			jr .pastdmark  
272e ..			.dmark: db "LSt"  
2731 f1			.pastdmark: pop af  
2732			endm  
# End of macro DMARK
2732					CALLMONITOR 
2732 cd 80 13			call break_point_state  
2735				endm  
# End of macro CALLMONITOR
2735				endif 
2735			 
2735			; cant push right now due to tokenised strings  
2735			 
2735			; get the destination of where to copy this definition to. 
2735			 
2735 c5					push bc 
2736 d1					pop de 
2737			 
2737 7e			.listl:         ld a,(hl) 
2738 fe 00				cp 0 
273a 28 09				jr z, .lreplsp     ; replace zero with space 
273c fe 7f				cp FORTH_END_BUFFER 
273e 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2740				 
2740					; just copy this char as is then 
2740			 
2740 12					ld (de), a 
2741			 
2741 23			.listnxt:	inc hl 
2742 13					inc de 
2743 18 f2				jr .listl 
2745			 
2745 3e 20		.lreplsp:	ld a,' ' 
2747 12					ld (de), a 
2748 18 f7				jr .listnxt 
274a			 
274a			; close up uword def 
274a			 
274a			.listdone: 
274a 3e 00				ld a, 0 
274c 12					ld (de), a 
274d			 
274d			; now have def so clean up and push to stack 
274d			 
274d 21 75 e3				ld hl, scratch 
2750				if DEBUG_FORTH_WORDS 
2750					DMARK "Ltp" 
2750 f5				push af  
2751 3a 65 27			ld a, (.dmark)  
2754 32 7a ee			ld (debug_mark),a  
2757 3a 66 27			ld a, (.dmark+1)  
275a 32 7b ee			ld (debug_mark+1),a  
275d 3a 67 27			ld a, (.dmark+2)  
2760 32 7c ee			ld (debug_mark+2),a  
2763 18 03			jr .pastdmark  
2765 ..			.dmark: db "Ltp"  
2768 f1			.pastdmark: pop af  
2769			endm  
# End of macro DMARK
2769					CALLMONITOR 
2769 cd 80 13			call break_point_state  
276c				endm  
# End of macro CALLMONITOR
276c				endif 
276c			 
276c 18 06			jr .listpush 
276e			 
276e			;.lnuword:	pop hl 
276e			;		call forth_tok_next 
276e			;		jp .ldouscan  
276e			 
276e			.lunotfound:		  
276e			 
276e			 
276e					 
276e					FORTH_DSP_POP 
276e cd 51 1a			call macro_forth_dsp_pop 
2771				endm 
# End of macro FORTH_DSP_POP
2771 21 7a 27				ld hl, .luno 
2774						 
2774			 
2774			.listpush: 
2774 cd 2c 19				call forth_push_str 
2777			 
2777			 
2777			 
2777					NEXTW 
2777 c3 0b 1b			jp macro_next 
277a				endm 
# End of macro NEXTW
277a			 
277a .. 00		.luno:    db "Not found",0 
2784			 
2784			 
2784			 
2784			 
2784			 
2784			;		push hl   ; save pointer to start of uword def string 
2784			; 
2784			;; look for FORTH_EOL_LINE 
2784			;		ld a, FORTH_END_BUFFER 
2784			;		call strlent 
2784			; 
2784			;		inc hl		 ; space for coln def 
2784			;		inc hl 
2784			;		inc hl          ; space for terms 
2784			;		inc hl 
2784			; 
2784			;		ld a, 20   ; TODO get actual length 
2784			;		call addatohl    ; include a random amount of room for the uword name 
2784			; 
2784			;		 
2784			;	if DEBUG_FORTH_WORDS 
2784			;		DMARK "Lt1" 
2784			;		CALLMONITOR 
2784			;	endif 
2784			;		 
2784			; 
2784			;; malloc space for the string because we cant change it 
2784			; 
2784			;		call malloc 
2784			;	if DEBUG_FORTH_MALLOC_GUARD 
2784			;		push af 
2784			;		call ishlzero 
2784			;		pop af 
2784			;		 
2784			;		call z,malloc_error 
2784			;	endif 
2784			; 
2784			;	if DEBUG_FORTH_WORDS 
2784			;		DMARK "Lt2" 
2784			;		CALLMONITOR 
2784			;	endif 
2784			;		pop de 
2784			;		push hl    ; push the malloc to release later 
2784			;		push hl   ;  push back a copy for the later stack push 
2784			;		 
2784			;; copy the string swapping out the zero terms for spaces 
2784			; 
2784			;		; de has our source 
2784			;		; hl has our dest 
2784			; 
2784			;; add the coln def 
2784			; 
2784			;		ld a, ':' 
2784			;		ld (hl), a 
2784			;		inc hl 
2784			;		ld a, ' ' 
2784			;		ld (hl), a 
2784			;		inc hl 
2784			; 
2784			;; add the uname word 
2784			;		push de   ; save our string for now 
2784			;		ex de, hl 
2784			; 
2784			;		FORTH_DSP_VALUE 
2784			;		;v5 FORTH_DSP_VALUE 
2784			; 
2784			;		inc hl   ; skip type but we know by now this is OK 
2784			; 
2784			;.luword:	ld a,(hl) 
2784			;		cp 0 
2784			;		jr z, .luword2 
2784			;		ld (de), a 
2784			;		inc de 
2784			;		inc hl 
2784			;		jr .luword 
2784			; 
2784			;.luword2:	ld a, ' ' 
2784			;		ld (de), a 
2784			;;		inc hl 
2784			;;		inc de 
2784			;;		ld (de), a 
2784			;;		inc hl 
2784			;		inc de 
2784			; 
2784			;		ex de, hl 
2784			;		pop de 
2784			;		 
2784			;		 
2784			; 
2784			;; detoken that string and copy it 
2784			; 
2784			;	if DEBUG_FORTH_WORDS 
2784			;		DMARK "Lt2" 
2784			;		CALLMONITOR 
2784			;	endif 
2784			;.ldetok:	ld a, (de) 
2784			;		cp FORTH_END_BUFFER 
2784			;		jr z, .ldetokend 
2784			;		; swap out any zero term for space 
2784			;		cp 0 
2784			;		jr nz, .ldetoknext 
2784			;		ld a, ' ' 
2784			; 
2784			;	if DEBUG_FORTH_WORDS 
2784			;		DMARK "LtS" 
2784			;		CALLMONITOR 
2784			;	endif 
2784			;.ldetoknext:	ld (hl), a 
2784			;		inc de 
2784			;		inc hl 
2784			;		jr .ldetok 
2784			; 
2784			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2784			;		ld (hl), a  
2784			; 
2784			;; free that temp malloc 
2784			; 
2784			;		pop hl    
2784			; 
2784			;	if DEBUG_FORTH_WORDS 
2784			;		DMARK "Lt4" 
2784			;		CALLMONITOR 
2784			;	endif 
2784			;		call forth_apushstrhl 
2784			; 
2784			;		; get rid of temp malloc area 
2784			; 
2784			;		pop hl 
2784			;		call free 
2784			; 
2784			;		jr .ludone 
2784			; 
2784			;.lnuword:	pop hl 
2784			;		call forth_tok_next 
2784			;		jp .ldouscan  
2784			; 
2784			;.ludone:		 pop hl 
2784			; 
2784					NEXTW 
2784 c3 0b 1b			jp macro_next 
2787				endm 
# End of macro NEXTW
2787			 
2787			.FORGET: 
2787				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2787 5d				db WORD_SYS_CORE+73             
2788 00 28			dw .NOP            
278a 07				db 6 + 1 
278b .. 00			db "FORGET",0              
2792				endm 
# End of macro CWHEAD
2792			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2792			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2792			; | |  
2792			; | | e.g. "MORE" forget 
2792					if DEBUG_FORTH_WORDS_KEY 
2792						DMARK "FRG" 
2792 f5				push af  
2793 3a a7 27			ld a, (.dmark)  
2796 32 7a ee			ld (debug_mark),a  
2799 3a a8 27			ld a, (.dmark+1)  
279c 32 7b ee			ld (debug_mark+1),a  
279f 3a a9 27			ld a, (.dmark+2)  
27a2 32 7c ee			ld (debug_mark+2),a  
27a5 18 03			jr .pastdmark  
27a7 ..			.dmark: db "FRG"  
27aa f1			.pastdmark: pop af  
27ab			endm  
# End of macro DMARK
27ab						CALLMONITOR 
27ab cd 80 13			call break_point_state  
27ae				endm  
# End of macro CALLMONITOR
27ae					endif 
27ae			 
27ae				; find uword 
27ae			        ; update start of word with "_" 
27ae				; replace uword with deleted flag 
27ae			 
27ae			 
27ae			;	if DEBUG_FORTH_WORDS 
27ae			;		DMARK "FOG" 
27ae			;		CALLMONITOR 
27ae			;	endif 
27ae			 
27ae			 
27ae					; Get ptr to the word we need to look up 
27ae			 
27ae					FORTH_DSP_VALUEHL 
27ae cd b5 19			call macro_dsp_valuehl 
27b1				endm 
# End of macro FORTH_DSP_VALUEHL
27b1					;v5 FORTH_DSP_VALUE 
27b1				; TODO type check 
27b1			;		inc hl    ; Skip type check  
27b1 e5					push hl 
27b2 c1					pop bc 
27b3			;		ex de, hl    ; put into DE 
27b3			 
27b3			 
27b3 21 ed 57				ld hl, baseram 
27b6					;ld hl, baseusermem 
27b6			 
27b6				; skip dict stub 
27b6			;	call forth_tok_next 
27b6 e5			push hl   ; sacreifical push 
27b7			 
27b7			.fldouscanm: 
27b7 e1				pop hl 
27b8			.fldouscan: 
27b8			;	if DEBUG_FORTH_WORDS 
27b8			;		DMARK "LSs" 
27b8			;		CALLMONITOR 
27b8			;	endif 
27b8				; skip dict stub 
27b8 cd 5c 1c				call forth_tok_next 
27bb			 
27bb			 
27bb			; while we have words to look for 
27bb			 
27bb 7e				ld a, (hl)      
27bc			;	if DEBUG_FORTH_WORDS 
27bc			;		DMARK "LSk" 
27bc			;		CALLMONITOR 
27bc			;	endif 
27bc fe 00				cp WORD_SYS_END 
27be ca fa 27				jp z, .flunotfound 
27c1 fe 01				cp WORD_SYS_UWORD 
27c3 c2 b8 27				jp nz, .fldouscan 
27c6			 
27c6			;	if DEBUG_FORTH_WORDS 
27c6			;		DMARK "LSu" 
27c6			;		CALLMONITOR 
27c6			;	endif 
27c6			 
27c6					; found a uword but is it the one we want... 
27c6			 
27c6 c5					push bc     ; uword to find is on bc 
27c7 d1					pop de 
27c8			 
27c8 e5					push hl  ; to save the ptr 
27c9			 
27c9					; skip opcode 
27c9 23					inc hl  
27ca					; skip next ptr 
27ca 23					inc hl  
27cb 23					inc hl 
27cc					; skip len 
27cc 23					inc hl 
27cd			 
27cd			;	if DEBUG_FORTH_WORDS 
27cd			;		DMARK "LSc" 
27cd			;		CALLMONITOR 
27cd			;	endif 
27cd cd fe 0f				call strcmp 
27d0 c2 b7 27				jp nz, .fldouscanm 
27d3			; 
27d3			; 
27d3			;; while we have words to look for 
27d3			; 
27d3			;.fdouscan:	ld a, (hl)      
27d3			;	if DEBUG_FORTH_WORDS 
27d3			;		DMARK "LSs" 
27d3			;		CALLMONITOR 
27d3			;	endif 
27d3			;		cp WORD_SYS_END 
27d3			;		jp z, .fudone 
27d3			;		cp WORD_SYS_UWORD 
27d3			;		jp nz, .fnuword 
27d3			; 
27d3			;	if DEBUG_FORTH_WORDS 
27d3			;		DMARK "FGu" 
27d3			;		CALLMONITOR 
27d3			;	endif 
27d3			; 
27d3			;		; found a uword but is it the one we want... 
27d3			; 
27d3			; 
27d3			;	        pop de   ; get back the dsp name 
27d3			;		push de 
27d3			; 
27d3			;		push hl  ; to save the ptr 
27d3			; 
27d3			;		; skip opcode 
27d3			;		inc hl  
27d3			;		; skip next ptr 
27d3			;		inc hl  
27d3			;		inc hl 
27d3			;		; skip len 
27d3			;		inc hl 
27d3			; 
27d3			;	if DEBUG_FORTH_WORDS 
27d3			;		DMARK "FGc" 
27d3			;		CALLMONITOR 
27d3			;	endif 
27d3			;		call strcmp 
27d3			;		jp nz, .fnuword 
27d3			 
27d3			 
27d3 e1			pop hl 
27d4			 
27d4				 
27d4				if DEBUG_FORTH_WORDS 
27d4					DMARK "FGm" 
27d4 f5				push af  
27d5 3a e9 27			ld a, (.dmark)  
27d8 32 7a ee			ld (debug_mark),a  
27db 3a ea 27			ld a, (.dmark+1)  
27de 32 7b ee			ld (debug_mark+1),a  
27e1 3a eb 27			ld a, (.dmark+2)  
27e4 32 7c ee			ld (debug_mark+2),a  
27e7 18 03			jr .pastdmark  
27e9 ..			.dmark: db "FGm"  
27ec f1			.pastdmark: pop af  
27ed			endm  
# End of macro DMARK
27ed					CALLMONITOR 
27ed cd 80 13			call break_point_state  
27f0				endm  
# End of macro CALLMONITOR
27f0				endif 
27f0			 
27f0			 
27f0			 
27f0					; we have a uword so push its name to the stack 
27f0			 
27f0			;	   	push hl  ; save so we can move to next dict block 
27f0			;pop hl 
27f0			 
27f0					; update opcode to deleted 
27f0 3e 03				ld a, WORD_SYS_DELETED 
27f2 77					ld (hl), a 
27f3			 
27f3 23					inc hl  
27f4					; skip next ptr 
27f4 23					inc hl  
27f5 23					inc hl 
27f6					; skip len 
27f6 23					inc hl 
27f7			 
27f7					; TODO change parser to skip deleted words but for now mark it out 
27f7 3e 5f				ld a, "_" 
27f9 77					ld  (hl),a 
27fa			 
27fa			;		jr .fudone 
27fa			; 
27fa			;.fnuword:	pop hl 
27fa			;		call forth_tok_next 
27fa			;		jp .fdouscan  
27fa			 
27fa			.flunotfound:		  
27fa			 
27fa			 
27fa					 
27fa					FORTH_DSP_POP 
27fa cd 51 1a			call macro_forth_dsp_pop 
27fd				endm 
# End of macro FORTH_DSP_POP
27fd			;		ld hl, .luno 
27fd			;.fudone:		 pop hl 
27fd					NEXTW 
27fd c3 0b 1b			jp macro_next 
2800				endm 
# End of macro NEXTW
2800			.NOP: 
2800				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2800 61				db WORD_SYS_CORE+77             
2801 27 28			dw .COMO            
2803 04				db 3 + 1 
2804 .. 00			db "NOP",0              
2808				endm 
# End of macro CWHEAD
2808			; | NOP (  --  ) Do nothing | DONE 
2808					if DEBUG_FORTH_WORDS_KEY 
2808						DMARK "NOP" 
2808 f5				push af  
2809 3a 1d 28			ld a, (.dmark)  
280c 32 7a ee			ld (debug_mark),a  
280f 3a 1e 28			ld a, (.dmark+1)  
2812 32 7b ee			ld (debug_mark+1),a  
2815 3a 1f 28			ld a, (.dmark+2)  
2818 32 7c ee			ld (debug_mark+2),a  
281b 18 03			jr .pastdmark  
281d ..			.dmark: db "NOP"  
2820 f1			.pastdmark: pop af  
2821			endm  
# End of macro DMARK
2821						CALLMONITOR 
2821 cd 80 13			call break_point_state  
2824				endm  
# End of macro CALLMONITOR
2824					endif 
2824				       NEXTW 
2824 c3 0b 1b			jp macro_next 
2827				endm 
# End of macro NEXTW
2827			.COMO: 
2827				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2827 6e				db WORD_SYS_CORE+90             
2828 79 28			dw .COMC            
282a 02				db 1 + 1 
282b .. 00			db "(",0              
282d				endm 
# End of macro CWHEAD
282d			; | ( ( -- )  Start of comment | DONE 
282d			 
282d			 
282d 2a 76 e6				ld hl, ( os_tok_ptr) 
2830 11 74 28			ld de, .closepar 
2833					 
2833					if DEBUG_FORTH_WORDS 
2833						DMARK ").." 
2833 f5				push af  
2834 3a 48 28			ld a, (.dmark)  
2837 32 7a ee			ld (debug_mark),a  
283a 3a 49 28			ld a, (.dmark+1)  
283d 32 7b ee			ld (debug_mark+1),a  
2840 3a 4a 28			ld a, (.dmark+2)  
2843 32 7c ee			ld (debug_mark+2),a  
2846 18 03			jr .pastdmark  
2848 ..			.dmark: db ").."  
284b f1			.pastdmark: pop af  
284c			endm  
# End of macro DMARK
284c						CALLMONITOR 
284c cd 80 13			call break_point_state  
284f				endm  
# End of macro CALLMONITOR
284f					endif 
284f cd 26 1c			call findnexttok  
2852			 
2852					if DEBUG_FORTH_WORDS 
2852						DMARK "IF5" 
2852 f5				push af  
2853 3a 67 28			ld a, (.dmark)  
2856 32 7a ee			ld (debug_mark),a  
2859 3a 68 28			ld a, (.dmark+1)  
285c 32 7b ee			ld (debug_mark+1),a  
285f 3a 69 28			ld a, (.dmark+2)  
2862 32 7c ee			ld (debug_mark+2),a  
2865 18 03			jr .pastdmark  
2867 ..			.dmark: db "IF5"  
286a f1			.pastdmark: pop af  
286b			endm  
# End of macro DMARK
286b						CALLMONITOR 
286b cd 80 13			call break_point_state  
286e				endm  
# End of macro CALLMONITOR
286e					endif 
286e				; replace below with ) exec using tok_ptr 
286e 22 76 e6			ld (os_tok_ptr), hl 
2871 c3 9c 1b			jp exec1 
2874			 
2874 .. 00			.closepar:   db ")",0 
2876			 
2876				       NEXTW 
2876 c3 0b 1b			jp macro_next 
2879				endm 
# End of macro NEXTW
2879			.COMC: 
2879				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2879 6f				db WORD_SYS_CORE+91             
287a 82 28			dw .SCRATCH            
287c 02				db 1 + 1 
287d .. 00			db ")",0              
287f				endm 
# End of macro CWHEAD
287f			; | ) ( -- )  End of comment |  DONE  
287f				       NEXTW 
287f c3 0b 1b			jp macro_next 
2882				endm 
# End of macro NEXTW
2882			 
2882			.SCRATCH: 
2882				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2882 6f				db WORD_SYS_CORE+91             
2883 bd 28			dw .INC            
2885 08				db 7 + 1 
2886 .. 00			db "SCRATCH",0              
288e				endm 
# End of macro CWHEAD
288e			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
288e			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
288e			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
288e			; | |  
288e			; | | e.g.    : score $00 scratch ; 
288e			; | |  
288e			; | | $00 score ! 
288e			; | | $01 score +! 
288e			; | |  
288e			; | | e.g.   : varword $0a scratch ;  
288e			; | | 
288e			; | | $8000 varword ! 
288e					if DEBUG_FORTH_WORDS_KEY 
288e						DMARK "SCR" 
288e f5				push af  
288f 3a a3 28			ld a, (.dmark)  
2892 32 7a ee			ld (debug_mark),a  
2895 3a a4 28			ld a, (.dmark+1)  
2898 32 7b ee			ld (debug_mark+1),a  
289b 3a a5 28			ld a, (.dmark+2)  
289e 32 7c ee			ld (debug_mark+2),a  
28a1 18 03			jr .pastdmark  
28a3 ..			.dmark: db "SCR"  
28a6 f1			.pastdmark: pop af  
28a7			endm  
# End of macro DMARK
28a7						CALLMONITOR 
28a7 cd 80 13			call break_point_state  
28aa				endm  
# End of macro CALLMONITOR
28aa					endif 
28aa			 
28aa					FORTH_DSP_VALUEHL 
28aa cd b5 19			call macro_dsp_valuehl 
28ad				endm 
# End of macro FORTH_DSP_VALUEHL
28ad				 
28ad					FORTH_DSP_POP 
28ad cd 51 1a			call macro_forth_dsp_pop 
28b0				endm 
# End of macro FORTH_DSP_POP
28b0			 
28b0 7d					ld a, l 
28b1 21 9a e8				ld hl, os_var_array 
28b4 cd 68 0b				call addatohl 
28b7			 
28b7 cd 1a 19				call forth_push_numhl 
28ba			 
28ba				       NEXTW 
28ba c3 0b 1b			jp macro_next 
28bd				endm 
# End of macro NEXTW
28bd			 
28bd			.INC: 
28bd				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
28bd 6f				db WORD_SYS_CORE+91             
28be 11 29			dw .DEC            
28c0 03				db 2 + 1 
28c1 .. 00			db "+!",0              
28c4				endm 
# End of macro CWHEAD
28c4			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
28c4					if DEBUG_FORTH_WORDS_KEY 
28c4						DMARK "+s_" 
28c4 f5				push af  
28c5 3a d9 28			ld a, (.dmark)  
28c8 32 7a ee			ld (debug_mark),a  
28cb 3a da 28			ld a, (.dmark+1)  
28ce 32 7b ee			ld (debug_mark+1),a  
28d1 3a db 28			ld a, (.dmark+2)  
28d4 32 7c ee			ld (debug_mark+2),a  
28d7 18 03			jr .pastdmark  
28d9 ..			.dmark: db "+s_"  
28dc f1			.pastdmark: pop af  
28dd			endm  
# End of macro DMARK
28dd						CALLMONITOR 
28dd cd 80 13			call break_point_state  
28e0				endm  
# End of macro CALLMONITOR
28e0					endif 
28e0			 
28e0					FORTH_DSP_VALUEHL 
28e0 cd b5 19			call macro_dsp_valuehl 
28e3				endm 
# End of macro FORTH_DSP_VALUEHL
28e3			 
28e3 e5					push hl   ; save address 
28e4			 
28e4					FORTH_DSP_POP 
28e4 cd 51 1a			call macro_forth_dsp_pop 
28e7				endm 
# End of macro FORTH_DSP_POP
28e7			 
28e7					FORTH_DSP_VALUEHL 
28e7 cd b5 19			call macro_dsp_valuehl 
28ea				endm 
# End of macro FORTH_DSP_VALUEHL
28ea			 
28ea					FORTH_DSP_POP 
28ea cd 51 1a			call macro_forth_dsp_pop 
28ed				endm 
# End of macro FORTH_DSP_POP
28ed			 
28ed					; hl contains value to add to byte at a 
28ed				 
28ed eb					ex de, hl 
28ee			 
28ee e1					pop hl 
28ef			 
28ef					if DEBUG_FORTH_WORDS 
28ef						DMARK "INC" 
28ef f5				push af  
28f0 3a 04 29			ld a, (.dmark)  
28f3 32 7a ee			ld (debug_mark),a  
28f6 3a 05 29			ld a, (.dmark+1)  
28f9 32 7b ee			ld (debug_mark+1),a  
28fc 3a 06 29			ld a, (.dmark+2)  
28ff 32 7c ee			ld (debug_mark+2),a  
2902 18 03			jr .pastdmark  
2904 ..			.dmark: db "INC"  
2907 f1			.pastdmark: pop af  
2908			endm  
# End of macro DMARK
2908						CALLMONITOR 
2908 cd 80 13			call break_point_state  
290b				endm  
# End of macro CALLMONITOR
290b					endif 
290b			 
290b 7e					ld a,(hl) 
290c 83					add e 
290d 77					ld (hl),a 
290e			 
290e			 
290e			 
290e				       NEXTW 
290e c3 0b 1b			jp macro_next 
2911				endm 
# End of macro NEXTW
2911			 
2911			.DEC: 
2911				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2911 6f				db WORD_SYS_CORE+91             
2912 62 29			dw .INC2            
2914 03				db 2 + 1 
2915 .. 00			db "-!",0              
2918				endm 
# End of macro CWHEAD
2918			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2918					if DEBUG_FORTH_WORDS_KEY 
2918						DMARK "-s_" 
2918 f5				push af  
2919 3a 2d 29			ld a, (.dmark)  
291c 32 7a ee			ld (debug_mark),a  
291f 3a 2e 29			ld a, (.dmark+1)  
2922 32 7b ee			ld (debug_mark+1),a  
2925 3a 2f 29			ld a, (.dmark+2)  
2928 32 7c ee			ld (debug_mark+2),a  
292b 18 03			jr .pastdmark  
292d ..			.dmark: db "-s_"  
2930 f1			.pastdmark: pop af  
2931			endm  
# End of macro DMARK
2931						CALLMONITOR 
2931 cd 80 13			call break_point_state  
2934				endm  
# End of macro CALLMONITOR
2934					endif 
2934			 
2934					FORTH_DSP_VALUEHL 
2934 cd b5 19			call macro_dsp_valuehl 
2937				endm 
# End of macro FORTH_DSP_VALUEHL
2937			 
2937 e5					push hl   ; save address 
2938			 
2938					FORTH_DSP_POP 
2938 cd 51 1a			call macro_forth_dsp_pop 
293b				endm 
# End of macro FORTH_DSP_POP
293b			 
293b					FORTH_DSP_VALUEHL 
293b cd b5 19			call macro_dsp_valuehl 
293e				endm 
# End of macro FORTH_DSP_VALUEHL
293e			 
293e					; hl contains value to add to byte at a 
293e				 
293e eb					ex de, hl 
293f			 
293f e1					pop hl 
2940			 
2940					if DEBUG_FORTH_WORDS 
2940						DMARK "DEC" 
2940 f5				push af  
2941 3a 55 29			ld a, (.dmark)  
2944 32 7a ee			ld (debug_mark),a  
2947 3a 56 29			ld a, (.dmark+1)  
294a 32 7b ee			ld (debug_mark+1),a  
294d 3a 57 29			ld a, (.dmark+2)  
2950 32 7c ee			ld (debug_mark+2),a  
2953 18 03			jr .pastdmark  
2955 ..			.dmark: db "DEC"  
2958 f1			.pastdmark: pop af  
2959			endm  
# End of macro DMARK
2959						CALLMONITOR 
2959 cd 80 13			call break_point_state  
295c				endm  
# End of macro CALLMONITOR
295c					endif 
295c			 
295c 7e					ld a,(hl) 
295d 93					sub e 
295e 77					ld (hl),a 
295f			 
295f			 
295f			 
295f				       NEXTW 
295f c3 0b 1b			jp macro_next 
2962				endm 
# End of macro NEXTW
2962			 
2962			.INC2: 
2962				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2962 6f				db WORD_SYS_CORE+91             
2963 0c 2a			dw .DEC2            
2965 04				db 3 + 1 
2966 .. 00			db "+2!",0              
296a				endm 
# End of macro CWHEAD
296a			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
296a			 
296a					if DEBUG_FORTH_WORDS_KEY 
296a						DMARK "+2s" 
296a f5				push af  
296b 3a 7f 29			ld a, (.dmark)  
296e 32 7a ee			ld (debug_mark),a  
2971 3a 80 29			ld a, (.dmark+1)  
2974 32 7b ee			ld (debug_mark+1),a  
2977 3a 81 29			ld a, (.dmark+2)  
297a 32 7c ee			ld (debug_mark+2),a  
297d 18 03			jr .pastdmark  
297f ..			.dmark: db "+2s"  
2982 f1			.pastdmark: pop af  
2983			endm  
# End of macro DMARK
2983						CALLMONITOR 
2983 cd 80 13			call break_point_state  
2986				endm  
# End of macro CALLMONITOR
2986					endif 
2986			 
2986					; Address 
2986			 
2986					FORTH_DSP_VALUEHL 
2986 cd b5 19			call macro_dsp_valuehl 
2989				endm 
# End of macro FORTH_DSP_VALUEHL
2989			 
2989 e5					push hl    ; save address 
298a			 
298a					; load content into de 
298a			 
298a 5e					ld e,(hl) 
298b 23					inc hl 
298c 56					ld d, (hl) 
298d			 
298d					if DEBUG_FORTH_WORDS 
298d						DMARK "+2a" 
298d f5				push af  
298e 3a a2 29			ld a, (.dmark)  
2991 32 7a ee			ld (debug_mark),a  
2994 3a a3 29			ld a, (.dmark+1)  
2997 32 7b ee			ld (debug_mark+1),a  
299a 3a a4 29			ld a, (.dmark+2)  
299d 32 7c ee			ld (debug_mark+2),a  
29a0 18 03			jr .pastdmark  
29a2 ..			.dmark: db "+2a"  
29a5 f1			.pastdmark: pop af  
29a6			endm  
# End of macro DMARK
29a6						CALLMONITOR 
29a6 cd 80 13			call break_point_state  
29a9				endm  
# End of macro CALLMONITOR
29a9					endif 
29a9			 
29a9					FORTH_DSP_POP 
29a9 cd 51 1a			call macro_forth_dsp_pop 
29ac				endm 
# End of macro FORTH_DSP_POP
29ac			 
29ac					; Get value to add 
29ac			 
29ac					FORTH_DSP_VALUE 
29ac cd 9e 19			call macro_forth_dsp_value 
29af				endm 
# End of macro FORTH_DSP_VALUE
29af			 
29af					if DEBUG_FORTH_WORDS 
29af						DMARK "+2v" 
29af f5				push af  
29b0 3a c4 29			ld a, (.dmark)  
29b3 32 7a ee			ld (debug_mark),a  
29b6 3a c5 29			ld a, (.dmark+1)  
29b9 32 7b ee			ld (debug_mark+1),a  
29bc 3a c6 29			ld a, (.dmark+2)  
29bf 32 7c ee			ld (debug_mark+2),a  
29c2 18 03			jr .pastdmark  
29c4 ..			.dmark: db "+2v"  
29c7 f1			.pastdmark: pop af  
29c8			endm  
# End of macro DMARK
29c8						CALLMONITOR 
29c8 cd 80 13			call break_point_state  
29cb				endm  
# End of macro CALLMONITOR
29cb					endif 
29cb			 
29cb 19					add hl, de 
29cc			 
29cc					if DEBUG_FORTH_WORDS 
29cc						DMARK "+2+" 
29cc f5				push af  
29cd 3a e1 29			ld a, (.dmark)  
29d0 32 7a ee			ld (debug_mark),a  
29d3 3a e2 29			ld a, (.dmark+1)  
29d6 32 7b ee			ld (debug_mark+1),a  
29d9 3a e3 29			ld a, (.dmark+2)  
29dc 32 7c ee			ld (debug_mark+2),a  
29df 18 03			jr .pastdmark  
29e1 ..			.dmark: db "+2+"  
29e4 f1			.pastdmark: pop af  
29e5			endm  
# End of macro DMARK
29e5						CALLMONITOR 
29e5 cd 80 13			call break_point_state  
29e8				endm  
# End of macro CALLMONITOR
29e8					endif 
29e8			 
29e8					; move result to de 
29e8			 
29e8 eb					ex de, hl 
29e9			 
29e9					; Address 
29e9			 
29e9 e1					pop hl 
29ea			 
29ea					; save it back 
29ea			 
29ea 73					ld (hl), e 
29eb 23					inc hl 
29ec 72					ld (hl), d 
29ed			 
29ed					if DEBUG_FORTH_WORDS 
29ed						DMARK "+2e" 
29ed f5				push af  
29ee 3a 02 2a			ld a, (.dmark)  
29f1 32 7a ee			ld (debug_mark),a  
29f4 3a 03 2a			ld a, (.dmark+1)  
29f7 32 7b ee			ld (debug_mark+1),a  
29fa 3a 04 2a			ld a, (.dmark+2)  
29fd 32 7c ee			ld (debug_mark+2),a  
2a00 18 03			jr .pastdmark  
2a02 ..			.dmark: db "+2e"  
2a05 f1			.pastdmark: pop af  
2a06			endm  
# End of macro DMARK
2a06						CALLMONITOR 
2a06 cd 80 13			call break_point_state  
2a09				endm  
# End of macro CALLMONITOR
2a09					endif 
2a09			 
2a09			 
2a09			 
2a09			 
2a09			 
2a09				       NEXTW 
2a09 c3 0b 1b			jp macro_next 
2a0c				endm 
# End of macro NEXTW
2a0c			 
2a0c			.DEC2: 
2a0c				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2a0c 6f				db WORD_SYS_CORE+91             
2a0d b8 2a			dw .GET2            
2a0f 04				db 3 + 1 
2a10 .. 00			db "-2!",0              
2a14				endm 
# End of macro CWHEAD
2a14			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2a14			 
2a14			 
2a14					if DEBUG_FORTH_WORDS_KEY 
2a14						DMARK "-2s" 
2a14 f5				push af  
2a15 3a 29 2a			ld a, (.dmark)  
2a18 32 7a ee			ld (debug_mark),a  
2a1b 3a 2a 2a			ld a, (.dmark+1)  
2a1e 32 7b ee			ld (debug_mark+1),a  
2a21 3a 2b 2a			ld a, (.dmark+2)  
2a24 32 7c ee			ld (debug_mark+2),a  
2a27 18 03			jr .pastdmark  
2a29 ..			.dmark: db "-2s"  
2a2c f1			.pastdmark: pop af  
2a2d			endm  
# End of macro DMARK
2a2d						CALLMONITOR 
2a2d cd 80 13			call break_point_state  
2a30				endm  
# End of macro CALLMONITOR
2a30					endif 
2a30			 
2a30					; Address 
2a30			 
2a30					FORTH_DSP_VALUEHL 
2a30 cd b5 19			call macro_dsp_valuehl 
2a33				endm 
# End of macro FORTH_DSP_VALUEHL
2a33			 
2a33 e5					push hl    ; save address 
2a34			 
2a34					; load content into de 
2a34			 
2a34 5e					ld e,(hl) 
2a35 23					inc hl 
2a36 56					ld d, (hl) 
2a37			 
2a37					if DEBUG_FORTH_WORDS 
2a37						DMARK "-2a" 
2a37 f5				push af  
2a38 3a 4c 2a			ld a, (.dmark)  
2a3b 32 7a ee			ld (debug_mark),a  
2a3e 3a 4d 2a			ld a, (.dmark+1)  
2a41 32 7b ee			ld (debug_mark+1),a  
2a44 3a 4e 2a			ld a, (.dmark+2)  
2a47 32 7c ee			ld (debug_mark+2),a  
2a4a 18 03			jr .pastdmark  
2a4c ..			.dmark: db "-2a"  
2a4f f1			.pastdmark: pop af  
2a50			endm  
# End of macro DMARK
2a50						CALLMONITOR 
2a50 cd 80 13			call break_point_state  
2a53				endm  
# End of macro CALLMONITOR
2a53					endif 
2a53			 
2a53					FORTH_DSP_POP 
2a53 cd 51 1a			call macro_forth_dsp_pop 
2a56				endm 
# End of macro FORTH_DSP_POP
2a56			 
2a56					; Get value to remove 
2a56			 
2a56					FORTH_DSP_VALUE 
2a56 cd 9e 19			call macro_forth_dsp_value 
2a59				endm 
# End of macro FORTH_DSP_VALUE
2a59			 
2a59					if DEBUG_FORTH_WORDS 
2a59						DMARK "-2v" 
2a59 f5				push af  
2a5a 3a 6e 2a			ld a, (.dmark)  
2a5d 32 7a ee			ld (debug_mark),a  
2a60 3a 6f 2a			ld a, (.dmark+1)  
2a63 32 7b ee			ld (debug_mark+1),a  
2a66 3a 70 2a			ld a, (.dmark+2)  
2a69 32 7c ee			ld (debug_mark+2),a  
2a6c 18 03			jr .pastdmark  
2a6e ..			.dmark: db "-2v"  
2a71 f1			.pastdmark: pop af  
2a72			endm  
# End of macro DMARK
2a72						CALLMONITOR 
2a72 cd 80 13			call break_point_state  
2a75				endm  
# End of macro CALLMONITOR
2a75					endif 
2a75			 
2a75 eb					ex de, hl 
2a76 ed 52				sbc hl, de 
2a78			 
2a78					if DEBUG_FORTH_WORDS 
2a78						DMARK "-2d" 
2a78 f5				push af  
2a79 3a 8d 2a			ld a, (.dmark)  
2a7c 32 7a ee			ld (debug_mark),a  
2a7f 3a 8e 2a			ld a, (.dmark+1)  
2a82 32 7b ee			ld (debug_mark+1),a  
2a85 3a 8f 2a			ld a, (.dmark+2)  
2a88 32 7c ee			ld (debug_mark+2),a  
2a8b 18 03			jr .pastdmark  
2a8d ..			.dmark: db "-2d"  
2a90 f1			.pastdmark: pop af  
2a91			endm  
# End of macro DMARK
2a91						CALLMONITOR 
2a91 cd 80 13			call break_point_state  
2a94				endm  
# End of macro CALLMONITOR
2a94					endif 
2a94			 
2a94					; move result to de 
2a94			 
2a94 eb					ex de, hl 
2a95			 
2a95					; Address 
2a95			 
2a95 e1					pop hl 
2a96			 
2a96					; save it back 
2a96			 
2a96 73					ld (hl), e 
2a97 23					inc hl 
2a98 72					ld (hl), d 
2a99			 
2a99					if DEBUG_FORTH_WORDS 
2a99						DMARK "-2e" 
2a99 f5				push af  
2a9a 3a ae 2a			ld a, (.dmark)  
2a9d 32 7a ee			ld (debug_mark),a  
2aa0 3a af 2a			ld a, (.dmark+1)  
2aa3 32 7b ee			ld (debug_mark+1),a  
2aa6 3a b0 2a			ld a, (.dmark+2)  
2aa9 32 7c ee			ld (debug_mark+2),a  
2aac 18 03			jr .pastdmark  
2aae ..			.dmark: db "-2e"  
2ab1 f1			.pastdmark: pop af  
2ab2			endm  
# End of macro DMARK
2ab2						CALLMONITOR 
2ab2 cd 80 13			call break_point_state  
2ab5				endm  
# End of macro CALLMONITOR
2ab5					endif 
2ab5			 
2ab5			 
2ab5			 
2ab5			 
2ab5			 
2ab5				       NEXTW 
2ab5 c3 0b 1b			jp macro_next 
2ab8				endm 
# End of macro NEXTW
2ab8			.GET2: 
2ab8				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2ab8 6f				db WORD_SYS_CORE+91             
2ab9 e8 2a			dw .BANG2            
2abb 03				db 2 + 1 
2abc .. 00			db "2@",0              
2abf				endm 
# End of macro CWHEAD
2abf			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2abf					if DEBUG_FORTH_WORDS_KEY 
2abf						DMARK "2A_" 
2abf f5				push af  
2ac0 3a d4 2a			ld a, (.dmark)  
2ac3 32 7a ee			ld (debug_mark),a  
2ac6 3a d5 2a			ld a, (.dmark+1)  
2ac9 32 7b ee			ld (debug_mark+1),a  
2acc 3a d6 2a			ld a, (.dmark+2)  
2acf 32 7c ee			ld (debug_mark+2),a  
2ad2 18 03			jr .pastdmark  
2ad4 ..			.dmark: db "2A_"  
2ad7 f1			.pastdmark: pop af  
2ad8			endm  
# End of macro DMARK
2ad8						CALLMONITOR 
2ad8 cd 80 13			call break_point_state  
2adb				endm  
# End of macro CALLMONITOR
2adb					endif 
2adb			 
2adb					FORTH_DSP_VALUEHL 
2adb cd b5 19			call macro_dsp_valuehl 
2ade				endm 
# End of macro FORTH_DSP_VALUEHL
2ade			 
2ade 5e					ld e, (hl) 
2adf 23					inc hl 
2ae0 56					ld d, (hl) 
2ae1			 
2ae1 eb					ex de, hl 
2ae2			 
2ae2 cd 1a 19				call forth_push_numhl 
2ae5			 
2ae5				       NEXTW 
2ae5 c3 0b 1b			jp macro_next 
2ae8				endm 
# End of macro NEXTW
2ae8			.BANG2: 
2ae8				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ae8 6f				db WORD_SYS_CORE+91             
2ae9 20 2b			dw .CONFIG            
2aeb 03				db 2 + 1 
2aec .. 00			db "2!",0              
2aef				endm 
# End of macro CWHEAD
2aef			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2aef					if DEBUG_FORTH_WORDS_KEY 
2aef						DMARK "2S_" 
2aef f5				push af  
2af0 3a 04 2b			ld a, (.dmark)  
2af3 32 7a ee			ld (debug_mark),a  
2af6 3a 05 2b			ld a, (.dmark+1)  
2af9 32 7b ee			ld (debug_mark+1),a  
2afc 3a 06 2b			ld a, (.dmark+2)  
2aff 32 7c ee			ld (debug_mark+2),a  
2b02 18 03			jr .pastdmark  
2b04 ..			.dmark: db "2S_"  
2b07 f1			.pastdmark: pop af  
2b08			endm  
# End of macro DMARK
2b08						CALLMONITOR 
2b08 cd 80 13			call break_point_state  
2b0b				endm  
# End of macro CALLMONITOR
2b0b					endif 
2b0b			 
2b0b					FORTH_DSP_VALUEHL 
2b0b cd b5 19			call macro_dsp_valuehl 
2b0e				endm 
# End of macro FORTH_DSP_VALUEHL
2b0e			 
2b0e e5					push hl   ; save address 
2b0f			 
2b0f			 
2b0f					FORTH_DSP_POP 
2b0f cd 51 1a			call macro_forth_dsp_pop 
2b12				endm 
# End of macro FORTH_DSP_POP
2b12			 
2b12					 
2b12					FORTH_DSP_VALUEHL 
2b12 cd b5 19			call macro_dsp_valuehl 
2b15				endm 
# End of macro FORTH_DSP_VALUEHL
2b15			 
2b15					FORTH_DSP_POP 
2b15 cd 51 1a			call macro_forth_dsp_pop 
2b18				endm 
# End of macro FORTH_DSP_POP
2b18			 
2b18 eb					ex de, hl    ; value now in de 
2b19			 
2b19 e1					pop hl 
2b1a			 
2b1a 73					ld (hl), e 
2b1b			 
2b1b 23					inc hl 
2b1c			 
2b1c 72					ld (hl), d 
2b1d			 
2b1d			 
2b1d				       NEXTW 
2b1d c3 0b 1b			jp macro_next 
2b20				endm 
# End of macro NEXTW
2b20			.CONFIG: 
2b20				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2b20 6f				db WORD_SYS_CORE+91             
2b21 31 2b			dw .ENDCORE            
2b23 07				db 6 + 1 
2b24 .. 00			db "CONFIG",0              
2b2b				endm 
# End of macro CWHEAD
2b2b			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2b2b			 
2b2b cd c8 11				call config 
2b2e					NEXTW 
2b2e c3 0b 1b			jp macro_next 
2b31				endm 
# End of macro NEXTW
2b31			.ENDCORE: 
2b31			 
2b31			; eof 
2b31			 
2b31			 
# End of file forth_words_core.asm
2b31			include "forth_words_flow.asm" 
2b31			 
2b31			; | ## Program Flow Words 
2b31			 
2b31			.IF: 
2b31				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2b31 1e				db WORD_SYS_CORE+10             
2b32 26 2c			dw .THEN            
2b34 03				db 2 + 1 
2b35 .. 00			db "IF",0              
2b38				endm 
# End of macro CWHEAD
2b38			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2b38			; 
2b38					if DEBUG_FORTH_WORDS_KEY 
2b38						DMARK "IF." 
2b38 f5				push af  
2b39 3a 4d 2b			ld a, (.dmark)  
2b3c 32 7a ee			ld (debug_mark),a  
2b3f 3a 4e 2b			ld a, (.dmark+1)  
2b42 32 7b ee			ld (debug_mark+1),a  
2b45 3a 4f 2b			ld a, (.dmark+2)  
2b48 32 7c ee			ld (debug_mark+2),a  
2b4b 18 03			jr .pastdmark  
2b4d ..			.dmark: db "IF."  
2b50 f1			.pastdmark: pop af  
2b51			endm  
# End of macro DMARK
2b51						CALLMONITOR 
2b51 cd 80 13			call break_point_state  
2b54				endm  
# End of macro CALLMONITOR
2b54					endif 
2b54			; eval TOS 
2b54			 
2b54				FORTH_DSP_VALUEHL 
2b54 cd b5 19			call macro_dsp_valuehl 
2b57				endm 
# End of macro FORTH_DSP_VALUEHL
2b57			 
2b57			;	push hl 
2b57				FORTH_DSP_POP 
2b57 cd 51 1a			call macro_forth_dsp_pop 
2b5a				endm 
# End of macro FORTH_DSP_POP
2b5a			;	pop hl 
2b5a			 
2b5a					if DEBUG_FORTH_WORDS 
2b5a						DMARK "IF1" 
2b5a f5				push af  
2b5b 3a 6f 2b			ld a, (.dmark)  
2b5e 32 7a ee			ld (debug_mark),a  
2b61 3a 70 2b			ld a, (.dmark+1)  
2b64 32 7b ee			ld (debug_mark+1),a  
2b67 3a 71 2b			ld a, (.dmark+2)  
2b6a 32 7c ee			ld (debug_mark+2),a  
2b6d 18 03			jr .pastdmark  
2b6f ..			.dmark: db "IF1"  
2b72 f1			.pastdmark: pop af  
2b73			endm  
# End of macro DMARK
2b73						CALLMONITOR 
2b73 cd 80 13			call break_point_state  
2b76				endm  
# End of macro CALLMONITOR
2b76					endif 
2b76 b7				or a        ; clear carry flag 
2b77 11 00 00			ld de, 0 
2b7a eb				ex de,hl 
2b7b ed 52			sbc hl, de 
2b7d c2 07 2c			jp nz, .iftrue 
2b80			 
2b80					if DEBUG_FORTH_WORDS 
2b80						DMARK "IF2" 
2b80 f5				push af  
2b81 3a 95 2b			ld a, (.dmark)  
2b84 32 7a ee			ld (debug_mark),a  
2b87 3a 96 2b			ld a, (.dmark+1)  
2b8a 32 7b ee			ld (debug_mark+1),a  
2b8d 3a 97 2b			ld a, (.dmark+2)  
2b90 32 7c ee			ld (debug_mark+2),a  
2b93 18 03			jr .pastdmark  
2b95 ..			.dmark: db "IF2"  
2b98 f1			.pastdmark: pop af  
2b99			endm  
# End of macro DMARK
2b99						CALLMONITOR 
2b99 cd 80 13			call break_point_state  
2b9c				endm  
# End of macro CALLMONITOR
2b9c					endif 
2b9c			 
2b9c			; if not true then skip to THEN 
2b9c			 
2b9c				; TODO get tok_ptr 
2b9c				; TODO consume toks until we get to THEN 
2b9c			 
2b9c 2a 76 e6			ld hl, (os_tok_ptr) 
2b9f					if DEBUG_FORTH_WORDS 
2b9f						DMARK "IF3" 
2b9f f5				push af  
2ba0 3a b4 2b			ld a, (.dmark)  
2ba3 32 7a ee			ld (debug_mark),a  
2ba6 3a b5 2b			ld a, (.dmark+1)  
2ba9 32 7b ee			ld (debug_mark+1),a  
2bac 3a b6 2b			ld a, (.dmark+2)  
2baf 32 7c ee			ld (debug_mark+2),a  
2bb2 18 03			jr .pastdmark  
2bb4 ..			.dmark: db "IF3"  
2bb7 f1			.pastdmark: pop af  
2bb8			endm  
# End of macro DMARK
2bb8						CALLMONITOR 
2bb8 cd 80 13			call break_point_state  
2bbb				endm  
# End of macro CALLMONITOR
2bbb						 
2bbb					endif 
2bbb 11 02 2c			ld de, .ifthen 
2bbe					if DEBUG_FORTH_WORDS 
2bbe						DMARK "IF4" 
2bbe f5				push af  
2bbf 3a d3 2b			ld a, (.dmark)  
2bc2 32 7a ee			ld (debug_mark),a  
2bc5 3a d4 2b			ld a, (.dmark+1)  
2bc8 32 7b ee			ld (debug_mark+1),a  
2bcb 3a d5 2b			ld a, (.dmark+2)  
2bce 32 7c ee			ld (debug_mark+2),a  
2bd1 18 03			jr .pastdmark  
2bd3 ..			.dmark: db "IF4"  
2bd6 f1			.pastdmark: pop af  
2bd7			endm  
# End of macro DMARK
2bd7						CALLMONITOR 
2bd7 cd 80 13			call break_point_state  
2bda				endm  
# End of macro CALLMONITOR
2bda					endif 
2bda cd 26 1c			call findnexttok  
2bdd			 
2bdd					if DEBUG_FORTH_WORDS 
2bdd						DMARK "IF5" 
2bdd f5				push af  
2bde 3a f2 2b			ld a, (.dmark)  
2be1 32 7a ee			ld (debug_mark),a  
2be4 3a f3 2b			ld a, (.dmark+1)  
2be7 32 7b ee			ld (debug_mark+1),a  
2bea 3a f4 2b			ld a, (.dmark+2)  
2bed 32 7c ee			ld (debug_mark+2),a  
2bf0 18 03			jr .pastdmark  
2bf2 ..			.dmark: db "IF5"  
2bf5 f1			.pastdmark: pop af  
2bf6			endm  
# End of macro DMARK
2bf6						CALLMONITOR 
2bf6 cd 80 13			call break_point_state  
2bf9				endm  
# End of macro CALLMONITOR
2bf9					endif 
2bf9				; TODO replace below with ; exec using tok_ptr 
2bf9 22 76 e6			ld (os_tok_ptr), hl 
2bfc c3 9c 1b			jp exec1 
2bff				NEXTW 
2bff c3 0b 1b			jp macro_next 
2c02				endm 
# End of macro NEXTW
2c02			 
2c02 .. 00		.ifthen:  db "THEN",0 
2c07			 
2c07			.iftrue:		 
2c07				; Exec next words normally 
2c07			 
2c07				; if true then exec following IF as normal 
2c07					if DEBUG_FORTH_WORDS 
2c07						DMARK "IFT" 
2c07 f5				push af  
2c08 3a 1c 2c			ld a, (.dmark)  
2c0b 32 7a ee			ld (debug_mark),a  
2c0e 3a 1d 2c			ld a, (.dmark+1)  
2c11 32 7b ee			ld (debug_mark+1),a  
2c14 3a 1e 2c			ld a, (.dmark+2)  
2c17 32 7c ee			ld (debug_mark+2),a  
2c1a 18 03			jr .pastdmark  
2c1c ..			.dmark: db "IFT"  
2c1f f1			.pastdmark: pop af  
2c20			endm  
# End of macro DMARK
2c20						CALLMONITOR 
2c20 cd 80 13			call break_point_state  
2c23				endm  
# End of macro CALLMONITOR
2c23					endif 
2c23			 
2c23					NEXTW 
2c23 c3 0b 1b			jp macro_next 
2c26				endm 
# End of macro NEXTW
2c26			.THEN: 
2c26				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2c26 1f				db WORD_SYS_CORE+11             
2c27 4e 2c			dw .ELSE            
2c29 05				db 4 + 1 
2c2a .. 00			db "THEN",0              
2c2f				endm 
# End of macro CWHEAD
2c2f			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2c2f					if DEBUG_FORTH_WORDS_KEY 
2c2f						DMARK "THN" 
2c2f f5				push af  
2c30 3a 44 2c			ld a, (.dmark)  
2c33 32 7a ee			ld (debug_mark),a  
2c36 3a 45 2c			ld a, (.dmark+1)  
2c39 32 7b ee			ld (debug_mark+1),a  
2c3c 3a 46 2c			ld a, (.dmark+2)  
2c3f 32 7c ee			ld (debug_mark+2),a  
2c42 18 03			jr .pastdmark  
2c44 ..			.dmark: db "THN"  
2c47 f1			.pastdmark: pop af  
2c48			endm  
# End of macro DMARK
2c48						CALLMONITOR 
2c48 cd 80 13			call break_point_state  
2c4b				endm  
# End of macro CALLMONITOR
2c4b					endif 
2c4b					NEXTW 
2c4b c3 0b 1b			jp macro_next 
2c4e				endm 
# End of macro NEXTW
2c4e			.ELSE: 
2c4e				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2c4e 20				db WORD_SYS_CORE+12             
2c4f 76 2c			dw .DO            
2c51 03				db 2 + 1 
2c52 .. 00			db "ELSE",0              
2c57				endm 
# End of macro CWHEAD
2c57			; | ELSE ( -- ) Not supported - does nothing | TODO 
2c57			 
2c57					if DEBUG_FORTH_WORDS_KEY 
2c57						DMARK "ELS" 
2c57 f5				push af  
2c58 3a 6c 2c			ld a, (.dmark)  
2c5b 32 7a ee			ld (debug_mark),a  
2c5e 3a 6d 2c			ld a, (.dmark+1)  
2c61 32 7b ee			ld (debug_mark+1),a  
2c64 3a 6e 2c			ld a, (.dmark+2)  
2c67 32 7c ee			ld (debug_mark+2),a  
2c6a 18 03			jr .pastdmark  
2c6c ..			.dmark: db "ELS"  
2c6f f1			.pastdmark: pop af  
2c70			endm  
# End of macro DMARK
2c70						CALLMONITOR 
2c70 cd 80 13			call break_point_state  
2c73				endm  
# End of macro CALLMONITOR
2c73					endif 
2c73			 
2c73			 
2c73					NEXTW 
2c73 c3 0b 1b			jp macro_next 
2c76				endm 
# End of macro NEXTW
2c76			.DO: 
2c76				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2c76 21				db WORD_SYS_CORE+13             
2c77 9d 2d			dw .LOOP            
2c79 03				db 2 + 1 
2c7a .. 00			db "DO",0              
2c7d				endm 
# End of macro CWHEAD
2c7d			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2c7d			 
2c7d					if DEBUG_FORTH_WORDS_KEY 
2c7d						DMARK "DO." 
2c7d f5				push af  
2c7e 3a 92 2c			ld a, (.dmark)  
2c81 32 7a ee			ld (debug_mark),a  
2c84 3a 93 2c			ld a, (.dmark+1)  
2c87 32 7b ee			ld (debug_mark+1),a  
2c8a 3a 94 2c			ld a, (.dmark+2)  
2c8d 32 7c ee			ld (debug_mark+2),a  
2c90 18 03			jr .pastdmark  
2c92 ..			.dmark: db "DO."  
2c95 f1			.pastdmark: pop af  
2c96			endm  
# End of macro DMARK
2c96						CALLMONITOR 
2c96 cd 80 13			call break_point_state  
2c99				endm  
# End of macro CALLMONITOR
2c99					endif 
2c99			;  push pc to rsp stack past the DO 
2c99			 
2c99 2a 76 e6				ld hl, (os_tok_ptr) 
2c9c 23					inc hl   ; D 
2c9d 23					inc hl  ; O 
2c9e 23					inc hl   ; null 
2c9f					if DEBUG_FORTH_WORDS 
2c9f						DMARK "DO2" 
2c9f f5				push af  
2ca0 3a b4 2c			ld a, (.dmark)  
2ca3 32 7a ee			ld (debug_mark),a  
2ca6 3a b5 2c			ld a, (.dmark+1)  
2ca9 32 7b ee			ld (debug_mark+1),a  
2cac 3a b6 2c			ld a, (.dmark+2)  
2caf 32 7c ee			ld (debug_mark+2),a  
2cb2 18 03			jr .pastdmark  
2cb4 ..			.dmark: db "DO2"  
2cb7 f1			.pastdmark: pop af  
2cb8			endm  
# End of macro DMARK
2cb8						CALLMONITOR 
2cb8 cd 80 13			call break_point_state  
2cbb				endm  
# End of macro CALLMONITOR
2cbb					endif 
2cbb					FORTH_RSP_NEXT 
2cbb cd c1 18			call macro_forth_rsp_next 
2cbe				endm 
# End of macro FORTH_RSP_NEXT
2cbe					if DEBUG_FORTH_WORDS 
2cbe						DMARK "DO3" 
2cbe f5				push af  
2cbf 3a d3 2c			ld a, (.dmark)  
2cc2 32 7a ee			ld (debug_mark),a  
2cc5 3a d4 2c			ld a, (.dmark+1)  
2cc8 32 7b ee			ld (debug_mark+1),a  
2ccb 3a d5 2c			ld a, (.dmark+2)  
2cce 32 7c ee			ld (debug_mark+2),a  
2cd1 18 03			jr .pastdmark  
2cd3 ..			.dmark: db "DO3"  
2cd6 f1			.pastdmark: pop af  
2cd7			endm  
# End of macro DMARK
2cd7						CALLMONITOR 
2cd7 cd 80 13			call break_point_state  
2cda				endm  
# End of macro CALLMONITOR
2cda					endif 
2cda			 
2cda					;if DEBUG_FORTH_WORDS 
2cda				;		push hl 
2cda			;		endif  
2cda			 
2cda			; get counters from data stack 
2cda			 
2cda			 
2cda					FORTH_DSP_VALUEHL 
2cda cd b5 19			call macro_dsp_valuehl 
2cdd				endm 
# End of macro FORTH_DSP_VALUEHL
2cdd e5					push hl		 ; hl now has starting counter which needs to be tos 
2cde			 
2cde					if DEBUG_FORTH_WORDS 
2cde						DMARK "DO4" 
2cde f5				push af  
2cdf 3a f3 2c			ld a, (.dmark)  
2ce2 32 7a ee			ld (debug_mark),a  
2ce5 3a f4 2c			ld a, (.dmark+1)  
2ce8 32 7b ee			ld (debug_mark+1),a  
2ceb 3a f5 2c			ld a, (.dmark+2)  
2cee 32 7c ee			ld (debug_mark+2),a  
2cf1 18 03			jr .pastdmark  
2cf3 ..			.dmark: db "DO4"  
2cf6 f1			.pastdmark: pop af  
2cf7			endm  
# End of macro DMARK
2cf7						CALLMONITOR 
2cf7 cd 80 13			call break_point_state  
2cfa				endm  
# End of macro CALLMONITOR
2cfa					endif 
2cfa					FORTH_DSP_POP 
2cfa cd 51 1a			call macro_forth_dsp_pop 
2cfd				endm 
# End of macro FORTH_DSP_POP
2cfd			 
2cfd					if DEBUG_FORTH_WORDS 
2cfd						DMARK "DO5" 
2cfd f5				push af  
2cfe 3a 12 2d			ld a, (.dmark)  
2d01 32 7a ee			ld (debug_mark),a  
2d04 3a 13 2d			ld a, (.dmark+1)  
2d07 32 7b ee			ld (debug_mark+1),a  
2d0a 3a 14 2d			ld a, (.dmark+2)  
2d0d 32 7c ee			ld (debug_mark+2),a  
2d10 18 03			jr .pastdmark  
2d12 ..			.dmark: db "DO5"  
2d15 f1			.pastdmark: pop af  
2d16			endm  
# End of macro DMARK
2d16						CALLMONITOR 
2d16 cd 80 13			call break_point_state  
2d19				endm  
# End of macro CALLMONITOR
2d19					endif 
2d19			 
2d19					FORTH_DSP_VALUEHL 
2d19 cd b5 19			call macro_dsp_valuehl 
2d1c				endm 
# End of macro FORTH_DSP_VALUEHL
2d1c			;		push hl		 ; hl now has starting limit counter 
2d1c			 
2d1c					if DEBUG_FORTH_WORDS 
2d1c						DMARK "DO6" 
2d1c f5				push af  
2d1d 3a 31 2d			ld a, (.dmark)  
2d20 32 7a ee			ld (debug_mark),a  
2d23 3a 32 2d			ld a, (.dmark+1)  
2d26 32 7b ee			ld (debug_mark+1),a  
2d29 3a 33 2d			ld a, (.dmark+2)  
2d2c 32 7c ee			ld (debug_mark+2),a  
2d2f 18 03			jr .pastdmark  
2d31 ..			.dmark: db "DO6"  
2d34 f1			.pastdmark: pop af  
2d35			endm  
# End of macro DMARK
2d35						CALLMONITOR 
2d35 cd 80 13			call break_point_state  
2d38				endm  
# End of macro CALLMONITOR
2d38					endif 
2d38					FORTH_DSP_POP 
2d38 cd 51 1a			call macro_forth_dsp_pop 
2d3b				endm 
# End of macro FORTH_DSP_POP
2d3b			 
2d3b			; put counters on the loop stack 
2d3b			 
2d3b			;		pop hl			 ; limit counter 
2d3b d1					pop de			; start counter 
2d3c			 
2d3c					; push limit counter 
2d3c			 
2d3c					if DEBUG_FORTH_WORDS 
2d3c						DMARK "DO7" 
2d3c f5				push af  
2d3d 3a 51 2d			ld a, (.dmark)  
2d40 32 7a ee			ld (debug_mark),a  
2d43 3a 52 2d			ld a, (.dmark+1)  
2d46 32 7b ee			ld (debug_mark+1),a  
2d49 3a 53 2d			ld a, (.dmark+2)  
2d4c 32 7c ee			ld (debug_mark+2),a  
2d4f 18 03			jr .pastdmark  
2d51 ..			.dmark: db "DO7"  
2d54 f1			.pastdmark: pop af  
2d55			endm  
# End of macro DMARK
2d55						CALLMONITOR 
2d55 cd 80 13			call break_point_state  
2d58				endm  
# End of macro CALLMONITOR
2d58					endif 
2d58					FORTH_LOOP_NEXT 
2d58 cd ca 19			call macro_forth_loop_next 
2d5b				endm 
# End of macro FORTH_LOOP_NEXT
2d5b			 
2d5b					; push start counter 
2d5b			 
2d5b eb					ex de, hl 
2d5c					if DEBUG_FORTH_WORDS 
2d5c						DMARK "DO7" 
2d5c f5				push af  
2d5d 3a 71 2d			ld a, (.dmark)  
2d60 32 7a ee			ld (debug_mark),a  
2d63 3a 72 2d			ld a, (.dmark+1)  
2d66 32 7b ee			ld (debug_mark+1),a  
2d69 3a 73 2d			ld a, (.dmark+2)  
2d6c 32 7c ee			ld (debug_mark+2),a  
2d6f 18 03			jr .pastdmark  
2d71 ..			.dmark: db "DO7"  
2d74 f1			.pastdmark: pop af  
2d75			endm  
# End of macro DMARK
2d75						CALLMONITOR 
2d75 cd 80 13			call break_point_state  
2d78				endm  
# End of macro CALLMONITOR
2d78					endif 
2d78					FORTH_LOOP_NEXT 
2d78 cd ca 19			call macro_forth_loop_next 
2d7b				endm 
# End of macro FORTH_LOOP_NEXT
2d7b			 
2d7b			 
2d7b					; init first round of I counter 
2d7b			 
2d7b 22 9a e6				ld (os_current_i), hl 
2d7e			 
2d7e					if DEBUG_FORTH_WORDS 
2d7e						DMARK "DO8" 
2d7e f5				push af  
2d7f 3a 93 2d			ld a, (.dmark)  
2d82 32 7a ee			ld (debug_mark),a  
2d85 3a 94 2d			ld a, (.dmark+1)  
2d88 32 7b ee			ld (debug_mark+1),a  
2d8b 3a 95 2d			ld a, (.dmark+2)  
2d8e 32 7c ee			ld (debug_mark+2),a  
2d91 18 03			jr .pastdmark  
2d93 ..			.dmark: db "DO8"  
2d96 f1			.pastdmark: pop af  
2d97			endm  
# End of macro DMARK
2d97						CALLMONITOR 
2d97 cd 80 13			call break_point_state  
2d9a				endm  
# End of macro CALLMONITOR
2d9a					endif 
2d9a			 
2d9a					NEXTW 
2d9a c3 0b 1b			jp macro_next 
2d9d				endm 
# End of macro NEXTW
2d9d			.LOOP: 
2d9d				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2d9d 22				db WORD_SYS_CORE+14             
2d9e b5 2e			dw .I            
2da0 05				db 4 + 1 
2da1 .. 00			db "LOOP",0              
2da6				endm 
# End of macro CWHEAD
2da6			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2da6			 
2da6				; pop tos as current loop count to hl 
2da6			 
2da6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2da6			 
2da6				FORTH_LOOP_TOS 
2da6 cd fd 19			call macro_forth_loop_tos 
2da9				endm 
# End of macro FORTH_LOOP_TOS
2da9 e5				push hl 
2daa			 
2daa					if DEBUG_FORTH_WORDS_KEY 
2daa						DMARK "LOP" 
2daa f5				push af  
2dab 3a bf 2d			ld a, (.dmark)  
2dae 32 7a ee			ld (debug_mark),a  
2db1 3a c0 2d			ld a, (.dmark+1)  
2db4 32 7b ee			ld (debug_mark+1),a  
2db7 3a c1 2d			ld a, (.dmark+2)  
2dba 32 7c ee			ld (debug_mark+2),a  
2dbd 18 03			jr .pastdmark  
2dbf ..			.dmark: db "LOP"  
2dc2 f1			.pastdmark: pop af  
2dc3			endm  
# End of macro DMARK
2dc3						CALLMONITOR 
2dc3 cd 80 13			call break_point_state  
2dc6				endm  
# End of macro CALLMONITOR
2dc6					endif 
2dc6				; next item on the stack is the limit. get it 
2dc6			 
2dc6			 
2dc6				FORTH_LOOP_POP 
2dc6 cd 07 1a			call macro_forth_loop_pop 
2dc9				endm 
# End of macro FORTH_LOOP_POP
2dc9			 
2dc9				FORTH_LOOP_TOS 
2dc9 cd fd 19			call macro_forth_loop_tos 
2dcc				endm 
# End of macro FORTH_LOOP_TOS
2dcc			 
2dcc d1				pop de		 ; de = i, hl = limit 
2dcd			 
2dcd					if DEBUG_FORTH_WORDS 
2dcd						DMARK "LP1" 
2dcd f5				push af  
2dce 3a e2 2d			ld a, (.dmark)  
2dd1 32 7a ee			ld (debug_mark),a  
2dd4 3a e3 2d			ld a, (.dmark+1)  
2dd7 32 7b ee			ld (debug_mark+1),a  
2dda 3a e4 2d			ld a, (.dmark+2)  
2ddd 32 7c ee			ld (debug_mark+2),a  
2de0 18 03			jr .pastdmark  
2de2 ..			.dmark: db "LP1"  
2de5 f1			.pastdmark: pop af  
2de6			endm  
# End of macro DMARK
2de6						CALLMONITOR 
2de6 cd 80 13			call break_point_state  
2de9				endm  
# End of macro CALLMONITOR
2de9					endif 
2de9			 
2de9				; go back to previous word 
2de9			 
2de9 d5				push de    ; save I for inc later 
2dea			 
2dea			 
2dea				; get limit 
2dea				;  is I at limit? 
2dea			 
2dea			 
2dea					if DEBUG_FORTH_WORDS 
2dea						DMARK "LP1" 
2dea f5				push af  
2deb 3a ff 2d			ld a, (.dmark)  
2dee 32 7a ee			ld (debug_mark),a  
2df1 3a 00 2e			ld a, (.dmark+1)  
2df4 32 7b ee			ld (debug_mark+1),a  
2df7 3a 01 2e			ld a, (.dmark+2)  
2dfa 32 7c ee			ld (debug_mark+2),a  
2dfd 18 03			jr .pastdmark  
2dff ..			.dmark: db "LP1"  
2e02 f1			.pastdmark: pop af  
2e03			endm  
# End of macro DMARK
2e03						CALLMONITOR 
2e03 cd 80 13			call break_point_state  
2e06				endm  
# End of macro CALLMONITOR
2e06					endif 
2e06			 
2e06 ed 52			sbc hl, de 
2e08			 
2e08			 
2e08				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2e08			 
2e08 20 26				jr nz, .loopnotdone 
2e0a			 
2e0a e1				pop hl   ; get rid of saved I 
2e0b				FORTH_LOOP_POP     ; get rid of limit 
2e0b cd 07 1a			call macro_forth_loop_pop 
2e0e				endm 
# End of macro FORTH_LOOP_POP
2e0e			 
2e0e				FORTH_RSP_POP     ; get rid of DO ptr 
2e0e cd e2 18			call macro_forth_rsp_pop 
2e11				endm 
# End of macro FORTH_RSP_POP
2e11			 
2e11			if DEBUG_FORTH_WORDS 
2e11						DMARK "LP>" 
2e11 f5				push af  
2e12 3a 26 2e			ld a, (.dmark)  
2e15 32 7a ee			ld (debug_mark),a  
2e18 3a 27 2e			ld a, (.dmark+1)  
2e1b 32 7b ee			ld (debug_mark+1),a  
2e1e 3a 28 2e			ld a, (.dmark+2)  
2e21 32 7c ee			ld (debug_mark+2),a  
2e24 18 03			jr .pastdmark  
2e26 ..			.dmark: db "LP>"  
2e29 f1			.pastdmark: pop af  
2e2a			endm  
# End of macro DMARK
2e2a				CALLMONITOR 
2e2a cd 80 13			call break_point_state  
2e2d				endm  
# End of macro CALLMONITOR
2e2d			endif 
2e2d			 
2e2d					NEXTW 
2e2d c3 0b 1b			jp macro_next 
2e30				endm 
# End of macro NEXTW
2e30				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2e30			 
2e30			.loopnotdone: 
2e30			 
2e30 e1				pop hl    ; get I 
2e31 23				inc hl 
2e32			 
2e32			   	; save new I 
2e32			 
2e32			 
2e32					; set I counter 
2e32			 
2e32 22 9a e6				ld (os_current_i), hl 
2e35			 
2e35					if DEBUG_FORTH_WORDS 
2e35						DMARK "LPN" 
2e35 f5				push af  
2e36 3a 4a 2e			ld a, (.dmark)  
2e39 32 7a ee			ld (debug_mark),a  
2e3c 3a 4b 2e			ld a, (.dmark+1)  
2e3f 32 7b ee			ld (debug_mark+1),a  
2e42 3a 4c 2e			ld a, (.dmark+2)  
2e45 32 7c ee			ld (debug_mark+2),a  
2e48 18 03			jr .pastdmark  
2e4a ..			.dmark: db "LPN"  
2e4d f1			.pastdmark: pop af  
2e4e			endm  
# End of macro DMARK
2e4e					CALLMONITOR 
2e4e cd 80 13			call break_point_state  
2e51				endm  
# End of macro CALLMONITOR
2e51					endif 
2e51					 
2e51				FORTH_LOOP_NEXT 
2e51 cd ca 19			call macro_forth_loop_next 
2e54				endm 
# End of macro FORTH_LOOP_NEXT
2e54			 
2e54			 
2e54					if DEBUG_FORTH_WORDS 
2e54 eb						ex de,hl 
2e55					endif 
2e55			 
2e55			;	; get DO ptr 
2e55			; 
2e55					if DEBUG_FORTH_WORDS 
2e55						DMARK "LP7" 
2e55 f5				push af  
2e56 3a 6a 2e			ld a, (.dmark)  
2e59 32 7a ee			ld (debug_mark),a  
2e5c 3a 6b 2e			ld a, (.dmark+1)  
2e5f 32 7b ee			ld (debug_mark+1),a  
2e62 3a 6c 2e			ld a, (.dmark+2)  
2e65 32 7c ee			ld (debug_mark+2),a  
2e68 18 03			jr .pastdmark  
2e6a ..			.dmark: db "LP7"  
2e6d f1			.pastdmark: pop af  
2e6e			endm  
# End of macro DMARK
2e6e					CALLMONITOR 
2e6e cd 80 13			call break_point_state  
2e71				endm  
# End of macro CALLMONITOR
2e71					endif 
2e71				FORTH_RSP_TOS 
2e71 cd d8 18			call macro_forth_rsp_tos 
2e74				endm 
# End of macro FORTH_RSP_TOS
2e74			 
2e74					if DEBUG_FORTH_WORDS 
2e74						DMARK "LP8" 
2e74 f5				push af  
2e75 3a 89 2e			ld a, (.dmark)  
2e78 32 7a ee			ld (debug_mark),a  
2e7b 3a 8a 2e			ld a, (.dmark+1)  
2e7e 32 7b ee			ld (debug_mark+1),a  
2e81 3a 8b 2e			ld a, (.dmark+2)  
2e84 32 7c ee			ld (debug_mark+2),a  
2e87 18 03			jr .pastdmark  
2e89 ..			.dmark: db "LP8"  
2e8c f1			.pastdmark: pop af  
2e8d			endm  
# End of macro DMARK
2e8d					CALLMONITOR 
2e8d cd 80 13			call break_point_state  
2e90				endm  
# End of macro CALLMONITOR
2e90					endif 
2e90				;push hl 
2e90			 
2e90				; not going to DO any more 
2e90				; get rid of the RSP pointer as DO will add it back in 
2e90				;FORTH_RSP_POP 
2e90				;pop hl 
2e90			 
2e90				;ld hl,(cli_ret_sp) 
2e90				;ld e, (hl) 
2e90				;inc hl 
2e90				;ld d, (hl) 
2e90				;ex de,hl 
2e90 22 76 e6			ld (os_tok_ptr), hl 
2e93					if DEBUG_FORTH_WORDS 
2e93						DMARK "LP<" 
2e93 f5				push af  
2e94 3a a8 2e			ld a, (.dmark)  
2e97 32 7a ee			ld (debug_mark),a  
2e9a 3a a9 2e			ld a, (.dmark+1)  
2e9d 32 7b ee			ld (debug_mark+1),a  
2ea0 3a aa 2e			ld a, (.dmark+2)  
2ea3 32 7c ee			ld (debug_mark+2),a  
2ea6 18 03			jr .pastdmark  
2ea8 ..			.dmark: db "LP<"  
2eab f1			.pastdmark: pop af  
2eac			endm  
# End of macro DMARK
2eac					CALLMONITOR 
2eac cd 80 13			call break_point_state  
2eaf				endm  
# End of macro CALLMONITOR
2eaf				endif 
2eaf c3 9c 1b			jp exec1 
2eb2			 
2eb2					 
2eb2			 
2eb2			 
2eb2					NEXTW 
2eb2 c3 0b 1b			jp macro_next 
2eb5				endm 
# End of macro NEXTW
2eb5			.I:  
2eb5			 
2eb5				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2eb5 5e				db WORD_SYS_CORE+74             
2eb6 e0 2e			dw .DLOOP            
2eb8 02				db 1 + 1 
2eb9 .. 00			db "I",0              
2ebb				endm 
# End of macro CWHEAD
2ebb			; | I ( -- ) Current loop counter | DONE 
2ebb					if DEBUG_FORTH_WORDS_KEY 
2ebb						DMARK "I.." 
2ebb f5				push af  
2ebc 3a d0 2e			ld a, (.dmark)  
2ebf 32 7a ee			ld (debug_mark),a  
2ec2 3a d1 2e			ld a, (.dmark+1)  
2ec5 32 7b ee			ld (debug_mark+1),a  
2ec8 3a d2 2e			ld a, (.dmark+2)  
2ecb 32 7c ee			ld (debug_mark+2),a  
2ece 18 03			jr .pastdmark  
2ed0 ..			.dmark: db "I.."  
2ed3 f1			.pastdmark: pop af  
2ed4			endm  
# End of macro DMARK
2ed4						CALLMONITOR 
2ed4 cd 80 13			call break_point_state  
2ed7				endm  
# End of macro CALLMONITOR
2ed7					endif 
2ed7			 
2ed7 2a 9a e6				ld hl,(os_current_i) 
2eda cd 1a 19				call forth_push_numhl 
2edd			 
2edd					NEXTW 
2edd c3 0b 1b			jp macro_next 
2ee0				endm 
# End of macro NEXTW
2ee0			.DLOOP: 
2ee0				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2ee0 5f				db WORD_SYS_CORE+75             
2ee1 c1 2f			dw .REPEAT            
2ee3 06				db 5 + 1 
2ee4 .. 00			db "-LOOP",0              
2eea				endm 
# End of macro CWHEAD
2eea			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2eea				; pop tos as current loop count to hl 
2eea					if DEBUG_FORTH_WORDS_KEY 
2eea						DMARK "-LP" 
2eea f5				push af  
2eeb 3a ff 2e			ld a, (.dmark)  
2eee 32 7a ee			ld (debug_mark),a  
2ef1 3a 00 2f			ld a, (.dmark+1)  
2ef4 32 7b ee			ld (debug_mark+1),a  
2ef7 3a 01 2f			ld a, (.dmark+2)  
2efa 32 7c ee			ld (debug_mark+2),a  
2efd 18 03			jr .pastdmark  
2eff ..			.dmark: db "-LP"  
2f02 f1			.pastdmark: pop af  
2f03			endm  
# End of macro DMARK
2f03						CALLMONITOR 
2f03 cd 80 13			call break_point_state  
2f06				endm  
# End of macro CALLMONITOR
2f06					endif 
2f06			 
2f06				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f06			 
2f06				FORTH_LOOP_TOS 
2f06 cd fd 19			call macro_forth_loop_tos 
2f09				endm 
# End of macro FORTH_LOOP_TOS
2f09 e5				push hl 
2f0a			 
2f0a					if DEBUG_FORTH_WORDS 
2f0a						DMARK "-LP" 
2f0a f5				push af  
2f0b 3a 1f 2f			ld a, (.dmark)  
2f0e 32 7a ee			ld (debug_mark),a  
2f11 3a 20 2f			ld a, (.dmark+1)  
2f14 32 7b ee			ld (debug_mark+1),a  
2f17 3a 21 2f			ld a, (.dmark+2)  
2f1a 32 7c ee			ld (debug_mark+2),a  
2f1d 18 03			jr .pastdmark  
2f1f ..			.dmark: db "-LP"  
2f22 f1			.pastdmark: pop af  
2f23			endm  
# End of macro DMARK
2f23						CALLMONITOR 
2f23 cd 80 13			call break_point_state  
2f26				endm  
# End of macro CALLMONITOR
2f26					endif 
2f26				; next item on the stack is the limit. get it 
2f26			 
2f26			 
2f26				FORTH_LOOP_POP 
2f26 cd 07 1a			call macro_forth_loop_pop 
2f29				endm 
# End of macro FORTH_LOOP_POP
2f29			 
2f29				FORTH_LOOP_TOS 
2f29 cd fd 19			call macro_forth_loop_tos 
2f2c				endm 
# End of macro FORTH_LOOP_TOS
2f2c			 
2f2c d1				pop de		 ; de = i, hl = limit 
2f2d			 
2f2d					if DEBUG_FORTH_WORDS 
2f2d						DMARK "-L1" 
2f2d f5				push af  
2f2e 3a 42 2f			ld a, (.dmark)  
2f31 32 7a ee			ld (debug_mark),a  
2f34 3a 43 2f			ld a, (.dmark+1)  
2f37 32 7b ee			ld (debug_mark+1),a  
2f3a 3a 44 2f			ld a, (.dmark+2)  
2f3d 32 7c ee			ld (debug_mark+2),a  
2f40 18 03			jr .pastdmark  
2f42 ..			.dmark: db "-L1"  
2f45 f1			.pastdmark: pop af  
2f46			endm  
# End of macro DMARK
2f46						CALLMONITOR 
2f46 cd 80 13			call break_point_state  
2f49				endm  
# End of macro CALLMONITOR
2f49					endif 
2f49			 
2f49				; go back to previous word 
2f49			 
2f49 d5				push de    ; save I for inc later 
2f4a			 
2f4a			 
2f4a				; get limit 
2f4a				;  is I at limit? 
2f4a			 
2f4a			 
2f4a					if DEBUG_FORTH_WORDS 
2f4a						DMARK "-L1" 
2f4a f5				push af  
2f4b 3a 5f 2f			ld a, (.dmark)  
2f4e 32 7a ee			ld (debug_mark),a  
2f51 3a 60 2f			ld a, (.dmark+1)  
2f54 32 7b ee			ld (debug_mark+1),a  
2f57 3a 61 2f			ld a, (.dmark+2)  
2f5a 32 7c ee			ld (debug_mark+2),a  
2f5d 18 03			jr .pastdmark  
2f5f ..			.dmark: db "-L1"  
2f62 f1			.pastdmark: pop af  
2f63			endm  
# End of macro DMARK
2f63						CALLMONITOR 
2f63 cd 80 13			call break_point_state  
2f66				endm  
# End of macro CALLMONITOR
2f66					endif 
2f66			 
2f66 ed 52			sbc hl, de 
2f68			 
2f68			 
2f68				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2f68			 
2f68 20 26				jr nz, .mloopnotdone 
2f6a			 
2f6a e1				pop hl   ; get rid of saved I 
2f6b				FORTH_LOOP_POP     ; get rid of limit 
2f6b cd 07 1a			call macro_forth_loop_pop 
2f6e				endm 
# End of macro FORTH_LOOP_POP
2f6e			 
2f6e				FORTH_RSP_POP     ; get rid of DO ptr 
2f6e cd e2 18			call macro_forth_rsp_pop 
2f71				endm 
# End of macro FORTH_RSP_POP
2f71			 
2f71			if DEBUG_FORTH_WORDS 
2f71						DMARK "-L>" 
2f71 f5				push af  
2f72 3a 86 2f			ld a, (.dmark)  
2f75 32 7a ee			ld (debug_mark),a  
2f78 3a 87 2f			ld a, (.dmark+1)  
2f7b 32 7b ee			ld (debug_mark+1),a  
2f7e 3a 88 2f			ld a, (.dmark+2)  
2f81 32 7c ee			ld (debug_mark+2),a  
2f84 18 03			jr .pastdmark  
2f86 ..			.dmark: db "-L>"  
2f89 f1			.pastdmark: pop af  
2f8a			endm  
# End of macro DMARK
2f8a				CALLMONITOR 
2f8a cd 80 13			call break_point_state  
2f8d				endm  
# End of macro CALLMONITOR
2f8d			endif 
2f8d			 
2f8d					NEXTW 
2f8d c3 0b 1b			jp macro_next 
2f90				endm 
# End of macro NEXTW
2f90				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2f90			 
2f90			.mloopnotdone: 
2f90			 
2f90 e1				pop hl    ; get I 
2f91 2b				dec hl 
2f92			 
2f92			   	; save new I 
2f92			 
2f92			 
2f92					; set I counter 
2f92			 
2f92 22 9a e6				ld (os_current_i), hl 
2f95			 
2f95					 
2f95				FORTH_LOOP_NEXT 
2f95 cd ca 19			call macro_forth_loop_next 
2f98				endm 
# End of macro FORTH_LOOP_NEXT
2f98			 
2f98			 
2f98					if DEBUG_FORTH_WORDS 
2f98 eb						ex de,hl 
2f99					endif 
2f99			 
2f99			;	; get DO ptr 
2f99			; 
2f99				FORTH_RSP_TOS 
2f99 cd d8 18			call macro_forth_rsp_tos 
2f9c				endm 
# End of macro FORTH_RSP_TOS
2f9c			 
2f9c				;push hl 
2f9c			 
2f9c				; not going to DO any more 
2f9c				; get rid of the RSP pointer as DO will add it back in 
2f9c				;FORTH_RSP_POP 
2f9c				;pop hl 
2f9c			 
2f9c			 
2f9c 22 76 e6			ld (os_tok_ptr), hl 
2f9f					if DEBUG_FORTH_WORDS 
2f9f						DMARK "-L<" 
2f9f f5				push af  
2fa0 3a b4 2f			ld a, (.dmark)  
2fa3 32 7a ee			ld (debug_mark),a  
2fa6 3a b5 2f			ld a, (.dmark+1)  
2fa9 32 7b ee			ld (debug_mark+1),a  
2fac 3a b6 2f			ld a, (.dmark+2)  
2faf 32 7c ee			ld (debug_mark+2),a  
2fb2 18 03			jr .pastdmark  
2fb4 ..			.dmark: db "-L<"  
2fb7 f1			.pastdmark: pop af  
2fb8			endm  
# End of macro DMARK
2fb8					CALLMONITOR 
2fb8 cd 80 13			call break_point_state  
2fbb				endm  
# End of macro CALLMONITOR
2fbb				endif 
2fbb c3 9c 1b			jp exec1 
2fbe			 
2fbe					 
2fbe			 
2fbe			 
2fbe			 
2fbe				NEXTW 
2fbe c3 0b 1b			jp macro_next 
2fc1				endm 
# End of macro NEXTW
2fc1			 
2fc1			 
2fc1			 
2fc1			 
2fc1			.REPEAT: 
2fc1				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
2fc1 71				db WORD_SYS_CORE+93             
2fc2 14 30			dw .UNTIL            
2fc4 06				db 5 + 1 
2fc5 .. 00			db "REPEAT",0              
2fcc				endm 
# End of macro CWHEAD
2fcc			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
2fcc			;  push pc to rsp stack past the REPEAT 
2fcc					if DEBUG_FORTH_WORDS_KEY 
2fcc						DMARK "REP" 
2fcc f5				push af  
2fcd 3a e1 2f			ld a, (.dmark)  
2fd0 32 7a ee			ld (debug_mark),a  
2fd3 3a e2 2f			ld a, (.dmark+1)  
2fd6 32 7b ee			ld (debug_mark+1),a  
2fd9 3a e3 2f			ld a, (.dmark+2)  
2fdc 32 7c ee			ld (debug_mark+2),a  
2fdf 18 03			jr .pastdmark  
2fe1 ..			.dmark: db "REP"  
2fe4 f1			.pastdmark: pop af  
2fe5			endm  
# End of macro DMARK
2fe5						CALLMONITOR 
2fe5 cd 80 13			call break_point_state  
2fe8				endm  
# End of macro CALLMONITOR
2fe8					endif 
2fe8			 
2fe8 2a 76 e6				ld hl, (os_tok_ptr) 
2feb 23					inc hl   ; R 
2fec 23					inc hl  ; E 
2fed 23					inc hl   ; P 
2fee 23					inc hl   ; E 
2fef 23					inc hl   ; A 
2ff0 23					inc hl   ; T 
2ff1 23					inc hl   ; zero 
2ff2					FORTH_RSP_NEXT 
2ff2 cd c1 18			call macro_forth_rsp_next 
2ff5				endm 
# End of macro FORTH_RSP_NEXT
2ff5			 
2ff5			 
2ff5					if DEBUG_FORTH_WORDS 
2ff5						DMARK "REP" 
2ff5 f5				push af  
2ff6 3a 0a 30			ld a, (.dmark)  
2ff9 32 7a ee			ld (debug_mark),a  
2ffc 3a 0b 30			ld a, (.dmark+1)  
2fff 32 7b ee			ld (debug_mark+1),a  
3002 3a 0c 30			ld a, (.dmark+2)  
3005 32 7c ee			ld (debug_mark+2),a  
3008 18 03			jr .pastdmark  
300a ..			.dmark: db "REP"  
300d f1			.pastdmark: pop af  
300e			endm  
# End of macro DMARK
300e						;pop bc    ; TODO BUG ?????? what is this for???? 
300e						CALLMONITOR 
300e cd 80 13			call break_point_state  
3011				endm  
# End of macro CALLMONITOR
3011					endif 
3011			 
3011					NEXTW 
3011 c3 0b 1b			jp macro_next 
3014				endm 
# End of macro NEXTW
3014			;	       NEXTW 
3014			 
3014			.UNTIL: 
3014				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3014 72				db WORD_SYS_CORE+94             
3015 ab 30			dw .ENDFLOW            
3017 06				db 5 + 1 
3018 .. 00			db "UNTIL",0              
301e				endm 
# End of macro CWHEAD
301e			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
301e			 
301e				; pop tos as check 
301e			 
301e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
301e			 
301e				FORTH_DSP_VALUEHL 
301e cd b5 19			call macro_dsp_valuehl 
3021				endm 
# End of macro FORTH_DSP_VALUEHL
3021			 
3021					if DEBUG_FORTH_WORDS_KEY 
3021						DMARK "UNT" 
3021 f5				push af  
3022 3a 36 30			ld a, (.dmark)  
3025 32 7a ee			ld (debug_mark),a  
3028 3a 37 30			ld a, (.dmark+1)  
302b 32 7b ee			ld (debug_mark+1),a  
302e 3a 38 30			ld a, (.dmark+2)  
3031 32 7c ee			ld (debug_mark+2),a  
3034 18 03			jr .pastdmark  
3036 ..			.dmark: db "UNT"  
3039 f1			.pastdmark: pop af  
303a			endm  
# End of macro DMARK
303a						CALLMONITOR 
303a cd 80 13			call break_point_state  
303d				endm  
# End of macro CALLMONITOR
303d					endif 
303d			 
303d			;	push hl 
303d				FORTH_DSP_POP 
303d cd 51 1a			call macro_forth_dsp_pop 
3040				endm 
# End of macro FORTH_DSP_POP
3040			 
3040			;	pop hl 
3040			 
3040				; test if true 
3040			 
3040 cd 91 0b			call ishlzero 
3043			;	ld a,l 
3043			;	add h 
3043			; 
3043			;	cp 0 
3043			 
3043 20 3e			jr nz, .untilnotdone 
3045			 
3045					if DEBUG_FORTH_WORDS 
3045						DMARK "UNf" 
3045 f5				push af  
3046 3a 5a 30			ld a, (.dmark)  
3049 32 7a ee			ld (debug_mark),a  
304c 3a 5b 30			ld a, (.dmark+1)  
304f 32 7b ee			ld (debug_mark+1),a  
3052 3a 5c 30			ld a, (.dmark+2)  
3055 32 7c ee			ld (debug_mark+2),a  
3058 18 03			jr .pastdmark  
305a ..			.dmark: db "UNf"  
305d f1			.pastdmark: pop af  
305e			endm  
# End of macro DMARK
305e						CALLMONITOR 
305e cd 80 13			call break_point_state  
3061				endm  
# End of macro CALLMONITOR
3061					endif 
3061			 
3061			 
3061			 
3061				FORTH_RSP_POP     ; get rid of DO ptr 
3061 cd e2 18			call macro_forth_rsp_pop 
3064				endm 
# End of macro FORTH_RSP_POP
3064			 
3064			if DEBUG_FORTH_WORDS 
3064						DMARK "UN>" 
3064 f5				push af  
3065 3a 79 30			ld a, (.dmark)  
3068 32 7a ee			ld (debug_mark),a  
306b 3a 7a 30			ld a, (.dmark+1)  
306e 32 7b ee			ld (debug_mark+1),a  
3071 3a 7b 30			ld a, (.dmark+2)  
3074 32 7c ee			ld (debug_mark+2),a  
3077 18 03			jr .pastdmark  
3079 ..			.dmark: db "UN>"  
307c f1			.pastdmark: pop af  
307d			endm  
# End of macro DMARK
307d				CALLMONITOR 
307d cd 80 13			call break_point_state  
3080				endm  
# End of macro CALLMONITOR
3080			endif 
3080			 
3080					NEXTW 
3080 c3 0b 1b			jp macro_next 
3083				endm 
# End of macro NEXTW
3083				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3083			 
3083			.untilnotdone: 
3083			 
3083			 
3083			;	; get DO ptr 
3083			; 
3083				FORTH_RSP_TOS 
3083 cd d8 18			call macro_forth_rsp_tos 
3086				endm 
# End of macro FORTH_RSP_TOS
3086			 
3086				;push hl 
3086			 
3086				; not going to DO any more 
3086				; get rid of the RSP pointer as DO will add it back in 
3086				;FORTH_RSP_POP 
3086				;pop hl 
3086			 
3086			 
3086 22 76 e6			ld (os_tok_ptr), hl 
3089					if DEBUG_FORTH_WORDS 
3089						DMARK "UN<" 
3089 f5				push af  
308a 3a 9e 30			ld a, (.dmark)  
308d 32 7a ee			ld (debug_mark),a  
3090 3a 9f 30			ld a, (.dmark+1)  
3093 32 7b ee			ld (debug_mark+1),a  
3096 3a a0 30			ld a, (.dmark+2)  
3099 32 7c ee			ld (debug_mark+2),a  
309c 18 03			jr .pastdmark  
309e ..			.dmark: db "UN<"  
30a1 f1			.pastdmark: pop af  
30a2			endm  
# End of macro DMARK
30a2					CALLMONITOR 
30a2 cd 80 13			call break_point_state  
30a5				endm  
# End of macro CALLMONITOR
30a5				endif 
30a5 c3 9c 1b			jp exec1 
30a8			 
30a8					 
30a8			 
30a8			 
30a8					NEXTW 
30a8 c3 0b 1b			jp macro_next 
30ab				endm 
# End of macro NEXTW
30ab			 
30ab			 
30ab			.ENDFLOW: 
30ab			 
30ab			; eof 
30ab			 
# End of file forth_words_flow.asm
30ab			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
30ab			include "forth_words_logic.asm" 
30ab			 
30ab			; | ## Logic Words 
30ab			 
30ab			.NOT: 
30ab				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
30ab 2d				db WORD_SYS_CORE+25             
30ac f3 30			dw .IS            
30ae 04				db 3 + 1 
30af .. 00			db "NOT",0              
30b3				endm 
# End of macro CWHEAD
30b3			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
30b3					if DEBUG_FORTH_WORDS_KEY 
30b3						DMARK "NOT" 
30b3 f5				push af  
30b4 3a c8 30			ld a, (.dmark)  
30b7 32 7a ee			ld (debug_mark),a  
30ba 3a c9 30			ld a, (.dmark+1)  
30bd 32 7b ee			ld (debug_mark+1),a  
30c0 3a ca 30			ld a, (.dmark+2)  
30c3 32 7c ee			ld (debug_mark+2),a  
30c6 18 03			jr .pastdmark  
30c8 ..			.dmark: db "NOT"  
30cb f1			.pastdmark: pop af  
30cc			endm  
# End of macro DMARK
30cc						CALLMONITOR 
30cc cd 80 13			call break_point_state  
30cf				endm  
# End of macro CALLMONITOR
30cf					endif 
30cf					FORTH_DSP 
30cf cd 9a 19			call macro_forth_dsp 
30d2				endm 
# End of macro FORTH_DSP
30d2 7e					ld a,(hl)	; get type of value on TOS 
30d3 fe 02				cp DS_TYPE_INUM  
30d5 28 03				jr z, .noti 
30d7					NEXTW 
30d7 c3 0b 1b			jp macro_next 
30da				endm 
# End of macro NEXTW
30da			.noti:          FORTH_DSP_VALUEHL 
30da cd b5 19			call macro_dsp_valuehl 
30dd				endm 
# End of macro FORTH_DSP_VALUEHL
30dd			;		push hl 
30dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
30dd cd 51 1a			call macro_forth_dsp_pop 
30e0				endm 
# End of macro FORTH_DSP_POP
30e0			;		pop hl 
30e0 3e 00				ld a,0 
30e2 bd					cp l 
30e3 28 04				jr z, .not2t 
30e5 2e 00				ld l, 0 
30e7 18 02				jr .notip 
30e9			 
30e9 2e ff		.not2t:		ld l, 255 
30eb			 
30eb 26 00		.notip:		ld h, 0	 
30ed			 
30ed cd 1a 19				call forth_push_numhl 
30f0					NEXTW 
30f0 c3 0b 1b			jp macro_next 
30f3				endm 
# End of macro NEXTW
30f3			 
30f3			.IS: 
30f3				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
30f3 2d				db WORD_SYS_CORE+25             
30f4 19 31			dw .LZERO            
30f6 03				db 2 + 1 
30f7 .. 00			db "IS",0              
30fa				endm 
# End of macro CWHEAD
30fa			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
30fa					if DEBUG_FORTH_WORDS_KEY 
30fa						DMARK "IS." 
30fa f5				push af  
30fb 3a 0f 31			ld a, (.dmark)  
30fe 32 7a ee			ld (debug_mark),a  
3101 3a 10 31			ld a, (.dmark+1)  
3104 32 7b ee			ld (debug_mark+1),a  
3107 3a 11 31			ld a, (.dmark+2)  
310a 32 7c ee			ld (debug_mark+2),a  
310d 18 03			jr .pastdmark  
310f ..			.dmark: db "IS."  
3112 f1			.pastdmark: pop af  
3113			endm  
# End of macro DMARK
3113						CALLMONITOR 
3113 cd 80 13			call break_point_state  
3116				endm  
# End of macro CALLMONITOR
3116					endif 
3116					NEXTW 
3116 c3 0b 1b			jp macro_next 
3119				endm 
# End of macro NEXTW
3119			.LZERO: 
3119				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3119 2d				db WORD_SYS_CORE+25             
311a 23 31			dw .TZERO            
311c 03				db 2 + 1 
311d .. 00			db "0<",0              
3120				endm 
# End of macro CWHEAD
3120			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3120					NEXTW 
3120 c3 0b 1b			jp macro_next 
3123				endm 
# End of macro NEXTW
3123			.TZERO: 
3123				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3123 2e				db WORD_SYS_CORE+26             
3124 6a 31			dw .LESS            
3126 03				db 2 + 1 
3127 .. 00			db "0=",0              
312a				endm 
# End of macro CWHEAD
312a			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
312a				; TODO add floating point number detection 
312a					;v5 FORTH_DSP_VALUE 
312a					if DEBUG_FORTH_WORDS_KEY 
312a						DMARK "0=." 
312a f5				push af  
312b 3a 3f 31			ld a, (.dmark)  
312e 32 7a ee			ld (debug_mark),a  
3131 3a 40 31			ld a, (.dmark+1)  
3134 32 7b ee			ld (debug_mark+1),a  
3137 3a 41 31			ld a, (.dmark+2)  
313a 32 7c ee			ld (debug_mark+2),a  
313d 18 03			jr .pastdmark  
313f ..			.dmark: db "0=."  
3142 f1			.pastdmark: pop af  
3143			endm  
# End of macro DMARK
3143						CALLMONITOR 
3143 cd 80 13			call break_point_state  
3146				endm  
# End of macro CALLMONITOR
3146					endif 
3146					FORTH_DSP 
3146 cd 9a 19			call macro_forth_dsp 
3149				endm 
# End of macro FORTH_DSP
3149 7e					ld a,(hl)	; get type of value on TOS 
314a fe 02				cp DS_TYPE_INUM  
314c 28 00				jr z, .tz_inum 
314e			 
314e				if FORTH_ENABLE_FLOATMATH 
314e					jr .tz_done 
314e			 
314e				endif 
314e					 
314e			 
314e			.tz_inum: 
314e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
314e cd b5 19			call macro_dsp_valuehl 
3151				endm 
# End of macro FORTH_DSP_VALUEHL
3151			 
3151			;		push hl 
3151			 
3151					; destroy value TOS 
3151			 
3151					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3151 cd 51 1a			call macro_forth_dsp_pop 
3154				endm 
# End of macro FORTH_DSP_POP
3154			 
3154			;		pop hl 
3154			 
3154 3e 00				ld a,0 
3156			 
3156 bd					cp l 
3157 20 08				jr nz, .tz_notzero 
3159			 
3159 bc					cp h 
315a			 
315a 20 05				jr nz, .tz_notzero 
315c			 
315c			 
315c 21 01 00				ld hl, FORTH_TRUE 
315f 18 03				jr .tz_done 
3161			 
3161 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3164			 
3164					; push value back onto stack for another op etc 
3164			 
3164			.tz_done: 
3164 cd 1a 19				call forth_push_numhl 
3167			 
3167					NEXTW 
3167 c3 0b 1b			jp macro_next 
316a				endm 
# End of macro NEXTW
316a			.LESS: 
316a				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
316a 2f				db WORD_SYS_CORE+27             
316b d3 31			dw .GT            
316d 02				db 1 + 1 
316e .. 00			db "<",0              
3170				endm 
# End of macro CWHEAD
3170			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3170				; TODO add floating point number detection 
3170					if DEBUG_FORTH_WORDS_KEY 
3170						DMARK "LES" 
3170 f5				push af  
3171 3a 85 31			ld a, (.dmark)  
3174 32 7a ee			ld (debug_mark),a  
3177 3a 86 31			ld a, (.dmark+1)  
317a 32 7b ee			ld (debug_mark+1),a  
317d 3a 87 31			ld a, (.dmark+2)  
3180 32 7c ee			ld (debug_mark+2),a  
3183 18 03			jr .pastdmark  
3185 ..			.dmark: db "LES"  
3188 f1			.pastdmark: pop af  
3189			endm  
# End of macro DMARK
3189						CALLMONITOR 
3189 cd 80 13			call break_point_state  
318c				endm  
# End of macro CALLMONITOR
318c					endif 
318c					FORTH_DSP 
318c cd 9a 19			call macro_forth_dsp 
318f				endm 
# End of macro FORTH_DSP
318f					;v5 FORTH_DSP_VALUE 
318f 7e					ld a,(hl)	; get type of value on TOS 
3190 fe 02				cp DS_TYPE_INUM  
3192 28 00				jr z, .less_inum 
3194			 
3194				if FORTH_ENABLE_FLOATMATH 
3194					jr .less_done 
3194			 
3194				endif 
3194					 
3194			 
3194			.less_inum: 
3194					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3194 cd b5 19			call macro_dsp_valuehl 
3197				endm 
# End of macro FORTH_DSP_VALUEHL
3197			 
3197 e5					push hl  ; u2 
3198			 
3198					; destroy value TOS 
3198			 
3198					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3198 cd 51 1a			call macro_forth_dsp_pop 
319b				endm 
# End of macro FORTH_DSP_POP
319b			 
319b			 
319b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
319b cd b5 19			call macro_dsp_valuehl 
319e				endm 
# End of macro FORTH_DSP_VALUEHL
319e			 
319e e5					push hl    ; u1 
319f			 
319f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
319f cd 51 1a			call macro_forth_dsp_pop 
31a2				endm 
# End of macro FORTH_DSP_POP
31a2			 
31a2			 
31a2 b7			 or a      ;clear carry flag 
31a3 01 00 00		 ld bc, FORTH_FALSE 
31a6 e1			  pop hl    ; u1 
31a7 d1			  pop de    ; u2 
31a8 ed 52		  sbc hl,de 
31aa 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
31ac			 
31ac 01 01 00		 ld bc, FORTH_TRUE 
31af			.lscont:  
31af c5					push bc 
31b0 e1					pop hl 
31b1			 
31b1					if DEBUG_FORTH_WORDS 
31b1						DMARK "LT1" 
31b1 f5				push af  
31b2 3a c6 31			ld a, (.dmark)  
31b5 32 7a ee			ld (debug_mark),a  
31b8 3a c7 31			ld a, (.dmark+1)  
31bb 32 7b ee			ld (debug_mark+1),a  
31be 3a c8 31			ld a, (.dmark+2)  
31c1 32 7c ee			ld (debug_mark+2),a  
31c4 18 03			jr .pastdmark  
31c6 ..			.dmark: db "LT1"  
31c9 f1			.pastdmark: pop af  
31ca			endm  
# End of macro DMARK
31ca						CALLMONITOR 
31ca cd 80 13			call break_point_state  
31cd				endm  
# End of macro CALLMONITOR
31cd					endif 
31cd cd 1a 19				call forth_push_numhl 
31d0			 
31d0					NEXTW 
31d0 c3 0b 1b			jp macro_next 
31d3				endm 
# End of macro NEXTW
31d3			.GT: 
31d3				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
31d3 30				db WORD_SYS_CORE+28             
31d4 3c 32			dw .EQUAL            
31d6 02				db 1 + 1 
31d7 .. 00			db ">",0              
31d9				endm 
# End of macro CWHEAD
31d9			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
31d9				; TODO add floating point number detection 
31d9					if DEBUG_FORTH_WORDS_KEY 
31d9						DMARK "GRT" 
31d9 f5				push af  
31da 3a ee 31			ld a, (.dmark)  
31dd 32 7a ee			ld (debug_mark),a  
31e0 3a ef 31			ld a, (.dmark+1)  
31e3 32 7b ee			ld (debug_mark+1),a  
31e6 3a f0 31			ld a, (.dmark+2)  
31e9 32 7c ee			ld (debug_mark+2),a  
31ec 18 03			jr .pastdmark  
31ee ..			.dmark: db "GRT"  
31f1 f1			.pastdmark: pop af  
31f2			endm  
# End of macro DMARK
31f2						CALLMONITOR 
31f2 cd 80 13			call break_point_state  
31f5				endm  
# End of macro CALLMONITOR
31f5					endif 
31f5					FORTH_DSP 
31f5 cd 9a 19			call macro_forth_dsp 
31f8				endm 
# End of macro FORTH_DSP
31f8					;FORTH_DSP_VALUE 
31f8 7e					ld a,(hl)	; get type of value on TOS 
31f9 fe 02				cp DS_TYPE_INUM  
31fb 28 00				jr z, .gt_inum 
31fd			 
31fd				if FORTH_ENABLE_FLOATMATH 
31fd					jr .gt_done 
31fd			 
31fd				endif 
31fd					 
31fd			 
31fd			.gt_inum: 
31fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31fd cd b5 19			call macro_dsp_valuehl 
3200				endm 
# End of macro FORTH_DSP_VALUEHL
3200			 
3200 e5					push hl  ; u2 
3201			 
3201					; destroy value TOS 
3201			 
3201					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3201 cd 51 1a			call macro_forth_dsp_pop 
3204				endm 
# End of macro FORTH_DSP_POP
3204			 
3204			 
3204					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3204 cd b5 19			call macro_dsp_valuehl 
3207				endm 
# End of macro FORTH_DSP_VALUEHL
3207			 
3207 e5					push hl    ; u1 
3208			 
3208					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3208 cd 51 1a			call macro_forth_dsp_pop 
320b				endm 
# End of macro FORTH_DSP_POP
320b			 
320b			 
320b b7			 or a      ;clear carry flag 
320c 01 00 00		 ld bc, FORTH_FALSE 
320f e1			  pop hl    ; u1 
3210 d1			  pop de    ; u2 
3211 ed 52		  sbc hl,de 
3213 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3215			 
3215 01 01 00		 ld bc, FORTH_TRUE 
3218			.gtcont:  
3218 c5					push bc 
3219 e1					pop hl 
321a			 
321a					if DEBUG_FORTH_WORDS 
321a						DMARK "GT1" 
321a f5				push af  
321b 3a 2f 32			ld a, (.dmark)  
321e 32 7a ee			ld (debug_mark),a  
3221 3a 30 32			ld a, (.dmark+1)  
3224 32 7b ee			ld (debug_mark+1),a  
3227 3a 31 32			ld a, (.dmark+2)  
322a 32 7c ee			ld (debug_mark+2),a  
322d 18 03			jr .pastdmark  
322f ..			.dmark: db "GT1"  
3232 f1			.pastdmark: pop af  
3233			endm  
# End of macro DMARK
3233						CALLMONITOR 
3233 cd 80 13			call break_point_state  
3236				endm  
# End of macro CALLMONITOR
3236					endif 
3236 cd 1a 19				call forth_push_numhl 
3239			 
3239					NEXTW 
3239 c3 0b 1b			jp macro_next 
323c				endm 
# End of macro NEXTW
323c			.EQUAL: 
323c				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
323c 31				db WORD_SYS_CORE+29             
323d a7 32			dw .ENDLOGIC            
323f 02				db 1 + 1 
3240 .. 00			db "=",0              
3242				endm 
# End of macro CWHEAD
3242			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3242				; TODO add floating point number detection 
3242					if DEBUG_FORTH_WORDS_KEY 
3242						DMARK "EQ." 
3242 f5				push af  
3243 3a 57 32			ld a, (.dmark)  
3246 32 7a ee			ld (debug_mark),a  
3249 3a 58 32			ld a, (.dmark+1)  
324c 32 7b ee			ld (debug_mark+1),a  
324f 3a 59 32			ld a, (.dmark+2)  
3252 32 7c ee			ld (debug_mark+2),a  
3255 18 03			jr .pastdmark  
3257 ..			.dmark: db "EQ."  
325a f1			.pastdmark: pop af  
325b			endm  
# End of macro DMARK
325b						CALLMONITOR 
325b cd 80 13			call break_point_state  
325e				endm  
# End of macro CALLMONITOR
325e					endif 
325e					FORTH_DSP 
325e cd 9a 19			call macro_forth_dsp 
3261				endm 
# End of macro FORTH_DSP
3261					;v5 FORTH_DSP_VALUE 
3261 7e					ld a,(hl)	; get type of value on TOS 
3262 fe 02				cp DS_TYPE_INUM  
3264 28 00				jr z, .eq_inum 
3266			 
3266				if FORTH_ENABLE_FLOATMATH 
3266					jr .eq_done 
3266			 
3266				endif 
3266					 
3266			 
3266			.eq_inum: 
3266					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3266 cd b5 19			call macro_dsp_valuehl 
3269				endm 
# End of macro FORTH_DSP_VALUEHL
3269			 
3269 e5					push hl 
326a			 
326a					; destroy value TOS 
326a			 
326a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
326a cd 51 1a			call macro_forth_dsp_pop 
326d				endm 
# End of macro FORTH_DSP_POP
326d			 
326d			 
326d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
326d cd b5 19			call macro_dsp_valuehl 
3270				endm 
# End of macro FORTH_DSP_VALUEHL
3270			 
3270					; one value on hl get other one back 
3270			 
3270 e5					push hl 
3271			 
3271					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3271 cd 51 1a			call macro_forth_dsp_pop 
3274				endm 
# End of macro FORTH_DSP_POP
3274			 
3274 0e 00				ld c, FORTH_FALSE 
3276			 
3276 e1					pop hl 
3277 d1					pop de 
3278			 
3278 7b					ld a, e 
3279 bd					cp l 
327a			 
327a 20 06				jr nz, .eq_done 
327c			 
327c 7a					ld a, d 
327d bc					cp h 
327e			 
327e 20 02				jr nz, .eq_done 
3280			 
3280 0e 01				ld c, FORTH_TRUE 
3282					 
3282			 
3282			 
3282			.eq_done: 
3282			 
3282					; TODO push value back onto stack for another op etc 
3282			 
3282 26 00				ld h, 0 
3284 69					ld l, c 
3285					if DEBUG_FORTH_WORDS 
3285						DMARK "EQ1" 
3285 f5				push af  
3286 3a 9a 32			ld a, (.dmark)  
3289 32 7a ee			ld (debug_mark),a  
328c 3a 9b 32			ld a, (.dmark+1)  
328f 32 7b ee			ld (debug_mark+1),a  
3292 3a 9c 32			ld a, (.dmark+2)  
3295 32 7c ee			ld (debug_mark+2),a  
3298 18 03			jr .pastdmark  
329a ..			.dmark: db "EQ1"  
329d f1			.pastdmark: pop af  
329e			endm  
# End of macro DMARK
329e						CALLMONITOR 
329e cd 80 13			call break_point_state  
32a1				endm  
# End of macro CALLMONITOR
32a1					endif 
32a1 cd 1a 19				call forth_push_numhl 
32a4			 
32a4					NEXTW 
32a4 c3 0b 1b			jp macro_next 
32a7				endm 
# End of macro NEXTW
32a7			 
32a7			 
32a7			.ENDLOGIC: 
32a7			; eof 
32a7			 
32a7			 
# End of file forth_words_logic.asm
32a7			include "forth_words_maths.asm" 
32a7			 
32a7			; | ## Maths Words 
32a7			 
32a7			.PLUS:	 
32a7				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
32a7 15				db WORD_SYS_CORE+1             
32a8 e9 32			dw .NEG            
32aa 02				db 1 + 1 
32ab .. 00			db "+",0              
32ad				endm 
# End of macro CWHEAD
32ad			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
32ad					if DEBUG_FORTH_WORDS_KEY 
32ad						DMARK "PLU" 
32ad f5				push af  
32ae 3a c2 32			ld a, (.dmark)  
32b1 32 7a ee			ld (debug_mark),a  
32b4 3a c3 32			ld a, (.dmark+1)  
32b7 32 7b ee			ld (debug_mark+1),a  
32ba 3a c4 32			ld a, (.dmark+2)  
32bd 32 7c ee			ld (debug_mark+2),a  
32c0 18 03			jr .pastdmark  
32c2 ..			.dmark: db "PLU"  
32c5 f1			.pastdmark: pop af  
32c6			endm  
# End of macro DMARK
32c6						CALLMONITOR 
32c6 cd 80 13			call break_point_state  
32c9				endm  
# End of macro CALLMONITOR
32c9					endif 
32c9					; add top two values and push back result 
32c9			 
32c9					;for v5 FORTH_DSP_VALUE 
32c9					FORTH_DSP 
32c9 cd 9a 19			call macro_forth_dsp 
32cc				endm 
# End of macro FORTH_DSP
32cc 7e					ld a,(hl)	; get type of value on TOS 
32cd fe 02				cp DS_TYPE_INUM  
32cf 28 03				jr z, .dot_inum 
32d1			 
32d1					NEXTW 
32d1 c3 0b 1b			jp macro_next 
32d4				endm 
# End of macro NEXTW
32d4			 
32d4			; float maths 
32d4			 
32d4				if FORTH_ENABLE_FLOATMATH 
32d4						inc hl      ; now at start of numeric as string 
32d4			 
32d4					if DEBUG_FORTH_MATHS 
32d4						DMARK "ADD" 
32d4				CALLMONITOR 
32d4					endif 
32d4			 
32d4					;ld ix, hl 
32d4					call CON 
32d4			 
32d4			 
32d4					push hl 
32d4					 
32d4					 
32d4			 
32d4						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
32d4			 
32d4					; get next number 
32d4			 
32d4						FORTH_DSP_VALUE 
32d4			 
32d4						inc hl      ; now at start of numeric as string 
32d4			 
32d4					;ld ix, hl 
32d4					call CON 
32d4			 
32d4					push hl 
32d4			 
32d4			 
32d4						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d4			 
32d4						; TODO do add 
32d4			 
32d4						call IADD 
32d4			 
32d4						; TODO get result back as ascii 
32d4			 
32d4						; TODO push result  
32d4			 
32d4			 
32d4			 
32d4						jr .dot_done 
32d4				endif 
32d4			 
32d4			.dot_inum: 
32d4			 
32d4			 
32d4					if DEBUG_FORTH_DOT 
32d4						DMARK "+IT" 
32d4				CALLMONITOR 
32d4					endif 
32d4			 
32d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32d4 cd b5 19			call macro_dsp_valuehl 
32d7				endm 
# End of macro FORTH_DSP_VALUEHL
32d7			 
32d7				; TODO add floating point number detection 
32d7			 
32d7 e5					push hl 
32d8			 
32d8					; destroy value TOS 
32d8			 
32d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d8 cd 51 1a			call macro_forth_dsp_pop 
32db				endm 
# End of macro FORTH_DSP_POP
32db			 
32db			 
32db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32db cd b5 19			call macro_dsp_valuehl 
32de				endm 
# End of macro FORTH_DSP_VALUEHL
32de			 
32de					; one value on hl get other one back 
32de			 
32de d1					pop de 
32df			 
32df					; do the add 
32df			 
32df 19					add hl,de 
32e0			 
32e0					; save it 
32e0			 
32e0			;		push hl	 
32e0			 
32e0					; 
32e0			 
32e0					; destroy value TOS 
32e0			 
32e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32e0 cd 51 1a			call macro_forth_dsp_pop 
32e3				endm 
# End of macro FORTH_DSP_POP
32e3			 
32e3					; TODO push value back onto stack for another op etc 
32e3			 
32e3			;		pop hl 
32e3			 
32e3			.dot_done: 
32e3 cd 1a 19				call forth_push_numhl 
32e6			 
32e6					NEXTW 
32e6 c3 0b 1b			jp macro_next 
32e9				endm 
# End of macro NEXTW
32e9			.NEG: 
32e9			 
32e9				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
32e9 17				db WORD_SYS_CORE+3             
32ea 2c 33			dw .DIV            
32ec 02				db 1 + 1 
32ed .. 00			db "-",0              
32ef				endm 
# End of macro CWHEAD
32ef			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
32ef					if DEBUG_FORTH_WORDS_KEY 
32ef						DMARK "SUB" 
32ef f5				push af  
32f0 3a 04 33			ld a, (.dmark)  
32f3 32 7a ee			ld (debug_mark),a  
32f6 3a 05 33			ld a, (.dmark+1)  
32f9 32 7b ee			ld (debug_mark+1),a  
32fc 3a 06 33			ld a, (.dmark+2)  
32ff 32 7c ee			ld (debug_mark+2),a  
3302 18 03			jr .pastdmark  
3304 ..			.dmark: db "SUB"  
3307 f1			.pastdmark: pop af  
3308			endm  
# End of macro DMARK
3308						CALLMONITOR 
3308 cd 80 13			call break_point_state  
330b				endm  
# End of macro CALLMONITOR
330b					endif 
330b			 
330b			 
330b				; TODO add floating point number detection 
330b					; v5 FORTH_DSP_VALUE 
330b					FORTH_DSP 
330b cd 9a 19			call macro_forth_dsp 
330e				endm 
# End of macro FORTH_DSP
330e 7e					ld a,(hl)	; get type of value on TOS 
330f fe 02				cp DS_TYPE_INUM  
3311 28 03				jr z, .neg_inum 
3313			 
3313					NEXTW 
3313 c3 0b 1b			jp macro_next 
3316				endm 
# End of macro NEXTW
3316			 
3316			; float maths 
3316			 
3316				if FORTH_ENABLE_FLOATMATH 
3316					jr .neg_done 
3316			 
3316				endif 
3316					 
3316			 
3316			.neg_inum: 
3316					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3316 cd b5 19			call macro_dsp_valuehl 
3319				endm 
# End of macro FORTH_DSP_VALUEHL
3319			 
3319 e5					push hl 
331a			 
331a					; destroy value TOS 
331a			 
331a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
331a cd 51 1a			call macro_forth_dsp_pop 
331d				endm 
# End of macro FORTH_DSP_POP
331d			 
331d			 
331d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
331d cd b5 19			call macro_dsp_valuehl 
3320				endm 
# End of macro FORTH_DSP_VALUEHL
3320			 
3320					; one value on hl get other one back 
3320			 
3320 d1					pop de 
3321			 
3321					; do the sub 
3321			;		ex de, hl 
3321			 
3321 ed 52				sbc hl,de 
3323			 
3323					; save it 
3323			 
3323			;		push hl	 
3323			 
3323					; 
3323			 
3323					; destroy value TOS 
3323			 
3323					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3323 cd 51 1a			call macro_forth_dsp_pop 
3326				endm 
# End of macro FORTH_DSP_POP
3326			 
3326					; TODO push value back onto stack for another op etc 
3326			 
3326			;		pop hl 
3326			 
3326 cd 1a 19				call forth_push_numhl 
3329			.neg_done: 
3329			 
3329					NEXTW 
3329 c3 0b 1b			jp macro_next 
332c				endm 
# End of macro NEXTW
332c			.DIV: 
332c				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
332c 18				db WORD_SYS_CORE+4             
332d 79 33			dw .MUL            
332f 02				db 1 + 1 
3330 .. 00			db "/",0              
3332				endm 
# End of macro CWHEAD
3332			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3332					if DEBUG_FORTH_WORDS_KEY 
3332						DMARK "DIV" 
3332 f5				push af  
3333 3a 47 33			ld a, (.dmark)  
3336 32 7a ee			ld (debug_mark),a  
3339 3a 48 33			ld a, (.dmark+1)  
333c 32 7b ee			ld (debug_mark+1),a  
333f 3a 49 33			ld a, (.dmark+2)  
3342 32 7c ee			ld (debug_mark+2),a  
3345 18 03			jr .pastdmark  
3347 ..			.dmark: db "DIV"  
334a f1			.pastdmark: pop af  
334b			endm  
# End of macro DMARK
334b						CALLMONITOR 
334b cd 80 13			call break_point_state  
334e				endm  
# End of macro CALLMONITOR
334e					endif 
334e				; TODO add floating point number detection 
334e					; v5 FORTH_DSP_VALUE 
334e					FORTH_DSP 
334e cd 9a 19			call macro_forth_dsp 
3351				endm 
# End of macro FORTH_DSP
3351 7e					ld a,(hl)	; get type of value on TOS 
3352 fe 02				cp DS_TYPE_INUM  
3354 28 03				jr z, .div_inum 
3356			 
3356				if FORTH_ENABLE_FLOATMATH 
3356					jr .div_done 
3356			 
3356				endif 
3356					NEXTW 
3356 c3 0b 1b			jp macro_next 
3359				endm 
# End of macro NEXTW
3359			.div_inum: 
3359			 
3359					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3359 cd b5 19			call macro_dsp_valuehl 
335c				endm 
# End of macro FORTH_DSP_VALUEHL
335c			 
335c e5					push hl    ; to go to bc 
335d			 
335d					; destroy value TOS 
335d			 
335d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
335d cd 51 1a			call macro_forth_dsp_pop 
3360				endm 
# End of macro FORTH_DSP_POP
3360			 
3360			 
3360					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3360 cd b5 19			call macro_dsp_valuehl 
3363				endm 
# End of macro FORTH_DSP_VALUEHL
3363			 
3363					; hl to go to de 
3363			 
3363 e5					push hl 
3364			 
3364 c1					pop bc 
3365 d1					pop de		 
3366			 
3366			 
3366					if DEBUG_FORTH_MATHS 
3366						DMARK "DIV" 
3366				CALLMONITOR 
3366					endif 
3366					; one value on hl but move to a get other one back 
3366			 
3366			        
3366 cd c5 0a			call Div16 
3369			 
3369			;	push af	 
3369 e5				push hl 
336a c5				push bc 
336b			 
336b					if DEBUG_FORTH_MATHS 
336b						DMARK "DI1" 
336b				CALLMONITOR 
336b					endif 
336b			 
336b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
336b cd 51 1a			call macro_forth_dsp_pop 
336e				endm 
# End of macro FORTH_DSP_POP
336e			 
336e			 
336e			 
336e e1					pop hl    ; result 
336f			 
336f cd 1a 19				call forth_push_numhl 
3372			 
3372 e1					pop hl    ; reminder 
3373			;		ld h,0 
3373			;		ld l,d 
3373			 
3373 cd 1a 19				call forth_push_numhl 
3376			.div_done: 
3376					NEXTW 
3376 c3 0b 1b			jp macro_next 
3379				endm 
# End of macro NEXTW
3379			.MUL: 
3379				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3379 19				db WORD_SYS_CORE+5             
337a be 33			dw .MIN            
337c 02				db 1 + 1 
337d .. 00			db "*",0              
337f				endm 
# End of macro CWHEAD
337f			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
337f				; TODO add floating point number detection 
337f					if DEBUG_FORTH_WORDS_KEY 
337f						DMARK "MUL" 
337f f5				push af  
3380 3a 94 33			ld a, (.dmark)  
3383 32 7a ee			ld (debug_mark),a  
3386 3a 95 33			ld a, (.dmark+1)  
3389 32 7b ee			ld (debug_mark+1),a  
338c 3a 96 33			ld a, (.dmark+2)  
338f 32 7c ee			ld (debug_mark+2),a  
3392 18 03			jr .pastdmark  
3394 ..			.dmark: db "MUL"  
3397 f1			.pastdmark: pop af  
3398			endm  
# End of macro DMARK
3398						CALLMONITOR 
3398 cd 80 13			call break_point_state  
339b				endm  
# End of macro CALLMONITOR
339b					endif 
339b					FORTH_DSP 
339b cd 9a 19			call macro_forth_dsp 
339e				endm 
# End of macro FORTH_DSP
339e					; v5 FORTH_DSP_VALUE 
339e 7e					ld a,(hl)	; get type of value on TOS 
339f fe 02				cp DS_TYPE_INUM  
33a1 28 03				jr z, .mul_inum 
33a3			 
33a3				if FORTH_ENABLE_FLOATMATH 
33a3					jr .mul_done 
33a3			 
33a3				endif 
33a3			 
33a3					NEXTW 
33a3 c3 0b 1b			jp macro_next 
33a6				endm 
# End of macro NEXTW
33a6			.mul_inum:	 
33a6			 
33a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33a6 cd b5 19			call macro_dsp_valuehl 
33a9				endm 
# End of macro FORTH_DSP_VALUEHL
33a9			 
33a9 e5					push hl 
33aa			 
33aa					; destroy value TOS 
33aa			 
33aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33aa cd 51 1a			call macro_forth_dsp_pop 
33ad				endm 
# End of macro FORTH_DSP_POP
33ad			 
33ad			 
33ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33ad cd b5 19			call macro_dsp_valuehl 
33b0				endm 
# End of macro FORTH_DSP_VALUEHL
33b0			 
33b0					; one value on hl but move to a get other one back 
33b0			 
33b0 7d					ld a, l 
33b1			 
33b1 d1					pop de 
33b2			 
33b2					; do the mull 
33b2			;		ex de, hl 
33b2			 
33b2 cd eb 0a				call Mult16 
33b5					; save it 
33b5			 
33b5			;		push hl	 
33b5			 
33b5					; 
33b5			 
33b5					; destroy value TOS 
33b5			 
33b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33b5 cd 51 1a			call macro_forth_dsp_pop 
33b8				endm 
# End of macro FORTH_DSP_POP
33b8			 
33b8					; TODO push value back onto stack for another op etc 
33b8			 
33b8			;		pop hl 
33b8			 
33b8 cd 1a 19				call forth_push_numhl 
33bb			 
33bb			.mul_done: 
33bb					NEXTW 
33bb c3 0b 1b			jp macro_next 
33be				endm 
# End of macro NEXTW
33be			 
33be			 
33be			 
33be			 
33be			.MIN: 
33be				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
33be 49				db WORD_SYS_CORE+53             
33bf 3f 34			dw .MAX            
33c1 04				db 3 + 1 
33c2 .. 00			db "MIN",0              
33c6				endm 
# End of macro CWHEAD
33c6			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
33c6					if DEBUG_FORTH_WORDS_KEY 
33c6						DMARK "MIN" 
33c6 f5				push af  
33c7 3a db 33			ld a, (.dmark)  
33ca 32 7a ee			ld (debug_mark),a  
33cd 3a dc 33			ld a, (.dmark+1)  
33d0 32 7b ee			ld (debug_mark+1),a  
33d3 3a dd 33			ld a, (.dmark+2)  
33d6 32 7c ee			ld (debug_mark+2),a  
33d9 18 03			jr .pastdmark  
33db ..			.dmark: db "MIN"  
33de f1			.pastdmark: pop af  
33df			endm  
# End of macro DMARK
33df						CALLMONITOR 
33df cd 80 13			call break_point_state  
33e2				endm  
# End of macro CALLMONITOR
33e2					endif 
33e2					; get u2 
33e2			 
33e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33e2 cd b5 19			call macro_dsp_valuehl 
33e5				endm 
# End of macro FORTH_DSP_VALUEHL
33e5			 
33e5 e5					push hl   ; u2 
33e6			 
33e6					; destroy value TOS 
33e6			 
33e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33e6 cd 51 1a			call macro_forth_dsp_pop 
33e9				endm 
# End of macro FORTH_DSP_POP
33e9			 
33e9					; get u1 
33e9			 
33e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33e9 cd b5 19			call macro_dsp_valuehl 
33ec				endm 
# End of macro FORTH_DSP_VALUEHL
33ec			 
33ec e5					push hl  ; u1 
33ed			 
33ed					; destroy value TOS 
33ed			 
33ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33ed cd 51 1a			call macro_forth_dsp_pop 
33f0				endm 
# End of macro FORTH_DSP_POP
33f0			 
33f0 b7			 or a      ;clear carry flag 
33f1 e1			  pop hl    ; u1 
33f2 d1			  pop de    ; u2 
33f3 e5				push hl   ; saved in case hl is lowest 
33f4 ed 52		  sbc hl,de 
33f6 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
33f8			 
33f8 e1				pop hl 
33f9					if DEBUG_FORTH_WORDS 
33f9						DMARK "MIN" 
33f9 f5				push af  
33fa 3a 0e 34			ld a, (.dmark)  
33fd 32 7a ee			ld (debug_mark),a  
3400 3a 0f 34			ld a, (.dmark+1)  
3403 32 7b ee			ld (debug_mark+1),a  
3406 3a 10 34			ld a, (.dmark+2)  
3409 32 7c ee			ld (debug_mark+2),a  
340c 18 03			jr .pastdmark  
340e ..			.dmark: db "MIN"  
3411 f1			.pastdmark: pop af  
3412			endm  
# End of macro DMARK
3412						CALLMONITOR 
3412 cd 80 13			call break_point_state  
3415				endm  
# End of macro CALLMONITOR
3415					endif 
3415 cd 1a 19				call forth_push_numhl 
3418			 
3418				       NEXTW 
3418 c3 0b 1b			jp macro_next 
341b				endm 
# End of macro NEXTW
341b			 
341b			.mincont:  
341b c1				pop bc   ; tidy up 
341c eb				ex de , hl  
341d					if DEBUG_FORTH_WORDS 
341d						DMARK "MI1" 
341d f5				push af  
341e 3a 32 34			ld a, (.dmark)  
3421 32 7a ee			ld (debug_mark),a  
3424 3a 33 34			ld a, (.dmark+1)  
3427 32 7b ee			ld (debug_mark+1),a  
342a 3a 34 34			ld a, (.dmark+2)  
342d 32 7c ee			ld (debug_mark+2),a  
3430 18 03			jr .pastdmark  
3432 ..			.dmark: db "MI1"  
3435 f1			.pastdmark: pop af  
3436			endm  
# End of macro DMARK
3436						CALLMONITOR 
3436 cd 80 13			call break_point_state  
3439				endm  
# End of macro CALLMONITOR
3439					endif 
3439 cd 1a 19				call forth_push_numhl 
343c			 
343c				       NEXTW 
343c c3 0b 1b			jp macro_next 
343f				endm 
# End of macro NEXTW
343f			.MAX: 
343f				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
343f 4a				db WORD_SYS_CORE+54             
3440 c0 34			dw .RND16            
3442 04				db 3 + 1 
3443 .. 00			db "MAX",0              
3447				endm 
# End of macro CWHEAD
3447			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3447					if DEBUG_FORTH_WORDS_KEY 
3447						DMARK "MAX" 
3447 f5				push af  
3448 3a 5c 34			ld a, (.dmark)  
344b 32 7a ee			ld (debug_mark),a  
344e 3a 5d 34			ld a, (.dmark+1)  
3451 32 7b ee			ld (debug_mark+1),a  
3454 3a 5e 34			ld a, (.dmark+2)  
3457 32 7c ee			ld (debug_mark+2),a  
345a 18 03			jr .pastdmark  
345c ..			.dmark: db "MAX"  
345f f1			.pastdmark: pop af  
3460			endm  
# End of macro DMARK
3460						CALLMONITOR 
3460 cd 80 13			call break_point_state  
3463				endm  
# End of macro CALLMONITOR
3463					endif 
3463					; get u2 
3463			 
3463					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3463 cd b5 19			call macro_dsp_valuehl 
3466				endm 
# End of macro FORTH_DSP_VALUEHL
3466			 
3466 e5					push hl   ; u2 
3467			 
3467					; destroy value TOS 
3467			 
3467					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3467 cd 51 1a			call macro_forth_dsp_pop 
346a				endm 
# End of macro FORTH_DSP_POP
346a			 
346a					; get u1 
346a			 
346a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
346a cd b5 19			call macro_dsp_valuehl 
346d				endm 
# End of macro FORTH_DSP_VALUEHL
346d			 
346d e5					push hl  ; u1 
346e			 
346e					; destroy value TOS 
346e			 
346e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
346e cd 51 1a			call macro_forth_dsp_pop 
3471				endm 
# End of macro FORTH_DSP_POP
3471			 
3471 b7			 or a      ;clear carry flag 
3472 e1			  pop hl    ; u1 
3473 d1			  pop de    ; u2 
3474 e5				push hl   ; saved in case hl is lowest 
3475 ed 52		  sbc hl,de 
3477 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3479			 
3479 e1				pop hl 
347a					if DEBUG_FORTH_WORDS 
347a						DMARK "MAX" 
347a f5				push af  
347b 3a 8f 34			ld a, (.dmark)  
347e 32 7a ee			ld (debug_mark),a  
3481 3a 90 34			ld a, (.dmark+1)  
3484 32 7b ee			ld (debug_mark+1),a  
3487 3a 91 34			ld a, (.dmark+2)  
348a 32 7c ee			ld (debug_mark+2),a  
348d 18 03			jr .pastdmark  
348f ..			.dmark: db "MAX"  
3492 f1			.pastdmark: pop af  
3493			endm  
# End of macro DMARK
3493						CALLMONITOR 
3493 cd 80 13			call break_point_state  
3496				endm  
# End of macro CALLMONITOR
3496					endif 
3496 cd 1a 19				call forth_push_numhl 
3499			 
3499				       NEXTW 
3499 c3 0b 1b			jp macro_next 
349c				endm 
# End of macro NEXTW
349c			 
349c			.maxcont:  
349c c1				pop bc   ; tidy up 
349d eb				ex de , hl  
349e					if DEBUG_FORTH_WORDS 
349e						DMARK "MA1" 
349e f5				push af  
349f 3a b3 34			ld a, (.dmark)  
34a2 32 7a ee			ld (debug_mark),a  
34a5 3a b4 34			ld a, (.dmark+1)  
34a8 32 7b ee			ld (debug_mark+1),a  
34ab 3a b5 34			ld a, (.dmark+2)  
34ae 32 7c ee			ld (debug_mark+2),a  
34b1 18 03			jr .pastdmark  
34b3 ..			.dmark: db "MA1"  
34b6 f1			.pastdmark: pop af  
34b7			endm  
# End of macro DMARK
34b7						CALLMONITOR 
34b7 cd 80 13			call break_point_state  
34ba				endm  
# End of macro CALLMONITOR
34ba					endif 
34ba cd 1a 19				call forth_push_numhl 
34bd				       NEXTW 
34bd c3 0b 1b			jp macro_next 
34c0				endm 
# End of macro NEXTW
34c0			 
34c0			.RND16: 
34c0				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
34c0 4e				db WORD_SYS_CORE+58             
34c1 ef 34			dw .RND8            
34c3 06				db 5 + 1 
34c4 .. 00			db "RND16",0              
34ca				endm 
# End of macro CWHEAD
34ca			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
34ca					if DEBUG_FORTH_WORDS_KEY 
34ca						DMARK "R16" 
34ca f5				push af  
34cb 3a df 34			ld a, (.dmark)  
34ce 32 7a ee			ld (debug_mark),a  
34d1 3a e0 34			ld a, (.dmark+1)  
34d4 32 7b ee			ld (debug_mark+1),a  
34d7 3a e1 34			ld a, (.dmark+2)  
34da 32 7c ee			ld (debug_mark+2),a  
34dd 18 03			jr .pastdmark  
34df ..			.dmark: db "R16"  
34e2 f1			.pastdmark: pop af  
34e3			endm  
# End of macro DMARK
34e3						CALLMONITOR 
34e3 cd 80 13			call break_point_state  
34e6				endm  
# End of macro CALLMONITOR
34e6					endif 
34e6 cd 8f 0a				call prng16  
34e9 cd 1a 19				call forth_push_numhl 
34ec				       NEXTW 
34ec c3 0b 1b			jp macro_next 
34ef				endm 
# End of macro NEXTW
34ef			.RND8: 
34ef				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
34ef 60				db WORD_SYS_CORE+76             
34f0 24 35			dw .RND            
34f2 05				db 4 + 1 
34f3 .. 00			db "RND8",0              
34f8				endm 
# End of macro CWHEAD
34f8			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
34f8					if DEBUG_FORTH_WORDS_KEY 
34f8						DMARK "RN8" 
34f8 f5				push af  
34f9 3a 0d 35			ld a, (.dmark)  
34fc 32 7a ee			ld (debug_mark),a  
34ff 3a 0e 35			ld a, (.dmark+1)  
3502 32 7b ee			ld (debug_mark+1),a  
3505 3a 0f 35			ld a, (.dmark+2)  
3508 32 7c ee			ld (debug_mark+2),a  
350b 18 03			jr .pastdmark  
350d ..			.dmark: db "RN8"  
3510 f1			.pastdmark: pop af  
3511			endm  
# End of macro DMARK
3511						CALLMONITOR 
3511 cd 80 13			call break_point_state  
3514				endm  
# End of macro CALLMONITOR
3514					endif 
3514 2a bb eb				ld hl,(xrandc) 
3517 23					inc hl 
3518 cd a9 0a				call xrnd 
351b 6f					ld l,a	 
351c 26 00				ld h,0 
351e cd 1a 19				call forth_push_numhl 
3521				       NEXTW 
3521 c3 0b 1b			jp macro_next 
3524				endm 
# End of macro NEXTW
3524			.RND: 
3524				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3524 60				db WORD_SYS_CORE+76             
3525 2a 36			dw .ENDMATHS            
3527 04				db 3 + 1 
3528 .. 00			db "RND",0              
352c				endm 
# End of macro CWHEAD
352c			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
352c			 
352c					if DEBUG_FORTH_WORDS_KEY 
352c						DMARK "RND" 
352c f5				push af  
352d 3a 41 35			ld a, (.dmark)  
3530 32 7a ee			ld (debug_mark),a  
3533 3a 42 35			ld a, (.dmark+1)  
3536 32 7b ee			ld (debug_mark+1),a  
3539 3a 43 35			ld a, (.dmark+2)  
353c 32 7c ee			ld (debug_mark+2),a  
353f 18 03			jr .pastdmark  
3541 ..			.dmark: db "RND"  
3544 f1			.pastdmark: pop af  
3545			endm  
# End of macro DMARK
3545						CALLMONITOR 
3545 cd 80 13			call break_point_state  
3548				endm  
# End of macro CALLMONITOR
3548					endif 
3548					 
3548					FORTH_DSP_VALUEHL    ; upper range 
3548 cd b5 19			call macro_dsp_valuehl 
354b				endm 
# End of macro FORTH_DSP_VALUEHL
354b			 
354b 22 bf eb				ld (LFSRSeed), hl	 
354e			 
354e					if DEBUG_FORTH_WORDS 
354e						DMARK "RN1" 
354e f5				push af  
354f 3a 63 35			ld a, (.dmark)  
3552 32 7a ee			ld (debug_mark),a  
3555 3a 64 35			ld a, (.dmark+1)  
3558 32 7b ee			ld (debug_mark+1),a  
355b 3a 65 35			ld a, (.dmark+2)  
355e 32 7c ee			ld (debug_mark+2),a  
3561 18 03			jr .pastdmark  
3563 ..			.dmark: db "RN1"  
3566 f1			.pastdmark: pop af  
3567			endm  
# End of macro DMARK
3567						CALLMONITOR 
3567 cd 80 13			call break_point_state  
356a				endm  
# End of macro CALLMONITOR
356a					endif 
356a					FORTH_DSP_POP 
356a cd 51 1a			call macro_forth_dsp_pop 
356d				endm 
# End of macro FORTH_DSP_POP
356d			 
356d					FORTH_DSP_VALUEHL    ; low range 
356d cd b5 19			call macro_dsp_valuehl 
3570				endm 
# End of macro FORTH_DSP_VALUEHL
3570			 
3570					if DEBUG_FORTH_WORDS 
3570						DMARK "RN2" 
3570 f5				push af  
3571 3a 85 35			ld a, (.dmark)  
3574 32 7a ee			ld (debug_mark),a  
3577 3a 86 35			ld a, (.dmark+1)  
357a 32 7b ee			ld (debug_mark+1),a  
357d 3a 87 35			ld a, (.dmark+2)  
3580 32 7c ee			ld (debug_mark+2),a  
3583 18 03			jr .pastdmark  
3585 ..			.dmark: db "RN2"  
3588 f1			.pastdmark: pop af  
3589			endm  
# End of macro DMARK
3589						CALLMONITOR 
3589 cd 80 13			call break_point_state  
358c				endm  
# End of macro CALLMONITOR
358c					endif 
358c 22 c1 eb				ld (LFSRSeed+2), hl 
358f			 
358f					FORTH_DSP_POP 
358f cd 51 1a			call macro_forth_dsp_pop 
3592				endm 
# End of macro FORTH_DSP_POP
3592			 
3592 e5					push hl 
3593			 
3593 e1			.inrange:	pop hl 
3594 cd 8f 0a				call prng16  
3597					if DEBUG_FORTH_WORDS 
3597						DMARK "RN3" 
3597 f5				push af  
3598 3a ac 35			ld a, (.dmark)  
359b 32 7a ee			ld (debug_mark),a  
359e 3a ad 35			ld a, (.dmark+1)  
35a1 32 7b ee			ld (debug_mark+1),a  
35a4 3a ae 35			ld a, (.dmark+2)  
35a7 32 7c ee			ld (debug_mark+2),a  
35aa 18 03			jr .pastdmark  
35ac ..			.dmark: db "RN3"  
35af f1			.pastdmark: pop af  
35b0			endm  
# End of macro DMARK
35b0						CALLMONITOR 
35b0 cd 80 13			call break_point_state  
35b3				endm  
# End of macro CALLMONITOR
35b3					endif 
35b3					 
35b3					; if the range is 8bit knock out the high byte 
35b3			 
35b3 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
35b7			 
35b7 3e 00				ld a, 0 
35b9 ba					cp d  
35ba 20 1e				jr nz, .hirange 
35bc 26 00				ld h, 0   ; knock it down to 8bit 
35be			 
35be					if DEBUG_FORTH_WORDS 
35be						DMARK "RNk" 
35be f5				push af  
35bf 3a d3 35			ld a, (.dmark)  
35c2 32 7a ee			ld (debug_mark),a  
35c5 3a d4 35			ld a, (.dmark+1)  
35c8 32 7b ee			ld (debug_mark+1),a  
35cb 3a d5 35			ld a, (.dmark+2)  
35ce 32 7c ee			ld (debug_mark+2),a  
35d1 18 03			jr .pastdmark  
35d3 ..			.dmark: db "RNk"  
35d6 f1			.pastdmark: pop af  
35d7			endm  
# End of macro DMARK
35d7						CALLMONITOR 
35d7 cd 80 13			call break_point_state  
35da				endm  
# End of macro CALLMONITOR
35da					endif 
35da			.hirange:   
35da e5					push hl  
35db b7					or a  
35dc ed 52		                sbc hl, de 
35de			 
35de					;call cmp16 
35de			 
35de 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
35e0 e1					pop hl 
35e1 e5					push hl 
35e2			 
35e2					if DEBUG_FORTH_WORDS 
35e2						DMARK "RN4" 
35e2 f5				push af  
35e3 3a f7 35			ld a, (.dmark)  
35e6 32 7a ee			ld (debug_mark),a  
35e9 3a f8 35			ld a, (.dmark+1)  
35ec 32 7b ee			ld (debug_mark+1),a  
35ef 3a f9 35			ld a, (.dmark+2)  
35f2 32 7c ee			ld (debug_mark+2),a  
35f5 18 03			jr .pastdmark  
35f7 ..			.dmark: db "RN4"  
35fa f1			.pastdmark: pop af  
35fb			endm  
# End of macro DMARK
35fb						CALLMONITOR 
35fb cd 80 13			call break_point_state  
35fe				endm  
# End of macro CALLMONITOR
35fe					endif 
35fe ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
3602					;call cmp16 
3602				 
3602 b7					or a  
3603 ed 52		                sbc hl, de 
3605 38 8c				jr c, .inrange 
3607			 
3607 e1					pop hl 
3608					 
3608					if DEBUG_FORTH_WORDS 
3608						DMARK "RNd" 
3608 f5				push af  
3609 3a 1d 36			ld a, (.dmark)  
360c 32 7a ee			ld (debug_mark),a  
360f 3a 1e 36			ld a, (.dmark+1)  
3612 32 7b ee			ld (debug_mark+1),a  
3615 3a 1f 36			ld a, (.dmark+2)  
3618 32 7c ee			ld (debug_mark+2),a  
361b 18 03			jr .pastdmark  
361d ..			.dmark: db "RNd"  
3620 f1			.pastdmark: pop af  
3621			endm  
# End of macro DMARK
3621						CALLMONITOR 
3621 cd 80 13			call break_point_state  
3624				endm  
# End of macro CALLMONITOR
3624					endif 
3624			 
3624			 
3624 cd 1a 19				call forth_push_numhl 
3627				       NEXTW 
3627 c3 0b 1b			jp macro_next 
362a				endm 
# End of macro NEXTW
362a			 
362a			.ENDMATHS: 
362a			 
362a			; eof 
362a			 
# End of file forth_words_maths.asm
362a			include "forth_words_display.asm" 
362a			 
362a			; | ## Display Words 
362a			 
362a			.ATP: 
362a				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
362a 62				db WORD_SYS_CORE+78             
362b a1 36			dw .FB            
362d 04				db 3 + 1 
362e .. 00			db "AT?",0              
3632				endm 
# End of macro CWHEAD
3632			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3632					if DEBUG_FORTH_WORDS_KEY 
3632						DMARK "AT?" 
3632 f5				push af  
3633 3a 47 36			ld a, (.dmark)  
3636 32 7a ee			ld (debug_mark),a  
3639 3a 48 36			ld a, (.dmark+1)  
363c 32 7b ee			ld (debug_mark+1),a  
363f 3a 49 36			ld a, (.dmark+2)  
3642 32 7c ee			ld (debug_mark+2),a  
3645 18 03			jr .pastdmark  
3647 ..			.dmark: db "AT?"  
364a f1			.pastdmark: pop af  
364b			endm  
# End of macro DMARK
364b						CALLMONITOR 
364b cd 80 13			call break_point_state  
364e				endm  
# End of macro CALLMONITOR
364e					endif 
364e 3a 5e eb				ld a, (f_cursor_ptr) 
3651			 
3651			if DEBUG_FORTH_WORDS 
3651				DMARK "AT?" 
3651 f5				push af  
3652 3a 66 36			ld a, (.dmark)  
3655 32 7a ee			ld (debug_mark),a  
3658 3a 67 36			ld a, (.dmark+1)  
365b 32 7b ee			ld (debug_mark+1),a  
365e 3a 68 36			ld a, (.dmark+2)  
3661 32 7c ee			ld (debug_mark+2),a  
3664 18 03			jr .pastdmark  
3666 ..			.dmark: db "AT?"  
3669 f1			.pastdmark: pop af  
366a			endm  
# End of macro DMARK
366a				CALLMONITOR 
366a cd 80 13			call break_point_state  
366d				endm  
# End of macro CALLMONITOR
366d			endif	 
366d					; count the number of rows 
366d			 
366d 06 00				ld b, 0 
366f 4f			.atpr:		ld c, a    ; save in case we go below zero 
3670 d6 28				sub display_cols 
3672 f2 78 36				jp p, .atprunder 
3675 04					inc b 
3676 18 f7				jr .atpr 
3678			.atprunder:	 
3678			if DEBUG_FORTH_WORDS 
3678				DMARK "A?2" 
3678 f5				push af  
3679 3a 8d 36			ld a, (.dmark)  
367c 32 7a ee			ld (debug_mark),a  
367f 3a 8e 36			ld a, (.dmark+1)  
3682 32 7b ee			ld (debug_mark+1),a  
3685 3a 8f 36			ld a, (.dmark+2)  
3688 32 7c ee			ld (debug_mark+2),a  
368b 18 03			jr .pastdmark  
368d ..			.dmark: db "A?2"  
3690 f1			.pastdmark: pop af  
3691			endm  
# End of macro DMARK
3691				CALLMONITOR 
3691 cd 80 13			call break_point_state  
3694				endm  
# End of macro CALLMONITOR
3694			endif	 
3694 26 00				ld h, 0 
3696 69					ld l, c 
3697 cd 1a 19				call forth_push_numhl 
369a 68					ld l, b  
369b cd 1a 19				call forth_push_numhl 
369e			 
369e			 
369e				NEXTW 
369e c3 0b 1b			jp macro_next 
36a1				endm 
# End of macro NEXTW
36a1			 
36a1			.FB: 
36a1				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
36a1 1b				db WORD_SYS_CORE+7             
36a2 ef 36			dw .EMIT            
36a4 03				db 2 + 1 
36a5 .. 00			db "FB",0              
36a8				endm 
# End of macro CWHEAD
36a8			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
36a8			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
36a8			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
36a8			; | | If automatic display is off then updates will not be shown until DRAW is used. 
36a8					if DEBUG_FORTH_WORDS_KEY 
36a8						DMARK "FB." 
36a8 f5				push af  
36a9 3a bd 36			ld a, (.dmark)  
36ac 32 7a ee			ld (debug_mark),a  
36af 3a be 36			ld a, (.dmark+1)  
36b2 32 7b ee			ld (debug_mark+1),a  
36b5 3a bf 36			ld a, (.dmark+2)  
36b8 32 7c ee			ld (debug_mark+2),a  
36bb 18 03			jr .pastdmark  
36bd ..			.dmark: db "FB."  
36c0 f1			.pastdmark: pop af  
36c1			endm  
# End of macro DMARK
36c1						CALLMONITOR 
36c1 cd 80 13			call break_point_state  
36c4				endm  
# End of macro CALLMONITOR
36c4					endif 
36c4			 
36c4					FORTH_DSP_VALUEHL 
36c4 cd b5 19			call macro_dsp_valuehl 
36c7				endm 
# End of macro FORTH_DSP_VALUEHL
36c7			 
36c7 7d					ld a, l 
36c8 fe 01				cp 1 
36ca 20 05				jr nz, .fbn1 
36cc 21 1f ed				ld hl, display_fb1 
36cf 18 15				jr .fbset 
36d1 fe 02		.fbn1:		cp 2 
36d3 20 05				jr nz, .fbn2 
36d5 21 dd eb				ld hl, display_fb2 
36d8 18 0c				jr .fbset 
36da fe 03		.fbn2:		cp 3 
36dc 20 05				jr nz, .fbn3 
36de 21 7e ec				ld hl, display_fb3 
36e1 18 03				jr .fbset 
36e3			.fbn3:		 ; if invalid number select first 
36e3 21 1f ed				ld hl, display_fb1 
36e6 22 db eb		.fbset:		ld (display_fb_active), hl 
36e9			 
36e9					FORTH_DSP_POP 
36e9 cd 51 1a			call macro_forth_dsp_pop 
36ec				endm 
# End of macro FORTH_DSP_POP
36ec			 
36ec					NEXTW 
36ec c3 0b 1b			jp macro_next 
36ef				endm 
# End of macro NEXTW
36ef			 
36ef			 
36ef			.EMIT: 
36ef				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
36ef 1b				db WORD_SYS_CORE+7             
36f0 40 37			dw .DOTH            
36f2 05				db 4 + 1 
36f3 .. 00			db "EMIT",0              
36f8				endm 
# End of macro CWHEAD
36f8			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
36f8					; get value off TOS and display it 
36f8			 
36f8					if DEBUG_FORTH_WORDS_KEY 
36f8						DMARK "EMT" 
36f8 f5				push af  
36f9 3a 0d 37			ld a, (.dmark)  
36fc 32 7a ee			ld (debug_mark),a  
36ff 3a 0e 37			ld a, (.dmark+1)  
3702 32 7b ee			ld (debug_mark+1),a  
3705 3a 0f 37			ld a, (.dmark+2)  
3708 32 7c ee			ld (debug_mark+2),a  
370b 18 03			jr .pastdmark  
370d ..			.dmark: db "EMT"  
3710 f1			.pastdmark: pop af  
3711			endm  
# End of macro DMARK
3711						CALLMONITOR 
3711 cd 80 13			call break_point_state  
3714				endm  
# End of macro CALLMONITOR
3714					endif 
3714			 
3714					FORTH_DSP_VALUEHL 
3714 cd b5 19			call macro_dsp_valuehl 
3717				endm 
# End of macro FORTH_DSP_VALUEHL
3717			 
3717 7d					ld a,l 
3718			 
3718					; TODO write to display 
3718			 
3718 32 73 e5				ld (os_input), a 
371b 3e 00				ld a, 0 
371d 32 74 e5				ld (os_input+1), a 
3720					 
3720 3a 5e eb				ld a, (f_cursor_ptr) 
3723 11 73 e5				ld de, os_input 
3726 cd 52 09				call str_at_display 
3729			 
3729			 
3729 3a 3c eb				ld a,(cli_autodisplay) 
372c fe 00				cp 0 
372e 28 03				jr z, .enoupdate 
3730 cd 62 09						call update_display 
3733					.enoupdate: 
3733			 
3733 3a 5e eb				ld a, (f_cursor_ptr) 
3736 3c					inc a 
3737 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
373a			 
373a			 
373a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373a cd 51 1a			call macro_forth_dsp_pop 
373d				endm 
# End of macro FORTH_DSP_POP
373d			  
373d			 
373d					NEXTW 
373d c3 0b 1b			jp macro_next 
3740				endm 
# End of macro NEXTW
3740			.DOTH: 
3740				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3740 1c				db WORD_SYS_CORE+8             
3741 70 37			dw .DOTF            
3743 03				db 2 + 1 
3744 .. 00			db ".-",0              
3747				endm 
# End of macro CWHEAD
3747			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3747					; get value off TOS and display it 
3747					if DEBUG_FORTH_WORDS_KEY 
3747						DMARK "DTD" 
3747 f5				push af  
3748 3a 5c 37			ld a, (.dmark)  
374b 32 7a ee			ld (debug_mark),a  
374e 3a 5d 37			ld a, (.dmark+1)  
3751 32 7b ee			ld (debug_mark+1),a  
3754 3a 5e 37			ld a, (.dmark+2)  
3757 32 7c ee			ld (debug_mark+2),a  
375a 18 03			jr .pastdmark  
375c ..			.dmark: db "DTD"  
375f f1			.pastdmark: pop af  
3760			endm  
# End of macro DMARK
3760						CALLMONITOR 
3760 cd 80 13			call break_point_state  
3763				endm  
# End of macro CALLMONITOR
3763					endif 
3763 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3765 3e 00			ld a, 0 
3767 32 3d eb			ld (cli_mvdot), a 
376a c3 c7 37			jp .dotgo 
376d				NEXTW 
376d c3 0b 1b			jp macro_next 
3770				endm 
# End of macro NEXTW
3770			.DOTF: 
3770				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3770 1c				db WORD_SYS_CORE+8             
3771 9e 37			dw .DOT            
3773 03				db 2 + 1 
3774 .. 00			db ".>",0              
3777				endm 
# End of macro CWHEAD
3777			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3777					; get value off TOS and display it 
3777			        ; TODO BUG adds extra spaces 
3777			        ; TODO BUG handle numerics? 
3777					if DEBUG_FORTH_WORDS_KEY 
3777						DMARK "DTC" 
3777 f5				push af  
3778 3a 8c 37			ld a, (.dmark)  
377b 32 7a ee			ld (debug_mark),a  
377e 3a 8d 37			ld a, (.dmark+1)  
3781 32 7b ee			ld (debug_mark+1),a  
3784 3a 8e 37			ld a, (.dmark+2)  
3787 32 7c ee			ld (debug_mark+2),a  
378a 18 03			jr .pastdmark  
378c ..			.dmark: db "DTC"  
378f f1			.pastdmark: pop af  
3790			endm  
# End of macro DMARK
3790						CALLMONITOR 
3790 cd 80 13			call break_point_state  
3793				endm  
# End of macro CALLMONITOR
3793					endif 
3793 3e 01			ld a, 1 
3795 32 3d eb			ld (cli_mvdot), a 
3798 c3 c7 37			jp .dotgo 
379b				NEXTW 
379b c3 0b 1b			jp macro_next 
379e				endm 
# End of macro NEXTW
379e			 
379e			.DOT: 
379e				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
379e 1c				db WORD_SYS_CORE+8             
379f 2a 38			dw .CLS            
37a1 02				db 1 + 1 
37a2 .. 00			db ".",0              
37a4				endm 
# End of macro CWHEAD
37a4			        ; | . ( u -- ) Display TOS | DONE 
37a4					; get value off TOS and display it 
37a4			 
37a4					if DEBUG_FORTH_WORDS_KEY 
37a4						DMARK "DOT" 
37a4 f5				push af  
37a5 3a b9 37			ld a, (.dmark)  
37a8 32 7a ee			ld (debug_mark),a  
37ab 3a ba 37			ld a, (.dmark+1)  
37ae 32 7b ee			ld (debug_mark+1),a  
37b1 3a bb 37			ld a, (.dmark+2)  
37b4 32 7c ee			ld (debug_mark+2),a  
37b7 18 03			jr .pastdmark  
37b9 ..			.dmark: db "DOT"  
37bc f1			.pastdmark: pop af  
37bd			endm  
# End of macro DMARK
37bd						CALLMONITOR 
37bd cd 80 13			call break_point_state  
37c0				endm  
# End of macro CALLMONITOR
37c0					endif 
37c0 3e 00			ld a, 0 
37c2 32 3d eb			ld (cli_mvdot), a 
37c5 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
37c7				 
37c7			 
37c7			.dotgo: 
37c7			 
37c7			; move up type to on stack for parserv5 
37c7					FORTH_DSP 
37c7 cd 9a 19			call macro_forth_dsp 
37ca				endm 
# End of macro FORTH_DSP
37ca				;FORTH_DSP_VALUE  
37ca			 
37ca			if DEBUG_FORTH_DOT 
37ca				DMARK "DOT" 
37ca				CALLMONITOR 
37ca			endif	 
37ca			;		.print: 
37ca			 
37ca 7e				ld a,(hl)  ; work out what type of value is on the TOS 
37cb 23				inc hl   ; position to the actual value 
37cc fe 01			cp DS_TYPE_STR 
37ce 20 06			jr nz, .dotnum1  
37d0			 
37d0			; display string 
37d0				FORTH_DSP_VALUE  
37d0 cd 9e 19			call macro_forth_dsp_value 
37d3				endm 
# End of macro FORTH_DSP_VALUE
37d3 eb				ex de,hl 
37d4 18 11			jr .dotwrite 
37d6			 
37d6			.dotnum1: 
37d6 fe 02			cp DS_TYPE_INUM 
37d8 20 0c			jr nz, .dotflot 
37da			 
37da			 
37da			; display number 
37da			 
37da			;	push hl 
37da			;	call clear_display 
37da			;	pop hl 
37da			 
37da 5e				ld e, (hl) 
37db 23				inc hl 
37dc 56				ld d, (hl) 
37dd 21 75 e3			ld hl, scratch 
37e0			if DEBUG_FORTH_DOT 
37e0				DMARK "DT1" 
37e0				CALLMONITOR 
37e0			endif	 
37e0			 
37e0 cd 75 0f			call uitoa_16 
37e3 eb				ex de,hl 
37e4			 
37e4			if DEBUG_FORTH_DOT 
37e4				DMARK "DT2" 
37e4				CALLMONITOR 
37e4			endif	 
37e4			 
37e4			;	ld de, os_word_scratch 
37e4 18 01			jr .dotwrite 
37e6			 
37e6 00			.dotflot:   nop 
37e7			; TODO print floating point number 
37e7			 
37e7			.dotwrite:		 
37e7			 
37e7					; if c is set then set all '-' to spaces 
37e7					; need to also take into account .>  
37e7			 
37e7 3e 01				ld a, 1 
37e9 b9					cp c 
37ea 20 13				jr nz, .nodashswap 
37ec			 
37ec					; DE has the string to write, working with HL 
37ec			 
37ec 06 ff				ld b, 255 
37ee d5					push de 
37ef e1					pop hl 
37f0			 
37f0			if DEBUG_FORTH_DOT 
37f0				DMARK "DT-" 
37f0				CALLMONITOR 
37f0			endif	 
37f0 7e			.dashscan:	ld a, (hl) 
37f1 fe 00				cp 0 
37f3 28 0a				jr z, .nodashswap 
37f5 fe 2d				cp '-' 
37f7 20 03				jr nz, .dashskip 
37f9 3e 20				ld a, ' ' 
37fb 77					ld (hl), a 
37fc 23			.dashskip:	inc hl 
37fd			if DEBUG_FORTH_DOT 
37fd				DMARK "D-2" 
37fd				CALLMONITOR 
37fd			endif	 
37fd 10 f1				djnz .dashscan 
37ff			 
37ff			if DEBUG_FORTH_DOT 
37ff				DMARK "D-1" 
37ff				CALLMONITOR 
37ff			endif	 
37ff			 
37ff			.nodashswap: 
37ff			 
37ff e5					push hl   ; save string start in case we need to advance print 
3800			 
3800 3a 5e eb				ld a, (f_cursor_ptr) 
3803 cd 52 09				call str_at_display 
3806 3a 3c eb				ld a,(cli_autodisplay) 
3809 fe 00				cp 0 
380b 28 03				jr z, .noupdate 
380d cd 62 09						call update_display 
3810					.noupdate: 
3810			 
3810			 
3810					; see if we need to advance the print position 
3810			 
3810 e1					pop hl   ; get back string 
3811			 
3811 3a 3d eb				ld a, (cli_mvdot) 
3814			if DEBUG_FORTH_DOT 
3814					ld e,a 
3814				DMARK "D>1" 
3814				CALLMONITOR 
3814			endif	 
3814 fe 00				cp 0 
3816 28 0c				jr z, .noadv 
3818					; yes, lets advance the print position 
3818 3e 00				ld a, 0 
381a cd d1 0f				call strlent 
381d 3a 5e eb				ld a, (f_cursor_ptr) 
3820 85					add a,l 
3821					;call addatohl 
3821					;ld a, l 
3821 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
3824			 
3824			if DEBUG_FORTH_DOT 
3824				DMARK "D->" 
3824				CALLMONITOR 
3824			endif	 
3824			 
3824			.noadv:	 
3824			 
3824					if DEBUG_FORTH_DOT_WAIT 
3824							call next_page_prompt 
3824					endif	 
3824			; TODO this pop off the stack causes a crash. i dont know why 
3824			 
3824			 
3824			if DEBUG_FORTH_DOT 
3824				DMARK "DTh" 
3824				CALLMONITOR 
3824			endif	 
3824			 
3824					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3824 cd 51 1a			call macro_forth_dsp_pop 
3827				endm 
# End of macro FORTH_DSP_POP
3827			 
3827			if DEBUG_FORTH_DOT 
3827				DMARK "DTi" 
3827				CALLMONITOR 
3827			endif	 
3827			 
3827			 
3827					NEXTW 
3827 c3 0b 1b			jp macro_next 
382a				endm 
# End of macro NEXTW
382a			 
382a			.CLS: 
382a				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
382a 35				db WORD_SYS_CORE+33             
382b 57 38			dw .DRAW            
382d 04				db 3 + 1 
382e .. 00			db "CLS",0              
3832				endm 
# End of macro CWHEAD
3832			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3832					if DEBUG_FORTH_WORDS_KEY 
3832						DMARK "CLS" 
3832 f5				push af  
3833 3a 47 38			ld a, (.dmark)  
3836 32 7a ee			ld (debug_mark),a  
3839 3a 48 38			ld a, (.dmark+1)  
383c 32 7b ee			ld (debug_mark+1),a  
383f 3a 49 38			ld a, (.dmark+2)  
3842 32 7c ee			ld (debug_mark+2),a  
3845 18 03			jr .pastdmark  
3847 ..			.dmark: db "CLS"  
384a f1			.pastdmark: pop af  
384b			endm  
# End of macro DMARK
384b						CALLMONITOR 
384b cd 80 13			call break_point_state  
384e				endm  
# End of macro CALLMONITOR
384e					endif 
384e cd 3f 09				call clear_display 
3851 c3 65 39				jp .home		; and home cursor 
3854					NEXTW 
3854 c3 0b 1b			jp macro_next 
3857				endm 
# End of macro NEXTW
3857			 
3857			.DRAW: 
3857				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3857 36				db WORD_SYS_CORE+34             
3858 82 38			dw .DUMP            
385a 05				db 4 + 1 
385b .. 00			db "DRAW",0              
3860				endm 
# End of macro CWHEAD
3860			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3860					if DEBUG_FORTH_WORDS_KEY 
3860						DMARK "DRW" 
3860 f5				push af  
3861 3a 75 38			ld a, (.dmark)  
3864 32 7a ee			ld (debug_mark),a  
3867 3a 76 38			ld a, (.dmark+1)  
386a 32 7b ee			ld (debug_mark+1),a  
386d 3a 77 38			ld a, (.dmark+2)  
3870 32 7c ee			ld (debug_mark+2),a  
3873 18 03			jr .pastdmark  
3875 ..			.dmark: db "DRW"  
3878 f1			.pastdmark: pop af  
3879			endm  
# End of macro DMARK
3879						CALLMONITOR 
3879 cd 80 13			call break_point_state  
387c				endm  
# End of macro CALLMONITOR
387c					endif 
387c cd 62 09				call update_display 
387f					NEXTW 
387f c3 0b 1b			jp macro_next 
3882				endm 
# End of macro NEXTW
3882			 
3882			.DUMP: 
3882				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3882 37				db WORD_SYS_CORE+35             
3883 ba 38			dw .CDUMP            
3885 05				db 4 + 1 
3886 .. 00			db "DUMP",0              
388b				endm 
# End of macro CWHEAD
388b			; | DUMP ( x -- ) With address x display dump   | DONE 
388b			; TODO pop address to use off of the stack 
388b					if DEBUG_FORTH_WORDS_KEY 
388b						DMARK "DUM" 
388b f5				push af  
388c 3a a0 38			ld a, (.dmark)  
388f 32 7a ee			ld (debug_mark),a  
3892 3a a1 38			ld a, (.dmark+1)  
3895 32 7b ee			ld (debug_mark+1),a  
3898 3a a2 38			ld a, (.dmark+2)  
389b 32 7c ee			ld (debug_mark+2),a  
389e 18 03			jr .pastdmark  
38a0 ..			.dmark: db "DUM"  
38a3 f1			.pastdmark: pop af  
38a4			endm  
# End of macro DMARK
38a4						CALLMONITOR 
38a4 cd 80 13			call break_point_state  
38a7				endm  
# End of macro CALLMONITOR
38a7					endif 
38a7 cd 3f 09				call clear_display 
38aa			 
38aa					; get address 
38aa			 
38aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38aa cd b5 19			call macro_dsp_valuehl 
38ad				endm 
# End of macro FORTH_DSP_VALUEHL
38ad				 
38ad					; save it for cdump 
38ad			 
38ad 22 98 e6				ld (os_cur_ptr),hl 
38b0			 
38b0					; destroy value TOS 
38b0			 
38b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38b0 cd 51 1a			call macro_forth_dsp_pop 
38b3				endm 
# End of macro FORTH_DSP_POP
38b3			 
38b3 cd 9a 17				call dumpcont	; skip old style of param parsing	 
38b6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
38b7					NEXTW 
38b7 c3 0b 1b			jp macro_next 
38ba				endm 
# End of macro NEXTW
38ba			.CDUMP: 
38ba				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
38ba 38				db WORD_SYS_CORE+36             
38bb ea 38			dw .DAT            
38bd 06				db 5 + 1 
38be .. 00			db "CDUMP",0              
38c4				endm 
# End of macro CWHEAD
38c4			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
38c4					if DEBUG_FORTH_WORDS_KEY 
38c4						DMARK "CDP" 
38c4 f5				push af  
38c5 3a d9 38			ld a, (.dmark)  
38c8 32 7a ee			ld (debug_mark),a  
38cb 3a da 38			ld a, (.dmark+1)  
38ce 32 7b ee			ld (debug_mark+1),a  
38d1 3a db 38			ld a, (.dmark+2)  
38d4 32 7c ee			ld (debug_mark+2),a  
38d7 18 03			jr .pastdmark  
38d9 ..			.dmark: db "CDP"  
38dc f1			.pastdmark: pop af  
38dd			endm  
# End of macro DMARK
38dd						CALLMONITOR 
38dd cd 80 13			call break_point_state  
38e0				endm  
# End of macro CALLMONITOR
38e0					endif 
38e0 cd 3f 09				call clear_display 
38e3 cd 9a 17				call dumpcont	 
38e6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
38e7					NEXTW 
38e7 c3 0b 1b			jp macro_next 
38ea				endm 
# End of macro NEXTW
38ea			 
38ea			 
38ea			 
38ea			 
38ea			.DAT: 
38ea				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
38ea 3d				db WORD_SYS_CORE+41             
38eb 40 39			dw .HOME            
38ed 03				db 2 + 1 
38ee .. 00			db "AT",0              
38f1				endm 
# End of macro CWHEAD
38f1			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
38f1					if DEBUG_FORTH_WORDS_KEY 
38f1						DMARK "AT." 
38f1 f5				push af  
38f2 3a 06 39			ld a, (.dmark)  
38f5 32 7a ee			ld (debug_mark),a  
38f8 3a 07 39			ld a, (.dmark+1)  
38fb 32 7b ee			ld (debug_mark+1),a  
38fe 3a 08 39			ld a, (.dmark+2)  
3901 32 7c ee			ld (debug_mark+2),a  
3904 18 03			jr .pastdmark  
3906 ..			.dmark: db "AT."  
3909 f1			.pastdmark: pop af  
390a			endm  
# End of macro DMARK
390a						CALLMONITOR 
390a cd 80 13			call break_point_state  
390d				endm  
# End of macro CALLMONITOR
390d					endif 
390d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
390d cd b5 19			call macro_dsp_valuehl 
3910				endm 
# End of macro FORTH_DSP_VALUEHL
3910			 
3910			 
3910					; TODO save cursor row 
3910 7d					ld a,l 
3911 fe 02				cp 2 
3913 20 04				jr nz, .crow3 
3915 3e 28				ld a, display_row_2 
3917 18 12				jr .ccol1 
3919 fe 03		.crow3:		cp 3 
391b 20 04				jr nz, .crow4 
391d 3e 50				ld a, display_row_3 
391f 18 0a				jr .ccol1 
3921 fe 04		.crow4:		cp 4 
3923 20 04				jr nz, .crow1 
3925 3e 78				ld a, display_row_4 
3927 18 02				jr .ccol1 
3929 3e 00		.crow1:		ld a,display_row_1 
392b f5			.ccol1:		push af			; got row offset 
392c 6f					ld l,a 
392d 26 00				ld h,0 
392f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392f cd 51 1a			call macro_forth_dsp_pop 
3932				endm 
# End of macro FORTH_DSP_POP
3932					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3932 cd b5 19			call macro_dsp_valuehl 
3935				endm 
# End of macro FORTH_DSP_VALUEHL
3935					; TODO save cursor col 
3935 f1					pop af 
3936 85					add l		; add col offset 
3937 32 5e eb				ld (f_cursor_ptr), a 
393a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
393a cd 51 1a			call macro_forth_dsp_pop 
393d				endm 
# End of macro FORTH_DSP_POP
393d			 
393d					; calculate  
393d			 
393d					NEXTW 
393d c3 0b 1b			jp macro_next 
3940				endm 
# End of macro NEXTW
3940			 
3940			 
3940			.HOME: 
3940				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3940 41				db WORD_SYS_CORE+45             
3941 6d 39			dw .SPACE            
3943 05				db 4 + 1 
3944 .. 00			db "HOME",0              
3949				endm 
# End of macro CWHEAD
3949			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3949					if DEBUG_FORTH_WORDS_KEY 
3949						DMARK "HOM" 
3949 f5				push af  
394a 3a 5e 39			ld a, (.dmark)  
394d 32 7a ee			ld (debug_mark),a  
3950 3a 5f 39			ld a, (.dmark+1)  
3953 32 7b ee			ld (debug_mark+1),a  
3956 3a 60 39			ld a, (.dmark+2)  
3959 32 7c ee			ld (debug_mark+2),a  
395c 18 03			jr .pastdmark  
395e ..			.dmark: db "HOM"  
3961 f1			.pastdmark: pop af  
3962			endm  
# End of macro DMARK
3962						CALLMONITOR 
3962 cd 80 13			call break_point_state  
3965				endm  
# End of macro CALLMONITOR
3965					endif 
3965 3e 00		.home:		ld a, 0		; and home cursor 
3967 32 5e eb				ld (f_cursor_ptr), a 
396a					NEXTW 
396a c3 0b 1b			jp macro_next 
396d				endm 
# End of macro NEXTW
396d			 
396d			 
396d			.SPACE: 
396d				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
396d 46				db WORD_SYS_CORE+50             
396e 9b 39			dw .SPACES            
3970 03				db 2 + 1 
3971 .. 00			db "BL",0              
3974				endm 
# End of macro CWHEAD
3974			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3974					if DEBUG_FORTH_WORDS_KEY 
3974						DMARK "BL." 
3974 f5				push af  
3975 3a 89 39			ld a, (.dmark)  
3978 32 7a ee			ld (debug_mark),a  
397b 3a 8a 39			ld a, (.dmark+1)  
397e 32 7b ee			ld (debug_mark+1),a  
3981 3a 8b 39			ld a, (.dmark+2)  
3984 32 7c ee			ld (debug_mark+2),a  
3987 18 03			jr .pastdmark  
3989 ..			.dmark: db "BL."  
398c f1			.pastdmark: pop af  
398d			endm  
# End of macro DMARK
398d						CALLMONITOR 
398d cd 80 13			call break_point_state  
3990				endm  
# End of macro CALLMONITOR
3990					endif 
3990 21 99 39				ld hl, .blstr 
3993 cd 2c 19				call forth_push_str 
3996					 
3996				       NEXTW 
3996 c3 0b 1b			jp macro_next 
3999				endm 
# End of macro NEXTW
3999			 
3999 .. 00		.blstr: db " ", 0 
399b			 
399b			.SPACES: 
399b				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
399b 47				db WORD_SYS_CORE+51             
399c 36 3a			dw .SCROLL            
399e 07				db 6 + 1 
399f .. 00			db "SPACES",0              
39a6				endm 
# End of macro CWHEAD
39a6			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
39a6					if DEBUG_FORTH_WORDS_KEY 
39a6						DMARK "SPS" 
39a6 f5				push af  
39a7 3a bb 39			ld a, (.dmark)  
39aa 32 7a ee			ld (debug_mark),a  
39ad 3a bc 39			ld a, (.dmark+1)  
39b0 32 7b ee			ld (debug_mark+1),a  
39b3 3a bd 39			ld a, (.dmark+2)  
39b6 32 7c ee			ld (debug_mark+2),a  
39b9 18 03			jr .pastdmark  
39bb ..			.dmark: db "SPS"  
39be f1			.pastdmark: pop af  
39bf			endm  
# End of macro DMARK
39bf						CALLMONITOR 
39bf cd 80 13			call break_point_state  
39c2				endm  
# End of macro CALLMONITOR
39c2					endif 
39c2			 
39c2			 
39c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39c2 cd b5 19			call macro_dsp_valuehl 
39c5				endm 
# End of macro FORTH_DSP_VALUEHL
39c5			 
39c5			;		push hl    ; u 
39c5					if DEBUG_FORTH_WORDS 
39c5						DMARK "SPA" 
39c5 f5				push af  
39c6 3a da 39			ld a, (.dmark)  
39c9 32 7a ee			ld (debug_mark),a  
39cc 3a db 39			ld a, (.dmark+1)  
39cf 32 7b ee			ld (debug_mark+1),a  
39d2 3a dc 39			ld a, (.dmark+2)  
39d5 32 7c ee			ld (debug_mark+2),a  
39d8 18 03			jr .pastdmark  
39da ..			.dmark: db "SPA"  
39dd f1			.pastdmark: pop af  
39de			endm  
# End of macro DMARK
39de						CALLMONITOR 
39de cd 80 13			call break_point_state  
39e1				endm  
# End of macro CALLMONITOR
39e1					endif 
39e1			 
39e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e1 cd 51 1a			call macro_forth_dsp_pop 
39e4				endm 
# End of macro FORTH_DSP_POP
39e4			;		pop hl 
39e4 4d					ld c, l 
39e5 06 00				ld b, 0 
39e7 21 75 e3				ld hl, scratch  
39ea			 
39ea					if DEBUG_FORTH_WORDS 
39ea						DMARK "SP2" 
39ea f5				push af  
39eb 3a ff 39			ld a, (.dmark)  
39ee 32 7a ee			ld (debug_mark),a  
39f1 3a 00 3a			ld a, (.dmark+1)  
39f4 32 7b ee			ld (debug_mark+1),a  
39f7 3a 01 3a			ld a, (.dmark+2)  
39fa 32 7c ee			ld (debug_mark+2),a  
39fd 18 03			jr .pastdmark  
39ff ..			.dmark: db "SP2"  
3a02 f1			.pastdmark: pop af  
3a03			endm  
# End of macro DMARK
3a03						CALLMONITOR 
3a03 cd 80 13			call break_point_state  
3a06				endm  
# End of macro CALLMONITOR
3a06					endif 
3a06 3e 20				ld a, ' ' 
3a08 c5			.spaces1:	push bc 
3a09 77					ld (hl),a 
3a0a 23					inc hl 
3a0b c1					pop bc 
3a0c 10 fa				djnz .spaces1 
3a0e 3e 00				ld a,0 
3a10 77					ld (hl),a 
3a11 21 75 e3				ld hl, scratch 
3a14					if DEBUG_FORTH_WORDS 
3a14						DMARK "SP3" 
3a14 f5				push af  
3a15 3a 29 3a			ld a, (.dmark)  
3a18 32 7a ee			ld (debug_mark),a  
3a1b 3a 2a 3a			ld a, (.dmark+1)  
3a1e 32 7b ee			ld (debug_mark+1),a  
3a21 3a 2b 3a			ld a, (.dmark+2)  
3a24 32 7c ee			ld (debug_mark+2),a  
3a27 18 03			jr .pastdmark  
3a29 ..			.dmark: db "SP3"  
3a2c f1			.pastdmark: pop af  
3a2d			endm  
# End of macro DMARK
3a2d						CALLMONITOR 
3a2d cd 80 13			call break_point_state  
3a30				endm  
# End of macro CALLMONITOR
3a30					endif 
3a30 cd 62 19				call forth_apush 
3a33			 
3a33				       NEXTW 
3a33 c3 0b 1b			jp macro_next 
3a36				endm 
# End of macro NEXTW
3a36			 
3a36			 
3a36			 
3a36			.SCROLL: 
3a36				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3a36 53				db WORD_SYS_CORE+63             
3a37 63 3a			dw .SCROLLD            
3a39 07				db 6 + 1 
3a3a .. 00			db "SCROLL",0              
3a41				endm 
# End of macro CWHEAD
3a41			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3a41					if DEBUG_FORTH_WORDS_KEY 
3a41						DMARK "SCR" 
3a41 f5				push af  
3a42 3a 56 3a			ld a, (.dmark)  
3a45 32 7a ee			ld (debug_mark),a  
3a48 3a 57 3a			ld a, (.dmark+1)  
3a4b 32 7b ee			ld (debug_mark+1),a  
3a4e 3a 58 3a			ld a, (.dmark+2)  
3a51 32 7c ee			ld (debug_mark+2),a  
3a54 18 03			jr .pastdmark  
3a56 ..			.dmark: db "SCR"  
3a59 f1			.pastdmark: pop af  
3a5a			endm  
# End of macro DMARK
3a5a						CALLMONITOR 
3a5a cd 80 13			call break_point_state  
3a5d				endm  
# End of macro CALLMONITOR
3a5d					endif 
3a5d			 
3a5d cd 01 09			call scroll_up 
3a60			;	call update_display 
3a60			 
3a60					NEXTW 
3a60 c3 0b 1b			jp macro_next 
3a63				endm 
# End of macro NEXTW
3a63			 
3a63			 
3a63			 
3a63			;		; get dir 
3a63			; 
3a63			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a63			; 
3a63			;		push hl 
3a63			; 
3a63			;		; destroy value TOS 
3a63			; 
3a63			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a63			; 
3a63			;		; get count 
3a63			; 
3a63			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a63			; 
3a63			;		push hl 
3a63			; 
3a63			;		; destroy value TOS 
3a63			; 
3a63			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a63			; 
3a63			;		; one value on hl get other one back 
3a63			; 
3a63			;		pop bc    ; count 
3a63			; 
3a63			;		pop de   ; dir 
3a63			; 
3a63			; 
3a63			;		ld b, c 
3a63			; 
3a63			;.scrolldir:     push bc 
3a63			;		push de 
3a63			; 
3a63			;		ld a, 0 
3a63			;		cp e 
3a63			;		jr z, .scrollup  
3a63			;		call scroll_down 
3a63			;		jr .scrollnext 
3a63			;.scrollup:	call scroll_up 
3a63			; 
3a63			;		 
3a63			;.scrollnext: 
3a63			;		pop de 
3a63			;		pop bc 
3a63			;		djnz .scrolldir 
3a63			; 
3a63			; 
3a63			; 
3a63			; 
3a63			; 
3a63			;		NEXTW 
3a63			 
3a63			.SCROLLD: 
3a63				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3a63 53				db WORD_SYS_CORE+63             
3a64 91 3a			dw .ATQ            
3a66 08				db 7 + 1 
3a67 .. 00			db "SCROLLD",0              
3a6f				endm 
# End of macro CWHEAD
3a6f			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3a6f					if DEBUG_FORTH_WORDS_KEY 
3a6f						DMARK "SCD" 
3a6f f5				push af  
3a70 3a 84 3a			ld a, (.dmark)  
3a73 32 7a ee			ld (debug_mark),a  
3a76 3a 85 3a			ld a, (.dmark+1)  
3a79 32 7b ee			ld (debug_mark+1),a  
3a7c 3a 86 3a			ld a, (.dmark+2)  
3a7f 32 7c ee			ld (debug_mark+2),a  
3a82 18 03			jr .pastdmark  
3a84 ..			.dmark: db "SCD"  
3a87 f1			.pastdmark: pop af  
3a88			endm  
# End of macro DMARK
3a88						CALLMONITOR 
3a88 cd 80 13			call break_point_state  
3a8b				endm  
# End of macro CALLMONITOR
3a8b					endif 
3a8b			 
3a8b cd 25 09			call scroll_down 
3a8e			;	call update_display 
3a8e			 
3a8e					NEXTW 
3a8e c3 0b 1b			jp macro_next 
3a91				endm 
# End of macro NEXTW
3a91			 
3a91			 
3a91			.ATQ: 
3a91				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3a91 62				db WORD_SYS_CORE+78             
3a92 ef 3a			dw .AUTODSP            
3a94 04				db 3 + 1 
3a95 .. 00			db "AT@",0              
3a99				endm 
# End of macro CWHEAD
3a99			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3a99					if DEBUG_FORTH_WORDS_KEY 
3a99						DMARK "ATA" 
3a99 f5				push af  
3a9a 3a ae 3a			ld a, (.dmark)  
3a9d 32 7a ee			ld (debug_mark),a  
3aa0 3a af 3a			ld a, (.dmark+1)  
3aa3 32 7b ee			ld (debug_mark+1),a  
3aa6 3a b0 3a			ld a, (.dmark+2)  
3aa9 32 7c ee			ld (debug_mark+2),a  
3aac 18 03			jr .pastdmark  
3aae ..			.dmark: db "ATA"  
3ab1 f1			.pastdmark: pop af  
3ab2			endm  
# End of macro DMARK
3ab2						CALLMONITOR 
3ab2 cd 80 13			call break_point_state  
3ab5				endm  
# End of macro CALLMONITOR
3ab5					endif 
3ab5			 
3ab5			 
3ab5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ab5 cd b5 19			call macro_dsp_valuehl 
3ab8				endm 
# End of macro FORTH_DSP_VALUEHL
3ab8			 
3ab8					; TODO save cursor row 
3ab8 7d					ld a,l 
3ab9 fe 02				cp 2 
3abb 20 04				jr nz, .crow3aq 
3abd 3e 28				ld a, display_row_2 
3abf 18 12				jr .ccol1aq 
3ac1 fe 03		.crow3aq:		cp 3 
3ac3 20 04				jr nz, .crow4aq 
3ac5 3e 50				ld a, display_row_3 
3ac7 18 0a				jr .ccol1aq 
3ac9 fe 04		.crow4aq:		cp 4 
3acb 20 04				jr nz, .crow1aq 
3acd 3e 78				ld a, display_row_4 
3acf 18 02				jr .ccol1aq 
3ad1 3e 00		.crow1aq:		ld a,display_row_1 
3ad3 f5			.ccol1aq:		push af			; got row offset 
3ad4 6f					ld l,a 
3ad5 26 00				ld h,0 
3ad7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad7 cd 51 1a			call macro_forth_dsp_pop 
3ada				endm 
# End of macro FORTH_DSP_POP
3ada					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ada cd b5 19			call macro_dsp_valuehl 
3add				endm 
# End of macro FORTH_DSP_VALUEHL
3add					; TODO save cursor col 
3add f1					pop af 
3ade 85					add l		; add col offset 
3adf			 
3adf					; add current frame buffer address 
3adf 2a db eb				ld hl, (display_fb_active) 
3ae2 cd 68 0b				call addatohl 
3ae5			 
3ae5			 
3ae5			 
3ae5			 
3ae5					; get char frame buffer location offset in hl 
3ae5			 
3ae5 7e					ld a,(hl) 
3ae6 26 00				ld h, 0 
3ae8 6f					ld l, a 
3ae9			 
3ae9 cd 1a 19				call forth_push_numhl 
3aec			 
3aec			 
3aec					NEXTW 
3aec c3 0b 1b			jp macro_next 
3aef				endm 
# End of macro NEXTW
3aef			 
3aef			.AUTODSP: 
3aef				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3aef 63				db WORD_SYS_CORE+79             
3af0 05 3b			dw .MENU            
3af2 05				db 4 + 1 
3af3 .. 00			db "ADSP",0              
3af8				endm 
# End of macro CWHEAD
3af8			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3af8			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3af8			 
3af8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3af8 cd b5 19			call macro_dsp_valuehl 
3afb				endm 
# End of macro FORTH_DSP_VALUEHL
3afb			 
3afb			;		push hl 
3afb			 
3afb					; destroy value TOS 
3afb			 
3afb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3afb cd 51 1a			call macro_forth_dsp_pop 
3afe				endm 
# End of macro FORTH_DSP_POP
3afe			 
3afe			;		pop hl 
3afe			 
3afe 7d					ld a,l 
3aff 32 3c eb				ld (cli_autodisplay), a 
3b02				       NEXTW 
3b02 c3 0b 1b			jp macro_next 
3b05				endm 
# End of macro NEXTW
3b05			 
3b05			.MENU: 
3b05				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3b05 70				db WORD_SYS_CORE+92             
3b06 ae 3b			dw .ENDDISPLAY            
3b08 05				db 4 + 1 
3b09 .. 00			db "MENU",0              
3b0e				endm 
# End of macro CWHEAD
3b0e			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3b0e			 
3b0e			;		; get number of items on the stack 
3b0e			; 
3b0e				 
3b0e					FORTH_DSP_VALUEHL 
3b0e cd b5 19			call macro_dsp_valuehl 
3b11				endm 
# End of macro FORTH_DSP_VALUEHL
3b11				 
3b11					if DEBUG_FORTH_WORDS_KEY 
3b11						DMARK "MNU" 
3b11 f5				push af  
3b12 3a 26 3b			ld a, (.dmark)  
3b15 32 7a ee			ld (debug_mark),a  
3b18 3a 27 3b			ld a, (.dmark+1)  
3b1b 32 7b ee			ld (debug_mark+1),a  
3b1e 3a 28 3b			ld a, (.dmark+2)  
3b21 32 7c ee			ld (debug_mark+2),a  
3b24 18 03			jr .pastdmark  
3b26 ..			.dmark: db "MNU"  
3b29 f1			.pastdmark: pop af  
3b2a			endm  
# End of macro DMARK
3b2a						CALLMONITOR 
3b2a cd 80 13			call break_point_state  
3b2d				endm  
# End of macro CALLMONITOR
3b2d					endif 
3b2d			 
3b2d 45					ld b, l	 
3b2e 05					dec b 
3b2f			 
3b2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b2f cd 51 1a			call macro_forth_dsp_pop 
3b32				endm 
# End of macro FORTH_DSP_POP
3b32			 
3b32			 
3b32					; go directly through the stack to pluck out the string pointers and build an array 
3b32			 
3b32			;		FORTH_DSP 
3b32			 
3b32					; hl contains top most stack item 
3b32				 
3b32 11 75 e3				ld de, scratch 
3b35			 
3b35			.mbuild: 
3b35			 
3b35					FORTH_DSP_VALUEHL 
3b35 cd b5 19			call macro_dsp_valuehl 
3b38				endm 
# End of macro FORTH_DSP_VALUEHL
3b38			 
3b38					if DEBUG_FORTH_WORDS 
3b38						DMARK "MN3" 
3b38 f5				push af  
3b39 3a 4d 3b			ld a, (.dmark)  
3b3c 32 7a ee			ld (debug_mark),a  
3b3f 3a 4e 3b			ld a, (.dmark+1)  
3b42 32 7b ee			ld (debug_mark+1),a  
3b45 3a 4f 3b			ld a, (.dmark+2)  
3b48 32 7c ee			ld (debug_mark+2),a  
3b4b 18 03			jr .pastdmark  
3b4d ..			.dmark: db "MN3"  
3b50 f1			.pastdmark: pop af  
3b51			endm  
# End of macro DMARK
3b51						CALLMONITOR 
3b51 cd 80 13			call break_point_state  
3b54				endm  
# End of macro CALLMONITOR
3b54					endif 
3b54 eb					ex de, hl 
3b55 73					ld (hl), e 
3b56 23					inc hl 
3b57 72					ld (hl), d 
3b58 23					inc hl 
3b59 eb					ex de, hl 
3b5a			 
3b5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b5a cd 51 1a			call macro_forth_dsp_pop 
3b5d				endm 
# End of macro FORTH_DSP_POP
3b5d			 
3b5d 10 d6				djnz .mbuild 
3b5f			 
3b5f					; done add term 
3b5f			 
3b5f eb					ex de, hl 
3b60 36 00				ld (hl), 0 
3b62 23					inc hl 
3b63 36 00				ld (hl), 0 
3b65			 
3b65				 
3b65					 
3b65 21 75 e3				ld hl, scratch 
3b68			 
3b68					if DEBUG_FORTH_WORDS 
3b68						DMARK "MNx" 
3b68 f5				push af  
3b69 3a 7d 3b			ld a, (.dmark)  
3b6c 32 7a ee			ld (debug_mark),a  
3b6f 3a 7e 3b			ld a, (.dmark+1)  
3b72 32 7b ee			ld (debug_mark+1),a  
3b75 3a 7f 3b			ld a, (.dmark+2)  
3b78 32 7c ee			ld (debug_mark+2),a  
3b7b 18 03			jr .pastdmark  
3b7d ..			.dmark: db "MNx"  
3b80 f1			.pastdmark: pop af  
3b81			endm  
# End of macro DMARK
3b81						CALLMONITOR 
3b81 cd 80 13			call break_point_state  
3b84				endm  
# End of macro CALLMONITOR
3b84					endif 
3b84			 
3b84			 
3b84			 
3b84 3e 00				ld a, 0 
3b86 cd 70 09				call menu 
3b89			 
3b89			 
3b89 6f					ld l, a 
3b8a 26 00				ld h, 0 
3b8c			 
3b8c					if DEBUG_FORTH_WORDS 
3b8c						DMARK "MNr" 
3b8c f5				push af  
3b8d 3a a1 3b			ld a, (.dmark)  
3b90 32 7a ee			ld (debug_mark),a  
3b93 3a a2 3b			ld a, (.dmark+1)  
3b96 32 7b ee			ld (debug_mark+1),a  
3b99 3a a3 3b			ld a, (.dmark+2)  
3b9c 32 7c ee			ld (debug_mark+2),a  
3b9f 18 03			jr .pastdmark  
3ba1 ..			.dmark: db "MNr"  
3ba4 f1			.pastdmark: pop af  
3ba5			endm  
# End of macro DMARK
3ba5						CALLMONITOR 
3ba5 cd 80 13			call break_point_state  
3ba8				endm  
# End of macro CALLMONITOR
3ba8					endif 
3ba8			 
3ba8 cd 1a 19				call forth_push_numhl 
3bab			 
3bab			 
3bab			 
3bab			 
3bab				       NEXTW 
3bab c3 0b 1b			jp macro_next 
3bae				endm 
# End of macro NEXTW
3bae			 
3bae			 
3bae			.ENDDISPLAY: 
3bae			 
3bae			; eof 
# End of file forth_words_display.asm
3bae			include "forth_words_str.asm" 
3bae			 
3bae			; | ## String Words 
3bae			 
3bae			.PTR:   
3bae			 
3bae				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3bae 48				db WORD_SYS_CORE+52             
3baf db 3b			dw .STYPE            
3bb1 04				db 3 + 1 
3bb2 .. 00			db "PTR",0              
3bb6				endm 
# End of macro CWHEAD
3bb6			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3bb6			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3bb6			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3bb6			 
3bb6					if DEBUG_FORTH_WORDS_KEY 
3bb6						DMARK "PTR" 
3bb6 f5				push af  
3bb7 3a cb 3b			ld a, (.dmark)  
3bba 32 7a ee			ld (debug_mark),a  
3bbd 3a cc 3b			ld a, (.dmark+1)  
3bc0 32 7b ee			ld (debug_mark+1),a  
3bc3 3a cd 3b			ld a, (.dmark+2)  
3bc6 32 7c ee			ld (debug_mark+2),a  
3bc9 18 03			jr .pastdmark  
3bcb ..			.dmark: db "PTR"  
3bce f1			.pastdmark: pop af  
3bcf			endm  
# End of macro DMARK
3bcf						CALLMONITOR 
3bcf cd 80 13			call break_point_state  
3bd2				endm  
# End of macro CALLMONITOR
3bd2					endif 
3bd2					FORTH_DSP_VALUEHL 
3bd2 cd b5 19			call macro_dsp_valuehl 
3bd5				endm 
# End of macro FORTH_DSP_VALUEHL
3bd5 cd 1a 19				call forth_push_numhl 
3bd8			 
3bd8			 
3bd8					NEXTW 
3bd8 c3 0b 1b			jp macro_next 
3bdb				endm 
# End of macro NEXTW
3bdb			.STYPE: 
3bdb				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3bdb 48				db WORD_SYS_CORE+52             
3bdc 2a 3c			dw .UPPER            
3bde 06				db 5 + 1 
3bdf .. 00			db "STYPE",0              
3be5				endm 
# End of macro CWHEAD
3be5			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3be5					if DEBUG_FORTH_WORDS_KEY 
3be5						DMARK "STY" 
3be5 f5				push af  
3be6 3a fa 3b			ld a, (.dmark)  
3be9 32 7a ee			ld (debug_mark),a  
3bec 3a fb 3b			ld a, (.dmark+1)  
3bef 32 7b ee			ld (debug_mark+1),a  
3bf2 3a fc 3b			ld a, (.dmark+2)  
3bf5 32 7c ee			ld (debug_mark+2),a  
3bf8 18 03			jr .pastdmark  
3bfa ..			.dmark: db "STY"  
3bfd f1			.pastdmark: pop af  
3bfe			endm  
# End of macro DMARK
3bfe						CALLMONITOR 
3bfe cd 80 13			call break_point_state  
3c01				endm  
# End of macro CALLMONITOR
3c01					endif 
3c01					FORTH_DSP 
3c01 cd 9a 19			call macro_forth_dsp 
3c04				endm 
# End of macro FORTH_DSP
3c04					;v5 FORTH_DSP_VALUE 
3c04			 
3c04 7e					ld a, (hl) 
3c05			 
3c05 f5					push af 
3c06			 
3c06			; Dont destroy TOS		FORTH_DSP_POP 
3c06			 
3c06 f1					pop af 
3c07			 
3c07 fe 01				cp DS_TYPE_STR 
3c09 28 09				jr z, .typestr 
3c0b			 
3c0b fe 02				cp DS_TYPE_INUM 
3c0d 28 0a				jr z, .typeinum 
3c0f			 
3c0f 21 28 3c				ld hl, .tna 
3c12 18 0a				jr .tpush 
3c14			 
3c14 21 24 3c		.typestr:	ld hl, .tstr 
3c17 18 05				jr .tpush 
3c19 21 26 3c		.typeinum:	ld hl, .tinum 
3c1c 18 00				jr .tpush 
3c1e			 
3c1e			.tpush: 
3c1e			 
3c1e cd 2c 19				call forth_push_str 
3c21			 
3c21					NEXTW 
3c21 c3 0b 1b			jp macro_next 
3c24				endm 
# End of macro NEXTW
3c24 .. 00		.tstr:	db "s",0 
3c26 .. 00		.tinum:  db "i",0 
3c28 .. 00		.tna:   db "?", 0 
3c2a			 
3c2a			 
3c2a			.UPPER: 
3c2a				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3c2a 48				db WORD_SYS_CORE+52             
3c2b 65 3c			dw .LOWER            
3c2d 06				db 5 + 1 
3c2e .. 00			db "UPPER",0              
3c34				endm 
# End of macro CWHEAD
3c34			; | UPPER ( s -- s ) Upper case string s  | DONE 
3c34					if DEBUG_FORTH_WORDS_KEY 
3c34						DMARK "UPR" 
3c34 f5				push af  
3c35 3a 49 3c			ld a, (.dmark)  
3c38 32 7a ee			ld (debug_mark),a  
3c3b 3a 4a 3c			ld a, (.dmark+1)  
3c3e 32 7b ee			ld (debug_mark+1),a  
3c41 3a 4b 3c			ld a, (.dmark+2)  
3c44 32 7c ee			ld (debug_mark+2),a  
3c47 18 03			jr .pastdmark  
3c49 ..			.dmark: db "UPR"  
3c4c f1			.pastdmark: pop af  
3c4d			endm  
# End of macro DMARK
3c4d						CALLMONITOR 
3c4d cd 80 13			call break_point_state  
3c50				endm  
# End of macro CALLMONITOR
3c50					endif 
3c50			 
3c50					FORTH_DSP 
3c50 cd 9a 19			call macro_forth_dsp 
3c53				endm 
# End of macro FORTH_DSP
3c53					 
3c53			; TODO check is string type 
3c53			 
3c53					FORTH_DSP_VALUEHL 
3c53 cd b5 19			call macro_dsp_valuehl 
3c56				endm 
# End of macro FORTH_DSP_VALUEHL
3c56			; get pointer to string in hl 
3c56			 
3c56 7e			.toup:		ld a, (hl) 
3c57 fe 00				cp 0 
3c59 28 07				jr z, .toupdone 
3c5b			 
3c5b cd d5 0e				call to_upper 
3c5e			 
3c5e 77					ld (hl), a 
3c5f 23					inc hl 
3c60 18 f4				jr .toup 
3c62			 
3c62					 
3c62			 
3c62			 
3c62			; for each char convert to upper 
3c62					 
3c62			.toupdone: 
3c62			 
3c62			 
3c62					NEXTW 
3c62 c3 0b 1b			jp macro_next 
3c65				endm 
# End of macro NEXTW
3c65			.LOWER: 
3c65				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3c65 48				db WORD_SYS_CORE+52             
3c66 a0 3c			dw .TCASE            
3c68 06				db 5 + 1 
3c69 .. 00			db "LOWER",0              
3c6f				endm 
# End of macro CWHEAD
3c6f			; | LOWER ( s -- s ) Lower case string s  | DONE 
3c6f					if DEBUG_FORTH_WORDS_KEY 
3c6f						DMARK "LWR" 
3c6f f5				push af  
3c70 3a 84 3c			ld a, (.dmark)  
3c73 32 7a ee			ld (debug_mark),a  
3c76 3a 85 3c			ld a, (.dmark+1)  
3c79 32 7b ee			ld (debug_mark+1),a  
3c7c 3a 86 3c			ld a, (.dmark+2)  
3c7f 32 7c ee			ld (debug_mark+2),a  
3c82 18 03			jr .pastdmark  
3c84 ..			.dmark: db "LWR"  
3c87 f1			.pastdmark: pop af  
3c88			endm  
# End of macro DMARK
3c88						CALLMONITOR 
3c88 cd 80 13			call break_point_state  
3c8b				endm  
# End of macro CALLMONITOR
3c8b					endif 
3c8b			 
3c8b					FORTH_DSP 
3c8b cd 9a 19			call macro_forth_dsp 
3c8e				endm 
# End of macro FORTH_DSP
3c8e					 
3c8e			; TODO check is string type 
3c8e			 
3c8e					FORTH_DSP_VALUEHL 
3c8e cd b5 19			call macro_dsp_valuehl 
3c91				endm 
# End of macro FORTH_DSP_VALUEHL
3c91			; get pointer to string in hl 
3c91			 
3c91 7e			.tolow:		ld a, (hl) 
3c92 fe 00				cp 0 
3c94 28 07				jr z, .tolowdone 
3c96			 
3c96 cd de 0e				call to_lower 
3c99			 
3c99 77					ld (hl), a 
3c9a 23					inc hl 
3c9b 18 f4				jr .tolow 
3c9d			 
3c9d					 
3c9d			 
3c9d			 
3c9d			; for each char convert to low 
3c9d					 
3c9d			.tolowdone: 
3c9d					NEXTW 
3c9d c3 0b 1b			jp macro_next 
3ca0				endm 
# End of macro NEXTW
3ca0			.TCASE: 
3ca0				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3ca0 48				db WORD_SYS_CORE+52             
3ca1 d6 3d			dw .SUBSTR            
3ca3 06				db 5 + 1 
3ca4 .. 00			db "TCASE",0              
3caa				endm 
# End of macro CWHEAD
3caa			; | TCASE ( s -- s ) Title case string s  | DONE 
3caa					if DEBUG_FORTH_WORDS_KEY 
3caa						DMARK "TCS" 
3caa f5				push af  
3cab 3a bf 3c			ld a, (.dmark)  
3cae 32 7a ee			ld (debug_mark),a  
3cb1 3a c0 3c			ld a, (.dmark+1)  
3cb4 32 7b ee			ld (debug_mark+1),a  
3cb7 3a c1 3c			ld a, (.dmark+2)  
3cba 32 7c ee			ld (debug_mark+2),a  
3cbd 18 03			jr .pastdmark  
3cbf ..			.dmark: db "TCS"  
3cc2 f1			.pastdmark: pop af  
3cc3			endm  
# End of macro DMARK
3cc3						CALLMONITOR 
3cc3 cd 80 13			call break_point_state  
3cc6				endm  
# End of macro CALLMONITOR
3cc6					endif 
3cc6			 
3cc6					FORTH_DSP 
3cc6 cd 9a 19			call macro_forth_dsp 
3cc9				endm 
# End of macro FORTH_DSP
3cc9					 
3cc9			; TODO check is string type 
3cc9			 
3cc9					FORTH_DSP_VALUEHL 
3cc9 cd b5 19			call macro_dsp_valuehl 
3ccc				endm 
# End of macro FORTH_DSP_VALUEHL
3ccc			; get pointer to string in hl 
3ccc			 
3ccc					if DEBUG_FORTH_WORDS 
3ccc						DMARK "TC1" 
3ccc f5				push af  
3ccd 3a e1 3c			ld a, (.dmark)  
3cd0 32 7a ee			ld (debug_mark),a  
3cd3 3a e2 3c			ld a, (.dmark+1)  
3cd6 32 7b ee			ld (debug_mark+1),a  
3cd9 3a e3 3c			ld a, (.dmark+2)  
3cdc 32 7c ee			ld (debug_mark+2),a  
3cdf 18 03			jr .pastdmark  
3ce1 ..			.dmark: db "TC1"  
3ce4 f1			.pastdmark: pop af  
3ce5			endm  
# End of macro DMARK
3ce5						CALLMONITOR 
3ce5 cd 80 13			call break_point_state  
3ce8				endm  
# End of macro CALLMONITOR
3ce8					endif 
3ce8			 
3ce8					; first time in turn to upper case first char 
3ce8			 
3ce8 7e					ld a, (hl) 
3ce9 c3 73 3d				jp .totsiptou 
3cec			 
3cec			 
3cec 7e			.tot:		ld a, (hl) 
3ced fe 00				cp 0 
3cef ca b7 3d				jp z, .totdone 
3cf2			 
3cf2					if DEBUG_FORTH_WORDS 
3cf2						DMARK "TC2" 
3cf2 f5				push af  
3cf3 3a 07 3d			ld a, (.dmark)  
3cf6 32 7a ee			ld (debug_mark),a  
3cf9 3a 08 3d			ld a, (.dmark+1)  
3cfc 32 7b ee			ld (debug_mark+1),a  
3cff 3a 09 3d			ld a, (.dmark+2)  
3d02 32 7c ee			ld (debug_mark+2),a  
3d05 18 03			jr .pastdmark  
3d07 ..			.dmark: db "TC2"  
3d0a f1			.pastdmark: pop af  
3d0b			endm  
# End of macro DMARK
3d0b						CALLMONITOR 
3d0b cd 80 13			call break_point_state  
3d0e				endm  
# End of macro CALLMONITOR
3d0e					endif 
3d0e					; check to see if current char is a space 
3d0e			 
3d0e fe 20				cp ' ' 
3d10 28 21				jr z, .totsp 
3d12 cd de 0e				call to_lower 
3d15					if DEBUG_FORTH_WORDS 
3d15						DMARK "TC3" 
3d15 f5				push af  
3d16 3a 2a 3d			ld a, (.dmark)  
3d19 32 7a ee			ld (debug_mark),a  
3d1c 3a 2b 3d			ld a, (.dmark+1)  
3d1f 32 7b ee			ld (debug_mark+1),a  
3d22 3a 2c 3d			ld a, (.dmark+2)  
3d25 32 7c ee			ld (debug_mark+2),a  
3d28 18 03			jr .pastdmark  
3d2a ..			.dmark: db "TC3"  
3d2d f1			.pastdmark: pop af  
3d2e			endm  
# End of macro DMARK
3d2e						CALLMONITOR 
3d2e cd 80 13			call break_point_state  
3d31				endm  
# End of macro CALLMONITOR
3d31					endif 
3d31 18 63				jr .totnxt 
3d33			 
3d33			.totsp:         ; on a space, find next char which should be upper 
3d33			 
3d33					if DEBUG_FORTH_WORDS 
3d33						DMARK "TC4" 
3d33 f5				push af  
3d34 3a 48 3d			ld a, (.dmark)  
3d37 32 7a ee			ld (debug_mark),a  
3d3a 3a 49 3d			ld a, (.dmark+1)  
3d3d 32 7b ee			ld (debug_mark+1),a  
3d40 3a 4a 3d			ld a, (.dmark+2)  
3d43 32 7c ee			ld (debug_mark+2),a  
3d46 18 03			jr .pastdmark  
3d48 ..			.dmark: db "TC4"  
3d4b f1			.pastdmark: pop af  
3d4c			endm  
# End of macro DMARK
3d4c						CALLMONITOR 
3d4c cd 80 13			call break_point_state  
3d4f				endm  
# End of macro CALLMONITOR
3d4f					endif 
3d4f					;; 
3d4f			 
3d4f fe 20				cp ' ' 
3d51 20 20				jr nz, .totsiptou 
3d53 23					inc hl 
3d54 7e					ld a, (hl) 
3d55					if DEBUG_FORTH_WORDS 
3d55						DMARK "TC5" 
3d55 f5				push af  
3d56 3a 6a 3d			ld a, (.dmark)  
3d59 32 7a ee			ld (debug_mark),a  
3d5c 3a 6b 3d			ld a, (.dmark+1)  
3d5f 32 7b ee			ld (debug_mark+1),a  
3d62 3a 6c 3d			ld a, (.dmark+2)  
3d65 32 7c ee			ld (debug_mark+2),a  
3d68 18 03			jr .pastdmark  
3d6a ..			.dmark: db "TC5"  
3d6d f1			.pastdmark: pop af  
3d6e			endm  
# End of macro DMARK
3d6e						CALLMONITOR 
3d6e cd 80 13			call break_point_state  
3d71				endm  
# End of macro CALLMONITOR
3d71					endif 
3d71 18 c0				jr .totsp 
3d73 fe 00		.totsiptou:    cp 0 
3d75 28 40				jr z, .totdone 
3d77					; not space and not zero term so upper case it 
3d77 cd d5 0e				call to_upper 
3d7a			 
3d7a					if DEBUG_FORTH_WORDS 
3d7a						DMARK "TC6" 
3d7a f5				push af  
3d7b 3a 8f 3d			ld a, (.dmark)  
3d7e 32 7a ee			ld (debug_mark),a  
3d81 3a 90 3d			ld a, (.dmark+1)  
3d84 32 7b ee			ld (debug_mark+1),a  
3d87 3a 91 3d			ld a, (.dmark+2)  
3d8a 32 7c ee			ld (debug_mark+2),a  
3d8d 18 03			jr .pastdmark  
3d8f ..			.dmark: db "TC6"  
3d92 f1			.pastdmark: pop af  
3d93			endm  
# End of macro DMARK
3d93						CALLMONITOR 
3d93 cd 80 13			call break_point_state  
3d96				endm  
# End of macro CALLMONITOR
3d96					endif 
3d96			 
3d96			 
3d96			.totnxt: 
3d96			 
3d96 77					ld (hl), a 
3d97 23					inc hl 
3d98					if DEBUG_FORTH_WORDS 
3d98						DMARK "TC7" 
3d98 f5				push af  
3d99 3a ad 3d			ld a, (.dmark)  
3d9c 32 7a ee			ld (debug_mark),a  
3d9f 3a ae 3d			ld a, (.dmark+1)  
3da2 32 7b ee			ld (debug_mark+1),a  
3da5 3a af 3d			ld a, (.dmark+2)  
3da8 32 7c ee			ld (debug_mark+2),a  
3dab 18 03			jr .pastdmark  
3dad ..			.dmark: db "TC7"  
3db0 f1			.pastdmark: pop af  
3db1			endm  
# End of macro DMARK
3db1						CALLMONITOR 
3db1 cd 80 13			call break_point_state  
3db4				endm  
# End of macro CALLMONITOR
3db4					endif 
3db4 c3 ec 3c				jp .tot 
3db7			 
3db7					 
3db7			 
3db7			 
3db7			; for each char convert to low 
3db7					 
3db7			.totdone: 
3db7					if DEBUG_FORTH_WORDS 
3db7						DMARK "TCd" 
3db7 f5				push af  
3db8 3a cc 3d			ld a, (.dmark)  
3dbb 32 7a ee			ld (debug_mark),a  
3dbe 3a cd 3d			ld a, (.dmark+1)  
3dc1 32 7b ee			ld (debug_mark+1),a  
3dc4 3a ce 3d			ld a, (.dmark+2)  
3dc7 32 7c ee			ld (debug_mark+2),a  
3dca 18 03			jr .pastdmark  
3dcc ..			.dmark: db "TCd"  
3dcf f1			.pastdmark: pop af  
3dd0			endm  
# End of macro DMARK
3dd0						CALLMONITOR 
3dd0 cd 80 13			call break_point_state  
3dd3				endm  
# End of macro CALLMONITOR
3dd3					endif 
3dd3					NEXTW 
3dd3 c3 0b 1b			jp macro_next 
3dd6				endm 
# End of macro NEXTW
3dd6			 
3dd6			.SUBSTR: 
3dd6				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3dd6 48				db WORD_SYS_CORE+52             
3dd7 34 3e			dw .LEFT            
3dd9 07				db 6 + 1 
3dda .. 00			db "SUBSTR",0              
3de1				endm 
# End of macro CWHEAD
3de1			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3de1			 
3de1					if DEBUG_FORTH_WORDS_KEY 
3de1						DMARK "SST" 
3de1 f5				push af  
3de2 3a f6 3d			ld a, (.dmark)  
3de5 32 7a ee			ld (debug_mark),a  
3de8 3a f7 3d			ld a, (.dmark+1)  
3deb 32 7b ee			ld (debug_mark+1),a  
3dee 3a f8 3d			ld a, (.dmark+2)  
3df1 32 7c ee			ld (debug_mark+2),a  
3df4 18 03			jr .pastdmark  
3df6 ..			.dmark: db "SST"  
3df9 f1			.pastdmark: pop af  
3dfa			endm  
# End of macro DMARK
3dfa						CALLMONITOR 
3dfa cd 80 13			call break_point_state  
3dfd				endm  
# End of macro CALLMONITOR
3dfd					endif 
3dfd			; TODO check string type 
3dfd					FORTH_DSP_VALUEHL 
3dfd cd b5 19			call macro_dsp_valuehl 
3e00				endm 
# End of macro FORTH_DSP_VALUEHL
3e00			 
3e00 e5					push hl      ; string length 
3e01			 
3e01					FORTH_DSP_POP 
3e01 cd 51 1a			call macro_forth_dsp_pop 
3e04				endm 
# End of macro FORTH_DSP_POP
3e04			 
3e04					FORTH_DSP_VALUEHL 
3e04 cd b5 19			call macro_dsp_valuehl 
3e07				endm 
# End of macro FORTH_DSP_VALUEHL
3e07			 
3e07 e5					push hl     ; start char 
3e08			 
3e08					FORTH_DSP_POP 
3e08 cd 51 1a			call macro_forth_dsp_pop 
3e0b				endm 
# End of macro FORTH_DSP_POP
3e0b			 
3e0b			 
3e0b					FORTH_DSP_VALUE 
3e0b cd 9e 19			call macro_forth_dsp_value 
3e0e				endm 
# End of macro FORTH_DSP_VALUE
3e0e			 
3e0e d1					pop de    ; get start post offset 
3e0f			 
3e0f 19					add hl, de    ; starting offset 
3e10			 
3e10 c1					pop bc 
3e11 c5					push bc      ; grab size of string 
3e12			 
3e12 e5					push hl    ; save string start  
3e13			 
3e13 26 00				ld h, 0 
3e15 69					ld l, c 
3e16 23					inc hl 
3e17 23					inc hl 
3e18			 
3e18 cd 2f 10				call malloc 
3e1b				if DEBUG_FORTH_MALLOC_GUARD 
3e1b cc 4a 44				call z,malloc_error 
3e1e				endif 
3e1e			 
3e1e eb					ex de, hl      ; save malloc area for string copy 
3e1f e1					pop hl    ; get back source 
3e20 c1					pop bc    ; get length of string back 
3e21			 
3e21 d5					push de    ; save malloc area for after we push 
3e22 ed b0				ldir     ; copy substr 
3e24			 
3e24			 
3e24 eb					ex de, hl 
3e25 3e 00				ld a, 0 
3e27 77					ld (hl), a   ; term substr 
3e28			 
3e28					 
3e28 e1					pop hl    ; get malloc so we can push it 
3e29 e5					push hl   ; save so we can free it afterwards 
3e2a			 
3e2a cd 2c 19				call forth_push_str 
3e2d			 
3e2d e1					pop hl 
3e2e cd f9 10				call free 
3e31			 
3e31					 
3e31					 
3e31			 
3e31			 
3e31					NEXTW 
3e31 c3 0b 1b			jp macro_next 
3e34				endm 
# End of macro NEXTW
3e34			 
3e34			.LEFT: 
3e34				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3e34 48				db WORD_SYS_CORE+52             
3e35 5c 3e			dw .RIGHT            
3e37 05				db 4 + 1 
3e38 .. 00			db "LEFT",0              
3e3d				endm 
# End of macro CWHEAD
3e3d			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3e3d					if DEBUG_FORTH_WORDS_KEY 
3e3d						DMARK "LEF" 
3e3d f5				push af  
3e3e 3a 52 3e			ld a, (.dmark)  
3e41 32 7a ee			ld (debug_mark),a  
3e44 3a 53 3e			ld a, (.dmark+1)  
3e47 32 7b ee			ld (debug_mark+1),a  
3e4a 3a 54 3e			ld a, (.dmark+2)  
3e4d 32 7c ee			ld (debug_mark+2),a  
3e50 18 03			jr .pastdmark  
3e52 ..			.dmark: db "LEF"  
3e55 f1			.pastdmark: pop af  
3e56			endm  
# End of macro DMARK
3e56						CALLMONITOR 
3e56 cd 80 13			call break_point_state  
3e59				endm  
# End of macro CALLMONITOR
3e59					endif 
3e59			 
3e59					NEXTW 
3e59 c3 0b 1b			jp macro_next 
3e5c				endm 
# End of macro NEXTW
3e5c			.RIGHT: 
3e5c				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3e5c 48				db WORD_SYS_CORE+52             
3e5d 85 3e			dw .STR2NUM            
3e5f 06				db 5 + 1 
3e60 .. 00			db "RIGHT",0              
3e66				endm 
# End of macro CWHEAD
3e66			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3e66					if DEBUG_FORTH_WORDS_KEY 
3e66						DMARK "RIG" 
3e66 f5				push af  
3e67 3a 7b 3e			ld a, (.dmark)  
3e6a 32 7a ee			ld (debug_mark),a  
3e6d 3a 7c 3e			ld a, (.dmark+1)  
3e70 32 7b ee			ld (debug_mark+1),a  
3e73 3a 7d 3e			ld a, (.dmark+2)  
3e76 32 7c ee			ld (debug_mark+2),a  
3e79 18 03			jr .pastdmark  
3e7b ..			.dmark: db "RIG"  
3e7e f1			.pastdmark: pop af  
3e7f			endm  
# End of macro DMARK
3e7f						CALLMONITOR 
3e7f cd 80 13			call break_point_state  
3e82				endm  
# End of macro CALLMONITOR
3e82					endif 
3e82			 
3e82					NEXTW 
3e82 c3 0b 1b			jp macro_next 
3e85				endm 
# End of macro NEXTW
3e85			 
3e85			 
3e85			.STR2NUM: 
3e85				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3e85 48				db WORD_SYS_CORE+52             
3e86 11 3f			dw .NUM2STR            
3e88 08				db 7 + 1 
3e89 .. 00			db "STR2NUM",0              
3e91				endm 
# End of macro CWHEAD
3e91			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3e91			 
3e91			 
3e91			; TODO STR type check to do 
3e91					if DEBUG_FORTH_WORDS_KEY 
3e91						DMARK "S2N" 
3e91 f5				push af  
3e92 3a a6 3e			ld a, (.dmark)  
3e95 32 7a ee			ld (debug_mark),a  
3e98 3a a7 3e			ld a, (.dmark+1)  
3e9b 32 7b ee			ld (debug_mark+1),a  
3e9e 3a a8 3e			ld a, (.dmark+2)  
3ea1 32 7c ee			ld (debug_mark+2),a  
3ea4 18 03			jr .pastdmark  
3ea6 ..			.dmark: db "S2N"  
3ea9 f1			.pastdmark: pop af  
3eaa			endm  
# End of macro DMARK
3eaa						CALLMONITOR 
3eaa cd 80 13			call break_point_state  
3ead				endm  
# End of macro CALLMONITOR
3ead					endif 
3ead			 
3ead					;FORTH_DSP 
3ead					FORTH_DSP_VALUE 
3ead cd 9e 19			call macro_forth_dsp_value 
3eb0				endm 
# End of macro FORTH_DSP_VALUE
3eb0					;inc hl 
3eb0			 
3eb0 eb					ex de, hl 
3eb1					if DEBUG_FORTH_WORDS 
3eb1						DMARK "S2a" 
3eb1 f5				push af  
3eb2 3a c6 3e			ld a, (.dmark)  
3eb5 32 7a ee			ld (debug_mark),a  
3eb8 3a c7 3e			ld a, (.dmark+1)  
3ebb 32 7b ee			ld (debug_mark+1),a  
3ebe 3a c8 3e			ld a, (.dmark+2)  
3ec1 32 7c ee			ld (debug_mark+2),a  
3ec4 18 03			jr .pastdmark  
3ec6 ..			.dmark: db "S2a"  
3ec9 f1			.pastdmark: pop af  
3eca			endm  
# End of macro DMARK
3eca						CALLMONITOR 
3eca cd 80 13			call break_point_state  
3ecd				endm  
# End of macro CALLMONITOR
3ecd					endif 
3ecd cd 5d 0f				call string_to_uint16 
3ed0			 
3ed0					if DEBUG_FORTH_WORDS 
3ed0						DMARK "S2b" 
3ed0 f5				push af  
3ed1 3a e5 3e			ld a, (.dmark)  
3ed4 32 7a ee			ld (debug_mark),a  
3ed7 3a e6 3e			ld a, (.dmark+1)  
3eda 32 7b ee			ld (debug_mark+1),a  
3edd 3a e7 3e			ld a, (.dmark+2)  
3ee0 32 7c ee			ld (debug_mark+2),a  
3ee3 18 03			jr .pastdmark  
3ee5 ..			.dmark: db "S2b"  
3ee8 f1			.pastdmark: pop af  
3ee9			endm  
# End of macro DMARK
3ee9						CALLMONITOR 
3ee9 cd 80 13			call break_point_state  
3eec				endm  
# End of macro CALLMONITOR
3eec					endif 
3eec			;		push hl 
3eec					FORTH_DSP_POP 
3eec cd 51 1a			call macro_forth_dsp_pop 
3eef				endm 
# End of macro FORTH_DSP_POP
3eef			;		pop hl 
3eef					 
3eef					if DEBUG_FORTH_WORDS 
3eef						DMARK "S2b" 
3eef f5				push af  
3ef0 3a 04 3f			ld a, (.dmark)  
3ef3 32 7a ee			ld (debug_mark),a  
3ef6 3a 05 3f			ld a, (.dmark+1)  
3ef9 32 7b ee			ld (debug_mark+1),a  
3efc 3a 06 3f			ld a, (.dmark+2)  
3eff 32 7c ee			ld (debug_mark+2),a  
3f02 18 03			jr .pastdmark  
3f04 ..			.dmark: db "S2b"  
3f07 f1			.pastdmark: pop af  
3f08			endm  
# End of macro DMARK
3f08						CALLMONITOR 
3f08 cd 80 13			call break_point_state  
3f0b				endm  
# End of macro CALLMONITOR
3f0b					endif 
3f0b cd 1a 19				call forth_push_numhl	 
3f0e			 
3f0e				 
3f0e				       NEXTW 
3f0e c3 0b 1b			jp macro_next 
3f11				endm 
# End of macro NEXTW
3f11			.NUM2STR: 
3f11				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3f11 48				db WORD_SYS_CORE+52             
3f12 20 3f			dw .CONCAT            
3f14 08				db 7 + 1 
3f15 .. 00			db "NUM2STR",0              
3f1d				endm 
# End of macro CWHEAD
3f1d			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3f1d			 
3f1d			;		; malloc a string to target 
3f1d			;		ld hl, 10     ; TODO max string size should be fine 
3f1d			;		call malloc 
3f1d			;		push hl    ; save malloc location 
3f1d			; 
3f1d			; 
3f1d			;; TODO check int type 
3f1d			;		FORTH_DSP_VALUEHL 
3f1d			;		ld a, l 
3f1d			;		call DispAToASCII   
3f1d			;;TODO need to chage above call to dump into string 
3f1d			; 
3f1d			; 
3f1d			 
3f1d				       NEXTW 
3f1d c3 0b 1b			jp macro_next 
3f20				endm 
# End of macro NEXTW
3f20			 
3f20			.CONCAT: 
3f20				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3f20 48				db WORD_SYS_CORE+52             
3f21 d3 3f			dw .FIND            
3f23 07				db 6 + 1 
3f24 .. 00			db "CONCAT",0              
3f2b				endm 
# End of macro CWHEAD
3f2b			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3f2b			 
3f2b			; TODO check string type 
3f2b			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3f2b			 
3f2b					if DEBUG_FORTH_WORDS_KEY 
3f2b						DMARK "CON" 
3f2b f5				push af  
3f2c 3a 40 3f			ld a, (.dmark)  
3f2f 32 7a ee			ld (debug_mark),a  
3f32 3a 41 3f			ld a, (.dmark+1)  
3f35 32 7b ee			ld (debug_mark+1),a  
3f38 3a 42 3f			ld a, (.dmark+2)  
3f3b 32 7c ee			ld (debug_mark+2),a  
3f3e 18 03			jr .pastdmark  
3f40 ..			.dmark: db "CON"  
3f43 f1			.pastdmark: pop af  
3f44			endm  
# End of macro DMARK
3f44						CALLMONITOR 
3f44 cd 80 13			call break_point_state  
3f47				endm  
# End of macro CALLMONITOR
3f47					endif 
3f47			 
3f47			 
3f47					FORTH_DSP_VALUE 
3f47 cd 9e 19			call macro_forth_dsp_value 
3f4a				endm 
# End of macro FORTH_DSP_VALUE
3f4a e5					push hl   ; s2 
3f4b			 
3f4b					FORTH_DSP_POP 
3f4b cd 51 1a			call macro_forth_dsp_pop 
3f4e				endm 
# End of macro FORTH_DSP_POP
3f4e			 
3f4e					FORTH_DSP_VALUE 
3f4e cd 9e 19			call macro_forth_dsp_value 
3f51				endm 
# End of macro FORTH_DSP_VALUE
3f51			 
3f51 e5					push hl   ; s1 
3f52			 
3f52					FORTH_DSP_POP 
3f52 cd 51 1a			call macro_forth_dsp_pop 
3f55				endm 
# End of macro FORTH_DSP_POP
3f55					 
3f55			 
3f55					; copy s1 
3f55			 
3f55				 
3f55					; save ptr 
3f55 e1					pop hl  
3f56 e5					push hl 
3f57 3e 00				ld a, 0 
3f59 cd d1 0f				call strlent 
3f5c					;inc hl    ; zer0 
3f5c 06 00				ld b, 0 
3f5e 4d					ld c, l 
3f5f e1					pop hl		 
3f60 11 75 e3				ld de, scratch	 
3f63					if DEBUG_FORTH_WORDS 
3f63						DMARK "CO1" 
3f63 f5				push af  
3f64 3a 78 3f			ld a, (.dmark)  
3f67 32 7a ee			ld (debug_mark),a  
3f6a 3a 79 3f			ld a, (.dmark+1)  
3f6d 32 7b ee			ld (debug_mark+1),a  
3f70 3a 7a 3f			ld a, (.dmark+2)  
3f73 32 7c ee			ld (debug_mark+2),a  
3f76 18 03			jr .pastdmark  
3f78 ..			.dmark: db "CO1"  
3f7b f1			.pastdmark: pop af  
3f7c			endm  
# End of macro DMARK
3f7c						CALLMONITOR 
3f7c cd 80 13			call break_point_state  
3f7f				endm  
# End of macro CALLMONITOR
3f7f					endif 
3f7f ed b0				ldir 
3f81			 
3f81 e1					pop hl 
3f82 e5					push hl 
3f83 d5					push de 
3f84			 
3f84			 
3f84 3e 00				ld a, 0 
3f86 cd d1 0f				call strlent 
3f89 23					inc hl    ; zer0 
3f8a 23					inc hl 
3f8b 06 00				ld b, 0 
3f8d 4d					ld c, l 
3f8e d1					pop de 
3f8f e1					pop hl		 
3f90					if DEBUG_FORTH_WORDS 
3f90						DMARK "CO2" 
3f90 f5				push af  
3f91 3a a5 3f			ld a, (.dmark)  
3f94 32 7a ee			ld (debug_mark),a  
3f97 3a a6 3f			ld a, (.dmark+1)  
3f9a 32 7b ee			ld (debug_mark+1),a  
3f9d 3a a7 3f			ld a, (.dmark+2)  
3fa0 32 7c ee			ld (debug_mark+2),a  
3fa3 18 03			jr .pastdmark  
3fa5 ..			.dmark: db "CO2"  
3fa8 f1			.pastdmark: pop af  
3fa9			endm  
# End of macro DMARK
3fa9						CALLMONITOR 
3fa9 cd 80 13			call break_point_state  
3fac				endm  
# End of macro CALLMONITOR
3fac					endif 
3fac ed b0				ldir 
3fae			 
3fae			 
3fae			 
3fae 21 75 e3				ld hl, scratch 
3fb1					if DEBUG_FORTH_WORDS 
3fb1						DMARK "CO5" 
3fb1 f5				push af  
3fb2 3a c6 3f			ld a, (.dmark)  
3fb5 32 7a ee			ld (debug_mark),a  
3fb8 3a c7 3f			ld a, (.dmark+1)  
3fbb 32 7b ee			ld (debug_mark+1),a  
3fbe 3a c8 3f			ld a, (.dmark+2)  
3fc1 32 7c ee			ld (debug_mark+2),a  
3fc4 18 03			jr .pastdmark  
3fc6 ..			.dmark: db "CO5"  
3fc9 f1			.pastdmark: pop af  
3fca			endm  
# End of macro DMARK
3fca						CALLMONITOR 
3fca cd 80 13			call break_point_state  
3fcd				endm  
# End of macro CALLMONITOR
3fcd					endif 
3fcd			 
3fcd cd 2c 19				call forth_push_str 
3fd0			 
3fd0			 
3fd0			 
3fd0			 
3fd0				       NEXTW 
3fd0 c3 0b 1b			jp macro_next 
3fd3				endm 
# End of macro NEXTW
3fd3			 
3fd3			 
3fd3			.FIND: 
3fd3				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3fd3 4b				db WORD_SYS_CORE+55             
3fd4 91 40			dw .LEN            
3fd6 05				db 4 + 1 
3fd7 .. 00			db "FIND",0              
3fdc				endm 
# End of macro CWHEAD
3fdc			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
3fdc			 
3fdc					if DEBUG_FORTH_WORDS_KEY 
3fdc						DMARK "FND" 
3fdc f5				push af  
3fdd 3a f1 3f			ld a, (.dmark)  
3fe0 32 7a ee			ld (debug_mark),a  
3fe3 3a f2 3f			ld a, (.dmark+1)  
3fe6 32 7b ee			ld (debug_mark+1),a  
3fe9 3a f3 3f			ld a, (.dmark+2)  
3fec 32 7c ee			ld (debug_mark+2),a  
3fef 18 03			jr .pastdmark  
3ff1 ..			.dmark: db "FND"  
3ff4 f1			.pastdmark: pop af  
3ff5			endm  
# End of macro DMARK
3ff5						CALLMONITOR 
3ff5 cd 80 13			call break_point_state  
3ff8				endm  
# End of macro CALLMONITOR
3ff8					endif 
3ff8			 
3ff8			; TODO check string type 
3ff8					FORTH_DSP_VALUE 
3ff8 cd 9e 19			call macro_forth_dsp_value 
3ffb				endm 
# End of macro FORTH_DSP_VALUE
3ffb			 
3ffb e5					push hl    
3ffc 7e					ld a,(hl)    ; char to find   
3ffd			; TODO change char to substr 
3ffd			 
3ffd f5					push af 
3ffe					 
3ffe			 
3ffe			 
3ffe					if DEBUG_FORTH_WORDS 
3ffe						DMARK "FN1" 
3ffe f5				push af  
3fff 3a 13 40			ld a, (.dmark)  
4002 32 7a ee			ld (debug_mark),a  
4005 3a 14 40			ld a, (.dmark+1)  
4008 32 7b ee			ld (debug_mark+1),a  
400b 3a 15 40			ld a, (.dmark+2)  
400e 32 7c ee			ld (debug_mark+2),a  
4011 18 03			jr .pastdmark  
4013 ..			.dmark: db "FN1"  
4016 f1			.pastdmark: pop af  
4017			endm  
# End of macro DMARK
4017						CALLMONITOR 
4017 cd 80 13			call break_point_state  
401a				endm  
# End of macro CALLMONITOR
401a					endif 
401a			 
401a					FORTH_DSP_POP 
401a cd 51 1a			call macro_forth_dsp_pop 
401d				endm 
# End of macro FORTH_DSP_POP
401d			 
401d					; string to search 
401d			 
401d					FORTH_DSP_VALUE 
401d cd 9e 19			call macro_forth_dsp_value 
4020				endm 
# End of macro FORTH_DSP_VALUE
4020			 
4020 d1					pop de  ; d is char to find  
4021			 
4021					if DEBUG_FORTH_WORDS 
4021						DMARK "FN2" 
4021 f5				push af  
4022 3a 36 40			ld a, (.dmark)  
4025 32 7a ee			ld (debug_mark),a  
4028 3a 37 40			ld a, (.dmark+1)  
402b 32 7b ee			ld (debug_mark+1),a  
402e 3a 38 40			ld a, (.dmark+2)  
4031 32 7c ee			ld (debug_mark+2),a  
4034 18 03			jr .pastdmark  
4036 ..			.dmark: db "FN2"  
4039 f1			.pastdmark: pop af  
403a			endm  
# End of macro DMARK
403a						CALLMONITOR 
403a cd 80 13			call break_point_state  
403d				endm  
# End of macro CALLMONITOR
403d					endif 
403d					 
403d 01 00 00				ld bc, 0 
4040 7e			.findchar:      ld a,(hl) 
4041 fe 00				cp 0   		 
4043 28 27				jr z, .finddone     
4045 ba					cp d 
4046 28 20				jr z, .foundchar 
4048 03					inc bc 
4049 23					inc hl 
404a					if DEBUG_FORTH_WORDS 
404a						DMARK "FN3" 
404a f5				push af  
404b 3a 5f 40			ld a, (.dmark)  
404e 32 7a ee			ld (debug_mark),a  
4051 3a 60 40			ld a, (.dmark+1)  
4054 32 7b ee			ld (debug_mark+1),a  
4057 3a 61 40			ld a, (.dmark+2)  
405a 32 7c ee			ld (debug_mark+2),a  
405d 18 03			jr .pastdmark  
405f ..			.dmark: db "FN3"  
4062 f1			.pastdmark: pop af  
4063			endm  
# End of macro DMARK
4063						CALLMONITOR 
4063 cd 80 13			call break_point_state  
4066				endm  
# End of macro CALLMONITOR
4066					endif 
4066 18 d8				jr .findchar 
4068			 
4068			 
4068 c5			.foundchar:	push bc 
4069 e1					pop hl 
406a 18 03				jr .findexit 
406c			 
406c			 
406c							 
406c			 
406c			.finddone:     ; got to end of string with no find 
406c 21 00 00				ld hl, 0 
406f			.findexit: 
406f			 
406f					if DEBUG_FORTH_WORDS 
406f						DMARK "FNd" 
406f f5				push af  
4070 3a 84 40			ld a, (.dmark)  
4073 32 7a ee			ld (debug_mark),a  
4076 3a 85 40			ld a, (.dmark+1)  
4079 32 7b ee			ld (debug_mark+1),a  
407c 3a 86 40			ld a, (.dmark+2)  
407f 32 7c ee			ld (debug_mark+2),a  
4082 18 03			jr .pastdmark  
4084 ..			.dmark: db "FNd"  
4087 f1			.pastdmark: pop af  
4088			endm  
# End of macro DMARK
4088						CALLMONITOR 
4088 cd 80 13			call break_point_state  
408b				endm  
# End of macro CALLMONITOR
408b					endif 
408b cd 1a 19			call forth_push_numhl 
408e			 
408e				       NEXTW 
408e c3 0b 1b			jp macro_next 
4091				endm 
# End of macro NEXTW
4091			 
4091			.LEN: 
4091				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4091 4c				db WORD_SYS_CORE+56             
4092 c6 40			dw .CHAR            
4094 06				db 5 + 1 
4095 .. 00			db "COUNT",0              
409b				endm 
# End of macro CWHEAD
409b			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
409b			 
409b					if DEBUG_FORTH_WORDS_KEY 
409b						DMARK "CNT" 
409b f5				push af  
409c 3a b0 40			ld a, (.dmark)  
409f 32 7a ee			ld (debug_mark),a  
40a2 3a b1 40			ld a, (.dmark+1)  
40a5 32 7b ee			ld (debug_mark+1),a  
40a8 3a b2 40			ld a, (.dmark+2)  
40ab 32 7c ee			ld (debug_mark+2),a  
40ae 18 03			jr .pastdmark  
40b0 ..			.dmark: db "CNT"  
40b3 f1			.pastdmark: pop af  
40b4			endm  
# End of macro DMARK
40b4						CALLMONITOR 
40b4 cd 80 13			call break_point_state  
40b7				endm  
# End of macro CALLMONITOR
40b7					endif 
40b7			; TODO check string type 
40b7					FORTH_DSP 
40b7 cd 9a 19			call macro_forth_dsp 
40ba				endm 
# End of macro FORTH_DSP
40ba					;v5FORTH_DSP_VALUE 
40ba			 
40ba 23					inc hl 
40bb			 
40bb 3e 00				ld a, 0 
40bd cd d1 0f				call strlent 
40c0			 
40c0 cd 1a 19				call forth_push_numhl 
40c3			 
40c3			 
40c3			 
40c3				       NEXTW 
40c3 c3 0b 1b			jp macro_next 
40c6				endm 
# End of macro NEXTW
40c6			.CHAR: 
40c6				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
40c6 4d				db WORD_SYS_CORE+57             
40c7 fc 40			dw .ENDSTR            
40c9 05				db 4 + 1 
40ca .. 00			db "CHAR",0              
40cf				endm 
# End of macro CWHEAD
40cf			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
40cf					if DEBUG_FORTH_WORDS_KEY 
40cf						DMARK "CHR" 
40cf f5				push af  
40d0 3a e4 40			ld a, (.dmark)  
40d3 32 7a ee			ld (debug_mark),a  
40d6 3a e5 40			ld a, (.dmark+1)  
40d9 32 7b ee			ld (debug_mark+1),a  
40dc 3a e6 40			ld a, (.dmark+2)  
40df 32 7c ee			ld (debug_mark+2),a  
40e2 18 03			jr .pastdmark  
40e4 ..			.dmark: db "CHR"  
40e7 f1			.pastdmark: pop af  
40e8			endm  
# End of macro DMARK
40e8						CALLMONITOR 
40e8 cd 80 13			call break_point_state  
40eb				endm  
# End of macro CALLMONITOR
40eb					endif 
40eb					FORTH_DSP 
40eb cd 9a 19			call macro_forth_dsp 
40ee				endm 
# End of macro FORTH_DSP
40ee					;v5 FORTH_DSP_VALUE 
40ee 23					inc hl      ; now at start of numeric as string 
40ef			 
40ef			;		push hl 
40ef			 
40ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ef cd 51 1a			call macro_forth_dsp_pop 
40f2				endm 
# End of macro FORTH_DSP_POP
40f2			 
40f2			;		pop hl 
40f2			 
40f2					; push the content of a onto the stack as a value 
40f2			 
40f2 7e					ld a,(hl)   ; get char 
40f3 26 00				ld h,0 
40f5 6f					ld l,a 
40f6 cd 1a 19				call forth_push_numhl 
40f9			 
40f9				       NEXTW 
40f9 c3 0b 1b			jp macro_next 
40fc				endm 
# End of macro NEXTW
40fc			 
40fc			 
40fc			 
40fc			 
40fc			.ENDSTR: 
40fc			; eof 
40fc			 
# End of file forth_words_str.asm
40fc			include "forth_words_key.asm" 
40fc			 
40fc			; | ## Keyboard Words 
40fc			 
40fc			.KEY: 
40fc				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
40fc 3e				db WORD_SYS_CORE+42             
40fd 2c 41			dw .WAITK            
40ff 04				db 3 + 1 
4100 .. 00			db "KEY",0              
4104				endm 
# End of macro CWHEAD
4104			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4104			 
4104					if DEBUG_FORTH_WORDS_KEY 
4104						DMARK "KEY" 
4104 f5				push af  
4105 3a 19 41			ld a, (.dmark)  
4108 32 7a ee			ld (debug_mark),a  
410b 3a 1a 41			ld a, (.dmark+1)  
410e 32 7b ee			ld (debug_mark+1),a  
4111 3a 1b 41			ld a, (.dmark+2)  
4114 32 7c ee			ld (debug_mark+2),a  
4117 18 03			jr .pastdmark  
4119 ..			.dmark: db "KEY"  
411c f1			.pastdmark: pop af  
411d			endm  
# End of macro DMARK
411d						CALLMONITOR 
411d cd 80 13			call break_point_state  
4120				endm  
# End of macro CALLMONITOR
4120					endif 
4120			; TODO currently waits 
4120 cd d4 57				call cin 
4123					;call cin_wait 
4123 6f					ld l, a 
4124 26 00				ld h, 0 
4126 cd 1a 19				call forth_push_numhl 
4129					NEXTW 
4129 c3 0b 1b			jp macro_next 
412c				endm 
# End of macro NEXTW
412c			.WAITK: 
412c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
412c 3f				db WORD_SYS_CORE+43             
412d 5e 41			dw .ACCEPT            
412f 06				db 5 + 1 
4130 .. 00			db "WAITK",0              
4136				endm 
# End of macro CWHEAD
4136			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4136					if DEBUG_FORTH_WORDS_KEY 
4136						DMARK "WAI" 
4136 f5				push af  
4137 3a 4b 41			ld a, (.dmark)  
413a 32 7a ee			ld (debug_mark),a  
413d 3a 4c 41			ld a, (.dmark+1)  
4140 32 7b ee			ld (debug_mark+1),a  
4143 3a 4d 41			ld a, (.dmark+2)  
4146 32 7c ee			ld (debug_mark+2),a  
4149 18 03			jr .pastdmark  
414b ..			.dmark: db "WAI"  
414e f1			.pastdmark: pop af  
414f			endm  
# End of macro DMARK
414f						CALLMONITOR 
414f cd 80 13			call break_point_state  
4152				endm  
# End of macro CALLMONITOR
4152					endif 
4152 cd cc 57				call cin_wait 
4155 6f					ld l, a 
4156 26 00				ld h, 0 
4158 cd 1a 19				call forth_push_numhl 
415b					NEXTW 
415b c3 0b 1b			jp macro_next 
415e				endm 
# End of macro NEXTW
415e			.ACCEPT: 
415e				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
415e 40				db WORD_SYS_CORE+44             
415f bc 41			dw .EDIT            
4161 07				db 6 + 1 
4162 .. 00			db "ACCEPT",0              
4169				endm 
# End of macro CWHEAD
4169			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4169					; TODO crashes on push 
4169					if DEBUG_FORTH_WORDS_KEY 
4169						DMARK "ACC" 
4169 f5				push af  
416a 3a 7e 41			ld a, (.dmark)  
416d 32 7a ee			ld (debug_mark),a  
4170 3a 7f 41			ld a, (.dmark+1)  
4173 32 7b ee			ld (debug_mark+1),a  
4176 3a 80 41			ld a, (.dmark+2)  
4179 32 7c ee			ld (debug_mark+2),a  
417c 18 03			jr .pastdmark  
417e ..			.dmark: db "ACC"  
4181 f1			.pastdmark: pop af  
4182			endm  
# End of macro DMARK
4182						CALLMONITOR 
4182 cd 80 13			call break_point_state  
4185				endm  
# End of macro CALLMONITOR
4185					endif 
4185 21 73 e5				ld hl, os_input 
4188 3e 00				ld a, 0 
418a 77					ld (hl),a 
418b 3a 5e eb				ld a,(f_cursor_ptr) 
418e 16 64				ld d, 100 
4190 0e 00				ld c, 0 
4192 1e 28				ld e, 40 
4194 cd 95 0b				call input_str 
4197					; TODO perhaps do a type check and wrap in quotes if not a number 
4197 21 73 e5				ld hl, os_input 
419a					if DEBUG_FORTH_WORDS 
419a						DMARK "AC1" 
419a f5				push af  
419b 3a af 41			ld a, (.dmark)  
419e 32 7a ee			ld (debug_mark),a  
41a1 3a b0 41			ld a, (.dmark+1)  
41a4 32 7b ee			ld (debug_mark+1),a  
41a7 3a b1 41			ld a, (.dmark+2)  
41aa 32 7c ee			ld (debug_mark+2),a  
41ad 18 03			jr .pastdmark  
41af ..			.dmark: db "AC1"  
41b2 f1			.pastdmark: pop af  
41b3			endm  
# End of macro DMARK
41b3						CALLMONITOR 
41b3 cd 80 13			call break_point_state  
41b6				endm  
# End of macro CALLMONITOR
41b6					endif 
41b6 cd 2c 19				call forth_push_str 
41b9					NEXTW 
41b9 c3 0b 1b			jp macro_next 
41bc				endm 
# End of macro NEXTW
41bc			 
41bc			.EDIT: 
41bc				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
41bc 40				db WORD_SYS_CORE+44             
41bd 45 42			dw .ENDKEY            
41bf 05				db 4 + 1 
41c0 .. 00			db "EDIT",0              
41c5				endm 
# End of macro CWHEAD
41c5			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
41c5			 
41c5					; TODO does not copy from stack 
41c5					if DEBUG_FORTH_WORDS_KEY 
41c5						DMARK "EDT" 
41c5 f5				push af  
41c6 3a da 41			ld a, (.dmark)  
41c9 32 7a ee			ld (debug_mark),a  
41cc 3a db 41			ld a, (.dmark+1)  
41cf 32 7b ee			ld (debug_mark+1),a  
41d2 3a dc 41			ld a, (.dmark+2)  
41d5 32 7c ee			ld (debug_mark+2),a  
41d8 18 03			jr .pastdmark  
41da ..			.dmark: db "EDT"  
41dd f1			.pastdmark: pop af  
41de			endm  
# End of macro DMARK
41de						CALLMONITOR 
41de cd 80 13			call break_point_state  
41e1				endm  
# End of macro CALLMONITOR
41e1					endif 
41e1			 
41e1					FORTH_DSP 
41e1 cd 9a 19			call macro_forth_dsp 
41e4				endm 
# End of macro FORTH_DSP
41e4					;v5 FORTH_DSP_VALUE 
41e4 23					inc hl    ; TODO do type check 
41e5			 
41e5 e5					push hl 
41e6 3e 00				ld a, 0 
41e8 cd d1 0f				call strlent 
41eb 23					inc hl 
41ec			 
41ec 06 00				ld b, 0 
41ee 4d					ld c, l 
41ef			 
41ef e1					pop hl 
41f0 11 73 e5				ld de, os_input 
41f3					if DEBUG_FORTH_WORDS_KEY 
41f3						DMARK "EDc" 
41f3 f5				push af  
41f4 3a 08 42			ld a, (.dmark)  
41f7 32 7a ee			ld (debug_mark),a  
41fa 3a 09 42			ld a, (.dmark+1)  
41fd 32 7b ee			ld (debug_mark+1),a  
4200 3a 0a 42			ld a, (.dmark+2)  
4203 32 7c ee			ld (debug_mark+2),a  
4206 18 03			jr .pastdmark  
4208 ..			.dmark: db "EDc"  
420b f1			.pastdmark: pop af  
420c			endm  
# End of macro DMARK
420c						CALLMONITOR 
420c cd 80 13			call break_point_state  
420f				endm  
# End of macro CALLMONITOR
420f					endif 
420f ed b0				ldir 
4211			 
4211			 
4211 21 73 e5				ld hl, os_input 
4214					;ld a, 0 
4214					;ld (hl),a 
4214 3a 5e eb				ld a,(f_cursor_ptr) 
4217 16 64				ld d, 100 
4219 0e 00				ld c, 0 
421b 1e 28				ld e, 40 
421d cd 95 0b				call input_str 
4220					; TODO perhaps do a type check and wrap in quotes if not a number 
4220 21 73 e5				ld hl, os_input 
4223					if DEBUG_FORTH_WORDS 
4223						DMARK "ED1" 
4223 f5				push af  
4224 3a 38 42			ld a, (.dmark)  
4227 32 7a ee			ld (debug_mark),a  
422a 3a 39 42			ld a, (.dmark+1)  
422d 32 7b ee			ld (debug_mark+1),a  
4230 3a 3a 42			ld a, (.dmark+2)  
4233 32 7c ee			ld (debug_mark+2),a  
4236 18 03			jr .pastdmark  
4238 ..			.dmark: db "ED1"  
423b f1			.pastdmark: pop af  
423c			endm  
# End of macro DMARK
423c						CALLMONITOR 
423c cd 80 13			call break_point_state  
423f				endm  
# End of macro CALLMONITOR
423f					endif 
423f cd 2c 19				call forth_push_str 
4242					NEXTW 
4242 c3 0b 1b			jp macro_next 
4245				endm 
# End of macro NEXTW
4245			 
4245			 
4245			 
4245			.ENDKEY: 
4245			; eof 
4245			 
# End of file forth_words_key.asm
4245			 
4245			if STORAGE_SE 
4245			   	include "forth_words_storage.asm" 
4245			endif 
4245				include "forth_words_device.asm" 
4245			; Device related words 
4245			 
4245			; | ## Device Words 
4245			 
4245			if SOUND_ENABLE 
4245			.NOTE: 
4245				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4245			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4245					if DEBUG_FORTH_WORDS_KEY 
4245						DMARK "NTE" 
4245						CALLMONITOR 
4245					endif 
4245			 
4245				 
4245			 
4245					NEXTW 
4245			.AFTERSOUND: 
4245			endif 
4245			 
4245			 
4245			USE_GPIO: equ 0 
4245			 
4245			if USE_GPIO 
4245			.GP1: 
4245				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4245			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4245					NEXTW 
4245			.GP2: 
4245				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4245			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4245			 
4245					NEXTW 
4245			 
4245			.GP3: 
4245				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4245			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4245			 
4245					NEXTW 
4245			 
4245			.GP4: 
4245				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4245			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4245			 
4245					NEXTW 
4245			.SIN: 
4245			 
4245			 
4245			endif 
4245			 
4245			 
4245				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4245 33				db WORD_SYS_CORE+31             
4246 7a 42			dw .SOUT            
4248 03				db 2 + 1 
4249 .. 00			db "IN",0              
424c				endm 
# End of macro CWHEAD
424c			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
424c					if DEBUG_FORTH_WORDS_KEY 
424c						DMARK "IN." 
424c f5				push af  
424d 3a 61 42			ld a, (.dmark)  
4250 32 7a ee			ld (debug_mark),a  
4253 3a 62 42			ld a, (.dmark+1)  
4256 32 7b ee			ld (debug_mark+1),a  
4259 3a 63 42			ld a, (.dmark+2)  
425c 32 7c ee			ld (debug_mark+2),a  
425f 18 03			jr .pastdmark  
4261 ..			.dmark: db "IN."  
4264 f1			.pastdmark: pop af  
4265			endm  
# End of macro DMARK
4265						CALLMONITOR 
4265 cd 80 13			call break_point_state  
4268				endm  
# End of macro CALLMONITOR
4268					endif 
4268					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4268 cd b5 19			call macro_dsp_valuehl 
426b				endm 
# End of macro FORTH_DSP_VALUEHL
426b			 
426b e5					push hl 
426c			 
426c					; destroy value TOS 
426c			 
426c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
426c cd 51 1a			call macro_forth_dsp_pop 
426f				endm 
# End of macro FORTH_DSP_POP
426f			 
426f					; one value on hl get other one back 
426f			 
426f c1					pop bc 
4270			 
4270					; do the sub 
4270			;		ex de, hl 
4270			 
4270 ed 68				in l,(c) 
4272			 
4272					; save it 
4272			 
4272 26 00				ld h,0 
4274			 
4274					; TODO push value back onto stack for another op etc 
4274			 
4274 cd 1a 19				call forth_push_numhl 
4277					NEXTW 
4277 c3 0b 1b			jp macro_next 
427a				endm 
# End of macro NEXTW
427a			.SOUT: 
427a				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
427a 34				db WORD_SYS_CORE+32             
427b cd 42			dw .SPIO            
427d 04				db 3 + 1 
427e .. 00			db "OUT",0              
4282				endm 
# End of macro CWHEAD
4282			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4282					if DEBUG_FORTH_WORDS_KEY 
4282						DMARK "OUT" 
4282 f5				push af  
4283 3a 97 42			ld a, (.dmark)  
4286 32 7a ee			ld (debug_mark),a  
4289 3a 98 42			ld a, (.dmark+1)  
428c 32 7b ee			ld (debug_mark+1),a  
428f 3a 99 42			ld a, (.dmark+2)  
4292 32 7c ee			ld (debug_mark+2),a  
4295 18 03			jr .pastdmark  
4297 ..			.dmark: db "OUT"  
429a f1			.pastdmark: pop af  
429b			endm  
# End of macro DMARK
429b						CALLMONITOR 
429b cd 80 13			call break_point_state  
429e				endm  
# End of macro CALLMONITOR
429e					endif 
429e			 
429e					; get port 
429e			 
429e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
429e cd b5 19			call macro_dsp_valuehl 
42a1				endm 
# End of macro FORTH_DSP_VALUEHL
42a1			 
42a1 e5					push hl 
42a2			 
42a2					; destroy value TOS 
42a2			 
42a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42a2 cd 51 1a			call macro_forth_dsp_pop 
42a5				endm 
# End of macro FORTH_DSP_POP
42a5			 
42a5					; get byte to send 
42a5			 
42a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42a5 cd b5 19			call macro_dsp_valuehl 
42a8				endm 
# End of macro FORTH_DSP_VALUEHL
42a8			 
42a8			;		push hl 
42a8			 
42a8					; destroy value TOS 
42a8			 
42a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42a8 cd 51 1a			call macro_forth_dsp_pop 
42ab				endm 
# End of macro FORTH_DSP_POP
42ab			 
42ab					; one value on hl get other one back 
42ab			 
42ab			;		pop hl 
42ab			 
42ab c1					pop bc 
42ac			 
42ac					if DEBUG_FORTH_WORDS 
42ac						DMARK "OUT" 
42ac f5				push af  
42ad 3a c1 42			ld a, (.dmark)  
42b0 32 7a ee			ld (debug_mark),a  
42b3 3a c2 42			ld a, (.dmark+1)  
42b6 32 7b ee			ld (debug_mark+1),a  
42b9 3a c3 42			ld a, (.dmark+2)  
42bc 32 7c ee			ld (debug_mark+2),a  
42bf 18 03			jr .pastdmark  
42c1 ..			.dmark: db "OUT"  
42c4 f1			.pastdmark: pop af  
42c5			endm  
# End of macro DMARK
42c5						CALLMONITOR 
42c5 cd 80 13			call break_point_state  
42c8				endm  
# End of macro CALLMONITOR
42c8					endif 
42c8			 
42c8 ed 69				out (c), l 
42ca			 
42ca					NEXTW 
42ca c3 0b 1b			jp macro_next 
42cd				endm 
# End of macro NEXTW
42cd			 
42cd			 
42cd			.SPIO: 
42cd			 
42cd			if STORAGE_SE 
42cd				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
42cd			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
42cd			 
42cd					call spi_ce_low 
42cd			    NEXTW 
42cd			 
42cd			.SPICEH: 
42cd				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
42cd			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
42cd			 
42cd					call spi_ce_high 
42cd			    NEXTW 
42cd			 
42cd			 
42cd			.SPIOb: 
42cd			 
42cd				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
42cd			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
42cd			 
42cd					; get port 
42cd			 
42cd			 
42cd					; get byte to send 
42cd			 
42cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42cd			 
42cd			;		push hl    ; u1  
42cd			 
42cd					; destroy value TOS 
42cd			 
42cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42cd			 
42cd					; one value on hl get other one back 
42cd			 
42cd			;		pop hl   ; u2 - addr 
42cd			 
42cd					; TODO Send SPI byte 
42cd			 
42cd					ld a, l 
42cd					call spi_send_byte 
42cd			 
42cd					NEXTW 
42cd			 
42cd			.SPII: 
42cd				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
42cd			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
42cd			 
42cd					; TODO Get SPI byte 
42cd			 
42cd					call spi_read_byte 
42cd			 
42cd					ld h, 0 
42cd					ld l, a 
42cd					call forth_push_numhl 
42cd			 
42cd					NEXTW 
42cd			 
42cd			 
42cd			 
42cd			.SESEL: 
42cd				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
42cd			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
42cd					if DEBUG_FORTH_WORDS_KEY 
42cd						DMARK "BNK" 
42cd						CALLMONITOR 
42cd					endif 
42cd			 
42cd					ld a, 255 
42cd					ld (spi_cartdev), a 
42cd			 
42cd					; get bank 
42cd			 
42cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42cd			 
42cd			;		push hl 
42cd			 
42cd					; destroy value TOS 
42cd			 
42cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42cd			 
42cd					; one value on hl get other one back 
42cd			 
42cd			;		pop hl 
42cd			 
42cd			 
42cd					ld c, SPI_CE_HIGH 
42cd			 
42cd					ld a, l 
42cd			 
42cd					if DEBUG_FORTH_WORDS 
42cd						DMARK "BNK" 
42cd						CALLMONITOR 
42cd					endif 
42cd			 
42cd					; active low 
42cd			 
42cd					cp 0 
42cd					jr z, .bset 
42cd					cp 1 
42cd					jr nz, .b2 
42cd					res 0, c 
42cd			.b2:		cp 2 
42cd					jr nz, .b3 
42cd					res 1, c 
42cd			.b3:		cp 3 
42cd					jr nz, .b4 
42cd					res 2, c 
42cd			.b4:		cp 4 
42cd					jr nz, .b5 
42cd					res 3, c 
42cd			.b5:		cp 5 
42cd					jr nz, .bset 
42cd					res 4, c 
42cd			 
42cd			.bset: 
42cd					ld a, c 
42cd					ld (spi_device),a 
42cd					if DEBUG_FORTH_WORDS 
42cd						DMARK "BN2" 
42cd						CALLMONITOR 
42cd					endif 
42cd			 
42cd					NEXTW 
42cd			 
42cd			.CARTDEV: 
42cd				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
42cd			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
42cd					if DEBUG_FORTH_WORDS_KEY 
42cd						DMARK "CDV" 
42cd						CALLMONITOR 
42cd					endif 
42cd			 
42cd					; disable se storage bank selection 
42cd			 
42cd					ld a, SPI_CE_HIGH		; ce high 
42cd					ld (spi_device), a 
42cd			 
42cd					; get bank 
42cd			 
42cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42cd			 
42cd			;		push hl 
42cd			 
42cd					; destroy value TOS 
42cd			 
42cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42cd			 
42cd					; one value on hl get other one back 
42cd			 
42cd			;		pop hl 
42cd			 
42cd					; active low 
42cd			 
42cd					ld c, 255 
42cd			 
42cd					ld a, l 
42cd					if DEBUG_FORTH_WORDS 
42cd						DMARK "CDV" 
42cd						CALLMONITOR 
42cd					endif 
42cd					cp 0 
42cd					jr z, .cset 
42cd					cp 1 
42cd					jr nz, .c2 
42cd					res 0, c 
42cd			.c2:		cp 2 
42cd					jr nz, .c3 
42cd					res 1, c 
42cd			.c3:		cp 3 
42cd					jr nz, .c4 
42cd					res 2, c 
42cd			.c4:		cp 4 
42cd					jr nz, .c5 
42cd					res 3, c 
42cd			.c5:		cp 5 
42cd					jr nz, .c6 
42cd					res 4, c 
42cd			.c6:		cp 6 
42cd					jr nz, .c7 
42cd					res 5, c 
42cd			.c7:		cp 7 
42cd					jr nz, .c8 
42cd					res 6, c 
42cd			.c8:		cp 8 
42cd					jr nz, .cset 
42cd					res 7, c 
42cd			.cset:		ld a, c 
42cd					ld (spi_cartdev),a 
42cd			 
42cd					if DEBUG_FORTH_WORDS 
42cd						DMARK "CD2" 
42cd						CALLMONITOR 
42cd					endif 
42cd					NEXTW 
42cd			endif 
42cd			 
42cd			.ENDDEVICE: 
42cd			; eof 
42cd			 
# End of file forth_words_device.asm
42cd			 
42cd			; var handler 
42cd			 
42cd			 
42cd			.VARS: 
42cd				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
42cd 78				db WORD_SYS_CORE+100             
42ce e5 42			dw .V0Q            
42d0 04				db 3 + 1 
42d1 .. 00			db "V0!",0              
42d5				endm 
# End of macro CWHEAD
42d5			;| V0! ( u1 -- )  Store value to v0  | DONE 
42d5			 
42d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42d5 cd b5 19			call macro_dsp_valuehl 
42d8				endm 
# End of macro FORTH_DSP_VALUEHL
42d8			 
42d8 11 28 eb				ld de, cli_var_array 
42db			 
42db eb					ex de, hl 
42dc 73					ld (hl), e 
42dd 23					inc hl 
42de 72					ld (hl), d 
42df			 
42df					; destroy value TOS 
42df			 
42df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42df cd 51 1a			call macro_forth_dsp_pop 
42e2				endm 
# End of macro FORTH_DSP_POP
42e2			 
42e2				       NEXTW 
42e2 c3 0b 1b			jp macro_next 
42e5				endm 
# End of macro NEXTW
42e5			.V0Q: 
42e5				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
42e5 79				db WORD_SYS_CORE+101             
42e6 f6 42			dw .V1S            
42e8 04				db 3 + 1 
42e9 .. 00			db "V0@",0              
42ed				endm 
# End of macro CWHEAD
42ed			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
42ed 2a 28 eb				ld hl, (cli_var_array) 
42f0 cd 1a 19				call forth_push_numhl 
42f3			 
42f3				       NEXTW 
42f3 c3 0b 1b			jp macro_next 
42f6				endm 
# End of macro NEXTW
42f6			.V1S: 
42f6				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
42f6 7a				db WORD_SYS_CORE+102             
42f7 0e 43			dw .V1Q            
42f9 04				db 3 + 1 
42fa .. 00			db "V1!",0              
42fe				endm 
# End of macro CWHEAD
42fe			;| V1! ( u1 -- )  Store value to v1 | DONE 
42fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42fe cd b5 19			call macro_dsp_valuehl 
4301				endm 
# End of macro FORTH_DSP_VALUEHL
4301			 
4301 11 2a eb				ld de, cli_var_array+2 
4304				 
4304 eb					ex de, hl 
4305 73					ld (hl), e 
4306 23					inc hl 
4307 72					ld (hl), d 
4308			 
4308					; destroy value TOS 
4308			 
4308					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4308 cd 51 1a			call macro_forth_dsp_pop 
430b				endm 
# End of macro FORTH_DSP_POP
430b				       NEXTW 
430b c3 0b 1b			jp macro_next 
430e				endm 
# End of macro NEXTW
430e			.V1Q: 
430e				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
430e 7b				db WORD_SYS_CORE+103             
430f 1f 43			dw .V2S            
4311 04				db 3 + 1 
4312 .. 00			db "V1@",0              
4316				endm 
# End of macro CWHEAD
4316			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4316 2a 2a eb				ld hl, (cli_var_array+2) 
4319 cd 1a 19				call forth_push_numhl 
431c				       NEXTW 
431c c3 0b 1b			jp macro_next 
431f				endm 
# End of macro NEXTW
431f			.V2S: 
431f				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
431f 7c				db WORD_SYS_CORE+104             
4320 37 43			dw .V2Q            
4322 04				db 3 + 1 
4323 .. 00			db "V2!",0              
4327				endm 
# End of macro CWHEAD
4327			;| V2! ( u1 -- )  Store value to v2 | DONE 
4327					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4327 cd b5 19			call macro_dsp_valuehl 
432a				endm 
# End of macro FORTH_DSP_VALUEHL
432a			 
432a 11 2c eb				ld de, cli_var_array+4 
432d				 
432d eb					ex de, hl 
432e 73					ld (hl), e 
432f 23					inc hl 
4330 72					ld (hl), d 
4331			 
4331					; destroy value TOS 
4331			 
4331					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4331 cd 51 1a			call macro_forth_dsp_pop 
4334				endm 
# End of macro FORTH_DSP_POP
4334				       NEXTW 
4334 c3 0b 1b			jp macro_next 
4337				endm 
# End of macro NEXTW
4337			.V2Q: 
4337				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4337 7d				db WORD_SYS_CORE+105             
4338 48 43			dw .V3S            
433a 04				db 3 + 1 
433b .. 00			db "V2@",0              
433f				endm 
# End of macro CWHEAD
433f			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
433f 2a 2c eb				ld hl, (cli_var_array+4) 
4342 cd 1a 19				call forth_push_numhl 
4345				       NEXTW 
4345 c3 0b 1b			jp macro_next 
4348				endm 
# End of macro NEXTW
4348			.V3S: 
4348				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4348 7c				db WORD_SYS_CORE+104             
4349 60 43			dw .V3Q            
434b 04				db 3 + 1 
434c .. 00			db "V3!",0              
4350				endm 
# End of macro CWHEAD
4350			;| V3! ( u1 -- )  Store value to v3 | DONE 
4350					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4350 cd b5 19			call macro_dsp_valuehl 
4353				endm 
# End of macro FORTH_DSP_VALUEHL
4353			 
4353 11 2e eb				ld de, cli_var_array+6 
4356				 
4356 eb					ex de, hl 
4357 73					ld (hl), e 
4358 23					inc hl 
4359 72					ld (hl), d 
435a			 
435a					; destroy value TOS 
435a			 
435a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
435a cd 51 1a			call macro_forth_dsp_pop 
435d				endm 
# End of macro FORTH_DSP_POP
435d				       NEXTW 
435d c3 0b 1b			jp macro_next 
4360				endm 
# End of macro NEXTW
4360			.V3Q: 
4360				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4360 7d				db WORD_SYS_CORE+105             
4361 71 43			dw .END            
4363 04				db 3 + 1 
4364 .. 00			db "V3@",0              
4368				endm 
# End of macro CWHEAD
4368			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4368 2a 2e eb				ld hl, (cli_var_array+6) 
436b cd 1a 19				call forth_push_numhl 
436e				       NEXTW 
436e c3 0b 1b			jp macro_next 
4371				endm 
# End of macro NEXTW
4371			 
4371			 
4371			 
4371			 
4371			 
4371			; end of dict marker 
4371			 
4371 00			.END:    db WORD_SYS_END 
4372 00 00			dw 0 
4374 00				db 0 
4375			 
4375			; use to jp here for user dict words to save on macro expansion  
4375			 
4375			user_dict_next: 
4375				NEXTW 
4375 c3 0b 1b			jp macro_next 
4378				endm 
# End of macro NEXTW
4378			 
4378			 
4378			user_exec: 
4378				;    ld hl, <word code> 
4378				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4378				;    call forthexec 
4378				;    jp user_dict_next   (NEXT) 
4378			        ;    <word code bytes> 
4378 eb				ex de, hl 
4379 2a 76 e6			ld hl,(os_tok_ptr) 
437c				 
437c				FORTH_RSP_NEXT 
437c cd c1 18			call macro_forth_rsp_next 
437f				endm 
# End of macro FORTH_RSP_NEXT
437f			 
437f			if DEBUG_FORTH_UWORD 
437f						DMARK "UEX" 
437f f5				push af  
4380 3a 94 43			ld a, (.dmark)  
4383 32 7a ee			ld (debug_mark),a  
4386 3a 95 43			ld a, (.dmark+1)  
4389 32 7b ee			ld (debug_mark+1),a  
438c 3a 96 43			ld a, (.dmark+2)  
438f 32 7c ee			ld (debug_mark+2),a  
4392 18 03			jr .pastdmark  
4394 ..			.dmark: db "UEX"  
4397 f1			.pastdmark: pop af  
4398			endm  
# End of macro DMARK
4398				CALLMONITOR 
4398 cd 80 13			call break_point_state  
439b				endm  
# End of macro CALLMONITOR
439b			endif 
439b			 
439b			 
439b			 
439b eb				ex de, hl 
439c 22 76 e6			ld (os_tok_ptr), hl 
439f				 
439f				; Don't use next - Skips the first word in uword. 
439f			 
439f c3 9c 1b			jp exec1 
43a2			;	NEXT 
43a2			 
43a2			 
43a2			; eof 
# End of file forth_wordsv4.asm
43a2			endif 
43a2			;;;;;;;;;;;;;; Debug code 
43a2			 
43a2			 
43a2			;if DEBUG_FORTH_PARSE 
43a2 .. 00		.nowordfound: db "No match",0 
43ab .. 00		.compword:	db "Comparing word ",0 
43bb .. 00		.nextwordat:	db "Next word at",0 
43c8 .. 00		.charmatch:	db "Char match",0 
43d3			;endif 
43d3			if DEBUG_FORTH_JP 
43d3			.foundword:	db "Word match. Exec..",0 
43d3			endif 
43d3			;if DEBUG_FORTH_PUSH 
43d3 .. 00		.enddict:	db "Dict end. Push.",0 
43e3 .. 00		.push_str:	db "Pushing string",0 
43f2 .. 00		.push_num:	db "Pushing number",0 
4401 .. 00		.data_sp:	db "SP:",0 
4405 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4417 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4429 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
443b			;endif 
443b			;if DEBUG_FORTH_MALLOC 
443b .. 00		.push_malloc:	db "Malloc address",0 
444a			;endif 
444a			 
444a			 
444a			 
444a			; display malloc address and current data stack pointer  
444a			 
444a			malloc_error: 
444a d5				push de 
444b f5				push af 
444c e5				push hl 
444d cd 3f 09			call clear_display 
4450 11 72 44			ld de, .mallocerr 
4453 3e 00			ld a,0 
4455			;	ld de,os_word_scratch 
4455 cd 52 09			call str_at_display 
4458 3e 11			ld a, display_row_1+17 
445a 11 7a ee			ld de, debug_mark 
445d cd 52 09			call str_at_display 
4460 cd 62 09			call update_display 
4463				;call break_point_state 
4463 cd cc 57			call cin_wait 
4466			 
4466 3e 20			ld a, ' ' 
4468 32 74 e3			ld (os_view_disable), a 
446b e1				pop hl 
446c f1				pop af 
446d d1				pop de	 
446e				CALLMONITOR 
446e cd 80 13			call break_point_state  
4471				endm  
# End of macro CALLMONITOR
4471 c9				ret 
4472			 
4472 .. 00		.mallocerr: 	db "Malloc Error",0 
447f			;if DEBUG_FORTH_PUSH 
447f			display_data_sp: 
447f f5				push af 
4480			 
4480				; see if disabled 
4480			 
4480 3a 74 e3			ld a, (os_view_disable) 
4483 fe 2a			cp '*' 
4485 28 67			jr z, .skipdsp 
4487			 
4487 e5				push hl 
4488 e5				push hl 
4489 e5			push hl 
448a cd 3f 09			call clear_display 
448d e1			pop hl 
448e 7c				ld a,h 
448f 21 7a e6			ld hl, os_word_scratch 
4492 cd 69 0e			call hexout 
4495 e1				pop hl 
4496 7d				ld a,l 
4497 21 7c e6			ld hl, os_word_scratch+2 
449a cd 69 0e			call hexout 
449d 21 7e e6			ld hl, os_word_scratch+4 
44a0 3e 00			ld a,0 
44a2 77				ld (hl),a 
44a3 11 7a e6			ld de,os_word_scratch 
44a6 3e 28				ld a, display_row_2 
44a8 cd 52 09				call str_at_display 
44ab 11 05 44			ld de, .wordinhl 
44ae 3e 00			ld a, display_row_1 
44b0			 
44b0 cd 52 09				call str_at_display 
44b3 11 7a ee			ld de, debug_mark 
44b6 3e 11			ld a, display_row_1+17 
44b8			 
44b8 cd 52 09				call str_at_display 
44bb			 
44bb				; display current data stack pointer 
44bb 11 01 44			ld de,.data_sp 
44be 3e 30				ld a, display_row_2 + 8 
44c0 cd 52 09				call str_at_display 
44c3			 
44c3 2a 22 eb			ld hl,(cli_data_sp) 
44c6 e5				push hl 
44c7 7c				ld a,h 
44c8 21 7a e6			ld hl, os_word_scratch 
44cb cd 69 0e			call hexout 
44ce e1				pop hl 
44cf 7d				ld a,l 
44d0 21 7c e6			ld hl, os_word_scratch+2 
44d3 cd 69 0e			call hexout 
44d6 21 7e e6			ld hl, os_word_scratch+4 
44d9 3e 00			ld a,0 
44db 77				ld (hl),a 
44dc 11 7a e6			ld de,os_word_scratch 
44df 3e 33				ld a, display_row_2 + 11 
44e1 cd 52 09				call str_at_display 
44e4			 
44e4			 
44e4 cd 62 09			call update_display 
44e7 cd e2 08			call delay1s 
44ea cd e2 08			call delay1s 
44ed e1				pop hl 
44ee			.skipdsp: 
44ee f1				pop af 
44ef c9				ret 
44f0			 
44f0			display_data_malloc: 
44f0			 
44f0 f5				push af 
44f1 e5				push hl 
44f2 e5				push hl 
44f3 e5			push hl 
44f4 cd 3f 09			call clear_display 
44f7 e1			pop hl 
44f8 7c				ld a,h 
44f9 21 7a e6			ld hl, os_word_scratch 
44fc cd 69 0e			call hexout 
44ff e1				pop hl 
4500 7d				ld a,l 
4501 21 7c e6			ld hl, os_word_scratch+2 
4504 cd 69 0e			call hexout 
4507 21 7e e6			ld hl, os_word_scratch+4 
450a 3e 00			ld a,0 
450c 77				ld (hl),a 
450d 11 7a e6			ld de,os_word_scratch 
4510 3e 28				ld a, display_row_2 
4512 cd 52 09				call str_at_display 
4515 11 3b 44			ld de, .push_malloc 
4518 3e 00			ld a, display_row_1 
451a			 
451a cd 52 09				call str_at_display 
451d			 
451d				; display current data stack pointer 
451d 11 01 44			ld de,.data_sp 
4520 3e 30				ld a, display_row_2 + 8 
4522 cd 52 09				call str_at_display 
4525			 
4525 2a 22 eb			ld hl,(cli_data_sp) 
4528 e5				push hl 
4529 7c				ld a,h 
452a 21 7a e6			ld hl, os_word_scratch 
452d cd 69 0e			call hexout 
4530 e1				pop hl 
4531 7d				ld a,l 
4532 21 7c e6			ld hl, os_word_scratch+2 
4535 cd 69 0e			call hexout 
4538 21 7e e6			ld hl, os_word_scratch+4 
453b 3e 00			ld a,0 
453d 77				ld (hl),a 
453e 11 7a e6			ld de,os_word_scratch 
4541 3e 33				ld a, display_row_2 + 11 
4543 cd 52 09				call str_at_display 
4546			 
4546 cd 62 09			call update_display 
4549 cd e2 08			call delay1s 
454c cd e2 08			call delay1s 
454f e1				pop hl 
4550 f1				pop af 
4551 c9				ret 
4552			;endif 
4552			 
4552			include "forth_autostart.asm" 
4552			; list of commands to perform at system start up 
4552			 
4552			startcmds: 
4552			;	dw test11 
4552			;	dw test12 
4552			;	dw test13 
4552			;	dw test14 
4552			;	dw test15 
4552			;	dw test16 
4552			;	dw test17 
4552			;	dw ifthtest1 
4552			;	dw ifthtest2 
4552			;	dw ifthtest3 
4552			;	dw mmtest1 
4552			;	dw mmtest2 
4552			;	dw mmtest3 
4552			;	dw mmtest4 
4552			;	dw mmtest5 
4552			;	dw mmtest6 
4552			;	dw iftest1 
4552			;	dw iftest2 
4552			;	dw iftest3 
4552			;	dw looptest1 
4552			;	dw looptest2 
4552			;	dw test1 
4552			;	dw test2 
4552			;	dw test3 
4552			;	dw test4 
4552			;	dw game2r 
4552			;	dw game2b1 
4552			;	dw game2b2 
4552			 
4552				; start up words that are actually useful 
4552			 
4552 b0 45			dw clrstack 
4554 e3 45			dw type 
4556 a4 47			dw stest 
4558 07 46			dw strncpy 
455a 45 47			dw list 
455c 68 46			dw start1 
455e 7a 46			dw start2 
4560			;	dw start3 
4560 8d 46			dw start3b 
4562 e5 46			dw start3c 
4564			 
4564				; (unit) testing words 
4564			 
4564 1b 48			dw mtesta 
4566 d0 48			dw mtestb 
4568 73 49			dw mtestc 
456a 28 4a			dw mtestd 
456c cc 4a			dw mteste 
456e			 
456e				; demo/game words 
456e			 
456e d8 51		        dw game3w 
4570 06 52		        dw game3p 
4572 24 52		        dw game3sc 
4574 55 52		        dw game3vsi 
4576 81 52		        dw game3vs 
4578				 
4578 cb 4f			dw game2b 
457a 39 50			dw game2bf 
457c 83 50			dw game2mba 
457e 19 51			dw game2mbas 
4580 5b 51			dw game2mb 
4582			 
4582 8c 4c			dw game1 
4584 9d 4c			dw game1a 
4586 ff 4c			dw game1b 
4588 34 4d			dw game1c 
458a 6a 4d			dw game1d 
458c 9b 4d			dw game1s 
458e af 4d			dw game1t 
4590 c4 4d			dw game1f 
4592 f8 4d			dw game1z 
4594 3c 4e			dw game1zz 
4596			 
4596 82 4b			dw test5 
4598 ba 4b			dw test6 
459a f2 4b			dw test7 
459c 06 4c			dw test8 
459e 32 4c			dw test9 
45a0 48 4c			dw test10 
45a2				 
45a2 13 4f		        dw ssv5 
45a4 f7 4e		        dw ssv4 
45a6 db 4e		        dw ssv3 
45a8 a5 4e		        dw ssv2 
45aa 2c 4f		        dw ssv1 
45ac 74 4f		        dw ssv1cpm 
45ae			;	dw keyup 
45ae			;	dw keydown 
45ae			;	dw keyleft 
45ae			;	dw keyright 
45ae			;	dw 	keyf1 
45ae			;	dw keyf2 
45ae			;	dw keyf3 
45ae			;	dw keyf4 
45ae			;	dw keyf5 
45ae			;	dw keyf6 
45ae			;	dw keyf7 
45ae			;	dw keyf8 
45ae			;	dw keyf9 
45ae			;	dw keyf10 
45ae			;	dw keyf11 
45ae			;	dw keyf12 
45ae			;	dw keytab 
45ae			;	dw keycr 
45ae			;	dw keyhome 
45ae			;	dw keyend 
45ae			;	dw keybs 
45ae 00 00			db 0, 0	 
45b0			 
45b0			 
45b0			; clear stack  
45b0			 
45b0 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
45e3			 
45e3			; type ( addr count - ) 
45e3 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4607			 
4607			; some direct memory words 
4607			; strncpy ( len t f -- t ) 
4607			 
4607 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4668			 
4668 .. 00		start1:     	db ": bpon $0000 bp ;",0 
467a .. 00		start2:     	db ": bpoff $0001 bp ;",0 
468d			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
468d .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
46e5 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
4745			 
4745			 
4745			; a handy word to list items on the stack 
4745			 
4745 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
47a4			 
47a4			 
47a4			; test stack  
47a4			; rnd8 stest 
47a4			 
47a4 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
481b			 
481b			; random malloc and free cycles 
481b			 
481b .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
48d0			 
48d0			; fixed malloc and free cycles 
48d0			 
48d0 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4973			 
4973			; fixed double string push and drop cycle  
4973			 
4973 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4a28			 
4a28			; consistent fixed string push and drop cycle  
4a28			 
4a28 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4acc			 
4acc .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4b82			 
4b82			;test1:		db ": aa 1 2 3 ;", 0 
4b82			;test2:     	db "111 aa 888 999",0 
4b82			;test3:     	db ": bb 77 ;",0 
4b82			;test4:     	db "$02 $01 do i . loop bb",0 
4b82			 
4b82 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4bba .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4bf2 .. 00		test7:     	db ": box hline vline ;",0 
4c06 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4c32 .. 00		test9:     	db ": sw $01 adsp world ;",0 
4c48 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4c6d .. 00		test11:     	db "hello create .",0 
4c7c .. 00		test12:     	db "hello2 create .",0 
4c8c			 
4c8c			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4c8c			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4c8c			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4c8c			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4c8c			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4c8c			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4c8c			 
4c8c			;iftest1:     	db "$0001 IF cls .",0 
4c8c			;iftest2:     	db "$0000 IF cls .",0 
4c8c			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4c8c			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4c8c			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4c8c			 
4c8c			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4c8c			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4c8c			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4c8c			 
4c8c			 
4c8c			 
4c8c			; a small guess the number game 
4c8c			 
4c8c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4c9d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4cff			 
4cff .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4d34 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4d6a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4d9b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4daf .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4dc4 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4df8 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4e3c			 
4e3c			; Using 'ga' save a high score across multiple runs using external storage 
4e3c			 
4e3c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4ea5			 
4ea5			 
4ea5			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4ea5			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ea5			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ea5			 
4ea5			; simple screen saver to test code memory reuse to destruction 
4ea5			 
4ea5 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
4edb .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
4ef7 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
4f13 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
4f2c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
4f74 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
4fcb			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
4fcb			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
4fcb			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
4fcb			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
4fcb			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
4fcb			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
4fcb			 
4fcb			 
4fcb			 
4fcb			; minesweeper/battleship finding game 
4fcb			; draws a game board of random ship/mine positions 
4fcb			; user enters coords to see if it hits on 
4fcb			; game ends when all are hit 
4fcb			; when hit or miss says how many may be in the area 
4fcb			 
4fcb			; setup the game board and then hide it 
4fcb .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5039 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5083			; prompt for where to target 
5083 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5119 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
513e			; TODO see if the entered coords hits or misses pushes char hit of miss 
513e .. 00		game2mbht:      db ": mbckht nop ;",0 
514d .. 00		game2mbms:      db ": mbcms nop ;",0 
515b			; TODO how many might be near by 
515b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
51d8			 
51d8			; Game 3 
51d8			 
51d8			; Vert scroller ski game - avoid the trees! 
51d8			 
51d8			; v0 score (ie turns) 
51d8			; v1 player pos 
51d8			; v2 left wall 
51d8			; v3 right wall 
51d8			 
51d8			; Draw side walls randomly 
51d8			 
51d8 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5206			 
5206			; Draw player 
5206 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5224			 
5224			; TODO Get Key 
5224			 
5224			; TODO Move left right 
5224			 
5224			; scroll and move walls a bit 
5224			 
5224 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5255			 
5255			; main game loop 
5255			 
5255 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5281 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
52c0			 
52c0			; key board defs 
52c0			 
52c0 .. 00		keyup:       db ": keyup $05 ;",0 
52ce .. 00		keydown:       db ": keydown $0a ;",0 
52de .. 00		keyleft:       db ": keyleft $0b ;",0 
52ee .. 00		keyright:       db ": keyright $0c ;",0 
52ff .. 00		keyf1:       db ": keyf1 $10 ;",0 
530d .. 00		keyf2:       db ": keyf2 $11 ;",0 
531b .. 00		keyf3:       db ": keyf3 $12 ;",0 
5329 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5337 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5345 .. 00		keyf6:       db ": keyf6 $15 ;",0 
5353 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5361 .. 00		keyf8:       db ": keyf8 $17 ;",0 
536f .. 00		keyf9:       db ": keyf9 $18 ;",0 
537d .. 00		keyf10:       db ": keyf10 $19 ;",0 
538c .. 00		keyf11:       db ": keyf11 $1a ;",0 
539b .. 00		keyf12:       db ": keyf12 $1b ;",0 
53aa			 
53aa .. 00		keytab:       db ": keytab $09 ;",0 
53b9 .. 00		keycr:       db ": keycr $0d ;",0 
53c7 .. 00		keyhome:       db ": keyhome $0e ;",0 
53d7 .. 00		keyend:       db ": keyend $0f ;",0 
53e6 .. 00		keybs:       db ": keybs $08 ;",0 
53f4			 
53f4			   
53f4			 
53f4			 
53f4			 
53f4			; eof 
# End of file forth_autostart.asm
53f4			 
53f4 .. 00		sprompt1: db "Startup load...",0 
5404 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
541a			 
541a			forth_startup: 
541a 21 52 45			ld hl, startcmds 
541d 3e 00			ld a, 0 
541f 32 9b e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5422			 
5422 e5			.start1:	push hl 
5423 cd 3f 09			call clear_display 
5426 11 f4 53			ld de, sprompt1 
5429 3e 00		        ld a, display_row_1 
542b cd 52 09			call str_at_display 
542e 11 04 54			ld de, sprompt2 
5431 3e 28		        ld a, display_row_2 
5433 cd 52 09			call str_at_display 
5436 e1				pop hl 
5437 e5				push hl 
5438 5e				ld e,(hl) 
5439 23				inc hl 
543a 56				ld d,(hl) 
543b 3e 50		        ld a, display_row_3 
543d cd 52 09			call str_at_display 
5440 cd 62 09			call update_display 
5443			 
5443			 
5443 3a 9b e7			ld a, (os_last_cmd) 
5446 fe 00			cp 0 
5448 28 05			jr z, .startprompt 
544a cd d6 08			call delay250ms 
544d 18 24			jr .startdo 
544f				 
544f				 
544f			 
544f			.startprompt: 
544f			 
544f 3e 9f			ld a,display_row_4 + display_cols - 1 
5451 11 90 18		        ld de, endprg 
5454 cd 52 09			call str_at_display 
5457 cd 62 09			call update_display 
545a cd e2 08			call delay1s 
545d cd cc 57			call cin_wait 
5460						 
5460 fe 2a			cp '*' 
5462 28 5e			jr z, .startupend1 
5464 fe 23			cp '#' 
5466 20 07			jr nz, .startno 
5468 3e 01			ld a, 1 
546a 32 9b e7			ld (os_last_cmd),a 
546d 18 04			jr .startdo 
546f fe 31		.startno:	cp '1' 
5471 28 3a			jr z,.startnxt  
5473			 
5473				; exec startup line 
5473			.startdo:	 
5473 e1				pop hl 
5474 e5				push hl 
5475				 
5475 5e				ld e,(hl) 
5476 23				inc hl 
5477 56				ld d,(hl) 
5478 eb				ex de,hl 
5479			 
5479 e5				push hl 
547a			 
547a 3e 00			ld a, 0 
547c				;ld a, FORTH_END_BUFFER 
547c cd d1 0f			call strlent 
547f 23				inc hl   ; include zero term to copy 
5480 06 00			ld b,0 
5482 4d				ld c,l 
5483 e1				pop hl 
5484 11 75 e3			ld de, scratch 
5487 ed b0			ldir 
5489			 
5489			 
5489 21 75 e3			ld hl, scratch 
548c cd 59 1b			call forthparse 
548f cd 99 1b			call forthexec 
5492 cd b0 1a			call forthexec_cleanup 
5495			 
5495 3e 78			ld a, display_row_4 
5497 11 34 16			ld de, endprog 
549a			 
549a cd 62 09			call update_display		 
549d			 
549d 3a 9b e7			ld a, (os_last_cmd) 
54a0 fe 00			cp 0 
54a2 20 09			jr nz, .startnxt 
54a4 cd 92 18			call next_page_prompt 
54a7 cd 3f 09		        call clear_display 
54aa cd 62 09			call update_display		 
54ad			 
54ad				; move onto next startup line? 
54ad			.startnxt: 
54ad			 
54ad cd d6 08			call delay250ms 
54b0 e1				pop hl 
54b1			 
54b1 23				inc hl 
54b2 23				inc hl 
54b3			 
54b3 e5				push hl 
54b4 5e				ld e, (hl) 
54b5 23				inc hl 
54b6 56				ld d, (hl) 
54b7 e1				pop hl 
54b8				; TODO replace 0 test 
54b8			 
54b8 eb				ex de, hl 
54b9 cd 91 0b			call ishlzero 
54bc			;	ld a,e 
54bc			;	add d 
54bc			;	cp 0    ; any left to do? 
54bc eb				ex de, hl 
54bd c2 22 54			jp nz, .start1 
54c0 18 01			jr .startupend 
54c2			 
54c2 e1			.startupend1: pop hl 
54c3			.startupend: 
54c3			 
54c3 cd 3f 09			call clear_display 
54c6 cd 62 09			call update_display 
54c9 c9				ret 
54ca			 
54ca			 
54ca			; stack over and underflow checks 
54ca			 
54ca			; init the words to detect the under/overflow 
54ca			 
54ca			chk_stk_init: 
54ca				; a vague random number to check so we dont get any "lucky" hits 
54ca 3e 2d			ld a, 45 
54cc 6f				ld l, a 
54cd 00				nop 
54ce 3e 17			ld a, 23 
54d0 67				ld h, a 
54d1			 
54d1 22 6a e3			ld (chk_word), hl     ; the word we need to check against 
54d4			 
54d4			;	ld (chk_stund), hl	; stack points.... 
54d4 22 00 ef			ld (chk_stovr), hl 
54d7 22 20 eb			ld (chk_ret_und), hl 
54da 22 de ea			ld (chk_ret_ovr), hl 
54dd 22 dc e9			ld (chk_loop_ovr), hl 
54e0 22 da e8			ld (chk_data_ovr), hl 
54e3 c9				ret 
54e4				 
54e4			check_stacks: 
54e4				; check all stack words 
54e4			 
54e4 e5				push hl 
54e5 d5				push de 
54e6			 
54e6			;	ld de,(chk_word) 
54e6			;	ld hl, (chk_stund)	; stack points.... 
54e6			;	if DEBUG_STK_FAULT 
54e6			;		DMARK "FAa" 
54e6			;		CALLMONITOR 
54e6			;	endif 
54e6			;	call cmp16 
54e6			;	jp z, .chk_faulta 
54e6			; 
54e6			;	ld de, sfaultsu 
54e6			;	jp .chk_fault 
54e6			 
54e6 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
54e9 ed 5b 6a e3		ld de,(chk_word) 
54ed				if DEBUG_STK_FAULT 
54ed					DMARK "FAb" 
54ed					CALLMONITOR 
54ed				endif 
54ed cd 86 0b			call cmp16 
54f0 28 06			jr z, .chk_fault1 
54f2 11 93 55			ld de, sfaultso 
54f5 c3 47 55			jp .chk_fault 
54f8			.chk_fault1:  
54f8 2a 20 eb			ld hl, (chk_ret_und) 
54fb ed 5b 6a e3		ld de,(chk_word) 
54ff				if DEBUG_STK_FAULT 
54ff					DMARK "FAU" 
54ff					CALLMONITOR 
54ff				endif 
54ff cd 86 0b			call cmp16 
5502 ca 0b 55			jp z, .chk_fault2 
5505 11 a3 55			ld de, sfaultru 
5508 c3 47 55			jp .chk_fault 
550b			.chk_fault2:  
550b 2a de ea			ld hl, (chk_ret_ovr) 
550e ed 5b 6a e3		ld de,(chk_word) 
5512				if DEBUG_STK_FAULT 
5512					DMARK "FA1" 
5512					CALLMONITOR 
5512				endif 
5512 cd 86 0b			call cmp16 
5515 ca 1e 55			jp z, .chk_fault3 
5518 11 b1 55			ld de, sfaultro 
551b c3 47 55			jp .chk_fault 
551e			.chk_fault3:  
551e 2a dc e9			ld hl, (chk_loop_ovr) 
5521 ed 5b 6a e3		ld de,(chk_word) 
5525				if DEBUG_STK_FAULT 
5525					DMARK "FA2" 
5525					CALLMONITOR 
5525				endif 
5525 cd 86 0b			call cmp16 
5528 ca 31 55			jp z, .chk_fault4 
552b 11 cb 55			ld de, sfaultlo 
552e c3 47 55			jp .chk_fault 
5531			.chk_fault4:  
5531 2a da e8			ld hl, (chk_data_ovr) 
5534 ed 5b 6a e3		ld de,(chk_word) 
5538				if DEBUG_STK_FAULT 
5538					DMARK "FA3" 
5538					CALLMONITOR 
5538				endif 
5538 cd 86 0b			call cmp16 
553b ca 44 55			jp z, .chk_fault5 
553e 11 e5 55			ld de, sfaultdo 
5541 c3 47 55			jp .chk_fault 
5544			 
5544			 
5544			.chk_fault5:  
5544 d1				pop de 
5545 e1				pop hl 
5546			 
5546 c9				ret 
5547			 
5547 cd 3f 09		.chk_fault: 	call clear_display 
554a 3e 28				ld a, display_row_2 
554c cd 52 09				call str_at_display 
554f 11 75 55				   ld de, .stackfault 
5552 3e 00				ld a, display_row_1 
5554 cd 52 09				call str_at_display 
5557 11 7a ee				    ld de, debug_mark 
555a 3e 11				ld a, display_row_1+17 
555c cd 52 09				call str_at_display 
555f cd 62 09				call update_display 
5562			 
5562				; prompt before entering montior for investigating issue 
5562			 
5562 3e 78			ld a, display_row_4 
5564 11 34 16			ld de, endprog 
5567			 
5567 cd 62 09			call update_display		 
556a			 
556a cd 92 18			call next_page_prompt 
556d			 
556d d1				pop de 
556e e1				pop hl 
556f cd 88 16				call monitor 
5572 c3 75 15				jp warmstart 
5575					;jp 0 
5575					;halt 
5575			 
5575			 
5575			 
5575 .. 00		.stackfault: 	db "Stack fault:",0 
5582			 
5582 .. 00		sfaultsu: 	db	"Stack under flow",0 
5593 .. 00		sfaultso: 	db	"Stack over flow",0 
55a3 .. 00		sfaultru:	db "RTS underflow",0 
55b1 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
55cb .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
55e5 .. 00		sfaultdo:	db "DTS overflow", 0 
55f2			 
55f2			 
55f2			fault_dsp_under: 
55f2 11 04 56			ld de, .dsp_under 
55f5 c3 b4 56			jp .show_fault 
55f8			 
55f8			fault_rsp_under: 
55f8 11 12 56			ld de, .rsp_under 
55fb c3 b4 56			jp .show_fault 
55fe			fault_loop_under: 
55fe 11 20 56			ld de, .loop_under 
5601 c3 b4 56			jp .show_fault 
5604			 
5604 .. 00		.dsp_under: db "DSP Underflow",0 
5612 .. 00		.rsp_under: db "RSP Underflow",0 
5620 .. 00		.loop_under: db "LOOP Underflow",0 
562f			 
562f			 
562f d5			type_faultn: 	push de 
5630 e5					push hl 
5631 cd 3f 09				call clear_display 
5634 11 5b 56				   ld de, .typefaultn 
5637 3e 00				ld a, display_row_1 
5639 cd 52 09				call str_at_display 
563c 11 7a ee				    ld de, debug_mark 
563f 3e 11				ld a, display_row_1+17 
5641 cd 52 09				call str_at_display 
5644 cd 62 09				call update_display 
5647			 
5647				; prompt before entering montior for investigating issue 
5647			 
5647 3e 78			ld a, display_row_4 
5649 11 34 16			ld de, endprog 
564c			 
564c cd 62 09			call update_display		 
564f			 
564f cd 92 18			call next_page_prompt 
5652			 
5652 e5					push hl 
5653 d5					push de 
5654 cd 88 16				call monitor 
5657 c3 75 15				jp warmstart 
565a 76					halt 
565b			 
565b			 
565b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5672			 
5672 d5			type_faults: 	push de 
5673 e5					push hl 
5674 cd 3f 09				call clear_display 
5677 11 9d 56				   ld de, .typefaults 
567a 3e 00				ld a, display_row_1 
567c cd 52 09				call str_at_display 
567f 11 7a ee				    ld de, debug_mark 
5682 3e 11				ld a, display_row_1+17 
5684 cd 52 09				call str_at_display 
5687 cd 62 09				call update_display 
568a			 
568a				; prompt before entering montior for investigating issue 
568a			 
568a 3e 78			ld a, display_row_4 
568c 11 34 16			ld de, endprog 
568f			 
568f cd 62 09			call update_display		 
5692			 
5692 cd 92 18			call next_page_prompt 
5695			 
5695 e1					pop hl 
5696 d1					pop de 
5697 cd 88 16				call monitor 
569a c3 75 15				jp warmstart 
569d			 
569d			 
569d .. 00		.typefaults: db "STR Type Expected TOS!",0 
56b4			 
56b4			.show_fault: 	 
56b4 d5					push de 
56b5 cd 3f 09				call clear_display 
56b8 d1					pop de 
56b9 3e 00				ld a, display_row_1 
56bb cd 52 09				call str_at_display 
56be 11 7a ee				    ld de, debug_mark 
56c1 3e 11				ld a, display_row_1+17 
56c3 cd 52 09				call str_at_display 
56c6 cd 62 09				call update_display 
56c9			 
56c9				; prompt before entering montior for investigating issue 
56c9			 
56c9 3e 78			ld a, display_row_4 
56cb 11 34 16			ld de, endprog 
56ce			 
56ce cd 62 09			call update_display		 
56d1			 
56d1 cd 92 18			call next_page_prompt 
56d4			 
56d4 e1					pop hl 
56d5 d1					pop de 
56d6 cd 88 16				call monitor 
56d9			; do a dump to cli and not warmstart so we preserve all of the uwords.  
56d9			; TODO Make optional fault restart to cli or warm boot? 
56d9					;jp warmstart 
56d9 c3 cd 15				jp cli 
56dc 76					halt 
56dd			; eof 
# End of file forth_kernel.asm
56dd			;include "nascombasic.asm" 
56dd			 
56dd			 
56dd			; find out where the code ends if loaded into RAM (for SC114) 
56dd			;endofcode:  
56dd			;	nop 
56dd			 
56dd			 
56dd			; eof 
56dd			 
# End of file main.asm
56dd			;include "firmware_lcd_4x40.asm" 
56dd			;;include "firmware_lcd_4x20.asm" 
56dd			include "firmware_cpm_display.asm" 
56dd			 
56dd			; Serial display interface for SC114 
56dd			 
56dd			 
56dd			display_row_1: equ 0 
56dd			display_row_2: equ display_row_1+display_cols 
56dd			display_row_3: equ display_row_2 + display_cols 
56dd			display_row_4: equ display_row_3 + display_cols 
56dd			 
56dd			kLCDWidth:  EQU display_cols             ;Width in characters 
56dd			kLCD_Line1: EQU 0x00  
56dd			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
56dd			; E1 
56dd			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
56dd			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
56dd			 
56dd			lcd_init: 
56dd				; no init as handled by the SCM bios 
56dd c9				ret 
56de			 
56de			 
56de			; low level functions for direct screen writes 
56de			 
56de			; output char at pos? 
56de			fLCD_Str: 
56de			        ;out (SC114_SIO_1_OUT),a 
56de c5				push bc 
56df d5				push de 
56e0 5f				ld e, a 
56e1			; TODO Replace with CP/M BIOS call 
56e1 0e 02			ld c, $02 
56e3 cd 05 00			call 5 
56e6 d1				pop de 
56e7 c1				pop bc 
56e8 c9				ret 
56e9			 
56e9			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
56e9			fLCD_Pos: 
56e9				; use ASCII escape to position 
56e9			        ;out (SC114_SIO_1_OUT),a 
56e9 c5				push bc 
56ea d5				push de 
56eb 5f				ld e, a 
56ec 0e 02			ld c, $02 
56ee			; TODO Replace with CP/M BIOS call 
56ee cd 05 00			call 5 
56f1 d1				pop de 
56f2 c1				pop bc 
56f3			 
56f3 c9				ret 
56f4			 
56f4			; output char at pos 
56f4			fLCD_Data: 
56f4			      ;  out (SC114_SIO_1_OUT),a 
56f4 c5				push bc 
56f5 d5				push de 
56f6 0e 02			ld c, $02 
56f8 5f				ld e, a 
56f9			; TODO Replace with CP/M BIOS call 
56f9 cd 05 00			call 5 
56fc d1				pop de 
56fd c1				pop bc 
56fe			 
56fe c9				ret 
56ff			 
56ff			; ascii cls  
56ff			 
56ff 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5703			 
5703 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
571a			;.clscpm: db 3, $3c,"$" 
571a			 
571a			; write the frame buffer given in hl to hardware  
571a			write_display: 
571a			 
571a			API: equ 0 
571a			 
571a			if API 
571a				push bc 
571a				ld b, 4 
571a			 
571a			        ld (display_write_tmp), hl 	  
571a			 
571a				; clear and home cursor 
571a			 
571a				ld c, 9 
571a				ld de, .cls 
571a			; TODO Replace with CP/M BIOS call 
571a				call 5 
571a			 
571a			 
571a			.writeln: 
571a			 
571a				ld de, (display_write_tmp) 
571a				ld c, 6 
571a			; TODO Replace with CP/M BIOS call 
571a				rst $30 
571a				ld c, 7 
571a				rst $30 
571a			 
571a				ld hl, (display_write_tmp) 
571a				ld de, display_cols 
571a				add hl,de 
571a				ld (display_write_tmp),hl 
571a			 
571a				djnz  .writeln 
571a			 
571a				pop bc 
571a			 
571a			 
571a				ret 
571a			endif 
571a e5				push hl 
571b c5				push bc 
571c d5				push de 
571d			 
571d			;	ld c, 2 
571d			;	;ld de, .cls 
571d			;	ld a, 27 
571d			;	rst $30 
571d			;	ld c, 2 
571d			;	;ld de, .cls 
571d			;	ld a, '[' 
571d			;	rst $30 
571d			; 
571d			;	ld c, 2 
571d			;	;ld de, .cls 
571d			;	ld a, 'H' 
571d			;	rst $30 
571d			; 
571d			 
571d			 
571d			; lots of CR/LF 
571d			;	ld c, 9 
571d			;	ld de, .clscpm 
571d			;	call 5 
571d			 
571d			; xterm cls 
571d 0e 02			ld c, 2 
571f 1e 1b			ld e, 27 
5721 cd 05 00			call 5 
5724			; cls causes too much flicker 
5724			;	ld c, 2 
5724			;	ld e, 'c' 
5724			;	call 5 
5724			 
5724			; use xterm home instead 
5724 0e 02			ld c, 2 
5726 1e 5b			ld e, '[' 
5728 cd 05 00			call 5 
572b 0e 02			ld c, 2 
572d 1e 48			ld e, 'H' 
572f cd 05 00			call 5 
5732			LLL: equ 0 
5732			 
5732			if LLL 
5732			 
5732				ld c, 2 
5732				;ld de, .cls 
5732				ld e, 27 
5732			; TODO Replace with CP/M BIOS call 
5732				call 5 
5732			 
5732			 
5732				ld c, 2 
5732				;ld de, .cls 
5732				ld e, '[' 
5732			; TODO Replace with CP/M BIOS call 
5732				call 5 
5732				ld c, 2 
5732				;ld de, .cls 
5732				ld e, '2' 
5732			; TODO Replace with CP/M BIOS call 
5732				call 5 
5732				ld c, 2 
5732				;ld de, .cls 
5732				ld e, 'J' 
5732			; TODO Replace with CP/M BIOS call 
5732				call 5 
5732			 
5732			endif 
5732			 
5732 d1				pop de 
5733 c1				pop bc 
5734 e1				pop hl 
5735			 
5735			 
5735 22 d8 eb		        ld (display_write_tmp), hl 	  
5738 3e 00			ld a, kLCD_Line1 
573a			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
573a 06 28			ld b, display_cols 
573c ed 5b d8 eb		ld de, (display_write_tmp) 
5740 cd c3 57			call write_len_string 
5743				 
5743			 
5743 e5			push hl 
5744 d5			push de 
5745 c5			push bc 
5746 0e 02			ld c, 2 
5748 1e 0a			ld e, 10 
574a cd 05 00			call 5 
574d 0e 02			ld c, 2 
574f 1e 0d			ld e, 13 
5751 cd 05 00			call 5 
5754			; TODO Replace with CP/M BIOS call 
5754				;rst $30 
5754 c1			pop bc 
5755 d1			pop de 
5756 e1			pop hl 
5757			 
5757				 
5757 2a d8 eb			ld hl, (display_write_tmp) 
575a 11 28 00			ld de, display_cols 
575d 19				add hl,de 
575e 22 d8 eb			ld (display_write_tmp),hl 
5761			 
5761				 
5761 3e 28			ld a, kLCD_Line2 
5763			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5763 06 28			ld b, display_cols 
5765 ed 5b d8 eb		ld de, (display_write_tmp) 
5769 cd c3 57			call write_len_string 
576c				 
576c 2a d8 eb			ld hl, (display_write_tmp) 
576f 11 28 00			ld de, display_cols 
5772 19				add hl,de 
5773 22 d8 eb			ld (display_write_tmp),hl 
5776			 
5776 e5			push hl 
5777 d5			push de 
5778 c5			push bc 
5779 0e 07			ld c, 7 
577b			; TODO Replace with CP/M BIOS call 
577b				;rst $30 
577b 0e 02			ld c, 2 
577d 1e 0a			ld e, 10 
577f cd 05 00			call 5 
5782 0e 02			ld c, 2 
5784 1e 0d			ld e, 13 
5786 cd 05 00			call 5 
5789 c1			pop bc 
578a d1			pop de 
578b e1			pop hl 
578c			 
578c				 
578c 3e 50			ld a, kLCD_Line3 
578e			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
578e 06 28			ld b, display_cols 
5790 ed 5b d8 eb		ld de, (display_write_tmp) 
5794 cd c3 57			call write_len_string 
5797				 
5797 2a d8 eb			ld hl, (display_write_tmp) 
579a 11 28 00			ld de, display_cols 
579d 19				add hl,de 
579e 22 d8 eb			ld (display_write_tmp),hl 
57a1			 
57a1 e5			push hl 
57a2 d5			push de 
57a3 c5			push bc 
57a4 0e 07			ld c, 7 
57a6			; TODO Replace with CP/M BIOS call 
57a6				;rst $30 
57a6 0e 02			ld c, 2 
57a8 1e 0a			ld e, 10 
57aa cd 05 00			call 5 
57ad 0e 02			ld c, 2 
57af 1e 0d			ld e, 13 
57b1 cd 05 00			call 5 
57b4 c1			pop bc 
57b5 d1			pop de 
57b6 e1			pop hl 
57b7			 
57b7				 
57b7 3e 78			ld a, kLCD_Line4 
57b9			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
57b9 06 28			ld b, display_cols 
57bb ed 5b d8 eb		ld de, (display_write_tmp) 
57bf cd c3 57			call write_len_string 
57c2 c9					ret 
57c3			 
57c3			 
57c3				; write out a fixed length string given in b from de 
57c3			 
57c3 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
57c4 cd f4 56		            CALL fLCD_Data      ;Write character to display 
57c7 13				inc de 
57c8 10 f9			djnz write_len_string 
57ca c9				ret 
57cb			 
57cb			 
57cb			; eof 
# End of file firmware_cpm_display.asm
57cb			;include "firmware_key_5x10.asm" 
57cb			;;include "firmware_key_4x10.asm" 
57cb			include "firmware_key_cpm.asm" 
57cb			; Serial keyboard interface for SC114 
57cb			 
57cb			 
57cb			key_init: 
57cb				; no init as handled by the SCM bios 
57cb c9				ret 
57cc			 
57cc			 
57cc			cin_wait: 
57cc			;	ld a, 0 
57cc			;	ret 
57cc			 
57cc				;in a,(SC114_SIO_1_IN) 
57cc			        ; Use SCM API to get from whatever console device we are using 
57cc			 
57cc			; TODO Replace with CP/M BIOS call 
57cc c5				push bc 
57cd 0e 01			ld c, $01 
57cf cd 05 00			call 5 
57d2 c1				pop bc 
57d3 c9				ret 
57d4			 
57d4			cin: 
57d4			 
57d4			 
57d4 c5				push bc 
57d5			 
57d5				; any key waiting to process? 
57d5			; TODO Replace with CP/M BIOS call 
57d5 0e 06			ld c, $06 
57d7 cd 05 00			call 5 
57da 28 0d			jr z, .cin_skip 
57dc			 
57dc				; yep, get it 
57dc			 
57dc 0e 01			ld c, $01 
57de			; TODO Replace with CP/M BIOS call 
57de cd 05 00			call 5 
57e1			 
57e1 fe 7f			cp $7f     ; back space 
57e3 20 02			jr nz, .skipbs 
57e5 3e 08			ld a, KEY_BS 
57e7			.skipbs: 
57e7			 
57e7 c1				pop bc 
57e8 c9				ret 
57e9			.cin_skip: 
57e9 3e 00			ld a, 0 
57eb c1				pop bc 
57ec c9				ret 
57ed			 
57ed			 
57ed			 
57ed			 
# End of file firmware_key_cpm.asm
57ed			endofcode:  
57ed			baseram:  
57ed 00				nop 
57ee			 
57ee			heap_start: equ baseram+15  ; Starting address of heap 
57ee			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
57ee			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
57ee			;VDU:  EQU     endofcode           ; BASIC Work space 
57ee			; eof 
57ee			 
# End of file os_mega_cpm.asm
57ee
