# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 19 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 1  
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 0  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c				call break_point_state  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			debug_mark: equ hardware_word - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_write_tmp-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_view_disable - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c				ld a, ' ' 
011c				ld (os_view_disable), a 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 16 ed				ld hl, display_fb1  
011f 22 d2 eb				ld (display_fb_active), hl  
0122			  
0122 cd 48 0b				call clear_display  
0125			  
0125 21 d4 eb				ld hl, display_fb2  
0128 22 d2 eb				ld (display_fb_active), hl  
012b			  
012b cd 48 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b7 ed				ld hl, display_fb0  
0131 22 d2 eb				ld (display_fb_active), hl  
0134			  
0134 cd 48 0b				call clear_display  
0137			  
0137			  
0137 cd a6 5a				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 94 5b			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 18 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd 6b 0b			call update_display  
0146 cd ba 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd 4d 0b			call fill_display  
014e cd 6b 0b			call update_display  
0151 cd ba 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd 4d 0b			call fill_display  
0159 cd 6b 0b			call update_display  
015c cd ba 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd 4d 0b			call fill_display  
0164 cd 6b 0b			call update_display  
0167 cd ba 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 4c 17			ld de, prom_bootmsg  
016f cd 5b 0b			call str_at_display  
0172 cd 6b 0b			call update_display  
0175			  
0175			  
0175 cd ba 0a			call delay1s  
0178 cd ba 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 61 17			ld de, prom_bootmsg1  
0180 cd 5b 0b			call str_at_display  
0183 cd 6b 0b			call update_display  
0186 cd ba 0a			call delay1s  
0189 cd ba 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 71 ee		ld (debug_mark),a  
0191 32 72 ee		ld (debug_mark+1),a  
0194 32 73 ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 74 ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 7d ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 71 ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 72 ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 73 ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd 76 15			call break_point_state  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 84 ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 71 ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 72 ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 73 ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd 76 15			call break_point_state  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 84 ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 71 ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 72 ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 73 ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd 76 15			call break_point_state  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd 9e 0d				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 7d ea				ld hl, (store_tmp1) 
0210 11 87 ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 71 ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 72 ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 73 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd 76 15			call break_point_state  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 0b 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 71 ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 72 ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 73 ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd 76 15			call break_point_state  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 71 ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 72 ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 73 ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd 76 15			call break_point_state  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 71 ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 72 ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 73 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd 76 15			call break_point_state  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 71 ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 72 ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 73 ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd 76 15			call break_point_state  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd 9e 0d			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 84 ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 71 ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 72 ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 73 ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd 76 15			call break_point_state  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 71 ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 72 ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 73 ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd 76 15			call break_point_state  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 84 ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 71 ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 72 ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 73 ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 84 ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd 76 15			call break_point_state  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 85 ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 71 ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 72 ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 73 ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd 76 15			call break_point_state  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 71 ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 72 ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 73 ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd 76 15			call break_point_state  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd 7d 0a			call storage_clear_page 
039b			 
039b 21 84 ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 85 ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 87 ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 90 ea			ld hl, store_page+3+9 
03b5 3a 6c ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 84 ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 71 ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 72 ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 73 ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd 76 15			call break_point_state  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 71 ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 72 ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 73 ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd 76 15			call break_point_state  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd 9f 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd 9f 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd 75 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd 9f 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd 9f 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd 75 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 71 ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 72 ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 73 ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd 76 15			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 87 ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 71 ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 72 ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 73 ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd 76 15			call break_point_state  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 84 ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 71 ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 72 ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 73 ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd 76 15			call break_point_state  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 71 ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 72 ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 73 ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd 76 15			call break_point_state  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd 9e 0d			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 84 ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd 9e 0d			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 71 ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 72 ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 73 ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd 76 15			call break_point_state  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 84 ea			ld a, (store_page)	; get file id 
0510 32 78 ea			ld (store_tmpid), a 
0513			 
0513 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
0516 32 77 ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 84 ea			ld (store_page), a 
051f 32 85 ea			ld (store_page+1),a 
0522 11 84 ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 71 ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 72 ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 73 ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd 76 15			call break_point_state  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 77 ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 78 ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 71 ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 72 ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 73 ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd 76 15			call break_point_state  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd 9e 0d			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 84 ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 84 ea			ld (store_page), a 
0582 32 85 ea			ld (store_page+1),a 
0585 11 84 ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 71 ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 72 ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 73 ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd 76 15			call break_point_state  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 71 ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 72 ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 73 ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd 76 15			call break_point_state  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd 93 0d				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd 75 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd 93 0d				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd 75 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 71 ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 72 ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 73 ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd 76 15			call break_point_state  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 71 ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 72 ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 73 ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd 76 15			call break_point_state  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd 75 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd 75 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 71 ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 72 ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 73 ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd 76 15			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 84 ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 84 ea			ld (store_page),a 
06a3				 
06a3 32 78 ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 84 ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 71 ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 72 ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 73 ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd 76 15			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 84 ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 71 ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 72 ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 73 ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 76 15			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 71 ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 71 ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 72 ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 73 ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd 76 15			call break_point_state  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 71 ea			ld (store_tmppageid), hl 
0715				 
0715 3a 78 ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 84 ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 85 ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 86 ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 71 ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 72 ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 73 ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd 76 15			call break_point_state  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd de 11			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 71 ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 72 ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 73 ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd 76 15			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 71 ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 72 ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 73 ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 76 15			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 71 ea			ld hl,(store_tmppageid) 
078b 11 84 ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 71 ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 72 ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 73 ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd 76 15			call break_point_state  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 78 ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 71 ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 72 ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 73 ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd 76 15			call break_point_state  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 71 ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 72 ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 73 ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd 76 15			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 71 ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 72 ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 73 ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd 76 15			call break_point_state  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd 9e 0d			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; hl contains page number to load 
081f d1				pop de   ; get storage 
0820 d5				push de 
0821				if DEBUG_STORESE 
0821					DMARK "srg" 
0821 f5				push af  
0822 3a 36 08			ld a, (.dmark)  
0825 32 71 ee			ld (debug_mark),a  
0828 3a 37 08			ld a, (.dmark+1)  
082b 32 72 ee			ld (debug_mark+1),a  
082e 3a 38 08			ld a, (.dmark+2)  
0831 32 73 ee			ld (debug_mark+2),a  
0834 18 03			jr .pastdmark  
0836 ..			.dmark: db "srg"  
0839 f1			.pastdmark: pop af  
083a			endm  
# End of macro DMARK
083a					CALLMONITOR 
083a cd 76 15			call break_point_state  
083d				endm  
# End of macro CALLMONITOR
083d				endif 
083d cd 79 02			call storage_read_block 
0840			 
0840			 
0840				; only short reads enabled 
0840			 
0840 3a 7f ea			ld a, (store_longread) 
0843 fe 00			cp 0 
0845 ca 0f 09			jp z, .readdone 
0848			 
0848			; TODO if block has no zeros then need to read next block  
0848			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0848			; check last byte of physical block. 
0848			; if not zero then the next block needs to be loaded 
0848			 
0848			 
0848 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084b			 
084b 3e 3f			ld a, STORE_BLOCK_PHY-1 
084d cd 75 0d			call addatohl 
0850				;dec hl 
0850 7e				ld a,(hl) 
0851				if DEBUG_STORESE 
0851					DMARK "sr?" 
0851 f5				push af  
0852 3a 66 08			ld a, (.dmark)  
0855 32 71 ee			ld (debug_mark),a  
0858 3a 67 08			ld a, (.dmark+1)  
085b 32 72 ee			ld (debug_mark+1),a  
085e 3a 68 08			ld a, (.dmark+2)  
0861 32 73 ee			ld (debug_mark+2),a  
0864 18 03			jr .pastdmark  
0866 ..			.dmark: db "sr?"  
0869 f1			.pastdmark: pop af  
086a			endm  
# End of macro DMARK
086a					CALLMONITOR 
086a cd 76 15			call break_point_state  
086d				endm  
# End of macro CALLMONITOR
086d				endif 
086d fe 00			cp 0 
086f ca 0f 09			jp z, .readdone 
0872			 
0872				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0872			 
0872 23				inc hl 
0873			 
0873 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
0876			 
0876 ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
087a			 
087a eb				ex de, hl 
087b			 
087b				; next ext 
087b			 
087b 23				inc hl 
087c 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
087f			 
087f				if DEBUG_STORESE 
087f					DMARK "sF2" 
087f f5				push af  
0880 3a 94 08			ld a, (.dmark)  
0883 32 71 ee			ld (debug_mark),a  
0886 3a 95 08			ld a, (.dmark+1)  
0889 32 72 ee			ld (debug_mark+1),a  
088c 3a 96 08			ld a, (.dmark+2)  
088f 32 73 ee			ld (debug_mark+2),a  
0892 18 03			jr .pastdmark  
0894 ..			.dmark: db "sF2"  
0897 f1			.pastdmark: pop af  
0898			endm  
# End of macro DMARK
0898					CALLMONITOR 
0898 cd 76 15			call break_point_state  
089b				endm  
# End of macro CALLMONITOR
089b				endif 
089b			 
089b				; get and load block 
089b			 
089b cd ac 05			call storage_findnextid 
089e			 
089e				if DEBUG_STORESE 
089e					DMARK "sf2" 
089e f5				push af  
089f 3a b3 08			ld a, (.dmark)  
08a2 32 71 ee			ld (debug_mark),a  
08a5 3a b4 08			ld a, (.dmark+1)  
08a8 32 72 ee			ld (debug_mark+1),a  
08ab 3a b5 08			ld a, (.dmark+2)  
08ae 32 73 ee			ld (debug_mark+2),a  
08b1 18 03			jr .pastdmark  
08b3 ..			.dmark: db "sf2"  
08b6 f1			.pastdmark: pop af  
08b7			endm  
# End of macro DMARK
08b7					CALLMONITOR 
08b7 cd 76 15			call break_point_state  
08ba				endm  
# End of macro CALLMONITOR
08ba				endif 
08ba cd 9e 0d			call ishlzero 
08bd			;	ld a, l 
08bd			;	add h 
08bd			;	cp 0 
08bd ca d0 07			jp z,.sr_fail			; block not found so EOF 
08c0				 
08c0 cd 79 02			call storage_read_block 
08c3			 
08c3				; on a continuation block, we now have the file id and ext in the middle of the block 
08c3				; we need to pull everything back  
08c3			 
08c3 ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08c7 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
08ca 23				inc hl 
08cb 23				inc hl     ; skip id and ext 
08cc 01 40 00			ld bc, STORE_BLOCK_PHY 
08cf				if DEBUG_STORESE 
08cf					DMARK "SR<" 
08cf f5				push af  
08d0 3a e4 08			ld a, (.dmark)  
08d3 32 71 ee			ld (debug_mark),a  
08d6 3a e5 08			ld a, (.dmark+1)  
08d9 32 72 ee			ld (debug_mark+1),a  
08dc 3a e6 08			ld a, (.dmark+2)  
08df 32 73 ee			ld (debug_mark+2),a  
08e2 18 03			jr .pastdmark  
08e4 ..			.dmark: db "SR<"  
08e7 f1			.pastdmark: pop af  
08e8			endm  
# End of macro DMARK
08e8					CALLMONITOR 
08e8 cd 76 15			call break_point_state  
08eb				endm  
# End of macro CALLMONITOR
08eb				endif 
08eb ed b0			ldir     ; copy data 
08ed			 
08ed				; move the pointer back and pretend we have a full buffer for next recheck 
08ed			 
08ed 1b				dec de 
08ee 1b				dec de 
08ef			 
08ef			; TODO do pop below now short circuit loop????? 
08ef c1				pop bc     ; get rid of spare de on stack 
08f0				if DEBUG_STORESE 
08f0					DMARK "SR>" 
08f0 f5				push af  
08f1 3a 05 09			ld a, (.dmark)  
08f4 32 71 ee			ld (debug_mark),a  
08f7 3a 06 09			ld a, (.dmark+1)  
08fa 32 72 ee			ld (debug_mark+1),a  
08fd 3a 07 09			ld a, (.dmark+2)  
0900 32 73 ee			ld (debug_mark+2),a  
0903 18 03			jr .pastdmark  
0905 ..			.dmark: db "SR>"  
0908 f1			.pastdmark: pop af  
0909			endm  
# End of macro DMARK
0909					CALLMONITOR 
0909 cd 76 15			call break_point_state  
090c				endm  
# End of macro CALLMONITOR
090c				endif 
090c c3 d5 07			jp .srext 
090f			 
090f			 
090f			 
090f			 
090f			 
090f			.readdone:		 
090f e1				pop hl 		 ; return start of data to show as not EOF 
0910 23				inc hl   ; past file id 
0911 23				inc hl   ; past ext 
0912				if DEBUG_STORESE 
0912					DMARK "SRe" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 71 ee			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 72 ee			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 73 ee			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SRe"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd 76 15			call break_point_state  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e c9					ret 
092f			 
092f			 
092f			 
092f			; 
092f			; Append File 
092f			; 
092f			; hl - file id to locate 
092f			; de - pointer to (multi block) string to write 
092f			 
092f			.sa_notfound: 
092f d1				pop de 
0930 c9				ret 
0931			 
0931			 
0931			storage_append: 
0931				; hl -  file id to append to 
0931				; de - string to append 
0931			 
0931 d5				push de 
0932				 
0932				if DEBUG_STORESE 
0932					DMARK "AP1" 
0932 f5				push af  
0933 3a 47 09			ld a, (.dmark)  
0936 32 71 ee			ld (debug_mark),a  
0939 3a 48 09			ld a, (.dmark+1)  
093c 32 72 ee			ld (debug_mark+1),a  
093f 3a 49 09			ld a, (.dmark+2)  
0942 32 73 ee			ld (debug_mark+2),a  
0945 18 03			jr .pastdmark  
0947 ..			.dmark: db "AP1"  
094a f1			.pastdmark: pop af  
094b			endm  
# End of macro DMARK
094b					CALLMONITOR 
094b cd 76 15			call break_point_state  
094e				endm  
# End of macro CALLMONITOR
094e				endif 
094e			 
094e 7d				ld a, l 
094f 32 78 ea			ld (store_tmpid), a 
0952			 
0952				; get file header  
0952			 
0952 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0954 3a 78 ea			ld a, (store_tmpid) 
0957 5f				ld e, a 
0958			 
0958 21 40 00				ld hl, STORE_BLOCK_PHY 
095b cd ac 05				call storage_findnextid 
095e			 
095e cd 9e 0d			call ishlzero 
0961 28 cc			jr z, .sa_notfound 
0963			 
0963 22 71 ea			ld (store_tmppageid), hl 
0966			 
0966				; TODO handle file id not found 
0966			 
0966				if DEBUG_STORESE 
0966					DMARK "AP2" 
0966 f5				push af  
0967 3a 7b 09			ld a, (.dmark)  
096a 32 71 ee			ld (debug_mark),a  
096d 3a 7c 09			ld a, (.dmark+1)  
0970 32 72 ee			ld (debug_mark+1),a  
0973 3a 7d 09			ld a, (.dmark+2)  
0976 32 73 ee			ld (debug_mark+2),a  
0979 18 03			jr .pastdmark  
097b ..			.dmark: db "AP2"  
097e f1			.pastdmark: pop af  
097f			endm  
# End of macro DMARK
097f					CALLMONITOR 
097f cd 76 15			call break_point_state  
0982				endm  
# End of macro CALLMONITOR
0982				endif 
0982			 
0982				; update file extent count 
0982			 
0982 11 84 ea			ld de, store_page 
0985			 
0985 cd 79 02			call storage_read_block 
0988			 
0988				if DEBUG_STORESE 
0988					DMARK "AP3" 
0988 f5				push af  
0989 3a 9d 09			ld a, (.dmark)  
098c 32 71 ee			ld (debug_mark),a  
098f 3a 9e 09			ld a, (.dmark+1)  
0992 32 72 ee			ld (debug_mark+1),a  
0995 3a 9f 09			ld a, (.dmark+2)  
0998 32 73 ee			ld (debug_mark+2),a  
099b 18 03			jr .pastdmark  
099d ..			.dmark: db "AP3"  
09a0 f1			.pastdmark: pop af  
09a1			endm  
# End of macro DMARK
09a1					CALLMONITOR 
09a1 cd 76 15			call break_point_state  
09a4				endm  
# End of macro CALLMONITOR
09a4				endif 
09a4			;	ld (store_tmppageid), hl 
09a4			 
09a4 3a 86 ea			ld a, (store_page+2) 
09a7 3c				inc a 
09a8 32 86 ea			ld (store_page+2), a 
09ab 32 77 ea			ld (store_tmpext), a 
09ae				 
09ae				if DEBUG_STORESE 
09ae					DMARK "AP3" 
09ae f5				push af  
09af 3a c3 09			ld a, (.dmark)  
09b2 32 71 ee			ld (debug_mark),a  
09b5 3a c4 09			ld a, (.dmark+1)  
09b8 32 72 ee			ld (debug_mark+1),a  
09bb 3a c5 09			ld a, (.dmark+2)  
09be 32 73 ee			ld (debug_mark+2),a  
09c1 18 03			jr .pastdmark  
09c3 ..			.dmark: db "AP3"  
09c6 f1			.pastdmark: pop af  
09c7			endm  
# End of macro DMARK
09c7					CALLMONITOR 
09c7 cd 76 15			call break_point_state  
09ca				endm  
# End of macro CALLMONITOR
09ca				endif 
09ca 2a 71 ea			ld hl, (store_tmppageid) 
09cd 11 84 ea			ld de, store_page 
09d0 cd de 02			call storage_write_block 
09d3			 
09d3				; find free block 
09d3			 
09d3 11 00 00			ld de, 0			 ; file extent to locate 
09d6			 
09d6 21 40 00				ld hl, STORE_BLOCK_PHY 
09d9 cd ac 05				call storage_findnextid 
09dc cd 9e 0d			call ishlzero 
09df ca 2f 09			jp z, .sa_notfound 
09e2			 
09e2					; TODO handle no space left 
09e2					 
09e2 22 71 ea				ld (store_tmppageid), hl 
09e5			 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP4" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 71 ee			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 72 ee			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 73 ee			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP4"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd 76 15			call break_point_state  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01					; init the buffer with zeros so we can id if the buffer is full or not 
0a01			 
0a01 e5					push hl 
0a02 c5					push bc 
0a03			 
0a03 21 84 ea				ld hl, store_page 
0a06 06 40				ld b, STORE_BLOCK_PHY 
0a08 3e 00				ld a, 0 
0a0a 77			.zeroblock:	ld (hl), a 
0a0b 23					inc hl 
0a0c 10 fc				djnz .zeroblock 
0a0e			 
0a0e c1					pop bc 
0a0f e1					pop hl 
0a10			 
0a10					; construct block 
0a10			 
0a10 3a 78 ea				ld a, (store_tmpid) 
0a13 32 84 ea				ld (store_page), a   ; file id 
0a16 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
0a19 32 85 ea				ld (store_page+1), a 
0a1c			 
0a1c e1					pop hl    ; get string to write 
0a1d 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a1f 11 86 ea				ld de, store_page+2 
0a22			 
0a22				if DEBUG_STORESE 
0a22					DMARK "AP5" 
0a22 f5				push af  
0a23 3a 37 0a			ld a, (.dmark)  
0a26 32 71 ee			ld (debug_mark),a  
0a29 3a 38 0a			ld a, (.dmark+1)  
0a2c 32 72 ee			ld (debug_mark+1),a  
0a2f 3a 39 0a			ld a, (.dmark+2)  
0a32 32 73 ee			ld (debug_mark+2),a  
0a35 18 03			jr .pastdmark  
0a37 ..			.dmark: db "AP5"  
0a3a f1			.pastdmark: pop af  
0a3b			endm  
# End of macro DMARK
0a3b					CALLMONITOR 
0a3b cd 76 15			call break_point_state  
0a3e				endm  
# End of macro CALLMONITOR
0a3e				endif 
0a3e			 
0a3e			 
0a3e			 
0a3e					; fill buffer with data until end of string or full block 
0a3e			 
0a3e 7e			.appd:		ld a, (hl) 
0a3f 12					ld (de), a 
0a40 fe 00				cp 0 
0a42 28 04				jr z, .appdone 
0a44 23					inc hl 
0a45 13					inc de 
0a46 10 f6				djnz .appd 
0a48			 
0a48 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a49 f5					push af   		; save last byte dumped 
0a4a			 
0a4a			 
0a4a 2a 71 ea			ld hl, (store_tmppageid) 
0a4d 11 84 ea			ld de, store_page 
0a50				if DEBUG_STORESE 
0a50					DMARK "AP6" 
0a50 f5				push af  
0a51 3a 65 0a			ld a, (.dmark)  
0a54 32 71 ee			ld (debug_mark),a  
0a57 3a 66 0a			ld a, (.dmark+1)  
0a5a 32 72 ee			ld (debug_mark+1),a  
0a5d 3a 67 0a			ld a, (.dmark+2)  
0a60 32 73 ee			ld (debug_mark+2),a  
0a63 18 03			jr .pastdmark  
0a65 ..			.dmark: db "AP6"  
0a68 f1			.pastdmark: pop af  
0a69			endm  
# End of macro DMARK
0a69					CALLMONITOR 
0a69 cd 76 15			call break_point_state  
0a6c				endm  
# End of macro CALLMONITOR
0a6c				endif 
0a6c cd de 02				call storage_write_block 
0a6f			 
0a6f			 
0a6f				; was that a full block of data written? 
0a6f				; any more to write out? 
0a6f			 
0a6f				; if yes then set vars and jump to start of function again 
0a6f			 
0a6f f1					pop af 
0a70 d1					pop de 
0a71			 
0a71 fe 00				cp 0		 ; no, string was fully written 
0a73 c8					ret z 
0a74			 
0a74					; setup vars for next cycle 
0a74			 
0a74 3a 78 ea				ld a, (store_tmpid) 
0a77 6f					ld l, a 
0a78 26 00				ld h, 0 
0a7a			 
0a7a c3 31 09			 	jp storage_append	 ; yes, need to write out some more 
0a7d			 
0a7d			 
0a7d			 
0a7d			 
0a7d			 
0a7d			 
0a7d			 
0a7d			if DEBUG_STORECF 
0a7d			storageput:	 
0a7d					ret 
0a7d			storageread: 
0a7d					ld hl, store_page 
0a7d					ld b, 200 
0a7d					ld a,0 
0a7d			.src:		ld (hl),a 
0a7d					inc hl 
0a7d					djnz .src 
0a7d					 
0a7d			 
0a7d					ld de, 0 
0a7d					ld bc, 1 
0a7d					ld hl, store_page 
0a7d					call cfRead 
0a7d			 
0a7d				call cfGetError 
0a7d				ld hl,scratch 
0a7d				call hexout 
0a7d				ld hl, scratch+2 
0a7d				ld a, 0 
0a7d				ld (hl),a 
0a7d				ld de, scratch 
0a7d				ld a,display_row_1 
0a7d				call str_at_display 
0a7d				call update_display 
0a7d			 
0a7d					ld hl, store_page 
0a7d					ld (os_cur_ptr),hl 
0a7d			 
0a7d					ret 
0a7d			endif 
0a7d			 
0a7d			 
0a7d			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a7d			 
0a7d			storage_clear_page: 
0a7d e5				push hl 
0a7e d5				push de 
0a7f c5				push bc 
0a80 21 84 ea			ld hl, store_page 
0a83 3e 00			ld a, 0 
0a85 77				ld (hl), a 
0a86			 
0a86 11 85 ea			ld de, store_page+1 
0a89 01 18 01			ld bc, STORE_BLOCK_LOG 
0a8c			 
0a8c ed b0			ldir 
0a8e				 
0a8e c1				pop bc 
0a8f d1				pop de 
0a90 e1				pop hl 
0a91 c9				ret 
0a92			 
0a92			; eof 
# End of file firmware_storage.asm
0a92			  
0a92			; support routines for above hardware abstraction layer  
0a92			  
0a92			include "firmware_general.asm"        ; general support functions  
0a92			 
0a92			; word look up 
0a92			 
0a92			; in 
0a92			; a is the index 
0a92			; hl is pointer start of array 
0a92			; 
0a92			; returns 
0a92			; hl to the word 
0a92			; 
0a92			 
0a92			table_lookup:  
0a92 d5					push de 
0a93 eb					ex de, hl 
0a94			 
0a94 6f					ld l, a 
0a95 26 00				ld h, 0 
0a97 29					add hl, hl 
0a98 19					add hl, de 
0a99 7e					ld a, (hl) 
0a9a 23					inc hl 
0a9b 66					ld h,(hl) 
0a9c 6f					ld l, a 
0a9d			 
0a9d d1					pop de 
0a9e c9					ret 
0a9f			 
0a9f			; Delay loops 
0a9f			 
0a9f			 
0a9f			 
0a9f			aDelayInMS: 
0a9f c5				push bc 
0aa0 47				ld b,a 
0aa1			msdelay: 
0aa1 c5				push bc 
0aa2				 
0aa2			 
0aa2 01 41 00			ld bc,041h 
0aa5 cd bd 0a			call delayloop 
0aa8 c1				pop bc 
0aa9 05				dec b 
0aaa 20 f5			jr nz,msdelay 
0aac			 
0aac			;if CPU_CLOCK_8MHZ 
0aac			;msdelay8: 
0aac			;	push bc 
0aac			;	 
0aac			; 
0aac			;	ld bc,041h 
0aac			;	call delayloop 
0aac			;	pop bc 
0aac			;	dec b 
0aac			;	jr nz,msdelay8 
0aac			;endif 
0aac			 
0aac			 
0aac c1				pop bc 
0aad c9				ret 
0aae			 
0aae			 
0aae			delay250ms: 
0aae				;push de 
0aae 01 00 40			ld bc, 04000h 
0ab1 c3 bd 0a			jp delayloop 
0ab4			delay500ms: 
0ab4				;push de 
0ab4 01 00 80			ld bc, 08000h 
0ab7 c3 bd 0a			jp delayloop 
0aba			delay1s: 
0aba				;push bc 
0aba			   ; Clobbers A, d and e 
0aba 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0abd			delayloop: 
0abd c5			    push bc 
0abe			 
0abe			if BASE_CPM 
0abe 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0ac1			.cpmloop: 
0ac1 c5				push bc 
0ac2			 
0ac2			endif 
0ac2			 
0ac2			 
0ac2			 
0ac2			delayloopi: 
0ac2			;	push bc 
0ac2			;.dl: 
0ac2 cb 47		    bit     0,a    	; 8 
0ac4 cb 47		    bit     0,a    	; 8 
0ac6 cb 47		    bit     0,a    	; 8 
0ac8 e6 ff		    and     255  	; 7 
0aca 0b			    dec     bc      	; 6 
0acb 79			    ld      a,c     	; 4 
0acc b0			    or      b     	; 4 
0acd c2 c2 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ad0			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ad0				;pop de 
0ad0			;pop bc 
0ad0			 
0ad0			if BASE_CPM 
0ad0 c1				pop bc 
0ad1				 
0ad1 0b			    dec     bc      	; 6 
0ad2 79			    ld      a,c     	; 4 
0ad3 b0			    or      b     	; 4 
0ad4 c2 c1 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ad7				 
0ad7			 
0ad7			endif 
0ad7			;if CPU_CLOCK_8MHZ 
0ad7			;    pop bc 
0ad7			;    push bc 
0ad7			;.dl8: 
0ad7			;    bit     0,a    	; 8 
0ad7			;    bit     0,a    	; 8 
0ad7			;    bit     0,a    	; 8 
0ad7			;    and     255  	; 7 
0ad7			;    dec     bc      	; 6 
0ad7			;    ld      a,c     	; 4 
0ad7			;    or      b     	; 4 
0ad7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ad7			;endif 
0ad7			 
0ad7			;if CPU_CLOCK_10MHZ 
0ad7			;    pop bc 
0ad7			;    push bc 
0ad7			;.dl8: 
0ad7			;    bit     0,a    	; 8 
0ad7			;    bit     0,a    	; 8 
0ad7			;    bit     0,a    	; 8 
0ad7			;    and     255  	; 7 
0ad7			;    dec     bc      	; 6 
0ad7			;    ld      a,c     	; 4 
0ad7			;    or      b     	; 4 
0ad7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ad7			;endif 
0ad7 c1			    pop bc 
0ad8			 
0ad8 c9				ret 
0ad9			 
0ad9			 
0ad9			 
0ad9			; eof 
# End of file firmware_general.asm
0ad9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ad9			; display routines that use the physical hardware abstraction layer 
0ad9			 
0ad9			 
0ad9			; information window 
0ad9			 
0ad9			; pass hl with 1st string to display 
0ad9			; pass de with 2nd string to display 
0ad9			 
0ad9			info_panel: 
0ad9 e5				push hl 
0ada			 
0ada 2a d2 eb			ld hl, (display_fb_active) 
0add e5				push hl    ; future de destination 
0ade 21 b7 ed				ld hl, display_fb0 
0ae1 22 d2 eb				ld (display_fb_active), hl 
0ae4			 
0ae4			;	call clear_display 
0ae4			 
0ae4				if BASE_CPM 
0ae4 3e 2e			ld a, '.' 
0ae6				else 
0ae6				ld a, 165 
0ae6				endif 
0ae6 cd 4d 0b			call fill_display 
0ae9			 
0ae9			 
0ae9 3e 55			ld a, display_row_3 + 5 
0aeb cd 5b 0b			call str_at_display 
0aee			 
0aee e1				pop hl 
0aef d1				pop de 
0af0			 
0af0 e5				push hl 
0af1			 
0af1			 
0af1 3e 2d			ld a, display_row_2 + 5 
0af3 cd 5b 0b			call str_at_display 
0af6			 
0af6			 
0af6 cd 6b 0b			call update_display 
0af9 cd 5f 1b			call next_page_prompt 
0afc cd 48 0b			call clear_display 
0aff			 
0aff				 
0aff 21 16 ed				ld hl, display_fb1 
0b02 22 d2 eb				ld (display_fb_active), hl 
0b05 cd 6b 0b			call update_display 
0b08			 
0b08 e1				pop hl 
0b09			 
0b09 c9				ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			 
0b0a			; TODO windowing? 
0b0a			 
0b0a			; TODO scroll line up 
0b0a			 
0b0a			scroll_up: 
0b0a			 
0b0a e5				push hl 
0b0b d5				push de 
0b0c c5				push bc 
0b0d			 
0b0d				; get frame buffer  
0b0d			 
0b0d 2a d2 eb			ld hl, (display_fb_active) 
0b10 e5				push hl    ; future de destination 
0b11			 
0b11 11 28 00			ld  de, display_cols 
0b14 19				add hl, de 
0b15			 
0b15 d1				pop de 
0b16			 
0b16				;ex de, hl 
0b16 01 9f 00			ld bc, display_fb_len -1  
0b19			;if DEBUG_FORTH_WORDS 
0b19			;	DMARK "SCL" 
0b19			;	CALLMONITOR 
0b19			;endif	 
0b19 ed b0			ldir 
0b1b			 
0b1b				; wipe bottom row 
0b1b			 
0b1b			 
0b1b 2a d2 eb			ld hl, (display_fb_active) 
0b1e 11 a0 00			ld de, display_cols*display_rows 
0b21 19				add hl, de 
0b22 06 28			ld b, display_cols 
0b24 3e 20			ld a, ' ' 
0b26			.scwipe: 
0b26 77				ld (hl), a 
0b27 2b				dec hl 
0b28 10 fc			djnz .scwipe 
0b2a			 
0b2a				;pop hl 
0b2a			 
0b2a c1				pop bc 
0b2b d1				pop de 
0b2c e1				pop hl 
0b2d			 
0b2d c9				ret 
0b2e			 
0b2e			 
0b2e			;scroll_upo: 
0b2e			;	ld de, display_row_1 
0b2e			 ;	ld hl, display_row_2 
0b2e			;	ld bc, display_cols 
0b2e			;	ldir 
0b2e			;	ld de, display_row_2 
0b2e			 ;	ld hl, display_row_3 
0b2e			;	ld bc, display_cols 
0b2e			;	ldir 
0b2e			;	ld de, display_row_3 
0b2e			 ;	ld hl, display_row_4 
0b2e			;	ld bc, display_cols 
0b2e			;	ldir 
0b2e			 
0b2e			; TODO clear row 4 
0b2e			 
0b2e			;	ret 
0b2e			 
0b2e				 
0b2e			scroll_down: 
0b2e			 
0b2e e5				push hl 
0b2f d5				push de 
0b30 c5				push bc 
0b31			 
0b31				; get frame buffer  
0b31			 
0b31 2a d2 eb			ld hl, (display_fb_active) 
0b34			 
0b34 11 9f 00			ld de, display_fb_len - 1 
0b37 19				add hl, de 
0b38			 
0b38 e5			push hl    ; future de destination 
0b39			 
0b39 11 28 00			ld  de, display_cols 
0b3c ed 52			sbc hl, de 
0b3e			 
0b3e			 
0b3e d1				pop de 
0b3f			 
0b3f			;	ex de, hl 
0b3f 01 9f 00			ld bc, display_fb_len -1  
0b42			 
0b42			 
0b42				 
0b42			 
0b42 ed b0			ldir 
0b44			 
0b44				; wipe bottom row 
0b44			 
0b44			 
0b44			;	ld hl, (display_fb_active) 
0b44			;;	ld de, display_cols*display_rows 
0b44			;;	add hl, de 
0b44			;	ld b, display_cols 
0b44			;	ld a, ' ' 
0b44			;.scwiped: 
0b44			;	ld (hl), a 
0b44			;	dec hl 
0b44			;	djnz .scwiped 
0b44			 
0b44				;pop hl 
0b44			 
0b44 c1				pop bc 
0b45 d1				pop de 
0b46 e1				pop hl 
0b47			 
0b47 c9				ret 
0b48			;scroll_down: 
0b48			;	ld de, display_row_4 
0b48			;	ld hl, display_row_3 
0b48			;	ld bc, display_cols 
0b48			;	ldir 
0b48			;	ld de, display_row_3 
0b48			; 	ld hl, display_row_2 
0b48			;	ld bc, display_cols 
0b48			;	ldir 
0b48			;	ld de, display_row_2 
0b48			;	ld hl, display_row_1 
0b48			;	ld bc, display_cols 
0b48			;	ldir 
0b48			;;; TODO clear row 1 
0b48			;	ret 
0b48			 
0b48			 
0b48			 
0b48			 
0b48			 
0b48			; clear active frame buffer 
0b48			 
0b48			clear_display: 
0b48 3e 20			ld a, ' ' 
0b4a c3 4d 0b			jp fill_display 
0b4d			 
0b4d			; fill active frame buffer with a char in A 
0b4d			 
0b4d			fill_display: 
0b4d 06 a0			ld b,display_fb_len 
0b4f 2a d2 eb			ld hl, (display_fb_active) 
0b52 77			.fd1:	ld (hl),a 
0b53 23				inc hl 
0b54 10 fc			djnz .fd1 
0b56 23				inc hl 
0b57 3e 00			ld a,0 
0b59 77				ld (hl),a 
0b5a			 
0b5a			 
0b5a c9				ret 
0b5b			; Write string (DE) at pos (A) to active frame buffer 
0b5b			 
0b5b 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0b5e 06 00					ld b,0 
0b60 4f					ld c,a 
0b61 09					add hl,bc 
0b62 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b63 b7			            OR   A              ;Null terminator? 
0b64 c8			            RET  Z              ;Yes, so finished 
0b65 77					ld (hl),a 
0b66 23				inc hl 
0b67 13			            INC  DE             ;Point to next character 
0b68 18 f8		            JR   .sad1     ;Repeat 
0b6a c9					ret 
0b6b			 
0b6b			; using current frame buffer write to physical display 
0b6b			 
0b6b			update_display: 
0b6b e5				push hl 
0b6c 2a d2 eb			ld hl, (display_fb_active) 
0b6f cd e3 5a			call write_display 
0b72 e1				pop hl 
0b73 c9				ret 
0b74			 
0b74			; TODO scrolling 
0b74			 
0b74			 
0b74			; move cursor right one char 
0b74			cursor_right: 
0b74			 
0b74				; TODO shift right 
0b74				; TODO if beyond max col 
0b74				; TODO       cursor_next_line 
0b74			 
0b74 c9				ret 
0b75			 
0b75			 
0b75			cursor_next_line: 
0b75				; TODO first char 
0b75				; TODO line down 
0b75				; TODO if past last row 
0b75				; TODO    scroll up 
0b75			 
0b75 c9				ret 
0b76			 
0b76			cursor_left: 
0b76				; TODO shift left 
0b76				; TODO if beyond left  
0b76				; TODO     cursor prev line 
0b76				 
0b76 c9				ret 
0b77			 
0b77			cursor_prev_line: 
0b77				; TODO last char 
0b77				; TODO line up 
0b77				; TODO if past first row 
0b77				; TODO   scroll down 
0b77			 
0b77 c9				ret 
0b78			 
0b78			 
0b78			cout: 
0b78				; A - char 
0b78 c9				ret 
0b79			 
0b79			 
0b79			; Display a menu and allow item selection (optional toggle items) 
0b79			; 
0b79			; format: 
0b79			; hl pointer to word array with zero term for items 
0b79			; e.g.    db item1 
0b79			;         db .... 
0b79			;         db 0 
0b79			; 
0b79			; a = starting menu item  
0b79			; 
0b79			; de = pointer item toggle array   (todo) 
0b79			; 
0b79			; returns item selected in a 1-... 
0b79			; returns 0 if back button pressed 
0b79			; 
0b79			; NOTE: Uses system frame buffer to display 
0b79			; 
0b79			; LEFT, Q = go back 
0b79			; RIGHT, SPACE, CR = select 
0b79			; UP, A - Up 
0b79			; DOWN, Z - Down 
0b79			 
0b79			 
0b79			 
0b79			 
0b79			 
0b79			menu: 
0b79			 
0b79					; keep array pointer 
0b79			 
0b79 22 7d ea				ld (store_tmp1), hl 
0b7c 32 7b ea				ld (store_tmp2), a 
0b7f			 
0b7f					; check for key bounce 
0b7f			 
0b7f			if BASE_KEV 
0b7f			 
0b7f			.mbounce:	call cin 
0b7f					cp 0 
0b7f					jr nz, .mbounce 
0b7f			endif 
0b7f					; for ease use ex 
0b7f			 
0b7f					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b7f 21 b7 ed				ld hl, display_fb0 
0b82 22 d2 eb				ld (display_fb_active), hl 
0b85			 
0b85 cd 48 0b		.mloop:		call clear_display 
0b88 cd 6b 0b				call update_display 
0b8b			 
0b8b					; draw selection id '>' at 1 
0b8b			 
0b8b					; init start of list display 
0b8b			 
0b8b 3e 05				ld a, 5 
0b8d 32 79 ea				ld (store_tmp3), a   ; display row count 
0b90 3a 7b ea				ld a,( store_tmp2) 
0b93 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0b96			 
0b96					 
0b96			.mitem:	 
0b96			 
0b96			 
0b96 3a 7c ea				ld a,(store_tmp2+1) 
0b99 6f					ld l, a 
0b9a 26 00				ld h, 0 
0b9c 29					add hl, hl 
0b9d ed 5b 7d ea			ld de, (store_tmp1) 
0ba1 19					add hl, de 
0ba2 7e					ld a, (hl) 
0ba3 23					inc hl 
0ba4 66					ld h,(hl) 
0ba5 6f					ld l, a 
0ba6			 
0ba6 cd 9e 0d				call ishlzero 
0ba9 28 1a				jr z, .mdone 
0bab			 
0bab eb					ex de, hl 
0bac 3a 79 ea				ld a, (store_tmp3) 
0baf cd 5b 0b				call str_at_display 
0bb2					 
0bb2			 
0bb2					; next item 
0bb2 3a 7c ea				ld a, (store_tmp2+1) 
0bb5 3c					inc a 
0bb6 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0bb9			 
0bb9			 		; next row 
0bb9			 
0bb9 3a 79 ea				ld a, (store_tmp3) 
0bbc c6 28				add display_cols 
0bbe 32 79 ea				ld (store_tmp3), a 
0bc1			 
0bc1					; at end of screen? 
0bc1			 
0bc1 fe 10				cp display_rows*4 
0bc3 20 d1				jr nz, .mitem 
0bc5			 
0bc5			 
0bc5			.mdone: 
0bc5 cd 9e 0d				call ishlzero 
0bc8 28 08				jr z, .nodn 
0bca			 
0bca 3e 78				ld a, display_row_4 
0bcc 11 4b 0c				ld de, .mdown 
0bcf cd 5b 0b				call str_at_display 
0bd2			 
0bd2					; draw options to fill the screens with active item on line 1 
0bd2					; if current option is 2 or more then display ^ in top 
0bd2			 
0bd2 3a 7b ea		.nodn:		ld a, (store_tmp2) 
0bd5 fe 00				cp 0 
0bd7 28 08				jr z, .noup 
0bd9			 
0bd9 3e 00				ld a, 0 
0bdb 11 49 0c				ld de, .mup 
0bde cd 5b 0b				call str_at_display 
0be1			 
0be1 3e 02		.noup:		ld a, 2 
0be3 11 47 0c				ld de, .msel 
0be6 cd 5b 0b				call str_at_display 
0be9			 
0be9					; if current option + 1 is not null then display V in bottom 
0be9					; get key 
0be9 cd 6b 0b				call update_display 
0bec			 
0bec			 
0bec					; handle key 
0bec			 
0bec cd 95 5b				call cin_wait 
0bef			 
0bef fe 05				cp KEY_UP 
0bf1 28 2b				jr z, .mgoup 
0bf3 fe 61				cp 'a' 
0bf5 28 27				jr z, .mgoup 
0bf7 fe 0a				cp KEY_DOWN 
0bf9 28 32				jr z, .mgod 
0bfb fe 7a				cp 'z' 
0bfd 28 2e				jr z, .mgod 
0bff fe 20				cp ' ' 
0c01 28 34				jr z, .goend 
0c03 fe 0c				cp KEY_RIGHT 
0c05 28 30				jr z, .goend 
0c07 fe 0d				cp KEY_CR 
0c09 28 2c				jr z, .goend 
0c0b fe 71				cp 'q' 
0c0d 28 0b				jr z, .goback 
0c0f			 
0c0f fe 0b				cp KEY_LEFT 
0c11 28 07				jr z, .goback 
0c13 fe 08				cp KEY_BS 
0c15 28 03				jr z, .goback 
0c17 c3 85 0b				jp .mloop 
0c1a			 
0c1a			.goback: 
0c1a 3e 00			ld a, 0 
0c1c 18 1d			jr .goend2 
0c1e			 
0c1e				; move up one 
0c1e			.mgoup: 
0c1e 3a 7b ea				ld a, (store_tmp2) 
0c21 fe 00				cp 0 
0c23 ca 85 0b				jp z, .mloop 
0c26 3d					dec a 
0c27 32 7b ea				ld (store_tmp2), a 
0c2a c3 85 0b				jp .mloop 
0c2d			 
0c2d				; move down one 
0c2d			.mgod: 
0c2d 3a 7b ea				ld a, (store_tmp2) 
0c30 3c					inc a 
0c31 32 7b ea				ld (store_tmp2), a 
0c34 c3 85 0b				jp .mloop 
0c37			 
0c37			 
0c37			.goend: 
0c37					; get selected item number 
0c37			 
0c37 3a 7b ea				ld a, (store_tmp2) 
0c3a 3c					inc a 
0c3b			 
0c3b			.goend2: 
0c3b f5					push af 
0c3c			 
0c3c					; restore active fb 
0c3c					; TODO BUG assumes fb1 
0c3c			 
0c3c 21 16 ed				ld hl, display_fb1 
0c3f 22 d2 eb				ld (display_fb_active), hl 
0c42			 
0c42					; restore main regs 
0c42			 
0c42			 
0c42 cd 6b 0b				call update_display 
0c45			 
0c45 f1					pop af 
0c46			 
0c46 c9				ret 
0c47			 
0c47 .. 00		.msel:   db ">",0 
0c49 .. 00		.mup:   db "^",0 
0c4b .. 00		.mdown:   db "v",0 
0c4d			 
0c4d			 
0c4d			; eof 
0c4d			 
# End of file firmware_display.asm
0c4d			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0c4d			; random number generators 
0c4d			 
0c4d			 
0c4d			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0c4d			 
0c4d			 
0c4d			;-----> Generate a random number 
0c4d			; output a=answer 0<=a<=255 
0c4d			; all registers are preserved except: af 
0c4d			random: 
0c4d e5			        push    hl 
0c4e d5			        push    de 
0c4f 2a b4 eb		        ld      hl,(randData) 
0c52 ed 5f		        ld      a,r 
0c54 57			        ld      d,a 
0c55 5e			        ld      e,(hl) 
0c56 19			        add     hl,de 
0c57 85			        add     a,l 
0c58 ac			        xor     h 
0c59 22 b4 eb		        ld      (randData),hl 
0c5c d1			        pop     de 
0c5d e1			        pop     hl 
0c5e c9			        ret 
0c5f			 
0c5f			 
0c5f			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c5f			 
0c5f			 
0c5f			 
0c5f			;------LFSR------ 
0c5f			;James Montelongo 
0c5f			;optimized by Spencer Putt 
0c5f			;out: 
0c5f			; a = 8 bit random number 
0c5f			RandLFSR: 
0c5f 21 ba eb		        ld hl,LFSRSeed+4 
0c62 5e			        ld e,(hl) 
0c63 23			        inc hl 
0c64 56			        ld d,(hl) 
0c65 23			        inc hl 
0c66 4e			        ld c,(hl) 
0c67 23			        inc hl 
0c68 7e			        ld a,(hl) 
0c69 47			        ld b,a 
0c6a cb 13		        rl e  
0c6c cb 12			rl d 
0c6e cb 11		        rl c  
0c70 17				rla 
0c71 cb 13		        rl e  
0c73 cb 12			rl d 
0c75 cb 11		        rl c  
0c77 17				rla 
0c78 cb 13		        rl e  
0c7a cb 12			rl d 
0c7c cb 11		        rl c  
0c7e 17				rla 
0c7f 67			        ld h,a 
0c80 cb 13		        rl e  
0c82 cb 12			rl d 
0c84 cb 11		        rl c  
0c86 17				rla 
0c87 a8			        xor b 
0c88 cb 13		        rl e  
0c8a cb 12			rl d 
0c8c ac			        xor h 
0c8d a9			        xor c 
0c8e aa			        xor d 
0c8f 21 bc eb		        ld hl,LFSRSeed+6 
0c92 11 bd eb		        ld de,LFSRSeed+7 
0c95 01 07 00		        ld bc,7 
0c98 ed b8		        lddr 
0c9a 12			        ld (de),a 
0c9b c9			        ret 
0c9c			 
0c9c			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c9c			 
0c9c			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c9c			 
0c9c			 
0c9c			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c9c			 
0c9c			prng16: 
0c9c			;Inputs: 
0c9c			;   (seed1) contains a 16-bit seed value 
0c9c			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c9c			;Outputs: 
0c9c			;   HL is the result 
0c9c			;   BC is the result of the LCG, so not that great of quality 
0c9c			;   DE is preserved 
0c9c			;Destroys: 
0c9c			;   AF 
0c9c			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c9c			;160cc 
0c9c			;26 bytes 
0c9c 2a ae eb		    ld hl,(seed1) 
0c9f 44			    ld b,h 
0ca0 4d			    ld c,l 
0ca1 29			    add hl,hl 
0ca2 29			    add hl,hl 
0ca3 2c			    inc l 
0ca4 09			    add hl,bc 
0ca5 22 ae eb		    ld (seed1),hl 
0ca8 2a ac eb		    ld hl,(seed2) 
0cab 29			    add hl,hl 
0cac 9f			    sbc a,a 
0cad e6 2d		    and %00101101 
0caf ad			    xor l 
0cb0 6f			    ld l,a 
0cb1 22 ac eb		    ld (seed2),hl 
0cb4 09			    add hl,bc 
0cb5 c9			    ret 
0cb6			 
0cb6			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0cb6			 
0cb6			rand32: 
0cb6			;Inputs: 
0cb6			;   (seed1_0) holds the lower 16 bits of the first seed 
0cb6			;   (seed1_1) holds the upper 16 bits of the first seed 
0cb6			;   (seed2_0) holds the lower 16 bits of the second seed 
0cb6			;   (seed2_1) holds the upper 16 bits of the second seed 
0cb6			;   **NOTE: seed2 must be non-zero 
0cb6			;Outputs: 
0cb6			;   HL is the result 
0cb6			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0cb6			;Destroys: 
0cb6			;   AF 
0cb6			;Tested and passes all CAcert tests 
0cb6			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0cb6			;it has a period of 18,446,744,069,414,584,320 
0cb6			;roughly 18.4 quintillion. 
0cb6			;LFSR taps: 0,2,6,7  = 11000101 
0cb6			;291cc 
0cb6			;seed1_0=$+1 
0cb6			;    ld hl,12345 
0cb6			;seed1_1=$+1 
0cb6			;    ld de,6789 
0cb6			;    ld b,h 
0cb6			;    ld c,l 
0cb6			;    add hl,hl \ rl e \ rl d 
0cb6			;    add hl,hl \ rl e \ rl d 
0cb6			;    inc l 
0cb6			;    add hl,bc 
0cb6			;    ld (seed1_0),hl 
0cb6			;    ld hl,(seed1_1) 
0cb6			;    adc hl,de 
0cb6			;    ld (seed1_1),hl 
0cb6			;    ex de,hl 
0cb6			;seed2_0=$+1 
0cb6			;    ld hl,9876 
0cb6			;seed2_1=$+1 
0cb6			;    ld bc,54321 
0cb6			;    add hl,hl \ rl c \ rl b 
0cb6			;    ld (seed2_1),bc 
0cb6			;    sbc a,a 
0cb6			;    and %11000101 
0cb6			;    xor l 
0cb6			;    ld l,a 
0cb6			;    ld (seed2_0),hl 
0cb6			;    ex de,hl 
0cb6			;    add hl,bc 
0cb6			;    ret 
0cb6			; 
0cb6			 
0cb6			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0cb6			; 20 bytes, 86 cycles (excluding ret) 
0cb6			 
0cb6			; returns   hl = pseudorandom number 
0cb6			; corrupts   a 
0cb6			 
0cb6			; generates 16-bit pseudorandom numbers with a period of 65535 
0cb6			; using the xorshift method: 
0cb6			 
0cb6			; hl ^= hl << 7 
0cb6			; hl ^= hl >> 9 
0cb6			; hl ^= hl << 8 
0cb6			 
0cb6			; some alternative shift triplets which also perform well are: 
0cb6			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0cb6			 
0cb6			;  org 32768 
0cb6			 
0cb6			xrnd: 
0cb6 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
0cb9 3e 00		  ld a,0 
0cbb bd			  cp l 
0cbc 20 02		  jr nz, .xrnd1 
0cbe 2e 01		  ld l, 1 
0cc0			.xrnd1: 
0cc0			 
0cc0 7c			  ld a,h 
0cc1 1f			  rra 
0cc2 7d			  ld a,l 
0cc3 1f			  rra 
0cc4 ac			  xor h 
0cc5 67			  ld h,a 
0cc6 7d			  ld a,l 
0cc7 1f			  rra 
0cc8 7c			  ld a,h 
0cc9 1f			  rra 
0cca ad			  xor l 
0ccb 6f			  ld l,a 
0ccc ac			  xor h 
0ccd 67			  ld h,a 
0cce			 
0cce 22 b2 eb		  ld (xrandc),hl 
0cd1			 
0cd1 c9			  ret 
0cd2			;  
0cd2			 
0cd2			 
0cd2			;;;; int maths 
0cd2			 
0cd2			; https://map.grauw.nl/articles/mult_div_shifts.php 
0cd2			; Divide 16-bit values (with 16-bit result) 
0cd2			; In: Divide BC by divider DE 
0cd2			; Out: BC = result, HL = rest 
0cd2			; 
0cd2			Div16: 
0cd2 21 00 00		    ld hl,0 
0cd5 78			    ld a,b 
0cd6 06 08		    ld b,8 
0cd8			Div16_Loop1: 
0cd8 17			    rla 
0cd9 ed 6a		    adc hl,hl 
0cdb ed 52		    sbc hl,de 
0cdd 30 01		    jr nc,Div16_NoAdd1 
0cdf 19			    add hl,de 
0ce0			Div16_NoAdd1: 
0ce0 10 f6		    djnz Div16_Loop1 
0ce2 17			    rla 
0ce3 2f			    cpl 
0ce4 47			    ld b,a 
0ce5 79			    ld a,c 
0ce6 48			    ld c,b 
0ce7 06 08		    ld b,8 
0ce9			Div16_Loop2: 
0ce9 17			    rla 
0cea ed 6a		    adc hl,hl 
0cec ed 52		    sbc hl,de 
0cee 30 01		    jr nc,Div16_NoAdd2 
0cf0 19			    add hl,de 
0cf1			Div16_NoAdd2: 
0cf1 10 f6		    djnz Div16_Loop2 
0cf3 17			    rla 
0cf4 2f			    cpl 
0cf5 41			    ld b,c 
0cf6 4f			    ld c,a 
0cf7 c9			ret 
0cf8			 
0cf8			 
0cf8			;http://z80-heaven.wikidot.com/math 
0cf8			; 
0cf8			;Inputs: 
0cf8			;     DE and A are factors 
0cf8			;Outputs: 
0cf8			;     A is not changed 
0cf8			;     B is 0 
0cf8			;     C is not changed 
0cf8			;     DE is not changed 
0cf8			;     HL is the product 
0cf8			;Time: 
0cf8			;     342+6x 
0cf8			; 
0cf8			Mult16: 
0cf8			 
0cf8 06 08		     ld b,8          ;7           7 
0cfa 21 00 00		     ld hl,0         ;10         10 
0cfd 29			       add hl,hl     ;11*8       88 
0cfe 07			       rlca          ;4*8        32 
0cff 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d01 19			         add hl,de   ;--         -- 
0d02 10 f9		       djnz $-5      ;13*7+8     99 
0d04 c9			ret 
0d05			 
0d05			; 
0d05			; Square root of 16-bit value 
0d05			; In:  HL = value 
0d05			; Out:  D = result (rounded down) 
0d05			; 
0d05			;Sqr16: 
0d05			;    ld de,#0040 
0d05			;    ld a,l 
0d05			;    ld l,h 
0d05			;    ld h,d 
0d05			;    or a 
0d05			;    ld b,8 
0d05			;Sqr16_Loop: 
0d05			;    sbc hl,de 
0d05			;    jr nc,Sqr16_Skip 
0d05			;    add hl,de 
0d05			;Sqr16_Skip: 
0d05			;    ccf 
0d05			;    rl d 
0d05			;    add a,a 
0d05			;    adc hl,hl 
0d05			;    add a,a 
0d05			;    adc hl,hl 
0d05			;    djnz Sqr16_Loop 
0d05			;    ret 
0d05			; 
0d05			; 
0d05			; Divide 8-bit values 
0d05			; In: Divide E by divider C 
0d05			; Out: A = result, B = rest 
0d05			; 
0d05			Div8: 
0d05 af			    xor a 
0d06 06 08		    ld b,8 
0d08			Div8_Loop: 
0d08 cb 13		    rl e 
0d0a 17			    rla 
0d0b 91			    sub c 
0d0c 30 01		    jr nc,Div8_NoAdd 
0d0e 81			    add a,c 
0d0f			Div8_NoAdd: 
0d0f 10 f7		    djnz Div8_Loop 
0d11 47			    ld b,a 
0d12 7b			    ld a,e 
0d13 17			    rla 
0d14 2f			    cpl 
0d15 c9			    ret 
0d16			 
0d16			; 
0d16			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d16			; In: Multiply A with DE 
0d16			; Out: HL = result 
0d16			; 
0d16			Mult12U: 
0d16 2e 00		    ld l,0 
0d18 87			    add a,a 
0d19 30 01		    jr nc,Mult12U_NoAdd0 
0d1b 19			    add hl,de 
0d1c			Mult12U_NoAdd0: 
0d1c 29			    add hl,hl 
0d1d 87			    add a,a 
0d1e 30 01		    jr nc,Mult12U_NoAdd1 
0d20 19			    add hl,de 
0d21			Mult12U_NoAdd1: 
0d21 29			    add hl,hl 
0d22 87			    add a,a 
0d23 30 01		    jr nc,Mult12U_NoAdd2 
0d25 19			    add hl,de 
0d26			Mult12U_NoAdd2: 
0d26 29			    add hl,hl 
0d27 87			    add a,a 
0d28 30 01		    jr nc,Mult12U_NoAdd3 
0d2a 19			    add hl,de 
0d2b			Mult12U_NoAdd3: 
0d2b 29			    add hl,hl 
0d2c 87			    add a,a 
0d2d 30 01		    jr nc,Mult12U_NoAdd4 
0d2f 19			    add hl,de 
0d30			Mult12U_NoAdd4: 
0d30 29			    add hl,hl 
0d31 87			    add a,a 
0d32 30 01		    jr nc,Mult12U_NoAdd5 
0d34 19			    add hl,de 
0d35			Mult12U_NoAdd5: 
0d35 29			    add hl,hl 
0d36 87			    add a,a 
0d37 30 01		    jr nc,Mult12U_NoAdd6 
0d39 19			    add hl,de 
0d3a			Mult12U_NoAdd6: 
0d3a 29			    add hl,hl 
0d3b 87			    add a,a 
0d3c d0			    ret nc 
0d3d 19			    add hl,de 
0d3e c9			    ret 
0d3f			 
0d3f			; 
0d3f			; Multiply 8-bit value with a 16-bit value (right rotating) 
0d3f			; In: Multiply A with DE 
0d3f			;      Put lowest value in A for most efficient calculation 
0d3f			; Out: HL = result 
0d3f			; 
0d3f			Mult12R: 
0d3f 21 00 00		    ld hl,0 
0d42			Mult12R_Loop: 
0d42 cb 3f		    srl a 
0d44 30 01		    jr nc,Mult12R_NoAdd 
0d46 19			    add hl,de 
0d47			Mult12R_NoAdd: 
0d47 cb 23		    sla e 
0d49 cb 12		    rl d 
0d4b b7			    or a 
0d4c c2 42 0d		    jp nz,Mult12R_Loop 
0d4f c9			    ret 
0d50			 
0d50			; 
0d50			; Multiply 16-bit values (with 32-bit result) 
0d50			; In: Multiply BC with DE 
0d50			; Out: BCHL = result 
0d50			; 
0d50			Mult32: 
0d50 79			    ld a,c 
0d51 48			    ld c,b 
0d52 21 00 00		    ld hl,0 
0d55 06 10		    ld b,16 
0d57			Mult32_Loop: 
0d57 29			    add hl,hl 
0d58 17			    rla 
0d59 cb 11		    rl c 
0d5b 30 07		    jr nc,Mult32_NoAdd 
0d5d 19			    add hl,de 
0d5e ce 00		    adc a,0 
0d60 d2 64 0d		    jp nc,Mult32_NoAdd 
0d63 0c			    inc c 
0d64			Mult32_NoAdd: 
0d64 10 f1		    djnz Mult32_Loop 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			    ret 
0d69			 
0d69			 
0d69			 
0d69			; 
0d69			; Multiply 8-bit values 
0d69			; In:  Multiply H with E 
0d69			; Out: HL = result 
0d69			; 
0d69			Mult8: 
0d69 16 00		    ld d,0 
0d6b 6a			    ld l,d 
0d6c 06 08		    ld b,8 
0d6e			Mult8_Loop: 
0d6e 29			    add hl,hl 
0d6f 30 01		    jr nc,Mult8_NoAdd 
0d71 19			    add hl,de 
0d72			Mult8_NoAdd: 
0d72 10 fa		    djnz Mult8_Loop 
0d74 c9			    ret 
0d75			 
0d75			 
0d75			 
0d75			 
0d75			 
0d75			 
0d75			 
0d75			 
0d75			;;http://z80-heaven.wikidot.com/math 
0d75			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d75			; 
0d75			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d75			;     ld a,16        ;7 
0d75			;     ld hl,0        ;10 
0d75			;     jp $+5         ;10 
0d75			;.DivLoop: 
0d75			;       add hl,bc    ;-- 
0d75			;       dec a        ;64 
0d75			;       jr z,.DivLoopEnd        ;86 
0d75			; 
0d75			;       sla e        ;128 
0d75			;       rl d         ;128 
0d75			;       adc hl,hl    ;240 
0d75			;       sbc hl,bc    ;240 
0d75			;       jr nc,.DivLoop ;23|21 
0d75			;       inc e        ;-- 
0d75			;       jp .DivLoop+1 
0d75			; 
0d75			;.DivLoopEnd: 
0d75			 
0d75			;HL_Div_C: 
0d75			;Inputs: 
0d75			;     HL is the numerator 
0d75			;     C is the denominator 
0d75			;Outputs: 
0d75			;     A is the remainder 
0d75			;     B is 0 
0d75			;     C is not changed 
0d75			;     DE is not changed 
0d75			;     HL is the quotient 
0d75			; 
0d75			;       ld b,16 
0d75			;       xor a 
0d75			;         add hl,hl 
0d75			;         rla 
0d75			;         cp c 
0d75			;         jr c,$+4 
0d75			;           inc l 
0d75			;           sub c 
0d75			;         djnz $-7 
0d75			 
0d75			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d75			 
0d75			addatohl: 
0d75 85			    add   a, l    ; A = A+L 
0d76 6f			    ld    l, a    ; L = A+L 
0d77 8c			    adc   a, h    ; A = A+L+H+carry 
0d78 95			    sub   l       ; A = H+carry 
0d79 67			    ld    h, a    ; H = H+carry 
0d7a c9			ret 
0d7b			 
0d7b			addatode: 
0d7b 83			    add   a, e    ; A = A+L 
0d7c 5f			    ld    e, a    ; L = A+L 
0d7d 8a			    adc   a, d    ; A = A+L+H+carry 
0d7e 93			    sub   e       ; A = H+carry 
0d7f 57			    ld    d, a    ; H = H+carry 
0d80 c9			ret 
0d81			 
0d81			 
0d81			addatobc: 
0d81 81			    add   a, c    ; A = A+L 
0d82 4f			    ld    c, a    ; L = A+L 
0d83 88			    adc   a, b    ; A = A+L+H+carry 
0d84 91			    sub   c       ; A = H+carry 
0d85 47			    ld    b, a    ; H = H+carry 
0d86 c9			ret 
0d87			 
0d87			subafromhl: 
0d87			   ; If A=0 do nothing 
0d87			    ; Otherwise flip A's sign. Since 
0d87			    ; the upper byte becomes -1, also 
0d87			    ; substract 1 from H. 
0d87 ed 44		    neg 
0d89 ca 92 0d		    jp    z, Skip 
0d8c 25			    dec   h 
0d8d			     
0d8d			    ; Now add the low byte as usual 
0d8d			    ; Two's complement takes care of 
0d8d			    ; ensuring the result is correct 
0d8d 85			    add   a, l 
0d8e 6f			    ld    l, a 
0d8f 8c			    adc   a, h 
0d90 95			    sub   l 
0d91 67			    ld    h, a 
0d92			Skip: 
0d92 c9				ret 
0d93			 
0d93			 
0d93			; compare hl and de 
0d93			; returns:  
0d93			; if hl = de, z=1, s=0, c0=0 
0d93			; if hl > de, z=0, s=0, c=0 
0d93			; if hl < de, z=0, s=1, c=1 
0d93			cmp16:	 
0d93 b7				or a 
0d94 ed 52			sbc hl,de 
0d96 e0				ret po 
0d97 7c				ld a,h 
0d98 1f				rra 
0d99 ee 40			xor 01000000B 
0d9b 37				scf 
0d9c 8f				adc a,a 
0d9d c9				ret 
0d9e			 
0d9e			 
0d9e			; test if hl contains zero   - A is destroyed 
0d9e			 
0d9e			ishlzero:    
0d9e b7				or a     ; reset flags 
0d9f 7c				ld a, h 
0da0 b5				or l        	 
0da1			 
0da1 c9				ret 
0da2			 
0da2			 
0da2			 
0da2			 
0da2			if FORTH_ENABLE_FLOATMATH 
0da2			;include "float/bbcmath.z80" 
0da2			include "float/lpfpcalc.asm" 
0da2			endif 
0da2			 
0da2			 
0da2			; eof 
0da2			 
# End of file firmware_maths.asm
0da2			include "firmware_strings.asm"   ; string handling  
0da2			 
0da2			 
0da2			; TODO string len 
0da2			; input text string, end on cr with zero term 
0da2			; a offset into frame buffer to start prompt 
0da2			; d is max length 
0da2			; e is display size TODO 
0da2			; c is current cursor position 
0da2			; hl is ptr to where string will be stored 
0da2			 
0da2			 
0da2			; TODO check limit of buffer for new inserts 
0da2			; TODO check insert does not push beyond buffer 
0da2			; TODO scroll in a limited display area 
0da2			; TODO scroll whole screen on page wrap 
0da2			 
0da2			 
0da2			; TODO handle KEY_PREVWORD 
0da2			; TODO handle KEY_NEXTWORD 
0da2			; TODO handle KEY_HOME 
0da2			; TODO handle KEY_END 
0da2			; TODO use LCD cursor? 
0da2			 
0da2 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0da5 81					add c 
0da6 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0da9 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0dac 79					ld a, c 
0dad cd 75 0d				call addatohl 
0db0 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0db3 7a					ld a,d 
0db4 32 6c ee			        ld (input_size), a       ; save length of input area 
0db7 79					ld a, c 
0db8 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0dbb 7b					ld a,e 
0dbc 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0dbf					 
0dbf					 
0dbf			 
0dbf			;		ld a,(input_ptr) 
0dbf			;		ld (input_under_cursor),a 	; save what is under the cursor 
0dbf			 
0dbf			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0dbf					; init cursor shape if not set by the cin routines 
0dbf 21 ca eb				ld hl, cursor_shape 
0dc2 3e ff				ld a, 255 
0dc4 77					ld (hl), a 
0dc5 23					inc hl 
0dc6 3e 00				ld a, 0 
0dc8 77					ld (hl), a 
0dc9			 
0dc9 3e 0f				ld a, CUR_BLINK_RATE 
0dcb 32 66 ee				ld (input_cur_flash), a 
0dce 3e 01				ld a, 1 
0dd0 32 65 ee				ld (input_cur_onoff),a 
0dd3			 
0dd3			;	if DEBUG_INPUT 
0dd3			;		push af 
0dd3			;		ld a, 'I' 
0dd3			;		ld (debug_mark),a 
0dd3			;		pop af 
0dd3			;		CALLMONITOR 
0dd3			;	endif 
0dd3			.is1:		; main entry loop 
0dd3			 
0dd3			 
0dd3			 
0dd3					; pause 1ms 
0dd3			 
0dd3 3e 01				ld a, 1 
0dd5 cd 9f 0a				call aDelayInMS 
0dd8			 
0dd8					; dec flash counter 
0dd8 3a 66 ee				ld a, (input_cur_flash) 
0ddb 3d					dec a 
0ddc 32 66 ee				ld (input_cur_flash), a 
0ddf fe 00				cp 0 
0de1 20 0d				jr nz, .nochgstate 
0de3			 
0de3			 
0de3					; change state 
0de3 3a 65 ee				ld a,(input_cur_onoff) 
0de6 ed 44				neg 
0de8 32 65 ee				ld (input_cur_onoff),a 
0deb			 
0deb			 
0deb					; reset on change of state 
0deb 3e 0f				ld a, CUR_BLINK_RATE 
0ded 32 66 ee				ld (input_cur_flash), a 
0df0			 
0df0			.nochgstate: 
0df0					 
0df0					 
0df0			 
0df0					; display cursor  
0df0			 
0df0			;		ld hl, (input_start) 
0df0			;		ld a, (input_cursor) 
0df0			;		call addatohl 
0df0			 
0df0					; get char under cursor and replace with cursor 
0df0 2a 6f ee		ld hl, (input_ptr) 
0df3			;		ld a, (hl) 
0df3			;		ld (input_under_cursor),a 
0df3			;		ld a, '_' 
0df3			;		ld (hl), a 
0df3			 
0df3					; display string 
0df3			 
0df3 ed 5b 6d ee			ld de, (input_start) 
0df7 3a 6a ee				ld a, (input_at_pos) 
0dfa cd 5b 0b				call str_at_display 
0dfd			;	        call update_display 
0dfd			 
0dfd					; find place to put the cursor 
0dfd			;		add h 
0dfd			;		ld l, display_row_1 
0dfd			;		sub l 
0dfd			; (input_at_pos) 
0dfd					;ld c, a 
0dfd			;		ld a, (input_cursor) 
0dfd			;		ld l, (input_at_pos) 
0dfd			;		;ld b, h 
0dfd			;		add l 
0dfd			;		ld (input_at_cursor),a 
0dfd					;ld l,h 
0dfd			 
0dfd			;		ld h, 0 
0dfd			;		ld l,(input_at_pos) 
0dfd			;		ld a, (input_cursor) 
0dfd			;		call addatohl 
0dfd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0dfd			;		call subafromhl 
0dfd			;		ld a,l 
0dfd			;		ld (input_at_cursor), a 
0dfd			 
0dfd				if DEBUG_INPUT 
0dfd					ld a, (hardware_diag) 
0dfd					cp 0 
0dfd					jr z, .skip_input_diag 
0dfd			 
0dfd					ld a,(input_at_pos) 
0dfd					ld hl, LFSRSeed 
0dfd					call hexout 
0dfd					ld a, (input_cursor) 
0dfd					ld hl, LFSRSeed+2 
0dfd					call hexout 
0dfd					ld a,(input_at_cursor) 
0dfd					ld hl, LFSRSeed+4 
0dfd					call hexout 
0dfd			 
0dfd					ld a,(input_cur_onoff) 
0dfd					ld hl, LFSRSeed+6 
0dfd					call hexout 
0dfd			 
0dfd					ld a,(input_cur_flash) 
0dfd					ld hl, LFSRSeed+8 
0dfd					call hexout 
0dfd			 
0dfd					ld a,(input_len) 
0dfd					ld hl, LFSRSeed+10 
0dfd					call hexout 
0dfd					ld hl, LFSRSeed+12 
0dfd					ld a, 0 
0dfd					ld (hl),a 
0dfd					ld a, display_row_4 
0dfd					ld de, LFSRSeed 
0dfd					call str_at_display 
0dfd					.skip_input_diag: 
0dfd				endif 
0dfd			 
0dfd					; decide on if we are showing the cursor this time round 
0dfd			 
0dfd 3a 65 ee				ld a, (input_cur_onoff) 
0e00 fe ff				cp 255 
0e02 28 13				jr z, .skipcur 
0e04			 
0e04			 
0e04 3a 68 ee				ld a,(input_at_cursor) 
0e07 11 ca eb				ld de, cursor_shape 
0e0a cd 5b 0b				call str_at_display 
0e0d			 
0e0d					; save length of current input string 
0e0d 2a 6d ee				ld hl, (input_start) 
0e10 cd d3 11				call strlenz 
0e13 7d					ld a,l 
0e14 32 60 ee				ld (input_len),a 
0e17			 
0e17			.skipcur: 
0e17			 
0e17 cd 6b 0b			        call update_display 
0e1a					 
0e1a			 
0e1a			 
0e1a					; wait 
0e1a				 
0e1a					; TODO loop without wait to flash the cursor and char under cursor	 
0e1a cd 9d 5b				call cin    ; _wait 
0e1d			 
0e1d fe 00				cp 0 
0e1f ca d3 0d				jp z, .is1 
0e22			 
0e22					; get ptr to char to input into 
0e22			 
0e22 4f					ld c,a 
0e23 2a 6d ee				ld hl, (input_start) 
0e26 3a 5b ee				ld a, (input_cursor) 
0e29 cd 75 0d				call addatohl 
0e2c 22 6f ee				ld (input_ptr), hl 
0e2f 79					ld a,c 
0e30			 
0e30					; replace char under cursor 
0e30			 
0e30			;		ld hl, (input_ptr) 
0e30			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0e30			;		ld (hl), a 
0e30			 
0e30			;	if DEBUG_INPUT 
0e30			;		push af 
0e30			;		ld a, 'i' 
0e30			;		ld (debug_mark),a 
0e30			;		pop af 
0e30			;		CALLMONITOR 
0e30			;	endif 
0e30 fe 0e				cp KEY_HOME 
0e32 20 0e				jr nz, .iske 
0e34			 
0e34 3a 6a ee				ld a, (input_at_pos) 
0e37 32 68 ee				ld (input_at_cursor),a 
0e3a 3e 00				ld a, 0 
0e3c 32 5b ee				ld (input_cursor), a 
0e3f c3 d3 0d				jp .is1 
0e42					 
0e42 fe 0f		.iske:		cp KEY_END 
0e44 20 03				jr nz, .isknw 
0e46 c3 d3 0d				jp .is1 
0e49			 
0e49 fe 06		.isknw:		cp KEY_NEXTWORD 
0e4b 20 1b				jr nz, .iskpw 
0e4d			 
0e4d 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0e50 7e					ld a,(hl)	 
0e51 fe 00				cp 0 
0e53 ca d3 0d				jp z, .is1    ; end of string 
0e56 fe 20				cp ' ' 
0e58 ca d3 0d				jp z, .is1    ; end of word 
0e5b 23					inc hl 
0e5c 22 6f ee				ld (input_ptr), hl 
0e5f 3a 68 ee				ld a, (input_at_cursor) 
0e62 3c					inc a 
0e63 32 68 ee				ld (input_at_cursor), a 
0e66 18 e5				jr .isknwm 
0e68			 
0e68 fe 07		.iskpw:		cp KEY_PREVWORD 
0e6a 20 1b				jr nz, .iskl 
0e6c			.iskpwm:	 
0e6c 2a 6f ee				ld hl, (input_ptr) 
0e6f 7e					ld a,(hl)	 
0e70 fe 00				cp 0  
0e72 ca d3 0d				jp z, .is1    ; end of string 
0e75 fe 20				cp ' ' 
0e77 ca d3 0d				jp z, .is1    ; end of word 
0e7a 2b					dec hl 
0e7b 22 6f ee				ld (input_ptr), hl 
0e7e 3a 68 ee				ld a, (input_at_cursor) 
0e81 3d					dec a 
0e82 32 68 ee				ld (input_at_cursor), a 
0e85 18 e5				jr .iskpwm 
0e87			 
0e87			 
0e87 fe 0b		.iskl:		cp KEY_LEFT 
0e89 20 27				jr nz, .isk1 
0e8b			 
0e8b 3a 5b ee				ld a, (input_cursor) 
0e8e			 
0e8e fe 00				cp 0 
0e90 ca d3 0d				jp z, .is1 		; at start of line to ignore  
0e93			 
0e93 3d					dec  a 		; TODO check underflow 
0e94 32 5b ee				ld (input_cursor), a 
0e97			 
0e97 2a 6f ee				ld hl, (input_ptr) 
0e9a 2b					dec hl 
0e9b 22 6f ee				ld (input_ptr), hl 
0e9e					 
0e9e 3a 68 ee				ld a, (input_at_cursor) 
0ea1 3d					dec a 
0ea2 32 68 ee				ld (input_at_cursor), a 
0ea5			 
0ea5 3e 01				ld a, 1		; show cursor moving 
0ea7 32 65 ee				ld (input_cur_onoff),a 
0eaa 3e 0f				ld a, CUR_BLINK_RATE 
0eac 32 66 ee				ld (input_cur_flash), a 
0eaf			 
0eaf c3 d3 0d				jp .is1 
0eb2			 
0eb2 fe 0c		.isk1:		cp KEY_RIGHT 
0eb4 20 2a				jr nz, .isk2 
0eb6			 
0eb6 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0eb9 5f					ld e,a 
0eba 3a 5b ee				ld a, (input_cursor) 
0ebd bb					cp e 
0ebe ca d3 0d				jp z, .is1		; at the end of string so dont go right 
0ec1			 
0ec1 3c					inc  a 		; TODO check overflow 
0ec2 32 5b ee				ld (input_cursor), a 
0ec5			 
0ec5 3a 68 ee				ld a, (input_at_cursor) 
0ec8 3c					inc a 
0ec9 32 68 ee				ld (input_at_cursor), a 
0ecc			 
0ecc 2a 6f ee				ld hl, (input_ptr) 
0ecf 23					inc hl 
0ed0 22 6f ee				ld (input_ptr), hl 
0ed3			 
0ed3 3e 01				ld a, 1		; show cursor moving 
0ed5 32 65 ee				ld (input_cur_onoff),a 
0ed8 3e 0f				ld a, CUR_BLINK_RATE 
0eda 32 66 ee				ld (input_cur_flash), a 
0edd			 
0edd c3 d3 0d				jp .is1 
0ee0			 
0ee0 fe 05		.isk2:		cp KEY_UP 
0ee2			 
0ee2 20 26				jr nz, .isk3 
0ee4			 
0ee4					; swap last command with the current on 
0ee4			 
0ee4					; move cursor to start of string 
0ee4 2a 6d ee				ld hl, (input_start) 
0ee7 22 6f ee				ld (input_ptr), hl 
0eea			 
0eea 3a 6a ee				ld a, (input_at_pos) 
0eed 32 68 ee				ld (input_at_cursor), a 
0ef0			 
0ef0 3e 00				ld a, 0 
0ef2 32 5b ee				ld (input_cursor), a 
0ef5					 
0ef5					; swap input and last command buffers 
0ef5			 
0ef5 21 29 e6				ld hl, os_cli_cmd 
0ef8 11 28 e7				ld de, os_last_cmd 
0efb 06 ff				ld b, 255 
0efd 7e			.swap1:		ld a, (hl) 
0efe 4f					ld c,a 
0eff 1a					ld a, (de) 
0f00 77					ld (hl), a 
0f01 79					ld a,c 
0f02 12					ld (de),a 
0f03 23					inc hl 
0f04 13					inc de 
0f05 10 f6				djnz .swap1 
0f07			 
0f07			 
0f07			 
0f07			 
0f07			 
0f07 c3 d3 0d				jp .is1 
0f0a			 
0f0a fe 08		.isk3:		cp KEY_BS 
0f0c 20 3c				jr nz, .isk4 
0f0e			 
0f0e 3a 5b ee				ld a, (input_cursor) 
0f11			 
0f11 fe 00				cp 0 
0f13 ca d3 0d				jp z, .is1 		; at start of line to ignore  
0f16			 
0f16 3d					dec  a 		; TODO check underflow 
0f17 32 5b ee				ld (input_cursor), a 
0f1a			 
0f1a					; hl is source 
0f1a					; de needs to be source - 1 
0f1a			 
0f1a			;		ld a, 0 
0f1a			;		dec hl 
0f1a			;		ld (hl), a 
0f1a			 
0f1a 2a 6f ee				ld hl, (input_ptr) 
0f1d 2b					dec hl 
0f1e 22 6f ee				ld (input_ptr), hl 
0f21			 
0f21					; shift all data 
0f21			 
0f21 e5					push hl 
0f22 23					inc hl 
0f23 d1					pop de 
0f24 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f27 4f					ld c,a 
0f28 06 00				ld b,0 
0f2a ed b0				ldir  
0f2c			 
0f2c			 
0f2c			 
0f2c			 
0f2c 3a 68 ee				ld a, (input_at_cursor) 
0f2f 3d					dec a 
0f30 32 68 ee				ld (input_at_cursor), a 
0f33			 
0f33			 
0f33 3e 01				ld a, 1		; show cursor moving 
0f35 32 65 ee				ld (input_cur_onoff),a 
0f38 3e 0f				ld a, CUR_BLINK_RATE 
0f3a 32 66 ee				ld (input_cur_flash), a 
0f3d			 
0f3d					; remove char 
0f3d 3a 68 ee				ld a, (input_at_cursor) 
0f40 3c					inc a 
0f41 11 cb 0f				ld de,.iblank 
0f44 cd 5b 0b				call str_at_display 
0f47			 
0f47 c3 d3 0d				jp .is1 
0f4a			 
0f4a fe 0d		.isk4:		cp KEY_CR 
0f4c 28 6c				jr z, .endinput 
0f4e			 
0f4e					; else add the key press to the end 
0f4e			 
0f4e 4f					ld c, a			; save key pressed 
0f4f			 
0f4f 7e					ld a,(hl)		; get what is currently under char 
0f50			 
0f50 fe 00				cp 0			; we are at the end of the string 
0f52 20 2f				jr nz, .onchar 
0f54					 
0f54					; add a char to the end of the string 
0f54				 
0f54 71					ld (hl),c 
0f55 23					inc hl 
0f56			;		ld a,' ' 
0f56			;		ld (hl),a 
0f56			;		inc hl 
0f56 3e 00				ld a,0 
0f58 77					ld (hl),a 
0f59 2b					dec hl 
0f5a			 
0f5a 3a 5b ee				ld a, (input_cursor) 
0f5d 3c					inc a				; TODO check max string length and scroll  
0f5e 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0f61							 
0f61 3a 68 ee				ld a, (input_at_cursor) 
0f64 3c					inc a 
0f65 32 68 ee				ld (input_at_cursor), a 
0f68			 
0f68 2a 6f ee				ld hl, (input_ptr) 
0f6b 23					inc hl 
0f6c 22 6f ee				ld (input_ptr), hl 
0f6f			 
0f6f 2a 6f ee				ld hl, (input_ptr) 
0f72 23					inc hl 
0f73 22 6f ee				ld (input_ptr), hl 
0f76			;	if DEBUG_INPUT 
0f76			;		push af 
0f76			;		ld a, '+' 
0f76			;		ld (debug_mark),a 
0f76			;		pop af 
0f76			;		CALLMONITOR 
0f76			;	endif 
0f76 3e 01				ld a, 1		; show cursor moving 
0f78 32 65 ee				ld (input_cur_onoff),a 
0f7b 3e 0f				ld a, CUR_BLINK_RATE 
0f7d 32 66 ee				ld (input_cur_flash), a 
0f80 c3 d3 0d				jp .is1 
0f83					 
0f83			 
0f83			 
0f83					; if on a char then insert 
0f83			.onchar: 
0f83			 
0f83					; TODO over flow check: make sure insert does not blow out buffer 
0f83			 
0f83					; need to do some maths to use lddr 
0f83			 
0f83 e5					push hl   ; save char pos 
0f84 c5					push bc 
0f85			 
0f85 2a 6d ee				ld hl, (input_start) 
0f88 3a 60 ee				ld a, (input_len) 
0f8b cd 75 0d				call addatohl  		; end of string 
0f8e 23					inc hl 
0f8f 23					inc hl		; past zero term 
0f90 e5					push hl 
0f91 23					inc hl 
0f92 e5					push hl  
0f93			 
0f93								; start and end of lddr set, now how much to move? 
0f93			 
0f93							 
0f93 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f96 47					ld b,a 
0f97 3a 60 ee				ld a,(input_len) 
0f9a 5f					ld e,a 
0f9b 90					sub b 
0f9c 3c					inc a		;?? 
0f9d 3c					inc a		;?? 
0f9e 3c					inc a		;?? 
0f9f			 
0f9f 06 00				ld b,0 
0fa1 4f					ld c,a 
0fa2			 
0fa2				if DEBUG_INPUT 
0fa2					push af 
0fa2					ld a, 'i' 
0fa2					ld (debug_mark),a 
0fa2					pop af 
0fa2			;		CALLMONITOR 
0fa2				endif 
0fa2 d1					pop de 
0fa3 e1					pop hl 
0fa4				if DEBUG_INPUT 
0fa4					push af 
0fa4					ld a, 'I' 
0fa4					ld (debug_mark),a 
0fa4					pop af 
0fa4			;		CALLMONITOR 
0fa4				endif 
0fa4 ed b8				lddr 
0fa6				 
0fa6			 
0fa6			 
0fa6					; TODO have a key for insert/overwrite mode???? 
0fa6 c1					pop bc 
0fa7 e1					pop hl 
0fa8 71					ld (hl), c		; otherwise overwrite current char 
0fa9					 
0fa9			 
0fa9			 
0fa9			 
0fa9 3a 5b ee				ld a, (input_cursor) 
0fac 3c					inc  a 		; TODO check overflow 
0fad 32 5b ee				ld (input_cursor), a 
0fb0			 
0fb0 3a 68 ee				ld a, (input_at_cursor) 
0fb3 3c					inc a 
0fb4 32 68 ee				ld (input_at_cursor), a 
0fb7			 
0fb7 c3 d3 0d				jp .is1 
0fba			 
0fba			.endinput:	; TODO look for end of string 
0fba			 
0fba					; add trailing space for end of token 
0fba			 
0fba 2a 6d ee				ld hl, (input_start) 
0fbd 3a 60 ee				ld a,(input_len) 
0fc0 cd 75 0d				call addatohl 
0fc3 3e 20				ld a, ' ' 
0fc5 77					ld (hl),a 
0fc6					; TODO eof of parse marker 
0fc6			 
0fc6 23					inc hl 
0fc7 3e 00				ld a, 0 
0fc9 77					ld (hl),a 
0fca			 
0fca			 
0fca c9					ret 
0fcb			 
0fcb .. 00		.iblank: db " ",0 
0fcd			 
0fcd			 
0fcd 32 6a ee		input_str_prev:	ld (input_at_pos), a 
0fd0 22 6d ee				ld (input_start), hl 
0fd3 3e 01				ld a,1			; add cursor 
0fd5 77					ld (hl),a 
0fd6 23					inc hl 
0fd7 3e 00				ld a,0 
0fd9 77					ld (hl),a 
0fda 22 6f ee				ld (input_ptr), hl 
0fdd 7a					ld a,d 
0fde 32 6c ee				ld (input_size), a 
0fe1 3e 00				ld a,0 
0fe3 32 5b ee				ld (input_cursor),a 
0fe6			.instr1:	 
0fe6			 
0fe6					; TODO do block cursor 
0fe6					; TODO switch cursor depending on the modifer key 
0fe6			 
0fe6					; update cursor shape change on key hold 
0fe6			 
0fe6 2a 6f ee				ld hl, (input_ptr) 
0fe9 2b					dec hl 
0fea 3a ca eb				ld a,(cursor_shape) 
0fed 77					ld (hl), a 
0fee			 
0fee					; display entered text 
0fee 3a 6a ee				ld a,(input_at_pos) 
0ff1 cd b2 5a		            	CALL fLCD_Pos       ;Position cursor to location in A 
0ff4 ed 5b 6d ee	            	LD   de, (input_start) 
0ff8 cd a7 5a		            	CALL fLCD_Str       ;Display string pointed to by DE 
0ffb			 
0ffb cd 9d 5b				call cin 
0ffe fe 00				cp 0 
1000 28 e4				jr z, .instr1 
1002			 
1002					; proecess keyboard controls first 
1002			 
1002 2a 6f ee				ld hl,(input_ptr) 
1005			 
1005 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1007 28 5a				jr z, .instrcr 
1009			 
1009 fe 08				cp KEY_BS 	; back space 
100b 20 0f				jr nz, .instr2 
100d					; process back space 
100d			 
100d					; TODO stop back space if at start of string 
100d 2b					dec hl 
100e 2b					dec hl ; to over write cursor 
100f 3a ca eb				ld a,(cursor_shape) 
1012					;ld a,0 
1012 77					ld (hl),a 
1013 23					inc hl 
1014 3e 20				ld a," " 
1016 77					ld (hl),a 
1017 22 6f ee				ld (input_ptr),hl 
101a					 
101a			 
101a 18 ca				jr .instr1 
101c			 
101c fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
101e 20 06				jr nz, .instr3 
1020 2b					dec hl 
1021 22 6f ee				ld (input_ptr),hl 
1024 18 c0				jr .instr1 
1026				 
1026 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1028 20 06				jr nz, .instr4 
102a 23					inc hl 
102b 22 6f ee				ld (input_ptr),hl 
102e 18 b6				jr .instr1 
1030			 
1030 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1032 20 06				jr nz, .instr5 
1034 2b					dec hl 
1035 22 6f ee				ld (input_ptr),hl 
1038 18 ac				jr .instr1 
103a			 
103a fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
103c 20 06				jr nz, .instr6 
103e 2b					dec hl 
103f 22 6f ee				ld (input_ptr),hl 
1042 18 a2				jr .instr1 
1044 fe 05		.instr6:        cp KEY_UP      ; recall last command 
1046 20 0b				jr nz, .instrnew 
1048			 
1048 21 02 e3			ld hl, scratch 
104b 11 28 e7			ld de, os_last_cmd 
104e cd 6c 10			call strcpy 
1051 18 93				jr .instr1 
1053			 
1053			 
1053			.instrnew:	; no special key pressed to see if we have room to store it 
1053			 
1053					; TODO do string size test 
1053			 
1053 2b					dec hl ; to over write cursor 
1054 77					ld (hl),a 
1055 23					inc hl 
1056 3a ca eb				ld a,(cursor_shape) 
1059 77					ld (hl),a 
105a 23					inc hl 
105b 3e 00				ld a,0 
105d 77					ld (hl),a 
105e			 
105e 22 6f ee				ld (input_ptr),hl 
1061					 
1061 18 83				jr .instr1 
1063 2b			.instrcr:	dec hl		; remove cursor 
1064 3e 20				ld a,' '	; TODO add a trailing space for safety 
1066 77					ld (hl),a 
1067 23					inc hl 
1068 3e 00				ld a,0 
106a 77					ld (hl),a 
106b			 
106b			 
106b					; if at end of line scroll up    
106b					; TODO detecting only end of line 4 for scroll up  
106b			 
106b					;ld   
106b			 
106b c9					ret 
106c			 
106c			 
106c			; strcpy hl = dest, de source 
106c			 
106c 1a			strcpy:   LD   A, (DE)        ;Get character from string 
106d b7			            OR   A              ;Null terminator? 
106e c8			            RET  Z              ;Yes, so finished 
106f 1a					ld a,(de) 
1070 77					ld (hl),a 
1071 13			            INC  DE             ;Point to next character 
1072 23					inc hl 
1073 18 f7		            JR   strcpy       ;Repeat 
1075 c9					ret 
1076			 
1076			 
1076			; TODO string_at  
1076			; pass string which starts with lcd offset address and then null term string 
1076			 
1076			; TODO string to dec 
1076			; TODO string to hex 
1076			; TODO byte to string hex 
1076			; TODO byte to string dec 
1076			 
1076			 
1076			 
1076			; from z80uartmonitor 
1076			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1076			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1076			; pass hl for where to put the text 
1076			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1076 c5			hexout:	PUSH BC 
1077 f5					PUSH AF 
1078 47					LD B, A 
1079					; Upper nybble 
1079 cb 3f				SRL A 
107b cb 3f				SRL A 
107d cb 3f				SRL A 
107f cb 3f				SRL A 
1081 cd 91 10				CALL tohex 
1084 77					ld (hl),a 
1085 23					inc hl	 
1086					 
1086					; Lower nybble 
1086 78					LD A, B 
1087 e6 0f				AND 0FH 
1089 cd 91 10				CALL tohex 
108c 77					ld (hl),a 
108d 23					inc hl	 
108e					 
108e f1					POP AF 
108f c1					POP BC 
1090 c9					RET 
1091					 
1091			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1091			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1091			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1091			tohex: 
1091 e5					PUSH HL 
1092 d5					PUSH DE 
1093 16 00				LD D, 0 
1095 5f					LD E, A 
1096 21 9e 10				LD HL, .DATA 
1099 19					ADD HL, DE 
109a 7e					LD A, (HL) 
109b d1					POP DE 
109c e1					POP HL 
109d c9					RET 
109e			 
109e			.DATA: 
109e 30					DEFB	30h	; 0 
109f 31					DEFB	31h	; 1 
10a0 32					DEFB	32h	; 2 
10a1 33					DEFB	33h	; 3 
10a2 34					DEFB	34h	; 4 
10a3 35					DEFB	35h	; 5 
10a4 36					DEFB	36h	; 6 
10a5 37					DEFB	37h	; 7 
10a6 38					DEFB	38h	; 8 
10a7 39					DEFB	39h	; 9 
10a8 41					DEFB	41h	; A 
10a9 42					DEFB	42h	; B 
10aa 43					DEFB	43h	; C 
10ab 44					DEFB	44h	; D 
10ac 45					DEFB	45h	; E 
10ad 46					DEFB	46h	; F 
10ae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10ae			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
10ae			;;    subtract $30, if result > 9 then subtract $7 more 
10ae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10ae			atohex: 
10ae d6 30				SUB $30 
10b0 fe 0a				CP 10 
10b2 f8					RET M		; If result negative it was 0-9 so we're done 
10b3 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
10b5 c9					RET		 
10b6			 
10b6			 
10b6			 
10b6			 
10b6			; Get 2 ASCII characters as hex byte from pointer in hl 
10b6			 
10b6			BYTERD: 
10b6 16 00			LD	D,00h		;Set up 
10b8 cd c0 10			CALL	HEXCON		;Get byte and convert to hex 
10bb 87				ADD	A,A		;First nibble so 
10bc 87				ADD	A,A		;multiply by 16 
10bd 87				ADD	A,A		; 
10be 87				ADD	A,A		; 
10bf 57				LD	D,A		;Save hi nibble in D 
10c0			HEXCON: 
10c0 7e				ld a, (hl)		;Get next chr 
10c1 23				inc hl 
10c2 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
10c4 fe 0a			CP	00Ah		;Is it 0-9 ? 
10c6 38 02			JR	C,NALPHA	;If so miss next bit 
10c8 d6 07			SUB	007h		;Else convert alpha 
10ca			NALPHA: 
10ca b2				OR	D		;Add hi nibble back 
10cb c9				RET			; 
10cc			 
10cc			 
10cc			; 
10cc			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
10cc			; Since the routines get_byte and therefore get_nibble are called, only valid 
10cc			; characters (0-9a-f) are accepted. 
10cc			; 
10cc			;get_word        push    af 
10cc			;                call    get_byte        ; Get the upper byte 
10cc			;                ld      h, a 
10cc			;                call    get_byte        ; Get the lower byte 
10cc			;                ld      l, a 
10cc			;                pop     af 
10cc			;                ret 
10cc			; 
10cc			; Get a byte in hexadecimal notation. The result is returned in A. Since 
10cc			; the routine get_nibble is used only valid characters are accepted - the  
10cc			; input routine only accepts characters 0-9a-f. 
10cc			; 
10cc c5			get_byte:        push    bc              ; Save contents of B (and C) 
10cd 7e					ld a,(hl) 
10ce 23					inc hl 
10cf cd f4 10		                call    nibble2val      ; Get upper nibble 
10d2 cb 07		                rlc     a 
10d4 cb 07		                rlc     a 
10d6 cb 07		                rlc     a 
10d8 cb 07		                rlc     a 
10da 47			                ld      b, a            ; Save upper four bits 
10db 7e					ld a,(hl) 
10dc cd f4 10		                call    nibble2val      ; Get lower nibble 
10df b0			                or      b               ; Combine both nibbles 
10e0 c1			                pop     bc              ; Restore B (and C) 
10e1 c9			                ret 
10e2			; 
10e2			; Get a hexadecimal digit from the serial line. This routine blocks until 
10e2			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
10e2			; to the serial line interface. The lower 4 bits of A contain the value of  
10e2			; that particular digit. 
10e2			; 
10e2			;get_nibble      ld a,(hl)           ; Read a character 
10e2			;                call    to_upper        ; Convert to upper case 
10e2			;                call    is_hex          ; Was it a hex digit? 
10e2			;                jr      nc, get_nibble  ; No, get another character 
10e2			 ;               call    nibble2val      ; Convert nibble to value 
10e2			 ;               call    print_nibble 
10e2			 ;               ret 
10e2			; 
10e2			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
10e2			; A valid hexadecimal digit is denoted by a set C flag. 
10e2			; 
10e2			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
10e2			;                ret     nc              ; Yes 
10e2			;                cp      '0'             ; Less than '0'? 
10e2			;                jr      nc, is_hex_1    ; No, continue 
10e2			;                ccf                     ; Complement carry (i.e. clear it) 
10e2			;                ret 
10e2			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
10e2			;                ret     c               ; Yes 
10e2			;                cp      'A'             ; Less than 'A'? 
10e2			;                jr      nc, is_hex_2    ; No, continue 
10e2			;                ccf                     ; Yes - clear carry and return 
10e2			;                ret 
10e2			;is_hex_2        scf                     ; Set carry 
10e2			;                ret 
10e2			; 
10e2			; Convert a single character contained in A to upper case: 
10e2			; 
10e2 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
10e4 d8			                ret     c 
10e5 fe 7b		                cp      'z' + 1         ; > 'z'? 
10e7 d0			                ret     nc              ; Nothing to do, either 
10e8 e6 5f		                and     $5f             ; Convert to upper case 
10ea c9			                ret 
10eb			 
10eb			 
10eb			to_lower: 
10eb			 
10eb			   ; if char is in [A-Z] make it lower case 
10eb			 
10eb			   ; enter : a = char 
10eb			   ; exit  : a = lower case char 
10eb			   ; uses  : af 
10eb			 
10eb fe 41		   cp 'A' 
10ed d8			   ret c 
10ee			    
10ee fe 5b		   cp 'Z'+1 
10f0 d0			   ret nc 
10f1			    
10f1 f6 20		   or $20 
10f3 c9			   ret 
10f4			 
10f4			; 
10f4			; Expects a hexadecimal digit (upper case!) in A and returns the 
10f4			; corresponding value in A. 
10f4			; 
10f4 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
10f6 38 02		                jr      c, nibble2val_1 ; Yes 
10f8 d6 07		                sub     7               ; Adjust for A-F 
10fa d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
10fc e6 0f		                and     $f              ; Only return lower 4 bits 
10fe c9			                ret 
10ff			; 
10ff			; Print_nibble prints a single hex nibble which is contained in the lower  
10ff			; four bits of A: 
10ff			; 
10ff			;print_nibble    push    af              ; We won't destroy the contents of A 
10ff			;                and     $f              ; Just in case... 
10ff			;                add     a, '0'             ; If we have a digit we are done here. 
10ff			;                cp      '9' + 1         ; Is the result > 9? 
10ff			;                jr      c, print_nibble_1 
10ff			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
10ff			;print_nibble_1  call    putc            ; Print the nibble and 
10ff			;                pop     af              ; restore the original value of A 
10ff			;                ret 
10ff			;; 
10ff			;; Send a CR/LF pair: 
10ff			; 
10ff			;crlf            push    af 
10ff			;                ld      a, cr 
10ff			;                call    putc 
10ff			;                ld      a, lf 
10ff			;                call    putc 
10ff			;                pop     af 
10ff			;                ret 
10ff			; 
10ff			; Print_word prints the four hex digits of a word to the serial line. The  
10ff			; word is expected to be in HL. 
10ff			; 
10ff			;print_word      push    hl 
10ff			;                push    af 
10ff			;                ld      a, h 
10ff			;                call    print_byte 
10ff			;                ld      a, l 
10ff			;                call    print_byte 
10ff			;                pop     af 
10ff			;                pop     hl 
10ff			;                ret 
10ff			; 
10ff			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
10ff			; The byte to be printed is expected to be in A. 
10ff			; 
10ff			;print_byte      push    af              ; Save the contents of the registers 
10ff			;                push    bc 
10ff			;                ld      b, a 
10ff			;                rrca 
10ff			;                rrca 
10ff			;                rrca 
10ff			;                rrca 
10ff			;                call    print_nibble    ; Print high nibble 
10ff			;                ld      a, b 
10ff			;                call    print_nibble    ; Print low nibble 
10ff			;                pop     bc              ; Restore original register contents 
10ff			;                pop     af 
10ff			;                ret 
10ff			 
10ff			 
10ff			 
10ff			 
10ff			 
10ff			fourehexhl:  
10ff 7e				ld a,(hl) 
1100 cd ae 10			call atohex 
1103 cb 3f				SRL A 
1105 cb 3f				SRL A 
1107 cb 3f				SRL A 
1109 cb 3f				SRL A 
110b 47				ld b, a 
110c 23				inc hl 
110d 7e				ld a,(hl) 
110e 23				inc hl 
110f cd ae 10			call atohex 
1112 80				add b 
1113 57				ld d,a 
1114 7e				ld a,(hl) 
1115 cd ae 10			call atohex 
1118 cb 3f				SRL A 
111a cb 3f				SRL A 
111c cb 3f				SRL A 
111e cb 3f				SRL A 
1120 47				ld b, a 
1121 23				inc hl 
1122 7e				ld a,(hl) 
1123 23				inc hl 
1124 cd ae 10			call atohex 
1127 80				add b 
1128 5f				ld e, a 
1129 d5				push de 
112a e1				pop hl 
112b c9				ret 
112c			 
112c			; pass hl. returns z set if the byte at hl is a digit 
112c			;isdigithl:  
112c			;	push bc 
112c			;	ld a,(hl) 
112c			;	cp ':' 
112c			;	jr nc, .isdf 		; > 
112c			;	cp '0' 
112c			;	jr c, .isdf		; < 
112c			; 
112c			;	; TODO find a better way to set z 
112c			; 
112c			;	ld b,a 
112c			;	cp b 
112c			;	pop bc 
112c			;	ret 
112c			; 
112c			;.isdf:	; not digit so clear z 
112c			; 
112c			;	; TODO find a better way to unset z 
112c			; 
112c			;	ld b,a 
112c			;	inc b 
112c			;	cp b 
112c			; 
112c			;	pop bc 
112c			;	ret 
112c				 
112c				 
112c			 
112c			 
112c			; pass hl as the four byte address to load 
112c			 
112c			get_word_hl:  
112c e5				push hl 
112d cd cc 10			call get_byte 
1130				 
1130 47				ld b, a 
1131			 
1131 e1				pop hl 
1132 23				inc hl 
1133 23				inc hl 
1134			 
1134			; TODO not able to handle a-f  
1134 7e				ld a,(hl) 
1135			;	;cp ':' 
1135			;	cp 'g' 
1135			;	jr nc, .single_byte_hl 		; > 
1135			;	cp 'G' 
1135			;	jr nc, .single_byte_hl 		; > 
1135			;	cp '0' 
1135			;	jr c, .single_byte_hl		; < 
1135			 
1135				;call isdigithl 
1135 fe 00			cp 0 
1137 28 06			jr z, .single_byte_hl 
1139			 
1139			.getwhln:   ; hex word so get next byte 
1139			 
1139 cd cc 10			call get_byte 
113c 6f				ld l, a 
113d 60				ld h,b 
113e c9				ret 
113f 68			.single_byte_hl:   ld l,b 
1140 26 00				ld h,0 
1142 c9					ret 
1143			 
1143			 
1143			 
1143			 
1143 21 fe 18			ld hl,asc+1 
1146			;	ld a, (hl) 
1146			;	call nibble2val 
1146 cd cc 10			call get_byte 
1149			 
1149			;	call fourehexhl 
1149 32 36 e3			ld (scratch+52),a 
114c				 
114c 21 34 e3			ld hl,scratch+50 
114f 22 25 e6			ld (os_cur_ptr),hl 
1152			 
1152 c9				ret 
1153			 
1153			 
1153			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1153			 
1153			; Decimal Unsigned Version 
1153			 
1153			;Number in a to decimal ASCII 
1153			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1153			;Example: display a=56 as "056" 
1153			;input: a = number 
1153			;Output: a=0,value of a in the screen 
1153			;destroys af,bc (don't know about hl and de) 
1153			DispAToASCII: 
1153 0e 9c			ld	c,-100 
1155 cd 5f 11			call	.Na1 
1158 0e f6			ld	c,-10 
115a cd 5f 11			call	.Na1 
115d 0e ff			ld	c,-1 
115f 06 2f		.Na1:	ld	b,'0'-1 
1161 04			.Na2:	inc	b 
1162 81				add	a,c 
1163 38 fc			jr	c,.Na2 
1165 91				sub	c		;works as add 100/10/1 
1166 f5				push af		;safer than ld c,a 
1167 78				ld	a,b		;char is in b 
1168			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1168 f1				pop af		;safer than ld a,c 
1169 c9				ret 
116a			 
116a			; Decimal Signed Version 
116a			 
116a			; DispA 
116a			; -------------------------------------------------------------- 
116a			; Converts a signed integer value to a zero-terminated ASCII 
116a			; string representative of that value (using radix 10). 
116a			; -------------------------------------------------------------- 
116a			; INPUTS: 
116a			;     HL     Value to convert (two's complement integer). 
116a			;     DE     Base address of string destination. (pointer). 
116a			; -------------------------------------------------------------- 
116a			; OUTPUTS: 
116a			;     None 
116a			; -------------------------------------------------------------- 
116a			; REGISTERS/MEMORY DESTROYED 
116a			; AF HL 
116a			; -------------------------------------------------------------- 
116a			 
116a			;DispHLToASCII: 
116a			;   push    de 
116a			;   push    bc 
116a			; 
116a			;; Detect sign of HL. 
116a			;    bit    7, h 
116a			;    jr     z, ._DoConvert 
116a			; 
116a			;; HL is negative. Output '-' to string and negate HL. 
116a			;    ld     a, '-' 
116a			;    ld     (de), a 
116a			;    inc    de 
116a			; 
116a			;; Negate HL (using two's complement) 
116a			;    xor    a 
116a			;    sub    l 
116a			;    ld     l, a 
116a			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
116a			;    sbc    a, h 
116a			;    ld     h, a 
116a			; 
116a			;; Convert HL to digit characters 
116a			;._DoConvert: 
116a			;    ld     b, 0     ; B will count character length of number 
116a			;-   ld     a, 10 
116a			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
116a			;    push   af 
116a			;    inc    b 
116a			;    ld     a, h 
116a			;    or     l 
116a			;    jr     nz, - 
116a			; 
116a			;; Retrieve digits from stack 
116a			;-   pop    af 
116a			;    or     $30 
116a			;    ld     (de), a 
116a			;    inc    de 
116a			;    djnz   - 
116a			; 
116a			;; Terminate string with NULL 
116a			;    xor    a 
116a			;    ld     (de), a 
116a			; 
116a			;    pop    bc 
116a			;    pop    de 
116a			;    ret 
116a			 
116a			;Comments 
116a			; 
116a			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
116a			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
116a			;    Note that the output string will not be fixed-width. 
116a			; 
116a			;Example Usage 
116a			; 
116a			;    ld    hl, -1004 
116a			;    ld    de, OP1 
116a			;    call  DispA 
116a			;    ld    hl, OP1 
116a			;    syscall  PutS 
116a			 
116a			 
116a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
116a			 
116a			 
116a			;Converts an ASCII string to an unsigned 16-bit integer 
116a			;Quits when it reaches a non-decimal digit 
116a			 
116a			string_to_uint16: 
116a			atoui_16: 
116a			;Input: 
116a			;     DE points to the string 
116a			;Outputs: 
116a			;     HL is the result 
116a			;     A is the 8-bit value of the number 
116a			;     DE points to the byte after the number 
116a			;Destroys: 
116a			;     BC 
116a			;       if the string is non-empty, BC is HL/10 
116a			;Size:  24 bytes 
116a			;Speed: 42+d(104+{0,9}) 
116a			;       d is the number of digits in the number 
116a			;       max is 640 cycles for a 5 digit number 
116a			;Assuming no leading zeros: 
116a			;1 digit:  146cc 
116a			;2 digit:  250cc 
116a			;3 digit:  354cc or 363cc (avg: 354.126cc) 
116a			;4 digit:  458cc or 467cc (avg: 458.27cc) 
116a			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
116a			;avg: 544.81158447265625cc (544+13297/16384) 
116a			;=============================================================== 
116a 21 00 00		  ld hl,0 
116d			.u16a: 
116d 1a			  ld a,(de) 
116e d6 30		  sub 30h 
1170 fe 0a		  cp 10 
1172 d0			  ret nc 
1173 13			  inc de 
1174 44			  ld b,h 
1175 4d			  ld c,l 
1176 29			  add hl,hl 
1177 29			  add hl,hl 
1178 09			  add hl,bc 
1179 29			  add hl,hl 
117a 85			  add a,l 
117b 6f			  ld l,a 
117c 30 ef		  jr nc,.u16a 
117e 24			  inc h 
117f c3 6d 11		  jp .u16a 
1182			 
1182			 
1182			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1182			 
1182			;written by Zeda 
1182			;Converts a 16-bit unsigned integer to an ASCII string. 
1182			 
1182			uitoa_16: 
1182			;Input: 
1182			;   DE is the number to convert 
1182			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1182			;Output: 
1182			;   HL points to the null-terminated ASCII string 
1182			;      NOTE: This isn't necessarily the same as the input HL. 
1182 d5			  push de 
1183 c5			  push bc 
1184 f5			  push af 
1185 eb			  ex de,hl 
1186			 
1186 01 f0 d8		  ld bc,-10000 
1189 3e 2f		  ld a,'0'-1 
118b 3c			  inc a 
118c 09			  add hl,bc  
118d 38 fc		   jr c,$-2 
118f 12			  ld (de),a 
1190 13			  inc de 
1191			 
1191 01 e8 03		  ld bc,1000 
1194 3e 3a		  ld a,'9'+1 
1196 3d			  dec a  
1197 09			  add hl,bc  
1198 30 fc		   jr nc,$-2 
119a 12			  ld (de),a 
119b 13			  inc de 
119c			 
119c 01 9c ff		  ld bc,-100 
119f 3e 2f		  ld a,'0'-1 
11a1 3c			  inc a  
11a2 09			  add hl,bc  
11a3 38 fc		   jr c,$-2 
11a5 12			  ld (de),a 
11a6 13			  inc de 
11a7			 
11a7 7d			  ld a,l 
11a8 26 3a		  ld h,'9'+1 
11aa 25			  dec h  
11ab c6 0a		  add a,10  
11ad 30 fb		   jr nc,$-3 
11af c6 30		  add a,'0' 
11b1 eb			  ex de,hl 
11b2 72			  ld (hl),d 
11b3 23			  inc hl 
11b4 77			  ld (hl),a 
11b5 23			  inc hl 
11b6 36 00		  ld (hl),0 
11b8			 
11b8			;Now strip the leading zeros 
11b8 0e fa		  ld c,-6 
11ba 09			  add hl,bc 
11bb 3e 30		  ld a,'0' 
11bd 23			  inc hl  
11be be			  cp (hl)  
11bf 28 fc		  jr z,$-2 
11c1			 
11c1			;Make sure that the string is non-empty! 
11c1 7e			  ld a,(hl) 
11c2 b7			  or a 
11c3 20 01		  jr nz,.atoub 
11c5 2b			  dec hl 
11c6			.atoub: 
11c6			 
11c6 f1			  pop af 
11c7 c1			  pop bc 
11c8 d1			  pop de 
11c9 c9			  ret 
11ca			 
11ca			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
11ca			 
11ca			toUpper: 
11ca			;A is the char. 
11ca			;If A is a lowercase letter, this sets it to the matching uppercase 
11ca			;18cc or 30cc or 41cc 
11ca			;avg: 26.75cc 
11ca fe 61		  cp 'a' 
11cc d8			  ret c 
11cd fe 7b		  cp 'z'+1 
11cf d0			  ret nc 
11d0 d6 20		  sub 'a'-'A' 
11d2 c9			  ret 
11d3			 
11d3			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
11d3			 
11d3			; String Length 
11d3			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
11d3			 
11d3			; Get the length of the null-terminated string starting at $8000 hl 
11d3			;    LD     HL, $8000 
11d3			 
11d3			strlenz: 
11d3			 
11d3 af			    XOR    A               ; Zero is the value we are looking for. 
11d4 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
11d5 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
11d6			                           ; 65, 536 bytes (the entire addressable memory space). 
11d6 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
11d8			 
11d8			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
11d8 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
11d9 6f			    LD     L, A             ; number of bytes 
11da ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
11dc 2b			    DEC    HL              ; Compensate for null. 
11dd c9				ret 
11de			 
11de			; Get the length of the A terminated string starting at $8000 hl 
11de			;    LD     HL, $8000 
11de			 
11de			strlent: 
11de			 
11de			                  ; A is the value we are looking for. 
11de 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
11e0 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
11e2			                           ; 65, 536 bytes (the entire addressable memory space). 
11e2 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
11e4			 
11e4			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
11e4 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
11e6 2e 00		    LD     L, 0             ; number of bytes 
11e8 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
11ea 2b			    DEC    HL              ; Compensate for null. 
11eb c9				ret 
11ec			 
11ec			 
11ec			;Comparing Strings 
11ec			 
11ec			;IN    HL     Address of string1. 
11ec			;      DE     Address of string2. 
11ec			 
11ec			; doc given but wrong??? 
11ec			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
11ec			;      carry  Set if string1 > string2, reset if string1 <= string2. 
11ec			; tested 
11ec			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
11ec			 
11ec			strcmp_old: 
11ec e5			    PUSH   HL 
11ed d5			    PUSH   DE 
11ee			 
11ee 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
11ef be			    CP     (HL)            ; (want to minimize work). 
11f0 38 01		    JR     C, Str1IsBigger 
11f2 7e			    LD     A, (HL) 
11f3			 
11f3			Str1IsBigger: 
11f3 4f			    LD     C, A             ; Put length in BC 
11f4 06 00		    LD     B, 0 
11f6 13			    INC    DE              ; Increment pointers to meat of string. 
11f7 23			    INC    HL 
11f8			 
11f8			CmpLoop: 
11f8 1a			    LD     A, (DE)          ; Compare bytes. 
11f9 ed a1		    CPI 
11fb 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
11fd 13			    INC    DE              ; Update pointer. 
11fe ea f8 11		    JP     PE, CmpLoop 
1201			 
1201 d1			    POP    DE 
1202 e1			    POP    HL 
1203 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1204 be			    CP     (HL) 
1205 c9			    RET 
1206			 
1206			NoMatch: 
1206 2b			    DEC    HL 
1207 be			    CP     (HL)            ; Compare again to affect carry. 
1208 d1			    POP    DE 
1209 e1			    POP    HL 
120a c9			    RET 
120b			 
120b			;; test strmp 
120b			; 
120b			;ld de, .str1 
120b			;ld hl, .str2 
120b			;call strcmp 
120b			;jr z, .z1 
120b			;;this 
120b			;	if DEBUG_FORTH_WORDS 
120b			;		DMARK "NZ1" 
120b			;		CALLMONITOR 
120b			;	endif 
120b			;.z1: 
120b			; 
120b			;	if DEBUG_FORTH_WORDS 
120b			;		DMARK "ZZ1" 
120b			;		CALLMONITOR 
120b			;	endif 
120b			; 
120b			;ld de, .str1 
120b			;ld hl, .str1 
120b			;call strcmp 
120b			;jr z, .z2 
120b			;;this 
120b			;	if DEBUG_FORTH_WORDS 
120b			;		DMARK "NZ2" 
120b			;		CALLMONITOR 
120b			;	endif 
120b			;.z2: 
120b			; 
120b			;	if DEBUG_FORTH_WORDS 
120b			;		DMARK "ZZ2" 
120b			;		CALLMONITOR 
120b			;	endif 
120b			; 
120b			;ld de, .str1 
120b			;ld hl, .str2 
120b			;call strcmp 
120b			;jr c, .c1 
120b			; 
120b			;	if DEBUG_FORTH_WORDS 
120b			;		DMARK "Nc1" 
120b			;		CALLMONITOR 
120b			;	endif 
120b			;.c1: 
120b			;;this 
120b			;	if DEBUG_FORTH_WORDS 
120b			;		DMARK "cc1" 
120b			;		CALLMONITOR 
120b			;	endif 
120b			; 
120b			;ld de, .str1 
120b			;ld hl, .str1 
120b			;call strcmp 
120b			;jr c, .c2 
120b			;;this 
120b			;	if DEBUG_FORTH_WORDS 
120b			;		DMARK "Nc2" 
120b			;		CALLMONITOR 
120b			;	endif 
120b			;.c2: 
120b			; 
120b			;	if DEBUG_FORTH_WORDS 
120b			;		DMARK "cc2" 
120b			;		CALLMONITOR 
120b			;	endif 
120b			;	NEXTW 
120b			;.str1:   db "string1",0 
120b			;.str2:   db "string2",0 
120b			 
120b			; only care about direct match or not 
120b			; hl and de strings 
120b			; zero set if the same 
120b			 
120b			strcmp: 
120b 1a				ld a, (de) 
120c be				cp (hl) 
120d 28 02			jr z, .ssame 
120f b7				or a 
1210 c9				ret 
1211			 
1211			.ssame:  
1211 fe 00			cp 0 
1213 c8				ret z 
1214			 
1214 23				inc hl 
1215 13				inc de 
1216 18 f3			jr strcmp 
1218				 
1218				 
1218			 
1218			 
1218			 
1218			 
1218			; eof 
1218			 
1218			 
1218			 
1218			 
1218			 
1218			 
# End of file firmware_strings.asm
1218			include "firmware_memory.asm"   ; malloc and free  
1218			 
1218			if DEBUG_FORTH_MALLOC_HIGH 
1218			.mallocsize: db "Wants malloc >256",0 
1218			.mallocasize: db "MALLOC gives >256",0 
1218			.malloczero: db "MALLOC gives zero",0 
1218			 
1218			malloc_guard_zerolen: 
1218				push hl 
1218				push de 
1218				push af 
1218			 
1218				ld de, 0 
1218			        call cmp16 
1218				jr nz, .lowalloz 
1218			 
1218				push hl 
1218				push de 
1218					ld hl, display_fb0 
1218					ld (display_fb_active), hl 
1218				call clear_display 
1218				ld a, 0 
1218				ld de, .malloczero 
1218				call str_at_display 
1218				call update_display 
1218				call delay1s 
1218				call delay1s 
1218				ld a, 0 
1218				ld (os_view_disable), a 
1218			 
1218				pop de 
1218				pop hl 
1218			 
1218				 
1218			 
1218				CALLMONITOR 
1218			.lowalloz: 
1218			 
1218			 
1218				pop af 
1218				pop de 
1218				pop hl 
1218			ret 
1218			 
1218			malloc_guard_entry: 
1218				push hl 
1218				push de 
1218				push af 
1218			 
1218			 	or a      ;clear carry flag 
1218				push hl 
1218				ld de, 255 
1218				sbc hl, de 
1218				jr c, .lowalloc 
1218			 
1218				push de 
1218					ld hl, display_fb0 
1218					ld (display_fb_active), hl 
1218				call clear_display 
1218				ld a, 0 
1218				ld de, .mallocsize 
1218				call str_at_display 
1218				call update_display 
1218				call delay1s 
1218				call delay1s 
1218				ld a, 0 
1218				ld (os_view_disable), a 
1218			 
1218				pop de 
1218				pop hl 
1218			 
1218				 
1218			 
1218				CALLMONITOR 
1218				jr .lowdone 
1218			.lowalloc: 
1218			 
1218			 
1218				pop hl 
1218			.lowdone:	pop af 
1218				pop de 
1218				pop hl 
1218			ret 
1218			 
1218			malloc_guard_exit: 
1218				push hl 
1218				push de 
1218				push af 
1218			 
1218			 	or a      ;clear carry flag 
1218				push hl 
1218				ld de, 255 
1218				sbc hl, de 
1218				jr c, .lowallocx 
1218			 
1218				push de 
1218					ld hl, display_fb0 
1218					ld (display_fb_active), hl 
1218				call clear_display 
1218				ld a, 0 
1218				ld de, .mallocasize 
1218				call str_at_display 
1218				call update_display 
1218				call delay1s 
1218				call delay1s 
1218				ld a, 0 
1218				ld (os_view_disable), a 
1218				pop de 
1218				pop hl 
1218			 
1218				CALLMONITOR 
1218				jr .lowdonex 
1218			.lowallocx: 
1218			 
1218				pop hl 
1218			.lowdonex:	pop af 
1218				pop de 
1218				pop hl 
1218			ret 
1218			endif 
1218			 
1218			if MALLOC_2 
1218			; Z80 Malloc and Free Functions 
1218			 
1218			; Malloc Function: 
1218			; Input: 
1218			;   HL: Size of block to allocate 
1218			; Output: 
1218			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1218			 
1218			malloc: 
1218				 
1218			if DEBUG_FORTH_MALLOC_HIGH 
1218			call malloc_guard_entry 
1218			endif 
1218			 
1218			 
1218			 
1218			 
1218					if DEBUG_FORTH_MALLOC 
1218						DMARK "mal" 
1218						CALLMONITOR 
1218					endif 
1218			    push af            ; Save AF register 
1218			    ld a, l            ; Load low byte of size into A 
1218			    or h               ; Check if size is zero 
1218			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1218			 
1218			    ; Allocate memory 
1218			    ld hl, (heap_start) ; Load start of heap into HL 
1218					if DEBUG_FORTH_MALLOC 
1218						DMARK "ma1" 
1218						CALLMONITOR 
1218					endif 
1218			    call malloc_internal ; Call internal malloc function 
1218			    pop af             ; Restore AF register 
1218			if DEBUG_FORTH_MALLOC_HIGH 
1218			call malloc_guard_exit 
1218			call malloc_guard_zerolen 
1218			endif 
1218			    ret                ; Return 
1218			 
1218			; Free Function: 
1218			; Input: 
1218			;   HL: Pointer to memory block to free 
1218			; Output: 
1218			;   None 
1218			 
1218			free: 
1218			    push af            ; Save AF register 
1218			    ld a, l            ; Load low byte of pointer into A 
1218			    or h               ; Check if pointer is NULL 
1218			    jp z, free_exit    ; If pointer is NULL, exit 
1218			 
1218			    ; Free memory 
1218			    ld hl, (heap_start) ; Load start of heap into HL 
1218			    call free_internal  ; Call internal free function 
1218			    pop af             ; Restore AF register 
1218			    ret                ; Return 
1218			 
1218			; Internal Malloc Function: 
1218			; Input: 
1218			;   HL: Size of block to allocate 
1218			; Output: 
1218			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1218			 
1218			malloc_internal: 
1218			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1218			    add hl, bc         ; Add management overhead to requested size 
1218			    ex de, hl          ; Save total size in DE, and keep it in HL 
1218					if DEBUG_FORTH_MALLOC 
1218						DMARK "ma2" 
1218						CALLMONITOR 
1218					endif 
1218			 
1218			    ; Search for free memory block 
1218			    ld de, (heap_end)  ; Load end of heap into DE 
1218			    ld bc, 0           ; Initialize counter 
1218			 
1218					if DEBUG_FORTH_MALLOC 
1218						DMARK "ma2" 
1218						CALLMONITOR 
1218					endif 
1218			malloc_search_loop: 
1218			    ; Check if current block is free 
1218			    ld a, (hl)         ; Load current block's status (free or used) 
1218			    cp 0               ; Compare with zero (free) 
1218			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1218			 
1218			    ; Check if current block is large enough 
1218			    ld a, (hl+1)       ; Load high byte of block size 
1218			    cp l               ; Compare with low byte of requested size 
1218			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1218			 
1218			    ld a, (hl+2)       ; Load low byte of block size 
1218			    cp h               ; Compare with high byte of requested size 
1218			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1218			 
1218			    ; Mark block as used 
1218			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1218			 
1218			    ; Calculate remaining space in block 
1218			    ld bc, 0           ; Clear BC 
1218			    add hl, bc         ; Increment HL to point to start of data block 
1218			    add hl, de         ; HL = HL + DE (total size) 
1218			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1218			    add hl, bc         ; Add management overhead to start of data block 
1218			 
1218			    ; Save pointer to allocated block in HL 
1218			if DEBUG_FORTH_MALLOC_HIGH 
1218						DMARK "ma5" 
1218			call malloc_guard_exit 
1218			call malloc_guard_zerolen 
1218			endif 
1218			    ret 
1218			 
1218			malloc_skip_block_check: 
1218			    ; Move to the next block 
1218			    ld bc, 3           ; Size of management overhead 
1218			    add hl, bc         ; Move to the next block 
1218			    inc de             ; Increment counter 
1218			 
1218			    ; Check if we have reached the end of heap 
1218			    ld a, e            ; Load low byte of heap end address 
1218			    cp (hl)            ; Compare with low byte of current address 
1218			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1218			    ld a, d            ; Load high byte of heap end address 
1218			    cp 0               ; Check if it's zero (end of memory) 
1218			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1218			 
1218			    ; If we reached here, allocation failed 
1218			    xor a              ; Set result to NULL 
1218			if DEBUG_FORTH_MALLOC_HIGH 
1218						DMARK "ma6" 
1218			call malloc_guard_exit 
1218			call malloc_guard_zerolen 
1218			endif 
1218			    ret 
1218			malloc_exit: 
1218			if DEBUG_FORTH_MALLOC_HIGH 
1218						DMARK "ma7" 
1218			call malloc_guard_exit 
1218			call malloc_guard_zerolen 
1218			endif 
1218			    ret 
1218			 
1218			; Internal Free Function: 
1218			; Input: 
1218			;   HL: Pointer to memory block to free 
1218			; Output: 
1218			;   None 
1218			 
1218			free_internal: 
1218			    ld de, (heap_start) ; Load start of heap into DE 
1218			    ld bc, 0            ; Initialize counter 
1218			 
1218			free_search_loop: 
1218			    ; Check if current block contains the pointer 
1218			    ld a, l             ; Load low byte of pointer 
1218			    cp (hl+1)           ; Compare with high byte of current block's address 
1218			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1218			    ld a, h             ; Load high byte of pointer 
1218			    cp (hl+2)           ; Compare with low byte of current block's address 
1218			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1218			 
1218			    ; Mark block as free 
1218			    ld (hl), 0          ; Set status byte to indicate free block 
1218			    ret                 ; Return 
1218			 
1218			free_skip_block_check: 
1218			    ; Move to the next block 
1218			    ld bc, 3            ; Size of management overhead 
1218			    add hl, bc          ; Move to the next block 
1218			    inc de              ; Increment counter 
1218			 
1218			    ; Check if we have reached the end of heap 
1218			    ld a, e             ; Load low byte of heap end address 
1218			    cp (hl)             ; Compare with low byte of current address 
1218			    jr nz, free_search_loop  ; If not equal, continue searching 
1218			    ld a, d             ; Load high byte of heap end address 
1218			    cp 0                ; Check if it's zero (end of memory) 
1218			    jr nz, free_search_loop  ; If not zero, continue searching 
1218			 
1218			    ; If we reached here, pointer is not found in heap 
1218			    ret 
1218			 
1218			free_exit: 
1218			    ret                 ; Return 
1218			 
1218			; Define heap start and end addresses 
1218			;heap_start:    .dw 0xC000   ; Start of heap 
1218			;heap_end:      .dw 0xE000   ; End of heap 
1218			 
1218			endif 
1218			 
1218			 
1218			if MALLOC_1 
1218			 
1218			 
1218			 
1218			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1218			 
1218			;moved to firmware.asm 
1218			;heap_start        .equ  0x9000      ; Starting address of heap 
1218			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1218			 
1218			;      .org 0 
1218			;      jp    main 
1218			 
1218			 
1218			;      .org  0x100 
1218			;main: 
1218			;      ld    HL, 0x8100 
1218			;      ld    SP, HL 
1218			; 
1218			;      call  heap_init 
1218			; 
1218			;      ; Make some allocations 
1218			;      ld    HL, 12 
1218			;      call  malloc            ; Allocates 0x9004 
1218			; 
1218			;      ld    HL, 12 
1218			;      call  malloc            ; Allocates 0x9014 
1218			; 
1218			;      ld    HL, 12 
1218			;      call  malloc            ; Allocates 0x9024 
1218			; 
1218			;      ; Free some allocations 
1218			;      ld    HL, 0x9014 
1218			;      call  free 
1218			; 
1218			;      ld    HL, 0x9004 
1218			;      call  free 
1218			; 
1218			;      ld    HL, 0x9024 
1218			;      call  free 
1218			; 
1218			; 
1218			;      halt 
1218			 
1218			 
1218			;------------------------------------------------------------------------------ 
1218			;     heap_init                                                               : 
1218			;                                                                             : 
1218			; Description                                                                 : 
1218			;     Initialise the heap and make it ready for malloc and free operations.   : 
1218			;                                                                             : 
1218			;     The heap is maintained as a linked list, starting with an initial       : 
1218			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1218			;     the first free block in the heap. Each block then points to the next    : 
1218			;     free block within the heap, and the free list ends at the first block   : 
1218			;     with a null pointer to the next free block.                             : 
1218			;                                                                             : 
1218			; Parameters                                                                  : 
1218			;     Inputs are compile-time only. Two defines which specify the starting    : 
1218			;     address of the heap and its size are required, along with a memory      : 
1218			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1218			;     principally stores a pointer to the first free block in the heap.       : 
1218			;                                                                             : 
1218			; Returns                                                                     : 
1218			;     Nothing                                                                 : 
1218			;------------------------------------------------------------------------------ 
1218			heap_init: 
1218 e5			      push  HL 
1219			 
1219			      ; Initialise free list struct 
1219 21 c5 5b		      ld    HL, heap_start 
121c 22 c0 5b		      ld    (free_list), HL 
121f 21 00 00		      ld    HL, 0 
1222 22 c2 5b		      ld    (free_list+2), HL 
1225			 
1225			      ; Insert first free block at bottom of heap, consumes entire heap 
1225 21 e4 e2		      ld    HL, heap_start+heap_size-4 
1228 22 c5 5b		      ld    (heap_start), HL        ; Next block (end of free list) 
122b 21 1f 87		      ld    HL, heap_size-4 
122e 22 c7 5b		      ld    (heap_start+2), HL      ; Block size 
1231			 
1231			      ; Insert end of free list block at top of heap - two null words will 
1231			      ; terminate the free list 
1231 21 00 00		      ld    HL, 0 
1234 22 e6 e2		      ld    (heap_start+heap_size-2), HL 
1237 22 e4 e2		      ld    (heap_start+heap_size-4), HL 
123a			 
123a e1			      pop   HL 
123b			 
123b c9			      ret 
123c			 
123c			 
123c			;------------------------------------------------------------------------------ 
123c			;     malloc                                                                  : 
123c			;                                                                             : 
123c			; Description                                                                 : 
123c			;     Allocates the wanted space from the heap and returns the address of the : 
123c			;     first useable byte of the allocation.                                   : 
123c			;                                                                             : 
123c			;     Allocations can happen in one of two ways:                              : 
123c			;                                                                             : 
123c			;     1. A free block may be found which is the exact size wanted. In this    : 
123c			;        case the block is removed from the free list and retuedn to the      : 
123c			;        caller.                                                              : 
123c			;     2. A free block may be found which is larger than the size wanted. In   : 
123c			;        this case, the larger block is split into two. The first portion of  : 
123c			;        this block will become the requested space by the malloc call and    : 
123c			;        is returned to the caller. The second portion becomes a new free     : 
123c			;        block, and the free list is adjusted to maintain continuity via this : 
123c			;        newly created block.                                                 : 
123c			;                                                                             : 
123c			;     malloc does not set any initial value in the allocated space, the       : 
123c			;     caller is required to do this as required.                              : 
123c			;                                                                             : 
123c			;     This implementation of malloc uses the stack exclusively, and is        : 
123c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
123c			;     advisable to disable interrupts before calling malloc, and recommended  : 
123c			;     to avoid the use of malloc inside ISRs in general.                      : 
123c			;                                                                             : 
123c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
123c			;                                                                             : 
123c			; Parameters                                                                  : 
123c			;     HL  Number of bytes wanted                                              : 
123c			;                                                                             : 
123c			; Returns                                                                     : 
123c			;     HL  Address of the first useable byte of the allocation                 : 
123c			;                                                                             : 
123c			; Flags                                                                       : 
123c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
123c			;                                                                             : 
123c			; Stack frame                                                                 : 
123c			;       |             |                                                       : 
123c			;       +-------------+                                                       : 
123c			;       |     BC      |                                                       : 
123c			;       +-------------+                                                       : 
123c			;       |     DE      |                                                       : 
123c			;       +-------------+                                                       : 
123c			;       |     IX      |                                                       : 
123c			;       +-------------+                                                       : 
123c			;       |  prev_free  |                                                       : 
123c			;   +4  +-------------+                                                       : 
123c			;       |  this_free  |                                                       : 
123c			;   +2  +-------------+                                                       : 
123c			;       |  next_free  |                                                       : 
123c			;   +0  +-------------+                                                       : 
123c			;       |             |                                                       : 
123c			;                                                                             : 
123c			;------------------------------------------------------------------------------ 
123c			 
123c			 
123c			;malloc: 
123c			; 
123c			;	SAVESP ON 1 
123c			; 
123c			;	call malloc_code 
123c			; 
123c			;	CHECKSP ON 1 
123c			;	ret 
123c			 
123c			 
123c			malloc: 
123c c5			      push  BC 
123d d5			      push  DE 
123e dd e5		      push  IX 
1240			if DEBUG_FORTH_MALLOC_HIGH 
1240			call malloc_guard_entry 
1240			endif 
1240			 
1240					if DEBUG_FORTH_MALLOC 
1240						DMARK "mal" 
1240						CALLMONITOR 
1240					endif 
1240 7c			      ld    A, H                    ; Exit if no space requested 
1241 b5			      or    L 
1242 ca 01 13		      jp    Z, malloc_early_exit 
1245			 
1245			;inc hl 
1245			;inc hl 
1245			;inc hl 
1245			; 
1245			;inc hl 
1245			;inc hl 
1245			;inc hl 
1245			;inc hl 
1245			;inc hl 
1245			;inc hl 
1245			;inc hl 
1245			;inc hl 
1245			;inc hl 
1245			 
1245			 
1245			 
1245			 
1245					if DEBUG_FORTH_MALLOC 
1245						DMARK "maA" 
1245						CALLMONITOR 
1245					endif 
1245			      ; Set up stack frame 
1245 eb			      ex    DE, HL 
1246 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1249 39			      add   HL, SP 
124a f9			      ld    SP, HL 
124b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
124f dd 39		      add   IX, SP 
1251			 
1251			      ; Setup initial state 
1251 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1254 19			      add   HL, DE 
1255			 
1255 44			      ld    B, H                    ; Move want to BC 
1256 4d			      ld    C, L 
1257			 
1257 21 c0 5b		      ld    HL, free_list           ; Store prev_free ptr to stack 
125a dd 75 04		      ld    (IX+4), L 
125d dd 74 05		      ld    (IX+5), H 
1260			 
1260 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1261 23			      inc   HL 
1262 56			      ld    D, (HL) 
1263 dd 73 02		      ld    (IX+2), E 
1266 dd 72 03		      ld    (IX+3), D 
1269 eb			      ex    DE, HL                  ; this_free ptr into HL 
126a			 
126a					if DEBUG_FORTH_MALLOC 
126a						DMARK "maB" 
126a						CALLMONITOR 
126a					endif 
126a			      ; Loop through free block list to find some space 
126a			malloc_find_space: 
126a 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
126b 23			      inc   HL 
126c 56			      ld    D, (HL) 
126d			 
126d 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
126e b3			      or    E 
126f ca fb 12		      jp    Z, malloc_no_space 
1272			 
1272 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1275 dd 72 01		      ld    (IX+1), D 
1278			 
1278			      ; Does this block have enough space to make the allocation? 
1278 23			      inc   HL                      ; Load free block size into DE 
1279 5e			      ld    E, (HL) 
127a 23			      inc   HL 
127b 56			      ld    D, (HL) 
127c			 
127c eb			      ex    DE, HL                  ; Check size of block against want 
127d b7			      or    A                       ; Ensure carry flag clear 
127e ed 42		      sbc   HL, BC 
1280 e5			      push  HL                      ; Store the result for later (new block size) 
1281			 
1281 ca d0 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1284 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1286			 
1286			      ; this_free block is not big enough, setup ptrs to test next free block 
1286 e1			      pop   HL                      ; Discard previous result 
1287			 
1287 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
128a dd 66 03		      ld    H, (IX+3) 
128d dd 75 04		      ld    (IX+4), L 
1290 dd 74 05		      ld    (IX+5), H 
1293			 
1293 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1296 dd 66 01		      ld    H, (IX+1) 
1299 dd 75 02		      ld    (IX+2), L 
129c dd 74 03		      ld    (IX+3), H 
129f			 
129f					if DEBUG_FORTH_MALLOC 
129f						DMARK "MA>" 
129f						CALLMONITOR 
129f					endif 
129f 18 c9		      jr    malloc_find_space 
12a1			 
12a1			      ; split a bigger block into two - requested size and remaining size 
12a1			malloc_alloc_split: 
12a1					if DEBUG_FORTH_MALLOC 
12a1						DMARK "MAs" 
12a1						CALLMONITOR 
12a1					endif 
12a1 eb			      ex    DE, HL                  ; Calculate address of new free block 
12a2 2b			      dec   HL 
12a3 2b			      dec   HL 
12a4 2b			      dec   HL 
12a5 09			      add   HL, BC 
12a6			 
12a6			      ; Create a new block and point it at next_free 
12a6 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
12a9 dd 56 01		      ld    D, (IX+1) 
12ac			 
12ac 73			      ld    (HL), E                 ; Store next_free ptr into new block 
12ad 23			      inc   HL 
12ae 72			      ld    (HL), D 
12af			 
12af d1			      pop   DE                      ; Store size of new block into new block 
12b0 23			      inc   HL 
12b1 73			      ld    (HL), E 
12b2 23			      inc   HL 
12b3 72			      ld    (HL), D 
12b4			 
12b4			      ; Update this_free ptr to point to new block 
12b4 2b			      dec   HL 
12b5 2b			      dec   HL 
12b6 2b			      dec   HL 
12b7			 
12b7 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
12ba dd 56 03		      ld    D, (IX+3) 
12bd			 
12bd dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
12c0 dd 74 03		      ld    (IX+3), H 
12c3			 
12c3			      ; Modify this_free block to be allocation 
12c3 eb			      ex    DE, HL 
12c4 af			      xor   A                       ; Null the next block ptr of allocated block 
12c5 77			      ld    (HL), A 
12c6 23			      inc   HL 
12c7 77			      ld    (HL), A 
12c8			 
12c8 23			      inc   HL                      ; Store want size into allocated block 
12c9 71			      ld    (HL), C 
12ca 23			      inc   HL 
12cb 70			      ld    (HL), B 
12cc 23			      inc   HL 
12cd e5			      push  HL                      ; Address of allocation to return 
12ce			 
12ce 18 19		      jr    malloc_update_links 
12d0			 
12d0			malloc_alloc_fit: 
12d0 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
12d1			 
12d1					if DEBUG_FORTH_MALLOC 
12d1						DMARK "MAf" 
12d1						CALLMONITOR 
12d1					endif 
12d1			      ; Modify this_free block to be allocation 
12d1 eb			      ex    DE, HL 
12d2 2b			      dec   HL 
12d3 2b			      dec   HL 
12d4 2b			      dec   HL 
12d5			 
12d5 af			      xor   A                       ; Null the next block ptr of allocated block 
12d6 77			      ld    (HL), A 
12d7 23			      inc   HL 
12d8 77			      ld    (HL), A 
12d9			 
12d9 23			      inc   HL                      ; Store address of allocation to return 
12da 23			      inc   HL 
12db 23			      inc   HL 
12dc e5			      push  HL 
12dd			 
12dd			      ; Copy next_free ptr to this_free, remove allocated block from free list 
12dd dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
12e0 dd 66 01		      ld    H, (IX+1) 
12e3			 
12e3 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
12e6 dd 74 03		      ld    (IX+3), H 
12e9			 
12e9			 
12e9			malloc_update_links: 
12e9			      ; Update prev_free ptr to point to this_free 
12e9 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
12ec dd 66 05		      ld    H, (IX+5) 
12ef			 
12ef dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
12f2 dd 56 03		      ld    D, (IX+3) 
12f5			 
12f5 73			      ld    (HL), E                 ; this_free ptr into prev_free 
12f6 23			      inc   HL 
12f7 72			      ld    (HL), D 
12f8			 
12f8					if DEBUG_FORTH_MALLOC 
12f8						DMARK "Mul" 
12f8						CALLMONITOR 
12f8					endif 
12f8			      ; Clear the Z flag to indicate successful allocation 
12f8 7a			      ld    A, D 
12f9 b3			      or    E 
12fa			 
12fa d1			      pop   DE                      ; Address of allocation 
12fb					if DEBUG_FORTH_MALLOC 
12fb						DMARK "MAu" 
12fb						CALLMONITOR 
12fb					endif 
12fb			 
12fb			malloc_no_space: 
12fb 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
12fe 39			      add   HL, SP 
12ff f9			      ld    SP, HL 
1300			 
1300 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1301					if DEBUG_FORTH_MALLOC 
1301						DMARK "MAN" 
1301						CALLMONITOR 
1301					endif 
1301			 
1301			malloc_early_exit: 
1301					if DEBUG_FORTH_MALLOC 
1301						DMARK "MAx" 
1301						CALLMONITOR 
1301					endif 
1301 dd e1		      pop   IX 
1303 d1			      pop   DE 
1304 c1			      pop   BC 
1305			 
1305			if DEBUG_FORTH_MALLOC_HIGH 
1305			call malloc_guard_exit 
1305			call malloc_guard_zerolen 
1305			endif 
1305 c9			      ret 
1306			 
1306			 
1306			;------------------------------------------------------------------------------ 
1306			;     free                                                                    : 
1306			;                                                                             : 
1306			; Description                                                                 : 
1306			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1306			;     returned by malloc, otherwise the behaviour is undefined.               : 
1306			;                                                                             : 
1306			;     Where possible, directly adjacent free blocks will be merged together   : 
1306			;     into larger blocks to help ensure that the heap does not become         : 
1306			;     excessively fragmented.                                                 : 
1306			;                                                                             : 
1306			;     free does not clear or set any other value into the freed space, and    : 
1306			;     therefore its contents may be visible through subsequent malloc's. The  : 
1306			;     caller should clear the freed space as required.                        : 
1306			;                                                                             : 
1306			;     This implementation of free uses the stack exclusively, and is          : 
1306			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1306			;     advisable to disable interrupts before calling free, and recommended    : 
1306			;     to avoid the use of free inside ISRs in general.                        : 
1306			;                                                                             : 
1306			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1306			;                                                                             : 
1306			; Parameters                                                                  : 
1306			;     HL  Pointer to address of first byte of allocation to be freed          : 
1306			;                                                                             : 
1306			; Returns                                                                     : 
1306			;     Nothing                                                                 : 
1306			;                                                                             : 
1306			; Stack frame                                                                 : 
1306			;       |             |                                                       : 
1306			;       +-------------+                                                       : 
1306			;       |     BC      |                                                       : 
1306			;       +-------------+                                                       : 
1306			;       |     DE      |                                                       : 
1306			;       +-------------+                                                       : 
1306			;       |     IX      |                                                       : 
1306			;       +-------------+                                                       : 
1306			;       |  prev_free  |                                                       : 
1306			;   +2  +-------------+                                                       : 
1306			;       |  next_free  |                                                       : 
1306			;   +0  +-------------+                                                       : 
1306			;       |             |                                                       : 
1306			;                                                                             : 
1306			;------------------------------------------------------------------------------ 
1306			free: 
1306 c5			      push  BC 
1307 d5			      push  DE 
1308 dd e5		      push  IX 
130a			 
130a 7c			      ld    A, H                    ; Exit if ptr is null 
130b b5			      or    L 
130c ca d0 13		      jp    Z, free_early_exit 
130f			 
130f			      ; Set up stack frame 
130f eb			      ex    DE, HL 
1310 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1313 39			      add   HL, SP 
1314 f9			      ld    SP, HL 
1315 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1319 dd 39		      add   IX, SP 
131b			 
131b			      ; The address in HL points to the start of the useable allocated space, 
131b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
131b			      ; address of the block itself. 
131b eb			      ex    DE, HL 
131c 11 fc ff		      ld    DE, -4 
131f 19			      add   HL, DE 
1320			 
1320			      ; An allocated block must have a null next block pointer in it 
1320 7e			      ld    A, (HL) 
1321 23			      inc   HL 
1322 b6			      or    (HL) 
1323 c2 cb 13		      jp    NZ, free_done 
1326			 
1326 2b			      dec   HL 
1327			 
1327 44			      ld    B, H                    ; Copy HL to BC 
1328 4d			      ld    C, L 
1329			 
1329			      ; Loop through the free list to find the first block with an address 
1329			      ; higher than the block being freed 
1329 21 c0 5b		      ld    HL, free_list 
132c			 
132c			free_find_higher_block: 
132c 5e			      ld    E, (HL)                 ; Load next ptr from free block 
132d 23			      inc   HL 
132e 56			      ld    D, (HL) 
132f 2b			      dec   HL 
1330			 
1330 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1333 dd 72 01		      ld    (IX+1), D 
1336 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1339 dd 74 03		      ld    (IX+3), H 
133c			 
133c 78			      ld    A, B                    ; Check if DE is greater than BC 
133d ba			      cp    D                       ; Compare MSB first 
133e 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1340 30 04		      jr    NC, free_find_higher_block_skip 
1342 79			      ld    A, C 
1343 bb			      cp    E                       ; Then compare LSB 
1344 38 08		      jr    C, free_found_higher_block 
1346			 
1346			free_find_higher_block_skip: 
1346 7a			      ld    A, D                    ; Reached the end of the free list? 
1347 b3			      or    E 
1348 ca cb 13		      jp    Z, free_done 
134b			 
134b eb			      ex    DE, HL 
134c			 
134c 18 de		      jr    free_find_higher_block 
134e			 
134e			free_found_higher_block: 
134e			      ; Insert freed block between prev and next free blocks 
134e 71			      ld    (HL), C                 ; Point prev free block to freed block 
134f 23			      inc   HL 
1350 70			      ld    (HL), B 
1351			 
1351 60			      ld    H, B                    ; Point freed block at next free block 
1352 69			      ld    L, C 
1353 73			      ld    (HL), E 
1354 23			      inc   HL 
1355 72			      ld    (HL), D 
1356			 
1356			      ; Check if the freed block is adjacent to the next free block 
1356 23			      inc   HL                      ; Load size of freed block into HL 
1357 5e			      ld    E, (HL) 
1358 23			      inc   HL 
1359 56			      ld    D, (HL) 
135a eb			      ex    DE, HL 
135b			 
135b 09			      add   HL, BC                  ; Add addr of freed block and its size 
135c			 
135c dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
135f dd 56 01		      ld    D, (IX+1) 
1362			 
1362 b7			      or    A                       ; Clear the carry flag 
1363 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1365 20 22		      jr    NZ, free_check_adjacent_to_prev 
1367			 
1367			      ; Freed block is adjacent to next, merge into one bigger block 
1367 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1368 5e			      ld    E, (HL) 
1369 23			      inc   HL 
136a 56			      ld    D, (HL) 
136b e5			      push  HL                      ; Save ptr to next block for later 
136c			 
136c 60			      ld    H, B                    ; Store ptr from next block into freed block 
136d 69			      ld    L, C 
136e 73			      ld    (HL), E 
136f 23			      inc   HL 
1370 72			      ld    (HL), D 
1371			 
1371 e1			      pop   HL                      ; Restore ptr to next block 
1372 23			      inc   HL                      ; Load size of next block into DE 
1373 5e			      ld    E, (HL) 
1374 23			      inc   HL 
1375 56			      ld    D, (HL) 
1376 d5			      push  DE                      ; Save next block size for later 
1377			 
1377 60			      ld    H, B                    ; Load size of freed block into HL 
1378 69			      ld    L, C 
1379 23			      inc   HL 
137a 23			      inc   HL 
137b 5e			      ld    E, (HL) 
137c 23			      inc   HL 
137d 56			      ld    D, (HL) 
137e eb			      ex    DE, HL 
137f			 
137f d1			      pop   DE                      ; Restore size of next block 
1380 19			      add   HL, DE                  ; Add sizes of both blocks 
1381 eb			      ex    DE, HL 
1382			 
1382 60			      ld    H, B                    ; Store new bigger size into freed block 
1383 69			      ld    L, C 
1384 23			      inc   HL 
1385 23			      inc   HL 
1386 73			      ld    (HL), E 
1387 23			      inc   HL 
1388 72			      ld    (HL), D 
1389			 
1389			free_check_adjacent_to_prev: 
1389			      ; Check if the freed block is adjacent to the prev free block 
1389 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
138c dd 66 03		      ld    H, (IX+3) 
138f			 
138f 23			      inc   HL                      ; Size of prev free block into DE 
1390 23			      inc   HL 
1391 5e			      ld    E, (HL) 
1392 23			      inc   HL 
1393 56			      ld    D, (HL) 
1394 2b			      dec   HL 
1395 2b			      dec   HL 
1396 2b			      dec   HL 
1397			 
1397 19			      add   HL, DE                  ; Add prev block addr and size 
1398			 
1398 b7			      or    A                       ; Clear the carry flag 
1399 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
139b 20 2e		      jr    NZ, free_done 
139d			 
139d			      ; Freed block is adjacent to prev, merge into one bigger block 
139d 60			      ld    H, B                    ; Load next ptr from freed block into DE 
139e 69			      ld    L, C 
139f 5e			      ld    E, (HL) 
13a0 23			      inc   HL 
13a1 56			      ld    D, (HL) 
13a2 e5			      push  HL                      ; Save freed block ptr for later 
13a3			 
13a3 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
13a6 dd 66 03		      ld    H, (IX+3) 
13a9 73			      ld    (HL), E 
13aa 23			      inc   HL 
13ab 72			      ld    (HL), D 
13ac			 
13ac e1			      pop   HL                      ; Restore freed block ptr 
13ad 23			      inc   HL                      ; Load size of freed block into DE 
13ae 5e			      ld    E, (HL) 
13af 23			      inc   HL 
13b0 56			      ld    D, (HL) 
13b1 d5			      push  DE                      ; Save freed block size for later 
13b2			 
13b2 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
13b5 dd 66 03		      ld    H, (IX+3) 
13b8 23			      inc   HL 
13b9 23			      inc   HL 
13ba 5e			      ld    E, (HL) 
13bb 23			      inc   HL 
13bc 56			      ld    D, (HL) 
13bd			 
13bd e1			      pop   HL                      ; Add sizes of both blocks 
13be 19			      add   HL, DE 
13bf eb			      ex    DE, HL 
13c0			 
13c0 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
13c3 dd 66 03		      ld    H, (IX+3) 
13c6 23			      inc   HL 
13c7 23			      inc   HL 
13c8 73			      ld    (HL), E 
13c9 23			      inc   HL 
13ca 72			      ld    (HL), D 
13cb			 
13cb			free_done: 
13cb 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
13ce 39			      add   HL, SP 
13cf f9			      ld    SP, HL 
13d0			 
13d0			free_early_exit: 
13d0 dd e1		      pop   IX 
13d2 d1			      pop   DE 
13d3 c1			      pop   BC 
13d4			 
13d4 c9			      ret 
13d5			 
13d5			; moved to firmware.asm 
13d5			; 
13d5			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
13d5			;                  .dw   0 
13d5			 
13d5			 
13d5			endif 
13d5			 
13d5			 
13d5			if MALLOC_3 
13d5			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
13d5			;heap_start        .equ  0x9000      ; Starting address of heap 
13d5			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13d5			; 
13d5			 ;     .org 0 
13d5			  ;    jp    main 
13d5			; 
13d5			; 
13d5			 ;     .org  0x100 
13d5			;main: 
13d5			 ;     ld    HL, 0x8100 
13d5			  ;    ld    SP, HL 
13d5			; 
13d5			;      call  heap_init 
13d5			 
13d5			      ; Make some allocations 
13d5			;      ld    HL, 12 
13d5			;      call  malloc            ; Allocates 0x9004 
13d5			; 
13d5			 ;     ld    HL, 12 
13d5			;      call  malloc            ; Allocates 0x9014 
13d5			 
13d5			;      ld    HL, 12 
13d5			;      call  malloc            ; Allocates 0x9024 
13d5			 
13d5			      ; Free some allocations 
13d5			;      ld    HL, 0x9014 
13d5			;      call  free 
13d5			 
13d5			;      ld    HL, 0x9004 
13d5			;      call  free 
13d5			; 
13d5			;      ld    HL, 0x9024 
13d5			;      call  free 
13d5			 
13d5			 
13d5			 ;     halt 
13d5			 
13d5			 
13d5			;------------------------------------------------------------------------------ 
13d5			;     heap_init                                                               : 
13d5			;                                                                             : 
13d5			; Description                                                                 : 
13d5			;     Initialise the heap and make it ready for malloc and free operations.   : 
13d5			;                                                                             : 
13d5			;     The heap is maintained as a linked list, starting with an initial       : 
13d5			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13d5			;     the first free block in the heap. Each block then points to the next    : 
13d5			;     free block within the heap, and the free list ends at the first block   : 
13d5			;     with a null pointer to the next free block.                             : 
13d5			;                                                                             : 
13d5			; Parameters                                                                  : 
13d5			;     Inputs are compile-time only. Two defines which specify the starting    : 
13d5			;     address of the heap and its size are required, along with a memory      : 
13d5			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13d5			;     principally stores a pointer to the first free block in the heap.       : 
13d5			;                                                                             : 
13d5			; Returns                                                                     : 
13d5			;     Nothing                                                                 : 
13d5			;------------------------------------------------------------------------------ 
13d5			heap_init: 
13d5			      push  HL 
13d5			 
13d5			      ; Initialise free list struct 
13d5			      ld    HL, heap_start 
13d5			      ld    (free_list), HL 
13d5			      ld    HL, 0 
13d5			      ld    (free_list+2), HL 
13d5			 
13d5			      ; Insert first free block at bottom of heap, consumes entire heap 
13d5			      ld    HL, heap_start+heap_size-4 
13d5			      ld    (heap_start), HL        ; Next block (end of free list) 
13d5			      ld    HL, heap_size-4 
13d5			      ld    (heap_start+2), HL      ; Block size 
13d5			 
13d5			      ; Insert end of free list block at top of heap - two null words will 
13d5			      ; terminate the free list 
13d5			      ld    HL, 0 
13d5			      ld    (heap_start+heap_size-2), HL 
13d5			      ld    (heap_start+heap_size-4), HL 
13d5			 
13d5			      pop   HL 
13d5			 
13d5			      ret 
13d5			 
13d5			 
13d5			;------------------------------------------------------------------------------ 
13d5			;     malloc                                                                  : 
13d5			;                                                                             : 
13d5			; Description                                                                 : 
13d5			;     Allocates the wanted space from the heap and returns the address of the : 
13d5			;     first useable byte of the allocation.                                   : 
13d5			;                                                                             : 
13d5			;     Allocations can happen in one of two ways:                              : 
13d5			;                                                                             : 
13d5			;     1. A free block may be found which is the exact size wanted. In this    : 
13d5			;        case the block is removed from the free list and retuedn to the      : 
13d5			;        caller.                                                              : 
13d5			;     2. A free block may be found which is larger than the size wanted. In   : 
13d5			;        this case, the larger block is split into two. The first portion of  : 
13d5			;        this block will become the requested space by the malloc call and    : 
13d5			;        is returned to the caller. The second portion becomes a new free     : 
13d5			;        block, and the free list is adjusted to maintain continuity via this : 
13d5			;        newly created block.                                                 : 
13d5			;                                                                             : 
13d5			;     malloc does not set any initial value in the allocated space, the       : 
13d5			;     caller is required to do this as required.                              : 
13d5			;                                                                             : 
13d5			;     This implementation of malloc uses the stack exclusively, and is        : 
13d5			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13d5			;     advisable to disable interrupts before calling malloc, and recommended  : 
13d5			;     to avoid the use of malloc inside ISRs in general.                      : 
13d5			;                                                                             : 
13d5			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13d5			;                                                                             : 
13d5			; Parameters                                                                  : 
13d5			;     HL  Number of bytes wanted                                              : 
13d5			;                                                                             : 
13d5			; Returns                                                                     : 
13d5			;     HL  Address of the first useable byte of the allocation                 : 
13d5			;                                                                             : 
13d5			; Flags                                                                       : 
13d5			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13d5			;                                                                             : 
13d5			; Stack frame                                                                 : 
13d5			;       |             |                                                       : 
13d5			;       +-------------+                                                       : 
13d5			;       |     BC      |                                                       : 
13d5			;       +-------------+                                                       : 
13d5			;       |     DE      |                                                       : 
13d5			;       +-------------+                                                       : 
13d5			;       |     IX      |                                                       : 
13d5			;       +-------------+                                                       : 
13d5			;       |  prev_free  |                                                       : 
13d5			;   +4  +-------------+                                                       : 
13d5			;       |  this_free  |                                                       : 
13d5			;   +2  +-------------+                                                       : 
13d5			;       |  next_free  |                                                       : 
13d5			;   +0  +-------------+                                                       : 
13d5			;       |             |                                                       : 
13d5			;                                                                             : 
13d5			;------------------------------------------------------------------------------ 
13d5			malloc: 
13d5			      push  BC 
13d5			      push  DE 
13d5			      push  IX 
13d5			 
13d5			      ld    A, H                    ; Exit if no space requested 
13d5			      or    L 
13d5			      jp    Z, malloc_early_exit 
13d5			 
13d5			      ; Set up stack frame 
13d5			      ex    DE, HL 
13d5			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13d5			      add   HL, SP 
13d5			      ld    SP, HL 
13d5			      ld    IX, 0                   ; Use IX as a frame pointer 
13d5			      add   IX, SP 
13d5			 
13d5			      ; Setup initial state 
13d5			      ld    HL, 4                   ; want must also include space used by block struct 
13d5			      add   HL, DE 
13d5			 
13d5			      ld    B, H                    ; Move want to BC 
13d5			      ld    C, L 
13d5			 
13d5			      ld    HL, free_list           ; Store prev_free ptr to stack 
13d5			      ld    (IX+4), L 
13d5			      ld    (IX+5), H 
13d5			 
13d5			      ld    E, (HL)                 ; Store this_free ptr to stack 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			      ld    (IX+2), E 
13d5			      ld    (IX+3), D 
13d5			      ex    DE, HL                  ; this_free ptr into HL 
13d5			 
13d5			      ; Loop through free block list to find some space 
13d5			malloc_find_space: 
13d5			      ld    E, (HL)                 ; Load next_free ptr into DE 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			 
13d5			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13d5			      or    E 
13d5			      jp    Z, malloc_no_space 
13d5			 
13d5			      ld    (IX+0), E               ; Store next_free ptr to stack 
13d5			      ld    (IX+1), D 
13d5			 
13d5			      ; Does this block have enough space to make the allocation? 
13d5			      inc   HL                      ; Load free block size into DE 
13d5			      ld    E, (HL) 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			 
13d5			      ex    DE, HL                  ; Check size of block against want 
13d5			      or    A                       ; Ensure carry flag clear 
13d5			      sbc   HL, BC 
13d5			      push  HL                      ; Store the result for later (new block size) 
13d5			 
13d5			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13d5			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
13d5			 
13d5			      ; this_free block is not big enough, setup ptrs to test next free block 
13d5			      pop   HL                      ; Discard previous result 
13d5			 
13d5			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
13d5			      ld    H, (IX+3) 
13d5			      ld    (IX+4), L 
13d5			      ld    (IX+5), H 
13d5			 
13d5			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
13d5			      ld    H, (IX+1) 
13d5			      ld    (IX+2), L 
13d5			      ld    (IX+3), H 
13d5			 
13d5			      jr    malloc_find_space 
13d5			 
13d5			      ; split a bigger block into two - requested size and remaining size 
13d5			malloc_alloc_split: 
13d5			      ex    DE, HL                  ; Calculate address of new free block 
13d5			      dec   HL 
13d5			      dec   HL 
13d5			      dec   HL 
13d5			      add   HL, BC 
13d5			 
13d5			      ; Create a new block and point it at next_free 
13d5			      ld    E, (IX+0)               ; Load next_free ptr into DE 
13d5			      ld    D, (IX+1) 
13d5			 
13d5			      ld    (HL), E                 ; Store next_free ptr into new block 
13d5			      inc   HL 
13d5			      ld    (HL), D 
13d5			 
13d5			      pop   DE                      ; Store size of new block into new block 
13d5			      inc   HL 
13d5			      ld    (HL), E 
13d5			      inc   HL 
13d5			      ld    (HL), D 
13d5			 
13d5			      ; Update this_free ptr to point to new block 
13d5			      dec   HL 
13d5			      dec   HL 
13d5			      dec   HL 
13d5			 
13d5			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
13d5			      ld    D, (IX+3) 
13d5			 
13d5			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
13d5			      ld    (IX+3), H 
13d5			 
13d5			      ; Modify this_free block to be allocation 
13d5			      ex    DE, HL 
13d5			      xor   A                       ; Null the next block ptr of allocated block 
13d5			      ld    (HL), A 
13d5			      inc   HL 
13d5			      ld    (HL), A 
13d5			 
13d5			      inc   HL                      ; Store want size into allocated block 
13d5			      ld    (HL), C 
13d5			      inc   HL 
13d5			      ld    (HL), B 
13d5			      inc   HL 
13d5			      push  HL                      ; Address of allocation to return 
13d5			 
13d5			      jr    malloc_update_links 
13d5			 
13d5			malloc_alloc_fit: 
13d5			      pop   HL                      ; Dont need new block size, want is exact fit 
13d5			 
13d5			      ; Modify this_free block to be allocation 
13d5			      ex    DE, HL 
13d5			      dec   HL 
13d5			      dec   HL 
13d5			      dec   HL 
13d5			 
13d5			      xor   A                       ; Null the next block ptr of allocated block 
13d5			      ld    (HL), A 
13d5			      inc   HL 
13d5			      ld    (HL), A 
13d5			 
13d5			      inc   HL                      ; Store address of allocation to return 
13d5			      inc   HL 
13d5			      inc   HL 
13d5			      push  HL 
13d5			 
13d5			      ; Copy next_free ptr to this_free, remove allocated block from free list 
13d5			      ld    L, (IX+0)               ; next_free to HL 
13d5			      ld    H, (IX+1) 
13d5			 
13d5			      ld    (IX+2), L               ; HL to this_free 
13d5			      ld    (IX+3), H 
13d5			 
13d5			 
13d5			malloc_update_links: 
13d5			      ; Update prev_free ptr to point to this_free 
13d5			      ld    L, (IX+4)               ; prev_free ptr to HL 
13d5			      ld    H, (IX+5) 
13d5			 
13d5			      ld    E, (IX+2)               ; this_free ptr to DE 
13d5			      ld    D, (IX+3) 
13d5			 
13d5			      ld    (HL), E                 ; this_free ptr into prev_free 
13d5			      inc   HL 
13d5			      ld    (HL), D 
13d5			 
13d5			      ; Clear the Z flag to indicate successful allocation 
13d5			      ld    A, D 
13d5			      or    E 
13d5			 
13d5			      pop   DE                      ; Address of allocation 
13d5			 
13d5			malloc_no_space: 
13d5			      ld    HL, 6                   ; Clean up stack frame 
13d5			      add   HL, SP 
13d5			      ld    SP, HL 
13d5			 
13d5			      ex    DE, HL                  ; Alloc addr into HL for return 
13d5			 
13d5			malloc_early_exit: 
13d5			      pop   IX 
13d5			      pop   DE 
13d5			      pop   BC 
13d5			 
13d5			      ret 
13d5			 
13d5			 
13d5			;------------------------------------------------------------------------------ 
13d5			;     free                                                                    : 
13d5			;                                                                             : 
13d5			; Description                                                                 : 
13d5			;     Return the space pointed to by HL to the heap. HL must be an address as : 
13d5			;     returned by malloc, otherwise the behaviour is undefined.               : 
13d5			;                                                                             : 
13d5			;     Where possible, directly adjacent free blocks will be merged together   : 
13d5			;     into larger blocks to help ensure that the heap does not become         : 
13d5			;     excessively fragmented.                                                 : 
13d5			;                                                                             : 
13d5			;     free does not clear or set any other value into the freed space, and    : 
13d5			;     therefore its contents may be visible through subsequent malloc's. The  : 
13d5			;     caller should clear the freed space as required.                        : 
13d5			;                                                                             : 
13d5			;     This implementation of free uses the stack exclusively, and is          : 
13d5			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13d5			;     advisable to disable interrupts before calling free, and recommended    : 
13d5			;     to avoid the use of free inside ISRs in general.                        : 
13d5			;                                                                             : 
13d5			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13d5			;                                                                             : 
13d5			; Parameters                                                                  : 
13d5			;     HL  Pointer to address of first byte of allocation to be freed          : 
13d5			;                                                                             : 
13d5			; Returns                                                                     : 
13d5			;     Nothing                                                                 : 
13d5			;                                                                             : 
13d5			; Stack frame                                                                 : 
13d5			;       |             |                                                       : 
13d5			;       +-------------+                                                       : 
13d5			;       |     BC      |                                                       : 
13d5			;       +-------------+                                                       : 
13d5			;       |     DE      |                                                       : 
13d5			;       +-------------+                                                       : 
13d5			;       |     IX      |                                                       : 
13d5			;       +-------------+                                                       : 
13d5			;       |  prev_free  |                                                       : 
13d5			;   +2  +-------------+                                                       : 
13d5			;       |  next_free  |                                                       : 
13d5			;   +0  +-------------+                                                       : 
13d5			;       |             |                                                       : 
13d5			;                                                                             : 
13d5			;------------------------------------------------------------------------------ 
13d5			free: 
13d5			      push  BC 
13d5			      push  DE 
13d5			      push  IX 
13d5			 
13d5			      ld    A, H                    ; Exit if ptr is null 
13d5			      or    L 
13d5			      jp    Z, free_early_exit 
13d5			 
13d5			      ; Set up stack frame 
13d5			      ex    DE, HL 
13d5			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
13d5			      add   HL, SP 
13d5			      ld    SP, HL 
13d5			      ld    IX, 0                   ; Use IX as a frame pointer 
13d5			      add   IX, SP 
13d5			 
13d5			      ; The address in HL points to the start of the useable allocated space, 
13d5			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
13d5			      ; address of the block itself. 
13d5			      ex    DE, HL 
13d5			      ld    DE, -4 
13d5			      add   HL, DE 
13d5			 
13d5			      ; An allocated block must have a null next block pointer in it 
13d5			      ld    A, (HL) 
13d5			      inc   HL 
13d5			      or    (HL) 
13d5			      jp    NZ, free_done 
13d5			 
13d5			      dec   HL 
13d5			 
13d5			      ld    B, H                    ; Copy HL to BC 
13d5			      ld    C, L 
13d5			 
13d5			      ; Loop through the free list to find the first block with an address 
13d5			      ; higher than the block being freed 
13d5			      ld    HL, free_list 
13d5			 
13d5			free_find_higher_block: 
13d5			      ld    E, (HL)                 ; Load next ptr from free block 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			      dec   HL 
13d5			 
13d5			      ld    (IX+0), E               ; Save ptr to next free block 
13d5			      ld    (IX+1), D 
13d5			      ld    (IX+2), L               ; Save ptr to prev free block 
13d5			      ld    (IX+3), H 
13d5			 
13d5			      ld    A, B                    ; Check if DE is greater than BC 
13d5			      cp    D                       ; Compare MSB first 
13d5			      jr    Z, $+4                  ; MSB the same, compare LSB 
13d5			      jr    NC, free_find_higher_block_skip 
13d5			      ld    A, C 
13d5			      cp    E                       ; Then compare LSB 
13d5			      jr    C, free_found_higher_block 
13d5			 
13d5			free_find_higher_block_skip: 
13d5			      ld    A, D                    ; Reached the end of the free list? 
13d5			      or    E 
13d5			      jp    Z, free_done 
13d5			 
13d5			      ex    DE, HL 
13d5			 
13d5			      jr    free_find_higher_block 
13d5			 
13d5			free_found_higher_block: 
13d5			      ; Insert freed block between prev and next free blocks 
13d5			      ld    (HL), C                 ; Point prev free block to freed block 
13d5			      inc   HL 
13d5			      ld    (HL), B 
13d5			 
13d5			      ld    H, B                    ; Point freed block at next free block 
13d5			      ld    L, C 
13d5			      ld    (HL), E 
13d5			      inc   HL 
13d5			      ld    (HL), D 
13d5			 
13d5			      ; Check if the freed block is adjacent to the next free block 
13d5			      inc   HL                      ; Load size of freed block into HL 
13d5			      ld    E, (HL) 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			      ex    DE, HL 
13d5			 
13d5			      add   HL, BC                  ; Add addr of freed block and its size 
13d5			 
13d5			      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d5			      ld    D, (IX+1) 
13d5			 
13d5			      or    A                       ; Clear the carry flag 
13d5			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d5			      jr    NZ, free_check_adjacent_to_prev 
13d5			 
13d5			      ; Freed block is adjacent to next, merge into one bigger block 
13d5			      ex    DE, HL                  ; Load next ptr from next block into DE 
13d5			      ld    E, (HL) 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			      push  HL                      ; Save ptr to next block for later 
13d5			 
13d5			      ld    H, B                    ; Store ptr from next block into freed block 
13d5			      ld    L, C 
13d5			      ld    (HL), E 
13d5			      inc   HL 
13d5			      ld    (HL), D 
13d5			 
13d5			      pop   HL                      ; Restore ptr to next block 
13d5			      inc   HL                      ; Load size of next block into DE 
13d5			      ld    E, (HL) 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			      push  DE                      ; Save next block size for later 
13d5			 
13d5			      ld    H, B                    ; Load size of freed block into HL 
13d5			      ld    L, C 
13d5			      inc   HL 
13d5			      inc   HL 
13d5			      ld    E, (HL) 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			      ex    DE, HL 
13d5			 
13d5			      pop   DE                      ; Restore size of next block 
13d5			      add   HL, DE                  ; Add sizes of both blocks 
13d5			      ex    DE, HL 
13d5			 
13d5			      ld    H, B                    ; Store new bigger size into freed block 
13d5			      ld    L, C 
13d5			      inc   HL 
13d5			      inc   HL 
13d5			      ld    (HL), E 
13d5			      inc   HL 
13d5			      ld    (HL), D 
13d5			 
13d5			free_check_adjacent_to_prev: 
13d5			      ; Check if the freed block is adjacent to the prev free block 
13d5			      ld    L, (IX+2)               ; Prev free block ptr into HL 
13d5			      ld    H, (IX+3) 
13d5			 
13d5			      inc   HL                      ; Size of prev free block into DE 
13d5			      inc   HL 
13d5			      ld    E, (HL) 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			      dec   HL 
13d5			      dec   HL 
13d5			      dec   HL 
13d5			 
13d5			      add   HL, DE                  ; Add prev block addr and size 
13d5			 
13d5			      or    A                       ; Clear the carry flag 
13d5			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
13d5			      jr    NZ, free_done 
13d5			 
13d5			      ; Freed block is adjacent to prev, merge into one bigger block 
13d5			      ld    H, B                    ; Load next ptr from freed block into DE 
13d5			      ld    L, C 
13d5			      ld    E, (HL) 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			      push  HL                      ; Save freed block ptr for later 
13d5			 
13d5			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
13d5			      ld    H, (IX+3) 
13d5			      ld    (HL), E 
13d5			      inc   HL 
13d5			      ld    (HL), D 
13d5			 
13d5			      pop   HL                      ; Restore freed block ptr 
13d5			      inc   HL                      ; Load size of freed block into DE 
13d5			      ld    E, (HL) 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			      push  DE                      ; Save freed block size for later 
13d5			 
13d5			      ld    L, (IX+2)               ; Load size of prev block into DE 
13d5			      ld    H, (IX+3) 
13d5			      inc   HL 
13d5			      inc   HL 
13d5			      ld    E, (HL) 
13d5			      inc   HL 
13d5			      ld    D, (HL) 
13d5			 
13d5			      pop   HL                      ; Add sizes of both blocks 
13d5			      add   HL, DE 
13d5			      ex    DE, HL 
13d5			 
13d5			      ld    L, (IX+2)               ; Store new bigger size into prev block 
13d5			      ld    H, (IX+3) 
13d5			      inc   HL 
13d5			      inc   HL 
13d5			      ld    (HL), E 
13d5			      inc   HL 
13d5			      ld    (HL), D 
13d5			 
13d5			free_done: 
13d5			      ld    HL, 4                   ; Clean up stack frame 
13d5			      add   HL, SP 
13d5			      ld    SP, HL 
13d5			 
13d5			free_early_exit: 
13d5			      pop   IX 
13d5			      pop   DE 
13d5			      pop   BC 
13d5			 
13d5			      ret 
13d5			 
13d5			 
13d5			;      .org 0x8000 
13d5			; 
13d5			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
13d5			 ;                 .dw   0 
13d5			 
13d5			endif 
13d5			 
13d5			 
13d5			if MALLOC_4 
13d5			 
13d5			; My memory allocation code. Very very simple.... 
13d5			; allocate space under 250 chars 
13d5			 
13d5			heap_init: 
13d5				; init start of heap as zero 
13d5				;  
13d5			 
13d5				ld hl, heap_start 
13d5				ld a, 0 
13d5				ld (hl), a      ; empty block 
13d5				inc hl 
13d5				ld a, 0 
13d5				ld (hl), a      ; length of block 
13d5				; write end of list 
13d5				inc hl 
13d5				ld a,(hl) 
13d5				inc hl 
13d5				ld a,(hl) 
13d5				 
13d5			 
13d5				; init some malloc vars 
13d5			 
13d5				ld hl, 0 
13d5				ld (free_list), hl       ; store last malloc location 
13d5			 
13d5				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
13d5				ld a, 0 
13d5				ld (hl), a 
13d5			 
13d5			 
13d5				ld hl, heap_start 
13d5				;  
13d5				  
13d5				ret 
13d5			 
13d5			 
13d5			;    free block marker 
13d5			;    requested size  
13d5			;    pointer to next block 
13d5			;    .... 
13d5			;    next block marker 
13d5			 
13d5			 
13d5			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
13d5			; 
13d5			 
13d5			 
13d5			malloc:  
13d5				push de 
13d5				push bc 
13d5				push af 
13d5			 
13d5				; hl space required 
13d5				 
13d5				ld c, l    ; hold space   (TODO only a max of 255) 
13d5			 
13d5			;	inc c     ; TODO BUG need to fix memory leak on push str 
13d5			;	inc c 
13d5			;	inc c 
13d5			;	inc c 
13d5			;	inc c 
13d5			;	inc c 
13d5			;	inc c 
13d5			 
13d5			 
13d5			 
13d5				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
13d5			 
13d5				ld a, (free_list+3) 
13d5				cp 0 
13d5				jr z, .contheap 
13d5			 
13d5				ld hl, (free_list)     ; get last alloc 
13d5					if DEBUG_FORTH_MALLOC_INT 
13d5						DMARK "mrs" 
13d5						CALLMONITOR 
13d5					endif 
13d5				jr .startalloc 
13d5			 
13d5			.contheap: 
13d5				ld hl, heap_start 
13d5			 
13d5			.startalloc: 
13d5			 
13d5					if DEBUG_FORTH_MALLOC_INT 
13d5						DMARK "mym" 
13d5						CALLMONITOR 
13d5					endif 
13d5			.findblock: 
13d5					if DEBUG_FORTH_MALLOC_INT 
13d5						DMARK "mmf" 
13d5						CALLMONITOR 
13d5					endif 
13d5			 
13d5				ld a,(hl)  
13d5				; if byte is zero then clear to use 
13d5			 
13d5				cp 0 
13d5				jr z, .foundemptyblock 
13d5			 
13d5				; if byte is not clear 
13d5				;     then byte is offset to next block 
13d5			 
13d5				inc hl 
13d5				ld a, (hl) ; get size 
13d5			.nextblock:	inc hl 
13d5					ld e, (hl) 
13d5					inc hl 
13d5					ld d, (hl) 
13d5					ex de, hl 
13d5			;	inc hl  ; move past the store space 
13d5			;	inc hl  ; move past zero index  
13d5			 
13d5				; TODO detect no more space 
13d5			 
13d5				push hl 
13d5				ld de, heap_end 
13d5				call cmp16 
13d5				pop hl 
13d5				jr nc, .nospace 
13d5			 
13d5				jr .findblock 
13d5			 
13d5			.nospace: ld hl, 0 
13d5				jp .exit 
13d5			 
13d5			 
13d5			.foundemptyblock:	 
13d5					if DEBUG_FORTH_MALLOC_INT 
13d5						DMARK "mme" 
13d5						CALLMONITOR 
13d5					endif 
13d5			 
13d5			; TODO has block enough space if reusing??? 
13d5			 
13d5				;  
13d5			 
13d5			; see if this block has been previously used 
13d5				inc hl 
13d5				ld a, (hl) 
13d5				dec hl 
13d5				cp 0 
13d5				jr z, .newblock 
13d5			 
13d5					if DEBUG_FORTH_MALLOC_INT 
13d5						DMARK "meR" 
13d5						CALLMONITOR 
13d5					endif 
13d5			 
13d5			; no reusing previously allocated block 
13d5			 
13d5			; is it smaller than previously used? 
13d5				 
13d5				inc hl    ; move to size 
13d5				ld a, c 
13d5				sub (hl)        ; we want c < (hl) 
13d5				dec hl    ; move back to marker 
13d5			        jr z, .findblock 
13d5			 
13d5				; update with the new size which should be lower 
13d5			 
13d5			        ;inc  hl   ; negate next move. move back to size  
13d5			 
13d5			.newblock: 
13d5				; need to be at marker here 
13d5			 
13d5					if DEBUG_FORTH_MALLOC_INT 
13d5						DMARK "meN" 
13d5						CALLMONITOR 
13d5					endif 
13d5			 
13d5			 
13d5				ld a, c 
13d5			 
13d5				ld (free_list+3), a	 ; flag resume from last malloc  
13d5				ld (free_list), hl    ; save out last location 
13d5			 
13d5			 
13d5				;inc a     ; space for length byte 
13d5				ld (hl), a     ; save block in use marker 
13d5			 
13d5				inc hl   ; move to space marker 
13d5				ld (hl), a    ; save new space 
13d5			 
13d5				inc hl   ; move to start of allocated area 
13d5				 
13d5			;	push hl     ; save where we are - 1  
13d5			 
13d5			;	inc hl  ; move past zero index  
13d5				; skip space to set down new marker 
13d5			 
13d5				; provide some extra space for now 
13d5			 
13d5				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
13d5				inc a 
13d5				inc a 
13d5			 
13d5				push hl   ; save where we are in the node block 
13d5			 
13d5				call addatohl 
13d5			 
13d5				; write linked list point 
13d5			 
13d5				pop de     ; get our node position 
13d5				ex de, hl 
13d5			 
13d5				ld (hl), e 
13d5				inc hl 
13d5				ld (hl), d 
13d5			 
13d5				inc hl 
13d5			 
13d5				; now at start of allocated data so save pointer 
13d5			 
13d5				push hl 
13d5			 
13d5				; jump to position of next node and setup empty header in DE 
13d5			 
13d5				ex de, hl 
13d5			 
13d5			;	inc hl ; move past end of block 
13d5			 
13d5				ld a, 0 
13d5				ld (hl), a   ; empty marker 
13d5				inc hl 
13d5				ld (hl), a   ; size 
13d5				inc hl  
13d5				ld (hl), a   ; ptr 
13d5				inc hl 
13d5				ld (hl), a   ; ptr 
13d5			 
13d5			 
13d5				pop hl 
13d5			 
13d5					if DEBUG_FORTH_MALLOC_INT 
13d5						DMARK "mmr" 
13d5						CALLMONITOR 
13d5					endif 
13d5			 
13d5			.exit: 
13d5				pop af 
13d5				pop bc 
13d5				pop de  
13d5				ret 
13d5			 
13d5			 
13d5			 
13d5			 
13d5			free:  
13d5				push hl 
13d5				push af 
13d5				; get address in hl 
13d5			 
13d5					if DEBUG_FORTH_MALLOC_INT 
13d5						DMARK "fre" 
13d5						CALLMONITOR 
13d5					endif 
13d5				; data is at hl - move to block count 
13d5				dec hl 
13d5				dec hl    ; get past pointer 
13d5				dec hl 
13d5			 
13d5				ld a, (hl)    ; need this for a validation check 
13d5			 
13d5				dec hl    ; move to block marker 
13d5			 
13d5				; now check that the block count and block marker are the same  
13d5			        ; this checks that we are on a malloc node and not random memory 
13d5			        ; OK a faint chance this could be a problem but rare - famous last words! 
13d5			 
13d5				ld c, a 
13d5				ld a, (hl)    
13d5			 
13d5				cp c 
13d5				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
13d5			 
13d5				; yes good chance we are on a malloc node 
13d5			 
13d5				ld a, 0      
13d5				ld (hl), a   ; mark as free 
13d5			 
13d5				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
13d5			 
13d5			.freeignore:  
13d5			 
13d5				pop af 
13d5				pop hl 
13d5			 
13d5				ret 
13d5			 
13d5			 
13d5			 
13d5			endif 
13d5			 
13d5			; eof 
# End of file firmware_memory.asm
13d5			  
13d5			; device C  
13d5			if SOUND_ENABLE  
13d5				include "firmware_sound.asm"  
13d5			endif  
13d5			  
13d5			include "firmware_diags.asm"  
13d5			; Hardware diags menu 
13d5			 
13d5			 
13d5			config: 
13d5			 
13d5 3e 00			ld a, 0 
13d7 21 05 14			ld hl, .configmn 
13da cd 79 0b			call menu 
13dd			 
13dd fe 00			cp 0 
13df c8				ret z 
13e0			 
13e0 fe 01			cp 1 
13e2 cc 33 14			call z, .savetostore 
13e5			 
13e5 fe 02			cp 2 
13e7 cc 1f 14			call z, .selautoload 
13ea fe 03			cp 3 
13ec cc 15 14			call z, .disautoload 
13ef fe 04			cp 4 
13f1 cc 29 14			call z, .selbank 
13f4 fe 05			cp 5 
13f6 cc 3d 14			call z, .debug_tog 
13f9 fe 06			cp 6 
13fb cc 80 15			call z, .bpsgo 
13fe fe 07			cp 7 
1400 cc 63 14			call z, hardware_diags 
1403			 
1403 18 d0			jr config 
1405			 
1405			.configmn: 
1405 71 17			dw prom_c3 
1407 88 17			dw prom_c2 
1409 9d 17			dw prom_c2a 
140b b3 17			dw prom_c2b 
140d			;	dw prom_c4 
140d d0 17			dw prom_m4 
140f eb 17			dw prom_m4b 
1411 f3 17			dw prom_c1 
1413 00 00			dw 0 
1415				 
1415			 
1415			 
1415			 
1415			.disautoload: 
1415				if STORAGE_SE 
1415				ld a, $fe      ; bit 0 clear 
1415				ld (spi_device), a 
1415			 
1415				call storage_get_block_0 
1415			 
1415				ld a, 0 
1415				ld (store_page+STORE_0_AUTOFILE), a 
1415			 
1415					ld hl, 0 
1415					ld de, store_page 
1415				call storage_write_block	 ; save update 
1415				else 
1415			 
1415 21 02 18			ld hl, prom_notav 
1418 11 18 18			ld de, prom_empty 
141b cd d9 0a			call info_panel 
141e				endif 
141e			 
141e			 
141e c9				ret 
141f			 
141f			 
141f			 
141f			; Select auto start 
141f			 
141f			.selautoload: 
141f			 
141f				 
141f				if STORAGE_SE 
141f			 
141f					call config_dir 
141f				        ld hl, scratch 
141f					ld a, 0 
141f					call menu 
141f			 
141f					cp 0 
141f					ret z 
141f			 
141f					dec a 
141f			 
141f			 
141f					; locate menu option 
141f			 
141f					ld hl, scratch 
141f					call table_lookup 
141f			 
141f					if DEBUG_FORTH_WORDS 
141f						DMARK "ALl" 
141f						CALLMONITOR 
141f					endif 
141f					; with the pointer to the menu it, the byte following the zero term is the file id 
141f			 
141f					ld a, 0 
141f					ld bc, 50   ; max of bytes to look at 
141f					cpir  
141f			 
141f					if DEBUG_FORTH_WORDS 
141f						DMARK "ALb" 
141f						CALLMONITOR 
141f					endif 
141f					;inc hl 
141f			 
141f					ld a, (hl)   ; file id 
141f					 
141f				        ; save bank and file ids 
141f			 
141f					push af 
141f			 
141f			; TODO need to save to block 0 on bank 1	 
141f			 
141f					call storage_get_block_0 
141f			 
141f					if DEBUG_FORTH_WORDS 
141f						DMARK "AL0" 
141f						CALLMONITOR 
141f					endif 
141f					pop af 
141f			 
141f					ld (store_page+STORE_0_FILERUN),a 
141f					 
141f					; save bank id 
141f			 
141f					ld a,(spi_device) 
141f					ld (store_page+STORE_0_BANKRUN),a 
141f			 
141f					; enable auto run of store file 
141f			 
141f					ld a, 1 
141f					ld (store_page+STORE_0_AUTOFILE),a 
141f			 
141f					; save buffer 
141f			 
141f					ld hl, 0 
141f					ld de, store_page 
141f					if DEBUG_FORTH_WORDS 
141f						DMARK "ALw" 
141f						CALLMONITOR 
141f					endif 
141f				call storage_write_block	 ; save update 
141f			  
141f			 
141f			 
141f			 
141f					ld hl, scratch 
141f					call config_fdir 
141f			 
141f				else 
141f			 
141f 21 02 18			ld hl, prom_notav 
1422 11 18 18			ld de, prom_empty 
1425 cd d9 0a			call info_panel 
1428			 
1428				endif 
1428 c9				ret 
1429			 
1429			 
1429			 
1429			; Select storage bank 
1429			 
1429			.selbank: 
1429			 
1429				if STORAGE_SE 
1429				else 
1429			 
1429 21 02 18			ld hl, prom_notav 
142c 11 18 18			ld de, prom_empty 
142f cd d9 0a			call info_panel 
1432				endif 
1432				 
1432 c9				ret 
1433			 
1433			if STORAGE_SE 
1433			 
1433			.config_ldir:   
1433				; Load storage bank labels into menu array 
1433			 
1433				 
1433			 
1433			 
1433				ret 
1433			 
1433			 
1433			endif 
1433			 
1433			 
1433			; Save user words to storage 
1433			 
1433			.savetostore: 
1433			 
1433				if STORAGE_SE 
1433			 
1433					call config_dir 
1433				        ld hl, scratch 
1433					ld a, 0 
1433					call menu 
1433					 
1433					ld hl, scratch 
1433					call config_fdir 
1433			 
1433				else 
1433			 
1433 21 02 18			ld hl, prom_notav 
1436 11 18 18			ld de, prom_empty 
1439 cd d9 0a			call info_panel 
143c			 
143c				endif 
143c			 
143c c9				ret 
143d			 
143d			 
143d			 
143d			if STORAGE_SE 
143d			 
143d			config_fdir: 
143d				; using the scratch dir go through and release the memory allocated for each string 
143d				 
143d				ld hl, scratch 
143d			.cfdir:	ld e,(hl) 
143d				inc hl 
143d				ld d,(hl) 
143d				inc hl 
143d			 
143d				ex de, hl 
143d				call ishlzero 
143d				ret z     ; return on null pointer 
143d				call free 
143d				ex de, hl 
143d				jr .cfdir 
143d			 
143d			 
143d				ret 
143d			 
143d			 
143d			config_dir: 
143d			 
143d				; for the config menus that need to build a directory of storage call this routine 
143d				; it will construct a menu in scratch to pass to menu 
143d			 
143d				; open storage device 
143d			 
143d				; execute DIR to build a list of files and their ids into scratch in menu format 
143d				; once the menu has finished then will need to call config_fdir to release the strings 
143d				 
143d				; c = number items 
143d			 
143d				 
143d				call storage_get_block_0 
143d			 
143d				ld hl, store_page     ; get current id count 
143d				ld b, (hl) 
143d				ld c, 0    ; count of files   
143d			 
143d			 
143d				ld hl, scratch 
143d				ld (store_tmp2), hl    ; location to poke strings 
143d			 
143d				; check for empty drive 
143d			 
143d				ld a, 0 
143d				cp b 
143d				jp z, .dirdone 
143d			 
143d				 
143d					if DEBUG_FORTH_WORDS 
143d						DMARK "Cdc" 
143d						CALLMONITOR 
143d					endif 
143d			 
143d			 
143d			.diritem:	 
143d				push bc 
143d				; for each of the current ids do a search for them and if found push to stack 
143d			 
143d					ld hl, STORE_BLOCK_PHY 
143d					ld d, 0		 ; look for extent 0 of block id as this contains file name 
143d					ld e,b 
143d			 
143d					call storage_findnextid 
143d			 
143d			 
143d					; if found hl will be non zero 
143d			 
143d					call ishlzero 
143d					jr z, .dirnotfound 
143d			 
143d					; increase count 
143d			 
143d					pop bc	 
143d					inc c 
143d					push bc 
143d					 
143d			 
143d					; get file header and push the file name 
143d			 
143d					ld de, store_page 
143d					call storage_read_block 
143d			 
143d					; push file id to stack 
143d				 
143d					ld a, (store_page) 
143d					ld h, 0 
143d					ld l, a 
143d			 
143d					;call forth_push_numhl 
143d					; TODO store id 
143d			 
143d					push hl 
143d			 
143d					; push extent count to stack  
143d				 
143d					ld hl, store_page+3 
143d			 
143d					; get file name length 
143d			 
143d					call strlenz   
143d			 
143d					inc hl   ; cover zero term 
143d					inc hl  ; stick the id at the end of the area 
143d			 
143d					push hl 
143d					pop bc    ; move length to bc 
143d			 
143d					call malloc 
143d			 
143d					; TODO save malloc area to scratch 
143d			 
143d					ex de, hl 
143d					ld hl, (store_tmp2) 
143d					ld (hl), e 
143d					inc hl 
143d					ld (hl), d 
143d					inc hl 
143d					ld (store_tmp2), hl 
143d			 
143d					 
143d			 
143d					;pop hl   ; get source 
143d			;		ex de, hl    ; swap aronund	 
143d			 
143d					ld hl, store_page+3 
143d					if DEBUG_FORTH_WORDS 
143d						DMARK "CFd" 
143d						CALLMONITOR 
143d					endif 
143d					ldir 
143d			 
143d					; de is past string, move back one and store id 
143d					 
143d					dec de 
143d			 
143d					; store file id 
143d			 
143d					pop hl 
143d					ex de,hl 
143d					ld (hl), e 
143d			 
143d					if DEBUG_FORTH_WORDS 
143d						DMARK "Cdi" 
143d						CALLMONITOR 
143d					endif 
143d					 
143d			.dirnotfound: 
143d					pop bc     
143d					djnz .diritem 
143d				 
143d			.dirdone:	 
143d			 
143d					ld a, 0 
143d					ld hl, (store_tmp2) 
143d					ld (hl), a 
143d					inc hl 
143d					ld (hl), a 
143d					inc hl 
143d					; push a count of the dir items found 
143d			 
143d			;		ld h, 0 
143d			;		ld l, c 
143d			 
143d				ret 
143d			 
143d			endif 
143d			 
143d			 
143d			; Settings 
143d			; Run  
143d			 
143d			 
143d			 
143d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
143d			;;hd_menu2:   db "        2: Editor",0   
143d			;hd_menu2:   db "        2: Editor       6: Menu",0   
143d			;hd_menu3:   db "        3: Storage",0 
143d			;hd_menu4:   db "0=quit  4: Debug",0 
143d			;hd_don:     db "ON",0 
143d			;hd_doff:     db "OFF",0 
143d			; 
143d			; 
143d			; 
143d			;hardware_diags_old:       
143d			; 
143d			;.diagmenu: 
143d			;	call clear_display 
143d			;	ld a, display_row_1 
143d			;	ld de, hd_menu1 
143d			;	call str_at_display 
143d			; 
143d			;	ld a, display_row_2 
143d			;	ld de, hd_menu2 
143d			;	call str_at_display 
143d			; 
143d			;	ld a, display_row_3 
143d			;	ld de, hd_menu3 
143d			;	call str_at_display 
143d			; 
143d			;	ld a,  display_row_4 
143d			;	ld de, hd_menu4 
143d			;	call str_at_display 
143d			; 
143d			;	; display debug state 
143d			; 
143d			;	ld de, hd_don 
143d			;	ld a, (os_view_disable) 
143d			;	cp 0 
143d			;	jr z, .distog 
143d			;	ld de, hd_doff 
143d			;.distog: ld a, display_row_4+17 
143d			;	call str_at_display 
143d			; 
143d			;	call update_display 
143d			; 
143d			;	call cin_wait 
143d			; 
143d			; 
143d			; 
143d			;	cp '4' 
143d			;	jr nz, .diagn1 
143d			; 
143d			;	; debug toggle 
143d			; 
143d			;	ld a, (os_view_disable) 
143d			;	ld b, '*' 
143d			;	cp 0 
143d			;	jr z, .debtog 
143d			;	ld b, 0 
143d			;.debtog:	 
143d			;	ld a,b 
143d			;	ld (os_view_disable),a 
143d			; 
143d			;.diagn1: cp '0' 
143d			;	 ret z 
143d			; 
143d			;;	cp '1' 
143d			;;       jp z, matrix	 
143d			;;   TODO keyboard matrix test 
143d			; 
143d			;	cp '2' 
143d			;	jp z, .diagedit 
143d			; 
143d			;;	cp '6' 
143d			;;	jp z, .menutest 
143d			;;if ENABLE_BASIC 
143d			;;	cp '6' 
143d			;;	jp z, basic 
143d			;;endif 
143d			 ; 
143d			;	jp .diagmenu 
143d			; 
143d			; 
143d			;	ret 
143d			 
143d			 
143d			.debug_tog: 
143d 21 84 14			ld hl, .menudebug 
1440				 
1440 3a f3 e2			ld a, (os_view_disable) 
1443 fe 2a			cp '*' 
1445 20 04			jr nz,.tdon  
1447 3e 01			ld a, 1 
1449 18 02			jr .tog1 
144b 3e 00		.tdon: ld a, 0 
144d			 
144d			.tog1: 
144d cd 79 0b			call menu 
1450 fe 00			cp 0 
1452 c8				ret z 
1453 fe 01			cp 1    ; disable debug 
1455 28 04			jr z, .dtog0 
1457 3e 2a			ld a, '*' 
1459 18 02			jr .dtogset 
145b 3e 00		.dtog0: ld a, 0 
145d 32 f3 e2		.dtogset:  ld (os_view_disable), a 
1460 c3 3d 14			jp .debug_tog 
1463			 
1463			 
1463			hardware_diags:       
1463			 
1463			.diagm: 
1463 21 76 14			ld hl, .menuitems 
1466 3e 00			ld a, 0 
1468 cd 79 0b			call menu 
146b			 
146b fe 00		         cp 0 
146d c8				 ret z 
146e			 
146e fe 02			cp 2 
1470 ca cf 14			jp z, .diagedit 
1473			 
1473			;	cp '6' 
1473			;	jp z, .menutest 
1473			;if ENABLE_BASIC 
1473			;	cp '6' 
1473			;	jp z, basic 
1473			;endif 
1473			  
1473 c3 63 14			jp .diagm 
1476			 
1476				 
1476 8a 14		.menuitems:   	dw .m1 
1478 95 14				dw .m2 
147a 9c 14				dw .m3 
147c a4 14				dw .m5 
147e aa 14				dw .m5a 
1480 b3 14				dw .m5b 
1482 00 00				dw 0 
1484			 
1484			.menudebug: 
1484 bc 14				dw .m6 
1486 c5 14				dw .m7 
1488 00 00				dw 0 
148a			 
148a .. 00		.m1:   db "Key Matrix",0 
1495 .. 00		.m2:   db "Editor",0 
149c .. 00		.m3:   db "Storage",0 
14a4 .. 00		.m5:   db "Sound",0 
14aa .. 00		.m5a:  db "RAM Test",0 
14b3 .. 00		.m5b:  db "LCD Test",0 
14bc			 
14bc .. 00		.m6:   db "Debug ON",0 
14c5 .. 00		.m7:   db "Debug OFF",0 
14cf			 
14cf			; debug editor 
14cf			 
14cf			.diagedit: 
14cf			 
14cf 21 02 e3			ld hl, scratch 
14d2			;	ld bc, 250 
14d2			;	ldir 
14d2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
14d2 3e 00			ld a, 0 
14d4 77				ld (hl), a 
14d5 23				inc hl 
14d6 77				ld (hl), a 
14d7 23				inc hl 
14d8 77				ld (hl), a 
14d9			 
14d9 cd 48 0b		        call clear_display 
14dc cd 6b 0b			call update_display 
14df				;ld a, 1 
14df				;ld (hardware_diag), a 
14df			.diloop: 
14df 3e 00			ld a, display_row_1 
14e1 0e 00			ld c, 0 
14e3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
14e5 1e 28			ld e, 40 
14e7			 
14e7 21 02 e3			ld hl, scratch	 
14ea cd a2 0d			call input_str 
14ed			 
14ed 3e 28			ld a, display_row_2 
14ef 11 02 e3			ld de, scratch 
14f2 cd 5b 0b			call str_at_display 
14f5 cd 6b 0b			call update_display 
14f8			 
14f8 c3 df 14			jp .diloop 
14fb			 
14fb			 
14fb			; pass word in hl 
14fb			; a has display location 
14fb			display_word_at: 
14fb f5				push af 
14fc e5				push hl 
14fd 7c				ld a,h 
14fe 21 07 e6			ld hl, os_word_scratch 
1501 cd 76 10			call hexout 
1504 e1				pop hl 
1505 7d				ld a,l 
1506 21 09 e6			ld hl, os_word_scratch+2 
1509 cd 76 10			call hexout 
150c 21 0b e6			ld hl, os_word_scratch+4 
150f 3e 00			ld a,0 
1511 77				ld (hl),a 
1512 11 07 e6			ld de,os_word_scratch 
1515 f1				pop af 
1516 cd 5b 0b				call str_at_display 
1519 c9				ret 
151a			 
151a			display_ptr_state: 
151a			 
151a				; to restore afterwards 
151a			 
151a d5				push de 
151b c5				push bc 
151c e5				push hl 
151d f5				push af 
151e			 
151e				; for use in here 
151e			 
151e			;	push bc 
151e			;	push de 
151e			;	push hl 
151e			;	push af 
151e			 
151e cd 48 0b			call clear_display 
1521			 
1521 11 f4 16			ld de, .ptrstate 
1524 3e 00			ld a, display_row_1 
1526 cd 5b 0b			call str_at_display 
1529			 
1529				; display debug step 
1529			 
1529			 
1529 11 71 ee			ld de, debug_mark 
152c 3e 26			ld a, display_row_1+display_cols-2 
152e cd 5b 0b			call str_at_display 
1531			 
1531				; display a 
1531 11 fe 16			ld de, .ptrcliptr 
1534 3e 28			ld a, display_row_2 
1536 cd 5b 0b			call str_at_display 
1539			 
1539 f1				pop af 
153a 2a 4d ea			ld hl,(cli_ptr) 
153d 3e 30			ld a, display_row_2+8 
153f cd fb 14			call display_word_at 
1542			 
1542			 
1542				; display hl 
1542			 
1542			 
1542 11 06 17			ld de, .ptrclioptr 
1545 3e 32			ld a, display_row_2+10 
1547 cd 5b 0b			call str_at_display 
154a			; 
154a			;	pop hl 
154a 3e 35			ld a, display_row_2+13 
154c 2a 4b ea			ld hl,(cli_origptr) 
154f cd fb 14			call display_word_at 
1552			; 
1552			;	 
1552			;	; display de 
1552			 
1552			;	ld de, .regstatede 
1552			;	ld a, display_row_3 
1552			;	call str_at_display 
1552			 
1552			;	pop de 
1552			;	ld h,d 
1552			;	ld l, e 
1552			;	ld a, display_row_3+3 
1552			;	call display_word_at 
1552			 
1552			 
1552				; display bc 
1552			 
1552			;	ld de, .regstatebc 
1552			;	ld a, display_row_3+10 
1552			;	call str_at_display 
1552			 
1552			;	pop bc 
1552			;	ld h,b 
1552			;	ld l, c 
1552			;	ld a, display_row_3+13 
1552			;	call display_word_at 
1552			 
1552			 
1552				; display dsp 
1552			 
1552			;	ld de, .regstatedsp 
1552			;	ld a, display_row_4 
1552			;	call str_at_display 
1552			 
1552				 
1552			;	ld hl,(cli_data_sp) 
1552			;	ld a, display_row_4+4 
1552			;	call display_word_at 
1552			 
1552				; display rsp 
1552			 
1552 11 35 17			ld de, .regstatersp 
1555 3e 82			ld a, display_row_4+10 
1557 cd 5b 0b			call str_at_display 
155a			 
155a				 
155a 2a 33 ea			ld hl,(cli_ret_sp) 
155d 3e 86			ld a, display_row_4+14 
155f cd fb 14			call display_word_at 
1562			 
1562 cd 6b 0b			call update_display 
1565			 
1565 cd ba 0a			call delay1s 
1568 cd ba 0a			call delay1s 
156b cd ba 0a			call delay1s 
156e			 
156e			 
156e cd 5f 1b			call next_page_prompt 
1571			 
1571				; restore  
1571			 
1571 f1				pop af 
1572 e1				pop hl 
1573 c1				pop bc 
1574 d1				pop de 
1575 c9				ret 
1576			 
1576			break_point_state: 
1576 f5				push af 
1577			 
1577				; see if disabled 
1577			 
1577 3a f3 e2			ld a, (os_view_disable) 
157a fe 2a			cp '*' 
157c 20 02			jr nz, .bpsgo 
157e f1				pop af 
157f c9				ret 
1580			 
1580			.bpsgo: 
1580 f1				pop af 
1581 f5				push af 
1582 22 ef e2			ld (os_view_hl), hl 
1585 ed 53 ed e2		ld (os_view_de), de 
1589 ed 43 eb e2		ld (os_view_bc), bc 
158d e5				push hl 
158e 6f				ld l, a 
158f 26 00			ld h, 0 
1591 22 f1 e2			ld (os_view_af),hl 
1594			 
1594 21 b7 ed				ld hl, display_fb0 
1597 22 d2 eb				ld (display_fb_active), hl 
159a e1				pop hl	 
159b			 
159b 3e 31			ld a, '1' 
159d fe 2a		.bps1:  cp '*' 
159f 20 03			jr nz, .bps1b 
15a1 32 f3 e2			ld (os_view_disable),a 
15a4 fe 31		.bps1b:  cp '1' 
15a6 20 14			jr nz, .bps2 
15a8			 
15a8				; display reg 
15a8			 
15a8				 
15a8			 
15a8 3a f1 e2			ld a, (os_view_af) 
15ab 2a ef e2			ld hl, (os_view_hl) 
15ae ed 5b ed e2		ld de, (os_view_de) 
15b2 ed 4b eb e2		ld bc, (os_view_bc) 
15b6 cd 50 16			call display_reg_state 
15b9 c3 3c 16			jp .bpschk 
15bc			 
15bc fe 32		.bps2:  cp '2' 
15be 20 08			jr nz, .bps3 
15c0				 
15c0				; display hl 
15c0 2a ef e2			ld hl, (os_view_hl) 
15c3 cd 3a 17			call display_dump_at_hl 
15c6			 
15c6 18 74			jr .bpschk 
15c8			 
15c8 fe 33		.bps3:  cp '3' 
15ca 20 08			jr nz, .bps4 
15cc			 
15cc			        ; display de 
15cc 2a ed e2			ld hl, (os_view_de) 
15cf cd 3a 17			call display_dump_at_hl 
15d2			 
15d2 18 68			jr .bpschk 
15d4 fe 34		.bps4:  cp '4' 
15d6 20 08			jr nz, .bps5 
15d8			 
15d8			        ; display bc 
15d8 2a eb e2			ld hl, (os_view_bc) 
15db cd 3a 17			call display_dump_at_hl 
15de			 
15de 18 5c			jr .bpschk 
15e0 fe 35		.bps5:  cp '5' 
15e2 20 08		        jr nz, .bps7 
15e4			 
15e4				; display cur ptr 
15e4 2a 4d ea			ld hl, (cli_ptr) 
15e7 cd 3a 17			call display_dump_at_hl 
15ea			 
15ea 18 50			jr .bpschk 
15ec fe 36		.bps7:  cp '6' 
15ee 20 08			jr nz, .bps8b 
15f0				 
15f0				; display cur orig ptr 
15f0 2a 4b ea			ld hl, (cli_origptr) 
15f3 cd 3a 17			call display_dump_at_hl 
15f6 18 44			jr .bpschk 
15f8 fe 37		.bps8b:  cp '7' 
15fa 20 08			jr nz, .bps9 
15fc				 
15fc				; display dsp 
15fc 2a 2f ea			ld hl, (cli_data_sp) 
15ff cd 3a 17			call display_dump_at_hl 
1602			 
1602 18 38			jr .bpschk 
1604 fe 39		.bps9:  cp '9' 
1606 20 05			jr nz, .bps8c 
1608				 
1608				; display SP 
1608			;	ld hl, sp 
1608 cd 3a 17			call display_dump_at_hl 
160b			 
160b 18 2f			jr .bpschk 
160d fe 38		.bps8c:  cp '8' 
160f 20 08			jr nz, .bps8d 
1611				 
1611				; display rsp 
1611 2a 33 ea			ld hl, (cli_ret_sp) 
1614 cd 3a 17			call display_dump_at_hl 
1617			 
1617 18 23			jr .bpschk 
1619 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
161b 20 05			jr nz, .bps8 
161d cd 55 19			call monitor 
1620			 
1620 18 1a			jr .bpschk 
1622 fe 30		.bps8:  cp '0' 
1624 20 16			jr nz, .bpschk 
1626			 
1626 21 16 ed				ld hl, display_fb1 
1629 22 d2 eb				ld (display_fb_active), hl 
162c cd 6b 0b				call update_display 
162f			 
162f				;ld a, (os_view_af) 
162f 2a ef e2			ld hl, (os_view_hl) 
1632 ed 5b ed e2		ld de, (os_view_de) 
1636 ed 4b eb e2		ld bc, (os_view_bc) 
163a f1				pop af 
163b c9				ret 
163c			 
163c			.bpschk:   
163c cd ba 0a			call delay1s 
163f 3e 9f		ld a,display_row_4 + display_cols - 1 
1641 11 5d 1b		        ld de, endprg 
1644 cd 5b 0b			call str_at_display 
1647 cd 6b 0b			call update_display 
164a cd 95 5b			call cin_wait 
164d			 
164d c3 9d 15			jp .bps1 
1650			 
1650			 
1650			display_reg_state: 
1650			 
1650				; to restore afterwards 
1650			 
1650 d5				push de 
1651 c5				push bc 
1652 e5				push hl 
1653 f5				push af 
1654			 
1654				; for use in here 
1654			 
1654 c5				push bc 
1655 d5				push de 
1656 e5				push hl 
1657 f5				push af 
1658			 
1658 cd 48 0b			call clear_display 
165b			 
165b 11 10 17			ld de, .regstate 
165e 3e 00			ld a, display_row_1 
1660 cd 5b 0b			call str_at_display 
1663			 
1663				; display debug step 
1663			 
1663			 
1663 11 71 ee			ld de, debug_mark 
1666 3e 25			ld a, display_row_1+display_cols-3 
1668 cd 5b 0b			call str_at_display 
166b			 
166b				; display a 
166b 11 2c 17			ld de, .regstatea 
166e 3e 28			ld a, display_row_2 
1670 cd 5b 0b			call str_at_display 
1673			 
1673 e1				pop hl 
1674			;	ld h,0 
1674			;	ld l, a 
1674 3e 2b			ld a, display_row_2+3 
1676 cd fb 14			call display_word_at 
1679			 
1679			 
1679				; display hl 
1679			 
1679			 
1679 11 20 17			ld de, .regstatehl 
167c 3e 32			ld a, display_row_2+10 
167e cd 5b 0b			call str_at_display 
1681			 
1681 e1				pop hl 
1682 3e 35			ld a, display_row_2+13 
1684 cd fb 14			call display_word_at 
1687			 
1687				 
1687				; display de 
1687			 
1687 11 24 17			ld de, .regstatede 
168a 3e 50			ld a, display_row_3 
168c cd 5b 0b			call str_at_display 
168f			 
168f e1				pop hl 
1690			;	ld h,d 
1690			;	ld l, e 
1690 3e 53			ld a, display_row_3+3 
1692 cd fb 14			call display_word_at 
1695			 
1695			 
1695				; display bc 
1695			 
1695 11 28 17			ld de, .regstatebc 
1698 3e 5a			ld a, display_row_3+10 
169a cd 5b 0b			call str_at_display 
169d			 
169d e1				pop hl 
169e			;	ld h,b 
169e			;	ld l, c 
169e 3e 5d			ld a, display_row_3+13 
16a0 cd fb 14			call display_word_at 
16a3			 
16a3			 
16a3				; display dsp 
16a3			 
16a3 11 30 17			ld de, .regstatedsp 
16a6 3e 78			ld a, display_row_4 
16a8 cd 5b 0b			call str_at_display 
16ab			 
16ab				 
16ab 2a 2f ea			ld hl,(cli_data_sp) 
16ae 3e 7c			ld a, display_row_4+4 
16b0 cd fb 14			call display_word_at 
16b3			 
16b3				; display rsp 
16b3			 
16b3 11 35 17			ld de, .regstatersp 
16b6 3e 82			ld a, display_row_4+10 
16b8 cd 5b 0b			call str_at_display 
16bb			 
16bb				 
16bb 2a 33 ea			ld hl,(cli_ret_sp) 
16be 3e 86			ld a, display_row_4+14 
16c0 cd fb 14			call display_word_at 
16c3			 
16c3 cd 6b 0b			call update_display 
16c6			 
16c6			;	call delay1s 
16c6			;	call delay1s 
16c6			;	call delay1s 
16c6			 
16c6			 
16c6			;	call next_page_prompt 
16c6			 
16c6				; restore  
16c6			 
16c6 f1				pop af 
16c7 e1				pop hl 
16c8 c1				pop bc 
16c9 d1				pop de 
16ca c9				ret 
16cb			 
16cb .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
16df .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
16f4 .. 00		.ptrstate:	db "Ptr State",0 
16fe .. 00		.ptrcliptr:     db "cli_ptr",0 
1706 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1710 .. 00		.regstate:	db "Reg State (1/0)",0 
1720 .. 00		.regstatehl:	db "HL:",0 
1724 .. 00		.regstatede:	db "DE:",0 
1728 .. 00		.regstatebc:	db "BC:",0 
172c .. 00		.regstatea:	db "A :",0 
1730 .. 00		.regstatedsp:	db "DSP:",0 
1735 .. 00		.regstatersp:	db "RSP:",0 
173a			 
173a			display_dump_at_hl: 
173a e5				push hl 
173b d5				push de 
173c c5				push bc 
173d f5				push af 
173e			 
173e 22 25 e6			ld (os_cur_ptr),hl	 
1741 cd 48 0b			call clear_display 
1744 cd 67 1a			call dumpcont 
1747			;	call delay1s 
1747			;	call next_page_prompt 
1747			 
1747			 
1747 f1				pop af 
1748 c1				pop bc 
1749 d1				pop de 
174a e1				pop hl 
174b c9				ret 
174c			 
174c			;if ENABLE_BASIC 
174c			;	include "nascombasic.asm" 
174c			;	basic: 
174c			;	include "forth/FORTH.ASM" 
174c			;endif 
174c			 
174c			; eof 
174c			 
174c			 
# End of file firmware_diags.asm
174c			  
174c			include "firmware_prompts.asm"  
174c			; Prompts  
174c			 
174c			; boot messages 
174c			 
174c .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1761 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1771			 
1771			 
1771			; config menus 
1771			 
1771 .. 00		prom_c3: db "Add Dictionary To File",0 
1788 .. 00		prom_c2: db "Select Autoload File",0 
179d .. 00		prom_c2a: db "Disable Autoload File", 0 
17b3 .. 00		prom_c2b: db "Select Storage Bank",0 
17c7 .. 00		prom_c4: db "Settings",0 
17d0 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
17eb .. 00		prom_m4b:   db "Monitor",0 
17f3 .. 00		prom_c1: db "Hardware Diags",0 
1802			 
1802			 
1802 .. 00		prom_notav:    db "Feature not available",0 
1818 .. 00		prom_empty:    db "",0 
1819			 
1819			; eof 
1819			 
# End of file firmware_prompts.asm
1819			  
1819			  
1819			; eof  
1819			  
# End of file firmware.asm
1819			 
1819			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1819			;if BASE_KEV  
1819			;baseram: equ 08000h 
1819			;endif 
1819			 
1819			;if BASE_SC114 
1819			;baseram:     equ    endofcode 
1819			;endif 
1819			 
1819			 
1819			; start system 
1819			 
1819			coldstart: 
1819				; set sp 
1819				; di/ei 
1819			 
1819 f3				di 
181a 31 00 f0			ld sp, tos 
181d			;	ei 
181d			 
181d			 
181d				; disable breakpoint by default 
181d			 
181d 3e 2a			ld a,'*' 
181f 32 f3 e2			ld (os_view_disable),a 
1822			 
1822				; init hardware 
1822			 
1822				; init keyboard and screen hardware 
1822			 
1822 cd 1c 01			call hardware_init 
1825			 
1825			 
1825 cd ba 0a			call delay1s 
1828 3e 58			ld a, display_row_3+8 
182a 11 03 01			ld de, buildtime 
182d cd 5b 0b			call str_at_display 
1830 cd 6b 0b			call update_display 
1833			 
1833 cd ba 0a			call delay1s 
1836 cd ba 0a			call delay1s 
1839 cd ba 0a			call delay1s 
183c			 
183c				; detect if any keys are held down to enable breakpoints at start up 
183c			 
183c cd 9d 5b			call cin  
183f fe 00			cp 0 
1841 28 03			jr z, .nokeys 
1843			 
1843				;call hardware_diags 
1843 cd d5 13			call config 
1846			 
1846			;	ld de, .bpen 
1846			;	ld a, display_row_4 
1846			;	call str_at_display 
1846			;	call update_display 
1846			; 
1846			;	ld a,0 
1846			;	ld (os_view_disable),a 
1846			; 
1846			;.bpwait: 
1846			;	call cin 
1846			;	cp 0 
1846			;	jr z, .bpwait 
1846			;	jr .nokeys 
1846			; 
1846			; 
1846			;.bpen:  db "Break points enabled!",0 
1846			 
1846			 
1846			 
1846			 
1846			 
1846			 
1846			.nokeys: 
1846			 
1846			 
1846				 
1846			 
1846			;jp  testkey 
1846			 
1846			;call storage_get_block_0 
1846			; 
1846			;ld hl, 0 
1846			;ld de, store_page 
1846			;call storage_read_block 
1846			 
1846				 
1846			;ld hl, 10 
1846			;ld de, store_page 
1846			;call storage_read_block 
1846			 
1846			 
1846			 
1846			 
1846			 
1846			;stop:	nop 
1846			;	jp stop 
1846			 
1846			 
1846			 
1846			main: 
1846 cd 48 0b			call clear_display 
1849 cd 6b 0b			call update_display 
184c			 
184c			 
184c			 
184c			;	call testlcd 
184c			 
184c			 
184c			 
184c cd 25 1f			call forth_init 
184f			 
184f			 
184f			warmstart: 
184f cd fb 1e			call forth_warmstart 
1852			 
1852				; run startup word load 
1852			        ; TODO prevent this running at warmstart after crash  
1852			 
1852				if STARTUP_ENABLE 
1852					if STORAGE_SE 
1852						call forth_autoload 
1852					endif 
1852 cd e3 57				call forth_startup 
1855			 
1855			 
1855				endif 
1855			 
1855				; show free memory after boot 
1855 11 ef 18			ld de, freeram 
1858 3e 00			ld a, display_row_1 
185a cd 5b 0b			call str_at_display 
185d			 
185d			; Or use heap_size word???? 
185d 21 e8 e2			ld hl, heap_end 
1860 11 c5 5b			ld de, heap_start 
1863 ed 52			sbc hl, de 
1865 e5				push hl 
1866 7c				ld a,h	         	 
1867 21 07 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
186a cd 76 10			call hexout 
186d e1			   	pop hl 
186e			 
186e 7d				ld a,l 
186f 21 09 e6			ld hl, os_word_scratch+2 
1872 cd 76 10			call hexout 
1875 21 0b e6			ld hl, os_word_scratch+4 
1878 3e 00			ld a, 0 
187a 77				ld (hl),a 
187b 11 07 e6			ld de, os_word_scratch 
187e 3e 0d			ld a, display_row_1 + 13 
1880 cd 5b 0b			call str_at_display 
1883 cd 6b 0b			call update_display 
1886			 
1886			 
1886				;call demo 
1886			 
1886			 
1886				; init scratch input area for cli commands 
1886			 
1886 21 29 e6			ld hl, os_cli_cmd 
1889 3e 00			ld a,0 
188b 77				ld (hl),a 
188c 23				inc hl 
188d 77				ld (hl),a 
188e			 
188e 3e 00			ld a,0 
1890 32 28 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1893			 
1893 32 25 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1896 32 26 e6			ld (os_cur_ptr+1),a	 
1899			 
1899 32 07 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
189c 32 08 e6			ld (os_word_scratch+1),a	 
189f				 
189f			 
189f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
189f 21 29 e6			ld hl, os_cli_cmd 
18a2			 
18a2 3e 00			ld a, 0		 ; init cli input 
18a4 77				ld (hl), a 
18a5 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18a7			cli: 
18a7				; show cli prompt 
18a7				;push af 
18a7				;ld a, 0 
18a7				;ld de, prompt 
18a7				;call str_at_display 
18a7			 
18a7				;call update_display 
18a7				;pop af 
18a7				;inc a 
18a7				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18a7 0e 00			ld c, 0 
18a9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18ab 1e 28			ld e, 40 
18ad			 
18ad 21 29 e6			ld hl, os_cli_cmd 
18b0			 
18b0				STACKFRAME OFF $fefe $9f9f 
18b0				if DEBUG_STACK_IMB 
18b0					if OFF 
18b0						exx 
18b0						ld de, $fefe 
18b0						ld a, d 
18b0						ld hl, curframe 
18b0						call hexout 
18b0						ld a, e 
18b0						ld hl, curframe+2 
18b0						call hexout 
18b0						ld hl, $fefe 
18b0						push hl 
18b0						ld hl, $9f9f 
18b0						push hl 
18b0						exx 
18b0					endif 
18b0				endif 
18b0			endm 
# End of macro STACKFRAME
18b0			 
18b0 cd a2 0d			call input_str 
18b3			 
18b3				STACKFRAMECHK OFF $fefe $9f9f 
18b3				if DEBUG_STACK_IMB 
18b3					if OFF 
18b3						exx 
18b3						ld hl, $9f9f 
18b3						pop de   ; $9f9f 
18b3						call cmp16 
18b3						jr nz, .spnosame 
18b3						ld hl, $fefe 
18b3						pop de   ; $fefe 
18b3						call cmp16 
18b3						jr z, .spfrsame 
18b3						.spnosame: call showsperror 
18b3						.spfrsame: nop 
18b3						exx 
18b3					endif 
18b3				endif 
18b3			endm 
# End of macro STACKFRAMECHK
18b3			 
18b3				; copy input to last command 
18b3			 
18b3 21 29 e6			ld hl, os_cli_cmd 
18b6 11 28 e7			ld de, os_last_cmd 
18b9 01 ff 00			ld bc, 255 
18bc ed b0			ldir 
18be			 
18be				; wipe current buffer 
18be			 
18be			;	ld a, 0 
18be			;	ld hl, os_cli_cmd 
18be			;	ld de, os_cli_cmd+1 
18be			;	ld bc, 254 
18be			;	ldir 
18be				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18be			;	call strcpy 
18be			;	ld a, 0 
18be			;	ld (hl), a 
18be			;	inc hl 
18be			;	ld (hl), a 
18be			;	inc hl 
18be			;	ld (hl), a 
18be			 
18be				; switch frame buffer to program  
18be			 
18be 21 16 ed				ld hl, display_fb1 
18c1 22 d2 eb				ld (display_fb_active), hl 
18c4			 
18c4			;	nop 
18c4				STACKFRAME ON $fbfe $8f9f 
18c4				if DEBUG_STACK_IMB 
18c4					if ON 
18c4						exx 
18c4						ld de, $fbfe 
18c4						ld a, d 
18c4						ld hl, curframe 
18c4						call hexout 
18c4						ld a, e 
18c4						ld hl, curframe+2 
18c4						call hexout 
18c4						ld hl, $fbfe 
18c4						push hl 
18c4						ld hl, $8f9f 
18c4						push hl 
18c4						exx 
18c4					endif 
18c4				endif 
18c4			endm 
# End of macro STACKFRAME
18c4				; first time into the parser so pass over the current scratch pad 
18c4 21 29 e6			ld hl,os_cli_cmd 
18c7				; tokenise the entered statement(s) in HL 
18c7 cd a3 1f			call forthparse 
18ca			        ; exec forth statements in top of return stack 
18ca cd e3 1f			call forthexec 
18cd				;call forthexec_cleanup 
18cd			;	call parsenext 
18cd			 
18cd				STACKFRAMECHK ON $fbfe $8f9f 
18cd				if DEBUG_STACK_IMB 
18cd					if ON 
18cd						exx 
18cd						ld hl, $8f9f 
18cd						pop de   ; $8f9f 
18cd						call cmp16 
18cd						jr nz, .spnosame 
18cd						ld hl, $fbfe 
18cd						pop de   ; $fbfe 
18cd						call cmp16 
18cd						jr z, .spfrsame 
18cd						.spnosame: call showsperror 
18cd						.spfrsame: nop 
18cd						exx 
18cd					endif 
18cd				endif 
18cd			endm 
# End of macro STACKFRAMECHK
18cd				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
18cd			 
18cd 3e 78			ld a, display_row_4 
18cf 11 01 19			ld de, endprog 
18d2			 
18d2 cd 6b 0b			call update_display		 
18d5			 
18d5 cd 5f 1b			call next_page_prompt 
18d8			 
18d8				; switch frame buffer to cli 
18d8			 
18d8 21 b7 ed				ld hl, display_fb0 
18db 22 d2 eb				ld (display_fb_active), hl 
18de			 
18de			 
18de cd 48 0b		        call clear_display 
18e1 cd 6b 0b			call update_display		 
18e4			 
18e4 21 29 e6			ld hl, os_cli_cmd 
18e7			 
18e7 3e 00			ld a, 0		 ; init cli input 
18e9 77				ld (hl), a 
18ea			 
18ea				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
18ea			 
18ea				; now on last line 
18ea			 
18ea				; TODO scroll screen up 
18ea			 
18ea				; TODO instead just clear screen and place at top of screen 
18ea			 
18ea			;	ld a, 0 
18ea			;	ld (f_cursor_ptr),a 
18ea			 
18ea				;call clear_display 
18ea				;call update_display 
18ea			 
18ea				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18ea 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18ec c3 a7 18			jp cli 
18ef			 
18ef .. 00		freeram: db "Free bytes: $",0 
18fd ..			asc: db "1A2F" 
1901 .. 00		endprog: db "End prog...",0 
190d			 
190d			testenter2:   
190d 21 34 e3			ld hl,scratch+50 
1910 22 25 e6			ld (os_cur_ptr),hl 
1913 c3 a7 18			jp cli 
1916			 
1916			testenter:  
1916			 
1916 21 fd 18			ld hl,asc 
1919			;	ld a,(hl) 
1919			;	call nibble2val 
1919 cd cc 10			call get_byte 
191c			 
191c			 
191c			;	ld a,(hl) 
191c			;	call atohex 
191c			 
191c			;	call fourehexhl 
191c 32 34 e3			ld (scratch+50),a 
191f			 
191f			 
191f			 
191f 21 ff 18			ld hl,asc+2 
1922			;	ld a, (hl) 
1922			;	call nibble2val 
1922 cd cc 10			call get_byte 
1925			 
1925			;	call fourehexhl 
1925 32 36 e3			ld (scratch+52),a 
1928				 
1928 21 34 e3			ld hl,scratch+50 
192b 22 25 e6			ld (os_cur_ptr),hl 
192e c3 a7 18			jp cli 
1931			 
1931			enter:	 
1931 3a 06 e3			ld a,(scratch+4) 
1934 fe 00			cp 0 
1936 28 0c			jr z, .entercont 
1938				; no, not a null term line so has an address to work out.... 
1938			 
1938 21 04 e3			ld hl,scratch+2 
193b cd 2c 11			call get_word_hl 
193e			 
193e 22 25 e6			ld (os_cur_ptr),hl	 
1941 c3 a7 18			jp cli 
1944			 
1944			 
1944			.entercont:  
1944			 
1944 21 04 e3			ld hl, scratch+2 
1947 cd cc 10			call get_byte 
194a			 
194a 2a 25 e6		   	ld hl,(os_cur_ptr) 
194d 77					ld (hl),a 
194e 23					inc hl 
194f 22 25 e6				ld (os_cur_ptr),hl 
1952				 
1952			; get byte  
1952			 
1952			 
1952 c3 a7 18			jp cli 
1955			 
1955			 
1955			; basic monitor support 
1955			 
1955			monitor: 
1955				;  
1955 cd 48 0b			call clear_display 
1958 3e 00			ld a, 0 
195a 11 a2 19			ld de, .monprompt 
195d cd 5b 0b			call str_at_display 
1960 cd 6b 0b			call update_display 
1963			 
1963				; get a monitor command 
1963			 
1963 0e 00			ld c, 0     ; entry at top left 
1965 16 64			ld d, 100   ; max buffer size 
1967 1e 0f			ld e, 15    ; input scroll area 
1969 3e 00			ld a, 0     ; init string 
196b 21 00 e5			ld hl, os_input 
196e 77				ld (hl), a 
196f 23				inc hl 
1970 77				ld (hl), a 
1971 21 00 e5			ld hl, os_input 
1974 3e 01			ld a, 1     ; init string 
1976 cd a2 0d			call input_str 
1979			 
1979 cd 48 0b		        call clear_display 
197c cd 6b 0b			call update_display		 
197f			 
197f 3a 00 e5			ld a, (os_input) 
1982 cd ca 11			call toUpper 
1985 fe 48		        cp 'H' 
1987 28 6f		        jr z, .monhelp 
1989 fe 44			cp 'D'		; dump 
198b ca 19 1a			jp z, .mondump	 
198e fe 43			cp 'C'		; dump 
1990 ca 33 1a			jp z, .moncdump	 
1993 fe 4d			cp 'M'		; dump 
1995 ca a4 19			jp z, .moneditstart 
1998 fe 55			cp 'U'		; dump 
199a 28 14			jr z, .monedit	 
199c fe 51			cp 'Q'		; dump 
199e c8				ret z	 
199f			 
199f			 
199f				; TODO "S" to access symbol by name and not need the address 
199f				; TODO "F" to find a string in memory 
199f			 
199f c3 55 19			jp monitor 
19a2			 
19a2 .. 00		.monprompt: db ">", 0 
19a4			 
19a4			.moneditstart: 
19a4				; get starting address 
19a4			 
19a4 21 02 e5			ld hl,os_input+2 
19a7 cd 2c 11			call get_word_hl 
19aa			 
19aa 22 25 e6			ld (os_cur_ptr),hl	 
19ad			 
19ad c3 55 19			jp monitor 
19b0			 
19b0			.monedit: 
19b0				; get byte to load 
19b0			 
19b0 21 02 e5			ld hl,os_input+2 
19b3 cd cc 10			call get_byte 
19b6			 
19b6				; get address to update 
19b6 2a 25 e6			ld hl, (os_cur_ptr) 
19b9			 
19b9				; update byte 
19b9			 
19b9 77				ld (hl), a 
19ba			 
19ba				; move to next address and save it 
19ba			 
19ba 23				inc hl 
19bb 22 25 e6			ld (os_cur_ptr),hl	 
19be			 
19be c3 55 19			jp monitor 
19c1			 
19c1			 
19c1 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
19d5 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
19f1 .. 00		.monhelptext3:  db "Q-Quit",0 
19f8			        
19f8			.monhelp: 
19f8 3e 00			ld a, display_row_1 
19fa 11 c1 19		        ld de, .monhelptext1 
19fd			 
19fd cd 5b 0b			call str_at_display 
1a00 3e 28			ld a, display_row_2 
1a02 11 d5 19		        ld de, .monhelptext2 
1a05					 
1a05 cd 5b 0b			call str_at_display 
1a08 3e 50			ld a, display_row_3 
1a0a 11 f1 19		        ld de, .monhelptext3 
1a0d					 
1a0d cd 5b 0b			call str_at_display 
1a10 cd 6b 0b			call update_display		 
1a13			 
1a13 cd 5f 1b			call next_page_prompt 
1a16 c3 55 19			jp monitor 
1a19			 
1a19			.mondump:    
1a19 21 02 e5			ld hl,os_input+2 
1a1c cd 2c 11			call get_word_hl 
1a1f			 
1a1f 22 25 e6			ld (os_cur_ptr),hl	 
1a22 cd 67 1a			call dumpcont 
1a25 3e 78			ld a, display_row_4 
1a27 11 01 19			ld de, endprog 
1a2a			 
1a2a cd 6b 0b			call update_display		 
1a2d			 
1a2d cd 5f 1b			call next_page_prompt 
1a30 c3 55 19			jp monitor 
1a33			.moncdump: 
1a33 cd 67 1a			call dumpcont 
1a36 3e 78			ld a, display_row_4 
1a38 11 01 19			ld de, endprog 
1a3b			 
1a3b cd 6b 0b			call update_display		 
1a3e			 
1a3e cd 5f 1b			call next_page_prompt 
1a41 c3 55 19			jp monitor 
1a44			 
1a44			 
1a44			; TODO symbol access  
1a44			 
1a44			.symbols:     ;; A list of symbols that can be called up  
1a44 b7 ed			dw display_fb0 
1a46 .. 00			db "fb0",0  
1a4a 84 ea		     	dw store_page 
1a4c .. 00			db "store_page",0 
1a57			 
1a57			 
1a57			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a57			 
1a57 3a 03 e3			ld a,(scratch+1) 
1a5a fe 00			cp 0 
1a5c 28 09			jr z, dumpcont 
1a5e			 
1a5e				; no, not a null term line so has an address to work out.... 
1a5e			 
1a5e 21 04 e3			ld hl,scratch+2 
1a61 cd 2c 11			call get_word_hl 
1a64			 
1a64 22 25 e6			ld (os_cur_ptr),hl	 
1a67			 
1a67			 
1a67			 
1a67			dumpcont: 
1a67			 
1a67				; dump bytes at ptr 
1a67			 
1a67			 
1a67 3e 00			ld a, display_row_1 
1a69 2a d2 eb			ld hl, (display_fb_active) 
1a6c cd 75 0d			call addatohl 
1a6f cd 97 1a			call .dumpbyterow 
1a72			 
1a72 3e 28			ld a, display_row_2 
1a74 2a d2 eb			ld hl, (display_fb_active) 
1a77 cd 75 0d			call addatohl 
1a7a cd 97 1a			call .dumpbyterow 
1a7d			 
1a7d			 
1a7d 3e 50			ld a, display_row_3 
1a7f 2a d2 eb			ld hl, (display_fb_active) 
1a82 cd 75 0d			call addatohl 
1a85 cd 97 1a			call .dumpbyterow 
1a88			 
1a88 3e 78			ld a, display_row_4 
1a8a 2a d2 eb			ld hl, (display_fb_active) 
1a8d cd 75 0d			call addatohl 
1a90 cd 97 1a			call .dumpbyterow 
1a93			 
1a93 cd 6b 0b			call update_display 
1a96			;		jp cli 
1a96 c9				ret 
1a97			 
1a97			.dumpbyterow: 
1a97			 
1a97				;push af 
1a97			 
1a97 e5				push hl 
1a98			 
1a98				; calc where to poke the ascii 
1a98			if display_cols == 20 
1a98				ld a, 16 
1a98			else 
1a98 3e 1f			ld a, 31 
1a9a			endif 
1a9a			 
1a9a cd 75 0d			call addatohl 
1a9d 22 07 e6			ld (os_word_scratch),hl  		; save pos for later 
1aa0			 
1aa0			 
1aa0			; display decoding address 
1aa0 2a 25 e6		   	ld hl,(os_cur_ptr) 
1aa3			 
1aa3 7c				ld a,h 
1aa4 e1				pop hl 
1aa5 e5				push hl 
1aa6			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1aa6 cd 76 10			call hexout 
1aa9 2a 25 e6		   	ld hl,(os_cur_ptr) 
1aac			 
1aac 7d				ld a,l 
1aad e1				pop hl 
1aae 23				inc hl 
1aaf 23				inc hl 
1ab0 e5				push hl 
1ab1			;	ld hl, os_word_scratch+2 
1ab1 cd 76 10			call hexout 
1ab4 e1				pop hl 
1ab5 23				inc hl 
1ab6 23				inc hl 
1ab7				;ld hl, os_word_scratch+4 
1ab7 3e 3a			ld a, ':' 
1ab9 77				ld (hl),a 
1aba 23				inc hl 
1abb				;ld a, 0 
1abb				;ld (hl),a 
1abb				;ld de, os_word_scratch 
1abb				;pop af 
1abb				;push af 
1abb			;		ld a, display_row_2 
1abb			;		call str_at_display 
1abb			;		call update_display 
1abb			 
1abb			 
1abb			;pop af 
1abb			;	add 5 
1abb			 
1abb			if display_cols == 20 
1abb				ld b, 4 
1abb			else 
1abb 06 08			ld b, 8 
1abd			endif	 
1abd			 
1abd			.dumpbyte: 
1abd c5				push bc 
1abe e5				push hl 
1abf			 
1abf			 
1abf 2a 25 e6		   	ld hl,(os_cur_ptr) 
1ac2 7e					ld a,(hl) 
1ac3			 
1ac3					; poke the ascii to display 
1ac3 2a 07 e6				ld hl,(os_word_scratch) 
1ac6 77					ld (hl),a 
1ac7 23					inc hl 
1ac8 22 07 e6				ld (os_word_scratch),hl 
1acb			 
1acb					 
1acb			 
1acb			 
1acb e1					pop hl 
1acc e5					push hl 
1acd			 
1acd cd 76 10				call hexout 
1ad0			 
1ad0					 
1ad0 2a 25 e6		   	ld hl,(os_cur_ptr) 
1ad3 23				inc hl 
1ad4 22 25 e6		   	ld (os_cur_ptr),hl 
1ad7			 
1ad7 e1					pop hl 
1ad8 23					inc hl 
1ad9 23					inc hl 
1ada 23					inc hl 
1adb			 
1adb			 
1adb			 
1adb					;ld a,0 
1adb					;ld (os_word_scratch+2),a 
1adb					;pop af 
1adb					;push af 
1adb			 
1adb					;ld de, os_word_scratch 
1adb					;call str_at_display 
1adb			;		call update_display 
1adb			;		pop af 
1adb c1					pop bc 
1adc c6 03				add 3 
1ade 10 dd			djnz .dumpbyte 
1ae0			 
1ae0				 
1ae0			 
1ae0 c9				ret 
1ae1			 
1ae1			jump:	 
1ae1			 
1ae1 21 04 e3			ld hl,scratch+2 
1ae4 cd 2c 11			call get_word_hl 
1ae7				;ld hl,(scratch+2) 
1ae7				;call fourehexhl 
1ae7			 
1ae7 22 25 e6			ld (os_cur_ptr),hl	 
1aea			 
1aea e9				jp (hl) 
1aeb			 
1aeb			 
1aeb			 
1aeb			; TODO implement a basic monitor mode to start with 
1aeb			 
1aeb			 
1aeb			 
1aeb			 
1aeb			 
1aeb			 
1aeb			 
1aeb			 
1aeb			 
1aeb			; testing and demo code during development 
1aeb			 
1aeb			 
1aeb .. 00		str1: db "Enter some text...",0 
1afe .. 00		clear: db "                    ",0 
1b13			 
1b13			demo: 
1b13			 
1b13			 
1b13			 
1b13			;	call update_display 
1b13			 
1b13				; init scratch input area for testing 
1b13 21 02 e3			ld hl, scratch	 
1b16 3e 00			ld a,0 
1b18 77				ld (hl),a 
1b19			 
1b19			 
1b19 3e 28		            LD   A, display_row_2 
1b1b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b1b 11 eb 1a		            LD   DE, str1 
1b1e cd 5b 0b			call str_at_display 
1b21			 
1b21			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b21			cloop:	 
1b21 3e 50		            LD   A, display_row_3 
1b23			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b23 11 fe 1a		            LD   DE, clear 
1b26			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b26 cd 5b 0b				call str_at_display 
1b29 3e 78			ld a, display_row_4 
1b2b 11 5b 1b			ld de, prompt 
1b2e			 
1b2e cd 5b 0b				call str_at_display 
1b31 cd 6b 0b			call update_display 
1b34			 
1b34 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b36 16 0a			ld d, 10 
1b38 21 02 e3			ld hl, scratch	 
1b3b cd a2 0d			call input_str 
1b3e			 
1b3e			;	call clear_display 
1b3e			;'	call update_display 
1b3e			 
1b3e 3e 00		            LD   A, display_row_1 
1b40			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b40 11 fe 1a		            LD   DE, clear 
1b43 cd 5b 0b				call str_at_display 
1b46			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b46 3e 00		            LD   A, display_row_1 
1b48			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b48 11 02 e3		            LD   DE, scratch 
1b4b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b4b cd 5b 0b				call str_at_display 
1b4e cd 6b 0b			call update_display 
1b51			 
1b51 3e 00				ld a,0 
1b53 21 02 e3			ld hl, scratch 
1b56 77				ld (hl),a 
1b57			 
1b57 00				nop 
1b58 c3 21 1b			jp cloop 
1b5b			 
1b5b			 
1b5b			 
1b5b			; OS Prompt 
1b5b			 
1b5b .. 00		prompt: db ">",0 
1b5d .. 00		endprg: db "?",0 
1b5f			 
1b5f			 
1b5f			; handy next page prompt 
1b5f			next_page_prompt: 
1b5f e5				push hl 
1b60 d5				push de 
1b61 f5				push af 
1b62 c5				push bc 
1b63			 
1b63 3e 9f			ld a,display_row_4 + display_cols - 1 
1b65 11 5d 1b		        ld de, endprg 
1b68 cd 5b 0b			call str_at_display 
1b6b cd 6b 0b			call update_display 
1b6e cd 95 5b			call cin_wait 
1b71 c1				pop bc 
1b72 f1				pop af 
1b73 d1				pop de 
1b74 e1				pop hl 
1b75			 
1b75			 
1b75 c9				ret 
1b76			 
1b76			 
1b76			; forth parser 
1b76			 
1b76			; My forth kernel 
1b76			include "forth_kernel.asm" 
1b76			; 
1b76			; kernel to the forth OS 
1b76			 
1b76			DS_TYPE_STR: equ 1     ; string type 
1b76			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b76			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b76			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b76			 
1b76			FORTH_PARSEV1: equ 0 
1b76			FORTH_PARSEV2: equ 0 
1b76			FORTH_PARSEV3: equ 0 
1b76			FORTH_PARSEV4: equ 0 
1b76			FORTH_PARSEV5: equ 1 
1b76			 
1b76			;if FORTH_PARSEV5 
1b76			;	FORTH_END_BUFFER: equ 0 
1b76			;else 
1b76			FORTH_END_BUFFER: equ 127 
1b76			;endif 
1b76			 
1b76			FORTH_TRUE: equ 1 
1b76			FORTH_FALSE: equ 0 
1b76			 
1b76			if FORTH_PARSEV4 
1b76			include "forth_stackops.asm" 
1b76			endif 
1b76			 
1b76			if FORTH_PARSEV5 
1b76			include "forth_stackopsv5.asm" 
1b76			 
1b76			; Stack operations for v5 parser on wards 
1b76			; * DATA stack 
1b76			; * LOOP stack 
1b76			; * RETURN stack 
1b76			 
1b76			 
1b76			 
1b76			FORTH_CHK_DSP_UNDER: macro 
1b76				push hl 
1b76				push de 
1b76				ld hl,(cli_data_sp) 
1b76				ld de, cli_data_stack 
1b76				call cmp16 
1b76				jp c, fault_dsp_under 
1b76				pop de 
1b76				pop hl 
1b76				endm 
1b76			 
1b76			 
1b76			FORTH_CHK_RSP_UNDER: macro 
1b76				push hl 
1b76				push de 
1b76				ld hl,(cli_ret_sp) 
1b76				ld de, cli_ret_stack 
1b76				call cmp16 
1b76				jp c, fault_rsp_under 
1b76				pop de 
1b76				pop hl 
1b76				endm 
1b76			 
1b76			FORTH_CHK_LOOP_UNDER: macro 
1b76				push hl 
1b76				push de 
1b76				ld hl,(cli_loop_sp) 
1b76				ld de, cli_loop_stack 
1b76				call cmp16 
1b76				jp c, fault_loop_under 
1b76				pop de 
1b76				pop hl 
1b76				endm 
1b76			 
1b76			FORTH_ERR_TOS_NOTSTR: macro 
1b76				; TOSO might need more for checks when used 
1b76				push af 
1b76				ld a,(hl) 
1b76				cp DS_TYPE_STR 
1b76				jp nz, type_faultn   
1b76				pop af 
1b76				endm 
1b76			 
1b76			FORTH_ERR_TOS_NOTNUM: macro 
1b76				push af 
1b76				ld a,(hl) 
1b76				cp DS_TYPE_INUM 
1b76				jp nz, type_faultn   
1b76				pop af 
1b76				endm 
1b76			 
1b76			 
1b76			; increase data stack pointer and save hl to it 
1b76				 
1b76			FORTH_DSP_NEXT: macro 
1b76				call macro_forth_dsp_next 
1b76				endm 
1b76			 
1b76			 
1b76			macro_forth_dsp_next: 
1b76				if DEBUG_FORTH_STACK_GUARD 
1b76 cd ad 58				call check_stacks 
1b79				endif 
1b79 e5				push hl 
1b7a d5				push de 
1b7b eb				ex de,hl 
1b7c 2a 2f ea			ld hl,(cli_data_sp) 
1b7f 23				inc hl 
1b80 23				inc hl 
1b81			 
1b81			; PARSEV5 
1b81 23				inc hl 
1b82 22 2f ea			ld (cli_data_sp),hl 
1b85 73				ld (hl), e 
1b86 23				inc hl 
1b87 72				ld (hl), d 
1b88 d1				pop de 
1b89 e1				pop hl 
1b8a				if DEBUG_FORTH_STACK_GUARD 
1b8a cd ad 58				call check_stacks 
1b8d				endif 
1b8d c9				ret 
1b8e			 
1b8e			 
1b8e			; increase ret stack pointer and save hl to it 
1b8e				 
1b8e			FORTH_RSP_NEXT: macro 
1b8e				call macro_forth_rsp_next 
1b8e				endm 
1b8e			 
1b8e			macro_forth_rsp_next: 
1b8e				if DEBUG_FORTH_STACK_GUARD 
1b8e cd ad 58				call check_stacks 
1b91				endif 
1b91 e5				push hl 
1b92 d5				push de 
1b93 eb				ex de,hl 
1b94 2a 33 ea			ld hl,(cli_ret_sp) 
1b97 23				inc hl 
1b98 23				inc hl 
1b99 22 33 ea			ld (cli_ret_sp),hl 
1b9c 73				ld (hl), e 
1b9d 23				inc hl 
1b9e 72				ld (hl), d 
1b9f d1				pop de 
1ba0 e1				pop hl 
1ba1				if DEBUG_FORTH_STACK_GUARD 
1ba1 cd ad 58				call check_stacks 
1ba4				endif 
1ba4 c9				ret 
1ba5			 
1ba5			; get current ret stack pointer and save to hl  
1ba5				 
1ba5			FORTH_RSP_TOS: macro 
1ba5				call macro_forth_rsp_tos 
1ba5				endm 
1ba5			 
1ba5			macro_forth_rsp_tos: 
1ba5				;push de 
1ba5 2a 33 ea			ld hl,(cli_ret_sp) 
1ba8 cd e0 1b			call loadhlptrtohl 
1bab				;ld e, (hl) 
1bab				;inc hl 
1bab				;ld d, (hl) 
1bab				;ex de, hl 
1bab					if DEBUG_FORTH_WORDS 
1bab			;			DMARK "RST" 
1bab						CALLMONITOR 
1bab cd 76 15			call break_point_state  
1bae				endm  
# End of macro CALLMONITOR
1bae					endif 
1bae				;pop de 
1bae c9				ret 
1baf			 
1baf			; pop ret stack pointer 
1baf				 
1baf			FORTH_RSP_POP: macro 
1baf				call macro_forth_rsp_pop 
1baf				endm 
1baf			 
1baf			 
1baf			macro_forth_rsp_pop: 
1baf				if DEBUG_FORTH_STACK_GUARD 
1baf			;		DMARK "RPP" 
1baf cd ad 58				call check_stacks 
1bb2					FORTH_CHK_RSP_UNDER 
1bb2 e5				push hl 
1bb3 d5				push de 
1bb4 2a 33 ea			ld hl,(cli_ret_sp) 
1bb7 11 ed e9			ld de, cli_ret_stack 
1bba cd 93 0d			call cmp16 
1bbd da c1 59			jp c, fault_rsp_under 
1bc0 d1				pop de 
1bc1 e1				pop hl 
1bc2				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bc2				endif 
1bc2 e5				push hl 
1bc3 2a 33 ea			ld hl,(cli_ret_sp) 
1bc6			 
1bc6			 
1bc6				if FORTH_ENABLE_FREE 
1bc6			 
1bc6					; get pointer 
1bc6			 
1bc6					push de 
1bc6					push hl 
1bc6			 
1bc6					ld e, (hl) 
1bc6					inc hl 
1bc6					ld d, (hl) 
1bc6			 
1bc6					ex de, hl 
1bc6					call free 
1bc6			 
1bc6					pop hl 
1bc6					pop de 
1bc6			 
1bc6			 
1bc6				endif 
1bc6			 
1bc6			 
1bc6 2b				dec hl 
1bc7 2b				dec hl 
1bc8 22 33 ea			ld (cli_ret_sp), hl 
1bcb				; do stack underflow checks 
1bcb e1				pop hl 
1bcc				if DEBUG_FORTH_STACK_GUARD 
1bcc cd ad 58				call check_stacks 
1bcf					FORTH_CHK_RSP_UNDER 
1bcf e5				push hl 
1bd0 d5				push de 
1bd1 2a 33 ea			ld hl,(cli_ret_sp) 
1bd4 11 ed e9			ld de, cli_ret_stack 
1bd7 cd 93 0d			call cmp16 
1bda da c1 59			jp c, fault_rsp_under 
1bdd d1				pop de 
1bde e1				pop hl 
1bdf				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bdf				endif 
1bdf c9				ret 
1be0			 
1be0			 
1be0			 
1be0			; routine to load word pointed to by hl into hl 
1be0			 
1be0			loadhlptrtohl: 
1be0			 
1be0 d5				push de 
1be1 5e				ld e, (hl) 
1be2 23				inc hl 
1be3 56				ld d, (hl) 
1be4 eb				ex de, hl 
1be5 d1				pop de 
1be6			 
1be6 c9				ret 
1be7			 
1be7			 
1be7			 
1be7			 
1be7			 
1be7			; push a number held in HL onto the data stack 
1be7			; entry point for pushing a value when already in hl used in function above 
1be7			 
1be7			forth_push_numhl: 
1be7			 
1be7 e5				push hl    ; save value to push 
1be8			 
1be8			if DEBUG_FORTH_PUSH 
1be8				; see if disabled 
1be8			 
1be8			 
1be8 f5				push af 
1be9 3a f3 e2			ld a, (os_view_disable) 
1bec fe 2a			cp '*' 
1bee 28 34			jr z, .pskip2 
1bf0 e5				push hl 
1bf1 e5			push hl 
1bf2 cd 48 0b			call clear_display 
1bf5 e1			pop hl 
1bf6 7c				ld a,h 
1bf7 21 07 e6			ld hl, os_word_scratch 
1bfa cd 76 10			call hexout 
1bfd e1				pop hl 
1bfe 7d				ld a,l 
1bff 21 09 e6			ld hl, os_word_scratch+2 
1c02 cd 76 10			call hexout 
1c05			 
1c05 21 0b e6			ld hl, os_word_scratch+4 
1c08 3e 00			ld a,0 
1c0a 77				ld (hl),a 
1c0b 11 07 e6			ld de,os_word_scratch 
1c0e 3e 28				ld a, display_row_2 
1c10 cd 5b 0b				call str_at_display 
1c13 11 64 47			ld de, .push_num 
1c16 3e 00			ld a, display_row_1 
1c18			 
1c18 cd 5b 0b				call str_at_display 
1c1b			 
1c1b			 
1c1b cd 6b 0b			call update_display 
1c1e cd ba 0a			call delay1s 
1c21 cd ba 0a			call delay1s 
1c24			.pskip2:  
1c24			 
1c24 f1				pop af 
1c25			endif	 
1c25			 
1c25			 
1c25				FORTH_DSP_NEXT 
1c25 cd 76 1b			call macro_forth_dsp_next 
1c28				endm 
# End of macro FORTH_DSP_NEXT
1c28			 
1c28 2a 2f ea			ld hl, (cli_data_sp) 
1c2b			 
1c2b				; save item type 
1c2b 3e 02			ld a,  DS_TYPE_INUM 
1c2d 77				ld (hl), a 
1c2e 23				inc hl 
1c2f			 
1c2f				; get word off stack 
1c2f d1				pop de 
1c30 7b				ld a,e 
1c31 77				ld (hl), a 
1c32 23				inc hl 
1c33 7a				ld a,d 
1c34 77				ld (hl), a 
1c35			 
1c35			if DEBUG_FORTH_PUSH 
1c35 2b				dec hl 
1c36 2b				dec hl 
1c37 2b				dec hl 
1c38						DMARK "PH5" 
1c38 f5				push af  
1c39 3a 4d 1c			ld a, (.dmark)  
1c3c 32 71 ee			ld (debug_mark),a  
1c3f 3a 4e 1c			ld a, (.dmark+1)  
1c42 32 72 ee			ld (debug_mark+1),a  
1c45 3a 4f 1c			ld a, (.dmark+2)  
1c48 32 73 ee			ld (debug_mark+2),a  
1c4b 18 03			jr .pastdmark  
1c4d ..			.dmark: db "PH5"  
1c50 f1			.pastdmark: pop af  
1c51			endm  
# End of macro DMARK
1c51				CALLMONITOR 
1c51 cd 76 15			call break_point_state  
1c54				endm  
# End of macro CALLMONITOR
1c54			endif	 
1c54			 
1c54 c9				ret 
1c55			 
1c55			 
1c55			; Push a string to stack pointed to by hl 
1c55			 
1c55			forth_push_str: 
1c55			 
1c55			if DEBUG_FORTH_PUSH 
1c55						DMARK "PSQ" 
1c55 f5				push af  
1c56 3a 6a 1c			ld a, (.dmark)  
1c59 32 71 ee			ld (debug_mark),a  
1c5c 3a 6b 1c			ld a, (.dmark+1)  
1c5f 32 72 ee			ld (debug_mark+1),a  
1c62 3a 6c 1c			ld a, (.dmark+2)  
1c65 32 73 ee			ld (debug_mark+2),a  
1c68 18 03			jr .pastdmark  
1c6a ..			.dmark: db "PSQ"  
1c6d f1			.pastdmark: pop af  
1c6e			endm  
# End of macro DMARK
1c6e				CALLMONITOR 
1c6e cd 76 15			call break_point_state  
1c71				endm  
# End of macro CALLMONITOR
1c71			endif	 
1c71			    
1c71 e5				push hl 
1c72 e5				push hl 
1c73			 
1c73			;	ld a, 0   ; find end of string 
1c73 cd d3 11			call strlenz 
1c76			if DEBUG_FORTH_PUSH 
1c76						DMARK "PQ2" 
1c76 f5				push af  
1c77 3a 8b 1c			ld a, (.dmark)  
1c7a 32 71 ee			ld (debug_mark),a  
1c7d 3a 8c 1c			ld a, (.dmark+1)  
1c80 32 72 ee			ld (debug_mark+1),a  
1c83 3a 8d 1c			ld a, (.dmark+2)  
1c86 32 73 ee			ld (debug_mark+2),a  
1c89 18 03			jr .pastdmark  
1c8b ..			.dmark: db "PQ2"  
1c8e f1			.pastdmark: pop af  
1c8f			endm  
# End of macro DMARK
1c8f				CALLMONITOR 
1c8f cd 76 15			call break_point_state  
1c92				endm  
# End of macro CALLMONITOR
1c92			endif	 
1c92 eb				ex de, hl 
1c93 e1				pop hl   ; get ptr to start of string 
1c94			if DEBUG_FORTH_PUSH 
1c94						DMARK "PQ3" 
1c94 f5				push af  
1c95 3a a9 1c			ld a, (.dmark)  
1c98 32 71 ee			ld (debug_mark),a  
1c9b 3a aa 1c			ld a, (.dmark+1)  
1c9e 32 72 ee			ld (debug_mark+1),a  
1ca1 3a ab 1c			ld a, (.dmark+2)  
1ca4 32 73 ee			ld (debug_mark+2),a  
1ca7 18 03			jr .pastdmark  
1ca9 ..			.dmark: db "PQ3"  
1cac f1			.pastdmark: pop af  
1cad			endm  
# End of macro DMARK
1cad				CALLMONITOR 
1cad cd 76 15			call break_point_state  
1cb0				endm  
# End of macro CALLMONITOR
1cb0			endif	 
1cb0 19				add hl,de 
1cb1			if DEBUG_FORTH_PUSH 
1cb1						DMARK "PQE" 
1cb1 f5				push af  
1cb2 3a c6 1c			ld a, (.dmark)  
1cb5 32 71 ee			ld (debug_mark),a  
1cb8 3a c7 1c			ld a, (.dmark+1)  
1cbb 32 72 ee			ld (debug_mark+1),a  
1cbe 3a c8 1c			ld a, (.dmark+2)  
1cc1 32 73 ee			ld (debug_mark+2),a  
1cc4 18 03			jr .pastdmark  
1cc6 ..			.dmark: db "PQE"  
1cc9 f1			.pastdmark: pop af  
1cca			endm  
# End of macro DMARK
1cca				CALLMONITOR 
1cca cd 76 15			call break_point_state  
1ccd				endm  
# End of macro CALLMONITOR
1ccd			endif	 
1ccd			 
1ccd 2b				dec hl    ; see if there is an optional trailing double quote 
1cce 7e				ld a,(hl) 
1ccf fe 22			cp '"' 
1cd1 20 03			jr nz, .strnoq 
1cd3 3e 00			ld a, 0      ; get rid of double quote 
1cd5 77				ld (hl), a 
1cd6 23			.strnoq: inc hl 
1cd7			 
1cd7 3e 00			ld a, 0 
1cd9 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1cda			 
1cda 13				inc de ; add one for the type string 
1cdb 13				inc de ; add one for null term??? 
1cdc			 
1cdc				; tos is get string pointer again 
1cdc				; de contains space to allocate 
1cdc				 
1cdc d5				push de 
1cdd			 
1cdd eb				ex de, hl 
1cde			 
1cde				;push af 
1cde			 
1cde			if DEBUG_FORTH_PUSH 
1cde						DMARK "PHm" 
1cde f5				push af  
1cdf 3a f3 1c			ld a, (.dmark)  
1ce2 32 71 ee			ld (debug_mark),a  
1ce5 3a f4 1c			ld a, (.dmark+1)  
1ce8 32 72 ee			ld (debug_mark+1),a  
1ceb 3a f5 1c			ld a, (.dmark+2)  
1cee 32 73 ee			ld (debug_mark+2),a  
1cf1 18 03			jr .pastdmark  
1cf3 ..			.dmark: db "PHm"  
1cf6 f1			.pastdmark: pop af  
1cf7			endm  
# End of macro DMARK
1cf7				CALLMONITOR 
1cf7 cd 76 15			call break_point_state  
1cfa				endm  
# End of macro CALLMONITOR
1cfa			endif	 
1cfa cd 3c 12			call malloc	; on ret hl now contains allocated memory 
1cfd				if DEBUG_FORTH_MALLOC_GUARD 
1cfd cc bc 47				call z,malloc_error 
1d00				endif 
1d00			 
1d00				 
1d00 c1				pop bc    ; get length 
1d01 d1				pop de   ;  get string start    
1d02			 
1d02				; hl has destination from malloc 
1d02			 
1d02 eb				ex de, hl    ; prep for ldir 
1d03			 
1d03 d5				push de   ; save malloc area for DSP later 
1d04				;push hl   ; save malloc area for DSP later 
1d04			 
1d04			if DEBUG_FORTH_PUSH 
1d04						DMARK "PHc" 
1d04 f5				push af  
1d05 3a 19 1d			ld a, (.dmark)  
1d08 32 71 ee			ld (debug_mark),a  
1d0b 3a 1a 1d			ld a, (.dmark+1)  
1d0e 32 72 ee			ld (debug_mark+1),a  
1d11 3a 1b 1d			ld a, (.dmark+2)  
1d14 32 73 ee			ld (debug_mark+2),a  
1d17 18 03			jr .pastdmark  
1d19 ..			.dmark: db "PHc"  
1d1c f1			.pastdmark: pop af  
1d1d			endm  
# End of macro DMARK
1d1d				CALLMONITOR 
1d1d cd 76 15			call break_point_state  
1d20				endm  
# End of macro CALLMONITOR
1d20			endif	 
1d20			 
1d20			 
1d20 ed b0			ldir 
1d22			 
1d22			 
1d22				; push malloc to data stack     macro?????  
1d22			 
1d22				FORTH_DSP_NEXT 
1d22 cd 76 1b			call macro_forth_dsp_next 
1d25				endm 
# End of macro FORTH_DSP_NEXT
1d25			 
1d25				; save value and type 
1d25			 
1d25 2a 2f ea			ld hl, (cli_data_sp) 
1d28			 
1d28				; save item type 
1d28 3e 01			ld a,  DS_TYPE_STR 
1d2a 77				ld (hl), a 
1d2b 23				inc hl 
1d2c			 
1d2c				; get malloc word off stack 
1d2c d1				pop de 
1d2d 73				ld (hl), e 
1d2e 23				inc hl 
1d2f 72				ld (hl), d 
1d30			 
1d30			 
1d30			 
1d30			if DEBUG_FORTH_PUSH 
1d30 2a 2f ea			ld hl, (cli_data_sp) 
1d33						DMARK "PHS" 
1d33 f5				push af  
1d34 3a 48 1d			ld a, (.dmark)  
1d37 32 71 ee			ld (debug_mark),a  
1d3a 3a 49 1d			ld a, (.dmark+1)  
1d3d 32 72 ee			ld (debug_mark+1),a  
1d40 3a 4a 1d			ld a, (.dmark+2)  
1d43 32 73 ee			ld (debug_mark+2),a  
1d46 18 03			jr .pastdmark  
1d48 ..			.dmark: db "PHS"  
1d4b f1			.pastdmark: pop af  
1d4c			endm  
# End of macro DMARK
1d4c				CALLMONITOR 
1d4c cd 76 15			call break_point_state  
1d4f				endm  
# End of macro CALLMONITOR
1d4f			;	ex de,hl 
1d4f			endif	 
1d4f				; in case of spaces, skip the ptr past the copied string 
1d4f				;pop af 
1d4f				;ld (cli_origptr),hl 
1d4f			 
1d4f c9				ret 
1d50			 
1d50			 
1d50			 
1d50			; TODO ascii push input onto stack given hl to start of input 
1d50			 
1d50			; identify type 
1d50			; if starts with a " then a string 
1d50			; otherwise it is a number 
1d50			;  
1d50			; if a string 
1d50			;     scan for ending " to get length of string to malloc for + 1 
1d50			;     malloc 
1d50			;     put pointer to string on stack first byte flags as string 
1d50			; 
1d50			; else a number 
1d50			;    look for number format identifier 
1d50			;    $xx hex 
1d50			;    %xxxxx bin 
1d50			;    xxxxx decimal 
1d50			;    convert number to 16bit word.  
1d50			;    malloc word + 1 with flag to identiy as num 
1d50			;    put pointer to number on stack 
1d50			;   
1d50			;  
1d50			  
1d50			forth_apush: 
1d50				; kernel push 
1d50			 
1d50			if DEBUG_FORTH_PUSH 
1d50						DMARK "PSH" 
1d50 f5				push af  
1d51 3a 65 1d			ld a, (.dmark)  
1d54 32 71 ee			ld (debug_mark),a  
1d57 3a 66 1d			ld a, (.dmark+1)  
1d5a 32 72 ee			ld (debug_mark+1),a  
1d5d 3a 67 1d			ld a, (.dmark+2)  
1d60 32 73 ee			ld (debug_mark+2),a  
1d63 18 03			jr .pastdmark  
1d65 ..			.dmark: db "PSH"  
1d68 f1			.pastdmark: pop af  
1d69			endm  
# End of macro DMARK
1d69				CALLMONITOR 
1d69 cd 76 15			call break_point_state  
1d6c				endm  
# End of macro CALLMONITOR
1d6c			endif	 
1d6c				; identify input type 
1d6c			 
1d6c 7e				ld a,(hl) 
1d6d fe 22			cp '"' 
1d6f 28 0a			jr z, .fapstr 
1d71 fe 24			cp '$' 
1d73 ca 9b 1d			jp z, .faphex 
1d76 fe 25			cp '%' 
1d78 ca 83 1d			jp z, .fapbin 
1d7b			;	cp 'b' 
1d7b			;	jp z, .fabin 
1d7b				; else decimal 
1d7b			 
1d7b				; TODO do decimal conversion 
1d7b				; decimal is stored as a 16bit word 
1d7b			 
1d7b				; by default everything is a string if type is not detected 
1d7b			.fapstr: ; 
1d7b fe 22			cp '"' 
1d7d 20 01			jr nz, .strnoqu 
1d7f 23				inc hl 
1d80			.strnoqu: 
1d80 c3 55 1c			jp forth_push_str 
1d83			 
1d83			 
1d83			 
1d83			.fapbin:    ; push a binary string.  
1d83 11 00 00			ld de, 0   ; hold a 16bit value 
1d86			 
1d86 23			.fapbinshift:	inc hl  
1d87 7e				ld a,(hl) 
1d88 fe 00			cp 0     ; done scanning  
1d8a 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d8c			 
1d8c				; left shift de 
1d8c eb				ex de, hl	 
1d8d 29				add hl, hl 
1d8e			 
1d8e				; is 1 
1d8e fe 31			cp '1' 
1d90 20 02			jr nz, .binzero 
1d92 cb 4d			bit 1, l 
1d94			.binzero: 
1d94 eb				ex de, hl	 ; save current de 
1d95 18 ef			jr .fapbinshift 
1d97			 
1d97			.fapbdone: 
1d97 eb				ex de, hl 
1d98 c3 e7 1b			jp forth_push_numhl 
1d9b			 
1d9b			 
1d9b			.faphex:   ; hex is always stored as a 16bit word 
1d9b				; skip number prefix 
1d9b 23				inc hl 
1d9c				; turn ascii into number 
1d9c cd 2c 11			call get_word_hl	; ret 16bit word in hl 
1d9f			 
1d9f c3 e7 1b			jp forth_push_numhl 
1da2			 
1da2 00				 nop 
1da3			 
1da3			.fabin:   ; TODO bin conversion 
1da3			 
1da3			 
1da3 c9				ret 
1da4			 
1da4			 
1da4			; get either a string ptr or a 16bit word from the data stack 
1da4			 
1da4			FORTH_DSP: macro 
1da4				call macro_forth_dsp 
1da4				endm 
1da4			 
1da4			macro_forth_dsp: 
1da4				; data stack pointer points to current word on tos 
1da4			 
1da4 2a 2f ea			ld hl,(cli_data_sp) 
1da7			 
1da7				if DEBUG_FORTH_PUSH 
1da7						DMARK "DSP" 
1da7 f5				push af  
1da8 3a bc 1d			ld a, (.dmark)  
1dab 32 71 ee			ld (debug_mark),a  
1dae 3a bd 1d			ld a, (.dmark+1)  
1db1 32 72 ee			ld (debug_mark+1),a  
1db4 3a be 1d			ld a, (.dmark+2)  
1db7 32 73 ee			ld (debug_mark+2),a  
1dba 18 03			jr .pastdmark  
1dbc ..			.dmark: db "DSP"  
1dbf f1			.pastdmark: pop af  
1dc0			endm  
# End of macro DMARK
1dc0			 
1dc0 cd f1 47				call display_data_sp 
1dc3				;call break_point_state 
1dc3				;rst 030h 
1dc3				CALLMONITOR 
1dc3 cd 76 15			call break_point_state  
1dc6				endm  
# End of macro CALLMONITOR
1dc6				endif 
1dc6			 
1dc6 c9				ret 
1dc7			 
1dc7			; return hl to start of value on stack 
1dc7			 
1dc7			FORTH_DSP_VALUE: macro 
1dc7				call macro_forth_dsp_value 
1dc7				endm 
1dc7			 
1dc7			macro_forth_dsp_value: 
1dc7			 
1dc7				FORTH_DSP 
1dc7 cd a4 1d			call macro_forth_dsp 
1dca				endm 
# End of macro FORTH_DSP
1dca			 
1dca d5				push de 
1dcb			 
1dcb 23				inc hl ; skip type 
1dcc			 
1dcc 5e				ld e, (hl) 
1dcd 23				inc hl 
1dce 56				ld d, (hl) 
1dcf eb				ex de,hl  
1dd0			 
1dd0 d1				pop de 
1dd1			 
1dd1 c9				ret 
1dd2			 
1dd2			; return hl to start of value to second item on stack 
1dd2			 
1dd2			FORTH_DSP_VALUEM1: macro 
1dd2				call macro_forth_dsp_value_m1 
1dd2				endm 
1dd2			 
1dd2			macro_forth_dsp_value_m1: 
1dd2			 
1dd2				FORTH_DSP 
1dd2 cd a4 1d			call macro_forth_dsp 
1dd5				endm 
# End of macro FORTH_DSP
1dd5			 
1dd5 2b				dec hl 
1dd6 2b				dec hl 
1dd7			;	dec hl 
1dd7			 
1dd7 d5				push de 
1dd8			 
1dd8 5e				ld e, (hl) 
1dd9 23				inc hl 
1dda 56				ld d, (hl) 
1ddb eb				ex de,hl  
1ddc			 
1ddc d1				pop de 
1ddd			 
1ddd c9				ret 
1dde			 
1dde				 
1dde			 
1dde			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1dde			 
1dde			FORTH_DSP_POP: macro 
1dde				call macro_forth_dsp_pop 
1dde				endm 
1dde			 
1dde			 
1dde			; get the tos data type 
1dde			 
1dde			FORTH_DSP_TYPE:   macro 
1dde			 
1dde				;FORTH_DSP_VALUE 
1dde				FORTH_DSP 
1dde				 
1dde				; hl points to value 
1dde				; check type 
1dde			 
1dde				ld a,(hl) 
1dde			 
1dde				endm 
1dde			 
1dde			; load the tos value into hl 
1dde			 
1dde			 
1dde			FORTH_DSP_VALUEHL:  macro 
1dde				call macro_dsp_valuehl 
1dde				endm 
1dde			 
1dde			 
1dde			 
1dde			macro_dsp_valuehl: 
1dde				FORTH_DSP_VALUE 
1dde cd c7 1d			call macro_forth_dsp_value 
1de1				endm 
# End of macro FORTH_DSP_VALUE
1de1			 
1de1				;FORTH_ERR_TOS_NOTNUM 
1de1			 
1de1				;inc hl   ; skip type id 
1de1			 
1de1			;	push de 
1de1			; 
1de1			;	ld e, (hl) 
1de1			;	inc hl 
1de1			;	ld d, (hl) 
1de1			;	ex de,hl  
1de1			 
1de1			;	pop de 
1de1			 
1de1				if DEBUG_FORTH_PUSH 
1de1						DMARK "DVL" 
1de1 f5				push af  
1de2 3a f6 1d			ld a, (.dmark)  
1de5 32 71 ee			ld (debug_mark),a  
1de8 3a f7 1d			ld a, (.dmark+1)  
1deb 32 72 ee			ld (debug_mark+1),a  
1dee 3a f8 1d			ld a, (.dmark+2)  
1df1 32 73 ee			ld (debug_mark+2),a  
1df4 18 03			jr .pastdmark  
1df6 ..			.dmark: db "DVL"  
1df9 f1			.pastdmark: pop af  
1dfa			endm  
# End of macro DMARK
1dfa				CALLMONITOR 
1dfa cd 76 15			call break_point_state  
1dfd				endm  
# End of macro CALLMONITOR
1dfd				endif 
1dfd c9				ret 
1dfe			 
1dfe			forth_apushstrhl:      
1dfe				; push of string requires use of cli_origptr 
1dfe				; bodge use 
1dfe			 
1dfe				; get current cli_origptr, save, update with temp pointer  
1dfe ed 5b 4b ea		ld de, (cli_origptr) 
1e02 22 4b ea			ld (cli_origptr), hl 
1e05 d5				push de 
1e06 cd 50 1d			call forth_apush 
1e09 d1				pop de 
1e0a ed 53 4b ea		ld (cli_origptr), de 
1e0e c9			        ret	 
1e0f			 
1e0f			 
1e0f			; increase loop stack pointer and save hl to it 
1e0f				 
1e0f			FORTH_LOOP_NEXT: macro 
1e0f				call macro_forth_loop_next 
1e0f				;nop 
1e0f				endm 
1e0f			 
1e0f			macro_forth_loop_next: 
1e0f				if DEBUG_FORTH_STACK_GUARD 
1e0f cd ad 58				call check_stacks 
1e12				endif 
1e12 e5				push hl 
1e13 d5				push de 
1e14 eb				ex de,hl 
1e15 2a 31 ea			ld hl,(cli_loop_sp) 
1e18 23				inc hl 
1e19 23				inc hl 
1e1a					if DEBUG_FORTH_WORDS 
1e1a						DMARK "LNX" 
1e1a f5				push af  
1e1b 3a 2f 1e			ld a, (.dmark)  
1e1e 32 71 ee			ld (debug_mark),a  
1e21 3a 30 1e			ld a, (.dmark+1)  
1e24 32 72 ee			ld (debug_mark+1),a  
1e27 3a 31 1e			ld a, (.dmark+2)  
1e2a 32 73 ee			ld (debug_mark+2),a  
1e2d 18 03			jr .pastdmark  
1e2f ..			.dmark: db "LNX"  
1e32 f1			.pastdmark: pop af  
1e33			endm  
# End of macro DMARK
1e33						CALLMONITOR 
1e33 cd 76 15			call break_point_state  
1e36				endm  
# End of macro CALLMONITOR
1e36					endif 
1e36 22 31 ea			ld (cli_loop_sp),hl 
1e39 73				ld (hl), e 
1e3a 23				inc hl 
1e3b 72				ld (hl), d 
1e3c d1				pop de    ; been reversed so save a swap on restore 
1e3d e1				pop hl 
1e3e				if DEBUG_FORTH_STACK_GUARD 
1e3e cd ad 58				call check_stacks 
1e41				endif 
1e41 c9				ret 
1e42			 
1e42			; get current ret stack pointer and save to hl  
1e42				 
1e42			FORTH_LOOP_TOS: macro 
1e42				call macro_forth_loop_tos 
1e42				endm 
1e42			 
1e42			macro_forth_loop_tos: 
1e42 d5				push de 
1e43 2a 31 ea			ld hl,(cli_loop_sp) 
1e46 5e				ld e, (hl) 
1e47 23				inc hl 
1e48 56				ld d, (hl) 
1e49 eb				ex de, hl 
1e4a d1				pop de 
1e4b c9				ret 
1e4c			 
1e4c			; pop loop stack pointer 
1e4c				 
1e4c			FORTH_LOOP_POP: macro 
1e4c				call macro_forth_loop_pop 
1e4c				endm 
1e4c			 
1e4c			 
1e4c			macro_forth_loop_pop: 
1e4c				if DEBUG_FORTH_STACK_GUARD 
1e4c					DMARK "LPP" 
1e4c f5				push af  
1e4d 3a 61 1e			ld a, (.dmark)  
1e50 32 71 ee			ld (debug_mark),a  
1e53 3a 62 1e			ld a, (.dmark+1)  
1e56 32 72 ee			ld (debug_mark+1),a  
1e59 3a 63 1e			ld a, (.dmark+2)  
1e5c 32 73 ee			ld (debug_mark+2),a  
1e5f 18 03			jr .pastdmark  
1e61 ..			.dmark: db "LPP"  
1e64 f1			.pastdmark: pop af  
1e65			endm  
# End of macro DMARK
1e65 cd ad 58				call check_stacks 
1e68					FORTH_CHK_LOOP_UNDER 
1e68 e5				push hl 
1e69 d5				push de 
1e6a 2a 31 ea			ld hl,(cli_loop_sp) 
1e6d 11 6b e9			ld de, cli_loop_stack 
1e70 cd 93 0d			call cmp16 
1e73 da c7 59			jp c, fault_loop_under 
1e76 d1				pop de 
1e77 e1				pop hl 
1e78				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e78				endif 
1e78 e5				push hl 
1e79 2a 31 ea			ld hl,(cli_loop_sp) 
1e7c 2b				dec hl 
1e7d 2b				dec hl 
1e7e 22 31 ea			ld (cli_loop_sp), hl 
1e81				; TODO do stack underflow checks 
1e81 e1				pop hl 
1e82				if DEBUG_FORTH_STACK_GUARD 
1e82 cd ad 58				call check_stacks 
1e85					FORTH_CHK_LOOP_UNDER 
1e85 e5				push hl 
1e86 d5				push de 
1e87 2a 31 ea			ld hl,(cli_loop_sp) 
1e8a 11 6b e9			ld de, cli_loop_stack 
1e8d cd 93 0d			call cmp16 
1e90 da c7 59			jp c, fault_loop_under 
1e93 d1				pop de 
1e94 e1				pop hl 
1e95				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e95				endif 
1e95 c9				ret 
1e96			 
1e96			macro_forth_dsp_pop: 
1e96			 
1e96 e5				push hl 
1e97			 
1e97				; release malloc data 
1e97			 
1e97				if DEBUG_FORTH_STACK_GUARD 
1e97 cd ad 58				call check_stacks 
1e9a					FORTH_CHK_DSP_UNDER 
1e9a e5				push hl 
1e9b d5				push de 
1e9c 2a 2f ea			ld hl,(cli_data_sp) 
1e9f 11 69 e8			ld de, cli_data_stack 
1ea2 cd 93 0d			call cmp16 
1ea5 da bb 59			jp c, fault_dsp_under 
1ea8 d1				pop de 
1ea9 e1				pop hl 
1eaa				endm 
# End of macro FORTH_CHK_DSP_UNDER
1eaa				endif 
1eaa				;ld hl,(cli_data_sp) 
1eaa			if DEBUG_FORTH_DOT 
1eaa				DMARK "DPP" 
1eaa				CALLMONITOR 
1eaa			endif	 
1eaa			 
1eaa			 
1eaa			if FORTH_ENABLE_DSPPOPFREE 
1eaa			 
1eaa				FORTH_DSP 
1eaa cd a4 1d			call macro_forth_dsp 
1ead				endm 
# End of macro FORTH_DSP
1ead			 
1ead 7e				ld a, (hl) 
1eae fe 01			cp DS_TYPE_STR 
1eb0 20 07			jr nz, .skippopfree 
1eb2			 
1eb2				FORTH_DSP_VALUEHL 
1eb2 cd de 1d			call macro_dsp_valuehl 
1eb5				endm 
# End of macro FORTH_DSP_VALUEHL
1eb5 00				nop 
1eb6			if DEBUG_FORTH_DOT 
1eb6				DMARK "DPf" 
1eb6				CALLMONITOR 
1eb6			endif	 
1eb6 cd 06 13			call free 
1eb9			.skippopfree: 
1eb9				 
1eb9			 
1eb9			endif 
1eb9			 
1eb9			if DEBUG_FORTH_DOT_KEY 
1eb9				DMARK "DP2" 
1eb9				CALLMONITOR 
1eb9			endif	 
1eb9			 
1eb9				; move pointer down 
1eb9			 
1eb9 2a 2f ea			ld hl,(cli_data_sp) 
1ebc 2b				dec hl 
1ebd 2b				dec hl 
1ebe			; PARSEV5 
1ebe 2b				dec hl 
1ebf 22 2f ea			ld (cli_data_sp), hl 
1ec2			 
1ec2				if DEBUG_FORTH_STACK_GUARD 
1ec2 cd ad 58				call check_stacks 
1ec5					FORTH_CHK_DSP_UNDER 
1ec5 e5				push hl 
1ec6 d5				push de 
1ec7 2a 2f ea			ld hl,(cli_data_sp) 
1eca 11 69 e8			ld de, cli_data_stack 
1ecd cd 93 0d			call cmp16 
1ed0 da bb 59			jp c, fault_dsp_under 
1ed3 d1				pop de 
1ed4 e1				pop hl 
1ed5				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ed5				endif 
1ed5			 
1ed5 e1				pop hl 
1ed6			 
1ed6 c9				ret 
1ed7			 
1ed7			getwordathl: 
1ed7				; hl points to an address 
1ed7				; load hl with the word at that address 
1ed7			 
1ed7 d5				push de 
1ed8			 
1ed8 5e				ld e, (hl) 
1ed9 23				inc hl 
1eda 56				ld d, (hl) 
1edb eb				ex de, hl 
1edc			 
1edc d1				pop de 
1edd c9				ret 
1ede			 
1ede			 
1ede			 
1ede			 
1ede			 
1ede			; eof 
1ede			 
# End of file forth_stackopsv5.asm
1ede			endif 
1ede			 
1ede			user_word_eol:  
1ede				; hl contains the pointer to where to create a linked list item from the end 
1ede				; of the user dict to continue on at the system word dict 
1ede				 
1ede				; poke the stub of the word list linked list to repoint to rom words 
1ede			 
1ede				; stub format 
1ede				; db   word id 
1ede				; dw    link to next word 
1ede			        ; db char length of token 
1ede				; db string + 0 term 
1ede				; db exec code....  
1ede			 
1ede 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ee0 77				ld (hl), a		; word id 
1ee1 23				inc hl 
1ee2			 
1ee2 11 ad 20			ld de, sysdict 
1ee5 73				ld (hl), e		; next word link ie system dict 
1ee6 23				inc hl 
1ee7 72				ld (hl), d		; next word link ie system dict 
1ee8 23				inc hl	 
1ee9			 
1ee9			;	ld (hl), sysdict		; next word link ie system dict 
1ee9			;	inc hl 
1ee9			;	inc hl 
1ee9			 
1ee9			;	inc hl 
1ee9			;	inc hl 
1ee9			 
1ee9 3e 02			ld a, 2			; word length is 0 
1eeb 77				ld (hl), a	 
1eec 23				inc hl 
1eed			 
1eed 3e 7e			ld a, '~'			; word length is 0 
1eef 77				ld (hl), a	 
1ef0 23				inc hl 
1ef1 3e 00			ld a, 0			; save empty word 
1ef3 77				ld (hl), a 
1ef4			 
1ef4 c9				ret 
1ef5			 
1ef5				 
1ef5			 
1ef5			forthexec_cleanup: 
1ef5				FORTH_RSP_POP 
1ef5 cd af 1b			call macro_forth_rsp_pop 
1ef8				endm 
# End of macro FORTH_RSP_POP
1ef8 c9				ret 
1ef9			 
1ef9			forth_call_hl: 
1ef9				; taking hl 
1ef9 e5				push hl 
1efa c9				ret 
1efb			 
1efb			; this is called to reset Forth system but keep existing uwords etc 
1efb			 
1efb			forth_warmstart: 
1efb				; setup stack over/under flow checks 
1efb				if DEBUG_FORTH_STACK_GUARD 
1efb cd 93 58				call chk_stk_init 
1efe				endif 
1efe			 
1efe				; init stack pointers  - * these stacks go upwards *  
1efe 21 ed e9			ld hl, cli_ret_stack 
1f01 22 33 ea			ld (cli_ret_sp), hl	 
1f04				; set bottom of stack 
1f04 3e 00			ld a,0 
1f06 77				ld (hl),a 
1f07 23				inc hl 
1f08 77				ld (hl),a 
1f09			 
1f09 21 69 e8			ld hl, cli_data_stack 
1f0c 22 2f ea			ld (cli_data_sp), hl	 
1f0f				; set bottom of stack 
1f0f 3e 00			ld a,0 
1f11 77				ld (hl),a 
1f12 23				inc hl 
1f13 77				ld (hl),a 
1f14			 
1f14 21 6b e9			ld hl, cli_loop_stack 
1f17 22 31 ea			ld (cli_loop_sp), hl	 
1f1a				; set bottom of stack 
1f1a 3e 00			ld a,0 
1f1c 77				ld (hl),a 
1f1d 23				inc hl 
1f1e 77				ld (hl),a 
1f1f			 
1f1f				; init extent of current open file 
1f1f			 
1f1f 3e 00			ld a, 0 
1f21 32 76 ea			ld (store_openext), a 
1f24			 
1f24 c9				ret 
1f25			 
1f25			 
1f25			; Cold Start - this is called to setup the whole Forth system 
1f25			 
1f25			forth_init: 
1f25			 
1f25				; setup stack over/under flow checks 
1f25			 
1f25			;	if DEBUG_FORTH_STACK_GUARD 
1f25			;		call chk_stk_init 
1f25			;	endif 
1f25			 
1f25				; enable auto display updates (slow.....) 
1f25			 
1f25 3e 01			ld a, 1 
1f27 32 49 ea			ld (cli_autodisplay), a 
1f2a			 
1f2a				; if storage is in use disable long reads for now 
1f2a 3e 00			ld a, 0 
1f2c 32 7f ea			ld (store_longread), a 
1f2f			 
1f2f			 
1f2f				; show start up screen 
1f2f			 
1f2f cd 48 0b			call clear_display 
1f32			 
1f32 3e 00			ld a,0 
1f34 32 6b ea			ld (f_cursor_ptr), a 
1f37			 
1f37				; set start of word list in start of ram - for use when creating user words 
1f37			 
1f37 21 b6 5b			ld hl, baseram 
1f3a 22 ff e5			ld (os_last_new_uword), hl 
1f3d cd de 1e			call user_word_eol 
1f40				 
1f40			;		call display_data_sp 
1f40			;		call next_page_prompt 
1f40			 
1f40			 
1f40			 
1f40			 
1f40 c9				ret 
1f41			 
1f41 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f55			 
1f55			; TODO push to stack 
1f55			 
1f55			;  
1f55			 
1f55			if FORTH_PARSEV2 
1f55			 
1f55			 
1f55				include "forth_parserv2.asm" 
1f55			 
1f55			endif 
1f55			 
1f55			 
1f55			; parse cli version 1 
1f55			 
1f55			if FORTH_PARSEV1 
1f55			 
1f55			 
1f55			 
1f55			      include "forth_parserv1.asm" 
1f55			endif 
1f55				 
1f55			if FORTH_PARSEV3 
1f55			 
1f55			 
1f55			 
1f55			      include "forth_parserv3.asm" 
1f55				include "forth_wordsv3.asm" 
1f55			endif 
1f55			 
1f55			if FORTH_PARSEV4 
1f55			 
1f55			 
1f55			 
1f55			      include "forth_parserv4.asm" 
1f55				include "forth_wordsv4.asm" 
1f55			endif 
1f55			 
1f55			if FORTH_PARSEV5 
1f55			 
1f55			 
1f55			 
1f55			      include "forth_parserv5.asm" 
1f55			 
1f55			 
1f55			; A better parser without using malloc and string copies all over the place.  
1f55			; Exec in situ should be faster 
1f55			 
1f55			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f55			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f55			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f55			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f55			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f55			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f55			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f55			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f55			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f55			 
1f55			; Core word preamble macro 
1f55			 
1f55			CWHEAD:   macro nxtword opcode lit len opflags 
1f55				db WORD_SYS_CORE+opcode             
1f55				; internal op code number 
1f55				dw nxtword            
1f55				; link to next dict word block 
1f55				db len + 1 
1f55				; literal length of dict word inc zero term 
1f55				db lit,0              
1f55				; literal dict word 
1f55			        ; TODO db opflags        
1f55				endm 
1f55			 
1f55			 
1f55			NEXTW: macro  
1f55				jp macro_next 
1f55				endm 
1f55			 
1f55			macro_next: 
1f55			if DEBUG_FORTH_PARSE_KEY 
1f55				DMARK "NXT" 
1f55				CALLMONITOR 
1f55			endif	 
1f55			;	inc hl  ; skip token null term  
1f55 ed 4b 4d ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f59 ed 5b 4b ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f5d 2a 03 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f60			if DEBUG_FORTH_PARSE_KEY 
1f60				DMARK "}AA" 
1f60				CALLMONITOR 
1f60			endif	 
1f60 c3 63 20			jp execnext 
1f63				;jp exec1 
1f63			       
1f63			 
1f63			 
1f63			; Another go at the parser to compile  
1f63			 
1f63			 
1f63			; TODO rework parser to change all of the string words to byte tokens 
1f63			; TODO do a search for  
1f63			 
1f63			; TODO first run normal parser to zero term sections 
1f63			; TODO for each word do a token look up to get the op code 
1f63			; TODO need some means to flag to the exec that this is a byte code form    
1f63			 
1f63			 
1f63			forthcompile: 
1f63			 
1f63			; 
1f63			; line parse: 
1f63			;       parse raw input buffer 
1f63			;       tokenise the words 
1f63			;       malloc new copy (for looping etc) 
1f63			;       copy to malloc + current pc in line to start of string and add line term 
1f63			;       save on new rsp 
1f63			; 
1f63			 
1f63			; hl to point to the line to tokenise 
1f63			 
1f63			;	push hl 
1f63 22 03 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1f66			 
1f66			;	ld a,0		; string term on input 
1f66			;	call strlent 
1f66			 
1f66			;	ld (os_tok_len), hl	 ; save string length 
1f66			 
1f66			;if DEBUG_FORTH_TOK 
1f66			;	ex de,hl		 
1f66			;endif 
1f66			 
1f66			;	pop hl 		; get back string pointer 
1f66			 
1f66			if DEBUG_FORTH_TOK 
1f66						DMARK "TOc" 
1f66				CALLMONITOR 
1f66			endif 
1f66 7e			.cptoken2:    ld a,(hl) 
1f67 23				inc hl 
1f68 fe 7f			cp FORTH_END_BUFFER 
1f6a 28 29			jr z, .cptokendone2 
1f6c fe 00			cp 0 
1f6e 28 25			jr z, .cptokendone2 
1f70 fe 22			cp '"' 
1f72 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f74 fe 20			cp ' ' 
1f76 20 ee			jr nz,  .cptoken2 
1f78			 
1f78			; TODO consume comments held between ( and ) 
1f78			 
1f78				; we have a space so change to zero term for dict match later 
1f78 2b				dec hl 
1f79 3e 00			ld a,0 
1f7b 77				ld (hl), a 
1f7c 23				inc hl 
1f7d 18 e7			jr .cptoken2 
1f7f				 
1f7f			 
1f7f			.cptokenstr2: 
1f7f				; skip all white space until either eol (because forgot to term) or end double quote 
1f7f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f7f				;inc hl ; skip current double quote 
1f7f 7e				ld a,(hl) 
1f80 23				inc hl 
1f81 fe 22			cp '"' 
1f83 28 e1			jr z, .cptoken2 
1f85 fe 7f			cp FORTH_END_BUFFER 
1f87 28 0c			jr z, .cptokendone2 
1f89 fe 00			cp 0 
1f8b 28 08			jr z, .cptokendone2 
1f8d fe 20			cp ' ' 
1f8f 28 02			jr z, .cptmp2 
1f91 18 ec			jr .cptokenstr2 
1f93			 
1f93			.cptmp2:	; we have a space so change to zero term for dict match later 
1f93				;dec hl 
1f93				;ld a,"-"	; TODO remove this when working 
1f93				;ld (hl), a 
1f93				;inc hl 
1f93 18 ea			jr .cptokenstr2 
1f95			 
1f95			.cptokendone2: 
1f95				;inc hl 
1f95 3e 7f			ld a, FORTH_END_BUFFER 
1f97 77				ld (hl),a 
1f98 23				inc hl 
1f99 3e 21			ld a, '!' 
1f9b 77				ld (hl),a 
1f9c			 
1f9c 2a 03 e6			ld hl,(os_tok_ptr) 
1f9f			         
1f9f			if DEBUG_FORTH_TOK 
1f9f						DMARK "Tc1" 
1f9f				CALLMONITOR 
1f9f			endif 
1f9f			 
1f9f				; push exec string to top of return stack 
1f9f				FORTH_RSP_NEXT 
1f9f cd 8e 1b			call macro_forth_rsp_next 
1fa2				endm 
# End of macro FORTH_RSP_NEXT
1fa2 c9				ret 
1fa3			 
1fa3			; Another go at the parser need to simplify the process 
1fa3			 
1fa3			forthparse: 
1fa3			 
1fa3			; 
1fa3			; line parse: 
1fa3			;       parse raw input buffer 
1fa3			;       tokenise the words 
1fa3			;       malloc new copy (for looping etc) 
1fa3			;       copy to malloc + current pc in line to start of string and add line term 
1fa3			;       save on new rsp 
1fa3			; 
1fa3			 
1fa3			; hl to point to the line to tokenise 
1fa3			 
1fa3			;	push hl 
1fa3 22 03 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1fa6			 
1fa6			;	ld a,0		; string term on input 
1fa6			;	call strlent 
1fa6			 
1fa6			;	ld (os_tok_len), hl	 ; save string length 
1fa6			 
1fa6			;if DEBUG_FORTH_TOK 
1fa6			;	ex de,hl		 
1fa6			;endif 
1fa6			 
1fa6			;	pop hl 		; get back string pointer 
1fa6			 
1fa6			if DEBUG_FORTH_TOK 
1fa6						DMARK "TOK" 
1fa6				CALLMONITOR 
1fa6			endif 
1fa6 7e			.ptoken2:    ld a,(hl) 
1fa7 23				inc hl 
1fa8 fe 7f			cp FORTH_END_BUFFER 
1faa 28 29			jr z, .ptokendone2 
1fac fe 00			cp 0 
1fae 28 25			jr z, .ptokendone2 
1fb0 fe 22			cp '"' 
1fb2 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fb4 fe 20			cp ' ' 
1fb6 20 ee			jr nz,  .ptoken2 
1fb8			 
1fb8			; TODO consume comments held between ( and ) 
1fb8			 
1fb8				; we have a space so change to zero term for dict match later 
1fb8 2b				dec hl 
1fb9 3e 00			ld a,0 
1fbb 77				ld (hl), a 
1fbc 23				inc hl 
1fbd 18 e7			jr .ptoken2 
1fbf				 
1fbf			 
1fbf			.ptokenstr2: 
1fbf				; skip all white space until either eol (because forgot to term) or end double quote 
1fbf			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fbf				;inc hl ; skip current double quote 
1fbf 7e				ld a,(hl) 
1fc0 23				inc hl 
1fc1 fe 22			cp '"' 
1fc3 28 e1			jr z, .ptoken2 
1fc5 fe 7f			cp FORTH_END_BUFFER 
1fc7 28 0c			jr z, .ptokendone2 
1fc9 fe 00			cp 0 
1fcb 28 08			jr z, .ptokendone2 
1fcd fe 20			cp ' ' 
1fcf 28 02			jr z, .ptmp2 
1fd1 18 ec			jr .ptokenstr2 
1fd3			 
1fd3			.ptmp2:	; we have a space so change to zero term for dict match later 
1fd3				;dec hl 
1fd3				;ld a,"-"	; TODO remove this when working 
1fd3				;ld (hl), a 
1fd3				;inc hl 
1fd3 18 ea			jr .ptokenstr2 
1fd5			 
1fd5			.ptokendone2: 
1fd5				;inc hl 
1fd5 3e 7f			ld a, FORTH_END_BUFFER 
1fd7 77				ld (hl),a 
1fd8 23				inc hl 
1fd9 3e 21			ld a, '!' 
1fdb 77				ld (hl),a 
1fdc			 
1fdc 2a 03 e6			ld hl,(os_tok_ptr) 
1fdf			         
1fdf			if DEBUG_FORTH_TOK 
1fdf						DMARK "TK1" 
1fdf				CALLMONITOR 
1fdf			endif 
1fdf			 
1fdf				; push exec string to top of return stack 
1fdf				FORTH_RSP_NEXT 
1fdf cd 8e 1b			call macro_forth_rsp_next 
1fe2				endm 
# End of macro FORTH_RSP_NEXT
1fe2 c9				ret 
1fe3			 
1fe3			; 
1fe3			;	; malloc size + buffer pointer + if is loop flag 
1fe3			;	ld hl,(os_tok_len) 		 ; get string length 
1fe3			; 
1fe3			;	ld a,l 
1fe3			; 
1fe3			;	cp 0			; we dont want to use a null string 
1fe3			;	ret z 
1fe3			; 
1fe3			;;	add 3    ; prefix malloc with buffer for current word ptr 
1fe3			; 
1fe3			;	add 5     ; TODO when certain not over writing memory remove 
1fe3			; 
1fe3			;		 
1fe3			; 
1fe3			;if DEBUG_FORTH_TOK 
1fe3			;			DMARK "TKE" 
1fe3			;	CALLMONITOR 
1fe3			;endif 
1fe3			; 
1fe3			;	ld l,a 
1fe3			;	ld h,0 
1fe3			;;	push hl   ; save required space for the copy later 
1fe3			;	call malloc 
1fe3			;if DEBUG_FORTH_TOK 
1fe3			;			DMARK "TKM" 
1fe3			;	CALLMONITOR 
1fe3			;endif 
1fe3			;	if DEBUG_FORTH_MALLOC_GUARD 
1fe3			;		push af 
1fe3			;		call ishlzero 
1fe3			;;		ld a, l 
1fe3			;;		add h 
1fe3			;;		cp 0 
1fe3			;		pop af 
1fe3			;		 
1fe3			;		call z,malloc_error 
1fe3			;	endif 
1fe3			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1fe3			; 
1fe3			; 
1fe3			;if DEBUG_FORTH_TOK 
1fe3			;			DMARK "TKR" 
1fe3			;	CALLMONITOR 
1fe3			;endif 
1fe3			; 
1fe3			;	FORTH_RSP_NEXT 
1fe3			; 
1fe3			;	;inc hl	 ; go past current buffer pointer 
1fe3			;	;inc hl 
1fe3			;	;inc hl   ; and past if loop flag 
1fe3			;		; TODO Need to set flag  
1fe3			; 
1fe3			;	 
1fe3			;	 
1fe3			;	ex de,hl	; malloc is dest 
1fe3			;	ld hl, (os_tok_len) 
1fe3			;;	pop bc 
1fe3			;	ld c, l                
1fe3			;	ld b,0 
1fe3			;	ld hl, (os_tok_ptr) 
1fe3			; 
1fe3			;if DEBUG_FORTH_TOK 
1fe3			;			DMARK "TKT" 
1fe3			;	CALLMONITOR 
1fe3			;endif 
1fe3			; 
1fe3			;	; do str cpy 
1fe3			; 
1fe3			;	ldir      ; copy byte in hl to de 
1fe3			; 
1fe3			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1fe3			; 
1fe3			;if DEBUG_FORTH_TOK 
1fe3			; 
1fe3			;			DMARK "TKY" 
1fe3			;	CALLMONITOR 
1fe3			;endif 
1fe3			;	;ld a,0 
1fe3			;	;ld a,FORTH_END_BUFFER 
1fe3			;	ex de, hl 
1fe3			;	;dec hl			 ; go back over the space delim at the end of word 
1fe3			;	;ld (hl),a 
1fe3			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1fe3			;	ld a,FORTH_END_BUFFER 
1fe3			;	ld (hl),a 
1fe3			;	inc hl 
1fe3			;	ld a,FORTH_END_BUFFER 
1fe3			;	ld (hl),a 
1fe3			; 
1fe3			;	; init the malloc area data 
1fe3			;	; set pc for in current area 
1fe3			;	;ld hl, (os_tok_malloc) 
1fe3			;	;inc hl 
1fe3			;	;inc hl 
1fe3			;	;inc hl 
1fe3			;	;ex de,hl 
1fe3			;	;ld hl, (os_tok_malloc) 
1fe3			;	;ld (hl),e 
1fe3			;	;inc hl 
1fe3			;	;ld (hl),d 
1fe3			; 
1fe3			; 
1fe3			;	ld hl,(os_tok_malloc) 
1fe3			;if DEBUG_FORTH_PARSE_KEY 
1fe3			;			DMARK "TKU" 
1fe3			;	CALLMONITOR 
1fe3			;endif 
1fe3			; 
1fe3			;	ret 
1fe3			 
1fe3			forthexec: 
1fe3			 
1fe3			; line exec: 
1fe3			; forth parser 
1fe3			 
1fe3			; 
1fe3			;       get current exec line on rsp 
1fe3			 
1fe3				FORTH_RSP_TOS 
1fe3 cd a5 1b			call macro_forth_rsp_tos 
1fe6				endm 
# End of macro FORTH_RSP_TOS
1fe6			 
1fe6			;       restore current pc - hl points to malloc of data 
1fe6			 
1fe6				;ld e, (hl) 
1fe6				;inc hl 
1fe6				;ld d, (hl) 
1fe6				;ex de,hl 
1fe6			 
1fe6			 
1fe6			exec1: 
1fe6 22 03 e6			ld (os_tok_ptr), hl 
1fe9			 
1fe9				; copy our PC to working vars  
1fe9 22 4d ea			ld (cli_ptr), hl 
1fec 22 4b ea			ld (cli_origptr), hl 
1fef			 
1fef 7e				ld a,(hl) 
1ff0 fe 7f			cp FORTH_END_BUFFER 
1ff2 c8				ret z 
1ff3			 
1ff3				; skip any nulls 
1ff3			 
1ff3 fe 00			cp 0 
1ff5 20 03			jr nz, .execword 
1ff7 23				inc hl 
1ff8 18 ec			jr exec1 
1ffa			 
1ffa			 
1ffa			.execword: 
1ffa			 
1ffa			 
1ffa			 
1ffa			if DEBUG_FORTH_PARSE_KEY 
1ffa						DMARK "KYQ" 
1ffa				CALLMONITOR 
1ffa			endif 
1ffa			;       while at start of word: 
1ffa			; get start of dict (in user area first) 
1ffa			 
1ffa 21 b6 5b		ld hl, baseram 
1ffd			;ld hl, sysdict 
1ffd 22 4f ea		ld (cli_nextword),hl 
2000			;           match word at pc 
2000			;           exec word 
2000			;           or push to dsp 
2000			;           forward to next token 
2000			;           if line term pop rsp and exit 
2000			;        
2000			 
2000			if DEBUG_FORTH_PARSE_KEY 
2000						DMARK "KYq" 
2000				CALLMONITOR 
2000			endif 
2000			 
2000			; 
2000			; word comp 
2000			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2000			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2000			;    move to start of word  
2000			;    compare word to cli_token 
2000			 
2000			.execpnword:	; HL at start of a word in the dictionary to check 
2000			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2000			;	ld (cli_ptr), hl 
2000			 
2000 2a 4f ea			ld hl,(cli_nextword) 
2003			 
2003 cd a6 20			call forth_tok_next 
2006			; tok next start here 
2006			;	; TODO skip compiled symbol for now 
2006			;	inc hl 
2006			; 
2006			;	; save pointer to next word 
2006			; 
2006			;	; hl now points to the address of the next word pointer  
2006			;	ld e, (hl) 
2006			;	inc hl 
2006			;	ld d, (hl) 
2006			;	inc l 
2006			; 
2006			;	ex de,hl 
2006			;if DEBUG_FORTH_PARSE_NEXTWORD 
2006			;	push bc 
2006			;	ld bc, (cli_nextword) 
2006			;			DMARK "NXW" 
2006			;	CALLMONITOR 
2006			;	pop bc 
2006			;endif 
2006			; tok next end here 
2006 22 4f ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
2009 eb				ex de, hl 
200a			 
200a			 
200a				; save the pointer of the current token - 1 to check against 
200a				 
200a 22 53 ea			ld (cli_token), hl   
200d				; TODO maybe remove below save if no debug 
200d				; save token string ptr for any debug later 
200d 23				inc hl  
200e 22 55 ea			ld (cli_origtoken), hl 
2011 2b				dec hl 
2012				; save pointer to the start of the next dictionay word 
2012 7e				ld a,(hl)   ; get string length 
2013 47				ld b,a 
2014			.execpnwordinc:  
2014 23				inc hl 
2015 10 fd			djnz .execpnwordinc 
2017 22 51 ea			ld (cli_execword), hl      ; save start of this words code 
201a			 
201a				; now check the word token against the string being parsed 
201a			 
201a 2a 53 ea			ld hl,(cli_token) 
201d 23				inc hl     ; skip string length (use zero term instead to end) 
201e 22 53 ea			ld (cli_token), hl 
2021			 
2021			if DEBUG_FORTH_PARSE_KEY 
2021						DMARK "KY2" 
2021			endif 
2021			if DEBUG_FORTH_PARSE_EXEC 
2021				; see if disabled 
2021			 
2021				ld a, (os_view_disable) 
2021				cp '*' 
2021				jr z, .skip 
2021			 
2021				push hl 
2021				push hl 
2021				call clear_display 
2021				ld de, .compword 
2021				ld a, display_row_1 
2021				call str_at_display 
2021				pop de 
2021				ld a, display_row_2 
2021				call str_at_display 
2021				ld hl,(cli_ptr) 
2021				ld a,(hl) 
2021			        ld hl, os_word_scratch 
2021				ld (hl),a 
2021				ld a,0 
2021				inc hl 
2021				ld (hl),a 	 
2021				ld de, os_word_scratch 
2021				ld a, display_row_2+10 
2021				call str_at_display 
2021				call update_display 
2021				ld a, 100 
2021				call aDelayInMS 
2021				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2021				call delay250ms 
2021				endif 
2021				pop hl 
2021			.skip:  
2021			endif	 
2021			.execpnchar:    ; compare char between token and string to parse 
2021			 
2021			if DEBUG_FORTH_PARSE_KEY 
2021						DMARK "Ky3" 
2021			endif 
2021			if DEBUG_FORTH_PARSE_EXEC 
2021				; see if disabled 
2021			 
2021				ld a, (os_view_disable) 
2021				cp '*' 
2021				jr z, .skip2 
2021			 
2021			;	call clear_display 
2021			ld hl,(cli_token) 
2021			ld a,(hl) 
2021			ld (os_word_scratch),a 
2021				ld hl,(cli_ptr) 
2021			ld a,(hl) 
2021				ld (os_word_scratch+1),a 
2021				ld a,0 
2021				ld (os_word_scratch+2),a 
2021				ld de,os_word_scratch 
2021				ld a,display_row_4 
2021				call str_at_display 
2021				call update_display 
2021			.skip2:  
2021			endif 
2021 2a 53 ea			ld hl,(cli_token) 
2024 7e				ld a, (hl)	 ; char in word token 
2025 23				inc hl 		; move to next char 
2026 22 53 ea			ld (cli_token), hl ; and save it 
2029 47				ld b,a 
202a			 
202a 2a 4d ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
202d 7e				ld a,(hl) 
202e 23				inc hl 
202f 22 4d ea			ld (cli_ptr), hl		; move to next char 
2032 cd ca 11			call toUpper 		; make sure the input string matches case 
2035			 
2035			if DEBUG_FORTH_PARSE 
2035			endif 
2035			 
2035				; input stream end of token is a space so get rid of it 
2035			 
2035			;	cp ' ' 
2035			;	jr nz, .pnskipspace 
2035			; 
2035			;	ld a, 0		; make same term as word token term 
2035			; 
2035			;.pnskipspace: 
2035			 
2035			if DEBUG_FORTH_PARSE_KEY 
2035						DMARK "KY7" 
2035			endif 
2035 b8				cp b 
2036 c2 4c 20			jp nz, .execpnskipword	 ; no match so move to next word 
2039				 
2039			;    if same 
2039			;       scan for string terms 0 for token and 32 for input 
2039			 
2039				 
2039			if DEBUG_FORTH_PARSE_KEY 
2039						DMARK "KY8" 
2039			endif 
2039			 
2039 80				add b			 
203a fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
203c							; TODO need to make sure last word in zero term string is accounted for 
203c 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
203e			 
203e			 
203e				; at end of both strings so both are exact match 
203e			 
203e			;       skip ptr for next word 
203e			 
203e 2a 4d ea			ld hl,(cli_ptr) 	; at input string term 
2041 23				inc hl			 ; at next char 
2042 22 4d ea			ld (cli_ptr), hl     ; save for next round of the parser 
2045 22 4b ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2048				 
2048				 
2048			if DEBUG_FORTH_PARSE_KEY 
2048						DMARK "KY3" 
2048			endif 
2048			 
2048			 
2048			 
2048			;       exec code block 
2048			if DEBUG_FORTH_JP 
2048				call clear_display 
2048				call update_display 
2048				call delay1s 
2048				ld hl, (cli_execword)     ; save for next check if no match on this word 
2048				ld a,h 
2048				ld hl, os_word_scratch 
2048				call hexout 
2048				ld hl, (cli_execword)     ; save for next check if no match on this word 
2048				ld a,l 
2048				ld hl, os_word_scratch+2 
2048				call hexout 
2048				ld hl, os_word_scratch+4 
2048				ld a,0 
2048				ld (hl),a 
2048				ld de,os_word_scratch 
2048				call str_at_display 
2048					ld a, display_row_2 
2048					call str_at_display 
2048				ld de, (cli_origtoken) 
2048				ld a, display_row_1+10 
2048					call str_at_display 
2048			 
2048				ld a,display_row_1 
2048				ld de, .foundword 
2048				ld a, display_row_3 
2048				call str_at_display 
2048				call update_display 
2048				call delay1s 
2048				call delay1s 
2048				call delay1s 
2048			endif 
2048			 
2048			if DEBUG_FORTH_PARSE_KEY 
2048						DMARK "KYj" 
2048			endif 
2048				; TODO save the word pointer in this exec 
2048			 
2048 2a 51 ea			ld hl,(cli_execword) 
204b e9				jp (hl) 
204c			 
204c			 
204c			;    if not same 
204c			;	scan for zero term 
204c			;	get ptr for next word 
204c			;	goto word comp 
204c			 
204c			.execpnskipword:	; get pointer to next word 
204c 2a 4f ea			ld hl,(cli_nextword) 
204f			 
204f 7e				ld a,(hl) 
2050 fe 00			cp WORD_SYS_END 
2052			;	cp 0 
2052 28 09			jr z, .execendofdict			 ; at end of words 
2054			 
2054			if DEBUG_FORTH_PARSE_KEY 
2054						DMARK "KY4" 
2054			endif 
2054			if DEBUG_FORTH_PARSE_EXEC 
2054			 
2054				; see if disabled 
2054			 
2054				ld a, (os_view_disable) 
2054				cp '*' 
2054				jr z, .noskip 
2054			 
2054			 
2054				ld de, .nowordfound 
2054				ld a, display_row_3 
2054				call str_at_display 
2054				call update_display 
2054				ld a, 100 
2054				call aDelayInMS 
2054				 
2054				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2054					call delay250ms 
2054				endif 
2054			.noskip:  
2054			 
2054			endif	 
2054			 
2054 2a 4b ea			ld hl,(cli_origptr) 
2057 22 4d ea			ld (cli_ptr),hl 
205a			 
205a			if DEBUG_FORTH_PARSE_KEY 
205a						DMARK "KY5" 
205a			endif 
205a c3 00 20			jp .execpnword			; else go to next word 
205d			 
205d			.execendofdict:  
205d			 
205d			if DEBUG_FORTH_PARSE_KEY 
205d						DMARK "KYe" 
205d			endif 
205d			if DEBUG_FORTH_PARSE_EXEC 
205d				; see if disabled 
205d			 
205d				ld a, (os_view_disable) 
205d				cp '*' 
205d				jr z, .ispskip 
205d			 
205d				call clear_display 
205d				call update_display 
205d				call delay1s 
205d				ld de, (cli_origptr) 
205d				ld a, display_row_1 
205d				call str_at_display 
205d				 
205d				ld de, .enddict 
205d				ld a, display_row_3 
205d				call str_at_display 
205d				call update_display 
205d				ld a, 100 
205d				call aDelayInMS 
205d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
205d				call delay1s 
205d				call delay1s 
205d				call delay1s 
205d				endif 
205d			.ispskip:  
205d				 
205d			endif	 
205d			 
205d			 
205d			 
205d				; if the word is not a keyword then must be a literal so push it to stack 
205d			 
205d			; push token to stack to end of word 
205d			 
205d				STACKFRAME ON $1efe $2f9f 
205d				if DEBUG_STACK_IMB 
205d					if ON 
205d						exx 
205d						ld de, $1efe 
205d						ld a, d 
205d						ld hl, curframe 
205d						call hexout 
205d						ld a, e 
205d						ld hl, curframe+2 
205d						call hexout 
205d						ld hl, $1efe 
205d						push hl 
205d						ld hl, $2f9f 
205d						push hl 
205d						exx 
205d					endif 
205d				endif 
205d			endm 
# End of macro STACKFRAME
205d			 
205d 2a 03 e6		ld hl,(os_tok_ptr) 
2060 cd 50 1d		call forth_apush 
2063			 
2063				STACKFRAMECHK ON $1efe $2f9f 
2063				if DEBUG_STACK_IMB 
2063					if ON 
2063						exx 
2063						ld hl, $2f9f 
2063						pop de   ; $2f9f 
2063						call cmp16 
2063						jr nz, .spnosame 
2063						ld hl, $1efe 
2063						pop de   ; $1efe 
2063						call cmp16 
2063						jr z, .spfrsame 
2063						.spnosame: call showsperror 
2063						.spfrsame: nop 
2063						exx 
2063					endif 
2063				endif 
2063			endm 
# End of macro STACKFRAMECHK
2063			 
2063			execnext: 
2063			 
2063			if DEBUG_FORTH_PARSE_KEY 
2063						DMARK "KY>" 
2063			endif 
2063			; move past token to next word 
2063			 
2063 2a 03 e6		ld hl, (os_tok_ptr) 
2066 3e 00		ld a, 0 
2068 01 ff 00		ld bc, 255     ; input buffer size 
206b ed b1		cpir 
206d			 
206d			if DEBUG_FORTH_PARSE_KEY 
206d						DMARK "KY!" 
206d				CALLMONITOR 
206d			endif	 
206d			; TODO this might place hl on the null, so will need to forward on??? 
206d			;inc hl   ; see if this gets onto the next item 
206d			 
206d			 
206d			; TODO pass a pointer to the buffer to push 
206d			; TODO call function to push 
206d			 
206d			; look for end of input 
206d			 
206d			;inc hl 
206d			;ld a,(hl) 
206d			;cp FORTH_END_BUFFER 
206d			;ret z 
206d			 
206d			 
206d c3 e6 1f		jp exec1 
2070			 
2070			 
2070			 
2070			 
2070			 
2070			 
2070			 
2070			 
2070			 
2070			findnexttok: 
2070			 
2070				; hl is pointer to move 
2070				; de is the token to locate 
2070			 
2070					if DEBUG_FORTH 
2070						DMARK "NTK" 
2070						CALLMONITOR 
2070					endif 
2070 d5				push de 
2071			 
2071			.fnt1:	 
2071				; find first char of token to locate 
2071			 
2071 1a				ld a, (de) 
2072 4f				ld c,a 
2073 7e				ld a,(hl) 
2074 cd ca 11			call toUpper 
2077					if DEBUG_FORTH 
2077						DMARK "NT1" 
2077						CALLMONITOR 
2077					endif 
2077 b9				cp c 
2078			 
2078 28 03			jr z, .fnt2cmpmorefirst	 
207a			 
207a				; first char not found move to next char 
207a			 
207a 23				inc hl 
207b 18 f4			jr .fnt1 
207d			 
207d			.fnt2cmpmorefirst:	 
207d				; first char of token found.  
207d			 
207d e5				push hl     ; save start of token just in case it is the right one 
207e d9				exx 
207f e1				pop hl        ; save it to hl' 
2080 d9				exx 
2081			 
2081			 
2081			.fnt2cmpmore:	 
2081				; compare the rest 
2081				 
2081 23				inc hl 
2082 13				inc de 
2083				 
2083 1a				ld a, (de) 
2084 4f				ld c,a 
2085 7e				ld a,(hl) 
2086 cd ca 11			call toUpper 
2089			 
2089					if DEBUG_FORTH 
2089						DMARK "NT2" 
2089						CALLMONITOR 
2089					endif 
2089				; c has the token to find char 
2089				; a has the mem to scan char 
2089			 
2089 b9				cp c 
208a 28 04			jr z,.fntmatch1 
208c			 
208c				; they are not the same 
208c			 
208c					if DEBUG_FORTH 
208c						DMARK "NT3" 
208c						CALLMONITOR 
208c					endif 
208c d1				pop de	; reset de token to look for 
208d d5				push de 
208e 18 e1			jr .fnt1 
2090				 
2090			.fntmatch1: 
2090			 
2090				; is the same char a null which means we might have a full hit? 
2090					if DEBUG_FORTH 
2090						DMARK "NT4" 
2090						CALLMONITOR 
2090					endif 
2090			 
2090 fe 00			cp 0 
2092 28 0b			jr z, .fntmatchyes 
2094			 
2094				; are we at the end of the token to find? 
2094			 
2094					if DEBUG_FORTH 
2094						DMARK "NT5" 
2094						CALLMONITOR 
2094					endif 
2094 3e 00			ld a, 0 
2096 b9				cp c 
2097			 
2097 c2 81 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
209a			 
209a					if DEBUG_FORTH 
209a						DMARK "NT6" 
209a						CALLMONITOR 
209a					endif 
209a				; token to find is exhusted but no match to stream 
209a			 
209a				; restore tok pointer and continue on 
209a d1				pop de 
209b d5				push de 
209c c3 71 20			jp .fnt1 
209f			 
209f			 
209f			.fntmatchyes: 
209f			 
209f				; hl now contains the end of the found token 
209f			 
209f				; get rid of saved token pointer to find 
209f			 
209f d1				pop de 
20a0			 
20a0					if DEBUG_FORTH 
20a0						DMARK "NT9" 
20a0						CALLMONITOR 
20a0					endif 
20a0			 
20a0				; hl will be on the null term so forward on 
20a0			 
20a0				; get back the saved start of the token 
20a0			 
20a0 d9				exx 
20a1 e5				push hl     ; save start of token just in case it is the right one 
20a2 d9				exx 
20a3 e1				pop hl        ; save it to hl 
20a4			 
20a4 c9				ret 
20a5			 
20a5			 
20a5			; LIST needs to find a specific token   
20a5			; FORGET needs to find a spefici token 
20a5			 
20a5			; SAVE needs to find all tokens by flag 
20a5			; WORDS just needs to scan through all  by flag 
20a5			; UWORDS needs to scan through all by flag 
20a5			 
20a5			 
20a5			; given hl as pointer to start of dict look up string 
20a5			; return hl as pointer to start of word block 
20a5			; or 0 if not found 
20a5			 
20a5			forth_find_tok: 
20a5 c9				ret 
20a6			 
20a6			; given hl as pointer to dict structure 
20a6			; move to the next dict block structure 
20a6			 
20a6			forth_tok_next: 
20a6				; hl now points to the address of the next word pointer  
20a6				; TODO skip compiled symbol for now 
20a6			;	push de 
20a6 23				inc hl 
20a7 5e				ld e, (hl) 
20a8 23				inc hl 
20a9 56				ld d, (hl) 
20aa 23				inc hl 
20ab			 
20ab eb				ex de,hl 
20ac			if DEBUG_FORTH_PARSE_NEXTWORD 
20ac				push bc 
20ac				ld bc, (cli_nextword) 
20ac						DMARK "NXW" 
20ac				CALLMONITOR 
20ac				pop bc 
20ac			endif 
20ac			;	pop de	 
20ac c9				ret 
20ad			 
20ad			 
20ad			 
20ad			; eof 
# End of file forth_parserv5.asm
20ad				include "forth_wordsv4.asm" 
20ad			 
20ad			; the core word dictionary v4 
20ad			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20ad			 
20ad			; this is a linked list for each of the system words used 
20ad			; user defined words will follow the same format but will be in ram 
20ad			 
20ad			 
20ad			; 
20ad			; 
20ad			; define linked list: 
20ad			; 
20ad			; 1. compiled byte op code 
20ad			; 2. len of text word 
20ad			; 3. text word 
20ad			; 4. ptr to next dictionary word 
20ad			; 5. asm, calls etc for the word 
20ad			; 
20ad			;  if 1 == 0 then last word in dict  
20ad			;   
20ad			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20ad			;  
20ad			;  
20ad			; create basic standard set of words 
20ad			; 
20ad			;  
20ad			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20ad			; 2DUP 2DROP 2SWAP  
20ad			; @ C@ - get byte  
20ad			; ! C! - store byte 
20ad			; 0< true if less than zero 
20ad			; 0= true if zero 
20ad			; < >  
20ad			; = true if same 
20ad			; variables 
20ad			 
20ad			 
20ad			; Hardware specific words I may need 
20ad			; 
20ad			; IN OUT  
20ad			; calls to key util functions 
20ad			; calls to hardward abstraction stuff 
20ad			; easy control of frame buffers and lcd i/o 
20ad			; keyboard  
20ad			 
20ad			 
20ad			;DICT: macro 
20ad			; op_code, len, word, next 
20ad			;    word: 
20ad			;    db op_code 
20ad			;    ds word zero term 
20ad			;    dw next 
20ad			;    endm 
20ad			 
20ad			 
20ad			 
20ad			 
20ad			; op code 1 is a flag for user define words which are to be handled differently 
20ad			 
20ad			 
20ad			; 
20ad			; 
20ad			;    TODO on entry to a word this should be the expected environment 
20ad			;    hl - tos value if number then held, if string this is the ptr 
20ad			;    de -  
20ad			 
20ad			 
20ad			; opcode ranges 
20ad			; 0 - end of word dict 
20ad			; 255 - user define words 
20ad			 
20ad			sysdict: 
20ad			include "forth_opcodes.asm" 
20ad			; op codes for forth keywords 
20ad			; free to use code 0  
20ad				OPCODE_HEAP: equ  1 
20ad				OPCODE_EXEC: equ 2 
20ad				OPCODE_DUP: equ 3 
20ad				OPCODE_SWAP: equ 4 
20ad				OPCODE_COLN: equ 5 
20ad				OPCODE_SCOLN: equ 6 
20ad				OPCODE_DROP: equ 7 
20ad				OPCODE_DUP2: equ 8 
20ad				OPCODE_DROP2: equ 9 
20ad				OPCODE_SWAP2: equ 10 
20ad				OPCODE_AT: equ 11 
20ad				OPCODE_CAT: equ 12 
20ad				OPCODE_BANG: equ 13 
20ad				OPCODE_CBANG: equ 14 
20ad				OPCODE_SCALL: equ 15 
20ad				OPCODE_DEPTH: equ 16 
20ad				OPCODE_OVER: equ 17 
20ad				OPCODE_PAUSE: equ 18 
20ad				OPCODE_PAUSES: equ 19 
20ad				OPCODE_ROT: equ 20 
20ad			;free to reuse	OPCODE_WORDS: equ 21 
20ad			        OPCODE_NOT: equ 21 
20ad				OPCODE_UWORDS: equ 22 
20ad				OPCODE_BP: equ 23 
20ad				OPCODE_MONITOR: equ 24  
20ad				OPCODE_MALLOC: equ 25 
20ad				OPCODE_FREE: equ 26 
20ad				OPCODE_LIST: equ 27 
20ad				OPCODE_FORGET: equ 28 
20ad				OPCODE_NOP: equ 29 
20ad				OPCODE_COMO: equ 30 
20ad				OPCODE_COMC: equ 31 
20ad			;free to reuse	OPCODE_ENDCORE: equ 32 
20ad				OPCODE_AFTERSOUND: equ 33 
20ad				OPCODE_GP2: equ 34 
20ad				OPCODE_GP3: equ 35 
20ad				OPCODE_GP4: equ 36 
20ad				OPCODE_SIN: equ 37 
20ad				OPCODE_SOUT: equ 38 
20ad				OPCODE_SPIO: equ 39 
20ad				OPCODE_SPICEH: equ 40 
20ad				OPCODE_SPIOb: equ 41 
20ad				OPCODE_SPII: equ 42 
20ad				OPCODE_SESEL: equ 43 
20ad				OPCODE_CARTDEV: equ 44 
20ad			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20ad				OPCODE_FB: equ 46 
20ad				OPCODE_EMIT: equ 47 
20ad				OPCODE_DOTH: equ 48 
20ad				OPCODE_DOTF: equ 49 
20ad				OPCODE_DOT: equ 50 
20ad				OPCODE_CLS: equ 51 
20ad				OPCODE_DRAW: equ 52 
20ad				OPCODE_DUMP: equ 53 
20ad				OPCODE_CDUMP: equ 54 
20ad				OPCODE_DAT: equ 55 
20ad				OPCODE_HOME: equ 56 
20ad				OPCODE_SPACE: equ 57 
20ad				OPCODE_SPACES: equ 58 
20ad				OPCODE_SCROLL: equ 59 
20ad				OPCODE_ATQ: equ 60 
20ad				OPCODE_AUTODSP: equ 61 
20ad				OPCODE_MENU: equ 62 
20ad			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20ad				OPCODE_THEN: equ 64 
20ad				OPCODE_ELSE: equ 65 
20ad				OPCODE_DO: equ 66 
20ad				OPCODE_LOOP: equ 67 
20ad				OPCODE_I: equ 68 
20ad				OPCODE_DLOOP: equ 69  
20ad				OPCODE_REPEAT: equ 70  
20ad				OPCODE_UNTIL: equ 71 
20ad				OPCODE_ENDFLOW: equ 72 
20ad				OPCODE_WAITK: equ 73 
20ad				OPCODE_ACCEPT: equ 74 
20ad				OPCODE_EDIT: equ 75 
20ad			;free to reuse	OPCODE_ENDKEY: equ 76 
20ad				OPCODE_LZERO: equ 77 
20ad				OPCODE_TZERO: equ 78 
20ad				OPCODE_LESS: equ 79 
20ad				OPCODE_GT: equ 80 
20ad				OPCODE_EQUAL: equ 81  
20ad			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20ad				OPCODE_NEG: equ 83 
20ad				OPCODE_DIV: equ 84 
20ad				OPCODE_MUL: equ 85 
20ad				OPCODE_MIN: equ 86 
20ad				OPCODE_MAX: equ 87 
20ad				OPCODE_RND16: equ 88 
20ad				OPCODE_RND8: equ 89 
20ad				OPCODE_RND: equ 90 
20ad			;free to reuse	OPCODE_ENDMATHS: equ 91  
20ad				OPCODE_BYNAME: equ 92 
20ad				OPCODE_DIR: equ 93 
20ad				OPCODE_SAVE: equ 94 
20ad				OPCODE_LOAD: equ 95 
20ad				OPCODE_BSAVE: equ 96 
20ad				OPCODE_BLOAD: equ 97 
20ad				OPCODE_SEO: equ 98  
20ad				OPCODE_SEI: equ 99 
20ad				OPCODE_SFREE: equ 100 
20ad				OPCODE_SIZE: equ 101 
20ad				OPCODE_CREATE: equ 102 
20ad				OPCODE_APPEND: equ 103 
20ad				OPCODE_SDEL: equ 104 
20ad				OPCODE_OPEN: equ 105 
20ad				OPCODE_READ: equ 106 
20ad				OPCODE_EOF: equ 106 
20ad				OPCODE_FORMAT: equ 107 
20ad				OPCODE_LABEL: equ 108 
20ad				OPCODE_LABELS: equ 109 
20ad			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20ad				OPCODE_UPPER: equ 111 
20ad				OPCODE_LOWER: equ 112 
20ad				OPCODE_SUBSTR: equ 113 
20ad				OPCODE_LEFT: equ 114 
20ad				OPCODE_RIGHT: equ 115 
20ad				OPCODE_STR2NUM: equ 116 
20ad				OPCODE_NUM2STR: equ 117 
20ad				OPCODE_CONCAT: equ 118 
20ad				OPCODE_FIND: equ 119 
20ad				OPCODE_LEN: equ 120 
20ad				OPCODE_CHAR: equ 121 
20ad			; free to reuse	OPCODE_STRLEN: equ 122 
20ad			; free to reuse	OPCODE_ENDSTR: equ 123 
20ad				OPCODE_V0S: equ 124 
20ad				OPCODE_V0Q: equ 125 
20ad				OPCODE_V1S: equ 126 
20ad				OPCODE_V1Q: equ 127 
20ad				OPCODE_V2S: equ 128 
20ad				OPCODE_V2Q: equ 129 
20ad				OPCODE_V3S: equ 130 
20ad				OPCODE_V3Q: equ 131 
20ad			;free to reuse	OPCODE_END: equ 132 
20ad				OPCODE_ZDUP: equ 133 
20ad			 
20ad			; eof 
# End of file forth_opcodes.asm
20ad			 
20ad			include "forth_words_core.asm" 
20ad			 
20ad			; | ## Core Words 
20ad			 
20ad			;if MALLOC_4 
20ad			 
20ad			.HEAP: 
20ad				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20ad 15				db WORD_SYS_CORE+OPCODE_HEAP             
20ae ec 20			dw .EXEC            
20b0 05				db 4 + 1 
20b1 .. 00			db "HEAP",0              
20b6				endm 
# End of macro CWHEAD
20b6			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20b6			; | | u1 - Current number of bytes in the heap 
20b6			; | | u2 - Remaining bytes left on the heap 
20b6			; | |  
20b6			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20b6			 
20b6			 
20b6					if DEBUG_FORTH_WORDS_KEY 
20b6						DMARK "HEP" 
20b6 f5				push af  
20b7 3a cb 20			ld a, (.dmark)  
20ba 32 71 ee			ld (debug_mark),a  
20bd 3a cc 20			ld a, (.dmark+1)  
20c0 32 72 ee			ld (debug_mark+1),a  
20c3 3a cd 20			ld a, (.dmark+2)  
20c6 32 73 ee			ld (debug_mark+2),a  
20c9 18 03			jr .pastdmark  
20cb ..			.dmark: db "HEP"  
20ce f1			.pastdmark: pop af  
20cf			endm  
# End of macro DMARK
20cf						CALLMONITOR 
20cf cd 76 15			call break_point_state  
20d2				endm  
# End of macro CALLMONITOR
20d2					endif 
20d2 2a c0 5b				ld hl, (free_list )      
20d5 11 c5 5b				ld de, heap_start 
20d8			 
20d8 ed 52				sbc hl, de  
20da			 
20da cd e7 1b				call forth_push_numhl 
20dd			 
20dd			 
20dd ed 5b c0 5b			ld de, (free_list )      
20e1 21 e8 e2				ld hl, heap_end 
20e4			 
20e4 ed 52				sbc hl, de 
20e6			 
20e6 cd e7 1b				call forth_push_numhl 
20e9					 
20e9			 
20e9					 
20e9			 
20e9			 
20e9			 
20e9					NEXTW 
20e9 c3 55 1f			jp macro_next 
20ec				endm 
# End of macro NEXTW
20ec			;endif 
20ec			 
20ec			.EXEC: 
20ec			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20ec			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
20ec			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
20ec			;; > > 
20ec			;; > >   
20ec			;	STACKFRAME OFF $5efe $5f9f 
20ec			; 
20ec			;		if DEBUG_FORTH_WORDS_KEY 
20ec			;			DMARK "EXE" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			; 
20ec			;	FORTH_DSP_VALUEHL 
20ec			; 
20ec			;	FORTH_DSP_POP 
20ec			; 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EX1" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			;;	ld e,(hl) 
20ec			;;	inc hl 
20ec			;;	ld d,(hl) 
20ec			;;	ex de,hl 
20ec			; 
20ec			;;		if DEBUG_FORTH_WORDS 
20ec			;;			DMARK "EX2" 
20ec			;;			CALLMONITOR 
20ec			;;		endif 
20ec			;	push hl 
20ec			; 
20ec			;	;ld a, 0 
20ec			;	;ld a, FORTH_END_BUFFER 
20ec			;	call strlenz 
20ec			;	inc hl   ; include zero term to copy 
20ec			;	inc hl   ; include term 
20ec			;	inc hl   ; include term 
20ec			;	ld b,0 
20ec			;	ld c,l 
20ec			;	pop hl 
20ec			;	ld de, execscratch 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EX3" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			;	ldir 
20ec			; 
20ec			; 
20ec			;	ld hl, execscratch 
20ec			; 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EXe" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			; 
20ec			;	call forthparse 
20ec			;	call forthexec 
20ec			;;	call forthexec_cleanup 
20ec			;;	call forthparse 
20ec			;;	call forthexec 
20ec			; 
20ec			;	STACKFRAMECHK OFF $5efe $5f9f 
20ec			; 
20ec			;	; an immediate word so no need to process any more words 
20ec			;	ret 
20ec			;	NEXTW 
20ec			 
20ec			; dead code - old version  
20ec			;	FORTH_RSP_NEXT 
20ec			 
20ec			;  
20ec			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
20ec			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
20ec			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
20ec			;	push hl 
20ec			;	push de 
20ec			;	push bc 
20ec			; 
20ec			; 
20ec			;		if DEBUG_FORTH_WORDS_KEY 
20ec			;			DMARK "EXR" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			; 
20ec			; 
20ec			; 
20ec			;	;v5 FORTH_DSP_VALUE 
20ec			;	FORTH_DSP_VALUEHL 
20ec			; 
20ec			;	; TODO do string type checks 
20ec			; 
20ec			;;v5	inc hl   ; skip type 
20ec			; 
20ec			;	push hl  ; source code  
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EX1" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			;	ld a, 0 
20ec			;	call strlent 
20ec			; 
20ec			;	inc hl 
20ec			;	inc hl 
20ec			;	inc hl 
20ec			;	inc hl 
20ec			; 
20ec			;	push hl    ; size 
20ec			; 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EX2" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			;	call malloc 
20ec			; 
20ec			;	ex de, hl    ; de now contains malloc area 
20ec			;	pop bc   	; get byte count 
20ec			;	pop hl      ; get string to copy 
20ec			; 
20ec			;	push de     ; save malloc for free later 
20ec			; 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EX3" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			;	ldir       ; duplicate string 
20ec			; 
20ec			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
20ec			;	 
20ec			;	; TODO fix the parse would be better than this...  
20ec			;	ex de, hl 
20ec			;	dec hl 
20ec			;	ld a, 0 
20ec			;	ld (hl), a 
20ec			;	dec hl 
20ec			;	ld a, ' ' 
20ec			;	ld (hl), a 
20ec			;	dec hl 
20ec			;	ld (hl), a 
20ec			; 
20ec			;	dec hl 
20ec			;	ld (hl), a 
20ec			; 
20ec			; 
20ec			;	FORTH_DSP_POP  
20ec			; 
20ec			;	pop hl     
20ec			;	push hl    ; save malloc area 
20ec			; 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EX4" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			; 
20ec			;	call forthparse 
20ec			;	call forthexec 
20ec			;	 
20ec			;	pop hl 
20ec			;	if DEBUG_FORTH_WORDS 
20ec			;		DMARK "EX5" 
20ec			;		CALLMONITOR 
20ec			;	endif 
20ec			; 
20ec			;	if FORTH_ENABLE_FREE 
20ec			;	call free 
20ec			;	endif 
20ec			; 
20ec			;	if DEBUG_FORTH_WORDS 
20ec			;		DMARK "EX6" 
20ec			;		CALLMONITOR 
20ec			;	endif 
20ec			; 
20ec			;	pop bc 
20ec			;	pop de 
20ec			;	pop hl 
20ec			;;	FORTH_RSP_POP	  
20ec			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
20ec			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
20ec			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
20ec			; 
20ec			;	if DEBUG_FORTH_WORDS 
20ec			;		DMARK "EX7" 
20ec			;		CALLMONITOR 
20ec			;	endif 
20ec			;	NEXTW 
20ec			 
20ec			;.STKEXEC: 
20ec			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
20ec			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
20ec			; 
20ec			; 
20ec			;		if DEBUG_FORTH_WORDS_KEY 
20ec			;			DMARK "STX" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			; 
20ec			;	FORTH_DSP_VALUEHL 
20ec			; 
20ec			;	ld (store_tmp1), hl    ; count 
20ec			; 
20ec			;	FORTH_DSP_POP 
20ec			;.stkexec1: 
20ec			;	ld hl, (store_tmp1)   ; count 
20ec			;	ld a, 0 
20ec			;	cp l 
20ec			;	ret z 
20ec			; 
20ec			;	dec hl 
20ec			;	ld (store_tmp1), hl    ; count 
20ec			;	 
20ec			;	FORTH_DSP_VALUEHL 
20ec			;	push hl 
20ec			;	 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EXp" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			;	FORTH_DSP_POP 
20ec			; 
20ec			;	call strlenz 
20ec			;	inc hl   ; include zero term to copy 
20ec			;	inc hl   ; include zero term to copy 
20ec			;	inc hl   ; include zero term to copy 
20ec			;	ld b,0 
20ec			;	ld c,l 
20ec			;	pop hl 
20ec			;	ld de, execscratch 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EX3" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			;	ldir 
20ec			; 
20ec			; 
20ec			;	ld hl, execscratch 
20ec			; 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EXP" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			; 
20ec			;	call forthparse 
20ec			;	ld hl, execscratch 
20ec			;		if DEBUG_FORTH_WORDS 
20ec			;			DMARK "EXx" 
20ec			;			CALLMONITOR 
20ec			;		endif 
20ec			;	call forthexec 
20ec			; 
20ec			;	jp .stkexec1 
20ec			; 
20ec			;	ret 
20ec			 
20ec			 
20ec			.DUP: 
20ec				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
20ec 17				db WORD_SYS_CORE+OPCODE_DUP             
20ed 62 21			dw .ZDUP            
20ef 04				db 3 + 1 
20f0 .. 00			db "DUP",0              
20f4				endm 
# End of macro CWHEAD
20f4			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
20f4			 
20f4					if DEBUG_FORTH_WORDS_KEY 
20f4						DMARK "DUP" 
20f4 f5				push af  
20f5 3a 09 21			ld a, (.dmark)  
20f8 32 71 ee			ld (debug_mark),a  
20fb 3a 0a 21			ld a, (.dmark+1)  
20fe 32 72 ee			ld (debug_mark+1),a  
2101 3a 0b 21			ld a, (.dmark+2)  
2104 32 73 ee			ld (debug_mark+2),a  
2107 18 03			jr .pastdmark  
2109 ..			.dmark: db "DUP"  
210c f1			.pastdmark: pop af  
210d			endm  
# End of macro DMARK
210d						CALLMONITOR 
210d cd 76 15			call break_point_state  
2110				endm  
# End of macro CALLMONITOR
2110					endif 
2110			 
2110					FORTH_DSP 
2110 cd a4 1d			call macro_forth_dsp 
2113				endm 
# End of macro FORTH_DSP
2113			 
2113 7e					ld a, (HL) 
2114 fe 01				cp DS_TYPE_STR 
2116 20 25				jr nz, .dupinum 
2118			 
2118					; push another string 
2118			 
2118					FORTH_DSP_VALUEHL     		 
2118 cd de 1d			call macro_dsp_valuehl 
211b				endm 
# End of macro FORTH_DSP_VALUEHL
211b			 
211b				if DEBUG_FORTH_WORDS 
211b					DMARK "DUs" 
211b f5				push af  
211c 3a 30 21			ld a, (.dmark)  
211f 32 71 ee			ld (debug_mark),a  
2122 3a 31 21			ld a, (.dmark+1)  
2125 32 72 ee			ld (debug_mark+1),a  
2128 3a 32 21			ld a, (.dmark+2)  
212b 32 73 ee			ld (debug_mark+2),a  
212e 18 03			jr .pastdmark  
2130 ..			.dmark: db "DUs"  
2133 f1			.pastdmark: pop af  
2134			endm  
# End of macro DMARK
2134					CALLMONITOR 
2134 cd 76 15			call break_point_state  
2137				endm  
# End of macro CALLMONITOR
2137				endif 
2137 cd 55 1c				call forth_push_str 
213a			 
213a					NEXTW 
213a c3 55 1f			jp macro_next 
213d				endm 
# End of macro NEXTW
213d			 
213d			 
213d			.dupinum: 
213d					 
213d			 
213d			 
213d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
213d cd de 1d			call macro_dsp_valuehl 
2140				endm 
# End of macro FORTH_DSP_VALUEHL
2140			 
2140				; TODO add floating point number detection 
2140			 
2140				if DEBUG_FORTH_WORDS 
2140					DMARK "DUi" 
2140 f5				push af  
2141 3a 55 21			ld a, (.dmark)  
2144 32 71 ee			ld (debug_mark),a  
2147 3a 56 21			ld a, (.dmark+1)  
214a 32 72 ee			ld (debug_mark+1),a  
214d 3a 57 21			ld a, (.dmark+2)  
2150 32 73 ee			ld (debug_mark+2),a  
2153 18 03			jr .pastdmark  
2155 ..			.dmark: db "DUi"  
2158 f1			.pastdmark: pop af  
2159			endm  
# End of macro DMARK
2159					CALLMONITOR 
2159 cd 76 15			call break_point_state  
215c				endm  
# End of macro CALLMONITOR
215c				endif 
215c			 
215c cd e7 1b				call forth_push_numhl 
215f					NEXTW 
215f c3 55 1f			jp macro_next 
2162				endm 
# End of macro NEXTW
2162			.ZDUP: 
2162				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2162 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2163 9a 21			dw .SWAP            
2165 05				db 4 + 1 
2166 .. 00			db "?DUP",0              
216b				endm 
# End of macro CWHEAD
216b			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
216b			 
216b					if DEBUG_FORTH_WORDS_KEY 
216b						DMARK "qDU" 
216b f5				push af  
216c 3a 80 21			ld a, (.dmark)  
216f 32 71 ee			ld (debug_mark),a  
2172 3a 81 21			ld a, (.dmark+1)  
2175 32 72 ee			ld (debug_mark+1),a  
2178 3a 82 21			ld a, (.dmark+2)  
217b 32 73 ee			ld (debug_mark+2),a  
217e 18 03			jr .pastdmark  
2180 ..			.dmark: db "qDU"  
2183 f1			.pastdmark: pop af  
2184			endm  
# End of macro DMARK
2184						CALLMONITOR 
2184 cd 76 15			call break_point_state  
2187				endm  
# End of macro CALLMONITOR
2187					endif 
2187					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2187 cd de 1d			call macro_dsp_valuehl 
218a				endm 
# End of macro FORTH_DSP_VALUEHL
218a			 
218a e5					push hl 
218b			 
218b					; is it a zero? 
218b			 
218b 3e 00				ld a, 0 
218d 84					add h 
218e 85					add l 
218f			 
218f e1					pop hl 
2190			 
2190 fe 00				cp 0 
2192 28 03				jr z, .dup2orig 
2194			 
2194			 
2194 cd e7 1b				call forth_push_numhl 
2197			 
2197			 
2197				; TODO add floating point number detection 
2197			 
2197			.dup2orig: 
2197			 
2197					NEXTW 
2197 c3 55 1f			jp macro_next 
219a				endm 
# End of macro NEXTW
219a			.SWAP: 
219a				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
219a 18				db WORD_SYS_CORE+OPCODE_SWAP             
219b d9 21			dw .COLN            
219d 05				db 4 + 1 
219e .. 00			db "SWAP",0              
21a3				endm 
# End of macro CWHEAD
21a3			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21a3					if DEBUG_FORTH_WORDS_KEY 
21a3						DMARK "SWP" 
21a3 f5				push af  
21a4 3a b8 21			ld a, (.dmark)  
21a7 32 71 ee			ld (debug_mark),a  
21aa 3a b9 21			ld a, (.dmark+1)  
21ad 32 72 ee			ld (debug_mark+1),a  
21b0 3a ba 21			ld a, (.dmark+2)  
21b3 32 73 ee			ld (debug_mark+2),a  
21b6 18 03			jr .pastdmark  
21b8 ..			.dmark: db "SWP"  
21bb f1			.pastdmark: pop af  
21bc			endm  
# End of macro DMARK
21bc						CALLMONITOR 
21bc cd 76 15			call break_point_state  
21bf				endm  
# End of macro CALLMONITOR
21bf					endif 
21bf			 
21bf					FORTH_DSP_VALUEHL 
21bf cd de 1d			call macro_dsp_valuehl 
21c2				endm 
# End of macro FORTH_DSP_VALUEHL
21c2 e5					push hl     ; w2 
21c3			 
21c3					FORTH_DSP_POP 
21c3 cd 96 1e			call macro_forth_dsp_pop 
21c6				endm 
# End of macro FORTH_DSP_POP
21c6			 
21c6					FORTH_DSP_VALUEHL 
21c6 cd de 1d			call macro_dsp_valuehl 
21c9				endm 
# End of macro FORTH_DSP_VALUEHL
21c9			 
21c9					FORTH_DSP_POP 
21c9 cd 96 1e			call macro_forth_dsp_pop 
21cc				endm 
# End of macro FORTH_DSP_POP
21cc			 
21cc d1					pop de     ; w2	, hl = w1 
21cd			 
21cd eb					ex de, hl 
21ce d5					push de 
21cf			 
21cf cd e7 1b				call forth_push_numhl 
21d2			 
21d2 e1					pop hl 
21d3			 
21d3 cd e7 1b				call forth_push_numhl 
21d6					 
21d6			 
21d6					NEXTW 
21d6 c3 55 1f			jp macro_next 
21d9				endm 
# End of macro NEXTW
21d9			.COLN: 
21d9				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
21d9 19				db WORD_SYS_CORE+OPCODE_COLN             
21da 65 23			dw .SCOLN            
21dc 02				db 1 + 1 
21dd .. 00			db ":",0              
21df				endm 
# End of macro CWHEAD
21df			; | : ( -- )         Create new word | DONE 
21df			 
21df					if DEBUG_FORTH_WORDS_KEY 
21df						DMARK "CLN" 
21df f5				push af  
21e0 3a f4 21			ld a, (.dmark)  
21e3 32 71 ee			ld (debug_mark),a  
21e6 3a f5 21			ld a, (.dmark+1)  
21e9 32 72 ee			ld (debug_mark+1),a  
21ec 3a f6 21			ld a, (.dmark+2)  
21ef 32 73 ee			ld (debug_mark+2),a  
21f2 18 03			jr .pastdmark  
21f4 ..			.dmark: db "CLN"  
21f7 f1			.pastdmark: pop af  
21f8			endm  
# End of macro DMARK
21f8						CALLMONITOR 
21f8 cd 76 15			call break_point_state  
21fb				endm  
# End of macro CALLMONITOR
21fb					endif 
21fb				STACKFRAME OFF $8efe $989f 
21fb				if DEBUG_STACK_IMB 
21fb					if OFF 
21fb						exx 
21fb						ld de, $8efe 
21fb						ld a, d 
21fb						ld hl, curframe 
21fb						call hexout 
21fb						ld a, e 
21fb						ld hl, curframe+2 
21fb						call hexout 
21fb						ld hl, $8efe 
21fb						push hl 
21fb						ld hl, $989f 
21fb						push hl 
21fb						exx 
21fb					endif 
21fb				endif 
21fb			endm 
# End of macro STACKFRAME
21fb				; get parser buffer length  of new word 
21fb			 
21fb				 
21fb			 
21fb					; move tok past this to start of name defintition 
21fb					; TODO get word to define 
21fb					; TODO Move past word token 
21fb					; TODO get length of string up to the ';' 
21fb			 
21fb 2a 03 e6			ld hl, (os_tok_ptr) 
21fe 23				inc hl 
21ff 23				inc hl 
2200			 
2200 3e 3b			ld a, ';' 
2202 cd de 11			call strlent 
2205			 
2205 7d				ld a,l 
2206 32 fe e2			ld (os_new_parse_len), a 
2209			 
2209			 
2209			if DEBUG_FORTH_UWORD 
2209 ed 5b 03 e6		ld de, (os_tok_ptr) 
220d						DMARK ":01" 
220d f5				push af  
220e 3a 22 22			ld a, (.dmark)  
2211 32 71 ee			ld (debug_mark),a  
2214 3a 23 22			ld a, (.dmark+1)  
2217 32 72 ee			ld (debug_mark+1),a  
221a 3a 24 22			ld a, (.dmark+2)  
221d 32 73 ee			ld (debug_mark+2),a  
2220 18 03			jr .pastdmark  
2222 ..			.dmark: db ":01"  
2225 f1			.pastdmark: pop af  
2226			endm  
# End of macro DMARK
2226				CALLMONITOR 
2226 cd 76 15			call break_point_state  
2229				endm  
# End of macro CALLMONITOR
2229			endif 
2229			 
2229			; 
2229			;  new word memory layout: 
2229			;  
2229			;    : adg 6666 ;  
2229			; 
2229			;    db   1     ; user defined word  
2229 23				inc hl    
222a			;    dw   sysdict 
222a 23				inc hl 
222b 23				inc hl 
222c			;    db <word len>+1 (for null) 
222c 23				inc hl 
222d			;    db .... <word> 
222d			; 
222d			 
222d 23				inc hl    ; some extras for the word preamble before the above 
222e 23				inc hl 
222f 23				inc hl 
2230 23				inc hl 
2231 23				inc hl 
2232 23				inc hl 
2233 23				inc hl  
2234 23				inc hl 
2235 23				inc hl 
2236 23				inc hl 
2237 23				inc hl 
2238 23				inc hl 
2239 23				inc hl 
223a 23				inc hl     ; TODO how many do we really need?     maybe only 6 
223b			;       exec word buffer 
223b			;	<ptr word>   
223b 23				inc hl 
223c 23				inc hl 
223d			;       <word list><null term> 7F final term 
223d			 
223d			 
223d			if DEBUG_FORTH_UWORD 
223d						DMARK ":02" 
223d f5				push af  
223e 3a 52 22			ld a, (.dmark)  
2241 32 71 ee			ld (debug_mark),a  
2244 3a 53 22			ld a, (.dmark+1)  
2247 32 72 ee			ld (debug_mark+1),a  
224a 3a 54 22			ld a, (.dmark+2)  
224d 32 73 ee			ld (debug_mark+2),a  
2250 18 03			jr .pastdmark  
2252 ..			.dmark: db ":02"  
2255 f1			.pastdmark: pop af  
2256			endm  
# End of macro DMARK
2256				CALLMONITOR 
2256 cd 76 15			call break_point_state  
2259				endm  
# End of macro CALLMONITOR
2259			endif 
2259			 
2259				 
2259					; malloc the size 
2259			 
2259 cd 3c 12				call malloc 
225c 22 00 e3				ld (os_new_malloc), hl     ; save malloc start 
225f			 
225f			;    db   1     ; user defined word  
225f 3e 01				ld a, WORD_SYS_UWORD  
2261 77					ld (hl), a 
2262				 
2262 23				inc hl    
2263			;    dw   sysdict 
2263 11 ad 20			ld de, sysdict       ; continue on with the scan to the system dict 
2266 73				ld (hl), e 
2267 23				inc hl 
2268 72				ld (hl), d 
2269 23				inc hl 
226a			 
226a			 
226a			;    Setup dict word 
226a			 
226a 23				inc hl 
226b 22 fa e2			ld (os_new_work_ptr), hl     ; save start of dict word  
226e			 
226e				; 1. get length of dict word 
226e			 
226e			 
226e 2a 03 e6			ld hl, (os_tok_ptr) 
2271 23				inc hl 
2272 23				inc hl    ; position to start of dict word 
2273 3e 00			ld a, 0 
2275 cd de 11			call strlent 
2278			 
2278			 
2278 23				inc hl    ; to include null??? 
2279			 
2279				; write length of dict word 
2279			 
2279 ed 5b fa e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
227d 1b				dec de 
227e eb				ex de, hl 
227f 73				ld (hl), e 
2280 eb				ex de, hl 
2281			 
2281				 
2281			 
2281				; copy  
2281 4d				ld c, l 
2282 06 00			ld b, 0 
2284 ed 5b fa e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2288 2a 03 e6			ld hl, (os_tok_ptr) 
228b 23				inc hl 
228c 23				inc hl    ; position to start of dict word 
228d				 
228d			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
228d				 
228d				; TODO need to convert word to upper case 
228d			 
228d			ucasetok:	 
228d 7e				ld a,(hl) 
228e cd ca 11			call toUpper 
2291 77				ld (hl),a 
2292 ed a0			ldi 
2294 f2 8d 22		 	jp p, ucasetok 
2297			 
2297			 
2297			 
2297				; de now points to start of where the word body code should be placed 
2297 ed 53 fa e2		ld (os_new_work_ptr), de 
229b				; hl now points to the words to throw at forthexec which needs to be copied 
229b 22 f8 e2			ld (os_new_src_ptr), hl 
229e			 
229e				; TODO add 'call to forthexec' 
229e			 
229e			if DEBUG_FORTH_UWORD 
229e c5				push bc 
229f ed 4b 00 e3		ld bc, (os_new_malloc) 
22a3						DMARK ":0x" 
22a3 f5				push af  
22a4 3a b8 22			ld a, (.dmark)  
22a7 32 71 ee			ld (debug_mark),a  
22aa 3a b9 22			ld a, (.dmark+1)  
22ad 32 72 ee			ld (debug_mark+1),a  
22b0 3a ba 22			ld a, (.dmark+2)  
22b3 32 73 ee			ld (debug_mark+2),a  
22b6 18 03			jr .pastdmark  
22b8 ..			.dmark: db ":0x"  
22bb f1			.pastdmark: pop af  
22bc			endm  
# End of macro DMARK
22bc				CALLMONITOR 
22bc cd 76 15			call break_point_state  
22bf				endm  
# End of macro CALLMONITOR
22bf c1				pop bc 
22c0			endif 
22c0			 
22c0			 
22c0				; create word preamble which should be: 
22c0			 
22c0			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
22c0			 
22c0				;    ld hl, <word code> 
22c0				;    jp user_exec 
22c0			        ;    <word code bytes> 
22c0			 
22c0			 
22c0			;	inc de     ; TODO ??? or are we already past the word's null 
22c0 eb				ex de, hl 
22c1			 
22c1 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
22c3			 
22c3 23				inc hl 
22c4 22 f4 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
22c7 23				inc hl 
22c8			 
22c8 23				inc hl 
22c9 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
22cb			 
22cb 01 ea 46			ld bc, user_exec 
22ce 23				inc hl 
22cf 71				ld (hl), c     ; poke address of user_exec 
22d0 23				inc hl 
22d1 70				ld (hl), b     
22d2			 ; 
22d2			;	inc hl 
22d2			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22d2			; 
22d2			; 
22d2			;	ld bc, macro_forth_rsp_next 
22d2			;	inc hl 
22d2			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
22d2			;	inc hl 
22d2			;	ld (hl), b     
22d2			 ; 
22d2			;	inc hl 
22d2			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22d2			; 
22d2			; 
22d2			;	inc hl 
22d2			;	ld bc, forthexec 
22d2			;	ld (hl), c     ; poke address of forthexec 
22d2			;	inc hl 
22d2			;	ld (hl), b      
22d2			; 
22d2			;	inc hl 
22d2			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
22d2			; 
22d2			;	ld bc, user_dict_next 
22d2			;	inc hl 
22d2			;	ld (hl), c     ; poke address of forthexec 
22d2			;	inc hl 
22d2			;	ld (hl), b      
22d2			 
22d2				; hl is now where we need to copy the word byte data to save this 
22d2			 
22d2 23				inc hl 
22d3 22 f6 e2			ld (os_new_exec), hl 
22d6				 
22d6				; copy definition 
22d6			 
22d6 eb				ex de, hl 
22d7			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
22d7			;	inc de    ; skip the PC for this parse 
22d7 3a fe e2			ld a, (os_new_parse_len) 
22da 4f				ld c, a 
22db 06 00			ld b, 0 
22dd ed b0			ldir		 ; copy defintion 
22df			 
22df			 
22df				; poke the address of where the new word bytes live for forthexec 
22df			 
22df 2a f4 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22e2			 
22e2 ed 5b f6 e2		ld de, (os_new_exec)      
22e6				 
22e6 73				ld (hl), e 
22e7 23				inc hl 
22e8 72				ld (hl), d 
22e9			 
22e9					; TODO copy last user dict word next link to this word 
22e9					; TODO update last user dict word to point to this word 
22e9			; 
22e9			; hl f923 de 812a ; bc 811a 
22e9			 
22e9			if DEBUG_FORTH_UWORD 
22e9 c5				push bc 
22ea ed 4b 00 e3		ld bc, (os_new_malloc) 
22ee						DMARK ":0A" 
22ee f5				push af  
22ef 3a 03 23			ld a, (.dmark)  
22f2 32 71 ee			ld (debug_mark),a  
22f5 3a 04 23			ld a, (.dmark+1)  
22f8 32 72 ee			ld (debug_mark+1),a  
22fb 3a 05 23			ld a, (.dmark+2)  
22fe 32 73 ee			ld (debug_mark+2),a  
2301 18 03			jr .pastdmark  
2303 ..			.dmark: db ":0A"  
2306 f1			.pastdmark: pop af  
2307			endm  
# End of macro DMARK
2307				CALLMONITOR 
2307 cd 76 15			call break_point_state  
230a				endm  
# End of macro CALLMONITOR
230a c1				pop bc 
230b			endif 
230b			if DEBUG_FORTH_UWORD 
230b c5				push bc 
230c ed 4b 00 e3		ld bc, (os_new_malloc) 
2310 03				inc bc 
2311 03				inc bc 
2312 03				inc bc 
2313 03				inc bc 
2314 03				inc bc 
2315 03				inc bc 
2316 03				inc bc 
2317 03				inc bc 
2318			 
2318						DMARK ":0B" 
2318 f5				push af  
2319 3a 2d 23			ld a, (.dmark)  
231c 32 71 ee			ld (debug_mark),a  
231f 3a 2e 23			ld a, (.dmark+1)  
2322 32 72 ee			ld (debug_mark+1),a  
2325 3a 2f 23			ld a, (.dmark+2)  
2328 32 73 ee			ld (debug_mark+2),a  
232b 18 03			jr .pastdmark  
232d ..			.dmark: db ":0B"  
2330 f1			.pastdmark: pop af  
2331			endm  
# End of macro DMARK
2331				CALLMONITOR 
2331 cd 76 15			call break_point_state  
2334				endm  
# End of macro CALLMONITOR
2334 c1				pop bc 
2335			endif 
2335			 
2335			; update word dict linked list for new word 
2335			 
2335			 
2335 2a ff e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2338 23			inc hl     ; move to next work linked list ptr 
2339			 
2339 ed 5b 00 e3	ld de, (os_new_malloc)		 ; new next word 
233d 73			ld (hl), e 
233e 23			inc hl 
233f 72			ld (hl), d 
2340			 
2340			if DEBUG_FORTH_UWORD 
2340 ed 4b ff e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2344			endif 
2344			 
2344 ed 53 ff e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2348			 
2348			 
2348			if DEBUG_FORTH_UWORD 
2348						DMARK ":0+" 
2348 f5				push af  
2349 3a 5d 23			ld a, (.dmark)  
234c 32 71 ee			ld (debug_mark),a  
234f 3a 5e 23			ld a, (.dmark+1)  
2352 32 72 ee			ld (debug_mark+1),a  
2355 3a 5f 23			ld a, (.dmark+2)  
2358 32 73 ee			ld (debug_mark+2),a  
235b 18 03			jr .pastdmark  
235d ..			.dmark: db ":0+"  
2360 f1			.pastdmark: pop af  
2361			endm  
# End of macro DMARK
2361				CALLMONITOR 
2361 cd 76 15			call break_point_state  
2364				endm  
# End of macro CALLMONITOR
2364			endif 
2364			 
2364				STACKFRAMECHK OFF $8efe $989f 
2364				if DEBUG_STACK_IMB 
2364					if OFF 
2364						exx 
2364						ld hl, $989f 
2364						pop de   ; $989f 
2364						call cmp16 
2364						jr nz, .spnosame 
2364						ld hl, $8efe 
2364						pop de   ; $8efe 
2364						call cmp16 
2364						jr z, .spfrsame 
2364						.spnosame: call showsperror 
2364						.spfrsame: nop 
2364						exx 
2364					endif 
2364				endif 
2364			endm 
# End of macro STACKFRAMECHK
2364			 
2364 c9			ret    ; dont process any remaining parser tokens as they form new word 
2365			 
2365			 
2365			 
2365			 
2365			;		NEXT 
2365			.SCOLN: 
2365			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2365 06				db OPCODE_SCOLN 
2366 b1 23			dw .DROP 
2368 02				db 2 
2369 .. 00			db ";",0           
236b			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
236b					if DEBUG_FORTH_WORDS_KEY 
236b						DMARK "SCN" 
236b f5				push af  
236c 3a 80 23			ld a, (.dmark)  
236f 32 71 ee			ld (debug_mark),a  
2372 3a 81 23			ld a, (.dmark+1)  
2375 32 72 ee			ld (debug_mark+1),a  
2378 3a 82 23			ld a, (.dmark+2)  
237b 32 73 ee			ld (debug_mark+2),a  
237e 18 03			jr .pastdmark  
2380 ..			.dmark: db "SCN"  
2383 f1			.pastdmark: pop af  
2384			endm  
# End of macro DMARK
2384						CALLMONITOR 
2384 cd 76 15			call break_point_state  
2387				endm  
# End of macro CALLMONITOR
2387					endif 
2387					FORTH_RSP_TOS 
2387 cd a5 1b			call macro_forth_rsp_tos 
238a				endm 
# End of macro FORTH_RSP_TOS
238a e5					push hl 
238b					FORTH_RSP_POP 
238b cd af 1b			call macro_forth_rsp_pop 
238e				endm 
# End of macro FORTH_RSP_POP
238e e1					pop hl 
238f			;		ex de,hl 
238f 22 03 e6				ld (os_tok_ptr),hl 
2392			 
2392			if DEBUG_FORTH_UWORD 
2392						DMARK "SCL" 
2392 f5				push af  
2393 3a a7 23			ld a, (.dmark)  
2396 32 71 ee			ld (debug_mark),a  
2399 3a a8 23			ld a, (.dmark+1)  
239c 32 72 ee			ld (debug_mark+1),a  
239f 3a a9 23			ld a, (.dmark+2)  
23a2 32 73 ee			ld (debug_mark+2),a  
23a5 18 03			jr .pastdmark  
23a7 ..			.dmark: db "SCL"  
23aa f1			.pastdmark: pop af  
23ab			endm  
# End of macro DMARK
23ab				CALLMONITOR 
23ab cd 76 15			call break_point_state  
23ae				endm  
# End of macro CALLMONITOR
23ae			endif 
23ae					NEXTW 
23ae c3 55 1f			jp macro_next 
23b1				endm 
# End of macro NEXTW
23b1			 
23b1			.DROP: 
23b1				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
23b1 1b				db WORD_SYS_CORE+OPCODE_DROP             
23b2 dc 23			dw .DUP2            
23b4 05				db 4 + 1 
23b5 .. 00			db "DROP",0              
23ba				endm 
# End of macro CWHEAD
23ba			; | DROP ( w -- )   drop the TOS item   | DONE 
23ba					if DEBUG_FORTH_WORDS_KEY 
23ba						DMARK "DRP" 
23ba f5				push af  
23bb 3a cf 23			ld a, (.dmark)  
23be 32 71 ee			ld (debug_mark),a  
23c1 3a d0 23			ld a, (.dmark+1)  
23c4 32 72 ee			ld (debug_mark+1),a  
23c7 3a d1 23			ld a, (.dmark+2)  
23ca 32 73 ee			ld (debug_mark+2),a  
23cd 18 03			jr .pastdmark  
23cf ..			.dmark: db "DRP"  
23d2 f1			.pastdmark: pop af  
23d3			endm  
# End of macro DMARK
23d3						CALLMONITOR 
23d3 cd 76 15			call break_point_state  
23d6				endm  
# End of macro CALLMONITOR
23d6					endif 
23d6					FORTH_DSP_POP 
23d6 cd 96 1e			call macro_forth_dsp_pop 
23d9				endm 
# End of macro FORTH_DSP_POP
23d9					NEXTW 
23d9 c3 55 1f			jp macro_next 
23dc				endm 
# End of macro NEXTW
23dc			.DUP2: 
23dc				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
23dc 1c				db WORD_SYS_CORE+OPCODE_DUP2             
23dd 21 24			dw .DROP2            
23df 05				db 4 + 1 
23e0 .. 00			db "2DUP",0              
23e5				endm 
# End of macro CWHEAD
23e5			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
23e5					if DEBUG_FORTH_WORDS_KEY 
23e5						DMARK "2DU" 
23e5 f5				push af  
23e6 3a fa 23			ld a, (.dmark)  
23e9 32 71 ee			ld (debug_mark),a  
23ec 3a fb 23			ld a, (.dmark+1)  
23ef 32 72 ee			ld (debug_mark+1),a  
23f2 3a fc 23			ld a, (.dmark+2)  
23f5 32 73 ee			ld (debug_mark+2),a  
23f8 18 03			jr .pastdmark  
23fa ..			.dmark: db "2DU"  
23fd f1			.pastdmark: pop af  
23fe			endm  
# End of macro DMARK
23fe						CALLMONITOR 
23fe cd 76 15			call break_point_state  
2401				endm  
# End of macro CALLMONITOR
2401					endif 
2401					FORTH_DSP_VALUEHL 
2401 cd de 1d			call macro_dsp_valuehl 
2404				endm 
# End of macro FORTH_DSP_VALUEHL
2404 e5					push hl      ; 2 
2405			 
2405					FORTH_DSP_POP 
2405 cd 96 1e			call macro_forth_dsp_pop 
2408				endm 
# End of macro FORTH_DSP_POP
2408					 
2408					FORTH_DSP_VALUEHL 
2408 cd de 1d			call macro_dsp_valuehl 
240b				endm 
# End of macro FORTH_DSP_VALUEHL
240b			;		push hl      ; 1 
240b			 
240b					FORTH_DSP_POP 
240b cd 96 1e			call macro_forth_dsp_pop 
240e				endm 
# End of macro FORTH_DSP_POP
240e			 
240e			;		pop hl       ; 1 
240e d1					pop de       ; 2 
240f			 
240f cd e7 1b				call forth_push_numhl 
2412 eb					ex de, hl 
2413 cd e7 1b				call forth_push_numhl 
2416			 
2416					 
2416 eb					ex de, hl 
2417			 
2417 cd e7 1b				call forth_push_numhl 
241a eb					ex de, hl 
241b cd e7 1b				call forth_push_numhl 
241e			 
241e			 
241e					NEXTW 
241e c3 55 1f			jp macro_next 
2421				endm 
# End of macro NEXTW
2421			.DROP2: 
2421				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2421 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2422 50 24			dw .SWAP2            
2424 06				db 5 + 1 
2425 .. 00			db "2DROP",0              
242b				endm 
# End of macro CWHEAD
242b			; | 2DROP ( w w -- )    Double drop | DONE 
242b					if DEBUG_FORTH_WORDS_KEY 
242b						DMARK "2DR" 
242b f5				push af  
242c 3a 40 24			ld a, (.dmark)  
242f 32 71 ee			ld (debug_mark),a  
2432 3a 41 24			ld a, (.dmark+1)  
2435 32 72 ee			ld (debug_mark+1),a  
2438 3a 42 24			ld a, (.dmark+2)  
243b 32 73 ee			ld (debug_mark+2),a  
243e 18 03			jr .pastdmark  
2440 ..			.dmark: db "2DR"  
2443 f1			.pastdmark: pop af  
2444			endm  
# End of macro DMARK
2444						CALLMONITOR 
2444 cd 76 15			call break_point_state  
2447				endm  
# End of macro CALLMONITOR
2447					endif 
2447					FORTH_DSP_POP 
2447 cd 96 1e			call macro_forth_dsp_pop 
244a				endm 
# End of macro FORTH_DSP_POP
244a					FORTH_DSP_POP 
244a cd 96 1e			call macro_forth_dsp_pop 
244d				endm 
# End of macro FORTH_DSP_POP
244d					NEXTW 
244d c3 55 1f			jp macro_next 
2450				endm 
# End of macro NEXTW
2450			.SWAP2: 
2450				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2450 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2451 79 24			dw .AT            
2453 06				db 5 + 1 
2454 .. 00			db "2SWAP",0              
245a				endm 
# End of macro CWHEAD
245a			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
245a					if DEBUG_FORTH_WORDS_KEY 
245a						DMARK "2SW" 
245a f5				push af  
245b 3a 6f 24			ld a, (.dmark)  
245e 32 71 ee			ld (debug_mark),a  
2461 3a 70 24			ld a, (.dmark+1)  
2464 32 72 ee			ld (debug_mark+1),a  
2467 3a 71 24			ld a, (.dmark+2)  
246a 32 73 ee			ld (debug_mark+2),a  
246d 18 03			jr .pastdmark  
246f ..			.dmark: db "2SW"  
2472 f1			.pastdmark: pop af  
2473			endm  
# End of macro DMARK
2473						CALLMONITOR 
2473 cd 76 15			call break_point_state  
2476				endm  
# End of macro CALLMONITOR
2476					endif 
2476					NEXTW 
2476 c3 55 1f			jp macro_next 
2479				endm 
# End of macro NEXTW
2479			.AT: 
2479				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2479 1f				db WORD_SYS_CORE+OPCODE_AT             
247a ab 24			dw .CAT            
247c 02				db 1 + 1 
247d .. 00			db "@",0              
247f				endm 
# End of macro CWHEAD
247f			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
247f			 
247f					if DEBUG_FORTH_WORDS_KEY 
247f						DMARK "AT." 
247f f5				push af  
2480 3a 94 24			ld a, (.dmark)  
2483 32 71 ee			ld (debug_mark),a  
2486 3a 95 24			ld a, (.dmark+1)  
2489 32 72 ee			ld (debug_mark+1),a  
248c 3a 96 24			ld a, (.dmark+2)  
248f 32 73 ee			ld (debug_mark+2),a  
2492 18 03			jr .pastdmark  
2494 ..			.dmark: db "AT."  
2497 f1			.pastdmark: pop af  
2498			endm  
# End of macro DMARK
2498						CALLMONITOR 
2498 cd 76 15			call break_point_state  
249b				endm  
# End of macro CALLMONITOR
249b					endif 
249b			.getbyteat:	 
249b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
249b cd de 1d			call macro_dsp_valuehl 
249e				endm 
# End of macro FORTH_DSP_VALUEHL
249e					 
249e			;		push hl 
249e				 
249e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
249e cd 96 1e			call macro_forth_dsp_pop 
24a1				endm 
# End of macro FORTH_DSP_POP
24a1			 
24a1			;		pop hl 
24a1			 
24a1 7e					ld a, (hl) 
24a2			 
24a2 6f					ld l, a 
24a3 26 00				ld h, 0 
24a5 cd e7 1b				call forth_push_numhl 
24a8			 
24a8					NEXTW 
24a8 c3 55 1f			jp macro_next 
24ab				endm 
# End of macro NEXTW
24ab			.CAT: 
24ab				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
24ab 20				db WORD_SYS_CORE+OPCODE_CAT             
24ac d4 24			dw .BANG            
24ae 03				db 2 + 1 
24af .. 00			db "C@",0              
24b2				endm 
# End of macro CWHEAD
24b2			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
24b2					if DEBUG_FORTH_WORDS_KEY 
24b2						DMARK "CAA" 
24b2 f5				push af  
24b3 3a c7 24			ld a, (.dmark)  
24b6 32 71 ee			ld (debug_mark),a  
24b9 3a c8 24			ld a, (.dmark+1)  
24bc 32 72 ee			ld (debug_mark+1),a  
24bf 3a c9 24			ld a, (.dmark+2)  
24c2 32 73 ee			ld (debug_mark+2),a  
24c5 18 03			jr .pastdmark  
24c7 ..			.dmark: db "CAA"  
24ca f1			.pastdmark: pop af  
24cb			endm  
# End of macro DMARK
24cb						CALLMONITOR 
24cb cd 76 15			call break_point_state  
24ce				endm  
# End of macro CALLMONITOR
24ce					endif 
24ce c3 9b 24				jp .getbyteat 
24d1					NEXTW 
24d1 c3 55 1f			jp macro_next 
24d4				endm 
# End of macro NEXTW
24d4			.BANG: 
24d4				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
24d4 21				db WORD_SYS_CORE+OPCODE_BANG             
24d5 0a 25			dw .CBANG            
24d7 02				db 1 + 1 
24d8 .. 00			db "!",0              
24da				endm 
# End of macro CWHEAD
24da			; | ! ( x w -- ) Store x at address w      | DONE 
24da					if DEBUG_FORTH_WORDS_KEY 
24da						DMARK "BNG" 
24da f5				push af  
24db 3a ef 24			ld a, (.dmark)  
24de 32 71 ee			ld (debug_mark),a  
24e1 3a f0 24			ld a, (.dmark+1)  
24e4 32 72 ee			ld (debug_mark+1),a  
24e7 3a f1 24			ld a, (.dmark+2)  
24ea 32 73 ee			ld (debug_mark+2),a  
24ed 18 03			jr .pastdmark  
24ef ..			.dmark: db "BNG"  
24f2 f1			.pastdmark: pop af  
24f3			endm  
# End of macro DMARK
24f3						CALLMONITOR 
24f3 cd 76 15			call break_point_state  
24f6				endm  
# End of macro CALLMONITOR
24f6					endif 
24f6			 
24f6			.storebyteat:		 
24f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24f6 cd de 1d			call macro_dsp_valuehl 
24f9				endm 
# End of macro FORTH_DSP_VALUEHL
24f9					 
24f9 e5					push hl 
24fa				 
24fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24fa cd 96 1e			call macro_forth_dsp_pop 
24fd				endm 
# End of macro FORTH_DSP_POP
24fd			 
24fd					; get byte to poke 
24fd			 
24fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24fd cd de 1d			call macro_dsp_valuehl 
2500				endm 
# End of macro FORTH_DSP_VALUEHL
2500 e5					push hl 
2501			 
2501			 
2501					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2501 cd 96 1e			call macro_forth_dsp_pop 
2504				endm 
# End of macro FORTH_DSP_POP
2504			 
2504			 
2504 d1					pop de 
2505 e1					pop hl 
2506			 
2506 73					ld (hl),e 
2507			 
2507			 
2507					NEXTW 
2507 c3 55 1f			jp macro_next 
250a				endm 
# End of macro NEXTW
250a			.CBANG: 
250a				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
250a 22				db WORD_SYS_CORE+OPCODE_CBANG             
250b 33 25			dw .SCALL            
250d 03				db 2 + 1 
250e .. 00			db "C!",0              
2511				endm 
# End of macro CWHEAD
2511			; | C!  ( x w -- ) Store x at address w  | DONE 
2511					if DEBUG_FORTH_WORDS_KEY 
2511						DMARK "CBA" 
2511 f5				push af  
2512 3a 26 25			ld a, (.dmark)  
2515 32 71 ee			ld (debug_mark),a  
2518 3a 27 25			ld a, (.dmark+1)  
251b 32 72 ee			ld (debug_mark+1),a  
251e 3a 28 25			ld a, (.dmark+2)  
2521 32 73 ee			ld (debug_mark+2),a  
2524 18 03			jr .pastdmark  
2526 ..			.dmark: db "CBA"  
2529 f1			.pastdmark: pop af  
252a			endm  
# End of macro DMARK
252a						CALLMONITOR 
252a cd 76 15			call break_point_state  
252d				endm  
# End of macro CALLMONITOR
252d					endif 
252d c3 f6 24				jp .storebyteat 
2530					NEXTW 
2530 c3 55 1f			jp macro_next 
2533				endm 
# End of macro NEXTW
2533			.SCALL: 
2533				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2533 23				db WORD_SYS_CORE+OPCODE_SCALL             
2534 67 25			dw .DEPTH            
2536 05				db 4 + 1 
2537 .. 00			db "CALL",0              
253c				endm 
# End of macro CWHEAD
253c			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
253c					if DEBUG_FORTH_WORDS_KEY 
253c						DMARK "CLL" 
253c f5				push af  
253d 3a 51 25			ld a, (.dmark)  
2540 32 71 ee			ld (debug_mark),a  
2543 3a 52 25			ld a, (.dmark+1)  
2546 32 72 ee			ld (debug_mark+1),a  
2549 3a 53 25			ld a, (.dmark+2)  
254c 32 73 ee			ld (debug_mark+2),a  
254f 18 03			jr .pastdmark  
2551 ..			.dmark: db "CLL"  
2554 f1			.pastdmark: pop af  
2555			endm  
# End of macro DMARK
2555						CALLMONITOR 
2555 cd 76 15			call break_point_state  
2558				endm  
# End of macro CALLMONITOR
2558					endif 
2558			 
2558					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2558 cd de 1d			call macro_dsp_valuehl 
255b				endm 
# End of macro FORTH_DSP_VALUEHL
255b			 
255b			;		push hl 
255b			 
255b					; destroy value TOS 
255b			 
255b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
255b cd 96 1e			call macro_forth_dsp_pop 
255e				endm 
# End of macro FORTH_DSP_POP
255e			 
255e						 
255e			;		pop hl 
255e			 
255e					; how to do a call with hl???? save SP? 
255e cd f9 1e				call forth_call_hl 
2561			 
2561			 
2561					; TODO push value back onto stack for another op etc 
2561			 
2561 cd e7 1b				call forth_push_numhl 
2564					NEXTW 
2564 c3 55 1f			jp macro_next 
2567				endm 
# End of macro NEXTW
2567			.DEPTH: 
2567				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2567 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2568 a4 25			dw .OVER            
256a 06				db 5 + 1 
256b .. 00			db "DEPTH",0              
2571				endm 
# End of macro CWHEAD
2571			; | DEPTH ( -- u ) Push count of stack | DONE 
2571					; take current TOS and remove from base value div by two to get count 
2571					if DEBUG_FORTH_WORDS_KEY 
2571						DMARK "DEP" 
2571 f5				push af  
2572 3a 86 25			ld a, (.dmark)  
2575 32 71 ee			ld (debug_mark),a  
2578 3a 87 25			ld a, (.dmark+1)  
257b 32 72 ee			ld (debug_mark+1),a  
257e 3a 88 25			ld a, (.dmark+2)  
2581 32 73 ee			ld (debug_mark+2),a  
2584 18 03			jr .pastdmark  
2586 ..			.dmark: db "DEP"  
2589 f1			.pastdmark: pop af  
258a			endm  
# End of macro DMARK
258a						CALLMONITOR 
258a cd 76 15			call break_point_state  
258d				endm  
# End of macro CALLMONITOR
258d					endif 
258d			 
258d			 
258d 2a 2f ea			ld hl, (cli_data_sp) 
2590 11 69 e8			ld de, cli_data_stack 
2593 ed 52			sbc hl,de 
2595				 
2595				; div by size of stack item 
2595			 
2595 5d				ld e,l 
2596 0e 03			ld c, 3 
2598 cd 05 0d			call Div8 
259b			 
259b 6f				ld l,a 
259c 26 00			ld h,0 
259e			 
259e				;srl h 
259e				;rr l 
259e			 
259e cd e7 1b				call forth_push_numhl 
25a1					NEXTW 
25a1 c3 55 1f			jp macro_next 
25a4				endm 
# End of macro NEXTW
25a4			.OVER: 
25a4				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
25a4 42				db WORD_SYS_CORE+46             
25a5 eb 25			dw .PAUSE            
25a7 05				db 4 + 1 
25a8 .. 00			db "OVER",0              
25ad				endm 
# End of macro CWHEAD
25ad			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
25ad					if DEBUG_FORTH_WORDS_KEY 
25ad						DMARK "OVR" 
25ad f5				push af  
25ae 3a c2 25			ld a, (.dmark)  
25b1 32 71 ee			ld (debug_mark),a  
25b4 3a c3 25			ld a, (.dmark+1)  
25b7 32 72 ee			ld (debug_mark+1),a  
25ba 3a c4 25			ld a, (.dmark+2)  
25bd 32 73 ee			ld (debug_mark+2),a  
25c0 18 03			jr .pastdmark  
25c2 ..			.dmark: db "OVR"  
25c5 f1			.pastdmark: pop af  
25c6			endm  
# End of macro DMARK
25c6						CALLMONITOR 
25c6 cd 76 15			call break_point_state  
25c9				endm  
# End of macro CALLMONITOR
25c9					endif 
25c9			 
25c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25c9 cd de 1d			call macro_dsp_valuehl 
25cc				endm 
# End of macro FORTH_DSP_VALUEHL
25cc e5					push hl    ; n2 
25cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25cd cd 96 1e			call macro_forth_dsp_pop 
25d0				endm 
# End of macro FORTH_DSP_POP
25d0			 
25d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25d0 cd de 1d			call macro_dsp_valuehl 
25d3				endm 
# End of macro FORTH_DSP_VALUEHL
25d3 e5					push hl    ; n1 
25d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25d4 cd 96 1e			call macro_forth_dsp_pop 
25d7				endm 
# End of macro FORTH_DSP_POP
25d7			 
25d7 d1					pop de     ; n1 
25d8 e1					pop hl     ; n2 
25d9			 
25d9 d5					push de 
25da e5					push hl 
25db d5					push de 
25dc			 
25dc					; push back  
25dc			 
25dc e1					pop hl 
25dd cd e7 1b				call forth_push_numhl 
25e0 e1					pop hl 
25e1 cd e7 1b				call forth_push_numhl 
25e4 e1					pop hl 
25e5 cd e7 1b				call forth_push_numhl 
25e8					NEXTW 
25e8 c3 55 1f			jp macro_next 
25eb				endm 
# End of macro NEXTW
25eb			 
25eb			.PAUSE: 
25eb				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
25eb 43				db WORD_SYS_CORE+47             
25ec 20 26			dw .PAUSES            
25ee 08				db 7 + 1 
25ef .. 00			db "PAUSEMS",0              
25f7				endm 
# End of macro CWHEAD
25f7			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
25f7					if DEBUG_FORTH_WORDS_KEY 
25f7						DMARK "PMS" 
25f7 f5				push af  
25f8 3a 0c 26			ld a, (.dmark)  
25fb 32 71 ee			ld (debug_mark),a  
25fe 3a 0d 26			ld a, (.dmark+1)  
2601 32 72 ee			ld (debug_mark+1),a  
2604 3a 0e 26			ld a, (.dmark+2)  
2607 32 73 ee			ld (debug_mark+2),a  
260a 18 03			jr .pastdmark  
260c ..			.dmark: db "PMS"  
260f f1			.pastdmark: pop af  
2610			endm  
# End of macro DMARK
2610						CALLMONITOR 
2610 cd 76 15			call break_point_state  
2613				endm  
# End of macro CALLMONITOR
2613					endif 
2613					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2613 cd de 1d			call macro_dsp_valuehl 
2616				endm 
# End of macro FORTH_DSP_VALUEHL
2616			;		push hl    ; n2 
2616					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2616 cd 96 1e			call macro_forth_dsp_pop 
2619				endm 
# End of macro FORTH_DSP_POP
2619			;		pop hl 
2619			 
2619 7d					ld a, l 
261a cd 9f 0a				call aDelayInMS 
261d				       NEXTW 
261d c3 55 1f			jp macro_next 
2620				endm 
# End of macro NEXTW
2620			.PAUSES:  
2620				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2620 44				db WORD_SYS_CORE+48             
2621 8f 26			dw .ROT            
2623 06				db 5 + 1 
2624 .. 00			db "PAUSE",0              
262a				endm 
# End of macro CWHEAD
262a			; | PAUSE ( n -- )  Pause for n seconds | DONE 
262a					if DEBUG_FORTH_WORDS_KEY 
262a						DMARK "PAU" 
262a f5				push af  
262b 3a 3f 26			ld a, (.dmark)  
262e 32 71 ee			ld (debug_mark),a  
2631 3a 40 26			ld a, (.dmark+1)  
2634 32 72 ee			ld (debug_mark+1),a  
2637 3a 41 26			ld a, (.dmark+2)  
263a 32 73 ee			ld (debug_mark+2),a  
263d 18 03			jr .pastdmark  
263f ..			.dmark: db "PAU"  
2642 f1			.pastdmark: pop af  
2643			endm  
# End of macro DMARK
2643						CALLMONITOR 
2643 cd 76 15			call break_point_state  
2646				endm  
# End of macro CALLMONITOR
2646					endif 
2646					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2646 cd de 1d			call macro_dsp_valuehl 
2649				endm 
# End of macro FORTH_DSP_VALUEHL
2649			;		push hl    ; n2 
2649					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2649 cd 96 1e			call macro_forth_dsp_pop 
264c				endm 
# End of macro FORTH_DSP_POP
264c			;		pop hl 
264c 45					ld b, l 
264d					if DEBUG_FORTH_WORDS 
264d						DMARK "PAU" 
264d f5				push af  
264e 3a 62 26			ld a, (.dmark)  
2651 32 71 ee			ld (debug_mark),a  
2654 3a 63 26			ld a, (.dmark+1)  
2657 32 72 ee			ld (debug_mark+1),a  
265a 3a 64 26			ld a, (.dmark+2)  
265d 32 73 ee			ld (debug_mark+2),a  
2660 18 03			jr .pastdmark  
2662 ..			.dmark: db "PAU"  
2665 f1			.pastdmark: pop af  
2666			endm  
# End of macro DMARK
2666						CALLMONITOR 
2666 cd 76 15			call break_point_state  
2669				endm  
# End of macro CALLMONITOR
2669					endif 
2669 c5			.pauses1:	push bc 
266a cd ba 0a				call delay1s 
266d c1					pop bc 
266e					if DEBUG_FORTH_WORDS 
266e						DMARK "PA1" 
266e f5				push af  
266f 3a 83 26			ld a, (.dmark)  
2672 32 71 ee			ld (debug_mark),a  
2675 3a 84 26			ld a, (.dmark+1)  
2678 32 72 ee			ld (debug_mark+1),a  
267b 3a 85 26			ld a, (.dmark+2)  
267e 32 73 ee			ld (debug_mark+2),a  
2681 18 03			jr .pastdmark  
2683 ..			.dmark: db "PA1"  
2686 f1			.pastdmark: pop af  
2687			endm  
# End of macro DMARK
2687						CALLMONITOR 
2687 cd 76 15			call break_point_state  
268a				endm  
# End of macro CALLMONITOR
268a					endif 
268a 10 dd				djnz .pauses1 
268c			 
268c				       NEXTW 
268c c3 55 1f			jp macro_next 
268f				endm 
# End of macro NEXTW
268f			.ROT: 
268f				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
268f 45				db WORD_SYS_CORE+49             
2690 dd 26			dw .UWORDS            
2692 04				db 3 + 1 
2693 .. 00			db "ROT",0              
2697				endm 
# End of macro CWHEAD
2697			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2697					if DEBUG_FORTH_WORDS_KEY 
2697						DMARK "ROT" 
2697 f5				push af  
2698 3a ac 26			ld a, (.dmark)  
269b 32 71 ee			ld (debug_mark),a  
269e 3a ad 26			ld a, (.dmark+1)  
26a1 32 72 ee			ld (debug_mark+1),a  
26a4 3a ae 26			ld a, (.dmark+2)  
26a7 32 73 ee			ld (debug_mark+2),a  
26aa 18 03			jr .pastdmark  
26ac ..			.dmark: db "ROT"  
26af f1			.pastdmark: pop af  
26b0			endm  
# End of macro DMARK
26b0						CALLMONITOR 
26b0 cd 76 15			call break_point_state  
26b3				endm  
# End of macro CALLMONITOR
26b3					endif 
26b3			 
26b3					FORTH_DSP_VALUEHL 
26b3 cd de 1d			call macro_dsp_valuehl 
26b6				endm 
# End of macro FORTH_DSP_VALUEHL
26b6 e5					push hl    ; u3  
26b7			 
26b7					FORTH_DSP_POP 
26b7 cd 96 1e			call macro_forth_dsp_pop 
26ba				endm 
# End of macro FORTH_DSP_POP
26ba			   
26ba					FORTH_DSP_VALUEHL 
26ba cd de 1d			call macro_dsp_valuehl 
26bd				endm 
# End of macro FORTH_DSP_VALUEHL
26bd e5					push hl     ; u2 
26be			 
26be					FORTH_DSP_POP 
26be cd 96 1e			call macro_forth_dsp_pop 
26c1				endm 
# End of macro FORTH_DSP_POP
26c1			 
26c1					FORTH_DSP_VALUEHL 
26c1 cd de 1d			call macro_dsp_valuehl 
26c4				endm 
# End of macro FORTH_DSP_VALUEHL
26c4 e5					push hl     ; u1 
26c5			 
26c5					FORTH_DSP_POP 
26c5 cd 96 1e			call macro_forth_dsp_pop 
26c8				endm 
# End of macro FORTH_DSP_POP
26c8			 
26c8 c1					pop bc      ; u1 
26c9 e1					pop hl      ; u2 
26ca d1					pop de      ; u3 
26cb			 
26cb			 
26cb c5					push bc 
26cc d5					push de 
26cd e5					push hl 
26ce			 
26ce			 
26ce e1					pop hl 
26cf cd e7 1b				call forth_push_numhl 
26d2			 
26d2 e1					pop hl 
26d3 cd e7 1b				call forth_push_numhl 
26d6			 
26d6 e1					pop hl 
26d7 cd e7 1b				call forth_push_numhl 
26da					 
26da			 
26da			 
26da			 
26da			 
26da			 
26da				       NEXTW 
26da c3 55 1f			jp macro_next 
26dd				endm 
# End of macro NEXTW
26dd			 
26dd			.UWORDS: 
26dd				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
26dd 50				db WORD_SYS_CORE+60             
26de 9f 27			dw .BP            
26e0 07				db 6 + 1 
26e1 .. 00			db "UWORDS",0              
26e8				endm 
# End of macro CWHEAD
26e8			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
26e8			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
26e8			; | | Following the count are the individual words. 
26e8			; | | 
26e8			; | | e.g. UWORDS 
26e8			; | | BOX DIRLIST 2 
26e8			; | |  
26e8			; | | Can be used to save the words to storage via: 
26e8			; | | UWORDS $01 DO $01 APPEND LOOP 
26e8				if DEBUG_FORTH_WORDS_KEY 
26e8					DMARK "UWR" 
26e8 f5				push af  
26e9 3a fd 26			ld a, (.dmark)  
26ec 32 71 ee			ld (debug_mark),a  
26ef 3a fe 26			ld a, (.dmark+1)  
26f2 32 72 ee			ld (debug_mark+1),a  
26f5 3a ff 26			ld a, (.dmark+2)  
26f8 32 73 ee			ld (debug_mark+2),a  
26fb 18 03			jr .pastdmark  
26fd ..			.dmark: db "UWR"  
2700 f1			.pastdmark: pop af  
2701			endm  
# End of macro DMARK
2701					CALLMONITOR 
2701 cd 76 15			call break_point_state  
2704				endm  
# End of macro CALLMONITOR
2704				endif 
2704 21 b6 5b				ld hl, baseram 
2707					;ld hl, baseusermem 
2707 01 00 00				ld bc, 0    ; start a counter 
270a			 
270a				; skip dict stub 
270a			 
270a cd a6 20				call forth_tok_next 
270d			 
270d			 
270d			; while we have words to look for 
270d			 
270d 7e			.douscan:	ld a, (hl)      
270e				if DEBUG_FORTH_WORDS 
270e					DMARK "UWs" 
270e f5				push af  
270f 3a 23 27			ld a, (.dmark)  
2712 32 71 ee			ld (debug_mark),a  
2715 3a 24 27			ld a, (.dmark+1)  
2718 32 72 ee			ld (debug_mark+1),a  
271b 3a 25 27			ld a, (.dmark+2)  
271e 32 73 ee			ld (debug_mark+2),a  
2721 18 03			jr .pastdmark  
2723 ..			.dmark: db "UWs"  
2726 f1			.pastdmark: pop af  
2727			endm  
# End of macro DMARK
2727					CALLMONITOR 
2727 cd 76 15			call break_point_state  
272a				endm  
# End of macro CALLMONITOR
272a				endif 
272a fe 00				cp WORD_SYS_END 
272c 28 4d				jr z, .udone 
272e fe 01				cp WORD_SYS_UWORD 
2730 20 44				jr nz, .nuword 
2732			 
2732				if DEBUG_FORTH_WORDS 
2732					DMARK "UWu" 
2732 f5				push af  
2733 3a 47 27			ld a, (.dmark)  
2736 32 71 ee			ld (debug_mark),a  
2739 3a 48 27			ld a, (.dmark+1)  
273c 32 72 ee			ld (debug_mark+1),a  
273f 3a 49 27			ld a, (.dmark+2)  
2742 32 73 ee			ld (debug_mark+2),a  
2745 18 03			jr .pastdmark  
2747 ..			.dmark: db "UWu"  
274a f1			.pastdmark: pop af  
274b			endm  
# End of macro DMARK
274b					CALLMONITOR 
274b cd 76 15			call break_point_state  
274e				endm  
# End of macro CALLMONITOR
274e				endif 
274e					; we have a uword so push its name to the stack 
274e			 
274e e5				   	push hl  ; save so we can move to next dict block 
274f			 
274f					; skip opcode 
274f 23					inc hl  
2750					; skip next ptr 
2750 23					inc hl  
2751 23					inc hl 
2752					; skip len 
2752 23					inc hl 
2753				if DEBUG_FORTH_WORDS 
2753					DMARK "UWt" 
2753 f5				push af  
2754 3a 68 27			ld a, (.dmark)  
2757 32 71 ee			ld (debug_mark),a  
275a 3a 69 27			ld a, (.dmark+1)  
275d 32 72 ee			ld (debug_mark+1),a  
2760 3a 6a 27			ld a, (.dmark+2)  
2763 32 73 ee			ld (debug_mark+2),a  
2766 18 03			jr .pastdmark  
2768 ..			.dmark: db "UWt"  
276b f1			.pastdmark: pop af  
276c			endm  
# End of macro DMARK
276c					CALLMONITOR 
276c cd 76 15			call break_point_state  
276f				endm  
# End of macro CALLMONITOR
276f				endif 
276f 03					inc bc 
2770			 
2770 c5					push bc 
2771 cd 55 1c				call forth_push_str 
2774 c1					pop bc 
2775			 
2775 e1					pop hl 	 
2776			 
2776 cd a6 20		.nuword:	call forth_tok_next 
2779 18 92				jr .douscan  
277b			 
277b			.udone:		 ; push count of uwords found 
277b c5					push bc 
277c e1					pop hl 
277d			 
277d				if DEBUG_FORTH_WORDS 
277d					DMARK "UWc" 
277d f5				push af  
277e 3a 92 27			ld a, (.dmark)  
2781 32 71 ee			ld (debug_mark),a  
2784 3a 93 27			ld a, (.dmark+1)  
2787 32 72 ee			ld (debug_mark+1),a  
278a 3a 94 27			ld a, (.dmark+2)  
278d 32 73 ee			ld (debug_mark+2),a  
2790 18 03			jr .pastdmark  
2792 ..			.dmark: db "UWc"  
2795 f1			.pastdmark: pop af  
2796			endm  
# End of macro DMARK
2796					CALLMONITOR 
2796 cd 76 15			call break_point_state  
2799				endm  
# End of macro CALLMONITOR
2799				endif 
2799 cd e7 1b				call forth_push_numhl 
279c			 
279c			 
279c				       NEXTW 
279c c3 55 1f			jp macro_next 
279f				endm 
# End of macro NEXTW
279f			 
279f			.BP: 
279f				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
279f 54				db WORD_SYS_CORE+64             
27a0 d5 27			dw .MONITOR            
27a2 03				db 2 + 1 
27a3 .. 00			db "BP",0              
27a6				endm 
# End of macro CWHEAD
27a6			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
27a6			; | | $00 Will enable the break points within specific code paths 
27a6			; | | $01 Will disable break points 
27a6			; | |  
27a6			; | | By default break points are off. Either the above can be used to enable them 
27a6			; | | or if a key is held down during start up the spashscreen will appear to freeze 
27a6			; | | and on release of the pressed key a message will be disaplayed to notify 
27a6			; | | that break points are enabled. Pressing any key will then continue boot process. 
27a6					; get byte count 
27a6					if DEBUG_FORTH_WORDS_KEY 
27a6						DMARK "BP." 
27a6 f5				push af  
27a7 3a bb 27			ld a, (.dmark)  
27aa 32 71 ee			ld (debug_mark),a  
27ad 3a bc 27			ld a, (.dmark+1)  
27b0 32 72 ee			ld (debug_mark+1),a  
27b3 3a bd 27			ld a, (.dmark+2)  
27b6 32 73 ee			ld (debug_mark+2),a  
27b9 18 03			jr .pastdmark  
27bb ..			.dmark: db "BP."  
27be f1			.pastdmark: pop af  
27bf			endm  
# End of macro DMARK
27bf						CALLMONITOR 
27bf cd 76 15			call break_point_state  
27c2				endm  
# End of macro CALLMONITOR
27c2					endif 
27c2			 
27c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27c2 cd de 1d			call macro_dsp_valuehl 
27c5				endm 
# End of macro FORTH_DSP_VALUEHL
27c5			 
27c5			;		push hl 
27c5			 
27c5					; destroy value TOS 
27c5			 
27c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c5 cd 96 1e			call macro_forth_dsp_pop 
27c8				endm 
# End of macro FORTH_DSP_POP
27c8			 
27c8			;		pop hl 
27c8			 
27c8 3e 00				ld a,0 
27ca bd					cp l 
27cb 28 02				jr z, .bpset 
27cd 3e 2a				ld a, '*' 
27cf			 
27cf 32 f3 e2		.bpset:		ld (os_view_disable), a 
27d2			 
27d2			 
27d2					NEXTW 
27d2 c3 55 1f			jp macro_next 
27d5				endm 
# End of macro NEXTW
27d5			 
27d5			 
27d5			.MONITOR: 
27d5				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
27d5 55				db WORD_SYS_CORE+65             
27d6 08 28			dw .MALLOC            
27d8 08				db 7 + 1 
27d9 .. 00			db "MONITOR",0              
27e1				endm 
# End of macro CWHEAD
27e1			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
27e1			; | | At start the current various registers will be displayed with contents. 
27e1			; | | Top right corner will show the most recent debug marker seen. 
27e1			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
27e1			; | | and the return stack pointer (RSP). 
27e1			; | | Pressing: 
27e1			; | |    1 - Initial screen 
27e1			; | |    2 - Display a data dump of HL 
27e1			; | |    3 - Display a data dump of DE 
27e1			; | |    4 - Display a data dump of BC 
27e1			; | |    5 - Display a data dump of HL 
27e1			; | |    6 - Display a data dump of DSP 
27e1			; | |    7 - Display a data dump of RSP 
27e1			; | |    8 - Display a data dump of what is at DSP 
27e1			; | |    9 - Display a data dump of what is at RSP 
27e1			; | |    0 - Exit monitor and continue running. This will also enable break points 
27e1			; | |    * - Disable break points 
27e1			; | |    # - Enter traditional monitor mode 
27e1			; | | 
27e1			; | | Monitor Mode 
27e1			; | | ------------ 
27e1			; | | A prompt of '>' will be shown for various commands: 
27e1			; | |    D xxxx - Display a data dump starting from hex address xxxx 
27e1			; | |    C - Continue display a data dump from the last set address 
27e1			; | |    M xxxx - Set start of memory edit at address xx 
27e1			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
27e1			; | |    Q - Return to previous 
27e1					if DEBUG_FORTH_WORDS_KEY 
27e1						DMARK "MON" 
27e1 f5				push af  
27e2 3a f6 27			ld a, (.dmark)  
27e5 32 71 ee			ld (debug_mark),a  
27e8 3a f7 27			ld a, (.dmark+1)  
27eb 32 72 ee			ld (debug_mark+1),a  
27ee 3a f8 27			ld a, (.dmark+2)  
27f1 32 73 ee			ld (debug_mark+2),a  
27f4 18 03			jr .pastdmark  
27f6 ..			.dmark: db "MON"  
27f9 f1			.pastdmark: pop af  
27fa			endm  
# End of macro DMARK
27fa						CALLMONITOR 
27fa cd 76 15			call break_point_state  
27fd				endm  
# End of macro CALLMONITOR
27fd					endif 
27fd 3e 00				ld a, 0 
27ff 32 f3 e2				ld (os_view_disable), a 
2802			 
2802					CALLMONITOR 
2802 cd 76 15			call break_point_state  
2805				endm  
# End of macro CALLMONITOR
2805			 
2805			;	call monitor 
2805			 
2805					NEXTW 
2805 c3 55 1f			jp macro_next 
2808				endm 
# End of macro NEXTW
2808			 
2808			 
2808			.MALLOC: 
2808				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2808 56				db WORD_SYS_CORE+66             
2809 31 28			dw .MALLOC2            
280b 06				db 5 + 1 
280c .. 00			db "ALLOT",0              
2812				endm 
# End of macro CWHEAD
2812			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2812					if DEBUG_FORTH_WORDS_KEY 
2812						DMARK "ALL" 
2812 f5				push af  
2813 3a 27 28			ld a, (.dmark)  
2816 32 71 ee			ld (debug_mark),a  
2819 3a 28 28			ld a, (.dmark+1)  
281c 32 72 ee			ld (debug_mark+1),a  
281f 3a 29 28			ld a, (.dmark+2)  
2822 32 73 ee			ld (debug_mark+2),a  
2825 18 03			jr .pastdmark  
2827 ..			.dmark: db "ALL"  
282a f1			.pastdmark: pop af  
282b			endm  
# End of macro DMARK
282b						CALLMONITOR 
282b cd 76 15			call break_point_state  
282e				endm  
# End of macro CALLMONITOR
282e					endif 
282e c3 58 28				jp .mallocc 
2831			.MALLOC2: 
2831				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2831 56				db WORD_SYS_CORE+66             
2832 6f 28			dw .FREE            
2834 07				db 6 + 1 
2835 .. 00			db "MALLOC",0              
283c				endm 
# End of macro CWHEAD
283c			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
283c					; get byte count 
283c					if DEBUG_FORTH_WORDS_KEY 
283c						DMARK "MAL" 
283c f5				push af  
283d 3a 51 28			ld a, (.dmark)  
2840 32 71 ee			ld (debug_mark),a  
2843 3a 52 28			ld a, (.dmark+1)  
2846 32 72 ee			ld (debug_mark+1),a  
2849 3a 53 28			ld a, (.dmark+2)  
284c 32 73 ee			ld (debug_mark+2),a  
284f 18 03			jr .pastdmark  
2851 ..			.dmark: db "MAL"  
2854 f1			.pastdmark: pop af  
2855			endm  
# End of macro DMARK
2855						CALLMONITOR 
2855 cd 76 15			call break_point_state  
2858				endm  
# End of macro CALLMONITOR
2858					endif 
2858			.mallocc: 
2858					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2858 cd de 1d			call macro_dsp_valuehl 
285b				endm 
# End of macro FORTH_DSP_VALUEHL
285b			 
285b			;		push hl 
285b			 
285b					; destroy value TOS 
285b			 
285b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
285b cd 96 1e			call macro_forth_dsp_pop 
285e				endm 
# End of macro FORTH_DSP_POP
285e			 
285e			;		pop hl 
285e cd 3c 12				call malloc 
2861				if DEBUG_FORTH_MALLOC_GUARD 
2861 f5					push af 
2862 cd 9e 0d				call ishlzero 
2865			;		ld a, l 
2865			;		add h 
2865			;		cp 0 
2865 f1					pop af 
2866					 
2866 cc bc 47				call z,malloc_error 
2869				endif 
2869			 
2869 cd e7 1b				call forth_push_numhl 
286c					NEXTW 
286c c3 55 1f			jp macro_next 
286f				endm 
# End of macro NEXTW
286f			 
286f			.FREE: 
286f				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
286f 57				db WORD_SYS_CORE+67             
2870 a0 28			dw .LIST            
2872 05				db 4 + 1 
2873 .. 00			db "FREE",0              
2878				endm 
# End of macro CWHEAD
2878			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2878					if DEBUG_FORTH_WORDS_KEY 
2878						DMARK "FRE" 
2878 f5				push af  
2879 3a 8d 28			ld a, (.dmark)  
287c 32 71 ee			ld (debug_mark),a  
287f 3a 8e 28			ld a, (.dmark+1)  
2882 32 72 ee			ld (debug_mark+1),a  
2885 3a 8f 28			ld a, (.dmark+2)  
2888 32 73 ee			ld (debug_mark+2),a  
288b 18 03			jr .pastdmark  
288d ..			.dmark: db "FRE"  
2890 f1			.pastdmark: pop af  
2891			endm  
# End of macro DMARK
2891						CALLMONITOR 
2891 cd 76 15			call break_point_state  
2894				endm  
# End of macro CALLMONITOR
2894					endif 
2894					; get address 
2894			 
2894					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2894 cd de 1d			call macro_dsp_valuehl 
2897				endm 
# End of macro FORTH_DSP_VALUEHL
2897			 
2897			;		push hl 
2897			 
2897					; destroy value TOS 
2897			 
2897					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2897 cd 96 1e			call macro_forth_dsp_pop 
289a				endm 
# End of macro FORTH_DSP_POP
289a			 
289a			;		pop hl 
289a			if FORTH_ENABLE_MALLOCFREE 
289a cd 06 13				call free 
289d			endif 
289d					NEXTW 
289d c3 55 1f			jp macro_next 
28a0				endm 
# End of macro NEXTW
28a0			.LIST: 
28a0				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
28a0 5c				db WORD_SYS_CORE+72             
28a1 8e 2a			dw .FORGET            
28a3 05				db 4 + 1 
28a4 .. 00			db "LIST",0              
28a9				endm 
# End of macro CWHEAD
28a9			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
28a9			; | | The quoted word must be in upper case. 
28a9				if DEBUG_FORTH_WORDS_KEY 
28a9					DMARK "LST" 
28a9 f5				push af  
28aa 3a be 28			ld a, (.dmark)  
28ad 32 71 ee			ld (debug_mark),a  
28b0 3a bf 28			ld a, (.dmark+1)  
28b3 32 72 ee			ld (debug_mark+1),a  
28b6 3a c0 28			ld a, (.dmark+2)  
28b9 32 73 ee			ld (debug_mark+2),a  
28bc 18 03			jr .pastdmark  
28be ..			.dmark: db "LST"  
28c1 f1			.pastdmark: pop af  
28c2			endm  
# End of macro DMARK
28c2					CALLMONITOR 
28c2 cd 76 15			call break_point_state  
28c5				endm  
# End of macro CALLMONITOR
28c5				endif 
28c5			 
28c5					FORTH_DSP_VALUEHL 
28c5 cd de 1d			call macro_dsp_valuehl 
28c8				endm 
# End of macro FORTH_DSP_VALUEHL
28c8			 
28c8 e5					push hl 
28c9					FORTH_DSP_POP 
28c9 cd 96 1e			call macro_forth_dsp_pop 
28cc				endm 
# End of macro FORTH_DSP_POP
28cc c1					pop bc 
28cd			 
28cd			; Start format of scratch string 
28cd			 
28cd 21 02 e3				ld hl, scratch 
28d0			 
28d0 3e 3a				ld a, ':' 
28d2 77					ld (hl),a 
28d3 23					inc hl 
28d4 3e 20				ld a, ' ' 
28d6 77					ld (hl), a 
28d7			 
28d7					; Get ptr to the word we need to look up 
28d7			 
28d7			;		FORTH_DSP_VALUEHL 
28d7					;v5 FORTH_DSP_VALUE 
28d7				; TODO type check 
28d7			;		inc hl    ; Skip type check  
28d7			;		push hl 
28d7			;		ex de, hl    ; put into DE 
28d7			 
28d7			 
28d7 21 b6 5b				ld hl, baseram 
28da					;ld hl, baseusermem 
28da			 
28da e5			push hl   ; sacreifical push 
28db			 
28db			.ldouscanm: 
28db e1				pop hl 
28dc			.ldouscan: 
28dc				if DEBUG_FORTH_WORDS 
28dc					DMARK "LSs" 
28dc f5				push af  
28dd 3a f1 28			ld a, (.dmark)  
28e0 32 71 ee			ld (debug_mark),a  
28e3 3a f2 28			ld a, (.dmark+1)  
28e6 32 72 ee			ld (debug_mark+1),a  
28e9 3a f3 28			ld a, (.dmark+2)  
28ec 32 73 ee			ld (debug_mark+2),a  
28ef 18 03			jr .pastdmark  
28f1 ..			.dmark: db "LSs"  
28f4 f1			.pastdmark: pop af  
28f5			endm  
# End of macro DMARK
28f5					CALLMONITOR 
28f5 cd 76 15			call break_point_state  
28f8				endm  
# End of macro CALLMONITOR
28f8				endif 
28f8				; skip dict stub 
28f8 cd a6 20				call forth_tok_next 
28fb			 
28fb			 
28fb			; while we have words to look for 
28fb			 
28fb 7e				ld a, (hl)      
28fc				if DEBUG_FORTH_WORDS 
28fc					DMARK "LSk" 
28fc f5				push af  
28fd 3a 11 29			ld a, (.dmark)  
2900 32 71 ee			ld (debug_mark),a  
2903 3a 12 29			ld a, (.dmark+1)  
2906 32 72 ee			ld (debug_mark+1),a  
2909 3a 13 29			ld a, (.dmark+2)  
290c 32 73 ee			ld (debug_mark+2),a  
290f 18 03			jr .pastdmark  
2911 ..			.dmark: db "LSk"  
2914 f1			.pastdmark: pop af  
2915			endm  
# End of macro DMARK
2915					CALLMONITOR 
2915 cd 76 15			call break_point_state  
2918				endm  
# End of macro CALLMONITOR
2918				endif 
2918					;cp WORD_SYS_END 
2918					;jp z, .lunotfound 
2918			 
2918					; if we hit non uwords then gone too far 
2918 fe 01				cp WORD_SYS_UWORD 
291a c2 4a 2a				jp nz, .lunotfound 
291d			 
291d				if DEBUG_FORTH_WORDS 
291d					DMARK "LSu" 
291d f5				push af  
291e 3a 32 29			ld a, (.dmark)  
2921 32 71 ee			ld (debug_mark),a  
2924 3a 33 29			ld a, (.dmark+1)  
2927 32 72 ee			ld (debug_mark+1),a  
292a 3a 34 29			ld a, (.dmark+2)  
292d 32 73 ee			ld (debug_mark+2),a  
2930 18 03			jr .pastdmark  
2932 ..			.dmark: db "LSu"  
2935 f1			.pastdmark: pop af  
2936			endm  
# End of macro DMARK
2936					CALLMONITOR 
2936 cd 76 15			call break_point_state  
2939				endm  
# End of macro CALLMONITOR
2939				endif 
2939			 
2939					; found a uword but is it the one we want... 
2939			 
2939 c5					push bc     ; uword to find is on bc 
293a d1					pop de 
293b			 
293b e5					push hl  ; to save the ptr 
293c			 
293c					; skip opcode 
293c 23					inc hl  
293d					; skip next ptr 
293d 23					inc hl  
293e 23					inc hl 
293f					; skip len 
293f 23					inc hl 
2940			 
2940				if DEBUG_FORTH_WORDS 
2940					DMARK "LSc" 
2940 f5				push af  
2941 3a 55 29			ld a, (.dmark)  
2944 32 71 ee			ld (debug_mark),a  
2947 3a 56 29			ld a, (.dmark+1)  
294a 32 72 ee			ld (debug_mark+1),a  
294d 3a 57 29			ld a, (.dmark+2)  
2950 32 73 ee			ld (debug_mark+2),a  
2953 18 03			jr .pastdmark  
2955 ..			.dmark: db "LSc"  
2958 f1			.pastdmark: pop af  
2959			endm  
# End of macro DMARK
2959					CALLMONITOR 
2959 cd 76 15			call break_point_state  
295c				endm  
# End of macro CALLMONITOR
295c				endif 
295c cd 0b 12				call strcmp 
295f c2 db 28				jp nz, .ldouscanm 
2962				 
2962			 
2962			 
2962					; we have a uword so push its name to the stack 
2962			 
2962			;	   	push hl  ; save so we can move to next dict block 
2962 e1			pop hl 
2963			 
2963				if DEBUG_FORTH_WORDS 
2963					DMARK "LSm" 
2963 f5				push af  
2964 3a 78 29			ld a, (.dmark)  
2967 32 71 ee			ld (debug_mark),a  
296a 3a 79 29			ld a, (.dmark+1)  
296d 32 72 ee			ld (debug_mark+1),a  
2970 3a 7a 29			ld a, (.dmark+2)  
2973 32 73 ee			ld (debug_mark+2),a  
2976 18 03			jr .pastdmark  
2978 ..			.dmark: db "LSm"  
297b f1			.pastdmark: pop af  
297c			endm  
# End of macro DMARK
297c					CALLMONITOR 
297c cd 76 15			call break_point_state  
297f				endm  
# End of macro CALLMONITOR
297f				endif 
297f			 
297f					; skip opcode 
297f 23					inc hl  
2980					; skip next ptr 
2980 23					inc hl  
2981 23					inc hl 
2982					; skip len 
2982 7e					ld a, (hl)   ; save length to add 
2983				if DEBUG_FORTH_WORDS 
2983					DMARK "LS2" 
2983 f5				push af  
2984 3a 98 29			ld a, (.dmark)  
2987 32 71 ee			ld (debug_mark),a  
298a 3a 99 29			ld a, (.dmark+1)  
298d 32 72 ee			ld (debug_mark+1),a  
2990 3a 9a 29			ld a, (.dmark+2)  
2993 32 73 ee			ld (debug_mark+2),a  
2996 18 03			jr .pastdmark  
2998 ..			.dmark: db "LS2"  
299b f1			.pastdmark: pop af  
299c			endm  
# End of macro DMARK
299c					CALLMONITOR 
299c cd 76 15			call break_point_state  
299f				endm  
# End of macro CALLMONITOR
299f				endif 
299f			 
299f					; save this location 
299f				 
299f e5					push hl 
29a0			 
29a0 23					inc hl 
29a1 11 04 e3				ld de, scratch+2 
29a4 4f					ld c, a 
29a5 06 00				ld b, 0 
29a7			 
29a7				if DEBUG_FORTH_WORDS 
29a7					DMARK "LSn" 
29a7 f5				push af  
29a8 3a bc 29			ld a, (.dmark)  
29ab 32 71 ee			ld (debug_mark),a  
29ae 3a bd 29			ld a, (.dmark+1)  
29b1 32 72 ee			ld (debug_mark+1),a  
29b4 3a be 29			ld a, (.dmark+2)  
29b7 32 73 ee			ld (debug_mark+2),a  
29ba 18 03			jr .pastdmark  
29bc ..			.dmark: db "LSn"  
29bf f1			.pastdmark: pop af  
29c0			endm  
# End of macro DMARK
29c0					CALLMONITOR 
29c0 cd 76 15			call break_point_state  
29c3				endm  
# End of macro CALLMONITOR
29c3				endif 
29c3			 
29c3					; copy uword name to scratch 
29c3			 
29c3 ed b0				ldir 
29c5			 
29c5 1b					dec de 
29c6 3e 20				ld a, ' '    ; change null to space 
29c8 12					ld (de), a 
29c9			 
29c9 13					inc de 
29ca			 
29ca d5					push de 
29cb c1					pop bc     ; move scratch pointer to end of word name and save it 
29cc			 
29cc e1					pop hl 
29cd 7e					ld a, (hl) 
29ce					;inc hl 
29ce					; skip word string 
29ce cd 75 0d				call addatohl 
29d1			 
29d1 23					inc hl 
29d2			 
29d2				if DEBUG_FORTH_WORDS 
29d2					DMARK "LS3" 
29d2 f5				push af  
29d3 3a e7 29			ld a, (.dmark)  
29d6 32 71 ee			ld (debug_mark),a  
29d9 3a e8 29			ld a, (.dmark+1)  
29dc 32 72 ee			ld (debug_mark+1),a  
29df 3a e9 29			ld a, (.dmark+2)  
29e2 32 73 ee			ld (debug_mark+2),a  
29e5 18 03			jr .pastdmark  
29e7 ..			.dmark: db "LS3"  
29ea f1			.pastdmark: pop af  
29eb			endm  
# End of macro DMARK
29eb					CALLMONITOR 
29eb cd 76 15			call break_point_state  
29ee				endm  
# End of macro CALLMONITOR
29ee				endif 
29ee					; should now be at the start of the machine code to setup the eval of the uword 
29ee					; now locate the ptr to the string defintion 
29ee			 
29ee					; skip ld hl, 
29ee					; then load the ptr 
29ee			; TODO use get from hl ptr 
29ee 23					inc hl 
29ef 5e					ld e, (hl) 
29f0 23					inc hl 
29f1 56					ld d, (hl) 
29f2 eb					ex de, hl 
29f3			 
29f3			 
29f3				if DEBUG_FORTH_WORDS 
29f3					DMARK "LSt" 
29f3 f5				push af  
29f4 3a 08 2a			ld a, (.dmark)  
29f7 32 71 ee			ld (debug_mark),a  
29fa 3a 09 2a			ld a, (.dmark+1)  
29fd 32 72 ee			ld (debug_mark+1),a  
2a00 3a 0a 2a			ld a, (.dmark+2)  
2a03 32 73 ee			ld (debug_mark+2),a  
2a06 18 03			jr .pastdmark  
2a08 ..			.dmark: db "LSt"  
2a0b f1			.pastdmark: pop af  
2a0c			endm  
# End of macro DMARK
2a0c					CALLMONITOR 
2a0c cd 76 15			call break_point_state  
2a0f				endm  
# End of macro CALLMONITOR
2a0f				endif 
2a0f			 
2a0f			; cant push right now due to tokenised strings  
2a0f			 
2a0f			; get the destination of where to copy this definition to. 
2a0f			 
2a0f c5					push bc 
2a10 d1					pop de 
2a11			 
2a11 7e			.listl:         ld a,(hl) 
2a12 fe 00				cp 0 
2a14 28 09				jr z, .lreplsp     ; replace zero with space 
2a16					;cp FORTH_END_BUFFER 
2a16 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2a18 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2a1a				 
2a1a					; just copy this char as is then 
2a1a			 
2a1a 12					ld (de), a 
2a1b			 
2a1b 23			.listnxt:	inc hl 
2a1c 13					inc de 
2a1d 18 f2				jr .listl 
2a1f			 
2a1f 3e 20		.lreplsp:	ld a,' ' 
2a21 12					ld (de), a 
2a22 18 f7				jr .listnxt 
2a24			 
2a24			; close up uword def 
2a24			 
2a24			.listdone: 
2a24 12					ld (de), a 
2a25 13					inc de 
2a26 3e 00				ld a, 0 
2a28 12					ld (de), a 
2a29			 
2a29			; now have def so clean up and push to stack 
2a29			 
2a29 21 02 e3				ld hl, scratch 
2a2c				if DEBUG_FORTH_WORDS 
2a2c					DMARK "Ltp" 
2a2c f5				push af  
2a2d 3a 41 2a			ld a, (.dmark)  
2a30 32 71 ee			ld (debug_mark),a  
2a33 3a 42 2a			ld a, (.dmark+1)  
2a36 32 72 ee			ld (debug_mark+1),a  
2a39 3a 43 2a			ld a, (.dmark+2)  
2a3c 32 73 ee			ld (debug_mark+2),a  
2a3f 18 03			jr .pastdmark  
2a41 ..			.dmark: db "Ltp"  
2a44 f1			.pastdmark: pop af  
2a45			endm  
# End of macro DMARK
2a45					CALLMONITOR 
2a45 cd 76 15			call break_point_state  
2a48				endm  
# End of macro CALLMONITOR
2a48				endif 
2a48			 
2a48 18 1f			jr .listpush 
2a4a			 
2a4a			;.lnuword:	pop hl 
2a4a			;		call forth_tok_next 
2a4a			;		jp .ldouscan  
2a4a			 
2a4a			.lunotfound:		  
2a4a			 
2a4a				if DEBUG_FORTH_WORDS 
2a4a					DMARK "LSn" 
2a4a f5				push af  
2a4b 3a 5f 2a			ld a, (.dmark)  
2a4e 32 71 ee			ld (debug_mark),a  
2a51 3a 60 2a			ld a, (.dmark+1)  
2a54 32 72 ee			ld (debug_mark+1),a  
2a57 3a 61 2a			ld a, (.dmark+2)  
2a5a 32 73 ee			ld (debug_mark+2),a  
2a5d 18 03			jr .pastdmark  
2a5f ..			.dmark: db "LSn"  
2a62 f1			.pastdmark: pop af  
2a63			endm  
# End of macro DMARK
2a63					CALLMONITOR 
2a63 cd 76 15			call break_point_state  
2a66				endm  
# End of macro CALLMONITOR
2a66				endif 
2a66			 
2a66					 
2a66			;		FORTH_DSP_POP 
2a66			;		ld hl, .luno 
2a66			 
2a66					NEXTW			 
2a66 c3 55 1f			jp macro_next 
2a69				endm 
# End of macro NEXTW
2a69			 
2a69			.listpush: 
2a69				if DEBUG_FORTH_WORDS 
2a69					DMARK "LS>" 
2a69 f5				push af  
2a6a 3a 7e 2a			ld a, (.dmark)  
2a6d 32 71 ee			ld (debug_mark),a  
2a70 3a 7f 2a			ld a, (.dmark+1)  
2a73 32 72 ee			ld (debug_mark+1),a  
2a76 3a 80 2a			ld a, (.dmark+2)  
2a79 32 73 ee			ld (debug_mark+2),a  
2a7c 18 03			jr .pastdmark  
2a7e ..			.dmark: db "LS>"  
2a81 f1			.pastdmark: pop af  
2a82			endm  
# End of macro DMARK
2a82					CALLMONITOR 
2a82 cd 76 15			call break_point_state  
2a85				endm  
# End of macro CALLMONITOR
2a85				endif 
2a85 cd 55 1c				call forth_push_str 
2a88			 
2a88			 
2a88			 
2a88					NEXTW 
2a88 c3 55 1f			jp macro_next 
2a8b				endm 
# End of macro NEXTW
2a8b			 
2a8b			;.luno:    db "Word not found",0 
2a8b			 
2a8b			 
2a8b			 
2a8b			 
2a8b			 
2a8b			;		push hl   ; save pointer to start of uword def string 
2a8b			; 
2a8b			;; look for FORTH_EOL_LINE 
2a8b			;		ld a, FORTH_END_BUFFER 
2a8b			;		call strlent 
2a8b			; 
2a8b			;		inc hl		 ; space for coln def 
2a8b			;		inc hl 
2a8b			;		inc hl          ; space for terms 
2a8b			;		inc hl 
2a8b			; 
2a8b			;		ld a, 20   ; TODO get actual length 
2a8b			;		call addatohl    ; include a random amount of room for the uword name 
2a8b			; 
2a8b			;		 
2a8b			;	if DEBUG_FORTH_WORDS 
2a8b			;		DMARK "Lt1" 
2a8b			;		CALLMONITOR 
2a8b			;	endif 
2a8b			;		 
2a8b			; 
2a8b			;; malloc space for the string because we cant change it 
2a8b			; 
2a8b			;		call malloc 
2a8b			;	if DEBUG_FORTH_MALLOC_GUARD 
2a8b			;		push af 
2a8b			;		call ishlzero 
2a8b			;		pop af 
2a8b			;		 
2a8b			;		call z,malloc_error 
2a8b			;	endif 
2a8b			; 
2a8b			;	if DEBUG_FORTH_WORDS 
2a8b			;		DMARK "Lt2" 
2a8b			;		CALLMONITOR 
2a8b			;	endif 
2a8b			;		pop de 
2a8b			;		push hl    ; push the malloc to release later 
2a8b			;		push hl   ;  push back a copy for the later stack push 
2a8b			;		 
2a8b			;; copy the string swapping out the zero terms for spaces 
2a8b			; 
2a8b			;		; de has our source 
2a8b			;		; hl has our dest 
2a8b			; 
2a8b			;; add the coln def 
2a8b			; 
2a8b			;		ld a, ':' 
2a8b			;		ld (hl), a 
2a8b			;		inc hl 
2a8b			;		ld a, ' ' 
2a8b			;		ld (hl), a 
2a8b			;		inc hl 
2a8b			; 
2a8b			;; add the uname word 
2a8b			;		push de   ; save our string for now 
2a8b			;		ex de, hl 
2a8b			; 
2a8b			;		FORTH_DSP_VALUE 
2a8b			;		;v5 FORTH_DSP_VALUE 
2a8b			; 
2a8b			;		inc hl   ; skip type but we know by now this is OK 
2a8b			; 
2a8b			;.luword:	ld a,(hl) 
2a8b			;		cp 0 
2a8b			;		jr z, .luword2 
2a8b			;		ld (de), a 
2a8b			;		inc de 
2a8b			;		inc hl 
2a8b			;		jr .luword 
2a8b			; 
2a8b			;.luword2:	ld a, ' ' 
2a8b			;		ld (de), a 
2a8b			;;		inc hl 
2a8b			;;		inc de 
2a8b			;;		ld (de), a 
2a8b			;;		inc hl 
2a8b			;		inc de 
2a8b			; 
2a8b			;		ex de, hl 
2a8b			;		pop de 
2a8b			;		 
2a8b			;		 
2a8b			; 
2a8b			;; detoken that string and copy it 
2a8b			; 
2a8b			;	if DEBUG_FORTH_WORDS 
2a8b			;		DMARK "Lt2" 
2a8b			;		CALLMONITOR 
2a8b			;	endif 
2a8b			;.ldetok:	ld a, (de) 
2a8b			;		cp FORTH_END_BUFFER 
2a8b			;		jr z, .ldetokend 
2a8b			;		; swap out any zero term for space 
2a8b			;		cp 0 
2a8b			;		jr nz, .ldetoknext 
2a8b			;		ld a, ' ' 
2a8b			; 
2a8b			;	if DEBUG_FORTH_WORDS 
2a8b			;		DMARK "LtS" 
2a8b			;		CALLMONITOR 
2a8b			;	endif 
2a8b			;.ldetoknext:	ld (hl), a 
2a8b			;		inc de 
2a8b			;		inc hl 
2a8b			;		jr .ldetok 
2a8b			; 
2a8b			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2a8b			;		ld (hl), a  
2a8b			; 
2a8b			;; free that temp malloc 
2a8b			; 
2a8b			;		pop hl    
2a8b			; 
2a8b			;	if DEBUG_FORTH_WORDS 
2a8b			;		DMARK "Lt4" 
2a8b			;		CALLMONITOR 
2a8b			;	endif 
2a8b			;		call forth_apushstrhl 
2a8b			; 
2a8b			;		; get rid of temp malloc area 
2a8b			; 
2a8b			;		pop hl 
2a8b			;		call free 
2a8b			; 
2a8b			;		jr .ludone 
2a8b			; 
2a8b			;.lnuword:	pop hl 
2a8b			;		call forth_tok_next 
2a8b			;		jp .ldouscan  
2a8b			; 
2a8b			;.ludone:		 pop hl 
2a8b			; 
2a8b					NEXTW 
2a8b c3 55 1f			jp macro_next 
2a8e				endm 
# End of macro NEXTW
2a8e			 
2a8e			.FORGET: 
2a8e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2a8e 5d				db WORD_SYS_CORE+73             
2a8f 07 2b			dw .NOP            
2a91 07				db 6 + 1 
2a92 .. 00			db "FORGET",0              
2a99				endm 
# End of macro CWHEAD
2a99			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2a99			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2a99			; | |  
2a99			; | | e.g. "MORE" forget 
2a99					if DEBUG_FORTH_WORDS_KEY 
2a99						DMARK "FRG" 
2a99 f5				push af  
2a9a 3a ae 2a			ld a, (.dmark)  
2a9d 32 71 ee			ld (debug_mark),a  
2aa0 3a af 2a			ld a, (.dmark+1)  
2aa3 32 72 ee			ld (debug_mark+1),a  
2aa6 3a b0 2a			ld a, (.dmark+2)  
2aa9 32 73 ee			ld (debug_mark+2),a  
2aac 18 03			jr .pastdmark  
2aae ..			.dmark: db "FRG"  
2ab1 f1			.pastdmark: pop af  
2ab2			endm  
# End of macro DMARK
2ab2						CALLMONITOR 
2ab2 cd 76 15			call break_point_state  
2ab5				endm  
# End of macro CALLMONITOR
2ab5					endif 
2ab5			 
2ab5				; find uword 
2ab5			        ; update start of word with "_" 
2ab5				; replace uword with deleted flag 
2ab5			 
2ab5			 
2ab5			;	if DEBUG_FORTH_WORDS 
2ab5			;		DMARK "FOG" 
2ab5			;		CALLMONITOR 
2ab5			;	endif 
2ab5			 
2ab5			 
2ab5					; Get ptr to the word we need to look up 
2ab5			 
2ab5					FORTH_DSP_VALUEHL 
2ab5 cd de 1d			call macro_dsp_valuehl 
2ab8				endm 
# End of macro FORTH_DSP_VALUEHL
2ab8					;v5 FORTH_DSP_VALUE 
2ab8				; TODO type check 
2ab8			;		inc hl    ; Skip type check  
2ab8 e5					push hl 
2ab9 c1					pop bc 
2aba			;		ex de, hl    ; put into DE 
2aba			 
2aba			 
2aba 21 b6 5b				ld hl, baseram 
2abd					;ld hl, baseusermem 
2abd			 
2abd				; skip dict stub 
2abd			;	call forth_tok_next 
2abd e5			push hl   ; sacreifical push 
2abe			 
2abe			.fldouscanm: 
2abe e1				pop hl 
2abf			.fldouscan: 
2abf			;	if DEBUG_FORTH_WORDS 
2abf			;		DMARK "LSs" 
2abf			;		CALLMONITOR 
2abf			;	endif 
2abf				; skip dict stub 
2abf cd a6 20				call forth_tok_next 
2ac2			 
2ac2			 
2ac2			; while we have words to look for 
2ac2			 
2ac2 7e				ld a, (hl)      
2ac3			;	if DEBUG_FORTH_WORDS 
2ac3			;		DMARK "LSk" 
2ac3			;		CALLMONITOR 
2ac3			;	endif 
2ac3 fe 00				cp WORD_SYS_END 
2ac5 ca 01 2b				jp z, .flunotfound 
2ac8 fe 01				cp WORD_SYS_UWORD 
2aca c2 bf 2a				jp nz, .fldouscan 
2acd			 
2acd			;	if DEBUG_FORTH_WORDS 
2acd			;		DMARK "LSu" 
2acd			;		CALLMONITOR 
2acd			;	endif 
2acd			 
2acd					; found a uword but is it the one we want... 
2acd			 
2acd c5					push bc     ; uword to find is on bc 
2ace d1					pop de 
2acf			 
2acf e5					push hl  ; to save the ptr 
2ad0			 
2ad0					; skip opcode 
2ad0 23					inc hl  
2ad1					; skip next ptr 
2ad1 23					inc hl  
2ad2 23					inc hl 
2ad3					; skip len 
2ad3 23					inc hl 
2ad4			 
2ad4			;	if DEBUG_FORTH_WORDS 
2ad4			;		DMARK "LSc" 
2ad4			;		CALLMONITOR 
2ad4			;	endif 
2ad4 cd 0b 12				call strcmp 
2ad7 c2 be 2a				jp nz, .fldouscanm 
2ada			; 
2ada			; 
2ada			;; while we have words to look for 
2ada			; 
2ada			;.fdouscan:	ld a, (hl)      
2ada			;	if DEBUG_FORTH_WORDS 
2ada			;		DMARK "LSs" 
2ada			;		CALLMONITOR 
2ada			;	endif 
2ada			;		cp WORD_SYS_END 
2ada			;		jp z, .fudone 
2ada			;		cp WORD_SYS_UWORD 
2ada			;		jp nz, .fnuword 
2ada			; 
2ada			;	if DEBUG_FORTH_WORDS 
2ada			;		DMARK "FGu" 
2ada			;		CALLMONITOR 
2ada			;	endif 
2ada			; 
2ada			;		; found a uword but is it the one we want... 
2ada			; 
2ada			; 
2ada			;	        pop de   ; get back the dsp name 
2ada			;		push de 
2ada			; 
2ada			;		push hl  ; to save the ptr 
2ada			; 
2ada			;		; skip opcode 
2ada			;		inc hl  
2ada			;		; skip next ptr 
2ada			;		inc hl  
2ada			;		inc hl 
2ada			;		; skip len 
2ada			;		inc hl 
2ada			; 
2ada			;	if DEBUG_FORTH_WORDS 
2ada			;		DMARK "FGc" 
2ada			;		CALLMONITOR 
2ada			;	endif 
2ada			;		call strcmp 
2ada			;		jp nz, .fnuword 
2ada			 
2ada			 
2ada e1			pop hl 
2adb			 
2adb				 
2adb				if DEBUG_FORTH_WORDS 
2adb					DMARK "FGm" 
2adb f5				push af  
2adc 3a f0 2a			ld a, (.dmark)  
2adf 32 71 ee			ld (debug_mark),a  
2ae2 3a f1 2a			ld a, (.dmark+1)  
2ae5 32 72 ee			ld (debug_mark+1),a  
2ae8 3a f2 2a			ld a, (.dmark+2)  
2aeb 32 73 ee			ld (debug_mark+2),a  
2aee 18 03			jr .pastdmark  
2af0 ..			.dmark: db "FGm"  
2af3 f1			.pastdmark: pop af  
2af4			endm  
# End of macro DMARK
2af4					CALLMONITOR 
2af4 cd 76 15			call break_point_state  
2af7				endm  
# End of macro CALLMONITOR
2af7				endif 
2af7			 
2af7			 
2af7			 
2af7					; we have a uword so push its name to the stack 
2af7			 
2af7			;	   	push hl  ; save so we can move to next dict block 
2af7			;pop hl 
2af7			 
2af7					; update opcode to deleted 
2af7 3e 03				ld a, WORD_SYS_DELETED 
2af9 77					ld (hl), a 
2afa			 
2afa 23					inc hl  
2afb					; skip next ptr 
2afb 23					inc hl  
2afc 23					inc hl 
2afd					; skip len 
2afd 23					inc hl 
2afe			 
2afe					; TODO change parser to skip deleted words but for now mark it out 
2afe 3e 5f				ld a, "_" 
2b00 77					ld  (hl),a 
2b01			 
2b01			;		jr .fudone 
2b01			; 
2b01			;.fnuword:	pop hl 
2b01			;		call forth_tok_next 
2b01			;		jp .fdouscan  
2b01			 
2b01			.flunotfound:		  
2b01			 
2b01			 
2b01					 
2b01					FORTH_DSP_POP 
2b01 cd 96 1e			call macro_forth_dsp_pop 
2b04				endm 
# End of macro FORTH_DSP_POP
2b04			;		ld hl, .luno 
2b04			;.fudone:		 pop hl 
2b04					NEXTW 
2b04 c3 55 1f			jp macro_next 
2b07				endm 
# End of macro NEXTW
2b07			.NOP: 
2b07				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2b07 61				db WORD_SYS_CORE+77             
2b08 2e 2b			dw .COMO            
2b0a 04				db 3 + 1 
2b0b .. 00			db "NOP",0              
2b0f				endm 
# End of macro CWHEAD
2b0f			; | NOP (  --  ) Do nothing | DONE 
2b0f					if DEBUG_FORTH_WORDS_KEY 
2b0f						DMARK "NOP" 
2b0f f5				push af  
2b10 3a 24 2b			ld a, (.dmark)  
2b13 32 71 ee			ld (debug_mark),a  
2b16 3a 25 2b			ld a, (.dmark+1)  
2b19 32 72 ee			ld (debug_mark+1),a  
2b1c 3a 26 2b			ld a, (.dmark+2)  
2b1f 32 73 ee			ld (debug_mark+2),a  
2b22 18 03			jr .pastdmark  
2b24 ..			.dmark: db "NOP"  
2b27 f1			.pastdmark: pop af  
2b28			endm  
# End of macro DMARK
2b28						CALLMONITOR 
2b28 cd 76 15			call break_point_state  
2b2b				endm  
# End of macro CALLMONITOR
2b2b					endif 
2b2b				       NEXTW 
2b2b c3 55 1f			jp macro_next 
2b2e				endm 
# End of macro NEXTW
2b2e			.COMO: 
2b2e				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2b2e 6e				db WORD_SYS_CORE+90             
2b2f 80 2b			dw .COMC            
2b31 02				db 1 + 1 
2b32 .. 00			db "(",0              
2b34				endm 
# End of macro CWHEAD
2b34			; | ( ( -- )  Start of comment | DONE 
2b34			 
2b34			 
2b34 2a 03 e6				ld hl, ( os_tok_ptr) 
2b37 11 7b 2b			ld de, .closepar 
2b3a					 
2b3a					if DEBUG_FORTH_WORDS 
2b3a						DMARK ").." 
2b3a f5				push af  
2b3b 3a 4f 2b			ld a, (.dmark)  
2b3e 32 71 ee			ld (debug_mark),a  
2b41 3a 50 2b			ld a, (.dmark+1)  
2b44 32 72 ee			ld (debug_mark+1),a  
2b47 3a 51 2b			ld a, (.dmark+2)  
2b4a 32 73 ee			ld (debug_mark+2),a  
2b4d 18 03			jr .pastdmark  
2b4f ..			.dmark: db ").."  
2b52 f1			.pastdmark: pop af  
2b53			endm  
# End of macro DMARK
2b53						CALLMONITOR 
2b53 cd 76 15			call break_point_state  
2b56				endm  
# End of macro CALLMONITOR
2b56					endif 
2b56 cd 70 20			call findnexttok  
2b59			 
2b59					if DEBUG_FORTH_WORDS 
2b59						DMARK "IF5" 
2b59 f5				push af  
2b5a 3a 6e 2b			ld a, (.dmark)  
2b5d 32 71 ee			ld (debug_mark),a  
2b60 3a 6f 2b			ld a, (.dmark+1)  
2b63 32 72 ee			ld (debug_mark+1),a  
2b66 3a 70 2b			ld a, (.dmark+2)  
2b69 32 73 ee			ld (debug_mark+2),a  
2b6c 18 03			jr .pastdmark  
2b6e ..			.dmark: db "IF5"  
2b71 f1			.pastdmark: pop af  
2b72			endm  
# End of macro DMARK
2b72						CALLMONITOR 
2b72 cd 76 15			call break_point_state  
2b75				endm  
# End of macro CALLMONITOR
2b75					endif 
2b75				; replace below with ) exec using tok_ptr 
2b75 22 03 e6			ld (os_tok_ptr), hl 
2b78 c3 e6 1f			jp exec1 
2b7b			 
2b7b .. 00			.closepar:   db ")",0 
2b7d			 
2b7d				       NEXTW 
2b7d c3 55 1f			jp macro_next 
2b80				endm 
# End of macro NEXTW
2b80			.COMC: 
2b80				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2b80 6f				db WORD_SYS_CORE+91             
2b81 89 2b			dw .SCRATCH            
2b83 02				db 1 + 1 
2b84 .. 00			db ")",0              
2b86				endm 
# End of macro CWHEAD
2b86			; | ) ( -- )  End of comment |  DONE  
2b86				       NEXTW 
2b86 c3 55 1f			jp macro_next 
2b89				endm 
# End of macro NEXTW
2b89			 
2b89			.SCRATCH: 
2b89				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2b89 6f				db WORD_SYS_CORE+91             
2b8a c4 2b			dw .INC            
2b8c 08				db 7 + 1 
2b8d .. 00			db "SCRATCH",0              
2b95				endm 
# End of macro CWHEAD
2b95			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2b95			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2b95			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2b95			; | |  
2b95			; | | e.g.    : score $00 scratch ; 
2b95			; | |  
2b95			; | | $00 score ! 
2b95			; | | $01 score +! 
2b95			; | |  
2b95			; | | e.g.   : varword $0a scratch ;  
2b95			; | | 
2b95			; | | $8000 varword ! 
2b95					if DEBUG_FORTH_WORDS_KEY 
2b95						DMARK "SCR" 
2b95 f5				push af  
2b96 3a aa 2b			ld a, (.dmark)  
2b99 32 71 ee			ld (debug_mark),a  
2b9c 3a ab 2b			ld a, (.dmark+1)  
2b9f 32 72 ee			ld (debug_mark+1),a  
2ba2 3a ac 2b			ld a, (.dmark+2)  
2ba5 32 73 ee			ld (debug_mark+2),a  
2ba8 18 03			jr .pastdmark  
2baa ..			.dmark: db "SCR"  
2bad f1			.pastdmark: pop af  
2bae			endm  
# End of macro DMARK
2bae						CALLMONITOR 
2bae cd 76 15			call break_point_state  
2bb1				endm  
# End of macro CALLMONITOR
2bb1					endif 
2bb1			 
2bb1					FORTH_DSP_VALUEHL 
2bb1 cd de 1d			call macro_dsp_valuehl 
2bb4				endm 
# End of macro FORTH_DSP_VALUEHL
2bb4				 
2bb4					FORTH_DSP_POP 
2bb4 cd 96 1e			call macro_forth_dsp_pop 
2bb7				endm 
# End of macro FORTH_DSP_POP
2bb7			 
2bb7 7d					ld a, l 
2bb8 21 27 e8				ld hl, os_var_array 
2bbb cd 75 0d				call addatohl 
2bbe			 
2bbe cd e7 1b				call forth_push_numhl 
2bc1			 
2bc1				       NEXTW 
2bc1 c3 55 1f			jp macro_next 
2bc4				endm 
# End of macro NEXTW
2bc4			 
2bc4			.INC: 
2bc4				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2bc4 6f				db WORD_SYS_CORE+91             
2bc5 18 2c			dw .DEC            
2bc7 03				db 2 + 1 
2bc8 .. 00			db "+!",0              
2bcb				endm 
# End of macro CWHEAD
2bcb			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2bcb					if DEBUG_FORTH_WORDS_KEY 
2bcb						DMARK "+s_" 
2bcb f5				push af  
2bcc 3a e0 2b			ld a, (.dmark)  
2bcf 32 71 ee			ld (debug_mark),a  
2bd2 3a e1 2b			ld a, (.dmark+1)  
2bd5 32 72 ee			ld (debug_mark+1),a  
2bd8 3a e2 2b			ld a, (.dmark+2)  
2bdb 32 73 ee			ld (debug_mark+2),a  
2bde 18 03			jr .pastdmark  
2be0 ..			.dmark: db "+s_"  
2be3 f1			.pastdmark: pop af  
2be4			endm  
# End of macro DMARK
2be4						CALLMONITOR 
2be4 cd 76 15			call break_point_state  
2be7				endm  
# End of macro CALLMONITOR
2be7					endif 
2be7			 
2be7					FORTH_DSP_VALUEHL 
2be7 cd de 1d			call macro_dsp_valuehl 
2bea				endm 
# End of macro FORTH_DSP_VALUEHL
2bea			 
2bea e5					push hl   ; save address 
2beb			 
2beb					FORTH_DSP_POP 
2beb cd 96 1e			call macro_forth_dsp_pop 
2bee				endm 
# End of macro FORTH_DSP_POP
2bee			 
2bee					FORTH_DSP_VALUEHL 
2bee cd de 1d			call macro_dsp_valuehl 
2bf1				endm 
# End of macro FORTH_DSP_VALUEHL
2bf1			 
2bf1					FORTH_DSP_POP 
2bf1 cd 96 1e			call macro_forth_dsp_pop 
2bf4				endm 
# End of macro FORTH_DSP_POP
2bf4			 
2bf4					; hl contains value to add to byte at a 
2bf4				 
2bf4 eb					ex de, hl 
2bf5			 
2bf5 e1					pop hl 
2bf6			 
2bf6					if DEBUG_FORTH_WORDS 
2bf6						DMARK "INC" 
2bf6 f5				push af  
2bf7 3a 0b 2c			ld a, (.dmark)  
2bfa 32 71 ee			ld (debug_mark),a  
2bfd 3a 0c 2c			ld a, (.dmark+1)  
2c00 32 72 ee			ld (debug_mark+1),a  
2c03 3a 0d 2c			ld a, (.dmark+2)  
2c06 32 73 ee			ld (debug_mark+2),a  
2c09 18 03			jr .pastdmark  
2c0b ..			.dmark: db "INC"  
2c0e f1			.pastdmark: pop af  
2c0f			endm  
# End of macro DMARK
2c0f						CALLMONITOR 
2c0f cd 76 15			call break_point_state  
2c12				endm  
# End of macro CALLMONITOR
2c12					endif 
2c12			 
2c12 7e					ld a,(hl) 
2c13 83					add e 
2c14 77					ld (hl),a 
2c15			 
2c15			 
2c15			 
2c15				       NEXTW 
2c15 c3 55 1f			jp macro_next 
2c18				endm 
# End of macro NEXTW
2c18			 
2c18			.DEC: 
2c18				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2c18 6f				db WORD_SYS_CORE+91             
2c19 69 2c			dw .INC2            
2c1b 03				db 2 + 1 
2c1c .. 00			db "-!",0              
2c1f				endm 
# End of macro CWHEAD
2c1f			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2c1f					if DEBUG_FORTH_WORDS_KEY 
2c1f						DMARK "-s_" 
2c1f f5				push af  
2c20 3a 34 2c			ld a, (.dmark)  
2c23 32 71 ee			ld (debug_mark),a  
2c26 3a 35 2c			ld a, (.dmark+1)  
2c29 32 72 ee			ld (debug_mark+1),a  
2c2c 3a 36 2c			ld a, (.dmark+2)  
2c2f 32 73 ee			ld (debug_mark+2),a  
2c32 18 03			jr .pastdmark  
2c34 ..			.dmark: db "-s_"  
2c37 f1			.pastdmark: pop af  
2c38			endm  
# End of macro DMARK
2c38						CALLMONITOR 
2c38 cd 76 15			call break_point_state  
2c3b				endm  
# End of macro CALLMONITOR
2c3b					endif 
2c3b			 
2c3b					FORTH_DSP_VALUEHL 
2c3b cd de 1d			call macro_dsp_valuehl 
2c3e				endm 
# End of macro FORTH_DSP_VALUEHL
2c3e			 
2c3e e5					push hl   ; save address 
2c3f			 
2c3f					FORTH_DSP_POP 
2c3f cd 96 1e			call macro_forth_dsp_pop 
2c42				endm 
# End of macro FORTH_DSP_POP
2c42			 
2c42					FORTH_DSP_VALUEHL 
2c42 cd de 1d			call macro_dsp_valuehl 
2c45				endm 
# End of macro FORTH_DSP_VALUEHL
2c45			 
2c45					; hl contains value to add to byte at a 
2c45				 
2c45 eb					ex de, hl 
2c46			 
2c46 e1					pop hl 
2c47			 
2c47					if DEBUG_FORTH_WORDS 
2c47						DMARK "DEC" 
2c47 f5				push af  
2c48 3a 5c 2c			ld a, (.dmark)  
2c4b 32 71 ee			ld (debug_mark),a  
2c4e 3a 5d 2c			ld a, (.dmark+1)  
2c51 32 72 ee			ld (debug_mark+1),a  
2c54 3a 5e 2c			ld a, (.dmark+2)  
2c57 32 73 ee			ld (debug_mark+2),a  
2c5a 18 03			jr .pastdmark  
2c5c ..			.dmark: db "DEC"  
2c5f f1			.pastdmark: pop af  
2c60			endm  
# End of macro DMARK
2c60						CALLMONITOR 
2c60 cd 76 15			call break_point_state  
2c63				endm  
# End of macro CALLMONITOR
2c63					endif 
2c63			 
2c63 7e					ld a,(hl) 
2c64 93					sub e 
2c65 77					ld (hl),a 
2c66			 
2c66			 
2c66			 
2c66				       NEXTW 
2c66 c3 55 1f			jp macro_next 
2c69				endm 
# End of macro NEXTW
2c69			 
2c69			.INC2: 
2c69				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2c69 6f				db WORD_SYS_CORE+91             
2c6a 13 2d			dw .DEC2            
2c6c 04				db 3 + 1 
2c6d .. 00			db "+2!",0              
2c71				endm 
# End of macro CWHEAD
2c71			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2c71			 
2c71					if DEBUG_FORTH_WORDS_KEY 
2c71						DMARK "+2s" 
2c71 f5				push af  
2c72 3a 86 2c			ld a, (.dmark)  
2c75 32 71 ee			ld (debug_mark),a  
2c78 3a 87 2c			ld a, (.dmark+1)  
2c7b 32 72 ee			ld (debug_mark+1),a  
2c7e 3a 88 2c			ld a, (.dmark+2)  
2c81 32 73 ee			ld (debug_mark+2),a  
2c84 18 03			jr .pastdmark  
2c86 ..			.dmark: db "+2s"  
2c89 f1			.pastdmark: pop af  
2c8a			endm  
# End of macro DMARK
2c8a						CALLMONITOR 
2c8a cd 76 15			call break_point_state  
2c8d				endm  
# End of macro CALLMONITOR
2c8d					endif 
2c8d			 
2c8d					; Address 
2c8d			 
2c8d					FORTH_DSP_VALUEHL 
2c8d cd de 1d			call macro_dsp_valuehl 
2c90				endm 
# End of macro FORTH_DSP_VALUEHL
2c90			 
2c90 e5					push hl    ; save address 
2c91			 
2c91					; load content into de 
2c91			 
2c91 5e					ld e,(hl) 
2c92 23					inc hl 
2c93 56					ld d, (hl) 
2c94			 
2c94					if DEBUG_FORTH_WORDS 
2c94						DMARK "+2a" 
2c94 f5				push af  
2c95 3a a9 2c			ld a, (.dmark)  
2c98 32 71 ee			ld (debug_mark),a  
2c9b 3a aa 2c			ld a, (.dmark+1)  
2c9e 32 72 ee			ld (debug_mark+1),a  
2ca1 3a ab 2c			ld a, (.dmark+2)  
2ca4 32 73 ee			ld (debug_mark+2),a  
2ca7 18 03			jr .pastdmark  
2ca9 ..			.dmark: db "+2a"  
2cac f1			.pastdmark: pop af  
2cad			endm  
# End of macro DMARK
2cad						CALLMONITOR 
2cad cd 76 15			call break_point_state  
2cb0				endm  
# End of macro CALLMONITOR
2cb0					endif 
2cb0			 
2cb0					FORTH_DSP_POP 
2cb0 cd 96 1e			call macro_forth_dsp_pop 
2cb3				endm 
# End of macro FORTH_DSP_POP
2cb3			 
2cb3					; Get value to add 
2cb3			 
2cb3					FORTH_DSP_VALUE 
2cb3 cd c7 1d			call macro_forth_dsp_value 
2cb6				endm 
# End of macro FORTH_DSP_VALUE
2cb6			 
2cb6					if DEBUG_FORTH_WORDS 
2cb6						DMARK "+2v" 
2cb6 f5				push af  
2cb7 3a cb 2c			ld a, (.dmark)  
2cba 32 71 ee			ld (debug_mark),a  
2cbd 3a cc 2c			ld a, (.dmark+1)  
2cc0 32 72 ee			ld (debug_mark+1),a  
2cc3 3a cd 2c			ld a, (.dmark+2)  
2cc6 32 73 ee			ld (debug_mark+2),a  
2cc9 18 03			jr .pastdmark  
2ccb ..			.dmark: db "+2v"  
2cce f1			.pastdmark: pop af  
2ccf			endm  
# End of macro DMARK
2ccf						CALLMONITOR 
2ccf cd 76 15			call break_point_state  
2cd2				endm  
# End of macro CALLMONITOR
2cd2					endif 
2cd2			 
2cd2 19					add hl, de 
2cd3			 
2cd3					if DEBUG_FORTH_WORDS 
2cd3						DMARK "+2+" 
2cd3 f5				push af  
2cd4 3a e8 2c			ld a, (.dmark)  
2cd7 32 71 ee			ld (debug_mark),a  
2cda 3a e9 2c			ld a, (.dmark+1)  
2cdd 32 72 ee			ld (debug_mark+1),a  
2ce0 3a ea 2c			ld a, (.dmark+2)  
2ce3 32 73 ee			ld (debug_mark+2),a  
2ce6 18 03			jr .pastdmark  
2ce8 ..			.dmark: db "+2+"  
2ceb f1			.pastdmark: pop af  
2cec			endm  
# End of macro DMARK
2cec						CALLMONITOR 
2cec cd 76 15			call break_point_state  
2cef				endm  
# End of macro CALLMONITOR
2cef					endif 
2cef			 
2cef					; move result to de 
2cef			 
2cef eb					ex de, hl 
2cf0			 
2cf0					; Address 
2cf0			 
2cf0 e1					pop hl 
2cf1			 
2cf1					; save it back 
2cf1			 
2cf1 73					ld (hl), e 
2cf2 23					inc hl 
2cf3 72					ld (hl), d 
2cf4			 
2cf4					if DEBUG_FORTH_WORDS 
2cf4						DMARK "+2e" 
2cf4 f5				push af  
2cf5 3a 09 2d			ld a, (.dmark)  
2cf8 32 71 ee			ld (debug_mark),a  
2cfb 3a 0a 2d			ld a, (.dmark+1)  
2cfe 32 72 ee			ld (debug_mark+1),a  
2d01 3a 0b 2d			ld a, (.dmark+2)  
2d04 32 73 ee			ld (debug_mark+2),a  
2d07 18 03			jr .pastdmark  
2d09 ..			.dmark: db "+2e"  
2d0c f1			.pastdmark: pop af  
2d0d			endm  
# End of macro DMARK
2d0d						CALLMONITOR 
2d0d cd 76 15			call break_point_state  
2d10				endm  
# End of macro CALLMONITOR
2d10					endif 
2d10			 
2d10			 
2d10			 
2d10			 
2d10			 
2d10				       NEXTW 
2d10 c3 55 1f			jp macro_next 
2d13				endm 
# End of macro NEXTW
2d13			 
2d13			.DEC2: 
2d13				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2d13 6f				db WORD_SYS_CORE+91             
2d14 bf 2d			dw .GET2            
2d16 04				db 3 + 1 
2d17 .. 00			db "-2!",0              
2d1b				endm 
# End of macro CWHEAD
2d1b			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2d1b			 
2d1b			 
2d1b					if DEBUG_FORTH_WORDS_KEY 
2d1b						DMARK "-2s" 
2d1b f5				push af  
2d1c 3a 30 2d			ld a, (.dmark)  
2d1f 32 71 ee			ld (debug_mark),a  
2d22 3a 31 2d			ld a, (.dmark+1)  
2d25 32 72 ee			ld (debug_mark+1),a  
2d28 3a 32 2d			ld a, (.dmark+2)  
2d2b 32 73 ee			ld (debug_mark+2),a  
2d2e 18 03			jr .pastdmark  
2d30 ..			.dmark: db "-2s"  
2d33 f1			.pastdmark: pop af  
2d34			endm  
# End of macro DMARK
2d34						CALLMONITOR 
2d34 cd 76 15			call break_point_state  
2d37				endm  
# End of macro CALLMONITOR
2d37					endif 
2d37			 
2d37					; Address 
2d37			 
2d37					FORTH_DSP_VALUEHL 
2d37 cd de 1d			call macro_dsp_valuehl 
2d3a				endm 
# End of macro FORTH_DSP_VALUEHL
2d3a			 
2d3a e5					push hl    ; save address 
2d3b			 
2d3b					; load content into de 
2d3b			 
2d3b 5e					ld e,(hl) 
2d3c 23					inc hl 
2d3d 56					ld d, (hl) 
2d3e			 
2d3e					if DEBUG_FORTH_WORDS 
2d3e						DMARK "-2a" 
2d3e f5				push af  
2d3f 3a 53 2d			ld a, (.dmark)  
2d42 32 71 ee			ld (debug_mark),a  
2d45 3a 54 2d			ld a, (.dmark+1)  
2d48 32 72 ee			ld (debug_mark+1),a  
2d4b 3a 55 2d			ld a, (.dmark+2)  
2d4e 32 73 ee			ld (debug_mark+2),a  
2d51 18 03			jr .pastdmark  
2d53 ..			.dmark: db "-2a"  
2d56 f1			.pastdmark: pop af  
2d57			endm  
# End of macro DMARK
2d57						CALLMONITOR 
2d57 cd 76 15			call break_point_state  
2d5a				endm  
# End of macro CALLMONITOR
2d5a					endif 
2d5a			 
2d5a					FORTH_DSP_POP 
2d5a cd 96 1e			call macro_forth_dsp_pop 
2d5d				endm 
# End of macro FORTH_DSP_POP
2d5d			 
2d5d					; Get value to remove 
2d5d			 
2d5d					FORTH_DSP_VALUE 
2d5d cd c7 1d			call macro_forth_dsp_value 
2d60				endm 
# End of macro FORTH_DSP_VALUE
2d60			 
2d60					if DEBUG_FORTH_WORDS 
2d60						DMARK "-2v" 
2d60 f5				push af  
2d61 3a 75 2d			ld a, (.dmark)  
2d64 32 71 ee			ld (debug_mark),a  
2d67 3a 76 2d			ld a, (.dmark+1)  
2d6a 32 72 ee			ld (debug_mark+1),a  
2d6d 3a 77 2d			ld a, (.dmark+2)  
2d70 32 73 ee			ld (debug_mark+2),a  
2d73 18 03			jr .pastdmark  
2d75 ..			.dmark: db "-2v"  
2d78 f1			.pastdmark: pop af  
2d79			endm  
# End of macro DMARK
2d79						CALLMONITOR 
2d79 cd 76 15			call break_point_state  
2d7c				endm  
# End of macro CALLMONITOR
2d7c					endif 
2d7c			 
2d7c eb					ex de, hl 
2d7d ed 52				sbc hl, de 
2d7f			 
2d7f					if DEBUG_FORTH_WORDS 
2d7f						DMARK "-2d" 
2d7f f5				push af  
2d80 3a 94 2d			ld a, (.dmark)  
2d83 32 71 ee			ld (debug_mark),a  
2d86 3a 95 2d			ld a, (.dmark+1)  
2d89 32 72 ee			ld (debug_mark+1),a  
2d8c 3a 96 2d			ld a, (.dmark+2)  
2d8f 32 73 ee			ld (debug_mark+2),a  
2d92 18 03			jr .pastdmark  
2d94 ..			.dmark: db "-2d"  
2d97 f1			.pastdmark: pop af  
2d98			endm  
# End of macro DMARK
2d98						CALLMONITOR 
2d98 cd 76 15			call break_point_state  
2d9b				endm  
# End of macro CALLMONITOR
2d9b					endif 
2d9b			 
2d9b					; move result to de 
2d9b			 
2d9b eb					ex de, hl 
2d9c			 
2d9c					; Address 
2d9c			 
2d9c e1					pop hl 
2d9d			 
2d9d					; save it back 
2d9d			 
2d9d 73					ld (hl), e 
2d9e 23					inc hl 
2d9f 72					ld (hl), d 
2da0			 
2da0					if DEBUG_FORTH_WORDS 
2da0						DMARK "-2e" 
2da0 f5				push af  
2da1 3a b5 2d			ld a, (.dmark)  
2da4 32 71 ee			ld (debug_mark),a  
2da7 3a b6 2d			ld a, (.dmark+1)  
2daa 32 72 ee			ld (debug_mark+1),a  
2dad 3a b7 2d			ld a, (.dmark+2)  
2db0 32 73 ee			ld (debug_mark+2),a  
2db3 18 03			jr .pastdmark  
2db5 ..			.dmark: db "-2e"  
2db8 f1			.pastdmark: pop af  
2db9			endm  
# End of macro DMARK
2db9						CALLMONITOR 
2db9 cd 76 15			call break_point_state  
2dbc				endm  
# End of macro CALLMONITOR
2dbc					endif 
2dbc			 
2dbc			 
2dbc			 
2dbc			 
2dbc			 
2dbc				       NEXTW 
2dbc c3 55 1f			jp macro_next 
2dbf				endm 
# End of macro NEXTW
2dbf			.GET2: 
2dbf				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2dbf 6f				db WORD_SYS_CORE+91             
2dc0 ef 2d			dw .BANG2            
2dc2 03				db 2 + 1 
2dc3 .. 00			db "2@",0              
2dc6				endm 
# End of macro CWHEAD
2dc6			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2dc6					if DEBUG_FORTH_WORDS_KEY 
2dc6						DMARK "2A_" 
2dc6 f5				push af  
2dc7 3a db 2d			ld a, (.dmark)  
2dca 32 71 ee			ld (debug_mark),a  
2dcd 3a dc 2d			ld a, (.dmark+1)  
2dd0 32 72 ee			ld (debug_mark+1),a  
2dd3 3a dd 2d			ld a, (.dmark+2)  
2dd6 32 73 ee			ld (debug_mark+2),a  
2dd9 18 03			jr .pastdmark  
2ddb ..			.dmark: db "2A_"  
2dde f1			.pastdmark: pop af  
2ddf			endm  
# End of macro DMARK
2ddf						CALLMONITOR 
2ddf cd 76 15			call break_point_state  
2de2				endm  
# End of macro CALLMONITOR
2de2					endif 
2de2			 
2de2					FORTH_DSP_VALUEHL 
2de2 cd de 1d			call macro_dsp_valuehl 
2de5				endm 
# End of macro FORTH_DSP_VALUEHL
2de5			 
2de5 5e					ld e, (hl) 
2de6 23					inc hl 
2de7 56					ld d, (hl) 
2de8			 
2de8 eb					ex de, hl 
2de9			 
2de9 cd e7 1b				call forth_push_numhl 
2dec			 
2dec				       NEXTW 
2dec c3 55 1f			jp macro_next 
2def				endm 
# End of macro NEXTW
2def			.BANG2: 
2def				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2def 6f				db WORD_SYS_CORE+91             
2df0 27 2e			dw .CONFIG            
2df2 03				db 2 + 1 
2df3 .. 00			db "2!",0              
2df6				endm 
# End of macro CWHEAD
2df6			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2df6					if DEBUG_FORTH_WORDS_KEY 
2df6						DMARK "2S_" 
2df6 f5				push af  
2df7 3a 0b 2e			ld a, (.dmark)  
2dfa 32 71 ee			ld (debug_mark),a  
2dfd 3a 0c 2e			ld a, (.dmark+1)  
2e00 32 72 ee			ld (debug_mark+1),a  
2e03 3a 0d 2e			ld a, (.dmark+2)  
2e06 32 73 ee			ld (debug_mark+2),a  
2e09 18 03			jr .pastdmark  
2e0b ..			.dmark: db "2S_"  
2e0e f1			.pastdmark: pop af  
2e0f			endm  
# End of macro DMARK
2e0f						CALLMONITOR 
2e0f cd 76 15			call break_point_state  
2e12				endm  
# End of macro CALLMONITOR
2e12					endif 
2e12			 
2e12					FORTH_DSP_VALUEHL 
2e12 cd de 1d			call macro_dsp_valuehl 
2e15				endm 
# End of macro FORTH_DSP_VALUEHL
2e15			 
2e15 e5					push hl   ; save address 
2e16			 
2e16			 
2e16					FORTH_DSP_POP 
2e16 cd 96 1e			call macro_forth_dsp_pop 
2e19				endm 
# End of macro FORTH_DSP_POP
2e19			 
2e19					 
2e19					FORTH_DSP_VALUEHL 
2e19 cd de 1d			call macro_dsp_valuehl 
2e1c				endm 
# End of macro FORTH_DSP_VALUEHL
2e1c			 
2e1c					FORTH_DSP_POP 
2e1c cd 96 1e			call macro_forth_dsp_pop 
2e1f				endm 
# End of macro FORTH_DSP_POP
2e1f			 
2e1f eb					ex de, hl    ; value now in de 
2e20			 
2e20 e1					pop hl 
2e21			 
2e21 73					ld (hl), e 
2e22			 
2e22 23					inc hl 
2e23			 
2e23 72					ld (hl), d 
2e24			 
2e24			 
2e24				       NEXTW 
2e24 c3 55 1f			jp macro_next 
2e27				endm 
# End of macro NEXTW
2e27			.CONFIG: 
2e27				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2e27 6f				db WORD_SYS_CORE+91             
2e28 38 2e			dw .ENDCORE            
2e2a 07				db 6 + 1 
2e2b .. 00			db "CONFIG",0              
2e32				endm 
# End of macro CWHEAD
2e32			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2e32			 
2e32 cd d5 13				call config 
2e35					NEXTW 
2e35 c3 55 1f			jp macro_next 
2e38				endm 
# End of macro NEXTW
2e38			.ENDCORE: 
2e38			 
2e38			; eof 
2e38			 
2e38			 
# End of file forth_words_core.asm
2e38			include "forth_words_flow.asm" 
2e38			 
2e38			; | ## Program Flow Words 
2e38			 
2e38			.IF: 
2e38				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2e38 1e				db WORD_SYS_CORE+10             
2e39 2d 2f			dw .THEN            
2e3b 03				db 2 + 1 
2e3c .. 00			db "IF",0              
2e3f				endm 
# End of macro CWHEAD
2e3f			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2e3f			; 
2e3f					if DEBUG_FORTH_WORDS_KEY 
2e3f						DMARK "IF." 
2e3f f5				push af  
2e40 3a 54 2e			ld a, (.dmark)  
2e43 32 71 ee			ld (debug_mark),a  
2e46 3a 55 2e			ld a, (.dmark+1)  
2e49 32 72 ee			ld (debug_mark+1),a  
2e4c 3a 56 2e			ld a, (.dmark+2)  
2e4f 32 73 ee			ld (debug_mark+2),a  
2e52 18 03			jr .pastdmark  
2e54 ..			.dmark: db "IF."  
2e57 f1			.pastdmark: pop af  
2e58			endm  
# End of macro DMARK
2e58						CALLMONITOR 
2e58 cd 76 15			call break_point_state  
2e5b				endm  
# End of macro CALLMONITOR
2e5b					endif 
2e5b			; eval TOS 
2e5b			 
2e5b				FORTH_DSP_VALUEHL 
2e5b cd de 1d			call macro_dsp_valuehl 
2e5e				endm 
# End of macro FORTH_DSP_VALUEHL
2e5e			 
2e5e			;	push hl 
2e5e				FORTH_DSP_POP 
2e5e cd 96 1e			call macro_forth_dsp_pop 
2e61				endm 
# End of macro FORTH_DSP_POP
2e61			;	pop hl 
2e61			 
2e61					if DEBUG_FORTH_WORDS 
2e61						DMARK "IF1" 
2e61 f5				push af  
2e62 3a 76 2e			ld a, (.dmark)  
2e65 32 71 ee			ld (debug_mark),a  
2e68 3a 77 2e			ld a, (.dmark+1)  
2e6b 32 72 ee			ld (debug_mark+1),a  
2e6e 3a 78 2e			ld a, (.dmark+2)  
2e71 32 73 ee			ld (debug_mark+2),a  
2e74 18 03			jr .pastdmark  
2e76 ..			.dmark: db "IF1"  
2e79 f1			.pastdmark: pop af  
2e7a			endm  
# End of macro DMARK
2e7a						CALLMONITOR 
2e7a cd 76 15			call break_point_state  
2e7d				endm  
# End of macro CALLMONITOR
2e7d					endif 
2e7d b7				or a        ; clear carry flag 
2e7e 11 00 00			ld de, 0 
2e81 eb				ex de,hl 
2e82 ed 52			sbc hl, de 
2e84 c2 0e 2f			jp nz, .iftrue 
2e87			 
2e87					if DEBUG_FORTH_WORDS 
2e87						DMARK "IF2" 
2e87 f5				push af  
2e88 3a 9c 2e			ld a, (.dmark)  
2e8b 32 71 ee			ld (debug_mark),a  
2e8e 3a 9d 2e			ld a, (.dmark+1)  
2e91 32 72 ee			ld (debug_mark+1),a  
2e94 3a 9e 2e			ld a, (.dmark+2)  
2e97 32 73 ee			ld (debug_mark+2),a  
2e9a 18 03			jr .pastdmark  
2e9c ..			.dmark: db "IF2"  
2e9f f1			.pastdmark: pop af  
2ea0			endm  
# End of macro DMARK
2ea0						CALLMONITOR 
2ea0 cd 76 15			call break_point_state  
2ea3				endm  
# End of macro CALLMONITOR
2ea3					endif 
2ea3			 
2ea3			; if not true then skip to THEN 
2ea3			 
2ea3				; TODO get tok_ptr 
2ea3				; TODO consume toks until we get to THEN 
2ea3			 
2ea3 2a 03 e6			ld hl, (os_tok_ptr) 
2ea6					if DEBUG_FORTH_WORDS 
2ea6						DMARK "IF3" 
2ea6 f5				push af  
2ea7 3a bb 2e			ld a, (.dmark)  
2eaa 32 71 ee			ld (debug_mark),a  
2ead 3a bc 2e			ld a, (.dmark+1)  
2eb0 32 72 ee			ld (debug_mark+1),a  
2eb3 3a bd 2e			ld a, (.dmark+2)  
2eb6 32 73 ee			ld (debug_mark+2),a  
2eb9 18 03			jr .pastdmark  
2ebb ..			.dmark: db "IF3"  
2ebe f1			.pastdmark: pop af  
2ebf			endm  
# End of macro DMARK
2ebf						CALLMONITOR 
2ebf cd 76 15			call break_point_state  
2ec2				endm  
# End of macro CALLMONITOR
2ec2						 
2ec2					endif 
2ec2 11 09 2f			ld de, .ifthen 
2ec5					if DEBUG_FORTH_WORDS 
2ec5						DMARK "IF4" 
2ec5 f5				push af  
2ec6 3a da 2e			ld a, (.dmark)  
2ec9 32 71 ee			ld (debug_mark),a  
2ecc 3a db 2e			ld a, (.dmark+1)  
2ecf 32 72 ee			ld (debug_mark+1),a  
2ed2 3a dc 2e			ld a, (.dmark+2)  
2ed5 32 73 ee			ld (debug_mark+2),a  
2ed8 18 03			jr .pastdmark  
2eda ..			.dmark: db "IF4"  
2edd f1			.pastdmark: pop af  
2ede			endm  
# End of macro DMARK
2ede						CALLMONITOR 
2ede cd 76 15			call break_point_state  
2ee1				endm  
# End of macro CALLMONITOR
2ee1					endif 
2ee1 cd 70 20			call findnexttok  
2ee4			 
2ee4					if DEBUG_FORTH_WORDS 
2ee4						DMARK "IF5" 
2ee4 f5				push af  
2ee5 3a f9 2e			ld a, (.dmark)  
2ee8 32 71 ee			ld (debug_mark),a  
2eeb 3a fa 2e			ld a, (.dmark+1)  
2eee 32 72 ee			ld (debug_mark+1),a  
2ef1 3a fb 2e			ld a, (.dmark+2)  
2ef4 32 73 ee			ld (debug_mark+2),a  
2ef7 18 03			jr .pastdmark  
2ef9 ..			.dmark: db "IF5"  
2efc f1			.pastdmark: pop af  
2efd			endm  
# End of macro DMARK
2efd						CALLMONITOR 
2efd cd 76 15			call break_point_state  
2f00				endm  
# End of macro CALLMONITOR
2f00					endif 
2f00				; TODO replace below with ; exec using tok_ptr 
2f00 22 03 e6			ld (os_tok_ptr), hl 
2f03 c3 e6 1f			jp exec1 
2f06				NEXTW 
2f06 c3 55 1f			jp macro_next 
2f09				endm 
# End of macro NEXTW
2f09			 
2f09 .. 00		.ifthen:  db "THEN",0 
2f0e			 
2f0e			.iftrue:		 
2f0e				; Exec next words normally 
2f0e			 
2f0e				; if true then exec following IF as normal 
2f0e					if DEBUG_FORTH_WORDS 
2f0e						DMARK "IFT" 
2f0e f5				push af  
2f0f 3a 23 2f			ld a, (.dmark)  
2f12 32 71 ee			ld (debug_mark),a  
2f15 3a 24 2f			ld a, (.dmark+1)  
2f18 32 72 ee			ld (debug_mark+1),a  
2f1b 3a 25 2f			ld a, (.dmark+2)  
2f1e 32 73 ee			ld (debug_mark+2),a  
2f21 18 03			jr .pastdmark  
2f23 ..			.dmark: db "IFT"  
2f26 f1			.pastdmark: pop af  
2f27			endm  
# End of macro DMARK
2f27						CALLMONITOR 
2f27 cd 76 15			call break_point_state  
2f2a				endm  
# End of macro CALLMONITOR
2f2a					endif 
2f2a			 
2f2a					NEXTW 
2f2a c3 55 1f			jp macro_next 
2f2d				endm 
# End of macro NEXTW
2f2d			.THEN: 
2f2d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2f2d 1f				db WORD_SYS_CORE+11             
2f2e 55 2f			dw .ELSE            
2f30 05				db 4 + 1 
2f31 .. 00			db "THEN",0              
2f36				endm 
# End of macro CWHEAD
2f36			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2f36					if DEBUG_FORTH_WORDS_KEY 
2f36						DMARK "THN" 
2f36 f5				push af  
2f37 3a 4b 2f			ld a, (.dmark)  
2f3a 32 71 ee			ld (debug_mark),a  
2f3d 3a 4c 2f			ld a, (.dmark+1)  
2f40 32 72 ee			ld (debug_mark+1),a  
2f43 3a 4d 2f			ld a, (.dmark+2)  
2f46 32 73 ee			ld (debug_mark+2),a  
2f49 18 03			jr .pastdmark  
2f4b ..			.dmark: db "THN"  
2f4e f1			.pastdmark: pop af  
2f4f			endm  
# End of macro DMARK
2f4f						CALLMONITOR 
2f4f cd 76 15			call break_point_state  
2f52				endm  
# End of macro CALLMONITOR
2f52					endif 
2f52					NEXTW 
2f52 c3 55 1f			jp macro_next 
2f55				endm 
# End of macro NEXTW
2f55			.ELSE: 
2f55				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2f55 20				db WORD_SYS_CORE+12             
2f56 7d 2f			dw .DO            
2f58 03				db 2 + 1 
2f59 .. 00			db "ELSE",0              
2f5e				endm 
# End of macro CWHEAD
2f5e			; | ELSE ( -- ) Not supported - does nothing | TODO 
2f5e			 
2f5e					if DEBUG_FORTH_WORDS_KEY 
2f5e						DMARK "ELS" 
2f5e f5				push af  
2f5f 3a 73 2f			ld a, (.dmark)  
2f62 32 71 ee			ld (debug_mark),a  
2f65 3a 74 2f			ld a, (.dmark+1)  
2f68 32 72 ee			ld (debug_mark+1),a  
2f6b 3a 75 2f			ld a, (.dmark+2)  
2f6e 32 73 ee			ld (debug_mark+2),a  
2f71 18 03			jr .pastdmark  
2f73 ..			.dmark: db "ELS"  
2f76 f1			.pastdmark: pop af  
2f77			endm  
# End of macro DMARK
2f77						CALLMONITOR 
2f77 cd 76 15			call break_point_state  
2f7a				endm  
# End of macro CALLMONITOR
2f7a					endif 
2f7a			 
2f7a			 
2f7a					NEXTW 
2f7a c3 55 1f			jp macro_next 
2f7d				endm 
# End of macro NEXTW
2f7d			.DO: 
2f7d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2f7d 21				db WORD_SYS_CORE+13             
2f7e a4 30			dw .LOOP            
2f80 03				db 2 + 1 
2f81 .. 00			db "DO",0              
2f84				endm 
# End of macro CWHEAD
2f84			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2f84			 
2f84					if DEBUG_FORTH_WORDS_KEY 
2f84						DMARK "DO." 
2f84 f5				push af  
2f85 3a 99 2f			ld a, (.dmark)  
2f88 32 71 ee			ld (debug_mark),a  
2f8b 3a 9a 2f			ld a, (.dmark+1)  
2f8e 32 72 ee			ld (debug_mark+1),a  
2f91 3a 9b 2f			ld a, (.dmark+2)  
2f94 32 73 ee			ld (debug_mark+2),a  
2f97 18 03			jr .pastdmark  
2f99 ..			.dmark: db "DO."  
2f9c f1			.pastdmark: pop af  
2f9d			endm  
# End of macro DMARK
2f9d						CALLMONITOR 
2f9d cd 76 15			call break_point_state  
2fa0				endm  
# End of macro CALLMONITOR
2fa0					endif 
2fa0			;  push pc to rsp stack past the DO 
2fa0			 
2fa0 2a 03 e6				ld hl, (os_tok_ptr) 
2fa3 23					inc hl   ; D 
2fa4 23					inc hl  ; O 
2fa5 23					inc hl   ; null 
2fa6					if DEBUG_FORTH_WORDS 
2fa6						DMARK "DO2" 
2fa6 f5				push af  
2fa7 3a bb 2f			ld a, (.dmark)  
2faa 32 71 ee			ld (debug_mark),a  
2fad 3a bc 2f			ld a, (.dmark+1)  
2fb0 32 72 ee			ld (debug_mark+1),a  
2fb3 3a bd 2f			ld a, (.dmark+2)  
2fb6 32 73 ee			ld (debug_mark+2),a  
2fb9 18 03			jr .pastdmark  
2fbb ..			.dmark: db "DO2"  
2fbe f1			.pastdmark: pop af  
2fbf			endm  
# End of macro DMARK
2fbf						CALLMONITOR 
2fbf cd 76 15			call break_point_state  
2fc2				endm  
# End of macro CALLMONITOR
2fc2					endif 
2fc2					FORTH_RSP_NEXT 
2fc2 cd 8e 1b			call macro_forth_rsp_next 
2fc5				endm 
# End of macro FORTH_RSP_NEXT
2fc5					if DEBUG_FORTH_WORDS 
2fc5						DMARK "DO3" 
2fc5 f5				push af  
2fc6 3a da 2f			ld a, (.dmark)  
2fc9 32 71 ee			ld (debug_mark),a  
2fcc 3a db 2f			ld a, (.dmark+1)  
2fcf 32 72 ee			ld (debug_mark+1),a  
2fd2 3a dc 2f			ld a, (.dmark+2)  
2fd5 32 73 ee			ld (debug_mark+2),a  
2fd8 18 03			jr .pastdmark  
2fda ..			.dmark: db "DO3"  
2fdd f1			.pastdmark: pop af  
2fde			endm  
# End of macro DMARK
2fde						CALLMONITOR 
2fde cd 76 15			call break_point_state  
2fe1				endm  
# End of macro CALLMONITOR
2fe1					endif 
2fe1			 
2fe1					;if DEBUG_FORTH_WORDS 
2fe1				;		push hl 
2fe1			;		endif  
2fe1			 
2fe1			; get counters from data stack 
2fe1			 
2fe1			 
2fe1					FORTH_DSP_VALUEHL 
2fe1 cd de 1d			call macro_dsp_valuehl 
2fe4				endm 
# End of macro FORTH_DSP_VALUEHL
2fe4 e5					push hl		 ; hl now has starting counter which needs to be tos 
2fe5			 
2fe5					if DEBUG_FORTH_WORDS 
2fe5						DMARK "DO4" 
2fe5 f5				push af  
2fe6 3a fa 2f			ld a, (.dmark)  
2fe9 32 71 ee			ld (debug_mark),a  
2fec 3a fb 2f			ld a, (.dmark+1)  
2fef 32 72 ee			ld (debug_mark+1),a  
2ff2 3a fc 2f			ld a, (.dmark+2)  
2ff5 32 73 ee			ld (debug_mark+2),a  
2ff8 18 03			jr .pastdmark  
2ffa ..			.dmark: db "DO4"  
2ffd f1			.pastdmark: pop af  
2ffe			endm  
# End of macro DMARK
2ffe						CALLMONITOR 
2ffe cd 76 15			call break_point_state  
3001				endm  
# End of macro CALLMONITOR
3001					endif 
3001					FORTH_DSP_POP 
3001 cd 96 1e			call macro_forth_dsp_pop 
3004				endm 
# End of macro FORTH_DSP_POP
3004			 
3004					if DEBUG_FORTH_WORDS 
3004						DMARK "DO5" 
3004 f5				push af  
3005 3a 19 30			ld a, (.dmark)  
3008 32 71 ee			ld (debug_mark),a  
300b 3a 1a 30			ld a, (.dmark+1)  
300e 32 72 ee			ld (debug_mark+1),a  
3011 3a 1b 30			ld a, (.dmark+2)  
3014 32 73 ee			ld (debug_mark+2),a  
3017 18 03			jr .pastdmark  
3019 ..			.dmark: db "DO5"  
301c f1			.pastdmark: pop af  
301d			endm  
# End of macro DMARK
301d						CALLMONITOR 
301d cd 76 15			call break_point_state  
3020				endm  
# End of macro CALLMONITOR
3020					endif 
3020			 
3020					FORTH_DSP_VALUEHL 
3020 cd de 1d			call macro_dsp_valuehl 
3023				endm 
# End of macro FORTH_DSP_VALUEHL
3023			;		push hl		 ; hl now has starting limit counter 
3023			 
3023					if DEBUG_FORTH_WORDS 
3023						DMARK "DO6" 
3023 f5				push af  
3024 3a 38 30			ld a, (.dmark)  
3027 32 71 ee			ld (debug_mark),a  
302a 3a 39 30			ld a, (.dmark+1)  
302d 32 72 ee			ld (debug_mark+1),a  
3030 3a 3a 30			ld a, (.dmark+2)  
3033 32 73 ee			ld (debug_mark+2),a  
3036 18 03			jr .pastdmark  
3038 ..			.dmark: db "DO6"  
303b f1			.pastdmark: pop af  
303c			endm  
# End of macro DMARK
303c						CALLMONITOR 
303c cd 76 15			call break_point_state  
303f				endm  
# End of macro CALLMONITOR
303f					endif 
303f					FORTH_DSP_POP 
303f cd 96 1e			call macro_forth_dsp_pop 
3042				endm 
# End of macro FORTH_DSP_POP
3042			 
3042			; put counters on the loop stack 
3042			 
3042			;		pop hl			 ; limit counter 
3042 d1					pop de			; start counter 
3043			 
3043					; push limit counter 
3043			 
3043					if DEBUG_FORTH_WORDS 
3043						DMARK "DO7" 
3043 f5				push af  
3044 3a 58 30			ld a, (.dmark)  
3047 32 71 ee			ld (debug_mark),a  
304a 3a 59 30			ld a, (.dmark+1)  
304d 32 72 ee			ld (debug_mark+1),a  
3050 3a 5a 30			ld a, (.dmark+2)  
3053 32 73 ee			ld (debug_mark+2),a  
3056 18 03			jr .pastdmark  
3058 ..			.dmark: db "DO7"  
305b f1			.pastdmark: pop af  
305c			endm  
# End of macro DMARK
305c						CALLMONITOR 
305c cd 76 15			call break_point_state  
305f				endm  
# End of macro CALLMONITOR
305f					endif 
305f					FORTH_LOOP_NEXT 
305f cd 0f 1e			call macro_forth_loop_next 
3062				endm 
# End of macro FORTH_LOOP_NEXT
3062			 
3062					; push start counter 
3062			 
3062 eb					ex de, hl 
3063					if DEBUG_FORTH_WORDS 
3063						DMARK "DO7" 
3063 f5				push af  
3064 3a 78 30			ld a, (.dmark)  
3067 32 71 ee			ld (debug_mark),a  
306a 3a 79 30			ld a, (.dmark+1)  
306d 32 72 ee			ld (debug_mark+1),a  
3070 3a 7a 30			ld a, (.dmark+2)  
3073 32 73 ee			ld (debug_mark+2),a  
3076 18 03			jr .pastdmark  
3078 ..			.dmark: db "DO7"  
307b f1			.pastdmark: pop af  
307c			endm  
# End of macro DMARK
307c						CALLMONITOR 
307c cd 76 15			call break_point_state  
307f				endm  
# End of macro CALLMONITOR
307f					endif 
307f					FORTH_LOOP_NEXT 
307f cd 0f 1e			call macro_forth_loop_next 
3082				endm 
# End of macro FORTH_LOOP_NEXT
3082			 
3082			 
3082					; init first round of I counter 
3082			 
3082 22 27 e6				ld (os_current_i), hl 
3085			 
3085					if DEBUG_FORTH_WORDS 
3085						DMARK "DO8" 
3085 f5				push af  
3086 3a 9a 30			ld a, (.dmark)  
3089 32 71 ee			ld (debug_mark),a  
308c 3a 9b 30			ld a, (.dmark+1)  
308f 32 72 ee			ld (debug_mark+1),a  
3092 3a 9c 30			ld a, (.dmark+2)  
3095 32 73 ee			ld (debug_mark+2),a  
3098 18 03			jr .pastdmark  
309a ..			.dmark: db "DO8"  
309d f1			.pastdmark: pop af  
309e			endm  
# End of macro DMARK
309e						CALLMONITOR 
309e cd 76 15			call break_point_state  
30a1				endm  
# End of macro CALLMONITOR
30a1					endif 
30a1			 
30a1					NEXTW 
30a1 c3 55 1f			jp macro_next 
30a4				endm 
# End of macro NEXTW
30a4			.LOOP: 
30a4				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
30a4 22				db WORD_SYS_CORE+14             
30a5 bc 31			dw .I            
30a7 05				db 4 + 1 
30a8 .. 00			db "LOOP",0              
30ad				endm 
# End of macro CWHEAD
30ad			; | LOOP ( -- ) Increment and test loop counter  | DONE 
30ad			 
30ad				; pop tos as current loop count to hl 
30ad			 
30ad				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30ad			 
30ad				FORTH_LOOP_TOS 
30ad cd 42 1e			call macro_forth_loop_tos 
30b0				endm 
# End of macro FORTH_LOOP_TOS
30b0 e5				push hl 
30b1			 
30b1					if DEBUG_FORTH_WORDS_KEY 
30b1						DMARK "LOP" 
30b1 f5				push af  
30b2 3a c6 30			ld a, (.dmark)  
30b5 32 71 ee			ld (debug_mark),a  
30b8 3a c7 30			ld a, (.dmark+1)  
30bb 32 72 ee			ld (debug_mark+1),a  
30be 3a c8 30			ld a, (.dmark+2)  
30c1 32 73 ee			ld (debug_mark+2),a  
30c4 18 03			jr .pastdmark  
30c6 ..			.dmark: db "LOP"  
30c9 f1			.pastdmark: pop af  
30ca			endm  
# End of macro DMARK
30ca						CALLMONITOR 
30ca cd 76 15			call break_point_state  
30cd				endm  
# End of macro CALLMONITOR
30cd					endif 
30cd				; next item on the stack is the limit. get it 
30cd			 
30cd			 
30cd				FORTH_LOOP_POP 
30cd cd 4c 1e			call macro_forth_loop_pop 
30d0				endm 
# End of macro FORTH_LOOP_POP
30d0			 
30d0				FORTH_LOOP_TOS 
30d0 cd 42 1e			call macro_forth_loop_tos 
30d3				endm 
# End of macro FORTH_LOOP_TOS
30d3			 
30d3 d1				pop de		 ; de = i, hl = limit 
30d4			 
30d4					if DEBUG_FORTH_WORDS 
30d4						DMARK "LP1" 
30d4 f5				push af  
30d5 3a e9 30			ld a, (.dmark)  
30d8 32 71 ee			ld (debug_mark),a  
30db 3a ea 30			ld a, (.dmark+1)  
30de 32 72 ee			ld (debug_mark+1),a  
30e1 3a eb 30			ld a, (.dmark+2)  
30e4 32 73 ee			ld (debug_mark+2),a  
30e7 18 03			jr .pastdmark  
30e9 ..			.dmark: db "LP1"  
30ec f1			.pastdmark: pop af  
30ed			endm  
# End of macro DMARK
30ed						CALLMONITOR 
30ed cd 76 15			call break_point_state  
30f0				endm  
# End of macro CALLMONITOR
30f0					endif 
30f0			 
30f0				; go back to previous word 
30f0			 
30f0 d5				push de    ; save I for inc later 
30f1			 
30f1			 
30f1				; get limit 
30f1				;  is I at limit? 
30f1			 
30f1			 
30f1					if DEBUG_FORTH_WORDS 
30f1						DMARK "LP1" 
30f1 f5				push af  
30f2 3a 06 31			ld a, (.dmark)  
30f5 32 71 ee			ld (debug_mark),a  
30f8 3a 07 31			ld a, (.dmark+1)  
30fb 32 72 ee			ld (debug_mark+1),a  
30fe 3a 08 31			ld a, (.dmark+2)  
3101 32 73 ee			ld (debug_mark+2),a  
3104 18 03			jr .pastdmark  
3106 ..			.dmark: db "LP1"  
3109 f1			.pastdmark: pop af  
310a			endm  
# End of macro DMARK
310a						CALLMONITOR 
310a cd 76 15			call break_point_state  
310d				endm  
# End of macro CALLMONITOR
310d					endif 
310d			 
310d ed 52			sbc hl, de 
310f			 
310f			 
310f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
310f			 
310f 20 26				jr nz, .loopnotdone 
3111			 
3111 e1				pop hl   ; get rid of saved I 
3112				FORTH_LOOP_POP     ; get rid of limit 
3112 cd 4c 1e			call macro_forth_loop_pop 
3115				endm 
# End of macro FORTH_LOOP_POP
3115			 
3115				FORTH_RSP_POP     ; get rid of DO ptr 
3115 cd af 1b			call macro_forth_rsp_pop 
3118				endm 
# End of macro FORTH_RSP_POP
3118			 
3118			if DEBUG_FORTH_WORDS 
3118						DMARK "LP>" 
3118 f5				push af  
3119 3a 2d 31			ld a, (.dmark)  
311c 32 71 ee			ld (debug_mark),a  
311f 3a 2e 31			ld a, (.dmark+1)  
3122 32 72 ee			ld (debug_mark+1),a  
3125 3a 2f 31			ld a, (.dmark+2)  
3128 32 73 ee			ld (debug_mark+2),a  
312b 18 03			jr .pastdmark  
312d ..			.dmark: db "LP>"  
3130 f1			.pastdmark: pop af  
3131			endm  
# End of macro DMARK
3131				CALLMONITOR 
3131 cd 76 15			call break_point_state  
3134				endm  
# End of macro CALLMONITOR
3134			endif 
3134			 
3134					NEXTW 
3134 c3 55 1f			jp macro_next 
3137				endm 
# End of macro NEXTW
3137				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3137			 
3137			.loopnotdone: 
3137			 
3137 e1				pop hl    ; get I 
3138 23				inc hl 
3139			 
3139			   	; save new I 
3139			 
3139			 
3139					; set I counter 
3139			 
3139 22 27 e6				ld (os_current_i), hl 
313c			 
313c					if DEBUG_FORTH_WORDS 
313c						DMARK "LPN" 
313c f5				push af  
313d 3a 51 31			ld a, (.dmark)  
3140 32 71 ee			ld (debug_mark),a  
3143 3a 52 31			ld a, (.dmark+1)  
3146 32 72 ee			ld (debug_mark+1),a  
3149 3a 53 31			ld a, (.dmark+2)  
314c 32 73 ee			ld (debug_mark+2),a  
314f 18 03			jr .pastdmark  
3151 ..			.dmark: db "LPN"  
3154 f1			.pastdmark: pop af  
3155			endm  
# End of macro DMARK
3155					CALLMONITOR 
3155 cd 76 15			call break_point_state  
3158				endm  
# End of macro CALLMONITOR
3158					endif 
3158					 
3158				FORTH_LOOP_NEXT 
3158 cd 0f 1e			call macro_forth_loop_next 
315b				endm 
# End of macro FORTH_LOOP_NEXT
315b			 
315b			 
315b					if DEBUG_FORTH_WORDS 
315b eb						ex de,hl 
315c					endif 
315c			 
315c			;	; get DO ptr 
315c			; 
315c					if DEBUG_FORTH_WORDS 
315c						DMARK "LP7" 
315c f5				push af  
315d 3a 71 31			ld a, (.dmark)  
3160 32 71 ee			ld (debug_mark),a  
3163 3a 72 31			ld a, (.dmark+1)  
3166 32 72 ee			ld (debug_mark+1),a  
3169 3a 73 31			ld a, (.dmark+2)  
316c 32 73 ee			ld (debug_mark+2),a  
316f 18 03			jr .pastdmark  
3171 ..			.dmark: db "LP7"  
3174 f1			.pastdmark: pop af  
3175			endm  
# End of macro DMARK
3175					CALLMONITOR 
3175 cd 76 15			call break_point_state  
3178				endm  
# End of macro CALLMONITOR
3178					endif 
3178				FORTH_RSP_TOS 
3178 cd a5 1b			call macro_forth_rsp_tos 
317b				endm 
# End of macro FORTH_RSP_TOS
317b			 
317b					if DEBUG_FORTH_WORDS 
317b						DMARK "LP8" 
317b f5				push af  
317c 3a 90 31			ld a, (.dmark)  
317f 32 71 ee			ld (debug_mark),a  
3182 3a 91 31			ld a, (.dmark+1)  
3185 32 72 ee			ld (debug_mark+1),a  
3188 3a 92 31			ld a, (.dmark+2)  
318b 32 73 ee			ld (debug_mark+2),a  
318e 18 03			jr .pastdmark  
3190 ..			.dmark: db "LP8"  
3193 f1			.pastdmark: pop af  
3194			endm  
# End of macro DMARK
3194					CALLMONITOR 
3194 cd 76 15			call break_point_state  
3197				endm  
# End of macro CALLMONITOR
3197					endif 
3197				;push hl 
3197			 
3197				; not going to DO any more 
3197				; get rid of the RSP pointer as DO will add it back in 
3197				;FORTH_RSP_POP 
3197				;pop hl 
3197			 
3197				;ld hl,(cli_ret_sp) 
3197				;ld e, (hl) 
3197				;inc hl 
3197				;ld d, (hl) 
3197				;ex de,hl 
3197 22 03 e6			ld (os_tok_ptr), hl 
319a					if DEBUG_FORTH_WORDS 
319a						DMARK "LP<" 
319a f5				push af  
319b 3a af 31			ld a, (.dmark)  
319e 32 71 ee			ld (debug_mark),a  
31a1 3a b0 31			ld a, (.dmark+1)  
31a4 32 72 ee			ld (debug_mark+1),a  
31a7 3a b1 31			ld a, (.dmark+2)  
31aa 32 73 ee			ld (debug_mark+2),a  
31ad 18 03			jr .pastdmark  
31af ..			.dmark: db "LP<"  
31b2 f1			.pastdmark: pop af  
31b3			endm  
# End of macro DMARK
31b3					CALLMONITOR 
31b3 cd 76 15			call break_point_state  
31b6				endm  
# End of macro CALLMONITOR
31b6				endif 
31b6 c3 e6 1f			jp exec1 
31b9			 
31b9					 
31b9			 
31b9			 
31b9					NEXTW 
31b9 c3 55 1f			jp macro_next 
31bc				endm 
# End of macro NEXTW
31bc			.I:  
31bc			 
31bc				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
31bc 5e				db WORD_SYS_CORE+74             
31bd e7 31			dw .DLOOP            
31bf 02				db 1 + 1 
31c0 .. 00			db "I",0              
31c2				endm 
# End of macro CWHEAD
31c2			; | I ( -- ) Current loop counter | DONE 
31c2					if DEBUG_FORTH_WORDS_KEY 
31c2						DMARK "I.." 
31c2 f5				push af  
31c3 3a d7 31			ld a, (.dmark)  
31c6 32 71 ee			ld (debug_mark),a  
31c9 3a d8 31			ld a, (.dmark+1)  
31cc 32 72 ee			ld (debug_mark+1),a  
31cf 3a d9 31			ld a, (.dmark+2)  
31d2 32 73 ee			ld (debug_mark+2),a  
31d5 18 03			jr .pastdmark  
31d7 ..			.dmark: db "I.."  
31da f1			.pastdmark: pop af  
31db			endm  
# End of macro DMARK
31db						CALLMONITOR 
31db cd 76 15			call break_point_state  
31de				endm  
# End of macro CALLMONITOR
31de					endif 
31de			 
31de 2a 27 e6				ld hl,(os_current_i) 
31e1 cd e7 1b				call forth_push_numhl 
31e4			 
31e4					NEXTW 
31e4 c3 55 1f			jp macro_next 
31e7				endm 
# End of macro NEXTW
31e7			.DLOOP: 
31e7				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
31e7 5f				db WORD_SYS_CORE+75             
31e8 c8 32			dw .REPEAT            
31ea 06				db 5 + 1 
31eb .. 00			db "-LOOP",0              
31f1				endm 
# End of macro CWHEAD
31f1			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
31f1				; pop tos as current loop count to hl 
31f1					if DEBUG_FORTH_WORDS_KEY 
31f1						DMARK "-LP" 
31f1 f5				push af  
31f2 3a 06 32			ld a, (.dmark)  
31f5 32 71 ee			ld (debug_mark),a  
31f8 3a 07 32			ld a, (.dmark+1)  
31fb 32 72 ee			ld (debug_mark+1),a  
31fe 3a 08 32			ld a, (.dmark+2)  
3201 32 73 ee			ld (debug_mark+2),a  
3204 18 03			jr .pastdmark  
3206 ..			.dmark: db "-LP"  
3209 f1			.pastdmark: pop af  
320a			endm  
# End of macro DMARK
320a						CALLMONITOR 
320a cd 76 15			call break_point_state  
320d				endm  
# End of macro CALLMONITOR
320d					endif 
320d			 
320d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
320d			 
320d				FORTH_LOOP_TOS 
320d cd 42 1e			call macro_forth_loop_tos 
3210				endm 
# End of macro FORTH_LOOP_TOS
3210 e5				push hl 
3211			 
3211					if DEBUG_FORTH_WORDS 
3211						DMARK "-LP" 
3211 f5				push af  
3212 3a 26 32			ld a, (.dmark)  
3215 32 71 ee			ld (debug_mark),a  
3218 3a 27 32			ld a, (.dmark+1)  
321b 32 72 ee			ld (debug_mark+1),a  
321e 3a 28 32			ld a, (.dmark+2)  
3221 32 73 ee			ld (debug_mark+2),a  
3224 18 03			jr .pastdmark  
3226 ..			.dmark: db "-LP"  
3229 f1			.pastdmark: pop af  
322a			endm  
# End of macro DMARK
322a						CALLMONITOR 
322a cd 76 15			call break_point_state  
322d				endm  
# End of macro CALLMONITOR
322d					endif 
322d				; next item on the stack is the limit. get it 
322d			 
322d			 
322d				FORTH_LOOP_POP 
322d cd 4c 1e			call macro_forth_loop_pop 
3230				endm 
# End of macro FORTH_LOOP_POP
3230			 
3230				FORTH_LOOP_TOS 
3230 cd 42 1e			call macro_forth_loop_tos 
3233				endm 
# End of macro FORTH_LOOP_TOS
3233			 
3233 d1				pop de		 ; de = i, hl = limit 
3234			 
3234					if DEBUG_FORTH_WORDS 
3234						DMARK "-L1" 
3234 f5				push af  
3235 3a 49 32			ld a, (.dmark)  
3238 32 71 ee			ld (debug_mark),a  
323b 3a 4a 32			ld a, (.dmark+1)  
323e 32 72 ee			ld (debug_mark+1),a  
3241 3a 4b 32			ld a, (.dmark+2)  
3244 32 73 ee			ld (debug_mark+2),a  
3247 18 03			jr .pastdmark  
3249 ..			.dmark: db "-L1"  
324c f1			.pastdmark: pop af  
324d			endm  
# End of macro DMARK
324d						CALLMONITOR 
324d cd 76 15			call break_point_state  
3250				endm  
# End of macro CALLMONITOR
3250					endif 
3250			 
3250				; go back to previous word 
3250			 
3250 d5				push de    ; save I for inc later 
3251			 
3251			 
3251				; get limit 
3251				;  is I at limit? 
3251			 
3251			 
3251					if DEBUG_FORTH_WORDS 
3251						DMARK "-L1" 
3251 f5				push af  
3252 3a 66 32			ld a, (.dmark)  
3255 32 71 ee			ld (debug_mark),a  
3258 3a 67 32			ld a, (.dmark+1)  
325b 32 72 ee			ld (debug_mark+1),a  
325e 3a 68 32			ld a, (.dmark+2)  
3261 32 73 ee			ld (debug_mark+2),a  
3264 18 03			jr .pastdmark  
3266 ..			.dmark: db "-L1"  
3269 f1			.pastdmark: pop af  
326a			endm  
# End of macro DMARK
326a						CALLMONITOR 
326a cd 76 15			call break_point_state  
326d				endm  
# End of macro CALLMONITOR
326d					endif 
326d			 
326d ed 52			sbc hl, de 
326f			 
326f			 
326f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
326f			 
326f 20 26				jr nz, .mloopnotdone 
3271			 
3271 e1				pop hl   ; get rid of saved I 
3272				FORTH_LOOP_POP     ; get rid of limit 
3272 cd 4c 1e			call macro_forth_loop_pop 
3275				endm 
# End of macro FORTH_LOOP_POP
3275			 
3275				FORTH_RSP_POP     ; get rid of DO ptr 
3275 cd af 1b			call macro_forth_rsp_pop 
3278				endm 
# End of macro FORTH_RSP_POP
3278			 
3278			if DEBUG_FORTH_WORDS 
3278						DMARK "-L>" 
3278 f5				push af  
3279 3a 8d 32			ld a, (.dmark)  
327c 32 71 ee			ld (debug_mark),a  
327f 3a 8e 32			ld a, (.dmark+1)  
3282 32 72 ee			ld (debug_mark+1),a  
3285 3a 8f 32			ld a, (.dmark+2)  
3288 32 73 ee			ld (debug_mark+2),a  
328b 18 03			jr .pastdmark  
328d ..			.dmark: db "-L>"  
3290 f1			.pastdmark: pop af  
3291			endm  
# End of macro DMARK
3291				CALLMONITOR 
3291 cd 76 15			call break_point_state  
3294				endm  
# End of macro CALLMONITOR
3294			endif 
3294			 
3294					NEXTW 
3294 c3 55 1f			jp macro_next 
3297				endm 
# End of macro NEXTW
3297				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3297			 
3297			.mloopnotdone: 
3297			 
3297 e1				pop hl    ; get I 
3298 2b				dec hl 
3299			 
3299			   	; save new I 
3299			 
3299			 
3299					; set I counter 
3299			 
3299 22 27 e6				ld (os_current_i), hl 
329c			 
329c					 
329c				FORTH_LOOP_NEXT 
329c cd 0f 1e			call macro_forth_loop_next 
329f				endm 
# End of macro FORTH_LOOP_NEXT
329f			 
329f			 
329f					if DEBUG_FORTH_WORDS 
329f eb						ex de,hl 
32a0					endif 
32a0			 
32a0			;	; get DO ptr 
32a0			; 
32a0				FORTH_RSP_TOS 
32a0 cd a5 1b			call macro_forth_rsp_tos 
32a3				endm 
# End of macro FORTH_RSP_TOS
32a3			 
32a3				;push hl 
32a3			 
32a3				; not going to DO any more 
32a3				; get rid of the RSP pointer as DO will add it back in 
32a3				;FORTH_RSP_POP 
32a3				;pop hl 
32a3			 
32a3			 
32a3 22 03 e6			ld (os_tok_ptr), hl 
32a6					if DEBUG_FORTH_WORDS 
32a6						DMARK "-L<" 
32a6 f5				push af  
32a7 3a bb 32			ld a, (.dmark)  
32aa 32 71 ee			ld (debug_mark),a  
32ad 3a bc 32			ld a, (.dmark+1)  
32b0 32 72 ee			ld (debug_mark+1),a  
32b3 3a bd 32			ld a, (.dmark+2)  
32b6 32 73 ee			ld (debug_mark+2),a  
32b9 18 03			jr .pastdmark  
32bb ..			.dmark: db "-L<"  
32be f1			.pastdmark: pop af  
32bf			endm  
# End of macro DMARK
32bf					CALLMONITOR 
32bf cd 76 15			call break_point_state  
32c2				endm  
# End of macro CALLMONITOR
32c2				endif 
32c2 c3 e6 1f			jp exec1 
32c5			 
32c5					 
32c5			 
32c5			 
32c5			 
32c5				NEXTW 
32c5 c3 55 1f			jp macro_next 
32c8				endm 
# End of macro NEXTW
32c8			 
32c8			 
32c8			 
32c8			 
32c8			.REPEAT: 
32c8				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
32c8 71				db WORD_SYS_CORE+93             
32c9 1b 33			dw .UNTIL            
32cb 06				db 5 + 1 
32cc .. 00			db "REPEAT",0              
32d3				endm 
# End of macro CWHEAD
32d3			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
32d3			;  push pc to rsp stack past the REPEAT 
32d3					if DEBUG_FORTH_WORDS_KEY 
32d3						DMARK "REP" 
32d3 f5				push af  
32d4 3a e8 32			ld a, (.dmark)  
32d7 32 71 ee			ld (debug_mark),a  
32da 3a e9 32			ld a, (.dmark+1)  
32dd 32 72 ee			ld (debug_mark+1),a  
32e0 3a ea 32			ld a, (.dmark+2)  
32e3 32 73 ee			ld (debug_mark+2),a  
32e6 18 03			jr .pastdmark  
32e8 ..			.dmark: db "REP"  
32eb f1			.pastdmark: pop af  
32ec			endm  
# End of macro DMARK
32ec						CALLMONITOR 
32ec cd 76 15			call break_point_state  
32ef				endm  
# End of macro CALLMONITOR
32ef					endif 
32ef			 
32ef 2a 03 e6				ld hl, (os_tok_ptr) 
32f2 23					inc hl   ; R 
32f3 23					inc hl  ; E 
32f4 23					inc hl   ; P 
32f5 23					inc hl   ; E 
32f6 23					inc hl   ; A 
32f7 23					inc hl   ; T 
32f8 23					inc hl   ; zero 
32f9					FORTH_RSP_NEXT 
32f9 cd 8e 1b			call macro_forth_rsp_next 
32fc				endm 
# End of macro FORTH_RSP_NEXT
32fc			 
32fc			 
32fc					if DEBUG_FORTH_WORDS 
32fc						DMARK "REP" 
32fc f5				push af  
32fd 3a 11 33			ld a, (.dmark)  
3300 32 71 ee			ld (debug_mark),a  
3303 3a 12 33			ld a, (.dmark+1)  
3306 32 72 ee			ld (debug_mark+1),a  
3309 3a 13 33			ld a, (.dmark+2)  
330c 32 73 ee			ld (debug_mark+2),a  
330f 18 03			jr .pastdmark  
3311 ..			.dmark: db "REP"  
3314 f1			.pastdmark: pop af  
3315			endm  
# End of macro DMARK
3315						;pop bc    ; TODO BUG ?????? what is this for???? 
3315						CALLMONITOR 
3315 cd 76 15			call break_point_state  
3318				endm  
# End of macro CALLMONITOR
3318					endif 
3318			 
3318					NEXTW 
3318 c3 55 1f			jp macro_next 
331b				endm 
# End of macro NEXTW
331b			;	       NEXTW 
331b			 
331b			.UNTIL: 
331b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
331b 72				db WORD_SYS_CORE+94             
331c b2 33			dw .ENDFLOW            
331e 06				db 5 + 1 
331f .. 00			db "UNTIL",0              
3325				endm 
# End of macro CWHEAD
3325			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3325			 
3325				; pop tos as check 
3325			 
3325				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3325			 
3325				FORTH_DSP_VALUEHL 
3325 cd de 1d			call macro_dsp_valuehl 
3328				endm 
# End of macro FORTH_DSP_VALUEHL
3328			 
3328					if DEBUG_FORTH_WORDS_KEY 
3328						DMARK "UNT" 
3328 f5				push af  
3329 3a 3d 33			ld a, (.dmark)  
332c 32 71 ee			ld (debug_mark),a  
332f 3a 3e 33			ld a, (.dmark+1)  
3332 32 72 ee			ld (debug_mark+1),a  
3335 3a 3f 33			ld a, (.dmark+2)  
3338 32 73 ee			ld (debug_mark+2),a  
333b 18 03			jr .pastdmark  
333d ..			.dmark: db "UNT"  
3340 f1			.pastdmark: pop af  
3341			endm  
# End of macro DMARK
3341						CALLMONITOR 
3341 cd 76 15			call break_point_state  
3344				endm  
# End of macro CALLMONITOR
3344					endif 
3344			 
3344			;	push hl 
3344				FORTH_DSP_POP 
3344 cd 96 1e			call macro_forth_dsp_pop 
3347				endm 
# End of macro FORTH_DSP_POP
3347			 
3347			;	pop hl 
3347			 
3347				; test if true 
3347			 
3347 cd 9e 0d			call ishlzero 
334a			;	ld a,l 
334a			;	add h 
334a			; 
334a			;	cp 0 
334a			 
334a 20 3e			jr nz, .untilnotdone 
334c			 
334c					if DEBUG_FORTH_WORDS 
334c						DMARK "UNf" 
334c f5				push af  
334d 3a 61 33			ld a, (.dmark)  
3350 32 71 ee			ld (debug_mark),a  
3353 3a 62 33			ld a, (.dmark+1)  
3356 32 72 ee			ld (debug_mark+1),a  
3359 3a 63 33			ld a, (.dmark+2)  
335c 32 73 ee			ld (debug_mark+2),a  
335f 18 03			jr .pastdmark  
3361 ..			.dmark: db "UNf"  
3364 f1			.pastdmark: pop af  
3365			endm  
# End of macro DMARK
3365						CALLMONITOR 
3365 cd 76 15			call break_point_state  
3368				endm  
# End of macro CALLMONITOR
3368					endif 
3368			 
3368			 
3368			 
3368				FORTH_RSP_POP     ; get rid of DO ptr 
3368 cd af 1b			call macro_forth_rsp_pop 
336b				endm 
# End of macro FORTH_RSP_POP
336b			 
336b			if DEBUG_FORTH_WORDS 
336b						DMARK "UN>" 
336b f5				push af  
336c 3a 80 33			ld a, (.dmark)  
336f 32 71 ee			ld (debug_mark),a  
3372 3a 81 33			ld a, (.dmark+1)  
3375 32 72 ee			ld (debug_mark+1),a  
3378 3a 82 33			ld a, (.dmark+2)  
337b 32 73 ee			ld (debug_mark+2),a  
337e 18 03			jr .pastdmark  
3380 ..			.dmark: db "UN>"  
3383 f1			.pastdmark: pop af  
3384			endm  
# End of macro DMARK
3384				CALLMONITOR 
3384 cd 76 15			call break_point_state  
3387				endm  
# End of macro CALLMONITOR
3387			endif 
3387			 
3387					NEXTW 
3387 c3 55 1f			jp macro_next 
338a				endm 
# End of macro NEXTW
338a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
338a			 
338a			.untilnotdone: 
338a			 
338a			 
338a			;	; get DO ptr 
338a			; 
338a				FORTH_RSP_TOS 
338a cd a5 1b			call macro_forth_rsp_tos 
338d				endm 
# End of macro FORTH_RSP_TOS
338d			 
338d				;push hl 
338d			 
338d				; not going to DO any more 
338d				; get rid of the RSP pointer as DO will add it back in 
338d				;FORTH_RSP_POP 
338d				;pop hl 
338d			 
338d			 
338d 22 03 e6			ld (os_tok_ptr), hl 
3390					if DEBUG_FORTH_WORDS 
3390						DMARK "UN<" 
3390 f5				push af  
3391 3a a5 33			ld a, (.dmark)  
3394 32 71 ee			ld (debug_mark),a  
3397 3a a6 33			ld a, (.dmark+1)  
339a 32 72 ee			ld (debug_mark+1),a  
339d 3a a7 33			ld a, (.dmark+2)  
33a0 32 73 ee			ld (debug_mark+2),a  
33a3 18 03			jr .pastdmark  
33a5 ..			.dmark: db "UN<"  
33a8 f1			.pastdmark: pop af  
33a9			endm  
# End of macro DMARK
33a9					CALLMONITOR 
33a9 cd 76 15			call break_point_state  
33ac				endm  
# End of macro CALLMONITOR
33ac				endif 
33ac c3 e6 1f			jp exec1 
33af			 
33af					 
33af			 
33af			 
33af					NEXTW 
33af c3 55 1f			jp macro_next 
33b2				endm 
# End of macro NEXTW
33b2			 
33b2			 
33b2			.ENDFLOW: 
33b2			 
33b2			; eof 
33b2			 
# End of file forth_words_flow.asm
33b2			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
33b2			include "forth_words_logic.asm" 
33b2			 
33b2			; | ## Logic Words 
33b2			 
33b2			.NOT: 
33b2				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
33b2 2d				db WORD_SYS_CORE+25             
33b3 fa 33			dw .IS            
33b5 04				db 3 + 1 
33b6 .. 00			db "NOT",0              
33ba				endm 
# End of macro CWHEAD
33ba			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
33ba					if DEBUG_FORTH_WORDS_KEY 
33ba						DMARK "NOT" 
33ba f5				push af  
33bb 3a cf 33			ld a, (.dmark)  
33be 32 71 ee			ld (debug_mark),a  
33c1 3a d0 33			ld a, (.dmark+1)  
33c4 32 72 ee			ld (debug_mark+1),a  
33c7 3a d1 33			ld a, (.dmark+2)  
33ca 32 73 ee			ld (debug_mark+2),a  
33cd 18 03			jr .pastdmark  
33cf ..			.dmark: db "NOT"  
33d2 f1			.pastdmark: pop af  
33d3			endm  
# End of macro DMARK
33d3						CALLMONITOR 
33d3 cd 76 15			call break_point_state  
33d6				endm  
# End of macro CALLMONITOR
33d6					endif 
33d6					FORTH_DSP 
33d6 cd a4 1d			call macro_forth_dsp 
33d9				endm 
# End of macro FORTH_DSP
33d9 7e					ld a,(hl)	; get type of value on TOS 
33da fe 02				cp DS_TYPE_INUM  
33dc 28 03				jr z, .noti 
33de					NEXTW 
33de c3 55 1f			jp macro_next 
33e1				endm 
# End of macro NEXTW
33e1			.noti:          FORTH_DSP_VALUEHL 
33e1 cd de 1d			call macro_dsp_valuehl 
33e4				endm 
# End of macro FORTH_DSP_VALUEHL
33e4			;		push hl 
33e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33e4 cd 96 1e			call macro_forth_dsp_pop 
33e7				endm 
# End of macro FORTH_DSP_POP
33e7			;		pop hl 
33e7 3e 00				ld a,0 
33e9 bd					cp l 
33ea 28 04				jr z, .not2t 
33ec 2e 00				ld l, 0 
33ee 18 02				jr .notip 
33f0			 
33f0 2e ff		.not2t:		ld l, 255 
33f2			 
33f2 26 00		.notip:		ld h, 0	 
33f4			 
33f4 cd e7 1b				call forth_push_numhl 
33f7					NEXTW 
33f7 c3 55 1f			jp macro_next 
33fa				endm 
# End of macro NEXTW
33fa			 
33fa			.IS: 
33fa				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
33fa 2d				db WORD_SYS_CORE+25             
33fb 20 34			dw .LZERO            
33fd 03				db 2 + 1 
33fe .. 00			db "IS",0              
3401				endm 
# End of macro CWHEAD
3401			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3401					if DEBUG_FORTH_WORDS_KEY 
3401						DMARK "IS." 
3401 f5				push af  
3402 3a 16 34			ld a, (.dmark)  
3405 32 71 ee			ld (debug_mark),a  
3408 3a 17 34			ld a, (.dmark+1)  
340b 32 72 ee			ld (debug_mark+1),a  
340e 3a 18 34			ld a, (.dmark+2)  
3411 32 73 ee			ld (debug_mark+2),a  
3414 18 03			jr .pastdmark  
3416 ..			.dmark: db "IS."  
3419 f1			.pastdmark: pop af  
341a			endm  
# End of macro DMARK
341a						CALLMONITOR 
341a cd 76 15			call break_point_state  
341d				endm  
# End of macro CALLMONITOR
341d					endif 
341d					NEXTW 
341d c3 55 1f			jp macro_next 
3420				endm 
# End of macro NEXTW
3420			.LZERO: 
3420				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3420 2d				db WORD_SYS_CORE+25             
3421 2a 34			dw .TZERO            
3423 03				db 2 + 1 
3424 .. 00			db "0<",0              
3427				endm 
# End of macro CWHEAD
3427			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3427					NEXTW 
3427 c3 55 1f			jp macro_next 
342a				endm 
# End of macro NEXTW
342a			.TZERO: 
342a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
342a 2e				db WORD_SYS_CORE+26             
342b 71 34			dw .LESS            
342d 03				db 2 + 1 
342e .. 00			db "0=",0              
3431				endm 
# End of macro CWHEAD
3431			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3431				; TODO add floating point number detection 
3431					;v5 FORTH_DSP_VALUE 
3431					if DEBUG_FORTH_WORDS_KEY 
3431						DMARK "0=." 
3431 f5				push af  
3432 3a 46 34			ld a, (.dmark)  
3435 32 71 ee			ld (debug_mark),a  
3438 3a 47 34			ld a, (.dmark+1)  
343b 32 72 ee			ld (debug_mark+1),a  
343e 3a 48 34			ld a, (.dmark+2)  
3441 32 73 ee			ld (debug_mark+2),a  
3444 18 03			jr .pastdmark  
3446 ..			.dmark: db "0=."  
3449 f1			.pastdmark: pop af  
344a			endm  
# End of macro DMARK
344a						CALLMONITOR 
344a cd 76 15			call break_point_state  
344d				endm  
# End of macro CALLMONITOR
344d					endif 
344d					FORTH_DSP 
344d cd a4 1d			call macro_forth_dsp 
3450				endm 
# End of macro FORTH_DSP
3450 7e					ld a,(hl)	; get type of value on TOS 
3451 fe 02				cp DS_TYPE_INUM  
3453 28 00				jr z, .tz_inum 
3455			 
3455				if FORTH_ENABLE_FLOATMATH 
3455					jr .tz_done 
3455			 
3455				endif 
3455					 
3455			 
3455			.tz_inum: 
3455					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3455 cd de 1d			call macro_dsp_valuehl 
3458				endm 
# End of macro FORTH_DSP_VALUEHL
3458			 
3458			;		push hl 
3458			 
3458					; destroy value TOS 
3458			 
3458					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3458 cd 96 1e			call macro_forth_dsp_pop 
345b				endm 
# End of macro FORTH_DSP_POP
345b			 
345b			;		pop hl 
345b			 
345b 3e 00				ld a,0 
345d			 
345d bd					cp l 
345e 20 08				jr nz, .tz_notzero 
3460			 
3460 bc					cp h 
3461			 
3461 20 05				jr nz, .tz_notzero 
3463			 
3463			 
3463 21 01 00				ld hl, FORTH_TRUE 
3466 18 03				jr .tz_done 
3468			 
3468 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
346b			 
346b					; push value back onto stack for another op etc 
346b			 
346b			.tz_done: 
346b cd e7 1b				call forth_push_numhl 
346e			 
346e					NEXTW 
346e c3 55 1f			jp macro_next 
3471				endm 
# End of macro NEXTW
3471			.LESS: 
3471				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3471 2f				db WORD_SYS_CORE+27             
3472 da 34			dw .GT            
3474 02				db 1 + 1 
3475 .. 00			db "<",0              
3477				endm 
# End of macro CWHEAD
3477			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3477				; TODO add floating point number detection 
3477					if DEBUG_FORTH_WORDS_KEY 
3477						DMARK "LES" 
3477 f5				push af  
3478 3a 8c 34			ld a, (.dmark)  
347b 32 71 ee			ld (debug_mark),a  
347e 3a 8d 34			ld a, (.dmark+1)  
3481 32 72 ee			ld (debug_mark+1),a  
3484 3a 8e 34			ld a, (.dmark+2)  
3487 32 73 ee			ld (debug_mark+2),a  
348a 18 03			jr .pastdmark  
348c ..			.dmark: db "LES"  
348f f1			.pastdmark: pop af  
3490			endm  
# End of macro DMARK
3490						CALLMONITOR 
3490 cd 76 15			call break_point_state  
3493				endm  
# End of macro CALLMONITOR
3493					endif 
3493					FORTH_DSP 
3493 cd a4 1d			call macro_forth_dsp 
3496				endm 
# End of macro FORTH_DSP
3496					;v5 FORTH_DSP_VALUE 
3496 7e					ld a,(hl)	; get type of value on TOS 
3497 fe 02				cp DS_TYPE_INUM  
3499 28 00				jr z, .less_inum 
349b			 
349b				if FORTH_ENABLE_FLOATMATH 
349b					jr .less_done 
349b			 
349b				endif 
349b					 
349b			 
349b			.less_inum: 
349b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
349b cd de 1d			call macro_dsp_valuehl 
349e				endm 
# End of macro FORTH_DSP_VALUEHL
349e			 
349e e5					push hl  ; u2 
349f			 
349f					; destroy value TOS 
349f			 
349f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
349f cd 96 1e			call macro_forth_dsp_pop 
34a2				endm 
# End of macro FORTH_DSP_POP
34a2			 
34a2			 
34a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34a2 cd de 1d			call macro_dsp_valuehl 
34a5				endm 
# End of macro FORTH_DSP_VALUEHL
34a5			 
34a5 e5					push hl    ; u1 
34a6			 
34a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34a6 cd 96 1e			call macro_forth_dsp_pop 
34a9				endm 
# End of macro FORTH_DSP_POP
34a9			 
34a9			 
34a9 b7			 or a      ;clear carry flag 
34aa 01 00 00		 ld bc, FORTH_FALSE 
34ad e1			  pop hl    ; u1 
34ae d1			  pop de    ; u2 
34af ed 52		  sbc hl,de 
34b1 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
34b3			 
34b3 01 01 00		 ld bc, FORTH_TRUE 
34b6			.lscont:  
34b6 c5					push bc 
34b7 e1					pop hl 
34b8			 
34b8					if DEBUG_FORTH_WORDS 
34b8						DMARK "LT1" 
34b8 f5				push af  
34b9 3a cd 34			ld a, (.dmark)  
34bc 32 71 ee			ld (debug_mark),a  
34bf 3a ce 34			ld a, (.dmark+1)  
34c2 32 72 ee			ld (debug_mark+1),a  
34c5 3a cf 34			ld a, (.dmark+2)  
34c8 32 73 ee			ld (debug_mark+2),a  
34cb 18 03			jr .pastdmark  
34cd ..			.dmark: db "LT1"  
34d0 f1			.pastdmark: pop af  
34d1			endm  
# End of macro DMARK
34d1						CALLMONITOR 
34d1 cd 76 15			call break_point_state  
34d4				endm  
# End of macro CALLMONITOR
34d4					endif 
34d4 cd e7 1b				call forth_push_numhl 
34d7			 
34d7					NEXTW 
34d7 c3 55 1f			jp macro_next 
34da				endm 
# End of macro NEXTW
34da			.GT: 
34da				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
34da 30				db WORD_SYS_CORE+28             
34db 43 35			dw .EQUAL            
34dd 02				db 1 + 1 
34de .. 00			db ">",0              
34e0				endm 
# End of macro CWHEAD
34e0			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
34e0				; TODO add floating point number detection 
34e0					if DEBUG_FORTH_WORDS_KEY 
34e0						DMARK "GRT" 
34e0 f5				push af  
34e1 3a f5 34			ld a, (.dmark)  
34e4 32 71 ee			ld (debug_mark),a  
34e7 3a f6 34			ld a, (.dmark+1)  
34ea 32 72 ee			ld (debug_mark+1),a  
34ed 3a f7 34			ld a, (.dmark+2)  
34f0 32 73 ee			ld (debug_mark+2),a  
34f3 18 03			jr .pastdmark  
34f5 ..			.dmark: db "GRT"  
34f8 f1			.pastdmark: pop af  
34f9			endm  
# End of macro DMARK
34f9						CALLMONITOR 
34f9 cd 76 15			call break_point_state  
34fc				endm  
# End of macro CALLMONITOR
34fc					endif 
34fc					FORTH_DSP 
34fc cd a4 1d			call macro_forth_dsp 
34ff				endm 
# End of macro FORTH_DSP
34ff					;FORTH_DSP_VALUE 
34ff 7e					ld a,(hl)	; get type of value on TOS 
3500 fe 02				cp DS_TYPE_INUM  
3502 28 00				jr z, .gt_inum 
3504			 
3504				if FORTH_ENABLE_FLOATMATH 
3504					jr .gt_done 
3504			 
3504				endif 
3504					 
3504			 
3504			.gt_inum: 
3504					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3504 cd de 1d			call macro_dsp_valuehl 
3507				endm 
# End of macro FORTH_DSP_VALUEHL
3507			 
3507 e5					push hl  ; u2 
3508			 
3508					; destroy value TOS 
3508			 
3508					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3508 cd 96 1e			call macro_forth_dsp_pop 
350b				endm 
# End of macro FORTH_DSP_POP
350b			 
350b			 
350b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
350b cd de 1d			call macro_dsp_valuehl 
350e				endm 
# End of macro FORTH_DSP_VALUEHL
350e			 
350e e5					push hl    ; u1 
350f			 
350f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
350f cd 96 1e			call macro_forth_dsp_pop 
3512				endm 
# End of macro FORTH_DSP_POP
3512			 
3512			 
3512 b7			 or a      ;clear carry flag 
3513 01 00 00		 ld bc, FORTH_FALSE 
3516 e1			  pop hl    ; u1 
3517 d1			  pop de    ; u2 
3518 ed 52		  sbc hl,de 
351a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
351c			 
351c 01 01 00		 ld bc, FORTH_TRUE 
351f			.gtcont:  
351f c5					push bc 
3520 e1					pop hl 
3521			 
3521					if DEBUG_FORTH_WORDS 
3521						DMARK "GT1" 
3521 f5				push af  
3522 3a 36 35			ld a, (.dmark)  
3525 32 71 ee			ld (debug_mark),a  
3528 3a 37 35			ld a, (.dmark+1)  
352b 32 72 ee			ld (debug_mark+1),a  
352e 3a 38 35			ld a, (.dmark+2)  
3531 32 73 ee			ld (debug_mark+2),a  
3534 18 03			jr .pastdmark  
3536 ..			.dmark: db "GT1"  
3539 f1			.pastdmark: pop af  
353a			endm  
# End of macro DMARK
353a						CALLMONITOR 
353a cd 76 15			call break_point_state  
353d				endm  
# End of macro CALLMONITOR
353d					endif 
353d cd e7 1b				call forth_push_numhl 
3540			 
3540					NEXTW 
3540 c3 55 1f			jp macro_next 
3543				endm 
# End of macro NEXTW
3543			.EQUAL: 
3543				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3543 31				db WORD_SYS_CORE+29             
3544 ae 35			dw .ENDLOGIC            
3546 02				db 1 + 1 
3547 .. 00			db "=",0              
3549				endm 
# End of macro CWHEAD
3549			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3549				; TODO add floating point number detection 
3549					if DEBUG_FORTH_WORDS_KEY 
3549						DMARK "EQ." 
3549 f5				push af  
354a 3a 5e 35			ld a, (.dmark)  
354d 32 71 ee			ld (debug_mark),a  
3550 3a 5f 35			ld a, (.dmark+1)  
3553 32 72 ee			ld (debug_mark+1),a  
3556 3a 60 35			ld a, (.dmark+2)  
3559 32 73 ee			ld (debug_mark+2),a  
355c 18 03			jr .pastdmark  
355e ..			.dmark: db "EQ."  
3561 f1			.pastdmark: pop af  
3562			endm  
# End of macro DMARK
3562						CALLMONITOR 
3562 cd 76 15			call break_point_state  
3565				endm  
# End of macro CALLMONITOR
3565					endif 
3565					FORTH_DSP 
3565 cd a4 1d			call macro_forth_dsp 
3568				endm 
# End of macro FORTH_DSP
3568					;v5 FORTH_DSP_VALUE 
3568 7e					ld a,(hl)	; get type of value on TOS 
3569 fe 02				cp DS_TYPE_INUM  
356b 28 00				jr z, .eq_inum 
356d			 
356d				if FORTH_ENABLE_FLOATMATH 
356d					jr .eq_done 
356d			 
356d				endif 
356d					 
356d			 
356d			.eq_inum: 
356d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
356d cd de 1d			call macro_dsp_valuehl 
3570				endm 
# End of macro FORTH_DSP_VALUEHL
3570			 
3570 e5					push hl 
3571			 
3571					; destroy value TOS 
3571			 
3571					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3571 cd 96 1e			call macro_forth_dsp_pop 
3574				endm 
# End of macro FORTH_DSP_POP
3574			 
3574			 
3574					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3574 cd de 1d			call macro_dsp_valuehl 
3577				endm 
# End of macro FORTH_DSP_VALUEHL
3577			 
3577					; one value on hl get other one back 
3577			 
3577 e5					push hl 
3578			 
3578					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3578 cd 96 1e			call macro_forth_dsp_pop 
357b				endm 
# End of macro FORTH_DSP_POP
357b			 
357b 0e 00				ld c, FORTH_FALSE 
357d			 
357d e1					pop hl 
357e d1					pop de 
357f			 
357f 7b					ld a, e 
3580 bd					cp l 
3581			 
3581 20 06				jr nz, .eq_done 
3583			 
3583 7a					ld a, d 
3584 bc					cp h 
3585			 
3585 20 02				jr nz, .eq_done 
3587			 
3587 0e 01				ld c, FORTH_TRUE 
3589					 
3589			 
3589			 
3589			.eq_done: 
3589			 
3589					; TODO push value back onto stack for another op etc 
3589			 
3589 26 00				ld h, 0 
358b 69					ld l, c 
358c					if DEBUG_FORTH_WORDS 
358c						DMARK "EQ1" 
358c f5				push af  
358d 3a a1 35			ld a, (.dmark)  
3590 32 71 ee			ld (debug_mark),a  
3593 3a a2 35			ld a, (.dmark+1)  
3596 32 72 ee			ld (debug_mark+1),a  
3599 3a a3 35			ld a, (.dmark+2)  
359c 32 73 ee			ld (debug_mark+2),a  
359f 18 03			jr .pastdmark  
35a1 ..			.dmark: db "EQ1"  
35a4 f1			.pastdmark: pop af  
35a5			endm  
# End of macro DMARK
35a5						CALLMONITOR 
35a5 cd 76 15			call break_point_state  
35a8				endm  
# End of macro CALLMONITOR
35a8					endif 
35a8 cd e7 1b				call forth_push_numhl 
35ab			 
35ab					NEXTW 
35ab c3 55 1f			jp macro_next 
35ae				endm 
# End of macro NEXTW
35ae			 
35ae			 
35ae			.ENDLOGIC: 
35ae			; eof 
35ae			 
35ae			 
# End of file forth_words_logic.asm
35ae			include "forth_words_maths.asm" 
35ae			 
35ae			; | ## Maths Words 
35ae			 
35ae			.PLUS:	 
35ae				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
35ae 15				db WORD_SYS_CORE+1             
35af f0 35			dw .NEG            
35b1 02				db 1 + 1 
35b2 .. 00			db "+",0              
35b4				endm 
# End of macro CWHEAD
35b4			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
35b4					if DEBUG_FORTH_WORDS_KEY 
35b4						DMARK "PLU" 
35b4 f5				push af  
35b5 3a c9 35			ld a, (.dmark)  
35b8 32 71 ee			ld (debug_mark),a  
35bb 3a ca 35			ld a, (.dmark+1)  
35be 32 72 ee			ld (debug_mark+1),a  
35c1 3a cb 35			ld a, (.dmark+2)  
35c4 32 73 ee			ld (debug_mark+2),a  
35c7 18 03			jr .pastdmark  
35c9 ..			.dmark: db "PLU"  
35cc f1			.pastdmark: pop af  
35cd			endm  
# End of macro DMARK
35cd						CALLMONITOR 
35cd cd 76 15			call break_point_state  
35d0				endm  
# End of macro CALLMONITOR
35d0					endif 
35d0					; add top two values and push back result 
35d0			 
35d0					;for v5 FORTH_DSP_VALUE 
35d0					FORTH_DSP 
35d0 cd a4 1d			call macro_forth_dsp 
35d3				endm 
# End of macro FORTH_DSP
35d3 7e					ld a,(hl)	; get type of value on TOS 
35d4 fe 02				cp DS_TYPE_INUM  
35d6 28 03				jr z, .dot_inum 
35d8			 
35d8					NEXTW 
35d8 c3 55 1f			jp macro_next 
35db				endm 
# End of macro NEXTW
35db			 
35db			; float maths 
35db			 
35db				if FORTH_ENABLE_FLOATMATH 
35db						inc hl      ; now at start of numeric as string 
35db			 
35db					if DEBUG_FORTH_MATHS 
35db						DMARK "ADD" 
35db				CALLMONITOR 
35db					endif 
35db			 
35db					;ld ix, hl 
35db					call CON 
35db			 
35db			 
35db					push hl 
35db					 
35db					 
35db			 
35db						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
35db			 
35db					; get next number 
35db			 
35db						FORTH_DSP_VALUE 
35db			 
35db						inc hl      ; now at start of numeric as string 
35db			 
35db					;ld ix, hl 
35db					call CON 
35db			 
35db					push hl 
35db			 
35db			 
35db						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35db			 
35db						; TODO do add 
35db			 
35db						call IADD 
35db			 
35db						; TODO get result back as ascii 
35db			 
35db						; TODO push result  
35db			 
35db			 
35db			 
35db						jr .dot_done 
35db				endif 
35db			 
35db			.dot_inum: 
35db			 
35db			 
35db					if DEBUG_FORTH_DOT 
35db						DMARK "+IT" 
35db				CALLMONITOR 
35db					endif 
35db			 
35db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35db cd de 1d			call macro_dsp_valuehl 
35de				endm 
# End of macro FORTH_DSP_VALUEHL
35de			 
35de				; TODO add floating point number detection 
35de			 
35de e5					push hl 
35df			 
35df					; destroy value TOS 
35df			 
35df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35df cd 96 1e			call macro_forth_dsp_pop 
35e2				endm 
# End of macro FORTH_DSP_POP
35e2			 
35e2			 
35e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e2 cd de 1d			call macro_dsp_valuehl 
35e5				endm 
# End of macro FORTH_DSP_VALUEHL
35e5			 
35e5					; one value on hl get other one back 
35e5			 
35e5 d1					pop de 
35e6			 
35e6					; do the add 
35e6			 
35e6 19					add hl,de 
35e7			 
35e7					; save it 
35e7			 
35e7			;		push hl	 
35e7			 
35e7					; 
35e7			 
35e7					; destroy value TOS 
35e7			 
35e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e7 cd 96 1e			call macro_forth_dsp_pop 
35ea				endm 
# End of macro FORTH_DSP_POP
35ea			 
35ea					; TODO push value back onto stack for another op etc 
35ea			 
35ea			;		pop hl 
35ea			 
35ea			.dot_done: 
35ea cd e7 1b				call forth_push_numhl 
35ed			 
35ed					NEXTW 
35ed c3 55 1f			jp macro_next 
35f0				endm 
# End of macro NEXTW
35f0			.NEG: 
35f0			 
35f0				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
35f0 17				db WORD_SYS_CORE+3             
35f1 33 36			dw .DIV            
35f3 02				db 1 + 1 
35f4 .. 00			db "-",0              
35f6				endm 
# End of macro CWHEAD
35f6			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
35f6					if DEBUG_FORTH_WORDS_KEY 
35f6						DMARK "SUB" 
35f6 f5				push af  
35f7 3a 0b 36			ld a, (.dmark)  
35fa 32 71 ee			ld (debug_mark),a  
35fd 3a 0c 36			ld a, (.dmark+1)  
3600 32 72 ee			ld (debug_mark+1),a  
3603 3a 0d 36			ld a, (.dmark+2)  
3606 32 73 ee			ld (debug_mark+2),a  
3609 18 03			jr .pastdmark  
360b ..			.dmark: db "SUB"  
360e f1			.pastdmark: pop af  
360f			endm  
# End of macro DMARK
360f						CALLMONITOR 
360f cd 76 15			call break_point_state  
3612				endm  
# End of macro CALLMONITOR
3612					endif 
3612			 
3612			 
3612				; TODO add floating point number detection 
3612					; v5 FORTH_DSP_VALUE 
3612					FORTH_DSP 
3612 cd a4 1d			call macro_forth_dsp 
3615				endm 
# End of macro FORTH_DSP
3615 7e					ld a,(hl)	; get type of value on TOS 
3616 fe 02				cp DS_TYPE_INUM  
3618 28 03				jr z, .neg_inum 
361a			 
361a					NEXTW 
361a c3 55 1f			jp macro_next 
361d				endm 
# End of macro NEXTW
361d			 
361d			; float maths 
361d			 
361d				if FORTH_ENABLE_FLOATMATH 
361d					jr .neg_done 
361d			 
361d				endif 
361d					 
361d			 
361d			.neg_inum: 
361d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
361d cd de 1d			call macro_dsp_valuehl 
3620				endm 
# End of macro FORTH_DSP_VALUEHL
3620			 
3620 e5					push hl 
3621			 
3621					; destroy value TOS 
3621			 
3621					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3621 cd 96 1e			call macro_forth_dsp_pop 
3624				endm 
# End of macro FORTH_DSP_POP
3624			 
3624			 
3624					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3624 cd de 1d			call macro_dsp_valuehl 
3627				endm 
# End of macro FORTH_DSP_VALUEHL
3627			 
3627					; one value on hl get other one back 
3627			 
3627 d1					pop de 
3628			 
3628					; do the sub 
3628			;		ex de, hl 
3628			 
3628 ed 52				sbc hl,de 
362a			 
362a					; save it 
362a			 
362a			;		push hl	 
362a			 
362a					; 
362a			 
362a					; destroy value TOS 
362a			 
362a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
362a cd 96 1e			call macro_forth_dsp_pop 
362d				endm 
# End of macro FORTH_DSP_POP
362d			 
362d					; TODO push value back onto stack for another op etc 
362d			 
362d			;		pop hl 
362d			 
362d cd e7 1b				call forth_push_numhl 
3630			.neg_done: 
3630			 
3630					NEXTW 
3630 c3 55 1f			jp macro_next 
3633				endm 
# End of macro NEXTW
3633			.DIV: 
3633				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3633 18				db WORD_SYS_CORE+4             
3634 80 36			dw .MUL            
3636 02				db 1 + 1 
3637 .. 00			db "/",0              
3639				endm 
# End of macro CWHEAD
3639			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3639					if DEBUG_FORTH_WORDS_KEY 
3639						DMARK "DIV" 
3639 f5				push af  
363a 3a 4e 36			ld a, (.dmark)  
363d 32 71 ee			ld (debug_mark),a  
3640 3a 4f 36			ld a, (.dmark+1)  
3643 32 72 ee			ld (debug_mark+1),a  
3646 3a 50 36			ld a, (.dmark+2)  
3649 32 73 ee			ld (debug_mark+2),a  
364c 18 03			jr .pastdmark  
364e ..			.dmark: db "DIV"  
3651 f1			.pastdmark: pop af  
3652			endm  
# End of macro DMARK
3652						CALLMONITOR 
3652 cd 76 15			call break_point_state  
3655				endm  
# End of macro CALLMONITOR
3655					endif 
3655				; TODO add floating point number detection 
3655					; v5 FORTH_DSP_VALUE 
3655					FORTH_DSP 
3655 cd a4 1d			call macro_forth_dsp 
3658				endm 
# End of macro FORTH_DSP
3658 7e					ld a,(hl)	; get type of value on TOS 
3659 fe 02				cp DS_TYPE_INUM  
365b 28 03				jr z, .div_inum 
365d			 
365d				if FORTH_ENABLE_FLOATMATH 
365d					jr .div_done 
365d			 
365d				endif 
365d					NEXTW 
365d c3 55 1f			jp macro_next 
3660				endm 
# End of macro NEXTW
3660			.div_inum: 
3660			 
3660					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3660 cd de 1d			call macro_dsp_valuehl 
3663				endm 
# End of macro FORTH_DSP_VALUEHL
3663			 
3663 e5					push hl    ; to go to bc 
3664			 
3664					; destroy value TOS 
3664			 
3664					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3664 cd 96 1e			call macro_forth_dsp_pop 
3667				endm 
# End of macro FORTH_DSP_POP
3667			 
3667			 
3667					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3667 cd de 1d			call macro_dsp_valuehl 
366a				endm 
# End of macro FORTH_DSP_VALUEHL
366a			 
366a					; hl to go to de 
366a			 
366a e5					push hl 
366b			 
366b c1					pop bc 
366c d1					pop de		 
366d			 
366d			 
366d					if DEBUG_FORTH_MATHS 
366d						DMARK "DIV" 
366d				CALLMONITOR 
366d					endif 
366d					; one value on hl but move to a get other one back 
366d			 
366d			        
366d cd d2 0c			call Div16 
3670			 
3670			;	push af	 
3670 e5				push hl 
3671 c5				push bc 
3672			 
3672					if DEBUG_FORTH_MATHS 
3672						DMARK "DI1" 
3672				CALLMONITOR 
3672					endif 
3672			 
3672					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3672 cd 96 1e			call macro_forth_dsp_pop 
3675				endm 
# End of macro FORTH_DSP_POP
3675			 
3675			 
3675			 
3675 e1					pop hl    ; result 
3676			 
3676 cd e7 1b				call forth_push_numhl 
3679			 
3679 e1					pop hl    ; reminder 
367a			;		ld h,0 
367a			;		ld l,d 
367a			 
367a cd e7 1b				call forth_push_numhl 
367d			.div_done: 
367d					NEXTW 
367d c3 55 1f			jp macro_next 
3680				endm 
# End of macro NEXTW
3680			.MUL: 
3680				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3680 19				db WORD_SYS_CORE+5             
3681 c5 36			dw .MIN            
3683 02				db 1 + 1 
3684 .. 00			db "*",0              
3686				endm 
# End of macro CWHEAD
3686			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3686				; TODO add floating point number detection 
3686					if DEBUG_FORTH_WORDS_KEY 
3686						DMARK "MUL" 
3686 f5				push af  
3687 3a 9b 36			ld a, (.dmark)  
368a 32 71 ee			ld (debug_mark),a  
368d 3a 9c 36			ld a, (.dmark+1)  
3690 32 72 ee			ld (debug_mark+1),a  
3693 3a 9d 36			ld a, (.dmark+2)  
3696 32 73 ee			ld (debug_mark+2),a  
3699 18 03			jr .pastdmark  
369b ..			.dmark: db "MUL"  
369e f1			.pastdmark: pop af  
369f			endm  
# End of macro DMARK
369f						CALLMONITOR 
369f cd 76 15			call break_point_state  
36a2				endm  
# End of macro CALLMONITOR
36a2					endif 
36a2					FORTH_DSP 
36a2 cd a4 1d			call macro_forth_dsp 
36a5				endm 
# End of macro FORTH_DSP
36a5					; v5 FORTH_DSP_VALUE 
36a5 7e					ld a,(hl)	; get type of value on TOS 
36a6 fe 02				cp DS_TYPE_INUM  
36a8 28 03				jr z, .mul_inum 
36aa			 
36aa				if FORTH_ENABLE_FLOATMATH 
36aa					jr .mul_done 
36aa			 
36aa				endif 
36aa			 
36aa					NEXTW 
36aa c3 55 1f			jp macro_next 
36ad				endm 
# End of macro NEXTW
36ad			.mul_inum:	 
36ad			 
36ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ad cd de 1d			call macro_dsp_valuehl 
36b0				endm 
# End of macro FORTH_DSP_VALUEHL
36b0			 
36b0 e5					push hl 
36b1			 
36b1					; destroy value TOS 
36b1			 
36b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b1 cd 96 1e			call macro_forth_dsp_pop 
36b4				endm 
# End of macro FORTH_DSP_POP
36b4			 
36b4			 
36b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b4 cd de 1d			call macro_dsp_valuehl 
36b7				endm 
# End of macro FORTH_DSP_VALUEHL
36b7			 
36b7					; one value on hl but move to a get other one back 
36b7			 
36b7 7d					ld a, l 
36b8			 
36b8 d1					pop de 
36b9			 
36b9					; do the mull 
36b9			;		ex de, hl 
36b9			 
36b9 cd f8 0c				call Mult16 
36bc					; save it 
36bc			 
36bc			;		push hl	 
36bc			 
36bc					; 
36bc			 
36bc					; destroy value TOS 
36bc			 
36bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36bc cd 96 1e			call macro_forth_dsp_pop 
36bf				endm 
# End of macro FORTH_DSP_POP
36bf			 
36bf					; TODO push value back onto stack for another op etc 
36bf			 
36bf			;		pop hl 
36bf			 
36bf cd e7 1b				call forth_push_numhl 
36c2			 
36c2			.mul_done: 
36c2					NEXTW 
36c2 c3 55 1f			jp macro_next 
36c5				endm 
# End of macro NEXTW
36c5			 
36c5			 
36c5			 
36c5			 
36c5			.MIN: 
36c5				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
36c5 49				db WORD_SYS_CORE+53             
36c6 46 37			dw .MAX            
36c8 04				db 3 + 1 
36c9 .. 00			db "MIN",0              
36cd				endm 
# End of macro CWHEAD
36cd			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
36cd					if DEBUG_FORTH_WORDS_KEY 
36cd						DMARK "MIN" 
36cd f5				push af  
36ce 3a e2 36			ld a, (.dmark)  
36d1 32 71 ee			ld (debug_mark),a  
36d4 3a e3 36			ld a, (.dmark+1)  
36d7 32 72 ee			ld (debug_mark+1),a  
36da 3a e4 36			ld a, (.dmark+2)  
36dd 32 73 ee			ld (debug_mark+2),a  
36e0 18 03			jr .pastdmark  
36e2 ..			.dmark: db "MIN"  
36e5 f1			.pastdmark: pop af  
36e6			endm  
# End of macro DMARK
36e6						CALLMONITOR 
36e6 cd 76 15			call break_point_state  
36e9				endm  
# End of macro CALLMONITOR
36e9					endif 
36e9					; get u2 
36e9			 
36e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e9 cd de 1d			call macro_dsp_valuehl 
36ec				endm 
# End of macro FORTH_DSP_VALUEHL
36ec			 
36ec e5					push hl   ; u2 
36ed			 
36ed					; destroy value TOS 
36ed			 
36ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ed cd 96 1e			call macro_forth_dsp_pop 
36f0				endm 
# End of macro FORTH_DSP_POP
36f0			 
36f0					; get u1 
36f0			 
36f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f0 cd de 1d			call macro_dsp_valuehl 
36f3				endm 
# End of macro FORTH_DSP_VALUEHL
36f3			 
36f3 e5					push hl  ; u1 
36f4			 
36f4					; destroy value TOS 
36f4			 
36f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f4 cd 96 1e			call macro_forth_dsp_pop 
36f7				endm 
# End of macro FORTH_DSP_POP
36f7			 
36f7 b7			 or a      ;clear carry flag 
36f8 e1			  pop hl    ; u1 
36f9 d1			  pop de    ; u2 
36fa e5				push hl   ; saved in case hl is lowest 
36fb ed 52		  sbc hl,de 
36fd 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
36ff			 
36ff e1				pop hl 
3700					if DEBUG_FORTH_WORDS 
3700						DMARK "MIN" 
3700 f5				push af  
3701 3a 15 37			ld a, (.dmark)  
3704 32 71 ee			ld (debug_mark),a  
3707 3a 16 37			ld a, (.dmark+1)  
370a 32 72 ee			ld (debug_mark+1),a  
370d 3a 17 37			ld a, (.dmark+2)  
3710 32 73 ee			ld (debug_mark+2),a  
3713 18 03			jr .pastdmark  
3715 ..			.dmark: db "MIN"  
3718 f1			.pastdmark: pop af  
3719			endm  
# End of macro DMARK
3719						CALLMONITOR 
3719 cd 76 15			call break_point_state  
371c				endm  
# End of macro CALLMONITOR
371c					endif 
371c cd e7 1b				call forth_push_numhl 
371f			 
371f				       NEXTW 
371f c3 55 1f			jp macro_next 
3722				endm 
# End of macro NEXTW
3722			 
3722			.mincont:  
3722 c1				pop bc   ; tidy up 
3723 eb				ex de , hl  
3724					if DEBUG_FORTH_WORDS 
3724						DMARK "MI1" 
3724 f5				push af  
3725 3a 39 37			ld a, (.dmark)  
3728 32 71 ee			ld (debug_mark),a  
372b 3a 3a 37			ld a, (.dmark+1)  
372e 32 72 ee			ld (debug_mark+1),a  
3731 3a 3b 37			ld a, (.dmark+2)  
3734 32 73 ee			ld (debug_mark+2),a  
3737 18 03			jr .pastdmark  
3739 ..			.dmark: db "MI1"  
373c f1			.pastdmark: pop af  
373d			endm  
# End of macro DMARK
373d						CALLMONITOR 
373d cd 76 15			call break_point_state  
3740				endm  
# End of macro CALLMONITOR
3740					endif 
3740 cd e7 1b				call forth_push_numhl 
3743			 
3743				       NEXTW 
3743 c3 55 1f			jp macro_next 
3746				endm 
# End of macro NEXTW
3746			.MAX: 
3746				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3746 4a				db WORD_SYS_CORE+54             
3747 c7 37			dw .RND16            
3749 04				db 3 + 1 
374a .. 00			db "MAX",0              
374e				endm 
# End of macro CWHEAD
374e			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
374e					if DEBUG_FORTH_WORDS_KEY 
374e						DMARK "MAX" 
374e f5				push af  
374f 3a 63 37			ld a, (.dmark)  
3752 32 71 ee			ld (debug_mark),a  
3755 3a 64 37			ld a, (.dmark+1)  
3758 32 72 ee			ld (debug_mark+1),a  
375b 3a 65 37			ld a, (.dmark+2)  
375e 32 73 ee			ld (debug_mark+2),a  
3761 18 03			jr .pastdmark  
3763 ..			.dmark: db "MAX"  
3766 f1			.pastdmark: pop af  
3767			endm  
# End of macro DMARK
3767						CALLMONITOR 
3767 cd 76 15			call break_point_state  
376a				endm  
# End of macro CALLMONITOR
376a					endif 
376a					; get u2 
376a			 
376a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
376a cd de 1d			call macro_dsp_valuehl 
376d				endm 
# End of macro FORTH_DSP_VALUEHL
376d			 
376d e5					push hl   ; u2 
376e			 
376e					; destroy value TOS 
376e			 
376e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376e cd 96 1e			call macro_forth_dsp_pop 
3771				endm 
# End of macro FORTH_DSP_POP
3771			 
3771					; get u1 
3771			 
3771					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3771 cd de 1d			call macro_dsp_valuehl 
3774				endm 
# End of macro FORTH_DSP_VALUEHL
3774			 
3774 e5					push hl  ; u1 
3775			 
3775					; destroy value TOS 
3775			 
3775					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3775 cd 96 1e			call macro_forth_dsp_pop 
3778				endm 
# End of macro FORTH_DSP_POP
3778			 
3778 b7			 or a      ;clear carry flag 
3779 e1			  pop hl    ; u1 
377a d1			  pop de    ; u2 
377b e5				push hl   ; saved in case hl is lowest 
377c ed 52		  sbc hl,de 
377e 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3780			 
3780 e1				pop hl 
3781					if DEBUG_FORTH_WORDS 
3781						DMARK "MAX" 
3781 f5				push af  
3782 3a 96 37			ld a, (.dmark)  
3785 32 71 ee			ld (debug_mark),a  
3788 3a 97 37			ld a, (.dmark+1)  
378b 32 72 ee			ld (debug_mark+1),a  
378e 3a 98 37			ld a, (.dmark+2)  
3791 32 73 ee			ld (debug_mark+2),a  
3794 18 03			jr .pastdmark  
3796 ..			.dmark: db "MAX"  
3799 f1			.pastdmark: pop af  
379a			endm  
# End of macro DMARK
379a						CALLMONITOR 
379a cd 76 15			call break_point_state  
379d				endm  
# End of macro CALLMONITOR
379d					endif 
379d cd e7 1b				call forth_push_numhl 
37a0			 
37a0				       NEXTW 
37a0 c3 55 1f			jp macro_next 
37a3				endm 
# End of macro NEXTW
37a3			 
37a3			.maxcont:  
37a3 c1				pop bc   ; tidy up 
37a4 eb				ex de , hl  
37a5					if DEBUG_FORTH_WORDS 
37a5						DMARK "MA1" 
37a5 f5				push af  
37a6 3a ba 37			ld a, (.dmark)  
37a9 32 71 ee			ld (debug_mark),a  
37ac 3a bb 37			ld a, (.dmark+1)  
37af 32 72 ee			ld (debug_mark+1),a  
37b2 3a bc 37			ld a, (.dmark+2)  
37b5 32 73 ee			ld (debug_mark+2),a  
37b8 18 03			jr .pastdmark  
37ba ..			.dmark: db "MA1"  
37bd f1			.pastdmark: pop af  
37be			endm  
# End of macro DMARK
37be						CALLMONITOR 
37be cd 76 15			call break_point_state  
37c1				endm  
# End of macro CALLMONITOR
37c1					endif 
37c1 cd e7 1b				call forth_push_numhl 
37c4				       NEXTW 
37c4 c3 55 1f			jp macro_next 
37c7				endm 
# End of macro NEXTW
37c7			 
37c7			.RND16: 
37c7				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
37c7 4e				db WORD_SYS_CORE+58             
37c8 f6 37			dw .RND8            
37ca 06				db 5 + 1 
37cb .. 00			db "RND16",0              
37d1				endm 
# End of macro CWHEAD
37d1			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
37d1					if DEBUG_FORTH_WORDS_KEY 
37d1						DMARK "R16" 
37d1 f5				push af  
37d2 3a e6 37			ld a, (.dmark)  
37d5 32 71 ee			ld (debug_mark),a  
37d8 3a e7 37			ld a, (.dmark+1)  
37db 32 72 ee			ld (debug_mark+1),a  
37de 3a e8 37			ld a, (.dmark+2)  
37e1 32 73 ee			ld (debug_mark+2),a  
37e4 18 03			jr .pastdmark  
37e6 ..			.dmark: db "R16"  
37e9 f1			.pastdmark: pop af  
37ea			endm  
# End of macro DMARK
37ea						CALLMONITOR 
37ea cd 76 15			call break_point_state  
37ed				endm  
# End of macro CALLMONITOR
37ed					endif 
37ed cd 9c 0c				call prng16  
37f0 cd e7 1b				call forth_push_numhl 
37f3				       NEXTW 
37f3 c3 55 1f			jp macro_next 
37f6				endm 
# End of macro NEXTW
37f6			.RND8: 
37f6				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
37f6 60				db WORD_SYS_CORE+76             
37f7 2b 38			dw .RND            
37f9 05				db 4 + 1 
37fa .. 00			db "RND8",0              
37ff				endm 
# End of macro CWHEAD
37ff			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
37ff					if DEBUG_FORTH_WORDS_KEY 
37ff						DMARK "RN8" 
37ff f5				push af  
3800 3a 14 38			ld a, (.dmark)  
3803 32 71 ee			ld (debug_mark),a  
3806 3a 15 38			ld a, (.dmark+1)  
3809 32 72 ee			ld (debug_mark+1),a  
380c 3a 16 38			ld a, (.dmark+2)  
380f 32 73 ee			ld (debug_mark+2),a  
3812 18 03			jr .pastdmark  
3814 ..			.dmark: db "RN8"  
3817 f1			.pastdmark: pop af  
3818			endm  
# End of macro DMARK
3818						CALLMONITOR 
3818 cd 76 15			call break_point_state  
381b				endm  
# End of macro CALLMONITOR
381b					endif 
381b 2a b2 eb				ld hl,(xrandc) 
381e 23					inc hl 
381f cd b6 0c				call xrnd 
3822 6f					ld l,a	 
3823 26 00				ld h,0 
3825 cd e7 1b				call forth_push_numhl 
3828				       NEXTW 
3828 c3 55 1f			jp macro_next 
382b				endm 
# End of macro NEXTW
382b			.RND: 
382b				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
382b 60				db WORD_SYS_CORE+76             
382c 31 39			dw .ENDMATHS            
382e 04				db 3 + 1 
382f .. 00			db "RND",0              
3833				endm 
# End of macro CWHEAD
3833			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3833			 
3833					if DEBUG_FORTH_WORDS_KEY 
3833						DMARK "RND" 
3833 f5				push af  
3834 3a 48 38			ld a, (.dmark)  
3837 32 71 ee			ld (debug_mark),a  
383a 3a 49 38			ld a, (.dmark+1)  
383d 32 72 ee			ld (debug_mark+1),a  
3840 3a 4a 38			ld a, (.dmark+2)  
3843 32 73 ee			ld (debug_mark+2),a  
3846 18 03			jr .pastdmark  
3848 ..			.dmark: db "RND"  
384b f1			.pastdmark: pop af  
384c			endm  
# End of macro DMARK
384c						CALLMONITOR 
384c cd 76 15			call break_point_state  
384f				endm  
# End of macro CALLMONITOR
384f					endif 
384f					 
384f					FORTH_DSP_VALUEHL    ; upper range 
384f cd de 1d			call macro_dsp_valuehl 
3852				endm 
# End of macro FORTH_DSP_VALUEHL
3852			 
3852 22 b6 eb				ld (LFSRSeed), hl	 
3855			 
3855					if DEBUG_FORTH_WORDS 
3855						DMARK "RN1" 
3855 f5				push af  
3856 3a 6a 38			ld a, (.dmark)  
3859 32 71 ee			ld (debug_mark),a  
385c 3a 6b 38			ld a, (.dmark+1)  
385f 32 72 ee			ld (debug_mark+1),a  
3862 3a 6c 38			ld a, (.dmark+2)  
3865 32 73 ee			ld (debug_mark+2),a  
3868 18 03			jr .pastdmark  
386a ..			.dmark: db "RN1"  
386d f1			.pastdmark: pop af  
386e			endm  
# End of macro DMARK
386e						CALLMONITOR 
386e cd 76 15			call break_point_state  
3871				endm  
# End of macro CALLMONITOR
3871					endif 
3871					FORTH_DSP_POP 
3871 cd 96 1e			call macro_forth_dsp_pop 
3874				endm 
# End of macro FORTH_DSP_POP
3874			 
3874					FORTH_DSP_VALUEHL    ; low range 
3874 cd de 1d			call macro_dsp_valuehl 
3877				endm 
# End of macro FORTH_DSP_VALUEHL
3877			 
3877					if DEBUG_FORTH_WORDS 
3877						DMARK "RN2" 
3877 f5				push af  
3878 3a 8c 38			ld a, (.dmark)  
387b 32 71 ee			ld (debug_mark),a  
387e 3a 8d 38			ld a, (.dmark+1)  
3881 32 72 ee			ld (debug_mark+1),a  
3884 3a 8e 38			ld a, (.dmark+2)  
3887 32 73 ee			ld (debug_mark+2),a  
388a 18 03			jr .pastdmark  
388c ..			.dmark: db "RN2"  
388f f1			.pastdmark: pop af  
3890			endm  
# End of macro DMARK
3890						CALLMONITOR 
3890 cd 76 15			call break_point_state  
3893				endm  
# End of macro CALLMONITOR
3893					endif 
3893 22 b8 eb				ld (LFSRSeed+2), hl 
3896			 
3896					FORTH_DSP_POP 
3896 cd 96 1e			call macro_forth_dsp_pop 
3899				endm 
# End of macro FORTH_DSP_POP
3899			 
3899 e5					push hl 
389a			 
389a e1			.inrange:	pop hl 
389b cd 9c 0c				call prng16  
389e					if DEBUG_FORTH_WORDS 
389e						DMARK "RN3" 
389e f5				push af  
389f 3a b3 38			ld a, (.dmark)  
38a2 32 71 ee			ld (debug_mark),a  
38a5 3a b4 38			ld a, (.dmark+1)  
38a8 32 72 ee			ld (debug_mark+1),a  
38ab 3a b5 38			ld a, (.dmark+2)  
38ae 32 73 ee			ld (debug_mark+2),a  
38b1 18 03			jr .pastdmark  
38b3 ..			.dmark: db "RN3"  
38b6 f1			.pastdmark: pop af  
38b7			endm  
# End of macro DMARK
38b7						CALLMONITOR 
38b7 cd 76 15			call break_point_state  
38ba				endm  
# End of macro CALLMONITOR
38ba					endif 
38ba					 
38ba					; if the range is 8bit knock out the high byte 
38ba			 
38ba ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
38be			 
38be 3e 00				ld a, 0 
38c0 ba					cp d  
38c1 20 1e				jr nz, .hirange 
38c3 26 00				ld h, 0   ; knock it down to 8bit 
38c5			 
38c5					if DEBUG_FORTH_WORDS 
38c5						DMARK "RNk" 
38c5 f5				push af  
38c6 3a da 38			ld a, (.dmark)  
38c9 32 71 ee			ld (debug_mark),a  
38cc 3a db 38			ld a, (.dmark+1)  
38cf 32 72 ee			ld (debug_mark+1),a  
38d2 3a dc 38			ld a, (.dmark+2)  
38d5 32 73 ee			ld (debug_mark+2),a  
38d8 18 03			jr .pastdmark  
38da ..			.dmark: db "RNk"  
38dd f1			.pastdmark: pop af  
38de			endm  
# End of macro DMARK
38de						CALLMONITOR 
38de cd 76 15			call break_point_state  
38e1				endm  
# End of macro CALLMONITOR
38e1					endif 
38e1			.hirange:   
38e1 e5					push hl  
38e2 b7					or a  
38e3 ed 52		                sbc hl, de 
38e5			 
38e5					;call cmp16 
38e5			 
38e5 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
38e7 e1					pop hl 
38e8 e5					push hl 
38e9			 
38e9					if DEBUG_FORTH_WORDS 
38e9						DMARK "RN4" 
38e9 f5				push af  
38ea 3a fe 38			ld a, (.dmark)  
38ed 32 71 ee			ld (debug_mark),a  
38f0 3a ff 38			ld a, (.dmark+1)  
38f3 32 72 ee			ld (debug_mark+1),a  
38f6 3a 00 39			ld a, (.dmark+2)  
38f9 32 73 ee			ld (debug_mark+2),a  
38fc 18 03			jr .pastdmark  
38fe ..			.dmark: db "RN4"  
3901 f1			.pastdmark: pop af  
3902			endm  
# End of macro DMARK
3902						CALLMONITOR 
3902 cd 76 15			call break_point_state  
3905				endm  
# End of macro CALLMONITOR
3905					endif 
3905 ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
3909					;call cmp16 
3909				 
3909 b7					or a  
390a ed 52		                sbc hl, de 
390c 38 8c				jr c, .inrange 
390e			 
390e e1					pop hl 
390f					 
390f					if DEBUG_FORTH_WORDS 
390f						DMARK "RNd" 
390f f5				push af  
3910 3a 24 39			ld a, (.dmark)  
3913 32 71 ee			ld (debug_mark),a  
3916 3a 25 39			ld a, (.dmark+1)  
3919 32 72 ee			ld (debug_mark+1),a  
391c 3a 26 39			ld a, (.dmark+2)  
391f 32 73 ee			ld (debug_mark+2),a  
3922 18 03			jr .pastdmark  
3924 ..			.dmark: db "RNd"  
3927 f1			.pastdmark: pop af  
3928			endm  
# End of macro DMARK
3928						CALLMONITOR 
3928 cd 76 15			call break_point_state  
392b				endm  
# End of macro CALLMONITOR
392b					endif 
392b			 
392b			 
392b cd e7 1b				call forth_push_numhl 
392e				       NEXTW 
392e c3 55 1f			jp macro_next 
3931				endm 
# End of macro NEXTW
3931			 
3931			.ENDMATHS: 
3931			 
3931			; eof 
3931			 
# End of file forth_words_maths.asm
3931			include "forth_words_display.asm" 
3931			 
3931			; | ## Display Words 
3931			 
3931			.INFO: 
3931			 
3931				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3931 62				db WORD_SYS_CORE+78             
3932 4e 39			dw .ATP            
3934 05				db 4 + 1 
3935 .. 00			db "INFO",0              
393a				endm 
# End of macro CWHEAD
393a			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
393a					FORTH_DSP_VALUEHL 
393a cd de 1d			call macro_dsp_valuehl 
393d				endm 
# End of macro FORTH_DSP_VALUEHL
393d			 
393d					FORTH_DSP_POP 
393d cd 96 1e			call macro_forth_dsp_pop 
3940				endm 
# End of macro FORTH_DSP_POP
3940			 
3940 e5					push hl 
3941			 
3941					FORTH_DSP_VALUEHL 
3941 cd de 1d			call macro_dsp_valuehl 
3944				endm 
# End of macro FORTH_DSP_VALUEHL
3944			 
3944					FORTH_DSP_POP 
3944 cd 96 1e			call macro_forth_dsp_pop 
3947				endm 
# End of macro FORTH_DSP_POP
3947			 
3947 d1					pop de 
3948			 
3948 cd d9 0a				call info_panel 
394b			 
394b			 
394b					NEXTW 
394b c3 55 1f			jp macro_next 
394e				endm 
# End of macro NEXTW
394e			.ATP: 
394e				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
394e 62				db WORD_SYS_CORE+78             
394f c5 39			dw .FB            
3951 04				db 3 + 1 
3952 .. 00			db "AT?",0              
3956				endm 
# End of macro CWHEAD
3956			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3956					if DEBUG_FORTH_WORDS_KEY 
3956						DMARK "AT?" 
3956 f5				push af  
3957 3a 6b 39			ld a, (.dmark)  
395a 32 71 ee			ld (debug_mark),a  
395d 3a 6c 39			ld a, (.dmark+1)  
3960 32 72 ee			ld (debug_mark+1),a  
3963 3a 6d 39			ld a, (.dmark+2)  
3966 32 73 ee			ld (debug_mark+2),a  
3969 18 03			jr .pastdmark  
396b ..			.dmark: db "AT?"  
396e f1			.pastdmark: pop af  
396f			endm  
# End of macro DMARK
396f						CALLMONITOR 
396f cd 76 15			call break_point_state  
3972				endm  
# End of macro CALLMONITOR
3972					endif 
3972 3a 6b ea				ld a, (f_cursor_ptr) 
3975			 
3975			if DEBUG_FORTH_WORDS 
3975				DMARK "AT?" 
3975 f5				push af  
3976 3a 8a 39			ld a, (.dmark)  
3979 32 71 ee			ld (debug_mark),a  
397c 3a 8b 39			ld a, (.dmark+1)  
397f 32 72 ee			ld (debug_mark+1),a  
3982 3a 8c 39			ld a, (.dmark+2)  
3985 32 73 ee			ld (debug_mark+2),a  
3988 18 03			jr .pastdmark  
398a ..			.dmark: db "AT?"  
398d f1			.pastdmark: pop af  
398e			endm  
# End of macro DMARK
398e				CALLMONITOR 
398e cd 76 15			call break_point_state  
3991				endm  
# End of macro CALLMONITOR
3991			endif	 
3991					; count the number of rows 
3991			 
3991 06 00				ld b, 0 
3993 4f			.atpr:		ld c, a    ; save in case we go below zero 
3994 d6 28				sub display_cols 
3996 f2 9c 39				jp p, .atprunder 
3999 04					inc b 
399a 18 f7				jr .atpr 
399c			.atprunder:	 
399c			if DEBUG_FORTH_WORDS 
399c				DMARK "A?2" 
399c f5				push af  
399d 3a b1 39			ld a, (.dmark)  
39a0 32 71 ee			ld (debug_mark),a  
39a3 3a b2 39			ld a, (.dmark+1)  
39a6 32 72 ee			ld (debug_mark+1),a  
39a9 3a b3 39			ld a, (.dmark+2)  
39ac 32 73 ee			ld (debug_mark+2),a  
39af 18 03			jr .pastdmark  
39b1 ..			.dmark: db "A?2"  
39b4 f1			.pastdmark: pop af  
39b5			endm  
# End of macro DMARK
39b5				CALLMONITOR 
39b5 cd 76 15			call break_point_state  
39b8				endm  
# End of macro CALLMONITOR
39b8			endif	 
39b8 26 00				ld h, 0 
39ba 69					ld l, c 
39bb cd e7 1b				call forth_push_numhl 
39be 68					ld l, b  
39bf cd e7 1b				call forth_push_numhl 
39c2			 
39c2			 
39c2				NEXTW 
39c2 c3 55 1f			jp macro_next 
39c5				endm 
# End of macro NEXTW
39c5			 
39c5			.FB: 
39c5				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
39c5 1b				db WORD_SYS_CORE+7             
39c6 13 3a			dw .EMIT            
39c8 03				db 2 + 1 
39c9 .. 00			db "FB",0              
39cc				endm 
# End of macro CWHEAD
39cc			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
39cc			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
39cc			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
39cc			; | | If automatic display is off then updates will not be shown until DRAW is used. 
39cc					if DEBUG_FORTH_WORDS_KEY 
39cc						DMARK "FB." 
39cc f5				push af  
39cd 3a e1 39			ld a, (.dmark)  
39d0 32 71 ee			ld (debug_mark),a  
39d3 3a e2 39			ld a, (.dmark+1)  
39d6 32 72 ee			ld (debug_mark+1),a  
39d9 3a e3 39			ld a, (.dmark+2)  
39dc 32 73 ee			ld (debug_mark+2),a  
39df 18 03			jr .pastdmark  
39e1 ..			.dmark: db "FB."  
39e4 f1			.pastdmark: pop af  
39e5			endm  
# End of macro DMARK
39e5						CALLMONITOR 
39e5 cd 76 15			call break_point_state  
39e8				endm  
# End of macro CALLMONITOR
39e8					endif 
39e8			 
39e8					FORTH_DSP_VALUEHL 
39e8 cd de 1d			call macro_dsp_valuehl 
39eb				endm 
# End of macro FORTH_DSP_VALUEHL
39eb			 
39eb 7d					ld a, l 
39ec fe 01				cp 1 
39ee 20 05				jr nz, .fbn1 
39f0 21 16 ed				ld hl, display_fb1 
39f3 18 15				jr .fbset 
39f5 fe 02		.fbn1:		cp 2 
39f7 20 05				jr nz, .fbn2 
39f9 21 d4 eb				ld hl, display_fb2 
39fc 18 0c				jr .fbset 
39fe fe 03		.fbn2:		cp 3 
3a00 20 05				jr nz, .fbn3 
3a02 21 75 ec				ld hl, display_fb3 
3a05 18 03				jr .fbset 
3a07			.fbn3:		 ; if invalid number select first 
3a07 21 16 ed				ld hl, display_fb1 
3a0a 22 d2 eb		.fbset:		ld (display_fb_active), hl 
3a0d			 
3a0d					FORTH_DSP_POP 
3a0d cd 96 1e			call macro_forth_dsp_pop 
3a10				endm 
# End of macro FORTH_DSP_POP
3a10			 
3a10					NEXTW 
3a10 c3 55 1f			jp macro_next 
3a13				endm 
# End of macro NEXTW
3a13			 
3a13			 
3a13			.EMIT: 
3a13				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3a13 1b				db WORD_SYS_CORE+7             
3a14 64 3a			dw .DOTH            
3a16 05				db 4 + 1 
3a17 .. 00			db "EMIT",0              
3a1c				endm 
# End of macro CWHEAD
3a1c			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3a1c					; get value off TOS and display it 
3a1c			 
3a1c					if DEBUG_FORTH_WORDS_KEY 
3a1c						DMARK "EMT" 
3a1c f5				push af  
3a1d 3a 31 3a			ld a, (.dmark)  
3a20 32 71 ee			ld (debug_mark),a  
3a23 3a 32 3a			ld a, (.dmark+1)  
3a26 32 72 ee			ld (debug_mark+1),a  
3a29 3a 33 3a			ld a, (.dmark+2)  
3a2c 32 73 ee			ld (debug_mark+2),a  
3a2f 18 03			jr .pastdmark  
3a31 ..			.dmark: db "EMT"  
3a34 f1			.pastdmark: pop af  
3a35			endm  
# End of macro DMARK
3a35						CALLMONITOR 
3a35 cd 76 15			call break_point_state  
3a38				endm  
# End of macro CALLMONITOR
3a38					endif 
3a38			 
3a38					FORTH_DSP_VALUEHL 
3a38 cd de 1d			call macro_dsp_valuehl 
3a3b				endm 
# End of macro FORTH_DSP_VALUEHL
3a3b			 
3a3b 7d					ld a,l 
3a3c			 
3a3c					; TODO write to display 
3a3c			 
3a3c 32 00 e5				ld (os_input), a 
3a3f 3e 00				ld a, 0 
3a41 32 01 e5				ld (os_input+1), a 
3a44					 
3a44 3a 6b ea				ld a, (f_cursor_ptr) 
3a47 11 00 e5				ld de, os_input 
3a4a cd 5b 0b				call str_at_display 
3a4d			 
3a4d			 
3a4d 3a 49 ea				ld a,(cli_autodisplay) 
3a50 fe 00				cp 0 
3a52 28 03				jr z, .enoupdate 
3a54 cd 6b 0b						call update_display 
3a57					.enoupdate: 
3a57			 
3a57 3a 6b ea				ld a, (f_cursor_ptr) 
3a5a 3c					inc a 
3a5b 32 6b ea				ld (f_cursor_ptr), a   ; save new pos 
3a5e			 
3a5e			 
3a5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5e cd 96 1e			call macro_forth_dsp_pop 
3a61				endm 
# End of macro FORTH_DSP_POP
3a61			  
3a61			 
3a61					NEXTW 
3a61 c3 55 1f			jp macro_next 
3a64				endm 
# End of macro NEXTW
3a64			.DOTH: 
3a64				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3a64 1c				db WORD_SYS_CORE+8             
3a65 94 3a			dw .DOTF            
3a67 03				db 2 + 1 
3a68 .. 00			db ".-",0              
3a6b				endm 
# End of macro CWHEAD
3a6b			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3a6b					; get value off TOS and display it 
3a6b					if DEBUG_FORTH_WORDS_KEY 
3a6b						DMARK "DTD" 
3a6b f5				push af  
3a6c 3a 80 3a			ld a, (.dmark)  
3a6f 32 71 ee			ld (debug_mark),a  
3a72 3a 81 3a			ld a, (.dmark+1)  
3a75 32 72 ee			ld (debug_mark+1),a  
3a78 3a 82 3a			ld a, (.dmark+2)  
3a7b 32 73 ee			ld (debug_mark+2),a  
3a7e 18 03			jr .pastdmark  
3a80 ..			.dmark: db "DTD"  
3a83 f1			.pastdmark: pop af  
3a84			endm  
# End of macro DMARK
3a84						CALLMONITOR 
3a84 cd 76 15			call break_point_state  
3a87				endm  
# End of macro CALLMONITOR
3a87					endif 
3a87 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3a89 3e 00			ld a, 0 
3a8b 32 4a ea			ld (cli_mvdot), a 
3a8e c3 eb 3a			jp .dotgo 
3a91				NEXTW 
3a91 c3 55 1f			jp macro_next 
3a94				endm 
# End of macro NEXTW
3a94			.DOTF: 
3a94				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3a94 1c				db WORD_SYS_CORE+8             
3a95 c2 3a			dw .DOT            
3a97 03				db 2 + 1 
3a98 .. 00			db ".>",0              
3a9b				endm 
# End of macro CWHEAD
3a9b			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3a9b					; get value off TOS and display it 
3a9b			        ; TODO BUG adds extra spaces 
3a9b			        ; TODO BUG handle numerics? 
3a9b					if DEBUG_FORTH_WORDS_KEY 
3a9b						DMARK "DTC" 
3a9b f5				push af  
3a9c 3a b0 3a			ld a, (.dmark)  
3a9f 32 71 ee			ld (debug_mark),a  
3aa2 3a b1 3a			ld a, (.dmark+1)  
3aa5 32 72 ee			ld (debug_mark+1),a  
3aa8 3a b2 3a			ld a, (.dmark+2)  
3aab 32 73 ee			ld (debug_mark+2),a  
3aae 18 03			jr .pastdmark  
3ab0 ..			.dmark: db "DTC"  
3ab3 f1			.pastdmark: pop af  
3ab4			endm  
# End of macro DMARK
3ab4						CALLMONITOR 
3ab4 cd 76 15			call break_point_state  
3ab7				endm  
# End of macro CALLMONITOR
3ab7					endif 
3ab7 3e 01			ld a, 1 
3ab9 32 4a ea			ld (cli_mvdot), a 
3abc c3 eb 3a			jp .dotgo 
3abf				NEXTW 
3abf c3 55 1f			jp macro_next 
3ac2				endm 
# End of macro NEXTW
3ac2			 
3ac2			.DOT: 
3ac2				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3ac2 1c				db WORD_SYS_CORE+8             
3ac3 4e 3b			dw .CLS            
3ac5 02				db 1 + 1 
3ac6 .. 00			db ".",0              
3ac8				endm 
# End of macro CWHEAD
3ac8			        ; | . ( u -- ) Display TOS | DONE 
3ac8					; get value off TOS and display it 
3ac8			 
3ac8					if DEBUG_FORTH_WORDS_KEY 
3ac8						DMARK "DOT" 
3ac8 f5				push af  
3ac9 3a dd 3a			ld a, (.dmark)  
3acc 32 71 ee			ld (debug_mark),a  
3acf 3a de 3a			ld a, (.dmark+1)  
3ad2 32 72 ee			ld (debug_mark+1),a  
3ad5 3a df 3a			ld a, (.dmark+2)  
3ad8 32 73 ee			ld (debug_mark+2),a  
3adb 18 03			jr .pastdmark  
3add ..			.dmark: db "DOT"  
3ae0 f1			.pastdmark: pop af  
3ae1			endm  
# End of macro DMARK
3ae1						CALLMONITOR 
3ae1 cd 76 15			call break_point_state  
3ae4				endm  
# End of macro CALLMONITOR
3ae4					endif 
3ae4 3e 00			ld a, 0 
3ae6 32 4a ea			ld (cli_mvdot), a 
3ae9 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3aeb				 
3aeb			 
3aeb			.dotgo: 
3aeb			 
3aeb			; move up type to on stack for parserv5 
3aeb					FORTH_DSP 
3aeb cd a4 1d			call macro_forth_dsp 
3aee				endm 
# End of macro FORTH_DSP
3aee				;FORTH_DSP_VALUE  
3aee			 
3aee			if DEBUG_FORTH_DOT 
3aee				DMARK "DOT" 
3aee				CALLMONITOR 
3aee			endif	 
3aee			;		.print: 
3aee			 
3aee 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3aef 23				inc hl   ; position to the actual value 
3af0 fe 01			cp DS_TYPE_STR 
3af2 20 06			jr nz, .dotnum1  
3af4			 
3af4			; display string 
3af4				FORTH_DSP_VALUE  
3af4 cd c7 1d			call macro_forth_dsp_value 
3af7				endm 
# End of macro FORTH_DSP_VALUE
3af7 eb				ex de,hl 
3af8 18 11			jr .dotwrite 
3afa			 
3afa			.dotnum1: 
3afa fe 02			cp DS_TYPE_INUM 
3afc 20 0c			jr nz, .dotflot 
3afe			 
3afe			 
3afe			; display number 
3afe			 
3afe			;	push hl 
3afe			;	call clear_display 
3afe			;	pop hl 
3afe			 
3afe 5e				ld e, (hl) 
3aff 23				inc hl 
3b00 56				ld d, (hl) 
3b01 21 02 e3			ld hl, scratch 
3b04			if DEBUG_FORTH_DOT 
3b04				DMARK "DT1" 
3b04				CALLMONITOR 
3b04			endif	 
3b04			 
3b04 cd 82 11			call uitoa_16 
3b07 eb				ex de,hl 
3b08			 
3b08			if DEBUG_FORTH_DOT 
3b08				DMARK "DT2" 
3b08				CALLMONITOR 
3b08			endif	 
3b08			 
3b08			;	ld de, os_word_scratch 
3b08 18 01			jr .dotwrite 
3b0a			 
3b0a 00			.dotflot:   nop 
3b0b			; TODO print floating point number 
3b0b			 
3b0b			.dotwrite:		 
3b0b			 
3b0b					; if c is set then set all '-' to spaces 
3b0b					; need to also take into account .>  
3b0b			 
3b0b 3e 01				ld a, 1 
3b0d b9					cp c 
3b0e 20 13				jr nz, .nodashswap 
3b10			 
3b10					; DE has the string to write, working with HL 
3b10			 
3b10 06 ff				ld b, 255 
3b12 d5					push de 
3b13 e1					pop hl 
3b14			 
3b14			if DEBUG_FORTH_DOT 
3b14				DMARK "DT-" 
3b14				CALLMONITOR 
3b14			endif	 
3b14 7e			.dashscan:	ld a, (hl) 
3b15 fe 00				cp 0 
3b17 28 0a				jr z, .nodashswap 
3b19 fe 2d				cp '-' 
3b1b 20 03				jr nz, .dashskip 
3b1d 3e 20				ld a, ' ' 
3b1f 77					ld (hl), a 
3b20 23			.dashskip:	inc hl 
3b21			if DEBUG_FORTH_DOT 
3b21				DMARK "D-2" 
3b21				CALLMONITOR 
3b21			endif	 
3b21 10 f1				djnz .dashscan 
3b23			 
3b23			if DEBUG_FORTH_DOT 
3b23				DMARK "D-1" 
3b23				CALLMONITOR 
3b23			endif	 
3b23			 
3b23			.nodashswap: 
3b23			 
3b23 e5					push hl   ; save string start in case we need to advance print 
3b24			 
3b24 3a 6b ea				ld a, (f_cursor_ptr) 
3b27 cd 5b 0b				call str_at_display 
3b2a 3a 49 ea				ld a,(cli_autodisplay) 
3b2d fe 00				cp 0 
3b2f 28 03				jr z, .noupdate 
3b31 cd 6b 0b						call update_display 
3b34					.noupdate: 
3b34			 
3b34			 
3b34					; see if we need to advance the print position 
3b34			 
3b34 e1					pop hl   ; get back string 
3b35			 
3b35 3a 4a ea				ld a, (cli_mvdot) 
3b38			if DEBUG_FORTH_DOT 
3b38					ld e,a 
3b38				DMARK "D>1" 
3b38				CALLMONITOR 
3b38			endif	 
3b38 fe 00				cp 0 
3b3a 28 0c				jr z, .noadv 
3b3c					; yes, lets advance the print position 
3b3c 3e 00				ld a, 0 
3b3e cd de 11				call strlent 
3b41 3a 6b ea				ld a, (f_cursor_ptr) 
3b44 85					add a,l 
3b45					;call addatohl 
3b45					;ld a, l 
3b45 32 6b ea				ld (f_cursor_ptr), a   ; save new pos 
3b48			 
3b48			if DEBUG_FORTH_DOT 
3b48				DMARK "D->" 
3b48				CALLMONITOR 
3b48			endif	 
3b48			 
3b48			.noadv:	 
3b48			 
3b48					if DEBUG_FORTH_DOT_WAIT 
3b48							call next_page_prompt 
3b48					endif	 
3b48			; TODO this pop off the stack causes a crash. i dont know why 
3b48			 
3b48			 
3b48			if DEBUG_FORTH_DOT 
3b48				DMARK "DTh" 
3b48				CALLMONITOR 
3b48			endif	 
3b48			 
3b48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b48 cd 96 1e			call macro_forth_dsp_pop 
3b4b				endm 
# End of macro FORTH_DSP_POP
3b4b			 
3b4b			if DEBUG_FORTH_DOT 
3b4b				DMARK "DTi" 
3b4b				CALLMONITOR 
3b4b			endif	 
3b4b			 
3b4b			 
3b4b					NEXTW 
3b4b c3 55 1f			jp macro_next 
3b4e				endm 
# End of macro NEXTW
3b4e			 
3b4e			.CLS: 
3b4e				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3b4e 35				db WORD_SYS_CORE+33             
3b4f 7b 3b			dw .DRAW            
3b51 04				db 3 + 1 
3b52 .. 00			db "CLS",0              
3b56				endm 
# End of macro CWHEAD
3b56			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3b56					if DEBUG_FORTH_WORDS_KEY 
3b56						DMARK "CLS" 
3b56 f5				push af  
3b57 3a 6b 3b			ld a, (.dmark)  
3b5a 32 71 ee			ld (debug_mark),a  
3b5d 3a 6c 3b			ld a, (.dmark+1)  
3b60 32 72 ee			ld (debug_mark+1),a  
3b63 3a 6d 3b			ld a, (.dmark+2)  
3b66 32 73 ee			ld (debug_mark+2),a  
3b69 18 03			jr .pastdmark  
3b6b ..			.dmark: db "CLS"  
3b6e f1			.pastdmark: pop af  
3b6f			endm  
# End of macro DMARK
3b6f						CALLMONITOR 
3b6f cd 76 15			call break_point_state  
3b72				endm  
# End of macro CALLMONITOR
3b72					endif 
3b72 cd 48 0b				call clear_display 
3b75 c3 89 3c				jp .home		; and home cursor 
3b78					NEXTW 
3b78 c3 55 1f			jp macro_next 
3b7b				endm 
# End of macro NEXTW
3b7b			 
3b7b			.DRAW: 
3b7b				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3b7b 36				db WORD_SYS_CORE+34             
3b7c a6 3b			dw .DUMP            
3b7e 05				db 4 + 1 
3b7f .. 00			db "DRAW",0              
3b84				endm 
# End of macro CWHEAD
3b84			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3b84					if DEBUG_FORTH_WORDS_KEY 
3b84						DMARK "DRW" 
3b84 f5				push af  
3b85 3a 99 3b			ld a, (.dmark)  
3b88 32 71 ee			ld (debug_mark),a  
3b8b 3a 9a 3b			ld a, (.dmark+1)  
3b8e 32 72 ee			ld (debug_mark+1),a  
3b91 3a 9b 3b			ld a, (.dmark+2)  
3b94 32 73 ee			ld (debug_mark+2),a  
3b97 18 03			jr .pastdmark  
3b99 ..			.dmark: db "DRW"  
3b9c f1			.pastdmark: pop af  
3b9d			endm  
# End of macro DMARK
3b9d						CALLMONITOR 
3b9d cd 76 15			call break_point_state  
3ba0				endm  
# End of macro CALLMONITOR
3ba0					endif 
3ba0 cd 6b 0b				call update_display 
3ba3					NEXTW 
3ba3 c3 55 1f			jp macro_next 
3ba6				endm 
# End of macro NEXTW
3ba6			 
3ba6			.DUMP: 
3ba6				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3ba6 37				db WORD_SYS_CORE+35             
3ba7 de 3b			dw .CDUMP            
3ba9 05				db 4 + 1 
3baa .. 00			db "DUMP",0              
3baf				endm 
# End of macro CWHEAD
3baf			; | DUMP ( x -- ) With address x display dump   | DONE 
3baf			; TODO pop address to use off of the stack 
3baf					if DEBUG_FORTH_WORDS_KEY 
3baf						DMARK "DUM" 
3baf f5				push af  
3bb0 3a c4 3b			ld a, (.dmark)  
3bb3 32 71 ee			ld (debug_mark),a  
3bb6 3a c5 3b			ld a, (.dmark+1)  
3bb9 32 72 ee			ld (debug_mark+1),a  
3bbc 3a c6 3b			ld a, (.dmark+2)  
3bbf 32 73 ee			ld (debug_mark+2),a  
3bc2 18 03			jr .pastdmark  
3bc4 ..			.dmark: db "DUM"  
3bc7 f1			.pastdmark: pop af  
3bc8			endm  
# End of macro DMARK
3bc8						CALLMONITOR 
3bc8 cd 76 15			call break_point_state  
3bcb				endm  
# End of macro CALLMONITOR
3bcb					endif 
3bcb cd 48 0b				call clear_display 
3bce			 
3bce					; get address 
3bce			 
3bce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bce cd de 1d			call macro_dsp_valuehl 
3bd1				endm 
# End of macro FORTH_DSP_VALUEHL
3bd1				 
3bd1					; save it for cdump 
3bd1			 
3bd1 22 25 e6				ld (os_cur_ptr),hl 
3bd4			 
3bd4					; destroy value TOS 
3bd4			 
3bd4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd4 cd 96 1e			call macro_forth_dsp_pop 
3bd7				endm 
# End of macro FORTH_DSP_POP
3bd7			 
3bd7 cd 67 1a				call dumpcont	; skip old style of param parsing	 
3bda c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3bdb					NEXTW 
3bdb c3 55 1f			jp macro_next 
3bde				endm 
# End of macro NEXTW
3bde			.CDUMP: 
3bde				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3bde 38				db WORD_SYS_CORE+36             
3bdf 0e 3c			dw .DAT            
3be1 06				db 5 + 1 
3be2 .. 00			db "CDUMP",0              
3be8				endm 
# End of macro CWHEAD
3be8			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3be8					if DEBUG_FORTH_WORDS_KEY 
3be8						DMARK "CDP" 
3be8 f5				push af  
3be9 3a fd 3b			ld a, (.dmark)  
3bec 32 71 ee			ld (debug_mark),a  
3bef 3a fe 3b			ld a, (.dmark+1)  
3bf2 32 72 ee			ld (debug_mark+1),a  
3bf5 3a ff 3b			ld a, (.dmark+2)  
3bf8 32 73 ee			ld (debug_mark+2),a  
3bfb 18 03			jr .pastdmark  
3bfd ..			.dmark: db "CDP"  
3c00 f1			.pastdmark: pop af  
3c01			endm  
# End of macro DMARK
3c01						CALLMONITOR 
3c01 cd 76 15			call break_point_state  
3c04				endm  
# End of macro CALLMONITOR
3c04					endif 
3c04 cd 48 0b				call clear_display 
3c07 cd 67 1a				call dumpcont	 
3c0a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3c0b					NEXTW 
3c0b c3 55 1f			jp macro_next 
3c0e				endm 
# End of macro NEXTW
3c0e			 
3c0e			 
3c0e			 
3c0e			 
3c0e			.DAT: 
3c0e				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3c0e 3d				db WORD_SYS_CORE+41             
3c0f 64 3c			dw .HOME            
3c11 03				db 2 + 1 
3c12 .. 00			db "AT",0              
3c15				endm 
# End of macro CWHEAD
3c15			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3c15					if DEBUG_FORTH_WORDS_KEY 
3c15						DMARK "AT." 
3c15 f5				push af  
3c16 3a 2a 3c			ld a, (.dmark)  
3c19 32 71 ee			ld (debug_mark),a  
3c1c 3a 2b 3c			ld a, (.dmark+1)  
3c1f 32 72 ee			ld (debug_mark+1),a  
3c22 3a 2c 3c			ld a, (.dmark+2)  
3c25 32 73 ee			ld (debug_mark+2),a  
3c28 18 03			jr .pastdmark  
3c2a ..			.dmark: db "AT."  
3c2d f1			.pastdmark: pop af  
3c2e			endm  
# End of macro DMARK
3c2e						CALLMONITOR 
3c2e cd 76 15			call break_point_state  
3c31				endm  
# End of macro CALLMONITOR
3c31					endif 
3c31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c31 cd de 1d			call macro_dsp_valuehl 
3c34				endm 
# End of macro FORTH_DSP_VALUEHL
3c34			 
3c34			 
3c34					; TODO save cursor row 
3c34 7d					ld a,l 
3c35 fe 02				cp 2 
3c37 20 04				jr nz, .crow3 
3c39 3e 28				ld a, display_row_2 
3c3b 18 12				jr .ccol1 
3c3d fe 03		.crow3:		cp 3 
3c3f 20 04				jr nz, .crow4 
3c41 3e 50				ld a, display_row_3 
3c43 18 0a				jr .ccol1 
3c45 fe 04		.crow4:		cp 4 
3c47 20 04				jr nz, .crow1 
3c49 3e 78				ld a, display_row_4 
3c4b 18 02				jr .ccol1 
3c4d 3e 00		.crow1:		ld a,display_row_1 
3c4f f5			.ccol1:		push af			; got row offset 
3c50 6f					ld l,a 
3c51 26 00				ld h,0 
3c53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c53 cd 96 1e			call macro_forth_dsp_pop 
3c56				endm 
# End of macro FORTH_DSP_POP
3c56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c56 cd de 1d			call macro_dsp_valuehl 
3c59				endm 
# End of macro FORTH_DSP_VALUEHL
3c59					; TODO save cursor col 
3c59 f1					pop af 
3c5a 85					add l		; add col offset 
3c5b 32 6b ea				ld (f_cursor_ptr), a 
3c5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c5e cd 96 1e			call macro_forth_dsp_pop 
3c61				endm 
# End of macro FORTH_DSP_POP
3c61			 
3c61					; calculate  
3c61			 
3c61					NEXTW 
3c61 c3 55 1f			jp macro_next 
3c64				endm 
# End of macro NEXTW
3c64			 
3c64			 
3c64			.HOME: 
3c64				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3c64 41				db WORD_SYS_CORE+45             
3c65 91 3c			dw .SPACE            
3c67 05				db 4 + 1 
3c68 .. 00			db "HOME",0              
3c6d				endm 
# End of macro CWHEAD
3c6d			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3c6d					if DEBUG_FORTH_WORDS_KEY 
3c6d						DMARK "HOM" 
3c6d f5				push af  
3c6e 3a 82 3c			ld a, (.dmark)  
3c71 32 71 ee			ld (debug_mark),a  
3c74 3a 83 3c			ld a, (.dmark+1)  
3c77 32 72 ee			ld (debug_mark+1),a  
3c7a 3a 84 3c			ld a, (.dmark+2)  
3c7d 32 73 ee			ld (debug_mark+2),a  
3c80 18 03			jr .pastdmark  
3c82 ..			.dmark: db "HOM"  
3c85 f1			.pastdmark: pop af  
3c86			endm  
# End of macro DMARK
3c86						CALLMONITOR 
3c86 cd 76 15			call break_point_state  
3c89				endm  
# End of macro CALLMONITOR
3c89					endif 
3c89 3e 00		.home:		ld a, 0		; and home cursor 
3c8b 32 6b ea				ld (f_cursor_ptr), a 
3c8e					NEXTW 
3c8e c3 55 1f			jp macro_next 
3c91				endm 
# End of macro NEXTW
3c91			 
3c91			 
3c91			.SPACE: 
3c91				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3c91 46				db WORD_SYS_CORE+50             
3c92 bf 3c			dw .SPACES            
3c94 03				db 2 + 1 
3c95 .. 00			db "BL",0              
3c98				endm 
# End of macro CWHEAD
3c98			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3c98					if DEBUG_FORTH_WORDS_KEY 
3c98						DMARK "BL." 
3c98 f5				push af  
3c99 3a ad 3c			ld a, (.dmark)  
3c9c 32 71 ee			ld (debug_mark),a  
3c9f 3a ae 3c			ld a, (.dmark+1)  
3ca2 32 72 ee			ld (debug_mark+1),a  
3ca5 3a af 3c			ld a, (.dmark+2)  
3ca8 32 73 ee			ld (debug_mark+2),a  
3cab 18 03			jr .pastdmark  
3cad ..			.dmark: db "BL."  
3cb0 f1			.pastdmark: pop af  
3cb1			endm  
# End of macro DMARK
3cb1						CALLMONITOR 
3cb1 cd 76 15			call break_point_state  
3cb4				endm  
# End of macro CALLMONITOR
3cb4					endif 
3cb4 21 bd 3c				ld hl, .blstr 
3cb7 cd 55 1c				call forth_push_str 
3cba					 
3cba				       NEXTW 
3cba c3 55 1f			jp macro_next 
3cbd				endm 
# End of macro NEXTW
3cbd			 
3cbd .. 00		.blstr: db " ", 0 
3cbf			 
3cbf			.SPACES: 
3cbf				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3cbf 47				db WORD_SYS_CORE+51             
3cc0 5a 3d			dw .SCROLL            
3cc2 07				db 6 + 1 
3cc3 .. 00			db "SPACES",0              
3cca				endm 
# End of macro CWHEAD
3cca			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3cca					if DEBUG_FORTH_WORDS_KEY 
3cca						DMARK "SPS" 
3cca f5				push af  
3ccb 3a df 3c			ld a, (.dmark)  
3cce 32 71 ee			ld (debug_mark),a  
3cd1 3a e0 3c			ld a, (.dmark+1)  
3cd4 32 72 ee			ld (debug_mark+1),a  
3cd7 3a e1 3c			ld a, (.dmark+2)  
3cda 32 73 ee			ld (debug_mark+2),a  
3cdd 18 03			jr .pastdmark  
3cdf ..			.dmark: db "SPS"  
3ce2 f1			.pastdmark: pop af  
3ce3			endm  
# End of macro DMARK
3ce3						CALLMONITOR 
3ce3 cd 76 15			call break_point_state  
3ce6				endm  
# End of macro CALLMONITOR
3ce6					endif 
3ce6			 
3ce6			 
3ce6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ce6 cd de 1d			call macro_dsp_valuehl 
3ce9				endm 
# End of macro FORTH_DSP_VALUEHL
3ce9			 
3ce9			;		push hl    ; u 
3ce9					if DEBUG_FORTH_WORDS 
3ce9						DMARK "SPA" 
3ce9 f5				push af  
3cea 3a fe 3c			ld a, (.dmark)  
3ced 32 71 ee			ld (debug_mark),a  
3cf0 3a ff 3c			ld a, (.dmark+1)  
3cf3 32 72 ee			ld (debug_mark+1),a  
3cf6 3a 00 3d			ld a, (.dmark+2)  
3cf9 32 73 ee			ld (debug_mark+2),a  
3cfc 18 03			jr .pastdmark  
3cfe ..			.dmark: db "SPA"  
3d01 f1			.pastdmark: pop af  
3d02			endm  
# End of macro DMARK
3d02						CALLMONITOR 
3d02 cd 76 15			call break_point_state  
3d05				endm  
# End of macro CALLMONITOR
3d05					endif 
3d05			 
3d05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d05 cd 96 1e			call macro_forth_dsp_pop 
3d08				endm 
# End of macro FORTH_DSP_POP
3d08			;		pop hl 
3d08 4d					ld c, l 
3d09 06 00				ld b, 0 
3d0b 21 02 e3				ld hl, scratch  
3d0e			 
3d0e					if DEBUG_FORTH_WORDS 
3d0e						DMARK "SP2" 
3d0e f5				push af  
3d0f 3a 23 3d			ld a, (.dmark)  
3d12 32 71 ee			ld (debug_mark),a  
3d15 3a 24 3d			ld a, (.dmark+1)  
3d18 32 72 ee			ld (debug_mark+1),a  
3d1b 3a 25 3d			ld a, (.dmark+2)  
3d1e 32 73 ee			ld (debug_mark+2),a  
3d21 18 03			jr .pastdmark  
3d23 ..			.dmark: db "SP2"  
3d26 f1			.pastdmark: pop af  
3d27			endm  
# End of macro DMARK
3d27						CALLMONITOR 
3d27 cd 76 15			call break_point_state  
3d2a				endm  
# End of macro CALLMONITOR
3d2a					endif 
3d2a 3e 20				ld a, ' ' 
3d2c c5			.spaces1:	push bc 
3d2d 77					ld (hl),a 
3d2e 23					inc hl 
3d2f c1					pop bc 
3d30 10 fa				djnz .spaces1 
3d32 3e 00				ld a,0 
3d34 77					ld (hl),a 
3d35 21 02 e3				ld hl, scratch 
3d38					if DEBUG_FORTH_WORDS 
3d38						DMARK "SP3" 
3d38 f5				push af  
3d39 3a 4d 3d			ld a, (.dmark)  
3d3c 32 71 ee			ld (debug_mark),a  
3d3f 3a 4e 3d			ld a, (.dmark+1)  
3d42 32 72 ee			ld (debug_mark+1),a  
3d45 3a 4f 3d			ld a, (.dmark+2)  
3d48 32 73 ee			ld (debug_mark+2),a  
3d4b 18 03			jr .pastdmark  
3d4d ..			.dmark: db "SP3"  
3d50 f1			.pastdmark: pop af  
3d51			endm  
# End of macro DMARK
3d51						CALLMONITOR 
3d51 cd 76 15			call break_point_state  
3d54				endm  
# End of macro CALLMONITOR
3d54					endif 
3d54 cd 50 1d				call forth_apush 
3d57			 
3d57				       NEXTW 
3d57 c3 55 1f			jp macro_next 
3d5a				endm 
# End of macro NEXTW
3d5a			 
3d5a			 
3d5a			 
3d5a			.SCROLL: 
3d5a				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3d5a 53				db WORD_SYS_CORE+63             
3d5b 87 3d			dw .SCROLLD            
3d5d 07				db 6 + 1 
3d5e .. 00			db "SCROLL",0              
3d65				endm 
# End of macro CWHEAD
3d65			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3d65					if DEBUG_FORTH_WORDS_KEY 
3d65						DMARK "SCR" 
3d65 f5				push af  
3d66 3a 7a 3d			ld a, (.dmark)  
3d69 32 71 ee			ld (debug_mark),a  
3d6c 3a 7b 3d			ld a, (.dmark+1)  
3d6f 32 72 ee			ld (debug_mark+1),a  
3d72 3a 7c 3d			ld a, (.dmark+2)  
3d75 32 73 ee			ld (debug_mark+2),a  
3d78 18 03			jr .pastdmark  
3d7a ..			.dmark: db "SCR"  
3d7d f1			.pastdmark: pop af  
3d7e			endm  
# End of macro DMARK
3d7e						CALLMONITOR 
3d7e cd 76 15			call break_point_state  
3d81				endm  
# End of macro CALLMONITOR
3d81					endif 
3d81			 
3d81 cd 0a 0b			call scroll_up 
3d84			;	call update_display 
3d84			 
3d84					NEXTW 
3d84 c3 55 1f			jp macro_next 
3d87				endm 
# End of macro NEXTW
3d87			 
3d87			 
3d87			 
3d87			;		; get dir 
3d87			; 
3d87			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d87			; 
3d87			;		push hl 
3d87			; 
3d87			;		; destroy value TOS 
3d87			; 
3d87			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d87			; 
3d87			;		; get count 
3d87			; 
3d87			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d87			; 
3d87			;		push hl 
3d87			; 
3d87			;		; destroy value TOS 
3d87			; 
3d87			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d87			; 
3d87			;		; one value on hl get other one back 
3d87			; 
3d87			;		pop bc    ; count 
3d87			; 
3d87			;		pop de   ; dir 
3d87			; 
3d87			; 
3d87			;		ld b, c 
3d87			; 
3d87			;.scrolldir:     push bc 
3d87			;		push de 
3d87			; 
3d87			;		ld a, 0 
3d87			;		cp e 
3d87			;		jr z, .scrollup  
3d87			;		call scroll_down 
3d87			;		jr .scrollnext 
3d87			;.scrollup:	call scroll_up 
3d87			; 
3d87			;		 
3d87			;.scrollnext: 
3d87			;		pop de 
3d87			;		pop bc 
3d87			;		djnz .scrolldir 
3d87			; 
3d87			; 
3d87			; 
3d87			; 
3d87			; 
3d87			;		NEXTW 
3d87			 
3d87			.SCROLLD: 
3d87				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3d87 53				db WORD_SYS_CORE+63             
3d88 b5 3d			dw .ATQ            
3d8a 08				db 7 + 1 
3d8b .. 00			db "SCROLLD",0              
3d93				endm 
# End of macro CWHEAD
3d93			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3d93					if DEBUG_FORTH_WORDS_KEY 
3d93						DMARK "SCD" 
3d93 f5				push af  
3d94 3a a8 3d			ld a, (.dmark)  
3d97 32 71 ee			ld (debug_mark),a  
3d9a 3a a9 3d			ld a, (.dmark+1)  
3d9d 32 72 ee			ld (debug_mark+1),a  
3da0 3a aa 3d			ld a, (.dmark+2)  
3da3 32 73 ee			ld (debug_mark+2),a  
3da6 18 03			jr .pastdmark  
3da8 ..			.dmark: db "SCD"  
3dab f1			.pastdmark: pop af  
3dac			endm  
# End of macro DMARK
3dac						CALLMONITOR 
3dac cd 76 15			call break_point_state  
3daf				endm  
# End of macro CALLMONITOR
3daf					endif 
3daf			 
3daf cd 2e 0b			call scroll_down 
3db2			;	call update_display 
3db2			 
3db2					NEXTW 
3db2 c3 55 1f			jp macro_next 
3db5				endm 
# End of macro NEXTW
3db5			 
3db5			 
3db5			.ATQ: 
3db5				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3db5 62				db WORD_SYS_CORE+78             
3db6 13 3e			dw .AUTODSP            
3db8 04				db 3 + 1 
3db9 .. 00			db "AT@",0              
3dbd				endm 
# End of macro CWHEAD
3dbd			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3dbd					if DEBUG_FORTH_WORDS_KEY 
3dbd						DMARK "ATA" 
3dbd f5				push af  
3dbe 3a d2 3d			ld a, (.dmark)  
3dc1 32 71 ee			ld (debug_mark),a  
3dc4 3a d3 3d			ld a, (.dmark+1)  
3dc7 32 72 ee			ld (debug_mark+1),a  
3dca 3a d4 3d			ld a, (.dmark+2)  
3dcd 32 73 ee			ld (debug_mark+2),a  
3dd0 18 03			jr .pastdmark  
3dd2 ..			.dmark: db "ATA"  
3dd5 f1			.pastdmark: pop af  
3dd6			endm  
# End of macro DMARK
3dd6						CALLMONITOR 
3dd6 cd 76 15			call break_point_state  
3dd9				endm  
# End of macro CALLMONITOR
3dd9					endif 
3dd9			 
3dd9			 
3dd9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dd9 cd de 1d			call macro_dsp_valuehl 
3ddc				endm 
# End of macro FORTH_DSP_VALUEHL
3ddc			 
3ddc					; TODO save cursor row 
3ddc 7d					ld a,l 
3ddd fe 02				cp 2 
3ddf 20 04				jr nz, .crow3aq 
3de1 3e 28				ld a, display_row_2 
3de3 18 12				jr .ccol1aq 
3de5 fe 03		.crow3aq:		cp 3 
3de7 20 04				jr nz, .crow4aq 
3de9 3e 50				ld a, display_row_3 
3deb 18 0a				jr .ccol1aq 
3ded fe 04		.crow4aq:		cp 4 
3def 20 04				jr nz, .crow1aq 
3df1 3e 78				ld a, display_row_4 
3df3 18 02				jr .ccol1aq 
3df5 3e 00		.crow1aq:		ld a,display_row_1 
3df7 f5			.ccol1aq:		push af			; got row offset 
3df8 6f					ld l,a 
3df9 26 00				ld h,0 
3dfb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dfb cd 96 1e			call macro_forth_dsp_pop 
3dfe				endm 
# End of macro FORTH_DSP_POP
3dfe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dfe cd de 1d			call macro_dsp_valuehl 
3e01				endm 
# End of macro FORTH_DSP_VALUEHL
3e01					; TODO save cursor col 
3e01 f1					pop af 
3e02 85					add l		; add col offset 
3e03			 
3e03					; add current frame buffer address 
3e03 2a d2 eb				ld hl, (display_fb_active) 
3e06 cd 75 0d				call addatohl 
3e09			 
3e09			 
3e09			 
3e09			 
3e09					; get char frame buffer location offset in hl 
3e09			 
3e09 7e					ld a,(hl) 
3e0a 26 00				ld h, 0 
3e0c 6f					ld l, a 
3e0d			 
3e0d cd e7 1b				call forth_push_numhl 
3e10			 
3e10			 
3e10					NEXTW 
3e10 c3 55 1f			jp macro_next 
3e13				endm 
# End of macro NEXTW
3e13			 
3e13			.AUTODSP: 
3e13				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3e13 63				db WORD_SYS_CORE+79             
3e14 29 3e			dw .MENU            
3e16 05				db 4 + 1 
3e17 .. 00			db "ADSP",0              
3e1c				endm 
# End of macro CWHEAD
3e1c			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3e1c			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3e1c			 
3e1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e1c cd de 1d			call macro_dsp_valuehl 
3e1f				endm 
# End of macro FORTH_DSP_VALUEHL
3e1f			 
3e1f			;		push hl 
3e1f			 
3e1f					; destroy value TOS 
3e1f			 
3e1f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e1f cd 96 1e			call macro_forth_dsp_pop 
3e22				endm 
# End of macro FORTH_DSP_POP
3e22			 
3e22			;		pop hl 
3e22			 
3e22 7d					ld a,l 
3e23 32 49 ea				ld (cli_autodisplay), a 
3e26				       NEXTW 
3e26 c3 55 1f			jp macro_next 
3e29				endm 
# End of macro NEXTW
3e29			 
3e29			.MENU: 
3e29				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3e29 70				db WORD_SYS_CORE+92             
3e2a d2 3e			dw .ENDDISPLAY            
3e2c 05				db 4 + 1 
3e2d .. 00			db "MENU",0              
3e32				endm 
# End of macro CWHEAD
3e32			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3e32			 
3e32			;		; get number of items on the stack 
3e32			; 
3e32				 
3e32					FORTH_DSP_VALUEHL 
3e32 cd de 1d			call macro_dsp_valuehl 
3e35				endm 
# End of macro FORTH_DSP_VALUEHL
3e35				 
3e35					if DEBUG_FORTH_WORDS_KEY 
3e35						DMARK "MNU" 
3e35 f5				push af  
3e36 3a 4a 3e			ld a, (.dmark)  
3e39 32 71 ee			ld (debug_mark),a  
3e3c 3a 4b 3e			ld a, (.dmark+1)  
3e3f 32 72 ee			ld (debug_mark+1),a  
3e42 3a 4c 3e			ld a, (.dmark+2)  
3e45 32 73 ee			ld (debug_mark+2),a  
3e48 18 03			jr .pastdmark  
3e4a ..			.dmark: db "MNU"  
3e4d f1			.pastdmark: pop af  
3e4e			endm  
# End of macro DMARK
3e4e						CALLMONITOR 
3e4e cd 76 15			call break_point_state  
3e51				endm  
# End of macro CALLMONITOR
3e51					endif 
3e51			 
3e51 45					ld b, l	 
3e52 05					dec b 
3e53			 
3e53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e53 cd 96 1e			call macro_forth_dsp_pop 
3e56				endm 
# End of macro FORTH_DSP_POP
3e56			 
3e56			 
3e56					; go directly through the stack to pluck out the string pointers and build an array 
3e56			 
3e56			;		FORTH_DSP 
3e56			 
3e56					; hl contains top most stack item 
3e56				 
3e56 11 02 e3				ld de, scratch 
3e59			 
3e59			.mbuild: 
3e59			 
3e59					FORTH_DSP_VALUEHL 
3e59 cd de 1d			call macro_dsp_valuehl 
3e5c				endm 
# End of macro FORTH_DSP_VALUEHL
3e5c			 
3e5c					if DEBUG_FORTH_WORDS 
3e5c						DMARK "MN3" 
3e5c f5				push af  
3e5d 3a 71 3e			ld a, (.dmark)  
3e60 32 71 ee			ld (debug_mark),a  
3e63 3a 72 3e			ld a, (.dmark+1)  
3e66 32 72 ee			ld (debug_mark+1),a  
3e69 3a 73 3e			ld a, (.dmark+2)  
3e6c 32 73 ee			ld (debug_mark+2),a  
3e6f 18 03			jr .pastdmark  
3e71 ..			.dmark: db "MN3"  
3e74 f1			.pastdmark: pop af  
3e75			endm  
# End of macro DMARK
3e75						CALLMONITOR 
3e75 cd 76 15			call break_point_state  
3e78				endm  
# End of macro CALLMONITOR
3e78					endif 
3e78 eb					ex de, hl 
3e79 73					ld (hl), e 
3e7a 23					inc hl 
3e7b 72					ld (hl), d 
3e7c 23					inc hl 
3e7d eb					ex de, hl 
3e7e			 
3e7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e7e cd 96 1e			call macro_forth_dsp_pop 
3e81				endm 
# End of macro FORTH_DSP_POP
3e81			 
3e81 10 d6				djnz .mbuild 
3e83			 
3e83					; done add term 
3e83			 
3e83 eb					ex de, hl 
3e84 36 00				ld (hl), 0 
3e86 23					inc hl 
3e87 36 00				ld (hl), 0 
3e89			 
3e89				 
3e89					 
3e89 21 02 e3				ld hl, scratch 
3e8c			 
3e8c					if DEBUG_FORTH_WORDS 
3e8c						DMARK "MNx" 
3e8c f5				push af  
3e8d 3a a1 3e			ld a, (.dmark)  
3e90 32 71 ee			ld (debug_mark),a  
3e93 3a a2 3e			ld a, (.dmark+1)  
3e96 32 72 ee			ld (debug_mark+1),a  
3e99 3a a3 3e			ld a, (.dmark+2)  
3e9c 32 73 ee			ld (debug_mark+2),a  
3e9f 18 03			jr .pastdmark  
3ea1 ..			.dmark: db "MNx"  
3ea4 f1			.pastdmark: pop af  
3ea5			endm  
# End of macro DMARK
3ea5						CALLMONITOR 
3ea5 cd 76 15			call break_point_state  
3ea8				endm  
# End of macro CALLMONITOR
3ea8					endif 
3ea8			 
3ea8			 
3ea8			 
3ea8 3e 00				ld a, 0 
3eaa cd 79 0b				call menu 
3ead			 
3ead			 
3ead 6f					ld l, a 
3eae 26 00				ld h, 0 
3eb0			 
3eb0					if DEBUG_FORTH_WORDS 
3eb0						DMARK "MNr" 
3eb0 f5				push af  
3eb1 3a c5 3e			ld a, (.dmark)  
3eb4 32 71 ee			ld (debug_mark),a  
3eb7 3a c6 3e			ld a, (.dmark+1)  
3eba 32 72 ee			ld (debug_mark+1),a  
3ebd 3a c7 3e			ld a, (.dmark+2)  
3ec0 32 73 ee			ld (debug_mark+2),a  
3ec3 18 03			jr .pastdmark  
3ec5 ..			.dmark: db "MNr"  
3ec8 f1			.pastdmark: pop af  
3ec9			endm  
# End of macro DMARK
3ec9						CALLMONITOR 
3ec9 cd 76 15			call break_point_state  
3ecc				endm  
# End of macro CALLMONITOR
3ecc					endif 
3ecc			 
3ecc cd e7 1b				call forth_push_numhl 
3ecf			 
3ecf			 
3ecf			 
3ecf			 
3ecf				       NEXTW 
3ecf c3 55 1f			jp macro_next 
3ed2				endm 
# End of macro NEXTW
3ed2			 
3ed2			 
3ed2			.ENDDISPLAY: 
3ed2			 
3ed2			; eof 
# End of file forth_words_display.asm
3ed2			include "forth_words_str.asm" 
3ed2			 
3ed2			; | ## String Words 
3ed2			 
3ed2			.PTR:   
3ed2			 
3ed2				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3ed2 48				db WORD_SYS_CORE+52             
3ed3 ff 3e			dw .STYPE            
3ed5 04				db 3 + 1 
3ed6 .. 00			db "PTR",0              
3eda				endm 
# End of macro CWHEAD
3eda			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3eda			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3eda			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3eda			 
3eda					if DEBUG_FORTH_WORDS_KEY 
3eda						DMARK "PTR" 
3eda f5				push af  
3edb 3a ef 3e			ld a, (.dmark)  
3ede 32 71 ee			ld (debug_mark),a  
3ee1 3a f0 3e			ld a, (.dmark+1)  
3ee4 32 72 ee			ld (debug_mark+1),a  
3ee7 3a f1 3e			ld a, (.dmark+2)  
3eea 32 73 ee			ld (debug_mark+2),a  
3eed 18 03			jr .pastdmark  
3eef ..			.dmark: db "PTR"  
3ef2 f1			.pastdmark: pop af  
3ef3			endm  
# End of macro DMARK
3ef3						CALLMONITOR 
3ef3 cd 76 15			call break_point_state  
3ef6				endm  
# End of macro CALLMONITOR
3ef6					endif 
3ef6					FORTH_DSP_VALUEHL 
3ef6 cd de 1d			call macro_dsp_valuehl 
3ef9				endm 
# End of macro FORTH_DSP_VALUEHL
3ef9 cd e7 1b				call forth_push_numhl 
3efc			 
3efc			 
3efc					NEXTW 
3efc c3 55 1f			jp macro_next 
3eff				endm 
# End of macro NEXTW
3eff			.STYPE: 
3eff				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3eff 48				db WORD_SYS_CORE+52             
3f00 4e 3f			dw .UPPER            
3f02 06				db 5 + 1 
3f03 .. 00			db "STYPE",0              
3f09				endm 
# End of macro CWHEAD
3f09			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3f09					if DEBUG_FORTH_WORDS_KEY 
3f09						DMARK "STY" 
3f09 f5				push af  
3f0a 3a 1e 3f			ld a, (.dmark)  
3f0d 32 71 ee			ld (debug_mark),a  
3f10 3a 1f 3f			ld a, (.dmark+1)  
3f13 32 72 ee			ld (debug_mark+1),a  
3f16 3a 20 3f			ld a, (.dmark+2)  
3f19 32 73 ee			ld (debug_mark+2),a  
3f1c 18 03			jr .pastdmark  
3f1e ..			.dmark: db "STY"  
3f21 f1			.pastdmark: pop af  
3f22			endm  
# End of macro DMARK
3f22						CALLMONITOR 
3f22 cd 76 15			call break_point_state  
3f25				endm  
# End of macro CALLMONITOR
3f25					endif 
3f25					FORTH_DSP 
3f25 cd a4 1d			call macro_forth_dsp 
3f28				endm 
# End of macro FORTH_DSP
3f28					;v5 FORTH_DSP_VALUE 
3f28			 
3f28 7e					ld a, (hl) 
3f29			 
3f29 f5					push af 
3f2a			 
3f2a			; Dont destroy TOS		FORTH_DSP_POP 
3f2a			 
3f2a f1					pop af 
3f2b			 
3f2b fe 01				cp DS_TYPE_STR 
3f2d 28 09				jr z, .typestr 
3f2f			 
3f2f fe 02				cp DS_TYPE_INUM 
3f31 28 0a				jr z, .typeinum 
3f33			 
3f33 21 4c 3f				ld hl, .tna 
3f36 18 0a				jr .tpush 
3f38			 
3f38 21 48 3f		.typestr:	ld hl, .tstr 
3f3b 18 05				jr .tpush 
3f3d 21 4a 3f		.typeinum:	ld hl, .tinum 
3f40 18 00				jr .tpush 
3f42			 
3f42			.tpush: 
3f42			 
3f42 cd 55 1c				call forth_push_str 
3f45			 
3f45					NEXTW 
3f45 c3 55 1f			jp macro_next 
3f48				endm 
# End of macro NEXTW
3f48 .. 00		.tstr:	db "s",0 
3f4a .. 00		.tinum:  db "i",0 
3f4c .. 00		.tna:   db "?", 0 
3f4e			 
3f4e			 
3f4e			.UPPER: 
3f4e				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3f4e 48				db WORD_SYS_CORE+52             
3f4f 89 3f			dw .LOWER            
3f51 06				db 5 + 1 
3f52 .. 00			db "UPPER",0              
3f58				endm 
# End of macro CWHEAD
3f58			; | UPPER ( s -- s ) Upper case string s  | DONE 
3f58					if DEBUG_FORTH_WORDS_KEY 
3f58						DMARK "UPR" 
3f58 f5				push af  
3f59 3a 6d 3f			ld a, (.dmark)  
3f5c 32 71 ee			ld (debug_mark),a  
3f5f 3a 6e 3f			ld a, (.dmark+1)  
3f62 32 72 ee			ld (debug_mark+1),a  
3f65 3a 6f 3f			ld a, (.dmark+2)  
3f68 32 73 ee			ld (debug_mark+2),a  
3f6b 18 03			jr .pastdmark  
3f6d ..			.dmark: db "UPR"  
3f70 f1			.pastdmark: pop af  
3f71			endm  
# End of macro DMARK
3f71						CALLMONITOR 
3f71 cd 76 15			call break_point_state  
3f74				endm  
# End of macro CALLMONITOR
3f74					endif 
3f74			 
3f74					FORTH_DSP 
3f74 cd a4 1d			call macro_forth_dsp 
3f77				endm 
# End of macro FORTH_DSP
3f77					 
3f77			; TODO check is string type 
3f77			 
3f77					FORTH_DSP_VALUEHL 
3f77 cd de 1d			call macro_dsp_valuehl 
3f7a				endm 
# End of macro FORTH_DSP_VALUEHL
3f7a			; get pointer to string in hl 
3f7a			 
3f7a 7e			.toup:		ld a, (hl) 
3f7b fe 00				cp 0 
3f7d 28 07				jr z, .toupdone 
3f7f			 
3f7f cd e2 10				call to_upper 
3f82			 
3f82 77					ld (hl), a 
3f83 23					inc hl 
3f84 18 f4				jr .toup 
3f86			 
3f86					 
3f86			 
3f86			 
3f86			; for each char convert to upper 
3f86					 
3f86			.toupdone: 
3f86			 
3f86			 
3f86					NEXTW 
3f86 c3 55 1f			jp macro_next 
3f89				endm 
# End of macro NEXTW
3f89			.LOWER: 
3f89				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3f89 48				db WORD_SYS_CORE+52             
3f8a c4 3f			dw .TCASE            
3f8c 06				db 5 + 1 
3f8d .. 00			db "LOWER",0              
3f93				endm 
# End of macro CWHEAD
3f93			; | LOWER ( s -- s ) Lower case string s  | DONE 
3f93					if DEBUG_FORTH_WORDS_KEY 
3f93						DMARK "LWR" 
3f93 f5				push af  
3f94 3a a8 3f			ld a, (.dmark)  
3f97 32 71 ee			ld (debug_mark),a  
3f9a 3a a9 3f			ld a, (.dmark+1)  
3f9d 32 72 ee			ld (debug_mark+1),a  
3fa0 3a aa 3f			ld a, (.dmark+2)  
3fa3 32 73 ee			ld (debug_mark+2),a  
3fa6 18 03			jr .pastdmark  
3fa8 ..			.dmark: db "LWR"  
3fab f1			.pastdmark: pop af  
3fac			endm  
# End of macro DMARK
3fac						CALLMONITOR 
3fac cd 76 15			call break_point_state  
3faf				endm  
# End of macro CALLMONITOR
3faf					endif 
3faf			 
3faf					FORTH_DSP 
3faf cd a4 1d			call macro_forth_dsp 
3fb2				endm 
# End of macro FORTH_DSP
3fb2					 
3fb2			; TODO check is string type 
3fb2			 
3fb2					FORTH_DSP_VALUEHL 
3fb2 cd de 1d			call macro_dsp_valuehl 
3fb5				endm 
# End of macro FORTH_DSP_VALUEHL
3fb5			; get pointer to string in hl 
3fb5			 
3fb5 7e			.tolow:		ld a, (hl) 
3fb6 fe 00				cp 0 
3fb8 28 07				jr z, .tolowdone 
3fba			 
3fba cd eb 10				call to_lower 
3fbd			 
3fbd 77					ld (hl), a 
3fbe 23					inc hl 
3fbf 18 f4				jr .tolow 
3fc1			 
3fc1					 
3fc1			 
3fc1			 
3fc1			; for each char convert to low 
3fc1					 
3fc1			.tolowdone: 
3fc1					NEXTW 
3fc1 c3 55 1f			jp macro_next 
3fc4				endm 
# End of macro NEXTW
3fc4			.TCASE: 
3fc4				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3fc4 48				db WORD_SYS_CORE+52             
3fc5 fa 40			dw .SUBSTR            
3fc7 06				db 5 + 1 
3fc8 .. 00			db "TCASE",0              
3fce				endm 
# End of macro CWHEAD
3fce			; | TCASE ( s -- s ) Title case string s  | DONE 
3fce					if DEBUG_FORTH_WORDS_KEY 
3fce						DMARK "TCS" 
3fce f5				push af  
3fcf 3a e3 3f			ld a, (.dmark)  
3fd2 32 71 ee			ld (debug_mark),a  
3fd5 3a e4 3f			ld a, (.dmark+1)  
3fd8 32 72 ee			ld (debug_mark+1),a  
3fdb 3a e5 3f			ld a, (.dmark+2)  
3fde 32 73 ee			ld (debug_mark+2),a  
3fe1 18 03			jr .pastdmark  
3fe3 ..			.dmark: db "TCS"  
3fe6 f1			.pastdmark: pop af  
3fe7			endm  
# End of macro DMARK
3fe7						CALLMONITOR 
3fe7 cd 76 15			call break_point_state  
3fea				endm  
# End of macro CALLMONITOR
3fea					endif 
3fea			 
3fea					FORTH_DSP 
3fea cd a4 1d			call macro_forth_dsp 
3fed				endm 
# End of macro FORTH_DSP
3fed					 
3fed			; TODO check is string type 
3fed			 
3fed					FORTH_DSP_VALUEHL 
3fed cd de 1d			call macro_dsp_valuehl 
3ff0				endm 
# End of macro FORTH_DSP_VALUEHL
3ff0			; get pointer to string in hl 
3ff0			 
3ff0					if DEBUG_FORTH_WORDS 
3ff0						DMARK "TC1" 
3ff0 f5				push af  
3ff1 3a 05 40			ld a, (.dmark)  
3ff4 32 71 ee			ld (debug_mark),a  
3ff7 3a 06 40			ld a, (.dmark+1)  
3ffa 32 72 ee			ld (debug_mark+1),a  
3ffd 3a 07 40			ld a, (.dmark+2)  
4000 32 73 ee			ld (debug_mark+2),a  
4003 18 03			jr .pastdmark  
4005 ..			.dmark: db "TC1"  
4008 f1			.pastdmark: pop af  
4009			endm  
# End of macro DMARK
4009						CALLMONITOR 
4009 cd 76 15			call break_point_state  
400c				endm  
# End of macro CALLMONITOR
400c					endif 
400c			 
400c					; first time in turn to upper case first char 
400c			 
400c 7e					ld a, (hl) 
400d c3 97 40				jp .totsiptou 
4010			 
4010			 
4010 7e			.tot:		ld a, (hl) 
4011 fe 00				cp 0 
4013 ca db 40				jp z, .totdone 
4016			 
4016					if DEBUG_FORTH_WORDS 
4016						DMARK "TC2" 
4016 f5				push af  
4017 3a 2b 40			ld a, (.dmark)  
401a 32 71 ee			ld (debug_mark),a  
401d 3a 2c 40			ld a, (.dmark+1)  
4020 32 72 ee			ld (debug_mark+1),a  
4023 3a 2d 40			ld a, (.dmark+2)  
4026 32 73 ee			ld (debug_mark+2),a  
4029 18 03			jr .pastdmark  
402b ..			.dmark: db "TC2"  
402e f1			.pastdmark: pop af  
402f			endm  
# End of macro DMARK
402f						CALLMONITOR 
402f cd 76 15			call break_point_state  
4032				endm  
# End of macro CALLMONITOR
4032					endif 
4032					; check to see if current char is a space 
4032			 
4032 fe 20				cp ' ' 
4034 28 21				jr z, .totsp 
4036 cd eb 10				call to_lower 
4039					if DEBUG_FORTH_WORDS 
4039						DMARK "TC3" 
4039 f5				push af  
403a 3a 4e 40			ld a, (.dmark)  
403d 32 71 ee			ld (debug_mark),a  
4040 3a 4f 40			ld a, (.dmark+1)  
4043 32 72 ee			ld (debug_mark+1),a  
4046 3a 50 40			ld a, (.dmark+2)  
4049 32 73 ee			ld (debug_mark+2),a  
404c 18 03			jr .pastdmark  
404e ..			.dmark: db "TC3"  
4051 f1			.pastdmark: pop af  
4052			endm  
# End of macro DMARK
4052						CALLMONITOR 
4052 cd 76 15			call break_point_state  
4055				endm  
# End of macro CALLMONITOR
4055					endif 
4055 18 63				jr .totnxt 
4057			 
4057			.totsp:         ; on a space, find next char which should be upper 
4057			 
4057					if DEBUG_FORTH_WORDS 
4057						DMARK "TC4" 
4057 f5				push af  
4058 3a 6c 40			ld a, (.dmark)  
405b 32 71 ee			ld (debug_mark),a  
405e 3a 6d 40			ld a, (.dmark+1)  
4061 32 72 ee			ld (debug_mark+1),a  
4064 3a 6e 40			ld a, (.dmark+2)  
4067 32 73 ee			ld (debug_mark+2),a  
406a 18 03			jr .pastdmark  
406c ..			.dmark: db "TC4"  
406f f1			.pastdmark: pop af  
4070			endm  
# End of macro DMARK
4070						CALLMONITOR 
4070 cd 76 15			call break_point_state  
4073				endm  
# End of macro CALLMONITOR
4073					endif 
4073					;; 
4073			 
4073 fe 20				cp ' ' 
4075 20 20				jr nz, .totsiptou 
4077 23					inc hl 
4078 7e					ld a, (hl) 
4079					if DEBUG_FORTH_WORDS 
4079						DMARK "TC5" 
4079 f5				push af  
407a 3a 8e 40			ld a, (.dmark)  
407d 32 71 ee			ld (debug_mark),a  
4080 3a 8f 40			ld a, (.dmark+1)  
4083 32 72 ee			ld (debug_mark+1),a  
4086 3a 90 40			ld a, (.dmark+2)  
4089 32 73 ee			ld (debug_mark+2),a  
408c 18 03			jr .pastdmark  
408e ..			.dmark: db "TC5"  
4091 f1			.pastdmark: pop af  
4092			endm  
# End of macro DMARK
4092						CALLMONITOR 
4092 cd 76 15			call break_point_state  
4095				endm  
# End of macro CALLMONITOR
4095					endif 
4095 18 c0				jr .totsp 
4097 fe 00		.totsiptou:    cp 0 
4099 28 40				jr z, .totdone 
409b					; not space and not zero term so upper case it 
409b cd e2 10				call to_upper 
409e			 
409e					if DEBUG_FORTH_WORDS 
409e						DMARK "TC6" 
409e f5				push af  
409f 3a b3 40			ld a, (.dmark)  
40a2 32 71 ee			ld (debug_mark),a  
40a5 3a b4 40			ld a, (.dmark+1)  
40a8 32 72 ee			ld (debug_mark+1),a  
40ab 3a b5 40			ld a, (.dmark+2)  
40ae 32 73 ee			ld (debug_mark+2),a  
40b1 18 03			jr .pastdmark  
40b3 ..			.dmark: db "TC6"  
40b6 f1			.pastdmark: pop af  
40b7			endm  
# End of macro DMARK
40b7						CALLMONITOR 
40b7 cd 76 15			call break_point_state  
40ba				endm  
# End of macro CALLMONITOR
40ba					endif 
40ba			 
40ba			 
40ba			.totnxt: 
40ba			 
40ba 77					ld (hl), a 
40bb 23					inc hl 
40bc					if DEBUG_FORTH_WORDS 
40bc						DMARK "TC7" 
40bc f5				push af  
40bd 3a d1 40			ld a, (.dmark)  
40c0 32 71 ee			ld (debug_mark),a  
40c3 3a d2 40			ld a, (.dmark+1)  
40c6 32 72 ee			ld (debug_mark+1),a  
40c9 3a d3 40			ld a, (.dmark+2)  
40cc 32 73 ee			ld (debug_mark+2),a  
40cf 18 03			jr .pastdmark  
40d1 ..			.dmark: db "TC7"  
40d4 f1			.pastdmark: pop af  
40d5			endm  
# End of macro DMARK
40d5						CALLMONITOR 
40d5 cd 76 15			call break_point_state  
40d8				endm  
# End of macro CALLMONITOR
40d8					endif 
40d8 c3 10 40				jp .tot 
40db			 
40db					 
40db			 
40db			 
40db			; for each char convert to low 
40db					 
40db			.totdone: 
40db					if DEBUG_FORTH_WORDS 
40db						DMARK "TCd" 
40db f5				push af  
40dc 3a f0 40			ld a, (.dmark)  
40df 32 71 ee			ld (debug_mark),a  
40e2 3a f1 40			ld a, (.dmark+1)  
40e5 32 72 ee			ld (debug_mark+1),a  
40e8 3a f2 40			ld a, (.dmark+2)  
40eb 32 73 ee			ld (debug_mark+2),a  
40ee 18 03			jr .pastdmark  
40f0 ..			.dmark: db "TCd"  
40f3 f1			.pastdmark: pop af  
40f4			endm  
# End of macro DMARK
40f4						CALLMONITOR 
40f4 cd 76 15			call break_point_state  
40f7				endm  
# End of macro CALLMONITOR
40f7					endif 
40f7					NEXTW 
40f7 c3 55 1f			jp macro_next 
40fa				endm 
# End of macro NEXTW
40fa			 
40fa			.SUBSTR: 
40fa				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
40fa 48				db WORD_SYS_CORE+52             
40fb 58 41			dw .LEFT            
40fd 07				db 6 + 1 
40fe .. 00			db "SUBSTR",0              
4105				endm 
# End of macro CWHEAD
4105			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4105			 
4105					if DEBUG_FORTH_WORDS_KEY 
4105						DMARK "SST" 
4105 f5				push af  
4106 3a 1a 41			ld a, (.dmark)  
4109 32 71 ee			ld (debug_mark),a  
410c 3a 1b 41			ld a, (.dmark+1)  
410f 32 72 ee			ld (debug_mark+1),a  
4112 3a 1c 41			ld a, (.dmark+2)  
4115 32 73 ee			ld (debug_mark+2),a  
4118 18 03			jr .pastdmark  
411a ..			.dmark: db "SST"  
411d f1			.pastdmark: pop af  
411e			endm  
# End of macro DMARK
411e						CALLMONITOR 
411e cd 76 15			call break_point_state  
4121				endm  
# End of macro CALLMONITOR
4121					endif 
4121			; TODO check string type 
4121					FORTH_DSP_VALUEHL 
4121 cd de 1d			call macro_dsp_valuehl 
4124				endm 
# End of macro FORTH_DSP_VALUEHL
4124			 
4124 e5					push hl      ; string length 
4125			 
4125					FORTH_DSP_POP 
4125 cd 96 1e			call macro_forth_dsp_pop 
4128				endm 
# End of macro FORTH_DSP_POP
4128			 
4128					FORTH_DSP_VALUEHL 
4128 cd de 1d			call macro_dsp_valuehl 
412b				endm 
# End of macro FORTH_DSP_VALUEHL
412b			 
412b e5					push hl     ; start char 
412c			 
412c					FORTH_DSP_POP 
412c cd 96 1e			call macro_forth_dsp_pop 
412f				endm 
# End of macro FORTH_DSP_POP
412f			 
412f			 
412f					FORTH_DSP_VALUE 
412f cd c7 1d			call macro_forth_dsp_value 
4132				endm 
# End of macro FORTH_DSP_VALUE
4132			 
4132 d1					pop de    ; get start post offset 
4133			 
4133 19					add hl, de    ; starting offset 
4134			 
4134 c1					pop bc 
4135 c5					push bc      ; grab size of string 
4136			 
4136 e5					push hl    ; save string start  
4137			 
4137 26 00				ld h, 0 
4139 69					ld l, c 
413a 23					inc hl 
413b 23					inc hl 
413c			 
413c cd 3c 12				call malloc 
413f				if DEBUG_FORTH_MALLOC_GUARD 
413f cc bc 47				call z,malloc_error 
4142				endif 
4142			 
4142 eb					ex de, hl      ; save malloc area for string copy 
4143 e1					pop hl    ; get back source 
4144 c1					pop bc    ; get length of string back 
4145			 
4145 d5					push de    ; save malloc area for after we push 
4146 ed b0				ldir     ; copy substr 
4148			 
4148			 
4148 eb					ex de, hl 
4149 3e 00				ld a, 0 
414b 77					ld (hl), a   ; term substr 
414c			 
414c					 
414c e1					pop hl    ; get malloc so we can push it 
414d e5					push hl   ; save so we can free it afterwards 
414e			 
414e cd 55 1c				call forth_push_str 
4151			 
4151 e1					pop hl 
4152 cd 06 13				call free 
4155			 
4155					 
4155					 
4155			 
4155			 
4155					NEXTW 
4155 c3 55 1f			jp macro_next 
4158				endm 
# End of macro NEXTW
4158			 
4158			.LEFT: 
4158				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4158 48				db WORD_SYS_CORE+52             
4159 80 41			dw .RIGHT            
415b 05				db 4 + 1 
415c .. 00			db "LEFT",0              
4161				endm 
# End of macro CWHEAD
4161			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4161					if DEBUG_FORTH_WORDS_KEY 
4161						DMARK "LEF" 
4161 f5				push af  
4162 3a 76 41			ld a, (.dmark)  
4165 32 71 ee			ld (debug_mark),a  
4168 3a 77 41			ld a, (.dmark+1)  
416b 32 72 ee			ld (debug_mark+1),a  
416e 3a 78 41			ld a, (.dmark+2)  
4171 32 73 ee			ld (debug_mark+2),a  
4174 18 03			jr .pastdmark  
4176 ..			.dmark: db "LEF"  
4179 f1			.pastdmark: pop af  
417a			endm  
# End of macro DMARK
417a						CALLMONITOR 
417a cd 76 15			call break_point_state  
417d				endm  
# End of macro CALLMONITOR
417d					endif 
417d			 
417d					NEXTW 
417d c3 55 1f			jp macro_next 
4180				endm 
# End of macro NEXTW
4180			.RIGHT: 
4180				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4180 48				db WORD_SYS_CORE+52             
4181 a9 41			dw .STR2NUM            
4183 06				db 5 + 1 
4184 .. 00			db "RIGHT",0              
418a				endm 
# End of macro CWHEAD
418a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
418a					if DEBUG_FORTH_WORDS_KEY 
418a						DMARK "RIG" 
418a f5				push af  
418b 3a 9f 41			ld a, (.dmark)  
418e 32 71 ee			ld (debug_mark),a  
4191 3a a0 41			ld a, (.dmark+1)  
4194 32 72 ee			ld (debug_mark+1),a  
4197 3a a1 41			ld a, (.dmark+2)  
419a 32 73 ee			ld (debug_mark+2),a  
419d 18 03			jr .pastdmark  
419f ..			.dmark: db "RIG"  
41a2 f1			.pastdmark: pop af  
41a3			endm  
# End of macro DMARK
41a3						CALLMONITOR 
41a3 cd 76 15			call break_point_state  
41a6				endm  
# End of macro CALLMONITOR
41a6					endif 
41a6			 
41a6					NEXTW 
41a6 c3 55 1f			jp macro_next 
41a9				endm 
# End of macro NEXTW
41a9			 
41a9			 
41a9			.STR2NUM: 
41a9				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
41a9 48				db WORD_SYS_CORE+52             
41aa 35 42			dw .NUM2STR            
41ac 08				db 7 + 1 
41ad .. 00			db "STR2NUM",0              
41b5				endm 
# End of macro CWHEAD
41b5			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
41b5			 
41b5			 
41b5			; TODO STR type check to do 
41b5					if DEBUG_FORTH_WORDS_KEY 
41b5						DMARK "S2N" 
41b5 f5				push af  
41b6 3a ca 41			ld a, (.dmark)  
41b9 32 71 ee			ld (debug_mark),a  
41bc 3a cb 41			ld a, (.dmark+1)  
41bf 32 72 ee			ld (debug_mark+1),a  
41c2 3a cc 41			ld a, (.dmark+2)  
41c5 32 73 ee			ld (debug_mark+2),a  
41c8 18 03			jr .pastdmark  
41ca ..			.dmark: db "S2N"  
41cd f1			.pastdmark: pop af  
41ce			endm  
# End of macro DMARK
41ce						CALLMONITOR 
41ce cd 76 15			call break_point_state  
41d1				endm  
# End of macro CALLMONITOR
41d1					endif 
41d1			 
41d1					;FORTH_DSP 
41d1					FORTH_DSP_VALUE 
41d1 cd c7 1d			call macro_forth_dsp_value 
41d4				endm 
# End of macro FORTH_DSP_VALUE
41d4					;inc hl 
41d4			 
41d4 eb					ex de, hl 
41d5					if DEBUG_FORTH_WORDS 
41d5						DMARK "S2a" 
41d5 f5				push af  
41d6 3a ea 41			ld a, (.dmark)  
41d9 32 71 ee			ld (debug_mark),a  
41dc 3a eb 41			ld a, (.dmark+1)  
41df 32 72 ee			ld (debug_mark+1),a  
41e2 3a ec 41			ld a, (.dmark+2)  
41e5 32 73 ee			ld (debug_mark+2),a  
41e8 18 03			jr .pastdmark  
41ea ..			.dmark: db "S2a"  
41ed f1			.pastdmark: pop af  
41ee			endm  
# End of macro DMARK
41ee						CALLMONITOR 
41ee cd 76 15			call break_point_state  
41f1				endm  
# End of macro CALLMONITOR
41f1					endif 
41f1 cd 6a 11				call string_to_uint16 
41f4			 
41f4					if DEBUG_FORTH_WORDS 
41f4						DMARK "S2b" 
41f4 f5				push af  
41f5 3a 09 42			ld a, (.dmark)  
41f8 32 71 ee			ld (debug_mark),a  
41fb 3a 0a 42			ld a, (.dmark+1)  
41fe 32 72 ee			ld (debug_mark+1),a  
4201 3a 0b 42			ld a, (.dmark+2)  
4204 32 73 ee			ld (debug_mark+2),a  
4207 18 03			jr .pastdmark  
4209 ..			.dmark: db "S2b"  
420c f1			.pastdmark: pop af  
420d			endm  
# End of macro DMARK
420d						CALLMONITOR 
420d cd 76 15			call break_point_state  
4210				endm  
# End of macro CALLMONITOR
4210					endif 
4210			;		push hl 
4210					FORTH_DSP_POP 
4210 cd 96 1e			call macro_forth_dsp_pop 
4213				endm 
# End of macro FORTH_DSP_POP
4213			;		pop hl 
4213					 
4213					if DEBUG_FORTH_WORDS 
4213						DMARK "S2b" 
4213 f5				push af  
4214 3a 28 42			ld a, (.dmark)  
4217 32 71 ee			ld (debug_mark),a  
421a 3a 29 42			ld a, (.dmark+1)  
421d 32 72 ee			ld (debug_mark+1),a  
4220 3a 2a 42			ld a, (.dmark+2)  
4223 32 73 ee			ld (debug_mark+2),a  
4226 18 03			jr .pastdmark  
4228 ..			.dmark: db "S2b"  
422b f1			.pastdmark: pop af  
422c			endm  
# End of macro DMARK
422c						CALLMONITOR 
422c cd 76 15			call break_point_state  
422f				endm  
# End of macro CALLMONITOR
422f					endif 
422f cd e7 1b				call forth_push_numhl	 
4232			 
4232				 
4232				       NEXTW 
4232 c3 55 1f			jp macro_next 
4235				endm 
# End of macro NEXTW
4235			.NUM2STR: 
4235				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4235 48				db WORD_SYS_CORE+52             
4236 44 42			dw .CONCAT            
4238 08				db 7 + 1 
4239 .. 00			db "NUM2STR",0              
4241				endm 
# End of macro CWHEAD
4241			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4241			 
4241			;		; malloc a string to target 
4241			;		ld hl, 10     ; TODO max string size should be fine 
4241			;		call malloc 
4241			;		push hl    ; save malloc location 
4241			; 
4241			; 
4241			;; TODO check int type 
4241			;		FORTH_DSP_VALUEHL 
4241			;		ld a, l 
4241			;		call DispAToASCII   
4241			;;TODO need to chage above call to dump into string 
4241			; 
4241			; 
4241			 
4241				       NEXTW 
4241 c3 55 1f			jp macro_next 
4244				endm 
# End of macro NEXTW
4244			 
4244			.CONCAT: 
4244				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4244 48				db WORD_SYS_CORE+52             
4245 f7 42			dw .FIND            
4247 07				db 6 + 1 
4248 .. 00			db "CONCAT",0              
424f				endm 
# End of macro CWHEAD
424f			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
424f			 
424f			; TODO check string type 
424f			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
424f			 
424f					if DEBUG_FORTH_WORDS_KEY 
424f						DMARK "CON" 
424f f5				push af  
4250 3a 64 42			ld a, (.dmark)  
4253 32 71 ee			ld (debug_mark),a  
4256 3a 65 42			ld a, (.dmark+1)  
4259 32 72 ee			ld (debug_mark+1),a  
425c 3a 66 42			ld a, (.dmark+2)  
425f 32 73 ee			ld (debug_mark+2),a  
4262 18 03			jr .pastdmark  
4264 ..			.dmark: db "CON"  
4267 f1			.pastdmark: pop af  
4268			endm  
# End of macro DMARK
4268						CALLMONITOR 
4268 cd 76 15			call break_point_state  
426b				endm  
# End of macro CALLMONITOR
426b					endif 
426b			 
426b			 
426b					FORTH_DSP_VALUE 
426b cd c7 1d			call macro_forth_dsp_value 
426e				endm 
# End of macro FORTH_DSP_VALUE
426e e5					push hl   ; s2 
426f			 
426f					FORTH_DSP_POP 
426f cd 96 1e			call macro_forth_dsp_pop 
4272				endm 
# End of macro FORTH_DSP_POP
4272			 
4272					FORTH_DSP_VALUE 
4272 cd c7 1d			call macro_forth_dsp_value 
4275				endm 
# End of macro FORTH_DSP_VALUE
4275			 
4275 e5					push hl   ; s1 
4276			 
4276					FORTH_DSP_POP 
4276 cd 96 1e			call macro_forth_dsp_pop 
4279				endm 
# End of macro FORTH_DSP_POP
4279					 
4279			 
4279					; copy s1 
4279			 
4279				 
4279					; save ptr 
4279 e1					pop hl  
427a e5					push hl 
427b 3e 00				ld a, 0 
427d cd de 11				call strlent 
4280					;inc hl    ; zer0 
4280 06 00				ld b, 0 
4282 4d					ld c, l 
4283 e1					pop hl		 
4284 11 02 e3				ld de, scratch	 
4287					if DEBUG_FORTH_WORDS 
4287						DMARK "CO1" 
4287 f5				push af  
4288 3a 9c 42			ld a, (.dmark)  
428b 32 71 ee			ld (debug_mark),a  
428e 3a 9d 42			ld a, (.dmark+1)  
4291 32 72 ee			ld (debug_mark+1),a  
4294 3a 9e 42			ld a, (.dmark+2)  
4297 32 73 ee			ld (debug_mark+2),a  
429a 18 03			jr .pastdmark  
429c ..			.dmark: db "CO1"  
429f f1			.pastdmark: pop af  
42a0			endm  
# End of macro DMARK
42a0						CALLMONITOR 
42a0 cd 76 15			call break_point_state  
42a3				endm  
# End of macro CALLMONITOR
42a3					endif 
42a3 ed b0				ldir 
42a5			 
42a5 e1					pop hl 
42a6 e5					push hl 
42a7 d5					push de 
42a8			 
42a8			 
42a8 3e 00				ld a, 0 
42aa cd de 11				call strlent 
42ad 23					inc hl    ; zer0 
42ae 23					inc hl 
42af 06 00				ld b, 0 
42b1 4d					ld c, l 
42b2 d1					pop de 
42b3 e1					pop hl		 
42b4					if DEBUG_FORTH_WORDS 
42b4						DMARK "CO2" 
42b4 f5				push af  
42b5 3a c9 42			ld a, (.dmark)  
42b8 32 71 ee			ld (debug_mark),a  
42bb 3a ca 42			ld a, (.dmark+1)  
42be 32 72 ee			ld (debug_mark+1),a  
42c1 3a cb 42			ld a, (.dmark+2)  
42c4 32 73 ee			ld (debug_mark+2),a  
42c7 18 03			jr .pastdmark  
42c9 ..			.dmark: db "CO2"  
42cc f1			.pastdmark: pop af  
42cd			endm  
# End of macro DMARK
42cd						CALLMONITOR 
42cd cd 76 15			call break_point_state  
42d0				endm  
# End of macro CALLMONITOR
42d0					endif 
42d0 ed b0				ldir 
42d2			 
42d2			 
42d2			 
42d2 21 02 e3				ld hl, scratch 
42d5					if DEBUG_FORTH_WORDS 
42d5						DMARK "CO5" 
42d5 f5				push af  
42d6 3a ea 42			ld a, (.dmark)  
42d9 32 71 ee			ld (debug_mark),a  
42dc 3a eb 42			ld a, (.dmark+1)  
42df 32 72 ee			ld (debug_mark+1),a  
42e2 3a ec 42			ld a, (.dmark+2)  
42e5 32 73 ee			ld (debug_mark+2),a  
42e8 18 03			jr .pastdmark  
42ea ..			.dmark: db "CO5"  
42ed f1			.pastdmark: pop af  
42ee			endm  
# End of macro DMARK
42ee						CALLMONITOR 
42ee cd 76 15			call break_point_state  
42f1				endm  
# End of macro CALLMONITOR
42f1					endif 
42f1			 
42f1 cd 55 1c				call forth_push_str 
42f4			 
42f4			 
42f4			 
42f4			 
42f4				       NEXTW 
42f4 c3 55 1f			jp macro_next 
42f7				endm 
# End of macro NEXTW
42f7			 
42f7			 
42f7			.FIND: 
42f7				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
42f7 4b				db WORD_SYS_CORE+55             
42f8 b5 43			dw .LEN            
42fa 05				db 4 + 1 
42fb .. 00			db "FIND",0              
4300				endm 
# End of macro CWHEAD
4300			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4300			 
4300					if DEBUG_FORTH_WORDS_KEY 
4300						DMARK "FND" 
4300 f5				push af  
4301 3a 15 43			ld a, (.dmark)  
4304 32 71 ee			ld (debug_mark),a  
4307 3a 16 43			ld a, (.dmark+1)  
430a 32 72 ee			ld (debug_mark+1),a  
430d 3a 17 43			ld a, (.dmark+2)  
4310 32 73 ee			ld (debug_mark+2),a  
4313 18 03			jr .pastdmark  
4315 ..			.dmark: db "FND"  
4318 f1			.pastdmark: pop af  
4319			endm  
# End of macro DMARK
4319						CALLMONITOR 
4319 cd 76 15			call break_point_state  
431c				endm  
# End of macro CALLMONITOR
431c					endif 
431c			 
431c			; TODO check string type 
431c					FORTH_DSP_VALUE 
431c cd c7 1d			call macro_forth_dsp_value 
431f				endm 
# End of macro FORTH_DSP_VALUE
431f			 
431f e5					push hl    
4320 7e					ld a,(hl)    ; char to find   
4321			; TODO change char to substr 
4321			 
4321 f5					push af 
4322					 
4322			 
4322			 
4322					if DEBUG_FORTH_WORDS 
4322						DMARK "FN1" 
4322 f5				push af  
4323 3a 37 43			ld a, (.dmark)  
4326 32 71 ee			ld (debug_mark),a  
4329 3a 38 43			ld a, (.dmark+1)  
432c 32 72 ee			ld (debug_mark+1),a  
432f 3a 39 43			ld a, (.dmark+2)  
4332 32 73 ee			ld (debug_mark+2),a  
4335 18 03			jr .pastdmark  
4337 ..			.dmark: db "FN1"  
433a f1			.pastdmark: pop af  
433b			endm  
# End of macro DMARK
433b						CALLMONITOR 
433b cd 76 15			call break_point_state  
433e				endm  
# End of macro CALLMONITOR
433e					endif 
433e			 
433e					FORTH_DSP_POP 
433e cd 96 1e			call macro_forth_dsp_pop 
4341				endm 
# End of macro FORTH_DSP_POP
4341			 
4341					; string to search 
4341			 
4341					FORTH_DSP_VALUE 
4341 cd c7 1d			call macro_forth_dsp_value 
4344				endm 
# End of macro FORTH_DSP_VALUE
4344			 
4344 d1					pop de  ; d is char to find  
4345			 
4345					if DEBUG_FORTH_WORDS 
4345						DMARK "FN2" 
4345 f5				push af  
4346 3a 5a 43			ld a, (.dmark)  
4349 32 71 ee			ld (debug_mark),a  
434c 3a 5b 43			ld a, (.dmark+1)  
434f 32 72 ee			ld (debug_mark+1),a  
4352 3a 5c 43			ld a, (.dmark+2)  
4355 32 73 ee			ld (debug_mark+2),a  
4358 18 03			jr .pastdmark  
435a ..			.dmark: db "FN2"  
435d f1			.pastdmark: pop af  
435e			endm  
# End of macro DMARK
435e						CALLMONITOR 
435e cd 76 15			call break_point_state  
4361				endm  
# End of macro CALLMONITOR
4361					endif 
4361					 
4361 01 00 00				ld bc, 0 
4364 7e			.findchar:      ld a,(hl) 
4365 fe 00				cp 0   		 
4367 28 27				jr z, .finddone     
4369 ba					cp d 
436a 28 20				jr z, .foundchar 
436c 03					inc bc 
436d 23					inc hl 
436e					if DEBUG_FORTH_WORDS 
436e						DMARK "FN3" 
436e f5				push af  
436f 3a 83 43			ld a, (.dmark)  
4372 32 71 ee			ld (debug_mark),a  
4375 3a 84 43			ld a, (.dmark+1)  
4378 32 72 ee			ld (debug_mark+1),a  
437b 3a 85 43			ld a, (.dmark+2)  
437e 32 73 ee			ld (debug_mark+2),a  
4381 18 03			jr .pastdmark  
4383 ..			.dmark: db "FN3"  
4386 f1			.pastdmark: pop af  
4387			endm  
# End of macro DMARK
4387						CALLMONITOR 
4387 cd 76 15			call break_point_state  
438a				endm  
# End of macro CALLMONITOR
438a					endif 
438a 18 d8				jr .findchar 
438c			 
438c			 
438c c5			.foundchar:	push bc 
438d e1					pop hl 
438e 18 03				jr .findexit 
4390			 
4390			 
4390							 
4390			 
4390			.finddone:     ; got to end of string with no find 
4390 21 00 00				ld hl, 0 
4393			.findexit: 
4393			 
4393					if DEBUG_FORTH_WORDS 
4393						DMARK "FNd" 
4393 f5				push af  
4394 3a a8 43			ld a, (.dmark)  
4397 32 71 ee			ld (debug_mark),a  
439a 3a a9 43			ld a, (.dmark+1)  
439d 32 72 ee			ld (debug_mark+1),a  
43a0 3a aa 43			ld a, (.dmark+2)  
43a3 32 73 ee			ld (debug_mark+2),a  
43a6 18 03			jr .pastdmark  
43a8 ..			.dmark: db "FNd"  
43ab f1			.pastdmark: pop af  
43ac			endm  
# End of macro DMARK
43ac						CALLMONITOR 
43ac cd 76 15			call break_point_state  
43af				endm  
# End of macro CALLMONITOR
43af					endif 
43af cd e7 1b			call forth_push_numhl 
43b2			 
43b2				       NEXTW 
43b2 c3 55 1f			jp macro_next 
43b5				endm 
# End of macro NEXTW
43b5			 
43b5			.LEN: 
43b5				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
43b5 4c				db WORD_SYS_CORE+56             
43b6 1f 44			dw .CHAR            
43b8 06				db 5 + 1 
43b9 .. 00			db "COUNT",0              
43bf				endm 
# End of macro CWHEAD
43bf			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
43bf			 
43bf					if DEBUG_FORTH_WORDS_KEY 
43bf						DMARK "CNT" 
43bf f5				push af  
43c0 3a d4 43			ld a, (.dmark)  
43c3 32 71 ee			ld (debug_mark),a  
43c6 3a d5 43			ld a, (.dmark+1)  
43c9 32 72 ee			ld (debug_mark+1),a  
43cc 3a d6 43			ld a, (.dmark+2)  
43cf 32 73 ee			ld (debug_mark+2),a  
43d2 18 03			jr .pastdmark  
43d4 ..			.dmark: db "CNT"  
43d7 f1			.pastdmark: pop af  
43d8			endm  
# End of macro DMARK
43d8						CALLMONITOR 
43d8 cd 76 15			call break_point_state  
43db				endm  
# End of macro CALLMONITOR
43db					endif 
43db			; TODO check string type 
43db					FORTH_DSP_VALUE 
43db cd c7 1d			call macro_forth_dsp_value 
43de				endm 
# End of macro FORTH_DSP_VALUE
43de			 
43de			 
43de					if DEBUG_FORTH_WORDS 
43de						DMARK "CN?" 
43de f5				push af  
43df 3a f3 43			ld a, (.dmark)  
43e2 32 71 ee			ld (debug_mark),a  
43e5 3a f4 43			ld a, (.dmark+1)  
43e8 32 72 ee			ld (debug_mark+1),a  
43eb 3a f5 43			ld a, (.dmark+2)  
43ee 32 73 ee			ld (debug_mark+2),a  
43f1 18 03			jr .pastdmark  
43f3 ..			.dmark: db "CN?"  
43f6 f1			.pastdmark: pop af  
43f7			endm  
# End of macro DMARK
43f7						CALLMONITOR 
43f7 cd 76 15			call break_point_state  
43fa				endm  
# End of macro CALLMONITOR
43fa					endif 
43fa cd d3 11				call strlenz 
43fd					if DEBUG_FORTH_WORDS 
43fd						DMARK "CNl" 
43fd f5				push af  
43fe 3a 12 44			ld a, (.dmark)  
4401 32 71 ee			ld (debug_mark),a  
4404 3a 13 44			ld a, (.dmark+1)  
4407 32 72 ee			ld (debug_mark+1),a  
440a 3a 14 44			ld a, (.dmark+2)  
440d 32 73 ee			ld (debug_mark+2),a  
4410 18 03			jr .pastdmark  
4412 ..			.dmark: db "CNl"  
4415 f1			.pastdmark: pop af  
4416			endm  
# End of macro DMARK
4416						CALLMONITOR 
4416 cd 76 15			call break_point_state  
4419				endm  
# End of macro CALLMONITOR
4419					endif 
4419			 
4419 cd e7 1b				call forth_push_numhl 
441c			 
441c			 
441c			 
441c				       NEXTW 
441c c3 55 1f			jp macro_next 
441f				endm 
# End of macro NEXTW
441f			.CHAR: 
441f				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
441f 4d				db WORD_SYS_CORE+57             
4420 55 44			dw .ENDSTR            
4422 05				db 4 + 1 
4423 .. 00			db "CHAR",0              
4428				endm 
# End of macro CWHEAD
4428			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4428					if DEBUG_FORTH_WORDS_KEY 
4428						DMARK "CHR" 
4428 f5				push af  
4429 3a 3d 44			ld a, (.dmark)  
442c 32 71 ee			ld (debug_mark),a  
442f 3a 3e 44			ld a, (.dmark+1)  
4432 32 72 ee			ld (debug_mark+1),a  
4435 3a 3f 44			ld a, (.dmark+2)  
4438 32 73 ee			ld (debug_mark+2),a  
443b 18 03			jr .pastdmark  
443d ..			.dmark: db "CHR"  
4440 f1			.pastdmark: pop af  
4441			endm  
# End of macro DMARK
4441						CALLMONITOR 
4441 cd 76 15			call break_point_state  
4444				endm  
# End of macro CALLMONITOR
4444					endif 
4444					FORTH_DSP 
4444 cd a4 1d			call macro_forth_dsp 
4447				endm 
# End of macro FORTH_DSP
4447					;v5 FORTH_DSP_VALUE 
4447 23					inc hl      ; now at start of numeric as string 
4448			 
4448			;		push hl 
4448			 
4448					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4448 cd 96 1e			call macro_forth_dsp_pop 
444b				endm 
# End of macro FORTH_DSP_POP
444b			 
444b			;		pop hl 
444b			 
444b					; push the content of a onto the stack as a value 
444b			 
444b 7e					ld a,(hl)   ; get char 
444c 26 00				ld h,0 
444e 6f					ld l,a 
444f cd e7 1b				call forth_push_numhl 
4452			 
4452				       NEXTW 
4452 c3 55 1f			jp macro_next 
4455				endm 
# End of macro NEXTW
4455			 
4455			 
4455			 
4455			 
4455			.ENDSTR: 
4455			; eof 
4455			 
# End of file forth_words_str.asm
4455			include "forth_words_key.asm" 
4455			 
4455			; | ## Keyboard Words 
4455			 
4455			.KEY: 
4455				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4455 3e				db WORD_SYS_CORE+42             
4456 85 44			dw .WAITK            
4458 04				db 3 + 1 
4459 .. 00			db "KEY",0              
445d				endm 
# End of macro CWHEAD
445d			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
445d			 
445d					if DEBUG_FORTH_WORDS_KEY 
445d						DMARK "KEY" 
445d f5				push af  
445e 3a 72 44			ld a, (.dmark)  
4461 32 71 ee			ld (debug_mark),a  
4464 3a 73 44			ld a, (.dmark+1)  
4467 32 72 ee			ld (debug_mark+1),a  
446a 3a 74 44			ld a, (.dmark+2)  
446d 32 73 ee			ld (debug_mark+2),a  
4470 18 03			jr .pastdmark  
4472 ..			.dmark: db "KEY"  
4475 f1			.pastdmark: pop af  
4476			endm  
# End of macro DMARK
4476						CALLMONITOR 
4476 cd 76 15			call break_point_state  
4479				endm  
# End of macro CALLMONITOR
4479					endif 
4479			; TODO currently waits 
4479 cd 9d 5b				call cin 
447c					;call cin_wait 
447c 6f					ld l, a 
447d 26 00				ld h, 0 
447f cd e7 1b				call forth_push_numhl 
4482					NEXTW 
4482 c3 55 1f			jp macro_next 
4485				endm 
# End of macro NEXTW
4485			.WAITK: 
4485				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4485 3f				db WORD_SYS_CORE+43             
4486 b7 44			dw .ACCEPT            
4488 06				db 5 + 1 
4489 .. 00			db "WAITK",0              
448f				endm 
# End of macro CWHEAD
448f			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
448f					if DEBUG_FORTH_WORDS_KEY 
448f						DMARK "WAI" 
448f f5				push af  
4490 3a a4 44			ld a, (.dmark)  
4493 32 71 ee			ld (debug_mark),a  
4496 3a a5 44			ld a, (.dmark+1)  
4499 32 72 ee			ld (debug_mark+1),a  
449c 3a a6 44			ld a, (.dmark+2)  
449f 32 73 ee			ld (debug_mark+2),a  
44a2 18 03			jr .pastdmark  
44a4 ..			.dmark: db "WAI"  
44a7 f1			.pastdmark: pop af  
44a8			endm  
# End of macro DMARK
44a8						CALLMONITOR 
44a8 cd 76 15			call break_point_state  
44ab				endm  
# End of macro CALLMONITOR
44ab					endif 
44ab cd 95 5b				call cin_wait 
44ae 6f					ld l, a 
44af 26 00				ld h, 0 
44b1 cd e7 1b				call forth_push_numhl 
44b4					NEXTW 
44b4 c3 55 1f			jp macro_next 
44b7				endm 
# End of macro NEXTW
44b7			.ACCEPT: 
44b7				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
44b7 40				db WORD_SYS_CORE+44             
44b8 15 45			dw .EDIT            
44ba 07				db 6 + 1 
44bb .. 00			db "ACCEPT",0              
44c2				endm 
# End of macro CWHEAD
44c2			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
44c2					; TODO crashes on push 
44c2					if DEBUG_FORTH_WORDS_KEY 
44c2						DMARK "ACC" 
44c2 f5				push af  
44c3 3a d7 44			ld a, (.dmark)  
44c6 32 71 ee			ld (debug_mark),a  
44c9 3a d8 44			ld a, (.dmark+1)  
44cc 32 72 ee			ld (debug_mark+1),a  
44cf 3a d9 44			ld a, (.dmark+2)  
44d2 32 73 ee			ld (debug_mark+2),a  
44d5 18 03			jr .pastdmark  
44d7 ..			.dmark: db "ACC"  
44da f1			.pastdmark: pop af  
44db			endm  
# End of macro DMARK
44db						CALLMONITOR 
44db cd 76 15			call break_point_state  
44de				endm  
# End of macro CALLMONITOR
44de					endif 
44de 21 00 e5				ld hl, os_input 
44e1 3e 00				ld a, 0 
44e3 77					ld (hl),a 
44e4 3a 6b ea				ld a,(f_cursor_ptr) 
44e7 16 64				ld d, 100 
44e9 0e 00				ld c, 0 
44eb 1e 28				ld e, 40 
44ed cd a2 0d				call input_str 
44f0					; TODO perhaps do a type check and wrap in quotes if not a number 
44f0 21 00 e5				ld hl, os_input 
44f3					if DEBUG_FORTH_WORDS 
44f3						DMARK "AC1" 
44f3 f5				push af  
44f4 3a 08 45			ld a, (.dmark)  
44f7 32 71 ee			ld (debug_mark),a  
44fa 3a 09 45			ld a, (.dmark+1)  
44fd 32 72 ee			ld (debug_mark+1),a  
4500 3a 0a 45			ld a, (.dmark+2)  
4503 32 73 ee			ld (debug_mark+2),a  
4506 18 03			jr .pastdmark  
4508 ..			.dmark: db "AC1"  
450b f1			.pastdmark: pop af  
450c			endm  
# End of macro DMARK
450c						CALLMONITOR 
450c cd 76 15			call break_point_state  
450f				endm  
# End of macro CALLMONITOR
450f					endif 
450f cd 55 1c				call forth_push_str 
4512					NEXTW 
4512 c3 55 1f			jp macro_next 
4515				endm 
# End of macro NEXTW
4515			 
4515			.EDIT: 
4515				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4515 40				db WORD_SYS_CORE+44             
4516 b7 45			dw .ENDKEY            
4518 05				db 4 + 1 
4519 .. 00			db "EDIT",0              
451e				endm 
# End of macro CWHEAD
451e			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
451e			 
451e					; TODO does not copy from stack 
451e					if DEBUG_FORTH_WORDS_KEY 
451e						DMARK "EDT" 
451e f5				push af  
451f 3a 33 45			ld a, (.dmark)  
4522 32 71 ee			ld (debug_mark),a  
4525 3a 34 45			ld a, (.dmark+1)  
4528 32 72 ee			ld (debug_mark+1),a  
452b 3a 35 45			ld a, (.dmark+2)  
452e 32 73 ee			ld (debug_mark+2),a  
4531 18 03			jr .pastdmark  
4533 ..			.dmark: db "EDT"  
4536 f1			.pastdmark: pop af  
4537			endm  
# End of macro DMARK
4537						CALLMONITOR 
4537 cd 76 15			call break_point_state  
453a				endm  
# End of macro CALLMONITOR
453a					endif 
453a			 
453a					;FORTH_DSP 
453a					FORTH_DSP_VALUEHL 
453a cd de 1d			call macro_dsp_valuehl 
453d				endm 
# End of macro FORTH_DSP_VALUEHL
453d			;		inc hl    ; TODO do type check 
453d			 
453d			;		call get_word_hl 
453d e5					push hl 
453e					if DEBUG_FORTH_WORDS 
453e						DMARK "EDp" 
453e f5				push af  
453f 3a 53 45			ld a, (.dmark)  
4542 32 71 ee			ld (debug_mark),a  
4545 3a 54 45			ld a, (.dmark+1)  
4548 32 72 ee			ld (debug_mark+1),a  
454b 3a 55 45			ld a, (.dmark+2)  
454e 32 73 ee			ld (debug_mark+2),a  
4551 18 03			jr .pastdmark  
4553 ..			.dmark: db "EDp"  
4556 f1			.pastdmark: pop af  
4557			endm  
# End of macro DMARK
4557						CALLMONITOR 
4557 cd 76 15			call break_point_state  
455a				endm  
# End of macro CALLMONITOR
455a					endif 
455a				;	ld a, 0 
455a cd d3 11				call strlenz 
455d 23					inc hl 
455e			 
455e 06 00				ld b, 0 
4560 4d					ld c, l 
4561			 
4561 e1					pop hl 
4562 11 00 e5				ld de, os_input 
4565					if DEBUG_FORTH_WORDS_KEY 
4565						DMARK "EDc" 
4565 f5				push af  
4566 3a 7a 45			ld a, (.dmark)  
4569 32 71 ee			ld (debug_mark),a  
456c 3a 7b 45			ld a, (.dmark+1)  
456f 32 72 ee			ld (debug_mark+1),a  
4572 3a 7c 45			ld a, (.dmark+2)  
4575 32 73 ee			ld (debug_mark+2),a  
4578 18 03			jr .pastdmark  
457a ..			.dmark: db "EDc"  
457d f1			.pastdmark: pop af  
457e			endm  
# End of macro DMARK
457e						CALLMONITOR 
457e cd 76 15			call break_point_state  
4581				endm  
# End of macro CALLMONITOR
4581					endif 
4581 ed b0				ldir 
4583			 
4583			 
4583 21 00 e5				ld hl, os_input 
4586					;ld a, 0 
4586					;ld (hl),a 
4586 3a 6b ea				ld a,(f_cursor_ptr) 
4589 16 64				ld d, 100 
458b 0e 00				ld c, 0 
458d 1e 28				ld e, 40 
458f cd a2 0d				call input_str 
4592					; TODO perhaps do a type check and wrap in quotes if not a number 
4592 21 00 e5				ld hl, os_input 
4595					if DEBUG_FORTH_WORDS 
4595						DMARK "ED1" 
4595 f5				push af  
4596 3a aa 45			ld a, (.dmark)  
4599 32 71 ee			ld (debug_mark),a  
459c 3a ab 45			ld a, (.dmark+1)  
459f 32 72 ee			ld (debug_mark+1),a  
45a2 3a ac 45			ld a, (.dmark+2)  
45a5 32 73 ee			ld (debug_mark+2),a  
45a8 18 03			jr .pastdmark  
45aa ..			.dmark: db "ED1"  
45ad f1			.pastdmark: pop af  
45ae			endm  
# End of macro DMARK
45ae						CALLMONITOR 
45ae cd 76 15			call break_point_state  
45b1				endm  
# End of macro CALLMONITOR
45b1					endif 
45b1 cd 55 1c				call forth_push_str 
45b4					NEXTW 
45b4 c3 55 1f			jp macro_next 
45b7				endm 
# End of macro NEXTW
45b7			 
45b7			 
45b7			 
45b7			.ENDKEY: 
45b7			; eof 
45b7			 
# End of file forth_words_key.asm
45b7			 
45b7			if STORAGE_SE 
45b7			   	include "forth_words_storage.asm" 
45b7			endif 
45b7				include "forth_words_device.asm" 
45b7			; Device related words 
45b7			 
45b7			; | ## Device Words 
45b7			 
45b7			if SOUND_ENABLE 
45b7			.NOTE: 
45b7				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
45b7			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
45b7					if DEBUG_FORTH_WORDS_KEY 
45b7						DMARK "NTE" 
45b7						CALLMONITOR 
45b7					endif 
45b7			 
45b7				 
45b7			 
45b7					NEXTW 
45b7			.AFTERSOUND: 
45b7			endif 
45b7			 
45b7			 
45b7			USE_GPIO: equ 0 
45b7			 
45b7			if USE_GPIO 
45b7			.GP1: 
45b7				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
45b7			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
45b7					NEXTW 
45b7			.GP2: 
45b7				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
45b7			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
45b7			 
45b7					NEXTW 
45b7			 
45b7			.GP3: 
45b7				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
45b7			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
45b7			 
45b7					NEXTW 
45b7			 
45b7			.GP4: 
45b7				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
45b7			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
45b7			 
45b7					NEXTW 
45b7			.SIN: 
45b7			 
45b7			 
45b7			endif 
45b7			 
45b7			 
45b7				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
45b7 33				db WORD_SYS_CORE+31             
45b8 ec 45			dw .SOUT            
45ba 03				db 2 + 1 
45bb .. 00			db "IN",0              
45be				endm 
# End of macro CWHEAD
45be			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
45be					if DEBUG_FORTH_WORDS_KEY 
45be						DMARK "IN." 
45be f5				push af  
45bf 3a d3 45			ld a, (.dmark)  
45c2 32 71 ee			ld (debug_mark),a  
45c5 3a d4 45			ld a, (.dmark+1)  
45c8 32 72 ee			ld (debug_mark+1),a  
45cb 3a d5 45			ld a, (.dmark+2)  
45ce 32 73 ee			ld (debug_mark+2),a  
45d1 18 03			jr .pastdmark  
45d3 ..			.dmark: db "IN."  
45d6 f1			.pastdmark: pop af  
45d7			endm  
# End of macro DMARK
45d7						CALLMONITOR 
45d7 cd 76 15			call break_point_state  
45da				endm  
# End of macro CALLMONITOR
45da					endif 
45da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45da cd de 1d			call macro_dsp_valuehl 
45dd				endm 
# End of macro FORTH_DSP_VALUEHL
45dd			 
45dd e5					push hl 
45de			 
45de					; destroy value TOS 
45de			 
45de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45de cd 96 1e			call macro_forth_dsp_pop 
45e1				endm 
# End of macro FORTH_DSP_POP
45e1			 
45e1					; one value on hl get other one back 
45e1			 
45e1 c1					pop bc 
45e2			 
45e2					; do the sub 
45e2			;		ex de, hl 
45e2			 
45e2 ed 68				in l,(c) 
45e4			 
45e4					; save it 
45e4			 
45e4 26 00				ld h,0 
45e6			 
45e6					; TODO push value back onto stack for another op etc 
45e6			 
45e6 cd e7 1b				call forth_push_numhl 
45e9					NEXTW 
45e9 c3 55 1f			jp macro_next 
45ec				endm 
# End of macro NEXTW
45ec			.SOUT: 
45ec				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
45ec 34				db WORD_SYS_CORE+32             
45ed 3f 46			dw .SPIO            
45ef 04				db 3 + 1 
45f0 .. 00			db "OUT",0              
45f4				endm 
# End of macro CWHEAD
45f4			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
45f4					if DEBUG_FORTH_WORDS_KEY 
45f4						DMARK "OUT" 
45f4 f5				push af  
45f5 3a 09 46			ld a, (.dmark)  
45f8 32 71 ee			ld (debug_mark),a  
45fb 3a 0a 46			ld a, (.dmark+1)  
45fe 32 72 ee			ld (debug_mark+1),a  
4601 3a 0b 46			ld a, (.dmark+2)  
4604 32 73 ee			ld (debug_mark+2),a  
4607 18 03			jr .pastdmark  
4609 ..			.dmark: db "OUT"  
460c f1			.pastdmark: pop af  
460d			endm  
# End of macro DMARK
460d						CALLMONITOR 
460d cd 76 15			call break_point_state  
4610				endm  
# End of macro CALLMONITOR
4610					endif 
4610			 
4610					; get port 
4610			 
4610					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4610 cd de 1d			call macro_dsp_valuehl 
4613				endm 
# End of macro FORTH_DSP_VALUEHL
4613			 
4613 e5					push hl 
4614			 
4614					; destroy value TOS 
4614			 
4614					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4614 cd 96 1e			call macro_forth_dsp_pop 
4617				endm 
# End of macro FORTH_DSP_POP
4617			 
4617					; get byte to send 
4617			 
4617					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4617 cd de 1d			call macro_dsp_valuehl 
461a				endm 
# End of macro FORTH_DSP_VALUEHL
461a			 
461a			;		push hl 
461a			 
461a					; destroy value TOS 
461a			 
461a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
461a cd 96 1e			call macro_forth_dsp_pop 
461d				endm 
# End of macro FORTH_DSP_POP
461d			 
461d					; one value on hl get other one back 
461d			 
461d			;		pop hl 
461d			 
461d c1					pop bc 
461e			 
461e					if DEBUG_FORTH_WORDS 
461e						DMARK "OUT" 
461e f5				push af  
461f 3a 33 46			ld a, (.dmark)  
4622 32 71 ee			ld (debug_mark),a  
4625 3a 34 46			ld a, (.dmark+1)  
4628 32 72 ee			ld (debug_mark+1),a  
462b 3a 35 46			ld a, (.dmark+2)  
462e 32 73 ee			ld (debug_mark+2),a  
4631 18 03			jr .pastdmark  
4633 ..			.dmark: db "OUT"  
4636 f1			.pastdmark: pop af  
4637			endm  
# End of macro DMARK
4637						CALLMONITOR 
4637 cd 76 15			call break_point_state  
463a				endm  
# End of macro CALLMONITOR
463a					endif 
463a			 
463a ed 69				out (c), l 
463c			 
463c					NEXTW 
463c c3 55 1f			jp macro_next 
463f				endm 
# End of macro NEXTW
463f			 
463f			 
463f			.SPIO: 
463f			 
463f			if STORAGE_SE 
463f				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
463f			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
463f			 
463f					call spi_ce_low 
463f			    NEXTW 
463f			 
463f			.SPICEH: 
463f				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
463f			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
463f			 
463f					call spi_ce_high 
463f			    NEXTW 
463f			 
463f			 
463f			.SPIOb: 
463f			 
463f				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
463f			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
463f			 
463f					; get port 
463f			 
463f			 
463f					; get byte to send 
463f			 
463f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
463f			 
463f			;		push hl    ; u1  
463f			 
463f					; destroy value TOS 
463f			 
463f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
463f			 
463f					; one value on hl get other one back 
463f			 
463f			;		pop hl   ; u2 - addr 
463f			 
463f					; TODO Send SPI byte 
463f			 
463f					ld a, l 
463f					call spi_send_byte 
463f			 
463f					NEXTW 
463f			 
463f			.SPII: 
463f				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
463f			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
463f			 
463f					; TODO Get SPI byte 
463f			 
463f					call spi_read_byte 
463f			 
463f					ld h, 0 
463f					ld l, a 
463f					call forth_push_numhl 
463f			 
463f					NEXTW 
463f			 
463f			 
463f			 
463f			.SESEL: 
463f				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
463f			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
463f					if DEBUG_FORTH_WORDS_KEY 
463f						DMARK "BNK" 
463f						CALLMONITOR 
463f					endif 
463f			 
463f					ld a, 255 
463f					ld (spi_cartdev), a 
463f			 
463f					; get bank 
463f			 
463f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
463f			 
463f			;		push hl 
463f			 
463f					; destroy value TOS 
463f			 
463f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
463f			 
463f					; one value on hl get other one back 
463f			 
463f			;		pop hl 
463f			 
463f			 
463f					ld c, SPI_CE_HIGH 
463f					ld b, '0'    ; human readable bank number 
463f			 
463f					ld a, l 
463f			 
463f					if DEBUG_FORTH_WORDS 
463f						DMARK "BNK" 
463f						CALLMONITOR 
463f					endif 
463f			 
463f					; active low 
463f			 
463f					cp 0 
463f					jr z, .bset 
463f					cp 1 
463f					jr nz, .b2 
463f					res 0, c 
463f					ld b, '1'    ; human readable bank number 
463f			.b2:		cp 2 
463f					jr nz, .b3 
463f					res 1, c 
463f					ld b, '2'    ; human readable bank number 
463f			.b3:		cp 3 
463f					jr nz, .b4 
463f					res 2, c 
463f					ld b, '3'    ; human readable bank number 
463f			.b4:		cp 4 
463f					jr nz, .b5 
463f					res 3, c 
463f					ld b, '4'    ; human readable bank number 
463f			.b5:		cp 5 
463f					jr nz, .bset 
463f					res 4, c 
463f					ld b, '5'    ; human readable bank number 
463f			 
463f			.bset: 
463f					ld a, c 
463f					ld (spi_device),a 
463f					ld a, b 
463f					ld (spi_device_id),a 
463f					if DEBUG_FORTH_WORDS 
463f						DMARK "BN2" 
463f						CALLMONITOR 
463f					endif 
463f			 
463f					NEXTW 
463f			 
463f			.CARTDEV: 
463f				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
463f			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
463f					if DEBUG_FORTH_WORDS_KEY 
463f						DMARK "CDV" 
463f						CALLMONITOR 
463f					endif 
463f			 
463f					; disable se storage bank selection 
463f			 
463f					ld a, SPI_CE_HIGH		; ce high 
463f					ld (spi_device), a 
463f			 
463f					; get bank 
463f			 
463f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
463f			 
463f			;		push hl 
463f			 
463f					; destroy value TOS 
463f			 
463f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
463f			 
463f					; one value on hl get other one back 
463f			 
463f			;		pop hl 
463f			 
463f					; active low 
463f			 
463f					ld c, 255 
463f			 
463f					ld a, l 
463f					if DEBUG_FORTH_WORDS 
463f						DMARK "CDV" 
463f						CALLMONITOR 
463f					endif 
463f					cp 0 
463f					jr z, .cset 
463f					cp 1 
463f					jr nz, .c2 
463f					res 0, c 
463f			.c2:		cp 2 
463f					jr nz, .c3 
463f					res 1, c 
463f			.c3:		cp 3 
463f					jr nz, .c4 
463f					res 2, c 
463f			.c4:		cp 4 
463f					jr nz, .c5 
463f					res 3, c 
463f			.c5:		cp 5 
463f					jr nz, .c6 
463f					res 4, c 
463f			.c6:		cp 6 
463f					jr nz, .c7 
463f					res 5, c 
463f			.c7:		cp 7 
463f					jr nz, .c8 
463f					res 6, c 
463f			.c8:		cp 8 
463f					jr nz, .cset 
463f					res 7, c 
463f			.cset:		ld a, c 
463f					ld (spi_cartdev),a 
463f			 
463f					if DEBUG_FORTH_WORDS 
463f						DMARK "CD2" 
463f						CALLMONITOR 
463f					endif 
463f					NEXTW 
463f			endif 
463f			 
463f			.ENDDEVICE: 
463f			; eof 
463f			 
# End of file forth_words_device.asm
463f			 
463f			; var handler 
463f			 
463f			 
463f			.VARS: 
463f				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
463f 78				db WORD_SYS_CORE+100             
4640 57 46			dw .V0Q            
4642 04				db 3 + 1 
4643 .. 00			db "V0!",0              
4647				endm 
# End of macro CWHEAD
4647			;| V0! ( u1 -- )  Store value to v0  | DONE 
4647			 
4647					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4647 cd de 1d			call macro_dsp_valuehl 
464a				endm 
# End of macro FORTH_DSP_VALUEHL
464a			 
464a 11 35 ea				ld de, cli_var_array 
464d			 
464d eb					ex de, hl 
464e 73					ld (hl), e 
464f 23					inc hl 
4650 72					ld (hl), d 
4651			 
4651					; destroy value TOS 
4651			 
4651					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4651 cd 96 1e			call macro_forth_dsp_pop 
4654				endm 
# End of macro FORTH_DSP_POP
4654			 
4654				       NEXTW 
4654 c3 55 1f			jp macro_next 
4657				endm 
# End of macro NEXTW
4657			.V0Q: 
4657				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4657 79				db WORD_SYS_CORE+101             
4658 68 46			dw .V1S            
465a 04				db 3 + 1 
465b .. 00			db "V0@",0              
465f				endm 
# End of macro CWHEAD
465f			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
465f 2a 35 ea				ld hl, (cli_var_array) 
4662 cd e7 1b				call forth_push_numhl 
4665			 
4665				       NEXTW 
4665 c3 55 1f			jp macro_next 
4668				endm 
# End of macro NEXTW
4668			.V1S: 
4668				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4668 7a				db WORD_SYS_CORE+102             
4669 80 46			dw .V1Q            
466b 04				db 3 + 1 
466c .. 00			db "V1!",0              
4670				endm 
# End of macro CWHEAD
4670			;| V1! ( u1 -- )  Store value to v1 | DONE 
4670					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4670 cd de 1d			call macro_dsp_valuehl 
4673				endm 
# End of macro FORTH_DSP_VALUEHL
4673			 
4673 11 37 ea				ld de, cli_var_array+2 
4676				 
4676 eb					ex de, hl 
4677 73					ld (hl), e 
4678 23					inc hl 
4679 72					ld (hl), d 
467a			 
467a					; destroy value TOS 
467a			 
467a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
467a cd 96 1e			call macro_forth_dsp_pop 
467d				endm 
# End of macro FORTH_DSP_POP
467d				       NEXTW 
467d c3 55 1f			jp macro_next 
4680				endm 
# End of macro NEXTW
4680			.V1Q: 
4680				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4680 7b				db WORD_SYS_CORE+103             
4681 91 46			dw .V2S            
4683 04				db 3 + 1 
4684 .. 00			db "V1@",0              
4688				endm 
# End of macro CWHEAD
4688			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4688 2a 37 ea				ld hl, (cli_var_array+2) 
468b cd e7 1b				call forth_push_numhl 
468e				       NEXTW 
468e c3 55 1f			jp macro_next 
4691				endm 
# End of macro NEXTW
4691			.V2S: 
4691				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4691 7c				db WORD_SYS_CORE+104             
4692 a9 46			dw .V2Q            
4694 04				db 3 + 1 
4695 .. 00			db "V2!",0              
4699				endm 
# End of macro CWHEAD
4699			;| V2! ( u1 -- )  Store value to v2 | DONE 
4699					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4699 cd de 1d			call macro_dsp_valuehl 
469c				endm 
# End of macro FORTH_DSP_VALUEHL
469c			 
469c 11 39 ea				ld de, cli_var_array+4 
469f				 
469f eb					ex de, hl 
46a0 73					ld (hl), e 
46a1 23					inc hl 
46a2 72					ld (hl), d 
46a3			 
46a3					; destroy value TOS 
46a3			 
46a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46a3 cd 96 1e			call macro_forth_dsp_pop 
46a6				endm 
# End of macro FORTH_DSP_POP
46a6				       NEXTW 
46a6 c3 55 1f			jp macro_next 
46a9				endm 
# End of macro NEXTW
46a9			.V2Q: 
46a9				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
46a9 7d				db WORD_SYS_CORE+105             
46aa ba 46			dw .V3S            
46ac 04				db 3 + 1 
46ad .. 00			db "V2@",0              
46b1				endm 
# End of macro CWHEAD
46b1			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
46b1 2a 39 ea				ld hl, (cli_var_array+4) 
46b4 cd e7 1b				call forth_push_numhl 
46b7				       NEXTW 
46b7 c3 55 1f			jp macro_next 
46ba				endm 
# End of macro NEXTW
46ba			.V3S: 
46ba				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
46ba 7c				db WORD_SYS_CORE+104             
46bb d2 46			dw .V3Q            
46bd 04				db 3 + 1 
46be .. 00			db "V3!",0              
46c2				endm 
# End of macro CWHEAD
46c2			;| V3! ( u1 -- )  Store value to v3 | DONE 
46c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46c2 cd de 1d			call macro_dsp_valuehl 
46c5				endm 
# End of macro FORTH_DSP_VALUEHL
46c5			 
46c5 11 3b ea				ld de, cli_var_array+6 
46c8				 
46c8 eb					ex de, hl 
46c9 73					ld (hl), e 
46ca 23					inc hl 
46cb 72					ld (hl), d 
46cc			 
46cc					; destroy value TOS 
46cc			 
46cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46cc cd 96 1e			call macro_forth_dsp_pop 
46cf				endm 
# End of macro FORTH_DSP_POP
46cf				       NEXTW 
46cf c3 55 1f			jp macro_next 
46d2				endm 
# End of macro NEXTW
46d2			.V3Q: 
46d2				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
46d2 7d				db WORD_SYS_CORE+105             
46d3 e3 46			dw .END            
46d5 04				db 3 + 1 
46d6 .. 00			db "V3@",0              
46da				endm 
# End of macro CWHEAD
46da			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
46da 2a 3b ea				ld hl, (cli_var_array+6) 
46dd cd e7 1b				call forth_push_numhl 
46e0				       NEXTW 
46e0 c3 55 1f			jp macro_next 
46e3				endm 
# End of macro NEXTW
46e3			 
46e3			 
46e3			 
46e3			 
46e3			 
46e3			; end of dict marker 
46e3			 
46e3 00			.END:    db WORD_SYS_END 
46e4 00 00			dw 0 
46e6 00				db 0 
46e7			 
46e7			; use to jp here for user dict words to save on macro expansion  
46e7			 
46e7			user_dict_next: 
46e7				NEXTW 
46e7 c3 55 1f			jp macro_next 
46ea				endm 
# End of macro NEXTW
46ea			 
46ea			 
46ea			user_exec: 
46ea				;    ld hl, <word code> 
46ea				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
46ea				;    call forthexec 
46ea				;    jp user_dict_next   (NEXT) 
46ea			        ;    <word code bytes> 
46ea eb				ex de, hl 
46eb 2a 03 e6			ld hl,(os_tok_ptr) 
46ee				 
46ee				FORTH_RSP_NEXT 
46ee cd 8e 1b			call macro_forth_rsp_next 
46f1				endm 
# End of macro FORTH_RSP_NEXT
46f1			 
46f1			if DEBUG_FORTH_UWORD 
46f1						DMARK "UEX" 
46f1 f5				push af  
46f2 3a 06 47			ld a, (.dmark)  
46f5 32 71 ee			ld (debug_mark),a  
46f8 3a 07 47			ld a, (.dmark+1)  
46fb 32 72 ee			ld (debug_mark+1),a  
46fe 3a 08 47			ld a, (.dmark+2)  
4701 32 73 ee			ld (debug_mark+2),a  
4704 18 03			jr .pastdmark  
4706 ..			.dmark: db "UEX"  
4709 f1			.pastdmark: pop af  
470a			endm  
# End of macro DMARK
470a				CALLMONITOR 
470a cd 76 15			call break_point_state  
470d				endm  
# End of macro CALLMONITOR
470d			endif 
470d			 
470d			 
470d			 
470d eb				ex de, hl 
470e 22 03 e6			ld (os_tok_ptr), hl 
4711				 
4711				; Don't use next - Skips the first word in uword. 
4711			 
4711 c3 e6 1f			jp exec1 
4714			;	NEXT 
4714			 
4714			 
4714			; eof 
# End of file forth_wordsv4.asm
4714			endif 
4714			;;;;;;;;;;;;;; Debug code 
4714			 
4714			 
4714			;if DEBUG_FORTH_PARSE 
4714 .. 00		.nowordfound: db "No match",0 
471d .. 00		.compword:	db "Comparing word ",0 
472d .. 00		.nextwordat:	db "Next word at",0 
473a .. 00		.charmatch:	db "Char match",0 
4745			;endif 
4745			if DEBUG_FORTH_JP 
4745			.foundword:	db "Word match. Exec..",0 
4745			endif 
4745			;if DEBUG_FORTH_PUSH 
4745 .. 00		.enddict:	db "Dict end. Push.",0 
4755 .. 00		.push_str:	db "Pushing string",0 
4764 .. 00		.push_num:	db "Pushing number",0 
4773 .. 00		.data_sp:	db "SP:",0 
4777 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4789 .. 00		.wordinde:	db "Word in DE (3/0):",0 
479b .. 00		.wordinbc:	db "Word in BC (4/0):",0 
47ad			;endif 
47ad			;if DEBUG_FORTH_MALLOC 
47ad .. 00		.push_malloc:	db "Malloc address",0 
47bc			;endif 
47bc			 
47bc			 
47bc			 
47bc			; display malloc address and current data stack pointer  
47bc			 
47bc			malloc_error: 
47bc d5				push de 
47bd f5				push af 
47be e5				push hl 
47bf cd 48 0b			call clear_display 
47c2 11 e4 47			ld de, .mallocerr 
47c5 3e 00			ld a,0 
47c7			;	ld de,os_word_scratch 
47c7 cd 5b 0b			call str_at_display 
47ca 3e 11			ld a, display_row_1+17 
47cc 11 71 ee			ld de, debug_mark 
47cf cd 5b 0b			call str_at_display 
47d2 cd 6b 0b			call update_display 
47d5				;call break_point_state 
47d5 cd 95 5b			call cin_wait 
47d8			 
47d8 3e 20			ld a, ' ' 
47da 32 f3 e2			ld (os_view_disable), a 
47dd e1				pop hl 
47de f1				pop af 
47df d1				pop de	 
47e0				CALLMONITOR 
47e0 cd 76 15			call break_point_state  
47e3				endm  
# End of macro CALLMONITOR
47e3 c9				ret 
47e4			 
47e4 .. 00		.mallocerr: 	db "Malloc Error",0 
47f1			;if DEBUG_FORTH_PUSH 
47f1			display_data_sp: 
47f1 f5				push af 
47f2			 
47f2				; see if disabled 
47f2			 
47f2 3a f3 e2			ld a, (os_view_disable) 
47f5 fe 2a			cp '*' 
47f7 28 67			jr z, .skipdsp 
47f9			 
47f9 e5				push hl 
47fa e5				push hl 
47fb e5			push hl 
47fc cd 48 0b			call clear_display 
47ff e1			pop hl 
4800 7c				ld a,h 
4801 21 07 e6			ld hl, os_word_scratch 
4804 cd 76 10			call hexout 
4807 e1				pop hl 
4808 7d				ld a,l 
4809 21 09 e6			ld hl, os_word_scratch+2 
480c cd 76 10			call hexout 
480f 21 0b e6			ld hl, os_word_scratch+4 
4812 3e 00			ld a,0 
4814 77				ld (hl),a 
4815 11 07 e6			ld de,os_word_scratch 
4818 3e 28				ld a, display_row_2 
481a cd 5b 0b				call str_at_display 
481d 11 77 47			ld de, .wordinhl 
4820 3e 00			ld a, display_row_1 
4822			 
4822 cd 5b 0b				call str_at_display 
4825 11 71 ee			ld de, debug_mark 
4828 3e 11			ld a, display_row_1+17 
482a			 
482a cd 5b 0b				call str_at_display 
482d			 
482d				; display current data stack pointer 
482d 11 73 47			ld de,.data_sp 
4830 3e 30				ld a, display_row_2 + 8 
4832 cd 5b 0b				call str_at_display 
4835			 
4835 2a 2f ea			ld hl,(cli_data_sp) 
4838 e5				push hl 
4839 7c				ld a,h 
483a 21 07 e6			ld hl, os_word_scratch 
483d cd 76 10			call hexout 
4840 e1				pop hl 
4841 7d				ld a,l 
4842 21 09 e6			ld hl, os_word_scratch+2 
4845 cd 76 10			call hexout 
4848 21 0b e6			ld hl, os_word_scratch+4 
484b 3e 00			ld a,0 
484d 77				ld (hl),a 
484e 11 07 e6			ld de,os_word_scratch 
4851 3e 33				ld a, display_row_2 + 11 
4853 cd 5b 0b				call str_at_display 
4856			 
4856			 
4856 cd 6b 0b			call update_display 
4859 cd ba 0a			call delay1s 
485c cd ba 0a			call delay1s 
485f e1				pop hl 
4860			.skipdsp: 
4860 f1				pop af 
4861 c9				ret 
4862			 
4862			display_data_malloc: 
4862			 
4862 f5				push af 
4863 e5				push hl 
4864 e5				push hl 
4865 e5			push hl 
4866 cd 48 0b			call clear_display 
4869 e1			pop hl 
486a 7c				ld a,h 
486b 21 07 e6			ld hl, os_word_scratch 
486e cd 76 10			call hexout 
4871 e1				pop hl 
4872 7d				ld a,l 
4873 21 09 e6			ld hl, os_word_scratch+2 
4876 cd 76 10			call hexout 
4879 21 0b e6			ld hl, os_word_scratch+4 
487c 3e 00			ld a,0 
487e 77				ld (hl),a 
487f 11 07 e6			ld de,os_word_scratch 
4882 3e 28				ld a, display_row_2 
4884 cd 5b 0b				call str_at_display 
4887 11 ad 47			ld de, .push_malloc 
488a 3e 00			ld a, display_row_1 
488c			 
488c cd 5b 0b				call str_at_display 
488f			 
488f				; display current data stack pointer 
488f 11 73 47			ld de,.data_sp 
4892 3e 30				ld a, display_row_2 + 8 
4894 cd 5b 0b				call str_at_display 
4897			 
4897 2a 2f ea			ld hl,(cli_data_sp) 
489a e5				push hl 
489b 7c				ld a,h 
489c 21 07 e6			ld hl, os_word_scratch 
489f cd 76 10			call hexout 
48a2 e1				pop hl 
48a3 7d				ld a,l 
48a4 21 09 e6			ld hl, os_word_scratch+2 
48a7 cd 76 10			call hexout 
48aa 21 0b e6			ld hl, os_word_scratch+4 
48ad 3e 00			ld a,0 
48af 77				ld (hl),a 
48b0 11 07 e6			ld de,os_word_scratch 
48b3 3e 33				ld a, display_row_2 + 11 
48b5 cd 5b 0b				call str_at_display 
48b8			 
48b8 cd 6b 0b			call update_display 
48bb cd ba 0a			call delay1s 
48be cd ba 0a			call delay1s 
48c1 e1				pop hl 
48c2 f1				pop af 
48c3 c9				ret 
48c4			;endif 
48c4			 
48c4			include "forth_autostart.asm" 
48c4			; list of commands to perform at system start up 
48c4			 
48c4			startcmds: 
48c4			;	dw test11 
48c4			;	dw test12 
48c4			;	dw test13 
48c4			;	dw test14 
48c4			;	dw test15 
48c4			;	dw test16 
48c4			;	dw test17 
48c4			;	dw ifthtest1 
48c4			;	dw ifthtest2 
48c4			;	dw ifthtest3 
48c4			;	dw mmtest1 
48c4			;	dw mmtest2 
48c4			;	dw mmtest3 
48c4			;	dw mmtest4 
48c4			;	dw mmtest5 
48c4			;	dw mmtest6 
48c4			;	dw iftest1 
48c4			;	dw iftest2 
48c4			;	dw iftest3 
48c4			;	dw looptest1 
48c4			;	dw looptest2 
48c4			;	dw test1 
48c4			;	dw test2 
48c4			;	dw test3 
48c4			;	dw test4 
48c4			;	dw game2r 
48c4			;	dw game2b1 
48c4			;	dw game2b2 
48c4			 
48c4				; start up words that are actually useful 
48c4			 
48c4 24 49			dw longread 
48c6 4a 49			dw clrstack 
48c8 7d 49			dw type 
48ca 6d 4b			dw stest 
48cc a1 49			dw strncpy 
48ce 03 4b			dw list 
48d0 02 4a			dw start1 
48d2 14 4a			dw start2 
48d4			;	dw start3 
48d4 27 4a			dw start3b 
48d6 a3 4a			dw start3c 
48d8			 
48d8				; (unit) testing words 
48d8			 
48d8 e4 4b			dw mtesta 
48da 99 4c			dw mtestb 
48dc 3c 4d			dw mtestc 
48de f1 4d			dw mtestd 
48e0 95 4e			dw mteste 
48e2			 
48e2				; demo/game words 
48e2			 
48e2 a1 55		        dw game3w 
48e4 cf 55		        dw game3p 
48e6 ed 55		        dw game3sc 
48e8 1e 56		        dw game3vsi 
48ea 4a 56		        dw game3vs 
48ec				 
48ec 94 53			dw game2b 
48ee 02 54			dw game2bf 
48f0 4c 54			dw game2mba 
48f2 e2 54			dw game2mbas 
48f4 24 55			dw game2mb 
48f6			 
48f6 55 50			dw game1 
48f8 66 50			dw game1a 
48fa c8 50			dw game1b 
48fc fd 50			dw game1c 
48fe 33 51			dw game1d 
4900 64 51			dw game1s 
4902 78 51			dw game1t 
4904 8d 51			dw game1f 
4906 c1 51			dw game1z 
4908 05 52			dw game1zz 
490a			 
490a 4b 4f			dw test5 
490c 83 4f			dw test6 
490e bb 4f			dw test7 
4910 cf 4f			dw test8 
4912 fb 4f			dw test9 
4914 11 50			dw test10 
4916				 
4916 dc 52		        dw ssv5 
4918 c0 52		        dw ssv4 
491a a4 52		        dw ssv3 
491c 6e 52		        dw ssv2 
491e f5 52		        dw ssv1 
4920 3d 53		        dw ssv1cpm 
4922			;	dw keyup 
4922			;	dw keydown 
4922			;	dw keyleft 
4922			;	dw keyright 
4922			;	dw 	keyf1 
4922			;	dw keyf2 
4922			;	dw keyf3 
4922			;	dw keyf4 
4922			;	dw keyf5 
4922			;	dw keyf6 
4922			;	dw keyf7 
4922			;	dw keyf8 
4922			;	dw keyf9 
4922			;	dw keyf10 
4922			;	dw keyf11 
4922			;	dw keyf12 
4922			;	dw keytab 
4922			;	dw keycr 
4922			;	dw keyhome 
4922			;	dw keyend 
4922			;	dw keybs 
4922 00 00			db 0, 0	 
4924			 
4924			 
4924			; Long read 
4924			; e.g. $01 lread 
4924			; 
4924			; TODO need some constants 
4924			 
4924 .. 00		longread:   db ": lread read repeat count $3e = if ; ", 0 
494a			 
494a			; clear stack  
494a			 
494a .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
497d			 
497d			; type ( addr count - ) 
497d .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
49a1			 
49a1			; some direct memory words 
49a1			; strncpy ( len t f -- t ) 
49a1			 
49a1 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4a02			 
4a02 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4a14 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4a27 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
4aa3 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
4b03			 
4b03			 
4b03			; a handy word to list items on the stack 
4b03			 
4b03 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
4b6d			 
4b6d			 
4b6d			; test stack  
4b6d			; rnd8 stest 
4b6d			 
4b6d .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4be4			 
4be4			; random malloc and free cycles 
4be4			 
4be4 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4c99			 
4c99			; fixed malloc and free cycles 
4c99			 
4c99 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4d3c			 
4d3c			; fixed double string push and drop cycle  
4d3c			 
4d3c .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4df1			 
4df1			; consistent fixed string push and drop cycle  
4df1			 
4df1 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4e95			 
4e95 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4f4b			 
4f4b			;test1:		db ": aa 1 2 3 ;", 0 
4f4b			;test2:     	db "111 aa 888 999",0 
4f4b			;test3:     	db ": bb 77 ;",0 
4f4b			;test4:     	db "$02 $01 do i . loop bb",0 
4f4b			 
4f4b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4f83 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4fbb .. 00		test7:     	db ": box hline vline ;",0 
4fcf .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4ffb .. 00		test9:     	db ": sw $01 adsp world ;",0 
5011 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5036 .. 00		test11:     	db "hello create .",0 
5045 .. 00		test12:     	db "hello2 create .",0 
5055			 
5055			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5055			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5055			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5055			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5055			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5055			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5055			 
5055			;iftest1:     	db "$0001 IF cls .",0 
5055			;iftest2:     	db "$0000 IF cls .",0 
5055			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5055			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5055			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5055			 
5055			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5055			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5055			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5055			 
5055			 
5055			 
5055			; a small guess the number game 
5055			 
5055 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5066 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
50c8			 
50c8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
50fd .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5133 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5164 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5178 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
518d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
51c1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5205			 
5205			; Using 'ga' save a high score across multiple runs using external storage 
5205			 
5205 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
526e			 
526e			 
526e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
526e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
526e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
526e			 
526e			; simple screen saver to test code memory reuse to destruction 
526e			 
526e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
52a4 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
52c0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
52dc .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
52f5 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
533d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5394			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5394			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5394			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5394			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5394			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5394			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5394			 
5394			 
5394			 
5394			; minesweeper/battleship finding game 
5394			; draws a game board of random ship/mine positions 
5394			; user enters coords to see if it hits on 
5394			; game ends when all are hit 
5394			; when hit or miss says how many may be in the area 
5394			 
5394			; setup the game board and then hide it 
5394 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5402 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
544c			; prompt for where to target 
544c .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
54e2 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5507			; TODO see if the entered coords hits or misses pushes char hit of miss 
5507 .. 00		game2mbht:      db ": mbckht nop ;",0 
5516 .. 00		game2mbms:      db ": mbcms nop ;",0 
5524			; TODO how many might be near by 
5524 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
55a1			 
55a1			; Game 3 
55a1			 
55a1			; Vert scroller ski game - avoid the trees! 
55a1			 
55a1			; v0 score (ie turns) 
55a1			; v1 player pos 
55a1			; v2 left wall 
55a1			; v3 right wall 
55a1			 
55a1			; Draw side walls randomly 
55a1			 
55a1 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
55cf			 
55cf			; Draw player 
55cf .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
55ed			 
55ed			; TODO Get Key 
55ed			 
55ed			; TODO Move left right 
55ed			 
55ed			; scroll and move walls a bit 
55ed			 
55ed .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
561e			 
561e			; main game loop 
561e			 
561e .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
564a .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5689			 
5689			; key board defs 
5689			 
5689 .. 00		keyup:       db ": keyup $05 ;",0 
5697 .. 00		keydown:       db ": keydown $0a ;",0 
56a7 .. 00		keyleft:       db ": keyleft $0b ;",0 
56b7 .. 00		keyright:       db ": keyright $0c ;",0 
56c8 .. 00		keyf1:       db ": keyf1 $10 ;",0 
56d6 .. 00		keyf2:       db ": keyf2 $11 ;",0 
56e4 .. 00		keyf3:       db ": keyf3 $12 ;",0 
56f2 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5700 .. 00		keyf5:       db ": keyf5 $14 ;",0 
570e .. 00		keyf6:       db ": keyf6 $15 ;",0 
571c .. 00		keyf7:       db ": keyf7 $16 ;",0 
572a .. 00		keyf8:       db ": keyf8 $17 ;",0 
5738 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5746 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5755 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5764 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5773			 
5773 .. 00		keytab:       db ": keytab $09 ;",0 
5782 .. 00		keycr:       db ": keycr $0d ;",0 
5790 .. 00		keyhome:       db ": keyhome $0e ;",0 
57a0 .. 00		keyend:       db ": keyend $0f ;",0 
57af .. 00		keybs:       db ": keybs $08 ;",0 
57bd			 
57bd			   
57bd			 
57bd			 
57bd			 
57bd			; eof 
# End of file forth_autostart.asm
57bd			 
57bd .. 00		sprompt1: db "Startup load...",0 
57cd .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
57e3			 
57e3			 
57e3			 
57e3			 
57e3			forth_startup: 
57e3 21 c4 48			ld hl, startcmds 
57e6 3e 00			ld a, 0 
57e8 32 28 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
57eb			 
57eb e5			.start1:	push hl 
57ec cd 48 0b			call clear_display 
57ef 11 bd 57			ld de, sprompt1 
57f2 3e 00		        ld a, display_row_1 
57f4 cd 5b 0b			call str_at_display 
57f7 11 cd 57			ld de, sprompt2 
57fa 3e 28		        ld a, display_row_2 
57fc cd 5b 0b			call str_at_display 
57ff e1				pop hl 
5800 e5				push hl 
5801 5e				ld e,(hl) 
5802 23				inc hl 
5803 56				ld d,(hl) 
5804 3e 50		        ld a, display_row_3 
5806 cd 5b 0b			call str_at_display 
5809 cd 6b 0b			call update_display 
580c			 
580c			 
580c 3a 28 e7			ld a, (os_last_cmd) 
580f fe 00			cp 0 
5811 28 05			jr z, .startprompt 
5813 cd ae 0a			call delay250ms 
5816 18 24			jr .startdo 
5818				 
5818				 
5818			 
5818			.startprompt: 
5818			 
5818 3e 9f			ld a,display_row_4 + display_cols - 1 
581a 11 5d 1b		        ld de, endprg 
581d cd 5b 0b			call str_at_display 
5820 cd 6b 0b			call update_display 
5823 cd ba 0a			call delay1s 
5826 cd 95 5b			call cin_wait 
5829						 
5829 fe 2a			cp '*' 
582b 28 5e			jr z, .startupend1 
582d fe 23			cp '#' 
582f 20 07			jr nz, .startno 
5831 3e 01			ld a, 1 
5833 32 28 e7			ld (os_last_cmd),a 
5836 18 04			jr .startdo 
5838 fe 31		.startno:	cp '1' 
583a 28 3a			jr z,.startnxt  
583c			 
583c				; exec startup line 
583c			.startdo:	 
583c e1				pop hl 
583d e5				push hl 
583e				 
583e 5e				ld e,(hl) 
583f 23				inc hl 
5840 56				ld d,(hl) 
5841 eb				ex de,hl 
5842			 
5842 e5				push hl 
5843			 
5843 3e 00			ld a, 0 
5845				;ld a, FORTH_END_BUFFER 
5845 cd de 11			call strlent 
5848 23				inc hl   ; include zero term to copy 
5849 06 00			ld b,0 
584b 4d				ld c,l 
584c e1				pop hl 
584d 11 02 e3			ld de, scratch 
5850 ed b0			ldir 
5852			 
5852			 
5852 21 02 e3			ld hl, scratch 
5855 cd a3 1f			call forthparse 
5858 cd e3 1f			call forthexec 
585b cd f5 1e			call forthexec_cleanup 
585e			 
585e 3e 78			ld a, display_row_4 
5860 11 01 19			ld de, endprog 
5863			 
5863 cd 6b 0b			call update_display		 
5866			 
5866 3a 28 e7			ld a, (os_last_cmd) 
5869 fe 00			cp 0 
586b 20 09			jr nz, .startnxt 
586d cd 5f 1b			call next_page_prompt 
5870 cd 48 0b		        call clear_display 
5873 cd 6b 0b			call update_display		 
5876			 
5876				; move onto next startup line? 
5876			.startnxt: 
5876			 
5876 cd ae 0a			call delay250ms 
5879 e1				pop hl 
587a			 
587a 23				inc hl 
587b 23				inc hl 
587c			 
587c e5				push hl 
587d 5e				ld e, (hl) 
587e 23				inc hl 
587f 56				ld d, (hl) 
5880 e1				pop hl 
5881				; TODO replace 0 test 
5881			 
5881 eb				ex de, hl 
5882 cd 9e 0d			call ishlzero 
5885			;	ld a,e 
5885			;	add d 
5885			;	cp 0    ; any left to do? 
5885 eb				ex de, hl 
5886 c2 eb 57			jp nz, .start1 
5889 18 01			jr .startupend 
588b			 
588b e1			.startupend1: pop hl 
588c			.startupend: 
588c			 
588c cd 48 0b			call clear_display 
588f cd 6b 0b			call update_display 
5892 c9				ret 
5893			 
5893			 
5893			; stack over and underflow checks 
5893			 
5893			; init the words to detect the under/overflow 
5893			 
5893			chk_stk_init: 
5893				; a vague random number to check so we dont get any "lucky" hits 
5893 3e 2d			ld a, 45 
5895 6f				ld l, a 
5896 00				nop 
5897 3e 17			ld a, 23 
5899 67				ld h, a 
589a			 
589a 22 e9 e2			ld (chk_word), hl     ; the word we need to check against 
589d			 
589d			;	ld (chk_stund), hl	; stack points.... 
589d 22 00 ef			ld (chk_stovr), hl 
58a0 22 2d ea			ld (chk_ret_und), hl 
58a3 22 eb e9			ld (chk_ret_ovr), hl 
58a6 22 69 e9			ld (chk_loop_ovr), hl 
58a9 22 67 e8			ld (chk_data_ovr), hl 
58ac c9				ret 
58ad				 
58ad			check_stacks: 
58ad				; check all stack words 
58ad			 
58ad e5				push hl 
58ae d5				push de 
58af			 
58af			;	ld de,(chk_word) 
58af			;	ld hl, (chk_stund)	; stack points.... 
58af			;	if DEBUG_STK_FAULT 
58af			;		DMARK "FAa" 
58af			;		CALLMONITOR 
58af			;	endif 
58af			;	call cmp16 
58af			;	jp z, .chk_faulta 
58af			; 
58af			;	ld de, sfaultsu 
58af			;	jp .chk_fault 
58af			 
58af 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
58b2 ed 5b e9 e2		ld de,(chk_word) 
58b6				if DEBUG_STK_FAULT 
58b6					DMARK "FAb" 
58b6					CALLMONITOR 
58b6				endif 
58b6 cd 93 0d			call cmp16 
58b9 28 06			jr z, .chk_fault1 
58bb 11 5c 59			ld de, sfaultso 
58be c3 10 59			jp .chk_fault 
58c1			.chk_fault1:  
58c1 2a 2d ea			ld hl, (chk_ret_und) 
58c4 ed 5b e9 e2		ld de,(chk_word) 
58c8				if DEBUG_STK_FAULT 
58c8					DMARK "FAU" 
58c8					CALLMONITOR 
58c8				endif 
58c8 cd 93 0d			call cmp16 
58cb ca d4 58			jp z, .chk_fault2 
58ce 11 6c 59			ld de, sfaultru 
58d1 c3 10 59			jp .chk_fault 
58d4			.chk_fault2:  
58d4 2a eb e9			ld hl, (chk_ret_ovr) 
58d7 ed 5b e9 e2		ld de,(chk_word) 
58db				if DEBUG_STK_FAULT 
58db					DMARK "FA1" 
58db					CALLMONITOR 
58db				endif 
58db cd 93 0d			call cmp16 
58de ca e7 58			jp z, .chk_fault3 
58e1 11 7a 59			ld de, sfaultro 
58e4 c3 10 59			jp .chk_fault 
58e7			.chk_fault3:  
58e7 2a 69 e9			ld hl, (chk_loop_ovr) 
58ea ed 5b e9 e2		ld de,(chk_word) 
58ee				if DEBUG_STK_FAULT 
58ee					DMARK "FA2" 
58ee					CALLMONITOR 
58ee				endif 
58ee cd 93 0d			call cmp16 
58f1 ca fa 58			jp z, .chk_fault4 
58f4 11 94 59			ld de, sfaultlo 
58f7 c3 10 59			jp .chk_fault 
58fa			.chk_fault4:  
58fa 2a 67 e8			ld hl, (chk_data_ovr) 
58fd ed 5b e9 e2		ld de,(chk_word) 
5901				if DEBUG_STK_FAULT 
5901					DMARK "FA3" 
5901					CALLMONITOR 
5901				endif 
5901 cd 93 0d			call cmp16 
5904 ca 0d 59			jp z, .chk_fault5 
5907 11 ae 59			ld de, sfaultdo 
590a c3 10 59			jp .chk_fault 
590d			 
590d			 
590d			.chk_fault5:  
590d d1				pop de 
590e e1				pop hl 
590f			 
590f c9				ret 
5910			 
5910 cd 48 0b		.chk_fault: 	call clear_display 
5913 3e 28				ld a, display_row_2 
5915 cd 5b 0b				call str_at_display 
5918 11 3e 59				   ld de, .stackfault 
591b 3e 00				ld a, display_row_1 
591d cd 5b 0b				call str_at_display 
5920 11 71 ee				    ld de, debug_mark 
5923 3e 11				ld a, display_row_1+17 
5925 cd 5b 0b				call str_at_display 
5928 cd 6b 0b				call update_display 
592b			 
592b				; prompt before entering montior for investigating issue 
592b			 
592b 3e 78			ld a, display_row_4 
592d 11 01 19			ld de, endprog 
5930			 
5930 cd 6b 0b			call update_display		 
5933			 
5933 cd 5f 1b			call next_page_prompt 
5936			 
5936 d1				pop de 
5937 e1				pop hl 
5938 cd 55 19				call monitor 
593b c3 4f 18				jp warmstart 
593e					;jp 0 
593e					;halt 
593e			 
593e			 
593e			 
593e .. 00		.stackfault: 	db "Stack fault:",0 
594b			 
594b .. 00		sfaultsu: 	db	"Stack under flow",0 
595c .. 00		sfaultso: 	db	"Stack over flow",0 
596c .. 00		sfaultru:	db "RTS underflow",0 
597a .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5994 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
59ae .. 00		sfaultdo:	db "DTS overflow", 0 
59bb			 
59bb			 
59bb			fault_dsp_under: 
59bb 11 cd 59			ld de, .dsp_under 
59be c3 7d 5a			jp .show_fault 
59c1			 
59c1			fault_rsp_under: 
59c1 11 db 59			ld de, .rsp_under 
59c4 c3 7d 5a			jp .show_fault 
59c7			fault_loop_under: 
59c7 11 e9 59			ld de, .loop_under 
59ca c3 7d 5a			jp .show_fault 
59cd			 
59cd .. 00		.dsp_under: db "DSP Underflow",0 
59db .. 00		.rsp_under: db "RSP Underflow",0 
59e9 .. 00		.loop_under: db "LOOP Underflow",0 
59f8			 
59f8			 
59f8 d5			type_faultn: 	push de 
59f9 e5					push hl 
59fa cd 48 0b				call clear_display 
59fd 11 24 5a				   ld de, .typefaultn 
5a00 3e 00				ld a, display_row_1 
5a02 cd 5b 0b				call str_at_display 
5a05 11 71 ee				    ld de, debug_mark 
5a08 3e 11				ld a, display_row_1+17 
5a0a cd 5b 0b				call str_at_display 
5a0d cd 6b 0b				call update_display 
5a10			 
5a10				; prompt before entering montior for investigating issue 
5a10			 
5a10 3e 78			ld a, display_row_4 
5a12 11 01 19			ld de, endprog 
5a15			 
5a15 cd 6b 0b			call update_display		 
5a18			 
5a18 cd 5f 1b			call next_page_prompt 
5a1b			 
5a1b e5					push hl 
5a1c d5					push de 
5a1d cd 55 19				call monitor 
5a20 c3 4f 18				jp warmstart 
5a23 76					halt 
5a24			 
5a24			 
5a24 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5a3b			 
5a3b d5			type_faults: 	push de 
5a3c e5					push hl 
5a3d cd 48 0b				call clear_display 
5a40 11 66 5a				   ld de, .typefaults 
5a43 3e 00				ld a, display_row_1 
5a45 cd 5b 0b				call str_at_display 
5a48 11 71 ee				    ld de, debug_mark 
5a4b 3e 11				ld a, display_row_1+17 
5a4d cd 5b 0b				call str_at_display 
5a50 cd 6b 0b				call update_display 
5a53			 
5a53				; prompt before entering montior for investigating issue 
5a53			 
5a53 3e 78			ld a, display_row_4 
5a55 11 01 19			ld de, endprog 
5a58			 
5a58 cd 6b 0b			call update_display		 
5a5b			 
5a5b cd 5f 1b			call next_page_prompt 
5a5e			 
5a5e e1					pop hl 
5a5f d1					pop de 
5a60 cd 55 19				call monitor 
5a63 c3 4f 18				jp warmstart 
5a66			 
5a66			 
5a66 .. 00		.typefaults: db "STR Type Expected TOS!",0 
5a7d			 
5a7d			.show_fault: 	 
5a7d d5					push de 
5a7e cd 48 0b				call clear_display 
5a81 d1					pop de 
5a82 3e 00				ld a, display_row_1 
5a84 cd 5b 0b				call str_at_display 
5a87 11 71 ee				    ld de, debug_mark 
5a8a 3e 11				ld a, display_row_1+17 
5a8c cd 5b 0b				call str_at_display 
5a8f cd 6b 0b				call update_display 
5a92			 
5a92				; prompt before entering montior for investigating issue 
5a92			 
5a92 3e 78			ld a, display_row_4 
5a94 11 01 19			ld de, endprog 
5a97			 
5a97 cd 6b 0b			call update_display		 
5a9a			 
5a9a cd 5f 1b			call next_page_prompt 
5a9d			 
5a9d e1					pop hl 
5a9e d1					pop de 
5a9f cd 55 19				call monitor 
5aa2			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5aa2			; TODO Make optional fault restart to cli or warm boot? 
5aa2					;jp warmstart 
5aa2 c3 a7 18				jp cli 
5aa5 76					halt 
5aa6			 
5aa6			; handle the auto run of code from files in storage 
5aa6			 
5aa6			 
5aa6			if STORAGE_SE 
5aa6			 
5aa6			sprompt3: db "Loading from start-up file?:",0 
5aa6			sprompt4: db "(Y=Any key/N=No)",0 
5aa6			 
5aa6			 
5aa6			forth_autoload: 
5aa6			 
5aa6				; load block 0 of store 1 
5aa6				 
5aa6				ld a, $fe      ; bit 0 clear 
5aa6				ld (spi_device), a 
5aa6			 
5aa6				call storage_get_block_0 
5aa6			 
5aa6				ld a, (store_page+STORE_0_AUTOFILE) 
5aa6			 
5aa6				cp 0 
5aa6				ret z     ; auto start not enabled 
5aa6			 
5aa6				call clear_display 
5aa6			 
5aa6				; set bank 
5aa6			 
5aa6					ld a, (store_page+STORE_0_BANKRUN) 
5aa6					ld (spi_device), a 
5aa6			 
5aa6				; get file id to load from and get the file name to display 
5aa6			 
5aa6					ld a, (store_page+STORE_0_FILERUN) 
5aa6			 
5aa6					ld l, 0 
5aa6					ld h, a 
5aa6					ld de, store_page 
5aa6			 
5aa6					if DEBUG_FORTH_WORDS 
5aa6						DMARK "ASp" 
5aa6						CALLMONITOR 
5aa6					endif 
5aa6					call storage_read 
5aa6			 
5aa6					if DEBUG_FORTH_WORDS 
5aa6						DMARK "ASr" 
5aa6						CALLMONITOR 
5aa6					endif 
5aa6			 
5aa6					call ishlzero 
5aa6					ret z             ; file not found 
5aa6			 
5aa6					ld a, display_row_2 + 10 
5aa6					ld de, store_page+3 
5aa6					call str_at_display 
5aa6				 
5aa6			; 
5aa6			 
5aa6				ld a, display_row_1+5 
5aa6				ld de, sprompt3 
5aa6				call str_at_display 
5aa6				ld a, display_row_3+15 
5aa6				ld de, sprompt4 
5aa6				call str_at_display 
5aa6			 
5aa6				call update_display 
5aa6			 
5aa6				call cin_wait 
5aa6				cp 'n' 
5aa6				ret z 
5aa6				cp 'N' 
5aa6				ret z 
5aa6			 
5aa6				call delay1s 
5aa6			 
5aa6				ld a, (store_page+2) 
5aa6				ld (store_openmaxext), a    ; save count of ext 
5aa6				ld a, 1  
5aa6				ld (store_openext), a    ; save count of ext 
5aa6			 
5aa6			.autof:  
5aa6				ld l , a 
5aa6				 
5aa6				ld a, (store_page) 
5aa6				ld h, a	 
5aa6				ld de, store_page 
5aa6					if DEBUG_FORTH_WORDS 
5aa6						DMARK "ASl" 
5aa6						CALLMONITOR 
5aa6					endif 
5aa6					call storage_read 
5aa6				call ishlzero 
5aa6				ret z 
5aa6			;	jr z, .autoend 
5aa6			 
5aa6					if DEBUG_FORTH_WORDS 
5aa6						DMARK "ASc" 
5aa6						CALLMONITOR 
5aa6					endif 
5aa6				ld de, store_page+2 
5aa6				ld a, display_row_4 
5aa6				call str_at_display 
5aa6			 
5aa6				call update_display 
5aa6				call delay250ms 
5aa6			 
5aa6			 
5aa6			 
5aa6				ld hl, store_page+2 
5aa6				call forthparse 
5aa6				call forthexec 
5aa6				call forthexec_cleanup 
5aa6			 
5aa6				 
5aa6				ld a, (store_openext) 
5aa6				inc a 
5aa6				ld (store_openext), a    ; save count of ext 
5aa6			 
5aa6				jr .autof 
5aa6			;.autofdone: 
5aa6			; 
5aa6			;		if DEBUG_FORTH_WORDS 
5aa6			;			DMARK "ASx" 
5aa6			;			CALLMONITOR 
5aa6			;		endif 
5aa6			;;	call clear_display 
5aa6			;	ret 
5aa6			 
5aa6			 
5aa6			 
5aa6			endif 
5aa6			 
5aa6			 
5aa6			; eof 
# End of file forth_kernel.asm
5aa6			;include "nascombasic.asm" 
5aa6			 
5aa6			 
5aa6			; find out where the code ends if loaded into RAM (for SC114) 
5aa6			;endofcode:  
5aa6			;	nop 
5aa6			 
5aa6			 
5aa6			; eof 
5aa6			 
# End of file main.asm
5aa6			;include "firmware_lcd_4x40.asm" 
5aa6			;;include "firmware_lcd_4x20.asm" 
5aa6			include "firmware_cpm_display.asm" 
5aa6			 
5aa6			; Serial display interface for SC114 
5aa6			 
5aa6			 
5aa6			display_row_1: equ 0 
5aa6			display_row_2: equ display_row_1+display_cols 
5aa6			display_row_3: equ display_row_2 + display_cols 
5aa6			display_row_4: equ display_row_3 + display_cols 
5aa6			 
5aa6			kLCDWidth:  EQU display_cols             ;Width in characters 
5aa6			kLCD_Line1: EQU 0x00  
5aa6			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5aa6			; E1 
5aa6			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5aa6			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5aa6			 
5aa6			lcd_init: 
5aa6				; no init as handled by the SCM bios 
5aa6 c9				ret 
5aa7			 
5aa7			 
5aa7			; low level functions for direct screen writes 
5aa7			 
5aa7			; output char at pos? 
5aa7			fLCD_Str: 
5aa7			        ;out (SC114_SIO_1_OUT),a 
5aa7 c5				push bc 
5aa8 d5				push de 
5aa9 5f				ld e, a 
5aaa			; TODO Replace with CP/M BIOS call 
5aaa 0e 02			ld c, $02 
5aac cd 05 00			call 5 
5aaf d1				pop de 
5ab0 c1				pop bc 
5ab1 c9				ret 
5ab2			 
5ab2			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5ab2			fLCD_Pos: 
5ab2				; use ASCII escape to position 
5ab2			        ;out (SC114_SIO_1_OUT),a 
5ab2 c5				push bc 
5ab3 d5				push de 
5ab4 5f				ld e, a 
5ab5 0e 02			ld c, $02 
5ab7			; TODO Replace with CP/M BIOS call 
5ab7 cd 05 00			call 5 
5aba d1				pop de 
5abb c1				pop bc 
5abc			 
5abc c9				ret 
5abd			 
5abd			; output char at pos 
5abd			fLCD_Data: 
5abd			      ;  out (SC114_SIO_1_OUT),a 
5abd c5				push bc 
5abe d5				push de 
5abf 0e 02			ld c, $02 
5ac1 5f				ld e, a 
5ac2			; TODO Replace with CP/M BIOS call 
5ac2 cd 05 00			call 5 
5ac5 d1				pop de 
5ac6 c1				pop bc 
5ac7			 
5ac7 c9				ret 
5ac8			 
5ac8			; ascii cls  
5ac8			 
5ac8 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5acc			 
5acc 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5ae3			;.clscpm: db 3, $3c,"$" 
5ae3			 
5ae3			; write the frame buffer given in hl to hardware  
5ae3			write_display: 
5ae3			 
5ae3			API: equ 0 
5ae3			 
5ae3			if API 
5ae3				push bc 
5ae3				ld b, 4 
5ae3			 
5ae3			        ld (display_write_tmp), hl 	  
5ae3			 
5ae3				; clear and home cursor 
5ae3			 
5ae3				ld c, 9 
5ae3				ld de, .cls 
5ae3			; TODO Replace with CP/M BIOS call 
5ae3				call 5 
5ae3			 
5ae3			 
5ae3			.writeln: 
5ae3			 
5ae3				ld de, (display_write_tmp) 
5ae3				ld c, 6 
5ae3			; TODO Replace with CP/M BIOS call 
5ae3				rst $30 
5ae3				ld c, 7 
5ae3				rst $30 
5ae3			 
5ae3				ld hl, (display_write_tmp) 
5ae3				ld de, display_cols 
5ae3				add hl,de 
5ae3				ld (display_write_tmp),hl 
5ae3			 
5ae3				djnz  .writeln 
5ae3			 
5ae3				pop bc 
5ae3			 
5ae3			 
5ae3				ret 
5ae3			endif 
5ae3 e5				push hl 
5ae4 c5				push bc 
5ae5 d5				push de 
5ae6			 
5ae6			;	ld c, 2 
5ae6			;	;ld de, .cls 
5ae6			;	ld a, 27 
5ae6			;	rst $30 
5ae6			;	ld c, 2 
5ae6			;	;ld de, .cls 
5ae6			;	ld a, '[' 
5ae6			;	rst $30 
5ae6			; 
5ae6			;	ld c, 2 
5ae6			;	;ld de, .cls 
5ae6			;	ld a, 'H' 
5ae6			;	rst $30 
5ae6			; 
5ae6			 
5ae6			 
5ae6			; lots of CR/LF 
5ae6			;	ld c, 9 
5ae6			;	ld de, .clscpm 
5ae6			;	call 5 
5ae6			 
5ae6			; xterm cls 
5ae6 0e 02			ld c, 2 
5ae8 1e 1b			ld e, 27 
5aea cd 05 00			call 5 
5aed			; cls causes too much flicker 
5aed			;	ld c, 2 
5aed			;	ld e, 'c' 
5aed			;	call 5 
5aed			 
5aed			; use xterm home instead 
5aed 0e 02			ld c, 2 
5aef 1e 5b			ld e, '[' 
5af1 cd 05 00			call 5 
5af4 0e 02			ld c, 2 
5af6 1e 48			ld e, 'H' 
5af8 cd 05 00			call 5 
5afb			LLL: equ 0 
5afb			 
5afb			if LLL 
5afb			 
5afb				ld c, 2 
5afb				;ld de, .cls 
5afb				ld e, 27 
5afb			; TODO Replace with CP/M BIOS call 
5afb				call 5 
5afb			 
5afb			 
5afb				ld c, 2 
5afb				;ld de, .cls 
5afb				ld e, '[' 
5afb			; TODO Replace with CP/M BIOS call 
5afb				call 5 
5afb				ld c, 2 
5afb				;ld de, .cls 
5afb				ld e, '2' 
5afb			; TODO Replace with CP/M BIOS call 
5afb				call 5 
5afb				ld c, 2 
5afb				;ld de, .cls 
5afb				ld e, 'J' 
5afb			; TODO Replace with CP/M BIOS call 
5afb				call 5 
5afb			 
5afb			endif 
5afb			 
5afb d1				pop de 
5afc c1				pop bc 
5afd e1				pop hl 
5afe			 
5afe			 
5afe 22 cf eb		        ld (display_write_tmp), hl 	  
5b01 3e 00			ld a, kLCD_Line1 
5b03			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5b03 06 28			ld b, display_cols 
5b05 ed 5b cf eb		ld de, (display_write_tmp) 
5b09 cd 8c 5b			call write_len_string 
5b0c				 
5b0c			 
5b0c e5			push hl 
5b0d d5			push de 
5b0e c5			push bc 
5b0f 0e 02			ld c, 2 
5b11 1e 0a			ld e, 10 
5b13 cd 05 00			call 5 
5b16 0e 02			ld c, 2 
5b18 1e 0d			ld e, 13 
5b1a cd 05 00			call 5 
5b1d			; TODO Replace with CP/M BIOS call 
5b1d				;rst $30 
5b1d c1			pop bc 
5b1e d1			pop de 
5b1f e1			pop hl 
5b20			 
5b20				 
5b20 2a cf eb			ld hl, (display_write_tmp) 
5b23 11 28 00			ld de, display_cols 
5b26 19				add hl,de 
5b27 22 cf eb			ld (display_write_tmp),hl 
5b2a			 
5b2a				 
5b2a 3e 28			ld a, kLCD_Line2 
5b2c			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5b2c 06 28			ld b, display_cols 
5b2e ed 5b cf eb		ld de, (display_write_tmp) 
5b32 cd 8c 5b			call write_len_string 
5b35				 
5b35 2a cf eb			ld hl, (display_write_tmp) 
5b38 11 28 00			ld de, display_cols 
5b3b 19				add hl,de 
5b3c 22 cf eb			ld (display_write_tmp),hl 
5b3f			 
5b3f e5			push hl 
5b40 d5			push de 
5b41 c5			push bc 
5b42 0e 07			ld c, 7 
5b44			; TODO Replace with CP/M BIOS call 
5b44				;rst $30 
5b44 0e 02			ld c, 2 
5b46 1e 0a			ld e, 10 
5b48 cd 05 00			call 5 
5b4b 0e 02			ld c, 2 
5b4d 1e 0d			ld e, 13 
5b4f cd 05 00			call 5 
5b52 c1			pop bc 
5b53 d1			pop de 
5b54 e1			pop hl 
5b55			 
5b55				 
5b55 3e 50			ld a, kLCD_Line3 
5b57			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5b57 06 28			ld b, display_cols 
5b59 ed 5b cf eb		ld de, (display_write_tmp) 
5b5d cd 8c 5b			call write_len_string 
5b60				 
5b60 2a cf eb			ld hl, (display_write_tmp) 
5b63 11 28 00			ld de, display_cols 
5b66 19				add hl,de 
5b67 22 cf eb			ld (display_write_tmp),hl 
5b6a			 
5b6a e5			push hl 
5b6b d5			push de 
5b6c c5			push bc 
5b6d 0e 07			ld c, 7 
5b6f			; TODO Replace with CP/M BIOS call 
5b6f				;rst $30 
5b6f 0e 02			ld c, 2 
5b71 1e 0a			ld e, 10 
5b73 cd 05 00			call 5 
5b76 0e 02			ld c, 2 
5b78 1e 0d			ld e, 13 
5b7a cd 05 00			call 5 
5b7d c1			pop bc 
5b7e d1			pop de 
5b7f e1			pop hl 
5b80			 
5b80				 
5b80 3e 78			ld a, kLCD_Line4 
5b82			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5b82 06 28			ld b, display_cols 
5b84 ed 5b cf eb		ld de, (display_write_tmp) 
5b88 cd 8c 5b			call write_len_string 
5b8b c9					ret 
5b8c			 
5b8c			 
5b8c				; write out a fixed length string given in b from de 
5b8c			 
5b8c 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5b8d cd bd 5a		            CALL fLCD_Data      ;Write character to display 
5b90 13				inc de 
5b91 10 f9			djnz write_len_string 
5b93 c9				ret 
5b94			 
5b94			 
5b94			; eof 
# End of file firmware_cpm_display.asm
5b94			;include "firmware_key_5x10.asm" 
5b94			;;include "firmware_key_4x10.asm" 
5b94			include "firmware_key_cpm.asm" 
5b94			; Serial keyboard interface for SC114 
5b94			 
5b94			 
5b94			key_init: 
5b94				; no init as handled by the SCM bios 
5b94 c9				ret 
5b95			 
5b95			 
5b95			cin_wait: 
5b95			;	ld a, 0 
5b95			;	ret 
5b95			 
5b95				;in a,(SC114_SIO_1_IN) 
5b95			        ; Use SCM API to get from whatever console device we are using 
5b95			 
5b95			; TODO Replace with CP/M BIOS call 
5b95 c5				push bc 
5b96 0e 01			ld c, $01 
5b98 cd 05 00			call 5 
5b9b c1				pop bc 
5b9c c9				ret 
5b9d			 
5b9d			cin: 
5b9d			 
5b9d			 
5b9d c5				push bc 
5b9e			 
5b9e				; any key waiting to process? 
5b9e			; TODO Replace with CP/M BIOS call 
5b9e 0e 06			ld c, $06 
5ba0 cd 05 00			call 5 
5ba3 28 0d			jr z, .cin_skip 
5ba5			 
5ba5				; yep, get it 
5ba5			 
5ba5 0e 01			ld c, $01 
5ba7			; TODO Replace with CP/M BIOS call 
5ba7 cd 05 00			call 5 
5baa			 
5baa fe 7f			cp $7f     ; back space 
5bac 20 02			jr nz, .skipbs 
5bae 3e 08			ld a, KEY_BS 
5bb0			.skipbs: 
5bb0			 
5bb0 c1				pop bc 
5bb1 c9				ret 
5bb2			.cin_skip: 
5bb2 3e 00			ld a, 0 
5bb4 c1				pop bc 
5bb5 c9				ret 
5bb6			 
5bb6			 
5bb6			 
5bb6			 
# End of file firmware_key_cpm.asm
5bb6			endofcode:  
5bb6			baseram:  
5bb6 00				nop 
5bb7			 
5bb7			heap_start: equ baseram+15  ; Starting address of heap 
5bb7			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5bb7			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5bb7			;VDU:  EQU     endofcode           ; BASIC Work space 
5bb7			; eof 
5bb7			 
# End of file os_mega_cpm.asm
5bb7
