# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 be 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd 18 0d				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd 18 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd 18 0d				call clear_display  
0037			  
0037			  
0037 cd 9a 74				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 31 77			call key_init  
003d cd fe 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ef 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd ac 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd 3b 0d			call update_display  
0049 cd 95 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 1d 0d			call fill_display  
0051 cd 3b 0d			call update_display  
0054 cd 95 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 1d 0d			call fill_display  
005c cd 3b 0d			call update_display  
005f cd 95 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 1d 0d			call fill_display  
0067 cd 3b 0d			call update_display  
006a cd 95 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 97 1b			ld de, prom_bootmsg  
0072 cd 2b 0d			call str_at_display  
0075 cd 3b 0d			call update_display  
0078			  
0078			  
0078 cd 95 0c			call delay1s  
007b cd 95 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 ac 1b			ld de, prom_bootmsg1  
0083 cd 2b 0d			call str_at_display  
0086 cd 3b 0d			call update_display  
0089 cd 95 0c			call delay1s  
008c cd 95 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			;  Perform SCLK wait pulse 
00a0			 
00a0			spi_clk: 
00a0 f5				push af 
00a1 3a 6b fa			ld a, (spi_clktime) 
00a4 fe 00			cp 0 
00a6 28 03			jr z, .scskip 
00a8 cd 7a 0c			call aDelayInMS 
00ab			.scskip: 
00ab f1				pop af 
00ac c9				ret 
00ad			 
00ad			 
00ad			 
00ad			; TODO store port id for spi device ie dev c 
00ad			; TODO store pin for SO 
00ad			; TODO store pin for SI 
00ad			; TODO store pin for SCLK 
00ad			 
00ad			; 
00ad			 
00ad			; ensure that spi bus is in a stable state with default pins  
00ad			 
00ad			se_stable_spi:   
00ad			 
00ad				 ; set DI high, CE high , SCLK low 
00ad				;ld a, SPI_DI | SPI_CE0 
00ad 3e 07			ld a, SPI_DI  
00af cd b9 01			call spi_ce_high 
00b2 d3 80			 out (storage_adata),a 
00b4 32 68 fa			ld (spi_portbyte),a 
00b7			 
00b7				if DEBUG_SPI 
00b7					push hl 
00b7					ld l, a 
00b7					DMARK "SPI" 
00b7					CALLMONITOR 
00b7					pop hl 
00b7				endif 
00b7 c9				ret 
00b8			 
00b8			; byte to send in a 
00b8			 
00b8			spi_send_byte: 
00b8				; save byte to send for bit mask shift out 
00b8 4f			        ld c,a 
00b9 3a 68 fa			ld a,(spi_portbyte) 
00bc				  
00bc				; clock out	each bit of the byte msb first 
00bc			 
00bc 06 08			ld b, 8 
00be			.ssb1: 
00be				; clear so bit  
00be cb bf			res SPI_DI, a 
00c0 cb 11			rl c 
00c2				; if bit 7 is set then carry is set 
00c2 30 02			jr nc, .ssb2 
00c4 cb ff			set SPI_DI,a 
00c6			.ssb2:  ; output bit to ensure it is stable 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce cd a0 00			call spi_clk 
00d1				; then low 
00d1 cb af			res SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6 cd a0 00			call spi_clk 
00d9 10 e3			djnz .ssb1 
00db			 
00db 32 68 fa			ld (spi_portbyte),a 
00de c9				ret 
00df			 
00df			; TODO low level get byte into A on spi 
00df			 
00df			spi_read_byte:  
00df			 
00df				; save byte to send for bit mask shift out 
00df 0e 00		    ld c,0 
00e1 3a 68 fa			ld a,(spi_portbyte) 
00e4				  
00e4				; clock out	each bit of the byte msb first 
00e4			 
00e4			 
00e4				; clock bit high 
00e4 cb ef			set SPI_SCLK,a 
00e6 d3 80			out (storage_adata),a 
00e8 00				nop 
00e9 cd a0 00			call spi_clk 
00ec			 
00ec			    ; read DO  
00ec			 
00ec cb f9		    set 7,c 
00ee db 80			in a,(storage_adata) 
00f0 cb 77		    bit SPI_DO,a 
00f2 20 02		    jr nz, .b7 
00f4 cb b9		    res 7,c 
00f6			.b7: 
00f6				; then low 
00f6 cb af			res SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb cd a0 00			call spi_clk 
00fe			     
00fe			 
00fe				; clock bit high 
00fe cb ef			set SPI_SCLK,a 
0100 d3 80			out (storage_adata),a 
0102 00				nop 
0103 cd a0 00			call spi_clk 
0106			 
0106			    ; read DO  
0106			 
0106 cb f1		    set 6,c 
0108 db 80			in a,(storage_adata) 
010a cb 77		    bit SPI_DO,a 
010c 20 02		    jr nz, .b6 
010e cb b1		    res 6,c 
0110			.b6: 
0110				; then low 
0110 cb af			res SPI_SCLK,a 
0112 d3 80			out (storage_adata),a 
0114 00				nop 
0115 cd a0 00			call spi_clk 
0118			 
0118				; clock bit high 
0118 cb ef			set SPI_SCLK,a 
011a d3 80			out (storage_adata),a 
011c 00				nop 
011d cd a0 00			call spi_clk 
0120			 
0120			 
0120			    ; read DO  
0120			 
0120 cb e9		    set 5,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b5 
0128 cb a9		    res 5,c 
012a			.b5: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f cd a0 00			call spi_clk 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137 cd a0 00			call spi_clk 
013a			 
013a			    ; read DO  
013a			 
013a cb e1		    set 4,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b4 
0142 cb a1		    res 4,c 
0144			.b4: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149 cd a0 00			call spi_clk 
014c				; clock bit high 
014c cb ef			set SPI_SCLK,a 
014e d3 80			out (storage_adata),a 
0150 00				nop 
0151 cd a0 00			call spi_clk 
0154			 
0154			    ; read DO  
0154			 
0154 cb d9		    set 3,c 
0156 db 80			in a,(storage_adata) 
0158 cb 77		    bit SPI_DO,a 
015a 20 02		    jr nz, .b3 
015c cb 99		    res 3,c 
015e			.b3: 
015e				; then low 
015e cb af			res SPI_SCLK,a 
0160 d3 80			out (storage_adata),a 
0162 00				nop 
0163 cd a0 00			call spi_clk 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b cd a0 00			call spi_clk 
016e			 
016e			    ; read DO  
016e			 
016e cb d1		    set 2,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b2 
0176 cb 91		    res 2,c 
0178			.b2: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d cd a0 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184 00				nop 
0185 cd a0 00			call spi_clk 
0188			 
0188			    ; read DO  
0188			 
0188 cb c9		    set 1,c 
018a db 80			in a,(storage_adata) 
018c cb 77		    bit SPI_DO,a 
018e 20 02		    jr nz, .b1 
0190 cb 89		    res 1,c 
0192			.b1: 
0192				; then low 
0192 cb af			res SPI_SCLK,a 
0194 d3 80			out (storage_adata),a 
0196 00				nop 
0197 cd a0 00			call spi_clk 
019a				; clock bit high 
019a cb ef			set SPI_SCLK,a 
019c d3 80			out (storage_adata),a 
019e 00				nop 
019f cd a0 00			call spi_clk 
01a2			 
01a2			    ; read DO  
01a2			 
01a2 cb c1		    set 0,c 
01a4 db 80			in a,(storage_adata) 
01a6 cb 77		    bit SPI_DO,a 
01a8 20 02		    jr nz, .b0 
01aa cb 81		    res 0,c 
01ac			.b0: 
01ac				; then low 
01ac cb af			res SPI_SCLK,a 
01ae d3 80			out (storage_adata),a 
01b0 00				nop 
01b1 cd a0 00			call spi_clk 
01b4			 
01b4			 
01b4 32 68 fa			ld (spi_portbyte),a 
01b7			 
01b7			    ; return byte 
01b7 79			    ld a,c 
01b8			 
01b8			 
01b8 c9				ret 
01b9			 
01b9			 
01b9			 
01b9			spi_ce_high: 
01b9			 
01b9				if DEBUG_SPI_HARD_CE0 
01b9			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b9					ret 
01b9			 
01b9				endif 
01b9			 
01b9			 
01b9 f5				push af 
01ba			 
01ba				; send direct ce to port b 
01ba 3e ff			ld a, 255 
01bc d3 81			out (storage_bdata), a 
01be			 
01be f1				pop af 
01bf			 
01bf				; for port a that shares with spi lines AND the mask 
01bf			  
01bf				if DEBUG_SPI 
01bf					push hl 
01bf					ld h, a 
01bf				endif 
01bf			;	ld c, SPI_CE_HIGH 
01bf			;	and c 
01bf cb c7			set SPI_CE0, a 
01c1 cb cf			set SPI_CE1, a 
01c3 cb d7			set SPI_CE2, a 
01c5 cb df			set SPI_CE3, a 
01c7 cb e7			set SPI_CE4, a 
01c9			 
01c9				if DEBUG_SPI 
01c9					ld l, a 
01c9					DMARK "CEh" 
01c9					CALLMONITOR 
01c9					pop hl 
01c9				endif 
01c9 c9				ret 
01ca			 
01ca			 
01ca			spi_ce_low: 
01ca			 
01ca				if DEBUG_SPI_HARD_CE0 
01ca			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ca					ret 
01ca			 
01ca				endif 
01ca			 
01ca c5				push bc 
01cb f5				push af 
01cc			 
01cc				; send direct ce to port b 
01cc 3a 6a fa			ld a, (spi_cartdev) 
01cf d3 81			out (storage_bdata), a 
01d1			 
01d1			 
01d1			 
01d1				; for port a that shares with spi lines AND the mask 
01d1			 
01d1 3a 67 fa			ld a, (spi_device)  
01d4 4f				ld c, a 
01d5			 
01d5 f1				pop af 
01d6			 
01d6				; detect CEx 
01d6			 
01d6				if DEBUG_SPI 
01d6					push hl 
01d6					ld h, a 
01d6				endif 
01d6			 
01d6 cb 41			bit SPI_CE0, c 
01d8 20 04			jr nz, .cel1 
01da cb 87			res SPI_CE0, a 
01dc 18 1e			jr .celn 
01de			.cel1: 
01de cb 49			bit SPI_CE1, c 
01e0 20 04			jr nz, .cel2 
01e2 cb 8f			res SPI_CE1, a 
01e4 18 16			jr .celn 
01e6			.cel2: 
01e6 cb 51			bit SPI_CE2, c 
01e8 20 04			jr nz, .cel3 
01ea cb 97			res SPI_CE2, a 
01ec 18 0e			jr .celn 
01ee			.cel3: 
01ee cb 59			bit SPI_CE3, c 
01f0 20 04			jr nz, .cel4 
01f2 cb 9f			res SPI_CE3, a 
01f4 18 06			jr .celn 
01f6			.cel4: 
01f6 cb 61			bit SPI_CE4, c 
01f8 20 02			jr nz, .celn 
01fa cb a7			res SPI_CE4, a 
01fc			.celn: 
01fc			 
01fc			 
01fc			 
01fc			;	add c 
01fc			 
01fc				if DEBUG_SPI 
01fc					ld l, a 
01fc					DMARK "CEl" 
01fc					CALLMONITOR 
01fc					pop hl 
01fc				endif 
01fc c1				pop bc 
01fd c9				ret 
01fe			 
01fe			 
01fe			 
01fe			; eof 
01fe			 
01fe			 
01fe			 
01fe			 
01fe			 
# End of file firmware_spi.asm
01fe				include "firmware_seeprom.asm"  
01fe			; 
01fe			; persisent storage interface via microchip serial eeprom 
01fe			 
01fe			; port a pio 2 
01fe			; pa 7 - si 
01fe			; pa 6 - sclk  
01fe			; pa 5 - so 
01fe			; pa 4 - cs 
01fe			; pa 3 - cs 
01fe			; pa 2 - cs 
01fe			; pa 1 - cs 
01fe			; pa 0 - cs 
01fe			; 
01fe			; TODO get block 
01fe			; TODO save block 
01fe			; TODO load file 
01fe			; TODO save file 
01fe			; TODO get dir  
01fe			 
01fe			;  
01fe			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fe			storage_actl: equ Device_C+2     ; device c port a 
01fe			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fe			storage_bctl: equ Device_C+3     ; device c port b 
01fe			 
01fe			 
01fe			; TODO move these to hardware driver file 
01fe			 
01fe			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fe			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fe			; storage bank file system format 
01fe			; 
01fe			; first page of bank: 
01fe			; 	addr 0 - status check 
01fe			;       addr 1 - write protect flag 
01fe			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fe			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fe			;         TODO see if scanning whole of for available next file id is fast enough 
01fe			;	addr 4 > zero term string of bank label 
01fe			; 
01fe			;        
01fe			;  
01fe			; first page of any file: 
01fe			;      byte 0 - file id  
01fe			;      byte 1-17 - fixed file name  
01fe			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fe			; 
01fe			; other pages of any file: 
01fe			;      byte 0 - file id 
01fe			;      byte 1> - file data 
01fe			; 
01fe			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fe			;  
01fe			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fe			 
01fe			 
01fe			;storage_so_bit: 5 
01fe			;storage_si_bit: 7 
01fe			;storage_sclk_bit: 6 
01fe			  
01fe			 
01fe			; init storage pio 
01fe			 
01fe			storage_init: 
01fe			 
01fe			 
01fe					; set default SPI clk pulse time as disabled 
01fe			 
01fe 3e 00				ld a, 0 
0200 32 6b fa				ld (spi_clktime), a 
0203			 
0203					; init hardware 
0203			 
0203 3e cf		            LD   A, 11001111b 
0205 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0207 3e 00		            LD   A, 00000000b 
0209 cb f7			set SPI_DO,a 
020b			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
020b d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020d			 
020d 3e cf		            LD   A, 11001111b 
020f d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0211 3e 00		            LD   A, 00000000b 
0213 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0215			 
0215				; set all external spi devices off  
0215 3e ff			ld a, 255 
0217 32 67 fa			ld (spi_device), a 
021a 32 6a fa			ld (spi_cartdev), a 
021d			 
021d					; ensure the spi bus is in a default stable state 
021d cd ad 00				call se_stable_spi 
0220			 
0220			; TODO scan spi bus and gather which storage banks are present 
0220			 
0220			; populate store_bank_active  
0220			; for each ce line activate and attempt to write first byte of bank and read back 
0220			; if zero is returned then bank is empty 
0220			;   
0220			; 
0220			 
0220					; init file extent cache to save on slow reads 
0220			 
0220			;	ld hl, store_filecache 
0220			;	ld de, 0 
0220			;	ld hl,(de)	 
0220			 
0220			 
0220 c9			    ret 
0221			 
0221			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0221			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0221			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0221			 
0221			; INSTRUCTION SET 
0221			; READ 0000 0011 Read data from memory array beginning at selected address 
0221			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0221			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0221			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0221			; RDSR 0000 0101 Read STATUS register 
0221			; WRSR 0000 0001 Write STATUS register 
0221			; PE 0100 0010 Page Erase – erase one page in memory array 
0221			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0221			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0221			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0221			 
0221			; TODO send byte steam for page without setting the address for every single byte 
0221			; TODO read byte  
0221			 
0221			; byte in a 
0221			; address in hl  
0221			se_writebyte: 
0221			        
0221			    ;   ld c, a 
0221 f5			        push af 
0222 e5			        push hl 
0223			 
0223			    ; initi write mode 
0223			    ; 
0223			    ;CS low 
0223			 
0223 3a 68 fa		       ld a,(spi_portbyte) 
0226 cd ca 01			call spi_ce_low 
0229			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0229 d3 80		       out (storage_adata),a 
022b 32 68 fa		       ld (spi_portbyte), a 
022e			 
022e			    ;clock out wren instruction 
022e			 
022e 3e 06		    ld a, store_wren_ins 
0230 cd b8 00		    call spi_send_byte  
0233			 
0233			    ;cs high to enable write latch 
0233			 
0233 3a 68 fa		       ld a,(spi_portbyte) 
0236 cd b9 01			call spi_ce_high 
0239			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 68 fa		       ld (spi_portbyte), a 
023e			 
023e 00				nop 
023f			    ; 
023f			    ; intial write data 
023f			    ; 
023f			    ; cs low 
023f			     
023f 3a 68 fa		       ld a,(spi_portbyte) 
0242 cd ca 01			call spi_ce_low 
0245			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0245 d3 80		       out (storage_adata),a 
0247 32 68 fa		       ld (spi_portbyte), a 
024a			 
024a			    ; clock out write instruction 
024a			     
024a 3e 02		    ld a, store_write_ins  
024c cd b8 00		    call spi_send_byte  
024f			 
024f			    ; clock out address (depending on address size) 
024f			     
024f e1			    pop hl 
0250 7c			    ld a,h    ; address out msb first 
0251 cd b8 00		    call spi_send_byte  
0254 7d			    ld a,l 
0255 cd b8 00		    call spi_send_byte  
0258			 
0258			    ; clock out byte(s) for page 
0258			 
0258 f1			    pop af 
0259 cd b8 00		    call spi_send_byte  
025c			 
025c			    ; end write with ce high 
025c 3a 68 fa		       ld a,(spi_portbyte) 
025f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025f cd b9 01			call spi_ce_high 
0262 d3 80		       out (storage_adata),a 
0264 32 68 fa		       ld (spi_portbyte), a 
0267			 
0267				; pause for internal write cycle 
0267 3e 0a			ld a, 10 
0269 cd 7a 0c			call aDelayInMS 
026c c9			    ret 
026d			 
026d			; buffer to write in de 
026d			; address in hl  
026d			se_writepage: 
026d			        
026d			    ;   ld c, a 
026d d5				push de 
026e e5			        push hl 
026f			 
026f			    ; initi write mode 
026f			    ; 
026f			    ;CS low 
026f			 
026f 3a 68 fa		       ld a,(spi_portbyte) 
0272 cd ca 01			call spi_ce_low 
0275			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0275 d3 80		       out (storage_adata),a 
0277 32 68 fa		       ld (spi_portbyte), a 
027a			 
027a			    ;clock out wren instruction 
027a			 
027a 3e 06		    ld a, store_wren_ins 
027c cd b8 00		    call spi_send_byte  
027f			 
027f			    ;cs high to enable write latch 
027f			 
027f 3a 68 fa		       ld a,(spi_portbyte) 
0282 cd b9 01			call spi_ce_high 
0285			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 68 fa		       ld (spi_portbyte), a 
028a			 
028a 00				nop 
028b			    ; 
028b			    ; intial write data 
028b			    ; 
028b			    ; cs low 
028b			     
028b 3a 68 fa		       ld a,(spi_portbyte) 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e cd ca 01			call spi_ce_low 
0291 d3 80		       out (storage_adata),a 
0293 32 68 fa		       ld (spi_portbyte), a 
0296			 
0296			    ; clock out write instruction 
0296			     
0296 3e 02		    ld a, store_write_ins  
0298 cd b8 00		    call spi_send_byte  
029b			 
029b			    ; clock out address (depending on address size) 
029b			     
029b e1			    pop hl 
029c 7c			    ld a,h    ; address out msb first 
029d cd b8 00		    call spi_send_byte  
02a0 7d			    ld a,l 
02a1 cd b8 00		    call spi_send_byte  
02a4			 
02a4			    ; clock out byte(s) for page 
02a4			 
02a4 e1				pop hl 
02a5 06 40			ld b, STORE_BLOCK_PHY 
02a7			.bytewrite: 
02a7			 
02a7 7e				ld a,(hl) 
02a8 e5			    push hl 
02a9 c5				push bc 
02aa cd b8 00		    call spi_send_byte  
02ad c1				pop bc 
02ae e1				pop hl 
02af			 
02af			    ; end write with ce high 
02af 3a 68 fa		       ld a,(spi_portbyte) 
02b2 cd b9 01			call spi_ce_high 
02b5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b5 d3 80		       out (storage_adata),a 
02b7 32 68 fa		       ld (spi_portbyte), a 
02ba			 
02ba 23				inc hl 
02bb 10 ea			djnz .bytewrite 
02bd			 
02bd				; pause for internal write cycle 
02bd 3e 64			ld a, 100 
02bf cd 7a 0c			call aDelayInMS 
02c2 c9			    ret 
02c3			; returns byte in a 
02c3			; address in hl  
02c3			se_readbyte: 
02c3 d5				push de 
02c4 c5				push bc 
02c5			 
02c5			    ;   ld c, a 
02c5 e5			        push hl 
02c6			 
02c6			    ; initi write mode 
02c6			    ; 
02c6			    ;CS low 
02c6			 
02c6 3a 68 fa		       ld a,(spi_portbyte) 
02c9 cd ca 01			call spi_ce_low 
02cc			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cc d3 80		       out (storage_adata),a 
02ce 32 68 fa		       ld (spi_portbyte), a 
02d1			 
02d1			    ;clock out wren instruction 
02d1			 
02d1 3e 03		    ld a, store_read_ins 
02d3 cd b8 00		    call spi_send_byte  
02d6			 
02d6			 
02d6			    ; clock out address (depending on address size) 
02d6			     
02d6 e1			    pop hl 
02d7 7c			    ld a,h    ; address out msb first 
02d8 cd b8 00		    call spi_send_byte  
02db 7d			    ld a,l 
02dc cd b8 00		    call spi_send_byte  
02df			 
02df			    ; clock in byte(s) for page 
02df			 
02df cd df 00		    call spi_read_byte  
02e2 f5				push af 
02e3			 
02e3			    ; end write with ce high 
02e3 3a 68 fa		       ld a,(spi_portbyte) 
02e6			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e6 cd b9 01			call spi_ce_high 
02e9 d3 80		       out (storage_adata),a 
02eb 32 68 fa		       ld (spi_portbyte), a 
02ee			 
02ee f1				pop af 
02ef			 
02ef c1				pop bc 
02f0 d1				pop de 
02f1			 
02f1 c9			    ret 
02f2			 
02f2			if DEBUG_STORESE 
02f2			 
02f2			storageput:  
02f2			 
02f2			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02f2			 
02f2 21 ca f1			ld hl,scratch+2 
02f5 cd 03 13			call get_word_hl 
02f8			 
02f8				; stuff it here for the moment as it will be overwritten later anyway 
02f8			 
02f8 22 eb f4			ld (os_cur_ptr),hl	 
02fb			 
02fb			 
02fb			; get pointer to start of string 
02fb			 
02fb 21 cf f1			ld hl, scratch+7 
02fe			 
02fe			; loop writing char of string to eeprom 
02fe			 
02fe 7e			.writestr:	ld a,(hl) 
02ff fe 00				cp 0 
0301 28 12				jr z, .wsdone		; done writing 
0303 e5					push hl 
0304 2a eb f4				ld hl,(os_cur_ptr) 
0307 cd 21 02				call se_writebyte 
030a			 
030a 2a eb f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030d 23					inc hl 
030e 22 eb f4				ld (os_cur_ptr),hl 
0311			 
0311					; restore string pointer and get next char 
0311			 
0311 e1					pop hl 
0312 23					inc hl 
0313 18 e9				jr .writestr 
0315			 
0315			 
0315			 
0315			.wsdone: 
0315			 
0315			 
0315			; when done load first page into a buffer  
0315			 
0315 21 00 80				ld hl,08000h		; start in ram 
0318 22 eb f4				ld (os_cur_ptr),hl 
031b 21 00 00				ld hl, 0		 ; start of page 
031e 22 f0 f1				ld (scratch+40),hl	; hang on to it 
0321			 
0321 06 80				ld b, 128		; actually get more then one page 
0323 c5			.wsload:	push bc 
0324 2a f0 f1				ld hl,(scratch+40) 
0327 e5					push hl 
0328 cd c3 02				call se_readbyte 
032b			 
032b					; a now as the byte 
032b			 
032b 2a eb f4				ld hl,(os_cur_ptr) 
032e 77					ld (hl),a 
032f					; inc next buffer area 
032f 23					inc hl 
0330 22 eb f4				ld (os_cur_ptr),hl 
0333			 
0333					; get eeprom position, inc and save for next round 
0333 e1					pop hl		 
0334 23					inc hl 
0335 22 f0 f1				ld (scratch+40),hl 
0338 c1					pop bc 
0339 10 e8				djnz .wsload 
033b			 
033b			; set 'd' pointer to start of buffer 
033b			 
033b 21 00 80				ld hl,08000h 
033e 22 eb f4				ld (os_cur_ptr),hl 
0341			 
0341			 
0341 c9			ret 
0342			 
0342			 
0342 c9			storageread: ret 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			endif 
0343			 
0343			 
0343			 
# End of file firmware_seeprom.asm
0343			else  
0343			   ; create some stubs for the labels  
0343			se_readbyte: ret  
0343			se_writebyte: ret  
0343			storage_init: ret  
0343			  
0343			endif  
0343			  
0343			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0343			;include "firmware_cf.asm"  
0343			  
0343			; load up high level storage hardward abstractions  
0343			include "firmware_storage.asm"  
0343			 
0343			; persisent storage hardware abstraction layer  
0343			 
0343			 
0343			 
0343			; Block 0 on storage is a config state 
0343			 
0343			 
0343			 
0343			; TODO add read phy block and write phy block functions 
0343			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0343			 
0343			; Abstraction layer  
0343			 
0343			; Logocial block size is same size as physical size - using tape concept 
0343			 
0343			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0343			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0343			 
0343			 
0343			 
0343			; Filesystem layout (Logical layout) 
0343			; 
0343			; Block 0 - Bank config  
0343			; 
0343			;      Byte - 0 file id counter 
0343			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0343			;      Byte - 3-20 zero terminated bank label 
0343			; 
0343			; Block 1 > File storage 
0343			; 
0343			;      Byte 0 file id    - block 0 file details 
0343			;      Byte 1 block id - block 0 is file  
0343			;            Byte 2-15 - File name 
0343			; 
0343			;       - to end of block data 
0343			; 
0343			 
0343			; Get ID for the file named in pointer held HL 
0343			; Returns ID in HL = 255 if no file found 
0343			 
0343			storage_getid: 
0343			 
0343 22 7a fa			ld (store_tmp1), hl 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SGI" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 6e fe			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 6f fe			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 70 fe			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SGI"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					CALLMONITOR 
035f cd c1 19			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362				; get block 0 and set counter for number of files to scan 
0362			 
0362 cd cd 04			call storage_get_block_0 
0365			 
0365 3a 81 fa			ld a, (store_page) 
0368 47				ld b, a 
0369			 
0369				; get extent 0 of each file id 
0369			 
0369				if DEBUG_STORESE 
0369					DMARK "SGc" 
0369 f5				push af  
036a 3a 7e 03			ld a, (.dmark)  
036d 32 6e fe			ld (debug_mark),a  
0370 3a 7f 03			ld a, (.dmark+1)  
0373 32 6f fe			ld (debug_mark+1),a  
0376 3a 80 03			ld a, (.dmark+2)  
0379 32 70 fe			ld (debug_mark+2),a  
037c 18 03			jr .pastdmark  
037e ..			.dmark: db "SGc"  
0381 f1			.pastdmark: pop af  
0382			endm  
# End of macro DMARK
0382					CALLMONITOR 
0382 cd c1 19			call break_point_state  
0385				endm  
# End of macro CALLMONITOR
0385				endif 
0385 60			.getloop:	ld h, b 
0386 2e 00				ld l, 0 
0388 c5					push bc 
0389			 
0389 11 81 fa				ld de, store_page 
038c				if DEBUG_STORESE 
038c					DMARK "SGr" 
038c f5				push af  
038d 3a a1 03			ld a, (.dmark)  
0390 32 6e fe			ld (debug_mark),a  
0393 3a a2 03			ld a, (.dmark+1)  
0396 32 6f fe			ld (debug_mark+1),a  
0399 3a a3 03			ld a, (.dmark+2)  
039c 32 70 fe			ld (debug_mark+2),a  
039f 18 03			jr .pastdmark  
03a1 ..			.dmark: db "SGr"  
03a4 f1			.pastdmark: pop af  
03a5			endm  
# End of macro DMARK
03a5					CALLMONITOR 
03a5 cd c1 19			call break_point_state  
03a8				endm  
# End of macro CALLMONITOR
03a8				endif 
03a8 cd 75 09				call storage_read 
03ab cd 75 0f				call ishlzero 
03ae 28 2d				jr z, .gap 
03b0					 
03b0					; have a file name read. Is it one we want. 
03b0			 
03b0 2a 7a fa				ld hl, (store_tmp1) 
03b3 11 84 fa				ld de, store_page+3   ; file name 
03b6			 
03b6				if DEBUG_STORESE 
03b6					DMARK "SGc" 
03b6 f5				push af  
03b7 3a cb 03			ld a, (.dmark)  
03ba 32 6e fe			ld (debug_mark),a  
03bd 3a cc 03			ld a, (.dmark+1)  
03c0 32 6f fe			ld (debug_mark+1),a  
03c3 3a cd 03			ld a, (.dmark+2)  
03c6 32 70 fe			ld (debug_mark+2),a  
03c9 18 03			jr .pastdmark  
03cb ..			.dmark: db "SGc"  
03ce f1			.pastdmark: pop af  
03cf			endm  
# End of macro DMARK
03cf					CALLMONITOR 
03cf cd c1 19			call break_point_state  
03d2				endm  
# End of macro CALLMONITOR
03d2				endif 
03d2 cd e2 13				call strcmp 
03d5 20 06				jr nz, .gap   ; not this one 
03d7			 
03d7 c1				        pop bc 
03d8			 
03d8 26 00				ld h, 0 
03da 68					ld l, b 
03db 18 22				jr .getdone 
03dd						 
03dd			 
03dd			 
03dd			 
03dd			.gap: 
03dd				if DEBUG_STORESE 
03dd					DMARK "SGg" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6e fe			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6f fe			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 70 fe			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SGg"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6					CALLMONITOR 
03f6 cd c1 19			call break_point_state  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 c1					pop bc 
03fa 10 89				djnz .getloop 
03fc 21 ff 00				ld hl, 255 
03ff			.getdone: 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGe" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 6e fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 6f fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 70 fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGe"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd c1 19			call break_point_state  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b			 
041b c9				ret 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			; Read Block 
041c			; ---------- 
041c			; 
041c			; With current bank 
041c			;  
041c			; Get block number to read 
041c			; Load physical blocks starting at start block into buffer 
041c			 
041c			; de points to buffer to use 
041c			; hl holds logical block number  
041c			 
041c			storage_read_block: 
041c			 
041c				; TODO bank selection 
041c			 
041c				; for each of the physical blocks read it into the buffer 
041c 06 40			ld b, STORE_BLOCK_PHY 
041e			 
041e				if DEBUG_STORESE 
041e d5					push de 
041f				endif 
041f				 
041f			.rl1:    
041f			 
041f				; read physical block at hl into de 
041f			        ; increment hl and de to next read position on exit 
041f			 
041f e5				push hl 
0420 d5				push de	 
0421 c5				push bc 
0422			;	if DEBUG_STORESE 
0422			;		push af 
0422			;		ld a, 'R' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 cd c3 02			call se_readbyte 
0425			;	if DEBUG_STORESE 
0425			;		ld a,(spi_portbyte) 
0425			;		ld l, a 
0425			;		push af 
0425			;		ld a, '1' 
0425			;		ld (debug_mark),a 
0425			;		pop af 
0425			;		CALLMONITOR 
0425			;	endif 
0425 c1				pop bc 
0426 d1				pop de 
0427 e1				pop hl 
0428 12				ld (de),a 
0429 23				inc hl 
042a 13				inc de 
042b			 
042b			;	if DEBUG_STORESE 
042b			;		push af 
042b			;		ld a, 'r' 
042b			;		ld (debug_mark),a 
042b			;		pop af 
042b			;		CALLMONITOR 
042b			;	endif 
042b			 
042b 10 f2			djnz .rl1 
042d			 
042d				if DEBUG_STORESE 
042d					DMARK "SRB" 
042d f5				push af  
042e 3a 42 04			ld a, (.dmark)  
0431 32 6e fe			ld (debug_mark),a  
0434 3a 43 04			ld a, (.dmark+1)  
0437 32 6f fe			ld (debug_mark+1),a  
043a 3a 44 04			ld a, (.dmark+2)  
043d 32 70 fe			ld (debug_mark+2),a  
0440 18 03			jr .pastdmark  
0442 ..			.dmark: db "SRB"  
0445 f1			.pastdmark: pop af  
0446			endm  
# End of macro DMARK
0446 d1					pop de 
0447			; 
0447			;		push af 
0447			;		ld a, 'R' 
0447			;		ld (debug_mark),a 
0447			;		pop af 
0447					CALLMONITOR 
0447 cd c1 19			call break_point_state  
044a				endm  
# End of macro CALLMONITOR
044a				endif 
044a c9				ret	 
044b				 
044b			 
044b			; File Size 
044b			; --------- 
044b			; 
044b			;   hl file id 
044b			; 
044b			;  returns in hl the number of blocks 
044b			 
044b			storage_file_size: 
044b 5d				ld e, l 
044c 16 00			ld d, 0 
044e 21 40 00			ld hl, STORE_BLOCK_PHY 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "SIZ" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 6e fe			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 6f fe			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 70 fe			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "SIZ"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd c1 19			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 4f 07			call storage_findnextid 
0470			 
0470 cd 75 0f			call ishlzero 
0473			;	ld a, l 
0473			;	add h 
0473			;	cp 0 
0473 c8				ret z			; block not found so EOF 
0474			 
0474 11 81 fa			ld de, store_page 
0477 cd 1c 04			call storage_read_block 
047a			 
047a 3a 83 fa			ld a, (store_page+2)	 ; get extent count 
047d 6f				ld l, a 
047e 26 00			ld h, 0 
0480 c9			 	ret 
0481			 
0481			 
0481			; Write Block 
0481			; ----------- 
0481			; 
0481			; With current bank 
0481			;  
0481			; Get block number to write 
0481			; Write physical blocks starting at start block from buffer 
0481			  
0481			storage_write_block: 
0481				; TODO bank selection 
0481			 
0481				; for each of the physical blocks read it into the buffer 
0481 06 40			ld b, STORE_BLOCK_PHY 
0483			 
0483				if DEBUG_STORESE 
0483					DMARK "SWB" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 6e fe			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 6f fe			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 70 fe			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "SWB"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c			 
049c					;push af 
049c					;ld a, 'W' 
049c					;ld (debug_mark),a 
049c					;pop af 
049c					CALLMONITOR 
049c cd c1 19			call break_point_state  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f			 
049f			; might not be working 
049f			;	call se_writepage 
049f			 
049f			;	ret 
049f			; 
049f			 
049f			 
049f			 
049f			.wl1:    
049f			 
049f				; read physical block at hl into de 
049f			        ; increment hl and de to next read position on exit 
049f			 
049f e5				push hl 
04a0 d5				push de	 
04a1 c5				push bc 
04a2 1a				ld a,(de) 
04a3				;if DEBUG_STORESE 
04a3			;		push af 
04a3			;		ld a, 'W' 
04a3			;		ld (debug_mark),a 
04a3			;		pop af 
04a3			;		CALLMONITOR 
04a3			;	endif 
04a3 cd 21 02			call se_writebyte 
04a6			;	call delay250ms 
04a6 00				nop 
04a7 00				nop 
04a8 00				nop 
04a9			;	if DEBUG_STORESE 
04a9			;		push af 
04a9			;		ld a, 'w' 
04a9			;		ld (debug_mark),a 
04a9			;		pop af 
04a9			;		CALLMONITOR 
04a9			;	endif 
04a9 c1				pop bc 
04aa d1				pop de 
04ab e1				pop hl 
04ac 23				inc hl 
04ad 13				inc de 
04ae			 
04ae			 
04ae 10 ef			djnz .wl1 
04b0			 
04b0				if DEBUG_STORESE 
04b0					DMARK "SW2" 
04b0 f5				push af  
04b1 3a c5 04			ld a, (.dmark)  
04b4 32 6e fe			ld (debug_mark),a  
04b7 3a c6 04			ld a, (.dmark+1)  
04ba 32 6f fe			ld (debug_mark+1),a  
04bd 3a c7 04			ld a, (.dmark+2)  
04c0 32 70 fe			ld (debug_mark+2),a  
04c3 18 03			jr .pastdmark  
04c5 ..			.dmark: db "SW2"  
04c8 f1			.pastdmark: pop af  
04c9			endm  
# End of macro DMARK
04c9			 
04c9					;push af 
04c9					;ld a, 'W' 
04c9					;ld (debug_mark),a 
04c9					;pop af 
04c9					CALLMONITOR 
04c9 cd c1 19			call break_point_state  
04cc				endm  
# End of macro CALLMONITOR
04cc				endif 
04cc c9				ret	 
04cd			 
04cd			; Init bank 
04cd			; --------- 
04cd			; 
04cd			; With current bank 
04cd			; 
04cd			; Setup block 0 config 
04cd			;     Set 0 file id counter 
04cd			;     Set formatted byte pattern 
04cd			;     Zero out bank label 
04cd			;      
04cd			; For every logical block write 0-1 byte as null 
04cd			 
04cd			storage_get_block_0: 
04cd			 
04cd				; TODO check presence 
04cd			 
04cd				; get block 0 config 
04cd			 
04cd 21 00 00			ld hl, 0 
04d0 11 81 fa			ld de, store_page 
04d3 cd 1c 04			call storage_read_block 
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "SB0" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 6e fe			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 6f fe			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 70 fe			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "SB0"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef 11 81 fa				ld de, store_page 
04f2			;		push af 
04f2			;		ld a, 'i' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2					CALLMONITOR 
04f2 cd c1 19			call break_point_state  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5				; is this area formatted? 
04f5			 
04f5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f5 2a 82 fa			ld hl, (store_page+1) 
04f8 3e 80			ld a,0x80 
04fa bd				cp l 
04fb 20 22			jr nz, .ininotformatted 
04fd				; do a double check 
04fd 3e 27			ld a, 0x27 
04ff bc				cp h 
0500 20 1d			jr nz, .ininotformatted 
0502			 
0502				; formatted then 
0502			 
0502				if DEBUG_STORESE 
0502					DMARK "SB1" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6e fe			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6f fe			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 70 fe			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "SB1"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					;push af 
051b					;ld a, 'I' 
051b					;ld (debug_mark),a 
051b					;pop af 
051b					CALLMONITOR 
051b cd c1 19			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e c9				ret 
051f			 
051f			.ininotformatted: 
051f				; bank not formatted so poke various bits to make sure 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB2" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 6e fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 6f fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 70 fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB2"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538					;push af 
0538					;ld a, 'f' 
0538					;ld (debug_mark),a 
0538					;pop af 
0538					CALLMONITOR 
0538 cd c1 19			call break_point_state  
053b				endm  
# End of macro CALLMONITOR
053b				endif 
053b			 
053b cd 58 0c			call storage_clear_page 
053e			 
053e 21 81 fa			ld hl, store_page 
0541 3e 00			ld a, 0 
0543				 
0543 77				ld (hl),a   ; reset file counter 
0544			 
0544 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0547 22 82 fa		 	ld (store_page+1), hl	 
054a			 
054a				; set default label 
054a			 
054a 21 e6 05			ld hl, .defaultbanklabl 
054d 11 84 fa		 	ld de, store_page+3 
0550 01 0f 00			ld bc, 15 
0553 ed b0			ldir 
0555			 
0555				; Append the current bank id 
0555 21 8d fa			ld hl, store_page+3+9 
0558 3a 66 fa			ld a, (spi_device_id) 
055b 77				ld (hl), a 
055c			 
055c				; save default page 0 
055c			 
055c 21 00 00			ld hl, 0 
055f 11 81 fa			ld de, store_page 
0562				if DEBUG_STORESE 
0562					DMARK "SB3" 
0562 f5				push af  
0563 3a 77 05			ld a, (.dmark)  
0566 32 6e fe			ld (debug_mark),a  
0569 3a 78 05			ld a, (.dmark+1)  
056c 32 6f fe			ld (debug_mark+1),a  
056f 3a 79 05			ld a, (.dmark+2)  
0572 32 70 fe			ld (debug_mark+2),a  
0575 18 03			jr .pastdmark  
0577 ..			.dmark: db "SB3"  
057a f1			.pastdmark: pop af  
057b			endm  
# End of macro DMARK
057b			;		push af 
057b			;		ld a, 'F' 
057b			;		ld (debug_mark),a 
057b			;		pop af 
057b					CALLMONITOR 
057b cd c1 19			call break_point_state  
057e				endm  
# End of macro CALLMONITOR
057e				endif 
057e cd 81 04			call storage_write_block 
0581				if DEBUG_STORESE 
0581					DMARK "SB4" 
0581 f5				push af  
0582 3a 96 05			ld a, (.dmark)  
0585 32 6e fe			ld (debug_mark),a  
0588 3a 97 05			ld a, (.dmark+1)  
058b 32 6f fe			ld (debug_mark+1),a  
058e 3a 98 05			ld a, (.dmark+2)  
0591 32 70 fe			ld (debug_mark+2),a  
0594 18 03			jr .pastdmark  
0596 ..			.dmark: db "SB4"  
0599 f1			.pastdmark: pop af  
059a			endm  
# End of macro DMARK
059a			;		push af 
059a			;		ld a, '>' 
059a			;		ld (debug_mark),a 
059a			;		pop af 
059a					CALLMONITOR 
059a cd c1 19			call break_point_state  
059d				endm  
# End of macro CALLMONITOR
059d				endif 
059d			 
059d 00				nop 
059e 00				nop 
059f 00				nop 
05a0			 
05a0				; now set 0 in every page to mark as a free block 
05a0			 
05a0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05a2 21 40 00			ld hl, STORE_BLOCK_PHY 
05a5			 
05a5 3e 00		.setmark1:   	ld a,0 
05a7 e5					push hl 
05a8 c5					push bc 
05a9 cd 21 02				call se_writebyte 
05ac 3e 0a			ld a, 10 
05ae cd 7a 0c			call aDelayInMS 
05b1 23				inc hl 
05b2 cd 21 02				call se_writebyte 
05b5 3e 0a			ld a, 10 
05b7 cd 7a 0c			call aDelayInMS 
05ba 2b				dec hl 
05bb c1					pop bc 
05bc e1					pop hl 
05bd 3e 40				ld a, STORE_BLOCK_PHY 
05bf cd 4c 0f				call addatohl 
05c2 10 e1				djnz .setmark1 
05c4			 
05c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c6 3e 00		.setmark2:   	ld a,0 
05c8 e5					push hl 
05c9 c5					push bc 
05ca cd 21 02				call se_writebyte 
05cd 3e 0a			ld a, 10 
05cf cd 7a 0c			call aDelayInMS 
05d2 23				inc hl 
05d3 cd 21 02				call se_writebyte 
05d6 3e 0a			ld a, 10 
05d8 cd 7a 0c			call aDelayInMS 
05db 2b				dec hl 
05dc c1					pop bc 
05dd e1					pop hl 
05de 3e 40				ld a, STORE_BLOCK_PHY 
05e0 cd 4c 0f				call addatohl 
05e3 10 e1				djnz .setmark2 
05e5			 
05e5					 
05e5			 
05e5			 
05e5 c9				ret 
05e6			 
05e6			 
05e6			 
05e6			 
05e6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05f1			 
05f1			 
05f1			 
05f1			; Label Bank 
05f1			; ---------- 
05f1			; 
05f1			; With current bank 
05f1			; Read block 0 
05f1			; Set label 
05f1			; Write block 0 
05f1			 
05f1			; label str pointer in hl 
05f1			 
05f1			storage_label:     
05f1			 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBL" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 6e fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 6f fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 70 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBL"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd c1 19			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d			 
060d e5				push hl 
060e			 
060e cd cd 04			call storage_get_block_0 
0611			 
0611				; set default label 
0611			 
0611 e1				pop hl 
0612			 
0612 11 84 fa		 	ld de, store_page+3 
0615 01 0f 00			ld bc, 15 
0618				if DEBUG_STORESE 
0618					DMARK "LB3" 
0618 f5				push af  
0619 3a 2d 06			ld a, (.dmark)  
061c 32 6e fe			ld (debug_mark),a  
061f 3a 2e 06			ld a, (.dmark+1)  
0622 32 6f fe			ld (debug_mark+1),a  
0625 3a 2f 06			ld a, (.dmark+2)  
0628 32 70 fe			ld (debug_mark+2),a  
062b 18 03			jr .pastdmark  
062d ..			.dmark: db "LB3"  
0630 f1			.pastdmark: pop af  
0631			endm  
# End of macro DMARK
0631					CALLMONITOR 
0631 cd c1 19			call break_point_state  
0634				endm  
# End of macro CALLMONITOR
0634				endif 
0634 ed b0			ldir 
0636				; save default page 0 
0636			 
0636 21 00 00			ld hl, 0 
0639 11 81 fa			ld de, store_page 
063c				if DEBUG_STORESE 
063c					DMARK "LBW" 
063c f5				push af  
063d 3a 51 06			ld a, (.dmark)  
0640 32 6e fe			ld (debug_mark),a  
0643 3a 52 06			ld a, (.dmark+1)  
0646 32 6f fe			ld (debug_mark+1),a  
0649 3a 53 06			ld a, (.dmark+2)  
064c 32 70 fe			ld (debug_mark+2),a  
064f 18 03			jr .pastdmark  
0651 ..			.dmark: db "LBW"  
0654 f1			.pastdmark: pop af  
0655			endm  
# End of macro DMARK
0655					CALLMONITOR 
0655 cd c1 19			call break_point_state  
0658				endm  
# End of macro CALLMONITOR
0658				endif 
0658 cd 81 04			call storage_write_block 
065b			 
065b c9				ret 
065c			 
065c			 
065c			 
065c			; Read Block 0 - Config 
065c			; --------------------- 
065c			; 
065c			; With current bank 
065c			; Call presence test 
065c			;    If not present format/init bank  
065c			; Read block 0  
065c			;  
065c			 
065c			 
065c			; Dir 
065c			; --- 
065c			; 
065c			; With current bank 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block read byte 2 
065c			;      if first block of file 
065c			;         Display file name 
065c			;         Display type flags for file 
065c			;        
065c			 
065c			; moving to words as this requires stack control 
065c			 
065c			 
065c			; Delete File 
065c			; ----------- 
065c			; 
065c			; With current bank 
065c			; 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block file id 
065c			;      If first block of file and dont have file id 
065c			;         if file to delete 
065c			;         Save file id 
065c			;         Null file id 
065c			;         Write this block back 
065c			;      If file id is one saved 
065c			;         Null file id 
065c			;         Write this block back 
065c			 
065c			 
065c			.se_done: 
065c e1				pop hl 
065d c9				ret 
065e			 
065e			storage_erase: 
065e			 
065e				; hl contains the file id 
065e			 
065e 5d				ld e, l 
065f 16 00			ld d, 0 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ERA" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 6e fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 6f fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 70 fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ERA"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd c1 19			call break_point_state  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 4f 07			call storage_findnextid 
0683 cd 75 0f			call ishlzero 
0686 c8				ret z 
0687			 
0687 e5				push hl 
0688			 
0688				; TODO check file not found 
0688			 
0688 11 81 fa			ld de, store_page 
068b cd 1c 04			call storage_read_block 
068e			 
068e cd 75 0f			call ishlzero 
0691 ca 5c 06			jp z,.se_done 
0694			 
0694					if DEBUG_FORTH_WORDS 
0694						DMARK "ER1" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 6e fe			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 6f fe			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 70 fe			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "ER1"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad						CALLMONITOR 
06ad cd c1 19			call break_point_state  
06b0				endm  
# End of macro CALLMONITOR
06b0					endif 
06b0 3a 81 fa			ld a, (store_page)	; get file id 
06b3 32 75 fa			ld (store_tmpid), a 
06b6			 
06b6 3a 83 fa			ld a, (store_page+2)    ; get count of extends 
06b9 32 74 fa			ld (store_tmpext), a 
06bc			 
06bc				; wipe file header 
06bc			 
06bc e1				pop hl 
06bd 3e 00			ld a, 0 
06bf 32 81 fa			ld (store_page), a 
06c2 32 82 fa			ld (store_page+1),a 
06c5 11 81 fa			ld de, store_page 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER2" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 6e fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 6f fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 70 fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER2"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd c1 19			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 81 04			call storage_write_block 
06e7			 
06e7			 
06e7				; wipe file extents 
06e7			 
06e7 3a 74 fa			ld a, (store_tmpext) 
06ea 47				ld b, a 
06eb			 
06eb			.eraext:	  
06eb c5				push bc 
06ec			 
06ec 21 40 00			ld hl, STORE_BLOCK_PHY 
06ef 3a 75 fa			ld a,(store_tmpid) 
06f2 5f				ld e, a 
06f3 50				ld d, b	 
06f4					if DEBUG_FORTH_WORDS 
06f4						DMARK "ER3" 
06f4 f5				push af  
06f5 3a 09 07			ld a, (.dmark)  
06f8 32 6e fe			ld (debug_mark),a  
06fb 3a 0a 07			ld a, (.dmark+1)  
06fe 32 6f fe			ld (debug_mark+1),a  
0701 3a 0b 07			ld a, (.dmark+2)  
0704 32 70 fe			ld (debug_mark+2),a  
0707 18 03			jr .pastdmark  
0709 ..			.dmark: db "ER3"  
070c f1			.pastdmark: pop af  
070d			endm  
# End of macro DMARK
070d						CALLMONITOR 
070d cd c1 19			call break_point_state  
0710				endm  
# End of macro CALLMONITOR
0710					endif 
0710 cd 4f 07			call storage_findnextid 
0713 cd 75 0f			call ishlzero 
0716 ca 5c 06			jp z,.se_done 
0719			 
0719 e5				push hl 
071a 11 81 fa			ld de, store_page 
071d cd 1c 04			call storage_read_block 
0720			 
0720				; free block	 
0720			 
0720 3e 00			ld a, 0 
0722 32 81 fa			ld (store_page), a 
0725 32 82 fa			ld (store_page+1),a 
0728 11 81 fa			ld de, store_page 
072b e1				pop hl 
072c					if DEBUG_FORTH_WORDS 
072c						DMARK "ER4" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6e fe			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6f fe			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 70 fe			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "ER4"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745						CALLMONITOR 
0745 cd c1 19			call break_point_state  
0748				endm  
# End of macro CALLMONITOR
0748					endif 
0748 cd 81 04			call storage_write_block 
074b			 
074b c1				pop bc 
074c 10 9d			djnz .eraext 
074e			 
074e c9				ret 
074f			 
074f			 
074f			; Find Free Block 
074f			; --------------- 
074f			; 
074f			; With current bank 
074f			;  
074f			; From given starting logical block 
074f			;    Read block  
074f			;    If no file id 
074f			;         Return block id 
074f			 
074f			 
074f			; hl starting page number 
074f			; hl contains free page number or zero if no pages free 
074f			; e contains the file id to locate 
074f			; d contains the block number 
074f			 
074f			; TODO change to find file id and use zero for free block 
074f			 
074f			storage_findnextid: 
074f			 
074f				; now locate first 0 page to mark as a free block 
074f			 
074f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0751			;	ld hl, STORE_BLOCK_PHY 
0751			 
0751					if DEBUG_FORTH_WORDS 
0751					DMARK "FNI" 
0751 f5				push af  
0752 3a 66 07			ld a, (.dmark)  
0755 32 6e fe			ld (debug_mark),a  
0758 3a 67 07			ld a, (.dmark+1)  
075b 32 6f fe			ld (debug_mark+1),a  
075e 3a 68 07			ld a, (.dmark+2)  
0761 32 70 fe			ld (debug_mark+2),a  
0764 18 03			jr .pastdmark  
0766 ..			.dmark: db "FNI"  
0769 f1			.pastdmark: pop af  
076a			endm  
# End of macro DMARK
076a						CALLMONITOR 
076a cd c1 19			call break_point_state  
076d				endm  
# End of macro CALLMONITOR
076d					endif 
076d			.ff1:   	 
076d e5					push hl 
076e c5					push bc 
076f d5					push de 
0770 cd c3 02				call se_readbyte 
0773 5f					ld e,a 
0774 23					inc hl 
0775 cd c3 02				call se_readbyte 
0778 57					ld d, a 
0779 e1					pop hl 
077a e5					push hl 
077b cd 6a 0f				call cmp16 
077e 28 49				jr z, .fffound 
0780			 
0780 d1					pop de 
0781 c1					pop bc 
0782 e1					pop hl 
0783			 
0783					; is found? 
0783					;cp e 
0783					;ret z 
0783			 
0783 3e 40				ld a, STORE_BLOCK_PHY 
0785 cd 4c 0f				call addatohl 
0788 10 e3				djnz .ff1 
078a			 
078a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078c			.ff2:   	 
078c			 
078c e5					push hl 
078d c5					push bc 
078e d5					push de 
078f cd c3 02				call se_readbyte 
0792 5f					ld e,a 
0793 23					inc hl 
0794 cd c3 02				call se_readbyte 
0797 57					ld d, a 
0798			 
0798 e1					pop hl 
0799 e5					push hl 
079a cd 6a 0f				call cmp16 
079d 28 2a				jr z, .fffound 
079f			 
079f d1					pop de 
07a0 c1					pop bc 
07a1 e1					pop hl 
07a2					; is found? 
07a2					;cp e 
07a2					;ret z 
07a2			 
07a2 3e 40				ld a, STORE_BLOCK_PHY 
07a4 cd 4c 0f				call addatohl 
07a7 10 e3				djnz .ff2 
07a9			 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FN-" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 6e fe			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 6f fe			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 70 fe			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FN-"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					;	push af 
07c2					;	ld a, 'n' 
07c2					;	ld (debug_mark),a 
07c2					;	pop af 
07c2						CALLMONITOR 
07c2 cd c1 19			call break_point_state  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5				; no free marks! 
07c5 21 00 00				ld hl, 0 
07c8 c9				ret 
07c9			.fffound: 
07c9				 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc					if DEBUG_FORTH_WORDS 
07cc					DMARK "FNF" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 6e fe			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 6f fe			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 70 fe			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "FNF"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;	push af 
07e5					;	ld a, 'n' 
07e5					;	ld (debug_mark),a 
07e5					;	pop af 
07e5						CALLMONITOR 
07e5 cd c1 19			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8					endif 
07e8 c9				ret 
07e9			 
07e9			 
07e9			 
07e9			; Free Space 
07e9			; ---------- 
07e9			; 
07e9			; With current bank 
07e9			; 
07e9			; Set block count to zero 
07e9			; Starting with first logical block 
07e9			;      Find free block  
07e9			;      If block id given, increment block count 
07e9			; 
07e9			;  
07e9			 
07e9			 
07e9			; hl contains count of free blocks 
07e9			 
07e9			storage_freeblocks: 
07e9			 
07e9				; now locate first 0 page to mark as a free block 
07e9			 
07e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07eb 21 40 00			ld hl, STORE_BLOCK_PHY 
07ee 11 00 00			ld de, 0 
07f1			 
07f1			.fb1:   	 
07f1 e5					push hl 
07f2 c5					push bc 
07f3 d5					push de 
07f4 cd c3 02				call se_readbyte 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa			 
07fa					; is free? 
07fa fe 00				cp 0 
07fc 20 01				jr nz, .ff1cont 
07fe 13					inc de 
07ff			 
07ff			.ff1cont: 
07ff			 
07ff			 
07ff 3e 40				ld a, STORE_BLOCK_PHY 
0801 cd 4c 0f				call addatohl 
0804 10 eb				djnz .fb1 
0806			 
0806 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0808			.fb2:   	 
0808 e5					push hl 
0809 c5					push bc 
080a d5					push de 
080b cd c3 02				call se_readbyte 
080e d1					pop de 
080f c1					pop bc 
0810 e1					pop hl 
0811			 
0811					; is free? 
0811 fe 00				cp 0 
0813 20 01				jr nz, .ff2cont 
0815 13					inc de 
0816			 
0816			.ff2cont: 
0816			 
0816 3e 40				ld a, STORE_BLOCK_PHY 
0818 cd 4c 0f				call addatohl 
081b 10 eb				djnz .fb2 
081d			 
081d eb				ex de, hl 
081e c9				ret 
081f			 
081f			; Get File ID 
081f			; ----------- 
081f			; 
081f			; With current bank 
081f			;  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; For each logical block 
081f			;    Read block file id 
081f			;      If first block of file and dont have file id 
081f			;         if file get id and exit 
081f			 
081f			 
081f			 
081f			 
081f			; Create File 
081f			; ----------- 
081f			; 
081f			; With current bank  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; Increment file id number 
081f			; Save Config 
081f			; Find free block 
081f			; Set buffer with file name and file id 
081f			; Write buffer to free block  
081f			 
081f			 
081f			; hl point to file name 
081f			; hl returns file id 
081f			 
081f			; file format: 
081f			; byte 0 - file id 
081f			; byte 1 - extent number 
081f			; byte 2-> data 
081f			 
081f			; format for extent number 0: 
081f			; 
081f			; byte 0 - file id 
081f			; byte 1 - extent 0 
081f			; byte 2 - extent count 
081f			; byte 3 -> file name and meta data 
081f			 
081f			 
081f			storage_create: 
081f				if DEBUG_STORESE 
081f					DMARK "SCR" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 6e fe			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 6f fe			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 70 fe			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "SCR"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd c1 19			call break_point_state  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			 
083b e5				push hl		; save file name pointer 
083c			 
083c cd cd 04			call storage_get_block_0 
083f			 
083f 3a 81 fa			ld a,(store_page)	; get current file id 
0842 3c				inc a 
0843 32 81 fa			ld (store_page),a 
0846				 
0846 32 75 fa			ld (store_tmpid),a			; save id 
0849			 
0849 21 00 00			ld hl, 0 
084c 11 81 fa			ld de, store_page 
084f				if DEBUG_STORESE 
084f					DMARK "SCw" 
084f f5				push af  
0850 3a 64 08			ld a, (.dmark)  
0853 32 6e fe			ld (debug_mark),a  
0856 3a 65 08			ld a, (.dmark+1)  
0859 32 6f fe			ld (debug_mark+1),a  
085c 3a 66 08			ld a, (.dmark+2)  
085f 32 70 fe			ld (debug_mark+2),a  
0862 18 03			jr .pastdmark  
0864 ..			.dmark: db "SCw"  
0867 f1			.pastdmark: pop af  
0868			endm  
# End of macro DMARK
0868					CALLMONITOR 
0868 cd c1 19			call break_point_state  
086b				endm  
# End of macro CALLMONITOR
086b				endif 
086b cd 81 04			call storage_write_block	 ; save update 
086e			 
086e				if DEBUG_STORESE 
086e 11 81 fa				ld de, store_page 
0871					DMARK "SCC" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 6e fe			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 6f fe			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 70 fe			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "SCC"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd c1 19			call break_point_state  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d				;  
088d				 
088d 21 40 00			ld hl, STORE_BLOCK_PHY 
0890 11 00 00			ld de, 0 
0893 cd 4f 07			call storage_findnextid 
0896			 
0896 22 6c fa			ld (store_tmppageid), hl    ; save page to use  
0899			 
0899				; TODO detect 0 = no spare blocks 
0899			 
0899				; hl now contains the free page to use for the file header page 
0899			 
0899				if DEBUG_STORESE 
0899				DMARK "SCF" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 6e fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 6f fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 70 fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCF"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd c1 19			call break_point_state  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			 
08b5 22 6c fa			ld (store_tmppageid), hl 
08b8				 
08b8 3a 75 fa			ld a,(store_tmpid)    ; get file id 
08bb			;	ld a, (store_filecache)			; save to cache 
08bb			 
08bb 32 81 fa			ld (store_page),a    ; set page id 
08be 3e 00			ld a, 0			 ; extent 0 is file header 
08c0 32 82 fa			ld (store_page+1), a   ; set file extent 
08c3			 
08c3 32 83 fa			ld (store_page+2), a   ; extent count for the file 
08c6			 
08c6			;	inc hl 		; init block 0 of file 
08c6			;	inc hl   		; skip file and extent id 
08c6			 ;       ld a, 0 
08c6			;	ld (hl),a 
08c6			;	ld a, (store_filecache+1)  	; save to cache 
08c6			 
08c6			;	inc hl    ; file name 
08c6				 
08c6				 
08c6 11 84 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
08c9				if DEBUG_STORESE 
08c9					DMARK "SCc" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 6e fe			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 6f fe			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 70 fe			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCc"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd c1 19			call break_point_state  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5 e1				pop hl    ; get zero term string 
08e6 e5				push hl 
08e7 3e 00			ld a, 0 
08e9 cd b5 13			call strlent 
08ec 23				inc hl   ; cover zero term 
08ed 06 00			ld b,0 
08ef 4d				ld c,l 
08f0 e1				pop hl 
08f1				;ex de, hl 
08f1				if DEBUG_STORESE 
08f1					DMARK "SCa" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 6e fe			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 6f fe			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 70 fe			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCa"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					;push af 
090a					;ld a, 'a' 
090a					;ld (debug_mark),a 
090a					;pop af 
090a					CALLMONITOR 
090a cd c1 19			call break_point_state  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d ed b0			ldir    ; copy zero term string 
090f				if DEBUG_STORESE 
090f					DMARK "SCA" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 6e fe			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 6f fe			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 70 fe			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "SCA"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd c1 19			call break_point_state  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b			 
092b				; write file header page 
092b			 
092b 2a 6c fa			ld hl,(store_tmppageid) 
092e 11 81 fa			ld de, store_page 
0931				if DEBUG_STORESE 
0931					DMARK "SCb" 
0931 f5				push af  
0932 3a 46 09			ld a, (.dmark)  
0935 32 6e fe			ld (debug_mark),a  
0938 3a 47 09			ld a, (.dmark+1)  
093b 32 6f fe			ld (debug_mark+1),a  
093e 3a 48 09			ld a, (.dmark+2)  
0941 32 70 fe			ld (debug_mark+2),a  
0944 18 03			jr .pastdmark  
0946 ..			.dmark: db "SCb"  
0949 f1			.pastdmark: pop af  
094a			endm  
# End of macro DMARK
094a					;push af 
094a					;ld a, 'b' 
094a					;ld (debug_mark),a 
094a					;pop af 
094a					CALLMONITOR 
094a cd c1 19			call break_point_state  
094d				endm  
# End of macro CALLMONITOR
094d				endif 
094d cd 81 04			call storage_write_block 
0950			 
0950 3a 75 fa			ld a, (store_tmpid) 
0953 6f				ld l, a 
0954 26 00			ld h,0 
0956				if DEBUG_STORESE 
0956					DMARK "SCz" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 6e fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 6f fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 70 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "SCz"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd c1 19			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 c9				ret 
0973				 
0973			 
0973			 
0973			; 
0973			; Read File 
0973			; 
0973			; h - file id to locate 
0973			; l - extent to locate 
0973			; de - pointer to string to read into 
0973			; 
0973			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0973			 
0973			.sr_fail: 
0973 d1				pop de 
0974 c9				ret 
0975			 
0975			storage_read: 
0975			 
0975			 
0975 d5				push de 
0976			 
0976			; TODO BUG the above push is it popped before the RET Z? 
0976			 
0976			; TODO how to handle multiple part blocks 
0976			 
0976				; locate file extent to read 
0976			 
0976 5c				ld e, h 
0977 55				ld d, l 
0978			 
0978			.srext: 
0978 22 7f fa			ld (store_readptr), hl     ; save the current extent to load 
097b ed 53 7d fa		ld (store_readbuf), de     ; save the current buffer to load in to 
097f			 
097f 21 40 00			ld hl, STORE_BLOCK_PHY 
0982				if DEBUG_STORESE 
0982					DMARK "sre" 
0982 f5				push af  
0983 3a 97 09			ld a, (.dmark)  
0986 32 6e fe			ld (debug_mark),a  
0989 3a 98 09			ld a, (.dmark+1)  
098c 32 6f fe			ld (debug_mark+1),a  
098f 3a 99 09			ld a, (.dmark+2)  
0992 32 70 fe			ld (debug_mark+2),a  
0995 18 03			jr .pastdmark  
0997 ..			.dmark: db "sre"  
099a f1			.pastdmark: pop af  
099b			endm  
# End of macro DMARK
099b					CALLMONITOR 
099b cd c1 19			call break_point_state  
099e				endm  
# End of macro CALLMONITOR
099e				endif 
099e cd 4f 07			call storage_findnextid 
09a1			 
09a1				if DEBUG_STORESE 
09a1					DMARK "srf" 
09a1 f5				push af  
09a2 3a b6 09			ld a, (.dmark)  
09a5 32 6e fe			ld (debug_mark),a  
09a8 3a b7 09			ld a, (.dmark+1)  
09ab 32 6f fe			ld (debug_mark+1),a  
09ae 3a b8 09			ld a, (.dmark+2)  
09b1 32 70 fe			ld (debug_mark+2),a  
09b4 18 03			jr .pastdmark  
09b6 ..			.dmark: db "srf"  
09b9 f1			.pastdmark: pop af  
09ba			endm  
# End of macro DMARK
09ba					CALLMONITOR 
09ba cd c1 19			call break_point_state  
09bd				endm  
# End of macro CALLMONITOR
09bd				endif 
09bd cd 75 0f			call ishlzero 
09c0			;	ld a, l 
09c0			;	add h 
09c0			;	cp 0 
09c0 28 b1			jr z,.sr_fail			; block not found so EOF 
09c2			 
09c2				; save current address for use by higher level words etc 
09c2			 
09c2 22 72 fa			ld (store_openaddr),hl 
09c5			 
09c5			 
09c5				; hl contains page number to load 
09c5 d1				pop de   ; get storage 
09c6 ed 53 7d fa		ld (store_readbuf), de     ; current buffer to load in to 
09ca d5				push de 
09cb				if DEBUG_STORESE 
09cb					DMARK "srg" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6e fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6f fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 70 fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "srg"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd c1 19			call break_point_state  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 1c 04			call storage_read_block 
09ea			 
09ea				; if this a continuation read??? 
09ea			 
09ea 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09ed			 
09ed 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ef cd 4c 0f			call addatohl 
09f2 7e				ld a,(hl) 
09f3 fe 00			cp 0 
09f5 28 02			jr z, .markiscont 
09f7 3e ff			ld a, 255 
09f9			 
09f9			.markiscont: 
09f9 32 74 fa			ld (store_readcont), a 
09fc			 
09fc				if DEBUG_STORESE 
09fc					DMARK "srC" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 6e fe			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 6f fe			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 70 fe			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "srC"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd c1 19			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18				; only short reads enabled 
0a18			 
0a18 3a 7c fa			ld a, (store_longread) 
0a1b fe 00			cp 0 
0a1d ca ea 0a			jp z, .readdone 
0a20			 
0a20			; TODO if block has no zeros then need to read next block  
0a20			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a20			; check last byte of physical block. 
0a20			; if not zero then the next block needs to be loaded 
0a20			 
0a20			 
0a20 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a23			 
0a23 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a25 cd 4c 0f			call addatohl 
0a28				;dec hl 
0a28 7e				ld a,(hl) 
0a29				if DEBUG_STORESE 
0a29					DMARK "sr?" 
0a29 f5				push af  
0a2a 3a 3e 0a			ld a, (.dmark)  
0a2d 32 6e fe			ld (debug_mark),a  
0a30 3a 3f 0a			ld a, (.dmark+1)  
0a33 32 6f fe			ld (debug_mark+1),a  
0a36 3a 40 0a			ld a, (.dmark+2)  
0a39 32 70 fe			ld (debug_mark+2),a  
0a3c 18 03			jr .pastdmark  
0a3e ..			.dmark: db "sr?"  
0a41 f1			.pastdmark: pop af  
0a42			endm  
# End of macro DMARK
0a42					CALLMONITOR 
0a42 cd c1 19			call break_point_state  
0a45				endm  
# End of macro CALLMONITOR
0a45				endif 
0a45 fe 00			cp 0 
0a47 ca ea 0a			jp z, .readdone 
0a4a			 
0a4a				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a4a			 
0a4a 23				inc hl 
0a4b			 
0a4b 22 7d fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4e			 
0a4e ed 5b 7f fa		ld de, (store_readptr)     ; save the current extent to load 
0a52			 
0a52 eb				ex de, hl 
0a53			 
0a53				; next ext 
0a53			 
0a53 23				inc hl 
0a54 22 7f fa			ld  (store_readptr), hl     ; save the current extent to load 
0a57			 
0a57				if DEBUG_STORESE 
0a57					DMARK "sF2" 
0a57 f5				push af  
0a58 3a 6c 0a			ld a, (.dmark)  
0a5b 32 6e fe			ld (debug_mark),a  
0a5e 3a 6d 0a			ld a, (.dmark+1)  
0a61 32 6f fe			ld (debug_mark+1),a  
0a64 3a 6e 0a			ld a, (.dmark+2)  
0a67 32 70 fe			ld (debug_mark+2),a  
0a6a 18 03			jr .pastdmark  
0a6c ..			.dmark: db "sF2"  
0a6f f1			.pastdmark: pop af  
0a70			endm  
# End of macro DMARK
0a70					CALLMONITOR 
0a70 cd c1 19			call break_point_state  
0a73				endm  
# End of macro CALLMONITOR
0a73				endif 
0a73			 
0a73				; get and load block 
0a73			 
0a73 cd 4f 07			call storage_findnextid 
0a76			 
0a76				if DEBUG_STORESE 
0a76					DMARK "sf2" 
0a76 f5				push af  
0a77 3a 8b 0a			ld a, (.dmark)  
0a7a 32 6e fe			ld (debug_mark),a  
0a7d 3a 8c 0a			ld a, (.dmark+1)  
0a80 32 6f fe			ld (debug_mark+1),a  
0a83 3a 8d 0a			ld a, (.dmark+2)  
0a86 32 70 fe			ld (debug_mark+2),a  
0a89 18 03			jr .pastdmark  
0a8b ..			.dmark: db "sf2"  
0a8e f1			.pastdmark: pop af  
0a8f			endm  
# End of macro DMARK
0a8f					CALLMONITOR 
0a8f cd c1 19			call break_point_state  
0a92				endm  
# End of macro CALLMONITOR
0a92				endif 
0a92 cd 75 0f			call ishlzero 
0a95			;	ld a, l 
0a95			;	add h 
0a95			;	cp 0 
0a95 ca 73 09			jp z,.sr_fail			; block not found so EOF 
0a98				 
0a98				; save current address for use by higher level words etc 
0a98			 
0a98 22 72 fa			ld (store_openaddr),hl 
0a9b			 
0a9b cd 1c 04			call storage_read_block 
0a9e			 
0a9e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9e				; we need to pull everything back  
0a9e			 
0a9e ed 5b 7d fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aa2 2a 7d fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa5 23				inc hl 
0aa6 23				inc hl     ; skip id and ext 
0aa7 01 40 00			ld bc, STORE_BLOCK_PHY 
0aaa				if DEBUG_STORESE 
0aaa					DMARK "SR<" 
0aaa f5				push af  
0aab 3a bf 0a			ld a, (.dmark)  
0aae 32 6e fe			ld (debug_mark),a  
0ab1 3a c0 0a			ld a, (.dmark+1)  
0ab4 32 6f fe			ld (debug_mark+1),a  
0ab7 3a c1 0a			ld a, (.dmark+2)  
0aba 32 70 fe			ld (debug_mark+2),a  
0abd 18 03			jr .pastdmark  
0abf ..			.dmark: db "SR<"  
0ac2 f1			.pastdmark: pop af  
0ac3			endm  
# End of macro DMARK
0ac3					CALLMONITOR 
0ac3 cd c1 19			call break_point_state  
0ac6				endm  
# End of macro CALLMONITOR
0ac6				endif 
0ac6 ed b0			ldir     ; copy data 
0ac8			 
0ac8				; move the pointer back and pretend we have a full buffer for next recheck 
0ac8			 
0ac8 1b				dec de 
0ac9 1b				dec de 
0aca			 
0aca			; TODO do pop below now short circuit loop????? 
0aca c1				pop bc     ; get rid of spare de on stack 
0acb				if DEBUG_STORESE 
0acb					DMARK "SR>" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 6e fe			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 6f fe			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 70 fe			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "SR>"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd c1 19			call break_point_state  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 c3 78 09			jp .srext 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			.readdone:		 
0aea e1				pop hl 		 ; return start of data to show as not EOF 
0aeb 23				inc hl   ; past file id 
0aec 23				inc hl   ; past ext 
0aed				if DEBUG_STORESE 
0aed					DMARK "SRe" 
0aed f5				push af  
0aee 3a 02 0b			ld a, (.dmark)  
0af1 32 6e fe			ld (debug_mark),a  
0af4 3a 03 0b			ld a, (.dmark+1)  
0af7 32 6f fe			ld (debug_mark+1),a  
0afa 3a 04 0b			ld a, (.dmark+2)  
0afd 32 70 fe			ld (debug_mark+2),a  
0b00 18 03			jr .pastdmark  
0b02 ..			.dmark: db "SRe"  
0b05 f1			.pastdmark: pop af  
0b06			endm  
# End of macro DMARK
0b06					CALLMONITOR 
0b06 cd c1 19			call break_point_state  
0b09				endm  
# End of macro CALLMONITOR
0b09				endif 
0b09 c9					ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Append File 
0b0a			; 
0b0a			; hl - file id to locate 
0b0a			; de - pointer to (multi block) string to write 
0b0a			 
0b0a			.sa_notfound: 
0b0a d1				pop de 
0b0b c9				ret 
0b0c			 
0b0c			 
0b0c			storage_append: 
0b0c				; hl -  file id to append to 
0b0c				; de - string to append 
0b0c			 
0b0c d5				push de 
0b0d				 
0b0d				if DEBUG_STORESE 
0b0d					DMARK "AP1" 
0b0d f5				push af  
0b0e 3a 22 0b			ld a, (.dmark)  
0b11 32 6e fe			ld (debug_mark),a  
0b14 3a 23 0b			ld a, (.dmark+1)  
0b17 32 6f fe			ld (debug_mark+1),a  
0b1a 3a 24 0b			ld a, (.dmark+2)  
0b1d 32 70 fe			ld (debug_mark+2),a  
0b20 18 03			jr .pastdmark  
0b22 ..			.dmark: db "AP1"  
0b25 f1			.pastdmark: pop af  
0b26			endm  
# End of macro DMARK
0b26					CALLMONITOR 
0b26 cd c1 19			call break_point_state  
0b29				endm  
# End of macro CALLMONITOR
0b29				endif 
0b29			 
0b29 7d				ld a, l 
0b2a 32 75 fa			ld (store_tmpid), a 
0b2d			 
0b2d				; get file header  
0b2d			 
0b2d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2f 3a 75 fa			ld a, (store_tmpid) 
0b32 5f				ld e, a 
0b33			 
0b33 21 40 00				ld hl, STORE_BLOCK_PHY 
0b36 cd 4f 07				call storage_findnextid 
0b39			 
0b39 cd 75 0f			call ishlzero 
0b3c 28 cc			jr z, .sa_notfound 
0b3e			 
0b3e 22 6c fa			ld (store_tmppageid), hl 
0b41			 
0b41				; TODO handle file id not found 
0b41			 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP2" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6e fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6f fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 70 fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP2"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd c1 19			call break_point_state  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d			 
0b5d				; update file extent count 
0b5d			 
0b5d 11 81 fa			ld de, store_page 
0b60			 
0b60 cd 1c 04			call storage_read_block 
0b63			 
0b63				if DEBUG_STORESE 
0b63					DMARK "AP3" 
0b63 f5				push af  
0b64 3a 78 0b			ld a, (.dmark)  
0b67 32 6e fe			ld (debug_mark),a  
0b6a 3a 79 0b			ld a, (.dmark+1)  
0b6d 32 6f fe			ld (debug_mark+1),a  
0b70 3a 7a 0b			ld a, (.dmark+2)  
0b73 32 70 fe			ld (debug_mark+2),a  
0b76 18 03			jr .pastdmark  
0b78 ..			.dmark: db "AP3"  
0b7b f1			.pastdmark: pop af  
0b7c			endm  
# End of macro DMARK
0b7c					CALLMONITOR 
0b7c cd c1 19			call break_point_state  
0b7f				endm  
# End of macro CALLMONITOR
0b7f				endif 
0b7f			;	ld (store_tmppageid), hl 
0b7f			 
0b7f 3a 83 fa			ld a, (store_page+2) 
0b82 3c				inc a 
0b83 32 83 fa			ld (store_page+2), a 
0b86 32 74 fa			ld (store_tmpext), a 
0b89				 
0b89				if DEBUG_STORESE 
0b89					DMARK "AP3" 
0b89 f5				push af  
0b8a 3a 9e 0b			ld a, (.dmark)  
0b8d 32 6e fe			ld (debug_mark),a  
0b90 3a 9f 0b			ld a, (.dmark+1)  
0b93 32 6f fe			ld (debug_mark+1),a  
0b96 3a a0 0b			ld a, (.dmark+2)  
0b99 32 70 fe			ld (debug_mark+2),a  
0b9c 18 03			jr .pastdmark  
0b9e ..			.dmark: db "AP3"  
0ba1 f1			.pastdmark: pop af  
0ba2			endm  
# End of macro DMARK
0ba2					CALLMONITOR 
0ba2 cd c1 19			call break_point_state  
0ba5				endm  
# End of macro CALLMONITOR
0ba5				endif 
0ba5 2a 6c fa			ld hl, (store_tmppageid) 
0ba8 11 81 fa			ld de, store_page 
0bab cd 81 04			call storage_write_block 
0bae			 
0bae				; find free block 
0bae			 
0bae 11 00 00			ld de, 0			 ; file extent to locate 
0bb1			 
0bb1 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb4 cd 4f 07				call storage_findnextid 
0bb7 cd 75 0f			call ishlzero 
0bba ca 0a 0b			jp z, .sa_notfound 
0bbd			 
0bbd					; TODO handle no space left 
0bbd					 
0bbd 22 6c fa				ld (store_tmppageid), hl 
0bc0			 
0bc0				if DEBUG_STORESE 
0bc0					DMARK "AP4" 
0bc0 f5				push af  
0bc1 3a d5 0b			ld a, (.dmark)  
0bc4 32 6e fe			ld (debug_mark),a  
0bc7 3a d6 0b			ld a, (.dmark+1)  
0bca 32 6f fe			ld (debug_mark+1),a  
0bcd 3a d7 0b			ld a, (.dmark+2)  
0bd0 32 70 fe			ld (debug_mark+2),a  
0bd3 18 03			jr .pastdmark  
0bd5 ..			.dmark: db "AP4"  
0bd8 f1			.pastdmark: pop af  
0bd9			endm  
# End of macro DMARK
0bd9					CALLMONITOR 
0bd9 cd c1 19			call break_point_state  
0bdc				endm  
# End of macro CALLMONITOR
0bdc				endif 
0bdc					; init the buffer with zeros so we can id if the buffer is full or not 
0bdc			 
0bdc e5					push hl 
0bdd c5					push bc 
0bde			 
0bde 21 81 fa				ld hl, store_page 
0be1 06 40				ld b, STORE_BLOCK_PHY 
0be3 3e 00				ld a, 0 
0be5 77			.zeroblock:	ld (hl), a 
0be6 23					inc hl 
0be7 10 fc				djnz .zeroblock 
0be9			 
0be9 c1					pop bc 
0bea e1					pop hl 
0beb			 
0beb					; construct block 
0beb			 
0beb 3a 75 fa				ld a, (store_tmpid) 
0bee 32 81 fa				ld (store_page), a   ; file id 
0bf1 3a 74 fa				ld a, (store_tmpext)   ; extent for this block 
0bf4 32 82 fa				ld (store_page+1), a 
0bf7			 
0bf7 e1					pop hl    ; get string to write 
0bf8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bfa 11 83 fa				ld de, store_page+2 
0bfd			 
0bfd				if DEBUG_STORESE 
0bfd					DMARK "AP5" 
0bfd f5				push af  
0bfe 3a 12 0c			ld a, (.dmark)  
0c01 32 6e fe			ld (debug_mark),a  
0c04 3a 13 0c			ld a, (.dmark+1)  
0c07 32 6f fe			ld (debug_mark+1),a  
0c0a 3a 14 0c			ld a, (.dmark+2)  
0c0d 32 70 fe			ld (debug_mark+2),a  
0c10 18 03			jr .pastdmark  
0c12 ..			.dmark: db "AP5"  
0c15 f1			.pastdmark: pop af  
0c16			endm  
# End of macro DMARK
0c16					CALLMONITOR 
0c16 cd c1 19			call break_point_state  
0c19				endm  
# End of macro CALLMONITOR
0c19				endif 
0c19			 
0c19			 
0c19			 
0c19					; fill buffer with data until end of string or full block 
0c19			 
0c19 7e			.appd:		ld a, (hl) 
0c1a 12					ld (de), a 
0c1b fe 00				cp 0 
0c1d 28 04				jr z, .appdone 
0c1f 23					inc hl 
0c20 13					inc de 
0c21 10 f6				djnz .appd 
0c23			 
0c23 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c24 f5					push af   		; save last byte dumped 
0c25			 
0c25			 
0c25 2a 6c fa			ld hl, (store_tmppageid) 
0c28 11 81 fa			ld de, store_page 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP6" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 6e fe			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 6f fe			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 70 fe			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP6"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd c1 19			call break_point_state  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47 cd 81 04				call storage_write_block 
0c4a			 
0c4a			 
0c4a				; was that a full block of data written? 
0c4a				; any more to write out? 
0c4a			 
0c4a				; if yes then set vars and jump to start of function again 
0c4a			 
0c4a f1					pop af 
0c4b d1					pop de 
0c4c			 
0c4c fe 00				cp 0		 ; no, string was fully written 
0c4e c8					ret z 
0c4f			 
0c4f					; setup vars for next cycle 
0c4f			 
0c4f 3a 75 fa				ld a, (store_tmpid) 
0c52 6f					ld l, a 
0c53 26 00				ld h, 0 
0c55			 
0c55 c3 0c 0b			 	jp storage_append	 ; yes, need to write out some more 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			if DEBUG_STORECF 
0c58			storageput:	 
0c58					ret 
0c58			storageread: 
0c58					ld hl, store_page 
0c58					ld b, 200 
0c58					ld a,0 
0c58			.src:		ld (hl),a 
0c58					inc hl 
0c58					djnz .src 
0c58					 
0c58			 
0c58					ld de, 0 
0c58					ld bc, 1 
0c58					ld hl, store_page 
0c58					call cfRead 
0c58			 
0c58				call cfGetError 
0c58				ld hl,scratch 
0c58				call hexout 
0c58				ld hl, scratch+2 
0c58				ld a, 0 
0c58				ld (hl),a 
0c58				ld de, scratch 
0c58				ld a,display_row_1 
0c58				call str_at_display 
0c58				call update_display 
0c58			 
0c58					ld hl, store_page 
0c58					ld (os_cur_ptr),hl 
0c58			 
0c58					ret 
0c58			endif 
0c58			 
0c58			 
0c58			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c58			 
0c58			storage_clear_page: 
0c58 e5				push hl 
0c59 d5				push de 
0c5a c5				push bc 
0c5b 21 81 fa			ld hl, store_page 
0c5e 3e 00			ld a, 0 
0c60 77				ld (hl), a 
0c61			 
0c61 11 82 fa			ld de, store_page+1 
0c64 01 18 01			ld bc, STORE_BLOCK_LOG 
0c67			 
0c67 ed b0			ldir 
0c69				 
0c69 c1				pop bc 
0c6a d1				pop de 
0c6b e1				pop hl 
0c6c c9				ret 
0c6d			 
0c6d			; eof 
# End of file firmware_storage.asm
0c6d			  
0c6d			; support routines for above hardware abstraction layer  
0c6d			  
0c6d			include "firmware_general.asm"        ; general support functions  
0c6d			 
0c6d			; word look up 
0c6d			 
0c6d			; in 
0c6d			; a is the index 
0c6d			; hl is pointer start of array 
0c6d			; 
0c6d			; returns 
0c6d			; hl to the word 
0c6d			; 
0c6d			 
0c6d			table_lookup:  
0c6d d5					push de 
0c6e eb					ex de, hl 
0c6f			 
0c6f 6f					ld l, a 
0c70 26 00				ld h, 0 
0c72 29					add hl, hl 
0c73 19					add hl, de 
0c74 7e					ld a, (hl) 
0c75 23					inc hl 
0c76 66					ld h,(hl) 
0c77 6f					ld l, a 
0c78			 
0c78 d1					pop de 
0c79 c9					ret 
0c7a			 
0c7a			; Delay loops 
0c7a			 
0c7a			 
0c7a			 
0c7a			aDelayInMS: 
0c7a c5				push bc 
0c7b 47				ld b,a 
0c7c			msdelay: 
0c7c c5				push bc 
0c7d				 
0c7d			 
0c7d 01 41 00			ld bc,041h 
0c80 cd 98 0c			call delayloop 
0c83 c1				pop bc 
0c84 05				dec b 
0c85 20 f5			jr nz,msdelay 
0c87			 
0c87			;if CPU_CLOCK_8MHZ 
0c87			;msdelay8: 
0c87			;	push bc 
0c87			;	 
0c87			; 
0c87			;	ld bc,041h 
0c87			;	call delayloop 
0c87			;	pop bc 
0c87			;	dec b 
0c87			;	jr nz,msdelay8 
0c87			;endif 
0c87			 
0c87			 
0c87 c1				pop bc 
0c88 c9				ret 
0c89			 
0c89			 
0c89			delay250ms: 
0c89				;push de 
0c89 01 00 40			ld bc, 04000h 
0c8c c3 98 0c			jp delayloop 
0c8f			delay500ms: 
0c8f				;push de 
0c8f 01 00 80			ld bc, 08000h 
0c92 c3 98 0c			jp delayloop 
0c95			delay1s: 
0c95				;push bc 
0c95			   ; Clobbers A, d and e 
0c95 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c98			delayloop: 
0c98 c5			    push bc 
0c99			 
0c99			if BASE_CPM 
0c99				ld bc, CPM_DELAY_TUNE 
0c99			.cpmloop: 
0c99				push bc 
0c99			 
0c99			endif 
0c99			 
0c99			 
0c99			 
0c99			delayloopi: 
0c99			;	push bc 
0c99			;.dl: 
0c99 cb 47		    bit     0,a    	; 8 
0c9b cb 47		    bit     0,a    	; 8 
0c9d cb 47		    bit     0,a    	; 8 
0c9f e6 ff		    and     255  	; 7 
0ca1 0b			    dec     bc      	; 6 
0ca2 79			    ld      a,c     	; 4 
0ca3 b0			    or      b     	; 4 
0ca4 c2 99 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca7			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca7				;pop de 
0ca7			;pop bc 
0ca7			 
0ca7			if BASE_CPM 
0ca7				pop bc 
0ca7				 
0ca7			    dec     bc      	; 6 
0ca7			    ld      a,c     	; 4 
0ca7			    or      b     	; 4 
0ca7			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca7				 
0ca7			 
0ca7			endif 
0ca7			;if CPU_CLOCK_8MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7			 
0ca7			;if CPU_CLOCK_10MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7 c1			    pop bc 
0ca8			 
0ca8 c9				ret 
0ca9			 
0ca9			 
0ca9			 
0ca9			; eof 
# End of file firmware_general.asm
0ca9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca9			; display routines that use the physical hardware abstraction layer 
0ca9			 
0ca9			 
0ca9			; information window 
0ca9			 
0ca9			; pass hl with 1st string to display 
0ca9			; pass de with 2nd string to display 
0ca9			 
0ca9			info_panel: 
0ca9 e5				push hl 
0caa			 
0caa 2a cf fb			ld hl, (display_fb_active) 
0cad e5				push hl    ; future de destination 
0cae 21 b4 fd				ld hl, display_fb0 
0cb1 22 cf fb				ld (display_fb_active), hl 
0cb4			 
0cb4			;	call clear_display 
0cb4			 
0cb4				if BASE_CPM 
0cb4				ld a, '.' 
0cb4				else 
0cb4 3e a5			ld a, 165 
0cb6				endif 
0cb6 cd 1d 0d			call fill_display 
0cb9			 
0cb9			 
0cb9 3e 55			ld a, display_row_3 + 5 
0cbb cd 2b 0d			call str_at_display 
0cbe			 
0cbe e1				pop hl 
0cbf d1				pop de 
0cc0			 
0cc0 e5				push hl 
0cc1			 
0cc1			 
0cc1 3e 2d			ld a, display_row_2 + 5 
0cc3 cd 2b 0d			call str_at_display 
0cc6			 
0cc6			 
0cc6 cd 3b 0d			call update_display 
0cc9 cd 04 20			call next_page_prompt 
0ccc cd 18 0d			call clear_display 
0ccf			 
0ccf				 
0ccf 21 13 fd				ld hl, display_fb1 
0cd2 22 cf fb				ld (display_fb_active), hl 
0cd5 cd 3b 0d			call update_display 
0cd8			 
0cd8 e1				pop hl 
0cd9			 
0cd9 c9				ret 
0cda			 
0cda			 
0cda			 
0cda			 
0cda			; TODO windowing? 
0cda			 
0cda			; TODO scroll line up 
0cda			 
0cda			scroll_up: 
0cda			 
0cda e5				push hl 
0cdb d5				push de 
0cdc c5				push bc 
0cdd			 
0cdd				; get frame buffer  
0cdd			 
0cdd 2a cf fb			ld hl, (display_fb_active) 
0ce0 e5				push hl    ; future de destination 
0ce1			 
0ce1 11 28 00			ld  de, display_cols 
0ce4 19				add hl, de 
0ce5			 
0ce5 d1				pop de 
0ce6			 
0ce6				;ex de, hl 
0ce6 01 9f 00			ld bc, display_fb_len -1  
0ce9			;if DEBUG_FORTH_WORDS 
0ce9			;	DMARK "SCL" 
0ce9			;	CALLMONITOR 
0ce9			;endif	 
0ce9 ed b0			ldir 
0ceb			 
0ceb				; wipe bottom row 
0ceb			 
0ceb			 
0ceb 2a cf fb			ld hl, (display_fb_active) 
0cee 11 a0 00			ld de, display_cols*display_rows 
0cf1 19				add hl, de 
0cf2 06 28			ld b, display_cols 
0cf4 3e 20			ld a, ' ' 
0cf6			.scwipe: 
0cf6 77				ld (hl), a 
0cf7 2b				dec hl 
0cf8 10 fc			djnz .scwipe 
0cfa			 
0cfa				;pop hl 
0cfa			 
0cfa c1				pop bc 
0cfb d1				pop de 
0cfc e1				pop hl 
0cfd			 
0cfd c9				ret 
0cfe			 
0cfe			 
0cfe			;scroll_upo: 
0cfe			;	ld de, display_row_1 
0cfe			 ;	ld hl, display_row_2 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_2 
0cfe			 ;	ld hl, display_row_3 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_3 
0cfe			 ;	ld hl, display_row_4 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			 
0cfe			; TODO clear row 4 
0cfe			 
0cfe			;	ret 
0cfe			 
0cfe				 
0cfe			scroll_down: 
0cfe			 
0cfe e5				push hl 
0cff d5				push de 
0d00 c5				push bc 
0d01			 
0d01				; get frame buffer  
0d01			 
0d01 2a cf fb			ld hl, (display_fb_active) 
0d04			 
0d04 11 9f 00			ld de, display_fb_len - 1 
0d07 19				add hl, de 
0d08			 
0d08 e5			push hl    ; future de destination 
0d09			 
0d09 11 28 00			ld  de, display_cols 
0d0c ed 52			sbc hl, de 
0d0e			 
0d0e			 
0d0e d1				pop de 
0d0f			 
0d0f			;	ex de, hl 
0d0f 01 9f 00			ld bc, display_fb_len -1  
0d12			 
0d12			 
0d12				 
0d12			 
0d12 ed b0			ldir 
0d14			 
0d14				; wipe bottom row 
0d14			 
0d14			 
0d14			;	ld hl, (display_fb_active) 
0d14			;;	ld de, display_cols*display_rows 
0d14			;;	add hl, de 
0d14			;	ld b, display_cols 
0d14			;	ld a, ' ' 
0d14			;.scwiped: 
0d14			;	ld (hl), a 
0d14			;	dec hl 
0d14			;	djnz .scwiped 
0d14			 
0d14				;pop hl 
0d14			 
0d14 c1				pop bc 
0d15 d1				pop de 
0d16 e1				pop hl 
0d17			 
0d17 c9				ret 
0d18			;scroll_down: 
0d18			;	ld de, display_row_4 
0d18			;	ld hl, display_row_3 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_3 
0d18			; 	ld hl, display_row_2 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_2 
0d18			;	ld hl, display_row_1 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;;; TODO clear row 1 
0d18			;	ret 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			; clear active frame buffer 
0d18			 
0d18			clear_display: 
0d18 3e 20			ld a, ' ' 
0d1a c3 1d 0d			jp fill_display 
0d1d			 
0d1d			; fill active frame buffer with a char in A 
0d1d			 
0d1d			fill_display: 
0d1d 06 a0			ld b,display_fb_len 
0d1f 2a cf fb			ld hl, (display_fb_active) 
0d22 77			.fd1:	ld (hl),a 
0d23 23				inc hl 
0d24 10 fc			djnz .fd1 
0d26 23				inc hl 
0d27 3e 00			ld a,0 
0d29 77				ld (hl),a 
0d2a			 
0d2a			 
0d2a c9				ret 
0d2b			; Write string (DE) at pos (A) to active frame buffer 
0d2b			 
0d2b 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0d2e 06 00					ld b,0 
0d30 4f					ld c,a 
0d31 09					add hl,bc 
0d32 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d33 b7			            OR   A              ;Null terminator? 
0d34 c8			            RET  Z              ;Yes, so finished 
0d35 77					ld (hl),a 
0d36 23				inc hl 
0d37 13			            INC  DE             ;Point to next character 
0d38 18 f8		            JR   .sad1     ;Repeat 
0d3a c9					ret 
0d3b			 
0d3b			; using current frame buffer write to physical display 
0d3b			 
0d3b			update_display: 
0d3b e5				push hl 
0d3c 2a cf fb			ld hl, (display_fb_active) 
0d3f cd c6 74			call write_display 
0d42 e1				pop hl 
0d43 c9				ret 
0d44			 
0d44			; TODO scrolling 
0d44			 
0d44			 
0d44			; move cursor right one char 
0d44			cursor_right: 
0d44			 
0d44				; TODO shift right 
0d44				; TODO if beyond max col 
0d44				; TODO       cursor_next_line 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cursor_next_line: 
0d45				; TODO first char 
0d45				; TODO line down 
0d45				; TODO if past last row 
0d45				; TODO    scroll up 
0d45			 
0d45 c9				ret 
0d46			 
0d46			cursor_left: 
0d46				; TODO shift left 
0d46				; TODO if beyond left  
0d46				; TODO     cursor prev line 
0d46				 
0d46 c9				ret 
0d47			 
0d47			cursor_prev_line: 
0d47				; TODO last char 
0d47				; TODO line up 
0d47				; TODO if past first row 
0d47				; TODO   scroll down 
0d47			 
0d47 c9				ret 
0d48			 
0d48			 
0d48			cout: 
0d48				; A - char 
0d48 c9				ret 
0d49			 
0d49			 
0d49			; Display a menu and allow item selection (optional toggle items) 
0d49			; 
0d49			; format: 
0d49			; hl pointer to word array with zero term for items 
0d49			; e.g.    db item1 
0d49			;         db .... 
0d49			;         db 0 
0d49			; 
0d49			; a = starting menu item  
0d49			; 
0d49			; de = pointer item toggle array   (todo) 
0d49			; 
0d49			; returns item selected in a 1-... 
0d49			; returns 0 if back button pressed 
0d49			; 
0d49			; NOTE: Uses system frame buffer to display 
0d49			; 
0d49			; LEFT, Q = go back 
0d49			; RIGHT, SPACE, CR = select 
0d49			; UP, A - Up 
0d49			; DOWN, Z - Down 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			menu: 
0d49			 
0d49					; keep array pointer 
0d49			 
0d49 22 7a fa				ld (store_tmp1), hl 
0d4c 32 78 fa				ld (store_tmp2), a 
0d4f			 
0d4f					; check for key bounce 
0d4f			 
0d4f			if BASE_KEV 
0d4f			 
0d4f cd 11 78		.mbounce:	call cin 
0d52 fe 00				cp 0 
0d54 20 f9				jr nz, .mbounce 
0d56			endif 
0d56					; for ease use ex 
0d56			 
0d56					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d56 21 b4 fd				ld hl, display_fb0 
0d59 22 cf fb				ld (display_fb_active), hl 
0d5c			 
0d5c cd 18 0d		.mloop:		call clear_display 
0d5f cd 3b 0d				call update_display 
0d62			 
0d62					; draw selection id '>' at 1 
0d62			 
0d62					; init start of list display 
0d62			 
0d62 3e 05				ld a, 5 
0d64 32 76 fa				ld (store_tmp3), a   ; display row count 
0d67 3a 78 fa				ld a,( store_tmp2) 
0d6a 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d6d			 
0d6d					 
0d6d			.mitem:	 
0d6d			 
0d6d			 
0d6d 3a 79 fa				ld a,(store_tmp2+1) 
0d70 6f					ld l, a 
0d71 26 00				ld h, 0 
0d73 29					add hl, hl 
0d74 ed 5b 7a fa			ld de, (store_tmp1) 
0d78 19					add hl, de 
0d79 7e					ld a, (hl) 
0d7a 23					inc hl 
0d7b 66					ld h,(hl) 
0d7c 6f					ld l, a 
0d7d			 
0d7d cd 75 0f				call ishlzero 
0d80 28 1a				jr z, .mdone 
0d82			 
0d82 eb					ex de, hl 
0d83 3a 76 fa				ld a, (store_tmp3) 
0d86 cd 2b 0d				call str_at_display 
0d89					 
0d89			 
0d89					; next item 
0d89 3a 79 fa				ld a, (store_tmp2+1) 
0d8c 3c					inc a 
0d8d 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d90			 
0d90			 		; next row 
0d90			 
0d90 3a 76 fa				ld a, (store_tmp3) 
0d93 c6 28				add display_cols 
0d95 32 76 fa				ld (store_tmp3), a 
0d98			 
0d98					; at end of screen? 
0d98			 
0d98 fe 10				cp display_rows*4 
0d9a 20 d1				jr nz, .mitem 
0d9c			 
0d9c			 
0d9c			.mdone: 
0d9c cd 75 0f				call ishlzero 
0d9f 28 08				jr z, .nodn 
0da1			 
0da1 3e 78				ld a, display_row_4 
0da3 11 22 0e				ld de, .mdown 
0da6 cd 2b 0d				call str_at_display 
0da9			 
0da9					; draw options to fill the screens with active item on line 1 
0da9					; if current option is 2 or more then display ^ in top 
0da9			 
0da9 3a 78 fa		.nodn:		ld a, (store_tmp2) 
0dac fe 00				cp 0 
0dae 28 08				jr z, .noup 
0db0			 
0db0 3e 00				ld a, 0 
0db2 11 20 0e				ld de, .mup 
0db5 cd 2b 0d				call str_at_display 
0db8			 
0db8 3e 02		.noup:		ld a, 2 
0dba 11 1e 0e				ld de, .msel 
0dbd cd 2b 0d				call str_at_display 
0dc0			 
0dc0					; if current option + 1 is not null then display V in bottom 
0dc0					; get key 
0dc0 cd 3b 0d				call update_display 
0dc3			 
0dc3			 
0dc3					; handle key 
0dc3			 
0dc3 cd 00 78				call cin_wait 
0dc6			 
0dc6 fe 05				cp KEY_UP 
0dc8 28 2b				jr z, .mgoup 
0dca fe 61				cp 'a' 
0dcc 28 27				jr z, .mgoup 
0dce fe 0a				cp KEY_DOWN 
0dd0 28 32				jr z, .mgod 
0dd2 fe 7a				cp 'z' 
0dd4 28 2e				jr z, .mgod 
0dd6 fe 20				cp ' ' 
0dd8 28 34				jr z, .goend 
0dda fe 0c				cp KEY_RIGHT 
0ddc 28 30				jr z, .goend 
0dde fe 0d				cp KEY_CR 
0de0 28 2c				jr z, .goend 
0de2 fe 71				cp 'q' 
0de4 28 0b				jr z, .goback 
0de6			 
0de6 fe 0b				cp KEY_LEFT 
0de8 28 07				jr z, .goback 
0dea fe 08				cp KEY_BS 
0dec 28 03				jr z, .goback 
0dee c3 5c 0d				jp .mloop 
0df1			 
0df1			.goback: 
0df1 3e 00			ld a, 0 
0df3 18 1d			jr .goend2 
0df5			 
0df5				; move up one 
0df5			.mgoup: 
0df5 3a 78 fa				ld a, (store_tmp2) 
0df8 fe 00				cp 0 
0dfa ca 5c 0d				jp z, .mloop 
0dfd 3d					dec a 
0dfe 32 78 fa				ld (store_tmp2), a 
0e01 c3 5c 0d				jp .mloop 
0e04			 
0e04				; move down one 
0e04			.mgod: 
0e04 3a 78 fa				ld a, (store_tmp2) 
0e07 3c					inc a 
0e08 32 78 fa				ld (store_tmp2), a 
0e0b c3 5c 0d				jp .mloop 
0e0e			 
0e0e			 
0e0e			.goend: 
0e0e					; get selected item number 
0e0e			 
0e0e 3a 78 fa				ld a, (store_tmp2) 
0e11 3c					inc a 
0e12			 
0e12			.goend2: 
0e12 f5					push af 
0e13			 
0e13					; restore active fb 
0e13					; TODO BUG assumes fb1 
0e13			 
0e13 21 13 fd				ld hl, display_fb1 
0e16 22 cf fb				ld (display_fb_active), hl 
0e19			 
0e19					; restore main regs 
0e19			 
0e19			 
0e19 cd 3b 0d				call update_display 
0e1c			 
0e1c f1					pop af 
0e1d			 
0e1d c9				ret 
0e1e			 
0e1e .. 00		.msel:   db ">",0 
0e20 .. 00		.mup:   db "^",0 
0e22 .. 00		.mdown:   db "v",0 
0e24			 
0e24			 
0e24			; eof 
0e24			 
# End of file firmware_display.asm
0e24			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e24			; random number generators 
0e24			 
0e24			 
0e24			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e24			 
0e24			 
0e24			;-----> Generate a random number 
0e24			; output a=answer 0<=a<=255 
0e24			; all registers are preserved except: af 
0e24			random: 
0e24 e5			        push    hl 
0e25 d5			        push    de 
0e26 2a b1 fb		        ld      hl,(randData) 
0e29 ed 5f		        ld      a,r 
0e2b 57			        ld      d,a 
0e2c 5e			        ld      e,(hl) 
0e2d 19			        add     hl,de 
0e2e 85			        add     a,l 
0e2f ac			        xor     h 
0e30 22 b1 fb		        ld      (randData),hl 
0e33 d1			        pop     de 
0e34 e1			        pop     hl 
0e35 c9			        ret 
0e36			 
0e36			 
0e36			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e36			 
0e36			 
0e36			 
0e36			;------LFSR------ 
0e36			;James Montelongo 
0e36			;optimized by Spencer Putt 
0e36			;out: 
0e36			; a = 8 bit random number 
0e36			RandLFSR: 
0e36 21 b7 fb		        ld hl,LFSRSeed+4 
0e39 5e			        ld e,(hl) 
0e3a 23			        inc hl 
0e3b 56			        ld d,(hl) 
0e3c 23			        inc hl 
0e3d 4e			        ld c,(hl) 
0e3e 23			        inc hl 
0e3f 7e			        ld a,(hl) 
0e40 47			        ld b,a 
0e41 cb 13		        rl e  
0e43 cb 12			rl d 
0e45 cb 11		        rl c  
0e47 17				rla 
0e48 cb 13		        rl e  
0e4a cb 12			rl d 
0e4c cb 11		        rl c  
0e4e 17				rla 
0e4f cb 13		        rl e  
0e51 cb 12			rl d 
0e53 cb 11		        rl c  
0e55 17				rla 
0e56 67			        ld h,a 
0e57 cb 13		        rl e  
0e59 cb 12			rl d 
0e5b cb 11		        rl c  
0e5d 17				rla 
0e5e a8			        xor b 
0e5f cb 13		        rl e  
0e61 cb 12			rl d 
0e63 ac			        xor h 
0e64 a9			        xor c 
0e65 aa			        xor d 
0e66 21 b9 fb		        ld hl,LFSRSeed+6 
0e69 11 ba fb		        ld de,LFSRSeed+7 
0e6c 01 07 00		        ld bc,7 
0e6f ed b8		        lddr 
0e71 12			        ld (de),a 
0e72 c9			        ret 
0e73			 
0e73			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e73			 
0e73			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e73			 
0e73			 
0e73			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e73			 
0e73			prng16: 
0e73			;Inputs: 
0e73			;   (seed1) contains a 16-bit seed value 
0e73			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e73			;Outputs: 
0e73			;   HL is the result 
0e73			;   BC is the result of the LCG, so not that great of quality 
0e73			;   DE is preserved 
0e73			;Destroys: 
0e73			;   AF 
0e73			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e73			;160cc 
0e73			;26 bytes 
0e73 2a ab fb		    ld hl,(seed1) 
0e76 44			    ld b,h 
0e77 4d			    ld c,l 
0e78 29			    add hl,hl 
0e79 29			    add hl,hl 
0e7a 2c			    inc l 
0e7b 09			    add hl,bc 
0e7c 22 ab fb		    ld (seed1),hl 
0e7f 2a a9 fb		    ld hl,(seed2) 
0e82 29			    add hl,hl 
0e83 9f			    sbc a,a 
0e84 e6 2d		    and %00101101 
0e86 ad			    xor l 
0e87 6f			    ld l,a 
0e88 22 a9 fb		    ld (seed2),hl 
0e8b 09			    add hl,bc 
0e8c c9			    ret 
0e8d			 
0e8d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8d			 
0e8d			rand32: 
0e8d			;Inputs: 
0e8d			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8d			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8d			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8d			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8d			;   **NOTE: seed2 must be non-zero 
0e8d			;Outputs: 
0e8d			;   HL is the result 
0e8d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8d			;Destroys: 
0e8d			;   AF 
0e8d			;Tested and passes all CAcert tests 
0e8d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8d			;it has a period of 18,446,744,069,414,584,320 
0e8d			;roughly 18.4 quintillion. 
0e8d			;LFSR taps: 0,2,6,7  = 11000101 
0e8d			;291cc 
0e8d			;seed1_0=$+1 
0e8d			;    ld hl,12345 
0e8d			;seed1_1=$+1 
0e8d			;    ld de,6789 
0e8d			;    ld b,h 
0e8d			;    ld c,l 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    inc l 
0e8d			;    add hl,bc 
0e8d			;    ld (seed1_0),hl 
0e8d			;    ld hl,(seed1_1) 
0e8d			;    adc hl,de 
0e8d			;    ld (seed1_1),hl 
0e8d			;    ex de,hl 
0e8d			;seed2_0=$+1 
0e8d			;    ld hl,9876 
0e8d			;seed2_1=$+1 
0e8d			;    ld bc,54321 
0e8d			;    add hl,hl \ rl c \ rl b 
0e8d			;    ld (seed2_1),bc 
0e8d			;    sbc a,a 
0e8d			;    and %11000101 
0e8d			;    xor l 
0e8d			;    ld l,a 
0e8d			;    ld (seed2_0),hl 
0e8d			;    ex de,hl 
0e8d			;    add hl,bc 
0e8d			;    ret 
0e8d			; 
0e8d			 
0e8d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8d			; 20 bytes, 86 cycles (excluding ret) 
0e8d			 
0e8d			; returns   hl = pseudorandom number 
0e8d			; corrupts   a 
0e8d			 
0e8d			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8d			; using the xorshift method: 
0e8d			 
0e8d			; hl ^= hl << 7 
0e8d			; hl ^= hl >> 9 
0e8d			; hl ^= hl << 8 
0e8d			 
0e8d			; some alternative shift triplets which also perform well are: 
0e8d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8d			 
0e8d			;  org 32768 
0e8d			 
0e8d			xrnd: 
0e8d 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0e90 3e 00		  ld a,0 
0e92 bd			  cp l 
0e93 20 02		  jr nz, .xrnd1 
0e95 2e 01		  ld l, 1 
0e97			.xrnd1: 
0e97			 
0e97 7c			  ld a,h 
0e98 1f			  rra 
0e99 7d			  ld a,l 
0e9a 1f			  rra 
0e9b ac			  xor h 
0e9c 67			  ld h,a 
0e9d 7d			  ld a,l 
0e9e 1f			  rra 
0e9f 7c			  ld a,h 
0ea0 1f			  rra 
0ea1 ad			  xor l 
0ea2 6f			  ld l,a 
0ea3 ac			  xor h 
0ea4 67			  ld h,a 
0ea5			 
0ea5 22 af fb		  ld (xrandc),hl 
0ea8			 
0ea8 c9			  ret 
0ea9			;  
0ea9			 
0ea9			 
0ea9			;;;; int maths 
0ea9			 
0ea9			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea9			; Divide 16-bit values (with 16-bit result) 
0ea9			; In: Divide BC by divider DE 
0ea9			; Out: BC = result, HL = rest 
0ea9			; 
0ea9			Div16: 
0ea9 21 00 00		    ld hl,0 
0eac 78			    ld a,b 
0ead 06 08		    ld b,8 
0eaf			Div16_Loop1: 
0eaf 17			    rla 
0eb0 ed 6a		    adc hl,hl 
0eb2 ed 52		    sbc hl,de 
0eb4 30 01		    jr nc,Div16_NoAdd1 
0eb6 19			    add hl,de 
0eb7			Div16_NoAdd1: 
0eb7 10 f6		    djnz Div16_Loop1 
0eb9 17			    rla 
0eba 2f			    cpl 
0ebb 47			    ld b,a 
0ebc 79			    ld a,c 
0ebd 48			    ld c,b 
0ebe 06 08		    ld b,8 
0ec0			Div16_Loop2: 
0ec0 17			    rla 
0ec1 ed 6a		    adc hl,hl 
0ec3 ed 52		    sbc hl,de 
0ec5 30 01		    jr nc,Div16_NoAdd2 
0ec7 19			    add hl,de 
0ec8			Div16_NoAdd2: 
0ec8 10 f6		    djnz Div16_Loop2 
0eca 17			    rla 
0ecb 2f			    cpl 
0ecc 41			    ld b,c 
0ecd 4f			    ld c,a 
0ece c9			ret 
0ecf			 
0ecf			 
0ecf			;http://z80-heaven.wikidot.com/math 
0ecf			; 
0ecf			;Inputs: 
0ecf			;     DE and A are factors 
0ecf			;Outputs: 
0ecf			;     A is not changed 
0ecf			;     B is 0 
0ecf			;     C is not changed 
0ecf			;     DE is not changed 
0ecf			;     HL is the product 
0ecf			;Time: 
0ecf			;     342+6x 
0ecf			; 
0ecf			Mult16: 
0ecf			 
0ecf 06 08		     ld b,8          ;7           7 
0ed1 21 00 00		     ld hl,0         ;10         10 
0ed4 29			       add hl,hl     ;11*8       88 
0ed5 07			       rlca          ;4*8        32 
0ed6 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed8 19			         add hl,de   ;--         -- 
0ed9 10 f9		       djnz $-5      ;13*7+8     99 
0edb c9			ret 
0edc			 
0edc			; 
0edc			; Square root of 16-bit value 
0edc			; In:  HL = value 
0edc			; Out:  D = result (rounded down) 
0edc			; 
0edc			;Sqr16: 
0edc			;    ld de,#0040 
0edc			;    ld a,l 
0edc			;    ld l,h 
0edc			;    ld h,d 
0edc			;    or a 
0edc			;    ld b,8 
0edc			;Sqr16_Loop: 
0edc			;    sbc hl,de 
0edc			;    jr nc,Sqr16_Skip 
0edc			;    add hl,de 
0edc			;Sqr16_Skip: 
0edc			;    ccf 
0edc			;    rl d 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    djnz Sqr16_Loop 
0edc			;    ret 
0edc			; 
0edc			; 
0edc			; Divide 8-bit values 
0edc			; In: Divide E by divider C 
0edc			; Out: A = result, B = rest 
0edc			; 
0edc			Div8: 
0edc af			    xor a 
0edd 06 08		    ld b,8 
0edf			Div8_Loop: 
0edf cb 13		    rl e 
0ee1 17			    rla 
0ee2 91			    sub c 
0ee3 30 01		    jr nc,Div8_NoAdd 
0ee5 81			    add a,c 
0ee6			Div8_NoAdd: 
0ee6 10 f7		    djnz Div8_Loop 
0ee8 47			    ld b,a 
0ee9 7b			    ld a,e 
0eea 17			    rla 
0eeb 2f			    cpl 
0eec c9			    ret 
0eed			 
0eed			; 
0eed			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eed			; In: Multiply A with DE 
0eed			; Out: HL = result 
0eed			; 
0eed			Mult12U: 
0eed 2e 00		    ld l,0 
0eef 87			    add a,a 
0ef0 30 01		    jr nc,Mult12U_NoAdd0 
0ef2 19			    add hl,de 
0ef3			Mult12U_NoAdd0: 
0ef3 29			    add hl,hl 
0ef4 87			    add a,a 
0ef5 30 01		    jr nc,Mult12U_NoAdd1 
0ef7 19			    add hl,de 
0ef8			Mult12U_NoAdd1: 
0ef8 29			    add hl,hl 
0ef9 87			    add a,a 
0efa 30 01		    jr nc,Mult12U_NoAdd2 
0efc 19			    add hl,de 
0efd			Mult12U_NoAdd2: 
0efd 29			    add hl,hl 
0efe 87			    add a,a 
0eff 30 01		    jr nc,Mult12U_NoAdd3 
0f01 19			    add hl,de 
0f02			Mult12U_NoAdd3: 
0f02 29			    add hl,hl 
0f03 87			    add a,a 
0f04 30 01		    jr nc,Mult12U_NoAdd4 
0f06 19			    add hl,de 
0f07			Mult12U_NoAdd4: 
0f07 29			    add hl,hl 
0f08 87			    add a,a 
0f09 30 01		    jr nc,Mult12U_NoAdd5 
0f0b 19			    add hl,de 
0f0c			Mult12U_NoAdd5: 
0f0c 29			    add hl,hl 
0f0d 87			    add a,a 
0f0e 30 01		    jr nc,Mult12U_NoAdd6 
0f10 19			    add hl,de 
0f11			Mult12U_NoAdd6: 
0f11 29			    add hl,hl 
0f12 87			    add a,a 
0f13 d0			    ret nc 
0f14 19			    add hl,de 
0f15 c9			    ret 
0f16			 
0f16			; 
0f16			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f16			; In: Multiply A with DE 
0f16			;      Put lowest value in A for most efficient calculation 
0f16			; Out: HL = result 
0f16			; 
0f16			Mult12R: 
0f16 21 00 00		    ld hl,0 
0f19			Mult12R_Loop: 
0f19 cb 3f		    srl a 
0f1b 30 01		    jr nc,Mult12R_NoAdd 
0f1d 19			    add hl,de 
0f1e			Mult12R_NoAdd: 
0f1e cb 23		    sla e 
0f20 cb 12		    rl d 
0f22 b7			    or a 
0f23 c2 19 0f		    jp nz,Mult12R_Loop 
0f26 c9			    ret 
0f27			 
0f27			; 
0f27			; Multiply 16-bit values (with 32-bit result) 
0f27			; In: Multiply BC with DE 
0f27			; Out: BCHL = result 
0f27			; 
0f27			Mult32: 
0f27 79			    ld a,c 
0f28 48			    ld c,b 
0f29 21 00 00		    ld hl,0 
0f2c 06 10		    ld b,16 
0f2e			Mult32_Loop: 
0f2e 29			    add hl,hl 
0f2f 17			    rla 
0f30 cb 11		    rl c 
0f32 30 07		    jr nc,Mult32_NoAdd 
0f34 19			    add hl,de 
0f35 ce 00		    adc a,0 
0f37 d2 3b 0f		    jp nc,Mult32_NoAdd 
0f3a 0c			    inc c 
0f3b			Mult32_NoAdd: 
0f3b 10 f1		    djnz Mult32_Loop 
0f3d 41			    ld b,c 
0f3e 4f			    ld c,a 
0f3f c9			    ret 
0f40			 
0f40			 
0f40			 
0f40			; 
0f40			; Multiply 8-bit values 
0f40			; In:  Multiply H with E 
0f40			; Out: HL = result 
0f40			; 
0f40			Mult8: 
0f40 16 00		    ld d,0 
0f42 6a			    ld l,d 
0f43 06 08		    ld b,8 
0f45			Mult8_Loop: 
0f45 29			    add hl,hl 
0f46 30 01		    jr nc,Mult8_NoAdd 
0f48 19			    add hl,de 
0f49			Mult8_NoAdd: 
0f49 10 fa		    djnz Mult8_Loop 
0f4b c9			    ret 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			;;http://z80-heaven.wikidot.com/math 
0f4c			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f4c			; 
0f4c			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f4c			;     ld a,16        ;7 
0f4c			;     ld hl,0        ;10 
0f4c			;     jp $+5         ;10 
0f4c			;.DivLoop: 
0f4c			;       add hl,bc    ;-- 
0f4c			;       dec a        ;64 
0f4c			;       jr z,.DivLoopEnd        ;86 
0f4c			; 
0f4c			;       sla e        ;128 
0f4c			;       rl d         ;128 
0f4c			;       adc hl,hl    ;240 
0f4c			;       sbc hl,bc    ;240 
0f4c			;       jr nc,.DivLoop ;23|21 
0f4c			;       inc e        ;-- 
0f4c			;       jp .DivLoop+1 
0f4c			; 
0f4c			;.DivLoopEnd: 
0f4c			 
0f4c			;HL_Div_C: 
0f4c			;Inputs: 
0f4c			;     HL is the numerator 
0f4c			;     C is the denominator 
0f4c			;Outputs: 
0f4c			;     A is the remainder 
0f4c			;     B is 0 
0f4c			;     C is not changed 
0f4c			;     DE is not changed 
0f4c			;     HL is the quotient 
0f4c			; 
0f4c			;       ld b,16 
0f4c			;       xor a 
0f4c			;         add hl,hl 
0f4c			;         rla 
0f4c			;         cp c 
0f4c			;         jr c,$+4 
0f4c			;           inc l 
0f4c			;           sub c 
0f4c			;         djnz $-7 
0f4c			 
0f4c			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f4c			 
0f4c			addatohl: 
0f4c 85			    add   a, l    ; A = A+L 
0f4d 6f			    ld    l, a    ; L = A+L 
0f4e 8c			    adc   a, h    ; A = A+L+H+carry 
0f4f 95			    sub   l       ; A = H+carry 
0f50 67			    ld    h, a    ; H = H+carry 
0f51 c9			ret 
0f52			 
0f52			addatode: 
0f52 83			    add   a, e    ; A = A+L 
0f53 5f			    ld    e, a    ; L = A+L 
0f54 8a			    adc   a, d    ; A = A+L+H+carry 
0f55 93			    sub   e       ; A = H+carry 
0f56 57			    ld    d, a    ; H = H+carry 
0f57 c9			ret 
0f58			 
0f58			 
0f58			addatobc: 
0f58 81			    add   a, c    ; A = A+L 
0f59 4f			    ld    c, a    ; L = A+L 
0f5a 88			    adc   a, b    ; A = A+L+H+carry 
0f5b 91			    sub   c       ; A = H+carry 
0f5c 47			    ld    b, a    ; H = H+carry 
0f5d c9			ret 
0f5e			 
0f5e			subafromhl: 
0f5e			   ; If A=0 do nothing 
0f5e			    ; Otherwise flip A's sign. Since 
0f5e			    ; the upper byte becomes -1, also 
0f5e			    ; substract 1 from H. 
0f5e ed 44		    neg 
0f60 ca 69 0f		    jp    z, Skip 
0f63 25			    dec   h 
0f64			     
0f64			    ; Now add the low byte as usual 
0f64			    ; Two's complement takes care of 
0f64			    ; ensuring the result is correct 
0f64 85			    add   a, l 
0f65 6f			    ld    l, a 
0f66 8c			    adc   a, h 
0f67 95			    sub   l 
0f68 67			    ld    h, a 
0f69			Skip: 
0f69 c9				ret 
0f6a			 
0f6a			 
0f6a			; compare hl and de 
0f6a			; returns:  
0f6a			; if hl = de, z=1, s=0, c0=0 
0f6a			; if hl > de, z=0, s=0, c=0 
0f6a			; if hl < de, z=0, s=1, c=1 
0f6a			cmp16:	 
0f6a b7				or a 
0f6b ed 52			sbc hl,de 
0f6d e0				ret po 
0f6e 7c				ld a,h 
0f6f 1f				rra 
0f70 ee 40			xor 01000000B 
0f72 37				scf 
0f73 8f				adc a,a 
0f74 c9				ret 
0f75			 
0f75			 
0f75			; test if hl contains zero   - A is destroyed 
0f75			 
0f75			ishlzero:    
0f75 b7				or a     ; reset flags 
0f76 7c				ld a, h 
0f77 b5				or l        	 
0f78			 
0f78 c9				ret 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			if FORTH_ENABLE_FLOATMATH 
0f79			;include "float/bbcmath.z80" 
0f79			include "float/lpfpcalc.asm" 
0f79			endif 
0f79			 
0f79			 
0f79			; eof 
0f79			 
# End of file firmware_maths.asm
0f79			include "firmware_strings.asm"   ; string handling  
0f79			 
0f79			 
0f79			; TODO string len 
0f79			; input text string, end on cr with zero term 
0f79			; a offset into frame buffer to start prompt 
0f79			; d is max length 
0f79			; e is display size TODO 
0f79			; c is current cursor position 
0f79			; hl is ptr to where string will be stored 
0f79			 
0f79			 
0f79			; TODO check limit of buffer for new inserts 
0f79			; TODO check insert does not push beyond buffer 
0f79			; TODO scroll in a limited display area 
0f79			; TODO scroll whole screen on page wrap 
0f79			 
0f79			 
0f79			; TODO handle KEY_PREVWORD 
0f79			; TODO handle KEY_NEXTWORD 
0f79			; TODO handle KEY_HOME 
0f79			; TODO handle KEY_END 
0f79			; TODO use LCD cursor? 
0f79			 
0f79 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f7c 81					add c 
0f7d 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f80 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0f83 79					ld a, c 
0f84 cd 4c 0f				call addatohl 
0f87 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f8a 7a					ld a,d 
0f8b 32 69 fe			        ld (input_size), a       ; save length of input area 
0f8e 79					ld a, c 
0f8f 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0f92 7b					ld a,e 
0f93 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f96					 
0f96					 
0f96			 
0f96			;		ld a,(input_ptr) 
0f96			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f96			 
0f96			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f96					; init cursor shape if not set by the cin routines 
0f96 21 c7 fb				ld hl, cursor_shape 
0f99 3e ff				ld a, 255 
0f9b 77					ld (hl), a 
0f9c 23					inc hl 
0f9d 3e 00				ld a, 0 
0f9f 77					ld (hl), a 
0fa0			 
0fa0 3e 0f				ld a, CUR_BLINK_RATE 
0fa2 32 63 fe				ld (input_cur_flash), a 
0fa5 3e 01				ld a, 1 
0fa7 32 62 fe				ld (input_cur_onoff),a 
0faa			 
0faa			;	if DEBUG_INPUT 
0faa			;		push af 
0faa			;		ld a, 'I' 
0faa			;		ld (debug_mark),a 
0faa			;		pop af 
0faa			;		CALLMONITOR 
0faa			;	endif 
0faa			.is1:		; main entry loop 
0faa			 
0faa			 
0faa			 
0faa					; pause 1ms 
0faa			 
0faa 3e 01				ld a, 1 
0fac cd 7a 0c				call aDelayInMS 
0faf			 
0faf					; dec flash counter 
0faf 3a 63 fe				ld a, (input_cur_flash) 
0fb2 3d					dec a 
0fb3 32 63 fe				ld (input_cur_flash), a 
0fb6 fe 00				cp 0 
0fb8 20 0d				jr nz, .nochgstate 
0fba			 
0fba			 
0fba					; change state 
0fba 3a 62 fe				ld a,(input_cur_onoff) 
0fbd ed 44				neg 
0fbf 32 62 fe				ld (input_cur_onoff),a 
0fc2			 
0fc2			 
0fc2					; reset on change of state 
0fc2 3e 0f				ld a, CUR_BLINK_RATE 
0fc4 32 63 fe				ld (input_cur_flash), a 
0fc7			 
0fc7			.nochgstate: 
0fc7					 
0fc7					 
0fc7			 
0fc7					; display cursor  
0fc7			 
0fc7			;		ld hl, (input_start) 
0fc7			;		ld a, (input_cursor) 
0fc7			;		call addatohl 
0fc7			 
0fc7					; get char under cursor and replace with cursor 
0fc7 2a 6c fe		ld hl, (input_ptr) 
0fca			;		ld a, (hl) 
0fca			;		ld (input_under_cursor),a 
0fca			;		ld a, '_' 
0fca			;		ld (hl), a 
0fca			 
0fca					; display string 
0fca			 
0fca ed 5b 6a fe			ld de, (input_start) 
0fce 3a 67 fe				ld a, (input_at_pos) 
0fd1 cd 2b 0d				call str_at_display 
0fd4			;	        call update_display 
0fd4			 
0fd4					; find place to put the cursor 
0fd4			;		add h 
0fd4			;		ld l, display_row_1 
0fd4			;		sub l 
0fd4			; (input_at_pos) 
0fd4					;ld c, a 
0fd4			;		ld a, (input_cursor) 
0fd4			;		ld l, (input_at_pos) 
0fd4			;		;ld b, h 
0fd4			;		add l 
0fd4			;		ld (input_at_cursor),a 
0fd4					;ld l,h 
0fd4			 
0fd4			;		ld h, 0 
0fd4			;		ld l,(input_at_pos) 
0fd4			;		ld a, (input_cursor) 
0fd4			;		call addatohl 
0fd4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd4			;		call subafromhl 
0fd4			;		ld a,l 
0fd4			;		ld (input_at_cursor), a 
0fd4			 
0fd4				if DEBUG_INPUT 
0fd4					ld a, (hardware_diag) 
0fd4					cp 0 
0fd4					jr z, .skip_input_diag 
0fd4			 
0fd4					ld a,(input_at_pos) 
0fd4					ld hl, LFSRSeed 
0fd4					call hexout 
0fd4					ld a, (input_cursor) 
0fd4					ld hl, LFSRSeed+2 
0fd4					call hexout 
0fd4					ld a,(input_at_cursor) 
0fd4					ld hl, LFSRSeed+4 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_onoff) 
0fd4					ld hl, LFSRSeed+6 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_flash) 
0fd4					ld hl, LFSRSeed+8 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_len) 
0fd4					ld hl, LFSRSeed+10 
0fd4					call hexout 
0fd4					ld hl, LFSRSeed+12 
0fd4					ld a, 0 
0fd4					ld (hl),a 
0fd4					ld a, display_row_4 
0fd4					ld de, LFSRSeed 
0fd4					call str_at_display 
0fd4					.skip_input_diag: 
0fd4				endif 
0fd4			 
0fd4					; decide on if we are showing the cursor this time round 
0fd4			 
0fd4 3a 62 fe				ld a, (input_cur_onoff) 
0fd7 fe ff				cp 255 
0fd9 28 13				jr z, .skipcur 
0fdb			 
0fdb			 
0fdb 3a 65 fe				ld a,(input_at_cursor) 
0fde 11 c7 fb				ld de, cursor_shape 
0fe1 cd 2b 0d				call str_at_display 
0fe4			 
0fe4					; save length of current input string 
0fe4 2a 6a fe				ld hl, (input_start) 
0fe7 cd aa 13				call strlenz 
0fea 7d					ld a,l 
0feb 32 5d fe				ld (input_len),a 
0fee			 
0fee			.skipcur: 
0fee			 
0fee cd 3b 0d			        call update_display 
0ff1					 
0ff1			 
0ff1			 
0ff1					; wait 
0ff1				 
0ff1					; TODO loop without wait to flash the cursor and char under cursor	 
0ff1 cd 11 78				call cin    ; _wait 
0ff4			 
0ff4 fe 00				cp 0 
0ff6 ca aa 0f				jp z, .is1 
0ff9			 
0ff9					; get ptr to char to input into 
0ff9			 
0ff9 4f					ld c,a 
0ffa 2a 6a fe				ld hl, (input_start) 
0ffd 3a 58 fe				ld a, (input_cursor) 
1000 cd 4c 0f				call addatohl 
1003 22 6c fe				ld (input_ptr), hl 
1006 79					ld a,c 
1007			 
1007					; replace char under cursor 
1007			 
1007			;		ld hl, (input_ptr) 
1007			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1007			;		ld (hl), a 
1007			 
1007			;	if DEBUG_INPUT 
1007			;		push af 
1007			;		ld a, 'i' 
1007			;		ld (debug_mark),a 
1007			;		pop af 
1007			;		CALLMONITOR 
1007			;	endif 
1007 fe 0e				cp KEY_HOME 
1009 20 0e				jr nz, .iske 
100b			 
100b 3a 67 fe				ld a, (input_at_pos) 
100e 32 65 fe				ld (input_at_cursor),a 
1011 3e 00				ld a, 0 
1013 32 58 fe				ld (input_cursor), a 
1016 c3 aa 0f				jp .is1 
1019					 
1019 fe 0f		.iske:		cp KEY_END 
101b 20 03				jr nz, .isknw 
101d c3 aa 0f				jp .is1 
1020			 
1020 fe 06		.isknw:		cp KEY_NEXTWORD 
1022 20 1b				jr nz, .iskpw 
1024			 
1024 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
1027 7e					ld a,(hl)	 
1028 fe 00				cp 0 
102a ca aa 0f				jp z, .is1    ; end of string 
102d fe 20				cp ' ' 
102f ca aa 0f				jp z, .is1    ; end of word 
1032 23					inc hl 
1033 22 6c fe				ld (input_ptr), hl 
1036 3a 65 fe				ld a, (input_at_cursor) 
1039 3c					inc a 
103a 32 65 fe				ld (input_at_cursor), a 
103d 18 e5				jr .isknwm 
103f			 
103f fe 07		.iskpw:		cp KEY_PREVWORD 
1041 20 1b				jr nz, .iskl 
1043			.iskpwm:	 
1043 2a 6c fe				ld hl, (input_ptr) 
1046 7e					ld a,(hl)	 
1047 fe 00				cp 0  
1049 ca aa 0f				jp z, .is1    ; end of string 
104c fe 20				cp ' ' 
104e ca aa 0f				jp z, .is1    ; end of word 
1051 2b					dec hl 
1052 22 6c fe				ld (input_ptr), hl 
1055 3a 65 fe				ld a, (input_at_cursor) 
1058 3d					dec a 
1059 32 65 fe				ld (input_at_cursor), a 
105c 18 e5				jr .iskpwm 
105e			 
105e			 
105e fe 0b		.iskl:		cp KEY_LEFT 
1060 20 27				jr nz, .isk1 
1062			 
1062 3a 58 fe				ld a, (input_cursor) 
1065			 
1065 fe 00				cp 0 
1067 ca aa 0f				jp z, .is1 		; at start of line to ignore  
106a			 
106a 3d					dec  a 		; TODO check underflow 
106b 32 58 fe				ld (input_cursor), a 
106e			 
106e 2a 6c fe				ld hl, (input_ptr) 
1071 2b					dec hl 
1072 22 6c fe				ld (input_ptr), hl 
1075					 
1075 3a 65 fe				ld a, (input_at_cursor) 
1078 3d					dec a 
1079 32 65 fe				ld (input_at_cursor), a 
107c			 
107c 3e 01				ld a, 1		; show cursor moving 
107e 32 62 fe				ld (input_cur_onoff),a 
1081 3e 0f				ld a, CUR_BLINK_RATE 
1083 32 63 fe				ld (input_cur_flash), a 
1086			 
1086 c3 aa 0f				jp .is1 
1089			 
1089 fe 0c		.isk1:		cp KEY_RIGHT 
108b 20 2a				jr nz, .isk2 
108d			 
108d 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1090 5f					ld e,a 
1091 3a 58 fe				ld a, (input_cursor) 
1094 bb					cp e 
1095 ca aa 0f				jp z, .is1		; at the end of string so dont go right 
1098			 
1098 3c					inc  a 		; TODO check overflow 
1099 32 58 fe				ld (input_cursor), a 
109c			 
109c 3a 65 fe				ld a, (input_at_cursor) 
109f 3c					inc a 
10a0 32 65 fe				ld (input_at_cursor), a 
10a3			 
10a3 2a 6c fe				ld hl, (input_ptr) 
10a6 23					inc hl 
10a7 22 6c fe				ld (input_ptr), hl 
10aa			 
10aa 3e 01				ld a, 1		; show cursor moving 
10ac 32 62 fe				ld (input_cur_onoff),a 
10af 3e 0f				ld a, CUR_BLINK_RATE 
10b1 32 63 fe				ld (input_cur_flash), a 
10b4			 
10b4 c3 aa 0f				jp .is1 
10b7			 
10b7 fe 05		.isk2:		cp KEY_UP 
10b9			 
10b9 20 26				jr nz, .isk3 
10bb			 
10bb					; swap last command with the current on 
10bb			 
10bb					; move cursor to start of string 
10bb 2a 6a fe				ld hl, (input_start) 
10be 22 6c fe				ld (input_ptr), hl 
10c1			 
10c1 3a 67 fe				ld a, (input_at_pos) 
10c4 32 65 fe				ld (input_at_cursor), a 
10c7			 
10c7 3e 00				ld a, 0 
10c9 32 58 fe				ld (input_cursor), a 
10cc					 
10cc					; swap input and last command buffers 
10cc			 
10cc 21 ef f4				ld hl, os_cli_cmd 
10cf 11 ee f5				ld de, os_last_cmd 
10d2 06 ff				ld b, 255 
10d4 7e			.swap1:		ld a, (hl) 
10d5 4f					ld c,a 
10d6 1a					ld a, (de) 
10d7 77					ld (hl), a 
10d8 79					ld a,c 
10d9 12					ld (de),a 
10da 23					inc hl 
10db 13					inc de 
10dc 10 f6				djnz .swap1 
10de			 
10de			 
10de			 
10de			 
10de			 
10de c3 aa 0f				jp .is1 
10e1			 
10e1 fe 08		.isk3:		cp KEY_BS 
10e3 20 3c				jr nz, .isk4 
10e5			 
10e5 3a 58 fe				ld a, (input_cursor) 
10e8			 
10e8 fe 00				cp 0 
10ea ca aa 0f				jp z, .is1 		; at start of line to ignore  
10ed			 
10ed 3d					dec  a 		; TODO check underflow 
10ee 32 58 fe				ld (input_cursor), a 
10f1			 
10f1					; hl is source 
10f1					; de needs to be source - 1 
10f1			 
10f1			;		ld a, 0 
10f1			;		dec hl 
10f1			;		ld (hl), a 
10f1			 
10f1 2a 6c fe				ld hl, (input_ptr) 
10f4 2b					dec hl 
10f5 22 6c fe				ld (input_ptr), hl 
10f8			 
10f8					; shift all data 
10f8			 
10f8 e5					push hl 
10f9 23					inc hl 
10fa d1					pop de 
10fb 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fe 4f					ld c,a 
10ff 06 00				ld b,0 
1101 ed b0				ldir  
1103			 
1103			 
1103			 
1103			 
1103 3a 65 fe				ld a, (input_at_cursor) 
1106 3d					dec a 
1107 32 65 fe				ld (input_at_cursor), a 
110a			 
110a			 
110a 3e 01				ld a, 1		; show cursor moving 
110c 32 62 fe				ld (input_cur_onoff),a 
110f 3e 0f				ld a, CUR_BLINK_RATE 
1111 32 63 fe				ld (input_cur_flash), a 
1114			 
1114					; remove char 
1114 3a 65 fe				ld a, (input_at_cursor) 
1117 3c					inc a 
1118 11 a2 11				ld de,.iblank 
111b cd 2b 0d				call str_at_display 
111e			 
111e c3 aa 0f				jp .is1 
1121			 
1121 fe 0d		.isk4:		cp KEY_CR 
1123 28 6c				jr z, .endinput 
1125			 
1125					; else add the key press to the end 
1125			 
1125 4f					ld c, a			; save key pressed 
1126			 
1126 7e					ld a,(hl)		; get what is currently under char 
1127			 
1127 fe 00				cp 0			; we are at the end of the string 
1129 20 2f				jr nz, .onchar 
112b					 
112b					; add a char to the end of the string 
112b				 
112b 71					ld (hl),c 
112c 23					inc hl 
112d			;		ld a,' ' 
112d			;		ld (hl),a 
112d			;		inc hl 
112d 3e 00				ld a,0 
112f 77					ld (hl),a 
1130 2b					dec hl 
1131			 
1131 3a 58 fe				ld a, (input_cursor) 
1134 3c					inc a				; TODO check max string length and scroll  
1135 32 58 fe				ld (input_cursor), a		; inc cursor pos 
1138							 
1138 3a 65 fe				ld a, (input_at_cursor) 
113b 3c					inc a 
113c 32 65 fe				ld (input_at_cursor), a 
113f			 
113f 2a 6c fe				ld hl, (input_ptr) 
1142 23					inc hl 
1143 22 6c fe				ld (input_ptr), hl 
1146			 
1146 2a 6c fe				ld hl, (input_ptr) 
1149 23					inc hl 
114a 22 6c fe				ld (input_ptr), hl 
114d			;	if DEBUG_INPUT 
114d			;		push af 
114d			;		ld a, '+' 
114d			;		ld (debug_mark),a 
114d			;		pop af 
114d			;		CALLMONITOR 
114d			;	endif 
114d 3e 01				ld a, 1		; show cursor moving 
114f 32 62 fe				ld (input_cur_onoff),a 
1152 3e 0f				ld a, CUR_BLINK_RATE 
1154 32 63 fe				ld (input_cur_flash), a 
1157 c3 aa 0f				jp .is1 
115a					 
115a			 
115a			 
115a					; if on a char then insert 
115a			.onchar: 
115a			 
115a					; TODO over flow check: make sure insert does not blow out buffer 
115a			 
115a					; need to do some maths to use lddr 
115a			 
115a e5					push hl   ; save char pos 
115b c5					push bc 
115c			 
115c 2a 6a fe				ld hl, (input_start) 
115f 3a 5d fe				ld a, (input_len) 
1162 cd 4c 0f				call addatohl  		; end of string 
1165 23					inc hl 
1166 23					inc hl		; past zero term 
1167 e5					push hl 
1168 23					inc hl 
1169 e5					push hl  
116a			 
116a								; start and end of lddr set, now how much to move? 
116a			 
116a							 
116a 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116d 47					ld b,a 
116e 3a 5d fe				ld a,(input_len) 
1171 5f					ld e,a 
1172 90					sub b 
1173 3c					inc a		;?? 
1174 3c					inc a		;?? 
1175 3c					inc a		;?? 
1176			 
1176 06 00				ld b,0 
1178 4f					ld c,a 
1179			 
1179				if DEBUG_INPUT 
1179					push af 
1179					ld a, 'i' 
1179					ld (debug_mark),a 
1179					pop af 
1179			;		CALLMONITOR 
1179				endif 
1179 d1					pop de 
117a e1					pop hl 
117b				if DEBUG_INPUT 
117b					push af 
117b					ld a, 'I' 
117b					ld (debug_mark),a 
117b					pop af 
117b			;		CALLMONITOR 
117b				endif 
117b ed b8				lddr 
117d				 
117d			 
117d			 
117d					; TODO have a key for insert/overwrite mode???? 
117d c1					pop bc 
117e e1					pop hl 
117f 71					ld (hl), c		; otherwise overwrite current char 
1180					 
1180			 
1180			 
1180			 
1180 3a 58 fe				ld a, (input_cursor) 
1183 3c					inc  a 		; TODO check overflow 
1184 32 58 fe				ld (input_cursor), a 
1187			 
1187 3a 65 fe				ld a, (input_at_cursor) 
118a 3c					inc a 
118b 32 65 fe				ld (input_at_cursor), a 
118e			 
118e c3 aa 0f				jp .is1 
1191			 
1191			.endinput:	; TODO look for end of string 
1191			 
1191					; add trailing space for end of token 
1191			 
1191 2a 6a fe				ld hl, (input_start) 
1194 3a 5d fe				ld a,(input_len) 
1197 cd 4c 0f				call addatohl 
119a 3e 20				ld a, ' ' 
119c 77					ld (hl),a 
119d					; TODO eof of parse marker 
119d			 
119d 23					inc hl 
119e 3e 00				ld a, 0 
11a0 77					ld (hl),a 
11a1			 
11a1			 
11a1 c9					ret 
11a2			 
11a2 .. 00		.iblank: db " ",0 
11a4			 
11a4			 
11a4 32 67 fe		input_str_prev:	ld (input_at_pos), a 
11a7 22 6a fe				ld (input_start), hl 
11aa 3e 01				ld a,1			; add cursor 
11ac 77					ld (hl),a 
11ad 23					inc hl 
11ae 3e 00				ld a,0 
11b0 77					ld (hl),a 
11b1 22 6c fe				ld (input_ptr), hl 
11b4 7a					ld a,d 
11b5 32 69 fe				ld (input_size), a 
11b8 3e 00				ld a,0 
11ba 32 58 fe				ld (input_cursor),a 
11bd			.instr1:	 
11bd			 
11bd					; TODO do block cursor 
11bd					; TODO switch cursor depending on the modifer key 
11bd			 
11bd					; update cursor shape change on key hold 
11bd			 
11bd 2a 6c fe				ld hl, (input_ptr) 
11c0 2b					dec hl 
11c1 3a c7 fb				ld a,(cursor_shape) 
11c4 77					ld (hl), a 
11c5			 
11c5					; display entered text 
11c5 3a 67 fe				ld a,(input_at_pos) 
11c8 cd d5 75		            	CALL fLCD_Pos       ;Position cursor to location in A 
11cb ed 5b 6a fe	            	LD   de, (input_start) 
11cf cd f7 75		            	CALL fLCD_Str       ;Display string pointed to by DE 
11d2			 
11d2 cd 11 78				call cin 
11d5 fe 00				cp 0 
11d7 28 e4				jr z, .instr1 
11d9			 
11d9					; proecess keyboard controls first 
11d9			 
11d9 2a 6c fe				ld hl,(input_ptr) 
11dc			 
11dc fe 0d				cp KEY_CR	 ; pressing enter ends input 
11de 28 5a				jr z, .instrcr 
11e0			 
11e0 fe 08				cp KEY_BS 	; back space 
11e2 20 0f				jr nz, .instr2 
11e4					; process back space 
11e4			 
11e4					; TODO stop back space if at start of string 
11e4 2b					dec hl 
11e5 2b					dec hl ; to over write cursor 
11e6 3a c7 fb				ld a,(cursor_shape) 
11e9					;ld a,0 
11e9 77					ld (hl),a 
11ea 23					inc hl 
11eb 3e 20				ld a," " 
11ed 77					ld (hl),a 
11ee 22 6c fe				ld (input_ptr),hl 
11f1					 
11f1			 
11f1 18 ca				jr .instr1 
11f3			 
11f3 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f5 20 06				jr nz, .instr3 
11f7 2b					dec hl 
11f8 22 6c fe				ld (input_ptr),hl 
11fb 18 c0				jr .instr1 
11fd				 
11fd fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11ff 20 06				jr nz, .instr4 
1201 23					inc hl 
1202 22 6c fe				ld (input_ptr),hl 
1205 18 b6				jr .instr1 
1207			 
1207 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1209 20 06				jr nz, .instr5 
120b 2b					dec hl 
120c 22 6c fe				ld (input_ptr),hl 
120f 18 ac				jr .instr1 
1211			 
1211 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1213 20 06				jr nz, .instr6 
1215 2b					dec hl 
1216 22 6c fe				ld (input_ptr),hl 
1219 18 a2				jr .instr1 
121b fe 05		.instr6:        cp KEY_UP      ; recall last command 
121d 20 0b				jr nz, .instrnew 
121f			 
121f 21 c8 f1			ld hl, scratch 
1222 11 ee f5			ld de, os_last_cmd 
1225 cd 43 12			call strcpy 
1228 18 93				jr .instr1 
122a			 
122a			 
122a			.instrnew:	; no special key pressed to see if we have room to store it 
122a			 
122a					; TODO do string size test 
122a			 
122a 2b					dec hl ; to over write cursor 
122b 77					ld (hl),a 
122c 23					inc hl 
122d 3a c7 fb				ld a,(cursor_shape) 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235			 
1235 22 6c fe				ld (input_ptr),hl 
1238					 
1238 18 83				jr .instr1 
123a 2b			.instrcr:	dec hl		; remove cursor 
123b 3e 20				ld a,' '	; TODO add a trailing space for safety 
123d 77					ld (hl),a 
123e 23					inc hl 
123f 3e 00				ld a,0 
1241 77					ld (hl),a 
1242			 
1242			 
1242					; if at end of line scroll up    
1242					; TODO detecting only end of line 4 for scroll up  
1242			 
1242					;ld   
1242			 
1242 c9					ret 
1243			 
1243			 
1243			; strcpy hl = dest, de source 
1243			 
1243 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1244 b7			            OR   A              ;Null terminator? 
1245 c8			            RET  Z              ;Yes, so finished 
1246 1a					ld a,(de) 
1247 77					ld (hl),a 
1248 13			            INC  DE             ;Point to next character 
1249 23					inc hl 
124a 18 f7		            JR   strcpy       ;Repeat 
124c c9					ret 
124d			 
124d			 
124d			; TODO string_at  
124d			; pass string which starts with lcd offset address and then null term string 
124d			 
124d			; TODO string to dec 
124d			; TODO string to hex 
124d			; TODO byte to string hex 
124d			; TODO byte to string dec 
124d			 
124d			 
124d			 
124d			; from z80uartmonitor 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124d			; pass hl for where to put the text 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d c5			hexout:	PUSH BC 
124e f5					PUSH AF 
124f 47					LD B, A 
1250					; Upper nybble 
1250 cb 3f				SRL A 
1252 cb 3f				SRL A 
1254 cb 3f				SRL A 
1256 cb 3f				SRL A 
1258 cd 68 12				CALL tohex 
125b 77					ld (hl),a 
125c 23					inc hl	 
125d					 
125d					; Lower nybble 
125d 78					LD A, B 
125e e6 0f				AND 0FH 
1260 cd 68 12				CALL tohex 
1263 77					ld (hl),a 
1264 23					inc hl	 
1265					 
1265 f1					POP AF 
1266 c1					POP BC 
1267 c9					RET 
1268					 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			tohex: 
1268 e5					PUSH HL 
1269 d5					PUSH DE 
126a 16 00				LD D, 0 
126c 5f					LD E, A 
126d 21 75 12				LD HL, .DATA 
1270 19					ADD HL, DE 
1271 7e					LD A, (HL) 
1272 d1					POP DE 
1273 e1					POP HL 
1274 c9					RET 
1275			 
1275			.DATA: 
1275 30					DEFB	30h	; 0 
1276 31					DEFB	31h	; 1 
1277 32					DEFB	32h	; 2 
1278 33					DEFB	33h	; 3 
1279 34					DEFB	34h	; 4 
127a 35					DEFB	35h	; 5 
127b 36					DEFB	36h	; 6 
127c 37					DEFB	37h	; 7 
127d 38					DEFB	38h	; 8 
127e 39					DEFB	39h	; 9 
127f 41					DEFB	41h	; A 
1280 42					DEFB	42h	; B 
1281 43					DEFB	43h	; C 
1282 44					DEFB	44h	; D 
1283 45					DEFB	45h	; E 
1284 46					DEFB	46h	; F 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1285			;;    subtract $30, if result > 9 then subtract $7 more 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			atohex: 
1285 d6 30				SUB $30 
1287 fe 0a				CP 10 
1289 f8					RET M		; If result negative it was 0-9 so we're done 
128a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
128c c9					RET		 
128d			 
128d			 
128d			 
128d			 
128d			; Get 2 ASCII characters as hex byte from pointer in hl 
128d			 
128d			BYTERD: 
128d 16 00			LD	D,00h		;Set up 
128f cd 97 12			CALL	HEXCON		;Get byte and convert to hex 
1292 87				ADD	A,A		;First nibble so 
1293 87				ADD	A,A		;multiply by 16 
1294 87				ADD	A,A		; 
1295 87				ADD	A,A		; 
1296 57				LD	D,A		;Save hi nibble in D 
1297			HEXCON: 
1297 7e				ld a, (hl)		;Get next chr 
1298 23				inc hl 
1299 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
129b fe 0a			CP	00Ah		;Is it 0-9 ? 
129d 38 02			JR	C,NALPHA	;If so miss next bit 
129f d6 07			SUB	007h		;Else convert alpha 
12a1			NALPHA: 
12a1 b2				OR	D		;Add hi nibble back 
12a2 c9				RET			; 
12a3			 
12a3			 
12a3			; 
12a3			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a3			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a3			; characters (0-9a-f) are accepted. 
12a3			; 
12a3			;get_word        push    af 
12a3			;                call    get_byte        ; Get the upper byte 
12a3			;                ld      h, a 
12a3			;                call    get_byte        ; Get the lower byte 
12a3			;                ld      l, a 
12a3			;                pop     af 
12a3			;                ret 
12a3			; 
12a3			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a3			; the routine get_nibble is used only valid characters are accepted - the  
12a3			; input routine only accepts characters 0-9a-f. 
12a3			; 
12a3 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a4 7e					ld a,(hl) 
12a5 23					inc hl 
12a6 cd cb 12		                call    nibble2val      ; Get upper nibble 
12a9 cb 07		                rlc     a 
12ab cb 07		                rlc     a 
12ad cb 07		                rlc     a 
12af cb 07		                rlc     a 
12b1 47			                ld      b, a            ; Save upper four bits 
12b2 7e					ld a,(hl) 
12b3 cd cb 12		                call    nibble2val      ; Get lower nibble 
12b6 b0			                or      b               ; Combine both nibbles 
12b7 c1			                pop     bc              ; Restore B (and C) 
12b8 c9			                ret 
12b9			; 
12b9			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b9			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b9			; to the serial line interface. The lower 4 bits of A contain the value of  
12b9			; that particular digit. 
12b9			; 
12b9			;get_nibble      ld a,(hl)           ; Read a character 
12b9			;                call    to_upper        ; Convert to upper case 
12b9			;                call    is_hex          ; Was it a hex digit? 
12b9			;                jr      nc, get_nibble  ; No, get another character 
12b9			 ;               call    nibble2val      ; Convert nibble to value 
12b9			 ;               call    print_nibble 
12b9			 ;               ret 
12b9			; 
12b9			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b9			; A valid hexadecimal digit is denoted by a set C flag. 
12b9			; 
12b9			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b9			;                ret     nc              ; Yes 
12b9			;                cp      '0'             ; Less than '0'? 
12b9			;                jr      nc, is_hex_1    ; No, continue 
12b9			;                ccf                     ; Complement carry (i.e. clear it) 
12b9			;                ret 
12b9			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b9			;                ret     c               ; Yes 
12b9			;                cp      'A'             ; Less than 'A'? 
12b9			;                jr      nc, is_hex_2    ; No, continue 
12b9			;                ccf                     ; Yes - clear carry and return 
12b9			;                ret 
12b9			;is_hex_2        scf                     ; Set carry 
12b9			;                ret 
12b9			; 
12b9			; Convert a single character contained in A to upper case: 
12b9			; 
12b9 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12bb d8			                ret     c 
12bc fe 7b		                cp      'z' + 1         ; > 'z'? 
12be d0			                ret     nc              ; Nothing to do, either 
12bf e6 5f		                and     $5f             ; Convert to upper case 
12c1 c9			                ret 
12c2			 
12c2			 
12c2			to_lower: 
12c2			 
12c2			   ; if char is in [A-Z] make it lower case 
12c2			 
12c2			   ; enter : a = char 
12c2			   ; exit  : a = lower case char 
12c2			   ; uses  : af 
12c2			 
12c2 fe 41		   cp 'A' 
12c4 d8			   ret c 
12c5			    
12c5 fe 5b		   cp 'Z'+1 
12c7 d0			   ret nc 
12c8			    
12c8 f6 20		   or $20 
12ca c9			   ret 
12cb			 
12cb			; 
12cb			; Expects a hexadecimal digit (upper case!) in A and returns the 
12cb			; corresponding value in A. 
12cb			; 
12cb fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12cd 38 02		                jr      c, nibble2val_1 ; Yes 
12cf d6 07		                sub     7               ; Adjust for A-F 
12d1 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d3 e6 0f		                and     $f              ; Only return lower 4 bits 
12d5 c9			                ret 
12d6			; 
12d6			; Print_nibble prints a single hex nibble which is contained in the lower  
12d6			; four bits of A: 
12d6			; 
12d6			;print_nibble    push    af              ; We won't destroy the contents of A 
12d6			;                and     $f              ; Just in case... 
12d6			;                add     a, '0'             ; If we have a digit we are done here. 
12d6			;                cp      '9' + 1         ; Is the result > 9? 
12d6			;                jr      c, print_nibble_1 
12d6			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d6			;print_nibble_1  call    putc            ; Print the nibble and 
12d6			;                pop     af              ; restore the original value of A 
12d6			;                ret 
12d6			;; 
12d6			;; Send a CR/LF pair: 
12d6			; 
12d6			;crlf            push    af 
12d6			;                ld      a, cr 
12d6			;                call    putc 
12d6			;                ld      a, lf 
12d6			;                call    putc 
12d6			;                pop     af 
12d6			;                ret 
12d6			; 
12d6			; Print_word prints the four hex digits of a word to the serial line. The  
12d6			; word is expected to be in HL. 
12d6			; 
12d6			;print_word      push    hl 
12d6			;                push    af 
12d6			;                ld      a, h 
12d6			;                call    print_byte 
12d6			;                ld      a, l 
12d6			;                call    print_byte 
12d6			;                pop     af 
12d6			;                pop     hl 
12d6			;                ret 
12d6			; 
12d6			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d6			; The byte to be printed is expected to be in A. 
12d6			; 
12d6			;print_byte      push    af              ; Save the contents of the registers 
12d6			;                push    bc 
12d6			;                ld      b, a 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                call    print_nibble    ; Print high nibble 
12d6			;                ld      a, b 
12d6			;                call    print_nibble    ; Print low nibble 
12d6			;                pop     bc              ; Restore original register contents 
12d6			;                pop     af 
12d6			;                ret 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			fourehexhl:  
12d6 7e				ld a,(hl) 
12d7 cd 85 12			call atohex 
12da cb 3f				SRL A 
12dc cb 3f				SRL A 
12de cb 3f				SRL A 
12e0 cb 3f				SRL A 
12e2 47				ld b, a 
12e3 23				inc hl 
12e4 7e				ld a,(hl) 
12e5 23				inc hl 
12e6 cd 85 12			call atohex 
12e9 80				add b 
12ea 57				ld d,a 
12eb 7e				ld a,(hl) 
12ec cd 85 12			call atohex 
12ef cb 3f				SRL A 
12f1 cb 3f				SRL A 
12f3 cb 3f				SRL A 
12f5 cb 3f				SRL A 
12f7 47				ld b, a 
12f8 23				inc hl 
12f9 7e				ld a,(hl) 
12fa 23				inc hl 
12fb cd 85 12			call atohex 
12fe 80				add b 
12ff 5f				ld e, a 
1300 d5				push de 
1301 e1				pop hl 
1302 c9				ret 
1303			 
1303			; pass hl. returns z set if the byte at hl is a digit 
1303			;isdigithl:  
1303			;	push bc 
1303			;	ld a,(hl) 
1303			;	cp ':' 
1303			;	jr nc, .isdf 		; > 
1303			;	cp '0' 
1303			;	jr c, .isdf		; < 
1303			; 
1303			;	; TODO find a better way to set z 
1303			; 
1303			;	ld b,a 
1303			;	cp b 
1303			;	pop bc 
1303			;	ret 
1303			; 
1303			;.isdf:	; not digit so clear z 
1303			; 
1303			;	; TODO find a better way to unset z 
1303			; 
1303			;	ld b,a 
1303			;	inc b 
1303			;	cp b 
1303			; 
1303			;	pop bc 
1303			;	ret 
1303				 
1303				 
1303			 
1303			 
1303			; pass hl as the four byte address to load 
1303			 
1303			get_word_hl:  
1303 e5				push hl 
1304 cd a3 12			call get_byte 
1307				 
1307 47				ld b, a 
1308			 
1308 e1				pop hl 
1309 23				inc hl 
130a 23				inc hl 
130b			 
130b			; TODO not able to handle a-f  
130b 7e				ld a,(hl) 
130c			;	;cp ':' 
130c			;	cp 'g' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp 'G' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp '0' 
130c			;	jr c, .single_byte_hl		; < 
130c			 
130c				;call isdigithl 
130c fe 00			cp 0 
130e 28 06			jr z, .single_byte_hl 
1310			 
1310			.getwhln:   ; hex word so get next byte 
1310			 
1310 cd a3 12			call get_byte 
1313 6f				ld l, a 
1314 60				ld h,b 
1315 c9				ret 
1316 68			.single_byte_hl:   ld l,b 
1317 26 00				ld h,0 
1319 c9					ret 
131a			 
131a			 
131a			 
131a			 
131a 21 a3 1d			ld hl,asc+1 
131d			;	ld a, (hl) 
131d			;	call nibble2val 
131d cd a3 12			call get_byte 
1320			 
1320			;	call fourehexhl 
1320 32 fc f1			ld (scratch+52),a 
1323				 
1323 21 fa f1			ld hl,scratch+50 
1326 22 eb f4			ld (os_cur_ptr),hl 
1329			 
1329 c9				ret 
132a			 
132a			 
132a			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
132a			 
132a			; Decimal Unsigned Version 
132a			 
132a			;Number in a to decimal ASCII 
132a			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
132a			;Example: display a=56 as "056" 
132a			;input: a = number 
132a			;Output: a=0,value of a in the screen 
132a			;destroys af,bc (don't know about hl and de) 
132a			DispAToASCII: 
132a 0e 9c			ld	c,-100 
132c cd 36 13			call	.Na1 
132f 0e f6			ld	c,-10 
1331 cd 36 13			call	.Na1 
1334 0e ff			ld	c,-1 
1336 06 2f		.Na1:	ld	b,'0'-1 
1338 04			.Na2:	inc	b 
1339 81				add	a,c 
133a 38 fc			jr	c,.Na2 
133c 91				sub	c		;works as add 100/10/1 
133d f5				push af		;safer than ld c,a 
133e 78				ld	a,b		;char is in b 
133f			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133f f1				pop af		;safer than ld a,c 
1340 c9				ret 
1341			 
1341			; Decimal Signed Version 
1341			 
1341			; DispA 
1341			; -------------------------------------------------------------- 
1341			; Converts a signed integer value to a zero-terminated ASCII 
1341			; string representative of that value (using radix 10). 
1341			; -------------------------------------------------------------- 
1341			; INPUTS: 
1341			;     HL     Value to convert (two's complement integer). 
1341			;     DE     Base address of string destination. (pointer). 
1341			; -------------------------------------------------------------- 
1341			; OUTPUTS: 
1341			;     None 
1341			; -------------------------------------------------------------- 
1341			; REGISTERS/MEMORY DESTROYED 
1341			; AF HL 
1341			; -------------------------------------------------------------- 
1341			 
1341			;DispHLToASCII: 
1341			;   push    de 
1341			;   push    bc 
1341			; 
1341			;; Detect sign of HL. 
1341			;    bit    7, h 
1341			;    jr     z, ._DoConvert 
1341			; 
1341			;; HL is negative. Output '-' to string and negate HL. 
1341			;    ld     a, '-' 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			; 
1341			;; Negate HL (using two's complement) 
1341			;    xor    a 
1341			;    sub    l 
1341			;    ld     l, a 
1341			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1341			;    sbc    a, h 
1341			;    ld     h, a 
1341			; 
1341			;; Convert HL to digit characters 
1341			;._DoConvert: 
1341			;    ld     b, 0     ; B will count character length of number 
1341			;-   ld     a, 10 
1341			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1341			;    push   af 
1341			;    inc    b 
1341			;    ld     a, h 
1341			;    or     l 
1341			;    jr     nz, - 
1341			; 
1341			;; Retrieve digits from stack 
1341			;-   pop    af 
1341			;    or     $30 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			;    djnz   - 
1341			; 
1341			;; Terminate string with NULL 
1341			;    xor    a 
1341			;    ld     (de), a 
1341			; 
1341			;    pop    bc 
1341			;    pop    de 
1341			;    ret 
1341			 
1341			;Comments 
1341			; 
1341			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1341			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1341			;    Note that the output string will not be fixed-width. 
1341			; 
1341			;Example Usage 
1341			; 
1341			;    ld    hl, -1004 
1341			;    ld    de, OP1 
1341			;    call  DispA 
1341			;    ld    hl, OP1 
1341			;    syscall  PutS 
1341			 
1341			 
1341			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1341			 
1341			 
1341			;Converts an ASCII string to an unsigned 16-bit integer 
1341			;Quits when it reaches a non-decimal digit 
1341			 
1341			string_to_uint16: 
1341			atoui_16: 
1341			;Input: 
1341			;     DE points to the string 
1341			;Outputs: 
1341			;     HL is the result 
1341			;     A is the 8-bit value of the number 
1341			;     DE points to the byte after the number 
1341			;Destroys: 
1341			;     BC 
1341			;       if the string is non-empty, BC is HL/10 
1341			;Size:  24 bytes 
1341			;Speed: 42+d(104+{0,9}) 
1341			;       d is the number of digits in the number 
1341			;       max is 640 cycles for a 5 digit number 
1341			;Assuming no leading zeros: 
1341			;1 digit:  146cc 
1341			;2 digit:  250cc 
1341			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1341			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1341			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1341			;avg: 544.81158447265625cc (544+13297/16384) 
1341			;=============================================================== 
1341 21 00 00		  ld hl,0 
1344			.u16a: 
1344 1a			  ld a,(de) 
1345 d6 30		  sub 30h 
1347 fe 0a		  cp 10 
1349 d0			  ret nc 
134a 13			  inc de 
134b 44			  ld b,h 
134c 4d			  ld c,l 
134d 29			  add hl,hl 
134e 29			  add hl,hl 
134f 09			  add hl,bc 
1350 29			  add hl,hl 
1351 85			  add a,l 
1352 6f			  ld l,a 
1353 30 ef		  jr nc,.u16a 
1355 24			  inc h 
1356 c3 44 13		  jp .u16a 
1359			 
1359			 
1359			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1359			 
1359			;written by Zeda 
1359			;Converts a 16-bit unsigned integer to an ASCII string. 
1359			 
1359			uitoa_16: 
1359			;Input: 
1359			;   DE is the number to convert 
1359			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1359			;Output: 
1359			;   HL points to the null-terminated ASCII string 
1359			;      NOTE: This isn't necessarily the same as the input HL. 
1359 d5			  push de 
135a c5			  push bc 
135b f5			  push af 
135c eb			  ex de,hl 
135d			 
135d 01 f0 d8		  ld bc,-10000 
1360 3e 2f		  ld a,'0'-1 
1362 3c			  inc a 
1363 09			  add hl,bc  
1364 38 fc		   jr c,$-2 
1366 12			  ld (de),a 
1367 13			  inc de 
1368			 
1368 01 e8 03		  ld bc,1000 
136b 3e 3a		  ld a,'9'+1 
136d 3d			  dec a  
136e 09			  add hl,bc  
136f 30 fc		   jr nc,$-2 
1371 12			  ld (de),a 
1372 13			  inc de 
1373			 
1373 01 9c ff		  ld bc,-100 
1376 3e 2f		  ld a,'0'-1 
1378 3c			  inc a  
1379 09			  add hl,bc  
137a 38 fc		   jr c,$-2 
137c 12			  ld (de),a 
137d 13			  inc de 
137e			 
137e 7d			  ld a,l 
137f 26 3a		  ld h,'9'+1 
1381 25			  dec h  
1382 c6 0a		  add a,10  
1384 30 fb		   jr nc,$-3 
1386 c6 30		  add a,'0' 
1388 eb			  ex de,hl 
1389 72			  ld (hl),d 
138a 23			  inc hl 
138b 77			  ld (hl),a 
138c 23			  inc hl 
138d 36 00		  ld (hl),0 
138f			 
138f			;Now strip the leading zeros 
138f 0e fa		  ld c,-6 
1391 09			  add hl,bc 
1392 3e 30		  ld a,'0' 
1394 23			  inc hl  
1395 be			  cp (hl)  
1396 28 fc		  jr z,$-2 
1398			 
1398			;Make sure that the string is non-empty! 
1398 7e			  ld a,(hl) 
1399 b7			  or a 
139a 20 01		  jr nz,.atoub 
139c 2b			  dec hl 
139d			.atoub: 
139d			 
139d f1			  pop af 
139e c1			  pop bc 
139f d1			  pop de 
13a0 c9			  ret 
13a1			 
13a1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
13a1			 
13a1			toUpper: 
13a1			;A is the char. 
13a1			;If A is a lowercase letter, this sets it to the matching uppercase 
13a1			;18cc or 30cc or 41cc 
13a1			;avg: 26.75cc 
13a1 fe 61		  cp 'a' 
13a3 d8			  ret c 
13a4 fe 7b		  cp 'z'+1 
13a6 d0			  ret nc 
13a7 d6 20		  sub 'a'-'A' 
13a9 c9			  ret 
13aa			 
13aa			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13aa			 
13aa			; String Length 
13aa			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13aa			 
13aa			; Get the length of the null-terminated string starting at $8000 hl 
13aa			;    LD     HL, $8000 
13aa			 
13aa			strlenz: 
13aa			 
13aa af			    XOR    A               ; Zero is the value we are looking for. 
13ab 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13ac 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13ad			                           ; 65, 536 bytes (the entire addressable memory space). 
13ad ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13af			 
13af			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13af 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13b0 6f			    LD     L, A             ; number of bytes 
13b1 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b3 2b			    DEC    HL              ; Compensate for null. 
13b4 c9				ret 
13b5			 
13b5			; Get the length of the A terminated string starting at $8000 hl 
13b5			;    LD     HL, $8000 
13b5			 
13b5			strlent: 
13b5			 
13b5			                  ; A is the value we are looking for. 
13b5 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b7 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b9			                           ; 65, 536 bytes (the entire addressable memory space). 
13b9 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13bb			 
13bb			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13bb 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13bd 2e 00		    LD     L, 0             ; number of bytes 
13bf ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13c1 2b			    DEC    HL              ; Compensate for null. 
13c2 c9				ret 
13c3			 
13c3			 
13c3			;Comparing Strings 
13c3			 
13c3			;IN    HL     Address of string1. 
13c3			;      DE     Address of string2. 
13c3			 
13c3			; doc given but wrong??? 
13c3			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c3			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c3			; tested 
13c3			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c3			 
13c3			strcmp_old: 
13c3 e5			    PUSH   HL 
13c4 d5			    PUSH   DE 
13c5			 
13c5 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c6 be			    CP     (HL)            ; (want to minimize work). 
13c7 38 01		    JR     C, Str1IsBigger 
13c9 7e			    LD     A, (HL) 
13ca			 
13ca			Str1IsBigger: 
13ca 4f			    LD     C, A             ; Put length in BC 
13cb 06 00		    LD     B, 0 
13cd 13			    INC    DE              ; Increment pointers to meat of string. 
13ce 23			    INC    HL 
13cf			 
13cf			CmpLoop: 
13cf 1a			    LD     A, (DE)          ; Compare bytes. 
13d0 ed a1		    CPI 
13d2 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d4 13			    INC    DE              ; Update pointer. 
13d5 ea cf 13		    JP     PE, CmpLoop 
13d8			 
13d8 d1			    POP    DE 
13d9 e1			    POP    HL 
13da 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13db be			    CP     (HL) 
13dc c9			    RET 
13dd			 
13dd			NoMatch: 
13dd 2b			    DEC    HL 
13de be			    CP     (HL)            ; Compare again to affect carry. 
13df d1			    POP    DE 
13e0 e1			    POP    HL 
13e1 c9			    RET 
13e2			 
13e2			;; test strmp 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr z, .z1 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z1: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr z, .z2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr c, .c1 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c1: 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr c, .c2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;	NEXTW 
13e2			;.str1:   db "string1",0 
13e2			;.str2:   db "string2",0 
13e2			 
13e2			; only care about direct match or not 
13e2			; hl and de strings 
13e2			; zero set if the same 
13e2			 
13e2			strcmp: 
13e2 1a				ld a, (de) 
13e3 be				cp (hl) 
13e4 28 02			jr z, .ssame 
13e6 b7				or a 
13e7 c9				ret 
13e8			 
13e8			.ssame:  
13e8 fe 00			cp 0 
13ea c8				ret z 
13eb			 
13eb 23				inc hl 
13ec 13				inc de 
13ed 18 f3			jr strcmp 
13ef				 
13ef				 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			; eof 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
# End of file firmware_strings.asm
13ef			include "firmware_memory.asm"   ; malloc and free  
13ef			 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			.mallocsize: db "Wants malloc >256",0 
13ef			.mallocasize: db "MALLOC gives >256",0 
13ef			.malloczero: db "MALLOC gives zero",0 
13ef			 
13ef			malloc_guard_zerolen: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef				ld de, 0 
13ef			        call cmp16 
13ef				jr nz, .lowalloz 
13ef			 
13ef				push hl 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .malloczero 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef			.lowalloz: 
13ef			 
13ef			 
13ef				pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_entry: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowalloc 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocsize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdone 
13ef			.lowalloc: 
13ef			 
13ef			 
13ef				pop hl 
13ef			.lowdone:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_exit: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowallocx 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocasize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdonex 
13ef			.lowallocx: 
13ef			 
13ef				pop hl 
13ef			.lowdonex:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			endif 
13ef			 
13ef			if MALLOC_2 
13ef			; Z80 Malloc and Free Functions 
13ef			 
13ef			; Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc: 
13ef				 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_entry 
13ef			endif 
13ef			 
13ef			 
13ef			 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "mal" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of size into A 
13ef			    or h               ; Check if size is zero 
13ef			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ef			 
13ef			    ; Allocate memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma1" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    call malloc_internal ; Call internal malloc function 
13ef			    pop af             ; Restore AF register 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret                ; Return 
13ef			 
13ef			; Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free: 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of pointer into A 
13ef			    or h               ; Check if pointer is NULL 
13ef			    jp z, free_exit    ; If pointer is NULL, exit 
13ef			 
13ef			    ; Free memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef			    call free_internal  ; Call internal free function 
13ef			    pop af             ; Restore AF register 
13ef			    ret                ; Return 
13ef			 
13ef			; Internal Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc_internal: 
13ef			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to requested size 
13ef			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			 
13ef			    ; Search for free memory block 
13ef			    ld de, (heap_end)  ; Load end of heap into DE 
13ef			    ld bc, 0           ; Initialize counter 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			malloc_search_loop: 
13ef			    ; Check if current block is free 
13ef			    ld a, (hl)         ; Load current block's status (free or used) 
13ef			    cp 0               ; Compare with zero (free) 
13ef			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ef			 
13ef			    ; Check if current block is large enough 
13ef			    ld a, (hl+1)       ; Load high byte of block size 
13ef			    cp l               ; Compare with low byte of requested size 
13ef			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ef			 
13ef			    ld a, (hl+2)       ; Load low byte of block size 
13ef			    cp h               ; Compare with high byte of requested size 
13ef			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ef			 
13ef			    ; Mark block as used 
13ef			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ef			 
13ef			    ; Calculate remaining space in block 
13ef			    ld bc, 0           ; Clear BC 
13ef			    add hl, bc         ; Increment HL to point to start of data block 
13ef			    add hl, de         ; HL = HL + DE (total size) 
13ef			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to start of data block 
13ef			 
13ef			    ; Save pointer to allocated block in HL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma5" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			malloc_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3           ; Size of management overhead 
13ef			    add hl, bc         ; Move to the next block 
13ef			    inc de             ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e            ; Load low byte of heap end address 
13ef			    cp (hl)            ; Compare with low byte of current address 
13ef			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ef			    ld a, d            ; Load high byte of heap end address 
13ef			    cp 0               ; Check if it's zero (end of memory) 
13ef			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, allocation failed 
13ef			    xor a              ; Set result to NULL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma6" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			malloc_exit: 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma7" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			; Internal Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free_internal: 
13ef			    ld de, (heap_start) ; Load start of heap into DE 
13ef			    ld bc, 0            ; Initialize counter 
13ef			 
13ef			free_search_loop: 
13ef			    ; Check if current block contains the pointer 
13ef			    ld a, l             ; Load low byte of pointer 
13ef			    cp (hl+1)           ; Compare with high byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			    ld a, h             ; Load high byte of pointer 
13ef			    cp (hl+2)           ; Compare with low byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			 
13ef			    ; Mark block as free 
13ef			    ld (hl), 0          ; Set status byte to indicate free block 
13ef			    ret                 ; Return 
13ef			 
13ef			free_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3            ; Size of management overhead 
13ef			    add hl, bc          ; Move to the next block 
13ef			    inc de              ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e             ; Load low byte of heap end address 
13ef			    cp (hl)             ; Compare with low byte of current address 
13ef			    jr nz, free_search_loop  ; If not equal, continue searching 
13ef			    ld a, d             ; Load high byte of heap end address 
13ef			    cp 0                ; Check if it's zero (end of memory) 
13ef			    jr nz, free_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, pointer is not found in heap 
13ef			    ret 
13ef			 
13ef			free_exit: 
13ef			    ret                 ; Return 
13ef			 
13ef			; Define heap start and end addresses 
13ef			;heap_start:    .dw 0xC000   ; Start of heap 
13ef			;heap_end:      .dw 0xE000   ; End of heap 
13ef			 
13ef			endif 
13ef			 
13ef			 
13ef			if MALLOC_1 
13ef			 
13ef			 
13ef			 
13ef			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ef			 
13ef			;moved to firmware.asm 
13ef			;heap_start        .equ  0x9000      ; Starting address of heap 
13ef			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ef			 
13ef			;      .org 0 
13ef			;      jp    main 
13ef			 
13ef			 
13ef			;      .org  0x100 
13ef			;main: 
13ef			;      ld    HL, 0x8100 
13ef			;      ld    SP, HL 
13ef			; 
13ef			;      call  heap_init 
13ef			; 
13ef			;      ; Make some allocations 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9004 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9014 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9024 
13ef			; 
13ef			;      ; Free some allocations 
13ef			;      ld    HL, 0x9014 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9004 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9024 
13ef			;      call  free 
13ef			; 
13ef			; 
13ef			;      halt 
13ef			 
13ef			 
13ef			;------------------------------------------------------------------------------ 
13ef			;     heap_init                                                               : 
13ef			;                                                                             : 
13ef			; Description                                                                 : 
13ef			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ef			;                                                                             : 
13ef			;     The heap is maintained as a linked list, starting with an initial       : 
13ef			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ef			;     the first free block in the heap. Each block then points to the next    : 
13ef			;     free block within the heap, and the free list ends at the first block   : 
13ef			;     with a null pointer to the next free block.                             : 
13ef			;                                                                             : 
13ef			; Parameters                                                                  : 
13ef			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ef			;     address of the heap and its size are required, along with a memory      : 
13ef			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ef			;     principally stores a pointer to the first free block in the heap.       : 
13ef			;                                                                             : 
13ef			; Returns                                                                     : 
13ef			;     Nothing                                                                 : 
13ef			;------------------------------------------------------------------------------ 
13ef			heap_init: 
13ef e5			      push  HL 
13f0			 
13f0			      ; Initialise free list struct 
13f0 21 0e 80		      ld    HL, heap_start 
13f3 22 0a 80		      ld    (free_list), HL 
13f6 21 00 00		      ld    HL, 0 
13f9 22 0c 80		      ld    (free_list+2), HL 
13fc			 
13fc			      ; Insert first free block at bottom of heap, consumes entire heap 
13fc 21 aa f1		      ld    HL, heap_start+heap_size-4 
13ff 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1402 21 9c 71		      ld    HL, heap_size-4 
1405 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1408			 
1408			      ; Insert end of free list block at top of heap - two null words will 
1408			      ; terminate the free list 
1408 21 00 00		      ld    HL, 0 
140b 22 ac f1		      ld    (heap_start+heap_size-2), HL 
140e 22 aa f1		      ld    (heap_start+heap_size-4), HL 
1411			 
1411 e1			      pop   HL 
1412			 
1412 c9			      ret 
1413			 
1413			 
1413			;------------------------------------------------------------------------------ 
1413			;     malloc                                                                  : 
1413			;                                                                             : 
1413			; Description                                                                 : 
1413			;     Allocates the wanted space from the heap and returns the address of the : 
1413			;     first useable byte of the allocation.                                   : 
1413			;                                                                             : 
1413			;     Allocations can happen in one of two ways:                              : 
1413			;                                                                             : 
1413			;     1. A free block may be found which is the exact size wanted. In this    : 
1413			;        case the block is removed from the free list and retuedn to the      : 
1413			;        caller.                                                              : 
1413			;     2. A free block may be found which is larger than the size wanted. In   : 
1413			;        this case, the larger block is split into two. The first portion of  : 
1413			;        this block will become the requested space by the malloc call and    : 
1413			;        is returned to the caller. The second portion becomes a new free     : 
1413			;        block, and the free list is adjusted to maintain continuity via this : 
1413			;        newly created block.                                                 : 
1413			;                                                                             : 
1413			;     malloc does not set any initial value in the allocated space, the       : 
1413			;     caller is required to do this as required.                              : 
1413			;                                                                             : 
1413			;     This implementation of malloc uses the stack exclusively, and is        : 
1413			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1413			;     advisable to disable interrupts before calling malloc, and recommended  : 
1413			;     to avoid the use of malloc inside ISRs in general.                      : 
1413			;                                                                             : 
1413			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1413			;                                                                             : 
1413			; Parameters                                                                  : 
1413			;     HL  Number of bytes wanted                                              : 
1413			;                                                                             : 
1413			; Returns                                                                     : 
1413			;     HL  Address of the first useable byte of the allocation                 : 
1413			;                                                                             : 
1413			; Flags                                                                       : 
1413			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1413			;                                                                             : 
1413			; Stack frame                                                                 : 
1413			;       |             |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     BC      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     DE      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     IX      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |  prev_free  |                                                       : 
1413			;   +4  +-------------+                                                       : 
1413			;       |  this_free  |                                                       : 
1413			;   +2  +-------------+                                                       : 
1413			;       |  next_free  |                                                       : 
1413			;   +0  +-------------+                                                       : 
1413			;       |             |                                                       : 
1413			;                                                                             : 
1413			;------------------------------------------------------------------------------ 
1413			 
1413			 
1413			;malloc: 
1413			; 
1413			;	SAVESP ON 1 
1413			; 
1413			;	call malloc_code 
1413			; 
1413			;	CHECKSP ON 1 
1413			;	ret 
1413			 
1413			 
1413			malloc: 
1413 c5			      push  BC 
1414 d5			      push  DE 
1415 dd e5		      push  IX 
1417			if DEBUG_FORTH_MALLOC_HIGH 
1417			call malloc_guard_entry 
1417			endif 
1417			 
1417					if DEBUG_FORTH_MALLOC 
1417						DMARK "mal" 
1417						CALLMONITOR 
1417					endif 
1417 7c			      ld    A, H                    ; Exit if no space requested 
1418 b5			      or    L 
1419 ca d8 14		      jp    Z, malloc_early_exit 
141c			 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			; 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			 
141c			 
141c			 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "maA" 
141c						CALLMONITOR 
141c					endif 
141c			      ; Set up stack frame 
141c eb			      ex    DE, HL 
141d 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1420 39			      add   HL, SP 
1421 f9			      ld    SP, HL 
1422 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1426 dd 39		      add   IX, SP 
1428			 
1428			      ; Setup initial state 
1428 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
142b 19			      add   HL, DE 
142c			 
142c 44			      ld    B, H                    ; Move want to BC 
142d 4d			      ld    C, L 
142e			 
142e 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1431 dd 75 04		      ld    (IX+4), L 
1434 dd 74 05		      ld    (IX+5), H 
1437			 
1437 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1438 23			      inc   HL 
1439 56			      ld    D, (HL) 
143a dd 73 02		      ld    (IX+2), E 
143d dd 72 03		      ld    (IX+3), D 
1440 eb			      ex    DE, HL                  ; this_free ptr into HL 
1441			 
1441					if DEBUG_FORTH_MALLOC 
1441						DMARK "maB" 
1441						CALLMONITOR 
1441					endif 
1441			      ; Loop through free block list to find some space 
1441			malloc_find_space: 
1441 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1442 23			      inc   HL 
1443 56			      ld    D, (HL) 
1444			 
1444 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1445 b3			      or    E 
1446 ca d2 14		      jp    Z, malloc_no_space 
1449			 
1449 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
144c dd 72 01		      ld    (IX+1), D 
144f			 
144f			      ; Does this block have enough space to make the allocation? 
144f 23			      inc   HL                      ; Load free block size into DE 
1450 5e			      ld    E, (HL) 
1451 23			      inc   HL 
1452 56			      ld    D, (HL) 
1453			 
1453 eb			      ex    DE, HL                  ; Check size of block against want 
1454 b7			      or    A                       ; Ensure carry flag clear 
1455 ed 42		      sbc   HL, BC 
1457 e5			      push  HL                      ; Store the result for later (new block size) 
1458			 
1458 ca a7 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
145b 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145d			 
145d			      ; this_free block is not big enough, setup ptrs to test next free block 
145d e1			      pop   HL                      ; Discard previous result 
145e			 
145e dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1461 dd 66 03		      ld    H, (IX+3) 
1464 dd 75 04		      ld    (IX+4), L 
1467 dd 74 05		      ld    (IX+5), H 
146a			 
146a dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146d dd 66 01		      ld    H, (IX+1) 
1470 dd 75 02		      ld    (IX+2), L 
1473 dd 74 03		      ld    (IX+3), H 
1476			 
1476					if DEBUG_FORTH_MALLOC 
1476						DMARK "MA>" 
1476						CALLMONITOR 
1476					endif 
1476 18 c9		      jr    malloc_find_space 
1478			 
1478			      ; split a bigger block into two - requested size and remaining size 
1478			malloc_alloc_split: 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAs" 
1478						CALLMONITOR 
1478					endif 
1478 eb			      ex    DE, HL                  ; Calculate address of new free block 
1479 2b			      dec   HL 
147a 2b			      dec   HL 
147b 2b			      dec   HL 
147c 09			      add   HL, BC 
147d			 
147d			      ; Create a new block and point it at next_free 
147d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1480 dd 56 01		      ld    D, (IX+1) 
1483			 
1483 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1484 23			      inc   HL 
1485 72			      ld    (HL), D 
1486			 
1486 d1			      pop   DE                      ; Store size of new block into new block 
1487 23			      inc   HL 
1488 73			      ld    (HL), E 
1489 23			      inc   HL 
148a 72			      ld    (HL), D 
148b			 
148b			      ; Update this_free ptr to point to new block 
148b 2b			      dec   HL 
148c 2b			      dec   HL 
148d 2b			      dec   HL 
148e			 
148e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1491 dd 56 03		      ld    D, (IX+3) 
1494			 
1494 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1497 dd 74 03		      ld    (IX+3), H 
149a			 
149a			      ; Modify this_free block to be allocation 
149a eb			      ex    DE, HL 
149b af			      xor   A                       ; Null the next block ptr of allocated block 
149c 77			      ld    (HL), A 
149d 23			      inc   HL 
149e 77			      ld    (HL), A 
149f			 
149f 23			      inc   HL                      ; Store want size into allocated block 
14a0 71			      ld    (HL), C 
14a1 23			      inc   HL 
14a2 70			      ld    (HL), B 
14a3 23			      inc   HL 
14a4 e5			      push  HL                      ; Address of allocation to return 
14a5			 
14a5 18 19		      jr    malloc_update_links 
14a7			 
14a7			malloc_alloc_fit: 
14a7 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a8			 
14a8					if DEBUG_FORTH_MALLOC 
14a8						DMARK "MAf" 
14a8						CALLMONITOR 
14a8					endif 
14a8			      ; Modify this_free block to be allocation 
14a8 eb			      ex    DE, HL 
14a9 2b			      dec   HL 
14aa 2b			      dec   HL 
14ab 2b			      dec   HL 
14ac			 
14ac af			      xor   A                       ; Null the next block ptr of allocated block 
14ad 77			      ld    (HL), A 
14ae 23			      inc   HL 
14af 77			      ld    (HL), A 
14b0			 
14b0 23			      inc   HL                      ; Store address of allocation to return 
14b1 23			      inc   HL 
14b2 23			      inc   HL 
14b3 e5			      push  HL 
14b4			 
14b4			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b4 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b7 dd 66 01		      ld    H, (IX+1) 
14ba			 
14ba dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14bd dd 74 03		      ld    (IX+3), H 
14c0			 
14c0			 
14c0			malloc_update_links: 
14c0			      ; Update prev_free ptr to point to this_free 
14c0 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c3 dd 66 05		      ld    H, (IX+5) 
14c6			 
14c6 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c9 dd 56 03		      ld    D, (IX+3) 
14cc			 
14cc 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14cd 23			      inc   HL 
14ce 72			      ld    (HL), D 
14cf			 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "Mul" 
14cf						CALLMONITOR 
14cf					endif 
14cf			      ; Clear the Z flag to indicate successful allocation 
14cf 7a			      ld    A, D 
14d0 b3			      or    E 
14d1			 
14d1 d1			      pop   DE                      ; Address of allocation 
14d2					if DEBUG_FORTH_MALLOC 
14d2						DMARK "MAu" 
14d2						CALLMONITOR 
14d2					endif 
14d2			 
14d2			malloc_no_space: 
14d2 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d5 39			      add   HL, SP 
14d6 f9			      ld    SP, HL 
14d7			 
14d7 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAN" 
14d8						CALLMONITOR 
14d8					endif 
14d8			 
14d8			malloc_early_exit: 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAx" 
14d8						CALLMONITOR 
14d8					endif 
14d8 dd e1		      pop   IX 
14da d1			      pop   DE 
14db c1			      pop   BC 
14dc			 
14dc			if DEBUG_FORTH_MALLOC_HIGH 
14dc			call malloc_guard_exit 
14dc			call malloc_guard_zerolen 
14dc			endif 
14dc c9			      ret 
14dd			 
14dd			 
14dd			;------------------------------------------------------------------------------ 
14dd			;     free                                                                    : 
14dd			;                                                                             : 
14dd			; Description                                                                 : 
14dd			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14dd			;     returned by malloc, otherwise the behaviour is undefined.               : 
14dd			;                                                                             : 
14dd			;     Where possible, directly adjacent free blocks will be merged together   : 
14dd			;     into larger blocks to help ensure that the heap does not become         : 
14dd			;     excessively fragmented.                                                 : 
14dd			;                                                                             : 
14dd			;     free does not clear or set any other value into the freed space, and    : 
14dd			;     therefore its contents may be visible through subsequent malloc's. The  : 
14dd			;     caller should clear the freed space as required.                        : 
14dd			;                                                                             : 
14dd			;     This implementation of free uses the stack exclusively, and is          : 
14dd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14dd			;     advisable to disable interrupts before calling free, and recommended    : 
14dd			;     to avoid the use of free inside ISRs in general.                        : 
14dd			;                                                                             : 
14dd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14dd			;                                                                             : 
14dd			; Parameters                                                                  : 
14dd			;     HL  Pointer to address of first byte of allocation to be freed          : 
14dd			;                                                                             : 
14dd			; Returns                                                                     : 
14dd			;     Nothing                                                                 : 
14dd			;                                                                             : 
14dd			; Stack frame                                                                 : 
14dd			;       |             |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     BC      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     DE      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     IX      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |  prev_free  |                                                       : 
14dd			;   +2  +-------------+                                                       : 
14dd			;       |  next_free  |                                                       : 
14dd			;   +0  +-------------+                                                       : 
14dd			;       |             |                                                       : 
14dd			;                                                                             : 
14dd			;------------------------------------------------------------------------------ 
14dd			free: 
14dd c5			      push  BC 
14de d5			      push  DE 
14df dd e5		      push  IX 
14e1			 
14e1 7c			      ld    A, H                    ; Exit if ptr is null 
14e2 b5			      or    L 
14e3 ca a7 15		      jp    Z, free_early_exit 
14e6			 
14e6			      ; Set up stack frame 
14e6 eb			      ex    DE, HL 
14e7 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14ea 39			      add   HL, SP 
14eb f9			      ld    SP, HL 
14ec dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14f0 dd 39		      add   IX, SP 
14f2			 
14f2			      ; The address in HL points to the start of the useable allocated space, 
14f2			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14f2			      ; address of the block itself. 
14f2 eb			      ex    DE, HL 
14f3 11 fc ff		      ld    DE, -4 
14f6 19			      add   HL, DE 
14f7			 
14f7			      ; An allocated block must have a null next block pointer in it 
14f7 7e			      ld    A, (HL) 
14f8 23			      inc   HL 
14f9 b6			      or    (HL) 
14fa c2 a2 15		      jp    NZ, free_done 
14fd			 
14fd 2b			      dec   HL 
14fe			 
14fe 44			      ld    B, H                    ; Copy HL to BC 
14ff 4d			      ld    C, L 
1500			 
1500			      ; Loop through the free list to find the first block with an address 
1500			      ; higher than the block being freed 
1500 21 0a 80		      ld    HL, free_list 
1503			 
1503			free_find_higher_block: 
1503 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1504 23			      inc   HL 
1505 56			      ld    D, (HL) 
1506 2b			      dec   HL 
1507			 
1507 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
150a dd 72 01		      ld    (IX+1), D 
150d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1510 dd 74 03		      ld    (IX+3), H 
1513			 
1513 78			      ld    A, B                    ; Check if DE is greater than BC 
1514 ba			      cp    D                       ; Compare MSB first 
1515 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1517 30 04		      jr    NC, free_find_higher_block_skip 
1519 79			      ld    A, C 
151a bb			      cp    E                       ; Then compare LSB 
151b 38 08		      jr    C, free_found_higher_block 
151d			 
151d			free_find_higher_block_skip: 
151d 7a			      ld    A, D                    ; Reached the end of the free list? 
151e b3			      or    E 
151f ca a2 15		      jp    Z, free_done 
1522			 
1522 eb			      ex    DE, HL 
1523			 
1523 18 de		      jr    free_find_higher_block 
1525			 
1525			free_found_higher_block: 
1525			      ; Insert freed block between prev and next free blocks 
1525 71			      ld    (HL), C                 ; Point prev free block to freed block 
1526 23			      inc   HL 
1527 70			      ld    (HL), B 
1528			 
1528 60			      ld    H, B                    ; Point freed block at next free block 
1529 69			      ld    L, C 
152a 73			      ld    (HL), E 
152b 23			      inc   HL 
152c 72			      ld    (HL), D 
152d			 
152d			      ; Check if the freed block is adjacent to the next free block 
152d 23			      inc   HL                      ; Load size of freed block into HL 
152e 5e			      ld    E, (HL) 
152f 23			      inc   HL 
1530 56			      ld    D, (HL) 
1531 eb			      ex    DE, HL 
1532			 
1532 09			      add   HL, BC                  ; Add addr of freed block and its size 
1533			 
1533 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1536 dd 56 01		      ld    D, (IX+1) 
1539			 
1539 b7			      or    A                       ; Clear the carry flag 
153a ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
153c 20 22		      jr    NZ, free_check_adjacent_to_prev 
153e			 
153e			      ; Freed block is adjacent to next, merge into one bigger block 
153e eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153f 5e			      ld    E, (HL) 
1540 23			      inc   HL 
1541 56			      ld    D, (HL) 
1542 e5			      push  HL                      ; Save ptr to next block for later 
1543			 
1543 60			      ld    H, B                    ; Store ptr from next block into freed block 
1544 69			      ld    L, C 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548 e1			      pop   HL                      ; Restore ptr to next block 
1549 23			      inc   HL                      ; Load size of next block into DE 
154a 5e			      ld    E, (HL) 
154b 23			      inc   HL 
154c 56			      ld    D, (HL) 
154d d5			      push  DE                      ; Save next block size for later 
154e			 
154e 60			      ld    H, B                    ; Load size of freed block into HL 
154f 69			      ld    L, C 
1550 23			      inc   HL 
1551 23			      inc   HL 
1552 5e			      ld    E, (HL) 
1553 23			      inc   HL 
1554 56			      ld    D, (HL) 
1555 eb			      ex    DE, HL 
1556			 
1556 d1			      pop   DE                      ; Restore size of next block 
1557 19			      add   HL, DE                  ; Add sizes of both blocks 
1558 eb			      ex    DE, HL 
1559			 
1559 60			      ld    H, B                    ; Store new bigger size into freed block 
155a 69			      ld    L, C 
155b 23			      inc   HL 
155c 23			      inc   HL 
155d 73			      ld    (HL), E 
155e 23			      inc   HL 
155f 72			      ld    (HL), D 
1560			 
1560			free_check_adjacent_to_prev: 
1560			      ; Check if the freed block is adjacent to the prev free block 
1560 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1563 dd 66 03		      ld    H, (IX+3) 
1566			 
1566 23			      inc   HL                      ; Size of prev free block into DE 
1567 23			      inc   HL 
1568 5e			      ld    E, (HL) 
1569 23			      inc   HL 
156a 56			      ld    D, (HL) 
156b 2b			      dec   HL 
156c 2b			      dec   HL 
156d 2b			      dec   HL 
156e			 
156e 19			      add   HL, DE                  ; Add prev block addr and size 
156f			 
156f b7			      or    A                       ; Clear the carry flag 
1570 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1572 20 2e		      jr    NZ, free_done 
1574			 
1574			      ; Freed block is adjacent to prev, merge into one bigger block 
1574 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1575 69			      ld    L, C 
1576 5e			      ld    E, (HL) 
1577 23			      inc   HL 
1578 56			      ld    D, (HL) 
1579 e5			      push  HL                      ; Save freed block ptr for later 
157a			 
157a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157d dd 66 03		      ld    H, (IX+3) 
1580 73			      ld    (HL), E 
1581 23			      inc   HL 
1582 72			      ld    (HL), D 
1583			 
1583 e1			      pop   HL                      ; Restore freed block ptr 
1584 23			      inc   HL                      ; Load size of freed block into DE 
1585 5e			      ld    E, (HL) 
1586 23			      inc   HL 
1587 56			      ld    D, (HL) 
1588 d5			      push  DE                      ; Save freed block size for later 
1589			 
1589 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
158c dd 66 03		      ld    H, (IX+3) 
158f 23			      inc   HL 
1590 23			      inc   HL 
1591 5e			      ld    E, (HL) 
1592 23			      inc   HL 
1593 56			      ld    D, (HL) 
1594			 
1594 e1			      pop   HL                      ; Add sizes of both blocks 
1595 19			      add   HL, DE 
1596 eb			      ex    DE, HL 
1597			 
1597 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
159a dd 66 03		      ld    H, (IX+3) 
159d 23			      inc   HL 
159e 23			      inc   HL 
159f 73			      ld    (HL), E 
15a0 23			      inc   HL 
15a1 72			      ld    (HL), D 
15a2			 
15a2			free_done: 
15a2 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a5 39			      add   HL, SP 
15a6 f9			      ld    SP, HL 
15a7			 
15a7			free_early_exit: 
15a7 dd e1		      pop   IX 
15a9 d1			      pop   DE 
15aa c1			      pop   BC 
15ab			 
15ab c9			      ret 
15ac			 
15ac			; moved to firmware.asm 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			;                  .dw   0 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_3 
15ac			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15ac			;heap_start        .equ  0x9000      ; Starting address of heap 
15ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15ac			; 
15ac			 ;     .org 0 
15ac			  ;    jp    main 
15ac			; 
15ac			; 
15ac			 ;     .org  0x100 
15ac			;main: 
15ac			 ;     ld    HL, 0x8100 
15ac			  ;    ld    SP, HL 
15ac			; 
15ac			;      call  heap_init 
15ac			 
15ac			      ; Make some allocations 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9004 
15ac			; 
15ac			 ;     ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9014 
15ac			 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9024 
15ac			 
15ac			      ; Free some allocations 
15ac			;      ld    HL, 0x9014 
15ac			;      call  free 
15ac			 
15ac			;      ld    HL, 0x9004 
15ac			;      call  free 
15ac			; 
15ac			;      ld    HL, 0x9024 
15ac			;      call  free 
15ac			 
15ac			 
15ac			 ;     halt 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     heap_init                                                               : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
15ac			;                                                                             : 
15ac			;     The heap is maintained as a linked list, starting with an initial       : 
15ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15ac			;     the first free block in the heap. Each block then points to the next    : 
15ac			;     free block within the heap, and the free list ends at the first block   : 
15ac			;     with a null pointer to the next free block.                             : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
15ac			;     address of the heap and its size are required, along with a memory      : 
15ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15ac			;     principally stores a pointer to the first free block in the heap.       : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;------------------------------------------------------------------------------ 
15ac			heap_init: 
15ac			      push  HL 
15ac			 
15ac			      ; Initialise free list struct 
15ac			      ld    HL, heap_start 
15ac			      ld    (free_list), HL 
15ac			      ld    HL, 0 
15ac			      ld    (free_list+2), HL 
15ac			 
15ac			      ; Insert first free block at bottom of heap, consumes entire heap 
15ac			      ld    HL, heap_start+heap_size-4 
15ac			      ld    (heap_start), HL        ; Next block (end of free list) 
15ac			      ld    HL, heap_size-4 
15ac			      ld    (heap_start+2), HL      ; Block size 
15ac			 
15ac			      ; Insert end of free list block at top of heap - two null words will 
15ac			      ; terminate the free list 
15ac			      ld    HL, 0 
15ac			      ld    (heap_start+heap_size-2), HL 
15ac			      ld    (heap_start+heap_size-4), HL 
15ac			 
15ac			      pop   HL 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     malloc                                                                  : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Allocates the wanted space from the heap and returns the address of the : 
15ac			;     first useable byte of the allocation.                                   : 
15ac			;                                                                             : 
15ac			;     Allocations can happen in one of two ways:                              : 
15ac			;                                                                             : 
15ac			;     1. A free block may be found which is the exact size wanted. In this    : 
15ac			;        case the block is removed from the free list and retuedn to the      : 
15ac			;        caller.                                                              : 
15ac			;     2. A free block may be found which is larger than the size wanted. In   : 
15ac			;        this case, the larger block is split into two. The first portion of  : 
15ac			;        this block will become the requested space by the malloc call and    : 
15ac			;        is returned to the caller. The second portion becomes a new free     : 
15ac			;        block, and the free list is adjusted to maintain continuity via this : 
15ac			;        newly created block.                                                 : 
15ac			;                                                                             : 
15ac			;     malloc does not set any initial value in the allocated space, the       : 
15ac			;     caller is required to do this as required.                              : 
15ac			;                                                                             : 
15ac			;     This implementation of malloc uses the stack exclusively, and is        : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling malloc, and recommended  : 
15ac			;     to avoid the use of malloc inside ISRs in general.                      : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Number of bytes wanted                                              : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     HL  Address of the first useable byte of the allocation                 : 
15ac			;                                                                             : 
15ac			; Flags                                                                       : 
15ac			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +4  +-------------+                                                       : 
15ac			;       |  this_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			malloc: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if no space requested 
15ac			      or    L 
15ac			      jp    Z, malloc_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; Setup initial state 
15ac			      ld    HL, 4                   ; want must also include space used by block struct 
15ac			      add   HL, DE 
15ac			 
15ac			      ld    B, H                    ; Move want to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ld    HL, free_list           ; Store prev_free ptr to stack 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    E, (HL)                 ; Store this_free ptr to stack 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ld    (IX+2), E 
15ac			      ld    (IX+3), D 
15ac			      ex    DE, HL                  ; this_free ptr into HL 
15ac			 
15ac			      ; Loop through free block list to find some space 
15ac			malloc_find_space: 
15ac			      ld    E, (HL)                 ; Load next_free ptr into DE 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15ac			      or    E 
15ac			      jp    Z, malloc_no_space 
15ac			 
15ac			      ld    (IX+0), E               ; Store next_free ptr to stack 
15ac			      ld    (IX+1), D 
15ac			 
15ac			      ; Does this block have enough space to make the allocation? 
15ac			      inc   HL                      ; Load free block size into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ex    DE, HL                  ; Check size of block against want 
15ac			      or    A                       ; Ensure carry flag clear 
15ac			      sbc   HL, BC 
15ac			      push  HL                      ; Store the result for later (new block size) 
15ac			 
15ac			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15ac			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15ac			 
15ac			      ; this_free block is not big enough, setup ptrs to test next free block 
15ac			      pop   HL                      ; Discard previous result 
15ac			 
15ac			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15ac			      ld    H, (IX+3) 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15ac			      ld    H, (IX+1) 
15ac			      ld    (IX+2), L 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      jr    malloc_find_space 
15ac			 
15ac			      ; split a bigger block into two - requested size and remaining size 
15ac			malloc_alloc_split: 
15ac			      ex    DE, HL                  ; Calculate address of new free block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      add   HL, BC 
15ac			 
15ac			      ; Create a new block and point it at next_free 
15ac			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      ld    (HL), E                 ; Store next_free ptr into new block 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   DE                      ; Store size of new block into new block 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Update this_free ptr to point to new block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store want size into allocated block 
15ac			      ld    (HL), C 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			      inc   HL 
15ac			      push  HL                      ; Address of allocation to return 
15ac			 
15ac			      jr    malloc_update_links 
15ac			 
15ac			malloc_alloc_fit: 
15ac			      pop   HL                      ; Dont need new block size, want is exact fit 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store address of allocation to return 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      push  HL 
15ac			 
15ac			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15ac			      ld    L, (IX+0)               ; next_free to HL 
15ac			      ld    H, (IX+1) 
15ac			 
15ac			      ld    (IX+2), L               ; HL to this_free 
15ac			      ld    (IX+3), H 
15ac			 
15ac			 
15ac			malloc_update_links: 
15ac			      ; Update prev_free ptr to point to this_free 
15ac			      ld    L, (IX+4)               ; prev_free ptr to HL 
15ac			      ld    H, (IX+5) 
15ac			 
15ac			      ld    E, (IX+2)               ; this_free ptr to DE 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (HL), E                 ; this_free ptr into prev_free 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Clear the Z flag to indicate successful allocation 
15ac			      ld    A, D 
15ac			      or    E 
15ac			 
15ac			      pop   DE                      ; Address of allocation 
15ac			 
15ac			malloc_no_space: 
15ac			      ld    HL, 6                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			      ex    DE, HL                  ; Alloc addr into HL for return 
15ac			 
15ac			malloc_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     free                                                                    : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15ac			;     returned by malloc, otherwise the behaviour is undefined.               : 
15ac			;                                                                             : 
15ac			;     Where possible, directly adjacent free blocks will be merged together   : 
15ac			;     into larger blocks to help ensure that the heap does not become         : 
15ac			;     excessively fragmented.                                                 : 
15ac			;                                                                             : 
15ac			;     free does not clear or set any other value into the freed space, and    : 
15ac			;     therefore its contents may be visible through subsequent malloc's. The  : 
15ac			;     caller should clear the freed space as required.                        : 
15ac			;                                                                             : 
15ac			;     This implementation of free uses the stack exclusively, and is          : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling free, and recommended    : 
15ac			;     to avoid the use of free inside ISRs in general.                        : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Pointer to address of first byte of allocation to be freed          : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			free: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if ptr is null 
15ac			      or    L 
15ac			      jp    Z, free_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; The address in HL points to the start of the useable allocated space, 
15ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15ac			      ; address of the block itself. 
15ac			      ex    DE, HL 
15ac			      ld    DE, -4 
15ac			      add   HL, DE 
15ac			 
15ac			      ; An allocated block must have a null next block pointer in it 
15ac			      ld    A, (HL) 
15ac			      inc   HL 
15ac			      or    (HL) 
15ac			      jp    NZ, free_done 
15ac			 
15ac			      dec   HL 
15ac			 
15ac			      ld    B, H                    ; Copy HL to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ; Loop through the free list to find the first block with an address 
15ac			      ; higher than the block being freed 
15ac			      ld    HL, free_list 
15ac			 
15ac			free_find_higher_block: 
15ac			      ld    E, (HL)                 ; Load next ptr from free block 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			 
15ac			      ld    (IX+0), E               ; Save ptr to next free block 
15ac			      ld    (IX+1), D 
15ac			      ld    (IX+2), L               ; Save ptr to prev free block 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ld    A, B                    ; Check if DE is greater than BC 
15ac			      cp    D                       ; Compare MSB first 
15ac			      jr    Z, $+4                  ; MSB the same, compare LSB 
15ac			      jr    NC, free_find_higher_block_skip 
15ac			      ld    A, C 
15ac			      cp    E                       ; Then compare LSB 
15ac			      jr    C, free_found_higher_block 
15ac			 
15ac			free_find_higher_block_skip: 
15ac			      ld    A, D                    ; Reached the end of the free list? 
15ac			      or    E 
15ac			      jp    Z, free_done 
15ac			 
15ac			      ex    DE, HL 
15ac			 
15ac			      jr    free_find_higher_block 
15ac			 
15ac			free_found_higher_block: 
15ac			      ; Insert freed block between prev and next free blocks 
15ac			      ld    (HL), C                 ; Point prev free block to freed block 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			 
15ac			      ld    H, B                    ; Point freed block at next free block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Check if the freed block is adjacent to the next free block 
15ac			      inc   HL                      ; Load size of freed block into HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      add   HL, BC                  ; Add addr of freed block and its size 
15ac			 
15ac			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_check_adjacent_to_prev 
15ac			 
15ac			      ; Freed block is adjacent to next, merge into one bigger block 
15ac			      ex    DE, HL                  ; Load next ptr from next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save ptr to next block for later 
15ac			 
15ac			      ld    H, B                    ; Store ptr from next block into freed block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore ptr to next block 
15ac			      inc   HL                      ; Load size of next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save next block size for later 
15ac			 
15ac			      ld    H, B                    ; Load size of freed block into HL 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      pop   DE                      ; Restore size of next block 
15ac			      add   HL, DE                  ; Add sizes of both blocks 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    H, B                    ; Store new bigger size into freed block 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_check_adjacent_to_prev: 
15ac			      ; Check if the freed block is adjacent to the prev free block 
15ac			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15ac			      ld    H, (IX+3) 
15ac			 
15ac			      inc   HL                      ; Size of prev free block into DE 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      add   HL, DE                  ; Add prev block addr and size 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_done 
15ac			 
15ac			      ; Freed block is adjacent to prev, merge into one bigger block 
15ac			      ld    H, B                    ; Load next ptr from freed block into DE 
15ac			      ld    L, C 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save freed block ptr for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15ac			      ld    H, (IX+3) 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore freed block ptr 
15ac			      inc   HL                      ; Load size of freed block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save freed block size for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Load size of prev block into DE 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      pop   HL                      ; Add sizes of both blocks 
15ac			      add   HL, DE 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_done: 
15ac			      ld    HL, 4                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			free_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;      .org 0x8000 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			 ;                 .dw   0 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_4 
15ac			 
15ac			; My memory allocation code. Very very simple.... 
15ac			; allocate space under 250 chars 
15ac			 
15ac			heap_init: 
15ac				; init start of heap as zero 
15ac				;  
15ac			 
15ac				ld hl, heap_start 
15ac				ld a, 0 
15ac				ld (hl), a      ; empty block 
15ac				inc hl 
15ac				ld a, 0 
15ac				ld (hl), a      ; length of block 
15ac				; write end of list 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				 
15ac			 
15ac				; init some malloc vars 
15ac			 
15ac				ld hl, 0 
15ac				ld (free_list), hl       ; store last malloc location 
15ac			 
15ac				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15ac				ld a, 0 
15ac				ld (hl), a 
15ac			 
15ac			 
15ac				ld hl, heap_start 
15ac				;  
15ac				  
15ac				ret 
15ac			 
15ac			 
15ac			;    free block marker 
15ac			;    requested size  
15ac			;    pointer to next block 
15ac			;    .... 
15ac			;    next block marker 
15ac			 
15ac			 
15ac			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15ac			; 
15ac			 
15ac			 
15ac			malloc:  
15ac				push de 
15ac				push bc 
15ac				push af 
15ac			 
15ac				; hl space required 
15ac				 
15ac				ld c, l    ; hold space   (TODO only a max of 255) 
15ac			 
15ac			;	inc c     ; TODO BUG need to fix memory leak on push str 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			 
15ac			 
15ac			 
15ac				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15ac			 
15ac				ld a, (free_list+3) 
15ac				cp 0 
15ac				jr z, .contheap 
15ac			 
15ac				ld hl, (free_list)     ; get last alloc 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mrs" 
15ac						CALLMONITOR 
15ac					endif 
15ac				jr .startalloc 
15ac			 
15ac			.contheap: 
15ac				ld hl, heap_start 
15ac			 
15ac			.startalloc: 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mym" 
15ac						CALLMONITOR 
15ac					endif 
15ac			.findblock: 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmf" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac				ld a,(hl)  
15ac				; if byte is zero then clear to use 
15ac			 
15ac				cp 0 
15ac				jr z, .foundemptyblock 
15ac			 
15ac				; if byte is not clear 
15ac				;     then byte is offset to next block 
15ac			 
15ac				inc hl 
15ac				ld a, (hl) ; get size 
15ac			.nextblock:	inc hl 
15ac					ld e, (hl) 
15ac					inc hl 
15ac					ld d, (hl) 
15ac					ex de, hl 
15ac			;	inc hl  ; move past the store space 
15ac			;	inc hl  ; move past zero index  
15ac			 
15ac				; TODO detect no more space 
15ac			 
15ac				push hl 
15ac				ld de, heap_end 
15ac				call cmp16 
15ac				pop hl 
15ac				jr nc, .nospace 
15ac			 
15ac				jr .findblock 
15ac			 
15ac			.nospace: ld hl, 0 
15ac				jp .exit 
15ac			 
15ac			 
15ac			.foundemptyblock:	 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mme" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; TODO has block enough space if reusing??? 
15ac			 
15ac				;  
15ac			 
15ac			; see if this block has been previously used 
15ac				inc hl 
15ac				ld a, (hl) 
15ac				dec hl 
15ac				cp 0 
15ac				jr z, .newblock 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meR" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; no reusing previously allocated block 
15ac			 
15ac			; is it smaller than previously used? 
15ac				 
15ac				inc hl    ; move to size 
15ac				ld a, c 
15ac				sub (hl)        ; we want c < (hl) 
15ac				dec hl    ; move back to marker 
15ac			        jr z, .findblock 
15ac			 
15ac				; update with the new size which should be lower 
15ac			 
15ac			        ;inc  hl   ; negate next move. move back to size  
15ac			 
15ac			.newblock: 
15ac				; need to be at marker here 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meN" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			 
15ac				ld a, c 
15ac			 
15ac				ld (free_list+3), a	 ; flag resume from last malloc  
15ac				ld (free_list), hl    ; save out last location 
15ac			 
15ac			 
15ac				;inc a     ; space for length byte 
15ac				ld (hl), a     ; save block in use marker 
15ac			 
15ac				inc hl   ; move to space marker 
15ac				ld (hl), a    ; save new space 
15ac			 
15ac				inc hl   ; move to start of allocated area 
15ac				 
15ac			;	push hl     ; save where we are - 1  
15ac			 
15ac			;	inc hl  ; move past zero index  
15ac				; skip space to set down new marker 
15ac			 
15ac				; provide some extra space for now 
15ac			 
15ac				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15ac				inc a 
15ac				inc a 
15ac			 
15ac				push hl   ; save where we are in the node block 
15ac			 
15ac				call addatohl 
15ac			 
15ac				; write linked list point 
15ac			 
15ac				pop de     ; get our node position 
15ac				ex de, hl 
15ac			 
15ac				ld (hl), e 
15ac				inc hl 
15ac				ld (hl), d 
15ac			 
15ac				inc hl 
15ac			 
15ac				; now at start of allocated data so save pointer 
15ac			 
15ac				push hl 
15ac			 
15ac				; jump to position of next node and setup empty header in DE 
15ac			 
15ac				ex de, hl 
15ac			 
15ac			;	inc hl ; move past end of block 
15ac			 
15ac				ld a, 0 
15ac				ld (hl), a   ; empty marker 
15ac				inc hl 
15ac				ld (hl), a   ; size 
15ac				inc hl  
15ac				ld (hl), a   ; ptr 
15ac				inc hl 
15ac				ld (hl), a   ; ptr 
15ac			 
15ac			 
15ac				pop hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmr" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			.exit: 
15ac				pop af 
15ac				pop bc 
15ac				pop de  
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			 
15ac			free:  
15ac				push hl 
15ac				push af 
15ac				; get address in hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "fre" 
15ac						CALLMONITOR 
15ac					endif 
15ac				; data is at hl - move to block count 
15ac				dec hl 
15ac				dec hl    ; get past pointer 
15ac				dec hl 
15ac			 
15ac				ld a, (hl)    ; need this for a validation check 
15ac			 
15ac				dec hl    ; move to block marker 
15ac			 
15ac				; now check that the block count and block marker are the same  
15ac			        ; this checks that we are on a malloc node and not random memory 
15ac			        ; OK a faint chance this could be a problem but rare - famous last words! 
15ac			 
15ac				ld c, a 
15ac				ld a, (hl)    
15ac			 
15ac				cp c 
15ac				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15ac			 
15ac				; yes good chance we are on a malloc node 
15ac			 
15ac				ld a, 0      
15ac				ld (hl), a   ; mark as free 
15ac			 
15ac				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15ac			 
15ac			.freeignore:  
15ac			 
15ac				pop af 
15ac				pop hl 
15ac			 
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			; eof 
# End of file firmware_memory.asm
15ac			  
15ac			; device C  
15ac			if SOUND_ENABLE  
15ac				include "firmware_sound.asm"  
15ac			; Sound abstraction layer 
15ac			 
15ac			; support different sound chips through common interface 
15ac			 
15ac			SOUND_DEVICE_AY: equ 0 
15ac			 
15ac			SOUND_DEVICE: equ Device_A 
15ac			 
15ac			 
15ac			 
15ac			if SOUND_DEVICE_AY 
15ac				include "firmware_sound_ay38910.asm" 
15ac			else 
15ac				include "firmware_sound_sn76489an.asm" 
15ac			 
15ac			; Device support for SN76489AN sound chip 
15ac			 
15ac			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
15ac			; http://danceswithferrets.org/geekblog/?p=93 
15ac			; https://www.smspower.org/Development/SN76489 
15ac			 
15ac			; D0 [ 3] 
15ac			; D1 [ 2] 
15ac			; D2 [ 1] 
15ac			; D3 [15] 
15ac			; D4 [13] 
15ac			; D5 [12] 
15ac			; D6 [11] 
15ac			; D7 [10] 
15ac			; /WE [ 5] 
15ac			; CLK [14] 
15ac			; /OE [ 6] 
15ac			; AUDIO [ 7] 
15ac			; GND 8 
15ac			; +5 16 
15ac			; 
15ac			 
15ac			; Write sequence: 
15ac			; CE low 
15ac			; Data bus 
15ac			; WE low then high 
15ac			; 32 clock cycles / 8ns write time at 4mhz 
15ac			; 
15ac			; https://github.com/jblang/SN76489 
15ac			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
15ac			; Tried: 
15ac			; 
15ac			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
15ac			; 
15ac			; Connected WE to OR too 
15ac			;  
15ac			; That enabled the clock when required 
15ac			; However still random bus corruption. Need further investigation 
15ac			 
15ac			 
15ac			SOUND_LATCH: equ 10000000B 
15ac			SOUND_DATA: equ 0B 
15ac			SOUND_CH0:  equ 0B    ; Tone 
15ac			SOUND_CH1: equ 0100000B        ; Tone 
15ac			SOUND_CH2: equ 1000000B   ; Tone 
15ac			SOUND_CH3: equ 1100000B    ; Noise 
15ac			SOUND_VOL: equ 10000B 
15ac			SOUND_TONE: equ 0B 
15ac			 
15ac			 
15ac			sound_init: 
15ac 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
15ae cd c3 15			call note_send_byte 
15b1 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
15b3 cd c3 15			call note_send_byte 
15b6 cd 89 0c			call delay250ms 
15b9 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
15bb cd c3 15			call note_send_byte 
15be cd 89 0c			call delay250ms 
15c1 c9				ret 
15c2			 
15c2			; Play a note 
15c2			; h = note 
15c2			; l = duration 
15c2			; a = channel 
15c2			 
15c2			 
15c2			;  frequ = clock / ( 2 x reg valu x 32 )  
15c2			 
15c2			note:  
15c2				 
15c2			 
15c2 c9				ret 
15c3			 
15c3			note_send_byte: 
15c3				; byte in a 
15c3			 
15c3				; we high 
15c3 d3 40			out (Device_B), a 
15c5			;	ld a, 1 
15c5			;	call aDelayInMS 
15c5 00				nop  
15c6 00				nop  
15c7 00				nop  
15c8 00				nop  
15c9				; we low 
15c9 d3 40			out (Device_B), a 
15cb			;	ld a, 1 
15cb			;	call aDelayInMS 
15cb 00				nop  
15cc 00				nop  
15cd 00				nop  
15ce 00				nop  
15cf				; we high 
15cf d3 40			out (Device_B), a 
15d1			;	ld a, 1 
15d1			;	call aDelayInMS 
15d1 00				nop  
15d2 00				nop  
15d3 00				nop  
15d4 00				nop  
15d5			 
15d5			 
15d5 c9				ret 
15d6			 
15d6			;void SilenceAllChannels() 
15d6			;{ 
15d6			;  SendByte(0x9f); 
15d6			;  SendByte(0xbf); 
15d6			;  SendByte(0xdf); 
15d6			;  SendByte(0xff); 
15d6			;} 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound_sn76489an.asm
15d6			endif 
15d6			 
15d6			 
15d6			; Abstraction entry points 
15d6			 
15d6			; init  
15d6			 
15d6			; sound_init in specific hardware files 
15d6			 
15d6			; Play a note 
15d6			; h = note 
15d6			; l = duration 
15d6			; a = channel 
15d6			 
15d6			;note:     
15d6			;	ret 
15d6			 
15d6			 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound.asm
15d6			endif  
15d6			  
15d6			include "firmware_diags.asm"  
15d6			; Hardware diags menu 
15d6			 
15d6			 
15d6			config: 
15d6			 
15d6 3e 00			ld a, 0 
15d8 21 0b 16			ld hl, .configmn 
15db cd 49 0d			call menu 
15de			 
15de fe 00			cp 0 
15e0 c8				ret z 
15e1			 
15e1 fe 01			cp 1 
15e3 cc 4d 16			call z, .savetostore 
15e6			 
15e6 fe 02			cp 2 
15e8			if STARTUP_V1 
15e8				call z, .selautoload 
15e8			endif 
15e8			 
15e8			if STARTUP_V2 
15e8 cc 1d 16			call z, .enautoload 
15eb			endif 
15eb fe 03			cp 3 
15ed cc 34 16			call z, .disautoload 
15f0 fe 04			cp 4 
15f2 cc 4b 16			call z, .selbank 
15f5 fe 05			cp 5 
15f7 cc 88 18			call z, .debug_tog 
15fa fe 06			cp 6 
15fc cc cb 19			call z, .bpsgo 
15ff fe 07			cp 7 
1601 cc ae 18			call z, hardware_diags 
1604			if STARTUP_V2 
1604 fe 08			cp 8 
1606 cc 5f 16			call z, create_startup 
1609			endif 
1609 18 cb			jr config 
160b			 
160b			.configmn: 
160b bc 1b			dw prom_c3 
160d d3 1b			dw prom_c2 
160f e9 1b			dw prom_c2a 
1611 43 1c			dw prom_c2b 
1613			;	dw prom_c4 
1613 60 1c			dw prom_m4 
1615 7b 1c			dw prom_m4b 
1617 83 1c			dw prom_c1 
1619			if STARTUP_V2 
1619 92 1c			dw prom_c9 
161b			endif 
161b 00 00			dw 0 
161d				 
161d			 
161d			if STARTUP_V2 
161d			.enautoload: 
161d				if STORAGE_SE 
161d 3e fe			ld a, $fe      ; bit 0 clear 
161f 32 67 fa			ld (spi_device), a 
1622			 
1622 cd cd 04			call storage_get_block_0 
1625			 
1625 3e 01			ld a, 1 
1627 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
162a			 
162a 21 00 00				ld hl, 0 
162d 11 81 fa				ld de, store_page 
1630 cd 81 04			call storage_write_block	 ; save update 
1633				else 
1633			 
1633				ld hl, prom_notav 
1633				ld de, prom_empty 
1633				call info_panel 
1633				endif 
1633			 
1633			 
1633 c9				ret 
1634			endif 
1634			 
1634			.disautoload: 
1634				if STORAGE_SE 
1634 3e fe			ld a, $fe      ; bit 0 clear 
1636 32 67 fa			ld (spi_device), a 
1639			 
1639 cd cd 04			call storage_get_block_0 
163c			 
163c 3e 00			ld a, 0 
163e 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
1641			 
1641 21 00 00				ld hl, 0 
1644 11 81 fa				ld de, store_page 
1647 cd 81 04			call storage_write_block	 ; save update 
164a				else 
164a			 
164a				ld hl, prom_notav 
164a				ld de, prom_empty 
164a				call info_panel 
164a				endif 
164a			 
164a			 
164a c9				ret 
164b			 
164b			if STARTUP_V1 
164b			 
164b			; Select auto start 
164b			 
164b			.selautoload: 
164b			 
164b				 
164b				if STORAGE_SE 
164b			 
164b					call config_dir 
164b				        ld hl, scratch 
164b					ld a, 0 
164b					call menu 
164b			 
164b					cp 0 
164b					ret z 
164b			 
164b					dec a 
164b			 
164b			 
164b					; locate menu option 
164b			 
164b					ld hl, scratch 
164b					call table_lookup 
164b			 
164b					if DEBUG_FORTH_WORDS 
164b						DMARK "ALl" 
164b						CALLMONITOR 
164b					endif 
164b					; with the pointer to the menu it, the byte following the zero term is the file id 
164b			 
164b					ld a, 0 
164b					ld bc, 50   ; max of bytes to look at 
164b					cpir  
164b			 
164b					if DEBUG_FORTH_WORDS 
164b						DMARK "ALb" 
164b						CALLMONITOR 
164b					endif 
164b					;inc hl 
164b			 
164b					ld a, (hl)   ; file id 
164b					 
164b				        ; save bank and file ids 
164b			 
164b					push af 
164b			 
164b			; TODO need to save to block 0 on bank 1	 
164b			 
164b					call storage_get_block_0 
164b			 
164b					if DEBUG_FORTH_WORDS 
164b						DMARK "AL0" 
164b						CALLMONITOR 
164b					endif 
164b					pop af 
164b			 
164b					ld (store_page+STORE_0_FILERUN),a 
164b					 
164b					; save bank id 
164b			 
164b					ld a,(spi_device) 
164b					ld (store_page+STORE_0_BANKRUN),a 
164b			 
164b					; enable auto run of store file 
164b			 
164b					ld a, 1 
164b					ld (store_page+STORE_0_AUTOFILE),a 
164b			 
164b					; save buffer 
164b			 
164b					ld hl, 0 
164b					ld de, store_page 
164b					if DEBUG_FORTH_WORDS 
164b						DMARK "ALw" 
164b						CALLMONITOR 
164b					endif 
164b				call storage_write_block	 ; save update 
164b			  
164b			 
164b			 
164b			 
164b					ld hl, scratch 
164b					call config_fdir 
164b			 
164b				else 
164b			 
164b				ld hl, prom_notav 
164b				ld de, prom_empty 
164b				call info_panel 
164b			 
164b				endif 
164b				ret 
164b			endif 
164b			 
164b			 
164b			; Select storage bank 
164b			 
164b			.selbank: 
164b			 
164b				if STORAGE_SE 
164b				else 
164b			 
164b				ld hl, prom_notav 
164b				ld de, prom_empty 
164b				call info_panel 
164b				endif 
164b				 
164b c9				ret 
164c			 
164c			if STORAGE_SE 
164c			 
164c			.config_ldir:   
164c				; Load storage bank labels into menu array 
164c			 
164c				 
164c			 
164c			 
164c c9				ret 
164d			 
164d			 
164d			endif 
164d			 
164d			 
164d			; Save user words to storage 
164d			 
164d			.savetostore: 
164d			 
164d				if STORAGE_SE 
164d			 
164d cd d2 17				call config_dir 
1650 21 c8 f1			        ld hl, scratch 
1653 3e 00				ld a, 0 
1655 cd 49 0d				call menu 
1658					 
1658 21 c8 f1				ld hl, scratch 
165b cd bf 17				call config_fdir 
165e			 
165e				else 
165e			 
165e				ld hl, prom_notav 
165e				ld de, prom_empty 
165e				call info_panel 
165e			 
165e				endif 
165e			 
165e c9				ret 
165f			 
165f			if STARTUP_V2 
165f			 
165f			create_startup: 
165f			 
165f 3e 00			ld a, 0 
1661 21 b1 17			ld hl, .crstart 
1664 cd 49 0d			call menu 
1667			 
1667 fe 00			cp 0 
1669 c8				ret z 
166a			 
166a fe 01			cp 1 
166c cc 8a 16			call z, .genlsword 
166f fe 02			cp 2 
1671 cc 94 16			call z, .genedword 
1674			 
1674 fe 03			cp 3 
1676 cc 9e 16			call z, .gendemword 
1679			 
1679 fe 04			cp 4 
167b cc a8 16			call z, .genutlword 
167e fe 05			cp 5 
1680 cc b2 16			call z, .genspiword 
1683 fe 06			cp 6 
1685 cc bc 16			call z, .genkeyword 
1688 18 d5			jr create_startup 
168a			 
168a			.genlsword: 
168a 21 00 1c			ld hl, crs_s1 
168d 11 1d 17			ld de, .lsworddef 
1690 cd c6 16			call .genfile 
1693 c9				ret 
1694			 
1694			.genedword: 
1694 11 21 17			ld de, .edworddef 
1697 21 09 1c			ld hl, crs_s2 
169a cd c6 16			call .genfile 
169d c9				ret 
169e			 
169e			.gendemword: 
169e 11 29 17			ld de, .demoworddef 
16a1 21 12 1c			ld hl, crs_s3 
16a4 cd c6 16			call .genfile 
16a7 c9				ret 
16a8			 
16a8			.genutlword: 
16a8 21 21 1c			ld hl, crs_s4 
16ab 11 09 17			ld de, .utilwordef 
16ae cd c6 16			call .genfile 
16b1 c9				ret 
16b2			.genspiword: 
16b2 21 28 1c			ld hl, crs_s5 
16b5 11 6f 17			ld de, .spiworddef 
16b8 cd c6 16			call .genfile 
16bb c9				ret 
16bc			.genkeyword: 
16bc 21 34 1c			ld hl, crs_s6 
16bf 11 85 17			ld de, .keyworddef 
16c2 cd c6 16			call .genfile 
16c5 c9				ret 
16c6			 
16c6			; hl - points to file name 
16c6			; de - points to strings to add to file 
16c6			 
16c6			.genfile: 
16c6 e5				push hl 
16c7 d5				push de 
16c8			 
16c8 cd 18 0d			call clear_display 
16cb 3e 00			ld a, display_row_1 
16cd 11 f8 16			ld de, .genfiletxt 
16d0 cd 2b 0d			call str_at_display 
16d3 cd 3b 0d			call update_display 
16d6			 
16d6 d1				pop de 
16d7 e1				pop hl 
16d8			 
16d8			 
16d8 d5				push de 
16d9 cd 1f 08			call storage_create 
16dc				; id in hl 
16dc d1				pop de   ; table of strings to add 
16dd			 
16dd			.genloop: 
16dd			 
16dd e5				push hl ; save id for next time around 
16de d5				push de ; save de for next time around 
16df			 
16df eb				ex de, hl 
16e0 cd bb 23			call loadwordinhl 
16e3 eb				ex de, hl 
16e4			 
16e4				; need hl to be the id 
16e4				; need de to be the string ptr 
16e4				 
16e4 cd 0c 0b			call storage_append 
16e7			 
16e7 d1				pop de 
16e8 e1				pop hl 
16e9			 
16e9 13				inc de 
16ea 13				inc de 
16eb			 
16eb 1a				ld a,(de) 
16ec fe 00			cp 0 
16ee 20 ed			jr nz, .genloop 
16f0 13				inc de 
16f1 1a				ld a, (de) 
16f2 1b				dec de 
16f3 fe 00			cp 0 
16f5 20 e6			jr nz, .genloop	 
16f7			 
16f7 c9				ret 
16f8			 
16f8 .. 00		.genfiletxt:  db "Creating file...",0 
1709			 
1709			.utilwordef: 
1709 9d 62			dw strncpy 
170b 79 62			dw type 
170d 46 62			dw clrstack 
170f ff 61			dw longread 
1711 fe 62			dw start1 
1713 0e 63			dw start2 
1715 1f 63			dw start3b 
1717 9a 63			dw start3c 
1719 fa 63			dw list 
171b 00 00			dw 0 
171d			 
171d			.lsworddef: 
171d 1f 63			dw start3b 
171f 00 00			dw 0 
1721			 
1721			.edworddef: 
1721 8d 5e			dw edit1 
1723 ae 5e			dw edit2 
1725 e3 5e			dw edit3 
1727 00 00			dw 0 
1729			 
1729			.demoworddef: 
1729 42 68			dw test5 
172b 7a 68			dw test6 
172d b2 68			dw test7 
172f c6 68			dw test8 
1731 f2 68			dw test9 
1733 08 69			dw test10 
1735 4c 69			dw game1 
1737 5d 69			dw game1a 
1739 bf 69			dw game1b 
173b f4 69			dw game1c 
173d 2a 6a			dw game1d 
173f 5b 6a			dw game1s 
1741 6f 6a			dw game1t 
1743 84 6a			dw game1f 
1745 b8 6a			dw game1z 
1747 fc 6a			dw game1zz 
1749 65 6b			dw ssv2 
174b 9b 6b			dw ssv3 
174d b7 6b			dw ssv4 
174f d3 6b			dw ssv5 
1751 ec 6b			dw ssv1 
1753 34 6c			dw ssv1cpm	 
1755 8b 6c			dw game2b 
1757 f9 6c			dw game2bf 
1759 43 6d			dw game2mba 
175b d9 6d			dw game2mbas	 
175d fe 6d			dw game2mbht 
175f 0d 6e			dw game2mbms 
1761 1b 6e			dw game2mb 
1763 98 6e			dw game3w 
1765 c6 6e			dw game3p 
1767 e4 6e			dw game3sc 
1769 15 6f			dw game3vsi 
176b 41 6f			dw game3vs 
176d 00 00			dw 0 
176f			 
176f			 
176f			.spiworddef: 
176f			 
176f 1b 5f		    dw spi1 
1771 74 5f		    dw spi2 
1773 02 60		    dw spi3 
1775 aa 5f		    dw spi4 
1777 d5 5f		    dw spi5 
1779 68 60		    dw spi6 
177b bd 60		    dw spi7 
177d			 
177d 15 61		    dw spi8 
177f 34 61		    dw spi9 
1781 8c 61		    dw spi10 
1783 00 00		    dw 0 
1785			 
1785			.keyworddef: 
1785			 
1785 80 6f			dw keyup 
1787 8e 6f			dw keydown 
1789 9e 6f			dw keyleft 
178b ae 6f			dw keyright 
178d bf 6f			dw 	keyf1 
178f cd 6f			dw keyf2 
1791 db 6f			dw keyf3 
1793 e9 6f			dw keyf4 
1795 f7 6f			dw keyf5 
1797 05 70			dw keyf6 
1799 13 70			dw keyf7 
179b 21 70			dw keyf8 
179d 2f 70			dw keyf9 
179f 3d 70			dw keyf10 
17a1 4c 70			dw keyf11 
17a3 5b 70			dw keyf12 
17a5 6a 70			dw keytab 
17a7 79 70			dw keycr 
17a9 87 70			dw keyhome 
17ab 97 70			dw keyend 
17ad a6 70			dw keybs 
17af 00 00			dw 0 
17b1			 
17b1			.crstart: 
17b1 00 1c			dw crs_s1 
17b3 09 1c			dw crs_s2 
17b5 12 1c			dw crs_s3 
17b7 21 1c			dw crs_s4 
17b9 28 1c			dw crs_s5 
17bb 34 1c			dw crs_s6 
17bd 00 00			dw 0 
17bf			 
17bf			endif 
17bf			 
17bf			 
17bf			if STORAGE_SE 
17bf			 
17bf			config_fdir: 
17bf				; using the scratch dir go through and release the memory allocated for each string 
17bf				 
17bf 21 c8 f1			ld hl, scratch 
17c2 5e			.cfdir:	ld e,(hl) 
17c3 23				inc hl 
17c4 56				ld d,(hl) 
17c5 23				inc hl 
17c6			 
17c6 eb				ex de, hl 
17c7 cd 75 0f			call ishlzero 
17ca c8				ret z     ; return on null pointer 
17cb cd dd 14			call free 
17ce eb				ex de, hl 
17cf 18 f1			jr .cfdir 
17d1			 
17d1			 
17d1 c9				ret 
17d2			 
17d2			 
17d2			config_dir: 
17d2			 
17d2				; for the config menus that need to build a directory of storage call this routine 
17d2				; it will construct a menu in scratch to pass to menu 
17d2			 
17d2				; open storage device 
17d2			 
17d2				; execute DIR to build a list of files and their ids into scratch in menu format 
17d2				; once the menu has finished then will need to call config_fdir to release the strings 
17d2				 
17d2				; c = number items 
17d2			 
17d2				 
17d2 cd cd 04			call storage_get_block_0 
17d5			 
17d5 21 81 fa			ld hl, store_page     ; get current id count 
17d8 46				ld b, (hl) 
17d9 0e 00			ld c, 0    ; count of files   
17db			 
17db			 
17db 21 c8 f1			ld hl, scratch 
17de 22 78 fa			ld (store_tmp2), hl    ; location to poke strings 
17e1			 
17e1				; check for empty drive 
17e1			 
17e1 3e 00			ld a, 0 
17e3 b8				cp b 
17e4 ca 7e 18			jp z, .dirdone 
17e7			 
17e7				 
17e7					if DEBUG_FORTH_WORDS 
17e7						DMARK "Cdc" 
17e7 f5				push af  
17e8 3a fc 17			ld a, (.dmark)  
17eb 32 6e fe			ld (debug_mark),a  
17ee 3a fd 17			ld a, (.dmark+1)  
17f1 32 6f fe			ld (debug_mark+1),a  
17f4 3a fe 17			ld a, (.dmark+2)  
17f7 32 70 fe			ld (debug_mark+2),a  
17fa 18 03			jr .pastdmark  
17fc ..			.dmark: db "Cdc"  
17ff f1			.pastdmark: pop af  
1800			endm  
# End of macro DMARK
1800						CALLMONITOR 
1800 cd c1 19			call break_point_state  
1803				endm  
# End of macro CALLMONITOR
1803					endif 
1803			 
1803			 
1803			.diritem:	 
1803 c5				push bc 
1804				; for each of the current ids do a search for them and if found push to stack 
1804			 
1804 21 40 00				ld hl, STORE_BLOCK_PHY 
1807 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1809 58					ld e,b 
180a			 
180a cd 4f 07				call storage_findnextid 
180d			 
180d			 
180d					; if found hl will be non zero 
180d			 
180d cd 75 0f				call ishlzero 
1810 28 69				jr z, .dirnotfound 
1812			 
1812					; increase count 
1812			 
1812 c1					pop bc	 
1813 0c					inc c 
1814 c5					push bc 
1815					 
1815			 
1815					; get file header and push the file name 
1815			 
1815 11 81 fa				ld de, store_page 
1818 cd 1c 04				call storage_read_block 
181b			 
181b					; push file id to stack 
181b				 
181b 3a 81 fa				ld a, (store_page) 
181e 26 00				ld h, 0 
1820 6f					ld l, a 
1821			 
1821					;call forth_push_numhl 
1821					; TODO store id 
1821			 
1821 e5					push hl 
1822			 
1822					; push extent count to stack  
1822				 
1822 21 84 fa				ld hl, store_page+3 
1825			 
1825					; get file name length 
1825			 
1825 cd aa 13				call strlenz   
1828			 
1828 23					inc hl   ; cover zero term 
1829 23					inc hl  ; stick the id at the end of the area 
182a			 
182a e5					push hl 
182b c1					pop bc    ; move length to bc 
182c			 
182c cd 13 14				call malloc 
182f			 
182f					; TODO save malloc area to scratch 
182f			 
182f eb					ex de, hl 
1830 2a 78 fa				ld hl, (store_tmp2) 
1833 73					ld (hl), e 
1834 23					inc hl 
1835 72					ld (hl), d 
1836 23					inc hl 
1837 22 78 fa				ld (store_tmp2), hl 
183a			 
183a					 
183a			 
183a					;pop hl   ; get source 
183a			;		ex de, hl    ; swap aronund	 
183a			 
183a 21 84 fa				ld hl, store_page+3 
183d					if DEBUG_FORTH_WORDS 
183d						DMARK "CFd" 
183d f5				push af  
183e 3a 52 18			ld a, (.dmark)  
1841 32 6e fe			ld (debug_mark),a  
1844 3a 53 18			ld a, (.dmark+1)  
1847 32 6f fe			ld (debug_mark+1),a  
184a 3a 54 18			ld a, (.dmark+2)  
184d 32 70 fe			ld (debug_mark+2),a  
1850 18 03			jr .pastdmark  
1852 ..			.dmark: db "CFd"  
1855 f1			.pastdmark: pop af  
1856			endm  
# End of macro DMARK
1856						CALLMONITOR 
1856 cd c1 19			call break_point_state  
1859				endm  
# End of macro CALLMONITOR
1859					endif 
1859 ed b0				ldir 
185b			 
185b					; de is past string, move back one and store id 
185b					 
185b 1b					dec de 
185c			 
185c					; store file id 
185c			 
185c e1					pop hl 
185d eb					ex de,hl 
185e 73					ld (hl), e 
185f			 
185f					if DEBUG_FORTH_WORDS 
185f						DMARK "Cdi" 
185f f5				push af  
1860 3a 74 18			ld a, (.dmark)  
1863 32 6e fe			ld (debug_mark),a  
1866 3a 75 18			ld a, (.dmark+1)  
1869 32 6f fe			ld (debug_mark+1),a  
186c 3a 76 18			ld a, (.dmark+2)  
186f 32 70 fe			ld (debug_mark+2),a  
1872 18 03			jr .pastdmark  
1874 ..			.dmark: db "Cdi"  
1877 f1			.pastdmark: pop af  
1878			endm  
# End of macro DMARK
1878						CALLMONITOR 
1878 cd c1 19			call break_point_state  
187b				endm  
# End of macro CALLMONITOR
187b					endif 
187b					 
187b			.dirnotfound: 
187b c1					pop bc     
187c 10 85				djnz .diritem 
187e				 
187e			.dirdone:	 
187e			 
187e 3e 00				ld a, 0 
1880 2a 78 fa				ld hl, (store_tmp2) 
1883 77					ld (hl), a 
1884 23					inc hl 
1885 77					ld (hl), a 
1886 23					inc hl 
1887					; push a count of the dir items found 
1887			 
1887			;		ld h, 0 
1887			;		ld l, c 
1887			 
1887 c9				ret 
1888			 
1888			endif 
1888			 
1888			 
1888			; Settings 
1888			; Run  
1888			 
1888			 
1888			 
1888			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1888			;;hd_menu2:   db "        2: Editor",0   
1888			;hd_menu2:   db "        2: Editor       6: Menu",0   
1888			;hd_menu3:   db "        3: Storage",0 
1888			;hd_menu4:   db "0=quit  4: Debug",0 
1888			;hd_don:     db "ON",0 
1888			;hd_doff:     db "OFF",0 
1888			; 
1888			; 
1888			; 
1888			;hardware_diags_old:       
1888			; 
1888			;.diagmenu: 
1888			;	call clear_display 
1888			;	ld a, display_row_1 
1888			;	ld de, hd_menu1 
1888			;	call str_at_display 
1888			; 
1888			;	ld a, display_row_2 
1888			;	ld de, hd_menu2 
1888			;	call str_at_display 
1888			; 
1888			;	ld a, display_row_3 
1888			;	ld de, hd_menu3 
1888			;	call str_at_display 
1888			; 
1888			;	ld a,  display_row_4 
1888			;	ld de, hd_menu4 
1888			;	call str_at_display 
1888			; 
1888			;	; display debug state 
1888			; 
1888			;	ld de, hd_don 
1888			;	ld a, (os_view_disable) 
1888			;	cp 0 
1888			;	jr z, .distog 
1888			;	ld de, hd_doff 
1888			;.distog: ld a, display_row_4+17 
1888			;	call str_at_display 
1888			; 
1888			;	call update_display 
1888			; 
1888			;	call cin_wait 
1888			; 
1888			; 
1888			; 
1888			;	cp '4' 
1888			;	jr nz, .diagn1 
1888			; 
1888			;	; debug toggle 
1888			; 
1888			;	ld a, (os_view_disable) 
1888			;	ld b, '*' 
1888			;	cp 0 
1888			;	jr z, .debtog 
1888			;	ld b, 0 
1888			;.debtog:	 
1888			;	ld a,b 
1888			;	ld (os_view_disable),a 
1888			; 
1888			;.diagn1: cp '0' 
1888			;	 ret z 
1888			; 
1888			;;	cp '1' 
1888			;;       jp z, matrix	 
1888			;;   TODO keyboard matrix test 
1888			; 
1888			;	cp '2' 
1888			;	jp z, .diagedit 
1888			; 
1888			;;	cp '6' 
1888			;;	jp z, .menutest 
1888			;;if ENABLE_BASIC 
1888			;;	cp '6' 
1888			;;	jp z, basic 
1888			;;endif 
1888			 ; 
1888			;	jp .diagmenu 
1888			; 
1888			; 
1888			;	ret 
1888			 
1888			 
1888			.debug_tog: 
1888 21 cf 18			ld hl, .menudebug 
188b				 
188b 3a b9 f1			ld a, (os_view_disable) 
188e fe 2a			cp '*' 
1890 20 04			jr nz,.tdon  
1892 3e 01			ld a, 1 
1894 18 02			jr .tog1 
1896 3e 00		.tdon: ld a, 0 
1898			 
1898			.tog1: 
1898 cd 49 0d			call menu 
189b fe 00			cp 0 
189d c8				ret z 
189e fe 01			cp 1    ; disable debug 
18a0 28 04			jr z, .dtog0 
18a2 3e 2a			ld a, '*' 
18a4 18 02			jr .dtogset 
18a6 3e 00		.dtog0: ld a, 0 
18a8 32 b9 f1		.dtogset:  ld (os_view_disable), a 
18ab c3 88 18			jp .debug_tog 
18ae			 
18ae			 
18ae			hardware_diags:       
18ae			 
18ae			.diagm: 
18ae 21 c1 18			ld hl, .menuitems 
18b1 3e 00			ld a, 0 
18b3 cd 49 0d			call menu 
18b6			 
18b6 fe 00		         cp 0 
18b8 c8				 ret z 
18b9			 
18b9 fe 02			cp 2 
18bb ca 1a 19			jp z, .diagedit 
18be			 
18be			;	cp '6' 
18be			;	jp z, .menutest 
18be			;if ENABLE_BASIC 
18be			;	cp '6' 
18be			;	jp z, basic 
18be			;endif 
18be			  
18be c3 ae 18			jp .diagm 
18c1			 
18c1				 
18c1 d5 18		.menuitems:   	dw .m1 
18c3 e0 18				dw .m2 
18c5 e7 18				dw .m3 
18c7 ef 18				dw .m5 
18c9 f5 18				dw .m5a 
18cb fe 18				dw .m5b 
18cd 00 00				dw 0 
18cf			 
18cf			.menudebug: 
18cf 07 19				dw .m6 
18d1 10 19				dw .m7 
18d3 00 00				dw 0 
18d5			 
18d5 .. 00		.m1:   db "Key Matrix",0 
18e0 .. 00		.m2:   db "Editor",0 
18e7 .. 00		.m3:   db "Storage",0 
18ef .. 00		.m5:   db "Sound",0 
18f5 .. 00		.m5a:  db "RAM Test",0 
18fe .. 00		.m5b:  db "LCD Test",0 
1907			 
1907 .. 00		.m6:   db "Debug ON",0 
1910 .. 00		.m7:   db "Debug OFF",0 
191a			 
191a			; debug editor 
191a			 
191a			.diagedit: 
191a			 
191a 21 c8 f1			ld hl, scratch 
191d			;	ld bc, 250 
191d			;	ldir 
191d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
191d 3e 00			ld a, 0 
191f 77				ld (hl), a 
1920 23				inc hl 
1921 77				ld (hl), a 
1922 23				inc hl 
1923 77				ld (hl), a 
1924			 
1924 cd 18 0d		        call clear_display 
1927 cd 3b 0d			call update_display 
192a				;ld a, 1 
192a				;ld (hardware_diag), a 
192a			.diloop: 
192a 3e 00			ld a, display_row_1 
192c 0e 00			ld c, 0 
192e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1930 1e 28			ld e, 40 
1932			 
1932 21 c8 f1			ld hl, scratch	 
1935 cd 79 0f			call input_str 
1938			 
1938 3e 28			ld a, display_row_2 
193a 11 c8 f1			ld de, scratch 
193d cd 2b 0d			call str_at_display 
1940 cd 3b 0d			call update_display 
1943			 
1943 c3 2a 19			jp .diloop 
1946			 
1946			 
1946			; pass word in hl 
1946			; a has display location 
1946			display_word_at: 
1946 f5				push af 
1947 e5				push hl 
1948 7c				ld a,h 
1949 21 cd f4			ld hl, os_word_scratch 
194c cd 4d 12			call hexout 
194f e1				pop hl 
1950 7d				ld a,l 
1951 21 cf f4			ld hl, os_word_scratch+2 
1954 cd 4d 12			call hexout 
1957 21 d1 f4			ld hl, os_word_scratch+4 
195a 3e 00			ld a,0 
195c 77				ld (hl),a 
195d 11 cd f4			ld de,os_word_scratch 
1960 f1				pop af 
1961 cd 2b 0d				call str_at_display 
1964 c9				ret 
1965			 
1965			display_ptr_state: 
1965			 
1965				; to restore afterwards 
1965			 
1965 d5				push de 
1966 c5				push bc 
1967 e5				push hl 
1968 f5				push af 
1969			 
1969				; for use in here 
1969			 
1969			;	push bc 
1969			;	push de 
1969			;	push hl 
1969			;	push af 
1969			 
1969 cd 18 0d			call clear_display 
196c			 
196c 11 3f 1b			ld de, .ptrstate 
196f 3e 00			ld a, display_row_1 
1971 cd 2b 0d			call str_at_display 
1974			 
1974				; display debug step 
1974			 
1974			 
1974 11 6e fe			ld de, debug_mark 
1977 3e 26			ld a, display_row_1+display_cols-2 
1979 cd 2b 0d			call str_at_display 
197c			 
197c				; display a 
197c 11 49 1b			ld de, .ptrcliptr 
197f 3e 28			ld a, display_row_2 
1981 cd 2b 0d			call str_at_display 
1984			 
1984 f1				pop af 
1985 2a 47 fa			ld hl,(cli_ptr) 
1988 3e 30			ld a, display_row_2+8 
198a cd 46 19			call display_word_at 
198d			 
198d			 
198d				; display hl 
198d			 
198d			 
198d 11 51 1b			ld de, .ptrclioptr 
1990 3e 32			ld a, display_row_2+10 
1992 cd 2b 0d			call str_at_display 
1995			; 
1995			;	pop hl 
1995 3e 35			ld a, display_row_2+13 
1997 2a 45 fa			ld hl,(cli_origptr) 
199a cd 46 19			call display_word_at 
199d			; 
199d			;	 
199d			;	; display de 
199d			 
199d			;	ld de, .regstatede 
199d			;	ld a, display_row_3 
199d			;	call str_at_display 
199d			 
199d			;	pop de 
199d			;	ld h,d 
199d			;	ld l, e 
199d			;	ld a, display_row_3+3 
199d			;	call display_word_at 
199d			 
199d			 
199d				; display bc 
199d			 
199d			;	ld de, .regstatebc 
199d			;	ld a, display_row_3+10 
199d			;	call str_at_display 
199d			 
199d			;	pop bc 
199d			;	ld h,b 
199d			;	ld l, c 
199d			;	ld a, display_row_3+13 
199d			;	call display_word_at 
199d			 
199d			 
199d				; display dsp 
199d			 
199d			;	ld de, .regstatedsp 
199d			;	ld a, display_row_4 
199d			;	call str_at_display 
199d			 
199d				 
199d			;	ld hl,(cli_data_sp) 
199d			;	ld a, display_row_4+4 
199d			;	call display_word_at 
199d			 
199d				; display rsp 
199d			 
199d 11 80 1b			ld de, .regstatersp 
19a0 3e 82			ld a, display_row_4+10 
19a2 cd 2b 0d			call str_at_display 
19a5			 
19a5				 
19a5 2a f9 f9			ld hl,(cli_ret_sp) 
19a8 3e 86			ld a, display_row_4+14 
19aa cd 46 19			call display_word_at 
19ad			 
19ad cd 3b 0d			call update_display 
19b0			 
19b0 cd 95 0c			call delay1s 
19b3 cd 95 0c			call delay1s 
19b6 cd 95 0c			call delay1s 
19b9			 
19b9			 
19b9 cd 04 20			call next_page_prompt 
19bc			 
19bc				; restore  
19bc			 
19bc f1				pop af 
19bd e1				pop hl 
19be c1				pop bc 
19bf d1				pop de 
19c0 c9				ret 
19c1			 
19c1			break_point_state: 
19c1 f5				push af 
19c2			 
19c2				; see if disabled 
19c2			 
19c2 3a b9 f1			ld a, (os_view_disable) 
19c5 fe 2a			cp '*' 
19c7 20 02			jr nz, .bpsgo 
19c9 f1				pop af 
19ca c9				ret 
19cb			 
19cb			.bpsgo: 
19cb f1				pop af 
19cc f5				push af 
19cd 22 b5 f1			ld (os_view_hl), hl 
19d0 ed 53 b3 f1		ld (os_view_de), de 
19d4 ed 43 b1 f1		ld (os_view_bc), bc 
19d8 e5				push hl 
19d9 6f				ld l, a 
19da 26 00			ld h, 0 
19dc 22 b7 f1			ld (os_view_af),hl 
19df			 
19df 21 b4 fd				ld hl, display_fb0 
19e2 22 cf fb				ld (display_fb_active), hl 
19e5 e1				pop hl	 
19e6			 
19e6 3e 31			ld a, '1' 
19e8 fe 2a		.bps1:  cp '*' 
19ea 20 03			jr nz, .bps1b 
19ec 32 b9 f1			ld (os_view_disable),a 
19ef fe 31		.bps1b:  cp '1' 
19f1 20 14			jr nz, .bps2 
19f3			 
19f3				; display reg 
19f3			 
19f3				 
19f3			 
19f3 3a b7 f1			ld a, (os_view_af) 
19f6 2a b5 f1			ld hl, (os_view_hl) 
19f9 ed 5b b3 f1		ld de, (os_view_de) 
19fd ed 4b b1 f1		ld bc, (os_view_bc) 
1a01 cd 9b 1a			call display_reg_state 
1a04 c3 87 1a			jp .bpschk 
1a07			 
1a07 fe 32		.bps2:  cp '2' 
1a09 20 08			jr nz, .bps3 
1a0b				 
1a0b				; display hl 
1a0b 2a b5 f1			ld hl, (os_view_hl) 
1a0e cd 85 1b			call display_dump_at_hl 
1a11			 
1a11 18 74			jr .bpschk 
1a13			 
1a13 fe 33		.bps3:  cp '3' 
1a15 20 08			jr nz, .bps4 
1a17			 
1a17			        ; display de 
1a17 2a b3 f1			ld hl, (os_view_de) 
1a1a cd 85 1b			call display_dump_at_hl 
1a1d			 
1a1d 18 68			jr .bpschk 
1a1f fe 34		.bps4:  cp '4' 
1a21 20 08			jr nz, .bps5 
1a23			 
1a23			        ; display bc 
1a23 2a b1 f1			ld hl, (os_view_bc) 
1a26 cd 85 1b			call display_dump_at_hl 
1a29			 
1a29 18 5c			jr .bpschk 
1a2b fe 35		.bps5:  cp '5' 
1a2d 20 08		        jr nz, .bps7 
1a2f			 
1a2f				; display cur ptr 
1a2f 2a 47 fa			ld hl, (cli_ptr) 
1a32 cd 85 1b			call display_dump_at_hl 
1a35			 
1a35 18 50			jr .bpschk 
1a37 fe 36		.bps7:  cp '6' 
1a39 20 08			jr nz, .bps8b 
1a3b				 
1a3b				; display cur orig ptr 
1a3b 2a 45 fa			ld hl, (cli_origptr) 
1a3e cd 85 1b			call display_dump_at_hl 
1a41 18 44			jr .bpschk 
1a43 fe 37		.bps8b:  cp '7' 
1a45 20 08			jr nz, .bps9 
1a47				 
1a47				; display dsp 
1a47 2a f5 f9			ld hl, (cli_data_sp) 
1a4a cd 85 1b			call display_dump_at_hl 
1a4d			 
1a4d 18 38			jr .bpschk 
1a4f fe 39		.bps9:  cp '9' 
1a51 20 05			jr nz, .bps8c 
1a53				 
1a53				; display SP 
1a53			;	ld hl, sp 
1a53 cd 85 1b			call display_dump_at_hl 
1a56			 
1a56 18 2f			jr .bpschk 
1a58 fe 38		.bps8c:  cp '8' 
1a5a 20 08			jr nz, .bps8d 
1a5c				 
1a5c				; display rsp 
1a5c 2a f9 f9			ld hl, (cli_ret_sp) 
1a5f cd 85 1b			call display_dump_at_hl 
1a62			 
1a62 18 23			jr .bpschk 
1a64 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1a66 20 05			jr nz, .bps8 
1a68 cd fa 1d			call monitor 
1a6b			 
1a6b 18 1a			jr .bpschk 
1a6d fe 30		.bps8:  cp '0' 
1a6f 20 16			jr nz, .bpschk 
1a71			 
1a71 21 13 fd				ld hl, display_fb1 
1a74 22 cf fb				ld (display_fb_active), hl 
1a77 cd 3b 0d				call update_display 
1a7a			 
1a7a				;ld a, (os_view_af) 
1a7a 2a b5 f1			ld hl, (os_view_hl) 
1a7d ed 5b b3 f1		ld de, (os_view_de) 
1a81 ed 4b b1 f1		ld bc, (os_view_bc) 
1a85 f1				pop af 
1a86 c9				ret 
1a87			 
1a87			.bpschk:   
1a87 cd 95 0c			call delay1s 
1a8a 3e 9f		ld a,display_row_4 + display_cols - 1 
1a8c 11 02 20		        ld de, endprg 
1a8f cd 2b 0d			call str_at_display 
1a92 cd 3b 0d			call update_display 
1a95 cd 00 78			call cin_wait 
1a98			 
1a98 c3 e8 19			jp .bps1 
1a9b			 
1a9b			 
1a9b			display_reg_state: 
1a9b			 
1a9b				; to restore afterwards 
1a9b			 
1a9b d5				push de 
1a9c c5				push bc 
1a9d e5				push hl 
1a9e f5				push af 
1a9f			 
1a9f				; for use in here 
1a9f			 
1a9f c5				push bc 
1aa0 d5				push de 
1aa1 e5				push hl 
1aa2 f5				push af 
1aa3			 
1aa3 cd 18 0d			call clear_display 
1aa6			 
1aa6 11 5b 1b			ld de, .regstate 
1aa9 3e 00			ld a, display_row_1 
1aab cd 2b 0d			call str_at_display 
1aae			 
1aae				; display debug step 
1aae			 
1aae			 
1aae 11 6e fe			ld de, debug_mark 
1ab1 3e 25			ld a, display_row_1+display_cols-3 
1ab3 cd 2b 0d			call str_at_display 
1ab6			 
1ab6				; display a 
1ab6 11 77 1b			ld de, .regstatea 
1ab9 3e 28			ld a, display_row_2 
1abb cd 2b 0d			call str_at_display 
1abe			 
1abe e1				pop hl 
1abf			;	ld h,0 
1abf			;	ld l, a 
1abf 3e 2b			ld a, display_row_2+3 
1ac1 cd 46 19			call display_word_at 
1ac4			 
1ac4			 
1ac4				; display hl 
1ac4			 
1ac4			 
1ac4 11 6b 1b			ld de, .regstatehl 
1ac7 3e 32			ld a, display_row_2+10 
1ac9 cd 2b 0d			call str_at_display 
1acc			 
1acc e1				pop hl 
1acd 3e 35			ld a, display_row_2+13 
1acf cd 46 19			call display_word_at 
1ad2			 
1ad2				 
1ad2				; display de 
1ad2			 
1ad2 11 6f 1b			ld de, .regstatede 
1ad5 3e 50			ld a, display_row_3 
1ad7 cd 2b 0d			call str_at_display 
1ada			 
1ada e1				pop hl 
1adb			;	ld h,d 
1adb			;	ld l, e 
1adb 3e 53			ld a, display_row_3+3 
1add cd 46 19			call display_word_at 
1ae0			 
1ae0			 
1ae0				; display bc 
1ae0			 
1ae0 11 73 1b			ld de, .regstatebc 
1ae3 3e 5a			ld a, display_row_3+10 
1ae5 cd 2b 0d			call str_at_display 
1ae8			 
1ae8 e1				pop hl 
1ae9			;	ld h,b 
1ae9			;	ld l, c 
1ae9 3e 5d			ld a, display_row_3+13 
1aeb cd 46 19			call display_word_at 
1aee			 
1aee			 
1aee				; display dsp 
1aee			 
1aee 11 7b 1b			ld de, .regstatedsp 
1af1 3e 78			ld a, display_row_4 
1af3 cd 2b 0d			call str_at_display 
1af6			 
1af6				 
1af6 2a f5 f9			ld hl,(cli_data_sp) 
1af9 3e 7c			ld a, display_row_4+4 
1afb cd 46 19			call display_word_at 
1afe			 
1afe				; display rsp 
1afe			 
1afe 11 80 1b			ld de, .regstatersp 
1b01 3e 82			ld a, display_row_4+10 
1b03 cd 2b 0d			call str_at_display 
1b06			 
1b06				 
1b06 2a f9 f9			ld hl,(cli_ret_sp) 
1b09 3e 86			ld a, display_row_4+14 
1b0b cd 46 19			call display_word_at 
1b0e			 
1b0e cd 3b 0d			call update_display 
1b11			 
1b11			;	call delay1s 
1b11			;	call delay1s 
1b11			;	call delay1s 
1b11			 
1b11			 
1b11			;	call next_page_prompt 
1b11			 
1b11				; restore  
1b11			 
1b11 f1				pop af 
1b12 e1				pop hl 
1b13 c1				pop bc 
1b14 d1				pop de 
1b15 c9				ret 
1b16			 
1b16 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1b2a .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1b3f .. 00		.ptrstate:	db "Ptr State",0 
1b49 .. 00		.ptrcliptr:     db "cli_ptr",0 
1b51 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1b5b .. 00		.regstate:	db "Reg State (1/0)",0 
1b6b .. 00		.regstatehl:	db "HL:",0 
1b6f .. 00		.regstatede:	db "DE:",0 
1b73 .. 00		.regstatebc:	db "BC:",0 
1b77 .. 00		.regstatea:	db "A :",0 
1b7b .. 00		.regstatedsp:	db "DSP:",0 
1b80 .. 00		.regstatersp:	db "RSP:",0 
1b85			 
1b85			display_dump_at_hl: 
1b85 e5				push hl 
1b86 d5				push de 
1b87 c5				push bc 
1b88 f5				push af 
1b89			 
1b89 22 eb f4			ld (os_cur_ptr),hl	 
1b8c cd 18 0d			call clear_display 
1b8f cd 0c 1f			call dumpcont 
1b92			;	call delay1s 
1b92			;	call next_page_prompt 
1b92			 
1b92			 
1b92 f1				pop af 
1b93 c1				pop bc 
1b94 d1				pop de 
1b95 e1				pop hl 
1b96 c9				ret 
1b97			 
1b97			;if ENABLE_BASIC 
1b97			;	include "nascombasic.asm" 
1b97			;	basic: 
1b97			;	include "forth/FORTH.ASM" 
1b97			;endif 
1b97			 
1b97			; eof 
1b97			 
1b97			 
# End of file firmware_diags.asm
1b97			  
1b97			include "firmware_prompts.asm"  
1b97			; Prompts  
1b97			 
1b97			; boot messages 
1b97			 
1b97 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1bac .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1bbc			 
1bbc			 
1bbc			; config menus 
1bbc			 
1bbc .. 00		prom_c3: db "Add Dictionary To File",0 
1bd3			 
1bd3			if STARTUP_V1 
1bd3			prom_c2: db "Select Autoload File",0 
1bd3			prom_c2a: db "Disable Autoload File", 0 
1bd3			endif 
1bd3			 
1bd3			if STARTUP_V2 
1bd3 .. 00		prom_c2: db "Enable Autoload Files",0 
1be9 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c00			 
1c00 .. 00		crs_s1: db "*ls-word", 0 
1c09 .. 00		crs_s2: db "*ed-word", 0 
1c12 .. 00		crs_s3: db "*Demo-Programs", 0 
1c21 .. 00		crs_s4: db "*Utils", 0 
1c28 .. 00		crs_s5: db "*SPI-Addons", 0 
1c34 .. 00		crs_s6: db "*Key-constants", 0 
1c43			 
1c43			 
1c43			 
1c43			endif 
1c43 .. 00		prom_c2b: db "Select Storage Bank",0 
1c57 .. 00		prom_c4: db "Settings",0 
1c60 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1c7b .. 00		prom_m4b:   db "Monitor",0 
1c83 .. 00		prom_c1: db "Hardware Diags",0 
1c92			 
1c92			 
1c92			if STARTUP_V2 
1c92 .. 00		prom_c9: db "Create Startup Files",0 
1ca7			endif 
1ca7			 
1ca7 .. 00		prom_notav:    db "Feature not available",0 
1cbd .. 00		prom_empty:    db "",0 
1cbe			 
1cbe			; eof 
1cbe			 
# End of file firmware_prompts.asm
1cbe			  
1cbe			  
1cbe			; eof  
1cbe			  
# End of file firmware.asm
1cbe			 
1cbe			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1cbe			;if BASE_KEV  
1cbe			;baseram: equ 08000h 
1cbe			;endif 
1cbe			 
1cbe			;if BASE_SC114 
1cbe			;baseram:     equ    endofcode 
1cbe			;endif 
1cbe			 
1cbe			 
1cbe			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1cbe			 
1cbe			; start system 
1cbe			 
1cbe			coldstart: 
1cbe				; set sp 
1cbe				; di/ei 
1cbe			 
1cbe f3				di 
1cbf 31 fd ff			ld sp, tos 
1cc2			;	ei 
1cc2			 
1cc2			 
1cc2				; disable breakpoint by default 
1cc2			 
1cc2 3e 2a			ld a,'*' 
1cc4 32 b9 f1			ld (os_view_disable),a 
1cc7			 
1cc7				; init hardware 
1cc7			 
1cc7				; init keyboard and screen hardware 
1cc7			 
1cc7 cd 1c 00			call hardware_init 
1cca			 
1cca			 
1cca cd 95 0c			call delay1s 
1ccd 3e 58			ld a, display_row_3+8 
1ccf 11 03 00			ld de, buildtime 
1cd2 cd 2b 0d			call str_at_display 
1cd5 cd 3b 0d			call update_display 
1cd8			 
1cd8 cd 95 0c			call delay1s 
1cdb cd 95 0c			call delay1s 
1cde cd 95 0c			call delay1s 
1ce1			 
1ce1				; detect if any keys are held down to enable breakpoints at start up 
1ce1			 
1ce1 cd 11 78			call cin  
1ce4 fe 00			cp 0 
1ce6 28 03			jr z, .nokeys 
1ce8			 
1ce8				;call hardware_diags 
1ce8 cd d6 15			call config 
1ceb			 
1ceb			;	ld de, .bpen 
1ceb			;	ld a, display_row_4 
1ceb			;	call str_at_display 
1ceb			;	call update_display 
1ceb			; 
1ceb			;	ld a,0 
1ceb			;	ld (os_view_disable),a 
1ceb			; 
1ceb			;.bpwait: 
1ceb			;	call cin 
1ceb			;	cp 0 
1ceb			;	jr z, .bpwait 
1ceb			;	jr .nokeys 
1ceb			; 
1ceb			; 
1ceb			;.bpen:  db "Break points enabled!",0 
1ceb			 
1ceb			 
1ceb			 
1ceb			 
1ceb			 
1ceb			 
1ceb			.nokeys: 
1ceb			 
1ceb			 
1ceb				 
1ceb			 
1ceb			;jp  testkey 
1ceb			 
1ceb			;call storage_get_block_0 
1ceb			; 
1ceb			;ld hl, 0 
1ceb			;ld de, store_page 
1ceb			;call storage_read_block 
1ceb			 
1ceb				 
1ceb			;ld hl, 10 
1ceb			;ld de, store_page 
1ceb			;call storage_read_block 
1ceb			 
1ceb			 
1ceb			 
1ceb			 
1ceb			 
1ceb			;stop:	nop 
1ceb			;	jp stop 
1ceb			 
1ceb			 
1ceb			 
1ceb			main: 
1ceb cd 18 0d			call clear_display 
1cee cd 3b 0d			call update_display 
1cf1			 
1cf1			 
1cf1			 
1cf1			;	call testlcd 
1cf1			 
1cf1			 
1cf1			 
1cf1 cd 09 24			call forth_init 
1cf4			 
1cf4			 
1cf4			warmstart: 
1cf4 cd df 23			call forth_warmstart 
1cf7			 
1cf7				; run startup word load 
1cf7			        ; TODO prevent this running at warmstart after crash  
1cf7			 
1cf7				if STARTUP_ENABLE 
1cf7			 
1cf7					if STARTUP_V1 
1cf7			 
1cf7						if STORAGE_SE 
1cf7							call forth_autoload 
1cf7						endif 
1cf7						call forth_startup 
1cf7					endif 
1cf7			 
1cf7					if STARTUP_V2 
1cf7			 
1cf7						if STORAGE_SE 
1cf7 cd e3 72						call forth_autoload 
1cfa						else 
1cfa							call forth_startup 
1cfa						endif 
1cfa			 
1cfa			 
1cfa					endif 
1cfa			 
1cfa				endif 
1cfa			 
1cfa				; show free memory after boot 
1cfa 11 94 1d			ld de, freeram 
1cfd 3e 00			ld a, display_row_1 
1cff cd 2b 0d			call str_at_display 
1d02			 
1d02			; Or use heap_size word???? 
1d02 21 ae f1			ld hl, heap_end 
1d05 11 0e 80			ld de, heap_start 
1d08 ed 52			sbc hl, de 
1d0a e5				push hl 
1d0b 7c				ld a,h	         	 
1d0c 21 cd f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d0f cd 4d 12			call hexout 
1d12 e1			   	pop hl 
1d13			 
1d13 7d				ld a,l 
1d14 21 cf f4			ld hl, os_word_scratch+2 
1d17 cd 4d 12			call hexout 
1d1a 21 d1 f4			ld hl, os_word_scratch+4 
1d1d 3e 00			ld a, 0 
1d1f 77				ld (hl),a 
1d20 11 cd f4			ld de, os_word_scratch 
1d23 3e 0d			ld a, display_row_1 + 13 
1d25 cd 2b 0d			call str_at_display 
1d28 cd 3b 0d			call update_display 
1d2b			 
1d2b			 
1d2b				;call demo 
1d2b			 
1d2b			 
1d2b				; init scratch input area for cli commands 
1d2b			 
1d2b 21 ef f4			ld hl, os_cli_cmd 
1d2e 3e 00			ld a,0 
1d30 77				ld (hl),a 
1d31 23				inc hl 
1d32 77				ld (hl),a 
1d33			 
1d33 3e 00			ld a,0 
1d35 32 ee f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d38			 
1d38 32 eb f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d3b 32 ec f4			ld (os_cur_ptr+1),a	 
1d3e			 
1d3e 32 cd f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d41 32 ce f4			ld (os_word_scratch+1),a	 
1d44				 
1d44			 
1d44				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d44 21 ef f4			ld hl, os_cli_cmd 
1d47			 
1d47 3e 00			ld a, 0		 ; init cli input 
1d49 77				ld (hl), a 
1d4a 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d4c			cli: 
1d4c				; show cli prompt 
1d4c				;push af 
1d4c				;ld a, 0 
1d4c				;ld de, prompt 
1d4c				;call str_at_display 
1d4c			 
1d4c				;call update_display 
1d4c				;pop af 
1d4c				;inc a 
1d4c				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d4c 0e 00			ld c, 0 
1d4e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1d50 1e 28			ld e, 40 
1d52			 
1d52 21 ef f4			ld hl, os_cli_cmd 
1d55			 
1d55				STACKFRAME OFF $fefe $9f9f 
1d55				if DEBUG_STACK_IMB 
1d55					if OFF 
1d55						exx 
1d55						ld de, $fefe 
1d55						ld a, d 
1d55						ld hl, curframe 
1d55						call hexout 
1d55						ld a, e 
1d55						ld hl, curframe+2 
1d55						call hexout 
1d55						ld hl, $fefe 
1d55						push hl 
1d55						ld hl, $9f9f 
1d55						push hl 
1d55						exx 
1d55					endif 
1d55				endif 
1d55			endm 
# End of macro STACKFRAME
1d55			 
1d55 cd 79 0f			call input_str 
1d58			 
1d58				STACKFRAMECHK OFF $fefe $9f9f 
1d58				if DEBUG_STACK_IMB 
1d58					if OFF 
1d58						exx 
1d58						ld hl, $9f9f 
1d58						pop de   ; $9f9f 
1d58						call cmp16 
1d58						jr nz, .spnosame 
1d58						ld hl, $fefe 
1d58						pop de   ; $fefe 
1d58						call cmp16 
1d58						jr z, .spfrsame 
1d58						.spnosame: call showsperror 
1d58						.spfrsame: nop 
1d58						exx 
1d58					endif 
1d58				endif 
1d58			endm 
# End of macro STACKFRAMECHK
1d58			 
1d58				; copy input to last command 
1d58			 
1d58 21 ef f4			ld hl, os_cli_cmd 
1d5b 11 ee f5			ld de, os_last_cmd 
1d5e 01 ff 00			ld bc, 255 
1d61 ed b0			ldir 
1d63			 
1d63				; wipe current buffer 
1d63			 
1d63			;	ld a, 0 
1d63			;	ld hl, os_cli_cmd 
1d63			;	ld de, os_cli_cmd+1 
1d63			;	ld bc, 254 
1d63			;	ldir 
1d63				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1d63			;	call strcpy 
1d63			;	ld a, 0 
1d63			;	ld (hl), a 
1d63			;	inc hl 
1d63			;	ld (hl), a 
1d63			;	inc hl 
1d63			;	ld (hl), a 
1d63			 
1d63				; switch frame buffer to program  
1d63			 
1d63 21 13 fd				ld hl, display_fb1 
1d66 22 cf fb				ld (display_fb_active), hl 
1d69			 
1d69			;	nop 
1d69				STACKFRAME ON $fbfe $8f9f 
1d69				if DEBUG_STACK_IMB 
1d69					if ON 
1d69						exx 
1d69						ld de, $fbfe 
1d69						ld a, d 
1d69						ld hl, curframe 
1d69						call hexout 
1d69						ld a, e 
1d69						ld hl, curframe+2 
1d69						call hexout 
1d69						ld hl, $fbfe 
1d69						push hl 
1d69						ld hl, $8f9f 
1d69						push hl 
1d69						exx 
1d69					endif 
1d69				endif 
1d69			endm 
# End of macro STACKFRAME
1d69				; first time into the parser so pass over the current scratch pad 
1d69 21 ef f4			ld hl,os_cli_cmd 
1d6c				; tokenise the entered statement(s) in HL 
1d6c cd 87 24			call forthparse 
1d6f			        ; exec forth statements in top of return stack 
1d6f cd c7 24			call forthexec 
1d72				;call forthexec_cleanup 
1d72			;	call parsenext 
1d72			 
1d72				STACKFRAMECHK ON $fbfe $8f9f 
1d72				if DEBUG_STACK_IMB 
1d72					if ON 
1d72						exx 
1d72						ld hl, $8f9f 
1d72						pop de   ; $8f9f 
1d72						call cmp16 
1d72						jr nz, .spnosame 
1d72						ld hl, $fbfe 
1d72						pop de   ; $fbfe 
1d72						call cmp16 
1d72						jr z, .spfrsame 
1d72						.spnosame: call showsperror 
1d72						.spfrsame: nop 
1d72						exx 
1d72					endif 
1d72				endif 
1d72			endm 
# End of macro STACKFRAMECHK
1d72				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1d72			 
1d72 3e 78			ld a, display_row_4 
1d74 11 a6 1d			ld de, endprog 
1d77			 
1d77 cd 3b 0d			call update_display		 
1d7a			 
1d7a cd 04 20			call next_page_prompt 
1d7d			 
1d7d				; switch frame buffer to cli 
1d7d			 
1d7d 21 b4 fd				ld hl, display_fb0 
1d80 22 cf fb				ld (display_fb_active), hl 
1d83			 
1d83			 
1d83 cd 18 0d		        call clear_display 
1d86 cd 3b 0d			call update_display		 
1d89			 
1d89 21 ef f4			ld hl, os_cli_cmd 
1d8c			 
1d8c 3e 00			ld a, 0		 ; init cli input 
1d8e 77				ld (hl), a 
1d8f			 
1d8f				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d8f			 
1d8f				; now on last line 
1d8f			 
1d8f				; TODO scroll screen up 
1d8f			 
1d8f				; TODO instead just clear screen and place at top of screen 
1d8f			 
1d8f			;	ld a, 0 
1d8f			;	ld (f_cursor_ptr),a 
1d8f			 
1d8f				;call clear_display 
1d8f				;call update_display 
1d8f			 
1d8f				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d8f 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d91 c3 4c 1d			jp cli 
1d94			 
1d94 .. 00		freeram: db "Free bytes: $",0 
1da2 ..			asc: db "1A2F" 
1da6 .. 00		endprog: db "End prog...",0 
1db2			 
1db2			testenter2:   
1db2 21 fa f1			ld hl,scratch+50 
1db5 22 eb f4			ld (os_cur_ptr),hl 
1db8 c3 4c 1d			jp cli 
1dbb			 
1dbb			testenter:  
1dbb			 
1dbb 21 a2 1d			ld hl,asc 
1dbe			;	ld a,(hl) 
1dbe			;	call nibble2val 
1dbe cd a3 12			call get_byte 
1dc1			 
1dc1			 
1dc1			;	ld a,(hl) 
1dc1			;	call atohex 
1dc1			 
1dc1			;	call fourehexhl 
1dc1 32 fa f1			ld (scratch+50),a 
1dc4			 
1dc4			 
1dc4			 
1dc4 21 a4 1d			ld hl,asc+2 
1dc7			;	ld a, (hl) 
1dc7			;	call nibble2val 
1dc7 cd a3 12			call get_byte 
1dca			 
1dca			;	call fourehexhl 
1dca 32 fc f1			ld (scratch+52),a 
1dcd				 
1dcd 21 fa f1			ld hl,scratch+50 
1dd0 22 eb f4			ld (os_cur_ptr),hl 
1dd3 c3 4c 1d			jp cli 
1dd6			 
1dd6			enter:	 
1dd6 3a cc f1			ld a,(scratch+4) 
1dd9 fe 00			cp 0 
1ddb 28 0c			jr z, .entercont 
1ddd				; no, not a null term line so has an address to work out.... 
1ddd			 
1ddd 21 ca f1			ld hl,scratch+2 
1de0 cd 03 13			call get_word_hl 
1de3			 
1de3 22 eb f4			ld (os_cur_ptr),hl	 
1de6 c3 4c 1d			jp cli 
1de9			 
1de9			 
1de9			.entercont:  
1de9			 
1de9 21 ca f1			ld hl, scratch+2 
1dec cd a3 12			call get_byte 
1def			 
1def 2a eb f4		   	ld hl,(os_cur_ptr) 
1df2 77					ld (hl),a 
1df3 23					inc hl 
1df4 22 eb f4				ld (os_cur_ptr),hl 
1df7				 
1df7			; get byte  
1df7			 
1df7			 
1df7 c3 4c 1d			jp cli 
1dfa			 
1dfa			 
1dfa			; basic monitor support 
1dfa			 
1dfa			monitor: 
1dfa				;  
1dfa cd 18 0d			call clear_display 
1dfd 3e 00			ld a, 0 
1dff 11 47 1e			ld de, .monprompt 
1e02 cd 2b 0d			call str_at_display 
1e05 cd 3b 0d			call update_display 
1e08			 
1e08				; get a monitor command 
1e08			 
1e08 0e 00			ld c, 0     ; entry at top left 
1e0a 16 64			ld d, 100   ; max buffer size 
1e0c 1e 0f			ld e, 15    ; input scroll area 
1e0e 3e 00			ld a, 0     ; init string 
1e10 21 c6 f3			ld hl, os_input 
1e13 77				ld (hl), a 
1e14 23				inc hl 
1e15 77				ld (hl), a 
1e16 21 c6 f3			ld hl, os_input 
1e19 3e 01			ld a, 1     ; init string 
1e1b cd 79 0f			call input_str 
1e1e			 
1e1e cd 18 0d		        call clear_display 
1e21 cd 3b 0d			call update_display		 
1e24			 
1e24 3a c6 f3			ld a, (os_input) 
1e27 cd a1 13			call toUpper 
1e2a fe 48		        cp 'H' 
1e2c 28 6f		        jr z, .monhelp 
1e2e fe 44			cp 'D'		; dump 
1e30 ca be 1e			jp z, .mondump	 
1e33 fe 43			cp 'C'		; dump 
1e35 ca d8 1e			jp z, .moncdump	 
1e38 fe 4d			cp 'M'		; dump 
1e3a ca 49 1e			jp z, .moneditstart 
1e3d fe 55			cp 'U'		; dump 
1e3f 28 14			jr z, .monedit	 
1e41 fe 51			cp 'Q'		; dump 
1e43 c8				ret z	 
1e44			 
1e44			 
1e44				; TODO "S" to access symbol by name and not need the address 
1e44				; TODO "F" to find a string in memory 
1e44			 
1e44 c3 fa 1d			jp monitor 
1e47			 
1e47 .. 00		.monprompt: db ">", 0 
1e49			 
1e49			.moneditstart: 
1e49				; get starting address 
1e49			 
1e49 21 c8 f3			ld hl,os_input+2 
1e4c cd 03 13			call get_word_hl 
1e4f			 
1e4f 22 eb f4			ld (os_cur_ptr),hl	 
1e52			 
1e52 c3 fa 1d			jp monitor 
1e55			 
1e55			.monedit: 
1e55				; get byte to load 
1e55			 
1e55 21 c8 f3			ld hl,os_input+2 
1e58 cd a3 12			call get_byte 
1e5b			 
1e5b				; get address to update 
1e5b 2a eb f4			ld hl, (os_cur_ptr) 
1e5e			 
1e5e				; update byte 
1e5e			 
1e5e 77				ld (hl), a 
1e5f			 
1e5f				; move to next address and save it 
1e5f			 
1e5f 23				inc hl 
1e60 22 eb f4			ld (os_cur_ptr),hl	 
1e63			 
1e63 c3 fa 1d			jp monitor 
1e66			 
1e66			 
1e66 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e7a .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e96 .. 00		.monhelptext3:  db "Q-Quit",0 
1e9d			        
1e9d			.monhelp: 
1e9d 3e 00			ld a, display_row_1 
1e9f 11 66 1e		        ld de, .monhelptext1 
1ea2			 
1ea2 cd 2b 0d			call str_at_display 
1ea5 3e 28			ld a, display_row_2 
1ea7 11 7a 1e		        ld de, .monhelptext2 
1eaa					 
1eaa cd 2b 0d			call str_at_display 
1ead 3e 50			ld a, display_row_3 
1eaf 11 96 1e		        ld de, .monhelptext3 
1eb2					 
1eb2 cd 2b 0d			call str_at_display 
1eb5 cd 3b 0d			call update_display		 
1eb8			 
1eb8 cd 04 20			call next_page_prompt 
1ebb c3 fa 1d			jp monitor 
1ebe			 
1ebe			.mondump:    
1ebe 21 c8 f3			ld hl,os_input+2 
1ec1 cd 03 13			call get_word_hl 
1ec4			 
1ec4 22 eb f4			ld (os_cur_ptr),hl	 
1ec7 cd 0c 1f			call dumpcont 
1eca 3e 78			ld a, display_row_4 
1ecc 11 a6 1d			ld de, endprog 
1ecf			 
1ecf cd 3b 0d			call update_display		 
1ed2			 
1ed2 cd 04 20			call next_page_prompt 
1ed5 c3 fa 1d			jp monitor 
1ed8			.moncdump: 
1ed8 cd 0c 1f			call dumpcont 
1edb 3e 78			ld a, display_row_4 
1edd 11 a6 1d			ld de, endprog 
1ee0			 
1ee0 cd 3b 0d			call update_display		 
1ee3			 
1ee3 cd 04 20			call next_page_prompt 
1ee6 c3 fa 1d			jp monitor 
1ee9			 
1ee9			 
1ee9			; TODO symbol access  
1ee9			 
1ee9			.symbols:     ;; A list of symbols that can be called up  
1ee9 b4 fd			dw display_fb0 
1eeb .. 00			db "fb0",0  
1eef 81 fa		     	dw store_page 
1ef1 .. 00			db "store_page",0 
1efc			 
1efc			 
1efc			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1efc			 
1efc 3a c9 f1			ld a,(scratch+1) 
1eff fe 00			cp 0 
1f01 28 09			jr z, dumpcont 
1f03			 
1f03				; no, not a null term line so has an address to work out.... 
1f03			 
1f03 21 ca f1			ld hl,scratch+2 
1f06 cd 03 13			call get_word_hl 
1f09			 
1f09 22 eb f4			ld (os_cur_ptr),hl	 
1f0c			 
1f0c			 
1f0c			 
1f0c			dumpcont: 
1f0c			 
1f0c				; dump bytes at ptr 
1f0c			 
1f0c			 
1f0c 3e 00			ld a, display_row_1 
1f0e 2a cf fb			ld hl, (display_fb_active) 
1f11 cd 4c 0f			call addatohl 
1f14 cd 3c 1f			call .dumpbyterow 
1f17			 
1f17 3e 28			ld a, display_row_2 
1f19 2a cf fb			ld hl, (display_fb_active) 
1f1c cd 4c 0f			call addatohl 
1f1f cd 3c 1f			call .dumpbyterow 
1f22			 
1f22			 
1f22 3e 50			ld a, display_row_3 
1f24 2a cf fb			ld hl, (display_fb_active) 
1f27 cd 4c 0f			call addatohl 
1f2a cd 3c 1f			call .dumpbyterow 
1f2d			 
1f2d 3e 78			ld a, display_row_4 
1f2f 2a cf fb			ld hl, (display_fb_active) 
1f32 cd 4c 0f			call addatohl 
1f35 cd 3c 1f			call .dumpbyterow 
1f38			 
1f38 cd 3b 0d			call update_display 
1f3b			;		jp cli 
1f3b c9				ret 
1f3c			 
1f3c			.dumpbyterow: 
1f3c			 
1f3c				;push af 
1f3c			 
1f3c e5				push hl 
1f3d			 
1f3d				; calc where to poke the ascii 
1f3d			if display_cols == 20 
1f3d				ld a, 16 
1f3d			else 
1f3d 3e 1f			ld a, 31 
1f3f			endif 
1f3f			 
1f3f cd 4c 0f			call addatohl 
1f42 22 cd f4			ld (os_word_scratch),hl  		; save pos for later 
1f45			 
1f45			 
1f45			; display decoding address 
1f45 2a eb f4		   	ld hl,(os_cur_ptr) 
1f48			 
1f48 7c				ld a,h 
1f49 e1				pop hl 
1f4a e5				push hl 
1f4b			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f4b cd 4d 12			call hexout 
1f4e 2a eb f4		   	ld hl,(os_cur_ptr) 
1f51			 
1f51 7d				ld a,l 
1f52 e1				pop hl 
1f53 23				inc hl 
1f54 23				inc hl 
1f55 e5				push hl 
1f56			;	ld hl, os_word_scratch+2 
1f56 cd 4d 12			call hexout 
1f59 e1				pop hl 
1f5a 23				inc hl 
1f5b 23				inc hl 
1f5c				;ld hl, os_word_scratch+4 
1f5c 3e 3a			ld a, ':' 
1f5e 77				ld (hl),a 
1f5f 23				inc hl 
1f60				;ld a, 0 
1f60				;ld (hl),a 
1f60				;ld de, os_word_scratch 
1f60				;pop af 
1f60				;push af 
1f60			;		ld a, display_row_2 
1f60			;		call str_at_display 
1f60			;		call update_display 
1f60			 
1f60			 
1f60			;pop af 
1f60			;	add 5 
1f60			 
1f60			if display_cols == 20 
1f60				ld b, 4 
1f60			else 
1f60 06 08			ld b, 8 
1f62			endif	 
1f62			 
1f62			.dumpbyte: 
1f62 c5				push bc 
1f63 e5				push hl 
1f64			 
1f64			 
1f64 2a eb f4		   	ld hl,(os_cur_ptr) 
1f67 7e					ld a,(hl) 
1f68			 
1f68					; poke the ascii to display 
1f68 2a cd f4				ld hl,(os_word_scratch) 
1f6b 77					ld (hl),a 
1f6c 23					inc hl 
1f6d 22 cd f4				ld (os_word_scratch),hl 
1f70			 
1f70					 
1f70			 
1f70			 
1f70 e1					pop hl 
1f71 e5					push hl 
1f72			 
1f72 cd 4d 12				call hexout 
1f75			 
1f75					 
1f75 2a eb f4		   	ld hl,(os_cur_ptr) 
1f78 23				inc hl 
1f79 22 eb f4		   	ld (os_cur_ptr),hl 
1f7c			 
1f7c e1					pop hl 
1f7d 23					inc hl 
1f7e 23					inc hl 
1f7f 23					inc hl 
1f80			 
1f80			 
1f80			 
1f80					;ld a,0 
1f80					;ld (os_word_scratch+2),a 
1f80					;pop af 
1f80					;push af 
1f80			 
1f80					;ld de, os_word_scratch 
1f80					;call str_at_display 
1f80			;		call update_display 
1f80			;		pop af 
1f80 c1					pop bc 
1f81 c6 03				add 3 
1f83 10 dd			djnz .dumpbyte 
1f85			 
1f85				 
1f85			 
1f85 c9				ret 
1f86			 
1f86			jump:	 
1f86			 
1f86 21 ca f1			ld hl,scratch+2 
1f89 cd 03 13			call get_word_hl 
1f8c				;ld hl,(scratch+2) 
1f8c				;call fourehexhl 
1f8c			 
1f8c 22 eb f4			ld (os_cur_ptr),hl	 
1f8f			 
1f8f e9				jp (hl) 
1f90			 
1f90			 
1f90			 
1f90			; TODO implement a basic monitor mode to start with 
1f90			 
1f90			 
1f90			 
1f90			 
1f90			 
1f90			 
1f90			 
1f90			 
1f90			 
1f90			; testing and demo code during development 
1f90			 
1f90			 
1f90 .. 00		str1: db "Enter some text...",0 
1fa3 .. 00		clear: db "                    ",0 
1fb8			 
1fb8			demo: 
1fb8			 
1fb8			 
1fb8			 
1fb8			;	call update_display 
1fb8			 
1fb8				; init scratch input area for testing 
1fb8 21 c8 f1			ld hl, scratch	 
1fbb 3e 00			ld a,0 
1fbd 77				ld (hl),a 
1fbe			 
1fbe			 
1fbe 3e 28		            LD   A, display_row_2 
1fc0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fc0 11 90 1f		            LD   DE, str1 
1fc3 cd 2b 0d			call str_at_display 
1fc6			 
1fc6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fc6			cloop:	 
1fc6 3e 50		            LD   A, display_row_3 
1fc8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fc8 11 a3 1f		            LD   DE, clear 
1fcb			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1fcb cd 2b 0d				call str_at_display 
1fce 3e 78			ld a, display_row_4 
1fd0 11 00 20			ld de, prompt 
1fd3			 
1fd3 cd 2b 0d				call str_at_display 
1fd6 cd 3b 0d			call update_display 
1fd9			 
1fd9 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1fdb 16 0a			ld d, 10 
1fdd 21 c8 f1			ld hl, scratch	 
1fe0 cd 79 0f			call input_str 
1fe3			 
1fe3			;	call clear_display 
1fe3			;'	call update_display 
1fe3			 
1fe3 3e 00		            LD   A, display_row_1 
1fe5			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fe5 11 a3 1f		            LD   DE, clear 
1fe8 cd 2b 0d				call str_at_display 
1feb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1feb 3e 00		            LD   A, display_row_1 
1fed			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fed 11 c8 f1		            LD   DE, scratch 
1ff0			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ff0 cd 2b 0d				call str_at_display 
1ff3 cd 3b 0d			call update_display 
1ff6			 
1ff6 3e 00				ld a,0 
1ff8 21 c8 f1			ld hl, scratch 
1ffb 77				ld (hl),a 
1ffc			 
1ffc 00				nop 
1ffd c3 c6 1f			jp cloop 
2000			 
2000			 
2000			 
2000			; OS Prompt 
2000			 
2000 .. 00		prompt: db ">",0 
2002 .. 00		endprg: db "?",0 
2004			 
2004			 
2004			; handy next page prompt 
2004			next_page_prompt: 
2004 e5				push hl 
2005 d5				push de 
2006 f5				push af 
2007 c5				push bc 
2008			 
2008 3e 9f			ld a,display_row_4 + display_cols - 1 
200a 11 02 20		        ld de, endprg 
200d cd 2b 0d			call str_at_display 
2010 cd 3b 0d			call update_display 
2013 cd 00 78			call cin_wait 
2016 c1				pop bc 
2017 f1				pop af 
2018 d1				pop de 
2019 e1				pop hl 
201a			 
201a			 
201a c9				ret 
201b			 
201b			 
201b			; forth parser 
201b			 
201b			; My forth kernel 
201b			include "forth_kernel.asm" 
201b			; 
201b			; kernel to the forth OS 
201b			 
201b			DS_TYPE_STR: equ 1     ; string type 
201b			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
201b			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
201b			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
201b			 
201b			FORTH_PARSEV1: equ 0 
201b			FORTH_PARSEV2: equ 0 
201b			FORTH_PARSEV3: equ 0 
201b			FORTH_PARSEV4: equ 0 
201b			FORTH_PARSEV5: equ 1 
201b			 
201b			;if FORTH_PARSEV5 
201b			;	FORTH_END_BUFFER: equ 0 
201b			;else 
201b			FORTH_END_BUFFER: equ 127 
201b			;endif 
201b			 
201b			FORTH_TRUE: equ 1 
201b			FORTH_FALSE: equ 0 
201b			 
201b			if FORTH_PARSEV4 
201b			include "forth_stackops.asm" 
201b			endif 
201b			 
201b			if FORTH_PARSEV5 
201b			include "forth_stackopsv5.asm" 
201b			 
201b			; Stack operations for v5 parser on wards 
201b			; * DATA stack 
201b			; * LOOP stack 
201b			; * RETURN stack 
201b			 
201b			 
201b			 
201b			FORTH_CHK_DSP_UNDER: macro 
201b				push hl 
201b				push de 
201b				ld hl,(cli_data_sp) 
201b				ld de, cli_data_stack 
201b				call cmp16 
201b				jp c, fault_dsp_under 
201b				pop de 
201b				pop hl 
201b				endm 
201b			 
201b			 
201b			FORTH_CHK_RSP_UNDER: macro 
201b				push hl 
201b				push de 
201b				ld hl,(cli_ret_sp) 
201b				ld de, cli_ret_stack 
201b				call cmp16 
201b				jp c, fault_rsp_under 
201b				pop de 
201b				pop hl 
201b				endm 
201b			 
201b			FORTH_CHK_LOOP_UNDER: macro 
201b				push hl 
201b				push de 
201b				ld hl,(cli_loop_sp) 
201b				ld de, cli_loop_stack 
201b				call cmp16 
201b				jp c, fault_loop_under 
201b				pop de 
201b				pop hl 
201b				endm 
201b			 
201b			FORTH_ERR_TOS_NOTSTR: macro 
201b				; TOSO might need more for checks when used 
201b				push af 
201b				ld a,(hl) 
201b				cp DS_TYPE_STR 
201b				jp nz, type_faultn   
201b				pop af 
201b				endm 
201b			 
201b			FORTH_ERR_TOS_NOTNUM: macro 
201b				push af 
201b				ld a,(hl) 
201b				cp DS_TYPE_INUM 
201b				jp nz, type_faultn   
201b				pop af 
201b				endm 
201b			 
201b			 
201b			; increase data stack pointer and save hl to it 
201b				 
201b			FORTH_DSP_NEXT: macro 
201b				call macro_forth_dsp_next 
201b				endm 
201b			 
201b			 
201b			macro_forth_dsp_next: 
201b				if DEBUG_FORTH_STACK_GUARD 
201b cd ce 70				call check_stacks 
201e				endif 
201e e5				push hl 
201f d5				push de 
2020 eb				ex de,hl 
2021 2a f5 f9			ld hl,(cli_data_sp) 
2024 23				inc hl 
2025 23				inc hl 
2026			 
2026			; PARSEV5 
2026 23				inc hl 
2027 22 f5 f9			ld (cli_data_sp),hl 
202a 73				ld (hl), e 
202b 23				inc hl 
202c 72				ld (hl), d 
202d d1				pop de 
202e e1				pop hl 
202f				if DEBUG_FORTH_STACK_GUARD 
202f cd ce 70				call check_stacks 
2032				endif 
2032 c9				ret 
2033			 
2033			 
2033			; increase ret stack pointer and save hl to it 
2033				 
2033			FORTH_RSP_NEXT: macro 
2033				call macro_forth_rsp_next 
2033				endm 
2033			 
2033			macro_forth_rsp_next: 
2033				if DEBUG_FORTH_STACK_GUARD 
2033 cd ce 70				call check_stacks 
2036				endif 
2036 e5				push hl 
2037 d5				push de 
2038 eb				ex de,hl 
2039 2a f9 f9			ld hl,(cli_ret_sp) 
203c 23				inc hl 
203d 23				inc hl 
203e 22 f9 f9			ld (cli_ret_sp),hl 
2041 73				ld (hl), e 
2042 23				inc hl 
2043 72				ld (hl), d 
2044 d1				pop de 
2045 e1				pop hl 
2046				if DEBUG_FORTH_STACK_GUARD 
2046 cd ce 70				call check_stacks 
2049				endif 
2049 c9				ret 
204a			 
204a			; get current ret stack pointer and save to hl  
204a				 
204a			FORTH_RSP_TOS: macro 
204a				call macro_forth_rsp_tos 
204a				endm 
204a			 
204a			macro_forth_rsp_tos: 
204a				;push de 
204a 2a f9 f9			ld hl,(cli_ret_sp) 
204d cd 85 20			call loadhlptrtohl 
2050				;ld e, (hl) 
2050				;inc hl 
2050				;ld d, (hl) 
2050				;ex de, hl 
2050					if DEBUG_FORTH_WORDS 
2050			;			DMARK "RST" 
2050						CALLMONITOR 
2050 cd c1 19			call break_point_state  
2053				endm  
# End of macro CALLMONITOR
2053					endif 
2053				;pop de 
2053 c9				ret 
2054			 
2054			; pop ret stack pointer 
2054				 
2054			FORTH_RSP_POP: macro 
2054				call macro_forth_rsp_pop 
2054				endm 
2054			 
2054			 
2054			macro_forth_rsp_pop: 
2054				if DEBUG_FORTH_STACK_GUARD 
2054			;		DMARK "RPP" 
2054 cd ce 70				call check_stacks 
2057					FORTH_CHK_RSP_UNDER 
2057 e5				push hl 
2058 d5				push de 
2059 2a f9 f9			ld hl,(cli_ret_sp) 
205c 11 b3 f9			ld de, cli_ret_stack 
205f cd 6a 0f			call cmp16 
2062 da e2 71			jp c, fault_rsp_under 
2065 d1				pop de 
2066 e1				pop hl 
2067				endm 
# End of macro FORTH_CHK_RSP_UNDER
2067				endif 
2067 e5				push hl 
2068 2a f9 f9			ld hl,(cli_ret_sp) 
206b			 
206b			 
206b				if FORTH_ENABLE_FREE 
206b			 
206b					; get pointer 
206b			 
206b					push de 
206b					push hl 
206b			 
206b					ld e, (hl) 
206b					inc hl 
206b					ld d, (hl) 
206b			 
206b					ex de, hl 
206b					call free 
206b			 
206b					pop hl 
206b					pop de 
206b			 
206b			 
206b				endif 
206b			 
206b			 
206b 2b				dec hl 
206c 2b				dec hl 
206d 22 f9 f9			ld (cli_ret_sp), hl 
2070				; do stack underflow checks 
2070 e1				pop hl 
2071				if DEBUG_FORTH_STACK_GUARD 
2071 cd ce 70				call check_stacks 
2074					FORTH_CHK_RSP_UNDER 
2074 e5				push hl 
2075 d5				push de 
2076 2a f9 f9			ld hl,(cli_ret_sp) 
2079 11 b3 f9			ld de, cli_ret_stack 
207c cd 6a 0f			call cmp16 
207f da e2 71			jp c, fault_rsp_under 
2082 d1				pop de 
2083 e1				pop hl 
2084				endm 
# End of macro FORTH_CHK_RSP_UNDER
2084				endif 
2084 c9				ret 
2085			 
2085			 
2085			 
2085			; routine to load word pointed to by hl into hl 
2085			 
2085			loadhlptrtohl: 
2085			 
2085 d5				push de 
2086 5e				ld e, (hl) 
2087 23				inc hl 
2088 56				ld d, (hl) 
2089 eb				ex de, hl 
208a d1				pop de 
208b			 
208b c9				ret 
208c			 
208c			 
208c			 
208c			 
208c			 
208c			; push a number held in HL onto the data stack 
208c			; entry point for pushing a value when already in hl used in function above 
208c			 
208c			forth_push_numhl: 
208c			 
208c e5				push hl    ; save value to push 
208d			 
208d			if DEBUG_FORTH_PUSH 
208d				; see if disabled 
208d			 
208d			 
208d f5				push af 
208e 3a b9 f1			ld a, (os_view_disable) 
2091 fe 2a			cp '*' 
2093 28 34			jr z, .pskip2 
2095 e5				push hl 
2096 e5			push hl 
2097 cd 18 0d			call clear_display 
209a e1			pop hl 
209b 7c				ld a,h 
209c 21 cd f4			ld hl, os_word_scratch 
209f cd 4d 12			call hexout 
20a2 e1				pop hl 
20a3 7d				ld a,l 
20a4 21 cf f4			ld hl, os_word_scratch+2 
20a7 cd 4d 12			call hexout 
20aa			 
20aa 21 d1 f4			ld hl, os_word_scratch+4 
20ad 3e 00			ld a,0 
20af 77				ld (hl),a 
20b0 11 cd f4			ld de,os_word_scratch 
20b3 3e 28				ld a, display_row_2 
20b5 cd 2b 0d				call str_at_display 
20b8 11 b3 5c			ld de, .push_num 
20bb 3e 00			ld a, display_row_1 
20bd			 
20bd cd 2b 0d				call str_at_display 
20c0			 
20c0			 
20c0 cd 3b 0d			call update_display 
20c3 cd 95 0c			call delay1s 
20c6 cd 95 0c			call delay1s 
20c9			.pskip2:  
20c9			 
20c9 f1				pop af 
20ca			endif	 
20ca			 
20ca			 
20ca				FORTH_DSP_NEXT 
20ca cd 1b 20			call macro_forth_dsp_next 
20cd				endm 
# End of macro FORTH_DSP_NEXT
20cd			 
20cd 2a f5 f9			ld hl, (cli_data_sp) 
20d0			 
20d0				; save item type 
20d0 3e 02			ld a,  DS_TYPE_INUM 
20d2 77				ld (hl), a 
20d3 23				inc hl 
20d4			 
20d4				; get word off stack 
20d4 d1				pop de 
20d5 7b				ld a,e 
20d6 77				ld (hl), a 
20d7 23				inc hl 
20d8 7a				ld a,d 
20d9 77				ld (hl), a 
20da			 
20da			if DEBUG_FORTH_PUSH 
20da 2b				dec hl 
20db 2b				dec hl 
20dc 2b				dec hl 
20dd						DMARK "PH5" 
20dd f5				push af  
20de 3a f2 20			ld a, (.dmark)  
20e1 32 6e fe			ld (debug_mark),a  
20e4 3a f3 20			ld a, (.dmark+1)  
20e7 32 6f fe			ld (debug_mark+1),a  
20ea 3a f4 20			ld a, (.dmark+2)  
20ed 32 70 fe			ld (debug_mark+2),a  
20f0 18 03			jr .pastdmark  
20f2 ..			.dmark: db "PH5"  
20f5 f1			.pastdmark: pop af  
20f6			endm  
# End of macro DMARK
20f6				CALLMONITOR 
20f6 cd c1 19			call break_point_state  
20f9				endm  
# End of macro CALLMONITOR
20f9			endif	 
20f9			 
20f9 c9				ret 
20fa			 
20fa			 
20fa			; Push a string to stack pointed to by hl 
20fa			 
20fa			forth_push_str: 
20fa			 
20fa			if DEBUG_FORTH_PUSH 
20fa						DMARK "PSQ" 
20fa f5				push af  
20fb 3a 0f 21			ld a, (.dmark)  
20fe 32 6e fe			ld (debug_mark),a  
2101 3a 10 21			ld a, (.dmark+1)  
2104 32 6f fe			ld (debug_mark+1),a  
2107 3a 11 21			ld a, (.dmark+2)  
210a 32 70 fe			ld (debug_mark+2),a  
210d 18 03			jr .pastdmark  
210f ..			.dmark: db "PSQ"  
2112 f1			.pastdmark: pop af  
2113			endm  
# End of macro DMARK
2113				CALLMONITOR 
2113 cd c1 19			call break_point_state  
2116				endm  
# End of macro CALLMONITOR
2116			endif	 
2116			    
2116 e5				push hl 
2117 e5				push hl 
2118			 
2118			;	ld a, 0   ; find end of string 
2118 cd aa 13			call strlenz 
211b			if DEBUG_FORTH_PUSH 
211b						DMARK "PQ2" 
211b f5				push af  
211c 3a 30 21			ld a, (.dmark)  
211f 32 6e fe			ld (debug_mark),a  
2122 3a 31 21			ld a, (.dmark+1)  
2125 32 6f fe			ld (debug_mark+1),a  
2128 3a 32 21			ld a, (.dmark+2)  
212b 32 70 fe			ld (debug_mark+2),a  
212e 18 03			jr .pastdmark  
2130 ..			.dmark: db "PQ2"  
2133 f1			.pastdmark: pop af  
2134			endm  
# End of macro DMARK
2134				CALLMONITOR 
2134 cd c1 19			call break_point_state  
2137				endm  
# End of macro CALLMONITOR
2137			endif	 
2137 eb				ex de, hl 
2138 e1				pop hl   ; get ptr to start of string 
2139			if DEBUG_FORTH_PUSH 
2139						DMARK "PQ3" 
2139 f5				push af  
213a 3a 4e 21			ld a, (.dmark)  
213d 32 6e fe			ld (debug_mark),a  
2140 3a 4f 21			ld a, (.dmark+1)  
2143 32 6f fe			ld (debug_mark+1),a  
2146 3a 50 21			ld a, (.dmark+2)  
2149 32 70 fe			ld (debug_mark+2),a  
214c 18 03			jr .pastdmark  
214e ..			.dmark: db "PQ3"  
2151 f1			.pastdmark: pop af  
2152			endm  
# End of macro DMARK
2152				CALLMONITOR 
2152 cd c1 19			call break_point_state  
2155				endm  
# End of macro CALLMONITOR
2155			endif	 
2155 19				add hl,de 
2156			if DEBUG_FORTH_PUSH 
2156						DMARK "PQE" 
2156 f5				push af  
2157 3a 6b 21			ld a, (.dmark)  
215a 32 6e fe			ld (debug_mark),a  
215d 3a 6c 21			ld a, (.dmark+1)  
2160 32 6f fe			ld (debug_mark+1),a  
2163 3a 6d 21			ld a, (.dmark+2)  
2166 32 70 fe			ld (debug_mark+2),a  
2169 18 03			jr .pastdmark  
216b ..			.dmark: db "PQE"  
216e f1			.pastdmark: pop af  
216f			endm  
# End of macro DMARK
216f				CALLMONITOR 
216f cd c1 19			call break_point_state  
2172				endm  
# End of macro CALLMONITOR
2172			endif	 
2172			 
2172 2b				dec hl    ; see if there is an optional trailing double quote 
2173 7e				ld a,(hl) 
2174 fe 22			cp '"' 
2176 20 03			jr nz, .strnoq 
2178 3e 00			ld a, 0      ; get rid of double quote 
217a 77				ld (hl), a 
217b 23			.strnoq: inc hl 
217c			 
217c 3e 00			ld a, 0 
217e 77				ld (hl), a     ; add null term and get rid of trailing double quote 
217f			 
217f 13				inc de ; add one for the type string 
2180 13				inc de ; add one for null term??? 
2181			 
2181				; tos is get string pointer again 
2181				; de contains space to allocate 
2181				 
2181 d5				push de 
2182			 
2182 eb				ex de, hl 
2183			 
2183				;push af 
2183			 
2183			if DEBUG_FORTH_PUSH 
2183						DMARK "PHm" 
2183 f5				push af  
2184 3a 98 21			ld a, (.dmark)  
2187 32 6e fe			ld (debug_mark),a  
218a 3a 99 21			ld a, (.dmark+1)  
218d 32 6f fe			ld (debug_mark+1),a  
2190 3a 9a 21			ld a, (.dmark+2)  
2193 32 70 fe			ld (debug_mark+2),a  
2196 18 03			jr .pastdmark  
2198 ..			.dmark: db "PHm"  
219b f1			.pastdmark: pop af  
219c			endm  
# End of macro DMARK
219c				CALLMONITOR 
219c cd c1 19			call break_point_state  
219f				endm  
# End of macro CALLMONITOR
219f			endif	 
219f cd 13 14			call malloc	; on ret hl now contains allocated memory 
21a2				if DEBUG_FORTH_MALLOC_GUARD 
21a2 cc 0b 5d				call z,malloc_error 
21a5				endif 
21a5			 
21a5				 
21a5 c1				pop bc    ; get length 
21a6 d1				pop de   ;  get string start    
21a7			 
21a7				; hl has destination from malloc 
21a7			 
21a7 eb				ex de, hl    ; prep for ldir 
21a8			 
21a8 d5				push de   ; save malloc area for DSP later 
21a9				;push hl   ; save malloc area for DSP later 
21a9			 
21a9			if DEBUG_FORTH_PUSH 
21a9						DMARK "PHc" 
21a9 f5				push af  
21aa 3a be 21			ld a, (.dmark)  
21ad 32 6e fe			ld (debug_mark),a  
21b0 3a bf 21			ld a, (.dmark+1)  
21b3 32 6f fe			ld (debug_mark+1),a  
21b6 3a c0 21			ld a, (.dmark+2)  
21b9 32 70 fe			ld (debug_mark+2),a  
21bc 18 03			jr .pastdmark  
21be ..			.dmark: db "PHc"  
21c1 f1			.pastdmark: pop af  
21c2			endm  
# End of macro DMARK
21c2				CALLMONITOR 
21c2 cd c1 19			call break_point_state  
21c5				endm  
# End of macro CALLMONITOR
21c5			endif	 
21c5			 
21c5			 
21c5 ed b0			ldir 
21c7			 
21c7			 
21c7				; push malloc to data stack     macro?????  
21c7			 
21c7				FORTH_DSP_NEXT 
21c7 cd 1b 20			call macro_forth_dsp_next 
21ca				endm 
# End of macro FORTH_DSP_NEXT
21ca			 
21ca				; save value and type 
21ca			 
21ca 2a f5 f9			ld hl, (cli_data_sp) 
21cd			 
21cd				; save item type 
21cd 3e 01			ld a,  DS_TYPE_STR 
21cf 77				ld (hl), a 
21d0 23				inc hl 
21d1			 
21d1				; get malloc word off stack 
21d1 d1				pop de 
21d2 73				ld (hl), e 
21d3 23				inc hl 
21d4 72				ld (hl), d 
21d5			 
21d5			 
21d5			 
21d5			if DEBUG_FORTH_PUSH 
21d5 2a f5 f9			ld hl, (cli_data_sp) 
21d8						DMARK "PHS" 
21d8 f5				push af  
21d9 3a ed 21			ld a, (.dmark)  
21dc 32 6e fe			ld (debug_mark),a  
21df 3a ee 21			ld a, (.dmark+1)  
21e2 32 6f fe			ld (debug_mark+1),a  
21e5 3a ef 21			ld a, (.dmark+2)  
21e8 32 70 fe			ld (debug_mark+2),a  
21eb 18 03			jr .pastdmark  
21ed ..			.dmark: db "PHS"  
21f0 f1			.pastdmark: pop af  
21f1			endm  
# End of macro DMARK
21f1				CALLMONITOR 
21f1 cd c1 19			call break_point_state  
21f4				endm  
# End of macro CALLMONITOR
21f4			;	ex de,hl 
21f4			endif	 
21f4				; in case of spaces, skip the ptr past the copied string 
21f4				;pop af 
21f4				;ld (cli_origptr),hl 
21f4			 
21f4 c9				ret 
21f5			 
21f5			 
21f5			 
21f5			; TODO ascii push input onto stack given hl to start of input 
21f5			 
21f5			; identify type 
21f5			; if starts with a " then a string 
21f5			; otherwise it is a number 
21f5			;  
21f5			; if a string 
21f5			;     scan for ending " to get length of string to malloc for + 1 
21f5			;     malloc 
21f5			;     put pointer to string on stack first byte flags as string 
21f5			; 
21f5			; else a number 
21f5			;    look for number format identifier 
21f5			;    $xx hex 
21f5			;    %xxxxx bin 
21f5			;    xxxxx decimal 
21f5			;    convert number to 16bit word.  
21f5			;    malloc word + 1 with flag to identiy as num 
21f5			;    put pointer to number on stack 
21f5			;   
21f5			;  
21f5			  
21f5			forth_apush: 
21f5				; kernel push 
21f5			 
21f5			if DEBUG_FORTH_PUSH 
21f5						DMARK "PSH" 
21f5 f5				push af  
21f6 3a 0a 22			ld a, (.dmark)  
21f9 32 6e fe			ld (debug_mark),a  
21fc 3a 0b 22			ld a, (.dmark+1)  
21ff 32 6f fe			ld (debug_mark+1),a  
2202 3a 0c 22			ld a, (.dmark+2)  
2205 32 70 fe			ld (debug_mark+2),a  
2208 18 03			jr .pastdmark  
220a ..			.dmark: db "PSH"  
220d f1			.pastdmark: pop af  
220e			endm  
# End of macro DMARK
220e				CALLMONITOR 
220e cd c1 19			call break_point_state  
2211				endm  
# End of macro CALLMONITOR
2211			endif	 
2211				; identify input type 
2211			 
2211 7e				ld a,(hl) 
2212 fe 22			cp '"' 
2214 28 0a			jr z, .fapstr 
2216 fe 24			cp '$' 
2218 ca 40 22			jp z, .faphex 
221b fe 25			cp '%' 
221d ca 28 22			jp z, .fapbin 
2220			;	cp 'b' 
2220			;	jp z, .fabin 
2220				; else decimal 
2220			 
2220				; TODO do decimal conversion 
2220				; decimal is stored as a 16bit word 
2220			 
2220				; by default everything is a string if type is not detected 
2220			.fapstr: ; 
2220 fe 22			cp '"' 
2222 20 01			jr nz, .strnoqu 
2224 23				inc hl 
2225			.strnoqu: 
2225 c3 fa 20			jp forth_push_str 
2228			 
2228			 
2228			 
2228			.fapbin:    ; push a binary string.  
2228 11 00 00			ld de, 0   ; hold a 16bit value 
222b			 
222b 23			.fapbinshift:	inc hl  
222c 7e				ld a,(hl) 
222d fe 00			cp 0     ; done scanning  
222f 28 0b			jr z, .fapbdone  	; got it in HL so push  
2231			 
2231				; left shift de 
2231 eb				ex de, hl	 
2232 29				add hl, hl 
2233			 
2233				; is 1 
2233 fe 31			cp '1' 
2235 20 02			jr nz, .binzero 
2237 cb 4d			bit 1, l 
2239			.binzero: 
2239 eb				ex de, hl	 ; save current de 
223a 18 ef			jr .fapbinshift 
223c			 
223c			.fapbdone: 
223c eb				ex de, hl 
223d c3 8c 20			jp forth_push_numhl 
2240			 
2240			 
2240			.faphex:   ; hex is always stored as a 16bit word 
2240				; skip number prefix 
2240 23				inc hl 
2241				; turn ascii into number 
2241 cd 03 13			call get_word_hl	; ret 16bit word in hl 
2244			 
2244 c3 8c 20			jp forth_push_numhl 
2247			 
2247 00				 nop 
2248			 
2248			.fabin:   ; TODO bin conversion 
2248			 
2248			 
2248 c9				ret 
2249			 
2249			 
2249			; get either a string ptr or a 16bit word from the data stack 
2249			 
2249			FORTH_DSP: macro 
2249				call macro_forth_dsp 
2249				endm 
2249			 
2249			macro_forth_dsp: 
2249				; data stack pointer points to current word on tos 
2249			 
2249 2a f5 f9			ld hl,(cli_data_sp) 
224c			 
224c				if DEBUG_FORTH_PUSH 
224c						DMARK "DSP" 
224c f5				push af  
224d 3a 61 22			ld a, (.dmark)  
2250 32 6e fe			ld (debug_mark),a  
2253 3a 62 22			ld a, (.dmark+1)  
2256 32 6f fe			ld (debug_mark+1),a  
2259 3a 63 22			ld a, (.dmark+2)  
225c 32 70 fe			ld (debug_mark+2),a  
225f 18 03			jr .pastdmark  
2261 ..			.dmark: db "DSP"  
2264 f1			.pastdmark: pop af  
2265			endm  
# End of macro DMARK
2265			 
2265 cd 40 5d				call display_data_sp 
2268				;call break_point_state 
2268				;rst 030h 
2268				CALLMONITOR 
2268 cd c1 19			call break_point_state  
226b				endm  
# End of macro CALLMONITOR
226b				endif 
226b			 
226b c9				ret 
226c			 
226c			; return hl to start of value on stack 
226c			 
226c			FORTH_DSP_VALUE: macro 
226c				call macro_forth_dsp_value 
226c				endm 
226c			 
226c			macro_forth_dsp_value: 
226c			 
226c				FORTH_DSP 
226c cd 49 22			call macro_forth_dsp 
226f				endm 
# End of macro FORTH_DSP
226f			 
226f d5				push de 
2270			 
2270 23				inc hl ; skip type 
2271			 
2271 5e				ld e, (hl) 
2272 23				inc hl 
2273 56				ld d, (hl) 
2274 eb				ex de,hl  
2275			 
2275 d1				pop de 
2276			 
2276 c9				ret 
2277			 
2277			; return hl to start of value to second item on stack 
2277			 
2277			FORTH_DSP_VALUEM1: macro 
2277				call macro_forth_dsp_value_m1 
2277				endm 
2277			 
2277			macro_forth_dsp_value_m1: 
2277			 
2277				FORTH_DSP 
2277 cd 49 22			call macro_forth_dsp 
227a				endm 
# End of macro FORTH_DSP
227a			 
227a 2b				dec hl 
227b 2b				dec hl 
227c			;	dec hl 
227c			 
227c d5				push de 
227d			 
227d 5e				ld e, (hl) 
227e 23				inc hl 
227f 56				ld d, (hl) 
2280 eb				ex de,hl  
2281			 
2281 d1				pop de 
2282			 
2282 c9				ret 
2283			 
2283				 
2283			 
2283			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2283			 
2283			FORTH_DSP_POP: macro 
2283				call macro_forth_dsp_pop 
2283				endm 
2283			 
2283			 
2283			; get the tos data type 
2283			 
2283			FORTH_DSP_TYPE:   macro 
2283			 
2283				;FORTH_DSP_VALUE 
2283				FORTH_DSP 
2283				 
2283				; hl points to value 
2283				; check type 
2283			 
2283				ld a,(hl) 
2283			 
2283				endm 
2283			 
2283			; load the tos value into hl 
2283			 
2283			 
2283			FORTH_DSP_VALUEHL:  macro 
2283				call macro_dsp_valuehl 
2283				endm 
2283			 
2283			 
2283			 
2283			macro_dsp_valuehl: 
2283				FORTH_DSP_VALUE 
2283 cd 6c 22			call macro_forth_dsp_value 
2286				endm 
# End of macro FORTH_DSP_VALUE
2286			 
2286				;FORTH_ERR_TOS_NOTNUM 
2286			 
2286				;inc hl   ; skip type id 
2286			 
2286			;	push de 
2286			; 
2286			;	ld e, (hl) 
2286			;	inc hl 
2286			;	ld d, (hl) 
2286			;	ex de,hl  
2286			 
2286			;	pop de 
2286			 
2286				if DEBUG_FORTH_PUSH 
2286						DMARK "DVL" 
2286 f5				push af  
2287 3a 9b 22			ld a, (.dmark)  
228a 32 6e fe			ld (debug_mark),a  
228d 3a 9c 22			ld a, (.dmark+1)  
2290 32 6f fe			ld (debug_mark+1),a  
2293 3a 9d 22			ld a, (.dmark+2)  
2296 32 70 fe			ld (debug_mark+2),a  
2299 18 03			jr .pastdmark  
229b ..			.dmark: db "DVL"  
229e f1			.pastdmark: pop af  
229f			endm  
# End of macro DMARK
229f				CALLMONITOR 
229f cd c1 19			call break_point_state  
22a2				endm  
# End of macro CALLMONITOR
22a2				endif 
22a2 c9				ret 
22a3			 
22a3			forth_apushstrhl:      
22a3				; push of string requires use of cli_origptr 
22a3				; bodge use 
22a3			 
22a3				; get current cli_origptr, save, update with temp pointer  
22a3 ed 5b 45 fa		ld de, (cli_origptr) 
22a7 22 45 fa			ld (cli_origptr), hl 
22aa d5				push de 
22ab cd f5 21			call forth_apush 
22ae d1				pop de 
22af ed 53 45 fa		ld (cli_origptr), de 
22b3 c9			        ret	 
22b4			 
22b4			 
22b4			; increase loop stack pointer and save hl to it 
22b4				 
22b4			FORTH_LOOP_NEXT: macro 
22b4				call macro_forth_loop_next 
22b4				;nop 
22b4				endm 
22b4			 
22b4			macro_forth_loop_next: 
22b4				if DEBUG_FORTH_STACK_GUARD 
22b4 cd ce 70				call check_stacks 
22b7				endif 
22b7 e5				push hl 
22b8 d5				push de 
22b9 eb				ex de,hl 
22ba 2a f7 f9			ld hl,(cli_loop_sp) 
22bd 23				inc hl 
22be 23				inc hl 
22bf					if DEBUG_FORTH_WORDS 
22bf						DMARK "LNX" 
22bf f5				push af  
22c0 3a d4 22			ld a, (.dmark)  
22c3 32 6e fe			ld (debug_mark),a  
22c6 3a d5 22			ld a, (.dmark+1)  
22c9 32 6f fe			ld (debug_mark+1),a  
22cc 3a d6 22			ld a, (.dmark+2)  
22cf 32 70 fe			ld (debug_mark+2),a  
22d2 18 03			jr .pastdmark  
22d4 ..			.dmark: db "LNX"  
22d7 f1			.pastdmark: pop af  
22d8			endm  
# End of macro DMARK
22d8						CALLMONITOR 
22d8 cd c1 19			call break_point_state  
22db				endm  
# End of macro CALLMONITOR
22db					endif 
22db 22 f7 f9			ld (cli_loop_sp),hl 
22de 73				ld (hl), e 
22df 23				inc hl 
22e0 72				ld (hl), d 
22e1 d1				pop de    ; been reversed so save a swap on restore 
22e2 e1				pop hl 
22e3				if DEBUG_FORTH_STACK_GUARD 
22e3 cd ce 70				call check_stacks 
22e6				endif 
22e6 c9				ret 
22e7			 
22e7			; get current ret stack pointer and save to hl  
22e7				 
22e7			FORTH_LOOP_TOS: macro 
22e7				call macro_forth_loop_tos 
22e7				endm 
22e7			 
22e7			macro_forth_loop_tos: 
22e7 d5				push de 
22e8 2a f7 f9			ld hl,(cli_loop_sp) 
22eb 5e				ld e, (hl) 
22ec 23				inc hl 
22ed 56				ld d, (hl) 
22ee eb				ex de, hl 
22ef d1				pop de 
22f0 c9				ret 
22f1			 
22f1			; pop loop stack pointer 
22f1				 
22f1			FORTH_LOOP_POP: macro 
22f1				call macro_forth_loop_pop 
22f1				endm 
22f1			 
22f1			 
22f1			macro_forth_loop_pop: 
22f1				if DEBUG_FORTH_STACK_GUARD 
22f1					DMARK "LPP" 
22f1 f5				push af  
22f2 3a 06 23			ld a, (.dmark)  
22f5 32 6e fe			ld (debug_mark),a  
22f8 3a 07 23			ld a, (.dmark+1)  
22fb 32 6f fe			ld (debug_mark+1),a  
22fe 3a 08 23			ld a, (.dmark+2)  
2301 32 70 fe			ld (debug_mark+2),a  
2304 18 03			jr .pastdmark  
2306 ..			.dmark: db "LPP"  
2309 f1			.pastdmark: pop af  
230a			endm  
# End of macro DMARK
230a cd ce 70				call check_stacks 
230d					FORTH_CHK_LOOP_UNDER 
230d e5				push hl 
230e d5				push de 
230f 2a f7 f9			ld hl,(cli_loop_sp) 
2312 11 31 f9			ld de, cli_loop_stack 
2315 cd 6a 0f			call cmp16 
2318 da e8 71			jp c, fault_loop_under 
231b d1				pop de 
231c e1				pop hl 
231d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
231d				endif 
231d e5				push hl 
231e 2a f7 f9			ld hl,(cli_loop_sp) 
2321 2b				dec hl 
2322 2b				dec hl 
2323 22 f7 f9			ld (cli_loop_sp), hl 
2326				; TODO do stack underflow checks 
2326 e1				pop hl 
2327				if DEBUG_FORTH_STACK_GUARD 
2327 cd ce 70				call check_stacks 
232a					FORTH_CHK_LOOP_UNDER 
232a e5				push hl 
232b d5				push de 
232c 2a f7 f9			ld hl,(cli_loop_sp) 
232f 11 31 f9			ld de, cli_loop_stack 
2332 cd 6a 0f			call cmp16 
2335 da e8 71			jp c, fault_loop_under 
2338 d1				pop de 
2339 e1				pop hl 
233a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
233a				endif 
233a c9				ret 
233b			 
233b			macro_forth_dsp_pop: 
233b			 
233b e5				push hl 
233c			 
233c				; release malloc data 
233c			 
233c				if DEBUG_FORTH_STACK_GUARD 
233c cd ce 70				call check_stacks 
233f					FORTH_CHK_DSP_UNDER 
233f e5				push hl 
2340 d5				push de 
2341 2a f5 f9			ld hl,(cli_data_sp) 
2344 11 2f f7			ld de, cli_data_stack 
2347 cd 6a 0f			call cmp16 
234a da dc 71			jp c, fault_dsp_under 
234d d1				pop de 
234e e1				pop hl 
234f				endm 
# End of macro FORTH_CHK_DSP_UNDER
234f				endif 
234f				;ld hl,(cli_data_sp) 
234f			if DEBUG_FORTH_DOT 
234f				DMARK "DPP" 
234f f5				push af  
2350 3a 64 23			ld a, (.dmark)  
2353 32 6e fe			ld (debug_mark),a  
2356 3a 65 23			ld a, (.dmark+1)  
2359 32 6f fe			ld (debug_mark+1),a  
235c 3a 66 23			ld a, (.dmark+2)  
235f 32 70 fe			ld (debug_mark+2),a  
2362 18 03			jr .pastdmark  
2364 ..			.dmark: db "DPP"  
2367 f1			.pastdmark: pop af  
2368			endm  
# End of macro DMARK
2368				CALLMONITOR 
2368 cd c1 19			call break_point_state  
236b				endm  
# End of macro CALLMONITOR
236b			endif	 
236b			 
236b			 
236b			if FORTH_ENABLE_DSPPOPFREE 
236b			 
236b				FORTH_DSP 
236b cd 49 22			call macro_forth_dsp 
236e				endm 
# End of macro FORTH_DSP
236e			 
236e 7e				ld a, (hl) 
236f fe 01			cp DS_TYPE_STR 
2371 20 23			jr nz, .skippopfree 
2373			 
2373				FORTH_DSP_VALUEHL 
2373 cd 83 22			call macro_dsp_valuehl 
2376				endm 
# End of macro FORTH_DSP_VALUEHL
2376 00				nop 
2377			if DEBUG_FORTH_DOT 
2377				DMARK "DPf" 
2377 f5				push af  
2378 3a 8c 23			ld a, (.dmark)  
237b 32 6e fe			ld (debug_mark),a  
237e 3a 8d 23			ld a, (.dmark+1)  
2381 32 6f fe			ld (debug_mark+1),a  
2384 3a 8e 23			ld a, (.dmark+2)  
2387 32 70 fe			ld (debug_mark+2),a  
238a 18 03			jr .pastdmark  
238c ..			.dmark: db "DPf"  
238f f1			.pastdmark: pop af  
2390			endm  
# End of macro DMARK
2390				CALLMONITOR 
2390 cd c1 19			call break_point_state  
2393				endm  
# End of macro CALLMONITOR
2393			endif	 
2393 cd dd 14			call free 
2396			.skippopfree: 
2396				 
2396			 
2396			endif 
2396			 
2396			if DEBUG_FORTH_DOT_KEY 
2396				DMARK "DP2" 
2396				CALLMONITOR 
2396			endif	 
2396			 
2396				; move pointer down 
2396			 
2396 2a f5 f9			ld hl,(cli_data_sp) 
2399 2b				dec hl 
239a 2b				dec hl 
239b			; PARSEV5 
239b 2b				dec hl 
239c 22 f5 f9			ld (cli_data_sp), hl 
239f			 
239f				if DEBUG_FORTH_STACK_GUARD 
239f cd ce 70				call check_stacks 
23a2					FORTH_CHK_DSP_UNDER 
23a2 e5				push hl 
23a3 d5				push de 
23a4 2a f5 f9			ld hl,(cli_data_sp) 
23a7 11 2f f7			ld de, cli_data_stack 
23aa cd 6a 0f			call cmp16 
23ad da dc 71			jp c, fault_dsp_under 
23b0 d1				pop de 
23b1 e1				pop hl 
23b2				endm 
# End of macro FORTH_CHK_DSP_UNDER
23b2				endif 
23b2			 
23b2 e1				pop hl 
23b3			 
23b3 c9				ret 
23b4			 
23b4			getwordathl: 
23b4				; hl points to an address 
23b4				; load hl with the word at that address 
23b4			 
23b4 d5				push de 
23b5			 
23b5 5e				ld e, (hl) 
23b6 23				inc hl 
23b7 56				ld d, (hl) 
23b8 eb				ex de, hl 
23b9			 
23b9 d1				pop de 
23ba c9				ret 
23bb			 
23bb			 
23bb			 
23bb			 
23bb			 
23bb			; eof 
23bb			 
# End of file forth_stackopsv5.asm
23bb			endif 
23bb			 
23bb			loadwordinhl:	 
23bb			 
23bb d5				push de 
23bc			 
23bc 5e				ld e, (hl) 
23bd 23				inc hl 
23be 56				ld d, (hl) 
23bf eb				ex de,hl  
23c0			 
23c0 d1				pop de 
23c1			 
23c1 c9				ret 
23c2			 
23c2			user_word_eol:  
23c2				; hl contains the pointer to where to create a linked list item from the end 
23c2				; of the user dict to continue on at the system word dict 
23c2				 
23c2				; poke the stub of the word list linked list to repoint to rom words 
23c2			 
23c2				; stub format 
23c2				; db   word id 
23c2				; dw    link to next word 
23c2			        ; db char length of token 
23c2				; db string + 0 term 
23c2				; db exec code....  
23c2			 
23c2 3e 00			ld a, WORD_SYS_ROOT     ; root word 
23c4 77				ld (hl), a		; word id 
23c5 23				inc hl 
23c6			 
23c6 11 91 25			ld de, sysdict 
23c9 73				ld (hl), e		; next word link ie system dict 
23ca 23				inc hl 
23cb 72				ld (hl), d		; next word link ie system dict 
23cc 23				inc hl	 
23cd			 
23cd			;	ld (hl), sysdict		; next word link ie system dict 
23cd			;	inc hl 
23cd			;	inc hl 
23cd			 
23cd			;	inc hl 
23cd			;	inc hl 
23cd			 
23cd 3e 02			ld a, 2			; word length is 0 
23cf 77				ld (hl), a	 
23d0 23				inc hl 
23d1			 
23d1 3e 7e			ld a, '~'			; word length is 0 
23d3 77				ld (hl), a	 
23d4 23				inc hl 
23d5 3e 00			ld a, 0			; save empty word 
23d7 77				ld (hl), a 
23d8			 
23d8 c9				ret 
23d9			 
23d9				 
23d9			 
23d9			forthexec_cleanup: 
23d9				FORTH_RSP_POP 
23d9 cd 54 20			call macro_forth_rsp_pop 
23dc				endm 
# End of macro FORTH_RSP_POP
23dc c9				ret 
23dd			 
23dd			forth_call_hl: 
23dd				; taking hl 
23dd e5				push hl 
23de c9				ret 
23df			 
23df			; this is called to reset Forth system but keep existing uwords etc 
23df			 
23df			forth_warmstart: 
23df				; setup stack over/under flow checks 
23df				if DEBUG_FORTH_STACK_GUARD 
23df cd b4 70				call chk_stk_init 
23e2				endif 
23e2			 
23e2				; init stack pointers  - * these stacks go upwards *  
23e2 21 b3 f9			ld hl, cli_ret_stack 
23e5 22 f9 f9			ld (cli_ret_sp), hl	 
23e8				; set bottom of stack 
23e8 3e 00			ld a,0 
23ea 77				ld (hl),a 
23eb 23				inc hl 
23ec 77				ld (hl),a 
23ed			 
23ed 21 2f f7			ld hl, cli_data_stack 
23f0 22 f5 f9			ld (cli_data_sp), hl	 
23f3				; set bottom of stack 
23f3 3e 00			ld a,0 
23f5 77				ld (hl),a 
23f6 23				inc hl 
23f7 77				ld (hl),a 
23f8			 
23f8 21 31 f9			ld hl, cli_loop_stack 
23fb 22 f7 f9			ld (cli_loop_sp), hl	 
23fe				; set bottom of stack 
23fe 3e 00			ld a,0 
2400 77				ld (hl),a 
2401 23				inc hl 
2402 77				ld (hl),a 
2403			 
2403				; init extent of current open file 
2403			 
2403 3e 00			ld a, 0 
2405 32 71 fa			ld (store_openext), a 
2408			 
2408 c9				ret 
2409			 
2409			 
2409			; Cold Start - this is called to setup the whole Forth system 
2409			 
2409			forth_init: 
2409			 
2409				; setup stack over/under flow checks 
2409			 
2409			;	if DEBUG_FORTH_STACK_GUARD 
2409			;		call chk_stk_init 
2409			;	endif 
2409			 
2409				; enable auto display updates (slow.....) 
2409			 
2409 3e 01			ld a, 1 
240b 32 43 fa			ld (cli_autodisplay), a 
240e			 
240e				; if storage is in use disable long reads for now 
240e 3e 00			ld a, 0 
2410 32 7c fa			ld (store_longread), a 
2413			 
2413			 
2413				; show start up screen 
2413			 
2413 cd 18 0d			call clear_display 
2416			 
2416 3e 00			ld a,0 
2418 32 65 fa			ld (f_cursor_ptr), a 
241b			 
241b				; set start of word list in start of ram - for use when creating user words 
241b			 
241b 21 00 80			ld hl, baseram 
241e 22 c5 f4			ld (os_last_new_uword), hl 
2421 cd c2 23			call user_word_eol 
2424				 
2424			;		call display_data_sp 
2424			;		call next_page_prompt 
2424			 
2424			 
2424			 
2424			 
2424 c9				ret 
2425			 
2425 .. 00		.bootforth: db " Forth Kernel Init ",0 
2439			 
2439			; TODO push to stack 
2439			 
2439			;  
2439			 
2439			if FORTH_PARSEV2 
2439			 
2439			 
2439				include "forth_parserv2.asm" 
2439			 
2439			endif 
2439			 
2439			 
2439			; parse cli version 1 
2439			 
2439			if FORTH_PARSEV1 
2439			 
2439			 
2439			 
2439			      include "forth_parserv1.asm" 
2439			endif 
2439				 
2439			if FORTH_PARSEV3 
2439			 
2439			 
2439			 
2439			      include "forth_parserv3.asm" 
2439				include "forth_wordsv3.asm" 
2439			endif 
2439			 
2439			if FORTH_PARSEV4 
2439			 
2439			 
2439			 
2439			      include "forth_parserv4.asm" 
2439				include "forth_wordsv4.asm" 
2439			endif 
2439			 
2439			if FORTH_PARSEV5 
2439			 
2439			 
2439			 
2439			      include "forth_parserv5.asm" 
2439			 
2439			 
2439			; A better parser without using malloc and string copies all over the place.  
2439			; Exec in situ should be faster 
2439			 
2439			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2439			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2439			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2439			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2439			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2439			WORD_SYS_END: equ 0   ; Opcode for all user words 
2439			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2439			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2439			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2439			 
2439			; Core word preamble macro 
2439			 
2439			CWHEAD:   macro nxtword opcode lit len opflags 
2439				db WORD_SYS_CORE+opcode             
2439				; internal op code number 
2439				dw nxtword            
2439				; link to next dict word block 
2439				db len + 1 
2439				; literal length of dict word inc zero term 
2439				db lit,0              
2439				; literal dict word 
2439			        ; TODO db opflags        
2439				endm 
2439			 
2439			 
2439			NEXTW: macro  
2439				jp macro_next 
2439				endm 
2439			 
2439			macro_next: 
2439			if DEBUG_FORTH_PARSE_KEY 
2439				DMARK "NXT" 
2439				CALLMONITOR 
2439			endif	 
2439			;	inc hl  ; skip token null term  
2439 ed 4b 47 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
243d ed 5b 45 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2441 2a c9 f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2444			if DEBUG_FORTH_PARSE_KEY 
2444				DMARK "}AA" 
2444				CALLMONITOR 
2444			endif	 
2444 c3 47 25			jp execnext 
2447				;jp exec1 
2447			       
2447			 
2447			 
2447			; Another go at the parser to compile  
2447			 
2447			 
2447			; TODO rework parser to change all of the string words to byte tokens 
2447			; TODO do a search for  
2447			 
2447			; TODO first run normal parser to zero term sections 
2447			; TODO for each word do a token look up to get the op code 
2447			; TODO need some means to flag to the exec that this is a byte code form    
2447			 
2447			 
2447			forthcompile: 
2447			 
2447			; 
2447			; line parse: 
2447			;       parse raw input buffer 
2447			;       tokenise the words 
2447			;       malloc new copy (for looping etc) 
2447			;       copy to malloc + current pc in line to start of string and add line term 
2447			;       save on new rsp 
2447			; 
2447			 
2447			; hl to point to the line to tokenise 
2447			 
2447			;	push hl 
2447 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
244a			 
244a			;	ld a,0		; string term on input 
244a			;	call strlent 
244a			 
244a			;	ld (os_tok_len), hl	 ; save string length 
244a			 
244a			;if DEBUG_FORTH_TOK 
244a			;	ex de,hl		 
244a			;endif 
244a			 
244a			;	pop hl 		; get back string pointer 
244a			 
244a			if DEBUG_FORTH_TOK 
244a						DMARK "TOc" 
244a				CALLMONITOR 
244a			endif 
244a 7e			.cptoken2:    ld a,(hl) 
244b 23				inc hl 
244c fe 7f			cp FORTH_END_BUFFER 
244e 28 29			jr z, .cptokendone2 
2450 fe 00			cp 0 
2452 28 25			jr z, .cptokendone2 
2454 fe 22			cp '"' 
2456 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2458 fe 20			cp ' ' 
245a 20 ee			jr nz,  .cptoken2 
245c			 
245c			; TODO consume comments held between ( and ) 
245c			 
245c				; we have a space so change to zero term for dict match later 
245c 2b				dec hl 
245d 3e 00			ld a,0 
245f 77				ld (hl), a 
2460 23				inc hl 
2461 18 e7			jr .cptoken2 
2463				 
2463			 
2463			.cptokenstr2: 
2463				; skip all white space until either eol (because forgot to term) or end double quote 
2463			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2463				;inc hl ; skip current double quote 
2463 7e				ld a,(hl) 
2464 23				inc hl 
2465 fe 22			cp '"' 
2467 28 e1			jr z, .cptoken2 
2469 fe 7f			cp FORTH_END_BUFFER 
246b 28 0c			jr z, .cptokendone2 
246d fe 00			cp 0 
246f 28 08			jr z, .cptokendone2 
2471 fe 20			cp ' ' 
2473 28 02			jr z, .cptmp2 
2475 18 ec			jr .cptokenstr2 
2477			 
2477			.cptmp2:	; we have a space so change to zero term for dict match later 
2477				;dec hl 
2477				;ld a,"-"	; TODO remove this when working 
2477				;ld (hl), a 
2477				;inc hl 
2477 18 ea			jr .cptokenstr2 
2479			 
2479			.cptokendone2: 
2479				;inc hl 
2479 3e 7f			ld a, FORTH_END_BUFFER 
247b 77				ld (hl),a 
247c 23				inc hl 
247d 3e 21			ld a, '!' 
247f 77				ld (hl),a 
2480			 
2480 2a c9 f4			ld hl,(os_tok_ptr) 
2483			         
2483			if DEBUG_FORTH_TOK 
2483						DMARK "Tc1" 
2483				CALLMONITOR 
2483			endif 
2483			 
2483				; push exec string to top of return stack 
2483				FORTH_RSP_NEXT 
2483 cd 33 20			call macro_forth_rsp_next 
2486				endm 
# End of macro FORTH_RSP_NEXT
2486 c9				ret 
2487			 
2487			; Another go at the parser need to simplify the process 
2487			 
2487			forthparse: 
2487			 
2487			; 
2487			; line parse: 
2487			;       parse raw input buffer 
2487			;       tokenise the words 
2487			;       malloc new copy (for looping etc) 
2487			;       copy to malloc + current pc in line to start of string and add line term 
2487			;       save on new rsp 
2487			; 
2487			 
2487			; hl to point to the line to tokenise 
2487			 
2487			;	push hl 
2487 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
248a			 
248a			;	ld a,0		; string term on input 
248a			;	call strlent 
248a			 
248a			;	ld (os_tok_len), hl	 ; save string length 
248a			 
248a			;if DEBUG_FORTH_TOK 
248a			;	ex de,hl		 
248a			;endif 
248a			 
248a			;	pop hl 		; get back string pointer 
248a			 
248a			if DEBUG_FORTH_TOK 
248a						DMARK "TOK" 
248a				CALLMONITOR 
248a			endif 
248a 7e			.ptoken2:    ld a,(hl) 
248b 23				inc hl 
248c fe 7f			cp FORTH_END_BUFFER 
248e 28 29			jr z, .ptokendone2 
2490 fe 00			cp 0 
2492 28 25			jr z, .ptokendone2 
2494 fe 22			cp '"' 
2496 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2498 fe 20			cp ' ' 
249a 20 ee			jr nz,  .ptoken2 
249c			 
249c			; TODO consume comments held between ( and ) 
249c			 
249c				; we have a space so change to zero term for dict match later 
249c 2b				dec hl 
249d 3e 00			ld a,0 
249f 77				ld (hl), a 
24a0 23				inc hl 
24a1 18 e7			jr .ptoken2 
24a3				 
24a3			 
24a3			.ptokenstr2: 
24a3				; skip all white space until either eol (because forgot to term) or end double quote 
24a3			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24a3				;inc hl ; skip current double quote 
24a3 7e				ld a,(hl) 
24a4 23				inc hl 
24a5 fe 22			cp '"' 
24a7 28 e1			jr z, .ptoken2 
24a9 fe 7f			cp FORTH_END_BUFFER 
24ab 28 0c			jr z, .ptokendone2 
24ad fe 00			cp 0 
24af 28 08			jr z, .ptokendone2 
24b1 fe 20			cp ' ' 
24b3 28 02			jr z, .ptmp2 
24b5 18 ec			jr .ptokenstr2 
24b7			 
24b7			.ptmp2:	; we have a space so change to zero term for dict match later 
24b7				;dec hl 
24b7				;ld a,"-"	; TODO remove this when working 
24b7				;ld (hl), a 
24b7				;inc hl 
24b7 18 ea			jr .ptokenstr2 
24b9			 
24b9			.ptokendone2: 
24b9				;inc hl 
24b9 3e 7f			ld a, FORTH_END_BUFFER 
24bb 77				ld (hl),a 
24bc 23				inc hl 
24bd 3e 21			ld a, '!' 
24bf 77				ld (hl),a 
24c0			 
24c0 2a c9 f4			ld hl,(os_tok_ptr) 
24c3			         
24c3			if DEBUG_FORTH_TOK 
24c3						DMARK "TK1" 
24c3				CALLMONITOR 
24c3			endif 
24c3			 
24c3				; push exec string to top of return stack 
24c3				FORTH_RSP_NEXT 
24c3 cd 33 20			call macro_forth_rsp_next 
24c6				endm 
# End of macro FORTH_RSP_NEXT
24c6 c9				ret 
24c7			 
24c7			; 
24c7			;	; malloc size + buffer pointer + if is loop flag 
24c7			;	ld hl,(os_tok_len) 		 ; get string length 
24c7			; 
24c7			;	ld a,l 
24c7			; 
24c7			;	cp 0			; we dont want to use a null string 
24c7			;	ret z 
24c7			; 
24c7			;;	add 3    ; prefix malloc with buffer for current word ptr 
24c7			; 
24c7			;	add 5     ; TODO when certain not over writing memory remove 
24c7			; 
24c7			;		 
24c7			; 
24c7			;if DEBUG_FORTH_TOK 
24c7			;			DMARK "TKE" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			; 
24c7			;	ld l,a 
24c7			;	ld h,0 
24c7			;;	push hl   ; save required space for the copy later 
24c7			;	call malloc 
24c7			;if DEBUG_FORTH_TOK 
24c7			;			DMARK "TKM" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			;	if DEBUG_FORTH_MALLOC_GUARD 
24c7			;		push af 
24c7			;		call ishlzero 
24c7			;;		ld a, l 
24c7			;;		add h 
24c7			;;		cp 0 
24c7			;		pop af 
24c7			;		 
24c7			;		call z,malloc_error 
24c7			;	endif 
24c7			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
24c7			; 
24c7			; 
24c7			;if DEBUG_FORTH_TOK 
24c7			;			DMARK "TKR" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			; 
24c7			;	FORTH_RSP_NEXT 
24c7			; 
24c7			;	;inc hl	 ; go past current buffer pointer 
24c7			;	;inc hl 
24c7			;	;inc hl   ; and past if loop flag 
24c7			;		; TODO Need to set flag  
24c7			; 
24c7			;	 
24c7			;	 
24c7			;	ex de,hl	; malloc is dest 
24c7			;	ld hl, (os_tok_len) 
24c7			;;	pop bc 
24c7			;	ld c, l                
24c7			;	ld b,0 
24c7			;	ld hl, (os_tok_ptr) 
24c7			; 
24c7			;if DEBUG_FORTH_TOK 
24c7			;			DMARK "TKT" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			; 
24c7			;	; do str cpy 
24c7			; 
24c7			;	ldir      ; copy byte in hl to de 
24c7			; 
24c7			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
24c7			; 
24c7			;if DEBUG_FORTH_TOK 
24c7			; 
24c7			;			DMARK "TKY" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			;	;ld a,0 
24c7			;	;ld a,FORTH_END_BUFFER 
24c7			;	ex de, hl 
24c7			;	;dec hl			 ; go back over the space delim at the end of word 
24c7			;	;ld (hl),a 
24c7			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
24c7			;	ld a,FORTH_END_BUFFER 
24c7			;	ld (hl),a 
24c7			;	inc hl 
24c7			;	ld a,FORTH_END_BUFFER 
24c7			;	ld (hl),a 
24c7			; 
24c7			;	; init the malloc area data 
24c7			;	; set pc for in current area 
24c7			;	;ld hl, (os_tok_malloc) 
24c7			;	;inc hl 
24c7			;	;inc hl 
24c7			;	;inc hl 
24c7			;	;ex de,hl 
24c7			;	;ld hl, (os_tok_malloc) 
24c7			;	;ld (hl),e 
24c7			;	;inc hl 
24c7			;	;ld (hl),d 
24c7			; 
24c7			; 
24c7			;	ld hl,(os_tok_malloc) 
24c7			;if DEBUG_FORTH_PARSE_KEY 
24c7			;			DMARK "TKU" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			; 
24c7			;	ret 
24c7			 
24c7			forthexec: 
24c7			 
24c7			; line exec: 
24c7			; forth parser 
24c7			 
24c7			; 
24c7			;       get current exec line on rsp 
24c7			 
24c7				FORTH_RSP_TOS 
24c7 cd 4a 20			call macro_forth_rsp_tos 
24ca				endm 
# End of macro FORTH_RSP_TOS
24ca			 
24ca			;       restore current pc - hl points to malloc of data 
24ca			 
24ca				;ld e, (hl) 
24ca				;inc hl 
24ca				;ld d, (hl) 
24ca				;ex de,hl 
24ca			 
24ca			 
24ca			exec1: 
24ca 22 c9 f4			ld (os_tok_ptr), hl 
24cd			 
24cd				; copy our PC to working vars  
24cd 22 47 fa			ld (cli_ptr), hl 
24d0 22 45 fa			ld (cli_origptr), hl 
24d3			 
24d3 7e				ld a,(hl) 
24d4 fe 7f			cp FORTH_END_BUFFER 
24d6 c8				ret z 
24d7			 
24d7				; skip any nulls 
24d7			 
24d7 fe 00			cp 0 
24d9 20 03			jr nz, .execword 
24db 23				inc hl 
24dc 18 ec			jr exec1 
24de			 
24de			 
24de			.execword: 
24de			 
24de			 
24de			 
24de			if DEBUG_FORTH_PARSE_KEY 
24de						DMARK "KYQ" 
24de				CALLMONITOR 
24de			endif 
24de			;       while at start of word: 
24de			; get start of dict (in user area first) 
24de			 
24de 21 00 80		ld hl, baseram 
24e1			;ld hl, sysdict 
24e1 22 49 fa		ld (cli_nextword),hl 
24e4			;           match word at pc 
24e4			;           exec word 
24e4			;           or push to dsp 
24e4			;           forward to next token 
24e4			;           if line term pop rsp and exit 
24e4			;        
24e4			 
24e4			if DEBUG_FORTH_PARSE_KEY 
24e4						DMARK "KYq" 
24e4				CALLMONITOR 
24e4			endif 
24e4			 
24e4			; 
24e4			; word comp 
24e4			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
24e4			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
24e4			;    move to start of word  
24e4			;    compare word to cli_token 
24e4			 
24e4			.execpnword:	; HL at start of a word in the dictionary to check 
24e4			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
24e4			;	ld (cli_ptr), hl 
24e4			 
24e4 2a 49 fa			ld hl,(cli_nextword) 
24e7			 
24e7 cd 8a 25			call forth_tok_next 
24ea			; tok next start here 
24ea			;	; TODO skip compiled symbol for now 
24ea			;	inc hl 
24ea			; 
24ea			;	; save pointer to next word 
24ea			; 
24ea			;	; hl now points to the address of the next word pointer  
24ea			;	ld e, (hl) 
24ea			;	inc hl 
24ea			;	ld d, (hl) 
24ea			;	inc l 
24ea			; 
24ea			;	ex de,hl 
24ea			;if DEBUG_FORTH_PARSE_NEXTWORD 
24ea			;	push bc 
24ea			;	ld bc, (cli_nextword) 
24ea			;			DMARK "NXW" 
24ea			;	CALLMONITOR 
24ea			;	pop bc 
24ea			;endif 
24ea			; tok next end here 
24ea 22 49 fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
24ed eb				ex de, hl 
24ee			 
24ee			 
24ee				; save the pointer of the current token - 1 to check against 
24ee				 
24ee 22 4d fa			ld (cli_token), hl   
24f1				; TODO maybe remove below save if no debug 
24f1				; save token string ptr for any debug later 
24f1 23				inc hl  
24f2 22 4f fa			ld (cli_origtoken), hl 
24f5 2b				dec hl 
24f6				; save pointer to the start of the next dictionay word 
24f6 7e				ld a,(hl)   ; get string length 
24f7 47				ld b,a 
24f8			.execpnwordinc:  
24f8 23				inc hl 
24f9 10 fd			djnz .execpnwordinc 
24fb 22 4b fa			ld (cli_execword), hl      ; save start of this words code 
24fe			 
24fe				; now check the word token against the string being parsed 
24fe			 
24fe 2a 4d fa			ld hl,(cli_token) 
2501 23				inc hl     ; skip string length (use zero term instead to end) 
2502 22 4d fa			ld (cli_token), hl 
2505			 
2505			if DEBUG_FORTH_PARSE_KEY 
2505						DMARK "KY2" 
2505			endif 
2505			if DEBUG_FORTH_PARSE_EXEC 
2505				; see if disabled 
2505			 
2505				ld a, (os_view_disable) 
2505				cp '*' 
2505				jr z, .skip 
2505			 
2505				push hl 
2505				push hl 
2505				call clear_display 
2505				ld de, .compword 
2505				ld a, display_row_1 
2505				call str_at_display 
2505				pop de 
2505				ld a, display_row_2 
2505				call str_at_display 
2505				ld hl,(cli_ptr) 
2505				ld a,(hl) 
2505			        ld hl, os_word_scratch 
2505				ld (hl),a 
2505				ld a,0 
2505				inc hl 
2505				ld (hl),a 	 
2505				ld de, os_word_scratch 
2505				ld a, display_row_2+10 
2505				call str_at_display 
2505				call update_display 
2505				ld a, 100 
2505				call aDelayInMS 
2505				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2505				call delay250ms 
2505				endif 
2505				pop hl 
2505			.skip:  
2505			endif	 
2505			.execpnchar:    ; compare char between token and string to parse 
2505			 
2505			if DEBUG_FORTH_PARSE_KEY 
2505						DMARK "Ky3" 
2505			endif 
2505			if DEBUG_FORTH_PARSE_EXEC 
2505				; see if disabled 
2505			 
2505				ld a, (os_view_disable) 
2505				cp '*' 
2505				jr z, .skip2 
2505			 
2505			;	call clear_display 
2505			ld hl,(cli_token) 
2505			ld a,(hl) 
2505			ld (os_word_scratch),a 
2505				ld hl,(cli_ptr) 
2505			ld a,(hl) 
2505				ld (os_word_scratch+1),a 
2505				ld a,0 
2505				ld (os_word_scratch+2),a 
2505				ld de,os_word_scratch 
2505				ld a,display_row_4 
2505				call str_at_display 
2505				call update_display 
2505			.skip2:  
2505			endif 
2505 2a 4d fa			ld hl,(cli_token) 
2508 7e				ld a, (hl)	 ; char in word token 
2509 23				inc hl 		; move to next char 
250a 22 4d fa			ld (cli_token), hl ; and save it 
250d 47				ld b,a 
250e			 
250e 2a 47 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
2511 7e				ld a,(hl) 
2512 23				inc hl 
2513 22 47 fa			ld (cli_ptr), hl		; move to next char 
2516 cd a1 13			call toUpper 		; make sure the input string matches case 
2519			 
2519			if DEBUG_FORTH_PARSE 
2519			endif 
2519			 
2519				; input stream end of token is a space so get rid of it 
2519			 
2519			;	cp ' ' 
2519			;	jr nz, .pnskipspace 
2519			; 
2519			;	ld a, 0		; make same term as word token term 
2519			; 
2519			;.pnskipspace: 
2519			 
2519			if DEBUG_FORTH_PARSE_KEY 
2519						DMARK "KY7" 
2519			endif 
2519 b8				cp b 
251a c2 30 25			jp nz, .execpnskipword	 ; no match so move to next word 
251d				 
251d			;    if same 
251d			;       scan for string terms 0 for token and 32 for input 
251d			 
251d				 
251d			if DEBUG_FORTH_PARSE_KEY 
251d						DMARK "KY8" 
251d			endif 
251d			 
251d 80				add b			 
251e fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2520							; TODO need to make sure last word in zero term string is accounted for 
2520 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2522			 
2522			 
2522				; at end of both strings so both are exact match 
2522			 
2522			;       skip ptr for next word 
2522			 
2522 2a 47 fa			ld hl,(cli_ptr) 	; at input string term 
2525 23				inc hl			 ; at next char 
2526 22 47 fa			ld (cli_ptr), hl     ; save for next round of the parser 
2529 22 45 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
252c				 
252c				 
252c			if DEBUG_FORTH_PARSE_KEY 
252c						DMARK "KY3" 
252c			endif 
252c			 
252c			 
252c			 
252c			;       exec code block 
252c			if DEBUG_FORTH_JP 
252c				call clear_display 
252c				call update_display 
252c				call delay1s 
252c				ld hl, (cli_execword)     ; save for next check if no match on this word 
252c				ld a,h 
252c				ld hl, os_word_scratch 
252c				call hexout 
252c				ld hl, (cli_execword)     ; save for next check if no match on this word 
252c				ld a,l 
252c				ld hl, os_word_scratch+2 
252c				call hexout 
252c				ld hl, os_word_scratch+4 
252c				ld a,0 
252c				ld (hl),a 
252c				ld de,os_word_scratch 
252c				call str_at_display 
252c					ld a, display_row_2 
252c					call str_at_display 
252c				ld de, (cli_origtoken) 
252c				ld a, display_row_1+10 
252c					call str_at_display 
252c			 
252c				ld a,display_row_1 
252c				ld de, .foundword 
252c				ld a, display_row_3 
252c				call str_at_display 
252c				call update_display 
252c				call delay1s 
252c				call delay1s 
252c				call delay1s 
252c			endif 
252c			 
252c			if DEBUG_FORTH_PARSE_KEY 
252c						DMARK "KYj" 
252c			endif 
252c				; TODO save the word pointer in this exec 
252c			 
252c 2a 4b fa			ld hl,(cli_execword) 
252f e9				jp (hl) 
2530			 
2530			 
2530			;    if not same 
2530			;	scan for zero term 
2530			;	get ptr for next word 
2530			;	goto word comp 
2530			 
2530			.execpnskipword:	; get pointer to next word 
2530 2a 49 fa			ld hl,(cli_nextword) 
2533			 
2533 7e				ld a,(hl) 
2534 fe 00			cp WORD_SYS_END 
2536			;	cp 0 
2536 28 09			jr z, .execendofdict			 ; at end of words 
2538			 
2538			if DEBUG_FORTH_PARSE_KEY 
2538						DMARK "KY4" 
2538			endif 
2538			if DEBUG_FORTH_PARSE_EXEC 
2538			 
2538				; see if disabled 
2538			 
2538				ld a, (os_view_disable) 
2538				cp '*' 
2538				jr z, .noskip 
2538			 
2538			 
2538				ld de, .nowordfound 
2538				ld a, display_row_3 
2538				call str_at_display 
2538				call update_display 
2538				ld a, 100 
2538				call aDelayInMS 
2538				 
2538				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2538					call delay250ms 
2538				endif 
2538			.noskip:  
2538			 
2538			endif	 
2538			 
2538 2a 45 fa			ld hl,(cli_origptr) 
253b 22 47 fa			ld (cli_ptr),hl 
253e			 
253e			if DEBUG_FORTH_PARSE_KEY 
253e						DMARK "KY5" 
253e			endif 
253e c3 e4 24			jp .execpnword			; else go to next word 
2541			 
2541			.execendofdict:  
2541			 
2541			if DEBUG_FORTH_PARSE_KEY 
2541						DMARK "KYe" 
2541			endif 
2541			if DEBUG_FORTH_PARSE_EXEC 
2541				; see if disabled 
2541			 
2541				ld a, (os_view_disable) 
2541				cp '*' 
2541				jr z, .ispskip 
2541			 
2541				call clear_display 
2541				call update_display 
2541				call delay1s 
2541				ld de, (cli_origptr) 
2541				ld a, display_row_1 
2541				call str_at_display 
2541				 
2541				ld de, .enddict 
2541				ld a, display_row_3 
2541				call str_at_display 
2541				call update_display 
2541				ld a, 100 
2541				call aDelayInMS 
2541				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2541				call delay1s 
2541				call delay1s 
2541				call delay1s 
2541				endif 
2541			.ispskip:  
2541				 
2541			endif	 
2541			 
2541			 
2541			 
2541				; if the word is not a keyword then must be a literal so push it to stack 
2541			 
2541			; push token to stack to end of word 
2541			 
2541				STACKFRAME ON $1efe $2f9f 
2541				if DEBUG_STACK_IMB 
2541					if ON 
2541						exx 
2541						ld de, $1efe 
2541						ld a, d 
2541						ld hl, curframe 
2541						call hexout 
2541						ld a, e 
2541						ld hl, curframe+2 
2541						call hexout 
2541						ld hl, $1efe 
2541						push hl 
2541						ld hl, $2f9f 
2541						push hl 
2541						exx 
2541					endif 
2541				endif 
2541			endm 
# End of macro STACKFRAME
2541			 
2541 2a c9 f4		ld hl,(os_tok_ptr) 
2544 cd f5 21		call forth_apush 
2547			 
2547				STACKFRAMECHK ON $1efe $2f9f 
2547				if DEBUG_STACK_IMB 
2547					if ON 
2547						exx 
2547						ld hl, $2f9f 
2547						pop de   ; $2f9f 
2547						call cmp16 
2547						jr nz, .spnosame 
2547						ld hl, $1efe 
2547						pop de   ; $1efe 
2547						call cmp16 
2547						jr z, .spfrsame 
2547						.spnosame: call showsperror 
2547						.spfrsame: nop 
2547						exx 
2547					endif 
2547				endif 
2547			endm 
# End of macro STACKFRAMECHK
2547			 
2547			execnext: 
2547			 
2547			if DEBUG_FORTH_PARSE_KEY 
2547						DMARK "KY>" 
2547			endif 
2547			; move past token to next word 
2547			 
2547 2a c9 f4		ld hl, (os_tok_ptr) 
254a 3e 00		ld a, 0 
254c 01 ff 00		ld bc, 255     ; input buffer size 
254f ed b1		cpir 
2551			 
2551			if DEBUG_FORTH_PARSE_KEY 
2551						DMARK "KY!" 
2551				CALLMONITOR 
2551			endif	 
2551			; TODO this might place hl on the null, so will need to forward on??? 
2551			;inc hl   ; see if this gets onto the next item 
2551			 
2551			 
2551			; TODO pass a pointer to the buffer to push 
2551			; TODO call function to push 
2551			 
2551			; look for end of input 
2551			 
2551			;inc hl 
2551			;ld a,(hl) 
2551			;cp FORTH_END_BUFFER 
2551			;ret z 
2551			 
2551			 
2551 c3 ca 24		jp exec1 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			findnexttok: 
2554			 
2554				; hl is pointer to move 
2554				; de is the token to locate 
2554			 
2554					if DEBUG_FORTH 
2554						DMARK "NTK" 
2554						CALLMONITOR 
2554					endif 
2554 d5				push de 
2555			 
2555			.fnt1:	 
2555				; find first char of token to locate 
2555			 
2555 1a				ld a, (de) 
2556 4f				ld c,a 
2557 7e				ld a,(hl) 
2558 cd a1 13			call toUpper 
255b					if DEBUG_FORTH 
255b						DMARK "NT1" 
255b						CALLMONITOR 
255b					endif 
255b b9				cp c 
255c			 
255c 28 03			jr z, .fnt2cmpmorefirst	 
255e			 
255e				; first char not found move to next char 
255e			 
255e 23				inc hl 
255f 18 f4			jr .fnt1 
2561			 
2561			.fnt2cmpmorefirst:	 
2561				; first char of token found.  
2561			 
2561 e5				push hl     ; save start of token just in case it is the right one 
2562 d9				exx 
2563 e1				pop hl        ; save it to hl' 
2564 d9				exx 
2565			 
2565			 
2565			.fnt2cmpmore:	 
2565				; compare the rest 
2565				 
2565 23				inc hl 
2566 13				inc de 
2567				 
2567 1a				ld a, (de) 
2568 4f				ld c,a 
2569 7e				ld a,(hl) 
256a cd a1 13			call toUpper 
256d			 
256d					if DEBUG_FORTH 
256d						DMARK "NT2" 
256d						CALLMONITOR 
256d					endif 
256d				; c has the token to find char 
256d				; a has the mem to scan char 
256d			 
256d b9				cp c 
256e 28 04			jr z,.fntmatch1 
2570			 
2570				; they are not the same 
2570			 
2570					if DEBUG_FORTH 
2570						DMARK "NT3" 
2570						CALLMONITOR 
2570					endif 
2570 d1				pop de	; reset de token to look for 
2571 d5				push de 
2572 18 e1			jr .fnt1 
2574				 
2574			.fntmatch1: 
2574			 
2574				; is the same char a null which means we might have a full hit? 
2574					if DEBUG_FORTH 
2574						DMARK "NT4" 
2574						CALLMONITOR 
2574					endif 
2574			 
2574 fe 00			cp 0 
2576 28 0b			jr z, .fntmatchyes 
2578			 
2578				; are we at the end of the token to find? 
2578			 
2578					if DEBUG_FORTH 
2578						DMARK "NT5" 
2578						CALLMONITOR 
2578					endif 
2578 3e 00			ld a, 0 
257a b9				cp c 
257b			 
257b c2 65 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
257e			 
257e					if DEBUG_FORTH 
257e						DMARK "NT6" 
257e						CALLMONITOR 
257e					endif 
257e				; token to find is exhusted but no match to stream 
257e			 
257e				; restore tok pointer and continue on 
257e d1				pop de 
257f d5				push de 
2580 c3 55 25			jp .fnt1 
2583			 
2583			 
2583			.fntmatchyes: 
2583			 
2583				; hl now contains the end of the found token 
2583			 
2583				; get rid of saved token pointer to find 
2583			 
2583 d1				pop de 
2584			 
2584					if DEBUG_FORTH 
2584						DMARK "NT9" 
2584						CALLMONITOR 
2584					endif 
2584			 
2584				; hl will be on the null term so forward on 
2584			 
2584				; get back the saved start of the token 
2584			 
2584 d9				exx 
2585 e5				push hl     ; save start of token just in case it is the right one 
2586 d9				exx 
2587 e1				pop hl        ; save it to hl 
2588			 
2588 c9				ret 
2589			 
2589			 
2589			; LIST needs to find a specific token   
2589			; FORGET needs to find a spefici token 
2589			 
2589			; SAVE needs to find all tokens by flag 
2589			; WORDS just needs to scan through all  by flag 
2589			; UWORDS needs to scan through all by flag 
2589			 
2589			 
2589			; given hl as pointer to start of dict look up string 
2589			; return hl as pointer to start of word block 
2589			; or 0 if not found 
2589			 
2589			forth_find_tok: 
2589 c9				ret 
258a			 
258a			; given hl as pointer to dict structure 
258a			; move to the next dict block structure 
258a			 
258a			forth_tok_next: 
258a				; hl now points to the address of the next word pointer  
258a				; TODO skip compiled symbol for now 
258a			;	push de 
258a 23				inc hl 
258b 5e				ld e, (hl) 
258c 23				inc hl 
258d 56				ld d, (hl) 
258e 23				inc hl 
258f			 
258f eb				ex de,hl 
2590			if DEBUG_FORTH_PARSE_NEXTWORD 
2590				push bc 
2590				ld bc, (cli_nextword) 
2590						DMARK "NXW" 
2590				CALLMONITOR 
2590				pop bc 
2590			endif 
2590			;	pop de	 
2590 c9				ret 
2591			 
2591			 
2591			 
2591			; eof 
# End of file forth_parserv5.asm
2591				include "forth_wordsv4.asm" 
2591			 
2591			; the core word dictionary v4 
2591			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2591			 
2591			; this is a linked list for each of the system words used 
2591			; user defined words will follow the same format but will be in ram 
2591			 
2591			 
2591			; 
2591			; 
2591			; define linked list: 
2591			; 
2591			; 1. compiled byte op code 
2591			; 2. len of text word 
2591			; 3. text word 
2591			; 4. ptr to next dictionary word 
2591			; 5. asm, calls etc for the word 
2591			; 
2591			;  if 1 == 0 then last word in dict  
2591			;   
2591			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2591			;  
2591			;  
2591			; create basic standard set of words 
2591			; 
2591			;  
2591			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2591			; 2DUP 2DROP 2SWAP  
2591			; @ C@ - get byte  
2591			; ! C! - store byte 
2591			; 0< true if less than zero 
2591			; 0= true if zero 
2591			; < >  
2591			; = true if same 
2591			; variables 
2591			 
2591			 
2591			; Hardware specific words I may need 
2591			; 
2591			; IN OUT  
2591			; calls to key util functions 
2591			; calls to hardward abstraction stuff 
2591			; easy control of frame buffers and lcd i/o 
2591			; keyboard  
2591			 
2591			 
2591			;DICT: macro 
2591			; op_code, len, word, next 
2591			;    word: 
2591			;    db op_code 
2591			;    ds word zero term 
2591			;    dw next 
2591			;    endm 
2591			 
2591			 
2591			 
2591			 
2591			; op code 1 is a flag for user define words which are to be handled differently 
2591			 
2591			 
2591			; 
2591			; 
2591			;    TODO on entry to a word this should be the expected environment 
2591			;    hl - tos value if number then held, if string this is the ptr 
2591			;    de -  
2591			 
2591			 
2591			; opcode ranges 
2591			; 0 - end of word dict 
2591			; 255 - user define words 
2591			 
2591			sysdict: 
2591			include "forth_opcodes.asm" 
2591			; op codes for forth keywords 
2591			; free to use code 0  
2591				OPCODE_HEAP: equ  1 
2591				OPCODE_EXEC: equ 2 
2591				OPCODE_DUP: equ 3 
2591				OPCODE_SWAP: equ 4 
2591				OPCODE_COLN: equ 5 
2591				OPCODE_SCOLN: equ 6 
2591				OPCODE_DROP: equ 7 
2591				OPCODE_DUP2: equ 8 
2591				OPCODE_DROP2: equ 9 
2591				OPCODE_SWAP2: equ 10 
2591				OPCODE_AT: equ 11 
2591				OPCODE_CAT: equ 12 
2591				OPCODE_BANG: equ 13 
2591				OPCODE_CBANG: equ 14 
2591				OPCODE_SCALL: equ 15 
2591				OPCODE_DEPTH: equ 16 
2591				OPCODE_OVER: equ 17 
2591				OPCODE_PAUSE: equ 18 
2591				OPCODE_PAUSES: equ 19 
2591				OPCODE_ROT: equ 20 
2591			;free to reuse	OPCODE_WORDS: equ 21 
2591			        OPCODE_NOT: equ 21 
2591				OPCODE_UWORDS: equ 22 
2591				OPCODE_BP: equ 23 
2591				OPCODE_MONITOR: equ 24  
2591				OPCODE_MALLOC: equ 25 
2591				OPCODE_FREE: equ 26 
2591				OPCODE_LIST: equ 27 
2591				OPCODE_FORGET: equ 28 
2591				OPCODE_NOP: equ 29 
2591				OPCODE_COMO: equ 30 
2591				OPCODE_COMC: equ 31 
2591			;free to reuse	OPCODE_ENDCORE: equ 32 
2591				OPCODE_AFTERSOUND: equ 33 
2591				OPCODE_GP2: equ 34 
2591				OPCODE_GP3: equ 35 
2591				OPCODE_GP4: equ 36 
2591				OPCODE_SIN: equ 37 
2591				OPCODE_SOUT: equ 38 
2591				OPCODE_SPIO: equ 39 
2591				OPCODE_SPICEH: equ 40 
2591				OPCODE_SPIOb: equ 41 
2591				OPCODE_SPII: equ 42 
2591				OPCODE_SESEL: equ 43 
2591				OPCODE_CARTDEV: equ 44 
2591			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2591				OPCODE_FB: equ 46 
2591				OPCODE_EMIT: equ 47 
2591				OPCODE_DOTH: equ 48 
2591				OPCODE_DOTF: equ 49 
2591				OPCODE_DOT: equ 50 
2591				OPCODE_CLS: equ 51 
2591				OPCODE_DRAW: equ 52 
2591				OPCODE_DUMP: equ 53 
2591				OPCODE_CDUMP: equ 54 
2591				OPCODE_DAT: equ 55 
2591				OPCODE_HOME: equ 56 
2591				OPCODE_SPACE: equ 57 
2591				OPCODE_SPACES: equ 58 
2591				OPCODE_SCROLL: equ 59 
2591				OPCODE_ATQ: equ 60 
2591				OPCODE_AUTODSP: equ 61 
2591				OPCODE_MENU: equ 62 
2591			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2591				OPCODE_THEN: equ 64 
2591				OPCODE_ELSE: equ 65 
2591				OPCODE_DO: equ 66 
2591				OPCODE_LOOP: equ 67 
2591				OPCODE_I: equ 68 
2591				OPCODE_DLOOP: equ 69  
2591				OPCODE_REPEAT: equ 70  
2591				OPCODE_UNTIL: equ 71 
2591				OPCODE_ENDFLOW: equ 72 
2591				OPCODE_WAITK: equ 73 
2591				OPCODE_ACCEPT: equ 74 
2591				OPCODE_EDIT: equ 75 
2591			;free to reuse	OPCODE_ENDKEY: equ 76 
2591				OPCODE_LZERO: equ 77 
2591				OPCODE_TZERO: equ 78 
2591				OPCODE_LESS: equ 79 
2591				OPCODE_GT: equ 80 
2591				OPCODE_EQUAL: equ 81  
2591			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2591				OPCODE_NEG: equ 83 
2591				OPCODE_DIV: equ 84 
2591				OPCODE_MUL: equ 85 
2591				OPCODE_MIN: equ 86 
2591				OPCODE_MAX: equ 87 
2591				OPCODE_RND16: equ 88 
2591				OPCODE_RND8: equ 89 
2591				OPCODE_RND: equ 90 
2591			;free to reuse	OPCODE_ENDMATHS: equ 91  
2591				OPCODE_BYNAME: equ 92 
2591				OPCODE_DIR: equ 93 
2591				OPCODE_SAVE: equ 94 
2591				OPCODE_LOAD: equ 95 
2591				OPCODE_BSAVE: equ 96 
2591				OPCODE_BLOAD: equ 97 
2591				OPCODE_SEO: equ 98  
2591				OPCODE_SEI: equ 99 
2591				OPCODE_SFREE: equ 100 
2591				OPCODE_SIZE: equ 101 
2591				OPCODE_CREATE: equ 102 
2591				OPCODE_APPEND: equ 103 
2591				OPCODE_SDEL: equ 104 
2591				OPCODE_OPEN: equ 105 
2591				OPCODE_READ: equ 106 
2591				OPCODE_EOF: equ 106 
2591				OPCODE_FORMAT: equ 107 
2591				OPCODE_LABEL: equ 108 
2591				OPCODE_LABELS: equ 109 
2591			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2591				OPCODE_UPPER: equ 111 
2591				OPCODE_LOWER: equ 112 
2591				OPCODE_SUBSTR: equ 113 
2591				OPCODE_LEFT: equ 114 
2591				OPCODE_RIGHT: equ 115 
2591				OPCODE_STR2NUM: equ 116 
2591				OPCODE_NUM2STR: equ 117 
2591				OPCODE_CONCAT: equ 118 
2591				OPCODE_FIND: equ 119 
2591				OPCODE_LEN: equ 120 
2591				OPCODE_CHAR: equ 121 
2591			; free to reuse	OPCODE_STRLEN: equ 122 
2591			; free to reuse	OPCODE_ENDSTR: equ 123 
2591				OPCODE_V0S: equ 124 
2591				OPCODE_V0Q: equ 125 
2591				OPCODE_V1S: equ 126 
2591				OPCODE_V1Q: equ 127 
2591				OPCODE_V2S: equ 128 
2591				OPCODE_V2Q: equ 129 
2591				OPCODE_V3S: equ 130 
2591				OPCODE_V3Q: equ 131 
2591			;free to reuse	OPCODE_END: equ 132 
2591				OPCODE_ZDUP: equ 133 
2591			 
2591			; eof 
# End of file forth_opcodes.asm
2591			 
2591			include "forth_words_core.asm" 
2591			 
2591			; | ## Core Words 
2591			 
2591			;if MALLOC_4 
2591			 
2591			.HEAP: 
2591				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2591 15				db WORD_SYS_CORE+OPCODE_HEAP             
2592 d0 25			dw .EXEC            
2594 05				db 4 + 1 
2595 .. 00			db "HEAP",0              
259a				endm 
# End of macro CWHEAD
259a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
259a			; | | u1 - Current number of bytes in the heap 
259a			; | | u2 - Remaining bytes left on the heap 
259a			; | |  
259a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
259a			 
259a			 
259a					if DEBUG_FORTH_WORDS_KEY 
259a						DMARK "HEP" 
259a f5				push af  
259b 3a af 25			ld a, (.dmark)  
259e 32 6e fe			ld (debug_mark),a  
25a1 3a b0 25			ld a, (.dmark+1)  
25a4 32 6f fe			ld (debug_mark+1),a  
25a7 3a b1 25			ld a, (.dmark+2)  
25aa 32 70 fe			ld (debug_mark+2),a  
25ad 18 03			jr .pastdmark  
25af ..			.dmark: db "HEP"  
25b2 f1			.pastdmark: pop af  
25b3			endm  
# End of macro DMARK
25b3						CALLMONITOR 
25b3 cd c1 19			call break_point_state  
25b6				endm  
# End of macro CALLMONITOR
25b6					endif 
25b6 2a 0a 80				ld hl, (free_list )      
25b9 11 0e 80				ld de, heap_start 
25bc			 
25bc ed 52				sbc hl, de  
25be			 
25be cd 8c 20				call forth_push_numhl 
25c1			 
25c1			 
25c1 ed 5b 0a 80			ld de, (free_list )      
25c5 21 ae f1				ld hl, heap_end 
25c8			 
25c8 ed 52				sbc hl, de 
25ca			 
25ca cd 8c 20				call forth_push_numhl 
25cd					 
25cd			 
25cd					 
25cd			 
25cd			 
25cd			 
25cd					NEXTW 
25cd c3 39 24			jp macro_next 
25d0				endm 
# End of macro NEXTW
25d0			;endif 
25d0			 
25d0			.EXEC: 
25d0			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
25d0			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
25d0			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
25d0			;; > > 
25d0			;; > >   
25d0			;	STACKFRAME OFF $5efe $5f9f 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS_KEY 
25d0			;			DMARK "EXE" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	FORTH_DSP_VALUEHL 
25d0			; 
25d0			;	FORTH_DSP_POP 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX1" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;;	ld e,(hl) 
25d0			;;	inc hl 
25d0			;;	ld d,(hl) 
25d0			;;	ex de,hl 
25d0			; 
25d0			;;		if DEBUG_FORTH_WORDS 
25d0			;;			DMARK "EX2" 
25d0			;;			CALLMONITOR 
25d0			;;		endif 
25d0			;	push hl 
25d0			; 
25d0			;	;ld a, 0 
25d0			;	;ld a, FORTH_END_BUFFER 
25d0			;	call strlenz 
25d0			;	inc hl   ; include zero term to copy 
25d0			;	inc hl   ; include term 
25d0			;	inc hl   ; include term 
25d0			;	ld b,0 
25d0			;	ld c,l 
25d0			;	pop hl 
25d0			;	ld de, execscratch 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX3" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	ldir 
25d0			; 
25d0			; 
25d0			;	ld hl, execscratch 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EXe" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	call forthparse 
25d0			;	call forthexec 
25d0			;;	call forthexec_cleanup 
25d0			;;	call forthparse 
25d0			;;	call forthexec 
25d0			; 
25d0			;	STACKFRAMECHK OFF $5efe $5f9f 
25d0			; 
25d0			;	; an immediate word so no need to process any more words 
25d0			;	ret 
25d0			;	NEXTW 
25d0			 
25d0			; dead code - old version  
25d0			;	FORTH_RSP_NEXT 
25d0			 
25d0			;  
25d0			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
25d0			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
25d0			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
25d0			;	push hl 
25d0			;	push de 
25d0			;	push bc 
25d0			; 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS_KEY 
25d0			;			DMARK "EXR" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			; 
25d0			; 
25d0			;	;v5 FORTH_DSP_VALUE 
25d0			;	FORTH_DSP_VALUEHL 
25d0			; 
25d0			;	; TODO do string type checks 
25d0			; 
25d0			;;v5	inc hl   ; skip type 
25d0			; 
25d0			;	push hl  ; source code  
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX1" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	ld a, 0 
25d0			;	call strlent 
25d0			; 
25d0			;	inc hl 
25d0			;	inc hl 
25d0			;	inc hl 
25d0			;	inc hl 
25d0			; 
25d0			;	push hl    ; size 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX2" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	call malloc 
25d0			; 
25d0			;	ex de, hl    ; de now contains malloc area 
25d0			;	pop bc   	; get byte count 
25d0			;	pop hl      ; get string to copy 
25d0			; 
25d0			;	push de     ; save malloc for free later 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX3" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	ldir       ; duplicate string 
25d0			; 
25d0			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
25d0			;	 
25d0			;	; TODO fix the parse would be better than this...  
25d0			;	ex de, hl 
25d0			;	dec hl 
25d0			;	ld a, 0 
25d0			;	ld (hl), a 
25d0			;	dec hl 
25d0			;	ld a, ' ' 
25d0			;	ld (hl), a 
25d0			;	dec hl 
25d0			;	ld (hl), a 
25d0			; 
25d0			;	dec hl 
25d0			;	ld (hl), a 
25d0			; 
25d0			; 
25d0			;	FORTH_DSP_POP  
25d0			; 
25d0			;	pop hl     
25d0			;	push hl    ; save malloc area 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX4" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	call forthparse 
25d0			;	call forthexec 
25d0			;	 
25d0			;	pop hl 
25d0			;	if DEBUG_FORTH_WORDS 
25d0			;		DMARK "EX5" 
25d0			;		CALLMONITOR 
25d0			;	endif 
25d0			; 
25d0			;	if FORTH_ENABLE_FREE 
25d0			;	call free 
25d0			;	endif 
25d0			; 
25d0			;	if DEBUG_FORTH_WORDS 
25d0			;		DMARK "EX6" 
25d0			;		CALLMONITOR 
25d0			;	endif 
25d0			; 
25d0			;	pop bc 
25d0			;	pop de 
25d0			;	pop hl 
25d0			;;	FORTH_RSP_POP	  
25d0			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
25d0			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
25d0			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
25d0			; 
25d0			;	if DEBUG_FORTH_WORDS 
25d0			;		DMARK "EX7" 
25d0			;		CALLMONITOR 
25d0			;	endif 
25d0			;	NEXTW 
25d0			 
25d0			;.STKEXEC: 
25d0			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
25d0			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
25d0			; 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS_KEY 
25d0			;			DMARK "STX" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	FORTH_DSP_VALUEHL 
25d0			; 
25d0			;	ld (store_tmp1), hl    ; count 
25d0			; 
25d0			;	FORTH_DSP_POP 
25d0			;.stkexec1: 
25d0			;	ld hl, (store_tmp1)   ; count 
25d0			;	ld a, 0 
25d0			;	cp l 
25d0			;	ret z 
25d0			; 
25d0			;	dec hl 
25d0			;	ld (store_tmp1), hl    ; count 
25d0			;	 
25d0			;	FORTH_DSP_VALUEHL 
25d0			;	push hl 
25d0			;	 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EXp" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	FORTH_DSP_POP 
25d0			; 
25d0			;	call strlenz 
25d0			;	inc hl   ; include zero term to copy 
25d0			;	inc hl   ; include zero term to copy 
25d0			;	inc hl   ; include zero term to copy 
25d0			;	ld b,0 
25d0			;	ld c,l 
25d0			;	pop hl 
25d0			;	ld de, execscratch 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX3" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	ldir 
25d0			; 
25d0			; 
25d0			;	ld hl, execscratch 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EXP" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	call forthparse 
25d0			;	ld hl, execscratch 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EXx" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	call forthexec 
25d0			; 
25d0			;	jp .stkexec1 
25d0			; 
25d0			;	ret 
25d0			 
25d0			 
25d0			.DUP: 
25d0				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
25d0 17				db WORD_SYS_CORE+OPCODE_DUP             
25d1 46 26			dw .ZDUP            
25d3 04				db 3 + 1 
25d4 .. 00			db "DUP",0              
25d8				endm 
# End of macro CWHEAD
25d8			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
25d8			 
25d8					if DEBUG_FORTH_WORDS_KEY 
25d8						DMARK "DUP" 
25d8 f5				push af  
25d9 3a ed 25			ld a, (.dmark)  
25dc 32 6e fe			ld (debug_mark),a  
25df 3a ee 25			ld a, (.dmark+1)  
25e2 32 6f fe			ld (debug_mark+1),a  
25e5 3a ef 25			ld a, (.dmark+2)  
25e8 32 70 fe			ld (debug_mark+2),a  
25eb 18 03			jr .pastdmark  
25ed ..			.dmark: db "DUP"  
25f0 f1			.pastdmark: pop af  
25f1			endm  
# End of macro DMARK
25f1						CALLMONITOR 
25f1 cd c1 19			call break_point_state  
25f4				endm  
# End of macro CALLMONITOR
25f4					endif 
25f4			 
25f4					FORTH_DSP 
25f4 cd 49 22			call macro_forth_dsp 
25f7				endm 
# End of macro FORTH_DSP
25f7			 
25f7 7e					ld a, (HL) 
25f8 fe 01				cp DS_TYPE_STR 
25fa 20 25				jr nz, .dupinum 
25fc			 
25fc					; push another string 
25fc			 
25fc					FORTH_DSP_VALUEHL     		 
25fc cd 83 22			call macro_dsp_valuehl 
25ff				endm 
# End of macro FORTH_DSP_VALUEHL
25ff			 
25ff				if DEBUG_FORTH_WORDS 
25ff					DMARK "DUs" 
25ff f5				push af  
2600 3a 14 26			ld a, (.dmark)  
2603 32 6e fe			ld (debug_mark),a  
2606 3a 15 26			ld a, (.dmark+1)  
2609 32 6f fe			ld (debug_mark+1),a  
260c 3a 16 26			ld a, (.dmark+2)  
260f 32 70 fe			ld (debug_mark+2),a  
2612 18 03			jr .pastdmark  
2614 ..			.dmark: db "DUs"  
2617 f1			.pastdmark: pop af  
2618			endm  
# End of macro DMARK
2618					CALLMONITOR 
2618 cd c1 19			call break_point_state  
261b				endm  
# End of macro CALLMONITOR
261b				endif 
261b cd fa 20				call forth_push_str 
261e			 
261e					NEXTW 
261e c3 39 24			jp macro_next 
2621				endm 
# End of macro NEXTW
2621			 
2621			 
2621			.dupinum: 
2621					 
2621			 
2621			 
2621					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2621 cd 83 22			call macro_dsp_valuehl 
2624				endm 
# End of macro FORTH_DSP_VALUEHL
2624			 
2624				; TODO add floating point number detection 
2624			 
2624				if DEBUG_FORTH_WORDS 
2624					DMARK "DUi" 
2624 f5				push af  
2625 3a 39 26			ld a, (.dmark)  
2628 32 6e fe			ld (debug_mark),a  
262b 3a 3a 26			ld a, (.dmark+1)  
262e 32 6f fe			ld (debug_mark+1),a  
2631 3a 3b 26			ld a, (.dmark+2)  
2634 32 70 fe			ld (debug_mark+2),a  
2637 18 03			jr .pastdmark  
2639 ..			.dmark: db "DUi"  
263c f1			.pastdmark: pop af  
263d			endm  
# End of macro DMARK
263d					CALLMONITOR 
263d cd c1 19			call break_point_state  
2640				endm  
# End of macro CALLMONITOR
2640				endif 
2640			 
2640 cd 8c 20				call forth_push_numhl 
2643					NEXTW 
2643 c3 39 24			jp macro_next 
2646				endm 
# End of macro NEXTW
2646			.ZDUP: 
2646				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2646 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2647 7e 26			dw .SWAP            
2649 05				db 4 + 1 
264a .. 00			db "?DUP",0              
264f				endm 
# End of macro CWHEAD
264f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
264f			 
264f					if DEBUG_FORTH_WORDS_KEY 
264f						DMARK "qDU" 
264f f5				push af  
2650 3a 64 26			ld a, (.dmark)  
2653 32 6e fe			ld (debug_mark),a  
2656 3a 65 26			ld a, (.dmark+1)  
2659 32 6f fe			ld (debug_mark+1),a  
265c 3a 66 26			ld a, (.dmark+2)  
265f 32 70 fe			ld (debug_mark+2),a  
2662 18 03			jr .pastdmark  
2664 ..			.dmark: db "qDU"  
2667 f1			.pastdmark: pop af  
2668			endm  
# End of macro DMARK
2668						CALLMONITOR 
2668 cd c1 19			call break_point_state  
266b				endm  
# End of macro CALLMONITOR
266b					endif 
266b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266b cd 83 22			call macro_dsp_valuehl 
266e				endm 
# End of macro FORTH_DSP_VALUEHL
266e			 
266e e5					push hl 
266f			 
266f					; is it a zero? 
266f			 
266f 3e 00				ld a, 0 
2671 84					add h 
2672 85					add l 
2673			 
2673 e1					pop hl 
2674			 
2674 fe 00				cp 0 
2676 28 03				jr z, .dup2orig 
2678			 
2678			 
2678 cd 8c 20				call forth_push_numhl 
267b			 
267b			 
267b				; TODO add floating point number detection 
267b			 
267b			.dup2orig: 
267b			 
267b					NEXTW 
267b c3 39 24			jp macro_next 
267e				endm 
# End of macro NEXTW
267e			.SWAP: 
267e				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
267e 18				db WORD_SYS_CORE+OPCODE_SWAP             
267f bd 26			dw .COLN            
2681 05				db 4 + 1 
2682 .. 00			db "SWAP",0              
2687				endm 
# End of macro CWHEAD
2687			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2687					if DEBUG_FORTH_WORDS_KEY 
2687						DMARK "SWP" 
2687 f5				push af  
2688 3a 9c 26			ld a, (.dmark)  
268b 32 6e fe			ld (debug_mark),a  
268e 3a 9d 26			ld a, (.dmark+1)  
2691 32 6f fe			ld (debug_mark+1),a  
2694 3a 9e 26			ld a, (.dmark+2)  
2697 32 70 fe			ld (debug_mark+2),a  
269a 18 03			jr .pastdmark  
269c ..			.dmark: db "SWP"  
269f f1			.pastdmark: pop af  
26a0			endm  
# End of macro DMARK
26a0						CALLMONITOR 
26a0 cd c1 19			call break_point_state  
26a3				endm  
# End of macro CALLMONITOR
26a3					endif 
26a3			 
26a3					FORTH_DSP_VALUEHL 
26a3 cd 83 22			call macro_dsp_valuehl 
26a6				endm 
# End of macro FORTH_DSP_VALUEHL
26a6 e5					push hl     ; w2 
26a7			 
26a7					FORTH_DSP_POP 
26a7 cd 3b 23			call macro_forth_dsp_pop 
26aa				endm 
# End of macro FORTH_DSP_POP
26aa			 
26aa					FORTH_DSP_VALUEHL 
26aa cd 83 22			call macro_dsp_valuehl 
26ad				endm 
# End of macro FORTH_DSP_VALUEHL
26ad			 
26ad					FORTH_DSP_POP 
26ad cd 3b 23			call macro_forth_dsp_pop 
26b0				endm 
# End of macro FORTH_DSP_POP
26b0			 
26b0 d1					pop de     ; w2	, hl = w1 
26b1			 
26b1 eb					ex de, hl 
26b2 d5					push de 
26b3			 
26b3 cd 8c 20				call forth_push_numhl 
26b6			 
26b6 e1					pop hl 
26b7			 
26b7 cd 8c 20				call forth_push_numhl 
26ba					 
26ba			 
26ba					NEXTW 
26ba c3 39 24			jp macro_next 
26bd				endm 
# End of macro NEXTW
26bd			.COLN: 
26bd				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
26bd 19				db WORD_SYS_CORE+OPCODE_COLN             
26be 49 28			dw .SCOLN            
26c0 02				db 1 + 1 
26c1 .. 00			db ":",0              
26c3				endm 
# End of macro CWHEAD
26c3			; | : ( -- )         Create new word | DONE 
26c3			 
26c3					if DEBUG_FORTH_WORDS_KEY 
26c3						DMARK "CLN" 
26c3 f5				push af  
26c4 3a d8 26			ld a, (.dmark)  
26c7 32 6e fe			ld (debug_mark),a  
26ca 3a d9 26			ld a, (.dmark+1)  
26cd 32 6f fe			ld (debug_mark+1),a  
26d0 3a da 26			ld a, (.dmark+2)  
26d3 32 70 fe			ld (debug_mark+2),a  
26d6 18 03			jr .pastdmark  
26d8 ..			.dmark: db "CLN"  
26db f1			.pastdmark: pop af  
26dc			endm  
# End of macro DMARK
26dc						CALLMONITOR 
26dc cd c1 19			call break_point_state  
26df				endm  
# End of macro CALLMONITOR
26df					endif 
26df				STACKFRAME OFF $8efe $989f 
26df				if DEBUG_STACK_IMB 
26df					if OFF 
26df						exx 
26df						ld de, $8efe 
26df						ld a, d 
26df						ld hl, curframe 
26df						call hexout 
26df						ld a, e 
26df						ld hl, curframe+2 
26df						call hexout 
26df						ld hl, $8efe 
26df						push hl 
26df						ld hl, $989f 
26df						push hl 
26df						exx 
26df					endif 
26df				endif 
26df			endm 
# End of macro STACKFRAME
26df				; get parser buffer length  of new word 
26df			 
26df				 
26df			 
26df					; move tok past this to start of name defintition 
26df					; TODO get word to define 
26df					; TODO Move past word token 
26df					; TODO get length of string up to the ';' 
26df			 
26df 2a c9 f4			ld hl, (os_tok_ptr) 
26e2 23				inc hl 
26e3 23				inc hl 
26e4			 
26e4 3e 3b			ld a, ';' 
26e6 cd b5 13			call strlent 
26e9			 
26e9 7d				ld a,l 
26ea 32 c4 f1			ld (os_new_parse_len), a 
26ed			 
26ed			 
26ed			if DEBUG_FORTH_UWORD 
26ed ed 5b c9 f4		ld de, (os_tok_ptr) 
26f1						DMARK ":01" 
26f1 f5				push af  
26f2 3a 06 27			ld a, (.dmark)  
26f5 32 6e fe			ld (debug_mark),a  
26f8 3a 07 27			ld a, (.dmark+1)  
26fb 32 6f fe			ld (debug_mark+1),a  
26fe 3a 08 27			ld a, (.dmark+2)  
2701 32 70 fe			ld (debug_mark+2),a  
2704 18 03			jr .pastdmark  
2706 ..			.dmark: db ":01"  
2709 f1			.pastdmark: pop af  
270a			endm  
# End of macro DMARK
270a				CALLMONITOR 
270a cd c1 19			call break_point_state  
270d				endm  
# End of macro CALLMONITOR
270d			endif 
270d			 
270d			; 
270d			;  new word memory layout: 
270d			;  
270d			;    : adg 6666 ;  
270d			; 
270d			;    db   1     ; user defined word  
270d 23				inc hl    
270e			;    dw   sysdict 
270e 23				inc hl 
270f 23				inc hl 
2710			;    db <word len>+1 (for null) 
2710 23				inc hl 
2711			;    db .... <word> 
2711			; 
2711			 
2711 23				inc hl    ; some extras for the word preamble before the above 
2712 23				inc hl 
2713 23				inc hl 
2714 23				inc hl 
2715 23				inc hl 
2716 23				inc hl 
2717 23				inc hl  
2718 23				inc hl 
2719 23				inc hl 
271a 23				inc hl 
271b 23				inc hl 
271c 23				inc hl 
271d 23				inc hl 
271e 23				inc hl     ; TODO how many do we really need?     maybe only 6 
271f			;       exec word buffer 
271f			;	<ptr word>   
271f 23				inc hl 
2720 23				inc hl 
2721			;       <word list><null term> 7F final term 
2721			 
2721			 
2721			if DEBUG_FORTH_UWORD 
2721						DMARK ":02" 
2721 f5				push af  
2722 3a 36 27			ld a, (.dmark)  
2725 32 6e fe			ld (debug_mark),a  
2728 3a 37 27			ld a, (.dmark+1)  
272b 32 6f fe			ld (debug_mark+1),a  
272e 3a 38 27			ld a, (.dmark+2)  
2731 32 70 fe			ld (debug_mark+2),a  
2734 18 03			jr .pastdmark  
2736 ..			.dmark: db ":02"  
2739 f1			.pastdmark: pop af  
273a			endm  
# End of macro DMARK
273a				CALLMONITOR 
273a cd c1 19			call break_point_state  
273d				endm  
# End of macro CALLMONITOR
273d			endif 
273d			 
273d				 
273d					; malloc the size 
273d			 
273d cd 13 14				call malloc 
2740 22 c6 f1				ld (os_new_malloc), hl     ; save malloc start 
2743			 
2743			;    db   1     ; user defined word  
2743 3e 01				ld a, WORD_SYS_UWORD  
2745 77					ld (hl), a 
2746				 
2746 23				inc hl    
2747			;    dw   sysdict 
2747 11 91 25			ld de, sysdict       ; continue on with the scan to the system dict 
274a 73				ld (hl), e 
274b 23				inc hl 
274c 72				ld (hl), d 
274d 23				inc hl 
274e			 
274e			 
274e			;    Setup dict word 
274e			 
274e 23				inc hl 
274f 22 c0 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
2752			 
2752				; 1. get length of dict word 
2752			 
2752			 
2752 2a c9 f4			ld hl, (os_tok_ptr) 
2755 23				inc hl 
2756 23				inc hl    ; position to start of dict word 
2757 3e 00			ld a, 0 
2759 cd b5 13			call strlent 
275c			 
275c			 
275c 23				inc hl    ; to include null??? 
275d			 
275d				; write length of dict word 
275d			 
275d ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2761 1b				dec de 
2762 eb				ex de, hl 
2763 73				ld (hl), e 
2764 eb				ex de, hl 
2765			 
2765				 
2765			 
2765				; copy  
2765 4d				ld c, l 
2766 06 00			ld b, 0 
2768 ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
276c 2a c9 f4			ld hl, (os_tok_ptr) 
276f 23				inc hl 
2770 23				inc hl    ; position to start of dict word 
2771				 
2771			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2771				 
2771				; TODO need to convert word to upper case 
2771			 
2771			ucasetok:	 
2771 7e				ld a,(hl) 
2772 cd a1 13			call toUpper 
2775 77				ld (hl),a 
2776 ed a0			ldi 
2778 f2 71 27		 	jp p, ucasetok 
277b			 
277b			 
277b			 
277b				; de now points to start of where the word body code should be placed 
277b ed 53 c0 f1		ld (os_new_work_ptr), de 
277f				; hl now points to the words to throw at forthexec which needs to be copied 
277f 22 be f1			ld (os_new_src_ptr), hl 
2782			 
2782				; TODO add 'call to forthexec' 
2782			 
2782			if DEBUG_FORTH_UWORD 
2782 c5				push bc 
2783 ed 4b c6 f1		ld bc, (os_new_malloc) 
2787						DMARK ":0x" 
2787 f5				push af  
2788 3a 9c 27			ld a, (.dmark)  
278b 32 6e fe			ld (debug_mark),a  
278e 3a 9d 27			ld a, (.dmark+1)  
2791 32 6f fe			ld (debug_mark+1),a  
2794 3a 9e 27			ld a, (.dmark+2)  
2797 32 70 fe			ld (debug_mark+2),a  
279a 18 03			jr .pastdmark  
279c ..			.dmark: db ":0x"  
279f f1			.pastdmark: pop af  
27a0			endm  
# End of macro DMARK
27a0				CALLMONITOR 
27a0 cd c1 19			call break_point_state  
27a3				endm  
# End of macro CALLMONITOR
27a3 c1				pop bc 
27a4			endif 
27a4			 
27a4			 
27a4				; create word preamble which should be: 
27a4			 
27a4			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
27a4			 
27a4				;    ld hl, <word code> 
27a4				;    jp user_exec 
27a4			        ;    <word code bytes> 
27a4			 
27a4			 
27a4			;	inc de     ; TODO ??? or are we already past the word's null 
27a4 eb				ex de, hl 
27a5			 
27a5 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
27a7			 
27a7 23				inc hl 
27a8 22 ba f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
27ab 23				inc hl 
27ac			 
27ac 23				inc hl 
27ad 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
27af			 
27af 01 39 5c			ld bc, user_exec 
27b2 23				inc hl 
27b3 71				ld (hl), c     ; poke address of user_exec 
27b4 23				inc hl 
27b5 70				ld (hl), b     
27b6			 ; 
27b6			;	inc hl 
27b6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27b6			; 
27b6			; 
27b6			;	ld bc, macro_forth_rsp_next 
27b6			;	inc hl 
27b6			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
27b6			;	inc hl 
27b6			;	ld (hl), b     
27b6			 ; 
27b6			;	inc hl 
27b6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27b6			; 
27b6			; 
27b6			;	inc hl 
27b6			;	ld bc, forthexec 
27b6			;	ld (hl), c     ; poke address of forthexec 
27b6			;	inc hl 
27b6			;	ld (hl), b      
27b6			; 
27b6			;	inc hl 
27b6			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
27b6			; 
27b6			;	ld bc, user_dict_next 
27b6			;	inc hl 
27b6			;	ld (hl), c     ; poke address of forthexec 
27b6			;	inc hl 
27b6			;	ld (hl), b      
27b6			 
27b6				; hl is now where we need to copy the word byte data to save this 
27b6			 
27b6 23				inc hl 
27b7 22 bc f1			ld (os_new_exec), hl 
27ba				 
27ba				; copy definition 
27ba			 
27ba eb				ex de, hl 
27bb			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
27bb			;	inc de    ; skip the PC for this parse 
27bb 3a c4 f1			ld a, (os_new_parse_len) 
27be 4f				ld c, a 
27bf 06 00			ld b, 0 
27c1 ed b0			ldir		 ; copy defintion 
27c3			 
27c3			 
27c3				; poke the address of where the new word bytes live for forthexec 
27c3			 
27c3 2a ba f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
27c6			 
27c6 ed 5b bc f1		ld de, (os_new_exec)      
27ca				 
27ca 73				ld (hl), e 
27cb 23				inc hl 
27cc 72				ld (hl), d 
27cd			 
27cd					; TODO copy last user dict word next link to this word 
27cd					; TODO update last user dict word to point to this word 
27cd			; 
27cd			; hl f923 de 812a ; bc 811a 
27cd			 
27cd			if DEBUG_FORTH_UWORD 
27cd c5				push bc 
27ce ed 4b c6 f1		ld bc, (os_new_malloc) 
27d2						DMARK ":0A" 
27d2 f5				push af  
27d3 3a e7 27			ld a, (.dmark)  
27d6 32 6e fe			ld (debug_mark),a  
27d9 3a e8 27			ld a, (.dmark+1)  
27dc 32 6f fe			ld (debug_mark+1),a  
27df 3a e9 27			ld a, (.dmark+2)  
27e2 32 70 fe			ld (debug_mark+2),a  
27e5 18 03			jr .pastdmark  
27e7 ..			.dmark: db ":0A"  
27ea f1			.pastdmark: pop af  
27eb			endm  
# End of macro DMARK
27eb				CALLMONITOR 
27eb cd c1 19			call break_point_state  
27ee				endm  
# End of macro CALLMONITOR
27ee c1				pop bc 
27ef			endif 
27ef			if DEBUG_FORTH_UWORD 
27ef c5				push bc 
27f0 ed 4b c6 f1		ld bc, (os_new_malloc) 
27f4 03				inc bc 
27f5 03				inc bc 
27f6 03				inc bc 
27f7 03				inc bc 
27f8 03				inc bc 
27f9 03				inc bc 
27fa 03				inc bc 
27fb 03				inc bc 
27fc			 
27fc						DMARK ":0B" 
27fc f5				push af  
27fd 3a 11 28			ld a, (.dmark)  
2800 32 6e fe			ld (debug_mark),a  
2803 3a 12 28			ld a, (.dmark+1)  
2806 32 6f fe			ld (debug_mark+1),a  
2809 3a 13 28			ld a, (.dmark+2)  
280c 32 70 fe			ld (debug_mark+2),a  
280f 18 03			jr .pastdmark  
2811 ..			.dmark: db ":0B"  
2814 f1			.pastdmark: pop af  
2815			endm  
# End of macro DMARK
2815				CALLMONITOR 
2815 cd c1 19			call break_point_state  
2818				endm  
# End of macro CALLMONITOR
2818 c1				pop bc 
2819			endif 
2819			 
2819			; update word dict linked list for new word 
2819			 
2819			 
2819 2a c5 f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
281c 23			inc hl     ; move to next work linked list ptr 
281d			 
281d ed 5b c6 f1	ld de, (os_new_malloc)		 ; new next word 
2821 73			ld (hl), e 
2822 23			inc hl 
2823 72			ld (hl), d 
2824			 
2824			if DEBUG_FORTH_UWORD 
2824 ed 4b c5 f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2828			endif 
2828			 
2828 ed 53 c5 f4	ld (os_last_new_uword), de      ; update last new uword ptr 
282c			 
282c			 
282c			if DEBUG_FORTH_UWORD 
282c						DMARK ":0+" 
282c f5				push af  
282d 3a 41 28			ld a, (.dmark)  
2830 32 6e fe			ld (debug_mark),a  
2833 3a 42 28			ld a, (.dmark+1)  
2836 32 6f fe			ld (debug_mark+1),a  
2839 3a 43 28			ld a, (.dmark+2)  
283c 32 70 fe			ld (debug_mark+2),a  
283f 18 03			jr .pastdmark  
2841 ..			.dmark: db ":0+"  
2844 f1			.pastdmark: pop af  
2845			endm  
# End of macro DMARK
2845				CALLMONITOR 
2845 cd c1 19			call break_point_state  
2848				endm  
# End of macro CALLMONITOR
2848			endif 
2848			 
2848				STACKFRAMECHK OFF $8efe $989f 
2848				if DEBUG_STACK_IMB 
2848					if OFF 
2848						exx 
2848						ld hl, $989f 
2848						pop de   ; $989f 
2848						call cmp16 
2848						jr nz, .spnosame 
2848						ld hl, $8efe 
2848						pop de   ; $8efe 
2848						call cmp16 
2848						jr z, .spfrsame 
2848						.spnosame: call showsperror 
2848						.spfrsame: nop 
2848						exx 
2848					endif 
2848				endif 
2848			endm 
# End of macro STACKFRAMECHK
2848			 
2848 c9			ret    ; dont process any remaining parser tokens as they form new word 
2849			 
2849			 
2849			 
2849			 
2849			;		NEXT 
2849			.SCOLN: 
2849			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2849 06				db OPCODE_SCOLN 
284a 95 28			dw .DROP 
284c 02				db 2 
284d .. 00			db ";",0           
284f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
284f					if DEBUG_FORTH_WORDS_KEY 
284f						DMARK "SCN" 
284f f5				push af  
2850 3a 64 28			ld a, (.dmark)  
2853 32 6e fe			ld (debug_mark),a  
2856 3a 65 28			ld a, (.dmark+1)  
2859 32 6f fe			ld (debug_mark+1),a  
285c 3a 66 28			ld a, (.dmark+2)  
285f 32 70 fe			ld (debug_mark+2),a  
2862 18 03			jr .pastdmark  
2864 ..			.dmark: db "SCN"  
2867 f1			.pastdmark: pop af  
2868			endm  
# End of macro DMARK
2868						CALLMONITOR 
2868 cd c1 19			call break_point_state  
286b				endm  
# End of macro CALLMONITOR
286b					endif 
286b					FORTH_RSP_TOS 
286b cd 4a 20			call macro_forth_rsp_tos 
286e				endm 
# End of macro FORTH_RSP_TOS
286e e5					push hl 
286f					FORTH_RSP_POP 
286f cd 54 20			call macro_forth_rsp_pop 
2872				endm 
# End of macro FORTH_RSP_POP
2872 e1					pop hl 
2873			;		ex de,hl 
2873 22 c9 f4				ld (os_tok_ptr),hl 
2876			 
2876			if DEBUG_FORTH_UWORD 
2876						DMARK "SCL" 
2876 f5				push af  
2877 3a 8b 28			ld a, (.dmark)  
287a 32 6e fe			ld (debug_mark),a  
287d 3a 8c 28			ld a, (.dmark+1)  
2880 32 6f fe			ld (debug_mark+1),a  
2883 3a 8d 28			ld a, (.dmark+2)  
2886 32 70 fe			ld (debug_mark+2),a  
2889 18 03			jr .pastdmark  
288b ..			.dmark: db "SCL"  
288e f1			.pastdmark: pop af  
288f			endm  
# End of macro DMARK
288f				CALLMONITOR 
288f cd c1 19			call break_point_state  
2892				endm  
# End of macro CALLMONITOR
2892			endif 
2892					NEXTW 
2892 c3 39 24			jp macro_next 
2895				endm 
# End of macro NEXTW
2895			 
2895			.DROP: 
2895				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2895 1b				db WORD_SYS_CORE+OPCODE_DROP             
2896 c0 28			dw .DUP2            
2898 05				db 4 + 1 
2899 .. 00			db "DROP",0              
289e				endm 
# End of macro CWHEAD
289e			; | DROP ( w -- )   drop the TOS item   | DONE 
289e					if DEBUG_FORTH_WORDS_KEY 
289e						DMARK "DRP" 
289e f5				push af  
289f 3a b3 28			ld a, (.dmark)  
28a2 32 6e fe			ld (debug_mark),a  
28a5 3a b4 28			ld a, (.dmark+1)  
28a8 32 6f fe			ld (debug_mark+1),a  
28ab 3a b5 28			ld a, (.dmark+2)  
28ae 32 70 fe			ld (debug_mark+2),a  
28b1 18 03			jr .pastdmark  
28b3 ..			.dmark: db "DRP"  
28b6 f1			.pastdmark: pop af  
28b7			endm  
# End of macro DMARK
28b7						CALLMONITOR 
28b7 cd c1 19			call break_point_state  
28ba				endm  
# End of macro CALLMONITOR
28ba					endif 
28ba					FORTH_DSP_POP 
28ba cd 3b 23			call macro_forth_dsp_pop 
28bd				endm 
# End of macro FORTH_DSP_POP
28bd					NEXTW 
28bd c3 39 24			jp macro_next 
28c0				endm 
# End of macro NEXTW
28c0			.DUP2: 
28c0				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
28c0 1c				db WORD_SYS_CORE+OPCODE_DUP2             
28c1 05 29			dw .DROP2            
28c3 05				db 4 + 1 
28c4 .. 00			db "2DUP",0              
28c9				endm 
# End of macro CWHEAD
28c9			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
28c9					if DEBUG_FORTH_WORDS_KEY 
28c9						DMARK "2DU" 
28c9 f5				push af  
28ca 3a de 28			ld a, (.dmark)  
28cd 32 6e fe			ld (debug_mark),a  
28d0 3a df 28			ld a, (.dmark+1)  
28d3 32 6f fe			ld (debug_mark+1),a  
28d6 3a e0 28			ld a, (.dmark+2)  
28d9 32 70 fe			ld (debug_mark+2),a  
28dc 18 03			jr .pastdmark  
28de ..			.dmark: db "2DU"  
28e1 f1			.pastdmark: pop af  
28e2			endm  
# End of macro DMARK
28e2						CALLMONITOR 
28e2 cd c1 19			call break_point_state  
28e5				endm  
# End of macro CALLMONITOR
28e5					endif 
28e5					FORTH_DSP_VALUEHL 
28e5 cd 83 22			call macro_dsp_valuehl 
28e8				endm 
# End of macro FORTH_DSP_VALUEHL
28e8 e5					push hl      ; 2 
28e9			 
28e9					FORTH_DSP_POP 
28e9 cd 3b 23			call macro_forth_dsp_pop 
28ec				endm 
# End of macro FORTH_DSP_POP
28ec					 
28ec					FORTH_DSP_VALUEHL 
28ec cd 83 22			call macro_dsp_valuehl 
28ef				endm 
# End of macro FORTH_DSP_VALUEHL
28ef			;		push hl      ; 1 
28ef			 
28ef					FORTH_DSP_POP 
28ef cd 3b 23			call macro_forth_dsp_pop 
28f2				endm 
# End of macro FORTH_DSP_POP
28f2			 
28f2			;		pop hl       ; 1 
28f2 d1					pop de       ; 2 
28f3			 
28f3 cd 8c 20				call forth_push_numhl 
28f6 eb					ex de, hl 
28f7 cd 8c 20				call forth_push_numhl 
28fa			 
28fa					 
28fa eb					ex de, hl 
28fb			 
28fb cd 8c 20				call forth_push_numhl 
28fe eb					ex de, hl 
28ff cd 8c 20				call forth_push_numhl 
2902			 
2902			 
2902					NEXTW 
2902 c3 39 24			jp macro_next 
2905				endm 
# End of macro NEXTW
2905			.DROP2: 
2905				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2905 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2906 34 29			dw .SWAP2            
2908 06				db 5 + 1 
2909 .. 00			db "2DROP",0              
290f				endm 
# End of macro CWHEAD
290f			; | 2DROP ( w w -- )    Double drop | DONE 
290f					if DEBUG_FORTH_WORDS_KEY 
290f						DMARK "2DR" 
290f f5				push af  
2910 3a 24 29			ld a, (.dmark)  
2913 32 6e fe			ld (debug_mark),a  
2916 3a 25 29			ld a, (.dmark+1)  
2919 32 6f fe			ld (debug_mark+1),a  
291c 3a 26 29			ld a, (.dmark+2)  
291f 32 70 fe			ld (debug_mark+2),a  
2922 18 03			jr .pastdmark  
2924 ..			.dmark: db "2DR"  
2927 f1			.pastdmark: pop af  
2928			endm  
# End of macro DMARK
2928						CALLMONITOR 
2928 cd c1 19			call break_point_state  
292b				endm  
# End of macro CALLMONITOR
292b					endif 
292b					FORTH_DSP_POP 
292b cd 3b 23			call macro_forth_dsp_pop 
292e				endm 
# End of macro FORTH_DSP_POP
292e					FORTH_DSP_POP 
292e cd 3b 23			call macro_forth_dsp_pop 
2931				endm 
# End of macro FORTH_DSP_POP
2931					NEXTW 
2931 c3 39 24			jp macro_next 
2934				endm 
# End of macro NEXTW
2934			.SWAP2: 
2934				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2934 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2935 5d 29			dw .AT            
2937 06				db 5 + 1 
2938 .. 00			db "2SWAP",0              
293e				endm 
# End of macro CWHEAD
293e			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
293e					if DEBUG_FORTH_WORDS_KEY 
293e						DMARK "2SW" 
293e f5				push af  
293f 3a 53 29			ld a, (.dmark)  
2942 32 6e fe			ld (debug_mark),a  
2945 3a 54 29			ld a, (.dmark+1)  
2948 32 6f fe			ld (debug_mark+1),a  
294b 3a 55 29			ld a, (.dmark+2)  
294e 32 70 fe			ld (debug_mark+2),a  
2951 18 03			jr .pastdmark  
2953 ..			.dmark: db "2SW"  
2956 f1			.pastdmark: pop af  
2957			endm  
# End of macro DMARK
2957						CALLMONITOR 
2957 cd c1 19			call break_point_state  
295a				endm  
# End of macro CALLMONITOR
295a					endif 
295a					NEXTW 
295a c3 39 24			jp macro_next 
295d				endm 
# End of macro NEXTW
295d			.AT: 
295d				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
295d 1f				db WORD_SYS_CORE+OPCODE_AT             
295e 8f 29			dw .CAT            
2960 02				db 1 + 1 
2961 .. 00			db "@",0              
2963				endm 
# End of macro CWHEAD
2963			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2963			 
2963					if DEBUG_FORTH_WORDS_KEY 
2963						DMARK "AT." 
2963 f5				push af  
2964 3a 78 29			ld a, (.dmark)  
2967 32 6e fe			ld (debug_mark),a  
296a 3a 79 29			ld a, (.dmark+1)  
296d 32 6f fe			ld (debug_mark+1),a  
2970 3a 7a 29			ld a, (.dmark+2)  
2973 32 70 fe			ld (debug_mark+2),a  
2976 18 03			jr .pastdmark  
2978 ..			.dmark: db "AT."  
297b f1			.pastdmark: pop af  
297c			endm  
# End of macro DMARK
297c						CALLMONITOR 
297c cd c1 19			call break_point_state  
297f				endm  
# End of macro CALLMONITOR
297f					endif 
297f			.getbyteat:	 
297f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
297f cd 83 22			call macro_dsp_valuehl 
2982				endm 
# End of macro FORTH_DSP_VALUEHL
2982					 
2982			;		push hl 
2982				 
2982					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2982 cd 3b 23			call macro_forth_dsp_pop 
2985				endm 
# End of macro FORTH_DSP_POP
2985			 
2985			;		pop hl 
2985			 
2985 7e					ld a, (hl) 
2986			 
2986 6f					ld l, a 
2987 26 00				ld h, 0 
2989 cd 8c 20				call forth_push_numhl 
298c			 
298c					NEXTW 
298c c3 39 24			jp macro_next 
298f				endm 
# End of macro NEXTW
298f			.CAT: 
298f				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
298f 20				db WORD_SYS_CORE+OPCODE_CAT             
2990 b8 29			dw .BANG            
2992 03				db 2 + 1 
2993 .. 00			db "C@",0              
2996				endm 
# End of macro CWHEAD
2996			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2996					if DEBUG_FORTH_WORDS_KEY 
2996						DMARK "CAA" 
2996 f5				push af  
2997 3a ab 29			ld a, (.dmark)  
299a 32 6e fe			ld (debug_mark),a  
299d 3a ac 29			ld a, (.dmark+1)  
29a0 32 6f fe			ld (debug_mark+1),a  
29a3 3a ad 29			ld a, (.dmark+2)  
29a6 32 70 fe			ld (debug_mark+2),a  
29a9 18 03			jr .pastdmark  
29ab ..			.dmark: db "CAA"  
29ae f1			.pastdmark: pop af  
29af			endm  
# End of macro DMARK
29af						CALLMONITOR 
29af cd c1 19			call break_point_state  
29b2				endm  
# End of macro CALLMONITOR
29b2					endif 
29b2 c3 7f 29				jp .getbyteat 
29b5					NEXTW 
29b5 c3 39 24			jp macro_next 
29b8				endm 
# End of macro NEXTW
29b8			.BANG: 
29b8				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
29b8 21				db WORD_SYS_CORE+OPCODE_BANG             
29b9 ee 29			dw .CBANG            
29bb 02				db 1 + 1 
29bc .. 00			db "!",0              
29be				endm 
# End of macro CWHEAD
29be			; | ! ( x w -- ) Store x at address w      | DONE 
29be					if DEBUG_FORTH_WORDS_KEY 
29be						DMARK "BNG" 
29be f5				push af  
29bf 3a d3 29			ld a, (.dmark)  
29c2 32 6e fe			ld (debug_mark),a  
29c5 3a d4 29			ld a, (.dmark+1)  
29c8 32 6f fe			ld (debug_mark+1),a  
29cb 3a d5 29			ld a, (.dmark+2)  
29ce 32 70 fe			ld (debug_mark+2),a  
29d1 18 03			jr .pastdmark  
29d3 ..			.dmark: db "BNG"  
29d6 f1			.pastdmark: pop af  
29d7			endm  
# End of macro DMARK
29d7						CALLMONITOR 
29d7 cd c1 19			call break_point_state  
29da				endm  
# End of macro CALLMONITOR
29da					endif 
29da			 
29da			.storebyteat:		 
29da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29da cd 83 22			call macro_dsp_valuehl 
29dd				endm 
# End of macro FORTH_DSP_VALUEHL
29dd					 
29dd e5					push hl 
29de				 
29de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29de cd 3b 23			call macro_forth_dsp_pop 
29e1				endm 
# End of macro FORTH_DSP_POP
29e1			 
29e1					; get byte to poke 
29e1			 
29e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29e1 cd 83 22			call macro_dsp_valuehl 
29e4				endm 
# End of macro FORTH_DSP_VALUEHL
29e4 e5					push hl 
29e5			 
29e5			 
29e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29e5 cd 3b 23			call macro_forth_dsp_pop 
29e8				endm 
# End of macro FORTH_DSP_POP
29e8			 
29e8			 
29e8 d1					pop de 
29e9 e1					pop hl 
29ea			 
29ea 73					ld (hl),e 
29eb			 
29eb			 
29eb					NEXTW 
29eb c3 39 24			jp macro_next 
29ee				endm 
# End of macro NEXTW
29ee			.CBANG: 
29ee				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
29ee 22				db WORD_SYS_CORE+OPCODE_CBANG             
29ef 17 2a			dw .SCALL            
29f1 03				db 2 + 1 
29f2 .. 00			db "C!",0              
29f5				endm 
# End of macro CWHEAD
29f5			; | C!  ( x w -- ) Store x at address w  | DONE 
29f5					if DEBUG_FORTH_WORDS_KEY 
29f5						DMARK "CBA" 
29f5 f5				push af  
29f6 3a 0a 2a			ld a, (.dmark)  
29f9 32 6e fe			ld (debug_mark),a  
29fc 3a 0b 2a			ld a, (.dmark+1)  
29ff 32 6f fe			ld (debug_mark+1),a  
2a02 3a 0c 2a			ld a, (.dmark+2)  
2a05 32 70 fe			ld (debug_mark+2),a  
2a08 18 03			jr .pastdmark  
2a0a ..			.dmark: db "CBA"  
2a0d f1			.pastdmark: pop af  
2a0e			endm  
# End of macro DMARK
2a0e						CALLMONITOR 
2a0e cd c1 19			call break_point_state  
2a11				endm  
# End of macro CALLMONITOR
2a11					endif 
2a11 c3 da 29				jp .storebyteat 
2a14					NEXTW 
2a14 c3 39 24			jp macro_next 
2a17				endm 
# End of macro NEXTW
2a17			.SCALL: 
2a17				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a17 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a18 4b 2a			dw .DEPTH            
2a1a 05				db 4 + 1 
2a1b .. 00			db "CALL",0              
2a20				endm 
# End of macro CWHEAD
2a20			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a20					if DEBUG_FORTH_WORDS_KEY 
2a20						DMARK "CLL" 
2a20 f5				push af  
2a21 3a 35 2a			ld a, (.dmark)  
2a24 32 6e fe			ld (debug_mark),a  
2a27 3a 36 2a			ld a, (.dmark+1)  
2a2a 32 6f fe			ld (debug_mark+1),a  
2a2d 3a 37 2a			ld a, (.dmark+2)  
2a30 32 70 fe			ld (debug_mark+2),a  
2a33 18 03			jr .pastdmark  
2a35 ..			.dmark: db "CLL"  
2a38 f1			.pastdmark: pop af  
2a39			endm  
# End of macro DMARK
2a39						CALLMONITOR 
2a39 cd c1 19			call break_point_state  
2a3c				endm  
# End of macro CALLMONITOR
2a3c					endif 
2a3c			 
2a3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a3c cd 83 22			call macro_dsp_valuehl 
2a3f				endm 
# End of macro FORTH_DSP_VALUEHL
2a3f			 
2a3f			;		push hl 
2a3f			 
2a3f					; destroy value TOS 
2a3f			 
2a3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a3f cd 3b 23			call macro_forth_dsp_pop 
2a42				endm 
# End of macro FORTH_DSP_POP
2a42			 
2a42						 
2a42			;		pop hl 
2a42			 
2a42					; how to do a call with hl???? save SP? 
2a42 cd dd 23				call forth_call_hl 
2a45			 
2a45			 
2a45					; TODO push value back onto stack for another op etc 
2a45			 
2a45 cd 8c 20				call forth_push_numhl 
2a48					NEXTW 
2a48 c3 39 24			jp macro_next 
2a4b				endm 
# End of macro NEXTW
2a4b			.DEPTH: 
2a4b				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2a4b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2a4c 88 2a			dw .OVER            
2a4e 06				db 5 + 1 
2a4f .. 00			db "DEPTH",0              
2a55				endm 
# End of macro CWHEAD
2a55			; | DEPTH ( -- u ) Push count of stack | DONE 
2a55					; take current TOS and remove from base value div by two to get count 
2a55					if DEBUG_FORTH_WORDS_KEY 
2a55						DMARK "DEP" 
2a55 f5				push af  
2a56 3a 6a 2a			ld a, (.dmark)  
2a59 32 6e fe			ld (debug_mark),a  
2a5c 3a 6b 2a			ld a, (.dmark+1)  
2a5f 32 6f fe			ld (debug_mark+1),a  
2a62 3a 6c 2a			ld a, (.dmark+2)  
2a65 32 70 fe			ld (debug_mark+2),a  
2a68 18 03			jr .pastdmark  
2a6a ..			.dmark: db "DEP"  
2a6d f1			.pastdmark: pop af  
2a6e			endm  
# End of macro DMARK
2a6e						CALLMONITOR 
2a6e cd c1 19			call break_point_state  
2a71				endm  
# End of macro CALLMONITOR
2a71					endif 
2a71			 
2a71			 
2a71 2a f5 f9			ld hl, (cli_data_sp) 
2a74 11 2f f7			ld de, cli_data_stack 
2a77 ed 52			sbc hl,de 
2a79				 
2a79				; div by size of stack item 
2a79			 
2a79 5d				ld e,l 
2a7a 0e 03			ld c, 3 
2a7c cd dc 0e			call Div8 
2a7f			 
2a7f 6f				ld l,a 
2a80 26 00			ld h,0 
2a82			 
2a82				;srl h 
2a82				;rr l 
2a82			 
2a82 cd 8c 20				call forth_push_numhl 
2a85					NEXTW 
2a85 c3 39 24			jp macro_next 
2a88				endm 
# End of macro NEXTW
2a88			.OVER: 
2a88				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2a88 42				db WORD_SYS_CORE+46             
2a89 cf 2a			dw .PAUSE            
2a8b 05				db 4 + 1 
2a8c .. 00			db "OVER",0              
2a91				endm 
# End of macro CWHEAD
2a91			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2a91					if DEBUG_FORTH_WORDS_KEY 
2a91						DMARK "OVR" 
2a91 f5				push af  
2a92 3a a6 2a			ld a, (.dmark)  
2a95 32 6e fe			ld (debug_mark),a  
2a98 3a a7 2a			ld a, (.dmark+1)  
2a9b 32 6f fe			ld (debug_mark+1),a  
2a9e 3a a8 2a			ld a, (.dmark+2)  
2aa1 32 70 fe			ld (debug_mark+2),a  
2aa4 18 03			jr .pastdmark  
2aa6 ..			.dmark: db "OVR"  
2aa9 f1			.pastdmark: pop af  
2aaa			endm  
# End of macro DMARK
2aaa						CALLMONITOR 
2aaa cd c1 19			call break_point_state  
2aad				endm  
# End of macro CALLMONITOR
2aad					endif 
2aad			 
2aad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2aad cd 83 22			call macro_dsp_valuehl 
2ab0				endm 
# End of macro FORTH_DSP_VALUEHL
2ab0 e5					push hl    ; n2 
2ab1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab1 cd 3b 23			call macro_forth_dsp_pop 
2ab4				endm 
# End of macro FORTH_DSP_POP
2ab4			 
2ab4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab4 cd 83 22			call macro_dsp_valuehl 
2ab7				endm 
# End of macro FORTH_DSP_VALUEHL
2ab7 e5					push hl    ; n1 
2ab8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab8 cd 3b 23			call macro_forth_dsp_pop 
2abb				endm 
# End of macro FORTH_DSP_POP
2abb			 
2abb d1					pop de     ; n1 
2abc e1					pop hl     ; n2 
2abd			 
2abd d5					push de 
2abe e5					push hl 
2abf d5					push de 
2ac0			 
2ac0					; push back  
2ac0			 
2ac0 e1					pop hl 
2ac1 cd 8c 20				call forth_push_numhl 
2ac4 e1					pop hl 
2ac5 cd 8c 20				call forth_push_numhl 
2ac8 e1					pop hl 
2ac9 cd 8c 20				call forth_push_numhl 
2acc					NEXTW 
2acc c3 39 24			jp macro_next 
2acf				endm 
# End of macro NEXTW
2acf			 
2acf			.PAUSE: 
2acf				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2acf 43				db WORD_SYS_CORE+47             
2ad0 04 2b			dw .PAUSES            
2ad2 08				db 7 + 1 
2ad3 .. 00			db "PAUSEMS",0              
2adb				endm 
# End of macro CWHEAD
2adb			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2adb					if DEBUG_FORTH_WORDS_KEY 
2adb						DMARK "PMS" 
2adb f5				push af  
2adc 3a f0 2a			ld a, (.dmark)  
2adf 32 6e fe			ld (debug_mark),a  
2ae2 3a f1 2a			ld a, (.dmark+1)  
2ae5 32 6f fe			ld (debug_mark+1),a  
2ae8 3a f2 2a			ld a, (.dmark+2)  
2aeb 32 70 fe			ld (debug_mark+2),a  
2aee 18 03			jr .pastdmark  
2af0 ..			.dmark: db "PMS"  
2af3 f1			.pastdmark: pop af  
2af4			endm  
# End of macro DMARK
2af4						CALLMONITOR 
2af4 cd c1 19			call break_point_state  
2af7				endm  
# End of macro CALLMONITOR
2af7					endif 
2af7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2af7 cd 83 22			call macro_dsp_valuehl 
2afa				endm 
# End of macro FORTH_DSP_VALUEHL
2afa			;		push hl    ; n2 
2afa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2afa cd 3b 23			call macro_forth_dsp_pop 
2afd				endm 
# End of macro FORTH_DSP_POP
2afd			;		pop hl 
2afd			 
2afd 7d					ld a, l 
2afe cd 7a 0c				call aDelayInMS 
2b01				       NEXTW 
2b01 c3 39 24			jp macro_next 
2b04				endm 
# End of macro NEXTW
2b04			.PAUSES:  
2b04				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b04 44				db WORD_SYS_CORE+48             
2b05 73 2b			dw .ROT            
2b07 06				db 5 + 1 
2b08 .. 00			db "PAUSE",0              
2b0e				endm 
# End of macro CWHEAD
2b0e			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b0e					if DEBUG_FORTH_WORDS_KEY 
2b0e						DMARK "PAU" 
2b0e f5				push af  
2b0f 3a 23 2b			ld a, (.dmark)  
2b12 32 6e fe			ld (debug_mark),a  
2b15 3a 24 2b			ld a, (.dmark+1)  
2b18 32 6f fe			ld (debug_mark+1),a  
2b1b 3a 25 2b			ld a, (.dmark+2)  
2b1e 32 70 fe			ld (debug_mark+2),a  
2b21 18 03			jr .pastdmark  
2b23 ..			.dmark: db "PAU"  
2b26 f1			.pastdmark: pop af  
2b27			endm  
# End of macro DMARK
2b27						CALLMONITOR 
2b27 cd c1 19			call break_point_state  
2b2a				endm  
# End of macro CALLMONITOR
2b2a					endif 
2b2a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b2a cd 83 22			call macro_dsp_valuehl 
2b2d				endm 
# End of macro FORTH_DSP_VALUEHL
2b2d			;		push hl    ; n2 
2b2d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b2d cd 3b 23			call macro_forth_dsp_pop 
2b30				endm 
# End of macro FORTH_DSP_POP
2b30			;		pop hl 
2b30 45					ld b, l 
2b31					if DEBUG_FORTH_WORDS 
2b31						DMARK "PAU" 
2b31 f5				push af  
2b32 3a 46 2b			ld a, (.dmark)  
2b35 32 6e fe			ld (debug_mark),a  
2b38 3a 47 2b			ld a, (.dmark+1)  
2b3b 32 6f fe			ld (debug_mark+1),a  
2b3e 3a 48 2b			ld a, (.dmark+2)  
2b41 32 70 fe			ld (debug_mark+2),a  
2b44 18 03			jr .pastdmark  
2b46 ..			.dmark: db "PAU"  
2b49 f1			.pastdmark: pop af  
2b4a			endm  
# End of macro DMARK
2b4a						CALLMONITOR 
2b4a cd c1 19			call break_point_state  
2b4d				endm  
# End of macro CALLMONITOR
2b4d					endif 
2b4d c5			.pauses1:	push bc 
2b4e cd 95 0c				call delay1s 
2b51 c1					pop bc 
2b52					if DEBUG_FORTH_WORDS 
2b52						DMARK "PA1" 
2b52 f5				push af  
2b53 3a 67 2b			ld a, (.dmark)  
2b56 32 6e fe			ld (debug_mark),a  
2b59 3a 68 2b			ld a, (.dmark+1)  
2b5c 32 6f fe			ld (debug_mark+1),a  
2b5f 3a 69 2b			ld a, (.dmark+2)  
2b62 32 70 fe			ld (debug_mark+2),a  
2b65 18 03			jr .pastdmark  
2b67 ..			.dmark: db "PA1"  
2b6a f1			.pastdmark: pop af  
2b6b			endm  
# End of macro DMARK
2b6b						CALLMONITOR 
2b6b cd c1 19			call break_point_state  
2b6e				endm  
# End of macro CALLMONITOR
2b6e					endif 
2b6e 10 dd				djnz .pauses1 
2b70			 
2b70				       NEXTW 
2b70 c3 39 24			jp macro_next 
2b73				endm 
# End of macro NEXTW
2b73			.ROT: 
2b73				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2b73 45				db WORD_SYS_CORE+49             
2b74 c1 2b			dw .UWORDS            
2b76 04				db 3 + 1 
2b77 .. 00			db "ROT",0              
2b7b				endm 
# End of macro CWHEAD
2b7b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2b7b					if DEBUG_FORTH_WORDS_KEY 
2b7b						DMARK "ROT" 
2b7b f5				push af  
2b7c 3a 90 2b			ld a, (.dmark)  
2b7f 32 6e fe			ld (debug_mark),a  
2b82 3a 91 2b			ld a, (.dmark+1)  
2b85 32 6f fe			ld (debug_mark+1),a  
2b88 3a 92 2b			ld a, (.dmark+2)  
2b8b 32 70 fe			ld (debug_mark+2),a  
2b8e 18 03			jr .pastdmark  
2b90 ..			.dmark: db "ROT"  
2b93 f1			.pastdmark: pop af  
2b94			endm  
# End of macro DMARK
2b94						CALLMONITOR 
2b94 cd c1 19			call break_point_state  
2b97				endm  
# End of macro CALLMONITOR
2b97					endif 
2b97			 
2b97					FORTH_DSP_VALUEHL 
2b97 cd 83 22			call macro_dsp_valuehl 
2b9a				endm 
# End of macro FORTH_DSP_VALUEHL
2b9a e5					push hl    ; u3  
2b9b			 
2b9b					FORTH_DSP_POP 
2b9b cd 3b 23			call macro_forth_dsp_pop 
2b9e				endm 
# End of macro FORTH_DSP_POP
2b9e			   
2b9e					FORTH_DSP_VALUEHL 
2b9e cd 83 22			call macro_dsp_valuehl 
2ba1				endm 
# End of macro FORTH_DSP_VALUEHL
2ba1 e5					push hl     ; u2 
2ba2			 
2ba2					FORTH_DSP_POP 
2ba2 cd 3b 23			call macro_forth_dsp_pop 
2ba5				endm 
# End of macro FORTH_DSP_POP
2ba5			 
2ba5					FORTH_DSP_VALUEHL 
2ba5 cd 83 22			call macro_dsp_valuehl 
2ba8				endm 
# End of macro FORTH_DSP_VALUEHL
2ba8 e5					push hl     ; u1 
2ba9			 
2ba9					FORTH_DSP_POP 
2ba9 cd 3b 23			call macro_forth_dsp_pop 
2bac				endm 
# End of macro FORTH_DSP_POP
2bac			 
2bac c1					pop bc      ; u1 
2bad e1					pop hl      ; u2 
2bae d1					pop de      ; u3 
2baf			 
2baf			 
2baf c5					push bc 
2bb0 d5					push de 
2bb1 e5					push hl 
2bb2			 
2bb2			 
2bb2 e1					pop hl 
2bb3 cd 8c 20				call forth_push_numhl 
2bb6			 
2bb6 e1					pop hl 
2bb7 cd 8c 20				call forth_push_numhl 
2bba			 
2bba e1					pop hl 
2bbb cd 8c 20				call forth_push_numhl 
2bbe					 
2bbe			 
2bbe			 
2bbe			 
2bbe			 
2bbe			 
2bbe				       NEXTW 
2bbe c3 39 24			jp macro_next 
2bc1				endm 
# End of macro NEXTW
2bc1			 
2bc1			.UWORDS: 
2bc1				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2bc1 50				db WORD_SYS_CORE+60             
2bc2 83 2c			dw .BP            
2bc4 07				db 6 + 1 
2bc5 .. 00			db "UWORDS",0              
2bcc				endm 
# End of macro CWHEAD
2bcc			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2bcc			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2bcc			; | | Following the count are the individual words. 
2bcc			; | | 
2bcc			; | | e.g. UWORDS 
2bcc			; | | BOX DIRLIST 2 
2bcc			; | |  
2bcc			; | | Can be used to save the words to storage via: 
2bcc			; | | UWORDS $01 DO $01 APPEND LOOP 
2bcc				if DEBUG_FORTH_WORDS_KEY 
2bcc					DMARK "UWR" 
2bcc f5				push af  
2bcd 3a e1 2b			ld a, (.dmark)  
2bd0 32 6e fe			ld (debug_mark),a  
2bd3 3a e2 2b			ld a, (.dmark+1)  
2bd6 32 6f fe			ld (debug_mark+1),a  
2bd9 3a e3 2b			ld a, (.dmark+2)  
2bdc 32 70 fe			ld (debug_mark+2),a  
2bdf 18 03			jr .pastdmark  
2be1 ..			.dmark: db "UWR"  
2be4 f1			.pastdmark: pop af  
2be5			endm  
# End of macro DMARK
2be5					CALLMONITOR 
2be5 cd c1 19			call break_point_state  
2be8				endm  
# End of macro CALLMONITOR
2be8				endif 
2be8 21 00 80				ld hl, baseram 
2beb					;ld hl, baseusermem 
2beb 01 00 00				ld bc, 0    ; start a counter 
2bee			 
2bee				; skip dict stub 
2bee			 
2bee cd 8a 25				call forth_tok_next 
2bf1			 
2bf1			 
2bf1			; while we have words to look for 
2bf1			 
2bf1 7e			.douscan:	ld a, (hl)      
2bf2				if DEBUG_FORTH_WORDS 
2bf2					DMARK "UWs" 
2bf2 f5				push af  
2bf3 3a 07 2c			ld a, (.dmark)  
2bf6 32 6e fe			ld (debug_mark),a  
2bf9 3a 08 2c			ld a, (.dmark+1)  
2bfc 32 6f fe			ld (debug_mark+1),a  
2bff 3a 09 2c			ld a, (.dmark+2)  
2c02 32 70 fe			ld (debug_mark+2),a  
2c05 18 03			jr .pastdmark  
2c07 ..			.dmark: db "UWs"  
2c0a f1			.pastdmark: pop af  
2c0b			endm  
# End of macro DMARK
2c0b					CALLMONITOR 
2c0b cd c1 19			call break_point_state  
2c0e				endm  
# End of macro CALLMONITOR
2c0e				endif 
2c0e fe 00				cp WORD_SYS_END 
2c10 28 4d				jr z, .udone 
2c12 fe 01				cp WORD_SYS_UWORD 
2c14 20 44				jr nz, .nuword 
2c16			 
2c16				if DEBUG_FORTH_WORDS 
2c16					DMARK "UWu" 
2c16 f5				push af  
2c17 3a 2b 2c			ld a, (.dmark)  
2c1a 32 6e fe			ld (debug_mark),a  
2c1d 3a 2c 2c			ld a, (.dmark+1)  
2c20 32 6f fe			ld (debug_mark+1),a  
2c23 3a 2d 2c			ld a, (.dmark+2)  
2c26 32 70 fe			ld (debug_mark+2),a  
2c29 18 03			jr .pastdmark  
2c2b ..			.dmark: db "UWu"  
2c2e f1			.pastdmark: pop af  
2c2f			endm  
# End of macro DMARK
2c2f					CALLMONITOR 
2c2f cd c1 19			call break_point_state  
2c32				endm  
# End of macro CALLMONITOR
2c32				endif 
2c32					; we have a uword so push its name to the stack 
2c32			 
2c32 e5				   	push hl  ; save so we can move to next dict block 
2c33			 
2c33					; skip opcode 
2c33 23					inc hl  
2c34					; skip next ptr 
2c34 23					inc hl  
2c35 23					inc hl 
2c36					; skip len 
2c36 23					inc hl 
2c37				if DEBUG_FORTH_WORDS 
2c37					DMARK "UWt" 
2c37 f5				push af  
2c38 3a 4c 2c			ld a, (.dmark)  
2c3b 32 6e fe			ld (debug_mark),a  
2c3e 3a 4d 2c			ld a, (.dmark+1)  
2c41 32 6f fe			ld (debug_mark+1),a  
2c44 3a 4e 2c			ld a, (.dmark+2)  
2c47 32 70 fe			ld (debug_mark+2),a  
2c4a 18 03			jr .pastdmark  
2c4c ..			.dmark: db "UWt"  
2c4f f1			.pastdmark: pop af  
2c50			endm  
# End of macro DMARK
2c50					CALLMONITOR 
2c50 cd c1 19			call break_point_state  
2c53				endm  
# End of macro CALLMONITOR
2c53				endif 
2c53 03					inc bc 
2c54			 
2c54 c5					push bc 
2c55 cd fa 20				call forth_push_str 
2c58 c1					pop bc 
2c59			 
2c59 e1					pop hl 	 
2c5a			 
2c5a cd 8a 25		.nuword:	call forth_tok_next 
2c5d 18 92				jr .douscan  
2c5f			 
2c5f			.udone:		 ; push count of uwords found 
2c5f c5					push bc 
2c60 e1					pop hl 
2c61			 
2c61				if DEBUG_FORTH_WORDS 
2c61					DMARK "UWc" 
2c61 f5				push af  
2c62 3a 76 2c			ld a, (.dmark)  
2c65 32 6e fe			ld (debug_mark),a  
2c68 3a 77 2c			ld a, (.dmark+1)  
2c6b 32 6f fe			ld (debug_mark+1),a  
2c6e 3a 78 2c			ld a, (.dmark+2)  
2c71 32 70 fe			ld (debug_mark+2),a  
2c74 18 03			jr .pastdmark  
2c76 ..			.dmark: db "UWc"  
2c79 f1			.pastdmark: pop af  
2c7a			endm  
# End of macro DMARK
2c7a					CALLMONITOR 
2c7a cd c1 19			call break_point_state  
2c7d				endm  
# End of macro CALLMONITOR
2c7d				endif 
2c7d cd 8c 20				call forth_push_numhl 
2c80			 
2c80			 
2c80				       NEXTW 
2c80 c3 39 24			jp macro_next 
2c83				endm 
# End of macro NEXTW
2c83			 
2c83			.BP: 
2c83				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2c83 54				db WORD_SYS_CORE+64             
2c84 b9 2c			dw .MONITOR            
2c86 03				db 2 + 1 
2c87 .. 00			db "BP",0              
2c8a				endm 
# End of macro CWHEAD
2c8a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2c8a			; | | $00 Will enable the break points within specific code paths 
2c8a			; | | $01 Will disable break points 
2c8a			; | |  
2c8a			; | | By default break points are off. Either the above can be used to enable them 
2c8a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2c8a			; | | and on release of the pressed key a message will be disaplayed to notify 
2c8a			; | | that break points are enabled. Pressing any key will then continue boot process. 
2c8a					; get byte count 
2c8a					if DEBUG_FORTH_WORDS_KEY 
2c8a						DMARK "BP." 
2c8a f5				push af  
2c8b 3a 9f 2c			ld a, (.dmark)  
2c8e 32 6e fe			ld (debug_mark),a  
2c91 3a a0 2c			ld a, (.dmark+1)  
2c94 32 6f fe			ld (debug_mark+1),a  
2c97 3a a1 2c			ld a, (.dmark+2)  
2c9a 32 70 fe			ld (debug_mark+2),a  
2c9d 18 03			jr .pastdmark  
2c9f ..			.dmark: db "BP."  
2ca2 f1			.pastdmark: pop af  
2ca3			endm  
# End of macro DMARK
2ca3						CALLMONITOR 
2ca3 cd c1 19			call break_point_state  
2ca6				endm  
# End of macro CALLMONITOR
2ca6					endif 
2ca6			 
2ca6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ca6 cd 83 22			call macro_dsp_valuehl 
2ca9				endm 
# End of macro FORTH_DSP_VALUEHL
2ca9			 
2ca9			;		push hl 
2ca9			 
2ca9					; destroy value TOS 
2ca9			 
2ca9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ca9 cd 3b 23			call macro_forth_dsp_pop 
2cac				endm 
# End of macro FORTH_DSP_POP
2cac			 
2cac			;		pop hl 
2cac			 
2cac 3e 00				ld a,0 
2cae bd					cp l 
2caf 28 02				jr z, .bpset 
2cb1 3e 2a				ld a, '*' 
2cb3			 
2cb3 32 b9 f1		.bpset:		ld (os_view_disable), a 
2cb6			 
2cb6			 
2cb6					NEXTW 
2cb6 c3 39 24			jp macro_next 
2cb9				endm 
# End of macro NEXTW
2cb9			 
2cb9			 
2cb9			.MONITOR: 
2cb9				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2cb9 55				db WORD_SYS_CORE+65             
2cba ec 2c			dw .MALLOC            
2cbc 08				db 7 + 1 
2cbd .. 00			db "MONITOR",0              
2cc5				endm 
# End of macro CWHEAD
2cc5			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2cc5			; | | At start the current various registers will be displayed with contents. 
2cc5			; | | Top right corner will show the most recent debug marker seen. 
2cc5			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2cc5			; | | and the return stack pointer (RSP). 
2cc5			; | | Pressing: 
2cc5			; | |    1 - Initial screen 
2cc5			; | |    2 - Display a data dump of HL 
2cc5			; | |    3 - Display a data dump of DE 
2cc5			; | |    4 - Display a data dump of BC 
2cc5			; | |    5 - Display a data dump of HL 
2cc5			; | |    6 - Display a data dump of DSP 
2cc5			; | |    7 - Display a data dump of RSP 
2cc5			; | |    8 - Display a data dump of what is at DSP 
2cc5			; | |    9 - Display a data dump of what is at RSP 
2cc5			; | |    0 - Exit monitor and continue running. This will also enable break points 
2cc5			; | |    * - Disable break points 
2cc5			; | |    # - Enter traditional monitor mode 
2cc5			; | | 
2cc5			; | | Monitor Mode 
2cc5			; | | ------------ 
2cc5			; | | A prompt of '>' will be shown for various commands: 
2cc5			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2cc5			; | |    C - Continue display a data dump from the last set address 
2cc5			; | |    M xxxx - Set start of memory edit at address xx 
2cc5			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2cc5			; | |    Q - Return to previous 
2cc5					if DEBUG_FORTH_WORDS_KEY 
2cc5						DMARK "MON" 
2cc5 f5				push af  
2cc6 3a da 2c			ld a, (.dmark)  
2cc9 32 6e fe			ld (debug_mark),a  
2ccc 3a db 2c			ld a, (.dmark+1)  
2ccf 32 6f fe			ld (debug_mark+1),a  
2cd2 3a dc 2c			ld a, (.dmark+2)  
2cd5 32 70 fe			ld (debug_mark+2),a  
2cd8 18 03			jr .pastdmark  
2cda ..			.dmark: db "MON"  
2cdd f1			.pastdmark: pop af  
2cde			endm  
# End of macro DMARK
2cde						CALLMONITOR 
2cde cd c1 19			call break_point_state  
2ce1				endm  
# End of macro CALLMONITOR
2ce1					endif 
2ce1 3e 00				ld a, 0 
2ce3 32 b9 f1				ld (os_view_disable), a 
2ce6			 
2ce6					CALLMONITOR 
2ce6 cd c1 19			call break_point_state  
2ce9				endm  
# End of macro CALLMONITOR
2ce9			 
2ce9			;	call monitor 
2ce9			 
2ce9					NEXTW 
2ce9 c3 39 24			jp macro_next 
2cec				endm 
# End of macro NEXTW
2cec			 
2cec			 
2cec			.MALLOC: 
2cec				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2cec 56				db WORD_SYS_CORE+66             
2ced 15 2d			dw .MALLOC2            
2cef 06				db 5 + 1 
2cf0 .. 00			db "ALLOT",0              
2cf6				endm 
# End of macro CWHEAD
2cf6			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cf6					if DEBUG_FORTH_WORDS_KEY 
2cf6						DMARK "ALL" 
2cf6 f5				push af  
2cf7 3a 0b 2d			ld a, (.dmark)  
2cfa 32 6e fe			ld (debug_mark),a  
2cfd 3a 0c 2d			ld a, (.dmark+1)  
2d00 32 6f fe			ld (debug_mark+1),a  
2d03 3a 0d 2d			ld a, (.dmark+2)  
2d06 32 70 fe			ld (debug_mark+2),a  
2d09 18 03			jr .pastdmark  
2d0b ..			.dmark: db "ALL"  
2d0e f1			.pastdmark: pop af  
2d0f			endm  
# End of macro DMARK
2d0f						CALLMONITOR 
2d0f cd c1 19			call break_point_state  
2d12				endm  
# End of macro CALLMONITOR
2d12					endif 
2d12 c3 3c 2d				jp .mallocc 
2d15			.MALLOC2: 
2d15				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d15 56				db WORD_SYS_CORE+66             
2d16 53 2d			dw .FREE            
2d18 07				db 6 + 1 
2d19 .. 00			db "MALLOC",0              
2d20				endm 
# End of macro CWHEAD
2d20			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d20					; get byte count 
2d20					if DEBUG_FORTH_WORDS_KEY 
2d20						DMARK "MAL" 
2d20 f5				push af  
2d21 3a 35 2d			ld a, (.dmark)  
2d24 32 6e fe			ld (debug_mark),a  
2d27 3a 36 2d			ld a, (.dmark+1)  
2d2a 32 6f fe			ld (debug_mark+1),a  
2d2d 3a 37 2d			ld a, (.dmark+2)  
2d30 32 70 fe			ld (debug_mark+2),a  
2d33 18 03			jr .pastdmark  
2d35 ..			.dmark: db "MAL"  
2d38 f1			.pastdmark: pop af  
2d39			endm  
# End of macro DMARK
2d39						CALLMONITOR 
2d39 cd c1 19			call break_point_state  
2d3c				endm  
# End of macro CALLMONITOR
2d3c					endif 
2d3c			.mallocc: 
2d3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d3c cd 83 22			call macro_dsp_valuehl 
2d3f				endm 
# End of macro FORTH_DSP_VALUEHL
2d3f			 
2d3f			;		push hl 
2d3f			 
2d3f					; destroy value TOS 
2d3f			 
2d3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d3f cd 3b 23			call macro_forth_dsp_pop 
2d42				endm 
# End of macro FORTH_DSP_POP
2d42			 
2d42			;		pop hl 
2d42 cd 13 14				call malloc 
2d45				if DEBUG_FORTH_MALLOC_GUARD 
2d45 f5					push af 
2d46 cd 75 0f				call ishlzero 
2d49			;		ld a, l 
2d49			;		add h 
2d49			;		cp 0 
2d49 f1					pop af 
2d4a					 
2d4a cc 0b 5d				call z,malloc_error 
2d4d				endif 
2d4d			 
2d4d cd 8c 20				call forth_push_numhl 
2d50					NEXTW 
2d50 c3 39 24			jp macro_next 
2d53				endm 
# End of macro NEXTW
2d53			 
2d53			.FREE: 
2d53				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2d53 57				db WORD_SYS_CORE+67             
2d54 84 2d			dw .LIST            
2d56 05				db 4 + 1 
2d57 .. 00			db "FREE",0              
2d5c				endm 
# End of macro CWHEAD
2d5c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2d5c					if DEBUG_FORTH_WORDS_KEY 
2d5c						DMARK "FRE" 
2d5c f5				push af  
2d5d 3a 71 2d			ld a, (.dmark)  
2d60 32 6e fe			ld (debug_mark),a  
2d63 3a 72 2d			ld a, (.dmark+1)  
2d66 32 6f fe			ld (debug_mark+1),a  
2d69 3a 73 2d			ld a, (.dmark+2)  
2d6c 32 70 fe			ld (debug_mark+2),a  
2d6f 18 03			jr .pastdmark  
2d71 ..			.dmark: db "FRE"  
2d74 f1			.pastdmark: pop af  
2d75			endm  
# End of macro DMARK
2d75						CALLMONITOR 
2d75 cd c1 19			call break_point_state  
2d78				endm  
# End of macro CALLMONITOR
2d78					endif 
2d78					; get address 
2d78			 
2d78					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d78 cd 83 22			call macro_dsp_valuehl 
2d7b				endm 
# End of macro FORTH_DSP_VALUEHL
2d7b			 
2d7b			;		push hl 
2d7b			 
2d7b					; destroy value TOS 
2d7b			 
2d7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d7b cd 3b 23			call macro_forth_dsp_pop 
2d7e				endm 
# End of macro FORTH_DSP_POP
2d7e			 
2d7e			;		pop hl 
2d7e			if FORTH_ENABLE_MALLOCFREE 
2d7e cd dd 14				call free 
2d81			endif 
2d81					NEXTW 
2d81 c3 39 24			jp macro_next 
2d84				endm 
# End of macro NEXTW
2d84			.LIST: 
2d84				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2d84 5c				db WORD_SYS_CORE+72             
2d85 72 2f			dw .FORGET            
2d87 05				db 4 + 1 
2d88 .. 00			db "LIST",0              
2d8d				endm 
# End of macro CWHEAD
2d8d			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2d8d			; | | The quoted word must be in upper case. 
2d8d				if DEBUG_FORTH_WORDS_KEY 
2d8d					DMARK "LST" 
2d8d f5				push af  
2d8e 3a a2 2d			ld a, (.dmark)  
2d91 32 6e fe			ld (debug_mark),a  
2d94 3a a3 2d			ld a, (.dmark+1)  
2d97 32 6f fe			ld (debug_mark+1),a  
2d9a 3a a4 2d			ld a, (.dmark+2)  
2d9d 32 70 fe			ld (debug_mark+2),a  
2da0 18 03			jr .pastdmark  
2da2 ..			.dmark: db "LST"  
2da5 f1			.pastdmark: pop af  
2da6			endm  
# End of macro DMARK
2da6					CALLMONITOR 
2da6 cd c1 19			call break_point_state  
2da9				endm  
# End of macro CALLMONITOR
2da9				endif 
2da9			 
2da9					FORTH_DSP_VALUEHL 
2da9 cd 83 22			call macro_dsp_valuehl 
2dac				endm 
# End of macro FORTH_DSP_VALUEHL
2dac			 
2dac e5					push hl 
2dad					FORTH_DSP_POP 
2dad cd 3b 23			call macro_forth_dsp_pop 
2db0				endm 
# End of macro FORTH_DSP_POP
2db0 c1					pop bc 
2db1			 
2db1			; Start format of scratch string 
2db1			 
2db1 21 c8 f1				ld hl, scratch 
2db4			 
2db4 3e 3a				ld a, ':' 
2db6 77					ld (hl),a 
2db7 23					inc hl 
2db8 3e 20				ld a, ' ' 
2dba 77					ld (hl), a 
2dbb			 
2dbb					; Get ptr to the word we need to look up 
2dbb			 
2dbb			;		FORTH_DSP_VALUEHL 
2dbb					;v5 FORTH_DSP_VALUE 
2dbb				; TODO type check 
2dbb			;		inc hl    ; Skip type check  
2dbb			;		push hl 
2dbb			;		ex de, hl    ; put into DE 
2dbb			 
2dbb			 
2dbb 21 00 80				ld hl, baseram 
2dbe					;ld hl, baseusermem 
2dbe			 
2dbe e5			push hl   ; sacreifical push 
2dbf			 
2dbf			.ldouscanm: 
2dbf e1				pop hl 
2dc0			.ldouscan: 
2dc0				if DEBUG_FORTH_WORDS 
2dc0					DMARK "LSs" 
2dc0 f5				push af  
2dc1 3a d5 2d			ld a, (.dmark)  
2dc4 32 6e fe			ld (debug_mark),a  
2dc7 3a d6 2d			ld a, (.dmark+1)  
2dca 32 6f fe			ld (debug_mark+1),a  
2dcd 3a d7 2d			ld a, (.dmark+2)  
2dd0 32 70 fe			ld (debug_mark+2),a  
2dd3 18 03			jr .pastdmark  
2dd5 ..			.dmark: db "LSs"  
2dd8 f1			.pastdmark: pop af  
2dd9			endm  
# End of macro DMARK
2dd9					CALLMONITOR 
2dd9 cd c1 19			call break_point_state  
2ddc				endm  
# End of macro CALLMONITOR
2ddc				endif 
2ddc				; skip dict stub 
2ddc cd 8a 25				call forth_tok_next 
2ddf			 
2ddf			 
2ddf			; while we have words to look for 
2ddf			 
2ddf 7e				ld a, (hl)      
2de0				if DEBUG_FORTH_WORDS 
2de0					DMARK "LSk" 
2de0 f5				push af  
2de1 3a f5 2d			ld a, (.dmark)  
2de4 32 6e fe			ld (debug_mark),a  
2de7 3a f6 2d			ld a, (.dmark+1)  
2dea 32 6f fe			ld (debug_mark+1),a  
2ded 3a f7 2d			ld a, (.dmark+2)  
2df0 32 70 fe			ld (debug_mark+2),a  
2df3 18 03			jr .pastdmark  
2df5 ..			.dmark: db "LSk"  
2df8 f1			.pastdmark: pop af  
2df9			endm  
# End of macro DMARK
2df9					CALLMONITOR 
2df9 cd c1 19			call break_point_state  
2dfc				endm  
# End of macro CALLMONITOR
2dfc				endif 
2dfc					;cp WORD_SYS_END 
2dfc					;jp z, .lunotfound 
2dfc			 
2dfc					; if we hit non uwords then gone too far 
2dfc fe 01				cp WORD_SYS_UWORD 
2dfe c2 2e 2f				jp nz, .lunotfound 
2e01			 
2e01				if DEBUG_FORTH_WORDS 
2e01					DMARK "LSu" 
2e01 f5				push af  
2e02 3a 16 2e			ld a, (.dmark)  
2e05 32 6e fe			ld (debug_mark),a  
2e08 3a 17 2e			ld a, (.dmark+1)  
2e0b 32 6f fe			ld (debug_mark+1),a  
2e0e 3a 18 2e			ld a, (.dmark+2)  
2e11 32 70 fe			ld (debug_mark+2),a  
2e14 18 03			jr .pastdmark  
2e16 ..			.dmark: db "LSu"  
2e19 f1			.pastdmark: pop af  
2e1a			endm  
# End of macro DMARK
2e1a					CALLMONITOR 
2e1a cd c1 19			call break_point_state  
2e1d				endm  
# End of macro CALLMONITOR
2e1d				endif 
2e1d			 
2e1d					; found a uword but is it the one we want... 
2e1d			 
2e1d c5					push bc     ; uword to find is on bc 
2e1e d1					pop de 
2e1f			 
2e1f e5					push hl  ; to save the ptr 
2e20			 
2e20					; skip opcode 
2e20 23					inc hl  
2e21					; skip next ptr 
2e21 23					inc hl  
2e22 23					inc hl 
2e23					; skip len 
2e23 23					inc hl 
2e24			 
2e24				if DEBUG_FORTH_WORDS 
2e24					DMARK "LSc" 
2e24 f5				push af  
2e25 3a 39 2e			ld a, (.dmark)  
2e28 32 6e fe			ld (debug_mark),a  
2e2b 3a 3a 2e			ld a, (.dmark+1)  
2e2e 32 6f fe			ld (debug_mark+1),a  
2e31 3a 3b 2e			ld a, (.dmark+2)  
2e34 32 70 fe			ld (debug_mark+2),a  
2e37 18 03			jr .pastdmark  
2e39 ..			.dmark: db "LSc"  
2e3c f1			.pastdmark: pop af  
2e3d			endm  
# End of macro DMARK
2e3d					CALLMONITOR 
2e3d cd c1 19			call break_point_state  
2e40				endm  
# End of macro CALLMONITOR
2e40				endif 
2e40 cd e2 13				call strcmp 
2e43 c2 bf 2d				jp nz, .ldouscanm 
2e46				 
2e46			 
2e46			 
2e46					; we have a uword so push its name to the stack 
2e46			 
2e46			;	   	push hl  ; save so we can move to next dict block 
2e46 e1			pop hl 
2e47			 
2e47				if DEBUG_FORTH_WORDS 
2e47					DMARK "LSm" 
2e47 f5				push af  
2e48 3a 5c 2e			ld a, (.dmark)  
2e4b 32 6e fe			ld (debug_mark),a  
2e4e 3a 5d 2e			ld a, (.dmark+1)  
2e51 32 6f fe			ld (debug_mark+1),a  
2e54 3a 5e 2e			ld a, (.dmark+2)  
2e57 32 70 fe			ld (debug_mark+2),a  
2e5a 18 03			jr .pastdmark  
2e5c ..			.dmark: db "LSm"  
2e5f f1			.pastdmark: pop af  
2e60			endm  
# End of macro DMARK
2e60					CALLMONITOR 
2e60 cd c1 19			call break_point_state  
2e63				endm  
# End of macro CALLMONITOR
2e63				endif 
2e63			 
2e63					; skip opcode 
2e63 23					inc hl  
2e64					; skip next ptr 
2e64 23					inc hl  
2e65 23					inc hl 
2e66					; skip len 
2e66 7e					ld a, (hl)   ; save length to add 
2e67				if DEBUG_FORTH_WORDS 
2e67					DMARK "LS2" 
2e67 f5				push af  
2e68 3a 7c 2e			ld a, (.dmark)  
2e6b 32 6e fe			ld (debug_mark),a  
2e6e 3a 7d 2e			ld a, (.dmark+1)  
2e71 32 6f fe			ld (debug_mark+1),a  
2e74 3a 7e 2e			ld a, (.dmark+2)  
2e77 32 70 fe			ld (debug_mark+2),a  
2e7a 18 03			jr .pastdmark  
2e7c ..			.dmark: db "LS2"  
2e7f f1			.pastdmark: pop af  
2e80			endm  
# End of macro DMARK
2e80					CALLMONITOR 
2e80 cd c1 19			call break_point_state  
2e83				endm  
# End of macro CALLMONITOR
2e83				endif 
2e83			 
2e83					; save this location 
2e83				 
2e83 e5					push hl 
2e84			 
2e84 23					inc hl 
2e85 11 ca f1				ld de, scratch+2 
2e88 4f					ld c, a 
2e89 06 00				ld b, 0 
2e8b			 
2e8b				if DEBUG_FORTH_WORDS 
2e8b					DMARK "LSn" 
2e8b f5				push af  
2e8c 3a a0 2e			ld a, (.dmark)  
2e8f 32 6e fe			ld (debug_mark),a  
2e92 3a a1 2e			ld a, (.dmark+1)  
2e95 32 6f fe			ld (debug_mark+1),a  
2e98 3a a2 2e			ld a, (.dmark+2)  
2e9b 32 70 fe			ld (debug_mark+2),a  
2e9e 18 03			jr .pastdmark  
2ea0 ..			.dmark: db "LSn"  
2ea3 f1			.pastdmark: pop af  
2ea4			endm  
# End of macro DMARK
2ea4					CALLMONITOR 
2ea4 cd c1 19			call break_point_state  
2ea7				endm  
# End of macro CALLMONITOR
2ea7				endif 
2ea7			 
2ea7					; copy uword name to scratch 
2ea7			 
2ea7 ed b0				ldir 
2ea9			 
2ea9 1b					dec de 
2eaa 3e 20				ld a, ' '    ; change null to space 
2eac 12					ld (de), a 
2ead			 
2ead 13					inc de 
2eae			 
2eae d5					push de 
2eaf c1					pop bc     ; move scratch pointer to end of word name and save it 
2eb0			 
2eb0 e1					pop hl 
2eb1 7e					ld a, (hl) 
2eb2					;inc hl 
2eb2					; skip word string 
2eb2 cd 4c 0f				call addatohl 
2eb5			 
2eb5 23					inc hl 
2eb6			 
2eb6				if DEBUG_FORTH_WORDS 
2eb6					DMARK "LS3" 
2eb6 f5				push af  
2eb7 3a cb 2e			ld a, (.dmark)  
2eba 32 6e fe			ld (debug_mark),a  
2ebd 3a cc 2e			ld a, (.dmark+1)  
2ec0 32 6f fe			ld (debug_mark+1),a  
2ec3 3a cd 2e			ld a, (.dmark+2)  
2ec6 32 70 fe			ld (debug_mark+2),a  
2ec9 18 03			jr .pastdmark  
2ecb ..			.dmark: db "LS3"  
2ece f1			.pastdmark: pop af  
2ecf			endm  
# End of macro DMARK
2ecf					CALLMONITOR 
2ecf cd c1 19			call break_point_state  
2ed2				endm  
# End of macro CALLMONITOR
2ed2				endif 
2ed2					; should now be at the start of the machine code to setup the eval of the uword 
2ed2					; now locate the ptr to the string defintion 
2ed2			 
2ed2					; skip ld hl, 
2ed2					; then load the ptr 
2ed2			; TODO use get from hl ptr 
2ed2 23					inc hl 
2ed3 5e					ld e, (hl) 
2ed4 23					inc hl 
2ed5 56					ld d, (hl) 
2ed6 eb					ex de, hl 
2ed7			 
2ed7			 
2ed7				if DEBUG_FORTH_WORDS 
2ed7					DMARK "LSt" 
2ed7 f5				push af  
2ed8 3a ec 2e			ld a, (.dmark)  
2edb 32 6e fe			ld (debug_mark),a  
2ede 3a ed 2e			ld a, (.dmark+1)  
2ee1 32 6f fe			ld (debug_mark+1),a  
2ee4 3a ee 2e			ld a, (.dmark+2)  
2ee7 32 70 fe			ld (debug_mark+2),a  
2eea 18 03			jr .pastdmark  
2eec ..			.dmark: db "LSt"  
2eef f1			.pastdmark: pop af  
2ef0			endm  
# End of macro DMARK
2ef0					CALLMONITOR 
2ef0 cd c1 19			call break_point_state  
2ef3				endm  
# End of macro CALLMONITOR
2ef3				endif 
2ef3			 
2ef3			; cant push right now due to tokenised strings  
2ef3			 
2ef3			; get the destination of where to copy this definition to. 
2ef3			 
2ef3 c5					push bc 
2ef4 d1					pop de 
2ef5			 
2ef5 7e			.listl:         ld a,(hl) 
2ef6 fe 00				cp 0 
2ef8 28 09				jr z, .lreplsp     ; replace zero with space 
2efa					;cp FORTH_END_BUFFER 
2efa fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2efc 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2efe				 
2efe					; just copy this char as is then 
2efe			 
2efe 12					ld (de), a 
2eff			 
2eff 23			.listnxt:	inc hl 
2f00 13					inc de 
2f01 18 f2				jr .listl 
2f03			 
2f03 3e 20		.lreplsp:	ld a,' ' 
2f05 12					ld (de), a 
2f06 18 f7				jr .listnxt 
2f08			 
2f08			; close up uword def 
2f08			 
2f08			.listdone: 
2f08 12					ld (de), a 
2f09 13					inc de 
2f0a 3e 00				ld a, 0 
2f0c 12					ld (de), a 
2f0d			 
2f0d			; now have def so clean up and push to stack 
2f0d			 
2f0d 21 c8 f1				ld hl, scratch 
2f10				if DEBUG_FORTH_WORDS 
2f10					DMARK "Ltp" 
2f10 f5				push af  
2f11 3a 25 2f			ld a, (.dmark)  
2f14 32 6e fe			ld (debug_mark),a  
2f17 3a 26 2f			ld a, (.dmark+1)  
2f1a 32 6f fe			ld (debug_mark+1),a  
2f1d 3a 27 2f			ld a, (.dmark+2)  
2f20 32 70 fe			ld (debug_mark+2),a  
2f23 18 03			jr .pastdmark  
2f25 ..			.dmark: db "Ltp"  
2f28 f1			.pastdmark: pop af  
2f29			endm  
# End of macro DMARK
2f29					CALLMONITOR 
2f29 cd c1 19			call break_point_state  
2f2c				endm  
# End of macro CALLMONITOR
2f2c				endif 
2f2c			 
2f2c 18 1f			jr .listpush 
2f2e			 
2f2e			;.lnuword:	pop hl 
2f2e			;		call forth_tok_next 
2f2e			;		jp .ldouscan  
2f2e			 
2f2e			.lunotfound:		  
2f2e			 
2f2e				if DEBUG_FORTH_WORDS 
2f2e					DMARK "LSn" 
2f2e f5				push af  
2f2f 3a 43 2f			ld a, (.dmark)  
2f32 32 6e fe			ld (debug_mark),a  
2f35 3a 44 2f			ld a, (.dmark+1)  
2f38 32 6f fe			ld (debug_mark+1),a  
2f3b 3a 45 2f			ld a, (.dmark+2)  
2f3e 32 70 fe			ld (debug_mark+2),a  
2f41 18 03			jr .pastdmark  
2f43 ..			.dmark: db "LSn"  
2f46 f1			.pastdmark: pop af  
2f47			endm  
# End of macro DMARK
2f47					CALLMONITOR 
2f47 cd c1 19			call break_point_state  
2f4a				endm  
# End of macro CALLMONITOR
2f4a				endif 
2f4a			 
2f4a					 
2f4a			;		FORTH_DSP_POP 
2f4a			;		ld hl, .luno 
2f4a			 
2f4a					NEXTW			 
2f4a c3 39 24			jp macro_next 
2f4d				endm 
# End of macro NEXTW
2f4d			 
2f4d			.listpush: 
2f4d				if DEBUG_FORTH_WORDS 
2f4d					DMARK "LS>" 
2f4d f5				push af  
2f4e 3a 62 2f			ld a, (.dmark)  
2f51 32 6e fe			ld (debug_mark),a  
2f54 3a 63 2f			ld a, (.dmark+1)  
2f57 32 6f fe			ld (debug_mark+1),a  
2f5a 3a 64 2f			ld a, (.dmark+2)  
2f5d 32 70 fe			ld (debug_mark+2),a  
2f60 18 03			jr .pastdmark  
2f62 ..			.dmark: db "LS>"  
2f65 f1			.pastdmark: pop af  
2f66			endm  
# End of macro DMARK
2f66					CALLMONITOR 
2f66 cd c1 19			call break_point_state  
2f69				endm  
# End of macro CALLMONITOR
2f69				endif 
2f69 cd fa 20				call forth_push_str 
2f6c			 
2f6c			 
2f6c			 
2f6c					NEXTW 
2f6c c3 39 24			jp macro_next 
2f6f				endm 
# End of macro NEXTW
2f6f			 
2f6f			;.luno:    db "Word not found",0 
2f6f			 
2f6f			 
2f6f			 
2f6f			 
2f6f			 
2f6f			;		push hl   ; save pointer to start of uword def string 
2f6f			; 
2f6f			;; look for FORTH_EOL_LINE 
2f6f			;		ld a, FORTH_END_BUFFER 
2f6f			;		call strlent 
2f6f			; 
2f6f			;		inc hl		 ; space for coln def 
2f6f			;		inc hl 
2f6f			;		inc hl          ; space for terms 
2f6f			;		inc hl 
2f6f			; 
2f6f			;		ld a, 20   ; TODO get actual length 
2f6f			;		call addatohl    ; include a random amount of room for the uword name 
2f6f			; 
2f6f			;		 
2f6f			;	if DEBUG_FORTH_WORDS 
2f6f			;		DMARK "Lt1" 
2f6f			;		CALLMONITOR 
2f6f			;	endif 
2f6f			;		 
2f6f			; 
2f6f			;; malloc space for the string because we cant change it 
2f6f			; 
2f6f			;		call malloc 
2f6f			;	if DEBUG_FORTH_MALLOC_GUARD 
2f6f			;		push af 
2f6f			;		call ishlzero 
2f6f			;		pop af 
2f6f			;		 
2f6f			;		call z,malloc_error 
2f6f			;	endif 
2f6f			; 
2f6f			;	if DEBUG_FORTH_WORDS 
2f6f			;		DMARK "Lt2" 
2f6f			;		CALLMONITOR 
2f6f			;	endif 
2f6f			;		pop de 
2f6f			;		push hl    ; push the malloc to release later 
2f6f			;		push hl   ;  push back a copy for the later stack push 
2f6f			;		 
2f6f			;; copy the string swapping out the zero terms for spaces 
2f6f			; 
2f6f			;		; de has our source 
2f6f			;		; hl has our dest 
2f6f			; 
2f6f			;; add the coln def 
2f6f			; 
2f6f			;		ld a, ':' 
2f6f			;		ld (hl), a 
2f6f			;		inc hl 
2f6f			;		ld a, ' ' 
2f6f			;		ld (hl), a 
2f6f			;		inc hl 
2f6f			; 
2f6f			;; add the uname word 
2f6f			;		push de   ; save our string for now 
2f6f			;		ex de, hl 
2f6f			; 
2f6f			;		FORTH_DSP_VALUE 
2f6f			;		;v5 FORTH_DSP_VALUE 
2f6f			; 
2f6f			;		inc hl   ; skip type but we know by now this is OK 
2f6f			; 
2f6f			;.luword:	ld a,(hl) 
2f6f			;		cp 0 
2f6f			;		jr z, .luword2 
2f6f			;		ld (de), a 
2f6f			;		inc de 
2f6f			;		inc hl 
2f6f			;		jr .luword 
2f6f			; 
2f6f			;.luword2:	ld a, ' ' 
2f6f			;		ld (de), a 
2f6f			;;		inc hl 
2f6f			;;		inc de 
2f6f			;;		ld (de), a 
2f6f			;;		inc hl 
2f6f			;		inc de 
2f6f			; 
2f6f			;		ex de, hl 
2f6f			;		pop de 
2f6f			;		 
2f6f			;		 
2f6f			; 
2f6f			;; detoken that string and copy it 
2f6f			; 
2f6f			;	if DEBUG_FORTH_WORDS 
2f6f			;		DMARK "Lt2" 
2f6f			;		CALLMONITOR 
2f6f			;	endif 
2f6f			;.ldetok:	ld a, (de) 
2f6f			;		cp FORTH_END_BUFFER 
2f6f			;		jr z, .ldetokend 
2f6f			;		; swap out any zero term for space 
2f6f			;		cp 0 
2f6f			;		jr nz, .ldetoknext 
2f6f			;		ld a, ' ' 
2f6f			; 
2f6f			;	if DEBUG_FORTH_WORDS 
2f6f			;		DMARK "LtS" 
2f6f			;		CALLMONITOR 
2f6f			;	endif 
2f6f			;.ldetoknext:	ld (hl), a 
2f6f			;		inc de 
2f6f			;		inc hl 
2f6f			;		jr .ldetok 
2f6f			; 
2f6f			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2f6f			;		ld (hl), a  
2f6f			; 
2f6f			;; free that temp malloc 
2f6f			; 
2f6f			;		pop hl    
2f6f			; 
2f6f			;	if DEBUG_FORTH_WORDS 
2f6f			;		DMARK "Lt4" 
2f6f			;		CALLMONITOR 
2f6f			;	endif 
2f6f			;		call forth_apushstrhl 
2f6f			; 
2f6f			;		; get rid of temp malloc area 
2f6f			; 
2f6f			;		pop hl 
2f6f			;		call free 
2f6f			; 
2f6f			;		jr .ludone 
2f6f			; 
2f6f			;.lnuword:	pop hl 
2f6f			;		call forth_tok_next 
2f6f			;		jp .ldouscan  
2f6f			; 
2f6f			;.ludone:		 pop hl 
2f6f			; 
2f6f					NEXTW 
2f6f c3 39 24			jp macro_next 
2f72				endm 
# End of macro NEXTW
2f72			 
2f72			.FORGET: 
2f72				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2f72 5d				db WORD_SYS_CORE+73             
2f73 eb 2f			dw .NOP            
2f75 07				db 6 + 1 
2f76 .. 00			db "FORGET",0              
2f7d				endm 
# End of macro CWHEAD
2f7d			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2f7d			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2f7d			; | |  
2f7d			; | | e.g. "MORE" forget 
2f7d					if DEBUG_FORTH_WORDS_KEY 
2f7d						DMARK "FRG" 
2f7d f5				push af  
2f7e 3a 92 2f			ld a, (.dmark)  
2f81 32 6e fe			ld (debug_mark),a  
2f84 3a 93 2f			ld a, (.dmark+1)  
2f87 32 6f fe			ld (debug_mark+1),a  
2f8a 3a 94 2f			ld a, (.dmark+2)  
2f8d 32 70 fe			ld (debug_mark+2),a  
2f90 18 03			jr .pastdmark  
2f92 ..			.dmark: db "FRG"  
2f95 f1			.pastdmark: pop af  
2f96			endm  
# End of macro DMARK
2f96						CALLMONITOR 
2f96 cd c1 19			call break_point_state  
2f99				endm  
# End of macro CALLMONITOR
2f99					endif 
2f99			 
2f99				; find uword 
2f99			        ; update start of word with "_" 
2f99				; replace uword with deleted flag 
2f99			 
2f99			 
2f99			;	if DEBUG_FORTH_WORDS 
2f99			;		DMARK "FOG" 
2f99			;		CALLMONITOR 
2f99			;	endif 
2f99			 
2f99			 
2f99					; Get ptr to the word we need to look up 
2f99			 
2f99					FORTH_DSP_VALUEHL 
2f99 cd 83 22			call macro_dsp_valuehl 
2f9c				endm 
# End of macro FORTH_DSP_VALUEHL
2f9c					;v5 FORTH_DSP_VALUE 
2f9c				; TODO type check 
2f9c			;		inc hl    ; Skip type check  
2f9c e5					push hl 
2f9d c1					pop bc 
2f9e			;		ex de, hl    ; put into DE 
2f9e			 
2f9e			 
2f9e 21 00 80				ld hl, baseram 
2fa1					;ld hl, baseusermem 
2fa1			 
2fa1				; skip dict stub 
2fa1			;	call forth_tok_next 
2fa1 e5			push hl   ; sacreifical push 
2fa2			 
2fa2			.fldouscanm: 
2fa2 e1				pop hl 
2fa3			.fldouscan: 
2fa3			;	if DEBUG_FORTH_WORDS 
2fa3			;		DMARK "LSs" 
2fa3			;		CALLMONITOR 
2fa3			;	endif 
2fa3				; skip dict stub 
2fa3 cd 8a 25				call forth_tok_next 
2fa6			 
2fa6			 
2fa6			; while we have words to look for 
2fa6			 
2fa6 7e				ld a, (hl)      
2fa7			;	if DEBUG_FORTH_WORDS 
2fa7			;		DMARK "LSk" 
2fa7			;		CALLMONITOR 
2fa7			;	endif 
2fa7 fe 00				cp WORD_SYS_END 
2fa9 ca e5 2f				jp z, .flunotfound 
2fac fe 01				cp WORD_SYS_UWORD 
2fae c2 a3 2f				jp nz, .fldouscan 
2fb1			 
2fb1			;	if DEBUG_FORTH_WORDS 
2fb1			;		DMARK "LSu" 
2fb1			;		CALLMONITOR 
2fb1			;	endif 
2fb1			 
2fb1					; found a uword but is it the one we want... 
2fb1			 
2fb1 c5					push bc     ; uword to find is on bc 
2fb2 d1					pop de 
2fb3			 
2fb3 e5					push hl  ; to save the ptr 
2fb4			 
2fb4					; skip opcode 
2fb4 23					inc hl  
2fb5					; skip next ptr 
2fb5 23					inc hl  
2fb6 23					inc hl 
2fb7					; skip len 
2fb7 23					inc hl 
2fb8			 
2fb8			;	if DEBUG_FORTH_WORDS 
2fb8			;		DMARK "LSc" 
2fb8			;		CALLMONITOR 
2fb8			;	endif 
2fb8 cd e2 13				call strcmp 
2fbb c2 a2 2f				jp nz, .fldouscanm 
2fbe			; 
2fbe			; 
2fbe			;; while we have words to look for 
2fbe			; 
2fbe			;.fdouscan:	ld a, (hl)      
2fbe			;	if DEBUG_FORTH_WORDS 
2fbe			;		DMARK "LSs" 
2fbe			;		CALLMONITOR 
2fbe			;	endif 
2fbe			;		cp WORD_SYS_END 
2fbe			;		jp z, .fudone 
2fbe			;		cp WORD_SYS_UWORD 
2fbe			;		jp nz, .fnuword 
2fbe			; 
2fbe			;	if DEBUG_FORTH_WORDS 
2fbe			;		DMARK "FGu" 
2fbe			;		CALLMONITOR 
2fbe			;	endif 
2fbe			; 
2fbe			;		; found a uword but is it the one we want... 
2fbe			; 
2fbe			; 
2fbe			;	        pop de   ; get back the dsp name 
2fbe			;		push de 
2fbe			; 
2fbe			;		push hl  ; to save the ptr 
2fbe			; 
2fbe			;		; skip opcode 
2fbe			;		inc hl  
2fbe			;		; skip next ptr 
2fbe			;		inc hl  
2fbe			;		inc hl 
2fbe			;		; skip len 
2fbe			;		inc hl 
2fbe			; 
2fbe			;	if DEBUG_FORTH_WORDS 
2fbe			;		DMARK "FGc" 
2fbe			;		CALLMONITOR 
2fbe			;	endif 
2fbe			;		call strcmp 
2fbe			;		jp nz, .fnuword 
2fbe			 
2fbe			 
2fbe e1			pop hl 
2fbf			 
2fbf				 
2fbf				if DEBUG_FORTH_WORDS 
2fbf					DMARK "FGm" 
2fbf f5				push af  
2fc0 3a d4 2f			ld a, (.dmark)  
2fc3 32 6e fe			ld (debug_mark),a  
2fc6 3a d5 2f			ld a, (.dmark+1)  
2fc9 32 6f fe			ld (debug_mark+1),a  
2fcc 3a d6 2f			ld a, (.dmark+2)  
2fcf 32 70 fe			ld (debug_mark+2),a  
2fd2 18 03			jr .pastdmark  
2fd4 ..			.dmark: db "FGm"  
2fd7 f1			.pastdmark: pop af  
2fd8			endm  
# End of macro DMARK
2fd8					CALLMONITOR 
2fd8 cd c1 19			call break_point_state  
2fdb				endm  
# End of macro CALLMONITOR
2fdb				endif 
2fdb			 
2fdb			 
2fdb			 
2fdb					; we have a uword so push its name to the stack 
2fdb			 
2fdb			;	   	push hl  ; save so we can move to next dict block 
2fdb			;pop hl 
2fdb			 
2fdb					; update opcode to deleted 
2fdb 3e 03				ld a, WORD_SYS_DELETED 
2fdd 77					ld (hl), a 
2fde			 
2fde 23					inc hl  
2fdf					; skip next ptr 
2fdf 23					inc hl  
2fe0 23					inc hl 
2fe1					; skip len 
2fe1 23					inc hl 
2fe2			 
2fe2					; TODO change parser to skip deleted words but for now mark it out 
2fe2 3e 5f				ld a, "_" 
2fe4 77					ld  (hl),a 
2fe5			 
2fe5			;		jr .fudone 
2fe5			; 
2fe5			;.fnuword:	pop hl 
2fe5			;		call forth_tok_next 
2fe5			;		jp .fdouscan  
2fe5			 
2fe5			.flunotfound:		  
2fe5			 
2fe5			 
2fe5					 
2fe5					FORTH_DSP_POP 
2fe5 cd 3b 23			call macro_forth_dsp_pop 
2fe8				endm 
# End of macro FORTH_DSP_POP
2fe8			;		ld hl, .luno 
2fe8			;.fudone:		 pop hl 
2fe8					NEXTW 
2fe8 c3 39 24			jp macro_next 
2feb				endm 
# End of macro NEXTW
2feb			.NOP: 
2feb				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2feb 61				db WORD_SYS_CORE+77             
2fec 12 30			dw .COMO            
2fee 04				db 3 + 1 
2fef .. 00			db "NOP",0              
2ff3				endm 
# End of macro CWHEAD
2ff3			; | NOP (  --  ) Do nothing | DONE 
2ff3					if DEBUG_FORTH_WORDS_KEY 
2ff3						DMARK "NOP" 
2ff3 f5				push af  
2ff4 3a 08 30			ld a, (.dmark)  
2ff7 32 6e fe			ld (debug_mark),a  
2ffa 3a 09 30			ld a, (.dmark+1)  
2ffd 32 6f fe			ld (debug_mark+1),a  
3000 3a 0a 30			ld a, (.dmark+2)  
3003 32 70 fe			ld (debug_mark+2),a  
3006 18 03			jr .pastdmark  
3008 ..			.dmark: db "NOP"  
300b f1			.pastdmark: pop af  
300c			endm  
# End of macro DMARK
300c						CALLMONITOR 
300c cd c1 19			call break_point_state  
300f				endm  
# End of macro CALLMONITOR
300f					endif 
300f				       NEXTW 
300f c3 39 24			jp macro_next 
3012				endm 
# End of macro NEXTW
3012			.COMO: 
3012				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
3012 6e				db WORD_SYS_CORE+90             
3013 64 30			dw .COMC            
3015 02				db 1 + 1 
3016 .. 00			db "(",0              
3018				endm 
# End of macro CWHEAD
3018			; | ( ( -- )  Start of comment | DONE 
3018			 
3018			 
3018 2a c9 f4				ld hl, ( os_tok_ptr) 
301b 11 5f 30			ld de, .closepar 
301e					 
301e					if DEBUG_FORTH_WORDS 
301e						DMARK ").." 
301e f5				push af  
301f 3a 33 30			ld a, (.dmark)  
3022 32 6e fe			ld (debug_mark),a  
3025 3a 34 30			ld a, (.dmark+1)  
3028 32 6f fe			ld (debug_mark+1),a  
302b 3a 35 30			ld a, (.dmark+2)  
302e 32 70 fe			ld (debug_mark+2),a  
3031 18 03			jr .pastdmark  
3033 ..			.dmark: db ").."  
3036 f1			.pastdmark: pop af  
3037			endm  
# End of macro DMARK
3037						CALLMONITOR 
3037 cd c1 19			call break_point_state  
303a				endm  
# End of macro CALLMONITOR
303a					endif 
303a cd 54 25			call findnexttok  
303d			 
303d					if DEBUG_FORTH_WORDS 
303d						DMARK "IF5" 
303d f5				push af  
303e 3a 52 30			ld a, (.dmark)  
3041 32 6e fe			ld (debug_mark),a  
3044 3a 53 30			ld a, (.dmark+1)  
3047 32 6f fe			ld (debug_mark+1),a  
304a 3a 54 30			ld a, (.dmark+2)  
304d 32 70 fe			ld (debug_mark+2),a  
3050 18 03			jr .pastdmark  
3052 ..			.dmark: db "IF5"  
3055 f1			.pastdmark: pop af  
3056			endm  
# End of macro DMARK
3056						CALLMONITOR 
3056 cd c1 19			call break_point_state  
3059				endm  
# End of macro CALLMONITOR
3059					endif 
3059				; replace below with ) exec using tok_ptr 
3059 22 c9 f4			ld (os_tok_ptr), hl 
305c c3 ca 24			jp exec1 
305f			 
305f .. 00			.closepar:   db ")",0 
3061			 
3061				       NEXTW 
3061 c3 39 24			jp macro_next 
3064				endm 
# End of macro NEXTW
3064			.COMC: 
3064				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
3064 6f				db WORD_SYS_CORE+91             
3065 6d 30			dw .SCRATCH            
3067 02				db 1 + 1 
3068 .. 00			db ")",0              
306a				endm 
# End of macro CWHEAD
306a			; | ) ( -- )  End of comment |  DONE  
306a				       NEXTW 
306a c3 39 24			jp macro_next 
306d				endm 
# End of macro NEXTW
306d			 
306d			.SCRATCH: 
306d				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
306d 6f				db WORD_SYS_CORE+91             
306e a8 30			dw .INC            
3070 08				db 7 + 1 
3071 .. 00			db "SCRATCH",0              
3079				endm 
# End of macro CWHEAD
3079			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3079			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3079			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3079			; | |  
3079			; | | e.g.    : score $00 scratch ; 
3079			; | |  
3079			; | | $00 score ! 
3079			; | | $01 score +! 
3079			; | |  
3079			; | | e.g.   : varword $0a scratch ;  
3079			; | | 
3079			; | | $8000 varword ! 
3079					if DEBUG_FORTH_WORDS_KEY 
3079						DMARK "SCR" 
3079 f5				push af  
307a 3a 8e 30			ld a, (.dmark)  
307d 32 6e fe			ld (debug_mark),a  
3080 3a 8f 30			ld a, (.dmark+1)  
3083 32 6f fe			ld (debug_mark+1),a  
3086 3a 90 30			ld a, (.dmark+2)  
3089 32 70 fe			ld (debug_mark+2),a  
308c 18 03			jr .pastdmark  
308e ..			.dmark: db "SCR"  
3091 f1			.pastdmark: pop af  
3092			endm  
# End of macro DMARK
3092						CALLMONITOR 
3092 cd c1 19			call break_point_state  
3095				endm  
# End of macro CALLMONITOR
3095					endif 
3095			 
3095					FORTH_DSP_VALUEHL 
3095 cd 83 22			call macro_dsp_valuehl 
3098				endm 
# End of macro FORTH_DSP_VALUEHL
3098				 
3098					FORTH_DSP_POP 
3098 cd 3b 23			call macro_forth_dsp_pop 
309b				endm 
# End of macro FORTH_DSP_POP
309b			 
309b 7d					ld a, l 
309c 21 ed f6				ld hl, os_var_array 
309f cd 4c 0f				call addatohl 
30a2			 
30a2 cd 8c 20				call forth_push_numhl 
30a5			 
30a5				       NEXTW 
30a5 c3 39 24			jp macro_next 
30a8				endm 
# End of macro NEXTW
30a8			 
30a8			.INC: 
30a8				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
30a8 6f				db WORD_SYS_CORE+91             
30a9 fc 30			dw .DEC            
30ab 03				db 2 + 1 
30ac .. 00			db "+!",0              
30af				endm 
# End of macro CWHEAD
30af			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
30af					if DEBUG_FORTH_WORDS_KEY 
30af						DMARK "+s_" 
30af f5				push af  
30b0 3a c4 30			ld a, (.dmark)  
30b3 32 6e fe			ld (debug_mark),a  
30b6 3a c5 30			ld a, (.dmark+1)  
30b9 32 6f fe			ld (debug_mark+1),a  
30bc 3a c6 30			ld a, (.dmark+2)  
30bf 32 70 fe			ld (debug_mark+2),a  
30c2 18 03			jr .pastdmark  
30c4 ..			.dmark: db "+s_"  
30c7 f1			.pastdmark: pop af  
30c8			endm  
# End of macro DMARK
30c8						CALLMONITOR 
30c8 cd c1 19			call break_point_state  
30cb				endm  
# End of macro CALLMONITOR
30cb					endif 
30cb			 
30cb					FORTH_DSP_VALUEHL 
30cb cd 83 22			call macro_dsp_valuehl 
30ce				endm 
# End of macro FORTH_DSP_VALUEHL
30ce			 
30ce e5					push hl   ; save address 
30cf			 
30cf					FORTH_DSP_POP 
30cf cd 3b 23			call macro_forth_dsp_pop 
30d2				endm 
# End of macro FORTH_DSP_POP
30d2			 
30d2					FORTH_DSP_VALUEHL 
30d2 cd 83 22			call macro_dsp_valuehl 
30d5				endm 
# End of macro FORTH_DSP_VALUEHL
30d5			 
30d5					FORTH_DSP_POP 
30d5 cd 3b 23			call macro_forth_dsp_pop 
30d8				endm 
# End of macro FORTH_DSP_POP
30d8			 
30d8					; hl contains value to add to byte at a 
30d8				 
30d8 eb					ex de, hl 
30d9			 
30d9 e1					pop hl 
30da			 
30da					if DEBUG_FORTH_WORDS 
30da						DMARK "INC" 
30da f5				push af  
30db 3a ef 30			ld a, (.dmark)  
30de 32 6e fe			ld (debug_mark),a  
30e1 3a f0 30			ld a, (.dmark+1)  
30e4 32 6f fe			ld (debug_mark+1),a  
30e7 3a f1 30			ld a, (.dmark+2)  
30ea 32 70 fe			ld (debug_mark+2),a  
30ed 18 03			jr .pastdmark  
30ef ..			.dmark: db "INC"  
30f2 f1			.pastdmark: pop af  
30f3			endm  
# End of macro DMARK
30f3						CALLMONITOR 
30f3 cd c1 19			call break_point_state  
30f6				endm  
# End of macro CALLMONITOR
30f6					endif 
30f6			 
30f6 7e					ld a,(hl) 
30f7 83					add e 
30f8 77					ld (hl),a 
30f9			 
30f9			 
30f9			 
30f9				       NEXTW 
30f9 c3 39 24			jp macro_next 
30fc				endm 
# End of macro NEXTW
30fc			 
30fc			.DEC: 
30fc				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
30fc 6f				db WORD_SYS_CORE+91             
30fd 4d 31			dw .INC2            
30ff 03				db 2 + 1 
3100 .. 00			db "-!",0              
3103				endm 
# End of macro CWHEAD
3103			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3103					if DEBUG_FORTH_WORDS_KEY 
3103						DMARK "-s_" 
3103 f5				push af  
3104 3a 18 31			ld a, (.dmark)  
3107 32 6e fe			ld (debug_mark),a  
310a 3a 19 31			ld a, (.dmark+1)  
310d 32 6f fe			ld (debug_mark+1),a  
3110 3a 1a 31			ld a, (.dmark+2)  
3113 32 70 fe			ld (debug_mark+2),a  
3116 18 03			jr .pastdmark  
3118 ..			.dmark: db "-s_"  
311b f1			.pastdmark: pop af  
311c			endm  
# End of macro DMARK
311c						CALLMONITOR 
311c cd c1 19			call break_point_state  
311f				endm  
# End of macro CALLMONITOR
311f					endif 
311f			 
311f					FORTH_DSP_VALUEHL 
311f cd 83 22			call macro_dsp_valuehl 
3122				endm 
# End of macro FORTH_DSP_VALUEHL
3122			 
3122 e5					push hl   ; save address 
3123			 
3123					FORTH_DSP_POP 
3123 cd 3b 23			call macro_forth_dsp_pop 
3126				endm 
# End of macro FORTH_DSP_POP
3126			 
3126					FORTH_DSP_VALUEHL 
3126 cd 83 22			call macro_dsp_valuehl 
3129				endm 
# End of macro FORTH_DSP_VALUEHL
3129			 
3129					; hl contains value to add to byte at a 
3129				 
3129 eb					ex de, hl 
312a			 
312a e1					pop hl 
312b			 
312b					if DEBUG_FORTH_WORDS 
312b						DMARK "DEC" 
312b f5				push af  
312c 3a 40 31			ld a, (.dmark)  
312f 32 6e fe			ld (debug_mark),a  
3132 3a 41 31			ld a, (.dmark+1)  
3135 32 6f fe			ld (debug_mark+1),a  
3138 3a 42 31			ld a, (.dmark+2)  
313b 32 70 fe			ld (debug_mark+2),a  
313e 18 03			jr .pastdmark  
3140 ..			.dmark: db "DEC"  
3143 f1			.pastdmark: pop af  
3144			endm  
# End of macro DMARK
3144						CALLMONITOR 
3144 cd c1 19			call break_point_state  
3147				endm  
# End of macro CALLMONITOR
3147					endif 
3147			 
3147 7e					ld a,(hl) 
3148 93					sub e 
3149 77					ld (hl),a 
314a			 
314a			 
314a			 
314a				       NEXTW 
314a c3 39 24			jp macro_next 
314d				endm 
# End of macro NEXTW
314d			 
314d			.INC2: 
314d				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
314d 6f				db WORD_SYS_CORE+91             
314e f7 31			dw .DEC2            
3150 04				db 3 + 1 
3151 .. 00			db "+2!",0              
3155				endm 
# End of macro CWHEAD
3155			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3155			 
3155					if DEBUG_FORTH_WORDS_KEY 
3155						DMARK "+2s" 
3155 f5				push af  
3156 3a 6a 31			ld a, (.dmark)  
3159 32 6e fe			ld (debug_mark),a  
315c 3a 6b 31			ld a, (.dmark+1)  
315f 32 6f fe			ld (debug_mark+1),a  
3162 3a 6c 31			ld a, (.dmark+2)  
3165 32 70 fe			ld (debug_mark+2),a  
3168 18 03			jr .pastdmark  
316a ..			.dmark: db "+2s"  
316d f1			.pastdmark: pop af  
316e			endm  
# End of macro DMARK
316e						CALLMONITOR 
316e cd c1 19			call break_point_state  
3171				endm  
# End of macro CALLMONITOR
3171					endif 
3171			 
3171					; Address 
3171			 
3171					FORTH_DSP_VALUEHL 
3171 cd 83 22			call macro_dsp_valuehl 
3174				endm 
# End of macro FORTH_DSP_VALUEHL
3174			 
3174 e5					push hl    ; save address 
3175			 
3175					; load content into de 
3175			 
3175 5e					ld e,(hl) 
3176 23					inc hl 
3177 56					ld d, (hl) 
3178			 
3178					if DEBUG_FORTH_WORDS 
3178						DMARK "+2a" 
3178 f5				push af  
3179 3a 8d 31			ld a, (.dmark)  
317c 32 6e fe			ld (debug_mark),a  
317f 3a 8e 31			ld a, (.dmark+1)  
3182 32 6f fe			ld (debug_mark+1),a  
3185 3a 8f 31			ld a, (.dmark+2)  
3188 32 70 fe			ld (debug_mark+2),a  
318b 18 03			jr .pastdmark  
318d ..			.dmark: db "+2a"  
3190 f1			.pastdmark: pop af  
3191			endm  
# End of macro DMARK
3191						CALLMONITOR 
3191 cd c1 19			call break_point_state  
3194				endm  
# End of macro CALLMONITOR
3194					endif 
3194			 
3194					FORTH_DSP_POP 
3194 cd 3b 23			call macro_forth_dsp_pop 
3197				endm 
# End of macro FORTH_DSP_POP
3197			 
3197					; Get value to add 
3197			 
3197					FORTH_DSP_VALUE 
3197 cd 6c 22			call macro_forth_dsp_value 
319a				endm 
# End of macro FORTH_DSP_VALUE
319a			 
319a					if DEBUG_FORTH_WORDS 
319a						DMARK "+2v" 
319a f5				push af  
319b 3a af 31			ld a, (.dmark)  
319e 32 6e fe			ld (debug_mark),a  
31a1 3a b0 31			ld a, (.dmark+1)  
31a4 32 6f fe			ld (debug_mark+1),a  
31a7 3a b1 31			ld a, (.dmark+2)  
31aa 32 70 fe			ld (debug_mark+2),a  
31ad 18 03			jr .pastdmark  
31af ..			.dmark: db "+2v"  
31b2 f1			.pastdmark: pop af  
31b3			endm  
# End of macro DMARK
31b3						CALLMONITOR 
31b3 cd c1 19			call break_point_state  
31b6				endm  
# End of macro CALLMONITOR
31b6					endif 
31b6			 
31b6 19					add hl, de 
31b7			 
31b7					if DEBUG_FORTH_WORDS 
31b7						DMARK "+2+" 
31b7 f5				push af  
31b8 3a cc 31			ld a, (.dmark)  
31bb 32 6e fe			ld (debug_mark),a  
31be 3a cd 31			ld a, (.dmark+1)  
31c1 32 6f fe			ld (debug_mark+1),a  
31c4 3a ce 31			ld a, (.dmark+2)  
31c7 32 70 fe			ld (debug_mark+2),a  
31ca 18 03			jr .pastdmark  
31cc ..			.dmark: db "+2+"  
31cf f1			.pastdmark: pop af  
31d0			endm  
# End of macro DMARK
31d0						CALLMONITOR 
31d0 cd c1 19			call break_point_state  
31d3				endm  
# End of macro CALLMONITOR
31d3					endif 
31d3			 
31d3					; move result to de 
31d3			 
31d3 eb					ex de, hl 
31d4			 
31d4					; Address 
31d4			 
31d4 e1					pop hl 
31d5			 
31d5					; save it back 
31d5			 
31d5 73					ld (hl), e 
31d6 23					inc hl 
31d7 72					ld (hl), d 
31d8			 
31d8					if DEBUG_FORTH_WORDS 
31d8						DMARK "+2e" 
31d8 f5				push af  
31d9 3a ed 31			ld a, (.dmark)  
31dc 32 6e fe			ld (debug_mark),a  
31df 3a ee 31			ld a, (.dmark+1)  
31e2 32 6f fe			ld (debug_mark+1),a  
31e5 3a ef 31			ld a, (.dmark+2)  
31e8 32 70 fe			ld (debug_mark+2),a  
31eb 18 03			jr .pastdmark  
31ed ..			.dmark: db "+2e"  
31f0 f1			.pastdmark: pop af  
31f1			endm  
# End of macro DMARK
31f1						CALLMONITOR 
31f1 cd c1 19			call break_point_state  
31f4				endm  
# End of macro CALLMONITOR
31f4					endif 
31f4			 
31f4			 
31f4			 
31f4			 
31f4			 
31f4				       NEXTW 
31f4 c3 39 24			jp macro_next 
31f7				endm 
# End of macro NEXTW
31f7			 
31f7			.DEC2: 
31f7				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
31f7 6f				db WORD_SYS_CORE+91             
31f8 a3 32			dw .GET2            
31fa 04				db 3 + 1 
31fb .. 00			db "-2!",0              
31ff				endm 
# End of macro CWHEAD
31ff			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
31ff			 
31ff			 
31ff					if DEBUG_FORTH_WORDS_KEY 
31ff						DMARK "-2s" 
31ff f5				push af  
3200 3a 14 32			ld a, (.dmark)  
3203 32 6e fe			ld (debug_mark),a  
3206 3a 15 32			ld a, (.dmark+1)  
3209 32 6f fe			ld (debug_mark+1),a  
320c 3a 16 32			ld a, (.dmark+2)  
320f 32 70 fe			ld (debug_mark+2),a  
3212 18 03			jr .pastdmark  
3214 ..			.dmark: db "-2s"  
3217 f1			.pastdmark: pop af  
3218			endm  
# End of macro DMARK
3218						CALLMONITOR 
3218 cd c1 19			call break_point_state  
321b				endm  
# End of macro CALLMONITOR
321b					endif 
321b			 
321b					; Address 
321b			 
321b					FORTH_DSP_VALUEHL 
321b cd 83 22			call macro_dsp_valuehl 
321e				endm 
# End of macro FORTH_DSP_VALUEHL
321e			 
321e e5					push hl    ; save address 
321f			 
321f					; load content into de 
321f			 
321f 5e					ld e,(hl) 
3220 23					inc hl 
3221 56					ld d, (hl) 
3222			 
3222					if DEBUG_FORTH_WORDS 
3222						DMARK "-2a" 
3222 f5				push af  
3223 3a 37 32			ld a, (.dmark)  
3226 32 6e fe			ld (debug_mark),a  
3229 3a 38 32			ld a, (.dmark+1)  
322c 32 6f fe			ld (debug_mark+1),a  
322f 3a 39 32			ld a, (.dmark+2)  
3232 32 70 fe			ld (debug_mark+2),a  
3235 18 03			jr .pastdmark  
3237 ..			.dmark: db "-2a"  
323a f1			.pastdmark: pop af  
323b			endm  
# End of macro DMARK
323b						CALLMONITOR 
323b cd c1 19			call break_point_state  
323e				endm  
# End of macro CALLMONITOR
323e					endif 
323e			 
323e					FORTH_DSP_POP 
323e cd 3b 23			call macro_forth_dsp_pop 
3241				endm 
# End of macro FORTH_DSP_POP
3241			 
3241					; Get value to remove 
3241			 
3241					FORTH_DSP_VALUE 
3241 cd 6c 22			call macro_forth_dsp_value 
3244				endm 
# End of macro FORTH_DSP_VALUE
3244			 
3244					if DEBUG_FORTH_WORDS 
3244						DMARK "-2v" 
3244 f5				push af  
3245 3a 59 32			ld a, (.dmark)  
3248 32 6e fe			ld (debug_mark),a  
324b 3a 5a 32			ld a, (.dmark+1)  
324e 32 6f fe			ld (debug_mark+1),a  
3251 3a 5b 32			ld a, (.dmark+2)  
3254 32 70 fe			ld (debug_mark+2),a  
3257 18 03			jr .pastdmark  
3259 ..			.dmark: db "-2v"  
325c f1			.pastdmark: pop af  
325d			endm  
# End of macro DMARK
325d						CALLMONITOR 
325d cd c1 19			call break_point_state  
3260				endm  
# End of macro CALLMONITOR
3260					endif 
3260			 
3260 eb					ex de, hl 
3261 ed 52				sbc hl, de 
3263			 
3263					if DEBUG_FORTH_WORDS 
3263						DMARK "-2d" 
3263 f5				push af  
3264 3a 78 32			ld a, (.dmark)  
3267 32 6e fe			ld (debug_mark),a  
326a 3a 79 32			ld a, (.dmark+1)  
326d 32 6f fe			ld (debug_mark+1),a  
3270 3a 7a 32			ld a, (.dmark+2)  
3273 32 70 fe			ld (debug_mark+2),a  
3276 18 03			jr .pastdmark  
3278 ..			.dmark: db "-2d"  
327b f1			.pastdmark: pop af  
327c			endm  
# End of macro DMARK
327c						CALLMONITOR 
327c cd c1 19			call break_point_state  
327f				endm  
# End of macro CALLMONITOR
327f					endif 
327f			 
327f					; move result to de 
327f			 
327f eb					ex de, hl 
3280			 
3280					; Address 
3280			 
3280 e1					pop hl 
3281			 
3281					; save it back 
3281			 
3281 73					ld (hl), e 
3282 23					inc hl 
3283 72					ld (hl), d 
3284			 
3284					if DEBUG_FORTH_WORDS 
3284						DMARK "-2e" 
3284 f5				push af  
3285 3a 99 32			ld a, (.dmark)  
3288 32 6e fe			ld (debug_mark),a  
328b 3a 9a 32			ld a, (.dmark+1)  
328e 32 6f fe			ld (debug_mark+1),a  
3291 3a 9b 32			ld a, (.dmark+2)  
3294 32 70 fe			ld (debug_mark+2),a  
3297 18 03			jr .pastdmark  
3299 ..			.dmark: db "-2e"  
329c f1			.pastdmark: pop af  
329d			endm  
# End of macro DMARK
329d						CALLMONITOR 
329d cd c1 19			call break_point_state  
32a0				endm  
# End of macro CALLMONITOR
32a0					endif 
32a0			 
32a0			 
32a0			 
32a0			 
32a0			 
32a0				       NEXTW 
32a0 c3 39 24			jp macro_next 
32a3				endm 
# End of macro NEXTW
32a3			.GET2: 
32a3				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
32a3 6f				db WORD_SYS_CORE+91             
32a4 d3 32			dw .BANG2            
32a6 03				db 2 + 1 
32a7 .. 00			db "2@",0              
32aa				endm 
# End of macro CWHEAD
32aa			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
32aa					if DEBUG_FORTH_WORDS_KEY 
32aa						DMARK "2A_" 
32aa f5				push af  
32ab 3a bf 32			ld a, (.dmark)  
32ae 32 6e fe			ld (debug_mark),a  
32b1 3a c0 32			ld a, (.dmark+1)  
32b4 32 6f fe			ld (debug_mark+1),a  
32b7 3a c1 32			ld a, (.dmark+2)  
32ba 32 70 fe			ld (debug_mark+2),a  
32bd 18 03			jr .pastdmark  
32bf ..			.dmark: db "2A_"  
32c2 f1			.pastdmark: pop af  
32c3			endm  
# End of macro DMARK
32c3						CALLMONITOR 
32c3 cd c1 19			call break_point_state  
32c6				endm  
# End of macro CALLMONITOR
32c6					endif 
32c6			 
32c6					FORTH_DSP_VALUEHL 
32c6 cd 83 22			call macro_dsp_valuehl 
32c9				endm 
# End of macro FORTH_DSP_VALUEHL
32c9			 
32c9 5e					ld e, (hl) 
32ca 23					inc hl 
32cb 56					ld d, (hl) 
32cc			 
32cc eb					ex de, hl 
32cd			 
32cd cd 8c 20				call forth_push_numhl 
32d0			 
32d0				       NEXTW 
32d0 c3 39 24			jp macro_next 
32d3				endm 
# End of macro NEXTW
32d3			.BANG2: 
32d3				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
32d3 6f				db WORD_SYS_CORE+91             
32d4 0b 33			dw .CONFIG            
32d6 03				db 2 + 1 
32d7 .. 00			db "2!",0              
32da				endm 
# End of macro CWHEAD
32da			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
32da					if DEBUG_FORTH_WORDS_KEY 
32da						DMARK "2S_" 
32da f5				push af  
32db 3a ef 32			ld a, (.dmark)  
32de 32 6e fe			ld (debug_mark),a  
32e1 3a f0 32			ld a, (.dmark+1)  
32e4 32 6f fe			ld (debug_mark+1),a  
32e7 3a f1 32			ld a, (.dmark+2)  
32ea 32 70 fe			ld (debug_mark+2),a  
32ed 18 03			jr .pastdmark  
32ef ..			.dmark: db "2S_"  
32f2 f1			.pastdmark: pop af  
32f3			endm  
# End of macro DMARK
32f3						CALLMONITOR 
32f3 cd c1 19			call break_point_state  
32f6				endm  
# End of macro CALLMONITOR
32f6					endif 
32f6			 
32f6					FORTH_DSP_VALUEHL 
32f6 cd 83 22			call macro_dsp_valuehl 
32f9				endm 
# End of macro FORTH_DSP_VALUEHL
32f9			 
32f9 e5					push hl   ; save address 
32fa			 
32fa			 
32fa					FORTH_DSP_POP 
32fa cd 3b 23			call macro_forth_dsp_pop 
32fd				endm 
# End of macro FORTH_DSP_POP
32fd			 
32fd					 
32fd					FORTH_DSP_VALUEHL 
32fd cd 83 22			call macro_dsp_valuehl 
3300				endm 
# End of macro FORTH_DSP_VALUEHL
3300			 
3300					FORTH_DSP_POP 
3300 cd 3b 23			call macro_forth_dsp_pop 
3303				endm 
# End of macro FORTH_DSP_POP
3303			 
3303 eb					ex de, hl    ; value now in de 
3304			 
3304 e1					pop hl 
3305			 
3305 73					ld (hl), e 
3306			 
3306 23					inc hl 
3307			 
3307 72					ld (hl), d 
3308			 
3308			 
3308				       NEXTW 
3308 c3 39 24			jp macro_next 
330b				endm 
# End of macro NEXTW
330b			.CONFIG: 
330b				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
330b 6f				db WORD_SYS_CORE+91             
330c 1c 33			dw .ENDCORE            
330e 07				db 6 + 1 
330f .. 00			db "CONFIG",0              
3316				endm 
# End of macro CWHEAD
3316			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3316			 
3316 cd d6 15				call config 
3319					NEXTW 
3319 c3 39 24			jp macro_next 
331c				endm 
# End of macro NEXTW
331c			.ENDCORE: 
331c			 
331c			; eof 
331c			 
331c			 
# End of file forth_words_core.asm
331c			include "forth_words_flow.asm" 
331c			 
331c			; | ## Program Flow Words 
331c			 
331c			.IF: 
331c				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
331c 1e				db WORD_SYS_CORE+10             
331d 11 34			dw .THEN            
331f 03				db 2 + 1 
3320 .. 00			db "IF",0              
3323				endm 
# End of macro CWHEAD
3323			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3323			; 
3323					if DEBUG_FORTH_WORDS_KEY 
3323						DMARK "IF." 
3323 f5				push af  
3324 3a 38 33			ld a, (.dmark)  
3327 32 6e fe			ld (debug_mark),a  
332a 3a 39 33			ld a, (.dmark+1)  
332d 32 6f fe			ld (debug_mark+1),a  
3330 3a 3a 33			ld a, (.dmark+2)  
3333 32 70 fe			ld (debug_mark+2),a  
3336 18 03			jr .pastdmark  
3338 ..			.dmark: db "IF."  
333b f1			.pastdmark: pop af  
333c			endm  
# End of macro DMARK
333c						CALLMONITOR 
333c cd c1 19			call break_point_state  
333f				endm  
# End of macro CALLMONITOR
333f					endif 
333f			; eval TOS 
333f			 
333f				FORTH_DSP_VALUEHL 
333f cd 83 22			call macro_dsp_valuehl 
3342				endm 
# End of macro FORTH_DSP_VALUEHL
3342			 
3342			;	push hl 
3342				FORTH_DSP_POP 
3342 cd 3b 23			call macro_forth_dsp_pop 
3345				endm 
# End of macro FORTH_DSP_POP
3345			;	pop hl 
3345			 
3345					if DEBUG_FORTH_WORDS 
3345						DMARK "IF1" 
3345 f5				push af  
3346 3a 5a 33			ld a, (.dmark)  
3349 32 6e fe			ld (debug_mark),a  
334c 3a 5b 33			ld a, (.dmark+1)  
334f 32 6f fe			ld (debug_mark+1),a  
3352 3a 5c 33			ld a, (.dmark+2)  
3355 32 70 fe			ld (debug_mark+2),a  
3358 18 03			jr .pastdmark  
335a ..			.dmark: db "IF1"  
335d f1			.pastdmark: pop af  
335e			endm  
# End of macro DMARK
335e						CALLMONITOR 
335e cd c1 19			call break_point_state  
3361				endm  
# End of macro CALLMONITOR
3361					endif 
3361 b7				or a        ; clear carry flag 
3362 11 00 00			ld de, 0 
3365 eb				ex de,hl 
3366 ed 52			sbc hl, de 
3368 c2 f2 33			jp nz, .iftrue 
336b			 
336b					if DEBUG_FORTH_WORDS 
336b						DMARK "IF2" 
336b f5				push af  
336c 3a 80 33			ld a, (.dmark)  
336f 32 6e fe			ld (debug_mark),a  
3372 3a 81 33			ld a, (.dmark+1)  
3375 32 6f fe			ld (debug_mark+1),a  
3378 3a 82 33			ld a, (.dmark+2)  
337b 32 70 fe			ld (debug_mark+2),a  
337e 18 03			jr .pastdmark  
3380 ..			.dmark: db "IF2"  
3383 f1			.pastdmark: pop af  
3384			endm  
# End of macro DMARK
3384						CALLMONITOR 
3384 cd c1 19			call break_point_state  
3387				endm  
# End of macro CALLMONITOR
3387					endif 
3387			 
3387			; if not true then skip to THEN 
3387			 
3387				; TODO get tok_ptr 
3387				; TODO consume toks until we get to THEN 
3387			 
3387 2a c9 f4			ld hl, (os_tok_ptr) 
338a					if DEBUG_FORTH_WORDS 
338a						DMARK "IF3" 
338a f5				push af  
338b 3a 9f 33			ld a, (.dmark)  
338e 32 6e fe			ld (debug_mark),a  
3391 3a a0 33			ld a, (.dmark+1)  
3394 32 6f fe			ld (debug_mark+1),a  
3397 3a a1 33			ld a, (.dmark+2)  
339a 32 70 fe			ld (debug_mark+2),a  
339d 18 03			jr .pastdmark  
339f ..			.dmark: db "IF3"  
33a2 f1			.pastdmark: pop af  
33a3			endm  
# End of macro DMARK
33a3						CALLMONITOR 
33a3 cd c1 19			call break_point_state  
33a6				endm  
# End of macro CALLMONITOR
33a6						 
33a6					endif 
33a6 11 ed 33			ld de, .ifthen 
33a9					if DEBUG_FORTH_WORDS 
33a9						DMARK "IF4" 
33a9 f5				push af  
33aa 3a be 33			ld a, (.dmark)  
33ad 32 6e fe			ld (debug_mark),a  
33b0 3a bf 33			ld a, (.dmark+1)  
33b3 32 6f fe			ld (debug_mark+1),a  
33b6 3a c0 33			ld a, (.dmark+2)  
33b9 32 70 fe			ld (debug_mark+2),a  
33bc 18 03			jr .pastdmark  
33be ..			.dmark: db "IF4"  
33c1 f1			.pastdmark: pop af  
33c2			endm  
# End of macro DMARK
33c2						CALLMONITOR 
33c2 cd c1 19			call break_point_state  
33c5				endm  
# End of macro CALLMONITOR
33c5					endif 
33c5 cd 54 25			call findnexttok  
33c8			 
33c8					if DEBUG_FORTH_WORDS 
33c8						DMARK "IF5" 
33c8 f5				push af  
33c9 3a dd 33			ld a, (.dmark)  
33cc 32 6e fe			ld (debug_mark),a  
33cf 3a de 33			ld a, (.dmark+1)  
33d2 32 6f fe			ld (debug_mark+1),a  
33d5 3a df 33			ld a, (.dmark+2)  
33d8 32 70 fe			ld (debug_mark+2),a  
33db 18 03			jr .pastdmark  
33dd ..			.dmark: db "IF5"  
33e0 f1			.pastdmark: pop af  
33e1			endm  
# End of macro DMARK
33e1						CALLMONITOR 
33e1 cd c1 19			call break_point_state  
33e4				endm  
# End of macro CALLMONITOR
33e4					endif 
33e4				; TODO replace below with ; exec using tok_ptr 
33e4 22 c9 f4			ld (os_tok_ptr), hl 
33e7 c3 ca 24			jp exec1 
33ea				NEXTW 
33ea c3 39 24			jp macro_next 
33ed				endm 
# End of macro NEXTW
33ed			 
33ed .. 00		.ifthen:  db "THEN",0 
33f2			 
33f2			.iftrue:		 
33f2				; Exec next words normally 
33f2			 
33f2				; if true then exec following IF as normal 
33f2					if DEBUG_FORTH_WORDS 
33f2						DMARK "IFT" 
33f2 f5				push af  
33f3 3a 07 34			ld a, (.dmark)  
33f6 32 6e fe			ld (debug_mark),a  
33f9 3a 08 34			ld a, (.dmark+1)  
33fc 32 6f fe			ld (debug_mark+1),a  
33ff 3a 09 34			ld a, (.dmark+2)  
3402 32 70 fe			ld (debug_mark+2),a  
3405 18 03			jr .pastdmark  
3407 ..			.dmark: db "IFT"  
340a f1			.pastdmark: pop af  
340b			endm  
# End of macro DMARK
340b						CALLMONITOR 
340b cd c1 19			call break_point_state  
340e				endm  
# End of macro CALLMONITOR
340e					endif 
340e			 
340e					NEXTW 
340e c3 39 24			jp macro_next 
3411				endm 
# End of macro NEXTW
3411			.THEN: 
3411				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3411 1f				db WORD_SYS_CORE+11             
3412 39 34			dw .ELSE            
3414 05				db 4 + 1 
3415 .. 00			db "THEN",0              
341a				endm 
# End of macro CWHEAD
341a			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
341a					if DEBUG_FORTH_WORDS_KEY 
341a						DMARK "THN" 
341a f5				push af  
341b 3a 2f 34			ld a, (.dmark)  
341e 32 6e fe			ld (debug_mark),a  
3421 3a 30 34			ld a, (.dmark+1)  
3424 32 6f fe			ld (debug_mark+1),a  
3427 3a 31 34			ld a, (.dmark+2)  
342a 32 70 fe			ld (debug_mark+2),a  
342d 18 03			jr .pastdmark  
342f ..			.dmark: db "THN"  
3432 f1			.pastdmark: pop af  
3433			endm  
# End of macro DMARK
3433						CALLMONITOR 
3433 cd c1 19			call break_point_state  
3436				endm  
# End of macro CALLMONITOR
3436					endif 
3436					NEXTW 
3436 c3 39 24			jp macro_next 
3439				endm 
# End of macro NEXTW
3439			.ELSE: 
3439				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3439 20				db WORD_SYS_CORE+12             
343a 61 34			dw .DO            
343c 03				db 2 + 1 
343d .. 00			db "ELSE",0              
3442				endm 
# End of macro CWHEAD
3442			; | ELSE ( -- ) Not supported - does nothing | TODO 
3442			 
3442					if DEBUG_FORTH_WORDS_KEY 
3442						DMARK "ELS" 
3442 f5				push af  
3443 3a 57 34			ld a, (.dmark)  
3446 32 6e fe			ld (debug_mark),a  
3449 3a 58 34			ld a, (.dmark+1)  
344c 32 6f fe			ld (debug_mark+1),a  
344f 3a 59 34			ld a, (.dmark+2)  
3452 32 70 fe			ld (debug_mark+2),a  
3455 18 03			jr .pastdmark  
3457 ..			.dmark: db "ELS"  
345a f1			.pastdmark: pop af  
345b			endm  
# End of macro DMARK
345b						CALLMONITOR 
345b cd c1 19			call break_point_state  
345e				endm  
# End of macro CALLMONITOR
345e					endif 
345e			 
345e			 
345e					NEXTW 
345e c3 39 24			jp macro_next 
3461				endm 
# End of macro NEXTW
3461			.DO: 
3461				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3461 21				db WORD_SYS_CORE+13             
3462 88 35			dw .LOOP            
3464 03				db 2 + 1 
3465 .. 00			db "DO",0              
3468				endm 
# End of macro CWHEAD
3468			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3468			 
3468					if DEBUG_FORTH_WORDS_KEY 
3468						DMARK "DO." 
3468 f5				push af  
3469 3a 7d 34			ld a, (.dmark)  
346c 32 6e fe			ld (debug_mark),a  
346f 3a 7e 34			ld a, (.dmark+1)  
3472 32 6f fe			ld (debug_mark+1),a  
3475 3a 7f 34			ld a, (.dmark+2)  
3478 32 70 fe			ld (debug_mark+2),a  
347b 18 03			jr .pastdmark  
347d ..			.dmark: db "DO."  
3480 f1			.pastdmark: pop af  
3481			endm  
# End of macro DMARK
3481						CALLMONITOR 
3481 cd c1 19			call break_point_state  
3484				endm  
# End of macro CALLMONITOR
3484					endif 
3484			;  push pc to rsp stack past the DO 
3484			 
3484 2a c9 f4				ld hl, (os_tok_ptr) 
3487 23					inc hl   ; D 
3488 23					inc hl  ; O 
3489 23					inc hl   ; null 
348a					if DEBUG_FORTH_WORDS 
348a						DMARK "DO2" 
348a f5				push af  
348b 3a 9f 34			ld a, (.dmark)  
348e 32 6e fe			ld (debug_mark),a  
3491 3a a0 34			ld a, (.dmark+1)  
3494 32 6f fe			ld (debug_mark+1),a  
3497 3a a1 34			ld a, (.dmark+2)  
349a 32 70 fe			ld (debug_mark+2),a  
349d 18 03			jr .pastdmark  
349f ..			.dmark: db "DO2"  
34a2 f1			.pastdmark: pop af  
34a3			endm  
# End of macro DMARK
34a3						CALLMONITOR 
34a3 cd c1 19			call break_point_state  
34a6				endm  
# End of macro CALLMONITOR
34a6					endif 
34a6					FORTH_RSP_NEXT 
34a6 cd 33 20			call macro_forth_rsp_next 
34a9				endm 
# End of macro FORTH_RSP_NEXT
34a9					if DEBUG_FORTH_WORDS 
34a9						DMARK "DO3" 
34a9 f5				push af  
34aa 3a be 34			ld a, (.dmark)  
34ad 32 6e fe			ld (debug_mark),a  
34b0 3a bf 34			ld a, (.dmark+1)  
34b3 32 6f fe			ld (debug_mark+1),a  
34b6 3a c0 34			ld a, (.dmark+2)  
34b9 32 70 fe			ld (debug_mark+2),a  
34bc 18 03			jr .pastdmark  
34be ..			.dmark: db "DO3"  
34c1 f1			.pastdmark: pop af  
34c2			endm  
# End of macro DMARK
34c2						CALLMONITOR 
34c2 cd c1 19			call break_point_state  
34c5				endm  
# End of macro CALLMONITOR
34c5					endif 
34c5			 
34c5					;if DEBUG_FORTH_WORDS 
34c5				;		push hl 
34c5			;		endif  
34c5			 
34c5			; get counters from data stack 
34c5			 
34c5			 
34c5					FORTH_DSP_VALUEHL 
34c5 cd 83 22			call macro_dsp_valuehl 
34c8				endm 
# End of macro FORTH_DSP_VALUEHL
34c8 e5					push hl		 ; hl now has starting counter which needs to be tos 
34c9			 
34c9					if DEBUG_FORTH_WORDS 
34c9						DMARK "DO4" 
34c9 f5				push af  
34ca 3a de 34			ld a, (.dmark)  
34cd 32 6e fe			ld (debug_mark),a  
34d0 3a df 34			ld a, (.dmark+1)  
34d3 32 6f fe			ld (debug_mark+1),a  
34d6 3a e0 34			ld a, (.dmark+2)  
34d9 32 70 fe			ld (debug_mark+2),a  
34dc 18 03			jr .pastdmark  
34de ..			.dmark: db "DO4"  
34e1 f1			.pastdmark: pop af  
34e2			endm  
# End of macro DMARK
34e2						CALLMONITOR 
34e2 cd c1 19			call break_point_state  
34e5				endm  
# End of macro CALLMONITOR
34e5					endif 
34e5					FORTH_DSP_POP 
34e5 cd 3b 23			call macro_forth_dsp_pop 
34e8				endm 
# End of macro FORTH_DSP_POP
34e8			 
34e8					if DEBUG_FORTH_WORDS 
34e8						DMARK "DO5" 
34e8 f5				push af  
34e9 3a fd 34			ld a, (.dmark)  
34ec 32 6e fe			ld (debug_mark),a  
34ef 3a fe 34			ld a, (.dmark+1)  
34f2 32 6f fe			ld (debug_mark+1),a  
34f5 3a ff 34			ld a, (.dmark+2)  
34f8 32 70 fe			ld (debug_mark+2),a  
34fb 18 03			jr .pastdmark  
34fd ..			.dmark: db "DO5"  
3500 f1			.pastdmark: pop af  
3501			endm  
# End of macro DMARK
3501						CALLMONITOR 
3501 cd c1 19			call break_point_state  
3504				endm  
# End of macro CALLMONITOR
3504					endif 
3504			 
3504					FORTH_DSP_VALUEHL 
3504 cd 83 22			call macro_dsp_valuehl 
3507				endm 
# End of macro FORTH_DSP_VALUEHL
3507			;		push hl		 ; hl now has starting limit counter 
3507			 
3507					if DEBUG_FORTH_WORDS 
3507						DMARK "DO6" 
3507 f5				push af  
3508 3a 1c 35			ld a, (.dmark)  
350b 32 6e fe			ld (debug_mark),a  
350e 3a 1d 35			ld a, (.dmark+1)  
3511 32 6f fe			ld (debug_mark+1),a  
3514 3a 1e 35			ld a, (.dmark+2)  
3517 32 70 fe			ld (debug_mark+2),a  
351a 18 03			jr .pastdmark  
351c ..			.dmark: db "DO6"  
351f f1			.pastdmark: pop af  
3520			endm  
# End of macro DMARK
3520						CALLMONITOR 
3520 cd c1 19			call break_point_state  
3523				endm  
# End of macro CALLMONITOR
3523					endif 
3523					FORTH_DSP_POP 
3523 cd 3b 23			call macro_forth_dsp_pop 
3526				endm 
# End of macro FORTH_DSP_POP
3526			 
3526			; put counters on the loop stack 
3526			 
3526			;		pop hl			 ; limit counter 
3526 d1					pop de			; start counter 
3527			 
3527					; push limit counter 
3527			 
3527					if DEBUG_FORTH_WORDS 
3527						DMARK "DO7" 
3527 f5				push af  
3528 3a 3c 35			ld a, (.dmark)  
352b 32 6e fe			ld (debug_mark),a  
352e 3a 3d 35			ld a, (.dmark+1)  
3531 32 6f fe			ld (debug_mark+1),a  
3534 3a 3e 35			ld a, (.dmark+2)  
3537 32 70 fe			ld (debug_mark+2),a  
353a 18 03			jr .pastdmark  
353c ..			.dmark: db "DO7"  
353f f1			.pastdmark: pop af  
3540			endm  
# End of macro DMARK
3540						CALLMONITOR 
3540 cd c1 19			call break_point_state  
3543				endm  
# End of macro CALLMONITOR
3543					endif 
3543					FORTH_LOOP_NEXT 
3543 cd b4 22			call macro_forth_loop_next 
3546				endm 
# End of macro FORTH_LOOP_NEXT
3546			 
3546					; push start counter 
3546			 
3546 eb					ex de, hl 
3547					if DEBUG_FORTH_WORDS 
3547						DMARK "DO7" 
3547 f5				push af  
3548 3a 5c 35			ld a, (.dmark)  
354b 32 6e fe			ld (debug_mark),a  
354e 3a 5d 35			ld a, (.dmark+1)  
3551 32 6f fe			ld (debug_mark+1),a  
3554 3a 5e 35			ld a, (.dmark+2)  
3557 32 70 fe			ld (debug_mark+2),a  
355a 18 03			jr .pastdmark  
355c ..			.dmark: db "DO7"  
355f f1			.pastdmark: pop af  
3560			endm  
# End of macro DMARK
3560						CALLMONITOR 
3560 cd c1 19			call break_point_state  
3563				endm  
# End of macro CALLMONITOR
3563					endif 
3563					FORTH_LOOP_NEXT 
3563 cd b4 22			call macro_forth_loop_next 
3566				endm 
# End of macro FORTH_LOOP_NEXT
3566			 
3566			 
3566					; init first round of I counter 
3566			 
3566 22 ed f4				ld (os_current_i), hl 
3569			 
3569					if DEBUG_FORTH_WORDS 
3569						DMARK "DO8" 
3569 f5				push af  
356a 3a 7e 35			ld a, (.dmark)  
356d 32 6e fe			ld (debug_mark),a  
3570 3a 7f 35			ld a, (.dmark+1)  
3573 32 6f fe			ld (debug_mark+1),a  
3576 3a 80 35			ld a, (.dmark+2)  
3579 32 70 fe			ld (debug_mark+2),a  
357c 18 03			jr .pastdmark  
357e ..			.dmark: db "DO8"  
3581 f1			.pastdmark: pop af  
3582			endm  
# End of macro DMARK
3582						CALLMONITOR 
3582 cd c1 19			call break_point_state  
3585				endm  
# End of macro CALLMONITOR
3585					endif 
3585			 
3585					NEXTW 
3585 c3 39 24			jp macro_next 
3588				endm 
# End of macro NEXTW
3588			.LOOP: 
3588				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3588 22				db WORD_SYS_CORE+14             
3589 a0 36			dw .I            
358b 05				db 4 + 1 
358c .. 00			db "LOOP",0              
3591				endm 
# End of macro CWHEAD
3591			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3591			 
3591				; pop tos as current loop count to hl 
3591			 
3591				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3591			 
3591				FORTH_LOOP_TOS 
3591 cd e7 22			call macro_forth_loop_tos 
3594				endm 
# End of macro FORTH_LOOP_TOS
3594 e5				push hl 
3595			 
3595					if DEBUG_FORTH_WORDS_KEY 
3595						DMARK "LOP" 
3595 f5				push af  
3596 3a aa 35			ld a, (.dmark)  
3599 32 6e fe			ld (debug_mark),a  
359c 3a ab 35			ld a, (.dmark+1)  
359f 32 6f fe			ld (debug_mark+1),a  
35a2 3a ac 35			ld a, (.dmark+2)  
35a5 32 70 fe			ld (debug_mark+2),a  
35a8 18 03			jr .pastdmark  
35aa ..			.dmark: db "LOP"  
35ad f1			.pastdmark: pop af  
35ae			endm  
# End of macro DMARK
35ae						CALLMONITOR 
35ae cd c1 19			call break_point_state  
35b1				endm  
# End of macro CALLMONITOR
35b1					endif 
35b1				; next item on the stack is the limit. get it 
35b1			 
35b1			 
35b1				FORTH_LOOP_POP 
35b1 cd f1 22			call macro_forth_loop_pop 
35b4				endm 
# End of macro FORTH_LOOP_POP
35b4			 
35b4				FORTH_LOOP_TOS 
35b4 cd e7 22			call macro_forth_loop_tos 
35b7				endm 
# End of macro FORTH_LOOP_TOS
35b7			 
35b7 d1				pop de		 ; de = i, hl = limit 
35b8			 
35b8					if DEBUG_FORTH_WORDS 
35b8						DMARK "LP1" 
35b8 f5				push af  
35b9 3a cd 35			ld a, (.dmark)  
35bc 32 6e fe			ld (debug_mark),a  
35bf 3a ce 35			ld a, (.dmark+1)  
35c2 32 6f fe			ld (debug_mark+1),a  
35c5 3a cf 35			ld a, (.dmark+2)  
35c8 32 70 fe			ld (debug_mark+2),a  
35cb 18 03			jr .pastdmark  
35cd ..			.dmark: db "LP1"  
35d0 f1			.pastdmark: pop af  
35d1			endm  
# End of macro DMARK
35d1						CALLMONITOR 
35d1 cd c1 19			call break_point_state  
35d4				endm  
# End of macro CALLMONITOR
35d4					endif 
35d4			 
35d4				; go back to previous word 
35d4			 
35d4 d5				push de    ; save I for inc later 
35d5			 
35d5			 
35d5				; get limit 
35d5				;  is I at limit? 
35d5			 
35d5			 
35d5					if DEBUG_FORTH_WORDS 
35d5						DMARK "LP1" 
35d5 f5				push af  
35d6 3a ea 35			ld a, (.dmark)  
35d9 32 6e fe			ld (debug_mark),a  
35dc 3a eb 35			ld a, (.dmark+1)  
35df 32 6f fe			ld (debug_mark+1),a  
35e2 3a ec 35			ld a, (.dmark+2)  
35e5 32 70 fe			ld (debug_mark+2),a  
35e8 18 03			jr .pastdmark  
35ea ..			.dmark: db "LP1"  
35ed f1			.pastdmark: pop af  
35ee			endm  
# End of macro DMARK
35ee						CALLMONITOR 
35ee cd c1 19			call break_point_state  
35f1				endm  
# End of macro CALLMONITOR
35f1					endif 
35f1			 
35f1 ed 52			sbc hl, de 
35f3			 
35f3			 
35f3				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35f3			 
35f3 20 26				jr nz, .loopnotdone 
35f5			 
35f5 e1				pop hl   ; get rid of saved I 
35f6				FORTH_LOOP_POP     ; get rid of limit 
35f6 cd f1 22			call macro_forth_loop_pop 
35f9				endm 
# End of macro FORTH_LOOP_POP
35f9			 
35f9				FORTH_RSP_POP     ; get rid of DO ptr 
35f9 cd 54 20			call macro_forth_rsp_pop 
35fc				endm 
# End of macro FORTH_RSP_POP
35fc			 
35fc			if DEBUG_FORTH_WORDS 
35fc						DMARK "LP>" 
35fc f5				push af  
35fd 3a 11 36			ld a, (.dmark)  
3600 32 6e fe			ld (debug_mark),a  
3603 3a 12 36			ld a, (.dmark+1)  
3606 32 6f fe			ld (debug_mark+1),a  
3609 3a 13 36			ld a, (.dmark+2)  
360c 32 70 fe			ld (debug_mark+2),a  
360f 18 03			jr .pastdmark  
3611 ..			.dmark: db "LP>"  
3614 f1			.pastdmark: pop af  
3615			endm  
# End of macro DMARK
3615				CALLMONITOR 
3615 cd c1 19			call break_point_state  
3618				endm  
# End of macro CALLMONITOR
3618			endif 
3618			 
3618					NEXTW 
3618 c3 39 24			jp macro_next 
361b				endm 
# End of macro NEXTW
361b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
361b			 
361b			.loopnotdone: 
361b			 
361b e1				pop hl    ; get I 
361c 23				inc hl 
361d			 
361d			   	; save new I 
361d			 
361d			 
361d					; set I counter 
361d			 
361d 22 ed f4				ld (os_current_i), hl 
3620			 
3620					if DEBUG_FORTH_WORDS 
3620						DMARK "LPN" 
3620 f5				push af  
3621 3a 35 36			ld a, (.dmark)  
3624 32 6e fe			ld (debug_mark),a  
3627 3a 36 36			ld a, (.dmark+1)  
362a 32 6f fe			ld (debug_mark+1),a  
362d 3a 37 36			ld a, (.dmark+2)  
3630 32 70 fe			ld (debug_mark+2),a  
3633 18 03			jr .pastdmark  
3635 ..			.dmark: db "LPN"  
3638 f1			.pastdmark: pop af  
3639			endm  
# End of macro DMARK
3639					CALLMONITOR 
3639 cd c1 19			call break_point_state  
363c				endm  
# End of macro CALLMONITOR
363c					endif 
363c					 
363c				FORTH_LOOP_NEXT 
363c cd b4 22			call macro_forth_loop_next 
363f				endm 
# End of macro FORTH_LOOP_NEXT
363f			 
363f			 
363f					if DEBUG_FORTH_WORDS 
363f eb						ex de,hl 
3640					endif 
3640			 
3640			;	; get DO ptr 
3640			; 
3640					if DEBUG_FORTH_WORDS 
3640						DMARK "LP7" 
3640 f5				push af  
3641 3a 55 36			ld a, (.dmark)  
3644 32 6e fe			ld (debug_mark),a  
3647 3a 56 36			ld a, (.dmark+1)  
364a 32 6f fe			ld (debug_mark+1),a  
364d 3a 57 36			ld a, (.dmark+2)  
3650 32 70 fe			ld (debug_mark+2),a  
3653 18 03			jr .pastdmark  
3655 ..			.dmark: db "LP7"  
3658 f1			.pastdmark: pop af  
3659			endm  
# End of macro DMARK
3659					CALLMONITOR 
3659 cd c1 19			call break_point_state  
365c				endm  
# End of macro CALLMONITOR
365c					endif 
365c				FORTH_RSP_TOS 
365c cd 4a 20			call macro_forth_rsp_tos 
365f				endm 
# End of macro FORTH_RSP_TOS
365f			 
365f					if DEBUG_FORTH_WORDS 
365f						DMARK "LP8" 
365f f5				push af  
3660 3a 74 36			ld a, (.dmark)  
3663 32 6e fe			ld (debug_mark),a  
3666 3a 75 36			ld a, (.dmark+1)  
3669 32 6f fe			ld (debug_mark+1),a  
366c 3a 76 36			ld a, (.dmark+2)  
366f 32 70 fe			ld (debug_mark+2),a  
3672 18 03			jr .pastdmark  
3674 ..			.dmark: db "LP8"  
3677 f1			.pastdmark: pop af  
3678			endm  
# End of macro DMARK
3678					CALLMONITOR 
3678 cd c1 19			call break_point_state  
367b				endm  
# End of macro CALLMONITOR
367b					endif 
367b				;push hl 
367b			 
367b				; not going to DO any more 
367b				; get rid of the RSP pointer as DO will add it back in 
367b				;FORTH_RSP_POP 
367b				;pop hl 
367b			 
367b				;ld hl,(cli_ret_sp) 
367b				;ld e, (hl) 
367b				;inc hl 
367b				;ld d, (hl) 
367b				;ex de,hl 
367b 22 c9 f4			ld (os_tok_ptr), hl 
367e					if DEBUG_FORTH_WORDS 
367e						DMARK "LP<" 
367e f5				push af  
367f 3a 93 36			ld a, (.dmark)  
3682 32 6e fe			ld (debug_mark),a  
3685 3a 94 36			ld a, (.dmark+1)  
3688 32 6f fe			ld (debug_mark+1),a  
368b 3a 95 36			ld a, (.dmark+2)  
368e 32 70 fe			ld (debug_mark+2),a  
3691 18 03			jr .pastdmark  
3693 ..			.dmark: db "LP<"  
3696 f1			.pastdmark: pop af  
3697			endm  
# End of macro DMARK
3697					CALLMONITOR 
3697 cd c1 19			call break_point_state  
369a				endm  
# End of macro CALLMONITOR
369a				endif 
369a c3 ca 24			jp exec1 
369d			 
369d					 
369d			 
369d			 
369d					NEXTW 
369d c3 39 24			jp macro_next 
36a0				endm 
# End of macro NEXTW
36a0			.I:  
36a0			 
36a0				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
36a0 5e				db WORD_SYS_CORE+74             
36a1 cb 36			dw .DLOOP            
36a3 02				db 1 + 1 
36a4 .. 00			db "I",0              
36a6				endm 
# End of macro CWHEAD
36a6			; | I ( -- ) Current loop counter | DONE 
36a6					if DEBUG_FORTH_WORDS_KEY 
36a6						DMARK "I.." 
36a6 f5				push af  
36a7 3a bb 36			ld a, (.dmark)  
36aa 32 6e fe			ld (debug_mark),a  
36ad 3a bc 36			ld a, (.dmark+1)  
36b0 32 6f fe			ld (debug_mark+1),a  
36b3 3a bd 36			ld a, (.dmark+2)  
36b6 32 70 fe			ld (debug_mark+2),a  
36b9 18 03			jr .pastdmark  
36bb ..			.dmark: db "I.."  
36be f1			.pastdmark: pop af  
36bf			endm  
# End of macro DMARK
36bf						CALLMONITOR 
36bf cd c1 19			call break_point_state  
36c2				endm  
# End of macro CALLMONITOR
36c2					endif 
36c2			 
36c2 2a ed f4				ld hl,(os_current_i) 
36c5 cd 8c 20				call forth_push_numhl 
36c8			 
36c8					NEXTW 
36c8 c3 39 24			jp macro_next 
36cb				endm 
# End of macro NEXTW
36cb			.DLOOP: 
36cb				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
36cb 5f				db WORD_SYS_CORE+75             
36cc ac 37			dw .REPEAT            
36ce 06				db 5 + 1 
36cf .. 00			db "-LOOP",0              
36d5				endm 
# End of macro CWHEAD
36d5			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
36d5				; pop tos as current loop count to hl 
36d5					if DEBUG_FORTH_WORDS_KEY 
36d5						DMARK "-LP" 
36d5 f5				push af  
36d6 3a ea 36			ld a, (.dmark)  
36d9 32 6e fe			ld (debug_mark),a  
36dc 3a eb 36			ld a, (.dmark+1)  
36df 32 6f fe			ld (debug_mark+1),a  
36e2 3a ec 36			ld a, (.dmark+2)  
36e5 32 70 fe			ld (debug_mark+2),a  
36e8 18 03			jr .pastdmark  
36ea ..			.dmark: db "-LP"  
36ed f1			.pastdmark: pop af  
36ee			endm  
# End of macro DMARK
36ee						CALLMONITOR 
36ee cd c1 19			call break_point_state  
36f1				endm  
# End of macro CALLMONITOR
36f1					endif 
36f1			 
36f1				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36f1			 
36f1				FORTH_LOOP_TOS 
36f1 cd e7 22			call macro_forth_loop_tos 
36f4				endm 
# End of macro FORTH_LOOP_TOS
36f4 e5				push hl 
36f5			 
36f5					if DEBUG_FORTH_WORDS 
36f5						DMARK "-LP" 
36f5 f5				push af  
36f6 3a 0a 37			ld a, (.dmark)  
36f9 32 6e fe			ld (debug_mark),a  
36fc 3a 0b 37			ld a, (.dmark+1)  
36ff 32 6f fe			ld (debug_mark+1),a  
3702 3a 0c 37			ld a, (.dmark+2)  
3705 32 70 fe			ld (debug_mark+2),a  
3708 18 03			jr .pastdmark  
370a ..			.dmark: db "-LP"  
370d f1			.pastdmark: pop af  
370e			endm  
# End of macro DMARK
370e						CALLMONITOR 
370e cd c1 19			call break_point_state  
3711				endm  
# End of macro CALLMONITOR
3711					endif 
3711				; next item on the stack is the limit. get it 
3711			 
3711			 
3711				FORTH_LOOP_POP 
3711 cd f1 22			call macro_forth_loop_pop 
3714				endm 
# End of macro FORTH_LOOP_POP
3714			 
3714				FORTH_LOOP_TOS 
3714 cd e7 22			call macro_forth_loop_tos 
3717				endm 
# End of macro FORTH_LOOP_TOS
3717			 
3717 d1				pop de		 ; de = i, hl = limit 
3718			 
3718					if DEBUG_FORTH_WORDS 
3718						DMARK "-L1" 
3718 f5				push af  
3719 3a 2d 37			ld a, (.dmark)  
371c 32 6e fe			ld (debug_mark),a  
371f 3a 2e 37			ld a, (.dmark+1)  
3722 32 6f fe			ld (debug_mark+1),a  
3725 3a 2f 37			ld a, (.dmark+2)  
3728 32 70 fe			ld (debug_mark+2),a  
372b 18 03			jr .pastdmark  
372d ..			.dmark: db "-L1"  
3730 f1			.pastdmark: pop af  
3731			endm  
# End of macro DMARK
3731						CALLMONITOR 
3731 cd c1 19			call break_point_state  
3734				endm  
# End of macro CALLMONITOR
3734					endif 
3734			 
3734				; go back to previous word 
3734			 
3734 d5				push de    ; save I for inc later 
3735			 
3735			 
3735				; get limit 
3735				;  is I at limit? 
3735			 
3735			 
3735					if DEBUG_FORTH_WORDS 
3735						DMARK "-L1" 
3735 f5				push af  
3736 3a 4a 37			ld a, (.dmark)  
3739 32 6e fe			ld (debug_mark),a  
373c 3a 4b 37			ld a, (.dmark+1)  
373f 32 6f fe			ld (debug_mark+1),a  
3742 3a 4c 37			ld a, (.dmark+2)  
3745 32 70 fe			ld (debug_mark+2),a  
3748 18 03			jr .pastdmark  
374a ..			.dmark: db "-L1"  
374d f1			.pastdmark: pop af  
374e			endm  
# End of macro DMARK
374e						CALLMONITOR 
374e cd c1 19			call break_point_state  
3751				endm  
# End of macro CALLMONITOR
3751					endif 
3751			 
3751 ed 52			sbc hl, de 
3753			 
3753			 
3753				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3753			 
3753 20 26				jr nz, .mloopnotdone 
3755			 
3755 e1				pop hl   ; get rid of saved I 
3756				FORTH_LOOP_POP     ; get rid of limit 
3756 cd f1 22			call macro_forth_loop_pop 
3759				endm 
# End of macro FORTH_LOOP_POP
3759			 
3759				FORTH_RSP_POP     ; get rid of DO ptr 
3759 cd 54 20			call macro_forth_rsp_pop 
375c				endm 
# End of macro FORTH_RSP_POP
375c			 
375c			if DEBUG_FORTH_WORDS 
375c						DMARK "-L>" 
375c f5				push af  
375d 3a 71 37			ld a, (.dmark)  
3760 32 6e fe			ld (debug_mark),a  
3763 3a 72 37			ld a, (.dmark+1)  
3766 32 6f fe			ld (debug_mark+1),a  
3769 3a 73 37			ld a, (.dmark+2)  
376c 32 70 fe			ld (debug_mark+2),a  
376f 18 03			jr .pastdmark  
3771 ..			.dmark: db "-L>"  
3774 f1			.pastdmark: pop af  
3775			endm  
# End of macro DMARK
3775				CALLMONITOR 
3775 cd c1 19			call break_point_state  
3778				endm  
# End of macro CALLMONITOR
3778			endif 
3778			 
3778					NEXTW 
3778 c3 39 24			jp macro_next 
377b				endm 
# End of macro NEXTW
377b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
377b			 
377b			.mloopnotdone: 
377b			 
377b e1				pop hl    ; get I 
377c 2b				dec hl 
377d			 
377d			   	; save new I 
377d			 
377d			 
377d					; set I counter 
377d			 
377d 22 ed f4				ld (os_current_i), hl 
3780			 
3780					 
3780				FORTH_LOOP_NEXT 
3780 cd b4 22			call macro_forth_loop_next 
3783				endm 
# End of macro FORTH_LOOP_NEXT
3783			 
3783			 
3783					if DEBUG_FORTH_WORDS 
3783 eb						ex de,hl 
3784					endif 
3784			 
3784			;	; get DO ptr 
3784			; 
3784				FORTH_RSP_TOS 
3784 cd 4a 20			call macro_forth_rsp_tos 
3787				endm 
# End of macro FORTH_RSP_TOS
3787			 
3787				;push hl 
3787			 
3787				; not going to DO any more 
3787				; get rid of the RSP pointer as DO will add it back in 
3787				;FORTH_RSP_POP 
3787				;pop hl 
3787			 
3787			 
3787 22 c9 f4			ld (os_tok_ptr), hl 
378a					if DEBUG_FORTH_WORDS 
378a						DMARK "-L<" 
378a f5				push af  
378b 3a 9f 37			ld a, (.dmark)  
378e 32 6e fe			ld (debug_mark),a  
3791 3a a0 37			ld a, (.dmark+1)  
3794 32 6f fe			ld (debug_mark+1),a  
3797 3a a1 37			ld a, (.dmark+2)  
379a 32 70 fe			ld (debug_mark+2),a  
379d 18 03			jr .pastdmark  
379f ..			.dmark: db "-L<"  
37a2 f1			.pastdmark: pop af  
37a3			endm  
# End of macro DMARK
37a3					CALLMONITOR 
37a3 cd c1 19			call break_point_state  
37a6				endm  
# End of macro CALLMONITOR
37a6				endif 
37a6 c3 ca 24			jp exec1 
37a9			 
37a9					 
37a9			 
37a9			 
37a9			 
37a9				NEXTW 
37a9 c3 39 24			jp macro_next 
37ac				endm 
# End of macro NEXTW
37ac			 
37ac			 
37ac			 
37ac			 
37ac			.REPEAT: 
37ac				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
37ac 71				db WORD_SYS_CORE+93             
37ad ff 37			dw .UNTIL            
37af 06				db 5 + 1 
37b0 .. 00			db "REPEAT",0              
37b7				endm 
# End of macro CWHEAD
37b7			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
37b7			;  push pc to rsp stack past the REPEAT 
37b7					if DEBUG_FORTH_WORDS_KEY 
37b7						DMARK "REP" 
37b7 f5				push af  
37b8 3a cc 37			ld a, (.dmark)  
37bb 32 6e fe			ld (debug_mark),a  
37be 3a cd 37			ld a, (.dmark+1)  
37c1 32 6f fe			ld (debug_mark+1),a  
37c4 3a ce 37			ld a, (.dmark+2)  
37c7 32 70 fe			ld (debug_mark+2),a  
37ca 18 03			jr .pastdmark  
37cc ..			.dmark: db "REP"  
37cf f1			.pastdmark: pop af  
37d0			endm  
# End of macro DMARK
37d0						CALLMONITOR 
37d0 cd c1 19			call break_point_state  
37d3				endm  
# End of macro CALLMONITOR
37d3					endif 
37d3			 
37d3 2a c9 f4				ld hl, (os_tok_ptr) 
37d6 23					inc hl   ; R 
37d7 23					inc hl  ; E 
37d8 23					inc hl   ; P 
37d9 23					inc hl   ; E 
37da 23					inc hl   ; A 
37db 23					inc hl   ; T 
37dc 23					inc hl   ; zero 
37dd					FORTH_RSP_NEXT 
37dd cd 33 20			call macro_forth_rsp_next 
37e0				endm 
# End of macro FORTH_RSP_NEXT
37e0			 
37e0			 
37e0					if DEBUG_FORTH_WORDS 
37e0						DMARK "REP" 
37e0 f5				push af  
37e1 3a f5 37			ld a, (.dmark)  
37e4 32 6e fe			ld (debug_mark),a  
37e7 3a f6 37			ld a, (.dmark+1)  
37ea 32 6f fe			ld (debug_mark+1),a  
37ed 3a f7 37			ld a, (.dmark+2)  
37f0 32 70 fe			ld (debug_mark+2),a  
37f3 18 03			jr .pastdmark  
37f5 ..			.dmark: db "REP"  
37f8 f1			.pastdmark: pop af  
37f9			endm  
# End of macro DMARK
37f9						;pop bc    ; TODO BUG ?????? what is this for???? 
37f9						CALLMONITOR 
37f9 cd c1 19			call break_point_state  
37fc				endm  
# End of macro CALLMONITOR
37fc					endif 
37fc			 
37fc					NEXTW 
37fc c3 39 24			jp macro_next 
37ff				endm 
# End of macro NEXTW
37ff			;	       NEXTW 
37ff			 
37ff			.UNTIL: 
37ff				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
37ff 72				db WORD_SYS_CORE+94             
3800 96 38			dw .ENDFLOW            
3802 06				db 5 + 1 
3803 .. 00			db "UNTIL",0              
3809				endm 
# End of macro CWHEAD
3809			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3809			 
3809				; pop tos as check 
3809			 
3809				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3809			 
3809				FORTH_DSP_VALUEHL 
3809 cd 83 22			call macro_dsp_valuehl 
380c				endm 
# End of macro FORTH_DSP_VALUEHL
380c			 
380c					if DEBUG_FORTH_WORDS_KEY 
380c						DMARK "UNT" 
380c f5				push af  
380d 3a 21 38			ld a, (.dmark)  
3810 32 6e fe			ld (debug_mark),a  
3813 3a 22 38			ld a, (.dmark+1)  
3816 32 6f fe			ld (debug_mark+1),a  
3819 3a 23 38			ld a, (.dmark+2)  
381c 32 70 fe			ld (debug_mark+2),a  
381f 18 03			jr .pastdmark  
3821 ..			.dmark: db "UNT"  
3824 f1			.pastdmark: pop af  
3825			endm  
# End of macro DMARK
3825						CALLMONITOR 
3825 cd c1 19			call break_point_state  
3828				endm  
# End of macro CALLMONITOR
3828					endif 
3828			 
3828			;	push hl 
3828				FORTH_DSP_POP 
3828 cd 3b 23			call macro_forth_dsp_pop 
382b				endm 
# End of macro FORTH_DSP_POP
382b			 
382b			;	pop hl 
382b			 
382b				; test if true 
382b			 
382b cd 75 0f			call ishlzero 
382e			;	ld a,l 
382e			;	add h 
382e			; 
382e			;	cp 0 
382e			 
382e 20 3e			jr nz, .untilnotdone 
3830			 
3830					if DEBUG_FORTH_WORDS 
3830						DMARK "UNf" 
3830 f5				push af  
3831 3a 45 38			ld a, (.dmark)  
3834 32 6e fe			ld (debug_mark),a  
3837 3a 46 38			ld a, (.dmark+1)  
383a 32 6f fe			ld (debug_mark+1),a  
383d 3a 47 38			ld a, (.dmark+2)  
3840 32 70 fe			ld (debug_mark+2),a  
3843 18 03			jr .pastdmark  
3845 ..			.dmark: db "UNf"  
3848 f1			.pastdmark: pop af  
3849			endm  
# End of macro DMARK
3849						CALLMONITOR 
3849 cd c1 19			call break_point_state  
384c				endm  
# End of macro CALLMONITOR
384c					endif 
384c			 
384c			 
384c			 
384c				FORTH_RSP_POP     ; get rid of DO ptr 
384c cd 54 20			call macro_forth_rsp_pop 
384f				endm 
# End of macro FORTH_RSP_POP
384f			 
384f			if DEBUG_FORTH_WORDS 
384f						DMARK "UN>" 
384f f5				push af  
3850 3a 64 38			ld a, (.dmark)  
3853 32 6e fe			ld (debug_mark),a  
3856 3a 65 38			ld a, (.dmark+1)  
3859 32 6f fe			ld (debug_mark+1),a  
385c 3a 66 38			ld a, (.dmark+2)  
385f 32 70 fe			ld (debug_mark+2),a  
3862 18 03			jr .pastdmark  
3864 ..			.dmark: db "UN>"  
3867 f1			.pastdmark: pop af  
3868			endm  
# End of macro DMARK
3868				CALLMONITOR 
3868 cd c1 19			call break_point_state  
386b				endm  
# End of macro CALLMONITOR
386b			endif 
386b			 
386b					NEXTW 
386b c3 39 24			jp macro_next 
386e				endm 
# End of macro NEXTW
386e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
386e			 
386e			.untilnotdone: 
386e			 
386e			 
386e			;	; get DO ptr 
386e			; 
386e				FORTH_RSP_TOS 
386e cd 4a 20			call macro_forth_rsp_tos 
3871				endm 
# End of macro FORTH_RSP_TOS
3871			 
3871				;push hl 
3871			 
3871				; not going to DO any more 
3871				; get rid of the RSP pointer as DO will add it back in 
3871				;FORTH_RSP_POP 
3871				;pop hl 
3871			 
3871			 
3871 22 c9 f4			ld (os_tok_ptr), hl 
3874					if DEBUG_FORTH_WORDS 
3874						DMARK "UN<" 
3874 f5				push af  
3875 3a 89 38			ld a, (.dmark)  
3878 32 6e fe			ld (debug_mark),a  
387b 3a 8a 38			ld a, (.dmark+1)  
387e 32 6f fe			ld (debug_mark+1),a  
3881 3a 8b 38			ld a, (.dmark+2)  
3884 32 70 fe			ld (debug_mark+2),a  
3887 18 03			jr .pastdmark  
3889 ..			.dmark: db "UN<"  
388c f1			.pastdmark: pop af  
388d			endm  
# End of macro DMARK
388d					CALLMONITOR 
388d cd c1 19			call break_point_state  
3890				endm  
# End of macro CALLMONITOR
3890				endif 
3890 c3 ca 24			jp exec1 
3893			 
3893					 
3893			 
3893			 
3893					NEXTW 
3893 c3 39 24			jp macro_next 
3896				endm 
# End of macro NEXTW
3896			 
3896			 
3896			.ENDFLOW: 
3896			 
3896			; eof 
3896			 
# End of file forth_words_flow.asm
3896			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3896			include "forth_words_logic.asm" 
3896			 
3896			; | ## Logic Words 
3896			 
3896			.NOT: 
3896				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3896 2d				db WORD_SYS_CORE+25             
3897 de 38			dw .IS            
3899 04				db 3 + 1 
389a .. 00			db "NOT",0              
389e				endm 
# End of macro CWHEAD
389e			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
389e					if DEBUG_FORTH_WORDS_KEY 
389e						DMARK "NOT" 
389e f5				push af  
389f 3a b3 38			ld a, (.dmark)  
38a2 32 6e fe			ld (debug_mark),a  
38a5 3a b4 38			ld a, (.dmark+1)  
38a8 32 6f fe			ld (debug_mark+1),a  
38ab 3a b5 38			ld a, (.dmark+2)  
38ae 32 70 fe			ld (debug_mark+2),a  
38b1 18 03			jr .pastdmark  
38b3 ..			.dmark: db "NOT"  
38b6 f1			.pastdmark: pop af  
38b7			endm  
# End of macro DMARK
38b7						CALLMONITOR 
38b7 cd c1 19			call break_point_state  
38ba				endm  
# End of macro CALLMONITOR
38ba					endif 
38ba					FORTH_DSP 
38ba cd 49 22			call macro_forth_dsp 
38bd				endm 
# End of macro FORTH_DSP
38bd 7e					ld a,(hl)	; get type of value on TOS 
38be fe 02				cp DS_TYPE_INUM  
38c0 28 03				jr z, .noti 
38c2					NEXTW 
38c2 c3 39 24			jp macro_next 
38c5				endm 
# End of macro NEXTW
38c5			.noti:          FORTH_DSP_VALUEHL 
38c5 cd 83 22			call macro_dsp_valuehl 
38c8				endm 
# End of macro FORTH_DSP_VALUEHL
38c8			;		push hl 
38c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c8 cd 3b 23			call macro_forth_dsp_pop 
38cb				endm 
# End of macro FORTH_DSP_POP
38cb			;		pop hl 
38cb 3e 00				ld a,0 
38cd bd					cp l 
38ce 28 04				jr z, .not2t 
38d0 2e 00				ld l, 0 
38d2 18 02				jr .notip 
38d4			 
38d4 2e ff		.not2t:		ld l, 255 
38d6			 
38d6 26 00		.notip:		ld h, 0	 
38d8			 
38d8 cd 8c 20				call forth_push_numhl 
38db					NEXTW 
38db c3 39 24			jp macro_next 
38de				endm 
# End of macro NEXTW
38de			 
38de			.IS: 
38de				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
38de 2d				db WORD_SYS_CORE+25             
38df 04 39			dw .LZERO            
38e1 03				db 2 + 1 
38e2 .. 00			db "IS",0              
38e5				endm 
# End of macro CWHEAD
38e5			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
38e5					if DEBUG_FORTH_WORDS_KEY 
38e5						DMARK "IS." 
38e5 f5				push af  
38e6 3a fa 38			ld a, (.dmark)  
38e9 32 6e fe			ld (debug_mark),a  
38ec 3a fb 38			ld a, (.dmark+1)  
38ef 32 6f fe			ld (debug_mark+1),a  
38f2 3a fc 38			ld a, (.dmark+2)  
38f5 32 70 fe			ld (debug_mark+2),a  
38f8 18 03			jr .pastdmark  
38fa ..			.dmark: db "IS."  
38fd f1			.pastdmark: pop af  
38fe			endm  
# End of macro DMARK
38fe						CALLMONITOR 
38fe cd c1 19			call break_point_state  
3901				endm  
# End of macro CALLMONITOR
3901					endif 
3901					NEXTW 
3901 c3 39 24			jp macro_next 
3904				endm 
# End of macro NEXTW
3904			.LZERO: 
3904				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3904 2d				db WORD_SYS_CORE+25             
3905 0e 39			dw .TZERO            
3907 03				db 2 + 1 
3908 .. 00			db "0<",0              
390b				endm 
# End of macro CWHEAD
390b			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
390b					NEXTW 
390b c3 39 24			jp macro_next 
390e				endm 
# End of macro NEXTW
390e			.TZERO: 
390e				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
390e 2e				db WORD_SYS_CORE+26             
390f 55 39			dw .LESS            
3911 03				db 2 + 1 
3912 .. 00			db "0=",0              
3915				endm 
# End of macro CWHEAD
3915			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3915				; TODO add floating point number detection 
3915					;v5 FORTH_DSP_VALUE 
3915					if DEBUG_FORTH_WORDS_KEY 
3915						DMARK "0=." 
3915 f5				push af  
3916 3a 2a 39			ld a, (.dmark)  
3919 32 6e fe			ld (debug_mark),a  
391c 3a 2b 39			ld a, (.dmark+1)  
391f 32 6f fe			ld (debug_mark+1),a  
3922 3a 2c 39			ld a, (.dmark+2)  
3925 32 70 fe			ld (debug_mark+2),a  
3928 18 03			jr .pastdmark  
392a ..			.dmark: db "0=."  
392d f1			.pastdmark: pop af  
392e			endm  
# End of macro DMARK
392e						CALLMONITOR 
392e cd c1 19			call break_point_state  
3931				endm  
# End of macro CALLMONITOR
3931					endif 
3931					FORTH_DSP 
3931 cd 49 22			call macro_forth_dsp 
3934				endm 
# End of macro FORTH_DSP
3934 7e					ld a,(hl)	; get type of value on TOS 
3935 fe 02				cp DS_TYPE_INUM  
3937 28 00				jr z, .tz_inum 
3939			 
3939				if FORTH_ENABLE_FLOATMATH 
3939					jr .tz_done 
3939			 
3939				endif 
3939					 
3939			 
3939			.tz_inum: 
3939					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3939 cd 83 22			call macro_dsp_valuehl 
393c				endm 
# End of macro FORTH_DSP_VALUEHL
393c			 
393c			;		push hl 
393c			 
393c					; destroy value TOS 
393c			 
393c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
393c cd 3b 23			call macro_forth_dsp_pop 
393f				endm 
# End of macro FORTH_DSP_POP
393f			 
393f			;		pop hl 
393f			 
393f 3e 00				ld a,0 
3941			 
3941 bd					cp l 
3942 20 08				jr nz, .tz_notzero 
3944			 
3944 bc					cp h 
3945			 
3945 20 05				jr nz, .tz_notzero 
3947			 
3947			 
3947 21 01 00				ld hl, FORTH_TRUE 
394a 18 03				jr .tz_done 
394c			 
394c 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
394f			 
394f					; push value back onto stack for another op etc 
394f			 
394f			.tz_done: 
394f cd 8c 20				call forth_push_numhl 
3952			 
3952					NEXTW 
3952 c3 39 24			jp macro_next 
3955				endm 
# End of macro NEXTW
3955			.LESS: 
3955				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3955 2f				db WORD_SYS_CORE+27             
3956 be 39			dw .GT            
3958 02				db 1 + 1 
3959 .. 00			db "<",0              
395b				endm 
# End of macro CWHEAD
395b			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
395b				; TODO add floating point number detection 
395b					if DEBUG_FORTH_WORDS_KEY 
395b						DMARK "LES" 
395b f5				push af  
395c 3a 70 39			ld a, (.dmark)  
395f 32 6e fe			ld (debug_mark),a  
3962 3a 71 39			ld a, (.dmark+1)  
3965 32 6f fe			ld (debug_mark+1),a  
3968 3a 72 39			ld a, (.dmark+2)  
396b 32 70 fe			ld (debug_mark+2),a  
396e 18 03			jr .pastdmark  
3970 ..			.dmark: db "LES"  
3973 f1			.pastdmark: pop af  
3974			endm  
# End of macro DMARK
3974						CALLMONITOR 
3974 cd c1 19			call break_point_state  
3977				endm  
# End of macro CALLMONITOR
3977					endif 
3977					FORTH_DSP 
3977 cd 49 22			call macro_forth_dsp 
397a				endm 
# End of macro FORTH_DSP
397a					;v5 FORTH_DSP_VALUE 
397a 7e					ld a,(hl)	; get type of value on TOS 
397b fe 02				cp DS_TYPE_INUM  
397d 28 00				jr z, .less_inum 
397f			 
397f				if FORTH_ENABLE_FLOATMATH 
397f					jr .less_done 
397f			 
397f				endif 
397f					 
397f			 
397f			.less_inum: 
397f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
397f cd 83 22			call macro_dsp_valuehl 
3982				endm 
# End of macro FORTH_DSP_VALUEHL
3982			 
3982 e5					push hl  ; u2 
3983			 
3983					; destroy value TOS 
3983			 
3983					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3983 cd 3b 23			call macro_forth_dsp_pop 
3986				endm 
# End of macro FORTH_DSP_POP
3986			 
3986			 
3986					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3986 cd 83 22			call macro_dsp_valuehl 
3989				endm 
# End of macro FORTH_DSP_VALUEHL
3989			 
3989 e5					push hl    ; u1 
398a			 
398a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
398a cd 3b 23			call macro_forth_dsp_pop 
398d				endm 
# End of macro FORTH_DSP_POP
398d			 
398d			 
398d b7			 or a      ;clear carry flag 
398e 01 00 00		 ld bc, FORTH_FALSE 
3991 e1			  pop hl    ; u1 
3992 d1			  pop de    ; u2 
3993 ed 52		  sbc hl,de 
3995 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3997			 
3997 01 01 00		 ld bc, FORTH_TRUE 
399a			.lscont:  
399a c5					push bc 
399b e1					pop hl 
399c			 
399c					if DEBUG_FORTH_WORDS 
399c						DMARK "LT1" 
399c f5				push af  
399d 3a b1 39			ld a, (.dmark)  
39a0 32 6e fe			ld (debug_mark),a  
39a3 3a b2 39			ld a, (.dmark+1)  
39a6 32 6f fe			ld (debug_mark+1),a  
39a9 3a b3 39			ld a, (.dmark+2)  
39ac 32 70 fe			ld (debug_mark+2),a  
39af 18 03			jr .pastdmark  
39b1 ..			.dmark: db "LT1"  
39b4 f1			.pastdmark: pop af  
39b5			endm  
# End of macro DMARK
39b5						CALLMONITOR 
39b5 cd c1 19			call break_point_state  
39b8				endm  
# End of macro CALLMONITOR
39b8					endif 
39b8 cd 8c 20				call forth_push_numhl 
39bb			 
39bb					NEXTW 
39bb c3 39 24			jp macro_next 
39be				endm 
# End of macro NEXTW
39be			.GT: 
39be				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
39be 30				db WORD_SYS_CORE+28             
39bf 27 3a			dw .EQUAL            
39c1 02				db 1 + 1 
39c2 .. 00			db ">",0              
39c4				endm 
# End of macro CWHEAD
39c4			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
39c4				; TODO add floating point number detection 
39c4					if DEBUG_FORTH_WORDS_KEY 
39c4						DMARK "GRT" 
39c4 f5				push af  
39c5 3a d9 39			ld a, (.dmark)  
39c8 32 6e fe			ld (debug_mark),a  
39cb 3a da 39			ld a, (.dmark+1)  
39ce 32 6f fe			ld (debug_mark+1),a  
39d1 3a db 39			ld a, (.dmark+2)  
39d4 32 70 fe			ld (debug_mark+2),a  
39d7 18 03			jr .pastdmark  
39d9 ..			.dmark: db "GRT"  
39dc f1			.pastdmark: pop af  
39dd			endm  
# End of macro DMARK
39dd						CALLMONITOR 
39dd cd c1 19			call break_point_state  
39e0				endm  
# End of macro CALLMONITOR
39e0					endif 
39e0					FORTH_DSP 
39e0 cd 49 22			call macro_forth_dsp 
39e3				endm 
# End of macro FORTH_DSP
39e3					;FORTH_DSP_VALUE 
39e3 7e					ld a,(hl)	; get type of value on TOS 
39e4 fe 02				cp DS_TYPE_INUM  
39e6 28 00				jr z, .gt_inum 
39e8			 
39e8				if FORTH_ENABLE_FLOATMATH 
39e8					jr .gt_done 
39e8			 
39e8				endif 
39e8					 
39e8			 
39e8			.gt_inum: 
39e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e8 cd 83 22			call macro_dsp_valuehl 
39eb				endm 
# End of macro FORTH_DSP_VALUEHL
39eb			 
39eb e5					push hl  ; u2 
39ec			 
39ec					; destroy value TOS 
39ec			 
39ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ec cd 3b 23			call macro_forth_dsp_pop 
39ef				endm 
# End of macro FORTH_DSP_POP
39ef			 
39ef			 
39ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ef cd 83 22			call macro_dsp_valuehl 
39f2				endm 
# End of macro FORTH_DSP_VALUEHL
39f2			 
39f2 e5					push hl    ; u1 
39f3			 
39f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f3 cd 3b 23			call macro_forth_dsp_pop 
39f6				endm 
# End of macro FORTH_DSP_POP
39f6			 
39f6			 
39f6 b7			 or a      ;clear carry flag 
39f7 01 00 00		 ld bc, FORTH_FALSE 
39fa e1			  pop hl    ; u1 
39fb d1			  pop de    ; u2 
39fc ed 52		  sbc hl,de 
39fe 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a00			 
3a00 01 01 00		 ld bc, FORTH_TRUE 
3a03			.gtcont:  
3a03 c5					push bc 
3a04 e1					pop hl 
3a05			 
3a05					if DEBUG_FORTH_WORDS 
3a05						DMARK "GT1" 
3a05 f5				push af  
3a06 3a 1a 3a			ld a, (.dmark)  
3a09 32 6e fe			ld (debug_mark),a  
3a0c 3a 1b 3a			ld a, (.dmark+1)  
3a0f 32 6f fe			ld (debug_mark+1),a  
3a12 3a 1c 3a			ld a, (.dmark+2)  
3a15 32 70 fe			ld (debug_mark+2),a  
3a18 18 03			jr .pastdmark  
3a1a ..			.dmark: db "GT1"  
3a1d f1			.pastdmark: pop af  
3a1e			endm  
# End of macro DMARK
3a1e						CALLMONITOR 
3a1e cd c1 19			call break_point_state  
3a21				endm  
# End of macro CALLMONITOR
3a21					endif 
3a21 cd 8c 20				call forth_push_numhl 
3a24			 
3a24					NEXTW 
3a24 c3 39 24			jp macro_next 
3a27				endm 
# End of macro NEXTW
3a27			.EQUAL: 
3a27				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a27 31				db WORD_SYS_CORE+29             
3a28 92 3a			dw .ENDLOGIC            
3a2a 02				db 1 + 1 
3a2b .. 00			db "=",0              
3a2d				endm 
# End of macro CWHEAD
3a2d			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3a2d				; TODO add floating point number detection 
3a2d					if DEBUG_FORTH_WORDS_KEY 
3a2d						DMARK "EQ." 
3a2d f5				push af  
3a2e 3a 42 3a			ld a, (.dmark)  
3a31 32 6e fe			ld (debug_mark),a  
3a34 3a 43 3a			ld a, (.dmark+1)  
3a37 32 6f fe			ld (debug_mark+1),a  
3a3a 3a 44 3a			ld a, (.dmark+2)  
3a3d 32 70 fe			ld (debug_mark+2),a  
3a40 18 03			jr .pastdmark  
3a42 ..			.dmark: db "EQ."  
3a45 f1			.pastdmark: pop af  
3a46			endm  
# End of macro DMARK
3a46						CALLMONITOR 
3a46 cd c1 19			call break_point_state  
3a49				endm  
# End of macro CALLMONITOR
3a49					endif 
3a49					FORTH_DSP 
3a49 cd 49 22			call macro_forth_dsp 
3a4c				endm 
# End of macro FORTH_DSP
3a4c					;v5 FORTH_DSP_VALUE 
3a4c 7e					ld a,(hl)	; get type of value on TOS 
3a4d fe 02				cp DS_TYPE_INUM  
3a4f 28 00				jr z, .eq_inum 
3a51			 
3a51				if FORTH_ENABLE_FLOATMATH 
3a51					jr .eq_done 
3a51			 
3a51				endif 
3a51					 
3a51			 
3a51			.eq_inum: 
3a51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a51 cd 83 22			call macro_dsp_valuehl 
3a54				endm 
# End of macro FORTH_DSP_VALUEHL
3a54			 
3a54 e5					push hl 
3a55			 
3a55					; destroy value TOS 
3a55			 
3a55					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a55 cd 3b 23			call macro_forth_dsp_pop 
3a58				endm 
# End of macro FORTH_DSP_POP
3a58			 
3a58			 
3a58					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a58 cd 83 22			call macro_dsp_valuehl 
3a5b				endm 
# End of macro FORTH_DSP_VALUEHL
3a5b			 
3a5b					; one value on hl get other one back 
3a5b			 
3a5b e5					push hl 
3a5c			 
3a5c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5c cd 3b 23			call macro_forth_dsp_pop 
3a5f				endm 
# End of macro FORTH_DSP_POP
3a5f			 
3a5f 0e 00				ld c, FORTH_FALSE 
3a61			 
3a61 e1					pop hl 
3a62 d1					pop de 
3a63			 
3a63 7b					ld a, e 
3a64 bd					cp l 
3a65			 
3a65 20 06				jr nz, .eq_done 
3a67			 
3a67 7a					ld a, d 
3a68 bc					cp h 
3a69			 
3a69 20 02				jr nz, .eq_done 
3a6b			 
3a6b 0e 01				ld c, FORTH_TRUE 
3a6d					 
3a6d			 
3a6d			 
3a6d			.eq_done: 
3a6d			 
3a6d					; TODO push value back onto stack for another op etc 
3a6d			 
3a6d 26 00				ld h, 0 
3a6f 69					ld l, c 
3a70					if DEBUG_FORTH_WORDS 
3a70						DMARK "EQ1" 
3a70 f5				push af  
3a71 3a 85 3a			ld a, (.dmark)  
3a74 32 6e fe			ld (debug_mark),a  
3a77 3a 86 3a			ld a, (.dmark+1)  
3a7a 32 6f fe			ld (debug_mark+1),a  
3a7d 3a 87 3a			ld a, (.dmark+2)  
3a80 32 70 fe			ld (debug_mark+2),a  
3a83 18 03			jr .pastdmark  
3a85 ..			.dmark: db "EQ1"  
3a88 f1			.pastdmark: pop af  
3a89			endm  
# End of macro DMARK
3a89						CALLMONITOR 
3a89 cd c1 19			call break_point_state  
3a8c				endm  
# End of macro CALLMONITOR
3a8c					endif 
3a8c cd 8c 20				call forth_push_numhl 
3a8f			 
3a8f					NEXTW 
3a8f c3 39 24			jp macro_next 
3a92				endm 
# End of macro NEXTW
3a92			 
3a92			 
3a92			.ENDLOGIC: 
3a92			; eof 
3a92			 
3a92			 
# End of file forth_words_logic.asm
3a92			include "forth_words_maths.asm" 
3a92			 
3a92			; | ## Maths Words 
3a92			 
3a92			.PLUS:	 
3a92				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3a92 15				db WORD_SYS_CORE+1             
3a93 f0 3a			dw .NEG            
3a95 02				db 1 + 1 
3a96 .. 00			db "+",0              
3a98				endm 
# End of macro CWHEAD
3a98			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3a98					if DEBUG_FORTH_WORDS_KEY 
3a98						DMARK "PLU" 
3a98 f5				push af  
3a99 3a ad 3a			ld a, (.dmark)  
3a9c 32 6e fe			ld (debug_mark),a  
3a9f 3a ae 3a			ld a, (.dmark+1)  
3aa2 32 6f fe			ld (debug_mark+1),a  
3aa5 3a af 3a			ld a, (.dmark+2)  
3aa8 32 70 fe			ld (debug_mark+2),a  
3aab 18 03			jr .pastdmark  
3aad ..			.dmark: db "PLU"  
3ab0 f1			.pastdmark: pop af  
3ab1			endm  
# End of macro DMARK
3ab1						CALLMONITOR 
3ab1 cd c1 19			call break_point_state  
3ab4				endm  
# End of macro CALLMONITOR
3ab4					endif 
3ab4					; add top two values and push back result 
3ab4			 
3ab4					;for v5 FORTH_DSP_VALUE 
3ab4					FORTH_DSP 
3ab4 cd 49 22			call macro_forth_dsp 
3ab7				endm 
# End of macro FORTH_DSP
3ab7 7e					ld a,(hl)	; get type of value on TOS 
3ab8 fe 02				cp DS_TYPE_INUM  
3aba 28 03				jr z, .dot_inum 
3abc			 
3abc					NEXTW 
3abc c3 39 24			jp macro_next 
3abf				endm 
# End of macro NEXTW
3abf			 
3abf			; float maths 
3abf			 
3abf				if FORTH_ENABLE_FLOATMATH 
3abf						inc hl      ; now at start of numeric as string 
3abf			 
3abf					if DEBUG_FORTH_MATHS 
3abf						DMARK "ADD" 
3abf				CALLMONITOR 
3abf					endif 
3abf			 
3abf					;ld ix, hl 
3abf					call CON 
3abf			 
3abf			 
3abf					push hl 
3abf					 
3abf					 
3abf			 
3abf						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3abf			 
3abf					; get next number 
3abf			 
3abf						FORTH_DSP_VALUE 
3abf			 
3abf						inc hl      ; now at start of numeric as string 
3abf			 
3abf					;ld ix, hl 
3abf					call CON 
3abf			 
3abf					push hl 
3abf			 
3abf			 
3abf						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3abf			 
3abf						; TODO do add 
3abf			 
3abf						call IADD 
3abf			 
3abf						; TODO get result back as ascii 
3abf			 
3abf						; TODO push result  
3abf			 
3abf			 
3abf			 
3abf						jr .dot_done 
3abf				endif 
3abf			 
3abf			.dot_inum: 
3abf			 
3abf			 
3abf					if DEBUG_FORTH_DOT 
3abf						DMARK "+IT" 
3abf f5				push af  
3ac0 3a d4 3a			ld a, (.dmark)  
3ac3 32 6e fe			ld (debug_mark),a  
3ac6 3a d5 3a			ld a, (.dmark+1)  
3ac9 32 6f fe			ld (debug_mark+1),a  
3acc 3a d6 3a			ld a, (.dmark+2)  
3acf 32 70 fe			ld (debug_mark+2),a  
3ad2 18 03			jr .pastdmark  
3ad4 ..			.dmark: db "+IT"  
3ad7 f1			.pastdmark: pop af  
3ad8			endm  
# End of macro DMARK
3ad8				CALLMONITOR 
3ad8 cd c1 19			call break_point_state  
3adb				endm  
# End of macro CALLMONITOR
3adb					endif 
3adb			 
3adb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3adb cd 83 22			call macro_dsp_valuehl 
3ade				endm 
# End of macro FORTH_DSP_VALUEHL
3ade			 
3ade				; TODO add floating point number detection 
3ade			 
3ade e5					push hl 
3adf			 
3adf					; destroy value TOS 
3adf			 
3adf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3adf cd 3b 23			call macro_forth_dsp_pop 
3ae2				endm 
# End of macro FORTH_DSP_POP
3ae2			 
3ae2			 
3ae2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ae2 cd 83 22			call macro_dsp_valuehl 
3ae5				endm 
# End of macro FORTH_DSP_VALUEHL
3ae5			 
3ae5					; one value on hl get other one back 
3ae5			 
3ae5 d1					pop de 
3ae6			 
3ae6					; do the add 
3ae6			 
3ae6 19					add hl,de 
3ae7			 
3ae7					; save it 
3ae7			 
3ae7			;		push hl	 
3ae7			 
3ae7					; 
3ae7			 
3ae7					; destroy value TOS 
3ae7			 
3ae7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ae7 cd 3b 23			call macro_forth_dsp_pop 
3aea				endm 
# End of macro FORTH_DSP_POP
3aea			 
3aea					; TODO push value back onto stack for another op etc 
3aea			 
3aea			;		pop hl 
3aea			 
3aea			.dot_done: 
3aea cd 8c 20				call forth_push_numhl 
3aed			 
3aed					NEXTW 
3aed c3 39 24			jp macro_next 
3af0				endm 
# End of macro NEXTW
3af0			.NEG: 
3af0			 
3af0				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3af0 17				db WORD_SYS_CORE+3             
3af1 33 3b			dw .DIV            
3af3 02				db 1 + 1 
3af4 .. 00			db "-",0              
3af6				endm 
# End of macro CWHEAD
3af6			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3af6					if DEBUG_FORTH_WORDS_KEY 
3af6						DMARK "SUB" 
3af6 f5				push af  
3af7 3a 0b 3b			ld a, (.dmark)  
3afa 32 6e fe			ld (debug_mark),a  
3afd 3a 0c 3b			ld a, (.dmark+1)  
3b00 32 6f fe			ld (debug_mark+1),a  
3b03 3a 0d 3b			ld a, (.dmark+2)  
3b06 32 70 fe			ld (debug_mark+2),a  
3b09 18 03			jr .pastdmark  
3b0b ..			.dmark: db "SUB"  
3b0e f1			.pastdmark: pop af  
3b0f			endm  
# End of macro DMARK
3b0f						CALLMONITOR 
3b0f cd c1 19			call break_point_state  
3b12				endm  
# End of macro CALLMONITOR
3b12					endif 
3b12			 
3b12			 
3b12				; TODO add floating point number detection 
3b12					; v5 FORTH_DSP_VALUE 
3b12					FORTH_DSP 
3b12 cd 49 22			call macro_forth_dsp 
3b15				endm 
# End of macro FORTH_DSP
3b15 7e					ld a,(hl)	; get type of value on TOS 
3b16 fe 02				cp DS_TYPE_INUM  
3b18 28 03				jr z, .neg_inum 
3b1a			 
3b1a					NEXTW 
3b1a c3 39 24			jp macro_next 
3b1d				endm 
# End of macro NEXTW
3b1d			 
3b1d			; float maths 
3b1d			 
3b1d				if FORTH_ENABLE_FLOATMATH 
3b1d					jr .neg_done 
3b1d			 
3b1d				endif 
3b1d					 
3b1d			 
3b1d			.neg_inum: 
3b1d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b1d cd 83 22			call macro_dsp_valuehl 
3b20				endm 
# End of macro FORTH_DSP_VALUEHL
3b20			 
3b20 e5					push hl 
3b21			 
3b21					; destroy value TOS 
3b21			 
3b21					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b21 cd 3b 23			call macro_forth_dsp_pop 
3b24				endm 
# End of macro FORTH_DSP_POP
3b24			 
3b24			 
3b24					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b24 cd 83 22			call macro_dsp_valuehl 
3b27				endm 
# End of macro FORTH_DSP_VALUEHL
3b27			 
3b27					; one value on hl get other one back 
3b27			 
3b27 d1					pop de 
3b28			 
3b28					; do the sub 
3b28			;		ex de, hl 
3b28			 
3b28 ed 52				sbc hl,de 
3b2a			 
3b2a					; save it 
3b2a			 
3b2a			;		push hl	 
3b2a			 
3b2a					; 
3b2a			 
3b2a					; destroy value TOS 
3b2a			 
3b2a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b2a cd 3b 23			call macro_forth_dsp_pop 
3b2d				endm 
# End of macro FORTH_DSP_POP
3b2d			 
3b2d					; TODO push value back onto stack for another op etc 
3b2d			 
3b2d			;		pop hl 
3b2d			 
3b2d cd 8c 20				call forth_push_numhl 
3b30			.neg_done: 
3b30			 
3b30					NEXTW 
3b30 c3 39 24			jp macro_next 
3b33				endm 
# End of macro NEXTW
3b33			.DIV: 
3b33				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3b33 18				db WORD_SYS_CORE+4             
3b34 80 3b			dw .MUL            
3b36 02				db 1 + 1 
3b37 .. 00			db "/",0              
3b39				endm 
# End of macro CWHEAD
3b39			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3b39					if DEBUG_FORTH_WORDS_KEY 
3b39						DMARK "DIV" 
3b39 f5				push af  
3b3a 3a 4e 3b			ld a, (.dmark)  
3b3d 32 6e fe			ld (debug_mark),a  
3b40 3a 4f 3b			ld a, (.dmark+1)  
3b43 32 6f fe			ld (debug_mark+1),a  
3b46 3a 50 3b			ld a, (.dmark+2)  
3b49 32 70 fe			ld (debug_mark+2),a  
3b4c 18 03			jr .pastdmark  
3b4e ..			.dmark: db "DIV"  
3b51 f1			.pastdmark: pop af  
3b52			endm  
# End of macro DMARK
3b52						CALLMONITOR 
3b52 cd c1 19			call break_point_state  
3b55				endm  
# End of macro CALLMONITOR
3b55					endif 
3b55				; TODO add floating point number detection 
3b55					; v5 FORTH_DSP_VALUE 
3b55					FORTH_DSP 
3b55 cd 49 22			call macro_forth_dsp 
3b58				endm 
# End of macro FORTH_DSP
3b58 7e					ld a,(hl)	; get type of value on TOS 
3b59 fe 02				cp DS_TYPE_INUM  
3b5b 28 03				jr z, .div_inum 
3b5d			 
3b5d				if FORTH_ENABLE_FLOATMATH 
3b5d					jr .div_done 
3b5d			 
3b5d				endif 
3b5d					NEXTW 
3b5d c3 39 24			jp macro_next 
3b60				endm 
# End of macro NEXTW
3b60			.div_inum: 
3b60			 
3b60					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b60 cd 83 22			call macro_dsp_valuehl 
3b63				endm 
# End of macro FORTH_DSP_VALUEHL
3b63			 
3b63 e5					push hl    ; to go to bc 
3b64			 
3b64					; destroy value TOS 
3b64			 
3b64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b64 cd 3b 23			call macro_forth_dsp_pop 
3b67				endm 
# End of macro FORTH_DSP_POP
3b67			 
3b67			 
3b67					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b67 cd 83 22			call macro_dsp_valuehl 
3b6a				endm 
# End of macro FORTH_DSP_VALUEHL
3b6a			 
3b6a					; hl to go to de 
3b6a			 
3b6a e5					push hl 
3b6b			 
3b6b c1					pop bc 
3b6c d1					pop de		 
3b6d			 
3b6d			 
3b6d					if DEBUG_FORTH_MATHS 
3b6d						DMARK "DIV" 
3b6d				CALLMONITOR 
3b6d					endif 
3b6d					; one value on hl but move to a get other one back 
3b6d			 
3b6d			        
3b6d cd a9 0e			call Div16 
3b70			 
3b70			;	push af	 
3b70 e5				push hl 
3b71 c5				push bc 
3b72			 
3b72					if DEBUG_FORTH_MATHS 
3b72						DMARK "DI1" 
3b72				CALLMONITOR 
3b72					endif 
3b72			 
3b72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b72 cd 3b 23			call macro_forth_dsp_pop 
3b75				endm 
# End of macro FORTH_DSP_POP
3b75			 
3b75			 
3b75			 
3b75 e1					pop hl    ; result 
3b76			 
3b76 cd 8c 20				call forth_push_numhl 
3b79			 
3b79 e1					pop hl    ; reminder 
3b7a			;		ld h,0 
3b7a			;		ld l,d 
3b7a			 
3b7a cd 8c 20				call forth_push_numhl 
3b7d			.div_done: 
3b7d					NEXTW 
3b7d c3 39 24			jp macro_next 
3b80				endm 
# End of macro NEXTW
3b80			.MUL: 
3b80				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3b80 19				db WORD_SYS_CORE+5             
3b81 c5 3b			dw .MIN            
3b83 02				db 1 + 1 
3b84 .. 00			db "*",0              
3b86				endm 
# End of macro CWHEAD
3b86			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3b86				; TODO add floating point number detection 
3b86					if DEBUG_FORTH_WORDS_KEY 
3b86						DMARK "MUL" 
3b86 f5				push af  
3b87 3a 9b 3b			ld a, (.dmark)  
3b8a 32 6e fe			ld (debug_mark),a  
3b8d 3a 9c 3b			ld a, (.dmark+1)  
3b90 32 6f fe			ld (debug_mark+1),a  
3b93 3a 9d 3b			ld a, (.dmark+2)  
3b96 32 70 fe			ld (debug_mark+2),a  
3b99 18 03			jr .pastdmark  
3b9b ..			.dmark: db "MUL"  
3b9e f1			.pastdmark: pop af  
3b9f			endm  
# End of macro DMARK
3b9f						CALLMONITOR 
3b9f cd c1 19			call break_point_state  
3ba2				endm  
# End of macro CALLMONITOR
3ba2					endif 
3ba2					FORTH_DSP 
3ba2 cd 49 22			call macro_forth_dsp 
3ba5				endm 
# End of macro FORTH_DSP
3ba5					; v5 FORTH_DSP_VALUE 
3ba5 7e					ld a,(hl)	; get type of value on TOS 
3ba6 fe 02				cp DS_TYPE_INUM  
3ba8 28 03				jr z, .mul_inum 
3baa			 
3baa				if FORTH_ENABLE_FLOATMATH 
3baa					jr .mul_done 
3baa			 
3baa				endif 
3baa			 
3baa					NEXTW 
3baa c3 39 24			jp macro_next 
3bad				endm 
# End of macro NEXTW
3bad			.mul_inum:	 
3bad			 
3bad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bad cd 83 22			call macro_dsp_valuehl 
3bb0				endm 
# End of macro FORTH_DSP_VALUEHL
3bb0			 
3bb0 e5					push hl 
3bb1			 
3bb1					; destroy value TOS 
3bb1			 
3bb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb1 cd 3b 23			call macro_forth_dsp_pop 
3bb4				endm 
# End of macro FORTH_DSP_POP
3bb4			 
3bb4			 
3bb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bb4 cd 83 22			call macro_dsp_valuehl 
3bb7				endm 
# End of macro FORTH_DSP_VALUEHL
3bb7			 
3bb7					; one value on hl but move to a get other one back 
3bb7			 
3bb7 7d					ld a, l 
3bb8			 
3bb8 d1					pop de 
3bb9			 
3bb9					; do the mull 
3bb9			;		ex de, hl 
3bb9			 
3bb9 cd cf 0e				call Mult16 
3bbc					; save it 
3bbc			 
3bbc			;		push hl	 
3bbc			 
3bbc					; 
3bbc			 
3bbc					; destroy value TOS 
3bbc			 
3bbc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bbc cd 3b 23			call macro_forth_dsp_pop 
3bbf				endm 
# End of macro FORTH_DSP_POP
3bbf			 
3bbf					; TODO push value back onto stack for another op etc 
3bbf			 
3bbf			;		pop hl 
3bbf			 
3bbf cd 8c 20				call forth_push_numhl 
3bc2			 
3bc2			.mul_done: 
3bc2					NEXTW 
3bc2 c3 39 24			jp macro_next 
3bc5				endm 
# End of macro NEXTW
3bc5			 
3bc5			 
3bc5			 
3bc5			 
3bc5			.MIN: 
3bc5				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3bc5 49				db WORD_SYS_CORE+53             
3bc6 46 3c			dw .MAX            
3bc8 04				db 3 + 1 
3bc9 .. 00			db "MIN",0              
3bcd				endm 
# End of macro CWHEAD
3bcd			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3bcd					if DEBUG_FORTH_WORDS_KEY 
3bcd						DMARK "MIN" 
3bcd f5				push af  
3bce 3a e2 3b			ld a, (.dmark)  
3bd1 32 6e fe			ld (debug_mark),a  
3bd4 3a e3 3b			ld a, (.dmark+1)  
3bd7 32 6f fe			ld (debug_mark+1),a  
3bda 3a e4 3b			ld a, (.dmark+2)  
3bdd 32 70 fe			ld (debug_mark+2),a  
3be0 18 03			jr .pastdmark  
3be2 ..			.dmark: db "MIN"  
3be5 f1			.pastdmark: pop af  
3be6			endm  
# End of macro DMARK
3be6						CALLMONITOR 
3be6 cd c1 19			call break_point_state  
3be9				endm  
# End of macro CALLMONITOR
3be9					endif 
3be9					; get u2 
3be9			 
3be9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3be9 cd 83 22			call macro_dsp_valuehl 
3bec				endm 
# End of macro FORTH_DSP_VALUEHL
3bec			 
3bec e5					push hl   ; u2 
3bed			 
3bed					; destroy value TOS 
3bed			 
3bed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bed cd 3b 23			call macro_forth_dsp_pop 
3bf0				endm 
# End of macro FORTH_DSP_POP
3bf0			 
3bf0					; get u1 
3bf0			 
3bf0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf0 cd 83 22			call macro_dsp_valuehl 
3bf3				endm 
# End of macro FORTH_DSP_VALUEHL
3bf3			 
3bf3 e5					push hl  ; u1 
3bf4			 
3bf4					; destroy value TOS 
3bf4			 
3bf4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bf4 cd 3b 23			call macro_forth_dsp_pop 
3bf7				endm 
# End of macro FORTH_DSP_POP
3bf7			 
3bf7 b7			 or a      ;clear carry flag 
3bf8 e1			  pop hl    ; u1 
3bf9 d1			  pop de    ; u2 
3bfa e5				push hl   ; saved in case hl is lowest 
3bfb ed 52		  sbc hl,de 
3bfd 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3bff			 
3bff e1				pop hl 
3c00					if DEBUG_FORTH_WORDS 
3c00						DMARK "MIN" 
3c00 f5				push af  
3c01 3a 15 3c			ld a, (.dmark)  
3c04 32 6e fe			ld (debug_mark),a  
3c07 3a 16 3c			ld a, (.dmark+1)  
3c0a 32 6f fe			ld (debug_mark+1),a  
3c0d 3a 17 3c			ld a, (.dmark+2)  
3c10 32 70 fe			ld (debug_mark+2),a  
3c13 18 03			jr .pastdmark  
3c15 ..			.dmark: db "MIN"  
3c18 f1			.pastdmark: pop af  
3c19			endm  
# End of macro DMARK
3c19						CALLMONITOR 
3c19 cd c1 19			call break_point_state  
3c1c				endm  
# End of macro CALLMONITOR
3c1c					endif 
3c1c cd 8c 20				call forth_push_numhl 
3c1f			 
3c1f				       NEXTW 
3c1f c3 39 24			jp macro_next 
3c22				endm 
# End of macro NEXTW
3c22			 
3c22			.mincont:  
3c22 c1				pop bc   ; tidy up 
3c23 eb				ex de , hl  
3c24					if DEBUG_FORTH_WORDS 
3c24						DMARK "MI1" 
3c24 f5				push af  
3c25 3a 39 3c			ld a, (.dmark)  
3c28 32 6e fe			ld (debug_mark),a  
3c2b 3a 3a 3c			ld a, (.dmark+1)  
3c2e 32 6f fe			ld (debug_mark+1),a  
3c31 3a 3b 3c			ld a, (.dmark+2)  
3c34 32 70 fe			ld (debug_mark+2),a  
3c37 18 03			jr .pastdmark  
3c39 ..			.dmark: db "MI1"  
3c3c f1			.pastdmark: pop af  
3c3d			endm  
# End of macro DMARK
3c3d						CALLMONITOR 
3c3d cd c1 19			call break_point_state  
3c40				endm  
# End of macro CALLMONITOR
3c40					endif 
3c40 cd 8c 20				call forth_push_numhl 
3c43			 
3c43				       NEXTW 
3c43 c3 39 24			jp macro_next 
3c46				endm 
# End of macro NEXTW
3c46			.MAX: 
3c46				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3c46 4a				db WORD_SYS_CORE+54             
3c47 c7 3c			dw .RND16            
3c49 04				db 3 + 1 
3c4a .. 00			db "MAX",0              
3c4e				endm 
# End of macro CWHEAD
3c4e			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3c4e					if DEBUG_FORTH_WORDS_KEY 
3c4e						DMARK "MAX" 
3c4e f5				push af  
3c4f 3a 63 3c			ld a, (.dmark)  
3c52 32 6e fe			ld (debug_mark),a  
3c55 3a 64 3c			ld a, (.dmark+1)  
3c58 32 6f fe			ld (debug_mark+1),a  
3c5b 3a 65 3c			ld a, (.dmark+2)  
3c5e 32 70 fe			ld (debug_mark+2),a  
3c61 18 03			jr .pastdmark  
3c63 ..			.dmark: db "MAX"  
3c66 f1			.pastdmark: pop af  
3c67			endm  
# End of macro DMARK
3c67						CALLMONITOR 
3c67 cd c1 19			call break_point_state  
3c6a				endm  
# End of macro CALLMONITOR
3c6a					endif 
3c6a					; get u2 
3c6a			 
3c6a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c6a cd 83 22			call macro_dsp_valuehl 
3c6d				endm 
# End of macro FORTH_DSP_VALUEHL
3c6d			 
3c6d e5					push hl   ; u2 
3c6e			 
3c6e					; destroy value TOS 
3c6e			 
3c6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c6e cd 3b 23			call macro_forth_dsp_pop 
3c71				endm 
# End of macro FORTH_DSP_POP
3c71			 
3c71					; get u1 
3c71			 
3c71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c71 cd 83 22			call macro_dsp_valuehl 
3c74				endm 
# End of macro FORTH_DSP_VALUEHL
3c74			 
3c74 e5					push hl  ; u1 
3c75			 
3c75					; destroy value TOS 
3c75			 
3c75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c75 cd 3b 23			call macro_forth_dsp_pop 
3c78				endm 
# End of macro FORTH_DSP_POP
3c78			 
3c78 b7			 or a      ;clear carry flag 
3c79 e1			  pop hl    ; u1 
3c7a d1			  pop de    ; u2 
3c7b e5				push hl   ; saved in case hl is lowest 
3c7c ed 52		  sbc hl,de 
3c7e 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3c80			 
3c80 e1				pop hl 
3c81					if DEBUG_FORTH_WORDS 
3c81						DMARK "MAX" 
3c81 f5				push af  
3c82 3a 96 3c			ld a, (.dmark)  
3c85 32 6e fe			ld (debug_mark),a  
3c88 3a 97 3c			ld a, (.dmark+1)  
3c8b 32 6f fe			ld (debug_mark+1),a  
3c8e 3a 98 3c			ld a, (.dmark+2)  
3c91 32 70 fe			ld (debug_mark+2),a  
3c94 18 03			jr .pastdmark  
3c96 ..			.dmark: db "MAX"  
3c99 f1			.pastdmark: pop af  
3c9a			endm  
# End of macro DMARK
3c9a						CALLMONITOR 
3c9a cd c1 19			call break_point_state  
3c9d				endm  
# End of macro CALLMONITOR
3c9d					endif 
3c9d cd 8c 20				call forth_push_numhl 
3ca0			 
3ca0				       NEXTW 
3ca0 c3 39 24			jp macro_next 
3ca3				endm 
# End of macro NEXTW
3ca3			 
3ca3			.maxcont:  
3ca3 c1				pop bc   ; tidy up 
3ca4 eb				ex de , hl  
3ca5					if DEBUG_FORTH_WORDS 
3ca5						DMARK "MA1" 
3ca5 f5				push af  
3ca6 3a ba 3c			ld a, (.dmark)  
3ca9 32 6e fe			ld (debug_mark),a  
3cac 3a bb 3c			ld a, (.dmark+1)  
3caf 32 6f fe			ld (debug_mark+1),a  
3cb2 3a bc 3c			ld a, (.dmark+2)  
3cb5 32 70 fe			ld (debug_mark+2),a  
3cb8 18 03			jr .pastdmark  
3cba ..			.dmark: db "MA1"  
3cbd f1			.pastdmark: pop af  
3cbe			endm  
# End of macro DMARK
3cbe						CALLMONITOR 
3cbe cd c1 19			call break_point_state  
3cc1				endm  
# End of macro CALLMONITOR
3cc1					endif 
3cc1 cd 8c 20				call forth_push_numhl 
3cc4				       NEXTW 
3cc4 c3 39 24			jp macro_next 
3cc7				endm 
# End of macro NEXTW
3cc7			 
3cc7			.RND16: 
3cc7				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3cc7 4e				db WORD_SYS_CORE+58             
3cc8 f6 3c			dw .RND8            
3cca 06				db 5 + 1 
3ccb .. 00			db "RND16",0              
3cd1				endm 
# End of macro CWHEAD
3cd1			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3cd1					if DEBUG_FORTH_WORDS_KEY 
3cd1						DMARK "R16" 
3cd1 f5				push af  
3cd2 3a e6 3c			ld a, (.dmark)  
3cd5 32 6e fe			ld (debug_mark),a  
3cd8 3a e7 3c			ld a, (.dmark+1)  
3cdb 32 6f fe			ld (debug_mark+1),a  
3cde 3a e8 3c			ld a, (.dmark+2)  
3ce1 32 70 fe			ld (debug_mark+2),a  
3ce4 18 03			jr .pastdmark  
3ce6 ..			.dmark: db "R16"  
3ce9 f1			.pastdmark: pop af  
3cea			endm  
# End of macro DMARK
3cea						CALLMONITOR 
3cea cd c1 19			call break_point_state  
3ced				endm  
# End of macro CALLMONITOR
3ced					endif 
3ced cd 73 0e				call prng16  
3cf0 cd 8c 20				call forth_push_numhl 
3cf3				       NEXTW 
3cf3 c3 39 24			jp macro_next 
3cf6				endm 
# End of macro NEXTW
3cf6			.RND8: 
3cf6				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3cf6 60				db WORD_SYS_CORE+76             
3cf7 2b 3d			dw .RND            
3cf9 05				db 4 + 1 
3cfa .. 00			db "RND8",0              
3cff				endm 
# End of macro CWHEAD
3cff			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3cff					if DEBUG_FORTH_WORDS_KEY 
3cff						DMARK "RN8" 
3cff f5				push af  
3d00 3a 14 3d			ld a, (.dmark)  
3d03 32 6e fe			ld (debug_mark),a  
3d06 3a 15 3d			ld a, (.dmark+1)  
3d09 32 6f fe			ld (debug_mark+1),a  
3d0c 3a 16 3d			ld a, (.dmark+2)  
3d0f 32 70 fe			ld (debug_mark+2),a  
3d12 18 03			jr .pastdmark  
3d14 ..			.dmark: db "RN8"  
3d17 f1			.pastdmark: pop af  
3d18			endm  
# End of macro DMARK
3d18						CALLMONITOR 
3d18 cd c1 19			call break_point_state  
3d1b				endm  
# End of macro CALLMONITOR
3d1b					endif 
3d1b 2a af fb				ld hl,(xrandc) 
3d1e 23					inc hl 
3d1f cd 8d 0e				call xrnd 
3d22 6f					ld l,a	 
3d23 26 00				ld h,0 
3d25 cd 8c 20				call forth_push_numhl 
3d28				       NEXTW 
3d28 c3 39 24			jp macro_next 
3d2b				endm 
# End of macro NEXTW
3d2b			.RND: 
3d2b				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3d2b 60				db WORD_SYS_CORE+76             
3d2c 31 3e			dw .ENDMATHS            
3d2e 04				db 3 + 1 
3d2f .. 00			db "RND",0              
3d33				endm 
# End of macro CWHEAD
3d33			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3d33			 
3d33					if DEBUG_FORTH_WORDS_KEY 
3d33						DMARK "RND" 
3d33 f5				push af  
3d34 3a 48 3d			ld a, (.dmark)  
3d37 32 6e fe			ld (debug_mark),a  
3d3a 3a 49 3d			ld a, (.dmark+1)  
3d3d 32 6f fe			ld (debug_mark+1),a  
3d40 3a 4a 3d			ld a, (.dmark+2)  
3d43 32 70 fe			ld (debug_mark+2),a  
3d46 18 03			jr .pastdmark  
3d48 ..			.dmark: db "RND"  
3d4b f1			.pastdmark: pop af  
3d4c			endm  
# End of macro DMARK
3d4c						CALLMONITOR 
3d4c cd c1 19			call break_point_state  
3d4f				endm  
# End of macro CALLMONITOR
3d4f					endif 
3d4f					 
3d4f					FORTH_DSP_VALUEHL    ; upper range 
3d4f cd 83 22			call macro_dsp_valuehl 
3d52				endm 
# End of macro FORTH_DSP_VALUEHL
3d52			 
3d52 22 b3 fb				ld (LFSRSeed), hl	 
3d55			 
3d55					if DEBUG_FORTH_WORDS 
3d55						DMARK "RN1" 
3d55 f5				push af  
3d56 3a 6a 3d			ld a, (.dmark)  
3d59 32 6e fe			ld (debug_mark),a  
3d5c 3a 6b 3d			ld a, (.dmark+1)  
3d5f 32 6f fe			ld (debug_mark+1),a  
3d62 3a 6c 3d			ld a, (.dmark+2)  
3d65 32 70 fe			ld (debug_mark+2),a  
3d68 18 03			jr .pastdmark  
3d6a ..			.dmark: db "RN1"  
3d6d f1			.pastdmark: pop af  
3d6e			endm  
# End of macro DMARK
3d6e						CALLMONITOR 
3d6e cd c1 19			call break_point_state  
3d71				endm  
# End of macro CALLMONITOR
3d71					endif 
3d71					FORTH_DSP_POP 
3d71 cd 3b 23			call macro_forth_dsp_pop 
3d74				endm 
# End of macro FORTH_DSP_POP
3d74			 
3d74					FORTH_DSP_VALUEHL    ; low range 
3d74 cd 83 22			call macro_dsp_valuehl 
3d77				endm 
# End of macro FORTH_DSP_VALUEHL
3d77			 
3d77					if DEBUG_FORTH_WORDS 
3d77						DMARK "RN2" 
3d77 f5				push af  
3d78 3a 8c 3d			ld a, (.dmark)  
3d7b 32 6e fe			ld (debug_mark),a  
3d7e 3a 8d 3d			ld a, (.dmark+1)  
3d81 32 6f fe			ld (debug_mark+1),a  
3d84 3a 8e 3d			ld a, (.dmark+2)  
3d87 32 70 fe			ld (debug_mark+2),a  
3d8a 18 03			jr .pastdmark  
3d8c ..			.dmark: db "RN2"  
3d8f f1			.pastdmark: pop af  
3d90			endm  
# End of macro DMARK
3d90						CALLMONITOR 
3d90 cd c1 19			call break_point_state  
3d93				endm  
# End of macro CALLMONITOR
3d93					endif 
3d93 22 b5 fb				ld (LFSRSeed+2), hl 
3d96			 
3d96					FORTH_DSP_POP 
3d96 cd 3b 23			call macro_forth_dsp_pop 
3d99				endm 
# End of macro FORTH_DSP_POP
3d99			 
3d99 e5					push hl 
3d9a			 
3d9a e1			.inrange:	pop hl 
3d9b cd 73 0e				call prng16  
3d9e					if DEBUG_FORTH_WORDS 
3d9e						DMARK "RN3" 
3d9e f5				push af  
3d9f 3a b3 3d			ld a, (.dmark)  
3da2 32 6e fe			ld (debug_mark),a  
3da5 3a b4 3d			ld a, (.dmark+1)  
3da8 32 6f fe			ld (debug_mark+1),a  
3dab 3a b5 3d			ld a, (.dmark+2)  
3dae 32 70 fe			ld (debug_mark+2),a  
3db1 18 03			jr .pastdmark  
3db3 ..			.dmark: db "RN3"  
3db6 f1			.pastdmark: pop af  
3db7			endm  
# End of macro DMARK
3db7						CALLMONITOR 
3db7 cd c1 19			call break_point_state  
3dba				endm  
# End of macro CALLMONITOR
3dba					endif 
3dba					 
3dba					; if the range is 8bit knock out the high byte 
3dba			 
3dba ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3dbe			 
3dbe 3e 00				ld a, 0 
3dc0 ba					cp d  
3dc1 20 1e				jr nz, .hirange 
3dc3 26 00				ld h, 0   ; knock it down to 8bit 
3dc5			 
3dc5					if DEBUG_FORTH_WORDS 
3dc5						DMARK "RNk" 
3dc5 f5				push af  
3dc6 3a da 3d			ld a, (.dmark)  
3dc9 32 6e fe			ld (debug_mark),a  
3dcc 3a db 3d			ld a, (.dmark+1)  
3dcf 32 6f fe			ld (debug_mark+1),a  
3dd2 3a dc 3d			ld a, (.dmark+2)  
3dd5 32 70 fe			ld (debug_mark+2),a  
3dd8 18 03			jr .pastdmark  
3dda ..			.dmark: db "RNk"  
3ddd f1			.pastdmark: pop af  
3dde			endm  
# End of macro DMARK
3dde						CALLMONITOR 
3dde cd c1 19			call break_point_state  
3de1				endm  
# End of macro CALLMONITOR
3de1					endif 
3de1			.hirange:   
3de1 e5					push hl  
3de2 b7					or a  
3de3 ed 52		                sbc hl, de 
3de5			 
3de5					;call cmp16 
3de5			 
3de5 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3de7 e1					pop hl 
3de8 e5					push hl 
3de9			 
3de9					if DEBUG_FORTH_WORDS 
3de9						DMARK "RN4" 
3de9 f5				push af  
3dea 3a fe 3d			ld a, (.dmark)  
3ded 32 6e fe			ld (debug_mark),a  
3df0 3a ff 3d			ld a, (.dmark+1)  
3df3 32 6f fe			ld (debug_mark+1),a  
3df6 3a 00 3e			ld a, (.dmark+2)  
3df9 32 70 fe			ld (debug_mark+2),a  
3dfc 18 03			jr .pastdmark  
3dfe ..			.dmark: db "RN4"  
3e01 f1			.pastdmark: pop af  
3e02			endm  
# End of macro DMARK
3e02						CALLMONITOR 
3e02 cd c1 19			call break_point_state  
3e05				endm  
# End of macro CALLMONITOR
3e05					endif 
3e05 ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3e09					;call cmp16 
3e09				 
3e09 b7					or a  
3e0a ed 52		                sbc hl, de 
3e0c 38 8c				jr c, .inrange 
3e0e			 
3e0e e1					pop hl 
3e0f					 
3e0f					if DEBUG_FORTH_WORDS 
3e0f						DMARK "RNd" 
3e0f f5				push af  
3e10 3a 24 3e			ld a, (.dmark)  
3e13 32 6e fe			ld (debug_mark),a  
3e16 3a 25 3e			ld a, (.dmark+1)  
3e19 32 6f fe			ld (debug_mark+1),a  
3e1c 3a 26 3e			ld a, (.dmark+2)  
3e1f 32 70 fe			ld (debug_mark+2),a  
3e22 18 03			jr .pastdmark  
3e24 ..			.dmark: db "RNd"  
3e27 f1			.pastdmark: pop af  
3e28			endm  
# End of macro DMARK
3e28						CALLMONITOR 
3e28 cd c1 19			call break_point_state  
3e2b				endm  
# End of macro CALLMONITOR
3e2b					endif 
3e2b			 
3e2b			 
3e2b cd 8c 20				call forth_push_numhl 
3e2e				       NEXTW 
3e2e c3 39 24			jp macro_next 
3e31				endm 
# End of macro NEXTW
3e31			 
3e31			.ENDMATHS: 
3e31			 
3e31			; eof 
3e31			 
# End of file forth_words_maths.asm
3e31			include "forth_words_display.asm" 
3e31			 
3e31			; | ## Display Words 
3e31			 
3e31			.INFO: 
3e31			 
3e31				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3e31 62				db WORD_SYS_CORE+78             
3e32 4e 3e			dw .ATP            
3e34 05				db 4 + 1 
3e35 .. 00			db "INFO",0              
3e3a				endm 
# End of macro CWHEAD
3e3a			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3e3a					FORTH_DSP_VALUEHL 
3e3a cd 83 22			call macro_dsp_valuehl 
3e3d				endm 
# End of macro FORTH_DSP_VALUEHL
3e3d			 
3e3d					FORTH_DSP_POP 
3e3d cd 3b 23			call macro_forth_dsp_pop 
3e40				endm 
# End of macro FORTH_DSP_POP
3e40			 
3e40 e5					push hl 
3e41			 
3e41					FORTH_DSP_VALUEHL 
3e41 cd 83 22			call macro_dsp_valuehl 
3e44				endm 
# End of macro FORTH_DSP_VALUEHL
3e44			 
3e44					FORTH_DSP_POP 
3e44 cd 3b 23			call macro_forth_dsp_pop 
3e47				endm 
# End of macro FORTH_DSP_POP
3e47			 
3e47 d1					pop de 
3e48			 
3e48 cd a9 0c				call info_panel 
3e4b			 
3e4b			 
3e4b					NEXTW 
3e4b c3 39 24			jp macro_next 
3e4e				endm 
# End of macro NEXTW
3e4e			.ATP: 
3e4e				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3e4e 62				db WORD_SYS_CORE+78             
3e4f c5 3e			dw .FB            
3e51 04				db 3 + 1 
3e52 .. 00			db "AT?",0              
3e56				endm 
# End of macro CWHEAD
3e56			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3e56					if DEBUG_FORTH_WORDS_KEY 
3e56						DMARK "AT?" 
3e56 f5				push af  
3e57 3a 6b 3e			ld a, (.dmark)  
3e5a 32 6e fe			ld (debug_mark),a  
3e5d 3a 6c 3e			ld a, (.dmark+1)  
3e60 32 6f fe			ld (debug_mark+1),a  
3e63 3a 6d 3e			ld a, (.dmark+2)  
3e66 32 70 fe			ld (debug_mark+2),a  
3e69 18 03			jr .pastdmark  
3e6b ..			.dmark: db "AT?"  
3e6e f1			.pastdmark: pop af  
3e6f			endm  
# End of macro DMARK
3e6f						CALLMONITOR 
3e6f cd c1 19			call break_point_state  
3e72				endm  
# End of macro CALLMONITOR
3e72					endif 
3e72 3a 65 fa				ld a, (f_cursor_ptr) 
3e75			 
3e75			if DEBUG_FORTH_WORDS 
3e75				DMARK "AT?" 
3e75 f5				push af  
3e76 3a 8a 3e			ld a, (.dmark)  
3e79 32 6e fe			ld (debug_mark),a  
3e7c 3a 8b 3e			ld a, (.dmark+1)  
3e7f 32 6f fe			ld (debug_mark+1),a  
3e82 3a 8c 3e			ld a, (.dmark+2)  
3e85 32 70 fe			ld (debug_mark+2),a  
3e88 18 03			jr .pastdmark  
3e8a ..			.dmark: db "AT?"  
3e8d f1			.pastdmark: pop af  
3e8e			endm  
# End of macro DMARK
3e8e				CALLMONITOR 
3e8e cd c1 19			call break_point_state  
3e91				endm  
# End of macro CALLMONITOR
3e91			endif	 
3e91					; count the number of rows 
3e91			 
3e91 06 00				ld b, 0 
3e93 4f			.atpr:		ld c, a    ; save in case we go below zero 
3e94 d6 28				sub display_cols 
3e96 f2 9c 3e				jp p, .atprunder 
3e99 04					inc b 
3e9a 18 f7				jr .atpr 
3e9c			.atprunder:	 
3e9c			if DEBUG_FORTH_WORDS 
3e9c				DMARK "A?2" 
3e9c f5				push af  
3e9d 3a b1 3e			ld a, (.dmark)  
3ea0 32 6e fe			ld (debug_mark),a  
3ea3 3a b2 3e			ld a, (.dmark+1)  
3ea6 32 6f fe			ld (debug_mark+1),a  
3ea9 3a b3 3e			ld a, (.dmark+2)  
3eac 32 70 fe			ld (debug_mark+2),a  
3eaf 18 03			jr .pastdmark  
3eb1 ..			.dmark: db "A?2"  
3eb4 f1			.pastdmark: pop af  
3eb5			endm  
# End of macro DMARK
3eb5				CALLMONITOR 
3eb5 cd c1 19			call break_point_state  
3eb8				endm  
# End of macro CALLMONITOR
3eb8			endif	 
3eb8 26 00				ld h, 0 
3eba 69					ld l, c 
3ebb cd 8c 20				call forth_push_numhl 
3ebe 68					ld l, b  
3ebf cd 8c 20				call forth_push_numhl 
3ec2			 
3ec2			 
3ec2				NEXTW 
3ec2 c3 39 24			jp macro_next 
3ec5				endm 
# End of macro NEXTW
3ec5			 
3ec5			.FB: 
3ec5				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ec5 1b				db WORD_SYS_CORE+7             
3ec6 13 3f			dw .EMIT            
3ec8 03				db 2 + 1 
3ec9 .. 00			db "FB",0              
3ecc				endm 
# End of macro CWHEAD
3ecc			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ecc			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ecc			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ecc			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ecc					if DEBUG_FORTH_WORDS_KEY 
3ecc						DMARK "FB." 
3ecc f5				push af  
3ecd 3a e1 3e			ld a, (.dmark)  
3ed0 32 6e fe			ld (debug_mark),a  
3ed3 3a e2 3e			ld a, (.dmark+1)  
3ed6 32 6f fe			ld (debug_mark+1),a  
3ed9 3a e3 3e			ld a, (.dmark+2)  
3edc 32 70 fe			ld (debug_mark+2),a  
3edf 18 03			jr .pastdmark  
3ee1 ..			.dmark: db "FB."  
3ee4 f1			.pastdmark: pop af  
3ee5			endm  
# End of macro DMARK
3ee5						CALLMONITOR 
3ee5 cd c1 19			call break_point_state  
3ee8				endm  
# End of macro CALLMONITOR
3ee8					endif 
3ee8			 
3ee8					FORTH_DSP_VALUEHL 
3ee8 cd 83 22			call macro_dsp_valuehl 
3eeb				endm 
# End of macro FORTH_DSP_VALUEHL
3eeb			 
3eeb 7d					ld a, l 
3eec fe 01				cp 1 
3eee 20 05				jr nz, .fbn1 
3ef0 21 13 fd				ld hl, display_fb1 
3ef3 18 15				jr .fbset 
3ef5 fe 02		.fbn1:		cp 2 
3ef7 20 05				jr nz, .fbn2 
3ef9 21 d1 fb				ld hl, display_fb2 
3efc 18 0c				jr .fbset 
3efe fe 03		.fbn2:		cp 3 
3f00 20 05				jr nz, .fbn3 
3f02 21 72 fc				ld hl, display_fb3 
3f05 18 03				jr .fbset 
3f07			.fbn3:		 ; if invalid number select first 
3f07 21 13 fd				ld hl, display_fb1 
3f0a 22 cf fb		.fbset:		ld (display_fb_active), hl 
3f0d			 
3f0d					FORTH_DSP_POP 
3f0d cd 3b 23			call macro_forth_dsp_pop 
3f10				endm 
# End of macro FORTH_DSP_POP
3f10			 
3f10					NEXTW 
3f10 c3 39 24			jp macro_next 
3f13				endm 
# End of macro NEXTW
3f13			 
3f13			 
3f13			.EMIT: 
3f13				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3f13 1b				db WORD_SYS_CORE+7             
3f14 64 3f			dw .DOTH            
3f16 05				db 4 + 1 
3f17 .. 00			db "EMIT",0              
3f1c				endm 
# End of macro CWHEAD
3f1c			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3f1c					; get value off TOS and display it 
3f1c			 
3f1c					if DEBUG_FORTH_WORDS_KEY 
3f1c						DMARK "EMT" 
3f1c f5				push af  
3f1d 3a 31 3f			ld a, (.dmark)  
3f20 32 6e fe			ld (debug_mark),a  
3f23 3a 32 3f			ld a, (.dmark+1)  
3f26 32 6f fe			ld (debug_mark+1),a  
3f29 3a 33 3f			ld a, (.dmark+2)  
3f2c 32 70 fe			ld (debug_mark+2),a  
3f2f 18 03			jr .pastdmark  
3f31 ..			.dmark: db "EMT"  
3f34 f1			.pastdmark: pop af  
3f35			endm  
# End of macro DMARK
3f35						CALLMONITOR 
3f35 cd c1 19			call break_point_state  
3f38				endm  
# End of macro CALLMONITOR
3f38					endif 
3f38			 
3f38					FORTH_DSP_VALUEHL 
3f38 cd 83 22			call macro_dsp_valuehl 
3f3b				endm 
# End of macro FORTH_DSP_VALUEHL
3f3b			 
3f3b 7d					ld a,l 
3f3c			 
3f3c					; TODO write to display 
3f3c			 
3f3c 32 c6 f3				ld (os_input), a 
3f3f 3e 00				ld a, 0 
3f41 32 c7 f3				ld (os_input+1), a 
3f44					 
3f44 3a 65 fa				ld a, (f_cursor_ptr) 
3f47 11 c6 f3				ld de, os_input 
3f4a cd 2b 0d				call str_at_display 
3f4d			 
3f4d			 
3f4d 3a 43 fa				ld a,(cli_autodisplay) 
3f50 fe 00				cp 0 
3f52 28 03				jr z, .enoupdate 
3f54 cd 3b 0d						call update_display 
3f57					.enoupdate: 
3f57			 
3f57 3a 65 fa				ld a, (f_cursor_ptr) 
3f5a 3c					inc a 
3f5b 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
3f5e			 
3f5e			 
3f5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f5e cd 3b 23			call macro_forth_dsp_pop 
3f61				endm 
# End of macro FORTH_DSP_POP
3f61			  
3f61			 
3f61					NEXTW 
3f61 c3 39 24			jp macro_next 
3f64				endm 
# End of macro NEXTW
3f64			.DOTH: 
3f64				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3f64 1c				db WORD_SYS_CORE+8             
3f65 94 3f			dw .DOTF            
3f67 03				db 2 + 1 
3f68 .. 00			db ".-",0              
3f6b				endm 
# End of macro CWHEAD
3f6b			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3f6b					; get value off TOS and display it 
3f6b					if DEBUG_FORTH_WORDS_KEY 
3f6b						DMARK "DTD" 
3f6b f5				push af  
3f6c 3a 80 3f			ld a, (.dmark)  
3f6f 32 6e fe			ld (debug_mark),a  
3f72 3a 81 3f			ld a, (.dmark+1)  
3f75 32 6f fe			ld (debug_mark+1),a  
3f78 3a 82 3f			ld a, (.dmark+2)  
3f7b 32 70 fe			ld (debug_mark+2),a  
3f7e 18 03			jr .pastdmark  
3f80 ..			.dmark: db "DTD"  
3f83 f1			.pastdmark: pop af  
3f84			endm  
# End of macro DMARK
3f84						CALLMONITOR 
3f84 cd c1 19			call break_point_state  
3f87				endm  
# End of macro CALLMONITOR
3f87					endif 
3f87 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3f89 3e 00			ld a, 0 
3f8b 32 44 fa			ld (cli_mvdot), a 
3f8e c3 eb 3f			jp .dotgo 
3f91				NEXTW 
3f91 c3 39 24			jp macro_next 
3f94				endm 
# End of macro NEXTW
3f94			.DOTF: 
3f94				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3f94 1c				db WORD_SYS_CORE+8             
3f95 c2 3f			dw .DOT            
3f97 03				db 2 + 1 
3f98 .. 00			db ".>",0              
3f9b				endm 
# End of macro CWHEAD
3f9b			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3f9b					; get value off TOS and display it 
3f9b			        ; TODO BUG adds extra spaces 
3f9b			        ; TODO BUG handle numerics? 
3f9b					if DEBUG_FORTH_WORDS_KEY 
3f9b						DMARK "DTC" 
3f9b f5				push af  
3f9c 3a b0 3f			ld a, (.dmark)  
3f9f 32 6e fe			ld (debug_mark),a  
3fa2 3a b1 3f			ld a, (.dmark+1)  
3fa5 32 6f fe			ld (debug_mark+1),a  
3fa8 3a b2 3f			ld a, (.dmark+2)  
3fab 32 70 fe			ld (debug_mark+2),a  
3fae 18 03			jr .pastdmark  
3fb0 ..			.dmark: db "DTC"  
3fb3 f1			.pastdmark: pop af  
3fb4			endm  
# End of macro DMARK
3fb4						CALLMONITOR 
3fb4 cd c1 19			call break_point_state  
3fb7				endm  
# End of macro CALLMONITOR
3fb7					endif 
3fb7 3e 01			ld a, 1 
3fb9 32 44 fa			ld (cli_mvdot), a 
3fbc c3 eb 3f			jp .dotgo 
3fbf				NEXTW 
3fbf c3 39 24			jp macro_next 
3fc2				endm 
# End of macro NEXTW
3fc2			 
3fc2			.DOT: 
3fc2				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3fc2 1c				db WORD_SYS_CORE+8             
3fc3 9e 41			dw .CLS            
3fc5 02				db 1 + 1 
3fc6 .. 00			db ".",0              
3fc8				endm 
# End of macro CWHEAD
3fc8			        ; | . ( u -- ) Display TOS | DONE 
3fc8					; get value off TOS and display it 
3fc8			 
3fc8					if DEBUG_FORTH_WORDS_KEY 
3fc8						DMARK "DOT" 
3fc8 f5				push af  
3fc9 3a dd 3f			ld a, (.dmark)  
3fcc 32 6e fe			ld (debug_mark),a  
3fcf 3a de 3f			ld a, (.dmark+1)  
3fd2 32 6f fe			ld (debug_mark+1),a  
3fd5 3a df 3f			ld a, (.dmark+2)  
3fd8 32 70 fe			ld (debug_mark+2),a  
3fdb 18 03			jr .pastdmark  
3fdd ..			.dmark: db "DOT"  
3fe0 f1			.pastdmark: pop af  
3fe1			endm  
# End of macro DMARK
3fe1						CALLMONITOR 
3fe1 cd c1 19			call break_point_state  
3fe4				endm  
# End of macro CALLMONITOR
3fe4					endif 
3fe4 3e 00			ld a, 0 
3fe6 32 44 fa			ld (cli_mvdot), a 
3fe9 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3feb				 
3feb			 
3feb			.dotgo: 
3feb			 
3feb			; move up type to on stack for parserv5 
3feb					FORTH_DSP 
3feb cd 49 22			call macro_forth_dsp 
3fee				endm 
# End of macro FORTH_DSP
3fee				;FORTH_DSP_VALUE  
3fee			 
3fee			if DEBUG_FORTH_DOT 
3fee				DMARK "DOT" 
3fee f5				push af  
3fef 3a 03 40			ld a, (.dmark)  
3ff2 32 6e fe			ld (debug_mark),a  
3ff5 3a 04 40			ld a, (.dmark+1)  
3ff8 32 6f fe			ld (debug_mark+1),a  
3ffb 3a 05 40			ld a, (.dmark+2)  
3ffe 32 70 fe			ld (debug_mark+2),a  
4001 18 03			jr .pastdmark  
4003 ..			.dmark: db "DOT"  
4006 f1			.pastdmark: pop af  
4007			endm  
# End of macro DMARK
4007				CALLMONITOR 
4007 cd c1 19			call break_point_state  
400a				endm  
# End of macro CALLMONITOR
400a			endif	 
400a			;		.print: 
400a			 
400a 7e				ld a,(hl)  ; work out what type of value is on the TOS 
400b 23				inc hl   ; position to the actual value 
400c fe 01			cp DS_TYPE_STR 
400e 20 06			jr nz, .dotnum1  
4010			 
4010			; display string 
4010				FORTH_DSP_VALUE  
4010 cd 6c 22			call macro_forth_dsp_value 
4013				endm 
# End of macro FORTH_DSP_VALUE
4013 eb				ex de,hl 
4014 18 49			jr .dotwrite 
4016			 
4016			.dotnum1: 
4016 fe 02			cp DS_TYPE_INUM 
4018 20 44			jr nz, .dotflot 
401a			 
401a			 
401a			; display number 
401a			 
401a			;	push hl 
401a			;	call clear_display 
401a			;	pop hl 
401a			 
401a 5e				ld e, (hl) 
401b 23				inc hl 
401c 56				ld d, (hl) 
401d 21 c8 f1			ld hl, scratch 
4020			if DEBUG_FORTH_DOT 
4020				DMARK "DT1" 
4020 f5				push af  
4021 3a 35 40			ld a, (.dmark)  
4024 32 6e fe			ld (debug_mark),a  
4027 3a 36 40			ld a, (.dmark+1)  
402a 32 6f fe			ld (debug_mark+1),a  
402d 3a 37 40			ld a, (.dmark+2)  
4030 32 70 fe			ld (debug_mark+2),a  
4033 18 03			jr .pastdmark  
4035 ..			.dmark: db "DT1"  
4038 f1			.pastdmark: pop af  
4039			endm  
# End of macro DMARK
4039				CALLMONITOR 
4039 cd c1 19			call break_point_state  
403c				endm  
# End of macro CALLMONITOR
403c			endif	 
403c			 
403c cd 59 13			call uitoa_16 
403f eb				ex de,hl 
4040			 
4040			if DEBUG_FORTH_DOT 
4040				DMARK "DT2" 
4040 f5				push af  
4041 3a 55 40			ld a, (.dmark)  
4044 32 6e fe			ld (debug_mark),a  
4047 3a 56 40			ld a, (.dmark+1)  
404a 32 6f fe			ld (debug_mark+1),a  
404d 3a 57 40			ld a, (.dmark+2)  
4050 32 70 fe			ld (debug_mark+2),a  
4053 18 03			jr .pastdmark  
4055 ..			.dmark: db "DT2"  
4058 f1			.pastdmark: pop af  
4059			endm  
# End of macro DMARK
4059				CALLMONITOR 
4059 cd c1 19			call break_point_state  
405c				endm  
# End of macro CALLMONITOR
405c			endif	 
405c			 
405c			;	ld de, os_word_scratch 
405c 18 01			jr .dotwrite 
405e			 
405e 00			.dotflot:   nop 
405f			; TODO print floating point number 
405f			 
405f			.dotwrite:		 
405f			 
405f					; if c is set then set all '-' to spaces 
405f					; need to also take into account .>  
405f			 
405f 3e 01				ld a, 1 
4061 b9					cp c 
4062 20 67				jr nz, .nodashswap 
4064			 
4064					; DE has the string to write, working with HL 
4064			 
4064 06 ff				ld b, 255 
4066 d5					push de 
4067 e1					pop hl 
4068			 
4068			if DEBUG_FORTH_DOT 
4068				DMARK "DT-" 
4068 f5				push af  
4069 3a 7d 40			ld a, (.dmark)  
406c 32 6e fe			ld (debug_mark),a  
406f 3a 7e 40			ld a, (.dmark+1)  
4072 32 6f fe			ld (debug_mark+1),a  
4075 3a 7f 40			ld a, (.dmark+2)  
4078 32 70 fe			ld (debug_mark+2),a  
407b 18 03			jr .pastdmark  
407d ..			.dmark: db "DT-"  
4080 f1			.pastdmark: pop af  
4081			endm  
# End of macro DMARK
4081				CALLMONITOR 
4081 cd c1 19			call break_point_state  
4084				endm  
# End of macro CALLMONITOR
4084			endif	 
4084 7e			.dashscan:	ld a, (hl) 
4085 fe 00				cp 0 
4087 28 42				jr z, .nodashswap 
4089 fe 2d				cp '-' 
408b 20 03				jr nz, .dashskip 
408d 3e 20				ld a, ' ' 
408f 77					ld (hl), a 
4090 23			.dashskip:	inc hl 
4091			if DEBUG_FORTH_DOT 
4091				DMARK "D-2" 
4091 f5				push af  
4092 3a a6 40			ld a, (.dmark)  
4095 32 6e fe			ld (debug_mark),a  
4098 3a a7 40			ld a, (.dmark+1)  
409b 32 6f fe			ld (debug_mark+1),a  
409e 3a a8 40			ld a, (.dmark+2)  
40a1 32 70 fe			ld (debug_mark+2),a  
40a4 18 03			jr .pastdmark  
40a6 ..			.dmark: db "D-2"  
40a9 f1			.pastdmark: pop af  
40aa			endm  
# End of macro DMARK
40aa				CALLMONITOR 
40aa cd c1 19			call break_point_state  
40ad				endm  
# End of macro CALLMONITOR
40ad			endif	 
40ad 10 d5				djnz .dashscan 
40af			 
40af			if DEBUG_FORTH_DOT 
40af				DMARK "D-1" 
40af f5				push af  
40b0 3a c4 40			ld a, (.dmark)  
40b3 32 6e fe			ld (debug_mark),a  
40b6 3a c5 40			ld a, (.dmark+1)  
40b9 32 6f fe			ld (debug_mark+1),a  
40bc 3a c6 40			ld a, (.dmark+2)  
40bf 32 70 fe			ld (debug_mark+2),a  
40c2 18 03			jr .pastdmark  
40c4 ..			.dmark: db "D-1"  
40c7 f1			.pastdmark: pop af  
40c8			endm  
# End of macro DMARK
40c8				CALLMONITOR 
40c8 cd c1 19			call break_point_state  
40cb				endm  
# End of macro CALLMONITOR
40cb			endif	 
40cb			 
40cb			.nodashswap: 
40cb			 
40cb			if DEBUG_FORTH_DOT 
40cb				DMARK "D-o" 
40cb f5				push af  
40cc 3a e0 40			ld a, (.dmark)  
40cf 32 6e fe			ld (debug_mark),a  
40d2 3a e1 40			ld a, (.dmark+1)  
40d5 32 6f fe			ld (debug_mark+1),a  
40d8 3a e2 40			ld a, (.dmark+2)  
40db 32 70 fe			ld (debug_mark+2),a  
40de 18 03			jr .pastdmark  
40e0 ..			.dmark: db "D-o"  
40e3 f1			.pastdmark: pop af  
40e4			endm  
# End of macro DMARK
40e4				CALLMONITOR 
40e4 cd c1 19			call break_point_state  
40e7				endm  
# End of macro CALLMONITOR
40e7			endif	 
40e7			 
40e7 d5					push de   ; save string start in case we need to advance print 
40e8			 
40e8 3a 65 fa				ld a, (f_cursor_ptr) 
40eb cd 2b 0d				call str_at_display 
40ee 3a 43 fa				ld a,(cli_autodisplay) 
40f1 fe 00				cp 0 
40f3 28 03				jr z, .noupdate 
40f5 cd 3b 0d						call update_display 
40f8					.noupdate: 
40f8			 
40f8			 
40f8					; see if we need to advance the print position 
40f8			 
40f8 e1					pop hl   ; get back string 
40f9			;		ex de,hl 
40f9			 
40f9 3a 44 fa				ld a, (cli_mvdot) 
40fc			if DEBUG_FORTH_DOT 
40fc			;		ld e,a 
40fc				DMARK "D>1" 
40fc f5				push af  
40fd 3a 11 41			ld a, (.dmark)  
4100 32 6e fe			ld (debug_mark),a  
4103 3a 12 41			ld a, (.dmark+1)  
4106 32 6f fe			ld (debug_mark+1),a  
4109 3a 13 41			ld a, (.dmark+2)  
410c 32 70 fe			ld (debug_mark+2),a  
410f 18 03			jr .pastdmark  
4111 ..			.dmark: db "D>1"  
4114 f1			.pastdmark: pop af  
4115			endm  
# End of macro DMARK
4115				CALLMONITOR 
4115 cd c1 19			call break_point_state  
4118				endm  
# End of macro CALLMONITOR
4118			endif	 
4118 fe 00				cp 0 
411a 28 44				jr z, .noadv 
411c					; yes, lets advance the print position 
411c 3e 00				ld a, 0 
411e cd b5 13				call strlent 
4121			if DEBUG_FORTH_DOT 
4121				DMARK "D-?" 
4121 f5				push af  
4122 3a 36 41			ld a, (.dmark)  
4125 32 6e fe			ld (debug_mark),a  
4128 3a 37 41			ld a, (.dmark+1)  
412b 32 6f fe			ld (debug_mark+1),a  
412e 3a 38 41			ld a, (.dmark+2)  
4131 32 70 fe			ld (debug_mark+2),a  
4134 18 03			jr .pastdmark  
4136 ..			.dmark: db "D-?"  
4139 f1			.pastdmark: pop af  
413a			endm  
# End of macro DMARK
413a				CALLMONITOR 
413a cd c1 19			call break_point_state  
413d				endm  
# End of macro CALLMONITOR
413d			endif	 
413d 3a 65 fa				ld a, (f_cursor_ptr) 
4140 85					add a,l 
4141					;call addatohl 
4141					;ld a, l 
4141 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
4144			 
4144			if DEBUG_FORTH_DOT 
4144				DMARK "D->" 
4144 f5				push af  
4145 3a 59 41			ld a, (.dmark)  
4148 32 6e fe			ld (debug_mark),a  
414b 3a 5a 41			ld a, (.dmark+1)  
414e 32 6f fe			ld (debug_mark+1),a  
4151 3a 5b 41			ld a, (.dmark+2)  
4154 32 70 fe			ld (debug_mark+2),a  
4157 18 03			jr .pastdmark  
4159 ..			.dmark: db "D->"  
415c f1			.pastdmark: pop af  
415d			endm  
# End of macro DMARK
415d				CALLMONITOR 
415d cd c1 19			call break_point_state  
4160				endm  
# End of macro CALLMONITOR
4160			endif	 
4160			 
4160			.noadv:	 
4160			 
4160					if DEBUG_FORTH_DOT_WAIT 
4160							call next_page_prompt 
4160					endif	 
4160			; TODO this pop off the stack causes a crash. i dont know why 
4160			 
4160			 
4160			if DEBUG_FORTH_DOT 
4160				DMARK "DTh" 
4160 f5				push af  
4161 3a 75 41			ld a, (.dmark)  
4164 32 6e fe			ld (debug_mark),a  
4167 3a 76 41			ld a, (.dmark+1)  
416a 32 6f fe			ld (debug_mark+1),a  
416d 3a 77 41			ld a, (.dmark+2)  
4170 32 70 fe			ld (debug_mark+2),a  
4173 18 03			jr .pastdmark  
4175 ..			.dmark: db "DTh"  
4178 f1			.pastdmark: pop af  
4179			endm  
# End of macro DMARK
4179				CALLMONITOR 
4179 cd c1 19			call break_point_state  
417c				endm  
# End of macro CALLMONITOR
417c			endif	 
417c			 
417c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
417c cd 3b 23			call macro_forth_dsp_pop 
417f				endm 
# End of macro FORTH_DSP_POP
417f			 
417f			if DEBUG_FORTH_DOT 
417f				DMARK "DTi" 
417f f5				push af  
4180 3a 94 41			ld a, (.dmark)  
4183 32 6e fe			ld (debug_mark),a  
4186 3a 95 41			ld a, (.dmark+1)  
4189 32 6f fe			ld (debug_mark+1),a  
418c 3a 96 41			ld a, (.dmark+2)  
418f 32 70 fe			ld (debug_mark+2),a  
4192 18 03			jr .pastdmark  
4194 ..			.dmark: db "DTi"  
4197 f1			.pastdmark: pop af  
4198			endm  
# End of macro DMARK
4198				CALLMONITOR 
4198 cd c1 19			call break_point_state  
419b				endm  
# End of macro CALLMONITOR
419b			endif	 
419b			 
419b			 
419b					NEXTW 
419b c3 39 24			jp macro_next 
419e				endm 
# End of macro NEXTW
419e			 
419e			.CLS: 
419e				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
419e 35				db WORD_SYS_CORE+33             
419f cb 41			dw .DRAW            
41a1 04				db 3 + 1 
41a2 .. 00			db "CLS",0              
41a6				endm 
# End of macro CWHEAD
41a6			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
41a6					if DEBUG_FORTH_WORDS_KEY 
41a6						DMARK "CLS" 
41a6 f5				push af  
41a7 3a bb 41			ld a, (.dmark)  
41aa 32 6e fe			ld (debug_mark),a  
41ad 3a bc 41			ld a, (.dmark+1)  
41b0 32 6f fe			ld (debug_mark+1),a  
41b3 3a bd 41			ld a, (.dmark+2)  
41b6 32 70 fe			ld (debug_mark+2),a  
41b9 18 03			jr .pastdmark  
41bb ..			.dmark: db "CLS"  
41be f1			.pastdmark: pop af  
41bf			endm  
# End of macro DMARK
41bf						CALLMONITOR 
41bf cd c1 19			call break_point_state  
41c2				endm  
# End of macro CALLMONITOR
41c2					endif 
41c2 cd 18 0d				call clear_display 
41c5 c3 d9 42				jp .home		; and home cursor 
41c8					NEXTW 
41c8 c3 39 24			jp macro_next 
41cb				endm 
# End of macro NEXTW
41cb			 
41cb			.DRAW: 
41cb				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
41cb 36				db WORD_SYS_CORE+34             
41cc f6 41			dw .DUMP            
41ce 05				db 4 + 1 
41cf .. 00			db "DRAW",0              
41d4				endm 
# End of macro CWHEAD
41d4			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
41d4					if DEBUG_FORTH_WORDS_KEY 
41d4						DMARK "DRW" 
41d4 f5				push af  
41d5 3a e9 41			ld a, (.dmark)  
41d8 32 6e fe			ld (debug_mark),a  
41db 3a ea 41			ld a, (.dmark+1)  
41de 32 6f fe			ld (debug_mark+1),a  
41e1 3a eb 41			ld a, (.dmark+2)  
41e4 32 70 fe			ld (debug_mark+2),a  
41e7 18 03			jr .pastdmark  
41e9 ..			.dmark: db "DRW"  
41ec f1			.pastdmark: pop af  
41ed			endm  
# End of macro DMARK
41ed						CALLMONITOR 
41ed cd c1 19			call break_point_state  
41f0				endm  
# End of macro CALLMONITOR
41f0					endif 
41f0 cd 3b 0d				call update_display 
41f3					NEXTW 
41f3 c3 39 24			jp macro_next 
41f6				endm 
# End of macro NEXTW
41f6			 
41f6			.DUMP: 
41f6				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
41f6 37				db WORD_SYS_CORE+35             
41f7 2e 42			dw .CDUMP            
41f9 05				db 4 + 1 
41fa .. 00			db "DUMP",0              
41ff				endm 
# End of macro CWHEAD
41ff			; | DUMP ( x -- ) With address x display dump   | DONE 
41ff			; TODO pop address to use off of the stack 
41ff					if DEBUG_FORTH_WORDS_KEY 
41ff						DMARK "DUM" 
41ff f5				push af  
4200 3a 14 42			ld a, (.dmark)  
4203 32 6e fe			ld (debug_mark),a  
4206 3a 15 42			ld a, (.dmark+1)  
4209 32 6f fe			ld (debug_mark+1),a  
420c 3a 16 42			ld a, (.dmark+2)  
420f 32 70 fe			ld (debug_mark+2),a  
4212 18 03			jr .pastdmark  
4214 ..			.dmark: db "DUM"  
4217 f1			.pastdmark: pop af  
4218			endm  
# End of macro DMARK
4218						CALLMONITOR 
4218 cd c1 19			call break_point_state  
421b				endm  
# End of macro CALLMONITOR
421b					endif 
421b cd 18 0d				call clear_display 
421e			 
421e					; get address 
421e			 
421e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
421e cd 83 22			call macro_dsp_valuehl 
4221				endm 
# End of macro FORTH_DSP_VALUEHL
4221				 
4221					; save it for cdump 
4221			 
4221 22 eb f4				ld (os_cur_ptr),hl 
4224			 
4224					; destroy value TOS 
4224			 
4224					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4224 cd 3b 23			call macro_forth_dsp_pop 
4227				endm 
# End of macro FORTH_DSP_POP
4227			 
4227 cd 0c 1f				call dumpcont	; skip old style of param parsing	 
422a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
422b					NEXTW 
422b c3 39 24			jp macro_next 
422e				endm 
# End of macro NEXTW
422e			.CDUMP: 
422e				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
422e 38				db WORD_SYS_CORE+36             
422f 5e 42			dw .DAT            
4231 06				db 5 + 1 
4232 .. 00			db "CDUMP",0              
4238				endm 
# End of macro CWHEAD
4238			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4238					if DEBUG_FORTH_WORDS_KEY 
4238						DMARK "CDP" 
4238 f5				push af  
4239 3a 4d 42			ld a, (.dmark)  
423c 32 6e fe			ld (debug_mark),a  
423f 3a 4e 42			ld a, (.dmark+1)  
4242 32 6f fe			ld (debug_mark+1),a  
4245 3a 4f 42			ld a, (.dmark+2)  
4248 32 70 fe			ld (debug_mark+2),a  
424b 18 03			jr .pastdmark  
424d ..			.dmark: db "CDP"  
4250 f1			.pastdmark: pop af  
4251			endm  
# End of macro DMARK
4251						CALLMONITOR 
4251 cd c1 19			call break_point_state  
4254				endm  
# End of macro CALLMONITOR
4254					endif 
4254 cd 18 0d				call clear_display 
4257 cd 0c 1f				call dumpcont	 
425a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
425b					NEXTW 
425b c3 39 24			jp macro_next 
425e				endm 
# End of macro NEXTW
425e			 
425e			 
425e			 
425e			 
425e			.DAT: 
425e				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
425e 3d				db WORD_SYS_CORE+41             
425f b4 42			dw .HOME            
4261 03				db 2 + 1 
4262 .. 00			db "AT",0              
4265				endm 
# End of macro CWHEAD
4265			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4265					if DEBUG_FORTH_WORDS_KEY 
4265						DMARK "AT." 
4265 f5				push af  
4266 3a 7a 42			ld a, (.dmark)  
4269 32 6e fe			ld (debug_mark),a  
426c 3a 7b 42			ld a, (.dmark+1)  
426f 32 6f fe			ld (debug_mark+1),a  
4272 3a 7c 42			ld a, (.dmark+2)  
4275 32 70 fe			ld (debug_mark+2),a  
4278 18 03			jr .pastdmark  
427a ..			.dmark: db "AT."  
427d f1			.pastdmark: pop af  
427e			endm  
# End of macro DMARK
427e						CALLMONITOR 
427e cd c1 19			call break_point_state  
4281				endm  
# End of macro CALLMONITOR
4281					endif 
4281					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4281 cd 83 22			call macro_dsp_valuehl 
4284				endm 
# End of macro FORTH_DSP_VALUEHL
4284			 
4284			 
4284					; TODO save cursor row 
4284 7d					ld a,l 
4285 fe 02				cp 2 
4287 20 04				jr nz, .crow3 
4289 3e 28				ld a, display_row_2 
428b 18 12				jr .ccol1 
428d fe 03		.crow3:		cp 3 
428f 20 04				jr nz, .crow4 
4291 3e 50				ld a, display_row_3 
4293 18 0a				jr .ccol1 
4295 fe 04		.crow4:		cp 4 
4297 20 04				jr nz, .crow1 
4299 3e 78				ld a, display_row_4 
429b 18 02				jr .ccol1 
429d 3e 00		.crow1:		ld a,display_row_1 
429f f5			.ccol1:		push af			; got row offset 
42a0 6f					ld l,a 
42a1 26 00				ld h,0 
42a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42a3 cd 3b 23			call macro_forth_dsp_pop 
42a6				endm 
# End of macro FORTH_DSP_POP
42a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42a6 cd 83 22			call macro_dsp_valuehl 
42a9				endm 
# End of macro FORTH_DSP_VALUEHL
42a9					; TODO save cursor col 
42a9 f1					pop af 
42aa 85					add l		; add col offset 
42ab 32 65 fa				ld (f_cursor_ptr), a 
42ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42ae cd 3b 23			call macro_forth_dsp_pop 
42b1				endm 
# End of macro FORTH_DSP_POP
42b1			 
42b1					; calculate  
42b1			 
42b1					NEXTW 
42b1 c3 39 24			jp macro_next 
42b4				endm 
# End of macro NEXTW
42b4			 
42b4			 
42b4			.HOME: 
42b4				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
42b4 41				db WORD_SYS_CORE+45             
42b5 e1 42			dw .SPACE            
42b7 05				db 4 + 1 
42b8 .. 00			db "HOME",0              
42bd				endm 
# End of macro CWHEAD
42bd			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
42bd					if DEBUG_FORTH_WORDS_KEY 
42bd						DMARK "HOM" 
42bd f5				push af  
42be 3a d2 42			ld a, (.dmark)  
42c1 32 6e fe			ld (debug_mark),a  
42c4 3a d3 42			ld a, (.dmark+1)  
42c7 32 6f fe			ld (debug_mark+1),a  
42ca 3a d4 42			ld a, (.dmark+2)  
42cd 32 70 fe			ld (debug_mark+2),a  
42d0 18 03			jr .pastdmark  
42d2 ..			.dmark: db "HOM"  
42d5 f1			.pastdmark: pop af  
42d6			endm  
# End of macro DMARK
42d6						CALLMONITOR 
42d6 cd c1 19			call break_point_state  
42d9				endm  
# End of macro CALLMONITOR
42d9					endif 
42d9 3e 00		.home:		ld a, 0		; and home cursor 
42db 32 65 fa				ld (f_cursor_ptr), a 
42de					NEXTW 
42de c3 39 24			jp macro_next 
42e1				endm 
# End of macro NEXTW
42e1			 
42e1			 
42e1			.SPACE: 
42e1				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
42e1 46				db WORD_SYS_CORE+50             
42e2 17 43			dw .SPACES            
42e4 03				db 2 + 1 
42e5 .. 00			db "BL",0              
42e8				endm 
# End of macro CWHEAD
42e8			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
42e8					if DEBUG_FORTH_WORDS_KEY 
42e8						DMARK "BL." 
42e8 f5				push af  
42e9 3a fd 42			ld a, (.dmark)  
42ec 32 6e fe			ld (debug_mark),a  
42ef 3a fe 42			ld a, (.dmark+1)  
42f2 32 6f fe			ld (debug_mark+1),a  
42f5 3a ff 42			ld a, (.dmark+2)  
42f8 32 70 fe			ld (debug_mark+2),a  
42fb 18 03			jr .pastdmark  
42fd ..			.dmark: db "BL."  
4300 f1			.pastdmark: pop af  
4301			endm  
# End of macro DMARK
4301						CALLMONITOR 
4301 cd c1 19			call break_point_state  
4304				endm  
# End of macro CALLMONITOR
4304					endif 
4304 3e 20				ld a, " " 
4306 32 c8 f1				ld (scratch),a 
4309 3e 00				ld a, 0 
430b 32 c9 f1				ld (scratch+1),a 
430e 21 c8 f1				ld hl, scratch 
4311 cd fa 20				call forth_push_str 
4314					 
4314				       NEXTW 
4314 c3 39 24			jp macro_next 
4317				endm 
# End of macro NEXTW
4317			 
4317			;.blstr: db " ", 0 
4317			 
4317			.SPACES: 
4317				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4317 47				db WORD_SYS_CORE+51             
4318 b2 43			dw .SCROLL            
431a 07				db 6 + 1 
431b .. 00			db "SPACES",0              
4322				endm 
# End of macro CWHEAD
4322			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4322					if DEBUG_FORTH_WORDS_KEY 
4322						DMARK "SPS" 
4322 f5				push af  
4323 3a 37 43			ld a, (.dmark)  
4326 32 6e fe			ld (debug_mark),a  
4329 3a 38 43			ld a, (.dmark+1)  
432c 32 6f fe			ld (debug_mark+1),a  
432f 3a 39 43			ld a, (.dmark+2)  
4332 32 70 fe			ld (debug_mark+2),a  
4335 18 03			jr .pastdmark  
4337 ..			.dmark: db "SPS"  
433a f1			.pastdmark: pop af  
433b			endm  
# End of macro DMARK
433b						CALLMONITOR 
433b cd c1 19			call break_point_state  
433e				endm  
# End of macro CALLMONITOR
433e					endif 
433e			 
433e			 
433e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
433e cd 83 22			call macro_dsp_valuehl 
4341				endm 
# End of macro FORTH_DSP_VALUEHL
4341			 
4341 e5					push hl    ; u 
4342					if DEBUG_FORTH_WORDS 
4342						DMARK "SPA" 
4342 f5				push af  
4343 3a 57 43			ld a, (.dmark)  
4346 32 6e fe			ld (debug_mark),a  
4349 3a 58 43			ld a, (.dmark+1)  
434c 32 6f fe			ld (debug_mark+1),a  
434f 3a 59 43			ld a, (.dmark+2)  
4352 32 70 fe			ld (debug_mark+2),a  
4355 18 03			jr .pastdmark  
4357 ..			.dmark: db "SPA"  
435a f1			.pastdmark: pop af  
435b			endm  
# End of macro DMARK
435b						CALLMONITOR 
435b cd c1 19			call break_point_state  
435e				endm  
# End of macro CALLMONITOR
435e					endif 
435e			 
435e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
435e cd 3b 23			call macro_forth_dsp_pop 
4361				endm 
# End of macro FORTH_DSP_POP
4361 e1					pop hl 
4362 0e 00				ld c, 0 
4364 45					ld b, l 
4365 21 c8 f1				ld hl, scratch  
4368			 
4368					if DEBUG_FORTH_WORDS 
4368						DMARK "SP2" 
4368 f5				push af  
4369 3a 7d 43			ld a, (.dmark)  
436c 32 6e fe			ld (debug_mark),a  
436f 3a 7e 43			ld a, (.dmark+1)  
4372 32 6f fe			ld (debug_mark+1),a  
4375 3a 7f 43			ld a, (.dmark+2)  
4378 32 70 fe			ld (debug_mark+2),a  
437b 18 03			jr .pastdmark  
437d ..			.dmark: db "SP2"  
4380 f1			.pastdmark: pop af  
4381			endm  
# End of macro DMARK
4381						CALLMONITOR 
4381 cd c1 19			call break_point_state  
4384				endm  
# End of macro CALLMONITOR
4384					endif 
4384 3e 20				ld a, ' ' 
4386			.spaces1:	 
4386 77					ld (hl),a 
4387 23					inc hl 
4388					 
4388 10 fc				djnz .spaces1 
438a 3e 00				ld a,0 
438c 77					ld (hl),a 
438d 21 c8 f1				ld hl, scratch 
4390					if DEBUG_FORTH_WORDS 
4390						DMARK "SP3" 
4390 f5				push af  
4391 3a a5 43			ld a, (.dmark)  
4394 32 6e fe			ld (debug_mark),a  
4397 3a a6 43			ld a, (.dmark+1)  
439a 32 6f fe			ld (debug_mark+1),a  
439d 3a a7 43			ld a, (.dmark+2)  
43a0 32 70 fe			ld (debug_mark+2),a  
43a3 18 03			jr .pastdmark  
43a5 ..			.dmark: db "SP3"  
43a8 f1			.pastdmark: pop af  
43a9			endm  
# End of macro DMARK
43a9						CALLMONITOR 
43a9 cd c1 19			call break_point_state  
43ac				endm  
# End of macro CALLMONITOR
43ac					endif 
43ac cd fa 20				call forth_push_str 
43af			 
43af				       NEXTW 
43af c3 39 24			jp macro_next 
43b2				endm 
# End of macro NEXTW
43b2			 
43b2			 
43b2			 
43b2			.SCROLL: 
43b2				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
43b2 53				db WORD_SYS_CORE+63             
43b3 df 43			dw .SCROLLD            
43b5 07				db 6 + 1 
43b6 .. 00			db "SCROLL",0              
43bd				endm 
# End of macro CWHEAD
43bd			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
43bd					if DEBUG_FORTH_WORDS_KEY 
43bd						DMARK "SCR" 
43bd f5				push af  
43be 3a d2 43			ld a, (.dmark)  
43c1 32 6e fe			ld (debug_mark),a  
43c4 3a d3 43			ld a, (.dmark+1)  
43c7 32 6f fe			ld (debug_mark+1),a  
43ca 3a d4 43			ld a, (.dmark+2)  
43cd 32 70 fe			ld (debug_mark+2),a  
43d0 18 03			jr .pastdmark  
43d2 ..			.dmark: db "SCR"  
43d5 f1			.pastdmark: pop af  
43d6			endm  
# End of macro DMARK
43d6						CALLMONITOR 
43d6 cd c1 19			call break_point_state  
43d9				endm  
# End of macro CALLMONITOR
43d9					endif 
43d9			 
43d9 cd da 0c			call scroll_up 
43dc			;	call update_display 
43dc			 
43dc					NEXTW 
43dc c3 39 24			jp macro_next 
43df				endm 
# End of macro NEXTW
43df			 
43df			 
43df			 
43df			;		; get dir 
43df			; 
43df			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43df			; 
43df			;		push hl 
43df			; 
43df			;		; destroy value TOS 
43df			; 
43df			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43df			; 
43df			;		; get count 
43df			; 
43df			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43df			; 
43df			;		push hl 
43df			; 
43df			;		; destroy value TOS 
43df			; 
43df			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43df			; 
43df			;		; one value on hl get other one back 
43df			; 
43df			;		pop bc    ; count 
43df			; 
43df			;		pop de   ; dir 
43df			; 
43df			; 
43df			;		ld b, c 
43df			; 
43df			;.scrolldir:     push bc 
43df			;		push de 
43df			; 
43df			;		ld a, 0 
43df			;		cp e 
43df			;		jr z, .scrollup  
43df			;		call scroll_down 
43df			;		jr .scrollnext 
43df			;.scrollup:	call scroll_up 
43df			; 
43df			;		 
43df			;.scrollnext: 
43df			;		pop de 
43df			;		pop bc 
43df			;		djnz .scrolldir 
43df			; 
43df			; 
43df			; 
43df			; 
43df			; 
43df			;		NEXTW 
43df			 
43df			.SCROLLD: 
43df				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
43df 53				db WORD_SYS_CORE+63             
43e0 0d 44			dw .ATQ            
43e2 08				db 7 + 1 
43e3 .. 00			db "SCROLLD",0              
43eb				endm 
# End of macro CWHEAD
43eb			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
43eb					if DEBUG_FORTH_WORDS_KEY 
43eb						DMARK "SCD" 
43eb f5				push af  
43ec 3a 00 44			ld a, (.dmark)  
43ef 32 6e fe			ld (debug_mark),a  
43f2 3a 01 44			ld a, (.dmark+1)  
43f5 32 6f fe			ld (debug_mark+1),a  
43f8 3a 02 44			ld a, (.dmark+2)  
43fb 32 70 fe			ld (debug_mark+2),a  
43fe 18 03			jr .pastdmark  
4400 ..			.dmark: db "SCD"  
4403 f1			.pastdmark: pop af  
4404			endm  
# End of macro DMARK
4404						CALLMONITOR 
4404 cd c1 19			call break_point_state  
4407				endm  
# End of macro CALLMONITOR
4407					endif 
4407			 
4407 cd fe 0c			call scroll_down 
440a			;	call update_display 
440a			 
440a					NEXTW 
440a c3 39 24			jp macro_next 
440d				endm 
# End of macro NEXTW
440d			 
440d			 
440d			.ATQ: 
440d				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
440d 62				db WORD_SYS_CORE+78             
440e 6b 44			dw .AUTODSP            
4410 04				db 3 + 1 
4411 .. 00			db "AT@",0              
4415				endm 
# End of macro CWHEAD
4415			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4415					if DEBUG_FORTH_WORDS_KEY 
4415						DMARK "ATA" 
4415 f5				push af  
4416 3a 2a 44			ld a, (.dmark)  
4419 32 6e fe			ld (debug_mark),a  
441c 3a 2b 44			ld a, (.dmark+1)  
441f 32 6f fe			ld (debug_mark+1),a  
4422 3a 2c 44			ld a, (.dmark+2)  
4425 32 70 fe			ld (debug_mark+2),a  
4428 18 03			jr .pastdmark  
442a ..			.dmark: db "ATA"  
442d f1			.pastdmark: pop af  
442e			endm  
# End of macro DMARK
442e						CALLMONITOR 
442e cd c1 19			call break_point_state  
4431				endm  
# End of macro CALLMONITOR
4431					endif 
4431			 
4431			 
4431					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4431 cd 83 22			call macro_dsp_valuehl 
4434				endm 
# End of macro FORTH_DSP_VALUEHL
4434			 
4434					; TODO save cursor row 
4434 7d					ld a,l 
4435 fe 02				cp 2 
4437 20 04				jr nz, .crow3aq 
4439 3e 28				ld a, display_row_2 
443b 18 12				jr .ccol1aq 
443d fe 03		.crow3aq:		cp 3 
443f 20 04				jr nz, .crow4aq 
4441 3e 50				ld a, display_row_3 
4443 18 0a				jr .ccol1aq 
4445 fe 04		.crow4aq:		cp 4 
4447 20 04				jr nz, .crow1aq 
4449 3e 78				ld a, display_row_4 
444b 18 02				jr .ccol1aq 
444d 3e 00		.crow1aq:		ld a,display_row_1 
444f f5			.ccol1aq:		push af			; got row offset 
4450 6f					ld l,a 
4451 26 00				ld h,0 
4453					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4453 cd 3b 23			call macro_forth_dsp_pop 
4456				endm 
# End of macro FORTH_DSP_POP
4456					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4456 cd 83 22			call macro_dsp_valuehl 
4459				endm 
# End of macro FORTH_DSP_VALUEHL
4459					; TODO save cursor col 
4459 f1					pop af 
445a 85					add l		; add col offset 
445b			 
445b					; add current frame buffer address 
445b 2a cf fb				ld hl, (display_fb_active) 
445e cd 4c 0f				call addatohl 
4461			 
4461			 
4461			 
4461			 
4461					; get char frame buffer location offset in hl 
4461			 
4461 7e					ld a,(hl) 
4462 26 00				ld h, 0 
4464 6f					ld l, a 
4465			 
4465 cd 8c 20				call forth_push_numhl 
4468			 
4468			 
4468					NEXTW 
4468 c3 39 24			jp macro_next 
446b				endm 
# End of macro NEXTW
446b			 
446b			.AUTODSP: 
446b				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
446b 63				db WORD_SYS_CORE+79             
446c 81 44			dw .MENU            
446e 05				db 4 + 1 
446f .. 00			db "ADSP",0              
4474				endm 
# End of macro CWHEAD
4474			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4474			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4474			 
4474					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4474 cd 83 22			call macro_dsp_valuehl 
4477				endm 
# End of macro FORTH_DSP_VALUEHL
4477			 
4477			;		push hl 
4477			 
4477					; destroy value TOS 
4477			 
4477					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4477 cd 3b 23			call macro_forth_dsp_pop 
447a				endm 
# End of macro FORTH_DSP_POP
447a			 
447a			;		pop hl 
447a			 
447a 7d					ld a,l 
447b 32 43 fa				ld (cli_autodisplay), a 
447e				       NEXTW 
447e c3 39 24			jp macro_next 
4481				endm 
# End of macro NEXTW
4481			 
4481			.MENU: 
4481				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4481 70				db WORD_SYS_CORE+92             
4482 2a 45			dw .ENDDISPLAY            
4484 05				db 4 + 1 
4485 .. 00			db "MENU",0              
448a				endm 
# End of macro CWHEAD
448a			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
448a			 
448a			;		; get number of items on the stack 
448a			; 
448a				 
448a					FORTH_DSP_VALUEHL 
448a cd 83 22			call macro_dsp_valuehl 
448d				endm 
# End of macro FORTH_DSP_VALUEHL
448d				 
448d					if DEBUG_FORTH_WORDS_KEY 
448d						DMARK "MNU" 
448d f5				push af  
448e 3a a2 44			ld a, (.dmark)  
4491 32 6e fe			ld (debug_mark),a  
4494 3a a3 44			ld a, (.dmark+1)  
4497 32 6f fe			ld (debug_mark+1),a  
449a 3a a4 44			ld a, (.dmark+2)  
449d 32 70 fe			ld (debug_mark+2),a  
44a0 18 03			jr .pastdmark  
44a2 ..			.dmark: db "MNU"  
44a5 f1			.pastdmark: pop af  
44a6			endm  
# End of macro DMARK
44a6						CALLMONITOR 
44a6 cd c1 19			call break_point_state  
44a9				endm  
# End of macro CALLMONITOR
44a9					endif 
44a9			 
44a9 45					ld b, l	 
44aa 05					dec b 
44ab			 
44ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44ab cd 3b 23			call macro_forth_dsp_pop 
44ae				endm 
# End of macro FORTH_DSP_POP
44ae			 
44ae			 
44ae					; go directly through the stack to pluck out the string pointers and build an array 
44ae			 
44ae			;		FORTH_DSP 
44ae			 
44ae					; hl contains top most stack item 
44ae				 
44ae 11 c8 f1				ld de, scratch 
44b1			 
44b1			.mbuild: 
44b1			 
44b1					FORTH_DSP_VALUEHL 
44b1 cd 83 22			call macro_dsp_valuehl 
44b4				endm 
# End of macro FORTH_DSP_VALUEHL
44b4			 
44b4					if DEBUG_FORTH_WORDS 
44b4						DMARK "MN3" 
44b4 f5				push af  
44b5 3a c9 44			ld a, (.dmark)  
44b8 32 6e fe			ld (debug_mark),a  
44bb 3a ca 44			ld a, (.dmark+1)  
44be 32 6f fe			ld (debug_mark+1),a  
44c1 3a cb 44			ld a, (.dmark+2)  
44c4 32 70 fe			ld (debug_mark+2),a  
44c7 18 03			jr .pastdmark  
44c9 ..			.dmark: db "MN3"  
44cc f1			.pastdmark: pop af  
44cd			endm  
# End of macro DMARK
44cd						CALLMONITOR 
44cd cd c1 19			call break_point_state  
44d0				endm  
# End of macro CALLMONITOR
44d0					endif 
44d0 eb					ex de, hl 
44d1 73					ld (hl), e 
44d2 23					inc hl 
44d3 72					ld (hl), d 
44d4 23					inc hl 
44d5 eb					ex de, hl 
44d6			 
44d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44d6 cd 3b 23			call macro_forth_dsp_pop 
44d9				endm 
# End of macro FORTH_DSP_POP
44d9			 
44d9 10 d6				djnz .mbuild 
44db			 
44db					; done add term 
44db			 
44db eb					ex de, hl 
44dc 36 00				ld (hl), 0 
44de 23					inc hl 
44df 36 00				ld (hl), 0 
44e1			 
44e1				 
44e1					 
44e1 21 c8 f1				ld hl, scratch 
44e4			 
44e4					if DEBUG_FORTH_WORDS 
44e4						DMARK "MNx" 
44e4 f5				push af  
44e5 3a f9 44			ld a, (.dmark)  
44e8 32 6e fe			ld (debug_mark),a  
44eb 3a fa 44			ld a, (.dmark+1)  
44ee 32 6f fe			ld (debug_mark+1),a  
44f1 3a fb 44			ld a, (.dmark+2)  
44f4 32 70 fe			ld (debug_mark+2),a  
44f7 18 03			jr .pastdmark  
44f9 ..			.dmark: db "MNx"  
44fc f1			.pastdmark: pop af  
44fd			endm  
# End of macro DMARK
44fd						CALLMONITOR 
44fd cd c1 19			call break_point_state  
4500				endm  
# End of macro CALLMONITOR
4500					endif 
4500			 
4500			 
4500			 
4500 3e 00				ld a, 0 
4502 cd 49 0d				call menu 
4505			 
4505			 
4505 6f					ld l, a 
4506 26 00				ld h, 0 
4508			 
4508					if DEBUG_FORTH_WORDS 
4508						DMARK "MNr" 
4508 f5				push af  
4509 3a 1d 45			ld a, (.dmark)  
450c 32 6e fe			ld (debug_mark),a  
450f 3a 1e 45			ld a, (.dmark+1)  
4512 32 6f fe			ld (debug_mark+1),a  
4515 3a 1f 45			ld a, (.dmark+2)  
4518 32 70 fe			ld (debug_mark+2),a  
451b 18 03			jr .pastdmark  
451d ..			.dmark: db "MNr"  
4520 f1			.pastdmark: pop af  
4521			endm  
# End of macro DMARK
4521						CALLMONITOR 
4521 cd c1 19			call break_point_state  
4524				endm  
# End of macro CALLMONITOR
4524					endif 
4524			 
4524 cd 8c 20				call forth_push_numhl 
4527			 
4527			 
4527			 
4527			 
4527				       NEXTW 
4527 c3 39 24			jp macro_next 
452a				endm 
# End of macro NEXTW
452a			 
452a			 
452a			.ENDDISPLAY: 
452a			 
452a			; eof 
# End of file forth_words_display.asm
452a			include "forth_words_str.asm" 
452a			 
452a			; | ## String Words 
452a			 
452a			.PTR:   
452a			 
452a				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
452a 48				db WORD_SYS_CORE+52             
452b 57 45			dw .STYPE            
452d 04				db 3 + 1 
452e .. 00			db "PTR",0              
4532				endm 
# End of macro CWHEAD
4532			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4532			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4532			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4532			 
4532					if DEBUG_FORTH_WORDS_KEY 
4532						DMARK "PTR" 
4532 f5				push af  
4533 3a 47 45			ld a, (.dmark)  
4536 32 6e fe			ld (debug_mark),a  
4539 3a 48 45			ld a, (.dmark+1)  
453c 32 6f fe			ld (debug_mark+1),a  
453f 3a 49 45			ld a, (.dmark+2)  
4542 32 70 fe			ld (debug_mark+2),a  
4545 18 03			jr .pastdmark  
4547 ..			.dmark: db "PTR"  
454a f1			.pastdmark: pop af  
454b			endm  
# End of macro DMARK
454b						CALLMONITOR 
454b cd c1 19			call break_point_state  
454e				endm  
# End of macro CALLMONITOR
454e					endif 
454e					FORTH_DSP_VALUEHL 
454e cd 83 22			call macro_dsp_valuehl 
4551				endm 
# End of macro FORTH_DSP_VALUEHL
4551 cd 8c 20				call forth_push_numhl 
4554			 
4554			 
4554					NEXTW 
4554 c3 39 24			jp macro_next 
4557				endm 
# End of macro NEXTW
4557			.STYPE: 
4557				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4557 48				db WORD_SYS_CORE+52             
4558 a6 45			dw .UPPER            
455a 06				db 5 + 1 
455b .. 00			db "STYPE",0              
4561				endm 
# End of macro CWHEAD
4561			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4561					if DEBUG_FORTH_WORDS_KEY 
4561						DMARK "STY" 
4561 f5				push af  
4562 3a 76 45			ld a, (.dmark)  
4565 32 6e fe			ld (debug_mark),a  
4568 3a 77 45			ld a, (.dmark+1)  
456b 32 6f fe			ld (debug_mark+1),a  
456e 3a 78 45			ld a, (.dmark+2)  
4571 32 70 fe			ld (debug_mark+2),a  
4574 18 03			jr .pastdmark  
4576 ..			.dmark: db "STY"  
4579 f1			.pastdmark: pop af  
457a			endm  
# End of macro DMARK
457a						CALLMONITOR 
457a cd c1 19			call break_point_state  
457d				endm  
# End of macro CALLMONITOR
457d					endif 
457d					FORTH_DSP 
457d cd 49 22			call macro_forth_dsp 
4580				endm 
# End of macro FORTH_DSP
4580					;v5 FORTH_DSP_VALUE 
4580			 
4580 7e					ld a, (hl) 
4581			 
4581 f5					push af 
4582			 
4582			; Dont destroy TOS		FORTH_DSP_POP 
4582			 
4582 f1					pop af 
4583			 
4583 fe 01				cp DS_TYPE_STR 
4585 28 09				jr z, .typestr 
4587			 
4587 fe 02				cp DS_TYPE_INUM 
4589 28 0a				jr z, .typeinum 
458b			 
458b 21 a4 45				ld hl, .tna 
458e 18 0a				jr .tpush 
4590			 
4590 21 a0 45		.typestr:	ld hl, .tstr 
4593 18 05				jr .tpush 
4595 21 a2 45		.typeinum:	ld hl, .tinum 
4598 18 00				jr .tpush 
459a			 
459a			.tpush: 
459a			 
459a cd fa 20				call forth_push_str 
459d			 
459d					NEXTW 
459d c3 39 24			jp macro_next 
45a0				endm 
# End of macro NEXTW
45a0 .. 00		.tstr:	db "s",0 
45a2 .. 00		.tinum:  db "i",0 
45a4 .. 00		.tna:   db "?", 0 
45a6			 
45a6			 
45a6			.UPPER: 
45a6				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
45a6 48				db WORD_SYS_CORE+52             
45a7 e1 45			dw .LOWER            
45a9 06				db 5 + 1 
45aa .. 00			db "UPPER",0              
45b0				endm 
# End of macro CWHEAD
45b0			; | UPPER ( s -- s ) Upper case string s  | DONE 
45b0					if DEBUG_FORTH_WORDS_KEY 
45b0						DMARK "UPR" 
45b0 f5				push af  
45b1 3a c5 45			ld a, (.dmark)  
45b4 32 6e fe			ld (debug_mark),a  
45b7 3a c6 45			ld a, (.dmark+1)  
45ba 32 6f fe			ld (debug_mark+1),a  
45bd 3a c7 45			ld a, (.dmark+2)  
45c0 32 70 fe			ld (debug_mark+2),a  
45c3 18 03			jr .pastdmark  
45c5 ..			.dmark: db "UPR"  
45c8 f1			.pastdmark: pop af  
45c9			endm  
# End of macro DMARK
45c9						CALLMONITOR 
45c9 cd c1 19			call break_point_state  
45cc				endm  
# End of macro CALLMONITOR
45cc					endif 
45cc			 
45cc					FORTH_DSP 
45cc cd 49 22			call macro_forth_dsp 
45cf				endm 
# End of macro FORTH_DSP
45cf					 
45cf			; TODO check is string type 
45cf			 
45cf					FORTH_DSP_VALUEHL 
45cf cd 83 22			call macro_dsp_valuehl 
45d2				endm 
# End of macro FORTH_DSP_VALUEHL
45d2			; get pointer to string in hl 
45d2			 
45d2 7e			.toup:		ld a, (hl) 
45d3 fe 00				cp 0 
45d5 28 07				jr z, .toupdone 
45d7			 
45d7 cd b9 12				call to_upper 
45da			 
45da 77					ld (hl), a 
45db 23					inc hl 
45dc 18 f4				jr .toup 
45de			 
45de					 
45de			 
45de			 
45de			; for each char convert to upper 
45de					 
45de			.toupdone: 
45de			 
45de			 
45de					NEXTW 
45de c3 39 24			jp macro_next 
45e1				endm 
# End of macro NEXTW
45e1			.LOWER: 
45e1				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
45e1 48				db WORD_SYS_CORE+52             
45e2 1c 46			dw .TCASE            
45e4 06				db 5 + 1 
45e5 .. 00			db "LOWER",0              
45eb				endm 
# End of macro CWHEAD
45eb			; | LOWER ( s -- s ) Lower case string s  | DONE 
45eb					if DEBUG_FORTH_WORDS_KEY 
45eb						DMARK "LWR" 
45eb f5				push af  
45ec 3a 00 46			ld a, (.dmark)  
45ef 32 6e fe			ld (debug_mark),a  
45f2 3a 01 46			ld a, (.dmark+1)  
45f5 32 6f fe			ld (debug_mark+1),a  
45f8 3a 02 46			ld a, (.dmark+2)  
45fb 32 70 fe			ld (debug_mark+2),a  
45fe 18 03			jr .pastdmark  
4600 ..			.dmark: db "LWR"  
4603 f1			.pastdmark: pop af  
4604			endm  
# End of macro DMARK
4604						CALLMONITOR 
4604 cd c1 19			call break_point_state  
4607				endm  
# End of macro CALLMONITOR
4607					endif 
4607			 
4607					FORTH_DSP 
4607 cd 49 22			call macro_forth_dsp 
460a				endm 
# End of macro FORTH_DSP
460a					 
460a			; TODO check is string type 
460a			 
460a					FORTH_DSP_VALUEHL 
460a cd 83 22			call macro_dsp_valuehl 
460d				endm 
# End of macro FORTH_DSP_VALUEHL
460d			; get pointer to string in hl 
460d			 
460d 7e			.tolow:		ld a, (hl) 
460e fe 00				cp 0 
4610 28 07				jr z, .tolowdone 
4612			 
4612 cd c2 12				call to_lower 
4615			 
4615 77					ld (hl), a 
4616 23					inc hl 
4617 18 f4				jr .tolow 
4619			 
4619					 
4619			 
4619			 
4619			; for each char convert to low 
4619					 
4619			.tolowdone: 
4619					NEXTW 
4619 c3 39 24			jp macro_next 
461c				endm 
# End of macro NEXTW
461c			.TCASE: 
461c				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
461c 48				db WORD_SYS_CORE+52             
461d 52 47			dw .SUBSTR            
461f 06				db 5 + 1 
4620 .. 00			db "TCASE",0              
4626				endm 
# End of macro CWHEAD
4626			; | TCASE ( s -- s ) Title case string s  | DONE 
4626					if DEBUG_FORTH_WORDS_KEY 
4626						DMARK "TCS" 
4626 f5				push af  
4627 3a 3b 46			ld a, (.dmark)  
462a 32 6e fe			ld (debug_mark),a  
462d 3a 3c 46			ld a, (.dmark+1)  
4630 32 6f fe			ld (debug_mark+1),a  
4633 3a 3d 46			ld a, (.dmark+2)  
4636 32 70 fe			ld (debug_mark+2),a  
4639 18 03			jr .pastdmark  
463b ..			.dmark: db "TCS"  
463e f1			.pastdmark: pop af  
463f			endm  
# End of macro DMARK
463f						CALLMONITOR 
463f cd c1 19			call break_point_state  
4642				endm  
# End of macro CALLMONITOR
4642					endif 
4642			 
4642					FORTH_DSP 
4642 cd 49 22			call macro_forth_dsp 
4645				endm 
# End of macro FORTH_DSP
4645					 
4645			; TODO check is string type 
4645			 
4645					FORTH_DSP_VALUEHL 
4645 cd 83 22			call macro_dsp_valuehl 
4648				endm 
# End of macro FORTH_DSP_VALUEHL
4648			; get pointer to string in hl 
4648			 
4648					if DEBUG_FORTH_WORDS 
4648						DMARK "TC1" 
4648 f5				push af  
4649 3a 5d 46			ld a, (.dmark)  
464c 32 6e fe			ld (debug_mark),a  
464f 3a 5e 46			ld a, (.dmark+1)  
4652 32 6f fe			ld (debug_mark+1),a  
4655 3a 5f 46			ld a, (.dmark+2)  
4658 32 70 fe			ld (debug_mark+2),a  
465b 18 03			jr .pastdmark  
465d ..			.dmark: db "TC1"  
4660 f1			.pastdmark: pop af  
4661			endm  
# End of macro DMARK
4661						CALLMONITOR 
4661 cd c1 19			call break_point_state  
4664				endm  
# End of macro CALLMONITOR
4664					endif 
4664			 
4664					; first time in turn to upper case first char 
4664			 
4664 7e					ld a, (hl) 
4665 c3 ef 46				jp .totsiptou 
4668			 
4668			 
4668 7e			.tot:		ld a, (hl) 
4669 fe 00				cp 0 
466b ca 33 47				jp z, .totdone 
466e			 
466e					if DEBUG_FORTH_WORDS 
466e						DMARK "TC2" 
466e f5				push af  
466f 3a 83 46			ld a, (.dmark)  
4672 32 6e fe			ld (debug_mark),a  
4675 3a 84 46			ld a, (.dmark+1)  
4678 32 6f fe			ld (debug_mark+1),a  
467b 3a 85 46			ld a, (.dmark+2)  
467e 32 70 fe			ld (debug_mark+2),a  
4681 18 03			jr .pastdmark  
4683 ..			.dmark: db "TC2"  
4686 f1			.pastdmark: pop af  
4687			endm  
# End of macro DMARK
4687						CALLMONITOR 
4687 cd c1 19			call break_point_state  
468a				endm  
# End of macro CALLMONITOR
468a					endif 
468a					; check to see if current char is a space 
468a			 
468a fe 20				cp ' ' 
468c 28 21				jr z, .totsp 
468e cd c2 12				call to_lower 
4691					if DEBUG_FORTH_WORDS 
4691						DMARK "TC3" 
4691 f5				push af  
4692 3a a6 46			ld a, (.dmark)  
4695 32 6e fe			ld (debug_mark),a  
4698 3a a7 46			ld a, (.dmark+1)  
469b 32 6f fe			ld (debug_mark+1),a  
469e 3a a8 46			ld a, (.dmark+2)  
46a1 32 70 fe			ld (debug_mark+2),a  
46a4 18 03			jr .pastdmark  
46a6 ..			.dmark: db "TC3"  
46a9 f1			.pastdmark: pop af  
46aa			endm  
# End of macro DMARK
46aa						CALLMONITOR 
46aa cd c1 19			call break_point_state  
46ad				endm  
# End of macro CALLMONITOR
46ad					endif 
46ad 18 63				jr .totnxt 
46af			 
46af			.totsp:         ; on a space, find next char which should be upper 
46af			 
46af					if DEBUG_FORTH_WORDS 
46af						DMARK "TC4" 
46af f5				push af  
46b0 3a c4 46			ld a, (.dmark)  
46b3 32 6e fe			ld (debug_mark),a  
46b6 3a c5 46			ld a, (.dmark+1)  
46b9 32 6f fe			ld (debug_mark+1),a  
46bc 3a c6 46			ld a, (.dmark+2)  
46bf 32 70 fe			ld (debug_mark+2),a  
46c2 18 03			jr .pastdmark  
46c4 ..			.dmark: db "TC4"  
46c7 f1			.pastdmark: pop af  
46c8			endm  
# End of macro DMARK
46c8						CALLMONITOR 
46c8 cd c1 19			call break_point_state  
46cb				endm  
# End of macro CALLMONITOR
46cb					endif 
46cb					;; 
46cb			 
46cb fe 20				cp ' ' 
46cd 20 20				jr nz, .totsiptou 
46cf 23					inc hl 
46d0 7e					ld a, (hl) 
46d1					if DEBUG_FORTH_WORDS 
46d1						DMARK "TC5" 
46d1 f5				push af  
46d2 3a e6 46			ld a, (.dmark)  
46d5 32 6e fe			ld (debug_mark),a  
46d8 3a e7 46			ld a, (.dmark+1)  
46db 32 6f fe			ld (debug_mark+1),a  
46de 3a e8 46			ld a, (.dmark+2)  
46e1 32 70 fe			ld (debug_mark+2),a  
46e4 18 03			jr .pastdmark  
46e6 ..			.dmark: db "TC5"  
46e9 f1			.pastdmark: pop af  
46ea			endm  
# End of macro DMARK
46ea						CALLMONITOR 
46ea cd c1 19			call break_point_state  
46ed				endm  
# End of macro CALLMONITOR
46ed					endif 
46ed 18 c0				jr .totsp 
46ef fe 00		.totsiptou:    cp 0 
46f1 28 40				jr z, .totdone 
46f3					; not space and not zero term so upper case it 
46f3 cd b9 12				call to_upper 
46f6			 
46f6					if DEBUG_FORTH_WORDS 
46f6						DMARK "TC6" 
46f6 f5				push af  
46f7 3a 0b 47			ld a, (.dmark)  
46fa 32 6e fe			ld (debug_mark),a  
46fd 3a 0c 47			ld a, (.dmark+1)  
4700 32 6f fe			ld (debug_mark+1),a  
4703 3a 0d 47			ld a, (.dmark+2)  
4706 32 70 fe			ld (debug_mark+2),a  
4709 18 03			jr .pastdmark  
470b ..			.dmark: db "TC6"  
470e f1			.pastdmark: pop af  
470f			endm  
# End of macro DMARK
470f						CALLMONITOR 
470f cd c1 19			call break_point_state  
4712				endm  
# End of macro CALLMONITOR
4712					endif 
4712			 
4712			 
4712			.totnxt: 
4712			 
4712 77					ld (hl), a 
4713 23					inc hl 
4714					if DEBUG_FORTH_WORDS 
4714						DMARK "TC7" 
4714 f5				push af  
4715 3a 29 47			ld a, (.dmark)  
4718 32 6e fe			ld (debug_mark),a  
471b 3a 2a 47			ld a, (.dmark+1)  
471e 32 6f fe			ld (debug_mark+1),a  
4721 3a 2b 47			ld a, (.dmark+2)  
4724 32 70 fe			ld (debug_mark+2),a  
4727 18 03			jr .pastdmark  
4729 ..			.dmark: db "TC7"  
472c f1			.pastdmark: pop af  
472d			endm  
# End of macro DMARK
472d						CALLMONITOR 
472d cd c1 19			call break_point_state  
4730				endm  
# End of macro CALLMONITOR
4730					endif 
4730 c3 68 46				jp .tot 
4733			 
4733					 
4733			 
4733			 
4733			; for each char convert to low 
4733					 
4733			.totdone: 
4733					if DEBUG_FORTH_WORDS 
4733						DMARK "TCd" 
4733 f5				push af  
4734 3a 48 47			ld a, (.dmark)  
4737 32 6e fe			ld (debug_mark),a  
473a 3a 49 47			ld a, (.dmark+1)  
473d 32 6f fe			ld (debug_mark+1),a  
4740 3a 4a 47			ld a, (.dmark+2)  
4743 32 70 fe			ld (debug_mark+2),a  
4746 18 03			jr .pastdmark  
4748 ..			.dmark: db "TCd"  
474b f1			.pastdmark: pop af  
474c			endm  
# End of macro DMARK
474c						CALLMONITOR 
474c cd c1 19			call break_point_state  
474f				endm  
# End of macro CALLMONITOR
474f					endif 
474f					NEXTW 
474f c3 39 24			jp macro_next 
4752				endm 
# End of macro NEXTW
4752			 
4752			.SUBSTR: 
4752				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4752 48				db WORD_SYS_CORE+52             
4753 b0 47			dw .LEFT            
4755 07				db 6 + 1 
4756 .. 00			db "SUBSTR",0              
475d				endm 
# End of macro CWHEAD
475d			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
475d			 
475d					if DEBUG_FORTH_WORDS_KEY 
475d						DMARK "SST" 
475d f5				push af  
475e 3a 72 47			ld a, (.dmark)  
4761 32 6e fe			ld (debug_mark),a  
4764 3a 73 47			ld a, (.dmark+1)  
4767 32 6f fe			ld (debug_mark+1),a  
476a 3a 74 47			ld a, (.dmark+2)  
476d 32 70 fe			ld (debug_mark+2),a  
4770 18 03			jr .pastdmark  
4772 ..			.dmark: db "SST"  
4775 f1			.pastdmark: pop af  
4776			endm  
# End of macro DMARK
4776						CALLMONITOR 
4776 cd c1 19			call break_point_state  
4779				endm  
# End of macro CALLMONITOR
4779					endif 
4779			; TODO check string type 
4779					FORTH_DSP_VALUEHL 
4779 cd 83 22			call macro_dsp_valuehl 
477c				endm 
# End of macro FORTH_DSP_VALUEHL
477c			 
477c e5					push hl      ; string length 
477d			 
477d					FORTH_DSP_POP 
477d cd 3b 23			call macro_forth_dsp_pop 
4780				endm 
# End of macro FORTH_DSP_POP
4780			 
4780					FORTH_DSP_VALUEHL 
4780 cd 83 22			call macro_dsp_valuehl 
4783				endm 
# End of macro FORTH_DSP_VALUEHL
4783			 
4783 e5					push hl     ; start char 
4784			 
4784					FORTH_DSP_POP 
4784 cd 3b 23			call macro_forth_dsp_pop 
4787				endm 
# End of macro FORTH_DSP_POP
4787			 
4787			 
4787					FORTH_DSP_VALUE 
4787 cd 6c 22			call macro_forth_dsp_value 
478a				endm 
# End of macro FORTH_DSP_VALUE
478a			 
478a d1					pop de    ; get start post offset 
478b			 
478b 19					add hl, de    ; starting offset 
478c			 
478c c1					pop bc 
478d c5					push bc      ; grab size of string 
478e			 
478e e5					push hl    ; save string start  
478f			 
478f 26 00				ld h, 0 
4791 69					ld l, c 
4792 23					inc hl 
4793 23					inc hl 
4794			 
4794 cd 13 14				call malloc 
4797				if DEBUG_FORTH_MALLOC_GUARD 
4797 cc 0b 5d				call z,malloc_error 
479a				endif 
479a			 
479a eb					ex de, hl      ; save malloc area for string copy 
479b e1					pop hl    ; get back source 
479c c1					pop bc    ; get length of string back 
479d			 
479d d5					push de    ; save malloc area for after we push 
479e ed b0				ldir     ; copy substr 
47a0			 
47a0			 
47a0 eb					ex de, hl 
47a1 3e 00				ld a, 0 
47a3 77					ld (hl), a   ; term substr 
47a4			 
47a4					 
47a4 e1					pop hl    ; get malloc so we can push it 
47a5 e5					push hl   ; save so we can free it afterwards 
47a6			 
47a6 cd fa 20				call forth_push_str 
47a9			 
47a9 e1					pop hl 
47aa cd dd 14				call free 
47ad			 
47ad					 
47ad					 
47ad			 
47ad			 
47ad					NEXTW 
47ad c3 39 24			jp macro_next 
47b0				endm 
# End of macro NEXTW
47b0			 
47b0			.LEFT: 
47b0				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
47b0 48				db WORD_SYS_CORE+52             
47b1 d8 47			dw .RIGHT            
47b3 05				db 4 + 1 
47b4 .. 00			db "LEFT",0              
47b9				endm 
# End of macro CWHEAD
47b9			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
47b9					if DEBUG_FORTH_WORDS_KEY 
47b9						DMARK "LEF" 
47b9 f5				push af  
47ba 3a ce 47			ld a, (.dmark)  
47bd 32 6e fe			ld (debug_mark),a  
47c0 3a cf 47			ld a, (.dmark+1)  
47c3 32 6f fe			ld (debug_mark+1),a  
47c6 3a d0 47			ld a, (.dmark+2)  
47c9 32 70 fe			ld (debug_mark+2),a  
47cc 18 03			jr .pastdmark  
47ce ..			.dmark: db "LEF"  
47d1 f1			.pastdmark: pop af  
47d2			endm  
# End of macro DMARK
47d2						CALLMONITOR 
47d2 cd c1 19			call break_point_state  
47d5				endm  
# End of macro CALLMONITOR
47d5					endif 
47d5			 
47d5					NEXTW 
47d5 c3 39 24			jp macro_next 
47d8				endm 
# End of macro NEXTW
47d8			.RIGHT: 
47d8				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
47d8 48				db WORD_SYS_CORE+52             
47d9 01 48			dw .STR2NUM            
47db 06				db 5 + 1 
47dc .. 00			db "RIGHT",0              
47e2				endm 
# End of macro CWHEAD
47e2			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
47e2					if DEBUG_FORTH_WORDS_KEY 
47e2						DMARK "RIG" 
47e2 f5				push af  
47e3 3a f7 47			ld a, (.dmark)  
47e6 32 6e fe			ld (debug_mark),a  
47e9 3a f8 47			ld a, (.dmark+1)  
47ec 32 6f fe			ld (debug_mark+1),a  
47ef 3a f9 47			ld a, (.dmark+2)  
47f2 32 70 fe			ld (debug_mark+2),a  
47f5 18 03			jr .pastdmark  
47f7 ..			.dmark: db "RIG"  
47fa f1			.pastdmark: pop af  
47fb			endm  
# End of macro DMARK
47fb						CALLMONITOR 
47fb cd c1 19			call break_point_state  
47fe				endm  
# End of macro CALLMONITOR
47fe					endif 
47fe			 
47fe					NEXTW 
47fe c3 39 24			jp macro_next 
4801				endm 
# End of macro NEXTW
4801			 
4801			 
4801			.STR2NUM: 
4801				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4801 48				db WORD_SYS_CORE+52             
4802 8d 48			dw .NUM2STR            
4804 08				db 7 + 1 
4805 .. 00			db "STR2NUM",0              
480d				endm 
# End of macro CWHEAD
480d			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
480d			 
480d			 
480d			; TODO STR type check to do 
480d					if DEBUG_FORTH_WORDS_KEY 
480d						DMARK "S2N" 
480d f5				push af  
480e 3a 22 48			ld a, (.dmark)  
4811 32 6e fe			ld (debug_mark),a  
4814 3a 23 48			ld a, (.dmark+1)  
4817 32 6f fe			ld (debug_mark+1),a  
481a 3a 24 48			ld a, (.dmark+2)  
481d 32 70 fe			ld (debug_mark+2),a  
4820 18 03			jr .pastdmark  
4822 ..			.dmark: db "S2N"  
4825 f1			.pastdmark: pop af  
4826			endm  
# End of macro DMARK
4826						CALLMONITOR 
4826 cd c1 19			call break_point_state  
4829				endm  
# End of macro CALLMONITOR
4829					endif 
4829			 
4829					;FORTH_DSP 
4829					FORTH_DSP_VALUE 
4829 cd 6c 22			call macro_forth_dsp_value 
482c				endm 
# End of macro FORTH_DSP_VALUE
482c					;inc hl 
482c			 
482c eb					ex de, hl 
482d					if DEBUG_FORTH_WORDS 
482d						DMARK "S2a" 
482d f5				push af  
482e 3a 42 48			ld a, (.dmark)  
4831 32 6e fe			ld (debug_mark),a  
4834 3a 43 48			ld a, (.dmark+1)  
4837 32 6f fe			ld (debug_mark+1),a  
483a 3a 44 48			ld a, (.dmark+2)  
483d 32 70 fe			ld (debug_mark+2),a  
4840 18 03			jr .pastdmark  
4842 ..			.dmark: db "S2a"  
4845 f1			.pastdmark: pop af  
4846			endm  
# End of macro DMARK
4846						CALLMONITOR 
4846 cd c1 19			call break_point_state  
4849				endm  
# End of macro CALLMONITOR
4849					endif 
4849 cd 41 13				call string_to_uint16 
484c			 
484c					if DEBUG_FORTH_WORDS 
484c						DMARK "S2b" 
484c f5				push af  
484d 3a 61 48			ld a, (.dmark)  
4850 32 6e fe			ld (debug_mark),a  
4853 3a 62 48			ld a, (.dmark+1)  
4856 32 6f fe			ld (debug_mark+1),a  
4859 3a 63 48			ld a, (.dmark+2)  
485c 32 70 fe			ld (debug_mark+2),a  
485f 18 03			jr .pastdmark  
4861 ..			.dmark: db "S2b"  
4864 f1			.pastdmark: pop af  
4865			endm  
# End of macro DMARK
4865						CALLMONITOR 
4865 cd c1 19			call break_point_state  
4868				endm  
# End of macro CALLMONITOR
4868					endif 
4868			;		push hl 
4868					FORTH_DSP_POP 
4868 cd 3b 23			call macro_forth_dsp_pop 
486b				endm 
# End of macro FORTH_DSP_POP
486b			;		pop hl 
486b					 
486b					if DEBUG_FORTH_WORDS 
486b						DMARK "S2b" 
486b f5				push af  
486c 3a 80 48			ld a, (.dmark)  
486f 32 6e fe			ld (debug_mark),a  
4872 3a 81 48			ld a, (.dmark+1)  
4875 32 6f fe			ld (debug_mark+1),a  
4878 3a 82 48			ld a, (.dmark+2)  
487b 32 70 fe			ld (debug_mark+2),a  
487e 18 03			jr .pastdmark  
4880 ..			.dmark: db "S2b"  
4883 f1			.pastdmark: pop af  
4884			endm  
# End of macro DMARK
4884						CALLMONITOR 
4884 cd c1 19			call break_point_state  
4887				endm  
# End of macro CALLMONITOR
4887					endif 
4887 cd 8c 20				call forth_push_numhl	 
488a			 
488a				 
488a				       NEXTW 
488a c3 39 24			jp macro_next 
488d				endm 
# End of macro NEXTW
488d			.NUM2STR: 
488d				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
488d 48				db WORD_SYS_CORE+52             
488e 9c 48			dw .CONCAT            
4890 08				db 7 + 1 
4891 .. 00			db "NUM2STR",0              
4899				endm 
# End of macro CWHEAD
4899			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4899			 
4899			;		; malloc a string to target 
4899			;		ld hl, 10     ; TODO max string size should be fine 
4899			;		call malloc 
4899			;		push hl    ; save malloc location 
4899			; 
4899			; 
4899			;; TODO check int type 
4899			;		FORTH_DSP_VALUEHL 
4899			;		ld a, l 
4899			;		call DispAToASCII   
4899			;;TODO need to chage above call to dump into string 
4899			; 
4899			; 
4899			 
4899				       NEXTW 
4899 c3 39 24			jp macro_next 
489c				endm 
# End of macro NEXTW
489c			 
489c			.CONCAT: 
489c				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
489c 48				db WORD_SYS_CORE+52             
489d 4f 49			dw .FIND            
489f 07				db 6 + 1 
48a0 .. 00			db "CONCAT",0              
48a7				endm 
# End of macro CWHEAD
48a7			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
48a7			 
48a7			; TODO check string type 
48a7			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
48a7			 
48a7					if DEBUG_FORTH_WORDS_KEY 
48a7						DMARK "CON" 
48a7 f5				push af  
48a8 3a bc 48			ld a, (.dmark)  
48ab 32 6e fe			ld (debug_mark),a  
48ae 3a bd 48			ld a, (.dmark+1)  
48b1 32 6f fe			ld (debug_mark+1),a  
48b4 3a be 48			ld a, (.dmark+2)  
48b7 32 70 fe			ld (debug_mark+2),a  
48ba 18 03			jr .pastdmark  
48bc ..			.dmark: db "CON"  
48bf f1			.pastdmark: pop af  
48c0			endm  
# End of macro DMARK
48c0						CALLMONITOR 
48c0 cd c1 19			call break_point_state  
48c3				endm  
# End of macro CALLMONITOR
48c3					endif 
48c3			 
48c3			 
48c3					FORTH_DSP_VALUE 
48c3 cd 6c 22			call macro_forth_dsp_value 
48c6				endm 
# End of macro FORTH_DSP_VALUE
48c6 e5					push hl   ; s2 
48c7			 
48c7					FORTH_DSP_POP 
48c7 cd 3b 23			call macro_forth_dsp_pop 
48ca				endm 
# End of macro FORTH_DSP_POP
48ca			 
48ca					FORTH_DSP_VALUE 
48ca cd 6c 22			call macro_forth_dsp_value 
48cd				endm 
# End of macro FORTH_DSP_VALUE
48cd			 
48cd e5					push hl   ; s1 
48ce			 
48ce					FORTH_DSP_POP 
48ce cd 3b 23			call macro_forth_dsp_pop 
48d1				endm 
# End of macro FORTH_DSP_POP
48d1					 
48d1			 
48d1					; copy s1 
48d1			 
48d1				 
48d1					; save ptr 
48d1 e1					pop hl  
48d2 e5					push hl 
48d3 3e 00				ld a, 0 
48d5 cd b5 13				call strlent 
48d8					;inc hl    ; zer0 
48d8 06 00				ld b, 0 
48da 4d					ld c, l 
48db e1					pop hl		 
48dc 11 c8 f1				ld de, scratch	 
48df					if DEBUG_FORTH_WORDS 
48df						DMARK "CO1" 
48df f5				push af  
48e0 3a f4 48			ld a, (.dmark)  
48e3 32 6e fe			ld (debug_mark),a  
48e6 3a f5 48			ld a, (.dmark+1)  
48e9 32 6f fe			ld (debug_mark+1),a  
48ec 3a f6 48			ld a, (.dmark+2)  
48ef 32 70 fe			ld (debug_mark+2),a  
48f2 18 03			jr .pastdmark  
48f4 ..			.dmark: db "CO1"  
48f7 f1			.pastdmark: pop af  
48f8			endm  
# End of macro DMARK
48f8						CALLMONITOR 
48f8 cd c1 19			call break_point_state  
48fb				endm  
# End of macro CALLMONITOR
48fb					endif 
48fb ed b0				ldir 
48fd			 
48fd e1					pop hl 
48fe e5					push hl 
48ff d5					push de 
4900			 
4900			 
4900 3e 00				ld a, 0 
4902 cd b5 13				call strlent 
4905 23					inc hl    ; zer0 
4906 23					inc hl 
4907 06 00				ld b, 0 
4909 4d					ld c, l 
490a d1					pop de 
490b e1					pop hl		 
490c					if DEBUG_FORTH_WORDS 
490c						DMARK "CO2" 
490c f5				push af  
490d 3a 21 49			ld a, (.dmark)  
4910 32 6e fe			ld (debug_mark),a  
4913 3a 22 49			ld a, (.dmark+1)  
4916 32 6f fe			ld (debug_mark+1),a  
4919 3a 23 49			ld a, (.dmark+2)  
491c 32 70 fe			ld (debug_mark+2),a  
491f 18 03			jr .pastdmark  
4921 ..			.dmark: db "CO2"  
4924 f1			.pastdmark: pop af  
4925			endm  
# End of macro DMARK
4925						CALLMONITOR 
4925 cd c1 19			call break_point_state  
4928				endm  
# End of macro CALLMONITOR
4928					endif 
4928 ed b0				ldir 
492a			 
492a			 
492a			 
492a 21 c8 f1				ld hl, scratch 
492d					if DEBUG_FORTH_WORDS 
492d						DMARK "CO5" 
492d f5				push af  
492e 3a 42 49			ld a, (.dmark)  
4931 32 6e fe			ld (debug_mark),a  
4934 3a 43 49			ld a, (.dmark+1)  
4937 32 6f fe			ld (debug_mark+1),a  
493a 3a 44 49			ld a, (.dmark+2)  
493d 32 70 fe			ld (debug_mark+2),a  
4940 18 03			jr .pastdmark  
4942 ..			.dmark: db "CO5"  
4945 f1			.pastdmark: pop af  
4946			endm  
# End of macro DMARK
4946						CALLMONITOR 
4946 cd c1 19			call break_point_state  
4949				endm  
# End of macro CALLMONITOR
4949					endif 
4949			 
4949 cd fa 20				call forth_push_str 
494c			 
494c			 
494c			 
494c			 
494c				       NEXTW 
494c c3 39 24			jp macro_next 
494f				endm 
# End of macro NEXTW
494f			 
494f			 
494f			.FIND: 
494f				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
494f 4b				db WORD_SYS_CORE+55             
4950 0d 4a			dw .LEN            
4952 05				db 4 + 1 
4953 .. 00			db "FIND",0              
4958				endm 
# End of macro CWHEAD
4958			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4958			 
4958					if DEBUG_FORTH_WORDS_KEY 
4958						DMARK "FND" 
4958 f5				push af  
4959 3a 6d 49			ld a, (.dmark)  
495c 32 6e fe			ld (debug_mark),a  
495f 3a 6e 49			ld a, (.dmark+1)  
4962 32 6f fe			ld (debug_mark+1),a  
4965 3a 6f 49			ld a, (.dmark+2)  
4968 32 70 fe			ld (debug_mark+2),a  
496b 18 03			jr .pastdmark  
496d ..			.dmark: db "FND"  
4970 f1			.pastdmark: pop af  
4971			endm  
# End of macro DMARK
4971						CALLMONITOR 
4971 cd c1 19			call break_point_state  
4974				endm  
# End of macro CALLMONITOR
4974					endif 
4974			 
4974			; TODO check string type 
4974					FORTH_DSP_VALUE 
4974 cd 6c 22			call macro_forth_dsp_value 
4977				endm 
# End of macro FORTH_DSP_VALUE
4977			 
4977 e5					push hl    
4978 7e					ld a,(hl)    ; char to find   
4979			; TODO change char to substr 
4979			 
4979 f5					push af 
497a					 
497a			 
497a			 
497a					if DEBUG_FORTH_WORDS 
497a						DMARK "FN1" 
497a f5				push af  
497b 3a 8f 49			ld a, (.dmark)  
497e 32 6e fe			ld (debug_mark),a  
4981 3a 90 49			ld a, (.dmark+1)  
4984 32 6f fe			ld (debug_mark+1),a  
4987 3a 91 49			ld a, (.dmark+2)  
498a 32 70 fe			ld (debug_mark+2),a  
498d 18 03			jr .pastdmark  
498f ..			.dmark: db "FN1"  
4992 f1			.pastdmark: pop af  
4993			endm  
# End of macro DMARK
4993						CALLMONITOR 
4993 cd c1 19			call break_point_state  
4996				endm  
# End of macro CALLMONITOR
4996					endif 
4996			 
4996					FORTH_DSP_POP 
4996 cd 3b 23			call macro_forth_dsp_pop 
4999				endm 
# End of macro FORTH_DSP_POP
4999			 
4999					; string to search 
4999			 
4999					FORTH_DSP_VALUE 
4999 cd 6c 22			call macro_forth_dsp_value 
499c				endm 
# End of macro FORTH_DSP_VALUE
499c			 
499c d1					pop de  ; d is char to find  
499d			 
499d					if DEBUG_FORTH_WORDS 
499d						DMARK "FN2" 
499d f5				push af  
499e 3a b2 49			ld a, (.dmark)  
49a1 32 6e fe			ld (debug_mark),a  
49a4 3a b3 49			ld a, (.dmark+1)  
49a7 32 6f fe			ld (debug_mark+1),a  
49aa 3a b4 49			ld a, (.dmark+2)  
49ad 32 70 fe			ld (debug_mark+2),a  
49b0 18 03			jr .pastdmark  
49b2 ..			.dmark: db "FN2"  
49b5 f1			.pastdmark: pop af  
49b6			endm  
# End of macro DMARK
49b6						CALLMONITOR 
49b6 cd c1 19			call break_point_state  
49b9				endm  
# End of macro CALLMONITOR
49b9					endif 
49b9					 
49b9 01 00 00				ld bc, 0 
49bc 7e			.findchar:      ld a,(hl) 
49bd fe 00				cp 0   		 
49bf 28 27				jr z, .finddone     
49c1 ba					cp d 
49c2 28 20				jr z, .foundchar 
49c4 03					inc bc 
49c5 23					inc hl 
49c6					if DEBUG_FORTH_WORDS 
49c6						DMARK "FN3" 
49c6 f5				push af  
49c7 3a db 49			ld a, (.dmark)  
49ca 32 6e fe			ld (debug_mark),a  
49cd 3a dc 49			ld a, (.dmark+1)  
49d0 32 6f fe			ld (debug_mark+1),a  
49d3 3a dd 49			ld a, (.dmark+2)  
49d6 32 70 fe			ld (debug_mark+2),a  
49d9 18 03			jr .pastdmark  
49db ..			.dmark: db "FN3"  
49de f1			.pastdmark: pop af  
49df			endm  
# End of macro DMARK
49df						CALLMONITOR 
49df cd c1 19			call break_point_state  
49e2				endm  
# End of macro CALLMONITOR
49e2					endif 
49e2 18 d8				jr .findchar 
49e4			 
49e4			 
49e4 c5			.foundchar:	push bc 
49e5 e1					pop hl 
49e6 18 03				jr .findexit 
49e8			 
49e8			 
49e8							 
49e8			 
49e8			.finddone:     ; got to end of string with no find 
49e8 21 00 00				ld hl, 0 
49eb			.findexit: 
49eb			 
49eb					if DEBUG_FORTH_WORDS 
49eb						DMARK "FNd" 
49eb f5				push af  
49ec 3a 00 4a			ld a, (.dmark)  
49ef 32 6e fe			ld (debug_mark),a  
49f2 3a 01 4a			ld a, (.dmark+1)  
49f5 32 6f fe			ld (debug_mark+1),a  
49f8 3a 02 4a			ld a, (.dmark+2)  
49fb 32 70 fe			ld (debug_mark+2),a  
49fe 18 03			jr .pastdmark  
4a00 ..			.dmark: db "FNd"  
4a03 f1			.pastdmark: pop af  
4a04			endm  
# End of macro DMARK
4a04						CALLMONITOR 
4a04 cd c1 19			call break_point_state  
4a07				endm  
# End of macro CALLMONITOR
4a07					endif 
4a07 cd 8c 20			call forth_push_numhl 
4a0a			 
4a0a				       NEXTW 
4a0a c3 39 24			jp macro_next 
4a0d				endm 
# End of macro NEXTW
4a0d			 
4a0d			.LEN: 
4a0d				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4a0d 4c				db WORD_SYS_CORE+56             
4a0e 77 4a			dw .ASC            
4a10 06				db 5 + 1 
4a11 .. 00			db "COUNT",0              
4a17				endm 
# End of macro CWHEAD
4a17			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4a17			 
4a17					if DEBUG_FORTH_WORDS_KEY 
4a17						DMARK "CNT" 
4a17 f5				push af  
4a18 3a 2c 4a			ld a, (.dmark)  
4a1b 32 6e fe			ld (debug_mark),a  
4a1e 3a 2d 4a			ld a, (.dmark+1)  
4a21 32 6f fe			ld (debug_mark+1),a  
4a24 3a 2e 4a			ld a, (.dmark+2)  
4a27 32 70 fe			ld (debug_mark+2),a  
4a2a 18 03			jr .pastdmark  
4a2c ..			.dmark: db "CNT"  
4a2f f1			.pastdmark: pop af  
4a30			endm  
# End of macro DMARK
4a30						CALLMONITOR 
4a30 cd c1 19			call break_point_state  
4a33				endm  
# End of macro CALLMONITOR
4a33					endif 
4a33			; TODO check string type 
4a33					FORTH_DSP_VALUE 
4a33 cd 6c 22			call macro_forth_dsp_value 
4a36				endm 
# End of macro FORTH_DSP_VALUE
4a36			 
4a36			 
4a36					if DEBUG_FORTH_WORDS 
4a36						DMARK "CN?" 
4a36 f5				push af  
4a37 3a 4b 4a			ld a, (.dmark)  
4a3a 32 6e fe			ld (debug_mark),a  
4a3d 3a 4c 4a			ld a, (.dmark+1)  
4a40 32 6f fe			ld (debug_mark+1),a  
4a43 3a 4d 4a			ld a, (.dmark+2)  
4a46 32 70 fe			ld (debug_mark+2),a  
4a49 18 03			jr .pastdmark  
4a4b ..			.dmark: db "CN?"  
4a4e f1			.pastdmark: pop af  
4a4f			endm  
# End of macro DMARK
4a4f						CALLMONITOR 
4a4f cd c1 19			call break_point_state  
4a52				endm  
# End of macro CALLMONITOR
4a52					endif 
4a52 cd aa 13				call strlenz 
4a55					if DEBUG_FORTH_WORDS 
4a55						DMARK "CNl" 
4a55 f5				push af  
4a56 3a 6a 4a			ld a, (.dmark)  
4a59 32 6e fe			ld (debug_mark),a  
4a5c 3a 6b 4a			ld a, (.dmark+1)  
4a5f 32 6f fe			ld (debug_mark+1),a  
4a62 3a 6c 4a			ld a, (.dmark+2)  
4a65 32 70 fe			ld (debug_mark+2),a  
4a68 18 03			jr .pastdmark  
4a6a ..			.dmark: db "CNl"  
4a6d f1			.pastdmark: pop af  
4a6e			endm  
# End of macro DMARK
4a6e						CALLMONITOR 
4a6e cd c1 19			call break_point_state  
4a71				endm  
# End of macro CALLMONITOR
4a71					endif 
4a71			 
4a71 cd 8c 20				call forth_push_numhl 
4a74			 
4a74			 
4a74			 
4a74				       NEXTW 
4a74 c3 39 24			jp macro_next 
4a77				endm 
# End of macro NEXTW
4a77			.ASC: 
4a77				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4a77 4d				db WORD_SYS_CORE+57             
4a78 e5 4a			dw .CHR            
4a7a 04				db 3 + 1 
4a7b .. 00			db "ASC",0              
4a7f				endm 
# End of macro CWHEAD
4a7f			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4a7f					if DEBUG_FORTH_WORDS_KEY 
4a7f						DMARK "ASC" 
4a7f f5				push af  
4a80 3a 94 4a			ld a, (.dmark)  
4a83 32 6e fe			ld (debug_mark),a  
4a86 3a 95 4a			ld a, (.dmark+1)  
4a89 32 6f fe			ld (debug_mark+1),a  
4a8c 3a 96 4a			ld a, (.dmark+2)  
4a8f 32 70 fe			ld (debug_mark+2),a  
4a92 18 03			jr .pastdmark  
4a94 ..			.dmark: db "ASC"  
4a97 f1			.pastdmark: pop af  
4a98			endm  
# End of macro DMARK
4a98						CALLMONITOR 
4a98 cd c1 19			call break_point_state  
4a9b				endm  
# End of macro CALLMONITOR
4a9b					endif 
4a9b					FORTH_DSP_VALUE 
4a9b cd 6c 22			call macro_forth_dsp_value 
4a9e				endm 
# End of macro FORTH_DSP_VALUE
4a9e					;v5 FORTH_DSP_VALUE 
4a9e			;		inc hl      ; now at start of numeric as string 
4a9e			 
4a9e e5					push hl 
4a9f			 
4a9f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a9f cd 3b 23			call macro_forth_dsp_pop 
4aa2				endm 
# End of macro FORTH_DSP_POP
4aa2			 
4aa2 e1					pop hl 
4aa3			 
4aa3					if DEBUG_FORTH_WORDS 
4aa3						DMARK "AS1" 
4aa3 f5				push af  
4aa4 3a b8 4a			ld a, (.dmark)  
4aa7 32 6e fe			ld (debug_mark),a  
4aaa 3a b9 4a			ld a, (.dmark+1)  
4aad 32 6f fe			ld (debug_mark+1),a  
4ab0 3a ba 4a			ld a, (.dmark+2)  
4ab3 32 70 fe			ld (debug_mark+2),a  
4ab6 18 03			jr .pastdmark  
4ab8 ..			.dmark: db "AS1"  
4abb f1			.pastdmark: pop af  
4abc			endm  
# End of macro DMARK
4abc						CALLMONITOR 
4abc cd c1 19			call break_point_state  
4abf				endm  
# End of macro CALLMONITOR
4abf					endif 
4abf					; push the content of a onto the stack as a value 
4abf			 
4abf 7e					ld a,(hl)   ; get char 
4ac0 26 00				ld h,0 
4ac2 6f					ld l,a 
4ac3					if DEBUG_FORTH_WORDS 
4ac3						DMARK "AS2" 
4ac3 f5				push af  
4ac4 3a d8 4a			ld a, (.dmark)  
4ac7 32 6e fe			ld (debug_mark),a  
4aca 3a d9 4a			ld a, (.dmark+1)  
4acd 32 6f fe			ld (debug_mark+1),a  
4ad0 3a da 4a			ld a, (.dmark+2)  
4ad3 32 70 fe			ld (debug_mark+2),a  
4ad6 18 03			jr .pastdmark  
4ad8 ..			.dmark: db "AS2"  
4adb f1			.pastdmark: pop af  
4adc			endm  
# End of macro DMARK
4adc						CALLMONITOR 
4adc cd c1 19			call break_point_state  
4adf				endm  
# End of macro CALLMONITOR
4adf					endif 
4adf cd 8c 20				call forth_push_numhl 
4ae2			 
4ae2				       NEXTW 
4ae2 c3 39 24			jp macro_next 
4ae5				endm 
# End of macro NEXTW
4ae5			 
4ae5			.CHR: 
4ae5				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4ae5 4d				db WORD_SYS_CORE+57             
4ae6 21 4b			dw .ENDSTR            
4ae8 04				db 3 + 1 
4ae9 .. 00			db "CHR",0              
4aed				endm 
# End of macro CWHEAD
4aed			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4aed					if DEBUG_FORTH_WORDS_KEY 
4aed						DMARK "CHR" 
4aed f5				push af  
4aee 3a 02 4b			ld a, (.dmark)  
4af1 32 6e fe			ld (debug_mark),a  
4af4 3a 03 4b			ld a, (.dmark+1)  
4af7 32 6f fe			ld (debug_mark+1),a  
4afa 3a 04 4b			ld a, (.dmark+2)  
4afd 32 70 fe			ld (debug_mark+2),a  
4b00 18 03			jr .pastdmark  
4b02 ..			.dmark: db "CHR"  
4b05 f1			.pastdmark: pop af  
4b06			endm  
# End of macro DMARK
4b06						CALLMONITOR 
4b06 cd c1 19			call break_point_state  
4b09				endm  
# End of macro CALLMONITOR
4b09					endif 
4b09					FORTH_DSP_VALUEHL 
4b09 cd 83 22			call macro_dsp_valuehl 
4b0c				endm 
# End of macro FORTH_DSP_VALUEHL
4b0c			 
4b0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b0c cd 3b 23			call macro_forth_dsp_pop 
4b0f				endm 
# End of macro FORTH_DSP_POP
4b0f			 
4b0f					; save asci byte as a zero term string and push string 
4b0f			 
4b0f 7d					ld a,l 
4b10 32 c8 f1				ld (scratch), a 
4b13			 
4b13 3e 00				ld a, 0 
4b15 32 c9 f1				ld (scratch+1), a 
4b18			 
4b18 21 c8 f1				ld hl, scratch 
4b1b cd fa 20				call forth_push_str 
4b1e			 
4b1e			 
4b1e				       NEXTW 
4b1e c3 39 24			jp macro_next 
4b21				endm 
# End of macro NEXTW
4b21			 
4b21			 
4b21			 
4b21			 
4b21			.ENDSTR: 
4b21			; eof 
4b21			 
# End of file forth_words_str.asm
4b21			include "forth_words_key.asm" 
4b21			 
4b21			; | ## Keyboard Words 
4b21			 
4b21			.KEY: 
4b21				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4b21 3e				db WORD_SYS_CORE+42             
4b22 51 4b			dw .WAITK            
4b24 04				db 3 + 1 
4b25 .. 00			db "KEY",0              
4b29				endm 
# End of macro CWHEAD
4b29			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4b29			 
4b29					if DEBUG_FORTH_WORDS_KEY 
4b29						DMARK "KEY" 
4b29 f5				push af  
4b2a 3a 3e 4b			ld a, (.dmark)  
4b2d 32 6e fe			ld (debug_mark),a  
4b30 3a 3f 4b			ld a, (.dmark+1)  
4b33 32 6f fe			ld (debug_mark+1),a  
4b36 3a 40 4b			ld a, (.dmark+2)  
4b39 32 70 fe			ld (debug_mark+2),a  
4b3c 18 03			jr .pastdmark  
4b3e ..			.dmark: db "KEY"  
4b41 f1			.pastdmark: pop af  
4b42			endm  
# End of macro DMARK
4b42						CALLMONITOR 
4b42 cd c1 19			call break_point_state  
4b45				endm  
# End of macro CALLMONITOR
4b45					endif 
4b45			; TODO currently waits 
4b45 cd 11 78				call cin 
4b48					;call cin_wait 
4b48 6f					ld l, a 
4b49 26 00				ld h, 0 
4b4b cd 8c 20				call forth_push_numhl 
4b4e					NEXTW 
4b4e c3 39 24			jp macro_next 
4b51				endm 
# End of macro NEXTW
4b51			.WAITK: 
4b51				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4b51 3f				db WORD_SYS_CORE+43             
4b52 83 4b			dw .ACCEPT            
4b54 06				db 5 + 1 
4b55 .. 00			db "WAITK",0              
4b5b				endm 
# End of macro CWHEAD
4b5b			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4b5b					if DEBUG_FORTH_WORDS_KEY 
4b5b						DMARK "WAI" 
4b5b f5				push af  
4b5c 3a 70 4b			ld a, (.dmark)  
4b5f 32 6e fe			ld (debug_mark),a  
4b62 3a 71 4b			ld a, (.dmark+1)  
4b65 32 6f fe			ld (debug_mark+1),a  
4b68 3a 72 4b			ld a, (.dmark+2)  
4b6b 32 70 fe			ld (debug_mark+2),a  
4b6e 18 03			jr .pastdmark  
4b70 ..			.dmark: db "WAI"  
4b73 f1			.pastdmark: pop af  
4b74			endm  
# End of macro DMARK
4b74						CALLMONITOR 
4b74 cd c1 19			call break_point_state  
4b77				endm  
# End of macro CALLMONITOR
4b77					endif 
4b77 cd 00 78				call cin_wait 
4b7a 6f					ld l, a 
4b7b 26 00				ld h, 0 
4b7d cd 8c 20				call forth_push_numhl 
4b80					NEXTW 
4b80 c3 39 24			jp macro_next 
4b83				endm 
# End of macro NEXTW
4b83			.ACCEPT: 
4b83				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4b83 40				db WORD_SYS_CORE+44             
4b84 e1 4b			dw .EDIT            
4b86 07				db 6 + 1 
4b87 .. 00			db "ACCEPT",0              
4b8e				endm 
# End of macro CWHEAD
4b8e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4b8e					; TODO crashes on push 
4b8e					if DEBUG_FORTH_WORDS_KEY 
4b8e						DMARK "ACC" 
4b8e f5				push af  
4b8f 3a a3 4b			ld a, (.dmark)  
4b92 32 6e fe			ld (debug_mark),a  
4b95 3a a4 4b			ld a, (.dmark+1)  
4b98 32 6f fe			ld (debug_mark+1),a  
4b9b 3a a5 4b			ld a, (.dmark+2)  
4b9e 32 70 fe			ld (debug_mark+2),a  
4ba1 18 03			jr .pastdmark  
4ba3 ..			.dmark: db "ACC"  
4ba6 f1			.pastdmark: pop af  
4ba7			endm  
# End of macro DMARK
4ba7						CALLMONITOR 
4ba7 cd c1 19			call break_point_state  
4baa				endm  
# End of macro CALLMONITOR
4baa					endif 
4baa 21 c6 f3				ld hl, os_input 
4bad 3e 00				ld a, 0 
4baf 77					ld (hl),a 
4bb0 3a 65 fa				ld a,(f_cursor_ptr) 
4bb3 16 64				ld d, 100 
4bb5 0e 00				ld c, 0 
4bb7 1e 28				ld e, 40 
4bb9 cd 79 0f				call input_str 
4bbc					; TODO perhaps do a type check and wrap in quotes if not a number 
4bbc 21 c6 f3				ld hl, os_input 
4bbf					if DEBUG_FORTH_WORDS 
4bbf						DMARK "AC1" 
4bbf f5				push af  
4bc0 3a d4 4b			ld a, (.dmark)  
4bc3 32 6e fe			ld (debug_mark),a  
4bc6 3a d5 4b			ld a, (.dmark+1)  
4bc9 32 6f fe			ld (debug_mark+1),a  
4bcc 3a d6 4b			ld a, (.dmark+2)  
4bcf 32 70 fe			ld (debug_mark+2),a  
4bd2 18 03			jr .pastdmark  
4bd4 ..			.dmark: db "AC1"  
4bd7 f1			.pastdmark: pop af  
4bd8			endm  
# End of macro DMARK
4bd8						CALLMONITOR 
4bd8 cd c1 19			call break_point_state  
4bdb				endm  
# End of macro CALLMONITOR
4bdb					endif 
4bdb cd fa 20				call forth_push_str 
4bde					NEXTW 
4bde c3 39 24			jp macro_next 
4be1				endm 
# End of macro NEXTW
4be1			 
4be1			.EDIT: 
4be1				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4be1 40				db WORD_SYS_CORE+44             
4be2 83 4c			dw .DEDIT            
4be4 05				db 4 + 1 
4be5 .. 00			db "EDIT",0              
4bea				endm 
# End of macro CWHEAD
4bea			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4bea			 
4bea					; TODO does not copy from stack 
4bea					if DEBUG_FORTH_WORDS_KEY 
4bea						DMARK "EDT" 
4bea f5				push af  
4beb 3a ff 4b			ld a, (.dmark)  
4bee 32 6e fe			ld (debug_mark),a  
4bf1 3a 00 4c			ld a, (.dmark+1)  
4bf4 32 6f fe			ld (debug_mark+1),a  
4bf7 3a 01 4c			ld a, (.dmark+2)  
4bfa 32 70 fe			ld (debug_mark+2),a  
4bfd 18 03			jr .pastdmark  
4bff ..			.dmark: db "EDT"  
4c02 f1			.pastdmark: pop af  
4c03			endm  
# End of macro DMARK
4c03						CALLMONITOR 
4c03 cd c1 19			call break_point_state  
4c06				endm  
# End of macro CALLMONITOR
4c06					endif 
4c06			 
4c06					;FORTH_DSP 
4c06					FORTH_DSP_VALUEHL 
4c06 cd 83 22			call macro_dsp_valuehl 
4c09				endm 
# End of macro FORTH_DSP_VALUEHL
4c09			;		inc hl    ; TODO do type check 
4c09			 
4c09			;		call get_word_hl 
4c09 e5					push hl 
4c0a					if DEBUG_FORTH_WORDS 
4c0a						DMARK "EDp" 
4c0a f5				push af  
4c0b 3a 1f 4c			ld a, (.dmark)  
4c0e 32 6e fe			ld (debug_mark),a  
4c11 3a 20 4c			ld a, (.dmark+1)  
4c14 32 6f fe			ld (debug_mark+1),a  
4c17 3a 21 4c			ld a, (.dmark+2)  
4c1a 32 70 fe			ld (debug_mark+2),a  
4c1d 18 03			jr .pastdmark  
4c1f ..			.dmark: db "EDp"  
4c22 f1			.pastdmark: pop af  
4c23			endm  
# End of macro DMARK
4c23						CALLMONITOR 
4c23 cd c1 19			call break_point_state  
4c26				endm  
# End of macro CALLMONITOR
4c26					endif 
4c26				;	ld a, 0 
4c26 cd aa 13				call strlenz 
4c29 23					inc hl 
4c2a			 
4c2a 06 00				ld b, 0 
4c2c 4d					ld c, l 
4c2d			 
4c2d e1					pop hl 
4c2e 11 c6 f3				ld de, os_input 
4c31					if DEBUG_FORTH_WORDS_KEY 
4c31						DMARK "EDc" 
4c31 f5				push af  
4c32 3a 46 4c			ld a, (.dmark)  
4c35 32 6e fe			ld (debug_mark),a  
4c38 3a 47 4c			ld a, (.dmark+1)  
4c3b 32 6f fe			ld (debug_mark+1),a  
4c3e 3a 48 4c			ld a, (.dmark+2)  
4c41 32 70 fe			ld (debug_mark+2),a  
4c44 18 03			jr .pastdmark  
4c46 ..			.dmark: db "EDc"  
4c49 f1			.pastdmark: pop af  
4c4a			endm  
# End of macro DMARK
4c4a						CALLMONITOR 
4c4a cd c1 19			call break_point_state  
4c4d				endm  
# End of macro CALLMONITOR
4c4d					endif 
4c4d ed b0				ldir 
4c4f			 
4c4f			 
4c4f 21 c6 f3				ld hl, os_input 
4c52					;ld a, 0 
4c52					;ld (hl),a 
4c52 3a 65 fa				ld a,(f_cursor_ptr) 
4c55 16 64				ld d, 100 
4c57 0e 00				ld c, 0 
4c59 1e 28				ld e, 40 
4c5b cd 79 0f				call input_str 
4c5e					; TODO perhaps do a type check and wrap in quotes if not a number 
4c5e 21 c6 f3				ld hl, os_input 
4c61					if DEBUG_FORTH_WORDS 
4c61						DMARK "ED1" 
4c61 f5				push af  
4c62 3a 76 4c			ld a, (.dmark)  
4c65 32 6e fe			ld (debug_mark),a  
4c68 3a 77 4c			ld a, (.dmark+1)  
4c6b 32 6f fe			ld (debug_mark+1),a  
4c6e 3a 78 4c			ld a, (.dmark+2)  
4c71 32 70 fe			ld (debug_mark+2),a  
4c74 18 03			jr .pastdmark  
4c76 ..			.dmark: db "ED1"  
4c79 f1			.pastdmark: pop af  
4c7a			endm  
# End of macro DMARK
4c7a						CALLMONITOR 
4c7a cd c1 19			call break_point_state  
4c7d				endm  
# End of macro CALLMONITOR
4c7d					endif 
4c7d cd fa 20				call forth_push_str 
4c80					NEXTW 
4c80 c3 39 24			jp macro_next 
4c83				endm 
# End of macro NEXTW
4c83			 
4c83			.DEDIT: 
4c83				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4c83 40				db WORD_SYS_CORE+44             
4c84 e5 4c			dw .ENDKEY            
4c86 06				db 5 + 1 
4c87 .. 00			db "DEDIT",0              
4c8d				endm 
# End of macro CWHEAD
4c8d			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4c8d			 
4c8d					; TODO does not copy from stack 
4c8d					if DEBUG_FORTH_WORDS_KEY 
4c8d						DMARK "DED" 
4c8d f5				push af  
4c8e 3a a2 4c			ld a, (.dmark)  
4c91 32 6e fe			ld (debug_mark),a  
4c94 3a a3 4c			ld a, (.dmark+1)  
4c97 32 6f fe			ld (debug_mark+1),a  
4c9a 3a a4 4c			ld a, (.dmark+2)  
4c9d 32 70 fe			ld (debug_mark+2),a  
4ca0 18 03			jr .pastdmark  
4ca2 ..			.dmark: db "DED"  
4ca5 f1			.pastdmark: pop af  
4ca6			endm  
# End of macro DMARK
4ca6						CALLMONITOR 
4ca6 cd c1 19			call break_point_state  
4ca9				endm  
# End of macro CALLMONITOR
4ca9					endif 
4ca9			 
4ca9					;FORTH_DSP 
4ca9					FORTH_DSP_VALUEHL 
4ca9 cd 83 22			call macro_dsp_valuehl 
4cac				endm 
# End of macro FORTH_DSP_VALUEHL
4cac			;		inc hl    ; TODO do type check 
4cac			 
4cac			;		call get_word_hl 
4cac e5					push hl 
4cad e5					push hl 
4cae					FORTH_DSP_POP 
4cae cd 3b 23			call macro_forth_dsp_pop 
4cb1				endm 
# End of macro FORTH_DSP_POP
4cb1 e1					pop hl 
4cb2					if DEBUG_FORTH_WORDS 
4cb2						DMARK "EDp" 
4cb2 f5				push af  
4cb3 3a c7 4c			ld a, (.dmark)  
4cb6 32 6e fe			ld (debug_mark),a  
4cb9 3a c8 4c			ld a, (.dmark+1)  
4cbc 32 6f fe			ld (debug_mark+1),a  
4cbf 3a c9 4c			ld a, (.dmark+2)  
4cc2 32 70 fe			ld (debug_mark+2),a  
4cc5 18 03			jr .pastdmark  
4cc7 ..			.dmark: db "EDp"  
4cca f1			.pastdmark: pop af  
4ccb			endm  
# End of macro DMARK
4ccb						CALLMONITOR 
4ccb cd c1 19			call break_point_state  
4cce				endm  
# End of macro CALLMONITOR
4cce					endif 
4cce				;	ld a, 0 
4cce cd aa 13				call strlenz 
4cd1 23					inc hl 
4cd2			 
4cd2 06 00				ld b, 0 
4cd4 4d					ld c, l 
4cd5			 
4cd5 e1					pop hl 
4cd6			 
4cd6					;ld a, 0 
4cd6					;ld (hl),a 
4cd6 3a 65 fa				ld a,(f_cursor_ptr) 
4cd9 16 64				ld d, 100 
4cdb 0e 00				ld c, 0 
4cdd 1e 28				ld e, 40 
4cdf cd 79 0f				call input_str 
4ce2					; TODO perhaps do a type check and wrap in quotes if not a number 
4ce2					NEXTW 
4ce2 c3 39 24			jp macro_next 
4ce5				endm 
# End of macro NEXTW
4ce5			 
4ce5			 
4ce5			.ENDKEY: 
4ce5			; eof 
4ce5			 
# End of file forth_words_key.asm
4ce5			include "forth_words_const.asm" 
4ce5			 
4ce5			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4ce5			 
4ce5			 
4ce5			.SPITIME: 
4ce5				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4ce5 77				db WORD_SYS_CORE+99             
4ce6 fa 4c			dw .VA            
4ce8 08				db 7 + 1 
4ce9 .. 00			db "SPITIME",0              
4cf1				endm 
# End of macro CWHEAD
4cf1			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4cf1			; 
4cf1			; | If using BANK devices then leave as is. 
4cf1			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4cf1			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4cf1			 
4cf1 21 6b fa				ld hl, spi_clktime  
4cf4 cd 8c 20				call forth_push_numhl 
4cf7			 
4cf7					NEXTW 
4cf7 c3 39 24			jp macro_next 
4cfa				endm 
# End of macro NEXTW
4cfa			 
4cfa			 
4cfa			.VA: 
4cfa				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4cfa 77				db WORD_SYS_CORE+99             
4cfb 0a 4d			dw .SYMBOL            
4cfd 03				db 2 + 1 
4cfe .. 00			db "VA",0              
4d01				endm 
# End of macro CWHEAD
4d01			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4d01 21 2f fa				ld hl, cli_var_array 
4d04 cd 8c 20				call forth_push_numhl 
4d07			 
4d07					NEXTW 
4d07 c3 39 24			jp macro_next 
4d0a				endm 
# End of macro NEXTW
4d0a			 
4d0a			.SYMBOL: 
4d0a				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4d0a 77				db WORD_SYS_CORE+99             
4d0b 42 4e			dw .ENDCONST            
4d0d 07				db 6 + 1 
4d0e .. 00			db "SYMBOL",0              
4d15				endm 
# End of macro CWHEAD
4d15			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4d15			; | 
4d15			; | The value is the number reference and the final address is pushed to stack 
4d15			 
4d15					if DEBUG_FORTH_WORDS_KEY 
4d15						DMARK "SYM" 
4d15 f5				push af  
4d16 3a 2a 4d			ld a, (.dmark)  
4d19 32 6e fe			ld (debug_mark),a  
4d1c 3a 2b 4d			ld a, (.dmark+1)  
4d1f 32 6f fe			ld (debug_mark+1),a  
4d22 3a 2c 4d			ld a, (.dmark+2)  
4d25 32 70 fe			ld (debug_mark+2),a  
4d28 18 03			jr .pastdmark  
4d2a ..			.dmark: db "SYM"  
4d2d f1			.pastdmark: pop af  
4d2e			endm  
# End of macro DMARK
4d2e						CALLMONITOR 
4d2e cd c1 19			call break_point_state  
4d31				endm  
# End of macro CALLMONITOR
4d31					endif 
4d31			 
4d31					FORTH_DSP_VALUEHL 
4d31 cd 83 22			call macro_dsp_valuehl 
4d34				endm 
# End of macro FORTH_DSP_VALUEHL
4d34			 
4d34 7d					ld a, l     
4d35			 
4d35			 
4d35					if DEBUG_FORTH_WORDS 
4d35						DMARK "SY1" 
4d35 f5				push af  
4d36 3a 4a 4d			ld a, (.dmark)  
4d39 32 6e fe			ld (debug_mark),a  
4d3c 3a 4b 4d			ld a, (.dmark+1)  
4d3f 32 6f fe			ld (debug_mark+1),a  
4d42 3a 4c 4d			ld a, (.dmark+2)  
4d45 32 70 fe			ld (debug_mark+2),a  
4d48 18 03			jr .pastdmark  
4d4a ..			.dmark: db "SY1"  
4d4d f1			.pastdmark: pop af  
4d4e			endm  
# End of macro DMARK
4d4e						CALLMONITOR 
4d4e cd c1 19			call break_point_state  
4d51				endm  
# End of macro CALLMONITOR
4d51					endif 
4d51					 
4d51 f5					push af	 
4d52					FORTH_DSP_POP 
4d52 cd 3b 23			call macro_forth_dsp_pop 
4d55				endm 
# End of macro FORTH_DSP_POP
4d55 f1					pop af 
4d56			 
4d56 cb 27				sla a  
4d58				 
4d58					 
4d58					if DEBUG_FORTH_WORDS 
4d58						DMARK "SY" 
4d58 f5				push af  
4d59 3a 6d 4d			ld a, (.dmark)  
4d5c 32 6e fe			ld (debug_mark),a  
4d5f 3a 6e 4d			ld a, (.dmark+1)  
4d62 32 6f fe			ld (debug_mark+1),a  
4d65 3a 6f 4d			ld a, (.dmark+2)  
4d68 32 70 fe			ld (debug_mark+2),a  
4d6b 18 02			jr .pastdmark  
4d6d ..			.dmark: db "SY"  
4d6f f1			.pastdmark: pop af  
4d70			endm  
# End of macro DMARK
4d70						CALLMONITOR 
4d70 cd c1 19			call break_point_state  
4d73				endm  
# End of macro CALLMONITOR
4d73					endif 
4d73			 
4d73 21 82 4d				ld hl, sym_table 
4d76 cd 4c 0f				call addatohl 
4d79 cd bb 23				call loadwordinhl 
4d7c cd 8c 20				call forth_push_numhl 
4d7f			 
4d7f			 
4d7f				       NEXTW 
4d7f c3 39 24			jp macro_next 
4d82				endm 
# End of macro NEXTW
4d82			 
4d82			sym_table: 
4d82			 
4d82			; 0 
4d82 43 fa		dw cli_autodisplay 
4d84 51 fa		dw cli_buffer 
4d86 f5 f9		dw cli_data_sp 
4d88 2f f7		dw cli_data_stack 
4d8a 4b fa		dw cli_execword 
4d8c f7 f9		dw cli_loop_sp 
4d8e 31 f9		dw cli_loop_stack 
4d90 44 fa		dw cli_mvdot 
4d92 49 fa		dw cli_nextword 
4d94 45 fa		dw cli_origptr 
4d96 4f fa		dw cli_origtoken 
4d98			; 11 
4d98 47 fa		dw cli_ptr 
4d9a f9 f9		dw cli_ret_sp 
4d9c b3 f9		dw cli_ret_stack 
4d9e 4d fa		dw cli_token 
4da0 2f fa		dw cli_var_array 
4da2 cb fb		dw cursor_col 
4da4 c9 fb		dw cursor_ptr 
4da6 ca fb		dw cursor_row 
4da8 c7 fb		dw cursor_shape 
4daa 6e fe		dw debug_mark 
4dac			; 21 
4dac b4 fd		dw display_fb0 
4dae 13 fd		dw display_fb1 
4db0 d1 fb		dw display_fb2 
4db2 72 fc		dw display_fb3 
4db4 cf fb		dw display_fb_active 
4db6 c7 f2		dw execscratch 
4db8 65 fa		dw f_cursor_ptr 
4dba 72 fe		dw hardware_word 
4dbc 65 fe		dw input_at_cursor 
4dbe 67 fe		dw input_at_pos 
4dc0			; 31 
4dc0 63 fe		dw input_cur_flash 
4dc2 62 fe		dw input_cur_onoff 
4dc4 58 fe		dw input_cursor 
4dc6 68 fe		dw input_display_size 
4dc8 5d fe		dw input_len 
4dca 6c fe		dw input_ptr 
4dcc 69 fe		dw input_size 
4dce 6a fe		dw input_start 
4dd0 79 0f		dw input_str 
4dd2 66 fe		dw input_under_cursor 
4dd4			; 41 
4dd4 57 fe		dw key_actual_pressed 
4dd6 82 fe		dw key_fa 
4dd8 7e fe		dw key_face_held 
4dda 81 fe		dw key_fb 
4ddc 80 fe		dw key_fc 
4dde 7f fe		dw key_fd 
4de0 88 fe		dw key_held 
4de2 87 fe		dw key_held_prev 
4de4 31 77		dw key_init 
4de6 83 fe		dw key_repeat_ct 
4de8			; 51 
4de8 05 00		dw key_rows 
4dea 55 fe		dw key_shift 
4dec 56 fe		dw key_symbol 
4dee 89 fe		dw keyscan_scancol 
4df0 93 fe		dw keyscan_table 
4df2 f2 fe		dw keyscan_table_row1 
4df4 e7 fe		dw keyscan_table_row2 
4df6 dc fe		dw keyscan_table_row3 
4df8 d1 fe		dw keyscan_table_row4 
4dfa c6 fe		dw keyscan_table_row5 
4dfc			; 61 
4dfc ef f4		dw os_cli_cmd 
4dfe eb f4		dw os_cur_ptr 
4e00 ed f4		dw os_current_i 
4e02 c6 f3		dw os_input 
4e04 ee f5		dw os_last_cmd 
4e06 c5 f4		dw os_last_new_uword 
4e08 b9 f1		dw os_view_disable 
4e0a b5 f1		dw os_view_hl 
4e0c cd f4		dw os_word_scratch 
4e0e c3 00		dw portbctl 
4e10			; 71 
4e10 c1 00		dw portbdata 
4e12 6a fa		dw spi_cartdev 
4e14 69 fa		dw spi_cartdev2 
4e16 6b fa		dw spi_clktime 
4e18 67 fa		dw spi_device 
4e1a 66 fa		dw spi_device_id 
4e1c 68 fa		dw spi_portbyte 
4e1e ad fb		dw stackstore 
4e20			if STORAGE_SE 
4e20 82 00		dw storage_actl 
4e22 80 00		dw storage_adata 
4e24			else 
4e24			dw 0 
4e24			dw 0 
4e24			endif 
4e24			; 81 
4e24 0c 0b		dw storage_append 
4e26			if STORAGE_SE 
4e26 83 00		dw storage_bctl 
4e28			else 
4e28			dw 0 
4e28			endif 
4e28 99 fb		dw store_bank_active 
4e2a 6e fa		dw store_filecache 
4e2c 7c fa		dw store_longread 
4e2e 72 fa		dw store_openaddr 
4e30 71 fa		dw store_openext 
4e32 70 fa		dw store_openmaxext 
4e34 81 fa		dw store_page 
4e36 7d fa		dw store_readbuf 
4e38			; 91 
4e38 74 fa		dw store_readcont 
4e3a 7f fa		dw store_readptr 
4e3c 74 fa		dw store_tmpext 
4e3e 75 fa		dw store_tmpid 
4e40 6c fa		dw store_tmppageid 
4e42			 
4e42			 
4e42			.ENDCONST: 
4e42			 
4e42			; eof 
4e42			 
4e42			 
# End of file forth_words_const.asm
4e42			 
4e42			if STORAGE_SE 
4e42			   	include "forth_words_storage.asm" 
4e42			 
4e42			; | ## Fixed Storage Words 
4e42			 
4e42			.RENAME: 
4e42			  
4e42				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4e42 3a				db WORD_SYS_CORE+38             
4e43 38 4f			dw .RECORD            
4e45 07				db 6 + 1 
4e46 .. 00			db "RENAME",0              
4e4d				endm 
# End of macro CWHEAD
4e4d			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4e4d			; | | Compatible with PicoSPINet  
4e4d					if DEBUG_FORTH_WORDS_KEY 
4e4d						DMARK "REN" 
4e4d f5				push af  
4e4e 3a 62 4e			ld a, (.dmark)  
4e51 32 6e fe			ld (debug_mark),a  
4e54 3a 63 4e			ld a, (.dmark+1)  
4e57 32 6f fe			ld (debug_mark+1),a  
4e5a 3a 64 4e			ld a, (.dmark+2)  
4e5d 32 70 fe			ld (debug_mark+2),a  
4e60 18 03			jr .pastdmark  
4e62 ..			.dmark: db "REN"  
4e65 f1			.pastdmark: pop af  
4e66			endm  
# End of macro DMARK
4e66						CALLMONITOR 
4e66 cd c1 19			call break_point_state  
4e69				endm  
# End of macro CALLMONITOR
4e69					endif 
4e69			 
4e69			 
4e69					; preserve some internal vars used by other file handing routines 
4e69			 
4e69 2a 72 fa				ld hl, (store_openaddr) 
4e6c e5					push hl 
4e6d 3a 74 fa				ld a, (store_readcont) 
4e70 f5					push af 
4e71			 
4e71					FORTH_DSP_VALUEHL 
4e71 cd 83 22			call macro_dsp_valuehl 
4e74				endm 
# End of macro FORTH_DSP_VALUEHL
4e74			 
4e74					; move ext and id around for the file header 
4e74			 
4e74 65					ld h, l 
4e75 2e 00				ld l, 0 
4e77			 
4e77 e5					push hl    ; id 
4e78			 
4e78					FORTH_DSP_POP 
4e78 cd 3b 23			call macro_forth_dsp_pop 
4e7b				endm 
# End of macro FORTH_DSP_POP
4e7b			 
4e7b					; Locate the file header 
4e7b			 
4e7b e1					pop hl 
4e7c e5					push hl 
4e7d 11 81 fa				ld de, store_page      ; get block zero of file 
4e80					if DEBUG_FORTH_WORDS 
4e80						DMARK "REr" 
4e80 f5				push af  
4e81 3a 95 4e			ld a, (.dmark)  
4e84 32 6e fe			ld (debug_mark),a  
4e87 3a 96 4e			ld a, (.dmark+1)  
4e8a 32 6f fe			ld (debug_mark+1),a  
4e8d 3a 97 4e			ld a, (.dmark+2)  
4e90 32 70 fe			ld (debug_mark+2),a  
4e93 18 03			jr .pastdmark  
4e95 ..			.dmark: db "REr"  
4e98 f1			.pastdmark: pop af  
4e99			endm  
# End of macro DMARK
4e99						CALLMONITOR 
4e99 cd c1 19			call break_point_state  
4e9c				endm  
# End of macro CALLMONITOR
4e9c					endif 
4e9c cd 75 09				call storage_read 
4e9f			 
4e9f cd 75 0f			call ishlzero 
4ea2 20 05			jr nz, .rnfound 
4ea4			 
4ea4				; file does not exist so indicate with 255 extents in use 
4ea4			 
4ea4 3e ff			ld a, 255 
4ea6 e1				pop hl ; clear dup hl 
4ea7 18 7b			jr .skiprneof 
4ea9			 
4ea9			 
4ea9			.rnfound: 
4ea9					; file found so rename 
4ea9			 
4ea9					FORTH_DSP_VALUEHL 
4ea9 cd 83 22			call macro_dsp_valuehl 
4eac				endm 
# End of macro FORTH_DSP_VALUEHL
4eac			 
4eac e5				push hl 
4ead 3e 00			ld a, 0 
4eaf cd b5 13			call strlent 
4eb2 23				inc hl   ; cover zero term 
4eb3 06 00			ld b,0 
4eb5 4d				ld c,l 
4eb6 e1				pop hl 
4eb7 11 84 fa				ld de, store_page + 3 
4eba ed b0				ldir 
4ebc			 
4ebc 11 81 fa				ld de, store_page 
4ebf					if DEBUG_FORTH_WORDS 
4ebf						DMARK "RER" 
4ebf f5				push af  
4ec0 3a d4 4e			ld a, (.dmark)  
4ec3 32 6e fe			ld (debug_mark),a  
4ec6 3a d5 4e			ld a, (.dmark+1)  
4ec9 32 6f fe			ld (debug_mark+1),a  
4ecc 3a d6 4e			ld a, (.dmark+2)  
4ecf 32 70 fe			ld (debug_mark+2),a  
4ed2 18 03			jr .pastdmark  
4ed4 ..			.dmark: db "RER"  
4ed7 f1			.pastdmark: pop af  
4ed8			endm  
# End of macro DMARK
4ed8						CALLMONITOR 
4ed8 cd c1 19			call break_point_state  
4edb				endm  
# End of macro CALLMONITOR
4edb					endif 
4edb			 
4edb e1					pop hl    ; get orig file id and mangle it for find id 
4edc 55					ld d, l 
4edd 5c					ld e, h 
4ede			 
4ede 21 00 00				ld hl, 0 
4ee1					if DEBUG_FORTH_WORDS 
4ee1						DMARK "REf" 
4ee1 f5				push af  
4ee2 3a f6 4e			ld a, (.dmark)  
4ee5 32 6e fe			ld (debug_mark),a  
4ee8 3a f7 4e			ld a, (.dmark+1)  
4eeb 32 6f fe			ld (debug_mark+1),a  
4eee 3a f8 4e			ld a, (.dmark+2)  
4ef1 32 70 fe			ld (debug_mark+2),a  
4ef4 18 03			jr .pastdmark  
4ef6 ..			.dmark: db "REf"  
4ef9 f1			.pastdmark: pop af  
4efa			endm  
# End of macro DMARK
4efa						CALLMONITOR 
4efa cd c1 19			call break_point_state  
4efd				endm  
# End of macro CALLMONITOR
4efd					endif 
4efd cd 4f 07				call storage_findnextid 
4f00 11 81 fa				ld de, store_page 
4f03					if DEBUG_FORTH_WORDS 
4f03						DMARK "REw" 
4f03 f5				push af  
4f04 3a 18 4f			ld a, (.dmark)  
4f07 32 6e fe			ld (debug_mark),a  
4f0a 3a 19 4f			ld a, (.dmark+1)  
4f0d 32 6f fe			ld (debug_mark+1),a  
4f10 3a 1a 4f			ld a, (.dmark+2)  
4f13 32 70 fe			ld (debug_mark+2),a  
4f16 18 03			jr .pastdmark  
4f18 ..			.dmark: db "REw"  
4f1b f1			.pastdmark: pop af  
4f1c			endm  
# End of macro DMARK
4f1c						CALLMONITOR 
4f1c cd c1 19			call break_point_state  
4f1f				endm  
# End of macro CALLMONITOR
4f1f					endif 
4f1f cd 81 04				call storage_write_block 
4f22			 
4f22 3e 00				ld a, 0 
4f24			.skiprneof: 
4f24					; drop file name 
4f24					FORTH_DSP_POP 
4f24 cd 3b 23			call macro_forth_dsp_pop 
4f27				endm 
# End of macro FORTH_DSP_POP
4f27			 
4f27 6f					ld l, a 
4f28 26 00				ld h, 0 
4f2a cd 8c 20				call forth_push_numhl 
4f2d			 
4f2d			 
4f2d f1					pop af 
4f2e 32 74 fa				ld (store_readcont),a 
4f31 e1					pop hl 
4f32 22 72 fa				ld (store_openaddr), hl 
4f35						 
4f35				NEXTW 
4f35 c3 39 24			jp macro_next 
4f38				endm 
# End of macro NEXTW
4f38			.RECORD: 
4f38			  
4f38				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4f38 3a				db WORD_SYS_CORE+38             
4f39 dc 4f			dw .BREAD            
4f3b 07				db 6 + 1 
4f3c .. 00			db "RECORD",0              
4f43				endm 
# End of macro CWHEAD
4f43			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4f43			; | | Compatible with PicoSPINet  
4f43			 
4f43					if DEBUG_FORTH_WORDS_KEY 
4f43						DMARK "REC" 
4f43 f5				push af  
4f44 3a 58 4f			ld a, (.dmark)  
4f47 32 6e fe			ld (debug_mark),a  
4f4a 3a 59 4f			ld a, (.dmark+1)  
4f4d 32 6f fe			ld (debug_mark+1),a  
4f50 3a 5a 4f			ld a, (.dmark+2)  
4f53 32 70 fe			ld (debug_mark+2),a  
4f56 18 03			jr .pastdmark  
4f58 ..			.dmark: db "REC"  
4f5b f1			.pastdmark: pop af  
4f5c			endm  
# End of macro DMARK
4f5c						CALLMONITOR 
4f5c cd c1 19			call break_point_state  
4f5f				endm  
# End of macro CALLMONITOR
4f5f					endif 
4f5f			 
4f5f					FORTH_DSP_VALUEHL 
4f5f cd 83 22			call macro_dsp_valuehl 
4f62				endm 
# End of macro FORTH_DSP_VALUEHL
4f62			 
4f62 e5					push hl    ; id 
4f63			 
4f63					FORTH_DSP_POP 
4f63 cd 3b 23			call macro_forth_dsp_pop 
4f66				endm 
# End of macro FORTH_DSP_POP
4f66			 
4f66					FORTH_DSP_VALUEHL 
4f66 cd 83 22			call macro_dsp_valuehl 
4f69				endm 
# End of macro FORTH_DSP_VALUEHL
4f69			 
4f69					FORTH_DSP_POP 
4f69 cd 3b 23			call macro_forth_dsp_pop 
4f6c				endm 
# End of macro FORTH_DSP_POP
4f6c			 
4f6c d1					pop de     ; get file id 
4f6d			 
4f6d					; e = file id 
4f6d					; l = file extent 
4f6d			 
4f6d			 
4f6d					; construct request to access file extent 
4f6d			 
4f6d			;		ld a, e 
4f6d 63					ld h, e 
4f6e					 
4f6e					 
4f6e					 
4f6e			 
4f6e					; e has id 
4f6e			 
4f6e 11 81 fa			ld de, store_page 
4f71					if DEBUG_FORTH_WORDS 
4f71						DMARK "REr" 
4f71 f5				push af  
4f72 3a 86 4f			ld a, (.dmark)  
4f75 32 6e fe			ld (debug_mark),a  
4f78 3a 87 4f			ld a, (.dmark+1)  
4f7b 32 6f fe			ld (debug_mark+1),a  
4f7e 3a 88 4f			ld a, (.dmark+2)  
4f81 32 70 fe			ld (debug_mark+2),a  
4f84 18 03			jr .pastdmark  
4f86 ..			.dmark: db "REr"  
4f89 f1			.pastdmark: pop af  
4f8a			endm  
# End of macro DMARK
4f8a						CALLMONITOR 
4f8a cd c1 19			call break_point_state  
4f8d				endm  
# End of macro CALLMONITOR
4f8d					endif 
4f8d cd 75 09				call storage_read 
4f90 cd 75 0f			call ishlzero 
4f93 28 22			jr z, .recnotfound 
4f95			 
4f95			 
4f95					if DEBUG_FORTH_WORDS 
4f95						DMARK "REe" 
4f95 f5				push af  
4f96 3a aa 4f			ld a, (.dmark)  
4f99 32 6e fe			ld (debug_mark),a  
4f9c 3a ab 4f			ld a, (.dmark+1)  
4f9f 32 6f fe			ld (debug_mark+1),a  
4fa2 3a ac 4f			ld a, (.dmark+2)  
4fa5 32 70 fe			ld (debug_mark+2),a  
4fa8 18 03			jr .pastdmark  
4faa ..			.dmark: db "REe"  
4fad f1			.pastdmark: pop af  
4fae			endm  
# End of macro DMARK
4fae						CALLMONITOR 
4fae cd c1 19			call break_point_state  
4fb1				endm  
# End of macro CALLMONITOR
4fb1					endif 
4fb1 cd fa 20			call forth_push_str 
4fb4			 
4fb4					NEXTW 
4fb4 c3 39 24			jp macro_next 
4fb7				endm 
# End of macro NEXTW
4fb7			 
4fb7			.recnotfound: 
4fb7					if DEBUG_FORTH_WORDS 
4fb7						DMARK "REf" 
4fb7 f5				push af  
4fb8 3a cc 4f			ld a, (.dmark)  
4fbb 32 6e fe			ld (debug_mark),a  
4fbe 3a cd 4f			ld a, (.dmark+1)  
4fc1 32 6f fe			ld (debug_mark+1),a  
4fc4 3a ce 4f			ld a, (.dmark+2)  
4fc7 32 70 fe			ld (debug_mark+2),a  
4fca 18 03			jr .pastdmark  
4fcc ..			.dmark: db "REf"  
4fcf f1			.pastdmark: pop af  
4fd0			endm  
# End of macro DMARK
4fd0						CALLMONITOR 
4fd0 cd c1 19			call break_point_state  
4fd3				endm  
# End of macro CALLMONITOR
4fd3					endif 
4fd3 21 ff 00			ld hl, 255 
4fd6 cd 8c 20			call forth_push_numhl 
4fd9				NEXTW 
4fd9 c3 39 24			jp macro_next 
4fdc				endm 
# End of macro NEXTW
4fdc			 
4fdc			 
4fdc			.BREAD: 
4fdc			  
4fdc				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4fdc 3a				db WORD_SYS_CORE+38             
4fdd 5f 50			dw .BWRITE            
4fdf 06				db 5 + 1 
4fe0 .. 00			db "BREAD",0              
4fe6				endm 
# End of macro CWHEAD
4fe6			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
4fe6			; | | Compatible with PicoSPINet  
4fe6				 
4fe6					if DEBUG_FORTH_WORDS_KEY 
4fe6						DMARK "BRD" 
4fe6 f5				push af  
4fe7 3a fb 4f			ld a, (.dmark)  
4fea 32 6e fe			ld (debug_mark),a  
4fed 3a fc 4f			ld a, (.dmark+1)  
4ff0 32 6f fe			ld (debug_mark+1),a  
4ff3 3a fd 4f			ld a, (.dmark+2)  
4ff6 32 70 fe			ld (debug_mark+2),a  
4ff9 18 03			jr .pastdmark  
4ffb ..			.dmark: db "BRD"  
4ffe f1			.pastdmark: pop af  
4fff			endm  
# End of macro DMARK
4fff						CALLMONITOR 
4fff cd c1 19			call break_point_state  
5002				endm  
# End of macro CALLMONITOR
5002					endif 
5002			 
5002				FORTH_DSP_VALUEHL 
5002 cd 83 22			call macro_dsp_valuehl 
5005				endm 
# End of macro FORTH_DSP_VALUEHL
5005			 
5005				FORTH_DSP_POP 
5005 cd 3b 23			call macro_forth_dsp_pop 
5008				endm 
# End of macro FORTH_DSP_POP
5008			 
5008				; calc block address 
5008			 
5008 eb				ex de, hl 
5009 3e 40			ld a, STORE_BLOCK_PHY 
500b cd cf 0e			call Mult16 
500e			 
500e			 
500e 11 81 fa			ld de, store_page 
5011			 
5011					if DEBUG_FORTH_WORDS 
5011						DMARK "BR1" 
5011 f5				push af  
5012 3a 26 50			ld a, (.dmark)  
5015 32 6e fe			ld (debug_mark),a  
5018 3a 27 50			ld a, (.dmark+1)  
501b 32 6f fe			ld (debug_mark+1),a  
501e 3a 28 50			ld a, (.dmark+2)  
5021 32 70 fe			ld (debug_mark+2),a  
5024 18 03			jr .pastdmark  
5026 ..			.dmark: db "BR1"  
5029 f1			.pastdmark: pop af  
502a			endm  
# End of macro DMARK
502a						CALLMONITOR 
502a cd c1 19			call break_point_state  
502d				endm  
# End of macro CALLMONITOR
502d					endif 
502d			 
502d cd 1c 04			call storage_read_block 
5030			 
5030 cd 75 0f			call ishlzero 
5033 20 05			jr nz, .brfound 
5035			 
5035 cd 8c 20			call forth_push_numhl 
5038 18 22			jr .brdone 
503a			 
503a			 
503a			.brfound: 
503a 21 83 fa		        ld hl, store_page+2 
503d			 
503d					if DEBUG_FORTH_WORDS 
503d						DMARK "BR2" 
503d f5				push af  
503e 3a 52 50			ld a, (.dmark)  
5041 32 6e fe			ld (debug_mark),a  
5044 3a 53 50			ld a, (.dmark+1)  
5047 32 6f fe			ld (debug_mark+1),a  
504a 3a 54 50			ld a, (.dmark+2)  
504d 32 70 fe			ld (debug_mark+2),a  
5050 18 03			jr .pastdmark  
5052 ..			.dmark: db "BR2"  
5055 f1			.pastdmark: pop af  
5056			endm  
# End of macro DMARK
5056						CALLMONITOR 
5056 cd c1 19			call break_point_state  
5059				endm  
# End of macro CALLMONITOR
5059					endif 
5059			 
5059 cd fa 20			call forth_push_str 
505c			 
505c			 
505c			.brdone: 
505c			 
505c					NEXTW 
505c c3 39 24			jp macro_next 
505f				endm 
# End of macro NEXTW
505f			.BWRITE: 
505f				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
505f 3a				db WORD_SYS_CORE+38             
5060 f4 50			dw .BUPD            
5062 07				db 6 + 1 
5063 .. 00			db "BWRITE",0              
506a				endm 
# End of macro CWHEAD
506a			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
506a			; | | Compatible with PicoSPINet  
506a			 
506a					if DEBUG_FORTH_WORDS_KEY 
506a						DMARK "BWR" 
506a f5				push af  
506b 3a 7f 50			ld a, (.dmark)  
506e 32 6e fe			ld (debug_mark),a  
5071 3a 80 50			ld a, (.dmark+1)  
5074 32 6f fe			ld (debug_mark+1),a  
5077 3a 81 50			ld a, (.dmark+2)  
507a 32 70 fe			ld (debug_mark+2),a  
507d 18 03			jr .pastdmark  
507f ..			.dmark: db "BWR"  
5082 f1			.pastdmark: pop af  
5083			endm  
# End of macro DMARK
5083						CALLMONITOR 
5083 cd c1 19			call break_point_state  
5086				endm  
# End of macro CALLMONITOR
5086					endif 
5086			 
5086				FORTH_DSP_VALUEHL 
5086 cd 83 22			call macro_dsp_valuehl 
5089				endm 
# End of macro FORTH_DSP_VALUEHL
5089			 
5089				; calc block address 
5089			 
5089 eb				ex de, hl 
508a 3e 40			ld a, STORE_BLOCK_PHY 
508c cd cf 0e			call Mult16 
508f			 
508f e5				push hl         ; address 
5090			 
5090				FORTH_DSP_POP 
5090 cd 3b 23			call macro_forth_dsp_pop 
5093				endm 
# End of macro FORTH_DSP_POP
5093			 
5093				FORTH_DSP_VALUEHL 
5093 cd 83 22			call macro_dsp_valuehl 
5096				endm 
# End of macro FORTH_DSP_VALUEHL
5096			 
5096				FORTH_DSP_POP 
5096 cd 3b 23			call macro_forth_dsp_pop 
5099				endm 
# End of macro FORTH_DSP_POP
5099			 
5099 cd 58 0c			call storage_clear_page 
509c			 
509c				; copy string to store page 
509c			 
509c e5				push hl     ; save string address 
509d			 
509d 3e 00			ld a, 0 
509f cd b5 13			call strlent 
50a2			 
50a2 23				inc hl 
50a3			 
50a3 4d				ld c, l 
50a4 06 00			ld b, 0 
50a6			 
50a6 e1				pop hl 
50a7 11 83 fa			ld de, store_page + 2 
50aa					if DEBUG_FORTH_WORDS 
50aa						DMARK "BW1" 
50aa f5				push af  
50ab 3a bf 50			ld a, (.dmark)  
50ae 32 6e fe			ld (debug_mark),a  
50b1 3a c0 50			ld a, (.dmark+1)  
50b4 32 6f fe			ld (debug_mark+1),a  
50b7 3a c1 50			ld a, (.dmark+2)  
50ba 32 70 fe			ld (debug_mark+2),a  
50bd 18 03			jr .pastdmark  
50bf ..			.dmark: db "BW1"  
50c2 f1			.pastdmark: pop af  
50c3			endm  
# End of macro DMARK
50c3						CALLMONITOR 
50c3 cd c1 19			call break_point_state  
50c6				endm  
# End of macro CALLMONITOR
50c6					endif 
50c6 ed b0			ldir 
50c8			 
50c8			 
50c8				; poke the start of the block with flags to prevent high level file ops hitting the block 
50c8			 
50c8 21 ff ff			ld hl, $ffff 
50cb			 
50cb 22 81 fa			ld (store_page), hl	 
50ce				 
50ce e1				pop hl    ; get address 
50cf 11 81 fa			ld de, store_page 
50d2			 
50d2					if DEBUG_FORTH_WORDS 
50d2						DMARK "BW2" 
50d2 f5				push af  
50d3 3a e7 50			ld a, (.dmark)  
50d6 32 6e fe			ld (debug_mark),a  
50d9 3a e8 50			ld a, (.dmark+1)  
50dc 32 6f fe			ld (debug_mark+1),a  
50df 3a e9 50			ld a, (.dmark+2)  
50e2 32 70 fe			ld (debug_mark+2),a  
50e5 18 03			jr .pastdmark  
50e7 ..			.dmark: db "BW2"  
50ea f1			.pastdmark: pop af  
50eb			endm  
# End of macro DMARK
50eb						CALLMONITOR 
50eb cd c1 19			call break_point_state  
50ee				endm  
# End of macro CALLMONITOR
50ee					endif 
50ee			 
50ee cd 81 04			call storage_write_block 
50f1			 
50f1					NEXTW 
50f1 c3 39 24			jp macro_next 
50f4				endm 
# End of macro NEXTW
50f4			 
50f4			.BUPD: 
50f4				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
50f4 3a				db WORD_SYS_CORE+38             
50f5 4a 51			dw .BYID            
50f7 05				db 4 + 1 
50f8 .. 00			db "BUPD",0              
50fd				endm 
# End of macro CWHEAD
50fd			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
50fd			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
50fd			; | | or completely different file system structure. 
50fd			; | | Compatible with PicoSPINet  
50fd			 
50fd					if DEBUG_FORTH_WORDS_KEY 
50fd						DMARK "BUD" 
50fd f5				push af  
50fe 3a 12 51			ld a, (.dmark)  
5101 32 6e fe			ld (debug_mark),a  
5104 3a 13 51			ld a, (.dmark+1)  
5107 32 6f fe			ld (debug_mark+1),a  
510a 3a 14 51			ld a, (.dmark+2)  
510d 32 70 fe			ld (debug_mark+2),a  
5110 18 03			jr .pastdmark  
5112 ..			.dmark: db "BUD"  
5115 f1			.pastdmark: pop af  
5116			endm  
# End of macro DMARK
5116						CALLMONITOR 
5116 cd c1 19			call break_point_state  
5119				endm  
# End of macro CALLMONITOR
5119					endif 
5119			 
5119				FORTH_DSP_VALUEHL 
5119 cd 83 22			call macro_dsp_valuehl 
511c				endm 
# End of macro FORTH_DSP_VALUEHL
511c			 
511c				; calc block address 
511c			 
511c eb				ex de, hl 
511d 3e 40			ld a, STORE_BLOCK_PHY 
511f cd cf 0e			call Mult16 
5122			 
5122				FORTH_DSP_POP 
5122 cd 3b 23			call macro_forth_dsp_pop 
5125				endm 
# End of macro FORTH_DSP_POP
5125			 
5125			 
5125 11 81 fa			ld de, store_page 
5128			 
5128					if DEBUG_FORTH_WORDS 
5128						DMARK "BUe" 
5128 f5				push af  
5129 3a 3d 51			ld a, (.dmark)  
512c 32 6e fe			ld (debug_mark),a  
512f 3a 3e 51			ld a, (.dmark+1)  
5132 32 6f fe			ld (debug_mark+1),a  
5135 3a 3f 51			ld a, (.dmark+2)  
5138 32 70 fe			ld (debug_mark+2),a  
513b 18 03			jr .pastdmark  
513d ..			.dmark: db "BUe"  
5140 f1			.pastdmark: pop af  
5141			endm  
# End of macro DMARK
5141						CALLMONITOR 
5141 cd c1 19			call break_point_state  
5144				endm  
# End of macro CALLMONITOR
5144					endif 
5144			 
5144 cd 81 04			call storage_write_block 
5147			 
5147					NEXTW 
5147 c3 39 24			jp macro_next 
514a				endm 
# End of macro NEXTW
514a			 
514a			.BYID: 
514a			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
514a			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
514a			; 
514a			;		 
514a			;		if DEBUG_FORTH_WORDS_KEY 
514a			;			DMARK "BYID" 
514a			;			CALLMONITOR 
514a			;		endif 
514a			; 
514a			;		; get direct address 
514a			; 
514a			;		FORTH_DSP_VALUEHL 
514a			; 
514a			;		FORTH_DSP_POP 
514a			; 
514a			;	; calc block address 
514a			; 
514a			;	ex de, hl 
514a			;	ld a, STORE_BLOCK_PHY 
514a			;	call Mult16 
514a			;	;	do BREAD with number as param 
514a			;	; push the file name	 
514a			;	ld de, store_page 
514a			;	call storage_read_block 
514a			 ;       ld hl, store_page+2 
514a			; 
514a			; 
514a			;		NEXTW 
514a			;.BYNAME: 
514a				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
514a 3a				db WORD_SYS_CORE+38             
514b 63 51			dw .DIR            
514d 06				db 5 + 1 
514e .. 00			db "GETID",0              
5154				endm 
# End of macro CWHEAD
5154			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
5154			; | | Compatible with PicoSPINet  
5154			 
5154					; get pointer to file name to seek 
5154			 
5154					FORTH_DSP_VALUEHL 
5154 cd 83 22			call macro_dsp_valuehl 
5157				endm 
# End of macro FORTH_DSP_VALUEHL
5157			 
5157			 
5157 cd 43 03				call storage_getid  
515a			 
515a					FORTH_DSP_POP 
515a cd 3b 23			call macro_forth_dsp_pop 
515d				endm 
# End of macro FORTH_DSP_POP
515d			 
515d cd 8c 20				call forth_push_numhl 
5160			 
5160					NEXTW 
5160 c3 39 24			jp macro_next 
5163				endm 
# End of macro NEXTW
5163			; 
5163			.DIR: 
5163				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
5163 3a				db WORD_SYS_CORE+38             
5164 67 52			dw .SAVE            
5166 04				db 3 + 1 
5167 .. 00			db "DIR",0              
516b				endm 
# End of macro CWHEAD
516b			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
516b			; | | Compatible with PicoSPINet  
516b			 
516b					if DEBUG_FORTH_WORDS_KEY 
516b						DMARK "DIR" 
516b f5				push af  
516c 3a 80 51			ld a, (.dmark)  
516f 32 6e fe			ld (debug_mark),a  
5172 3a 81 51			ld a, (.dmark+1)  
5175 32 6f fe			ld (debug_mark+1),a  
5178 3a 82 51			ld a, (.dmark+2)  
517b 32 70 fe			ld (debug_mark+2),a  
517e 18 03			jr .pastdmark  
5180 ..			.dmark: db "DIR"  
5183 f1			.pastdmark: pop af  
5184			endm  
# End of macro DMARK
5184						CALLMONITOR 
5184 cd c1 19			call break_point_state  
5187				endm  
# End of macro CALLMONITOR
5187					endif 
5187 cd cd 04			call storage_get_block_0 
518a			 
518a 21 81 fa			ld hl, store_page     ; get current id count 
518d 46				ld b, (hl) 
518e 0e 00			ld c, 0    ; count of files   
5190					if DEBUG_FORTH_WORDS 
5190						DMARK "DI1" 
5190 f5				push af  
5191 3a a5 51			ld a, (.dmark)  
5194 32 6e fe			ld (debug_mark),a  
5197 3a a6 51			ld a, (.dmark+1)  
519a 32 6f fe			ld (debug_mark+1),a  
519d 3a a7 51			ld a, (.dmark+2)  
51a0 32 70 fe			ld (debug_mark+2),a  
51a3 18 03			jr .pastdmark  
51a5 ..			.dmark: db "DI1"  
51a8 f1			.pastdmark: pop af  
51a9			endm  
# End of macro DMARK
51a9						CALLMONITOR 
51a9 cd c1 19			call break_point_state  
51ac				endm  
# End of macro CALLMONITOR
51ac					endif 
51ac			 
51ac				; check for empty drive 
51ac			 
51ac 3e 00			ld a, 0 
51ae b8				cp b 
51af ca 1d 52			jp z, .dirdone 
51b2			 
51b2				; for each of the current ids do a search for them and if found push to stack 
51b2			 
51b2 c5			.diritem:	push bc 
51b3 21 40 00				ld hl, STORE_BLOCK_PHY 
51b6 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
51b8 58					ld e,b 
51b9			 
51b9			;		if DEBUG_FORTH_WORDS 
51b9			;			DMARK "DI2" 
51b9			;			CALLMONITOR 
51b9			;		endif 
51b9			 
51b9 cd 4f 07				call storage_findnextid 
51bc			 
51bc			;		if DEBUG_FORTH_WORDS 
51bc			;			DMARK "DI3" 
51bc			;			CALLMONITOR 
51bc			;		endif 
51bc			 
51bc					; if found hl will be non zero 
51bc			 
51bc cd 75 0f				call ishlzero 
51bf			;		ld a, l 
51bf			;		add h 
51bf			; 
51bf			;		cp 0 
51bf 28 59				jr z, .dirnotfound 
51c1			 
51c1					; increase count 
51c1			 
51c1 c1					pop bc	 
51c2 0c					inc c 
51c3 c5					push bc 
51c4					 
51c4			 
51c4					; get file header and push the file name 
51c4			 
51c4 11 81 fa				ld de, store_page 
51c7 cd 1c 04				call storage_read_block 
51ca			 
51ca					; push file id to stack 
51ca				 
51ca 3a 81 fa				ld a, (store_page) 
51cd 26 00				ld h, 0 
51cf 6f					ld l, a 
51d0 cd 8c 20				call forth_push_numhl 
51d3			 
51d3					; push extent count to stack  
51d3				 
51d3 3a 83 fa				ld a, (store_page+2) 
51d6 26 00				ld h, 0 
51d8 6f					ld l, a 
51d9 cd 8c 20				call forth_push_numhl 
51dc			 
51dc					; push file name 
51dc			 
51dc 21 84 fa				ld hl, store_page+3 
51df					if DEBUG_FORTH_WORDS 
51df						DMARK "DI5" 
51df f5				push af  
51e0 3a f4 51			ld a, (.dmark)  
51e3 32 6e fe			ld (debug_mark),a  
51e6 3a f5 51			ld a, (.dmark+1)  
51e9 32 6f fe			ld (debug_mark+1),a  
51ec 3a f6 51			ld a, (.dmark+2)  
51ef 32 70 fe			ld (debug_mark+2),a  
51f2 18 03			jr .pastdmark  
51f4 ..			.dmark: db "DI5"  
51f7 f1			.pastdmark: pop af  
51f8			endm  
# End of macro DMARK
51f8						CALLMONITOR 
51f8 cd c1 19			call break_point_state  
51fb				endm  
# End of macro CALLMONITOR
51fb					endif 
51fb cd fa 20				call forth_push_str 
51fe					if DEBUG_FORTH_WORDS 
51fe						DMARK "DI6" 
51fe f5				push af  
51ff 3a 13 52			ld a, (.dmark)  
5202 32 6e fe			ld (debug_mark),a  
5205 3a 14 52			ld a, (.dmark+1)  
5208 32 6f fe			ld (debug_mark+1),a  
520b 3a 15 52			ld a, (.dmark+2)  
520e 32 70 fe			ld (debug_mark+2),a  
5211 18 03			jr .pastdmark  
5213 ..			.dmark: db "DI6"  
5216 f1			.pastdmark: pop af  
5217			endm  
# End of macro DMARK
5217						CALLMONITOR 
5217 cd c1 19			call break_point_state  
521a				endm  
# End of macro CALLMONITOR
521a					endif 
521a			.dirnotfound: 
521a c1					pop bc     
521b 10 95				djnz .diritem 
521d				 
521d			.dirdone:	 
521d					if DEBUG_FORTH_WORDS 
521d						DMARK "DI7" 
521d f5				push af  
521e 3a 32 52			ld a, (.dmark)  
5221 32 6e fe			ld (debug_mark),a  
5224 3a 33 52			ld a, (.dmark+1)  
5227 32 6f fe			ld (debug_mark+1),a  
522a 3a 34 52			ld a, (.dmark+2)  
522d 32 70 fe			ld (debug_mark+2),a  
5230 18 03			jr .pastdmark  
5232 ..			.dmark: db "DI7"  
5235 f1			.pastdmark: pop af  
5236			endm  
# End of macro DMARK
5236						CALLMONITOR 
5236 cd c1 19			call break_point_state  
5239				endm  
# End of macro CALLMONITOR
5239					endif 
5239			 
5239					; push a count of the dir items found 
5239			 
5239 26 00				ld h, 0 
523b 69					ld l, c 
523c cd 8c 20				call forth_push_numhl 
523f			 
523f					; push the bank label 
523f			 
523f cd cd 04				call storage_get_block_0 
5242			 
5242				 
5242 21 84 fa		 		ld hl, store_page+3 
5245			 
5245					if DEBUG_FORTH_WORDS 
5245						DMARK "DI8" 
5245 f5				push af  
5246 3a 5a 52			ld a, (.dmark)  
5249 32 6e fe			ld (debug_mark),a  
524c 3a 5b 52			ld a, (.dmark+1)  
524f 32 6f fe			ld (debug_mark+1),a  
5252 3a 5c 52			ld a, (.dmark+2)  
5255 32 70 fe			ld (debug_mark+2),a  
5258 18 03			jr .pastdmark  
525a ..			.dmark: db "DI8"  
525d f1			.pastdmark: pop af  
525e			endm  
# End of macro DMARK
525e						CALLMONITOR 
525e cd c1 19			call break_point_state  
5261				endm  
# End of macro CALLMONITOR
5261					endif 
5261 cd fa 20				call forth_push_str 
5264			 
5264			 
5264				 
5264					NEXTW 
5264 c3 39 24			jp macro_next 
5267				endm 
# End of macro NEXTW
5267			.SAVE: 
5267			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5267			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5267			;		NEXTW 
5267			;.LOAD: 
5267			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5267			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5267			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5267			;; > > The LOAD command can not be used in any user words or compound lines. 
5267			; 
5267			;		; store_openext use it. If zero it is EOF 
5267			; 
5267			;		; read block from current stream id 
5267			;		; if the block does not contain zero term keep reading blocks until zero found 
5267			;		; push the block to stack 
5267			;		; save the block id to stream 
5267			; 
5267			; 
5267			;		FORTH_DSP_VALUEHL 
5267			; 
5267			;;		push hl 
5267			; 
5267			;	if DEBUG_STORESE 
5267			;		DMARK "LOA" 
5267			;		CALLMONITOR 
5267			;	endif 
5267			;		FORTH_DSP_POP 
5267			; 
5267			;;		pop hl 
5267			; 
5267			;		ld h, l 
5267			;		ld l, 0 
5267			; 
5267			;		push hl     ; stack holds current file id and extent to work with 
5267			; 
5267			; 
5267			;		ld de, store_page      ; get block zero of file 
5267			;	if DEBUG_STORESE 
5267			;		DMARK "LO0" 
5267			;		CALLMONITOR 
5267			;	endif 
5267			;		call storage_read 
5267			; 
5267			;		ld a, (store_page+2)    ; max extents for this file 
5267			;		ld  (store_openmaxext),a   ; get our limit 
5267			; 
5267			;	if DEBUG_STORESE 
5267			;		DMARK "LOE" 
5267			;		CALLMONITOR 
5267			;	endif 
5267			; 
5267			;; TODO dont know why max extents are not present 
5267			;;		cp 0 
5267			;;		jp z, .loadeof     ; dont read past eof 
5267			; 
5267			;;		ld a, 1   ; start from the head of the file 
5267			; 
5267			;.loadline:	pop hl 
5267			;		inc hl 
5267			;		ld  a, (store_openmaxext)   ; get our limit 
5267			;	if DEBUG_STORESE 
5267			;		DMARK "LOx" 
5267			;		CALLMONITOR 
5267			;	endif 
5267			;		inc a 
5267			;		cp l 
5267			;		jp z, .loadeof 
5267			;		push hl    ; save current extent 
5267			; 
5267			;		ld de, store_page 
5267			; 
5267			;	if DEBUG_STORESE 
5267			;		DMARK "LO1" 
5267			;		CALLMONITOR 
5267			;	endif 
5267			;		call storage_read 
5267			; 
5267			;	if DEBUG_STORESE 
5267			;		DMARK "LO2" 
5267			;		CALLMONITOR 
5267			;	endif 
5267			;	call ishlzero 
5267			;	ld a, l 
5267			;	add h 
5267			;	cp 0 
5267			;	jr z, .loadeof 
5267			; 
5267			;	; not eof so hl should point to data to exec 
5267			; 
5267			;	; will need to add the FORTH_END_BUFFER flag 
5267			 ; 
5267			;	ld hl, store_page+2 
5267			;	ld bc, 255 
5267			;	ld a, 0 
5267			;	cpir 
5267			;	if DEBUG_STORESE 
5267			;		DMARK "LOt" 
5267			;		CALLMONITOR 
5267			;	endif 
5267			;	dec hl 
5267			;	ld a, ' ' 
5267			;	ld (hl), a 
5267			;	inc hl 
5267			;	ld (hl), a 
5267			;	inc hl 
5267			;	ld (hl), a 
5267			;	inc hl 
5267			;	ld a, FORTH_END_BUFFER 
5267			;	ld (hl), a 
5267			; 
5267			;	; TODO handle more than a single block read 
5267			; 
5267			; 
5267			;	ld hl, store_page+2 
5267			; 
5267			;	ld (os_tok_ptr), hl 
5267			; 
5267			;	if DEBUG_STORESE 
5267			;		DMARK "LO3" 
5267			;		CALLMONITOR 
5267			;	endif 
5267			; 
5267			;	call forthparse 
5267			;	call forthexec 
5267			;	call forthexec_cleanup 
5267			; 
5267			;	; go to next extent 
5267			; 
5267			;	; get next block  or mark as eof 
5267			;	jp .loadline 
5267			; 
5267			; 
5267			; 
5267			;	       NEXTW 
5267			;.loadeof:	ld a, 0 
5267			;		ld (store_openext), a 
5267			; 
5267			;	if DEBUG_STORESE 
5267			;		DMARK "LOF" 
5267			;		CALLMONITOR 
5267			;	endif 
5267			;		ret 
5267			;		;NEXTW 
5267			;.BSAVE:   
5267			; 
5267			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5267			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5267			;		NEXTW 
5267			;.BLOAD: 
5267			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5267			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5267			;		NEXTW 
5267			;;;; counter gap 
5267			 
5267			 
5267			.SEO: 
5267				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5267 64				db WORD_SYS_CORE+80             
5268 86 52			dw .SEI            
526a 04				db 3 + 1 
526b .. 00			db "SEO",0              
526f				endm 
# End of macro CWHEAD
526f			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
526f			 
526f					; get port 
526f			 
526f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
526f cd 83 22			call macro_dsp_valuehl 
5272				endm 
# End of macro FORTH_DSP_VALUEHL
5272			 
5272 e5					push hl    ; u2 - byte 
5273			 
5273					; destroy value TOS 
5273			 
5273					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5273 cd 3b 23			call macro_forth_dsp_pop 
5276				endm 
# End of macro FORTH_DSP_POP
5276			 
5276					; get byte to send 
5276			 
5276					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5276 cd 83 22			call macro_dsp_valuehl 
5279				endm 
# End of macro FORTH_DSP_VALUEHL
5279			 
5279 e5					push hl    ; u1 - addr 
527a			 
527a					; destroy value TOS 
527a			 
527a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
527a cd 3b 23			call macro_forth_dsp_pop 
527d				endm 
# End of macro FORTH_DSP_POP
527d			 
527d					; one value on hl get other one back 
527d			 
527d d1					pop de   ; u1 - byte 
527e			 
527e e1					pop hl   ; u2 - addr 
527f			 
527f					; TODO Send SPI byte 
527f			 
527f			 
527f 7b					ld a, e 
5280 cd 21 02				call se_writebyte 
5283			 
5283					 
5283			 
5283					NEXTW 
5283 c3 39 24			jp macro_next 
5286				endm 
# End of macro NEXTW
5286			 
5286			.SEI: 
5286				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5286 65				db WORD_SYS_CORE+81             
5287 a0 52			dw .SFREE            
5289 04				db 3 + 1 
528a .. 00			db "SEI",0              
528e				endm 
# End of macro CWHEAD
528e			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
528e			 
528e					; get port 
528e			 
528e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
528e cd 83 22			call macro_dsp_valuehl 
5291				endm 
# End of macro FORTH_DSP_VALUEHL
5291			 
5291			;		push hl 
5291			 
5291					; destroy value TOS 
5291			 
5291					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5291 cd 3b 23			call macro_forth_dsp_pop 
5294				endm 
# End of macro FORTH_DSP_POP
5294			 
5294					; one value on hl get other one back 
5294			 
5294			;		pop hl 
5294			 
5294			 
5294					; TODO Get SPI byte 
5294			 
5294 cd c3 02				call se_readbyte 
5297			 
5297 26 00				ld h, 0 
5299 6f					ld l, a 
529a cd 8c 20				call forth_push_numhl 
529d			 
529d					NEXTW 
529d c3 39 24			jp macro_next 
52a0				endm 
# End of macro NEXTW
52a0			 
52a0			.SFREE: 
52a0				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
52a0 67				db WORD_SYS_CORE+83             
52a1 cf 52			dw .SIZE            
52a3 06				db 5 + 1 
52a4 .. 00			db "FFREE",0              
52aa				endm 
# End of macro CWHEAD
52aa			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
52aa			; | | Compatible with PicoSPINet  
52aa					if DEBUG_FORTH_WORDS_KEY 
52aa						DMARK "FFR" 
52aa f5				push af  
52ab 3a bf 52			ld a, (.dmark)  
52ae 32 6e fe			ld (debug_mark),a  
52b1 3a c0 52			ld a, (.dmark+1)  
52b4 32 6f fe			ld (debug_mark+1),a  
52b7 3a c1 52			ld a, (.dmark+2)  
52ba 32 70 fe			ld (debug_mark+2),a  
52bd 18 03			jr .pastdmark  
52bf ..			.dmark: db "FFR"  
52c2 f1			.pastdmark: pop af  
52c3			endm  
# End of macro DMARK
52c3						CALLMONITOR 
52c3 cd c1 19			call break_point_state  
52c6				endm  
# End of macro CALLMONITOR
52c6					endif 
52c6			 
52c6 cd e9 07				call storage_freeblocks 
52c9			 
52c9 cd 8c 20				call forth_push_numhl 
52cc			 
52cc				       NEXTW 
52cc c3 39 24			jp macro_next 
52cf				endm 
# End of macro NEXTW
52cf			.SIZE: 
52cf				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
52cf 67				db WORD_SYS_CORE+83             
52d0 03 53			dw .CREATE            
52d2 05				db 4 + 1 
52d3 .. 00			db "SIZE",0              
52d8				endm 
# End of macro CWHEAD
52d8			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
52d8			; | | Compatible with PicoSPINet  
52d8					if DEBUG_FORTH_WORDS_KEY 
52d8						DMARK "SIZ" 
52d8 f5				push af  
52d9 3a ed 52			ld a, (.dmark)  
52dc 32 6e fe			ld (debug_mark),a  
52df 3a ee 52			ld a, (.dmark+1)  
52e2 32 6f fe			ld (debug_mark+1),a  
52e5 3a ef 52			ld a, (.dmark+2)  
52e8 32 70 fe			ld (debug_mark+2),a  
52eb 18 03			jr .pastdmark  
52ed ..			.dmark: db "SIZ"  
52f0 f1			.pastdmark: pop af  
52f1			endm  
# End of macro DMARK
52f1						CALLMONITOR 
52f1 cd c1 19			call break_point_state  
52f4				endm  
# End of macro CALLMONITOR
52f4					endif 
52f4			 
52f4					FORTH_DSP_VALUEHL 
52f4 cd 83 22			call macro_dsp_valuehl 
52f7				endm 
# End of macro FORTH_DSP_VALUEHL
52f7			;		push hl 
52f7					FORTH_DSP_POP 
52f7 cd 3b 23			call macro_forth_dsp_pop 
52fa				endm 
# End of macro FORTH_DSP_POP
52fa			;		pop hl 
52fa cd 4b 04				call storage_file_size 
52fd			 
52fd cd 8c 20				call forth_push_numhl 
5300			  
5300			 
5300				       NEXTW 
5300 c3 39 24			jp macro_next 
5303				endm 
# End of macro NEXTW
5303			 
5303			.CREATE: 
5303				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5303 68				db WORD_SYS_CORE+84             
5304 71 53			dw .APPEND            
5306 07				db 6 + 1 
5307 .. 00			db "CREATE",0              
530e				endm 
# End of macro CWHEAD
530e			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
530e			; | | e.g.  
530e			; | | TestProgram CREATE 
530e			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
530e			; | |  
530e			; | | Max file IDs are 255. 
530e			; | |  
530e			; | | Compatible with PicoSPINet  
530e					 
530e					if DEBUG_FORTH_WORDS_KEY 
530e						DMARK "CRT" 
530e f5				push af  
530f 3a 23 53			ld a, (.dmark)  
5312 32 6e fe			ld (debug_mark),a  
5315 3a 24 53			ld a, (.dmark+1)  
5318 32 6f fe			ld (debug_mark+1),a  
531b 3a 25 53			ld a, (.dmark+2)  
531e 32 70 fe			ld (debug_mark+2),a  
5321 18 03			jr .pastdmark  
5323 ..			.dmark: db "CRT"  
5326 f1			.pastdmark: pop af  
5327			endm  
# End of macro DMARK
5327						CALLMONITOR 
5327 cd c1 19			call break_point_state  
532a				endm  
# End of macro CALLMONITOR
532a					endif 
532a			;		call storage_get_block_0 
532a			 
532a					; TODO pop hl 
532a			 
532a					;v5 FORTH_DSP_VALUE 
532a					FORTH_DSP_VALUE 
532a cd 6c 22			call macro_forth_dsp_value 
532d				endm 
# End of macro FORTH_DSP_VALUE
532d			 
532d				if DEBUG_STORESE 
532d					DMARK "CR1" 
532d f5				push af  
532e 3a 42 53			ld a, (.dmark)  
5331 32 6e fe			ld (debug_mark),a  
5334 3a 43 53			ld a, (.dmark+1)  
5337 32 6f fe			ld (debug_mark+1),a  
533a 3a 44 53			ld a, (.dmark+2)  
533d 32 70 fe			ld (debug_mark+2),a  
5340 18 03			jr .pastdmark  
5342 ..			.dmark: db "CR1"  
5345 f1			.pastdmark: pop af  
5346			endm  
# End of macro DMARK
5346					CALLMONITOR 
5346 cd c1 19			call break_point_state  
5349				endm  
# End of macro CALLMONITOR
5349				endif 
5349			;		push hl 
5349			;		FORTH_DSP_POP 
5349			;		pop hl 
5349			 
5349			;		inc hl   ; move past the type marker 
5349			 
5349 cd 1f 08				call storage_create 
534c			 
534c				if DEBUG_STORESE 
534c					DMARK "CT1" 
534c f5				push af  
534d 3a 61 53			ld a, (.dmark)  
5350 32 6e fe			ld (debug_mark),a  
5353 3a 62 53			ld a, (.dmark+1)  
5356 32 6f fe			ld (debug_mark+1),a  
5359 3a 63 53			ld a, (.dmark+2)  
535c 32 70 fe			ld (debug_mark+2),a  
535f 18 03			jr .pastdmark  
5361 ..			.dmark: db "CT1"  
5364 f1			.pastdmark: pop af  
5365			endm  
# End of macro DMARK
5365					CALLMONITOR 
5365 cd c1 19			call break_point_state  
5368				endm  
# End of macro CALLMONITOR
5368				endif 
5368			;		push hl 
5368					FORTH_DSP_POP 
5368 cd 3b 23			call macro_forth_dsp_pop 
536b				endm 
# End of macro FORTH_DSP_POP
536b			;		pop hl 
536b					; push file id to stack 
536b cd 8c 20				call forth_push_numhl 
536e			 
536e			 
536e			 
536e				       NEXTW 
536e c3 39 24			jp macro_next 
5371				endm 
# End of macro NEXTW
5371			 
5371			.APPEND: 
5371				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5371 69				db WORD_SYS_CORE+85             
5372 02 54			dw .SDEL            
5374 07				db 6 + 1 
5375 .. 00			db "APPEND",0              
537c				endm 
# End of macro CWHEAD
537c			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
537c			; | | e.g. 
537c			; | | Test CREATE      -> $01 
537c			; | | "A string to add to file" $01 APPEND 
537c			; | |  
537c			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
537c			; | | Compatible with PicoSPINet  
537c					if DEBUG_FORTH_WORDS_KEY 
537c						DMARK "APP" 
537c f5				push af  
537d 3a 91 53			ld a, (.dmark)  
5380 32 6e fe			ld (debug_mark),a  
5383 3a 92 53			ld a, (.dmark+1)  
5386 32 6f fe			ld (debug_mark+1),a  
5389 3a 93 53			ld a, (.dmark+2)  
538c 32 70 fe			ld (debug_mark+2),a  
538f 18 03			jr .pastdmark  
5391 ..			.dmark: db "APP"  
5394 f1			.pastdmark: pop af  
5395			endm  
# End of macro DMARK
5395						CALLMONITOR 
5395 cd c1 19			call break_point_state  
5398				endm  
# End of macro CALLMONITOR
5398					endif 
5398			 
5398					FORTH_DSP_VALUEHL 
5398 cd 83 22			call macro_dsp_valuehl 
539b				endm 
# End of macro FORTH_DSP_VALUEHL
539b e5					push hl 	; save file id 
539c			 
539c				if DEBUG_STORESE 
539c					DMARK "AP1" 
539c f5				push af  
539d 3a b1 53			ld a, (.dmark)  
53a0 32 6e fe			ld (debug_mark),a  
53a3 3a b2 53			ld a, (.dmark+1)  
53a6 32 6f fe			ld (debug_mark+1),a  
53a9 3a b3 53			ld a, (.dmark+2)  
53ac 32 70 fe			ld (debug_mark+2),a  
53af 18 03			jr .pastdmark  
53b1 ..			.dmark: db "AP1"  
53b4 f1			.pastdmark: pop af  
53b5			endm  
# End of macro DMARK
53b5					CALLMONITOR 
53b5 cd c1 19			call break_point_state  
53b8				endm  
# End of macro CALLMONITOR
53b8				endif 
53b8					FORTH_DSP_POP 
53b8 cd 3b 23			call macro_forth_dsp_pop 
53bb				endm 
# End of macro FORTH_DSP_POP
53bb			 
53bb					FORTH_DSP_VALUEHL 
53bb cd 83 22			call macro_dsp_valuehl 
53be				endm 
# End of macro FORTH_DSP_VALUEHL
53be					;v5 FORTH_DSP_VALUE 
53be e5					push hl 	; save ptr to string to save 
53bf			 
53bf				if DEBUG_STORESE 
53bf					DMARK "AP1" 
53bf f5				push af  
53c0 3a d4 53			ld a, (.dmark)  
53c3 32 6e fe			ld (debug_mark),a  
53c6 3a d5 53			ld a, (.dmark+1)  
53c9 32 6f fe			ld (debug_mark+1),a  
53cc 3a d6 53			ld a, (.dmark+2)  
53cf 32 70 fe			ld (debug_mark+2),a  
53d2 18 03			jr .pastdmark  
53d4 ..			.dmark: db "AP1"  
53d7 f1			.pastdmark: pop af  
53d8			endm  
# End of macro DMARK
53d8					CALLMONITOR 
53d8 cd c1 19			call break_point_state  
53db				endm  
# End of macro CALLMONITOR
53db				endif 
53db					FORTH_DSP_POP 
53db cd 3b 23			call macro_forth_dsp_pop 
53de				endm 
# End of macro FORTH_DSP_POP
53de			 
53de d1					pop de 
53df e1					pop hl 
53e0				if DEBUG_STORESE 
53e0					DMARK "AP2" 
53e0 f5				push af  
53e1 3a f5 53			ld a, (.dmark)  
53e4 32 6e fe			ld (debug_mark),a  
53e7 3a f6 53			ld a, (.dmark+1)  
53ea 32 6f fe			ld (debug_mark+1),a  
53ed 3a f7 53			ld a, (.dmark+2)  
53f0 32 70 fe			ld (debug_mark+2),a  
53f3 18 03			jr .pastdmark  
53f5 ..			.dmark: db "AP2"  
53f8 f1			.pastdmark: pop af  
53f9			endm  
# End of macro DMARK
53f9					CALLMONITOR 
53f9 cd c1 19			call break_point_state  
53fc				endm  
# End of macro CALLMONITOR
53fc				endif 
53fc					;inc de ; skip var type indicator 
53fc			 
53fc					; TODO how to append numerics???? 
53fc			 
53fc cd 0c 0b				call storage_append		 
53ff			 
53ff				       NEXTW 
53ff c3 39 24			jp macro_next 
5402				endm 
# End of macro NEXTW
5402			.SDEL: 
5402				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5402 6a				db WORD_SYS_CORE+86             
5403 4e 54			dw .OPEN            
5405 05				db 4 + 1 
5406 .. 00			db "ERA",0              
540a				endm 
# End of macro CWHEAD
540a			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
540a			; | | Compatible with PicoSPINet  
540a					FORTH_DSP_VALUEHL 
540a cd 83 22			call macro_dsp_valuehl 
540d				endm 
# End of macro FORTH_DSP_VALUEHL
540d			;		push hl 	; save file id 
540d			 
540d					if DEBUG_FORTH_WORDS_KEY 
540d						DMARK "ERA" 
540d f5				push af  
540e 3a 22 54			ld a, (.dmark)  
5411 32 6e fe			ld (debug_mark),a  
5414 3a 23 54			ld a, (.dmark+1)  
5417 32 6f fe			ld (debug_mark+1),a  
541a 3a 24 54			ld a, (.dmark+2)  
541d 32 70 fe			ld (debug_mark+2),a  
5420 18 03			jr .pastdmark  
5422 ..			.dmark: db "ERA"  
5425 f1			.pastdmark: pop af  
5426			endm  
# End of macro DMARK
5426						CALLMONITOR 
5426 cd c1 19			call break_point_state  
5429				endm  
# End of macro CALLMONITOR
5429					endif 
5429				if DEBUG_STORESE 
5429					DMARK "ER1" 
5429 f5				push af  
542a 3a 3e 54			ld a, (.dmark)  
542d 32 6e fe			ld (debug_mark),a  
5430 3a 3f 54			ld a, (.dmark+1)  
5433 32 6f fe			ld (debug_mark+1),a  
5436 3a 40 54			ld a, (.dmark+2)  
5439 32 70 fe			ld (debug_mark+2),a  
543c 18 03			jr .pastdmark  
543e ..			.dmark: db "ER1"  
5441 f1			.pastdmark: pop af  
5442			endm  
# End of macro DMARK
5442					CALLMONITOR 
5442 cd c1 19			call break_point_state  
5445				endm  
# End of macro CALLMONITOR
5445				endif 
5445					FORTH_DSP_POP 
5445 cd 3b 23			call macro_forth_dsp_pop 
5448				endm 
# End of macro FORTH_DSP_POP
5448			 
5448			;		pop hl 
5448			 
5448 cd 5e 06				call storage_erase 
544b				       NEXTW 
544b c3 39 24			jp macro_next 
544e				endm 
# End of macro NEXTW
544e			 
544e			.OPEN: 
544e				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
544e 6b				db WORD_SYS_CORE+87             
544f e2 54			dw .READ            
5451 05				db 4 + 1 
5452 .. 00			db "OPEN",0              
5457				endm 
# End of macro CWHEAD
5457			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5457			; | | e.g. 
5457			; | | $01 OPEN $01 DO $01 READ . LOOP 
5457			; | | 
5457			; | | Will return with 255 blocks if the file does not exist 
5457			; | | Compatible with PicoSPINet  
5457			 
5457					if DEBUG_FORTH_WORDS_KEY 
5457						DMARK "OPN" 
5457 f5				push af  
5458 3a 6c 54			ld a, (.dmark)  
545b 32 6e fe			ld (debug_mark),a  
545e 3a 6d 54			ld a, (.dmark+1)  
5461 32 6f fe			ld (debug_mark+1),a  
5464 3a 6e 54			ld a, (.dmark+2)  
5467 32 70 fe			ld (debug_mark+2),a  
546a 18 03			jr .pastdmark  
546c ..			.dmark: db "OPN"  
546f f1			.pastdmark: pop af  
5470			endm  
# End of macro DMARK
5470						CALLMONITOR 
5470 cd c1 19			call break_point_state  
5473				endm  
# End of macro CALLMONITOR
5473					endif 
5473					; TODO handle multiple file opens 
5473			 
5473 3e 01			       	ld a, 1 
5475 32 71 fa				ld (store_openext), a 
5478			 
5478					; get max extents for this file 
5478				 
5478								 
5478					FORTH_DSP_VALUEHL 
5478 cd 83 22			call macro_dsp_valuehl 
547b				endm 
# End of macro FORTH_DSP_VALUEHL
547b			 
547b 65					ld h, l 
547c 2e 00				ld l, 0 
547e			 
547e					; store file id 
547e			 
547e 7c					ld a, h 
547f 32 6e fa				ld (store_filecache), a 
5482			 
5482				if DEBUG_STORESE 
5482					DMARK "OPN" 
5482 f5				push af  
5483 3a 97 54			ld a, (.dmark)  
5486 32 6e fe			ld (debug_mark),a  
5489 3a 98 54			ld a, (.dmark+1)  
548c 32 6f fe			ld (debug_mark+1),a  
548f 3a 99 54			ld a, (.dmark+2)  
5492 32 70 fe			ld (debug_mark+2),a  
5495 18 03			jr .pastdmark  
5497 ..			.dmark: db "OPN"  
549a f1			.pastdmark: pop af  
549b			endm  
# End of macro DMARK
549b					CALLMONITOR 
549b cd c1 19			call break_point_state  
549e				endm  
# End of macro CALLMONITOR
549e				endif 
549e			;		push hl 
549e					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
549e cd 3b 23			call macro_forth_dsp_pop 
54a1				endm 
# End of macro FORTH_DSP_POP
54a1			;		pop hl 
54a1						 
54a1 11 81 fa				ld de, store_page      ; get block zero of file 
54a4 cd 75 09				call storage_read 
54a7 cd 75 0f			call ishlzero 
54aa 20 04			jr nz, .opfound 
54ac			 
54ac				; file does not exist so indicate with 255 extents in use 
54ac			 
54ac 3e ff			ld a, 255 
54ae 18 29			jr .skipopeneof 
54b0			 
54b0			 
54b0			.opfound: 
54b0			 
54b0			 
54b0 3a 83 fa				ld a, (store_page+2)    ; max extents for this file 
54b3 32 70 fa				ld  (store_openmaxext), a   ; get our limit and push 
54b6					 
54b6				if DEBUG_STORESE 
54b6					DMARK "OPx" 
54b6 f5				push af  
54b7 3a cb 54			ld a, (.dmark)  
54ba 32 6e fe			ld (debug_mark),a  
54bd 3a cc 54			ld a, (.dmark+1)  
54c0 32 6f fe			ld (debug_mark+1),a  
54c3 3a cd 54			ld a, (.dmark+2)  
54c6 32 70 fe			ld (debug_mark+2),a  
54c9 18 03			jr .pastdmark  
54cb ..			.dmark: db "OPx"  
54ce f1			.pastdmark: pop af  
54cf			endm  
# End of macro DMARK
54cf					CALLMONITOR 
54cf cd c1 19			call break_point_state  
54d2				endm  
# End of macro CALLMONITOR
54d2				endif 
54d2 fe 00				cp 0 
54d4 20 03				jr nz, .skipopeneof 
54d6					; have opened an empty file 
54d6					 
54d6 32 71 fa				ld (store_openext), a 
54d9			 
54d9			.skipopeneof: 
54d9			 
54d9 6f					ld l, a 
54da 26 00				ld h, 0 
54dc cd 8c 20				call forth_push_numhl 
54df			 
54df			 
54df				       NEXTW 
54df c3 39 24			jp macro_next 
54e2				endm 
# End of macro NEXTW
54e2			.READ: 
54e2				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
54e2 6c				db WORD_SYS_CORE+88             
54e3 0c 56			dw .EOF            
54e5 05				db 4 + 1 
54e6 .. 00			db "READ",0              
54eb				endm 
# End of macro CWHEAD
54eb			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
54eb			; | | e.g. 
54eb			; | | $01 OPEN $01 DO READ . LOOP 
54eb			; | | 
54eb			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
54eb			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
54eb			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
54eb			; | | two bytes contain the file id and extent. 
54eb			; | |  
54eb			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
54eb			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
54eb			; | | Compatible with PicoSPINet  
54eb			 
54eb					if DEBUG_FORTH_WORDS_KEY 
54eb						DMARK "REA" 
54eb f5				push af  
54ec 3a 00 55			ld a, (.dmark)  
54ef 32 6e fe			ld (debug_mark),a  
54f2 3a 01 55			ld a, (.dmark+1)  
54f5 32 6f fe			ld (debug_mark+1),a  
54f8 3a 02 55			ld a, (.dmark+2)  
54fb 32 70 fe			ld (debug_mark+2),a  
54fe 18 03			jr .pastdmark  
5500 ..			.dmark: db "REA"  
5503 f1			.pastdmark: pop af  
5504			endm  
# End of macro DMARK
5504						CALLMONITOR 
5504 cd c1 19			call break_point_state  
5507				endm  
# End of macro CALLMONITOR
5507					endif 
5507					; store_openext use it. If zero it is EOF 
5507			 
5507					; read block from current stream id 
5507					; if the block does not contain zero term keep reading blocks until zero found 
5507					; push the block to stack 
5507					; save the block id to stream 
5507			 
5507			 
5507 cd 39 56				call .testeof 
550a 3e 01				ld a, 1 
550c bd					cp l 
550d ca e8 55				jp z, .ateof 
5510			 
5510			 
5510			;		FORTH_DSP_VALUEHL 
5510			 
5510			;		push hl 
5510			 
5510			;	if DEBUG_STORESE 
5510			;		DMARK "REA" 
5510			;		CALLMONITOR 
5510			;	endif 
5510			;		FORTH_DSP_POP 
5510			 
5510			;		pop hl 
5510				 
5510 3a 6e fa				ld a, (store_filecache) 
5513 67					ld h,a 
5514			 
5514 3a 71 fa				ld a, (store_openext) 
5517 6f					ld l, a 
5518					 
5518 fe 00				cp 0 
551a ca e8 55				jp z, .ateof     ; dont read past eof 
551d			 
551d cd 58 0c				call storage_clear_page 
5520			 
5520 11 81 fa				ld de, store_page 
5523				if DEBUG_STORESE 
5523					DMARK "RE1" 
5523 f5				push af  
5524 3a 38 55			ld a, (.dmark)  
5527 32 6e fe			ld (debug_mark),a  
552a 3a 39 55			ld a, (.dmark+1)  
552d 32 6f fe			ld (debug_mark+1),a  
5530 3a 3a 55			ld a, (.dmark+2)  
5533 32 70 fe			ld (debug_mark+2),a  
5536 18 03			jr .pastdmark  
5538 ..			.dmark: db "RE1"  
553b f1			.pastdmark: pop af  
553c			endm  
# End of macro DMARK
553c					CALLMONITOR 
553c cd c1 19			call break_point_state  
553f				endm  
# End of macro CALLMONITOR
553f				endif 
553f cd 75 09				call storage_read 
5542			 
5542				if DEBUG_STORESE 
5542					DMARK "RE2" 
5542 f5				push af  
5543 3a 57 55			ld a, (.dmark)  
5546 32 6e fe			ld (debug_mark),a  
5549 3a 58 55			ld a, (.dmark+1)  
554c 32 6f fe			ld (debug_mark+1),a  
554f 3a 59 55			ld a, (.dmark+2)  
5552 32 70 fe			ld (debug_mark+2),a  
5555 18 03			jr .pastdmark  
5557 ..			.dmark: db "RE2"  
555a f1			.pastdmark: pop af  
555b			endm  
# End of macro DMARK
555b					CALLMONITOR 
555b cd c1 19			call break_point_state  
555e				endm  
# End of macro CALLMONITOR
555e				endif 
555e cd 75 0f			call ishlzero 
5561			;	ld a, l 
5561			;	add h 
5561			;	cp 0 
5561 ca e8 55			jp z, .readeof 
5564			 
5564				; not eof so hl should point to data to push to stack 
5564			 
5564				if DEBUG_STORESE 
5564					DMARK "RE3" 
5564 f5				push af  
5565 3a 79 55			ld a, (.dmark)  
5568 32 6e fe			ld (debug_mark),a  
556b 3a 7a 55			ld a, (.dmark+1)  
556e 32 6f fe			ld (debug_mark+1),a  
5571 3a 7b 55			ld a, (.dmark+2)  
5574 32 70 fe			ld (debug_mark+2),a  
5577 18 03			jr .pastdmark  
5579 ..			.dmark: db "RE3"  
557c f1			.pastdmark: pop af  
557d			endm  
# End of macro DMARK
557d					CALLMONITOR 
557d cd c1 19			call break_point_state  
5580				endm  
# End of macro CALLMONITOR
5580				endif 
5580 cd fa 20			call forth_push_str 
5583			 
5583				if DEBUG_STORESE 
5583					DMARK "RE4" 
5583 f5				push af  
5584 3a 98 55			ld a, (.dmark)  
5587 32 6e fe			ld (debug_mark),a  
558a 3a 99 55			ld a, (.dmark+1)  
558d 32 6f fe			ld (debug_mark+1),a  
5590 3a 9a 55			ld a, (.dmark+2)  
5593 32 70 fe			ld (debug_mark+2),a  
5596 18 03			jr .pastdmark  
5598 ..			.dmark: db "RE4"  
559b f1			.pastdmark: pop af  
559c			endm  
# End of macro DMARK
559c					CALLMONITOR 
559c cd c1 19			call break_point_state  
559f				endm  
# End of macro CALLMONITOR
559f				endif 
559f				; get next block  or mark as eof 
559f			 
559f 3a 70 fa			ld a, (store_openmaxext)   ; get our limit 
55a2 4f				ld c, a	 
55a3 3a 71 fa			ld a, (store_openext) 
55a6			 
55a6				if DEBUG_STORESE 
55a6					DMARK "RE5" 
55a6 f5				push af  
55a7 3a bb 55			ld a, (.dmark)  
55aa 32 6e fe			ld (debug_mark),a  
55ad 3a bc 55			ld a, (.dmark+1)  
55b0 32 6f fe			ld (debug_mark+1),a  
55b3 3a bd 55			ld a, (.dmark+2)  
55b6 32 70 fe			ld (debug_mark+2),a  
55b9 18 03			jr .pastdmark  
55bb ..			.dmark: db "RE5"  
55be f1			.pastdmark: pop af  
55bf			endm  
# End of macro DMARK
55bf					CALLMONITOR 
55bf cd c1 19			call break_point_state  
55c2				endm  
# End of macro CALLMONITOR
55c2				endif 
55c2 b9				cp c 
55c3 28 23			jr z, .readeof     ; at last extent 
55c5			 
55c5 3c					inc a 
55c6 32 71 fa				ld (store_openext), a 
55c9			 
55c9				if DEBUG_STORESE 
55c9					DMARK "RE6" 
55c9 f5				push af  
55ca 3a de 55			ld a, (.dmark)  
55cd 32 6e fe			ld (debug_mark),a  
55d0 3a df 55			ld a, (.dmark+1)  
55d3 32 6f fe			ld (debug_mark+1),a  
55d6 3a e0 55			ld a, (.dmark+2)  
55d9 32 70 fe			ld (debug_mark+2),a  
55dc 18 03			jr .pastdmark  
55de ..			.dmark: db "RE6"  
55e1 f1			.pastdmark: pop af  
55e2			endm  
# End of macro DMARK
55e2					CALLMONITOR 
55e2 cd c1 19			call break_point_state  
55e5				endm  
# End of macro CALLMONITOR
55e5				endif 
55e5			 
55e5			 
55e5				       NEXTW 
55e5 c3 39 24			jp macro_next 
55e8				endm 
# End of macro NEXTW
55e8			.ateof: 
55e8				;	ld hl, .showeof 
55e8				;	call forth_push_str 
55e8 3e 00		.readeof:	ld a, 0 
55ea 32 71 fa				ld (store_openext), a 
55ed			 
55ed					 
55ed				if DEBUG_STORESE 
55ed					DMARK "REF" 
55ed f5				push af  
55ee 3a 02 56			ld a, (.dmark)  
55f1 32 6e fe			ld (debug_mark),a  
55f4 3a 03 56			ld a, (.dmark+1)  
55f7 32 6f fe			ld (debug_mark+1),a  
55fa 3a 04 56			ld a, (.dmark+2)  
55fd 32 70 fe			ld (debug_mark+2),a  
5600 18 03			jr .pastdmark  
5602 ..			.dmark: db "REF"  
5605 f1			.pastdmark: pop af  
5606			endm  
# End of macro DMARK
5606					CALLMONITOR 
5606 cd c1 19			call break_point_state  
5609				endm  
# End of macro CALLMONITOR
5609				endif 
5609				       NEXTW 
5609 c3 39 24			jp macro_next 
560c				endm 
# End of macro NEXTW
560c			 
560c			;.showeof:   db "eof", 0 
560c			 
560c			 
560c			.EOF: 
560c				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
560c 6d				db WORD_SYS_CORE+89             
560d 4e 56			dw .FORMAT            
560f 04				db 3 + 1 
5610 .. 00			db "EOF",0              
5614				endm 
# End of macro CWHEAD
5614			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5614			; | | e.g. 
5614			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5614			; | | Compatible with PicoSPINet  
5614					; TODO if current block id for stream is zero then push true else false 
5614			 
5614					if DEBUG_FORTH_WORDS_KEY 
5614						DMARK "EOF" 
5614 f5				push af  
5615 3a 29 56			ld a, (.dmark)  
5618 32 6e fe			ld (debug_mark),a  
561b 3a 2a 56			ld a, (.dmark+1)  
561e 32 6f fe			ld (debug_mark+1),a  
5621 3a 2b 56			ld a, (.dmark+2)  
5624 32 70 fe			ld (debug_mark+2),a  
5627 18 03			jr .pastdmark  
5629 ..			.dmark: db "EOF"  
562c f1			.pastdmark: pop af  
562d			endm  
# End of macro DMARK
562d						CALLMONITOR 
562d cd c1 19			call break_point_state  
5630				endm  
# End of macro CALLMONITOR
5630					endif 
5630			 
5630					; TODO handlue multiple file streams 
5630			 
5630			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5630 cd 39 56				call .testeof 
5633 cd 8c 20				call forth_push_numhl 
5636			 
5636			 
5636				       NEXTW 
5636 c3 39 24			jp macro_next 
5639				endm 
# End of macro NEXTW
5639			 
5639			.testeof: 
5639 2e 01				ld l, 1 
563b 3a 70 fa				ld a, (store_openmaxext) 
563e fe 00				cp 0 
5640 28 09				jr  z, .eofdone   ; empty file 
5642 3a 71 fa				ld a, (store_openext) 
5645 fe 00				cp 0 
5647 28 02				jr  z, .eofdone 
5649 2e 00				ld l, 0 
564b 26 00		.eofdone:	ld h, 0 
564d c9					ret 
564e			 
564e			 
564e			 
564e			 
564e			.FORMAT: 
564e				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
564e 6d				db WORD_SYS_CORE+89             
564f 9f 56			dw .LABEL            
5651 07				db 6 + 1 
5652 .. 00			db "FORMAT",0              
5659				endm 
# End of macro CWHEAD
5659			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5659			; | | Compatible with PicoSPINet  
5659					; TODO if current block id for stream is zero then push true else false 
5659				 
5659				if DEBUG_STORESE 
5659					DMARK "FOR" 
5659 f5				push af  
565a 3a 6e 56			ld a, (.dmark)  
565d 32 6e fe			ld (debug_mark),a  
5660 3a 6f 56			ld a, (.dmark+1)  
5663 32 6f fe			ld (debug_mark+1),a  
5666 3a 70 56			ld a, (.dmark+2)  
5669 32 70 fe			ld (debug_mark+2),a  
566c 18 03			jr .pastdmark  
566e ..			.dmark: db "FOR"  
5671 f1			.pastdmark: pop af  
5672			endm  
# End of macro DMARK
5672					CALLMONITOR 
5672 cd c1 19			call break_point_state  
5675				endm  
# End of macro CALLMONITOR
5675				endif 
5675					; Wipes the bank check flags to cause a reformat on next block 0 read 
5675			 
5675 21 01 00				ld hl, 1 
5678 3e 00				ld a, 0 
567a cd 21 02				call se_writebyte 
567d			 
567d				if DEBUG_STORESE 
567d					DMARK "FO0" 
567d f5				push af  
567e 3a 92 56			ld a, (.dmark)  
5681 32 6e fe			ld (debug_mark),a  
5684 3a 93 56			ld a, (.dmark+1)  
5687 32 6f fe			ld (debug_mark+1),a  
568a 3a 94 56			ld a, (.dmark+2)  
568d 32 70 fe			ld (debug_mark+2),a  
5690 18 03			jr .pastdmark  
5692 ..			.dmark: db "FO0"  
5695 f1			.pastdmark: pop af  
5696			endm  
# End of macro DMARK
5696					CALLMONITOR 
5696 cd c1 19			call break_point_state  
5699				endm  
# End of macro CALLMONITOR
5699				endif 
5699					; force bank init 
5699			 
5699 cd cd 04				call storage_get_block_0 
569c					 
569c				       NEXTW 
569c c3 39 24			jp macro_next 
569f				endm 
# End of macro NEXTW
569f			.LABEL: 
569f				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
569f 6d				db WORD_SYS_CORE+89             
56a0 ed 56			dw .STOREPAGE            
56a2 06				db 5 + 1 
56a3 .. 00			db "LABEL",0              
56a9				endm 
# End of macro CWHEAD
56a9			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
56a9			; | | Compatible with PicoSPINet  
56a9					; TODO test to see if bank is selected 
56a9				 
56a9					if DEBUG_FORTH_WORDS_KEY 
56a9						DMARK "LBL" 
56a9 f5				push af  
56aa 3a be 56			ld a, (.dmark)  
56ad 32 6e fe			ld (debug_mark),a  
56b0 3a bf 56			ld a, (.dmark+1)  
56b3 32 6f fe			ld (debug_mark+1),a  
56b6 3a c0 56			ld a, (.dmark+2)  
56b9 32 70 fe			ld (debug_mark+2),a  
56bc 18 03			jr .pastdmark  
56be ..			.dmark: db "LBL"  
56c1 f1			.pastdmark: pop af  
56c2			endm  
# End of macro DMARK
56c2						CALLMONITOR 
56c2 cd c1 19			call break_point_state  
56c5				endm  
# End of macro CALLMONITOR
56c5					endif 
56c5			;	if DEBUG_STORESE 
56c5			;		DMARK "LBL" 
56c5			;		CALLMONITOR 
56c5			;	endif 
56c5					FORTH_DSP_VALUEHL 
56c5 cd 83 22			call macro_dsp_valuehl 
56c8				endm 
# End of macro FORTH_DSP_VALUEHL
56c8					;v5FORTH_DSP_VALUE 
56c8					 
56c8			;		push hl 
56c8					FORTH_DSP_POP 
56c8 cd 3b 23			call macro_forth_dsp_pop 
56cb				endm 
# End of macro FORTH_DSP_POP
56cb			;		pop hl 
56cb			 
56cb			;v5		inc hl   ; move past the type marker 
56cb			 
56cb				if DEBUG_STORESE 
56cb					DMARK "LBl" 
56cb f5				push af  
56cc 3a e0 56			ld a, (.dmark)  
56cf 32 6e fe			ld (debug_mark),a  
56d2 3a e1 56			ld a, (.dmark+1)  
56d5 32 6f fe			ld (debug_mark+1),a  
56d8 3a e2 56			ld a, (.dmark+2)  
56db 32 70 fe			ld (debug_mark+2),a  
56de 18 03			jr .pastdmark  
56e0 ..			.dmark: db "LBl"  
56e3 f1			.pastdmark: pop af  
56e4			endm  
# End of macro DMARK
56e4					CALLMONITOR 
56e4 cd c1 19			call break_point_state  
56e7				endm  
# End of macro CALLMONITOR
56e7				endif 
56e7 cd f1 05				call storage_label 
56ea			 
56ea				       NEXTW 
56ea c3 39 24			jp macro_next 
56ed				endm 
# End of macro NEXTW
56ed			.STOREPAGE: 
56ed				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
56ed 6d				db WORD_SYS_CORE+89             
56ee 20 57			dw .LABELS            
56f0 0a				db 9 + 1 
56f1 .. 00			db "STOREPAGE",0              
56fb				endm 
# End of macro CWHEAD
56fb			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
56fb			; | | Compatible with PicoSPINet  
56fb					; TODO test to see if bank is selected 
56fb				 
56fb					if DEBUG_FORTH_WORDS_KEY 
56fb						DMARK "STP" 
56fb f5				push af  
56fc 3a 10 57			ld a, (.dmark)  
56ff 32 6e fe			ld (debug_mark),a  
5702 3a 11 57			ld a, (.dmark+1)  
5705 32 6f fe			ld (debug_mark+1),a  
5708 3a 12 57			ld a, (.dmark+2)  
570b 32 70 fe			ld (debug_mark+2),a  
570e 18 03			jr .pastdmark  
5710 ..			.dmark: db "STP"  
5713 f1			.pastdmark: pop af  
5714			endm  
# End of macro DMARK
5714						CALLMONITOR 
5714 cd c1 19			call break_point_state  
5717				endm  
# End of macro CALLMONITOR
5717					endif 
5717			;	if DEBUG_STORESE 
5717			;		DMARK "STP" 
5717			;		CALLMONITOR 
5717			;	endif 
5717			 
5717 21 81 fa			ld hl, store_page 
571a cd 8c 20			call forth_push_numhl 
571d			 
571d			 
571d				       NEXTW 
571d c3 39 24			jp macro_next 
5720				endm 
# End of macro NEXTW
5720			.LABELS: 
5720				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5720 6d				db WORD_SYS_CORE+89             
5721 aa 57			dw .SCONST1            
5723 07				db 6 + 1 
5724 .. 00			db "LABELS",0              
572b				endm 
# End of macro CWHEAD
572b			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
572b			; | | *NOT* Compatible with PicoSPINet  
572b					;  
572b			 
572b					; save the current device selected to restore afterwards 
572b				 
572b 3a 67 fa				ld a, (spi_device) 
572e f5					push af 
572f			 
572f			 
572f					; run through each of the banks 
572f			 
572f 21 01 00				ld hl, 1 
5732 cd 8c 20				call forth_push_numhl 
5735 3e ff				ld a, SPI_CE_HIGH 
5737 cb 87				res SPI_CE0, a 
5739 32 67 fa				ld (spi_device), a 
573c cd cd 04				call storage_get_block_0 
573f 21 84 fa				ld hl, store_page+3 
5742 cd fa 20				call forth_push_str 
5745			 
5745					 
5745 21 02 00				ld hl, 2 
5748 cd 8c 20				call forth_push_numhl 
574b 3e ff				ld a, SPI_CE_HIGH 
574d cb 8f				res SPI_CE1, a 
574f 32 67 fa				ld (spi_device), a 
5752 cd cd 04				call storage_get_block_0 
5755 21 84 fa				ld hl, store_page+3 
5758 cd fa 20				call forth_push_str 
575b			 
575b					 
575b 21 03 00				ld hl, 3 
575e cd 8c 20				call forth_push_numhl 
5761 3e ff				ld a, SPI_CE_HIGH 
5763 cb 97				res SPI_CE2, a 
5765 32 67 fa				ld (spi_device), a 
5768 cd cd 04				call storage_get_block_0 
576b 21 84 fa				ld hl, store_page+3 
576e cd fa 20				call forth_push_str 
5771			 
5771			 
5771 21 04 00				ld hl, 4 
5774 cd 8c 20				call forth_push_numhl 
5777 3e ff				ld a, SPI_CE_HIGH 
5779 cb 9f				res SPI_CE3, a 
577b 32 67 fa				ld (spi_device), a 
577e cd cd 04				call storage_get_block_0 
5781 21 84 fa				ld hl, store_page+3 
5784 cd fa 20				call forth_push_str 
5787			 
5787					 
5787			 
5787 21 05 00				ld hl, 5 
578a cd 8c 20				call forth_push_numhl 
578d 3e ff				ld a, SPI_CE_HIGH 
578f cb a7				res SPI_CE4, a 
5791 32 67 fa				ld (spi_device), a 
5794 cd cd 04				call storage_get_block_0 
5797 21 84 fa				ld hl, store_page+3 
579a cd fa 20				call forth_push_str 
579d			 
579d					 
579d					; push fixed count of storage devices (on board) for now 
579d			 
579d 21 05 00				ld hl, 5 
57a0 cd 8c 20				call forth_push_numhl 
57a3			 
57a3					; restore selected device  
57a3				 
57a3 f1					pop af 
57a4 32 67 fa				ld (spi_device), a 
57a7			 
57a7				       NEXTW 
57a7 c3 39 24			jp macro_next 
57aa				endm 
# End of macro NEXTW
57aa			 
57aa			.SCONST1: 
57aa				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
57aa 6d				db WORD_SYS_CORE+89             
57ab c1 57			dw .SCONST2            
57ad 07				db 6 + 1 
57ae .. 00			db "FILEID",0              
57b5				endm 
# End of macro CWHEAD
57b5			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
57b5			; | | Compatible with PicoSPINet  
57b5 3a 6e fa				ld a, (store_filecache) 
57b8 26 00				ld h, 0 
57ba 6f					ld l, a 
57bb cd 8c 20				call forth_push_numhl 
57be					NEXTW 
57be c3 39 24			jp macro_next 
57c1				endm 
# End of macro NEXTW
57c1			.SCONST2: 
57c1				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
57c1 6d				db WORD_SYS_CORE+89             
57c2 d9 57			dw .SCONST3            
57c4 08				db 7 + 1 
57c5 .. 00			db "FILEEXT",0              
57cd				endm 
# End of macro CWHEAD
57cd			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
57cd			; | | Compatible with PicoSPINet  
57cd 3a 71 fa				ld a, (store_openext) 
57d0 26 00				ld h, 0 
57d2 6f					ld l, a 
57d3 cd 8c 20				call forth_push_numhl 
57d6					NEXTW 
57d6 c3 39 24			jp macro_next 
57d9				endm 
# End of macro NEXTW
57d9			.SCONST3: 
57d9				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
57d9 6d				db WORD_SYS_CORE+89             
57da f1 57			dw .SCONST4            
57dc 08				db 7 + 1 
57dd .. 00			db "FILEMAX",0              
57e5				endm 
# End of macro CWHEAD
57e5			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
57e5			; | | Compatible with PicoSPINet  
57e5 3a 70 fa				ld a, (store_openmaxext) 
57e8 26 00				ld h, 0 
57ea 6f					ld l, a 
57eb cd 8c 20				call forth_push_numhl 
57ee					NEXTW 
57ee c3 39 24			jp macro_next 
57f1				endm 
# End of macro NEXTW
57f1			.SCONST4: 
57f1				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
57f1 6d				db WORD_SYS_CORE+89             
57f2 07 58			dw .SCONST5            
57f4 09				db 8 + 1 
57f5 .. 00			db "FILEADDR",0              
57fe				endm 
# End of macro CWHEAD
57fe			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
57fe			; | | Compatible with PicoSPINet  
57fe 2a 72 fa				ld hl, (store_openaddr) 
5801 cd 8c 20				call forth_push_numhl 
5804					NEXTW 
5804 c3 39 24			jp macro_next 
5807				endm 
# End of macro NEXTW
5807			.SCONST5: 
5807				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5807 6d				db WORD_SYS_CORE+89             
5808 28 58			dw .SCONST6            
580a 09				db 8 + 1 
580b .. 00			db "FILEPAGE",0              
5814				endm 
# End of macro CWHEAD
5814			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5814			; | | Compatible with PicoSPINet  
5814 2a 72 fa				ld hl, (store_openaddr) 
5817 e5					push hl 
5818 c1					pop bc 
5819 16 00				ld d, 0 
581b 1e 40				ld e, STORE_BLOCK_PHY 
581d cd a9 0e				call Div16 
5820 c5					push bc 
5821 e1					pop hl 
5822 cd 8c 20				call forth_push_numhl 
5825					NEXTW 
5825 c3 39 24			jp macro_next 
5828				endm 
# End of macro NEXTW
5828			.SCONST6: 
5828				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5828 6d				db WORD_SYS_CORE+89             
5829 41 58			dw .ENDSTORAGE            
582b 09				db 8 + 1 
582c .. 00			db "READCONT",0              
5835				endm 
# End of macro CWHEAD
5835			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5835			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5835			; | | a further read should, if applicable, be CONCAT to the previous read. 
5835			; | | Compatible with PicoSPINet  
5835 3a 74 fa				ld a, (store_readcont) 
5838 26 00				ld h, 0 
583a 6f					ld l, a 
583b cd 8c 20				call forth_push_numhl 
583e					NEXTW 
583e c3 39 24			jp macro_next 
5841				endm 
# End of macro NEXTW
5841			.ENDSTORAGE: 
5841			; eof 
# End of file forth_words_storage.asm
5841			endif 
5841				include "forth_words_device.asm" 
5841			; Device related words 
5841			 
5841			; | ## Device Words 
5841			 
5841			;if SOUND_ENABLE 
5841			;.NOTE: 
5841			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5841			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
5841			;		if DEBUG_FORTH_WORDS_KEY 
5841			;			DMARK "NTE" 
5841			;			CALLMONITOR 
5841			;		endif 
5841			; 
5841			;	 
5841			; 
5841			;		NEXTW 
5841			;.AFTERSOUND: 
5841			;endif 
5841			 
5841			 
5841			USE_GPIO: equ 0 
5841			 
5841			if USE_GPIO 
5841			.GP1: 
5841				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5841			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
5841					NEXTW 
5841			.GP2: 
5841				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5841			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
5841			 
5841					NEXTW 
5841			 
5841			.GP3: 
5841				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5841			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
5841			 
5841					NEXTW 
5841			 
5841			.GP4: 
5841				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5841			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
5841			 
5841					NEXTW 
5841			.SIN: 
5841			 
5841			 
5841			endif 
5841			 
5841			 
5841				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5841 33				db WORD_SYS_CORE+31             
5842 76 58			dw .SOUT            
5844 03				db 2 + 1 
5845 .. 00			db "IN",0              
5848				endm 
# End of macro CWHEAD
5848			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5848					if DEBUG_FORTH_WORDS_KEY 
5848						DMARK "IN." 
5848 f5				push af  
5849 3a 5d 58			ld a, (.dmark)  
584c 32 6e fe			ld (debug_mark),a  
584f 3a 5e 58			ld a, (.dmark+1)  
5852 32 6f fe			ld (debug_mark+1),a  
5855 3a 5f 58			ld a, (.dmark+2)  
5858 32 70 fe			ld (debug_mark+2),a  
585b 18 03			jr .pastdmark  
585d ..			.dmark: db "IN."  
5860 f1			.pastdmark: pop af  
5861			endm  
# End of macro DMARK
5861						CALLMONITOR 
5861 cd c1 19			call break_point_state  
5864				endm  
# End of macro CALLMONITOR
5864					endif 
5864					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5864 cd 83 22			call macro_dsp_valuehl 
5867				endm 
# End of macro FORTH_DSP_VALUEHL
5867			 
5867 e5					push hl 
5868			 
5868					; destroy value TOS 
5868			 
5868					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5868 cd 3b 23			call macro_forth_dsp_pop 
586b				endm 
# End of macro FORTH_DSP_POP
586b			 
586b					; one value on hl get other one back 
586b			 
586b c1					pop bc 
586c			 
586c					; do the sub 
586c			;		ex de, hl 
586c			 
586c ed 68				in l,(c) 
586e			 
586e					; save it 
586e			 
586e 26 00				ld h,0 
5870			 
5870					; TODO push value back onto stack for another op etc 
5870			 
5870 cd 8c 20				call forth_push_numhl 
5873					NEXTW 
5873 c3 39 24			jp macro_next 
5876				endm 
# End of macro NEXTW
5876			.SOUT: 
5876				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5876 34				db WORD_SYS_CORE+32             
5877 c9 58			dw .SPIO            
5879 04				db 3 + 1 
587a .. 00			db "OUT",0              
587e				endm 
# End of macro CWHEAD
587e			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
587e					if DEBUG_FORTH_WORDS_KEY 
587e						DMARK "OUT" 
587e f5				push af  
587f 3a 93 58			ld a, (.dmark)  
5882 32 6e fe			ld (debug_mark),a  
5885 3a 94 58			ld a, (.dmark+1)  
5888 32 6f fe			ld (debug_mark+1),a  
588b 3a 95 58			ld a, (.dmark+2)  
588e 32 70 fe			ld (debug_mark+2),a  
5891 18 03			jr .pastdmark  
5893 ..			.dmark: db "OUT"  
5896 f1			.pastdmark: pop af  
5897			endm  
# End of macro DMARK
5897						CALLMONITOR 
5897 cd c1 19			call break_point_state  
589a				endm  
# End of macro CALLMONITOR
589a					endif 
589a			 
589a					; get port 
589a			 
589a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
589a cd 83 22			call macro_dsp_valuehl 
589d				endm 
# End of macro FORTH_DSP_VALUEHL
589d			 
589d e5					push hl 
589e			 
589e					; destroy value TOS 
589e			 
589e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
589e cd 3b 23			call macro_forth_dsp_pop 
58a1				endm 
# End of macro FORTH_DSP_POP
58a1			 
58a1					; get byte to send 
58a1			 
58a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58a1 cd 83 22			call macro_dsp_valuehl 
58a4				endm 
# End of macro FORTH_DSP_VALUEHL
58a4			 
58a4			;		push hl 
58a4			 
58a4					; destroy value TOS 
58a4			 
58a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58a4 cd 3b 23			call macro_forth_dsp_pop 
58a7				endm 
# End of macro FORTH_DSP_POP
58a7			 
58a7					; one value on hl get other one back 
58a7			 
58a7			;		pop hl 
58a7			 
58a7 c1					pop bc 
58a8			 
58a8					if DEBUG_FORTH_WORDS 
58a8						DMARK "OUT" 
58a8 f5				push af  
58a9 3a bd 58			ld a, (.dmark)  
58ac 32 6e fe			ld (debug_mark),a  
58af 3a be 58			ld a, (.dmark+1)  
58b2 32 6f fe			ld (debug_mark+1),a  
58b5 3a bf 58			ld a, (.dmark+2)  
58b8 32 70 fe			ld (debug_mark+2),a  
58bb 18 03			jr .pastdmark  
58bd ..			.dmark: db "OUT"  
58c0 f1			.pastdmark: pop af  
58c1			endm  
# End of macro DMARK
58c1						CALLMONITOR 
58c1 cd c1 19			call break_point_state  
58c4				endm  
# End of macro CALLMONITOR
58c4					endif 
58c4			 
58c4 ed 69				out (c), l 
58c6			 
58c6					NEXTW 
58c6 c3 39 24			jp macro_next 
58c9				endm 
# End of macro NEXTW
58c9			 
58c9			 
58c9			.SPIO: 
58c9			 
58c9			if STORAGE_SE 
58c9				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
58c9 51				db WORD_SYS_CORE+61             
58ca da 58			dw .SPICEH            
58cc 07				db 6 + 1 
58cd .. 00			db "SPICEL",0              
58d4				endm 
# End of macro CWHEAD
58d4			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
58d4			 
58d4 cd ca 01				call spi_ce_low 
58d7			    NEXTW 
58d7 c3 39 24			jp macro_next 
58da				endm 
# End of macro NEXTW
58da			 
58da			.SPICEH: 
58da				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
58da 51				db WORD_SYS_CORE+61             
58db eb 58			dw .SPIOb            
58dd 07				db 6 + 1 
58de .. 00			db "SPICEH",0              
58e5				endm 
# End of macro CWHEAD
58e5			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
58e5			 
58e5 cd b9 01				call spi_ce_high 
58e8			    NEXTW 
58e8 c3 39 24			jp macro_next 
58eb				endm 
# End of macro NEXTW
58eb			 
58eb			 
58eb			.SPIOb: 
58eb			 
58eb				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
58eb 51				db WORD_SYS_CORE+61             
58ec 1d 59			dw .SPII            
58ee 05				db 4 + 1 
58ef .. 00			db "SPIO",0              
58f4				endm 
# End of macro CWHEAD
58f4			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
58f4			 
58f4					if DEBUG_FORTH_WORDS_KEY 
58f4						DMARK "SPo" 
58f4 f5				push af  
58f5 3a 09 59			ld a, (.dmark)  
58f8 32 6e fe			ld (debug_mark),a  
58fb 3a 0a 59			ld a, (.dmark+1)  
58fe 32 6f fe			ld (debug_mark+1),a  
5901 3a 0b 59			ld a, (.dmark+2)  
5904 32 70 fe			ld (debug_mark+2),a  
5907 18 03			jr .pastdmark  
5909 ..			.dmark: db "SPo"  
590c f1			.pastdmark: pop af  
590d			endm  
# End of macro DMARK
590d						CALLMONITOR 
590d cd c1 19			call break_point_state  
5910				endm  
# End of macro CALLMONITOR
5910					endif 
5910					; get port 
5910			 
5910			 
5910					; get byte to send 
5910			 
5910					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5910 cd 83 22			call macro_dsp_valuehl 
5913				endm 
# End of macro FORTH_DSP_VALUEHL
5913			 
5913			;		push hl    ; u1  
5913			 
5913					; destroy value TOS 
5913			 
5913					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5913 cd 3b 23			call macro_forth_dsp_pop 
5916				endm 
# End of macro FORTH_DSP_POP
5916			 
5916					; one value on hl get other one back 
5916			 
5916			;		pop hl   ; u2 - addr 
5916			 
5916					; TODO Send SPI byte 
5916			 
5916			;		push hl 
5916			;		call spi_ce_low 
5916			;		pop hl 
5916 7d					ld a, l 
5917 cd b8 00				call spi_send_byte 
591a			;		call spi_ce_high 
591a			 
591a					NEXTW 
591a c3 39 24			jp macro_next 
591d				endm 
# End of macro NEXTW
591d			 
591d			.SPII: 
591d				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
591d 52				db WORD_SYS_CORE+62             
591e 86 59			dw .SESEL            
5920 06				db 5 + 1 
5921 .. 00			db "SPII",0              
5926				endm 
# End of macro CWHEAD
5926			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5926					if DEBUG_FORTH_WORDS_KEY 
5926						DMARK "SPi" 
5926 f5				push af  
5927 3a 3b 59			ld a, (.dmark)  
592a 32 6e fe			ld (debug_mark),a  
592d 3a 3c 59			ld a, (.dmark+1)  
5930 32 6f fe			ld (debug_mark+1),a  
5933 3a 3d 59			ld a, (.dmark+2)  
5936 32 70 fe			ld (debug_mark+2),a  
5939 18 03			jr .pastdmark  
593b ..			.dmark: db "SPi"  
593e f1			.pastdmark: pop af  
593f			endm  
# End of macro DMARK
593f						CALLMONITOR 
593f cd c1 19			call break_point_state  
5942				endm  
# End of macro CALLMONITOR
5942					endif 
5942			 
5942					; TODO Get SPI byte 
5942			 
5942 cd df 00				call spi_read_byte 
5945			 
5945					if DEBUG_FORTH_WORDS 
5945						DMARK "Si2" 
5945 f5				push af  
5946 3a 5a 59			ld a, (.dmark)  
5949 32 6e fe			ld (debug_mark),a  
594c 3a 5b 59			ld a, (.dmark+1)  
594f 32 6f fe			ld (debug_mark+1),a  
5952 3a 5c 59			ld a, (.dmark+2)  
5955 32 70 fe			ld (debug_mark+2),a  
5958 18 03			jr .pastdmark  
595a ..			.dmark: db "Si2"  
595d f1			.pastdmark: pop af  
595e			endm  
# End of macro DMARK
595e						CALLMONITOR 
595e cd c1 19			call break_point_state  
5961				endm  
# End of macro CALLMONITOR
5961					endif 
5961 26 00				ld h, 0 
5963 6f					ld l, a 
5964					if DEBUG_FORTH_WORDS 
5964						DMARK "Si3" 
5964 f5				push af  
5965 3a 79 59			ld a, (.dmark)  
5968 32 6e fe			ld (debug_mark),a  
596b 3a 7a 59			ld a, (.dmark+1)  
596e 32 6f fe			ld (debug_mark+1),a  
5971 3a 7b 59			ld a, (.dmark+2)  
5974 32 70 fe			ld (debug_mark+2),a  
5977 18 03			jr .pastdmark  
5979 ..			.dmark: db "Si3"  
597c f1			.pastdmark: pop af  
597d			endm  
# End of macro DMARK
597d						CALLMONITOR 
597d cd c1 19			call break_point_state  
5980				endm  
# End of macro CALLMONITOR
5980					endif 
5980 cd 8c 20				call forth_push_numhl 
5983			 
5983					NEXTW 
5983 c3 39 24			jp macro_next 
5986				endm 
# End of macro NEXTW
5986			 
5986			 
5986			 
5986			.SESEL: 
5986				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5986 66				db WORD_SYS_CORE+82             
5987 2f 5a			dw .CARTDEV            
5989 05				db 4 + 1 
598a .. 00			db "BANK",0              
598f				endm 
# End of macro CWHEAD
598f			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
598f					if DEBUG_FORTH_WORDS_KEY 
598f						DMARK "BNK" 
598f f5				push af  
5990 3a a4 59			ld a, (.dmark)  
5993 32 6e fe			ld (debug_mark),a  
5996 3a a5 59			ld a, (.dmark+1)  
5999 32 6f fe			ld (debug_mark+1),a  
599c 3a a6 59			ld a, (.dmark+2)  
599f 32 70 fe			ld (debug_mark+2),a  
59a2 18 03			jr .pastdmark  
59a4 ..			.dmark: db "BNK"  
59a7 f1			.pastdmark: pop af  
59a8			endm  
# End of macro DMARK
59a8						CALLMONITOR 
59a8 cd c1 19			call break_point_state  
59ab				endm  
# End of macro CALLMONITOR
59ab					endif 
59ab			 
59ab 3e ff				ld a, 255 
59ad 32 6a fa				ld (spi_cartdev), a 
59b0			 
59b0					; get bank 
59b0			 
59b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59b0 cd 83 22			call macro_dsp_valuehl 
59b3				endm 
# End of macro FORTH_DSP_VALUEHL
59b3			 
59b3			;		push hl 
59b3			 
59b3					; destroy value TOS 
59b3			 
59b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59b3 cd 3b 23			call macro_forth_dsp_pop 
59b6				endm 
# End of macro FORTH_DSP_POP
59b6			 
59b6					; one value on hl get other one back 
59b6			 
59b6			;		pop hl 
59b6			 
59b6			 
59b6 0e ff				ld c, SPI_CE_HIGH 
59b8 06 30				ld b, '0'    ; human readable bank number 
59ba			 
59ba 7d					ld a, l 
59bb			 
59bb					if DEBUG_FORTH_WORDS 
59bb						DMARK "BNK" 
59bb f5				push af  
59bc 3a d0 59			ld a, (.dmark)  
59bf 32 6e fe			ld (debug_mark),a  
59c2 3a d1 59			ld a, (.dmark+1)  
59c5 32 6f fe			ld (debug_mark+1),a  
59c8 3a d2 59			ld a, (.dmark+2)  
59cb 32 70 fe			ld (debug_mark+2),a  
59ce 18 03			jr .pastdmark  
59d0 ..			.dmark: db "BNK"  
59d3 f1			.pastdmark: pop af  
59d4			endm  
# End of macro DMARK
59d4						CALLMONITOR 
59d4 cd c1 19			call break_point_state  
59d7				endm  
# End of macro CALLMONITOR
59d7					endif 
59d7			 
59d7					; active low 
59d7			 
59d7 fe 00				cp 0 
59d9 28 28				jr z, .bset 
59db fe 01				cp 1 
59dd 20 04				jr nz, .b2 
59df cb 81				res 0, c 
59e1 06 31				ld b, '1'    ; human readable bank number 
59e3 fe 02		.b2:		cp 2 
59e5 20 04				jr nz, .b3 
59e7 cb 89				res 1, c 
59e9 06 32				ld b, '2'    ; human readable bank number 
59eb fe 03		.b3:		cp 3 
59ed 20 04				jr nz, .b4 
59ef cb 91				res 2, c 
59f1 06 33				ld b, '3'    ; human readable bank number 
59f3 fe 04		.b4:		cp 4 
59f5 20 04				jr nz, .b5 
59f7 cb 99				res 3, c 
59f9 06 34				ld b, '4'    ; human readable bank number 
59fb fe 05		.b5:		cp 5 
59fd 20 04				jr nz, .bset 
59ff cb a1				res 4, c 
5a01 06 35				ld b, '5'    ; human readable bank number 
5a03			 
5a03			.bset: 
5a03 79					ld a, c 
5a04 32 67 fa				ld (spi_device),a 
5a07 78					ld a, b 
5a08 32 66 fa				ld (spi_device_id),a 
5a0b					if DEBUG_FORTH_WORDS 
5a0b						DMARK "BN2" 
5a0b f5				push af  
5a0c 3a 20 5a			ld a, (.dmark)  
5a0f 32 6e fe			ld (debug_mark),a  
5a12 3a 21 5a			ld a, (.dmark+1)  
5a15 32 6f fe			ld (debug_mark+1),a  
5a18 3a 22 5a			ld a, (.dmark+2)  
5a1b 32 70 fe			ld (debug_mark+2),a  
5a1e 18 03			jr .pastdmark  
5a20 ..			.dmark: db "BN2"  
5a23 f1			.pastdmark: pop af  
5a24			endm  
# End of macro DMARK
5a24						CALLMONITOR 
5a24 cd c1 19			call break_point_state  
5a27				endm  
# End of macro CALLMONITOR
5a27					endif 
5a27			 
5a27					; set default SPI clk pulse time as disabled for BANK use 
5a27			 
5a27 3e 00				ld a, 0 
5a29 32 6b fa				ld (spi_clktime), a 
5a2c			 
5a2c					NEXTW 
5a2c c3 39 24			jp macro_next 
5a2f				endm 
# End of macro NEXTW
5a2f			 
5a2f			.CARTDEV: 
5a2f				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5a2f 66				db WORD_SYS_CORE+82             
5a30 dd 5a			dw .ENDDEVICE            
5a32 08				db 7 + 1 
5a33 .. 00			db "CARTDEV",0              
5a3b				endm 
# End of macro CWHEAD
5a3b			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5a3b					if DEBUG_FORTH_WORDS_KEY 
5a3b						DMARK "CDV" 
5a3b f5				push af  
5a3c 3a 50 5a			ld a, (.dmark)  
5a3f 32 6e fe			ld (debug_mark),a  
5a42 3a 51 5a			ld a, (.dmark+1)  
5a45 32 6f fe			ld (debug_mark+1),a  
5a48 3a 52 5a			ld a, (.dmark+2)  
5a4b 32 70 fe			ld (debug_mark+2),a  
5a4e 18 03			jr .pastdmark  
5a50 ..			.dmark: db "CDV"  
5a53 f1			.pastdmark: pop af  
5a54			endm  
# End of macro DMARK
5a54						CALLMONITOR 
5a54 cd c1 19			call break_point_state  
5a57				endm  
# End of macro CALLMONITOR
5a57					endif 
5a57			 
5a57					; disable se storage bank selection 
5a57			 
5a57 3e ff				ld a, SPI_CE_HIGH		; ce high 
5a59 32 67 fa				ld (spi_device), a 
5a5c			 
5a5c					; get bank 
5a5c			 
5a5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a5c cd 83 22			call macro_dsp_valuehl 
5a5f				endm 
# End of macro FORTH_DSP_VALUEHL
5a5f			 
5a5f			;		push hl 
5a5f			 
5a5f					; destroy value TOS 
5a5f			 
5a5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a5f cd 3b 23			call macro_forth_dsp_pop 
5a62				endm 
# End of macro FORTH_DSP_POP
5a62			 
5a62					; one value on hl get other one back 
5a62			 
5a62			;		pop hl 
5a62			 
5a62					; active low 
5a62			 
5a62 0e ff				ld c, 255 
5a64			 
5a64 7d					ld a, l 
5a65					if DEBUG_FORTH_WORDS 
5a65						DMARK "CDV" 
5a65 f5				push af  
5a66 3a 7a 5a			ld a, (.dmark)  
5a69 32 6e fe			ld (debug_mark),a  
5a6c 3a 7b 5a			ld a, (.dmark+1)  
5a6f 32 6f fe			ld (debug_mark+1),a  
5a72 3a 7c 5a			ld a, (.dmark+2)  
5a75 32 70 fe			ld (debug_mark+2),a  
5a78 18 03			jr .pastdmark  
5a7a ..			.dmark: db "CDV"  
5a7d f1			.pastdmark: pop af  
5a7e			endm  
# End of macro DMARK
5a7e						CALLMONITOR 
5a7e cd c1 19			call break_point_state  
5a81				endm  
# End of macro CALLMONITOR
5a81					endif 
5a81 fe 00				cp 0 
5a83 28 30				jr z, .cset 
5a85 fe 01				cp 1 
5a87 20 02				jr nz, .c2 
5a89 cb 81				res 0, c 
5a8b fe 02		.c2:		cp 2 
5a8d 20 02				jr nz, .c3 
5a8f cb 89				res 1, c 
5a91 fe 03		.c3:		cp 3 
5a93 20 02				jr nz, .c4 
5a95 cb 91				res 2, c 
5a97 fe 04		.c4:		cp 4 
5a99 20 02				jr nz, .c5 
5a9b cb 99				res 3, c 
5a9d fe 05		.c5:		cp 5 
5a9f 20 02				jr nz, .c6 
5aa1 cb a1				res 4, c 
5aa3 fe 06		.c6:		cp 6 
5aa5 20 02				jr nz, .c7 
5aa7 cb a9				res 5, c 
5aa9 fe 07		.c7:		cp 7 
5aab 20 02				jr nz, .c8 
5aad cb b1				res 6, c 
5aaf fe 08		.c8:		cp 8 
5ab1 20 02				jr nz, .cset 
5ab3 cb b9				res 7, c 
5ab5 79			.cset:		ld a, c 
5ab6 32 6a fa				ld (spi_cartdev),a 
5ab9			 
5ab9					if DEBUG_FORTH_WORDS 
5ab9						DMARK "CD2" 
5ab9 f5				push af  
5aba 3a ce 5a			ld a, (.dmark)  
5abd 32 6e fe			ld (debug_mark),a  
5ac0 3a cf 5a			ld a, (.dmark+1)  
5ac3 32 6f fe			ld (debug_mark+1),a  
5ac6 3a d0 5a			ld a, (.dmark+2)  
5ac9 32 70 fe			ld (debug_mark+2),a  
5acc 18 03			jr .pastdmark  
5ace ..			.dmark: db "CD2"  
5ad1 f1			.pastdmark: pop af  
5ad2			endm  
# End of macro DMARK
5ad2						CALLMONITOR 
5ad2 cd c1 19			call break_point_state  
5ad5				endm  
# End of macro CALLMONITOR
5ad5					endif 
5ad5			 
5ad5					; set default SPI clk pulse time as 10ms for CARTDEV use 
5ad5			 
5ad5 3e 0a				ld a, $0a 
5ad7 32 6b fa				ld (spi_clktime), a 
5ada					NEXTW 
5ada c3 39 24			jp macro_next 
5add				endm 
# End of macro NEXTW
5add			endif 
5add			 
5add			.ENDDEVICE: 
5add			; eof 
5add			 
# End of file forth_words_device.asm
5add			 
5add			; var handler 
5add			 
5add			 
5add			.VARS: 
5add				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5add 77				db WORD_SYS_CORE+99             
5ade 8e 5b			dw .V0            
5ae0 04				db 3 + 1 
5ae1 .. 00			db "VAR",0              
5ae5				endm 
# End of macro CWHEAD
5ae5			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5ae5			;| 
5ae5			;| The variable name should consist of a single letter. e.g. "a" 
5ae5			;! If a full string is passed then only the first char is looked at 
5ae5			;| Any other char could exceed bounds checks!  
5ae5			 
5ae5					if DEBUG_FORTH_WORDS_KEY 
5ae5						DMARK "VAR" 
5ae5 f5				push af  
5ae6 3a fa 5a			ld a, (.dmark)  
5ae9 32 6e fe			ld (debug_mark),a  
5aec 3a fb 5a			ld a, (.dmark+1)  
5aef 32 6f fe			ld (debug_mark+1),a  
5af2 3a fc 5a			ld a, (.dmark+2)  
5af5 32 70 fe			ld (debug_mark+2),a  
5af8 18 03			jr .pastdmark  
5afa ..			.dmark: db "VAR"  
5afd f1			.pastdmark: pop af  
5afe			endm  
# End of macro DMARK
5afe						CALLMONITOR 
5afe cd c1 19			call break_point_state  
5b01				endm  
# End of macro CALLMONITOR
5b01					endif 
5b01			 
5b01					FORTH_DSP_VALUEHL 
5b01 cd 83 22			call macro_dsp_valuehl 
5b04				endm 
# End of macro FORTH_DSP_VALUEHL
5b04			 
5b04 7e					ld a, (hl)    ; get first char on of the string 
5b05			 
5b05			 
5b05					if DEBUG_FORTH_WORDS 
5b05						DMARK "VR1" 
5b05 f5				push af  
5b06 3a 1a 5b			ld a, (.dmark)  
5b09 32 6e fe			ld (debug_mark),a  
5b0c 3a 1b 5b			ld a, (.dmark+1)  
5b0f 32 6f fe			ld (debug_mark+1),a  
5b12 3a 1c 5b			ld a, (.dmark+2)  
5b15 32 70 fe			ld (debug_mark+2),a  
5b18 18 03			jr .pastdmark  
5b1a ..			.dmark: db "VR1"  
5b1d f1			.pastdmark: pop af  
5b1e			endm  
# End of macro DMARK
5b1e						CALLMONITOR 
5b1e cd c1 19			call break_point_state  
5b21				endm  
# End of macro CALLMONITOR
5b21					endif 
5b21					 
5b21 f5					push af	 
5b22					FORTH_DSP_POP 
5b22 cd 3b 23			call macro_forth_dsp_pop 
5b25				endm 
# End of macro FORTH_DSP_POP
5b25 f1					pop af 
5b26			 
5b26					; convert to upper 
5b26			 
5b26 cd b9 12				call to_upper 
5b29					if DEBUG_FORTH_WORDS 
5b29						DMARK "Vaa" 
5b29 f5				push af  
5b2a 3a 3e 5b			ld a, (.dmark)  
5b2d 32 6e fe			ld (debug_mark),a  
5b30 3a 3f 5b			ld a, (.dmark+1)  
5b33 32 6f fe			ld (debug_mark+1),a  
5b36 3a 40 5b			ld a, (.dmark+2)  
5b39 32 70 fe			ld (debug_mark+2),a  
5b3c 18 03			jr .pastdmark  
5b3e ..			.dmark: db "Vaa"  
5b41 f1			.pastdmark: pop af  
5b42			endm  
# End of macro DMARK
5b42						CALLMONITOR 
5b42 cd c1 19			call break_point_state  
5b45				endm  
# End of macro CALLMONITOR
5b45					endif 
5b45 06 41				ld b, 'A' 
5b47 90					sub b			; set offset 
5b48					if DEBUG_FORTH_WORDS 
5b48						DMARK "Vbb" 
5b48 f5				push af  
5b49 3a 5d 5b			ld a, (.dmark)  
5b4c 32 6e fe			ld (debug_mark),a  
5b4f 3a 5e 5b			ld a, (.dmark+1)  
5b52 32 6f fe			ld (debug_mark+1),a  
5b55 3a 5f 5b			ld a, (.dmark+2)  
5b58 32 70 fe			ld (debug_mark+2),a  
5b5b 18 03			jr .pastdmark  
5b5d ..			.dmark: db "Vbb"  
5b60 f1			.pastdmark: pop af  
5b61			endm  
# End of macro DMARK
5b61						CALLMONITOR 
5b61 cd c1 19			call break_point_state  
5b64				endm  
# End of macro CALLMONITOR
5b64					endif 
5b64 cb 27				sla a  
5b66				 
5b66					 
5b66					if DEBUG_FORTH_WORDS 
5b66						DMARK "VR2" 
5b66 f5				push af  
5b67 3a 7b 5b			ld a, (.dmark)  
5b6a 32 6e fe			ld (debug_mark),a  
5b6d 3a 7c 5b			ld a, (.dmark+1)  
5b70 32 6f fe			ld (debug_mark+1),a  
5b73 3a 7d 5b			ld a, (.dmark+2)  
5b76 32 70 fe			ld (debug_mark+2),a  
5b79 18 03			jr .pastdmark  
5b7b ..			.dmark: db "VR2"  
5b7e f1			.pastdmark: pop af  
5b7f			endm  
# End of macro DMARK
5b7f						CALLMONITOR 
5b7f cd c1 19			call break_point_state  
5b82				endm  
# End of macro CALLMONITOR
5b82					endif 
5b82			 
5b82 21 fb f9				ld hl, cli_var_array2 
5b85 cd 4c 0f				call addatohl 
5b88 cd 8c 20				call forth_push_numhl 
5b8b			 
5b8b			 
5b8b				       NEXTW 
5b8b c3 39 24			jp macro_next 
5b8e				endm 
# End of macro NEXTW
5b8e			.V0: 
5b8e				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5b8e 78				db WORD_SYS_CORE+100             
5b8f a6 5b			dw .V0Q            
5b91 04				db 3 + 1 
5b92 .. 00			db "V0!",0              
5b96				endm 
# End of macro CWHEAD
5b96			;| V0! ( u1 -- )  Store value to v0  | DONE 
5b96			 
5b96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b96 cd 83 22			call macro_dsp_valuehl 
5b99				endm 
# End of macro FORTH_DSP_VALUEHL
5b99			 
5b99 11 2f fa				ld de, cli_var_array 
5b9c			 
5b9c eb					ex de, hl 
5b9d 73					ld (hl), e 
5b9e 23					inc hl 
5b9f 72					ld (hl), d 
5ba0			 
5ba0					; destroy value TOS 
5ba0			 
5ba0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ba0 cd 3b 23			call macro_forth_dsp_pop 
5ba3				endm 
# End of macro FORTH_DSP_POP
5ba3			 
5ba3				       NEXTW 
5ba3 c3 39 24			jp macro_next 
5ba6				endm 
# End of macro NEXTW
5ba6			.V0Q: 
5ba6				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5ba6 79				db WORD_SYS_CORE+101             
5ba7 b7 5b			dw .V1S            
5ba9 04				db 3 + 1 
5baa .. 00			db "V0@",0              
5bae				endm 
# End of macro CWHEAD
5bae			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5bae 2a 2f fa				ld hl, (cli_var_array) 
5bb1 cd 8c 20				call forth_push_numhl 
5bb4			 
5bb4				       NEXTW 
5bb4 c3 39 24			jp macro_next 
5bb7				endm 
# End of macro NEXTW
5bb7			.V1S: 
5bb7				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5bb7 7a				db WORD_SYS_CORE+102             
5bb8 cf 5b			dw .V1Q            
5bba 04				db 3 + 1 
5bbb .. 00			db "V1!",0              
5bbf				endm 
# End of macro CWHEAD
5bbf			;| V1! ( u1 -- )  Store value to v1 | DONE 
5bbf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5bbf cd 83 22			call macro_dsp_valuehl 
5bc2				endm 
# End of macro FORTH_DSP_VALUEHL
5bc2			 
5bc2 11 31 fa				ld de, cli_var_array+2 
5bc5				 
5bc5 eb					ex de, hl 
5bc6 73					ld (hl), e 
5bc7 23					inc hl 
5bc8 72					ld (hl), d 
5bc9			 
5bc9					; destroy value TOS 
5bc9			 
5bc9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5bc9 cd 3b 23			call macro_forth_dsp_pop 
5bcc				endm 
# End of macro FORTH_DSP_POP
5bcc				       NEXTW 
5bcc c3 39 24			jp macro_next 
5bcf				endm 
# End of macro NEXTW
5bcf			.V1Q: 
5bcf				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5bcf 7b				db WORD_SYS_CORE+103             
5bd0 e0 5b			dw .V2S            
5bd2 04				db 3 + 1 
5bd3 .. 00			db "V1@",0              
5bd7				endm 
# End of macro CWHEAD
5bd7			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5bd7 2a 31 fa				ld hl, (cli_var_array+2) 
5bda cd 8c 20				call forth_push_numhl 
5bdd				       NEXTW 
5bdd c3 39 24			jp macro_next 
5be0				endm 
# End of macro NEXTW
5be0			.V2S: 
5be0				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5be0 7c				db WORD_SYS_CORE+104             
5be1 f8 5b			dw .V2Q            
5be3 04				db 3 + 1 
5be4 .. 00			db "V2!",0              
5be8				endm 
# End of macro CWHEAD
5be8			;| V2! ( u1 -- )  Store value to v2 | DONE 
5be8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5be8 cd 83 22			call macro_dsp_valuehl 
5beb				endm 
# End of macro FORTH_DSP_VALUEHL
5beb			 
5beb 11 33 fa				ld de, cli_var_array+4 
5bee				 
5bee eb					ex de, hl 
5bef 73					ld (hl), e 
5bf0 23					inc hl 
5bf1 72					ld (hl), d 
5bf2			 
5bf2					; destroy value TOS 
5bf2			 
5bf2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5bf2 cd 3b 23			call macro_forth_dsp_pop 
5bf5				endm 
# End of macro FORTH_DSP_POP
5bf5				       NEXTW 
5bf5 c3 39 24			jp macro_next 
5bf8				endm 
# End of macro NEXTW
5bf8			.V2Q: 
5bf8				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5bf8 7d				db WORD_SYS_CORE+105             
5bf9 09 5c			dw .V3S            
5bfb 04				db 3 + 1 
5bfc .. 00			db "V2@",0              
5c00				endm 
# End of macro CWHEAD
5c00			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5c00 2a 33 fa				ld hl, (cli_var_array+4) 
5c03 cd 8c 20				call forth_push_numhl 
5c06				       NEXTW 
5c06 c3 39 24			jp macro_next 
5c09				endm 
# End of macro NEXTW
5c09			.V3S: 
5c09				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5c09 7c				db WORD_SYS_CORE+104             
5c0a 21 5c			dw .V3Q            
5c0c 04				db 3 + 1 
5c0d .. 00			db "V3!",0              
5c11				endm 
# End of macro CWHEAD
5c11			;| V3! ( u1 -- )  Store value to v3 | DONE 
5c11					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c11 cd 83 22			call macro_dsp_valuehl 
5c14				endm 
# End of macro FORTH_DSP_VALUEHL
5c14			 
5c14 11 35 fa				ld de, cli_var_array+6 
5c17				 
5c17 eb					ex de, hl 
5c18 73					ld (hl), e 
5c19 23					inc hl 
5c1a 72					ld (hl), d 
5c1b			 
5c1b					; destroy value TOS 
5c1b			 
5c1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c1b cd 3b 23			call macro_forth_dsp_pop 
5c1e				endm 
# End of macro FORTH_DSP_POP
5c1e				       NEXTW 
5c1e c3 39 24			jp macro_next 
5c21				endm 
# End of macro NEXTW
5c21			.V3Q: 
5c21				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5c21 7d				db WORD_SYS_CORE+105             
5c22 32 5c			dw .END            
5c24 04				db 3 + 1 
5c25 .. 00			db "V3@",0              
5c29				endm 
# End of macro CWHEAD
5c29			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5c29 2a 35 fa				ld hl, (cli_var_array+6) 
5c2c cd 8c 20				call forth_push_numhl 
5c2f				       NEXTW 
5c2f c3 39 24			jp macro_next 
5c32				endm 
# End of macro NEXTW
5c32			 
5c32			 
5c32			 
5c32			 
5c32			 
5c32			; end of dict marker 
5c32			 
5c32 00			.END:    db WORD_SYS_END 
5c33 00 00			dw 0 
5c35 00				db 0 
5c36			 
5c36			; use to jp here for user dict words to save on macro expansion  
5c36			 
5c36			user_dict_next: 
5c36				NEXTW 
5c36 c3 39 24			jp macro_next 
5c39				endm 
# End of macro NEXTW
5c39			 
5c39			 
5c39			user_exec: 
5c39				;    ld hl, <word code> 
5c39				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5c39				;    call forthexec 
5c39				;    jp user_dict_next   (NEXT) 
5c39			        ;    <word code bytes> 
5c39 eb				ex de, hl 
5c3a 2a c9 f4			ld hl,(os_tok_ptr) 
5c3d				 
5c3d				FORTH_RSP_NEXT 
5c3d cd 33 20			call macro_forth_rsp_next 
5c40				endm 
# End of macro FORTH_RSP_NEXT
5c40			 
5c40			if DEBUG_FORTH_UWORD 
5c40						DMARK "UEX" 
5c40 f5				push af  
5c41 3a 55 5c			ld a, (.dmark)  
5c44 32 6e fe			ld (debug_mark),a  
5c47 3a 56 5c			ld a, (.dmark+1)  
5c4a 32 6f fe			ld (debug_mark+1),a  
5c4d 3a 57 5c			ld a, (.dmark+2)  
5c50 32 70 fe			ld (debug_mark+2),a  
5c53 18 03			jr .pastdmark  
5c55 ..			.dmark: db "UEX"  
5c58 f1			.pastdmark: pop af  
5c59			endm  
# End of macro DMARK
5c59				CALLMONITOR 
5c59 cd c1 19			call break_point_state  
5c5c				endm  
# End of macro CALLMONITOR
5c5c			endif 
5c5c			 
5c5c			 
5c5c			 
5c5c eb				ex de, hl 
5c5d 22 c9 f4			ld (os_tok_ptr), hl 
5c60				 
5c60				; Don't use next - Skips the first word in uword. 
5c60			 
5c60 c3 ca 24			jp exec1 
5c63			;	NEXT 
5c63			 
5c63			 
5c63			; eof 
# End of file forth_wordsv4.asm
5c63			endif 
5c63			;;;;;;;;;;;;;; Debug code 
5c63			 
5c63			 
5c63			;if DEBUG_FORTH_PARSE 
5c63 .. 00		.nowordfound: db "No match",0 
5c6c .. 00		.compword:	db "Comparing word ",0 
5c7c .. 00		.nextwordat:	db "Next word at",0 
5c89 .. 00		.charmatch:	db "Char match",0 
5c94			;endif 
5c94			if DEBUG_FORTH_JP 
5c94			.foundword:	db "Word match. Exec..",0 
5c94			endif 
5c94			;if DEBUG_FORTH_PUSH 
5c94 .. 00		.enddict:	db "Dict end. Push.",0 
5ca4 .. 00		.push_str:	db "Pushing string",0 
5cb3 .. 00		.push_num:	db "Pushing number",0 
5cc2 .. 00		.data_sp:	db "SP:",0 
5cc6 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5cd8 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5cea .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5cfc			;endif 
5cfc			;if DEBUG_FORTH_MALLOC 
5cfc .. 00		.push_malloc:	db "Malloc address",0 
5d0b			;endif 
5d0b			 
5d0b			 
5d0b			 
5d0b			; display malloc address and current data stack pointer  
5d0b			 
5d0b			malloc_error: 
5d0b d5				push de 
5d0c f5				push af 
5d0d e5				push hl 
5d0e cd 18 0d			call clear_display 
5d11 11 33 5d			ld de, .mallocerr 
5d14 3e 00			ld a,0 
5d16			;	ld de,os_word_scratch 
5d16 cd 2b 0d			call str_at_display 
5d19 3e 11			ld a, display_row_1+17 
5d1b 11 6e fe			ld de, debug_mark 
5d1e cd 2b 0d			call str_at_display 
5d21 cd 3b 0d			call update_display 
5d24				;call break_point_state 
5d24 cd 00 78			call cin_wait 
5d27			 
5d27 3e 20			ld a, ' ' 
5d29 32 b9 f1			ld (os_view_disable), a 
5d2c e1				pop hl 
5d2d f1				pop af 
5d2e d1				pop de	 
5d2f				CALLMONITOR 
5d2f cd c1 19			call break_point_state  
5d32				endm  
# End of macro CALLMONITOR
5d32 c9				ret 
5d33			 
5d33 .. 00		.mallocerr: 	db "Malloc Error",0 
5d40			;if DEBUG_FORTH_PUSH 
5d40			display_data_sp: 
5d40 f5				push af 
5d41			 
5d41				; see if disabled 
5d41			 
5d41 3a b9 f1			ld a, (os_view_disable) 
5d44 fe 2a			cp '*' 
5d46 28 67			jr z, .skipdsp 
5d48			 
5d48 e5				push hl 
5d49 e5				push hl 
5d4a e5			push hl 
5d4b cd 18 0d			call clear_display 
5d4e e1			pop hl 
5d4f 7c				ld a,h 
5d50 21 cd f4			ld hl, os_word_scratch 
5d53 cd 4d 12			call hexout 
5d56 e1				pop hl 
5d57 7d				ld a,l 
5d58 21 cf f4			ld hl, os_word_scratch+2 
5d5b cd 4d 12			call hexout 
5d5e 21 d1 f4			ld hl, os_word_scratch+4 
5d61 3e 00			ld a,0 
5d63 77				ld (hl),a 
5d64 11 cd f4			ld de,os_word_scratch 
5d67 3e 28				ld a, display_row_2 
5d69 cd 2b 0d				call str_at_display 
5d6c 11 c6 5c			ld de, .wordinhl 
5d6f 3e 00			ld a, display_row_1 
5d71			 
5d71 cd 2b 0d				call str_at_display 
5d74 11 6e fe			ld de, debug_mark 
5d77 3e 11			ld a, display_row_1+17 
5d79			 
5d79 cd 2b 0d				call str_at_display 
5d7c			 
5d7c				; display current data stack pointer 
5d7c 11 c2 5c			ld de,.data_sp 
5d7f 3e 30				ld a, display_row_2 + 8 
5d81 cd 2b 0d				call str_at_display 
5d84			 
5d84 2a f5 f9			ld hl,(cli_data_sp) 
5d87 e5				push hl 
5d88 7c				ld a,h 
5d89 21 cd f4			ld hl, os_word_scratch 
5d8c cd 4d 12			call hexout 
5d8f e1				pop hl 
5d90 7d				ld a,l 
5d91 21 cf f4			ld hl, os_word_scratch+2 
5d94 cd 4d 12			call hexout 
5d97 21 d1 f4			ld hl, os_word_scratch+4 
5d9a 3e 00			ld a,0 
5d9c 77				ld (hl),a 
5d9d 11 cd f4			ld de,os_word_scratch 
5da0 3e 33				ld a, display_row_2 + 11 
5da2 cd 2b 0d				call str_at_display 
5da5			 
5da5			 
5da5 cd 3b 0d			call update_display 
5da8 cd 95 0c			call delay1s 
5dab cd 95 0c			call delay1s 
5dae e1				pop hl 
5daf			.skipdsp: 
5daf f1				pop af 
5db0 c9				ret 
5db1			 
5db1			display_data_malloc: 
5db1			 
5db1 f5				push af 
5db2 e5				push hl 
5db3 e5				push hl 
5db4 e5			push hl 
5db5 cd 18 0d			call clear_display 
5db8 e1			pop hl 
5db9 7c				ld a,h 
5dba 21 cd f4			ld hl, os_word_scratch 
5dbd cd 4d 12			call hexout 
5dc0 e1				pop hl 
5dc1 7d				ld a,l 
5dc2 21 cf f4			ld hl, os_word_scratch+2 
5dc5 cd 4d 12			call hexout 
5dc8 21 d1 f4			ld hl, os_word_scratch+4 
5dcb 3e 00			ld a,0 
5dcd 77				ld (hl),a 
5dce 11 cd f4			ld de,os_word_scratch 
5dd1 3e 28				ld a, display_row_2 
5dd3 cd 2b 0d				call str_at_display 
5dd6 11 fc 5c			ld de, .push_malloc 
5dd9 3e 00			ld a, display_row_1 
5ddb			 
5ddb cd 2b 0d				call str_at_display 
5dde			 
5dde				; display current data stack pointer 
5dde 11 c2 5c			ld de,.data_sp 
5de1 3e 30				ld a, display_row_2 + 8 
5de3 cd 2b 0d				call str_at_display 
5de6			 
5de6 2a f5 f9			ld hl,(cli_data_sp) 
5de9 e5				push hl 
5dea 7c				ld a,h 
5deb 21 cd f4			ld hl, os_word_scratch 
5dee cd 4d 12			call hexout 
5df1 e1				pop hl 
5df2 7d				ld a,l 
5df3 21 cf f4			ld hl, os_word_scratch+2 
5df6 cd 4d 12			call hexout 
5df9 21 d1 f4			ld hl, os_word_scratch+4 
5dfc 3e 00			ld a,0 
5dfe 77				ld (hl),a 
5dff 11 cd f4			ld de,os_word_scratch 
5e02 3e 33				ld a, display_row_2 + 11 
5e04 cd 2b 0d				call str_at_display 
5e07			 
5e07 cd 3b 0d			call update_display 
5e0a cd 95 0c			call delay1s 
5e0d cd 95 0c			call delay1s 
5e10 e1				pop hl 
5e11 f1				pop af 
5e12 c9				ret 
5e13			;endif 
5e13			 
5e13			include "forth_autostart.asm" 
5e13			; list of commands to perform at system start up 
5e13			 
5e13			startcmds: 
5e13			;	dw test11 
5e13			;	dw test12 
5e13			;	dw test13 
5e13			;	dw test14 
5e13			;	dw test15 
5e13			;	dw test16 
5e13			;	dw test17 
5e13			;	dw ifthtest1 
5e13			;	dw ifthtest2 
5e13			;	dw ifthtest3 
5e13			;	dw mmtest1 
5e13			;	dw mmtest2 
5e13			;	dw mmtest3 
5e13			;	dw mmtest4 
5e13			;	dw mmtest5 
5e13			;	dw mmtest6 
5e13			;	dw iftest1 
5e13			;	dw iftest2 
5e13			;	dw iftest3 
5e13			;	dw looptest1 
5e13			;	dw looptest2 
5e13			;	dw test1 
5e13			;	dw test2 
5e13			;	dw test3 
5e13			;	dw test4 
5e13			;	dw game2r 
5e13			;	dw game2b1 
5e13			;	dw game2b2 
5e13			 
5e13				; start up words that are actually useful 
5e13			 
5e13 1b 5f		    dw spi1 
5e15 74 5f		    dw spi2 
5e17 02 60		    dw spi3 
5e19 aa 5f		    dw spi4 
5e1b d5 5f		    dw spi5 
5e1d 68 60		    dw spi6 
5e1f bd 60		    dw spi7 
5e21			 
5e21 15 61		    dw spi8 
5e23 34 61		    dw spi9 
5e25 8c 61		    dw spi10 
5e27			 
5e27			; file editor 
5e27 8d 5e			dw edit1 
5e29 ae 5e			dw edit2 
5e2b e3 5e			dw edit3 
5e2d			 
5e2d ff 61			dw longread 
5e2f 46 62			dw clrstack 
5e31 79 62			dw type 
5e33 64 64			dw stest 
5e35 9d 62			dw strncpy 
5e37 fa 63			dw list 
5e39 fe 62			dw start1 
5e3b 0e 63			dw start2 
5e3d			;	dw start3 
5e3d 1f 63			dw start3b 
5e3f 9a 63			dw start3c 
5e41			 
5e41				; (unit) testing words 
5e41			 
5e41 db 64			dw mtesta 
5e43 90 65			dw mtestb 
5e45 33 66			dw mtestc 
5e47 e8 66			dw mtestd 
5e49 8c 67			dw mteste 
5e4b			 
5e4b				; demo/game words 
5e4b			 
5e4b 98 6e		        dw game3w 
5e4d c6 6e		        dw game3p 
5e4f e4 6e		        dw game3sc 
5e51 15 6f		        dw game3vsi 
5e53 41 6f		        dw game3vs 
5e55				 
5e55 8b 6c			dw game2b 
5e57 f9 6c			dw game2bf 
5e59 43 6d			dw game2mba 
5e5b d9 6d			dw game2mbas 
5e5d 1b 6e			dw game2mb 
5e5f			 
5e5f 4c 69			dw game1 
5e61 5d 69			dw game1a 
5e63 bf 69			dw game1b 
5e65 f4 69			dw game1c 
5e67 2a 6a			dw game1d 
5e69 5b 6a			dw game1s 
5e6b 6f 6a			dw game1t 
5e6d 84 6a			dw game1f 
5e6f b8 6a			dw game1z 
5e71 fc 6a			dw game1zz 
5e73			 
5e73 42 68			dw test5 
5e75 7a 68			dw test6 
5e77 b2 68			dw test7 
5e79 c6 68			dw test8 
5e7b f2 68			dw test9 
5e7d 08 69			dw test10 
5e7f				 
5e7f d3 6b		        dw ssv5 
5e81 b7 6b		        dw ssv4 
5e83 9b 6b		        dw ssv3 
5e85 65 6b		        dw ssv2 
5e87 ec 6b		        dw ssv1 
5e89 34 6c		        dw ssv1cpm 
5e8b			;	dw keyup 
5e8b			;	dw keydown 
5e8b			;	dw keyleft 
5e8b			;	dw keyright 
5e8b			;	dw 	keyf1 
5e8b			;	dw keyf2 
5e8b			;	dw keyf3 
5e8b			;	dw keyf4 
5e8b			;	dw keyf5 
5e8b			;	dw keyf6 
5e8b			;	dw keyf7 
5e8b			;	dw keyf8 
5e8b			;	dw keyf9 
5e8b			;	dw keyf10 
5e8b			;	dw keyf11 
5e8b			;	dw keyf12 
5e8b			;	dw keytab 
5e8b			;	dw keycr 
5e8b			;	dw keyhome 
5e8b			;	dw keyend 
5e8b			;	dw keybs 
5e8b 00 00			db 0, 0	 
5e8d			 
5e8d			 
5e8d			; File Editor 
5e8d			 
5e8d			; ( id - ) use 'e' to edit the displayed line 
5e8d .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5eae .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5ee3			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5ee3 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5f1b			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5f1b			 
5f1b			; SPI Net support words 
5f1b			 
5f1b			; v0! = node to send to 
5f1b			; ( str count - ) 
5f1b .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5f74			 
5f74			; spiputchr ( char node - ) 
5f74 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
5faa			 
5faa			; spigetchr ( - n ) 
5faa .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5fd5			 
5fd5			; getnode ( - n ) 
5fd5 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6002			 
6002			; ( str node - )  
6002 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6068			; store string ( str i - ) 
6068			 
6068			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6068 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
60bd			 
60bd			; get string ( addr i -  )    TO FIX 
60bd			 
60bd .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6115			 
6115			 
6115			; NETCHAT (TODO) 
6115			; Program to allow two nodes to chat with eachother 
6115			; 
6115			; v0 - target node 
6115			;  
6115			; accept input at 0,0 
6115			; if input is string send spitype to target node 
6115			; starting at row 2,0 , while spigetchr is not zero ->  
6115			; 
6115			; 
6115			; TODO add paging of get request 
6115			 
6115			; ( node - ) 
6115 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6134 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
618c .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
61ff			 
61ff			 
61ff			; Long read of currently open file 
61ff .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6246			 
6246			; clear stack  
6246			 
6246 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
6279			 
6279			; type ( addr count - ) 
6279 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
629d			 
629d			; some direct memory words 
629d			; strncpy ( len t f -- t ) 
629d			 
629d .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
62fe			 
62fe .. 00		start1:     	db ": bpon $00 bp ;",0 
630e .. 00		start2:     	db ": bpoff $01 bp ;",0 
631f .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
639a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
63fa			 
63fa			 
63fa			; a handy word to list items on the stack 
63fa			 
63fa .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6464			 
6464			 
6464			; test stack  
6464			; rnd8 stest 
6464			 
6464 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
64db			 
64db			; random malloc and free cycles 
64db			 
64db .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6590			 
6590			; fixed malloc and free cycles 
6590			 
6590 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6633			 
6633			; fixed double string push and drop cycle  
6633			 
6633 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
66e8			 
66e8			; consistent fixed string push and drop cycle  
66e8			 
66e8 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
678c			 
678c .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6842			 
6842			;test1:		db ": aa 1 2 3 ;", 0 
6842			;test2:     	db "111 aa 888 999",0 
6842			;test3:     	db ": bb 77 ;",0 
6842			;test4:     	db "$02 $01 do i . loop bb",0 
6842			 
6842 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
687a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
68b2 .. 00		test7:     	db ": box hline vline ;",0 
68c6 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
68f2 .. 00		test9:     	db ": sw $01 adsp world ;",0 
6908 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
692d .. 00		test11:     	db "hello create .",0 
693c .. 00		test12:     	db "hello2 create .",0 
694c			 
694c			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
694c			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
694c			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
694c			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
694c			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
694c			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
694c			 
694c			;iftest1:     	db "$0001 IF cls .",0 
694c			;iftest2:     	db "$0000 IF cls .",0 
694c			;iftest3:     	db "$0002 $0003 - IF cls .",0 
694c			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
694c			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
694c			 
694c			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
694c			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
694c			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
694c			 
694c			 
694c			 
694c			; a small guess the number game 
694c			 
694c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
695d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
69bf			 
69bf .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
69f4 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6a2a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6a5b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6a6f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6a84 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6ab8 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6afc			 
6afc			; Using 'ga' save a high score across multiple runs using external storage 
6afc			 
6afc .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6b65			 
6b65			 
6b65			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6b65			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6b65			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6b65			 
6b65			; simple screen saver to test code memory reuse to destruction 
6b65			 
6b65 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6b9b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6bb7 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6bd3 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6bec .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6c34 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6c8b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6c8b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6c8b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6c8b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6c8b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6c8b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6c8b			 
6c8b			 
6c8b			 
6c8b			; minesweeper/battleship finding game 
6c8b			; draws a game board of random ship/mine positions 
6c8b			; user enters coords to see if it hits on 
6c8b			; game ends when all are hit 
6c8b			; when hit or miss says how many may be in the area 
6c8b			 
6c8b			; setup the game board and then hide it 
6c8b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6cf9 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6d43			; prompt for where to target 
6d43 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6dd9 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6dfe			; TODO see if the entered coords hits or misses pushes char hit of miss 
6dfe .. 00		game2mbht:      db ": mbckht nop ;",0 
6e0d .. 00		game2mbms:      db ": mbcms nop ;",0 
6e1b			; TODO how many might be near by 
6e1b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6e98			 
6e98			; Game 3 
6e98			 
6e98			; Vert scroller ski game - avoid the trees! 
6e98			 
6e98			; v0 score (ie turns) 
6e98			; v1 player pos 
6e98			; v2 left wall 
6e98			; v3 right wall 
6e98			 
6e98			; Draw side walls randomly 
6e98			 
6e98 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6ec6			 
6ec6			; Draw player 
6ec6 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6ee4			 
6ee4			; TODO Get Key 
6ee4			 
6ee4			; TODO Move left right 
6ee4			 
6ee4			; scroll and move walls a bit 
6ee4			 
6ee4 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6f15			 
6f15			; main game loop 
6f15			 
6f15 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6f41 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6f80			 
6f80			; key board defs 
6f80			 
6f80 .. 00		keyup:       db ": keyup $05 ;",0 
6f8e .. 00		keydown:       db ": keydown $0a ;",0 
6f9e .. 00		keyleft:       db ": keyleft $0b ;",0 
6fae .. 00		keyright:       db ": keyright $0c ;",0 
6fbf .. 00		keyf1:       db ": keyf1 $10 ;",0 
6fcd .. 00		keyf2:       db ": keyf2 $11 ;",0 
6fdb .. 00		keyf3:       db ": keyf3 $12 ;",0 
6fe9 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6ff7 .. 00		keyf5:       db ": keyf5 $14 ;",0 
7005 .. 00		keyf6:       db ": keyf6 $15 ;",0 
7013 .. 00		keyf7:       db ": keyf7 $16 ;",0 
7021 .. 00		keyf8:       db ": keyf8 $17 ;",0 
702f .. 00		keyf9:       db ": keyf9 $18 ;",0 
703d .. 00		keyf10:       db ": keyf10 $19 ;",0 
704c .. 00		keyf11:       db ": keyf11 $1a ;",0 
705b .. 00		keyf12:       db ": keyf12 $1b ;",0 
706a			 
706a .. 00		keytab:       db ": keytab $09 ;",0 
7079 .. 00		keycr:       db ": keycr $0d ;",0 
7087 .. 00		keyhome:       db ": keyhome $0e ;",0 
7097 .. 00		keyend:       db ": keyend $0f ;",0 
70a6 .. 00		keybs:       db ": keybs $08 ;",0 
70b4			 
70b4			   
70b4			 
70b4			 
70b4			 
70b4			; eof 
# End of file forth_autostart.asm
70b4			 
70b4			 
70b4			 
70b4			; stack over and underflow checks 
70b4			 
70b4			; init the words to detect the under/overflow 
70b4			 
70b4			chk_stk_init: 
70b4				; a vague random number to check so we dont get any "lucky" hits 
70b4 3e 2d			ld a, 45 
70b6 6f				ld l, a 
70b7 00				nop 
70b8 3e 17			ld a, 23 
70ba 67				ld h, a 
70bb			 
70bb 22 af f1			ld (chk_word), hl     ; the word we need to check against 
70be			 
70be			;	ld (chk_stund), hl	; stack points.... 
70be 22 fd fe			ld (chk_stovr), hl 
70c1 22 f3 f9			ld (chk_ret_und), hl 
70c4 22 b1 f9			ld (chk_ret_ovr), hl 
70c7 22 2f f9			ld (chk_loop_ovr), hl 
70ca 22 2d f7			ld (chk_data_ovr), hl 
70cd c9				ret 
70ce				 
70ce			check_stacks: 
70ce				; check all stack words 
70ce			 
70ce e5				push hl 
70cf d5				push de 
70d0			 
70d0			;	ld de,(chk_word) 
70d0			;	ld hl, (chk_stund)	; stack points.... 
70d0			;	if DEBUG_STK_FAULT 
70d0			;		DMARK "FAa" 
70d0			;		CALLMONITOR 
70d0			;	endif 
70d0			;	call cmp16 
70d0			;	jp z, .chk_faulta 
70d0			; 
70d0			;	ld de, sfaultsu 
70d0			;	jp .chk_fault 
70d0			 
70d0 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
70d3 ed 5b af f1		ld de,(chk_word) 
70d7				if DEBUG_STK_FAULT 
70d7					DMARK "FAb" 
70d7					CALLMONITOR 
70d7				endif 
70d7 cd 6a 0f			call cmp16 
70da 28 06			jr z, .chk_fault1 
70dc 11 7d 71			ld de, sfaultso 
70df c3 31 71			jp .chk_fault 
70e2			.chk_fault1:  
70e2 2a f3 f9			ld hl, (chk_ret_und) 
70e5 ed 5b af f1		ld de,(chk_word) 
70e9				if DEBUG_STK_FAULT 
70e9					DMARK "FAU" 
70e9					CALLMONITOR 
70e9				endif 
70e9 cd 6a 0f			call cmp16 
70ec ca f5 70			jp z, .chk_fault2 
70ef 11 8d 71			ld de, sfaultru 
70f2 c3 31 71			jp .chk_fault 
70f5			.chk_fault2:  
70f5 2a b1 f9			ld hl, (chk_ret_ovr) 
70f8 ed 5b af f1		ld de,(chk_word) 
70fc				if DEBUG_STK_FAULT 
70fc					DMARK "FA1" 
70fc					CALLMONITOR 
70fc				endif 
70fc cd 6a 0f			call cmp16 
70ff ca 08 71			jp z, .chk_fault3 
7102 11 9b 71			ld de, sfaultro 
7105 c3 31 71			jp .chk_fault 
7108			.chk_fault3:  
7108 2a 2f f9			ld hl, (chk_loop_ovr) 
710b ed 5b af f1		ld de,(chk_word) 
710f				if DEBUG_STK_FAULT 
710f					DMARK "FA2" 
710f					CALLMONITOR 
710f				endif 
710f cd 6a 0f			call cmp16 
7112 ca 1b 71			jp z, .chk_fault4 
7115 11 b5 71			ld de, sfaultlo 
7118 c3 31 71			jp .chk_fault 
711b			.chk_fault4:  
711b 2a 2d f7			ld hl, (chk_data_ovr) 
711e ed 5b af f1		ld de,(chk_word) 
7122				if DEBUG_STK_FAULT 
7122					DMARK "FA3" 
7122					CALLMONITOR 
7122				endif 
7122 cd 6a 0f			call cmp16 
7125 ca 2e 71			jp z, .chk_fault5 
7128 11 cf 71			ld de, sfaultdo 
712b c3 31 71			jp .chk_fault 
712e			 
712e			 
712e			.chk_fault5:  
712e d1				pop de 
712f e1				pop hl 
7130			 
7130 c9				ret 
7131			 
7131 cd 18 0d		.chk_fault: 	call clear_display 
7134 3e 28				ld a, display_row_2 
7136 cd 2b 0d				call str_at_display 
7139 11 5f 71				   ld de, .stackfault 
713c 3e 00				ld a, display_row_1 
713e cd 2b 0d				call str_at_display 
7141 11 6e fe				    ld de, debug_mark 
7144 3e 11				ld a, display_row_1+17 
7146 cd 2b 0d				call str_at_display 
7149 cd 3b 0d				call update_display 
714c			 
714c				; prompt before entering montior for investigating issue 
714c			 
714c 3e 78			ld a, display_row_4 
714e 11 a6 1d			ld de, endprog 
7151			 
7151 cd 3b 0d			call update_display		 
7154			 
7154 cd 04 20			call next_page_prompt 
7157			 
7157 d1				pop de 
7158 e1				pop hl 
7159 cd fa 1d				call monitor 
715c c3 f4 1c				jp warmstart 
715f					;jp 0 
715f					;halt 
715f			 
715f			 
715f			 
715f .. 00		.stackfault: 	db "Stack fault:",0 
716c			 
716c .. 00		sfaultsu: 	db	"Stack under flow",0 
717d .. 00		sfaultso: 	db	"Stack over flow",0 
718d .. 00		sfaultru:	db "RTS underflow",0 
719b .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
71b5 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
71cf .. 00		sfaultdo:	db "DTS overflow", 0 
71dc			 
71dc			 
71dc			fault_dsp_under: 
71dc 11 ee 71			ld de, .dsp_under 
71df c3 9e 72			jp .show_fault 
71e2			 
71e2			fault_rsp_under: 
71e2 11 fc 71			ld de, .rsp_under 
71e5 c3 9e 72			jp .show_fault 
71e8			fault_loop_under: 
71e8 11 0a 72			ld de, .loop_under 
71eb c3 9e 72			jp .show_fault 
71ee			 
71ee .. 00		.dsp_under: db "DSP Underflow",0 
71fc .. 00		.rsp_under: db "RSP Underflow",0 
720a .. 00		.loop_under: db "LOOP Underflow",0 
7219			 
7219			 
7219 d5			type_faultn: 	push de 
721a e5					push hl 
721b cd 18 0d				call clear_display 
721e 11 45 72				   ld de, .typefaultn 
7221 3e 00				ld a, display_row_1 
7223 cd 2b 0d				call str_at_display 
7226 11 6e fe				    ld de, debug_mark 
7229 3e 11				ld a, display_row_1+17 
722b cd 2b 0d				call str_at_display 
722e cd 3b 0d				call update_display 
7231			 
7231				; prompt before entering montior for investigating issue 
7231			 
7231 3e 78			ld a, display_row_4 
7233 11 a6 1d			ld de, endprog 
7236			 
7236 cd 3b 0d			call update_display		 
7239			 
7239 cd 04 20			call next_page_prompt 
723c			 
723c e5					push hl 
723d d5					push de 
723e cd fa 1d				call monitor 
7241 c3 f4 1c				jp warmstart 
7244 76					halt 
7245			 
7245			 
7245 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
725c			 
725c d5			type_faults: 	push de 
725d e5					push hl 
725e cd 18 0d				call clear_display 
7261 11 87 72				   ld de, .typefaults 
7264 3e 00				ld a, display_row_1 
7266 cd 2b 0d				call str_at_display 
7269 11 6e fe				    ld de, debug_mark 
726c 3e 11				ld a, display_row_1+17 
726e cd 2b 0d				call str_at_display 
7271 cd 3b 0d				call update_display 
7274			 
7274				; prompt before entering montior for investigating issue 
7274			 
7274 3e 78			ld a, display_row_4 
7276 11 a6 1d			ld de, endprog 
7279			 
7279 cd 3b 0d			call update_display		 
727c			 
727c cd 04 20			call next_page_prompt 
727f			 
727f e1					pop hl 
7280 d1					pop de 
7281 cd fa 1d				call monitor 
7284 c3 f4 1c				jp warmstart 
7287			 
7287			 
7287 .. 00		.typefaults: db "STR Type Expected TOS!",0 
729e			 
729e			.show_fault: 	 
729e d5					push de 
729f cd 18 0d				call clear_display 
72a2 d1					pop de 
72a3 3e 00				ld a, display_row_1 
72a5 cd 2b 0d				call str_at_display 
72a8 11 6e fe				    ld de, debug_mark 
72ab 3e 11				ld a, display_row_1+17 
72ad cd 2b 0d				call str_at_display 
72b0 cd 3b 0d				call update_display 
72b3			 
72b3				; prompt before entering montior for investigating issue 
72b3			 
72b3 3e 78			ld a, display_row_4 
72b5 11 a6 1d			ld de, endprog 
72b8			 
72b8 cd 3b 0d			call update_display		 
72bb			 
72bb cd 04 20			call next_page_prompt 
72be			 
72be e1					pop hl 
72bf d1					pop de 
72c0 cd fa 1d				call monitor 
72c3			; do a dump to cli and not warmstart so we preserve all of the uwords.  
72c3			; TODO Make optional fault restart to cli or warm boot? 
72c3					;jp warmstart 
72c3 c3 4c 1d				jp cli 
72c6 76					halt 
72c7			 
72c7			; handle the auto run of code from files in storage 
72c7			 
72c7			 
72c7			include "forth_startup.asm" 
72c7			; Which startup method to use? 
72c7			; 
72c7			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
72c7			; followed by loading of a list of scripts in eeprom 
72c7			 
72c7			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
72c7			; from eeprom 
72c7			 
72c7			; Select with define in main stubs 
72c7			 
72c7			if STARTUP_V1 
72c7				include "forth_startupv1.asm" 
72c7			endif 
72c7			if STARTUP_V2 
72c7				include "forth_startupv2.asm" 
72c7			; Version 2 of the startup  
72c7			;  
72c7			; Auto load any files in bank 1 that start with a '*' 
72c7			; If no se storage then revert to using eprom 
72c7			 
72c7			 
72c7			if STORAGE_SE = 0 
72c7			 
72c7			sprompt1: db "Startup load...",0 
72c7			sprompt2: db "Run? 1=No *=End #=All",0 
72c7			 
72c7			 
72c7			 
72c7			 
72c7			forth_startup: 
72c7				ld hl, startcmds 
72c7				ld a, 0 
72c7				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
72c7			 
72c7			.start1:	push hl 
72c7				call clear_display 
72c7				ld de, sprompt1 
72c7			        ld a, display_row_1 
72c7				call str_at_display 
72c7				ld de, sprompt2 
72c7			        ld a, display_row_2 
72c7				call str_at_display 
72c7				pop hl 
72c7				push hl 
72c7				ld e,(hl) 
72c7				inc hl 
72c7				ld d,(hl) 
72c7			        ld a, display_row_3 
72c7				call str_at_display 
72c7				call update_display 
72c7			 
72c7			 
72c7				ld a, (os_last_cmd) 
72c7				cp 0 
72c7				jr z, .startprompt 
72c7				call delay250ms 
72c7				jr .startdo 
72c7				 
72c7				 
72c7			 
72c7			.startprompt: 
72c7			 
72c7				ld a,display_row_4 + display_cols - 1 
72c7			        ld de, endprg 
72c7				call str_at_display 
72c7				call update_display 
72c7				call delay1s 
72c7				call cin_wait 
72c7						 
72c7				cp '*' 
72c7				jr z, .startupend1 
72c7				cp '#' 
72c7				jr nz, .startno 
72c7				ld a, 1 
72c7				ld (os_last_cmd),a 
72c7				jr .startdo 
72c7			.startno:	cp '1' 
72c7				jr z,.startnxt  
72c7			 
72c7				; exec startup line 
72c7			.startdo:	 
72c7				pop hl 
72c7				push hl 
72c7				 
72c7				ld e,(hl) 
72c7				inc hl 
72c7				ld d,(hl) 
72c7				ex de,hl 
72c7			 
72c7				push hl 
72c7			 
72c7				ld a, 0 
72c7				;ld a, FORTH_END_BUFFER 
72c7				call strlent 
72c7				inc hl   ; include zero term to copy 
72c7				ld b,0 
72c7				ld c,l 
72c7				pop hl 
72c7				ld de, scratch 
72c7				ldir 
72c7			 
72c7			 
72c7				ld hl, scratch 
72c7				call forthparse 
72c7				call forthexec 
72c7				call forthexec_cleanup 
72c7			 
72c7				ld a, display_row_4 
72c7				ld de, endprog 
72c7			 
72c7				call update_display		 
72c7			 
72c7				ld a, (os_last_cmd) 
72c7				cp 0 
72c7				jr nz, .startnxt 
72c7				call next_page_prompt 
72c7			        call clear_display 
72c7				call update_display		 
72c7			 
72c7				; move onto next startup line? 
72c7			.startnxt: 
72c7			 
72c7				call delay250ms 
72c7				pop hl 
72c7			 
72c7				inc hl 
72c7				inc hl 
72c7			 
72c7				push hl 
72c7				ld e, (hl) 
72c7				inc hl 
72c7				ld d, (hl) 
72c7				pop hl 
72c7				; TODO replace 0 test 
72c7			 
72c7				ex de, hl 
72c7				call ishlzero 
72c7			;	ld a,e 
72c7			;	add d 
72c7			;	cp 0    ; any left to do? 
72c7				ex de, hl 
72c7				jp nz, .start1 
72c7				jr .startupend 
72c7			 
72c7			.startupend1: pop hl 
72c7			.startupend: 
72c7			 
72c7				call clear_display 
72c7				call update_display 
72c7				ret 
72c7			endif 
72c7			 
72c7			 
72c7			if STORAGE_SE 
72c7			 
72c7 .. 00		sprompt3: db "Loading from start-up file:",0 
72e3			;sprompt4: db "(Any key to stop)",0 
72e3			 
72e3			 
72e3			forth_autoload: 
72e3			 
72e3				; load block 0 of store 1 
72e3				 
72e3 3e fe			ld a, $fe      ; bit 0 clear 
72e5 32 67 fa			ld (spi_device), a 
72e8			 
72e8 cd cd 04			call storage_get_block_0 
72eb			 
72eb 3a a2 fa			ld a, (store_page+STORE_0_AUTOFILE) 
72ee			 
72ee fe 00			cp 0 
72f0 c8				ret z     ; auto start not enabled 
72f1			 
72f1 cd 18 0d			call clear_display 
72f4			 
72f4				; set bank 
72f4			 
72f4 3a a4 fa				ld a, (store_page+STORE_0_BANKRUN) 
72f7 32 67 fa				ld (spi_device), a 
72fa			 
72fa			 
72fa				; generate a directory of bank 1 and search for flagged files 
72fa			 
72fa					if DEBUG_FORTH_WORDS_KEY 
72fa						DMARK "DIR" 
72fa f5				push af  
72fb 3a 0f 73			ld a, (.dmark)  
72fe 32 6e fe			ld (debug_mark),a  
7301 3a 10 73			ld a, (.dmark+1)  
7304 32 6f fe			ld (debug_mark+1),a  
7307 3a 11 73			ld a, (.dmark+2)  
730a 32 70 fe			ld (debug_mark+2),a  
730d 18 03			jr .pastdmark  
730f ..			.dmark: db "DIR"  
7312 f1			.pastdmark: pop af  
7313			endm  
# End of macro DMARK
7313						CALLMONITOR 
7313 cd c1 19			call break_point_state  
7316				endm  
# End of macro CALLMONITOR
7316					endif 
7316			 
7316 cd cd 04			call storage_get_block_0 
7319			 
7319 21 81 fa			ld hl, store_page     ; get current id count 
731c 46				ld b, (hl) 
731d 0e 00			ld c, 0    ; count of files   
731f					if DEBUG_FORTH_WORDS 
731f						DMARK "DI1" 
731f f5				push af  
7320 3a 34 73			ld a, (.dmark)  
7323 32 6e fe			ld (debug_mark),a  
7326 3a 35 73			ld a, (.dmark+1)  
7329 32 6f fe			ld (debug_mark+1),a  
732c 3a 36 73			ld a, (.dmark+2)  
732f 32 70 fe			ld (debug_mark+2),a  
7332 18 03			jr .pastdmark  
7334 ..			.dmark: db "DI1"  
7337 f1			.pastdmark: pop af  
7338			endm  
# End of macro DMARK
7338						CALLMONITOR 
7338 cd c1 19			call break_point_state  
733b				endm  
# End of macro CALLMONITOR
733b					endif 
733b			 
733b				; check for empty drive 
733b			 
733b 3e 00			ld a, 0 
733d b8				cp b 
733e ca 70 73			jp z, .dirdone 
7341			 
7341				; for each of the current ids do a search for them and if found push to stack 
7341			 
7341 c5			.diritem:	push bc 
7342 21 40 00				ld hl, STORE_BLOCK_PHY 
7345 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
7347 58					ld e,b 
7348			 
7348			;		if DEBUG_FORTH_WORDS 
7348			;			DMARK "DI2" 
7348			;			CALLMONITOR 
7348			;		endif 
7348			 
7348 cd 4f 07				call storage_findnextid 
734b			 
734b			;		if DEBUG_FORTH_WORDS 
734b			;			DMARK "DI3" 
734b			;			CALLMONITOR 
734b			;		endif 
734b			 
734b					; if found hl will be non zero 
734b			 
734b cd 75 0f				call ishlzero 
734e			;		ld a, l 
734e			;		add h 
734e			; 
734e			;		cp 0 
734e 28 1d				jr z, .dirnotfound 
7350			 
7350					; increase count 
7350			 
7350 c1					pop bc	 
7351 0c					inc c 
7352 c5					push bc 
7353					 
7353			 
7353					; get file header and push the file name 
7353			 
7353 11 81 fa				ld de, store_page 
7356 cd 1c 04				call storage_read_block 
7359			 
7359					; push file id to stack 
7359				 
7359			 
7359					; is this a file we want to run? 
7359			 
7359 21 84 fa				ld hl, store_page+3 
735c 7e					ld a,(hl) 
735d fe 2a				cp '*' 
735f 20 0c				jr nz,  .dirnotfound 
7361					 
7361			 
7361			 
7361 3a 81 fa				ld a, (store_page) 
7364 d5					push de 
7365 e5					push hl 
7366 c5					push bc 
7367 cd 93 73				call .autorunf 
736a c1					pop bc 
736b e1					pop hl 
736c d1					pop de 
736d			 
736d			 
736d			 
736d				; save this extent 
736d			 
736d					; push file name 
736d			;display file name to run 
736d			 
736d			;		ld hl, store_page+3 
736d			;		if DEBUG_FORTH_WORDS 
736d			;			DMARK "DI5" 
736d			;			CALLMONITOR 
736d			;		endif 
736d			; 
736d			;		 
736d			; 
736d			;		call forth_push_str 
736d			;		if DEBUG_FORTH_WORDS 
736d			;			DMARK "DI6" 
736d			;			CALLMONITOR 
736d			;		endif 
736d			.dirnotfound: 
736d c1					pop bc     
736e 10 d1				djnz .diritem 
7370				 
7370			.dirdone:	 
7370					if DEBUG_FORTH_WORDS 
7370						DMARK "DI7" 
7370 f5				push af  
7371 3a 85 73			ld a, (.dmark)  
7374 32 6e fe			ld (debug_mark),a  
7377 3a 86 73			ld a, (.dmark+1)  
737a 32 6f fe			ld (debug_mark+1),a  
737d 3a 87 73			ld a, (.dmark+2)  
7380 32 70 fe			ld (debug_mark+2),a  
7383 18 03			jr .pastdmark  
7385 ..			.dmark: db "DI7"  
7388 f1			.pastdmark: pop af  
7389			endm  
# End of macro DMARK
7389						CALLMONITOR 
7389 cd c1 19			call break_point_state  
738c				endm  
# End of macro CALLMONITOR
738c					endif 
738c			 
738c cd 18 0d				call clear_display 
738f cd 3b 0d				call update_display 
7392			 
7392 c9					ret 
7393			 
7393			 
7393			 
7393			 
7393			 
7393			.autorunf: 
7393			 
7393			 
7393				; get file id to load from and get the file name to display 
7393			 
7393			;		ld a, (store_page+STORE_0_FILERUN) 
7393			 
7393 2e 00				ld l, 0 
7395 67					ld h, a 
7396 11 81 fa				ld de, store_page 
7399			 
7399					if DEBUG_FORTH_WORDS 
7399						DMARK "ASp" 
7399 f5				push af  
739a 3a ae 73			ld a, (.dmark)  
739d 32 6e fe			ld (debug_mark),a  
73a0 3a af 73			ld a, (.dmark+1)  
73a3 32 6f fe			ld (debug_mark+1),a  
73a6 3a b0 73			ld a, (.dmark+2)  
73a9 32 70 fe			ld (debug_mark+2),a  
73ac 18 03			jr .pastdmark  
73ae ..			.dmark: db "ASp"  
73b1 f1			.pastdmark: pop af  
73b2			endm  
# End of macro DMARK
73b2						CALLMONITOR 
73b2 cd c1 19			call break_point_state  
73b5				endm  
# End of macro CALLMONITOR
73b5					endif 
73b5 cd 75 09				call storage_read 
73b8			 
73b8					if DEBUG_FORTH_WORDS 
73b8						DMARK "ASr" 
73b8 f5				push af  
73b9 3a cd 73			ld a, (.dmark)  
73bc 32 6e fe			ld (debug_mark),a  
73bf 3a ce 73			ld a, (.dmark+1)  
73c2 32 6f fe			ld (debug_mark+1),a  
73c5 3a cf 73			ld a, (.dmark+2)  
73c8 32 70 fe			ld (debug_mark+2),a  
73cb 18 03			jr .pastdmark  
73cd ..			.dmark: db "ASr"  
73d0 f1			.pastdmark: pop af  
73d1			endm  
# End of macro DMARK
73d1						CALLMONITOR 
73d1 cd c1 19			call break_point_state  
73d4				endm  
# End of macro CALLMONITOR
73d4					endif 
73d4			 
73d4 cd 75 0f				call ishlzero 
73d7 c8					ret z             ; file not found 
73d8			 
73d8 3e 32				ld a, display_row_2 + 10 
73da 11 84 fa				ld de, store_page+3 
73dd cd 2b 0d				call str_at_display 
73e0				 
73e0			; 
73e0			 
73e0 3e 05			ld a, display_row_1+5 
73e2 11 c7 72			ld de, sprompt3 
73e5 cd 2b 0d			call str_at_display 
73e8			;	ld a, display_row_3+15 
73e8			;	ld de, sprompt4 
73e8			;	call str_at_display 
73e8			 
73e8 cd 3b 0d			call update_display 
73eb			 
73eb			;	call cin_wait 
73eb			;	cp 'n' 
73eb			;	ret z 
73eb			;	cp 'N' 
73eb			;	ret z 
73eb			 
73eb			;	call delay1s 
73eb			 
73eb 3a 83 fa			ld a, (store_page+2) 
73ee 32 70 fa			ld (store_openmaxext), a    ; save count of ext 
73f1 3e 01			ld a, 1  
73f3 32 71 fa			ld (store_openext), a    ; save count of ext 
73f6			 
73f6			.autof: 
73f6				; begin to read a line from file 
73f6			 
73f6 21 ef f4			ld hl, os_cli_cmd 
73f9 22 ed f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
73fc			  
73fc			.readext: 
73fc 3a 71 fa			ld a, (store_openext) 
73ff 6f				ld l , a 
7400				 
7400 3a 81 fa			ld a, (store_page) 
7403 67				ld h, a	 
7404 11 81 fa			ld de, store_page 
7407					if DEBUG_FORTH_WORDS 
7407						DMARK "ASl" 
7407 f5				push af  
7408 3a 1c 74			ld a, (.dmark)  
740b 32 6e fe			ld (debug_mark),a  
740e 3a 1d 74			ld a, (.dmark+1)  
7411 32 6f fe			ld (debug_mark+1),a  
7414 3a 1e 74			ld a, (.dmark+2)  
7417 32 70 fe			ld (debug_mark+2),a  
741a 18 03			jr .pastdmark  
741c ..			.dmark: db "ASl"  
741f f1			.pastdmark: pop af  
7420			endm  
# End of macro DMARK
7420						CALLMONITOR 
7420 cd c1 19			call break_point_state  
7423				endm  
# End of macro CALLMONITOR
7423					endif 
7423 cd 75 09				call storage_read 
7426 cd 75 0f			call ishlzero 
7429 c8				ret z 
742a			 
742a			; TODO copy to exec buffer 
742a			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
742a			 
742a				; copy the record buffer to the cli buffer 
742a			 
742a ed 5b ed f6		ld de, (os_var_array) 
742e 21 83 fa			ld hl, store_page+2 
7431			;	ex de, hl 
7431 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
7434 ed b0			ldir 
7436 ed 53 ed f6		ld (os_var_array), de 
743a				 
743a 3a 71 fa			ld a, (store_openext) 
743d 3c				inc a 
743e 32 71 fa			ld (store_openext), a    ; save count of ext 
7441			 
7441			 
7441			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7441				 
7441 3a 74 fa			ld a, (store_readcont) 
7444 fe 00			cp 0 
7446 20 b4			jr nz, .readext 
7448			 
7448			;	jr z, .autoend 
7448			 
7448					if DEBUG_FORTH_WORDS 
7448						DMARK "ASc" 
7448 f5				push af  
7449 3a 5d 74			ld a, (.dmark)  
744c 32 6e fe			ld (debug_mark),a  
744f 3a 5e 74			ld a, (.dmark+1)  
7452 32 6f fe			ld (debug_mark+1),a  
7455 3a 5f 74			ld a, (.dmark+2)  
7458 32 70 fe			ld (debug_mark+2),a  
745b 18 03			jr .pastdmark  
745d ..			.dmark: db "ASc"  
7460 f1			.pastdmark: pop af  
7461			endm  
# End of macro DMARK
7461						CALLMONITOR 
7461 cd c1 19			call break_point_state  
7464				endm  
# End of macro CALLMONITOR
7464					endif 
7464 11 83 fa			ld de, store_page+2 
7467 3e 78			ld a, display_row_4 
7469 cd 2b 0d			call str_at_display 
746c			 
746c cd 3b 0d			call update_display 
746f			;	call delay250ms 
746f			 
746f			 
746f			 
746f			 
746f			.autoexec: 
746f			 
746f			 
746f 21 ef f4			ld hl, os_cli_cmd 
7472					if DEBUG_FORTH_WORDS 
7472						DMARK "ASx" 
7472 f5				push af  
7473 3a 87 74			ld a, (.dmark)  
7476 32 6e fe			ld (debug_mark),a  
7479 3a 88 74			ld a, (.dmark+1)  
747c 32 6f fe			ld (debug_mark+1),a  
747f 3a 89 74			ld a, (.dmark+2)  
7482 32 70 fe			ld (debug_mark+2),a  
7485 18 03			jr .pastdmark  
7487 ..			.dmark: db "ASx"  
748a f1			.pastdmark: pop af  
748b			endm  
# End of macro DMARK
748b						CALLMONITOR 
748b cd c1 19			call break_point_state  
748e				endm  
# End of macro CALLMONITOR
748e					endif 
748e cd 87 24			call forthparse 
7491 cd c7 24			call forthexec 
7494 cd d9 23			call forthexec_cleanup 
7497			 
7497			 
7497			 
7497 c3 f6 73			jp .autof 
749a			;.autofdone: 
749a			; 
749a			;		if DEBUG_FORTH_WORDS 
749a			;			DMARK "ASx" 
749a			;			CALLMONITOR 
749a			;		endif 
749a			;;	call clear_display 
749a			;	ret 
749a			 
749a			 
749a			 
749a			endif 
# End of file forth_startupv2.asm
749a			endif 
749a			 
# End of file forth_startup.asm
749a			 
749a			; eof 
# End of file forth_kernel.asm
749a			;include "nascombasic.asm" 
749a			 
749a			 
749a			; find out where the code ends if loaded into RAM (for SC114) 
749a			;endofcode:  
749a			;	nop 
749a			 
749a			 
749a			; eof 
749a			 
# End of file main.asm
749a			include "firmware_lcd_4x40.asm" 
749a			; **********************************************************************  
749a			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
749a			; **********************************************************************  
749a			;  
749a			; **  Written as a Small Computer Monitor App  
749a			; **  www.scc.me.uk  
749a			;  
749a			; History  
749a			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
749a			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
749a			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
749a			;  
749a			; **********************************************************************  
749a			;  
749a			; This program is an example of one of the methods of interfacing an   
749a			; alphanumeric LCD module.   
749a			;  
749a			; In this example the display is connected to either a Z80 PIO or a   
749a			; simple 8-bit output port.   
749a			;  
749a			; This interfacing method uses 4-bit data mode and uses time delays  
749a			; rather than polling the display's ready status. As a result the   
749a			; interface only requires 6 simple output lines:  
749a			;   Output bit 0 = not used  
749a			;   Output bit 1 = not used  
749a			;   Output bit 2 = RS         High = data, Low = instruction  
749a			;   Output bit 3 = E          Active high  
749a			;   Output bit 4 = DB4  
749a			;   Output bit 5 = DB5  
749a			;   Output bit 6 = DB6  
749a			;   Output bit 7 = DB7  
749a			; Display's R/W is connected to 0v so it is always in write mode  
749a			;  
749a			; This set up should work with any system supporting the RC2014 bus  
749a			  
749a			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
749a			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
749a			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
749a			;  
749a			; **********************************************************************  
749a			  
749a			; Additonal for 4x40. E1 and E2 instead of just E   
749a			; TODO swipe vidout signal on port a to activate E2  
749a			  
749a			; **********************************************************************  
749a			; **  Constants  
749a			; **********************************************************************  
749a			; LCD constants required by LCD support module  
749a			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
749a			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
749a			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
749a			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
749a			; TODO Decide which E is being set  
749a			kLCDWidth:  EQU display_cols             ;Width in characters  
749a			  
749a			; **********************************************************************  
749a			; **  Code library usage  
749a			; **********************************************************************  
749a			  
749a			; send character to current cursor position  
749a			; wraps and/or scrolls screen automatically  
749a			  
749a			  
749a			  
749a			lcd_init:  
749a			  
749a			; SCMonAPI functions used  
749a			  
749a			; Alphanumeric LCD functions used  
749a			; no need to specify specific functions for this module  
749a			  
749a 3e cf		            LD   A, 11001111b  
749c d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
749e 3e 00		            LD   A, 00000000b  
74a0 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
74a2			  
74a2			; Initialise alphanumeric LCD module  
74a2 3e 00				ld a, 0  
74a4 32 ce fb				ld (display_lcde1e2), a  
74a7 cd 28 75		            CALL fLCD_Init      ;Initialise LCD module  
74aa 3e 01				ld a, 1  
74ac 32 ce fb				ld (display_lcde1e2), a  
74af cd 28 75		            CALL fLCD_Init      ;Initialise LCD module  
74b2			  
74b2 c9				ret  
74b3			  
74b3			;  
74b3			;;  
74b3			; lcd functions  
74b3			;  
74b3			;  
74b3			  
74b3			; what is at cursor position   
74b3			  
74b3			;get_cursor:	ld de, (cursor_row)   ;  row + col  
74b3			;		call curptr  
74b3			;		ret  
74b3			  
74b3			  
74b3			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
74b3			  
74b3			curptr:  
74b3 c5				push bc  
74b4 21 b4 fd			ld hl, display_fb0  
74b7			cpr:	  
74b7				; loop for cursor whole row  
74b7 0e 28			ld c, display_cols  
74b9 23			cpr1:	inc hl  
74ba 0d				dec c  
74bb 20 fc			jr nz, cpr1  
74bd 05				dec b  
74be 20 f7			jr nz, cpr  
74c0			  
74c0				; add col	  
74c0			  
74c0 23			cpr2:	inc hl  
74c1 1d				dec e  
74c2 20 fc			jr nz, cpr2  
74c4			  
74c4 c1				pop bc  
74c5 c9				ret  
74c6				  
74c6			  
74c6			  
74c6			  
74c6			  
74c6			; write the frame buffer given in hl to hardware   
74c6 22 cc fb		write_display: ld (display_write_tmp), hl 	   
74c9 3e 00			ld a, kLCD_Line1  
74cb cd d5 75		            CALL fLCD_Pos       ;Position cursor to location in A  
74ce 06 28			ld b, display_cols  
74d0 ed 5b cc fb		ld de, (display_write_tmp)  
74d4 cd 20 75			call write_len_string  
74d7				  
74d7				  
74d7 2a cc fb			ld hl, (display_write_tmp)  
74da 11 28 00			ld de, display_cols  
74dd 19				add hl,de  
74de 22 cc fb			ld (display_write_tmp),hl  
74e1			  
74e1				  
74e1 3e 28			ld a, kLCD_Line2  
74e3 cd d5 75		            CALL fLCD_Pos       ;Position cursor to location in A  
74e6 06 28			ld b, display_cols  
74e8 ed 5b cc fb		ld de, (display_write_tmp)  
74ec cd 20 75			call write_len_string  
74ef				  
74ef 2a cc fb			ld hl, (display_write_tmp)  
74f2 11 28 00			ld de, display_cols  
74f5 19				add hl,de  
74f6 22 cc fb			ld (display_write_tmp),hl  
74f9			  
74f9				  
74f9 3e 50			ld a, kLCD_Line3  
74fb cd d5 75		            CALL fLCD_Pos       ;Position cursor to location in A  
74fe 06 28			ld b, display_cols  
7500 ed 5b cc fb		ld de, (display_write_tmp)  
7504 cd 20 75			call write_len_string  
7507				  
7507 2a cc fb			ld hl, (display_write_tmp)  
750a 11 28 00			ld de, display_cols  
750d 19				add hl,de  
750e 22 cc fb			ld (display_write_tmp),hl  
7511			  
7511				  
7511 3e 78			ld a, kLCD_Line4  
7513 cd d5 75		            CALL fLCD_Pos       ;Position cursor to location in A  
7516 06 28			ld b, display_cols  
7518 ed 5b cc fb		ld de, (display_write_tmp)  
751c cd 20 75			call write_len_string  
751f c9					ret  
7520				  
7520				; write out a fixed length string given in b from de  
7520			  
7520 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7521 cd 8d 75		            CALL fLCD_Data      ;Write character to display  
7524 13				inc de  
7525 10 f9			djnz write_len_string  
7527 c9				ret  
7528			  
7528			; Some other things to do  
7528			;            LD   A, kLCD_Clear ;Display clear  
7528			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7528			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7528			;            LD   A, kLCD_On     ;Display on with no cursor  
7528			;            ;LD   A, kLCD_Off   ;Display off  
7528			;            CALL fLCD_Inst      ;Send instruction to display  
7528			;  
7528			;  
7528			;            halt  
7528			;  
7528			;  
7528			;MsgHello:   DB  "Hello World!",0  
7528			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7528			  
7528			; Custom characters 5 pixels wide by 8 pixels high  
7528			; Up to 8 custom characters can be defined  
7528			;BitMaps:      
7528			;; Character 0x00 = Battery icon  
7528			;            DB  01110b  
7528			;            DB  11011b  
7528			;            DB  10001b  
7528			;            DB  10001b  
7528			;            DB  11111b  
7528			;            DB  11111b  
7528			;            DB  11111b  
7528			;            DB  11111b  
7528			;; Character 0x01 = Bluetooth icon  
7528			;            DB  01100b  
7528			;            DB  01010b  
7528			;            DB  11100b  
7528			;            DB  01000b  
7528			;            DB  11100b  
7528			;            DB  01010b  
7528			;            DB  01100b  
7528			;            DB  00000b  
7528			;  
7528			  
7528			  
7528			; **********************************************************************  
7528			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7528			; **********************************************************************  
7528			;  
7528			; **  Written as a Small Computer Monitor App   
7528			; **  Version 0.1 SCC 2018-05-16  
7528			; **  www.scc.me.uk  
7528			;  
7528			; **********************************************************************  
7528			;  
7528			; This module provides support for alphanumeric LCD modules using with  
7528			; *  HD44780 (or compatible) controller  
7528			; *  5 x 7 pixel fonts  
7528			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7528			; *  Interface via six digital outputs to the display (see below)  
7528			;  
7528			; LCD module pinout:  
7528			;   1  Vss   0v supply  
7528			;   2  Vdd   5v supply  
7528			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7528			;   4  RS    High = data, Low = instruction  
7528			;   5  R/W   High = Read, Low = Write  
7528			;   6  E     Enable signal (active high)  
7528			;   7  DB0   Data bit 0  
7528			;   8  DB1   Data bit 1  
7528			;   9  DB2   Data bit 2  
7528			;  10  DB3   Data bit 3  
7528			;  11  DB4   Data bit 4  
7528			;  12  DB5   Data bit 5  
7528			;  13  DB6   Data bit 6  
7528			;  14  DB7   Data bit 7  
7528			;  15  A     Backlight anode (+)  
7528			;  16  K     Backlight cathode (-)  
7528			;  
7528			; This interfacing method uses 4-bit data mode and uses time delays  
7528			; rather than polling the display's ready status. As a result the   
7528			; interface only requires 6 simple output lines:  
7528			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7528			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7528			;   LCD DB4 = Microcomputer output port bit 4  
7528			;   LCD DB5 = Microcomputer output port bit 5  
7528			;   LCD DB6 = Microcomputer output port bit 6  
7528			;   LCD DB7 = Microcomputer output port bit 7  
7528			; Display's R/W is connected to 0v so it is always in write mode  
7528			; All 6 connections must be on the same port address <kLCDPrt>  
7528			; This method also allows a decent length of cable from micro to LCD  
7528			;  
7528			; **********************************************************************  
7528			;  
7528			; To include the code for any given function provided by this module,   
7528			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7528			; the parent source file.  
7528			; For example:  #REQUIRES   uHexPrefix  
7528			;  
7528			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7528			; in the parent source file.  
7528			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7528			;  
7528			; These are the function names provided by this module:  
7528			; fLCD_Init                     ;Initialise LCD  
7528			; fLCD_Inst                     ;Send instruction to LCD  
7528			; fLCD_Data                     ;Send data byte to LCD  
7528			; fLCD_Pos                      ;Position cursor  
7528			; fLCD_Str                      ;Display string  
7528			; fLCD_Def                      ;Define custom character  
7528			;  
7528			; **********************************************************************  
7528			;  
7528			; Requires SCMonAPI.asm to also be included in the project  
7528			;  
7528			  
7528			  
7528			; **********************************************************************  
7528			; **  Constants  
7528			; **********************************************************************  
7528			  
7528			; Constants that must be defined externally  
7528			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7528			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7528			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7528			;kLCDWidth: EQU 20             ;Width in characters  
7528			  
7528			; general line offsets in any frame buffer  
7528			  
7528			  
7528			display_row_1: equ 0  
7528			display_row_2: equ display_row_1+display_cols  
7528			display_row_3: equ display_row_2 + display_cols  
7528			display_row_4: equ display_row_3 + display_cols  
7528			;display_row_4_eol:   
7528			  
7528			  
7528			; Cursor position values for the start of each line  
7528			  
7528			; E  
7528			kLCD_Line1: EQU 0x00   
7528			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7528			; E1  
7528			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7528			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7528			  
7528			; Instructions to send as A register to fLCD_Inst  
7528			kLCD_Clear: EQU 00000001b     ;LCD clear  
7528			kLCD_Off:   EQU 00001000b     ;LCD off  
7528			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7528			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7528			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7528			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7528			  
7528			; Constants used by this code module  
7528			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7528			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7528			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7528			  
7528			  
7528			  
7528			; **********************************************************************  
7528			; **  LCD support functions  
7528			; **********************************************************************  
7528			  
7528			; Initialise alphanumeric LCD module  
7528			; LCD control register codes:  
7528			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7528			;   N    0 = 1-line mode       1 = 2-line mode  
7528			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7528			;   D    0 = Display off       1 = Display on  
7528			;   C    0 = Cursor off        1 = Cursor on  
7528			;   B    0 = Blinking off      1 = Blinking on  
7528			;   ID   0 = Decrement mode    1 = Increment mode  
7528			;   SH   0 = Entire shift off  1 = Entire shift on  
7528 3e 28		fLCD_Init:  LD   A, 40  
752a cd 4f 76		            CALL LCDDelay       ;Delay 40ms after power up  
752d			; For reliable reset set 8-bit mode - 3 times  
752d cd 1f 76		            CALL WrFn8bit       ;Function = 8-bit mode  
7530 cd 1f 76		            CALL WrFn8bit       ;Function = 8-bit mode  
7533 cd 1f 76		            CALL WrFn8bit       ;Function = 8-bit mode  
7536			; Set 4-bit mode  
7536 cd 1b 76		            CALL WrFn4bit       ;Function = 4-bit mode  
7539 cd 4d 76		            CALL LCDDelay1      ;Delay 37 us or more  
753c			; Function set  
753c 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
753e cd 51 75		            CALL fLCD_Inst      ;2 line, display on  
7541			; Display On/Off control  
7541 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7543 cd 51 75		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7546			; Display Clear  
7546 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7548 cd 51 75		            CALL fLCD_Inst      ;Clear display  
754b			; Entry mode  
754b 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
754d cd 51 75		            CALL fLCD_Inst      ;Increment mode, shift off  
7550			; Display module now initialised  
7550 c9			            RET  
7551			; ok to here  
7551			  
7551			; Write instruction to LCD  
7551			;   On entry: A = Instruction byte to be written  
7551			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7551 f5			fLCD_Inst:  PUSH AF  
7552 f5			            PUSH AF  
7553 cd 65 75		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7556 f1			            POP  AF  
7557 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7558 17			            RLA  
7559 17			            RLA  
755a 17			            RLA  
755b cd 65 75		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
755e 3e 02		            LD   A, 2  
7560 cd 4f 76		            CALL LCDDelay       ;Delay 2 ms to complete   
7563 f1			            POP  AF  
7564 c9			            RET  
7565			Wr4bits:   
7565 f5					push af  
7566 3a ce fb				ld a, (display_lcde1e2)  
7569 fe 00				cp 0     ; e  
756b 20 10				jr nz, .wea2	  
756d f1					pop af  
756e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7570 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7572 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7574 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7576 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7578 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
757a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
757c c9			            RET  
757d f1			.wea2:		pop af  
757e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7580 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7582 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7584 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7586 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7588 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
758a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
758c c9			            RET  
758d			  
758d			  
758d			; Write data to LCD  
758d			;   On entry: A = Data byte to be written  
758d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
758d f5			fLCD_Data:  PUSH AF  
758e f5			            PUSH AF  
758f cd a1 75		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7592 f1			            POP  AF  
7593 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7594 17			            RLA  
7595 17			            RLA  
7596 17			            RLA  
7597 cd a1 75		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
759a 3e 96		            LD   A, 150  
759c 3d			Wait:      DEC  A              ;Wait a while to allow data   
759d 20 fd		            JR   NZ, Wait      ;  write to complete  
759f f1			            POP  AF  
75a0 c9			            RET  
75a1			Wr4bitsa:     
75a1 f5					push af  
75a2 3a ce fb				ld a, (display_lcde1e2)  
75a5 fe 00				cp 0     ; e1  
75a7 20 16				jr nz, .we2	  
75a9 f1					pop af  
75aa e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
75ac cb d7		            SET  kLCDBitRS, A  
75ae d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
75b0 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
75b2 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
75b4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
75b6 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
75b8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
75ba cb 97		            RES  kLCDBitRS, A  
75bc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75be c9			            RET  
75bf f1			.we2:		pop af  
75c0 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
75c2 cb d7		            SET  kLCDBitRS, A  
75c4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
75c6 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
75c8 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
75ca d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
75cc cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
75ce d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
75d0 cb 97		            RES  kLCDBitRS, A  
75d2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75d4 c9			            RET  
75d5			  
75d5			  
75d5			; Position cursor to specified location  
75d5			;   On entry: A = Cursor position  
75d5			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
75d5 f5			fLCD_Pos:   PUSH AF  
75d6					; at this point set the E1 or E2 flag depending on position  
75d6			  
75d6 c5					push bc  
75d7			;		push af  
75d7 06 00				ld b, 0  
75d9 4f					ld c, a  
75da 3e 4f				ld a, kLCD_Line3-1  
75dc b7			 		or a      ;clear carry flag  
75dd 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
75de 38 04				jr c, .pe1  
75e0			  
75e0					; E selection  
75e0 cb 80				res 0, b         ; bit 0 unset e  
75e2			;		pop af    ; before line 3 so recover orig pos  
75e2			;		ld c, a    ; save for poking back  
75e2 18 06				jr .peset	          
75e4			.pe1:          	; E2 selection  
75e4 cb c0				set 0, b         ; bit 0 set e1  
75e6 79					ld a, c  
75e7 de 4f				sbc a, kLCD_Line3-1  
75e9 4f					ld c, a	         ; save caculated offset  
75ea			;		pop af     ; bin this original value now we have calculated form  
75ea			  
75ea			.peset:		; set bit  
75ea 78					ld a, b  
75eb 32 ce fb				ld (display_lcde1e2), a 	  
75ee 79					ld a, c  
75ef c1					pop bc  
75f0			  
75f0 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
75f2 cd 51 75		            CALL fLCD_Inst      ;Write instruction to LCD  
75f5 f1			            POP  AF  
75f6 c9			            RET  
75f7			  
75f7			  
75f7			; Output text string to LCD  
75f7			;   On entry: DE = Pointer to null terminated text string  
75f7			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
75f7 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
75f8 b7			            OR   A              ;Null terminator?  
75f9 c8			            RET  Z              ;Yes, so finished  
75fa cd 8d 75		            CALL fLCD_Data      ;Write character to display  
75fd 13			            INC  DE             ;Point to next character  
75fe 18 f7		            JR   fLCD_Str       ;Repeat  
7600 c9					ret  
7601			  
7601			; Define custom character  
7601			;   On entry: A = Character number (0 to 7)  
7601			;             DE = Pointer to character bitmap data  
7601			;   On exit:  A = Next character number  
7601			;             DE = Next location following bitmap  
7601			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7601			; Character is   
7601 c5			fLCD_Def:   PUSH BC  
7602 f5			            PUSH AF  
7603 07			            RLCA                ;Calculate location  
7604 07			            RLCA                ;  for bitmap data  
7605 07			            RLCA                ;  = 8 x CharacterNumber  
7606 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7608 cd 51 75		            CALL fLCD_Inst      ;Write instruction to LCD  
760b 06 00		            LD   B, 0  
760d 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
760e cd 8d 75		            CALL fLCD_Data      ;Write byte to display  
7611 13			            INC  DE             ;Point to next byte  
7612 04			            INC  B              ;Count bytes  
7613 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7615 28 f6		            JR   Z, Loop       ;No, so repeat  
7617 f1			            POP  AF  
7618 3c			            INC  A              ;Increment character number  
7619 c1			            POP  BC  
761a c9			            RET  
761b			  
761b			  
761b			; **********************************************************************  
761b			; **  Private functions  
761b			; **********************************************************************  
761b			  
761b			; Write function to LCD  
761b			;   On entry: A = Function byte to be written  
761b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
761b 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
761d 18 02		            JR   WrFunc  
761f 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7621 f5			WrFunc:     PUSH AF  
7622 f5					push af  
7623 3a ce fb				ld a, (display_lcde1e2)  
7626 fe 00				cp 0     ; e1  
7628 20 0f				jr nz, .wfea2	  
762a f1					pop af  
762b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
762d cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
762f cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7631 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7633 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7635 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7637 18 0d			jr .wfskip  
7639 f1			.wfea2:		pop af  
763a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
763c cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
763e cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7640 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7642 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7644 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7646 3e 05		.wfskip:            LD  A, 5  
7648 cd 4f 76		            CALL LCDDelay       ;Delay 5 ms to complete  
764b f1			            POP  AF  
764c c9			            RET  
764d			  
764d			  
764d			; Delay in milliseconds  
764d			;   On entry: A = Number of milliseconds delay  
764d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
764d 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
764f d5			LCDDelay:   PUSH DE  
7650 5f			            LD   E, A           ;Delay by 'A' ms  
7651 16 00		            LD   D, 0  
7653 cd 7a 0c		            CALL aDelayInMS  
7656 d1			            POP  DE  
7657 c9			            RET  
7658			  
7658			  
7658			testlcd:  
7658 3e 00			ld a, kLCD_Line1  
765a cd d5 75			call fLCD_Pos  
765d 06 28			ld b, 40  
765f 11 8d 76			ld de, .ttext1  
7662 cd 20 75			call write_len_string  
7665			  
7665 3e 28			ld a, kLCD_Line2  
7667 cd d5 75			call fLCD_Pos  
766a 06 28			ld b, 40  
766c 11 b6 76			ld de, .ttext2  
766f cd 20 75			call write_len_string  
7672 3e 50			ld a, kLCD_Line3  
7674 cd d5 75			call fLCD_Pos  
7677 06 28			ld b, 40  
7679 11 df 76			ld de, .ttext3  
767c cd 20 75			call write_len_string  
767f 3e 78			ld a, kLCD_Line4  
7681 cd d5 75			call fLCD_Pos  
7684 06 28			ld b, 40  
7686 11 08 77			ld de, .ttext4  
7689 cd 20 75			call write_len_string  
768c			  
768c 76				halt  
768d			  
768d			  
768d .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
76b6 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
76df .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7708 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7731			   
7731			  
7731			  
7731			; eof  
7731			  
# End of file firmware_lcd_4x40.asm
7731			;include "firmware_lcd_4x20.asm" 
7731			include "firmware_key_5x10.asm" 
7731			; 5 x 10 decade counter scanner  
7731			  
7731			  
7731			; TODO do cursor shape change for shift keys  
7731			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7731			  
7731			  
7731			; bit mask for each scan column and row for teing the matrix  
7731			  
7731			  
7731			key_init:  
7731			  
7731			; SCMonAPI functions used  
7731			  
7731			; Alphanumeric LCD functions used  
7731			; no need to specify specific functions for this module  
7731			  
7731			  
7731 3e cf		            LD   A, 11001111b  
7733 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7735			;            LD   A, 00000000b  
7735 3e 1f		            LD   A, 00011111b  
7737 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7739			  
7739			  
7739				; TODO Configure cursor shapes  
7739			  
7739				; Load cursor shapes   
7739 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
773b 11 4b 77		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
773e 06 02		            LD   B, 2           ;Number of characters to define  
7740 cd 01 76		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7743 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7745			  
7745 3e 01				ld a, 1  
7747 32 c7 fb			ld (cursor_shape),a  
774a c9				ret  
774b			  
774b			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
774b			; Up to 8 custom characters can be defined  
774b			.cursor_shapes:      
774b			;; Character 0x00 = Normal  
774b 1f			            DB  11111b  
774c 1f			            DB  11111b  
774d 1f			            DB  11111b  
774e 1f			            DB  11111b  
774f 1f			            DB  11111b  
7750 1f			            DB  11111b  
7751 1f			            DB  11111b  
7752 1f			            DB  11111b  
7753			;; Character 0x01 = Modifier  
7753 1f			            DB  11111b  
7754 1b			            DB  11011b  
7755 1b			            DB  11011b  
7756 1b			            DB  11011b  
7757 1b			            DB  11011b  
7758 1f			            DB  11111b  
7759 1b			            DB  11011b  
775a 1f			            DB  11111b  
775b			  
775b			  
775b			  
775b			  
775b			; Display custom character 0  
775b			;            LD   A, kLCD_Line1+14  
775b			;            CALL fLCD_Pos       ;Position cursor to location in A  
775b			;            LD   A, 0  
775b			;            CALL fLCD_Data      ;Write character in A at cursor  
775b			  
775b			; Display custom character 1  
775b			;            LD   A, kLCD_Line2+14  
775b			;            CALL fLCD_Pos      ;Position cursor to location in A  
775b			;            LD   A, 1  
775b			;            CALL fLCD_Data     ;Write character in A at cursor  
775b			  
775b			; keyboard scanning   
775b			  
775b			; character in from keyboard  
775b			  
775b			; mapping for the pcb layout  
775b			  
775b			.matrix_to_char:  
775b .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7766 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7771 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
777c 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7787 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7792			.matrix_to_shift:  
7792			  
7792 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
779d .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
77a8 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
77b3 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
77be .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
77c9			  
77c9			.matrix_to_symbolshift:  
77c9			  
77c9 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
77d4 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
77df 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
77ea			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
77ea 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
77f5 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7800			  
7800			  
7800			  
7800			; mapping for a simple straight through breadboard layout  
7800			  
7800			;.matrix_to_char:  
7800			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7800			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7800			;		db "asdfghjkl",KEY_CR,0  
7800			;		db "qwertyuiop",0  
7800			;		 db "1234567890",0  
7800			;.matrix_to_shift:  
7800			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7800			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7800			;		db "ASDFGHJKL",KEY_CR,0  
7800			;		db "QWERTYUIOP",0  
7800			;		 db "!",'"',"#$%^&*()",0  
7800			;.matrix_to_symbolshift:  
7800			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7800			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7800			;		db "_?*fghjk=",KEY_CR,0  
7800			;		db "-/+*[]{}@#",0  
7800			;		 db "1234567890",0  
7800			  
7800			;.matrix_to_char: db "D#0*C987B654A321"  
7800			  
7800			  
7800				  
7800			  
7800			; add cin and cin_wait  
7800			  
7800 cd 11 78		cin_wait: 	call cin  
7803						if DEBUG_KEYCINWAIT  
7803							push af  
7803							  
7803							ld hl,key_repeat_ct  
7803							ld (hl),a  
7803							inc hl  
7803							call hexout  
7803							ld hl,key_repeat_ct+3  
7803							ld a,0  
7803							ld (hl),a  
7803			  
7803							    LD   A, kLCD_Line1+11  
7803							    CALL fLCD_Pos       ;Position cursor to location in A  
7803							    LD   DE, key_repeat_ct  
7803							    ;LD   DE, MsgHello  
7803							    CALL fLCD_Str       ;Display string pointed to by DE  
7803			  
7803			  
7803			  
7803							pop af  
7803						endif  
7803 fe 00			cp 0  
7805 28 f9			jr z, cin_wait   ; block until key press  
7807			  
7807							if DEBUG_KEYCINWAIT  
7807								push af  
7807			  
7807								ld a, 'A'	  
7807								ld hl,key_repeat_ct  
7807								ld (hl),a  
7807								inc hl  
7807								ld a,0  
7807								ld (hl),a  
7807			  
7807								    LD   A, kLCD_Line2+11  
7807								    CALL fLCD_Pos       ;Position cursor to location in A  
7807								    LD   DE, key_repeat_ct  
7807								    ;LD   DE, MsgHello  
7807								    CALL fLCD_Str       ;Display string pointed to by DE  
7807			  
7807							call delay500ms  
7807			  
7807								pop af  
7807							endif  
7807 f5				push af   ; save key pressed  
7808			  
7808			.cin_wait1:	  
7808							if DEBUG_KEYCINWAIT  
7808								push af  
7808			  
7808								ld a, 'b'	  
7808								ld hl,key_repeat_ct  
7808								ld (hl),a  
7808								inc hl  
7808								ld a,0  
7808								ld (hl),a  
7808			  
7808								    LD   A, kLCD_Line2+11  
7808								    CALL fLCD_Pos       ;Position cursor to location in A  
7808								    LD   DE, key_repeat_ct  
7808								    ;LD   DE, MsgHello  
7808								    CALL fLCD_Str       ;Display string pointed to by DE  
7808			  
7808			  
7808							call delay500ms  
7808			  
7808								pop af  
7808							endif  
7808			  
7808 cd 11 78		call cin  
780b fe 00			cp 0  
780d 20 f9			jr nz, .cin_wait1  	; wait for key release  
780f			if DEBUG_KEYCINWAIT  
780f				push af  
780f			  
780f				ld a, '3'	  
780f				ld hl,key_repeat_ct  
780f				ld (hl),a  
780f				inc hl  
780f				ld a,0  
780f				ld (hl),a  
780f			  
780f			            LD   A, kLCD_Line2+11  
780f			            CALL fLCD_Pos       ;Position cursor to location in A  
780f			            LD   DE, key_repeat_ct  
780f			            ;LD   DE, MsgHello  
780f			            CALL fLCD_Str       ;Display string pointed to by DE  
780f			  
780f			  
780f			call delay500ms  
780f			  
780f				pop af  
780f			endif  
780f			  
780f f1				pop af   ; get key  
7810 c9				ret  
7811			  
7811			  
7811 cd 25 78		cin: 	call .mtoc  
7814			  
7814			if DEBUG_KEYCIN  
7814				push af  
7814				  
7814				ld hl,key_repeat_ct  
7814				ld (hl),a  
7814				inc hl  
7814				call hexout  
7814				ld hl,key_repeat_ct+3  
7814				ld a,0  
7814				ld (hl),a  
7814			  
7814			            LD   A, kLCD_Line3+15  
7814			            CALL fLCD_Pos       ;Position cursor to location in A  
7814			            LD   DE, key_repeat_ct  
7814			            ;LD   DE, MsgHello  
7814			            CALL fLCD_Str       ;Display string pointed to by DE  
7814			  
7814			  
7814			call delay500ms  
7814			  
7814				pop af  
7814			endif  
7814			  
7814			  
7814				; no key held  
7814 fe 00			cp 0  
7816 c8				ret z  
7817			  
7817			if DEBUG_KEYCIN  
7817				push af  
7817			  
7817				ld a, '1'	  
7817				ld hl,key_repeat_ct  
7817				ld (hl),a  
7817				inc hl  
7817				ld a,0  
7817				ld (hl),a  
7817			  
7817			            LD   A, kLCD_Line4+15  
7817			            CALL fLCD_Pos       ;Position cursor to location in A  
7817			            LD   DE, key_repeat_ct  
7817			            ;LD   DE, MsgHello  
7817			            CALL fLCD_Str       ;Display string pointed to by DE  
7817			  
7817			  
7817			call delay500ms  
7817			  
7817				pop af  
7817			endif  
7817			  
7817				; stop key bounce  
7817			  
7817 32 88 fe			ld (key_held),a		 ; save it  
781a 47				ld b, a  
781b			  
781b c5			.cina1:	push bc  
781c			if DEBUG_KEYCIN  
781c				push af  
781c			  
781c				ld hl,key_repeat_ct  
781c				inc hl  
781c				call hexout  
781c				ld hl,key_repeat_ct+3  
781c				ld a,0  
781c				ld (hl),a  
781c				ld hl,key_repeat_ct  
781c				ld a, '2'	  
781c				ld (hl),a  
781c			  
781c			            LD   A, kLCD_Line4+15  
781c			            CALL fLCD_Pos       ;Position cursor to location in A  
781c			            LD   DE, key_repeat_ct  
781c			            ;LD   DE, MsgHello  
781c			            CALL fLCD_Str       ;Display string pointed to by DE  
781c			  
781c				pop af  
781c			endif  
781c cd 25 78			call .mtoc  
781f c1				pop bc  
7820 b8				cp b  
7821 28 f8			jr z, .cina1  
7823 78				ld a,b		  
7824			if DEBUG_KEYCIN  
7824				push af  
7824			  
7824				ld hl,key_repeat_ct  
7824				inc hl  
7824				call hexout  
7824				ld hl,key_repeat_ct+3  
7824				ld a,0  
7824				ld (hl),a  
7824				ld hl,key_repeat_ct  
7824				ld a, '3'	  
7824				ld (hl),a  
7824			  
7824			            LD   A, kLCD_Line4+15  
7824			            CALL fLCD_Pos       ;Position cursor to location in A  
7824			            LD   DE, key_repeat_ct  
7824			            ;LD   DE, MsgHello  
7824			            CALL fLCD_Str       ;Display string pointed to by DE  
7824			  
7824				pop af  
7824			endif  
7824 c9				ret  
7825			  
7825			; detect keyboard modifier key press and apply new overlay to the face key held  
7825			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7825			  
7825			;.cin_map_modifier:   
7825			;	ld a, (hl)  
7825			;	and 255  
7825			;	ret NZ		; modifier key not flagged  
7825			;  
7825			;	; get key face  
7825			;  
7825			;	ld b,(key_face_held)  
7825			;  
7825			;	ld b, key_cols * key_rows  
7825			;  
7825			;	push de  
7825			;	pop hl  
7825			;  
7825			;.mmod1: ld a,(hl)   ; get map test  
7825			;	cp b  
7825			;	jr z, .mmod2  
7825			;  
7825			;  
7825			;  
7825			;.mmod2: inc hl    ;   
7825			;  
7825			;	  
7825			;  
7825			;	  
7825			;  
7825			;	ld hl,key_actual_pressed  
7825			;	ld (hl),a,  
7825			;	ret  
7825			  
7825			; map matrix key held to char on face of key  
7825			  
7825			.mtoc:  
7825			  
7825			; test decade counter strobes  
7825			  
7825			;.decadetest1:  
7825			  
7825			; reset counter  
7825			;ld a, 128  
7825			;out (portbdata),a  
7825			  
7825			  
7825			;ld b, 5  
7825			;.dec1:  
7825			;ld a, 0  
7825			;out (portbdata),a  
7825			;call delay1s  
7825			  
7825			;ld a, 32  
7825			;out (portbdata),a  
7825			;call delay1s  
7825			;call delay1s  
7825			;call delay1s  
7825			;  
7825			;ld a, 64+32  
7825			;out (portbdata),a  
7825			;call delay1s  
7825			;;djnz .dec1  
7825			;  
7825			;jp .decadetest1  
7825			  
7825			  
7825			  
7825			  
7825			  
7825			  
7825			  
7825			  
7825			  
7825			  
7825				; scan keyboard matrix and generate raw scan map  
7825 cd b8 78			call matrix  
7828			  
7828				; reuse c bit 0 left modifer button - ie shift  
7828			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7828				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7828			  
7828 0e 00			ld c, 0  
782a			  
782a				; TODO set flags for modifer key presses   
782a				; TODO do a search for modifer key...  
782a			  
782a				;ld hl,keyscan_table_row4  
782a 21 e7 fe			ld hl,keyscan_table_row2  
782d			  
782d 7e				ld a, (hl)  
782e fe 23			cp '#'  
7830 20 07			jr nz, .nextmodcheck  
7832 cb c1			set 0, c  
7834 21 92 77			ld hl, .matrix_to_shift  
7837 18 21			jr .dokeymap  
7839				; TODO for now igonre  
7839			.nextmodcheck:  
7839 21 dc fe			ld hl,keyscan_table_row3  
783c			  
783c 7e				ld a, (hl)  
783d fe 23			cp '#'  
783f 20 07			jr nz, .nextmodcheck2  
7841 cb c9			set 1, c   
7843 21 c9 77			ld hl, .matrix_to_symbolshift  
7846 18 12			jr .dokeymap  
7848			.nextmodcheck2:  
7848 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
784b			  
784b 7e				ld a, (hl)  
784c fe 23			cp '#'  
784e 20 07			jr nz, .donemodcheck  
7850 cb c9			set 1, c   
7852 21 92 77			ld hl, .matrix_to_shift  
7855 18 03			jr .dokeymap  
7857			  
7857				; no modifer found so just map to normal keys  
7857				; get mtoc map matrix to respective keys  
7857			;	ld hl, .matrix_to_char  
7857			;	ld hl, .matrix_to_char  
7857			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7857			;	ld a, KEY_SHIFT  
7857			;	call findchar  
7857			;  
7857			;	; got offset to key modifer in b  
7857			;  
7857			;	ld hl,keyscan_table_row5  
7857			;  
7857			;	ld a,b  
7857			;	call addatohl  
7857			;	ld a,(hl)  
7857			;  
7857			;	cp '#'  
7857			;	jr nz, .nextmodcheck  
7857			;	set 0, c  
7857			;	ld hl, .matrix_to_char  
7857			;	jr .dokeymap  
7857			;	; TODO for now igonre  
7857			;.nextmodcheck:  
7857			;	ld hl, .matrix_to_symbolshift  
7857			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7857			;	ld a, KEY_SYMBOLSHIFT  
7857			;	call findchar  
7857			;  
7857			;  
7857			;	; got offset to key modifer in b  
7857			;  
7857			;	ld hl,keyscan_table_row5  
7857			;  
7857			;	ld a,b  
7857			;	call addatohl  
7857			;	ld a,(hl)  
7857			;  
7857			;	cp '#'  
7857			;	jr nz, .donemodcheck  
7857			;	set 1, c   
7857			;	ld hl, .matrix_to_symbolshift  
7857			;	jr .dokeymap  
7857			  
7857			  
7857			  
7857			.donemodcheck:  
7857				; no modifer found so just map to normal keys  
7857				; get mtoc map matrix to respective keys  
7857 21 5b 77			ld hl, .matrix_to_char  
785a			  
785a			.dokeymap:  
785a				;ld (key_fa), c   
785a cd 73 78			call .mapkeys  
785d			  
785d			  
785d			if DEBUG_KEY  
785d			  
785d			; Display text on first line  
785d			            LD   A, kLCD_Line1  
785d			            CALL fLCD_Pos       ;Position cursor to location in A  
785d			            LD   DE, keyscan_table_row1  
785d			            ;LD   DE, MsgHello  
785d			            CALL fLCD_Str       ;Display string pointed to by DE  
785d			  
785d			; Display text on second line  
785d			            LD   A, kLCD_Line2  
785d			            CALL fLCD_Pos       ;Position cursor to location in A  
785d			            LD   DE, keyscan_table_row2  
785d			            CALL fLCD_Str       ;Display string pointed to by DE  
785d			            LD   A, kLCD_Line3  
785d			            CALL fLCD_Pos       ;Position cursor to location in A  
785d			            LD   DE, keyscan_table_row3  
785d			            CALL fLCD_Str       ;Display string pointed to by DE  
785d			            LD   A, kLCD_Line4  
785d			            CALL fLCD_Pos       ;Position cursor to location in A  
785d			            LD   DE, keyscan_table_row4  
785d			            CALL fLCD_Str       ;Display string pointed to by DE  
785d			            LD   A, kLCD_Line1+10  
785d			            CALL fLCD_Pos       ;Position cursor to location in A  
785d			            LD   DE, keyscan_table_row5  
785d			            CALL fLCD_Str       ;Display string pointed to by DE  
785d			  
785d				;call delay250ms  
785d			endif  
785d			;	jp testkey  
785d			  
785d			; get first char reported  
785d			  
785d 21 c6 fe			ld hl,keyscan_table_row5  
7860			  
7860				;ld b, 46   ; 30 keys to remap + 8 nulls   
7860 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7862			.findkey:  
7862 7e				ld a,(hl)  
7863 fe 00			cp 0  
7865 28 04			jr z, .nextkey  
7867 fe 7e			cp KEY_MATRIX_NO_PRESS  
7869 20 06			jr nz, .foundkey  
786b			.nextkey:  
786b 23				inc hl  
786c 10 f4			djnz .findkey  
786e 3e 00			ld a,0  
7870 c9				ret  
7871			.foundkey:  
7871 7e				ld a,(hl)  
7872 c9				ret  
7873				  
7873			  
7873			; convert the raw key map given hl for destination key  
7873			.mapkeys:  
7873 11 c6 fe			ld de,keyscan_table_row5  
7876			  
7876 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7878			.remap:  
7878 1a				ld a,(de)  
7879 fe 23			cp '#'  
787b 20 02			jr nz, .remapnext  
787d				;CALLMONITOR  
787d 7e				ld a,(hl)  
787e 12				ld (de),a  
787f			  
787f			  
787f			  
787f			.remapnext:  
787f 23				inc hl  
7880 13				inc de  
7881 10 f5			djnz .remap  
7883				  
7883 c9				ret  
7884			  
7884			  
7884			  
7884			.mtocold2:  
7884			  
7884			;	; flag if key D is held down and remove from reporting  
7884			;	ld bc, .key_map_fd    
7884			;	ld hl, keyscan_table  
7884			;	ld de, key_fd  
7884			;	call .key_shift_hold  
7884			;	cp 255  
7884			;	jr z, .cinmap  
7884			;	; flag if key C is held down and remove from reporting  
7884			;	ld bc, .key_map_fc    
7884			;	ld hl, keyscan_table+key_cols  
7884			;	ld de, key_fc  
7884			;	call .key_shift_hold  
7884			;	cp 255  
7884			;	jr z, .cinmap  
7884			;	; flag if key B is held down and remove from reporting  
7884			;	ld bc, .key_map_fb    
7884			;	ld hl, keyscan_table+(key_cols*2)  
7884			;	ld de, key_fb  
7884			;	call .key_shift_hold  
7884			;	cp 255  
7884			;	jr z, .cinmap  
7884			;	; flag if key A is held down and remove from reporting  
7884			;	ld bc, .key_map_fa    
7884			;	ld hl, keyscan_table+(key_cols*3)  
7884			;	ld de, key_fa  
7884			;	call .key_shift_hold  
7884			;	cp 255  
7884			;	jr z, .cinmap  
7884			  
7884 11 5b 77			ld de, .matrix_to_char  
7887			  
7887			  
7887			.cinmap1:   
7887				if DEBUG_KEY  
7887			            LD   A, kLCD_Line4  
7887			            CALL fLCD_Pos       ;Position cursor to location in A  
7887					push de  
7887			            LD   DE, keyscan_table  
7887			            CALL fLCD_Str       ;Display string pointed to by DE  
7887					pop de  
7887				endif  
7887			  
7887				; scan key matrix table for any held key  
7887			  
7887				; de holds either the default matrix or one selected above  
7887			  
7887 21 93 fe			ld hl, keyscan_table  
788a 06 32			ld b,key_cols*key_rows  
788c			  
788c 7e			.cin11:	ld a,(hl)  
788d fe 23			cp '#'  
788f 28 08			jr z, .cinhit1  
7891 23				inc hl  
7892 13				inc de  
7893 05				dec b  
7894 20 f6			jr nz, .cin11  
7896				; no key found held  
7896 3e 00			ld a,0  
7898 c9				ret  
7899 d5			.cinhit1: push de  
789a e1				pop hl  
789b 7e				ld a,(hl)  
789c c9				ret  
789d			  
789d			; flag a control key is held   
789d			; hl is key pin, de is flag indicator  
789d			  
789d			.key_shift_hold1:  
789d c5				push bc  
789e 3e 01			ld a, 1  
78a0 32 c7 fb			ld (cursor_shape),a  
78a3 06 00			ld b, 0  
78a5 7e				ld a, (hl)  
78a6 fe 2e			cp '.'  
78a8 28 0a			jr z, .key_shift11  
78aa 06 ff			ld b, 255  
78ac 3e 2b			ld a, '+'    ; hide key from later scans  
78ae 77				ld (hl),a  
78af 3e 02			ld a, 2  
78b1 32 c7 fb			ld (cursor_shape),a  
78b4			.key_shift11:  
78b4				; write flag indicator  
78b4 78				ld a,b  
78b5 12				ld (de),a  
78b6			  
78b6 d1				pop de    ; de now holds the key map ptr  
78b7 c9				ret  
78b8			  
78b8				  
78b8			  
78b8			; scans keyboard matrix and flags key press in memory array	  
78b8				  
78b8			matrix:  
78b8				;call matrix  
78b8				; TODO optimise the code....  
78b8			  
78b8			  
78b8			;ld hl, keyscan_table_row1  
78b8			;ld de, keyscan_table_row1+1  
78b8			;ld bc,46  
78b8			;ld a,KEY_MATRIX_NO_PRESS  
78b8			;ldir  
78b8			  
78b8			  
78b8			  
78b8			; reset counter  
78b8 3e 80		ld a, 128  
78ba d3 c1		out (portbdata),a  
78bc			  
78bc 06 0a		ld b, 10  
78be 0e 00		ld c, 0       ; current clock toggle  
78c0			  
78c0			.colscan:  
78c0			  
78c0			; set current column  
78c0			; disable clock enable and set clock low  
78c0			  
78c0			;ld a, 0  
78c0			;out (portbdata),a  
78c0			  
78c0			; For each column scan for switches  
78c0			  
78c0 c5			push bc  
78c1 21 89 fe		ld hl, keyscan_scancol  
78c4 cd cd 79		call .rowscan  
78c7 c1			pop bc  
78c8			  
78c8			  
78c8			; get back current column  
78c8			  
78c8			; translate the row scan  
78c8			  
78c8			;   
78c8			; row 1  
78c8			  
78c8 78			ld a,b  
78c9			  
78c9 21 fc fe		LD   hl, keyscan_table_row1+10  
78cc			  
78cc cd 5e 0f		call subafromhl  
78cf			;call addatohl  
78cf			  
78cf 11 89 fe		ld de, keyscan_scancol  
78d2			  
78d2 1a			ld a,(de)  
78d3 77			ld (hl),a  
78d4			  
78d4			  
78d4			  
78d4			  
78d4			; row 2  
78d4			  
78d4 78			ld a,b  
78d5			  
78d5 21 f1 fe		LD   hl, keyscan_table_row2+10  
78d8			  
78d8			;call addatohl  
78d8 cd 5e 0f		call subafromhl  
78db			  
78db			  
78db 11 8a fe		ld de, keyscan_scancol+1  
78de			  
78de 1a			ld a,(de)  
78df 77			ld (hl),a  
78e0			  
78e0			  
78e0			; row 3  
78e0			  
78e0 78			ld a,b  
78e1			  
78e1 21 e6 fe		LD   hl, keyscan_table_row3+10  
78e4			  
78e4			;call addatohl  
78e4 cd 5e 0f		call subafromhl  
78e7			  
78e7 11 8b fe		ld de, keyscan_scancol+2  
78ea			  
78ea 1a			ld a,(de)  
78eb 77			ld (hl),a  
78ec			  
78ec			  
78ec			  
78ec			; row 4  
78ec			  
78ec 78			ld a,b  
78ed			  
78ed 21 db fe		LD   hl, keyscan_table_row4+10  
78f0			  
78f0			;call addatohl  
78f0 cd 5e 0f		call subafromhl  
78f3			  
78f3 11 8c fe		ld de, keyscan_scancol+3  
78f6			  
78f6 1a			ld a,(de)  
78f7 77			ld (hl),a  
78f8			  
78f8			; row 5  
78f8			  
78f8 78			ld a,b  
78f9			  
78f9 21 d0 fe		LD   hl, keyscan_table_row5+10  
78fc			  
78fc			;call addatohl  
78fc cd 5e 0f		call subafromhl  
78ff			  
78ff 11 8d fe		ld de, keyscan_scancol+4  
7902			  
7902 1a			ld a,(de)  
7903 77			ld (hl),a  
7904			  
7904			; handshake next column  
7904			  
7904			  
7904 3e 40		ld a, 64  
7906 d3 c1		out (portbdata),a  
7908			  
7908 3e 00		ld a, 0  
790a d3 c1		out (portbdata),a  
790c			  
790c			; toggle clk and move to next column  
790c			;ld a, 64  
790c			;cp c  
790c			;  
790c			;jr z, .coltoglow  
790c			;ld c, a  
790c			;jr .coltog  
790c			;.coltoglow:  
790c			;ld c, 0  
790c			;.coltog:  
790c			;ld a, c  
790c			;out (portbdata),a  
790c			  
790c 10 b2		djnz .colscan  
790e			  
790e 3e 0a		ld a,10  
7910 21 f2 fe		LD   hl, keyscan_table_row1  
7913 cd 4c 0f		call addatohl  
7916 3e 00		ld a, 0  
7918 77			ld (hl), a  
7919			  
7919			  
7919 3e 0a		ld a,10  
791b 21 e7 fe		LD   hl, keyscan_table_row2  
791e cd 4c 0f		call addatohl  
7921 3e 00		ld a, 0  
7923 77			ld (hl), a  
7924			  
7924 3e 0a		ld a,10  
7926 21 dc fe		LD   hl, keyscan_table_row3  
7929 cd 4c 0f		call addatohl  
792c 3e 00		ld a, 0  
792e 77			ld (hl), a  
792f			  
792f 3e 0a		ld a,10  
7931 21 d1 fe		LD   hl, keyscan_table_row4  
7934 cd 4c 0f		call addatohl  
7937 3e 00		ld a, 0  
7939 77			ld (hl), a  
793a			  
793a 3e 0a		ld a,10  
793c 21 c6 fe		LD   hl, keyscan_table_row5  
793f cd 4c 0f		call addatohl  
7942 3e 00		ld a, 0  
7944 77			ld (hl), a  
7945			  
7945			if DEBUG_KEY_MATRIX  
7945			  
7945			; Display text on first line  
7945			            LD   A, kLCD_Line1  
7945			            CALL fLCD_Pos       ;Position cursor to location in A  
7945			            LD   DE, keyscan_table_row1  
7945			            ;LD   DE, MsgHello  
7945			            CALL fLCD_Str       ;Display string pointed to by DE  
7945			  
7945			; Display text on second line  
7945			            LD   A, kLCD_Line2  
7945			            CALL fLCD_Pos       ;Position cursor to location in A  
7945			            LD   DE, keyscan_table_row2  
7945			            CALL fLCD_Str       ;Display string pointed to by DE  
7945			            LD   A, kLCD_Line3  
7945			            CALL fLCD_Pos       ;Position cursor to location in A  
7945			            LD   DE, keyscan_table_row3  
7945			            CALL fLCD_Str       ;Display string pointed to by DE  
7945			            LD   A, kLCD_Line4  
7945			            CALL fLCD_Pos       ;Position cursor to location in A  
7945			            LD   DE, keyscan_table_row4  
7945			            CALL fLCD_Str       ;Display string pointed to by DE  
7945			            LD   A, kLCD_Line4+10  
7945			            CALL fLCD_Pos       ;Position cursor to location in A  
7945			            LD   DE, keyscan_table_row5  
7945			            CALL fLCD_Str       ;Display string pointed to by DE  
7945			  
7945			;call delay250ms  
7945				jp matrix  
7945			endif  
7945 c9			ret  
7946			  
7946			; using decade counter....  
7946			  
7946			  
7946			; TODO reset decade counter to start of scan  
7946			  
7946			; reset 15  
7946			; clock 14  
7946			; ce 13  
7946			  
7946			; 1 - q5  
7946			; 2 - q1  
7946			; 3 - q0  
7946			; 4 - q2  
7946			; 5 - q6  
7946			; 6 - q7  
7946			; 7 - q3  
7946			; 8 - vss  
7946			; 9 - q8  
7946			; 10 - q4  
7946			; 11 - q9  
7946			; 12 - cout  
7946			; 16 - vdd  
7946			  
7946			; clock      ce       reset     output  
7946			; 0          x        0         n  
7946			; x          1        0         n  
7946			; x          x        1         q0  
7946			; rising     0        0         n+1  
7946			; falling    x        0         n  
7946			; x          rising   0         n  
7946			; 1          falling  0         x+1  
7946			;  
7946			; x = dont care, if n < 5 carry = 1 otherwise 0  
7946			  
7946			;   
7946			; reset   
7946			; 13=0, 14=0, 15=1 .. 15=0  
7946			;  
7946			; handshake line  
7946			; 14=1.... read line 14=0  
7946			  
7946			  
7946			  
7946			  
7946			  
7946			; TODO hand shake clock for next column scan  
7946			; TODO detect each row  
7946			  
7946			  
7946			  
7946			  
7946			; reset 128  
7946			; clock 64  
7946			; ce 32  
7946			  
7946			  
7946			.cyclestart:  
7946			  
7946			; reset counter  
7946 3e 80		ld a, 128  
7948 d3 c1		out (portbdata),a  
794a			  
794a			; loop leds  
794a 06 0a		ld b,10  
794c			  
794c			.cycle1:  
794c c5			push bc  
794d 3e 00		ld a, 0  
794f d3 c1		out (portbdata),a  
7951 cd 89 0c		call delay250ms  
7954			  
7954 3e 40		ld a, 64  
7956 d3 c1		out (portbdata),a  
7958 cd 89 0c		call delay250ms  
795b			  
795b 3e 00		ld a, 0  
795d d3 c1		out (portbdata),a  
795f cd 89 0c		call delay250ms  
7962			  
7962 c1			pop bc  
7963 10 e7		djnz .cycle1  
7965			  
7965			  
7965 18 df		jr .cyclestart  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			; map matrix key held to char on face of key  
7967			  
7967			;.mtocold:  
7967			;  
7967			;  
7967			;; reset counter  
7967			;ld a, 128  
7967			;out (portbdata),a  
7967			;  
7967			;  
7967			;; scan keyboard row 1  
7967			;ld a, 0  
7967			;out (portbdata),a  
7967			;;ld a, 64  
7967			;;out (portbdata),a  
7967			;  
7967			;  
7967			;	ld a, 128  
7967			;	ld hl, keyscan_table  
7967			;	call .rowscan  
7967			;  
7967			;;ld a, 0  
7967			;;out (portbdata),a  
7967			;ld a, 64  
7967			;out (portbdata),a  
7967			;  
7967			;	ld a, 64  
7967			;	ld hl, keyscan_table+key_cols  
7967			;	call .rowscan  
7967			;  
7967			;ld a, 0  
7967			;out (portbdata),a  
7967			;;ld a, 64  
7967			;;out (portbdata),a  
7967			;	ld a, 32  
7967			;	ld hl, keyscan_table+(key_cols*2)  
7967			;	call .rowscan  
7967			;  
7967			;  
7967			;;ld a, 0  
7967			;;out (portbdata),a  
7967			;ld a, 64  
7967			;out (portbdata),a  
7967			;  
7967			;	ld a, 16  
7967			;	ld hl, keyscan_table+(key_cols*3)  
7967			;	call .rowscan  
7967			;  
7967			;  
7967			;	; flag if key D is held down and remove from reporting  
7967			;	ld bc, .key_map_fd    
7967			;	ld hl, keyscan_table  
7967			;	ld de, key_fd  
7967			;	call .key_shift_hold  
7967			;	cp 255  
7967			;	jr z, .cinmap  
7967			;	; flag if key C is held down and remove from reporting  
7967			;	ld bc, .key_map_fc    
7967			;	ld hl, keyscan_table+key_cols  
7967			;	ld de, key_fc  
7967			;	call .key_shift_hold  
7967			;	cp 255  
7967			;	jr z, .cinmap  
7967			;	; flag if key B is held down and remove from reporting  
7967			;	ld bc, .key_map_fb    
7967			;	ld hl, keyscan_table+(key_cols*2)  
7967			;	ld de, key_fb  
7967			;	call .key_shift_hold  
7967			;	cp 255  
7967			;	jr z, .cinmap  
7967			;	; flag if key A is held down and remove from reporting  
7967			;	ld bc, .key_map_fa    
7967			;	ld hl, keyscan_table+(key_cols*3)  
7967			;	ld de, key_fa  
7967			;	call .key_shift_hold  
7967			;	cp 255  
7967			;	jr z, .cinmap  
7967			;  
7967			;	ld de, .matrix_to_char  
7967			;  
7967			;  
7967			;.cinmap:   
7967			;	if DEBUG_KEY  
7967			;            LD   A, kLCD_Line4  
7967			;            CALL fLCD_Pos       ;Position cursor to location in A  
7967			;		push de  
7967			;            LD   DE, keyscan_table  
7967			;            CALL fLCD_Str       ;Display string pointed to by DE  
7967			;		pop de  
7967			;	endif  
7967			  
7967				; scan key matrix table for any held key  
7967			  
7967				; de holds either the default matrix or one selected above  
7967			  
7967			;	ld hl, keyscan_table  
7967			;	ld b,key_cols*key_rows  
7967			;  
7967			;.cin1:	ld a,(hl)  
7967			;	cp '#'  
7967			;	jr z, .cinhit  
7967			;	inc hl  
7967			;	inc de  
7967			;	dec b  
7967			;	jr nz, .cin1  
7967			;	; no key found held  
7967			;	ld a,0  
7967			;	ret  
7967			;.cinhit: push de  
7967			;	pop hl  
7967			;	ld a,(hl)  
7967			;	ret  
7967			  
7967			; flag a control key is held   
7967			; hl is key pin, de is flag indicator  
7967			  
7967			;.key_shift_hold:  
7967			;	push bc  
7967			;	ld a, 1  
7967			;	ld (cursor_shape),a  
7967			;	ld b, 0  
7967			;	ld a, (hl)  
7967			;	cp '.'  
7967			;	jr z, .key_shift1  
7967			;	ld b, 255  
7967			;	ld a, '+'    ; hide key from later scans  
7967			;	ld (hl),a  
7967			;	ld a, 2  
7967			;	ld (cursor_shape),a  
7967			;.key_shift1:  
7967			;	; write flag indicator  
7967			;	ld a,b  
7967			;	ld (de),a  
7967			;  
7967			;	pop de    ; de now holds the key map ptr  
7967			;	ret  
7967			  
7967				  
7967				  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			  
7967			;	push hl  
7967			;	push de  
7967			;	push bc  
7967			;	call keyscan  
7967			;	; map key matrix to ascii value of key face  
7967			;  
7967			;	ld hl, key_face_map  
7967			;	ld de, keyscan_table  
7967			;  
7967			;	; get how many keys to look at  
7967			;	ld b, keyscan_table_len  
7967			;	  
7967			;  
7967			;	; at this stage fall out on first key hit  
7967			;	; TODO handle multiple key press  
7967			;  
7967			;map1:	ld a,(hl)  
7967			;	cp '#'  
7967			;	jr z, keyhit  
7967			;	inc hl  
7967			;	inc de  
7967			;	dec b  
7967			;	jr nz, map1  
7967			;nohit:	ld a, 0  
7967			;	jr keydone  
7967			;keyhit: push de  
7967			;	pop hl  
7967			;	ld a,(hl)  
7967			;keydone:  
7967			;	push bc  
7967			;	push de  
7967			; 	push hl  
7967			;	ret   
7967			;  
7967			  
7967			  
7967			  
7967			  
7967			; scan physical key matrix  
7967			  
7967			  
7967			;keyscan:  
7967			;  
7967			;; for each key_row use keyscanr bit mask for out  
7967			;; then read in for keyscanc bitmask  
7967			;; save result of row scan to keyscantable  
7967			;  
7967			;; scan keyboard row 1  
7967			;  
7967			;	ld b, key_rows  
7967			;	ld hl, key_scanr  
7967			;	ld de, keyscan_table  
7967			;  
7967			;rowloop:  
7967			;  
7967			;	ld a,(hl)		; out bit mask to energise keyboard row  
7967			;	call rowscan  
7967			;	inc hl  
7967			;	dec b  
7967			;	jr nz, rowloop  
7967			;  
7967			;	ret  
7967			;  
7967			;  
7967			;; pass a out bitmask, b row number  
7967			;arowscan:   
7967			;	push bc  
7967			;  
7967			;	ld d, b  
7967			;  
7967			;	; calculate buffer location for this row  
7967			;  
7967			;	ld hl, keyscan_table	  
7967			;kbufr:  ld e, key_cols  
7967			;kbufc:	inc hl  
7967			;	dec e  
7967			;	jr nz, kbufc  
7967			;	dec d  
7967			;	jr nz, kbufr  
7967			;  
7967			;	; energise row and read columns  
7967			;  
7967			;	out (portbdata),a  
7967			;	in a,(portbdata)  
7967			;	ld c,a  
7967			;  
7967			;  
7967			;	; save buffer loc  
7967			;  
7967			;	ld (keybufptr), hl  
7967			;  
7967			;	ld hl, key_scanc  
7967			;	ld d, key_cols  
7967			;  
7967			;	; for each column check each bit mask  
7967			;  
7967			;colloop:  
7967			;	  
7967			;  
7967			;	; reset flags for the row   
7967			;  
7967			;	ld b,'.'  
7967			;	and (hl)  
7967			;	jr z, maskskip  
7967			;	ld b,'#'  
7967			;maskskip:  
7967			;	; save  key state  
7967			;	push hl  
7967			;	ld hl, (keybufptr)  
7967			;	ld (hl), b  
7967			;	inc hl  
7967			;	ld (keybufptr), hl  
7967			;  
7967			;	; move to next bit mask  
7967			;	pop hl  
7967			;	inc hl  
7967			;  
7967			;	dec d  
7967			;	jr nz, colloop  
7967			;  
7967			;	ret  
7967			;  
7967			;  
7967			;;  
7967			; lcd functions  
7967			;  
7967			;  
7967			  
7967			;if DEBUG_KEY_MATRIX  
7967			  
7967			; test function to display hardware view of matrix state  
7967			  
7967			matrixold:  
7967			  
7967			  
7967			  
7967			; reset counter  
7967 3e 80		ld a, 128  
7969 d3 c1		out (portbdata),a  
796b			; scan keyboard row 1  
796b 3e 00		ld a, 0  
796d d3 c1		out (portbdata),a  
796f			;ld a, 64  
796f			;out (portbdata),a  
796f 3e 80			ld a, 128  
7971 21 f2 fe			ld hl, keyscan_table_row1  
7974 cd cd 79			call .rowscan  
7977			  
7977			;ld a, 0  
7977			;out (portbdata),a  
7977 3e 40		ld a, 64  
7979 d3 c1		out (portbdata),a  
797b 3e 40			ld a, 64  
797d 21 e7 fe			ld hl, keyscan_table_row2  
7980 cd cd 79			call .rowscan  
7983			  
7983 3e 00		ld a, 0  
7985 d3 c1		out (portbdata),a  
7987			;ld a, 64  
7987			;out (portbdata),a  
7987 3e 20			ld a, 32  
7989 21 dc fe			ld hl, keyscan_table_row3  
798c cd cd 79			call .rowscan  
798f			  
798f			;ld a, 0  
798f			;out (portbdata),a  
798f 3e 40		ld a, 64  
7991 d3 c1		out (portbdata),a  
7993 3e 10			ld a, 16  
7995 21 d1 fe			ld hl, keyscan_table_row4  
7998 cd cd 79			call .rowscan  
799b			  
799b			; Display text on first line  
799b 3e 00		            LD   A, kLCD_Line1  
799d cd d5 75		            CALL fLCD_Pos       ;Position cursor to location in A  
79a0 11 f2 fe		            LD   DE, keyscan_table_row1  
79a3			            ;LD   DE, MsgHello  
79a3 cd f7 75		            CALL fLCD_Str       ;Display string pointed to by DE  
79a6			  
79a6			; Display text on second line  
79a6 3e 28		            LD   A, kLCD_Line2  
79a8 cd d5 75		            CALL fLCD_Pos       ;Position cursor to location in A  
79ab 11 e7 fe		            LD   DE, keyscan_table_row2  
79ae cd f7 75		            CALL fLCD_Str       ;Display string pointed to by DE  
79b1 3e 50		            LD   A, kLCD_Line3  
79b3 cd d5 75		            CALL fLCD_Pos       ;Position cursor to location in A  
79b6 11 dc fe		            LD   DE, keyscan_table_row3  
79b9 cd f7 75		            CALL fLCD_Str       ;Display string pointed to by DE  
79bc 3e 78		            LD   A, kLCD_Line4  
79be cd d5 75		            CALL fLCD_Pos       ;Position cursor to location in A  
79c1 11 d1 fe		            LD   DE, keyscan_table_row4  
79c4 cd f7 75		            CALL fLCD_Str       ;Display string pointed to by DE  
79c7			  
79c7 cd 89 0c			call delay250ms  
79ca c3 b8 78			jp matrix  
79cd			  
79cd			; pass de as row display flags  
79cd			.rowscan:   
79cd			;	out (portbdata),a  
79cd db c1			in a,(portbdata)  
79cf 4f				ld c,a  
79d0				; reset flags for the row   
79d0 06 7e			ld b,KEY_MATRIX_NO_PRESS  
79d2 e6 01			and 1  
79d4 28 02			jr z, .p1on  
79d6 06 23			ld b,'#'  
79d8			.p1on:  
79d8 70				ld (hl), b  
79d9 23				inc hl  
79da			  
79da 06 7e			ld b,KEY_MATRIX_NO_PRESS  
79dc 79				ld a,c  
79dd e6 02			and 2  
79df			;	bit 0,a  
79df 28 02			jr z, .p2on  
79e1 06 23			ld b,'#'  
79e3			.p2on:  
79e3 70				ld (hl), b  
79e4 23				inc hl  
79e5			;  
79e5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
79e7 79				ld a,c  
79e8 e6 04			and 4  
79ea			;;	bit 0,a  
79ea 28 02			jr z, .p3on  
79ec 06 23			ld b,'#'  
79ee			.p3on:  
79ee 70				ld (hl), b  
79ef 23				inc hl  
79f0			;;  
79f0 06 7e			ld b,KEY_MATRIX_NO_PRESS  
79f2			;;	bit 0,a  
79f2 79				ld a,c  
79f3 e6 08			and 8  
79f5 28 02			jr z, .p4on  
79f7 06 23			ld b,'#'  
79f9			.p4on:  
79f9 70				ld (hl), b  
79fa 23				inc hl  
79fb			  
79fb 06 7e			ld b,KEY_MATRIX_NO_PRESS  
79fd			;;	bit 0,a  
79fd 79				ld a,c  
79fe e6 10			and 16  
7a00 28 02			jr z, .p5on  
7a02 06 23			ld b,'#'  
7a04			.p5on:  
7a04 70				ld (hl), b  
7a05 23				inc hl  
7a06			; zero term  
7a06 06 00			ld b,0  
7a08 70				ld (hl), b  
7a09			  
7a09 c9			.rscandone: ret  
7a0a			  
7a0a			;addatohl:  
7a0a			;  
7a0a			 ;add   a, l    ; A = A+L  
7a0a			  ;  ld    l, a    ; L = A+L  
7a0a			   ; adc   a, h    ; A = A+L+H+carry  
7a0a			   ; sub   l       ; A = H+carry  
7a0a			   ; ld    h, a    ; H = H+carry  
7a0a			  
7a0a			;ret  
7a0a			; eof  
# End of file firmware_key_5x10.asm
7a0a			;include "firmware_key_4x10.asm" 
7a0a			 
7a0a			heap_size:    equ heap_end - heap_start 
7a0a			;eof 
# End of file os_mega.asm
7a0a
