# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 48 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openext: equ store_readcont - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd ca 0c				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd ca 0c				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd ca 0c				call clear_display  
0037			  
0037			  
0037 cd b6 69				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 4d 6c			call key_init  
003d cd bb 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd a1 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd 5e 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd ed 0c			call update_display  
0049 cd 47 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd cf 0c			call fill_display  
0051 cd ed 0c			call update_display  
0054 cd 47 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd cf 0c			call fill_display  
005c cd ed 0c			call update_display  
005f cd 47 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd cf 0c			call fill_display  
0067 cd ed 0c			call update_display  
006a cd 47 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 7b 1a			ld de, prom_bootmsg  
0072 cd dd 0c			call str_at_display  
0075 cd ed 0c			call update_display  
0078			  
0078			  
0078 cd 47 0c			call delay1s  
007b cd 47 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 90 1a			ld de, prom_bootmsg1  
0083 cd dd 0c			call str_at_display  
0086 cd ed 0c			call update_display  
0089 cd 47 0c			call delay1s  
008c cd 47 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			 
00a0			; TODO store port id for spi device ie dev c 
00a0			; TODO store pin for SO 
00a0			; TODO store pin for SI 
00a0			; TODO store pin for SCLK 
00a0			 
00a0			; 
00a0			 
00a0			; ensure that spi bus is in a stable state with default pins  
00a0			 
00a0			se_stable_spi:   
00a0			 
00a0				 ; set DI high, CE high , SCLK low 
00a0				;ld a, SPI_DI | SPI_CE0 
00a0 3e 07			ld a, SPI_DI  
00a2 cd 76 01			call spi_ce_high 
00a5 d3 80			 out (storage_adata),a 
00a7 32 6b fa			ld (spi_portbyte),a 
00aa			 
00aa				if DEBUG_SPI 
00aa					push hl 
00aa					ld l, a 
00aa					DMARK "SPI" 
00aa					CALLMONITOR 
00aa					pop hl 
00aa				endif 
00aa c9				ret 
00ab			 
00ab			; byte to send in a 
00ab			 
00ab			spi_send_byte: 
00ab				; save byte to send for bit mask shift out 
00ab 4f			        ld c,a 
00ac 3a 6b fa			ld a,(spi_portbyte) 
00af				  
00af				; clock out	each bit of the byte msb first 
00af			 
00af 06 08			ld b, 8 
00b1			.ssb1: 
00b1				; clear so bit  
00b1 cb bf			res SPI_DI, a 
00b3 cb 11			rl c 
00b5				; if bit 7 is set then carry is set 
00b5 30 02			jr nc, .ssb2 
00b7 cb ff			set SPI_DI,a 
00b9			.ssb2:  ; output bit to ensure it is stable 
00b9 d3 80			out (storage_adata),a 
00bb 00				nop 
00bc				; clock bit high 
00bc cb ef			set SPI_SCLK,a 
00be d3 80			out (storage_adata),a 
00c0 00				nop 
00c1				; then low 
00c1 cb af			res SPI_SCLK,a 
00c3 d3 80			out (storage_adata),a 
00c5 00				nop 
00c6 10 e9			djnz .ssb1 
00c8			 
00c8 32 6b fa			ld (spi_portbyte),a 
00cb c9				ret 
00cc			 
00cc			; TODO low level get byte into A on spi 
00cc			 
00cc			spi_read_byte:  
00cc			 
00cc				; save byte to send for bit mask shift out 
00cc 0e 00		    ld c,0 
00ce 3a 6b fa			ld a,(spi_portbyte) 
00d1				  
00d1				; clock out	each bit of the byte msb first 
00d1			 
00d1			 
00d1				; clock bit high 
00d1 cb ef			set SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6			 
00d6			    ; read DO  
00d6			 
00d6 cb f9		    set 7,c 
00d8 db 80			in a,(storage_adata) 
00da cb 77		    bit SPI_DO,a 
00dc 20 02		    jr nz, .b7 
00de cb b9		    res 7,c 
00e0			.b7: 
00e0				; then low 
00e0 cb af			res SPI_SCLK,a 
00e2 d3 80			out (storage_adata),a 
00e4 00				nop 
00e5			     
00e5			 
00e5				; clock bit high 
00e5 cb ef			set SPI_SCLK,a 
00e7 d3 80			out (storage_adata),a 
00e9 00				nop 
00ea			 
00ea			    ; read DO  
00ea			 
00ea cb f1		    set 6,c 
00ec db 80			in a,(storage_adata) 
00ee cb 77		    bit SPI_DO,a 
00f0 20 02		    jr nz, .b6 
00f2 cb b1		    res 6,c 
00f4			.b6: 
00f4				; then low 
00f4 cb af			res SPI_SCLK,a 
00f6 d3 80			out (storage_adata),a 
00f8 00				nop 
00f9			 
00f9				; clock bit high 
00f9 cb ef			set SPI_SCLK,a 
00fb d3 80			out (storage_adata),a 
00fd 00				nop 
00fe			 
00fe			 
00fe			    ; read DO  
00fe			 
00fe cb e9		    set 5,c 
0100 db 80			in a,(storage_adata) 
0102 cb 77		    bit SPI_DO,a 
0104 20 02		    jr nz, .b5 
0106 cb a9		    res 5,c 
0108			.b5: 
0108				; then low 
0108 cb af			res SPI_SCLK,a 
010a d3 80			out (storage_adata),a 
010c 00				nop 
010d				; clock bit high 
010d cb ef			set SPI_SCLK,a 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112			 
0112			    ; read DO  
0112			 
0112 cb e1		    set 4,c 
0114 db 80			in a,(storage_adata) 
0116 cb 77		    bit SPI_DO,a 
0118 20 02		    jr nz, .b4 
011a cb a1		    res 4,c 
011c			.b4: 
011c				; then low 
011c cb af			res SPI_SCLK,a 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126			 
0126			    ; read DO  
0126			 
0126 cb d9		    set 3,c 
0128 db 80			in a,(storage_adata) 
012a cb 77		    bit SPI_DO,a 
012c 20 02		    jr nz, .b3 
012e cb 99		    res 3,c 
0130			.b3: 
0130				; then low 
0130 cb af			res SPI_SCLK,a 
0132 d3 80			out (storage_adata),a 
0134 00				nop 
0135				; clock bit high 
0135 cb ef			set SPI_SCLK,a 
0137 d3 80			out (storage_adata),a 
0139 00				nop 
013a			 
013a			    ; read DO  
013a			 
013a cb d1		    set 2,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b2 
0142 cb 91		    res 2,c 
0144			.b2: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149				; clock bit high 
0149 cb ef			set SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d 00				nop 
014e			 
014e			    ; read DO  
014e			 
014e cb c9		    set 1,c 
0150 db 80			in a,(storage_adata) 
0152 cb 77		    bit SPI_DO,a 
0154 20 02		    jr nz, .b1 
0156 cb 89		    res 1,c 
0158			.b1: 
0158				; then low 
0158 cb af			res SPI_SCLK,a 
015a d3 80			out (storage_adata),a 
015c 00				nop 
015d				; clock bit high 
015d cb ef			set SPI_SCLK,a 
015f d3 80			out (storage_adata),a 
0161 00				nop 
0162			 
0162			    ; read DO  
0162			 
0162 cb c1		    set 0,c 
0164 db 80			in a,(storage_adata) 
0166 cb 77		    bit SPI_DO,a 
0168 20 02		    jr nz, .b0 
016a cb 81		    res 0,c 
016c			.b0: 
016c				; then low 
016c cb af			res SPI_SCLK,a 
016e d3 80			out (storage_adata),a 
0170 00				nop 
0171			 
0171			 
0171 32 6b fa			ld (spi_portbyte),a 
0174			 
0174			    ; return byte 
0174 79			    ld a,c 
0175			 
0175			 
0175 c9				ret 
0176			 
0176			 
0176			 
0176			spi_ce_high: 
0176			 
0176				if DEBUG_SPI_HARD_CE0 
0176			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0176					ret 
0176			 
0176				endif 
0176			 
0176			 
0176 f5				push af 
0177			 
0177				; send direct ce to port b 
0177 3e ff			ld a, 255 
0179 d3 81			out (storage_bdata), a 
017b			 
017b f1				pop af 
017c			 
017c				; for port a that shares with spi lines AND the mask 
017c			  
017c				if DEBUG_SPI 
017c					push hl 
017c					ld h, a 
017c				endif 
017c			;	ld c, SPI_CE_HIGH 
017c			;	and c 
017c cb c7			set SPI_CE0, a 
017e cb cf			set SPI_CE1, a 
0180 cb d7			set SPI_CE2, a 
0182 cb df			set SPI_CE3, a 
0184 cb e7			set SPI_CE4, a 
0186			 
0186				if DEBUG_SPI 
0186					ld l, a 
0186					DMARK "CEh" 
0186					CALLMONITOR 
0186					pop hl 
0186				endif 
0186 c9				ret 
0187			 
0187			 
0187			spi_ce_low: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187 c5				push bc 
0188 f5				push af 
0189			 
0189				; send direct ce to port b 
0189 3a 6d fa			ld a, (spi_cartdev) 
018c d3 81			out (storage_bdata), a 
018e			 
018e			 
018e			 
018e				; for port a that shares with spi lines AND the mask 
018e			 
018e 3a 6a fa			ld a, (spi_device)  
0191 4f				ld c, a 
0192			 
0192 f1				pop af 
0193			 
0193				; detect CEx 
0193			 
0193				if DEBUG_SPI 
0193					push hl 
0193					ld h, a 
0193				endif 
0193			 
0193 cb 41			bit SPI_CE0, c 
0195 20 04			jr nz, .cel1 
0197 cb 87			res SPI_CE0, a 
0199 18 1e			jr .celn 
019b			.cel1: 
019b cb 49			bit SPI_CE1, c 
019d 20 04			jr nz, .cel2 
019f cb 8f			res SPI_CE1, a 
01a1 18 16			jr .celn 
01a3			.cel2: 
01a3 cb 51			bit SPI_CE2, c 
01a5 20 04			jr nz, .cel3 
01a7 cb 97			res SPI_CE2, a 
01a9 18 0e			jr .celn 
01ab			.cel3: 
01ab cb 59			bit SPI_CE3, c 
01ad 20 04			jr nz, .cel4 
01af cb 9f			res SPI_CE3, a 
01b1 18 06			jr .celn 
01b3			.cel4: 
01b3 cb 61			bit SPI_CE4, c 
01b5 20 02			jr nz, .celn 
01b7 cb a7			res SPI_CE4, a 
01b9			.celn: 
01b9			 
01b9			 
01b9			 
01b9			;	add c 
01b9			 
01b9				if DEBUG_SPI 
01b9					ld l, a 
01b9					DMARK "CEl" 
01b9					CALLMONITOR 
01b9					pop hl 
01b9				endif 
01b9 c1				pop bc 
01ba c9				ret 
01bb			 
01bb			 
01bb			 
01bb			; eof 
01bb			 
01bb			 
01bb			 
01bb			 
01bb			 
# End of file firmware_spi.asm
01bb				include "firmware_seeprom.asm"  
01bb			; 
01bb			; persisent storage interface via microchip serial eeprom 
01bb			 
01bb			; port a pio 2 
01bb			; pa 7 - si 
01bb			; pa 6 - sclk  
01bb			; pa 5 - so 
01bb			; pa 4 - cs 
01bb			; pa 3 - cs 
01bb			; pa 2 - cs 
01bb			; pa 1 - cs 
01bb			; pa 0 - cs 
01bb			; 
01bb			; TODO get block 
01bb			; TODO save block 
01bb			; TODO load file 
01bb			; TODO save file 
01bb			; TODO get dir  
01bb			 
01bb			;  
01bb			storage_adata: equ Device_C    ; device c port a - onboard storage 
01bb			storage_actl: equ Device_C+2     ; device c port a 
01bb			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01bb			storage_bctl: equ Device_C+3     ; device c port b 
01bb			 
01bb			 
01bb			; TODO move these to hardware driver file 
01bb			 
01bb			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01bb			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01bb			; storage bank file system format 
01bb			; 
01bb			; first page of bank: 
01bb			; 	addr 0 - status check 
01bb			;       addr 1 - write protect flag 
01bb			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01bb			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01bb			;         TODO see if scanning whole of for available next file id is fast enough 
01bb			;	addr 4 > zero term string of bank label 
01bb			; 
01bb			;        
01bb			;  
01bb			; first page of any file: 
01bb			;      byte 0 - file id  
01bb			;      byte 1-17 - fixed file name  
01bb			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01bb			; 
01bb			; other pages of any file: 
01bb			;      byte 0 - file id 
01bb			;      byte 1> - file data 
01bb			; 
01bb			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01bb			;  
01bb			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01bb			 
01bb			 
01bb			;storage_so_bit: 5 
01bb			;storage_si_bit: 7 
01bb			;storage_sclk_bit: 6 
01bb			  
01bb			 
01bb			; init storage pio 
01bb			 
01bb			storage_init: 
01bb			 
01bb 3e cf		            LD   A, 11001111b 
01bd d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01bf 3e 00		            LD   A, 00000000b 
01c1 cb f7			set SPI_DO,a 
01c3			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01c3 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01c5			 
01c5 3e cf		            LD   A, 11001111b 
01c7 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01c9 3e 00		            LD   A, 00000000b 
01cb d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01cd			 
01cd				; set all external spi devices off 
01cd 3e 00			ld a, 0 
01cf 32 6a fa			ld (spi_device), a 
01d2 32 6d fa			ld (spi_cartdev), a 
01d5			 
01d5					; ensure the spi bus is in a default stable state 
01d5 cd a0 00				call se_stable_spi 
01d8			 
01d8			; TODO scan spi bus and gather which storage banks are present 
01d8			 
01d8			; populate store_bank_active  
01d8			; for each ce line activate and attempt to write first byte of bank and read back 
01d8			; if zero is returned then bank is empty 
01d8			;   
01d8			; 
01d8			 
01d8					; init file extent cache to save on slow reads 
01d8			 
01d8			;	ld hl, store_filecache 
01d8			;	ld de, 0 
01d8			;	ld hl,(de)	 
01d8			 
01d8			 
01d8 c9			    ret 
01d9			 
01d9			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01d9			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01d9			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01d9			 
01d9			; INSTRUCTION SET 
01d9			; READ 0000 0011 Read data from memory array beginning at selected address 
01d9			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01d9			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01d9			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01d9			; RDSR 0000 0101 Read STATUS register 
01d9			; WRSR 0000 0001 Write STATUS register 
01d9			; PE 0100 0010 Page Erase – erase one page in memory array 
01d9			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01d9			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01d9			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01d9			 
01d9			; TODO send byte steam for page without setting the address for every single byte 
01d9			; TODO read byte  
01d9			 
01d9			; byte in a 
01d9			; address in hl  
01d9			se_writebyte: 
01d9			        
01d9			    ;   ld c, a 
01d9 f5			        push af 
01da e5			        push hl 
01db			 
01db			    ; initi write mode 
01db			    ; 
01db			    ;CS low 
01db			 
01db 3a 6b fa		       ld a,(spi_portbyte) 
01de cd 87 01			call spi_ce_low 
01e1			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01e1 d3 80		       out (storage_adata),a 
01e3 32 6b fa		       ld (spi_portbyte), a 
01e6			 
01e6			    ;clock out wren instruction 
01e6			 
01e6 3e 06		    ld a, store_wren_ins 
01e8 cd ab 00		    call spi_send_byte  
01eb			 
01eb			    ;cs high to enable write latch 
01eb			 
01eb 3a 6b fa		       ld a,(spi_portbyte) 
01ee cd 76 01			call spi_ce_high 
01f1			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f1 d3 80		       out (storage_adata),a 
01f3 32 6b fa		       ld (spi_portbyte), a 
01f6			 
01f6 00				nop 
01f7			    ; 
01f7			    ; intial write data 
01f7			    ; 
01f7			    ; cs low 
01f7			     
01f7 3a 6b fa		       ld a,(spi_portbyte) 
01fa cd 87 01			call spi_ce_low 
01fd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fd d3 80		       out (storage_adata),a 
01ff 32 6b fa		       ld (spi_portbyte), a 
0202			 
0202			    ; clock out write instruction 
0202			     
0202 3e 02		    ld a, store_write_ins  
0204 cd ab 00		    call spi_send_byte  
0207			 
0207			    ; clock out address (depending on address size) 
0207			     
0207 e1			    pop hl 
0208 7c			    ld a,h    ; address out msb first 
0209 cd ab 00		    call spi_send_byte  
020c 7d			    ld a,l 
020d cd ab 00		    call spi_send_byte  
0210			 
0210			    ; clock out byte(s) for page 
0210			 
0210 f1			    pop af 
0211 cd ab 00		    call spi_send_byte  
0214			 
0214			    ; end write with ce high 
0214 3a 6b fa		       ld a,(spi_portbyte) 
0217			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0217 cd 76 01			call spi_ce_high 
021a d3 80		       out (storage_adata),a 
021c 32 6b fa		       ld (spi_portbyte), a 
021f			 
021f				; pause for internal write cycle 
021f 3e 0a			ld a, 10 
0221 cd 2c 0c			call aDelayInMS 
0224 c9			    ret 
0225			 
0225			; buffer to write in de 
0225			; address in hl  
0225			se_writepage: 
0225			        
0225			    ;   ld c, a 
0225 d5				push de 
0226 e5			        push hl 
0227			 
0227			    ; initi write mode 
0227			    ; 
0227			    ;CS low 
0227			 
0227 3a 6b fa		       ld a,(spi_portbyte) 
022a cd 87 01			call spi_ce_low 
022d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022d d3 80		       out (storage_adata),a 
022f 32 6b fa		       ld (spi_portbyte), a 
0232			 
0232			    ;clock out wren instruction 
0232			 
0232 3e 06		    ld a, store_wren_ins 
0234 cd ab 00		    call spi_send_byte  
0237			 
0237			    ;cs high to enable write latch 
0237			 
0237 3a 6b fa		       ld a,(spi_portbyte) 
023a cd 76 01			call spi_ce_high 
023d			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
023d d3 80		       out (storage_adata),a 
023f 32 6b fa		       ld (spi_portbyte), a 
0242			 
0242 00				nop 
0243			    ; 
0243			    ; intial write data 
0243			    ; 
0243			    ; cs low 
0243			     
0243 3a 6b fa		       ld a,(spi_portbyte) 
0246			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0246 cd 87 01			call spi_ce_low 
0249 d3 80		       out (storage_adata),a 
024b 32 6b fa		       ld (spi_portbyte), a 
024e			 
024e			    ; clock out write instruction 
024e			     
024e 3e 02		    ld a, store_write_ins  
0250 cd ab 00		    call spi_send_byte  
0253			 
0253			    ; clock out address (depending on address size) 
0253			     
0253 e1			    pop hl 
0254 7c			    ld a,h    ; address out msb first 
0255 cd ab 00		    call spi_send_byte  
0258 7d			    ld a,l 
0259 cd ab 00		    call spi_send_byte  
025c			 
025c			    ; clock out byte(s) for page 
025c			 
025c e1				pop hl 
025d 06 40			ld b, STORE_BLOCK_PHY 
025f			.bytewrite: 
025f			 
025f 7e				ld a,(hl) 
0260 e5			    push hl 
0261 c5				push bc 
0262 cd ab 00		    call spi_send_byte  
0265 c1				pop bc 
0266 e1				pop hl 
0267			 
0267			    ; end write with ce high 
0267 3a 6b fa		       ld a,(spi_portbyte) 
026a cd 76 01			call spi_ce_high 
026d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
026d d3 80		       out (storage_adata),a 
026f 32 6b fa		       ld (spi_portbyte), a 
0272			 
0272 23				inc hl 
0273 10 ea			djnz .bytewrite 
0275			 
0275				; pause for internal write cycle 
0275 3e 64			ld a, 100 
0277 cd 2c 0c			call aDelayInMS 
027a c9			    ret 
027b			; returns byte in a 
027b			; address in hl  
027b			se_readbyte: 
027b d5				push de 
027c c5				push bc 
027d			 
027d			    ;   ld c, a 
027d e5			        push hl 
027e			 
027e			    ; initi write mode 
027e			    ; 
027e			    ;CS low 
027e			 
027e 3a 6b fa		       ld a,(spi_portbyte) 
0281 cd 87 01			call spi_ce_low 
0284			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0284 d3 80		       out (storage_adata),a 
0286 32 6b fa		       ld (spi_portbyte), a 
0289			 
0289			    ;clock out wren instruction 
0289			 
0289 3e 03		    ld a, store_read_ins 
028b cd ab 00		    call spi_send_byte  
028e			 
028e			 
028e			    ; clock out address (depending on address size) 
028e			     
028e e1			    pop hl 
028f 7c			    ld a,h    ; address out msb first 
0290 cd ab 00		    call spi_send_byte  
0293 7d			    ld a,l 
0294 cd ab 00		    call spi_send_byte  
0297			 
0297			    ; clock in byte(s) for page 
0297			 
0297 cd cc 00		    call spi_read_byte  
029a f5				push af 
029b			 
029b			    ; end write with ce high 
029b 3a 6b fa		       ld a,(spi_portbyte) 
029e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029e cd 76 01			call spi_ce_high 
02a1 d3 80		       out (storage_adata),a 
02a3 32 6b fa		       ld (spi_portbyte), a 
02a6			 
02a6 f1				pop af 
02a7			 
02a7 c1				pop bc 
02a8 d1				pop de 
02a9			 
02a9 c9			    ret 
02aa			 
02aa			if DEBUG_STORESE 
02aa			 
02aa			storageput:  
02aa			 
02aa			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02aa			 
02aa 21 01 f2			ld hl,scratch+2 
02ad cd b5 12			call get_word_hl 
02b0			 
02b0				; stuff it here for the moment as it will be overwritten later anyway 
02b0			 
02b0 22 22 f5			ld (os_cur_ptr),hl	 
02b3			 
02b3			 
02b3			; get pointer to start of string 
02b3			 
02b3 21 06 f2			ld hl, scratch+7 
02b6			 
02b6			; loop writing char of string to eeprom 
02b6			 
02b6 7e			.writestr:	ld a,(hl) 
02b7 fe 00				cp 0 
02b9 28 12				jr z, .wsdone		; done writing 
02bb e5					push hl 
02bc 2a 22 f5				ld hl,(os_cur_ptr) 
02bf cd d9 01				call se_writebyte 
02c2			 
02c2 2a 22 f5				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02c5 23					inc hl 
02c6 22 22 f5				ld (os_cur_ptr),hl 
02c9			 
02c9					; restore string pointer and get next char 
02c9			 
02c9 e1					pop hl 
02ca 23					inc hl 
02cb 18 e9				jr .writestr 
02cd			 
02cd			 
02cd			 
02cd			.wsdone: 
02cd			 
02cd			 
02cd			; when done load first page into a buffer  
02cd			 
02cd 21 00 80				ld hl,08000h		; start in ram 
02d0 22 22 f5				ld (os_cur_ptr),hl 
02d3 21 00 00				ld hl, 0		 ; start of page 
02d6 22 27 f2				ld (scratch+40),hl	; hang on to it 
02d9			 
02d9 06 80				ld b, 128		; actually get more then one page 
02db c5			.wsload:	push bc 
02dc 2a 27 f2				ld hl,(scratch+40) 
02df e5					push hl 
02e0 cd 7b 02				call se_readbyte 
02e3			 
02e3					; a now as the byte 
02e3			 
02e3 2a 22 f5				ld hl,(os_cur_ptr) 
02e6 77					ld (hl),a 
02e7					; inc next buffer area 
02e7 23					inc hl 
02e8 22 22 f5				ld (os_cur_ptr),hl 
02eb			 
02eb					; get eeprom position, inc and save for next round 
02eb e1					pop hl		 
02ec 23					inc hl 
02ed 22 27 f2				ld (scratch+40),hl 
02f0 c1					pop bc 
02f1 10 e8				djnz .wsload 
02f3			 
02f3			; set 'd' pointer to start of buffer 
02f3			 
02f3 21 00 80				ld hl,08000h 
02f6 22 22 f5				ld (os_cur_ptr),hl 
02f9			 
02f9			 
02f9 c9			ret 
02fa			 
02fa			 
02fa c9			storageread: ret 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			endif 
02fb			 
02fb			 
02fb			 
# End of file firmware_seeprom.asm
02fb			else  
02fb			   ; create some stubs for the labels  
02fb			se_readbyte: ret  
02fb			se_writebyte: ret  
02fb			storage_init: ret  
02fb			  
02fb			endif  
02fb			  
02fb			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02fb			;include "firmware_cf.asm"  
02fb			  
02fb			; load up high level storage hardward abstractions  
02fb			include "firmware_storage.asm"  
02fb			 
02fb			; persisent storage hardware abstraction layer  
02fb			 
02fb			 
02fb			 
02fb			; Block 0 on storage is a config state 
02fb			 
02fb			 
02fb			 
02fb			; TODO add read phy block and write phy block functions 
02fb			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02fb			 
02fb			; Abstraction layer  
02fb			 
02fb			; Logocial block size is same size as physical size - using tape concept 
02fb			 
02fb			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02fb			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02fb			 
02fb			 
02fb			 
02fb			; Filesystem layout (Logical layout) 
02fb			; 
02fb			; Block 0 - Bank config  
02fb			; 
02fb			;      Byte - 0 file id counter 
02fb			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02fb			;      Byte - 3-20 zero terminated bank label 
02fb			; 
02fb			; Block 1 > File storage 
02fb			; 
02fb			;      Byte 0 file id    - block 0 file details 
02fb			;      Byte 1 block id - block 0 is file  
02fb			;            Byte 2-15 - File name 
02fb			; 
02fb			;       - to end of block data 
02fb			; 
02fb			 
02fb			; Get ID for the file named in pointer held HL 
02fb			; Returns ID in HL = 255 if no file found 
02fb			 
02fb			storage_getid: 
02fb			 
02fb 22 7a fa			ld (store_tmp1), hl 
02fe			 
02fe				if DEBUG_STORESE 
02fe					DMARK "SGI" 
02fe f5				push af  
02ff 3a 13 03			ld a, (.dmark)  
0302 32 6e fe			ld (debug_mark),a  
0305 3a 14 03			ld a, (.dmark+1)  
0308 32 6f fe			ld (debug_mark+1),a  
030b 3a 15 03			ld a, (.dmark+2)  
030e 32 70 fe			ld (debug_mark+2),a  
0311 18 03			jr .pastdmark  
0313 ..			.dmark: db "SGI"  
0316 f1			.pastdmark: pop af  
0317			endm  
# End of macro DMARK
0317					CALLMONITOR 
0317 cd a5 18			call break_point_state  
031a				endm  
# End of macro CALLMONITOR
031a				endif 
031a				; get block 0 and set counter for number of files to scan 
031a			 
031a cd 85 04			call storage_get_block_0 
031d			 
031d 3a 81 fa			ld a, (store_page) 
0320 47				ld b, a 
0321			 
0321				; get extent 0 of each file id 
0321			 
0321				if DEBUG_STORESE 
0321					DMARK "SGc" 
0321 f5				push af  
0322 3a 36 03			ld a, (.dmark)  
0325 32 6e fe			ld (debug_mark),a  
0328 3a 37 03			ld a, (.dmark+1)  
032b 32 6f fe			ld (debug_mark+1),a  
032e 3a 38 03			ld a, (.dmark+2)  
0331 32 70 fe			ld (debug_mark+2),a  
0334 18 03			jr .pastdmark  
0336 ..			.dmark: db "SGc"  
0339 f1			.pastdmark: pop af  
033a			endm  
# End of macro DMARK
033a					CALLMONITOR 
033a cd a5 18			call break_point_state  
033d				endm  
# End of macro CALLMONITOR
033d				endif 
033d 60			.getloop:	ld h, b 
033e 2e 00				ld l, 0 
0340 c5					push bc 
0341			 
0341 11 81 fa				ld de, store_page 
0344				if DEBUG_STORESE 
0344					DMARK "SGr" 
0344 f5				push af  
0345 3a 59 03			ld a, (.dmark)  
0348 32 6e fe			ld (debug_mark),a  
034b 3a 5a 03			ld a, (.dmark+1)  
034e 32 6f fe			ld (debug_mark+1),a  
0351 3a 5b 03			ld a, (.dmark+2)  
0354 32 70 fe			ld (debug_mark+2),a  
0357 18 03			jr .pastdmark  
0359 ..			.dmark: db "SGr"  
035c f1			.pastdmark: pop af  
035d			endm  
# End of macro DMARK
035d					CALLMONITOR 
035d cd a5 18			call break_point_state  
0360				endm  
# End of macro CALLMONITOR
0360				endif 
0360 cd 2d 09				call storage_read 
0363 cd 27 0f				call ishlzero 
0366 28 2d				jr z, .gap 
0368					 
0368					; have a file name read. Is it one we want. 
0368			 
0368 2a 7a fa				ld hl, (store_tmp1) 
036b 11 84 fa				ld de, store_page+3   ; file name 
036e			 
036e				if DEBUG_STORESE 
036e					DMARK "SGc" 
036e f5				push af  
036f 3a 83 03			ld a, (.dmark)  
0372 32 6e fe			ld (debug_mark),a  
0375 3a 84 03			ld a, (.dmark+1)  
0378 32 6f fe			ld (debug_mark+1),a  
037b 3a 85 03			ld a, (.dmark+2)  
037e 32 70 fe			ld (debug_mark+2),a  
0381 18 03			jr .pastdmark  
0383 ..			.dmark: db "SGc"  
0386 f1			.pastdmark: pop af  
0387			endm  
# End of macro DMARK
0387					CALLMONITOR 
0387 cd a5 18			call break_point_state  
038a				endm  
# End of macro CALLMONITOR
038a				endif 
038a cd 94 13				call strcmp 
038d 20 06				jr nz, .gap   ; not this one 
038f			 
038f c1				        pop bc 
0390			 
0390 26 00				ld h, 0 
0392 68					ld l, b 
0393 18 22				jr .getdone 
0395						 
0395			 
0395			 
0395			 
0395			.gap: 
0395				if DEBUG_STORESE 
0395					DMARK "SGg" 
0395 f5				push af  
0396 3a aa 03			ld a, (.dmark)  
0399 32 6e fe			ld (debug_mark),a  
039c 3a ab 03			ld a, (.dmark+1)  
039f 32 6f fe			ld (debug_mark+1),a  
03a2 3a ac 03			ld a, (.dmark+2)  
03a5 32 70 fe			ld (debug_mark+2),a  
03a8 18 03			jr .pastdmark  
03aa ..			.dmark: db "SGg"  
03ad f1			.pastdmark: pop af  
03ae			endm  
# End of macro DMARK
03ae					CALLMONITOR 
03ae cd a5 18			call break_point_state  
03b1				endm  
# End of macro CALLMONITOR
03b1				endif 
03b1			 
03b1 c1					pop bc 
03b2 10 89				djnz .getloop 
03b4 21 ff 00				ld hl, 255 
03b7			.getdone: 
03b7			 
03b7				if DEBUG_STORESE 
03b7					DMARK "SGe" 
03b7 f5				push af  
03b8 3a cc 03			ld a, (.dmark)  
03bb 32 6e fe			ld (debug_mark),a  
03be 3a cd 03			ld a, (.dmark+1)  
03c1 32 6f fe			ld (debug_mark+1),a  
03c4 3a ce 03			ld a, (.dmark+2)  
03c7 32 70 fe			ld (debug_mark+2),a  
03ca 18 03			jr .pastdmark  
03cc ..			.dmark: db "SGe"  
03cf f1			.pastdmark: pop af  
03d0			endm  
# End of macro DMARK
03d0					CALLMONITOR 
03d0 cd a5 18			call break_point_state  
03d3				endm  
# End of macro CALLMONITOR
03d3				endif 
03d3			 
03d3 c9				ret 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			; Read Block 
03d4			; ---------- 
03d4			; 
03d4			; With current bank 
03d4			;  
03d4			; Get block number to read 
03d4			; Load physical blocks starting at start block into buffer 
03d4			 
03d4			; de points to buffer to use 
03d4			; hl holds logical block number  
03d4			 
03d4			storage_read_block: 
03d4			 
03d4				; TODO bank selection 
03d4			 
03d4				; for each of the physical blocks read it into the buffer 
03d4 06 40			ld b, STORE_BLOCK_PHY 
03d6			 
03d6				if DEBUG_STORESE 
03d6 d5					push de 
03d7				endif 
03d7				 
03d7			.rl1:    
03d7			 
03d7				; read physical block at hl into de 
03d7			        ; increment hl and de to next read position on exit 
03d7			 
03d7 e5				push hl 
03d8 d5				push de	 
03d9 c5				push bc 
03da			;	if DEBUG_STORESE 
03da			;		push af 
03da			;		ld a, 'R' 
03da			;		ld (debug_mark),a 
03da			;		pop af 
03da			;		CALLMONITOR 
03da			;	endif 
03da cd 7b 02			call se_readbyte 
03dd			;	if DEBUG_STORESE 
03dd			;		ld a,(spi_portbyte) 
03dd			;		ld l, a 
03dd			;		push af 
03dd			;		ld a, '1' 
03dd			;		ld (debug_mark),a 
03dd			;		pop af 
03dd			;		CALLMONITOR 
03dd			;	endif 
03dd c1				pop bc 
03de d1				pop de 
03df e1				pop hl 
03e0 12				ld (de),a 
03e1 23				inc hl 
03e2 13				inc de 
03e3			 
03e3			;	if DEBUG_STORESE 
03e3			;		push af 
03e3			;		ld a, 'r' 
03e3			;		ld (debug_mark),a 
03e3			;		pop af 
03e3			;		CALLMONITOR 
03e3			;	endif 
03e3			 
03e3 10 f2			djnz .rl1 
03e5			 
03e5				if DEBUG_STORESE 
03e5					DMARK "SRB" 
03e5 f5				push af  
03e6 3a fa 03			ld a, (.dmark)  
03e9 32 6e fe			ld (debug_mark),a  
03ec 3a fb 03			ld a, (.dmark+1)  
03ef 32 6f fe			ld (debug_mark+1),a  
03f2 3a fc 03			ld a, (.dmark+2)  
03f5 32 70 fe			ld (debug_mark+2),a  
03f8 18 03			jr .pastdmark  
03fa ..			.dmark: db "SRB"  
03fd f1			.pastdmark: pop af  
03fe			endm  
# End of macro DMARK
03fe d1					pop de 
03ff			; 
03ff			;		push af 
03ff			;		ld a, 'R' 
03ff			;		ld (debug_mark),a 
03ff			;		pop af 
03ff					CALLMONITOR 
03ff cd a5 18			call break_point_state  
0402				endm  
# End of macro CALLMONITOR
0402				endif 
0402 c9				ret	 
0403				 
0403			 
0403			; File Size 
0403			; --------- 
0403			; 
0403			;   hl file id 
0403			; 
0403			;  returns in hl the number of blocks 
0403			 
0403			storage_file_size: 
0403 5d				ld e, l 
0404 16 00			ld d, 0 
0406 21 40 00			ld hl, STORE_BLOCK_PHY 
0409					if DEBUG_FORTH_WORDS 
0409						DMARK "SIZ" 
0409 f5				push af  
040a 3a 1e 04			ld a, (.dmark)  
040d 32 6e fe			ld (debug_mark),a  
0410 3a 1f 04			ld a, (.dmark+1)  
0413 32 6f fe			ld (debug_mark+1),a  
0416 3a 20 04			ld a, (.dmark+2)  
0419 32 70 fe			ld (debug_mark+2),a  
041c 18 03			jr .pastdmark  
041e ..			.dmark: db "SIZ"  
0421 f1			.pastdmark: pop af  
0422			endm  
# End of macro DMARK
0422						CALLMONITOR 
0422 cd a5 18			call break_point_state  
0425				endm  
# End of macro CALLMONITOR
0425					endif 
0425 cd 07 07			call storage_findnextid 
0428			 
0428 cd 27 0f			call ishlzero 
042b			;	ld a, l 
042b			;	add h 
042b			;	cp 0 
042b c8				ret z			; block not found so EOF 
042c			 
042c 11 81 fa			ld de, store_page 
042f cd d4 03			call storage_read_block 
0432			 
0432 3a 83 fa			ld a, (store_page+2)	 ; get extent count 
0435 6f				ld l, a 
0436 26 00			ld h, 0 
0438 c9			 	ret 
0439			 
0439			 
0439			; Write Block 
0439			; ----------- 
0439			; 
0439			; With current bank 
0439			;  
0439			; Get block number to write 
0439			; Write physical blocks starting at start block from buffer 
0439			  
0439			storage_write_block: 
0439				; TODO bank selection 
0439			 
0439				; for each of the physical blocks read it into the buffer 
0439 06 40			ld b, STORE_BLOCK_PHY 
043b			 
043b				if DEBUG_STORESE 
043b					DMARK "SWB" 
043b f5				push af  
043c 3a 50 04			ld a, (.dmark)  
043f 32 6e fe			ld (debug_mark),a  
0442 3a 51 04			ld a, (.dmark+1)  
0445 32 6f fe			ld (debug_mark+1),a  
0448 3a 52 04			ld a, (.dmark+2)  
044b 32 70 fe			ld (debug_mark+2),a  
044e 18 03			jr .pastdmark  
0450 ..			.dmark: db "SWB"  
0453 f1			.pastdmark: pop af  
0454			endm  
# End of macro DMARK
0454			 
0454					;push af 
0454					;ld a, 'W' 
0454					;ld (debug_mark),a 
0454					;pop af 
0454					CALLMONITOR 
0454 cd a5 18			call break_point_state  
0457				endm  
# End of macro CALLMONITOR
0457				endif 
0457			 
0457			; might not be working 
0457			;	call se_writepage 
0457			 
0457			;	ret 
0457			; 
0457			 
0457			 
0457			 
0457			.wl1:    
0457			 
0457				; read physical block at hl into de 
0457			        ; increment hl and de to next read position on exit 
0457			 
0457 e5				push hl 
0458 d5				push de	 
0459 c5				push bc 
045a 1a				ld a,(de) 
045b				;if DEBUG_STORESE 
045b			;		push af 
045b			;		ld a, 'W' 
045b			;		ld (debug_mark),a 
045b			;		pop af 
045b			;		CALLMONITOR 
045b			;	endif 
045b cd d9 01			call se_writebyte 
045e			;	call delay250ms 
045e 00				nop 
045f 00				nop 
0460 00				nop 
0461			;	if DEBUG_STORESE 
0461			;		push af 
0461			;		ld a, 'w' 
0461			;		ld (debug_mark),a 
0461			;		pop af 
0461			;		CALLMONITOR 
0461			;	endif 
0461 c1				pop bc 
0462 d1				pop de 
0463 e1				pop hl 
0464 23				inc hl 
0465 13				inc de 
0466			 
0466			 
0466 10 ef			djnz .wl1 
0468			 
0468				if DEBUG_STORESE 
0468					DMARK "SW2" 
0468 f5				push af  
0469 3a 7d 04			ld a, (.dmark)  
046c 32 6e fe			ld (debug_mark),a  
046f 3a 7e 04			ld a, (.dmark+1)  
0472 32 6f fe			ld (debug_mark+1),a  
0475 3a 7f 04			ld a, (.dmark+2)  
0478 32 70 fe			ld (debug_mark+2),a  
047b 18 03			jr .pastdmark  
047d ..			.dmark: db "SW2"  
0480 f1			.pastdmark: pop af  
0481			endm  
# End of macro DMARK
0481			 
0481					;push af 
0481					;ld a, 'W' 
0481					;ld (debug_mark),a 
0481					;pop af 
0481					CALLMONITOR 
0481 cd a5 18			call break_point_state  
0484				endm  
# End of macro CALLMONITOR
0484				endif 
0484 c9				ret	 
0485			 
0485			; Init bank 
0485			; --------- 
0485			; 
0485			; With current bank 
0485			; 
0485			; Setup block 0 config 
0485			;     Set 0 file id counter 
0485			;     Set formatted byte pattern 
0485			;     Zero out bank label 
0485			;      
0485			; For every logical block write 0-1 byte as null 
0485			 
0485			storage_get_block_0: 
0485			 
0485				; TODO check presence 
0485			 
0485				; get block 0 config 
0485			 
0485 21 00 00			ld hl, 0 
0488 11 81 fa			ld de, store_page 
048b cd d4 03			call storage_read_block 
048e			 
048e				if DEBUG_STORESE 
048e					DMARK "SB0" 
048e f5				push af  
048f 3a a3 04			ld a, (.dmark)  
0492 32 6e fe			ld (debug_mark),a  
0495 3a a4 04			ld a, (.dmark+1)  
0498 32 6f fe			ld (debug_mark+1),a  
049b 3a a5 04			ld a, (.dmark+2)  
049e 32 70 fe			ld (debug_mark+2),a  
04a1 18 03			jr .pastdmark  
04a3 ..			.dmark: db "SB0"  
04a6 f1			.pastdmark: pop af  
04a7			endm  
# End of macro DMARK
04a7 11 81 fa				ld de, store_page 
04aa			;		push af 
04aa			;		ld a, 'i' 
04aa			;		ld (debug_mark),a 
04aa			;		pop af 
04aa					CALLMONITOR 
04aa cd a5 18			call break_point_state  
04ad				endm  
# End of macro CALLMONITOR
04ad				endif 
04ad			 
04ad				; is this area formatted? 
04ad			 
04ad			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04ad 2a 82 fa			ld hl, (store_page+1) 
04b0 3e 80			ld a,0x80 
04b2 bd				cp l 
04b3 20 22			jr nz, .ininotformatted 
04b5				; do a double check 
04b5 3e 27			ld a, 0x27 
04b7 bc				cp h 
04b8 20 1d			jr nz, .ininotformatted 
04ba			 
04ba				; formatted then 
04ba			 
04ba				if DEBUG_STORESE 
04ba					DMARK "SB1" 
04ba f5				push af  
04bb 3a cf 04			ld a, (.dmark)  
04be 32 6e fe			ld (debug_mark),a  
04c1 3a d0 04			ld a, (.dmark+1)  
04c4 32 6f fe			ld (debug_mark+1),a  
04c7 3a d1 04			ld a, (.dmark+2)  
04ca 32 70 fe			ld (debug_mark+2),a  
04cd 18 03			jr .pastdmark  
04cf ..			.dmark: db "SB1"  
04d2 f1			.pastdmark: pop af  
04d3			endm  
# End of macro DMARK
04d3					;push af 
04d3					;ld a, 'I' 
04d3					;ld (debug_mark),a 
04d3					;pop af 
04d3					CALLMONITOR 
04d3 cd a5 18			call break_point_state  
04d6				endm  
# End of macro CALLMONITOR
04d6				endif 
04d6 c9				ret 
04d7			 
04d7			.ininotformatted: 
04d7				; bank not formatted so poke various bits to make sure 
04d7			 
04d7				if DEBUG_STORESE 
04d7					DMARK "SB2" 
04d7 f5				push af  
04d8 3a ec 04			ld a, (.dmark)  
04db 32 6e fe			ld (debug_mark),a  
04de 3a ed 04			ld a, (.dmark+1)  
04e1 32 6f fe			ld (debug_mark+1),a  
04e4 3a ee 04			ld a, (.dmark+2)  
04e7 32 70 fe			ld (debug_mark+2),a  
04ea 18 03			jr .pastdmark  
04ec ..			.dmark: db "SB2"  
04ef f1			.pastdmark: pop af  
04f0			endm  
# End of macro DMARK
04f0					;push af 
04f0					;ld a, 'f' 
04f0					;ld (debug_mark),a 
04f0					;pop af 
04f0					CALLMONITOR 
04f0 cd a5 18			call break_point_state  
04f3				endm  
# End of macro CALLMONITOR
04f3				endif 
04f3			 
04f3 cd 0a 0c			call storage_clear_page 
04f6			 
04f6 21 81 fa			ld hl, store_page 
04f9 3e 00			ld a, 0 
04fb				 
04fb 77				ld (hl),a   ; reset file counter 
04fc			 
04fc 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04ff 22 82 fa		 	ld (store_page+1), hl	 
0502			 
0502				; set default label 
0502			 
0502 21 9e 05			ld hl, .defaultbanklabl 
0505 11 84 fa		 	ld de, store_page+3 
0508 01 0f 00			ld bc, 15 
050b ed b0			ldir 
050d			 
050d				; Append the current bank id 
050d 21 8d fa			ld hl, store_page+3+9 
0510 3a 69 fa			ld a, (spi_device_id) 
0513 77				ld (hl), a 
0514			 
0514				; save default page 0 
0514			 
0514 21 00 00			ld hl, 0 
0517 11 81 fa			ld de, store_page 
051a				if DEBUG_STORESE 
051a					DMARK "SB3" 
051a f5				push af  
051b 3a 2f 05			ld a, (.dmark)  
051e 32 6e fe			ld (debug_mark),a  
0521 3a 30 05			ld a, (.dmark+1)  
0524 32 6f fe			ld (debug_mark+1),a  
0527 3a 31 05			ld a, (.dmark+2)  
052a 32 70 fe			ld (debug_mark+2),a  
052d 18 03			jr .pastdmark  
052f ..			.dmark: db "SB3"  
0532 f1			.pastdmark: pop af  
0533			endm  
# End of macro DMARK
0533			;		push af 
0533			;		ld a, 'F' 
0533			;		ld (debug_mark),a 
0533			;		pop af 
0533					CALLMONITOR 
0533 cd a5 18			call break_point_state  
0536				endm  
# End of macro CALLMONITOR
0536				endif 
0536 cd 39 04			call storage_write_block 
0539				if DEBUG_STORESE 
0539					DMARK "SB4" 
0539 f5				push af  
053a 3a 4e 05			ld a, (.dmark)  
053d 32 6e fe			ld (debug_mark),a  
0540 3a 4f 05			ld a, (.dmark+1)  
0543 32 6f fe			ld (debug_mark+1),a  
0546 3a 50 05			ld a, (.dmark+2)  
0549 32 70 fe			ld (debug_mark+2),a  
054c 18 03			jr .pastdmark  
054e ..			.dmark: db "SB4"  
0551 f1			.pastdmark: pop af  
0552			endm  
# End of macro DMARK
0552			;		push af 
0552			;		ld a, '>' 
0552			;		ld (debug_mark),a 
0552			;		pop af 
0552					CALLMONITOR 
0552 cd a5 18			call break_point_state  
0555				endm  
# End of macro CALLMONITOR
0555				endif 
0555			 
0555 00				nop 
0556 00				nop 
0557 00				nop 
0558			 
0558				; now set 0 in every page to mark as a free block 
0558			 
0558 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
055a 21 40 00			ld hl, STORE_BLOCK_PHY 
055d			 
055d 3e 00		.setmark1:   	ld a,0 
055f e5					push hl 
0560 c5					push bc 
0561 cd d9 01				call se_writebyte 
0564 3e 0a			ld a, 10 
0566 cd 2c 0c			call aDelayInMS 
0569 23				inc hl 
056a cd d9 01				call se_writebyte 
056d 3e 0a			ld a, 10 
056f cd 2c 0c			call aDelayInMS 
0572 2b				dec hl 
0573 c1					pop bc 
0574 e1					pop hl 
0575 3e 40				ld a, STORE_BLOCK_PHY 
0577 cd fe 0e				call addatohl 
057a 10 e1				djnz .setmark1 
057c			 
057c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
057e 3e 00		.setmark2:   	ld a,0 
0580 e5					push hl 
0581 c5					push bc 
0582 cd d9 01				call se_writebyte 
0585 3e 0a			ld a, 10 
0587 cd 2c 0c			call aDelayInMS 
058a 23				inc hl 
058b cd d9 01				call se_writebyte 
058e 3e 0a			ld a, 10 
0590 cd 2c 0c			call aDelayInMS 
0593 2b				dec hl 
0594 c1					pop bc 
0595 e1					pop hl 
0596 3e 40				ld a, STORE_BLOCK_PHY 
0598 cd fe 0e				call addatohl 
059b 10 e1				djnz .setmark2 
059d			 
059d					 
059d			 
059d			 
059d c9				ret 
059e			 
059e			 
059e			 
059e			 
059e .. 00		.defaultbanklabl:   db "BankLabel_",0 
05a9			 
05a9			 
05a9			 
05a9			; Label Bank 
05a9			; ---------- 
05a9			; 
05a9			; With current bank 
05a9			; Read block 0 
05a9			; Set label 
05a9			; Write block 0 
05a9			 
05a9			; label str pointer in hl 
05a9			 
05a9			storage_label:     
05a9			 
05a9				if DEBUG_STORESE 
05a9					DMARK "LBL" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 6e fe			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 6f fe			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 70 fe			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "LBL"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2					CALLMONITOR 
05c2 cd a5 18			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5				endif 
05c5			 
05c5 e5				push hl 
05c6			 
05c6 cd 85 04			call storage_get_block_0 
05c9			 
05c9				; set default label 
05c9			 
05c9 e1				pop hl 
05ca			 
05ca 11 84 fa		 	ld de, store_page+3 
05cd 01 0f 00			ld bc, 15 
05d0				if DEBUG_STORESE 
05d0					DMARK "LB3" 
05d0 f5				push af  
05d1 3a e5 05			ld a, (.dmark)  
05d4 32 6e fe			ld (debug_mark),a  
05d7 3a e6 05			ld a, (.dmark+1)  
05da 32 6f fe			ld (debug_mark+1),a  
05dd 3a e7 05			ld a, (.dmark+2)  
05e0 32 70 fe			ld (debug_mark+2),a  
05e3 18 03			jr .pastdmark  
05e5 ..			.dmark: db "LB3"  
05e8 f1			.pastdmark: pop af  
05e9			endm  
# End of macro DMARK
05e9					CALLMONITOR 
05e9 cd a5 18			call break_point_state  
05ec				endm  
# End of macro CALLMONITOR
05ec				endif 
05ec ed b0			ldir 
05ee				; save default page 0 
05ee			 
05ee 21 00 00			ld hl, 0 
05f1 11 81 fa			ld de, store_page 
05f4				if DEBUG_STORESE 
05f4					DMARK "LBW" 
05f4 f5				push af  
05f5 3a 09 06			ld a, (.dmark)  
05f8 32 6e fe			ld (debug_mark),a  
05fb 3a 0a 06			ld a, (.dmark+1)  
05fe 32 6f fe			ld (debug_mark+1),a  
0601 3a 0b 06			ld a, (.dmark+2)  
0604 32 70 fe			ld (debug_mark+2),a  
0607 18 03			jr .pastdmark  
0609 ..			.dmark: db "LBW"  
060c f1			.pastdmark: pop af  
060d			endm  
# End of macro DMARK
060d					CALLMONITOR 
060d cd a5 18			call break_point_state  
0610				endm  
# End of macro CALLMONITOR
0610				endif 
0610 cd 39 04			call storage_write_block 
0613			 
0613 c9				ret 
0614			 
0614			 
0614			 
0614			; Read Block 0 - Config 
0614			; --------------------- 
0614			; 
0614			; With current bank 
0614			; Call presence test 
0614			;    If not present format/init bank  
0614			; Read block 0  
0614			;  
0614			 
0614			 
0614			; Dir 
0614			; --- 
0614			; 
0614			; With current bank 
0614			; Load Block 0 Config 
0614			; Get max file id number 
0614			; For each logical block 
0614			;    Read block read byte 2 
0614			;      if first block of file 
0614			;         Display file name 
0614			;         Display type flags for file 
0614			;        
0614			 
0614			; moving to words as this requires stack control 
0614			 
0614			 
0614			; Delete File 
0614			; ----------- 
0614			; 
0614			; With current bank 
0614			; 
0614			; Load Block 0 Config 
0614			; Get max file id number 
0614			; For each logical block 
0614			;    Read block file id 
0614			;      If first block of file and dont have file id 
0614			;         if file to delete 
0614			;         Save file id 
0614			;         Null file id 
0614			;         Write this block back 
0614			;      If file id is one saved 
0614			;         Null file id 
0614			;         Write this block back 
0614			 
0614			 
0614			.se_done: 
0614 e1				pop hl 
0615 c9				ret 
0616			 
0616			storage_erase: 
0616			 
0616				; hl contains the file id 
0616			 
0616 5d				ld e, l 
0617 16 00			ld d, 0 
0619 21 40 00			ld hl, STORE_BLOCK_PHY 
061c					if DEBUG_FORTH_WORDS 
061c						DMARK "ERA" 
061c f5				push af  
061d 3a 31 06			ld a, (.dmark)  
0620 32 6e fe			ld (debug_mark),a  
0623 3a 32 06			ld a, (.dmark+1)  
0626 32 6f fe			ld (debug_mark+1),a  
0629 3a 33 06			ld a, (.dmark+2)  
062c 32 70 fe			ld (debug_mark+2),a  
062f 18 03			jr .pastdmark  
0631 ..			.dmark: db "ERA"  
0634 f1			.pastdmark: pop af  
0635			endm  
# End of macro DMARK
0635						CALLMONITOR 
0635 cd a5 18			call break_point_state  
0638				endm  
# End of macro CALLMONITOR
0638					endif 
0638 cd 07 07			call storage_findnextid 
063b cd 27 0f			call ishlzero 
063e c8				ret z 
063f			 
063f e5				push hl 
0640			 
0640				; TODO check file not found 
0640			 
0640 11 81 fa			ld de, store_page 
0643 cd d4 03			call storage_read_block 
0646			 
0646 cd 27 0f			call ishlzero 
0649 ca 14 06			jp z,.se_done 
064c			 
064c					if DEBUG_FORTH_WORDS 
064c						DMARK "ER1" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 6e fe			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 6f fe			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 70 fe			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "ER1"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665						CALLMONITOR 
0665 cd a5 18			call break_point_state  
0668				endm  
# End of macro CALLMONITOR
0668					endif 
0668 3a 81 fa			ld a, (store_page)	; get file id 
066b 32 75 fa			ld (store_tmpid), a 
066e			 
066e 3a 83 fa			ld a, (store_page+2)    ; get count of extends 
0671 32 74 fa			ld (store_tmpext), a 
0674			 
0674				; wipe file header 
0674			 
0674 e1				pop hl 
0675 3e 00			ld a, 0 
0677 32 81 fa			ld (store_page), a 
067a 32 82 fa			ld (store_page+1),a 
067d 11 81 fa			ld de, store_page 
0680					if DEBUG_FORTH_WORDS 
0680						DMARK "ER2" 
0680 f5				push af  
0681 3a 95 06			ld a, (.dmark)  
0684 32 6e fe			ld (debug_mark),a  
0687 3a 96 06			ld a, (.dmark+1)  
068a 32 6f fe			ld (debug_mark+1),a  
068d 3a 97 06			ld a, (.dmark+2)  
0690 32 70 fe			ld (debug_mark+2),a  
0693 18 03			jr .pastdmark  
0695 ..			.dmark: db "ER2"  
0698 f1			.pastdmark: pop af  
0699			endm  
# End of macro DMARK
0699						CALLMONITOR 
0699 cd a5 18			call break_point_state  
069c				endm  
# End of macro CALLMONITOR
069c					endif 
069c cd 39 04			call storage_write_block 
069f			 
069f			 
069f				; wipe file extents 
069f			 
069f 3a 74 fa			ld a, (store_tmpext) 
06a2 47				ld b, a 
06a3			 
06a3			.eraext:	  
06a3 c5				push bc 
06a4			 
06a4 21 40 00			ld hl, STORE_BLOCK_PHY 
06a7 3a 75 fa			ld a,(store_tmpid) 
06aa 5f				ld e, a 
06ab 50				ld d, b	 
06ac					if DEBUG_FORTH_WORDS 
06ac						DMARK "ER3" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6e fe			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6f fe			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 70 fe			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "ER3"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5						CALLMONITOR 
06c5 cd a5 18			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8					endif 
06c8 cd 07 07			call storage_findnextid 
06cb cd 27 0f			call ishlzero 
06ce ca 14 06			jp z,.se_done 
06d1			 
06d1 e5				push hl 
06d2 11 81 fa			ld de, store_page 
06d5 cd d4 03			call storage_read_block 
06d8			 
06d8				; free block	 
06d8			 
06d8 3e 00			ld a, 0 
06da 32 81 fa			ld (store_page), a 
06dd 32 82 fa			ld (store_page+1),a 
06e0 11 81 fa			ld de, store_page 
06e3 e1				pop hl 
06e4					if DEBUG_FORTH_WORDS 
06e4						DMARK "ER4" 
06e4 f5				push af  
06e5 3a f9 06			ld a, (.dmark)  
06e8 32 6e fe			ld (debug_mark),a  
06eb 3a fa 06			ld a, (.dmark+1)  
06ee 32 6f fe			ld (debug_mark+1),a  
06f1 3a fb 06			ld a, (.dmark+2)  
06f4 32 70 fe			ld (debug_mark+2),a  
06f7 18 03			jr .pastdmark  
06f9 ..			.dmark: db "ER4"  
06fc f1			.pastdmark: pop af  
06fd			endm  
# End of macro DMARK
06fd						CALLMONITOR 
06fd cd a5 18			call break_point_state  
0700				endm  
# End of macro CALLMONITOR
0700					endif 
0700 cd 39 04			call storage_write_block 
0703			 
0703 c1				pop bc 
0704 10 9d			djnz .eraext 
0706			 
0706 c9				ret 
0707			 
0707			 
0707			; Find Free Block 
0707			; --------------- 
0707			; 
0707			; With current bank 
0707			;  
0707			; From given starting logical block 
0707			;    Read block  
0707			;    If no file id 
0707			;         Return block id 
0707			 
0707			 
0707			; hl starting page number 
0707			; hl contains free page number or zero if no pages free 
0707			; e contains the file id to locate 
0707			; d contains the block number 
0707			 
0707			; TODO change to find file id and use zero for free block 
0707			 
0707			storage_findnextid: 
0707			 
0707				; now locate first 0 page to mark as a free block 
0707			 
0707 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0709			;	ld hl, STORE_BLOCK_PHY 
0709			 
0709					if DEBUG_FORTH_WORDS 
0709					DMARK "FNI" 
0709 f5				push af  
070a 3a 1e 07			ld a, (.dmark)  
070d 32 6e fe			ld (debug_mark),a  
0710 3a 1f 07			ld a, (.dmark+1)  
0713 32 6f fe			ld (debug_mark+1),a  
0716 3a 20 07			ld a, (.dmark+2)  
0719 32 70 fe			ld (debug_mark+2),a  
071c 18 03			jr .pastdmark  
071e ..			.dmark: db "FNI"  
0721 f1			.pastdmark: pop af  
0722			endm  
# End of macro DMARK
0722						CALLMONITOR 
0722 cd a5 18			call break_point_state  
0725				endm  
# End of macro CALLMONITOR
0725					endif 
0725			.ff1:   	 
0725 e5					push hl 
0726 c5					push bc 
0727 d5					push de 
0728 cd 7b 02				call se_readbyte 
072b 5f					ld e,a 
072c 23					inc hl 
072d cd 7b 02				call se_readbyte 
0730 57					ld d, a 
0731 e1					pop hl 
0732 e5					push hl 
0733 cd 1c 0f				call cmp16 
0736 28 49				jr z, .fffound 
0738			 
0738 d1					pop de 
0739 c1					pop bc 
073a e1					pop hl 
073b			 
073b					; is found? 
073b					;cp e 
073b					;ret z 
073b			 
073b 3e 40				ld a, STORE_BLOCK_PHY 
073d cd fe 0e				call addatohl 
0740 10 e3				djnz .ff1 
0742			 
0742 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0744			.ff2:   	 
0744			 
0744 e5					push hl 
0745 c5					push bc 
0746 d5					push de 
0747 cd 7b 02				call se_readbyte 
074a 5f					ld e,a 
074b 23					inc hl 
074c cd 7b 02				call se_readbyte 
074f 57					ld d, a 
0750			 
0750 e1					pop hl 
0751 e5					push hl 
0752 cd 1c 0f				call cmp16 
0755 28 2a				jr z, .fffound 
0757			 
0757 d1					pop de 
0758 c1					pop bc 
0759 e1					pop hl 
075a					; is found? 
075a					;cp e 
075a					;ret z 
075a			 
075a 3e 40				ld a, STORE_BLOCK_PHY 
075c cd fe 0e				call addatohl 
075f 10 e3				djnz .ff2 
0761			 
0761			 
0761					if DEBUG_FORTH_WORDS 
0761					DMARK "FN-" 
0761 f5				push af  
0762 3a 76 07			ld a, (.dmark)  
0765 32 6e fe			ld (debug_mark),a  
0768 3a 77 07			ld a, (.dmark+1)  
076b 32 6f fe			ld (debug_mark+1),a  
076e 3a 78 07			ld a, (.dmark+2)  
0771 32 70 fe			ld (debug_mark+2),a  
0774 18 03			jr .pastdmark  
0776 ..			.dmark: db "FN-"  
0779 f1			.pastdmark: pop af  
077a			endm  
# End of macro DMARK
077a					;	push af 
077a					;	ld a, 'n' 
077a					;	ld (debug_mark),a 
077a					;	pop af 
077a						CALLMONITOR 
077a cd a5 18			call break_point_state  
077d				endm  
# End of macro CALLMONITOR
077d					endif 
077d				; no free marks! 
077d 21 00 00				ld hl, 0 
0780 c9				ret 
0781			.fffound: 
0781				 
0781			 
0781 d1					pop de 
0782 c1					pop bc 
0783 e1					pop hl 
0784					if DEBUG_FORTH_WORDS 
0784					DMARK "FNF" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 6e fe			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 6f fe			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 70 fe			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "FNF"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d					;	push af 
079d					;	ld a, 'n' 
079d					;	ld (debug_mark),a 
079d					;	pop af 
079d						CALLMONITOR 
079d cd a5 18			call break_point_state  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 c9				ret 
07a1			 
07a1			 
07a1			 
07a1			; Free Space 
07a1			; ---------- 
07a1			; 
07a1			; With current bank 
07a1			; 
07a1			; Set block count to zero 
07a1			; Starting with first logical block 
07a1			;      Find free block  
07a1			;      If block id given, increment block count 
07a1			; 
07a1			;  
07a1			 
07a1			 
07a1			; hl contains count of free blocks 
07a1			 
07a1			storage_freeblocks: 
07a1			 
07a1				; now locate first 0 page to mark as a free block 
07a1			 
07a1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a3 21 40 00			ld hl, STORE_BLOCK_PHY 
07a6 11 00 00			ld de, 0 
07a9			 
07a9			.fb1:   	 
07a9 e5					push hl 
07aa c5					push bc 
07ab d5					push de 
07ac cd 7b 02				call se_readbyte 
07af d1					pop de 
07b0 c1					pop bc 
07b1 e1					pop hl 
07b2			 
07b2					; is free? 
07b2 fe 00				cp 0 
07b4 20 01				jr nz, .ff1cont 
07b6 13					inc de 
07b7			 
07b7			.ff1cont: 
07b7			 
07b7			 
07b7 3e 40				ld a, STORE_BLOCK_PHY 
07b9 cd fe 0e				call addatohl 
07bc 10 eb				djnz .fb1 
07be			 
07be 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07c0			.fb2:   	 
07c0 e5					push hl 
07c1 c5					push bc 
07c2 d5					push de 
07c3 cd 7b 02				call se_readbyte 
07c6 d1					pop de 
07c7 c1					pop bc 
07c8 e1					pop hl 
07c9			 
07c9					; is free? 
07c9 fe 00				cp 0 
07cb 20 01				jr nz, .ff2cont 
07cd 13					inc de 
07ce			 
07ce			.ff2cont: 
07ce			 
07ce 3e 40				ld a, STORE_BLOCK_PHY 
07d0 cd fe 0e				call addatohl 
07d3 10 eb				djnz .fb2 
07d5			 
07d5 eb				ex de, hl 
07d6 c9				ret 
07d7			 
07d7			; Get File ID 
07d7			; ----------- 
07d7			; 
07d7			; With current bank 
07d7			;  
07d7			; Load Block 0 Config 
07d7			; Get max file id number 
07d7			; For each logical block 
07d7			;    Read block file id 
07d7			;      If first block of file and dont have file id 
07d7			;         if file get id and exit 
07d7			 
07d7			 
07d7			 
07d7			 
07d7			; Create File 
07d7			; ----------- 
07d7			; 
07d7			; With current bank  
07d7			; Load Block 0 Config 
07d7			; Get max file id number 
07d7			; Increment file id number 
07d7			; Save Config 
07d7			; Find free block 
07d7			; Set buffer with file name and file id 
07d7			; Write buffer to free block  
07d7			 
07d7			 
07d7			; hl point to file name 
07d7			; hl returns file id 
07d7			 
07d7			; file format: 
07d7			; byte 0 - file id 
07d7			; byte 1 - extent number 
07d7			; byte 2-> data 
07d7			 
07d7			; format for extent number 0: 
07d7			; 
07d7			; byte 0 - file id 
07d7			; byte 1 - extent 0 
07d7			; byte 2 - extent count 
07d7			; byte 3 -> file name and meta data 
07d7			 
07d7			 
07d7			storage_create: 
07d7				if DEBUG_STORESE 
07d7					DMARK "SCR" 
07d7 f5				push af  
07d8 3a ec 07			ld a, (.dmark)  
07db 32 6e fe			ld (debug_mark),a  
07de 3a ed 07			ld a, (.dmark+1)  
07e1 32 6f fe			ld (debug_mark+1),a  
07e4 3a ee 07			ld a, (.dmark+2)  
07e7 32 70 fe			ld (debug_mark+2),a  
07ea 18 03			jr .pastdmark  
07ec ..			.dmark: db "SCR"  
07ef f1			.pastdmark: pop af  
07f0			endm  
# End of macro DMARK
07f0					CALLMONITOR 
07f0 cd a5 18			call break_point_state  
07f3				endm  
# End of macro CALLMONITOR
07f3				endif 
07f3			 
07f3 e5				push hl		; save file name pointer 
07f4			 
07f4 cd 85 04			call storage_get_block_0 
07f7			 
07f7 3a 81 fa			ld a,(store_page)	; get current file id 
07fa 3c				inc a 
07fb 32 81 fa			ld (store_page),a 
07fe				 
07fe 32 75 fa			ld (store_tmpid),a			; save id 
0801			 
0801 21 00 00			ld hl, 0 
0804 11 81 fa			ld de, store_page 
0807				if DEBUG_STORESE 
0807					DMARK "SCw" 
0807 f5				push af  
0808 3a 1c 08			ld a, (.dmark)  
080b 32 6e fe			ld (debug_mark),a  
080e 3a 1d 08			ld a, (.dmark+1)  
0811 32 6f fe			ld (debug_mark+1),a  
0814 3a 1e 08			ld a, (.dmark+2)  
0817 32 70 fe			ld (debug_mark+2),a  
081a 18 03			jr .pastdmark  
081c ..			.dmark: db "SCw"  
081f f1			.pastdmark: pop af  
0820			endm  
# End of macro DMARK
0820					CALLMONITOR 
0820 cd a5 18			call break_point_state  
0823				endm  
# End of macro CALLMONITOR
0823				endif 
0823 cd 39 04			call storage_write_block	 ; save update 
0826			 
0826				if DEBUG_STORESE 
0826 11 81 fa				ld de, store_page 
0829					DMARK "SCC" 
0829 f5				push af  
082a 3a 3e 08			ld a, (.dmark)  
082d 32 6e fe			ld (debug_mark),a  
0830 3a 3f 08			ld a, (.dmark+1)  
0833 32 6f fe			ld (debug_mark+1),a  
0836 3a 40 08			ld a, (.dmark+2)  
0839 32 70 fe			ld (debug_mark+2),a  
083c 18 03			jr .pastdmark  
083e ..			.dmark: db "SCC"  
0841 f1			.pastdmark: pop af  
0842			endm  
# End of macro DMARK
0842					CALLMONITOR 
0842 cd a5 18			call break_point_state  
0845				endm  
# End of macro CALLMONITOR
0845				endif 
0845				;  
0845				 
0845 21 40 00			ld hl, STORE_BLOCK_PHY 
0848 11 00 00			ld de, 0 
084b cd 07 07			call storage_findnextid 
084e			 
084e 22 6e fa			ld (store_tmppageid), hl    ; save page to use  
0851			 
0851				; TODO detect 0 = no spare blocks 
0851			 
0851				; hl now contains the free page to use for the file header page 
0851			 
0851				if DEBUG_STORESE 
0851				DMARK "SCF" 
0851 f5				push af  
0852 3a 66 08			ld a, (.dmark)  
0855 32 6e fe			ld (debug_mark),a  
0858 3a 67 08			ld a, (.dmark+1)  
085b 32 6f fe			ld (debug_mark+1),a  
085e 3a 68 08			ld a, (.dmark+2)  
0861 32 70 fe			ld (debug_mark+2),a  
0864 18 03			jr .pastdmark  
0866 ..			.dmark: db "SCF"  
0869 f1			.pastdmark: pop af  
086a			endm  
# End of macro DMARK
086a					CALLMONITOR 
086a cd a5 18			call break_point_state  
086d				endm  
# End of macro CALLMONITOR
086d				endif 
086d			 
086d 22 6e fa			ld (store_tmppageid), hl 
0870				 
0870 3a 75 fa			ld a,(store_tmpid)    ; get file id 
0873			;	ld a, (store_filecache)			; save to cache 
0873			 
0873 32 81 fa			ld (store_page),a    ; set page id 
0876 3e 00			ld a, 0			 ; extent 0 is file header 
0878 32 82 fa			ld (store_page+1), a   ; set file extent 
087b			 
087b 32 83 fa			ld (store_page+2), a   ; extent count for the file 
087e			 
087e			;	inc hl 		; init block 0 of file 
087e			;	inc hl   		; skip file and extent id 
087e			 ;       ld a, 0 
087e			;	ld (hl),a 
087e			;	ld a, (store_filecache+1)  	; save to cache 
087e			 
087e			;	inc hl    ; file name 
087e				 
087e				 
087e 11 84 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
0881				if DEBUG_STORESE 
0881					DMARK "SCc" 
0881 f5				push af  
0882 3a 96 08			ld a, (.dmark)  
0885 32 6e fe			ld (debug_mark),a  
0888 3a 97 08			ld a, (.dmark+1)  
088b 32 6f fe			ld (debug_mark+1),a  
088e 3a 98 08			ld a, (.dmark+2)  
0891 32 70 fe			ld (debug_mark+2),a  
0894 18 03			jr .pastdmark  
0896 ..			.dmark: db "SCc"  
0899 f1			.pastdmark: pop af  
089a			endm  
# End of macro DMARK
089a					CALLMONITOR 
089a cd a5 18			call break_point_state  
089d				endm  
# End of macro CALLMONITOR
089d				endif 
089d e1				pop hl    ; get zero term string 
089e e5				push hl 
089f 3e 00			ld a, 0 
08a1 cd 67 13			call strlent 
08a4 23				inc hl   ; cover zero term 
08a5 06 00			ld b,0 
08a7 4d				ld c,l 
08a8 e1				pop hl 
08a9				;ex de, hl 
08a9				if DEBUG_STORESE 
08a9					DMARK "SCa" 
08a9 f5				push af  
08aa 3a be 08			ld a, (.dmark)  
08ad 32 6e fe			ld (debug_mark),a  
08b0 3a bf 08			ld a, (.dmark+1)  
08b3 32 6f fe			ld (debug_mark+1),a  
08b6 3a c0 08			ld a, (.dmark+2)  
08b9 32 70 fe			ld (debug_mark+2),a  
08bc 18 03			jr .pastdmark  
08be ..			.dmark: db "SCa"  
08c1 f1			.pastdmark: pop af  
08c2			endm  
# End of macro DMARK
08c2					;push af 
08c2					;ld a, 'a' 
08c2					;ld (debug_mark),a 
08c2					;pop af 
08c2					CALLMONITOR 
08c2 cd a5 18			call break_point_state  
08c5				endm  
# End of macro CALLMONITOR
08c5				endif 
08c5 ed b0			ldir    ; copy zero term string 
08c7				if DEBUG_STORESE 
08c7					DMARK "SCA" 
08c7 f5				push af  
08c8 3a dc 08			ld a, (.dmark)  
08cb 32 6e fe			ld (debug_mark),a  
08ce 3a dd 08			ld a, (.dmark+1)  
08d1 32 6f fe			ld (debug_mark+1),a  
08d4 3a de 08			ld a, (.dmark+2)  
08d7 32 70 fe			ld (debug_mark+2),a  
08da 18 03			jr .pastdmark  
08dc ..			.dmark: db "SCA"  
08df f1			.pastdmark: pop af  
08e0			endm  
# End of macro DMARK
08e0					CALLMONITOR 
08e0 cd a5 18			call break_point_state  
08e3				endm  
# End of macro CALLMONITOR
08e3				endif 
08e3			 
08e3				; write file header page 
08e3			 
08e3 2a 6e fa			ld hl,(store_tmppageid) 
08e6 11 81 fa			ld de, store_page 
08e9				if DEBUG_STORESE 
08e9					DMARK "SCb" 
08e9 f5				push af  
08ea 3a fe 08			ld a, (.dmark)  
08ed 32 6e fe			ld (debug_mark),a  
08f0 3a ff 08			ld a, (.dmark+1)  
08f3 32 6f fe			ld (debug_mark+1),a  
08f6 3a 00 09			ld a, (.dmark+2)  
08f9 32 70 fe			ld (debug_mark+2),a  
08fc 18 03			jr .pastdmark  
08fe ..			.dmark: db "SCb"  
0901 f1			.pastdmark: pop af  
0902			endm  
# End of macro DMARK
0902					;push af 
0902					;ld a, 'b' 
0902					;ld (debug_mark),a 
0902					;pop af 
0902					CALLMONITOR 
0902 cd a5 18			call break_point_state  
0905				endm  
# End of macro CALLMONITOR
0905				endif 
0905 cd 39 04			call storage_write_block 
0908			 
0908 3a 75 fa			ld a, (store_tmpid) 
090b 6f				ld l, a 
090c 26 00			ld h,0 
090e				if DEBUG_STORESE 
090e					DMARK "SCz" 
090e f5				push af  
090f 3a 23 09			ld a, (.dmark)  
0912 32 6e fe			ld (debug_mark),a  
0915 3a 24 09			ld a, (.dmark+1)  
0918 32 6f fe			ld (debug_mark+1),a  
091b 3a 25 09			ld a, (.dmark+2)  
091e 32 70 fe			ld (debug_mark+2),a  
0921 18 03			jr .pastdmark  
0923 ..			.dmark: db "SCz"  
0926 f1			.pastdmark: pop af  
0927			endm  
# End of macro DMARK
0927					CALLMONITOR 
0927 cd a5 18			call break_point_state  
092a				endm  
# End of macro CALLMONITOR
092a				endif 
092a c9				ret 
092b				 
092b			 
092b			 
092b			; 
092b			; Read File 
092b			; 
092b			; h - file id to locate 
092b			; l - extent to locate 
092b			; de - pointer to string to read into 
092b			; 
092b			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
092b			 
092b			.sr_fail: 
092b d1				pop de 
092c c9				ret 
092d			 
092d			storage_read: 
092d			 
092d			 
092d d5				push de 
092e			 
092e			; TODO BUG the above push is it popped before the RET Z? 
092e			 
092e			; TODO how to handle multiple part blocks 
092e			 
092e				; locate file extent to read 
092e			 
092e 5c				ld e, h 
092f 55				ld d, l 
0930			 
0930			.srext: 
0930 22 7f fa			ld (store_readptr), hl     ; save the current extent to load 
0933 ed 53 7d fa		ld (store_readbuf), de     ; save the current buffer to load in to 
0937			 
0937 21 40 00			ld hl, STORE_BLOCK_PHY 
093a				if DEBUG_STORESE 
093a					DMARK "sre" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 6e fe			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 6f fe			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 70 fe			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "sre"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					CALLMONITOR 
0953 cd a5 18			call break_point_state  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 cd 07 07			call storage_findnextid 
0959			 
0959				if DEBUG_STORESE 
0959					DMARK "srf" 
0959 f5				push af  
095a 3a 6e 09			ld a, (.dmark)  
095d 32 6e fe			ld (debug_mark),a  
0960 3a 6f 09			ld a, (.dmark+1)  
0963 32 6f fe			ld (debug_mark+1),a  
0966 3a 70 09			ld a, (.dmark+2)  
0969 32 70 fe			ld (debug_mark+2),a  
096c 18 03			jr .pastdmark  
096e ..			.dmark: db "srf"  
0971 f1			.pastdmark: pop af  
0972			endm  
# End of macro DMARK
0972					CALLMONITOR 
0972 cd a5 18			call break_point_state  
0975				endm  
# End of macro CALLMONITOR
0975				endif 
0975 cd 27 0f			call ishlzero 
0978			;	ld a, l 
0978			;	add h 
0978			;	cp 0 
0978 28 b1			jr z,.sr_fail			; block not found so EOF 
097a			 
097a				; hl contains page number to load 
097a d1				pop de   ; get storage 
097b ed 53 7d fa		ld (store_readbuf), de     ; current buffer to load in to 
097f d5				push de 
0980				if DEBUG_STORESE 
0980					DMARK "srg" 
0980 f5				push af  
0981 3a 95 09			ld a, (.dmark)  
0984 32 6e fe			ld (debug_mark),a  
0987 3a 96 09			ld a, (.dmark+1)  
098a 32 6f fe			ld (debug_mark+1),a  
098d 3a 97 09			ld a, (.dmark+2)  
0990 32 70 fe			ld (debug_mark+2),a  
0993 18 03			jr .pastdmark  
0995 ..			.dmark: db "srg"  
0998 f1			.pastdmark: pop af  
0999			endm  
# End of macro DMARK
0999					CALLMONITOR 
0999 cd a5 18			call break_point_state  
099c				endm  
# End of macro CALLMONITOR
099c				endif 
099c cd d4 03			call storage_read_block 
099f			 
099f				; if this a continuation read??? 
099f			 
099f 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09a2			 
09a2 3e 3f			ld a, STORE_BLOCK_PHY-1 
09a4 cd fe 0e			call addatohl 
09a7 7e				ld a,(hl) 
09a8 fe 00			cp 0 
09aa 28 02			jr z, .markiscont 
09ac 3e ff			ld a, 255 
09ae			 
09ae			.markiscont: 
09ae 32 74 fa			ld (store_readcont), a 
09b1			 
09b1				if DEBUG_STORESE 
09b1					DMARK "srC" 
09b1 f5				push af  
09b2 3a c6 09			ld a, (.dmark)  
09b5 32 6e fe			ld (debug_mark),a  
09b8 3a c7 09			ld a, (.dmark+1)  
09bb 32 6f fe			ld (debug_mark+1),a  
09be 3a c8 09			ld a, (.dmark+2)  
09c1 32 70 fe			ld (debug_mark+2),a  
09c4 18 03			jr .pastdmark  
09c6 ..			.dmark: db "srC"  
09c9 f1			.pastdmark: pop af  
09ca			endm  
# End of macro DMARK
09ca					CALLMONITOR 
09ca cd a5 18			call break_point_state  
09cd				endm  
# End of macro CALLMONITOR
09cd				endif 
09cd				; only short reads enabled 
09cd			 
09cd 3a 7c fa			ld a, (store_longread) 
09d0 fe 00			cp 0 
09d2 ca 9c 0a			jp z, .readdone 
09d5			 
09d5			; TODO if block has no zeros then need to read next block  
09d5			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
09d5			; check last byte of physical block. 
09d5			; if not zero then the next block needs to be loaded 
09d5			 
09d5			 
09d5 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09d8			 
09d8 3e 3f			ld a, STORE_BLOCK_PHY-1 
09da cd fe 0e			call addatohl 
09dd				;dec hl 
09dd 7e				ld a,(hl) 
09de				if DEBUG_STORESE 
09de					DMARK "sr?" 
09de f5				push af  
09df 3a f3 09			ld a, (.dmark)  
09e2 32 6e fe			ld (debug_mark),a  
09e5 3a f4 09			ld a, (.dmark+1)  
09e8 32 6f fe			ld (debug_mark+1),a  
09eb 3a f5 09			ld a, (.dmark+2)  
09ee 32 70 fe			ld (debug_mark+2),a  
09f1 18 03			jr .pastdmark  
09f3 ..			.dmark: db "sr?"  
09f6 f1			.pastdmark: pop af  
09f7			endm  
# End of macro DMARK
09f7					CALLMONITOR 
09f7 cd a5 18			call break_point_state  
09fa				endm  
# End of macro CALLMONITOR
09fa				endif 
09fa fe 00			cp 0 
09fc ca 9c 0a			jp z, .readdone 
09ff			 
09ff				; last byte is not zero so there is more in the next extent. Load it on the end.	 
09ff			 
09ff 23				inc hl 
0a00			 
0a00 22 7d fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a03			 
0a03 ed 5b 7f fa		ld de, (store_readptr)     ; save the current extent to load 
0a07			 
0a07 eb				ex de, hl 
0a08			 
0a08				; next ext 
0a08			 
0a08 23				inc hl 
0a09 22 7f fa			ld  (store_readptr), hl     ; save the current extent to load 
0a0c			 
0a0c				if DEBUG_STORESE 
0a0c					DMARK "sF2" 
0a0c f5				push af  
0a0d 3a 21 0a			ld a, (.dmark)  
0a10 32 6e fe			ld (debug_mark),a  
0a13 3a 22 0a			ld a, (.dmark+1)  
0a16 32 6f fe			ld (debug_mark+1),a  
0a19 3a 23 0a			ld a, (.dmark+2)  
0a1c 32 70 fe			ld (debug_mark+2),a  
0a1f 18 03			jr .pastdmark  
0a21 ..			.dmark: db "sF2"  
0a24 f1			.pastdmark: pop af  
0a25			endm  
# End of macro DMARK
0a25					CALLMONITOR 
0a25 cd a5 18			call break_point_state  
0a28				endm  
# End of macro CALLMONITOR
0a28				endif 
0a28			 
0a28				; get and load block 
0a28			 
0a28 cd 07 07			call storage_findnextid 
0a2b			 
0a2b				if DEBUG_STORESE 
0a2b					DMARK "sf2" 
0a2b f5				push af  
0a2c 3a 40 0a			ld a, (.dmark)  
0a2f 32 6e fe			ld (debug_mark),a  
0a32 3a 41 0a			ld a, (.dmark+1)  
0a35 32 6f fe			ld (debug_mark+1),a  
0a38 3a 42 0a			ld a, (.dmark+2)  
0a3b 32 70 fe			ld (debug_mark+2),a  
0a3e 18 03			jr .pastdmark  
0a40 ..			.dmark: db "sf2"  
0a43 f1			.pastdmark: pop af  
0a44			endm  
# End of macro DMARK
0a44					CALLMONITOR 
0a44 cd a5 18			call break_point_state  
0a47				endm  
# End of macro CALLMONITOR
0a47				endif 
0a47 cd 27 0f			call ishlzero 
0a4a			;	ld a, l 
0a4a			;	add h 
0a4a			;	cp 0 
0a4a ca 2b 09			jp z,.sr_fail			; block not found so EOF 
0a4d				 
0a4d cd d4 03			call storage_read_block 
0a50			 
0a50				; on a continuation block, we now have the file id and ext in the middle of the block 
0a50				; we need to pull everything back  
0a50			 
0a50 ed 5b 7d fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0a54 2a 7d fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0a57 23				inc hl 
0a58 23				inc hl     ; skip id and ext 
0a59 01 40 00			ld bc, STORE_BLOCK_PHY 
0a5c				if DEBUG_STORESE 
0a5c					DMARK "SR<" 
0a5c f5				push af  
0a5d 3a 71 0a			ld a, (.dmark)  
0a60 32 6e fe			ld (debug_mark),a  
0a63 3a 72 0a			ld a, (.dmark+1)  
0a66 32 6f fe			ld (debug_mark+1),a  
0a69 3a 73 0a			ld a, (.dmark+2)  
0a6c 32 70 fe			ld (debug_mark+2),a  
0a6f 18 03			jr .pastdmark  
0a71 ..			.dmark: db "SR<"  
0a74 f1			.pastdmark: pop af  
0a75			endm  
# End of macro DMARK
0a75					CALLMONITOR 
0a75 cd a5 18			call break_point_state  
0a78				endm  
# End of macro CALLMONITOR
0a78				endif 
0a78 ed b0			ldir     ; copy data 
0a7a			 
0a7a				; move the pointer back and pretend we have a full buffer for next recheck 
0a7a			 
0a7a 1b				dec de 
0a7b 1b				dec de 
0a7c			 
0a7c			; TODO do pop below now short circuit loop????? 
0a7c c1				pop bc     ; get rid of spare de on stack 
0a7d				if DEBUG_STORESE 
0a7d					DMARK "SR>" 
0a7d f5				push af  
0a7e 3a 92 0a			ld a, (.dmark)  
0a81 32 6e fe			ld (debug_mark),a  
0a84 3a 93 0a			ld a, (.dmark+1)  
0a87 32 6f fe			ld (debug_mark+1),a  
0a8a 3a 94 0a			ld a, (.dmark+2)  
0a8d 32 70 fe			ld (debug_mark+2),a  
0a90 18 03			jr .pastdmark  
0a92 ..			.dmark: db "SR>"  
0a95 f1			.pastdmark: pop af  
0a96			endm  
# End of macro DMARK
0a96					CALLMONITOR 
0a96 cd a5 18			call break_point_state  
0a99				endm  
# End of macro CALLMONITOR
0a99				endif 
0a99 c3 30 09			jp .srext 
0a9c			 
0a9c			 
0a9c			 
0a9c			 
0a9c			 
0a9c			.readdone:		 
0a9c e1				pop hl 		 ; return start of data to show as not EOF 
0a9d 23				inc hl   ; past file id 
0a9e 23				inc hl   ; past ext 
0a9f				if DEBUG_STORESE 
0a9f					DMARK "SRe" 
0a9f f5				push af  
0aa0 3a b4 0a			ld a, (.dmark)  
0aa3 32 6e fe			ld (debug_mark),a  
0aa6 3a b5 0a			ld a, (.dmark+1)  
0aa9 32 6f fe			ld (debug_mark+1),a  
0aac 3a b6 0a			ld a, (.dmark+2)  
0aaf 32 70 fe			ld (debug_mark+2),a  
0ab2 18 03			jr .pastdmark  
0ab4 ..			.dmark: db "SRe"  
0ab7 f1			.pastdmark: pop af  
0ab8			endm  
# End of macro DMARK
0ab8					CALLMONITOR 
0ab8 cd a5 18			call break_point_state  
0abb				endm  
# End of macro CALLMONITOR
0abb				endif 
0abb c9					ret 
0abc			 
0abc			 
0abc			 
0abc			; 
0abc			; Append File 
0abc			; 
0abc			; hl - file id to locate 
0abc			; de - pointer to (multi block) string to write 
0abc			 
0abc			.sa_notfound: 
0abc d1				pop de 
0abd c9				ret 
0abe			 
0abe			 
0abe			storage_append: 
0abe				; hl -  file id to append to 
0abe				; de - string to append 
0abe			 
0abe d5				push de 
0abf				 
0abf				if DEBUG_STORESE 
0abf					DMARK "AP1" 
0abf f5				push af  
0ac0 3a d4 0a			ld a, (.dmark)  
0ac3 32 6e fe			ld (debug_mark),a  
0ac6 3a d5 0a			ld a, (.dmark+1)  
0ac9 32 6f fe			ld (debug_mark+1),a  
0acc 3a d6 0a			ld a, (.dmark+2)  
0acf 32 70 fe			ld (debug_mark+2),a  
0ad2 18 03			jr .pastdmark  
0ad4 ..			.dmark: db "AP1"  
0ad7 f1			.pastdmark: pop af  
0ad8			endm  
# End of macro DMARK
0ad8					CALLMONITOR 
0ad8 cd a5 18			call break_point_state  
0adb				endm  
# End of macro CALLMONITOR
0adb				endif 
0adb			 
0adb 7d				ld a, l 
0adc 32 75 fa			ld (store_tmpid), a 
0adf			 
0adf				; get file header  
0adf			 
0adf 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0ae1 3a 75 fa			ld a, (store_tmpid) 
0ae4 5f				ld e, a 
0ae5			 
0ae5 21 40 00				ld hl, STORE_BLOCK_PHY 
0ae8 cd 07 07				call storage_findnextid 
0aeb			 
0aeb cd 27 0f			call ishlzero 
0aee 28 cc			jr z, .sa_notfound 
0af0			 
0af0 22 6e fa			ld (store_tmppageid), hl 
0af3			 
0af3				; TODO handle file id not found 
0af3			 
0af3				if DEBUG_STORESE 
0af3					DMARK "AP2" 
0af3 f5				push af  
0af4 3a 08 0b			ld a, (.dmark)  
0af7 32 6e fe			ld (debug_mark),a  
0afa 3a 09 0b			ld a, (.dmark+1)  
0afd 32 6f fe			ld (debug_mark+1),a  
0b00 3a 0a 0b			ld a, (.dmark+2)  
0b03 32 70 fe			ld (debug_mark+2),a  
0b06 18 03			jr .pastdmark  
0b08 ..			.dmark: db "AP2"  
0b0b f1			.pastdmark: pop af  
0b0c			endm  
# End of macro DMARK
0b0c					CALLMONITOR 
0b0c cd a5 18			call break_point_state  
0b0f				endm  
# End of macro CALLMONITOR
0b0f				endif 
0b0f			 
0b0f				; update file extent count 
0b0f			 
0b0f 11 81 fa			ld de, store_page 
0b12			 
0b12 cd d4 03			call storage_read_block 
0b15			 
0b15				if DEBUG_STORESE 
0b15					DMARK "AP3" 
0b15 f5				push af  
0b16 3a 2a 0b			ld a, (.dmark)  
0b19 32 6e fe			ld (debug_mark),a  
0b1c 3a 2b 0b			ld a, (.dmark+1)  
0b1f 32 6f fe			ld (debug_mark+1),a  
0b22 3a 2c 0b			ld a, (.dmark+2)  
0b25 32 70 fe			ld (debug_mark+2),a  
0b28 18 03			jr .pastdmark  
0b2a ..			.dmark: db "AP3"  
0b2d f1			.pastdmark: pop af  
0b2e			endm  
# End of macro DMARK
0b2e					CALLMONITOR 
0b2e cd a5 18			call break_point_state  
0b31				endm  
# End of macro CALLMONITOR
0b31				endif 
0b31			;	ld (store_tmppageid), hl 
0b31			 
0b31 3a 83 fa			ld a, (store_page+2) 
0b34 3c				inc a 
0b35 32 83 fa			ld (store_page+2), a 
0b38 32 74 fa			ld (store_tmpext), a 
0b3b				 
0b3b				if DEBUG_STORESE 
0b3b					DMARK "AP3" 
0b3b f5				push af  
0b3c 3a 50 0b			ld a, (.dmark)  
0b3f 32 6e fe			ld (debug_mark),a  
0b42 3a 51 0b			ld a, (.dmark+1)  
0b45 32 6f fe			ld (debug_mark+1),a  
0b48 3a 52 0b			ld a, (.dmark+2)  
0b4b 32 70 fe			ld (debug_mark+2),a  
0b4e 18 03			jr .pastdmark  
0b50 ..			.dmark: db "AP3"  
0b53 f1			.pastdmark: pop af  
0b54			endm  
# End of macro DMARK
0b54					CALLMONITOR 
0b54 cd a5 18			call break_point_state  
0b57				endm  
# End of macro CALLMONITOR
0b57				endif 
0b57 2a 6e fa			ld hl, (store_tmppageid) 
0b5a 11 81 fa			ld de, store_page 
0b5d cd 39 04			call storage_write_block 
0b60			 
0b60				; find free block 
0b60			 
0b60 11 00 00			ld de, 0			 ; file extent to locate 
0b63			 
0b63 21 40 00				ld hl, STORE_BLOCK_PHY 
0b66 cd 07 07				call storage_findnextid 
0b69 cd 27 0f			call ishlzero 
0b6c ca bc 0a			jp z, .sa_notfound 
0b6f			 
0b6f					; TODO handle no space left 
0b6f					 
0b6f 22 6e fa				ld (store_tmppageid), hl 
0b72			 
0b72				if DEBUG_STORESE 
0b72					DMARK "AP4" 
0b72 f5				push af  
0b73 3a 87 0b			ld a, (.dmark)  
0b76 32 6e fe			ld (debug_mark),a  
0b79 3a 88 0b			ld a, (.dmark+1)  
0b7c 32 6f fe			ld (debug_mark+1),a  
0b7f 3a 89 0b			ld a, (.dmark+2)  
0b82 32 70 fe			ld (debug_mark+2),a  
0b85 18 03			jr .pastdmark  
0b87 ..			.dmark: db "AP4"  
0b8a f1			.pastdmark: pop af  
0b8b			endm  
# End of macro DMARK
0b8b					CALLMONITOR 
0b8b cd a5 18			call break_point_state  
0b8e				endm  
# End of macro CALLMONITOR
0b8e				endif 
0b8e					; init the buffer with zeros so we can id if the buffer is full or not 
0b8e			 
0b8e e5					push hl 
0b8f c5					push bc 
0b90			 
0b90 21 81 fa				ld hl, store_page 
0b93 06 40				ld b, STORE_BLOCK_PHY 
0b95 3e 00				ld a, 0 
0b97 77			.zeroblock:	ld (hl), a 
0b98 23					inc hl 
0b99 10 fc				djnz .zeroblock 
0b9b			 
0b9b c1					pop bc 
0b9c e1					pop hl 
0b9d			 
0b9d					; construct block 
0b9d			 
0b9d 3a 75 fa				ld a, (store_tmpid) 
0ba0 32 81 fa				ld (store_page), a   ; file id 
0ba3 3a 74 fa				ld a, (store_tmpext)   ; extent for this block 
0ba6 32 82 fa				ld (store_page+1), a 
0ba9			 
0ba9 e1					pop hl    ; get string to write 
0baa 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bac 11 83 fa				ld de, store_page+2 
0baf			 
0baf				if DEBUG_STORESE 
0baf					DMARK "AP5" 
0baf f5				push af  
0bb0 3a c4 0b			ld a, (.dmark)  
0bb3 32 6e fe			ld (debug_mark),a  
0bb6 3a c5 0b			ld a, (.dmark+1)  
0bb9 32 6f fe			ld (debug_mark+1),a  
0bbc 3a c6 0b			ld a, (.dmark+2)  
0bbf 32 70 fe			ld (debug_mark+2),a  
0bc2 18 03			jr .pastdmark  
0bc4 ..			.dmark: db "AP5"  
0bc7 f1			.pastdmark: pop af  
0bc8			endm  
# End of macro DMARK
0bc8					CALLMONITOR 
0bc8 cd a5 18			call break_point_state  
0bcb				endm  
# End of macro CALLMONITOR
0bcb				endif 
0bcb			 
0bcb			 
0bcb			 
0bcb					; fill buffer with data until end of string or full block 
0bcb			 
0bcb 7e			.appd:		ld a, (hl) 
0bcc 12					ld (de), a 
0bcd fe 00				cp 0 
0bcf 28 04				jr z, .appdone 
0bd1 23					inc hl 
0bd2 13					inc de 
0bd3 10 f6				djnz .appd 
0bd5			 
0bd5 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0bd6 f5					push af   		; save last byte dumped 
0bd7			 
0bd7			 
0bd7 2a 6e fa			ld hl, (store_tmppageid) 
0bda 11 81 fa			ld de, store_page 
0bdd				if DEBUG_STORESE 
0bdd					DMARK "AP6" 
0bdd f5				push af  
0bde 3a f2 0b			ld a, (.dmark)  
0be1 32 6e fe			ld (debug_mark),a  
0be4 3a f3 0b			ld a, (.dmark+1)  
0be7 32 6f fe			ld (debug_mark+1),a  
0bea 3a f4 0b			ld a, (.dmark+2)  
0bed 32 70 fe			ld (debug_mark+2),a  
0bf0 18 03			jr .pastdmark  
0bf2 ..			.dmark: db "AP6"  
0bf5 f1			.pastdmark: pop af  
0bf6			endm  
# End of macro DMARK
0bf6					CALLMONITOR 
0bf6 cd a5 18			call break_point_state  
0bf9				endm  
# End of macro CALLMONITOR
0bf9				endif 
0bf9 cd 39 04				call storage_write_block 
0bfc			 
0bfc			 
0bfc				; was that a full block of data written? 
0bfc				; any more to write out? 
0bfc			 
0bfc				; if yes then set vars and jump to start of function again 
0bfc			 
0bfc f1					pop af 
0bfd d1					pop de 
0bfe			 
0bfe fe 00				cp 0		 ; no, string was fully written 
0c00 c8					ret z 
0c01			 
0c01					; setup vars for next cycle 
0c01			 
0c01 3a 75 fa				ld a, (store_tmpid) 
0c04 6f					ld l, a 
0c05 26 00				ld h, 0 
0c07			 
0c07 c3 be 0a			 	jp storage_append	 ; yes, need to write out some more 
0c0a			 
0c0a			 
0c0a			 
0c0a			 
0c0a			 
0c0a			 
0c0a			 
0c0a			if DEBUG_STORECF 
0c0a			storageput:	 
0c0a					ret 
0c0a			storageread: 
0c0a					ld hl, store_page 
0c0a					ld b, 200 
0c0a					ld a,0 
0c0a			.src:		ld (hl),a 
0c0a					inc hl 
0c0a					djnz .src 
0c0a					 
0c0a			 
0c0a					ld de, 0 
0c0a					ld bc, 1 
0c0a					ld hl, store_page 
0c0a					call cfRead 
0c0a			 
0c0a				call cfGetError 
0c0a				ld hl,scratch 
0c0a				call hexout 
0c0a				ld hl, scratch+2 
0c0a				ld a, 0 
0c0a				ld (hl),a 
0c0a				ld de, scratch 
0c0a				ld a,display_row_1 
0c0a				call str_at_display 
0c0a				call update_display 
0c0a			 
0c0a					ld hl, store_page 
0c0a					ld (os_cur_ptr),hl 
0c0a			 
0c0a					ret 
0c0a			endif 
0c0a			 
0c0a			 
0c0a			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c0a			 
0c0a			storage_clear_page: 
0c0a e5				push hl 
0c0b d5				push de 
0c0c c5				push bc 
0c0d 21 81 fa			ld hl, store_page 
0c10 3e 00			ld a, 0 
0c12 77				ld (hl), a 
0c13			 
0c13 11 82 fa			ld de, store_page+1 
0c16 01 18 01			ld bc, STORE_BLOCK_LOG 
0c19			 
0c19 ed b0			ldir 
0c1b				 
0c1b c1				pop bc 
0c1c d1				pop de 
0c1d e1				pop hl 
0c1e c9				ret 
0c1f			 
0c1f			; eof 
# End of file firmware_storage.asm
0c1f			  
0c1f			; support routines for above hardware abstraction layer  
0c1f			  
0c1f			include "firmware_general.asm"        ; general support functions  
0c1f			 
0c1f			; word look up 
0c1f			 
0c1f			; in 
0c1f			; a is the index 
0c1f			; hl is pointer start of array 
0c1f			; 
0c1f			; returns 
0c1f			; hl to the word 
0c1f			; 
0c1f			 
0c1f			table_lookup:  
0c1f d5					push de 
0c20 eb					ex de, hl 
0c21			 
0c21 6f					ld l, a 
0c22 26 00				ld h, 0 
0c24 29					add hl, hl 
0c25 19					add hl, de 
0c26 7e					ld a, (hl) 
0c27 23					inc hl 
0c28 66					ld h,(hl) 
0c29 6f					ld l, a 
0c2a			 
0c2a d1					pop de 
0c2b c9					ret 
0c2c			 
0c2c			; Delay loops 
0c2c			 
0c2c			 
0c2c			 
0c2c			aDelayInMS: 
0c2c c5				push bc 
0c2d 47				ld b,a 
0c2e			msdelay: 
0c2e c5				push bc 
0c2f				 
0c2f			 
0c2f 01 41 00			ld bc,041h 
0c32 cd 4a 0c			call delayloop 
0c35 c1				pop bc 
0c36 05				dec b 
0c37 20 f5			jr nz,msdelay 
0c39			 
0c39			;if CPU_CLOCK_8MHZ 
0c39			;msdelay8: 
0c39			;	push bc 
0c39			;	 
0c39			; 
0c39			;	ld bc,041h 
0c39			;	call delayloop 
0c39			;	pop bc 
0c39			;	dec b 
0c39			;	jr nz,msdelay8 
0c39			;endif 
0c39			 
0c39			 
0c39 c1				pop bc 
0c3a c9				ret 
0c3b			 
0c3b			 
0c3b			delay250ms: 
0c3b				;push de 
0c3b 01 00 40			ld bc, 04000h 
0c3e c3 4a 0c			jp delayloop 
0c41			delay500ms: 
0c41				;push de 
0c41 01 00 80			ld bc, 08000h 
0c44 c3 4a 0c			jp delayloop 
0c47			delay1s: 
0c47				;push bc 
0c47			   ; Clobbers A, d and e 
0c47 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c4a			delayloop: 
0c4a c5			    push bc 
0c4b			 
0c4b			if BASE_CPM 
0c4b				ld bc, CPM_DELAY_TUNE 
0c4b			.cpmloop: 
0c4b				push bc 
0c4b			 
0c4b			endif 
0c4b			 
0c4b			 
0c4b			 
0c4b			delayloopi: 
0c4b			;	push bc 
0c4b			;.dl: 
0c4b cb 47		    bit     0,a    	; 8 
0c4d cb 47		    bit     0,a    	; 8 
0c4f cb 47		    bit     0,a    	; 8 
0c51 e6 ff		    and     255  	; 7 
0c53 0b			    dec     bc      	; 6 
0c54 79			    ld      a,c     	; 4 
0c55 b0			    or      b     	; 4 
0c56 c2 4b 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0c59			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0c59				;pop de 
0c59			;pop bc 
0c59			 
0c59			if BASE_CPM 
0c59				pop bc 
0c59				 
0c59			    dec     bc      	; 6 
0c59			    ld      a,c     	; 4 
0c59			    or      b     	; 4 
0c59			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0c59				 
0c59			 
0c59			endif 
0c59			;if CPU_CLOCK_8MHZ 
0c59			;    pop bc 
0c59			;    push bc 
0c59			;.dl8: 
0c59			;    bit     0,a    	; 8 
0c59			;    bit     0,a    	; 8 
0c59			;    bit     0,a    	; 8 
0c59			;    and     255  	; 7 
0c59			;    dec     bc      	; 6 
0c59			;    ld      a,c     	; 4 
0c59			;    or      b     	; 4 
0c59			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c59			;endif 
0c59			 
0c59			;if CPU_CLOCK_10MHZ 
0c59			;    pop bc 
0c59			;    push bc 
0c59			;.dl8: 
0c59			;    bit     0,a    	; 8 
0c59			;    bit     0,a    	; 8 
0c59			;    bit     0,a    	; 8 
0c59			;    and     255  	; 7 
0c59			;    dec     bc      	; 6 
0c59			;    ld      a,c     	; 4 
0c59			;    or      b     	; 4 
0c59			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c59			;endif 
0c59 c1			    pop bc 
0c5a			 
0c5a c9				ret 
0c5b			 
0c5b			 
0c5b			 
0c5b			; eof 
# End of file firmware_general.asm
0c5b			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0c5b			; display routines that use the physical hardware abstraction layer 
0c5b			 
0c5b			 
0c5b			; information window 
0c5b			 
0c5b			; pass hl with 1st string to display 
0c5b			; pass de with 2nd string to display 
0c5b			 
0c5b			info_panel: 
0c5b e5				push hl 
0c5c			 
0c5c 2a cf fb			ld hl, (display_fb_active) 
0c5f e5				push hl    ; future de destination 
0c60 21 b4 fd				ld hl, display_fb0 
0c63 22 cf fb				ld (display_fb_active), hl 
0c66			 
0c66			;	call clear_display 
0c66			 
0c66				if BASE_CPM 
0c66				ld a, '.' 
0c66				else 
0c66 3e a5			ld a, 165 
0c68				endif 
0c68 cd cf 0c			call fill_display 
0c6b			 
0c6b			 
0c6b 3e 55			ld a, display_row_3 + 5 
0c6d cd dd 0c			call str_at_display 
0c70			 
0c70 e1				pop hl 
0c71 d1				pop de 
0c72			 
0c72 e5				push hl 
0c73			 
0c73			 
0c73 3e 2d			ld a, display_row_2 + 5 
0c75 cd dd 0c			call str_at_display 
0c78			 
0c78			 
0c78 cd ed 0c			call update_display 
0c7b cd 91 1e			call next_page_prompt 
0c7e cd ca 0c			call clear_display 
0c81			 
0c81				 
0c81 21 13 fd				ld hl, display_fb1 
0c84 22 cf fb				ld (display_fb_active), hl 
0c87 cd ed 0c			call update_display 
0c8a			 
0c8a e1				pop hl 
0c8b			 
0c8b c9				ret 
0c8c			 
0c8c			 
0c8c			 
0c8c			 
0c8c			; TODO windowing? 
0c8c			 
0c8c			; TODO scroll line up 
0c8c			 
0c8c			scroll_up: 
0c8c			 
0c8c e5				push hl 
0c8d d5				push de 
0c8e c5				push bc 
0c8f			 
0c8f				; get frame buffer  
0c8f			 
0c8f 2a cf fb			ld hl, (display_fb_active) 
0c92 e5				push hl    ; future de destination 
0c93			 
0c93 11 28 00			ld  de, display_cols 
0c96 19				add hl, de 
0c97			 
0c97 d1				pop de 
0c98			 
0c98				;ex de, hl 
0c98 01 9f 00			ld bc, display_fb_len -1  
0c9b			;if DEBUG_FORTH_WORDS 
0c9b			;	DMARK "SCL" 
0c9b			;	CALLMONITOR 
0c9b			;endif	 
0c9b ed b0			ldir 
0c9d			 
0c9d				; wipe bottom row 
0c9d			 
0c9d			 
0c9d 2a cf fb			ld hl, (display_fb_active) 
0ca0 11 a0 00			ld de, display_cols*display_rows 
0ca3 19				add hl, de 
0ca4 06 28			ld b, display_cols 
0ca6 3e 20			ld a, ' ' 
0ca8			.scwipe: 
0ca8 77				ld (hl), a 
0ca9 2b				dec hl 
0caa 10 fc			djnz .scwipe 
0cac			 
0cac				;pop hl 
0cac			 
0cac c1				pop bc 
0cad d1				pop de 
0cae e1				pop hl 
0caf			 
0caf c9				ret 
0cb0			 
0cb0			 
0cb0			;scroll_upo: 
0cb0			;	ld de, display_row_1 
0cb0			 ;	ld hl, display_row_2 
0cb0			;	ld bc, display_cols 
0cb0			;	ldir 
0cb0			;	ld de, display_row_2 
0cb0			 ;	ld hl, display_row_3 
0cb0			;	ld bc, display_cols 
0cb0			;	ldir 
0cb0			;	ld de, display_row_3 
0cb0			 ;	ld hl, display_row_4 
0cb0			;	ld bc, display_cols 
0cb0			;	ldir 
0cb0			 
0cb0			; TODO clear row 4 
0cb0			 
0cb0			;	ret 
0cb0			 
0cb0				 
0cb0			scroll_down: 
0cb0			 
0cb0 e5				push hl 
0cb1 d5				push de 
0cb2 c5				push bc 
0cb3			 
0cb3				; get frame buffer  
0cb3			 
0cb3 2a cf fb			ld hl, (display_fb_active) 
0cb6			 
0cb6 11 9f 00			ld de, display_fb_len - 1 
0cb9 19				add hl, de 
0cba			 
0cba e5			push hl    ; future de destination 
0cbb			 
0cbb 11 28 00			ld  de, display_cols 
0cbe ed 52			sbc hl, de 
0cc0			 
0cc0			 
0cc0 d1				pop de 
0cc1			 
0cc1			;	ex de, hl 
0cc1 01 9f 00			ld bc, display_fb_len -1  
0cc4			 
0cc4			 
0cc4				 
0cc4			 
0cc4 ed b0			ldir 
0cc6			 
0cc6				; wipe bottom row 
0cc6			 
0cc6			 
0cc6			;	ld hl, (display_fb_active) 
0cc6			;;	ld de, display_cols*display_rows 
0cc6			;;	add hl, de 
0cc6			;	ld b, display_cols 
0cc6			;	ld a, ' ' 
0cc6			;.scwiped: 
0cc6			;	ld (hl), a 
0cc6			;	dec hl 
0cc6			;	djnz .scwiped 
0cc6			 
0cc6				;pop hl 
0cc6			 
0cc6 c1				pop bc 
0cc7 d1				pop de 
0cc8 e1				pop hl 
0cc9			 
0cc9 c9				ret 
0cca			;scroll_down: 
0cca			;	ld de, display_row_4 
0cca			;	ld hl, display_row_3 
0cca			;	ld bc, display_cols 
0cca			;	ldir 
0cca			;	ld de, display_row_3 
0cca			; 	ld hl, display_row_2 
0cca			;	ld bc, display_cols 
0cca			;	ldir 
0cca			;	ld de, display_row_2 
0cca			;	ld hl, display_row_1 
0cca			;	ld bc, display_cols 
0cca			;	ldir 
0cca			;;; TODO clear row 1 
0cca			;	ret 
0cca			 
0cca			 
0cca			 
0cca			 
0cca			 
0cca			; clear active frame buffer 
0cca			 
0cca			clear_display: 
0cca 3e 20			ld a, ' ' 
0ccc c3 cf 0c			jp fill_display 
0ccf			 
0ccf			; fill active frame buffer with a char in A 
0ccf			 
0ccf			fill_display: 
0ccf 06 a0			ld b,display_fb_len 
0cd1 2a cf fb			ld hl, (display_fb_active) 
0cd4 77			.fd1:	ld (hl),a 
0cd5 23				inc hl 
0cd6 10 fc			djnz .fd1 
0cd8 23				inc hl 
0cd9 3e 00			ld a,0 
0cdb 77				ld (hl),a 
0cdc			 
0cdc			 
0cdc c9				ret 
0cdd			; Write string (DE) at pos (A) to active frame buffer 
0cdd			 
0cdd 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0ce0 06 00					ld b,0 
0ce2 4f					ld c,a 
0ce3 09					add hl,bc 
0ce4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ce5 b7			            OR   A              ;Null terminator? 
0ce6 c8			            RET  Z              ;Yes, so finished 
0ce7 77					ld (hl),a 
0ce8 23				inc hl 
0ce9 13			            INC  DE             ;Point to next character 
0cea 18 f8		            JR   .sad1     ;Repeat 
0cec c9					ret 
0ced			 
0ced			; using current frame buffer write to physical display 
0ced			 
0ced			update_display: 
0ced e5				push hl 
0cee 2a cf fb			ld hl, (display_fb_active) 
0cf1 cd e2 69			call write_display 
0cf4 e1				pop hl 
0cf5 c9				ret 
0cf6			 
0cf6			; TODO scrolling 
0cf6			 
0cf6			 
0cf6			; move cursor right one char 
0cf6			cursor_right: 
0cf6			 
0cf6				; TODO shift right 
0cf6				; TODO if beyond max col 
0cf6				; TODO       cursor_next_line 
0cf6			 
0cf6 c9				ret 
0cf7			 
0cf7			 
0cf7			cursor_next_line: 
0cf7				; TODO first char 
0cf7				; TODO line down 
0cf7				; TODO if past last row 
0cf7				; TODO    scroll up 
0cf7			 
0cf7 c9				ret 
0cf8			 
0cf8			cursor_left: 
0cf8				; TODO shift left 
0cf8				; TODO if beyond left  
0cf8				; TODO     cursor prev line 
0cf8				 
0cf8 c9				ret 
0cf9			 
0cf9			cursor_prev_line: 
0cf9				; TODO last char 
0cf9				; TODO line up 
0cf9				; TODO if past first row 
0cf9				; TODO   scroll down 
0cf9			 
0cf9 c9				ret 
0cfa			 
0cfa			 
0cfa			cout: 
0cfa				; A - char 
0cfa c9				ret 
0cfb			 
0cfb			 
0cfb			; Display a menu and allow item selection (optional toggle items) 
0cfb			; 
0cfb			; format: 
0cfb			; hl pointer to word array with zero term for items 
0cfb			; e.g.    db item1 
0cfb			;         db .... 
0cfb			;         db 0 
0cfb			; 
0cfb			; a = starting menu item  
0cfb			; 
0cfb			; de = pointer item toggle array   (todo) 
0cfb			; 
0cfb			; returns item selected in a 1-... 
0cfb			; returns 0 if back button pressed 
0cfb			; 
0cfb			; NOTE: Uses system frame buffer to display 
0cfb			; 
0cfb			; LEFT, Q = go back 
0cfb			; RIGHT, SPACE, CR = select 
0cfb			; UP, A - Up 
0cfb			; DOWN, Z - Down 
0cfb			 
0cfb			 
0cfb			 
0cfb			 
0cfb			 
0cfb			menu: 
0cfb			 
0cfb					; keep array pointer 
0cfb			 
0cfb 22 7a fa				ld (store_tmp1), hl 
0cfe 32 78 fa				ld (store_tmp2), a 
0d01			 
0d01					; check for key bounce 
0d01			 
0d01			if BASE_KEV 
0d01			 
0d01 cd 2d 6d		.mbounce:	call cin 
0d04 fe 00				cp 0 
0d06 20 f9				jr nz, .mbounce 
0d08			endif 
0d08					; for ease use ex 
0d08			 
0d08					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d08 21 b4 fd				ld hl, display_fb0 
0d0b 22 cf fb				ld (display_fb_active), hl 
0d0e			 
0d0e cd ca 0c		.mloop:		call clear_display 
0d11 cd ed 0c				call update_display 
0d14			 
0d14					; draw selection id '>' at 1 
0d14			 
0d14					; init start of list display 
0d14			 
0d14 3e 05				ld a, 5 
0d16 32 76 fa				ld (store_tmp3), a   ; display row count 
0d19 3a 78 fa				ld a,( store_tmp2) 
0d1c 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d1f			 
0d1f					 
0d1f			.mitem:	 
0d1f			 
0d1f			 
0d1f 3a 79 fa				ld a,(store_tmp2+1) 
0d22 6f					ld l, a 
0d23 26 00				ld h, 0 
0d25 29					add hl, hl 
0d26 ed 5b 7a fa			ld de, (store_tmp1) 
0d2a 19					add hl, de 
0d2b 7e					ld a, (hl) 
0d2c 23					inc hl 
0d2d 66					ld h,(hl) 
0d2e 6f					ld l, a 
0d2f			 
0d2f cd 27 0f				call ishlzero 
0d32 28 1a				jr z, .mdone 
0d34			 
0d34 eb					ex de, hl 
0d35 3a 76 fa				ld a, (store_tmp3) 
0d38 cd dd 0c				call str_at_display 
0d3b					 
0d3b			 
0d3b					; next item 
0d3b 3a 79 fa				ld a, (store_tmp2+1) 
0d3e 3c					inc a 
0d3f 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d42			 
0d42			 		; next row 
0d42			 
0d42 3a 76 fa				ld a, (store_tmp3) 
0d45 c6 28				add display_cols 
0d47 32 76 fa				ld (store_tmp3), a 
0d4a			 
0d4a					; at end of screen? 
0d4a			 
0d4a fe 10				cp display_rows*4 
0d4c 20 d1				jr nz, .mitem 
0d4e			 
0d4e			 
0d4e			.mdone: 
0d4e cd 27 0f				call ishlzero 
0d51 28 08				jr z, .nodn 
0d53			 
0d53 3e 78				ld a, display_row_4 
0d55 11 d4 0d				ld de, .mdown 
0d58 cd dd 0c				call str_at_display 
0d5b			 
0d5b					; draw options to fill the screens with active item on line 1 
0d5b					; if current option is 2 or more then display ^ in top 
0d5b			 
0d5b 3a 78 fa		.nodn:		ld a, (store_tmp2) 
0d5e fe 00				cp 0 
0d60 28 08				jr z, .noup 
0d62			 
0d62 3e 00				ld a, 0 
0d64 11 d2 0d				ld de, .mup 
0d67 cd dd 0c				call str_at_display 
0d6a			 
0d6a 3e 02		.noup:		ld a, 2 
0d6c 11 d0 0d				ld de, .msel 
0d6f cd dd 0c				call str_at_display 
0d72			 
0d72					; if current option + 1 is not null then display V in bottom 
0d72					; get key 
0d72 cd ed 0c				call update_display 
0d75			 
0d75			 
0d75					; handle key 
0d75			 
0d75 cd 1c 6d				call cin_wait 
0d78			 
0d78 fe 05				cp KEY_UP 
0d7a 28 2b				jr z, .mgoup 
0d7c fe 61				cp 'a' 
0d7e 28 27				jr z, .mgoup 
0d80 fe 0a				cp KEY_DOWN 
0d82 28 32				jr z, .mgod 
0d84 fe 7a				cp 'z' 
0d86 28 2e				jr z, .mgod 
0d88 fe 20				cp ' ' 
0d8a 28 34				jr z, .goend 
0d8c fe 0c				cp KEY_RIGHT 
0d8e 28 30				jr z, .goend 
0d90 fe 0d				cp KEY_CR 
0d92 28 2c				jr z, .goend 
0d94 fe 71				cp 'q' 
0d96 28 0b				jr z, .goback 
0d98			 
0d98 fe 0b				cp KEY_LEFT 
0d9a 28 07				jr z, .goback 
0d9c fe 08				cp KEY_BS 
0d9e 28 03				jr z, .goback 
0da0 c3 0e 0d				jp .mloop 
0da3			 
0da3			.goback: 
0da3 3e 00			ld a, 0 
0da5 18 1d			jr .goend2 
0da7			 
0da7				; move up one 
0da7			.mgoup: 
0da7 3a 78 fa				ld a, (store_tmp2) 
0daa fe 00				cp 0 
0dac ca 0e 0d				jp z, .mloop 
0daf 3d					dec a 
0db0 32 78 fa				ld (store_tmp2), a 
0db3 c3 0e 0d				jp .mloop 
0db6			 
0db6				; move down one 
0db6			.mgod: 
0db6 3a 78 fa				ld a, (store_tmp2) 
0db9 3c					inc a 
0dba 32 78 fa				ld (store_tmp2), a 
0dbd c3 0e 0d				jp .mloop 
0dc0			 
0dc0			 
0dc0			.goend: 
0dc0					; get selected item number 
0dc0			 
0dc0 3a 78 fa				ld a, (store_tmp2) 
0dc3 3c					inc a 
0dc4			 
0dc4			.goend2: 
0dc4 f5					push af 
0dc5			 
0dc5					; restore active fb 
0dc5					; TODO BUG assumes fb1 
0dc5			 
0dc5 21 13 fd				ld hl, display_fb1 
0dc8 22 cf fb				ld (display_fb_active), hl 
0dcb			 
0dcb					; restore main regs 
0dcb			 
0dcb			 
0dcb cd ed 0c				call update_display 
0dce			 
0dce f1					pop af 
0dcf			 
0dcf c9				ret 
0dd0			 
0dd0 .. 00		.msel:   db ">",0 
0dd2 .. 00		.mup:   db "^",0 
0dd4 .. 00		.mdown:   db "v",0 
0dd6			 
0dd6			 
0dd6			; eof 
0dd6			 
# End of file firmware_display.asm
0dd6			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0dd6			; random number generators 
0dd6			 
0dd6			 
0dd6			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0dd6			 
0dd6			 
0dd6			;-----> Generate a random number 
0dd6			; output a=answer 0<=a<=255 
0dd6			; all registers are preserved except: af 
0dd6			random: 
0dd6 e5			        push    hl 
0dd7 d5			        push    de 
0dd8 2a b1 fb		        ld      hl,(randData) 
0ddb ed 5f		        ld      a,r 
0ddd 57			        ld      d,a 
0dde 5e			        ld      e,(hl) 
0ddf 19			        add     hl,de 
0de0 85			        add     a,l 
0de1 ac			        xor     h 
0de2 22 b1 fb		        ld      (randData),hl 
0de5 d1			        pop     de 
0de6 e1			        pop     hl 
0de7 c9			        ret 
0de8			 
0de8			 
0de8			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0de8			 
0de8			 
0de8			 
0de8			;------LFSR------ 
0de8			;James Montelongo 
0de8			;optimized by Spencer Putt 
0de8			;out: 
0de8			; a = 8 bit random number 
0de8			RandLFSR: 
0de8 21 b7 fb		        ld hl,LFSRSeed+4 
0deb 5e			        ld e,(hl) 
0dec 23			        inc hl 
0ded 56			        ld d,(hl) 
0dee 23			        inc hl 
0def 4e			        ld c,(hl) 
0df0 23			        inc hl 
0df1 7e			        ld a,(hl) 
0df2 47			        ld b,a 
0df3 cb 13		        rl e  
0df5 cb 12			rl d 
0df7 cb 11		        rl c  
0df9 17				rla 
0dfa cb 13		        rl e  
0dfc cb 12			rl d 
0dfe cb 11		        rl c  
0e00 17				rla 
0e01 cb 13		        rl e  
0e03 cb 12			rl d 
0e05 cb 11		        rl c  
0e07 17				rla 
0e08 67			        ld h,a 
0e09 cb 13		        rl e  
0e0b cb 12			rl d 
0e0d cb 11		        rl c  
0e0f 17				rla 
0e10 a8			        xor b 
0e11 cb 13		        rl e  
0e13 cb 12			rl d 
0e15 ac			        xor h 
0e16 a9			        xor c 
0e17 aa			        xor d 
0e18 21 b9 fb		        ld hl,LFSRSeed+6 
0e1b 11 ba fb		        ld de,LFSRSeed+7 
0e1e 01 07 00		        ld bc,7 
0e21 ed b8		        lddr 
0e23 12			        ld (de),a 
0e24 c9			        ret 
0e25			 
0e25			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e25			 
0e25			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e25			 
0e25			 
0e25			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e25			 
0e25			prng16: 
0e25			;Inputs: 
0e25			;   (seed1) contains a 16-bit seed value 
0e25			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e25			;Outputs: 
0e25			;   HL is the result 
0e25			;   BC is the result of the LCG, so not that great of quality 
0e25			;   DE is preserved 
0e25			;Destroys: 
0e25			;   AF 
0e25			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e25			;160cc 
0e25			;26 bytes 
0e25 2a ab fb		    ld hl,(seed1) 
0e28 44			    ld b,h 
0e29 4d			    ld c,l 
0e2a 29			    add hl,hl 
0e2b 29			    add hl,hl 
0e2c 2c			    inc l 
0e2d 09			    add hl,bc 
0e2e 22 ab fb		    ld (seed1),hl 
0e31 2a a9 fb		    ld hl,(seed2) 
0e34 29			    add hl,hl 
0e35 9f			    sbc a,a 
0e36 e6 2d		    and %00101101 
0e38 ad			    xor l 
0e39 6f			    ld l,a 
0e3a 22 a9 fb		    ld (seed2),hl 
0e3d 09			    add hl,bc 
0e3e c9			    ret 
0e3f			 
0e3f			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e3f			 
0e3f			rand32: 
0e3f			;Inputs: 
0e3f			;   (seed1_0) holds the lower 16 bits of the first seed 
0e3f			;   (seed1_1) holds the upper 16 bits of the first seed 
0e3f			;   (seed2_0) holds the lower 16 bits of the second seed 
0e3f			;   (seed2_1) holds the upper 16 bits of the second seed 
0e3f			;   **NOTE: seed2 must be non-zero 
0e3f			;Outputs: 
0e3f			;   HL is the result 
0e3f			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e3f			;Destroys: 
0e3f			;   AF 
0e3f			;Tested and passes all CAcert tests 
0e3f			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e3f			;it has a period of 18,446,744,069,414,584,320 
0e3f			;roughly 18.4 quintillion. 
0e3f			;LFSR taps: 0,2,6,7  = 11000101 
0e3f			;291cc 
0e3f			;seed1_0=$+1 
0e3f			;    ld hl,12345 
0e3f			;seed1_1=$+1 
0e3f			;    ld de,6789 
0e3f			;    ld b,h 
0e3f			;    ld c,l 
0e3f			;    add hl,hl \ rl e \ rl d 
0e3f			;    add hl,hl \ rl e \ rl d 
0e3f			;    inc l 
0e3f			;    add hl,bc 
0e3f			;    ld (seed1_0),hl 
0e3f			;    ld hl,(seed1_1) 
0e3f			;    adc hl,de 
0e3f			;    ld (seed1_1),hl 
0e3f			;    ex de,hl 
0e3f			;seed2_0=$+1 
0e3f			;    ld hl,9876 
0e3f			;seed2_1=$+1 
0e3f			;    ld bc,54321 
0e3f			;    add hl,hl \ rl c \ rl b 
0e3f			;    ld (seed2_1),bc 
0e3f			;    sbc a,a 
0e3f			;    and %11000101 
0e3f			;    xor l 
0e3f			;    ld l,a 
0e3f			;    ld (seed2_0),hl 
0e3f			;    ex de,hl 
0e3f			;    add hl,bc 
0e3f			;    ret 
0e3f			; 
0e3f			 
0e3f			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e3f			; 20 bytes, 86 cycles (excluding ret) 
0e3f			 
0e3f			; returns   hl = pseudorandom number 
0e3f			; corrupts   a 
0e3f			 
0e3f			; generates 16-bit pseudorandom numbers with a period of 65535 
0e3f			; using the xorshift method: 
0e3f			 
0e3f			; hl ^= hl << 7 
0e3f			; hl ^= hl >> 9 
0e3f			; hl ^= hl << 8 
0e3f			 
0e3f			; some alternative shift triplets which also perform well are: 
0e3f			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e3f			 
0e3f			;  org 32768 
0e3f			 
0e3f			xrnd: 
0e3f 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0e42 3e 00		  ld a,0 
0e44 bd			  cp l 
0e45 20 02		  jr nz, .xrnd1 
0e47 2e 01		  ld l, 1 
0e49			.xrnd1: 
0e49			 
0e49 7c			  ld a,h 
0e4a 1f			  rra 
0e4b 7d			  ld a,l 
0e4c 1f			  rra 
0e4d ac			  xor h 
0e4e 67			  ld h,a 
0e4f 7d			  ld a,l 
0e50 1f			  rra 
0e51 7c			  ld a,h 
0e52 1f			  rra 
0e53 ad			  xor l 
0e54 6f			  ld l,a 
0e55 ac			  xor h 
0e56 67			  ld h,a 
0e57			 
0e57 22 af fb		  ld (xrandc),hl 
0e5a			 
0e5a c9			  ret 
0e5b			;  
0e5b			 
0e5b			 
0e5b			;;;; int maths 
0e5b			 
0e5b			; https://map.grauw.nl/articles/mult_div_shifts.php 
0e5b			; Divide 16-bit values (with 16-bit result) 
0e5b			; In: Divide BC by divider DE 
0e5b			; Out: BC = result, HL = rest 
0e5b			; 
0e5b			Div16: 
0e5b 21 00 00		    ld hl,0 
0e5e 78			    ld a,b 
0e5f 06 08		    ld b,8 
0e61			Div16_Loop1: 
0e61 17			    rla 
0e62 ed 6a		    adc hl,hl 
0e64 ed 52		    sbc hl,de 
0e66 30 01		    jr nc,Div16_NoAdd1 
0e68 19			    add hl,de 
0e69			Div16_NoAdd1: 
0e69 10 f6		    djnz Div16_Loop1 
0e6b 17			    rla 
0e6c 2f			    cpl 
0e6d 47			    ld b,a 
0e6e 79			    ld a,c 
0e6f 48			    ld c,b 
0e70 06 08		    ld b,8 
0e72			Div16_Loop2: 
0e72 17			    rla 
0e73 ed 6a		    adc hl,hl 
0e75 ed 52		    sbc hl,de 
0e77 30 01		    jr nc,Div16_NoAdd2 
0e79 19			    add hl,de 
0e7a			Div16_NoAdd2: 
0e7a 10 f6		    djnz Div16_Loop2 
0e7c 17			    rla 
0e7d 2f			    cpl 
0e7e 41			    ld b,c 
0e7f 4f			    ld c,a 
0e80 c9			ret 
0e81			 
0e81			 
0e81			;http://z80-heaven.wikidot.com/math 
0e81			; 
0e81			;Inputs: 
0e81			;     DE and A are factors 
0e81			;Outputs: 
0e81			;     A is not changed 
0e81			;     B is 0 
0e81			;     C is not changed 
0e81			;     DE is not changed 
0e81			;     HL is the product 
0e81			;Time: 
0e81			;     342+6x 
0e81			; 
0e81			Mult16: 
0e81			 
0e81 06 08		     ld b,8          ;7           7 
0e83 21 00 00		     ld hl,0         ;10         10 
0e86 29			       add hl,hl     ;11*8       88 
0e87 07			       rlca          ;4*8        32 
0e88 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0e8a 19			         add hl,de   ;--         -- 
0e8b 10 f9		       djnz $-5      ;13*7+8     99 
0e8d c9			ret 
0e8e			 
0e8e			; 
0e8e			; Square root of 16-bit value 
0e8e			; In:  HL = value 
0e8e			; Out:  D = result (rounded down) 
0e8e			; 
0e8e			;Sqr16: 
0e8e			;    ld de,#0040 
0e8e			;    ld a,l 
0e8e			;    ld l,h 
0e8e			;    ld h,d 
0e8e			;    or a 
0e8e			;    ld b,8 
0e8e			;Sqr16_Loop: 
0e8e			;    sbc hl,de 
0e8e			;    jr nc,Sqr16_Skip 
0e8e			;    add hl,de 
0e8e			;Sqr16_Skip: 
0e8e			;    ccf 
0e8e			;    rl d 
0e8e			;    add a,a 
0e8e			;    adc hl,hl 
0e8e			;    add a,a 
0e8e			;    adc hl,hl 
0e8e			;    djnz Sqr16_Loop 
0e8e			;    ret 
0e8e			; 
0e8e			; 
0e8e			; Divide 8-bit values 
0e8e			; In: Divide E by divider C 
0e8e			; Out: A = result, B = rest 
0e8e			; 
0e8e			Div8: 
0e8e af			    xor a 
0e8f 06 08		    ld b,8 
0e91			Div8_Loop: 
0e91 cb 13		    rl e 
0e93 17			    rla 
0e94 91			    sub c 
0e95 30 01		    jr nc,Div8_NoAdd 
0e97 81			    add a,c 
0e98			Div8_NoAdd: 
0e98 10 f7		    djnz Div8_Loop 
0e9a 47			    ld b,a 
0e9b 7b			    ld a,e 
0e9c 17			    rla 
0e9d 2f			    cpl 
0e9e c9			    ret 
0e9f			 
0e9f			; 
0e9f			; Multiply 8-bit value with a 16-bit value (unrolled) 
0e9f			; In: Multiply A with DE 
0e9f			; Out: HL = result 
0e9f			; 
0e9f			Mult12U: 
0e9f 2e 00		    ld l,0 
0ea1 87			    add a,a 
0ea2 30 01		    jr nc,Mult12U_NoAdd0 
0ea4 19			    add hl,de 
0ea5			Mult12U_NoAdd0: 
0ea5 29			    add hl,hl 
0ea6 87			    add a,a 
0ea7 30 01		    jr nc,Mult12U_NoAdd1 
0ea9 19			    add hl,de 
0eaa			Mult12U_NoAdd1: 
0eaa 29			    add hl,hl 
0eab 87			    add a,a 
0eac 30 01		    jr nc,Mult12U_NoAdd2 
0eae 19			    add hl,de 
0eaf			Mult12U_NoAdd2: 
0eaf 29			    add hl,hl 
0eb0 87			    add a,a 
0eb1 30 01		    jr nc,Mult12U_NoAdd3 
0eb3 19			    add hl,de 
0eb4			Mult12U_NoAdd3: 
0eb4 29			    add hl,hl 
0eb5 87			    add a,a 
0eb6 30 01		    jr nc,Mult12U_NoAdd4 
0eb8 19			    add hl,de 
0eb9			Mult12U_NoAdd4: 
0eb9 29			    add hl,hl 
0eba 87			    add a,a 
0ebb 30 01		    jr nc,Mult12U_NoAdd5 
0ebd 19			    add hl,de 
0ebe			Mult12U_NoAdd5: 
0ebe 29			    add hl,hl 
0ebf 87			    add a,a 
0ec0 30 01		    jr nc,Mult12U_NoAdd6 
0ec2 19			    add hl,de 
0ec3			Mult12U_NoAdd6: 
0ec3 29			    add hl,hl 
0ec4 87			    add a,a 
0ec5 d0			    ret nc 
0ec6 19			    add hl,de 
0ec7 c9			    ret 
0ec8			 
0ec8			; 
0ec8			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ec8			; In: Multiply A with DE 
0ec8			;      Put lowest value in A for most efficient calculation 
0ec8			; Out: HL = result 
0ec8			; 
0ec8			Mult12R: 
0ec8 21 00 00		    ld hl,0 
0ecb			Mult12R_Loop: 
0ecb cb 3f		    srl a 
0ecd 30 01		    jr nc,Mult12R_NoAdd 
0ecf 19			    add hl,de 
0ed0			Mult12R_NoAdd: 
0ed0 cb 23		    sla e 
0ed2 cb 12		    rl d 
0ed4 b7			    or a 
0ed5 c2 cb 0e		    jp nz,Mult12R_Loop 
0ed8 c9			    ret 
0ed9			 
0ed9			; 
0ed9			; Multiply 16-bit values (with 32-bit result) 
0ed9			; In: Multiply BC with DE 
0ed9			; Out: BCHL = result 
0ed9			; 
0ed9			Mult32: 
0ed9 79			    ld a,c 
0eda 48			    ld c,b 
0edb 21 00 00		    ld hl,0 
0ede 06 10		    ld b,16 
0ee0			Mult32_Loop: 
0ee0 29			    add hl,hl 
0ee1 17			    rla 
0ee2 cb 11		    rl c 
0ee4 30 07		    jr nc,Mult32_NoAdd 
0ee6 19			    add hl,de 
0ee7 ce 00		    adc a,0 
0ee9 d2 ed 0e		    jp nc,Mult32_NoAdd 
0eec 0c			    inc c 
0eed			Mult32_NoAdd: 
0eed 10 f1		    djnz Mult32_Loop 
0eef 41			    ld b,c 
0ef0 4f			    ld c,a 
0ef1 c9			    ret 
0ef2			 
0ef2			 
0ef2			 
0ef2			; 
0ef2			; Multiply 8-bit values 
0ef2			; In:  Multiply H with E 
0ef2			; Out: HL = result 
0ef2			; 
0ef2			Mult8: 
0ef2 16 00		    ld d,0 
0ef4 6a			    ld l,d 
0ef5 06 08		    ld b,8 
0ef7			Mult8_Loop: 
0ef7 29			    add hl,hl 
0ef8 30 01		    jr nc,Mult8_NoAdd 
0efa 19			    add hl,de 
0efb			Mult8_NoAdd: 
0efb 10 fa		    djnz Mult8_Loop 
0efd c9			    ret 
0efe			 
0efe			 
0efe			 
0efe			 
0efe			 
0efe			 
0efe			 
0efe			 
0efe			;;http://z80-heaven.wikidot.com/math 
0efe			;;This divides DE by BC, storing the result in DE, remainder in HL 
0efe			; 
0efe			;DE_Div_BC:          ;1281-2x, x is at most 16 
0efe			;     ld a,16        ;7 
0efe			;     ld hl,0        ;10 
0efe			;     jp $+5         ;10 
0efe			;.DivLoop: 
0efe			;       add hl,bc    ;-- 
0efe			;       dec a        ;64 
0efe			;       jr z,.DivLoopEnd        ;86 
0efe			; 
0efe			;       sla e        ;128 
0efe			;       rl d         ;128 
0efe			;       adc hl,hl    ;240 
0efe			;       sbc hl,bc    ;240 
0efe			;       jr nc,.DivLoop ;23|21 
0efe			;       inc e        ;-- 
0efe			;       jp .DivLoop+1 
0efe			; 
0efe			;.DivLoopEnd: 
0efe			 
0efe			;HL_Div_C: 
0efe			;Inputs: 
0efe			;     HL is the numerator 
0efe			;     C is the denominator 
0efe			;Outputs: 
0efe			;     A is the remainder 
0efe			;     B is 0 
0efe			;     C is not changed 
0efe			;     DE is not changed 
0efe			;     HL is the quotient 
0efe			; 
0efe			;       ld b,16 
0efe			;       xor a 
0efe			;         add hl,hl 
0efe			;         rla 
0efe			;         cp c 
0efe			;         jr c,$+4 
0efe			;           inc l 
0efe			;           sub c 
0efe			;         djnz $-7 
0efe			 
0efe			; https://plutiedev.com/z80-add-8bit-to-16bit 
0efe			 
0efe			addatohl: 
0efe 85			    add   a, l    ; A = A+L 
0eff 6f			    ld    l, a    ; L = A+L 
0f00 8c			    adc   a, h    ; A = A+L+H+carry 
0f01 95			    sub   l       ; A = H+carry 
0f02 67			    ld    h, a    ; H = H+carry 
0f03 c9			ret 
0f04			 
0f04			addatode: 
0f04 83			    add   a, e    ; A = A+L 
0f05 5f			    ld    e, a    ; L = A+L 
0f06 8a			    adc   a, d    ; A = A+L+H+carry 
0f07 93			    sub   e       ; A = H+carry 
0f08 57			    ld    d, a    ; H = H+carry 
0f09 c9			ret 
0f0a			 
0f0a			 
0f0a			addatobc: 
0f0a 81			    add   a, c    ; A = A+L 
0f0b 4f			    ld    c, a    ; L = A+L 
0f0c 88			    adc   a, b    ; A = A+L+H+carry 
0f0d 91			    sub   c       ; A = H+carry 
0f0e 47			    ld    b, a    ; H = H+carry 
0f0f c9			ret 
0f10			 
0f10			subafromhl: 
0f10			   ; If A=0 do nothing 
0f10			    ; Otherwise flip A's sign. Since 
0f10			    ; the upper byte becomes -1, also 
0f10			    ; substract 1 from H. 
0f10 ed 44		    neg 
0f12 ca 1b 0f		    jp    z, Skip 
0f15 25			    dec   h 
0f16			     
0f16			    ; Now add the low byte as usual 
0f16			    ; Two's complement takes care of 
0f16			    ; ensuring the result is correct 
0f16 85			    add   a, l 
0f17 6f			    ld    l, a 
0f18 8c			    adc   a, h 
0f19 95			    sub   l 
0f1a 67			    ld    h, a 
0f1b			Skip: 
0f1b c9				ret 
0f1c			 
0f1c			 
0f1c			; compare hl and de 
0f1c			; returns:  
0f1c			; if hl = de, z=1, s=0, c0=0 
0f1c			; if hl > de, z=0, s=0, c=0 
0f1c			; if hl < de, z=0, s=1, c=1 
0f1c			cmp16:	 
0f1c b7				or a 
0f1d ed 52			sbc hl,de 
0f1f e0				ret po 
0f20 7c				ld a,h 
0f21 1f				rra 
0f22 ee 40			xor 01000000B 
0f24 37				scf 
0f25 8f				adc a,a 
0f26 c9				ret 
0f27			 
0f27			 
0f27			; test if hl contains zero   - A is destroyed 
0f27			 
0f27			ishlzero:    
0f27 b7				or a     ; reset flags 
0f28 7c				ld a, h 
0f29 b5				or l        	 
0f2a			 
0f2a c9				ret 
0f2b			 
0f2b			 
0f2b			 
0f2b			 
0f2b			if FORTH_ENABLE_FLOATMATH 
0f2b			;include "float/bbcmath.z80" 
0f2b			include "float/lpfpcalc.asm" 
0f2b			endif 
0f2b			 
0f2b			 
0f2b			; eof 
0f2b			 
# End of file firmware_maths.asm
0f2b			include "firmware_strings.asm"   ; string handling  
0f2b			 
0f2b			 
0f2b			; TODO string len 
0f2b			; input text string, end on cr with zero term 
0f2b			; a offset into frame buffer to start prompt 
0f2b			; d is max length 
0f2b			; e is display size TODO 
0f2b			; c is current cursor position 
0f2b			; hl is ptr to where string will be stored 
0f2b			 
0f2b			 
0f2b			; TODO check limit of buffer for new inserts 
0f2b			; TODO check insert does not push beyond buffer 
0f2b			; TODO scroll in a limited display area 
0f2b			; TODO scroll whole screen on page wrap 
0f2b			 
0f2b			 
0f2b			; TODO handle KEY_PREVWORD 
0f2b			; TODO handle KEY_NEXTWORD 
0f2b			; TODO handle KEY_HOME 
0f2b			; TODO handle KEY_END 
0f2b			; TODO use LCD cursor? 
0f2b			 
0f2b 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f2e 81					add c 
0f2f 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f32 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0f35 79					ld a, c 
0f36 cd fe 0e				call addatohl 
0f39 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f3c 7a					ld a,d 
0f3d 32 69 fe			        ld (input_size), a       ; save length of input area 
0f40 79					ld a, c 
0f41 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0f44 7b					ld a,e 
0f45 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f48					 
0f48					 
0f48			 
0f48			;		ld a,(input_ptr) 
0f48			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f48			 
0f48			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f48					; init cursor shape if not set by the cin routines 
0f48 21 c7 fb				ld hl, cursor_shape 
0f4b 3e ff				ld a, 255 
0f4d 77					ld (hl), a 
0f4e 23					inc hl 
0f4f 3e 00				ld a, 0 
0f51 77					ld (hl), a 
0f52			 
0f52 3e 0f				ld a, CUR_BLINK_RATE 
0f54 32 63 fe				ld (input_cur_flash), a 
0f57 3e 01				ld a, 1 
0f59 32 62 fe				ld (input_cur_onoff),a 
0f5c			 
0f5c			;	if DEBUG_INPUT 
0f5c			;		push af 
0f5c			;		ld a, 'I' 
0f5c			;		ld (debug_mark),a 
0f5c			;		pop af 
0f5c			;		CALLMONITOR 
0f5c			;	endif 
0f5c			.is1:		; main entry loop 
0f5c			 
0f5c			 
0f5c			 
0f5c					; pause 1ms 
0f5c			 
0f5c 3e 01				ld a, 1 
0f5e cd 2c 0c				call aDelayInMS 
0f61			 
0f61					; dec flash counter 
0f61 3a 63 fe				ld a, (input_cur_flash) 
0f64 3d					dec a 
0f65 32 63 fe				ld (input_cur_flash), a 
0f68 fe 00				cp 0 
0f6a 20 0d				jr nz, .nochgstate 
0f6c			 
0f6c			 
0f6c					; change state 
0f6c 3a 62 fe				ld a,(input_cur_onoff) 
0f6f ed 44				neg 
0f71 32 62 fe				ld (input_cur_onoff),a 
0f74			 
0f74			 
0f74					; reset on change of state 
0f74 3e 0f				ld a, CUR_BLINK_RATE 
0f76 32 63 fe				ld (input_cur_flash), a 
0f79			 
0f79			.nochgstate: 
0f79					 
0f79					 
0f79			 
0f79					; display cursor  
0f79			 
0f79			;		ld hl, (input_start) 
0f79			;		ld a, (input_cursor) 
0f79			;		call addatohl 
0f79			 
0f79					; get char under cursor and replace with cursor 
0f79 2a 6c fe		ld hl, (input_ptr) 
0f7c			;		ld a, (hl) 
0f7c			;		ld (input_under_cursor),a 
0f7c			;		ld a, '_' 
0f7c			;		ld (hl), a 
0f7c			 
0f7c					; display string 
0f7c			 
0f7c ed 5b 6a fe			ld de, (input_start) 
0f80 3a 67 fe				ld a, (input_at_pos) 
0f83 cd dd 0c				call str_at_display 
0f86			;	        call update_display 
0f86			 
0f86					; find place to put the cursor 
0f86			;		add h 
0f86			;		ld l, display_row_1 
0f86			;		sub l 
0f86			; (input_at_pos) 
0f86					;ld c, a 
0f86			;		ld a, (input_cursor) 
0f86			;		ld l, (input_at_pos) 
0f86			;		;ld b, h 
0f86			;		add l 
0f86			;		ld (input_at_cursor),a 
0f86					;ld l,h 
0f86			 
0f86			;		ld h, 0 
0f86			;		ld l,(input_at_pos) 
0f86			;		ld a, (input_cursor) 
0f86			;		call addatohl 
0f86			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0f86			;		call subafromhl 
0f86			;		ld a,l 
0f86			;		ld (input_at_cursor), a 
0f86			 
0f86				if DEBUG_INPUT 
0f86					ld a, (hardware_diag) 
0f86					cp 0 
0f86					jr z, .skip_input_diag 
0f86			 
0f86					ld a,(input_at_pos) 
0f86					ld hl, LFSRSeed 
0f86					call hexout 
0f86					ld a, (input_cursor) 
0f86					ld hl, LFSRSeed+2 
0f86					call hexout 
0f86					ld a,(input_at_cursor) 
0f86					ld hl, LFSRSeed+4 
0f86					call hexout 
0f86			 
0f86					ld a,(input_cur_onoff) 
0f86					ld hl, LFSRSeed+6 
0f86					call hexout 
0f86			 
0f86					ld a,(input_cur_flash) 
0f86					ld hl, LFSRSeed+8 
0f86					call hexout 
0f86			 
0f86					ld a,(input_len) 
0f86					ld hl, LFSRSeed+10 
0f86					call hexout 
0f86					ld hl, LFSRSeed+12 
0f86					ld a, 0 
0f86					ld (hl),a 
0f86					ld a, display_row_4 
0f86					ld de, LFSRSeed 
0f86					call str_at_display 
0f86					.skip_input_diag: 
0f86				endif 
0f86			 
0f86					; decide on if we are showing the cursor this time round 
0f86			 
0f86 3a 62 fe				ld a, (input_cur_onoff) 
0f89 fe ff				cp 255 
0f8b 28 13				jr z, .skipcur 
0f8d			 
0f8d			 
0f8d 3a 65 fe				ld a,(input_at_cursor) 
0f90 11 c7 fb				ld de, cursor_shape 
0f93 cd dd 0c				call str_at_display 
0f96			 
0f96					; save length of current input string 
0f96 2a 6a fe				ld hl, (input_start) 
0f99 cd 5c 13				call strlenz 
0f9c 7d					ld a,l 
0f9d 32 5d fe				ld (input_len),a 
0fa0			 
0fa0			.skipcur: 
0fa0			 
0fa0 cd ed 0c			        call update_display 
0fa3					 
0fa3			 
0fa3			 
0fa3					; wait 
0fa3				 
0fa3					; TODO loop without wait to flash the cursor and char under cursor	 
0fa3 cd 2d 6d				call cin    ; _wait 
0fa6			 
0fa6 fe 00				cp 0 
0fa8 ca 5c 0f				jp z, .is1 
0fab			 
0fab					; get ptr to char to input into 
0fab			 
0fab 4f					ld c,a 
0fac 2a 6a fe				ld hl, (input_start) 
0faf 3a 58 fe				ld a, (input_cursor) 
0fb2 cd fe 0e				call addatohl 
0fb5 22 6c fe				ld (input_ptr), hl 
0fb8 79					ld a,c 
0fb9			 
0fb9					; replace char under cursor 
0fb9			 
0fb9			;		ld hl, (input_ptr) 
0fb9			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0fb9			;		ld (hl), a 
0fb9			 
0fb9			;	if DEBUG_INPUT 
0fb9			;		push af 
0fb9			;		ld a, 'i' 
0fb9			;		ld (debug_mark),a 
0fb9			;		pop af 
0fb9			;		CALLMONITOR 
0fb9			;	endif 
0fb9 fe 0e				cp KEY_HOME 
0fbb 20 0e				jr nz, .iske 
0fbd			 
0fbd 3a 67 fe				ld a, (input_at_pos) 
0fc0 32 65 fe				ld (input_at_cursor),a 
0fc3 3e 00				ld a, 0 
0fc5 32 58 fe				ld (input_cursor), a 
0fc8 c3 5c 0f				jp .is1 
0fcb					 
0fcb fe 0f		.iske:		cp KEY_END 
0fcd 20 03				jr nz, .isknw 
0fcf c3 5c 0f				jp .is1 
0fd2			 
0fd2 fe 06		.isknw:		cp KEY_NEXTWORD 
0fd4 20 1b				jr nz, .iskpw 
0fd6			 
0fd6 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
0fd9 7e					ld a,(hl)	 
0fda fe 00				cp 0 
0fdc ca 5c 0f				jp z, .is1    ; end of string 
0fdf fe 20				cp ' ' 
0fe1 ca 5c 0f				jp z, .is1    ; end of word 
0fe4 23					inc hl 
0fe5 22 6c fe				ld (input_ptr), hl 
0fe8 3a 65 fe				ld a, (input_at_cursor) 
0feb 3c					inc a 
0fec 32 65 fe				ld (input_at_cursor), a 
0fef 18 e5				jr .isknwm 
0ff1			 
0ff1 fe 07		.iskpw:		cp KEY_PREVWORD 
0ff3 20 1b				jr nz, .iskl 
0ff5			.iskpwm:	 
0ff5 2a 6c fe				ld hl, (input_ptr) 
0ff8 7e					ld a,(hl)	 
0ff9 fe 00				cp 0  
0ffb ca 5c 0f				jp z, .is1    ; end of string 
0ffe fe 20				cp ' ' 
1000 ca 5c 0f				jp z, .is1    ; end of word 
1003 2b					dec hl 
1004 22 6c fe				ld (input_ptr), hl 
1007 3a 65 fe				ld a, (input_at_cursor) 
100a 3d					dec a 
100b 32 65 fe				ld (input_at_cursor), a 
100e 18 e5				jr .iskpwm 
1010			 
1010			 
1010 fe 0b		.iskl:		cp KEY_LEFT 
1012 20 27				jr nz, .isk1 
1014			 
1014 3a 58 fe				ld a, (input_cursor) 
1017			 
1017 fe 00				cp 0 
1019 ca 5c 0f				jp z, .is1 		; at start of line to ignore  
101c			 
101c 3d					dec  a 		; TODO check underflow 
101d 32 58 fe				ld (input_cursor), a 
1020			 
1020 2a 6c fe				ld hl, (input_ptr) 
1023 2b					dec hl 
1024 22 6c fe				ld (input_ptr), hl 
1027					 
1027 3a 65 fe				ld a, (input_at_cursor) 
102a 3d					dec a 
102b 32 65 fe				ld (input_at_cursor), a 
102e			 
102e 3e 01				ld a, 1		; show cursor moving 
1030 32 62 fe				ld (input_cur_onoff),a 
1033 3e 0f				ld a, CUR_BLINK_RATE 
1035 32 63 fe				ld (input_cur_flash), a 
1038			 
1038 c3 5c 0f				jp .is1 
103b			 
103b fe 0c		.isk1:		cp KEY_RIGHT 
103d 20 2a				jr nz, .isk2 
103f			 
103f 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1042 5f					ld e,a 
1043 3a 58 fe				ld a, (input_cursor) 
1046 bb					cp e 
1047 ca 5c 0f				jp z, .is1		; at the end of string so dont go right 
104a			 
104a 3c					inc  a 		; TODO check overflow 
104b 32 58 fe				ld (input_cursor), a 
104e			 
104e 3a 65 fe				ld a, (input_at_cursor) 
1051 3c					inc a 
1052 32 65 fe				ld (input_at_cursor), a 
1055			 
1055 2a 6c fe				ld hl, (input_ptr) 
1058 23					inc hl 
1059 22 6c fe				ld (input_ptr), hl 
105c			 
105c 3e 01				ld a, 1		; show cursor moving 
105e 32 62 fe				ld (input_cur_onoff),a 
1061 3e 0f				ld a, CUR_BLINK_RATE 
1063 32 63 fe				ld (input_cur_flash), a 
1066			 
1066 c3 5c 0f				jp .is1 
1069			 
1069 fe 05		.isk2:		cp KEY_UP 
106b			 
106b 20 26				jr nz, .isk3 
106d			 
106d					; swap last command with the current on 
106d			 
106d					; move cursor to start of string 
106d 2a 6a fe				ld hl, (input_start) 
1070 22 6c fe				ld (input_ptr), hl 
1073			 
1073 3a 67 fe				ld a, (input_at_pos) 
1076 32 65 fe				ld (input_at_cursor), a 
1079			 
1079 3e 00				ld a, 0 
107b 32 58 fe				ld (input_cursor), a 
107e					 
107e					; swap input and last command buffers 
107e			 
107e 21 26 f5				ld hl, os_cli_cmd 
1081 11 25 f6				ld de, os_last_cmd 
1084 06 ff				ld b, 255 
1086 7e			.swap1:		ld a, (hl) 
1087 4f					ld c,a 
1088 1a					ld a, (de) 
1089 77					ld (hl), a 
108a 79					ld a,c 
108b 12					ld (de),a 
108c 23					inc hl 
108d 13					inc de 
108e 10 f6				djnz .swap1 
1090			 
1090			 
1090			 
1090			 
1090			 
1090 c3 5c 0f				jp .is1 
1093			 
1093 fe 08		.isk3:		cp KEY_BS 
1095 20 3c				jr nz, .isk4 
1097			 
1097 3a 58 fe				ld a, (input_cursor) 
109a			 
109a fe 00				cp 0 
109c ca 5c 0f				jp z, .is1 		; at start of line to ignore  
109f			 
109f 3d					dec  a 		; TODO check underflow 
10a0 32 58 fe				ld (input_cursor), a 
10a3			 
10a3					; hl is source 
10a3					; de needs to be source - 1 
10a3			 
10a3			;		ld a, 0 
10a3			;		dec hl 
10a3			;		ld (hl), a 
10a3			 
10a3 2a 6c fe				ld hl, (input_ptr) 
10a6 2b					dec hl 
10a7 22 6c fe				ld (input_ptr), hl 
10aa			 
10aa					; shift all data 
10aa			 
10aa e5					push hl 
10ab 23					inc hl 
10ac d1					pop de 
10ad 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10b0 4f					ld c,a 
10b1 06 00				ld b,0 
10b3 ed b0				ldir  
10b5			 
10b5			 
10b5			 
10b5			 
10b5 3a 65 fe				ld a, (input_at_cursor) 
10b8 3d					dec a 
10b9 32 65 fe				ld (input_at_cursor), a 
10bc			 
10bc			 
10bc 3e 01				ld a, 1		; show cursor moving 
10be 32 62 fe				ld (input_cur_onoff),a 
10c1 3e 0f				ld a, CUR_BLINK_RATE 
10c3 32 63 fe				ld (input_cur_flash), a 
10c6			 
10c6					; remove char 
10c6 3a 65 fe				ld a, (input_at_cursor) 
10c9 3c					inc a 
10ca 11 54 11				ld de,.iblank 
10cd cd dd 0c				call str_at_display 
10d0			 
10d0 c3 5c 0f				jp .is1 
10d3			 
10d3 fe 0d		.isk4:		cp KEY_CR 
10d5 28 6c				jr z, .endinput 
10d7			 
10d7					; else add the key press to the end 
10d7			 
10d7 4f					ld c, a			; save key pressed 
10d8			 
10d8 7e					ld a,(hl)		; get what is currently under char 
10d9			 
10d9 fe 00				cp 0			; we are at the end of the string 
10db 20 2f				jr nz, .onchar 
10dd					 
10dd					; add a char to the end of the string 
10dd				 
10dd 71					ld (hl),c 
10de 23					inc hl 
10df			;		ld a,' ' 
10df			;		ld (hl),a 
10df			;		inc hl 
10df 3e 00				ld a,0 
10e1 77					ld (hl),a 
10e2 2b					dec hl 
10e3			 
10e3 3a 58 fe				ld a, (input_cursor) 
10e6 3c					inc a				; TODO check max string length and scroll  
10e7 32 58 fe				ld (input_cursor), a		; inc cursor pos 
10ea							 
10ea 3a 65 fe				ld a, (input_at_cursor) 
10ed 3c					inc a 
10ee 32 65 fe				ld (input_at_cursor), a 
10f1			 
10f1 2a 6c fe				ld hl, (input_ptr) 
10f4 23					inc hl 
10f5 22 6c fe				ld (input_ptr), hl 
10f8			 
10f8 2a 6c fe				ld hl, (input_ptr) 
10fb 23					inc hl 
10fc 22 6c fe				ld (input_ptr), hl 
10ff			;	if DEBUG_INPUT 
10ff			;		push af 
10ff			;		ld a, '+' 
10ff			;		ld (debug_mark),a 
10ff			;		pop af 
10ff			;		CALLMONITOR 
10ff			;	endif 
10ff 3e 01				ld a, 1		; show cursor moving 
1101 32 62 fe				ld (input_cur_onoff),a 
1104 3e 0f				ld a, CUR_BLINK_RATE 
1106 32 63 fe				ld (input_cur_flash), a 
1109 c3 5c 0f				jp .is1 
110c					 
110c			 
110c			 
110c					; if on a char then insert 
110c			.onchar: 
110c			 
110c					; TODO over flow check: make sure insert does not blow out buffer 
110c			 
110c					; need to do some maths to use lddr 
110c			 
110c e5					push hl   ; save char pos 
110d c5					push bc 
110e			 
110e 2a 6a fe				ld hl, (input_start) 
1111 3a 5d fe				ld a, (input_len) 
1114 cd fe 0e				call addatohl  		; end of string 
1117 23					inc hl 
1118 23					inc hl		; past zero term 
1119 e5					push hl 
111a 23					inc hl 
111b e5					push hl  
111c			 
111c								; start and end of lddr set, now how much to move? 
111c			 
111c							 
111c 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
111f 47					ld b,a 
1120 3a 5d fe				ld a,(input_len) 
1123 5f					ld e,a 
1124 90					sub b 
1125 3c					inc a		;?? 
1126 3c					inc a		;?? 
1127 3c					inc a		;?? 
1128			 
1128 06 00				ld b,0 
112a 4f					ld c,a 
112b			 
112b				if DEBUG_INPUT 
112b					push af 
112b					ld a, 'i' 
112b					ld (debug_mark),a 
112b					pop af 
112b			;		CALLMONITOR 
112b				endif 
112b d1					pop de 
112c e1					pop hl 
112d				if DEBUG_INPUT 
112d					push af 
112d					ld a, 'I' 
112d					ld (debug_mark),a 
112d					pop af 
112d			;		CALLMONITOR 
112d				endif 
112d ed b8				lddr 
112f				 
112f			 
112f			 
112f					; TODO have a key for insert/overwrite mode???? 
112f c1					pop bc 
1130 e1					pop hl 
1131 71					ld (hl), c		; otherwise overwrite current char 
1132					 
1132			 
1132			 
1132			 
1132 3a 58 fe				ld a, (input_cursor) 
1135 3c					inc  a 		; TODO check overflow 
1136 32 58 fe				ld (input_cursor), a 
1139			 
1139 3a 65 fe				ld a, (input_at_cursor) 
113c 3c					inc a 
113d 32 65 fe				ld (input_at_cursor), a 
1140			 
1140 c3 5c 0f				jp .is1 
1143			 
1143			.endinput:	; TODO look for end of string 
1143			 
1143					; add trailing space for end of token 
1143			 
1143 2a 6a fe				ld hl, (input_start) 
1146 3a 5d fe				ld a,(input_len) 
1149 cd fe 0e				call addatohl 
114c 3e 20				ld a, ' ' 
114e 77					ld (hl),a 
114f					; TODO eof of parse marker 
114f			 
114f 23					inc hl 
1150 3e 00				ld a, 0 
1152 77					ld (hl),a 
1153			 
1153			 
1153 c9					ret 
1154			 
1154 .. 00		.iblank: db " ",0 
1156			 
1156			 
1156 32 67 fe		input_str_prev:	ld (input_at_pos), a 
1159 22 6a fe				ld (input_start), hl 
115c 3e 01				ld a,1			; add cursor 
115e 77					ld (hl),a 
115f 23					inc hl 
1160 3e 00				ld a,0 
1162 77					ld (hl),a 
1163 22 6c fe				ld (input_ptr), hl 
1166 7a					ld a,d 
1167 32 69 fe				ld (input_size), a 
116a 3e 00				ld a,0 
116c 32 58 fe				ld (input_cursor),a 
116f			.instr1:	 
116f			 
116f					; TODO do block cursor 
116f					; TODO switch cursor depending on the modifer key 
116f			 
116f					; update cursor shape change on key hold 
116f			 
116f 2a 6c fe				ld hl, (input_ptr) 
1172 2b					dec hl 
1173 3a c7 fb				ld a,(cursor_shape) 
1176 77					ld (hl), a 
1177			 
1177					; display entered text 
1177 3a 67 fe				ld a,(input_at_pos) 
117a cd f1 6a		            	CALL fLCD_Pos       ;Position cursor to location in A 
117d ed 5b 6a fe	            	LD   de, (input_start) 
1181 cd 13 6b		            	CALL fLCD_Str       ;Display string pointed to by DE 
1184			 
1184 cd 2d 6d				call cin 
1187 fe 00				cp 0 
1189 28 e4				jr z, .instr1 
118b			 
118b					; proecess keyboard controls first 
118b			 
118b 2a 6c fe				ld hl,(input_ptr) 
118e			 
118e fe 0d				cp KEY_CR	 ; pressing enter ends input 
1190 28 5a				jr z, .instrcr 
1192			 
1192 fe 08				cp KEY_BS 	; back space 
1194 20 0f				jr nz, .instr2 
1196					; process back space 
1196			 
1196					; TODO stop back space if at start of string 
1196 2b					dec hl 
1197 2b					dec hl ; to over write cursor 
1198 3a c7 fb				ld a,(cursor_shape) 
119b					;ld a,0 
119b 77					ld (hl),a 
119c 23					inc hl 
119d 3e 20				ld a," " 
119f 77					ld (hl),a 
11a0 22 6c fe				ld (input_ptr),hl 
11a3					 
11a3			 
11a3 18 ca				jr .instr1 
11a5			 
11a5 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11a7 20 06				jr nz, .instr3 
11a9 2b					dec hl 
11aa 22 6c fe				ld (input_ptr),hl 
11ad 18 c0				jr .instr1 
11af				 
11af fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11b1 20 06				jr nz, .instr4 
11b3 23					inc hl 
11b4 22 6c fe				ld (input_ptr),hl 
11b7 18 b6				jr .instr1 
11b9			 
11b9 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
11bb 20 06				jr nz, .instr5 
11bd 2b					dec hl 
11be 22 6c fe				ld (input_ptr),hl 
11c1 18 ac				jr .instr1 
11c3			 
11c3 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
11c5 20 06				jr nz, .instr6 
11c7 2b					dec hl 
11c8 22 6c fe				ld (input_ptr),hl 
11cb 18 a2				jr .instr1 
11cd fe 05		.instr6:        cp KEY_UP      ; recall last command 
11cf 20 0b				jr nz, .instrnew 
11d1			 
11d1 21 ff f1			ld hl, scratch 
11d4 11 25 f6			ld de, os_last_cmd 
11d7 cd f5 11			call strcpy 
11da 18 93				jr .instr1 
11dc			 
11dc			 
11dc			.instrnew:	; no special key pressed to see if we have room to store it 
11dc			 
11dc					; TODO do string size test 
11dc			 
11dc 2b					dec hl ; to over write cursor 
11dd 77					ld (hl),a 
11de 23					inc hl 
11df 3a c7 fb				ld a,(cursor_shape) 
11e2 77					ld (hl),a 
11e3 23					inc hl 
11e4 3e 00				ld a,0 
11e6 77					ld (hl),a 
11e7			 
11e7 22 6c fe				ld (input_ptr),hl 
11ea					 
11ea 18 83				jr .instr1 
11ec 2b			.instrcr:	dec hl		; remove cursor 
11ed 3e 20				ld a,' '	; TODO add a trailing space for safety 
11ef 77					ld (hl),a 
11f0 23					inc hl 
11f1 3e 00				ld a,0 
11f3 77					ld (hl),a 
11f4			 
11f4			 
11f4					; if at end of line scroll up    
11f4					; TODO detecting only end of line 4 for scroll up  
11f4			 
11f4					;ld   
11f4			 
11f4 c9					ret 
11f5			 
11f5			 
11f5			; strcpy hl = dest, de source 
11f5			 
11f5 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11f6 b7			            OR   A              ;Null terminator? 
11f7 c8			            RET  Z              ;Yes, so finished 
11f8 1a					ld a,(de) 
11f9 77					ld (hl),a 
11fa 13			            INC  DE             ;Point to next character 
11fb 23					inc hl 
11fc 18 f7		            JR   strcpy       ;Repeat 
11fe c9					ret 
11ff			 
11ff			 
11ff			; TODO string_at  
11ff			; pass string which starts with lcd offset address and then null term string 
11ff			 
11ff			; TODO string to dec 
11ff			; TODO string to hex 
11ff			; TODO byte to string hex 
11ff			; TODO byte to string dec 
11ff			 
11ff			 
11ff			 
11ff			; from z80uartmonitor 
11ff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11ff			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11ff			; pass hl for where to put the text 
11ff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11ff c5			hexout:	PUSH BC 
1200 f5					PUSH AF 
1201 47					LD B, A 
1202					; Upper nybble 
1202 cb 3f				SRL A 
1204 cb 3f				SRL A 
1206 cb 3f				SRL A 
1208 cb 3f				SRL A 
120a cd 1a 12				CALL tohex 
120d 77					ld (hl),a 
120e 23					inc hl	 
120f					 
120f					; Lower nybble 
120f 78					LD A, B 
1210 e6 0f				AND 0FH 
1212 cd 1a 12				CALL tohex 
1215 77					ld (hl),a 
1216 23					inc hl	 
1217					 
1217 f1					POP AF 
1218 c1					POP BC 
1219 c9					RET 
121a					 
121a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
121a			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
121a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
121a			tohex: 
121a e5					PUSH HL 
121b d5					PUSH DE 
121c 16 00				LD D, 0 
121e 5f					LD E, A 
121f 21 27 12				LD HL, .DATA 
1222 19					ADD HL, DE 
1223 7e					LD A, (HL) 
1224 d1					POP DE 
1225 e1					POP HL 
1226 c9					RET 
1227			 
1227			.DATA: 
1227 30					DEFB	30h	; 0 
1228 31					DEFB	31h	; 1 
1229 32					DEFB	32h	; 2 
122a 33					DEFB	33h	; 3 
122b 34					DEFB	34h	; 4 
122c 35					DEFB	35h	; 5 
122d 36					DEFB	36h	; 6 
122e 37					DEFB	37h	; 7 
122f 38					DEFB	38h	; 8 
1230 39					DEFB	39h	; 9 
1231 41					DEFB	41h	; A 
1232 42					DEFB	42h	; B 
1233 43					DEFB	43h	; C 
1234 44					DEFB	44h	; D 
1235 45					DEFB	45h	; E 
1236 46					DEFB	46h	; F 
1237			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1237			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1237			;;    subtract $30, if result > 9 then subtract $7 more 
1237			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1237			atohex: 
1237 d6 30				SUB $30 
1239 fe 0a				CP 10 
123b f8					RET M		; If result negative it was 0-9 so we're done 
123c d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
123e c9					RET		 
123f			 
123f			 
123f			 
123f			 
123f			; Get 2 ASCII characters as hex byte from pointer in hl 
123f			 
123f			BYTERD: 
123f 16 00			LD	D,00h		;Set up 
1241 cd 49 12			CALL	HEXCON		;Get byte and convert to hex 
1244 87				ADD	A,A		;First nibble so 
1245 87				ADD	A,A		;multiply by 16 
1246 87				ADD	A,A		; 
1247 87				ADD	A,A		; 
1248 57				LD	D,A		;Save hi nibble in D 
1249			HEXCON: 
1249 7e				ld a, (hl)		;Get next chr 
124a 23				inc hl 
124b d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
124d fe 0a			CP	00Ah		;Is it 0-9 ? 
124f 38 02			JR	C,NALPHA	;If so miss next bit 
1251 d6 07			SUB	007h		;Else convert alpha 
1253			NALPHA: 
1253 b2				OR	D		;Add hi nibble back 
1254 c9				RET			; 
1255			 
1255			 
1255			; 
1255			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1255			; Since the routines get_byte and therefore get_nibble are called, only valid 
1255			; characters (0-9a-f) are accepted. 
1255			; 
1255			;get_word        push    af 
1255			;                call    get_byte        ; Get the upper byte 
1255			;                ld      h, a 
1255			;                call    get_byte        ; Get the lower byte 
1255			;                ld      l, a 
1255			;                pop     af 
1255			;                ret 
1255			; 
1255			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1255			; the routine get_nibble is used only valid characters are accepted - the  
1255			; input routine only accepts characters 0-9a-f. 
1255			; 
1255 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1256 7e					ld a,(hl) 
1257 23					inc hl 
1258 cd 7d 12		                call    nibble2val      ; Get upper nibble 
125b cb 07		                rlc     a 
125d cb 07		                rlc     a 
125f cb 07		                rlc     a 
1261 cb 07		                rlc     a 
1263 47			                ld      b, a            ; Save upper four bits 
1264 7e					ld a,(hl) 
1265 cd 7d 12		                call    nibble2val      ; Get lower nibble 
1268 b0			                or      b               ; Combine both nibbles 
1269 c1			                pop     bc              ; Restore B (and C) 
126a c9			                ret 
126b			; 
126b			; Get a hexadecimal digit from the serial line. This routine blocks until 
126b			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
126b			; to the serial line interface. The lower 4 bits of A contain the value of  
126b			; that particular digit. 
126b			; 
126b			;get_nibble      ld a,(hl)           ; Read a character 
126b			;                call    to_upper        ; Convert to upper case 
126b			;                call    is_hex          ; Was it a hex digit? 
126b			;                jr      nc, get_nibble  ; No, get another character 
126b			 ;               call    nibble2val      ; Convert nibble to value 
126b			 ;               call    print_nibble 
126b			 ;               ret 
126b			; 
126b			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
126b			; A valid hexadecimal digit is denoted by a set C flag. 
126b			; 
126b			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
126b			;                ret     nc              ; Yes 
126b			;                cp      '0'             ; Less than '0'? 
126b			;                jr      nc, is_hex_1    ; No, continue 
126b			;                ccf                     ; Complement carry (i.e. clear it) 
126b			;                ret 
126b			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
126b			;                ret     c               ; Yes 
126b			;                cp      'A'             ; Less than 'A'? 
126b			;                jr      nc, is_hex_2    ; No, continue 
126b			;                ccf                     ; Yes - clear carry and return 
126b			;                ret 
126b			;is_hex_2        scf                     ; Set carry 
126b			;                ret 
126b			; 
126b			; Convert a single character contained in A to upper case: 
126b			; 
126b fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
126d d8			                ret     c 
126e fe 7b		                cp      'z' + 1         ; > 'z'? 
1270 d0			                ret     nc              ; Nothing to do, either 
1271 e6 5f		                and     $5f             ; Convert to upper case 
1273 c9			                ret 
1274			 
1274			 
1274			to_lower: 
1274			 
1274			   ; if char is in [A-Z] make it lower case 
1274			 
1274			   ; enter : a = char 
1274			   ; exit  : a = lower case char 
1274			   ; uses  : af 
1274			 
1274 fe 41		   cp 'A' 
1276 d8			   ret c 
1277			    
1277 fe 5b		   cp 'Z'+1 
1279 d0			   ret nc 
127a			    
127a f6 20		   or $20 
127c c9			   ret 
127d			 
127d			; 
127d			; Expects a hexadecimal digit (upper case!) in A and returns the 
127d			; corresponding value in A. 
127d			; 
127d fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
127f 38 02		                jr      c, nibble2val_1 ; Yes 
1281 d6 07		                sub     7               ; Adjust for A-F 
1283 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1285 e6 0f		                and     $f              ; Only return lower 4 bits 
1287 c9			                ret 
1288			; 
1288			; Print_nibble prints a single hex nibble which is contained in the lower  
1288			; four bits of A: 
1288			; 
1288			;print_nibble    push    af              ; We won't destroy the contents of A 
1288			;                and     $f              ; Just in case... 
1288			;                add     a, '0'             ; If we have a digit we are done here. 
1288			;                cp      '9' + 1         ; Is the result > 9? 
1288			;                jr      c, print_nibble_1 
1288			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1288			;print_nibble_1  call    putc            ; Print the nibble and 
1288			;                pop     af              ; restore the original value of A 
1288			;                ret 
1288			;; 
1288			;; Send a CR/LF pair: 
1288			; 
1288			;crlf            push    af 
1288			;                ld      a, cr 
1288			;                call    putc 
1288			;                ld      a, lf 
1288			;                call    putc 
1288			;                pop     af 
1288			;                ret 
1288			; 
1288			; Print_word prints the four hex digits of a word to the serial line. The  
1288			; word is expected to be in HL. 
1288			; 
1288			;print_word      push    hl 
1288			;                push    af 
1288			;                ld      a, h 
1288			;                call    print_byte 
1288			;                ld      a, l 
1288			;                call    print_byte 
1288			;                pop     af 
1288			;                pop     hl 
1288			;                ret 
1288			; 
1288			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1288			; The byte to be printed is expected to be in A. 
1288			; 
1288			;print_byte      push    af              ; Save the contents of the registers 
1288			;                push    bc 
1288			;                ld      b, a 
1288			;                rrca 
1288			;                rrca 
1288			;                rrca 
1288			;                rrca 
1288			;                call    print_nibble    ; Print high nibble 
1288			;                ld      a, b 
1288			;                call    print_nibble    ; Print low nibble 
1288			;                pop     bc              ; Restore original register contents 
1288			;                pop     af 
1288			;                ret 
1288			 
1288			 
1288			 
1288			 
1288			 
1288			fourehexhl:  
1288 7e				ld a,(hl) 
1289 cd 37 12			call atohex 
128c cb 3f				SRL A 
128e cb 3f				SRL A 
1290 cb 3f				SRL A 
1292 cb 3f				SRL A 
1294 47				ld b, a 
1295 23				inc hl 
1296 7e				ld a,(hl) 
1297 23				inc hl 
1298 cd 37 12			call atohex 
129b 80				add b 
129c 57				ld d,a 
129d 7e				ld a,(hl) 
129e cd 37 12			call atohex 
12a1 cb 3f				SRL A 
12a3 cb 3f				SRL A 
12a5 cb 3f				SRL A 
12a7 cb 3f				SRL A 
12a9 47				ld b, a 
12aa 23				inc hl 
12ab 7e				ld a,(hl) 
12ac 23				inc hl 
12ad cd 37 12			call atohex 
12b0 80				add b 
12b1 5f				ld e, a 
12b2 d5				push de 
12b3 e1				pop hl 
12b4 c9				ret 
12b5			 
12b5			; pass hl. returns z set if the byte at hl is a digit 
12b5			;isdigithl:  
12b5			;	push bc 
12b5			;	ld a,(hl) 
12b5			;	cp ':' 
12b5			;	jr nc, .isdf 		; > 
12b5			;	cp '0' 
12b5			;	jr c, .isdf		; < 
12b5			; 
12b5			;	; TODO find a better way to set z 
12b5			; 
12b5			;	ld b,a 
12b5			;	cp b 
12b5			;	pop bc 
12b5			;	ret 
12b5			; 
12b5			;.isdf:	; not digit so clear z 
12b5			; 
12b5			;	; TODO find a better way to unset z 
12b5			; 
12b5			;	ld b,a 
12b5			;	inc b 
12b5			;	cp b 
12b5			; 
12b5			;	pop bc 
12b5			;	ret 
12b5				 
12b5				 
12b5			 
12b5			 
12b5			; pass hl as the four byte address to load 
12b5			 
12b5			get_word_hl:  
12b5 e5				push hl 
12b6 cd 55 12			call get_byte 
12b9				 
12b9 47				ld b, a 
12ba			 
12ba e1				pop hl 
12bb 23				inc hl 
12bc 23				inc hl 
12bd			 
12bd			; TODO not able to handle a-f  
12bd 7e				ld a,(hl) 
12be			;	;cp ':' 
12be			;	cp 'g' 
12be			;	jr nc, .single_byte_hl 		; > 
12be			;	cp 'G' 
12be			;	jr nc, .single_byte_hl 		; > 
12be			;	cp '0' 
12be			;	jr c, .single_byte_hl		; < 
12be			 
12be				;call isdigithl 
12be fe 00			cp 0 
12c0 28 06			jr z, .single_byte_hl 
12c2			 
12c2			.getwhln:   ; hex word so get next byte 
12c2			 
12c2 cd 55 12			call get_byte 
12c5 6f				ld l, a 
12c6 60				ld h,b 
12c7 c9				ret 
12c8 68			.single_byte_hl:   ld l,b 
12c9 26 00				ld h,0 
12cb c9					ret 
12cc			 
12cc			 
12cc			 
12cc			 
12cc 21 30 1c			ld hl,asc+1 
12cf			;	ld a, (hl) 
12cf			;	call nibble2val 
12cf cd 55 12			call get_byte 
12d2			 
12d2			;	call fourehexhl 
12d2 32 33 f2			ld (scratch+52),a 
12d5				 
12d5 21 31 f2			ld hl,scratch+50 
12d8 22 22 f5			ld (os_cur_ptr),hl 
12db			 
12db c9				ret 
12dc			 
12dc			 
12dc			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12dc			 
12dc			; Decimal Unsigned Version 
12dc			 
12dc			;Number in a to decimal ASCII 
12dc			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12dc			;Example: display a=56 as "056" 
12dc			;input: a = number 
12dc			;Output: a=0,value of a in the screen 
12dc			;destroys af,bc (don't know about hl and de) 
12dc			DispAToASCII: 
12dc 0e 9c			ld	c,-100 
12de cd e8 12			call	.Na1 
12e1 0e f6			ld	c,-10 
12e3 cd e8 12			call	.Na1 
12e6 0e ff			ld	c,-1 
12e8 06 2f		.Na1:	ld	b,'0'-1 
12ea 04			.Na2:	inc	b 
12eb 81				add	a,c 
12ec 38 fc			jr	c,.Na2 
12ee 91				sub	c		;works as add 100/10/1 
12ef f5				push af		;safer than ld c,a 
12f0 78				ld	a,b		;char is in b 
12f1			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12f1 f1				pop af		;safer than ld a,c 
12f2 c9				ret 
12f3			 
12f3			; Decimal Signed Version 
12f3			 
12f3			; DispA 
12f3			; -------------------------------------------------------------- 
12f3			; Converts a signed integer value to a zero-terminated ASCII 
12f3			; string representative of that value (using radix 10). 
12f3			; -------------------------------------------------------------- 
12f3			; INPUTS: 
12f3			;     HL     Value to convert (two's complement integer). 
12f3			;     DE     Base address of string destination. (pointer). 
12f3			; -------------------------------------------------------------- 
12f3			; OUTPUTS: 
12f3			;     None 
12f3			; -------------------------------------------------------------- 
12f3			; REGISTERS/MEMORY DESTROYED 
12f3			; AF HL 
12f3			; -------------------------------------------------------------- 
12f3			 
12f3			;DispHLToASCII: 
12f3			;   push    de 
12f3			;   push    bc 
12f3			; 
12f3			;; Detect sign of HL. 
12f3			;    bit    7, h 
12f3			;    jr     z, ._DoConvert 
12f3			; 
12f3			;; HL is negative. Output '-' to string and negate HL. 
12f3			;    ld     a, '-' 
12f3			;    ld     (de), a 
12f3			;    inc    de 
12f3			; 
12f3			;; Negate HL (using two's complement) 
12f3			;    xor    a 
12f3			;    sub    l 
12f3			;    ld     l, a 
12f3			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12f3			;    sbc    a, h 
12f3			;    ld     h, a 
12f3			; 
12f3			;; Convert HL to digit characters 
12f3			;._DoConvert: 
12f3			;    ld     b, 0     ; B will count character length of number 
12f3			;-   ld     a, 10 
12f3			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12f3			;    push   af 
12f3			;    inc    b 
12f3			;    ld     a, h 
12f3			;    or     l 
12f3			;    jr     nz, - 
12f3			; 
12f3			;; Retrieve digits from stack 
12f3			;-   pop    af 
12f3			;    or     $30 
12f3			;    ld     (de), a 
12f3			;    inc    de 
12f3			;    djnz   - 
12f3			; 
12f3			;; Terminate string with NULL 
12f3			;    xor    a 
12f3			;    ld     (de), a 
12f3			; 
12f3			;    pop    bc 
12f3			;    pop    de 
12f3			;    ret 
12f3			 
12f3			;Comments 
12f3			; 
12f3			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12f3			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12f3			;    Note that the output string will not be fixed-width. 
12f3			; 
12f3			;Example Usage 
12f3			; 
12f3			;    ld    hl, -1004 
12f3			;    ld    de, OP1 
12f3			;    call  DispA 
12f3			;    ld    hl, OP1 
12f3			;    syscall  PutS 
12f3			 
12f3			 
12f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f3			 
12f3			 
12f3			;Converts an ASCII string to an unsigned 16-bit integer 
12f3			;Quits when it reaches a non-decimal digit 
12f3			 
12f3			string_to_uint16: 
12f3			atoui_16: 
12f3			;Input: 
12f3			;     DE points to the string 
12f3			;Outputs: 
12f3			;     HL is the result 
12f3			;     A is the 8-bit value of the number 
12f3			;     DE points to the byte after the number 
12f3			;Destroys: 
12f3			;     BC 
12f3			;       if the string is non-empty, BC is HL/10 
12f3			;Size:  24 bytes 
12f3			;Speed: 42+d(104+{0,9}) 
12f3			;       d is the number of digits in the number 
12f3			;       max is 640 cycles for a 5 digit number 
12f3			;Assuming no leading zeros: 
12f3			;1 digit:  146cc 
12f3			;2 digit:  250cc 
12f3			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12f3			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12f3			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12f3			;avg: 544.81158447265625cc (544+13297/16384) 
12f3			;=============================================================== 
12f3 21 00 00		  ld hl,0 
12f6			.u16a: 
12f6 1a			  ld a,(de) 
12f7 d6 30		  sub 30h 
12f9 fe 0a		  cp 10 
12fb d0			  ret nc 
12fc 13			  inc de 
12fd 44			  ld b,h 
12fe 4d			  ld c,l 
12ff 29			  add hl,hl 
1300 29			  add hl,hl 
1301 09			  add hl,bc 
1302 29			  add hl,hl 
1303 85			  add a,l 
1304 6f			  ld l,a 
1305 30 ef		  jr nc,.u16a 
1307 24			  inc h 
1308 c3 f6 12		  jp .u16a 
130b			 
130b			 
130b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
130b			 
130b			;written by Zeda 
130b			;Converts a 16-bit unsigned integer to an ASCII string. 
130b			 
130b			uitoa_16: 
130b			;Input: 
130b			;   DE is the number to convert 
130b			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
130b			;Output: 
130b			;   HL points to the null-terminated ASCII string 
130b			;      NOTE: This isn't necessarily the same as the input HL. 
130b d5			  push de 
130c c5			  push bc 
130d f5			  push af 
130e eb			  ex de,hl 
130f			 
130f 01 f0 d8		  ld bc,-10000 
1312 3e 2f		  ld a,'0'-1 
1314 3c			  inc a 
1315 09			  add hl,bc  
1316 38 fc		   jr c,$-2 
1318 12			  ld (de),a 
1319 13			  inc de 
131a			 
131a 01 e8 03		  ld bc,1000 
131d 3e 3a		  ld a,'9'+1 
131f 3d			  dec a  
1320 09			  add hl,bc  
1321 30 fc		   jr nc,$-2 
1323 12			  ld (de),a 
1324 13			  inc de 
1325			 
1325 01 9c ff		  ld bc,-100 
1328 3e 2f		  ld a,'0'-1 
132a 3c			  inc a  
132b 09			  add hl,bc  
132c 38 fc		   jr c,$-2 
132e 12			  ld (de),a 
132f 13			  inc de 
1330			 
1330 7d			  ld a,l 
1331 26 3a		  ld h,'9'+1 
1333 25			  dec h  
1334 c6 0a		  add a,10  
1336 30 fb		   jr nc,$-3 
1338 c6 30		  add a,'0' 
133a eb			  ex de,hl 
133b 72			  ld (hl),d 
133c 23			  inc hl 
133d 77			  ld (hl),a 
133e 23			  inc hl 
133f 36 00		  ld (hl),0 
1341			 
1341			;Now strip the leading zeros 
1341 0e fa		  ld c,-6 
1343 09			  add hl,bc 
1344 3e 30		  ld a,'0' 
1346 23			  inc hl  
1347 be			  cp (hl)  
1348 28 fc		  jr z,$-2 
134a			 
134a			;Make sure that the string is non-empty! 
134a 7e			  ld a,(hl) 
134b b7			  or a 
134c 20 01		  jr nz,.atoub 
134e 2b			  dec hl 
134f			.atoub: 
134f			 
134f f1			  pop af 
1350 c1			  pop bc 
1351 d1			  pop de 
1352 c9			  ret 
1353			 
1353			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1353			 
1353			toUpper: 
1353			;A is the char. 
1353			;If A is a lowercase letter, this sets it to the matching uppercase 
1353			;18cc or 30cc or 41cc 
1353			;avg: 26.75cc 
1353 fe 61		  cp 'a' 
1355 d8			  ret c 
1356 fe 7b		  cp 'z'+1 
1358 d0			  ret nc 
1359 d6 20		  sub 'a'-'A' 
135b c9			  ret 
135c			 
135c			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
135c			 
135c			; String Length 
135c			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
135c			 
135c			; Get the length of the null-terminated string starting at $8000 hl 
135c			;    LD     HL, $8000 
135c			 
135c			strlenz: 
135c			 
135c af			    XOR    A               ; Zero is the value we are looking for. 
135d 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
135e 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
135f			                           ; 65, 536 bytes (the entire addressable memory space). 
135f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1361			 
1361			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1361 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1362 6f			    LD     L, A             ; number of bytes 
1363 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1365 2b			    DEC    HL              ; Compensate for null. 
1366 c9				ret 
1367			 
1367			; Get the length of the A terminated string starting at $8000 hl 
1367			;    LD     HL, $8000 
1367			 
1367			strlent: 
1367			 
1367			                  ; A is the value we are looking for. 
1367 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1369 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
136b			                           ; 65, 536 bytes (the entire addressable memory space). 
136b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
136d			 
136d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
136d 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
136f 2e 00		    LD     L, 0             ; number of bytes 
1371 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1373 2b			    DEC    HL              ; Compensate for null. 
1374 c9				ret 
1375			 
1375			 
1375			;Comparing Strings 
1375			 
1375			;IN    HL     Address of string1. 
1375			;      DE     Address of string2. 
1375			 
1375			; doc given but wrong??? 
1375			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1375			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1375			; tested 
1375			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1375			 
1375			strcmp_old: 
1375 e5			    PUSH   HL 
1376 d5			    PUSH   DE 
1377			 
1377 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1378 be			    CP     (HL)            ; (want to minimize work). 
1379 38 01		    JR     C, Str1IsBigger 
137b 7e			    LD     A, (HL) 
137c			 
137c			Str1IsBigger: 
137c 4f			    LD     C, A             ; Put length in BC 
137d 06 00		    LD     B, 0 
137f 13			    INC    DE              ; Increment pointers to meat of string. 
1380 23			    INC    HL 
1381			 
1381			CmpLoop: 
1381 1a			    LD     A, (DE)          ; Compare bytes. 
1382 ed a1		    CPI 
1384 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1386 13			    INC    DE              ; Update pointer. 
1387 ea 81 13		    JP     PE, CmpLoop 
138a			 
138a d1			    POP    DE 
138b e1			    POP    HL 
138c 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
138d be			    CP     (HL) 
138e c9			    RET 
138f			 
138f			NoMatch: 
138f 2b			    DEC    HL 
1390 be			    CP     (HL)            ; Compare again to affect carry. 
1391 d1			    POP    DE 
1392 e1			    POP    HL 
1393 c9			    RET 
1394			 
1394			;; test strmp 
1394			; 
1394			;ld de, .str1 
1394			;ld hl, .str2 
1394			;call strcmp 
1394			;jr z, .z1 
1394			;;this 
1394			;	if DEBUG_FORTH_WORDS 
1394			;		DMARK "NZ1" 
1394			;		CALLMONITOR 
1394			;	endif 
1394			;.z1: 
1394			; 
1394			;	if DEBUG_FORTH_WORDS 
1394			;		DMARK "ZZ1" 
1394			;		CALLMONITOR 
1394			;	endif 
1394			; 
1394			;ld de, .str1 
1394			;ld hl, .str1 
1394			;call strcmp 
1394			;jr z, .z2 
1394			;;this 
1394			;	if DEBUG_FORTH_WORDS 
1394			;		DMARK "NZ2" 
1394			;		CALLMONITOR 
1394			;	endif 
1394			;.z2: 
1394			; 
1394			;	if DEBUG_FORTH_WORDS 
1394			;		DMARK "ZZ2" 
1394			;		CALLMONITOR 
1394			;	endif 
1394			; 
1394			;ld de, .str1 
1394			;ld hl, .str2 
1394			;call strcmp 
1394			;jr c, .c1 
1394			; 
1394			;	if DEBUG_FORTH_WORDS 
1394			;		DMARK "Nc1" 
1394			;		CALLMONITOR 
1394			;	endif 
1394			;.c1: 
1394			;;this 
1394			;	if DEBUG_FORTH_WORDS 
1394			;		DMARK "cc1" 
1394			;		CALLMONITOR 
1394			;	endif 
1394			; 
1394			;ld de, .str1 
1394			;ld hl, .str1 
1394			;call strcmp 
1394			;jr c, .c2 
1394			;;this 
1394			;	if DEBUG_FORTH_WORDS 
1394			;		DMARK "Nc2" 
1394			;		CALLMONITOR 
1394			;	endif 
1394			;.c2: 
1394			; 
1394			;	if DEBUG_FORTH_WORDS 
1394			;		DMARK "cc2" 
1394			;		CALLMONITOR 
1394			;	endif 
1394			;	NEXTW 
1394			;.str1:   db "string1",0 
1394			;.str2:   db "string2",0 
1394			 
1394			; only care about direct match or not 
1394			; hl and de strings 
1394			; zero set if the same 
1394			 
1394			strcmp: 
1394 1a				ld a, (de) 
1395 be				cp (hl) 
1396 28 02			jr z, .ssame 
1398 b7				or a 
1399 c9				ret 
139a			 
139a			.ssame:  
139a fe 00			cp 0 
139c c8				ret z 
139d			 
139d 23				inc hl 
139e 13				inc de 
139f 18 f3			jr strcmp 
13a1				 
13a1				 
13a1			 
13a1			 
13a1			 
13a1			 
13a1			; eof 
13a1			 
13a1			 
13a1			 
13a1			 
13a1			 
13a1			 
# End of file firmware_strings.asm
13a1			include "firmware_memory.asm"   ; malloc and free  
13a1			 
13a1			if DEBUG_FORTH_MALLOC_HIGH 
13a1			.mallocsize: db "Wants malloc >256",0 
13a1			.mallocasize: db "MALLOC gives >256",0 
13a1			.malloczero: db "MALLOC gives zero",0 
13a1			 
13a1			malloc_guard_zerolen: 
13a1				push hl 
13a1				push de 
13a1				push af 
13a1			 
13a1				ld de, 0 
13a1			        call cmp16 
13a1				jr nz, .lowalloz 
13a1			 
13a1				push hl 
13a1				push de 
13a1					ld hl, display_fb0 
13a1					ld (display_fb_active), hl 
13a1				call clear_display 
13a1				ld a, 0 
13a1				ld de, .malloczero 
13a1				call str_at_display 
13a1				call update_display 
13a1				call delay1s 
13a1				call delay1s 
13a1				ld a, 0 
13a1				ld (os_view_disable), a 
13a1			 
13a1				pop de 
13a1				pop hl 
13a1			 
13a1				 
13a1			 
13a1				CALLMONITOR 
13a1			.lowalloz: 
13a1			 
13a1			 
13a1				pop af 
13a1				pop de 
13a1				pop hl 
13a1			ret 
13a1			 
13a1			malloc_guard_entry: 
13a1				push hl 
13a1				push de 
13a1				push af 
13a1			 
13a1			 	or a      ;clear carry flag 
13a1				push hl 
13a1				ld de, 255 
13a1				sbc hl, de 
13a1				jr c, .lowalloc 
13a1			 
13a1				push de 
13a1					ld hl, display_fb0 
13a1					ld (display_fb_active), hl 
13a1				call clear_display 
13a1				ld a, 0 
13a1				ld de, .mallocsize 
13a1				call str_at_display 
13a1				call update_display 
13a1				call delay1s 
13a1				call delay1s 
13a1				ld a, 0 
13a1				ld (os_view_disable), a 
13a1			 
13a1				pop de 
13a1				pop hl 
13a1			 
13a1				 
13a1			 
13a1				CALLMONITOR 
13a1				jr .lowdone 
13a1			.lowalloc: 
13a1			 
13a1			 
13a1				pop hl 
13a1			.lowdone:	pop af 
13a1				pop de 
13a1				pop hl 
13a1			ret 
13a1			 
13a1			malloc_guard_exit: 
13a1				push hl 
13a1				push de 
13a1				push af 
13a1			 
13a1			 	or a      ;clear carry flag 
13a1				push hl 
13a1				ld de, 255 
13a1				sbc hl, de 
13a1				jr c, .lowallocx 
13a1			 
13a1				push de 
13a1					ld hl, display_fb0 
13a1					ld (display_fb_active), hl 
13a1				call clear_display 
13a1				ld a, 0 
13a1				ld de, .mallocasize 
13a1				call str_at_display 
13a1				call update_display 
13a1				call delay1s 
13a1				call delay1s 
13a1				ld a, 0 
13a1				ld (os_view_disable), a 
13a1				pop de 
13a1				pop hl 
13a1			 
13a1				CALLMONITOR 
13a1				jr .lowdonex 
13a1			.lowallocx: 
13a1			 
13a1				pop hl 
13a1			.lowdonex:	pop af 
13a1				pop de 
13a1				pop hl 
13a1			ret 
13a1			endif 
13a1			 
13a1			if MALLOC_2 
13a1			; Z80 Malloc and Free Functions 
13a1			 
13a1			; Malloc Function: 
13a1			; Input: 
13a1			;   HL: Size of block to allocate 
13a1			; Output: 
13a1			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13a1			 
13a1			malloc: 
13a1				 
13a1			if DEBUG_FORTH_MALLOC_HIGH 
13a1			call malloc_guard_entry 
13a1			endif 
13a1			 
13a1			 
13a1			 
13a1			 
13a1					if DEBUG_FORTH_MALLOC 
13a1						DMARK "mal" 
13a1						CALLMONITOR 
13a1					endif 
13a1			    push af            ; Save AF register 
13a1			    ld a, l            ; Load low byte of size into A 
13a1			    or h               ; Check if size is zero 
13a1			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13a1			 
13a1			    ; Allocate memory 
13a1			    ld hl, (heap_start) ; Load start of heap into HL 
13a1					if DEBUG_FORTH_MALLOC 
13a1						DMARK "ma1" 
13a1						CALLMONITOR 
13a1					endif 
13a1			    call malloc_internal ; Call internal malloc function 
13a1			    pop af             ; Restore AF register 
13a1			if DEBUG_FORTH_MALLOC_HIGH 
13a1			call malloc_guard_exit 
13a1			call malloc_guard_zerolen 
13a1			endif 
13a1			    ret                ; Return 
13a1			 
13a1			; Free Function: 
13a1			; Input: 
13a1			;   HL: Pointer to memory block to free 
13a1			; Output: 
13a1			;   None 
13a1			 
13a1			free: 
13a1			    push af            ; Save AF register 
13a1			    ld a, l            ; Load low byte of pointer into A 
13a1			    or h               ; Check if pointer is NULL 
13a1			    jp z, free_exit    ; If pointer is NULL, exit 
13a1			 
13a1			    ; Free memory 
13a1			    ld hl, (heap_start) ; Load start of heap into HL 
13a1			    call free_internal  ; Call internal free function 
13a1			    pop af             ; Restore AF register 
13a1			    ret                ; Return 
13a1			 
13a1			; Internal Malloc Function: 
13a1			; Input: 
13a1			;   HL: Size of block to allocate 
13a1			; Output: 
13a1			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13a1			 
13a1			malloc_internal: 
13a1			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13a1			    add hl, bc         ; Add management overhead to requested size 
13a1			    ex de, hl          ; Save total size in DE, and keep it in HL 
13a1					if DEBUG_FORTH_MALLOC 
13a1						DMARK "ma2" 
13a1						CALLMONITOR 
13a1					endif 
13a1			 
13a1			    ; Search for free memory block 
13a1			    ld de, (heap_end)  ; Load end of heap into DE 
13a1			    ld bc, 0           ; Initialize counter 
13a1			 
13a1					if DEBUG_FORTH_MALLOC 
13a1						DMARK "ma2" 
13a1						CALLMONITOR 
13a1					endif 
13a1			malloc_search_loop: 
13a1			    ; Check if current block is free 
13a1			    ld a, (hl)         ; Load current block's status (free or used) 
13a1			    cp 0               ; Compare with zero (free) 
13a1			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13a1			 
13a1			    ; Check if current block is large enough 
13a1			    ld a, (hl+1)       ; Load high byte of block size 
13a1			    cp l               ; Compare with low byte of requested size 
13a1			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13a1			 
13a1			    ld a, (hl+2)       ; Load low byte of block size 
13a1			    cp h               ; Compare with high byte of requested size 
13a1			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13a1			 
13a1			    ; Mark block as used 
13a1			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13a1			 
13a1			    ; Calculate remaining space in block 
13a1			    ld bc, 0           ; Clear BC 
13a1			    add hl, bc         ; Increment HL to point to start of data block 
13a1			    add hl, de         ; HL = HL + DE (total size) 
13a1			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13a1			    add hl, bc         ; Add management overhead to start of data block 
13a1			 
13a1			    ; Save pointer to allocated block in HL 
13a1			if DEBUG_FORTH_MALLOC_HIGH 
13a1						DMARK "ma5" 
13a1			call malloc_guard_exit 
13a1			call malloc_guard_zerolen 
13a1			endif 
13a1			    ret 
13a1			 
13a1			malloc_skip_block_check: 
13a1			    ; Move to the next block 
13a1			    ld bc, 3           ; Size of management overhead 
13a1			    add hl, bc         ; Move to the next block 
13a1			    inc de             ; Increment counter 
13a1			 
13a1			    ; Check if we have reached the end of heap 
13a1			    ld a, e            ; Load low byte of heap end address 
13a1			    cp (hl)            ; Compare with low byte of current address 
13a1			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13a1			    ld a, d            ; Load high byte of heap end address 
13a1			    cp 0               ; Check if it's zero (end of memory) 
13a1			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13a1			 
13a1			    ; If we reached here, allocation failed 
13a1			    xor a              ; Set result to NULL 
13a1			if DEBUG_FORTH_MALLOC_HIGH 
13a1						DMARK "ma6" 
13a1			call malloc_guard_exit 
13a1			call malloc_guard_zerolen 
13a1			endif 
13a1			    ret 
13a1			malloc_exit: 
13a1			if DEBUG_FORTH_MALLOC_HIGH 
13a1						DMARK "ma7" 
13a1			call malloc_guard_exit 
13a1			call malloc_guard_zerolen 
13a1			endif 
13a1			    ret 
13a1			 
13a1			; Internal Free Function: 
13a1			; Input: 
13a1			;   HL: Pointer to memory block to free 
13a1			; Output: 
13a1			;   None 
13a1			 
13a1			free_internal: 
13a1			    ld de, (heap_start) ; Load start of heap into DE 
13a1			    ld bc, 0            ; Initialize counter 
13a1			 
13a1			free_search_loop: 
13a1			    ; Check if current block contains the pointer 
13a1			    ld a, l             ; Load low byte of pointer 
13a1			    cp (hl+1)           ; Compare with high byte of current block's address 
13a1			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13a1			    ld a, h             ; Load high byte of pointer 
13a1			    cp (hl+2)           ; Compare with low byte of current block's address 
13a1			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13a1			 
13a1			    ; Mark block as free 
13a1			    ld (hl), 0          ; Set status byte to indicate free block 
13a1			    ret                 ; Return 
13a1			 
13a1			free_skip_block_check: 
13a1			    ; Move to the next block 
13a1			    ld bc, 3            ; Size of management overhead 
13a1			    add hl, bc          ; Move to the next block 
13a1			    inc de              ; Increment counter 
13a1			 
13a1			    ; Check if we have reached the end of heap 
13a1			    ld a, e             ; Load low byte of heap end address 
13a1			    cp (hl)             ; Compare with low byte of current address 
13a1			    jr nz, free_search_loop  ; If not equal, continue searching 
13a1			    ld a, d             ; Load high byte of heap end address 
13a1			    cp 0                ; Check if it's zero (end of memory) 
13a1			    jr nz, free_search_loop  ; If not zero, continue searching 
13a1			 
13a1			    ; If we reached here, pointer is not found in heap 
13a1			    ret 
13a1			 
13a1			free_exit: 
13a1			    ret                 ; Return 
13a1			 
13a1			; Define heap start and end addresses 
13a1			;heap_start:    .dw 0xC000   ; Start of heap 
13a1			;heap_end:      .dw 0xE000   ; End of heap 
13a1			 
13a1			endif 
13a1			 
13a1			 
13a1			if MALLOC_1 
13a1			 
13a1			 
13a1			 
13a1			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13a1			 
13a1			;moved to firmware.asm 
13a1			;heap_start        .equ  0x9000      ; Starting address of heap 
13a1			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13a1			 
13a1			;      .org 0 
13a1			;      jp    main 
13a1			 
13a1			 
13a1			;      .org  0x100 
13a1			;main: 
13a1			;      ld    HL, 0x8100 
13a1			;      ld    SP, HL 
13a1			; 
13a1			;      call  heap_init 
13a1			; 
13a1			;      ; Make some allocations 
13a1			;      ld    HL, 12 
13a1			;      call  malloc            ; Allocates 0x9004 
13a1			; 
13a1			;      ld    HL, 12 
13a1			;      call  malloc            ; Allocates 0x9014 
13a1			; 
13a1			;      ld    HL, 12 
13a1			;      call  malloc            ; Allocates 0x9024 
13a1			; 
13a1			;      ; Free some allocations 
13a1			;      ld    HL, 0x9014 
13a1			;      call  free 
13a1			; 
13a1			;      ld    HL, 0x9004 
13a1			;      call  free 
13a1			; 
13a1			;      ld    HL, 0x9024 
13a1			;      call  free 
13a1			; 
13a1			; 
13a1			;      halt 
13a1			 
13a1			 
13a1			;------------------------------------------------------------------------------ 
13a1			;     heap_init                                                               : 
13a1			;                                                                             : 
13a1			; Description                                                                 : 
13a1			;     Initialise the heap and make it ready for malloc and free operations.   : 
13a1			;                                                                             : 
13a1			;     The heap is maintained as a linked list, starting with an initial       : 
13a1			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13a1			;     the first free block in the heap. Each block then points to the next    : 
13a1			;     free block within the heap, and the free list ends at the first block   : 
13a1			;     with a null pointer to the next free block.                             : 
13a1			;                                                                             : 
13a1			; Parameters                                                                  : 
13a1			;     Inputs are compile-time only. Two defines which specify the starting    : 
13a1			;     address of the heap and its size are required, along with a memory      : 
13a1			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13a1			;     principally stores a pointer to the first free block in the heap.       : 
13a1			;                                                                             : 
13a1			; Returns                                                                     : 
13a1			;     Nothing                                                                 : 
13a1			;------------------------------------------------------------------------------ 
13a1			heap_init: 
13a1 e5			      push  HL 
13a2			 
13a2			      ; Initialise free list struct 
13a2 21 0e 80		      ld    HL, heap_start 
13a5 22 0a 80		      ld    (free_list), HL 
13a8 21 00 00		      ld    HL, 0 
13ab 22 0c 80		      ld    (free_list+2), HL 
13ae			 
13ae			      ; Insert first free block at bottom of heap, consumes entire heap 
13ae 21 e1 f1		      ld    HL, heap_start+heap_size-4 
13b1 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13b4 21 d3 71		      ld    HL, heap_size-4 
13b7 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ba			 
13ba			      ; Insert end of free list block at top of heap - two null words will 
13ba			      ; terminate the free list 
13ba 21 00 00		      ld    HL, 0 
13bd 22 e3 f1		      ld    (heap_start+heap_size-2), HL 
13c0 22 e1 f1		      ld    (heap_start+heap_size-4), HL 
13c3			 
13c3 e1			      pop   HL 
13c4			 
13c4 c9			      ret 
13c5			 
13c5			 
13c5			;------------------------------------------------------------------------------ 
13c5			;     malloc                                                                  : 
13c5			;                                                                             : 
13c5			; Description                                                                 : 
13c5			;     Allocates the wanted space from the heap and returns the address of the : 
13c5			;     first useable byte of the allocation.                                   : 
13c5			;                                                                             : 
13c5			;     Allocations can happen in one of two ways:                              : 
13c5			;                                                                             : 
13c5			;     1. A free block may be found which is the exact size wanted. In this    : 
13c5			;        case the block is removed from the free list and retuedn to the      : 
13c5			;        caller.                                                              : 
13c5			;     2. A free block may be found which is larger than the size wanted. In   : 
13c5			;        this case, the larger block is split into two. The first portion of  : 
13c5			;        this block will become the requested space by the malloc call and    : 
13c5			;        is returned to the caller. The second portion becomes a new free     : 
13c5			;        block, and the free list is adjusted to maintain continuity via this : 
13c5			;        newly created block.                                                 : 
13c5			;                                                                             : 
13c5			;     malloc does not set any initial value in the allocated space, the       : 
13c5			;     caller is required to do this as required.                              : 
13c5			;                                                                             : 
13c5			;     This implementation of malloc uses the stack exclusively, and is        : 
13c5			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13c5			;     advisable to disable interrupts before calling malloc, and recommended  : 
13c5			;     to avoid the use of malloc inside ISRs in general.                      : 
13c5			;                                                                             : 
13c5			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13c5			;                                                                             : 
13c5			; Parameters                                                                  : 
13c5			;     HL  Number of bytes wanted                                              : 
13c5			;                                                                             : 
13c5			; Returns                                                                     : 
13c5			;     HL  Address of the first useable byte of the allocation                 : 
13c5			;                                                                             : 
13c5			; Flags                                                                       : 
13c5			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13c5			;                                                                             : 
13c5			; Stack frame                                                                 : 
13c5			;       |             |                                                       : 
13c5			;       +-------------+                                                       : 
13c5			;       |     BC      |                                                       : 
13c5			;       +-------------+                                                       : 
13c5			;       |     DE      |                                                       : 
13c5			;       +-------------+                                                       : 
13c5			;       |     IX      |                                                       : 
13c5			;       +-------------+                                                       : 
13c5			;       |  prev_free  |                                                       : 
13c5			;   +4  +-------------+                                                       : 
13c5			;       |  this_free  |                                                       : 
13c5			;   +2  +-------------+                                                       : 
13c5			;       |  next_free  |                                                       : 
13c5			;   +0  +-------------+                                                       : 
13c5			;       |             |                                                       : 
13c5			;                                                                             : 
13c5			;------------------------------------------------------------------------------ 
13c5			 
13c5			 
13c5			;malloc: 
13c5			; 
13c5			;	SAVESP ON 1 
13c5			; 
13c5			;	call malloc_code 
13c5			; 
13c5			;	CHECKSP ON 1 
13c5			;	ret 
13c5			 
13c5			 
13c5			malloc: 
13c5 c5			      push  BC 
13c6 d5			      push  DE 
13c7 dd e5		      push  IX 
13c9			if DEBUG_FORTH_MALLOC_HIGH 
13c9			call malloc_guard_entry 
13c9			endif 
13c9			 
13c9					if DEBUG_FORTH_MALLOC 
13c9						DMARK "mal" 
13c9						CALLMONITOR 
13c9					endif 
13c9 7c			      ld    A, H                    ; Exit if no space requested 
13ca b5			      or    L 
13cb ca 8a 14		      jp    Z, malloc_early_exit 
13ce			 
13ce			;inc hl 
13ce			;inc hl 
13ce			;inc hl 
13ce			; 
13ce			;inc hl 
13ce			;inc hl 
13ce			;inc hl 
13ce			;inc hl 
13ce			;inc hl 
13ce			;inc hl 
13ce			;inc hl 
13ce			;inc hl 
13ce			;inc hl 
13ce			 
13ce			 
13ce			 
13ce			 
13ce					if DEBUG_FORTH_MALLOC 
13ce						DMARK "maA" 
13ce						CALLMONITOR 
13ce					endif 
13ce			      ; Set up stack frame 
13ce eb			      ex    DE, HL 
13cf 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13d2 39			      add   HL, SP 
13d3 f9			      ld    SP, HL 
13d4 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13d8 dd 39		      add   IX, SP 
13da			 
13da			      ; Setup initial state 
13da 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13dd 19			      add   HL, DE 
13de			 
13de 44			      ld    B, H                    ; Move want to BC 
13df 4d			      ld    C, L 
13e0			 
13e0 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13e3 dd 75 04		      ld    (IX+4), L 
13e6 dd 74 05		      ld    (IX+5), H 
13e9			 
13e9 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13ea 23			      inc   HL 
13eb 56			      ld    D, (HL) 
13ec dd 73 02		      ld    (IX+2), E 
13ef dd 72 03		      ld    (IX+3), D 
13f2 eb			      ex    DE, HL                  ; this_free ptr into HL 
13f3			 
13f3					if DEBUG_FORTH_MALLOC 
13f3						DMARK "maB" 
13f3						CALLMONITOR 
13f3					endif 
13f3			      ; Loop through free block list to find some space 
13f3			malloc_find_space: 
13f3 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13f4 23			      inc   HL 
13f5 56			      ld    D, (HL) 
13f6			 
13f6 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13f7 b3			      or    E 
13f8 ca 84 14		      jp    Z, malloc_no_space 
13fb			 
13fb dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13fe dd 72 01		      ld    (IX+1), D 
1401			 
1401			      ; Does this block have enough space to make the allocation? 
1401 23			      inc   HL                      ; Load free block size into DE 
1402 5e			      ld    E, (HL) 
1403 23			      inc   HL 
1404 56			      ld    D, (HL) 
1405			 
1405 eb			      ex    DE, HL                  ; Check size of block against want 
1406 b7			      or    A                       ; Ensure carry flag clear 
1407 ed 42		      sbc   HL, BC 
1409 e5			      push  HL                      ; Store the result for later (new block size) 
140a			 
140a ca 59 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
140d 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
140f			 
140f			      ; this_free block is not big enough, setup ptrs to test next free block 
140f e1			      pop   HL                      ; Discard previous result 
1410			 
1410 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1413 dd 66 03		      ld    H, (IX+3) 
1416 dd 75 04		      ld    (IX+4), L 
1419 dd 74 05		      ld    (IX+5), H 
141c			 
141c dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
141f dd 66 01		      ld    H, (IX+1) 
1422 dd 75 02		      ld    (IX+2), L 
1425 dd 74 03		      ld    (IX+3), H 
1428			 
1428					if DEBUG_FORTH_MALLOC 
1428						DMARK "MA>" 
1428						CALLMONITOR 
1428					endif 
1428 18 c9		      jr    malloc_find_space 
142a			 
142a			      ; split a bigger block into two - requested size and remaining size 
142a			malloc_alloc_split: 
142a					if DEBUG_FORTH_MALLOC 
142a						DMARK "MAs" 
142a						CALLMONITOR 
142a					endif 
142a eb			      ex    DE, HL                  ; Calculate address of new free block 
142b 2b			      dec   HL 
142c 2b			      dec   HL 
142d 2b			      dec   HL 
142e 09			      add   HL, BC 
142f			 
142f			      ; Create a new block and point it at next_free 
142f dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1432 dd 56 01		      ld    D, (IX+1) 
1435			 
1435 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1436 23			      inc   HL 
1437 72			      ld    (HL), D 
1438			 
1438 d1			      pop   DE                      ; Store size of new block into new block 
1439 23			      inc   HL 
143a 73			      ld    (HL), E 
143b 23			      inc   HL 
143c 72			      ld    (HL), D 
143d			 
143d			      ; Update this_free ptr to point to new block 
143d 2b			      dec   HL 
143e 2b			      dec   HL 
143f 2b			      dec   HL 
1440			 
1440 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1443 dd 56 03		      ld    D, (IX+3) 
1446			 
1446 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1449 dd 74 03		      ld    (IX+3), H 
144c			 
144c			      ; Modify this_free block to be allocation 
144c eb			      ex    DE, HL 
144d af			      xor   A                       ; Null the next block ptr of allocated block 
144e 77			      ld    (HL), A 
144f 23			      inc   HL 
1450 77			      ld    (HL), A 
1451			 
1451 23			      inc   HL                      ; Store want size into allocated block 
1452 71			      ld    (HL), C 
1453 23			      inc   HL 
1454 70			      ld    (HL), B 
1455 23			      inc   HL 
1456 e5			      push  HL                      ; Address of allocation to return 
1457			 
1457 18 19		      jr    malloc_update_links 
1459			 
1459			malloc_alloc_fit: 
1459 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
145a			 
145a					if DEBUG_FORTH_MALLOC 
145a						DMARK "MAf" 
145a						CALLMONITOR 
145a					endif 
145a			      ; Modify this_free block to be allocation 
145a eb			      ex    DE, HL 
145b 2b			      dec   HL 
145c 2b			      dec   HL 
145d 2b			      dec   HL 
145e			 
145e af			      xor   A                       ; Null the next block ptr of allocated block 
145f 77			      ld    (HL), A 
1460 23			      inc   HL 
1461 77			      ld    (HL), A 
1462			 
1462 23			      inc   HL                      ; Store address of allocation to return 
1463 23			      inc   HL 
1464 23			      inc   HL 
1465 e5			      push  HL 
1466			 
1466			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1466 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1469 dd 66 01		      ld    H, (IX+1) 
146c			 
146c dd 75 02		      ld    (IX+2), L               ; HL to this_free 
146f dd 74 03		      ld    (IX+3), H 
1472			 
1472			 
1472			malloc_update_links: 
1472			      ; Update prev_free ptr to point to this_free 
1472 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1475 dd 66 05		      ld    H, (IX+5) 
1478			 
1478 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
147b dd 56 03		      ld    D, (IX+3) 
147e			 
147e 73			      ld    (HL), E                 ; this_free ptr into prev_free 
147f 23			      inc   HL 
1480 72			      ld    (HL), D 
1481			 
1481					if DEBUG_FORTH_MALLOC 
1481						DMARK "Mul" 
1481						CALLMONITOR 
1481					endif 
1481			      ; Clear the Z flag to indicate successful allocation 
1481 7a			      ld    A, D 
1482 b3			      or    E 
1483			 
1483 d1			      pop   DE                      ; Address of allocation 
1484					if DEBUG_FORTH_MALLOC 
1484						DMARK "MAu" 
1484						CALLMONITOR 
1484					endif 
1484			 
1484			malloc_no_space: 
1484 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1487 39			      add   HL, SP 
1488 f9			      ld    SP, HL 
1489			 
1489 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
148a					if DEBUG_FORTH_MALLOC 
148a						DMARK "MAN" 
148a						CALLMONITOR 
148a					endif 
148a			 
148a			malloc_early_exit: 
148a					if DEBUG_FORTH_MALLOC 
148a						DMARK "MAx" 
148a						CALLMONITOR 
148a					endif 
148a dd e1		      pop   IX 
148c d1			      pop   DE 
148d c1			      pop   BC 
148e			 
148e			if DEBUG_FORTH_MALLOC_HIGH 
148e			call malloc_guard_exit 
148e			call malloc_guard_zerolen 
148e			endif 
148e c9			      ret 
148f			 
148f			 
148f			;------------------------------------------------------------------------------ 
148f			;     free                                                                    : 
148f			;                                                                             : 
148f			; Description                                                                 : 
148f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
148f			;     returned by malloc, otherwise the behaviour is undefined.               : 
148f			;                                                                             : 
148f			;     Where possible, directly adjacent free blocks will be merged together   : 
148f			;     into larger blocks to help ensure that the heap does not become         : 
148f			;     excessively fragmented.                                                 : 
148f			;                                                                             : 
148f			;     free does not clear or set any other value into the freed space, and    : 
148f			;     therefore its contents may be visible through subsequent malloc's. The  : 
148f			;     caller should clear the freed space as required.                        : 
148f			;                                                                             : 
148f			;     This implementation of free uses the stack exclusively, and is          : 
148f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
148f			;     advisable to disable interrupts before calling free, and recommended    : 
148f			;     to avoid the use of free inside ISRs in general.                        : 
148f			;                                                                             : 
148f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
148f			;                                                                             : 
148f			; Parameters                                                                  : 
148f			;     HL  Pointer to address of first byte of allocation to be freed          : 
148f			;                                                                             : 
148f			; Returns                                                                     : 
148f			;     Nothing                                                                 : 
148f			;                                                                             : 
148f			; Stack frame                                                                 : 
148f			;       |             |                                                       : 
148f			;       +-------------+                                                       : 
148f			;       |     BC      |                                                       : 
148f			;       +-------------+                                                       : 
148f			;       |     DE      |                                                       : 
148f			;       +-------------+                                                       : 
148f			;       |     IX      |                                                       : 
148f			;       +-------------+                                                       : 
148f			;       |  prev_free  |                                                       : 
148f			;   +2  +-------------+                                                       : 
148f			;       |  next_free  |                                                       : 
148f			;   +0  +-------------+                                                       : 
148f			;       |             |                                                       : 
148f			;                                                                             : 
148f			;------------------------------------------------------------------------------ 
148f			free: 
148f c5			      push  BC 
1490 d5			      push  DE 
1491 dd e5		      push  IX 
1493			 
1493 7c			      ld    A, H                    ; Exit if ptr is null 
1494 b5			      or    L 
1495 ca 59 15		      jp    Z, free_early_exit 
1498			 
1498			      ; Set up stack frame 
1498 eb			      ex    DE, HL 
1499 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
149c 39			      add   HL, SP 
149d f9			      ld    SP, HL 
149e dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14a2 dd 39		      add   IX, SP 
14a4			 
14a4			      ; The address in HL points to the start of the useable allocated space, 
14a4			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14a4			      ; address of the block itself. 
14a4 eb			      ex    DE, HL 
14a5 11 fc ff		      ld    DE, -4 
14a8 19			      add   HL, DE 
14a9			 
14a9			      ; An allocated block must have a null next block pointer in it 
14a9 7e			      ld    A, (HL) 
14aa 23			      inc   HL 
14ab b6			      or    (HL) 
14ac c2 54 15		      jp    NZ, free_done 
14af			 
14af 2b			      dec   HL 
14b0			 
14b0 44			      ld    B, H                    ; Copy HL to BC 
14b1 4d			      ld    C, L 
14b2			 
14b2			      ; Loop through the free list to find the first block with an address 
14b2			      ; higher than the block being freed 
14b2 21 0a 80		      ld    HL, free_list 
14b5			 
14b5			free_find_higher_block: 
14b5 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14b6 23			      inc   HL 
14b7 56			      ld    D, (HL) 
14b8 2b			      dec   HL 
14b9			 
14b9 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14bc dd 72 01		      ld    (IX+1), D 
14bf dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14c2 dd 74 03		      ld    (IX+3), H 
14c5			 
14c5 78			      ld    A, B                    ; Check if DE is greater than BC 
14c6 ba			      cp    D                       ; Compare MSB first 
14c7 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14c9 30 04		      jr    NC, free_find_higher_block_skip 
14cb 79			      ld    A, C 
14cc bb			      cp    E                       ; Then compare LSB 
14cd 38 08		      jr    C, free_found_higher_block 
14cf			 
14cf			free_find_higher_block_skip: 
14cf 7a			      ld    A, D                    ; Reached the end of the free list? 
14d0 b3			      or    E 
14d1 ca 54 15		      jp    Z, free_done 
14d4			 
14d4 eb			      ex    DE, HL 
14d5			 
14d5 18 de		      jr    free_find_higher_block 
14d7			 
14d7			free_found_higher_block: 
14d7			      ; Insert freed block between prev and next free blocks 
14d7 71			      ld    (HL), C                 ; Point prev free block to freed block 
14d8 23			      inc   HL 
14d9 70			      ld    (HL), B 
14da			 
14da 60			      ld    H, B                    ; Point freed block at next free block 
14db 69			      ld    L, C 
14dc 73			      ld    (HL), E 
14dd 23			      inc   HL 
14de 72			      ld    (HL), D 
14df			 
14df			      ; Check if the freed block is adjacent to the next free block 
14df 23			      inc   HL                      ; Load size of freed block into HL 
14e0 5e			      ld    E, (HL) 
14e1 23			      inc   HL 
14e2 56			      ld    D, (HL) 
14e3 eb			      ex    DE, HL 
14e4			 
14e4 09			      add   HL, BC                  ; Add addr of freed block and its size 
14e5			 
14e5 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14e8 dd 56 01		      ld    D, (IX+1) 
14eb			 
14eb b7			      or    A                       ; Clear the carry flag 
14ec ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14ee 20 22		      jr    NZ, free_check_adjacent_to_prev 
14f0			 
14f0			      ; Freed block is adjacent to next, merge into one bigger block 
14f0 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14f1 5e			      ld    E, (HL) 
14f2 23			      inc   HL 
14f3 56			      ld    D, (HL) 
14f4 e5			      push  HL                      ; Save ptr to next block for later 
14f5			 
14f5 60			      ld    H, B                    ; Store ptr from next block into freed block 
14f6 69			      ld    L, C 
14f7 73			      ld    (HL), E 
14f8 23			      inc   HL 
14f9 72			      ld    (HL), D 
14fa			 
14fa e1			      pop   HL                      ; Restore ptr to next block 
14fb 23			      inc   HL                      ; Load size of next block into DE 
14fc 5e			      ld    E, (HL) 
14fd 23			      inc   HL 
14fe 56			      ld    D, (HL) 
14ff d5			      push  DE                      ; Save next block size for later 
1500			 
1500 60			      ld    H, B                    ; Load size of freed block into HL 
1501 69			      ld    L, C 
1502 23			      inc   HL 
1503 23			      inc   HL 
1504 5e			      ld    E, (HL) 
1505 23			      inc   HL 
1506 56			      ld    D, (HL) 
1507 eb			      ex    DE, HL 
1508			 
1508 d1			      pop   DE                      ; Restore size of next block 
1509 19			      add   HL, DE                  ; Add sizes of both blocks 
150a eb			      ex    DE, HL 
150b			 
150b 60			      ld    H, B                    ; Store new bigger size into freed block 
150c 69			      ld    L, C 
150d 23			      inc   HL 
150e 23			      inc   HL 
150f 73			      ld    (HL), E 
1510 23			      inc   HL 
1511 72			      ld    (HL), D 
1512			 
1512			free_check_adjacent_to_prev: 
1512			      ; Check if the freed block is adjacent to the prev free block 
1512 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1515 dd 66 03		      ld    H, (IX+3) 
1518			 
1518 23			      inc   HL                      ; Size of prev free block into DE 
1519 23			      inc   HL 
151a 5e			      ld    E, (HL) 
151b 23			      inc   HL 
151c 56			      ld    D, (HL) 
151d 2b			      dec   HL 
151e 2b			      dec   HL 
151f 2b			      dec   HL 
1520			 
1520 19			      add   HL, DE                  ; Add prev block addr and size 
1521			 
1521 b7			      or    A                       ; Clear the carry flag 
1522 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1524 20 2e		      jr    NZ, free_done 
1526			 
1526			      ; Freed block is adjacent to prev, merge into one bigger block 
1526 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1527 69			      ld    L, C 
1528 5e			      ld    E, (HL) 
1529 23			      inc   HL 
152a 56			      ld    D, (HL) 
152b e5			      push  HL                      ; Save freed block ptr for later 
152c			 
152c dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
152f dd 66 03		      ld    H, (IX+3) 
1532 73			      ld    (HL), E 
1533 23			      inc   HL 
1534 72			      ld    (HL), D 
1535			 
1535 e1			      pop   HL                      ; Restore freed block ptr 
1536 23			      inc   HL                      ; Load size of freed block into DE 
1537 5e			      ld    E, (HL) 
1538 23			      inc   HL 
1539 56			      ld    D, (HL) 
153a d5			      push  DE                      ; Save freed block size for later 
153b			 
153b dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
153e dd 66 03		      ld    H, (IX+3) 
1541 23			      inc   HL 
1542 23			      inc   HL 
1543 5e			      ld    E, (HL) 
1544 23			      inc   HL 
1545 56			      ld    D, (HL) 
1546			 
1546 e1			      pop   HL                      ; Add sizes of both blocks 
1547 19			      add   HL, DE 
1548 eb			      ex    DE, HL 
1549			 
1549 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
154c dd 66 03		      ld    H, (IX+3) 
154f 23			      inc   HL 
1550 23			      inc   HL 
1551 73			      ld    (HL), E 
1552 23			      inc   HL 
1553 72			      ld    (HL), D 
1554			 
1554			free_done: 
1554 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1557 39			      add   HL, SP 
1558 f9			      ld    SP, HL 
1559			 
1559			free_early_exit: 
1559 dd e1		      pop   IX 
155b d1			      pop   DE 
155c c1			      pop   BC 
155d			 
155d c9			      ret 
155e			 
155e			; moved to firmware.asm 
155e			; 
155e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
155e			;                  .dw   0 
155e			 
155e			 
155e			endif 
155e			 
155e			 
155e			if MALLOC_3 
155e			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
155e			;heap_start        .equ  0x9000      ; Starting address of heap 
155e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
155e			; 
155e			 ;     .org 0 
155e			  ;    jp    main 
155e			; 
155e			; 
155e			 ;     .org  0x100 
155e			;main: 
155e			 ;     ld    HL, 0x8100 
155e			  ;    ld    SP, HL 
155e			; 
155e			;      call  heap_init 
155e			 
155e			      ; Make some allocations 
155e			;      ld    HL, 12 
155e			;      call  malloc            ; Allocates 0x9004 
155e			; 
155e			 ;     ld    HL, 12 
155e			;      call  malloc            ; Allocates 0x9014 
155e			 
155e			;      ld    HL, 12 
155e			;      call  malloc            ; Allocates 0x9024 
155e			 
155e			      ; Free some allocations 
155e			;      ld    HL, 0x9014 
155e			;      call  free 
155e			 
155e			;      ld    HL, 0x9004 
155e			;      call  free 
155e			; 
155e			;      ld    HL, 0x9024 
155e			;      call  free 
155e			 
155e			 
155e			 ;     halt 
155e			 
155e			 
155e			;------------------------------------------------------------------------------ 
155e			;     heap_init                                                               : 
155e			;                                                                             : 
155e			; Description                                                                 : 
155e			;     Initialise the heap and make it ready for malloc and free operations.   : 
155e			;                                                                             : 
155e			;     The heap is maintained as a linked list, starting with an initial       : 
155e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
155e			;     the first free block in the heap. Each block then points to the next    : 
155e			;     free block within the heap, and the free list ends at the first block   : 
155e			;     with a null pointer to the next free block.                             : 
155e			;                                                                             : 
155e			; Parameters                                                                  : 
155e			;     Inputs are compile-time only. Two defines which specify the starting    : 
155e			;     address of the heap and its size are required, along with a memory      : 
155e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
155e			;     principally stores a pointer to the first free block in the heap.       : 
155e			;                                                                             : 
155e			; Returns                                                                     : 
155e			;     Nothing                                                                 : 
155e			;------------------------------------------------------------------------------ 
155e			heap_init: 
155e			      push  HL 
155e			 
155e			      ; Initialise free list struct 
155e			      ld    HL, heap_start 
155e			      ld    (free_list), HL 
155e			      ld    HL, 0 
155e			      ld    (free_list+2), HL 
155e			 
155e			      ; Insert first free block at bottom of heap, consumes entire heap 
155e			      ld    HL, heap_start+heap_size-4 
155e			      ld    (heap_start), HL        ; Next block (end of free list) 
155e			      ld    HL, heap_size-4 
155e			      ld    (heap_start+2), HL      ; Block size 
155e			 
155e			      ; Insert end of free list block at top of heap - two null words will 
155e			      ; terminate the free list 
155e			      ld    HL, 0 
155e			      ld    (heap_start+heap_size-2), HL 
155e			      ld    (heap_start+heap_size-4), HL 
155e			 
155e			      pop   HL 
155e			 
155e			      ret 
155e			 
155e			 
155e			;------------------------------------------------------------------------------ 
155e			;     malloc                                                                  : 
155e			;                                                                             : 
155e			; Description                                                                 : 
155e			;     Allocates the wanted space from the heap and returns the address of the : 
155e			;     first useable byte of the allocation.                                   : 
155e			;                                                                             : 
155e			;     Allocations can happen in one of two ways:                              : 
155e			;                                                                             : 
155e			;     1. A free block may be found which is the exact size wanted. In this    : 
155e			;        case the block is removed from the free list and retuedn to the      : 
155e			;        caller.                                                              : 
155e			;     2. A free block may be found which is larger than the size wanted. In   : 
155e			;        this case, the larger block is split into two. The first portion of  : 
155e			;        this block will become the requested space by the malloc call and    : 
155e			;        is returned to the caller. The second portion becomes a new free     : 
155e			;        block, and the free list is adjusted to maintain continuity via this : 
155e			;        newly created block.                                                 : 
155e			;                                                                             : 
155e			;     malloc does not set any initial value in the allocated space, the       : 
155e			;     caller is required to do this as required.                              : 
155e			;                                                                             : 
155e			;     This implementation of malloc uses the stack exclusively, and is        : 
155e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
155e			;     advisable to disable interrupts before calling malloc, and recommended  : 
155e			;     to avoid the use of malloc inside ISRs in general.                      : 
155e			;                                                                             : 
155e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
155e			;                                                                             : 
155e			; Parameters                                                                  : 
155e			;     HL  Number of bytes wanted                                              : 
155e			;                                                                             : 
155e			; Returns                                                                     : 
155e			;     HL  Address of the first useable byte of the allocation                 : 
155e			;                                                                             : 
155e			; Flags                                                                       : 
155e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
155e			;                                                                             : 
155e			; Stack frame                                                                 : 
155e			;       |             |                                                       : 
155e			;       +-------------+                                                       : 
155e			;       |     BC      |                                                       : 
155e			;       +-------------+                                                       : 
155e			;       |     DE      |                                                       : 
155e			;       +-------------+                                                       : 
155e			;       |     IX      |                                                       : 
155e			;       +-------------+                                                       : 
155e			;       |  prev_free  |                                                       : 
155e			;   +4  +-------------+                                                       : 
155e			;       |  this_free  |                                                       : 
155e			;   +2  +-------------+                                                       : 
155e			;       |  next_free  |                                                       : 
155e			;   +0  +-------------+                                                       : 
155e			;       |             |                                                       : 
155e			;                                                                             : 
155e			;------------------------------------------------------------------------------ 
155e			malloc: 
155e			      push  BC 
155e			      push  DE 
155e			      push  IX 
155e			 
155e			      ld    A, H                    ; Exit if no space requested 
155e			      or    L 
155e			      jp    Z, malloc_early_exit 
155e			 
155e			      ; Set up stack frame 
155e			      ex    DE, HL 
155e			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
155e			      add   HL, SP 
155e			      ld    SP, HL 
155e			      ld    IX, 0                   ; Use IX as a frame pointer 
155e			      add   IX, SP 
155e			 
155e			      ; Setup initial state 
155e			      ld    HL, 4                   ; want must also include space used by block struct 
155e			      add   HL, DE 
155e			 
155e			      ld    B, H                    ; Move want to BC 
155e			      ld    C, L 
155e			 
155e			      ld    HL, free_list           ; Store prev_free ptr to stack 
155e			      ld    (IX+4), L 
155e			      ld    (IX+5), H 
155e			 
155e			      ld    E, (HL)                 ; Store this_free ptr to stack 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			      ld    (IX+2), E 
155e			      ld    (IX+3), D 
155e			      ex    DE, HL                  ; this_free ptr into HL 
155e			 
155e			      ; Loop through free block list to find some space 
155e			malloc_find_space: 
155e			      ld    E, (HL)                 ; Load next_free ptr into DE 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			 
155e			      ld    A, D                    ; Check for null next_free ptr - end of free list 
155e			      or    E 
155e			      jp    Z, malloc_no_space 
155e			 
155e			      ld    (IX+0), E               ; Store next_free ptr to stack 
155e			      ld    (IX+1), D 
155e			 
155e			      ; Does this block have enough space to make the allocation? 
155e			      inc   HL                      ; Load free block size into DE 
155e			      ld    E, (HL) 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			 
155e			      ex    DE, HL                  ; Check size of block against want 
155e			      or    A                       ; Ensure carry flag clear 
155e			      sbc   HL, BC 
155e			      push  HL                      ; Store the result for later (new block size) 
155e			 
155e			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
155e			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
155e			 
155e			      ; this_free block is not big enough, setup ptrs to test next free block 
155e			      pop   HL                      ; Discard previous result 
155e			 
155e			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
155e			      ld    H, (IX+3) 
155e			      ld    (IX+4), L 
155e			      ld    (IX+5), H 
155e			 
155e			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
155e			      ld    H, (IX+1) 
155e			      ld    (IX+2), L 
155e			      ld    (IX+3), H 
155e			 
155e			      jr    malloc_find_space 
155e			 
155e			      ; split a bigger block into two - requested size and remaining size 
155e			malloc_alloc_split: 
155e			      ex    DE, HL                  ; Calculate address of new free block 
155e			      dec   HL 
155e			      dec   HL 
155e			      dec   HL 
155e			      add   HL, BC 
155e			 
155e			      ; Create a new block and point it at next_free 
155e			      ld    E, (IX+0)               ; Load next_free ptr into DE 
155e			      ld    D, (IX+1) 
155e			 
155e			      ld    (HL), E                 ; Store next_free ptr into new block 
155e			      inc   HL 
155e			      ld    (HL), D 
155e			 
155e			      pop   DE                      ; Store size of new block into new block 
155e			      inc   HL 
155e			      ld    (HL), E 
155e			      inc   HL 
155e			      ld    (HL), D 
155e			 
155e			      ; Update this_free ptr to point to new block 
155e			      dec   HL 
155e			      dec   HL 
155e			      dec   HL 
155e			 
155e			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
155e			      ld    D, (IX+3) 
155e			 
155e			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
155e			      ld    (IX+3), H 
155e			 
155e			      ; Modify this_free block to be allocation 
155e			      ex    DE, HL 
155e			      xor   A                       ; Null the next block ptr of allocated block 
155e			      ld    (HL), A 
155e			      inc   HL 
155e			      ld    (HL), A 
155e			 
155e			      inc   HL                      ; Store want size into allocated block 
155e			      ld    (HL), C 
155e			      inc   HL 
155e			      ld    (HL), B 
155e			      inc   HL 
155e			      push  HL                      ; Address of allocation to return 
155e			 
155e			      jr    malloc_update_links 
155e			 
155e			malloc_alloc_fit: 
155e			      pop   HL                      ; Dont need new block size, want is exact fit 
155e			 
155e			      ; Modify this_free block to be allocation 
155e			      ex    DE, HL 
155e			      dec   HL 
155e			      dec   HL 
155e			      dec   HL 
155e			 
155e			      xor   A                       ; Null the next block ptr of allocated block 
155e			      ld    (HL), A 
155e			      inc   HL 
155e			      ld    (HL), A 
155e			 
155e			      inc   HL                      ; Store address of allocation to return 
155e			      inc   HL 
155e			      inc   HL 
155e			      push  HL 
155e			 
155e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
155e			      ld    L, (IX+0)               ; next_free to HL 
155e			      ld    H, (IX+1) 
155e			 
155e			      ld    (IX+2), L               ; HL to this_free 
155e			      ld    (IX+3), H 
155e			 
155e			 
155e			malloc_update_links: 
155e			      ; Update prev_free ptr to point to this_free 
155e			      ld    L, (IX+4)               ; prev_free ptr to HL 
155e			      ld    H, (IX+5) 
155e			 
155e			      ld    E, (IX+2)               ; this_free ptr to DE 
155e			      ld    D, (IX+3) 
155e			 
155e			      ld    (HL), E                 ; this_free ptr into prev_free 
155e			      inc   HL 
155e			      ld    (HL), D 
155e			 
155e			      ; Clear the Z flag to indicate successful allocation 
155e			      ld    A, D 
155e			      or    E 
155e			 
155e			      pop   DE                      ; Address of allocation 
155e			 
155e			malloc_no_space: 
155e			      ld    HL, 6                   ; Clean up stack frame 
155e			      add   HL, SP 
155e			      ld    SP, HL 
155e			 
155e			      ex    DE, HL                  ; Alloc addr into HL for return 
155e			 
155e			malloc_early_exit: 
155e			      pop   IX 
155e			      pop   DE 
155e			      pop   BC 
155e			 
155e			      ret 
155e			 
155e			 
155e			;------------------------------------------------------------------------------ 
155e			;     free                                                                    : 
155e			;                                                                             : 
155e			; Description                                                                 : 
155e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
155e			;     returned by malloc, otherwise the behaviour is undefined.               : 
155e			;                                                                             : 
155e			;     Where possible, directly adjacent free blocks will be merged together   : 
155e			;     into larger blocks to help ensure that the heap does not become         : 
155e			;     excessively fragmented.                                                 : 
155e			;                                                                             : 
155e			;     free does not clear or set any other value into the freed space, and    : 
155e			;     therefore its contents may be visible through subsequent malloc's. The  : 
155e			;     caller should clear the freed space as required.                        : 
155e			;                                                                             : 
155e			;     This implementation of free uses the stack exclusively, and is          : 
155e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
155e			;     advisable to disable interrupts before calling free, and recommended    : 
155e			;     to avoid the use of free inside ISRs in general.                        : 
155e			;                                                                             : 
155e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
155e			;                                                                             : 
155e			; Parameters                                                                  : 
155e			;     HL  Pointer to address of first byte of allocation to be freed          : 
155e			;                                                                             : 
155e			; Returns                                                                     : 
155e			;     Nothing                                                                 : 
155e			;                                                                             : 
155e			; Stack frame                                                                 : 
155e			;       |             |                                                       : 
155e			;       +-------------+                                                       : 
155e			;       |     BC      |                                                       : 
155e			;       +-------------+                                                       : 
155e			;       |     DE      |                                                       : 
155e			;       +-------------+                                                       : 
155e			;       |     IX      |                                                       : 
155e			;       +-------------+                                                       : 
155e			;       |  prev_free  |                                                       : 
155e			;   +2  +-------------+                                                       : 
155e			;       |  next_free  |                                                       : 
155e			;   +0  +-------------+                                                       : 
155e			;       |             |                                                       : 
155e			;                                                                             : 
155e			;------------------------------------------------------------------------------ 
155e			free: 
155e			      push  BC 
155e			      push  DE 
155e			      push  IX 
155e			 
155e			      ld    A, H                    ; Exit if ptr is null 
155e			      or    L 
155e			      jp    Z, free_early_exit 
155e			 
155e			      ; Set up stack frame 
155e			      ex    DE, HL 
155e			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
155e			      add   HL, SP 
155e			      ld    SP, HL 
155e			      ld    IX, 0                   ; Use IX as a frame pointer 
155e			      add   IX, SP 
155e			 
155e			      ; The address in HL points to the start of the useable allocated space, 
155e			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
155e			      ; address of the block itself. 
155e			      ex    DE, HL 
155e			      ld    DE, -4 
155e			      add   HL, DE 
155e			 
155e			      ; An allocated block must have a null next block pointer in it 
155e			      ld    A, (HL) 
155e			      inc   HL 
155e			      or    (HL) 
155e			      jp    NZ, free_done 
155e			 
155e			      dec   HL 
155e			 
155e			      ld    B, H                    ; Copy HL to BC 
155e			      ld    C, L 
155e			 
155e			      ; Loop through the free list to find the first block with an address 
155e			      ; higher than the block being freed 
155e			      ld    HL, free_list 
155e			 
155e			free_find_higher_block: 
155e			      ld    E, (HL)                 ; Load next ptr from free block 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			      dec   HL 
155e			 
155e			      ld    (IX+0), E               ; Save ptr to next free block 
155e			      ld    (IX+1), D 
155e			      ld    (IX+2), L               ; Save ptr to prev free block 
155e			      ld    (IX+3), H 
155e			 
155e			      ld    A, B                    ; Check if DE is greater than BC 
155e			      cp    D                       ; Compare MSB first 
155e			      jr    Z, $+4                  ; MSB the same, compare LSB 
155e			      jr    NC, free_find_higher_block_skip 
155e			      ld    A, C 
155e			      cp    E                       ; Then compare LSB 
155e			      jr    C, free_found_higher_block 
155e			 
155e			free_find_higher_block_skip: 
155e			      ld    A, D                    ; Reached the end of the free list? 
155e			      or    E 
155e			      jp    Z, free_done 
155e			 
155e			      ex    DE, HL 
155e			 
155e			      jr    free_find_higher_block 
155e			 
155e			free_found_higher_block: 
155e			      ; Insert freed block between prev and next free blocks 
155e			      ld    (HL), C                 ; Point prev free block to freed block 
155e			      inc   HL 
155e			      ld    (HL), B 
155e			 
155e			      ld    H, B                    ; Point freed block at next free block 
155e			      ld    L, C 
155e			      ld    (HL), E 
155e			      inc   HL 
155e			      ld    (HL), D 
155e			 
155e			      ; Check if the freed block is adjacent to the next free block 
155e			      inc   HL                      ; Load size of freed block into HL 
155e			      ld    E, (HL) 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			      ex    DE, HL 
155e			 
155e			      add   HL, BC                  ; Add addr of freed block and its size 
155e			 
155e			      ld    E, (IX+0)               ; Load addr of next free block into DE 
155e			      ld    D, (IX+1) 
155e			 
155e			      or    A                       ; Clear the carry flag 
155e			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
155e			      jr    NZ, free_check_adjacent_to_prev 
155e			 
155e			      ; Freed block is adjacent to next, merge into one bigger block 
155e			      ex    DE, HL                  ; Load next ptr from next block into DE 
155e			      ld    E, (HL) 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			      push  HL                      ; Save ptr to next block for later 
155e			 
155e			      ld    H, B                    ; Store ptr from next block into freed block 
155e			      ld    L, C 
155e			      ld    (HL), E 
155e			      inc   HL 
155e			      ld    (HL), D 
155e			 
155e			      pop   HL                      ; Restore ptr to next block 
155e			      inc   HL                      ; Load size of next block into DE 
155e			      ld    E, (HL) 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			      push  DE                      ; Save next block size for later 
155e			 
155e			      ld    H, B                    ; Load size of freed block into HL 
155e			      ld    L, C 
155e			      inc   HL 
155e			      inc   HL 
155e			      ld    E, (HL) 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			      ex    DE, HL 
155e			 
155e			      pop   DE                      ; Restore size of next block 
155e			      add   HL, DE                  ; Add sizes of both blocks 
155e			      ex    DE, HL 
155e			 
155e			      ld    H, B                    ; Store new bigger size into freed block 
155e			      ld    L, C 
155e			      inc   HL 
155e			      inc   HL 
155e			      ld    (HL), E 
155e			      inc   HL 
155e			      ld    (HL), D 
155e			 
155e			free_check_adjacent_to_prev: 
155e			      ; Check if the freed block is adjacent to the prev free block 
155e			      ld    L, (IX+2)               ; Prev free block ptr into HL 
155e			      ld    H, (IX+3) 
155e			 
155e			      inc   HL                      ; Size of prev free block into DE 
155e			      inc   HL 
155e			      ld    E, (HL) 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			      dec   HL 
155e			      dec   HL 
155e			      dec   HL 
155e			 
155e			      add   HL, DE                  ; Add prev block addr and size 
155e			 
155e			      or    A                       ; Clear the carry flag 
155e			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
155e			      jr    NZ, free_done 
155e			 
155e			      ; Freed block is adjacent to prev, merge into one bigger block 
155e			      ld    H, B                    ; Load next ptr from freed block into DE 
155e			      ld    L, C 
155e			      ld    E, (HL) 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			      push  HL                      ; Save freed block ptr for later 
155e			 
155e			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
155e			      ld    H, (IX+3) 
155e			      ld    (HL), E 
155e			      inc   HL 
155e			      ld    (HL), D 
155e			 
155e			      pop   HL                      ; Restore freed block ptr 
155e			      inc   HL                      ; Load size of freed block into DE 
155e			      ld    E, (HL) 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			      push  DE                      ; Save freed block size for later 
155e			 
155e			      ld    L, (IX+2)               ; Load size of prev block into DE 
155e			      ld    H, (IX+3) 
155e			      inc   HL 
155e			      inc   HL 
155e			      ld    E, (HL) 
155e			      inc   HL 
155e			      ld    D, (HL) 
155e			 
155e			      pop   HL                      ; Add sizes of both blocks 
155e			      add   HL, DE 
155e			      ex    DE, HL 
155e			 
155e			      ld    L, (IX+2)               ; Store new bigger size into prev block 
155e			      ld    H, (IX+3) 
155e			      inc   HL 
155e			      inc   HL 
155e			      ld    (HL), E 
155e			      inc   HL 
155e			      ld    (HL), D 
155e			 
155e			free_done: 
155e			      ld    HL, 4                   ; Clean up stack frame 
155e			      add   HL, SP 
155e			      ld    SP, HL 
155e			 
155e			free_early_exit: 
155e			      pop   IX 
155e			      pop   DE 
155e			      pop   BC 
155e			 
155e			      ret 
155e			 
155e			 
155e			;      .org 0x8000 
155e			; 
155e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
155e			 ;                 .dw   0 
155e			 
155e			endif 
155e			 
155e			 
155e			if MALLOC_4 
155e			 
155e			; My memory allocation code. Very very simple.... 
155e			; allocate space under 250 chars 
155e			 
155e			heap_init: 
155e				; init start of heap as zero 
155e				;  
155e			 
155e				ld hl, heap_start 
155e				ld a, 0 
155e				ld (hl), a      ; empty block 
155e				inc hl 
155e				ld a, 0 
155e				ld (hl), a      ; length of block 
155e				; write end of list 
155e				inc hl 
155e				ld a,(hl) 
155e				inc hl 
155e				ld a,(hl) 
155e				 
155e			 
155e				; init some malloc vars 
155e			 
155e				ld hl, 0 
155e				ld (free_list), hl       ; store last malloc location 
155e			 
155e				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
155e				ld a, 0 
155e				ld (hl), a 
155e			 
155e			 
155e				ld hl, heap_start 
155e				;  
155e				  
155e				ret 
155e			 
155e			 
155e			;    free block marker 
155e			;    requested size  
155e			;    pointer to next block 
155e			;    .... 
155e			;    next block marker 
155e			 
155e			 
155e			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
155e			; 
155e			 
155e			 
155e			malloc:  
155e				push de 
155e				push bc 
155e				push af 
155e			 
155e				; hl space required 
155e				 
155e				ld c, l    ; hold space   (TODO only a max of 255) 
155e			 
155e			;	inc c     ; TODO BUG need to fix memory leak on push str 
155e			;	inc c 
155e			;	inc c 
155e			;	inc c 
155e			;	inc c 
155e			;	inc c 
155e			;	inc c 
155e			 
155e			 
155e			 
155e				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
155e			 
155e				ld a, (free_list+3) 
155e				cp 0 
155e				jr z, .contheap 
155e			 
155e				ld hl, (free_list)     ; get last alloc 
155e					if DEBUG_FORTH_MALLOC_INT 
155e						DMARK "mrs" 
155e						CALLMONITOR 
155e					endif 
155e				jr .startalloc 
155e			 
155e			.contheap: 
155e				ld hl, heap_start 
155e			 
155e			.startalloc: 
155e			 
155e					if DEBUG_FORTH_MALLOC_INT 
155e						DMARK "mym" 
155e						CALLMONITOR 
155e					endif 
155e			.findblock: 
155e					if DEBUG_FORTH_MALLOC_INT 
155e						DMARK "mmf" 
155e						CALLMONITOR 
155e					endif 
155e			 
155e				ld a,(hl)  
155e				; if byte is zero then clear to use 
155e			 
155e				cp 0 
155e				jr z, .foundemptyblock 
155e			 
155e				; if byte is not clear 
155e				;     then byte is offset to next block 
155e			 
155e				inc hl 
155e				ld a, (hl) ; get size 
155e			.nextblock:	inc hl 
155e					ld e, (hl) 
155e					inc hl 
155e					ld d, (hl) 
155e					ex de, hl 
155e			;	inc hl  ; move past the store space 
155e			;	inc hl  ; move past zero index  
155e			 
155e				; TODO detect no more space 
155e			 
155e				push hl 
155e				ld de, heap_end 
155e				call cmp16 
155e				pop hl 
155e				jr nc, .nospace 
155e			 
155e				jr .findblock 
155e			 
155e			.nospace: ld hl, 0 
155e				jp .exit 
155e			 
155e			 
155e			.foundemptyblock:	 
155e					if DEBUG_FORTH_MALLOC_INT 
155e						DMARK "mme" 
155e						CALLMONITOR 
155e					endif 
155e			 
155e			; TODO has block enough space if reusing??? 
155e			 
155e				;  
155e			 
155e			; see if this block has been previously used 
155e				inc hl 
155e				ld a, (hl) 
155e				dec hl 
155e				cp 0 
155e				jr z, .newblock 
155e			 
155e					if DEBUG_FORTH_MALLOC_INT 
155e						DMARK "meR" 
155e						CALLMONITOR 
155e					endif 
155e			 
155e			; no reusing previously allocated block 
155e			 
155e			; is it smaller than previously used? 
155e				 
155e				inc hl    ; move to size 
155e				ld a, c 
155e				sub (hl)        ; we want c < (hl) 
155e				dec hl    ; move back to marker 
155e			        jr z, .findblock 
155e			 
155e				; update with the new size which should be lower 
155e			 
155e			        ;inc  hl   ; negate next move. move back to size  
155e			 
155e			.newblock: 
155e				; need to be at marker here 
155e			 
155e					if DEBUG_FORTH_MALLOC_INT 
155e						DMARK "meN" 
155e						CALLMONITOR 
155e					endif 
155e			 
155e			 
155e				ld a, c 
155e			 
155e				ld (free_list+3), a	 ; flag resume from last malloc  
155e				ld (free_list), hl    ; save out last location 
155e			 
155e			 
155e				;inc a     ; space for length byte 
155e				ld (hl), a     ; save block in use marker 
155e			 
155e				inc hl   ; move to space marker 
155e				ld (hl), a    ; save new space 
155e			 
155e				inc hl   ; move to start of allocated area 
155e				 
155e			;	push hl     ; save where we are - 1  
155e			 
155e			;	inc hl  ; move past zero index  
155e				; skip space to set down new marker 
155e			 
155e				; provide some extra space for now 
155e			 
155e				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
155e				inc a 
155e				inc a 
155e			 
155e				push hl   ; save where we are in the node block 
155e			 
155e				call addatohl 
155e			 
155e				; write linked list point 
155e			 
155e				pop de     ; get our node position 
155e				ex de, hl 
155e			 
155e				ld (hl), e 
155e				inc hl 
155e				ld (hl), d 
155e			 
155e				inc hl 
155e			 
155e				; now at start of allocated data so save pointer 
155e			 
155e				push hl 
155e			 
155e				; jump to position of next node and setup empty header in DE 
155e			 
155e				ex de, hl 
155e			 
155e			;	inc hl ; move past end of block 
155e			 
155e				ld a, 0 
155e				ld (hl), a   ; empty marker 
155e				inc hl 
155e				ld (hl), a   ; size 
155e				inc hl  
155e				ld (hl), a   ; ptr 
155e				inc hl 
155e				ld (hl), a   ; ptr 
155e			 
155e			 
155e				pop hl 
155e			 
155e					if DEBUG_FORTH_MALLOC_INT 
155e						DMARK "mmr" 
155e						CALLMONITOR 
155e					endif 
155e			 
155e			.exit: 
155e				pop af 
155e				pop bc 
155e				pop de  
155e				ret 
155e			 
155e			 
155e			 
155e			 
155e			free:  
155e				push hl 
155e				push af 
155e				; get address in hl 
155e			 
155e					if DEBUG_FORTH_MALLOC_INT 
155e						DMARK "fre" 
155e						CALLMONITOR 
155e					endif 
155e				; data is at hl - move to block count 
155e				dec hl 
155e				dec hl    ; get past pointer 
155e				dec hl 
155e			 
155e				ld a, (hl)    ; need this for a validation check 
155e			 
155e				dec hl    ; move to block marker 
155e			 
155e				; now check that the block count and block marker are the same  
155e			        ; this checks that we are on a malloc node and not random memory 
155e			        ; OK a faint chance this could be a problem but rare - famous last words! 
155e			 
155e				ld c, a 
155e				ld a, (hl)    
155e			 
155e				cp c 
155e				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
155e			 
155e				; yes good chance we are on a malloc node 
155e			 
155e				ld a, 0      
155e				ld (hl), a   ; mark as free 
155e			 
155e				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
155e			 
155e			.freeignore:  
155e			 
155e				pop af 
155e				pop hl 
155e			 
155e				ret 
155e			 
155e			 
155e			 
155e			endif 
155e			 
155e			; eof 
# End of file firmware_memory.asm
155e			  
155e			; device C  
155e			if SOUND_ENABLE  
155e				include "firmware_sound.asm"  
155e			; Sound abstraction layer 
155e			 
155e			; support different sound chips through common interface 
155e			 
155e			SOUND_DEVICE_AY: equ 0 
155e			 
155e			SOUND_DEVICE: equ Device_A 
155e			 
155e			 
155e			 
155e			if SOUND_DEVICE_AY 
155e				include "firmware_sound_ay38910.asm" 
155e			else 
155e				include "firmware_sound_sn76489an.asm" 
155e			 
155e			; Device support for SN76489AN sound chip 
155e			 
155e			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
155e			; http://danceswithferrets.org/geekblog/?p=93 
155e			; https://www.smspower.org/Development/SN76489 
155e			 
155e			; D0 [ 3] 
155e			; D1 [ 2] 
155e			; D2 [ 1] 
155e			; D3 [15] 
155e			; D4 [13] 
155e			; D5 [12] 
155e			; D6 [11] 
155e			; D7 [10] 
155e			; /WE [ 5] 
155e			; CLK [14] 
155e			; /OE [ 6] 
155e			; AUDIO [ 7] 
155e			; GND 8 
155e			; +5 16 
155e			; 
155e			 
155e			; Write sequence: 
155e			; CE low 
155e			; Data bus 
155e			; WE low then high 
155e			; 32 clock cycles / 8ns write time at 4mhz 
155e			; 
155e			; https://github.com/jblang/SN76489 
155e			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
155e			; Tried: 
155e			; 
155e			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
155e			; 
155e			; Connected WE to OR too 
155e			;  
155e			; That enabled the clock when required 
155e			; However still random bus corruption. Need further investigation 
155e			 
155e			 
155e			SOUND_LATCH: equ 10000000B 
155e			SOUND_DATA: equ 0B 
155e			SOUND_CH0:  equ 0B    ; Tone 
155e			SOUND_CH1: equ 0100000B        ; Tone 
155e			SOUND_CH2: equ 1000000B   ; Tone 
155e			SOUND_CH3: equ 1100000B    ; Noise 
155e			SOUND_VOL: equ 10000B 
155e			SOUND_TONE: equ 0B 
155e			 
155e			 
155e			sound_init: 
155e 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1560 cd 75 15			call note_send_byte 
1563 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1565 cd 75 15			call note_send_byte 
1568 cd 3b 0c			call delay250ms 
156b 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
156d cd 75 15			call note_send_byte 
1570 cd 3b 0c			call delay250ms 
1573 c9				ret 
1574			 
1574			; Play a note 
1574			; h = note 
1574			; l = duration 
1574			; a = channel 
1574			 
1574			 
1574			;  frequ = clock / ( 2 x reg valu x 32 )  
1574			 
1574			note:  
1574				 
1574			 
1574 c9				ret 
1575			 
1575			note_send_byte: 
1575				; byte in a 
1575			 
1575				; we high 
1575 d3 40			out (Device_B), a 
1577			;	ld a, 1 
1577			;	call aDelayInMS 
1577 00				nop  
1578 00				nop  
1579 00				nop  
157a 00				nop  
157b				; we low 
157b d3 40			out (Device_B), a 
157d			;	ld a, 1 
157d			;	call aDelayInMS 
157d 00				nop  
157e 00				nop  
157f 00				nop  
1580 00				nop  
1581				; we high 
1581 d3 40			out (Device_B), a 
1583			;	ld a, 1 
1583			;	call aDelayInMS 
1583 00				nop  
1584 00				nop  
1585 00				nop  
1586 00				nop  
1587			 
1587			 
1587 c9				ret 
1588			 
1588			;void SilenceAllChannels() 
1588			;{ 
1588			;  SendByte(0x9f); 
1588			;  SendByte(0xbf); 
1588			;  SendByte(0xdf); 
1588			;  SendByte(0xff); 
1588			;} 
1588			 
1588			 
1588			; eof 
1588			 
# End of file firmware_sound_sn76489an.asm
1588			endif 
1588			 
1588			 
1588			; Abstraction entry points 
1588			 
1588			; init  
1588			 
1588			; sound_init in specific hardware files 
1588			 
1588			; Play a note 
1588			; h = note 
1588			; l = duration 
1588			; a = channel 
1588			 
1588			;note:     
1588			;	ret 
1588			 
1588			 
1588			 
1588			 
1588			; eof 
1588			 
# End of file firmware_sound.asm
1588			endif  
1588			  
1588			include "firmware_diags.asm"  
1588			; Hardware diags menu 
1588			 
1588			 
1588			config: 
1588			 
1588 3e 00			ld a, 0 
158a 21 b8 15			ld hl, .configmn 
158d cd fb 0c			call menu 
1590			 
1590 fe 00			cp 0 
1592 c8				ret z 
1593			 
1593 fe 01			cp 1 
1595 cc 91 16			call z, .savetostore 
1598			 
1598 fe 02			cp 2 
159a cc df 15			call z, .selautoload 
159d fe 03			cp 3 
159f cc c8 15			call z, .disautoload 
15a2 fe 04			cp 4 
15a4 cc 8f 16			call z, .selbank 
15a7 fe 05			cp 5 
15a9 cc 6c 17			call z, .debug_tog 
15ac fe 06			cp 6 
15ae cc af 18			call z, .bpsgo 
15b1 fe 07			cp 7 
15b3 cc 92 17			call z, hardware_diags 
15b6			 
15b6 18 d0			jr config 
15b8			 
15b8			.configmn: 
15b8 a0 1a			dw prom_c3 
15ba b7 1a			dw prom_c2 
15bc cc 1a			dw prom_c2a 
15be e2 1a			dw prom_c2b 
15c0			;	dw prom_c4 
15c0 ff 1a			dw prom_m4 
15c2 1a 1b			dw prom_m4b 
15c4 22 1b			dw prom_c1 
15c6 00 00			dw 0 
15c8				 
15c8			 
15c8			 
15c8			 
15c8			.disautoload: 
15c8				if STORAGE_SE 
15c8 3e fe			ld a, $fe      ; bit 0 clear 
15ca 32 6a fa			ld (spi_device), a 
15cd			 
15cd cd 85 04			call storage_get_block_0 
15d0			 
15d0 3e 00			ld a, 0 
15d2 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
15d5			 
15d5 21 00 00				ld hl, 0 
15d8 11 81 fa				ld de, store_page 
15db cd 39 04			call storage_write_block	 ; save update 
15de				else 
15de			 
15de				ld hl, prom_notav 
15de				ld de, prom_empty 
15de				call info_panel 
15de				endif 
15de			 
15de			 
15de c9				ret 
15df			 
15df			 
15df			 
15df			; Select auto start 
15df			 
15df			.selautoload: 
15df			 
15df				 
15df				if STORAGE_SE 
15df			 
15df cd b6 16				call config_dir 
15e2 21 ff f1			        ld hl, scratch 
15e5 3e 00				ld a, 0 
15e7 cd fb 0c				call menu 
15ea			 
15ea fe 00				cp 0 
15ec c8					ret z 
15ed			 
15ed 3d					dec a 
15ee			 
15ee			 
15ee					; locate menu option 
15ee			 
15ee 21 ff f1				ld hl, scratch 
15f1 cd 1f 0c				call table_lookup 
15f4			 
15f4					if DEBUG_FORTH_WORDS 
15f4						DMARK "ALl" 
15f4 f5				push af  
15f5 3a 09 16			ld a, (.dmark)  
15f8 32 6e fe			ld (debug_mark),a  
15fb 3a 0a 16			ld a, (.dmark+1)  
15fe 32 6f fe			ld (debug_mark+1),a  
1601 3a 0b 16			ld a, (.dmark+2)  
1604 32 70 fe			ld (debug_mark+2),a  
1607 18 03			jr .pastdmark  
1609 ..			.dmark: db "ALl"  
160c f1			.pastdmark: pop af  
160d			endm  
# End of macro DMARK
160d						CALLMONITOR 
160d cd a5 18			call break_point_state  
1610				endm  
# End of macro CALLMONITOR
1610					endif 
1610					; with the pointer to the menu it, the byte following the zero term is the file id 
1610			 
1610 3e 00				ld a, 0 
1612 01 32 00				ld bc, 50   ; max of bytes to look at 
1615 ed b1				cpir  
1617			 
1617					if DEBUG_FORTH_WORDS 
1617						DMARK "ALb" 
1617 f5				push af  
1618 3a 2c 16			ld a, (.dmark)  
161b 32 6e fe			ld (debug_mark),a  
161e 3a 2d 16			ld a, (.dmark+1)  
1621 32 6f fe			ld (debug_mark+1),a  
1624 3a 2e 16			ld a, (.dmark+2)  
1627 32 70 fe			ld (debug_mark+2),a  
162a 18 03			jr .pastdmark  
162c ..			.dmark: db "ALb"  
162f f1			.pastdmark: pop af  
1630			endm  
# End of macro DMARK
1630						CALLMONITOR 
1630 cd a5 18			call break_point_state  
1633				endm  
# End of macro CALLMONITOR
1633					endif 
1633					;inc hl 
1633			 
1633 7e					ld a, (hl)   ; file id 
1634					 
1634				        ; save bank and file ids 
1634			 
1634 f5					push af 
1635			 
1635			; TODO need to save to block 0 on bank 1	 
1635			 
1635 cd 85 04				call storage_get_block_0 
1638			 
1638					if DEBUG_FORTH_WORDS 
1638						DMARK "AL0" 
1638 f5				push af  
1639 3a 4d 16			ld a, (.dmark)  
163c 32 6e fe			ld (debug_mark),a  
163f 3a 4e 16			ld a, (.dmark+1)  
1642 32 6f fe			ld (debug_mark+1),a  
1645 3a 4f 16			ld a, (.dmark+2)  
1648 32 70 fe			ld (debug_mark+2),a  
164b 18 03			jr .pastdmark  
164d ..			.dmark: db "AL0"  
1650 f1			.pastdmark: pop af  
1651			endm  
# End of macro DMARK
1651						CALLMONITOR 
1651 cd a5 18			call break_point_state  
1654				endm  
# End of macro CALLMONITOR
1654					endif 
1654 f1					pop af 
1655			 
1655 32 a5 fa				ld (store_page+STORE_0_FILERUN),a 
1658					 
1658					; save bank id 
1658			 
1658 3a 6a fa				ld a,(spi_device) 
165b 32 a4 fa				ld (store_page+STORE_0_BANKRUN),a 
165e			 
165e					; enable auto run of store file 
165e			 
165e 3e 01				ld a, 1 
1660 32 a2 fa				ld (store_page+STORE_0_AUTOFILE),a 
1663			 
1663					; save buffer 
1663			 
1663 21 00 00				ld hl, 0 
1666 11 81 fa				ld de, store_page 
1669					if DEBUG_FORTH_WORDS 
1669						DMARK "ALw" 
1669 f5				push af  
166a 3a 7e 16			ld a, (.dmark)  
166d 32 6e fe			ld (debug_mark),a  
1670 3a 7f 16			ld a, (.dmark+1)  
1673 32 6f fe			ld (debug_mark+1),a  
1676 3a 80 16			ld a, (.dmark+2)  
1679 32 70 fe			ld (debug_mark+2),a  
167c 18 03			jr .pastdmark  
167e ..			.dmark: db "ALw"  
1681 f1			.pastdmark: pop af  
1682			endm  
# End of macro DMARK
1682						CALLMONITOR 
1682 cd a5 18			call break_point_state  
1685				endm  
# End of macro CALLMONITOR
1685					endif 
1685 cd 39 04			call storage_write_block	 ; save update 
1688			  
1688			 
1688			 
1688			 
1688 21 ff f1				ld hl, scratch 
168b cd a3 16				call config_fdir 
168e			 
168e				else 
168e			 
168e				ld hl, prom_notav 
168e				ld de, prom_empty 
168e				call info_panel 
168e			 
168e				endif 
168e c9				ret 
168f			 
168f			 
168f			 
168f			; Select storage bank 
168f			 
168f			.selbank: 
168f			 
168f				if STORAGE_SE 
168f				else 
168f			 
168f				ld hl, prom_notav 
168f				ld de, prom_empty 
168f				call info_panel 
168f				endif 
168f				 
168f c9				ret 
1690			 
1690			if STORAGE_SE 
1690			 
1690			.config_ldir:   
1690				; Load storage bank labels into menu array 
1690			 
1690				 
1690			 
1690			 
1690 c9				ret 
1691			 
1691			 
1691			endif 
1691			 
1691			 
1691			; Save user words to storage 
1691			 
1691			.savetostore: 
1691			 
1691				if STORAGE_SE 
1691			 
1691 cd b6 16				call config_dir 
1694 21 ff f1			        ld hl, scratch 
1697 3e 00				ld a, 0 
1699 cd fb 0c				call menu 
169c					 
169c 21 ff f1				ld hl, scratch 
169f cd a3 16				call config_fdir 
16a2			 
16a2				else 
16a2			 
16a2				ld hl, prom_notav 
16a2				ld de, prom_empty 
16a2				call info_panel 
16a2			 
16a2				endif 
16a2			 
16a2 c9				ret 
16a3			 
16a3			 
16a3			 
16a3			if STORAGE_SE 
16a3			 
16a3			config_fdir: 
16a3				; using the scratch dir go through and release the memory allocated for each string 
16a3				 
16a3 21 ff f1			ld hl, scratch 
16a6 5e			.cfdir:	ld e,(hl) 
16a7 23				inc hl 
16a8 56				ld d,(hl) 
16a9 23				inc hl 
16aa			 
16aa eb				ex de, hl 
16ab cd 27 0f			call ishlzero 
16ae c8				ret z     ; return on null pointer 
16af cd 8f 14			call free 
16b2 eb				ex de, hl 
16b3 18 f1			jr .cfdir 
16b5			 
16b5			 
16b5 c9				ret 
16b6			 
16b6			 
16b6			config_dir: 
16b6			 
16b6				; for the config menus that need to build a directory of storage call this routine 
16b6				; it will construct a menu in scratch to pass to menu 
16b6			 
16b6				; open storage device 
16b6			 
16b6				; execute DIR to build a list of files and their ids into scratch in menu format 
16b6				; once the menu has finished then will need to call config_fdir to release the strings 
16b6				 
16b6				; c = number items 
16b6			 
16b6				 
16b6 cd 85 04			call storage_get_block_0 
16b9			 
16b9 21 81 fa			ld hl, store_page     ; get current id count 
16bc 46				ld b, (hl) 
16bd 0e 00			ld c, 0    ; count of files   
16bf			 
16bf			 
16bf 21 ff f1			ld hl, scratch 
16c2 22 78 fa			ld (store_tmp2), hl    ; location to poke strings 
16c5			 
16c5				; check for empty drive 
16c5			 
16c5 3e 00			ld a, 0 
16c7 b8				cp b 
16c8 ca 62 17			jp z, .dirdone 
16cb			 
16cb				 
16cb					if DEBUG_FORTH_WORDS 
16cb						DMARK "Cdc" 
16cb f5				push af  
16cc 3a e0 16			ld a, (.dmark)  
16cf 32 6e fe			ld (debug_mark),a  
16d2 3a e1 16			ld a, (.dmark+1)  
16d5 32 6f fe			ld (debug_mark+1),a  
16d8 3a e2 16			ld a, (.dmark+2)  
16db 32 70 fe			ld (debug_mark+2),a  
16de 18 03			jr .pastdmark  
16e0 ..			.dmark: db "Cdc"  
16e3 f1			.pastdmark: pop af  
16e4			endm  
# End of macro DMARK
16e4						CALLMONITOR 
16e4 cd a5 18			call break_point_state  
16e7				endm  
# End of macro CALLMONITOR
16e7					endif 
16e7			 
16e7			 
16e7			.diritem:	 
16e7 c5				push bc 
16e8				; for each of the current ids do a search for them and if found push to stack 
16e8			 
16e8 21 40 00				ld hl, STORE_BLOCK_PHY 
16eb 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
16ed 58					ld e,b 
16ee			 
16ee cd 07 07				call storage_findnextid 
16f1			 
16f1			 
16f1					; if found hl will be non zero 
16f1			 
16f1 cd 27 0f				call ishlzero 
16f4 28 69				jr z, .dirnotfound 
16f6			 
16f6					; increase count 
16f6			 
16f6 c1					pop bc	 
16f7 0c					inc c 
16f8 c5					push bc 
16f9					 
16f9			 
16f9					; get file header and push the file name 
16f9			 
16f9 11 81 fa				ld de, store_page 
16fc cd d4 03				call storage_read_block 
16ff			 
16ff					; push file id to stack 
16ff				 
16ff 3a 81 fa				ld a, (store_page) 
1702 26 00				ld h, 0 
1704 6f					ld l, a 
1705			 
1705					;call forth_push_numhl 
1705					; TODO store id 
1705			 
1705 e5					push hl 
1706			 
1706					; push extent count to stack  
1706				 
1706 21 84 fa				ld hl, store_page+3 
1709			 
1709					; get file name length 
1709			 
1709 cd 5c 13				call strlenz   
170c			 
170c 23					inc hl   ; cover zero term 
170d 23					inc hl  ; stick the id at the end of the area 
170e			 
170e e5					push hl 
170f c1					pop bc    ; move length to bc 
1710			 
1710 cd c5 13				call malloc 
1713			 
1713					; TODO save malloc area to scratch 
1713			 
1713 eb					ex de, hl 
1714 2a 78 fa				ld hl, (store_tmp2) 
1717 73					ld (hl), e 
1718 23					inc hl 
1719 72					ld (hl), d 
171a 23					inc hl 
171b 22 78 fa				ld (store_tmp2), hl 
171e			 
171e					 
171e			 
171e					;pop hl   ; get source 
171e			;		ex de, hl    ; swap aronund	 
171e			 
171e 21 84 fa				ld hl, store_page+3 
1721					if DEBUG_FORTH_WORDS 
1721						DMARK "CFd" 
1721 f5				push af  
1722 3a 36 17			ld a, (.dmark)  
1725 32 6e fe			ld (debug_mark),a  
1728 3a 37 17			ld a, (.dmark+1)  
172b 32 6f fe			ld (debug_mark+1),a  
172e 3a 38 17			ld a, (.dmark+2)  
1731 32 70 fe			ld (debug_mark+2),a  
1734 18 03			jr .pastdmark  
1736 ..			.dmark: db "CFd"  
1739 f1			.pastdmark: pop af  
173a			endm  
# End of macro DMARK
173a						CALLMONITOR 
173a cd a5 18			call break_point_state  
173d				endm  
# End of macro CALLMONITOR
173d					endif 
173d ed b0				ldir 
173f			 
173f					; de is past string, move back one and store id 
173f					 
173f 1b					dec de 
1740			 
1740					; store file id 
1740			 
1740 e1					pop hl 
1741 eb					ex de,hl 
1742 73					ld (hl), e 
1743			 
1743					if DEBUG_FORTH_WORDS 
1743						DMARK "Cdi" 
1743 f5				push af  
1744 3a 58 17			ld a, (.dmark)  
1747 32 6e fe			ld (debug_mark),a  
174a 3a 59 17			ld a, (.dmark+1)  
174d 32 6f fe			ld (debug_mark+1),a  
1750 3a 5a 17			ld a, (.dmark+2)  
1753 32 70 fe			ld (debug_mark+2),a  
1756 18 03			jr .pastdmark  
1758 ..			.dmark: db "Cdi"  
175b f1			.pastdmark: pop af  
175c			endm  
# End of macro DMARK
175c						CALLMONITOR 
175c cd a5 18			call break_point_state  
175f				endm  
# End of macro CALLMONITOR
175f					endif 
175f					 
175f			.dirnotfound: 
175f c1					pop bc     
1760 10 85				djnz .diritem 
1762				 
1762			.dirdone:	 
1762			 
1762 3e 00				ld a, 0 
1764 2a 78 fa				ld hl, (store_tmp2) 
1767 77					ld (hl), a 
1768 23					inc hl 
1769 77					ld (hl), a 
176a 23					inc hl 
176b					; push a count of the dir items found 
176b			 
176b			;		ld h, 0 
176b			;		ld l, c 
176b			 
176b c9				ret 
176c			 
176c			endif 
176c			 
176c			 
176c			; Settings 
176c			; Run  
176c			 
176c			 
176c			 
176c			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
176c			;;hd_menu2:   db "        2: Editor",0   
176c			;hd_menu2:   db "        2: Editor       6: Menu",0   
176c			;hd_menu3:   db "        3: Storage",0 
176c			;hd_menu4:   db "0=quit  4: Debug",0 
176c			;hd_don:     db "ON",0 
176c			;hd_doff:     db "OFF",0 
176c			; 
176c			; 
176c			; 
176c			;hardware_diags_old:       
176c			; 
176c			;.diagmenu: 
176c			;	call clear_display 
176c			;	ld a, display_row_1 
176c			;	ld de, hd_menu1 
176c			;	call str_at_display 
176c			; 
176c			;	ld a, display_row_2 
176c			;	ld de, hd_menu2 
176c			;	call str_at_display 
176c			; 
176c			;	ld a, display_row_3 
176c			;	ld de, hd_menu3 
176c			;	call str_at_display 
176c			; 
176c			;	ld a,  display_row_4 
176c			;	ld de, hd_menu4 
176c			;	call str_at_display 
176c			; 
176c			;	; display debug state 
176c			; 
176c			;	ld de, hd_don 
176c			;	ld a, (os_view_disable) 
176c			;	cp 0 
176c			;	jr z, .distog 
176c			;	ld de, hd_doff 
176c			;.distog: ld a, display_row_4+17 
176c			;	call str_at_display 
176c			; 
176c			;	call update_display 
176c			; 
176c			;	call cin_wait 
176c			; 
176c			; 
176c			; 
176c			;	cp '4' 
176c			;	jr nz, .diagn1 
176c			; 
176c			;	; debug toggle 
176c			; 
176c			;	ld a, (os_view_disable) 
176c			;	ld b, '*' 
176c			;	cp 0 
176c			;	jr z, .debtog 
176c			;	ld b, 0 
176c			;.debtog:	 
176c			;	ld a,b 
176c			;	ld (os_view_disable),a 
176c			; 
176c			;.diagn1: cp '0' 
176c			;	 ret z 
176c			; 
176c			;;	cp '1' 
176c			;;       jp z, matrix	 
176c			;;   TODO keyboard matrix test 
176c			; 
176c			;	cp '2' 
176c			;	jp z, .diagedit 
176c			; 
176c			;;	cp '6' 
176c			;;	jp z, .menutest 
176c			;;if ENABLE_BASIC 
176c			;;	cp '6' 
176c			;;	jp z, basic 
176c			;;endif 
176c			 ; 
176c			;	jp .diagmenu 
176c			; 
176c			; 
176c			;	ret 
176c			 
176c			 
176c			.debug_tog: 
176c 21 b3 17			ld hl, .menudebug 
176f				 
176f 3a f0 f1			ld a, (os_view_disable) 
1772 fe 2a			cp '*' 
1774 20 04			jr nz,.tdon  
1776 3e 01			ld a, 1 
1778 18 02			jr .tog1 
177a 3e 00		.tdon: ld a, 0 
177c			 
177c			.tog1: 
177c cd fb 0c			call menu 
177f fe 00			cp 0 
1781 c8				ret z 
1782 fe 01			cp 1    ; disable debug 
1784 28 04			jr z, .dtog0 
1786 3e 2a			ld a, '*' 
1788 18 02			jr .dtogset 
178a 3e 00		.dtog0: ld a, 0 
178c 32 f0 f1		.dtogset:  ld (os_view_disable), a 
178f c3 6c 17			jp .debug_tog 
1792			 
1792			 
1792			hardware_diags:       
1792			 
1792			.diagm: 
1792 21 a5 17			ld hl, .menuitems 
1795 3e 00			ld a, 0 
1797 cd fb 0c			call menu 
179a			 
179a fe 00		         cp 0 
179c c8				 ret z 
179d			 
179d fe 02			cp 2 
179f ca fe 17			jp z, .diagedit 
17a2			 
17a2			;	cp '6' 
17a2			;	jp z, .menutest 
17a2			;if ENABLE_BASIC 
17a2			;	cp '6' 
17a2			;	jp z, basic 
17a2			;endif 
17a2			  
17a2 c3 92 17			jp .diagm 
17a5			 
17a5				 
17a5 b9 17		.menuitems:   	dw .m1 
17a7 c4 17				dw .m2 
17a9 cb 17				dw .m3 
17ab d3 17				dw .m5 
17ad d9 17				dw .m5a 
17af e2 17				dw .m5b 
17b1 00 00				dw 0 
17b3			 
17b3			.menudebug: 
17b3 eb 17				dw .m6 
17b5 f4 17				dw .m7 
17b7 00 00				dw 0 
17b9			 
17b9 .. 00		.m1:   db "Key Matrix",0 
17c4 .. 00		.m2:   db "Editor",0 
17cb .. 00		.m3:   db "Storage",0 
17d3 .. 00		.m5:   db "Sound",0 
17d9 .. 00		.m5a:  db "RAM Test",0 
17e2 .. 00		.m5b:  db "LCD Test",0 
17eb			 
17eb .. 00		.m6:   db "Debug ON",0 
17f4 .. 00		.m7:   db "Debug OFF",0 
17fe			 
17fe			; debug editor 
17fe			 
17fe			.diagedit: 
17fe			 
17fe 21 ff f1			ld hl, scratch 
1801			;	ld bc, 250 
1801			;	ldir 
1801				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1801 3e 00			ld a, 0 
1803 77				ld (hl), a 
1804 23				inc hl 
1805 77				ld (hl), a 
1806 23				inc hl 
1807 77				ld (hl), a 
1808			 
1808 cd ca 0c		        call clear_display 
180b cd ed 0c			call update_display 
180e				;ld a, 1 
180e				;ld (hardware_diag), a 
180e			.diloop: 
180e 3e 00			ld a, display_row_1 
1810 0e 00			ld c, 0 
1812 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1814 1e 28			ld e, 40 
1816			 
1816 21 ff f1			ld hl, scratch	 
1819 cd 2b 0f			call input_str 
181c			 
181c 3e 28			ld a, display_row_2 
181e 11 ff f1			ld de, scratch 
1821 cd dd 0c			call str_at_display 
1824 cd ed 0c			call update_display 
1827			 
1827 c3 0e 18			jp .diloop 
182a			 
182a			 
182a			; pass word in hl 
182a			; a has display location 
182a			display_word_at: 
182a f5				push af 
182b e5				push hl 
182c 7c				ld a,h 
182d 21 04 f5			ld hl, os_word_scratch 
1830 cd ff 11			call hexout 
1833 e1				pop hl 
1834 7d				ld a,l 
1835 21 06 f5			ld hl, os_word_scratch+2 
1838 cd ff 11			call hexout 
183b 21 08 f5			ld hl, os_word_scratch+4 
183e 3e 00			ld a,0 
1840 77				ld (hl),a 
1841 11 04 f5			ld de,os_word_scratch 
1844 f1				pop af 
1845 cd dd 0c				call str_at_display 
1848 c9				ret 
1849			 
1849			display_ptr_state: 
1849			 
1849				; to restore afterwards 
1849			 
1849 d5				push de 
184a c5				push bc 
184b e5				push hl 
184c f5				push af 
184d			 
184d				; for use in here 
184d			 
184d			;	push bc 
184d			;	push de 
184d			;	push hl 
184d			;	push af 
184d			 
184d cd ca 0c			call clear_display 
1850			 
1850 11 23 1a			ld de, .ptrstate 
1853 3e 00			ld a, display_row_1 
1855 cd dd 0c			call str_at_display 
1858			 
1858				; display debug step 
1858			 
1858			 
1858 11 6e fe			ld de, debug_mark 
185b 3e 26			ld a, display_row_1+display_cols-2 
185d cd dd 0c			call str_at_display 
1860			 
1860				; display a 
1860 11 2d 1a			ld de, .ptrcliptr 
1863 3e 28			ld a, display_row_2 
1865 cd dd 0c			call str_at_display 
1868			 
1868 f1				pop af 
1869 2a 4a fa			ld hl,(cli_ptr) 
186c 3e 30			ld a, display_row_2+8 
186e cd 2a 18			call display_word_at 
1871			 
1871			 
1871				; display hl 
1871			 
1871			 
1871 11 35 1a			ld de, .ptrclioptr 
1874 3e 32			ld a, display_row_2+10 
1876 cd dd 0c			call str_at_display 
1879			; 
1879			;	pop hl 
1879 3e 35			ld a, display_row_2+13 
187b 2a 48 fa			ld hl,(cli_origptr) 
187e cd 2a 18			call display_word_at 
1881			; 
1881			;	 
1881			;	; display de 
1881			 
1881			;	ld de, .regstatede 
1881			;	ld a, display_row_3 
1881			;	call str_at_display 
1881			 
1881			;	pop de 
1881			;	ld h,d 
1881			;	ld l, e 
1881			;	ld a, display_row_3+3 
1881			;	call display_word_at 
1881			 
1881			 
1881				; display bc 
1881			 
1881			;	ld de, .regstatebc 
1881			;	ld a, display_row_3+10 
1881			;	call str_at_display 
1881			 
1881			;	pop bc 
1881			;	ld h,b 
1881			;	ld l, c 
1881			;	ld a, display_row_3+13 
1881			;	call display_word_at 
1881			 
1881			 
1881				; display dsp 
1881			 
1881			;	ld de, .regstatedsp 
1881			;	ld a, display_row_4 
1881			;	call str_at_display 
1881			 
1881				 
1881			;	ld hl,(cli_data_sp) 
1881			;	ld a, display_row_4+4 
1881			;	call display_word_at 
1881			 
1881				; display rsp 
1881			 
1881 11 64 1a			ld de, .regstatersp 
1884 3e 82			ld a, display_row_4+10 
1886 cd dd 0c			call str_at_display 
1889			 
1889				 
1889 2a 30 fa			ld hl,(cli_ret_sp) 
188c 3e 86			ld a, display_row_4+14 
188e cd 2a 18			call display_word_at 
1891			 
1891 cd ed 0c			call update_display 
1894			 
1894 cd 47 0c			call delay1s 
1897 cd 47 0c			call delay1s 
189a cd 47 0c			call delay1s 
189d			 
189d			 
189d cd 91 1e			call next_page_prompt 
18a0			 
18a0				; restore  
18a0			 
18a0 f1				pop af 
18a1 e1				pop hl 
18a2 c1				pop bc 
18a3 d1				pop de 
18a4 c9				ret 
18a5			 
18a5			break_point_state: 
18a5 f5				push af 
18a6			 
18a6				; see if disabled 
18a6			 
18a6 3a f0 f1			ld a, (os_view_disable) 
18a9 fe 2a			cp '*' 
18ab 20 02			jr nz, .bpsgo 
18ad f1				pop af 
18ae c9				ret 
18af			 
18af			.bpsgo: 
18af f1				pop af 
18b0 f5				push af 
18b1 22 ec f1			ld (os_view_hl), hl 
18b4 ed 53 ea f1		ld (os_view_de), de 
18b8 ed 43 e8 f1		ld (os_view_bc), bc 
18bc e5				push hl 
18bd 6f				ld l, a 
18be 26 00			ld h, 0 
18c0 22 ee f1			ld (os_view_af),hl 
18c3			 
18c3 21 b4 fd				ld hl, display_fb0 
18c6 22 cf fb				ld (display_fb_active), hl 
18c9 e1				pop hl	 
18ca			 
18ca 3e 31			ld a, '1' 
18cc fe 2a		.bps1:  cp '*' 
18ce 20 03			jr nz, .bps1b 
18d0 32 f0 f1			ld (os_view_disable),a 
18d3 fe 31		.bps1b:  cp '1' 
18d5 20 14			jr nz, .bps2 
18d7			 
18d7				; display reg 
18d7			 
18d7				 
18d7			 
18d7 3a ee f1			ld a, (os_view_af) 
18da 2a ec f1			ld hl, (os_view_hl) 
18dd ed 5b ea f1		ld de, (os_view_de) 
18e1 ed 4b e8 f1		ld bc, (os_view_bc) 
18e5 cd 7f 19			call display_reg_state 
18e8 c3 6b 19			jp .bpschk 
18eb			 
18eb fe 32		.bps2:  cp '2' 
18ed 20 08			jr nz, .bps3 
18ef				 
18ef				; display hl 
18ef 2a ec f1			ld hl, (os_view_hl) 
18f2 cd 69 1a			call display_dump_at_hl 
18f5			 
18f5 18 74			jr .bpschk 
18f7			 
18f7 fe 33		.bps3:  cp '3' 
18f9 20 08			jr nz, .bps4 
18fb			 
18fb			        ; display de 
18fb 2a ea f1			ld hl, (os_view_de) 
18fe cd 69 1a			call display_dump_at_hl 
1901			 
1901 18 68			jr .bpschk 
1903 fe 34		.bps4:  cp '4' 
1905 20 08			jr nz, .bps5 
1907			 
1907			        ; display bc 
1907 2a e8 f1			ld hl, (os_view_bc) 
190a cd 69 1a			call display_dump_at_hl 
190d			 
190d 18 5c			jr .bpschk 
190f fe 35		.bps5:  cp '5' 
1911 20 08		        jr nz, .bps7 
1913			 
1913				; display cur ptr 
1913 2a 4a fa			ld hl, (cli_ptr) 
1916 cd 69 1a			call display_dump_at_hl 
1919			 
1919 18 50			jr .bpschk 
191b fe 36		.bps7:  cp '6' 
191d 20 08			jr nz, .bps8b 
191f				 
191f				; display cur orig ptr 
191f 2a 48 fa			ld hl, (cli_origptr) 
1922 cd 69 1a			call display_dump_at_hl 
1925 18 44			jr .bpschk 
1927 fe 37		.bps8b:  cp '7' 
1929 20 08			jr nz, .bps9 
192b				 
192b				; display dsp 
192b 2a 2c fa			ld hl, (cli_data_sp) 
192e cd 69 1a			call display_dump_at_hl 
1931			 
1931 18 38			jr .bpschk 
1933 fe 39		.bps9:  cp '9' 
1935 20 05			jr nz, .bps8c 
1937				 
1937				; display SP 
1937			;	ld hl, sp 
1937 cd 69 1a			call display_dump_at_hl 
193a			 
193a 18 2f			jr .bpschk 
193c fe 38		.bps8c:  cp '8' 
193e 20 08			jr nz, .bps8d 
1940				 
1940				; display rsp 
1940 2a 30 fa			ld hl, (cli_ret_sp) 
1943 cd 69 1a			call display_dump_at_hl 
1946			 
1946 18 23			jr .bpschk 
1948 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
194a 20 05			jr nz, .bps8 
194c cd 87 1c			call monitor 
194f			 
194f 18 1a			jr .bpschk 
1951 fe 30		.bps8:  cp '0' 
1953 20 16			jr nz, .bpschk 
1955			 
1955 21 13 fd				ld hl, display_fb1 
1958 22 cf fb				ld (display_fb_active), hl 
195b cd ed 0c				call update_display 
195e			 
195e				;ld a, (os_view_af) 
195e 2a ec f1			ld hl, (os_view_hl) 
1961 ed 5b ea f1		ld de, (os_view_de) 
1965 ed 4b e8 f1		ld bc, (os_view_bc) 
1969 f1				pop af 
196a c9				ret 
196b			 
196b			.bpschk:   
196b cd 47 0c			call delay1s 
196e 3e 9f		ld a,display_row_4 + display_cols - 1 
1970 11 8f 1e		        ld de, endprg 
1973 cd dd 0c			call str_at_display 
1976 cd ed 0c			call update_display 
1979 cd 1c 6d			call cin_wait 
197c			 
197c c3 cc 18			jp .bps1 
197f			 
197f			 
197f			display_reg_state: 
197f			 
197f				; to restore afterwards 
197f			 
197f d5				push de 
1980 c5				push bc 
1981 e5				push hl 
1982 f5				push af 
1983			 
1983				; for use in here 
1983			 
1983 c5				push bc 
1984 d5				push de 
1985 e5				push hl 
1986 f5				push af 
1987			 
1987 cd ca 0c			call clear_display 
198a			 
198a 11 3f 1a			ld de, .regstate 
198d 3e 00			ld a, display_row_1 
198f cd dd 0c			call str_at_display 
1992			 
1992				; display debug step 
1992			 
1992			 
1992 11 6e fe			ld de, debug_mark 
1995 3e 25			ld a, display_row_1+display_cols-3 
1997 cd dd 0c			call str_at_display 
199a			 
199a				; display a 
199a 11 5b 1a			ld de, .regstatea 
199d 3e 28			ld a, display_row_2 
199f cd dd 0c			call str_at_display 
19a2			 
19a2 e1				pop hl 
19a3			;	ld h,0 
19a3			;	ld l, a 
19a3 3e 2b			ld a, display_row_2+3 
19a5 cd 2a 18			call display_word_at 
19a8			 
19a8			 
19a8				; display hl 
19a8			 
19a8			 
19a8 11 4f 1a			ld de, .regstatehl 
19ab 3e 32			ld a, display_row_2+10 
19ad cd dd 0c			call str_at_display 
19b0			 
19b0 e1				pop hl 
19b1 3e 35			ld a, display_row_2+13 
19b3 cd 2a 18			call display_word_at 
19b6			 
19b6				 
19b6				; display de 
19b6			 
19b6 11 53 1a			ld de, .regstatede 
19b9 3e 50			ld a, display_row_3 
19bb cd dd 0c			call str_at_display 
19be			 
19be e1				pop hl 
19bf			;	ld h,d 
19bf			;	ld l, e 
19bf 3e 53			ld a, display_row_3+3 
19c1 cd 2a 18			call display_word_at 
19c4			 
19c4			 
19c4				; display bc 
19c4			 
19c4 11 57 1a			ld de, .regstatebc 
19c7 3e 5a			ld a, display_row_3+10 
19c9 cd dd 0c			call str_at_display 
19cc			 
19cc e1				pop hl 
19cd			;	ld h,b 
19cd			;	ld l, c 
19cd 3e 5d			ld a, display_row_3+13 
19cf cd 2a 18			call display_word_at 
19d2			 
19d2			 
19d2				; display dsp 
19d2			 
19d2 11 5f 1a			ld de, .regstatedsp 
19d5 3e 78			ld a, display_row_4 
19d7 cd dd 0c			call str_at_display 
19da			 
19da				 
19da 2a 2c fa			ld hl,(cli_data_sp) 
19dd 3e 7c			ld a, display_row_4+4 
19df cd 2a 18			call display_word_at 
19e2			 
19e2				; display rsp 
19e2			 
19e2 11 64 1a			ld de, .regstatersp 
19e5 3e 82			ld a, display_row_4+10 
19e7 cd dd 0c			call str_at_display 
19ea			 
19ea				 
19ea 2a 30 fa			ld hl,(cli_ret_sp) 
19ed 3e 86			ld a, display_row_4+14 
19ef cd 2a 18			call display_word_at 
19f2			 
19f2 cd ed 0c			call update_display 
19f5			 
19f5			;	call delay1s 
19f5			;	call delay1s 
19f5			;	call delay1s 
19f5			 
19f5			 
19f5			;	call next_page_prompt 
19f5			 
19f5				; restore  
19f5			 
19f5 f1				pop af 
19f6 e1				pop hl 
19f7 c1				pop bc 
19f8 d1				pop de 
19f9 c9				ret 
19fa			 
19fa .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a0e .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a23 .. 00		.ptrstate:	db "Ptr State",0 
1a2d .. 00		.ptrcliptr:     db "cli_ptr",0 
1a35 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a3f .. 00		.regstate:	db "Reg State (1/0)",0 
1a4f .. 00		.regstatehl:	db "HL:",0 
1a53 .. 00		.regstatede:	db "DE:",0 
1a57 .. 00		.regstatebc:	db "BC:",0 
1a5b .. 00		.regstatea:	db "A :",0 
1a5f .. 00		.regstatedsp:	db "DSP:",0 
1a64 .. 00		.regstatersp:	db "RSP:",0 
1a69			 
1a69			display_dump_at_hl: 
1a69 e5				push hl 
1a6a d5				push de 
1a6b c5				push bc 
1a6c f5				push af 
1a6d			 
1a6d 22 22 f5			ld (os_cur_ptr),hl	 
1a70 cd ca 0c			call clear_display 
1a73 cd 99 1d			call dumpcont 
1a76			;	call delay1s 
1a76			;	call next_page_prompt 
1a76			 
1a76			 
1a76 f1				pop af 
1a77 c1				pop bc 
1a78 d1				pop de 
1a79 e1				pop hl 
1a7a c9				ret 
1a7b			 
1a7b			;if ENABLE_BASIC 
1a7b			;	include "nascombasic.asm" 
1a7b			;	basic: 
1a7b			;	include "forth/FORTH.ASM" 
1a7b			;endif 
1a7b			 
1a7b			; eof 
1a7b			 
1a7b			 
# End of file firmware_diags.asm
1a7b			  
1a7b			include "firmware_prompts.asm"  
1a7b			; Prompts  
1a7b			 
1a7b			; boot messages 
1a7b			 
1a7b .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1a90 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1aa0			 
1aa0			 
1aa0			; config menus 
1aa0			 
1aa0 .. 00		prom_c3: db "Add Dictionary To File",0 
1ab7 .. 00		prom_c2: db "Select Autoload File",0 
1acc .. 00		prom_c2a: db "Disable Autoload File", 0 
1ae2 .. 00		prom_c2b: db "Select Storage Bank",0 
1af6 .. 00		prom_c4: db "Settings",0 
1aff .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b1a .. 00		prom_m4b:   db "Monitor",0 
1b22 .. 00		prom_c1: db "Hardware Diags",0 
1b31			 
1b31			 
1b31 .. 00		prom_notav:    db "Feature not available",0 
1b47 .. 00		prom_empty:    db "",0 
1b48			 
1b48			; eof 
1b48			 
# End of file firmware_prompts.asm
1b48			  
1b48			  
1b48			; eof  
1b48			  
# End of file firmware.asm
1b48			 
1b48			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b48			;if BASE_KEV  
1b48			;baseram: equ 08000h 
1b48			;endif 
1b48			 
1b48			;if BASE_SC114 
1b48			;baseram:     equ    endofcode 
1b48			;endif 
1b48			 
1b48			 
1b48			; start system 
1b48			 
1b48			coldstart: 
1b48				; set sp 
1b48				; di/ei 
1b48			 
1b48 f3				di 
1b49 31 fd ff			ld sp, tos 
1b4c			;	ei 
1b4c			 
1b4c			 
1b4c				; disable breakpoint by default 
1b4c			 
1b4c 3e 2a			ld a,'*' 
1b4e 32 f0 f1			ld (os_view_disable),a 
1b51			 
1b51				; init hardware 
1b51			 
1b51				; init keyboard and screen hardware 
1b51			 
1b51 cd 1c 00			call hardware_init 
1b54			 
1b54			 
1b54 cd 47 0c			call delay1s 
1b57 3e 58			ld a, display_row_3+8 
1b59 11 03 00			ld de, buildtime 
1b5c cd dd 0c			call str_at_display 
1b5f cd ed 0c			call update_display 
1b62			 
1b62 cd 47 0c			call delay1s 
1b65 cd 47 0c			call delay1s 
1b68 cd 47 0c			call delay1s 
1b6b			 
1b6b				; detect if any keys are held down to enable breakpoints at start up 
1b6b			 
1b6b cd 2d 6d			call cin  
1b6e fe 00			cp 0 
1b70 28 03			jr z, .nokeys 
1b72			 
1b72				;call hardware_diags 
1b72 cd 88 15			call config 
1b75			 
1b75			;	ld de, .bpen 
1b75			;	ld a, display_row_4 
1b75			;	call str_at_display 
1b75			;	call update_display 
1b75			; 
1b75			;	ld a,0 
1b75			;	ld (os_view_disable),a 
1b75			; 
1b75			;.bpwait: 
1b75			;	call cin 
1b75			;	cp 0 
1b75			;	jr z, .bpwait 
1b75			;	jr .nokeys 
1b75			; 
1b75			; 
1b75			;.bpen:  db "Break points enabled!",0 
1b75			 
1b75			 
1b75			 
1b75			 
1b75			 
1b75			 
1b75			.nokeys: 
1b75			 
1b75			 
1b75				 
1b75			 
1b75			;jp  testkey 
1b75			 
1b75			;call storage_get_block_0 
1b75			; 
1b75			;ld hl, 0 
1b75			;ld de, store_page 
1b75			;call storage_read_block 
1b75			 
1b75				 
1b75			;ld hl, 10 
1b75			;ld de, store_page 
1b75			;call storage_read_block 
1b75			 
1b75			 
1b75			 
1b75			 
1b75			 
1b75			;stop:	nop 
1b75			;	jp stop 
1b75			 
1b75			 
1b75			 
1b75			main: 
1b75 cd ca 0c			call clear_display 
1b78 cd ed 0c			call update_display 
1b7b			 
1b7b			 
1b7b			 
1b7b			;	call testlcd 
1b7b			 
1b7b			 
1b7b			 
1b7b cd 57 22			call forth_init 
1b7e			 
1b7e			 
1b7e			warmstart: 
1b7e cd 2d 22			call forth_warmstart 
1b81			 
1b81				; run startup word load 
1b81			        ; TODO prevent this running at warmstart after crash  
1b81			 
1b81				if STARTUP_ENABLE 
1b81					if STORAGE_SE 
1b81 cd bb 68					call forth_autoload 
1b84					endif 
1b84 cd ca 65				call forth_startup 
1b87			 
1b87			 
1b87				endif 
1b87			 
1b87				; show free memory after boot 
1b87 11 21 1c			ld de, freeram 
1b8a 3e 00			ld a, display_row_1 
1b8c cd dd 0c			call str_at_display 
1b8f			 
1b8f			; Or use heap_size word???? 
1b8f 21 e5 f1			ld hl, heap_end 
1b92 11 0e 80			ld de, heap_start 
1b95 ed 52			sbc hl, de 
1b97 e5				push hl 
1b98 7c				ld a,h	         	 
1b99 21 04 f5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b9c cd ff 11			call hexout 
1b9f e1			   	pop hl 
1ba0			 
1ba0 7d				ld a,l 
1ba1 21 06 f5			ld hl, os_word_scratch+2 
1ba4 cd ff 11			call hexout 
1ba7 21 08 f5			ld hl, os_word_scratch+4 
1baa 3e 00			ld a, 0 
1bac 77				ld (hl),a 
1bad 11 04 f5			ld de, os_word_scratch 
1bb0 3e 0d			ld a, display_row_1 + 13 
1bb2 cd dd 0c			call str_at_display 
1bb5 cd ed 0c			call update_display 
1bb8			 
1bb8			 
1bb8				;call demo 
1bb8			 
1bb8			 
1bb8				; init scratch input area for cli commands 
1bb8			 
1bb8 21 26 f5			ld hl, os_cli_cmd 
1bbb 3e 00			ld a,0 
1bbd 77				ld (hl),a 
1bbe 23				inc hl 
1bbf 77				ld (hl),a 
1bc0			 
1bc0 3e 00			ld a,0 
1bc2 32 25 f6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1bc5			 
1bc5 32 22 f5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1bc8 32 23 f5			ld (os_cur_ptr+1),a	 
1bcb			 
1bcb 32 04 f5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1bce 32 05 f5			ld (os_word_scratch+1),a	 
1bd1				 
1bd1			 
1bd1				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bd1 21 26 f5			ld hl, os_cli_cmd 
1bd4			 
1bd4 3e 00			ld a, 0		 ; init cli input 
1bd6 77				ld (hl), a 
1bd7 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bd9			cli: 
1bd9				; show cli prompt 
1bd9				;push af 
1bd9				;ld a, 0 
1bd9				;ld de, prompt 
1bd9				;call str_at_display 
1bd9			 
1bd9				;call update_display 
1bd9				;pop af 
1bd9				;inc a 
1bd9				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bd9 0e 00			ld c, 0 
1bdb 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1bdd 1e 28			ld e, 40 
1bdf			 
1bdf 21 26 f5			ld hl, os_cli_cmd 
1be2			 
1be2				STACKFRAME OFF $fefe $9f9f 
1be2				if DEBUG_STACK_IMB 
1be2					if OFF 
1be2						exx 
1be2						ld de, $fefe 
1be2						ld a, d 
1be2						ld hl, curframe 
1be2						call hexout 
1be2						ld a, e 
1be2						ld hl, curframe+2 
1be2						call hexout 
1be2						ld hl, $fefe 
1be2						push hl 
1be2						ld hl, $9f9f 
1be2						push hl 
1be2						exx 
1be2					endif 
1be2				endif 
1be2			endm 
# End of macro STACKFRAME
1be2			 
1be2 cd 2b 0f			call input_str 
1be5			 
1be5				STACKFRAMECHK OFF $fefe $9f9f 
1be5				if DEBUG_STACK_IMB 
1be5					if OFF 
1be5						exx 
1be5						ld hl, $9f9f 
1be5						pop de   ; $9f9f 
1be5						call cmp16 
1be5						jr nz, .spnosame 
1be5						ld hl, $fefe 
1be5						pop de   ; $fefe 
1be5						call cmp16 
1be5						jr z, .spfrsame 
1be5						.spnosame: call showsperror 
1be5						.spfrsame: nop 
1be5						exx 
1be5					endif 
1be5				endif 
1be5			endm 
# End of macro STACKFRAMECHK
1be5			 
1be5				; copy input to last command 
1be5			 
1be5 21 26 f5			ld hl, os_cli_cmd 
1be8 11 25 f6			ld de, os_last_cmd 
1beb 01 ff 00			ld bc, 255 
1bee ed b0			ldir 
1bf0			 
1bf0				; wipe current buffer 
1bf0			 
1bf0			;	ld a, 0 
1bf0			;	ld hl, os_cli_cmd 
1bf0			;	ld de, os_cli_cmd+1 
1bf0			;	ld bc, 254 
1bf0			;	ldir 
1bf0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1bf0			;	call strcpy 
1bf0			;	ld a, 0 
1bf0			;	ld (hl), a 
1bf0			;	inc hl 
1bf0			;	ld (hl), a 
1bf0			;	inc hl 
1bf0			;	ld (hl), a 
1bf0			 
1bf0				; switch frame buffer to program  
1bf0			 
1bf0 21 13 fd				ld hl, display_fb1 
1bf3 22 cf fb				ld (display_fb_active), hl 
1bf6			 
1bf6			;	nop 
1bf6				STACKFRAME ON $fbfe $8f9f 
1bf6				if DEBUG_STACK_IMB 
1bf6					if ON 
1bf6						exx 
1bf6						ld de, $fbfe 
1bf6						ld a, d 
1bf6						ld hl, curframe 
1bf6						call hexout 
1bf6						ld a, e 
1bf6						ld hl, curframe+2 
1bf6						call hexout 
1bf6						ld hl, $fbfe 
1bf6						push hl 
1bf6						ld hl, $8f9f 
1bf6						push hl 
1bf6						exx 
1bf6					endif 
1bf6				endif 
1bf6			endm 
# End of macro STACKFRAME
1bf6				; first time into the parser so pass over the current scratch pad 
1bf6 21 26 f5			ld hl,os_cli_cmd 
1bf9				; tokenise the entered statement(s) in HL 
1bf9 cd d5 22			call forthparse 
1bfc			        ; exec forth statements in top of return stack 
1bfc cd 15 23			call forthexec 
1bff				;call forthexec_cleanup 
1bff			;	call parsenext 
1bff			 
1bff				STACKFRAMECHK ON $fbfe $8f9f 
1bff				if DEBUG_STACK_IMB 
1bff					if ON 
1bff						exx 
1bff						ld hl, $8f9f 
1bff						pop de   ; $8f9f 
1bff						call cmp16 
1bff						jr nz, .spnosame 
1bff						ld hl, $fbfe 
1bff						pop de   ; $fbfe 
1bff						call cmp16 
1bff						jr z, .spfrsame 
1bff						.spnosame: call showsperror 
1bff						.spfrsame: nop 
1bff						exx 
1bff					endif 
1bff				endif 
1bff			endm 
# End of macro STACKFRAMECHK
1bff				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1bff			 
1bff 3e 78			ld a, display_row_4 
1c01 11 33 1c			ld de, endprog 
1c04			 
1c04 cd ed 0c			call update_display		 
1c07			 
1c07 cd 91 1e			call next_page_prompt 
1c0a			 
1c0a				; switch frame buffer to cli 
1c0a			 
1c0a 21 b4 fd				ld hl, display_fb0 
1c0d 22 cf fb				ld (display_fb_active), hl 
1c10			 
1c10			 
1c10 cd ca 0c		        call clear_display 
1c13 cd ed 0c			call update_display		 
1c16			 
1c16 21 26 f5			ld hl, os_cli_cmd 
1c19			 
1c19 3e 00			ld a, 0		 ; init cli input 
1c1b 77				ld (hl), a 
1c1c			 
1c1c				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c1c			 
1c1c				; now on last line 
1c1c			 
1c1c				; TODO scroll screen up 
1c1c			 
1c1c				; TODO instead just clear screen and place at top of screen 
1c1c			 
1c1c			;	ld a, 0 
1c1c			;	ld (f_cursor_ptr),a 
1c1c			 
1c1c				;call clear_display 
1c1c				;call update_display 
1c1c			 
1c1c				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c1c 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c1e c3 d9 1b			jp cli 
1c21			 
1c21 .. 00		freeram: db "Free bytes: $",0 
1c2f ..			asc: db "1A2F" 
1c33 .. 00		endprog: db "End prog...",0 
1c3f			 
1c3f			testenter2:   
1c3f 21 31 f2			ld hl,scratch+50 
1c42 22 22 f5			ld (os_cur_ptr),hl 
1c45 c3 d9 1b			jp cli 
1c48			 
1c48			testenter:  
1c48			 
1c48 21 2f 1c			ld hl,asc 
1c4b			;	ld a,(hl) 
1c4b			;	call nibble2val 
1c4b cd 55 12			call get_byte 
1c4e			 
1c4e			 
1c4e			;	ld a,(hl) 
1c4e			;	call atohex 
1c4e			 
1c4e			;	call fourehexhl 
1c4e 32 31 f2			ld (scratch+50),a 
1c51			 
1c51			 
1c51			 
1c51 21 31 1c			ld hl,asc+2 
1c54			;	ld a, (hl) 
1c54			;	call nibble2val 
1c54 cd 55 12			call get_byte 
1c57			 
1c57			;	call fourehexhl 
1c57 32 33 f2			ld (scratch+52),a 
1c5a				 
1c5a 21 31 f2			ld hl,scratch+50 
1c5d 22 22 f5			ld (os_cur_ptr),hl 
1c60 c3 d9 1b			jp cli 
1c63			 
1c63			enter:	 
1c63 3a 03 f2			ld a,(scratch+4) 
1c66 fe 00			cp 0 
1c68 28 0c			jr z, .entercont 
1c6a				; no, not a null term line so has an address to work out.... 
1c6a			 
1c6a 21 01 f2			ld hl,scratch+2 
1c6d cd b5 12			call get_word_hl 
1c70			 
1c70 22 22 f5			ld (os_cur_ptr),hl	 
1c73 c3 d9 1b			jp cli 
1c76			 
1c76			 
1c76			.entercont:  
1c76			 
1c76 21 01 f2			ld hl, scratch+2 
1c79 cd 55 12			call get_byte 
1c7c			 
1c7c 2a 22 f5		   	ld hl,(os_cur_ptr) 
1c7f 77					ld (hl),a 
1c80 23					inc hl 
1c81 22 22 f5				ld (os_cur_ptr),hl 
1c84				 
1c84			; get byte  
1c84			 
1c84			 
1c84 c3 d9 1b			jp cli 
1c87			 
1c87			 
1c87			; basic monitor support 
1c87			 
1c87			monitor: 
1c87				;  
1c87 cd ca 0c			call clear_display 
1c8a 3e 00			ld a, 0 
1c8c 11 d4 1c			ld de, .monprompt 
1c8f cd dd 0c			call str_at_display 
1c92 cd ed 0c			call update_display 
1c95			 
1c95				; get a monitor command 
1c95			 
1c95 0e 00			ld c, 0     ; entry at top left 
1c97 16 64			ld d, 100   ; max buffer size 
1c99 1e 0f			ld e, 15    ; input scroll area 
1c9b 3e 00			ld a, 0     ; init string 
1c9d 21 fd f3			ld hl, os_input 
1ca0 77				ld (hl), a 
1ca1 23				inc hl 
1ca2 77				ld (hl), a 
1ca3 21 fd f3			ld hl, os_input 
1ca6 3e 01			ld a, 1     ; init string 
1ca8 cd 2b 0f			call input_str 
1cab			 
1cab cd ca 0c		        call clear_display 
1cae cd ed 0c			call update_display		 
1cb1			 
1cb1 3a fd f3			ld a, (os_input) 
1cb4 cd 53 13			call toUpper 
1cb7 fe 48		        cp 'H' 
1cb9 28 6f		        jr z, .monhelp 
1cbb fe 44			cp 'D'		; dump 
1cbd ca 4b 1d			jp z, .mondump	 
1cc0 fe 43			cp 'C'		; dump 
1cc2 ca 65 1d			jp z, .moncdump	 
1cc5 fe 4d			cp 'M'		; dump 
1cc7 ca d6 1c			jp z, .moneditstart 
1cca fe 55			cp 'U'		; dump 
1ccc 28 14			jr z, .monedit	 
1cce fe 51			cp 'Q'		; dump 
1cd0 c8				ret z	 
1cd1			 
1cd1			 
1cd1				; TODO "S" to access symbol by name and not need the address 
1cd1				; TODO "F" to find a string in memory 
1cd1			 
1cd1 c3 87 1c			jp monitor 
1cd4			 
1cd4 .. 00		.monprompt: db ">", 0 
1cd6			 
1cd6			.moneditstart: 
1cd6				; get starting address 
1cd6			 
1cd6 21 ff f3			ld hl,os_input+2 
1cd9 cd b5 12			call get_word_hl 
1cdc			 
1cdc 22 22 f5			ld (os_cur_ptr),hl	 
1cdf			 
1cdf c3 87 1c			jp monitor 
1ce2			 
1ce2			.monedit: 
1ce2				; get byte to load 
1ce2			 
1ce2 21 ff f3			ld hl,os_input+2 
1ce5 cd 55 12			call get_byte 
1ce8			 
1ce8				; get address to update 
1ce8 2a 22 f5			ld hl, (os_cur_ptr) 
1ceb			 
1ceb				; update byte 
1ceb			 
1ceb 77				ld (hl), a 
1cec			 
1cec				; move to next address and save it 
1cec			 
1cec 23				inc hl 
1ced 22 22 f5			ld (os_cur_ptr),hl	 
1cf0			 
1cf0 c3 87 1c			jp monitor 
1cf3			 
1cf3			 
1cf3 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d07 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d23 .. 00		.monhelptext3:  db "Q-Quit",0 
1d2a			        
1d2a			.monhelp: 
1d2a 3e 00			ld a, display_row_1 
1d2c 11 f3 1c		        ld de, .monhelptext1 
1d2f			 
1d2f cd dd 0c			call str_at_display 
1d32 3e 28			ld a, display_row_2 
1d34 11 07 1d		        ld de, .monhelptext2 
1d37					 
1d37 cd dd 0c			call str_at_display 
1d3a 3e 50			ld a, display_row_3 
1d3c 11 23 1d		        ld de, .monhelptext3 
1d3f					 
1d3f cd dd 0c			call str_at_display 
1d42 cd ed 0c			call update_display		 
1d45			 
1d45 cd 91 1e			call next_page_prompt 
1d48 c3 87 1c			jp monitor 
1d4b			 
1d4b			.mondump:    
1d4b 21 ff f3			ld hl,os_input+2 
1d4e cd b5 12			call get_word_hl 
1d51			 
1d51 22 22 f5			ld (os_cur_ptr),hl	 
1d54 cd 99 1d			call dumpcont 
1d57 3e 78			ld a, display_row_4 
1d59 11 33 1c			ld de, endprog 
1d5c			 
1d5c cd ed 0c			call update_display		 
1d5f			 
1d5f cd 91 1e			call next_page_prompt 
1d62 c3 87 1c			jp monitor 
1d65			.moncdump: 
1d65 cd 99 1d			call dumpcont 
1d68 3e 78			ld a, display_row_4 
1d6a 11 33 1c			ld de, endprog 
1d6d			 
1d6d cd ed 0c			call update_display		 
1d70			 
1d70 cd 91 1e			call next_page_prompt 
1d73 c3 87 1c			jp monitor 
1d76			 
1d76			 
1d76			; TODO symbol access  
1d76			 
1d76			.symbols:     ;; A list of symbols that can be called up  
1d76 b4 fd			dw display_fb0 
1d78 .. 00			db "fb0",0  
1d7c 81 fa		     	dw store_page 
1d7e .. 00			db "store_page",0 
1d89			 
1d89			 
1d89			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1d89			 
1d89 3a 00 f2			ld a,(scratch+1) 
1d8c fe 00			cp 0 
1d8e 28 09			jr z, dumpcont 
1d90			 
1d90				; no, not a null term line so has an address to work out.... 
1d90			 
1d90 21 01 f2			ld hl,scratch+2 
1d93 cd b5 12			call get_word_hl 
1d96			 
1d96 22 22 f5			ld (os_cur_ptr),hl	 
1d99			 
1d99			 
1d99			 
1d99			dumpcont: 
1d99			 
1d99				; dump bytes at ptr 
1d99			 
1d99			 
1d99 3e 00			ld a, display_row_1 
1d9b 2a cf fb			ld hl, (display_fb_active) 
1d9e cd fe 0e			call addatohl 
1da1 cd c9 1d			call .dumpbyterow 
1da4			 
1da4 3e 28			ld a, display_row_2 
1da6 2a cf fb			ld hl, (display_fb_active) 
1da9 cd fe 0e			call addatohl 
1dac cd c9 1d			call .dumpbyterow 
1daf			 
1daf			 
1daf 3e 50			ld a, display_row_3 
1db1 2a cf fb			ld hl, (display_fb_active) 
1db4 cd fe 0e			call addatohl 
1db7 cd c9 1d			call .dumpbyterow 
1dba			 
1dba 3e 78			ld a, display_row_4 
1dbc 2a cf fb			ld hl, (display_fb_active) 
1dbf cd fe 0e			call addatohl 
1dc2 cd c9 1d			call .dumpbyterow 
1dc5			 
1dc5 cd ed 0c			call update_display 
1dc8			;		jp cli 
1dc8 c9				ret 
1dc9			 
1dc9			.dumpbyterow: 
1dc9			 
1dc9				;push af 
1dc9			 
1dc9 e5				push hl 
1dca			 
1dca				; calc where to poke the ascii 
1dca			if display_cols == 20 
1dca				ld a, 16 
1dca			else 
1dca 3e 1f			ld a, 31 
1dcc			endif 
1dcc			 
1dcc cd fe 0e			call addatohl 
1dcf 22 04 f5			ld (os_word_scratch),hl  		; save pos for later 
1dd2			 
1dd2			 
1dd2			; display decoding address 
1dd2 2a 22 f5		   	ld hl,(os_cur_ptr) 
1dd5			 
1dd5 7c				ld a,h 
1dd6 e1				pop hl 
1dd7 e5				push hl 
1dd8			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1dd8 cd ff 11			call hexout 
1ddb 2a 22 f5		   	ld hl,(os_cur_ptr) 
1dde			 
1dde 7d				ld a,l 
1ddf e1				pop hl 
1de0 23				inc hl 
1de1 23				inc hl 
1de2 e5				push hl 
1de3			;	ld hl, os_word_scratch+2 
1de3 cd ff 11			call hexout 
1de6 e1				pop hl 
1de7 23				inc hl 
1de8 23				inc hl 
1de9				;ld hl, os_word_scratch+4 
1de9 3e 3a			ld a, ':' 
1deb 77				ld (hl),a 
1dec 23				inc hl 
1ded				;ld a, 0 
1ded				;ld (hl),a 
1ded				;ld de, os_word_scratch 
1ded				;pop af 
1ded				;push af 
1ded			;		ld a, display_row_2 
1ded			;		call str_at_display 
1ded			;		call update_display 
1ded			 
1ded			 
1ded			;pop af 
1ded			;	add 5 
1ded			 
1ded			if display_cols == 20 
1ded				ld b, 4 
1ded			else 
1ded 06 08			ld b, 8 
1def			endif	 
1def			 
1def			.dumpbyte: 
1def c5				push bc 
1df0 e5				push hl 
1df1			 
1df1			 
1df1 2a 22 f5		   	ld hl,(os_cur_ptr) 
1df4 7e					ld a,(hl) 
1df5			 
1df5					; poke the ascii to display 
1df5 2a 04 f5				ld hl,(os_word_scratch) 
1df8 77					ld (hl),a 
1df9 23					inc hl 
1dfa 22 04 f5				ld (os_word_scratch),hl 
1dfd			 
1dfd					 
1dfd			 
1dfd			 
1dfd e1					pop hl 
1dfe e5					push hl 
1dff			 
1dff cd ff 11				call hexout 
1e02			 
1e02					 
1e02 2a 22 f5		   	ld hl,(os_cur_ptr) 
1e05 23				inc hl 
1e06 22 22 f5		   	ld (os_cur_ptr),hl 
1e09			 
1e09 e1					pop hl 
1e0a 23					inc hl 
1e0b 23					inc hl 
1e0c 23					inc hl 
1e0d			 
1e0d			 
1e0d			 
1e0d					;ld a,0 
1e0d					;ld (os_word_scratch+2),a 
1e0d					;pop af 
1e0d					;push af 
1e0d			 
1e0d					;ld de, os_word_scratch 
1e0d					;call str_at_display 
1e0d			;		call update_display 
1e0d			;		pop af 
1e0d c1					pop bc 
1e0e c6 03				add 3 
1e10 10 dd			djnz .dumpbyte 
1e12			 
1e12				 
1e12			 
1e12 c9				ret 
1e13			 
1e13			jump:	 
1e13			 
1e13 21 01 f2			ld hl,scratch+2 
1e16 cd b5 12			call get_word_hl 
1e19				;ld hl,(scratch+2) 
1e19				;call fourehexhl 
1e19			 
1e19 22 22 f5			ld (os_cur_ptr),hl	 
1e1c			 
1e1c e9				jp (hl) 
1e1d			 
1e1d			 
1e1d			 
1e1d			; TODO implement a basic monitor mode to start with 
1e1d			 
1e1d			 
1e1d			 
1e1d			 
1e1d			 
1e1d			 
1e1d			 
1e1d			 
1e1d			 
1e1d			; testing and demo code during development 
1e1d			 
1e1d			 
1e1d .. 00		str1: db "Enter some text...",0 
1e30 .. 00		clear: db "                    ",0 
1e45			 
1e45			demo: 
1e45			 
1e45			 
1e45			 
1e45			;	call update_display 
1e45			 
1e45				; init scratch input area for testing 
1e45 21 ff f1			ld hl, scratch	 
1e48 3e 00			ld a,0 
1e4a 77				ld (hl),a 
1e4b			 
1e4b			 
1e4b 3e 28		            LD   A, display_row_2 
1e4d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e4d 11 1d 1e		            LD   DE, str1 
1e50 cd dd 0c			call str_at_display 
1e53			 
1e53			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e53			cloop:	 
1e53 3e 50		            LD   A, display_row_3 
1e55			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e55 11 30 1e		            LD   DE, clear 
1e58			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1e58 cd dd 0c				call str_at_display 
1e5b 3e 78			ld a, display_row_4 
1e5d 11 8d 1e			ld de, prompt 
1e60			 
1e60 cd dd 0c				call str_at_display 
1e63 cd ed 0c			call update_display 
1e66			 
1e66 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e68 16 0a			ld d, 10 
1e6a 21 ff f1			ld hl, scratch	 
1e6d cd 2b 0f			call input_str 
1e70			 
1e70			;	call clear_display 
1e70			;'	call update_display 
1e70			 
1e70 3e 00		            LD   A, display_row_1 
1e72			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e72 11 30 1e		            LD   DE, clear 
1e75 cd dd 0c				call str_at_display 
1e78			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e78 3e 00		            LD   A, display_row_1 
1e7a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e7a 11 ff f1		            LD   DE, scratch 
1e7d			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e7d cd dd 0c				call str_at_display 
1e80 cd ed 0c			call update_display 
1e83			 
1e83 3e 00				ld a,0 
1e85 21 ff f1			ld hl, scratch 
1e88 77				ld (hl),a 
1e89			 
1e89 00				nop 
1e8a c3 53 1e			jp cloop 
1e8d			 
1e8d			 
1e8d			 
1e8d			; OS Prompt 
1e8d			 
1e8d .. 00		prompt: db ">",0 
1e8f .. 00		endprg: db "?",0 
1e91			 
1e91			 
1e91			; handy next page prompt 
1e91			next_page_prompt: 
1e91 e5				push hl 
1e92 d5				push de 
1e93 f5				push af 
1e94 c5				push bc 
1e95			 
1e95 3e 9f			ld a,display_row_4 + display_cols - 1 
1e97 11 8f 1e		        ld de, endprg 
1e9a cd dd 0c			call str_at_display 
1e9d cd ed 0c			call update_display 
1ea0 cd 1c 6d			call cin_wait 
1ea3 c1				pop bc 
1ea4 f1				pop af 
1ea5 d1				pop de 
1ea6 e1				pop hl 
1ea7			 
1ea7			 
1ea7 c9				ret 
1ea8			 
1ea8			 
1ea8			; forth parser 
1ea8			 
1ea8			; My forth kernel 
1ea8			include "forth_kernel.asm" 
1ea8			; 
1ea8			; kernel to the forth OS 
1ea8			 
1ea8			DS_TYPE_STR: equ 1     ; string type 
1ea8			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ea8			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ea8			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ea8			 
1ea8			FORTH_PARSEV1: equ 0 
1ea8			FORTH_PARSEV2: equ 0 
1ea8			FORTH_PARSEV3: equ 0 
1ea8			FORTH_PARSEV4: equ 0 
1ea8			FORTH_PARSEV5: equ 1 
1ea8			 
1ea8			;if FORTH_PARSEV5 
1ea8			;	FORTH_END_BUFFER: equ 0 
1ea8			;else 
1ea8			FORTH_END_BUFFER: equ 127 
1ea8			;endif 
1ea8			 
1ea8			FORTH_TRUE: equ 1 
1ea8			FORTH_FALSE: equ 0 
1ea8			 
1ea8			if FORTH_PARSEV4 
1ea8			include "forth_stackops.asm" 
1ea8			endif 
1ea8			 
1ea8			if FORTH_PARSEV5 
1ea8			include "forth_stackopsv5.asm" 
1ea8			 
1ea8			; Stack operations for v5 parser on wards 
1ea8			; * DATA stack 
1ea8			; * LOOP stack 
1ea8			; * RETURN stack 
1ea8			 
1ea8			 
1ea8			 
1ea8			FORTH_CHK_DSP_UNDER: macro 
1ea8				push hl 
1ea8				push de 
1ea8				ld hl,(cli_data_sp) 
1ea8				ld de, cli_data_stack 
1ea8				call cmp16 
1ea8				jp c, fault_dsp_under 
1ea8				pop de 
1ea8				pop hl 
1ea8				endm 
1ea8			 
1ea8			 
1ea8			FORTH_CHK_RSP_UNDER: macro 
1ea8				push hl 
1ea8				push de 
1ea8				ld hl,(cli_ret_sp) 
1ea8				ld de, cli_ret_stack 
1ea8				call cmp16 
1ea8				jp c, fault_rsp_under 
1ea8				pop de 
1ea8				pop hl 
1ea8				endm 
1ea8			 
1ea8			FORTH_CHK_LOOP_UNDER: macro 
1ea8				push hl 
1ea8				push de 
1ea8				ld hl,(cli_loop_sp) 
1ea8				ld de, cli_loop_stack 
1ea8				call cmp16 
1ea8				jp c, fault_loop_under 
1ea8				pop de 
1ea8				pop hl 
1ea8				endm 
1ea8			 
1ea8			FORTH_ERR_TOS_NOTSTR: macro 
1ea8				; TOSO might need more for checks when used 
1ea8				push af 
1ea8				ld a,(hl) 
1ea8				cp DS_TYPE_STR 
1ea8				jp nz, type_faultn   
1ea8				pop af 
1ea8				endm 
1ea8			 
1ea8			FORTH_ERR_TOS_NOTNUM: macro 
1ea8				push af 
1ea8				ld a,(hl) 
1ea8				cp DS_TYPE_INUM 
1ea8				jp nz, type_faultn   
1ea8				pop af 
1ea8				endm 
1ea8			 
1ea8			 
1ea8			; increase data stack pointer and save hl to it 
1ea8				 
1ea8			FORTH_DSP_NEXT: macro 
1ea8				call macro_forth_dsp_next 
1ea8				endm 
1ea8			 
1ea8			 
1ea8			macro_forth_dsp_next: 
1ea8				if DEBUG_FORTH_STACK_GUARD 
1ea8 cd 94 66				call check_stacks 
1eab				endif 
1eab e5				push hl 
1eac d5				push de 
1ead eb				ex de,hl 
1eae 2a 2c fa			ld hl,(cli_data_sp) 
1eb1 23				inc hl 
1eb2 23				inc hl 
1eb3			 
1eb3			; PARSEV5 
1eb3 23				inc hl 
1eb4 22 2c fa			ld (cli_data_sp),hl 
1eb7 73				ld (hl), e 
1eb8 23				inc hl 
1eb9 72				ld (hl), d 
1eba d1				pop de 
1ebb e1				pop hl 
1ebc				if DEBUG_FORTH_STACK_GUARD 
1ebc cd 94 66				call check_stacks 
1ebf				endif 
1ebf c9				ret 
1ec0			 
1ec0			 
1ec0			; increase ret stack pointer and save hl to it 
1ec0				 
1ec0			FORTH_RSP_NEXT: macro 
1ec0				call macro_forth_rsp_next 
1ec0				endm 
1ec0			 
1ec0			macro_forth_rsp_next: 
1ec0				if DEBUG_FORTH_STACK_GUARD 
1ec0 cd 94 66				call check_stacks 
1ec3				endif 
1ec3 e5				push hl 
1ec4 d5				push de 
1ec5 eb				ex de,hl 
1ec6 2a 30 fa			ld hl,(cli_ret_sp) 
1ec9 23				inc hl 
1eca 23				inc hl 
1ecb 22 30 fa			ld (cli_ret_sp),hl 
1ece 73				ld (hl), e 
1ecf 23				inc hl 
1ed0 72				ld (hl), d 
1ed1 d1				pop de 
1ed2 e1				pop hl 
1ed3				if DEBUG_FORTH_STACK_GUARD 
1ed3 cd 94 66				call check_stacks 
1ed6				endif 
1ed6 c9				ret 
1ed7			 
1ed7			; get current ret stack pointer and save to hl  
1ed7				 
1ed7			FORTH_RSP_TOS: macro 
1ed7				call macro_forth_rsp_tos 
1ed7				endm 
1ed7			 
1ed7			macro_forth_rsp_tos: 
1ed7				;push de 
1ed7 2a 30 fa			ld hl,(cli_ret_sp) 
1eda cd 12 1f			call loadhlptrtohl 
1edd				;ld e, (hl) 
1edd				;inc hl 
1edd				;ld d, (hl) 
1edd				;ex de, hl 
1edd					if DEBUG_FORTH_WORDS 
1edd			;			DMARK "RST" 
1edd						CALLMONITOR 
1edd cd a5 18			call break_point_state  
1ee0				endm  
# End of macro CALLMONITOR
1ee0					endif 
1ee0				;pop de 
1ee0 c9				ret 
1ee1			 
1ee1			; pop ret stack pointer 
1ee1				 
1ee1			FORTH_RSP_POP: macro 
1ee1				call macro_forth_rsp_pop 
1ee1				endm 
1ee1			 
1ee1			 
1ee1			macro_forth_rsp_pop: 
1ee1				if DEBUG_FORTH_STACK_GUARD 
1ee1			;		DMARK "RPP" 
1ee1 cd 94 66				call check_stacks 
1ee4					FORTH_CHK_RSP_UNDER 
1ee4 e5				push hl 
1ee5 d5				push de 
1ee6 2a 30 fa			ld hl,(cli_ret_sp) 
1ee9 11 ea f9			ld de, cli_ret_stack 
1eec cd 1c 0f			call cmp16 
1eef da a8 67			jp c, fault_rsp_under 
1ef2 d1				pop de 
1ef3 e1				pop hl 
1ef4				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ef4				endif 
1ef4 e5				push hl 
1ef5 2a 30 fa			ld hl,(cli_ret_sp) 
1ef8			 
1ef8			 
1ef8				if FORTH_ENABLE_FREE 
1ef8			 
1ef8					; get pointer 
1ef8			 
1ef8					push de 
1ef8					push hl 
1ef8			 
1ef8					ld e, (hl) 
1ef8					inc hl 
1ef8					ld d, (hl) 
1ef8			 
1ef8					ex de, hl 
1ef8					call free 
1ef8			 
1ef8					pop hl 
1ef8					pop de 
1ef8			 
1ef8			 
1ef8				endif 
1ef8			 
1ef8			 
1ef8 2b				dec hl 
1ef9 2b				dec hl 
1efa 22 30 fa			ld (cli_ret_sp), hl 
1efd				; do stack underflow checks 
1efd e1				pop hl 
1efe				if DEBUG_FORTH_STACK_GUARD 
1efe cd 94 66				call check_stacks 
1f01					FORTH_CHK_RSP_UNDER 
1f01 e5				push hl 
1f02 d5				push de 
1f03 2a 30 fa			ld hl,(cli_ret_sp) 
1f06 11 ea f9			ld de, cli_ret_stack 
1f09 cd 1c 0f			call cmp16 
1f0c da a8 67			jp c, fault_rsp_under 
1f0f d1				pop de 
1f10 e1				pop hl 
1f11				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f11				endif 
1f11 c9				ret 
1f12			 
1f12			 
1f12			 
1f12			; routine to load word pointed to by hl into hl 
1f12			 
1f12			loadhlptrtohl: 
1f12			 
1f12 d5				push de 
1f13 5e				ld e, (hl) 
1f14 23				inc hl 
1f15 56				ld d, (hl) 
1f16 eb				ex de, hl 
1f17 d1				pop de 
1f18			 
1f18 c9				ret 
1f19			 
1f19			 
1f19			 
1f19			 
1f19			 
1f19			; push a number held in HL onto the data stack 
1f19			; entry point for pushing a value when already in hl used in function above 
1f19			 
1f19			forth_push_numhl: 
1f19			 
1f19 e5				push hl    ; save value to push 
1f1a			 
1f1a			if DEBUG_FORTH_PUSH 
1f1a				; see if disabled 
1f1a			 
1f1a			 
1f1a f5				push af 
1f1b 3a f0 f1			ld a, (os_view_disable) 
1f1e fe 2a			cp '*' 
1f20 28 34			jr z, .pskip2 
1f22 e5				push hl 
1f23 e5			push hl 
1f24 cd ca 0c			call clear_display 
1f27 e1			pop hl 
1f28 7c				ld a,h 
1f29 21 04 f5			ld hl, os_word_scratch 
1f2c cd ff 11			call hexout 
1f2f e1				pop hl 
1f30 7d				ld a,l 
1f31 21 06 f5			ld hl, os_word_scratch+2 
1f34 cd ff 11			call hexout 
1f37			 
1f37 21 08 f5			ld hl, os_word_scratch+4 
1f3a 3e 00			ld a,0 
1f3c 77				ld (hl),a 
1f3d 11 04 f5			ld de,os_word_scratch 
1f40 3e 28				ld a, display_row_2 
1f42 cd dd 0c				call str_at_display 
1f45 11 2a 55			ld de, .push_num 
1f48 3e 00			ld a, display_row_1 
1f4a			 
1f4a cd dd 0c				call str_at_display 
1f4d			 
1f4d			 
1f4d cd ed 0c			call update_display 
1f50 cd 47 0c			call delay1s 
1f53 cd 47 0c			call delay1s 
1f56			.pskip2:  
1f56			 
1f56 f1				pop af 
1f57			endif	 
1f57			 
1f57			 
1f57				FORTH_DSP_NEXT 
1f57 cd a8 1e			call macro_forth_dsp_next 
1f5a				endm 
# End of macro FORTH_DSP_NEXT
1f5a			 
1f5a 2a 2c fa			ld hl, (cli_data_sp) 
1f5d			 
1f5d				; save item type 
1f5d 3e 02			ld a,  DS_TYPE_INUM 
1f5f 77				ld (hl), a 
1f60 23				inc hl 
1f61			 
1f61				; get word off stack 
1f61 d1				pop de 
1f62 7b				ld a,e 
1f63 77				ld (hl), a 
1f64 23				inc hl 
1f65 7a				ld a,d 
1f66 77				ld (hl), a 
1f67			 
1f67			if DEBUG_FORTH_PUSH 
1f67 2b				dec hl 
1f68 2b				dec hl 
1f69 2b				dec hl 
1f6a						DMARK "PH5" 
1f6a f5				push af  
1f6b 3a 7f 1f			ld a, (.dmark)  
1f6e 32 6e fe			ld (debug_mark),a  
1f71 3a 80 1f			ld a, (.dmark+1)  
1f74 32 6f fe			ld (debug_mark+1),a  
1f77 3a 81 1f			ld a, (.dmark+2)  
1f7a 32 70 fe			ld (debug_mark+2),a  
1f7d 18 03			jr .pastdmark  
1f7f ..			.dmark: db "PH5"  
1f82 f1			.pastdmark: pop af  
1f83			endm  
# End of macro DMARK
1f83				CALLMONITOR 
1f83 cd a5 18			call break_point_state  
1f86				endm  
# End of macro CALLMONITOR
1f86			endif	 
1f86			 
1f86 c9				ret 
1f87			 
1f87			 
1f87			; Push a string to stack pointed to by hl 
1f87			 
1f87			forth_push_str: 
1f87			 
1f87			if DEBUG_FORTH_PUSH 
1f87						DMARK "PSQ" 
1f87 f5				push af  
1f88 3a 9c 1f			ld a, (.dmark)  
1f8b 32 6e fe			ld (debug_mark),a  
1f8e 3a 9d 1f			ld a, (.dmark+1)  
1f91 32 6f fe			ld (debug_mark+1),a  
1f94 3a 9e 1f			ld a, (.dmark+2)  
1f97 32 70 fe			ld (debug_mark+2),a  
1f9a 18 03			jr .pastdmark  
1f9c ..			.dmark: db "PSQ"  
1f9f f1			.pastdmark: pop af  
1fa0			endm  
# End of macro DMARK
1fa0				CALLMONITOR 
1fa0 cd a5 18			call break_point_state  
1fa3				endm  
# End of macro CALLMONITOR
1fa3			endif	 
1fa3			    
1fa3 e5				push hl 
1fa4 e5				push hl 
1fa5			 
1fa5			;	ld a, 0   ; find end of string 
1fa5 cd 5c 13			call strlenz 
1fa8			if DEBUG_FORTH_PUSH 
1fa8						DMARK "PQ2" 
1fa8 f5				push af  
1fa9 3a bd 1f			ld a, (.dmark)  
1fac 32 6e fe			ld (debug_mark),a  
1faf 3a be 1f			ld a, (.dmark+1)  
1fb2 32 6f fe			ld (debug_mark+1),a  
1fb5 3a bf 1f			ld a, (.dmark+2)  
1fb8 32 70 fe			ld (debug_mark+2),a  
1fbb 18 03			jr .pastdmark  
1fbd ..			.dmark: db "PQ2"  
1fc0 f1			.pastdmark: pop af  
1fc1			endm  
# End of macro DMARK
1fc1				CALLMONITOR 
1fc1 cd a5 18			call break_point_state  
1fc4				endm  
# End of macro CALLMONITOR
1fc4			endif	 
1fc4 eb				ex de, hl 
1fc5 e1				pop hl   ; get ptr to start of string 
1fc6			if DEBUG_FORTH_PUSH 
1fc6						DMARK "PQ3" 
1fc6 f5				push af  
1fc7 3a db 1f			ld a, (.dmark)  
1fca 32 6e fe			ld (debug_mark),a  
1fcd 3a dc 1f			ld a, (.dmark+1)  
1fd0 32 6f fe			ld (debug_mark+1),a  
1fd3 3a dd 1f			ld a, (.dmark+2)  
1fd6 32 70 fe			ld (debug_mark+2),a  
1fd9 18 03			jr .pastdmark  
1fdb ..			.dmark: db "PQ3"  
1fde f1			.pastdmark: pop af  
1fdf			endm  
# End of macro DMARK
1fdf				CALLMONITOR 
1fdf cd a5 18			call break_point_state  
1fe2				endm  
# End of macro CALLMONITOR
1fe2			endif	 
1fe2 19				add hl,de 
1fe3			if DEBUG_FORTH_PUSH 
1fe3						DMARK "PQE" 
1fe3 f5				push af  
1fe4 3a f8 1f			ld a, (.dmark)  
1fe7 32 6e fe			ld (debug_mark),a  
1fea 3a f9 1f			ld a, (.dmark+1)  
1fed 32 6f fe			ld (debug_mark+1),a  
1ff0 3a fa 1f			ld a, (.dmark+2)  
1ff3 32 70 fe			ld (debug_mark+2),a  
1ff6 18 03			jr .pastdmark  
1ff8 ..			.dmark: db "PQE"  
1ffb f1			.pastdmark: pop af  
1ffc			endm  
# End of macro DMARK
1ffc				CALLMONITOR 
1ffc cd a5 18			call break_point_state  
1fff				endm  
# End of macro CALLMONITOR
1fff			endif	 
1fff			 
1fff 2b				dec hl    ; see if there is an optional trailing double quote 
2000 7e				ld a,(hl) 
2001 fe 22			cp '"' 
2003 20 03			jr nz, .strnoq 
2005 3e 00			ld a, 0      ; get rid of double quote 
2007 77				ld (hl), a 
2008 23			.strnoq: inc hl 
2009			 
2009 3e 00			ld a, 0 
200b 77				ld (hl), a     ; add null term and get rid of trailing double quote 
200c			 
200c 13				inc de ; add one for the type string 
200d 13				inc de ; add one for null term??? 
200e			 
200e				; tos is get string pointer again 
200e				; de contains space to allocate 
200e				 
200e d5				push de 
200f			 
200f eb				ex de, hl 
2010			 
2010				;push af 
2010			 
2010			if DEBUG_FORTH_PUSH 
2010						DMARK "PHm" 
2010 f5				push af  
2011 3a 25 20			ld a, (.dmark)  
2014 32 6e fe			ld (debug_mark),a  
2017 3a 26 20			ld a, (.dmark+1)  
201a 32 6f fe			ld (debug_mark+1),a  
201d 3a 27 20			ld a, (.dmark+2)  
2020 32 70 fe			ld (debug_mark+2),a  
2023 18 03			jr .pastdmark  
2025 ..			.dmark: db "PHm"  
2028 f1			.pastdmark: pop af  
2029			endm  
# End of macro DMARK
2029				CALLMONITOR 
2029 cd a5 18			call break_point_state  
202c				endm  
# End of macro CALLMONITOR
202c			endif	 
202c cd c5 13			call malloc	; on ret hl now contains allocated memory 
202f				if DEBUG_FORTH_MALLOC_GUARD 
202f cc 82 55				call z,malloc_error 
2032				endif 
2032			 
2032				 
2032 c1				pop bc    ; get length 
2033 d1				pop de   ;  get string start    
2034			 
2034				; hl has destination from malloc 
2034			 
2034 eb				ex de, hl    ; prep for ldir 
2035			 
2035 d5				push de   ; save malloc area for DSP later 
2036				;push hl   ; save malloc area for DSP later 
2036			 
2036			if DEBUG_FORTH_PUSH 
2036						DMARK "PHc" 
2036 f5				push af  
2037 3a 4b 20			ld a, (.dmark)  
203a 32 6e fe			ld (debug_mark),a  
203d 3a 4c 20			ld a, (.dmark+1)  
2040 32 6f fe			ld (debug_mark+1),a  
2043 3a 4d 20			ld a, (.dmark+2)  
2046 32 70 fe			ld (debug_mark+2),a  
2049 18 03			jr .pastdmark  
204b ..			.dmark: db "PHc"  
204e f1			.pastdmark: pop af  
204f			endm  
# End of macro DMARK
204f				CALLMONITOR 
204f cd a5 18			call break_point_state  
2052				endm  
# End of macro CALLMONITOR
2052			endif	 
2052			 
2052			 
2052 ed b0			ldir 
2054			 
2054			 
2054				; push malloc to data stack     macro?????  
2054			 
2054				FORTH_DSP_NEXT 
2054 cd a8 1e			call macro_forth_dsp_next 
2057				endm 
# End of macro FORTH_DSP_NEXT
2057			 
2057				; save value and type 
2057			 
2057 2a 2c fa			ld hl, (cli_data_sp) 
205a			 
205a				; save item type 
205a 3e 01			ld a,  DS_TYPE_STR 
205c 77				ld (hl), a 
205d 23				inc hl 
205e			 
205e				; get malloc word off stack 
205e d1				pop de 
205f 73				ld (hl), e 
2060 23				inc hl 
2061 72				ld (hl), d 
2062			 
2062			 
2062			 
2062			if DEBUG_FORTH_PUSH 
2062 2a 2c fa			ld hl, (cli_data_sp) 
2065						DMARK "PHS" 
2065 f5				push af  
2066 3a 7a 20			ld a, (.dmark)  
2069 32 6e fe			ld (debug_mark),a  
206c 3a 7b 20			ld a, (.dmark+1)  
206f 32 6f fe			ld (debug_mark+1),a  
2072 3a 7c 20			ld a, (.dmark+2)  
2075 32 70 fe			ld (debug_mark+2),a  
2078 18 03			jr .pastdmark  
207a ..			.dmark: db "PHS"  
207d f1			.pastdmark: pop af  
207e			endm  
# End of macro DMARK
207e				CALLMONITOR 
207e cd a5 18			call break_point_state  
2081				endm  
# End of macro CALLMONITOR
2081			;	ex de,hl 
2081			endif	 
2081				; in case of spaces, skip the ptr past the copied string 
2081				;pop af 
2081				;ld (cli_origptr),hl 
2081			 
2081 c9				ret 
2082			 
2082			 
2082			 
2082			; TODO ascii push input onto stack given hl to start of input 
2082			 
2082			; identify type 
2082			; if starts with a " then a string 
2082			; otherwise it is a number 
2082			;  
2082			; if a string 
2082			;     scan for ending " to get length of string to malloc for + 1 
2082			;     malloc 
2082			;     put pointer to string on stack first byte flags as string 
2082			; 
2082			; else a number 
2082			;    look for number format identifier 
2082			;    $xx hex 
2082			;    %xxxxx bin 
2082			;    xxxxx decimal 
2082			;    convert number to 16bit word.  
2082			;    malloc word + 1 with flag to identiy as num 
2082			;    put pointer to number on stack 
2082			;   
2082			;  
2082			  
2082			forth_apush: 
2082				; kernel push 
2082			 
2082			if DEBUG_FORTH_PUSH 
2082						DMARK "PSH" 
2082 f5				push af  
2083 3a 97 20			ld a, (.dmark)  
2086 32 6e fe			ld (debug_mark),a  
2089 3a 98 20			ld a, (.dmark+1)  
208c 32 6f fe			ld (debug_mark+1),a  
208f 3a 99 20			ld a, (.dmark+2)  
2092 32 70 fe			ld (debug_mark+2),a  
2095 18 03			jr .pastdmark  
2097 ..			.dmark: db "PSH"  
209a f1			.pastdmark: pop af  
209b			endm  
# End of macro DMARK
209b				CALLMONITOR 
209b cd a5 18			call break_point_state  
209e				endm  
# End of macro CALLMONITOR
209e			endif	 
209e				; identify input type 
209e			 
209e 7e				ld a,(hl) 
209f fe 22			cp '"' 
20a1 28 0a			jr z, .fapstr 
20a3 fe 24			cp '$' 
20a5 ca cd 20			jp z, .faphex 
20a8 fe 25			cp '%' 
20aa ca b5 20			jp z, .fapbin 
20ad			;	cp 'b' 
20ad			;	jp z, .fabin 
20ad				; else decimal 
20ad			 
20ad				; TODO do decimal conversion 
20ad				; decimal is stored as a 16bit word 
20ad			 
20ad				; by default everything is a string if type is not detected 
20ad			.fapstr: ; 
20ad fe 22			cp '"' 
20af 20 01			jr nz, .strnoqu 
20b1 23				inc hl 
20b2			.strnoqu: 
20b2 c3 87 1f			jp forth_push_str 
20b5			 
20b5			 
20b5			 
20b5			.fapbin:    ; push a binary string.  
20b5 11 00 00			ld de, 0   ; hold a 16bit value 
20b8			 
20b8 23			.fapbinshift:	inc hl  
20b9 7e				ld a,(hl) 
20ba fe 00			cp 0     ; done scanning  
20bc 28 0b			jr z, .fapbdone  	; got it in HL so push  
20be			 
20be				; left shift de 
20be eb				ex de, hl	 
20bf 29				add hl, hl 
20c0			 
20c0				; is 1 
20c0 fe 31			cp '1' 
20c2 20 02			jr nz, .binzero 
20c4 cb 4d			bit 1, l 
20c6			.binzero: 
20c6 eb				ex de, hl	 ; save current de 
20c7 18 ef			jr .fapbinshift 
20c9			 
20c9			.fapbdone: 
20c9 eb				ex de, hl 
20ca c3 19 1f			jp forth_push_numhl 
20cd			 
20cd			 
20cd			.faphex:   ; hex is always stored as a 16bit word 
20cd				; skip number prefix 
20cd 23				inc hl 
20ce				; turn ascii into number 
20ce cd b5 12			call get_word_hl	; ret 16bit word in hl 
20d1			 
20d1 c3 19 1f			jp forth_push_numhl 
20d4			 
20d4 00				 nop 
20d5			 
20d5			.fabin:   ; TODO bin conversion 
20d5			 
20d5			 
20d5 c9				ret 
20d6			 
20d6			 
20d6			; get either a string ptr or a 16bit word from the data stack 
20d6			 
20d6			FORTH_DSP: macro 
20d6				call macro_forth_dsp 
20d6				endm 
20d6			 
20d6			macro_forth_dsp: 
20d6				; data stack pointer points to current word on tos 
20d6			 
20d6 2a 2c fa			ld hl,(cli_data_sp) 
20d9			 
20d9				if DEBUG_FORTH_PUSH 
20d9						DMARK "DSP" 
20d9 f5				push af  
20da 3a ee 20			ld a, (.dmark)  
20dd 32 6e fe			ld (debug_mark),a  
20e0 3a ef 20			ld a, (.dmark+1)  
20e3 32 6f fe			ld (debug_mark+1),a  
20e6 3a f0 20			ld a, (.dmark+2)  
20e9 32 70 fe			ld (debug_mark+2),a  
20ec 18 03			jr .pastdmark  
20ee ..			.dmark: db "DSP"  
20f1 f1			.pastdmark: pop af  
20f2			endm  
# End of macro DMARK
20f2			 
20f2 cd b7 55				call display_data_sp 
20f5				;call break_point_state 
20f5				;rst 030h 
20f5				CALLMONITOR 
20f5 cd a5 18			call break_point_state  
20f8				endm  
# End of macro CALLMONITOR
20f8				endif 
20f8			 
20f8 c9				ret 
20f9			 
20f9			; return hl to start of value on stack 
20f9			 
20f9			FORTH_DSP_VALUE: macro 
20f9				call macro_forth_dsp_value 
20f9				endm 
20f9			 
20f9			macro_forth_dsp_value: 
20f9			 
20f9				FORTH_DSP 
20f9 cd d6 20			call macro_forth_dsp 
20fc				endm 
# End of macro FORTH_DSP
20fc			 
20fc d5				push de 
20fd			 
20fd 23				inc hl ; skip type 
20fe			 
20fe 5e				ld e, (hl) 
20ff 23				inc hl 
2100 56				ld d, (hl) 
2101 eb				ex de,hl  
2102			 
2102 d1				pop de 
2103			 
2103 c9				ret 
2104			 
2104			; return hl to start of value to second item on stack 
2104			 
2104			FORTH_DSP_VALUEM1: macro 
2104				call macro_forth_dsp_value_m1 
2104				endm 
2104			 
2104			macro_forth_dsp_value_m1: 
2104			 
2104				FORTH_DSP 
2104 cd d6 20			call macro_forth_dsp 
2107				endm 
# End of macro FORTH_DSP
2107			 
2107 2b				dec hl 
2108 2b				dec hl 
2109			;	dec hl 
2109			 
2109 d5				push de 
210a			 
210a 5e				ld e, (hl) 
210b 23				inc hl 
210c 56				ld d, (hl) 
210d eb				ex de,hl  
210e			 
210e d1				pop de 
210f			 
210f c9				ret 
2110			 
2110				 
2110			 
2110			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2110			 
2110			FORTH_DSP_POP: macro 
2110				call macro_forth_dsp_pop 
2110				endm 
2110			 
2110			 
2110			; get the tos data type 
2110			 
2110			FORTH_DSP_TYPE:   macro 
2110			 
2110				;FORTH_DSP_VALUE 
2110				FORTH_DSP 
2110				 
2110				; hl points to value 
2110				; check type 
2110			 
2110				ld a,(hl) 
2110			 
2110				endm 
2110			 
2110			; load the tos value into hl 
2110			 
2110			 
2110			FORTH_DSP_VALUEHL:  macro 
2110				call macro_dsp_valuehl 
2110				endm 
2110			 
2110			 
2110			 
2110			macro_dsp_valuehl: 
2110				FORTH_DSP_VALUE 
2110 cd f9 20			call macro_forth_dsp_value 
2113				endm 
# End of macro FORTH_DSP_VALUE
2113			 
2113				;FORTH_ERR_TOS_NOTNUM 
2113			 
2113				;inc hl   ; skip type id 
2113			 
2113			;	push de 
2113			; 
2113			;	ld e, (hl) 
2113			;	inc hl 
2113			;	ld d, (hl) 
2113			;	ex de,hl  
2113			 
2113			;	pop de 
2113			 
2113				if DEBUG_FORTH_PUSH 
2113						DMARK "DVL" 
2113 f5				push af  
2114 3a 28 21			ld a, (.dmark)  
2117 32 6e fe			ld (debug_mark),a  
211a 3a 29 21			ld a, (.dmark+1)  
211d 32 6f fe			ld (debug_mark+1),a  
2120 3a 2a 21			ld a, (.dmark+2)  
2123 32 70 fe			ld (debug_mark+2),a  
2126 18 03			jr .pastdmark  
2128 ..			.dmark: db "DVL"  
212b f1			.pastdmark: pop af  
212c			endm  
# End of macro DMARK
212c				CALLMONITOR 
212c cd a5 18			call break_point_state  
212f				endm  
# End of macro CALLMONITOR
212f				endif 
212f c9				ret 
2130			 
2130			forth_apushstrhl:      
2130				; push of string requires use of cli_origptr 
2130				; bodge use 
2130			 
2130				; get current cli_origptr, save, update with temp pointer  
2130 ed 5b 48 fa		ld de, (cli_origptr) 
2134 22 48 fa			ld (cli_origptr), hl 
2137 d5				push de 
2138 cd 82 20			call forth_apush 
213b d1				pop de 
213c ed 53 48 fa		ld (cli_origptr), de 
2140 c9			        ret	 
2141			 
2141			 
2141			; increase loop stack pointer and save hl to it 
2141				 
2141			FORTH_LOOP_NEXT: macro 
2141				call macro_forth_loop_next 
2141				;nop 
2141				endm 
2141			 
2141			macro_forth_loop_next: 
2141				if DEBUG_FORTH_STACK_GUARD 
2141 cd 94 66				call check_stacks 
2144				endif 
2144 e5				push hl 
2145 d5				push de 
2146 eb				ex de,hl 
2147 2a 2e fa			ld hl,(cli_loop_sp) 
214a 23				inc hl 
214b 23				inc hl 
214c					if DEBUG_FORTH_WORDS 
214c						DMARK "LNX" 
214c f5				push af  
214d 3a 61 21			ld a, (.dmark)  
2150 32 6e fe			ld (debug_mark),a  
2153 3a 62 21			ld a, (.dmark+1)  
2156 32 6f fe			ld (debug_mark+1),a  
2159 3a 63 21			ld a, (.dmark+2)  
215c 32 70 fe			ld (debug_mark+2),a  
215f 18 03			jr .pastdmark  
2161 ..			.dmark: db "LNX"  
2164 f1			.pastdmark: pop af  
2165			endm  
# End of macro DMARK
2165						CALLMONITOR 
2165 cd a5 18			call break_point_state  
2168				endm  
# End of macro CALLMONITOR
2168					endif 
2168 22 2e fa			ld (cli_loop_sp),hl 
216b 73				ld (hl), e 
216c 23				inc hl 
216d 72				ld (hl), d 
216e d1				pop de    ; been reversed so save a swap on restore 
216f e1				pop hl 
2170				if DEBUG_FORTH_STACK_GUARD 
2170 cd 94 66				call check_stacks 
2173				endif 
2173 c9				ret 
2174			 
2174			; get current ret stack pointer and save to hl  
2174				 
2174			FORTH_LOOP_TOS: macro 
2174				call macro_forth_loop_tos 
2174				endm 
2174			 
2174			macro_forth_loop_tos: 
2174 d5				push de 
2175 2a 2e fa			ld hl,(cli_loop_sp) 
2178 5e				ld e, (hl) 
2179 23				inc hl 
217a 56				ld d, (hl) 
217b eb				ex de, hl 
217c d1				pop de 
217d c9				ret 
217e			 
217e			; pop loop stack pointer 
217e				 
217e			FORTH_LOOP_POP: macro 
217e				call macro_forth_loop_pop 
217e				endm 
217e			 
217e			 
217e			macro_forth_loop_pop: 
217e				if DEBUG_FORTH_STACK_GUARD 
217e					DMARK "LPP" 
217e f5				push af  
217f 3a 93 21			ld a, (.dmark)  
2182 32 6e fe			ld (debug_mark),a  
2185 3a 94 21			ld a, (.dmark+1)  
2188 32 6f fe			ld (debug_mark+1),a  
218b 3a 95 21			ld a, (.dmark+2)  
218e 32 70 fe			ld (debug_mark+2),a  
2191 18 03			jr .pastdmark  
2193 ..			.dmark: db "LPP"  
2196 f1			.pastdmark: pop af  
2197			endm  
# End of macro DMARK
2197 cd 94 66				call check_stacks 
219a					FORTH_CHK_LOOP_UNDER 
219a e5				push hl 
219b d5				push de 
219c 2a 2e fa			ld hl,(cli_loop_sp) 
219f 11 68 f9			ld de, cli_loop_stack 
21a2 cd 1c 0f			call cmp16 
21a5 da ae 67			jp c, fault_loop_under 
21a8 d1				pop de 
21a9 e1				pop hl 
21aa				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21aa				endif 
21aa e5				push hl 
21ab 2a 2e fa			ld hl,(cli_loop_sp) 
21ae 2b				dec hl 
21af 2b				dec hl 
21b0 22 2e fa			ld (cli_loop_sp), hl 
21b3				; TODO do stack underflow checks 
21b3 e1				pop hl 
21b4				if DEBUG_FORTH_STACK_GUARD 
21b4 cd 94 66				call check_stacks 
21b7					FORTH_CHK_LOOP_UNDER 
21b7 e5				push hl 
21b8 d5				push de 
21b9 2a 2e fa			ld hl,(cli_loop_sp) 
21bc 11 68 f9			ld de, cli_loop_stack 
21bf cd 1c 0f			call cmp16 
21c2 da ae 67			jp c, fault_loop_under 
21c5 d1				pop de 
21c6 e1				pop hl 
21c7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21c7				endif 
21c7 c9				ret 
21c8			 
21c8			macro_forth_dsp_pop: 
21c8			 
21c8 e5				push hl 
21c9			 
21c9				; release malloc data 
21c9			 
21c9				if DEBUG_FORTH_STACK_GUARD 
21c9 cd 94 66				call check_stacks 
21cc					FORTH_CHK_DSP_UNDER 
21cc e5				push hl 
21cd d5				push de 
21ce 2a 2c fa			ld hl,(cli_data_sp) 
21d1 11 66 f7			ld de, cli_data_stack 
21d4 cd 1c 0f			call cmp16 
21d7 da a2 67			jp c, fault_dsp_under 
21da d1				pop de 
21db e1				pop hl 
21dc				endm 
# End of macro FORTH_CHK_DSP_UNDER
21dc				endif 
21dc				;ld hl,(cli_data_sp) 
21dc			if DEBUG_FORTH_DOT 
21dc				DMARK "DPP" 
21dc				CALLMONITOR 
21dc			endif	 
21dc			 
21dc			 
21dc			if FORTH_ENABLE_DSPPOPFREE 
21dc			 
21dc				FORTH_DSP 
21dc cd d6 20			call macro_forth_dsp 
21df				endm 
# End of macro FORTH_DSP
21df			 
21df 7e				ld a, (hl) 
21e0 fe 01			cp DS_TYPE_STR 
21e2 20 07			jr nz, .skippopfree 
21e4			 
21e4				FORTH_DSP_VALUEHL 
21e4 cd 10 21			call macro_dsp_valuehl 
21e7				endm 
# End of macro FORTH_DSP_VALUEHL
21e7 00				nop 
21e8			if DEBUG_FORTH_DOT 
21e8				DMARK "DPf" 
21e8				CALLMONITOR 
21e8			endif	 
21e8 cd 8f 14			call free 
21eb			.skippopfree: 
21eb				 
21eb			 
21eb			endif 
21eb			 
21eb			if DEBUG_FORTH_DOT_KEY 
21eb				DMARK "DP2" 
21eb				CALLMONITOR 
21eb			endif	 
21eb			 
21eb				; move pointer down 
21eb			 
21eb 2a 2c fa			ld hl,(cli_data_sp) 
21ee 2b				dec hl 
21ef 2b				dec hl 
21f0			; PARSEV5 
21f0 2b				dec hl 
21f1 22 2c fa			ld (cli_data_sp), hl 
21f4			 
21f4				if DEBUG_FORTH_STACK_GUARD 
21f4 cd 94 66				call check_stacks 
21f7					FORTH_CHK_DSP_UNDER 
21f7 e5				push hl 
21f8 d5				push de 
21f9 2a 2c fa			ld hl,(cli_data_sp) 
21fc 11 66 f7			ld de, cli_data_stack 
21ff cd 1c 0f			call cmp16 
2202 da a2 67			jp c, fault_dsp_under 
2205 d1				pop de 
2206 e1				pop hl 
2207				endm 
# End of macro FORTH_CHK_DSP_UNDER
2207				endif 
2207			 
2207 e1				pop hl 
2208			 
2208 c9				ret 
2209			 
2209			getwordathl: 
2209				; hl points to an address 
2209				; load hl with the word at that address 
2209			 
2209 d5				push de 
220a			 
220a 5e				ld e, (hl) 
220b 23				inc hl 
220c 56				ld d, (hl) 
220d eb				ex de, hl 
220e			 
220e d1				pop de 
220f c9				ret 
2210			 
2210			 
2210			 
2210			 
2210			 
2210			; eof 
2210			 
# End of file forth_stackopsv5.asm
2210			endif 
2210			 
2210			user_word_eol:  
2210				; hl contains the pointer to where to create a linked list item from the end 
2210				; of the user dict to continue on at the system word dict 
2210				 
2210				; poke the stub of the word list linked list to repoint to rom words 
2210			 
2210				; stub format 
2210				; db   word id 
2210				; dw    link to next word 
2210			        ; db char length of token 
2210				; db string + 0 term 
2210				; db exec code....  
2210			 
2210 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2212 77				ld (hl), a		; word id 
2213 23				inc hl 
2214			 
2214 11 df 23			ld de, sysdict 
2217 73				ld (hl), e		; next word link ie system dict 
2218 23				inc hl 
2219 72				ld (hl), d		; next word link ie system dict 
221a 23				inc hl	 
221b			 
221b			;	ld (hl), sysdict		; next word link ie system dict 
221b			;	inc hl 
221b			;	inc hl 
221b			 
221b			;	inc hl 
221b			;	inc hl 
221b			 
221b 3e 02			ld a, 2			; word length is 0 
221d 77				ld (hl), a	 
221e 23				inc hl 
221f			 
221f 3e 7e			ld a, '~'			; word length is 0 
2221 77				ld (hl), a	 
2222 23				inc hl 
2223 3e 00			ld a, 0			; save empty word 
2225 77				ld (hl), a 
2226			 
2226 c9				ret 
2227			 
2227				 
2227			 
2227			forthexec_cleanup: 
2227				FORTH_RSP_POP 
2227 cd e1 1e			call macro_forth_rsp_pop 
222a				endm 
# End of macro FORTH_RSP_POP
222a c9				ret 
222b			 
222b			forth_call_hl: 
222b				; taking hl 
222b e5				push hl 
222c c9				ret 
222d			 
222d			; this is called to reset Forth system but keep existing uwords etc 
222d			 
222d			forth_warmstart: 
222d				; setup stack over/under flow checks 
222d				if DEBUG_FORTH_STACK_GUARD 
222d cd 7a 66				call chk_stk_init 
2230				endif 
2230			 
2230				; init stack pointers  - * these stacks go upwards *  
2230 21 ea f9			ld hl, cli_ret_stack 
2233 22 30 fa			ld (cli_ret_sp), hl	 
2236				; set bottom of stack 
2236 3e 00			ld a,0 
2238 77				ld (hl),a 
2239 23				inc hl 
223a 77				ld (hl),a 
223b			 
223b 21 66 f7			ld hl, cli_data_stack 
223e 22 2c fa			ld (cli_data_sp), hl	 
2241				; set bottom of stack 
2241 3e 00			ld a,0 
2243 77				ld (hl),a 
2244 23				inc hl 
2245 77				ld (hl),a 
2246			 
2246 21 68 f9			ld hl, cli_loop_stack 
2249 22 2e fa			ld (cli_loop_sp), hl	 
224c				; set bottom of stack 
224c 3e 00			ld a,0 
224e 77				ld (hl),a 
224f 23				inc hl 
2250 77				ld (hl),a 
2251			 
2251				; init extent of current open file 
2251			 
2251 3e 00			ld a, 0 
2253 32 73 fa			ld (store_openext), a 
2256			 
2256 c9				ret 
2257			 
2257			 
2257			; Cold Start - this is called to setup the whole Forth system 
2257			 
2257			forth_init: 
2257			 
2257				; setup stack over/under flow checks 
2257			 
2257			;	if DEBUG_FORTH_STACK_GUARD 
2257			;		call chk_stk_init 
2257			;	endif 
2257			 
2257				; enable auto display updates (slow.....) 
2257			 
2257 3e 01			ld a, 1 
2259 32 46 fa			ld (cli_autodisplay), a 
225c			 
225c				; if storage is in use disable long reads for now 
225c 3e 00			ld a, 0 
225e 32 7c fa			ld (store_longread), a 
2261			 
2261			 
2261				; show start up screen 
2261			 
2261 cd ca 0c			call clear_display 
2264			 
2264 3e 00			ld a,0 
2266 32 68 fa			ld (f_cursor_ptr), a 
2269			 
2269				; set start of word list in start of ram - for use when creating user words 
2269			 
2269 21 00 80			ld hl, baseram 
226c 22 fc f4			ld (os_last_new_uword), hl 
226f cd 10 22			call user_word_eol 
2272				 
2272			;		call display_data_sp 
2272			;		call next_page_prompt 
2272			 
2272			 
2272			 
2272			 
2272 c9				ret 
2273			 
2273 .. 00		.bootforth: db " Forth Kernel Init ",0 
2287			 
2287			; TODO push to stack 
2287			 
2287			;  
2287			 
2287			if FORTH_PARSEV2 
2287			 
2287			 
2287				include "forth_parserv2.asm" 
2287			 
2287			endif 
2287			 
2287			 
2287			; parse cli version 1 
2287			 
2287			if FORTH_PARSEV1 
2287			 
2287			 
2287			 
2287			      include "forth_parserv1.asm" 
2287			endif 
2287				 
2287			if FORTH_PARSEV3 
2287			 
2287			 
2287			 
2287			      include "forth_parserv3.asm" 
2287				include "forth_wordsv3.asm" 
2287			endif 
2287			 
2287			if FORTH_PARSEV4 
2287			 
2287			 
2287			 
2287			      include "forth_parserv4.asm" 
2287				include "forth_wordsv4.asm" 
2287			endif 
2287			 
2287			if FORTH_PARSEV5 
2287			 
2287			 
2287			 
2287			      include "forth_parserv5.asm" 
2287			 
2287			 
2287			; A better parser without using malloc and string copies all over the place.  
2287			; Exec in situ should be faster 
2287			 
2287			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2287			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2287			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2287			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2287			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2287			WORD_SYS_END: equ 0   ; Opcode for all user words 
2287			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2287			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2287			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2287			 
2287			; Core word preamble macro 
2287			 
2287			CWHEAD:   macro nxtword opcode lit len opflags 
2287				db WORD_SYS_CORE+opcode             
2287				; internal op code number 
2287				dw nxtword            
2287				; link to next dict word block 
2287				db len + 1 
2287				; literal length of dict word inc zero term 
2287				db lit,0              
2287				; literal dict word 
2287			        ; TODO db opflags        
2287				endm 
2287			 
2287			 
2287			NEXTW: macro  
2287				jp macro_next 
2287				endm 
2287			 
2287			macro_next: 
2287			if DEBUG_FORTH_PARSE_KEY 
2287				DMARK "NXT" 
2287				CALLMONITOR 
2287			endif	 
2287			;	inc hl  ; skip token null term  
2287 ed 4b 4a fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
228b ed 5b 48 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
228f 2a 00 f5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2292			if DEBUG_FORTH_PARSE_KEY 
2292				DMARK "}AA" 
2292				CALLMONITOR 
2292			endif	 
2292 c3 95 23			jp execnext 
2295				;jp exec1 
2295			       
2295			 
2295			 
2295			; Another go at the parser to compile  
2295			 
2295			 
2295			; TODO rework parser to change all of the string words to byte tokens 
2295			; TODO do a search for  
2295			 
2295			; TODO first run normal parser to zero term sections 
2295			; TODO for each word do a token look up to get the op code 
2295			; TODO need some means to flag to the exec that this is a byte code form    
2295			 
2295			 
2295			forthcompile: 
2295			 
2295			; 
2295			; line parse: 
2295			;       parse raw input buffer 
2295			;       tokenise the words 
2295			;       malloc new copy (for looping etc) 
2295			;       copy to malloc + current pc in line to start of string and add line term 
2295			;       save on new rsp 
2295			; 
2295			 
2295			; hl to point to the line to tokenise 
2295			 
2295			;	push hl 
2295 22 00 f5			ld (os_tok_ptr), hl  ; save ptr to string 
2298			 
2298			;	ld a,0		; string term on input 
2298			;	call strlent 
2298			 
2298			;	ld (os_tok_len), hl	 ; save string length 
2298			 
2298			;if DEBUG_FORTH_TOK 
2298			;	ex de,hl		 
2298			;endif 
2298			 
2298			;	pop hl 		; get back string pointer 
2298			 
2298			if DEBUG_FORTH_TOK 
2298						DMARK "TOc" 
2298				CALLMONITOR 
2298			endif 
2298 7e			.cptoken2:    ld a,(hl) 
2299 23				inc hl 
229a fe 7f			cp FORTH_END_BUFFER 
229c 28 29			jr z, .cptokendone2 
229e fe 00			cp 0 
22a0 28 25			jr z, .cptokendone2 
22a2 fe 22			cp '"' 
22a4 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
22a6 fe 20			cp ' ' 
22a8 20 ee			jr nz,  .cptoken2 
22aa			 
22aa			; TODO consume comments held between ( and ) 
22aa			 
22aa				; we have a space so change to zero term for dict match later 
22aa 2b				dec hl 
22ab 3e 00			ld a,0 
22ad 77				ld (hl), a 
22ae 23				inc hl 
22af 18 e7			jr .cptoken2 
22b1				 
22b1			 
22b1			.cptokenstr2: 
22b1				; skip all white space until either eol (because forgot to term) or end double quote 
22b1			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
22b1				;inc hl ; skip current double quote 
22b1 7e				ld a,(hl) 
22b2 23				inc hl 
22b3 fe 22			cp '"' 
22b5 28 e1			jr z, .cptoken2 
22b7 fe 7f			cp FORTH_END_BUFFER 
22b9 28 0c			jr z, .cptokendone2 
22bb fe 00			cp 0 
22bd 28 08			jr z, .cptokendone2 
22bf fe 20			cp ' ' 
22c1 28 02			jr z, .cptmp2 
22c3 18 ec			jr .cptokenstr2 
22c5			 
22c5			.cptmp2:	; we have a space so change to zero term for dict match later 
22c5				;dec hl 
22c5				;ld a,"-"	; TODO remove this when working 
22c5				;ld (hl), a 
22c5				;inc hl 
22c5 18 ea			jr .cptokenstr2 
22c7			 
22c7			.cptokendone2: 
22c7				;inc hl 
22c7 3e 7f			ld a, FORTH_END_BUFFER 
22c9 77				ld (hl),a 
22ca 23				inc hl 
22cb 3e 21			ld a, '!' 
22cd 77				ld (hl),a 
22ce			 
22ce 2a 00 f5			ld hl,(os_tok_ptr) 
22d1			         
22d1			if DEBUG_FORTH_TOK 
22d1						DMARK "Tc1" 
22d1				CALLMONITOR 
22d1			endif 
22d1			 
22d1				; push exec string to top of return stack 
22d1				FORTH_RSP_NEXT 
22d1 cd c0 1e			call macro_forth_rsp_next 
22d4				endm 
# End of macro FORTH_RSP_NEXT
22d4 c9				ret 
22d5			 
22d5			; Another go at the parser need to simplify the process 
22d5			 
22d5			forthparse: 
22d5			 
22d5			; 
22d5			; line parse: 
22d5			;       parse raw input buffer 
22d5			;       tokenise the words 
22d5			;       malloc new copy (for looping etc) 
22d5			;       copy to malloc + current pc in line to start of string and add line term 
22d5			;       save on new rsp 
22d5			; 
22d5			 
22d5			; hl to point to the line to tokenise 
22d5			 
22d5			;	push hl 
22d5 22 00 f5			ld (os_tok_ptr), hl  ; save ptr to string 
22d8			 
22d8			;	ld a,0		; string term on input 
22d8			;	call strlent 
22d8			 
22d8			;	ld (os_tok_len), hl	 ; save string length 
22d8			 
22d8			;if DEBUG_FORTH_TOK 
22d8			;	ex de,hl		 
22d8			;endif 
22d8			 
22d8			;	pop hl 		; get back string pointer 
22d8			 
22d8			if DEBUG_FORTH_TOK 
22d8						DMARK "TOK" 
22d8				CALLMONITOR 
22d8			endif 
22d8 7e			.ptoken2:    ld a,(hl) 
22d9 23				inc hl 
22da fe 7f			cp FORTH_END_BUFFER 
22dc 28 29			jr z, .ptokendone2 
22de fe 00			cp 0 
22e0 28 25			jr z, .ptokendone2 
22e2 fe 22			cp '"' 
22e4 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
22e6 fe 20			cp ' ' 
22e8 20 ee			jr nz,  .ptoken2 
22ea			 
22ea			; TODO consume comments held between ( and ) 
22ea			 
22ea				; we have a space so change to zero term for dict match later 
22ea 2b				dec hl 
22eb 3e 00			ld a,0 
22ed 77				ld (hl), a 
22ee 23				inc hl 
22ef 18 e7			jr .ptoken2 
22f1				 
22f1			 
22f1			.ptokenstr2: 
22f1				; skip all white space until either eol (because forgot to term) or end double quote 
22f1			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
22f1				;inc hl ; skip current double quote 
22f1 7e				ld a,(hl) 
22f2 23				inc hl 
22f3 fe 22			cp '"' 
22f5 28 e1			jr z, .ptoken2 
22f7 fe 7f			cp FORTH_END_BUFFER 
22f9 28 0c			jr z, .ptokendone2 
22fb fe 00			cp 0 
22fd 28 08			jr z, .ptokendone2 
22ff fe 20			cp ' ' 
2301 28 02			jr z, .ptmp2 
2303 18 ec			jr .ptokenstr2 
2305			 
2305			.ptmp2:	; we have a space so change to zero term for dict match later 
2305				;dec hl 
2305				;ld a,"-"	; TODO remove this when working 
2305				;ld (hl), a 
2305				;inc hl 
2305 18 ea			jr .ptokenstr2 
2307			 
2307			.ptokendone2: 
2307				;inc hl 
2307 3e 7f			ld a, FORTH_END_BUFFER 
2309 77				ld (hl),a 
230a 23				inc hl 
230b 3e 21			ld a, '!' 
230d 77				ld (hl),a 
230e			 
230e 2a 00 f5			ld hl,(os_tok_ptr) 
2311			         
2311			if DEBUG_FORTH_TOK 
2311						DMARK "TK1" 
2311				CALLMONITOR 
2311			endif 
2311			 
2311				; push exec string to top of return stack 
2311				FORTH_RSP_NEXT 
2311 cd c0 1e			call macro_forth_rsp_next 
2314				endm 
# End of macro FORTH_RSP_NEXT
2314 c9				ret 
2315			 
2315			; 
2315			;	; malloc size + buffer pointer + if is loop flag 
2315			;	ld hl,(os_tok_len) 		 ; get string length 
2315			; 
2315			;	ld a,l 
2315			; 
2315			;	cp 0			; we dont want to use a null string 
2315			;	ret z 
2315			; 
2315			;;	add 3    ; prefix malloc with buffer for current word ptr 
2315			; 
2315			;	add 5     ; TODO when certain not over writing memory remove 
2315			; 
2315			;		 
2315			; 
2315			;if DEBUG_FORTH_TOK 
2315			;			DMARK "TKE" 
2315			;	CALLMONITOR 
2315			;endif 
2315			; 
2315			;	ld l,a 
2315			;	ld h,0 
2315			;;	push hl   ; save required space for the copy later 
2315			;	call malloc 
2315			;if DEBUG_FORTH_TOK 
2315			;			DMARK "TKM" 
2315			;	CALLMONITOR 
2315			;endif 
2315			;	if DEBUG_FORTH_MALLOC_GUARD 
2315			;		push af 
2315			;		call ishlzero 
2315			;;		ld a, l 
2315			;;		add h 
2315			;;		cp 0 
2315			;		pop af 
2315			;		 
2315			;		call z,malloc_error 
2315			;	endif 
2315			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2315			; 
2315			; 
2315			;if DEBUG_FORTH_TOK 
2315			;			DMARK "TKR" 
2315			;	CALLMONITOR 
2315			;endif 
2315			; 
2315			;	FORTH_RSP_NEXT 
2315			; 
2315			;	;inc hl	 ; go past current buffer pointer 
2315			;	;inc hl 
2315			;	;inc hl   ; and past if loop flag 
2315			;		; TODO Need to set flag  
2315			; 
2315			;	 
2315			;	 
2315			;	ex de,hl	; malloc is dest 
2315			;	ld hl, (os_tok_len) 
2315			;;	pop bc 
2315			;	ld c, l                
2315			;	ld b,0 
2315			;	ld hl, (os_tok_ptr) 
2315			; 
2315			;if DEBUG_FORTH_TOK 
2315			;			DMARK "TKT" 
2315			;	CALLMONITOR 
2315			;endif 
2315			; 
2315			;	; do str cpy 
2315			; 
2315			;	ldir      ; copy byte in hl to de 
2315			; 
2315			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2315			; 
2315			;if DEBUG_FORTH_TOK 
2315			; 
2315			;			DMARK "TKY" 
2315			;	CALLMONITOR 
2315			;endif 
2315			;	;ld a,0 
2315			;	;ld a,FORTH_END_BUFFER 
2315			;	ex de, hl 
2315			;	;dec hl			 ; go back over the space delim at the end of word 
2315			;	;ld (hl),a 
2315			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2315			;	ld a,FORTH_END_BUFFER 
2315			;	ld (hl),a 
2315			;	inc hl 
2315			;	ld a,FORTH_END_BUFFER 
2315			;	ld (hl),a 
2315			; 
2315			;	; init the malloc area data 
2315			;	; set pc for in current area 
2315			;	;ld hl, (os_tok_malloc) 
2315			;	;inc hl 
2315			;	;inc hl 
2315			;	;inc hl 
2315			;	;ex de,hl 
2315			;	;ld hl, (os_tok_malloc) 
2315			;	;ld (hl),e 
2315			;	;inc hl 
2315			;	;ld (hl),d 
2315			; 
2315			; 
2315			;	ld hl,(os_tok_malloc) 
2315			;if DEBUG_FORTH_PARSE_KEY 
2315			;			DMARK "TKU" 
2315			;	CALLMONITOR 
2315			;endif 
2315			; 
2315			;	ret 
2315			 
2315			forthexec: 
2315			 
2315			; line exec: 
2315			; forth parser 
2315			 
2315			; 
2315			;       get current exec line on rsp 
2315			 
2315				FORTH_RSP_TOS 
2315 cd d7 1e			call macro_forth_rsp_tos 
2318				endm 
# End of macro FORTH_RSP_TOS
2318			 
2318			;       restore current pc - hl points to malloc of data 
2318			 
2318				;ld e, (hl) 
2318				;inc hl 
2318				;ld d, (hl) 
2318				;ex de,hl 
2318			 
2318			 
2318			exec1: 
2318 22 00 f5			ld (os_tok_ptr), hl 
231b			 
231b				; copy our PC to working vars  
231b 22 4a fa			ld (cli_ptr), hl 
231e 22 48 fa			ld (cli_origptr), hl 
2321			 
2321 7e				ld a,(hl) 
2322 fe 7f			cp FORTH_END_BUFFER 
2324 c8				ret z 
2325			 
2325				; skip any nulls 
2325			 
2325 fe 00			cp 0 
2327 20 03			jr nz, .execword 
2329 23				inc hl 
232a 18 ec			jr exec1 
232c			 
232c			 
232c			.execword: 
232c			 
232c			 
232c			 
232c			if DEBUG_FORTH_PARSE_KEY 
232c						DMARK "KYQ" 
232c				CALLMONITOR 
232c			endif 
232c			;       while at start of word: 
232c			; get start of dict (in user area first) 
232c			 
232c 21 00 80		ld hl, baseram 
232f			;ld hl, sysdict 
232f 22 4c fa		ld (cli_nextword),hl 
2332			;           match word at pc 
2332			;           exec word 
2332			;           or push to dsp 
2332			;           forward to next token 
2332			;           if line term pop rsp and exit 
2332			;        
2332			 
2332			if DEBUG_FORTH_PARSE_KEY 
2332						DMARK "KYq" 
2332				CALLMONITOR 
2332			endif 
2332			 
2332			; 
2332			; word comp 
2332			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2332			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2332			;    move to start of word  
2332			;    compare word to cli_token 
2332			 
2332			.execpnword:	; HL at start of a word in the dictionary to check 
2332			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2332			;	ld (cli_ptr), hl 
2332			 
2332 2a 4c fa			ld hl,(cli_nextword) 
2335			 
2335 cd d8 23			call forth_tok_next 
2338			; tok next start here 
2338			;	; TODO skip compiled symbol for now 
2338			;	inc hl 
2338			; 
2338			;	; save pointer to next word 
2338			; 
2338			;	; hl now points to the address of the next word pointer  
2338			;	ld e, (hl) 
2338			;	inc hl 
2338			;	ld d, (hl) 
2338			;	inc l 
2338			; 
2338			;	ex de,hl 
2338			;if DEBUG_FORTH_PARSE_NEXTWORD 
2338			;	push bc 
2338			;	ld bc, (cli_nextword) 
2338			;			DMARK "NXW" 
2338			;	CALLMONITOR 
2338			;	pop bc 
2338			;endif 
2338			; tok next end here 
2338 22 4c fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
233b eb				ex de, hl 
233c			 
233c			 
233c				; save the pointer of the current token - 1 to check against 
233c				 
233c 22 50 fa			ld (cli_token), hl   
233f				; TODO maybe remove below save if no debug 
233f				; save token string ptr for any debug later 
233f 23				inc hl  
2340 22 52 fa			ld (cli_origtoken), hl 
2343 2b				dec hl 
2344				; save pointer to the start of the next dictionay word 
2344 7e				ld a,(hl)   ; get string length 
2345 47				ld b,a 
2346			.execpnwordinc:  
2346 23				inc hl 
2347 10 fd			djnz .execpnwordinc 
2349 22 4e fa			ld (cli_execword), hl      ; save start of this words code 
234c			 
234c				; now check the word token against the string being parsed 
234c			 
234c 2a 50 fa			ld hl,(cli_token) 
234f 23				inc hl     ; skip string length (use zero term instead to end) 
2350 22 50 fa			ld (cli_token), hl 
2353			 
2353			if DEBUG_FORTH_PARSE_KEY 
2353						DMARK "KY2" 
2353			endif 
2353			if DEBUG_FORTH_PARSE_EXEC 
2353				; see if disabled 
2353			 
2353				ld a, (os_view_disable) 
2353				cp '*' 
2353				jr z, .skip 
2353			 
2353				push hl 
2353				push hl 
2353				call clear_display 
2353				ld de, .compword 
2353				ld a, display_row_1 
2353				call str_at_display 
2353				pop de 
2353				ld a, display_row_2 
2353				call str_at_display 
2353				ld hl,(cli_ptr) 
2353				ld a,(hl) 
2353			        ld hl, os_word_scratch 
2353				ld (hl),a 
2353				ld a,0 
2353				inc hl 
2353				ld (hl),a 	 
2353				ld de, os_word_scratch 
2353				ld a, display_row_2+10 
2353				call str_at_display 
2353				call update_display 
2353				ld a, 100 
2353				call aDelayInMS 
2353				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2353				call delay250ms 
2353				endif 
2353				pop hl 
2353			.skip:  
2353			endif	 
2353			.execpnchar:    ; compare char between token and string to parse 
2353			 
2353			if DEBUG_FORTH_PARSE_KEY 
2353						DMARK "Ky3" 
2353			endif 
2353			if DEBUG_FORTH_PARSE_EXEC 
2353				; see if disabled 
2353			 
2353				ld a, (os_view_disable) 
2353				cp '*' 
2353				jr z, .skip2 
2353			 
2353			;	call clear_display 
2353			ld hl,(cli_token) 
2353			ld a,(hl) 
2353			ld (os_word_scratch),a 
2353				ld hl,(cli_ptr) 
2353			ld a,(hl) 
2353				ld (os_word_scratch+1),a 
2353				ld a,0 
2353				ld (os_word_scratch+2),a 
2353				ld de,os_word_scratch 
2353				ld a,display_row_4 
2353				call str_at_display 
2353				call update_display 
2353			.skip2:  
2353			endif 
2353 2a 50 fa			ld hl,(cli_token) 
2356 7e				ld a, (hl)	 ; char in word token 
2357 23				inc hl 		; move to next char 
2358 22 50 fa			ld (cli_token), hl ; and save it 
235b 47				ld b,a 
235c			 
235c 2a 4a fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
235f 7e				ld a,(hl) 
2360 23				inc hl 
2361 22 4a fa			ld (cli_ptr), hl		; move to next char 
2364 cd 53 13			call toUpper 		; make sure the input string matches case 
2367			 
2367			if DEBUG_FORTH_PARSE 
2367			endif 
2367			 
2367				; input stream end of token is a space so get rid of it 
2367			 
2367			;	cp ' ' 
2367			;	jr nz, .pnskipspace 
2367			; 
2367			;	ld a, 0		; make same term as word token term 
2367			; 
2367			;.pnskipspace: 
2367			 
2367			if DEBUG_FORTH_PARSE_KEY 
2367						DMARK "KY7" 
2367			endif 
2367 b8				cp b 
2368 c2 7e 23			jp nz, .execpnskipword	 ; no match so move to next word 
236b				 
236b			;    if same 
236b			;       scan for string terms 0 for token and 32 for input 
236b			 
236b				 
236b			if DEBUG_FORTH_PARSE_KEY 
236b						DMARK "KY8" 
236b			endif 
236b			 
236b 80				add b			 
236c fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
236e							; TODO need to make sure last word in zero term string is accounted for 
236e 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2370			 
2370			 
2370				; at end of both strings so both are exact match 
2370			 
2370			;       skip ptr for next word 
2370			 
2370 2a 4a fa			ld hl,(cli_ptr) 	; at input string term 
2373 23				inc hl			 ; at next char 
2374 22 4a fa			ld (cli_ptr), hl     ; save for next round of the parser 
2377 22 48 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
237a				 
237a				 
237a			if DEBUG_FORTH_PARSE_KEY 
237a						DMARK "KY3" 
237a			endif 
237a			 
237a			 
237a			 
237a			;       exec code block 
237a			if DEBUG_FORTH_JP 
237a				call clear_display 
237a				call update_display 
237a				call delay1s 
237a				ld hl, (cli_execword)     ; save for next check if no match on this word 
237a				ld a,h 
237a				ld hl, os_word_scratch 
237a				call hexout 
237a				ld hl, (cli_execword)     ; save for next check if no match on this word 
237a				ld a,l 
237a				ld hl, os_word_scratch+2 
237a				call hexout 
237a				ld hl, os_word_scratch+4 
237a				ld a,0 
237a				ld (hl),a 
237a				ld de,os_word_scratch 
237a				call str_at_display 
237a					ld a, display_row_2 
237a					call str_at_display 
237a				ld de, (cli_origtoken) 
237a				ld a, display_row_1+10 
237a					call str_at_display 
237a			 
237a				ld a,display_row_1 
237a				ld de, .foundword 
237a				ld a, display_row_3 
237a				call str_at_display 
237a				call update_display 
237a				call delay1s 
237a				call delay1s 
237a				call delay1s 
237a			endif 
237a			 
237a			if DEBUG_FORTH_PARSE_KEY 
237a						DMARK "KYj" 
237a			endif 
237a				; TODO save the word pointer in this exec 
237a			 
237a 2a 4e fa			ld hl,(cli_execword) 
237d e9				jp (hl) 
237e			 
237e			 
237e			;    if not same 
237e			;	scan for zero term 
237e			;	get ptr for next word 
237e			;	goto word comp 
237e			 
237e			.execpnskipword:	; get pointer to next word 
237e 2a 4c fa			ld hl,(cli_nextword) 
2381			 
2381 7e				ld a,(hl) 
2382 fe 00			cp WORD_SYS_END 
2384			;	cp 0 
2384 28 09			jr z, .execendofdict			 ; at end of words 
2386			 
2386			if DEBUG_FORTH_PARSE_KEY 
2386						DMARK "KY4" 
2386			endif 
2386			if DEBUG_FORTH_PARSE_EXEC 
2386			 
2386				; see if disabled 
2386			 
2386				ld a, (os_view_disable) 
2386				cp '*' 
2386				jr z, .noskip 
2386			 
2386			 
2386				ld de, .nowordfound 
2386				ld a, display_row_3 
2386				call str_at_display 
2386				call update_display 
2386				ld a, 100 
2386				call aDelayInMS 
2386				 
2386				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2386					call delay250ms 
2386				endif 
2386			.noskip:  
2386			 
2386			endif	 
2386			 
2386 2a 48 fa			ld hl,(cli_origptr) 
2389 22 4a fa			ld (cli_ptr),hl 
238c			 
238c			if DEBUG_FORTH_PARSE_KEY 
238c						DMARK "KY5" 
238c			endif 
238c c3 32 23			jp .execpnword			; else go to next word 
238f			 
238f			.execendofdict:  
238f			 
238f			if DEBUG_FORTH_PARSE_KEY 
238f						DMARK "KYe" 
238f			endif 
238f			if DEBUG_FORTH_PARSE_EXEC 
238f				; see if disabled 
238f			 
238f				ld a, (os_view_disable) 
238f				cp '*' 
238f				jr z, .ispskip 
238f			 
238f				call clear_display 
238f				call update_display 
238f				call delay1s 
238f				ld de, (cli_origptr) 
238f				ld a, display_row_1 
238f				call str_at_display 
238f				 
238f				ld de, .enddict 
238f				ld a, display_row_3 
238f				call str_at_display 
238f				call update_display 
238f				ld a, 100 
238f				call aDelayInMS 
238f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
238f				call delay1s 
238f				call delay1s 
238f				call delay1s 
238f				endif 
238f			.ispskip:  
238f				 
238f			endif	 
238f			 
238f			 
238f			 
238f				; if the word is not a keyword then must be a literal so push it to stack 
238f			 
238f			; push token to stack to end of word 
238f			 
238f				STACKFRAME ON $1efe $2f9f 
238f				if DEBUG_STACK_IMB 
238f					if ON 
238f						exx 
238f						ld de, $1efe 
238f						ld a, d 
238f						ld hl, curframe 
238f						call hexout 
238f						ld a, e 
238f						ld hl, curframe+2 
238f						call hexout 
238f						ld hl, $1efe 
238f						push hl 
238f						ld hl, $2f9f 
238f						push hl 
238f						exx 
238f					endif 
238f				endif 
238f			endm 
# End of macro STACKFRAME
238f			 
238f 2a 00 f5		ld hl,(os_tok_ptr) 
2392 cd 82 20		call forth_apush 
2395			 
2395				STACKFRAMECHK ON $1efe $2f9f 
2395				if DEBUG_STACK_IMB 
2395					if ON 
2395						exx 
2395						ld hl, $2f9f 
2395						pop de   ; $2f9f 
2395						call cmp16 
2395						jr nz, .spnosame 
2395						ld hl, $1efe 
2395						pop de   ; $1efe 
2395						call cmp16 
2395						jr z, .spfrsame 
2395						.spnosame: call showsperror 
2395						.spfrsame: nop 
2395						exx 
2395					endif 
2395				endif 
2395			endm 
# End of macro STACKFRAMECHK
2395			 
2395			execnext: 
2395			 
2395			if DEBUG_FORTH_PARSE_KEY 
2395						DMARK "KY>" 
2395			endif 
2395			; move past token to next word 
2395			 
2395 2a 00 f5		ld hl, (os_tok_ptr) 
2398 3e 00		ld a, 0 
239a 01 ff 00		ld bc, 255     ; input buffer size 
239d ed b1		cpir 
239f			 
239f			if DEBUG_FORTH_PARSE_KEY 
239f						DMARK "KY!" 
239f				CALLMONITOR 
239f			endif	 
239f			; TODO this might place hl on the null, so will need to forward on??? 
239f			;inc hl   ; see if this gets onto the next item 
239f			 
239f			 
239f			; TODO pass a pointer to the buffer to push 
239f			; TODO call function to push 
239f			 
239f			; look for end of input 
239f			 
239f			;inc hl 
239f			;ld a,(hl) 
239f			;cp FORTH_END_BUFFER 
239f			;ret z 
239f			 
239f			 
239f c3 18 23		jp exec1 
23a2			 
23a2			 
23a2			 
23a2			 
23a2			 
23a2			 
23a2			 
23a2			 
23a2			 
23a2			findnexttok: 
23a2			 
23a2				; hl is pointer to move 
23a2				; de is the token to locate 
23a2			 
23a2					if DEBUG_FORTH 
23a2						DMARK "NTK" 
23a2						CALLMONITOR 
23a2					endif 
23a2 d5				push de 
23a3			 
23a3			.fnt1:	 
23a3				; find first char of token to locate 
23a3			 
23a3 1a				ld a, (de) 
23a4 4f				ld c,a 
23a5 7e				ld a,(hl) 
23a6 cd 53 13			call toUpper 
23a9					if DEBUG_FORTH 
23a9						DMARK "NT1" 
23a9						CALLMONITOR 
23a9					endif 
23a9 b9				cp c 
23aa			 
23aa 28 03			jr z, .fnt2cmpmorefirst	 
23ac			 
23ac				; first char not found move to next char 
23ac			 
23ac 23				inc hl 
23ad 18 f4			jr .fnt1 
23af			 
23af			.fnt2cmpmorefirst:	 
23af				; first char of token found.  
23af			 
23af e5				push hl     ; save start of token just in case it is the right one 
23b0 d9				exx 
23b1 e1				pop hl        ; save it to hl' 
23b2 d9				exx 
23b3			 
23b3			 
23b3			.fnt2cmpmore:	 
23b3				; compare the rest 
23b3				 
23b3 23				inc hl 
23b4 13				inc de 
23b5				 
23b5 1a				ld a, (de) 
23b6 4f				ld c,a 
23b7 7e				ld a,(hl) 
23b8 cd 53 13			call toUpper 
23bb			 
23bb					if DEBUG_FORTH 
23bb						DMARK "NT2" 
23bb						CALLMONITOR 
23bb					endif 
23bb				; c has the token to find char 
23bb				; a has the mem to scan char 
23bb			 
23bb b9				cp c 
23bc 28 04			jr z,.fntmatch1 
23be			 
23be				; they are not the same 
23be			 
23be					if DEBUG_FORTH 
23be						DMARK "NT3" 
23be						CALLMONITOR 
23be					endif 
23be d1				pop de	; reset de token to look for 
23bf d5				push de 
23c0 18 e1			jr .fnt1 
23c2				 
23c2			.fntmatch1: 
23c2			 
23c2				; is the same char a null which means we might have a full hit? 
23c2					if DEBUG_FORTH 
23c2						DMARK "NT4" 
23c2						CALLMONITOR 
23c2					endif 
23c2			 
23c2 fe 00			cp 0 
23c4 28 0b			jr z, .fntmatchyes 
23c6			 
23c6				; are we at the end of the token to find? 
23c6			 
23c6					if DEBUG_FORTH 
23c6						DMARK "NT5" 
23c6						CALLMONITOR 
23c6					endif 
23c6 3e 00			ld a, 0 
23c8 b9				cp c 
23c9			 
23c9 c2 b3 23			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
23cc			 
23cc					if DEBUG_FORTH 
23cc						DMARK "NT6" 
23cc						CALLMONITOR 
23cc					endif 
23cc				; token to find is exhusted but no match to stream 
23cc			 
23cc				; restore tok pointer and continue on 
23cc d1				pop de 
23cd d5				push de 
23ce c3 a3 23			jp .fnt1 
23d1			 
23d1			 
23d1			.fntmatchyes: 
23d1			 
23d1				; hl now contains the end of the found token 
23d1			 
23d1				; get rid of saved token pointer to find 
23d1			 
23d1 d1				pop de 
23d2			 
23d2					if DEBUG_FORTH 
23d2						DMARK "NT9" 
23d2						CALLMONITOR 
23d2					endif 
23d2			 
23d2				; hl will be on the null term so forward on 
23d2			 
23d2				; get back the saved start of the token 
23d2			 
23d2 d9				exx 
23d3 e5				push hl     ; save start of token just in case it is the right one 
23d4 d9				exx 
23d5 e1				pop hl        ; save it to hl 
23d6			 
23d6 c9				ret 
23d7			 
23d7			 
23d7			; LIST needs to find a specific token   
23d7			; FORGET needs to find a spefici token 
23d7			 
23d7			; SAVE needs to find all tokens by flag 
23d7			; WORDS just needs to scan through all  by flag 
23d7			; UWORDS needs to scan through all by flag 
23d7			 
23d7			 
23d7			; given hl as pointer to start of dict look up string 
23d7			; return hl as pointer to start of word block 
23d7			; or 0 if not found 
23d7			 
23d7			forth_find_tok: 
23d7 c9				ret 
23d8			 
23d8			; given hl as pointer to dict structure 
23d8			; move to the next dict block structure 
23d8			 
23d8			forth_tok_next: 
23d8				; hl now points to the address of the next word pointer  
23d8				; TODO skip compiled symbol for now 
23d8			;	push de 
23d8 23				inc hl 
23d9 5e				ld e, (hl) 
23da 23				inc hl 
23db 56				ld d, (hl) 
23dc 23				inc hl 
23dd			 
23dd eb				ex de,hl 
23de			if DEBUG_FORTH_PARSE_NEXTWORD 
23de				push bc 
23de				ld bc, (cli_nextword) 
23de						DMARK "NXW" 
23de				CALLMONITOR 
23de				pop bc 
23de			endif 
23de			;	pop de	 
23de c9				ret 
23df			 
23df			 
23df			 
23df			; eof 
# End of file forth_parserv5.asm
23df				include "forth_wordsv4.asm" 
23df			 
23df			; the core word dictionary v4 
23df			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
23df			 
23df			; this is a linked list for each of the system words used 
23df			; user defined words will follow the same format but will be in ram 
23df			 
23df			 
23df			; 
23df			; 
23df			; define linked list: 
23df			; 
23df			; 1. compiled byte op code 
23df			; 2. len of text word 
23df			; 3. text word 
23df			; 4. ptr to next dictionary word 
23df			; 5. asm, calls etc for the word 
23df			; 
23df			;  if 1 == 0 then last word in dict  
23df			;   
23df			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
23df			;  
23df			;  
23df			; create basic standard set of words 
23df			; 
23df			;  
23df			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
23df			; 2DUP 2DROP 2SWAP  
23df			; @ C@ - get byte  
23df			; ! C! - store byte 
23df			; 0< true if less than zero 
23df			; 0= true if zero 
23df			; < >  
23df			; = true if same 
23df			; variables 
23df			 
23df			 
23df			; Hardware specific words I may need 
23df			; 
23df			; IN OUT  
23df			; calls to key util functions 
23df			; calls to hardward abstraction stuff 
23df			; easy control of frame buffers and lcd i/o 
23df			; keyboard  
23df			 
23df			 
23df			;DICT: macro 
23df			; op_code, len, word, next 
23df			;    word: 
23df			;    db op_code 
23df			;    ds word zero term 
23df			;    dw next 
23df			;    endm 
23df			 
23df			 
23df			 
23df			 
23df			; op code 1 is a flag for user define words which are to be handled differently 
23df			 
23df			 
23df			; 
23df			; 
23df			;    TODO on entry to a word this should be the expected environment 
23df			;    hl - tos value if number then held, if string this is the ptr 
23df			;    de -  
23df			 
23df			 
23df			; opcode ranges 
23df			; 0 - end of word dict 
23df			; 255 - user define words 
23df			 
23df			sysdict: 
23df			include "forth_opcodes.asm" 
23df			; op codes for forth keywords 
23df			; free to use code 0  
23df				OPCODE_HEAP: equ  1 
23df				OPCODE_EXEC: equ 2 
23df				OPCODE_DUP: equ 3 
23df				OPCODE_SWAP: equ 4 
23df				OPCODE_COLN: equ 5 
23df				OPCODE_SCOLN: equ 6 
23df				OPCODE_DROP: equ 7 
23df				OPCODE_DUP2: equ 8 
23df				OPCODE_DROP2: equ 9 
23df				OPCODE_SWAP2: equ 10 
23df				OPCODE_AT: equ 11 
23df				OPCODE_CAT: equ 12 
23df				OPCODE_BANG: equ 13 
23df				OPCODE_CBANG: equ 14 
23df				OPCODE_SCALL: equ 15 
23df				OPCODE_DEPTH: equ 16 
23df				OPCODE_OVER: equ 17 
23df				OPCODE_PAUSE: equ 18 
23df				OPCODE_PAUSES: equ 19 
23df				OPCODE_ROT: equ 20 
23df			;free to reuse	OPCODE_WORDS: equ 21 
23df			        OPCODE_NOT: equ 21 
23df				OPCODE_UWORDS: equ 22 
23df				OPCODE_BP: equ 23 
23df				OPCODE_MONITOR: equ 24  
23df				OPCODE_MALLOC: equ 25 
23df				OPCODE_FREE: equ 26 
23df				OPCODE_LIST: equ 27 
23df				OPCODE_FORGET: equ 28 
23df				OPCODE_NOP: equ 29 
23df				OPCODE_COMO: equ 30 
23df				OPCODE_COMC: equ 31 
23df			;free to reuse	OPCODE_ENDCORE: equ 32 
23df				OPCODE_AFTERSOUND: equ 33 
23df				OPCODE_GP2: equ 34 
23df				OPCODE_GP3: equ 35 
23df				OPCODE_GP4: equ 36 
23df				OPCODE_SIN: equ 37 
23df				OPCODE_SOUT: equ 38 
23df				OPCODE_SPIO: equ 39 
23df				OPCODE_SPICEH: equ 40 
23df				OPCODE_SPIOb: equ 41 
23df				OPCODE_SPII: equ 42 
23df				OPCODE_SESEL: equ 43 
23df				OPCODE_CARTDEV: equ 44 
23df			; free to reuse	OPCODE_ENDDEVICE: equ 45 
23df				OPCODE_FB: equ 46 
23df				OPCODE_EMIT: equ 47 
23df				OPCODE_DOTH: equ 48 
23df				OPCODE_DOTF: equ 49 
23df				OPCODE_DOT: equ 50 
23df				OPCODE_CLS: equ 51 
23df				OPCODE_DRAW: equ 52 
23df				OPCODE_DUMP: equ 53 
23df				OPCODE_CDUMP: equ 54 
23df				OPCODE_DAT: equ 55 
23df				OPCODE_HOME: equ 56 
23df				OPCODE_SPACE: equ 57 
23df				OPCODE_SPACES: equ 58 
23df				OPCODE_SCROLL: equ 59 
23df				OPCODE_ATQ: equ 60 
23df				OPCODE_AUTODSP: equ 61 
23df				OPCODE_MENU: equ 62 
23df			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
23df				OPCODE_THEN: equ 64 
23df				OPCODE_ELSE: equ 65 
23df				OPCODE_DO: equ 66 
23df				OPCODE_LOOP: equ 67 
23df				OPCODE_I: equ 68 
23df				OPCODE_DLOOP: equ 69  
23df				OPCODE_REPEAT: equ 70  
23df				OPCODE_UNTIL: equ 71 
23df				OPCODE_ENDFLOW: equ 72 
23df				OPCODE_WAITK: equ 73 
23df				OPCODE_ACCEPT: equ 74 
23df				OPCODE_EDIT: equ 75 
23df			;free to reuse	OPCODE_ENDKEY: equ 76 
23df				OPCODE_LZERO: equ 77 
23df				OPCODE_TZERO: equ 78 
23df				OPCODE_LESS: equ 79 
23df				OPCODE_GT: equ 80 
23df				OPCODE_EQUAL: equ 81  
23df			;free to reuse	OPCODE_ENDLOGIC: equ 82 
23df				OPCODE_NEG: equ 83 
23df				OPCODE_DIV: equ 84 
23df				OPCODE_MUL: equ 85 
23df				OPCODE_MIN: equ 86 
23df				OPCODE_MAX: equ 87 
23df				OPCODE_RND16: equ 88 
23df				OPCODE_RND8: equ 89 
23df				OPCODE_RND: equ 90 
23df			;free to reuse	OPCODE_ENDMATHS: equ 91  
23df				OPCODE_BYNAME: equ 92 
23df				OPCODE_DIR: equ 93 
23df				OPCODE_SAVE: equ 94 
23df				OPCODE_LOAD: equ 95 
23df				OPCODE_BSAVE: equ 96 
23df				OPCODE_BLOAD: equ 97 
23df				OPCODE_SEO: equ 98  
23df				OPCODE_SEI: equ 99 
23df				OPCODE_SFREE: equ 100 
23df				OPCODE_SIZE: equ 101 
23df				OPCODE_CREATE: equ 102 
23df				OPCODE_APPEND: equ 103 
23df				OPCODE_SDEL: equ 104 
23df				OPCODE_OPEN: equ 105 
23df				OPCODE_READ: equ 106 
23df				OPCODE_EOF: equ 106 
23df				OPCODE_FORMAT: equ 107 
23df				OPCODE_LABEL: equ 108 
23df				OPCODE_LABELS: equ 109 
23df			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
23df				OPCODE_UPPER: equ 111 
23df				OPCODE_LOWER: equ 112 
23df				OPCODE_SUBSTR: equ 113 
23df				OPCODE_LEFT: equ 114 
23df				OPCODE_RIGHT: equ 115 
23df				OPCODE_STR2NUM: equ 116 
23df				OPCODE_NUM2STR: equ 117 
23df				OPCODE_CONCAT: equ 118 
23df				OPCODE_FIND: equ 119 
23df				OPCODE_LEN: equ 120 
23df				OPCODE_CHAR: equ 121 
23df			; free to reuse	OPCODE_STRLEN: equ 122 
23df			; free to reuse	OPCODE_ENDSTR: equ 123 
23df				OPCODE_V0S: equ 124 
23df				OPCODE_V0Q: equ 125 
23df				OPCODE_V1S: equ 126 
23df				OPCODE_V1Q: equ 127 
23df				OPCODE_V2S: equ 128 
23df				OPCODE_V2Q: equ 129 
23df				OPCODE_V3S: equ 130 
23df				OPCODE_V3Q: equ 131 
23df			;free to reuse	OPCODE_END: equ 132 
23df				OPCODE_ZDUP: equ 133 
23df			 
23df			; eof 
# End of file forth_opcodes.asm
23df			 
23df			include "forth_words_core.asm" 
23df			 
23df			; | ## Core Words 
23df			 
23df			;if MALLOC_4 
23df			 
23df			.HEAP: 
23df				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
23df 15				db WORD_SYS_CORE+OPCODE_HEAP             
23e0 1e 24			dw .EXEC            
23e2 05				db 4 + 1 
23e3 .. 00			db "HEAP",0              
23e8				endm 
# End of macro CWHEAD
23e8			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
23e8			; | | u1 - Current number of bytes in the heap 
23e8			; | | u2 - Remaining bytes left on the heap 
23e8			; | |  
23e8			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
23e8			 
23e8			 
23e8					if DEBUG_FORTH_WORDS_KEY 
23e8						DMARK "HEP" 
23e8 f5				push af  
23e9 3a fd 23			ld a, (.dmark)  
23ec 32 6e fe			ld (debug_mark),a  
23ef 3a fe 23			ld a, (.dmark+1)  
23f2 32 6f fe			ld (debug_mark+1),a  
23f5 3a ff 23			ld a, (.dmark+2)  
23f8 32 70 fe			ld (debug_mark+2),a  
23fb 18 03			jr .pastdmark  
23fd ..			.dmark: db "HEP"  
2400 f1			.pastdmark: pop af  
2401			endm  
# End of macro DMARK
2401						CALLMONITOR 
2401 cd a5 18			call break_point_state  
2404				endm  
# End of macro CALLMONITOR
2404					endif 
2404 2a 0a 80				ld hl, (free_list )      
2407 11 0e 80				ld de, heap_start 
240a			 
240a ed 52				sbc hl, de  
240c			 
240c cd 19 1f				call forth_push_numhl 
240f			 
240f			 
240f ed 5b 0a 80			ld de, (free_list )      
2413 21 e5 f1				ld hl, heap_end 
2416			 
2416 ed 52				sbc hl, de 
2418			 
2418 cd 19 1f				call forth_push_numhl 
241b					 
241b			 
241b					 
241b			 
241b			 
241b			 
241b					NEXTW 
241b c3 87 22			jp macro_next 
241e				endm 
# End of macro NEXTW
241e			;endif 
241e			 
241e			.EXEC: 
241e			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
241e			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
241e			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
241e			;; > > 
241e			;; > >   
241e			;	STACKFRAME OFF $5efe $5f9f 
241e			; 
241e			;		if DEBUG_FORTH_WORDS_KEY 
241e			;			DMARK "EXE" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			; 
241e			;	FORTH_DSP_VALUEHL 
241e			; 
241e			;	FORTH_DSP_POP 
241e			; 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EX1" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			;;	ld e,(hl) 
241e			;;	inc hl 
241e			;;	ld d,(hl) 
241e			;;	ex de,hl 
241e			; 
241e			;;		if DEBUG_FORTH_WORDS 
241e			;;			DMARK "EX2" 
241e			;;			CALLMONITOR 
241e			;;		endif 
241e			;	push hl 
241e			; 
241e			;	;ld a, 0 
241e			;	;ld a, FORTH_END_BUFFER 
241e			;	call strlenz 
241e			;	inc hl   ; include zero term to copy 
241e			;	inc hl   ; include term 
241e			;	inc hl   ; include term 
241e			;	ld b,0 
241e			;	ld c,l 
241e			;	pop hl 
241e			;	ld de, execscratch 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EX3" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			;	ldir 
241e			; 
241e			; 
241e			;	ld hl, execscratch 
241e			; 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EXe" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			; 
241e			;	call forthparse 
241e			;	call forthexec 
241e			;;	call forthexec_cleanup 
241e			;;	call forthparse 
241e			;;	call forthexec 
241e			; 
241e			;	STACKFRAMECHK OFF $5efe $5f9f 
241e			; 
241e			;	; an immediate word so no need to process any more words 
241e			;	ret 
241e			;	NEXTW 
241e			 
241e			; dead code - old version  
241e			;	FORTH_RSP_NEXT 
241e			 
241e			;  
241e			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
241e			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
241e			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
241e			;	push hl 
241e			;	push de 
241e			;	push bc 
241e			; 
241e			; 
241e			;		if DEBUG_FORTH_WORDS_KEY 
241e			;			DMARK "EXR" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			; 
241e			; 
241e			; 
241e			;	;v5 FORTH_DSP_VALUE 
241e			;	FORTH_DSP_VALUEHL 
241e			; 
241e			;	; TODO do string type checks 
241e			; 
241e			;;v5	inc hl   ; skip type 
241e			; 
241e			;	push hl  ; source code  
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EX1" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			;	ld a, 0 
241e			;	call strlent 
241e			; 
241e			;	inc hl 
241e			;	inc hl 
241e			;	inc hl 
241e			;	inc hl 
241e			; 
241e			;	push hl    ; size 
241e			; 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EX2" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			;	call malloc 
241e			; 
241e			;	ex de, hl    ; de now contains malloc area 
241e			;	pop bc   	; get byte count 
241e			;	pop hl      ; get string to copy 
241e			; 
241e			;	push de     ; save malloc for free later 
241e			; 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EX3" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			;	ldir       ; duplicate string 
241e			; 
241e			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
241e			;	 
241e			;	; TODO fix the parse would be better than this...  
241e			;	ex de, hl 
241e			;	dec hl 
241e			;	ld a, 0 
241e			;	ld (hl), a 
241e			;	dec hl 
241e			;	ld a, ' ' 
241e			;	ld (hl), a 
241e			;	dec hl 
241e			;	ld (hl), a 
241e			; 
241e			;	dec hl 
241e			;	ld (hl), a 
241e			; 
241e			; 
241e			;	FORTH_DSP_POP  
241e			; 
241e			;	pop hl     
241e			;	push hl    ; save malloc area 
241e			; 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EX4" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			; 
241e			;	call forthparse 
241e			;	call forthexec 
241e			;	 
241e			;	pop hl 
241e			;	if DEBUG_FORTH_WORDS 
241e			;		DMARK "EX5" 
241e			;		CALLMONITOR 
241e			;	endif 
241e			; 
241e			;	if FORTH_ENABLE_FREE 
241e			;	call free 
241e			;	endif 
241e			; 
241e			;	if DEBUG_FORTH_WORDS 
241e			;		DMARK "EX6" 
241e			;		CALLMONITOR 
241e			;	endif 
241e			; 
241e			;	pop bc 
241e			;	pop de 
241e			;	pop hl 
241e			;;	FORTH_RSP_POP	  
241e			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
241e			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
241e			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
241e			; 
241e			;	if DEBUG_FORTH_WORDS 
241e			;		DMARK "EX7" 
241e			;		CALLMONITOR 
241e			;	endif 
241e			;	NEXTW 
241e			 
241e			;.STKEXEC: 
241e			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
241e			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
241e			; 
241e			; 
241e			;		if DEBUG_FORTH_WORDS_KEY 
241e			;			DMARK "STX" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			; 
241e			;	FORTH_DSP_VALUEHL 
241e			; 
241e			;	ld (store_tmp1), hl    ; count 
241e			; 
241e			;	FORTH_DSP_POP 
241e			;.stkexec1: 
241e			;	ld hl, (store_tmp1)   ; count 
241e			;	ld a, 0 
241e			;	cp l 
241e			;	ret z 
241e			; 
241e			;	dec hl 
241e			;	ld (store_tmp1), hl    ; count 
241e			;	 
241e			;	FORTH_DSP_VALUEHL 
241e			;	push hl 
241e			;	 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EXp" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			;	FORTH_DSP_POP 
241e			; 
241e			;	call strlenz 
241e			;	inc hl   ; include zero term to copy 
241e			;	inc hl   ; include zero term to copy 
241e			;	inc hl   ; include zero term to copy 
241e			;	ld b,0 
241e			;	ld c,l 
241e			;	pop hl 
241e			;	ld de, execscratch 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EX3" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			;	ldir 
241e			; 
241e			; 
241e			;	ld hl, execscratch 
241e			; 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EXP" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			; 
241e			;	call forthparse 
241e			;	ld hl, execscratch 
241e			;		if DEBUG_FORTH_WORDS 
241e			;			DMARK "EXx" 
241e			;			CALLMONITOR 
241e			;		endif 
241e			;	call forthexec 
241e			; 
241e			;	jp .stkexec1 
241e			; 
241e			;	ret 
241e			 
241e			 
241e			.DUP: 
241e				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
241e 17				db WORD_SYS_CORE+OPCODE_DUP             
241f 94 24			dw .ZDUP            
2421 04				db 3 + 1 
2422 .. 00			db "DUP",0              
2426				endm 
# End of macro CWHEAD
2426			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2426			 
2426					if DEBUG_FORTH_WORDS_KEY 
2426						DMARK "DUP" 
2426 f5				push af  
2427 3a 3b 24			ld a, (.dmark)  
242a 32 6e fe			ld (debug_mark),a  
242d 3a 3c 24			ld a, (.dmark+1)  
2430 32 6f fe			ld (debug_mark+1),a  
2433 3a 3d 24			ld a, (.dmark+2)  
2436 32 70 fe			ld (debug_mark+2),a  
2439 18 03			jr .pastdmark  
243b ..			.dmark: db "DUP"  
243e f1			.pastdmark: pop af  
243f			endm  
# End of macro DMARK
243f						CALLMONITOR 
243f cd a5 18			call break_point_state  
2442				endm  
# End of macro CALLMONITOR
2442					endif 
2442			 
2442					FORTH_DSP 
2442 cd d6 20			call macro_forth_dsp 
2445				endm 
# End of macro FORTH_DSP
2445			 
2445 7e					ld a, (HL) 
2446 fe 01				cp DS_TYPE_STR 
2448 20 25				jr nz, .dupinum 
244a			 
244a					; push another string 
244a			 
244a					FORTH_DSP_VALUEHL     		 
244a cd 10 21			call macro_dsp_valuehl 
244d				endm 
# End of macro FORTH_DSP_VALUEHL
244d			 
244d				if DEBUG_FORTH_WORDS 
244d					DMARK "DUs" 
244d f5				push af  
244e 3a 62 24			ld a, (.dmark)  
2451 32 6e fe			ld (debug_mark),a  
2454 3a 63 24			ld a, (.dmark+1)  
2457 32 6f fe			ld (debug_mark+1),a  
245a 3a 64 24			ld a, (.dmark+2)  
245d 32 70 fe			ld (debug_mark+2),a  
2460 18 03			jr .pastdmark  
2462 ..			.dmark: db "DUs"  
2465 f1			.pastdmark: pop af  
2466			endm  
# End of macro DMARK
2466					CALLMONITOR 
2466 cd a5 18			call break_point_state  
2469				endm  
# End of macro CALLMONITOR
2469				endif 
2469 cd 87 1f				call forth_push_str 
246c			 
246c					NEXTW 
246c c3 87 22			jp macro_next 
246f				endm 
# End of macro NEXTW
246f			 
246f			 
246f			.dupinum: 
246f					 
246f			 
246f			 
246f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
246f cd 10 21			call macro_dsp_valuehl 
2472				endm 
# End of macro FORTH_DSP_VALUEHL
2472			 
2472				; TODO add floating point number detection 
2472			 
2472				if DEBUG_FORTH_WORDS 
2472					DMARK "DUi" 
2472 f5				push af  
2473 3a 87 24			ld a, (.dmark)  
2476 32 6e fe			ld (debug_mark),a  
2479 3a 88 24			ld a, (.dmark+1)  
247c 32 6f fe			ld (debug_mark+1),a  
247f 3a 89 24			ld a, (.dmark+2)  
2482 32 70 fe			ld (debug_mark+2),a  
2485 18 03			jr .pastdmark  
2487 ..			.dmark: db "DUi"  
248a f1			.pastdmark: pop af  
248b			endm  
# End of macro DMARK
248b					CALLMONITOR 
248b cd a5 18			call break_point_state  
248e				endm  
# End of macro CALLMONITOR
248e				endif 
248e			 
248e cd 19 1f				call forth_push_numhl 
2491					NEXTW 
2491 c3 87 22			jp macro_next 
2494				endm 
# End of macro NEXTW
2494			.ZDUP: 
2494				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2494 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2495 cc 24			dw .SWAP            
2497 05				db 4 + 1 
2498 .. 00			db "?DUP",0              
249d				endm 
# End of macro CWHEAD
249d			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
249d			 
249d					if DEBUG_FORTH_WORDS_KEY 
249d						DMARK "qDU" 
249d f5				push af  
249e 3a b2 24			ld a, (.dmark)  
24a1 32 6e fe			ld (debug_mark),a  
24a4 3a b3 24			ld a, (.dmark+1)  
24a7 32 6f fe			ld (debug_mark+1),a  
24aa 3a b4 24			ld a, (.dmark+2)  
24ad 32 70 fe			ld (debug_mark+2),a  
24b0 18 03			jr .pastdmark  
24b2 ..			.dmark: db "qDU"  
24b5 f1			.pastdmark: pop af  
24b6			endm  
# End of macro DMARK
24b6						CALLMONITOR 
24b6 cd a5 18			call break_point_state  
24b9				endm  
# End of macro CALLMONITOR
24b9					endif 
24b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24b9 cd 10 21			call macro_dsp_valuehl 
24bc				endm 
# End of macro FORTH_DSP_VALUEHL
24bc			 
24bc e5					push hl 
24bd			 
24bd					; is it a zero? 
24bd			 
24bd 3e 00				ld a, 0 
24bf 84					add h 
24c0 85					add l 
24c1			 
24c1 e1					pop hl 
24c2			 
24c2 fe 00				cp 0 
24c4 28 03				jr z, .dup2orig 
24c6			 
24c6			 
24c6 cd 19 1f				call forth_push_numhl 
24c9			 
24c9			 
24c9				; TODO add floating point number detection 
24c9			 
24c9			.dup2orig: 
24c9			 
24c9					NEXTW 
24c9 c3 87 22			jp macro_next 
24cc				endm 
# End of macro NEXTW
24cc			.SWAP: 
24cc				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
24cc 18				db WORD_SYS_CORE+OPCODE_SWAP             
24cd 0b 25			dw .COLN            
24cf 05				db 4 + 1 
24d0 .. 00			db "SWAP",0              
24d5				endm 
# End of macro CWHEAD
24d5			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
24d5					if DEBUG_FORTH_WORDS_KEY 
24d5						DMARK "SWP" 
24d5 f5				push af  
24d6 3a ea 24			ld a, (.dmark)  
24d9 32 6e fe			ld (debug_mark),a  
24dc 3a eb 24			ld a, (.dmark+1)  
24df 32 6f fe			ld (debug_mark+1),a  
24e2 3a ec 24			ld a, (.dmark+2)  
24e5 32 70 fe			ld (debug_mark+2),a  
24e8 18 03			jr .pastdmark  
24ea ..			.dmark: db "SWP"  
24ed f1			.pastdmark: pop af  
24ee			endm  
# End of macro DMARK
24ee						CALLMONITOR 
24ee cd a5 18			call break_point_state  
24f1				endm  
# End of macro CALLMONITOR
24f1					endif 
24f1			 
24f1					FORTH_DSP_VALUEHL 
24f1 cd 10 21			call macro_dsp_valuehl 
24f4				endm 
# End of macro FORTH_DSP_VALUEHL
24f4 e5					push hl     ; w2 
24f5			 
24f5					FORTH_DSP_POP 
24f5 cd c8 21			call macro_forth_dsp_pop 
24f8				endm 
# End of macro FORTH_DSP_POP
24f8			 
24f8					FORTH_DSP_VALUEHL 
24f8 cd 10 21			call macro_dsp_valuehl 
24fb				endm 
# End of macro FORTH_DSP_VALUEHL
24fb			 
24fb					FORTH_DSP_POP 
24fb cd c8 21			call macro_forth_dsp_pop 
24fe				endm 
# End of macro FORTH_DSP_POP
24fe			 
24fe d1					pop de     ; w2	, hl = w1 
24ff			 
24ff eb					ex de, hl 
2500 d5					push de 
2501			 
2501 cd 19 1f				call forth_push_numhl 
2504			 
2504 e1					pop hl 
2505			 
2505 cd 19 1f				call forth_push_numhl 
2508					 
2508			 
2508					NEXTW 
2508 c3 87 22			jp macro_next 
250b				endm 
# End of macro NEXTW
250b			.COLN: 
250b				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
250b 19				db WORD_SYS_CORE+OPCODE_COLN             
250c 97 26			dw .SCOLN            
250e 02				db 1 + 1 
250f .. 00			db ":",0              
2511				endm 
# End of macro CWHEAD
2511			; | : ( -- )         Create new word | DONE 
2511			 
2511					if DEBUG_FORTH_WORDS_KEY 
2511						DMARK "CLN" 
2511 f5				push af  
2512 3a 26 25			ld a, (.dmark)  
2515 32 6e fe			ld (debug_mark),a  
2518 3a 27 25			ld a, (.dmark+1)  
251b 32 6f fe			ld (debug_mark+1),a  
251e 3a 28 25			ld a, (.dmark+2)  
2521 32 70 fe			ld (debug_mark+2),a  
2524 18 03			jr .pastdmark  
2526 ..			.dmark: db "CLN"  
2529 f1			.pastdmark: pop af  
252a			endm  
# End of macro DMARK
252a						CALLMONITOR 
252a cd a5 18			call break_point_state  
252d				endm  
# End of macro CALLMONITOR
252d					endif 
252d				STACKFRAME OFF $8efe $989f 
252d				if DEBUG_STACK_IMB 
252d					if OFF 
252d						exx 
252d						ld de, $8efe 
252d						ld a, d 
252d						ld hl, curframe 
252d						call hexout 
252d						ld a, e 
252d						ld hl, curframe+2 
252d						call hexout 
252d						ld hl, $8efe 
252d						push hl 
252d						ld hl, $989f 
252d						push hl 
252d						exx 
252d					endif 
252d				endif 
252d			endm 
# End of macro STACKFRAME
252d				; get parser buffer length  of new word 
252d			 
252d				 
252d			 
252d					; move tok past this to start of name defintition 
252d					; TODO get word to define 
252d					; TODO Move past word token 
252d					; TODO get length of string up to the ';' 
252d			 
252d 2a 00 f5			ld hl, (os_tok_ptr) 
2530 23				inc hl 
2531 23				inc hl 
2532			 
2532 3e 3b			ld a, ';' 
2534 cd 67 13			call strlent 
2537			 
2537 7d				ld a,l 
2538 32 fb f1			ld (os_new_parse_len), a 
253b			 
253b			 
253b			if DEBUG_FORTH_UWORD 
253b ed 5b 00 f5		ld de, (os_tok_ptr) 
253f						DMARK ":01" 
253f f5				push af  
2540 3a 54 25			ld a, (.dmark)  
2543 32 6e fe			ld (debug_mark),a  
2546 3a 55 25			ld a, (.dmark+1)  
2549 32 6f fe			ld (debug_mark+1),a  
254c 3a 56 25			ld a, (.dmark+2)  
254f 32 70 fe			ld (debug_mark+2),a  
2552 18 03			jr .pastdmark  
2554 ..			.dmark: db ":01"  
2557 f1			.pastdmark: pop af  
2558			endm  
# End of macro DMARK
2558				CALLMONITOR 
2558 cd a5 18			call break_point_state  
255b				endm  
# End of macro CALLMONITOR
255b			endif 
255b			 
255b			; 
255b			;  new word memory layout: 
255b			;  
255b			;    : adg 6666 ;  
255b			; 
255b			;    db   1     ; user defined word  
255b 23				inc hl    
255c			;    dw   sysdict 
255c 23				inc hl 
255d 23				inc hl 
255e			;    db <word len>+1 (for null) 
255e 23				inc hl 
255f			;    db .... <word> 
255f			; 
255f			 
255f 23				inc hl    ; some extras for the word preamble before the above 
2560 23				inc hl 
2561 23				inc hl 
2562 23				inc hl 
2563 23				inc hl 
2564 23				inc hl 
2565 23				inc hl  
2566 23				inc hl 
2567 23				inc hl 
2568 23				inc hl 
2569 23				inc hl 
256a 23				inc hl 
256b 23				inc hl 
256c 23				inc hl     ; TODO how many do we really need?     maybe only 6 
256d			;       exec word buffer 
256d			;	<ptr word>   
256d 23				inc hl 
256e 23				inc hl 
256f			;       <word list><null term> 7F final term 
256f			 
256f			 
256f			if DEBUG_FORTH_UWORD 
256f						DMARK ":02" 
256f f5				push af  
2570 3a 84 25			ld a, (.dmark)  
2573 32 6e fe			ld (debug_mark),a  
2576 3a 85 25			ld a, (.dmark+1)  
2579 32 6f fe			ld (debug_mark+1),a  
257c 3a 86 25			ld a, (.dmark+2)  
257f 32 70 fe			ld (debug_mark+2),a  
2582 18 03			jr .pastdmark  
2584 ..			.dmark: db ":02"  
2587 f1			.pastdmark: pop af  
2588			endm  
# End of macro DMARK
2588				CALLMONITOR 
2588 cd a5 18			call break_point_state  
258b				endm  
# End of macro CALLMONITOR
258b			endif 
258b			 
258b				 
258b					; malloc the size 
258b			 
258b cd c5 13				call malloc 
258e 22 fd f1				ld (os_new_malloc), hl     ; save malloc start 
2591			 
2591			;    db   1     ; user defined word  
2591 3e 01				ld a, WORD_SYS_UWORD  
2593 77					ld (hl), a 
2594				 
2594 23				inc hl    
2595			;    dw   sysdict 
2595 11 df 23			ld de, sysdict       ; continue on with the scan to the system dict 
2598 73				ld (hl), e 
2599 23				inc hl 
259a 72				ld (hl), d 
259b 23				inc hl 
259c			 
259c			 
259c			;    Setup dict word 
259c			 
259c 23				inc hl 
259d 22 f7 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
25a0			 
25a0				; 1. get length of dict word 
25a0			 
25a0			 
25a0 2a 00 f5			ld hl, (os_tok_ptr) 
25a3 23				inc hl 
25a4 23				inc hl    ; position to start of dict word 
25a5 3e 00			ld a, 0 
25a7 cd 67 13			call strlent 
25aa			 
25aa			 
25aa 23				inc hl    ; to include null??? 
25ab			 
25ab				; write length of dict word 
25ab			 
25ab ed 5b f7 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
25af 1b				dec de 
25b0 eb				ex de, hl 
25b1 73				ld (hl), e 
25b2 eb				ex de, hl 
25b3			 
25b3				 
25b3			 
25b3				; copy  
25b3 4d				ld c, l 
25b4 06 00			ld b, 0 
25b6 ed 5b f7 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
25ba 2a 00 f5			ld hl, (os_tok_ptr) 
25bd 23				inc hl 
25be 23				inc hl    ; position to start of dict word 
25bf				 
25bf			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
25bf				 
25bf				; TODO need to convert word to upper case 
25bf			 
25bf			ucasetok:	 
25bf 7e				ld a,(hl) 
25c0 cd 53 13			call toUpper 
25c3 77				ld (hl),a 
25c4 ed a0			ldi 
25c6 f2 bf 25		 	jp p, ucasetok 
25c9			 
25c9			 
25c9			 
25c9				; de now points to start of where the word body code should be placed 
25c9 ed 53 f7 f1		ld (os_new_work_ptr), de 
25cd				; hl now points to the words to throw at forthexec which needs to be copied 
25cd 22 f5 f1			ld (os_new_src_ptr), hl 
25d0			 
25d0				; TODO add 'call to forthexec' 
25d0			 
25d0			if DEBUG_FORTH_UWORD 
25d0 c5				push bc 
25d1 ed 4b fd f1		ld bc, (os_new_malloc) 
25d5						DMARK ":0x" 
25d5 f5				push af  
25d6 3a ea 25			ld a, (.dmark)  
25d9 32 6e fe			ld (debug_mark),a  
25dc 3a eb 25			ld a, (.dmark+1)  
25df 32 6f fe			ld (debug_mark+1),a  
25e2 3a ec 25			ld a, (.dmark+2)  
25e5 32 70 fe			ld (debug_mark+2),a  
25e8 18 03			jr .pastdmark  
25ea ..			.dmark: db ":0x"  
25ed f1			.pastdmark: pop af  
25ee			endm  
# End of macro DMARK
25ee				CALLMONITOR 
25ee cd a5 18			call break_point_state  
25f1				endm  
# End of macro CALLMONITOR
25f1 c1				pop bc 
25f2			endif 
25f2			 
25f2			 
25f2				; create word preamble which should be: 
25f2			 
25f2			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
25f2			 
25f2				;    ld hl, <word code> 
25f2				;    jp user_exec 
25f2			        ;    <word code bytes> 
25f2			 
25f2			 
25f2			;	inc de     ; TODO ??? or are we already past the word's null 
25f2 eb				ex de, hl 
25f3			 
25f3 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
25f5			 
25f5 23				inc hl 
25f6 22 f1 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
25f9 23				inc hl 
25fa			 
25fa 23				inc hl 
25fb 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
25fd			 
25fd 01 b0 54			ld bc, user_exec 
2600 23				inc hl 
2601 71				ld (hl), c     ; poke address of user_exec 
2602 23				inc hl 
2603 70				ld (hl), b     
2604			 ; 
2604			;	inc hl 
2604			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2604			; 
2604			; 
2604			;	ld bc, macro_forth_rsp_next 
2604			;	inc hl 
2604			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2604			;	inc hl 
2604			;	ld (hl), b     
2604			 ; 
2604			;	inc hl 
2604			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2604			; 
2604			; 
2604			;	inc hl 
2604			;	ld bc, forthexec 
2604			;	ld (hl), c     ; poke address of forthexec 
2604			;	inc hl 
2604			;	ld (hl), b      
2604			; 
2604			;	inc hl 
2604			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2604			; 
2604			;	ld bc, user_dict_next 
2604			;	inc hl 
2604			;	ld (hl), c     ; poke address of forthexec 
2604			;	inc hl 
2604			;	ld (hl), b      
2604			 
2604				; hl is now where we need to copy the word byte data to save this 
2604			 
2604 23				inc hl 
2605 22 f3 f1			ld (os_new_exec), hl 
2608				 
2608				; copy definition 
2608			 
2608 eb				ex de, hl 
2609			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2609			;	inc de    ; skip the PC for this parse 
2609 3a fb f1			ld a, (os_new_parse_len) 
260c 4f				ld c, a 
260d 06 00			ld b, 0 
260f ed b0			ldir		 ; copy defintion 
2611			 
2611			 
2611				; poke the address of where the new word bytes live for forthexec 
2611			 
2611 2a f1 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2614			 
2614 ed 5b f3 f1		ld de, (os_new_exec)      
2618				 
2618 73				ld (hl), e 
2619 23				inc hl 
261a 72				ld (hl), d 
261b			 
261b					; TODO copy last user dict word next link to this word 
261b					; TODO update last user dict word to point to this word 
261b			; 
261b			; hl f923 de 812a ; bc 811a 
261b			 
261b			if DEBUG_FORTH_UWORD 
261b c5				push bc 
261c ed 4b fd f1		ld bc, (os_new_malloc) 
2620						DMARK ":0A" 
2620 f5				push af  
2621 3a 35 26			ld a, (.dmark)  
2624 32 6e fe			ld (debug_mark),a  
2627 3a 36 26			ld a, (.dmark+1)  
262a 32 6f fe			ld (debug_mark+1),a  
262d 3a 37 26			ld a, (.dmark+2)  
2630 32 70 fe			ld (debug_mark+2),a  
2633 18 03			jr .pastdmark  
2635 ..			.dmark: db ":0A"  
2638 f1			.pastdmark: pop af  
2639			endm  
# End of macro DMARK
2639				CALLMONITOR 
2639 cd a5 18			call break_point_state  
263c				endm  
# End of macro CALLMONITOR
263c c1				pop bc 
263d			endif 
263d			if DEBUG_FORTH_UWORD 
263d c5				push bc 
263e ed 4b fd f1		ld bc, (os_new_malloc) 
2642 03				inc bc 
2643 03				inc bc 
2644 03				inc bc 
2645 03				inc bc 
2646 03				inc bc 
2647 03				inc bc 
2648 03				inc bc 
2649 03				inc bc 
264a			 
264a						DMARK ":0B" 
264a f5				push af  
264b 3a 5f 26			ld a, (.dmark)  
264e 32 6e fe			ld (debug_mark),a  
2651 3a 60 26			ld a, (.dmark+1)  
2654 32 6f fe			ld (debug_mark+1),a  
2657 3a 61 26			ld a, (.dmark+2)  
265a 32 70 fe			ld (debug_mark+2),a  
265d 18 03			jr .pastdmark  
265f ..			.dmark: db ":0B"  
2662 f1			.pastdmark: pop af  
2663			endm  
# End of macro DMARK
2663				CALLMONITOR 
2663 cd a5 18			call break_point_state  
2666				endm  
# End of macro CALLMONITOR
2666 c1				pop bc 
2667			endif 
2667			 
2667			; update word dict linked list for new word 
2667			 
2667			 
2667 2a fc f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
266a 23			inc hl     ; move to next work linked list ptr 
266b			 
266b ed 5b fd f1	ld de, (os_new_malloc)		 ; new next word 
266f 73			ld (hl), e 
2670 23			inc hl 
2671 72			ld (hl), d 
2672			 
2672			if DEBUG_FORTH_UWORD 
2672 ed 4b fc f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2676			endif 
2676			 
2676 ed 53 fc f4	ld (os_last_new_uword), de      ; update last new uword ptr 
267a			 
267a			 
267a			if DEBUG_FORTH_UWORD 
267a						DMARK ":0+" 
267a f5				push af  
267b 3a 8f 26			ld a, (.dmark)  
267e 32 6e fe			ld (debug_mark),a  
2681 3a 90 26			ld a, (.dmark+1)  
2684 32 6f fe			ld (debug_mark+1),a  
2687 3a 91 26			ld a, (.dmark+2)  
268a 32 70 fe			ld (debug_mark+2),a  
268d 18 03			jr .pastdmark  
268f ..			.dmark: db ":0+"  
2692 f1			.pastdmark: pop af  
2693			endm  
# End of macro DMARK
2693				CALLMONITOR 
2693 cd a5 18			call break_point_state  
2696				endm  
# End of macro CALLMONITOR
2696			endif 
2696			 
2696				STACKFRAMECHK OFF $8efe $989f 
2696				if DEBUG_STACK_IMB 
2696					if OFF 
2696						exx 
2696						ld hl, $989f 
2696						pop de   ; $989f 
2696						call cmp16 
2696						jr nz, .spnosame 
2696						ld hl, $8efe 
2696						pop de   ; $8efe 
2696						call cmp16 
2696						jr z, .spfrsame 
2696						.spnosame: call showsperror 
2696						.spfrsame: nop 
2696						exx 
2696					endif 
2696				endif 
2696			endm 
# End of macro STACKFRAMECHK
2696			 
2696 c9			ret    ; dont process any remaining parser tokens as they form new word 
2697			 
2697			 
2697			 
2697			 
2697			;		NEXT 
2697			.SCOLN: 
2697			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2697 06				db OPCODE_SCOLN 
2698 e3 26			dw .DROP 
269a 02				db 2 
269b .. 00			db ";",0           
269d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
269d					if DEBUG_FORTH_WORDS_KEY 
269d						DMARK "SCN" 
269d f5				push af  
269e 3a b2 26			ld a, (.dmark)  
26a1 32 6e fe			ld (debug_mark),a  
26a4 3a b3 26			ld a, (.dmark+1)  
26a7 32 6f fe			ld (debug_mark+1),a  
26aa 3a b4 26			ld a, (.dmark+2)  
26ad 32 70 fe			ld (debug_mark+2),a  
26b0 18 03			jr .pastdmark  
26b2 ..			.dmark: db "SCN"  
26b5 f1			.pastdmark: pop af  
26b6			endm  
# End of macro DMARK
26b6						CALLMONITOR 
26b6 cd a5 18			call break_point_state  
26b9				endm  
# End of macro CALLMONITOR
26b9					endif 
26b9					FORTH_RSP_TOS 
26b9 cd d7 1e			call macro_forth_rsp_tos 
26bc				endm 
# End of macro FORTH_RSP_TOS
26bc e5					push hl 
26bd					FORTH_RSP_POP 
26bd cd e1 1e			call macro_forth_rsp_pop 
26c0				endm 
# End of macro FORTH_RSP_POP
26c0 e1					pop hl 
26c1			;		ex de,hl 
26c1 22 00 f5				ld (os_tok_ptr),hl 
26c4			 
26c4			if DEBUG_FORTH_UWORD 
26c4						DMARK "SCL" 
26c4 f5				push af  
26c5 3a d9 26			ld a, (.dmark)  
26c8 32 6e fe			ld (debug_mark),a  
26cb 3a da 26			ld a, (.dmark+1)  
26ce 32 6f fe			ld (debug_mark+1),a  
26d1 3a db 26			ld a, (.dmark+2)  
26d4 32 70 fe			ld (debug_mark+2),a  
26d7 18 03			jr .pastdmark  
26d9 ..			.dmark: db "SCL"  
26dc f1			.pastdmark: pop af  
26dd			endm  
# End of macro DMARK
26dd				CALLMONITOR 
26dd cd a5 18			call break_point_state  
26e0				endm  
# End of macro CALLMONITOR
26e0			endif 
26e0					NEXTW 
26e0 c3 87 22			jp macro_next 
26e3				endm 
# End of macro NEXTW
26e3			 
26e3			.DROP: 
26e3				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
26e3 1b				db WORD_SYS_CORE+OPCODE_DROP             
26e4 0e 27			dw .DUP2            
26e6 05				db 4 + 1 
26e7 .. 00			db "DROP",0              
26ec				endm 
# End of macro CWHEAD
26ec			; | DROP ( w -- )   drop the TOS item   | DONE 
26ec					if DEBUG_FORTH_WORDS_KEY 
26ec						DMARK "DRP" 
26ec f5				push af  
26ed 3a 01 27			ld a, (.dmark)  
26f0 32 6e fe			ld (debug_mark),a  
26f3 3a 02 27			ld a, (.dmark+1)  
26f6 32 6f fe			ld (debug_mark+1),a  
26f9 3a 03 27			ld a, (.dmark+2)  
26fc 32 70 fe			ld (debug_mark+2),a  
26ff 18 03			jr .pastdmark  
2701 ..			.dmark: db "DRP"  
2704 f1			.pastdmark: pop af  
2705			endm  
# End of macro DMARK
2705						CALLMONITOR 
2705 cd a5 18			call break_point_state  
2708				endm  
# End of macro CALLMONITOR
2708					endif 
2708					FORTH_DSP_POP 
2708 cd c8 21			call macro_forth_dsp_pop 
270b				endm 
# End of macro FORTH_DSP_POP
270b					NEXTW 
270b c3 87 22			jp macro_next 
270e				endm 
# End of macro NEXTW
270e			.DUP2: 
270e				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
270e 1c				db WORD_SYS_CORE+OPCODE_DUP2             
270f 53 27			dw .DROP2            
2711 05				db 4 + 1 
2712 .. 00			db "2DUP",0              
2717				endm 
# End of macro CWHEAD
2717			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2717					if DEBUG_FORTH_WORDS_KEY 
2717						DMARK "2DU" 
2717 f5				push af  
2718 3a 2c 27			ld a, (.dmark)  
271b 32 6e fe			ld (debug_mark),a  
271e 3a 2d 27			ld a, (.dmark+1)  
2721 32 6f fe			ld (debug_mark+1),a  
2724 3a 2e 27			ld a, (.dmark+2)  
2727 32 70 fe			ld (debug_mark+2),a  
272a 18 03			jr .pastdmark  
272c ..			.dmark: db "2DU"  
272f f1			.pastdmark: pop af  
2730			endm  
# End of macro DMARK
2730						CALLMONITOR 
2730 cd a5 18			call break_point_state  
2733				endm  
# End of macro CALLMONITOR
2733					endif 
2733					FORTH_DSP_VALUEHL 
2733 cd 10 21			call macro_dsp_valuehl 
2736				endm 
# End of macro FORTH_DSP_VALUEHL
2736 e5					push hl      ; 2 
2737			 
2737					FORTH_DSP_POP 
2737 cd c8 21			call macro_forth_dsp_pop 
273a				endm 
# End of macro FORTH_DSP_POP
273a					 
273a					FORTH_DSP_VALUEHL 
273a cd 10 21			call macro_dsp_valuehl 
273d				endm 
# End of macro FORTH_DSP_VALUEHL
273d			;		push hl      ; 1 
273d			 
273d					FORTH_DSP_POP 
273d cd c8 21			call macro_forth_dsp_pop 
2740				endm 
# End of macro FORTH_DSP_POP
2740			 
2740			;		pop hl       ; 1 
2740 d1					pop de       ; 2 
2741			 
2741 cd 19 1f				call forth_push_numhl 
2744 eb					ex de, hl 
2745 cd 19 1f				call forth_push_numhl 
2748			 
2748					 
2748 eb					ex de, hl 
2749			 
2749 cd 19 1f				call forth_push_numhl 
274c eb					ex de, hl 
274d cd 19 1f				call forth_push_numhl 
2750			 
2750			 
2750					NEXTW 
2750 c3 87 22			jp macro_next 
2753				endm 
# End of macro NEXTW
2753			.DROP2: 
2753				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2753 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2754 82 27			dw .SWAP2            
2756 06				db 5 + 1 
2757 .. 00			db "2DROP",0              
275d				endm 
# End of macro CWHEAD
275d			; | 2DROP ( w w -- )    Double drop | DONE 
275d					if DEBUG_FORTH_WORDS_KEY 
275d						DMARK "2DR" 
275d f5				push af  
275e 3a 72 27			ld a, (.dmark)  
2761 32 6e fe			ld (debug_mark),a  
2764 3a 73 27			ld a, (.dmark+1)  
2767 32 6f fe			ld (debug_mark+1),a  
276a 3a 74 27			ld a, (.dmark+2)  
276d 32 70 fe			ld (debug_mark+2),a  
2770 18 03			jr .pastdmark  
2772 ..			.dmark: db "2DR"  
2775 f1			.pastdmark: pop af  
2776			endm  
# End of macro DMARK
2776						CALLMONITOR 
2776 cd a5 18			call break_point_state  
2779				endm  
# End of macro CALLMONITOR
2779					endif 
2779					FORTH_DSP_POP 
2779 cd c8 21			call macro_forth_dsp_pop 
277c				endm 
# End of macro FORTH_DSP_POP
277c					FORTH_DSP_POP 
277c cd c8 21			call macro_forth_dsp_pop 
277f				endm 
# End of macro FORTH_DSP_POP
277f					NEXTW 
277f c3 87 22			jp macro_next 
2782				endm 
# End of macro NEXTW
2782			.SWAP2: 
2782				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2782 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2783 ab 27			dw .AT            
2785 06				db 5 + 1 
2786 .. 00			db "2SWAP",0              
278c				endm 
# End of macro CWHEAD
278c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
278c					if DEBUG_FORTH_WORDS_KEY 
278c						DMARK "2SW" 
278c f5				push af  
278d 3a a1 27			ld a, (.dmark)  
2790 32 6e fe			ld (debug_mark),a  
2793 3a a2 27			ld a, (.dmark+1)  
2796 32 6f fe			ld (debug_mark+1),a  
2799 3a a3 27			ld a, (.dmark+2)  
279c 32 70 fe			ld (debug_mark+2),a  
279f 18 03			jr .pastdmark  
27a1 ..			.dmark: db "2SW"  
27a4 f1			.pastdmark: pop af  
27a5			endm  
# End of macro DMARK
27a5						CALLMONITOR 
27a5 cd a5 18			call break_point_state  
27a8				endm  
# End of macro CALLMONITOR
27a8					endif 
27a8					NEXTW 
27a8 c3 87 22			jp macro_next 
27ab				endm 
# End of macro NEXTW
27ab			.AT: 
27ab				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
27ab 1f				db WORD_SYS_CORE+OPCODE_AT             
27ac dd 27			dw .CAT            
27ae 02				db 1 + 1 
27af .. 00			db "@",0              
27b1				endm 
# End of macro CWHEAD
27b1			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
27b1			 
27b1					if DEBUG_FORTH_WORDS_KEY 
27b1						DMARK "AT." 
27b1 f5				push af  
27b2 3a c6 27			ld a, (.dmark)  
27b5 32 6e fe			ld (debug_mark),a  
27b8 3a c7 27			ld a, (.dmark+1)  
27bb 32 6f fe			ld (debug_mark+1),a  
27be 3a c8 27			ld a, (.dmark+2)  
27c1 32 70 fe			ld (debug_mark+2),a  
27c4 18 03			jr .pastdmark  
27c6 ..			.dmark: db "AT."  
27c9 f1			.pastdmark: pop af  
27ca			endm  
# End of macro DMARK
27ca						CALLMONITOR 
27ca cd a5 18			call break_point_state  
27cd				endm  
# End of macro CALLMONITOR
27cd					endif 
27cd			.getbyteat:	 
27cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27cd cd 10 21			call macro_dsp_valuehl 
27d0				endm 
# End of macro FORTH_DSP_VALUEHL
27d0					 
27d0			;		push hl 
27d0				 
27d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27d0 cd c8 21			call macro_forth_dsp_pop 
27d3				endm 
# End of macro FORTH_DSP_POP
27d3			 
27d3			;		pop hl 
27d3			 
27d3 7e					ld a, (hl) 
27d4			 
27d4 6f					ld l, a 
27d5 26 00				ld h, 0 
27d7 cd 19 1f				call forth_push_numhl 
27da			 
27da					NEXTW 
27da c3 87 22			jp macro_next 
27dd				endm 
# End of macro NEXTW
27dd			.CAT: 
27dd				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
27dd 20				db WORD_SYS_CORE+OPCODE_CAT             
27de 06 28			dw .BANG            
27e0 03				db 2 + 1 
27e1 .. 00			db "C@",0              
27e4				endm 
# End of macro CWHEAD
27e4			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
27e4					if DEBUG_FORTH_WORDS_KEY 
27e4						DMARK "CAA" 
27e4 f5				push af  
27e5 3a f9 27			ld a, (.dmark)  
27e8 32 6e fe			ld (debug_mark),a  
27eb 3a fa 27			ld a, (.dmark+1)  
27ee 32 6f fe			ld (debug_mark+1),a  
27f1 3a fb 27			ld a, (.dmark+2)  
27f4 32 70 fe			ld (debug_mark+2),a  
27f7 18 03			jr .pastdmark  
27f9 ..			.dmark: db "CAA"  
27fc f1			.pastdmark: pop af  
27fd			endm  
# End of macro DMARK
27fd						CALLMONITOR 
27fd cd a5 18			call break_point_state  
2800				endm  
# End of macro CALLMONITOR
2800					endif 
2800 c3 cd 27				jp .getbyteat 
2803					NEXTW 
2803 c3 87 22			jp macro_next 
2806				endm 
# End of macro NEXTW
2806			.BANG: 
2806				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2806 21				db WORD_SYS_CORE+OPCODE_BANG             
2807 3c 28			dw .CBANG            
2809 02				db 1 + 1 
280a .. 00			db "!",0              
280c				endm 
# End of macro CWHEAD
280c			; | ! ( x w -- ) Store x at address w      | DONE 
280c					if DEBUG_FORTH_WORDS_KEY 
280c						DMARK "BNG" 
280c f5				push af  
280d 3a 21 28			ld a, (.dmark)  
2810 32 6e fe			ld (debug_mark),a  
2813 3a 22 28			ld a, (.dmark+1)  
2816 32 6f fe			ld (debug_mark+1),a  
2819 3a 23 28			ld a, (.dmark+2)  
281c 32 70 fe			ld (debug_mark+2),a  
281f 18 03			jr .pastdmark  
2821 ..			.dmark: db "BNG"  
2824 f1			.pastdmark: pop af  
2825			endm  
# End of macro DMARK
2825						CALLMONITOR 
2825 cd a5 18			call break_point_state  
2828				endm  
# End of macro CALLMONITOR
2828					endif 
2828			 
2828			.storebyteat:		 
2828					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2828 cd 10 21			call macro_dsp_valuehl 
282b				endm 
# End of macro FORTH_DSP_VALUEHL
282b					 
282b e5					push hl 
282c				 
282c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
282c cd c8 21			call macro_forth_dsp_pop 
282f				endm 
# End of macro FORTH_DSP_POP
282f			 
282f					; get byte to poke 
282f			 
282f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
282f cd 10 21			call macro_dsp_valuehl 
2832				endm 
# End of macro FORTH_DSP_VALUEHL
2832 e5					push hl 
2833			 
2833			 
2833					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2833 cd c8 21			call macro_forth_dsp_pop 
2836				endm 
# End of macro FORTH_DSP_POP
2836			 
2836			 
2836 d1					pop de 
2837 e1					pop hl 
2838			 
2838 73					ld (hl),e 
2839			 
2839			 
2839					NEXTW 
2839 c3 87 22			jp macro_next 
283c				endm 
# End of macro NEXTW
283c			.CBANG: 
283c				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
283c 22				db WORD_SYS_CORE+OPCODE_CBANG             
283d 65 28			dw .SCALL            
283f 03				db 2 + 1 
2840 .. 00			db "C!",0              
2843				endm 
# End of macro CWHEAD
2843			; | C!  ( x w -- ) Store x at address w  | DONE 
2843					if DEBUG_FORTH_WORDS_KEY 
2843						DMARK "CBA" 
2843 f5				push af  
2844 3a 58 28			ld a, (.dmark)  
2847 32 6e fe			ld (debug_mark),a  
284a 3a 59 28			ld a, (.dmark+1)  
284d 32 6f fe			ld (debug_mark+1),a  
2850 3a 5a 28			ld a, (.dmark+2)  
2853 32 70 fe			ld (debug_mark+2),a  
2856 18 03			jr .pastdmark  
2858 ..			.dmark: db "CBA"  
285b f1			.pastdmark: pop af  
285c			endm  
# End of macro DMARK
285c						CALLMONITOR 
285c cd a5 18			call break_point_state  
285f				endm  
# End of macro CALLMONITOR
285f					endif 
285f c3 28 28				jp .storebyteat 
2862					NEXTW 
2862 c3 87 22			jp macro_next 
2865				endm 
# End of macro NEXTW
2865			.SCALL: 
2865				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2865 23				db WORD_SYS_CORE+OPCODE_SCALL             
2866 99 28			dw .DEPTH            
2868 05				db 4 + 1 
2869 .. 00			db "CALL",0              
286e				endm 
# End of macro CWHEAD
286e			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
286e					if DEBUG_FORTH_WORDS_KEY 
286e						DMARK "CLL" 
286e f5				push af  
286f 3a 83 28			ld a, (.dmark)  
2872 32 6e fe			ld (debug_mark),a  
2875 3a 84 28			ld a, (.dmark+1)  
2878 32 6f fe			ld (debug_mark+1),a  
287b 3a 85 28			ld a, (.dmark+2)  
287e 32 70 fe			ld (debug_mark+2),a  
2881 18 03			jr .pastdmark  
2883 ..			.dmark: db "CLL"  
2886 f1			.pastdmark: pop af  
2887			endm  
# End of macro DMARK
2887						CALLMONITOR 
2887 cd a5 18			call break_point_state  
288a				endm  
# End of macro CALLMONITOR
288a					endif 
288a			 
288a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
288a cd 10 21			call macro_dsp_valuehl 
288d				endm 
# End of macro FORTH_DSP_VALUEHL
288d			 
288d			;		push hl 
288d			 
288d					; destroy value TOS 
288d			 
288d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
288d cd c8 21			call macro_forth_dsp_pop 
2890				endm 
# End of macro FORTH_DSP_POP
2890			 
2890						 
2890			;		pop hl 
2890			 
2890					; how to do a call with hl???? save SP? 
2890 cd 2b 22				call forth_call_hl 
2893			 
2893			 
2893					; TODO push value back onto stack for another op etc 
2893			 
2893 cd 19 1f				call forth_push_numhl 
2896					NEXTW 
2896 c3 87 22			jp macro_next 
2899				endm 
# End of macro NEXTW
2899			.DEPTH: 
2899				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2899 24				db WORD_SYS_CORE+OPCODE_DEPTH             
289a d6 28			dw .OVER            
289c 06				db 5 + 1 
289d .. 00			db "DEPTH",0              
28a3				endm 
# End of macro CWHEAD
28a3			; | DEPTH ( -- u ) Push count of stack | DONE 
28a3					; take current TOS and remove from base value div by two to get count 
28a3					if DEBUG_FORTH_WORDS_KEY 
28a3						DMARK "DEP" 
28a3 f5				push af  
28a4 3a b8 28			ld a, (.dmark)  
28a7 32 6e fe			ld (debug_mark),a  
28aa 3a b9 28			ld a, (.dmark+1)  
28ad 32 6f fe			ld (debug_mark+1),a  
28b0 3a ba 28			ld a, (.dmark+2)  
28b3 32 70 fe			ld (debug_mark+2),a  
28b6 18 03			jr .pastdmark  
28b8 ..			.dmark: db "DEP"  
28bb f1			.pastdmark: pop af  
28bc			endm  
# End of macro DMARK
28bc						CALLMONITOR 
28bc cd a5 18			call break_point_state  
28bf				endm  
# End of macro CALLMONITOR
28bf					endif 
28bf			 
28bf			 
28bf 2a 2c fa			ld hl, (cli_data_sp) 
28c2 11 66 f7			ld de, cli_data_stack 
28c5 ed 52			sbc hl,de 
28c7				 
28c7				; div by size of stack item 
28c7			 
28c7 5d				ld e,l 
28c8 0e 03			ld c, 3 
28ca cd 8e 0e			call Div8 
28cd			 
28cd 6f				ld l,a 
28ce 26 00			ld h,0 
28d0			 
28d0				;srl h 
28d0				;rr l 
28d0			 
28d0 cd 19 1f				call forth_push_numhl 
28d3					NEXTW 
28d3 c3 87 22			jp macro_next 
28d6				endm 
# End of macro NEXTW
28d6			.OVER: 
28d6				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
28d6 42				db WORD_SYS_CORE+46             
28d7 1d 29			dw .PAUSE            
28d9 05				db 4 + 1 
28da .. 00			db "OVER",0              
28df				endm 
# End of macro CWHEAD
28df			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
28df					if DEBUG_FORTH_WORDS_KEY 
28df						DMARK "OVR" 
28df f5				push af  
28e0 3a f4 28			ld a, (.dmark)  
28e3 32 6e fe			ld (debug_mark),a  
28e6 3a f5 28			ld a, (.dmark+1)  
28e9 32 6f fe			ld (debug_mark+1),a  
28ec 3a f6 28			ld a, (.dmark+2)  
28ef 32 70 fe			ld (debug_mark+2),a  
28f2 18 03			jr .pastdmark  
28f4 ..			.dmark: db "OVR"  
28f7 f1			.pastdmark: pop af  
28f8			endm  
# End of macro DMARK
28f8						CALLMONITOR 
28f8 cd a5 18			call break_point_state  
28fb				endm  
# End of macro CALLMONITOR
28fb					endif 
28fb			 
28fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28fb cd 10 21			call macro_dsp_valuehl 
28fe				endm 
# End of macro FORTH_DSP_VALUEHL
28fe e5					push hl    ; n2 
28ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28ff cd c8 21			call macro_forth_dsp_pop 
2902				endm 
# End of macro FORTH_DSP_POP
2902			 
2902					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2902 cd 10 21			call macro_dsp_valuehl 
2905				endm 
# End of macro FORTH_DSP_VALUEHL
2905 e5					push hl    ; n1 
2906					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2906 cd c8 21			call macro_forth_dsp_pop 
2909				endm 
# End of macro FORTH_DSP_POP
2909			 
2909 d1					pop de     ; n1 
290a e1					pop hl     ; n2 
290b			 
290b d5					push de 
290c e5					push hl 
290d d5					push de 
290e			 
290e					; push back  
290e			 
290e e1					pop hl 
290f cd 19 1f				call forth_push_numhl 
2912 e1					pop hl 
2913 cd 19 1f				call forth_push_numhl 
2916 e1					pop hl 
2917 cd 19 1f				call forth_push_numhl 
291a					NEXTW 
291a c3 87 22			jp macro_next 
291d				endm 
# End of macro NEXTW
291d			 
291d			.PAUSE: 
291d				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
291d 43				db WORD_SYS_CORE+47             
291e 52 29			dw .PAUSES            
2920 08				db 7 + 1 
2921 .. 00			db "PAUSEMS",0              
2929				endm 
# End of macro CWHEAD
2929			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2929					if DEBUG_FORTH_WORDS_KEY 
2929						DMARK "PMS" 
2929 f5				push af  
292a 3a 3e 29			ld a, (.dmark)  
292d 32 6e fe			ld (debug_mark),a  
2930 3a 3f 29			ld a, (.dmark+1)  
2933 32 6f fe			ld (debug_mark+1),a  
2936 3a 40 29			ld a, (.dmark+2)  
2939 32 70 fe			ld (debug_mark+2),a  
293c 18 03			jr .pastdmark  
293e ..			.dmark: db "PMS"  
2941 f1			.pastdmark: pop af  
2942			endm  
# End of macro DMARK
2942						CALLMONITOR 
2942 cd a5 18			call break_point_state  
2945				endm  
# End of macro CALLMONITOR
2945					endif 
2945					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2945 cd 10 21			call macro_dsp_valuehl 
2948				endm 
# End of macro FORTH_DSP_VALUEHL
2948			;		push hl    ; n2 
2948					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2948 cd c8 21			call macro_forth_dsp_pop 
294b				endm 
# End of macro FORTH_DSP_POP
294b			;		pop hl 
294b			 
294b 7d					ld a, l 
294c cd 2c 0c				call aDelayInMS 
294f				       NEXTW 
294f c3 87 22			jp macro_next 
2952				endm 
# End of macro NEXTW
2952			.PAUSES:  
2952				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2952 44				db WORD_SYS_CORE+48             
2953 c1 29			dw .ROT            
2955 06				db 5 + 1 
2956 .. 00			db "PAUSE",0              
295c				endm 
# End of macro CWHEAD
295c			; | PAUSE ( n -- )  Pause for n seconds | DONE 
295c					if DEBUG_FORTH_WORDS_KEY 
295c						DMARK "PAU" 
295c f5				push af  
295d 3a 71 29			ld a, (.dmark)  
2960 32 6e fe			ld (debug_mark),a  
2963 3a 72 29			ld a, (.dmark+1)  
2966 32 6f fe			ld (debug_mark+1),a  
2969 3a 73 29			ld a, (.dmark+2)  
296c 32 70 fe			ld (debug_mark+2),a  
296f 18 03			jr .pastdmark  
2971 ..			.dmark: db "PAU"  
2974 f1			.pastdmark: pop af  
2975			endm  
# End of macro DMARK
2975						CALLMONITOR 
2975 cd a5 18			call break_point_state  
2978				endm  
# End of macro CALLMONITOR
2978					endif 
2978					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2978 cd 10 21			call macro_dsp_valuehl 
297b				endm 
# End of macro FORTH_DSP_VALUEHL
297b			;		push hl    ; n2 
297b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
297b cd c8 21			call macro_forth_dsp_pop 
297e				endm 
# End of macro FORTH_DSP_POP
297e			;		pop hl 
297e 45					ld b, l 
297f					if DEBUG_FORTH_WORDS 
297f						DMARK "PAU" 
297f f5				push af  
2980 3a 94 29			ld a, (.dmark)  
2983 32 6e fe			ld (debug_mark),a  
2986 3a 95 29			ld a, (.dmark+1)  
2989 32 6f fe			ld (debug_mark+1),a  
298c 3a 96 29			ld a, (.dmark+2)  
298f 32 70 fe			ld (debug_mark+2),a  
2992 18 03			jr .pastdmark  
2994 ..			.dmark: db "PAU"  
2997 f1			.pastdmark: pop af  
2998			endm  
# End of macro DMARK
2998						CALLMONITOR 
2998 cd a5 18			call break_point_state  
299b				endm  
# End of macro CALLMONITOR
299b					endif 
299b c5			.pauses1:	push bc 
299c cd 47 0c				call delay1s 
299f c1					pop bc 
29a0					if DEBUG_FORTH_WORDS 
29a0						DMARK "PA1" 
29a0 f5				push af  
29a1 3a b5 29			ld a, (.dmark)  
29a4 32 6e fe			ld (debug_mark),a  
29a7 3a b6 29			ld a, (.dmark+1)  
29aa 32 6f fe			ld (debug_mark+1),a  
29ad 3a b7 29			ld a, (.dmark+2)  
29b0 32 70 fe			ld (debug_mark+2),a  
29b3 18 03			jr .pastdmark  
29b5 ..			.dmark: db "PA1"  
29b8 f1			.pastdmark: pop af  
29b9			endm  
# End of macro DMARK
29b9						CALLMONITOR 
29b9 cd a5 18			call break_point_state  
29bc				endm  
# End of macro CALLMONITOR
29bc					endif 
29bc 10 dd				djnz .pauses1 
29be			 
29be				       NEXTW 
29be c3 87 22			jp macro_next 
29c1				endm 
# End of macro NEXTW
29c1			.ROT: 
29c1				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
29c1 45				db WORD_SYS_CORE+49             
29c2 0f 2a			dw .UWORDS            
29c4 04				db 3 + 1 
29c5 .. 00			db "ROT",0              
29c9				endm 
# End of macro CWHEAD
29c9			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
29c9					if DEBUG_FORTH_WORDS_KEY 
29c9						DMARK "ROT" 
29c9 f5				push af  
29ca 3a de 29			ld a, (.dmark)  
29cd 32 6e fe			ld (debug_mark),a  
29d0 3a df 29			ld a, (.dmark+1)  
29d3 32 6f fe			ld (debug_mark+1),a  
29d6 3a e0 29			ld a, (.dmark+2)  
29d9 32 70 fe			ld (debug_mark+2),a  
29dc 18 03			jr .pastdmark  
29de ..			.dmark: db "ROT"  
29e1 f1			.pastdmark: pop af  
29e2			endm  
# End of macro DMARK
29e2						CALLMONITOR 
29e2 cd a5 18			call break_point_state  
29e5				endm  
# End of macro CALLMONITOR
29e5					endif 
29e5			 
29e5					FORTH_DSP_VALUEHL 
29e5 cd 10 21			call macro_dsp_valuehl 
29e8				endm 
# End of macro FORTH_DSP_VALUEHL
29e8 e5					push hl    ; u3  
29e9			 
29e9					FORTH_DSP_POP 
29e9 cd c8 21			call macro_forth_dsp_pop 
29ec				endm 
# End of macro FORTH_DSP_POP
29ec			   
29ec					FORTH_DSP_VALUEHL 
29ec cd 10 21			call macro_dsp_valuehl 
29ef				endm 
# End of macro FORTH_DSP_VALUEHL
29ef e5					push hl     ; u2 
29f0			 
29f0					FORTH_DSP_POP 
29f0 cd c8 21			call macro_forth_dsp_pop 
29f3				endm 
# End of macro FORTH_DSP_POP
29f3			 
29f3					FORTH_DSP_VALUEHL 
29f3 cd 10 21			call macro_dsp_valuehl 
29f6				endm 
# End of macro FORTH_DSP_VALUEHL
29f6 e5					push hl     ; u1 
29f7			 
29f7					FORTH_DSP_POP 
29f7 cd c8 21			call macro_forth_dsp_pop 
29fa				endm 
# End of macro FORTH_DSP_POP
29fa			 
29fa c1					pop bc      ; u1 
29fb e1					pop hl      ; u2 
29fc d1					pop de      ; u3 
29fd			 
29fd			 
29fd c5					push bc 
29fe d5					push de 
29ff e5					push hl 
2a00			 
2a00			 
2a00 e1					pop hl 
2a01 cd 19 1f				call forth_push_numhl 
2a04			 
2a04 e1					pop hl 
2a05 cd 19 1f				call forth_push_numhl 
2a08			 
2a08 e1					pop hl 
2a09 cd 19 1f				call forth_push_numhl 
2a0c					 
2a0c			 
2a0c			 
2a0c			 
2a0c			 
2a0c			 
2a0c				       NEXTW 
2a0c c3 87 22			jp macro_next 
2a0f				endm 
# End of macro NEXTW
2a0f			 
2a0f			.UWORDS: 
2a0f				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a0f 50				db WORD_SYS_CORE+60             
2a10 d1 2a			dw .BP            
2a12 07				db 6 + 1 
2a13 .. 00			db "UWORDS",0              
2a1a				endm 
# End of macro CWHEAD
2a1a			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2a1a			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2a1a			; | | Following the count are the individual words. 
2a1a			; | | 
2a1a			; | | e.g. UWORDS 
2a1a			; | | BOX DIRLIST 2 
2a1a			; | |  
2a1a			; | | Can be used to save the words to storage via: 
2a1a			; | | UWORDS $01 DO $01 APPEND LOOP 
2a1a				if DEBUG_FORTH_WORDS_KEY 
2a1a					DMARK "UWR" 
2a1a f5				push af  
2a1b 3a 2f 2a			ld a, (.dmark)  
2a1e 32 6e fe			ld (debug_mark),a  
2a21 3a 30 2a			ld a, (.dmark+1)  
2a24 32 6f fe			ld (debug_mark+1),a  
2a27 3a 31 2a			ld a, (.dmark+2)  
2a2a 32 70 fe			ld (debug_mark+2),a  
2a2d 18 03			jr .pastdmark  
2a2f ..			.dmark: db "UWR"  
2a32 f1			.pastdmark: pop af  
2a33			endm  
# End of macro DMARK
2a33					CALLMONITOR 
2a33 cd a5 18			call break_point_state  
2a36				endm  
# End of macro CALLMONITOR
2a36				endif 
2a36 21 00 80				ld hl, baseram 
2a39					;ld hl, baseusermem 
2a39 01 00 00				ld bc, 0    ; start a counter 
2a3c			 
2a3c				; skip dict stub 
2a3c			 
2a3c cd d8 23				call forth_tok_next 
2a3f			 
2a3f			 
2a3f			; while we have words to look for 
2a3f			 
2a3f 7e			.douscan:	ld a, (hl)      
2a40				if DEBUG_FORTH_WORDS 
2a40					DMARK "UWs" 
2a40 f5				push af  
2a41 3a 55 2a			ld a, (.dmark)  
2a44 32 6e fe			ld (debug_mark),a  
2a47 3a 56 2a			ld a, (.dmark+1)  
2a4a 32 6f fe			ld (debug_mark+1),a  
2a4d 3a 57 2a			ld a, (.dmark+2)  
2a50 32 70 fe			ld (debug_mark+2),a  
2a53 18 03			jr .pastdmark  
2a55 ..			.dmark: db "UWs"  
2a58 f1			.pastdmark: pop af  
2a59			endm  
# End of macro DMARK
2a59					CALLMONITOR 
2a59 cd a5 18			call break_point_state  
2a5c				endm  
# End of macro CALLMONITOR
2a5c				endif 
2a5c fe 00				cp WORD_SYS_END 
2a5e 28 4d				jr z, .udone 
2a60 fe 01				cp WORD_SYS_UWORD 
2a62 20 44				jr nz, .nuword 
2a64			 
2a64				if DEBUG_FORTH_WORDS 
2a64					DMARK "UWu" 
2a64 f5				push af  
2a65 3a 79 2a			ld a, (.dmark)  
2a68 32 6e fe			ld (debug_mark),a  
2a6b 3a 7a 2a			ld a, (.dmark+1)  
2a6e 32 6f fe			ld (debug_mark+1),a  
2a71 3a 7b 2a			ld a, (.dmark+2)  
2a74 32 70 fe			ld (debug_mark+2),a  
2a77 18 03			jr .pastdmark  
2a79 ..			.dmark: db "UWu"  
2a7c f1			.pastdmark: pop af  
2a7d			endm  
# End of macro DMARK
2a7d					CALLMONITOR 
2a7d cd a5 18			call break_point_state  
2a80				endm  
# End of macro CALLMONITOR
2a80				endif 
2a80					; we have a uword so push its name to the stack 
2a80			 
2a80 e5				   	push hl  ; save so we can move to next dict block 
2a81			 
2a81					; skip opcode 
2a81 23					inc hl  
2a82					; skip next ptr 
2a82 23					inc hl  
2a83 23					inc hl 
2a84					; skip len 
2a84 23					inc hl 
2a85				if DEBUG_FORTH_WORDS 
2a85					DMARK "UWt" 
2a85 f5				push af  
2a86 3a 9a 2a			ld a, (.dmark)  
2a89 32 6e fe			ld (debug_mark),a  
2a8c 3a 9b 2a			ld a, (.dmark+1)  
2a8f 32 6f fe			ld (debug_mark+1),a  
2a92 3a 9c 2a			ld a, (.dmark+2)  
2a95 32 70 fe			ld (debug_mark+2),a  
2a98 18 03			jr .pastdmark  
2a9a ..			.dmark: db "UWt"  
2a9d f1			.pastdmark: pop af  
2a9e			endm  
# End of macro DMARK
2a9e					CALLMONITOR 
2a9e cd a5 18			call break_point_state  
2aa1				endm  
# End of macro CALLMONITOR
2aa1				endif 
2aa1 03					inc bc 
2aa2			 
2aa2 c5					push bc 
2aa3 cd 87 1f				call forth_push_str 
2aa6 c1					pop bc 
2aa7			 
2aa7 e1					pop hl 	 
2aa8			 
2aa8 cd d8 23		.nuword:	call forth_tok_next 
2aab 18 92				jr .douscan  
2aad			 
2aad			.udone:		 ; push count of uwords found 
2aad c5					push bc 
2aae e1					pop hl 
2aaf			 
2aaf				if DEBUG_FORTH_WORDS 
2aaf					DMARK "UWc" 
2aaf f5				push af  
2ab0 3a c4 2a			ld a, (.dmark)  
2ab3 32 6e fe			ld (debug_mark),a  
2ab6 3a c5 2a			ld a, (.dmark+1)  
2ab9 32 6f fe			ld (debug_mark+1),a  
2abc 3a c6 2a			ld a, (.dmark+2)  
2abf 32 70 fe			ld (debug_mark+2),a  
2ac2 18 03			jr .pastdmark  
2ac4 ..			.dmark: db "UWc"  
2ac7 f1			.pastdmark: pop af  
2ac8			endm  
# End of macro DMARK
2ac8					CALLMONITOR 
2ac8 cd a5 18			call break_point_state  
2acb				endm  
# End of macro CALLMONITOR
2acb				endif 
2acb cd 19 1f				call forth_push_numhl 
2ace			 
2ace			 
2ace				       NEXTW 
2ace c3 87 22			jp macro_next 
2ad1				endm 
# End of macro NEXTW
2ad1			 
2ad1			.BP: 
2ad1				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2ad1 54				db WORD_SYS_CORE+64             
2ad2 07 2b			dw .MONITOR            
2ad4 03				db 2 + 1 
2ad5 .. 00			db "BP",0              
2ad8				endm 
# End of macro CWHEAD
2ad8			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2ad8			; | | $00 Will enable the break points within specific code paths 
2ad8			; | | $01 Will disable break points 
2ad8			; | |  
2ad8			; | | By default break points are off. Either the above can be used to enable them 
2ad8			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2ad8			; | | and on release of the pressed key a message will be disaplayed to notify 
2ad8			; | | that break points are enabled. Pressing any key will then continue boot process. 
2ad8					; get byte count 
2ad8					if DEBUG_FORTH_WORDS_KEY 
2ad8						DMARK "BP." 
2ad8 f5				push af  
2ad9 3a ed 2a			ld a, (.dmark)  
2adc 32 6e fe			ld (debug_mark),a  
2adf 3a ee 2a			ld a, (.dmark+1)  
2ae2 32 6f fe			ld (debug_mark+1),a  
2ae5 3a ef 2a			ld a, (.dmark+2)  
2ae8 32 70 fe			ld (debug_mark+2),a  
2aeb 18 03			jr .pastdmark  
2aed ..			.dmark: db "BP."  
2af0 f1			.pastdmark: pop af  
2af1			endm  
# End of macro DMARK
2af1						CALLMONITOR 
2af1 cd a5 18			call break_point_state  
2af4				endm  
# End of macro CALLMONITOR
2af4					endif 
2af4			 
2af4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2af4 cd 10 21			call macro_dsp_valuehl 
2af7				endm 
# End of macro FORTH_DSP_VALUEHL
2af7			 
2af7			;		push hl 
2af7			 
2af7					; destroy value TOS 
2af7			 
2af7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2af7 cd c8 21			call macro_forth_dsp_pop 
2afa				endm 
# End of macro FORTH_DSP_POP
2afa			 
2afa			;		pop hl 
2afa			 
2afa 3e 00				ld a,0 
2afc bd					cp l 
2afd 28 02				jr z, .bpset 
2aff 3e 2a				ld a, '*' 
2b01			 
2b01 32 f0 f1		.bpset:		ld (os_view_disable), a 
2b04			 
2b04			 
2b04					NEXTW 
2b04 c3 87 22			jp macro_next 
2b07				endm 
# End of macro NEXTW
2b07			 
2b07			 
2b07			.MONITOR: 
2b07				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b07 55				db WORD_SYS_CORE+65             
2b08 3a 2b			dw .MALLOC            
2b0a 08				db 7 + 1 
2b0b .. 00			db "MONITOR",0              
2b13				endm 
# End of macro CWHEAD
2b13			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2b13			; | | At start the current various registers will be displayed with contents. 
2b13			; | | Top right corner will show the most recent debug marker seen. 
2b13			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2b13			; | | and the return stack pointer (RSP). 
2b13			; | | Pressing: 
2b13			; | |    1 - Initial screen 
2b13			; | |    2 - Display a data dump of HL 
2b13			; | |    3 - Display a data dump of DE 
2b13			; | |    4 - Display a data dump of BC 
2b13			; | |    5 - Display a data dump of HL 
2b13			; | |    6 - Display a data dump of DSP 
2b13			; | |    7 - Display a data dump of RSP 
2b13			; | |    8 - Display a data dump of what is at DSP 
2b13			; | |    9 - Display a data dump of what is at RSP 
2b13			; | |    0 - Exit monitor and continue running. This will also enable break points 
2b13			; | |    * - Disable break points 
2b13			; | |    # - Enter traditional monitor mode 
2b13			; | | 
2b13			; | | Monitor Mode 
2b13			; | | ------------ 
2b13			; | | A prompt of '>' will be shown for various commands: 
2b13			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2b13			; | |    C - Continue display a data dump from the last set address 
2b13			; | |    M xxxx - Set start of memory edit at address xx 
2b13			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2b13			; | |    Q - Return to previous 
2b13					if DEBUG_FORTH_WORDS_KEY 
2b13						DMARK "MON" 
2b13 f5				push af  
2b14 3a 28 2b			ld a, (.dmark)  
2b17 32 6e fe			ld (debug_mark),a  
2b1a 3a 29 2b			ld a, (.dmark+1)  
2b1d 32 6f fe			ld (debug_mark+1),a  
2b20 3a 2a 2b			ld a, (.dmark+2)  
2b23 32 70 fe			ld (debug_mark+2),a  
2b26 18 03			jr .pastdmark  
2b28 ..			.dmark: db "MON"  
2b2b f1			.pastdmark: pop af  
2b2c			endm  
# End of macro DMARK
2b2c						CALLMONITOR 
2b2c cd a5 18			call break_point_state  
2b2f				endm  
# End of macro CALLMONITOR
2b2f					endif 
2b2f 3e 00				ld a, 0 
2b31 32 f0 f1				ld (os_view_disable), a 
2b34			 
2b34					CALLMONITOR 
2b34 cd a5 18			call break_point_state  
2b37				endm  
# End of macro CALLMONITOR
2b37			 
2b37			;	call monitor 
2b37			 
2b37					NEXTW 
2b37 c3 87 22			jp macro_next 
2b3a				endm 
# End of macro NEXTW
2b3a			 
2b3a			 
2b3a			.MALLOC: 
2b3a				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b3a 56				db WORD_SYS_CORE+66             
2b3b 63 2b			dw .MALLOC2            
2b3d 06				db 5 + 1 
2b3e .. 00			db "ALLOT",0              
2b44				endm 
# End of macro CWHEAD
2b44			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b44					if DEBUG_FORTH_WORDS_KEY 
2b44						DMARK "ALL" 
2b44 f5				push af  
2b45 3a 59 2b			ld a, (.dmark)  
2b48 32 6e fe			ld (debug_mark),a  
2b4b 3a 5a 2b			ld a, (.dmark+1)  
2b4e 32 6f fe			ld (debug_mark+1),a  
2b51 3a 5b 2b			ld a, (.dmark+2)  
2b54 32 70 fe			ld (debug_mark+2),a  
2b57 18 03			jr .pastdmark  
2b59 ..			.dmark: db "ALL"  
2b5c f1			.pastdmark: pop af  
2b5d			endm  
# End of macro DMARK
2b5d						CALLMONITOR 
2b5d cd a5 18			call break_point_state  
2b60				endm  
# End of macro CALLMONITOR
2b60					endif 
2b60 c3 8a 2b				jp .mallocc 
2b63			.MALLOC2: 
2b63				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2b63 56				db WORD_SYS_CORE+66             
2b64 a1 2b			dw .FREE            
2b66 07				db 6 + 1 
2b67 .. 00			db "MALLOC",0              
2b6e				endm 
# End of macro CWHEAD
2b6e			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b6e					; get byte count 
2b6e					if DEBUG_FORTH_WORDS_KEY 
2b6e						DMARK "MAL" 
2b6e f5				push af  
2b6f 3a 83 2b			ld a, (.dmark)  
2b72 32 6e fe			ld (debug_mark),a  
2b75 3a 84 2b			ld a, (.dmark+1)  
2b78 32 6f fe			ld (debug_mark+1),a  
2b7b 3a 85 2b			ld a, (.dmark+2)  
2b7e 32 70 fe			ld (debug_mark+2),a  
2b81 18 03			jr .pastdmark  
2b83 ..			.dmark: db "MAL"  
2b86 f1			.pastdmark: pop af  
2b87			endm  
# End of macro DMARK
2b87						CALLMONITOR 
2b87 cd a5 18			call break_point_state  
2b8a				endm  
# End of macro CALLMONITOR
2b8a					endif 
2b8a			.mallocc: 
2b8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b8a cd 10 21			call macro_dsp_valuehl 
2b8d				endm 
# End of macro FORTH_DSP_VALUEHL
2b8d			 
2b8d			;		push hl 
2b8d			 
2b8d					; destroy value TOS 
2b8d			 
2b8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b8d cd c8 21			call macro_forth_dsp_pop 
2b90				endm 
# End of macro FORTH_DSP_POP
2b90			 
2b90			;		pop hl 
2b90 cd c5 13				call malloc 
2b93				if DEBUG_FORTH_MALLOC_GUARD 
2b93 f5					push af 
2b94 cd 27 0f				call ishlzero 
2b97			;		ld a, l 
2b97			;		add h 
2b97			;		cp 0 
2b97 f1					pop af 
2b98					 
2b98 cc 82 55				call z,malloc_error 
2b9b				endif 
2b9b			 
2b9b cd 19 1f				call forth_push_numhl 
2b9e					NEXTW 
2b9e c3 87 22			jp macro_next 
2ba1				endm 
# End of macro NEXTW
2ba1			 
2ba1			.FREE: 
2ba1				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2ba1 57				db WORD_SYS_CORE+67             
2ba2 d2 2b			dw .LIST            
2ba4 05				db 4 + 1 
2ba5 .. 00			db "FREE",0              
2baa				endm 
# End of macro CWHEAD
2baa			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2baa					if DEBUG_FORTH_WORDS_KEY 
2baa						DMARK "FRE" 
2baa f5				push af  
2bab 3a bf 2b			ld a, (.dmark)  
2bae 32 6e fe			ld (debug_mark),a  
2bb1 3a c0 2b			ld a, (.dmark+1)  
2bb4 32 6f fe			ld (debug_mark+1),a  
2bb7 3a c1 2b			ld a, (.dmark+2)  
2bba 32 70 fe			ld (debug_mark+2),a  
2bbd 18 03			jr .pastdmark  
2bbf ..			.dmark: db "FRE"  
2bc2 f1			.pastdmark: pop af  
2bc3			endm  
# End of macro DMARK
2bc3						CALLMONITOR 
2bc3 cd a5 18			call break_point_state  
2bc6				endm  
# End of macro CALLMONITOR
2bc6					endif 
2bc6					; get address 
2bc6			 
2bc6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bc6 cd 10 21			call macro_dsp_valuehl 
2bc9				endm 
# End of macro FORTH_DSP_VALUEHL
2bc9			 
2bc9			;		push hl 
2bc9			 
2bc9					; destroy value TOS 
2bc9			 
2bc9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bc9 cd c8 21			call macro_forth_dsp_pop 
2bcc				endm 
# End of macro FORTH_DSP_POP
2bcc			 
2bcc			;		pop hl 
2bcc			if FORTH_ENABLE_MALLOCFREE 
2bcc cd 8f 14				call free 
2bcf			endif 
2bcf					NEXTW 
2bcf c3 87 22			jp macro_next 
2bd2				endm 
# End of macro NEXTW
2bd2			.LIST: 
2bd2				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2bd2 5c				db WORD_SYS_CORE+72             
2bd3 c0 2d			dw .FORGET            
2bd5 05				db 4 + 1 
2bd6 .. 00			db "LIST",0              
2bdb				endm 
# End of macro CWHEAD
2bdb			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2bdb			; | | The quoted word must be in upper case. 
2bdb				if DEBUG_FORTH_WORDS_KEY 
2bdb					DMARK "LST" 
2bdb f5				push af  
2bdc 3a f0 2b			ld a, (.dmark)  
2bdf 32 6e fe			ld (debug_mark),a  
2be2 3a f1 2b			ld a, (.dmark+1)  
2be5 32 6f fe			ld (debug_mark+1),a  
2be8 3a f2 2b			ld a, (.dmark+2)  
2beb 32 70 fe			ld (debug_mark+2),a  
2bee 18 03			jr .pastdmark  
2bf0 ..			.dmark: db "LST"  
2bf3 f1			.pastdmark: pop af  
2bf4			endm  
# End of macro DMARK
2bf4					CALLMONITOR 
2bf4 cd a5 18			call break_point_state  
2bf7				endm  
# End of macro CALLMONITOR
2bf7				endif 
2bf7			 
2bf7					FORTH_DSP_VALUEHL 
2bf7 cd 10 21			call macro_dsp_valuehl 
2bfa				endm 
# End of macro FORTH_DSP_VALUEHL
2bfa			 
2bfa e5					push hl 
2bfb					FORTH_DSP_POP 
2bfb cd c8 21			call macro_forth_dsp_pop 
2bfe				endm 
# End of macro FORTH_DSP_POP
2bfe c1					pop bc 
2bff			 
2bff			; Start format of scratch string 
2bff			 
2bff 21 ff f1				ld hl, scratch 
2c02			 
2c02 3e 3a				ld a, ':' 
2c04 77					ld (hl),a 
2c05 23					inc hl 
2c06 3e 20				ld a, ' ' 
2c08 77					ld (hl), a 
2c09			 
2c09					; Get ptr to the word we need to look up 
2c09			 
2c09			;		FORTH_DSP_VALUEHL 
2c09					;v5 FORTH_DSP_VALUE 
2c09				; TODO type check 
2c09			;		inc hl    ; Skip type check  
2c09			;		push hl 
2c09			;		ex de, hl    ; put into DE 
2c09			 
2c09			 
2c09 21 00 80				ld hl, baseram 
2c0c					;ld hl, baseusermem 
2c0c			 
2c0c e5			push hl   ; sacreifical push 
2c0d			 
2c0d			.ldouscanm: 
2c0d e1				pop hl 
2c0e			.ldouscan: 
2c0e				if DEBUG_FORTH_WORDS 
2c0e					DMARK "LSs" 
2c0e f5				push af  
2c0f 3a 23 2c			ld a, (.dmark)  
2c12 32 6e fe			ld (debug_mark),a  
2c15 3a 24 2c			ld a, (.dmark+1)  
2c18 32 6f fe			ld (debug_mark+1),a  
2c1b 3a 25 2c			ld a, (.dmark+2)  
2c1e 32 70 fe			ld (debug_mark+2),a  
2c21 18 03			jr .pastdmark  
2c23 ..			.dmark: db "LSs"  
2c26 f1			.pastdmark: pop af  
2c27			endm  
# End of macro DMARK
2c27					CALLMONITOR 
2c27 cd a5 18			call break_point_state  
2c2a				endm  
# End of macro CALLMONITOR
2c2a				endif 
2c2a				; skip dict stub 
2c2a cd d8 23				call forth_tok_next 
2c2d			 
2c2d			 
2c2d			; while we have words to look for 
2c2d			 
2c2d 7e				ld a, (hl)      
2c2e				if DEBUG_FORTH_WORDS 
2c2e					DMARK "LSk" 
2c2e f5				push af  
2c2f 3a 43 2c			ld a, (.dmark)  
2c32 32 6e fe			ld (debug_mark),a  
2c35 3a 44 2c			ld a, (.dmark+1)  
2c38 32 6f fe			ld (debug_mark+1),a  
2c3b 3a 45 2c			ld a, (.dmark+2)  
2c3e 32 70 fe			ld (debug_mark+2),a  
2c41 18 03			jr .pastdmark  
2c43 ..			.dmark: db "LSk"  
2c46 f1			.pastdmark: pop af  
2c47			endm  
# End of macro DMARK
2c47					CALLMONITOR 
2c47 cd a5 18			call break_point_state  
2c4a				endm  
# End of macro CALLMONITOR
2c4a				endif 
2c4a					;cp WORD_SYS_END 
2c4a					;jp z, .lunotfound 
2c4a			 
2c4a					; if we hit non uwords then gone too far 
2c4a fe 01				cp WORD_SYS_UWORD 
2c4c c2 7c 2d				jp nz, .lunotfound 
2c4f			 
2c4f				if DEBUG_FORTH_WORDS 
2c4f					DMARK "LSu" 
2c4f f5				push af  
2c50 3a 64 2c			ld a, (.dmark)  
2c53 32 6e fe			ld (debug_mark),a  
2c56 3a 65 2c			ld a, (.dmark+1)  
2c59 32 6f fe			ld (debug_mark+1),a  
2c5c 3a 66 2c			ld a, (.dmark+2)  
2c5f 32 70 fe			ld (debug_mark+2),a  
2c62 18 03			jr .pastdmark  
2c64 ..			.dmark: db "LSu"  
2c67 f1			.pastdmark: pop af  
2c68			endm  
# End of macro DMARK
2c68					CALLMONITOR 
2c68 cd a5 18			call break_point_state  
2c6b				endm  
# End of macro CALLMONITOR
2c6b				endif 
2c6b			 
2c6b					; found a uword but is it the one we want... 
2c6b			 
2c6b c5					push bc     ; uword to find is on bc 
2c6c d1					pop de 
2c6d			 
2c6d e5					push hl  ; to save the ptr 
2c6e			 
2c6e					; skip opcode 
2c6e 23					inc hl  
2c6f					; skip next ptr 
2c6f 23					inc hl  
2c70 23					inc hl 
2c71					; skip len 
2c71 23					inc hl 
2c72			 
2c72				if DEBUG_FORTH_WORDS 
2c72					DMARK "LSc" 
2c72 f5				push af  
2c73 3a 87 2c			ld a, (.dmark)  
2c76 32 6e fe			ld (debug_mark),a  
2c79 3a 88 2c			ld a, (.dmark+1)  
2c7c 32 6f fe			ld (debug_mark+1),a  
2c7f 3a 89 2c			ld a, (.dmark+2)  
2c82 32 70 fe			ld (debug_mark+2),a  
2c85 18 03			jr .pastdmark  
2c87 ..			.dmark: db "LSc"  
2c8a f1			.pastdmark: pop af  
2c8b			endm  
# End of macro DMARK
2c8b					CALLMONITOR 
2c8b cd a5 18			call break_point_state  
2c8e				endm  
# End of macro CALLMONITOR
2c8e				endif 
2c8e cd 94 13				call strcmp 
2c91 c2 0d 2c				jp nz, .ldouscanm 
2c94				 
2c94			 
2c94			 
2c94					; we have a uword so push its name to the stack 
2c94			 
2c94			;	   	push hl  ; save so we can move to next dict block 
2c94 e1			pop hl 
2c95			 
2c95				if DEBUG_FORTH_WORDS 
2c95					DMARK "LSm" 
2c95 f5				push af  
2c96 3a aa 2c			ld a, (.dmark)  
2c99 32 6e fe			ld (debug_mark),a  
2c9c 3a ab 2c			ld a, (.dmark+1)  
2c9f 32 6f fe			ld (debug_mark+1),a  
2ca2 3a ac 2c			ld a, (.dmark+2)  
2ca5 32 70 fe			ld (debug_mark+2),a  
2ca8 18 03			jr .pastdmark  
2caa ..			.dmark: db "LSm"  
2cad f1			.pastdmark: pop af  
2cae			endm  
# End of macro DMARK
2cae					CALLMONITOR 
2cae cd a5 18			call break_point_state  
2cb1				endm  
# End of macro CALLMONITOR
2cb1				endif 
2cb1			 
2cb1					; skip opcode 
2cb1 23					inc hl  
2cb2					; skip next ptr 
2cb2 23					inc hl  
2cb3 23					inc hl 
2cb4					; skip len 
2cb4 7e					ld a, (hl)   ; save length to add 
2cb5				if DEBUG_FORTH_WORDS 
2cb5					DMARK "LS2" 
2cb5 f5				push af  
2cb6 3a ca 2c			ld a, (.dmark)  
2cb9 32 6e fe			ld (debug_mark),a  
2cbc 3a cb 2c			ld a, (.dmark+1)  
2cbf 32 6f fe			ld (debug_mark+1),a  
2cc2 3a cc 2c			ld a, (.dmark+2)  
2cc5 32 70 fe			ld (debug_mark+2),a  
2cc8 18 03			jr .pastdmark  
2cca ..			.dmark: db "LS2"  
2ccd f1			.pastdmark: pop af  
2cce			endm  
# End of macro DMARK
2cce					CALLMONITOR 
2cce cd a5 18			call break_point_state  
2cd1				endm  
# End of macro CALLMONITOR
2cd1				endif 
2cd1			 
2cd1					; save this location 
2cd1				 
2cd1 e5					push hl 
2cd2			 
2cd2 23					inc hl 
2cd3 11 01 f2				ld de, scratch+2 
2cd6 4f					ld c, a 
2cd7 06 00				ld b, 0 
2cd9			 
2cd9				if DEBUG_FORTH_WORDS 
2cd9					DMARK "LSn" 
2cd9 f5				push af  
2cda 3a ee 2c			ld a, (.dmark)  
2cdd 32 6e fe			ld (debug_mark),a  
2ce0 3a ef 2c			ld a, (.dmark+1)  
2ce3 32 6f fe			ld (debug_mark+1),a  
2ce6 3a f0 2c			ld a, (.dmark+2)  
2ce9 32 70 fe			ld (debug_mark+2),a  
2cec 18 03			jr .pastdmark  
2cee ..			.dmark: db "LSn"  
2cf1 f1			.pastdmark: pop af  
2cf2			endm  
# End of macro DMARK
2cf2					CALLMONITOR 
2cf2 cd a5 18			call break_point_state  
2cf5				endm  
# End of macro CALLMONITOR
2cf5				endif 
2cf5			 
2cf5					; copy uword name to scratch 
2cf5			 
2cf5 ed b0				ldir 
2cf7			 
2cf7 1b					dec de 
2cf8 3e 20				ld a, ' '    ; change null to space 
2cfa 12					ld (de), a 
2cfb			 
2cfb 13					inc de 
2cfc			 
2cfc d5					push de 
2cfd c1					pop bc     ; move scratch pointer to end of word name and save it 
2cfe			 
2cfe e1					pop hl 
2cff 7e					ld a, (hl) 
2d00					;inc hl 
2d00					; skip word string 
2d00 cd fe 0e				call addatohl 
2d03			 
2d03 23					inc hl 
2d04			 
2d04				if DEBUG_FORTH_WORDS 
2d04					DMARK "LS3" 
2d04 f5				push af  
2d05 3a 19 2d			ld a, (.dmark)  
2d08 32 6e fe			ld (debug_mark),a  
2d0b 3a 1a 2d			ld a, (.dmark+1)  
2d0e 32 6f fe			ld (debug_mark+1),a  
2d11 3a 1b 2d			ld a, (.dmark+2)  
2d14 32 70 fe			ld (debug_mark+2),a  
2d17 18 03			jr .pastdmark  
2d19 ..			.dmark: db "LS3"  
2d1c f1			.pastdmark: pop af  
2d1d			endm  
# End of macro DMARK
2d1d					CALLMONITOR 
2d1d cd a5 18			call break_point_state  
2d20				endm  
# End of macro CALLMONITOR
2d20				endif 
2d20					; should now be at the start of the machine code to setup the eval of the uword 
2d20					; now locate the ptr to the string defintion 
2d20			 
2d20					; skip ld hl, 
2d20					; then load the ptr 
2d20			; TODO use get from hl ptr 
2d20 23					inc hl 
2d21 5e					ld e, (hl) 
2d22 23					inc hl 
2d23 56					ld d, (hl) 
2d24 eb					ex de, hl 
2d25			 
2d25			 
2d25				if DEBUG_FORTH_WORDS 
2d25					DMARK "LSt" 
2d25 f5				push af  
2d26 3a 3a 2d			ld a, (.dmark)  
2d29 32 6e fe			ld (debug_mark),a  
2d2c 3a 3b 2d			ld a, (.dmark+1)  
2d2f 32 6f fe			ld (debug_mark+1),a  
2d32 3a 3c 2d			ld a, (.dmark+2)  
2d35 32 70 fe			ld (debug_mark+2),a  
2d38 18 03			jr .pastdmark  
2d3a ..			.dmark: db "LSt"  
2d3d f1			.pastdmark: pop af  
2d3e			endm  
# End of macro DMARK
2d3e					CALLMONITOR 
2d3e cd a5 18			call break_point_state  
2d41				endm  
# End of macro CALLMONITOR
2d41				endif 
2d41			 
2d41			; cant push right now due to tokenised strings  
2d41			 
2d41			; get the destination of where to copy this definition to. 
2d41			 
2d41 c5					push bc 
2d42 d1					pop de 
2d43			 
2d43 7e			.listl:         ld a,(hl) 
2d44 fe 00				cp 0 
2d46 28 09				jr z, .lreplsp     ; replace zero with space 
2d48					;cp FORTH_END_BUFFER 
2d48 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2d4a 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2d4c				 
2d4c					; just copy this char as is then 
2d4c			 
2d4c 12					ld (de), a 
2d4d			 
2d4d 23			.listnxt:	inc hl 
2d4e 13					inc de 
2d4f 18 f2				jr .listl 
2d51			 
2d51 3e 20		.lreplsp:	ld a,' ' 
2d53 12					ld (de), a 
2d54 18 f7				jr .listnxt 
2d56			 
2d56			; close up uword def 
2d56			 
2d56			.listdone: 
2d56 12					ld (de), a 
2d57 13					inc de 
2d58 3e 00				ld a, 0 
2d5a 12					ld (de), a 
2d5b			 
2d5b			; now have def so clean up and push to stack 
2d5b			 
2d5b 21 ff f1				ld hl, scratch 
2d5e				if DEBUG_FORTH_WORDS 
2d5e					DMARK "Ltp" 
2d5e f5				push af  
2d5f 3a 73 2d			ld a, (.dmark)  
2d62 32 6e fe			ld (debug_mark),a  
2d65 3a 74 2d			ld a, (.dmark+1)  
2d68 32 6f fe			ld (debug_mark+1),a  
2d6b 3a 75 2d			ld a, (.dmark+2)  
2d6e 32 70 fe			ld (debug_mark+2),a  
2d71 18 03			jr .pastdmark  
2d73 ..			.dmark: db "Ltp"  
2d76 f1			.pastdmark: pop af  
2d77			endm  
# End of macro DMARK
2d77					CALLMONITOR 
2d77 cd a5 18			call break_point_state  
2d7a				endm  
# End of macro CALLMONITOR
2d7a				endif 
2d7a			 
2d7a 18 1f			jr .listpush 
2d7c			 
2d7c			;.lnuword:	pop hl 
2d7c			;		call forth_tok_next 
2d7c			;		jp .ldouscan  
2d7c			 
2d7c			.lunotfound:		  
2d7c			 
2d7c				if DEBUG_FORTH_WORDS 
2d7c					DMARK "LSn" 
2d7c f5				push af  
2d7d 3a 91 2d			ld a, (.dmark)  
2d80 32 6e fe			ld (debug_mark),a  
2d83 3a 92 2d			ld a, (.dmark+1)  
2d86 32 6f fe			ld (debug_mark+1),a  
2d89 3a 93 2d			ld a, (.dmark+2)  
2d8c 32 70 fe			ld (debug_mark+2),a  
2d8f 18 03			jr .pastdmark  
2d91 ..			.dmark: db "LSn"  
2d94 f1			.pastdmark: pop af  
2d95			endm  
# End of macro DMARK
2d95					CALLMONITOR 
2d95 cd a5 18			call break_point_state  
2d98				endm  
# End of macro CALLMONITOR
2d98				endif 
2d98			 
2d98					 
2d98			;		FORTH_DSP_POP 
2d98			;		ld hl, .luno 
2d98			 
2d98					NEXTW			 
2d98 c3 87 22			jp macro_next 
2d9b				endm 
# End of macro NEXTW
2d9b			 
2d9b			.listpush: 
2d9b				if DEBUG_FORTH_WORDS 
2d9b					DMARK "LS>" 
2d9b f5				push af  
2d9c 3a b0 2d			ld a, (.dmark)  
2d9f 32 6e fe			ld (debug_mark),a  
2da2 3a b1 2d			ld a, (.dmark+1)  
2da5 32 6f fe			ld (debug_mark+1),a  
2da8 3a b2 2d			ld a, (.dmark+2)  
2dab 32 70 fe			ld (debug_mark+2),a  
2dae 18 03			jr .pastdmark  
2db0 ..			.dmark: db "LS>"  
2db3 f1			.pastdmark: pop af  
2db4			endm  
# End of macro DMARK
2db4					CALLMONITOR 
2db4 cd a5 18			call break_point_state  
2db7				endm  
# End of macro CALLMONITOR
2db7				endif 
2db7 cd 87 1f				call forth_push_str 
2dba			 
2dba			 
2dba			 
2dba					NEXTW 
2dba c3 87 22			jp macro_next 
2dbd				endm 
# End of macro NEXTW
2dbd			 
2dbd			;.luno:    db "Word not found",0 
2dbd			 
2dbd			 
2dbd			 
2dbd			 
2dbd			 
2dbd			;		push hl   ; save pointer to start of uword def string 
2dbd			; 
2dbd			;; look for FORTH_EOL_LINE 
2dbd			;		ld a, FORTH_END_BUFFER 
2dbd			;		call strlent 
2dbd			; 
2dbd			;		inc hl		 ; space for coln def 
2dbd			;		inc hl 
2dbd			;		inc hl          ; space for terms 
2dbd			;		inc hl 
2dbd			; 
2dbd			;		ld a, 20   ; TODO get actual length 
2dbd			;		call addatohl    ; include a random amount of room for the uword name 
2dbd			; 
2dbd			;		 
2dbd			;	if DEBUG_FORTH_WORDS 
2dbd			;		DMARK "Lt1" 
2dbd			;		CALLMONITOR 
2dbd			;	endif 
2dbd			;		 
2dbd			; 
2dbd			;; malloc space for the string because we cant change it 
2dbd			; 
2dbd			;		call malloc 
2dbd			;	if DEBUG_FORTH_MALLOC_GUARD 
2dbd			;		push af 
2dbd			;		call ishlzero 
2dbd			;		pop af 
2dbd			;		 
2dbd			;		call z,malloc_error 
2dbd			;	endif 
2dbd			; 
2dbd			;	if DEBUG_FORTH_WORDS 
2dbd			;		DMARK "Lt2" 
2dbd			;		CALLMONITOR 
2dbd			;	endif 
2dbd			;		pop de 
2dbd			;		push hl    ; push the malloc to release later 
2dbd			;		push hl   ;  push back a copy for the later stack push 
2dbd			;		 
2dbd			;; copy the string swapping out the zero terms for spaces 
2dbd			; 
2dbd			;		; de has our source 
2dbd			;		; hl has our dest 
2dbd			; 
2dbd			;; add the coln def 
2dbd			; 
2dbd			;		ld a, ':' 
2dbd			;		ld (hl), a 
2dbd			;		inc hl 
2dbd			;		ld a, ' ' 
2dbd			;		ld (hl), a 
2dbd			;		inc hl 
2dbd			; 
2dbd			;; add the uname word 
2dbd			;		push de   ; save our string for now 
2dbd			;		ex de, hl 
2dbd			; 
2dbd			;		FORTH_DSP_VALUE 
2dbd			;		;v5 FORTH_DSP_VALUE 
2dbd			; 
2dbd			;		inc hl   ; skip type but we know by now this is OK 
2dbd			; 
2dbd			;.luword:	ld a,(hl) 
2dbd			;		cp 0 
2dbd			;		jr z, .luword2 
2dbd			;		ld (de), a 
2dbd			;		inc de 
2dbd			;		inc hl 
2dbd			;		jr .luword 
2dbd			; 
2dbd			;.luword2:	ld a, ' ' 
2dbd			;		ld (de), a 
2dbd			;;		inc hl 
2dbd			;;		inc de 
2dbd			;;		ld (de), a 
2dbd			;;		inc hl 
2dbd			;		inc de 
2dbd			; 
2dbd			;		ex de, hl 
2dbd			;		pop de 
2dbd			;		 
2dbd			;		 
2dbd			; 
2dbd			;; detoken that string and copy it 
2dbd			; 
2dbd			;	if DEBUG_FORTH_WORDS 
2dbd			;		DMARK "Lt2" 
2dbd			;		CALLMONITOR 
2dbd			;	endif 
2dbd			;.ldetok:	ld a, (de) 
2dbd			;		cp FORTH_END_BUFFER 
2dbd			;		jr z, .ldetokend 
2dbd			;		; swap out any zero term for space 
2dbd			;		cp 0 
2dbd			;		jr nz, .ldetoknext 
2dbd			;		ld a, ' ' 
2dbd			; 
2dbd			;	if DEBUG_FORTH_WORDS 
2dbd			;		DMARK "LtS" 
2dbd			;		CALLMONITOR 
2dbd			;	endif 
2dbd			;.ldetoknext:	ld (hl), a 
2dbd			;		inc de 
2dbd			;		inc hl 
2dbd			;		jr .ldetok 
2dbd			; 
2dbd			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2dbd			;		ld (hl), a  
2dbd			; 
2dbd			;; free that temp malloc 
2dbd			; 
2dbd			;		pop hl    
2dbd			; 
2dbd			;	if DEBUG_FORTH_WORDS 
2dbd			;		DMARK "Lt4" 
2dbd			;		CALLMONITOR 
2dbd			;	endif 
2dbd			;		call forth_apushstrhl 
2dbd			; 
2dbd			;		; get rid of temp malloc area 
2dbd			; 
2dbd			;		pop hl 
2dbd			;		call free 
2dbd			; 
2dbd			;		jr .ludone 
2dbd			; 
2dbd			;.lnuword:	pop hl 
2dbd			;		call forth_tok_next 
2dbd			;		jp .ldouscan  
2dbd			; 
2dbd			;.ludone:		 pop hl 
2dbd			; 
2dbd					NEXTW 
2dbd c3 87 22			jp macro_next 
2dc0				endm 
# End of macro NEXTW
2dc0			 
2dc0			.FORGET: 
2dc0				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2dc0 5d				db WORD_SYS_CORE+73             
2dc1 39 2e			dw .NOP            
2dc3 07				db 6 + 1 
2dc4 .. 00			db "FORGET",0              
2dcb				endm 
# End of macro CWHEAD
2dcb			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2dcb			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2dcb			; | |  
2dcb			; | | e.g. "MORE" forget 
2dcb					if DEBUG_FORTH_WORDS_KEY 
2dcb						DMARK "FRG" 
2dcb f5				push af  
2dcc 3a e0 2d			ld a, (.dmark)  
2dcf 32 6e fe			ld (debug_mark),a  
2dd2 3a e1 2d			ld a, (.dmark+1)  
2dd5 32 6f fe			ld (debug_mark+1),a  
2dd8 3a e2 2d			ld a, (.dmark+2)  
2ddb 32 70 fe			ld (debug_mark+2),a  
2dde 18 03			jr .pastdmark  
2de0 ..			.dmark: db "FRG"  
2de3 f1			.pastdmark: pop af  
2de4			endm  
# End of macro DMARK
2de4						CALLMONITOR 
2de4 cd a5 18			call break_point_state  
2de7				endm  
# End of macro CALLMONITOR
2de7					endif 
2de7			 
2de7				; find uword 
2de7			        ; update start of word with "_" 
2de7				; replace uword with deleted flag 
2de7			 
2de7			 
2de7			;	if DEBUG_FORTH_WORDS 
2de7			;		DMARK "FOG" 
2de7			;		CALLMONITOR 
2de7			;	endif 
2de7			 
2de7			 
2de7					; Get ptr to the word we need to look up 
2de7			 
2de7					FORTH_DSP_VALUEHL 
2de7 cd 10 21			call macro_dsp_valuehl 
2dea				endm 
# End of macro FORTH_DSP_VALUEHL
2dea					;v5 FORTH_DSP_VALUE 
2dea				; TODO type check 
2dea			;		inc hl    ; Skip type check  
2dea e5					push hl 
2deb c1					pop bc 
2dec			;		ex de, hl    ; put into DE 
2dec			 
2dec			 
2dec 21 00 80				ld hl, baseram 
2def					;ld hl, baseusermem 
2def			 
2def				; skip dict stub 
2def			;	call forth_tok_next 
2def e5			push hl   ; sacreifical push 
2df0			 
2df0			.fldouscanm: 
2df0 e1				pop hl 
2df1			.fldouscan: 
2df1			;	if DEBUG_FORTH_WORDS 
2df1			;		DMARK "LSs" 
2df1			;		CALLMONITOR 
2df1			;	endif 
2df1				; skip dict stub 
2df1 cd d8 23				call forth_tok_next 
2df4			 
2df4			 
2df4			; while we have words to look for 
2df4			 
2df4 7e				ld a, (hl)      
2df5			;	if DEBUG_FORTH_WORDS 
2df5			;		DMARK "LSk" 
2df5			;		CALLMONITOR 
2df5			;	endif 
2df5 fe 00				cp WORD_SYS_END 
2df7 ca 33 2e				jp z, .flunotfound 
2dfa fe 01				cp WORD_SYS_UWORD 
2dfc c2 f1 2d				jp nz, .fldouscan 
2dff			 
2dff			;	if DEBUG_FORTH_WORDS 
2dff			;		DMARK "LSu" 
2dff			;		CALLMONITOR 
2dff			;	endif 
2dff			 
2dff					; found a uword but is it the one we want... 
2dff			 
2dff c5					push bc     ; uword to find is on bc 
2e00 d1					pop de 
2e01			 
2e01 e5					push hl  ; to save the ptr 
2e02			 
2e02					; skip opcode 
2e02 23					inc hl  
2e03					; skip next ptr 
2e03 23					inc hl  
2e04 23					inc hl 
2e05					; skip len 
2e05 23					inc hl 
2e06			 
2e06			;	if DEBUG_FORTH_WORDS 
2e06			;		DMARK "LSc" 
2e06			;		CALLMONITOR 
2e06			;	endif 
2e06 cd 94 13				call strcmp 
2e09 c2 f0 2d				jp nz, .fldouscanm 
2e0c			; 
2e0c			; 
2e0c			;; while we have words to look for 
2e0c			; 
2e0c			;.fdouscan:	ld a, (hl)      
2e0c			;	if DEBUG_FORTH_WORDS 
2e0c			;		DMARK "LSs" 
2e0c			;		CALLMONITOR 
2e0c			;	endif 
2e0c			;		cp WORD_SYS_END 
2e0c			;		jp z, .fudone 
2e0c			;		cp WORD_SYS_UWORD 
2e0c			;		jp nz, .fnuword 
2e0c			; 
2e0c			;	if DEBUG_FORTH_WORDS 
2e0c			;		DMARK "FGu" 
2e0c			;		CALLMONITOR 
2e0c			;	endif 
2e0c			; 
2e0c			;		; found a uword but is it the one we want... 
2e0c			; 
2e0c			; 
2e0c			;	        pop de   ; get back the dsp name 
2e0c			;		push de 
2e0c			; 
2e0c			;		push hl  ; to save the ptr 
2e0c			; 
2e0c			;		; skip opcode 
2e0c			;		inc hl  
2e0c			;		; skip next ptr 
2e0c			;		inc hl  
2e0c			;		inc hl 
2e0c			;		; skip len 
2e0c			;		inc hl 
2e0c			; 
2e0c			;	if DEBUG_FORTH_WORDS 
2e0c			;		DMARK "FGc" 
2e0c			;		CALLMONITOR 
2e0c			;	endif 
2e0c			;		call strcmp 
2e0c			;		jp nz, .fnuword 
2e0c			 
2e0c			 
2e0c e1			pop hl 
2e0d			 
2e0d				 
2e0d				if DEBUG_FORTH_WORDS 
2e0d					DMARK "FGm" 
2e0d f5				push af  
2e0e 3a 22 2e			ld a, (.dmark)  
2e11 32 6e fe			ld (debug_mark),a  
2e14 3a 23 2e			ld a, (.dmark+1)  
2e17 32 6f fe			ld (debug_mark+1),a  
2e1a 3a 24 2e			ld a, (.dmark+2)  
2e1d 32 70 fe			ld (debug_mark+2),a  
2e20 18 03			jr .pastdmark  
2e22 ..			.dmark: db "FGm"  
2e25 f1			.pastdmark: pop af  
2e26			endm  
# End of macro DMARK
2e26					CALLMONITOR 
2e26 cd a5 18			call break_point_state  
2e29				endm  
# End of macro CALLMONITOR
2e29				endif 
2e29			 
2e29			 
2e29			 
2e29					; we have a uword so push its name to the stack 
2e29			 
2e29			;	   	push hl  ; save so we can move to next dict block 
2e29			;pop hl 
2e29			 
2e29					; update opcode to deleted 
2e29 3e 03				ld a, WORD_SYS_DELETED 
2e2b 77					ld (hl), a 
2e2c			 
2e2c 23					inc hl  
2e2d					; skip next ptr 
2e2d 23					inc hl  
2e2e 23					inc hl 
2e2f					; skip len 
2e2f 23					inc hl 
2e30			 
2e30					; TODO change parser to skip deleted words but for now mark it out 
2e30 3e 5f				ld a, "_" 
2e32 77					ld  (hl),a 
2e33			 
2e33			;		jr .fudone 
2e33			; 
2e33			;.fnuword:	pop hl 
2e33			;		call forth_tok_next 
2e33			;		jp .fdouscan  
2e33			 
2e33			.flunotfound:		  
2e33			 
2e33			 
2e33					 
2e33					FORTH_DSP_POP 
2e33 cd c8 21			call macro_forth_dsp_pop 
2e36				endm 
# End of macro FORTH_DSP_POP
2e36			;		ld hl, .luno 
2e36			;.fudone:		 pop hl 
2e36					NEXTW 
2e36 c3 87 22			jp macro_next 
2e39				endm 
# End of macro NEXTW
2e39			.NOP: 
2e39				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e39 61				db WORD_SYS_CORE+77             
2e3a 60 2e			dw .COMO            
2e3c 04				db 3 + 1 
2e3d .. 00			db "NOP",0              
2e41				endm 
# End of macro CWHEAD
2e41			; | NOP (  --  ) Do nothing | DONE 
2e41					if DEBUG_FORTH_WORDS_KEY 
2e41						DMARK "NOP" 
2e41 f5				push af  
2e42 3a 56 2e			ld a, (.dmark)  
2e45 32 6e fe			ld (debug_mark),a  
2e48 3a 57 2e			ld a, (.dmark+1)  
2e4b 32 6f fe			ld (debug_mark+1),a  
2e4e 3a 58 2e			ld a, (.dmark+2)  
2e51 32 70 fe			ld (debug_mark+2),a  
2e54 18 03			jr .pastdmark  
2e56 ..			.dmark: db "NOP"  
2e59 f1			.pastdmark: pop af  
2e5a			endm  
# End of macro DMARK
2e5a						CALLMONITOR 
2e5a cd a5 18			call break_point_state  
2e5d				endm  
# End of macro CALLMONITOR
2e5d					endif 
2e5d				       NEXTW 
2e5d c3 87 22			jp macro_next 
2e60				endm 
# End of macro NEXTW
2e60			.COMO: 
2e60				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2e60 6e				db WORD_SYS_CORE+90             
2e61 b2 2e			dw .COMC            
2e63 02				db 1 + 1 
2e64 .. 00			db "(",0              
2e66				endm 
# End of macro CWHEAD
2e66			; | ( ( -- )  Start of comment | DONE 
2e66			 
2e66			 
2e66 2a 00 f5				ld hl, ( os_tok_ptr) 
2e69 11 ad 2e			ld de, .closepar 
2e6c					 
2e6c					if DEBUG_FORTH_WORDS 
2e6c						DMARK ").." 
2e6c f5				push af  
2e6d 3a 81 2e			ld a, (.dmark)  
2e70 32 6e fe			ld (debug_mark),a  
2e73 3a 82 2e			ld a, (.dmark+1)  
2e76 32 6f fe			ld (debug_mark+1),a  
2e79 3a 83 2e			ld a, (.dmark+2)  
2e7c 32 70 fe			ld (debug_mark+2),a  
2e7f 18 03			jr .pastdmark  
2e81 ..			.dmark: db ").."  
2e84 f1			.pastdmark: pop af  
2e85			endm  
# End of macro DMARK
2e85						CALLMONITOR 
2e85 cd a5 18			call break_point_state  
2e88				endm  
# End of macro CALLMONITOR
2e88					endif 
2e88 cd a2 23			call findnexttok  
2e8b			 
2e8b					if DEBUG_FORTH_WORDS 
2e8b						DMARK "IF5" 
2e8b f5				push af  
2e8c 3a a0 2e			ld a, (.dmark)  
2e8f 32 6e fe			ld (debug_mark),a  
2e92 3a a1 2e			ld a, (.dmark+1)  
2e95 32 6f fe			ld (debug_mark+1),a  
2e98 3a a2 2e			ld a, (.dmark+2)  
2e9b 32 70 fe			ld (debug_mark+2),a  
2e9e 18 03			jr .pastdmark  
2ea0 ..			.dmark: db "IF5"  
2ea3 f1			.pastdmark: pop af  
2ea4			endm  
# End of macro DMARK
2ea4						CALLMONITOR 
2ea4 cd a5 18			call break_point_state  
2ea7				endm  
# End of macro CALLMONITOR
2ea7					endif 
2ea7				; replace below with ) exec using tok_ptr 
2ea7 22 00 f5			ld (os_tok_ptr), hl 
2eaa c3 18 23			jp exec1 
2ead			 
2ead .. 00			.closepar:   db ")",0 
2eaf			 
2eaf				       NEXTW 
2eaf c3 87 22			jp macro_next 
2eb2				endm 
# End of macro NEXTW
2eb2			.COMC: 
2eb2				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2eb2 6f				db WORD_SYS_CORE+91             
2eb3 bb 2e			dw .SCRATCH            
2eb5 02				db 1 + 1 
2eb6 .. 00			db ")",0              
2eb8				endm 
# End of macro CWHEAD
2eb8			; | ) ( -- )  End of comment |  DONE  
2eb8				       NEXTW 
2eb8 c3 87 22			jp macro_next 
2ebb				endm 
# End of macro NEXTW
2ebb			 
2ebb			.SCRATCH: 
2ebb				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2ebb 6f				db WORD_SYS_CORE+91             
2ebc f6 2e			dw .INC            
2ebe 08				db 7 + 1 
2ebf .. 00			db "SCRATCH",0              
2ec7				endm 
# End of macro CWHEAD
2ec7			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2ec7			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2ec7			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2ec7			; | |  
2ec7			; | | e.g.    : score $00 scratch ; 
2ec7			; | |  
2ec7			; | | $00 score ! 
2ec7			; | | $01 score +! 
2ec7			; | |  
2ec7			; | | e.g.   : varword $0a scratch ;  
2ec7			; | | 
2ec7			; | | $8000 varword ! 
2ec7					if DEBUG_FORTH_WORDS_KEY 
2ec7						DMARK "SCR" 
2ec7 f5				push af  
2ec8 3a dc 2e			ld a, (.dmark)  
2ecb 32 6e fe			ld (debug_mark),a  
2ece 3a dd 2e			ld a, (.dmark+1)  
2ed1 32 6f fe			ld (debug_mark+1),a  
2ed4 3a de 2e			ld a, (.dmark+2)  
2ed7 32 70 fe			ld (debug_mark+2),a  
2eda 18 03			jr .pastdmark  
2edc ..			.dmark: db "SCR"  
2edf f1			.pastdmark: pop af  
2ee0			endm  
# End of macro DMARK
2ee0						CALLMONITOR 
2ee0 cd a5 18			call break_point_state  
2ee3				endm  
# End of macro CALLMONITOR
2ee3					endif 
2ee3			 
2ee3					FORTH_DSP_VALUEHL 
2ee3 cd 10 21			call macro_dsp_valuehl 
2ee6				endm 
# End of macro FORTH_DSP_VALUEHL
2ee6				 
2ee6					FORTH_DSP_POP 
2ee6 cd c8 21			call macro_forth_dsp_pop 
2ee9				endm 
# End of macro FORTH_DSP_POP
2ee9			 
2ee9 7d					ld a, l 
2eea 21 24 f7				ld hl, os_var_array 
2eed cd fe 0e				call addatohl 
2ef0			 
2ef0 cd 19 1f				call forth_push_numhl 
2ef3			 
2ef3				       NEXTW 
2ef3 c3 87 22			jp macro_next 
2ef6				endm 
# End of macro NEXTW
2ef6			 
2ef6			.INC: 
2ef6				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ef6 6f				db WORD_SYS_CORE+91             
2ef7 4a 2f			dw .DEC            
2ef9 03				db 2 + 1 
2efa .. 00			db "+!",0              
2efd				endm 
# End of macro CWHEAD
2efd			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2efd					if DEBUG_FORTH_WORDS_KEY 
2efd						DMARK "+s_" 
2efd f5				push af  
2efe 3a 12 2f			ld a, (.dmark)  
2f01 32 6e fe			ld (debug_mark),a  
2f04 3a 13 2f			ld a, (.dmark+1)  
2f07 32 6f fe			ld (debug_mark+1),a  
2f0a 3a 14 2f			ld a, (.dmark+2)  
2f0d 32 70 fe			ld (debug_mark+2),a  
2f10 18 03			jr .pastdmark  
2f12 ..			.dmark: db "+s_"  
2f15 f1			.pastdmark: pop af  
2f16			endm  
# End of macro DMARK
2f16						CALLMONITOR 
2f16 cd a5 18			call break_point_state  
2f19				endm  
# End of macro CALLMONITOR
2f19					endif 
2f19			 
2f19					FORTH_DSP_VALUEHL 
2f19 cd 10 21			call macro_dsp_valuehl 
2f1c				endm 
# End of macro FORTH_DSP_VALUEHL
2f1c			 
2f1c e5					push hl   ; save address 
2f1d			 
2f1d					FORTH_DSP_POP 
2f1d cd c8 21			call macro_forth_dsp_pop 
2f20				endm 
# End of macro FORTH_DSP_POP
2f20			 
2f20					FORTH_DSP_VALUEHL 
2f20 cd 10 21			call macro_dsp_valuehl 
2f23				endm 
# End of macro FORTH_DSP_VALUEHL
2f23			 
2f23					FORTH_DSP_POP 
2f23 cd c8 21			call macro_forth_dsp_pop 
2f26				endm 
# End of macro FORTH_DSP_POP
2f26			 
2f26					; hl contains value to add to byte at a 
2f26				 
2f26 eb					ex de, hl 
2f27			 
2f27 e1					pop hl 
2f28			 
2f28					if DEBUG_FORTH_WORDS 
2f28						DMARK "INC" 
2f28 f5				push af  
2f29 3a 3d 2f			ld a, (.dmark)  
2f2c 32 6e fe			ld (debug_mark),a  
2f2f 3a 3e 2f			ld a, (.dmark+1)  
2f32 32 6f fe			ld (debug_mark+1),a  
2f35 3a 3f 2f			ld a, (.dmark+2)  
2f38 32 70 fe			ld (debug_mark+2),a  
2f3b 18 03			jr .pastdmark  
2f3d ..			.dmark: db "INC"  
2f40 f1			.pastdmark: pop af  
2f41			endm  
# End of macro DMARK
2f41						CALLMONITOR 
2f41 cd a5 18			call break_point_state  
2f44				endm  
# End of macro CALLMONITOR
2f44					endif 
2f44			 
2f44 7e					ld a,(hl) 
2f45 83					add e 
2f46 77					ld (hl),a 
2f47			 
2f47			 
2f47			 
2f47				       NEXTW 
2f47 c3 87 22			jp macro_next 
2f4a				endm 
# End of macro NEXTW
2f4a			 
2f4a			.DEC: 
2f4a				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2f4a 6f				db WORD_SYS_CORE+91             
2f4b 9b 2f			dw .INC2            
2f4d 03				db 2 + 1 
2f4e .. 00			db "-!",0              
2f51				endm 
# End of macro CWHEAD
2f51			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2f51					if DEBUG_FORTH_WORDS_KEY 
2f51						DMARK "-s_" 
2f51 f5				push af  
2f52 3a 66 2f			ld a, (.dmark)  
2f55 32 6e fe			ld (debug_mark),a  
2f58 3a 67 2f			ld a, (.dmark+1)  
2f5b 32 6f fe			ld (debug_mark+1),a  
2f5e 3a 68 2f			ld a, (.dmark+2)  
2f61 32 70 fe			ld (debug_mark+2),a  
2f64 18 03			jr .pastdmark  
2f66 ..			.dmark: db "-s_"  
2f69 f1			.pastdmark: pop af  
2f6a			endm  
# End of macro DMARK
2f6a						CALLMONITOR 
2f6a cd a5 18			call break_point_state  
2f6d				endm  
# End of macro CALLMONITOR
2f6d					endif 
2f6d			 
2f6d					FORTH_DSP_VALUEHL 
2f6d cd 10 21			call macro_dsp_valuehl 
2f70				endm 
# End of macro FORTH_DSP_VALUEHL
2f70			 
2f70 e5					push hl   ; save address 
2f71			 
2f71					FORTH_DSP_POP 
2f71 cd c8 21			call macro_forth_dsp_pop 
2f74				endm 
# End of macro FORTH_DSP_POP
2f74			 
2f74					FORTH_DSP_VALUEHL 
2f74 cd 10 21			call macro_dsp_valuehl 
2f77				endm 
# End of macro FORTH_DSP_VALUEHL
2f77			 
2f77					; hl contains value to add to byte at a 
2f77				 
2f77 eb					ex de, hl 
2f78			 
2f78 e1					pop hl 
2f79			 
2f79					if DEBUG_FORTH_WORDS 
2f79						DMARK "DEC" 
2f79 f5				push af  
2f7a 3a 8e 2f			ld a, (.dmark)  
2f7d 32 6e fe			ld (debug_mark),a  
2f80 3a 8f 2f			ld a, (.dmark+1)  
2f83 32 6f fe			ld (debug_mark+1),a  
2f86 3a 90 2f			ld a, (.dmark+2)  
2f89 32 70 fe			ld (debug_mark+2),a  
2f8c 18 03			jr .pastdmark  
2f8e ..			.dmark: db "DEC"  
2f91 f1			.pastdmark: pop af  
2f92			endm  
# End of macro DMARK
2f92						CALLMONITOR 
2f92 cd a5 18			call break_point_state  
2f95				endm  
# End of macro CALLMONITOR
2f95					endif 
2f95			 
2f95 7e					ld a,(hl) 
2f96 93					sub e 
2f97 77					ld (hl),a 
2f98			 
2f98			 
2f98			 
2f98				       NEXTW 
2f98 c3 87 22			jp macro_next 
2f9b				endm 
# End of macro NEXTW
2f9b			 
2f9b			.INC2: 
2f9b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f9b 6f				db WORD_SYS_CORE+91             
2f9c 45 30			dw .DEC2            
2f9e 04				db 3 + 1 
2f9f .. 00			db "+2!",0              
2fa3				endm 
# End of macro CWHEAD
2fa3			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2fa3			 
2fa3					if DEBUG_FORTH_WORDS_KEY 
2fa3						DMARK "+2s" 
2fa3 f5				push af  
2fa4 3a b8 2f			ld a, (.dmark)  
2fa7 32 6e fe			ld (debug_mark),a  
2faa 3a b9 2f			ld a, (.dmark+1)  
2fad 32 6f fe			ld (debug_mark+1),a  
2fb0 3a ba 2f			ld a, (.dmark+2)  
2fb3 32 70 fe			ld (debug_mark+2),a  
2fb6 18 03			jr .pastdmark  
2fb8 ..			.dmark: db "+2s"  
2fbb f1			.pastdmark: pop af  
2fbc			endm  
# End of macro DMARK
2fbc						CALLMONITOR 
2fbc cd a5 18			call break_point_state  
2fbf				endm  
# End of macro CALLMONITOR
2fbf					endif 
2fbf			 
2fbf					; Address 
2fbf			 
2fbf					FORTH_DSP_VALUEHL 
2fbf cd 10 21			call macro_dsp_valuehl 
2fc2				endm 
# End of macro FORTH_DSP_VALUEHL
2fc2			 
2fc2 e5					push hl    ; save address 
2fc3			 
2fc3					; load content into de 
2fc3			 
2fc3 5e					ld e,(hl) 
2fc4 23					inc hl 
2fc5 56					ld d, (hl) 
2fc6			 
2fc6					if DEBUG_FORTH_WORDS 
2fc6						DMARK "+2a" 
2fc6 f5				push af  
2fc7 3a db 2f			ld a, (.dmark)  
2fca 32 6e fe			ld (debug_mark),a  
2fcd 3a dc 2f			ld a, (.dmark+1)  
2fd0 32 6f fe			ld (debug_mark+1),a  
2fd3 3a dd 2f			ld a, (.dmark+2)  
2fd6 32 70 fe			ld (debug_mark+2),a  
2fd9 18 03			jr .pastdmark  
2fdb ..			.dmark: db "+2a"  
2fde f1			.pastdmark: pop af  
2fdf			endm  
# End of macro DMARK
2fdf						CALLMONITOR 
2fdf cd a5 18			call break_point_state  
2fe2				endm  
# End of macro CALLMONITOR
2fe2					endif 
2fe2			 
2fe2					FORTH_DSP_POP 
2fe2 cd c8 21			call macro_forth_dsp_pop 
2fe5				endm 
# End of macro FORTH_DSP_POP
2fe5			 
2fe5					; Get value to add 
2fe5			 
2fe5					FORTH_DSP_VALUE 
2fe5 cd f9 20			call macro_forth_dsp_value 
2fe8				endm 
# End of macro FORTH_DSP_VALUE
2fe8			 
2fe8					if DEBUG_FORTH_WORDS 
2fe8						DMARK "+2v" 
2fe8 f5				push af  
2fe9 3a fd 2f			ld a, (.dmark)  
2fec 32 6e fe			ld (debug_mark),a  
2fef 3a fe 2f			ld a, (.dmark+1)  
2ff2 32 6f fe			ld (debug_mark+1),a  
2ff5 3a ff 2f			ld a, (.dmark+2)  
2ff8 32 70 fe			ld (debug_mark+2),a  
2ffb 18 03			jr .pastdmark  
2ffd ..			.dmark: db "+2v"  
3000 f1			.pastdmark: pop af  
3001			endm  
# End of macro DMARK
3001						CALLMONITOR 
3001 cd a5 18			call break_point_state  
3004				endm  
# End of macro CALLMONITOR
3004					endif 
3004			 
3004 19					add hl, de 
3005			 
3005					if DEBUG_FORTH_WORDS 
3005						DMARK "+2+" 
3005 f5				push af  
3006 3a 1a 30			ld a, (.dmark)  
3009 32 6e fe			ld (debug_mark),a  
300c 3a 1b 30			ld a, (.dmark+1)  
300f 32 6f fe			ld (debug_mark+1),a  
3012 3a 1c 30			ld a, (.dmark+2)  
3015 32 70 fe			ld (debug_mark+2),a  
3018 18 03			jr .pastdmark  
301a ..			.dmark: db "+2+"  
301d f1			.pastdmark: pop af  
301e			endm  
# End of macro DMARK
301e						CALLMONITOR 
301e cd a5 18			call break_point_state  
3021				endm  
# End of macro CALLMONITOR
3021					endif 
3021			 
3021					; move result to de 
3021			 
3021 eb					ex de, hl 
3022			 
3022					; Address 
3022			 
3022 e1					pop hl 
3023			 
3023					; save it back 
3023			 
3023 73					ld (hl), e 
3024 23					inc hl 
3025 72					ld (hl), d 
3026			 
3026					if DEBUG_FORTH_WORDS 
3026						DMARK "+2e" 
3026 f5				push af  
3027 3a 3b 30			ld a, (.dmark)  
302a 32 6e fe			ld (debug_mark),a  
302d 3a 3c 30			ld a, (.dmark+1)  
3030 32 6f fe			ld (debug_mark+1),a  
3033 3a 3d 30			ld a, (.dmark+2)  
3036 32 70 fe			ld (debug_mark+2),a  
3039 18 03			jr .pastdmark  
303b ..			.dmark: db "+2e"  
303e f1			.pastdmark: pop af  
303f			endm  
# End of macro DMARK
303f						CALLMONITOR 
303f cd a5 18			call break_point_state  
3042				endm  
# End of macro CALLMONITOR
3042					endif 
3042			 
3042			 
3042			 
3042			 
3042			 
3042				       NEXTW 
3042 c3 87 22			jp macro_next 
3045				endm 
# End of macro NEXTW
3045			 
3045			.DEC2: 
3045				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3045 6f				db WORD_SYS_CORE+91             
3046 f1 30			dw .GET2            
3048 04				db 3 + 1 
3049 .. 00			db "-2!",0              
304d				endm 
# End of macro CWHEAD
304d			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
304d			 
304d			 
304d					if DEBUG_FORTH_WORDS_KEY 
304d						DMARK "-2s" 
304d f5				push af  
304e 3a 62 30			ld a, (.dmark)  
3051 32 6e fe			ld (debug_mark),a  
3054 3a 63 30			ld a, (.dmark+1)  
3057 32 6f fe			ld (debug_mark+1),a  
305a 3a 64 30			ld a, (.dmark+2)  
305d 32 70 fe			ld (debug_mark+2),a  
3060 18 03			jr .pastdmark  
3062 ..			.dmark: db "-2s"  
3065 f1			.pastdmark: pop af  
3066			endm  
# End of macro DMARK
3066						CALLMONITOR 
3066 cd a5 18			call break_point_state  
3069				endm  
# End of macro CALLMONITOR
3069					endif 
3069			 
3069					; Address 
3069			 
3069					FORTH_DSP_VALUEHL 
3069 cd 10 21			call macro_dsp_valuehl 
306c				endm 
# End of macro FORTH_DSP_VALUEHL
306c			 
306c e5					push hl    ; save address 
306d			 
306d					; load content into de 
306d			 
306d 5e					ld e,(hl) 
306e 23					inc hl 
306f 56					ld d, (hl) 
3070			 
3070					if DEBUG_FORTH_WORDS 
3070						DMARK "-2a" 
3070 f5				push af  
3071 3a 85 30			ld a, (.dmark)  
3074 32 6e fe			ld (debug_mark),a  
3077 3a 86 30			ld a, (.dmark+1)  
307a 32 6f fe			ld (debug_mark+1),a  
307d 3a 87 30			ld a, (.dmark+2)  
3080 32 70 fe			ld (debug_mark+2),a  
3083 18 03			jr .pastdmark  
3085 ..			.dmark: db "-2a"  
3088 f1			.pastdmark: pop af  
3089			endm  
# End of macro DMARK
3089						CALLMONITOR 
3089 cd a5 18			call break_point_state  
308c				endm  
# End of macro CALLMONITOR
308c					endif 
308c			 
308c					FORTH_DSP_POP 
308c cd c8 21			call macro_forth_dsp_pop 
308f				endm 
# End of macro FORTH_DSP_POP
308f			 
308f					; Get value to remove 
308f			 
308f					FORTH_DSP_VALUE 
308f cd f9 20			call macro_forth_dsp_value 
3092				endm 
# End of macro FORTH_DSP_VALUE
3092			 
3092					if DEBUG_FORTH_WORDS 
3092						DMARK "-2v" 
3092 f5				push af  
3093 3a a7 30			ld a, (.dmark)  
3096 32 6e fe			ld (debug_mark),a  
3099 3a a8 30			ld a, (.dmark+1)  
309c 32 6f fe			ld (debug_mark+1),a  
309f 3a a9 30			ld a, (.dmark+2)  
30a2 32 70 fe			ld (debug_mark+2),a  
30a5 18 03			jr .pastdmark  
30a7 ..			.dmark: db "-2v"  
30aa f1			.pastdmark: pop af  
30ab			endm  
# End of macro DMARK
30ab						CALLMONITOR 
30ab cd a5 18			call break_point_state  
30ae				endm  
# End of macro CALLMONITOR
30ae					endif 
30ae			 
30ae eb					ex de, hl 
30af ed 52				sbc hl, de 
30b1			 
30b1					if DEBUG_FORTH_WORDS 
30b1						DMARK "-2d" 
30b1 f5				push af  
30b2 3a c6 30			ld a, (.dmark)  
30b5 32 6e fe			ld (debug_mark),a  
30b8 3a c7 30			ld a, (.dmark+1)  
30bb 32 6f fe			ld (debug_mark+1),a  
30be 3a c8 30			ld a, (.dmark+2)  
30c1 32 70 fe			ld (debug_mark+2),a  
30c4 18 03			jr .pastdmark  
30c6 ..			.dmark: db "-2d"  
30c9 f1			.pastdmark: pop af  
30ca			endm  
# End of macro DMARK
30ca						CALLMONITOR 
30ca cd a5 18			call break_point_state  
30cd				endm  
# End of macro CALLMONITOR
30cd					endif 
30cd			 
30cd					; move result to de 
30cd			 
30cd eb					ex de, hl 
30ce			 
30ce					; Address 
30ce			 
30ce e1					pop hl 
30cf			 
30cf					; save it back 
30cf			 
30cf 73					ld (hl), e 
30d0 23					inc hl 
30d1 72					ld (hl), d 
30d2			 
30d2					if DEBUG_FORTH_WORDS 
30d2						DMARK "-2e" 
30d2 f5				push af  
30d3 3a e7 30			ld a, (.dmark)  
30d6 32 6e fe			ld (debug_mark),a  
30d9 3a e8 30			ld a, (.dmark+1)  
30dc 32 6f fe			ld (debug_mark+1),a  
30df 3a e9 30			ld a, (.dmark+2)  
30e2 32 70 fe			ld (debug_mark+2),a  
30e5 18 03			jr .pastdmark  
30e7 ..			.dmark: db "-2e"  
30ea f1			.pastdmark: pop af  
30eb			endm  
# End of macro DMARK
30eb						CALLMONITOR 
30eb cd a5 18			call break_point_state  
30ee				endm  
# End of macro CALLMONITOR
30ee					endif 
30ee			 
30ee			 
30ee			 
30ee			 
30ee			 
30ee				       NEXTW 
30ee c3 87 22			jp macro_next 
30f1				endm 
# End of macro NEXTW
30f1			.GET2: 
30f1				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
30f1 6f				db WORD_SYS_CORE+91             
30f2 21 31			dw .BANG2            
30f4 03				db 2 + 1 
30f5 .. 00			db "2@",0              
30f8				endm 
# End of macro CWHEAD
30f8			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
30f8					if DEBUG_FORTH_WORDS_KEY 
30f8						DMARK "2A_" 
30f8 f5				push af  
30f9 3a 0d 31			ld a, (.dmark)  
30fc 32 6e fe			ld (debug_mark),a  
30ff 3a 0e 31			ld a, (.dmark+1)  
3102 32 6f fe			ld (debug_mark+1),a  
3105 3a 0f 31			ld a, (.dmark+2)  
3108 32 70 fe			ld (debug_mark+2),a  
310b 18 03			jr .pastdmark  
310d ..			.dmark: db "2A_"  
3110 f1			.pastdmark: pop af  
3111			endm  
# End of macro DMARK
3111						CALLMONITOR 
3111 cd a5 18			call break_point_state  
3114				endm  
# End of macro CALLMONITOR
3114					endif 
3114			 
3114					FORTH_DSP_VALUEHL 
3114 cd 10 21			call macro_dsp_valuehl 
3117				endm 
# End of macro FORTH_DSP_VALUEHL
3117			 
3117 5e					ld e, (hl) 
3118 23					inc hl 
3119 56					ld d, (hl) 
311a			 
311a eb					ex de, hl 
311b			 
311b cd 19 1f				call forth_push_numhl 
311e			 
311e				       NEXTW 
311e c3 87 22			jp macro_next 
3121				endm 
# End of macro NEXTW
3121			.BANG2: 
3121				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3121 6f				db WORD_SYS_CORE+91             
3122 59 31			dw .CONFIG            
3124 03				db 2 + 1 
3125 .. 00			db "2!",0              
3128				endm 
# End of macro CWHEAD
3128			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3128					if DEBUG_FORTH_WORDS_KEY 
3128						DMARK "2S_" 
3128 f5				push af  
3129 3a 3d 31			ld a, (.dmark)  
312c 32 6e fe			ld (debug_mark),a  
312f 3a 3e 31			ld a, (.dmark+1)  
3132 32 6f fe			ld (debug_mark+1),a  
3135 3a 3f 31			ld a, (.dmark+2)  
3138 32 70 fe			ld (debug_mark+2),a  
313b 18 03			jr .pastdmark  
313d ..			.dmark: db "2S_"  
3140 f1			.pastdmark: pop af  
3141			endm  
# End of macro DMARK
3141						CALLMONITOR 
3141 cd a5 18			call break_point_state  
3144				endm  
# End of macro CALLMONITOR
3144					endif 
3144			 
3144					FORTH_DSP_VALUEHL 
3144 cd 10 21			call macro_dsp_valuehl 
3147				endm 
# End of macro FORTH_DSP_VALUEHL
3147			 
3147 e5					push hl   ; save address 
3148			 
3148			 
3148					FORTH_DSP_POP 
3148 cd c8 21			call macro_forth_dsp_pop 
314b				endm 
# End of macro FORTH_DSP_POP
314b			 
314b					 
314b					FORTH_DSP_VALUEHL 
314b cd 10 21			call macro_dsp_valuehl 
314e				endm 
# End of macro FORTH_DSP_VALUEHL
314e			 
314e					FORTH_DSP_POP 
314e cd c8 21			call macro_forth_dsp_pop 
3151				endm 
# End of macro FORTH_DSP_POP
3151			 
3151 eb					ex de, hl    ; value now in de 
3152			 
3152 e1					pop hl 
3153			 
3153 73					ld (hl), e 
3154			 
3154 23					inc hl 
3155			 
3155 72					ld (hl), d 
3156			 
3156			 
3156				       NEXTW 
3156 c3 87 22			jp macro_next 
3159				endm 
# End of macro NEXTW
3159			.CONFIG: 
3159				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
3159 6f				db WORD_SYS_CORE+91             
315a 6a 31			dw .ENDCORE            
315c 07				db 6 + 1 
315d .. 00			db "CONFIG",0              
3164				endm 
# End of macro CWHEAD
3164			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3164			 
3164 cd 88 15				call config 
3167					NEXTW 
3167 c3 87 22			jp macro_next 
316a				endm 
# End of macro NEXTW
316a			.ENDCORE: 
316a			 
316a			; eof 
316a			 
316a			 
# End of file forth_words_core.asm
316a			include "forth_words_flow.asm" 
316a			 
316a			; | ## Program Flow Words 
316a			 
316a			.IF: 
316a				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
316a 1e				db WORD_SYS_CORE+10             
316b 5f 32			dw .THEN            
316d 03				db 2 + 1 
316e .. 00			db "IF",0              
3171				endm 
# End of macro CWHEAD
3171			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3171			; 
3171					if DEBUG_FORTH_WORDS_KEY 
3171						DMARK "IF." 
3171 f5				push af  
3172 3a 86 31			ld a, (.dmark)  
3175 32 6e fe			ld (debug_mark),a  
3178 3a 87 31			ld a, (.dmark+1)  
317b 32 6f fe			ld (debug_mark+1),a  
317e 3a 88 31			ld a, (.dmark+2)  
3181 32 70 fe			ld (debug_mark+2),a  
3184 18 03			jr .pastdmark  
3186 ..			.dmark: db "IF."  
3189 f1			.pastdmark: pop af  
318a			endm  
# End of macro DMARK
318a						CALLMONITOR 
318a cd a5 18			call break_point_state  
318d				endm  
# End of macro CALLMONITOR
318d					endif 
318d			; eval TOS 
318d			 
318d				FORTH_DSP_VALUEHL 
318d cd 10 21			call macro_dsp_valuehl 
3190				endm 
# End of macro FORTH_DSP_VALUEHL
3190			 
3190			;	push hl 
3190				FORTH_DSP_POP 
3190 cd c8 21			call macro_forth_dsp_pop 
3193				endm 
# End of macro FORTH_DSP_POP
3193			;	pop hl 
3193			 
3193					if DEBUG_FORTH_WORDS 
3193						DMARK "IF1" 
3193 f5				push af  
3194 3a a8 31			ld a, (.dmark)  
3197 32 6e fe			ld (debug_mark),a  
319a 3a a9 31			ld a, (.dmark+1)  
319d 32 6f fe			ld (debug_mark+1),a  
31a0 3a aa 31			ld a, (.dmark+2)  
31a3 32 70 fe			ld (debug_mark+2),a  
31a6 18 03			jr .pastdmark  
31a8 ..			.dmark: db "IF1"  
31ab f1			.pastdmark: pop af  
31ac			endm  
# End of macro DMARK
31ac						CALLMONITOR 
31ac cd a5 18			call break_point_state  
31af				endm  
# End of macro CALLMONITOR
31af					endif 
31af b7				or a        ; clear carry flag 
31b0 11 00 00			ld de, 0 
31b3 eb				ex de,hl 
31b4 ed 52			sbc hl, de 
31b6 c2 40 32			jp nz, .iftrue 
31b9			 
31b9					if DEBUG_FORTH_WORDS 
31b9						DMARK "IF2" 
31b9 f5				push af  
31ba 3a ce 31			ld a, (.dmark)  
31bd 32 6e fe			ld (debug_mark),a  
31c0 3a cf 31			ld a, (.dmark+1)  
31c3 32 6f fe			ld (debug_mark+1),a  
31c6 3a d0 31			ld a, (.dmark+2)  
31c9 32 70 fe			ld (debug_mark+2),a  
31cc 18 03			jr .pastdmark  
31ce ..			.dmark: db "IF2"  
31d1 f1			.pastdmark: pop af  
31d2			endm  
# End of macro DMARK
31d2						CALLMONITOR 
31d2 cd a5 18			call break_point_state  
31d5				endm  
# End of macro CALLMONITOR
31d5					endif 
31d5			 
31d5			; if not true then skip to THEN 
31d5			 
31d5				; TODO get tok_ptr 
31d5				; TODO consume toks until we get to THEN 
31d5			 
31d5 2a 00 f5			ld hl, (os_tok_ptr) 
31d8					if DEBUG_FORTH_WORDS 
31d8						DMARK "IF3" 
31d8 f5				push af  
31d9 3a ed 31			ld a, (.dmark)  
31dc 32 6e fe			ld (debug_mark),a  
31df 3a ee 31			ld a, (.dmark+1)  
31e2 32 6f fe			ld (debug_mark+1),a  
31e5 3a ef 31			ld a, (.dmark+2)  
31e8 32 70 fe			ld (debug_mark+2),a  
31eb 18 03			jr .pastdmark  
31ed ..			.dmark: db "IF3"  
31f0 f1			.pastdmark: pop af  
31f1			endm  
# End of macro DMARK
31f1						CALLMONITOR 
31f1 cd a5 18			call break_point_state  
31f4				endm  
# End of macro CALLMONITOR
31f4						 
31f4					endif 
31f4 11 3b 32			ld de, .ifthen 
31f7					if DEBUG_FORTH_WORDS 
31f7						DMARK "IF4" 
31f7 f5				push af  
31f8 3a 0c 32			ld a, (.dmark)  
31fb 32 6e fe			ld (debug_mark),a  
31fe 3a 0d 32			ld a, (.dmark+1)  
3201 32 6f fe			ld (debug_mark+1),a  
3204 3a 0e 32			ld a, (.dmark+2)  
3207 32 70 fe			ld (debug_mark+2),a  
320a 18 03			jr .pastdmark  
320c ..			.dmark: db "IF4"  
320f f1			.pastdmark: pop af  
3210			endm  
# End of macro DMARK
3210						CALLMONITOR 
3210 cd a5 18			call break_point_state  
3213				endm  
# End of macro CALLMONITOR
3213					endif 
3213 cd a2 23			call findnexttok  
3216			 
3216					if DEBUG_FORTH_WORDS 
3216						DMARK "IF5" 
3216 f5				push af  
3217 3a 2b 32			ld a, (.dmark)  
321a 32 6e fe			ld (debug_mark),a  
321d 3a 2c 32			ld a, (.dmark+1)  
3220 32 6f fe			ld (debug_mark+1),a  
3223 3a 2d 32			ld a, (.dmark+2)  
3226 32 70 fe			ld (debug_mark+2),a  
3229 18 03			jr .pastdmark  
322b ..			.dmark: db "IF5"  
322e f1			.pastdmark: pop af  
322f			endm  
# End of macro DMARK
322f						CALLMONITOR 
322f cd a5 18			call break_point_state  
3232				endm  
# End of macro CALLMONITOR
3232					endif 
3232				; TODO replace below with ; exec using tok_ptr 
3232 22 00 f5			ld (os_tok_ptr), hl 
3235 c3 18 23			jp exec1 
3238				NEXTW 
3238 c3 87 22			jp macro_next 
323b				endm 
# End of macro NEXTW
323b			 
323b .. 00		.ifthen:  db "THEN",0 
3240			 
3240			.iftrue:		 
3240				; Exec next words normally 
3240			 
3240				; if true then exec following IF as normal 
3240					if DEBUG_FORTH_WORDS 
3240						DMARK "IFT" 
3240 f5				push af  
3241 3a 55 32			ld a, (.dmark)  
3244 32 6e fe			ld (debug_mark),a  
3247 3a 56 32			ld a, (.dmark+1)  
324a 32 6f fe			ld (debug_mark+1),a  
324d 3a 57 32			ld a, (.dmark+2)  
3250 32 70 fe			ld (debug_mark+2),a  
3253 18 03			jr .pastdmark  
3255 ..			.dmark: db "IFT"  
3258 f1			.pastdmark: pop af  
3259			endm  
# End of macro DMARK
3259						CALLMONITOR 
3259 cd a5 18			call break_point_state  
325c				endm  
# End of macro CALLMONITOR
325c					endif 
325c			 
325c					NEXTW 
325c c3 87 22			jp macro_next 
325f				endm 
# End of macro NEXTW
325f			.THEN: 
325f				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
325f 1f				db WORD_SYS_CORE+11             
3260 87 32			dw .ELSE            
3262 05				db 4 + 1 
3263 .. 00			db "THEN",0              
3268				endm 
# End of macro CWHEAD
3268			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3268					if DEBUG_FORTH_WORDS_KEY 
3268						DMARK "THN" 
3268 f5				push af  
3269 3a 7d 32			ld a, (.dmark)  
326c 32 6e fe			ld (debug_mark),a  
326f 3a 7e 32			ld a, (.dmark+1)  
3272 32 6f fe			ld (debug_mark+1),a  
3275 3a 7f 32			ld a, (.dmark+2)  
3278 32 70 fe			ld (debug_mark+2),a  
327b 18 03			jr .pastdmark  
327d ..			.dmark: db "THN"  
3280 f1			.pastdmark: pop af  
3281			endm  
# End of macro DMARK
3281						CALLMONITOR 
3281 cd a5 18			call break_point_state  
3284				endm  
# End of macro CALLMONITOR
3284					endif 
3284					NEXTW 
3284 c3 87 22			jp macro_next 
3287				endm 
# End of macro NEXTW
3287			.ELSE: 
3287				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3287 20				db WORD_SYS_CORE+12             
3288 af 32			dw .DO            
328a 03				db 2 + 1 
328b .. 00			db "ELSE",0              
3290				endm 
# End of macro CWHEAD
3290			; | ELSE ( -- ) Not supported - does nothing | TODO 
3290			 
3290					if DEBUG_FORTH_WORDS_KEY 
3290						DMARK "ELS" 
3290 f5				push af  
3291 3a a5 32			ld a, (.dmark)  
3294 32 6e fe			ld (debug_mark),a  
3297 3a a6 32			ld a, (.dmark+1)  
329a 32 6f fe			ld (debug_mark+1),a  
329d 3a a7 32			ld a, (.dmark+2)  
32a0 32 70 fe			ld (debug_mark+2),a  
32a3 18 03			jr .pastdmark  
32a5 ..			.dmark: db "ELS"  
32a8 f1			.pastdmark: pop af  
32a9			endm  
# End of macro DMARK
32a9						CALLMONITOR 
32a9 cd a5 18			call break_point_state  
32ac				endm  
# End of macro CALLMONITOR
32ac					endif 
32ac			 
32ac			 
32ac					NEXTW 
32ac c3 87 22			jp macro_next 
32af				endm 
# End of macro NEXTW
32af			.DO: 
32af				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
32af 21				db WORD_SYS_CORE+13             
32b0 d6 33			dw .LOOP            
32b2 03				db 2 + 1 
32b3 .. 00			db "DO",0              
32b6				endm 
# End of macro CWHEAD
32b6			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
32b6			 
32b6					if DEBUG_FORTH_WORDS_KEY 
32b6						DMARK "DO." 
32b6 f5				push af  
32b7 3a cb 32			ld a, (.dmark)  
32ba 32 6e fe			ld (debug_mark),a  
32bd 3a cc 32			ld a, (.dmark+1)  
32c0 32 6f fe			ld (debug_mark+1),a  
32c3 3a cd 32			ld a, (.dmark+2)  
32c6 32 70 fe			ld (debug_mark+2),a  
32c9 18 03			jr .pastdmark  
32cb ..			.dmark: db "DO."  
32ce f1			.pastdmark: pop af  
32cf			endm  
# End of macro DMARK
32cf						CALLMONITOR 
32cf cd a5 18			call break_point_state  
32d2				endm  
# End of macro CALLMONITOR
32d2					endif 
32d2			;  push pc to rsp stack past the DO 
32d2			 
32d2 2a 00 f5				ld hl, (os_tok_ptr) 
32d5 23					inc hl   ; D 
32d6 23					inc hl  ; O 
32d7 23					inc hl   ; null 
32d8					if DEBUG_FORTH_WORDS 
32d8						DMARK "DO2" 
32d8 f5				push af  
32d9 3a ed 32			ld a, (.dmark)  
32dc 32 6e fe			ld (debug_mark),a  
32df 3a ee 32			ld a, (.dmark+1)  
32e2 32 6f fe			ld (debug_mark+1),a  
32e5 3a ef 32			ld a, (.dmark+2)  
32e8 32 70 fe			ld (debug_mark+2),a  
32eb 18 03			jr .pastdmark  
32ed ..			.dmark: db "DO2"  
32f0 f1			.pastdmark: pop af  
32f1			endm  
# End of macro DMARK
32f1						CALLMONITOR 
32f1 cd a5 18			call break_point_state  
32f4				endm  
# End of macro CALLMONITOR
32f4					endif 
32f4					FORTH_RSP_NEXT 
32f4 cd c0 1e			call macro_forth_rsp_next 
32f7				endm 
# End of macro FORTH_RSP_NEXT
32f7					if DEBUG_FORTH_WORDS 
32f7						DMARK "DO3" 
32f7 f5				push af  
32f8 3a 0c 33			ld a, (.dmark)  
32fb 32 6e fe			ld (debug_mark),a  
32fe 3a 0d 33			ld a, (.dmark+1)  
3301 32 6f fe			ld (debug_mark+1),a  
3304 3a 0e 33			ld a, (.dmark+2)  
3307 32 70 fe			ld (debug_mark+2),a  
330a 18 03			jr .pastdmark  
330c ..			.dmark: db "DO3"  
330f f1			.pastdmark: pop af  
3310			endm  
# End of macro DMARK
3310						CALLMONITOR 
3310 cd a5 18			call break_point_state  
3313				endm  
# End of macro CALLMONITOR
3313					endif 
3313			 
3313					;if DEBUG_FORTH_WORDS 
3313				;		push hl 
3313			;		endif  
3313			 
3313			; get counters from data stack 
3313			 
3313			 
3313					FORTH_DSP_VALUEHL 
3313 cd 10 21			call macro_dsp_valuehl 
3316				endm 
# End of macro FORTH_DSP_VALUEHL
3316 e5					push hl		 ; hl now has starting counter which needs to be tos 
3317			 
3317					if DEBUG_FORTH_WORDS 
3317						DMARK "DO4" 
3317 f5				push af  
3318 3a 2c 33			ld a, (.dmark)  
331b 32 6e fe			ld (debug_mark),a  
331e 3a 2d 33			ld a, (.dmark+1)  
3321 32 6f fe			ld (debug_mark+1),a  
3324 3a 2e 33			ld a, (.dmark+2)  
3327 32 70 fe			ld (debug_mark+2),a  
332a 18 03			jr .pastdmark  
332c ..			.dmark: db "DO4"  
332f f1			.pastdmark: pop af  
3330			endm  
# End of macro DMARK
3330						CALLMONITOR 
3330 cd a5 18			call break_point_state  
3333				endm  
# End of macro CALLMONITOR
3333					endif 
3333					FORTH_DSP_POP 
3333 cd c8 21			call macro_forth_dsp_pop 
3336				endm 
# End of macro FORTH_DSP_POP
3336			 
3336					if DEBUG_FORTH_WORDS 
3336						DMARK "DO5" 
3336 f5				push af  
3337 3a 4b 33			ld a, (.dmark)  
333a 32 6e fe			ld (debug_mark),a  
333d 3a 4c 33			ld a, (.dmark+1)  
3340 32 6f fe			ld (debug_mark+1),a  
3343 3a 4d 33			ld a, (.dmark+2)  
3346 32 70 fe			ld (debug_mark+2),a  
3349 18 03			jr .pastdmark  
334b ..			.dmark: db "DO5"  
334e f1			.pastdmark: pop af  
334f			endm  
# End of macro DMARK
334f						CALLMONITOR 
334f cd a5 18			call break_point_state  
3352				endm  
# End of macro CALLMONITOR
3352					endif 
3352			 
3352					FORTH_DSP_VALUEHL 
3352 cd 10 21			call macro_dsp_valuehl 
3355				endm 
# End of macro FORTH_DSP_VALUEHL
3355			;		push hl		 ; hl now has starting limit counter 
3355			 
3355					if DEBUG_FORTH_WORDS 
3355						DMARK "DO6" 
3355 f5				push af  
3356 3a 6a 33			ld a, (.dmark)  
3359 32 6e fe			ld (debug_mark),a  
335c 3a 6b 33			ld a, (.dmark+1)  
335f 32 6f fe			ld (debug_mark+1),a  
3362 3a 6c 33			ld a, (.dmark+2)  
3365 32 70 fe			ld (debug_mark+2),a  
3368 18 03			jr .pastdmark  
336a ..			.dmark: db "DO6"  
336d f1			.pastdmark: pop af  
336e			endm  
# End of macro DMARK
336e						CALLMONITOR 
336e cd a5 18			call break_point_state  
3371				endm  
# End of macro CALLMONITOR
3371					endif 
3371					FORTH_DSP_POP 
3371 cd c8 21			call macro_forth_dsp_pop 
3374				endm 
# End of macro FORTH_DSP_POP
3374			 
3374			; put counters on the loop stack 
3374			 
3374			;		pop hl			 ; limit counter 
3374 d1					pop de			; start counter 
3375			 
3375					; push limit counter 
3375			 
3375					if DEBUG_FORTH_WORDS 
3375						DMARK "DO7" 
3375 f5				push af  
3376 3a 8a 33			ld a, (.dmark)  
3379 32 6e fe			ld (debug_mark),a  
337c 3a 8b 33			ld a, (.dmark+1)  
337f 32 6f fe			ld (debug_mark+1),a  
3382 3a 8c 33			ld a, (.dmark+2)  
3385 32 70 fe			ld (debug_mark+2),a  
3388 18 03			jr .pastdmark  
338a ..			.dmark: db "DO7"  
338d f1			.pastdmark: pop af  
338e			endm  
# End of macro DMARK
338e						CALLMONITOR 
338e cd a5 18			call break_point_state  
3391				endm  
# End of macro CALLMONITOR
3391					endif 
3391					FORTH_LOOP_NEXT 
3391 cd 41 21			call macro_forth_loop_next 
3394				endm 
# End of macro FORTH_LOOP_NEXT
3394			 
3394					; push start counter 
3394			 
3394 eb					ex de, hl 
3395					if DEBUG_FORTH_WORDS 
3395						DMARK "DO7" 
3395 f5				push af  
3396 3a aa 33			ld a, (.dmark)  
3399 32 6e fe			ld (debug_mark),a  
339c 3a ab 33			ld a, (.dmark+1)  
339f 32 6f fe			ld (debug_mark+1),a  
33a2 3a ac 33			ld a, (.dmark+2)  
33a5 32 70 fe			ld (debug_mark+2),a  
33a8 18 03			jr .pastdmark  
33aa ..			.dmark: db "DO7"  
33ad f1			.pastdmark: pop af  
33ae			endm  
# End of macro DMARK
33ae						CALLMONITOR 
33ae cd a5 18			call break_point_state  
33b1				endm  
# End of macro CALLMONITOR
33b1					endif 
33b1					FORTH_LOOP_NEXT 
33b1 cd 41 21			call macro_forth_loop_next 
33b4				endm 
# End of macro FORTH_LOOP_NEXT
33b4			 
33b4			 
33b4					; init first round of I counter 
33b4			 
33b4 22 24 f5				ld (os_current_i), hl 
33b7			 
33b7					if DEBUG_FORTH_WORDS 
33b7						DMARK "DO8" 
33b7 f5				push af  
33b8 3a cc 33			ld a, (.dmark)  
33bb 32 6e fe			ld (debug_mark),a  
33be 3a cd 33			ld a, (.dmark+1)  
33c1 32 6f fe			ld (debug_mark+1),a  
33c4 3a ce 33			ld a, (.dmark+2)  
33c7 32 70 fe			ld (debug_mark+2),a  
33ca 18 03			jr .pastdmark  
33cc ..			.dmark: db "DO8"  
33cf f1			.pastdmark: pop af  
33d0			endm  
# End of macro DMARK
33d0						CALLMONITOR 
33d0 cd a5 18			call break_point_state  
33d3				endm  
# End of macro CALLMONITOR
33d3					endif 
33d3			 
33d3					NEXTW 
33d3 c3 87 22			jp macro_next 
33d6				endm 
# End of macro NEXTW
33d6			.LOOP: 
33d6				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
33d6 22				db WORD_SYS_CORE+14             
33d7 ee 34			dw .I            
33d9 05				db 4 + 1 
33da .. 00			db "LOOP",0              
33df				endm 
# End of macro CWHEAD
33df			; | LOOP ( -- ) Increment and test loop counter  | DONE 
33df			 
33df				; pop tos as current loop count to hl 
33df			 
33df				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33df			 
33df				FORTH_LOOP_TOS 
33df cd 74 21			call macro_forth_loop_tos 
33e2				endm 
# End of macro FORTH_LOOP_TOS
33e2 e5				push hl 
33e3			 
33e3					if DEBUG_FORTH_WORDS_KEY 
33e3						DMARK "LOP" 
33e3 f5				push af  
33e4 3a f8 33			ld a, (.dmark)  
33e7 32 6e fe			ld (debug_mark),a  
33ea 3a f9 33			ld a, (.dmark+1)  
33ed 32 6f fe			ld (debug_mark+1),a  
33f0 3a fa 33			ld a, (.dmark+2)  
33f3 32 70 fe			ld (debug_mark+2),a  
33f6 18 03			jr .pastdmark  
33f8 ..			.dmark: db "LOP"  
33fb f1			.pastdmark: pop af  
33fc			endm  
# End of macro DMARK
33fc						CALLMONITOR 
33fc cd a5 18			call break_point_state  
33ff				endm  
# End of macro CALLMONITOR
33ff					endif 
33ff				; next item on the stack is the limit. get it 
33ff			 
33ff			 
33ff				FORTH_LOOP_POP 
33ff cd 7e 21			call macro_forth_loop_pop 
3402				endm 
# End of macro FORTH_LOOP_POP
3402			 
3402				FORTH_LOOP_TOS 
3402 cd 74 21			call macro_forth_loop_tos 
3405				endm 
# End of macro FORTH_LOOP_TOS
3405			 
3405 d1				pop de		 ; de = i, hl = limit 
3406			 
3406					if DEBUG_FORTH_WORDS 
3406						DMARK "LP1" 
3406 f5				push af  
3407 3a 1b 34			ld a, (.dmark)  
340a 32 6e fe			ld (debug_mark),a  
340d 3a 1c 34			ld a, (.dmark+1)  
3410 32 6f fe			ld (debug_mark+1),a  
3413 3a 1d 34			ld a, (.dmark+2)  
3416 32 70 fe			ld (debug_mark+2),a  
3419 18 03			jr .pastdmark  
341b ..			.dmark: db "LP1"  
341e f1			.pastdmark: pop af  
341f			endm  
# End of macro DMARK
341f						CALLMONITOR 
341f cd a5 18			call break_point_state  
3422				endm  
# End of macro CALLMONITOR
3422					endif 
3422			 
3422				; go back to previous word 
3422			 
3422 d5				push de    ; save I for inc later 
3423			 
3423			 
3423				; get limit 
3423				;  is I at limit? 
3423			 
3423			 
3423					if DEBUG_FORTH_WORDS 
3423						DMARK "LP1" 
3423 f5				push af  
3424 3a 38 34			ld a, (.dmark)  
3427 32 6e fe			ld (debug_mark),a  
342a 3a 39 34			ld a, (.dmark+1)  
342d 32 6f fe			ld (debug_mark+1),a  
3430 3a 3a 34			ld a, (.dmark+2)  
3433 32 70 fe			ld (debug_mark+2),a  
3436 18 03			jr .pastdmark  
3438 ..			.dmark: db "LP1"  
343b f1			.pastdmark: pop af  
343c			endm  
# End of macro DMARK
343c						CALLMONITOR 
343c cd a5 18			call break_point_state  
343f				endm  
# End of macro CALLMONITOR
343f					endif 
343f			 
343f ed 52			sbc hl, de 
3441			 
3441			 
3441				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3441			 
3441 20 26				jr nz, .loopnotdone 
3443			 
3443 e1				pop hl   ; get rid of saved I 
3444				FORTH_LOOP_POP     ; get rid of limit 
3444 cd 7e 21			call macro_forth_loop_pop 
3447				endm 
# End of macro FORTH_LOOP_POP
3447			 
3447				FORTH_RSP_POP     ; get rid of DO ptr 
3447 cd e1 1e			call macro_forth_rsp_pop 
344a				endm 
# End of macro FORTH_RSP_POP
344a			 
344a			if DEBUG_FORTH_WORDS 
344a						DMARK "LP>" 
344a f5				push af  
344b 3a 5f 34			ld a, (.dmark)  
344e 32 6e fe			ld (debug_mark),a  
3451 3a 60 34			ld a, (.dmark+1)  
3454 32 6f fe			ld (debug_mark+1),a  
3457 3a 61 34			ld a, (.dmark+2)  
345a 32 70 fe			ld (debug_mark+2),a  
345d 18 03			jr .pastdmark  
345f ..			.dmark: db "LP>"  
3462 f1			.pastdmark: pop af  
3463			endm  
# End of macro DMARK
3463				CALLMONITOR 
3463 cd a5 18			call break_point_state  
3466				endm  
# End of macro CALLMONITOR
3466			endif 
3466			 
3466					NEXTW 
3466 c3 87 22			jp macro_next 
3469				endm 
# End of macro NEXTW
3469				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3469			 
3469			.loopnotdone: 
3469			 
3469 e1				pop hl    ; get I 
346a 23				inc hl 
346b			 
346b			   	; save new I 
346b			 
346b			 
346b					; set I counter 
346b			 
346b 22 24 f5				ld (os_current_i), hl 
346e			 
346e					if DEBUG_FORTH_WORDS 
346e						DMARK "LPN" 
346e f5				push af  
346f 3a 83 34			ld a, (.dmark)  
3472 32 6e fe			ld (debug_mark),a  
3475 3a 84 34			ld a, (.dmark+1)  
3478 32 6f fe			ld (debug_mark+1),a  
347b 3a 85 34			ld a, (.dmark+2)  
347e 32 70 fe			ld (debug_mark+2),a  
3481 18 03			jr .pastdmark  
3483 ..			.dmark: db "LPN"  
3486 f1			.pastdmark: pop af  
3487			endm  
# End of macro DMARK
3487					CALLMONITOR 
3487 cd a5 18			call break_point_state  
348a				endm  
# End of macro CALLMONITOR
348a					endif 
348a					 
348a				FORTH_LOOP_NEXT 
348a cd 41 21			call macro_forth_loop_next 
348d				endm 
# End of macro FORTH_LOOP_NEXT
348d			 
348d			 
348d					if DEBUG_FORTH_WORDS 
348d eb						ex de,hl 
348e					endif 
348e			 
348e			;	; get DO ptr 
348e			; 
348e					if DEBUG_FORTH_WORDS 
348e						DMARK "LP7" 
348e f5				push af  
348f 3a a3 34			ld a, (.dmark)  
3492 32 6e fe			ld (debug_mark),a  
3495 3a a4 34			ld a, (.dmark+1)  
3498 32 6f fe			ld (debug_mark+1),a  
349b 3a a5 34			ld a, (.dmark+2)  
349e 32 70 fe			ld (debug_mark+2),a  
34a1 18 03			jr .pastdmark  
34a3 ..			.dmark: db "LP7"  
34a6 f1			.pastdmark: pop af  
34a7			endm  
# End of macro DMARK
34a7					CALLMONITOR 
34a7 cd a5 18			call break_point_state  
34aa				endm  
# End of macro CALLMONITOR
34aa					endif 
34aa				FORTH_RSP_TOS 
34aa cd d7 1e			call macro_forth_rsp_tos 
34ad				endm 
# End of macro FORTH_RSP_TOS
34ad			 
34ad					if DEBUG_FORTH_WORDS 
34ad						DMARK "LP8" 
34ad f5				push af  
34ae 3a c2 34			ld a, (.dmark)  
34b1 32 6e fe			ld (debug_mark),a  
34b4 3a c3 34			ld a, (.dmark+1)  
34b7 32 6f fe			ld (debug_mark+1),a  
34ba 3a c4 34			ld a, (.dmark+2)  
34bd 32 70 fe			ld (debug_mark+2),a  
34c0 18 03			jr .pastdmark  
34c2 ..			.dmark: db "LP8"  
34c5 f1			.pastdmark: pop af  
34c6			endm  
# End of macro DMARK
34c6					CALLMONITOR 
34c6 cd a5 18			call break_point_state  
34c9				endm  
# End of macro CALLMONITOR
34c9					endif 
34c9				;push hl 
34c9			 
34c9				; not going to DO any more 
34c9				; get rid of the RSP pointer as DO will add it back in 
34c9				;FORTH_RSP_POP 
34c9				;pop hl 
34c9			 
34c9				;ld hl,(cli_ret_sp) 
34c9				;ld e, (hl) 
34c9				;inc hl 
34c9				;ld d, (hl) 
34c9				;ex de,hl 
34c9 22 00 f5			ld (os_tok_ptr), hl 
34cc					if DEBUG_FORTH_WORDS 
34cc						DMARK "LP<" 
34cc f5				push af  
34cd 3a e1 34			ld a, (.dmark)  
34d0 32 6e fe			ld (debug_mark),a  
34d3 3a e2 34			ld a, (.dmark+1)  
34d6 32 6f fe			ld (debug_mark+1),a  
34d9 3a e3 34			ld a, (.dmark+2)  
34dc 32 70 fe			ld (debug_mark+2),a  
34df 18 03			jr .pastdmark  
34e1 ..			.dmark: db "LP<"  
34e4 f1			.pastdmark: pop af  
34e5			endm  
# End of macro DMARK
34e5					CALLMONITOR 
34e5 cd a5 18			call break_point_state  
34e8				endm  
# End of macro CALLMONITOR
34e8				endif 
34e8 c3 18 23			jp exec1 
34eb			 
34eb					 
34eb			 
34eb			 
34eb					NEXTW 
34eb c3 87 22			jp macro_next 
34ee				endm 
# End of macro NEXTW
34ee			.I:  
34ee			 
34ee				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
34ee 5e				db WORD_SYS_CORE+74             
34ef 19 35			dw .DLOOP            
34f1 02				db 1 + 1 
34f2 .. 00			db "I",0              
34f4				endm 
# End of macro CWHEAD
34f4			; | I ( -- ) Current loop counter | DONE 
34f4					if DEBUG_FORTH_WORDS_KEY 
34f4						DMARK "I.." 
34f4 f5				push af  
34f5 3a 09 35			ld a, (.dmark)  
34f8 32 6e fe			ld (debug_mark),a  
34fb 3a 0a 35			ld a, (.dmark+1)  
34fe 32 6f fe			ld (debug_mark+1),a  
3501 3a 0b 35			ld a, (.dmark+2)  
3504 32 70 fe			ld (debug_mark+2),a  
3507 18 03			jr .pastdmark  
3509 ..			.dmark: db "I.."  
350c f1			.pastdmark: pop af  
350d			endm  
# End of macro DMARK
350d						CALLMONITOR 
350d cd a5 18			call break_point_state  
3510				endm  
# End of macro CALLMONITOR
3510					endif 
3510			 
3510 2a 24 f5				ld hl,(os_current_i) 
3513 cd 19 1f				call forth_push_numhl 
3516			 
3516					NEXTW 
3516 c3 87 22			jp macro_next 
3519				endm 
# End of macro NEXTW
3519			.DLOOP: 
3519				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3519 5f				db WORD_SYS_CORE+75             
351a fa 35			dw .REPEAT            
351c 06				db 5 + 1 
351d .. 00			db "-LOOP",0              
3523				endm 
# End of macro CWHEAD
3523			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3523				; pop tos as current loop count to hl 
3523					if DEBUG_FORTH_WORDS_KEY 
3523						DMARK "-LP" 
3523 f5				push af  
3524 3a 38 35			ld a, (.dmark)  
3527 32 6e fe			ld (debug_mark),a  
352a 3a 39 35			ld a, (.dmark+1)  
352d 32 6f fe			ld (debug_mark+1),a  
3530 3a 3a 35			ld a, (.dmark+2)  
3533 32 70 fe			ld (debug_mark+2),a  
3536 18 03			jr .pastdmark  
3538 ..			.dmark: db "-LP"  
353b f1			.pastdmark: pop af  
353c			endm  
# End of macro DMARK
353c						CALLMONITOR 
353c cd a5 18			call break_point_state  
353f				endm  
# End of macro CALLMONITOR
353f					endif 
353f			 
353f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
353f			 
353f				FORTH_LOOP_TOS 
353f cd 74 21			call macro_forth_loop_tos 
3542				endm 
# End of macro FORTH_LOOP_TOS
3542 e5				push hl 
3543			 
3543					if DEBUG_FORTH_WORDS 
3543						DMARK "-LP" 
3543 f5				push af  
3544 3a 58 35			ld a, (.dmark)  
3547 32 6e fe			ld (debug_mark),a  
354a 3a 59 35			ld a, (.dmark+1)  
354d 32 6f fe			ld (debug_mark+1),a  
3550 3a 5a 35			ld a, (.dmark+2)  
3553 32 70 fe			ld (debug_mark+2),a  
3556 18 03			jr .pastdmark  
3558 ..			.dmark: db "-LP"  
355b f1			.pastdmark: pop af  
355c			endm  
# End of macro DMARK
355c						CALLMONITOR 
355c cd a5 18			call break_point_state  
355f				endm  
# End of macro CALLMONITOR
355f					endif 
355f				; next item on the stack is the limit. get it 
355f			 
355f			 
355f				FORTH_LOOP_POP 
355f cd 7e 21			call macro_forth_loop_pop 
3562				endm 
# End of macro FORTH_LOOP_POP
3562			 
3562				FORTH_LOOP_TOS 
3562 cd 74 21			call macro_forth_loop_tos 
3565				endm 
# End of macro FORTH_LOOP_TOS
3565			 
3565 d1				pop de		 ; de = i, hl = limit 
3566			 
3566					if DEBUG_FORTH_WORDS 
3566						DMARK "-L1" 
3566 f5				push af  
3567 3a 7b 35			ld a, (.dmark)  
356a 32 6e fe			ld (debug_mark),a  
356d 3a 7c 35			ld a, (.dmark+1)  
3570 32 6f fe			ld (debug_mark+1),a  
3573 3a 7d 35			ld a, (.dmark+2)  
3576 32 70 fe			ld (debug_mark+2),a  
3579 18 03			jr .pastdmark  
357b ..			.dmark: db "-L1"  
357e f1			.pastdmark: pop af  
357f			endm  
# End of macro DMARK
357f						CALLMONITOR 
357f cd a5 18			call break_point_state  
3582				endm  
# End of macro CALLMONITOR
3582					endif 
3582			 
3582				; go back to previous word 
3582			 
3582 d5				push de    ; save I for inc later 
3583			 
3583			 
3583				; get limit 
3583				;  is I at limit? 
3583			 
3583			 
3583					if DEBUG_FORTH_WORDS 
3583						DMARK "-L1" 
3583 f5				push af  
3584 3a 98 35			ld a, (.dmark)  
3587 32 6e fe			ld (debug_mark),a  
358a 3a 99 35			ld a, (.dmark+1)  
358d 32 6f fe			ld (debug_mark+1),a  
3590 3a 9a 35			ld a, (.dmark+2)  
3593 32 70 fe			ld (debug_mark+2),a  
3596 18 03			jr .pastdmark  
3598 ..			.dmark: db "-L1"  
359b f1			.pastdmark: pop af  
359c			endm  
# End of macro DMARK
359c						CALLMONITOR 
359c cd a5 18			call break_point_state  
359f				endm  
# End of macro CALLMONITOR
359f					endif 
359f			 
359f ed 52			sbc hl, de 
35a1			 
35a1			 
35a1				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35a1			 
35a1 20 26				jr nz, .mloopnotdone 
35a3			 
35a3 e1				pop hl   ; get rid of saved I 
35a4				FORTH_LOOP_POP     ; get rid of limit 
35a4 cd 7e 21			call macro_forth_loop_pop 
35a7				endm 
# End of macro FORTH_LOOP_POP
35a7			 
35a7				FORTH_RSP_POP     ; get rid of DO ptr 
35a7 cd e1 1e			call macro_forth_rsp_pop 
35aa				endm 
# End of macro FORTH_RSP_POP
35aa			 
35aa			if DEBUG_FORTH_WORDS 
35aa						DMARK "-L>" 
35aa f5				push af  
35ab 3a bf 35			ld a, (.dmark)  
35ae 32 6e fe			ld (debug_mark),a  
35b1 3a c0 35			ld a, (.dmark+1)  
35b4 32 6f fe			ld (debug_mark+1),a  
35b7 3a c1 35			ld a, (.dmark+2)  
35ba 32 70 fe			ld (debug_mark+2),a  
35bd 18 03			jr .pastdmark  
35bf ..			.dmark: db "-L>"  
35c2 f1			.pastdmark: pop af  
35c3			endm  
# End of macro DMARK
35c3				CALLMONITOR 
35c3 cd a5 18			call break_point_state  
35c6				endm  
# End of macro CALLMONITOR
35c6			endif 
35c6			 
35c6					NEXTW 
35c6 c3 87 22			jp macro_next 
35c9				endm 
# End of macro NEXTW
35c9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
35c9			 
35c9			.mloopnotdone: 
35c9			 
35c9 e1				pop hl    ; get I 
35ca 2b				dec hl 
35cb			 
35cb			   	; save new I 
35cb			 
35cb			 
35cb					; set I counter 
35cb			 
35cb 22 24 f5				ld (os_current_i), hl 
35ce			 
35ce					 
35ce				FORTH_LOOP_NEXT 
35ce cd 41 21			call macro_forth_loop_next 
35d1				endm 
# End of macro FORTH_LOOP_NEXT
35d1			 
35d1			 
35d1					if DEBUG_FORTH_WORDS 
35d1 eb						ex de,hl 
35d2					endif 
35d2			 
35d2			;	; get DO ptr 
35d2			; 
35d2				FORTH_RSP_TOS 
35d2 cd d7 1e			call macro_forth_rsp_tos 
35d5				endm 
# End of macro FORTH_RSP_TOS
35d5			 
35d5				;push hl 
35d5			 
35d5				; not going to DO any more 
35d5				; get rid of the RSP pointer as DO will add it back in 
35d5				;FORTH_RSP_POP 
35d5				;pop hl 
35d5			 
35d5			 
35d5 22 00 f5			ld (os_tok_ptr), hl 
35d8					if DEBUG_FORTH_WORDS 
35d8						DMARK "-L<" 
35d8 f5				push af  
35d9 3a ed 35			ld a, (.dmark)  
35dc 32 6e fe			ld (debug_mark),a  
35df 3a ee 35			ld a, (.dmark+1)  
35e2 32 6f fe			ld (debug_mark+1),a  
35e5 3a ef 35			ld a, (.dmark+2)  
35e8 32 70 fe			ld (debug_mark+2),a  
35eb 18 03			jr .pastdmark  
35ed ..			.dmark: db "-L<"  
35f0 f1			.pastdmark: pop af  
35f1			endm  
# End of macro DMARK
35f1					CALLMONITOR 
35f1 cd a5 18			call break_point_state  
35f4				endm  
# End of macro CALLMONITOR
35f4				endif 
35f4 c3 18 23			jp exec1 
35f7			 
35f7					 
35f7			 
35f7			 
35f7			 
35f7				NEXTW 
35f7 c3 87 22			jp macro_next 
35fa				endm 
# End of macro NEXTW
35fa			 
35fa			 
35fa			 
35fa			 
35fa			.REPEAT: 
35fa				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
35fa 71				db WORD_SYS_CORE+93             
35fb 4d 36			dw .UNTIL            
35fd 06				db 5 + 1 
35fe .. 00			db "REPEAT",0              
3605				endm 
# End of macro CWHEAD
3605			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3605			;  push pc to rsp stack past the REPEAT 
3605					if DEBUG_FORTH_WORDS_KEY 
3605						DMARK "REP" 
3605 f5				push af  
3606 3a 1a 36			ld a, (.dmark)  
3609 32 6e fe			ld (debug_mark),a  
360c 3a 1b 36			ld a, (.dmark+1)  
360f 32 6f fe			ld (debug_mark+1),a  
3612 3a 1c 36			ld a, (.dmark+2)  
3615 32 70 fe			ld (debug_mark+2),a  
3618 18 03			jr .pastdmark  
361a ..			.dmark: db "REP"  
361d f1			.pastdmark: pop af  
361e			endm  
# End of macro DMARK
361e						CALLMONITOR 
361e cd a5 18			call break_point_state  
3621				endm  
# End of macro CALLMONITOR
3621					endif 
3621			 
3621 2a 00 f5				ld hl, (os_tok_ptr) 
3624 23					inc hl   ; R 
3625 23					inc hl  ; E 
3626 23					inc hl   ; P 
3627 23					inc hl   ; E 
3628 23					inc hl   ; A 
3629 23					inc hl   ; T 
362a 23					inc hl   ; zero 
362b					FORTH_RSP_NEXT 
362b cd c0 1e			call macro_forth_rsp_next 
362e				endm 
# End of macro FORTH_RSP_NEXT
362e			 
362e			 
362e					if DEBUG_FORTH_WORDS 
362e						DMARK "REP" 
362e f5				push af  
362f 3a 43 36			ld a, (.dmark)  
3632 32 6e fe			ld (debug_mark),a  
3635 3a 44 36			ld a, (.dmark+1)  
3638 32 6f fe			ld (debug_mark+1),a  
363b 3a 45 36			ld a, (.dmark+2)  
363e 32 70 fe			ld (debug_mark+2),a  
3641 18 03			jr .pastdmark  
3643 ..			.dmark: db "REP"  
3646 f1			.pastdmark: pop af  
3647			endm  
# End of macro DMARK
3647						;pop bc    ; TODO BUG ?????? what is this for???? 
3647						CALLMONITOR 
3647 cd a5 18			call break_point_state  
364a				endm  
# End of macro CALLMONITOR
364a					endif 
364a			 
364a					NEXTW 
364a c3 87 22			jp macro_next 
364d				endm 
# End of macro NEXTW
364d			;	       NEXTW 
364d			 
364d			.UNTIL: 
364d				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
364d 72				db WORD_SYS_CORE+94             
364e e4 36			dw .ENDFLOW            
3650 06				db 5 + 1 
3651 .. 00			db "UNTIL",0              
3657				endm 
# End of macro CWHEAD
3657			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3657			 
3657				; pop tos as check 
3657			 
3657				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3657			 
3657				FORTH_DSP_VALUEHL 
3657 cd 10 21			call macro_dsp_valuehl 
365a				endm 
# End of macro FORTH_DSP_VALUEHL
365a			 
365a					if DEBUG_FORTH_WORDS_KEY 
365a						DMARK "UNT" 
365a f5				push af  
365b 3a 6f 36			ld a, (.dmark)  
365e 32 6e fe			ld (debug_mark),a  
3661 3a 70 36			ld a, (.dmark+1)  
3664 32 6f fe			ld (debug_mark+1),a  
3667 3a 71 36			ld a, (.dmark+2)  
366a 32 70 fe			ld (debug_mark+2),a  
366d 18 03			jr .pastdmark  
366f ..			.dmark: db "UNT"  
3672 f1			.pastdmark: pop af  
3673			endm  
# End of macro DMARK
3673						CALLMONITOR 
3673 cd a5 18			call break_point_state  
3676				endm  
# End of macro CALLMONITOR
3676					endif 
3676			 
3676			;	push hl 
3676				FORTH_DSP_POP 
3676 cd c8 21			call macro_forth_dsp_pop 
3679				endm 
# End of macro FORTH_DSP_POP
3679			 
3679			;	pop hl 
3679			 
3679				; test if true 
3679			 
3679 cd 27 0f			call ishlzero 
367c			;	ld a,l 
367c			;	add h 
367c			; 
367c			;	cp 0 
367c			 
367c 20 3e			jr nz, .untilnotdone 
367e			 
367e					if DEBUG_FORTH_WORDS 
367e						DMARK "UNf" 
367e f5				push af  
367f 3a 93 36			ld a, (.dmark)  
3682 32 6e fe			ld (debug_mark),a  
3685 3a 94 36			ld a, (.dmark+1)  
3688 32 6f fe			ld (debug_mark+1),a  
368b 3a 95 36			ld a, (.dmark+2)  
368e 32 70 fe			ld (debug_mark+2),a  
3691 18 03			jr .pastdmark  
3693 ..			.dmark: db "UNf"  
3696 f1			.pastdmark: pop af  
3697			endm  
# End of macro DMARK
3697						CALLMONITOR 
3697 cd a5 18			call break_point_state  
369a				endm  
# End of macro CALLMONITOR
369a					endif 
369a			 
369a			 
369a			 
369a				FORTH_RSP_POP     ; get rid of DO ptr 
369a cd e1 1e			call macro_forth_rsp_pop 
369d				endm 
# End of macro FORTH_RSP_POP
369d			 
369d			if DEBUG_FORTH_WORDS 
369d						DMARK "UN>" 
369d f5				push af  
369e 3a b2 36			ld a, (.dmark)  
36a1 32 6e fe			ld (debug_mark),a  
36a4 3a b3 36			ld a, (.dmark+1)  
36a7 32 6f fe			ld (debug_mark+1),a  
36aa 3a b4 36			ld a, (.dmark+2)  
36ad 32 70 fe			ld (debug_mark+2),a  
36b0 18 03			jr .pastdmark  
36b2 ..			.dmark: db "UN>"  
36b5 f1			.pastdmark: pop af  
36b6			endm  
# End of macro DMARK
36b6				CALLMONITOR 
36b6 cd a5 18			call break_point_state  
36b9				endm  
# End of macro CALLMONITOR
36b9			endif 
36b9			 
36b9					NEXTW 
36b9 c3 87 22			jp macro_next 
36bc				endm 
# End of macro NEXTW
36bc				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
36bc			 
36bc			.untilnotdone: 
36bc			 
36bc			 
36bc			;	; get DO ptr 
36bc			; 
36bc				FORTH_RSP_TOS 
36bc cd d7 1e			call macro_forth_rsp_tos 
36bf				endm 
# End of macro FORTH_RSP_TOS
36bf			 
36bf				;push hl 
36bf			 
36bf				; not going to DO any more 
36bf				; get rid of the RSP pointer as DO will add it back in 
36bf				;FORTH_RSP_POP 
36bf				;pop hl 
36bf			 
36bf			 
36bf 22 00 f5			ld (os_tok_ptr), hl 
36c2					if DEBUG_FORTH_WORDS 
36c2						DMARK "UN<" 
36c2 f5				push af  
36c3 3a d7 36			ld a, (.dmark)  
36c6 32 6e fe			ld (debug_mark),a  
36c9 3a d8 36			ld a, (.dmark+1)  
36cc 32 6f fe			ld (debug_mark+1),a  
36cf 3a d9 36			ld a, (.dmark+2)  
36d2 32 70 fe			ld (debug_mark+2),a  
36d5 18 03			jr .pastdmark  
36d7 ..			.dmark: db "UN<"  
36da f1			.pastdmark: pop af  
36db			endm  
# End of macro DMARK
36db					CALLMONITOR 
36db cd a5 18			call break_point_state  
36de				endm  
# End of macro CALLMONITOR
36de				endif 
36de c3 18 23			jp exec1 
36e1			 
36e1					 
36e1			 
36e1			 
36e1					NEXTW 
36e1 c3 87 22			jp macro_next 
36e4				endm 
# End of macro NEXTW
36e4			 
36e4			 
36e4			.ENDFLOW: 
36e4			 
36e4			; eof 
36e4			 
# End of file forth_words_flow.asm
36e4			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
36e4			include "forth_words_logic.asm" 
36e4			 
36e4			; | ## Logic Words 
36e4			 
36e4			.NOT: 
36e4				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
36e4 2d				db WORD_SYS_CORE+25             
36e5 2c 37			dw .IS            
36e7 04				db 3 + 1 
36e8 .. 00			db "NOT",0              
36ec				endm 
# End of macro CWHEAD
36ec			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
36ec					if DEBUG_FORTH_WORDS_KEY 
36ec						DMARK "NOT" 
36ec f5				push af  
36ed 3a 01 37			ld a, (.dmark)  
36f0 32 6e fe			ld (debug_mark),a  
36f3 3a 02 37			ld a, (.dmark+1)  
36f6 32 6f fe			ld (debug_mark+1),a  
36f9 3a 03 37			ld a, (.dmark+2)  
36fc 32 70 fe			ld (debug_mark+2),a  
36ff 18 03			jr .pastdmark  
3701 ..			.dmark: db "NOT"  
3704 f1			.pastdmark: pop af  
3705			endm  
# End of macro DMARK
3705						CALLMONITOR 
3705 cd a5 18			call break_point_state  
3708				endm  
# End of macro CALLMONITOR
3708					endif 
3708					FORTH_DSP 
3708 cd d6 20			call macro_forth_dsp 
370b				endm 
# End of macro FORTH_DSP
370b 7e					ld a,(hl)	; get type of value on TOS 
370c fe 02				cp DS_TYPE_INUM  
370e 28 03				jr z, .noti 
3710					NEXTW 
3710 c3 87 22			jp macro_next 
3713				endm 
# End of macro NEXTW
3713			.noti:          FORTH_DSP_VALUEHL 
3713 cd 10 21			call macro_dsp_valuehl 
3716				endm 
# End of macro FORTH_DSP_VALUEHL
3716			;		push hl 
3716					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3716 cd c8 21			call macro_forth_dsp_pop 
3719				endm 
# End of macro FORTH_DSP_POP
3719			;		pop hl 
3719 3e 00				ld a,0 
371b bd					cp l 
371c 28 04				jr z, .not2t 
371e 2e 00				ld l, 0 
3720 18 02				jr .notip 
3722			 
3722 2e ff		.not2t:		ld l, 255 
3724			 
3724 26 00		.notip:		ld h, 0	 
3726			 
3726 cd 19 1f				call forth_push_numhl 
3729					NEXTW 
3729 c3 87 22			jp macro_next 
372c				endm 
# End of macro NEXTW
372c			 
372c			.IS: 
372c				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
372c 2d				db WORD_SYS_CORE+25             
372d 52 37			dw .LZERO            
372f 03				db 2 + 1 
3730 .. 00			db "IS",0              
3733				endm 
# End of macro CWHEAD
3733			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3733					if DEBUG_FORTH_WORDS_KEY 
3733						DMARK "IS." 
3733 f5				push af  
3734 3a 48 37			ld a, (.dmark)  
3737 32 6e fe			ld (debug_mark),a  
373a 3a 49 37			ld a, (.dmark+1)  
373d 32 6f fe			ld (debug_mark+1),a  
3740 3a 4a 37			ld a, (.dmark+2)  
3743 32 70 fe			ld (debug_mark+2),a  
3746 18 03			jr .pastdmark  
3748 ..			.dmark: db "IS."  
374b f1			.pastdmark: pop af  
374c			endm  
# End of macro DMARK
374c						CALLMONITOR 
374c cd a5 18			call break_point_state  
374f				endm  
# End of macro CALLMONITOR
374f					endif 
374f					NEXTW 
374f c3 87 22			jp macro_next 
3752				endm 
# End of macro NEXTW
3752			.LZERO: 
3752				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3752 2d				db WORD_SYS_CORE+25             
3753 5c 37			dw .TZERO            
3755 03				db 2 + 1 
3756 .. 00			db "0<",0              
3759				endm 
# End of macro CWHEAD
3759			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3759					NEXTW 
3759 c3 87 22			jp macro_next 
375c				endm 
# End of macro NEXTW
375c			.TZERO: 
375c				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
375c 2e				db WORD_SYS_CORE+26             
375d a3 37			dw .LESS            
375f 03				db 2 + 1 
3760 .. 00			db "0=",0              
3763				endm 
# End of macro CWHEAD
3763			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3763				; TODO add floating point number detection 
3763					;v5 FORTH_DSP_VALUE 
3763					if DEBUG_FORTH_WORDS_KEY 
3763						DMARK "0=." 
3763 f5				push af  
3764 3a 78 37			ld a, (.dmark)  
3767 32 6e fe			ld (debug_mark),a  
376a 3a 79 37			ld a, (.dmark+1)  
376d 32 6f fe			ld (debug_mark+1),a  
3770 3a 7a 37			ld a, (.dmark+2)  
3773 32 70 fe			ld (debug_mark+2),a  
3776 18 03			jr .pastdmark  
3778 ..			.dmark: db "0=."  
377b f1			.pastdmark: pop af  
377c			endm  
# End of macro DMARK
377c						CALLMONITOR 
377c cd a5 18			call break_point_state  
377f				endm  
# End of macro CALLMONITOR
377f					endif 
377f					FORTH_DSP 
377f cd d6 20			call macro_forth_dsp 
3782				endm 
# End of macro FORTH_DSP
3782 7e					ld a,(hl)	; get type of value on TOS 
3783 fe 02				cp DS_TYPE_INUM  
3785 28 00				jr z, .tz_inum 
3787			 
3787				if FORTH_ENABLE_FLOATMATH 
3787					jr .tz_done 
3787			 
3787				endif 
3787					 
3787			 
3787			.tz_inum: 
3787					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3787 cd 10 21			call macro_dsp_valuehl 
378a				endm 
# End of macro FORTH_DSP_VALUEHL
378a			 
378a			;		push hl 
378a			 
378a					; destroy value TOS 
378a			 
378a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378a cd c8 21			call macro_forth_dsp_pop 
378d				endm 
# End of macro FORTH_DSP_POP
378d			 
378d			;		pop hl 
378d			 
378d 3e 00				ld a,0 
378f			 
378f bd					cp l 
3790 20 08				jr nz, .tz_notzero 
3792			 
3792 bc					cp h 
3793			 
3793 20 05				jr nz, .tz_notzero 
3795			 
3795			 
3795 21 01 00				ld hl, FORTH_TRUE 
3798 18 03				jr .tz_done 
379a			 
379a 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
379d			 
379d					; push value back onto stack for another op etc 
379d			 
379d			.tz_done: 
379d cd 19 1f				call forth_push_numhl 
37a0			 
37a0					NEXTW 
37a0 c3 87 22			jp macro_next 
37a3				endm 
# End of macro NEXTW
37a3			.LESS: 
37a3				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
37a3 2f				db WORD_SYS_CORE+27             
37a4 0c 38			dw .GT            
37a6 02				db 1 + 1 
37a7 .. 00			db "<",0              
37a9				endm 
# End of macro CWHEAD
37a9			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
37a9				; TODO add floating point number detection 
37a9					if DEBUG_FORTH_WORDS_KEY 
37a9						DMARK "LES" 
37a9 f5				push af  
37aa 3a be 37			ld a, (.dmark)  
37ad 32 6e fe			ld (debug_mark),a  
37b0 3a bf 37			ld a, (.dmark+1)  
37b3 32 6f fe			ld (debug_mark+1),a  
37b6 3a c0 37			ld a, (.dmark+2)  
37b9 32 70 fe			ld (debug_mark+2),a  
37bc 18 03			jr .pastdmark  
37be ..			.dmark: db "LES"  
37c1 f1			.pastdmark: pop af  
37c2			endm  
# End of macro DMARK
37c2						CALLMONITOR 
37c2 cd a5 18			call break_point_state  
37c5				endm  
# End of macro CALLMONITOR
37c5					endif 
37c5					FORTH_DSP 
37c5 cd d6 20			call macro_forth_dsp 
37c8				endm 
# End of macro FORTH_DSP
37c8					;v5 FORTH_DSP_VALUE 
37c8 7e					ld a,(hl)	; get type of value on TOS 
37c9 fe 02				cp DS_TYPE_INUM  
37cb 28 00				jr z, .less_inum 
37cd			 
37cd				if FORTH_ENABLE_FLOATMATH 
37cd					jr .less_done 
37cd			 
37cd				endif 
37cd					 
37cd			 
37cd			.less_inum: 
37cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37cd cd 10 21			call macro_dsp_valuehl 
37d0				endm 
# End of macro FORTH_DSP_VALUEHL
37d0			 
37d0 e5					push hl  ; u2 
37d1			 
37d1					; destroy value TOS 
37d1			 
37d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d1 cd c8 21			call macro_forth_dsp_pop 
37d4				endm 
# End of macro FORTH_DSP_POP
37d4			 
37d4			 
37d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d4 cd 10 21			call macro_dsp_valuehl 
37d7				endm 
# End of macro FORTH_DSP_VALUEHL
37d7			 
37d7 e5					push hl    ; u1 
37d8			 
37d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d8 cd c8 21			call macro_forth_dsp_pop 
37db				endm 
# End of macro FORTH_DSP_POP
37db			 
37db			 
37db b7			 or a      ;clear carry flag 
37dc 01 00 00		 ld bc, FORTH_FALSE 
37df e1			  pop hl    ; u1 
37e0 d1			  pop de    ; u2 
37e1 ed 52		  sbc hl,de 
37e3 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
37e5			 
37e5 01 01 00		 ld bc, FORTH_TRUE 
37e8			.lscont:  
37e8 c5					push bc 
37e9 e1					pop hl 
37ea			 
37ea					if DEBUG_FORTH_WORDS 
37ea						DMARK "LT1" 
37ea f5				push af  
37eb 3a ff 37			ld a, (.dmark)  
37ee 32 6e fe			ld (debug_mark),a  
37f1 3a 00 38			ld a, (.dmark+1)  
37f4 32 6f fe			ld (debug_mark+1),a  
37f7 3a 01 38			ld a, (.dmark+2)  
37fa 32 70 fe			ld (debug_mark+2),a  
37fd 18 03			jr .pastdmark  
37ff ..			.dmark: db "LT1"  
3802 f1			.pastdmark: pop af  
3803			endm  
# End of macro DMARK
3803						CALLMONITOR 
3803 cd a5 18			call break_point_state  
3806				endm  
# End of macro CALLMONITOR
3806					endif 
3806 cd 19 1f				call forth_push_numhl 
3809			 
3809					NEXTW 
3809 c3 87 22			jp macro_next 
380c				endm 
# End of macro NEXTW
380c			.GT: 
380c				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
380c 30				db WORD_SYS_CORE+28             
380d 75 38			dw .EQUAL            
380f 02				db 1 + 1 
3810 .. 00			db ">",0              
3812				endm 
# End of macro CWHEAD
3812			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3812				; TODO add floating point number detection 
3812					if DEBUG_FORTH_WORDS_KEY 
3812						DMARK "GRT" 
3812 f5				push af  
3813 3a 27 38			ld a, (.dmark)  
3816 32 6e fe			ld (debug_mark),a  
3819 3a 28 38			ld a, (.dmark+1)  
381c 32 6f fe			ld (debug_mark+1),a  
381f 3a 29 38			ld a, (.dmark+2)  
3822 32 70 fe			ld (debug_mark+2),a  
3825 18 03			jr .pastdmark  
3827 ..			.dmark: db "GRT"  
382a f1			.pastdmark: pop af  
382b			endm  
# End of macro DMARK
382b						CALLMONITOR 
382b cd a5 18			call break_point_state  
382e				endm  
# End of macro CALLMONITOR
382e					endif 
382e					FORTH_DSP 
382e cd d6 20			call macro_forth_dsp 
3831				endm 
# End of macro FORTH_DSP
3831					;FORTH_DSP_VALUE 
3831 7e					ld a,(hl)	; get type of value on TOS 
3832 fe 02				cp DS_TYPE_INUM  
3834 28 00				jr z, .gt_inum 
3836			 
3836				if FORTH_ENABLE_FLOATMATH 
3836					jr .gt_done 
3836			 
3836				endif 
3836					 
3836			 
3836			.gt_inum: 
3836					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3836 cd 10 21			call macro_dsp_valuehl 
3839				endm 
# End of macro FORTH_DSP_VALUEHL
3839			 
3839 e5					push hl  ; u2 
383a			 
383a					; destroy value TOS 
383a			 
383a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383a cd c8 21			call macro_forth_dsp_pop 
383d				endm 
# End of macro FORTH_DSP_POP
383d			 
383d			 
383d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383d cd 10 21			call macro_dsp_valuehl 
3840				endm 
# End of macro FORTH_DSP_VALUEHL
3840			 
3840 e5					push hl    ; u1 
3841			 
3841					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3841 cd c8 21			call macro_forth_dsp_pop 
3844				endm 
# End of macro FORTH_DSP_POP
3844			 
3844			 
3844 b7			 or a      ;clear carry flag 
3845 01 00 00		 ld bc, FORTH_FALSE 
3848 e1			  pop hl    ; u1 
3849 d1			  pop de    ; u2 
384a ed 52		  sbc hl,de 
384c 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
384e			 
384e 01 01 00		 ld bc, FORTH_TRUE 
3851			.gtcont:  
3851 c5					push bc 
3852 e1					pop hl 
3853			 
3853					if DEBUG_FORTH_WORDS 
3853						DMARK "GT1" 
3853 f5				push af  
3854 3a 68 38			ld a, (.dmark)  
3857 32 6e fe			ld (debug_mark),a  
385a 3a 69 38			ld a, (.dmark+1)  
385d 32 6f fe			ld (debug_mark+1),a  
3860 3a 6a 38			ld a, (.dmark+2)  
3863 32 70 fe			ld (debug_mark+2),a  
3866 18 03			jr .pastdmark  
3868 ..			.dmark: db "GT1"  
386b f1			.pastdmark: pop af  
386c			endm  
# End of macro DMARK
386c						CALLMONITOR 
386c cd a5 18			call break_point_state  
386f				endm  
# End of macro CALLMONITOR
386f					endif 
386f cd 19 1f				call forth_push_numhl 
3872			 
3872					NEXTW 
3872 c3 87 22			jp macro_next 
3875				endm 
# End of macro NEXTW
3875			.EQUAL: 
3875				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3875 31				db WORD_SYS_CORE+29             
3876 e0 38			dw .ENDLOGIC            
3878 02				db 1 + 1 
3879 .. 00			db "=",0              
387b				endm 
# End of macro CWHEAD
387b			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
387b				; TODO add floating point number detection 
387b					if DEBUG_FORTH_WORDS_KEY 
387b						DMARK "EQ." 
387b f5				push af  
387c 3a 90 38			ld a, (.dmark)  
387f 32 6e fe			ld (debug_mark),a  
3882 3a 91 38			ld a, (.dmark+1)  
3885 32 6f fe			ld (debug_mark+1),a  
3888 3a 92 38			ld a, (.dmark+2)  
388b 32 70 fe			ld (debug_mark+2),a  
388e 18 03			jr .pastdmark  
3890 ..			.dmark: db "EQ."  
3893 f1			.pastdmark: pop af  
3894			endm  
# End of macro DMARK
3894						CALLMONITOR 
3894 cd a5 18			call break_point_state  
3897				endm  
# End of macro CALLMONITOR
3897					endif 
3897					FORTH_DSP 
3897 cd d6 20			call macro_forth_dsp 
389a				endm 
# End of macro FORTH_DSP
389a					;v5 FORTH_DSP_VALUE 
389a 7e					ld a,(hl)	; get type of value on TOS 
389b fe 02				cp DS_TYPE_INUM  
389d 28 00				jr z, .eq_inum 
389f			 
389f				if FORTH_ENABLE_FLOATMATH 
389f					jr .eq_done 
389f			 
389f				endif 
389f					 
389f			 
389f			.eq_inum: 
389f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
389f cd 10 21			call macro_dsp_valuehl 
38a2				endm 
# End of macro FORTH_DSP_VALUEHL
38a2			 
38a2 e5					push hl 
38a3			 
38a3					; destroy value TOS 
38a3			 
38a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a3 cd c8 21			call macro_forth_dsp_pop 
38a6				endm 
# End of macro FORTH_DSP_POP
38a6			 
38a6			 
38a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38a6 cd 10 21			call macro_dsp_valuehl 
38a9				endm 
# End of macro FORTH_DSP_VALUEHL
38a9			 
38a9					; one value on hl get other one back 
38a9			 
38a9 e5					push hl 
38aa			 
38aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38aa cd c8 21			call macro_forth_dsp_pop 
38ad				endm 
# End of macro FORTH_DSP_POP
38ad			 
38ad 0e 00				ld c, FORTH_FALSE 
38af			 
38af e1					pop hl 
38b0 d1					pop de 
38b1			 
38b1 7b					ld a, e 
38b2 bd					cp l 
38b3			 
38b3 20 06				jr nz, .eq_done 
38b5			 
38b5 7a					ld a, d 
38b6 bc					cp h 
38b7			 
38b7 20 02				jr nz, .eq_done 
38b9			 
38b9 0e 01				ld c, FORTH_TRUE 
38bb					 
38bb			 
38bb			 
38bb			.eq_done: 
38bb			 
38bb					; TODO push value back onto stack for another op etc 
38bb			 
38bb 26 00				ld h, 0 
38bd 69					ld l, c 
38be					if DEBUG_FORTH_WORDS 
38be						DMARK "EQ1" 
38be f5				push af  
38bf 3a d3 38			ld a, (.dmark)  
38c2 32 6e fe			ld (debug_mark),a  
38c5 3a d4 38			ld a, (.dmark+1)  
38c8 32 6f fe			ld (debug_mark+1),a  
38cb 3a d5 38			ld a, (.dmark+2)  
38ce 32 70 fe			ld (debug_mark+2),a  
38d1 18 03			jr .pastdmark  
38d3 ..			.dmark: db "EQ1"  
38d6 f1			.pastdmark: pop af  
38d7			endm  
# End of macro DMARK
38d7						CALLMONITOR 
38d7 cd a5 18			call break_point_state  
38da				endm  
# End of macro CALLMONITOR
38da					endif 
38da cd 19 1f				call forth_push_numhl 
38dd			 
38dd					NEXTW 
38dd c3 87 22			jp macro_next 
38e0				endm 
# End of macro NEXTW
38e0			 
38e0			 
38e0			.ENDLOGIC: 
38e0			; eof 
38e0			 
38e0			 
# End of file forth_words_logic.asm
38e0			include "forth_words_maths.asm" 
38e0			 
38e0			; | ## Maths Words 
38e0			 
38e0			.PLUS:	 
38e0				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
38e0 15				db WORD_SYS_CORE+1             
38e1 22 39			dw .NEG            
38e3 02				db 1 + 1 
38e4 .. 00			db "+",0              
38e6				endm 
# End of macro CWHEAD
38e6			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
38e6					if DEBUG_FORTH_WORDS_KEY 
38e6						DMARK "PLU" 
38e6 f5				push af  
38e7 3a fb 38			ld a, (.dmark)  
38ea 32 6e fe			ld (debug_mark),a  
38ed 3a fc 38			ld a, (.dmark+1)  
38f0 32 6f fe			ld (debug_mark+1),a  
38f3 3a fd 38			ld a, (.dmark+2)  
38f6 32 70 fe			ld (debug_mark+2),a  
38f9 18 03			jr .pastdmark  
38fb ..			.dmark: db "PLU"  
38fe f1			.pastdmark: pop af  
38ff			endm  
# End of macro DMARK
38ff						CALLMONITOR 
38ff cd a5 18			call break_point_state  
3902				endm  
# End of macro CALLMONITOR
3902					endif 
3902					; add top two values and push back result 
3902			 
3902					;for v5 FORTH_DSP_VALUE 
3902					FORTH_DSP 
3902 cd d6 20			call macro_forth_dsp 
3905				endm 
# End of macro FORTH_DSP
3905 7e					ld a,(hl)	; get type of value on TOS 
3906 fe 02				cp DS_TYPE_INUM  
3908 28 03				jr z, .dot_inum 
390a			 
390a					NEXTW 
390a c3 87 22			jp macro_next 
390d				endm 
# End of macro NEXTW
390d			 
390d			; float maths 
390d			 
390d				if FORTH_ENABLE_FLOATMATH 
390d						inc hl      ; now at start of numeric as string 
390d			 
390d					if DEBUG_FORTH_MATHS 
390d						DMARK "ADD" 
390d				CALLMONITOR 
390d					endif 
390d			 
390d					;ld ix, hl 
390d					call CON 
390d			 
390d			 
390d					push hl 
390d					 
390d					 
390d			 
390d						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
390d			 
390d					; get next number 
390d			 
390d						FORTH_DSP_VALUE 
390d			 
390d						inc hl      ; now at start of numeric as string 
390d			 
390d					;ld ix, hl 
390d					call CON 
390d			 
390d					push hl 
390d			 
390d			 
390d						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
390d			 
390d						; TODO do add 
390d			 
390d						call IADD 
390d			 
390d						; TODO get result back as ascii 
390d			 
390d						; TODO push result  
390d			 
390d			 
390d			 
390d						jr .dot_done 
390d				endif 
390d			 
390d			.dot_inum: 
390d			 
390d			 
390d					if DEBUG_FORTH_DOT 
390d						DMARK "+IT" 
390d				CALLMONITOR 
390d					endif 
390d			 
390d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
390d cd 10 21			call macro_dsp_valuehl 
3910				endm 
# End of macro FORTH_DSP_VALUEHL
3910			 
3910				; TODO add floating point number detection 
3910			 
3910 e5					push hl 
3911			 
3911					; destroy value TOS 
3911			 
3911					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3911 cd c8 21			call macro_forth_dsp_pop 
3914				endm 
# End of macro FORTH_DSP_POP
3914			 
3914			 
3914					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3914 cd 10 21			call macro_dsp_valuehl 
3917				endm 
# End of macro FORTH_DSP_VALUEHL
3917			 
3917					; one value on hl get other one back 
3917			 
3917 d1					pop de 
3918			 
3918					; do the add 
3918			 
3918 19					add hl,de 
3919			 
3919					; save it 
3919			 
3919			;		push hl	 
3919			 
3919					; 
3919			 
3919					; destroy value TOS 
3919			 
3919					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3919 cd c8 21			call macro_forth_dsp_pop 
391c				endm 
# End of macro FORTH_DSP_POP
391c			 
391c					; TODO push value back onto stack for another op etc 
391c			 
391c			;		pop hl 
391c			 
391c			.dot_done: 
391c cd 19 1f				call forth_push_numhl 
391f			 
391f					NEXTW 
391f c3 87 22			jp macro_next 
3922				endm 
# End of macro NEXTW
3922			.NEG: 
3922			 
3922				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3922 17				db WORD_SYS_CORE+3             
3923 65 39			dw .DIV            
3925 02				db 1 + 1 
3926 .. 00			db "-",0              
3928				endm 
# End of macro CWHEAD
3928			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3928					if DEBUG_FORTH_WORDS_KEY 
3928						DMARK "SUB" 
3928 f5				push af  
3929 3a 3d 39			ld a, (.dmark)  
392c 32 6e fe			ld (debug_mark),a  
392f 3a 3e 39			ld a, (.dmark+1)  
3932 32 6f fe			ld (debug_mark+1),a  
3935 3a 3f 39			ld a, (.dmark+2)  
3938 32 70 fe			ld (debug_mark+2),a  
393b 18 03			jr .pastdmark  
393d ..			.dmark: db "SUB"  
3940 f1			.pastdmark: pop af  
3941			endm  
# End of macro DMARK
3941						CALLMONITOR 
3941 cd a5 18			call break_point_state  
3944				endm  
# End of macro CALLMONITOR
3944					endif 
3944			 
3944			 
3944				; TODO add floating point number detection 
3944					; v5 FORTH_DSP_VALUE 
3944					FORTH_DSP 
3944 cd d6 20			call macro_forth_dsp 
3947				endm 
# End of macro FORTH_DSP
3947 7e					ld a,(hl)	; get type of value on TOS 
3948 fe 02				cp DS_TYPE_INUM  
394a 28 03				jr z, .neg_inum 
394c			 
394c					NEXTW 
394c c3 87 22			jp macro_next 
394f				endm 
# End of macro NEXTW
394f			 
394f			; float maths 
394f			 
394f				if FORTH_ENABLE_FLOATMATH 
394f					jr .neg_done 
394f			 
394f				endif 
394f					 
394f			 
394f			.neg_inum: 
394f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
394f cd 10 21			call macro_dsp_valuehl 
3952				endm 
# End of macro FORTH_DSP_VALUEHL
3952			 
3952 e5					push hl 
3953			 
3953					; destroy value TOS 
3953			 
3953					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3953 cd c8 21			call macro_forth_dsp_pop 
3956				endm 
# End of macro FORTH_DSP_POP
3956			 
3956			 
3956					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3956 cd 10 21			call macro_dsp_valuehl 
3959				endm 
# End of macro FORTH_DSP_VALUEHL
3959			 
3959					; one value on hl get other one back 
3959			 
3959 d1					pop de 
395a			 
395a					; do the sub 
395a			;		ex de, hl 
395a			 
395a ed 52				sbc hl,de 
395c			 
395c					; save it 
395c			 
395c			;		push hl	 
395c			 
395c					; 
395c			 
395c					; destroy value TOS 
395c			 
395c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
395c cd c8 21			call macro_forth_dsp_pop 
395f				endm 
# End of macro FORTH_DSP_POP
395f			 
395f					; TODO push value back onto stack for another op etc 
395f			 
395f			;		pop hl 
395f			 
395f cd 19 1f				call forth_push_numhl 
3962			.neg_done: 
3962			 
3962					NEXTW 
3962 c3 87 22			jp macro_next 
3965				endm 
# End of macro NEXTW
3965			.DIV: 
3965				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3965 18				db WORD_SYS_CORE+4             
3966 b2 39			dw .MUL            
3968 02				db 1 + 1 
3969 .. 00			db "/",0              
396b				endm 
# End of macro CWHEAD
396b			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
396b					if DEBUG_FORTH_WORDS_KEY 
396b						DMARK "DIV" 
396b f5				push af  
396c 3a 80 39			ld a, (.dmark)  
396f 32 6e fe			ld (debug_mark),a  
3972 3a 81 39			ld a, (.dmark+1)  
3975 32 6f fe			ld (debug_mark+1),a  
3978 3a 82 39			ld a, (.dmark+2)  
397b 32 70 fe			ld (debug_mark+2),a  
397e 18 03			jr .pastdmark  
3980 ..			.dmark: db "DIV"  
3983 f1			.pastdmark: pop af  
3984			endm  
# End of macro DMARK
3984						CALLMONITOR 
3984 cd a5 18			call break_point_state  
3987				endm  
# End of macro CALLMONITOR
3987					endif 
3987				; TODO add floating point number detection 
3987					; v5 FORTH_DSP_VALUE 
3987					FORTH_DSP 
3987 cd d6 20			call macro_forth_dsp 
398a				endm 
# End of macro FORTH_DSP
398a 7e					ld a,(hl)	; get type of value on TOS 
398b fe 02				cp DS_TYPE_INUM  
398d 28 03				jr z, .div_inum 
398f			 
398f				if FORTH_ENABLE_FLOATMATH 
398f					jr .div_done 
398f			 
398f				endif 
398f					NEXTW 
398f c3 87 22			jp macro_next 
3992				endm 
# End of macro NEXTW
3992			.div_inum: 
3992			 
3992					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3992 cd 10 21			call macro_dsp_valuehl 
3995				endm 
# End of macro FORTH_DSP_VALUEHL
3995			 
3995 e5					push hl    ; to go to bc 
3996			 
3996					; destroy value TOS 
3996			 
3996					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3996 cd c8 21			call macro_forth_dsp_pop 
3999				endm 
# End of macro FORTH_DSP_POP
3999			 
3999			 
3999					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3999 cd 10 21			call macro_dsp_valuehl 
399c				endm 
# End of macro FORTH_DSP_VALUEHL
399c			 
399c					; hl to go to de 
399c			 
399c e5					push hl 
399d			 
399d c1					pop bc 
399e d1					pop de		 
399f			 
399f			 
399f					if DEBUG_FORTH_MATHS 
399f						DMARK "DIV" 
399f				CALLMONITOR 
399f					endif 
399f					; one value on hl but move to a get other one back 
399f			 
399f			        
399f cd 5b 0e			call Div16 
39a2			 
39a2			;	push af	 
39a2 e5				push hl 
39a3 c5				push bc 
39a4			 
39a4					if DEBUG_FORTH_MATHS 
39a4						DMARK "DI1" 
39a4				CALLMONITOR 
39a4					endif 
39a4			 
39a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a4 cd c8 21			call macro_forth_dsp_pop 
39a7				endm 
# End of macro FORTH_DSP_POP
39a7			 
39a7			 
39a7			 
39a7 e1					pop hl    ; result 
39a8			 
39a8 cd 19 1f				call forth_push_numhl 
39ab			 
39ab e1					pop hl    ; reminder 
39ac			;		ld h,0 
39ac			;		ld l,d 
39ac			 
39ac cd 19 1f				call forth_push_numhl 
39af			.div_done: 
39af					NEXTW 
39af c3 87 22			jp macro_next 
39b2				endm 
# End of macro NEXTW
39b2			.MUL: 
39b2				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
39b2 19				db WORD_SYS_CORE+5             
39b3 f7 39			dw .MIN            
39b5 02				db 1 + 1 
39b6 .. 00			db "*",0              
39b8				endm 
# End of macro CWHEAD
39b8			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
39b8				; TODO add floating point number detection 
39b8					if DEBUG_FORTH_WORDS_KEY 
39b8						DMARK "MUL" 
39b8 f5				push af  
39b9 3a cd 39			ld a, (.dmark)  
39bc 32 6e fe			ld (debug_mark),a  
39bf 3a ce 39			ld a, (.dmark+1)  
39c2 32 6f fe			ld (debug_mark+1),a  
39c5 3a cf 39			ld a, (.dmark+2)  
39c8 32 70 fe			ld (debug_mark+2),a  
39cb 18 03			jr .pastdmark  
39cd ..			.dmark: db "MUL"  
39d0 f1			.pastdmark: pop af  
39d1			endm  
# End of macro DMARK
39d1						CALLMONITOR 
39d1 cd a5 18			call break_point_state  
39d4				endm  
# End of macro CALLMONITOR
39d4					endif 
39d4					FORTH_DSP 
39d4 cd d6 20			call macro_forth_dsp 
39d7				endm 
# End of macro FORTH_DSP
39d7					; v5 FORTH_DSP_VALUE 
39d7 7e					ld a,(hl)	; get type of value on TOS 
39d8 fe 02				cp DS_TYPE_INUM  
39da 28 03				jr z, .mul_inum 
39dc			 
39dc				if FORTH_ENABLE_FLOATMATH 
39dc					jr .mul_done 
39dc			 
39dc				endif 
39dc			 
39dc					NEXTW 
39dc c3 87 22			jp macro_next 
39df				endm 
# End of macro NEXTW
39df			.mul_inum:	 
39df			 
39df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39df cd 10 21			call macro_dsp_valuehl 
39e2				endm 
# End of macro FORTH_DSP_VALUEHL
39e2			 
39e2 e5					push hl 
39e3			 
39e3					; destroy value TOS 
39e3			 
39e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e3 cd c8 21			call macro_forth_dsp_pop 
39e6				endm 
# End of macro FORTH_DSP_POP
39e6			 
39e6			 
39e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e6 cd 10 21			call macro_dsp_valuehl 
39e9				endm 
# End of macro FORTH_DSP_VALUEHL
39e9			 
39e9					; one value on hl but move to a get other one back 
39e9			 
39e9 7d					ld a, l 
39ea			 
39ea d1					pop de 
39eb			 
39eb					; do the mull 
39eb			;		ex de, hl 
39eb			 
39eb cd 81 0e				call Mult16 
39ee					; save it 
39ee			 
39ee			;		push hl	 
39ee			 
39ee					; 
39ee			 
39ee					; destroy value TOS 
39ee			 
39ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ee cd c8 21			call macro_forth_dsp_pop 
39f1				endm 
# End of macro FORTH_DSP_POP
39f1			 
39f1					; TODO push value back onto stack for another op etc 
39f1			 
39f1			;		pop hl 
39f1			 
39f1 cd 19 1f				call forth_push_numhl 
39f4			 
39f4			.mul_done: 
39f4					NEXTW 
39f4 c3 87 22			jp macro_next 
39f7				endm 
# End of macro NEXTW
39f7			 
39f7			 
39f7			 
39f7			 
39f7			.MIN: 
39f7				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
39f7 49				db WORD_SYS_CORE+53             
39f8 78 3a			dw .MAX            
39fa 04				db 3 + 1 
39fb .. 00			db "MIN",0              
39ff				endm 
# End of macro CWHEAD
39ff			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
39ff					if DEBUG_FORTH_WORDS_KEY 
39ff						DMARK "MIN" 
39ff f5				push af  
3a00 3a 14 3a			ld a, (.dmark)  
3a03 32 6e fe			ld (debug_mark),a  
3a06 3a 15 3a			ld a, (.dmark+1)  
3a09 32 6f fe			ld (debug_mark+1),a  
3a0c 3a 16 3a			ld a, (.dmark+2)  
3a0f 32 70 fe			ld (debug_mark+2),a  
3a12 18 03			jr .pastdmark  
3a14 ..			.dmark: db "MIN"  
3a17 f1			.pastdmark: pop af  
3a18			endm  
# End of macro DMARK
3a18						CALLMONITOR 
3a18 cd a5 18			call break_point_state  
3a1b				endm  
# End of macro CALLMONITOR
3a1b					endif 
3a1b					; get u2 
3a1b			 
3a1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a1b cd 10 21			call macro_dsp_valuehl 
3a1e				endm 
# End of macro FORTH_DSP_VALUEHL
3a1e			 
3a1e e5					push hl   ; u2 
3a1f			 
3a1f					; destroy value TOS 
3a1f			 
3a1f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a1f cd c8 21			call macro_forth_dsp_pop 
3a22				endm 
# End of macro FORTH_DSP_POP
3a22			 
3a22					; get u1 
3a22			 
3a22					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a22 cd 10 21			call macro_dsp_valuehl 
3a25				endm 
# End of macro FORTH_DSP_VALUEHL
3a25			 
3a25 e5					push hl  ; u1 
3a26			 
3a26					; destroy value TOS 
3a26			 
3a26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a26 cd c8 21			call macro_forth_dsp_pop 
3a29				endm 
# End of macro FORTH_DSP_POP
3a29			 
3a29 b7			 or a      ;clear carry flag 
3a2a e1			  pop hl    ; u1 
3a2b d1			  pop de    ; u2 
3a2c e5				push hl   ; saved in case hl is lowest 
3a2d ed 52		  sbc hl,de 
3a2f 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3a31			 
3a31 e1				pop hl 
3a32					if DEBUG_FORTH_WORDS 
3a32						DMARK "MIN" 
3a32 f5				push af  
3a33 3a 47 3a			ld a, (.dmark)  
3a36 32 6e fe			ld (debug_mark),a  
3a39 3a 48 3a			ld a, (.dmark+1)  
3a3c 32 6f fe			ld (debug_mark+1),a  
3a3f 3a 49 3a			ld a, (.dmark+2)  
3a42 32 70 fe			ld (debug_mark+2),a  
3a45 18 03			jr .pastdmark  
3a47 ..			.dmark: db "MIN"  
3a4a f1			.pastdmark: pop af  
3a4b			endm  
# End of macro DMARK
3a4b						CALLMONITOR 
3a4b cd a5 18			call break_point_state  
3a4e				endm  
# End of macro CALLMONITOR
3a4e					endif 
3a4e cd 19 1f				call forth_push_numhl 
3a51			 
3a51				       NEXTW 
3a51 c3 87 22			jp macro_next 
3a54				endm 
# End of macro NEXTW
3a54			 
3a54			.mincont:  
3a54 c1				pop bc   ; tidy up 
3a55 eb				ex de , hl  
3a56					if DEBUG_FORTH_WORDS 
3a56						DMARK "MI1" 
3a56 f5				push af  
3a57 3a 6b 3a			ld a, (.dmark)  
3a5a 32 6e fe			ld (debug_mark),a  
3a5d 3a 6c 3a			ld a, (.dmark+1)  
3a60 32 6f fe			ld (debug_mark+1),a  
3a63 3a 6d 3a			ld a, (.dmark+2)  
3a66 32 70 fe			ld (debug_mark+2),a  
3a69 18 03			jr .pastdmark  
3a6b ..			.dmark: db "MI1"  
3a6e f1			.pastdmark: pop af  
3a6f			endm  
# End of macro DMARK
3a6f						CALLMONITOR 
3a6f cd a5 18			call break_point_state  
3a72				endm  
# End of macro CALLMONITOR
3a72					endif 
3a72 cd 19 1f				call forth_push_numhl 
3a75			 
3a75				       NEXTW 
3a75 c3 87 22			jp macro_next 
3a78				endm 
# End of macro NEXTW
3a78			.MAX: 
3a78				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3a78 4a				db WORD_SYS_CORE+54             
3a79 f9 3a			dw .RND16            
3a7b 04				db 3 + 1 
3a7c .. 00			db "MAX",0              
3a80				endm 
# End of macro CWHEAD
3a80			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3a80					if DEBUG_FORTH_WORDS_KEY 
3a80						DMARK "MAX" 
3a80 f5				push af  
3a81 3a 95 3a			ld a, (.dmark)  
3a84 32 6e fe			ld (debug_mark),a  
3a87 3a 96 3a			ld a, (.dmark+1)  
3a8a 32 6f fe			ld (debug_mark+1),a  
3a8d 3a 97 3a			ld a, (.dmark+2)  
3a90 32 70 fe			ld (debug_mark+2),a  
3a93 18 03			jr .pastdmark  
3a95 ..			.dmark: db "MAX"  
3a98 f1			.pastdmark: pop af  
3a99			endm  
# End of macro DMARK
3a99						CALLMONITOR 
3a99 cd a5 18			call break_point_state  
3a9c				endm  
# End of macro CALLMONITOR
3a9c					endif 
3a9c					; get u2 
3a9c			 
3a9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9c cd 10 21			call macro_dsp_valuehl 
3a9f				endm 
# End of macro FORTH_DSP_VALUEHL
3a9f			 
3a9f e5					push hl   ; u2 
3aa0			 
3aa0					; destroy value TOS 
3aa0			 
3aa0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa0 cd c8 21			call macro_forth_dsp_pop 
3aa3				endm 
# End of macro FORTH_DSP_POP
3aa3			 
3aa3					; get u1 
3aa3			 
3aa3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa3 cd 10 21			call macro_dsp_valuehl 
3aa6				endm 
# End of macro FORTH_DSP_VALUEHL
3aa6			 
3aa6 e5					push hl  ; u1 
3aa7			 
3aa7					; destroy value TOS 
3aa7			 
3aa7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa7 cd c8 21			call macro_forth_dsp_pop 
3aaa				endm 
# End of macro FORTH_DSP_POP
3aaa			 
3aaa b7			 or a      ;clear carry flag 
3aab e1			  pop hl    ; u1 
3aac d1			  pop de    ; u2 
3aad e5				push hl   ; saved in case hl is lowest 
3aae ed 52		  sbc hl,de 
3ab0 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3ab2			 
3ab2 e1				pop hl 
3ab3					if DEBUG_FORTH_WORDS 
3ab3						DMARK "MAX" 
3ab3 f5				push af  
3ab4 3a c8 3a			ld a, (.dmark)  
3ab7 32 6e fe			ld (debug_mark),a  
3aba 3a c9 3a			ld a, (.dmark+1)  
3abd 32 6f fe			ld (debug_mark+1),a  
3ac0 3a ca 3a			ld a, (.dmark+2)  
3ac3 32 70 fe			ld (debug_mark+2),a  
3ac6 18 03			jr .pastdmark  
3ac8 ..			.dmark: db "MAX"  
3acb f1			.pastdmark: pop af  
3acc			endm  
# End of macro DMARK
3acc						CALLMONITOR 
3acc cd a5 18			call break_point_state  
3acf				endm  
# End of macro CALLMONITOR
3acf					endif 
3acf cd 19 1f				call forth_push_numhl 
3ad2			 
3ad2				       NEXTW 
3ad2 c3 87 22			jp macro_next 
3ad5				endm 
# End of macro NEXTW
3ad5			 
3ad5			.maxcont:  
3ad5 c1				pop bc   ; tidy up 
3ad6 eb				ex de , hl  
3ad7					if DEBUG_FORTH_WORDS 
3ad7						DMARK "MA1" 
3ad7 f5				push af  
3ad8 3a ec 3a			ld a, (.dmark)  
3adb 32 6e fe			ld (debug_mark),a  
3ade 3a ed 3a			ld a, (.dmark+1)  
3ae1 32 6f fe			ld (debug_mark+1),a  
3ae4 3a ee 3a			ld a, (.dmark+2)  
3ae7 32 70 fe			ld (debug_mark+2),a  
3aea 18 03			jr .pastdmark  
3aec ..			.dmark: db "MA1"  
3aef f1			.pastdmark: pop af  
3af0			endm  
# End of macro DMARK
3af0						CALLMONITOR 
3af0 cd a5 18			call break_point_state  
3af3				endm  
# End of macro CALLMONITOR
3af3					endif 
3af3 cd 19 1f				call forth_push_numhl 
3af6				       NEXTW 
3af6 c3 87 22			jp macro_next 
3af9				endm 
# End of macro NEXTW
3af9			 
3af9			.RND16: 
3af9				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3af9 4e				db WORD_SYS_CORE+58             
3afa 28 3b			dw .RND8            
3afc 06				db 5 + 1 
3afd .. 00			db "RND16",0              
3b03				endm 
# End of macro CWHEAD
3b03			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3b03					if DEBUG_FORTH_WORDS_KEY 
3b03						DMARK "R16" 
3b03 f5				push af  
3b04 3a 18 3b			ld a, (.dmark)  
3b07 32 6e fe			ld (debug_mark),a  
3b0a 3a 19 3b			ld a, (.dmark+1)  
3b0d 32 6f fe			ld (debug_mark+1),a  
3b10 3a 1a 3b			ld a, (.dmark+2)  
3b13 32 70 fe			ld (debug_mark+2),a  
3b16 18 03			jr .pastdmark  
3b18 ..			.dmark: db "R16"  
3b1b f1			.pastdmark: pop af  
3b1c			endm  
# End of macro DMARK
3b1c						CALLMONITOR 
3b1c cd a5 18			call break_point_state  
3b1f				endm  
# End of macro CALLMONITOR
3b1f					endif 
3b1f cd 25 0e				call prng16  
3b22 cd 19 1f				call forth_push_numhl 
3b25				       NEXTW 
3b25 c3 87 22			jp macro_next 
3b28				endm 
# End of macro NEXTW
3b28			.RND8: 
3b28				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3b28 60				db WORD_SYS_CORE+76             
3b29 5d 3b			dw .RND            
3b2b 05				db 4 + 1 
3b2c .. 00			db "RND8",0              
3b31				endm 
# End of macro CWHEAD
3b31			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3b31					if DEBUG_FORTH_WORDS_KEY 
3b31						DMARK "RN8" 
3b31 f5				push af  
3b32 3a 46 3b			ld a, (.dmark)  
3b35 32 6e fe			ld (debug_mark),a  
3b38 3a 47 3b			ld a, (.dmark+1)  
3b3b 32 6f fe			ld (debug_mark+1),a  
3b3e 3a 48 3b			ld a, (.dmark+2)  
3b41 32 70 fe			ld (debug_mark+2),a  
3b44 18 03			jr .pastdmark  
3b46 ..			.dmark: db "RN8"  
3b49 f1			.pastdmark: pop af  
3b4a			endm  
# End of macro DMARK
3b4a						CALLMONITOR 
3b4a cd a5 18			call break_point_state  
3b4d				endm  
# End of macro CALLMONITOR
3b4d					endif 
3b4d 2a af fb				ld hl,(xrandc) 
3b50 23					inc hl 
3b51 cd 3f 0e				call xrnd 
3b54 6f					ld l,a	 
3b55 26 00				ld h,0 
3b57 cd 19 1f				call forth_push_numhl 
3b5a				       NEXTW 
3b5a c3 87 22			jp macro_next 
3b5d				endm 
# End of macro NEXTW
3b5d			.RND: 
3b5d				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3b5d 60				db WORD_SYS_CORE+76             
3b5e 63 3c			dw .ENDMATHS            
3b60 04				db 3 + 1 
3b61 .. 00			db "RND",0              
3b65				endm 
# End of macro CWHEAD
3b65			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3b65			 
3b65					if DEBUG_FORTH_WORDS_KEY 
3b65						DMARK "RND" 
3b65 f5				push af  
3b66 3a 7a 3b			ld a, (.dmark)  
3b69 32 6e fe			ld (debug_mark),a  
3b6c 3a 7b 3b			ld a, (.dmark+1)  
3b6f 32 6f fe			ld (debug_mark+1),a  
3b72 3a 7c 3b			ld a, (.dmark+2)  
3b75 32 70 fe			ld (debug_mark+2),a  
3b78 18 03			jr .pastdmark  
3b7a ..			.dmark: db "RND"  
3b7d f1			.pastdmark: pop af  
3b7e			endm  
# End of macro DMARK
3b7e						CALLMONITOR 
3b7e cd a5 18			call break_point_state  
3b81				endm  
# End of macro CALLMONITOR
3b81					endif 
3b81					 
3b81					FORTH_DSP_VALUEHL    ; upper range 
3b81 cd 10 21			call macro_dsp_valuehl 
3b84				endm 
# End of macro FORTH_DSP_VALUEHL
3b84			 
3b84 22 b3 fb				ld (LFSRSeed), hl	 
3b87			 
3b87					if DEBUG_FORTH_WORDS 
3b87						DMARK "RN1" 
3b87 f5				push af  
3b88 3a 9c 3b			ld a, (.dmark)  
3b8b 32 6e fe			ld (debug_mark),a  
3b8e 3a 9d 3b			ld a, (.dmark+1)  
3b91 32 6f fe			ld (debug_mark+1),a  
3b94 3a 9e 3b			ld a, (.dmark+2)  
3b97 32 70 fe			ld (debug_mark+2),a  
3b9a 18 03			jr .pastdmark  
3b9c ..			.dmark: db "RN1"  
3b9f f1			.pastdmark: pop af  
3ba0			endm  
# End of macro DMARK
3ba0						CALLMONITOR 
3ba0 cd a5 18			call break_point_state  
3ba3				endm  
# End of macro CALLMONITOR
3ba3					endif 
3ba3					FORTH_DSP_POP 
3ba3 cd c8 21			call macro_forth_dsp_pop 
3ba6				endm 
# End of macro FORTH_DSP_POP
3ba6			 
3ba6					FORTH_DSP_VALUEHL    ; low range 
3ba6 cd 10 21			call macro_dsp_valuehl 
3ba9				endm 
# End of macro FORTH_DSP_VALUEHL
3ba9			 
3ba9					if DEBUG_FORTH_WORDS 
3ba9						DMARK "RN2" 
3ba9 f5				push af  
3baa 3a be 3b			ld a, (.dmark)  
3bad 32 6e fe			ld (debug_mark),a  
3bb0 3a bf 3b			ld a, (.dmark+1)  
3bb3 32 6f fe			ld (debug_mark+1),a  
3bb6 3a c0 3b			ld a, (.dmark+2)  
3bb9 32 70 fe			ld (debug_mark+2),a  
3bbc 18 03			jr .pastdmark  
3bbe ..			.dmark: db "RN2"  
3bc1 f1			.pastdmark: pop af  
3bc2			endm  
# End of macro DMARK
3bc2						CALLMONITOR 
3bc2 cd a5 18			call break_point_state  
3bc5				endm  
# End of macro CALLMONITOR
3bc5					endif 
3bc5 22 b5 fb				ld (LFSRSeed+2), hl 
3bc8			 
3bc8					FORTH_DSP_POP 
3bc8 cd c8 21			call macro_forth_dsp_pop 
3bcb				endm 
# End of macro FORTH_DSP_POP
3bcb			 
3bcb e5					push hl 
3bcc			 
3bcc e1			.inrange:	pop hl 
3bcd cd 25 0e				call prng16  
3bd0					if DEBUG_FORTH_WORDS 
3bd0						DMARK "RN3" 
3bd0 f5				push af  
3bd1 3a e5 3b			ld a, (.dmark)  
3bd4 32 6e fe			ld (debug_mark),a  
3bd7 3a e6 3b			ld a, (.dmark+1)  
3bda 32 6f fe			ld (debug_mark+1),a  
3bdd 3a e7 3b			ld a, (.dmark+2)  
3be0 32 70 fe			ld (debug_mark+2),a  
3be3 18 03			jr .pastdmark  
3be5 ..			.dmark: db "RN3"  
3be8 f1			.pastdmark: pop af  
3be9			endm  
# End of macro DMARK
3be9						CALLMONITOR 
3be9 cd a5 18			call break_point_state  
3bec				endm  
# End of macro CALLMONITOR
3bec					endif 
3bec					 
3bec					; if the range is 8bit knock out the high byte 
3bec			 
3bec ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3bf0			 
3bf0 3e 00				ld a, 0 
3bf2 ba					cp d  
3bf3 20 1e				jr nz, .hirange 
3bf5 26 00				ld h, 0   ; knock it down to 8bit 
3bf7			 
3bf7					if DEBUG_FORTH_WORDS 
3bf7						DMARK "RNk" 
3bf7 f5				push af  
3bf8 3a 0c 3c			ld a, (.dmark)  
3bfb 32 6e fe			ld (debug_mark),a  
3bfe 3a 0d 3c			ld a, (.dmark+1)  
3c01 32 6f fe			ld (debug_mark+1),a  
3c04 3a 0e 3c			ld a, (.dmark+2)  
3c07 32 70 fe			ld (debug_mark+2),a  
3c0a 18 03			jr .pastdmark  
3c0c ..			.dmark: db "RNk"  
3c0f f1			.pastdmark: pop af  
3c10			endm  
# End of macro DMARK
3c10						CALLMONITOR 
3c10 cd a5 18			call break_point_state  
3c13				endm  
# End of macro CALLMONITOR
3c13					endif 
3c13			.hirange:   
3c13 e5					push hl  
3c14 b7					or a  
3c15 ed 52		                sbc hl, de 
3c17			 
3c17					;call cmp16 
3c17			 
3c17 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3c19 e1					pop hl 
3c1a e5					push hl 
3c1b			 
3c1b					if DEBUG_FORTH_WORDS 
3c1b						DMARK "RN4" 
3c1b f5				push af  
3c1c 3a 30 3c			ld a, (.dmark)  
3c1f 32 6e fe			ld (debug_mark),a  
3c22 3a 31 3c			ld a, (.dmark+1)  
3c25 32 6f fe			ld (debug_mark+1),a  
3c28 3a 32 3c			ld a, (.dmark+2)  
3c2b 32 70 fe			ld (debug_mark+2),a  
3c2e 18 03			jr .pastdmark  
3c30 ..			.dmark: db "RN4"  
3c33 f1			.pastdmark: pop af  
3c34			endm  
# End of macro DMARK
3c34						CALLMONITOR 
3c34 cd a5 18			call break_point_state  
3c37				endm  
# End of macro CALLMONITOR
3c37					endif 
3c37 ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3c3b					;call cmp16 
3c3b				 
3c3b b7					or a  
3c3c ed 52		                sbc hl, de 
3c3e 38 8c				jr c, .inrange 
3c40			 
3c40 e1					pop hl 
3c41					 
3c41					if DEBUG_FORTH_WORDS 
3c41						DMARK "RNd" 
3c41 f5				push af  
3c42 3a 56 3c			ld a, (.dmark)  
3c45 32 6e fe			ld (debug_mark),a  
3c48 3a 57 3c			ld a, (.dmark+1)  
3c4b 32 6f fe			ld (debug_mark+1),a  
3c4e 3a 58 3c			ld a, (.dmark+2)  
3c51 32 70 fe			ld (debug_mark+2),a  
3c54 18 03			jr .pastdmark  
3c56 ..			.dmark: db "RNd"  
3c59 f1			.pastdmark: pop af  
3c5a			endm  
# End of macro DMARK
3c5a						CALLMONITOR 
3c5a cd a5 18			call break_point_state  
3c5d				endm  
# End of macro CALLMONITOR
3c5d					endif 
3c5d			 
3c5d			 
3c5d cd 19 1f				call forth_push_numhl 
3c60				       NEXTW 
3c60 c3 87 22			jp macro_next 
3c63				endm 
# End of macro NEXTW
3c63			 
3c63			.ENDMATHS: 
3c63			 
3c63			; eof 
3c63			 
# End of file forth_words_maths.asm
3c63			include "forth_words_display.asm" 
3c63			 
3c63			; | ## Display Words 
3c63			 
3c63			.INFO: 
3c63			 
3c63				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3c63 62				db WORD_SYS_CORE+78             
3c64 80 3c			dw .ATP            
3c66 05				db 4 + 1 
3c67 .. 00			db "INFO",0              
3c6c				endm 
# End of macro CWHEAD
3c6c			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3c6c					FORTH_DSP_VALUEHL 
3c6c cd 10 21			call macro_dsp_valuehl 
3c6f				endm 
# End of macro FORTH_DSP_VALUEHL
3c6f			 
3c6f					FORTH_DSP_POP 
3c6f cd c8 21			call macro_forth_dsp_pop 
3c72				endm 
# End of macro FORTH_DSP_POP
3c72			 
3c72 e5					push hl 
3c73			 
3c73					FORTH_DSP_VALUEHL 
3c73 cd 10 21			call macro_dsp_valuehl 
3c76				endm 
# End of macro FORTH_DSP_VALUEHL
3c76			 
3c76					FORTH_DSP_POP 
3c76 cd c8 21			call macro_forth_dsp_pop 
3c79				endm 
# End of macro FORTH_DSP_POP
3c79			 
3c79 d1					pop de 
3c7a			 
3c7a cd 5b 0c				call info_panel 
3c7d			 
3c7d			 
3c7d					NEXTW 
3c7d c3 87 22			jp macro_next 
3c80				endm 
# End of macro NEXTW
3c80			.ATP: 
3c80				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3c80 62				db WORD_SYS_CORE+78             
3c81 f7 3c			dw .FB            
3c83 04				db 3 + 1 
3c84 .. 00			db "AT?",0              
3c88				endm 
# End of macro CWHEAD
3c88			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3c88					if DEBUG_FORTH_WORDS_KEY 
3c88						DMARK "AT?" 
3c88 f5				push af  
3c89 3a 9d 3c			ld a, (.dmark)  
3c8c 32 6e fe			ld (debug_mark),a  
3c8f 3a 9e 3c			ld a, (.dmark+1)  
3c92 32 6f fe			ld (debug_mark+1),a  
3c95 3a 9f 3c			ld a, (.dmark+2)  
3c98 32 70 fe			ld (debug_mark+2),a  
3c9b 18 03			jr .pastdmark  
3c9d ..			.dmark: db "AT?"  
3ca0 f1			.pastdmark: pop af  
3ca1			endm  
# End of macro DMARK
3ca1						CALLMONITOR 
3ca1 cd a5 18			call break_point_state  
3ca4				endm  
# End of macro CALLMONITOR
3ca4					endif 
3ca4 3a 68 fa				ld a, (f_cursor_ptr) 
3ca7			 
3ca7			if DEBUG_FORTH_WORDS 
3ca7				DMARK "AT?" 
3ca7 f5				push af  
3ca8 3a bc 3c			ld a, (.dmark)  
3cab 32 6e fe			ld (debug_mark),a  
3cae 3a bd 3c			ld a, (.dmark+1)  
3cb1 32 6f fe			ld (debug_mark+1),a  
3cb4 3a be 3c			ld a, (.dmark+2)  
3cb7 32 70 fe			ld (debug_mark+2),a  
3cba 18 03			jr .pastdmark  
3cbc ..			.dmark: db "AT?"  
3cbf f1			.pastdmark: pop af  
3cc0			endm  
# End of macro DMARK
3cc0				CALLMONITOR 
3cc0 cd a5 18			call break_point_state  
3cc3				endm  
# End of macro CALLMONITOR
3cc3			endif	 
3cc3					; count the number of rows 
3cc3			 
3cc3 06 00				ld b, 0 
3cc5 4f			.atpr:		ld c, a    ; save in case we go below zero 
3cc6 d6 28				sub display_cols 
3cc8 f2 ce 3c				jp p, .atprunder 
3ccb 04					inc b 
3ccc 18 f7				jr .atpr 
3cce			.atprunder:	 
3cce			if DEBUG_FORTH_WORDS 
3cce				DMARK "A?2" 
3cce f5				push af  
3ccf 3a e3 3c			ld a, (.dmark)  
3cd2 32 6e fe			ld (debug_mark),a  
3cd5 3a e4 3c			ld a, (.dmark+1)  
3cd8 32 6f fe			ld (debug_mark+1),a  
3cdb 3a e5 3c			ld a, (.dmark+2)  
3cde 32 70 fe			ld (debug_mark+2),a  
3ce1 18 03			jr .pastdmark  
3ce3 ..			.dmark: db "A?2"  
3ce6 f1			.pastdmark: pop af  
3ce7			endm  
# End of macro DMARK
3ce7				CALLMONITOR 
3ce7 cd a5 18			call break_point_state  
3cea				endm  
# End of macro CALLMONITOR
3cea			endif	 
3cea 26 00				ld h, 0 
3cec 69					ld l, c 
3ced cd 19 1f				call forth_push_numhl 
3cf0 68					ld l, b  
3cf1 cd 19 1f				call forth_push_numhl 
3cf4			 
3cf4			 
3cf4				NEXTW 
3cf4 c3 87 22			jp macro_next 
3cf7				endm 
# End of macro NEXTW
3cf7			 
3cf7			.FB: 
3cf7				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3cf7 1b				db WORD_SYS_CORE+7             
3cf8 45 3d			dw .EMIT            
3cfa 03				db 2 + 1 
3cfb .. 00			db "FB",0              
3cfe				endm 
# End of macro CWHEAD
3cfe			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3cfe			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3cfe			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3cfe			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3cfe					if DEBUG_FORTH_WORDS_KEY 
3cfe						DMARK "FB." 
3cfe f5				push af  
3cff 3a 13 3d			ld a, (.dmark)  
3d02 32 6e fe			ld (debug_mark),a  
3d05 3a 14 3d			ld a, (.dmark+1)  
3d08 32 6f fe			ld (debug_mark+1),a  
3d0b 3a 15 3d			ld a, (.dmark+2)  
3d0e 32 70 fe			ld (debug_mark+2),a  
3d11 18 03			jr .pastdmark  
3d13 ..			.dmark: db "FB."  
3d16 f1			.pastdmark: pop af  
3d17			endm  
# End of macro DMARK
3d17						CALLMONITOR 
3d17 cd a5 18			call break_point_state  
3d1a				endm  
# End of macro CALLMONITOR
3d1a					endif 
3d1a			 
3d1a					FORTH_DSP_VALUEHL 
3d1a cd 10 21			call macro_dsp_valuehl 
3d1d				endm 
# End of macro FORTH_DSP_VALUEHL
3d1d			 
3d1d 7d					ld a, l 
3d1e fe 01				cp 1 
3d20 20 05				jr nz, .fbn1 
3d22 21 13 fd				ld hl, display_fb1 
3d25 18 15				jr .fbset 
3d27 fe 02		.fbn1:		cp 2 
3d29 20 05				jr nz, .fbn2 
3d2b 21 d1 fb				ld hl, display_fb2 
3d2e 18 0c				jr .fbset 
3d30 fe 03		.fbn2:		cp 3 
3d32 20 05				jr nz, .fbn3 
3d34 21 72 fc				ld hl, display_fb3 
3d37 18 03				jr .fbset 
3d39			.fbn3:		 ; if invalid number select first 
3d39 21 13 fd				ld hl, display_fb1 
3d3c 22 cf fb		.fbset:		ld (display_fb_active), hl 
3d3f			 
3d3f					FORTH_DSP_POP 
3d3f cd c8 21			call macro_forth_dsp_pop 
3d42				endm 
# End of macro FORTH_DSP_POP
3d42			 
3d42					NEXTW 
3d42 c3 87 22			jp macro_next 
3d45				endm 
# End of macro NEXTW
3d45			 
3d45			 
3d45			.EMIT: 
3d45				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3d45 1b				db WORD_SYS_CORE+7             
3d46 96 3d			dw .DOTH            
3d48 05				db 4 + 1 
3d49 .. 00			db "EMIT",0              
3d4e				endm 
# End of macro CWHEAD
3d4e			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3d4e					; get value off TOS and display it 
3d4e			 
3d4e					if DEBUG_FORTH_WORDS_KEY 
3d4e						DMARK "EMT" 
3d4e f5				push af  
3d4f 3a 63 3d			ld a, (.dmark)  
3d52 32 6e fe			ld (debug_mark),a  
3d55 3a 64 3d			ld a, (.dmark+1)  
3d58 32 6f fe			ld (debug_mark+1),a  
3d5b 3a 65 3d			ld a, (.dmark+2)  
3d5e 32 70 fe			ld (debug_mark+2),a  
3d61 18 03			jr .pastdmark  
3d63 ..			.dmark: db "EMT"  
3d66 f1			.pastdmark: pop af  
3d67			endm  
# End of macro DMARK
3d67						CALLMONITOR 
3d67 cd a5 18			call break_point_state  
3d6a				endm  
# End of macro CALLMONITOR
3d6a					endif 
3d6a			 
3d6a					FORTH_DSP_VALUEHL 
3d6a cd 10 21			call macro_dsp_valuehl 
3d6d				endm 
# End of macro FORTH_DSP_VALUEHL
3d6d			 
3d6d 7d					ld a,l 
3d6e			 
3d6e					; TODO write to display 
3d6e			 
3d6e 32 fd f3				ld (os_input), a 
3d71 3e 00				ld a, 0 
3d73 32 fe f3				ld (os_input+1), a 
3d76					 
3d76 3a 68 fa				ld a, (f_cursor_ptr) 
3d79 11 fd f3				ld de, os_input 
3d7c cd dd 0c				call str_at_display 
3d7f			 
3d7f			 
3d7f 3a 46 fa				ld a,(cli_autodisplay) 
3d82 fe 00				cp 0 
3d84 28 03				jr z, .enoupdate 
3d86 cd ed 0c						call update_display 
3d89					.enoupdate: 
3d89			 
3d89 3a 68 fa				ld a, (f_cursor_ptr) 
3d8c 3c					inc a 
3d8d 32 68 fa				ld (f_cursor_ptr), a   ; save new pos 
3d90			 
3d90			 
3d90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d90 cd c8 21			call macro_forth_dsp_pop 
3d93				endm 
# End of macro FORTH_DSP_POP
3d93			  
3d93			 
3d93					NEXTW 
3d93 c3 87 22			jp macro_next 
3d96				endm 
# End of macro NEXTW
3d96			.DOTH: 
3d96				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3d96 1c				db WORD_SYS_CORE+8             
3d97 c6 3d			dw .DOTF            
3d99 03				db 2 + 1 
3d9a .. 00			db ".-",0              
3d9d				endm 
# End of macro CWHEAD
3d9d			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3d9d					; get value off TOS and display it 
3d9d					if DEBUG_FORTH_WORDS_KEY 
3d9d						DMARK "DTD" 
3d9d f5				push af  
3d9e 3a b2 3d			ld a, (.dmark)  
3da1 32 6e fe			ld (debug_mark),a  
3da4 3a b3 3d			ld a, (.dmark+1)  
3da7 32 6f fe			ld (debug_mark+1),a  
3daa 3a b4 3d			ld a, (.dmark+2)  
3dad 32 70 fe			ld (debug_mark+2),a  
3db0 18 03			jr .pastdmark  
3db2 ..			.dmark: db "DTD"  
3db5 f1			.pastdmark: pop af  
3db6			endm  
# End of macro DMARK
3db6						CALLMONITOR 
3db6 cd a5 18			call break_point_state  
3db9				endm  
# End of macro CALLMONITOR
3db9					endif 
3db9 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3dbb 3e 00			ld a, 0 
3dbd 32 47 fa			ld (cli_mvdot), a 
3dc0 c3 1d 3e			jp .dotgo 
3dc3				NEXTW 
3dc3 c3 87 22			jp macro_next 
3dc6				endm 
# End of macro NEXTW
3dc6			.DOTF: 
3dc6				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3dc6 1c				db WORD_SYS_CORE+8             
3dc7 f4 3d			dw .DOT            
3dc9 03				db 2 + 1 
3dca .. 00			db ".>",0              
3dcd				endm 
# End of macro CWHEAD
3dcd			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3dcd					; get value off TOS and display it 
3dcd			        ; TODO BUG adds extra spaces 
3dcd			        ; TODO BUG handle numerics? 
3dcd					if DEBUG_FORTH_WORDS_KEY 
3dcd						DMARK "DTC" 
3dcd f5				push af  
3dce 3a e2 3d			ld a, (.dmark)  
3dd1 32 6e fe			ld (debug_mark),a  
3dd4 3a e3 3d			ld a, (.dmark+1)  
3dd7 32 6f fe			ld (debug_mark+1),a  
3dda 3a e4 3d			ld a, (.dmark+2)  
3ddd 32 70 fe			ld (debug_mark+2),a  
3de0 18 03			jr .pastdmark  
3de2 ..			.dmark: db "DTC"  
3de5 f1			.pastdmark: pop af  
3de6			endm  
# End of macro DMARK
3de6						CALLMONITOR 
3de6 cd a5 18			call break_point_state  
3de9				endm  
# End of macro CALLMONITOR
3de9					endif 
3de9 3e 01			ld a, 1 
3deb 32 47 fa			ld (cli_mvdot), a 
3dee c3 1d 3e			jp .dotgo 
3df1				NEXTW 
3df1 c3 87 22			jp macro_next 
3df4				endm 
# End of macro NEXTW
3df4			 
3df4			.DOT: 
3df4				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3df4 1c				db WORD_SYS_CORE+8             
3df5 80 3e			dw .CLS            
3df7 02				db 1 + 1 
3df8 .. 00			db ".",0              
3dfa				endm 
# End of macro CWHEAD
3dfa			        ; | . ( u -- ) Display TOS | DONE 
3dfa					; get value off TOS and display it 
3dfa			 
3dfa					if DEBUG_FORTH_WORDS_KEY 
3dfa						DMARK "DOT" 
3dfa f5				push af  
3dfb 3a 0f 3e			ld a, (.dmark)  
3dfe 32 6e fe			ld (debug_mark),a  
3e01 3a 10 3e			ld a, (.dmark+1)  
3e04 32 6f fe			ld (debug_mark+1),a  
3e07 3a 11 3e			ld a, (.dmark+2)  
3e0a 32 70 fe			ld (debug_mark+2),a  
3e0d 18 03			jr .pastdmark  
3e0f ..			.dmark: db "DOT"  
3e12 f1			.pastdmark: pop af  
3e13			endm  
# End of macro DMARK
3e13						CALLMONITOR 
3e13 cd a5 18			call break_point_state  
3e16				endm  
# End of macro CALLMONITOR
3e16					endif 
3e16 3e 00			ld a, 0 
3e18 32 47 fa			ld (cli_mvdot), a 
3e1b 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3e1d				 
3e1d			 
3e1d			.dotgo: 
3e1d			 
3e1d			; move up type to on stack for parserv5 
3e1d					FORTH_DSP 
3e1d cd d6 20			call macro_forth_dsp 
3e20				endm 
# End of macro FORTH_DSP
3e20				;FORTH_DSP_VALUE  
3e20			 
3e20			if DEBUG_FORTH_DOT 
3e20				DMARK "DOT" 
3e20				CALLMONITOR 
3e20			endif	 
3e20			;		.print: 
3e20			 
3e20 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3e21 23				inc hl   ; position to the actual value 
3e22 fe 01			cp DS_TYPE_STR 
3e24 20 06			jr nz, .dotnum1  
3e26			 
3e26			; display string 
3e26				FORTH_DSP_VALUE  
3e26 cd f9 20			call macro_forth_dsp_value 
3e29				endm 
# End of macro FORTH_DSP_VALUE
3e29 eb				ex de,hl 
3e2a 18 11			jr .dotwrite 
3e2c			 
3e2c			.dotnum1: 
3e2c fe 02			cp DS_TYPE_INUM 
3e2e 20 0c			jr nz, .dotflot 
3e30			 
3e30			 
3e30			; display number 
3e30			 
3e30			;	push hl 
3e30			;	call clear_display 
3e30			;	pop hl 
3e30			 
3e30 5e				ld e, (hl) 
3e31 23				inc hl 
3e32 56				ld d, (hl) 
3e33 21 ff f1			ld hl, scratch 
3e36			if DEBUG_FORTH_DOT 
3e36				DMARK "DT1" 
3e36				CALLMONITOR 
3e36			endif	 
3e36			 
3e36 cd 0b 13			call uitoa_16 
3e39 eb				ex de,hl 
3e3a			 
3e3a			if DEBUG_FORTH_DOT 
3e3a				DMARK "DT2" 
3e3a				CALLMONITOR 
3e3a			endif	 
3e3a			 
3e3a			;	ld de, os_word_scratch 
3e3a 18 01			jr .dotwrite 
3e3c			 
3e3c 00			.dotflot:   nop 
3e3d			; TODO print floating point number 
3e3d			 
3e3d			.dotwrite:		 
3e3d			 
3e3d					; if c is set then set all '-' to spaces 
3e3d					; need to also take into account .>  
3e3d			 
3e3d 3e 01				ld a, 1 
3e3f b9					cp c 
3e40 20 13				jr nz, .nodashswap 
3e42			 
3e42					; DE has the string to write, working with HL 
3e42			 
3e42 06 ff				ld b, 255 
3e44 d5					push de 
3e45 e1					pop hl 
3e46			 
3e46			if DEBUG_FORTH_DOT 
3e46				DMARK "DT-" 
3e46				CALLMONITOR 
3e46			endif	 
3e46 7e			.dashscan:	ld a, (hl) 
3e47 fe 00				cp 0 
3e49 28 0a				jr z, .nodashswap 
3e4b fe 2d				cp '-' 
3e4d 20 03				jr nz, .dashskip 
3e4f 3e 20				ld a, ' ' 
3e51 77					ld (hl), a 
3e52 23			.dashskip:	inc hl 
3e53			if DEBUG_FORTH_DOT 
3e53				DMARK "D-2" 
3e53				CALLMONITOR 
3e53			endif	 
3e53 10 f1				djnz .dashscan 
3e55			 
3e55			if DEBUG_FORTH_DOT 
3e55				DMARK "D-1" 
3e55				CALLMONITOR 
3e55			endif	 
3e55			 
3e55			.nodashswap: 
3e55			 
3e55 e5					push hl   ; save string start in case we need to advance print 
3e56			 
3e56 3a 68 fa				ld a, (f_cursor_ptr) 
3e59 cd dd 0c				call str_at_display 
3e5c 3a 46 fa				ld a,(cli_autodisplay) 
3e5f fe 00				cp 0 
3e61 28 03				jr z, .noupdate 
3e63 cd ed 0c						call update_display 
3e66					.noupdate: 
3e66			 
3e66			 
3e66					; see if we need to advance the print position 
3e66			 
3e66 e1					pop hl   ; get back string 
3e67			 
3e67 3a 47 fa				ld a, (cli_mvdot) 
3e6a			if DEBUG_FORTH_DOT 
3e6a					ld e,a 
3e6a				DMARK "D>1" 
3e6a				CALLMONITOR 
3e6a			endif	 
3e6a fe 00				cp 0 
3e6c 28 0c				jr z, .noadv 
3e6e					; yes, lets advance the print position 
3e6e 3e 00				ld a, 0 
3e70 cd 67 13				call strlent 
3e73 3a 68 fa				ld a, (f_cursor_ptr) 
3e76 85					add a,l 
3e77					;call addatohl 
3e77					;ld a, l 
3e77 32 68 fa				ld (f_cursor_ptr), a   ; save new pos 
3e7a			 
3e7a			if DEBUG_FORTH_DOT 
3e7a				DMARK "D->" 
3e7a				CALLMONITOR 
3e7a			endif	 
3e7a			 
3e7a			.noadv:	 
3e7a			 
3e7a					if DEBUG_FORTH_DOT_WAIT 
3e7a							call next_page_prompt 
3e7a					endif	 
3e7a			; TODO this pop off the stack causes a crash. i dont know why 
3e7a			 
3e7a			 
3e7a			if DEBUG_FORTH_DOT 
3e7a				DMARK "DTh" 
3e7a				CALLMONITOR 
3e7a			endif	 
3e7a			 
3e7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e7a cd c8 21			call macro_forth_dsp_pop 
3e7d				endm 
# End of macro FORTH_DSP_POP
3e7d			 
3e7d			if DEBUG_FORTH_DOT 
3e7d				DMARK "DTi" 
3e7d				CALLMONITOR 
3e7d			endif	 
3e7d			 
3e7d			 
3e7d					NEXTW 
3e7d c3 87 22			jp macro_next 
3e80				endm 
# End of macro NEXTW
3e80			 
3e80			.CLS: 
3e80				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e80 35				db WORD_SYS_CORE+33             
3e81 ad 3e			dw .DRAW            
3e83 04				db 3 + 1 
3e84 .. 00			db "CLS",0              
3e88				endm 
# End of macro CWHEAD
3e88			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e88					if DEBUG_FORTH_WORDS_KEY 
3e88						DMARK "CLS" 
3e88 f5				push af  
3e89 3a 9d 3e			ld a, (.dmark)  
3e8c 32 6e fe			ld (debug_mark),a  
3e8f 3a 9e 3e			ld a, (.dmark+1)  
3e92 32 6f fe			ld (debug_mark+1),a  
3e95 3a 9f 3e			ld a, (.dmark+2)  
3e98 32 70 fe			ld (debug_mark+2),a  
3e9b 18 03			jr .pastdmark  
3e9d ..			.dmark: db "CLS"  
3ea0 f1			.pastdmark: pop af  
3ea1			endm  
# End of macro DMARK
3ea1						CALLMONITOR 
3ea1 cd a5 18			call break_point_state  
3ea4				endm  
# End of macro CALLMONITOR
3ea4					endif 
3ea4 cd ca 0c				call clear_display 
3ea7 c3 bb 3f				jp .home		; and home cursor 
3eaa					NEXTW 
3eaa c3 87 22			jp macro_next 
3ead				endm 
# End of macro NEXTW
3ead			 
3ead			.DRAW: 
3ead				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3ead 36				db WORD_SYS_CORE+34             
3eae d8 3e			dw .DUMP            
3eb0 05				db 4 + 1 
3eb1 .. 00			db "DRAW",0              
3eb6				endm 
# End of macro CWHEAD
3eb6			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3eb6					if DEBUG_FORTH_WORDS_KEY 
3eb6						DMARK "DRW" 
3eb6 f5				push af  
3eb7 3a cb 3e			ld a, (.dmark)  
3eba 32 6e fe			ld (debug_mark),a  
3ebd 3a cc 3e			ld a, (.dmark+1)  
3ec0 32 6f fe			ld (debug_mark+1),a  
3ec3 3a cd 3e			ld a, (.dmark+2)  
3ec6 32 70 fe			ld (debug_mark+2),a  
3ec9 18 03			jr .pastdmark  
3ecb ..			.dmark: db "DRW"  
3ece f1			.pastdmark: pop af  
3ecf			endm  
# End of macro DMARK
3ecf						CALLMONITOR 
3ecf cd a5 18			call break_point_state  
3ed2				endm  
# End of macro CALLMONITOR
3ed2					endif 
3ed2 cd ed 0c				call update_display 
3ed5					NEXTW 
3ed5 c3 87 22			jp macro_next 
3ed8				endm 
# End of macro NEXTW
3ed8			 
3ed8			.DUMP: 
3ed8				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3ed8 37				db WORD_SYS_CORE+35             
3ed9 10 3f			dw .CDUMP            
3edb 05				db 4 + 1 
3edc .. 00			db "DUMP",0              
3ee1				endm 
# End of macro CWHEAD
3ee1			; | DUMP ( x -- ) With address x display dump   | DONE 
3ee1			; TODO pop address to use off of the stack 
3ee1					if DEBUG_FORTH_WORDS_KEY 
3ee1						DMARK "DUM" 
3ee1 f5				push af  
3ee2 3a f6 3e			ld a, (.dmark)  
3ee5 32 6e fe			ld (debug_mark),a  
3ee8 3a f7 3e			ld a, (.dmark+1)  
3eeb 32 6f fe			ld (debug_mark+1),a  
3eee 3a f8 3e			ld a, (.dmark+2)  
3ef1 32 70 fe			ld (debug_mark+2),a  
3ef4 18 03			jr .pastdmark  
3ef6 ..			.dmark: db "DUM"  
3ef9 f1			.pastdmark: pop af  
3efa			endm  
# End of macro DMARK
3efa						CALLMONITOR 
3efa cd a5 18			call break_point_state  
3efd				endm  
# End of macro CALLMONITOR
3efd					endif 
3efd cd ca 0c				call clear_display 
3f00			 
3f00					; get address 
3f00			 
3f00					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f00 cd 10 21			call macro_dsp_valuehl 
3f03				endm 
# End of macro FORTH_DSP_VALUEHL
3f03				 
3f03					; save it for cdump 
3f03			 
3f03 22 22 f5				ld (os_cur_ptr),hl 
3f06			 
3f06					; destroy value TOS 
3f06			 
3f06					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f06 cd c8 21			call macro_forth_dsp_pop 
3f09				endm 
# End of macro FORTH_DSP_POP
3f09			 
3f09 cd 99 1d				call dumpcont	; skip old style of param parsing	 
3f0c c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3f0d					NEXTW 
3f0d c3 87 22			jp macro_next 
3f10				endm 
# End of macro NEXTW
3f10			.CDUMP: 
3f10				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3f10 38				db WORD_SYS_CORE+36             
3f11 40 3f			dw .DAT            
3f13 06				db 5 + 1 
3f14 .. 00			db "CDUMP",0              
3f1a				endm 
# End of macro CWHEAD
3f1a			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3f1a					if DEBUG_FORTH_WORDS_KEY 
3f1a						DMARK "CDP" 
3f1a f5				push af  
3f1b 3a 2f 3f			ld a, (.dmark)  
3f1e 32 6e fe			ld (debug_mark),a  
3f21 3a 30 3f			ld a, (.dmark+1)  
3f24 32 6f fe			ld (debug_mark+1),a  
3f27 3a 31 3f			ld a, (.dmark+2)  
3f2a 32 70 fe			ld (debug_mark+2),a  
3f2d 18 03			jr .pastdmark  
3f2f ..			.dmark: db "CDP"  
3f32 f1			.pastdmark: pop af  
3f33			endm  
# End of macro DMARK
3f33						CALLMONITOR 
3f33 cd a5 18			call break_point_state  
3f36				endm  
# End of macro CALLMONITOR
3f36					endif 
3f36 cd ca 0c				call clear_display 
3f39 cd 99 1d				call dumpcont	 
3f3c c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f3d					NEXTW 
3f3d c3 87 22			jp macro_next 
3f40				endm 
# End of macro NEXTW
3f40			 
3f40			 
3f40			 
3f40			 
3f40			.DAT: 
3f40				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f40 3d				db WORD_SYS_CORE+41             
3f41 96 3f			dw .HOME            
3f43 03				db 2 + 1 
3f44 .. 00			db "AT",0              
3f47				endm 
# End of macro CWHEAD
3f47			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f47					if DEBUG_FORTH_WORDS_KEY 
3f47						DMARK "AT." 
3f47 f5				push af  
3f48 3a 5c 3f			ld a, (.dmark)  
3f4b 32 6e fe			ld (debug_mark),a  
3f4e 3a 5d 3f			ld a, (.dmark+1)  
3f51 32 6f fe			ld (debug_mark+1),a  
3f54 3a 5e 3f			ld a, (.dmark+2)  
3f57 32 70 fe			ld (debug_mark+2),a  
3f5a 18 03			jr .pastdmark  
3f5c ..			.dmark: db "AT."  
3f5f f1			.pastdmark: pop af  
3f60			endm  
# End of macro DMARK
3f60						CALLMONITOR 
3f60 cd a5 18			call break_point_state  
3f63				endm  
# End of macro CALLMONITOR
3f63					endif 
3f63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f63 cd 10 21			call macro_dsp_valuehl 
3f66				endm 
# End of macro FORTH_DSP_VALUEHL
3f66			 
3f66			 
3f66					; TODO save cursor row 
3f66 7d					ld a,l 
3f67 fe 02				cp 2 
3f69 20 04				jr nz, .crow3 
3f6b 3e 28				ld a, display_row_2 
3f6d 18 12				jr .ccol1 
3f6f fe 03		.crow3:		cp 3 
3f71 20 04				jr nz, .crow4 
3f73 3e 50				ld a, display_row_3 
3f75 18 0a				jr .ccol1 
3f77 fe 04		.crow4:		cp 4 
3f79 20 04				jr nz, .crow1 
3f7b 3e 78				ld a, display_row_4 
3f7d 18 02				jr .ccol1 
3f7f 3e 00		.crow1:		ld a,display_row_1 
3f81 f5			.ccol1:		push af			; got row offset 
3f82 6f					ld l,a 
3f83 26 00				ld h,0 
3f85					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f85 cd c8 21			call macro_forth_dsp_pop 
3f88				endm 
# End of macro FORTH_DSP_POP
3f88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f88 cd 10 21			call macro_dsp_valuehl 
3f8b				endm 
# End of macro FORTH_DSP_VALUEHL
3f8b					; TODO save cursor col 
3f8b f1					pop af 
3f8c 85					add l		; add col offset 
3f8d 32 68 fa				ld (f_cursor_ptr), a 
3f90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f90 cd c8 21			call macro_forth_dsp_pop 
3f93				endm 
# End of macro FORTH_DSP_POP
3f93			 
3f93					; calculate  
3f93			 
3f93					NEXTW 
3f93 c3 87 22			jp macro_next 
3f96				endm 
# End of macro NEXTW
3f96			 
3f96			 
3f96			.HOME: 
3f96				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f96 41				db WORD_SYS_CORE+45             
3f97 c3 3f			dw .SPACE            
3f99 05				db 4 + 1 
3f9a .. 00			db "HOME",0              
3f9f				endm 
# End of macro CWHEAD
3f9f			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f9f					if DEBUG_FORTH_WORDS_KEY 
3f9f						DMARK "HOM" 
3f9f f5				push af  
3fa0 3a b4 3f			ld a, (.dmark)  
3fa3 32 6e fe			ld (debug_mark),a  
3fa6 3a b5 3f			ld a, (.dmark+1)  
3fa9 32 6f fe			ld (debug_mark+1),a  
3fac 3a b6 3f			ld a, (.dmark+2)  
3faf 32 70 fe			ld (debug_mark+2),a  
3fb2 18 03			jr .pastdmark  
3fb4 ..			.dmark: db "HOM"  
3fb7 f1			.pastdmark: pop af  
3fb8			endm  
# End of macro DMARK
3fb8						CALLMONITOR 
3fb8 cd a5 18			call break_point_state  
3fbb				endm  
# End of macro CALLMONITOR
3fbb					endif 
3fbb 3e 00		.home:		ld a, 0		; and home cursor 
3fbd 32 68 fa				ld (f_cursor_ptr), a 
3fc0					NEXTW 
3fc0 c3 87 22			jp macro_next 
3fc3				endm 
# End of macro NEXTW
3fc3			 
3fc3			 
3fc3			.SPACE: 
3fc3				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3fc3 46				db WORD_SYS_CORE+50             
3fc4 f1 3f			dw .SPACES            
3fc6 03				db 2 + 1 
3fc7 .. 00			db "BL",0              
3fca				endm 
# End of macro CWHEAD
3fca			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3fca					if DEBUG_FORTH_WORDS_KEY 
3fca						DMARK "BL." 
3fca f5				push af  
3fcb 3a df 3f			ld a, (.dmark)  
3fce 32 6e fe			ld (debug_mark),a  
3fd1 3a e0 3f			ld a, (.dmark+1)  
3fd4 32 6f fe			ld (debug_mark+1),a  
3fd7 3a e1 3f			ld a, (.dmark+2)  
3fda 32 70 fe			ld (debug_mark+2),a  
3fdd 18 03			jr .pastdmark  
3fdf ..			.dmark: db "BL."  
3fe2 f1			.pastdmark: pop af  
3fe3			endm  
# End of macro DMARK
3fe3						CALLMONITOR 
3fe3 cd a5 18			call break_point_state  
3fe6				endm  
# End of macro CALLMONITOR
3fe6					endif 
3fe6 21 ef 3f				ld hl, .blstr 
3fe9 cd 87 1f				call forth_push_str 
3fec					 
3fec				       NEXTW 
3fec c3 87 22			jp macro_next 
3fef				endm 
# End of macro NEXTW
3fef			 
3fef .. 00		.blstr: db " ", 0 
3ff1			 
3ff1			.SPACES: 
3ff1				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3ff1 47				db WORD_SYS_CORE+51             
3ff2 8c 40			dw .SCROLL            
3ff4 07				db 6 + 1 
3ff5 .. 00			db "SPACES",0              
3ffc				endm 
# End of macro CWHEAD
3ffc			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3ffc					if DEBUG_FORTH_WORDS_KEY 
3ffc						DMARK "SPS" 
3ffc f5				push af  
3ffd 3a 11 40			ld a, (.dmark)  
4000 32 6e fe			ld (debug_mark),a  
4003 3a 12 40			ld a, (.dmark+1)  
4006 32 6f fe			ld (debug_mark+1),a  
4009 3a 13 40			ld a, (.dmark+2)  
400c 32 70 fe			ld (debug_mark+2),a  
400f 18 03			jr .pastdmark  
4011 ..			.dmark: db "SPS"  
4014 f1			.pastdmark: pop af  
4015			endm  
# End of macro DMARK
4015						CALLMONITOR 
4015 cd a5 18			call break_point_state  
4018				endm  
# End of macro CALLMONITOR
4018					endif 
4018			 
4018			 
4018					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4018 cd 10 21			call macro_dsp_valuehl 
401b				endm 
# End of macro FORTH_DSP_VALUEHL
401b			 
401b			;		push hl    ; u 
401b					if DEBUG_FORTH_WORDS 
401b						DMARK "SPA" 
401b f5				push af  
401c 3a 30 40			ld a, (.dmark)  
401f 32 6e fe			ld (debug_mark),a  
4022 3a 31 40			ld a, (.dmark+1)  
4025 32 6f fe			ld (debug_mark+1),a  
4028 3a 32 40			ld a, (.dmark+2)  
402b 32 70 fe			ld (debug_mark+2),a  
402e 18 03			jr .pastdmark  
4030 ..			.dmark: db "SPA"  
4033 f1			.pastdmark: pop af  
4034			endm  
# End of macro DMARK
4034						CALLMONITOR 
4034 cd a5 18			call break_point_state  
4037				endm  
# End of macro CALLMONITOR
4037					endif 
4037			 
4037					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4037 cd c8 21			call macro_forth_dsp_pop 
403a				endm 
# End of macro FORTH_DSP_POP
403a			;		pop hl 
403a 4d					ld c, l 
403b 06 00				ld b, 0 
403d 21 ff f1				ld hl, scratch  
4040			 
4040					if DEBUG_FORTH_WORDS 
4040						DMARK "SP2" 
4040 f5				push af  
4041 3a 55 40			ld a, (.dmark)  
4044 32 6e fe			ld (debug_mark),a  
4047 3a 56 40			ld a, (.dmark+1)  
404a 32 6f fe			ld (debug_mark+1),a  
404d 3a 57 40			ld a, (.dmark+2)  
4050 32 70 fe			ld (debug_mark+2),a  
4053 18 03			jr .pastdmark  
4055 ..			.dmark: db "SP2"  
4058 f1			.pastdmark: pop af  
4059			endm  
# End of macro DMARK
4059						CALLMONITOR 
4059 cd a5 18			call break_point_state  
405c				endm  
# End of macro CALLMONITOR
405c					endif 
405c 3e 20				ld a, ' ' 
405e c5			.spaces1:	push bc 
405f 77					ld (hl),a 
4060 23					inc hl 
4061 c1					pop bc 
4062 10 fa				djnz .spaces1 
4064 3e 00				ld a,0 
4066 77					ld (hl),a 
4067 21 ff f1				ld hl, scratch 
406a					if DEBUG_FORTH_WORDS 
406a						DMARK "SP3" 
406a f5				push af  
406b 3a 7f 40			ld a, (.dmark)  
406e 32 6e fe			ld (debug_mark),a  
4071 3a 80 40			ld a, (.dmark+1)  
4074 32 6f fe			ld (debug_mark+1),a  
4077 3a 81 40			ld a, (.dmark+2)  
407a 32 70 fe			ld (debug_mark+2),a  
407d 18 03			jr .pastdmark  
407f ..			.dmark: db "SP3"  
4082 f1			.pastdmark: pop af  
4083			endm  
# End of macro DMARK
4083						CALLMONITOR 
4083 cd a5 18			call break_point_state  
4086				endm  
# End of macro CALLMONITOR
4086					endif 
4086 cd 82 20				call forth_apush 
4089			 
4089				       NEXTW 
4089 c3 87 22			jp macro_next 
408c				endm 
# End of macro NEXTW
408c			 
408c			 
408c			 
408c			.SCROLL: 
408c				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
408c 53				db WORD_SYS_CORE+63             
408d b9 40			dw .SCROLLD            
408f 07				db 6 + 1 
4090 .. 00			db "SCROLL",0              
4097				endm 
# End of macro CWHEAD
4097			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4097					if DEBUG_FORTH_WORDS_KEY 
4097						DMARK "SCR" 
4097 f5				push af  
4098 3a ac 40			ld a, (.dmark)  
409b 32 6e fe			ld (debug_mark),a  
409e 3a ad 40			ld a, (.dmark+1)  
40a1 32 6f fe			ld (debug_mark+1),a  
40a4 3a ae 40			ld a, (.dmark+2)  
40a7 32 70 fe			ld (debug_mark+2),a  
40aa 18 03			jr .pastdmark  
40ac ..			.dmark: db "SCR"  
40af f1			.pastdmark: pop af  
40b0			endm  
# End of macro DMARK
40b0						CALLMONITOR 
40b0 cd a5 18			call break_point_state  
40b3				endm  
# End of macro CALLMONITOR
40b3					endif 
40b3			 
40b3 cd 8c 0c			call scroll_up 
40b6			;	call update_display 
40b6			 
40b6					NEXTW 
40b6 c3 87 22			jp macro_next 
40b9				endm 
# End of macro NEXTW
40b9			 
40b9			 
40b9			 
40b9			;		; get dir 
40b9			; 
40b9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40b9			; 
40b9			;		push hl 
40b9			; 
40b9			;		; destroy value TOS 
40b9			; 
40b9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40b9			; 
40b9			;		; get count 
40b9			; 
40b9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40b9			; 
40b9			;		push hl 
40b9			; 
40b9			;		; destroy value TOS 
40b9			; 
40b9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40b9			; 
40b9			;		; one value on hl get other one back 
40b9			; 
40b9			;		pop bc    ; count 
40b9			; 
40b9			;		pop de   ; dir 
40b9			; 
40b9			; 
40b9			;		ld b, c 
40b9			; 
40b9			;.scrolldir:     push bc 
40b9			;		push de 
40b9			; 
40b9			;		ld a, 0 
40b9			;		cp e 
40b9			;		jr z, .scrollup  
40b9			;		call scroll_down 
40b9			;		jr .scrollnext 
40b9			;.scrollup:	call scroll_up 
40b9			; 
40b9			;		 
40b9			;.scrollnext: 
40b9			;		pop de 
40b9			;		pop bc 
40b9			;		djnz .scrolldir 
40b9			; 
40b9			; 
40b9			; 
40b9			; 
40b9			; 
40b9			;		NEXTW 
40b9			 
40b9			.SCROLLD: 
40b9				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
40b9 53				db WORD_SYS_CORE+63             
40ba e7 40			dw .ATQ            
40bc 08				db 7 + 1 
40bd .. 00			db "SCROLLD",0              
40c5				endm 
# End of macro CWHEAD
40c5			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
40c5					if DEBUG_FORTH_WORDS_KEY 
40c5						DMARK "SCD" 
40c5 f5				push af  
40c6 3a da 40			ld a, (.dmark)  
40c9 32 6e fe			ld (debug_mark),a  
40cc 3a db 40			ld a, (.dmark+1)  
40cf 32 6f fe			ld (debug_mark+1),a  
40d2 3a dc 40			ld a, (.dmark+2)  
40d5 32 70 fe			ld (debug_mark+2),a  
40d8 18 03			jr .pastdmark  
40da ..			.dmark: db "SCD"  
40dd f1			.pastdmark: pop af  
40de			endm  
# End of macro DMARK
40de						CALLMONITOR 
40de cd a5 18			call break_point_state  
40e1				endm  
# End of macro CALLMONITOR
40e1					endif 
40e1			 
40e1 cd b0 0c			call scroll_down 
40e4			;	call update_display 
40e4			 
40e4					NEXTW 
40e4 c3 87 22			jp macro_next 
40e7				endm 
# End of macro NEXTW
40e7			 
40e7			 
40e7			.ATQ: 
40e7				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
40e7 62				db WORD_SYS_CORE+78             
40e8 45 41			dw .AUTODSP            
40ea 04				db 3 + 1 
40eb .. 00			db "AT@",0              
40ef				endm 
# End of macro CWHEAD
40ef			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
40ef					if DEBUG_FORTH_WORDS_KEY 
40ef						DMARK "ATA" 
40ef f5				push af  
40f0 3a 04 41			ld a, (.dmark)  
40f3 32 6e fe			ld (debug_mark),a  
40f6 3a 05 41			ld a, (.dmark+1)  
40f9 32 6f fe			ld (debug_mark+1),a  
40fc 3a 06 41			ld a, (.dmark+2)  
40ff 32 70 fe			ld (debug_mark+2),a  
4102 18 03			jr .pastdmark  
4104 ..			.dmark: db "ATA"  
4107 f1			.pastdmark: pop af  
4108			endm  
# End of macro DMARK
4108						CALLMONITOR 
4108 cd a5 18			call break_point_state  
410b				endm  
# End of macro CALLMONITOR
410b					endif 
410b			 
410b			 
410b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
410b cd 10 21			call macro_dsp_valuehl 
410e				endm 
# End of macro FORTH_DSP_VALUEHL
410e			 
410e					; TODO save cursor row 
410e 7d					ld a,l 
410f fe 02				cp 2 
4111 20 04				jr nz, .crow3aq 
4113 3e 28				ld a, display_row_2 
4115 18 12				jr .ccol1aq 
4117 fe 03		.crow3aq:		cp 3 
4119 20 04				jr nz, .crow4aq 
411b 3e 50				ld a, display_row_3 
411d 18 0a				jr .ccol1aq 
411f fe 04		.crow4aq:		cp 4 
4121 20 04				jr nz, .crow1aq 
4123 3e 78				ld a, display_row_4 
4125 18 02				jr .ccol1aq 
4127 3e 00		.crow1aq:		ld a,display_row_1 
4129 f5			.ccol1aq:		push af			; got row offset 
412a 6f					ld l,a 
412b 26 00				ld h,0 
412d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
412d cd c8 21			call macro_forth_dsp_pop 
4130				endm 
# End of macro FORTH_DSP_POP
4130					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4130 cd 10 21			call macro_dsp_valuehl 
4133				endm 
# End of macro FORTH_DSP_VALUEHL
4133					; TODO save cursor col 
4133 f1					pop af 
4134 85					add l		; add col offset 
4135			 
4135					; add current frame buffer address 
4135 2a cf fb				ld hl, (display_fb_active) 
4138 cd fe 0e				call addatohl 
413b			 
413b			 
413b			 
413b			 
413b					; get char frame buffer location offset in hl 
413b			 
413b 7e					ld a,(hl) 
413c 26 00				ld h, 0 
413e 6f					ld l, a 
413f			 
413f cd 19 1f				call forth_push_numhl 
4142			 
4142			 
4142					NEXTW 
4142 c3 87 22			jp macro_next 
4145				endm 
# End of macro NEXTW
4145			 
4145			.AUTODSP: 
4145				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4145 63				db WORD_SYS_CORE+79             
4146 5b 41			dw .MENU            
4148 05				db 4 + 1 
4149 .. 00			db "ADSP",0              
414e				endm 
# End of macro CWHEAD
414e			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
414e			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
414e			 
414e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
414e cd 10 21			call macro_dsp_valuehl 
4151				endm 
# End of macro FORTH_DSP_VALUEHL
4151			 
4151			;		push hl 
4151			 
4151					; destroy value TOS 
4151			 
4151					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4151 cd c8 21			call macro_forth_dsp_pop 
4154				endm 
# End of macro FORTH_DSP_POP
4154			 
4154			;		pop hl 
4154			 
4154 7d					ld a,l 
4155 32 46 fa				ld (cli_autodisplay), a 
4158				       NEXTW 
4158 c3 87 22			jp macro_next 
415b				endm 
# End of macro NEXTW
415b			 
415b			.MENU: 
415b				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
415b 70				db WORD_SYS_CORE+92             
415c 04 42			dw .ENDDISPLAY            
415e 05				db 4 + 1 
415f .. 00			db "MENU",0              
4164				endm 
# End of macro CWHEAD
4164			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4164			 
4164			;		; get number of items on the stack 
4164			; 
4164				 
4164					FORTH_DSP_VALUEHL 
4164 cd 10 21			call macro_dsp_valuehl 
4167				endm 
# End of macro FORTH_DSP_VALUEHL
4167				 
4167					if DEBUG_FORTH_WORDS_KEY 
4167						DMARK "MNU" 
4167 f5				push af  
4168 3a 7c 41			ld a, (.dmark)  
416b 32 6e fe			ld (debug_mark),a  
416e 3a 7d 41			ld a, (.dmark+1)  
4171 32 6f fe			ld (debug_mark+1),a  
4174 3a 7e 41			ld a, (.dmark+2)  
4177 32 70 fe			ld (debug_mark+2),a  
417a 18 03			jr .pastdmark  
417c ..			.dmark: db "MNU"  
417f f1			.pastdmark: pop af  
4180			endm  
# End of macro DMARK
4180						CALLMONITOR 
4180 cd a5 18			call break_point_state  
4183				endm  
# End of macro CALLMONITOR
4183					endif 
4183			 
4183 45					ld b, l	 
4184 05					dec b 
4185			 
4185					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4185 cd c8 21			call macro_forth_dsp_pop 
4188				endm 
# End of macro FORTH_DSP_POP
4188			 
4188			 
4188					; go directly through the stack to pluck out the string pointers and build an array 
4188			 
4188			;		FORTH_DSP 
4188			 
4188					; hl contains top most stack item 
4188				 
4188 11 ff f1				ld de, scratch 
418b			 
418b			.mbuild: 
418b			 
418b					FORTH_DSP_VALUEHL 
418b cd 10 21			call macro_dsp_valuehl 
418e				endm 
# End of macro FORTH_DSP_VALUEHL
418e			 
418e					if DEBUG_FORTH_WORDS 
418e						DMARK "MN3" 
418e f5				push af  
418f 3a a3 41			ld a, (.dmark)  
4192 32 6e fe			ld (debug_mark),a  
4195 3a a4 41			ld a, (.dmark+1)  
4198 32 6f fe			ld (debug_mark+1),a  
419b 3a a5 41			ld a, (.dmark+2)  
419e 32 70 fe			ld (debug_mark+2),a  
41a1 18 03			jr .pastdmark  
41a3 ..			.dmark: db "MN3"  
41a6 f1			.pastdmark: pop af  
41a7			endm  
# End of macro DMARK
41a7						CALLMONITOR 
41a7 cd a5 18			call break_point_state  
41aa				endm  
# End of macro CALLMONITOR
41aa					endif 
41aa eb					ex de, hl 
41ab 73					ld (hl), e 
41ac 23					inc hl 
41ad 72					ld (hl), d 
41ae 23					inc hl 
41af eb					ex de, hl 
41b0			 
41b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41b0 cd c8 21			call macro_forth_dsp_pop 
41b3				endm 
# End of macro FORTH_DSP_POP
41b3			 
41b3 10 d6				djnz .mbuild 
41b5			 
41b5					; done add term 
41b5			 
41b5 eb					ex de, hl 
41b6 36 00				ld (hl), 0 
41b8 23					inc hl 
41b9 36 00				ld (hl), 0 
41bb			 
41bb				 
41bb					 
41bb 21 ff f1				ld hl, scratch 
41be			 
41be					if DEBUG_FORTH_WORDS 
41be						DMARK "MNx" 
41be f5				push af  
41bf 3a d3 41			ld a, (.dmark)  
41c2 32 6e fe			ld (debug_mark),a  
41c5 3a d4 41			ld a, (.dmark+1)  
41c8 32 6f fe			ld (debug_mark+1),a  
41cb 3a d5 41			ld a, (.dmark+2)  
41ce 32 70 fe			ld (debug_mark+2),a  
41d1 18 03			jr .pastdmark  
41d3 ..			.dmark: db "MNx"  
41d6 f1			.pastdmark: pop af  
41d7			endm  
# End of macro DMARK
41d7						CALLMONITOR 
41d7 cd a5 18			call break_point_state  
41da				endm  
# End of macro CALLMONITOR
41da					endif 
41da			 
41da			 
41da			 
41da 3e 00				ld a, 0 
41dc cd fb 0c				call menu 
41df			 
41df			 
41df 6f					ld l, a 
41e0 26 00				ld h, 0 
41e2			 
41e2					if DEBUG_FORTH_WORDS 
41e2						DMARK "MNr" 
41e2 f5				push af  
41e3 3a f7 41			ld a, (.dmark)  
41e6 32 6e fe			ld (debug_mark),a  
41e9 3a f8 41			ld a, (.dmark+1)  
41ec 32 6f fe			ld (debug_mark+1),a  
41ef 3a f9 41			ld a, (.dmark+2)  
41f2 32 70 fe			ld (debug_mark+2),a  
41f5 18 03			jr .pastdmark  
41f7 ..			.dmark: db "MNr"  
41fa f1			.pastdmark: pop af  
41fb			endm  
# End of macro DMARK
41fb						CALLMONITOR 
41fb cd a5 18			call break_point_state  
41fe				endm  
# End of macro CALLMONITOR
41fe					endif 
41fe			 
41fe cd 19 1f				call forth_push_numhl 
4201			 
4201			 
4201			 
4201			 
4201				       NEXTW 
4201 c3 87 22			jp macro_next 
4204				endm 
# End of macro NEXTW
4204			 
4204			 
4204			.ENDDISPLAY: 
4204			 
4204			; eof 
# End of file forth_words_display.asm
4204			include "forth_words_str.asm" 
4204			 
4204			; | ## String Words 
4204			 
4204			.PTR:   
4204			 
4204				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4204 48				db WORD_SYS_CORE+52             
4205 31 42			dw .STYPE            
4207 04				db 3 + 1 
4208 .. 00			db "PTR",0              
420c				endm 
# End of macro CWHEAD
420c			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
420c			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
420c			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
420c			 
420c					if DEBUG_FORTH_WORDS_KEY 
420c						DMARK "PTR" 
420c f5				push af  
420d 3a 21 42			ld a, (.dmark)  
4210 32 6e fe			ld (debug_mark),a  
4213 3a 22 42			ld a, (.dmark+1)  
4216 32 6f fe			ld (debug_mark+1),a  
4219 3a 23 42			ld a, (.dmark+2)  
421c 32 70 fe			ld (debug_mark+2),a  
421f 18 03			jr .pastdmark  
4221 ..			.dmark: db "PTR"  
4224 f1			.pastdmark: pop af  
4225			endm  
# End of macro DMARK
4225						CALLMONITOR 
4225 cd a5 18			call break_point_state  
4228				endm  
# End of macro CALLMONITOR
4228					endif 
4228					FORTH_DSP_VALUEHL 
4228 cd 10 21			call macro_dsp_valuehl 
422b				endm 
# End of macro FORTH_DSP_VALUEHL
422b cd 19 1f				call forth_push_numhl 
422e			 
422e			 
422e					NEXTW 
422e c3 87 22			jp macro_next 
4231				endm 
# End of macro NEXTW
4231			.STYPE: 
4231				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4231 48				db WORD_SYS_CORE+52             
4232 80 42			dw .UPPER            
4234 06				db 5 + 1 
4235 .. 00			db "STYPE",0              
423b				endm 
# End of macro CWHEAD
423b			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
423b					if DEBUG_FORTH_WORDS_KEY 
423b						DMARK "STY" 
423b f5				push af  
423c 3a 50 42			ld a, (.dmark)  
423f 32 6e fe			ld (debug_mark),a  
4242 3a 51 42			ld a, (.dmark+1)  
4245 32 6f fe			ld (debug_mark+1),a  
4248 3a 52 42			ld a, (.dmark+2)  
424b 32 70 fe			ld (debug_mark+2),a  
424e 18 03			jr .pastdmark  
4250 ..			.dmark: db "STY"  
4253 f1			.pastdmark: pop af  
4254			endm  
# End of macro DMARK
4254						CALLMONITOR 
4254 cd a5 18			call break_point_state  
4257				endm  
# End of macro CALLMONITOR
4257					endif 
4257					FORTH_DSP 
4257 cd d6 20			call macro_forth_dsp 
425a				endm 
# End of macro FORTH_DSP
425a					;v5 FORTH_DSP_VALUE 
425a			 
425a 7e					ld a, (hl) 
425b			 
425b f5					push af 
425c			 
425c			; Dont destroy TOS		FORTH_DSP_POP 
425c			 
425c f1					pop af 
425d			 
425d fe 01				cp DS_TYPE_STR 
425f 28 09				jr z, .typestr 
4261			 
4261 fe 02				cp DS_TYPE_INUM 
4263 28 0a				jr z, .typeinum 
4265			 
4265 21 7e 42				ld hl, .tna 
4268 18 0a				jr .tpush 
426a			 
426a 21 7a 42		.typestr:	ld hl, .tstr 
426d 18 05				jr .tpush 
426f 21 7c 42		.typeinum:	ld hl, .tinum 
4272 18 00				jr .tpush 
4274			 
4274			.tpush: 
4274			 
4274 cd 87 1f				call forth_push_str 
4277			 
4277					NEXTW 
4277 c3 87 22			jp macro_next 
427a				endm 
# End of macro NEXTW
427a .. 00		.tstr:	db "s",0 
427c .. 00		.tinum:  db "i",0 
427e .. 00		.tna:   db "?", 0 
4280			 
4280			 
4280			.UPPER: 
4280				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4280 48				db WORD_SYS_CORE+52             
4281 bb 42			dw .LOWER            
4283 06				db 5 + 1 
4284 .. 00			db "UPPER",0              
428a				endm 
# End of macro CWHEAD
428a			; | UPPER ( s -- s ) Upper case string s  | DONE 
428a					if DEBUG_FORTH_WORDS_KEY 
428a						DMARK "UPR" 
428a f5				push af  
428b 3a 9f 42			ld a, (.dmark)  
428e 32 6e fe			ld (debug_mark),a  
4291 3a a0 42			ld a, (.dmark+1)  
4294 32 6f fe			ld (debug_mark+1),a  
4297 3a a1 42			ld a, (.dmark+2)  
429a 32 70 fe			ld (debug_mark+2),a  
429d 18 03			jr .pastdmark  
429f ..			.dmark: db "UPR"  
42a2 f1			.pastdmark: pop af  
42a3			endm  
# End of macro DMARK
42a3						CALLMONITOR 
42a3 cd a5 18			call break_point_state  
42a6				endm  
# End of macro CALLMONITOR
42a6					endif 
42a6			 
42a6					FORTH_DSP 
42a6 cd d6 20			call macro_forth_dsp 
42a9				endm 
# End of macro FORTH_DSP
42a9					 
42a9			; TODO check is string type 
42a9			 
42a9					FORTH_DSP_VALUEHL 
42a9 cd 10 21			call macro_dsp_valuehl 
42ac				endm 
# End of macro FORTH_DSP_VALUEHL
42ac			; get pointer to string in hl 
42ac			 
42ac 7e			.toup:		ld a, (hl) 
42ad fe 00				cp 0 
42af 28 07				jr z, .toupdone 
42b1			 
42b1 cd 6b 12				call to_upper 
42b4			 
42b4 77					ld (hl), a 
42b5 23					inc hl 
42b6 18 f4				jr .toup 
42b8			 
42b8					 
42b8			 
42b8			 
42b8			; for each char convert to upper 
42b8					 
42b8			.toupdone: 
42b8			 
42b8			 
42b8					NEXTW 
42b8 c3 87 22			jp macro_next 
42bb				endm 
# End of macro NEXTW
42bb			.LOWER: 
42bb				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
42bb 48				db WORD_SYS_CORE+52             
42bc f6 42			dw .TCASE            
42be 06				db 5 + 1 
42bf .. 00			db "LOWER",0              
42c5				endm 
# End of macro CWHEAD
42c5			; | LOWER ( s -- s ) Lower case string s  | DONE 
42c5					if DEBUG_FORTH_WORDS_KEY 
42c5						DMARK "LWR" 
42c5 f5				push af  
42c6 3a da 42			ld a, (.dmark)  
42c9 32 6e fe			ld (debug_mark),a  
42cc 3a db 42			ld a, (.dmark+1)  
42cf 32 6f fe			ld (debug_mark+1),a  
42d2 3a dc 42			ld a, (.dmark+2)  
42d5 32 70 fe			ld (debug_mark+2),a  
42d8 18 03			jr .pastdmark  
42da ..			.dmark: db "LWR"  
42dd f1			.pastdmark: pop af  
42de			endm  
# End of macro DMARK
42de						CALLMONITOR 
42de cd a5 18			call break_point_state  
42e1				endm  
# End of macro CALLMONITOR
42e1					endif 
42e1			 
42e1					FORTH_DSP 
42e1 cd d6 20			call macro_forth_dsp 
42e4				endm 
# End of macro FORTH_DSP
42e4					 
42e4			; TODO check is string type 
42e4			 
42e4					FORTH_DSP_VALUEHL 
42e4 cd 10 21			call macro_dsp_valuehl 
42e7				endm 
# End of macro FORTH_DSP_VALUEHL
42e7			; get pointer to string in hl 
42e7			 
42e7 7e			.tolow:		ld a, (hl) 
42e8 fe 00				cp 0 
42ea 28 07				jr z, .tolowdone 
42ec			 
42ec cd 74 12				call to_lower 
42ef			 
42ef 77					ld (hl), a 
42f0 23					inc hl 
42f1 18 f4				jr .tolow 
42f3			 
42f3					 
42f3			 
42f3			 
42f3			; for each char convert to low 
42f3					 
42f3			.tolowdone: 
42f3					NEXTW 
42f3 c3 87 22			jp macro_next 
42f6				endm 
# End of macro NEXTW
42f6			.TCASE: 
42f6				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
42f6 48				db WORD_SYS_CORE+52             
42f7 2c 44			dw .SUBSTR            
42f9 06				db 5 + 1 
42fa .. 00			db "TCASE",0              
4300				endm 
# End of macro CWHEAD
4300			; | TCASE ( s -- s ) Title case string s  | DONE 
4300					if DEBUG_FORTH_WORDS_KEY 
4300						DMARK "TCS" 
4300 f5				push af  
4301 3a 15 43			ld a, (.dmark)  
4304 32 6e fe			ld (debug_mark),a  
4307 3a 16 43			ld a, (.dmark+1)  
430a 32 6f fe			ld (debug_mark+1),a  
430d 3a 17 43			ld a, (.dmark+2)  
4310 32 70 fe			ld (debug_mark+2),a  
4313 18 03			jr .pastdmark  
4315 ..			.dmark: db "TCS"  
4318 f1			.pastdmark: pop af  
4319			endm  
# End of macro DMARK
4319						CALLMONITOR 
4319 cd a5 18			call break_point_state  
431c				endm  
# End of macro CALLMONITOR
431c					endif 
431c			 
431c					FORTH_DSP 
431c cd d6 20			call macro_forth_dsp 
431f				endm 
# End of macro FORTH_DSP
431f					 
431f			; TODO check is string type 
431f			 
431f					FORTH_DSP_VALUEHL 
431f cd 10 21			call macro_dsp_valuehl 
4322				endm 
# End of macro FORTH_DSP_VALUEHL
4322			; get pointer to string in hl 
4322			 
4322					if DEBUG_FORTH_WORDS 
4322						DMARK "TC1" 
4322 f5				push af  
4323 3a 37 43			ld a, (.dmark)  
4326 32 6e fe			ld (debug_mark),a  
4329 3a 38 43			ld a, (.dmark+1)  
432c 32 6f fe			ld (debug_mark+1),a  
432f 3a 39 43			ld a, (.dmark+2)  
4332 32 70 fe			ld (debug_mark+2),a  
4335 18 03			jr .pastdmark  
4337 ..			.dmark: db "TC1"  
433a f1			.pastdmark: pop af  
433b			endm  
# End of macro DMARK
433b						CALLMONITOR 
433b cd a5 18			call break_point_state  
433e				endm  
# End of macro CALLMONITOR
433e					endif 
433e			 
433e					; first time in turn to upper case first char 
433e			 
433e 7e					ld a, (hl) 
433f c3 c9 43				jp .totsiptou 
4342			 
4342			 
4342 7e			.tot:		ld a, (hl) 
4343 fe 00				cp 0 
4345 ca 0d 44				jp z, .totdone 
4348			 
4348					if DEBUG_FORTH_WORDS 
4348						DMARK "TC2" 
4348 f5				push af  
4349 3a 5d 43			ld a, (.dmark)  
434c 32 6e fe			ld (debug_mark),a  
434f 3a 5e 43			ld a, (.dmark+1)  
4352 32 6f fe			ld (debug_mark+1),a  
4355 3a 5f 43			ld a, (.dmark+2)  
4358 32 70 fe			ld (debug_mark+2),a  
435b 18 03			jr .pastdmark  
435d ..			.dmark: db "TC2"  
4360 f1			.pastdmark: pop af  
4361			endm  
# End of macro DMARK
4361						CALLMONITOR 
4361 cd a5 18			call break_point_state  
4364				endm  
# End of macro CALLMONITOR
4364					endif 
4364					; check to see if current char is a space 
4364			 
4364 fe 20				cp ' ' 
4366 28 21				jr z, .totsp 
4368 cd 74 12				call to_lower 
436b					if DEBUG_FORTH_WORDS 
436b						DMARK "TC3" 
436b f5				push af  
436c 3a 80 43			ld a, (.dmark)  
436f 32 6e fe			ld (debug_mark),a  
4372 3a 81 43			ld a, (.dmark+1)  
4375 32 6f fe			ld (debug_mark+1),a  
4378 3a 82 43			ld a, (.dmark+2)  
437b 32 70 fe			ld (debug_mark+2),a  
437e 18 03			jr .pastdmark  
4380 ..			.dmark: db "TC3"  
4383 f1			.pastdmark: pop af  
4384			endm  
# End of macro DMARK
4384						CALLMONITOR 
4384 cd a5 18			call break_point_state  
4387				endm  
# End of macro CALLMONITOR
4387					endif 
4387 18 63				jr .totnxt 
4389			 
4389			.totsp:         ; on a space, find next char which should be upper 
4389			 
4389					if DEBUG_FORTH_WORDS 
4389						DMARK "TC4" 
4389 f5				push af  
438a 3a 9e 43			ld a, (.dmark)  
438d 32 6e fe			ld (debug_mark),a  
4390 3a 9f 43			ld a, (.dmark+1)  
4393 32 6f fe			ld (debug_mark+1),a  
4396 3a a0 43			ld a, (.dmark+2)  
4399 32 70 fe			ld (debug_mark+2),a  
439c 18 03			jr .pastdmark  
439e ..			.dmark: db "TC4"  
43a1 f1			.pastdmark: pop af  
43a2			endm  
# End of macro DMARK
43a2						CALLMONITOR 
43a2 cd a5 18			call break_point_state  
43a5				endm  
# End of macro CALLMONITOR
43a5					endif 
43a5					;; 
43a5			 
43a5 fe 20				cp ' ' 
43a7 20 20				jr nz, .totsiptou 
43a9 23					inc hl 
43aa 7e					ld a, (hl) 
43ab					if DEBUG_FORTH_WORDS 
43ab						DMARK "TC5" 
43ab f5				push af  
43ac 3a c0 43			ld a, (.dmark)  
43af 32 6e fe			ld (debug_mark),a  
43b2 3a c1 43			ld a, (.dmark+1)  
43b5 32 6f fe			ld (debug_mark+1),a  
43b8 3a c2 43			ld a, (.dmark+2)  
43bb 32 70 fe			ld (debug_mark+2),a  
43be 18 03			jr .pastdmark  
43c0 ..			.dmark: db "TC5"  
43c3 f1			.pastdmark: pop af  
43c4			endm  
# End of macro DMARK
43c4						CALLMONITOR 
43c4 cd a5 18			call break_point_state  
43c7				endm  
# End of macro CALLMONITOR
43c7					endif 
43c7 18 c0				jr .totsp 
43c9 fe 00		.totsiptou:    cp 0 
43cb 28 40				jr z, .totdone 
43cd					; not space and not zero term so upper case it 
43cd cd 6b 12				call to_upper 
43d0			 
43d0					if DEBUG_FORTH_WORDS 
43d0						DMARK "TC6" 
43d0 f5				push af  
43d1 3a e5 43			ld a, (.dmark)  
43d4 32 6e fe			ld (debug_mark),a  
43d7 3a e6 43			ld a, (.dmark+1)  
43da 32 6f fe			ld (debug_mark+1),a  
43dd 3a e7 43			ld a, (.dmark+2)  
43e0 32 70 fe			ld (debug_mark+2),a  
43e3 18 03			jr .pastdmark  
43e5 ..			.dmark: db "TC6"  
43e8 f1			.pastdmark: pop af  
43e9			endm  
# End of macro DMARK
43e9						CALLMONITOR 
43e9 cd a5 18			call break_point_state  
43ec				endm  
# End of macro CALLMONITOR
43ec					endif 
43ec			 
43ec			 
43ec			.totnxt: 
43ec			 
43ec 77					ld (hl), a 
43ed 23					inc hl 
43ee					if DEBUG_FORTH_WORDS 
43ee						DMARK "TC7" 
43ee f5				push af  
43ef 3a 03 44			ld a, (.dmark)  
43f2 32 6e fe			ld (debug_mark),a  
43f5 3a 04 44			ld a, (.dmark+1)  
43f8 32 6f fe			ld (debug_mark+1),a  
43fb 3a 05 44			ld a, (.dmark+2)  
43fe 32 70 fe			ld (debug_mark+2),a  
4401 18 03			jr .pastdmark  
4403 ..			.dmark: db "TC7"  
4406 f1			.pastdmark: pop af  
4407			endm  
# End of macro DMARK
4407						CALLMONITOR 
4407 cd a5 18			call break_point_state  
440a				endm  
# End of macro CALLMONITOR
440a					endif 
440a c3 42 43				jp .tot 
440d			 
440d					 
440d			 
440d			 
440d			; for each char convert to low 
440d					 
440d			.totdone: 
440d					if DEBUG_FORTH_WORDS 
440d						DMARK "TCd" 
440d f5				push af  
440e 3a 22 44			ld a, (.dmark)  
4411 32 6e fe			ld (debug_mark),a  
4414 3a 23 44			ld a, (.dmark+1)  
4417 32 6f fe			ld (debug_mark+1),a  
441a 3a 24 44			ld a, (.dmark+2)  
441d 32 70 fe			ld (debug_mark+2),a  
4420 18 03			jr .pastdmark  
4422 ..			.dmark: db "TCd"  
4425 f1			.pastdmark: pop af  
4426			endm  
# End of macro DMARK
4426						CALLMONITOR 
4426 cd a5 18			call break_point_state  
4429				endm  
# End of macro CALLMONITOR
4429					endif 
4429					NEXTW 
4429 c3 87 22			jp macro_next 
442c				endm 
# End of macro NEXTW
442c			 
442c			.SUBSTR: 
442c				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
442c 48				db WORD_SYS_CORE+52             
442d 8a 44			dw .LEFT            
442f 07				db 6 + 1 
4430 .. 00			db "SUBSTR",0              
4437				endm 
# End of macro CWHEAD
4437			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4437			 
4437					if DEBUG_FORTH_WORDS_KEY 
4437						DMARK "SST" 
4437 f5				push af  
4438 3a 4c 44			ld a, (.dmark)  
443b 32 6e fe			ld (debug_mark),a  
443e 3a 4d 44			ld a, (.dmark+1)  
4441 32 6f fe			ld (debug_mark+1),a  
4444 3a 4e 44			ld a, (.dmark+2)  
4447 32 70 fe			ld (debug_mark+2),a  
444a 18 03			jr .pastdmark  
444c ..			.dmark: db "SST"  
444f f1			.pastdmark: pop af  
4450			endm  
# End of macro DMARK
4450						CALLMONITOR 
4450 cd a5 18			call break_point_state  
4453				endm  
# End of macro CALLMONITOR
4453					endif 
4453			; TODO check string type 
4453					FORTH_DSP_VALUEHL 
4453 cd 10 21			call macro_dsp_valuehl 
4456				endm 
# End of macro FORTH_DSP_VALUEHL
4456			 
4456 e5					push hl      ; string length 
4457			 
4457					FORTH_DSP_POP 
4457 cd c8 21			call macro_forth_dsp_pop 
445a				endm 
# End of macro FORTH_DSP_POP
445a			 
445a					FORTH_DSP_VALUEHL 
445a cd 10 21			call macro_dsp_valuehl 
445d				endm 
# End of macro FORTH_DSP_VALUEHL
445d			 
445d e5					push hl     ; start char 
445e			 
445e					FORTH_DSP_POP 
445e cd c8 21			call macro_forth_dsp_pop 
4461				endm 
# End of macro FORTH_DSP_POP
4461			 
4461			 
4461					FORTH_DSP_VALUE 
4461 cd f9 20			call macro_forth_dsp_value 
4464				endm 
# End of macro FORTH_DSP_VALUE
4464			 
4464 d1					pop de    ; get start post offset 
4465			 
4465 19					add hl, de    ; starting offset 
4466			 
4466 c1					pop bc 
4467 c5					push bc      ; grab size of string 
4468			 
4468 e5					push hl    ; save string start  
4469			 
4469 26 00				ld h, 0 
446b 69					ld l, c 
446c 23					inc hl 
446d 23					inc hl 
446e			 
446e cd c5 13				call malloc 
4471				if DEBUG_FORTH_MALLOC_GUARD 
4471 cc 82 55				call z,malloc_error 
4474				endif 
4474			 
4474 eb					ex de, hl      ; save malloc area for string copy 
4475 e1					pop hl    ; get back source 
4476 c1					pop bc    ; get length of string back 
4477			 
4477 d5					push de    ; save malloc area for after we push 
4478 ed b0				ldir     ; copy substr 
447a			 
447a			 
447a eb					ex de, hl 
447b 3e 00				ld a, 0 
447d 77					ld (hl), a   ; term substr 
447e			 
447e					 
447e e1					pop hl    ; get malloc so we can push it 
447f e5					push hl   ; save so we can free it afterwards 
4480			 
4480 cd 87 1f				call forth_push_str 
4483			 
4483 e1					pop hl 
4484 cd 8f 14				call free 
4487			 
4487					 
4487					 
4487			 
4487			 
4487					NEXTW 
4487 c3 87 22			jp macro_next 
448a				endm 
# End of macro NEXTW
448a			 
448a			.LEFT: 
448a				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
448a 48				db WORD_SYS_CORE+52             
448b b2 44			dw .RIGHT            
448d 05				db 4 + 1 
448e .. 00			db "LEFT",0              
4493				endm 
# End of macro CWHEAD
4493			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4493					if DEBUG_FORTH_WORDS_KEY 
4493						DMARK "LEF" 
4493 f5				push af  
4494 3a a8 44			ld a, (.dmark)  
4497 32 6e fe			ld (debug_mark),a  
449a 3a a9 44			ld a, (.dmark+1)  
449d 32 6f fe			ld (debug_mark+1),a  
44a0 3a aa 44			ld a, (.dmark+2)  
44a3 32 70 fe			ld (debug_mark+2),a  
44a6 18 03			jr .pastdmark  
44a8 ..			.dmark: db "LEF"  
44ab f1			.pastdmark: pop af  
44ac			endm  
# End of macro DMARK
44ac						CALLMONITOR 
44ac cd a5 18			call break_point_state  
44af				endm  
# End of macro CALLMONITOR
44af					endif 
44af			 
44af					NEXTW 
44af c3 87 22			jp macro_next 
44b2				endm 
# End of macro NEXTW
44b2			.RIGHT: 
44b2				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
44b2 48				db WORD_SYS_CORE+52             
44b3 db 44			dw .STR2NUM            
44b5 06				db 5 + 1 
44b6 .. 00			db "RIGHT",0              
44bc				endm 
# End of macro CWHEAD
44bc			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
44bc					if DEBUG_FORTH_WORDS_KEY 
44bc						DMARK "RIG" 
44bc f5				push af  
44bd 3a d1 44			ld a, (.dmark)  
44c0 32 6e fe			ld (debug_mark),a  
44c3 3a d2 44			ld a, (.dmark+1)  
44c6 32 6f fe			ld (debug_mark+1),a  
44c9 3a d3 44			ld a, (.dmark+2)  
44cc 32 70 fe			ld (debug_mark+2),a  
44cf 18 03			jr .pastdmark  
44d1 ..			.dmark: db "RIG"  
44d4 f1			.pastdmark: pop af  
44d5			endm  
# End of macro DMARK
44d5						CALLMONITOR 
44d5 cd a5 18			call break_point_state  
44d8				endm  
# End of macro CALLMONITOR
44d8					endif 
44d8			 
44d8					NEXTW 
44d8 c3 87 22			jp macro_next 
44db				endm 
# End of macro NEXTW
44db			 
44db			 
44db			.STR2NUM: 
44db				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44db 48				db WORD_SYS_CORE+52             
44dc 67 45			dw .NUM2STR            
44de 08				db 7 + 1 
44df .. 00			db "STR2NUM",0              
44e7				endm 
# End of macro CWHEAD
44e7			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
44e7			 
44e7			 
44e7			; TODO STR type check to do 
44e7					if DEBUG_FORTH_WORDS_KEY 
44e7						DMARK "S2N" 
44e7 f5				push af  
44e8 3a fc 44			ld a, (.dmark)  
44eb 32 6e fe			ld (debug_mark),a  
44ee 3a fd 44			ld a, (.dmark+1)  
44f1 32 6f fe			ld (debug_mark+1),a  
44f4 3a fe 44			ld a, (.dmark+2)  
44f7 32 70 fe			ld (debug_mark+2),a  
44fa 18 03			jr .pastdmark  
44fc ..			.dmark: db "S2N"  
44ff f1			.pastdmark: pop af  
4500			endm  
# End of macro DMARK
4500						CALLMONITOR 
4500 cd a5 18			call break_point_state  
4503				endm  
# End of macro CALLMONITOR
4503					endif 
4503			 
4503					;FORTH_DSP 
4503					FORTH_DSP_VALUE 
4503 cd f9 20			call macro_forth_dsp_value 
4506				endm 
# End of macro FORTH_DSP_VALUE
4506					;inc hl 
4506			 
4506 eb					ex de, hl 
4507					if DEBUG_FORTH_WORDS 
4507						DMARK "S2a" 
4507 f5				push af  
4508 3a 1c 45			ld a, (.dmark)  
450b 32 6e fe			ld (debug_mark),a  
450e 3a 1d 45			ld a, (.dmark+1)  
4511 32 6f fe			ld (debug_mark+1),a  
4514 3a 1e 45			ld a, (.dmark+2)  
4517 32 70 fe			ld (debug_mark+2),a  
451a 18 03			jr .pastdmark  
451c ..			.dmark: db "S2a"  
451f f1			.pastdmark: pop af  
4520			endm  
# End of macro DMARK
4520						CALLMONITOR 
4520 cd a5 18			call break_point_state  
4523				endm  
# End of macro CALLMONITOR
4523					endif 
4523 cd f3 12				call string_to_uint16 
4526			 
4526					if DEBUG_FORTH_WORDS 
4526						DMARK "S2b" 
4526 f5				push af  
4527 3a 3b 45			ld a, (.dmark)  
452a 32 6e fe			ld (debug_mark),a  
452d 3a 3c 45			ld a, (.dmark+1)  
4530 32 6f fe			ld (debug_mark+1),a  
4533 3a 3d 45			ld a, (.dmark+2)  
4536 32 70 fe			ld (debug_mark+2),a  
4539 18 03			jr .pastdmark  
453b ..			.dmark: db "S2b"  
453e f1			.pastdmark: pop af  
453f			endm  
# End of macro DMARK
453f						CALLMONITOR 
453f cd a5 18			call break_point_state  
4542				endm  
# End of macro CALLMONITOR
4542					endif 
4542			;		push hl 
4542					FORTH_DSP_POP 
4542 cd c8 21			call macro_forth_dsp_pop 
4545				endm 
# End of macro FORTH_DSP_POP
4545			;		pop hl 
4545					 
4545					if DEBUG_FORTH_WORDS 
4545						DMARK "S2b" 
4545 f5				push af  
4546 3a 5a 45			ld a, (.dmark)  
4549 32 6e fe			ld (debug_mark),a  
454c 3a 5b 45			ld a, (.dmark+1)  
454f 32 6f fe			ld (debug_mark+1),a  
4552 3a 5c 45			ld a, (.dmark+2)  
4555 32 70 fe			ld (debug_mark+2),a  
4558 18 03			jr .pastdmark  
455a ..			.dmark: db "S2b"  
455d f1			.pastdmark: pop af  
455e			endm  
# End of macro DMARK
455e						CALLMONITOR 
455e cd a5 18			call break_point_state  
4561				endm  
# End of macro CALLMONITOR
4561					endif 
4561 cd 19 1f				call forth_push_numhl	 
4564			 
4564				 
4564				       NEXTW 
4564 c3 87 22			jp macro_next 
4567				endm 
# End of macro NEXTW
4567			.NUM2STR: 
4567				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4567 48				db WORD_SYS_CORE+52             
4568 76 45			dw .CONCAT            
456a 08				db 7 + 1 
456b .. 00			db "NUM2STR",0              
4573				endm 
# End of macro CWHEAD
4573			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4573			 
4573			;		; malloc a string to target 
4573			;		ld hl, 10     ; TODO max string size should be fine 
4573			;		call malloc 
4573			;		push hl    ; save malloc location 
4573			; 
4573			; 
4573			;; TODO check int type 
4573			;		FORTH_DSP_VALUEHL 
4573			;		ld a, l 
4573			;		call DispAToASCII   
4573			;;TODO need to chage above call to dump into string 
4573			; 
4573			; 
4573			 
4573				       NEXTW 
4573 c3 87 22			jp macro_next 
4576				endm 
# End of macro NEXTW
4576			 
4576			.CONCAT: 
4576				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4576 48				db WORD_SYS_CORE+52             
4577 29 46			dw .FIND            
4579 07				db 6 + 1 
457a .. 00			db "CONCAT",0              
4581				endm 
# End of macro CWHEAD
4581			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4581			 
4581			; TODO check string type 
4581			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4581			 
4581					if DEBUG_FORTH_WORDS_KEY 
4581						DMARK "CON" 
4581 f5				push af  
4582 3a 96 45			ld a, (.dmark)  
4585 32 6e fe			ld (debug_mark),a  
4588 3a 97 45			ld a, (.dmark+1)  
458b 32 6f fe			ld (debug_mark+1),a  
458e 3a 98 45			ld a, (.dmark+2)  
4591 32 70 fe			ld (debug_mark+2),a  
4594 18 03			jr .pastdmark  
4596 ..			.dmark: db "CON"  
4599 f1			.pastdmark: pop af  
459a			endm  
# End of macro DMARK
459a						CALLMONITOR 
459a cd a5 18			call break_point_state  
459d				endm  
# End of macro CALLMONITOR
459d					endif 
459d			 
459d			 
459d					FORTH_DSP_VALUE 
459d cd f9 20			call macro_forth_dsp_value 
45a0				endm 
# End of macro FORTH_DSP_VALUE
45a0 e5					push hl   ; s2 
45a1			 
45a1					FORTH_DSP_POP 
45a1 cd c8 21			call macro_forth_dsp_pop 
45a4				endm 
# End of macro FORTH_DSP_POP
45a4			 
45a4					FORTH_DSP_VALUE 
45a4 cd f9 20			call macro_forth_dsp_value 
45a7				endm 
# End of macro FORTH_DSP_VALUE
45a7			 
45a7 e5					push hl   ; s1 
45a8			 
45a8					FORTH_DSP_POP 
45a8 cd c8 21			call macro_forth_dsp_pop 
45ab				endm 
# End of macro FORTH_DSP_POP
45ab					 
45ab			 
45ab					; copy s1 
45ab			 
45ab				 
45ab					; save ptr 
45ab e1					pop hl  
45ac e5					push hl 
45ad 3e 00				ld a, 0 
45af cd 67 13				call strlent 
45b2					;inc hl    ; zer0 
45b2 06 00				ld b, 0 
45b4 4d					ld c, l 
45b5 e1					pop hl		 
45b6 11 ff f1				ld de, scratch	 
45b9					if DEBUG_FORTH_WORDS 
45b9						DMARK "CO1" 
45b9 f5				push af  
45ba 3a ce 45			ld a, (.dmark)  
45bd 32 6e fe			ld (debug_mark),a  
45c0 3a cf 45			ld a, (.dmark+1)  
45c3 32 6f fe			ld (debug_mark+1),a  
45c6 3a d0 45			ld a, (.dmark+2)  
45c9 32 70 fe			ld (debug_mark+2),a  
45cc 18 03			jr .pastdmark  
45ce ..			.dmark: db "CO1"  
45d1 f1			.pastdmark: pop af  
45d2			endm  
# End of macro DMARK
45d2						CALLMONITOR 
45d2 cd a5 18			call break_point_state  
45d5				endm  
# End of macro CALLMONITOR
45d5					endif 
45d5 ed b0				ldir 
45d7			 
45d7 e1					pop hl 
45d8 e5					push hl 
45d9 d5					push de 
45da			 
45da			 
45da 3e 00				ld a, 0 
45dc cd 67 13				call strlent 
45df 23					inc hl    ; zer0 
45e0 23					inc hl 
45e1 06 00				ld b, 0 
45e3 4d					ld c, l 
45e4 d1					pop de 
45e5 e1					pop hl		 
45e6					if DEBUG_FORTH_WORDS 
45e6						DMARK "CO2" 
45e6 f5				push af  
45e7 3a fb 45			ld a, (.dmark)  
45ea 32 6e fe			ld (debug_mark),a  
45ed 3a fc 45			ld a, (.dmark+1)  
45f0 32 6f fe			ld (debug_mark+1),a  
45f3 3a fd 45			ld a, (.dmark+2)  
45f6 32 70 fe			ld (debug_mark+2),a  
45f9 18 03			jr .pastdmark  
45fb ..			.dmark: db "CO2"  
45fe f1			.pastdmark: pop af  
45ff			endm  
# End of macro DMARK
45ff						CALLMONITOR 
45ff cd a5 18			call break_point_state  
4602				endm  
# End of macro CALLMONITOR
4602					endif 
4602 ed b0				ldir 
4604			 
4604			 
4604			 
4604 21 ff f1				ld hl, scratch 
4607					if DEBUG_FORTH_WORDS 
4607						DMARK "CO5" 
4607 f5				push af  
4608 3a 1c 46			ld a, (.dmark)  
460b 32 6e fe			ld (debug_mark),a  
460e 3a 1d 46			ld a, (.dmark+1)  
4611 32 6f fe			ld (debug_mark+1),a  
4614 3a 1e 46			ld a, (.dmark+2)  
4617 32 70 fe			ld (debug_mark+2),a  
461a 18 03			jr .pastdmark  
461c ..			.dmark: db "CO5"  
461f f1			.pastdmark: pop af  
4620			endm  
# End of macro DMARK
4620						CALLMONITOR 
4620 cd a5 18			call break_point_state  
4623				endm  
# End of macro CALLMONITOR
4623					endif 
4623			 
4623 cd 87 1f				call forth_push_str 
4626			 
4626			 
4626			 
4626			 
4626				       NEXTW 
4626 c3 87 22			jp macro_next 
4629				endm 
# End of macro NEXTW
4629			 
4629			 
4629			.FIND: 
4629				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4629 4b				db WORD_SYS_CORE+55             
462a e7 46			dw .LEN            
462c 05				db 4 + 1 
462d .. 00			db "FIND",0              
4632				endm 
# End of macro CWHEAD
4632			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4632			 
4632					if DEBUG_FORTH_WORDS_KEY 
4632						DMARK "FND" 
4632 f5				push af  
4633 3a 47 46			ld a, (.dmark)  
4636 32 6e fe			ld (debug_mark),a  
4639 3a 48 46			ld a, (.dmark+1)  
463c 32 6f fe			ld (debug_mark+1),a  
463f 3a 49 46			ld a, (.dmark+2)  
4642 32 70 fe			ld (debug_mark+2),a  
4645 18 03			jr .pastdmark  
4647 ..			.dmark: db "FND"  
464a f1			.pastdmark: pop af  
464b			endm  
# End of macro DMARK
464b						CALLMONITOR 
464b cd a5 18			call break_point_state  
464e				endm  
# End of macro CALLMONITOR
464e					endif 
464e			 
464e			; TODO check string type 
464e					FORTH_DSP_VALUE 
464e cd f9 20			call macro_forth_dsp_value 
4651				endm 
# End of macro FORTH_DSP_VALUE
4651			 
4651 e5					push hl    
4652 7e					ld a,(hl)    ; char to find   
4653			; TODO change char to substr 
4653			 
4653 f5					push af 
4654					 
4654			 
4654			 
4654					if DEBUG_FORTH_WORDS 
4654						DMARK "FN1" 
4654 f5				push af  
4655 3a 69 46			ld a, (.dmark)  
4658 32 6e fe			ld (debug_mark),a  
465b 3a 6a 46			ld a, (.dmark+1)  
465e 32 6f fe			ld (debug_mark+1),a  
4661 3a 6b 46			ld a, (.dmark+2)  
4664 32 70 fe			ld (debug_mark+2),a  
4667 18 03			jr .pastdmark  
4669 ..			.dmark: db "FN1"  
466c f1			.pastdmark: pop af  
466d			endm  
# End of macro DMARK
466d						CALLMONITOR 
466d cd a5 18			call break_point_state  
4670				endm  
# End of macro CALLMONITOR
4670					endif 
4670			 
4670					FORTH_DSP_POP 
4670 cd c8 21			call macro_forth_dsp_pop 
4673				endm 
# End of macro FORTH_DSP_POP
4673			 
4673					; string to search 
4673			 
4673					FORTH_DSP_VALUE 
4673 cd f9 20			call macro_forth_dsp_value 
4676				endm 
# End of macro FORTH_DSP_VALUE
4676			 
4676 d1					pop de  ; d is char to find  
4677			 
4677					if DEBUG_FORTH_WORDS 
4677						DMARK "FN2" 
4677 f5				push af  
4678 3a 8c 46			ld a, (.dmark)  
467b 32 6e fe			ld (debug_mark),a  
467e 3a 8d 46			ld a, (.dmark+1)  
4681 32 6f fe			ld (debug_mark+1),a  
4684 3a 8e 46			ld a, (.dmark+2)  
4687 32 70 fe			ld (debug_mark+2),a  
468a 18 03			jr .pastdmark  
468c ..			.dmark: db "FN2"  
468f f1			.pastdmark: pop af  
4690			endm  
# End of macro DMARK
4690						CALLMONITOR 
4690 cd a5 18			call break_point_state  
4693				endm  
# End of macro CALLMONITOR
4693					endif 
4693					 
4693 01 00 00				ld bc, 0 
4696 7e			.findchar:      ld a,(hl) 
4697 fe 00				cp 0   		 
4699 28 27				jr z, .finddone     
469b ba					cp d 
469c 28 20				jr z, .foundchar 
469e 03					inc bc 
469f 23					inc hl 
46a0					if DEBUG_FORTH_WORDS 
46a0						DMARK "FN3" 
46a0 f5				push af  
46a1 3a b5 46			ld a, (.dmark)  
46a4 32 6e fe			ld (debug_mark),a  
46a7 3a b6 46			ld a, (.dmark+1)  
46aa 32 6f fe			ld (debug_mark+1),a  
46ad 3a b7 46			ld a, (.dmark+2)  
46b0 32 70 fe			ld (debug_mark+2),a  
46b3 18 03			jr .pastdmark  
46b5 ..			.dmark: db "FN3"  
46b8 f1			.pastdmark: pop af  
46b9			endm  
# End of macro DMARK
46b9						CALLMONITOR 
46b9 cd a5 18			call break_point_state  
46bc				endm  
# End of macro CALLMONITOR
46bc					endif 
46bc 18 d8				jr .findchar 
46be			 
46be			 
46be c5			.foundchar:	push bc 
46bf e1					pop hl 
46c0 18 03				jr .findexit 
46c2			 
46c2			 
46c2							 
46c2			 
46c2			.finddone:     ; got to end of string with no find 
46c2 21 00 00				ld hl, 0 
46c5			.findexit: 
46c5			 
46c5					if DEBUG_FORTH_WORDS 
46c5						DMARK "FNd" 
46c5 f5				push af  
46c6 3a da 46			ld a, (.dmark)  
46c9 32 6e fe			ld (debug_mark),a  
46cc 3a db 46			ld a, (.dmark+1)  
46cf 32 6f fe			ld (debug_mark+1),a  
46d2 3a dc 46			ld a, (.dmark+2)  
46d5 32 70 fe			ld (debug_mark+2),a  
46d8 18 03			jr .pastdmark  
46da ..			.dmark: db "FNd"  
46dd f1			.pastdmark: pop af  
46de			endm  
# End of macro DMARK
46de						CALLMONITOR 
46de cd a5 18			call break_point_state  
46e1				endm  
# End of macro CALLMONITOR
46e1					endif 
46e1 cd 19 1f			call forth_push_numhl 
46e4			 
46e4				       NEXTW 
46e4 c3 87 22			jp macro_next 
46e7				endm 
# End of macro NEXTW
46e7			 
46e7			.LEN: 
46e7				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
46e7 4c				db WORD_SYS_CORE+56             
46e8 51 47			dw .CHAR            
46ea 06				db 5 + 1 
46eb .. 00			db "COUNT",0              
46f1				endm 
# End of macro CWHEAD
46f1			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
46f1			 
46f1					if DEBUG_FORTH_WORDS_KEY 
46f1						DMARK "CNT" 
46f1 f5				push af  
46f2 3a 06 47			ld a, (.dmark)  
46f5 32 6e fe			ld (debug_mark),a  
46f8 3a 07 47			ld a, (.dmark+1)  
46fb 32 6f fe			ld (debug_mark+1),a  
46fe 3a 08 47			ld a, (.dmark+2)  
4701 32 70 fe			ld (debug_mark+2),a  
4704 18 03			jr .pastdmark  
4706 ..			.dmark: db "CNT"  
4709 f1			.pastdmark: pop af  
470a			endm  
# End of macro DMARK
470a						CALLMONITOR 
470a cd a5 18			call break_point_state  
470d				endm  
# End of macro CALLMONITOR
470d					endif 
470d			; TODO check string type 
470d					FORTH_DSP_VALUE 
470d cd f9 20			call macro_forth_dsp_value 
4710				endm 
# End of macro FORTH_DSP_VALUE
4710			 
4710			 
4710					if DEBUG_FORTH_WORDS 
4710						DMARK "CN?" 
4710 f5				push af  
4711 3a 25 47			ld a, (.dmark)  
4714 32 6e fe			ld (debug_mark),a  
4717 3a 26 47			ld a, (.dmark+1)  
471a 32 6f fe			ld (debug_mark+1),a  
471d 3a 27 47			ld a, (.dmark+2)  
4720 32 70 fe			ld (debug_mark+2),a  
4723 18 03			jr .pastdmark  
4725 ..			.dmark: db "CN?"  
4728 f1			.pastdmark: pop af  
4729			endm  
# End of macro DMARK
4729						CALLMONITOR 
4729 cd a5 18			call break_point_state  
472c				endm  
# End of macro CALLMONITOR
472c					endif 
472c cd 5c 13				call strlenz 
472f					if DEBUG_FORTH_WORDS 
472f						DMARK "CNl" 
472f f5				push af  
4730 3a 44 47			ld a, (.dmark)  
4733 32 6e fe			ld (debug_mark),a  
4736 3a 45 47			ld a, (.dmark+1)  
4739 32 6f fe			ld (debug_mark+1),a  
473c 3a 46 47			ld a, (.dmark+2)  
473f 32 70 fe			ld (debug_mark+2),a  
4742 18 03			jr .pastdmark  
4744 ..			.dmark: db "CNl"  
4747 f1			.pastdmark: pop af  
4748			endm  
# End of macro DMARK
4748						CALLMONITOR 
4748 cd a5 18			call break_point_state  
474b				endm  
# End of macro CALLMONITOR
474b					endif 
474b			 
474b cd 19 1f				call forth_push_numhl 
474e			 
474e			 
474e			 
474e				       NEXTW 
474e c3 87 22			jp macro_next 
4751				endm 
# End of macro NEXTW
4751			.CHAR: 
4751				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4751 4d				db WORD_SYS_CORE+57             
4752 87 47			dw .ENDSTR            
4754 05				db 4 + 1 
4755 .. 00			db "CHAR",0              
475a				endm 
# End of macro CWHEAD
475a			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
475a					if DEBUG_FORTH_WORDS_KEY 
475a						DMARK "CHR" 
475a f5				push af  
475b 3a 6f 47			ld a, (.dmark)  
475e 32 6e fe			ld (debug_mark),a  
4761 3a 70 47			ld a, (.dmark+1)  
4764 32 6f fe			ld (debug_mark+1),a  
4767 3a 71 47			ld a, (.dmark+2)  
476a 32 70 fe			ld (debug_mark+2),a  
476d 18 03			jr .pastdmark  
476f ..			.dmark: db "CHR"  
4772 f1			.pastdmark: pop af  
4773			endm  
# End of macro DMARK
4773						CALLMONITOR 
4773 cd a5 18			call break_point_state  
4776				endm  
# End of macro CALLMONITOR
4776					endif 
4776					FORTH_DSP 
4776 cd d6 20			call macro_forth_dsp 
4779				endm 
# End of macro FORTH_DSP
4779					;v5 FORTH_DSP_VALUE 
4779 23					inc hl      ; now at start of numeric as string 
477a			 
477a			;		push hl 
477a			 
477a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
477a cd c8 21			call macro_forth_dsp_pop 
477d				endm 
# End of macro FORTH_DSP_POP
477d			 
477d			;		pop hl 
477d			 
477d					; push the content of a onto the stack as a value 
477d			 
477d 7e					ld a,(hl)   ; get char 
477e 26 00				ld h,0 
4780 6f					ld l,a 
4781 cd 19 1f				call forth_push_numhl 
4784			 
4784				       NEXTW 
4784 c3 87 22			jp macro_next 
4787				endm 
# End of macro NEXTW
4787			 
4787			 
4787			 
4787			 
4787			.ENDSTR: 
4787			; eof 
4787			 
# End of file forth_words_str.asm
4787			include "forth_words_key.asm" 
4787			 
4787			; | ## Keyboard Words 
4787			 
4787			.KEY: 
4787				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4787 3e				db WORD_SYS_CORE+42             
4788 b7 47			dw .WAITK            
478a 04				db 3 + 1 
478b .. 00			db "KEY",0              
478f				endm 
# End of macro CWHEAD
478f			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
478f			 
478f					if DEBUG_FORTH_WORDS_KEY 
478f						DMARK "KEY" 
478f f5				push af  
4790 3a a4 47			ld a, (.dmark)  
4793 32 6e fe			ld (debug_mark),a  
4796 3a a5 47			ld a, (.dmark+1)  
4799 32 6f fe			ld (debug_mark+1),a  
479c 3a a6 47			ld a, (.dmark+2)  
479f 32 70 fe			ld (debug_mark+2),a  
47a2 18 03			jr .pastdmark  
47a4 ..			.dmark: db "KEY"  
47a7 f1			.pastdmark: pop af  
47a8			endm  
# End of macro DMARK
47a8						CALLMONITOR 
47a8 cd a5 18			call break_point_state  
47ab				endm  
# End of macro CALLMONITOR
47ab					endif 
47ab			; TODO currently waits 
47ab cd 2d 6d				call cin 
47ae					;call cin_wait 
47ae 6f					ld l, a 
47af 26 00				ld h, 0 
47b1 cd 19 1f				call forth_push_numhl 
47b4					NEXTW 
47b4 c3 87 22			jp macro_next 
47b7				endm 
# End of macro NEXTW
47b7			.WAITK: 
47b7				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
47b7 3f				db WORD_SYS_CORE+43             
47b8 e9 47			dw .ACCEPT            
47ba 06				db 5 + 1 
47bb .. 00			db "WAITK",0              
47c1				endm 
# End of macro CWHEAD
47c1			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
47c1					if DEBUG_FORTH_WORDS_KEY 
47c1						DMARK "WAI" 
47c1 f5				push af  
47c2 3a d6 47			ld a, (.dmark)  
47c5 32 6e fe			ld (debug_mark),a  
47c8 3a d7 47			ld a, (.dmark+1)  
47cb 32 6f fe			ld (debug_mark+1),a  
47ce 3a d8 47			ld a, (.dmark+2)  
47d1 32 70 fe			ld (debug_mark+2),a  
47d4 18 03			jr .pastdmark  
47d6 ..			.dmark: db "WAI"  
47d9 f1			.pastdmark: pop af  
47da			endm  
# End of macro DMARK
47da						CALLMONITOR 
47da cd a5 18			call break_point_state  
47dd				endm  
# End of macro CALLMONITOR
47dd					endif 
47dd cd 1c 6d				call cin_wait 
47e0 6f					ld l, a 
47e1 26 00				ld h, 0 
47e3 cd 19 1f				call forth_push_numhl 
47e6					NEXTW 
47e6 c3 87 22			jp macro_next 
47e9				endm 
# End of macro NEXTW
47e9			.ACCEPT: 
47e9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47e9 40				db WORD_SYS_CORE+44             
47ea 47 48			dw .EDIT            
47ec 07				db 6 + 1 
47ed .. 00			db "ACCEPT",0              
47f4				endm 
# End of macro CWHEAD
47f4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47f4					; TODO crashes on push 
47f4					if DEBUG_FORTH_WORDS_KEY 
47f4						DMARK "ACC" 
47f4 f5				push af  
47f5 3a 09 48			ld a, (.dmark)  
47f8 32 6e fe			ld (debug_mark),a  
47fb 3a 0a 48			ld a, (.dmark+1)  
47fe 32 6f fe			ld (debug_mark+1),a  
4801 3a 0b 48			ld a, (.dmark+2)  
4804 32 70 fe			ld (debug_mark+2),a  
4807 18 03			jr .pastdmark  
4809 ..			.dmark: db "ACC"  
480c f1			.pastdmark: pop af  
480d			endm  
# End of macro DMARK
480d						CALLMONITOR 
480d cd a5 18			call break_point_state  
4810				endm  
# End of macro CALLMONITOR
4810					endif 
4810 21 fd f3				ld hl, os_input 
4813 3e 00				ld a, 0 
4815 77					ld (hl),a 
4816 3a 68 fa				ld a,(f_cursor_ptr) 
4819 16 64				ld d, 100 
481b 0e 00				ld c, 0 
481d 1e 28				ld e, 40 
481f cd 2b 0f				call input_str 
4822					; TODO perhaps do a type check and wrap in quotes if not a number 
4822 21 fd f3				ld hl, os_input 
4825					if DEBUG_FORTH_WORDS 
4825						DMARK "AC1" 
4825 f5				push af  
4826 3a 3a 48			ld a, (.dmark)  
4829 32 6e fe			ld (debug_mark),a  
482c 3a 3b 48			ld a, (.dmark+1)  
482f 32 6f fe			ld (debug_mark+1),a  
4832 3a 3c 48			ld a, (.dmark+2)  
4835 32 70 fe			ld (debug_mark+2),a  
4838 18 03			jr .pastdmark  
483a ..			.dmark: db "AC1"  
483d f1			.pastdmark: pop af  
483e			endm  
# End of macro DMARK
483e						CALLMONITOR 
483e cd a5 18			call break_point_state  
4841				endm  
# End of macro CALLMONITOR
4841					endif 
4841 cd 87 1f				call forth_push_str 
4844					NEXTW 
4844 c3 87 22			jp macro_next 
4847				endm 
# End of macro NEXTW
4847			 
4847			.EDIT: 
4847				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4847 40				db WORD_SYS_CORE+44             
4848 e9 48			dw .ENDKEY            
484a 05				db 4 + 1 
484b .. 00			db "EDIT",0              
4850				endm 
# End of macro CWHEAD
4850			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4850			 
4850					; TODO does not copy from stack 
4850					if DEBUG_FORTH_WORDS_KEY 
4850						DMARK "EDT" 
4850 f5				push af  
4851 3a 65 48			ld a, (.dmark)  
4854 32 6e fe			ld (debug_mark),a  
4857 3a 66 48			ld a, (.dmark+1)  
485a 32 6f fe			ld (debug_mark+1),a  
485d 3a 67 48			ld a, (.dmark+2)  
4860 32 70 fe			ld (debug_mark+2),a  
4863 18 03			jr .pastdmark  
4865 ..			.dmark: db "EDT"  
4868 f1			.pastdmark: pop af  
4869			endm  
# End of macro DMARK
4869						CALLMONITOR 
4869 cd a5 18			call break_point_state  
486c				endm  
# End of macro CALLMONITOR
486c					endif 
486c			 
486c					;FORTH_DSP 
486c					FORTH_DSP_VALUEHL 
486c cd 10 21			call macro_dsp_valuehl 
486f				endm 
# End of macro FORTH_DSP_VALUEHL
486f			;		inc hl    ; TODO do type check 
486f			 
486f			;		call get_word_hl 
486f e5					push hl 
4870					if DEBUG_FORTH_WORDS 
4870						DMARK "EDp" 
4870 f5				push af  
4871 3a 85 48			ld a, (.dmark)  
4874 32 6e fe			ld (debug_mark),a  
4877 3a 86 48			ld a, (.dmark+1)  
487a 32 6f fe			ld (debug_mark+1),a  
487d 3a 87 48			ld a, (.dmark+2)  
4880 32 70 fe			ld (debug_mark+2),a  
4883 18 03			jr .pastdmark  
4885 ..			.dmark: db "EDp"  
4888 f1			.pastdmark: pop af  
4889			endm  
# End of macro DMARK
4889						CALLMONITOR 
4889 cd a5 18			call break_point_state  
488c				endm  
# End of macro CALLMONITOR
488c					endif 
488c				;	ld a, 0 
488c cd 5c 13				call strlenz 
488f 23					inc hl 
4890			 
4890 06 00				ld b, 0 
4892 4d					ld c, l 
4893			 
4893 e1					pop hl 
4894 11 fd f3				ld de, os_input 
4897					if DEBUG_FORTH_WORDS_KEY 
4897						DMARK "EDc" 
4897 f5				push af  
4898 3a ac 48			ld a, (.dmark)  
489b 32 6e fe			ld (debug_mark),a  
489e 3a ad 48			ld a, (.dmark+1)  
48a1 32 6f fe			ld (debug_mark+1),a  
48a4 3a ae 48			ld a, (.dmark+2)  
48a7 32 70 fe			ld (debug_mark+2),a  
48aa 18 03			jr .pastdmark  
48ac ..			.dmark: db "EDc"  
48af f1			.pastdmark: pop af  
48b0			endm  
# End of macro DMARK
48b0						CALLMONITOR 
48b0 cd a5 18			call break_point_state  
48b3				endm  
# End of macro CALLMONITOR
48b3					endif 
48b3 ed b0				ldir 
48b5			 
48b5			 
48b5 21 fd f3				ld hl, os_input 
48b8					;ld a, 0 
48b8					;ld (hl),a 
48b8 3a 68 fa				ld a,(f_cursor_ptr) 
48bb 16 64				ld d, 100 
48bd 0e 00				ld c, 0 
48bf 1e 28				ld e, 40 
48c1 cd 2b 0f				call input_str 
48c4					; TODO perhaps do a type check and wrap in quotes if not a number 
48c4 21 fd f3				ld hl, os_input 
48c7					if DEBUG_FORTH_WORDS 
48c7						DMARK "ED1" 
48c7 f5				push af  
48c8 3a dc 48			ld a, (.dmark)  
48cb 32 6e fe			ld (debug_mark),a  
48ce 3a dd 48			ld a, (.dmark+1)  
48d1 32 6f fe			ld (debug_mark+1),a  
48d4 3a de 48			ld a, (.dmark+2)  
48d7 32 70 fe			ld (debug_mark+2),a  
48da 18 03			jr .pastdmark  
48dc ..			.dmark: db "ED1"  
48df f1			.pastdmark: pop af  
48e0			endm  
# End of macro DMARK
48e0						CALLMONITOR 
48e0 cd a5 18			call break_point_state  
48e3				endm  
# End of macro CALLMONITOR
48e3					endif 
48e3 cd 87 1f				call forth_push_str 
48e6					NEXTW 
48e6 c3 87 22			jp macro_next 
48e9				endm 
# End of macro NEXTW
48e9			 
48e9			 
48e9			 
48e9			.ENDKEY: 
48e9			; eof 
48e9			 
# End of file forth_words_key.asm
48e9			 
48e9			if STORAGE_SE 
48e9			   	include "forth_words_storage.asm" 
48e9			 
48e9			; | ## Fixed Storage Words 
48e9			 
48e9			.RECORD: 
48e9			  
48e9				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
48e9 3a				db WORD_SYS_CORE+38             
48ea 8d 49			dw .BREAD            
48ec 07				db 6 + 1 
48ed .. 00			db "RECORD",0              
48f4				endm 
# End of macro CWHEAD
48f4			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
48f4			 
48f4					if DEBUG_FORTH_WORDS_KEY 
48f4						DMARK "REC" 
48f4 f5				push af  
48f5 3a 09 49			ld a, (.dmark)  
48f8 32 6e fe			ld (debug_mark),a  
48fb 3a 0a 49			ld a, (.dmark+1)  
48fe 32 6f fe			ld (debug_mark+1),a  
4901 3a 0b 49			ld a, (.dmark+2)  
4904 32 70 fe			ld (debug_mark+2),a  
4907 18 03			jr .pastdmark  
4909 ..			.dmark: db "REC"  
490c f1			.pastdmark: pop af  
490d			endm  
# End of macro DMARK
490d						CALLMONITOR 
490d cd a5 18			call break_point_state  
4910				endm  
# End of macro CALLMONITOR
4910					endif 
4910			 
4910					FORTH_DSP_VALUEHL 
4910 cd 10 21			call macro_dsp_valuehl 
4913				endm 
# End of macro FORTH_DSP_VALUEHL
4913			 
4913 e5					push hl    ; id 
4914			 
4914					FORTH_DSP_POP 
4914 cd c8 21			call macro_forth_dsp_pop 
4917				endm 
# End of macro FORTH_DSP_POP
4917			 
4917					FORTH_DSP_VALUEHL 
4917 cd 10 21			call macro_dsp_valuehl 
491a				endm 
# End of macro FORTH_DSP_VALUEHL
491a			 
491a					FORTH_DSP_POP 
491a cd c8 21			call macro_forth_dsp_pop 
491d				endm 
# End of macro FORTH_DSP_POP
491d			 
491d d1					pop de     ; get file id 
491e			 
491e					; e = file id 
491e					; l = file extent 
491e			 
491e			 
491e					; construct request to access file extent 
491e			 
491e			;		ld a, e 
491e 63					ld h, e 
491f					 
491f					 
491f					 
491f			 
491f					; e has id 
491f			 
491f 11 81 fa			ld de, store_page 
4922					if DEBUG_FORTH_WORDS 
4922						DMARK "REr" 
4922 f5				push af  
4923 3a 37 49			ld a, (.dmark)  
4926 32 6e fe			ld (debug_mark),a  
4929 3a 38 49			ld a, (.dmark+1)  
492c 32 6f fe			ld (debug_mark+1),a  
492f 3a 39 49			ld a, (.dmark+2)  
4932 32 70 fe			ld (debug_mark+2),a  
4935 18 03			jr .pastdmark  
4937 ..			.dmark: db "REr"  
493a f1			.pastdmark: pop af  
493b			endm  
# End of macro DMARK
493b						CALLMONITOR 
493b cd a5 18			call break_point_state  
493e				endm  
# End of macro CALLMONITOR
493e					endif 
493e cd 2d 09				call storage_read 
4941 cd 27 0f			call ishlzero 
4944 28 22			jr z, .recnotfound 
4946			 
4946			 
4946					if DEBUG_FORTH_WORDS 
4946						DMARK "REe" 
4946 f5				push af  
4947 3a 5b 49			ld a, (.dmark)  
494a 32 6e fe			ld (debug_mark),a  
494d 3a 5c 49			ld a, (.dmark+1)  
4950 32 6f fe			ld (debug_mark+1),a  
4953 3a 5d 49			ld a, (.dmark+2)  
4956 32 70 fe			ld (debug_mark+2),a  
4959 18 03			jr .pastdmark  
495b ..			.dmark: db "REe"  
495e f1			.pastdmark: pop af  
495f			endm  
# End of macro DMARK
495f						CALLMONITOR 
495f cd a5 18			call break_point_state  
4962				endm  
# End of macro CALLMONITOR
4962					endif 
4962 cd 87 1f			call forth_push_str 
4965			 
4965					NEXTW 
4965 c3 87 22			jp macro_next 
4968				endm 
# End of macro NEXTW
4968			 
4968			.recnotfound: 
4968					if DEBUG_FORTH_WORDS 
4968						DMARK "REf" 
4968 f5				push af  
4969 3a 7d 49			ld a, (.dmark)  
496c 32 6e fe			ld (debug_mark),a  
496f 3a 7e 49			ld a, (.dmark+1)  
4972 32 6f fe			ld (debug_mark+1),a  
4975 3a 7f 49			ld a, (.dmark+2)  
4978 32 70 fe			ld (debug_mark+2),a  
497b 18 03			jr .pastdmark  
497d ..			.dmark: db "REf"  
4980 f1			.pastdmark: pop af  
4981			endm  
# End of macro DMARK
4981						CALLMONITOR 
4981 cd a5 18			call break_point_state  
4984				endm  
# End of macro CALLMONITOR
4984					endif 
4984 21 ff 00			ld hl, 255 
4987 cd 19 1f			call forth_push_numhl 
498a				NEXTW 
498a c3 87 22			jp macro_next 
498d				endm 
# End of macro NEXTW
498d			 
498d			 
498d			.BREAD: 
498d			  
498d				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
498d 3a				db WORD_SYS_CORE+38             
498e 10 4a			dw .BWRITE            
4990 06				db 5 + 1 
4991 .. 00			db "BREAD",0              
4997				endm 
# End of macro CWHEAD
4997			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4997				 
4997					if DEBUG_FORTH_WORDS_KEY 
4997						DMARK "BRD" 
4997 f5				push af  
4998 3a ac 49			ld a, (.dmark)  
499b 32 6e fe			ld (debug_mark),a  
499e 3a ad 49			ld a, (.dmark+1)  
49a1 32 6f fe			ld (debug_mark+1),a  
49a4 3a ae 49			ld a, (.dmark+2)  
49a7 32 70 fe			ld (debug_mark+2),a  
49aa 18 03			jr .pastdmark  
49ac ..			.dmark: db "BRD"  
49af f1			.pastdmark: pop af  
49b0			endm  
# End of macro DMARK
49b0						CALLMONITOR 
49b0 cd a5 18			call break_point_state  
49b3				endm  
# End of macro CALLMONITOR
49b3					endif 
49b3			 
49b3				FORTH_DSP_VALUEHL 
49b3 cd 10 21			call macro_dsp_valuehl 
49b6				endm 
# End of macro FORTH_DSP_VALUEHL
49b6			 
49b6				FORTH_DSP_POP 
49b6 cd c8 21			call macro_forth_dsp_pop 
49b9				endm 
# End of macro FORTH_DSP_POP
49b9			 
49b9				; calc block address 
49b9			 
49b9 eb				ex de, hl 
49ba 3e 40			ld a, STORE_BLOCK_PHY 
49bc cd 81 0e			call Mult16 
49bf			 
49bf			 
49bf 11 81 fa			ld de, store_page 
49c2			 
49c2					if DEBUG_FORTH_WORDS 
49c2						DMARK "BR1" 
49c2 f5				push af  
49c3 3a d7 49			ld a, (.dmark)  
49c6 32 6e fe			ld (debug_mark),a  
49c9 3a d8 49			ld a, (.dmark+1)  
49cc 32 6f fe			ld (debug_mark+1),a  
49cf 3a d9 49			ld a, (.dmark+2)  
49d2 32 70 fe			ld (debug_mark+2),a  
49d5 18 03			jr .pastdmark  
49d7 ..			.dmark: db "BR1"  
49da f1			.pastdmark: pop af  
49db			endm  
# End of macro DMARK
49db						CALLMONITOR 
49db cd a5 18			call break_point_state  
49de				endm  
# End of macro CALLMONITOR
49de					endif 
49de			 
49de cd d4 03			call storage_read_block 
49e1			 
49e1 cd 27 0f			call ishlzero 
49e4 20 05			jr nz, .brfound 
49e6			 
49e6 cd 19 1f			call forth_push_numhl 
49e9 18 22			jr .brdone 
49eb			 
49eb			 
49eb			.brfound: 
49eb 21 83 fa		        ld hl, store_page+2 
49ee			 
49ee					if DEBUG_FORTH_WORDS 
49ee						DMARK "BR2" 
49ee f5				push af  
49ef 3a 03 4a			ld a, (.dmark)  
49f2 32 6e fe			ld (debug_mark),a  
49f5 3a 04 4a			ld a, (.dmark+1)  
49f8 32 6f fe			ld (debug_mark+1),a  
49fb 3a 05 4a			ld a, (.dmark+2)  
49fe 32 70 fe			ld (debug_mark+2),a  
4a01 18 03			jr .pastdmark  
4a03 ..			.dmark: db "BR2"  
4a06 f1			.pastdmark: pop af  
4a07			endm  
# End of macro DMARK
4a07						CALLMONITOR 
4a07 cd a5 18			call break_point_state  
4a0a				endm  
# End of macro CALLMONITOR
4a0a					endif 
4a0a			 
4a0a cd 87 1f			call forth_push_str 
4a0d			 
4a0d			 
4a0d			.brdone: 
4a0d			 
4a0d					NEXTW 
4a0d c3 87 22			jp macro_next 
4a10				endm 
# End of macro NEXTW
4a10			.BWRITE: 
4a10				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4a10 3a				db WORD_SYS_CORE+38             
4a11 a5 4a			dw .BUPD            
4a13 07				db 6 + 1 
4a14 .. 00			db "BWRITE",0              
4a1b				endm 
# End of macro CWHEAD
4a1b			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
4a1b			 
4a1b					if DEBUG_FORTH_WORDS_KEY 
4a1b						DMARK "BWR" 
4a1b f5				push af  
4a1c 3a 30 4a			ld a, (.dmark)  
4a1f 32 6e fe			ld (debug_mark),a  
4a22 3a 31 4a			ld a, (.dmark+1)  
4a25 32 6f fe			ld (debug_mark+1),a  
4a28 3a 32 4a			ld a, (.dmark+2)  
4a2b 32 70 fe			ld (debug_mark+2),a  
4a2e 18 03			jr .pastdmark  
4a30 ..			.dmark: db "BWR"  
4a33 f1			.pastdmark: pop af  
4a34			endm  
# End of macro DMARK
4a34						CALLMONITOR 
4a34 cd a5 18			call break_point_state  
4a37				endm  
# End of macro CALLMONITOR
4a37					endif 
4a37			 
4a37				FORTH_DSP_VALUEHL 
4a37 cd 10 21			call macro_dsp_valuehl 
4a3a				endm 
# End of macro FORTH_DSP_VALUEHL
4a3a			 
4a3a				; calc block address 
4a3a			 
4a3a eb				ex de, hl 
4a3b 3e 40			ld a, STORE_BLOCK_PHY 
4a3d cd 81 0e			call Mult16 
4a40			 
4a40 e5				push hl         ; address 
4a41			 
4a41				FORTH_DSP_POP 
4a41 cd c8 21			call macro_forth_dsp_pop 
4a44				endm 
# End of macro FORTH_DSP_POP
4a44			 
4a44				FORTH_DSP_VALUEHL 
4a44 cd 10 21			call macro_dsp_valuehl 
4a47				endm 
# End of macro FORTH_DSP_VALUEHL
4a47			 
4a47				FORTH_DSP_POP 
4a47 cd c8 21			call macro_forth_dsp_pop 
4a4a				endm 
# End of macro FORTH_DSP_POP
4a4a			 
4a4a cd 0a 0c			call storage_clear_page 
4a4d			 
4a4d				; copy string to store page 
4a4d			 
4a4d e5				push hl     ; save string address 
4a4e			 
4a4e 3e 00			ld a, 0 
4a50 cd 67 13			call strlent 
4a53			 
4a53 23				inc hl 
4a54			 
4a54 4d				ld c, l 
4a55 06 00			ld b, 0 
4a57			 
4a57 e1				pop hl 
4a58 11 83 fa			ld de, store_page + 2 
4a5b					if DEBUG_FORTH_WORDS 
4a5b						DMARK "BW1" 
4a5b f5				push af  
4a5c 3a 70 4a			ld a, (.dmark)  
4a5f 32 6e fe			ld (debug_mark),a  
4a62 3a 71 4a			ld a, (.dmark+1)  
4a65 32 6f fe			ld (debug_mark+1),a  
4a68 3a 72 4a			ld a, (.dmark+2)  
4a6b 32 70 fe			ld (debug_mark+2),a  
4a6e 18 03			jr .pastdmark  
4a70 ..			.dmark: db "BW1"  
4a73 f1			.pastdmark: pop af  
4a74			endm  
# End of macro DMARK
4a74						CALLMONITOR 
4a74 cd a5 18			call break_point_state  
4a77				endm  
# End of macro CALLMONITOR
4a77					endif 
4a77 ed b0			ldir 
4a79			 
4a79			 
4a79				; poke the start of the block with flags to prevent high level file ops hitting the block 
4a79			 
4a79 21 ff ff			ld hl, $ffff 
4a7c			 
4a7c 22 81 fa			ld (store_page), hl	 
4a7f				 
4a7f e1				pop hl    ; get address 
4a80 11 81 fa			ld de, store_page 
4a83			 
4a83					if DEBUG_FORTH_WORDS 
4a83						DMARK "BW2" 
4a83 f5				push af  
4a84 3a 98 4a			ld a, (.dmark)  
4a87 32 6e fe			ld (debug_mark),a  
4a8a 3a 99 4a			ld a, (.dmark+1)  
4a8d 32 6f fe			ld (debug_mark+1),a  
4a90 3a 9a 4a			ld a, (.dmark+2)  
4a93 32 70 fe			ld (debug_mark+2),a  
4a96 18 03			jr .pastdmark  
4a98 ..			.dmark: db "BW2"  
4a9b f1			.pastdmark: pop af  
4a9c			endm  
# End of macro DMARK
4a9c						CALLMONITOR 
4a9c cd a5 18			call break_point_state  
4a9f				endm  
# End of macro CALLMONITOR
4a9f					endif 
4a9f			 
4a9f cd 39 04			call storage_write_block 
4aa2			 
4aa2					NEXTW 
4aa2 c3 87 22			jp macro_next 
4aa5				endm 
# End of macro NEXTW
4aa5			 
4aa5			.BUPD: 
4aa5				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4aa5 3a				db WORD_SYS_CORE+38             
4aa6 fb 4a			dw .BYID            
4aa8 05				db 4 + 1 
4aa9 .. 00			db "BUPD",0              
4aae				endm 
# End of macro CWHEAD
4aae			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4aae			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4aae			; | | or completely different file system structure. 
4aae			 
4aae					if DEBUG_FORTH_WORDS_KEY 
4aae						DMARK "BUD" 
4aae f5				push af  
4aaf 3a c3 4a			ld a, (.dmark)  
4ab2 32 6e fe			ld (debug_mark),a  
4ab5 3a c4 4a			ld a, (.dmark+1)  
4ab8 32 6f fe			ld (debug_mark+1),a  
4abb 3a c5 4a			ld a, (.dmark+2)  
4abe 32 70 fe			ld (debug_mark+2),a  
4ac1 18 03			jr .pastdmark  
4ac3 ..			.dmark: db "BUD"  
4ac6 f1			.pastdmark: pop af  
4ac7			endm  
# End of macro DMARK
4ac7						CALLMONITOR 
4ac7 cd a5 18			call break_point_state  
4aca				endm  
# End of macro CALLMONITOR
4aca					endif 
4aca			 
4aca				FORTH_DSP_VALUEHL 
4aca cd 10 21			call macro_dsp_valuehl 
4acd				endm 
# End of macro FORTH_DSP_VALUEHL
4acd			 
4acd				; calc block address 
4acd			 
4acd eb				ex de, hl 
4ace 3e 40			ld a, STORE_BLOCK_PHY 
4ad0 cd 81 0e			call Mult16 
4ad3			 
4ad3				FORTH_DSP_POP 
4ad3 cd c8 21			call macro_forth_dsp_pop 
4ad6				endm 
# End of macro FORTH_DSP_POP
4ad6			 
4ad6			 
4ad6 11 81 fa			ld de, store_page 
4ad9			 
4ad9					if DEBUG_FORTH_WORDS 
4ad9						DMARK "BUe" 
4ad9 f5				push af  
4ada 3a ee 4a			ld a, (.dmark)  
4add 32 6e fe			ld (debug_mark),a  
4ae0 3a ef 4a			ld a, (.dmark+1)  
4ae3 32 6f fe			ld (debug_mark+1),a  
4ae6 3a f0 4a			ld a, (.dmark+2)  
4ae9 32 70 fe			ld (debug_mark+2),a  
4aec 18 03			jr .pastdmark  
4aee ..			.dmark: db "BUe"  
4af1 f1			.pastdmark: pop af  
4af2			endm  
# End of macro DMARK
4af2						CALLMONITOR 
4af2 cd a5 18			call break_point_state  
4af5				endm  
# End of macro CALLMONITOR
4af5					endif 
4af5			 
4af5 cd 39 04			call storage_write_block 
4af8			 
4af8					NEXTW 
4af8 c3 87 22			jp macro_next 
4afb				endm 
# End of macro NEXTW
4afb			 
4afb			.BYID: 
4afb			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4afb			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4afb			; 
4afb			;		 
4afb			;		if DEBUG_FORTH_WORDS_KEY 
4afb			;			DMARK "BYID" 
4afb			;			CALLMONITOR 
4afb			;		endif 
4afb			; 
4afb			;		; get direct address 
4afb			; 
4afb			;		FORTH_DSP_VALUEHL 
4afb			; 
4afb			;		FORTH_DSP_POP 
4afb			; 
4afb			;	; calc block address 
4afb			; 
4afb			;	ex de, hl 
4afb			;	ld a, STORE_BLOCK_PHY 
4afb			;	call Mult16 
4afb			;	;	do BREAD with number as param 
4afb			;	; push the file name	 
4afb			;	ld de, store_page 
4afb			;	call storage_read_block 
4afb			 ;       ld hl, store_page+2 
4afb			; 
4afb			; 
4afb			;		NEXTW 
4afb			;.BYNAME: 
4afb				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4afb 3a				db WORD_SYS_CORE+38             
4afc 14 4b			dw .DIR            
4afe 06				db 5 + 1 
4aff .. 00			db "GETID",0              
4b05				endm 
# End of macro CWHEAD
4b05			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4b05			 
4b05					; get pointer to file name to seek 
4b05			 
4b05					FORTH_DSP_VALUEHL 
4b05 cd 10 21			call macro_dsp_valuehl 
4b08				endm 
# End of macro FORTH_DSP_VALUEHL
4b08			 
4b08			 
4b08 cd fb 02				call storage_getid  
4b0b			 
4b0b					FORTH_DSP_POP 
4b0b cd c8 21			call macro_forth_dsp_pop 
4b0e				endm 
# End of macro FORTH_DSP_POP
4b0e			 
4b0e cd 19 1f				call forth_push_numhl 
4b11			 
4b11					NEXTW 
4b11 c3 87 22			jp macro_next 
4b14				endm 
# End of macro NEXTW
4b14			; 
4b14			.DIR: 
4b14				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4b14 3a				db WORD_SYS_CORE+38             
4b15 18 4c			dw .SAVE            
4b17 04				db 3 + 1 
4b18 .. 00			db "DIR",0              
4b1c				endm 
# End of macro CWHEAD
4b1c			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4b1c			 
4b1c					if DEBUG_FORTH_WORDS_KEY 
4b1c						DMARK "DIR" 
4b1c f5				push af  
4b1d 3a 31 4b			ld a, (.dmark)  
4b20 32 6e fe			ld (debug_mark),a  
4b23 3a 32 4b			ld a, (.dmark+1)  
4b26 32 6f fe			ld (debug_mark+1),a  
4b29 3a 33 4b			ld a, (.dmark+2)  
4b2c 32 70 fe			ld (debug_mark+2),a  
4b2f 18 03			jr .pastdmark  
4b31 ..			.dmark: db "DIR"  
4b34 f1			.pastdmark: pop af  
4b35			endm  
# End of macro DMARK
4b35						CALLMONITOR 
4b35 cd a5 18			call break_point_state  
4b38				endm  
# End of macro CALLMONITOR
4b38					endif 
4b38 cd 85 04			call storage_get_block_0 
4b3b			 
4b3b 21 81 fa			ld hl, store_page     ; get current id count 
4b3e 46				ld b, (hl) 
4b3f 0e 00			ld c, 0    ; count of files   
4b41					if DEBUG_FORTH_WORDS 
4b41						DMARK "DI1" 
4b41 f5				push af  
4b42 3a 56 4b			ld a, (.dmark)  
4b45 32 6e fe			ld (debug_mark),a  
4b48 3a 57 4b			ld a, (.dmark+1)  
4b4b 32 6f fe			ld (debug_mark+1),a  
4b4e 3a 58 4b			ld a, (.dmark+2)  
4b51 32 70 fe			ld (debug_mark+2),a  
4b54 18 03			jr .pastdmark  
4b56 ..			.dmark: db "DI1"  
4b59 f1			.pastdmark: pop af  
4b5a			endm  
# End of macro DMARK
4b5a						CALLMONITOR 
4b5a cd a5 18			call break_point_state  
4b5d				endm  
# End of macro CALLMONITOR
4b5d					endif 
4b5d			 
4b5d				; check for empty drive 
4b5d			 
4b5d 3e 00			ld a, 0 
4b5f b8				cp b 
4b60 ca ce 4b			jp z, .dirdone 
4b63			 
4b63				; for each of the current ids do a search for them and if found push to stack 
4b63			 
4b63 c5			.diritem:	push bc 
4b64 21 40 00				ld hl, STORE_BLOCK_PHY 
4b67 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4b69 58					ld e,b 
4b6a			 
4b6a			;		if DEBUG_FORTH_WORDS 
4b6a			;			DMARK "DI2" 
4b6a			;			CALLMONITOR 
4b6a			;		endif 
4b6a			 
4b6a cd 07 07				call storage_findnextid 
4b6d			 
4b6d			;		if DEBUG_FORTH_WORDS 
4b6d			;			DMARK "DI3" 
4b6d			;			CALLMONITOR 
4b6d			;		endif 
4b6d			 
4b6d					; if found hl will be non zero 
4b6d			 
4b6d cd 27 0f				call ishlzero 
4b70			;		ld a, l 
4b70			;		add h 
4b70			; 
4b70			;		cp 0 
4b70 28 59				jr z, .dirnotfound 
4b72			 
4b72					; increase count 
4b72			 
4b72 c1					pop bc	 
4b73 0c					inc c 
4b74 c5					push bc 
4b75					 
4b75			 
4b75					; get file header and push the file name 
4b75			 
4b75 11 81 fa				ld de, store_page 
4b78 cd d4 03				call storage_read_block 
4b7b			 
4b7b					; push file id to stack 
4b7b				 
4b7b 3a 81 fa				ld a, (store_page) 
4b7e 26 00				ld h, 0 
4b80 6f					ld l, a 
4b81 cd 19 1f				call forth_push_numhl 
4b84			 
4b84					; push extent count to stack  
4b84				 
4b84 3a 83 fa				ld a, (store_page+2) 
4b87 26 00				ld h, 0 
4b89 6f					ld l, a 
4b8a cd 19 1f				call forth_push_numhl 
4b8d			 
4b8d					; push file name 
4b8d			 
4b8d 21 84 fa				ld hl, store_page+3 
4b90					if DEBUG_FORTH_WORDS 
4b90						DMARK "DI5" 
4b90 f5				push af  
4b91 3a a5 4b			ld a, (.dmark)  
4b94 32 6e fe			ld (debug_mark),a  
4b97 3a a6 4b			ld a, (.dmark+1)  
4b9a 32 6f fe			ld (debug_mark+1),a  
4b9d 3a a7 4b			ld a, (.dmark+2)  
4ba0 32 70 fe			ld (debug_mark+2),a  
4ba3 18 03			jr .pastdmark  
4ba5 ..			.dmark: db "DI5"  
4ba8 f1			.pastdmark: pop af  
4ba9			endm  
# End of macro DMARK
4ba9						CALLMONITOR 
4ba9 cd a5 18			call break_point_state  
4bac				endm  
# End of macro CALLMONITOR
4bac					endif 
4bac cd 87 1f				call forth_push_str 
4baf					if DEBUG_FORTH_WORDS 
4baf						DMARK "DI6" 
4baf f5				push af  
4bb0 3a c4 4b			ld a, (.dmark)  
4bb3 32 6e fe			ld (debug_mark),a  
4bb6 3a c5 4b			ld a, (.dmark+1)  
4bb9 32 6f fe			ld (debug_mark+1),a  
4bbc 3a c6 4b			ld a, (.dmark+2)  
4bbf 32 70 fe			ld (debug_mark+2),a  
4bc2 18 03			jr .pastdmark  
4bc4 ..			.dmark: db "DI6"  
4bc7 f1			.pastdmark: pop af  
4bc8			endm  
# End of macro DMARK
4bc8						CALLMONITOR 
4bc8 cd a5 18			call break_point_state  
4bcb				endm  
# End of macro CALLMONITOR
4bcb					endif 
4bcb			.dirnotfound: 
4bcb c1					pop bc     
4bcc 10 95				djnz .diritem 
4bce				 
4bce			.dirdone:	 
4bce					if DEBUG_FORTH_WORDS 
4bce						DMARK "DI7" 
4bce f5				push af  
4bcf 3a e3 4b			ld a, (.dmark)  
4bd2 32 6e fe			ld (debug_mark),a  
4bd5 3a e4 4b			ld a, (.dmark+1)  
4bd8 32 6f fe			ld (debug_mark+1),a  
4bdb 3a e5 4b			ld a, (.dmark+2)  
4bde 32 70 fe			ld (debug_mark+2),a  
4be1 18 03			jr .pastdmark  
4be3 ..			.dmark: db "DI7"  
4be6 f1			.pastdmark: pop af  
4be7			endm  
# End of macro DMARK
4be7						CALLMONITOR 
4be7 cd a5 18			call break_point_state  
4bea				endm  
# End of macro CALLMONITOR
4bea					endif 
4bea			 
4bea					; push a count of the dir items found 
4bea			 
4bea 26 00				ld h, 0 
4bec 69					ld l, c 
4bed cd 19 1f				call forth_push_numhl 
4bf0			 
4bf0					; push the bank label 
4bf0			 
4bf0 cd 85 04				call storage_get_block_0 
4bf3			 
4bf3				 
4bf3 21 84 fa		 		ld hl, store_page+3 
4bf6			 
4bf6					if DEBUG_FORTH_WORDS 
4bf6						DMARK "DI8" 
4bf6 f5				push af  
4bf7 3a 0b 4c			ld a, (.dmark)  
4bfa 32 6e fe			ld (debug_mark),a  
4bfd 3a 0c 4c			ld a, (.dmark+1)  
4c00 32 6f fe			ld (debug_mark+1),a  
4c03 3a 0d 4c			ld a, (.dmark+2)  
4c06 32 70 fe			ld (debug_mark+2),a  
4c09 18 03			jr .pastdmark  
4c0b ..			.dmark: db "DI8"  
4c0e f1			.pastdmark: pop af  
4c0f			endm  
# End of macro DMARK
4c0f						CALLMONITOR 
4c0f cd a5 18			call break_point_state  
4c12				endm  
# End of macro CALLMONITOR
4c12					endif 
4c12 cd 87 1f				call forth_push_str 
4c15			 
4c15			 
4c15				 
4c15					NEXTW 
4c15 c3 87 22			jp macro_next 
4c18				endm 
# End of macro NEXTW
4c18			.SAVE: 
4c18			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4c18			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4c18			;		NEXTW 
4c18			;.LOAD: 
4c18			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4c18			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4c18			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4c18			;; > > The LOAD command can not be used in any user words or compound lines. 
4c18			; 
4c18			;		; store_openext use it. If zero it is EOF 
4c18			; 
4c18			;		; read block from current stream id 
4c18			;		; if the block does not contain zero term keep reading blocks until zero found 
4c18			;		; push the block to stack 
4c18			;		; save the block id to stream 
4c18			; 
4c18			; 
4c18			;		FORTH_DSP_VALUEHL 
4c18			; 
4c18			;;		push hl 
4c18			; 
4c18			;	if DEBUG_STORESE 
4c18			;		DMARK "LOA" 
4c18			;		CALLMONITOR 
4c18			;	endif 
4c18			;		FORTH_DSP_POP 
4c18			; 
4c18			;;		pop hl 
4c18			; 
4c18			;		ld h, l 
4c18			;		ld l, 0 
4c18			; 
4c18			;		push hl     ; stack holds current file id and extent to work with 
4c18			; 
4c18			; 
4c18			;		ld de, store_page      ; get block zero of file 
4c18			;	if DEBUG_STORESE 
4c18			;		DMARK "LO0" 
4c18			;		CALLMONITOR 
4c18			;	endif 
4c18			;		call storage_read 
4c18			; 
4c18			;		ld a, (store_page+2)    ; max extents for this file 
4c18			;		ld  (store_openmaxext),a   ; get our limit 
4c18			; 
4c18			;	if DEBUG_STORESE 
4c18			;		DMARK "LOE" 
4c18			;		CALLMONITOR 
4c18			;	endif 
4c18			; 
4c18			;; TODO dont know why max extents are not present 
4c18			;;		cp 0 
4c18			;;		jp z, .loadeof     ; dont read past eof 
4c18			; 
4c18			;;		ld a, 1   ; start from the head of the file 
4c18			; 
4c18			;.loadline:	pop hl 
4c18			;		inc hl 
4c18			;		ld  a, (store_openmaxext)   ; get our limit 
4c18			;	if DEBUG_STORESE 
4c18			;		DMARK "LOx" 
4c18			;		CALLMONITOR 
4c18			;	endif 
4c18			;		inc a 
4c18			;		cp l 
4c18			;		jp z, .loadeof 
4c18			;		push hl    ; save current extent 
4c18			; 
4c18			;		ld de, store_page 
4c18			; 
4c18			;	if DEBUG_STORESE 
4c18			;		DMARK "LO1" 
4c18			;		CALLMONITOR 
4c18			;	endif 
4c18			;		call storage_read 
4c18			; 
4c18			;	if DEBUG_STORESE 
4c18			;		DMARK "LO2" 
4c18			;		CALLMONITOR 
4c18			;	endif 
4c18			;	call ishlzero 
4c18			;	ld a, l 
4c18			;	add h 
4c18			;	cp 0 
4c18			;	jr z, .loadeof 
4c18			; 
4c18			;	; not eof so hl should point to data to exec 
4c18			; 
4c18			;	; will need to add the FORTH_END_BUFFER flag 
4c18			 ; 
4c18			;	ld hl, store_page+2 
4c18			;	ld bc, 255 
4c18			;	ld a, 0 
4c18			;	cpir 
4c18			;	if DEBUG_STORESE 
4c18			;		DMARK "LOt" 
4c18			;		CALLMONITOR 
4c18			;	endif 
4c18			;	dec hl 
4c18			;	ld a, ' ' 
4c18			;	ld (hl), a 
4c18			;	inc hl 
4c18			;	ld (hl), a 
4c18			;	inc hl 
4c18			;	ld (hl), a 
4c18			;	inc hl 
4c18			;	ld a, FORTH_END_BUFFER 
4c18			;	ld (hl), a 
4c18			; 
4c18			;	; TODO handle more than a single block read 
4c18			; 
4c18			; 
4c18			;	ld hl, store_page+2 
4c18			; 
4c18			;	ld (os_tok_ptr), hl 
4c18			; 
4c18			;	if DEBUG_STORESE 
4c18			;		DMARK "LO3" 
4c18			;		CALLMONITOR 
4c18			;	endif 
4c18			; 
4c18			;	call forthparse 
4c18			;	call forthexec 
4c18			;	call forthexec_cleanup 
4c18			; 
4c18			;	; go to next extent 
4c18			; 
4c18			;	; get next block  or mark as eof 
4c18			;	jp .loadline 
4c18			; 
4c18			; 
4c18			; 
4c18			;	       NEXTW 
4c18			;.loadeof:	ld a, 0 
4c18			;		ld (store_openext), a 
4c18			; 
4c18			;	if DEBUG_STORESE 
4c18			;		DMARK "LOF" 
4c18			;		CALLMONITOR 
4c18			;	endif 
4c18			;		ret 
4c18			;		;NEXTW 
4c18			;.BSAVE:   
4c18			; 
4c18			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4c18			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4c18			;		NEXTW 
4c18			;.BLOAD: 
4c18			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4c18			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4c18			;		NEXTW 
4c18			;;;; counter gap 
4c18			 
4c18			 
4c18			.SEO: 
4c18				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4c18 64				db WORD_SYS_CORE+80             
4c19 37 4c			dw .SEI            
4c1b 04				db 3 + 1 
4c1c .. 00			db "SEO",0              
4c20				endm 
# End of macro CWHEAD
4c20			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4c20			 
4c20					; get port 
4c20			 
4c20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c20 cd 10 21			call macro_dsp_valuehl 
4c23				endm 
# End of macro FORTH_DSP_VALUEHL
4c23			 
4c23 e5					push hl    ; u2 - byte 
4c24			 
4c24					; destroy value TOS 
4c24			 
4c24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c24 cd c8 21			call macro_forth_dsp_pop 
4c27				endm 
# End of macro FORTH_DSP_POP
4c27			 
4c27					; get byte to send 
4c27			 
4c27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c27 cd 10 21			call macro_dsp_valuehl 
4c2a				endm 
# End of macro FORTH_DSP_VALUEHL
4c2a			 
4c2a e5					push hl    ; u1 - addr 
4c2b			 
4c2b					; destroy value TOS 
4c2b			 
4c2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c2b cd c8 21			call macro_forth_dsp_pop 
4c2e				endm 
# End of macro FORTH_DSP_POP
4c2e			 
4c2e					; one value on hl get other one back 
4c2e			 
4c2e d1					pop de   ; u1 - byte 
4c2f			 
4c2f e1					pop hl   ; u2 - addr 
4c30			 
4c30					; TODO Send SPI byte 
4c30			 
4c30			 
4c30 7b					ld a, e 
4c31 cd d9 01				call se_writebyte 
4c34			 
4c34					 
4c34			 
4c34					NEXTW 
4c34 c3 87 22			jp macro_next 
4c37				endm 
# End of macro NEXTW
4c37			 
4c37			.SEI: 
4c37				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4c37 65				db WORD_SYS_CORE+81             
4c38 51 4c			dw .SFREE            
4c3a 04				db 3 + 1 
4c3b .. 00			db "SEI",0              
4c3f				endm 
# End of macro CWHEAD
4c3f			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4c3f			 
4c3f					; get port 
4c3f			 
4c3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c3f cd 10 21			call macro_dsp_valuehl 
4c42				endm 
# End of macro FORTH_DSP_VALUEHL
4c42			 
4c42			;		push hl 
4c42			 
4c42					; destroy value TOS 
4c42			 
4c42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c42 cd c8 21			call macro_forth_dsp_pop 
4c45				endm 
# End of macro FORTH_DSP_POP
4c45			 
4c45					; one value on hl get other one back 
4c45			 
4c45			;		pop hl 
4c45			 
4c45			 
4c45					; TODO Get SPI byte 
4c45			 
4c45 cd 7b 02				call se_readbyte 
4c48			 
4c48 26 00				ld h, 0 
4c4a 6f					ld l, a 
4c4b cd 19 1f				call forth_push_numhl 
4c4e			 
4c4e					NEXTW 
4c4e c3 87 22			jp macro_next 
4c51				endm 
# End of macro NEXTW
4c51			 
4c51			.SFREE: 
4c51				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4c51 67				db WORD_SYS_CORE+83             
4c52 80 4c			dw .SIZE            
4c54 06				db 5 + 1 
4c55 .. 00			db "FFREE",0              
4c5b				endm 
# End of macro CWHEAD
4c5b			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4c5b					if DEBUG_FORTH_WORDS_KEY 
4c5b						DMARK "FFR" 
4c5b f5				push af  
4c5c 3a 70 4c			ld a, (.dmark)  
4c5f 32 6e fe			ld (debug_mark),a  
4c62 3a 71 4c			ld a, (.dmark+1)  
4c65 32 6f fe			ld (debug_mark+1),a  
4c68 3a 72 4c			ld a, (.dmark+2)  
4c6b 32 70 fe			ld (debug_mark+2),a  
4c6e 18 03			jr .pastdmark  
4c70 ..			.dmark: db "FFR"  
4c73 f1			.pastdmark: pop af  
4c74			endm  
# End of macro DMARK
4c74						CALLMONITOR 
4c74 cd a5 18			call break_point_state  
4c77				endm  
# End of macro CALLMONITOR
4c77					endif 
4c77			 
4c77 cd a1 07				call storage_freeblocks 
4c7a			 
4c7a cd 19 1f				call forth_push_numhl 
4c7d			 
4c7d				       NEXTW 
4c7d c3 87 22			jp macro_next 
4c80				endm 
# End of macro NEXTW
4c80			.SIZE: 
4c80				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4c80 67				db WORD_SYS_CORE+83             
4c81 b4 4c			dw .CREATE            
4c83 05				db 4 + 1 
4c84 .. 00			db "SIZE",0              
4c89				endm 
# End of macro CWHEAD
4c89			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4c89					if DEBUG_FORTH_WORDS_KEY 
4c89						DMARK "SIZ" 
4c89 f5				push af  
4c8a 3a 9e 4c			ld a, (.dmark)  
4c8d 32 6e fe			ld (debug_mark),a  
4c90 3a 9f 4c			ld a, (.dmark+1)  
4c93 32 6f fe			ld (debug_mark+1),a  
4c96 3a a0 4c			ld a, (.dmark+2)  
4c99 32 70 fe			ld (debug_mark+2),a  
4c9c 18 03			jr .pastdmark  
4c9e ..			.dmark: db "SIZ"  
4ca1 f1			.pastdmark: pop af  
4ca2			endm  
# End of macro DMARK
4ca2						CALLMONITOR 
4ca2 cd a5 18			call break_point_state  
4ca5				endm  
# End of macro CALLMONITOR
4ca5					endif 
4ca5			 
4ca5					FORTH_DSP_VALUEHL 
4ca5 cd 10 21			call macro_dsp_valuehl 
4ca8				endm 
# End of macro FORTH_DSP_VALUEHL
4ca8			;		push hl 
4ca8					FORTH_DSP_POP 
4ca8 cd c8 21			call macro_forth_dsp_pop 
4cab				endm 
# End of macro FORTH_DSP_POP
4cab			;		pop hl 
4cab cd 03 04				call storage_file_size 
4cae			 
4cae cd 19 1f				call forth_push_numhl 
4cb1			  
4cb1			 
4cb1				       NEXTW 
4cb1 c3 87 22			jp macro_next 
4cb4				endm 
# End of macro NEXTW
4cb4			 
4cb4			.CREATE: 
4cb4				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4cb4 68				db WORD_SYS_CORE+84             
4cb5 22 4d			dw .APPEND            
4cb7 07				db 6 + 1 
4cb8 .. 00			db "CREATE",0              
4cbf				endm 
# End of macro CWHEAD
4cbf			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4cbf			; | | e.g.  
4cbf			; | | TestProgram CREATE 
4cbf			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4cbf			; | |  
4cbf			; | | Max file IDs are 255. 
4cbf			; | |  
4cbf					 
4cbf					if DEBUG_FORTH_WORDS_KEY 
4cbf						DMARK "CRT" 
4cbf f5				push af  
4cc0 3a d4 4c			ld a, (.dmark)  
4cc3 32 6e fe			ld (debug_mark),a  
4cc6 3a d5 4c			ld a, (.dmark+1)  
4cc9 32 6f fe			ld (debug_mark+1),a  
4ccc 3a d6 4c			ld a, (.dmark+2)  
4ccf 32 70 fe			ld (debug_mark+2),a  
4cd2 18 03			jr .pastdmark  
4cd4 ..			.dmark: db "CRT"  
4cd7 f1			.pastdmark: pop af  
4cd8			endm  
# End of macro DMARK
4cd8						CALLMONITOR 
4cd8 cd a5 18			call break_point_state  
4cdb				endm  
# End of macro CALLMONITOR
4cdb					endif 
4cdb			;		call storage_get_block_0 
4cdb			 
4cdb					; TODO pop hl 
4cdb			 
4cdb					;v5 FORTH_DSP_VALUE 
4cdb					FORTH_DSP_VALUE 
4cdb cd f9 20			call macro_forth_dsp_value 
4cde				endm 
# End of macro FORTH_DSP_VALUE
4cde			 
4cde				if DEBUG_STORESE 
4cde					DMARK "CR1" 
4cde f5				push af  
4cdf 3a f3 4c			ld a, (.dmark)  
4ce2 32 6e fe			ld (debug_mark),a  
4ce5 3a f4 4c			ld a, (.dmark+1)  
4ce8 32 6f fe			ld (debug_mark+1),a  
4ceb 3a f5 4c			ld a, (.dmark+2)  
4cee 32 70 fe			ld (debug_mark+2),a  
4cf1 18 03			jr .pastdmark  
4cf3 ..			.dmark: db "CR1"  
4cf6 f1			.pastdmark: pop af  
4cf7			endm  
# End of macro DMARK
4cf7					CALLMONITOR 
4cf7 cd a5 18			call break_point_state  
4cfa				endm  
# End of macro CALLMONITOR
4cfa				endif 
4cfa			;		push hl 
4cfa			;		FORTH_DSP_POP 
4cfa			;		pop hl 
4cfa			 
4cfa			;		inc hl   ; move past the type marker 
4cfa			 
4cfa cd d7 07				call storage_create 
4cfd			 
4cfd				if DEBUG_STORESE 
4cfd					DMARK "CT1" 
4cfd f5				push af  
4cfe 3a 12 4d			ld a, (.dmark)  
4d01 32 6e fe			ld (debug_mark),a  
4d04 3a 13 4d			ld a, (.dmark+1)  
4d07 32 6f fe			ld (debug_mark+1),a  
4d0a 3a 14 4d			ld a, (.dmark+2)  
4d0d 32 70 fe			ld (debug_mark+2),a  
4d10 18 03			jr .pastdmark  
4d12 ..			.dmark: db "CT1"  
4d15 f1			.pastdmark: pop af  
4d16			endm  
# End of macro DMARK
4d16					CALLMONITOR 
4d16 cd a5 18			call break_point_state  
4d19				endm  
# End of macro CALLMONITOR
4d19				endif 
4d19			;		push hl 
4d19					FORTH_DSP_POP 
4d19 cd c8 21			call macro_forth_dsp_pop 
4d1c				endm 
# End of macro FORTH_DSP_POP
4d1c			;		pop hl 
4d1c					; push file id to stack 
4d1c cd 19 1f				call forth_push_numhl 
4d1f			 
4d1f			 
4d1f			 
4d1f				       NEXTW 
4d1f c3 87 22			jp macro_next 
4d22				endm 
# End of macro NEXTW
4d22			 
4d22			.APPEND: 
4d22				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4d22 69				db WORD_SYS_CORE+85             
4d23 b3 4d			dw .SDEL            
4d25 07				db 6 + 1 
4d26 .. 00			db "APPEND",0              
4d2d				endm 
# End of macro CWHEAD
4d2d			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4d2d			; | | e.g. 
4d2d			; | | Test CREATE      -> $01 
4d2d			; | | "A string to add to file" $01 APPEND 
4d2d			; | |  
4d2d			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4d2d					if DEBUG_FORTH_WORDS_KEY 
4d2d						DMARK "APP" 
4d2d f5				push af  
4d2e 3a 42 4d			ld a, (.dmark)  
4d31 32 6e fe			ld (debug_mark),a  
4d34 3a 43 4d			ld a, (.dmark+1)  
4d37 32 6f fe			ld (debug_mark+1),a  
4d3a 3a 44 4d			ld a, (.dmark+2)  
4d3d 32 70 fe			ld (debug_mark+2),a  
4d40 18 03			jr .pastdmark  
4d42 ..			.dmark: db "APP"  
4d45 f1			.pastdmark: pop af  
4d46			endm  
# End of macro DMARK
4d46						CALLMONITOR 
4d46 cd a5 18			call break_point_state  
4d49				endm  
# End of macro CALLMONITOR
4d49					endif 
4d49			 
4d49					FORTH_DSP_VALUEHL 
4d49 cd 10 21			call macro_dsp_valuehl 
4d4c				endm 
# End of macro FORTH_DSP_VALUEHL
4d4c e5					push hl 	; save file id 
4d4d			 
4d4d				if DEBUG_STORESE 
4d4d					DMARK "AP1" 
4d4d f5				push af  
4d4e 3a 62 4d			ld a, (.dmark)  
4d51 32 6e fe			ld (debug_mark),a  
4d54 3a 63 4d			ld a, (.dmark+1)  
4d57 32 6f fe			ld (debug_mark+1),a  
4d5a 3a 64 4d			ld a, (.dmark+2)  
4d5d 32 70 fe			ld (debug_mark+2),a  
4d60 18 03			jr .pastdmark  
4d62 ..			.dmark: db "AP1"  
4d65 f1			.pastdmark: pop af  
4d66			endm  
# End of macro DMARK
4d66					CALLMONITOR 
4d66 cd a5 18			call break_point_state  
4d69				endm  
# End of macro CALLMONITOR
4d69				endif 
4d69					FORTH_DSP_POP 
4d69 cd c8 21			call macro_forth_dsp_pop 
4d6c				endm 
# End of macro FORTH_DSP_POP
4d6c			 
4d6c					FORTH_DSP_VALUEHL 
4d6c cd 10 21			call macro_dsp_valuehl 
4d6f				endm 
# End of macro FORTH_DSP_VALUEHL
4d6f					;v5 FORTH_DSP_VALUE 
4d6f e5					push hl 	; save ptr to string to save 
4d70			 
4d70				if DEBUG_STORESE 
4d70					DMARK "AP1" 
4d70 f5				push af  
4d71 3a 85 4d			ld a, (.dmark)  
4d74 32 6e fe			ld (debug_mark),a  
4d77 3a 86 4d			ld a, (.dmark+1)  
4d7a 32 6f fe			ld (debug_mark+1),a  
4d7d 3a 87 4d			ld a, (.dmark+2)  
4d80 32 70 fe			ld (debug_mark+2),a  
4d83 18 03			jr .pastdmark  
4d85 ..			.dmark: db "AP1"  
4d88 f1			.pastdmark: pop af  
4d89			endm  
# End of macro DMARK
4d89					CALLMONITOR 
4d89 cd a5 18			call break_point_state  
4d8c				endm  
# End of macro CALLMONITOR
4d8c				endif 
4d8c					FORTH_DSP_POP 
4d8c cd c8 21			call macro_forth_dsp_pop 
4d8f				endm 
# End of macro FORTH_DSP_POP
4d8f			 
4d8f d1					pop de 
4d90 e1					pop hl 
4d91				if DEBUG_STORESE 
4d91					DMARK "AP2" 
4d91 f5				push af  
4d92 3a a6 4d			ld a, (.dmark)  
4d95 32 6e fe			ld (debug_mark),a  
4d98 3a a7 4d			ld a, (.dmark+1)  
4d9b 32 6f fe			ld (debug_mark+1),a  
4d9e 3a a8 4d			ld a, (.dmark+2)  
4da1 32 70 fe			ld (debug_mark+2),a  
4da4 18 03			jr .pastdmark  
4da6 ..			.dmark: db "AP2"  
4da9 f1			.pastdmark: pop af  
4daa			endm  
# End of macro DMARK
4daa					CALLMONITOR 
4daa cd a5 18			call break_point_state  
4dad				endm  
# End of macro CALLMONITOR
4dad				endif 
4dad					;inc de ; skip var type indicator 
4dad			 
4dad					; TODO how to append numerics???? 
4dad			 
4dad cd be 0a				call storage_append		 
4db0			 
4db0				       NEXTW 
4db0 c3 87 22			jp macro_next 
4db3				endm 
# End of macro NEXTW
4db3			.SDEL: 
4db3				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4db3 6a				db WORD_SYS_CORE+86             
4db4 ff 4d			dw .OPEN            
4db6 05				db 4 + 1 
4db7 .. 00			db "ERA",0              
4dbb				endm 
# End of macro CWHEAD
4dbb			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4dbb					FORTH_DSP_VALUEHL 
4dbb cd 10 21			call macro_dsp_valuehl 
4dbe				endm 
# End of macro FORTH_DSP_VALUEHL
4dbe			;		push hl 	; save file id 
4dbe			 
4dbe					if DEBUG_FORTH_WORDS_KEY 
4dbe						DMARK "ERA" 
4dbe f5				push af  
4dbf 3a d3 4d			ld a, (.dmark)  
4dc2 32 6e fe			ld (debug_mark),a  
4dc5 3a d4 4d			ld a, (.dmark+1)  
4dc8 32 6f fe			ld (debug_mark+1),a  
4dcb 3a d5 4d			ld a, (.dmark+2)  
4dce 32 70 fe			ld (debug_mark+2),a  
4dd1 18 03			jr .pastdmark  
4dd3 ..			.dmark: db "ERA"  
4dd6 f1			.pastdmark: pop af  
4dd7			endm  
# End of macro DMARK
4dd7						CALLMONITOR 
4dd7 cd a5 18			call break_point_state  
4dda				endm  
# End of macro CALLMONITOR
4dda					endif 
4dda				if DEBUG_STORESE 
4dda					DMARK "ER1" 
4dda f5				push af  
4ddb 3a ef 4d			ld a, (.dmark)  
4dde 32 6e fe			ld (debug_mark),a  
4de1 3a f0 4d			ld a, (.dmark+1)  
4de4 32 6f fe			ld (debug_mark+1),a  
4de7 3a f1 4d			ld a, (.dmark+2)  
4dea 32 70 fe			ld (debug_mark+2),a  
4ded 18 03			jr .pastdmark  
4def ..			.dmark: db "ER1"  
4df2 f1			.pastdmark: pop af  
4df3			endm  
# End of macro DMARK
4df3					CALLMONITOR 
4df3 cd a5 18			call break_point_state  
4df6				endm  
# End of macro CALLMONITOR
4df6				endif 
4df6					FORTH_DSP_POP 
4df6 cd c8 21			call macro_forth_dsp_pop 
4df9				endm 
# End of macro FORTH_DSP_POP
4df9			 
4df9			;		pop hl 
4df9			 
4df9 cd 16 06				call storage_erase 
4dfc				       NEXTW 
4dfc c3 87 22			jp macro_next 
4dff				endm 
# End of macro NEXTW
4dff			 
4dff			.OPEN: 
4dff				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4dff 6b				db WORD_SYS_CORE+87             
4e00 93 4e			dw .READ            
4e02 05				db 4 + 1 
4e03 .. 00			db "OPEN",0              
4e08				endm 
# End of macro CWHEAD
4e08			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4e08			; | | e.g. 
4e08			; | | $01 OPEN $01 DO $01 READ . LOOP 
4e08			; | | 
4e08			; | | Will return with 255 blocks if the file does not exist 
4e08			 
4e08					if DEBUG_FORTH_WORDS_KEY 
4e08						DMARK "OPN" 
4e08 f5				push af  
4e09 3a 1d 4e			ld a, (.dmark)  
4e0c 32 6e fe			ld (debug_mark),a  
4e0f 3a 1e 4e			ld a, (.dmark+1)  
4e12 32 6f fe			ld (debug_mark+1),a  
4e15 3a 1f 4e			ld a, (.dmark+2)  
4e18 32 70 fe			ld (debug_mark+2),a  
4e1b 18 03			jr .pastdmark  
4e1d ..			.dmark: db "OPN"  
4e20 f1			.pastdmark: pop af  
4e21			endm  
# End of macro DMARK
4e21						CALLMONITOR 
4e21 cd a5 18			call break_point_state  
4e24				endm  
# End of macro CALLMONITOR
4e24					endif 
4e24					; TODO handle multiple file opens 
4e24			 
4e24 3e 01			       	ld a, 1 
4e26 32 73 fa				ld (store_openext), a 
4e29			 
4e29					; get max extents for this file 
4e29				 
4e29								 
4e29					FORTH_DSP_VALUEHL 
4e29 cd 10 21			call macro_dsp_valuehl 
4e2c				endm 
# End of macro FORTH_DSP_VALUEHL
4e2c			 
4e2c 65					ld h, l 
4e2d 2e 00				ld l, 0 
4e2f			 
4e2f					; store file id 
4e2f			 
4e2f 7c					ld a, h 
4e30 32 70 fa				ld (store_filecache), a 
4e33			 
4e33				if DEBUG_STORESE 
4e33					DMARK "OPN" 
4e33 f5				push af  
4e34 3a 48 4e			ld a, (.dmark)  
4e37 32 6e fe			ld (debug_mark),a  
4e3a 3a 49 4e			ld a, (.dmark+1)  
4e3d 32 6f fe			ld (debug_mark+1),a  
4e40 3a 4a 4e			ld a, (.dmark+2)  
4e43 32 70 fe			ld (debug_mark+2),a  
4e46 18 03			jr .pastdmark  
4e48 ..			.dmark: db "OPN"  
4e4b f1			.pastdmark: pop af  
4e4c			endm  
# End of macro DMARK
4e4c					CALLMONITOR 
4e4c cd a5 18			call break_point_state  
4e4f				endm  
# End of macro CALLMONITOR
4e4f				endif 
4e4f			;		push hl 
4e4f					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4e4f cd c8 21			call macro_forth_dsp_pop 
4e52				endm 
# End of macro FORTH_DSP_POP
4e52			;		pop hl 
4e52						 
4e52 11 81 fa				ld de, store_page      ; get block zero of file 
4e55 cd 2d 09				call storage_read 
4e58 cd 27 0f			call ishlzero 
4e5b 20 04			jr nz, .opfound 
4e5d			 
4e5d				; file does not exist so indicate with 255 extents in use 
4e5d			 
4e5d 3e ff			ld a, 255 
4e5f 18 29			jr .skipopeneof 
4e61			 
4e61			 
4e61			.opfound: 
4e61			 
4e61			 
4e61 3a 83 fa				ld a, (store_page+2)    ; max extents for this file 
4e64 32 72 fa				ld  (store_openmaxext), a   ; get our limit and push 
4e67					 
4e67				if DEBUG_STORESE 
4e67					DMARK "OPx" 
4e67 f5				push af  
4e68 3a 7c 4e			ld a, (.dmark)  
4e6b 32 6e fe			ld (debug_mark),a  
4e6e 3a 7d 4e			ld a, (.dmark+1)  
4e71 32 6f fe			ld (debug_mark+1),a  
4e74 3a 7e 4e			ld a, (.dmark+2)  
4e77 32 70 fe			ld (debug_mark+2),a  
4e7a 18 03			jr .pastdmark  
4e7c ..			.dmark: db "OPx"  
4e7f f1			.pastdmark: pop af  
4e80			endm  
# End of macro DMARK
4e80					CALLMONITOR 
4e80 cd a5 18			call break_point_state  
4e83				endm  
# End of macro CALLMONITOR
4e83				endif 
4e83 fe 00				cp 0 
4e85 20 03				jr nz, .skipopeneof 
4e87					; have opened an empty file 
4e87					 
4e87 32 73 fa				ld (store_openext), a 
4e8a			 
4e8a			.skipopeneof: 
4e8a			 
4e8a 6f					ld l, a 
4e8b 26 00				ld h, 0 
4e8d cd 19 1f				call forth_push_numhl 
4e90			 
4e90			 
4e90				       NEXTW 
4e90 c3 87 22			jp macro_next 
4e93				endm 
# End of macro NEXTW
4e93			.READ: 
4e93				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4e93 6c				db WORD_SYS_CORE+88             
4e94 bd 4f			dw .EOF            
4e96 05				db 4 + 1 
4e97 .. 00			db "READ",0              
4e9c				endm 
# End of macro CWHEAD
4e9c			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
4e9c			; | | e.g. 
4e9c			; | | $01 OPEN $01 DO READ . LOOP 
4e9c			; | | 
4e9c			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
4e9c			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
4e9c			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
4e9c			; | | two bytes contain the file id and extent. 
4e9c			; | |  
4e9c			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
4e9c			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
4e9c			 
4e9c					if DEBUG_FORTH_WORDS_KEY 
4e9c						DMARK "REA" 
4e9c f5				push af  
4e9d 3a b1 4e			ld a, (.dmark)  
4ea0 32 6e fe			ld (debug_mark),a  
4ea3 3a b2 4e			ld a, (.dmark+1)  
4ea6 32 6f fe			ld (debug_mark+1),a  
4ea9 3a b3 4e			ld a, (.dmark+2)  
4eac 32 70 fe			ld (debug_mark+2),a  
4eaf 18 03			jr .pastdmark  
4eb1 ..			.dmark: db "REA"  
4eb4 f1			.pastdmark: pop af  
4eb5			endm  
# End of macro DMARK
4eb5						CALLMONITOR 
4eb5 cd a5 18			call break_point_state  
4eb8				endm  
# End of macro CALLMONITOR
4eb8					endif 
4eb8					; store_openext use it. If zero it is EOF 
4eb8			 
4eb8					; read block from current stream id 
4eb8					; if the block does not contain zero term keep reading blocks until zero found 
4eb8					; push the block to stack 
4eb8					; save the block id to stream 
4eb8			 
4eb8			 
4eb8 cd ea 4f				call .testeof 
4ebb 3e 01				ld a, 1 
4ebd bd					cp l 
4ebe ca 99 4f				jp z, .ateof 
4ec1			 
4ec1			 
4ec1			;		FORTH_DSP_VALUEHL 
4ec1			 
4ec1			;		push hl 
4ec1			 
4ec1			;	if DEBUG_STORESE 
4ec1			;		DMARK "REA" 
4ec1			;		CALLMONITOR 
4ec1			;	endif 
4ec1			;		FORTH_DSP_POP 
4ec1			 
4ec1			;		pop hl 
4ec1				 
4ec1 3a 70 fa				ld a, (store_filecache) 
4ec4 67					ld h,a 
4ec5			 
4ec5 3a 73 fa				ld a, (store_openext) 
4ec8 6f					ld l, a 
4ec9					 
4ec9 fe 00				cp 0 
4ecb ca 99 4f				jp z, .ateof     ; dont read past eof 
4ece			 
4ece cd 0a 0c				call storage_clear_page 
4ed1			 
4ed1 11 81 fa				ld de, store_page 
4ed4				if DEBUG_STORESE 
4ed4					DMARK "RE1" 
4ed4 f5				push af  
4ed5 3a e9 4e			ld a, (.dmark)  
4ed8 32 6e fe			ld (debug_mark),a  
4edb 3a ea 4e			ld a, (.dmark+1)  
4ede 32 6f fe			ld (debug_mark+1),a  
4ee1 3a eb 4e			ld a, (.dmark+2)  
4ee4 32 70 fe			ld (debug_mark+2),a  
4ee7 18 03			jr .pastdmark  
4ee9 ..			.dmark: db "RE1"  
4eec f1			.pastdmark: pop af  
4eed			endm  
# End of macro DMARK
4eed					CALLMONITOR 
4eed cd a5 18			call break_point_state  
4ef0				endm  
# End of macro CALLMONITOR
4ef0				endif 
4ef0 cd 2d 09				call storage_read 
4ef3			 
4ef3				if DEBUG_STORESE 
4ef3					DMARK "RE2" 
4ef3 f5				push af  
4ef4 3a 08 4f			ld a, (.dmark)  
4ef7 32 6e fe			ld (debug_mark),a  
4efa 3a 09 4f			ld a, (.dmark+1)  
4efd 32 6f fe			ld (debug_mark+1),a  
4f00 3a 0a 4f			ld a, (.dmark+2)  
4f03 32 70 fe			ld (debug_mark+2),a  
4f06 18 03			jr .pastdmark  
4f08 ..			.dmark: db "RE2"  
4f0b f1			.pastdmark: pop af  
4f0c			endm  
# End of macro DMARK
4f0c					CALLMONITOR 
4f0c cd a5 18			call break_point_state  
4f0f				endm  
# End of macro CALLMONITOR
4f0f				endif 
4f0f cd 27 0f			call ishlzero 
4f12			;	ld a, l 
4f12			;	add h 
4f12			;	cp 0 
4f12 ca 99 4f			jp z, .readeof 
4f15			 
4f15				; not eof so hl should point to data to push to stack 
4f15			 
4f15				if DEBUG_STORESE 
4f15					DMARK "RE3" 
4f15 f5				push af  
4f16 3a 2a 4f			ld a, (.dmark)  
4f19 32 6e fe			ld (debug_mark),a  
4f1c 3a 2b 4f			ld a, (.dmark+1)  
4f1f 32 6f fe			ld (debug_mark+1),a  
4f22 3a 2c 4f			ld a, (.dmark+2)  
4f25 32 70 fe			ld (debug_mark+2),a  
4f28 18 03			jr .pastdmark  
4f2a ..			.dmark: db "RE3"  
4f2d f1			.pastdmark: pop af  
4f2e			endm  
# End of macro DMARK
4f2e					CALLMONITOR 
4f2e cd a5 18			call break_point_state  
4f31				endm  
# End of macro CALLMONITOR
4f31				endif 
4f31 cd 87 1f			call forth_push_str 
4f34			 
4f34				if DEBUG_STORESE 
4f34					DMARK "RE4" 
4f34 f5				push af  
4f35 3a 49 4f			ld a, (.dmark)  
4f38 32 6e fe			ld (debug_mark),a  
4f3b 3a 4a 4f			ld a, (.dmark+1)  
4f3e 32 6f fe			ld (debug_mark+1),a  
4f41 3a 4b 4f			ld a, (.dmark+2)  
4f44 32 70 fe			ld (debug_mark+2),a  
4f47 18 03			jr .pastdmark  
4f49 ..			.dmark: db "RE4"  
4f4c f1			.pastdmark: pop af  
4f4d			endm  
# End of macro DMARK
4f4d					CALLMONITOR 
4f4d cd a5 18			call break_point_state  
4f50				endm  
# End of macro CALLMONITOR
4f50				endif 
4f50				; get next block  or mark as eof 
4f50			 
4f50 3a 72 fa			ld a, (store_openmaxext)   ; get our limit 
4f53 4f				ld c, a	 
4f54 3a 73 fa			ld a, (store_openext) 
4f57			 
4f57				if DEBUG_STORESE 
4f57					DMARK "RE5" 
4f57 f5				push af  
4f58 3a 6c 4f			ld a, (.dmark)  
4f5b 32 6e fe			ld (debug_mark),a  
4f5e 3a 6d 4f			ld a, (.dmark+1)  
4f61 32 6f fe			ld (debug_mark+1),a  
4f64 3a 6e 4f			ld a, (.dmark+2)  
4f67 32 70 fe			ld (debug_mark+2),a  
4f6a 18 03			jr .pastdmark  
4f6c ..			.dmark: db "RE5"  
4f6f f1			.pastdmark: pop af  
4f70			endm  
# End of macro DMARK
4f70					CALLMONITOR 
4f70 cd a5 18			call break_point_state  
4f73				endm  
# End of macro CALLMONITOR
4f73				endif 
4f73 b9				cp c 
4f74 28 23			jr z, .readeof     ; at last extent 
4f76			 
4f76 3c					inc a 
4f77 32 73 fa				ld (store_openext), a 
4f7a			 
4f7a				if DEBUG_STORESE 
4f7a					DMARK "RE6" 
4f7a f5				push af  
4f7b 3a 8f 4f			ld a, (.dmark)  
4f7e 32 6e fe			ld (debug_mark),a  
4f81 3a 90 4f			ld a, (.dmark+1)  
4f84 32 6f fe			ld (debug_mark+1),a  
4f87 3a 91 4f			ld a, (.dmark+2)  
4f8a 32 70 fe			ld (debug_mark+2),a  
4f8d 18 03			jr .pastdmark  
4f8f ..			.dmark: db "RE6"  
4f92 f1			.pastdmark: pop af  
4f93			endm  
# End of macro DMARK
4f93					CALLMONITOR 
4f93 cd a5 18			call break_point_state  
4f96				endm  
# End of macro CALLMONITOR
4f96				endif 
4f96			 
4f96			 
4f96				       NEXTW 
4f96 c3 87 22			jp macro_next 
4f99				endm 
# End of macro NEXTW
4f99			.ateof: 
4f99				;	ld hl, .showeof 
4f99				;	call forth_push_str 
4f99 3e 00		.readeof:	ld a, 0 
4f9b 32 73 fa				ld (store_openext), a 
4f9e			 
4f9e					 
4f9e				if DEBUG_STORESE 
4f9e					DMARK "REF" 
4f9e f5				push af  
4f9f 3a b3 4f			ld a, (.dmark)  
4fa2 32 6e fe			ld (debug_mark),a  
4fa5 3a b4 4f			ld a, (.dmark+1)  
4fa8 32 6f fe			ld (debug_mark+1),a  
4fab 3a b5 4f			ld a, (.dmark+2)  
4fae 32 70 fe			ld (debug_mark+2),a  
4fb1 18 03			jr .pastdmark  
4fb3 ..			.dmark: db "REF"  
4fb6 f1			.pastdmark: pop af  
4fb7			endm  
# End of macro DMARK
4fb7					CALLMONITOR 
4fb7 cd a5 18			call break_point_state  
4fba				endm  
# End of macro CALLMONITOR
4fba				endif 
4fba				       NEXTW 
4fba c3 87 22			jp macro_next 
4fbd				endm 
# End of macro NEXTW
4fbd			 
4fbd			;.showeof:   db "eof", 0 
4fbd			 
4fbd			 
4fbd			.EOF: 
4fbd				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4fbd 6d				db WORD_SYS_CORE+89             
4fbe ff 4f			dw .FORMAT            
4fc0 04				db 3 + 1 
4fc1 .. 00			db "EOF",0              
4fc5				endm 
# End of macro CWHEAD
4fc5			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
4fc5			; | | e.g. 
4fc5			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
4fc5					; TODO if current block id for stream is zero then push true else false 
4fc5			 
4fc5					if DEBUG_FORTH_WORDS_KEY 
4fc5						DMARK "EOF" 
4fc5 f5				push af  
4fc6 3a da 4f			ld a, (.dmark)  
4fc9 32 6e fe			ld (debug_mark),a  
4fcc 3a db 4f			ld a, (.dmark+1)  
4fcf 32 6f fe			ld (debug_mark+1),a  
4fd2 3a dc 4f			ld a, (.dmark+2)  
4fd5 32 70 fe			ld (debug_mark+2),a  
4fd8 18 03			jr .pastdmark  
4fda ..			.dmark: db "EOF"  
4fdd f1			.pastdmark: pop af  
4fde			endm  
# End of macro DMARK
4fde						CALLMONITOR 
4fde cd a5 18			call break_point_state  
4fe1				endm  
# End of macro CALLMONITOR
4fe1					endif 
4fe1			 
4fe1					; TODO handlue multiple file streams 
4fe1			 
4fe1			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
4fe1 cd ea 4f				call .testeof 
4fe4 cd 19 1f				call forth_push_numhl 
4fe7			 
4fe7			 
4fe7				       NEXTW 
4fe7 c3 87 22			jp macro_next 
4fea				endm 
# End of macro NEXTW
4fea			 
4fea			.testeof: 
4fea 2e 01				ld l, 1 
4fec 3a 72 fa				ld a, (store_openmaxext) 
4fef fe 00				cp 0 
4ff1 28 09				jr  z, .eofdone   ; empty file 
4ff3 3a 73 fa				ld a, (store_openext) 
4ff6 fe 00				cp 0 
4ff8 28 02				jr  z, .eofdone 
4ffa 2e 00				ld l, 0 
4ffc 26 00		.eofdone:	ld h, 0 
4ffe c9					ret 
4fff			 
4fff			 
4fff			 
4fff			 
4fff			.FORMAT: 
4fff				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4fff 6d				db WORD_SYS_CORE+89             
5000 50 50			dw .LABEL            
5002 07				db 6 + 1 
5003 .. 00			db "FORMAT",0              
500a				endm 
# End of macro CWHEAD
500a			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
500a					; TODO if current block id for stream is zero then push true else false 
500a				 
500a				if DEBUG_STORESE 
500a					DMARK "FOR" 
500a f5				push af  
500b 3a 1f 50			ld a, (.dmark)  
500e 32 6e fe			ld (debug_mark),a  
5011 3a 20 50			ld a, (.dmark+1)  
5014 32 6f fe			ld (debug_mark+1),a  
5017 3a 21 50			ld a, (.dmark+2)  
501a 32 70 fe			ld (debug_mark+2),a  
501d 18 03			jr .pastdmark  
501f ..			.dmark: db "FOR"  
5022 f1			.pastdmark: pop af  
5023			endm  
# End of macro DMARK
5023					CALLMONITOR 
5023 cd a5 18			call break_point_state  
5026				endm  
# End of macro CALLMONITOR
5026				endif 
5026					; Wipes the bank check flags to cause a reformat on next block 0 read 
5026			 
5026 21 01 00				ld hl, 1 
5029 3e 00				ld a, 0 
502b cd d9 01				call se_writebyte 
502e			 
502e				if DEBUG_STORESE 
502e					DMARK "FO0" 
502e f5				push af  
502f 3a 43 50			ld a, (.dmark)  
5032 32 6e fe			ld (debug_mark),a  
5035 3a 44 50			ld a, (.dmark+1)  
5038 32 6f fe			ld (debug_mark+1),a  
503b 3a 45 50			ld a, (.dmark+2)  
503e 32 70 fe			ld (debug_mark+2),a  
5041 18 03			jr .pastdmark  
5043 ..			.dmark: db "FO0"  
5046 f1			.pastdmark: pop af  
5047			endm  
# End of macro DMARK
5047					CALLMONITOR 
5047 cd a5 18			call break_point_state  
504a				endm  
# End of macro CALLMONITOR
504a				endif 
504a					; force bank init 
504a			 
504a cd 85 04				call storage_get_block_0 
504d					 
504d				       NEXTW 
504d c3 87 22			jp macro_next 
5050				endm 
# End of macro NEXTW
5050			.LABEL: 
5050				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5050 6d				db WORD_SYS_CORE+89             
5051 9e 50			dw .STOREPAGE            
5053 06				db 5 + 1 
5054 .. 00			db "LABEL",0              
505a				endm 
# End of macro CWHEAD
505a			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
505a					; TODO test to see if bank is selected 
505a				 
505a					if DEBUG_FORTH_WORDS_KEY 
505a						DMARK "LBL" 
505a f5				push af  
505b 3a 6f 50			ld a, (.dmark)  
505e 32 6e fe			ld (debug_mark),a  
5061 3a 70 50			ld a, (.dmark+1)  
5064 32 6f fe			ld (debug_mark+1),a  
5067 3a 71 50			ld a, (.dmark+2)  
506a 32 70 fe			ld (debug_mark+2),a  
506d 18 03			jr .pastdmark  
506f ..			.dmark: db "LBL"  
5072 f1			.pastdmark: pop af  
5073			endm  
# End of macro DMARK
5073						CALLMONITOR 
5073 cd a5 18			call break_point_state  
5076				endm  
# End of macro CALLMONITOR
5076					endif 
5076			;	if DEBUG_STORESE 
5076			;		DMARK "LBL" 
5076			;		CALLMONITOR 
5076			;	endif 
5076					FORTH_DSP_VALUEHL 
5076 cd 10 21			call macro_dsp_valuehl 
5079				endm 
# End of macro FORTH_DSP_VALUEHL
5079					;v5FORTH_DSP_VALUE 
5079					 
5079			;		push hl 
5079					FORTH_DSP_POP 
5079 cd c8 21			call macro_forth_dsp_pop 
507c				endm 
# End of macro FORTH_DSP_POP
507c			;		pop hl 
507c			 
507c			;v5		inc hl   ; move past the type marker 
507c			 
507c				if DEBUG_STORESE 
507c					DMARK "LBl" 
507c f5				push af  
507d 3a 91 50			ld a, (.dmark)  
5080 32 6e fe			ld (debug_mark),a  
5083 3a 92 50			ld a, (.dmark+1)  
5086 32 6f fe			ld (debug_mark+1),a  
5089 3a 93 50			ld a, (.dmark+2)  
508c 32 70 fe			ld (debug_mark+2),a  
508f 18 03			jr .pastdmark  
5091 ..			.dmark: db "LBl"  
5094 f1			.pastdmark: pop af  
5095			endm  
# End of macro DMARK
5095					CALLMONITOR 
5095 cd a5 18			call break_point_state  
5098				endm  
# End of macro CALLMONITOR
5098				endif 
5098 cd a9 05				call storage_label 
509b			 
509b				       NEXTW 
509b c3 87 22			jp macro_next 
509e				endm 
# End of macro NEXTW
509e			.STOREPAGE: 
509e				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
509e 6d				db WORD_SYS_CORE+89             
509f d1 50			dw .LABELS            
50a1 0a				db 9 + 1 
50a2 .. 00			db "STOREPAGE",0              
50ac				endm 
# End of macro CWHEAD
50ac			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
50ac					; TODO test to see if bank is selected 
50ac				 
50ac					if DEBUG_FORTH_WORDS_KEY 
50ac						DMARK "STP" 
50ac f5				push af  
50ad 3a c1 50			ld a, (.dmark)  
50b0 32 6e fe			ld (debug_mark),a  
50b3 3a c2 50			ld a, (.dmark+1)  
50b6 32 6f fe			ld (debug_mark+1),a  
50b9 3a c3 50			ld a, (.dmark+2)  
50bc 32 70 fe			ld (debug_mark+2),a  
50bf 18 03			jr .pastdmark  
50c1 ..			.dmark: db "STP"  
50c4 f1			.pastdmark: pop af  
50c5			endm  
# End of macro DMARK
50c5						CALLMONITOR 
50c5 cd a5 18			call break_point_state  
50c8				endm  
# End of macro CALLMONITOR
50c8					endif 
50c8			;	if DEBUG_STORESE 
50c8			;		DMARK "STP" 
50c8			;		CALLMONITOR 
50c8			;	endif 
50c8			 
50c8 21 81 fa			ld hl, store_page 
50cb cd 19 1f			call forth_push_numhl 
50ce			 
50ce			 
50ce				       NEXTW 
50ce c3 87 22			jp macro_next 
50d1				endm 
# End of macro NEXTW
50d1			.LABELS: 
50d1				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
50d1 6d				db WORD_SYS_CORE+89             
50d2 5b 51			dw .SCONST1            
50d4 07				db 6 + 1 
50d5 .. 00			db "LABELS",0              
50dc				endm 
# End of macro CWHEAD
50dc			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
50dc					;  
50dc			 
50dc					; save the current device selected to restore afterwards 
50dc				 
50dc 3a 6a fa				ld a, (spi_device) 
50df f5					push af 
50e0			 
50e0			 
50e0					; run through each of the banks 
50e0			 
50e0 21 01 00				ld hl, 1 
50e3 cd 19 1f				call forth_push_numhl 
50e6 3e ff				ld a, SPI_CE_HIGH 
50e8 cb 87				res SPI_CE0, a 
50ea 32 6a fa				ld (spi_device), a 
50ed cd 85 04				call storage_get_block_0 
50f0 21 84 fa				ld hl, store_page+3 
50f3 cd 87 1f				call forth_push_str 
50f6			 
50f6					 
50f6 21 02 00				ld hl, 2 
50f9 cd 19 1f				call forth_push_numhl 
50fc 3e ff				ld a, SPI_CE_HIGH 
50fe cb 8f				res SPI_CE1, a 
5100 32 6a fa				ld (spi_device), a 
5103 cd 85 04				call storage_get_block_0 
5106 21 84 fa				ld hl, store_page+3 
5109 cd 87 1f				call forth_push_str 
510c			 
510c					 
510c 21 03 00				ld hl, 3 
510f cd 19 1f				call forth_push_numhl 
5112 3e ff				ld a, SPI_CE_HIGH 
5114 cb 97				res SPI_CE2, a 
5116 32 6a fa				ld (spi_device), a 
5119 cd 85 04				call storage_get_block_0 
511c 21 84 fa				ld hl, store_page+3 
511f cd 87 1f				call forth_push_str 
5122			 
5122			 
5122 21 04 00				ld hl, 4 
5125 cd 19 1f				call forth_push_numhl 
5128 3e ff				ld a, SPI_CE_HIGH 
512a cb 9f				res SPI_CE3, a 
512c 32 6a fa				ld (spi_device), a 
512f cd 85 04				call storage_get_block_0 
5132 21 84 fa				ld hl, store_page+3 
5135 cd 87 1f				call forth_push_str 
5138			 
5138					 
5138			 
5138 21 05 00				ld hl, 5 
513b cd 19 1f				call forth_push_numhl 
513e 3e ff				ld a, SPI_CE_HIGH 
5140 cb a7				res SPI_CE4, a 
5142 32 6a fa				ld (spi_device), a 
5145 cd 85 04				call storage_get_block_0 
5148 21 84 fa				ld hl, store_page+3 
514b cd 87 1f				call forth_push_str 
514e			 
514e					 
514e					; push fixed count of storage devices (on board) for now 
514e			 
514e 21 05 00				ld hl, 5 
5151 cd 19 1f				call forth_push_numhl 
5154			 
5154					; restore selected device  
5154				 
5154 f1					pop af 
5155 32 6a fa				ld (spi_device), a 
5158			 
5158				       NEXTW 
5158 c3 87 22			jp macro_next 
515b				endm 
# End of macro NEXTW
515b			 
515b			.SCONST1: 
515b				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
515b 6d				db WORD_SYS_CORE+89             
515c 72 51			dw .SCONST2            
515e 07				db 6 + 1 
515f .. 00			db "FILEID",0              
5166				endm 
# End of macro CWHEAD
5166			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5166 3a 70 fa				ld a, (store_filecache) 
5169 26 00				ld h, 0 
516b 6f					ld l, a 
516c cd 19 1f				call forth_push_numhl 
516f					NEXTW 
516f c3 87 22			jp macro_next 
5172				endm 
# End of macro NEXTW
5172			.SCONST2: 
5172				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5172 6d				db WORD_SYS_CORE+89             
5173 8a 51			dw .SCONST3            
5175 08				db 7 + 1 
5176 .. 00			db "FILEEXT",0              
517e				endm 
# End of macro CWHEAD
517e			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
517e 3a 73 fa				ld a, (store_openext) 
5181 26 00				ld h, 0 
5183 6f					ld l, a 
5184 cd 19 1f				call forth_push_numhl 
5187					NEXTW 
5187 c3 87 22			jp macro_next 
518a				endm 
# End of macro NEXTW
518a			.SCONST3: 
518a				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
518a 6d				db WORD_SYS_CORE+89             
518b a2 51			dw .SCONST4            
518d 08				db 7 + 1 
518e .. 00			db "FILEMAX",0              
5196				endm 
# End of macro CWHEAD
5196			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5196 3a 72 fa				ld a, (store_openmaxext) 
5199 26 00				ld h, 0 
519b 6f					ld l, a 
519c cd 19 1f				call forth_push_numhl 
519f					NEXTW 
519f c3 87 22			jp macro_next 
51a2				endm 
# End of macro NEXTW
51a2			.SCONST4: 
51a2				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
51a2 6d				db WORD_SYS_CORE+89             
51a3 bb 51			dw .ENDSTORAGE            
51a5 09				db 8 + 1 
51a6 .. 00			db "READCONT",0              
51af				endm 
# End of macro CWHEAD
51af			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
51af			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
51af			; | | a further read should, if applicable, be CONCAT to the previous read. 
51af 3a 74 fa				ld a, (store_readcont) 
51b2 26 00				ld h, 0 
51b4 6f					ld l, a 
51b5 cd 19 1f				call forth_push_numhl 
51b8					NEXTW 
51b8 c3 87 22			jp macro_next 
51bb				endm 
# End of macro NEXTW
51bb			.ENDSTORAGE: 
51bb			; eof 
# End of file forth_words_storage.asm
51bb			endif 
51bb				include "forth_words_device.asm" 
51bb			; Device related words 
51bb			 
51bb			; | ## Device Words 
51bb			 
51bb			if SOUND_ENABLE 
51bb			.NOTE: 
51bb				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
51bb 33				db WORD_SYS_CORE+31             
51bc e3 51			dw .AFTERSOUND            
51be 05				db 4 + 1 
51bf .. 00			db "NOTE",0              
51c4				endm 
# End of macro CWHEAD
51c4			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
51c4					if DEBUG_FORTH_WORDS_KEY 
51c4						DMARK "NTE" 
51c4 f5				push af  
51c5 3a d9 51			ld a, (.dmark)  
51c8 32 6e fe			ld (debug_mark),a  
51cb 3a da 51			ld a, (.dmark+1)  
51ce 32 6f fe			ld (debug_mark+1),a  
51d1 3a db 51			ld a, (.dmark+2)  
51d4 32 70 fe			ld (debug_mark+2),a  
51d7 18 03			jr .pastdmark  
51d9 ..			.dmark: db "NTE"  
51dc f1			.pastdmark: pop af  
51dd			endm  
# End of macro DMARK
51dd						CALLMONITOR 
51dd cd a5 18			call break_point_state  
51e0				endm  
# End of macro CALLMONITOR
51e0					endif 
51e0			 
51e0				 
51e0			 
51e0					NEXTW 
51e0 c3 87 22			jp macro_next 
51e3				endm 
# End of macro NEXTW
51e3			.AFTERSOUND: 
51e3			endif 
51e3			 
51e3			 
51e3			USE_GPIO: equ 0 
51e3			 
51e3			if USE_GPIO 
51e3			.GP1: 
51e3				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
51e3			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
51e3					NEXTW 
51e3			.GP2: 
51e3				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
51e3			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
51e3			 
51e3					NEXTW 
51e3			 
51e3			.GP3: 
51e3				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
51e3			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
51e3			 
51e3					NEXTW 
51e3			 
51e3			.GP4: 
51e3				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
51e3			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
51e3			 
51e3					NEXTW 
51e3			.SIN: 
51e3			 
51e3			 
51e3			endif 
51e3			 
51e3			 
51e3				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
51e3 33				db WORD_SYS_CORE+31             
51e4 18 52			dw .SOUT            
51e6 03				db 2 + 1 
51e7 .. 00			db "IN",0              
51ea				endm 
# End of macro CWHEAD
51ea			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
51ea					if DEBUG_FORTH_WORDS_KEY 
51ea						DMARK "IN." 
51ea f5				push af  
51eb 3a ff 51			ld a, (.dmark)  
51ee 32 6e fe			ld (debug_mark),a  
51f1 3a 00 52			ld a, (.dmark+1)  
51f4 32 6f fe			ld (debug_mark+1),a  
51f7 3a 01 52			ld a, (.dmark+2)  
51fa 32 70 fe			ld (debug_mark+2),a  
51fd 18 03			jr .pastdmark  
51ff ..			.dmark: db "IN."  
5202 f1			.pastdmark: pop af  
5203			endm  
# End of macro DMARK
5203						CALLMONITOR 
5203 cd a5 18			call break_point_state  
5206				endm  
# End of macro CALLMONITOR
5206					endif 
5206					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5206 cd 10 21			call macro_dsp_valuehl 
5209				endm 
# End of macro FORTH_DSP_VALUEHL
5209			 
5209 e5					push hl 
520a			 
520a					; destroy value TOS 
520a			 
520a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
520a cd c8 21			call macro_forth_dsp_pop 
520d				endm 
# End of macro FORTH_DSP_POP
520d			 
520d					; one value on hl get other one back 
520d			 
520d c1					pop bc 
520e			 
520e					; do the sub 
520e			;		ex de, hl 
520e			 
520e ed 68				in l,(c) 
5210			 
5210					; save it 
5210			 
5210 26 00				ld h,0 
5212			 
5212					; TODO push value back onto stack for another op etc 
5212			 
5212 cd 19 1f				call forth_push_numhl 
5215					NEXTW 
5215 c3 87 22			jp macro_next 
5218				endm 
# End of macro NEXTW
5218			.SOUT: 
5218				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5218 34				db WORD_SYS_CORE+32             
5219 6b 52			dw .SPIO            
521b 04				db 3 + 1 
521c .. 00			db "OUT",0              
5220				endm 
# End of macro CWHEAD
5220			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5220					if DEBUG_FORTH_WORDS_KEY 
5220						DMARK "OUT" 
5220 f5				push af  
5221 3a 35 52			ld a, (.dmark)  
5224 32 6e fe			ld (debug_mark),a  
5227 3a 36 52			ld a, (.dmark+1)  
522a 32 6f fe			ld (debug_mark+1),a  
522d 3a 37 52			ld a, (.dmark+2)  
5230 32 70 fe			ld (debug_mark+2),a  
5233 18 03			jr .pastdmark  
5235 ..			.dmark: db "OUT"  
5238 f1			.pastdmark: pop af  
5239			endm  
# End of macro DMARK
5239						CALLMONITOR 
5239 cd a5 18			call break_point_state  
523c				endm  
# End of macro CALLMONITOR
523c					endif 
523c			 
523c					; get port 
523c			 
523c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
523c cd 10 21			call macro_dsp_valuehl 
523f				endm 
# End of macro FORTH_DSP_VALUEHL
523f			 
523f e5					push hl 
5240			 
5240					; destroy value TOS 
5240			 
5240					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5240 cd c8 21			call macro_forth_dsp_pop 
5243				endm 
# End of macro FORTH_DSP_POP
5243			 
5243					; get byte to send 
5243			 
5243					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5243 cd 10 21			call macro_dsp_valuehl 
5246				endm 
# End of macro FORTH_DSP_VALUEHL
5246			 
5246			;		push hl 
5246			 
5246					; destroy value TOS 
5246			 
5246					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5246 cd c8 21			call macro_forth_dsp_pop 
5249				endm 
# End of macro FORTH_DSP_POP
5249			 
5249					; one value on hl get other one back 
5249			 
5249			;		pop hl 
5249			 
5249 c1					pop bc 
524a			 
524a					if DEBUG_FORTH_WORDS 
524a						DMARK "OUT" 
524a f5				push af  
524b 3a 5f 52			ld a, (.dmark)  
524e 32 6e fe			ld (debug_mark),a  
5251 3a 60 52			ld a, (.dmark+1)  
5254 32 6f fe			ld (debug_mark+1),a  
5257 3a 61 52			ld a, (.dmark+2)  
525a 32 70 fe			ld (debug_mark+2),a  
525d 18 03			jr .pastdmark  
525f ..			.dmark: db "OUT"  
5262 f1			.pastdmark: pop af  
5263			endm  
# End of macro DMARK
5263						CALLMONITOR 
5263 cd a5 18			call break_point_state  
5266				endm  
# End of macro CALLMONITOR
5266					endif 
5266			 
5266 ed 69				out (c), l 
5268			 
5268					NEXTW 
5268 c3 87 22			jp macro_next 
526b				endm 
# End of macro NEXTW
526b			 
526b			 
526b			.SPIO: 
526b			 
526b			if STORAGE_SE 
526b				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
526b 51				db WORD_SYS_CORE+61             
526c 7c 52			dw .SPICEH            
526e 07				db 6 + 1 
526f .. 00			db "SPICEL",0              
5276				endm 
# End of macro CWHEAD
5276			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5276			 
5276 cd 87 01				call spi_ce_low 
5279			    NEXTW 
5279 c3 87 22			jp macro_next 
527c				endm 
# End of macro NEXTW
527c			 
527c			.SPICEH: 
527c				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
527c 51				db WORD_SYS_CORE+61             
527d 8d 52			dw .SPIOb            
527f 07				db 6 + 1 
5280 .. 00			db "SPICEH",0              
5287				endm 
# End of macro CWHEAD
5287			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5287			 
5287 cd 76 01				call spi_ce_high 
528a			    NEXTW 
528a c3 87 22			jp macro_next 
528d				endm 
# End of macro NEXTW
528d			 
528d			 
528d			.SPIOb: 
528d			 
528d				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
528d 51				db WORD_SYS_CORE+61             
528e a3 52			dw .SPII            
5290 05				db 4 + 1 
5291 .. 00			db "SPIO",0              
5296				endm 
# End of macro CWHEAD
5296			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5296			 
5296					; get port 
5296			 
5296			 
5296					; get byte to send 
5296			 
5296					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5296 cd 10 21			call macro_dsp_valuehl 
5299				endm 
# End of macro FORTH_DSP_VALUEHL
5299			 
5299			;		push hl    ; u1  
5299			 
5299					; destroy value TOS 
5299			 
5299					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5299 cd c8 21			call macro_forth_dsp_pop 
529c				endm 
# End of macro FORTH_DSP_POP
529c			 
529c					; one value on hl get other one back 
529c			 
529c			;		pop hl   ; u2 - addr 
529c			 
529c					; TODO Send SPI byte 
529c			 
529c 7d					ld a, l 
529d cd ab 00				call spi_send_byte 
52a0			 
52a0					NEXTW 
52a0 c3 87 22			jp macro_next 
52a3				endm 
# End of macro NEXTW
52a3			 
52a3			.SPII: 
52a3				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
52a3 52				db WORD_SYS_CORE+62             
52a4 b8 52			dw .SESEL            
52a6 06				db 5 + 1 
52a7 .. 00			db "SPII",0              
52ac				endm 
# End of macro CWHEAD
52ac			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
52ac			 
52ac					; TODO Get SPI byte 
52ac			 
52ac cd cc 00				call spi_read_byte 
52af			 
52af 26 00				ld h, 0 
52b1 6f					ld l, a 
52b2 cd 19 1f				call forth_push_numhl 
52b5			 
52b5					NEXTW 
52b5 c3 87 22			jp macro_next 
52b8				endm 
# End of macro NEXTW
52b8			 
52b8			 
52b8			 
52b8			.SESEL: 
52b8				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
52b8 66				db WORD_SYS_CORE+82             
52b9 5c 53			dw .CARTDEV            
52bb 05				db 4 + 1 
52bc .. 00			db "BANK",0              
52c1				endm 
# End of macro CWHEAD
52c1			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
52c1					if DEBUG_FORTH_WORDS_KEY 
52c1						DMARK "BNK" 
52c1 f5				push af  
52c2 3a d6 52			ld a, (.dmark)  
52c5 32 6e fe			ld (debug_mark),a  
52c8 3a d7 52			ld a, (.dmark+1)  
52cb 32 6f fe			ld (debug_mark+1),a  
52ce 3a d8 52			ld a, (.dmark+2)  
52d1 32 70 fe			ld (debug_mark+2),a  
52d4 18 03			jr .pastdmark  
52d6 ..			.dmark: db "BNK"  
52d9 f1			.pastdmark: pop af  
52da			endm  
# End of macro DMARK
52da						CALLMONITOR 
52da cd a5 18			call break_point_state  
52dd				endm  
# End of macro CALLMONITOR
52dd					endif 
52dd			 
52dd 3e ff				ld a, 255 
52df 32 6d fa				ld (spi_cartdev), a 
52e2			 
52e2					; get bank 
52e2			 
52e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52e2 cd 10 21			call macro_dsp_valuehl 
52e5				endm 
# End of macro FORTH_DSP_VALUEHL
52e5			 
52e5			;		push hl 
52e5			 
52e5					; destroy value TOS 
52e5			 
52e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52e5 cd c8 21			call macro_forth_dsp_pop 
52e8				endm 
# End of macro FORTH_DSP_POP
52e8			 
52e8					; one value on hl get other one back 
52e8			 
52e8			;		pop hl 
52e8			 
52e8			 
52e8 0e ff				ld c, SPI_CE_HIGH 
52ea 06 30				ld b, '0'    ; human readable bank number 
52ec			 
52ec 7d					ld a, l 
52ed			 
52ed					if DEBUG_FORTH_WORDS 
52ed						DMARK "BNK" 
52ed f5				push af  
52ee 3a 02 53			ld a, (.dmark)  
52f1 32 6e fe			ld (debug_mark),a  
52f4 3a 03 53			ld a, (.dmark+1)  
52f7 32 6f fe			ld (debug_mark+1),a  
52fa 3a 04 53			ld a, (.dmark+2)  
52fd 32 70 fe			ld (debug_mark+2),a  
5300 18 03			jr .pastdmark  
5302 ..			.dmark: db "BNK"  
5305 f1			.pastdmark: pop af  
5306			endm  
# End of macro DMARK
5306						CALLMONITOR 
5306 cd a5 18			call break_point_state  
5309				endm  
# End of macro CALLMONITOR
5309					endif 
5309			 
5309					; active low 
5309			 
5309 fe 00				cp 0 
530b 28 28				jr z, .bset 
530d fe 01				cp 1 
530f 20 04				jr nz, .b2 
5311 cb 81				res 0, c 
5313 06 31				ld b, '1'    ; human readable bank number 
5315 fe 02		.b2:		cp 2 
5317 20 04				jr nz, .b3 
5319 cb 89				res 1, c 
531b 06 32				ld b, '2'    ; human readable bank number 
531d fe 03		.b3:		cp 3 
531f 20 04				jr nz, .b4 
5321 cb 91				res 2, c 
5323 06 33				ld b, '3'    ; human readable bank number 
5325 fe 04		.b4:		cp 4 
5327 20 04				jr nz, .b5 
5329 cb 99				res 3, c 
532b 06 34				ld b, '4'    ; human readable bank number 
532d fe 05		.b5:		cp 5 
532f 20 04				jr nz, .bset 
5331 cb a1				res 4, c 
5333 06 35				ld b, '5'    ; human readable bank number 
5335			 
5335			.bset: 
5335 79					ld a, c 
5336 32 6a fa				ld (spi_device),a 
5339 78					ld a, b 
533a 32 69 fa				ld (spi_device_id),a 
533d					if DEBUG_FORTH_WORDS 
533d						DMARK "BN2" 
533d f5				push af  
533e 3a 52 53			ld a, (.dmark)  
5341 32 6e fe			ld (debug_mark),a  
5344 3a 53 53			ld a, (.dmark+1)  
5347 32 6f fe			ld (debug_mark+1),a  
534a 3a 54 53			ld a, (.dmark+2)  
534d 32 70 fe			ld (debug_mark+2),a  
5350 18 03			jr .pastdmark  
5352 ..			.dmark: db "BN2"  
5355 f1			.pastdmark: pop af  
5356			endm  
# End of macro DMARK
5356						CALLMONITOR 
5356 cd a5 18			call break_point_state  
5359				endm  
# End of macro CALLMONITOR
5359					endif 
5359			 
5359					NEXTW 
5359 c3 87 22			jp macro_next 
535c				endm 
# End of macro NEXTW
535c			 
535c			.CARTDEV: 
535c				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
535c 66				db WORD_SYS_CORE+82             
535d 05 54			dw .ENDDEVICE            
535f 08				db 7 + 1 
5360 .. 00			db "CARTDEV",0              
5368				endm 
# End of macro CWHEAD
5368			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5368					if DEBUG_FORTH_WORDS_KEY 
5368						DMARK "CDV" 
5368 f5				push af  
5369 3a 7d 53			ld a, (.dmark)  
536c 32 6e fe			ld (debug_mark),a  
536f 3a 7e 53			ld a, (.dmark+1)  
5372 32 6f fe			ld (debug_mark+1),a  
5375 3a 7f 53			ld a, (.dmark+2)  
5378 32 70 fe			ld (debug_mark+2),a  
537b 18 03			jr .pastdmark  
537d ..			.dmark: db "CDV"  
5380 f1			.pastdmark: pop af  
5381			endm  
# End of macro DMARK
5381						CALLMONITOR 
5381 cd a5 18			call break_point_state  
5384				endm  
# End of macro CALLMONITOR
5384					endif 
5384			 
5384					; disable se storage bank selection 
5384			 
5384 3e ff				ld a, SPI_CE_HIGH		; ce high 
5386 32 6a fa				ld (spi_device), a 
5389			 
5389					; get bank 
5389			 
5389					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5389 cd 10 21			call macro_dsp_valuehl 
538c				endm 
# End of macro FORTH_DSP_VALUEHL
538c			 
538c			;		push hl 
538c			 
538c					; destroy value TOS 
538c			 
538c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
538c cd c8 21			call macro_forth_dsp_pop 
538f				endm 
# End of macro FORTH_DSP_POP
538f			 
538f					; one value on hl get other one back 
538f			 
538f			;		pop hl 
538f			 
538f					; active low 
538f			 
538f 0e ff				ld c, 255 
5391			 
5391 7d					ld a, l 
5392					if DEBUG_FORTH_WORDS 
5392						DMARK "CDV" 
5392 f5				push af  
5393 3a a7 53			ld a, (.dmark)  
5396 32 6e fe			ld (debug_mark),a  
5399 3a a8 53			ld a, (.dmark+1)  
539c 32 6f fe			ld (debug_mark+1),a  
539f 3a a9 53			ld a, (.dmark+2)  
53a2 32 70 fe			ld (debug_mark+2),a  
53a5 18 03			jr .pastdmark  
53a7 ..			.dmark: db "CDV"  
53aa f1			.pastdmark: pop af  
53ab			endm  
# End of macro DMARK
53ab						CALLMONITOR 
53ab cd a5 18			call break_point_state  
53ae				endm  
# End of macro CALLMONITOR
53ae					endif 
53ae fe 00				cp 0 
53b0 28 30				jr z, .cset 
53b2 fe 01				cp 1 
53b4 20 02				jr nz, .c2 
53b6 cb 81				res 0, c 
53b8 fe 02		.c2:		cp 2 
53ba 20 02				jr nz, .c3 
53bc cb 89				res 1, c 
53be fe 03		.c3:		cp 3 
53c0 20 02				jr nz, .c4 
53c2 cb 91				res 2, c 
53c4 fe 04		.c4:		cp 4 
53c6 20 02				jr nz, .c5 
53c8 cb 99				res 3, c 
53ca fe 05		.c5:		cp 5 
53cc 20 02				jr nz, .c6 
53ce cb a1				res 4, c 
53d0 fe 06		.c6:		cp 6 
53d2 20 02				jr nz, .c7 
53d4 cb a9				res 5, c 
53d6 fe 07		.c7:		cp 7 
53d8 20 02				jr nz, .c8 
53da cb b1				res 6, c 
53dc fe 08		.c8:		cp 8 
53de 20 02				jr nz, .cset 
53e0 cb b9				res 7, c 
53e2 79			.cset:		ld a, c 
53e3 32 6d fa				ld (spi_cartdev),a 
53e6			 
53e6					if DEBUG_FORTH_WORDS 
53e6						DMARK "CD2" 
53e6 f5				push af  
53e7 3a fb 53			ld a, (.dmark)  
53ea 32 6e fe			ld (debug_mark),a  
53ed 3a fc 53			ld a, (.dmark+1)  
53f0 32 6f fe			ld (debug_mark+1),a  
53f3 3a fd 53			ld a, (.dmark+2)  
53f6 32 70 fe			ld (debug_mark+2),a  
53f9 18 03			jr .pastdmark  
53fb ..			.dmark: db "CD2"  
53fe f1			.pastdmark: pop af  
53ff			endm  
# End of macro DMARK
53ff						CALLMONITOR 
53ff cd a5 18			call break_point_state  
5402				endm  
# End of macro CALLMONITOR
5402					endif 
5402					NEXTW 
5402 c3 87 22			jp macro_next 
5405				endm 
# End of macro NEXTW
5405			endif 
5405			 
5405			.ENDDEVICE: 
5405			; eof 
5405			 
# End of file forth_words_device.asm
5405			 
5405			; var handler 
5405			 
5405			 
5405			.VARS: 
5405				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5405 78				db WORD_SYS_CORE+100             
5406 1d 54			dw .V0Q            
5408 04				db 3 + 1 
5409 .. 00			db "V0!",0              
540d				endm 
# End of macro CWHEAD
540d			;| V0! ( u1 -- )  Store value to v0  | DONE 
540d			 
540d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
540d cd 10 21			call macro_dsp_valuehl 
5410				endm 
# End of macro FORTH_DSP_VALUEHL
5410			 
5410 11 32 fa				ld de, cli_var_array 
5413			 
5413 eb					ex de, hl 
5414 73					ld (hl), e 
5415 23					inc hl 
5416 72					ld (hl), d 
5417			 
5417					; destroy value TOS 
5417			 
5417					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5417 cd c8 21			call macro_forth_dsp_pop 
541a				endm 
# End of macro FORTH_DSP_POP
541a			 
541a				       NEXTW 
541a c3 87 22			jp macro_next 
541d				endm 
# End of macro NEXTW
541d			.V0Q: 
541d				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
541d 79				db WORD_SYS_CORE+101             
541e 2e 54			dw .V1S            
5420 04				db 3 + 1 
5421 .. 00			db "V0@",0              
5425				endm 
# End of macro CWHEAD
5425			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5425 2a 32 fa				ld hl, (cli_var_array) 
5428 cd 19 1f				call forth_push_numhl 
542b			 
542b				       NEXTW 
542b c3 87 22			jp macro_next 
542e				endm 
# End of macro NEXTW
542e			.V1S: 
542e				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
542e 7a				db WORD_SYS_CORE+102             
542f 46 54			dw .V1Q            
5431 04				db 3 + 1 
5432 .. 00			db "V1!",0              
5436				endm 
# End of macro CWHEAD
5436			;| V1! ( u1 -- )  Store value to v1 | DONE 
5436					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5436 cd 10 21			call macro_dsp_valuehl 
5439				endm 
# End of macro FORTH_DSP_VALUEHL
5439			 
5439 11 34 fa				ld de, cli_var_array+2 
543c				 
543c eb					ex de, hl 
543d 73					ld (hl), e 
543e 23					inc hl 
543f 72					ld (hl), d 
5440			 
5440					; destroy value TOS 
5440			 
5440					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5440 cd c8 21			call macro_forth_dsp_pop 
5443				endm 
# End of macro FORTH_DSP_POP
5443				       NEXTW 
5443 c3 87 22			jp macro_next 
5446				endm 
# End of macro NEXTW
5446			.V1Q: 
5446				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5446 7b				db WORD_SYS_CORE+103             
5447 57 54			dw .V2S            
5449 04				db 3 + 1 
544a .. 00			db "V1@",0              
544e				endm 
# End of macro CWHEAD
544e			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
544e 2a 34 fa				ld hl, (cli_var_array+2) 
5451 cd 19 1f				call forth_push_numhl 
5454				       NEXTW 
5454 c3 87 22			jp macro_next 
5457				endm 
# End of macro NEXTW
5457			.V2S: 
5457				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5457 7c				db WORD_SYS_CORE+104             
5458 6f 54			dw .V2Q            
545a 04				db 3 + 1 
545b .. 00			db "V2!",0              
545f				endm 
# End of macro CWHEAD
545f			;| V2! ( u1 -- )  Store value to v2 | DONE 
545f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
545f cd 10 21			call macro_dsp_valuehl 
5462				endm 
# End of macro FORTH_DSP_VALUEHL
5462			 
5462 11 36 fa				ld de, cli_var_array+4 
5465				 
5465 eb					ex de, hl 
5466 73					ld (hl), e 
5467 23					inc hl 
5468 72					ld (hl), d 
5469			 
5469					; destroy value TOS 
5469			 
5469					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5469 cd c8 21			call macro_forth_dsp_pop 
546c				endm 
# End of macro FORTH_DSP_POP
546c				       NEXTW 
546c c3 87 22			jp macro_next 
546f				endm 
# End of macro NEXTW
546f			.V2Q: 
546f				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
546f 7d				db WORD_SYS_CORE+105             
5470 80 54			dw .V3S            
5472 04				db 3 + 1 
5473 .. 00			db "V2@",0              
5477				endm 
# End of macro CWHEAD
5477			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5477 2a 36 fa				ld hl, (cli_var_array+4) 
547a cd 19 1f				call forth_push_numhl 
547d				       NEXTW 
547d c3 87 22			jp macro_next 
5480				endm 
# End of macro NEXTW
5480			.V3S: 
5480				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5480 7c				db WORD_SYS_CORE+104             
5481 98 54			dw .V3Q            
5483 04				db 3 + 1 
5484 .. 00			db "V3!",0              
5488				endm 
# End of macro CWHEAD
5488			;| V3! ( u1 -- )  Store value to v3 | DONE 
5488					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5488 cd 10 21			call macro_dsp_valuehl 
548b				endm 
# End of macro FORTH_DSP_VALUEHL
548b			 
548b 11 38 fa				ld de, cli_var_array+6 
548e				 
548e eb					ex de, hl 
548f 73					ld (hl), e 
5490 23					inc hl 
5491 72					ld (hl), d 
5492			 
5492					; destroy value TOS 
5492			 
5492					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5492 cd c8 21			call macro_forth_dsp_pop 
5495				endm 
# End of macro FORTH_DSP_POP
5495				       NEXTW 
5495 c3 87 22			jp macro_next 
5498				endm 
# End of macro NEXTW
5498			.V3Q: 
5498				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5498 7d				db WORD_SYS_CORE+105             
5499 a9 54			dw .END            
549b 04				db 3 + 1 
549c .. 00			db "V3@",0              
54a0				endm 
# End of macro CWHEAD
54a0			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
54a0 2a 38 fa				ld hl, (cli_var_array+6) 
54a3 cd 19 1f				call forth_push_numhl 
54a6				       NEXTW 
54a6 c3 87 22			jp macro_next 
54a9				endm 
# End of macro NEXTW
54a9			 
54a9			 
54a9			 
54a9			 
54a9			 
54a9			; end of dict marker 
54a9			 
54a9 00			.END:    db WORD_SYS_END 
54aa 00 00			dw 0 
54ac 00				db 0 
54ad			 
54ad			; use to jp here for user dict words to save on macro expansion  
54ad			 
54ad			user_dict_next: 
54ad				NEXTW 
54ad c3 87 22			jp macro_next 
54b0				endm 
# End of macro NEXTW
54b0			 
54b0			 
54b0			user_exec: 
54b0				;    ld hl, <word code> 
54b0				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
54b0				;    call forthexec 
54b0				;    jp user_dict_next   (NEXT) 
54b0			        ;    <word code bytes> 
54b0 eb				ex de, hl 
54b1 2a 00 f5			ld hl,(os_tok_ptr) 
54b4				 
54b4				FORTH_RSP_NEXT 
54b4 cd c0 1e			call macro_forth_rsp_next 
54b7				endm 
# End of macro FORTH_RSP_NEXT
54b7			 
54b7			if DEBUG_FORTH_UWORD 
54b7						DMARK "UEX" 
54b7 f5				push af  
54b8 3a cc 54			ld a, (.dmark)  
54bb 32 6e fe			ld (debug_mark),a  
54be 3a cd 54			ld a, (.dmark+1)  
54c1 32 6f fe			ld (debug_mark+1),a  
54c4 3a ce 54			ld a, (.dmark+2)  
54c7 32 70 fe			ld (debug_mark+2),a  
54ca 18 03			jr .pastdmark  
54cc ..			.dmark: db "UEX"  
54cf f1			.pastdmark: pop af  
54d0			endm  
# End of macro DMARK
54d0				CALLMONITOR 
54d0 cd a5 18			call break_point_state  
54d3				endm  
# End of macro CALLMONITOR
54d3			endif 
54d3			 
54d3			 
54d3			 
54d3 eb				ex de, hl 
54d4 22 00 f5			ld (os_tok_ptr), hl 
54d7				 
54d7				; Don't use next - Skips the first word in uword. 
54d7			 
54d7 c3 18 23			jp exec1 
54da			;	NEXT 
54da			 
54da			 
54da			; eof 
# End of file forth_wordsv4.asm
54da			endif 
54da			;;;;;;;;;;;;;; Debug code 
54da			 
54da			 
54da			;if DEBUG_FORTH_PARSE 
54da .. 00		.nowordfound: db "No match",0 
54e3 .. 00		.compword:	db "Comparing word ",0 
54f3 .. 00		.nextwordat:	db "Next word at",0 
5500 .. 00		.charmatch:	db "Char match",0 
550b			;endif 
550b			if DEBUG_FORTH_JP 
550b			.foundword:	db "Word match. Exec..",0 
550b			endif 
550b			;if DEBUG_FORTH_PUSH 
550b .. 00		.enddict:	db "Dict end. Push.",0 
551b .. 00		.push_str:	db "Pushing string",0 
552a .. 00		.push_num:	db "Pushing number",0 
5539 .. 00		.data_sp:	db "SP:",0 
553d .. 00		.wordinhl:	db "Word in HL (2/0):",0 
554f .. 00		.wordinde:	db "Word in DE (3/0):",0 
5561 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5573			;endif 
5573			;if DEBUG_FORTH_MALLOC 
5573 .. 00		.push_malloc:	db "Malloc address",0 
5582			;endif 
5582			 
5582			 
5582			 
5582			; display malloc address and current data stack pointer  
5582			 
5582			malloc_error: 
5582 d5				push de 
5583 f5				push af 
5584 e5				push hl 
5585 cd ca 0c			call clear_display 
5588 11 aa 55			ld de, .mallocerr 
558b 3e 00			ld a,0 
558d			;	ld de,os_word_scratch 
558d cd dd 0c			call str_at_display 
5590 3e 11			ld a, display_row_1+17 
5592 11 6e fe			ld de, debug_mark 
5595 cd dd 0c			call str_at_display 
5598 cd ed 0c			call update_display 
559b				;call break_point_state 
559b cd 1c 6d			call cin_wait 
559e			 
559e 3e 20			ld a, ' ' 
55a0 32 f0 f1			ld (os_view_disable), a 
55a3 e1				pop hl 
55a4 f1				pop af 
55a5 d1				pop de	 
55a6				CALLMONITOR 
55a6 cd a5 18			call break_point_state  
55a9				endm  
# End of macro CALLMONITOR
55a9 c9				ret 
55aa			 
55aa .. 00		.mallocerr: 	db "Malloc Error",0 
55b7			;if DEBUG_FORTH_PUSH 
55b7			display_data_sp: 
55b7 f5				push af 
55b8			 
55b8				; see if disabled 
55b8			 
55b8 3a f0 f1			ld a, (os_view_disable) 
55bb fe 2a			cp '*' 
55bd 28 67			jr z, .skipdsp 
55bf			 
55bf e5				push hl 
55c0 e5				push hl 
55c1 e5			push hl 
55c2 cd ca 0c			call clear_display 
55c5 e1			pop hl 
55c6 7c				ld a,h 
55c7 21 04 f5			ld hl, os_word_scratch 
55ca cd ff 11			call hexout 
55cd e1				pop hl 
55ce 7d				ld a,l 
55cf 21 06 f5			ld hl, os_word_scratch+2 
55d2 cd ff 11			call hexout 
55d5 21 08 f5			ld hl, os_word_scratch+4 
55d8 3e 00			ld a,0 
55da 77				ld (hl),a 
55db 11 04 f5			ld de,os_word_scratch 
55de 3e 28				ld a, display_row_2 
55e0 cd dd 0c				call str_at_display 
55e3 11 3d 55			ld de, .wordinhl 
55e6 3e 00			ld a, display_row_1 
55e8			 
55e8 cd dd 0c				call str_at_display 
55eb 11 6e fe			ld de, debug_mark 
55ee 3e 11			ld a, display_row_1+17 
55f0			 
55f0 cd dd 0c				call str_at_display 
55f3			 
55f3				; display current data stack pointer 
55f3 11 39 55			ld de,.data_sp 
55f6 3e 30				ld a, display_row_2 + 8 
55f8 cd dd 0c				call str_at_display 
55fb			 
55fb 2a 2c fa			ld hl,(cli_data_sp) 
55fe e5				push hl 
55ff 7c				ld a,h 
5600 21 04 f5			ld hl, os_word_scratch 
5603 cd ff 11			call hexout 
5606 e1				pop hl 
5607 7d				ld a,l 
5608 21 06 f5			ld hl, os_word_scratch+2 
560b cd ff 11			call hexout 
560e 21 08 f5			ld hl, os_word_scratch+4 
5611 3e 00			ld a,0 
5613 77				ld (hl),a 
5614 11 04 f5			ld de,os_word_scratch 
5617 3e 33				ld a, display_row_2 + 11 
5619 cd dd 0c				call str_at_display 
561c			 
561c			 
561c cd ed 0c			call update_display 
561f cd 47 0c			call delay1s 
5622 cd 47 0c			call delay1s 
5625 e1				pop hl 
5626			.skipdsp: 
5626 f1				pop af 
5627 c9				ret 
5628			 
5628			display_data_malloc: 
5628			 
5628 f5				push af 
5629 e5				push hl 
562a e5				push hl 
562b e5			push hl 
562c cd ca 0c			call clear_display 
562f e1			pop hl 
5630 7c				ld a,h 
5631 21 04 f5			ld hl, os_word_scratch 
5634 cd ff 11			call hexout 
5637 e1				pop hl 
5638 7d				ld a,l 
5639 21 06 f5			ld hl, os_word_scratch+2 
563c cd ff 11			call hexout 
563f 21 08 f5			ld hl, os_word_scratch+4 
5642 3e 00			ld a,0 
5644 77				ld (hl),a 
5645 11 04 f5			ld de,os_word_scratch 
5648 3e 28				ld a, display_row_2 
564a cd dd 0c				call str_at_display 
564d 11 73 55			ld de, .push_malloc 
5650 3e 00			ld a, display_row_1 
5652			 
5652 cd dd 0c				call str_at_display 
5655			 
5655				; display current data stack pointer 
5655 11 39 55			ld de,.data_sp 
5658 3e 30				ld a, display_row_2 + 8 
565a cd dd 0c				call str_at_display 
565d			 
565d 2a 2c fa			ld hl,(cli_data_sp) 
5660 e5				push hl 
5661 7c				ld a,h 
5662 21 04 f5			ld hl, os_word_scratch 
5665 cd ff 11			call hexout 
5668 e1				pop hl 
5669 7d				ld a,l 
566a 21 06 f5			ld hl, os_word_scratch+2 
566d cd ff 11			call hexout 
5670 21 08 f5			ld hl, os_word_scratch+4 
5673 3e 00			ld a,0 
5675 77				ld (hl),a 
5676 11 04 f5			ld de,os_word_scratch 
5679 3e 33				ld a, display_row_2 + 11 
567b cd dd 0c				call str_at_display 
567e			 
567e cd ed 0c			call update_display 
5681 cd 47 0c			call delay1s 
5684 cd 47 0c			call delay1s 
5687 e1				pop hl 
5688 f1				pop af 
5689 c9				ret 
568a			;endif 
568a			 
568a			include "forth_autostart.asm" 
568a			; list of commands to perform at system start up 
568a			 
568a			startcmds: 
568a			;	dw test11 
568a			;	dw test12 
568a			;	dw test13 
568a			;	dw test14 
568a			;	dw test15 
568a			;	dw test16 
568a			;	dw test17 
568a			;	dw ifthtest1 
568a			;	dw ifthtest2 
568a			;	dw ifthtest3 
568a			;	dw mmtest1 
568a			;	dw mmtest2 
568a			;	dw mmtest3 
568a			;	dw mmtest4 
568a			;	dw mmtest5 
568a			;	dw mmtest6 
568a			;	dw iftest1 
568a			;	dw iftest2 
568a			;	dw iftest3 
568a			;	dw looptest1 
568a			;	dw looptest2 
568a			;	dw test1 
568a			;	dw test2 
568a			;	dw test3 
568a			;	dw test4 
568a			;	dw game2r 
568a			;	dw game2b1 
568a			;	dw game2b2 
568a			 
568a				; start up words that are actually useful 
568a			 
568a ea 56			dw longread 
568c 31 57			dw clrstack 
568e 64 57			dw type 
5690 54 59			dw stest 
5692 88 57			dw strncpy 
5694 ea 58			dw list 
5696 e9 57			dw start1 
5698 fb 57			dw start2 
569a			;	dw start3 
569a 0e 58			dw start3b 
569c 8a 58			dw start3c 
569e			 
569e				; (unit) testing words 
569e			 
569e cb 59			dw mtesta 
56a0 80 5a			dw mtestb 
56a2 23 5b			dw mtestc 
56a4 d8 5b			dw mtestd 
56a6 7c 5c			dw mteste 
56a8			 
56a8				; demo/game words 
56a8			 
56a8 88 63		        dw game3w 
56aa b6 63		        dw game3p 
56ac d4 63		        dw game3sc 
56ae 05 64		        dw game3vsi 
56b0 31 64		        dw game3vs 
56b2				 
56b2 7b 61			dw game2b 
56b4 e9 61			dw game2bf 
56b6 33 62			dw game2mba 
56b8 c9 62			dw game2mbas 
56ba 0b 63			dw game2mb 
56bc			 
56bc 3c 5e			dw game1 
56be 4d 5e			dw game1a 
56c0 af 5e			dw game1b 
56c2 e4 5e			dw game1c 
56c4 1a 5f			dw game1d 
56c6 4b 5f			dw game1s 
56c8 5f 5f			dw game1t 
56ca 74 5f			dw game1f 
56cc a8 5f			dw game1z 
56ce ec 5f			dw game1zz 
56d0			 
56d0 32 5d			dw test5 
56d2 6a 5d			dw test6 
56d4 a2 5d			dw test7 
56d6 b6 5d			dw test8 
56d8 e2 5d			dw test9 
56da f8 5d			dw test10 
56dc				 
56dc c3 60		        dw ssv5 
56de a7 60		        dw ssv4 
56e0 8b 60		        dw ssv3 
56e2 55 60		        dw ssv2 
56e4 dc 60		        dw ssv1 
56e6 24 61		        dw ssv1cpm 
56e8			;	dw keyup 
56e8			;	dw keydown 
56e8			;	dw keyleft 
56e8			;	dw keyright 
56e8			;	dw 	keyf1 
56e8			;	dw keyf2 
56e8			;	dw keyf3 
56e8			;	dw keyf4 
56e8			;	dw keyf5 
56e8			;	dw keyf6 
56e8			;	dw keyf7 
56e8			;	dw keyf8 
56e8			;	dw keyf9 
56e8			;	dw keyf10 
56e8			;	dw keyf11 
56e8			;	dw keyf12 
56e8			;	dw keytab 
56e8			;	dw keycr 
56e8			;	dw keyhome 
56e8			;	dw keyend 
56e8			;	dw keybs 
56e8 00 00			db 0, 0	 
56ea			 
56ea			 
56ea			; Long read of currently open file 
56ea .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5731			 
5731			; clear stack  
5731			 
5731 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5764			 
5764			; type ( addr count - ) 
5764 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5788			 
5788			; some direct memory words 
5788			; strncpy ( len t f -- t ) 
5788			 
5788 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
57e9			 
57e9 .. 00		start1:     	db ": bpon $0000 bp ;",0 
57fb .. 00		start2:     	db ": bpoff $0001 bp ;",0 
580e .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
588a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
58ea			 
58ea			 
58ea			; a handy word to list items on the stack 
58ea			 
58ea .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5954			 
5954			 
5954			; test stack  
5954			; rnd8 stest 
5954			 
5954 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
59cb			 
59cb			; random malloc and free cycles 
59cb			 
59cb .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5a80			 
5a80			; fixed malloc and free cycles 
5a80			 
5a80 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5b23			 
5b23			; fixed double string push and drop cycle  
5b23			 
5b23 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5bd8			 
5bd8			; consistent fixed string push and drop cycle  
5bd8			 
5bd8 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5c7c			 
5c7c .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5d32			 
5d32			;test1:		db ": aa 1 2 3 ;", 0 
5d32			;test2:     	db "111 aa 888 999",0 
5d32			;test3:     	db ": bb 77 ;",0 
5d32			;test4:     	db "$02 $01 do i . loop bb",0 
5d32			 
5d32 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5d6a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5da2 .. 00		test7:     	db ": box hline vline ;",0 
5db6 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5de2 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5df8 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5e1d .. 00		test11:     	db "hello create .",0 
5e2c .. 00		test12:     	db "hello2 create .",0 
5e3c			 
5e3c			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5e3c			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5e3c			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5e3c			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5e3c			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5e3c			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5e3c			 
5e3c			;iftest1:     	db "$0001 IF cls .",0 
5e3c			;iftest2:     	db "$0000 IF cls .",0 
5e3c			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5e3c			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5e3c			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5e3c			 
5e3c			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e3c			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e3c			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e3c			 
5e3c			 
5e3c			 
5e3c			; a small guess the number game 
5e3c			 
5e3c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5e4d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5eaf			 
5eaf .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ee4 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5f1a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5f4b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5f5f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5f74 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5fa8 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5fec			 
5fec			; Using 'ga' save a high score across multiple runs using external storage 
5fec			 
5fec .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6055			 
6055			 
6055			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6055			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6055			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6055			 
6055			; simple screen saver to test code memory reuse to destruction 
6055			 
6055 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
608b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
60a7 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
60c3 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
60dc .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6124 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
617b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
617b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
617b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
617b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
617b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
617b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
617b			 
617b			 
617b			 
617b			; minesweeper/battleship finding game 
617b			; draws a game board of random ship/mine positions 
617b			; user enters coords to see if it hits on 
617b			; game ends when all are hit 
617b			; when hit or miss says how many may be in the area 
617b			 
617b			; setup the game board and then hide it 
617b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
61e9 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6233			; prompt for where to target 
6233 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
62c9 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
62ee			; TODO see if the entered coords hits or misses pushes char hit of miss 
62ee .. 00		game2mbht:      db ": mbckht nop ;",0 
62fd .. 00		game2mbms:      db ": mbcms nop ;",0 
630b			; TODO how many might be near by 
630b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6388			 
6388			; Game 3 
6388			 
6388			; Vert scroller ski game - avoid the trees! 
6388			 
6388			; v0 score (ie turns) 
6388			; v1 player pos 
6388			; v2 left wall 
6388			; v3 right wall 
6388			 
6388			; Draw side walls randomly 
6388			 
6388 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
63b6			 
63b6			; Draw player 
63b6 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
63d4			 
63d4			; TODO Get Key 
63d4			 
63d4			; TODO Move left right 
63d4			 
63d4			; scroll and move walls a bit 
63d4			 
63d4 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6405			 
6405			; main game loop 
6405			 
6405 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6431 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6470			 
6470			; key board defs 
6470			 
6470 .. 00		keyup:       db ": keyup $05 ;",0 
647e .. 00		keydown:       db ": keydown $0a ;",0 
648e .. 00		keyleft:       db ": keyleft $0b ;",0 
649e .. 00		keyright:       db ": keyright $0c ;",0 
64af .. 00		keyf1:       db ": keyf1 $10 ;",0 
64bd .. 00		keyf2:       db ": keyf2 $11 ;",0 
64cb .. 00		keyf3:       db ": keyf3 $12 ;",0 
64d9 .. 00		keyf4:       db ": keyf4 $13 ;",0 
64e7 .. 00		keyf5:       db ": keyf5 $14 ;",0 
64f5 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6503 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6511 .. 00		keyf8:       db ": keyf8 $17 ;",0 
651f .. 00		keyf9:       db ": keyf9 $18 ;",0 
652d .. 00		keyf10:       db ": keyf10 $19 ;",0 
653c .. 00		keyf11:       db ": keyf11 $1a ;",0 
654b .. 00		keyf12:       db ": keyf12 $1b ;",0 
655a			 
655a .. 00		keytab:       db ": keytab $09 ;",0 
6569 .. 00		keycr:       db ": keycr $0d ;",0 
6577 .. 00		keyhome:       db ": keyhome $0e ;",0 
6587 .. 00		keyend:       db ": keyend $0f ;",0 
6596 .. 00		keybs:       db ": keybs $08 ;",0 
65a4			 
65a4			   
65a4			 
65a4			 
65a4			 
65a4			; eof 
# End of file forth_autostart.asm
65a4			 
65a4 .. 00		sprompt1: db "Startup load...",0 
65b4 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
65ca			 
65ca			 
65ca			 
65ca			 
65ca			forth_startup: 
65ca 21 8a 56			ld hl, startcmds 
65cd 3e 00			ld a, 0 
65cf 32 25 f6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
65d2			 
65d2 e5			.start1:	push hl 
65d3 cd ca 0c			call clear_display 
65d6 11 a4 65			ld de, sprompt1 
65d9 3e 00		        ld a, display_row_1 
65db cd dd 0c			call str_at_display 
65de 11 b4 65			ld de, sprompt2 
65e1 3e 28		        ld a, display_row_2 
65e3 cd dd 0c			call str_at_display 
65e6 e1				pop hl 
65e7 e5				push hl 
65e8 5e				ld e,(hl) 
65e9 23				inc hl 
65ea 56				ld d,(hl) 
65eb 3e 50		        ld a, display_row_3 
65ed cd dd 0c			call str_at_display 
65f0 cd ed 0c			call update_display 
65f3			 
65f3			 
65f3 3a 25 f6			ld a, (os_last_cmd) 
65f6 fe 00			cp 0 
65f8 28 05			jr z, .startprompt 
65fa cd 3b 0c			call delay250ms 
65fd 18 24			jr .startdo 
65ff				 
65ff				 
65ff			 
65ff			.startprompt: 
65ff			 
65ff 3e 9f			ld a,display_row_4 + display_cols - 1 
6601 11 8f 1e		        ld de, endprg 
6604 cd dd 0c			call str_at_display 
6607 cd ed 0c			call update_display 
660a cd 47 0c			call delay1s 
660d cd 1c 6d			call cin_wait 
6610						 
6610 fe 2a			cp '*' 
6612 28 5e			jr z, .startupend1 
6614 fe 23			cp '#' 
6616 20 07			jr nz, .startno 
6618 3e 01			ld a, 1 
661a 32 25 f6			ld (os_last_cmd),a 
661d 18 04			jr .startdo 
661f fe 31		.startno:	cp '1' 
6621 28 3a			jr z,.startnxt  
6623			 
6623				; exec startup line 
6623			.startdo:	 
6623 e1				pop hl 
6624 e5				push hl 
6625				 
6625 5e				ld e,(hl) 
6626 23				inc hl 
6627 56				ld d,(hl) 
6628 eb				ex de,hl 
6629			 
6629 e5				push hl 
662a			 
662a 3e 00			ld a, 0 
662c				;ld a, FORTH_END_BUFFER 
662c cd 67 13			call strlent 
662f 23				inc hl   ; include zero term to copy 
6630 06 00			ld b,0 
6632 4d				ld c,l 
6633 e1				pop hl 
6634 11 ff f1			ld de, scratch 
6637 ed b0			ldir 
6639			 
6639			 
6639 21 ff f1			ld hl, scratch 
663c cd d5 22			call forthparse 
663f cd 15 23			call forthexec 
6642 cd 27 22			call forthexec_cleanup 
6645			 
6645 3e 78			ld a, display_row_4 
6647 11 33 1c			ld de, endprog 
664a			 
664a cd ed 0c			call update_display		 
664d			 
664d 3a 25 f6			ld a, (os_last_cmd) 
6650 fe 00			cp 0 
6652 20 09			jr nz, .startnxt 
6654 cd 91 1e			call next_page_prompt 
6657 cd ca 0c		        call clear_display 
665a cd ed 0c			call update_display		 
665d			 
665d				; move onto next startup line? 
665d			.startnxt: 
665d			 
665d cd 3b 0c			call delay250ms 
6660 e1				pop hl 
6661			 
6661 23				inc hl 
6662 23				inc hl 
6663			 
6663 e5				push hl 
6664 5e				ld e, (hl) 
6665 23				inc hl 
6666 56				ld d, (hl) 
6667 e1				pop hl 
6668				; TODO replace 0 test 
6668			 
6668 eb				ex de, hl 
6669 cd 27 0f			call ishlzero 
666c			;	ld a,e 
666c			;	add d 
666c			;	cp 0    ; any left to do? 
666c eb				ex de, hl 
666d c2 d2 65			jp nz, .start1 
6670 18 01			jr .startupend 
6672			 
6672 e1			.startupend1: pop hl 
6673			.startupend: 
6673			 
6673 cd ca 0c			call clear_display 
6676 cd ed 0c			call update_display 
6679 c9				ret 
667a			 
667a			 
667a			; stack over and underflow checks 
667a			 
667a			; init the words to detect the under/overflow 
667a			 
667a			chk_stk_init: 
667a				; a vague random number to check so we dont get any "lucky" hits 
667a 3e 2d			ld a, 45 
667c 6f				ld l, a 
667d 00				nop 
667e 3e 17			ld a, 23 
6680 67				ld h, a 
6681			 
6681 22 e6 f1			ld (chk_word), hl     ; the word we need to check against 
6684			 
6684			;	ld (chk_stund), hl	; stack points.... 
6684 22 fd fe			ld (chk_stovr), hl 
6687 22 2a fa			ld (chk_ret_und), hl 
668a 22 e8 f9			ld (chk_ret_ovr), hl 
668d 22 66 f9			ld (chk_loop_ovr), hl 
6690 22 64 f7			ld (chk_data_ovr), hl 
6693 c9				ret 
6694				 
6694			check_stacks: 
6694				; check all stack words 
6694			 
6694 e5				push hl 
6695 d5				push de 
6696			 
6696			;	ld de,(chk_word) 
6696			;	ld hl, (chk_stund)	; stack points.... 
6696			;	if DEBUG_STK_FAULT 
6696			;		DMARK "FAa" 
6696			;		CALLMONITOR 
6696			;	endif 
6696			;	call cmp16 
6696			;	jp z, .chk_faulta 
6696			; 
6696			;	ld de, sfaultsu 
6696			;	jp .chk_fault 
6696			 
6696 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6699 ed 5b e6 f1		ld de,(chk_word) 
669d				if DEBUG_STK_FAULT 
669d					DMARK "FAb" 
669d					CALLMONITOR 
669d				endif 
669d cd 1c 0f			call cmp16 
66a0 28 06			jr z, .chk_fault1 
66a2 11 43 67			ld de, sfaultso 
66a5 c3 f7 66			jp .chk_fault 
66a8			.chk_fault1:  
66a8 2a 2a fa			ld hl, (chk_ret_und) 
66ab ed 5b e6 f1		ld de,(chk_word) 
66af				if DEBUG_STK_FAULT 
66af					DMARK "FAU" 
66af					CALLMONITOR 
66af				endif 
66af cd 1c 0f			call cmp16 
66b2 ca bb 66			jp z, .chk_fault2 
66b5 11 53 67			ld de, sfaultru 
66b8 c3 f7 66			jp .chk_fault 
66bb			.chk_fault2:  
66bb 2a e8 f9			ld hl, (chk_ret_ovr) 
66be ed 5b e6 f1		ld de,(chk_word) 
66c2				if DEBUG_STK_FAULT 
66c2					DMARK "FA1" 
66c2					CALLMONITOR 
66c2				endif 
66c2 cd 1c 0f			call cmp16 
66c5 ca ce 66			jp z, .chk_fault3 
66c8 11 61 67			ld de, sfaultro 
66cb c3 f7 66			jp .chk_fault 
66ce			.chk_fault3:  
66ce 2a 66 f9			ld hl, (chk_loop_ovr) 
66d1 ed 5b e6 f1		ld de,(chk_word) 
66d5				if DEBUG_STK_FAULT 
66d5					DMARK "FA2" 
66d5					CALLMONITOR 
66d5				endif 
66d5 cd 1c 0f			call cmp16 
66d8 ca e1 66			jp z, .chk_fault4 
66db 11 7b 67			ld de, sfaultlo 
66de c3 f7 66			jp .chk_fault 
66e1			.chk_fault4:  
66e1 2a 64 f7			ld hl, (chk_data_ovr) 
66e4 ed 5b e6 f1		ld de,(chk_word) 
66e8				if DEBUG_STK_FAULT 
66e8					DMARK "FA3" 
66e8					CALLMONITOR 
66e8				endif 
66e8 cd 1c 0f			call cmp16 
66eb ca f4 66			jp z, .chk_fault5 
66ee 11 95 67			ld de, sfaultdo 
66f1 c3 f7 66			jp .chk_fault 
66f4			 
66f4			 
66f4			.chk_fault5:  
66f4 d1				pop de 
66f5 e1				pop hl 
66f6			 
66f6 c9				ret 
66f7			 
66f7 cd ca 0c		.chk_fault: 	call clear_display 
66fa 3e 28				ld a, display_row_2 
66fc cd dd 0c				call str_at_display 
66ff 11 25 67				   ld de, .stackfault 
6702 3e 00				ld a, display_row_1 
6704 cd dd 0c				call str_at_display 
6707 11 6e fe				    ld de, debug_mark 
670a 3e 11				ld a, display_row_1+17 
670c cd dd 0c				call str_at_display 
670f cd ed 0c				call update_display 
6712			 
6712				; prompt before entering montior for investigating issue 
6712			 
6712 3e 78			ld a, display_row_4 
6714 11 33 1c			ld de, endprog 
6717			 
6717 cd ed 0c			call update_display		 
671a			 
671a cd 91 1e			call next_page_prompt 
671d			 
671d d1				pop de 
671e e1				pop hl 
671f cd 87 1c				call monitor 
6722 c3 7e 1b				jp warmstart 
6725					;jp 0 
6725					;halt 
6725			 
6725			 
6725			 
6725 .. 00		.stackfault: 	db "Stack fault:",0 
6732			 
6732 .. 00		sfaultsu: 	db	"Stack under flow",0 
6743 .. 00		sfaultso: 	db	"Stack over flow",0 
6753 .. 00		sfaultru:	db "RTS underflow",0 
6761 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
677b .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6795 .. 00		sfaultdo:	db "DTS overflow", 0 
67a2			 
67a2			 
67a2			fault_dsp_under: 
67a2 11 b4 67			ld de, .dsp_under 
67a5 c3 64 68			jp .show_fault 
67a8			 
67a8			fault_rsp_under: 
67a8 11 c2 67			ld de, .rsp_under 
67ab c3 64 68			jp .show_fault 
67ae			fault_loop_under: 
67ae 11 d0 67			ld de, .loop_under 
67b1 c3 64 68			jp .show_fault 
67b4			 
67b4 .. 00		.dsp_under: db "DSP Underflow",0 
67c2 .. 00		.rsp_under: db "RSP Underflow",0 
67d0 .. 00		.loop_under: db "LOOP Underflow",0 
67df			 
67df			 
67df d5			type_faultn: 	push de 
67e0 e5					push hl 
67e1 cd ca 0c				call clear_display 
67e4 11 0b 68				   ld de, .typefaultn 
67e7 3e 00				ld a, display_row_1 
67e9 cd dd 0c				call str_at_display 
67ec 11 6e fe				    ld de, debug_mark 
67ef 3e 11				ld a, display_row_1+17 
67f1 cd dd 0c				call str_at_display 
67f4 cd ed 0c				call update_display 
67f7			 
67f7				; prompt before entering montior for investigating issue 
67f7			 
67f7 3e 78			ld a, display_row_4 
67f9 11 33 1c			ld de, endprog 
67fc			 
67fc cd ed 0c			call update_display		 
67ff			 
67ff cd 91 1e			call next_page_prompt 
6802			 
6802 e5					push hl 
6803 d5					push de 
6804 cd 87 1c				call monitor 
6807 c3 7e 1b				jp warmstart 
680a 76					halt 
680b			 
680b			 
680b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6822			 
6822 d5			type_faults: 	push de 
6823 e5					push hl 
6824 cd ca 0c				call clear_display 
6827 11 4d 68				   ld de, .typefaults 
682a 3e 00				ld a, display_row_1 
682c cd dd 0c				call str_at_display 
682f 11 6e fe				    ld de, debug_mark 
6832 3e 11				ld a, display_row_1+17 
6834 cd dd 0c				call str_at_display 
6837 cd ed 0c				call update_display 
683a			 
683a				; prompt before entering montior for investigating issue 
683a			 
683a 3e 78			ld a, display_row_4 
683c 11 33 1c			ld de, endprog 
683f			 
683f cd ed 0c			call update_display		 
6842			 
6842 cd 91 1e			call next_page_prompt 
6845			 
6845 e1					pop hl 
6846 d1					pop de 
6847 cd 87 1c				call monitor 
684a c3 7e 1b				jp warmstart 
684d			 
684d			 
684d .. 00		.typefaults: db "STR Type Expected TOS!",0 
6864			 
6864			.show_fault: 	 
6864 d5					push de 
6865 cd ca 0c				call clear_display 
6868 d1					pop de 
6869 3e 00				ld a, display_row_1 
686b cd dd 0c				call str_at_display 
686e 11 6e fe				    ld de, debug_mark 
6871 3e 11				ld a, display_row_1+17 
6873 cd dd 0c				call str_at_display 
6876 cd ed 0c				call update_display 
6879			 
6879				; prompt before entering montior for investigating issue 
6879			 
6879 3e 78			ld a, display_row_4 
687b 11 33 1c			ld de, endprog 
687e			 
687e cd ed 0c			call update_display		 
6881			 
6881 cd 91 1e			call next_page_prompt 
6884			 
6884 e1					pop hl 
6885 d1					pop de 
6886 cd 87 1c				call monitor 
6889			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6889			; TODO Make optional fault restart to cli or warm boot? 
6889					;jp warmstart 
6889 c3 d9 1b				jp cli 
688c 76					halt 
688d			 
688d			; handle the auto run of code from files in storage 
688d			 
688d			 
688d			if STORAGE_SE 
688d			 
688d .. 00		sprompt3: db "Loading from start-up file?:",0 
68aa .. 00		sprompt4: db "(Y=Any key/N=No)",0 
68bb			 
68bb			 
68bb			forth_autoload: 
68bb			 
68bb				; load block 0 of store 1 
68bb				 
68bb 3e fe			ld a, $fe      ; bit 0 clear 
68bd 32 6a fa			ld (spi_device), a 
68c0			 
68c0 cd 85 04			call storage_get_block_0 
68c3			 
68c3 3a a2 fa			ld a, (store_page+STORE_0_AUTOFILE) 
68c6			 
68c6 fe 00			cp 0 
68c8 c8				ret z     ; auto start not enabled 
68c9			 
68c9 cd ca 0c			call clear_display 
68cc			 
68cc				; set bank 
68cc			 
68cc 3a a4 fa				ld a, (store_page+STORE_0_BANKRUN) 
68cf 32 6a fa				ld (spi_device), a 
68d2			 
68d2				; get file id to load from and get the file name to display 
68d2			 
68d2 3a a5 fa				ld a, (store_page+STORE_0_FILERUN) 
68d5			 
68d5 2e 00				ld l, 0 
68d7 67					ld h, a 
68d8 11 81 fa				ld de, store_page 
68db			 
68db					if DEBUG_FORTH_WORDS 
68db						DMARK "ASp" 
68db f5				push af  
68dc 3a f0 68			ld a, (.dmark)  
68df 32 6e fe			ld (debug_mark),a  
68e2 3a f1 68			ld a, (.dmark+1)  
68e5 32 6f fe			ld (debug_mark+1),a  
68e8 3a f2 68			ld a, (.dmark+2)  
68eb 32 70 fe			ld (debug_mark+2),a  
68ee 18 03			jr .pastdmark  
68f0 ..			.dmark: db "ASp"  
68f3 f1			.pastdmark: pop af  
68f4			endm  
# End of macro DMARK
68f4						CALLMONITOR 
68f4 cd a5 18			call break_point_state  
68f7				endm  
# End of macro CALLMONITOR
68f7					endif 
68f7 cd 2d 09				call storage_read 
68fa			 
68fa					if DEBUG_FORTH_WORDS 
68fa						DMARK "ASr" 
68fa f5				push af  
68fb 3a 0f 69			ld a, (.dmark)  
68fe 32 6e fe			ld (debug_mark),a  
6901 3a 10 69			ld a, (.dmark+1)  
6904 32 6f fe			ld (debug_mark+1),a  
6907 3a 11 69			ld a, (.dmark+2)  
690a 32 70 fe			ld (debug_mark+2),a  
690d 18 03			jr .pastdmark  
690f ..			.dmark: db "ASr"  
6912 f1			.pastdmark: pop af  
6913			endm  
# End of macro DMARK
6913						CALLMONITOR 
6913 cd a5 18			call break_point_state  
6916				endm  
# End of macro CALLMONITOR
6916					endif 
6916			 
6916 cd 27 0f				call ishlzero 
6919 c8					ret z             ; file not found 
691a			 
691a 3e 32				ld a, display_row_2 + 10 
691c 11 84 fa				ld de, store_page+3 
691f cd dd 0c				call str_at_display 
6922				 
6922			; 
6922			 
6922 3e 05			ld a, display_row_1+5 
6924 11 8d 68			ld de, sprompt3 
6927 cd dd 0c			call str_at_display 
692a 3e 5f			ld a, display_row_3+15 
692c 11 aa 68			ld de, sprompt4 
692f cd dd 0c			call str_at_display 
6932			 
6932 cd ed 0c			call update_display 
6935			 
6935 cd 1c 6d			call cin_wait 
6938 fe 6e			cp 'n' 
693a c8				ret z 
693b fe 4e			cp 'N' 
693d c8				ret z 
693e			 
693e cd 47 0c			call delay1s 
6941			 
6941 3a 83 fa			ld a, (store_page+2) 
6944 32 72 fa			ld (store_openmaxext), a    ; save count of ext 
6947 3e 01			ld a, 1  
6949 32 73 fa			ld (store_openext), a    ; save count of ext 
694c			 
694c			.autof:  
694c 6f				ld l , a 
694d				 
694d 3a 81 fa			ld a, (store_page) 
6950 67				ld h, a	 
6951 11 81 fa			ld de, store_page 
6954					if DEBUG_FORTH_WORDS 
6954						DMARK "ASl" 
6954 f5				push af  
6955 3a 69 69			ld a, (.dmark)  
6958 32 6e fe			ld (debug_mark),a  
695b 3a 6a 69			ld a, (.dmark+1)  
695e 32 6f fe			ld (debug_mark+1),a  
6961 3a 6b 69			ld a, (.dmark+2)  
6964 32 70 fe			ld (debug_mark+2),a  
6967 18 03			jr .pastdmark  
6969 ..			.dmark: db "ASl"  
696c f1			.pastdmark: pop af  
696d			endm  
# End of macro DMARK
696d						CALLMONITOR 
696d cd a5 18			call break_point_state  
6970				endm  
# End of macro CALLMONITOR
6970					endif 
6970 cd 2d 09				call storage_read 
6973 cd 27 0f			call ishlzero 
6976 c8				ret z 
6977			;	jr z, .autoend 
6977			 
6977					if DEBUG_FORTH_WORDS 
6977						DMARK "ASc" 
6977 f5				push af  
6978 3a 8c 69			ld a, (.dmark)  
697b 32 6e fe			ld (debug_mark),a  
697e 3a 8d 69			ld a, (.dmark+1)  
6981 32 6f fe			ld (debug_mark+1),a  
6984 3a 8e 69			ld a, (.dmark+2)  
6987 32 70 fe			ld (debug_mark+2),a  
698a 18 03			jr .pastdmark  
698c ..			.dmark: db "ASc"  
698f f1			.pastdmark: pop af  
6990			endm  
# End of macro DMARK
6990						CALLMONITOR 
6990 cd a5 18			call break_point_state  
6993				endm  
# End of macro CALLMONITOR
6993					endif 
6993 11 83 fa			ld de, store_page+2 
6996 3e 78			ld a, display_row_4 
6998 cd dd 0c			call str_at_display 
699b			 
699b cd ed 0c			call update_display 
699e cd 3b 0c			call delay250ms 
69a1			 
69a1			 
69a1			 
69a1 21 83 fa			ld hl, store_page+2 
69a4 cd d5 22			call forthparse 
69a7 cd 15 23			call forthexec 
69aa cd 27 22			call forthexec_cleanup 
69ad			 
69ad				 
69ad 3a 73 fa			ld a, (store_openext) 
69b0 3c				inc a 
69b1 32 73 fa			ld (store_openext), a    ; save count of ext 
69b4			 
69b4 18 96			jr .autof 
69b6			;.autofdone: 
69b6			; 
69b6			;		if DEBUG_FORTH_WORDS 
69b6			;			DMARK "ASx" 
69b6			;			CALLMONITOR 
69b6			;		endif 
69b6			;;	call clear_display 
69b6			;	ret 
69b6			 
69b6			 
69b6			 
69b6			endif 
69b6			 
69b6			 
69b6			; eof 
# End of file forth_kernel.asm
69b6			;include "nascombasic.asm" 
69b6			 
69b6			 
69b6			; find out where the code ends if loaded into RAM (for SC114) 
69b6			;endofcode:  
69b6			;	nop 
69b6			 
69b6			 
69b6			; eof 
69b6			 
# End of file main.asm
69b6			include "firmware_lcd_4x40.asm" 
69b6			; **********************************************************************  
69b6			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
69b6			; **********************************************************************  
69b6			;  
69b6			; **  Written as a Small Computer Monitor App  
69b6			; **  www.scc.me.uk  
69b6			;  
69b6			; History  
69b6			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
69b6			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
69b6			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
69b6			;  
69b6			; **********************************************************************  
69b6			;  
69b6			; This program is an example of one of the methods of interfacing an   
69b6			; alphanumeric LCD module.   
69b6			;  
69b6			; In this example the display is connected to either a Z80 PIO or a   
69b6			; simple 8-bit output port.   
69b6			;  
69b6			; This interfacing method uses 4-bit data mode and uses time delays  
69b6			; rather than polling the display's ready status. As a result the   
69b6			; interface only requires 6 simple output lines:  
69b6			;   Output bit 0 = not used  
69b6			;   Output bit 1 = not used  
69b6			;   Output bit 2 = RS         High = data, Low = instruction  
69b6			;   Output bit 3 = E          Active high  
69b6			;   Output bit 4 = DB4  
69b6			;   Output bit 5 = DB5  
69b6			;   Output bit 6 = DB6  
69b6			;   Output bit 7 = DB7  
69b6			; Display's R/W is connected to 0v so it is always in write mode  
69b6			;  
69b6			; This set up should work with any system supporting the RC2014 bus  
69b6			  
69b6			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
69b6			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
69b6			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
69b6			;  
69b6			; **********************************************************************  
69b6			  
69b6			; Additonal for 4x40. E1 and E2 instead of just E   
69b6			; TODO swipe vidout signal on port a to activate E2  
69b6			  
69b6			; **********************************************************************  
69b6			; **  Constants  
69b6			; **********************************************************************  
69b6			; LCD constants required by LCD support module  
69b6			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
69b6			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
69b6			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
69b6			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
69b6			; TODO Decide which E is being set  
69b6			kLCDWidth:  EQU display_cols             ;Width in characters  
69b6			  
69b6			; **********************************************************************  
69b6			; **  Code library usage  
69b6			; **********************************************************************  
69b6			  
69b6			; send character to current cursor position  
69b6			; wraps and/or scrolls screen automatically  
69b6			  
69b6			  
69b6			  
69b6			lcd_init:  
69b6			  
69b6			; SCMonAPI functions used  
69b6			  
69b6			; Alphanumeric LCD functions used  
69b6			; no need to specify specific functions for this module  
69b6			  
69b6 3e cf		            LD   A, 11001111b  
69b8 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
69ba 3e 00		            LD   A, 00000000b  
69bc d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
69be			  
69be			; Initialise alphanumeric LCD module  
69be 3e 00				ld a, 0  
69c0 32 ce fb				ld (display_lcde1e2), a  
69c3 cd 44 6a		            CALL fLCD_Init      ;Initialise LCD module  
69c6 3e 01				ld a, 1  
69c8 32 ce fb				ld (display_lcde1e2), a  
69cb cd 44 6a		            CALL fLCD_Init      ;Initialise LCD module  
69ce			  
69ce c9				ret  
69cf			  
69cf			;  
69cf			;;  
69cf			; lcd functions  
69cf			;  
69cf			;  
69cf			  
69cf			; what is at cursor position   
69cf			  
69cf			;get_cursor:	ld de, (cursor_row)   ;  row + col  
69cf			;		call curptr  
69cf			;		ret  
69cf			  
69cf			  
69cf			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
69cf			  
69cf			curptr:  
69cf c5				push bc  
69d0 21 b4 fd			ld hl, display_fb0  
69d3			cpr:	  
69d3				; loop for cursor whole row  
69d3 0e 28			ld c, display_cols  
69d5 23			cpr1:	inc hl  
69d6 0d				dec c  
69d7 20 fc			jr nz, cpr1  
69d9 05				dec b  
69da 20 f7			jr nz, cpr  
69dc			  
69dc				; add col	  
69dc			  
69dc 23			cpr2:	inc hl  
69dd 1d				dec e  
69de 20 fc			jr nz, cpr2  
69e0			  
69e0 c1				pop bc  
69e1 c9				ret  
69e2				  
69e2			  
69e2			  
69e2			  
69e2			  
69e2			; write the frame buffer given in hl to hardware   
69e2 22 cc fb		write_display: ld (display_write_tmp), hl 	   
69e5 3e 00			ld a, kLCD_Line1  
69e7 cd f1 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69ea 06 28			ld b, display_cols  
69ec ed 5b cc fb		ld de, (display_write_tmp)  
69f0 cd 3c 6a			call write_len_string  
69f3				  
69f3				  
69f3 2a cc fb			ld hl, (display_write_tmp)  
69f6 11 28 00			ld de, display_cols  
69f9 19				add hl,de  
69fa 22 cc fb			ld (display_write_tmp),hl  
69fd			  
69fd				  
69fd 3e 28			ld a, kLCD_Line2  
69ff cd f1 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6a02 06 28			ld b, display_cols  
6a04 ed 5b cc fb		ld de, (display_write_tmp)  
6a08 cd 3c 6a			call write_len_string  
6a0b				  
6a0b 2a cc fb			ld hl, (display_write_tmp)  
6a0e 11 28 00			ld de, display_cols  
6a11 19				add hl,de  
6a12 22 cc fb			ld (display_write_tmp),hl  
6a15			  
6a15				  
6a15 3e 50			ld a, kLCD_Line3  
6a17 cd f1 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6a1a 06 28			ld b, display_cols  
6a1c ed 5b cc fb		ld de, (display_write_tmp)  
6a20 cd 3c 6a			call write_len_string  
6a23				  
6a23 2a cc fb			ld hl, (display_write_tmp)  
6a26 11 28 00			ld de, display_cols  
6a29 19				add hl,de  
6a2a 22 cc fb			ld (display_write_tmp),hl  
6a2d			  
6a2d				  
6a2d 3e 78			ld a, kLCD_Line4  
6a2f cd f1 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6a32 06 28			ld b, display_cols  
6a34 ed 5b cc fb		ld de, (display_write_tmp)  
6a38 cd 3c 6a			call write_len_string  
6a3b c9					ret  
6a3c				  
6a3c				; write out a fixed length string given in b from de  
6a3c			  
6a3c 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6a3d cd a9 6a		            CALL fLCD_Data      ;Write character to display  
6a40 13				inc de  
6a41 10 f9			djnz write_len_string  
6a43 c9				ret  
6a44			  
6a44			; Some other things to do  
6a44			;            LD   A, kLCD_Clear ;Display clear  
6a44			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6a44			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6a44			;            LD   A, kLCD_On     ;Display on with no cursor  
6a44			;            ;LD   A, kLCD_Off   ;Display off  
6a44			;            CALL fLCD_Inst      ;Send instruction to display  
6a44			;  
6a44			;  
6a44			;            halt  
6a44			;  
6a44			;  
6a44			;MsgHello:   DB  "Hello World!",0  
6a44			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6a44			  
6a44			; Custom characters 5 pixels wide by 8 pixels high  
6a44			; Up to 8 custom characters can be defined  
6a44			;BitMaps:      
6a44			;; Character 0x00 = Battery icon  
6a44			;            DB  01110b  
6a44			;            DB  11011b  
6a44			;            DB  10001b  
6a44			;            DB  10001b  
6a44			;            DB  11111b  
6a44			;            DB  11111b  
6a44			;            DB  11111b  
6a44			;            DB  11111b  
6a44			;; Character 0x01 = Bluetooth icon  
6a44			;            DB  01100b  
6a44			;            DB  01010b  
6a44			;            DB  11100b  
6a44			;            DB  01000b  
6a44			;            DB  11100b  
6a44			;            DB  01010b  
6a44			;            DB  01100b  
6a44			;            DB  00000b  
6a44			;  
6a44			  
6a44			  
6a44			; **********************************************************************  
6a44			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6a44			; **********************************************************************  
6a44			;  
6a44			; **  Written as a Small Computer Monitor App   
6a44			; **  Version 0.1 SCC 2018-05-16  
6a44			; **  www.scc.me.uk  
6a44			;  
6a44			; **********************************************************************  
6a44			;  
6a44			; This module provides support for alphanumeric LCD modules using with  
6a44			; *  HD44780 (or compatible) controller  
6a44			; *  5 x 7 pixel fonts  
6a44			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6a44			; *  Interface via six digital outputs to the display (see below)  
6a44			;  
6a44			; LCD module pinout:  
6a44			;   1  Vss   0v supply  
6a44			;   2  Vdd   5v supply  
6a44			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6a44			;   4  RS    High = data, Low = instruction  
6a44			;   5  R/W   High = Read, Low = Write  
6a44			;   6  E     Enable signal (active high)  
6a44			;   7  DB0   Data bit 0  
6a44			;   8  DB1   Data bit 1  
6a44			;   9  DB2   Data bit 2  
6a44			;  10  DB3   Data bit 3  
6a44			;  11  DB4   Data bit 4  
6a44			;  12  DB5   Data bit 5  
6a44			;  13  DB6   Data bit 6  
6a44			;  14  DB7   Data bit 7  
6a44			;  15  A     Backlight anode (+)  
6a44			;  16  K     Backlight cathode (-)  
6a44			;  
6a44			; This interfacing method uses 4-bit data mode and uses time delays  
6a44			; rather than polling the display's ready status. As a result the   
6a44			; interface only requires 6 simple output lines:  
6a44			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6a44			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6a44			;   LCD DB4 = Microcomputer output port bit 4  
6a44			;   LCD DB5 = Microcomputer output port bit 5  
6a44			;   LCD DB6 = Microcomputer output port bit 6  
6a44			;   LCD DB7 = Microcomputer output port bit 7  
6a44			; Display's R/W is connected to 0v so it is always in write mode  
6a44			; All 6 connections must be on the same port address <kLCDPrt>  
6a44			; This method also allows a decent length of cable from micro to LCD  
6a44			;  
6a44			; **********************************************************************  
6a44			;  
6a44			; To include the code for any given function provided by this module,   
6a44			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6a44			; the parent source file.  
6a44			; For example:  #REQUIRES   uHexPrefix  
6a44			;  
6a44			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6a44			; in the parent source file.  
6a44			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6a44			;  
6a44			; These are the function names provided by this module:  
6a44			; fLCD_Init                     ;Initialise LCD  
6a44			; fLCD_Inst                     ;Send instruction to LCD  
6a44			; fLCD_Data                     ;Send data byte to LCD  
6a44			; fLCD_Pos                      ;Position cursor  
6a44			; fLCD_Str                      ;Display string  
6a44			; fLCD_Def                      ;Define custom character  
6a44			;  
6a44			; **********************************************************************  
6a44			;  
6a44			; Requires SCMonAPI.asm to also be included in the project  
6a44			;  
6a44			  
6a44			  
6a44			; **********************************************************************  
6a44			; **  Constants  
6a44			; **********************************************************************  
6a44			  
6a44			; Constants that must be defined externally  
6a44			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6a44			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6a44			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6a44			;kLCDWidth: EQU 20             ;Width in characters  
6a44			  
6a44			; general line offsets in any frame buffer  
6a44			  
6a44			  
6a44			display_row_1: equ 0  
6a44			display_row_2: equ display_row_1+display_cols  
6a44			display_row_3: equ display_row_2 + display_cols  
6a44			display_row_4: equ display_row_3 + display_cols  
6a44			;display_row_4_eol:   
6a44			  
6a44			  
6a44			; Cursor position values for the start of each line  
6a44			  
6a44			; E  
6a44			kLCD_Line1: EQU 0x00   
6a44			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6a44			; E1  
6a44			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6a44			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6a44			  
6a44			; Instructions to send as A register to fLCD_Inst  
6a44			kLCD_Clear: EQU 00000001b     ;LCD clear  
6a44			kLCD_Off:   EQU 00001000b     ;LCD off  
6a44			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6a44			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6a44			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6a44			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6a44			  
6a44			; Constants used by this code module  
6a44			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6a44			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6a44			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6a44			  
6a44			  
6a44			  
6a44			; **********************************************************************  
6a44			; **  LCD support functions  
6a44			; **********************************************************************  
6a44			  
6a44			; Initialise alphanumeric LCD module  
6a44			; LCD control register codes:  
6a44			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6a44			;   N    0 = 1-line mode       1 = 2-line mode  
6a44			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6a44			;   D    0 = Display off       1 = Display on  
6a44			;   C    0 = Cursor off        1 = Cursor on  
6a44			;   B    0 = Blinking off      1 = Blinking on  
6a44			;   ID   0 = Decrement mode    1 = Increment mode  
6a44			;   SH   0 = Entire shift off  1 = Entire shift on  
6a44 3e 28		fLCD_Init:  LD   A, 40  
6a46 cd 6b 6b		            CALL LCDDelay       ;Delay 40ms after power up  
6a49			; For reliable reset set 8-bit mode - 3 times  
6a49 cd 3b 6b		            CALL WrFn8bit       ;Function = 8-bit mode  
6a4c cd 3b 6b		            CALL WrFn8bit       ;Function = 8-bit mode  
6a4f cd 3b 6b		            CALL WrFn8bit       ;Function = 8-bit mode  
6a52			; Set 4-bit mode  
6a52 cd 37 6b		            CALL WrFn4bit       ;Function = 4-bit mode  
6a55 cd 69 6b		            CALL LCDDelay1      ;Delay 37 us or more  
6a58			; Function set  
6a58 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6a5a cd 6d 6a		            CALL fLCD_Inst      ;2 line, display on  
6a5d			; Display On/Off control  
6a5d 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6a5f cd 6d 6a		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6a62			; Display Clear  
6a62 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6a64 cd 6d 6a		            CALL fLCD_Inst      ;Clear display  
6a67			; Entry mode  
6a67 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6a69 cd 6d 6a		            CALL fLCD_Inst      ;Increment mode, shift off  
6a6c			; Display module now initialised  
6a6c c9			            RET  
6a6d			; ok to here  
6a6d			  
6a6d			; Write instruction to LCD  
6a6d			;   On entry: A = Instruction byte to be written  
6a6d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a6d f5			fLCD_Inst:  PUSH AF  
6a6e f5			            PUSH AF  
6a6f cd 81 6a		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6a72 f1			            POP  AF  
6a73 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6a74 17			            RLA  
6a75 17			            RLA  
6a76 17			            RLA  
6a77 cd 81 6a		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6a7a 3e 02		            LD   A, 2  
6a7c cd 6b 6b		            CALL LCDDelay       ;Delay 2 ms to complete   
6a7f f1			            POP  AF  
6a80 c9			            RET  
6a81			Wr4bits:   
6a81 f5					push af  
6a82 3a ce fb				ld a, (display_lcde1e2)  
6a85 fe 00				cp 0     ; e  
6a87 20 10				jr nz, .wea2	  
6a89 f1					pop af  
6a8a e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6a8c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a8e cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
6a90 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
6a92 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6a94 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6a96 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a98 c9			            RET  
6a99 f1			.wea2:		pop af  
6a9a e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6a9c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a9e cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
6aa0 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
6aa2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6aa4 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
6aa6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6aa8 c9			            RET  
6aa9			  
6aa9			  
6aa9			; Write data to LCD  
6aa9			;   On entry: A = Data byte to be written  
6aa9			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6aa9 f5			fLCD_Data:  PUSH AF  
6aaa f5			            PUSH AF  
6aab cd bd 6a		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6aae f1			            POP  AF  
6aaf 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6ab0 17			            RLA  
6ab1 17			            RLA  
6ab2 17			            RLA  
6ab3 cd bd 6a		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6ab6 3e 96		            LD   A, 150  
6ab8 3d			Wait:      DEC  A              ;Wait a while to allow data   
6ab9 20 fd		            JR   NZ, Wait      ;  write to complete  
6abb f1			            POP  AF  
6abc c9			            RET  
6abd			Wr4bitsa:     
6abd f5					push af  
6abe 3a ce fb				ld a, (display_lcde1e2)  
6ac1 fe 00				cp 0     ; e1  
6ac3 20 16				jr nz, .we2	  
6ac5 f1					pop af  
6ac6 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6ac8 cb d7		            SET  kLCDBitRS, A  
6aca d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6acc cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6ace cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6ad0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6ad2 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
6ad4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6ad6 cb 97		            RES  kLCDBitRS, A  
6ad8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6ada c9			            RET  
6adb f1			.we2:		pop af  
6adc e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6ade cb d7		            SET  kLCDBitRS, A  
6ae0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6ae2 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
6ae4 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
6ae6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6ae8 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6aea d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6aec cb 97		            RES  kLCDBitRS, A  
6aee d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6af0 c9			            RET  
6af1			  
6af1			  
6af1			; Position cursor to specified location  
6af1			;   On entry: A = Cursor position  
6af1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6af1 f5			fLCD_Pos:   PUSH AF  
6af2					; at this point set the E1 or E2 flag depending on position  
6af2			  
6af2 c5					push bc  
6af3			;		push af  
6af3 06 00				ld b, 0  
6af5 4f					ld c, a  
6af6 3e 4f				ld a, kLCD_Line3-1  
6af8 b7			 		or a      ;clear carry flag  
6af9 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
6afa 38 04				jr c, .pe1  
6afc			  
6afc					; E selection  
6afc cb 80				res 0, b         ; bit 0 unset e  
6afe			;		pop af    ; before line 3 so recover orig pos  
6afe			;		ld c, a    ; save for poking back  
6afe 18 06				jr .peset	          
6b00			.pe1:          	; E2 selection  
6b00 cb c0				set 0, b         ; bit 0 set e1  
6b02 79					ld a, c  
6b03 de 4f				sbc a, kLCD_Line3-1  
6b05 4f					ld c, a	         ; save caculated offset  
6b06			;		pop af     ; bin this original value now we have calculated form  
6b06			  
6b06			.peset:		; set bit  
6b06 78					ld a, b  
6b07 32 ce fb				ld (display_lcde1e2), a 	  
6b0a 79					ld a, c  
6b0b c1					pop bc  
6b0c			  
6b0c f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6b0e cd 6d 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6b11 f1			            POP  AF  
6b12 c9			            RET  
6b13			  
6b13			  
6b13			; Output text string to LCD  
6b13			;   On entry: DE = Pointer to null terminated text string  
6b13			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6b13 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6b14 b7			            OR   A              ;Null terminator?  
6b15 c8			            RET  Z              ;Yes, so finished  
6b16 cd a9 6a		            CALL fLCD_Data      ;Write character to display  
6b19 13			            INC  DE             ;Point to next character  
6b1a 18 f7		            JR   fLCD_Str       ;Repeat  
6b1c c9					ret  
6b1d			  
6b1d			; Define custom character  
6b1d			;   On entry: A = Character number (0 to 7)  
6b1d			;             DE = Pointer to character bitmap data  
6b1d			;   On exit:  A = Next character number  
6b1d			;             DE = Next location following bitmap  
6b1d			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6b1d			; Character is   
6b1d c5			fLCD_Def:   PUSH BC  
6b1e f5			            PUSH AF  
6b1f 07			            RLCA                ;Calculate location  
6b20 07			            RLCA                ;  for bitmap data  
6b21 07			            RLCA                ;  = 8 x CharacterNumber  
6b22 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6b24 cd 6d 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6b27 06 00		            LD   B, 0  
6b29 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6b2a cd a9 6a		            CALL fLCD_Data      ;Write byte to display  
6b2d 13			            INC  DE             ;Point to next byte  
6b2e 04			            INC  B              ;Count bytes  
6b2f cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6b31 28 f6		            JR   Z, Loop       ;No, so repeat  
6b33 f1			            POP  AF  
6b34 3c			            INC  A              ;Increment character number  
6b35 c1			            POP  BC  
6b36 c9			            RET  
6b37			  
6b37			  
6b37			; **********************************************************************  
6b37			; **  Private functions  
6b37			; **********************************************************************  
6b37			  
6b37			; Write function to LCD  
6b37			;   On entry: A = Function byte to be written  
6b37			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6b37 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6b39 18 02		            JR   WrFunc  
6b3b 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6b3d f5			WrFunc:     PUSH AF  
6b3e f5					push af  
6b3f 3a ce fb				ld a, (display_lcde1e2)  
6b42 fe 00				cp 0     ; e1  
6b44 20 0f				jr nz, .wfea2	  
6b46 f1					pop af  
6b47 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b49 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6b4b cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6b4d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6b4f cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6b51 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b53 18 0d			jr .wfskip  
6b55 f1			.wfea2:		pop af  
6b56 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b58 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6b5a cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6b5c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6b5e cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6b60 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b62 3e 05		.wfskip:            LD  A, 5  
6b64 cd 6b 6b		            CALL LCDDelay       ;Delay 5 ms to complete  
6b67 f1			            POP  AF  
6b68 c9			            RET  
6b69			  
6b69			  
6b69			; Delay in milliseconds  
6b69			;   On entry: A = Number of milliseconds delay  
6b69			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6b69 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6b6b d5			LCDDelay:   PUSH DE  
6b6c 5f			            LD   E, A           ;Delay by 'A' ms  
6b6d 16 00		            LD   D, 0  
6b6f cd 2c 0c		            CALL aDelayInMS  
6b72 d1			            POP  DE  
6b73 c9			            RET  
6b74			  
6b74			  
6b74			testlcd:  
6b74 3e 00			ld a, kLCD_Line1  
6b76 cd f1 6a			call fLCD_Pos  
6b79 06 28			ld b, 40  
6b7b 11 a9 6b			ld de, .ttext1  
6b7e cd 3c 6a			call write_len_string  
6b81			  
6b81 3e 28			ld a, kLCD_Line2  
6b83 cd f1 6a			call fLCD_Pos  
6b86 06 28			ld b, 40  
6b88 11 d2 6b			ld de, .ttext2  
6b8b cd 3c 6a			call write_len_string  
6b8e 3e 50			ld a, kLCD_Line3  
6b90 cd f1 6a			call fLCD_Pos  
6b93 06 28			ld b, 40  
6b95 11 fb 6b			ld de, .ttext3  
6b98 cd 3c 6a			call write_len_string  
6b9b 3e 78			ld a, kLCD_Line4  
6b9d cd f1 6a			call fLCD_Pos  
6ba0 06 28			ld b, 40  
6ba2 11 24 6c			ld de, .ttext4  
6ba5 cd 3c 6a			call write_len_string  
6ba8			  
6ba8 76				halt  
6ba9			  
6ba9			  
6ba9 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
6bd2 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
6bfb .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
6c24 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6c4d			   
6c4d			  
6c4d			  
6c4d			; eof  
6c4d			  
# End of file firmware_lcd_4x40.asm
6c4d			;include "firmware_lcd_4x20.asm" 
6c4d			include "firmware_key_5x10.asm" 
6c4d			; 5 x 10 decade counter scanner  
6c4d			  
6c4d			  
6c4d			; TODO do cursor shape change for shift keys  
6c4d			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6c4d			  
6c4d			  
6c4d			; bit mask for each scan column and row for teing the matrix  
6c4d			  
6c4d			  
6c4d			key_init:  
6c4d			  
6c4d			; SCMonAPI functions used  
6c4d			  
6c4d			; Alphanumeric LCD functions used  
6c4d			; no need to specify specific functions for this module  
6c4d			  
6c4d			  
6c4d 3e cf		            LD   A, 11001111b  
6c4f d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6c51			;            LD   A, 00000000b  
6c51 3e 1f		            LD   A, 00011111b  
6c53 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6c55			  
6c55			  
6c55				; TODO Configure cursor shapes  
6c55			  
6c55				; Load cursor shapes   
6c55 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6c57 11 67 6c		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6c5a 06 02		            LD   B, 2           ;Number of characters to define  
6c5c cd 1d 6b		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6c5f 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6c61			  
6c61 3e 01				ld a, 1  
6c63 32 c7 fb			ld (cursor_shape),a  
6c66 c9				ret  
6c67			  
6c67			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6c67			; Up to 8 custom characters can be defined  
6c67			.cursor_shapes:      
6c67			;; Character 0x00 = Normal  
6c67 1f			            DB  11111b  
6c68 1f			            DB  11111b  
6c69 1f			            DB  11111b  
6c6a 1f			            DB  11111b  
6c6b 1f			            DB  11111b  
6c6c 1f			            DB  11111b  
6c6d 1f			            DB  11111b  
6c6e 1f			            DB  11111b  
6c6f			;; Character 0x01 = Modifier  
6c6f 1f			            DB  11111b  
6c70 1b			            DB  11011b  
6c71 1b			            DB  11011b  
6c72 1b			            DB  11011b  
6c73 1b			            DB  11011b  
6c74 1f			            DB  11111b  
6c75 1b			            DB  11011b  
6c76 1f			            DB  11111b  
6c77			  
6c77			  
6c77			  
6c77			  
6c77			; Display custom character 0  
6c77			;            LD   A, kLCD_Line1+14  
6c77			;            CALL fLCD_Pos       ;Position cursor to location in A  
6c77			;            LD   A, 0  
6c77			;            CALL fLCD_Data      ;Write character in A at cursor  
6c77			  
6c77			; Display custom character 1  
6c77			;            LD   A, kLCD_Line2+14  
6c77			;            CALL fLCD_Pos      ;Position cursor to location in A  
6c77			;            LD   A, 1  
6c77			;            CALL fLCD_Data     ;Write character in A at cursor  
6c77			  
6c77			; keyboard scanning   
6c77			  
6c77			; character in from keyboard  
6c77			  
6c77			; mapping for the pcb layout  
6c77			  
6c77			.matrix_to_char:  
6c77 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6c82 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6c8d 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6c98 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
6ca3 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6cae			.matrix_to_shift:  
6cae			  
6cae .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
6cb9 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6cc4 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6ccf 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6cda .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
6ce5			  
6ce5			.matrix_to_symbolshift:  
6ce5			  
6ce5 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6cf0 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
6cfb 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
6d06			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6d06 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6d11 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6d1c			  
6d1c			  
6d1c			  
6d1c			; mapping for a simple straight through breadboard layout  
6d1c			  
6d1c			;.matrix_to_char:  
6d1c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6d1c			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6d1c			;		db "asdfghjkl",KEY_CR,0  
6d1c			;		db "qwertyuiop",0  
6d1c			;		 db "1234567890",0  
6d1c			;.matrix_to_shift:  
6d1c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6d1c			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6d1c			;		db "ASDFGHJKL",KEY_CR,0  
6d1c			;		db "QWERTYUIOP",0  
6d1c			;		 db "!",'"',"#$%^&*()",0  
6d1c			;.matrix_to_symbolshift:  
6d1c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6d1c			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6d1c			;		db "_?*fghjk=",KEY_CR,0  
6d1c			;		db "-/+*[]{}@#",0  
6d1c			;		 db "1234567890",0  
6d1c			  
6d1c			;.matrix_to_char: db "D#0*C987B654A321"  
6d1c			  
6d1c			  
6d1c				  
6d1c			  
6d1c			; add cin and cin_wait  
6d1c			  
6d1c cd 2d 6d		cin_wait: 	call cin  
6d1f						if DEBUG_KEYCINWAIT  
6d1f							push af  
6d1f							  
6d1f							ld hl,key_repeat_ct  
6d1f							ld (hl),a  
6d1f							inc hl  
6d1f							call hexout  
6d1f							ld hl,key_repeat_ct+3  
6d1f							ld a,0  
6d1f							ld (hl),a  
6d1f			  
6d1f							    LD   A, kLCD_Line1+11  
6d1f							    CALL fLCD_Pos       ;Position cursor to location in A  
6d1f							    LD   DE, key_repeat_ct  
6d1f							    ;LD   DE, MsgHello  
6d1f							    CALL fLCD_Str       ;Display string pointed to by DE  
6d1f			  
6d1f			  
6d1f			  
6d1f							pop af  
6d1f						endif  
6d1f fe 00			cp 0  
6d21 28 f9			jr z, cin_wait   ; block until key press  
6d23			  
6d23							if DEBUG_KEYCINWAIT  
6d23								push af  
6d23			  
6d23								ld a, 'A'	  
6d23								ld hl,key_repeat_ct  
6d23								ld (hl),a  
6d23								inc hl  
6d23								ld a,0  
6d23								ld (hl),a  
6d23			  
6d23								    LD   A, kLCD_Line2+11  
6d23								    CALL fLCD_Pos       ;Position cursor to location in A  
6d23								    LD   DE, key_repeat_ct  
6d23								    ;LD   DE, MsgHello  
6d23								    CALL fLCD_Str       ;Display string pointed to by DE  
6d23			  
6d23							call delay500ms  
6d23			  
6d23								pop af  
6d23							endif  
6d23 f5				push af   ; save key pressed  
6d24			  
6d24			.cin_wait1:	  
6d24							if DEBUG_KEYCINWAIT  
6d24								push af  
6d24			  
6d24								ld a, 'b'	  
6d24								ld hl,key_repeat_ct  
6d24								ld (hl),a  
6d24								inc hl  
6d24								ld a,0  
6d24								ld (hl),a  
6d24			  
6d24								    LD   A, kLCD_Line2+11  
6d24								    CALL fLCD_Pos       ;Position cursor to location in A  
6d24								    LD   DE, key_repeat_ct  
6d24								    ;LD   DE, MsgHello  
6d24								    CALL fLCD_Str       ;Display string pointed to by DE  
6d24			  
6d24			  
6d24							call delay500ms  
6d24			  
6d24								pop af  
6d24							endif  
6d24			  
6d24 cd 2d 6d		call cin  
6d27 fe 00			cp 0  
6d29 20 f9			jr nz, .cin_wait1  	; wait for key release  
6d2b			if DEBUG_KEYCINWAIT  
6d2b				push af  
6d2b			  
6d2b				ld a, '3'	  
6d2b				ld hl,key_repeat_ct  
6d2b				ld (hl),a  
6d2b				inc hl  
6d2b				ld a,0  
6d2b				ld (hl),a  
6d2b			  
6d2b			            LD   A, kLCD_Line2+11  
6d2b			            CALL fLCD_Pos       ;Position cursor to location in A  
6d2b			            LD   DE, key_repeat_ct  
6d2b			            ;LD   DE, MsgHello  
6d2b			            CALL fLCD_Str       ;Display string pointed to by DE  
6d2b			  
6d2b			  
6d2b			call delay500ms  
6d2b			  
6d2b				pop af  
6d2b			endif  
6d2b			  
6d2b f1				pop af   ; get key  
6d2c c9				ret  
6d2d			  
6d2d			  
6d2d cd 41 6d		cin: 	call .mtoc  
6d30			  
6d30			if DEBUG_KEYCIN  
6d30				push af  
6d30				  
6d30				ld hl,key_repeat_ct  
6d30				ld (hl),a  
6d30				inc hl  
6d30				call hexout  
6d30				ld hl,key_repeat_ct+3  
6d30				ld a,0  
6d30				ld (hl),a  
6d30			  
6d30			            LD   A, kLCD_Line3+15  
6d30			            CALL fLCD_Pos       ;Position cursor to location in A  
6d30			            LD   DE, key_repeat_ct  
6d30			            ;LD   DE, MsgHello  
6d30			            CALL fLCD_Str       ;Display string pointed to by DE  
6d30			  
6d30			  
6d30			call delay500ms  
6d30			  
6d30				pop af  
6d30			endif  
6d30			  
6d30			  
6d30				; no key held  
6d30 fe 00			cp 0  
6d32 c8				ret z  
6d33			  
6d33			if DEBUG_KEYCIN  
6d33				push af  
6d33			  
6d33				ld a, '1'	  
6d33				ld hl,key_repeat_ct  
6d33				ld (hl),a  
6d33				inc hl  
6d33				ld a,0  
6d33				ld (hl),a  
6d33			  
6d33			            LD   A, kLCD_Line4+15  
6d33			            CALL fLCD_Pos       ;Position cursor to location in A  
6d33			            LD   DE, key_repeat_ct  
6d33			            ;LD   DE, MsgHello  
6d33			            CALL fLCD_Str       ;Display string pointed to by DE  
6d33			  
6d33			  
6d33			call delay500ms  
6d33			  
6d33				pop af  
6d33			endif  
6d33			  
6d33				; stop key bounce  
6d33			  
6d33 32 88 fe			ld (key_held),a		 ; save it  
6d36 47				ld b, a  
6d37			  
6d37 c5			.cina1:	push bc  
6d38			if DEBUG_KEYCIN  
6d38				push af  
6d38			  
6d38				ld hl,key_repeat_ct  
6d38				inc hl  
6d38				call hexout  
6d38				ld hl,key_repeat_ct+3  
6d38				ld a,0  
6d38				ld (hl),a  
6d38				ld hl,key_repeat_ct  
6d38				ld a, '2'	  
6d38				ld (hl),a  
6d38			  
6d38			            LD   A, kLCD_Line4+15  
6d38			            CALL fLCD_Pos       ;Position cursor to location in A  
6d38			            LD   DE, key_repeat_ct  
6d38			            ;LD   DE, MsgHello  
6d38			            CALL fLCD_Str       ;Display string pointed to by DE  
6d38			  
6d38				pop af  
6d38			endif  
6d38 cd 41 6d			call .mtoc  
6d3b c1				pop bc  
6d3c b8				cp b  
6d3d 28 f8			jr z, .cina1  
6d3f 78				ld a,b		  
6d40			if DEBUG_KEYCIN  
6d40				push af  
6d40			  
6d40				ld hl,key_repeat_ct  
6d40				inc hl  
6d40				call hexout  
6d40				ld hl,key_repeat_ct+3  
6d40				ld a,0  
6d40				ld (hl),a  
6d40				ld hl,key_repeat_ct  
6d40				ld a, '3'	  
6d40				ld (hl),a  
6d40			  
6d40			            LD   A, kLCD_Line4+15  
6d40			            CALL fLCD_Pos       ;Position cursor to location in A  
6d40			            LD   DE, key_repeat_ct  
6d40			            ;LD   DE, MsgHello  
6d40			            CALL fLCD_Str       ;Display string pointed to by DE  
6d40			  
6d40				pop af  
6d40			endif  
6d40 c9				ret  
6d41			  
6d41			; detect keyboard modifier key press and apply new overlay to the face key held  
6d41			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6d41			  
6d41			;.cin_map_modifier:   
6d41			;	ld a, (hl)  
6d41			;	and 255  
6d41			;	ret NZ		; modifier key not flagged  
6d41			;  
6d41			;	; get key face  
6d41			;  
6d41			;	ld b,(key_face_held)  
6d41			;  
6d41			;	ld b, key_cols * key_rows  
6d41			;  
6d41			;	push de  
6d41			;	pop hl  
6d41			;  
6d41			;.mmod1: ld a,(hl)   ; get map test  
6d41			;	cp b  
6d41			;	jr z, .mmod2  
6d41			;  
6d41			;  
6d41			;  
6d41			;.mmod2: inc hl    ;   
6d41			;  
6d41			;	  
6d41			;  
6d41			;	  
6d41			;  
6d41			;	ld hl,key_actual_pressed  
6d41			;	ld (hl),a,  
6d41			;	ret  
6d41			  
6d41			; map matrix key held to char on face of key  
6d41			  
6d41			.mtoc:  
6d41			  
6d41			; test decade counter strobes  
6d41			  
6d41			;.decadetest1:  
6d41			  
6d41			; reset counter  
6d41			;ld a, 128  
6d41			;out (portbdata),a  
6d41			  
6d41			  
6d41			;ld b, 5  
6d41			;.dec1:  
6d41			;ld a, 0  
6d41			;out (portbdata),a  
6d41			;call delay1s  
6d41			  
6d41			;ld a, 32  
6d41			;out (portbdata),a  
6d41			;call delay1s  
6d41			;call delay1s  
6d41			;call delay1s  
6d41			;  
6d41			;ld a, 64+32  
6d41			;out (portbdata),a  
6d41			;call delay1s  
6d41			;;djnz .dec1  
6d41			;  
6d41			;jp .decadetest1  
6d41			  
6d41			  
6d41			  
6d41			  
6d41			  
6d41			  
6d41			  
6d41			  
6d41			  
6d41			  
6d41				; scan keyboard matrix and generate raw scan map  
6d41 cd d4 6d			call matrix  
6d44			  
6d44				; reuse c bit 0 left modifer button - ie shift  
6d44			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6d44				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6d44			  
6d44 0e 00			ld c, 0  
6d46			  
6d46				; TODO set flags for modifer key presses   
6d46				; TODO do a search for modifer key...  
6d46			  
6d46				;ld hl,keyscan_table_row4  
6d46 21 e7 fe			ld hl,keyscan_table_row2  
6d49			  
6d49 7e				ld a, (hl)  
6d4a fe 23			cp '#'  
6d4c 20 07			jr nz, .nextmodcheck  
6d4e cb c1			set 0, c  
6d50 21 ae 6c			ld hl, .matrix_to_shift  
6d53 18 21			jr .dokeymap  
6d55				; TODO for now igonre  
6d55			.nextmodcheck:  
6d55 21 dc fe			ld hl,keyscan_table_row3  
6d58			  
6d58 7e				ld a, (hl)  
6d59 fe 23			cp '#'  
6d5b 20 07			jr nz, .nextmodcheck2  
6d5d cb c9			set 1, c   
6d5f 21 e5 6c			ld hl, .matrix_to_symbolshift  
6d62 18 12			jr .dokeymap  
6d64			.nextmodcheck2:  
6d64 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
6d67			  
6d67 7e				ld a, (hl)  
6d68 fe 23			cp '#'  
6d6a 20 07			jr nz, .donemodcheck  
6d6c cb c9			set 1, c   
6d6e 21 ae 6c			ld hl, .matrix_to_shift  
6d71 18 03			jr .dokeymap  
6d73			  
6d73				; no modifer found so just map to normal keys  
6d73				; get mtoc map matrix to respective keys  
6d73			;	ld hl, .matrix_to_char  
6d73			;	ld hl, .matrix_to_char  
6d73			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6d73			;	ld a, KEY_SHIFT  
6d73			;	call findchar  
6d73			;  
6d73			;	; got offset to key modifer in b  
6d73			;  
6d73			;	ld hl,keyscan_table_row5  
6d73			;  
6d73			;	ld a,b  
6d73			;	call addatohl  
6d73			;	ld a,(hl)  
6d73			;  
6d73			;	cp '#'  
6d73			;	jr nz, .nextmodcheck  
6d73			;	set 0, c  
6d73			;	ld hl, .matrix_to_char  
6d73			;	jr .dokeymap  
6d73			;	; TODO for now igonre  
6d73			;.nextmodcheck:  
6d73			;	ld hl, .matrix_to_symbolshift  
6d73			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6d73			;	ld a, KEY_SYMBOLSHIFT  
6d73			;	call findchar  
6d73			;  
6d73			;  
6d73			;	; got offset to key modifer in b  
6d73			;  
6d73			;	ld hl,keyscan_table_row5  
6d73			;  
6d73			;	ld a,b  
6d73			;	call addatohl  
6d73			;	ld a,(hl)  
6d73			;  
6d73			;	cp '#'  
6d73			;	jr nz, .donemodcheck  
6d73			;	set 1, c   
6d73			;	ld hl, .matrix_to_symbolshift  
6d73			;	jr .dokeymap  
6d73			  
6d73			  
6d73			  
6d73			.donemodcheck:  
6d73				; no modifer found so just map to normal keys  
6d73				; get mtoc map matrix to respective keys  
6d73 21 77 6c			ld hl, .matrix_to_char  
6d76			  
6d76			.dokeymap:  
6d76				;ld (key_fa), c   
6d76 cd 8f 6d			call .mapkeys  
6d79			  
6d79			  
6d79			if DEBUG_KEY  
6d79			  
6d79			; Display text on first line  
6d79			            LD   A, kLCD_Line1  
6d79			            CALL fLCD_Pos       ;Position cursor to location in A  
6d79			            LD   DE, keyscan_table_row1  
6d79			            ;LD   DE, MsgHello  
6d79			            CALL fLCD_Str       ;Display string pointed to by DE  
6d79			  
6d79			; Display text on second line  
6d79			            LD   A, kLCD_Line2  
6d79			            CALL fLCD_Pos       ;Position cursor to location in A  
6d79			            LD   DE, keyscan_table_row2  
6d79			            CALL fLCD_Str       ;Display string pointed to by DE  
6d79			            LD   A, kLCD_Line3  
6d79			            CALL fLCD_Pos       ;Position cursor to location in A  
6d79			            LD   DE, keyscan_table_row3  
6d79			            CALL fLCD_Str       ;Display string pointed to by DE  
6d79			            LD   A, kLCD_Line4  
6d79			            CALL fLCD_Pos       ;Position cursor to location in A  
6d79			            LD   DE, keyscan_table_row4  
6d79			            CALL fLCD_Str       ;Display string pointed to by DE  
6d79			            LD   A, kLCD_Line1+10  
6d79			            CALL fLCD_Pos       ;Position cursor to location in A  
6d79			            LD   DE, keyscan_table_row5  
6d79			            CALL fLCD_Str       ;Display string pointed to by DE  
6d79			  
6d79				;call delay250ms  
6d79			endif  
6d79			;	jp testkey  
6d79			  
6d79			; get first char reported  
6d79			  
6d79 21 c6 fe			ld hl,keyscan_table_row5  
6d7c			  
6d7c				;ld b, 46   ; 30 keys to remap + 8 nulls   
6d7c 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6d7e			.findkey:  
6d7e 7e				ld a,(hl)  
6d7f fe 00			cp 0  
6d81 28 04			jr z, .nextkey  
6d83 fe 7e			cp KEY_MATRIX_NO_PRESS  
6d85 20 06			jr nz, .foundkey  
6d87			.nextkey:  
6d87 23				inc hl  
6d88 10 f4			djnz .findkey  
6d8a 3e 00			ld a,0  
6d8c c9				ret  
6d8d			.foundkey:  
6d8d 7e				ld a,(hl)  
6d8e c9				ret  
6d8f				  
6d8f			  
6d8f			; convert the raw key map given hl for destination key  
6d8f			.mapkeys:  
6d8f 11 c6 fe			ld de,keyscan_table_row5  
6d92			  
6d92 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6d94			.remap:  
6d94 1a				ld a,(de)  
6d95 fe 23			cp '#'  
6d97 20 02			jr nz, .remapnext  
6d99				;CALLMONITOR  
6d99 7e				ld a,(hl)  
6d9a 12				ld (de),a  
6d9b			  
6d9b			  
6d9b			  
6d9b			.remapnext:  
6d9b 23				inc hl  
6d9c 13				inc de  
6d9d 10 f5			djnz .remap  
6d9f				  
6d9f c9				ret  
6da0			  
6da0			  
6da0			  
6da0			.mtocold2:  
6da0			  
6da0			;	; flag if key D is held down and remove from reporting  
6da0			;	ld bc, .key_map_fd    
6da0			;	ld hl, keyscan_table  
6da0			;	ld de, key_fd  
6da0			;	call .key_shift_hold  
6da0			;	cp 255  
6da0			;	jr z, .cinmap  
6da0			;	; flag if key C is held down and remove from reporting  
6da0			;	ld bc, .key_map_fc    
6da0			;	ld hl, keyscan_table+key_cols  
6da0			;	ld de, key_fc  
6da0			;	call .key_shift_hold  
6da0			;	cp 255  
6da0			;	jr z, .cinmap  
6da0			;	; flag if key B is held down and remove from reporting  
6da0			;	ld bc, .key_map_fb    
6da0			;	ld hl, keyscan_table+(key_cols*2)  
6da0			;	ld de, key_fb  
6da0			;	call .key_shift_hold  
6da0			;	cp 255  
6da0			;	jr z, .cinmap  
6da0			;	; flag if key A is held down and remove from reporting  
6da0			;	ld bc, .key_map_fa    
6da0			;	ld hl, keyscan_table+(key_cols*3)  
6da0			;	ld de, key_fa  
6da0			;	call .key_shift_hold  
6da0			;	cp 255  
6da0			;	jr z, .cinmap  
6da0			  
6da0 11 77 6c			ld de, .matrix_to_char  
6da3			  
6da3			  
6da3			.cinmap1:   
6da3				if DEBUG_KEY  
6da3			            LD   A, kLCD_Line4  
6da3			            CALL fLCD_Pos       ;Position cursor to location in A  
6da3					push de  
6da3			            LD   DE, keyscan_table  
6da3			            CALL fLCD_Str       ;Display string pointed to by DE  
6da3					pop de  
6da3				endif  
6da3			  
6da3				; scan key matrix table for any held key  
6da3			  
6da3				; de holds either the default matrix or one selected above  
6da3			  
6da3 21 93 fe			ld hl, keyscan_table  
6da6 06 32			ld b,key_cols*key_rows  
6da8			  
6da8 7e			.cin11:	ld a,(hl)  
6da9 fe 23			cp '#'  
6dab 28 08			jr z, .cinhit1  
6dad 23				inc hl  
6dae 13				inc de  
6daf 05				dec b  
6db0 20 f6			jr nz, .cin11  
6db2				; no key found held  
6db2 3e 00			ld a,0  
6db4 c9				ret  
6db5 d5			.cinhit1: push de  
6db6 e1				pop hl  
6db7 7e				ld a,(hl)  
6db8 c9				ret  
6db9			  
6db9			; flag a control key is held   
6db9			; hl is key pin, de is flag indicator  
6db9			  
6db9			.key_shift_hold1:  
6db9 c5				push bc  
6dba 3e 01			ld a, 1  
6dbc 32 c7 fb			ld (cursor_shape),a  
6dbf 06 00			ld b, 0  
6dc1 7e				ld a, (hl)  
6dc2 fe 2e			cp '.'  
6dc4 28 0a			jr z, .key_shift11  
6dc6 06 ff			ld b, 255  
6dc8 3e 2b			ld a, '+'    ; hide key from later scans  
6dca 77				ld (hl),a  
6dcb 3e 02			ld a, 2  
6dcd 32 c7 fb			ld (cursor_shape),a  
6dd0			.key_shift11:  
6dd0				; write flag indicator  
6dd0 78				ld a,b  
6dd1 12				ld (de),a  
6dd2			  
6dd2 d1				pop de    ; de now holds the key map ptr  
6dd3 c9				ret  
6dd4			  
6dd4				  
6dd4			  
6dd4			; scans keyboard matrix and flags key press in memory array	  
6dd4				  
6dd4			matrix:  
6dd4				;call matrix  
6dd4				; TODO optimise the code....  
6dd4			  
6dd4			  
6dd4			;ld hl, keyscan_table_row1  
6dd4			;ld de, keyscan_table_row1+1  
6dd4			;ld bc,46  
6dd4			;ld a,KEY_MATRIX_NO_PRESS  
6dd4			;ldir  
6dd4			  
6dd4			  
6dd4			  
6dd4			; reset counter  
6dd4 3e 80		ld a, 128  
6dd6 d3 c1		out (portbdata),a  
6dd8			  
6dd8 06 0a		ld b, 10  
6dda 0e 00		ld c, 0       ; current clock toggle  
6ddc			  
6ddc			.colscan:  
6ddc			  
6ddc			; set current column  
6ddc			; disable clock enable and set clock low  
6ddc			  
6ddc			;ld a, 0  
6ddc			;out (portbdata),a  
6ddc			  
6ddc			; For each column scan for switches  
6ddc			  
6ddc c5			push bc  
6ddd 21 89 fe		ld hl, keyscan_scancol  
6de0 cd e9 6e		call .rowscan  
6de3 c1			pop bc  
6de4			  
6de4			  
6de4			; get back current column  
6de4			  
6de4			; translate the row scan  
6de4			  
6de4			;   
6de4			; row 1  
6de4			  
6de4 78			ld a,b  
6de5			  
6de5 21 fc fe		LD   hl, keyscan_table_row1+10  
6de8			  
6de8 cd 10 0f		call subafromhl  
6deb			;call addatohl  
6deb			  
6deb 11 89 fe		ld de, keyscan_scancol  
6dee			  
6dee 1a			ld a,(de)  
6def 77			ld (hl),a  
6df0			  
6df0			  
6df0			  
6df0			  
6df0			; row 2  
6df0			  
6df0 78			ld a,b  
6df1			  
6df1 21 f1 fe		LD   hl, keyscan_table_row2+10  
6df4			  
6df4			;call addatohl  
6df4 cd 10 0f		call subafromhl  
6df7			  
6df7			  
6df7 11 8a fe		ld de, keyscan_scancol+1  
6dfa			  
6dfa 1a			ld a,(de)  
6dfb 77			ld (hl),a  
6dfc			  
6dfc			  
6dfc			; row 3  
6dfc			  
6dfc 78			ld a,b  
6dfd			  
6dfd 21 e6 fe		LD   hl, keyscan_table_row3+10  
6e00			  
6e00			;call addatohl  
6e00 cd 10 0f		call subafromhl  
6e03			  
6e03 11 8b fe		ld de, keyscan_scancol+2  
6e06			  
6e06 1a			ld a,(de)  
6e07 77			ld (hl),a  
6e08			  
6e08			  
6e08			  
6e08			; row 4  
6e08			  
6e08 78			ld a,b  
6e09			  
6e09 21 db fe		LD   hl, keyscan_table_row4+10  
6e0c			  
6e0c			;call addatohl  
6e0c cd 10 0f		call subafromhl  
6e0f			  
6e0f 11 8c fe		ld de, keyscan_scancol+3  
6e12			  
6e12 1a			ld a,(de)  
6e13 77			ld (hl),a  
6e14			  
6e14			; row 5  
6e14			  
6e14 78			ld a,b  
6e15			  
6e15 21 d0 fe		LD   hl, keyscan_table_row5+10  
6e18			  
6e18			;call addatohl  
6e18 cd 10 0f		call subafromhl  
6e1b			  
6e1b 11 8d fe		ld de, keyscan_scancol+4  
6e1e			  
6e1e 1a			ld a,(de)  
6e1f 77			ld (hl),a  
6e20			  
6e20			; handshake next column  
6e20			  
6e20			  
6e20 3e 40		ld a, 64  
6e22 d3 c1		out (portbdata),a  
6e24			  
6e24 3e 00		ld a, 0  
6e26 d3 c1		out (portbdata),a  
6e28			  
6e28			; toggle clk and move to next column  
6e28			;ld a, 64  
6e28			;cp c  
6e28			;  
6e28			;jr z, .coltoglow  
6e28			;ld c, a  
6e28			;jr .coltog  
6e28			;.coltoglow:  
6e28			;ld c, 0  
6e28			;.coltog:  
6e28			;ld a, c  
6e28			;out (portbdata),a  
6e28			  
6e28 10 b2		djnz .colscan  
6e2a			  
6e2a 3e 0a		ld a,10  
6e2c 21 f2 fe		LD   hl, keyscan_table_row1  
6e2f cd fe 0e		call addatohl  
6e32 3e 00		ld a, 0  
6e34 77			ld (hl), a  
6e35			  
6e35			  
6e35 3e 0a		ld a,10  
6e37 21 e7 fe		LD   hl, keyscan_table_row2  
6e3a cd fe 0e		call addatohl  
6e3d 3e 00		ld a, 0  
6e3f 77			ld (hl), a  
6e40			  
6e40 3e 0a		ld a,10  
6e42 21 dc fe		LD   hl, keyscan_table_row3  
6e45 cd fe 0e		call addatohl  
6e48 3e 00		ld a, 0  
6e4a 77			ld (hl), a  
6e4b			  
6e4b 3e 0a		ld a,10  
6e4d 21 d1 fe		LD   hl, keyscan_table_row4  
6e50 cd fe 0e		call addatohl  
6e53 3e 00		ld a, 0  
6e55 77			ld (hl), a  
6e56			  
6e56 3e 0a		ld a,10  
6e58 21 c6 fe		LD   hl, keyscan_table_row5  
6e5b cd fe 0e		call addatohl  
6e5e 3e 00		ld a, 0  
6e60 77			ld (hl), a  
6e61			  
6e61			if DEBUG_KEY_MATRIX  
6e61			  
6e61			; Display text on first line  
6e61			            LD   A, kLCD_Line1  
6e61			            CALL fLCD_Pos       ;Position cursor to location in A  
6e61			            LD   DE, keyscan_table_row1  
6e61			            ;LD   DE, MsgHello  
6e61			            CALL fLCD_Str       ;Display string pointed to by DE  
6e61			  
6e61			; Display text on second line  
6e61			            LD   A, kLCD_Line2  
6e61			            CALL fLCD_Pos       ;Position cursor to location in A  
6e61			            LD   DE, keyscan_table_row2  
6e61			            CALL fLCD_Str       ;Display string pointed to by DE  
6e61			            LD   A, kLCD_Line3  
6e61			            CALL fLCD_Pos       ;Position cursor to location in A  
6e61			            LD   DE, keyscan_table_row3  
6e61			            CALL fLCD_Str       ;Display string pointed to by DE  
6e61			            LD   A, kLCD_Line4  
6e61			            CALL fLCD_Pos       ;Position cursor to location in A  
6e61			            LD   DE, keyscan_table_row4  
6e61			            CALL fLCD_Str       ;Display string pointed to by DE  
6e61			            LD   A, kLCD_Line4+10  
6e61			            CALL fLCD_Pos       ;Position cursor to location in A  
6e61			            LD   DE, keyscan_table_row5  
6e61			            CALL fLCD_Str       ;Display string pointed to by DE  
6e61			  
6e61			;call delay250ms  
6e61				jp matrix  
6e61			endif  
6e61 c9			ret  
6e62			  
6e62			; using decade counter....  
6e62			  
6e62			  
6e62			; TODO reset decade counter to start of scan  
6e62			  
6e62			; reset 15  
6e62			; clock 14  
6e62			; ce 13  
6e62			  
6e62			; 1 - q5  
6e62			; 2 - q1  
6e62			; 3 - q0  
6e62			; 4 - q2  
6e62			; 5 - q6  
6e62			; 6 - q7  
6e62			; 7 - q3  
6e62			; 8 - vss  
6e62			; 9 - q8  
6e62			; 10 - q4  
6e62			; 11 - q9  
6e62			; 12 - cout  
6e62			; 16 - vdd  
6e62			  
6e62			; clock      ce       reset     output  
6e62			; 0          x        0         n  
6e62			; x          1        0         n  
6e62			; x          x        1         q0  
6e62			; rising     0        0         n+1  
6e62			; falling    x        0         n  
6e62			; x          rising   0         n  
6e62			; 1          falling  0         x+1  
6e62			;  
6e62			; x = dont care, if n < 5 carry = 1 otherwise 0  
6e62			  
6e62			;   
6e62			; reset   
6e62			; 13=0, 14=0, 15=1 .. 15=0  
6e62			;  
6e62			; handshake line  
6e62			; 14=1.... read line 14=0  
6e62			  
6e62			  
6e62			  
6e62			  
6e62			  
6e62			; TODO hand shake clock for next column scan  
6e62			; TODO detect each row  
6e62			  
6e62			  
6e62			  
6e62			  
6e62			; reset 128  
6e62			; clock 64  
6e62			; ce 32  
6e62			  
6e62			  
6e62			.cyclestart:  
6e62			  
6e62			; reset counter  
6e62 3e 80		ld a, 128  
6e64 d3 c1		out (portbdata),a  
6e66			  
6e66			; loop leds  
6e66 06 0a		ld b,10  
6e68			  
6e68			.cycle1:  
6e68 c5			push bc  
6e69 3e 00		ld a, 0  
6e6b d3 c1		out (portbdata),a  
6e6d cd 3b 0c		call delay250ms  
6e70			  
6e70 3e 40		ld a, 64  
6e72 d3 c1		out (portbdata),a  
6e74 cd 3b 0c		call delay250ms  
6e77			  
6e77 3e 00		ld a, 0  
6e79 d3 c1		out (portbdata),a  
6e7b cd 3b 0c		call delay250ms  
6e7e			  
6e7e c1			pop bc  
6e7f 10 e7		djnz .cycle1  
6e81			  
6e81			  
6e81 18 df		jr .cyclestart  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			; map matrix key held to char on face of key  
6e83			  
6e83			;.mtocold:  
6e83			;  
6e83			;  
6e83			;; reset counter  
6e83			;ld a, 128  
6e83			;out (portbdata),a  
6e83			;  
6e83			;  
6e83			;; scan keyboard row 1  
6e83			;ld a, 0  
6e83			;out (portbdata),a  
6e83			;;ld a, 64  
6e83			;;out (portbdata),a  
6e83			;  
6e83			;  
6e83			;	ld a, 128  
6e83			;	ld hl, keyscan_table  
6e83			;	call .rowscan  
6e83			;  
6e83			;;ld a, 0  
6e83			;;out (portbdata),a  
6e83			;ld a, 64  
6e83			;out (portbdata),a  
6e83			;  
6e83			;	ld a, 64  
6e83			;	ld hl, keyscan_table+key_cols  
6e83			;	call .rowscan  
6e83			;  
6e83			;ld a, 0  
6e83			;out (portbdata),a  
6e83			;;ld a, 64  
6e83			;;out (portbdata),a  
6e83			;	ld a, 32  
6e83			;	ld hl, keyscan_table+(key_cols*2)  
6e83			;	call .rowscan  
6e83			;  
6e83			;  
6e83			;;ld a, 0  
6e83			;;out (portbdata),a  
6e83			;ld a, 64  
6e83			;out (portbdata),a  
6e83			;  
6e83			;	ld a, 16  
6e83			;	ld hl, keyscan_table+(key_cols*3)  
6e83			;	call .rowscan  
6e83			;  
6e83			;  
6e83			;	; flag if key D is held down and remove from reporting  
6e83			;	ld bc, .key_map_fd    
6e83			;	ld hl, keyscan_table  
6e83			;	ld de, key_fd  
6e83			;	call .key_shift_hold  
6e83			;	cp 255  
6e83			;	jr z, .cinmap  
6e83			;	; flag if key C is held down and remove from reporting  
6e83			;	ld bc, .key_map_fc    
6e83			;	ld hl, keyscan_table+key_cols  
6e83			;	ld de, key_fc  
6e83			;	call .key_shift_hold  
6e83			;	cp 255  
6e83			;	jr z, .cinmap  
6e83			;	; flag if key B is held down and remove from reporting  
6e83			;	ld bc, .key_map_fb    
6e83			;	ld hl, keyscan_table+(key_cols*2)  
6e83			;	ld de, key_fb  
6e83			;	call .key_shift_hold  
6e83			;	cp 255  
6e83			;	jr z, .cinmap  
6e83			;	; flag if key A is held down and remove from reporting  
6e83			;	ld bc, .key_map_fa    
6e83			;	ld hl, keyscan_table+(key_cols*3)  
6e83			;	ld de, key_fa  
6e83			;	call .key_shift_hold  
6e83			;	cp 255  
6e83			;	jr z, .cinmap  
6e83			;  
6e83			;	ld de, .matrix_to_char  
6e83			;  
6e83			;  
6e83			;.cinmap:   
6e83			;	if DEBUG_KEY  
6e83			;            LD   A, kLCD_Line4  
6e83			;            CALL fLCD_Pos       ;Position cursor to location in A  
6e83			;		push de  
6e83			;            LD   DE, keyscan_table  
6e83			;            CALL fLCD_Str       ;Display string pointed to by DE  
6e83			;		pop de  
6e83			;	endif  
6e83			  
6e83				; scan key matrix table for any held key  
6e83			  
6e83				; de holds either the default matrix or one selected above  
6e83			  
6e83			;	ld hl, keyscan_table  
6e83			;	ld b,key_cols*key_rows  
6e83			;  
6e83			;.cin1:	ld a,(hl)  
6e83			;	cp '#'  
6e83			;	jr z, .cinhit  
6e83			;	inc hl  
6e83			;	inc de  
6e83			;	dec b  
6e83			;	jr nz, .cin1  
6e83			;	; no key found held  
6e83			;	ld a,0  
6e83			;	ret  
6e83			;.cinhit: push de  
6e83			;	pop hl  
6e83			;	ld a,(hl)  
6e83			;	ret  
6e83			  
6e83			; flag a control key is held   
6e83			; hl is key pin, de is flag indicator  
6e83			  
6e83			;.key_shift_hold:  
6e83			;	push bc  
6e83			;	ld a, 1  
6e83			;	ld (cursor_shape),a  
6e83			;	ld b, 0  
6e83			;	ld a, (hl)  
6e83			;	cp '.'  
6e83			;	jr z, .key_shift1  
6e83			;	ld b, 255  
6e83			;	ld a, '+'    ; hide key from later scans  
6e83			;	ld (hl),a  
6e83			;	ld a, 2  
6e83			;	ld (cursor_shape),a  
6e83			;.key_shift1:  
6e83			;	; write flag indicator  
6e83			;	ld a,b  
6e83			;	ld (de),a  
6e83			;  
6e83			;	pop de    ; de now holds the key map ptr  
6e83			;	ret  
6e83			  
6e83				  
6e83				  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			;	push hl  
6e83			;	push de  
6e83			;	push bc  
6e83			;	call keyscan  
6e83			;	; map key matrix to ascii value of key face  
6e83			;  
6e83			;	ld hl, key_face_map  
6e83			;	ld de, keyscan_table  
6e83			;  
6e83			;	; get how many keys to look at  
6e83			;	ld b, keyscan_table_len  
6e83			;	  
6e83			;  
6e83			;	; at this stage fall out on first key hit  
6e83			;	; TODO handle multiple key press  
6e83			;  
6e83			;map1:	ld a,(hl)  
6e83			;	cp '#'  
6e83			;	jr z, keyhit  
6e83			;	inc hl  
6e83			;	inc de  
6e83			;	dec b  
6e83			;	jr nz, map1  
6e83			;nohit:	ld a, 0  
6e83			;	jr keydone  
6e83			;keyhit: push de  
6e83			;	pop hl  
6e83			;	ld a,(hl)  
6e83			;keydone:  
6e83			;	push bc  
6e83			;	push de  
6e83			; 	push hl  
6e83			;	ret   
6e83			;  
6e83			  
6e83			  
6e83			  
6e83			  
6e83			; scan physical key matrix  
6e83			  
6e83			  
6e83			;keyscan:  
6e83			;  
6e83			;; for each key_row use keyscanr bit mask for out  
6e83			;; then read in for keyscanc bitmask  
6e83			;; save result of row scan to keyscantable  
6e83			;  
6e83			;; scan keyboard row 1  
6e83			;  
6e83			;	ld b, key_rows  
6e83			;	ld hl, key_scanr  
6e83			;	ld de, keyscan_table  
6e83			;  
6e83			;rowloop:  
6e83			;  
6e83			;	ld a,(hl)		; out bit mask to energise keyboard row  
6e83			;	call rowscan  
6e83			;	inc hl  
6e83			;	dec b  
6e83			;	jr nz, rowloop  
6e83			;  
6e83			;	ret  
6e83			;  
6e83			;  
6e83			;; pass a out bitmask, b row number  
6e83			;arowscan:   
6e83			;	push bc  
6e83			;  
6e83			;	ld d, b  
6e83			;  
6e83			;	; calculate buffer location for this row  
6e83			;  
6e83			;	ld hl, keyscan_table	  
6e83			;kbufr:  ld e, key_cols  
6e83			;kbufc:	inc hl  
6e83			;	dec e  
6e83			;	jr nz, kbufc  
6e83			;	dec d  
6e83			;	jr nz, kbufr  
6e83			;  
6e83			;	; energise row and read columns  
6e83			;  
6e83			;	out (portbdata),a  
6e83			;	in a,(portbdata)  
6e83			;	ld c,a  
6e83			;  
6e83			;  
6e83			;	; save buffer loc  
6e83			;  
6e83			;	ld (keybufptr), hl  
6e83			;  
6e83			;	ld hl, key_scanc  
6e83			;	ld d, key_cols  
6e83			;  
6e83			;	; for each column check each bit mask  
6e83			;  
6e83			;colloop:  
6e83			;	  
6e83			;  
6e83			;	; reset flags for the row   
6e83			;  
6e83			;	ld b,'.'  
6e83			;	and (hl)  
6e83			;	jr z, maskskip  
6e83			;	ld b,'#'  
6e83			;maskskip:  
6e83			;	; save  key state  
6e83			;	push hl  
6e83			;	ld hl, (keybufptr)  
6e83			;	ld (hl), b  
6e83			;	inc hl  
6e83			;	ld (keybufptr), hl  
6e83			;  
6e83			;	; move to next bit mask  
6e83			;	pop hl  
6e83			;	inc hl  
6e83			;  
6e83			;	dec d  
6e83			;	jr nz, colloop  
6e83			;  
6e83			;	ret  
6e83			;  
6e83			;  
6e83			;;  
6e83			; lcd functions  
6e83			;  
6e83			;  
6e83			  
6e83			;if DEBUG_KEY_MATRIX  
6e83			  
6e83			; test function to display hardware view of matrix state  
6e83			  
6e83			matrixold:  
6e83			  
6e83			  
6e83			  
6e83			; reset counter  
6e83 3e 80		ld a, 128  
6e85 d3 c1		out (portbdata),a  
6e87			; scan keyboard row 1  
6e87 3e 00		ld a, 0  
6e89 d3 c1		out (portbdata),a  
6e8b			;ld a, 64  
6e8b			;out (portbdata),a  
6e8b 3e 80			ld a, 128  
6e8d 21 f2 fe			ld hl, keyscan_table_row1  
6e90 cd e9 6e			call .rowscan  
6e93			  
6e93			;ld a, 0  
6e93			;out (portbdata),a  
6e93 3e 40		ld a, 64  
6e95 d3 c1		out (portbdata),a  
6e97 3e 40			ld a, 64  
6e99 21 e7 fe			ld hl, keyscan_table_row2  
6e9c cd e9 6e			call .rowscan  
6e9f			  
6e9f 3e 00		ld a, 0  
6ea1 d3 c1		out (portbdata),a  
6ea3			;ld a, 64  
6ea3			;out (portbdata),a  
6ea3 3e 20			ld a, 32  
6ea5 21 dc fe			ld hl, keyscan_table_row3  
6ea8 cd e9 6e			call .rowscan  
6eab			  
6eab			;ld a, 0  
6eab			;out (portbdata),a  
6eab 3e 40		ld a, 64  
6ead d3 c1		out (portbdata),a  
6eaf 3e 10			ld a, 16  
6eb1 21 d1 fe			ld hl, keyscan_table_row4  
6eb4 cd e9 6e			call .rowscan  
6eb7			  
6eb7			; Display text on first line  
6eb7 3e 00		            LD   A, kLCD_Line1  
6eb9 cd f1 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6ebc 11 f2 fe		            LD   DE, keyscan_table_row1  
6ebf			            ;LD   DE, MsgHello  
6ebf cd 13 6b		            CALL fLCD_Str       ;Display string pointed to by DE  
6ec2			  
6ec2			; Display text on second line  
6ec2 3e 28		            LD   A, kLCD_Line2  
6ec4 cd f1 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6ec7 11 e7 fe		            LD   DE, keyscan_table_row2  
6eca cd 13 6b		            CALL fLCD_Str       ;Display string pointed to by DE  
6ecd 3e 50		            LD   A, kLCD_Line3  
6ecf cd f1 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6ed2 11 dc fe		            LD   DE, keyscan_table_row3  
6ed5 cd 13 6b		            CALL fLCD_Str       ;Display string pointed to by DE  
6ed8 3e 78		            LD   A, kLCD_Line4  
6eda cd f1 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6edd 11 d1 fe		            LD   DE, keyscan_table_row4  
6ee0 cd 13 6b		            CALL fLCD_Str       ;Display string pointed to by DE  
6ee3			  
6ee3 cd 3b 0c			call delay250ms  
6ee6 c3 d4 6d			jp matrix  
6ee9			  
6ee9			; pass de as row display flags  
6ee9			.rowscan:   
6ee9			;	out (portbdata),a  
6ee9 db c1			in a,(portbdata)  
6eeb 4f				ld c,a  
6eec				; reset flags for the row   
6eec 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6eee e6 01			and 1  
6ef0 28 02			jr z, .p1on  
6ef2 06 23			ld b,'#'  
6ef4			.p1on:  
6ef4 70				ld (hl), b  
6ef5 23				inc hl  
6ef6			  
6ef6 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6ef8 79				ld a,c  
6ef9 e6 02			and 2  
6efb			;	bit 0,a  
6efb 28 02			jr z, .p2on  
6efd 06 23			ld b,'#'  
6eff			.p2on:  
6eff 70				ld (hl), b  
6f00 23				inc hl  
6f01			;  
6f01 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6f03 79				ld a,c  
6f04 e6 04			and 4  
6f06			;;	bit 0,a  
6f06 28 02			jr z, .p3on  
6f08 06 23			ld b,'#'  
6f0a			.p3on:  
6f0a 70				ld (hl), b  
6f0b 23				inc hl  
6f0c			;;  
6f0c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6f0e			;;	bit 0,a  
6f0e 79				ld a,c  
6f0f e6 08			and 8  
6f11 28 02			jr z, .p4on  
6f13 06 23			ld b,'#'  
6f15			.p4on:  
6f15 70				ld (hl), b  
6f16 23				inc hl  
6f17			  
6f17 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6f19			;;	bit 0,a  
6f19 79				ld a,c  
6f1a e6 10			and 16  
6f1c 28 02			jr z, .p5on  
6f1e 06 23			ld b,'#'  
6f20			.p5on:  
6f20 70				ld (hl), b  
6f21 23				inc hl  
6f22			; zero term  
6f22 06 00			ld b,0  
6f24 70				ld (hl), b  
6f25			  
6f25 c9			.rscandone: ret  
6f26			  
6f26			;addatohl:  
6f26			;  
6f26			 ;add   a, l    ; A = A+L  
6f26			  ;  ld    l, a    ; L = A+L  
6f26			   ; adc   a, h    ; A = A+L+H+carry  
6f26			   ; sub   l       ; A = H+carry  
6f26			   ; ld    h, a    ; H = H+carry  
6f26			  
6f26			;ret  
6f26			; eof  
# End of file firmware_key_5x10.asm
6f26			;include "firmware_key_4x10.asm" 
6f26			 
6f26			heap_size:    equ heap_end - heap_start 
6f26			;eof 
# End of file os_mega.asm
6f26
