# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 0e 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 0  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_write_tmp-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 16 ed				ld hl, display_fb1  
801f 22 d2 eb				ld (display_fb_active), hl  
8022			  
8022 cd 3d 8a				call clear_display  
8025			  
8025 21 d4 eb				ld hl, display_fb2  
8028 22 d2 eb				ld (display_fb_active), hl  
802b			  
802b cd 3d 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b7 ed				ld hl, display_fb0  
8031 22 d2 eb				ld (display_fb_active), hl  
8034			  
8034 cd 3d 8a				call clear_display  
8037			  
8037			  
8037 cd 9b d9				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 3d da			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 0d 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd 60 8a			call update_display  
8046 cd ba 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd 42 8a			call fill_display  
804e cd 60 8a			call update_display  
8051 cd ba 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd 42 8a			call fill_display  
8059 cd 60 8a			call update_display  
805c cd ba 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd 42 8a			call fill_display  
8064 cd 60 8a			call update_display  
8067 cd ba 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 41 96			ld de, prom_bootmsg  
806f cd 50 8a			call str_at_display  
8072 cd 60 8a			call update_display  
8075			  
8075			  
8075 cd ba 89			call delay1s  
8078 cd ba 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 56 96			ld de, prom_bootmsg1  
8080 cd 50 8a			call str_at_display  
8083 cd 60 8a			call update_display  
8086 cd ba 89			call delay1s  
8089 cd ba 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 71 ee		ld (debug_mark),a  
8091 32 72 ee		ld (debug_mark+1),a  
8094 32 73 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 74 ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 7d ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 71 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 72 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 73 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd 6b 94			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 84 ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 71 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 72 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 73 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd 6b 94			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 84 ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 71 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 72 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 73 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd 6b 94			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd 93 8c				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 7d ea				ld hl, (store_tmp1) 
8110 11 87 ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 71 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 72 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 73 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd 6b 94			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 00 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 71 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 72 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 73 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd 6b 94			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 71 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 72 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 73 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd 6b 94			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 71 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 72 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 73 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd 6b 94			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 71 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 72 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 73 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd 6b 94			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd 93 8c			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 84 ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 71 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 72 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 73 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd 6b 94			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 71 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 72 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 73 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd 6b 94			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 84 ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 71 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 72 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 73 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 84 ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd 6b 94			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 85 ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 71 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 72 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 73 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd 6b 94			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 71 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 72 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 73 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd 6b 94			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd 7d 89			call storage_clear_page 
829b			 
829b 21 84 ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 85 ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 87 ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 90 ea			ld hl, store_page+3+9 
82b5 3a 6c ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 84 ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 71 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 72 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 73 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd 6b 94			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 71 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 72 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 73 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd 6b 94			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd 9f 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd 9f 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd 6a 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd 9f 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd 9f 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd 6a 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 71 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 72 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 73 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd 6b 94			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 87 ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 71 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 72 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 73 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd 6b 94			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 84 ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 71 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 72 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 73 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd 6b 94			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 71 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 72 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 73 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd 6b 94			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd 93 8c			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 84 ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd 93 8c			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 71 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 72 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 73 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd 6b 94			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 84 ea			ld a, (store_page)	; get file id 
8410 32 78 ea			ld (store_tmpid), a 
8413			 
8413 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
8416 32 77 ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 84 ea			ld (store_page), a 
841f 32 85 ea			ld (store_page+1),a 
8422 11 84 ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 71 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 72 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 73 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd 6b 94			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 77 ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 78 ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 71 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 72 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 73 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd 6b 94			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd 93 8c			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 84 ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 84 ea			ld (store_page), a 
8482 32 85 ea			ld (store_page+1),a 
8485 11 84 ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 71 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 72 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 73 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd 6b 94			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 71 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 72 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 73 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd 6b 94			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd 88 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd 6a 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd 88 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd 6a 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 71 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 72 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 73 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd 6b 94			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 71 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 72 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 73 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd 6b 94			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd 6a 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd 6a 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 71 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 72 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 73 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd 6b 94			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 84 ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 84 ea			ld (store_page),a 
85a3				 
85a3 32 78 ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 84 ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 71 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 72 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 73 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd 6b 94			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 84 ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 71 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 72 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 73 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 6b 94			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 71 ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 71 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 72 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 73 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd 6b 94			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 71 ea			ld (store_tmppageid), hl 
8615				 
8615 3a 78 ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 84 ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 85 ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 86 ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 71 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 72 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 73 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd 6b 94			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd d3 90			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 71 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 72 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 73 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd 6b 94			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 71 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 72 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 73 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd 6b 94			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 71 ea			ld hl,(store_tmppageid) 
868b 11 84 ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 71 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 72 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 73 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd 6b 94			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 78 ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 71 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 72 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 73 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd 6b 94			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 71 ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 72 ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 73 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd 6b 94			call break_point_state  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 71 ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 72 ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 73 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd 6b 94			call break_point_state  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd 93 8c			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; hl contains page number to load 
871f d1				pop de   ; get storage 
8720 d5				push de 
8721				if DEBUG_STORESE 
8721					DMARK "srg" 
8721 f5				push af  
8722 3a 36 87			ld a, (.dmark)  
8725 32 71 ee			ld (debug_mark),a  
8728 3a 37 87			ld a, (.dmark+1)  
872b 32 72 ee			ld (debug_mark+1),a  
872e 3a 38 87			ld a, (.dmark+2)  
8731 32 73 ee			ld (debug_mark+2),a  
8734 18 03			jr .pastdmark  
8736 ..			.dmark: db "srg"  
8739 f1			.pastdmark: pop af  
873a			endm  
# End of macro DMARK
873a					CALLMONITOR 
873a cd 6b 94			call break_point_state  
873d				endm  
# End of macro CALLMONITOR
873d				endif 
873d cd 79 81			call storage_read_block 
8740			 
8740			 
8740				; only short reads enabled 
8740			 
8740 3a 7f ea			ld a, (store_longread) 
8743 fe 00			cp 0 
8745 ca 0f 88			jp z, .readdone 
8748			 
8748			; TODO if block has no zeros then need to read next block  
8748			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
8748			; check last byte of physical block. 
8748			; if not zero then the next block needs to be loaded 
8748			 
8748			 
8748 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874b			 
874b 3e 3f			ld a, STORE_BLOCK_PHY-1 
874d cd 6a 8c			call addatohl 
8750				;dec hl 
8750 7e				ld a,(hl) 
8751				if DEBUG_STORESE 
8751					DMARK "sr?" 
8751 f5				push af  
8752 3a 66 87			ld a, (.dmark)  
8755 32 71 ee			ld (debug_mark),a  
8758 3a 67 87			ld a, (.dmark+1)  
875b 32 72 ee			ld (debug_mark+1),a  
875e 3a 68 87			ld a, (.dmark+2)  
8761 32 73 ee			ld (debug_mark+2),a  
8764 18 03			jr .pastdmark  
8766 ..			.dmark: db "sr?"  
8769 f1			.pastdmark: pop af  
876a			endm  
# End of macro DMARK
876a					CALLMONITOR 
876a cd 6b 94			call break_point_state  
876d				endm  
# End of macro CALLMONITOR
876d				endif 
876d fe 00			cp 0 
876f ca 0f 88			jp z, .readdone 
8772			 
8772				; last byte is not zero so there is more in the next extent. Load it on the end.	 
8772			 
8772 23				inc hl 
8773			 
8773 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
8776			 
8776 ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
877a			 
877a eb				ex de, hl 
877b			 
877b				; next ext 
877b			 
877b 23				inc hl 
877c 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
877f			 
877f				if DEBUG_STORESE 
877f					DMARK "sF2" 
877f f5				push af  
8780 3a 94 87			ld a, (.dmark)  
8783 32 71 ee			ld (debug_mark),a  
8786 3a 95 87			ld a, (.dmark+1)  
8789 32 72 ee			ld (debug_mark+1),a  
878c 3a 96 87			ld a, (.dmark+2)  
878f 32 73 ee			ld (debug_mark+2),a  
8792 18 03			jr .pastdmark  
8794 ..			.dmark: db "sF2"  
8797 f1			.pastdmark: pop af  
8798			endm  
# End of macro DMARK
8798					CALLMONITOR 
8798 cd 6b 94			call break_point_state  
879b				endm  
# End of macro CALLMONITOR
879b				endif 
879b			 
879b				; get and load block 
879b			 
879b cd ac 84			call storage_findnextid 
879e			 
879e				if DEBUG_STORESE 
879e					DMARK "sf2" 
879e f5				push af  
879f 3a b3 87			ld a, (.dmark)  
87a2 32 71 ee			ld (debug_mark),a  
87a5 3a b4 87			ld a, (.dmark+1)  
87a8 32 72 ee			ld (debug_mark+1),a  
87ab 3a b5 87			ld a, (.dmark+2)  
87ae 32 73 ee			ld (debug_mark+2),a  
87b1 18 03			jr .pastdmark  
87b3 ..			.dmark: db "sf2"  
87b6 f1			.pastdmark: pop af  
87b7			endm  
# End of macro DMARK
87b7					CALLMONITOR 
87b7 cd 6b 94			call break_point_state  
87ba				endm  
# End of macro CALLMONITOR
87ba				endif 
87ba cd 93 8c			call ishlzero 
87bd			;	ld a, l 
87bd			;	add h 
87bd			;	cp 0 
87bd ca d0 86			jp z,.sr_fail			; block not found so EOF 
87c0				 
87c0 cd 79 81			call storage_read_block 
87c3			 
87c3				; on a continuation block, we now have the file id and ext in the middle of the block 
87c3				; we need to pull everything back  
87c3			 
87c3 ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87c7 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
87ca 23				inc hl 
87cb 23				inc hl     ; skip id and ext 
87cc 01 40 00			ld bc, STORE_BLOCK_PHY 
87cf				if DEBUG_STORESE 
87cf					DMARK "SR<" 
87cf f5				push af  
87d0 3a e4 87			ld a, (.dmark)  
87d3 32 71 ee			ld (debug_mark),a  
87d6 3a e5 87			ld a, (.dmark+1)  
87d9 32 72 ee			ld (debug_mark+1),a  
87dc 3a e6 87			ld a, (.dmark+2)  
87df 32 73 ee			ld (debug_mark+2),a  
87e2 18 03			jr .pastdmark  
87e4 ..			.dmark: db "SR<"  
87e7 f1			.pastdmark: pop af  
87e8			endm  
# End of macro DMARK
87e8					CALLMONITOR 
87e8 cd 6b 94			call break_point_state  
87eb				endm  
# End of macro CALLMONITOR
87eb				endif 
87eb ed b0			ldir     ; copy data 
87ed			 
87ed				; move the pointer back and pretend we have a full buffer for next recheck 
87ed			 
87ed 1b				dec de 
87ee 1b				dec de 
87ef			 
87ef			; TODO do pop below now short circuit loop????? 
87ef c1				pop bc     ; get rid of spare de on stack 
87f0				if DEBUG_STORESE 
87f0					DMARK "SR>" 
87f0 f5				push af  
87f1 3a 05 88			ld a, (.dmark)  
87f4 32 71 ee			ld (debug_mark),a  
87f7 3a 06 88			ld a, (.dmark+1)  
87fa 32 72 ee			ld (debug_mark+1),a  
87fd 3a 07 88			ld a, (.dmark+2)  
8800 32 73 ee			ld (debug_mark+2),a  
8803 18 03			jr .pastdmark  
8805 ..			.dmark: db "SR>"  
8808 f1			.pastdmark: pop af  
8809			endm  
# End of macro DMARK
8809					CALLMONITOR 
8809 cd 6b 94			call break_point_state  
880c				endm  
# End of macro CALLMONITOR
880c				endif 
880c c3 d5 86			jp .srext 
880f			 
880f			 
880f			 
880f			 
880f			 
880f			.readdone:		 
880f e1				pop hl 		 ; return start of data to show as not EOF 
8810 23				inc hl   ; past file id 
8811 23				inc hl   ; past ext 
8812				if DEBUG_STORESE 
8812					DMARK "SRe" 
8812 f5				push af  
8813 3a 27 88			ld a, (.dmark)  
8816 32 71 ee			ld (debug_mark),a  
8819 3a 28 88			ld a, (.dmark+1)  
881c 32 72 ee			ld (debug_mark+1),a  
881f 3a 29 88			ld a, (.dmark+2)  
8822 32 73 ee			ld (debug_mark+2),a  
8825 18 03			jr .pastdmark  
8827 ..			.dmark: db "SRe"  
882a f1			.pastdmark: pop af  
882b			endm  
# End of macro DMARK
882b					CALLMONITOR 
882b cd 6b 94			call break_point_state  
882e				endm  
# End of macro CALLMONITOR
882e				endif 
882e c9					ret 
882f			 
882f			 
882f			 
882f			; 
882f			; Append File 
882f			; 
882f			; hl - file id to locate 
882f			; de - pointer to (multi block) string to write 
882f			 
882f			.sa_notfound: 
882f d1				pop de 
8830 c9				ret 
8831			 
8831			 
8831			storage_append: 
8831				; hl -  file id to append to 
8831				; de - string to append 
8831			 
8831 d5				push de 
8832				 
8832				if DEBUG_STORESE 
8832					DMARK "AP1" 
8832 f5				push af  
8833 3a 47 88			ld a, (.dmark)  
8836 32 71 ee			ld (debug_mark),a  
8839 3a 48 88			ld a, (.dmark+1)  
883c 32 72 ee			ld (debug_mark+1),a  
883f 3a 49 88			ld a, (.dmark+2)  
8842 32 73 ee			ld (debug_mark+2),a  
8845 18 03			jr .pastdmark  
8847 ..			.dmark: db "AP1"  
884a f1			.pastdmark: pop af  
884b			endm  
# End of macro DMARK
884b					CALLMONITOR 
884b cd 6b 94			call break_point_state  
884e				endm  
# End of macro CALLMONITOR
884e				endif 
884e			 
884e 7d				ld a, l 
884f 32 78 ea			ld (store_tmpid), a 
8852			 
8852				; get file header  
8852			 
8852 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
8854 3a 78 ea			ld a, (store_tmpid) 
8857 5f				ld e, a 
8858			 
8858 21 40 00				ld hl, STORE_BLOCK_PHY 
885b cd ac 84				call storage_findnextid 
885e			 
885e cd 93 8c			call ishlzero 
8861 28 cc			jr z, .sa_notfound 
8863			 
8863 22 71 ea			ld (store_tmppageid), hl 
8866			 
8866				; TODO handle file id not found 
8866			 
8866				if DEBUG_STORESE 
8866					DMARK "AP2" 
8866 f5				push af  
8867 3a 7b 88			ld a, (.dmark)  
886a 32 71 ee			ld (debug_mark),a  
886d 3a 7c 88			ld a, (.dmark+1)  
8870 32 72 ee			ld (debug_mark+1),a  
8873 3a 7d 88			ld a, (.dmark+2)  
8876 32 73 ee			ld (debug_mark+2),a  
8879 18 03			jr .pastdmark  
887b ..			.dmark: db "AP2"  
887e f1			.pastdmark: pop af  
887f			endm  
# End of macro DMARK
887f					CALLMONITOR 
887f cd 6b 94			call break_point_state  
8882				endm  
# End of macro CALLMONITOR
8882				endif 
8882			 
8882				; update file extent count 
8882			 
8882 11 84 ea			ld de, store_page 
8885			 
8885 cd 79 81			call storage_read_block 
8888			 
8888				if DEBUG_STORESE 
8888					DMARK "AP3" 
8888 f5				push af  
8889 3a 9d 88			ld a, (.dmark)  
888c 32 71 ee			ld (debug_mark),a  
888f 3a 9e 88			ld a, (.dmark+1)  
8892 32 72 ee			ld (debug_mark+1),a  
8895 3a 9f 88			ld a, (.dmark+2)  
8898 32 73 ee			ld (debug_mark+2),a  
889b 18 03			jr .pastdmark  
889d ..			.dmark: db "AP3"  
88a0 f1			.pastdmark: pop af  
88a1			endm  
# End of macro DMARK
88a1					CALLMONITOR 
88a1 cd 6b 94			call break_point_state  
88a4				endm  
# End of macro CALLMONITOR
88a4				endif 
88a4			;	ld (store_tmppageid), hl 
88a4			 
88a4 3a 86 ea			ld a, (store_page+2) 
88a7 3c				inc a 
88a8 32 86 ea			ld (store_page+2), a 
88ab 32 77 ea			ld (store_tmpext), a 
88ae				 
88ae				if DEBUG_STORESE 
88ae					DMARK "AP3" 
88ae f5				push af  
88af 3a c3 88			ld a, (.dmark)  
88b2 32 71 ee			ld (debug_mark),a  
88b5 3a c4 88			ld a, (.dmark+1)  
88b8 32 72 ee			ld (debug_mark+1),a  
88bb 3a c5 88			ld a, (.dmark+2)  
88be 32 73 ee			ld (debug_mark+2),a  
88c1 18 03			jr .pastdmark  
88c3 ..			.dmark: db "AP3"  
88c6 f1			.pastdmark: pop af  
88c7			endm  
# End of macro DMARK
88c7					CALLMONITOR 
88c7 cd 6b 94			call break_point_state  
88ca				endm  
# End of macro CALLMONITOR
88ca				endif 
88ca 2a 71 ea			ld hl, (store_tmppageid) 
88cd 11 84 ea			ld de, store_page 
88d0 cd de 81			call storage_write_block 
88d3			 
88d3				; find free block 
88d3			 
88d3 11 00 00			ld de, 0			 ; file extent to locate 
88d6			 
88d6 21 40 00				ld hl, STORE_BLOCK_PHY 
88d9 cd ac 84				call storage_findnextid 
88dc cd 93 8c			call ishlzero 
88df ca 2f 88			jp z, .sa_notfound 
88e2			 
88e2					; TODO handle no space left 
88e2					 
88e2 22 71 ea				ld (store_tmppageid), hl 
88e5			 
88e5				if DEBUG_STORESE 
88e5					DMARK "AP4" 
88e5 f5				push af  
88e6 3a fa 88			ld a, (.dmark)  
88e9 32 71 ee			ld (debug_mark),a  
88ec 3a fb 88			ld a, (.dmark+1)  
88ef 32 72 ee			ld (debug_mark+1),a  
88f2 3a fc 88			ld a, (.dmark+2)  
88f5 32 73 ee			ld (debug_mark+2),a  
88f8 18 03			jr .pastdmark  
88fa ..			.dmark: db "AP4"  
88fd f1			.pastdmark: pop af  
88fe			endm  
# End of macro DMARK
88fe					CALLMONITOR 
88fe cd 6b 94			call break_point_state  
8901				endm  
# End of macro CALLMONITOR
8901				endif 
8901					; init the buffer with zeros so we can id if the buffer is full or not 
8901			 
8901 e5					push hl 
8902 c5					push bc 
8903			 
8903 21 84 ea				ld hl, store_page 
8906 06 40				ld b, STORE_BLOCK_PHY 
8908 3e 00				ld a, 0 
890a 77			.zeroblock:	ld (hl), a 
890b 23					inc hl 
890c 10 fc				djnz .zeroblock 
890e			 
890e c1					pop bc 
890f e1					pop hl 
8910			 
8910					; construct block 
8910			 
8910 3a 78 ea				ld a, (store_tmpid) 
8913 32 84 ea				ld (store_page), a   ; file id 
8916 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
8919 32 85 ea				ld (store_page+1), a 
891c			 
891c e1					pop hl    ; get string to write 
891d 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
891f 11 86 ea				ld de, store_page+2 
8922			 
8922				if DEBUG_STORESE 
8922					DMARK "AP5" 
8922 f5				push af  
8923 3a 37 89			ld a, (.dmark)  
8926 32 71 ee			ld (debug_mark),a  
8929 3a 38 89			ld a, (.dmark+1)  
892c 32 72 ee			ld (debug_mark+1),a  
892f 3a 39 89			ld a, (.dmark+2)  
8932 32 73 ee			ld (debug_mark+2),a  
8935 18 03			jr .pastdmark  
8937 ..			.dmark: db "AP5"  
893a f1			.pastdmark: pop af  
893b			endm  
# End of macro DMARK
893b					CALLMONITOR 
893b cd 6b 94			call break_point_state  
893e				endm  
# End of macro CALLMONITOR
893e				endif 
893e			 
893e			 
893e			 
893e					; fill buffer with data until end of string or full block 
893e			 
893e 7e			.appd:		ld a, (hl) 
893f 12					ld (de), a 
8940 fe 00				cp 0 
8942 28 04				jr z, .appdone 
8944 23					inc hl 
8945 13					inc de 
8946 10 f6				djnz .appd 
8948			 
8948 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8949 f5					push af   		; save last byte dumped 
894a			 
894a			 
894a 2a 71 ea			ld hl, (store_tmppageid) 
894d 11 84 ea			ld de, store_page 
8950				if DEBUG_STORESE 
8950					DMARK "AP6" 
8950 f5				push af  
8951 3a 65 89			ld a, (.dmark)  
8954 32 71 ee			ld (debug_mark),a  
8957 3a 66 89			ld a, (.dmark+1)  
895a 32 72 ee			ld (debug_mark+1),a  
895d 3a 67 89			ld a, (.dmark+2)  
8960 32 73 ee			ld (debug_mark+2),a  
8963 18 03			jr .pastdmark  
8965 ..			.dmark: db "AP6"  
8968 f1			.pastdmark: pop af  
8969			endm  
# End of macro DMARK
8969					CALLMONITOR 
8969 cd 6b 94			call break_point_state  
896c				endm  
# End of macro CALLMONITOR
896c				endif 
896c cd de 81				call storage_write_block 
896f			 
896f			 
896f				; was that a full block of data written? 
896f				; any more to write out? 
896f			 
896f				; if yes then set vars and jump to start of function again 
896f			 
896f f1					pop af 
8970 d1					pop de 
8971			 
8971 fe 00				cp 0		 ; no, string was fully written 
8973 c8					ret z 
8974			 
8974					; setup vars for next cycle 
8974			 
8974 3a 78 ea				ld a, (store_tmpid) 
8977 6f					ld l, a 
8978 26 00				ld h, 0 
897a			 
897a c3 31 88			 	jp storage_append	 ; yes, need to write out some more 
897d			 
897d			 
897d			 
897d			 
897d			 
897d			 
897d			 
897d			if DEBUG_STORECF 
897d			storageput:	 
897d					ret 
897d			storageread: 
897d					ld hl, store_page 
897d					ld b, 200 
897d					ld a,0 
897d			.src:		ld (hl),a 
897d					inc hl 
897d					djnz .src 
897d					 
897d			 
897d					ld de, 0 
897d					ld bc, 1 
897d					ld hl, store_page 
897d					call cfRead 
897d			 
897d				call cfGetError 
897d				ld hl,scratch 
897d				call hexout 
897d				ld hl, scratch+2 
897d				ld a, 0 
897d				ld (hl),a 
897d				ld de, scratch 
897d				ld a,display_row_1 
897d				call str_at_display 
897d				call update_display 
897d			 
897d					ld hl, store_page 
897d					ld (os_cur_ptr),hl 
897d			 
897d					ret 
897d			endif 
897d			 
897d			 
897d			; Clear out the main buffer store (used to remove junk before writing a new block) 
897d			 
897d			storage_clear_page: 
897d e5				push hl 
897e d5				push de 
897f c5				push bc 
8980 21 84 ea			ld hl, store_page 
8983 3e 00			ld a, 0 
8985 77				ld (hl), a 
8986			 
8986 11 85 ea			ld de, store_page+1 
8989 01 18 01			ld bc, STORE_BLOCK_LOG 
898c			 
898c ed b0			ldir 
898e				 
898e c1				pop bc 
898f d1				pop de 
8990 e1				pop hl 
8991 c9				ret 
8992			 
8992			; eof 
# End of file firmware_storage.asm
8992			  
8992			; support routines for above hardware abstraction layer  
8992			  
8992			include "firmware_general.asm"        ; general support functions  
8992			 
8992			; word look up 
8992			 
8992			; in 
8992			; a is the index 
8992			; hl is pointer start of array 
8992			; 
8992			; returns 
8992			; hl to the word 
8992			; 
8992			 
8992			table_lookup:  
8992 d5					push de 
8993 eb					ex de, hl 
8994			 
8994 6f					ld l, a 
8995 26 00				ld h, 0 
8997 29					add hl, hl 
8998 19					add hl, de 
8999 7e					ld a, (hl) 
899a 23					inc hl 
899b 66					ld h,(hl) 
899c 6f					ld l, a 
899d			 
899d d1					pop de 
899e c9					ret 
899f			 
899f			; Delay loops 
899f			 
899f			 
899f			 
899f			aDelayInMS: 
899f c5				push bc 
89a0 47				ld b,a 
89a1			msdelay: 
89a1 c5				push bc 
89a2				 
89a2			 
89a2 01 41 00			ld bc,041h 
89a5 cd bd 89			call delayloop 
89a8 c1				pop bc 
89a9 05				dec b 
89aa 20 f5			jr nz,msdelay 
89ac			 
89ac			;if CPU_CLOCK_8MHZ 
89ac			;msdelay8: 
89ac			;	push bc 
89ac			;	 
89ac			; 
89ac			;	ld bc,041h 
89ac			;	call delayloop 
89ac			;	pop bc 
89ac			;	dec b 
89ac			;	jr nz,msdelay8 
89ac			;endif 
89ac			 
89ac			 
89ac c1				pop bc 
89ad c9				ret 
89ae			 
89ae			 
89ae			delay250ms: 
89ae				;push de 
89ae 01 00 40			ld bc, 04000h 
89b1 c3 bd 89			jp delayloop 
89b4			delay500ms: 
89b4				;push de 
89b4 01 00 80			ld bc, 08000h 
89b7 c3 bd 89			jp delayloop 
89ba			delay1s: 
89ba				;push bc 
89ba			   ; Clobbers A, d and e 
89ba 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89bd			delayloop: 
89bd c5			    push bc 
89be			 
89be			if BASE_CPM 
89be				ld bc, CPM_DELAY_TUNE 
89be			.cpmloop: 
89be				push bc 
89be			 
89be			endif 
89be			 
89be			 
89be			 
89be			delayloopi: 
89be			;	push bc 
89be			;.dl: 
89be cb 47		    bit     0,a    	; 8 
89c0 cb 47		    bit     0,a    	; 8 
89c2 cb 47		    bit     0,a    	; 8 
89c4 e6 ff		    and     255  	; 7 
89c6 0b			    dec     bc      	; 6 
89c7 79			    ld      a,c     	; 4 
89c8 b0			    or      b     	; 4 
89c9 c2 be 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
89cc			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
89cc				;pop de 
89cc			;pop bc 
89cc			 
89cc			if BASE_CPM 
89cc				pop bc 
89cc				 
89cc			    dec     bc      	; 6 
89cc			    ld      a,c     	; 4 
89cc			    or      b     	; 4 
89cc			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
89cc				 
89cc			 
89cc			endif 
89cc			;if CPU_CLOCK_8MHZ 
89cc			;    pop bc 
89cc			;    push bc 
89cc			;.dl8: 
89cc			;    bit     0,a    	; 8 
89cc			;    bit     0,a    	; 8 
89cc			;    bit     0,a    	; 8 
89cc			;    and     255  	; 7 
89cc			;    dec     bc      	; 6 
89cc			;    ld      a,c     	; 4 
89cc			;    or      b     	; 4 
89cc			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
89cc			;endif 
89cc			 
89cc			;if CPU_CLOCK_10MHZ 
89cc			;    pop bc 
89cc			;    push bc 
89cc			;.dl8: 
89cc			;    bit     0,a    	; 8 
89cc			;    bit     0,a    	; 8 
89cc			;    bit     0,a    	; 8 
89cc			;    and     255  	; 7 
89cc			;    dec     bc      	; 6 
89cc			;    ld      a,c     	; 4 
89cc			;    or      b     	; 4 
89cc			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
89cc			;endif 
89cc c1			    pop bc 
89cd			 
89cd c9				ret 
89ce			 
89ce			 
89ce			 
89ce			; eof 
# End of file firmware_general.asm
89ce			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
89ce			; display routines that use the physical hardware abstraction layer 
89ce			 
89ce			 
89ce			; information window 
89ce			 
89ce			; pass hl with 1st string to display 
89ce			; pass de with 2nd string to display 
89ce			 
89ce			info_panel: 
89ce e5				push hl 
89cf			 
89cf 2a d2 eb			ld hl, (display_fb_active) 
89d2 e5				push hl    ; future de destination 
89d3 21 b7 ed				ld hl, display_fb0 
89d6 22 d2 eb				ld (display_fb_active), hl 
89d9			 
89d9			;	call clear_display 
89d9			 
89d9				if BASE_CPM 
89d9				ld a, '.' 
89d9				else 
89d9 3e a5			ld a, 165 
89db				endif 
89db cd 42 8a			call fill_display 
89de			 
89de			 
89de 3e 55			ld a, display_row_3 + 5 
89e0 cd 50 8a			call str_at_display 
89e3			 
89e3 e1				pop hl 
89e4 d1				pop de 
89e5			 
89e5 e5				push hl 
89e6			 
89e6			 
89e6 3e 2d			ld a, display_row_2 + 5 
89e8 cd 50 8a			call str_at_display 
89eb			 
89eb			 
89eb cd 60 8a			call update_display 
89ee cd 54 9a			call next_page_prompt 
89f1 cd 3d 8a			call clear_display 
89f4			 
89f4				 
89f4 21 16 ed				ld hl, display_fb1 
89f7 22 d2 eb				ld (display_fb_active), hl 
89fa cd 60 8a			call update_display 
89fd			 
89fd e1				pop hl 
89fe			 
89fe c9				ret 
89ff			 
89ff			 
89ff			 
89ff			 
89ff			; TODO windowing? 
89ff			 
89ff			; TODO scroll line up 
89ff			 
89ff			scroll_up: 
89ff			 
89ff e5				push hl 
8a00 d5				push de 
8a01 c5				push bc 
8a02			 
8a02				; get frame buffer  
8a02			 
8a02 2a d2 eb			ld hl, (display_fb_active) 
8a05 e5				push hl    ; future de destination 
8a06			 
8a06 11 28 00			ld  de, display_cols 
8a09 19				add hl, de 
8a0a			 
8a0a d1				pop de 
8a0b			 
8a0b				;ex de, hl 
8a0b 01 9f 00			ld bc, display_fb_len -1  
8a0e			;if DEBUG_FORTH_WORDS 
8a0e			;	DMARK "SCL" 
8a0e			;	CALLMONITOR 
8a0e			;endif	 
8a0e ed b0			ldir 
8a10			 
8a10				; wipe bottom row 
8a10			 
8a10			 
8a10 2a d2 eb			ld hl, (display_fb_active) 
8a13 11 a0 00			ld de, display_cols*display_rows 
8a16 19				add hl, de 
8a17 06 28			ld b, display_cols 
8a19 3e 20			ld a, ' ' 
8a1b			.scwipe: 
8a1b 77				ld (hl), a 
8a1c 2b				dec hl 
8a1d 10 fc			djnz .scwipe 
8a1f			 
8a1f				;pop hl 
8a1f			 
8a1f c1				pop bc 
8a20 d1				pop de 
8a21 e1				pop hl 
8a22			 
8a22 c9				ret 
8a23			 
8a23			 
8a23			;scroll_upo: 
8a23			;	ld de, display_row_1 
8a23			 ;	ld hl, display_row_2 
8a23			;	ld bc, display_cols 
8a23			;	ldir 
8a23			;	ld de, display_row_2 
8a23			 ;	ld hl, display_row_3 
8a23			;	ld bc, display_cols 
8a23			;	ldir 
8a23			;	ld de, display_row_3 
8a23			 ;	ld hl, display_row_4 
8a23			;	ld bc, display_cols 
8a23			;	ldir 
8a23			 
8a23			; TODO clear row 4 
8a23			 
8a23			;	ret 
8a23			 
8a23				 
8a23			scroll_down: 
8a23			 
8a23 e5				push hl 
8a24 d5				push de 
8a25 c5				push bc 
8a26			 
8a26				; get frame buffer  
8a26			 
8a26 2a d2 eb			ld hl, (display_fb_active) 
8a29			 
8a29 11 9f 00			ld de, display_fb_len - 1 
8a2c 19				add hl, de 
8a2d			 
8a2d e5			push hl    ; future de destination 
8a2e			 
8a2e 11 28 00			ld  de, display_cols 
8a31 ed 52			sbc hl, de 
8a33			 
8a33			 
8a33 d1				pop de 
8a34			 
8a34			;	ex de, hl 
8a34 01 9f 00			ld bc, display_fb_len -1  
8a37			 
8a37			 
8a37				 
8a37			 
8a37 ed b0			ldir 
8a39			 
8a39				; wipe bottom row 
8a39			 
8a39			 
8a39			;	ld hl, (display_fb_active) 
8a39			;;	ld de, display_cols*display_rows 
8a39			;;	add hl, de 
8a39			;	ld b, display_cols 
8a39			;	ld a, ' ' 
8a39			;.scwiped: 
8a39			;	ld (hl), a 
8a39			;	dec hl 
8a39			;	djnz .scwiped 
8a39			 
8a39				;pop hl 
8a39			 
8a39 c1				pop bc 
8a3a d1				pop de 
8a3b e1				pop hl 
8a3c			 
8a3c c9				ret 
8a3d			;scroll_down: 
8a3d			;	ld de, display_row_4 
8a3d			;	ld hl, display_row_3 
8a3d			;	ld bc, display_cols 
8a3d			;	ldir 
8a3d			;	ld de, display_row_3 
8a3d			; 	ld hl, display_row_2 
8a3d			;	ld bc, display_cols 
8a3d			;	ldir 
8a3d			;	ld de, display_row_2 
8a3d			;	ld hl, display_row_1 
8a3d			;	ld bc, display_cols 
8a3d			;	ldir 
8a3d			;;; TODO clear row 1 
8a3d			;	ret 
8a3d			 
8a3d			 
8a3d			 
8a3d			 
8a3d			 
8a3d			; clear active frame buffer 
8a3d			 
8a3d			clear_display: 
8a3d 3e 20			ld a, ' ' 
8a3f c3 42 8a			jp fill_display 
8a42			 
8a42			; fill active frame buffer with a char in A 
8a42			 
8a42			fill_display: 
8a42 06 a0			ld b,display_fb_len 
8a44 2a d2 eb			ld hl, (display_fb_active) 
8a47 77			.fd1:	ld (hl),a 
8a48 23				inc hl 
8a49 10 fc			djnz .fd1 
8a4b 23				inc hl 
8a4c 3e 00			ld a,0 
8a4e 77				ld (hl),a 
8a4f			 
8a4f			 
8a4f c9				ret 
8a50			; Write string (DE) at pos (A) to active frame buffer 
8a50			 
8a50 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
8a53 06 00					ld b,0 
8a55 4f					ld c,a 
8a56 09					add hl,bc 
8a57 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8a58 b7			            OR   A              ;Null terminator? 
8a59 c8			            RET  Z              ;Yes, so finished 
8a5a 77					ld (hl),a 
8a5b 23				inc hl 
8a5c 13			            INC  DE             ;Point to next character 
8a5d 18 f8		            JR   .sad1     ;Repeat 
8a5f c9					ret 
8a60			 
8a60			; using current frame buffer write to physical display 
8a60			 
8a60			update_display: 
8a60 e5				push hl 
8a61 2a d2 eb			ld hl, (display_fb_active) 
8a64 cd b2 d9			call write_display 
8a67 e1				pop hl 
8a68 c9				ret 
8a69			 
8a69			; TODO scrolling 
8a69			 
8a69			 
8a69			; move cursor right one char 
8a69			cursor_right: 
8a69			 
8a69				; TODO shift right 
8a69				; TODO if beyond max col 
8a69				; TODO       cursor_next_line 
8a69			 
8a69 c9				ret 
8a6a			 
8a6a			 
8a6a			cursor_next_line: 
8a6a				; TODO first char 
8a6a				; TODO line down 
8a6a				; TODO if past last row 
8a6a				; TODO    scroll up 
8a6a			 
8a6a c9				ret 
8a6b			 
8a6b			cursor_left: 
8a6b				; TODO shift left 
8a6b				; TODO if beyond left  
8a6b				; TODO     cursor prev line 
8a6b				 
8a6b c9				ret 
8a6c			 
8a6c			cursor_prev_line: 
8a6c				; TODO last char 
8a6c				; TODO line up 
8a6c				; TODO if past first row 
8a6c				; TODO   scroll down 
8a6c			 
8a6c c9				ret 
8a6d			 
8a6d			 
8a6d			cout: 
8a6d				; A - char 
8a6d c9				ret 
8a6e			 
8a6e			 
8a6e			; Display a menu and allow item selection (optional toggle items) 
8a6e			; 
8a6e			; format: 
8a6e			; hl pointer to word array with zero term for items 
8a6e			; e.g.    db item1 
8a6e			;         db .... 
8a6e			;         db 0 
8a6e			; 
8a6e			; a = starting menu item  
8a6e			; 
8a6e			; de = pointer item toggle array   (todo) 
8a6e			; 
8a6e			; returns item selected in a 1-... 
8a6e			; returns 0 if back button pressed 
8a6e			; 
8a6e			; NOTE: Uses system frame buffer to display 
8a6e			; 
8a6e			; LEFT, Q = go back 
8a6e			; RIGHT, SPACE, CR = select 
8a6e			; UP, A - Up 
8a6e			; DOWN, Z - Down 
8a6e			 
8a6e			 
8a6e			 
8a6e			 
8a6e			 
8a6e			menu: 
8a6e			 
8a6e					; keep array pointer 
8a6e			 
8a6e 22 7d ea				ld (store_tmp1), hl 
8a71 32 7b ea				ld (store_tmp2), a 
8a74			 
8a74					; check for key bounce 
8a74			 
8a74			if BASE_KEV 
8a74			 
8a74			.mbounce:	call cin 
8a74					cp 0 
8a74					jr nz, .mbounce 
8a74			endif 
8a74					; for ease use ex 
8a74			 
8a74					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8a74 21 b7 ed				ld hl, display_fb0 
8a77 22 d2 eb				ld (display_fb_active), hl 
8a7a			 
8a7a cd 3d 8a		.mloop:		call clear_display 
8a7d cd 60 8a				call update_display 
8a80			 
8a80					; draw selection id '>' at 1 
8a80			 
8a80					; init start of list display 
8a80			 
8a80 3e 05				ld a, 5 
8a82 32 79 ea				ld (store_tmp3), a   ; display row count 
8a85 3a 7b ea				ld a,( store_tmp2) 
8a88 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8a8b			 
8a8b					 
8a8b			.mitem:	 
8a8b			 
8a8b			 
8a8b 3a 7c ea				ld a,(store_tmp2+1) 
8a8e 6f					ld l, a 
8a8f 26 00				ld h, 0 
8a91 29					add hl, hl 
8a92 ed 5b 7d ea			ld de, (store_tmp1) 
8a96 19					add hl, de 
8a97 7e					ld a, (hl) 
8a98 23					inc hl 
8a99 66					ld h,(hl) 
8a9a 6f					ld l, a 
8a9b			 
8a9b cd 93 8c				call ishlzero 
8a9e 28 1a				jr z, .mdone 
8aa0			 
8aa0 eb					ex de, hl 
8aa1 3a 79 ea				ld a, (store_tmp3) 
8aa4 cd 50 8a				call str_at_display 
8aa7					 
8aa7			 
8aa7					; next item 
8aa7 3a 7c ea				ld a, (store_tmp2+1) 
8aaa 3c					inc a 
8aab 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8aae			 
8aae			 		; next row 
8aae			 
8aae 3a 79 ea				ld a, (store_tmp3) 
8ab1 c6 28				add display_cols 
8ab3 32 79 ea				ld (store_tmp3), a 
8ab6			 
8ab6					; at end of screen? 
8ab6			 
8ab6 fe 10				cp display_rows*4 
8ab8 20 d1				jr nz, .mitem 
8aba			 
8aba			 
8aba			.mdone: 
8aba cd 93 8c				call ishlzero 
8abd 28 08				jr z, .nodn 
8abf			 
8abf 3e 78				ld a, display_row_4 
8ac1 11 40 8b				ld de, .mdown 
8ac4 cd 50 8a				call str_at_display 
8ac7			 
8ac7					; draw options to fill the screens with active item on line 1 
8ac7					; if current option is 2 or more then display ^ in top 
8ac7			 
8ac7 3a 7b ea		.nodn:		ld a, (store_tmp2) 
8aca fe 00				cp 0 
8acc 28 08				jr z, .noup 
8ace			 
8ace 3e 00				ld a, 0 
8ad0 11 3e 8b				ld de, .mup 
8ad3 cd 50 8a				call str_at_display 
8ad6			 
8ad6 3e 02		.noup:		ld a, 2 
8ad8 11 3c 8b				ld de, .msel 
8adb cd 50 8a				call str_at_display 
8ade			 
8ade					; if current option + 1 is not null then display V in bottom 
8ade					; get key 
8ade cd 60 8a				call update_display 
8ae1			 
8ae1			 
8ae1					; handle key 
8ae1			 
8ae1 cd 3e da				call cin_wait 
8ae4			 
8ae4 fe 05				cp KEY_UP 
8ae6 28 2b				jr z, .mgoup 
8ae8 fe 61				cp 'a' 
8aea 28 27				jr z, .mgoup 
8aec fe 0a				cp KEY_DOWN 
8aee 28 32				jr z, .mgod 
8af0 fe 7a				cp 'z' 
8af2 28 2e				jr z, .mgod 
8af4 fe 20				cp ' ' 
8af6 28 34				jr z, .goend 
8af8 fe 0c				cp KEY_RIGHT 
8afa 28 30				jr z, .goend 
8afc fe 0d				cp KEY_CR 
8afe 28 2c				jr z, .goend 
8b00 fe 71				cp 'q' 
8b02 28 0b				jr z, .goback 
8b04			 
8b04 fe 0b				cp KEY_LEFT 
8b06 28 07				jr z, .goback 
8b08 fe 08				cp KEY_BS 
8b0a 28 03				jr z, .goback 
8b0c c3 7a 8a				jp .mloop 
8b0f			 
8b0f			.goback: 
8b0f 3e 00			ld a, 0 
8b11 18 1d			jr .goend2 
8b13			 
8b13				; move up one 
8b13			.mgoup: 
8b13 3a 7b ea				ld a, (store_tmp2) 
8b16 fe 00				cp 0 
8b18 ca 7a 8a				jp z, .mloop 
8b1b 3d					dec a 
8b1c 32 7b ea				ld (store_tmp2), a 
8b1f c3 7a 8a				jp .mloop 
8b22			 
8b22				; move down one 
8b22			.mgod: 
8b22 3a 7b ea				ld a, (store_tmp2) 
8b25 3c					inc a 
8b26 32 7b ea				ld (store_tmp2), a 
8b29 c3 7a 8a				jp .mloop 
8b2c			 
8b2c			 
8b2c			.goend: 
8b2c					; get selected item number 
8b2c			 
8b2c 3a 7b ea				ld a, (store_tmp2) 
8b2f 3c					inc a 
8b30			 
8b30			.goend2: 
8b30 f5					push af 
8b31			 
8b31					; restore active fb 
8b31					; TODO BUG assumes fb1 
8b31			 
8b31 21 16 ed				ld hl, display_fb1 
8b34 22 d2 eb				ld (display_fb_active), hl 
8b37			 
8b37					; restore main regs 
8b37			 
8b37			 
8b37 cd 60 8a				call update_display 
8b3a			 
8b3a f1					pop af 
8b3b			 
8b3b c9				ret 
8b3c			 
8b3c .. 00		.msel:   db ">",0 
8b3e .. 00		.mup:   db "^",0 
8b40 .. 00		.mdown:   db "v",0 
8b42			 
8b42			 
8b42			; eof 
8b42			 
# End of file firmware_display.asm
8b42			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8b42			; random number generators 
8b42			 
8b42			 
8b42			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8b42			 
8b42			 
8b42			;-----> Generate a random number 
8b42			; output a=answer 0<=a<=255 
8b42			; all registers are preserved except: af 
8b42			random: 
8b42 e5			        push    hl 
8b43 d5			        push    de 
8b44 2a b4 eb		        ld      hl,(randData) 
8b47 ed 5f		        ld      a,r 
8b49 57			        ld      d,a 
8b4a 5e			        ld      e,(hl) 
8b4b 19			        add     hl,de 
8b4c 85			        add     a,l 
8b4d ac			        xor     h 
8b4e 22 b4 eb		        ld      (randData),hl 
8b51 d1			        pop     de 
8b52 e1			        pop     hl 
8b53 c9			        ret 
8b54			 
8b54			 
8b54			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8b54			 
8b54			 
8b54			 
8b54			;------LFSR------ 
8b54			;James Montelongo 
8b54			;optimized by Spencer Putt 
8b54			;out: 
8b54			; a = 8 bit random number 
8b54			RandLFSR: 
8b54 21 ba eb		        ld hl,LFSRSeed+4 
8b57 5e			        ld e,(hl) 
8b58 23			        inc hl 
8b59 56			        ld d,(hl) 
8b5a 23			        inc hl 
8b5b 4e			        ld c,(hl) 
8b5c 23			        inc hl 
8b5d 7e			        ld a,(hl) 
8b5e 47			        ld b,a 
8b5f cb 13		        rl e  
8b61 cb 12			rl d 
8b63 cb 11		        rl c  
8b65 17				rla 
8b66 cb 13		        rl e  
8b68 cb 12			rl d 
8b6a cb 11		        rl c  
8b6c 17				rla 
8b6d cb 13		        rl e  
8b6f cb 12			rl d 
8b71 cb 11		        rl c  
8b73 17				rla 
8b74 67			        ld h,a 
8b75 cb 13		        rl e  
8b77 cb 12			rl d 
8b79 cb 11		        rl c  
8b7b 17				rla 
8b7c a8			        xor b 
8b7d cb 13		        rl e  
8b7f cb 12			rl d 
8b81 ac			        xor h 
8b82 a9			        xor c 
8b83 aa			        xor d 
8b84 21 bc eb		        ld hl,LFSRSeed+6 
8b87 11 bd eb		        ld de,LFSRSeed+7 
8b8a 01 07 00		        ld bc,7 
8b8d ed b8		        lddr 
8b8f 12			        ld (de),a 
8b90 c9			        ret 
8b91			 
8b91			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8b91			 
8b91			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8b91			 
8b91			 
8b91			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8b91			 
8b91			prng16: 
8b91			;Inputs: 
8b91			;   (seed1) contains a 16-bit seed value 
8b91			;   (seed2) contains a NON-ZERO 16-bit seed value 
8b91			;Outputs: 
8b91			;   HL is the result 
8b91			;   BC is the result of the LCG, so not that great of quality 
8b91			;   DE is preserved 
8b91			;Destroys: 
8b91			;   AF 
8b91			;cycle: 4,294,901,760 (almost 4.3 billion) 
8b91			;160cc 
8b91			;26 bytes 
8b91 2a ae eb		    ld hl,(seed1) 
8b94 44			    ld b,h 
8b95 4d			    ld c,l 
8b96 29			    add hl,hl 
8b97 29			    add hl,hl 
8b98 2c			    inc l 
8b99 09			    add hl,bc 
8b9a 22 ae eb		    ld (seed1),hl 
8b9d 2a ac eb		    ld hl,(seed2) 
8ba0 29			    add hl,hl 
8ba1 9f			    sbc a,a 
8ba2 e6 2d		    and %00101101 
8ba4 ad			    xor l 
8ba5 6f			    ld l,a 
8ba6 22 ac eb		    ld (seed2),hl 
8ba9 09			    add hl,bc 
8baa c9			    ret 
8bab			 
8bab			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8bab			 
8bab			rand32: 
8bab			;Inputs: 
8bab			;   (seed1_0) holds the lower 16 bits of the first seed 
8bab			;   (seed1_1) holds the upper 16 bits of the first seed 
8bab			;   (seed2_0) holds the lower 16 bits of the second seed 
8bab			;   (seed2_1) holds the upper 16 bits of the second seed 
8bab			;   **NOTE: seed2 must be non-zero 
8bab			;Outputs: 
8bab			;   HL is the result 
8bab			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8bab			;Destroys: 
8bab			;   AF 
8bab			;Tested and passes all CAcert tests 
8bab			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8bab			;it has a period of 18,446,744,069,414,584,320 
8bab			;roughly 18.4 quintillion. 
8bab			;LFSR taps: 0,2,6,7  = 11000101 
8bab			;291cc 
8bab			;seed1_0=$+1 
8bab			;    ld hl,12345 
8bab			;seed1_1=$+1 
8bab			;    ld de,6789 
8bab			;    ld b,h 
8bab			;    ld c,l 
8bab			;    add hl,hl \ rl e \ rl d 
8bab			;    add hl,hl \ rl e \ rl d 
8bab			;    inc l 
8bab			;    add hl,bc 
8bab			;    ld (seed1_0),hl 
8bab			;    ld hl,(seed1_1) 
8bab			;    adc hl,de 
8bab			;    ld (seed1_1),hl 
8bab			;    ex de,hl 
8bab			;seed2_0=$+1 
8bab			;    ld hl,9876 
8bab			;seed2_1=$+1 
8bab			;    ld bc,54321 
8bab			;    add hl,hl \ rl c \ rl b 
8bab			;    ld (seed2_1),bc 
8bab			;    sbc a,a 
8bab			;    and %11000101 
8bab			;    xor l 
8bab			;    ld l,a 
8bab			;    ld (seed2_0),hl 
8bab			;    ex de,hl 
8bab			;    add hl,bc 
8bab			;    ret 
8bab			; 
8bab			 
8bab			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8bab			; 20 bytes, 86 cycles (excluding ret) 
8bab			 
8bab			; returns   hl = pseudorandom number 
8bab			; corrupts   a 
8bab			 
8bab			; generates 16-bit pseudorandom numbers with a period of 65535 
8bab			; using the xorshift method: 
8bab			 
8bab			; hl ^= hl << 7 
8bab			; hl ^= hl >> 9 
8bab			; hl ^= hl << 8 
8bab			 
8bab			; some alternative shift triplets which also perform well are: 
8bab			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8bab			 
8bab			;  org 32768 
8bab			 
8bab			xrnd: 
8bab 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
8bae 3e 00		  ld a,0 
8bb0 bd			  cp l 
8bb1 20 02		  jr nz, .xrnd1 
8bb3 2e 01		  ld l, 1 
8bb5			.xrnd1: 
8bb5			 
8bb5 7c			  ld a,h 
8bb6 1f			  rra 
8bb7 7d			  ld a,l 
8bb8 1f			  rra 
8bb9 ac			  xor h 
8bba 67			  ld h,a 
8bbb 7d			  ld a,l 
8bbc 1f			  rra 
8bbd 7c			  ld a,h 
8bbe 1f			  rra 
8bbf ad			  xor l 
8bc0 6f			  ld l,a 
8bc1 ac			  xor h 
8bc2 67			  ld h,a 
8bc3			 
8bc3 22 b2 eb		  ld (xrandc),hl 
8bc6			 
8bc6 c9			  ret 
8bc7			;  
8bc7			 
8bc7			 
8bc7			;;;; int maths 
8bc7			 
8bc7			; https://map.grauw.nl/articles/mult_div_shifts.php 
8bc7			; Divide 16-bit values (with 16-bit result) 
8bc7			; In: Divide BC by divider DE 
8bc7			; Out: BC = result, HL = rest 
8bc7			; 
8bc7			Div16: 
8bc7 21 00 00		    ld hl,0 
8bca 78			    ld a,b 
8bcb 06 08		    ld b,8 
8bcd			Div16_Loop1: 
8bcd 17			    rla 
8bce ed 6a		    adc hl,hl 
8bd0 ed 52		    sbc hl,de 
8bd2 30 01		    jr nc,Div16_NoAdd1 
8bd4 19			    add hl,de 
8bd5			Div16_NoAdd1: 
8bd5 10 f6		    djnz Div16_Loop1 
8bd7 17			    rla 
8bd8 2f			    cpl 
8bd9 47			    ld b,a 
8bda 79			    ld a,c 
8bdb 48			    ld c,b 
8bdc 06 08		    ld b,8 
8bde			Div16_Loop2: 
8bde 17			    rla 
8bdf ed 6a		    adc hl,hl 
8be1 ed 52		    sbc hl,de 
8be3 30 01		    jr nc,Div16_NoAdd2 
8be5 19			    add hl,de 
8be6			Div16_NoAdd2: 
8be6 10 f6		    djnz Div16_Loop2 
8be8 17			    rla 
8be9 2f			    cpl 
8bea 41			    ld b,c 
8beb 4f			    ld c,a 
8bec c9			ret 
8bed			 
8bed			 
8bed			;http://z80-heaven.wikidot.com/math 
8bed			; 
8bed			;Inputs: 
8bed			;     DE and A are factors 
8bed			;Outputs: 
8bed			;     A is not changed 
8bed			;     B is 0 
8bed			;     C is not changed 
8bed			;     DE is not changed 
8bed			;     HL is the product 
8bed			;Time: 
8bed			;     342+6x 
8bed			; 
8bed			Mult16: 
8bed			 
8bed 06 08		     ld b,8          ;7           7 
8bef 21 00 00		     ld hl,0         ;10         10 
8bf2 29			       add hl,hl     ;11*8       88 
8bf3 07			       rlca          ;4*8        32 
8bf4 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8bf6 19			         add hl,de   ;--         -- 
8bf7 10 f9		       djnz $-5      ;13*7+8     99 
8bf9 c9			ret 
8bfa			 
8bfa			; 
8bfa			; Square root of 16-bit value 
8bfa			; In:  HL = value 
8bfa			; Out:  D = result (rounded down) 
8bfa			; 
8bfa			;Sqr16: 
8bfa			;    ld de,#0040 
8bfa			;    ld a,l 
8bfa			;    ld l,h 
8bfa			;    ld h,d 
8bfa			;    or a 
8bfa			;    ld b,8 
8bfa			;Sqr16_Loop: 
8bfa			;    sbc hl,de 
8bfa			;    jr nc,Sqr16_Skip 
8bfa			;    add hl,de 
8bfa			;Sqr16_Skip: 
8bfa			;    ccf 
8bfa			;    rl d 
8bfa			;    add a,a 
8bfa			;    adc hl,hl 
8bfa			;    add a,a 
8bfa			;    adc hl,hl 
8bfa			;    djnz Sqr16_Loop 
8bfa			;    ret 
8bfa			; 
8bfa			; 
8bfa			; Divide 8-bit values 
8bfa			; In: Divide E by divider C 
8bfa			; Out: A = result, B = rest 
8bfa			; 
8bfa			Div8: 
8bfa af			    xor a 
8bfb 06 08		    ld b,8 
8bfd			Div8_Loop: 
8bfd cb 13		    rl e 
8bff 17			    rla 
8c00 91			    sub c 
8c01 30 01		    jr nc,Div8_NoAdd 
8c03 81			    add a,c 
8c04			Div8_NoAdd: 
8c04 10 f7		    djnz Div8_Loop 
8c06 47			    ld b,a 
8c07 7b			    ld a,e 
8c08 17			    rla 
8c09 2f			    cpl 
8c0a c9			    ret 
8c0b			 
8c0b			; 
8c0b			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c0b			; In: Multiply A with DE 
8c0b			; Out: HL = result 
8c0b			; 
8c0b			Mult12U: 
8c0b 2e 00		    ld l,0 
8c0d 87			    add a,a 
8c0e 30 01		    jr nc,Mult12U_NoAdd0 
8c10 19			    add hl,de 
8c11			Mult12U_NoAdd0: 
8c11 29			    add hl,hl 
8c12 87			    add a,a 
8c13 30 01		    jr nc,Mult12U_NoAdd1 
8c15 19			    add hl,de 
8c16			Mult12U_NoAdd1: 
8c16 29			    add hl,hl 
8c17 87			    add a,a 
8c18 30 01		    jr nc,Mult12U_NoAdd2 
8c1a 19			    add hl,de 
8c1b			Mult12U_NoAdd2: 
8c1b 29			    add hl,hl 
8c1c 87			    add a,a 
8c1d 30 01		    jr nc,Mult12U_NoAdd3 
8c1f 19			    add hl,de 
8c20			Mult12U_NoAdd3: 
8c20 29			    add hl,hl 
8c21 87			    add a,a 
8c22 30 01		    jr nc,Mult12U_NoAdd4 
8c24 19			    add hl,de 
8c25			Mult12U_NoAdd4: 
8c25 29			    add hl,hl 
8c26 87			    add a,a 
8c27 30 01		    jr nc,Mult12U_NoAdd5 
8c29 19			    add hl,de 
8c2a			Mult12U_NoAdd5: 
8c2a 29			    add hl,hl 
8c2b 87			    add a,a 
8c2c 30 01		    jr nc,Mult12U_NoAdd6 
8c2e 19			    add hl,de 
8c2f			Mult12U_NoAdd6: 
8c2f 29			    add hl,hl 
8c30 87			    add a,a 
8c31 d0			    ret nc 
8c32 19			    add hl,de 
8c33 c9			    ret 
8c34			 
8c34			; 
8c34			; Multiply 8-bit value with a 16-bit value (right rotating) 
8c34			; In: Multiply A with DE 
8c34			;      Put lowest value in A for most efficient calculation 
8c34			; Out: HL = result 
8c34			; 
8c34			Mult12R: 
8c34 21 00 00		    ld hl,0 
8c37			Mult12R_Loop: 
8c37 cb 3f		    srl a 
8c39 30 01		    jr nc,Mult12R_NoAdd 
8c3b 19			    add hl,de 
8c3c			Mult12R_NoAdd: 
8c3c cb 23		    sla e 
8c3e cb 12		    rl d 
8c40 b7			    or a 
8c41 c2 37 8c		    jp nz,Mult12R_Loop 
8c44 c9			    ret 
8c45			 
8c45			; 
8c45			; Multiply 16-bit values (with 32-bit result) 
8c45			; In: Multiply BC with DE 
8c45			; Out: BCHL = result 
8c45			; 
8c45			Mult32: 
8c45 79			    ld a,c 
8c46 48			    ld c,b 
8c47 21 00 00		    ld hl,0 
8c4a 06 10		    ld b,16 
8c4c			Mult32_Loop: 
8c4c 29			    add hl,hl 
8c4d 17			    rla 
8c4e cb 11		    rl c 
8c50 30 07		    jr nc,Mult32_NoAdd 
8c52 19			    add hl,de 
8c53 ce 00		    adc a,0 
8c55 d2 59 8c		    jp nc,Mult32_NoAdd 
8c58 0c			    inc c 
8c59			Mult32_NoAdd: 
8c59 10 f1		    djnz Mult32_Loop 
8c5b 41			    ld b,c 
8c5c 4f			    ld c,a 
8c5d c9			    ret 
8c5e			 
8c5e			 
8c5e			 
8c5e			; 
8c5e			; Multiply 8-bit values 
8c5e			; In:  Multiply H with E 
8c5e			; Out: HL = result 
8c5e			; 
8c5e			Mult8: 
8c5e 16 00		    ld d,0 
8c60 6a			    ld l,d 
8c61 06 08		    ld b,8 
8c63			Mult8_Loop: 
8c63 29			    add hl,hl 
8c64 30 01		    jr nc,Mult8_NoAdd 
8c66 19			    add hl,de 
8c67			Mult8_NoAdd: 
8c67 10 fa		    djnz Mult8_Loop 
8c69 c9			    ret 
8c6a			 
8c6a			 
8c6a			 
8c6a			 
8c6a			 
8c6a			 
8c6a			 
8c6a			 
8c6a			;;http://z80-heaven.wikidot.com/math 
8c6a			;;This divides DE by BC, storing the result in DE, remainder in HL 
8c6a			; 
8c6a			;DE_Div_BC:          ;1281-2x, x is at most 16 
8c6a			;     ld a,16        ;7 
8c6a			;     ld hl,0        ;10 
8c6a			;     jp $+5         ;10 
8c6a			;.DivLoop: 
8c6a			;       add hl,bc    ;-- 
8c6a			;       dec a        ;64 
8c6a			;       jr z,.DivLoopEnd        ;86 
8c6a			; 
8c6a			;       sla e        ;128 
8c6a			;       rl d         ;128 
8c6a			;       adc hl,hl    ;240 
8c6a			;       sbc hl,bc    ;240 
8c6a			;       jr nc,.DivLoop ;23|21 
8c6a			;       inc e        ;-- 
8c6a			;       jp .DivLoop+1 
8c6a			; 
8c6a			;.DivLoopEnd: 
8c6a			 
8c6a			;HL_Div_C: 
8c6a			;Inputs: 
8c6a			;     HL is the numerator 
8c6a			;     C is the denominator 
8c6a			;Outputs: 
8c6a			;     A is the remainder 
8c6a			;     B is 0 
8c6a			;     C is not changed 
8c6a			;     DE is not changed 
8c6a			;     HL is the quotient 
8c6a			; 
8c6a			;       ld b,16 
8c6a			;       xor a 
8c6a			;         add hl,hl 
8c6a			;         rla 
8c6a			;         cp c 
8c6a			;         jr c,$+4 
8c6a			;           inc l 
8c6a			;           sub c 
8c6a			;         djnz $-7 
8c6a			 
8c6a			; https://plutiedev.com/z80-add-8bit-to-16bit 
8c6a			 
8c6a			addatohl: 
8c6a 85			    add   a, l    ; A = A+L 
8c6b 6f			    ld    l, a    ; L = A+L 
8c6c 8c			    adc   a, h    ; A = A+L+H+carry 
8c6d 95			    sub   l       ; A = H+carry 
8c6e 67			    ld    h, a    ; H = H+carry 
8c6f c9			ret 
8c70			 
8c70			addatode: 
8c70 83			    add   a, e    ; A = A+L 
8c71 5f			    ld    e, a    ; L = A+L 
8c72 8a			    adc   a, d    ; A = A+L+H+carry 
8c73 93			    sub   e       ; A = H+carry 
8c74 57			    ld    d, a    ; H = H+carry 
8c75 c9			ret 
8c76			 
8c76			 
8c76			addatobc: 
8c76 81			    add   a, c    ; A = A+L 
8c77 4f			    ld    c, a    ; L = A+L 
8c78 88			    adc   a, b    ; A = A+L+H+carry 
8c79 91			    sub   c       ; A = H+carry 
8c7a 47			    ld    b, a    ; H = H+carry 
8c7b c9			ret 
8c7c			 
8c7c			subafromhl: 
8c7c			   ; If A=0 do nothing 
8c7c			    ; Otherwise flip A's sign. Since 
8c7c			    ; the upper byte becomes -1, also 
8c7c			    ; substract 1 from H. 
8c7c ed 44		    neg 
8c7e ca 87 8c		    jp    z, Skip 
8c81 25			    dec   h 
8c82			     
8c82			    ; Now add the low byte as usual 
8c82			    ; Two's complement takes care of 
8c82			    ; ensuring the result is correct 
8c82 85			    add   a, l 
8c83 6f			    ld    l, a 
8c84 8c			    adc   a, h 
8c85 95			    sub   l 
8c86 67			    ld    h, a 
8c87			Skip: 
8c87 c9				ret 
8c88			 
8c88			 
8c88			; compare hl and de 
8c88			; returns:  
8c88			; if hl = de, z=1, s=0, c0=0 
8c88			; if hl > de, z=0, s=0, c=0 
8c88			; if hl < de, z=0, s=1, c=1 
8c88			cmp16:	 
8c88 b7				or a 
8c89 ed 52			sbc hl,de 
8c8b e0				ret po 
8c8c 7c				ld a,h 
8c8d 1f				rra 
8c8e ee 40			xor 01000000B 
8c90 37				scf 
8c91 8f				adc a,a 
8c92 c9				ret 
8c93			 
8c93			 
8c93			; test if hl contains zero   - A is destroyed 
8c93			 
8c93			ishlzero:    
8c93 b7				or a     ; reset flags 
8c94 7c				ld a, h 
8c95 b5				or l        	 
8c96			 
8c96 c9				ret 
8c97			 
8c97			 
8c97			 
8c97			 
8c97			if FORTH_ENABLE_FLOATMATH 
8c97			;include "float/bbcmath.z80" 
8c97			include "float/lpfpcalc.asm" 
8c97			endif 
8c97			 
8c97			 
8c97			; eof 
8c97			 
# End of file firmware_maths.asm
8c97			include "firmware_strings.asm"   ; string handling  
8c97			 
8c97			 
8c97			; TODO string len 
8c97			; input text string, end on cr with zero term 
8c97			; a offset into frame buffer to start prompt 
8c97			; d is max length 
8c97			; e is display size TODO 
8c97			; c is current cursor position 
8c97			; hl is ptr to where string will be stored 
8c97			 
8c97			 
8c97			; TODO check limit of buffer for new inserts 
8c97			; TODO check insert does not push beyond buffer 
8c97			; TODO scroll in a limited display area 
8c97			; TODO scroll whole screen on page wrap 
8c97			 
8c97			 
8c97			; TODO handle KEY_PREVWORD 
8c97			; TODO handle KEY_NEXTWORD 
8c97			; TODO handle KEY_HOME 
8c97			; TODO handle KEY_END 
8c97			; TODO use LCD cursor? 
8c97			 
8c97 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8c9a 81					add c 
8c9b 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8c9e 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
8ca1 79					ld a, c 
8ca2 cd 6a 8c				call addatohl 
8ca5 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ca8 7a					ld a,d 
8ca9 32 6c ee			        ld (input_size), a       ; save length of input area 
8cac 79					ld a, c 
8cad 32 5b ee				ld (input_cursor),a      ; init cursor start position  
8cb0 7b					ld a,e 
8cb1 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8cb4					 
8cb4					 
8cb4			 
8cb4			;		ld a,(input_ptr) 
8cb4			;		ld (input_under_cursor),a 	; save what is under the cursor 
8cb4			 
8cb4			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8cb4					; init cursor shape if not set by the cin routines 
8cb4 21 ca eb				ld hl, cursor_shape 
8cb7 3e ff				ld a, 255 
8cb9 77					ld (hl), a 
8cba 23					inc hl 
8cbb 3e 00				ld a, 0 
8cbd 77					ld (hl), a 
8cbe			 
8cbe 3e 0f				ld a, CUR_BLINK_RATE 
8cc0 32 66 ee				ld (input_cur_flash), a 
8cc3 3e 01				ld a, 1 
8cc5 32 65 ee				ld (input_cur_onoff),a 
8cc8			 
8cc8			;	if DEBUG_INPUT 
8cc8			;		push af 
8cc8			;		ld a, 'I' 
8cc8			;		ld (debug_mark),a 
8cc8			;		pop af 
8cc8			;		CALLMONITOR 
8cc8			;	endif 
8cc8			.is1:		; main entry loop 
8cc8			 
8cc8			 
8cc8			 
8cc8					; pause 1ms 
8cc8			 
8cc8 3e 01				ld a, 1 
8cca cd 9f 89				call aDelayInMS 
8ccd			 
8ccd					; dec flash counter 
8ccd 3a 66 ee				ld a, (input_cur_flash) 
8cd0 3d					dec a 
8cd1 32 66 ee				ld (input_cur_flash), a 
8cd4 fe 00				cp 0 
8cd6 20 0d				jr nz, .nochgstate 
8cd8			 
8cd8			 
8cd8					; change state 
8cd8 3a 65 ee				ld a,(input_cur_onoff) 
8cdb ed 44				neg 
8cdd 32 65 ee				ld (input_cur_onoff),a 
8ce0			 
8ce0			 
8ce0					; reset on change of state 
8ce0 3e 0f				ld a, CUR_BLINK_RATE 
8ce2 32 66 ee				ld (input_cur_flash), a 
8ce5			 
8ce5			.nochgstate: 
8ce5					 
8ce5					 
8ce5			 
8ce5					; display cursor  
8ce5			 
8ce5			;		ld hl, (input_start) 
8ce5			;		ld a, (input_cursor) 
8ce5			;		call addatohl 
8ce5			 
8ce5					; get char under cursor and replace with cursor 
8ce5 2a 6f ee		ld hl, (input_ptr) 
8ce8			;		ld a, (hl) 
8ce8			;		ld (input_under_cursor),a 
8ce8			;		ld a, '_' 
8ce8			;		ld (hl), a 
8ce8			 
8ce8					; display string 
8ce8			 
8ce8 ed 5b 6d ee			ld de, (input_start) 
8cec 3a 6a ee				ld a, (input_at_pos) 
8cef cd 50 8a				call str_at_display 
8cf2			;	        call update_display 
8cf2			 
8cf2					; find place to put the cursor 
8cf2			;		add h 
8cf2			;		ld l, display_row_1 
8cf2			;		sub l 
8cf2			; (input_at_pos) 
8cf2					;ld c, a 
8cf2			;		ld a, (input_cursor) 
8cf2			;		ld l, (input_at_pos) 
8cf2			;		;ld b, h 
8cf2			;		add l 
8cf2			;		ld (input_at_cursor),a 
8cf2					;ld l,h 
8cf2			 
8cf2			;		ld h, 0 
8cf2			;		ld l,(input_at_pos) 
8cf2			;		ld a, (input_cursor) 
8cf2			;		call addatohl 
8cf2			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8cf2			;		call subafromhl 
8cf2			;		ld a,l 
8cf2			;		ld (input_at_cursor), a 
8cf2			 
8cf2				if DEBUG_INPUT 
8cf2					ld a, (hardware_diag) 
8cf2					cp 0 
8cf2					jr z, .skip_input_diag 
8cf2			 
8cf2					ld a,(input_at_pos) 
8cf2					ld hl, LFSRSeed 
8cf2					call hexout 
8cf2					ld a, (input_cursor) 
8cf2					ld hl, LFSRSeed+2 
8cf2					call hexout 
8cf2					ld a,(input_at_cursor) 
8cf2					ld hl, LFSRSeed+4 
8cf2					call hexout 
8cf2			 
8cf2					ld a,(input_cur_onoff) 
8cf2					ld hl, LFSRSeed+6 
8cf2					call hexout 
8cf2			 
8cf2					ld a,(input_cur_flash) 
8cf2					ld hl, LFSRSeed+8 
8cf2					call hexout 
8cf2			 
8cf2					ld a,(input_len) 
8cf2					ld hl, LFSRSeed+10 
8cf2					call hexout 
8cf2					ld hl, LFSRSeed+12 
8cf2					ld a, 0 
8cf2					ld (hl),a 
8cf2					ld a, display_row_4 
8cf2					ld de, LFSRSeed 
8cf2					call str_at_display 
8cf2					.skip_input_diag: 
8cf2				endif 
8cf2			 
8cf2					; decide on if we are showing the cursor this time round 
8cf2			 
8cf2 3a 65 ee				ld a, (input_cur_onoff) 
8cf5 fe ff				cp 255 
8cf7 28 13				jr z, .skipcur 
8cf9			 
8cf9			 
8cf9 3a 68 ee				ld a,(input_at_cursor) 
8cfc 11 ca eb				ld de, cursor_shape 
8cff cd 50 8a				call str_at_display 
8d02			 
8d02					; save length of current input string 
8d02 2a 6d ee				ld hl, (input_start) 
8d05 cd c8 90				call strlenz 
8d08 7d					ld a,l 
8d09 32 60 ee				ld (input_len),a 
8d0c			 
8d0c			.skipcur: 
8d0c			 
8d0c cd 60 8a			        call update_display 
8d0f					 
8d0f			 
8d0f			 
8d0f					; wait 
8d0f				 
8d0f					; TODO loop without wait to flash the cursor and char under cursor	 
8d0f cd 44 da				call cin    ; _wait 
8d12			 
8d12 fe 00				cp 0 
8d14 ca c8 8c				jp z, .is1 
8d17			 
8d17					; get ptr to char to input into 
8d17			 
8d17 4f					ld c,a 
8d18 2a 6d ee				ld hl, (input_start) 
8d1b 3a 5b ee				ld a, (input_cursor) 
8d1e cd 6a 8c				call addatohl 
8d21 22 6f ee				ld (input_ptr), hl 
8d24 79					ld a,c 
8d25			 
8d25					; replace char under cursor 
8d25			 
8d25			;		ld hl, (input_ptr) 
8d25			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d25			;		ld (hl), a 
8d25			 
8d25			;	if DEBUG_INPUT 
8d25			;		push af 
8d25			;		ld a, 'i' 
8d25			;		ld (debug_mark),a 
8d25			;		pop af 
8d25			;		CALLMONITOR 
8d25			;	endif 
8d25 fe 0e				cp KEY_HOME 
8d27 20 0e				jr nz, .iske 
8d29			 
8d29 3a 6a ee				ld a, (input_at_pos) 
8d2c 32 68 ee				ld (input_at_cursor),a 
8d2f 3e 00				ld a, 0 
8d31 32 5b ee				ld (input_cursor), a 
8d34 c3 c8 8c				jp .is1 
8d37					 
8d37 fe 0f		.iske:		cp KEY_END 
8d39 20 03				jr nz, .isknw 
8d3b c3 c8 8c				jp .is1 
8d3e			 
8d3e fe 06		.isknw:		cp KEY_NEXTWORD 
8d40 20 1b				jr nz, .iskpw 
8d42			 
8d42 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
8d45 7e					ld a,(hl)	 
8d46 fe 00				cp 0 
8d48 ca c8 8c				jp z, .is1    ; end of string 
8d4b fe 20				cp ' ' 
8d4d ca c8 8c				jp z, .is1    ; end of word 
8d50 23					inc hl 
8d51 22 6f ee				ld (input_ptr), hl 
8d54 3a 68 ee				ld a, (input_at_cursor) 
8d57 3c					inc a 
8d58 32 68 ee				ld (input_at_cursor), a 
8d5b 18 e5				jr .isknwm 
8d5d			 
8d5d fe 07		.iskpw:		cp KEY_PREVWORD 
8d5f 20 1b				jr nz, .iskl 
8d61			.iskpwm:	 
8d61 2a 6f ee				ld hl, (input_ptr) 
8d64 7e					ld a,(hl)	 
8d65 fe 00				cp 0  
8d67 ca c8 8c				jp z, .is1    ; end of string 
8d6a fe 20				cp ' ' 
8d6c ca c8 8c				jp z, .is1    ; end of word 
8d6f 2b					dec hl 
8d70 22 6f ee				ld (input_ptr), hl 
8d73 3a 68 ee				ld a, (input_at_cursor) 
8d76 3d					dec a 
8d77 32 68 ee				ld (input_at_cursor), a 
8d7a 18 e5				jr .iskpwm 
8d7c			 
8d7c			 
8d7c fe 0b		.iskl:		cp KEY_LEFT 
8d7e 20 27				jr nz, .isk1 
8d80			 
8d80 3a 5b ee				ld a, (input_cursor) 
8d83			 
8d83 fe 00				cp 0 
8d85 ca c8 8c				jp z, .is1 		; at start of line to ignore  
8d88			 
8d88 3d					dec  a 		; TODO check underflow 
8d89 32 5b ee				ld (input_cursor), a 
8d8c			 
8d8c 2a 6f ee				ld hl, (input_ptr) 
8d8f 2b					dec hl 
8d90 22 6f ee				ld (input_ptr), hl 
8d93					 
8d93 3a 68 ee				ld a, (input_at_cursor) 
8d96 3d					dec a 
8d97 32 68 ee				ld (input_at_cursor), a 
8d9a			 
8d9a 3e 01				ld a, 1		; show cursor moving 
8d9c 32 65 ee				ld (input_cur_onoff),a 
8d9f 3e 0f				ld a, CUR_BLINK_RATE 
8da1 32 66 ee				ld (input_cur_flash), a 
8da4			 
8da4 c3 c8 8c				jp .is1 
8da7			 
8da7 fe 0c		.isk1:		cp KEY_RIGHT 
8da9 20 2a				jr nz, .isk2 
8dab			 
8dab 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8dae 5f					ld e,a 
8daf 3a 5b ee				ld a, (input_cursor) 
8db2 bb					cp e 
8db3 ca c8 8c				jp z, .is1		; at the end of string so dont go right 
8db6			 
8db6 3c					inc  a 		; TODO check overflow 
8db7 32 5b ee				ld (input_cursor), a 
8dba			 
8dba 3a 68 ee				ld a, (input_at_cursor) 
8dbd 3c					inc a 
8dbe 32 68 ee				ld (input_at_cursor), a 
8dc1			 
8dc1 2a 6f ee				ld hl, (input_ptr) 
8dc4 23					inc hl 
8dc5 22 6f ee				ld (input_ptr), hl 
8dc8			 
8dc8 3e 01				ld a, 1		; show cursor moving 
8dca 32 65 ee				ld (input_cur_onoff),a 
8dcd 3e 0f				ld a, CUR_BLINK_RATE 
8dcf 32 66 ee				ld (input_cur_flash), a 
8dd2			 
8dd2 c3 c8 8c				jp .is1 
8dd5			 
8dd5 fe 05		.isk2:		cp KEY_UP 
8dd7			 
8dd7 20 26				jr nz, .isk3 
8dd9			 
8dd9					; swap last command with the current on 
8dd9			 
8dd9					; move cursor to start of string 
8dd9 2a 6d ee				ld hl, (input_start) 
8ddc 22 6f ee				ld (input_ptr), hl 
8ddf			 
8ddf 3a 6a ee				ld a, (input_at_pos) 
8de2 32 68 ee				ld (input_at_cursor), a 
8de5			 
8de5 3e 00				ld a, 0 
8de7 32 5b ee				ld (input_cursor), a 
8dea					 
8dea					; swap input and last command buffers 
8dea			 
8dea 21 29 e6				ld hl, os_cli_cmd 
8ded 11 28 e7				ld de, os_last_cmd 
8df0 06 ff				ld b, 255 
8df2 7e			.swap1:		ld a, (hl) 
8df3 4f					ld c,a 
8df4 1a					ld a, (de) 
8df5 77					ld (hl), a 
8df6 79					ld a,c 
8df7 12					ld (de),a 
8df8 23					inc hl 
8df9 13					inc de 
8dfa 10 f6				djnz .swap1 
8dfc			 
8dfc			 
8dfc			 
8dfc			 
8dfc			 
8dfc c3 c8 8c				jp .is1 
8dff			 
8dff fe 08		.isk3:		cp KEY_BS 
8e01 20 3c				jr nz, .isk4 
8e03			 
8e03 3a 5b ee				ld a, (input_cursor) 
8e06			 
8e06 fe 00				cp 0 
8e08 ca c8 8c				jp z, .is1 		; at start of line to ignore  
8e0b			 
8e0b 3d					dec  a 		; TODO check underflow 
8e0c 32 5b ee				ld (input_cursor), a 
8e0f			 
8e0f					; hl is source 
8e0f					; de needs to be source - 1 
8e0f			 
8e0f			;		ld a, 0 
8e0f			;		dec hl 
8e0f			;		ld (hl), a 
8e0f			 
8e0f 2a 6f ee				ld hl, (input_ptr) 
8e12 2b					dec hl 
8e13 22 6f ee				ld (input_ptr), hl 
8e16			 
8e16					; shift all data 
8e16			 
8e16 e5					push hl 
8e17 23					inc hl 
8e18 d1					pop de 
8e19 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e1c 4f					ld c,a 
8e1d 06 00				ld b,0 
8e1f ed b0				ldir  
8e21			 
8e21			 
8e21			 
8e21			 
8e21 3a 68 ee				ld a, (input_at_cursor) 
8e24 3d					dec a 
8e25 32 68 ee				ld (input_at_cursor), a 
8e28			 
8e28			 
8e28 3e 01				ld a, 1		; show cursor moving 
8e2a 32 65 ee				ld (input_cur_onoff),a 
8e2d 3e 0f				ld a, CUR_BLINK_RATE 
8e2f 32 66 ee				ld (input_cur_flash), a 
8e32			 
8e32					; remove char 
8e32 3a 68 ee				ld a, (input_at_cursor) 
8e35 3c					inc a 
8e36 11 c0 8e				ld de,.iblank 
8e39 cd 50 8a				call str_at_display 
8e3c			 
8e3c c3 c8 8c				jp .is1 
8e3f			 
8e3f fe 0d		.isk4:		cp KEY_CR 
8e41 28 6c				jr z, .endinput 
8e43			 
8e43					; else add the key press to the end 
8e43			 
8e43 4f					ld c, a			; save key pressed 
8e44			 
8e44 7e					ld a,(hl)		; get what is currently under char 
8e45			 
8e45 fe 00				cp 0			; we are at the end of the string 
8e47 20 2f				jr nz, .onchar 
8e49					 
8e49					; add a char to the end of the string 
8e49				 
8e49 71					ld (hl),c 
8e4a 23					inc hl 
8e4b			;		ld a,' ' 
8e4b			;		ld (hl),a 
8e4b			;		inc hl 
8e4b 3e 00				ld a,0 
8e4d 77					ld (hl),a 
8e4e 2b					dec hl 
8e4f			 
8e4f 3a 5b ee				ld a, (input_cursor) 
8e52 3c					inc a				; TODO check max string length and scroll  
8e53 32 5b ee				ld (input_cursor), a		; inc cursor pos 
8e56							 
8e56 3a 68 ee				ld a, (input_at_cursor) 
8e59 3c					inc a 
8e5a 32 68 ee				ld (input_at_cursor), a 
8e5d			 
8e5d 2a 6f ee				ld hl, (input_ptr) 
8e60 23					inc hl 
8e61 22 6f ee				ld (input_ptr), hl 
8e64			 
8e64 2a 6f ee				ld hl, (input_ptr) 
8e67 23					inc hl 
8e68 22 6f ee				ld (input_ptr), hl 
8e6b			;	if DEBUG_INPUT 
8e6b			;		push af 
8e6b			;		ld a, '+' 
8e6b			;		ld (debug_mark),a 
8e6b			;		pop af 
8e6b			;		CALLMONITOR 
8e6b			;	endif 
8e6b 3e 01				ld a, 1		; show cursor moving 
8e6d 32 65 ee				ld (input_cur_onoff),a 
8e70 3e 0f				ld a, CUR_BLINK_RATE 
8e72 32 66 ee				ld (input_cur_flash), a 
8e75 c3 c8 8c				jp .is1 
8e78					 
8e78			 
8e78			 
8e78					; if on a char then insert 
8e78			.onchar: 
8e78			 
8e78					; TODO over flow check: make sure insert does not blow out buffer 
8e78			 
8e78					; need to do some maths to use lddr 
8e78			 
8e78 e5					push hl   ; save char pos 
8e79 c5					push bc 
8e7a			 
8e7a 2a 6d ee				ld hl, (input_start) 
8e7d 3a 60 ee				ld a, (input_len) 
8e80 cd 6a 8c				call addatohl  		; end of string 
8e83 23					inc hl 
8e84 23					inc hl		; past zero term 
8e85 e5					push hl 
8e86 23					inc hl 
8e87 e5					push hl  
8e88			 
8e88								; start and end of lddr set, now how much to move? 
8e88			 
8e88							 
8e88 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8e8b 47					ld b,a 
8e8c 3a 60 ee				ld a,(input_len) 
8e8f 5f					ld e,a 
8e90 90					sub b 
8e91 3c					inc a		;?? 
8e92 3c					inc a		;?? 
8e93 3c					inc a		;?? 
8e94			 
8e94 06 00				ld b,0 
8e96 4f					ld c,a 
8e97			 
8e97				if DEBUG_INPUT 
8e97					push af 
8e97					ld a, 'i' 
8e97					ld (debug_mark),a 
8e97					pop af 
8e97			;		CALLMONITOR 
8e97				endif 
8e97 d1					pop de 
8e98 e1					pop hl 
8e99				if DEBUG_INPUT 
8e99					push af 
8e99					ld a, 'I' 
8e99					ld (debug_mark),a 
8e99					pop af 
8e99			;		CALLMONITOR 
8e99				endif 
8e99 ed b8				lddr 
8e9b				 
8e9b			 
8e9b			 
8e9b					; TODO have a key for insert/overwrite mode???? 
8e9b c1					pop bc 
8e9c e1					pop hl 
8e9d 71					ld (hl), c		; otherwise overwrite current char 
8e9e					 
8e9e			 
8e9e			 
8e9e			 
8e9e 3a 5b ee				ld a, (input_cursor) 
8ea1 3c					inc  a 		; TODO check overflow 
8ea2 32 5b ee				ld (input_cursor), a 
8ea5			 
8ea5 3a 68 ee				ld a, (input_at_cursor) 
8ea8 3c					inc a 
8ea9 32 68 ee				ld (input_at_cursor), a 
8eac			 
8eac c3 c8 8c				jp .is1 
8eaf			 
8eaf			.endinput:	; TODO look for end of string 
8eaf			 
8eaf					; add trailing space for end of token 
8eaf			 
8eaf 2a 6d ee				ld hl, (input_start) 
8eb2 3a 60 ee				ld a,(input_len) 
8eb5 cd 6a 8c				call addatohl 
8eb8 3e 20				ld a, ' ' 
8eba 77					ld (hl),a 
8ebb					; TODO eof of parse marker 
8ebb			 
8ebb 23					inc hl 
8ebc 3e 00				ld a, 0 
8ebe 77					ld (hl),a 
8ebf			 
8ebf			 
8ebf c9					ret 
8ec0			 
8ec0 .. 00		.iblank: db " ",0 
8ec2			 
8ec2			 
8ec2 32 6a ee		input_str_prev:	ld (input_at_pos), a 
8ec5 22 6d ee				ld (input_start), hl 
8ec8 3e 01				ld a,1			; add cursor 
8eca 77					ld (hl),a 
8ecb 23					inc hl 
8ecc 3e 00				ld a,0 
8ece 77					ld (hl),a 
8ecf 22 6f ee				ld (input_ptr), hl 
8ed2 7a					ld a,d 
8ed3 32 6c ee				ld (input_size), a 
8ed6 3e 00				ld a,0 
8ed8 32 5b ee				ld (input_cursor),a 
8edb			.instr1:	 
8edb			 
8edb					; TODO do block cursor 
8edb					; TODO switch cursor depending on the modifer key 
8edb			 
8edb					; update cursor shape change on key hold 
8edb			 
8edb 2a 6f ee				ld hl, (input_ptr) 
8ede 2b					dec hl 
8edf 3a ca eb				ld a,(cursor_shape) 
8ee2 77					ld (hl), a 
8ee3			 
8ee3					; display entered text 
8ee3 3a 6a ee				ld a,(input_at_pos) 
8ee6 cd a2 d9		            	CALL fLCD_Pos       ;Position cursor to location in A 
8ee9 ed 5b 6d ee	            	LD   de, (input_start) 
8eed cd 9c d9		            	CALL fLCD_Str       ;Display string pointed to by DE 
8ef0			 
8ef0 cd 44 da				call cin 
8ef3 fe 00				cp 0 
8ef5 28 e4				jr z, .instr1 
8ef7			 
8ef7					; proecess keyboard controls first 
8ef7			 
8ef7 2a 6f ee				ld hl,(input_ptr) 
8efa			 
8efa fe 0d				cp KEY_CR	 ; pressing enter ends input 
8efc 28 5a				jr z, .instrcr 
8efe			 
8efe fe 08				cp KEY_BS 	; back space 
8f00 20 0f				jr nz, .instr2 
8f02					; process back space 
8f02			 
8f02					; TODO stop back space if at start of string 
8f02 2b					dec hl 
8f03 2b					dec hl ; to over write cursor 
8f04 3a ca eb				ld a,(cursor_shape) 
8f07					;ld a,0 
8f07 77					ld (hl),a 
8f08 23					inc hl 
8f09 3e 20				ld a," " 
8f0b 77					ld (hl),a 
8f0c 22 6f ee				ld (input_ptr),hl 
8f0f					 
8f0f			 
8f0f 18 ca				jr .instr1 
8f11			 
8f11 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f13 20 06				jr nz, .instr3 
8f15 2b					dec hl 
8f16 22 6f ee				ld (input_ptr),hl 
8f19 18 c0				jr .instr1 
8f1b				 
8f1b fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f1d 20 06				jr nz, .instr4 
8f1f 23					inc hl 
8f20 22 6f ee				ld (input_ptr),hl 
8f23 18 b6				jr .instr1 
8f25			 
8f25 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f27 20 06				jr nz, .instr5 
8f29 2b					dec hl 
8f2a 22 6f ee				ld (input_ptr),hl 
8f2d 18 ac				jr .instr1 
8f2f			 
8f2f fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8f31 20 06				jr nz, .instr6 
8f33 2b					dec hl 
8f34 22 6f ee				ld (input_ptr),hl 
8f37 18 a2				jr .instr1 
8f39 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8f3b 20 0b				jr nz, .instrnew 
8f3d			 
8f3d 21 02 e3			ld hl, scratch 
8f40 11 28 e7			ld de, os_last_cmd 
8f43 cd 61 8f			call strcpy 
8f46 18 93				jr .instr1 
8f48			 
8f48			 
8f48			.instrnew:	; no special key pressed to see if we have room to store it 
8f48			 
8f48					; TODO do string size test 
8f48			 
8f48 2b					dec hl ; to over write cursor 
8f49 77					ld (hl),a 
8f4a 23					inc hl 
8f4b 3a ca eb				ld a,(cursor_shape) 
8f4e 77					ld (hl),a 
8f4f 23					inc hl 
8f50 3e 00				ld a,0 
8f52 77					ld (hl),a 
8f53			 
8f53 22 6f ee				ld (input_ptr),hl 
8f56					 
8f56 18 83				jr .instr1 
8f58 2b			.instrcr:	dec hl		; remove cursor 
8f59 3e 20				ld a,' '	; TODO add a trailing space for safety 
8f5b 77					ld (hl),a 
8f5c 23					inc hl 
8f5d 3e 00				ld a,0 
8f5f 77					ld (hl),a 
8f60			 
8f60			 
8f60					; if at end of line scroll up    
8f60					; TODO detecting only end of line 4 for scroll up  
8f60			 
8f60					;ld   
8f60			 
8f60 c9					ret 
8f61			 
8f61			 
8f61			; strcpy hl = dest, de source 
8f61			 
8f61 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8f62 b7			            OR   A              ;Null terminator? 
8f63 c8			            RET  Z              ;Yes, so finished 
8f64 1a					ld a,(de) 
8f65 77					ld (hl),a 
8f66 13			            INC  DE             ;Point to next character 
8f67 23					inc hl 
8f68 18 f7		            JR   strcpy       ;Repeat 
8f6a c9					ret 
8f6b			 
8f6b			 
8f6b			; TODO string_at  
8f6b			; pass string which starts with lcd offset address and then null term string 
8f6b			 
8f6b			; TODO string to dec 
8f6b			; TODO string to hex 
8f6b			; TODO byte to string hex 
8f6b			; TODO byte to string dec 
8f6b			 
8f6b			 
8f6b			 
8f6b			; from z80uartmonitor 
8f6b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f6b			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8f6b			; pass hl for where to put the text 
8f6b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f6b c5			hexout:	PUSH BC 
8f6c f5					PUSH AF 
8f6d 47					LD B, A 
8f6e					; Upper nybble 
8f6e cb 3f				SRL A 
8f70 cb 3f				SRL A 
8f72 cb 3f				SRL A 
8f74 cb 3f				SRL A 
8f76 cd 86 8f				CALL tohex 
8f79 77					ld (hl),a 
8f7a 23					inc hl	 
8f7b					 
8f7b					; Lower nybble 
8f7b 78					LD A, B 
8f7c e6 0f				AND 0FH 
8f7e cd 86 8f				CALL tohex 
8f81 77					ld (hl),a 
8f82 23					inc hl	 
8f83					 
8f83 f1					POP AF 
8f84 c1					POP BC 
8f85 c9					RET 
8f86					 
8f86			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f86			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8f86			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f86			tohex: 
8f86 e5					PUSH HL 
8f87 d5					PUSH DE 
8f88 16 00				LD D, 0 
8f8a 5f					LD E, A 
8f8b 21 93 8f				LD HL, .DATA 
8f8e 19					ADD HL, DE 
8f8f 7e					LD A, (HL) 
8f90 d1					POP DE 
8f91 e1					POP HL 
8f92 c9					RET 
8f93			 
8f93			.DATA: 
8f93 30					DEFB	30h	; 0 
8f94 31					DEFB	31h	; 1 
8f95 32					DEFB	32h	; 2 
8f96 33					DEFB	33h	; 3 
8f97 34					DEFB	34h	; 4 
8f98 35					DEFB	35h	; 5 
8f99 36					DEFB	36h	; 6 
8f9a 37					DEFB	37h	; 7 
8f9b 38					DEFB	38h	; 8 
8f9c 39					DEFB	39h	; 9 
8f9d 41					DEFB	41h	; A 
8f9e 42					DEFB	42h	; B 
8f9f 43					DEFB	43h	; C 
8fa0 44					DEFB	44h	; D 
8fa1 45					DEFB	45h	; E 
8fa2 46					DEFB	46h	; F 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fa3			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8fa3			;;    subtract $30, if result > 9 then subtract $7 more 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fa3			atohex: 
8fa3 d6 30				SUB $30 
8fa5 fe 0a				CP 10 
8fa7 f8					RET M		; If result negative it was 0-9 so we're done 
8fa8 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8faa c9					RET		 
8fab			 
8fab			 
8fab			 
8fab			 
8fab			; Get 2 ASCII characters as hex byte from pointer in hl 
8fab			 
8fab			BYTERD: 
8fab 16 00			LD	D,00h		;Set up 
8fad cd b5 8f			CALL	HEXCON		;Get byte and convert to hex 
8fb0 87				ADD	A,A		;First nibble so 
8fb1 87				ADD	A,A		;multiply by 16 
8fb2 87				ADD	A,A		; 
8fb3 87				ADD	A,A		; 
8fb4 57				LD	D,A		;Save hi nibble in D 
8fb5			HEXCON: 
8fb5 7e				ld a, (hl)		;Get next chr 
8fb6 23				inc hl 
8fb7 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8fb9 fe 0a			CP	00Ah		;Is it 0-9 ? 
8fbb 38 02			JR	C,NALPHA	;If so miss next bit 
8fbd d6 07			SUB	007h		;Else convert alpha 
8fbf			NALPHA: 
8fbf b2				OR	D		;Add hi nibble back 
8fc0 c9				RET			; 
8fc1			 
8fc1			 
8fc1			; 
8fc1			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8fc1			; Since the routines get_byte and therefore get_nibble are called, only valid 
8fc1			; characters (0-9a-f) are accepted. 
8fc1			; 
8fc1			;get_word        push    af 
8fc1			;                call    get_byte        ; Get the upper byte 
8fc1			;                ld      h, a 
8fc1			;                call    get_byte        ; Get the lower byte 
8fc1			;                ld      l, a 
8fc1			;                pop     af 
8fc1			;                ret 
8fc1			; 
8fc1			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8fc1			; the routine get_nibble is used only valid characters are accepted - the  
8fc1			; input routine only accepts characters 0-9a-f. 
8fc1			; 
8fc1 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8fc2 7e					ld a,(hl) 
8fc3 23					inc hl 
8fc4 cd e9 8f		                call    nibble2val      ; Get upper nibble 
8fc7 cb 07		                rlc     a 
8fc9 cb 07		                rlc     a 
8fcb cb 07		                rlc     a 
8fcd cb 07		                rlc     a 
8fcf 47			                ld      b, a            ; Save upper four bits 
8fd0 7e					ld a,(hl) 
8fd1 cd e9 8f		                call    nibble2val      ; Get lower nibble 
8fd4 b0			                or      b               ; Combine both nibbles 
8fd5 c1			                pop     bc              ; Restore B (and C) 
8fd6 c9			                ret 
8fd7			; 
8fd7			; Get a hexadecimal digit from the serial line. This routine blocks until 
8fd7			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8fd7			; to the serial line interface. The lower 4 bits of A contain the value of  
8fd7			; that particular digit. 
8fd7			; 
8fd7			;get_nibble      ld a,(hl)           ; Read a character 
8fd7			;                call    to_upper        ; Convert to upper case 
8fd7			;                call    is_hex          ; Was it a hex digit? 
8fd7			;                jr      nc, get_nibble  ; No, get another character 
8fd7			 ;               call    nibble2val      ; Convert nibble to value 
8fd7			 ;               call    print_nibble 
8fd7			 ;               ret 
8fd7			; 
8fd7			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8fd7			; A valid hexadecimal digit is denoted by a set C flag. 
8fd7			; 
8fd7			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8fd7			;                ret     nc              ; Yes 
8fd7			;                cp      '0'             ; Less than '0'? 
8fd7			;                jr      nc, is_hex_1    ; No, continue 
8fd7			;                ccf                     ; Complement carry (i.e. clear it) 
8fd7			;                ret 
8fd7			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8fd7			;                ret     c               ; Yes 
8fd7			;                cp      'A'             ; Less than 'A'? 
8fd7			;                jr      nc, is_hex_2    ; No, continue 
8fd7			;                ccf                     ; Yes - clear carry and return 
8fd7			;                ret 
8fd7			;is_hex_2        scf                     ; Set carry 
8fd7			;                ret 
8fd7			; 
8fd7			; Convert a single character contained in A to upper case: 
8fd7			; 
8fd7 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8fd9 d8			                ret     c 
8fda fe 7b		                cp      'z' + 1         ; > 'z'? 
8fdc d0			                ret     nc              ; Nothing to do, either 
8fdd e6 5f		                and     $5f             ; Convert to upper case 
8fdf c9			                ret 
8fe0			 
8fe0			 
8fe0			to_lower: 
8fe0			 
8fe0			   ; if char is in [A-Z] make it lower case 
8fe0			 
8fe0			   ; enter : a = char 
8fe0			   ; exit  : a = lower case char 
8fe0			   ; uses  : af 
8fe0			 
8fe0 fe 41		   cp 'A' 
8fe2 d8			   ret c 
8fe3			    
8fe3 fe 5b		   cp 'Z'+1 
8fe5 d0			   ret nc 
8fe6			    
8fe6 f6 20		   or $20 
8fe8 c9			   ret 
8fe9			 
8fe9			; 
8fe9			; Expects a hexadecimal digit (upper case!) in A and returns the 
8fe9			; corresponding value in A. 
8fe9			; 
8fe9 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8feb 38 02		                jr      c, nibble2val_1 ; Yes 
8fed d6 07		                sub     7               ; Adjust for A-F 
8fef d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8ff1 e6 0f		                and     $f              ; Only return lower 4 bits 
8ff3 c9			                ret 
8ff4			; 
8ff4			; Print_nibble prints a single hex nibble which is contained in the lower  
8ff4			; four bits of A: 
8ff4			; 
8ff4			;print_nibble    push    af              ; We won't destroy the contents of A 
8ff4			;                and     $f              ; Just in case... 
8ff4			;                add     a, '0'             ; If we have a digit we are done here. 
8ff4			;                cp      '9' + 1         ; Is the result > 9? 
8ff4			;                jr      c, print_nibble_1 
8ff4			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8ff4			;print_nibble_1  call    putc            ; Print the nibble and 
8ff4			;                pop     af              ; restore the original value of A 
8ff4			;                ret 
8ff4			;; 
8ff4			;; Send a CR/LF pair: 
8ff4			; 
8ff4			;crlf            push    af 
8ff4			;                ld      a, cr 
8ff4			;                call    putc 
8ff4			;                ld      a, lf 
8ff4			;                call    putc 
8ff4			;                pop     af 
8ff4			;                ret 
8ff4			; 
8ff4			; Print_word prints the four hex digits of a word to the serial line. The  
8ff4			; word is expected to be in HL. 
8ff4			; 
8ff4			;print_word      push    hl 
8ff4			;                push    af 
8ff4			;                ld      a, h 
8ff4			;                call    print_byte 
8ff4			;                ld      a, l 
8ff4			;                call    print_byte 
8ff4			;                pop     af 
8ff4			;                pop     hl 
8ff4			;                ret 
8ff4			; 
8ff4			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8ff4			; The byte to be printed is expected to be in A. 
8ff4			; 
8ff4			;print_byte      push    af              ; Save the contents of the registers 
8ff4			;                push    bc 
8ff4			;                ld      b, a 
8ff4			;                rrca 
8ff4			;                rrca 
8ff4			;                rrca 
8ff4			;                rrca 
8ff4			;                call    print_nibble    ; Print high nibble 
8ff4			;                ld      a, b 
8ff4			;                call    print_nibble    ; Print low nibble 
8ff4			;                pop     bc              ; Restore original register contents 
8ff4			;                pop     af 
8ff4			;                ret 
8ff4			 
8ff4			 
8ff4			 
8ff4			 
8ff4			 
8ff4			fourehexhl:  
8ff4 7e				ld a,(hl) 
8ff5 cd a3 8f			call atohex 
8ff8 cb 3f				SRL A 
8ffa cb 3f				SRL A 
8ffc cb 3f				SRL A 
8ffe cb 3f				SRL A 
9000 47				ld b, a 
9001 23				inc hl 
9002 7e				ld a,(hl) 
9003 23				inc hl 
9004 cd a3 8f			call atohex 
9007 80				add b 
9008 57				ld d,a 
9009 7e				ld a,(hl) 
900a cd a3 8f			call atohex 
900d cb 3f				SRL A 
900f cb 3f				SRL A 
9011 cb 3f				SRL A 
9013 cb 3f				SRL A 
9015 47				ld b, a 
9016 23				inc hl 
9017 7e				ld a,(hl) 
9018 23				inc hl 
9019 cd a3 8f			call atohex 
901c 80				add b 
901d 5f				ld e, a 
901e d5				push de 
901f e1				pop hl 
9020 c9				ret 
9021			 
9021			; pass hl. returns z set if the byte at hl is a digit 
9021			;isdigithl:  
9021			;	push bc 
9021			;	ld a,(hl) 
9021			;	cp ':' 
9021			;	jr nc, .isdf 		; > 
9021			;	cp '0' 
9021			;	jr c, .isdf		; < 
9021			; 
9021			;	; TODO find a better way to set z 
9021			; 
9021			;	ld b,a 
9021			;	cp b 
9021			;	pop bc 
9021			;	ret 
9021			; 
9021			;.isdf:	; not digit so clear z 
9021			; 
9021			;	; TODO find a better way to unset z 
9021			; 
9021			;	ld b,a 
9021			;	inc b 
9021			;	cp b 
9021			; 
9021			;	pop bc 
9021			;	ret 
9021				 
9021				 
9021			 
9021			 
9021			; pass hl as the four byte address to load 
9021			 
9021			get_word_hl:  
9021 e5				push hl 
9022 cd c1 8f			call get_byte 
9025				 
9025 47				ld b, a 
9026			 
9026 e1				pop hl 
9027 23				inc hl 
9028 23				inc hl 
9029			 
9029			; TODO not able to handle a-f  
9029 7e				ld a,(hl) 
902a			;	;cp ':' 
902a			;	cp 'g' 
902a			;	jr nc, .single_byte_hl 		; > 
902a			;	cp 'G' 
902a			;	jr nc, .single_byte_hl 		; > 
902a			;	cp '0' 
902a			;	jr c, .single_byte_hl		; < 
902a			 
902a				;call isdigithl 
902a fe 00			cp 0 
902c 28 06			jr z, .single_byte_hl 
902e			 
902e			.getwhln:   ; hex word so get next byte 
902e			 
902e cd c1 8f			call get_byte 
9031 6f				ld l, a 
9032 60				ld h,b 
9033 c9				ret 
9034 68			.single_byte_hl:   ld l,b 
9035 26 00				ld h,0 
9037 c9					ret 
9038			 
9038			 
9038			 
9038			 
9038 21 f3 97			ld hl,asc+1 
903b			;	ld a, (hl) 
903b			;	call nibble2val 
903b cd c1 8f			call get_byte 
903e			 
903e			;	call fourehexhl 
903e 32 36 e3			ld (scratch+52),a 
9041				 
9041 21 34 e3			ld hl,scratch+50 
9044 22 25 e6			ld (os_cur_ptr),hl 
9047			 
9047 c9				ret 
9048			 
9048			 
9048			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
9048			 
9048			; Decimal Unsigned Version 
9048			 
9048			;Number in a to decimal ASCII 
9048			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
9048			;Example: display a=56 as "056" 
9048			;input: a = number 
9048			;Output: a=0,value of a in the screen 
9048			;destroys af,bc (don't know about hl and de) 
9048			DispAToASCII: 
9048 0e 9c			ld	c,-100 
904a cd 54 90			call	.Na1 
904d 0e f6			ld	c,-10 
904f cd 54 90			call	.Na1 
9052 0e ff			ld	c,-1 
9054 06 2f		.Na1:	ld	b,'0'-1 
9056 04			.Na2:	inc	b 
9057 81				add	a,c 
9058 38 fc			jr	c,.Na2 
905a 91				sub	c		;works as add 100/10/1 
905b f5				push af		;safer than ld c,a 
905c 78				ld	a,b		;char is in b 
905d			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
905d f1				pop af		;safer than ld a,c 
905e c9				ret 
905f			 
905f			; Decimal Signed Version 
905f			 
905f			; DispA 
905f			; -------------------------------------------------------------- 
905f			; Converts a signed integer value to a zero-terminated ASCII 
905f			; string representative of that value (using radix 10). 
905f			; -------------------------------------------------------------- 
905f			; INPUTS: 
905f			;     HL     Value to convert (two's complement integer). 
905f			;     DE     Base address of string destination. (pointer). 
905f			; -------------------------------------------------------------- 
905f			; OUTPUTS: 
905f			;     None 
905f			; -------------------------------------------------------------- 
905f			; REGISTERS/MEMORY DESTROYED 
905f			; AF HL 
905f			; -------------------------------------------------------------- 
905f			 
905f			;DispHLToASCII: 
905f			;   push    de 
905f			;   push    bc 
905f			; 
905f			;; Detect sign of HL. 
905f			;    bit    7, h 
905f			;    jr     z, ._DoConvert 
905f			; 
905f			;; HL is negative. Output '-' to string and negate HL. 
905f			;    ld     a, '-' 
905f			;    ld     (de), a 
905f			;    inc    de 
905f			; 
905f			;; Negate HL (using two's complement) 
905f			;    xor    a 
905f			;    sub    l 
905f			;    ld     l, a 
905f			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
905f			;    sbc    a, h 
905f			;    ld     h, a 
905f			; 
905f			;; Convert HL to digit characters 
905f			;._DoConvert: 
905f			;    ld     b, 0     ; B will count character length of number 
905f			;-   ld     a, 10 
905f			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
905f			;    push   af 
905f			;    inc    b 
905f			;    ld     a, h 
905f			;    or     l 
905f			;    jr     nz, - 
905f			; 
905f			;; Retrieve digits from stack 
905f			;-   pop    af 
905f			;    or     $30 
905f			;    ld     (de), a 
905f			;    inc    de 
905f			;    djnz   - 
905f			; 
905f			;; Terminate string with NULL 
905f			;    xor    a 
905f			;    ld     (de), a 
905f			; 
905f			;    pop    bc 
905f			;    pop    de 
905f			;    ret 
905f			 
905f			;Comments 
905f			; 
905f			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
905f			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
905f			;    Note that the output string will not be fixed-width. 
905f			; 
905f			;Example Usage 
905f			; 
905f			;    ld    hl, -1004 
905f			;    ld    de, OP1 
905f			;    call  DispA 
905f			;    ld    hl, OP1 
905f			;    syscall  PutS 
905f			 
905f			 
905f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
905f			 
905f			 
905f			;Converts an ASCII string to an unsigned 16-bit integer 
905f			;Quits when it reaches a non-decimal digit 
905f			 
905f			string_to_uint16: 
905f			atoui_16: 
905f			;Input: 
905f			;     DE points to the string 
905f			;Outputs: 
905f			;     HL is the result 
905f			;     A is the 8-bit value of the number 
905f			;     DE points to the byte after the number 
905f			;Destroys: 
905f			;     BC 
905f			;       if the string is non-empty, BC is HL/10 
905f			;Size:  24 bytes 
905f			;Speed: 42+d(104+{0,9}) 
905f			;       d is the number of digits in the number 
905f			;       max is 640 cycles for a 5 digit number 
905f			;Assuming no leading zeros: 
905f			;1 digit:  146cc 
905f			;2 digit:  250cc 
905f			;3 digit:  354cc or 363cc (avg: 354.126cc) 
905f			;4 digit:  458cc or 467cc (avg: 458.27cc) 
905f			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
905f			;avg: 544.81158447265625cc (544+13297/16384) 
905f			;=============================================================== 
905f 21 00 00		  ld hl,0 
9062			.u16a: 
9062 1a			  ld a,(de) 
9063 d6 30		  sub 30h 
9065 fe 0a		  cp 10 
9067 d0			  ret nc 
9068 13			  inc de 
9069 44			  ld b,h 
906a 4d			  ld c,l 
906b 29			  add hl,hl 
906c 29			  add hl,hl 
906d 09			  add hl,bc 
906e 29			  add hl,hl 
906f 85			  add a,l 
9070 6f			  ld l,a 
9071 30 ef		  jr nc,.u16a 
9073 24			  inc h 
9074 c3 62 90		  jp .u16a 
9077			 
9077			 
9077			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9077			 
9077			;written by Zeda 
9077			;Converts a 16-bit unsigned integer to an ASCII string. 
9077			 
9077			uitoa_16: 
9077			;Input: 
9077			;   DE is the number to convert 
9077			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
9077			;Output: 
9077			;   HL points to the null-terminated ASCII string 
9077			;      NOTE: This isn't necessarily the same as the input HL. 
9077 d5			  push de 
9078 c5			  push bc 
9079 f5			  push af 
907a eb			  ex de,hl 
907b			 
907b 01 f0 d8		  ld bc,-10000 
907e 3e 2f		  ld a,'0'-1 
9080 3c			  inc a 
9081 09			  add hl,bc  
9082 38 fc		   jr c,$-2 
9084 12			  ld (de),a 
9085 13			  inc de 
9086			 
9086 01 e8 03		  ld bc,1000 
9089 3e 3a		  ld a,'9'+1 
908b 3d			  dec a  
908c 09			  add hl,bc  
908d 30 fc		   jr nc,$-2 
908f 12			  ld (de),a 
9090 13			  inc de 
9091			 
9091 01 9c ff		  ld bc,-100 
9094 3e 2f		  ld a,'0'-1 
9096 3c			  inc a  
9097 09			  add hl,bc  
9098 38 fc		   jr c,$-2 
909a 12			  ld (de),a 
909b 13			  inc de 
909c			 
909c 7d			  ld a,l 
909d 26 3a		  ld h,'9'+1 
909f 25			  dec h  
90a0 c6 0a		  add a,10  
90a2 30 fb		   jr nc,$-3 
90a4 c6 30		  add a,'0' 
90a6 eb			  ex de,hl 
90a7 72			  ld (hl),d 
90a8 23			  inc hl 
90a9 77			  ld (hl),a 
90aa 23			  inc hl 
90ab 36 00		  ld (hl),0 
90ad			 
90ad			;Now strip the leading zeros 
90ad 0e fa		  ld c,-6 
90af 09			  add hl,bc 
90b0 3e 30		  ld a,'0' 
90b2 23			  inc hl  
90b3 be			  cp (hl)  
90b4 28 fc		  jr z,$-2 
90b6			 
90b6			;Make sure that the string is non-empty! 
90b6 7e			  ld a,(hl) 
90b7 b7			  or a 
90b8 20 01		  jr nz,.atoub 
90ba 2b			  dec hl 
90bb			.atoub: 
90bb			 
90bb f1			  pop af 
90bc c1			  pop bc 
90bd d1			  pop de 
90be c9			  ret 
90bf			 
90bf			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
90bf			 
90bf			toUpper: 
90bf			;A is the char. 
90bf			;If A is a lowercase letter, this sets it to the matching uppercase 
90bf			;18cc or 30cc or 41cc 
90bf			;avg: 26.75cc 
90bf fe 61		  cp 'a' 
90c1 d8			  ret c 
90c2 fe 7b		  cp 'z'+1 
90c4 d0			  ret nc 
90c5 d6 20		  sub 'a'-'A' 
90c7 c9			  ret 
90c8			 
90c8			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
90c8			 
90c8			; String Length 
90c8			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
90c8			 
90c8			; Get the length of the null-terminated string starting at $8000 hl 
90c8			;    LD     HL, $8000 
90c8			 
90c8			strlenz: 
90c8			 
90c8 af			    XOR    A               ; Zero is the value we are looking for. 
90c9 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
90ca 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
90cb			                           ; 65, 536 bytes (the entire addressable memory space). 
90cb ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
90cd			 
90cd			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
90cd 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
90ce 6f			    LD     L, A             ; number of bytes 
90cf ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
90d1 2b			    DEC    HL              ; Compensate for null. 
90d2 c9				ret 
90d3			 
90d3			; Get the length of the A terminated string starting at $8000 hl 
90d3			;    LD     HL, $8000 
90d3			 
90d3			strlent: 
90d3			 
90d3			                  ; A is the value we are looking for. 
90d3 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
90d5 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
90d7			                           ; 65, 536 bytes (the entire addressable memory space). 
90d7 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
90d9			 
90d9			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
90d9 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
90db 2e 00		    LD     L, 0             ; number of bytes 
90dd ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
90df 2b			    DEC    HL              ; Compensate for null. 
90e0 c9				ret 
90e1			 
90e1			 
90e1			;Comparing Strings 
90e1			 
90e1			;IN    HL     Address of string1. 
90e1			;      DE     Address of string2. 
90e1			 
90e1			; doc given but wrong??? 
90e1			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
90e1			;      carry  Set if string1 > string2, reset if string1 <= string2. 
90e1			; tested 
90e1			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
90e1			 
90e1			strcmp_old: 
90e1 e5			    PUSH   HL 
90e2 d5			    PUSH   DE 
90e3			 
90e3 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
90e4 be			    CP     (HL)            ; (want to minimize work). 
90e5 38 01		    JR     C, Str1IsBigger 
90e7 7e			    LD     A, (HL) 
90e8			 
90e8			Str1IsBigger: 
90e8 4f			    LD     C, A             ; Put length in BC 
90e9 06 00		    LD     B, 0 
90eb 13			    INC    DE              ; Increment pointers to meat of string. 
90ec 23			    INC    HL 
90ed			 
90ed			CmpLoop: 
90ed 1a			    LD     A, (DE)          ; Compare bytes. 
90ee ed a1		    CPI 
90f0 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
90f2 13			    INC    DE              ; Update pointer. 
90f3 ea ed 90		    JP     PE, CmpLoop 
90f6			 
90f6 d1			    POP    DE 
90f7 e1			    POP    HL 
90f8 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
90f9 be			    CP     (HL) 
90fa c9			    RET 
90fb			 
90fb			NoMatch: 
90fb 2b			    DEC    HL 
90fc be			    CP     (HL)            ; Compare again to affect carry. 
90fd d1			    POP    DE 
90fe e1			    POP    HL 
90ff c9			    RET 
9100			 
9100			;; test strmp 
9100			; 
9100			;ld de, .str1 
9100			;ld hl, .str2 
9100			;call strcmp 
9100			;jr z, .z1 
9100			;;this 
9100			;	if DEBUG_FORTH_WORDS 
9100			;		DMARK "NZ1" 
9100			;		CALLMONITOR 
9100			;	endif 
9100			;.z1: 
9100			; 
9100			;	if DEBUG_FORTH_WORDS 
9100			;		DMARK "ZZ1" 
9100			;		CALLMONITOR 
9100			;	endif 
9100			; 
9100			;ld de, .str1 
9100			;ld hl, .str1 
9100			;call strcmp 
9100			;jr z, .z2 
9100			;;this 
9100			;	if DEBUG_FORTH_WORDS 
9100			;		DMARK "NZ2" 
9100			;		CALLMONITOR 
9100			;	endif 
9100			;.z2: 
9100			; 
9100			;	if DEBUG_FORTH_WORDS 
9100			;		DMARK "ZZ2" 
9100			;		CALLMONITOR 
9100			;	endif 
9100			; 
9100			;ld de, .str1 
9100			;ld hl, .str2 
9100			;call strcmp 
9100			;jr c, .c1 
9100			; 
9100			;	if DEBUG_FORTH_WORDS 
9100			;		DMARK "Nc1" 
9100			;		CALLMONITOR 
9100			;	endif 
9100			;.c1: 
9100			;;this 
9100			;	if DEBUG_FORTH_WORDS 
9100			;		DMARK "cc1" 
9100			;		CALLMONITOR 
9100			;	endif 
9100			; 
9100			;ld de, .str1 
9100			;ld hl, .str1 
9100			;call strcmp 
9100			;jr c, .c2 
9100			;;this 
9100			;	if DEBUG_FORTH_WORDS 
9100			;		DMARK "Nc2" 
9100			;		CALLMONITOR 
9100			;	endif 
9100			;.c2: 
9100			; 
9100			;	if DEBUG_FORTH_WORDS 
9100			;		DMARK "cc2" 
9100			;		CALLMONITOR 
9100			;	endif 
9100			;	NEXTW 
9100			;.str1:   db "string1",0 
9100			;.str2:   db "string2",0 
9100			 
9100			; only care about direct match or not 
9100			; hl and de strings 
9100			; zero set if the same 
9100			 
9100			strcmp: 
9100 1a				ld a, (de) 
9101 be				cp (hl) 
9102 28 02			jr z, .ssame 
9104 b7				or a 
9105 c9				ret 
9106			 
9106			.ssame:  
9106 fe 00			cp 0 
9108 c8				ret z 
9109			 
9109 23				inc hl 
910a 13				inc de 
910b 18 f3			jr strcmp 
910d				 
910d				 
910d			 
910d			 
910d			 
910d			 
910d			; eof 
910d			 
910d			 
910d			 
910d			 
910d			 
910d			 
# End of file firmware_strings.asm
910d			include "firmware_memory.asm"   ; malloc and free  
910d			 
910d			if DEBUG_FORTH_MALLOC_HIGH 
910d			.mallocsize: db "Wants malloc >256",0 
910d			.mallocasize: db "MALLOC gives >256",0 
910d			.malloczero: db "MALLOC gives zero",0 
910d			 
910d			malloc_guard_zerolen: 
910d				push hl 
910d				push de 
910d				push af 
910d			 
910d				ld de, 0 
910d			        call cmp16 
910d				jr nz, .lowalloz 
910d			 
910d				push hl 
910d				push de 
910d					ld hl, display_fb0 
910d					ld (display_fb_active), hl 
910d				call clear_display 
910d				ld a, 0 
910d				ld de, .malloczero 
910d				call str_at_display 
910d				call update_display 
910d				call delay1s 
910d				call delay1s 
910d				ld a, 0 
910d				ld (os_view_disable), a 
910d			 
910d				pop de 
910d				pop hl 
910d			 
910d				 
910d			 
910d				CALLMONITOR 
910d			.lowalloz: 
910d			 
910d			 
910d				pop af 
910d				pop de 
910d				pop hl 
910d			ret 
910d			 
910d			malloc_guard_entry: 
910d				push hl 
910d				push de 
910d				push af 
910d			 
910d			 	or a      ;clear carry flag 
910d				push hl 
910d				ld de, 255 
910d				sbc hl, de 
910d				jr c, .lowalloc 
910d			 
910d				push de 
910d					ld hl, display_fb0 
910d					ld (display_fb_active), hl 
910d				call clear_display 
910d				ld a, 0 
910d				ld de, .mallocsize 
910d				call str_at_display 
910d				call update_display 
910d				call delay1s 
910d				call delay1s 
910d				ld a, 0 
910d				ld (os_view_disable), a 
910d			 
910d				pop de 
910d				pop hl 
910d			 
910d				 
910d			 
910d				CALLMONITOR 
910d				jr .lowdone 
910d			.lowalloc: 
910d			 
910d			 
910d				pop hl 
910d			.lowdone:	pop af 
910d				pop de 
910d				pop hl 
910d			ret 
910d			 
910d			malloc_guard_exit: 
910d				push hl 
910d				push de 
910d				push af 
910d			 
910d			 	or a      ;clear carry flag 
910d				push hl 
910d				ld de, 255 
910d				sbc hl, de 
910d				jr c, .lowallocx 
910d			 
910d				push de 
910d					ld hl, display_fb0 
910d					ld (display_fb_active), hl 
910d				call clear_display 
910d				ld a, 0 
910d				ld de, .mallocasize 
910d				call str_at_display 
910d				call update_display 
910d				call delay1s 
910d				call delay1s 
910d				ld a, 0 
910d				ld (os_view_disable), a 
910d				pop de 
910d				pop hl 
910d			 
910d				CALLMONITOR 
910d				jr .lowdonex 
910d			.lowallocx: 
910d			 
910d				pop hl 
910d			.lowdonex:	pop af 
910d				pop de 
910d				pop hl 
910d			ret 
910d			endif 
910d			 
910d			if MALLOC_2 
910d			; Z80 Malloc and Free Functions 
910d			 
910d			; Malloc Function: 
910d			; Input: 
910d			;   HL: Size of block to allocate 
910d			; Output: 
910d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
910d			 
910d			malloc: 
910d				 
910d			if DEBUG_FORTH_MALLOC_HIGH 
910d			call malloc_guard_entry 
910d			endif 
910d			 
910d			 
910d			 
910d			 
910d					if DEBUG_FORTH_MALLOC 
910d						DMARK "mal" 
910d						CALLMONITOR 
910d					endif 
910d			    push af            ; Save AF register 
910d			    ld a, l            ; Load low byte of size into A 
910d			    or h               ; Check if size is zero 
910d			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
910d			 
910d			    ; Allocate memory 
910d			    ld hl, (heap_start) ; Load start of heap into HL 
910d					if DEBUG_FORTH_MALLOC 
910d						DMARK "ma1" 
910d						CALLMONITOR 
910d					endif 
910d			    call malloc_internal ; Call internal malloc function 
910d			    pop af             ; Restore AF register 
910d			if DEBUG_FORTH_MALLOC_HIGH 
910d			call malloc_guard_exit 
910d			call malloc_guard_zerolen 
910d			endif 
910d			    ret                ; Return 
910d			 
910d			; Free Function: 
910d			; Input: 
910d			;   HL: Pointer to memory block to free 
910d			; Output: 
910d			;   None 
910d			 
910d			free: 
910d			    push af            ; Save AF register 
910d			    ld a, l            ; Load low byte of pointer into A 
910d			    or h               ; Check if pointer is NULL 
910d			    jp z, free_exit    ; If pointer is NULL, exit 
910d			 
910d			    ; Free memory 
910d			    ld hl, (heap_start) ; Load start of heap into HL 
910d			    call free_internal  ; Call internal free function 
910d			    pop af             ; Restore AF register 
910d			    ret                ; Return 
910d			 
910d			; Internal Malloc Function: 
910d			; Input: 
910d			;   HL: Size of block to allocate 
910d			; Output: 
910d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
910d			 
910d			malloc_internal: 
910d			    ld bc, 2           ; Number of bytes to allocate for management overhead 
910d			    add hl, bc         ; Add management overhead to requested size 
910d			    ex de, hl          ; Save total size in DE, and keep it in HL 
910d					if DEBUG_FORTH_MALLOC 
910d						DMARK "ma2" 
910d						CALLMONITOR 
910d					endif 
910d			 
910d			    ; Search for free memory block 
910d			    ld de, (heap_end)  ; Load end of heap into DE 
910d			    ld bc, 0           ; Initialize counter 
910d			 
910d					if DEBUG_FORTH_MALLOC 
910d						DMARK "ma2" 
910d						CALLMONITOR 
910d					endif 
910d			malloc_search_loop: 
910d			    ; Check if current block is free 
910d			    ld a, (hl)         ; Load current block's status (free or used) 
910d			    cp 0               ; Compare with zero (free) 
910d			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
910d			 
910d			    ; Check if current block is large enough 
910d			    ld a, (hl+1)       ; Load high byte of block size 
910d			    cp l               ; Compare with low byte of requested size 
910d			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
910d			 
910d			    ld a, (hl+2)       ; Load low byte of block size 
910d			    cp h               ; Compare with high byte of requested size 
910d			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
910d			 
910d			    ; Mark block as used 
910d			    ld (hl), 0xFF      ; Set status byte to indicate used block 
910d			 
910d			    ; Calculate remaining space in block 
910d			    ld bc, 0           ; Clear BC 
910d			    add hl, bc         ; Increment HL to point to start of data block 
910d			    add hl, de         ; HL = HL + DE (total size) 
910d			    ld bc, 1           ; Number of bytes to allocate for management overhead 
910d			    add hl, bc         ; Add management overhead to start of data block 
910d			 
910d			    ; Save pointer to allocated block in HL 
910d			if DEBUG_FORTH_MALLOC_HIGH 
910d						DMARK "ma5" 
910d			call malloc_guard_exit 
910d			call malloc_guard_zerolen 
910d			endif 
910d			    ret 
910d			 
910d			malloc_skip_block_check: 
910d			    ; Move to the next block 
910d			    ld bc, 3           ; Size of management overhead 
910d			    add hl, bc         ; Move to the next block 
910d			    inc de             ; Increment counter 
910d			 
910d			    ; Check if we have reached the end of heap 
910d			    ld a, e            ; Load low byte of heap end address 
910d			    cp (hl)            ; Compare with low byte of current address 
910d			    jr nz, malloc_search_loop  ; If not equal, continue searching 
910d			    ld a, d            ; Load high byte of heap end address 
910d			    cp 0               ; Check if it's zero (end of memory) 
910d			    jr nz, malloc_search_loop  ; If not zero, continue searching 
910d			 
910d			    ; If we reached here, allocation failed 
910d			    xor a              ; Set result to NULL 
910d			if DEBUG_FORTH_MALLOC_HIGH 
910d						DMARK "ma6" 
910d			call malloc_guard_exit 
910d			call malloc_guard_zerolen 
910d			endif 
910d			    ret 
910d			malloc_exit: 
910d			if DEBUG_FORTH_MALLOC_HIGH 
910d						DMARK "ma7" 
910d			call malloc_guard_exit 
910d			call malloc_guard_zerolen 
910d			endif 
910d			    ret 
910d			 
910d			; Internal Free Function: 
910d			; Input: 
910d			;   HL: Pointer to memory block to free 
910d			; Output: 
910d			;   None 
910d			 
910d			free_internal: 
910d			    ld de, (heap_start) ; Load start of heap into DE 
910d			    ld bc, 0            ; Initialize counter 
910d			 
910d			free_search_loop: 
910d			    ; Check if current block contains the pointer 
910d			    ld a, l             ; Load low byte of pointer 
910d			    cp (hl+1)           ; Compare with high byte of current block's address 
910d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
910d			    ld a, h             ; Load high byte of pointer 
910d			    cp (hl+2)           ; Compare with low byte of current block's address 
910d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
910d			 
910d			    ; Mark block as free 
910d			    ld (hl), 0          ; Set status byte to indicate free block 
910d			    ret                 ; Return 
910d			 
910d			free_skip_block_check: 
910d			    ; Move to the next block 
910d			    ld bc, 3            ; Size of management overhead 
910d			    add hl, bc          ; Move to the next block 
910d			    inc de              ; Increment counter 
910d			 
910d			    ; Check if we have reached the end of heap 
910d			    ld a, e             ; Load low byte of heap end address 
910d			    cp (hl)             ; Compare with low byte of current address 
910d			    jr nz, free_search_loop  ; If not equal, continue searching 
910d			    ld a, d             ; Load high byte of heap end address 
910d			    cp 0                ; Check if it's zero (end of memory) 
910d			    jr nz, free_search_loop  ; If not zero, continue searching 
910d			 
910d			    ; If we reached here, pointer is not found in heap 
910d			    ret 
910d			 
910d			free_exit: 
910d			    ret                 ; Return 
910d			 
910d			; Define heap start and end addresses 
910d			;heap_start:    .dw 0xC000   ; Start of heap 
910d			;heap_end:      .dw 0xE000   ; End of heap 
910d			 
910d			endif 
910d			 
910d			 
910d			if MALLOC_1 
910d			 
910d			 
910d			 
910d			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
910d			 
910d			;moved to firmware.asm 
910d			;heap_start        .equ  0x9000      ; Starting address of heap 
910d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
910d			 
910d			;      .org 0 
910d			;      jp    main 
910d			 
910d			 
910d			;      .org  0x100 
910d			;main: 
910d			;      ld    HL, 0x8100 
910d			;      ld    SP, HL 
910d			; 
910d			;      call  heap_init 
910d			; 
910d			;      ; Make some allocations 
910d			;      ld    HL, 12 
910d			;      call  malloc            ; Allocates 0x9004 
910d			; 
910d			;      ld    HL, 12 
910d			;      call  malloc            ; Allocates 0x9014 
910d			; 
910d			;      ld    HL, 12 
910d			;      call  malloc            ; Allocates 0x9024 
910d			; 
910d			;      ; Free some allocations 
910d			;      ld    HL, 0x9014 
910d			;      call  free 
910d			; 
910d			;      ld    HL, 0x9004 
910d			;      call  free 
910d			; 
910d			;      ld    HL, 0x9024 
910d			;      call  free 
910d			; 
910d			; 
910d			;      halt 
910d			 
910d			 
910d			;------------------------------------------------------------------------------ 
910d			;     heap_init                                                               : 
910d			;                                                                             : 
910d			; Description                                                                 : 
910d			;     Initialise the heap and make it ready for malloc and free operations.   : 
910d			;                                                                             : 
910d			;     The heap is maintained as a linked list, starting with an initial       : 
910d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
910d			;     the first free block in the heap. Each block then points to the next    : 
910d			;     free block within the heap, and the free list ends at the first block   : 
910d			;     with a null pointer to the next free block.                             : 
910d			;                                                                             : 
910d			; Parameters                                                                  : 
910d			;     Inputs are compile-time only. Two defines which specify the starting    : 
910d			;     address of the heap and its size are required, along with a memory      : 
910d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
910d			;     principally stores a pointer to the first free block in the heap.       : 
910d			;                                                                             : 
910d			; Returns                                                                     : 
910d			;     Nothing                                                                 : 
910d			;------------------------------------------------------------------------------ 
910d			heap_init: 
910d e5			      push  HL 
910e			 
910e			      ; Initialise free list struct 
910e 21 62 da		      ld    HL, heap_start 
9111 22 5d da		      ld    (free_list), HL 
9114 21 00 00		      ld    HL, 0 
9117 22 5f da		      ld    (free_list+2), HL 
911a			 
911a			      ; Insert first free block at bottom of heap, consumes entire heap 
911a 21 e4 e2		      ld    HL, heap_start+heap_size-4 
911d 22 62 da		      ld    (heap_start), HL        ; Next block (end of free list) 
9120 21 82 08		      ld    HL, heap_size-4 
9123 22 64 da		      ld    (heap_start+2), HL      ; Block size 
9126			 
9126			      ; Insert end of free list block at top of heap - two null words will 
9126			      ; terminate the free list 
9126 21 00 00		      ld    HL, 0 
9129 22 e6 e2		      ld    (heap_start+heap_size-2), HL 
912c 22 e4 e2		      ld    (heap_start+heap_size-4), HL 
912f			 
912f e1			      pop   HL 
9130			 
9130 c9			      ret 
9131			 
9131			 
9131			;------------------------------------------------------------------------------ 
9131			;     malloc                                                                  : 
9131			;                                                                             : 
9131			; Description                                                                 : 
9131			;     Allocates the wanted space from the heap and returns the address of the : 
9131			;     first useable byte of the allocation.                                   : 
9131			;                                                                             : 
9131			;     Allocations can happen in one of two ways:                              : 
9131			;                                                                             : 
9131			;     1. A free block may be found which is the exact size wanted. In this    : 
9131			;        case the block is removed from the free list and retuedn to the      : 
9131			;        caller.                                                              : 
9131			;     2. A free block may be found which is larger than the size wanted. In   : 
9131			;        this case, the larger block is split into two. The first portion of  : 
9131			;        this block will become the requested space by the malloc call and    : 
9131			;        is returned to the caller. The second portion becomes a new free     : 
9131			;        block, and the free list is adjusted to maintain continuity via this : 
9131			;        newly created block.                                                 : 
9131			;                                                                             : 
9131			;     malloc does not set any initial value in the allocated space, the       : 
9131			;     caller is required to do this as required.                              : 
9131			;                                                                             : 
9131			;     This implementation of malloc uses the stack exclusively, and is        : 
9131			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9131			;     advisable to disable interrupts before calling malloc, and recommended  : 
9131			;     to avoid the use of malloc inside ISRs in general.                      : 
9131			;                                                                             : 
9131			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9131			;                                                                             : 
9131			; Parameters                                                                  : 
9131			;     HL  Number of bytes wanted                                              : 
9131			;                                                                             : 
9131			; Returns                                                                     : 
9131			;     HL  Address of the first useable byte of the allocation                 : 
9131			;                                                                             : 
9131			; Flags                                                                       : 
9131			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9131			;                                                                             : 
9131			; Stack frame                                                                 : 
9131			;       |             |                                                       : 
9131			;       +-------------+                                                       : 
9131			;       |     BC      |                                                       : 
9131			;       +-------------+                                                       : 
9131			;       |     DE      |                                                       : 
9131			;       +-------------+                                                       : 
9131			;       |     IX      |                                                       : 
9131			;       +-------------+                                                       : 
9131			;       |  prev_free  |                                                       : 
9131			;   +4  +-------------+                                                       : 
9131			;       |  this_free  |                                                       : 
9131			;   +2  +-------------+                                                       : 
9131			;       |  next_free  |                                                       : 
9131			;   +0  +-------------+                                                       : 
9131			;       |             |                                                       : 
9131			;                                                                             : 
9131			;------------------------------------------------------------------------------ 
9131			 
9131			 
9131			;malloc: 
9131			; 
9131			;	SAVESP ON 1 
9131			; 
9131			;	call malloc_code 
9131			; 
9131			;	CHECKSP ON 1 
9131			;	ret 
9131			 
9131			 
9131			malloc: 
9131 c5			      push  BC 
9132 d5			      push  DE 
9133 dd e5		      push  IX 
9135			if DEBUG_FORTH_MALLOC_HIGH 
9135			call malloc_guard_entry 
9135			endif 
9135			 
9135					if DEBUG_FORTH_MALLOC 
9135						DMARK "mal" 
9135						CALLMONITOR 
9135					endif 
9135 7c			      ld    A, H                    ; Exit if no space requested 
9136 b5			      or    L 
9137 ca f6 91		      jp    Z, malloc_early_exit 
913a			 
913a			;inc hl 
913a			;inc hl 
913a			;inc hl 
913a			; 
913a			;inc hl 
913a			;inc hl 
913a			;inc hl 
913a			;inc hl 
913a			;inc hl 
913a			;inc hl 
913a			;inc hl 
913a			;inc hl 
913a			;inc hl 
913a			 
913a			 
913a			 
913a			 
913a					if DEBUG_FORTH_MALLOC 
913a						DMARK "maA" 
913a						CALLMONITOR 
913a					endif 
913a			      ; Set up stack frame 
913a eb			      ex    DE, HL 
913b 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
913e 39			      add   HL, SP 
913f f9			      ld    SP, HL 
9140 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9144 dd 39		      add   IX, SP 
9146			 
9146			      ; Setup initial state 
9146 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
9149 19			      add   HL, DE 
914a			 
914a 44			      ld    B, H                    ; Move want to BC 
914b 4d			      ld    C, L 
914c			 
914c 21 5d da		      ld    HL, free_list           ; Store prev_free ptr to stack 
914f dd 75 04		      ld    (IX+4), L 
9152 dd 74 05		      ld    (IX+5), H 
9155			 
9155 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
9156 23			      inc   HL 
9157 56			      ld    D, (HL) 
9158 dd 73 02		      ld    (IX+2), E 
915b dd 72 03		      ld    (IX+3), D 
915e eb			      ex    DE, HL                  ; this_free ptr into HL 
915f			 
915f					if DEBUG_FORTH_MALLOC 
915f						DMARK "maB" 
915f						CALLMONITOR 
915f					endif 
915f			      ; Loop through free block list to find some space 
915f			malloc_find_space: 
915f 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
9160 23			      inc   HL 
9161 56			      ld    D, (HL) 
9162			 
9162 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9163 b3			      or    E 
9164 ca f0 91		      jp    Z, malloc_no_space 
9167			 
9167 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
916a dd 72 01		      ld    (IX+1), D 
916d			 
916d			      ; Does this block have enough space to make the allocation? 
916d 23			      inc   HL                      ; Load free block size into DE 
916e 5e			      ld    E, (HL) 
916f 23			      inc   HL 
9170 56			      ld    D, (HL) 
9171			 
9171 eb			      ex    DE, HL                  ; Check size of block against want 
9172 b7			      or    A                       ; Ensure carry flag clear 
9173 ed 42		      sbc   HL, BC 
9175 e5			      push  HL                      ; Store the result for later (new block size) 
9176			 
9176 ca c5 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9179 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
917b			 
917b			      ; this_free block is not big enough, setup ptrs to test next free block 
917b e1			      pop   HL                      ; Discard previous result 
917c			 
917c dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
917f dd 66 03		      ld    H, (IX+3) 
9182 dd 75 04		      ld    (IX+4), L 
9185 dd 74 05		      ld    (IX+5), H 
9188			 
9188 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
918b dd 66 01		      ld    H, (IX+1) 
918e dd 75 02		      ld    (IX+2), L 
9191 dd 74 03		      ld    (IX+3), H 
9194			 
9194					if DEBUG_FORTH_MALLOC 
9194						DMARK "MA>" 
9194						CALLMONITOR 
9194					endif 
9194 18 c9		      jr    malloc_find_space 
9196			 
9196			      ; split a bigger block into two - requested size and remaining size 
9196			malloc_alloc_split: 
9196					if DEBUG_FORTH_MALLOC 
9196						DMARK "MAs" 
9196						CALLMONITOR 
9196					endif 
9196 eb			      ex    DE, HL                  ; Calculate address of new free block 
9197 2b			      dec   HL 
9198 2b			      dec   HL 
9199 2b			      dec   HL 
919a 09			      add   HL, BC 
919b			 
919b			      ; Create a new block and point it at next_free 
919b dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
919e dd 56 01		      ld    D, (IX+1) 
91a1			 
91a1 73			      ld    (HL), E                 ; Store next_free ptr into new block 
91a2 23			      inc   HL 
91a3 72			      ld    (HL), D 
91a4			 
91a4 d1			      pop   DE                      ; Store size of new block into new block 
91a5 23			      inc   HL 
91a6 73			      ld    (HL), E 
91a7 23			      inc   HL 
91a8 72			      ld    (HL), D 
91a9			 
91a9			      ; Update this_free ptr to point to new block 
91a9 2b			      dec   HL 
91aa 2b			      dec   HL 
91ab 2b			      dec   HL 
91ac			 
91ac dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
91af dd 56 03		      ld    D, (IX+3) 
91b2			 
91b2 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
91b5 dd 74 03		      ld    (IX+3), H 
91b8			 
91b8			      ; Modify this_free block to be allocation 
91b8 eb			      ex    DE, HL 
91b9 af			      xor   A                       ; Null the next block ptr of allocated block 
91ba 77			      ld    (HL), A 
91bb 23			      inc   HL 
91bc 77			      ld    (HL), A 
91bd			 
91bd 23			      inc   HL                      ; Store want size into allocated block 
91be 71			      ld    (HL), C 
91bf 23			      inc   HL 
91c0 70			      ld    (HL), B 
91c1 23			      inc   HL 
91c2 e5			      push  HL                      ; Address of allocation to return 
91c3			 
91c3 18 19		      jr    malloc_update_links 
91c5			 
91c5			malloc_alloc_fit: 
91c5 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
91c6			 
91c6					if DEBUG_FORTH_MALLOC 
91c6						DMARK "MAf" 
91c6						CALLMONITOR 
91c6					endif 
91c6			      ; Modify this_free block to be allocation 
91c6 eb			      ex    DE, HL 
91c7 2b			      dec   HL 
91c8 2b			      dec   HL 
91c9 2b			      dec   HL 
91ca			 
91ca af			      xor   A                       ; Null the next block ptr of allocated block 
91cb 77			      ld    (HL), A 
91cc 23			      inc   HL 
91cd 77			      ld    (HL), A 
91ce			 
91ce 23			      inc   HL                      ; Store address of allocation to return 
91cf 23			      inc   HL 
91d0 23			      inc   HL 
91d1 e5			      push  HL 
91d2			 
91d2			      ; Copy next_free ptr to this_free, remove allocated block from free list 
91d2 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
91d5 dd 66 01		      ld    H, (IX+1) 
91d8			 
91d8 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
91db dd 74 03		      ld    (IX+3), H 
91de			 
91de			 
91de			malloc_update_links: 
91de			      ; Update prev_free ptr to point to this_free 
91de dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
91e1 dd 66 05		      ld    H, (IX+5) 
91e4			 
91e4 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
91e7 dd 56 03		      ld    D, (IX+3) 
91ea			 
91ea 73			      ld    (HL), E                 ; this_free ptr into prev_free 
91eb 23			      inc   HL 
91ec 72			      ld    (HL), D 
91ed			 
91ed					if DEBUG_FORTH_MALLOC 
91ed						DMARK "Mul" 
91ed						CALLMONITOR 
91ed					endif 
91ed			      ; Clear the Z flag to indicate successful allocation 
91ed 7a			      ld    A, D 
91ee b3			      or    E 
91ef			 
91ef d1			      pop   DE                      ; Address of allocation 
91f0					if DEBUG_FORTH_MALLOC 
91f0						DMARK "MAu" 
91f0						CALLMONITOR 
91f0					endif 
91f0			 
91f0			malloc_no_space: 
91f0 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
91f3 39			      add   HL, SP 
91f4 f9			      ld    SP, HL 
91f5			 
91f5 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
91f6					if DEBUG_FORTH_MALLOC 
91f6						DMARK "MAN" 
91f6						CALLMONITOR 
91f6					endif 
91f6			 
91f6			malloc_early_exit: 
91f6					if DEBUG_FORTH_MALLOC 
91f6						DMARK "MAx" 
91f6						CALLMONITOR 
91f6					endif 
91f6 dd e1		      pop   IX 
91f8 d1			      pop   DE 
91f9 c1			      pop   BC 
91fa			 
91fa			if DEBUG_FORTH_MALLOC_HIGH 
91fa			call malloc_guard_exit 
91fa			call malloc_guard_zerolen 
91fa			endif 
91fa c9			      ret 
91fb			 
91fb			 
91fb			;------------------------------------------------------------------------------ 
91fb			;     free                                                                    : 
91fb			;                                                                             : 
91fb			; Description                                                                 : 
91fb			;     Return the space pointed to by HL to the heap. HL must be an address as : 
91fb			;     returned by malloc, otherwise the behaviour is undefined.               : 
91fb			;                                                                             : 
91fb			;     Where possible, directly adjacent free blocks will be merged together   : 
91fb			;     into larger blocks to help ensure that the heap does not become         : 
91fb			;     excessively fragmented.                                                 : 
91fb			;                                                                             : 
91fb			;     free does not clear or set any other value into the freed space, and    : 
91fb			;     therefore its contents may be visible through subsequent malloc's. The  : 
91fb			;     caller should clear the freed space as required.                        : 
91fb			;                                                                             : 
91fb			;     This implementation of free uses the stack exclusively, and is          : 
91fb			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91fb			;     advisable to disable interrupts before calling free, and recommended    : 
91fb			;     to avoid the use of free inside ISRs in general.                        : 
91fb			;                                                                             : 
91fb			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91fb			;                                                                             : 
91fb			; Parameters                                                                  : 
91fb			;     HL  Pointer to address of first byte of allocation to be freed          : 
91fb			;                                                                             : 
91fb			; Returns                                                                     : 
91fb			;     Nothing                                                                 : 
91fb			;                                                                             : 
91fb			; Stack frame                                                                 : 
91fb			;       |             |                                                       : 
91fb			;       +-------------+                                                       : 
91fb			;       |     BC      |                                                       : 
91fb			;       +-------------+                                                       : 
91fb			;       |     DE      |                                                       : 
91fb			;       +-------------+                                                       : 
91fb			;       |     IX      |                                                       : 
91fb			;       +-------------+                                                       : 
91fb			;       |  prev_free  |                                                       : 
91fb			;   +2  +-------------+                                                       : 
91fb			;       |  next_free  |                                                       : 
91fb			;   +0  +-------------+                                                       : 
91fb			;       |             |                                                       : 
91fb			;                                                                             : 
91fb			;------------------------------------------------------------------------------ 
91fb			free: 
91fb c5			      push  BC 
91fc d5			      push  DE 
91fd dd e5		      push  IX 
91ff			 
91ff 7c			      ld    A, H                    ; Exit if ptr is null 
9200 b5			      or    L 
9201 ca c5 92		      jp    Z, free_early_exit 
9204			 
9204			      ; Set up stack frame 
9204 eb			      ex    DE, HL 
9205 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9208 39			      add   HL, SP 
9209 f9			      ld    SP, HL 
920a dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
920e dd 39		      add   IX, SP 
9210			 
9210			      ; The address in HL points to the start of the useable allocated space, 
9210			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9210			      ; address of the block itself. 
9210 eb			      ex    DE, HL 
9211 11 fc ff		      ld    DE, -4 
9214 19			      add   HL, DE 
9215			 
9215			      ; An allocated block must have a null next block pointer in it 
9215 7e			      ld    A, (HL) 
9216 23			      inc   HL 
9217 b6			      or    (HL) 
9218 c2 c0 92		      jp    NZ, free_done 
921b			 
921b 2b			      dec   HL 
921c			 
921c 44			      ld    B, H                    ; Copy HL to BC 
921d 4d			      ld    C, L 
921e			 
921e			      ; Loop through the free list to find the first block with an address 
921e			      ; higher than the block being freed 
921e 21 5d da		      ld    HL, free_list 
9221			 
9221			free_find_higher_block: 
9221 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9222 23			      inc   HL 
9223 56			      ld    D, (HL) 
9224 2b			      dec   HL 
9225			 
9225 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9228 dd 72 01		      ld    (IX+1), D 
922b dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
922e dd 74 03		      ld    (IX+3), H 
9231			 
9231 78			      ld    A, B                    ; Check if DE is greater than BC 
9232 ba			      cp    D                       ; Compare MSB first 
9233 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9235 30 04		      jr    NC, free_find_higher_block_skip 
9237 79			      ld    A, C 
9238 bb			      cp    E                       ; Then compare LSB 
9239 38 08		      jr    C, free_found_higher_block 
923b			 
923b			free_find_higher_block_skip: 
923b 7a			      ld    A, D                    ; Reached the end of the free list? 
923c b3			      or    E 
923d ca c0 92		      jp    Z, free_done 
9240			 
9240 eb			      ex    DE, HL 
9241			 
9241 18 de		      jr    free_find_higher_block 
9243			 
9243			free_found_higher_block: 
9243			      ; Insert freed block between prev and next free blocks 
9243 71			      ld    (HL), C                 ; Point prev free block to freed block 
9244 23			      inc   HL 
9245 70			      ld    (HL), B 
9246			 
9246 60			      ld    H, B                    ; Point freed block at next free block 
9247 69			      ld    L, C 
9248 73			      ld    (HL), E 
9249 23			      inc   HL 
924a 72			      ld    (HL), D 
924b			 
924b			      ; Check if the freed block is adjacent to the next free block 
924b 23			      inc   HL                      ; Load size of freed block into HL 
924c 5e			      ld    E, (HL) 
924d 23			      inc   HL 
924e 56			      ld    D, (HL) 
924f eb			      ex    DE, HL 
9250			 
9250 09			      add   HL, BC                  ; Add addr of freed block and its size 
9251			 
9251 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9254 dd 56 01		      ld    D, (IX+1) 
9257			 
9257 b7			      or    A                       ; Clear the carry flag 
9258 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
925a 20 22		      jr    NZ, free_check_adjacent_to_prev 
925c			 
925c			      ; Freed block is adjacent to next, merge into one bigger block 
925c eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
925d 5e			      ld    E, (HL) 
925e 23			      inc   HL 
925f 56			      ld    D, (HL) 
9260 e5			      push  HL                      ; Save ptr to next block for later 
9261			 
9261 60			      ld    H, B                    ; Store ptr from next block into freed block 
9262 69			      ld    L, C 
9263 73			      ld    (HL), E 
9264 23			      inc   HL 
9265 72			      ld    (HL), D 
9266			 
9266 e1			      pop   HL                      ; Restore ptr to next block 
9267 23			      inc   HL                      ; Load size of next block into DE 
9268 5e			      ld    E, (HL) 
9269 23			      inc   HL 
926a 56			      ld    D, (HL) 
926b d5			      push  DE                      ; Save next block size for later 
926c			 
926c 60			      ld    H, B                    ; Load size of freed block into HL 
926d 69			      ld    L, C 
926e 23			      inc   HL 
926f 23			      inc   HL 
9270 5e			      ld    E, (HL) 
9271 23			      inc   HL 
9272 56			      ld    D, (HL) 
9273 eb			      ex    DE, HL 
9274			 
9274 d1			      pop   DE                      ; Restore size of next block 
9275 19			      add   HL, DE                  ; Add sizes of both blocks 
9276 eb			      ex    DE, HL 
9277			 
9277 60			      ld    H, B                    ; Store new bigger size into freed block 
9278 69			      ld    L, C 
9279 23			      inc   HL 
927a 23			      inc   HL 
927b 73			      ld    (HL), E 
927c 23			      inc   HL 
927d 72			      ld    (HL), D 
927e			 
927e			free_check_adjacent_to_prev: 
927e			      ; Check if the freed block is adjacent to the prev free block 
927e dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9281 dd 66 03		      ld    H, (IX+3) 
9284			 
9284 23			      inc   HL                      ; Size of prev free block into DE 
9285 23			      inc   HL 
9286 5e			      ld    E, (HL) 
9287 23			      inc   HL 
9288 56			      ld    D, (HL) 
9289 2b			      dec   HL 
928a 2b			      dec   HL 
928b 2b			      dec   HL 
928c			 
928c 19			      add   HL, DE                  ; Add prev block addr and size 
928d			 
928d b7			      or    A                       ; Clear the carry flag 
928e ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9290 20 2e		      jr    NZ, free_done 
9292			 
9292			      ; Freed block is adjacent to prev, merge into one bigger block 
9292 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9293 69			      ld    L, C 
9294 5e			      ld    E, (HL) 
9295 23			      inc   HL 
9296 56			      ld    D, (HL) 
9297 e5			      push  HL                      ; Save freed block ptr for later 
9298			 
9298 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
929b dd 66 03		      ld    H, (IX+3) 
929e 73			      ld    (HL), E 
929f 23			      inc   HL 
92a0 72			      ld    (HL), D 
92a1			 
92a1 e1			      pop   HL                      ; Restore freed block ptr 
92a2 23			      inc   HL                      ; Load size of freed block into DE 
92a3 5e			      ld    E, (HL) 
92a4 23			      inc   HL 
92a5 56			      ld    D, (HL) 
92a6 d5			      push  DE                      ; Save freed block size for later 
92a7			 
92a7 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
92aa dd 66 03		      ld    H, (IX+3) 
92ad 23			      inc   HL 
92ae 23			      inc   HL 
92af 5e			      ld    E, (HL) 
92b0 23			      inc   HL 
92b1 56			      ld    D, (HL) 
92b2			 
92b2 e1			      pop   HL                      ; Add sizes of both blocks 
92b3 19			      add   HL, DE 
92b4 eb			      ex    DE, HL 
92b5			 
92b5 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
92b8 dd 66 03		      ld    H, (IX+3) 
92bb 23			      inc   HL 
92bc 23			      inc   HL 
92bd 73			      ld    (HL), E 
92be 23			      inc   HL 
92bf 72			      ld    (HL), D 
92c0			 
92c0			free_done: 
92c0 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
92c3 39			      add   HL, SP 
92c4 f9			      ld    SP, HL 
92c5			 
92c5			free_early_exit: 
92c5 dd e1		      pop   IX 
92c7 d1			      pop   DE 
92c8 c1			      pop   BC 
92c9			 
92c9 c9			      ret 
92ca			 
92ca			; moved to firmware.asm 
92ca			; 
92ca			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
92ca			;                  .dw   0 
92ca			 
92ca			 
92ca			endif 
92ca			 
92ca			 
92ca			if MALLOC_3 
92ca			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
92ca			;heap_start        .equ  0x9000      ; Starting address of heap 
92ca			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
92ca			; 
92ca			 ;     .org 0 
92ca			  ;    jp    main 
92ca			; 
92ca			; 
92ca			 ;     .org  0x100 
92ca			;main: 
92ca			 ;     ld    HL, 0x8100 
92ca			  ;    ld    SP, HL 
92ca			; 
92ca			;      call  heap_init 
92ca			 
92ca			      ; Make some allocations 
92ca			;      ld    HL, 12 
92ca			;      call  malloc            ; Allocates 0x9004 
92ca			; 
92ca			 ;     ld    HL, 12 
92ca			;      call  malloc            ; Allocates 0x9014 
92ca			 
92ca			;      ld    HL, 12 
92ca			;      call  malloc            ; Allocates 0x9024 
92ca			 
92ca			      ; Free some allocations 
92ca			;      ld    HL, 0x9014 
92ca			;      call  free 
92ca			 
92ca			;      ld    HL, 0x9004 
92ca			;      call  free 
92ca			; 
92ca			;      ld    HL, 0x9024 
92ca			;      call  free 
92ca			 
92ca			 
92ca			 ;     halt 
92ca			 
92ca			 
92ca			;------------------------------------------------------------------------------ 
92ca			;     heap_init                                                               : 
92ca			;                                                                             : 
92ca			; Description                                                                 : 
92ca			;     Initialise the heap and make it ready for malloc and free operations.   : 
92ca			;                                                                             : 
92ca			;     The heap is maintained as a linked list, starting with an initial       : 
92ca			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
92ca			;     the first free block in the heap. Each block then points to the next    : 
92ca			;     free block within the heap, and the free list ends at the first block   : 
92ca			;     with a null pointer to the next free block.                             : 
92ca			;                                                                             : 
92ca			; Parameters                                                                  : 
92ca			;     Inputs are compile-time only. Two defines which specify the starting    : 
92ca			;     address of the heap and its size are required, along with a memory      : 
92ca			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
92ca			;     principally stores a pointer to the first free block in the heap.       : 
92ca			;                                                                             : 
92ca			; Returns                                                                     : 
92ca			;     Nothing                                                                 : 
92ca			;------------------------------------------------------------------------------ 
92ca			heap_init: 
92ca			      push  HL 
92ca			 
92ca			      ; Initialise free list struct 
92ca			      ld    HL, heap_start 
92ca			      ld    (free_list), HL 
92ca			      ld    HL, 0 
92ca			      ld    (free_list+2), HL 
92ca			 
92ca			      ; Insert first free block at bottom of heap, consumes entire heap 
92ca			      ld    HL, heap_start+heap_size-4 
92ca			      ld    (heap_start), HL        ; Next block (end of free list) 
92ca			      ld    HL, heap_size-4 
92ca			      ld    (heap_start+2), HL      ; Block size 
92ca			 
92ca			      ; Insert end of free list block at top of heap - two null words will 
92ca			      ; terminate the free list 
92ca			      ld    HL, 0 
92ca			      ld    (heap_start+heap_size-2), HL 
92ca			      ld    (heap_start+heap_size-4), HL 
92ca			 
92ca			      pop   HL 
92ca			 
92ca			      ret 
92ca			 
92ca			 
92ca			;------------------------------------------------------------------------------ 
92ca			;     malloc                                                                  : 
92ca			;                                                                             : 
92ca			; Description                                                                 : 
92ca			;     Allocates the wanted space from the heap and returns the address of the : 
92ca			;     first useable byte of the allocation.                                   : 
92ca			;                                                                             : 
92ca			;     Allocations can happen in one of two ways:                              : 
92ca			;                                                                             : 
92ca			;     1. A free block may be found which is the exact size wanted. In this    : 
92ca			;        case the block is removed from the free list and retuedn to the      : 
92ca			;        caller.                                                              : 
92ca			;     2. A free block may be found which is larger than the size wanted. In   : 
92ca			;        this case, the larger block is split into two. The first portion of  : 
92ca			;        this block will become the requested space by the malloc call and    : 
92ca			;        is returned to the caller. The second portion becomes a new free     : 
92ca			;        block, and the free list is adjusted to maintain continuity via this : 
92ca			;        newly created block.                                                 : 
92ca			;                                                                             : 
92ca			;     malloc does not set any initial value in the allocated space, the       : 
92ca			;     caller is required to do this as required.                              : 
92ca			;                                                                             : 
92ca			;     This implementation of malloc uses the stack exclusively, and is        : 
92ca			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
92ca			;     advisable to disable interrupts before calling malloc, and recommended  : 
92ca			;     to avoid the use of malloc inside ISRs in general.                      : 
92ca			;                                                                             : 
92ca			;     NOTE: heap_init must be called before malloc and free can be used.      : 
92ca			;                                                                             : 
92ca			; Parameters                                                                  : 
92ca			;     HL  Number of bytes wanted                                              : 
92ca			;                                                                             : 
92ca			; Returns                                                                     : 
92ca			;     HL  Address of the first useable byte of the allocation                 : 
92ca			;                                                                             : 
92ca			; Flags                                                                       : 
92ca			;     Z   Set if the allocation did not succeed, clear otherwise              : 
92ca			;                                                                             : 
92ca			; Stack frame                                                                 : 
92ca			;       |             |                                                       : 
92ca			;       +-------------+                                                       : 
92ca			;       |     BC      |                                                       : 
92ca			;       +-------------+                                                       : 
92ca			;       |     DE      |                                                       : 
92ca			;       +-------------+                                                       : 
92ca			;       |     IX      |                                                       : 
92ca			;       +-------------+                                                       : 
92ca			;       |  prev_free  |                                                       : 
92ca			;   +4  +-------------+                                                       : 
92ca			;       |  this_free  |                                                       : 
92ca			;   +2  +-------------+                                                       : 
92ca			;       |  next_free  |                                                       : 
92ca			;   +0  +-------------+                                                       : 
92ca			;       |             |                                                       : 
92ca			;                                                                             : 
92ca			;------------------------------------------------------------------------------ 
92ca			malloc: 
92ca			      push  BC 
92ca			      push  DE 
92ca			      push  IX 
92ca			 
92ca			      ld    A, H                    ; Exit if no space requested 
92ca			      or    L 
92ca			      jp    Z, malloc_early_exit 
92ca			 
92ca			      ; Set up stack frame 
92ca			      ex    DE, HL 
92ca			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
92ca			      add   HL, SP 
92ca			      ld    SP, HL 
92ca			      ld    IX, 0                   ; Use IX as a frame pointer 
92ca			      add   IX, SP 
92ca			 
92ca			      ; Setup initial state 
92ca			      ld    HL, 4                   ; want must also include space used by block struct 
92ca			      add   HL, DE 
92ca			 
92ca			      ld    B, H                    ; Move want to BC 
92ca			      ld    C, L 
92ca			 
92ca			      ld    HL, free_list           ; Store prev_free ptr to stack 
92ca			      ld    (IX+4), L 
92ca			      ld    (IX+5), H 
92ca			 
92ca			      ld    E, (HL)                 ; Store this_free ptr to stack 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			      ld    (IX+2), E 
92ca			      ld    (IX+3), D 
92ca			      ex    DE, HL                  ; this_free ptr into HL 
92ca			 
92ca			      ; Loop through free block list to find some space 
92ca			malloc_find_space: 
92ca			      ld    E, (HL)                 ; Load next_free ptr into DE 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			 
92ca			      ld    A, D                    ; Check for null next_free ptr - end of free list 
92ca			      or    E 
92ca			      jp    Z, malloc_no_space 
92ca			 
92ca			      ld    (IX+0), E               ; Store next_free ptr to stack 
92ca			      ld    (IX+1), D 
92ca			 
92ca			      ; Does this block have enough space to make the allocation? 
92ca			      inc   HL                      ; Load free block size into DE 
92ca			      ld    E, (HL) 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			 
92ca			      ex    DE, HL                  ; Check size of block against want 
92ca			      or    A                       ; Ensure carry flag clear 
92ca			      sbc   HL, BC 
92ca			      push  HL                      ; Store the result for later (new block size) 
92ca			 
92ca			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
92ca			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
92ca			 
92ca			      ; this_free block is not big enough, setup ptrs to test next free block 
92ca			      pop   HL                      ; Discard previous result 
92ca			 
92ca			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
92ca			      ld    H, (IX+3) 
92ca			      ld    (IX+4), L 
92ca			      ld    (IX+5), H 
92ca			 
92ca			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
92ca			      ld    H, (IX+1) 
92ca			      ld    (IX+2), L 
92ca			      ld    (IX+3), H 
92ca			 
92ca			      jr    malloc_find_space 
92ca			 
92ca			      ; split a bigger block into two - requested size and remaining size 
92ca			malloc_alloc_split: 
92ca			      ex    DE, HL                  ; Calculate address of new free block 
92ca			      dec   HL 
92ca			      dec   HL 
92ca			      dec   HL 
92ca			      add   HL, BC 
92ca			 
92ca			      ; Create a new block and point it at next_free 
92ca			      ld    E, (IX+0)               ; Load next_free ptr into DE 
92ca			      ld    D, (IX+1) 
92ca			 
92ca			      ld    (HL), E                 ; Store next_free ptr into new block 
92ca			      inc   HL 
92ca			      ld    (HL), D 
92ca			 
92ca			      pop   DE                      ; Store size of new block into new block 
92ca			      inc   HL 
92ca			      ld    (HL), E 
92ca			      inc   HL 
92ca			      ld    (HL), D 
92ca			 
92ca			      ; Update this_free ptr to point to new block 
92ca			      dec   HL 
92ca			      dec   HL 
92ca			      dec   HL 
92ca			 
92ca			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
92ca			      ld    D, (IX+3) 
92ca			 
92ca			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
92ca			      ld    (IX+3), H 
92ca			 
92ca			      ; Modify this_free block to be allocation 
92ca			      ex    DE, HL 
92ca			      xor   A                       ; Null the next block ptr of allocated block 
92ca			      ld    (HL), A 
92ca			      inc   HL 
92ca			      ld    (HL), A 
92ca			 
92ca			      inc   HL                      ; Store want size into allocated block 
92ca			      ld    (HL), C 
92ca			      inc   HL 
92ca			      ld    (HL), B 
92ca			      inc   HL 
92ca			      push  HL                      ; Address of allocation to return 
92ca			 
92ca			      jr    malloc_update_links 
92ca			 
92ca			malloc_alloc_fit: 
92ca			      pop   HL                      ; Dont need new block size, want is exact fit 
92ca			 
92ca			      ; Modify this_free block to be allocation 
92ca			      ex    DE, HL 
92ca			      dec   HL 
92ca			      dec   HL 
92ca			      dec   HL 
92ca			 
92ca			      xor   A                       ; Null the next block ptr of allocated block 
92ca			      ld    (HL), A 
92ca			      inc   HL 
92ca			      ld    (HL), A 
92ca			 
92ca			      inc   HL                      ; Store address of allocation to return 
92ca			      inc   HL 
92ca			      inc   HL 
92ca			      push  HL 
92ca			 
92ca			      ; Copy next_free ptr to this_free, remove allocated block from free list 
92ca			      ld    L, (IX+0)               ; next_free to HL 
92ca			      ld    H, (IX+1) 
92ca			 
92ca			      ld    (IX+2), L               ; HL to this_free 
92ca			      ld    (IX+3), H 
92ca			 
92ca			 
92ca			malloc_update_links: 
92ca			      ; Update prev_free ptr to point to this_free 
92ca			      ld    L, (IX+4)               ; prev_free ptr to HL 
92ca			      ld    H, (IX+5) 
92ca			 
92ca			      ld    E, (IX+2)               ; this_free ptr to DE 
92ca			      ld    D, (IX+3) 
92ca			 
92ca			      ld    (HL), E                 ; this_free ptr into prev_free 
92ca			      inc   HL 
92ca			      ld    (HL), D 
92ca			 
92ca			      ; Clear the Z flag to indicate successful allocation 
92ca			      ld    A, D 
92ca			      or    E 
92ca			 
92ca			      pop   DE                      ; Address of allocation 
92ca			 
92ca			malloc_no_space: 
92ca			      ld    HL, 6                   ; Clean up stack frame 
92ca			      add   HL, SP 
92ca			      ld    SP, HL 
92ca			 
92ca			      ex    DE, HL                  ; Alloc addr into HL for return 
92ca			 
92ca			malloc_early_exit: 
92ca			      pop   IX 
92ca			      pop   DE 
92ca			      pop   BC 
92ca			 
92ca			      ret 
92ca			 
92ca			 
92ca			;------------------------------------------------------------------------------ 
92ca			;     free                                                                    : 
92ca			;                                                                             : 
92ca			; Description                                                                 : 
92ca			;     Return the space pointed to by HL to the heap. HL must be an address as : 
92ca			;     returned by malloc, otherwise the behaviour is undefined.               : 
92ca			;                                                                             : 
92ca			;     Where possible, directly adjacent free blocks will be merged together   : 
92ca			;     into larger blocks to help ensure that the heap does not become         : 
92ca			;     excessively fragmented.                                                 : 
92ca			;                                                                             : 
92ca			;     free does not clear or set any other value into the freed space, and    : 
92ca			;     therefore its contents may be visible through subsequent malloc's. The  : 
92ca			;     caller should clear the freed space as required.                        : 
92ca			;                                                                             : 
92ca			;     This implementation of free uses the stack exclusively, and is          : 
92ca			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
92ca			;     advisable to disable interrupts before calling free, and recommended    : 
92ca			;     to avoid the use of free inside ISRs in general.                        : 
92ca			;                                                                             : 
92ca			;     NOTE: heap_init must be called before malloc and free can be used.      : 
92ca			;                                                                             : 
92ca			; Parameters                                                                  : 
92ca			;     HL  Pointer to address of first byte of allocation to be freed          : 
92ca			;                                                                             : 
92ca			; Returns                                                                     : 
92ca			;     Nothing                                                                 : 
92ca			;                                                                             : 
92ca			; Stack frame                                                                 : 
92ca			;       |             |                                                       : 
92ca			;       +-------------+                                                       : 
92ca			;       |     BC      |                                                       : 
92ca			;       +-------------+                                                       : 
92ca			;       |     DE      |                                                       : 
92ca			;       +-------------+                                                       : 
92ca			;       |     IX      |                                                       : 
92ca			;       +-------------+                                                       : 
92ca			;       |  prev_free  |                                                       : 
92ca			;   +2  +-------------+                                                       : 
92ca			;       |  next_free  |                                                       : 
92ca			;   +0  +-------------+                                                       : 
92ca			;       |             |                                                       : 
92ca			;                                                                             : 
92ca			;------------------------------------------------------------------------------ 
92ca			free: 
92ca			      push  BC 
92ca			      push  DE 
92ca			      push  IX 
92ca			 
92ca			      ld    A, H                    ; Exit if ptr is null 
92ca			      or    L 
92ca			      jp    Z, free_early_exit 
92ca			 
92ca			      ; Set up stack frame 
92ca			      ex    DE, HL 
92ca			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
92ca			      add   HL, SP 
92ca			      ld    SP, HL 
92ca			      ld    IX, 0                   ; Use IX as a frame pointer 
92ca			      add   IX, SP 
92ca			 
92ca			      ; The address in HL points to the start of the useable allocated space, 
92ca			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
92ca			      ; address of the block itself. 
92ca			      ex    DE, HL 
92ca			      ld    DE, -4 
92ca			      add   HL, DE 
92ca			 
92ca			      ; An allocated block must have a null next block pointer in it 
92ca			      ld    A, (HL) 
92ca			      inc   HL 
92ca			      or    (HL) 
92ca			      jp    NZ, free_done 
92ca			 
92ca			      dec   HL 
92ca			 
92ca			      ld    B, H                    ; Copy HL to BC 
92ca			      ld    C, L 
92ca			 
92ca			      ; Loop through the free list to find the first block with an address 
92ca			      ; higher than the block being freed 
92ca			      ld    HL, free_list 
92ca			 
92ca			free_find_higher_block: 
92ca			      ld    E, (HL)                 ; Load next ptr from free block 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			      dec   HL 
92ca			 
92ca			      ld    (IX+0), E               ; Save ptr to next free block 
92ca			      ld    (IX+1), D 
92ca			      ld    (IX+2), L               ; Save ptr to prev free block 
92ca			      ld    (IX+3), H 
92ca			 
92ca			      ld    A, B                    ; Check if DE is greater than BC 
92ca			      cp    D                       ; Compare MSB first 
92ca			      jr    Z, $+4                  ; MSB the same, compare LSB 
92ca			      jr    NC, free_find_higher_block_skip 
92ca			      ld    A, C 
92ca			      cp    E                       ; Then compare LSB 
92ca			      jr    C, free_found_higher_block 
92ca			 
92ca			free_find_higher_block_skip: 
92ca			      ld    A, D                    ; Reached the end of the free list? 
92ca			      or    E 
92ca			      jp    Z, free_done 
92ca			 
92ca			      ex    DE, HL 
92ca			 
92ca			      jr    free_find_higher_block 
92ca			 
92ca			free_found_higher_block: 
92ca			      ; Insert freed block between prev and next free blocks 
92ca			      ld    (HL), C                 ; Point prev free block to freed block 
92ca			      inc   HL 
92ca			      ld    (HL), B 
92ca			 
92ca			      ld    H, B                    ; Point freed block at next free block 
92ca			      ld    L, C 
92ca			      ld    (HL), E 
92ca			      inc   HL 
92ca			      ld    (HL), D 
92ca			 
92ca			      ; Check if the freed block is adjacent to the next free block 
92ca			      inc   HL                      ; Load size of freed block into HL 
92ca			      ld    E, (HL) 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			      ex    DE, HL 
92ca			 
92ca			      add   HL, BC                  ; Add addr of freed block and its size 
92ca			 
92ca			      ld    E, (IX+0)               ; Load addr of next free block into DE 
92ca			      ld    D, (IX+1) 
92ca			 
92ca			      or    A                       ; Clear the carry flag 
92ca			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92ca			      jr    NZ, free_check_adjacent_to_prev 
92ca			 
92ca			      ; Freed block is adjacent to next, merge into one bigger block 
92ca			      ex    DE, HL                  ; Load next ptr from next block into DE 
92ca			      ld    E, (HL) 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			      push  HL                      ; Save ptr to next block for later 
92ca			 
92ca			      ld    H, B                    ; Store ptr from next block into freed block 
92ca			      ld    L, C 
92ca			      ld    (HL), E 
92ca			      inc   HL 
92ca			      ld    (HL), D 
92ca			 
92ca			      pop   HL                      ; Restore ptr to next block 
92ca			      inc   HL                      ; Load size of next block into DE 
92ca			      ld    E, (HL) 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			      push  DE                      ; Save next block size for later 
92ca			 
92ca			      ld    H, B                    ; Load size of freed block into HL 
92ca			      ld    L, C 
92ca			      inc   HL 
92ca			      inc   HL 
92ca			      ld    E, (HL) 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			      ex    DE, HL 
92ca			 
92ca			      pop   DE                      ; Restore size of next block 
92ca			      add   HL, DE                  ; Add sizes of both blocks 
92ca			      ex    DE, HL 
92ca			 
92ca			      ld    H, B                    ; Store new bigger size into freed block 
92ca			      ld    L, C 
92ca			      inc   HL 
92ca			      inc   HL 
92ca			      ld    (HL), E 
92ca			      inc   HL 
92ca			      ld    (HL), D 
92ca			 
92ca			free_check_adjacent_to_prev: 
92ca			      ; Check if the freed block is adjacent to the prev free block 
92ca			      ld    L, (IX+2)               ; Prev free block ptr into HL 
92ca			      ld    H, (IX+3) 
92ca			 
92ca			      inc   HL                      ; Size of prev free block into DE 
92ca			      inc   HL 
92ca			      ld    E, (HL) 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			      dec   HL 
92ca			      dec   HL 
92ca			      dec   HL 
92ca			 
92ca			      add   HL, DE                  ; Add prev block addr and size 
92ca			 
92ca			      or    A                       ; Clear the carry flag 
92ca			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
92ca			      jr    NZ, free_done 
92ca			 
92ca			      ; Freed block is adjacent to prev, merge into one bigger block 
92ca			      ld    H, B                    ; Load next ptr from freed block into DE 
92ca			      ld    L, C 
92ca			      ld    E, (HL) 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			      push  HL                      ; Save freed block ptr for later 
92ca			 
92ca			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
92ca			      ld    H, (IX+3) 
92ca			      ld    (HL), E 
92ca			      inc   HL 
92ca			      ld    (HL), D 
92ca			 
92ca			      pop   HL                      ; Restore freed block ptr 
92ca			      inc   HL                      ; Load size of freed block into DE 
92ca			      ld    E, (HL) 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			      push  DE                      ; Save freed block size for later 
92ca			 
92ca			      ld    L, (IX+2)               ; Load size of prev block into DE 
92ca			      ld    H, (IX+3) 
92ca			      inc   HL 
92ca			      inc   HL 
92ca			      ld    E, (HL) 
92ca			      inc   HL 
92ca			      ld    D, (HL) 
92ca			 
92ca			      pop   HL                      ; Add sizes of both blocks 
92ca			      add   HL, DE 
92ca			      ex    DE, HL 
92ca			 
92ca			      ld    L, (IX+2)               ; Store new bigger size into prev block 
92ca			      ld    H, (IX+3) 
92ca			      inc   HL 
92ca			      inc   HL 
92ca			      ld    (HL), E 
92ca			      inc   HL 
92ca			      ld    (HL), D 
92ca			 
92ca			free_done: 
92ca			      ld    HL, 4                   ; Clean up stack frame 
92ca			      add   HL, SP 
92ca			      ld    SP, HL 
92ca			 
92ca			free_early_exit: 
92ca			      pop   IX 
92ca			      pop   DE 
92ca			      pop   BC 
92ca			 
92ca			      ret 
92ca			 
92ca			 
92ca			;      .org 0x8000 
92ca			; 
92ca			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
92ca			 ;                 .dw   0 
92ca			 
92ca			endif 
92ca			 
92ca			 
92ca			if MALLOC_4 
92ca			 
92ca			; My memory allocation code. Very very simple.... 
92ca			; allocate space under 250 chars 
92ca			 
92ca			heap_init: 
92ca				; init start of heap as zero 
92ca				;  
92ca			 
92ca				ld hl, heap_start 
92ca				ld a, 0 
92ca				ld (hl), a      ; empty block 
92ca				inc hl 
92ca				ld a, 0 
92ca				ld (hl), a      ; length of block 
92ca				; write end of list 
92ca				inc hl 
92ca				ld a,(hl) 
92ca				inc hl 
92ca				ld a,(hl) 
92ca				 
92ca			 
92ca				; init some malloc vars 
92ca			 
92ca				ld hl, 0 
92ca				ld (free_list), hl       ; store last malloc location 
92ca			 
92ca				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
92ca				ld a, 0 
92ca				ld (hl), a 
92ca			 
92ca			 
92ca				ld hl, heap_start 
92ca				;  
92ca				  
92ca				ret 
92ca			 
92ca			 
92ca			;    free block marker 
92ca			;    requested size  
92ca			;    pointer to next block 
92ca			;    .... 
92ca			;    next block marker 
92ca			 
92ca			 
92ca			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
92ca			; 
92ca			 
92ca			 
92ca			malloc:  
92ca				push de 
92ca				push bc 
92ca				push af 
92ca			 
92ca				; hl space required 
92ca				 
92ca				ld c, l    ; hold space   (TODO only a max of 255) 
92ca			 
92ca			;	inc c     ; TODO BUG need to fix memory leak on push str 
92ca			;	inc c 
92ca			;	inc c 
92ca			;	inc c 
92ca			;	inc c 
92ca			;	inc c 
92ca			;	inc c 
92ca			 
92ca			 
92ca			 
92ca				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
92ca			 
92ca				ld a, (free_list+3) 
92ca				cp 0 
92ca				jr z, .contheap 
92ca			 
92ca				ld hl, (free_list)     ; get last alloc 
92ca					if DEBUG_FORTH_MALLOC_INT 
92ca						DMARK "mrs" 
92ca						CALLMONITOR 
92ca					endif 
92ca				jr .startalloc 
92ca			 
92ca			.contheap: 
92ca				ld hl, heap_start 
92ca			 
92ca			.startalloc: 
92ca			 
92ca					if DEBUG_FORTH_MALLOC_INT 
92ca						DMARK "mym" 
92ca						CALLMONITOR 
92ca					endif 
92ca			.findblock: 
92ca					if DEBUG_FORTH_MALLOC_INT 
92ca						DMARK "mmf" 
92ca						CALLMONITOR 
92ca					endif 
92ca			 
92ca				ld a,(hl)  
92ca				; if byte is zero then clear to use 
92ca			 
92ca				cp 0 
92ca				jr z, .foundemptyblock 
92ca			 
92ca				; if byte is not clear 
92ca				;     then byte is offset to next block 
92ca			 
92ca				inc hl 
92ca				ld a, (hl) ; get size 
92ca			.nextblock:	inc hl 
92ca					ld e, (hl) 
92ca					inc hl 
92ca					ld d, (hl) 
92ca					ex de, hl 
92ca			;	inc hl  ; move past the store space 
92ca			;	inc hl  ; move past zero index  
92ca			 
92ca				; TODO detect no more space 
92ca			 
92ca				push hl 
92ca				ld de, heap_end 
92ca				call cmp16 
92ca				pop hl 
92ca				jr nc, .nospace 
92ca			 
92ca				jr .findblock 
92ca			 
92ca			.nospace: ld hl, 0 
92ca				jp .exit 
92ca			 
92ca			 
92ca			.foundemptyblock:	 
92ca					if DEBUG_FORTH_MALLOC_INT 
92ca						DMARK "mme" 
92ca						CALLMONITOR 
92ca					endif 
92ca			 
92ca			; TODO has block enough space if reusing??? 
92ca			 
92ca				;  
92ca			 
92ca			; see if this block has been previously used 
92ca				inc hl 
92ca				ld a, (hl) 
92ca				dec hl 
92ca				cp 0 
92ca				jr z, .newblock 
92ca			 
92ca					if DEBUG_FORTH_MALLOC_INT 
92ca						DMARK "meR" 
92ca						CALLMONITOR 
92ca					endif 
92ca			 
92ca			; no reusing previously allocated block 
92ca			 
92ca			; is it smaller than previously used? 
92ca				 
92ca				inc hl    ; move to size 
92ca				ld a, c 
92ca				sub (hl)        ; we want c < (hl) 
92ca				dec hl    ; move back to marker 
92ca			        jr z, .findblock 
92ca			 
92ca				; update with the new size which should be lower 
92ca			 
92ca			        ;inc  hl   ; negate next move. move back to size  
92ca			 
92ca			.newblock: 
92ca				; need to be at marker here 
92ca			 
92ca					if DEBUG_FORTH_MALLOC_INT 
92ca						DMARK "meN" 
92ca						CALLMONITOR 
92ca					endif 
92ca			 
92ca			 
92ca				ld a, c 
92ca			 
92ca				ld (free_list+3), a	 ; flag resume from last malloc  
92ca				ld (free_list), hl    ; save out last location 
92ca			 
92ca			 
92ca				;inc a     ; space for length byte 
92ca				ld (hl), a     ; save block in use marker 
92ca			 
92ca				inc hl   ; move to space marker 
92ca				ld (hl), a    ; save new space 
92ca			 
92ca				inc hl   ; move to start of allocated area 
92ca				 
92ca			;	push hl     ; save where we are - 1  
92ca			 
92ca			;	inc hl  ; move past zero index  
92ca				; skip space to set down new marker 
92ca			 
92ca				; provide some extra space for now 
92ca			 
92ca				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
92ca				inc a 
92ca				inc a 
92ca			 
92ca				push hl   ; save where we are in the node block 
92ca			 
92ca				call addatohl 
92ca			 
92ca				; write linked list point 
92ca			 
92ca				pop de     ; get our node position 
92ca				ex de, hl 
92ca			 
92ca				ld (hl), e 
92ca				inc hl 
92ca				ld (hl), d 
92ca			 
92ca				inc hl 
92ca			 
92ca				; now at start of allocated data so save pointer 
92ca			 
92ca				push hl 
92ca			 
92ca				; jump to position of next node and setup empty header in DE 
92ca			 
92ca				ex de, hl 
92ca			 
92ca			;	inc hl ; move past end of block 
92ca			 
92ca				ld a, 0 
92ca				ld (hl), a   ; empty marker 
92ca				inc hl 
92ca				ld (hl), a   ; size 
92ca				inc hl  
92ca				ld (hl), a   ; ptr 
92ca				inc hl 
92ca				ld (hl), a   ; ptr 
92ca			 
92ca			 
92ca				pop hl 
92ca			 
92ca					if DEBUG_FORTH_MALLOC_INT 
92ca						DMARK "mmr" 
92ca						CALLMONITOR 
92ca					endif 
92ca			 
92ca			.exit: 
92ca				pop af 
92ca				pop bc 
92ca				pop de  
92ca				ret 
92ca			 
92ca			 
92ca			 
92ca			 
92ca			free:  
92ca				push hl 
92ca				push af 
92ca				; get address in hl 
92ca			 
92ca					if DEBUG_FORTH_MALLOC_INT 
92ca						DMARK "fre" 
92ca						CALLMONITOR 
92ca					endif 
92ca				; data is at hl - move to block count 
92ca				dec hl 
92ca				dec hl    ; get past pointer 
92ca				dec hl 
92ca			 
92ca				ld a, (hl)    ; need this for a validation check 
92ca			 
92ca				dec hl    ; move to block marker 
92ca			 
92ca				; now check that the block count and block marker are the same  
92ca			        ; this checks that we are on a malloc node and not random memory 
92ca			        ; OK a faint chance this could be a problem but rare - famous last words! 
92ca			 
92ca				ld c, a 
92ca				ld a, (hl)    
92ca			 
92ca				cp c 
92ca				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
92ca			 
92ca				; yes good chance we are on a malloc node 
92ca			 
92ca				ld a, 0      
92ca				ld (hl), a   ; mark as free 
92ca			 
92ca				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
92ca			 
92ca			.freeignore:  
92ca			 
92ca				pop af 
92ca				pop hl 
92ca			 
92ca				ret 
92ca			 
92ca			 
92ca			 
92ca			endif 
92ca			 
92ca			; eof 
# End of file firmware_memory.asm
92ca			  
92ca			; device C  
92ca			if SOUND_ENABLE  
92ca				include "firmware_sound.asm"  
92ca			endif  
92ca			  
92ca			include "firmware_diags.asm"  
92ca			; Hardware diags menu 
92ca			 
92ca			 
92ca			config: 
92ca			 
92ca 3e 00			ld a, 0 
92cc 21 fa 92			ld hl, .configmn 
92cf cd 6e 8a			call menu 
92d2			 
92d2 fe 00			cp 0 
92d4 c8				ret z 
92d5			 
92d5 fe 01			cp 1 
92d7 cc 28 93			call z, .savetostore 
92da			 
92da fe 02			cp 2 
92dc cc 14 93			call z, .selautoload 
92df fe 03			cp 3 
92e1 cc 0a 93			call z, .disautoload 
92e4 fe 04			cp 4 
92e6 cc 1e 93			call z, .selbank 
92e9 fe 05			cp 5 
92eb cc 32 93			call z, .debug_tog 
92ee fe 06			cp 6 
92f0 cc 75 94			call z, .bpsgo 
92f3 fe 07			cp 7 
92f5 cc 58 93			call z, hardware_diags 
92f8			 
92f8 18 d0			jr config 
92fa			 
92fa			.configmn: 
92fa 66 96			dw prom_c3 
92fc 7d 96			dw prom_c2 
92fe 92 96			dw prom_c2a 
9300 a8 96			dw prom_c2b 
9302			;	dw prom_c4 
9302 c5 96			dw prom_m4 
9304 e0 96			dw prom_m4b 
9306 e8 96			dw prom_c1 
9308 00 00			dw 0 
930a				 
930a			 
930a			 
930a			 
930a			.disautoload: 
930a				if STORAGE_SE 
930a				ld a, $fe      ; bit 0 clear 
930a				ld (spi_device), a 
930a			 
930a				call storage_get_block_0 
930a			 
930a				ld a, 0 
930a				ld (store_page+STORE_0_AUTOFILE), a 
930a			 
930a					ld hl, 0 
930a					ld de, store_page 
930a				call storage_write_block	 ; save update 
930a				else 
930a			 
930a 21 f7 96			ld hl, prom_notav 
930d 11 0d 97			ld de, prom_empty 
9310 cd ce 89			call info_panel 
9313				endif 
9313			 
9313			 
9313 c9				ret 
9314			 
9314			 
9314			 
9314			; Select auto start 
9314			 
9314			.selautoload: 
9314			 
9314				 
9314				if STORAGE_SE 
9314			 
9314					call config_dir 
9314				        ld hl, scratch 
9314					ld a, 0 
9314					call menu 
9314			 
9314					cp 0 
9314					ret z 
9314			 
9314					dec a 
9314			 
9314			 
9314					; locate menu option 
9314			 
9314					ld hl, scratch 
9314					call table_lookup 
9314			 
9314					if DEBUG_FORTH_WORDS 
9314						DMARK "ALl" 
9314						CALLMONITOR 
9314					endif 
9314					; with the pointer to the menu it, the byte following the zero term is the file id 
9314			 
9314					ld a, 0 
9314					ld bc, 50   ; max of bytes to look at 
9314					cpir  
9314			 
9314					if DEBUG_FORTH_WORDS 
9314						DMARK "ALb" 
9314						CALLMONITOR 
9314					endif 
9314					;inc hl 
9314			 
9314					ld a, (hl)   ; file id 
9314					 
9314				        ; save bank and file ids 
9314			 
9314					push af 
9314			 
9314			; TODO need to save to block 0 on bank 1	 
9314			 
9314					call storage_get_block_0 
9314			 
9314					if DEBUG_FORTH_WORDS 
9314						DMARK "AL0" 
9314						CALLMONITOR 
9314					endif 
9314					pop af 
9314			 
9314					ld (store_page+STORE_0_FILERUN),a 
9314					 
9314					; save bank id 
9314			 
9314					ld a,(spi_device) 
9314					ld (store_page+STORE_0_BANKRUN),a 
9314			 
9314					; enable auto run of store file 
9314			 
9314					ld a, 1 
9314					ld (store_page+STORE_0_AUTOFILE),a 
9314			 
9314					; save buffer 
9314			 
9314					ld hl, 0 
9314					ld de, store_page 
9314					if DEBUG_FORTH_WORDS 
9314						DMARK "ALw" 
9314						CALLMONITOR 
9314					endif 
9314				call storage_write_block	 ; save update 
9314			  
9314			 
9314			 
9314			 
9314					ld hl, scratch 
9314					call config_fdir 
9314			 
9314				else 
9314			 
9314 21 f7 96			ld hl, prom_notav 
9317 11 0d 97			ld de, prom_empty 
931a cd ce 89			call info_panel 
931d			 
931d				endif 
931d c9				ret 
931e			 
931e			 
931e			 
931e			; Select storage bank 
931e			 
931e			.selbank: 
931e			 
931e				if STORAGE_SE 
931e				else 
931e			 
931e 21 f7 96			ld hl, prom_notav 
9321 11 0d 97			ld de, prom_empty 
9324 cd ce 89			call info_panel 
9327				endif 
9327				 
9327 c9				ret 
9328			 
9328			if STORAGE_SE 
9328			 
9328			.config_ldir:   
9328				; Load storage bank labels into menu array 
9328			 
9328				 
9328			 
9328			 
9328				ret 
9328			 
9328			 
9328			endif 
9328			 
9328			 
9328			; Save user words to storage 
9328			 
9328			.savetostore: 
9328			 
9328				if STORAGE_SE 
9328			 
9328					call config_dir 
9328				        ld hl, scratch 
9328					ld a, 0 
9328					call menu 
9328					 
9328					ld hl, scratch 
9328					call config_fdir 
9328			 
9328				else 
9328			 
9328 21 f7 96			ld hl, prom_notav 
932b 11 0d 97			ld de, prom_empty 
932e cd ce 89			call info_panel 
9331			 
9331				endif 
9331			 
9331 c9				ret 
9332			 
9332			 
9332			 
9332			if STORAGE_SE 
9332			 
9332			config_fdir: 
9332				; using the scratch dir go through and release the memory allocated for each string 
9332				 
9332				ld hl, scratch 
9332			.cfdir:	ld e,(hl) 
9332				inc hl 
9332				ld d,(hl) 
9332				inc hl 
9332			 
9332				ex de, hl 
9332				call ishlzero 
9332				ret z     ; return on null pointer 
9332				call free 
9332				ex de, hl 
9332				jr .cfdir 
9332			 
9332			 
9332				ret 
9332			 
9332			 
9332			config_dir: 
9332			 
9332				; for the config menus that need to build a directory of storage call this routine 
9332				; it will construct a menu in scratch to pass to menu 
9332			 
9332				; open storage device 
9332			 
9332				; execute DIR to build a list of files and their ids into scratch in menu format 
9332				; once the menu has finished then will need to call config_fdir to release the strings 
9332				 
9332				; c = number items 
9332			 
9332				 
9332				call storage_get_block_0 
9332			 
9332				ld hl, store_page     ; get current id count 
9332				ld b, (hl) 
9332				ld c, 0    ; count of files   
9332			 
9332			 
9332				ld hl, scratch 
9332				ld (store_tmp2), hl    ; location to poke strings 
9332			 
9332				; check for empty drive 
9332			 
9332				ld a, 0 
9332				cp b 
9332				jp z, .dirdone 
9332			 
9332				 
9332					if DEBUG_FORTH_WORDS 
9332						DMARK "Cdc" 
9332						CALLMONITOR 
9332					endif 
9332			 
9332			 
9332			.diritem:	 
9332				push bc 
9332				; for each of the current ids do a search for them and if found push to stack 
9332			 
9332					ld hl, STORE_BLOCK_PHY 
9332					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9332					ld e,b 
9332			 
9332					call storage_findnextid 
9332			 
9332			 
9332					; if found hl will be non zero 
9332			 
9332					call ishlzero 
9332					jr z, .dirnotfound 
9332			 
9332					; increase count 
9332			 
9332					pop bc	 
9332					inc c 
9332					push bc 
9332					 
9332			 
9332					; get file header and push the file name 
9332			 
9332					ld de, store_page 
9332					call storage_read_block 
9332			 
9332					; push file id to stack 
9332				 
9332					ld a, (store_page) 
9332					ld h, 0 
9332					ld l, a 
9332			 
9332					;call forth_push_numhl 
9332					; TODO store id 
9332			 
9332					push hl 
9332			 
9332					; push extent count to stack  
9332				 
9332					ld hl, store_page+3 
9332			 
9332					; get file name length 
9332			 
9332					call strlenz   
9332			 
9332					inc hl   ; cover zero term 
9332					inc hl  ; stick the id at the end of the area 
9332			 
9332					push hl 
9332					pop bc    ; move length to bc 
9332			 
9332					call malloc 
9332			 
9332					; TODO save malloc area to scratch 
9332			 
9332					ex de, hl 
9332					ld hl, (store_tmp2) 
9332					ld (hl), e 
9332					inc hl 
9332					ld (hl), d 
9332					inc hl 
9332					ld (store_tmp2), hl 
9332			 
9332					 
9332			 
9332					;pop hl   ; get source 
9332			;		ex de, hl    ; swap aronund	 
9332			 
9332					ld hl, store_page+3 
9332					if DEBUG_FORTH_WORDS 
9332						DMARK "CFd" 
9332						CALLMONITOR 
9332					endif 
9332					ldir 
9332			 
9332					; de is past string, move back one and store id 
9332					 
9332					dec de 
9332			 
9332					; store file id 
9332			 
9332					pop hl 
9332					ex de,hl 
9332					ld (hl), e 
9332			 
9332					if DEBUG_FORTH_WORDS 
9332						DMARK "Cdi" 
9332						CALLMONITOR 
9332					endif 
9332					 
9332			.dirnotfound: 
9332					pop bc     
9332					djnz .diritem 
9332				 
9332			.dirdone:	 
9332			 
9332					ld a, 0 
9332					ld hl, (store_tmp2) 
9332					ld (hl), a 
9332					inc hl 
9332					ld (hl), a 
9332					inc hl 
9332					; push a count of the dir items found 
9332			 
9332			;		ld h, 0 
9332			;		ld l, c 
9332			 
9332				ret 
9332			 
9332			endif 
9332			 
9332			 
9332			; Settings 
9332			; Run  
9332			 
9332			 
9332			 
9332			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9332			;;hd_menu2:   db "        2: Editor",0   
9332			;hd_menu2:   db "        2: Editor       6: Menu",0   
9332			;hd_menu3:   db "        3: Storage",0 
9332			;hd_menu4:   db "0=quit  4: Debug",0 
9332			;hd_don:     db "ON",0 
9332			;hd_doff:     db "OFF",0 
9332			; 
9332			; 
9332			; 
9332			;hardware_diags_old:       
9332			; 
9332			;.diagmenu: 
9332			;	call clear_display 
9332			;	ld a, display_row_1 
9332			;	ld de, hd_menu1 
9332			;	call str_at_display 
9332			; 
9332			;	ld a, display_row_2 
9332			;	ld de, hd_menu2 
9332			;	call str_at_display 
9332			; 
9332			;	ld a, display_row_3 
9332			;	ld de, hd_menu3 
9332			;	call str_at_display 
9332			; 
9332			;	ld a,  display_row_4 
9332			;	ld de, hd_menu4 
9332			;	call str_at_display 
9332			; 
9332			;	; display debug state 
9332			; 
9332			;	ld de, hd_don 
9332			;	ld a, (os_view_disable) 
9332			;	cp 0 
9332			;	jr z, .distog 
9332			;	ld de, hd_doff 
9332			;.distog: ld a, display_row_4+17 
9332			;	call str_at_display 
9332			; 
9332			;	call update_display 
9332			; 
9332			;	call cin_wait 
9332			; 
9332			; 
9332			; 
9332			;	cp '4' 
9332			;	jr nz, .diagn1 
9332			; 
9332			;	; debug toggle 
9332			; 
9332			;	ld a, (os_view_disable) 
9332			;	ld b, '*' 
9332			;	cp 0 
9332			;	jr z, .debtog 
9332			;	ld b, 0 
9332			;.debtog:	 
9332			;	ld a,b 
9332			;	ld (os_view_disable),a 
9332			; 
9332			;.diagn1: cp '0' 
9332			;	 ret z 
9332			; 
9332			;;	cp '1' 
9332			;;       jp z, matrix	 
9332			;;   TODO keyboard matrix test 
9332			; 
9332			;	cp '2' 
9332			;	jp z, .diagedit 
9332			; 
9332			;;	cp '6' 
9332			;;	jp z, .menutest 
9332			;;if ENABLE_BASIC 
9332			;;	cp '6' 
9332			;;	jp z, basic 
9332			;;endif 
9332			 ; 
9332			;	jp .diagmenu 
9332			; 
9332			; 
9332			;	ret 
9332			 
9332			 
9332			.debug_tog: 
9332 21 79 93			ld hl, .menudebug 
9335				 
9335 3a f3 e2			ld a, (os_view_disable) 
9338 fe 2a			cp '*' 
933a 20 04			jr nz,.tdon  
933c 3e 01			ld a, 1 
933e 18 02			jr .tog1 
9340 3e 00		.tdon: ld a, 0 
9342			 
9342			.tog1: 
9342 cd 6e 8a			call menu 
9345 fe 00			cp 0 
9347 c8				ret z 
9348 fe 01			cp 1    ; disable debug 
934a 28 04			jr z, .dtog0 
934c 3e 2a			ld a, '*' 
934e 18 02			jr .dtogset 
9350 3e 00		.dtog0: ld a, 0 
9352 32 f3 e2		.dtogset:  ld (os_view_disable), a 
9355 c3 32 93			jp .debug_tog 
9358			 
9358			 
9358			hardware_diags:       
9358			 
9358			.diagm: 
9358 21 6b 93			ld hl, .menuitems 
935b 3e 00			ld a, 0 
935d cd 6e 8a			call menu 
9360			 
9360 fe 00		         cp 0 
9362 c8				 ret z 
9363			 
9363 fe 02			cp 2 
9365 ca c4 93			jp z, .diagedit 
9368			 
9368			;	cp '6' 
9368			;	jp z, .menutest 
9368			;if ENABLE_BASIC 
9368			;	cp '6' 
9368			;	jp z, basic 
9368			;endif 
9368			  
9368 c3 58 93			jp .diagm 
936b			 
936b				 
936b 7f 93		.menuitems:   	dw .m1 
936d 8a 93				dw .m2 
936f 91 93				dw .m3 
9371 99 93				dw .m5 
9373 9f 93				dw .m5a 
9375 a8 93				dw .m5b 
9377 00 00				dw 0 
9379			 
9379			.menudebug: 
9379 b1 93				dw .m6 
937b ba 93				dw .m7 
937d 00 00				dw 0 
937f			 
937f .. 00		.m1:   db "Key Matrix",0 
938a .. 00		.m2:   db "Editor",0 
9391 .. 00		.m3:   db "Storage",0 
9399 .. 00		.m5:   db "Sound",0 
939f .. 00		.m5a:  db "RAM Test",0 
93a8 .. 00		.m5b:  db "LCD Test",0 
93b1			 
93b1 .. 00		.m6:   db "Debug ON",0 
93ba .. 00		.m7:   db "Debug OFF",0 
93c4			 
93c4			; debug editor 
93c4			 
93c4			.diagedit: 
93c4			 
93c4 21 02 e3			ld hl, scratch 
93c7			;	ld bc, 250 
93c7			;	ldir 
93c7				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
93c7 3e 00			ld a, 0 
93c9 77				ld (hl), a 
93ca 23				inc hl 
93cb 77				ld (hl), a 
93cc 23				inc hl 
93cd 77				ld (hl), a 
93ce			 
93ce cd 3d 8a		        call clear_display 
93d1 cd 60 8a			call update_display 
93d4				;ld a, 1 
93d4				;ld (hardware_diag), a 
93d4			.diloop: 
93d4 3e 00			ld a, display_row_1 
93d6 0e 00			ld c, 0 
93d8 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
93da 1e 28			ld e, 40 
93dc			 
93dc 21 02 e3			ld hl, scratch	 
93df cd 97 8c			call input_str 
93e2			 
93e2 3e 28			ld a, display_row_2 
93e4 11 02 e3			ld de, scratch 
93e7 cd 50 8a			call str_at_display 
93ea cd 60 8a			call update_display 
93ed			 
93ed c3 d4 93			jp .diloop 
93f0			 
93f0			 
93f0			; pass word in hl 
93f0			; a has display location 
93f0			display_word_at: 
93f0 f5				push af 
93f1 e5				push hl 
93f2 7c				ld a,h 
93f3 21 07 e6			ld hl, os_word_scratch 
93f6 cd 6b 8f			call hexout 
93f9 e1				pop hl 
93fa 7d				ld a,l 
93fb 21 09 e6			ld hl, os_word_scratch+2 
93fe cd 6b 8f			call hexout 
9401 21 0b e6			ld hl, os_word_scratch+4 
9404 3e 00			ld a,0 
9406 77				ld (hl),a 
9407 11 07 e6			ld de,os_word_scratch 
940a f1				pop af 
940b cd 50 8a				call str_at_display 
940e c9				ret 
940f			 
940f			display_ptr_state: 
940f			 
940f				; to restore afterwards 
940f			 
940f d5				push de 
9410 c5				push bc 
9411 e5				push hl 
9412 f5				push af 
9413			 
9413				; for use in here 
9413			 
9413			;	push bc 
9413			;	push de 
9413			;	push hl 
9413			;	push af 
9413			 
9413 cd 3d 8a			call clear_display 
9416			 
9416 11 e9 95			ld de, .ptrstate 
9419 3e 00			ld a, display_row_1 
941b cd 50 8a			call str_at_display 
941e			 
941e				; display debug step 
941e			 
941e			 
941e 11 71 ee			ld de, debug_mark 
9421 3e 26			ld a, display_row_1+display_cols-2 
9423 cd 50 8a			call str_at_display 
9426			 
9426				; display a 
9426 11 f3 95			ld de, .ptrcliptr 
9429 3e 28			ld a, display_row_2 
942b cd 50 8a			call str_at_display 
942e			 
942e f1				pop af 
942f 2a 4d ea			ld hl,(cli_ptr) 
9432 3e 30			ld a, display_row_2+8 
9434 cd f0 93			call display_word_at 
9437			 
9437			 
9437				; display hl 
9437			 
9437			 
9437 11 fb 95			ld de, .ptrclioptr 
943a 3e 32			ld a, display_row_2+10 
943c cd 50 8a			call str_at_display 
943f			; 
943f			;	pop hl 
943f 3e 35			ld a, display_row_2+13 
9441 2a 4b ea			ld hl,(cli_origptr) 
9444 cd f0 93			call display_word_at 
9447			; 
9447			;	 
9447			;	; display de 
9447			 
9447			;	ld de, .regstatede 
9447			;	ld a, display_row_3 
9447			;	call str_at_display 
9447			 
9447			;	pop de 
9447			;	ld h,d 
9447			;	ld l, e 
9447			;	ld a, display_row_3+3 
9447			;	call display_word_at 
9447			 
9447			 
9447				; display bc 
9447			 
9447			;	ld de, .regstatebc 
9447			;	ld a, display_row_3+10 
9447			;	call str_at_display 
9447			 
9447			;	pop bc 
9447			;	ld h,b 
9447			;	ld l, c 
9447			;	ld a, display_row_3+13 
9447			;	call display_word_at 
9447			 
9447			 
9447				; display dsp 
9447			 
9447			;	ld de, .regstatedsp 
9447			;	ld a, display_row_4 
9447			;	call str_at_display 
9447			 
9447				 
9447			;	ld hl,(cli_data_sp) 
9447			;	ld a, display_row_4+4 
9447			;	call display_word_at 
9447			 
9447				; display rsp 
9447			 
9447 11 2a 96			ld de, .regstatersp 
944a 3e 82			ld a, display_row_4+10 
944c cd 50 8a			call str_at_display 
944f			 
944f				 
944f 2a 33 ea			ld hl,(cli_ret_sp) 
9452 3e 86			ld a, display_row_4+14 
9454 cd f0 93			call display_word_at 
9457			 
9457 cd 60 8a			call update_display 
945a			 
945a cd ba 89			call delay1s 
945d cd ba 89			call delay1s 
9460 cd ba 89			call delay1s 
9463			 
9463			 
9463 cd 54 9a			call next_page_prompt 
9466			 
9466				; restore  
9466			 
9466 f1				pop af 
9467 e1				pop hl 
9468 c1				pop bc 
9469 d1				pop de 
946a c9				ret 
946b			 
946b			break_point_state: 
946b f5				push af 
946c			 
946c				; see if disabled 
946c			 
946c 3a f3 e2			ld a, (os_view_disable) 
946f fe 2a			cp '*' 
9471 20 02			jr nz, .bpsgo 
9473 f1				pop af 
9474 c9				ret 
9475			 
9475			.bpsgo: 
9475 f1				pop af 
9476 f5				push af 
9477 22 ef e2			ld (os_view_hl), hl 
947a ed 53 ed e2		ld (os_view_de), de 
947e ed 43 eb e2		ld (os_view_bc), bc 
9482 e5				push hl 
9483 6f				ld l, a 
9484 26 00			ld h, 0 
9486 22 f1 e2			ld (os_view_af),hl 
9489			 
9489 21 b7 ed				ld hl, display_fb0 
948c 22 d2 eb				ld (display_fb_active), hl 
948f e1				pop hl	 
9490			 
9490 3e 31			ld a, '1' 
9492 fe 2a		.bps1:  cp '*' 
9494 20 03			jr nz, .bps1b 
9496 32 f3 e2			ld (os_view_disable),a 
9499 fe 31		.bps1b:  cp '1' 
949b 20 14			jr nz, .bps2 
949d			 
949d				; display reg 
949d			 
949d				 
949d			 
949d 3a f1 e2			ld a, (os_view_af) 
94a0 2a ef e2			ld hl, (os_view_hl) 
94a3 ed 5b ed e2		ld de, (os_view_de) 
94a7 ed 4b eb e2		ld bc, (os_view_bc) 
94ab cd 45 95			call display_reg_state 
94ae c3 31 95			jp .bpschk 
94b1			 
94b1 fe 32		.bps2:  cp '2' 
94b3 20 08			jr nz, .bps3 
94b5				 
94b5				; display hl 
94b5 2a ef e2			ld hl, (os_view_hl) 
94b8 cd 2f 96			call display_dump_at_hl 
94bb			 
94bb 18 74			jr .bpschk 
94bd			 
94bd fe 33		.bps3:  cp '3' 
94bf 20 08			jr nz, .bps4 
94c1			 
94c1			        ; display de 
94c1 2a ed e2			ld hl, (os_view_de) 
94c4 cd 2f 96			call display_dump_at_hl 
94c7			 
94c7 18 68			jr .bpschk 
94c9 fe 34		.bps4:  cp '4' 
94cb 20 08			jr nz, .bps5 
94cd			 
94cd			        ; display bc 
94cd 2a eb e2			ld hl, (os_view_bc) 
94d0 cd 2f 96			call display_dump_at_hl 
94d3			 
94d3 18 5c			jr .bpschk 
94d5 fe 35		.bps5:  cp '5' 
94d7 20 08		        jr nz, .bps7 
94d9			 
94d9				; display cur ptr 
94d9 2a 4d ea			ld hl, (cli_ptr) 
94dc cd 2f 96			call display_dump_at_hl 
94df			 
94df 18 50			jr .bpschk 
94e1 fe 36		.bps7:  cp '6' 
94e3 20 08			jr nz, .bps8b 
94e5				 
94e5				; display cur orig ptr 
94e5 2a 4b ea			ld hl, (cli_origptr) 
94e8 cd 2f 96			call display_dump_at_hl 
94eb 18 44			jr .bpschk 
94ed fe 37		.bps8b:  cp '7' 
94ef 20 08			jr nz, .bps9 
94f1				 
94f1				; display dsp 
94f1 2a 2f ea			ld hl, (cli_data_sp) 
94f4 cd 2f 96			call display_dump_at_hl 
94f7			 
94f7 18 38			jr .bpschk 
94f9 fe 39		.bps9:  cp '9' 
94fb 20 05			jr nz, .bps8c 
94fd				 
94fd				; display SP 
94fd			;	ld hl, sp 
94fd cd 2f 96			call display_dump_at_hl 
9500			 
9500 18 2f			jr .bpschk 
9502 fe 38		.bps8c:  cp '8' 
9504 20 08			jr nz, .bps8d 
9506				 
9506				; display rsp 
9506 2a 33 ea			ld hl, (cli_ret_sp) 
9509 cd 2f 96			call display_dump_at_hl 
950c			 
950c 18 23			jr .bpschk 
950e fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9510 20 05			jr nz, .bps8 
9512 cd 4a 98			call monitor 
9515			 
9515 18 1a			jr .bpschk 
9517 fe 30		.bps8:  cp '0' 
9519 20 16			jr nz, .bpschk 
951b			 
951b 21 16 ed				ld hl, display_fb1 
951e 22 d2 eb				ld (display_fb_active), hl 
9521 cd 60 8a				call update_display 
9524			 
9524				;ld a, (os_view_af) 
9524 2a ef e2			ld hl, (os_view_hl) 
9527 ed 5b ed e2		ld de, (os_view_de) 
952b ed 4b eb e2		ld bc, (os_view_bc) 
952f f1				pop af 
9530 c9				ret 
9531			 
9531			.bpschk:   
9531 cd ba 89			call delay1s 
9534 3e 9f		ld a,display_row_4 + display_cols - 1 
9536 11 52 9a		        ld de, endprg 
9539 cd 50 8a			call str_at_display 
953c cd 60 8a			call update_display 
953f cd 3e da			call cin_wait 
9542			 
9542 c3 92 94			jp .bps1 
9545			 
9545			 
9545			display_reg_state: 
9545			 
9545				; to restore afterwards 
9545			 
9545 d5				push de 
9546 c5				push bc 
9547 e5				push hl 
9548 f5				push af 
9549			 
9549				; for use in here 
9549			 
9549 c5				push bc 
954a d5				push de 
954b e5				push hl 
954c f5				push af 
954d			 
954d cd 3d 8a			call clear_display 
9550			 
9550 11 05 96			ld de, .regstate 
9553 3e 00			ld a, display_row_1 
9555 cd 50 8a			call str_at_display 
9558			 
9558				; display debug step 
9558			 
9558			 
9558 11 71 ee			ld de, debug_mark 
955b 3e 25			ld a, display_row_1+display_cols-3 
955d cd 50 8a			call str_at_display 
9560			 
9560				; display a 
9560 11 21 96			ld de, .regstatea 
9563 3e 28			ld a, display_row_2 
9565 cd 50 8a			call str_at_display 
9568			 
9568 e1				pop hl 
9569			;	ld h,0 
9569			;	ld l, a 
9569 3e 2b			ld a, display_row_2+3 
956b cd f0 93			call display_word_at 
956e			 
956e			 
956e				; display hl 
956e			 
956e			 
956e 11 15 96			ld de, .regstatehl 
9571 3e 32			ld a, display_row_2+10 
9573 cd 50 8a			call str_at_display 
9576			 
9576 e1				pop hl 
9577 3e 35			ld a, display_row_2+13 
9579 cd f0 93			call display_word_at 
957c			 
957c				 
957c				; display de 
957c			 
957c 11 19 96			ld de, .regstatede 
957f 3e 50			ld a, display_row_3 
9581 cd 50 8a			call str_at_display 
9584			 
9584 e1				pop hl 
9585			;	ld h,d 
9585			;	ld l, e 
9585 3e 53			ld a, display_row_3+3 
9587 cd f0 93			call display_word_at 
958a			 
958a			 
958a				; display bc 
958a			 
958a 11 1d 96			ld de, .regstatebc 
958d 3e 5a			ld a, display_row_3+10 
958f cd 50 8a			call str_at_display 
9592			 
9592 e1				pop hl 
9593			;	ld h,b 
9593			;	ld l, c 
9593 3e 5d			ld a, display_row_3+13 
9595 cd f0 93			call display_word_at 
9598			 
9598			 
9598				; display dsp 
9598			 
9598 11 25 96			ld de, .regstatedsp 
959b 3e 78			ld a, display_row_4 
959d cd 50 8a			call str_at_display 
95a0			 
95a0				 
95a0 2a 2f ea			ld hl,(cli_data_sp) 
95a3 3e 7c			ld a, display_row_4+4 
95a5 cd f0 93			call display_word_at 
95a8			 
95a8				; display rsp 
95a8			 
95a8 11 2a 96			ld de, .regstatersp 
95ab 3e 82			ld a, display_row_4+10 
95ad cd 50 8a			call str_at_display 
95b0			 
95b0				 
95b0 2a 33 ea			ld hl,(cli_ret_sp) 
95b3 3e 86			ld a, display_row_4+14 
95b5 cd f0 93			call display_word_at 
95b8			 
95b8 cd 60 8a			call update_display 
95bb			 
95bb			;	call delay1s 
95bb			;	call delay1s 
95bb			;	call delay1s 
95bb			 
95bb			 
95bb			;	call next_page_prompt 
95bb			 
95bb				; restore  
95bb			 
95bb f1				pop af 
95bc e1				pop hl 
95bd c1				pop bc 
95be d1				pop de 
95bf c9				ret 
95c0			 
95c0 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
95d4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
95e9 .. 00		.ptrstate:	db "Ptr State",0 
95f3 .. 00		.ptrcliptr:     db "cli_ptr",0 
95fb .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9605 .. 00		.regstate:	db "Reg State (1/0)",0 
9615 .. 00		.regstatehl:	db "HL:",0 
9619 .. 00		.regstatede:	db "DE:",0 
961d .. 00		.regstatebc:	db "BC:",0 
9621 .. 00		.regstatea:	db "A :",0 
9625 .. 00		.regstatedsp:	db "DSP:",0 
962a .. 00		.regstatersp:	db "RSP:",0 
962f			 
962f			display_dump_at_hl: 
962f e5				push hl 
9630 d5				push de 
9631 c5				push bc 
9632 f5				push af 
9633			 
9633 22 25 e6			ld (os_cur_ptr),hl	 
9636 cd 3d 8a			call clear_display 
9639 cd 5c 99			call dumpcont 
963c			;	call delay1s 
963c			;	call next_page_prompt 
963c			 
963c			 
963c f1				pop af 
963d c1				pop bc 
963e d1				pop de 
963f e1				pop hl 
9640 c9				ret 
9641			 
9641			;if ENABLE_BASIC 
9641			;	include "nascombasic.asm" 
9641			;	basic: 
9641			;	include "forth/FORTH.ASM" 
9641			;endif 
9641			 
9641			; eof 
9641			 
9641			 
# End of file firmware_diags.asm
9641			  
9641			include "firmware_prompts.asm"  
9641			; Prompts  
9641			 
9641			; boot messages 
9641			 
9641 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
9656 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
9666			 
9666			 
9666			; config menus 
9666			 
9666 .. 00		prom_c3: db "Add Dictionary To File",0 
967d .. 00		prom_c2: db "Select Autoload File",0 
9692 .. 00		prom_c2a: db "Disable Autoload File", 0 
96a8 .. 00		prom_c2b: db "Select Storage Bank",0 
96bc .. 00		prom_c4: db "Settings",0 
96c5 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
96e0 .. 00		prom_m4b:   db "Monitor",0 
96e8 .. 00		prom_c1: db "Hardware Diags",0 
96f7			 
96f7			 
96f7 .. 00		prom_notav:    db "Feature not available",0 
970d .. 00		prom_empty:    db "",0 
970e			 
970e			; eof 
970e			 
# End of file firmware_prompts.asm
970e			  
970e			  
970e			; eof  
970e			  
# End of file firmware.asm
970e			 
970e			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
970e			;if BASE_KEV  
970e			;baseram: equ 08000h 
970e			;endif 
970e			 
970e			;if BASE_SC114 
970e			;baseram:     equ    endofcode 
970e			;endif 
970e			 
970e			 
970e			; start system 
970e			 
970e			coldstart: 
970e				; set sp 
970e				; di/ei 
970e			 
970e f3				di 
970f 31 00 f0			ld sp, tos 
9712			;	ei 
9712			 
9712			 
9712				; disable breakpoint by default 
9712			 
9712 3e 2a			ld a,'*' 
9714 32 f3 e2			ld (os_view_disable),a 
9717			 
9717				; init hardware 
9717			 
9717				; init keyboard and screen hardware 
9717			 
9717 cd 1c 80			call hardware_init 
971a			 
971a			 
971a cd ba 89			call delay1s 
971d 3e 58			ld a, display_row_3+8 
971f 11 03 80			ld de, buildtime 
9722 cd 50 8a			call str_at_display 
9725 cd 60 8a			call update_display 
9728			 
9728 cd ba 89			call delay1s 
972b cd ba 89			call delay1s 
972e cd ba 89			call delay1s 
9731			 
9731				; detect if any keys are held down to enable breakpoints at start up 
9731			 
9731 cd 44 da			call cin  
9734 fe 00			cp 0 
9736 28 03			jr z, .nokeys 
9738			 
9738				;call hardware_diags 
9738 cd ca 92			call config 
973b			 
973b			;	ld de, .bpen 
973b			;	ld a, display_row_4 
973b			;	call str_at_display 
973b			;	call update_display 
973b			; 
973b			;	ld a,0 
973b			;	ld (os_view_disable),a 
973b			; 
973b			;.bpwait: 
973b			;	call cin 
973b			;	cp 0 
973b			;	jr z, .bpwait 
973b			;	jr .nokeys 
973b			; 
973b			; 
973b			;.bpen:  db "Break points enabled!",0 
973b			 
973b			 
973b			 
973b			 
973b			 
973b			 
973b			.nokeys: 
973b			 
973b			 
973b				 
973b			 
973b			;jp  testkey 
973b			 
973b			;call storage_get_block_0 
973b			; 
973b			;ld hl, 0 
973b			;ld de, store_page 
973b			;call storage_read_block 
973b			 
973b				 
973b			;ld hl, 10 
973b			;ld de, store_page 
973b			;call storage_read_block 
973b			 
973b			 
973b			 
973b			 
973b			 
973b			;stop:	nop 
973b			;	jp stop 
973b			 
973b			 
973b			 
973b			main: 
973b cd 3d 8a			call clear_display 
973e cd 60 8a			call update_display 
9741			 
9741			 
9741			 
9741			;	call testlcd 
9741			 
9741			 
9741			 
9741 cd 1a 9e			call forth_init 
9744			 
9744			 
9744			warmstart: 
9744 cd f0 9d			call forth_warmstart 
9747			 
9747				; run startup word load 
9747			        ; TODO prevent this running at warmstart after crash  
9747			 
9747				if STARTUP_ENABLE 
9747					if STORAGE_SE 
9747						call forth_autoload 
9747					endif 
9747 cd d8 d6				call forth_startup 
974a			 
974a			 
974a				endif 
974a			 
974a				; show free memory after boot 
974a 11 e4 97			ld de, freeram 
974d 3e 00			ld a, display_row_1 
974f cd 50 8a			call str_at_display 
9752			 
9752			; Or use heap_size word???? 
9752 21 e8 e2			ld hl, heap_end 
9755 11 62 da			ld de, heap_start 
9758 ed 52			sbc hl, de 
975a e5				push hl 
975b 7c				ld a,h	         	 
975c 21 07 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
975f cd 6b 8f			call hexout 
9762 e1			   	pop hl 
9763			 
9763 7d				ld a,l 
9764 21 09 e6			ld hl, os_word_scratch+2 
9767 cd 6b 8f			call hexout 
976a 21 0b e6			ld hl, os_word_scratch+4 
976d 3e 00			ld a, 0 
976f 77				ld (hl),a 
9770 11 07 e6			ld de, os_word_scratch 
9773 3e 0d			ld a, display_row_1 + 13 
9775 cd 50 8a			call str_at_display 
9778 cd 60 8a			call update_display 
977b			 
977b			 
977b				;call demo 
977b			 
977b			 
977b				; init scratch input area for cli commands 
977b			 
977b 21 29 e6			ld hl, os_cli_cmd 
977e 3e 00			ld a,0 
9780 77				ld (hl),a 
9781 23				inc hl 
9782 77				ld (hl),a 
9783			 
9783 3e 00			ld a,0 
9785 32 28 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
9788			 
9788 32 25 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
978b 32 26 e6			ld (os_cur_ptr+1),a	 
978e			 
978e 32 07 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9791 32 08 e6			ld (os_word_scratch+1),a	 
9794				 
9794			 
9794				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9794 21 29 e6			ld hl, os_cli_cmd 
9797			 
9797 3e 00			ld a, 0		 ; init cli input 
9799 77				ld (hl), a 
979a 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
979c			cli: 
979c				; show cli prompt 
979c				;push af 
979c				;ld a, 0 
979c				;ld de, prompt 
979c				;call str_at_display 
979c			 
979c				;call update_display 
979c				;pop af 
979c				;inc a 
979c				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
979c 0e 00			ld c, 0 
979e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97a0 1e 28			ld e, 40 
97a2			 
97a2 21 29 e6			ld hl, os_cli_cmd 
97a5			 
97a5				STACKFRAME OFF $fefe $9f9f 
97a5				if DEBUG_STACK_IMB 
97a5					if OFF 
97a5						exx 
97a5						ld de, $fefe 
97a5						ld a, d 
97a5						ld hl, curframe 
97a5						call hexout 
97a5						ld a, e 
97a5						ld hl, curframe+2 
97a5						call hexout 
97a5						ld hl, $fefe 
97a5						push hl 
97a5						ld hl, $9f9f 
97a5						push hl 
97a5						exx 
97a5					endif 
97a5				endif 
97a5			endm 
# End of macro STACKFRAME
97a5			 
97a5 cd 97 8c			call input_str 
97a8			 
97a8				STACKFRAMECHK OFF $fefe $9f9f 
97a8				if DEBUG_STACK_IMB 
97a8					if OFF 
97a8						exx 
97a8						ld hl, $9f9f 
97a8						pop de   ; $9f9f 
97a8						call cmp16 
97a8						jr nz, .spnosame 
97a8						ld hl, $fefe 
97a8						pop de   ; $fefe 
97a8						call cmp16 
97a8						jr z, .spfrsame 
97a8						.spnosame: call showsperror 
97a8						.spfrsame: nop 
97a8						exx 
97a8					endif 
97a8				endif 
97a8			endm 
# End of macro STACKFRAMECHK
97a8			 
97a8				; copy input to last command 
97a8			 
97a8 21 29 e6			ld hl, os_cli_cmd 
97ab 11 28 e7			ld de, os_last_cmd 
97ae 01 ff 00			ld bc, 255 
97b1 ed b0			ldir 
97b3			 
97b3				; wipe current buffer 
97b3			 
97b3			;	ld a, 0 
97b3			;	ld hl, os_cli_cmd 
97b3			;	ld de, os_cli_cmd+1 
97b3			;	ld bc, 254 
97b3			;	ldir 
97b3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97b3			;	call strcpy 
97b3			;	ld a, 0 
97b3			;	ld (hl), a 
97b3			;	inc hl 
97b3			;	ld (hl), a 
97b3			;	inc hl 
97b3			;	ld (hl), a 
97b3			 
97b3				; switch frame buffer to program  
97b3			 
97b3 21 16 ed				ld hl, display_fb1 
97b6 22 d2 eb				ld (display_fb_active), hl 
97b9			 
97b9			;	nop 
97b9				STACKFRAME ON $fbfe $8f9f 
97b9				if DEBUG_STACK_IMB 
97b9					if ON 
97b9						exx 
97b9						ld de, $fbfe 
97b9						ld a, d 
97b9						ld hl, curframe 
97b9						call hexout 
97b9						ld a, e 
97b9						ld hl, curframe+2 
97b9						call hexout 
97b9						ld hl, $fbfe 
97b9						push hl 
97b9						ld hl, $8f9f 
97b9						push hl 
97b9						exx 
97b9					endif 
97b9				endif 
97b9			endm 
# End of macro STACKFRAME
97b9				; first time into the parser so pass over the current scratch pad 
97b9 21 29 e6			ld hl,os_cli_cmd 
97bc				; tokenise the entered statement(s) in HL 
97bc cd 98 9e			call forthparse 
97bf			        ; exec forth statements in top of return stack 
97bf cd d8 9e			call forthexec 
97c2				;call forthexec_cleanup 
97c2			;	call parsenext 
97c2			 
97c2				STACKFRAMECHK ON $fbfe $8f9f 
97c2				if DEBUG_STACK_IMB 
97c2					if ON 
97c2						exx 
97c2						ld hl, $8f9f 
97c2						pop de   ; $8f9f 
97c2						call cmp16 
97c2						jr nz, .spnosame 
97c2						ld hl, $fbfe 
97c2						pop de   ; $fbfe 
97c2						call cmp16 
97c2						jr z, .spfrsame 
97c2						.spnosame: call showsperror 
97c2						.spfrsame: nop 
97c2						exx 
97c2					endif 
97c2				endif 
97c2			endm 
# End of macro STACKFRAMECHK
97c2				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
97c2			 
97c2 3e 78			ld a, display_row_4 
97c4 11 f6 97			ld de, endprog 
97c7			 
97c7 cd 60 8a			call update_display		 
97ca			 
97ca cd 54 9a			call next_page_prompt 
97cd			 
97cd				; switch frame buffer to cli 
97cd			 
97cd 21 b7 ed				ld hl, display_fb0 
97d0 22 d2 eb				ld (display_fb_active), hl 
97d3			 
97d3			 
97d3 cd 3d 8a		        call clear_display 
97d6 cd 60 8a			call update_display		 
97d9			 
97d9 21 29 e6			ld hl, os_cli_cmd 
97dc			 
97dc 3e 00			ld a, 0		 ; init cli input 
97de 77				ld (hl), a 
97df			 
97df				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
97df			 
97df				; now on last line 
97df			 
97df				; TODO scroll screen up 
97df			 
97df				; TODO instead just clear screen and place at top of screen 
97df			 
97df			;	ld a, 0 
97df			;	ld (f_cursor_ptr),a 
97df			 
97df				;call clear_display 
97df				;call update_display 
97df			 
97df				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97df 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97e1 c3 9c 97			jp cli 
97e4			 
97e4 .. 00		freeram: db "Free bytes: $",0 
97f2 ..			asc: db "1A2F" 
97f6 .. 00		endprog: db "End prog...",0 
9802			 
9802			testenter2:   
9802 21 34 e3			ld hl,scratch+50 
9805 22 25 e6			ld (os_cur_ptr),hl 
9808 c3 9c 97			jp cli 
980b			 
980b			testenter:  
980b			 
980b 21 f2 97			ld hl,asc 
980e			;	ld a,(hl) 
980e			;	call nibble2val 
980e cd c1 8f			call get_byte 
9811			 
9811			 
9811			;	ld a,(hl) 
9811			;	call atohex 
9811			 
9811			;	call fourehexhl 
9811 32 34 e3			ld (scratch+50),a 
9814			 
9814			 
9814			 
9814 21 f4 97			ld hl,asc+2 
9817			;	ld a, (hl) 
9817			;	call nibble2val 
9817 cd c1 8f			call get_byte 
981a			 
981a			;	call fourehexhl 
981a 32 36 e3			ld (scratch+52),a 
981d				 
981d 21 34 e3			ld hl,scratch+50 
9820 22 25 e6			ld (os_cur_ptr),hl 
9823 c3 9c 97			jp cli 
9826			 
9826			enter:	 
9826 3a 06 e3			ld a,(scratch+4) 
9829 fe 00			cp 0 
982b 28 0c			jr z, .entercont 
982d				; no, not a null term line so has an address to work out.... 
982d			 
982d 21 04 e3			ld hl,scratch+2 
9830 cd 21 90			call get_word_hl 
9833			 
9833 22 25 e6			ld (os_cur_ptr),hl	 
9836 c3 9c 97			jp cli 
9839			 
9839			 
9839			.entercont:  
9839			 
9839 21 04 e3			ld hl, scratch+2 
983c cd c1 8f			call get_byte 
983f			 
983f 2a 25 e6		   	ld hl,(os_cur_ptr) 
9842 77					ld (hl),a 
9843 23					inc hl 
9844 22 25 e6				ld (os_cur_ptr),hl 
9847				 
9847			; get byte  
9847			 
9847			 
9847 c3 9c 97			jp cli 
984a			 
984a			 
984a			; basic monitor support 
984a			 
984a			monitor: 
984a				;  
984a cd 3d 8a			call clear_display 
984d 3e 00			ld a, 0 
984f 11 97 98			ld de, .monprompt 
9852 cd 50 8a			call str_at_display 
9855 cd 60 8a			call update_display 
9858			 
9858				; get a monitor command 
9858			 
9858 0e 00			ld c, 0     ; entry at top left 
985a 16 64			ld d, 100   ; max buffer size 
985c 1e 0f			ld e, 15    ; input scroll area 
985e 3e 00			ld a, 0     ; init string 
9860 21 00 e5			ld hl, os_input 
9863 77				ld (hl), a 
9864 23				inc hl 
9865 77				ld (hl), a 
9866 21 00 e5			ld hl, os_input 
9869 3e 01			ld a, 1     ; init string 
986b cd 97 8c			call input_str 
986e			 
986e cd 3d 8a		        call clear_display 
9871 cd 60 8a			call update_display		 
9874			 
9874 3a 00 e5			ld a, (os_input) 
9877 cd bf 90			call toUpper 
987a fe 48		        cp 'H' 
987c 28 6f		        jr z, .monhelp 
987e fe 44			cp 'D'		; dump 
9880 ca 0e 99			jp z, .mondump	 
9883 fe 43			cp 'C'		; dump 
9885 ca 28 99			jp z, .moncdump	 
9888 fe 4d			cp 'M'		; dump 
988a ca 99 98			jp z, .moneditstart 
988d fe 55			cp 'U'		; dump 
988f 28 14			jr z, .monedit	 
9891 fe 51			cp 'Q'		; dump 
9893 c8				ret z	 
9894			 
9894			 
9894				; TODO "S" to access symbol by name and not need the address 
9894				; TODO "F" to find a string in memory 
9894			 
9894 c3 4a 98			jp monitor 
9897			 
9897 .. 00		.monprompt: db ">", 0 
9899			 
9899			.moneditstart: 
9899				; get starting address 
9899			 
9899 21 02 e5			ld hl,os_input+2 
989c cd 21 90			call get_word_hl 
989f			 
989f 22 25 e6			ld (os_cur_ptr),hl	 
98a2			 
98a2 c3 4a 98			jp monitor 
98a5			 
98a5			.monedit: 
98a5				; get byte to load 
98a5			 
98a5 21 02 e5			ld hl,os_input+2 
98a8 cd c1 8f			call get_byte 
98ab			 
98ab				; get address to update 
98ab 2a 25 e6			ld hl, (os_cur_ptr) 
98ae			 
98ae				; update byte 
98ae			 
98ae 77				ld (hl), a 
98af			 
98af				; move to next address and save it 
98af			 
98af 23				inc hl 
98b0 22 25 e6			ld (os_cur_ptr),hl	 
98b3			 
98b3 c3 4a 98			jp monitor 
98b6			 
98b6			 
98b6 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
98ca .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
98e6 .. 00		.monhelptext3:  db "Q-Quit",0 
98ed			        
98ed			.monhelp: 
98ed 3e 00			ld a, display_row_1 
98ef 11 b6 98		        ld de, .monhelptext1 
98f2			 
98f2 cd 50 8a			call str_at_display 
98f5 3e 28			ld a, display_row_2 
98f7 11 ca 98		        ld de, .monhelptext2 
98fa					 
98fa cd 50 8a			call str_at_display 
98fd 3e 50			ld a, display_row_3 
98ff 11 e6 98		        ld de, .monhelptext3 
9902					 
9902 cd 50 8a			call str_at_display 
9905 cd 60 8a			call update_display		 
9908			 
9908 cd 54 9a			call next_page_prompt 
990b c3 4a 98			jp monitor 
990e			 
990e			.mondump:    
990e 21 02 e5			ld hl,os_input+2 
9911 cd 21 90			call get_word_hl 
9914			 
9914 22 25 e6			ld (os_cur_ptr),hl	 
9917 cd 5c 99			call dumpcont 
991a 3e 78			ld a, display_row_4 
991c 11 f6 97			ld de, endprog 
991f			 
991f cd 60 8a			call update_display		 
9922			 
9922 cd 54 9a			call next_page_prompt 
9925 c3 4a 98			jp monitor 
9928			.moncdump: 
9928 cd 5c 99			call dumpcont 
992b 3e 78			ld a, display_row_4 
992d 11 f6 97			ld de, endprog 
9930			 
9930 cd 60 8a			call update_display		 
9933			 
9933 cd 54 9a			call next_page_prompt 
9936 c3 4a 98			jp monitor 
9939			 
9939			 
9939			; TODO symbol access  
9939			 
9939			.symbols:     ;; A list of symbols that can be called up  
9939 b7 ed			dw display_fb0 
993b .. 00			db "fb0",0  
993f 84 ea		     	dw store_page 
9941 .. 00			db "store_page",0 
994c			 
994c			 
994c			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
994c			 
994c 3a 03 e3			ld a,(scratch+1) 
994f fe 00			cp 0 
9951 28 09			jr z, dumpcont 
9953			 
9953				; no, not a null term line so has an address to work out.... 
9953			 
9953 21 04 e3			ld hl,scratch+2 
9956 cd 21 90			call get_word_hl 
9959			 
9959 22 25 e6			ld (os_cur_ptr),hl	 
995c			 
995c			 
995c			 
995c			dumpcont: 
995c			 
995c				; dump bytes at ptr 
995c			 
995c			 
995c 3e 00			ld a, display_row_1 
995e 2a d2 eb			ld hl, (display_fb_active) 
9961 cd 6a 8c			call addatohl 
9964 cd 8c 99			call .dumpbyterow 
9967			 
9967 3e 28			ld a, display_row_2 
9969 2a d2 eb			ld hl, (display_fb_active) 
996c cd 6a 8c			call addatohl 
996f cd 8c 99			call .dumpbyterow 
9972			 
9972			 
9972 3e 50			ld a, display_row_3 
9974 2a d2 eb			ld hl, (display_fb_active) 
9977 cd 6a 8c			call addatohl 
997a cd 8c 99			call .dumpbyterow 
997d			 
997d 3e 78			ld a, display_row_4 
997f 2a d2 eb			ld hl, (display_fb_active) 
9982 cd 6a 8c			call addatohl 
9985 cd 8c 99			call .dumpbyterow 
9988			 
9988 cd 60 8a			call update_display 
998b			;		jp cli 
998b c9				ret 
998c			 
998c			.dumpbyterow: 
998c			 
998c				;push af 
998c			 
998c e5				push hl 
998d			 
998d				; calc where to poke the ascii 
998d			if display_cols == 20 
998d				ld a, 16 
998d			else 
998d 3e 1f			ld a, 31 
998f			endif 
998f			 
998f cd 6a 8c			call addatohl 
9992 22 07 e6			ld (os_word_scratch),hl  		; save pos for later 
9995			 
9995			 
9995			; display decoding address 
9995 2a 25 e6		   	ld hl,(os_cur_ptr) 
9998			 
9998 7c				ld a,h 
9999 e1				pop hl 
999a e5				push hl 
999b			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
999b cd 6b 8f			call hexout 
999e 2a 25 e6		   	ld hl,(os_cur_ptr) 
99a1			 
99a1 7d				ld a,l 
99a2 e1				pop hl 
99a3 23				inc hl 
99a4 23				inc hl 
99a5 e5				push hl 
99a6			;	ld hl, os_word_scratch+2 
99a6 cd 6b 8f			call hexout 
99a9 e1				pop hl 
99aa 23				inc hl 
99ab 23				inc hl 
99ac				;ld hl, os_word_scratch+4 
99ac 3e 3a			ld a, ':' 
99ae 77				ld (hl),a 
99af 23				inc hl 
99b0				;ld a, 0 
99b0				;ld (hl),a 
99b0				;ld de, os_word_scratch 
99b0				;pop af 
99b0				;push af 
99b0			;		ld a, display_row_2 
99b0			;		call str_at_display 
99b0			;		call update_display 
99b0			 
99b0			 
99b0			;pop af 
99b0			;	add 5 
99b0			 
99b0			if display_cols == 20 
99b0				ld b, 4 
99b0			else 
99b0 06 08			ld b, 8 
99b2			endif	 
99b2			 
99b2			.dumpbyte: 
99b2 c5				push bc 
99b3 e5				push hl 
99b4			 
99b4			 
99b4 2a 25 e6		   	ld hl,(os_cur_ptr) 
99b7 7e					ld a,(hl) 
99b8			 
99b8					; poke the ascii to display 
99b8 2a 07 e6				ld hl,(os_word_scratch) 
99bb 77					ld (hl),a 
99bc 23					inc hl 
99bd 22 07 e6				ld (os_word_scratch),hl 
99c0			 
99c0					 
99c0			 
99c0			 
99c0 e1					pop hl 
99c1 e5					push hl 
99c2			 
99c2 cd 6b 8f				call hexout 
99c5			 
99c5					 
99c5 2a 25 e6		   	ld hl,(os_cur_ptr) 
99c8 23				inc hl 
99c9 22 25 e6		   	ld (os_cur_ptr),hl 
99cc			 
99cc e1					pop hl 
99cd 23					inc hl 
99ce 23					inc hl 
99cf 23					inc hl 
99d0			 
99d0			 
99d0			 
99d0					;ld a,0 
99d0					;ld (os_word_scratch+2),a 
99d0					;pop af 
99d0					;push af 
99d0			 
99d0					;ld de, os_word_scratch 
99d0					;call str_at_display 
99d0			;		call update_display 
99d0			;		pop af 
99d0 c1					pop bc 
99d1 c6 03				add 3 
99d3 10 dd			djnz .dumpbyte 
99d5			 
99d5				 
99d5			 
99d5 c9				ret 
99d6			 
99d6			jump:	 
99d6			 
99d6 21 04 e3			ld hl,scratch+2 
99d9 cd 21 90			call get_word_hl 
99dc				;ld hl,(scratch+2) 
99dc				;call fourehexhl 
99dc			 
99dc 22 25 e6			ld (os_cur_ptr),hl	 
99df			 
99df e9				jp (hl) 
99e0			 
99e0			 
99e0			 
99e0			; TODO implement a basic monitor mode to start with 
99e0			 
99e0			 
99e0			 
99e0			 
99e0			 
99e0			 
99e0			 
99e0			 
99e0			 
99e0			; testing and demo code during development 
99e0			 
99e0			 
99e0 .. 00		str1: db "Enter some text...",0 
99f3 .. 00		clear: db "                    ",0 
9a08			 
9a08			demo: 
9a08			 
9a08			 
9a08			 
9a08			;	call update_display 
9a08			 
9a08				; init scratch input area for testing 
9a08 21 02 e3			ld hl, scratch	 
9a0b 3e 00			ld a,0 
9a0d 77				ld (hl),a 
9a0e			 
9a0e			 
9a0e 3e 28		            LD   A, display_row_2 
9a10			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a10 11 e0 99		            LD   DE, str1 
9a13 cd 50 8a			call str_at_display 
9a16			 
9a16			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a16			cloop:	 
9a16 3e 50		            LD   A, display_row_3 
9a18			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a18 11 f3 99		            LD   DE, clear 
9a1b			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a1b cd 50 8a				call str_at_display 
9a1e 3e 78			ld a, display_row_4 
9a20 11 50 9a			ld de, prompt 
9a23			 
9a23 cd 50 8a				call str_at_display 
9a26 cd 60 8a			call update_display 
9a29			 
9a29 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a2b 16 0a			ld d, 10 
9a2d 21 02 e3			ld hl, scratch	 
9a30 cd 97 8c			call input_str 
9a33			 
9a33			;	call clear_display 
9a33			;'	call update_display 
9a33			 
9a33 3e 00		            LD   A, display_row_1 
9a35			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a35 11 f3 99		            LD   DE, clear 
9a38 cd 50 8a				call str_at_display 
9a3b			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a3b 3e 00		            LD   A, display_row_1 
9a3d			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a3d 11 02 e3		            LD   DE, scratch 
9a40			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a40 cd 50 8a				call str_at_display 
9a43 cd 60 8a			call update_display 
9a46			 
9a46 3e 00				ld a,0 
9a48 21 02 e3			ld hl, scratch 
9a4b 77				ld (hl),a 
9a4c			 
9a4c 00				nop 
9a4d c3 16 9a			jp cloop 
9a50			 
9a50			 
9a50			 
9a50			; OS Prompt 
9a50			 
9a50 .. 00		prompt: db ">",0 
9a52 .. 00		endprg: db "?",0 
9a54			 
9a54			 
9a54			; handy next page prompt 
9a54			next_page_prompt: 
9a54 e5				push hl 
9a55 d5				push de 
9a56 f5				push af 
9a57 c5				push bc 
9a58			 
9a58 3e 9f			ld a,display_row_4 + display_cols - 1 
9a5a 11 52 9a		        ld de, endprg 
9a5d cd 50 8a			call str_at_display 
9a60 cd 60 8a			call update_display 
9a63 cd 3e da			call cin_wait 
9a66 c1				pop bc 
9a67 f1				pop af 
9a68 d1				pop de 
9a69 e1				pop hl 
9a6a			 
9a6a			 
9a6a c9				ret 
9a6b			 
9a6b			 
9a6b			; forth parser 
9a6b			 
9a6b			; My forth kernel 
9a6b			include "forth_kernel.asm" 
9a6b			; 
9a6b			; kernel to the forth OS 
9a6b			 
9a6b			DS_TYPE_STR: equ 1     ; string type 
9a6b			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9a6b			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9a6b			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9a6b			 
9a6b			FORTH_PARSEV1: equ 0 
9a6b			FORTH_PARSEV2: equ 0 
9a6b			FORTH_PARSEV3: equ 0 
9a6b			FORTH_PARSEV4: equ 0 
9a6b			FORTH_PARSEV5: equ 1 
9a6b			 
9a6b			;if FORTH_PARSEV5 
9a6b			;	FORTH_END_BUFFER: equ 0 
9a6b			;else 
9a6b			FORTH_END_BUFFER: equ 127 
9a6b			;endif 
9a6b			 
9a6b			FORTH_TRUE: equ 1 
9a6b			FORTH_FALSE: equ 0 
9a6b			 
9a6b			if FORTH_PARSEV4 
9a6b			include "forth_stackops.asm" 
9a6b			endif 
9a6b			 
9a6b			if FORTH_PARSEV5 
9a6b			include "forth_stackopsv5.asm" 
9a6b			 
9a6b			; Stack operations for v5 parser on wards 
9a6b			; * DATA stack 
9a6b			; * LOOP stack 
9a6b			; * RETURN stack 
9a6b			 
9a6b			 
9a6b			 
9a6b			FORTH_CHK_DSP_UNDER: macro 
9a6b				push hl 
9a6b				push de 
9a6b				ld hl,(cli_data_sp) 
9a6b				ld de, cli_data_stack 
9a6b				call cmp16 
9a6b				jp c, fault_dsp_under 
9a6b				pop de 
9a6b				pop hl 
9a6b				endm 
9a6b			 
9a6b			 
9a6b			FORTH_CHK_RSP_UNDER: macro 
9a6b				push hl 
9a6b				push de 
9a6b				ld hl,(cli_ret_sp) 
9a6b				ld de, cli_ret_stack 
9a6b				call cmp16 
9a6b				jp c, fault_rsp_under 
9a6b				pop de 
9a6b				pop hl 
9a6b				endm 
9a6b			 
9a6b			FORTH_CHK_LOOP_UNDER: macro 
9a6b				push hl 
9a6b				push de 
9a6b				ld hl,(cli_loop_sp) 
9a6b				ld de, cli_loop_stack 
9a6b				call cmp16 
9a6b				jp c, fault_loop_under 
9a6b				pop de 
9a6b				pop hl 
9a6b				endm 
9a6b			 
9a6b			FORTH_ERR_TOS_NOTSTR: macro 
9a6b				; TOSO might need more for checks when used 
9a6b				push af 
9a6b				ld a,(hl) 
9a6b				cp DS_TYPE_STR 
9a6b				jp nz, type_faultn   
9a6b				pop af 
9a6b				endm 
9a6b			 
9a6b			FORTH_ERR_TOS_NOTNUM: macro 
9a6b				push af 
9a6b				ld a,(hl) 
9a6b				cp DS_TYPE_INUM 
9a6b				jp nz, type_faultn   
9a6b				pop af 
9a6b				endm 
9a6b			 
9a6b			 
9a6b			; increase data stack pointer and save hl to it 
9a6b				 
9a6b			FORTH_DSP_NEXT: macro 
9a6b				call macro_forth_dsp_next 
9a6b				endm 
9a6b			 
9a6b			 
9a6b			macro_forth_dsp_next: 
9a6b				if DEBUG_FORTH_STACK_GUARD 
9a6b cd a2 d7				call check_stacks 
9a6e				endif 
9a6e e5				push hl 
9a6f d5				push de 
9a70 eb				ex de,hl 
9a71 2a 2f ea			ld hl,(cli_data_sp) 
9a74 23				inc hl 
9a75 23				inc hl 
9a76			 
9a76			; PARSEV5 
9a76 23				inc hl 
9a77 22 2f ea			ld (cli_data_sp),hl 
9a7a 73				ld (hl), e 
9a7b 23				inc hl 
9a7c 72				ld (hl), d 
9a7d d1				pop de 
9a7e e1				pop hl 
9a7f				if DEBUG_FORTH_STACK_GUARD 
9a7f cd a2 d7				call check_stacks 
9a82				endif 
9a82 c9				ret 
9a83			 
9a83			 
9a83			; increase ret stack pointer and save hl to it 
9a83				 
9a83			FORTH_RSP_NEXT: macro 
9a83				call macro_forth_rsp_next 
9a83				endm 
9a83			 
9a83			macro_forth_rsp_next: 
9a83				if DEBUG_FORTH_STACK_GUARD 
9a83 cd a2 d7				call check_stacks 
9a86				endif 
9a86 e5				push hl 
9a87 d5				push de 
9a88 eb				ex de,hl 
9a89 2a 33 ea			ld hl,(cli_ret_sp) 
9a8c 23				inc hl 
9a8d 23				inc hl 
9a8e 22 33 ea			ld (cli_ret_sp),hl 
9a91 73				ld (hl), e 
9a92 23				inc hl 
9a93 72				ld (hl), d 
9a94 d1				pop de 
9a95 e1				pop hl 
9a96				if DEBUG_FORTH_STACK_GUARD 
9a96 cd a2 d7				call check_stacks 
9a99				endif 
9a99 c9				ret 
9a9a			 
9a9a			; get current ret stack pointer and save to hl  
9a9a				 
9a9a			FORTH_RSP_TOS: macro 
9a9a				call macro_forth_rsp_tos 
9a9a				endm 
9a9a			 
9a9a			macro_forth_rsp_tos: 
9a9a				;push de 
9a9a 2a 33 ea			ld hl,(cli_ret_sp) 
9a9d cd d5 9a			call loadhlptrtohl 
9aa0				;ld e, (hl) 
9aa0				;inc hl 
9aa0				;ld d, (hl) 
9aa0				;ex de, hl 
9aa0					if DEBUG_FORTH_WORDS 
9aa0			;			DMARK "RST" 
9aa0						CALLMONITOR 
9aa0 cd 6b 94			call break_point_state  
9aa3				endm  
# End of macro CALLMONITOR
9aa3					endif 
9aa3				;pop de 
9aa3 c9				ret 
9aa4			 
9aa4			; pop ret stack pointer 
9aa4				 
9aa4			FORTH_RSP_POP: macro 
9aa4				call macro_forth_rsp_pop 
9aa4				endm 
9aa4			 
9aa4			 
9aa4			macro_forth_rsp_pop: 
9aa4				if DEBUG_FORTH_STACK_GUARD 
9aa4			;		DMARK "RPP" 
9aa4 cd a2 d7				call check_stacks 
9aa7					FORTH_CHK_RSP_UNDER 
9aa7 e5				push hl 
9aa8 d5				push de 
9aa9 2a 33 ea			ld hl,(cli_ret_sp) 
9aac 11 ed e9			ld de, cli_ret_stack 
9aaf cd 88 8c			call cmp16 
9ab2 da b6 d8			jp c, fault_rsp_under 
9ab5 d1				pop de 
9ab6 e1				pop hl 
9ab7				endm 
# End of macro FORTH_CHK_RSP_UNDER
9ab7				endif 
9ab7 e5				push hl 
9ab8 2a 33 ea			ld hl,(cli_ret_sp) 
9abb			 
9abb			 
9abb				if FORTH_ENABLE_FREE 
9abb			 
9abb					; get pointer 
9abb			 
9abb					push de 
9abb					push hl 
9abb			 
9abb					ld e, (hl) 
9abb					inc hl 
9abb					ld d, (hl) 
9abb			 
9abb					ex de, hl 
9abb					call free 
9abb			 
9abb					pop hl 
9abb					pop de 
9abb			 
9abb			 
9abb				endif 
9abb			 
9abb			 
9abb 2b				dec hl 
9abc 2b				dec hl 
9abd 22 33 ea			ld (cli_ret_sp), hl 
9ac0				; do stack underflow checks 
9ac0 e1				pop hl 
9ac1				if DEBUG_FORTH_STACK_GUARD 
9ac1 cd a2 d7				call check_stacks 
9ac4					FORTH_CHK_RSP_UNDER 
9ac4 e5				push hl 
9ac5 d5				push de 
9ac6 2a 33 ea			ld hl,(cli_ret_sp) 
9ac9 11 ed e9			ld de, cli_ret_stack 
9acc cd 88 8c			call cmp16 
9acf da b6 d8			jp c, fault_rsp_under 
9ad2 d1				pop de 
9ad3 e1				pop hl 
9ad4				endm 
# End of macro FORTH_CHK_RSP_UNDER
9ad4				endif 
9ad4 c9				ret 
9ad5			 
9ad5			 
9ad5			 
9ad5			; routine to load word pointed to by hl into hl 
9ad5			 
9ad5			loadhlptrtohl: 
9ad5			 
9ad5 d5				push de 
9ad6 5e				ld e, (hl) 
9ad7 23				inc hl 
9ad8 56				ld d, (hl) 
9ad9 eb				ex de, hl 
9ada d1				pop de 
9adb			 
9adb c9				ret 
9adc			 
9adc			 
9adc			 
9adc			 
9adc			 
9adc			; push a number held in HL onto the data stack 
9adc			; entry point for pushing a value when already in hl used in function above 
9adc			 
9adc			forth_push_numhl: 
9adc			 
9adc e5				push hl    ; save value to push 
9add			 
9add			if DEBUG_FORTH_PUSH 
9add				; see if disabled 
9add			 
9add			 
9add f5				push af 
9ade 3a f3 e2			ld a, (os_view_disable) 
9ae1 fe 2a			cp '*' 
9ae3 28 34			jr z, .pskip2 
9ae5 e5				push hl 
9ae6 e5			push hl 
9ae7 cd 3d 8a			call clear_display 
9aea e1			pop hl 
9aeb 7c				ld a,h 
9aec 21 07 e6			ld hl, os_word_scratch 
9aef cd 6b 8f			call hexout 
9af2 e1				pop hl 
9af3 7d				ld a,l 
9af4 21 09 e6			ld hl, os_word_scratch+2 
9af7 cd 6b 8f			call hexout 
9afa			 
9afa 21 0b e6			ld hl, os_word_scratch+4 
9afd 3e 00			ld a,0 
9aff 77				ld (hl),a 
9b00 11 07 e6			ld de,os_word_scratch 
9b03 3e 28				ld a, display_row_2 
9b05 cd 50 8a				call str_at_display 
9b08 11 59 c6			ld de, .push_num 
9b0b 3e 00			ld a, display_row_1 
9b0d			 
9b0d cd 50 8a				call str_at_display 
9b10			 
9b10			 
9b10 cd 60 8a			call update_display 
9b13 cd ba 89			call delay1s 
9b16 cd ba 89			call delay1s 
9b19			.pskip2:  
9b19			 
9b19 f1				pop af 
9b1a			endif	 
9b1a			 
9b1a			 
9b1a				FORTH_DSP_NEXT 
9b1a cd 6b 9a			call macro_forth_dsp_next 
9b1d				endm 
# End of macro FORTH_DSP_NEXT
9b1d			 
9b1d 2a 2f ea			ld hl, (cli_data_sp) 
9b20			 
9b20				; save item type 
9b20 3e 02			ld a,  DS_TYPE_INUM 
9b22 77				ld (hl), a 
9b23 23				inc hl 
9b24			 
9b24				; get word off stack 
9b24 d1				pop de 
9b25 7b				ld a,e 
9b26 77				ld (hl), a 
9b27 23				inc hl 
9b28 7a				ld a,d 
9b29 77				ld (hl), a 
9b2a			 
9b2a			if DEBUG_FORTH_PUSH 
9b2a 2b				dec hl 
9b2b 2b				dec hl 
9b2c 2b				dec hl 
9b2d						DMARK "PH5" 
9b2d f5				push af  
9b2e 3a 42 9b			ld a, (.dmark)  
9b31 32 71 ee			ld (debug_mark),a  
9b34 3a 43 9b			ld a, (.dmark+1)  
9b37 32 72 ee			ld (debug_mark+1),a  
9b3a 3a 44 9b			ld a, (.dmark+2)  
9b3d 32 73 ee			ld (debug_mark+2),a  
9b40 18 03			jr .pastdmark  
9b42 ..			.dmark: db "PH5"  
9b45 f1			.pastdmark: pop af  
9b46			endm  
# End of macro DMARK
9b46				CALLMONITOR 
9b46 cd 6b 94			call break_point_state  
9b49				endm  
# End of macro CALLMONITOR
9b49			endif	 
9b49			 
9b49 c9				ret 
9b4a			 
9b4a			 
9b4a			; Push a string to stack pointed to by hl 
9b4a			 
9b4a			forth_push_str: 
9b4a			 
9b4a			if DEBUG_FORTH_PUSH 
9b4a						DMARK "PSQ" 
9b4a f5				push af  
9b4b 3a 5f 9b			ld a, (.dmark)  
9b4e 32 71 ee			ld (debug_mark),a  
9b51 3a 60 9b			ld a, (.dmark+1)  
9b54 32 72 ee			ld (debug_mark+1),a  
9b57 3a 61 9b			ld a, (.dmark+2)  
9b5a 32 73 ee			ld (debug_mark+2),a  
9b5d 18 03			jr .pastdmark  
9b5f ..			.dmark: db "PSQ"  
9b62 f1			.pastdmark: pop af  
9b63			endm  
# End of macro DMARK
9b63				CALLMONITOR 
9b63 cd 6b 94			call break_point_state  
9b66				endm  
# End of macro CALLMONITOR
9b66			endif	 
9b66			    
9b66 e5				push hl 
9b67 e5				push hl 
9b68			 
9b68			;	ld a, 0   ; find end of string 
9b68 cd c8 90			call strlenz 
9b6b			if DEBUG_FORTH_PUSH 
9b6b						DMARK "PQ2" 
9b6b f5				push af  
9b6c 3a 80 9b			ld a, (.dmark)  
9b6f 32 71 ee			ld (debug_mark),a  
9b72 3a 81 9b			ld a, (.dmark+1)  
9b75 32 72 ee			ld (debug_mark+1),a  
9b78 3a 82 9b			ld a, (.dmark+2)  
9b7b 32 73 ee			ld (debug_mark+2),a  
9b7e 18 03			jr .pastdmark  
9b80 ..			.dmark: db "PQ2"  
9b83 f1			.pastdmark: pop af  
9b84			endm  
# End of macro DMARK
9b84				CALLMONITOR 
9b84 cd 6b 94			call break_point_state  
9b87				endm  
# End of macro CALLMONITOR
9b87			endif	 
9b87 eb				ex de, hl 
9b88 e1				pop hl   ; get ptr to start of string 
9b89			if DEBUG_FORTH_PUSH 
9b89						DMARK "PQ3" 
9b89 f5				push af  
9b8a 3a 9e 9b			ld a, (.dmark)  
9b8d 32 71 ee			ld (debug_mark),a  
9b90 3a 9f 9b			ld a, (.dmark+1)  
9b93 32 72 ee			ld (debug_mark+1),a  
9b96 3a a0 9b			ld a, (.dmark+2)  
9b99 32 73 ee			ld (debug_mark+2),a  
9b9c 18 03			jr .pastdmark  
9b9e ..			.dmark: db "PQ3"  
9ba1 f1			.pastdmark: pop af  
9ba2			endm  
# End of macro DMARK
9ba2				CALLMONITOR 
9ba2 cd 6b 94			call break_point_state  
9ba5				endm  
# End of macro CALLMONITOR
9ba5			endif	 
9ba5 19				add hl,de 
9ba6			if DEBUG_FORTH_PUSH 
9ba6						DMARK "PQE" 
9ba6 f5				push af  
9ba7 3a bb 9b			ld a, (.dmark)  
9baa 32 71 ee			ld (debug_mark),a  
9bad 3a bc 9b			ld a, (.dmark+1)  
9bb0 32 72 ee			ld (debug_mark+1),a  
9bb3 3a bd 9b			ld a, (.dmark+2)  
9bb6 32 73 ee			ld (debug_mark+2),a  
9bb9 18 03			jr .pastdmark  
9bbb ..			.dmark: db "PQE"  
9bbe f1			.pastdmark: pop af  
9bbf			endm  
# End of macro DMARK
9bbf				CALLMONITOR 
9bbf cd 6b 94			call break_point_state  
9bc2				endm  
# End of macro CALLMONITOR
9bc2			endif	 
9bc2			 
9bc2 2b				dec hl    ; see if there is an optional trailing double quote 
9bc3 7e				ld a,(hl) 
9bc4 fe 22			cp '"' 
9bc6 20 03			jr nz, .strnoq 
9bc8 3e 00			ld a, 0      ; get rid of double quote 
9bca 77				ld (hl), a 
9bcb 23			.strnoq: inc hl 
9bcc			 
9bcc 3e 00			ld a, 0 
9bce 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9bcf			 
9bcf 13				inc de ; add one for the type string 
9bd0 13				inc de ; add one for null term??? 
9bd1			 
9bd1				; tos is get string pointer again 
9bd1				; de contains space to allocate 
9bd1				 
9bd1 d5				push de 
9bd2			 
9bd2 eb				ex de, hl 
9bd3			 
9bd3				;push af 
9bd3			 
9bd3			if DEBUG_FORTH_PUSH 
9bd3						DMARK "PHm" 
9bd3 f5				push af  
9bd4 3a e8 9b			ld a, (.dmark)  
9bd7 32 71 ee			ld (debug_mark),a  
9bda 3a e9 9b			ld a, (.dmark+1)  
9bdd 32 72 ee			ld (debug_mark+1),a  
9be0 3a ea 9b			ld a, (.dmark+2)  
9be3 32 73 ee			ld (debug_mark+2),a  
9be6 18 03			jr .pastdmark  
9be8 ..			.dmark: db "PHm"  
9beb f1			.pastdmark: pop af  
9bec			endm  
# End of macro DMARK
9bec				CALLMONITOR 
9bec cd 6b 94			call break_point_state  
9bef				endm  
# End of macro CALLMONITOR
9bef			endif	 
9bef cd 31 91			call malloc	; on ret hl now contains allocated memory 
9bf2				if DEBUG_FORTH_MALLOC_GUARD 
9bf2 cc b1 c6				call z,malloc_error 
9bf5				endif 
9bf5			 
9bf5				 
9bf5 c1				pop bc    ; get length 
9bf6 d1				pop de   ;  get string start    
9bf7			 
9bf7				; hl has destination from malloc 
9bf7			 
9bf7 eb				ex de, hl    ; prep for ldir 
9bf8			 
9bf8 d5				push de   ; save malloc area for DSP later 
9bf9				;push hl   ; save malloc area for DSP later 
9bf9			 
9bf9			if DEBUG_FORTH_PUSH 
9bf9						DMARK "PHc" 
9bf9 f5				push af  
9bfa 3a 0e 9c			ld a, (.dmark)  
9bfd 32 71 ee			ld (debug_mark),a  
9c00 3a 0f 9c			ld a, (.dmark+1)  
9c03 32 72 ee			ld (debug_mark+1),a  
9c06 3a 10 9c			ld a, (.dmark+2)  
9c09 32 73 ee			ld (debug_mark+2),a  
9c0c 18 03			jr .pastdmark  
9c0e ..			.dmark: db "PHc"  
9c11 f1			.pastdmark: pop af  
9c12			endm  
# End of macro DMARK
9c12				CALLMONITOR 
9c12 cd 6b 94			call break_point_state  
9c15				endm  
# End of macro CALLMONITOR
9c15			endif	 
9c15			 
9c15			 
9c15 ed b0			ldir 
9c17			 
9c17			 
9c17				; push malloc to data stack     macro?????  
9c17			 
9c17				FORTH_DSP_NEXT 
9c17 cd 6b 9a			call macro_forth_dsp_next 
9c1a				endm 
# End of macro FORTH_DSP_NEXT
9c1a			 
9c1a				; save value and type 
9c1a			 
9c1a 2a 2f ea			ld hl, (cli_data_sp) 
9c1d			 
9c1d				; save item type 
9c1d 3e 01			ld a,  DS_TYPE_STR 
9c1f 77				ld (hl), a 
9c20 23				inc hl 
9c21			 
9c21				; get malloc word off stack 
9c21 d1				pop de 
9c22 73				ld (hl), e 
9c23 23				inc hl 
9c24 72				ld (hl), d 
9c25			 
9c25			 
9c25			 
9c25			if DEBUG_FORTH_PUSH 
9c25 2a 2f ea			ld hl, (cli_data_sp) 
9c28						DMARK "PHS" 
9c28 f5				push af  
9c29 3a 3d 9c			ld a, (.dmark)  
9c2c 32 71 ee			ld (debug_mark),a  
9c2f 3a 3e 9c			ld a, (.dmark+1)  
9c32 32 72 ee			ld (debug_mark+1),a  
9c35 3a 3f 9c			ld a, (.dmark+2)  
9c38 32 73 ee			ld (debug_mark+2),a  
9c3b 18 03			jr .pastdmark  
9c3d ..			.dmark: db "PHS"  
9c40 f1			.pastdmark: pop af  
9c41			endm  
# End of macro DMARK
9c41				CALLMONITOR 
9c41 cd 6b 94			call break_point_state  
9c44				endm  
# End of macro CALLMONITOR
9c44			;	ex de,hl 
9c44			endif	 
9c44				; in case of spaces, skip the ptr past the copied string 
9c44				;pop af 
9c44				;ld (cli_origptr),hl 
9c44			 
9c44 c9				ret 
9c45			 
9c45			 
9c45			 
9c45			; TODO ascii push input onto stack given hl to start of input 
9c45			 
9c45			; identify type 
9c45			; if starts with a " then a string 
9c45			; otherwise it is a number 
9c45			;  
9c45			; if a string 
9c45			;     scan for ending " to get length of string to malloc for + 1 
9c45			;     malloc 
9c45			;     put pointer to string on stack first byte flags as string 
9c45			; 
9c45			; else a number 
9c45			;    look for number format identifier 
9c45			;    $xx hex 
9c45			;    %xxxxx bin 
9c45			;    xxxxx decimal 
9c45			;    convert number to 16bit word.  
9c45			;    malloc word + 1 with flag to identiy as num 
9c45			;    put pointer to number on stack 
9c45			;   
9c45			;  
9c45			  
9c45			forth_apush: 
9c45				; kernel push 
9c45			 
9c45			if DEBUG_FORTH_PUSH 
9c45						DMARK "PSH" 
9c45 f5				push af  
9c46 3a 5a 9c			ld a, (.dmark)  
9c49 32 71 ee			ld (debug_mark),a  
9c4c 3a 5b 9c			ld a, (.dmark+1)  
9c4f 32 72 ee			ld (debug_mark+1),a  
9c52 3a 5c 9c			ld a, (.dmark+2)  
9c55 32 73 ee			ld (debug_mark+2),a  
9c58 18 03			jr .pastdmark  
9c5a ..			.dmark: db "PSH"  
9c5d f1			.pastdmark: pop af  
9c5e			endm  
# End of macro DMARK
9c5e				CALLMONITOR 
9c5e cd 6b 94			call break_point_state  
9c61				endm  
# End of macro CALLMONITOR
9c61			endif	 
9c61				; identify input type 
9c61			 
9c61 7e				ld a,(hl) 
9c62 fe 22			cp '"' 
9c64 28 0a			jr z, .fapstr 
9c66 fe 24			cp '$' 
9c68 ca 90 9c			jp z, .faphex 
9c6b fe 25			cp '%' 
9c6d ca 78 9c			jp z, .fapbin 
9c70			;	cp 'b' 
9c70			;	jp z, .fabin 
9c70				; else decimal 
9c70			 
9c70				; TODO do decimal conversion 
9c70				; decimal is stored as a 16bit word 
9c70			 
9c70				; by default everything is a string if type is not detected 
9c70			.fapstr: ; 
9c70 fe 22			cp '"' 
9c72 20 01			jr nz, .strnoqu 
9c74 23				inc hl 
9c75			.strnoqu: 
9c75 c3 4a 9b			jp forth_push_str 
9c78			 
9c78			 
9c78			 
9c78			.fapbin:    ; push a binary string.  
9c78 11 00 00			ld de, 0   ; hold a 16bit value 
9c7b			 
9c7b 23			.fapbinshift:	inc hl  
9c7c 7e				ld a,(hl) 
9c7d fe 00			cp 0     ; done scanning  
9c7f 28 0b			jr z, .fapbdone  	; got it in HL so push  
9c81			 
9c81				; left shift de 
9c81 eb				ex de, hl	 
9c82 29				add hl, hl 
9c83			 
9c83				; is 1 
9c83 fe 31			cp '1' 
9c85 20 02			jr nz, .binzero 
9c87 cb 4d			bit 1, l 
9c89			.binzero: 
9c89 eb				ex de, hl	 ; save current de 
9c8a 18 ef			jr .fapbinshift 
9c8c			 
9c8c			.fapbdone: 
9c8c eb				ex de, hl 
9c8d c3 dc 9a			jp forth_push_numhl 
9c90			 
9c90			 
9c90			.faphex:   ; hex is always stored as a 16bit word 
9c90				; skip number prefix 
9c90 23				inc hl 
9c91				; turn ascii into number 
9c91 cd 21 90			call get_word_hl	; ret 16bit word in hl 
9c94			 
9c94 c3 dc 9a			jp forth_push_numhl 
9c97			 
9c97 00				 nop 
9c98			 
9c98			.fabin:   ; TODO bin conversion 
9c98			 
9c98			 
9c98 c9				ret 
9c99			 
9c99			 
9c99			; get either a string ptr or a 16bit word from the data stack 
9c99			 
9c99			FORTH_DSP: macro 
9c99				call macro_forth_dsp 
9c99				endm 
9c99			 
9c99			macro_forth_dsp: 
9c99				; data stack pointer points to current word on tos 
9c99			 
9c99 2a 2f ea			ld hl,(cli_data_sp) 
9c9c			 
9c9c				if DEBUG_FORTH_PUSH 
9c9c						DMARK "DSP" 
9c9c f5				push af  
9c9d 3a b1 9c			ld a, (.dmark)  
9ca0 32 71 ee			ld (debug_mark),a  
9ca3 3a b2 9c			ld a, (.dmark+1)  
9ca6 32 72 ee			ld (debug_mark+1),a  
9ca9 3a b3 9c			ld a, (.dmark+2)  
9cac 32 73 ee			ld (debug_mark+2),a  
9caf 18 03			jr .pastdmark  
9cb1 ..			.dmark: db "DSP"  
9cb4 f1			.pastdmark: pop af  
9cb5			endm  
# End of macro DMARK
9cb5			 
9cb5 cd e6 c6				call display_data_sp 
9cb8				;call break_point_state 
9cb8				;rst 030h 
9cb8				CALLMONITOR 
9cb8 cd 6b 94			call break_point_state  
9cbb				endm  
# End of macro CALLMONITOR
9cbb				endif 
9cbb			 
9cbb c9				ret 
9cbc			 
9cbc			; return hl to start of value on stack 
9cbc			 
9cbc			FORTH_DSP_VALUE: macro 
9cbc				call macro_forth_dsp_value 
9cbc				endm 
9cbc			 
9cbc			macro_forth_dsp_value: 
9cbc			 
9cbc				FORTH_DSP 
9cbc cd 99 9c			call macro_forth_dsp 
9cbf				endm 
# End of macro FORTH_DSP
9cbf			 
9cbf d5				push de 
9cc0			 
9cc0 23				inc hl ; skip type 
9cc1			 
9cc1 5e				ld e, (hl) 
9cc2 23				inc hl 
9cc3 56				ld d, (hl) 
9cc4 eb				ex de,hl  
9cc5			 
9cc5 d1				pop de 
9cc6			 
9cc6 c9				ret 
9cc7			 
9cc7			; return hl to start of value to second item on stack 
9cc7			 
9cc7			FORTH_DSP_VALUEM1: macro 
9cc7				call macro_forth_dsp_value_m1 
9cc7				endm 
9cc7			 
9cc7			macro_forth_dsp_value_m1: 
9cc7			 
9cc7				FORTH_DSP 
9cc7 cd 99 9c			call macro_forth_dsp 
9cca				endm 
# End of macro FORTH_DSP
9cca			 
9cca 2b				dec hl 
9ccb 2b				dec hl 
9ccc			;	dec hl 
9ccc			 
9ccc d5				push de 
9ccd			 
9ccd 5e				ld e, (hl) 
9cce 23				inc hl 
9ccf 56				ld d, (hl) 
9cd0 eb				ex de,hl  
9cd1			 
9cd1 d1				pop de 
9cd2			 
9cd2 c9				ret 
9cd3			 
9cd3				 
9cd3			 
9cd3			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9cd3			 
9cd3			FORTH_DSP_POP: macro 
9cd3				call macro_forth_dsp_pop 
9cd3				endm 
9cd3			 
9cd3			 
9cd3			; get the tos data type 
9cd3			 
9cd3			FORTH_DSP_TYPE:   macro 
9cd3			 
9cd3				;FORTH_DSP_VALUE 
9cd3				FORTH_DSP 
9cd3				 
9cd3				; hl points to value 
9cd3				; check type 
9cd3			 
9cd3				ld a,(hl) 
9cd3			 
9cd3				endm 
9cd3			 
9cd3			; load the tos value into hl 
9cd3			 
9cd3			 
9cd3			FORTH_DSP_VALUEHL:  macro 
9cd3				call macro_dsp_valuehl 
9cd3				endm 
9cd3			 
9cd3			 
9cd3			 
9cd3			macro_dsp_valuehl: 
9cd3				FORTH_DSP_VALUE 
9cd3 cd bc 9c			call macro_forth_dsp_value 
9cd6				endm 
# End of macro FORTH_DSP_VALUE
9cd6			 
9cd6				;FORTH_ERR_TOS_NOTNUM 
9cd6			 
9cd6				;inc hl   ; skip type id 
9cd6			 
9cd6			;	push de 
9cd6			; 
9cd6			;	ld e, (hl) 
9cd6			;	inc hl 
9cd6			;	ld d, (hl) 
9cd6			;	ex de,hl  
9cd6			 
9cd6			;	pop de 
9cd6			 
9cd6				if DEBUG_FORTH_PUSH 
9cd6						DMARK "DVL" 
9cd6 f5				push af  
9cd7 3a eb 9c			ld a, (.dmark)  
9cda 32 71 ee			ld (debug_mark),a  
9cdd 3a ec 9c			ld a, (.dmark+1)  
9ce0 32 72 ee			ld (debug_mark+1),a  
9ce3 3a ed 9c			ld a, (.dmark+2)  
9ce6 32 73 ee			ld (debug_mark+2),a  
9ce9 18 03			jr .pastdmark  
9ceb ..			.dmark: db "DVL"  
9cee f1			.pastdmark: pop af  
9cef			endm  
# End of macro DMARK
9cef				CALLMONITOR 
9cef cd 6b 94			call break_point_state  
9cf2				endm  
# End of macro CALLMONITOR
9cf2				endif 
9cf2 c9				ret 
9cf3			 
9cf3			forth_apushstrhl:      
9cf3				; push of string requires use of cli_origptr 
9cf3				; bodge use 
9cf3			 
9cf3				; get current cli_origptr, save, update with temp pointer  
9cf3 ed 5b 4b ea		ld de, (cli_origptr) 
9cf7 22 4b ea			ld (cli_origptr), hl 
9cfa d5				push de 
9cfb cd 45 9c			call forth_apush 
9cfe d1				pop de 
9cff ed 53 4b ea		ld (cli_origptr), de 
9d03 c9			        ret	 
9d04			 
9d04			 
9d04			; increase loop stack pointer and save hl to it 
9d04				 
9d04			FORTH_LOOP_NEXT: macro 
9d04				call macro_forth_loop_next 
9d04				;nop 
9d04				endm 
9d04			 
9d04			macro_forth_loop_next: 
9d04				if DEBUG_FORTH_STACK_GUARD 
9d04 cd a2 d7				call check_stacks 
9d07				endif 
9d07 e5				push hl 
9d08 d5				push de 
9d09 eb				ex de,hl 
9d0a 2a 31 ea			ld hl,(cli_loop_sp) 
9d0d 23				inc hl 
9d0e 23				inc hl 
9d0f					if DEBUG_FORTH_WORDS 
9d0f						DMARK "LNX" 
9d0f f5				push af  
9d10 3a 24 9d			ld a, (.dmark)  
9d13 32 71 ee			ld (debug_mark),a  
9d16 3a 25 9d			ld a, (.dmark+1)  
9d19 32 72 ee			ld (debug_mark+1),a  
9d1c 3a 26 9d			ld a, (.dmark+2)  
9d1f 32 73 ee			ld (debug_mark+2),a  
9d22 18 03			jr .pastdmark  
9d24 ..			.dmark: db "LNX"  
9d27 f1			.pastdmark: pop af  
9d28			endm  
# End of macro DMARK
9d28						CALLMONITOR 
9d28 cd 6b 94			call break_point_state  
9d2b				endm  
# End of macro CALLMONITOR
9d2b					endif 
9d2b 22 31 ea			ld (cli_loop_sp),hl 
9d2e 73				ld (hl), e 
9d2f 23				inc hl 
9d30 72				ld (hl), d 
9d31 d1				pop de    ; been reversed so save a swap on restore 
9d32 e1				pop hl 
9d33				if DEBUG_FORTH_STACK_GUARD 
9d33 cd a2 d7				call check_stacks 
9d36				endif 
9d36 c9				ret 
9d37			 
9d37			; get current ret stack pointer and save to hl  
9d37				 
9d37			FORTH_LOOP_TOS: macro 
9d37				call macro_forth_loop_tos 
9d37				endm 
9d37			 
9d37			macro_forth_loop_tos: 
9d37 d5				push de 
9d38 2a 31 ea			ld hl,(cli_loop_sp) 
9d3b 5e				ld e, (hl) 
9d3c 23				inc hl 
9d3d 56				ld d, (hl) 
9d3e eb				ex de, hl 
9d3f d1				pop de 
9d40 c9				ret 
9d41			 
9d41			; pop loop stack pointer 
9d41				 
9d41			FORTH_LOOP_POP: macro 
9d41				call macro_forth_loop_pop 
9d41				endm 
9d41			 
9d41			 
9d41			macro_forth_loop_pop: 
9d41				if DEBUG_FORTH_STACK_GUARD 
9d41					DMARK "LPP" 
9d41 f5				push af  
9d42 3a 56 9d			ld a, (.dmark)  
9d45 32 71 ee			ld (debug_mark),a  
9d48 3a 57 9d			ld a, (.dmark+1)  
9d4b 32 72 ee			ld (debug_mark+1),a  
9d4e 3a 58 9d			ld a, (.dmark+2)  
9d51 32 73 ee			ld (debug_mark+2),a  
9d54 18 03			jr .pastdmark  
9d56 ..			.dmark: db "LPP"  
9d59 f1			.pastdmark: pop af  
9d5a			endm  
# End of macro DMARK
9d5a cd a2 d7				call check_stacks 
9d5d					FORTH_CHK_LOOP_UNDER 
9d5d e5				push hl 
9d5e d5				push de 
9d5f 2a 31 ea			ld hl,(cli_loop_sp) 
9d62 11 6b e9			ld de, cli_loop_stack 
9d65 cd 88 8c			call cmp16 
9d68 da bc d8			jp c, fault_loop_under 
9d6b d1				pop de 
9d6c e1				pop hl 
9d6d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d6d				endif 
9d6d e5				push hl 
9d6e 2a 31 ea			ld hl,(cli_loop_sp) 
9d71 2b				dec hl 
9d72 2b				dec hl 
9d73 22 31 ea			ld (cli_loop_sp), hl 
9d76				; TODO do stack underflow checks 
9d76 e1				pop hl 
9d77				if DEBUG_FORTH_STACK_GUARD 
9d77 cd a2 d7				call check_stacks 
9d7a					FORTH_CHK_LOOP_UNDER 
9d7a e5				push hl 
9d7b d5				push de 
9d7c 2a 31 ea			ld hl,(cli_loop_sp) 
9d7f 11 6b e9			ld de, cli_loop_stack 
9d82 cd 88 8c			call cmp16 
9d85 da bc d8			jp c, fault_loop_under 
9d88 d1				pop de 
9d89 e1				pop hl 
9d8a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d8a				endif 
9d8a c9				ret 
9d8b			 
9d8b			macro_forth_dsp_pop: 
9d8b			 
9d8b e5				push hl 
9d8c			 
9d8c				; release malloc data 
9d8c			 
9d8c				if DEBUG_FORTH_STACK_GUARD 
9d8c cd a2 d7				call check_stacks 
9d8f					FORTH_CHK_DSP_UNDER 
9d8f e5				push hl 
9d90 d5				push de 
9d91 2a 2f ea			ld hl,(cli_data_sp) 
9d94 11 69 e8			ld de, cli_data_stack 
9d97 cd 88 8c			call cmp16 
9d9a da b0 d8			jp c, fault_dsp_under 
9d9d d1				pop de 
9d9e e1				pop hl 
9d9f				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d9f				endif 
9d9f				;ld hl,(cli_data_sp) 
9d9f			if DEBUG_FORTH_DOT 
9d9f				DMARK "DPP" 
9d9f				CALLMONITOR 
9d9f			endif	 
9d9f			 
9d9f			 
9d9f			if FORTH_ENABLE_DSPPOPFREE 
9d9f			 
9d9f				FORTH_DSP 
9d9f cd 99 9c			call macro_forth_dsp 
9da2				endm 
# End of macro FORTH_DSP
9da2			 
9da2 7e				ld a, (hl) 
9da3 fe 01			cp DS_TYPE_STR 
9da5 20 07			jr nz, .skippopfree 
9da7			 
9da7				FORTH_DSP_VALUEHL 
9da7 cd d3 9c			call macro_dsp_valuehl 
9daa				endm 
# End of macro FORTH_DSP_VALUEHL
9daa 00				nop 
9dab			if DEBUG_FORTH_DOT 
9dab				DMARK "DPf" 
9dab				CALLMONITOR 
9dab			endif	 
9dab cd fb 91			call free 
9dae			.skippopfree: 
9dae				 
9dae			 
9dae			endif 
9dae			 
9dae			if DEBUG_FORTH_DOT_KEY 
9dae				DMARK "DP2" 
9dae				CALLMONITOR 
9dae			endif	 
9dae			 
9dae				; move pointer down 
9dae			 
9dae 2a 2f ea			ld hl,(cli_data_sp) 
9db1 2b				dec hl 
9db2 2b				dec hl 
9db3			; PARSEV5 
9db3 2b				dec hl 
9db4 22 2f ea			ld (cli_data_sp), hl 
9db7			 
9db7				if DEBUG_FORTH_STACK_GUARD 
9db7 cd a2 d7				call check_stacks 
9dba					FORTH_CHK_DSP_UNDER 
9dba e5				push hl 
9dbb d5				push de 
9dbc 2a 2f ea			ld hl,(cli_data_sp) 
9dbf 11 69 e8			ld de, cli_data_stack 
9dc2 cd 88 8c			call cmp16 
9dc5 da b0 d8			jp c, fault_dsp_under 
9dc8 d1				pop de 
9dc9 e1				pop hl 
9dca				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dca				endif 
9dca			 
9dca e1				pop hl 
9dcb			 
9dcb c9				ret 
9dcc			 
9dcc			getwordathl: 
9dcc				; hl points to an address 
9dcc				; load hl with the word at that address 
9dcc			 
9dcc d5				push de 
9dcd			 
9dcd 5e				ld e, (hl) 
9dce 23				inc hl 
9dcf 56				ld d, (hl) 
9dd0 eb				ex de, hl 
9dd1			 
9dd1 d1				pop de 
9dd2 c9				ret 
9dd3			 
9dd3			 
9dd3			 
9dd3			 
9dd3			 
9dd3			; eof 
9dd3			 
# End of file forth_stackopsv5.asm
9dd3			endif 
9dd3			 
9dd3			user_word_eol:  
9dd3				; hl contains the pointer to where to create a linked list item from the end 
9dd3				; of the user dict to continue on at the system word dict 
9dd3				 
9dd3				; poke the stub of the word list linked list to repoint to rom words 
9dd3			 
9dd3				; stub format 
9dd3				; db   word id 
9dd3				; dw    link to next word 
9dd3			        ; db char length of token 
9dd3				; db string + 0 term 
9dd3				; db exec code....  
9dd3			 
9dd3 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9dd5 77				ld (hl), a		; word id 
9dd6 23				inc hl 
9dd7			 
9dd7 11 a2 9f			ld de, sysdict 
9dda 73				ld (hl), e		; next word link ie system dict 
9ddb 23				inc hl 
9ddc 72				ld (hl), d		; next word link ie system dict 
9ddd 23				inc hl	 
9dde			 
9dde			;	ld (hl), sysdict		; next word link ie system dict 
9dde			;	inc hl 
9dde			;	inc hl 
9dde			 
9dde			;	inc hl 
9dde			;	inc hl 
9dde			 
9dde 3e 02			ld a, 2			; word length is 0 
9de0 77				ld (hl), a	 
9de1 23				inc hl 
9de2			 
9de2 3e 7e			ld a, '~'			; word length is 0 
9de4 77				ld (hl), a	 
9de5 23				inc hl 
9de6 3e 00			ld a, 0			; save empty word 
9de8 77				ld (hl), a 
9de9			 
9de9 c9				ret 
9dea			 
9dea				 
9dea			 
9dea			forthexec_cleanup: 
9dea				FORTH_RSP_POP 
9dea cd a4 9a			call macro_forth_rsp_pop 
9ded				endm 
# End of macro FORTH_RSP_POP
9ded c9				ret 
9dee			 
9dee			forth_call_hl: 
9dee				; taking hl 
9dee e5				push hl 
9def c9				ret 
9df0			 
9df0			; this is called to reset Forth system but keep existing uwords etc 
9df0			 
9df0			forth_warmstart: 
9df0				; setup stack over/under flow checks 
9df0				if DEBUG_FORTH_STACK_GUARD 
9df0 cd 88 d7				call chk_stk_init 
9df3				endif 
9df3			 
9df3				; init stack pointers  - * these stacks go upwards *  
9df3 21 ed e9			ld hl, cli_ret_stack 
9df6 22 33 ea			ld (cli_ret_sp), hl	 
9df9				; set bottom of stack 
9df9 3e 00			ld a,0 
9dfb 77				ld (hl),a 
9dfc 23				inc hl 
9dfd 77				ld (hl),a 
9dfe			 
9dfe 21 69 e8			ld hl, cli_data_stack 
9e01 22 2f ea			ld (cli_data_sp), hl	 
9e04				; set bottom of stack 
9e04 3e 00			ld a,0 
9e06 77				ld (hl),a 
9e07 23				inc hl 
9e08 77				ld (hl),a 
9e09			 
9e09 21 6b e9			ld hl, cli_loop_stack 
9e0c 22 31 ea			ld (cli_loop_sp), hl	 
9e0f				; set bottom of stack 
9e0f 3e 00			ld a,0 
9e11 77				ld (hl),a 
9e12 23				inc hl 
9e13 77				ld (hl),a 
9e14			 
9e14				; init extent of current open file 
9e14			 
9e14 3e 00			ld a, 0 
9e16 32 76 ea			ld (store_openext), a 
9e19			 
9e19 c9				ret 
9e1a			 
9e1a			 
9e1a			; Cold Start - this is called to setup the whole Forth system 
9e1a			 
9e1a			forth_init: 
9e1a			 
9e1a				; setup stack over/under flow checks 
9e1a			 
9e1a			;	if DEBUG_FORTH_STACK_GUARD 
9e1a			;		call chk_stk_init 
9e1a			;	endif 
9e1a			 
9e1a				; enable auto display updates (slow.....) 
9e1a			 
9e1a 3e 01			ld a, 1 
9e1c 32 49 ea			ld (cli_autodisplay), a 
9e1f			 
9e1f				; if storage is in use disable long reads for now 
9e1f 3e 00			ld a, 0 
9e21 32 7f ea			ld (store_longread), a 
9e24			 
9e24			 
9e24				; show start up screen 
9e24			 
9e24 cd 3d 8a			call clear_display 
9e27			 
9e27 3e 00			ld a,0 
9e29 32 6b ea			ld (f_cursor_ptr), a 
9e2c			 
9e2c				; set start of word list in start of ram - for use when creating user words 
9e2c			 
9e2c 21 53 da			ld hl, baseram 
9e2f 22 ff e5			ld (os_last_new_uword), hl 
9e32 cd d3 9d			call user_word_eol 
9e35				 
9e35			;		call display_data_sp 
9e35			;		call next_page_prompt 
9e35			 
9e35			 
9e35			 
9e35			 
9e35 c9				ret 
9e36			 
9e36 .. 00		.bootforth: db " Forth Kernel Init ",0 
9e4a			 
9e4a			; TODO push to stack 
9e4a			 
9e4a			;  
9e4a			 
9e4a			if FORTH_PARSEV2 
9e4a			 
9e4a			 
9e4a				include "forth_parserv2.asm" 
9e4a			 
9e4a			endif 
9e4a			 
9e4a			 
9e4a			; parse cli version 1 
9e4a			 
9e4a			if FORTH_PARSEV1 
9e4a			 
9e4a			 
9e4a			 
9e4a			      include "forth_parserv1.asm" 
9e4a			endif 
9e4a				 
9e4a			if FORTH_PARSEV3 
9e4a			 
9e4a			 
9e4a			 
9e4a			      include "forth_parserv3.asm" 
9e4a				include "forth_wordsv3.asm" 
9e4a			endif 
9e4a			 
9e4a			if FORTH_PARSEV4 
9e4a			 
9e4a			 
9e4a			 
9e4a			      include "forth_parserv4.asm" 
9e4a				include "forth_wordsv4.asm" 
9e4a			endif 
9e4a			 
9e4a			if FORTH_PARSEV5 
9e4a			 
9e4a			 
9e4a			 
9e4a			      include "forth_parserv5.asm" 
9e4a			 
9e4a			 
9e4a			; A better parser without using malloc and string copies all over the place.  
9e4a			; Exec in situ should be faster 
9e4a			 
9e4a			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e4a			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e4a			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e4a			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e4a			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e4a			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e4a			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e4a			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e4a			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e4a			 
9e4a			; Core word preamble macro 
9e4a			 
9e4a			CWHEAD:   macro nxtword opcode lit len opflags 
9e4a				db WORD_SYS_CORE+opcode             
9e4a				; internal op code number 
9e4a				dw nxtword            
9e4a				; link to next dict word block 
9e4a				db len + 1 
9e4a				; literal length of dict word inc zero term 
9e4a				db lit,0              
9e4a				; literal dict word 
9e4a			        ; TODO db opflags        
9e4a				endm 
9e4a			 
9e4a			 
9e4a			NEXTW: macro  
9e4a				jp macro_next 
9e4a				endm 
9e4a			 
9e4a			macro_next: 
9e4a			if DEBUG_FORTH_PARSE_KEY 
9e4a				DMARK "NXT" 
9e4a				CALLMONITOR 
9e4a			endif	 
9e4a			;	inc hl  ; skip token null term  
9e4a ed 4b 4d ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e4e ed 5b 4b ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e52 2a 03 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e55			if DEBUG_FORTH_PARSE_KEY 
9e55				DMARK "}AA" 
9e55				CALLMONITOR 
9e55			endif	 
9e55 c3 58 9f			jp execnext 
9e58				;jp exec1 
9e58			       
9e58			 
9e58			 
9e58			; Another go at the parser to compile  
9e58			 
9e58			 
9e58			; TODO rework parser to change all of the string words to byte tokens 
9e58			; TODO do a search for  
9e58			 
9e58			; TODO first run normal parser to zero term sections 
9e58			; TODO for each word do a token look up to get the op code 
9e58			; TODO need some means to flag to the exec that this is a byte code form    
9e58			 
9e58			 
9e58			forthcompile: 
9e58			 
9e58			; 
9e58			; line parse: 
9e58			;       parse raw input buffer 
9e58			;       tokenise the words 
9e58			;       malloc new copy (for looping etc) 
9e58			;       copy to malloc + current pc in line to start of string and add line term 
9e58			;       save on new rsp 
9e58			; 
9e58			 
9e58			; hl to point to the line to tokenise 
9e58			 
9e58			;	push hl 
9e58 22 03 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9e5b			 
9e5b			;	ld a,0		; string term on input 
9e5b			;	call strlent 
9e5b			 
9e5b			;	ld (os_tok_len), hl	 ; save string length 
9e5b			 
9e5b			;if DEBUG_FORTH_TOK 
9e5b			;	ex de,hl		 
9e5b			;endif 
9e5b			 
9e5b			;	pop hl 		; get back string pointer 
9e5b			 
9e5b			if DEBUG_FORTH_TOK 
9e5b						DMARK "TOc" 
9e5b				CALLMONITOR 
9e5b			endif 
9e5b 7e			.cptoken2:    ld a,(hl) 
9e5c 23				inc hl 
9e5d fe 7f			cp FORTH_END_BUFFER 
9e5f 28 29			jr z, .cptokendone2 
9e61 fe 00			cp 0 
9e63 28 25			jr z, .cptokendone2 
9e65 fe 22			cp '"' 
9e67 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e69 fe 20			cp ' ' 
9e6b 20 ee			jr nz,  .cptoken2 
9e6d			 
9e6d			; TODO consume comments held between ( and ) 
9e6d			 
9e6d				; we have a space so change to zero term for dict match later 
9e6d 2b				dec hl 
9e6e 3e 00			ld a,0 
9e70 77				ld (hl), a 
9e71 23				inc hl 
9e72 18 e7			jr .cptoken2 
9e74				 
9e74			 
9e74			.cptokenstr2: 
9e74				; skip all white space until either eol (because forgot to term) or end double quote 
9e74			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e74				;inc hl ; skip current double quote 
9e74 7e				ld a,(hl) 
9e75 23				inc hl 
9e76 fe 22			cp '"' 
9e78 28 e1			jr z, .cptoken2 
9e7a fe 7f			cp FORTH_END_BUFFER 
9e7c 28 0c			jr z, .cptokendone2 
9e7e fe 00			cp 0 
9e80 28 08			jr z, .cptokendone2 
9e82 fe 20			cp ' ' 
9e84 28 02			jr z, .cptmp2 
9e86 18 ec			jr .cptokenstr2 
9e88			 
9e88			.cptmp2:	; we have a space so change to zero term for dict match later 
9e88				;dec hl 
9e88				;ld a,"-"	; TODO remove this when working 
9e88				;ld (hl), a 
9e88				;inc hl 
9e88 18 ea			jr .cptokenstr2 
9e8a			 
9e8a			.cptokendone2: 
9e8a				;inc hl 
9e8a 3e 7f			ld a, FORTH_END_BUFFER 
9e8c 77				ld (hl),a 
9e8d 23				inc hl 
9e8e 3e 21			ld a, '!' 
9e90 77				ld (hl),a 
9e91			 
9e91 2a 03 e6			ld hl,(os_tok_ptr) 
9e94			         
9e94			if DEBUG_FORTH_TOK 
9e94						DMARK "Tc1" 
9e94				CALLMONITOR 
9e94			endif 
9e94			 
9e94				; push exec string to top of return stack 
9e94				FORTH_RSP_NEXT 
9e94 cd 83 9a			call macro_forth_rsp_next 
9e97				endm 
# End of macro FORTH_RSP_NEXT
9e97 c9				ret 
9e98			 
9e98			; Another go at the parser need to simplify the process 
9e98			 
9e98			forthparse: 
9e98			 
9e98			; 
9e98			; line parse: 
9e98			;       parse raw input buffer 
9e98			;       tokenise the words 
9e98			;       malloc new copy (for looping etc) 
9e98			;       copy to malloc + current pc in line to start of string and add line term 
9e98			;       save on new rsp 
9e98			; 
9e98			 
9e98			; hl to point to the line to tokenise 
9e98			 
9e98			;	push hl 
9e98 22 03 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9e9b			 
9e9b			;	ld a,0		; string term on input 
9e9b			;	call strlent 
9e9b			 
9e9b			;	ld (os_tok_len), hl	 ; save string length 
9e9b			 
9e9b			;if DEBUG_FORTH_TOK 
9e9b			;	ex de,hl		 
9e9b			;endif 
9e9b			 
9e9b			;	pop hl 		; get back string pointer 
9e9b			 
9e9b			if DEBUG_FORTH_TOK 
9e9b						DMARK "TOK" 
9e9b				CALLMONITOR 
9e9b			endif 
9e9b 7e			.ptoken2:    ld a,(hl) 
9e9c 23				inc hl 
9e9d fe 7f			cp FORTH_END_BUFFER 
9e9f 28 29			jr z, .ptokendone2 
9ea1 fe 00			cp 0 
9ea3 28 25			jr z, .ptokendone2 
9ea5 fe 22			cp '"' 
9ea7 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9ea9 fe 20			cp ' ' 
9eab 20 ee			jr nz,  .ptoken2 
9ead			 
9ead			; TODO consume comments held between ( and ) 
9ead			 
9ead				; we have a space so change to zero term for dict match later 
9ead 2b				dec hl 
9eae 3e 00			ld a,0 
9eb0 77				ld (hl), a 
9eb1 23				inc hl 
9eb2 18 e7			jr .ptoken2 
9eb4				 
9eb4			 
9eb4			.ptokenstr2: 
9eb4				; skip all white space until either eol (because forgot to term) or end double quote 
9eb4			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9eb4				;inc hl ; skip current double quote 
9eb4 7e				ld a,(hl) 
9eb5 23				inc hl 
9eb6 fe 22			cp '"' 
9eb8 28 e1			jr z, .ptoken2 
9eba fe 7f			cp FORTH_END_BUFFER 
9ebc 28 0c			jr z, .ptokendone2 
9ebe fe 00			cp 0 
9ec0 28 08			jr z, .ptokendone2 
9ec2 fe 20			cp ' ' 
9ec4 28 02			jr z, .ptmp2 
9ec6 18 ec			jr .ptokenstr2 
9ec8			 
9ec8			.ptmp2:	; we have a space so change to zero term for dict match later 
9ec8				;dec hl 
9ec8				;ld a,"-"	; TODO remove this when working 
9ec8				;ld (hl), a 
9ec8				;inc hl 
9ec8 18 ea			jr .ptokenstr2 
9eca			 
9eca			.ptokendone2: 
9eca				;inc hl 
9eca 3e 7f			ld a, FORTH_END_BUFFER 
9ecc 77				ld (hl),a 
9ecd 23				inc hl 
9ece 3e 21			ld a, '!' 
9ed0 77				ld (hl),a 
9ed1			 
9ed1 2a 03 e6			ld hl,(os_tok_ptr) 
9ed4			         
9ed4			if DEBUG_FORTH_TOK 
9ed4						DMARK "TK1" 
9ed4				CALLMONITOR 
9ed4			endif 
9ed4			 
9ed4				; push exec string to top of return stack 
9ed4				FORTH_RSP_NEXT 
9ed4 cd 83 9a			call macro_forth_rsp_next 
9ed7				endm 
# End of macro FORTH_RSP_NEXT
9ed7 c9				ret 
9ed8			 
9ed8			; 
9ed8			;	; malloc size + buffer pointer + if is loop flag 
9ed8			;	ld hl,(os_tok_len) 		 ; get string length 
9ed8			; 
9ed8			;	ld a,l 
9ed8			; 
9ed8			;	cp 0			; we dont want to use a null string 
9ed8			;	ret z 
9ed8			; 
9ed8			;;	add 3    ; prefix malloc with buffer for current word ptr 
9ed8			; 
9ed8			;	add 5     ; TODO when certain not over writing memory remove 
9ed8			; 
9ed8			;		 
9ed8			; 
9ed8			;if DEBUG_FORTH_TOK 
9ed8			;			DMARK "TKE" 
9ed8			;	CALLMONITOR 
9ed8			;endif 
9ed8			; 
9ed8			;	ld l,a 
9ed8			;	ld h,0 
9ed8			;;	push hl   ; save required space for the copy later 
9ed8			;	call malloc 
9ed8			;if DEBUG_FORTH_TOK 
9ed8			;			DMARK "TKM" 
9ed8			;	CALLMONITOR 
9ed8			;endif 
9ed8			;	if DEBUG_FORTH_MALLOC_GUARD 
9ed8			;		push af 
9ed8			;		call ishlzero 
9ed8			;;		ld a, l 
9ed8			;;		add h 
9ed8			;;		cp 0 
9ed8			;		pop af 
9ed8			;		 
9ed8			;		call z,malloc_error 
9ed8			;	endif 
9ed8			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9ed8			; 
9ed8			; 
9ed8			;if DEBUG_FORTH_TOK 
9ed8			;			DMARK "TKR" 
9ed8			;	CALLMONITOR 
9ed8			;endif 
9ed8			; 
9ed8			;	FORTH_RSP_NEXT 
9ed8			; 
9ed8			;	;inc hl	 ; go past current buffer pointer 
9ed8			;	;inc hl 
9ed8			;	;inc hl   ; and past if loop flag 
9ed8			;		; TODO Need to set flag  
9ed8			; 
9ed8			;	 
9ed8			;	 
9ed8			;	ex de,hl	; malloc is dest 
9ed8			;	ld hl, (os_tok_len) 
9ed8			;;	pop bc 
9ed8			;	ld c, l                
9ed8			;	ld b,0 
9ed8			;	ld hl, (os_tok_ptr) 
9ed8			; 
9ed8			;if DEBUG_FORTH_TOK 
9ed8			;			DMARK "TKT" 
9ed8			;	CALLMONITOR 
9ed8			;endif 
9ed8			; 
9ed8			;	; do str cpy 
9ed8			; 
9ed8			;	ldir      ; copy byte in hl to de 
9ed8			; 
9ed8			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9ed8			; 
9ed8			;if DEBUG_FORTH_TOK 
9ed8			; 
9ed8			;			DMARK "TKY" 
9ed8			;	CALLMONITOR 
9ed8			;endif 
9ed8			;	;ld a,0 
9ed8			;	;ld a,FORTH_END_BUFFER 
9ed8			;	ex de, hl 
9ed8			;	;dec hl			 ; go back over the space delim at the end of word 
9ed8			;	;ld (hl),a 
9ed8			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9ed8			;	ld a,FORTH_END_BUFFER 
9ed8			;	ld (hl),a 
9ed8			;	inc hl 
9ed8			;	ld a,FORTH_END_BUFFER 
9ed8			;	ld (hl),a 
9ed8			; 
9ed8			;	; init the malloc area data 
9ed8			;	; set pc for in current area 
9ed8			;	;ld hl, (os_tok_malloc) 
9ed8			;	;inc hl 
9ed8			;	;inc hl 
9ed8			;	;inc hl 
9ed8			;	;ex de,hl 
9ed8			;	;ld hl, (os_tok_malloc) 
9ed8			;	;ld (hl),e 
9ed8			;	;inc hl 
9ed8			;	;ld (hl),d 
9ed8			; 
9ed8			; 
9ed8			;	ld hl,(os_tok_malloc) 
9ed8			;if DEBUG_FORTH_PARSE_KEY 
9ed8			;			DMARK "TKU" 
9ed8			;	CALLMONITOR 
9ed8			;endif 
9ed8			; 
9ed8			;	ret 
9ed8			 
9ed8			forthexec: 
9ed8			 
9ed8			; line exec: 
9ed8			; forth parser 
9ed8			 
9ed8			; 
9ed8			;       get current exec line on rsp 
9ed8			 
9ed8				FORTH_RSP_TOS 
9ed8 cd 9a 9a			call macro_forth_rsp_tos 
9edb				endm 
# End of macro FORTH_RSP_TOS
9edb			 
9edb			;       restore current pc - hl points to malloc of data 
9edb			 
9edb				;ld e, (hl) 
9edb				;inc hl 
9edb				;ld d, (hl) 
9edb				;ex de,hl 
9edb			 
9edb			 
9edb			exec1: 
9edb 22 03 e6			ld (os_tok_ptr), hl 
9ede			 
9ede				; copy our PC to working vars  
9ede 22 4d ea			ld (cli_ptr), hl 
9ee1 22 4b ea			ld (cli_origptr), hl 
9ee4			 
9ee4 7e				ld a,(hl) 
9ee5 fe 7f			cp FORTH_END_BUFFER 
9ee7 c8				ret z 
9ee8			 
9ee8				; skip any nulls 
9ee8			 
9ee8 fe 00			cp 0 
9eea 20 03			jr nz, .execword 
9eec 23				inc hl 
9eed 18 ec			jr exec1 
9eef			 
9eef			 
9eef			.execword: 
9eef			 
9eef			 
9eef			 
9eef			if DEBUG_FORTH_PARSE_KEY 
9eef						DMARK "KYQ" 
9eef				CALLMONITOR 
9eef			endif 
9eef			;       while at start of word: 
9eef			; get start of dict (in user area first) 
9eef			 
9eef 21 53 da		ld hl, baseram 
9ef2			;ld hl, sysdict 
9ef2 22 4f ea		ld (cli_nextword),hl 
9ef5			;           match word at pc 
9ef5			;           exec word 
9ef5			;           or push to dsp 
9ef5			;           forward to next token 
9ef5			;           if line term pop rsp and exit 
9ef5			;        
9ef5			 
9ef5			if DEBUG_FORTH_PARSE_KEY 
9ef5						DMARK "KYq" 
9ef5				CALLMONITOR 
9ef5			endif 
9ef5			 
9ef5			; 
9ef5			; word comp 
9ef5			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9ef5			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9ef5			;    move to start of word  
9ef5			;    compare word to cli_token 
9ef5			 
9ef5			.execpnword:	; HL at start of a word in the dictionary to check 
9ef5			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9ef5			;	ld (cli_ptr), hl 
9ef5			 
9ef5 2a 4f ea			ld hl,(cli_nextword) 
9ef8			 
9ef8 cd 9b 9f			call forth_tok_next 
9efb			; tok next start here 
9efb			;	; TODO skip compiled symbol for now 
9efb			;	inc hl 
9efb			; 
9efb			;	; save pointer to next word 
9efb			; 
9efb			;	; hl now points to the address of the next word pointer  
9efb			;	ld e, (hl) 
9efb			;	inc hl 
9efb			;	ld d, (hl) 
9efb			;	inc l 
9efb			; 
9efb			;	ex de,hl 
9efb			;if DEBUG_FORTH_PARSE_NEXTWORD 
9efb			;	push bc 
9efb			;	ld bc, (cli_nextword) 
9efb			;			DMARK "NXW" 
9efb			;	CALLMONITOR 
9efb			;	pop bc 
9efb			;endif 
9efb			; tok next end here 
9efb 22 4f ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9efe eb				ex de, hl 
9eff			 
9eff			 
9eff				; save the pointer of the current token - 1 to check against 
9eff				 
9eff 22 53 ea			ld (cli_token), hl   
9f02				; TODO maybe remove below save if no debug 
9f02				; save token string ptr for any debug later 
9f02 23				inc hl  
9f03 22 55 ea			ld (cli_origtoken), hl 
9f06 2b				dec hl 
9f07				; save pointer to the start of the next dictionay word 
9f07 7e				ld a,(hl)   ; get string length 
9f08 47				ld b,a 
9f09			.execpnwordinc:  
9f09 23				inc hl 
9f0a 10 fd			djnz .execpnwordinc 
9f0c 22 51 ea			ld (cli_execword), hl      ; save start of this words code 
9f0f			 
9f0f				; now check the word token against the string being parsed 
9f0f			 
9f0f 2a 53 ea			ld hl,(cli_token) 
9f12 23				inc hl     ; skip string length (use zero term instead to end) 
9f13 22 53 ea			ld (cli_token), hl 
9f16			 
9f16			if DEBUG_FORTH_PARSE_KEY 
9f16						DMARK "KY2" 
9f16			endif 
9f16			if DEBUG_FORTH_PARSE_EXEC 
9f16				; see if disabled 
9f16			 
9f16				ld a, (os_view_disable) 
9f16				cp '*' 
9f16				jr z, .skip 
9f16			 
9f16				push hl 
9f16				push hl 
9f16				call clear_display 
9f16				ld de, .compword 
9f16				ld a, display_row_1 
9f16				call str_at_display 
9f16				pop de 
9f16				ld a, display_row_2 
9f16				call str_at_display 
9f16				ld hl,(cli_ptr) 
9f16				ld a,(hl) 
9f16			        ld hl, os_word_scratch 
9f16				ld (hl),a 
9f16				ld a,0 
9f16				inc hl 
9f16				ld (hl),a 	 
9f16				ld de, os_word_scratch 
9f16				ld a, display_row_2+10 
9f16				call str_at_display 
9f16				call update_display 
9f16				ld a, 100 
9f16				call aDelayInMS 
9f16				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f16				call delay250ms 
9f16				endif 
9f16				pop hl 
9f16			.skip:  
9f16			endif	 
9f16			.execpnchar:    ; compare char between token and string to parse 
9f16			 
9f16			if DEBUG_FORTH_PARSE_KEY 
9f16						DMARK "Ky3" 
9f16			endif 
9f16			if DEBUG_FORTH_PARSE_EXEC 
9f16				; see if disabled 
9f16			 
9f16				ld a, (os_view_disable) 
9f16				cp '*' 
9f16				jr z, .skip2 
9f16			 
9f16			;	call clear_display 
9f16			ld hl,(cli_token) 
9f16			ld a,(hl) 
9f16			ld (os_word_scratch),a 
9f16				ld hl,(cli_ptr) 
9f16			ld a,(hl) 
9f16				ld (os_word_scratch+1),a 
9f16				ld a,0 
9f16				ld (os_word_scratch+2),a 
9f16				ld de,os_word_scratch 
9f16				ld a,display_row_4 
9f16				call str_at_display 
9f16				call update_display 
9f16			.skip2:  
9f16			endif 
9f16 2a 53 ea			ld hl,(cli_token) 
9f19 7e				ld a, (hl)	 ; char in word token 
9f1a 23				inc hl 		; move to next char 
9f1b 22 53 ea			ld (cli_token), hl ; and save it 
9f1e 47				ld b,a 
9f1f			 
9f1f 2a 4d ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9f22 7e				ld a,(hl) 
9f23 23				inc hl 
9f24 22 4d ea			ld (cli_ptr), hl		; move to next char 
9f27 cd bf 90			call toUpper 		; make sure the input string matches case 
9f2a			 
9f2a			if DEBUG_FORTH_PARSE 
9f2a			endif 
9f2a			 
9f2a				; input stream end of token is a space so get rid of it 
9f2a			 
9f2a			;	cp ' ' 
9f2a			;	jr nz, .pnskipspace 
9f2a			; 
9f2a			;	ld a, 0		; make same term as word token term 
9f2a			; 
9f2a			;.pnskipspace: 
9f2a			 
9f2a			if DEBUG_FORTH_PARSE_KEY 
9f2a						DMARK "KY7" 
9f2a			endif 
9f2a b8				cp b 
9f2b c2 41 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f2e				 
9f2e			;    if same 
9f2e			;       scan for string terms 0 for token and 32 for input 
9f2e			 
9f2e				 
9f2e			if DEBUG_FORTH_PARSE_KEY 
9f2e						DMARK "KY8" 
9f2e			endif 
9f2e			 
9f2e 80				add b			 
9f2f fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9f31							; TODO need to make sure last word in zero term string is accounted for 
9f31 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9f33			 
9f33			 
9f33				; at end of both strings so both are exact match 
9f33			 
9f33			;       skip ptr for next word 
9f33			 
9f33 2a 4d ea			ld hl,(cli_ptr) 	; at input string term 
9f36 23				inc hl			 ; at next char 
9f37 22 4d ea			ld (cli_ptr), hl     ; save for next round of the parser 
9f3a 22 4b ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9f3d				 
9f3d				 
9f3d			if DEBUG_FORTH_PARSE_KEY 
9f3d						DMARK "KY3" 
9f3d			endif 
9f3d			 
9f3d			 
9f3d			 
9f3d			;       exec code block 
9f3d			if DEBUG_FORTH_JP 
9f3d				call clear_display 
9f3d				call update_display 
9f3d				call delay1s 
9f3d				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f3d				ld a,h 
9f3d				ld hl, os_word_scratch 
9f3d				call hexout 
9f3d				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f3d				ld a,l 
9f3d				ld hl, os_word_scratch+2 
9f3d				call hexout 
9f3d				ld hl, os_word_scratch+4 
9f3d				ld a,0 
9f3d				ld (hl),a 
9f3d				ld de,os_word_scratch 
9f3d				call str_at_display 
9f3d					ld a, display_row_2 
9f3d					call str_at_display 
9f3d				ld de, (cli_origtoken) 
9f3d				ld a, display_row_1+10 
9f3d					call str_at_display 
9f3d			 
9f3d				ld a,display_row_1 
9f3d				ld de, .foundword 
9f3d				ld a, display_row_3 
9f3d				call str_at_display 
9f3d				call update_display 
9f3d				call delay1s 
9f3d				call delay1s 
9f3d				call delay1s 
9f3d			endif 
9f3d			 
9f3d			if DEBUG_FORTH_PARSE_KEY 
9f3d						DMARK "KYj" 
9f3d			endif 
9f3d				; TODO save the word pointer in this exec 
9f3d			 
9f3d 2a 51 ea			ld hl,(cli_execword) 
9f40 e9				jp (hl) 
9f41			 
9f41			 
9f41			;    if not same 
9f41			;	scan for zero term 
9f41			;	get ptr for next word 
9f41			;	goto word comp 
9f41			 
9f41			.execpnskipword:	; get pointer to next word 
9f41 2a 4f ea			ld hl,(cli_nextword) 
9f44			 
9f44 7e				ld a,(hl) 
9f45 fe 00			cp WORD_SYS_END 
9f47			;	cp 0 
9f47 28 09			jr z, .execendofdict			 ; at end of words 
9f49			 
9f49			if DEBUG_FORTH_PARSE_KEY 
9f49						DMARK "KY4" 
9f49			endif 
9f49			if DEBUG_FORTH_PARSE_EXEC 
9f49			 
9f49				; see if disabled 
9f49			 
9f49				ld a, (os_view_disable) 
9f49				cp '*' 
9f49				jr z, .noskip 
9f49			 
9f49			 
9f49				ld de, .nowordfound 
9f49				ld a, display_row_3 
9f49				call str_at_display 
9f49				call update_display 
9f49				ld a, 100 
9f49				call aDelayInMS 
9f49				 
9f49				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f49					call delay250ms 
9f49				endif 
9f49			.noskip:  
9f49			 
9f49			endif	 
9f49			 
9f49 2a 4b ea			ld hl,(cli_origptr) 
9f4c 22 4d ea			ld (cli_ptr),hl 
9f4f			 
9f4f			if DEBUG_FORTH_PARSE_KEY 
9f4f						DMARK "KY5" 
9f4f			endif 
9f4f c3 f5 9e			jp .execpnword			; else go to next word 
9f52			 
9f52			.execendofdict:  
9f52			 
9f52			if DEBUG_FORTH_PARSE_KEY 
9f52						DMARK "KYe" 
9f52			endif 
9f52			if DEBUG_FORTH_PARSE_EXEC 
9f52				; see if disabled 
9f52			 
9f52				ld a, (os_view_disable) 
9f52				cp '*' 
9f52				jr z, .ispskip 
9f52			 
9f52				call clear_display 
9f52				call update_display 
9f52				call delay1s 
9f52				ld de, (cli_origptr) 
9f52				ld a, display_row_1 
9f52				call str_at_display 
9f52				 
9f52				ld de, .enddict 
9f52				ld a, display_row_3 
9f52				call str_at_display 
9f52				call update_display 
9f52				ld a, 100 
9f52				call aDelayInMS 
9f52				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f52				call delay1s 
9f52				call delay1s 
9f52				call delay1s 
9f52				endif 
9f52			.ispskip:  
9f52				 
9f52			endif	 
9f52			 
9f52			 
9f52			 
9f52				; if the word is not a keyword then must be a literal so push it to stack 
9f52			 
9f52			; push token to stack to end of word 
9f52			 
9f52				STACKFRAME ON $1efe $2f9f 
9f52				if DEBUG_STACK_IMB 
9f52					if ON 
9f52						exx 
9f52						ld de, $1efe 
9f52						ld a, d 
9f52						ld hl, curframe 
9f52						call hexout 
9f52						ld a, e 
9f52						ld hl, curframe+2 
9f52						call hexout 
9f52						ld hl, $1efe 
9f52						push hl 
9f52						ld hl, $2f9f 
9f52						push hl 
9f52						exx 
9f52					endif 
9f52				endif 
9f52			endm 
# End of macro STACKFRAME
9f52			 
9f52 2a 03 e6		ld hl,(os_tok_ptr) 
9f55 cd 45 9c		call forth_apush 
9f58			 
9f58				STACKFRAMECHK ON $1efe $2f9f 
9f58				if DEBUG_STACK_IMB 
9f58					if ON 
9f58						exx 
9f58						ld hl, $2f9f 
9f58						pop de   ; $2f9f 
9f58						call cmp16 
9f58						jr nz, .spnosame 
9f58						ld hl, $1efe 
9f58						pop de   ; $1efe 
9f58						call cmp16 
9f58						jr z, .spfrsame 
9f58						.spnosame: call showsperror 
9f58						.spfrsame: nop 
9f58						exx 
9f58					endif 
9f58				endif 
9f58			endm 
# End of macro STACKFRAMECHK
9f58			 
9f58			execnext: 
9f58			 
9f58			if DEBUG_FORTH_PARSE_KEY 
9f58						DMARK "KY>" 
9f58			endif 
9f58			; move past token to next word 
9f58			 
9f58 2a 03 e6		ld hl, (os_tok_ptr) 
9f5b 3e 00		ld a, 0 
9f5d 01 ff 00		ld bc, 255     ; input buffer size 
9f60 ed b1		cpir 
9f62			 
9f62			if DEBUG_FORTH_PARSE_KEY 
9f62						DMARK "KY!" 
9f62				CALLMONITOR 
9f62			endif	 
9f62			; TODO this might place hl on the null, so will need to forward on??? 
9f62			;inc hl   ; see if this gets onto the next item 
9f62			 
9f62			 
9f62			; TODO pass a pointer to the buffer to push 
9f62			; TODO call function to push 
9f62			 
9f62			; look for end of input 
9f62			 
9f62			;inc hl 
9f62			;ld a,(hl) 
9f62			;cp FORTH_END_BUFFER 
9f62			;ret z 
9f62			 
9f62			 
9f62 c3 db 9e		jp exec1 
9f65			 
9f65			 
9f65			 
9f65			 
9f65			 
9f65			 
9f65			 
9f65			 
9f65			 
9f65			findnexttok: 
9f65			 
9f65				; hl is pointer to move 
9f65				; de is the token to locate 
9f65			 
9f65					if DEBUG_FORTH 
9f65						DMARK "NTK" 
9f65						CALLMONITOR 
9f65					endif 
9f65 d5				push de 
9f66			 
9f66			.fnt1:	 
9f66				; find first char of token to locate 
9f66			 
9f66 1a				ld a, (de) 
9f67 4f				ld c,a 
9f68 7e				ld a,(hl) 
9f69 cd bf 90			call toUpper 
9f6c					if DEBUG_FORTH 
9f6c						DMARK "NT1" 
9f6c						CALLMONITOR 
9f6c					endif 
9f6c b9				cp c 
9f6d			 
9f6d 28 03			jr z, .fnt2cmpmorefirst	 
9f6f			 
9f6f				; first char not found move to next char 
9f6f			 
9f6f 23				inc hl 
9f70 18 f4			jr .fnt1 
9f72			 
9f72			.fnt2cmpmorefirst:	 
9f72				; first char of token found.  
9f72			 
9f72 e5				push hl     ; save start of token just in case it is the right one 
9f73 d9				exx 
9f74 e1				pop hl        ; save it to hl' 
9f75 d9				exx 
9f76			 
9f76			 
9f76			.fnt2cmpmore:	 
9f76				; compare the rest 
9f76				 
9f76 23				inc hl 
9f77 13				inc de 
9f78				 
9f78 1a				ld a, (de) 
9f79 4f				ld c,a 
9f7a 7e				ld a,(hl) 
9f7b cd bf 90			call toUpper 
9f7e			 
9f7e					if DEBUG_FORTH 
9f7e						DMARK "NT2" 
9f7e						CALLMONITOR 
9f7e					endif 
9f7e				; c has the token to find char 
9f7e				; a has the mem to scan char 
9f7e			 
9f7e b9				cp c 
9f7f 28 04			jr z,.fntmatch1 
9f81			 
9f81				; they are not the same 
9f81			 
9f81					if DEBUG_FORTH 
9f81						DMARK "NT3" 
9f81						CALLMONITOR 
9f81					endif 
9f81 d1				pop de	; reset de token to look for 
9f82 d5				push de 
9f83 18 e1			jr .fnt1 
9f85				 
9f85			.fntmatch1: 
9f85			 
9f85				; is the same char a null which means we might have a full hit? 
9f85					if DEBUG_FORTH 
9f85						DMARK "NT4" 
9f85						CALLMONITOR 
9f85					endif 
9f85			 
9f85 fe 00			cp 0 
9f87 28 0b			jr z, .fntmatchyes 
9f89			 
9f89				; are we at the end of the token to find? 
9f89			 
9f89					if DEBUG_FORTH 
9f89						DMARK "NT5" 
9f89						CALLMONITOR 
9f89					endif 
9f89 3e 00			ld a, 0 
9f8b b9				cp c 
9f8c			 
9f8c c2 76 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9f8f			 
9f8f					if DEBUG_FORTH 
9f8f						DMARK "NT6" 
9f8f						CALLMONITOR 
9f8f					endif 
9f8f				; token to find is exhusted but no match to stream 
9f8f			 
9f8f				; restore tok pointer and continue on 
9f8f d1				pop de 
9f90 d5				push de 
9f91 c3 66 9f			jp .fnt1 
9f94			 
9f94			 
9f94			.fntmatchyes: 
9f94			 
9f94				; hl now contains the end of the found token 
9f94			 
9f94				; get rid of saved token pointer to find 
9f94			 
9f94 d1				pop de 
9f95			 
9f95					if DEBUG_FORTH 
9f95						DMARK "NT9" 
9f95						CALLMONITOR 
9f95					endif 
9f95			 
9f95				; hl will be on the null term so forward on 
9f95			 
9f95				; get back the saved start of the token 
9f95			 
9f95 d9				exx 
9f96 e5				push hl     ; save start of token just in case it is the right one 
9f97 d9				exx 
9f98 e1				pop hl        ; save it to hl 
9f99			 
9f99 c9				ret 
9f9a			 
9f9a			 
9f9a			; LIST needs to find a specific token   
9f9a			; FORGET needs to find a spefici token 
9f9a			 
9f9a			; SAVE needs to find all tokens by flag 
9f9a			; WORDS just needs to scan through all  by flag 
9f9a			; UWORDS needs to scan through all by flag 
9f9a			 
9f9a			 
9f9a			; given hl as pointer to start of dict look up string 
9f9a			; return hl as pointer to start of word block 
9f9a			; or 0 if not found 
9f9a			 
9f9a			forth_find_tok: 
9f9a c9				ret 
9f9b			 
9f9b			; given hl as pointer to dict structure 
9f9b			; move to the next dict block structure 
9f9b			 
9f9b			forth_tok_next: 
9f9b				; hl now points to the address of the next word pointer  
9f9b				; TODO skip compiled symbol for now 
9f9b			;	push de 
9f9b 23				inc hl 
9f9c 5e				ld e, (hl) 
9f9d 23				inc hl 
9f9e 56				ld d, (hl) 
9f9f 23				inc hl 
9fa0			 
9fa0 eb				ex de,hl 
9fa1			if DEBUG_FORTH_PARSE_NEXTWORD 
9fa1				push bc 
9fa1				ld bc, (cli_nextword) 
9fa1						DMARK "NXW" 
9fa1				CALLMONITOR 
9fa1				pop bc 
9fa1			endif 
9fa1			;	pop de	 
9fa1 c9				ret 
9fa2			 
9fa2			 
9fa2			 
9fa2			; eof 
# End of file forth_parserv5.asm
9fa2				include "forth_wordsv4.asm" 
9fa2			 
9fa2			; the core word dictionary v4 
9fa2			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9fa2			 
9fa2			; this is a linked list for each of the system words used 
9fa2			; user defined words will follow the same format but will be in ram 
9fa2			 
9fa2			 
9fa2			; 
9fa2			; 
9fa2			; define linked list: 
9fa2			; 
9fa2			; 1. compiled byte op code 
9fa2			; 2. len of text word 
9fa2			; 3. text word 
9fa2			; 4. ptr to next dictionary word 
9fa2			; 5. asm, calls etc for the word 
9fa2			; 
9fa2			;  if 1 == 0 then last word in dict  
9fa2			;   
9fa2			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9fa2			;  
9fa2			;  
9fa2			; create basic standard set of words 
9fa2			; 
9fa2			;  
9fa2			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9fa2			; 2DUP 2DROP 2SWAP  
9fa2			; @ C@ - get byte  
9fa2			; ! C! - store byte 
9fa2			; 0< true if less than zero 
9fa2			; 0= true if zero 
9fa2			; < >  
9fa2			; = true if same 
9fa2			; variables 
9fa2			 
9fa2			 
9fa2			; Hardware specific words I may need 
9fa2			; 
9fa2			; IN OUT  
9fa2			; calls to key util functions 
9fa2			; calls to hardward abstraction stuff 
9fa2			; easy control of frame buffers and lcd i/o 
9fa2			; keyboard  
9fa2			 
9fa2			 
9fa2			;DICT: macro 
9fa2			; op_code, len, word, next 
9fa2			;    word: 
9fa2			;    db op_code 
9fa2			;    ds word zero term 
9fa2			;    dw next 
9fa2			;    endm 
9fa2			 
9fa2			 
9fa2			 
9fa2			 
9fa2			; op code 1 is a flag for user define words which are to be handled differently 
9fa2			 
9fa2			 
9fa2			; 
9fa2			; 
9fa2			;    TODO on entry to a word this should be the expected environment 
9fa2			;    hl - tos value if number then held, if string this is the ptr 
9fa2			;    de -  
9fa2			 
9fa2			 
9fa2			; opcode ranges 
9fa2			; 0 - end of word dict 
9fa2			; 255 - user define words 
9fa2			 
9fa2			sysdict: 
9fa2			include "forth_opcodes.asm" 
9fa2			; op codes for forth keywords 
9fa2			; free to use code 0  
9fa2				OPCODE_HEAP: equ  1 
9fa2				OPCODE_EXEC: equ 2 
9fa2				OPCODE_DUP: equ 3 
9fa2				OPCODE_SWAP: equ 4 
9fa2				OPCODE_COLN: equ 5 
9fa2				OPCODE_SCOLN: equ 6 
9fa2				OPCODE_DROP: equ 7 
9fa2				OPCODE_DUP2: equ 8 
9fa2				OPCODE_DROP2: equ 9 
9fa2				OPCODE_SWAP2: equ 10 
9fa2				OPCODE_AT: equ 11 
9fa2				OPCODE_CAT: equ 12 
9fa2				OPCODE_BANG: equ 13 
9fa2				OPCODE_CBANG: equ 14 
9fa2				OPCODE_SCALL: equ 15 
9fa2				OPCODE_DEPTH: equ 16 
9fa2				OPCODE_OVER: equ 17 
9fa2				OPCODE_PAUSE: equ 18 
9fa2				OPCODE_PAUSES: equ 19 
9fa2				OPCODE_ROT: equ 20 
9fa2			;free to reuse	OPCODE_WORDS: equ 21 
9fa2			        OPCODE_NOT: equ 21 
9fa2				OPCODE_UWORDS: equ 22 
9fa2				OPCODE_BP: equ 23 
9fa2				OPCODE_MONITOR: equ 24  
9fa2				OPCODE_MALLOC: equ 25 
9fa2				OPCODE_FREE: equ 26 
9fa2				OPCODE_LIST: equ 27 
9fa2				OPCODE_FORGET: equ 28 
9fa2				OPCODE_NOP: equ 29 
9fa2				OPCODE_COMO: equ 30 
9fa2				OPCODE_COMC: equ 31 
9fa2			;free to reuse	OPCODE_ENDCORE: equ 32 
9fa2				OPCODE_AFTERSOUND: equ 33 
9fa2				OPCODE_GP2: equ 34 
9fa2				OPCODE_GP3: equ 35 
9fa2				OPCODE_GP4: equ 36 
9fa2				OPCODE_SIN: equ 37 
9fa2				OPCODE_SOUT: equ 38 
9fa2				OPCODE_SPIO: equ 39 
9fa2				OPCODE_SPICEH: equ 40 
9fa2				OPCODE_SPIOb: equ 41 
9fa2				OPCODE_SPII: equ 42 
9fa2				OPCODE_SESEL: equ 43 
9fa2				OPCODE_CARTDEV: equ 44 
9fa2			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9fa2				OPCODE_FB: equ 46 
9fa2				OPCODE_EMIT: equ 47 
9fa2				OPCODE_DOTH: equ 48 
9fa2				OPCODE_DOTF: equ 49 
9fa2				OPCODE_DOT: equ 50 
9fa2				OPCODE_CLS: equ 51 
9fa2				OPCODE_DRAW: equ 52 
9fa2				OPCODE_DUMP: equ 53 
9fa2				OPCODE_CDUMP: equ 54 
9fa2				OPCODE_DAT: equ 55 
9fa2				OPCODE_HOME: equ 56 
9fa2				OPCODE_SPACE: equ 57 
9fa2				OPCODE_SPACES: equ 58 
9fa2				OPCODE_SCROLL: equ 59 
9fa2				OPCODE_ATQ: equ 60 
9fa2				OPCODE_AUTODSP: equ 61 
9fa2				OPCODE_MENU: equ 62 
9fa2			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9fa2				OPCODE_THEN: equ 64 
9fa2				OPCODE_ELSE: equ 65 
9fa2				OPCODE_DO: equ 66 
9fa2				OPCODE_LOOP: equ 67 
9fa2				OPCODE_I: equ 68 
9fa2				OPCODE_DLOOP: equ 69  
9fa2				OPCODE_REPEAT: equ 70  
9fa2				OPCODE_UNTIL: equ 71 
9fa2				OPCODE_ENDFLOW: equ 72 
9fa2				OPCODE_WAITK: equ 73 
9fa2				OPCODE_ACCEPT: equ 74 
9fa2				OPCODE_EDIT: equ 75 
9fa2			;free to reuse	OPCODE_ENDKEY: equ 76 
9fa2				OPCODE_LZERO: equ 77 
9fa2				OPCODE_TZERO: equ 78 
9fa2				OPCODE_LESS: equ 79 
9fa2				OPCODE_GT: equ 80 
9fa2				OPCODE_EQUAL: equ 81  
9fa2			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9fa2				OPCODE_NEG: equ 83 
9fa2				OPCODE_DIV: equ 84 
9fa2				OPCODE_MUL: equ 85 
9fa2				OPCODE_MIN: equ 86 
9fa2				OPCODE_MAX: equ 87 
9fa2				OPCODE_RND16: equ 88 
9fa2				OPCODE_RND8: equ 89 
9fa2				OPCODE_RND: equ 90 
9fa2			;free to reuse	OPCODE_ENDMATHS: equ 91  
9fa2				OPCODE_BYNAME: equ 92 
9fa2				OPCODE_DIR: equ 93 
9fa2				OPCODE_SAVE: equ 94 
9fa2				OPCODE_LOAD: equ 95 
9fa2				OPCODE_BSAVE: equ 96 
9fa2				OPCODE_BLOAD: equ 97 
9fa2				OPCODE_SEO: equ 98  
9fa2				OPCODE_SEI: equ 99 
9fa2				OPCODE_SFREE: equ 100 
9fa2				OPCODE_SIZE: equ 101 
9fa2				OPCODE_CREATE: equ 102 
9fa2				OPCODE_APPEND: equ 103 
9fa2				OPCODE_SDEL: equ 104 
9fa2				OPCODE_OPEN: equ 105 
9fa2				OPCODE_READ: equ 106 
9fa2				OPCODE_EOF: equ 106 
9fa2				OPCODE_FORMAT: equ 107 
9fa2				OPCODE_LABEL: equ 108 
9fa2				OPCODE_LABELS: equ 109 
9fa2			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9fa2				OPCODE_UPPER: equ 111 
9fa2				OPCODE_LOWER: equ 112 
9fa2				OPCODE_SUBSTR: equ 113 
9fa2				OPCODE_LEFT: equ 114 
9fa2				OPCODE_RIGHT: equ 115 
9fa2				OPCODE_STR2NUM: equ 116 
9fa2				OPCODE_NUM2STR: equ 117 
9fa2				OPCODE_CONCAT: equ 118 
9fa2				OPCODE_FIND: equ 119 
9fa2				OPCODE_LEN: equ 120 
9fa2				OPCODE_CHAR: equ 121 
9fa2			; free to reuse	OPCODE_STRLEN: equ 122 
9fa2			; free to reuse	OPCODE_ENDSTR: equ 123 
9fa2				OPCODE_V0S: equ 124 
9fa2				OPCODE_V0Q: equ 125 
9fa2				OPCODE_V1S: equ 126 
9fa2				OPCODE_V1Q: equ 127 
9fa2				OPCODE_V2S: equ 128 
9fa2				OPCODE_V2Q: equ 129 
9fa2				OPCODE_V3S: equ 130 
9fa2				OPCODE_V3Q: equ 131 
9fa2			;free to reuse	OPCODE_END: equ 132 
9fa2				OPCODE_ZDUP: equ 133 
9fa2			 
9fa2			; eof 
# End of file forth_opcodes.asm
9fa2			 
9fa2			include "forth_words_core.asm" 
9fa2			 
9fa2			; | ## Core Words 
9fa2			 
9fa2			;if MALLOC_4 
9fa2			 
9fa2			.HEAP: 
9fa2				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9fa2 15				db WORD_SYS_CORE+OPCODE_HEAP             
9fa3 e1 9f			dw .EXEC            
9fa5 05				db 4 + 1 
9fa6 .. 00			db "HEAP",0              
9fab				endm 
# End of macro CWHEAD
9fab			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9fab			; | | u1 - Current number of bytes in the heap 
9fab			; | | u2 - Remaining bytes left on the heap 
9fab			; | |  
9fab			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9fab			 
9fab			 
9fab					if DEBUG_FORTH_WORDS_KEY 
9fab						DMARK "HEP" 
9fab f5				push af  
9fac 3a c0 9f			ld a, (.dmark)  
9faf 32 71 ee			ld (debug_mark),a  
9fb2 3a c1 9f			ld a, (.dmark+1)  
9fb5 32 72 ee			ld (debug_mark+1),a  
9fb8 3a c2 9f			ld a, (.dmark+2)  
9fbb 32 73 ee			ld (debug_mark+2),a  
9fbe 18 03			jr .pastdmark  
9fc0 ..			.dmark: db "HEP"  
9fc3 f1			.pastdmark: pop af  
9fc4			endm  
# End of macro DMARK
9fc4						CALLMONITOR 
9fc4 cd 6b 94			call break_point_state  
9fc7				endm  
# End of macro CALLMONITOR
9fc7					endif 
9fc7 2a 5d da				ld hl, (free_list )      
9fca 11 62 da				ld de, heap_start 
9fcd			 
9fcd ed 52				sbc hl, de  
9fcf			 
9fcf cd dc 9a				call forth_push_numhl 
9fd2			 
9fd2			 
9fd2 ed 5b 5d da			ld de, (free_list )      
9fd6 21 e8 e2				ld hl, heap_end 
9fd9			 
9fd9 ed 52				sbc hl, de 
9fdb			 
9fdb cd dc 9a				call forth_push_numhl 
9fde					 
9fde			 
9fde					 
9fde			 
9fde			 
9fde			 
9fde					NEXTW 
9fde c3 4a 9e			jp macro_next 
9fe1				endm 
# End of macro NEXTW
9fe1			;endif 
9fe1			 
9fe1			.EXEC: 
9fe1			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9fe1			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9fe1			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9fe1			;; > > 
9fe1			;; > >   
9fe1			;	STACKFRAME OFF $5efe $5f9f 
9fe1			; 
9fe1			;		if DEBUG_FORTH_WORDS_KEY 
9fe1			;			DMARK "EXE" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			; 
9fe1			;	FORTH_DSP_VALUEHL 
9fe1			; 
9fe1			;	FORTH_DSP_POP 
9fe1			; 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EX1" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			;;	ld e,(hl) 
9fe1			;;	inc hl 
9fe1			;;	ld d,(hl) 
9fe1			;;	ex de,hl 
9fe1			; 
9fe1			;;		if DEBUG_FORTH_WORDS 
9fe1			;;			DMARK "EX2" 
9fe1			;;			CALLMONITOR 
9fe1			;;		endif 
9fe1			;	push hl 
9fe1			; 
9fe1			;	;ld a, 0 
9fe1			;	;ld a, FORTH_END_BUFFER 
9fe1			;	call strlenz 
9fe1			;	inc hl   ; include zero term to copy 
9fe1			;	inc hl   ; include term 
9fe1			;	inc hl   ; include term 
9fe1			;	ld b,0 
9fe1			;	ld c,l 
9fe1			;	pop hl 
9fe1			;	ld de, execscratch 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EX3" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			;	ldir 
9fe1			; 
9fe1			; 
9fe1			;	ld hl, execscratch 
9fe1			; 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EXe" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			; 
9fe1			;	call forthparse 
9fe1			;	call forthexec 
9fe1			;;	call forthexec_cleanup 
9fe1			;;	call forthparse 
9fe1			;;	call forthexec 
9fe1			; 
9fe1			;	STACKFRAMECHK OFF $5efe $5f9f 
9fe1			; 
9fe1			;	; an immediate word so no need to process any more words 
9fe1			;	ret 
9fe1			;	NEXTW 
9fe1			 
9fe1			; dead code - old version  
9fe1			;	FORTH_RSP_NEXT 
9fe1			 
9fe1			;  
9fe1			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9fe1			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9fe1			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9fe1			;	push hl 
9fe1			;	push de 
9fe1			;	push bc 
9fe1			; 
9fe1			; 
9fe1			;		if DEBUG_FORTH_WORDS_KEY 
9fe1			;			DMARK "EXR" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			; 
9fe1			; 
9fe1			; 
9fe1			;	;v5 FORTH_DSP_VALUE 
9fe1			;	FORTH_DSP_VALUEHL 
9fe1			; 
9fe1			;	; TODO do string type checks 
9fe1			; 
9fe1			;;v5	inc hl   ; skip type 
9fe1			; 
9fe1			;	push hl  ; source code  
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EX1" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			;	ld a, 0 
9fe1			;	call strlent 
9fe1			; 
9fe1			;	inc hl 
9fe1			;	inc hl 
9fe1			;	inc hl 
9fe1			;	inc hl 
9fe1			; 
9fe1			;	push hl    ; size 
9fe1			; 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EX2" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			;	call malloc 
9fe1			; 
9fe1			;	ex de, hl    ; de now contains malloc area 
9fe1			;	pop bc   	; get byte count 
9fe1			;	pop hl      ; get string to copy 
9fe1			; 
9fe1			;	push de     ; save malloc for free later 
9fe1			; 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EX3" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			;	ldir       ; duplicate string 
9fe1			; 
9fe1			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9fe1			;	 
9fe1			;	; TODO fix the parse would be better than this...  
9fe1			;	ex de, hl 
9fe1			;	dec hl 
9fe1			;	ld a, 0 
9fe1			;	ld (hl), a 
9fe1			;	dec hl 
9fe1			;	ld a, ' ' 
9fe1			;	ld (hl), a 
9fe1			;	dec hl 
9fe1			;	ld (hl), a 
9fe1			; 
9fe1			;	dec hl 
9fe1			;	ld (hl), a 
9fe1			; 
9fe1			; 
9fe1			;	FORTH_DSP_POP  
9fe1			; 
9fe1			;	pop hl     
9fe1			;	push hl    ; save malloc area 
9fe1			; 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EX4" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			; 
9fe1			;	call forthparse 
9fe1			;	call forthexec 
9fe1			;	 
9fe1			;	pop hl 
9fe1			;	if DEBUG_FORTH_WORDS 
9fe1			;		DMARK "EX5" 
9fe1			;		CALLMONITOR 
9fe1			;	endif 
9fe1			; 
9fe1			;	if FORTH_ENABLE_FREE 
9fe1			;	call free 
9fe1			;	endif 
9fe1			; 
9fe1			;	if DEBUG_FORTH_WORDS 
9fe1			;		DMARK "EX6" 
9fe1			;		CALLMONITOR 
9fe1			;	endif 
9fe1			; 
9fe1			;	pop bc 
9fe1			;	pop de 
9fe1			;	pop hl 
9fe1			;;	FORTH_RSP_POP	  
9fe1			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9fe1			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9fe1			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9fe1			; 
9fe1			;	if DEBUG_FORTH_WORDS 
9fe1			;		DMARK "EX7" 
9fe1			;		CALLMONITOR 
9fe1			;	endif 
9fe1			;	NEXTW 
9fe1			 
9fe1			;.STKEXEC: 
9fe1			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9fe1			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9fe1			; 
9fe1			; 
9fe1			;		if DEBUG_FORTH_WORDS_KEY 
9fe1			;			DMARK "STX" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			; 
9fe1			;	FORTH_DSP_VALUEHL 
9fe1			; 
9fe1			;	ld (store_tmp1), hl    ; count 
9fe1			; 
9fe1			;	FORTH_DSP_POP 
9fe1			;.stkexec1: 
9fe1			;	ld hl, (store_tmp1)   ; count 
9fe1			;	ld a, 0 
9fe1			;	cp l 
9fe1			;	ret z 
9fe1			; 
9fe1			;	dec hl 
9fe1			;	ld (store_tmp1), hl    ; count 
9fe1			;	 
9fe1			;	FORTH_DSP_VALUEHL 
9fe1			;	push hl 
9fe1			;	 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EXp" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			;	FORTH_DSP_POP 
9fe1			; 
9fe1			;	call strlenz 
9fe1			;	inc hl   ; include zero term to copy 
9fe1			;	inc hl   ; include zero term to copy 
9fe1			;	inc hl   ; include zero term to copy 
9fe1			;	ld b,0 
9fe1			;	ld c,l 
9fe1			;	pop hl 
9fe1			;	ld de, execscratch 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EX3" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			;	ldir 
9fe1			; 
9fe1			; 
9fe1			;	ld hl, execscratch 
9fe1			; 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EXP" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			; 
9fe1			;	call forthparse 
9fe1			;	ld hl, execscratch 
9fe1			;		if DEBUG_FORTH_WORDS 
9fe1			;			DMARK "EXx" 
9fe1			;			CALLMONITOR 
9fe1			;		endif 
9fe1			;	call forthexec 
9fe1			; 
9fe1			;	jp .stkexec1 
9fe1			; 
9fe1			;	ret 
9fe1			 
9fe1			 
9fe1			.DUP: 
9fe1				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9fe1 17				db WORD_SYS_CORE+OPCODE_DUP             
9fe2 57 a0			dw .ZDUP            
9fe4 04				db 3 + 1 
9fe5 .. 00			db "DUP",0              
9fe9				endm 
# End of macro CWHEAD
9fe9			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9fe9			 
9fe9					if DEBUG_FORTH_WORDS_KEY 
9fe9						DMARK "DUP" 
9fe9 f5				push af  
9fea 3a fe 9f			ld a, (.dmark)  
9fed 32 71 ee			ld (debug_mark),a  
9ff0 3a ff 9f			ld a, (.dmark+1)  
9ff3 32 72 ee			ld (debug_mark+1),a  
9ff6 3a 00 a0			ld a, (.dmark+2)  
9ff9 32 73 ee			ld (debug_mark+2),a  
9ffc 18 03			jr .pastdmark  
9ffe ..			.dmark: db "DUP"  
a001 f1			.pastdmark: pop af  
a002			endm  
# End of macro DMARK
a002						CALLMONITOR 
a002 cd 6b 94			call break_point_state  
a005				endm  
# End of macro CALLMONITOR
a005					endif 
a005			 
a005					FORTH_DSP 
a005 cd 99 9c			call macro_forth_dsp 
a008				endm 
# End of macro FORTH_DSP
a008			 
a008 7e					ld a, (HL) 
a009 fe 01				cp DS_TYPE_STR 
a00b 20 25				jr nz, .dupinum 
a00d			 
a00d					; push another string 
a00d			 
a00d					FORTH_DSP_VALUEHL     		 
a00d cd d3 9c			call macro_dsp_valuehl 
a010				endm 
# End of macro FORTH_DSP_VALUEHL
a010			 
a010				if DEBUG_FORTH_WORDS 
a010					DMARK "DUs" 
a010 f5				push af  
a011 3a 25 a0			ld a, (.dmark)  
a014 32 71 ee			ld (debug_mark),a  
a017 3a 26 a0			ld a, (.dmark+1)  
a01a 32 72 ee			ld (debug_mark+1),a  
a01d 3a 27 a0			ld a, (.dmark+2)  
a020 32 73 ee			ld (debug_mark+2),a  
a023 18 03			jr .pastdmark  
a025 ..			.dmark: db "DUs"  
a028 f1			.pastdmark: pop af  
a029			endm  
# End of macro DMARK
a029					CALLMONITOR 
a029 cd 6b 94			call break_point_state  
a02c				endm  
# End of macro CALLMONITOR
a02c				endif 
a02c cd 4a 9b				call forth_push_str 
a02f			 
a02f					NEXTW 
a02f c3 4a 9e			jp macro_next 
a032				endm 
# End of macro NEXTW
a032			 
a032			 
a032			.dupinum: 
a032					 
a032			 
a032			 
a032					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a032 cd d3 9c			call macro_dsp_valuehl 
a035				endm 
# End of macro FORTH_DSP_VALUEHL
a035			 
a035				; TODO add floating point number detection 
a035			 
a035				if DEBUG_FORTH_WORDS 
a035					DMARK "DUi" 
a035 f5				push af  
a036 3a 4a a0			ld a, (.dmark)  
a039 32 71 ee			ld (debug_mark),a  
a03c 3a 4b a0			ld a, (.dmark+1)  
a03f 32 72 ee			ld (debug_mark+1),a  
a042 3a 4c a0			ld a, (.dmark+2)  
a045 32 73 ee			ld (debug_mark+2),a  
a048 18 03			jr .pastdmark  
a04a ..			.dmark: db "DUi"  
a04d f1			.pastdmark: pop af  
a04e			endm  
# End of macro DMARK
a04e					CALLMONITOR 
a04e cd 6b 94			call break_point_state  
a051				endm  
# End of macro CALLMONITOR
a051				endif 
a051			 
a051 cd dc 9a				call forth_push_numhl 
a054					NEXTW 
a054 c3 4a 9e			jp macro_next 
a057				endm 
# End of macro NEXTW
a057			.ZDUP: 
a057				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a057 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a058 8f a0			dw .SWAP            
a05a 05				db 4 + 1 
a05b .. 00			db "?DUP",0              
a060				endm 
# End of macro CWHEAD
a060			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a060			 
a060					if DEBUG_FORTH_WORDS_KEY 
a060						DMARK "qDU" 
a060 f5				push af  
a061 3a 75 a0			ld a, (.dmark)  
a064 32 71 ee			ld (debug_mark),a  
a067 3a 76 a0			ld a, (.dmark+1)  
a06a 32 72 ee			ld (debug_mark+1),a  
a06d 3a 77 a0			ld a, (.dmark+2)  
a070 32 73 ee			ld (debug_mark+2),a  
a073 18 03			jr .pastdmark  
a075 ..			.dmark: db "qDU"  
a078 f1			.pastdmark: pop af  
a079			endm  
# End of macro DMARK
a079						CALLMONITOR 
a079 cd 6b 94			call break_point_state  
a07c				endm  
# End of macro CALLMONITOR
a07c					endif 
a07c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a07c cd d3 9c			call macro_dsp_valuehl 
a07f				endm 
# End of macro FORTH_DSP_VALUEHL
a07f			 
a07f e5					push hl 
a080			 
a080					; is it a zero? 
a080			 
a080 3e 00				ld a, 0 
a082 84					add h 
a083 85					add l 
a084			 
a084 e1					pop hl 
a085			 
a085 fe 00				cp 0 
a087 28 03				jr z, .dup2orig 
a089			 
a089			 
a089 cd dc 9a				call forth_push_numhl 
a08c			 
a08c			 
a08c				; TODO add floating point number detection 
a08c			 
a08c			.dup2orig: 
a08c			 
a08c					NEXTW 
a08c c3 4a 9e			jp macro_next 
a08f				endm 
# End of macro NEXTW
a08f			.SWAP: 
a08f				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a08f 18				db WORD_SYS_CORE+OPCODE_SWAP             
a090 ce a0			dw .COLN            
a092 05				db 4 + 1 
a093 .. 00			db "SWAP",0              
a098				endm 
# End of macro CWHEAD
a098			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a098					if DEBUG_FORTH_WORDS_KEY 
a098						DMARK "SWP" 
a098 f5				push af  
a099 3a ad a0			ld a, (.dmark)  
a09c 32 71 ee			ld (debug_mark),a  
a09f 3a ae a0			ld a, (.dmark+1)  
a0a2 32 72 ee			ld (debug_mark+1),a  
a0a5 3a af a0			ld a, (.dmark+2)  
a0a8 32 73 ee			ld (debug_mark+2),a  
a0ab 18 03			jr .pastdmark  
a0ad ..			.dmark: db "SWP"  
a0b0 f1			.pastdmark: pop af  
a0b1			endm  
# End of macro DMARK
a0b1						CALLMONITOR 
a0b1 cd 6b 94			call break_point_state  
a0b4				endm  
# End of macro CALLMONITOR
a0b4					endif 
a0b4			 
a0b4					FORTH_DSP_VALUEHL 
a0b4 cd d3 9c			call macro_dsp_valuehl 
a0b7				endm 
# End of macro FORTH_DSP_VALUEHL
a0b7 e5					push hl     ; w2 
a0b8			 
a0b8					FORTH_DSP_POP 
a0b8 cd 8b 9d			call macro_forth_dsp_pop 
a0bb				endm 
# End of macro FORTH_DSP_POP
a0bb			 
a0bb					FORTH_DSP_VALUEHL 
a0bb cd d3 9c			call macro_dsp_valuehl 
a0be				endm 
# End of macro FORTH_DSP_VALUEHL
a0be			 
a0be					FORTH_DSP_POP 
a0be cd 8b 9d			call macro_forth_dsp_pop 
a0c1				endm 
# End of macro FORTH_DSP_POP
a0c1			 
a0c1 d1					pop de     ; w2	, hl = w1 
a0c2			 
a0c2 eb					ex de, hl 
a0c3 d5					push de 
a0c4			 
a0c4 cd dc 9a				call forth_push_numhl 
a0c7			 
a0c7 e1					pop hl 
a0c8			 
a0c8 cd dc 9a				call forth_push_numhl 
a0cb					 
a0cb			 
a0cb					NEXTW 
a0cb c3 4a 9e			jp macro_next 
a0ce				endm 
# End of macro NEXTW
a0ce			.COLN: 
a0ce				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a0ce 19				db WORD_SYS_CORE+OPCODE_COLN             
a0cf 5a a2			dw .SCOLN            
a0d1 02				db 1 + 1 
a0d2 .. 00			db ":",0              
a0d4				endm 
# End of macro CWHEAD
a0d4			; | : ( -- )         Create new word | DONE 
a0d4			 
a0d4					if DEBUG_FORTH_WORDS_KEY 
a0d4						DMARK "CLN" 
a0d4 f5				push af  
a0d5 3a e9 a0			ld a, (.dmark)  
a0d8 32 71 ee			ld (debug_mark),a  
a0db 3a ea a0			ld a, (.dmark+1)  
a0de 32 72 ee			ld (debug_mark+1),a  
a0e1 3a eb a0			ld a, (.dmark+2)  
a0e4 32 73 ee			ld (debug_mark+2),a  
a0e7 18 03			jr .pastdmark  
a0e9 ..			.dmark: db "CLN"  
a0ec f1			.pastdmark: pop af  
a0ed			endm  
# End of macro DMARK
a0ed						CALLMONITOR 
a0ed cd 6b 94			call break_point_state  
a0f0				endm  
# End of macro CALLMONITOR
a0f0					endif 
a0f0				STACKFRAME OFF $8efe $989f 
a0f0				if DEBUG_STACK_IMB 
a0f0					if OFF 
a0f0						exx 
a0f0						ld de, $8efe 
a0f0						ld a, d 
a0f0						ld hl, curframe 
a0f0						call hexout 
a0f0						ld a, e 
a0f0						ld hl, curframe+2 
a0f0						call hexout 
a0f0						ld hl, $8efe 
a0f0						push hl 
a0f0						ld hl, $989f 
a0f0						push hl 
a0f0						exx 
a0f0					endif 
a0f0				endif 
a0f0			endm 
# End of macro STACKFRAME
a0f0				; get parser buffer length  of new word 
a0f0			 
a0f0				 
a0f0			 
a0f0					; move tok past this to start of name defintition 
a0f0					; TODO get word to define 
a0f0					; TODO Move past word token 
a0f0					; TODO get length of string up to the ';' 
a0f0			 
a0f0 2a 03 e6			ld hl, (os_tok_ptr) 
a0f3 23				inc hl 
a0f4 23				inc hl 
a0f5			 
a0f5 3e 3b			ld a, ';' 
a0f7 cd d3 90			call strlent 
a0fa			 
a0fa 7d				ld a,l 
a0fb 32 fe e2			ld (os_new_parse_len), a 
a0fe			 
a0fe			 
a0fe			if DEBUG_FORTH_UWORD 
a0fe ed 5b 03 e6		ld de, (os_tok_ptr) 
a102						DMARK ":01" 
a102 f5				push af  
a103 3a 17 a1			ld a, (.dmark)  
a106 32 71 ee			ld (debug_mark),a  
a109 3a 18 a1			ld a, (.dmark+1)  
a10c 32 72 ee			ld (debug_mark+1),a  
a10f 3a 19 a1			ld a, (.dmark+2)  
a112 32 73 ee			ld (debug_mark+2),a  
a115 18 03			jr .pastdmark  
a117 ..			.dmark: db ":01"  
a11a f1			.pastdmark: pop af  
a11b			endm  
# End of macro DMARK
a11b				CALLMONITOR 
a11b cd 6b 94			call break_point_state  
a11e				endm  
# End of macro CALLMONITOR
a11e			endif 
a11e			 
a11e			; 
a11e			;  new word memory layout: 
a11e			;  
a11e			;    : adg 6666 ;  
a11e			; 
a11e			;    db   1     ; user defined word  
a11e 23				inc hl    
a11f			;    dw   sysdict 
a11f 23				inc hl 
a120 23				inc hl 
a121			;    db <word len>+1 (for null) 
a121 23				inc hl 
a122			;    db .... <word> 
a122			; 
a122			 
a122 23				inc hl    ; some extras for the word preamble before the above 
a123 23				inc hl 
a124 23				inc hl 
a125 23				inc hl 
a126 23				inc hl 
a127 23				inc hl 
a128 23				inc hl  
a129 23				inc hl 
a12a 23				inc hl 
a12b 23				inc hl 
a12c 23				inc hl 
a12d 23				inc hl 
a12e 23				inc hl 
a12f 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a130			;       exec word buffer 
a130			;	<ptr word>   
a130 23				inc hl 
a131 23				inc hl 
a132			;       <word list><null term> 7F final term 
a132			 
a132			 
a132			if DEBUG_FORTH_UWORD 
a132						DMARK ":02" 
a132 f5				push af  
a133 3a 47 a1			ld a, (.dmark)  
a136 32 71 ee			ld (debug_mark),a  
a139 3a 48 a1			ld a, (.dmark+1)  
a13c 32 72 ee			ld (debug_mark+1),a  
a13f 3a 49 a1			ld a, (.dmark+2)  
a142 32 73 ee			ld (debug_mark+2),a  
a145 18 03			jr .pastdmark  
a147 ..			.dmark: db ":02"  
a14a f1			.pastdmark: pop af  
a14b			endm  
# End of macro DMARK
a14b				CALLMONITOR 
a14b cd 6b 94			call break_point_state  
a14e				endm  
# End of macro CALLMONITOR
a14e			endif 
a14e			 
a14e				 
a14e					; malloc the size 
a14e			 
a14e cd 31 91				call malloc 
a151 22 00 e3				ld (os_new_malloc), hl     ; save malloc start 
a154			 
a154			;    db   1     ; user defined word  
a154 3e 01				ld a, WORD_SYS_UWORD  
a156 77					ld (hl), a 
a157				 
a157 23				inc hl    
a158			;    dw   sysdict 
a158 11 a2 9f			ld de, sysdict       ; continue on with the scan to the system dict 
a15b 73				ld (hl), e 
a15c 23				inc hl 
a15d 72				ld (hl), d 
a15e 23				inc hl 
a15f			 
a15f			 
a15f			;    Setup dict word 
a15f			 
a15f 23				inc hl 
a160 22 fa e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a163			 
a163				; 1. get length of dict word 
a163			 
a163			 
a163 2a 03 e6			ld hl, (os_tok_ptr) 
a166 23				inc hl 
a167 23				inc hl    ; position to start of dict word 
a168 3e 00			ld a, 0 
a16a cd d3 90			call strlent 
a16d			 
a16d			 
a16d 23				inc hl    ; to include null??? 
a16e			 
a16e				; write length of dict word 
a16e			 
a16e ed 5b fa e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a172 1b				dec de 
a173 eb				ex de, hl 
a174 73				ld (hl), e 
a175 eb				ex de, hl 
a176			 
a176				 
a176			 
a176				; copy  
a176 4d				ld c, l 
a177 06 00			ld b, 0 
a179 ed 5b fa e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a17d 2a 03 e6			ld hl, (os_tok_ptr) 
a180 23				inc hl 
a181 23				inc hl    ; position to start of dict word 
a182				 
a182			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a182				 
a182				; TODO need to convert word to upper case 
a182			 
a182			ucasetok:	 
a182 7e				ld a,(hl) 
a183 cd bf 90			call toUpper 
a186 77				ld (hl),a 
a187 ed a0			ldi 
a189 f2 82 a1		 	jp p, ucasetok 
a18c			 
a18c			 
a18c			 
a18c				; de now points to start of where the word body code should be placed 
a18c ed 53 fa e2		ld (os_new_work_ptr), de 
a190				; hl now points to the words to throw at forthexec which needs to be copied 
a190 22 f8 e2			ld (os_new_src_ptr), hl 
a193			 
a193				; TODO add 'call to forthexec' 
a193			 
a193			if DEBUG_FORTH_UWORD 
a193 c5				push bc 
a194 ed 4b 00 e3		ld bc, (os_new_malloc) 
a198						DMARK ":0x" 
a198 f5				push af  
a199 3a ad a1			ld a, (.dmark)  
a19c 32 71 ee			ld (debug_mark),a  
a19f 3a ae a1			ld a, (.dmark+1)  
a1a2 32 72 ee			ld (debug_mark+1),a  
a1a5 3a af a1			ld a, (.dmark+2)  
a1a8 32 73 ee			ld (debug_mark+2),a  
a1ab 18 03			jr .pastdmark  
a1ad ..			.dmark: db ":0x"  
a1b0 f1			.pastdmark: pop af  
a1b1			endm  
# End of macro DMARK
a1b1				CALLMONITOR 
a1b1 cd 6b 94			call break_point_state  
a1b4				endm  
# End of macro CALLMONITOR
a1b4 c1				pop bc 
a1b5			endif 
a1b5			 
a1b5			 
a1b5				; create word preamble which should be: 
a1b5			 
a1b5			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a1b5			 
a1b5				;    ld hl, <word code> 
a1b5				;    jp user_exec 
a1b5			        ;    <word code bytes> 
a1b5			 
a1b5			 
a1b5			;	inc de     ; TODO ??? or are we already past the word's null 
a1b5 eb				ex de, hl 
a1b6			 
a1b6 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a1b8			 
a1b8 23				inc hl 
a1b9 22 f4 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a1bc 23				inc hl 
a1bd			 
a1bd 23				inc hl 
a1be 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a1c0			 
a1c0 01 df c5			ld bc, user_exec 
a1c3 23				inc hl 
a1c4 71				ld (hl), c     ; poke address of user_exec 
a1c5 23				inc hl 
a1c6 70				ld (hl), b     
a1c7			 ; 
a1c7			;	inc hl 
a1c7			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1c7			; 
a1c7			; 
a1c7			;	ld bc, macro_forth_rsp_next 
a1c7			;	inc hl 
a1c7			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1c7			;	inc hl 
a1c7			;	ld (hl), b     
a1c7			 ; 
a1c7			;	inc hl 
a1c7			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1c7			; 
a1c7			; 
a1c7			;	inc hl 
a1c7			;	ld bc, forthexec 
a1c7			;	ld (hl), c     ; poke address of forthexec 
a1c7			;	inc hl 
a1c7			;	ld (hl), b      
a1c7			; 
a1c7			;	inc hl 
a1c7			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1c7			; 
a1c7			;	ld bc, user_dict_next 
a1c7			;	inc hl 
a1c7			;	ld (hl), c     ; poke address of forthexec 
a1c7			;	inc hl 
a1c7			;	ld (hl), b      
a1c7			 
a1c7				; hl is now where we need to copy the word byte data to save this 
a1c7			 
a1c7 23				inc hl 
a1c8 22 f6 e2			ld (os_new_exec), hl 
a1cb				 
a1cb				; copy definition 
a1cb			 
a1cb eb				ex de, hl 
a1cc			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a1cc			;	inc de    ; skip the PC for this parse 
a1cc 3a fe e2			ld a, (os_new_parse_len) 
a1cf 4f				ld c, a 
a1d0 06 00			ld b, 0 
a1d2 ed b0			ldir		 ; copy defintion 
a1d4			 
a1d4			 
a1d4				; poke the address of where the new word bytes live for forthexec 
a1d4			 
a1d4 2a f4 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a1d7			 
a1d7 ed 5b f6 e2		ld de, (os_new_exec)      
a1db				 
a1db 73				ld (hl), e 
a1dc 23				inc hl 
a1dd 72				ld (hl), d 
a1de			 
a1de					; TODO copy last user dict word next link to this word 
a1de					; TODO update last user dict word to point to this word 
a1de			; 
a1de			; hl f923 de 812a ; bc 811a 
a1de			 
a1de			if DEBUG_FORTH_UWORD 
a1de c5				push bc 
a1df ed 4b 00 e3		ld bc, (os_new_malloc) 
a1e3						DMARK ":0A" 
a1e3 f5				push af  
a1e4 3a f8 a1			ld a, (.dmark)  
a1e7 32 71 ee			ld (debug_mark),a  
a1ea 3a f9 a1			ld a, (.dmark+1)  
a1ed 32 72 ee			ld (debug_mark+1),a  
a1f0 3a fa a1			ld a, (.dmark+2)  
a1f3 32 73 ee			ld (debug_mark+2),a  
a1f6 18 03			jr .pastdmark  
a1f8 ..			.dmark: db ":0A"  
a1fb f1			.pastdmark: pop af  
a1fc			endm  
# End of macro DMARK
a1fc				CALLMONITOR 
a1fc cd 6b 94			call break_point_state  
a1ff				endm  
# End of macro CALLMONITOR
a1ff c1				pop bc 
a200			endif 
a200			if DEBUG_FORTH_UWORD 
a200 c5				push bc 
a201 ed 4b 00 e3		ld bc, (os_new_malloc) 
a205 03				inc bc 
a206 03				inc bc 
a207 03				inc bc 
a208 03				inc bc 
a209 03				inc bc 
a20a 03				inc bc 
a20b 03				inc bc 
a20c 03				inc bc 
a20d			 
a20d						DMARK ":0B" 
a20d f5				push af  
a20e 3a 22 a2			ld a, (.dmark)  
a211 32 71 ee			ld (debug_mark),a  
a214 3a 23 a2			ld a, (.dmark+1)  
a217 32 72 ee			ld (debug_mark+1),a  
a21a 3a 24 a2			ld a, (.dmark+2)  
a21d 32 73 ee			ld (debug_mark+2),a  
a220 18 03			jr .pastdmark  
a222 ..			.dmark: db ":0B"  
a225 f1			.pastdmark: pop af  
a226			endm  
# End of macro DMARK
a226				CALLMONITOR 
a226 cd 6b 94			call break_point_state  
a229				endm  
# End of macro CALLMONITOR
a229 c1				pop bc 
a22a			endif 
a22a			 
a22a			; update word dict linked list for new word 
a22a			 
a22a			 
a22a 2a ff e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a22d 23			inc hl     ; move to next work linked list ptr 
a22e			 
a22e ed 5b 00 e3	ld de, (os_new_malloc)		 ; new next word 
a232 73			ld (hl), e 
a233 23			inc hl 
a234 72			ld (hl), d 
a235			 
a235			if DEBUG_FORTH_UWORD 
a235 ed 4b ff e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a239			endif 
a239			 
a239 ed 53 ff e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a23d			 
a23d			 
a23d			if DEBUG_FORTH_UWORD 
a23d						DMARK ":0+" 
a23d f5				push af  
a23e 3a 52 a2			ld a, (.dmark)  
a241 32 71 ee			ld (debug_mark),a  
a244 3a 53 a2			ld a, (.dmark+1)  
a247 32 72 ee			ld (debug_mark+1),a  
a24a 3a 54 a2			ld a, (.dmark+2)  
a24d 32 73 ee			ld (debug_mark+2),a  
a250 18 03			jr .pastdmark  
a252 ..			.dmark: db ":0+"  
a255 f1			.pastdmark: pop af  
a256			endm  
# End of macro DMARK
a256				CALLMONITOR 
a256 cd 6b 94			call break_point_state  
a259				endm  
# End of macro CALLMONITOR
a259			endif 
a259			 
a259				STACKFRAMECHK OFF $8efe $989f 
a259				if DEBUG_STACK_IMB 
a259					if OFF 
a259						exx 
a259						ld hl, $989f 
a259						pop de   ; $989f 
a259						call cmp16 
a259						jr nz, .spnosame 
a259						ld hl, $8efe 
a259						pop de   ; $8efe 
a259						call cmp16 
a259						jr z, .spfrsame 
a259						.spnosame: call showsperror 
a259						.spfrsame: nop 
a259						exx 
a259					endif 
a259				endif 
a259			endm 
# End of macro STACKFRAMECHK
a259			 
a259 c9			ret    ; dont process any remaining parser tokens as they form new word 
a25a			 
a25a			 
a25a			 
a25a			 
a25a			;		NEXT 
a25a			.SCOLN: 
a25a			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a25a 06				db OPCODE_SCOLN 
a25b a6 a2			dw .DROP 
a25d 02				db 2 
a25e .. 00			db ";",0           
a260			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a260					if DEBUG_FORTH_WORDS_KEY 
a260						DMARK "SCN" 
a260 f5				push af  
a261 3a 75 a2			ld a, (.dmark)  
a264 32 71 ee			ld (debug_mark),a  
a267 3a 76 a2			ld a, (.dmark+1)  
a26a 32 72 ee			ld (debug_mark+1),a  
a26d 3a 77 a2			ld a, (.dmark+2)  
a270 32 73 ee			ld (debug_mark+2),a  
a273 18 03			jr .pastdmark  
a275 ..			.dmark: db "SCN"  
a278 f1			.pastdmark: pop af  
a279			endm  
# End of macro DMARK
a279						CALLMONITOR 
a279 cd 6b 94			call break_point_state  
a27c				endm  
# End of macro CALLMONITOR
a27c					endif 
a27c					FORTH_RSP_TOS 
a27c cd 9a 9a			call macro_forth_rsp_tos 
a27f				endm 
# End of macro FORTH_RSP_TOS
a27f e5					push hl 
a280					FORTH_RSP_POP 
a280 cd a4 9a			call macro_forth_rsp_pop 
a283				endm 
# End of macro FORTH_RSP_POP
a283 e1					pop hl 
a284			;		ex de,hl 
a284 22 03 e6				ld (os_tok_ptr),hl 
a287			 
a287			if DEBUG_FORTH_UWORD 
a287						DMARK "SCL" 
a287 f5				push af  
a288 3a 9c a2			ld a, (.dmark)  
a28b 32 71 ee			ld (debug_mark),a  
a28e 3a 9d a2			ld a, (.dmark+1)  
a291 32 72 ee			ld (debug_mark+1),a  
a294 3a 9e a2			ld a, (.dmark+2)  
a297 32 73 ee			ld (debug_mark+2),a  
a29a 18 03			jr .pastdmark  
a29c ..			.dmark: db "SCL"  
a29f f1			.pastdmark: pop af  
a2a0			endm  
# End of macro DMARK
a2a0				CALLMONITOR 
a2a0 cd 6b 94			call break_point_state  
a2a3				endm  
# End of macro CALLMONITOR
a2a3			endif 
a2a3					NEXTW 
a2a3 c3 4a 9e			jp macro_next 
a2a6				endm 
# End of macro NEXTW
a2a6			 
a2a6			.DROP: 
a2a6				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a2a6 1b				db WORD_SYS_CORE+OPCODE_DROP             
a2a7 d1 a2			dw .DUP2            
a2a9 05				db 4 + 1 
a2aa .. 00			db "DROP",0              
a2af				endm 
# End of macro CWHEAD
a2af			; | DROP ( w -- )   drop the TOS item   | DONE 
a2af					if DEBUG_FORTH_WORDS_KEY 
a2af						DMARK "DRP" 
a2af f5				push af  
a2b0 3a c4 a2			ld a, (.dmark)  
a2b3 32 71 ee			ld (debug_mark),a  
a2b6 3a c5 a2			ld a, (.dmark+1)  
a2b9 32 72 ee			ld (debug_mark+1),a  
a2bc 3a c6 a2			ld a, (.dmark+2)  
a2bf 32 73 ee			ld (debug_mark+2),a  
a2c2 18 03			jr .pastdmark  
a2c4 ..			.dmark: db "DRP"  
a2c7 f1			.pastdmark: pop af  
a2c8			endm  
# End of macro DMARK
a2c8						CALLMONITOR 
a2c8 cd 6b 94			call break_point_state  
a2cb				endm  
# End of macro CALLMONITOR
a2cb					endif 
a2cb					FORTH_DSP_POP 
a2cb cd 8b 9d			call macro_forth_dsp_pop 
a2ce				endm 
# End of macro FORTH_DSP_POP
a2ce					NEXTW 
a2ce c3 4a 9e			jp macro_next 
a2d1				endm 
# End of macro NEXTW
a2d1			.DUP2: 
a2d1				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a2d1 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a2d2 16 a3			dw .DROP2            
a2d4 05				db 4 + 1 
a2d5 .. 00			db "2DUP",0              
a2da				endm 
# End of macro CWHEAD
a2da			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a2da					if DEBUG_FORTH_WORDS_KEY 
a2da						DMARK "2DU" 
a2da f5				push af  
a2db 3a ef a2			ld a, (.dmark)  
a2de 32 71 ee			ld (debug_mark),a  
a2e1 3a f0 a2			ld a, (.dmark+1)  
a2e4 32 72 ee			ld (debug_mark+1),a  
a2e7 3a f1 a2			ld a, (.dmark+2)  
a2ea 32 73 ee			ld (debug_mark+2),a  
a2ed 18 03			jr .pastdmark  
a2ef ..			.dmark: db "2DU"  
a2f2 f1			.pastdmark: pop af  
a2f3			endm  
# End of macro DMARK
a2f3						CALLMONITOR 
a2f3 cd 6b 94			call break_point_state  
a2f6				endm  
# End of macro CALLMONITOR
a2f6					endif 
a2f6					FORTH_DSP_VALUEHL 
a2f6 cd d3 9c			call macro_dsp_valuehl 
a2f9				endm 
# End of macro FORTH_DSP_VALUEHL
a2f9 e5					push hl      ; 2 
a2fa			 
a2fa					FORTH_DSP_POP 
a2fa cd 8b 9d			call macro_forth_dsp_pop 
a2fd				endm 
# End of macro FORTH_DSP_POP
a2fd					 
a2fd					FORTH_DSP_VALUEHL 
a2fd cd d3 9c			call macro_dsp_valuehl 
a300				endm 
# End of macro FORTH_DSP_VALUEHL
a300			;		push hl      ; 1 
a300			 
a300					FORTH_DSP_POP 
a300 cd 8b 9d			call macro_forth_dsp_pop 
a303				endm 
# End of macro FORTH_DSP_POP
a303			 
a303			;		pop hl       ; 1 
a303 d1					pop de       ; 2 
a304			 
a304 cd dc 9a				call forth_push_numhl 
a307 eb					ex de, hl 
a308 cd dc 9a				call forth_push_numhl 
a30b			 
a30b					 
a30b eb					ex de, hl 
a30c			 
a30c cd dc 9a				call forth_push_numhl 
a30f eb					ex de, hl 
a310 cd dc 9a				call forth_push_numhl 
a313			 
a313			 
a313					NEXTW 
a313 c3 4a 9e			jp macro_next 
a316				endm 
# End of macro NEXTW
a316			.DROP2: 
a316				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a316 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a317 45 a3			dw .SWAP2            
a319 06				db 5 + 1 
a31a .. 00			db "2DROP",0              
a320				endm 
# End of macro CWHEAD
a320			; | 2DROP ( w w -- )    Double drop | DONE 
a320					if DEBUG_FORTH_WORDS_KEY 
a320						DMARK "2DR" 
a320 f5				push af  
a321 3a 35 a3			ld a, (.dmark)  
a324 32 71 ee			ld (debug_mark),a  
a327 3a 36 a3			ld a, (.dmark+1)  
a32a 32 72 ee			ld (debug_mark+1),a  
a32d 3a 37 a3			ld a, (.dmark+2)  
a330 32 73 ee			ld (debug_mark+2),a  
a333 18 03			jr .pastdmark  
a335 ..			.dmark: db "2DR"  
a338 f1			.pastdmark: pop af  
a339			endm  
# End of macro DMARK
a339						CALLMONITOR 
a339 cd 6b 94			call break_point_state  
a33c				endm  
# End of macro CALLMONITOR
a33c					endif 
a33c					FORTH_DSP_POP 
a33c cd 8b 9d			call macro_forth_dsp_pop 
a33f				endm 
# End of macro FORTH_DSP_POP
a33f					FORTH_DSP_POP 
a33f cd 8b 9d			call macro_forth_dsp_pop 
a342				endm 
# End of macro FORTH_DSP_POP
a342					NEXTW 
a342 c3 4a 9e			jp macro_next 
a345				endm 
# End of macro NEXTW
a345			.SWAP2: 
a345				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a345 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a346 6e a3			dw .AT            
a348 06				db 5 + 1 
a349 .. 00			db "2SWAP",0              
a34f				endm 
# End of macro CWHEAD
a34f			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a34f					if DEBUG_FORTH_WORDS_KEY 
a34f						DMARK "2SW" 
a34f f5				push af  
a350 3a 64 a3			ld a, (.dmark)  
a353 32 71 ee			ld (debug_mark),a  
a356 3a 65 a3			ld a, (.dmark+1)  
a359 32 72 ee			ld (debug_mark+1),a  
a35c 3a 66 a3			ld a, (.dmark+2)  
a35f 32 73 ee			ld (debug_mark+2),a  
a362 18 03			jr .pastdmark  
a364 ..			.dmark: db "2SW"  
a367 f1			.pastdmark: pop af  
a368			endm  
# End of macro DMARK
a368						CALLMONITOR 
a368 cd 6b 94			call break_point_state  
a36b				endm  
# End of macro CALLMONITOR
a36b					endif 
a36b					NEXTW 
a36b c3 4a 9e			jp macro_next 
a36e				endm 
# End of macro NEXTW
a36e			.AT: 
a36e				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a36e 1f				db WORD_SYS_CORE+OPCODE_AT             
a36f a0 a3			dw .CAT            
a371 02				db 1 + 1 
a372 .. 00			db "@",0              
a374				endm 
# End of macro CWHEAD
a374			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a374			 
a374					if DEBUG_FORTH_WORDS_KEY 
a374						DMARK "AT." 
a374 f5				push af  
a375 3a 89 a3			ld a, (.dmark)  
a378 32 71 ee			ld (debug_mark),a  
a37b 3a 8a a3			ld a, (.dmark+1)  
a37e 32 72 ee			ld (debug_mark+1),a  
a381 3a 8b a3			ld a, (.dmark+2)  
a384 32 73 ee			ld (debug_mark+2),a  
a387 18 03			jr .pastdmark  
a389 ..			.dmark: db "AT."  
a38c f1			.pastdmark: pop af  
a38d			endm  
# End of macro DMARK
a38d						CALLMONITOR 
a38d cd 6b 94			call break_point_state  
a390				endm  
# End of macro CALLMONITOR
a390					endif 
a390			.getbyteat:	 
a390					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a390 cd d3 9c			call macro_dsp_valuehl 
a393				endm 
# End of macro FORTH_DSP_VALUEHL
a393					 
a393			;		push hl 
a393				 
a393					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a393 cd 8b 9d			call macro_forth_dsp_pop 
a396				endm 
# End of macro FORTH_DSP_POP
a396			 
a396			;		pop hl 
a396			 
a396 7e					ld a, (hl) 
a397			 
a397 6f					ld l, a 
a398 26 00				ld h, 0 
a39a cd dc 9a				call forth_push_numhl 
a39d			 
a39d					NEXTW 
a39d c3 4a 9e			jp macro_next 
a3a0				endm 
# End of macro NEXTW
a3a0			.CAT: 
a3a0				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a3a0 20				db WORD_SYS_CORE+OPCODE_CAT             
a3a1 c9 a3			dw .BANG            
a3a3 03				db 2 + 1 
a3a4 .. 00			db "C@",0              
a3a7				endm 
# End of macro CWHEAD
a3a7			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a3a7					if DEBUG_FORTH_WORDS_KEY 
a3a7						DMARK "CAA" 
a3a7 f5				push af  
a3a8 3a bc a3			ld a, (.dmark)  
a3ab 32 71 ee			ld (debug_mark),a  
a3ae 3a bd a3			ld a, (.dmark+1)  
a3b1 32 72 ee			ld (debug_mark+1),a  
a3b4 3a be a3			ld a, (.dmark+2)  
a3b7 32 73 ee			ld (debug_mark+2),a  
a3ba 18 03			jr .pastdmark  
a3bc ..			.dmark: db "CAA"  
a3bf f1			.pastdmark: pop af  
a3c0			endm  
# End of macro DMARK
a3c0						CALLMONITOR 
a3c0 cd 6b 94			call break_point_state  
a3c3				endm  
# End of macro CALLMONITOR
a3c3					endif 
a3c3 c3 90 a3				jp .getbyteat 
a3c6					NEXTW 
a3c6 c3 4a 9e			jp macro_next 
a3c9				endm 
# End of macro NEXTW
a3c9			.BANG: 
a3c9				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a3c9 21				db WORD_SYS_CORE+OPCODE_BANG             
a3ca ff a3			dw .CBANG            
a3cc 02				db 1 + 1 
a3cd .. 00			db "!",0              
a3cf				endm 
# End of macro CWHEAD
a3cf			; | ! ( x w -- ) Store x at address w      | DONE 
a3cf					if DEBUG_FORTH_WORDS_KEY 
a3cf						DMARK "BNG" 
a3cf f5				push af  
a3d0 3a e4 a3			ld a, (.dmark)  
a3d3 32 71 ee			ld (debug_mark),a  
a3d6 3a e5 a3			ld a, (.dmark+1)  
a3d9 32 72 ee			ld (debug_mark+1),a  
a3dc 3a e6 a3			ld a, (.dmark+2)  
a3df 32 73 ee			ld (debug_mark+2),a  
a3e2 18 03			jr .pastdmark  
a3e4 ..			.dmark: db "BNG"  
a3e7 f1			.pastdmark: pop af  
a3e8			endm  
# End of macro DMARK
a3e8						CALLMONITOR 
a3e8 cd 6b 94			call break_point_state  
a3eb				endm  
# End of macro CALLMONITOR
a3eb					endif 
a3eb			 
a3eb			.storebyteat:		 
a3eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3eb cd d3 9c			call macro_dsp_valuehl 
a3ee				endm 
# End of macro FORTH_DSP_VALUEHL
a3ee					 
a3ee e5					push hl 
a3ef				 
a3ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3ef cd 8b 9d			call macro_forth_dsp_pop 
a3f2				endm 
# End of macro FORTH_DSP_POP
a3f2			 
a3f2					; get byte to poke 
a3f2			 
a3f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3f2 cd d3 9c			call macro_dsp_valuehl 
a3f5				endm 
# End of macro FORTH_DSP_VALUEHL
a3f5 e5					push hl 
a3f6			 
a3f6			 
a3f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3f6 cd 8b 9d			call macro_forth_dsp_pop 
a3f9				endm 
# End of macro FORTH_DSP_POP
a3f9			 
a3f9			 
a3f9 d1					pop de 
a3fa e1					pop hl 
a3fb			 
a3fb 73					ld (hl),e 
a3fc			 
a3fc			 
a3fc					NEXTW 
a3fc c3 4a 9e			jp macro_next 
a3ff				endm 
# End of macro NEXTW
a3ff			.CBANG: 
a3ff				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a3ff 22				db WORD_SYS_CORE+OPCODE_CBANG             
a400 28 a4			dw .SCALL            
a402 03				db 2 + 1 
a403 .. 00			db "C!",0              
a406				endm 
# End of macro CWHEAD
a406			; | C!  ( x w -- ) Store x at address w  | DONE 
a406					if DEBUG_FORTH_WORDS_KEY 
a406						DMARK "CBA" 
a406 f5				push af  
a407 3a 1b a4			ld a, (.dmark)  
a40a 32 71 ee			ld (debug_mark),a  
a40d 3a 1c a4			ld a, (.dmark+1)  
a410 32 72 ee			ld (debug_mark+1),a  
a413 3a 1d a4			ld a, (.dmark+2)  
a416 32 73 ee			ld (debug_mark+2),a  
a419 18 03			jr .pastdmark  
a41b ..			.dmark: db "CBA"  
a41e f1			.pastdmark: pop af  
a41f			endm  
# End of macro DMARK
a41f						CALLMONITOR 
a41f cd 6b 94			call break_point_state  
a422				endm  
# End of macro CALLMONITOR
a422					endif 
a422 c3 eb a3				jp .storebyteat 
a425					NEXTW 
a425 c3 4a 9e			jp macro_next 
a428				endm 
# End of macro NEXTW
a428			.SCALL: 
a428				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a428 23				db WORD_SYS_CORE+OPCODE_SCALL             
a429 5c a4			dw .DEPTH            
a42b 05				db 4 + 1 
a42c .. 00			db "CALL",0              
a431				endm 
# End of macro CWHEAD
a431			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a431					if DEBUG_FORTH_WORDS_KEY 
a431						DMARK "CLL" 
a431 f5				push af  
a432 3a 46 a4			ld a, (.dmark)  
a435 32 71 ee			ld (debug_mark),a  
a438 3a 47 a4			ld a, (.dmark+1)  
a43b 32 72 ee			ld (debug_mark+1),a  
a43e 3a 48 a4			ld a, (.dmark+2)  
a441 32 73 ee			ld (debug_mark+2),a  
a444 18 03			jr .pastdmark  
a446 ..			.dmark: db "CLL"  
a449 f1			.pastdmark: pop af  
a44a			endm  
# End of macro DMARK
a44a						CALLMONITOR 
a44a cd 6b 94			call break_point_state  
a44d				endm  
# End of macro CALLMONITOR
a44d					endif 
a44d			 
a44d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a44d cd d3 9c			call macro_dsp_valuehl 
a450				endm 
# End of macro FORTH_DSP_VALUEHL
a450			 
a450			;		push hl 
a450			 
a450					; destroy value TOS 
a450			 
a450					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a450 cd 8b 9d			call macro_forth_dsp_pop 
a453				endm 
# End of macro FORTH_DSP_POP
a453			 
a453						 
a453			;		pop hl 
a453			 
a453					; how to do a call with hl???? save SP? 
a453 cd ee 9d				call forth_call_hl 
a456			 
a456			 
a456					; TODO push value back onto stack for another op etc 
a456			 
a456 cd dc 9a				call forth_push_numhl 
a459					NEXTW 
a459 c3 4a 9e			jp macro_next 
a45c				endm 
# End of macro NEXTW
a45c			.DEPTH: 
a45c				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a45c 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a45d 99 a4			dw .OVER            
a45f 06				db 5 + 1 
a460 .. 00			db "DEPTH",0              
a466				endm 
# End of macro CWHEAD
a466			; | DEPTH ( -- u ) Push count of stack | DONE 
a466					; take current TOS and remove from base value div by two to get count 
a466					if DEBUG_FORTH_WORDS_KEY 
a466						DMARK "DEP" 
a466 f5				push af  
a467 3a 7b a4			ld a, (.dmark)  
a46a 32 71 ee			ld (debug_mark),a  
a46d 3a 7c a4			ld a, (.dmark+1)  
a470 32 72 ee			ld (debug_mark+1),a  
a473 3a 7d a4			ld a, (.dmark+2)  
a476 32 73 ee			ld (debug_mark+2),a  
a479 18 03			jr .pastdmark  
a47b ..			.dmark: db "DEP"  
a47e f1			.pastdmark: pop af  
a47f			endm  
# End of macro DMARK
a47f						CALLMONITOR 
a47f cd 6b 94			call break_point_state  
a482				endm  
# End of macro CALLMONITOR
a482					endif 
a482			 
a482			 
a482 2a 2f ea			ld hl, (cli_data_sp) 
a485 11 69 e8			ld de, cli_data_stack 
a488 ed 52			sbc hl,de 
a48a				 
a48a				; div by size of stack item 
a48a			 
a48a 5d				ld e,l 
a48b 0e 03			ld c, 3 
a48d cd fa 8b			call Div8 
a490			 
a490 6f				ld l,a 
a491 26 00			ld h,0 
a493			 
a493				;srl h 
a493				;rr l 
a493			 
a493 cd dc 9a				call forth_push_numhl 
a496					NEXTW 
a496 c3 4a 9e			jp macro_next 
a499				endm 
# End of macro NEXTW
a499			.OVER: 
a499				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a499 42				db WORD_SYS_CORE+46             
a49a e0 a4			dw .PAUSE            
a49c 05				db 4 + 1 
a49d .. 00			db "OVER",0              
a4a2				endm 
# End of macro CWHEAD
a4a2			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a4a2					if DEBUG_FORTH_WORDS_KEY 
a4a2						DMARK "OVR" 
a4a2 f5				push af  
a4a3 3a b7 a4			ld a, (.dmark)  
a4a6 32 71 ee			ld (debug_mark),a  
a4a9 3a b8 a4			ld a, (.dmark+1)  
a4ac 32 72 ee			ld (debug_mark+1),a  
a4af 3a b9 a4			ld a, (.dmark+2)  
a4b2 32 73 ee			ld (debug_mark+2),a  
a4b5 18 03			jr .pastdmark  
a4b7 ..			.dmark: db "OVR"  
a4ba f1			.pastdmark: pop af  
a4bb			endm  
# End of macro DMARK
a4bb						CALLMONITOR 
a4bb cd 6b 94			call break_point_state  
a4be				endm  
# End of macro CALLMONITOR
a4be					endif 
a4be			 
a4be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4be cd d3 9c			call macro_dsp_valuehl 
a4c1				endm 
# End of macro FORTH_DSP_VALUEHL
a4c1 e5					push hl    ; n2 
a4c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4c2 cd 8b 9d			call macro_forth_dsp_pop 
a4c5				endm 
# End of macro FORTH_DSP_POP
a4c5			 
a4c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4c5 cd d3 9c			call macro_dsp_valuehl 
a4c8				endm 
# End of macro FORTH_DSP_VALUEHL
a4c8 e5					push hl    ; n1 
a4c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4c9 cd 8b 9d			call macro_forth_dsp_pop 
a4cc				endm 
# End of macro FORTH_DSP_POP
a4cc			 
a4cc d1					pop de     ; n1 
a4cd e1					pop hl     ; n2 
a4ce			 
a4ce d5					push de 
a4cf e5					push hl 
a4d0 d5					push de 
a4d1			 
a4d1					; push back  
a4d1			 
a4d1 e1					pop hl 
a4d2 cd dc 9a				call forth_push_numhl 
a4d5 e1					pop hl 
a4d6 cd dc 9a				call forth_push_numhl 
a4d9 e1					pop hl 
a4da cd dc 9a				call forth_push_numhl 
a4dd					NEXTW 
a4dd c3 4a 9e			jp macro_next 
a4e0				endm 
# End of macro NEXTW
a4e0			 
a4e0			.PAUSE: 
a4e0				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a4e0 43				db WORD_SYS_CORE+47             
a4e1 15 a5			dw .PAUSES            
a4e3 08				db 7 + 1 
a4e4 .. 00			db "PAUSEMS",0              
a4ec				endm 
# End of macro CWHEAD
a4ec			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a4ec					if DEBUG_FORTH_WORDS_KEY 
a4ec						DMARK "PMS" 
a4ec f5				push af  
a4ed 3a 01 a5			ld a, (.dmark)  
a4f0 32 71 ee			ld (debug_mark),a  
a4f3 3a 02 a5			ld a, (.dmark+1)  
a4f6 32 72 ee			ld (debug_mark+1),a  
a4f9 3a 03 a5			ld a, (.dmark+2)  
a4fc 32 73 ee			ld (debug_mark+2),a  
a4ff 18 03			jr .pastdmark  
a501 ..			.dmark: db "PMS"  
a504 f1			.pastdmark: pop af  
a505			endm  
# End of macro DMARK
a505						CALLMONITOR 
a505 cd 6b 94			call break_point_state  
a508				endm  
# End of macro CALLMONITOR
a508					endif 
a508					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a508 cd d3 9c			call macro_dsp_valuehl 
a50b				endm 
# End of macro FORTH_DSP_VALUEHL
a50b			;		push hl    ; n2 
a50b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a50b cd 8b 9d			call macro_forth_dsp_pop 
a50e				endm 
# End of macro FORTH_DSP_POP
a50e			;		pop hl 
a50e			 
a50e 7d					ld a, l 
a50f cd 9f 89				call aDelayInMS 
a512				       NEXTW 
a512 c3 4a 9e			jp macro_next 
a515				endm 
# End of macro NEXTW
a515			.PAUSES:  
a515				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a515 44				db WORD_SYS_CORE+48             
a516 84 a5			dw .ROT            
a518 06				db 5 + 1 
a519 .. 00			db "PAUSE",0              
a51f				endm 
# End of macro CWHEAD
a51f			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a51f					if DEBUG_FORTH_WORDS_KEY 
a51f						DMARK "PAU" 
a51f f5				push af  
a520 3a 34 a5			ld a, (.dmark)  
a523 32 71 ee			ld (debug_mark),a  
a526 3a 35 a5			ld a, (.dmark+1)  
a529 32 72 ee			ld (debug_mark+1),a  
a52c 3a 36 a5			ld a, (.dmark+2)  
a52f 32 73 ee			ld (debug_mark+2),a  
a532 18 03			jr .pastdmark  
a534 ..			.dmark: db "PAU"  
a537 f1			.pastdmark: pop af  
a538			endm  
# End of macro DMARK
a538						CALLMONITOR 
a538 cd 6b 94			call break_point_state  
a53b				endm  
# End of macro CALLMONITOR
a53b					endif 
a53b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a53b cd d3 9c			call macro_dsp_valuehl 
a53e				endm 
# End of macro FORTH_DSP_VALUEHL
a53e			;		push hl    ; n2 
a53e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a53e cd 8b 9d			call macro_forth_dsp_pop 
a541				endm 
# End of macro FORTH_DSP_POP
a541			;		pop hl 
a541 45					ld b, l 
a542					if DEBUG_FORTH_WORDS 
a542						DMARK "PAU" 
a542 f5				push af  
a543 3a 57 a5			ld a, (.dmark)  
a546 32 71 ee			ld (debug_mark),a  
a549 3a 58 a5			ld a, (.dmark+1)  
a54c 32 72 ee			ld (debug_mark+1),a  
a54f 3a 59 a5			ld a, (.dmark+2)  
a552 32 73 ee			ld (debug_mark+2),a  
a555 18 03			jr .pastdmark  
a557 ..			.dmark: db "PAU"  
a55a f1			.pastdmark: pop af  
a55b			endm  
# End of macro DMARK
a55b						CALLMONITOR 
a55b cd 6b 94			call break_point_state  
a55e				endm  
# End of macro CALLMONITOR
a55e					endif 
a55e c5			.pauses1:	push bc 
a55f cd ba 89				call delay1s 
a562 c1					pop bc 
a563					if DEBUG_FORTH_WORDS 
a563						DMARK "PA1" 
a563 f5				push af  
a564 3a 78 a5			ld a, (.dmark)  
a567 32 71 ee			ld (debug_mark),a  
a56a 3a 79 a5			ld a, (.dmark+1)  
a56d 32 72 ee			ld (debug_mark+1),a  
a570 3a 7a a5			ld a, (.dmark+2)  
a573 32 73 ee			ld (debug_mark+2),a  
a576 18 03			jr .pastdmark  
a578 ..			.dmark: db "PA1"  
a57b f1			.pastdmark: pop af  
a57c			endm  
# End of macro DMARK
a57c						CALLMONITOR 
a57c cd 6b 94			call break_point_state  
a57f				endm  
# End of macro CALLMONITOR
a57f					endif 
a57f 10 dd				djnz .pauses1 
a581			 
a581				       NEXTW 
a581 c3 4a 9e			jp macro_next 
a584				endm 
# End of macro NEXTW
a584			.ROT: 
a584				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a584 45				db WORD_SYS_CORE+49             
a585 d2 a5			dw .UWORDS            
a587 04				db 3 + 1 
a588 .. 00			db "ROT",0              
a58c				endm 
# End of macro CWHEAD
a58c			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a58c					if DEBUG_FORTH_WORDS_KEY 
a58c						DMARK "ROT" 
a58c f5				push af  
a58d 3a a1 a5			ld a, (.dmark)  
a590 32 71 ee			ld (debug_mark),a  
a593 3a a2 a5			ld a, (.dmark+1)  
a596 32 72 ee			ld (debug_mark+1),a  
a599 3a a3 a5			ld a, (.dmark+2)  
a59c 32 73 ee			ld (debug_mark+2),a  
a59f 18 03			jr .pastdmark  
a5a1 ..			.dmark: db "ROT"  
a5a4 f1			.pastdmark: pop af  
a5a5			endm  
# End of macro DMARK
a5a5						CALLMONITOR 
a5a5 cd 6b 94			call break_point_state  
a5a8				endm  
# End of macro CALLMONITOR
a5a8					endif 
a5a8			 
a5a8					FORTH_DSP_VALUEHL 
a5a8 cd d3 9c			call macro_dsp_valuehl 
a5ab				endm 
# End of macro FORTH_DSP_VALUEHL
a5ab e5					push hl    ; u3  
a5ac			 
a5ac					FORTH_DSP_POP 
a5ac cd 8b 9d			call macro_forth_dsp_pop 
a5af				endm 
# End of macro FORTH_DSP_POP
a5af			   
a5af					FORTH_DSP_VALUEHL 
a5af cd d3 9c			call macro_dsp_valuehl 
a5b2				endm 
# End of macro FORTH_DSP_VALUEHL
a5b2 e5					push hl     ; u2 
a5b3			 
a5b3					FORTH_DSP_POP 
a5b3 cd 8b 9d			call macro_forth_dsp_pop 
a5b6				endm 
# End of macro FORTH_DSP_POP
a5b6			 
a5b6					FORTH_DSP_VALUEHL 
a5b6 cd d3 9c			call macro_dsp_valuehl 
a5b9				endm 
# End of macro FORTH_DSP_VALUEHL
a5b9 e5					push hl     ; u1 
a5ba			 
a5ba					FORTH_DSP_POP 
a5ba cd 8b 9d			call macro_forth_dsp_pop 
a5bd				endm 
# End of macro FORTH_DSP_POP
a5bd			 
a5bd c1					pop bc      ; u1 
a5be e1					pop hl      ; u2 
a5bf d1					pop de      ; u3 
a5c0			 
a5c0			 
a5c0 c5					push bc 
a5c1 d5					push de 
a5c2 e5					push hl 
a5c3			 
a5c3			 
a5c3 e1					pop hl 
a5c4 cd dc 9a				call forth_push_numhl 
a5c7			 
a5c7 e1					pop hl 
a5c8 cd dc 9a				call forth_push_numhl 
a5cb			 
a5cb e1					pop hl 
a5cc cd dc 9a				call forth_push_numhl 
a5cf					 
a5cf			 
a5cf			 
a5cf			 
a5cf			 
a5cf			 
a5cf				       NEXTW 
a5cf c3 4a 9e			jp macro_next 
a5d2				endm 
# End of macro NEXTW
a5d2			 
a5d2			.UWORDS: 
a5d2				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a5d2 50				db WORD_SYS_CORE+60             
a5d3 94 a6			dw .BP            
a5d5 07				db 6 + 1 
a5d6 .. 00			db "UWORDS",0              
a5dd				endm 
# End of macro CWHEAD
a5dd			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a5dd			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a5dd			; | | Following the count are the individual words. 
a5dd			; | | 
a5dd			; | | e.g. UWORDS 
a5dd			; | | BOX DIRLIST 2 
a5dd			; | |  
a5dd			; | | Can be used to save the words to storage via: 
a5dd			; | | UWORDS $01 DO $01 APPEND LOOP 
a5dd				if DEBUG_FORTH_WORDS_KEY 
a5dd					DMARK "UWR" 
a5dd f5				push af  
a5de 3a f2 a5			ld a, (.dmark)  
a5e1 32 71 ee			ld (debug_mark),a  
a5e4 3a f3 a5			ld a, (.dmark+1)  
a5e7 32 72 ee			ld (debug_mark+1),a  
a5ea 3a f4 a5			ld a, (.dmark+2)  
a5ed 32 73 ee			ld (debug_mark+2),a  
a5f0 18 03			jr .pastdmark  
a5f2 ..			.dmark: db "UWR"  
a5f5 f1			.pastdmark: pop af  
a5f6			endm  
# End of macro DMARK
a5f6					CALLMONITOR 
a5f6 cd 6b 94			call break_point_state  
a5f9				endm  
# End of macro CALLMONITOR
a5f9				endif 
a5f9 21 53 da				ld hl, baseram 
a5fc					;ld hl, baseusermem 
a5fc 01 00 00				ld bc, 0    ; start a counter 
a5ff			 
a5ff				; skip dict stub 
a5ff			 
a5ff cd 9b 9f				call forth_tok_next 
a602			 
a602			 
a602			; while we have words to look for 
a602			 
a602 7e			.douscan:	ld a, (hl)      
a603				if DEBUG_FORTH_WORDS 
a603					DMARK "UWs" 
a603 f5				push af  
a604 3a 18 a6			ld a, (.dmark)  
a607 32 71 ee			ld (debug_mark),a  
a60a 3a 19 a6			ld a, (.dmark+1)  
a60d 32 72 ee			ld (debug_mark+1),a  
a610 3a 1a a6			ld a, (.dmark+2)  
a613 32 73 ee			ld (debug_mark+2),a  
a616 18 03			jr .pastdmark  
a618 ..			.dmark: db "UWs"  
a61b f1			.pastdmark: pop af  
a61c			endm  
# End of macro DMARK
a61c					CALLMONITOR 
a61c cd 6b 94			call break_point_state  
a61f				endm  
# End of macro CALLMONITOR
a61f				endif 
a61f fe 00				cp WORD_SYS_END 
a621 28 4d				jr z, .udone 
a623 fe 01				cp WORD_SYS_UWORD 
a625 20 44				jr nz, .nuword 
a627			 
a627				if DEBUG_FORTH_WORDS 
a627					DMARK "UWu" 
a627 f5				push af  
a628 3a 3c a6			ld a, (.dmark)  
a62b 32 71 ee			ld (debug_mark),a  
a62e 3a 3d a6			ld a, (.dmark+1)  
a631 32 72 ee			ld (debug_mark+1),a  
a634 3a 3e a6			ld a, (.dmark+2)  
a637 32 73 ee			ld (debug_mark+2),a  
a63a 18 03			jr .pastdmark  
a63c ..			.dmark: db "UWu"  
a63f f1			.pastdmark: pop af  
a640			endm  
# End of macro DMARK
a640					CALLMONITOR 
a640 cd 6b 94			call break_point_state  
a643				endm  
# End of macro CALLMONITOR
a643				endif 
a643					; we have a uword so push its name to the stack 
a643			 
a643 e5				   	push hl  ; save so we can move to next dict block 
a644			 
a644					; skip opcode 
a644 23					inc hl  
a645					; skip next ptr 
a645 23					inc hl  
a646 23					inc hl 
a647					; skip len 
a647 23					inc hl 
a648				if DEBUG_FORTH_WORDS 
a648					DMARK "UWt" 
a648 f5				push af  
a649 3a 5d a6			ld a, (.dmark)  
a64c 32 71 ee			ld (debug_mark),a  
a64f 3a 5e a6			ld a, (.dmark+1)  
a652 32 72 ee			ld (debug_mark+1),a  
a655 3a 5f a6			ld a, (.dmark+2)  
a658 32 73 ee			ld (debug_mark+2),a  
a65b 18 03			jr .pastdmark  
a65d ..			.dmark: db "UWt"  
a660 f1			.pastdmark: pop af  
a661			endm  
# End of macro DMARK
a661					CALLMONITOR 
a661 cd 6b 94			call break_point_state  
a664				endm  
# End of macro CALLMONITOR
a664				endif 
a664 03					inc bc 
a665			 
a665 c5					push bc 
a666 cd 4a 9b				call forth_push_str 
a669 c1					pop bc 
a66a			 
a66a e1					pop hl 	 
a66b			 
a66b cd 9b 9f		.nuword:	call forth_tok_next 
a66e 18 92				jr .douscan  
a670			 
a670			.udone:		 ; push count of uwords found 
a670 c5					push bc 
a671 e1					pop hl 
a672			 
a672				if DEBUG_FORTH_WORDS 
a672					DMARK "UWc" 
a672 f5				push af  
a673 3a 87 a6			ld a, (.dmark)  
a676 32 71 ee			ld (debug_mark),a  
a679 3a 88 a6			ld a, (.dmark+1)  
a67c 32 72 ee			ld (debug_mark+1),a  
a67f 3a 89 a6			ld a, (.dmark+2)  
a682 32 73 ee			ld (debug_mark+2),a  
a685 18 03			jr .pastdmark  
a687 ..			.dmark: db "UWc"  
a68a f1			.pastdmark: pop af  
a68b			endm  
# End of macro DMARK
a68b					CALLMONITOR 
a68b cd 6b 94			call break_point_state  
a68e				endm  
# End of macro CALLMONITOR
a68e				endif 
a68e cd dc 9a				call forth_push_numhl 
a691			 
a691			 
a691				       NEXTW 
a691 c3 4a 9e			jp macro_next 
a694				endm 
# End of macro NEXTW
a694			 
a694			.BP: 
a694				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a694 54				db WORD_SYS_CORE+64             
a695 ca a6			dw .MONITOR            
a697 03				db 2 + 1 
a698 .. 00			db "BP",0              
a69b				endm 
# End of macro CWHEAD
a69b			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a69b			; | | $00 Will enable the break points within specific code paths 
a69b			; | | $01 Will disable break points 
a69b			; | |  
a69b			; | | By default break points are off. Either the above can be used to enable them 
a69b			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a69b			; | | and on release of the pressed key a message will be disaplayed to notify 
a69b			; | | that break points are enabled. Pressing any key will then continue boot process. 
a69b					; get byte count 
a69b					if DEBUG_FORTH_WORDS_KEY 
a69b						DMARK "BP." 
a69b f5				push af  
a69c 3a b0 a6			ld a, (.dmark)  
a69f 32 71 ee			ld (debug_mark),a  
a6a2 3a b1 a6			ld a, (.dmark+1)  
a6a5 32 72 ee			ld (debug_mark+1),a  
a6a8 3a b2 a6			ld a, (.dmark+2)  
a6ab 32 73 ee			ld (debug_mark+2),a  
a6ae 18 03			jr .pastdmark  
a6b0 ..			.dmark: db "BP."  
a6b3 f1			.pastdmark: pop af  
a6b4			endm  
# End of macro DMARK
a6b4						CALLMONITOR 
a6b4 cd 6b 94			call break_point_state  
a6b7				endm  
# End of macro CALLMONITOR
a6b7					endif 
a6b7			 
a6b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6b7 cd d3 9c			call macro_dsp_valuehl 
a6ba				endm 
# End of macro FORTH_DSP_VALUEHL
a6ba			 
a6ba			;		push hl 
a6ba			 
a6ba					; destroy value TOS 
a6ba			 
a6ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6ba cd 8b 9d			call macro_forth_dsp_pop 
a6bd				endm 
# End of macro FORTH_DSP_POP
a6bd			 
a6bd			;		pop hl 
a6bd			 
a6bd 3e 00				ld a,0 
a6bf bd					cp l 
a6c0 28 02				jr z, .bpset 
a6c2 3e 2a				ld a, '*' 
a6c4			 
a6c4 32 f3 e2		.bpset:		ld (os_view_disable), a 
a6c7			 
a6c7			 
a6c7					NEXTW 
a6c7 c3 4a 9e			jp macro_next 
a6ca				endm 
# End of macro NEXTW
a6ca			 
a6ca			 
a6ca			.MONITOR: 
a6ca				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a6ca 55				db WORD_SYS_CORE+65             
a6cb fd a6			dw .MALLOC            
a6cd 08				db 7 + 1 
a6ce .. 00			db "MONITOR",0              
a6d6				endm 
# End of macro CWHEAD
a6d6			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a6d6			; | | At start the current various registers will be displayed with contents. 
a6d6			; | | Top right corner will show the most recent debug marker seen. 
a6d6			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a6d6			; | | and the return stack pointer (RSP). 
a6d6			; | | Pressing: 
a6d6			; | |    1 - Initial screen 
a6d6			; | |    2 - Display a data dump of HL 
a6d6			; | |    3 - Display a data dump of DE 
a6d6			; | |    4 - Display a data dump of BC 
a6d6			; | |    5 - Display a data dump of HL 
a6d6			; | |    6 - Display a data dump of DSP 
a6d6			; | |    7 - Display a data dump of RSP 
a6d6			; | |    8 - Display a data dump of what is at DSP 
a6d6			; | |    9 - Display a data dump of what is at RSP 
a6d6			; | |    0 - Exit monitor and continue running. This will also enable break points 
a6d6			; | |    * - Disable break points 
a6d6			; | |    # - Enter traditional monitor mode 
a6d6			; | | 
a6d6			; | | Monitor Mode 
a6d6			; | | ------------ 
a6d6			; | | A prompt of '>' will be shown for various commands: 
a6d6			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a6d6			; | |    C - Continue display a data dump from the last set address 
a6d6			; | |    M xxxx - Set start of memory edit at address xx 
a6d6			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a6d6			; | |    Q - Return to previous 
a6d6					if DEBUG_FORTH_WORDS_KEY 
a6d6						DMARK "MON" 
a6d6 f5				push af  
a6d7 3a eb a6			ld a, (.dmark)  
a6da 32 71 ee			ld (debug_mark),a  
a6dd 3a ec a6			ld a, (.dmark+1)  
a6e0 32 72 ee			ld (debug_mark+1),a  
a6e3 3a ed a6			ld a, (.dmark+2)  
a6e6 32 73 ee			ld (debug_mark+2),a  
a6e9 18 03			jr .pastdmark  
a6eb ..			.dmark: db "MON"  
a6ee f1			.pastdmark: pop af  
a6ef			endm  
# End of macro DMARK
a6ef						CALLMONITOR 
a6ef cd 6b 94			call break_point_state  
a6f2				endm  
# End of macro CALLMONITOR
a6f2					endif 
a6f2 3e 00				ld a, 0 
a6f4 32 f3 e2				ld (os_view_disable), a 
a6f7			 
a6f7					CALLMONITOR 
a6f7 cd 6b 94			call break_point_state  
a6fa				endm  
# End of macro CALLMONITOR
a6fa			 
a6fa			;	call monitor 
a6fa			 
a6fa					NEXTW 
a6fa c3 4a 9e			jp macro_next 
a6fd				endm 
# End of macro NEXTW
a6fd			 
a6fd			 
a6fd			.MALLOC: 
a6fd				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a6fd 56				db WORD_SYS_CORE+66             
a6fe 26 a7			dw .MALLOC2            
a700 06				db 5 + 1 
a701 .. 00			db "ALLOT",0              
a707				endm 
# End of macro CWHEAD
a707			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a707					if DEBUG_FORTH_WORDS_KEY 
a707						DMARK "ALL" 
a707 f5				push af  
a708 3a 1c a7			ld a, (.dmark)  
a70b 32 71 ee			ld (debug_mark),a  
a70e 3a 1d a7			ld a, (.dmark+1)  
a711 32 72 ee			ld (debug_mark+1),a  
a714 3a 1e a7			ld a, (.dmark+2)  
a717 32 73 ee			ld (debug_mark+2),a  
a71a 18 03			jr .pastdmark  
a71c ..			.dmark: db "ALL"  
a71f f1			.pastdmark: pop af  
a720			endm  
# End of macro DMARK
a720						CALLMONITOR 
a720 cd 6b 94			call break_point_state  
a723				endm  
# End of macro CALLMONITOR
a723					endif 
a723 c3 4d a7				jp .mallocc 
a726			.MALLOC2: 
a726				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a726 56				db WORD_SYS_CORE+66             
a727 64 a7			dw .FREE            
a729 07				db 6 + 1 
a72a .. 00			db "MALLOC",0              
a731				endm 
# End of macro CWHEAD
a731			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a731					; get byte count 
a731					if DEBUG_FORTH_WORDS_KEY 
a731						DMARK "MAL" 
a731 f5				push af  
a732 3a 46 a7			ld a, (.dmark)  
a735 32 71 ee			ld (debug_mark),a  
a738 3a 47 a7			ld a, (.dmark+1)  
a73b 32 72 ee			ld (debug_mark+1),a  
a73e 3a 48 a7			ld a, (.dmark+2)  
a741 32 73 ee			ld (debug_mark+2),a  
a744 18 03			jr .pastdmark  
a746 ..			.dmark: db "MAL"  
a749 f1			.pastdmark: pop af  
a74a			endm  
# End of macro DMARK
a74a						CALLMONITOR 
a74a cd 6b 94			call break_point_state  
a74d				endm  
# End of macro CALLMONITOR
a74d					endif 
a74d			.mallocc: 
a74d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a74d cd d3 9c			call macro_dsp_valuehl 
a750				endm 
# End of macro FORTH_DSP_VALUEHL
a750			 
a750			;		push hl 
a750			 
a750					; destroy value TOS 
a750			 
a750					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a750 cd 8b 9d			call macro_forth_dsp_pop 
a753				endm 
# End of macro FORTH_DSP_POP
a753			 
a753			;		pop hl 
a753 cd 31 91				call malloc 
a756				if DEBUG_FORTH_MALLOC_GUARD 
a756 f5					push af 
a757 cd 93 8c				call ishlzero 
a75a			;		ld a, l 
a75a			;		add h 
a75a			;		cp 0 
a75a f1					pop af 
a75b					 
a75b cc b1 c6				call z,malloc_error 
a75e				endif 
a75e			 
a75e cd dc 9a				call forth_push_numhl 
a761					NEXTW 
a761 c3 4a 9e			jp macro_next 
a764				endm 
# End of macro NEXTW
a764			 
a764			.FREE: 
a764				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a764 57				db WORD_SYS_CORE+67             
a765 95 a7			dw .LIST            
a767 05				db 4 + 1 
a768 .. 00			db "FREE",0              
a76d				endm 
# End of macro CWHEAD
a76d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a76d					if DEBUG_FORTH_WORDS_KEY 
a76d						DMARK "FRE" 
a76d f5				push af  
a76e 3a 82 a7			ld a, (.dmark)  
a771 32 71 ee			ld (debug_mark),a  
a774 3a 83 a7			ld a, (.dmark+1)  
a777 32 72 ee			ld (debug_mark+1),a  
a77a 3a 84 a7			ld a, (.dmark+2)  
a77d 32 73 ee			ld (debug_mark+2),a  
a780 18 03			jr .pastdmark  
a782 ..			.dmark: db "FRE"  
a785 f1			.pastdmark: pop af  
a786			endm  
# End of macro DMARK
a786						CALLMONITOR 
a786 cd 6b 94			call break_point_state  
a789				endm  
# End of macro CALLMONITOR
a789					endif 
a789					; get address 
a789			 
a789					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a789 cd d3 9c			call macro_dsp_valuehl 
a78c				endm 
# End of macro FORTH_DSP_VALUEHL
a78c			 
a78c			;		push hl 
a78c			 
a78c					; destroy value TOS 
a78c			 
a78c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a78c cd 8b 9d			call macro_forth_dsp_pop 
a78f				endm 
# End of macro FORTH_DSP_POP
a78f			 
a78f			;		pop hl 
a78f			if FORTH_ENABLE_MALLOCFREE 
a78f cd fb 91				call free 
a792			endif 
a792					NEXTW 
a792 c3 4a 9e			jp macro_next 
a795				endm 
# End of macro NEXTW
a795			.LIST: 
a795				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a795 5c				db WORD_SYS_CORE+72             
a796 83 a9			dw .FORGET            
a798 05				db 4 + 1 
a799 .. 00			db "LIST",0              
a79e				endm 
# End of macro CWHEAD
a79e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a79e			; | | The quoted word must be in upper case. 
a79e				if DEBUG_FORTH_WORDS_KEY 
a79e					DMARK "LST" 
a79e f5				push af  
a79f 3a b3 a7			ld a, (.dmark)  
a7a2 32 71 ee			ld (debug_mark),a  
a7a5 3a b4 a7			ld a, (.dmark+1)  
a7a8 32 72 ee			ld (debug_mark+1),a  
a7ab 3a b5 a7			ld a, (.dmark+2)  
a7ae 32 73 ee			ld (debug_mark+2),a  
a7b1 18 03			jr .pastdmark  
a7b3 ..			.dmark: db "LST"  
a7b6 f1			.pastdmark: pop af  
a7b7			endm  
# End of macro DMARK
a7b7					CALLMONITOR 
a7b7 cd 6b 94			call break_point_state  
a7ba				endm  
# End of macro CALLMONITOR
a7ba				endif 
a7ba			 
a7ba					FORTH_DSP_VALUEHL 
a7ba cd d3 9c			call macro_dsp_valuehl 
a7bd				endm 
# End of macro FORTH_DSP_VALUEHL
a7bd			 
a7bd e5					push hl 
a7be					FORTH_DSP_POP 
a7be cd 8b 9d			call macro_forth_dsp_pop 
a7c1				endm 
# End of macro FORTH_DSP_POP
a7c1 c1					pop bc 
a7c2			 
a7c2			; Start format of scratch string 
a7c2			 
a7c2 21 02 e3				ld hl, scratch 
a7c5			 
a7c5 3e 3a				ld a, ':' 
a7c7 77					ld (hl),a 
a7c8 23					inc hl 
a7c9 3e 20				ld a, ' ' 
a7cb 77					ld (hl), a 
a7cc			 
a7cc					; Get ptr to the word we need to look up 
a7cc			 
a7cc			;		FORTH_DSP_VALUEHL 
a7cc					;v5 FORTH_DSP_VALUE 
a7cc				; TODO type check 
a7cc			;		inc hl    ; Skip type check  
a7cc			;		push hl 
a7cc			;		ex de, hl    ; put into DE 
a7cc			 
a7cc			 
a7cc 21 53 da				ld hl, baseram 
a7cf					;ld hl, baseusermem 
a7cf			 
a7cf e5			push hl   ; sacreifical push 
a7d0			 
a7d0			.ldouscanm: 
a7d0 e1				pop hl 
a7d1			.ldouscan: 
a7d1				if DEBUG_FORTH_WORDS 
a7d1					DMARK "LSs" 
a7d1 f5				push af  
a7d2 3a e6 a7			ld a, (.dmark)  
a7d5 32 71 ee			ld (debug_mark),a  
a7d8 3a e7 a7			ld a, (.dmark+1)  
a7db 32 72 ee			ld (debug_mark+1),a  
a7de 3a e8 a7			ld a, (.dmark+2)  
a7e1 32 73 ee			ld (debug_mark+2),a  
a7e4 18 03			jr .pastdmark  
a7e6 ..			.dmark: db "LSs"  
a7e9 f1			.pastdmark: pop af  
a7ea			endm  
# End of macro DMARK
a7ea					CALLMONITOR 
a7ea cd 6b 94			call break_point_state  
a7ed				endm  
# End of macro CALLMONITOR
a7ed				endif 
a7ed				; skip dict stub 
a7ed cd 9b 9f				call forth_tok_next 
a7f0			 
a7f0			 
a7f0			; while we have words to look for 
a7f0			 
a7f0 7e				ld a, (hl)      
a7f1				if DEBUG_FORTH_WORDS 
a7f1					DMARK "LSk" 
a7f1 f5				push af  
a7f2 3a 06 a8			ld a, (.dmark)  
a7f5 32 71 ee			ld (debug_mark),a  
a7f8 3a 07 a8			ld a, (.dmark+1)  
a7fb 32 72 ee			ld (debug_mark+1),a  
a7fe 3a 08 a8			ld a, (.dmark+2)  
a801 32 73 ee			ld (debug_mark+2),a  
a804 18 03			jr .pastdmark  
a806 ..			.dmark: db "LSk"  
a809 f1			.pastdmark: pop af  
a80a			endm  
# End of macro DMARK
a80a					CALLMONITOR 
a80a cd 6b 94			call break_point_state  
a80d				endm  
# End of macro CALLMONITOR
a80d				endif 
a80d					;cp WORD_SYS_END 
a80d					;jp z, .lunotfound 
a80d			 
a80d					; if we hit non uwords then gone too far 
a80d fe 01				cp WORD_SYS_UWORD 
a80f c2 3f a9				jp nz, .lunotfound 
a812			 
a812				if DEBUG_FORTH_WORDS 
a812					DMARK "LSu" 
a812 f5				push af  
a813 3a 27 a8			ld a, (.dmark)  
a816 32 71 ee			ld (debug_mark),a  
a819 3a 28 a8			ld a, (.dmark+1)  
a81c 32 72 ee			ld (debug_mark+1),a  
a81f 3a 29 a8			ld a, (.dmark+2)  
a822 32 73 ee			ld (debug_mark+2),a  
a825 18 03			jr .pastdmark  
a827 ..			.dmark: db "LSu"  
a82a f1			.pastdmark: pop af  
a82b			endm  
# End of macro DMARK
a82b					CALLMONITOR 
a82b cd 6b 94			call break_point_state  
a82e				endm  
# End of macro CALLMONITOR
a82e				endif 
a82e			 
a82e					; found a uword but is it the one we want... 
a82e			 
a82e c5					push bc     ; uword to find is on bc 
a82f d1					pop de 
a830			 
a830 e5					push hl  ; to save the ptr 
a831			 
a831					; skip opcode 
a831 23					inc hl  
a832					; skip next ptr 
a832 23					inc hl  
a833 23					inc hl 
a834					; skip len 
a834 23					inc hl 
a835			 
a835				if DEBUG_FORTH_WORDS 
a835					DMARK "LSc" 
a835 f5				push af  
a836 3a 4a a8			ld a, (.dmark)  
a839 32 71 ee			ld (debug_mark),a  
a83c 3a 4b a8			ld a, (.dmark+1)  
a83f 32 72 ee			ld (debug_mark+1),a  
a842 3a 4c a8			ld a, (.dmark+2)  
a845 32 73 ee			ld (debug_mark+2),a  
a848 18 03			jr .pastdmark  
a84a ..			.dmark: db "LSc"  
a84d f1			.pastdmark: pop af  
a84e			endm  
# End of macro DMARK
a84e					CALLMONITOR 
a84e cd 6b 94			call break_point_state  
a851				endm  
# End of macro CALLMONITOR
a851				endif 
a851 cd 00 91				call strcmp 
a854 c2 d0 a7				jp nz, .ldouscanm 
a857				 
a857			 
a857			 
a857					; we have a uword so push its name to the stack 
a857			 
a857			;	   	push hl  ; save so we can move to next dict block 
a857 e1			pop hl 
a858			 
a858				if DEBUG_FORTH_WORDS 
a858					DMARK "LSm" 
a858 f5				push af  
a859 3a 6d a8			ld a, (.dmark)  
a85c 32 71 ee			ld (debug_mark),a  
a85f 3a 6e a8			ld a, (.dmark+1)  
a862 32 72 ee			ld (debug_mark+1),a  
a865 3a 6f a8			ld a, (.dmark+2)  
a868 32 73 ee			ld (debug_mark+2),a  
a86b 18 03			jr .pastdmark  
a86d ..			.dmark: db "LSm"  
a870 f1			.pastdmark: pop af  
a871			endm  
# End of macro DMARK
a871					CALLMONITOR 
a871 cd 6b 94			call break_point_state  
a874				endm  
# End of macro CALLMONITOR
a874				endif 
a874			 
a874					; skip opcode 
a874 23					inc hl  
a875					; skip next ptr 
a875 23					inc hl  
a876 23					inc hl 
a877					; skip len 
a877 7e					ld a, (hl)   ; save length to add 
a878				if DEBUG_FORTH_WORDS 
a878					DMARK "LS2" 
a878 f5				push af  
a879 3a 8d a8			ld a, (.dmark)  
a87c 32 71 ee			ld (debug_mark),a  
a87f 3a 8e a8			ld a, (.dmark+1)  
a882 32 72 ee			ld (debug_mark+1),a  
a885 3a 8f a8			ld a, (.dmark+2)  
a888 32 73 ee			ld (debug_mark+2),a  
a88b 18 03			jr .pastdmark  
a88d ..			.dmark: db "LS2"  
a890 f1			.pastdmark: pop af  
a891			endm  
# End of macro DMARK
a891					CALLMONITOR 
a891 cd 6b 94			call break_point_state  
a894				endm  
# End of macro CALLMONITOR
a894				endif 
a894			 
a894					; save this location 
a894				 
a894 e5					push hl 
a895			 
a895 23					inc hl 
a896 11 04 e3				ld de, scratch+2 
a899 4f					ld c, a 
a89a 06 00				ld b, 0 
a89c			 
a89c				if DEBUG_FORTH_WORDS 
a89c					DMARK "LSn" 
a89c f5				push af  
a89d 3a b1 a8			ld a, (.dmark)  
a8a0 32 71 ee			ld (debug_mark),a  
a8a3 3a b2 a8			ld a, (.dmark+1)  
a8a6 32 72 ee			ld (debug_mark+1),a  
a8a9 3a b3 a8			ld a, (.dmark+2)  
a8ac 32 73 ee			ld (debug_mark+2),a  
a8af 18 03			jr .pastdmark  
a8b1 ..			.dmark: db "LSn"  
a8b4 f1			.pastdmark: pop af  
a8b5			endm  
# End of macro DMARK
a8b5					CALLMONITOR 
a8b5 cd 6b 94			call break_point_state  
a8b8				endm  
# End of macro CALLMONITOR
a8b8				endif 
a8b8			 
a8b8					; copy uword name to scratch 
a8b8			 
a8b8 ed b0				ldir 
a8ba			 
a8ba 1b					dec de 
a8bb 3e 20				ld a, ' '    ; change null to space 
a8bd 12					ld (de), a 
a8be			 
a8be 13					inc de 
a8bf			 
a8bf d5					push de 
a8c0 c1					pop bc     ; move scratch pointer to end of word name and save it 
a8c1			 
a8c1 e1					pop hl 
a8c2 7e					ld a, (hl) 
a8c3					;inc hl 
a8c3					; skip word string 
a8c3 cd 6a 8c				call addatohl 
a8c6			 
a8c6 23					inc hl 
a8c7			 
a8c7				if DEBUG_FORTH_WORDS 
a8c7					DMARK "LS3" 
a8c7 f5				push af  
a8c8 3a dc a8			ld a, (.dmark)  
a8cb 32 71 ee			ld (debug_mark),a  
a8ce 3a dd a8			ld a, (.dmark+1)  
a8d1 32 72 ee			ld (debug_mark+1),a  
a8d4 3a de a8			ld a, (.dmark+2)  
a8d7 32 73 ee			ld (debug_mark+2),a  
a8da 18 03			jr .pastdmark  
a8dc ..			.dmark: db "LS3"  
a8df f1			.pastdmark: pop af  
a8e0			endm  
# End of macro DMARK
a8e0					CALLMONITOR 
a8e0 cd 6b 94			call break_point_state  
a8e3				endm  
# End of macro CALLMONITOR
a8e3				endif 
a8e3					; should now be at the start of the machine code to setup the eval of the uword 
a8e3					; now locate the ptr to the string defintion 
a8e3			 
a8e3					; skip ld hl, 
a8e3					; then load the ptr 
a8e3			; TODO use get from hl ptr 
a8e3 23					inc hl 
a8e4 5e					ld e, (hl) 
a8e5 23					inc hl 
a8e6 56					ld d, (hl) 
a8e7 eb					ex de, hl 
a8e8			 
a8e8			 
a8e8				if DEBUG_FORTH_WORDS 
a8e8					DMARK "LSt" 
a8e8 f5				push af  
a8e9 3a fd a8			ld a, (.dmark)  
a8ec 32 71 ee			ld (debug_mark),a  
a8ef 3a fe a8			ld a, (.dmark+1)  
a8f2 32 72 ee			ld (debug_mark+1),a  
a8f5 3a ff a8			ld a, (.dmark+2)  
a8f8 32 73 ee			ld (debug_mark+2),a  
a8fb 18 03			jr .pastdmark  
a8fd ..			.dmark: db "LSt"  
a900 f1			.pastdmark: pop af  
a901			endm  
# End of macro DMARK
a901					CALLMONITOR 
a901 cd 6b 94			call break_point_state  
a904				endm  
# End of macro CALLMONITOR
a904				endif 
a904			 
a904			; cant push right now due to tokenised strings  
a904			 
a904			; get the destination of where to copy this definition to. 
a904			 
a904 c5					push bc 
a905 d1					pop de 
a906			 
a906 7e			.listl:         ld a,(hl) 
a907 fe 00				cp 0 
a909 28 09				jr z, .lreplsp     ; replace zero with space 
a90b					;cp FORTH_END_BUFFER 
a90b fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a90d 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a90f				 
a90f					; just copy this char as is then 
a90f			 
a90f 12					ld (de), a 
a910			 
a910 23			.listnxt:	inc hl 
a911 13					inc de 
a912 18 f2				jr .listl 
a914			 
a914 3e 20		.lreplsp:	ld a,' ' 
a916 12					ld (de), a 
a917 18 f7				jr .listnxt 
a919			 
a919			; close up uword def 
a919			 
a919			.listdone: 
a919 12					ld (de), a 
a91a 13					inc de 
a91b 3e 00				ld a, 0 
a91d 12					ld (de), a 
a91e			 
a91e			; now have def so clean up and push to stack 
a91e			 
a91e 21 02 e3				ld hl, scratch 
a921				if DEBUG_FORTH_WORDS 
a921					DMARK "Ltp" 
a921 f5				push af  
a922 3a 36 a9			ld a, (.dmark)  
a925 32 71 ee			ld (debug_mark),a  
a928 3a 37 a9			ld a, (.dmark+1)  
a92b 32 72 ee			ld (debug_mark+1),a  
a92e 3a 38 a9			ld a, (.dmark+2)  
a931 32 73 ee			ld (debug_mark+2),a  
a934 18 03			jr .pastdmark  
a936 ..			.dmark: db "Ltp"  
a939 f1			.pastdmark: pop af  
a93a			endm  
# End of macro DMARK
a93a					CALLMONITOR 
a93a cd 6b 94			call break_point_state  
a93d				endm  
# End of macro CALLMONITOR
a93d				endif 
a93d			 
a93d 18 1f			jr .listpush 
a93f			 
a93f			;.lnuword:	pop hl 
a93f			;		call forth_tok_next 
a93f			;		jp .ldouscan  
a93f			 
a93f			.lunotfound:		  
a93f			 
a93f				if DEBUG_FORTH_WORDS 
a93f					DMARK "LSn" 
a93f f5				push af  
a940 3a 54 a9			ld a, (.dmark)  
a943 32 71 ee			ld (debug_mark),a  
a946 3a 55 a9			ld a, (.dmark+1)  
a949 32 72 ee			ld (debug_mark+1),a  
a94c 3a 56 a9			ld a, (.dmark+2)  
a94f 32 73 ee			ld (debug_mark+2),a  
a952 18 03			jr .pastdmark  
a954 ..			.dmark: db "LSn"  
a957 f1			.pastdmark: pop af  
a958			endm  
# End of macro DMARK
a958					CALLMONITOR 
a958 cd 6b 94			call break_point_state  
a95b				endm  
# End of macro CALLMONITOR
a95b				endif 
a95b			 
a95b					 
a95b			;		FORTH_DSP_POP 
a95b			;		ld hl, .luno 
a95b			 
a95b					NEXTW			 
a95b c3 4a 9e			jp macro_next 
a95e				endm 
# End of macro NEXTW
a95e			 
a95e			.listpush: 
a95e				if DEBUG_FORTH_WORDS 
a95e					DMARK "LS>" 
a95e f5				push af  
a95f 3a 73 a9			ld a, (.dmark)  
a962 32 71 ee			ld (debug_mark),a  
a965 3a 74 a9			ld a, (.dmark+1)  
a968 32 72 ee			ld (debug_mark+1),a  
a96b 3a 75 a9			ld a, (.dmark+2)  
a96e 32 73 ee			ld (debug_mark+2),a  
a971 18 03			jr .pastdmark  
a973 ..			.dmark: db "LS>"  
a976 f1			.pastdmark: pop af  
a977			endm  
# End of macro DMARK
a977					CALLMONITOR 
a977 cd 6b 94			call break_point_state  
a97a				endm  
# End of macro CALLMONITOR
a97a				endif 
a97a cd 4a 9b				call forth_push_str 
a97d			 
a97d			 
a97d			 
a97d					NEXTW 
a97d c3 4a 9e			jp macro_next 
a980				endm 
# End of macro NEXTW
a980			 
a980			;.luno:    db "Word not found",0 
a980			 
a980			 
a980			 
a980			 
a980			 
a980			;		push hl   ; save pointer to start of uword def string 
a980			; 
a980			;; look for FORTH_EOL_LINE 
a980			;		ld a, FORTH_END_BUFFER 
a980			;		call strlent 
a980			; 
a980			;		inc hl		 ; space for coln def 
a980			;		inc hl 
a980			;		inc hl          ; space for terms 
a980			;		inc hl 
a980			; 
a980			;		ld a, 20   ; TODO get actual length 
a980			;		call addatohl    ; include a random amount of room for the uword name 
a980			; 
a980			;		 
a980			;	if DEBUG_FORTH_WORDS 
a980			;		DMARK "Lt1" 
a980			;		CALLMONITOR 
a980			;	endif 
a980			;		 
a980			; 
a980			;; malloc space for the string because we cant change it 
a980			; 
a980			;		call malloc 
a980			;	if DEBUG_FORTH_MALLOC_GUARD 
a980			;		push af 
a980			;		call ishlzero 
a980			;		pop af 
a980			;		 
a980			;		call z,malloc_error 
a980			;	endif 
a980			; 
a980			;	if DEBUG_FORTH_WORDS 
a980			;		DMARK "Lt2" 
a980			;		CALLMONITOR 
a980			;	endif 
a980			;		pop de 
a980			;		push hl    ; push the malloc to release later 
a980			;		push hl   ;  push back a copy for the later stack push 
a980			;		 
a980			;; copy the string swapping out the zero terms for spaces 
a980			; 
a980			;		; de has our source 
a980			;		; hl has our dest 
a980			; 
a980			;; add the coln def 
a980			; 
a980			;		ld a, ':' 
a980			;		ld (hl), a 
a980			;		inc hl 
a980			;		ld a, ' ' 
a980			;		ld (hl), a 
a980			;		inc hl 
a980			; 
a980			;; add the uname word 
a980			;		push de   ; save our string for now 
a980			;		ex de, hl 
a980			; 
a980			;		FORTH_DSP_VALUE 
a980			;		;v5 FORTH_DSP_VALUE 
a980			; 
a980			;		inc hl   ; skip type but we know by now this is OK 
a980			; 
a980			;.luword:	ld a,(hl) 
a980			;		cp 0 
a980			;		jr z, .luword2 
a980			;		ld (de), a 
a980			;		inc de 
a980			;		inc hl 
a980			;		jr .luword 
a980			; 
a980			;.luword2:	ld a, ' ' 
a980			;		ld (de), a 
a980			;;		inc hl 
a980			;;		inc de 
a980			;;		ld (de), a 
a980			;;		inc hl 
a980			;		inc de 
a980			; 
a980			;		ex de, hl 
a980			;		pop de 
a980			;		 
a980			;		 
a980			; 
a980			;; detoken that string and copy it 
a980			; 
a980			;	if DEBUG_FORTH_WORDS 
a980			;		DMARK "Lt2" 
a980			;		CALLMONITOR 
a980			;	endif 
a980			;.ldetok:	ld a, (de) 
a980			;		cp FORTH_END_BUFFER 
a980			;		jr z, .ldetokend 
a980			;		; swap out any zero term for space 
a980			;		cp 0 
a980			;		jr nz, .ldetoknext 
a980			;		ld a, ' ' 
a980			; 
a980			;	if DEBUG_FORTH_WORDS 
a980			;		DMARK "LtS" 
a980			;		CALLMONITOR 
a980			;	endif 
a980			;.ldetoknext:	ld (hl), a 
a980			;		inc de 
a980			;		inc hl 
a980			;		jr .ldetok 
a980			; 
a980			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a980			;		ld (hl), a  
a980			; 
a980			;; free that temp malloc 
a980			; 
a980			;		pop hl    
a980			; 
a980			;	if DEBUG_FORTH_WORDS 
a980			;		DMARK "Lt4" 
a980			;		CALLMONITOR 
a980			;	endif 
a980			;		call forth_apushstrhl 
a980			; 
a980			;		; get rid of temp malloc area 
a980			; 
a980			;		pop hl 
a980			;		call free 
a980			; 
a980			;		jr .ludone 
a980			; 
a980			;.lnuword:	pop hl 
a980			;		call forth_tok_next 
a980			;		jp .ldouscan  
a980			; 
a980			;.ludone:		 pop hl 
a980			; 
a980					NEXTW 
a980 c3 4a 9e			jp macro_next 
a983				endm 
# End of macro NEXTW
a983			 
a983			.FORGET: 
a983				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a983 5d				db WORD_SYS_CORE+73             
a984 fc a9			dw .NOP            
a986 07				db 6 + 1 
a987 .. 00			db "FORGET",0              
a98e				endm 
# End of macro CWHEAD
a98e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a98e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a98e			; | |  
a98e			; | | e.g. "MORE" forget 
a98e					if DEBUG_FORTH_WORDS_KEY 
a98e						DMARK "FRG" 
a98e f5				push af  
a98f 3a a3 a9			ld a, (.dmark)  
a992 32 71 ee			ld (debug_mark),a  
a995 3a a4 a9			ld a, (.dmark+1)  
a998 32 72 ee			ld (debug_mark+1),a  
a99b 3a a5 a9			ld a, (.dmark+2)  
a99e 32 73 ee			ld (debug_mark+2),a  
a9a1 18 03			jr .pastdmark  
a9a3 ..			.dmark: db "FRG"  
a9a6 f1			.pastdmark: pop af  
a9a7			endm  
# End of macro DMARK
a9a7						CALLMONITOR 
a9a7 cd 6b 94			call break_point_state  
a9aa				endm  
# End of macro CALLMONITOR
a9aa					endif 
a9aa			 
a9aa				; find uword 
a9aa			        ; update start of word with "_" 
a9aa				; replace uword with deleted flag 
a9aa			 
a9aa			 
a9aa			;	if DEBUG_FORTH_WORDS 
a9aa			;		DMARK "FOG" 
a9aa			;		CALLMONITOR 
a9aa			;	endif 
a9aa			 
a9aa			 
a9aa					; Get ptr to the word we need to look up 
a9aa			 
a9aa					FORTH_DSP_VALUEHL 
a9aa cd d3 9c			call macro_dsp_valuehl 
a9ad				endm 
# End of macro FORTH_DSP_VALUEHL
a9ad					;v5 FORTH_DSP_VALUE 
a9ad				; TODO type check 
a9ad			;		inc hl    ; Skip type check  
a9ad e5					push hl 
a9ae c1					pop bc 
a9af			;		ex de, hl    ; put into DE 
a9af			 
a9af			 
a9af 21 53 da				ld hl, baseram 
a9b2					;ld hl, baseusermem 
a9b2			 
a9b2				; skip dict stub 
a9b2			;	call forth_tok_next 
a9b2 e5			push hl   ; sacreifical push 
a9b3			 
a9b3			.fldouscanm: 
a9b3 e1				pop hl 
a9b4			.fldouscan: 
a9b4			;	if DEBUG_FORTH_WORDS 
a9b4			;		DMARK "LSs" 
a9b4			;		CALLMONITOR 
a9b4			;	endif 
a9b4				; skip dict stub 
a9b4 cd 9b 9f				call forth_tok_next 
a9b7			 
a9b7			 
a9b7			; while we have words to look for 
a9b7			 
a9b7 7e				ld a, (hl)      
a9b8			;	if DEBUG_FORTH_WORDS 
a9b8			;		DMARK "LSk" 
a9b8			;		CALLMONITOR 
a9b8			;	endif 
a9b8 fe 00				cp WORD_SYS_END 
a9ba ca f6 a9				jp z, .flunotfound 
a9bd fe 01				cp WORD_SYS_UWORD 
a9bf c2 b4 a9				jp nz, .fldouscan 
a9c2			 
a9c2			;	if DEBUG_FORTH_WORDS 
a9c2			;		DMARK "LSu" 
a9c2			;		CALLMONITOR 
a9c2			;	endif 
a9c2			 
a9c2					; found a uword but is it the one we want... 
a9c2			 
a9c2 c5					push bc     ; uword to find is on bc 
a9c3 d1					pop de 
a9c4			 
a9c4 e5					push hl  ; to save the ptr 
a9c5			 
a9c5					; skip opcode 
a9c5 23					inc hl  
a9c6					; skip next ptr 
a9c6 23					inc hl  
a9c7 23					inc hl 
a9c8					; skip len 
a9c8 23					inc hl 
a9c9			 
a9c9			;	if DEBUG_FORTH_WORDS 
a9c9			;		DMARK "LSc" 
a9c9			;		CALLMONITOR 
a9c9			;	endif 
a9c9 cd 00 91				call strcmp 
a9cc c2 b3 a9				jp nz, .fldouscanm 
a9cf			; 
a9cf			; 
a9cf			;; while we have words to look for 
a9cf			; 
a9cf			;.fdouscan:	ld a, (hl)      
a9cf			;	if DEBUG_FORTH_WORDS 
a9cf			;		DMARK "LSs" 
a9cf			;		CALLMONITOR 
a9cf			;	endif 
a9cf			;		cp WORD_SYS_END 
a9cf			;		jp z, .fudone 
a9cf			;		cp WORD_SYS_UWORD 
a9cf			;		jp nz, .fnuword 
a9cf			; 
a9cf			;	if DEBUG_FORTH_WORDS 
a9cf			;		DMARK "FGu" 
a9cf			;		CALLMONITOR 
a9cf			;	endif 
a9cf			; 
a9cf			;		; found a uword but is it the one we want... 
a9cf			; 
a9cf			; 
a9cf			;	        pop de   ; get back the dsp name 
a9cf			;		push de 
a9cf			; 
a9cf			;		push hl  ; to save the ptr 
a9cf			; 
a9cf			;		; skip opcode 
a9cf			;		inc hl  
a9cf			;		; skip next ptr 
a9cf			;		inc hl  
a9cf			;		inc hl 
a9cf			;		; skip len 
a9cf			;		inc hl 
a9cf			; 
a9cf			;	if DEBUG_FORTH_WORDS 
a9cf			;		DMARK "FGc" 
a9cf			;		CALLMONITOR 
a9cf			;	endif 
a9cf			;		call strcmp 
a9cf			;		jp nz, .fnuword 
a9cf			 
a9cf			 
a9cf e1			pop hl 
a9d0			 
a9d0				 
a9d0				if DEBUG_FORTH_WORDS 
a9d0					DMARK "FGm" 
a9d0 f5				push af  
a9d1 3a e5 a9			ld a, (.dmark)  
a9d4 32 71 ee			ld (debug_mark),a  
a9d7 3a e6 a9			ld a, (.dmark+1)  
a9da 32 72 ee			ld (debug_mark+1),a  
a9dd 3a e7 a9			ld a, (.dmark+2)  
a9e0 32 73 ee			ld (debug_mark+2),a  
a9e3 18 03			jr .pastdmark  
a9e5 ..			.dmark: db "FGm"  
a9e8 f1			.pastdmark: pop af  
a9e9			endm  
# End of macro DMARK
a9e9					CALLMONITOR 
a9e9 cd 6b 94			call break_point_state  
a9ec				endm  
# End of macro CALLMONITOR
a9ec				endif 
a9ec			 
a9ec			 
a9ec			 
a9ec					; we have a uword so push its name to the stack 
a9ec			 
a9ec			;	   	push hl  ; save so we can move to next dict block 
a9ec			;pop hl 
a9ec			 
a9ec					; update opcode to deleted 
a9ec 3e 03				ld a, WORD_SYS_DELETED 
a9ee 77					ld (hl), a 
a9ef			 
a9ef 23					inc hl  
a9f0					; skip next ptr 
a9f0 23					inc hl  
a9f1 23					inc hl 
a9f2					; skip len 
a9f2 23					inc hl 
a9f3			 
a9f3					; TODO change parser to skip deleted words but for now mark it out 
a9f3 3e 5f				ld a, "_" 
a9f5 77					ld  (hl),a 
a9f6			 
a9f6			;		jr .fudone 
a9f6			; 
a9f6			;.fnuword:	pop hl 
a9f6			;		call forth_tok_next 
a9f6			;		jp .fdouscan  
a9f6			 
a9f6			.flunotfound:		  
a9f6			 
a9f6			 
a9f6					 
a9f6					FORTH_DSP_POP 
a9f6 cd 8b 9d			call macro_forth_dsp_pop 
a9f9				endm 
# End of macro FORTH_DSP_POP
a9f9			;		ld hl, .luno 
a9f9			;.fudone:		 pop hl 
a9f9					NEXTW 
a9f9 c3 4a 9e			jp macro_next 
a9fc				endm 
# End of macro NEXTW
a9fc			.NOP: 
a9fc				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a9fc 61				db WORD_SYS_CORE+77             
a9fd 23 aa			dw .COMO            
a9ff 04				db 3 + 1 
aa00 .. 00			db "NOP",0              
aa04				endm 
# End of macro CWHEAD
aa04			; | NOP (  --  ) Do nothing | DONE 
aa04					if DEBUG_FORTH_WORDS_KEY 
aa04						DMARK "NOP" 
aa04 f5				push af  
aa05 3a 19 aa			ld a, (.dmark)  
aa08 32 71 ee			ld (debug_mark),a  
aa0b 3a 1a aa			ld a, (.dmark+1)  
aa0e 32 72 ee			ld (debug_mark+1),a  
aa11 3a 1b aa			ld a, (.dmark+2)  
aa14 32 73 ee			ld (debug_mark+2),a  
aa17 18 03			jr .pastdmark  
aa19 ..			.dmark: db "NOP"  
aa1c f1			.pastdmark: pop af  
aa1d			endm  
# End of macro DMARK
aa1d						CALLMONITOR 
aa1d cd 6b 94			call break_point_state  
aa20				endm  
# End of macro CALLMONITOR
aa20					endif 
aa20				       NEXTW 
aa20 c3 4a 9e			jp macro_next 
aa23				endm 
# End of macro NEXTW
aa23			.COMO: 
aa23				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aa23 6e				db WORD_SYS_CORE+90             
aa24 75 aa			dw .COMC            
aa26 02				db 1 + 1 
aa27 .. 00			db "(",0              
aa29				endm 
# End of macro CWHEAD
aa29			; | ( ( -- )  Start of comment | DONE 
aa29			 
aa29			 
aa29 2a 03 e6				ld hl, ( os_tok_ptr) 
aa2c 11 70 aa			ld de, .closepar 
aa2f					 
aa2f					if DEBUG_FORTH_WORDS 
aa2f						DMARK ").." 
aa2f f5				push af  
aa30 3a 44 aa			ld a, (.dmark)  
aa33 32 71 ee			ld (debug_mark),a  
aa36 3a 45 aa			ld a, (.dmark+1)  
aa39 32 72 ee			ld (debug_mark+1),a  
aa3c 3a 46 aa			ld a, (.dmark+2)  
aa3f 32 73 ee			ld (debug_mark+2),a  
aa42 18 03			jr .pastdmark  
aa44 ..			.dmark: db ").."  
aa47 f1			.pastdmark: pop af  
aa48			endm  
# End of macro DMARK
aa48						CALLMONITOR 
aa48 cd 6b 94			call break_point_state  
aa4b				endm  
# End of macro CALLMONITOR
aa4b					endif 
aa4b cd 65 9f			call findnexttok  
aa4e			 
aa4e					if DEBUG_FORTH_WORDS 
aa4e						DMARK "IF5" 
aa4e f5				push af  
aa4f 3a 63 aa			ld a, (.dmark)  
aa52 32 71 ee			ld (debug_mark),a  
aa55 3a 64 aa			ld a, (.dmark+1)  
aa58 32 72 ee			ld (debug_mark+1),a  
aa5b 3a 65 aa			ld a, (.dmark+2)  
aa5e 32 73 ee			ld (debug_mark+2),a  
aa61 18 03			jr .pastdmark  
aa63 ..			.dmark: db "IF5"  
aa66 f1			.pastdmark: pop af  
aa67			endm  
# End of macro DMARK
aa67						CALLMONITOR 
aa67 cd 6b 94			call break_point_state  
aa6a				endm  
# End of macro CALLMONITOR
aa6a					endif 
aa6a				; replace below with ) exec using tok_ptr 
aa6a 22 03 e6			ld (os_tok_ptr), hl 
aa6d c3 db 9e			jp exec1 
aa70			 
aa70 .. 00			.closepar:   db ")",0 
aa72			 
aa72				       NEXTW 
aa72 c3 4a 9e			jp macro_next 
aa75				endm 
# End of macro NEXTW
aa75			.COMC: 
aa75				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aa75 6f				db WORD_SYS_CORE+91             
aa76 7e aa			dw .SCRATCH            
aa78 02				db 1 + 1 
aa79 .. 00			db ")",0              
aa7b				endm 
# End of macro CWHEAD
aa7b			; | ) ( -- )  End of comment |  DONE  
aa7b				       NEXTW 
aa7b c3 4a 9e			jp macro_next 
aa7e				endm 
# End of macro NEXTW
aa7e			 
aa7e			.SCRATCH: 
aa7e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aa7e 6f				db WORD_SYS_CORE+91             
aa7f b9 aa			dw .INC            
aa81 08				db 7 + 1 
aa82 .. 00			db "SCRATCH",0              
aa8a				endm 
# End of macro CWHEAD
aa8a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
aa8a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
aa8a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
aa8a			; | |  
aa8a			; | | e.g.    : score $00 scratch ; 
aa8a			; | |  
aa8a			; | | $00 score ! 
aa8a			; | | $01 score +! 
aa8a			; | |  
aa8a			; | | e.g.   : varword $0a scratch ;  
aa8a			; | | 
aa8a			; | | $8000 varword ! 
aa8a					if DEBUG_FORTH_WORDS_KEY 
aa8a						DMARK "SCR" 
aa8a f5				push af  
aa8b 3a 9f aa			ld a, (.dmark)  
aa8e 32 71 ee			ld (debug_mark),a  
aa91 3a a0 aa			ld a, (.dmark+1)  
aa94 32 72 ee			ld (debug_mark+1),a  
aa97 3a a1 aa			ld a, (.dmark+2)  
aa9a 32 73 ee			ld (debug_mark+2),a  
aa9d 18 03			jr .pastdmark  
aa9f ..			.dmark: db "SCR"  
aaa2 f1			.pastdmark: pop af  
aaa3			endm  
# End of macro DMARK
aaa3						CALLMONITOR 
aaa3 cd 6b 94			call break_point_state  
aaa6				endm  
# End of macro CALLMONITOR
aaa6					endif 
aaa6			 
aaa6					FORTH_DSP_VALUEHL 
aaa6 cd d3 9c			call macro_dsp_valuehl 
aaa9				endm 
# End of macro FORTH_DSP_VALUEHL
aaa9				 
aaa9					FORTH_DSP_POP 
aaa9 cd 8b 9d			call macro_forth_dsp_pop 
aaac				endm 
# End of macro FORTH_DSP_POP
aaac			 
aaac 7d					ld a, l 
aaad 21 27 e8				ld hl, os_var_array 
aab0 cd 6a 8c				call addatohl 
aab3			 
aab3 cd dc 9a				call forth_push_numhl 
aab6			 
aab6				       NEXTW 
aab6 c3 4a 9e			jp macro_next 
aab9				endm 
# End of macro NEXTW
aab9			 
aab9			.INC: 
aab9				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
aab9 6f				db WORD_SYS_CORE+91             
aaba 0d ab			dw .DEC            
aabc 03				db 2 + 1 
aabd .. 00			db "+!",0              
aac0				endm 
# End of macro CWHEAD
aac0			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
aac0					if DEBUG_FORTH_WORDS_KEY 
aac0						DMARK "+s_" 
aac0 f5				push af  
aac1 3a d5 aa			ld a, (.dmark)  
aac4 32 71 ee			ld (debug_mark),a  
aac7 3a d6 aa			ld a, (.dmark+1)  
aaca 32 72 ee			ld (debug_mark+1),a  
aacd 3a d7 aa			ld a, (.dmark+2)  
aad0 32 73 ee			ld (debug_mark+2),a  
aad3 18 03			jr .pastdmark  
aad5 ..			.dmark: db "+s_"  
aad8 f1			.pastdmark: pop af  
aad9			endm  
# End of macro DMARK
aad9						CALLMONITOR 
aad9 cd 6b 94			call break_point_state  
aadc				endm  
# End of macro CALLMONITOR
aadc					endif 
aadc			 
aadc					FORTH_DSP_VALUEHL 
aadc cd d3 9c			call macro_dsp_valuehl 
aadf				endm 
# End of macro FORTH_DSP_VALUEHL
aadf			 
aadf e5					push hl   ; save address 
aae0			 
aae0					FORTH_DSP_POP 
aae0 cd 8b 9d			call macro_forth_dsp_pop 
aae3				endm 
# End of macro FORTH_DSP_POP
aae3			 
aae3					FORTH_DSP_VALUEHL 
aae3 cd d3 9c			call macro_dsp_valuehl 
aae6				endm 
# End of macro FORTH_DSP_VALUEHL
aae6			 
aae6					FORTH_DSP_POP 
aae6 cd 8b 9d			call macro_forth_dsp_pop 
aae9				endm 
# End of macro FORTH_DSP_POP
aae9			 
aae9					; hl contains value to add to byte at a 
aae9				 
aae9 eb					ex de, hl 
aaea			 
aaea e1					pop hl 
aaeb			 
aaeb					if DEBUG_FORTH_WORDS 
aaeb						DMARK "INC" 
aaeb f5				push af  
aaec 3a 00 ab			ld a, (.dmark)  
aaef 32 71 ee			ld (debug_mark),a  
aaf2 3a 01 ab			ld a, (.dmark+1)  
aaf5 32 72 ee			ld (debug_mark+1),a  
aaf8 3a 02 ab			ld a, (.dmark+2)  
aafb 32 73 ee			ld (debug_mark+2),a  
aafe 18 03			jr .pastdmark  
ab00 ..			.dmark: db "INC"  
ab03 f1			.pastdmark: pop af  
ab04			endm  
# End of macro DMARK
ab04						CALLMONITOR 
ab04 cd 6b 94			call break_point_state  
ab07				endm  
# End of macro CALLMONITOR
ab07					endif 
ab07			 
ab07 7e					ld a,(hl) 
ab08 83					add e 
ab09 77					ld (hl),a 
ab0a			 
ab0a			 
ab0a			 
ab0a				       NEXTW 
ab0a c3 4a 9e			jp macro_next 
ab0d				endm 
# End of macro NEXTW
ab0d			 
ab0d			.DEC: 
ab0d				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ab0d 6f				db WORD_SYS_CORE+91             
ab0e 5e ab			dw .INC2            
ab10 03				db 2 + 1 
ab11 .. 00			db "-!",0              
ab14				endm 
# End of macro CWHEAD
ab14			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ab14					if DEBUG_FORTH_WORDS_KEY 
ab14						DMARK "-s_" 
ab14 f5				push af  
ab15 3a 29 ab			ld a, (.dmark)  
ab18 32 71 ee			ld (debug_mark),a  
ab1b 3a 2a ab			ld a, (.dmark+1)  
ab1e 32 72 ee			ld (debug_mark+1),a  
ab21 3a 2b ab			ld a, (.dmark+2)  
ab24 32 73 ee			ld (debug_mark+2),a  
ab27 18 03			jr .pastdmark  
ab29 ..			.dmark: db "-s_"  
ab2c f1			.pastdmark: pop af  
ab2d			endm  
# End of macro DMARK
ab2d						CALLMONITOR 
ab2d cd 6b 94			call break_point_state  
ab30				endm  
# End of macro CALLMONITOR
ab30					endif 
ab30			 
ab30					FORTH_DSP_VALUEHL 
ab30 cd d3 9c			call macro_dsp_valuehl 
ab33				endm 
# End of macro FORTH_DSP_VALUEHL
ab33			 
ab33 e5					push hl   ; save address 
ab34			 
ab34					FORTH_DSP_POP 
ab34 cd 8b 9d			call macro_forth_dsp_pop 
ab37				endm 
# End of macro FORTH_DSP_POP
ab37			 
ab37					FORTH_DSP_VALUEHL 
ab37 cd d3 9c			call macro_dsp_valuehl 
ab3a				endm 
# End of macro FORTH_DSP_VALUEHL
ab3a			 
ab3a					; hl contains value to add to byte at a 
ab3a				 
ab3a eb					ex de, hl 
ab3b			 
ab3b e1					pop hl 
ab3c			 
ab3c					if DEBUG_FORTH_WORDS 
ab3c						DMARK "DEC" 
ab3c f5				push af  
ab3d 3a 51 ab			ld a, (.dmark)  
ab40 32 71 ee			ld (debug_mark),a  
ab43 3a 52 ab			ld a, (.dmark+1)  
ab46 32 72 ee			ld (debug_mark+1),a  
ab49 3a 53 ab			ld a, (.dmark+2)  
ab4c 32 73 ee			ld (debug_mark+2),a  
ab4f 18 03			jr .pastdmark  
ab51 ..			.dmark: db "DEC"  
ab54 f1			.pastdmark: pop af  
ab55			endm  
# End of macro DMARK
ab55						CALLMONITOR 
ab55 cd 6b 94			call break_point_state  
ab58				endm  
# End of macro CALLMONITOR
ab58					endif 
ab58			 
ab58 7e					ld a,(hl) 
ab59 93					sub e 
ab5a 77					ld (hl),a 
ab5b			 
ab5b			 
ab5b			 
ab5b				       NEXTW 
ab5b c3 4a 9e			jp macro_next 
ab5e				endm 
# End of macro NEXTW
ab5e			 
ab5e			.INC2: 
ab5e				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ab5e 6f				db WORD_SYS_CORE+91             
ab5f 08 ac			dw .DEC2            
ab61 04				db 3 + 1 
ab62 .. 00			db "+2!",0              
ab66				endm 
# End of macro CWHEAD
ab66			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ab66			 
ab66					if DEBUG_FORTH_WORDS_KEY 
ab66						DMARK "+2s" 
ab66 f5				push af  
ab67 3a 7b ab			ld a, (.dmark)  
ab6a 32 71 ee			ld (debug_mark),a  
ab6d 3a 7c ab			ld a, (.dmark+1)  
ab70 32 72 ee			ld (debug_mark+1),a  
ab73 3a 7d ab			ld a, (.dmark+2)  
ab76 32 73 ee			ld (debug_mark+2),a  
ab79 18 03			jr .pastdmark  
ab7b ..			.dmark: db "+2s"  
ab7e f1			.pastdmark: pop af  
ab7f			endm  
# End of macro DMARK
ab7f						CALLMONITOR 
ab7f cd 6b 94			call break_point_state  
ab82				endm  
# End of macro CALLMONITOR
ab82					endif 
ab82			 
ab82					; Address 
ab82			 
ab82					FORTH_DSP_VALUEHL 
ab82 cd d3 9c			call macro_dsp_valuehl 
ab85				endm 
# End of macro FORTH_DSP_VALUEHL
ab85			 
ab85 e5					push hl    ; save address 
ab86			 
ab86					; load content into de 
ab86			 
ab86 5e					ld e,(hl) 
ab87 23					inc hl 
ab88 56					ld d, (hl) 
ab89			 
ab89					if DEBUG_FORTH_WORDS 
ab89						DMARK "+2a" 
ab89 f5				push af  
ab8a 3a 9e ab			ld a, (.dmark)  
ab8d 32 71 ee			ld (debug_mark),a  
ab90 3a 9f ab			ld a, (.dmark+1)  
ab93 32 72 ee			ld (debug_mark+1),a  
ab96 3a a0 ab			ld a, (.dmark+2)  
ab99 32 73 ee			ld (debug_mark+2),a  
ab9c 18 03			jr .pastdmark  
ab9e ..			.dmark: db "+2a"  
aba1 f1			.pastdmark: pop af  
aba2			endm  
# End of macro DMARK
aba2						CALLMONITOR 
aba2 cd 6b 94			call break_point_state  
aba5				endm  
# End of macro CALLMONITOR
aba5					endif 
aba5			 
aba5					FORTH_DSP_POP 
aba5 cd 8b 9d			call macro_forth_dsp_pop 
aba8				endm 
# End of macro FORTH_DSP_POP
aba8			 
aba8					; Get value to add 
aba8			 
aba8					FORTH_DSP_VALUE 
aba8 cd bc 9c			call macro_forth_dsp_value 
abab				endm 
# End of macro FORTH_DSP_VALUE
abab			 
abab					if DEBUG_FORTH_WORDS 
abab						DMARK "+2v" 
abab f5				push af  
abac 3a c0 ab			ld a, (.dmark)  
abaf 32 71 ee			ld (debug_mark),a  
abb2 3a c1 ab			ld a, (.dmark+1)  
abb5 32 72 ee			ld (debug_mark+1),a  
abb8 3a c2 ab			ld a, (.dmark+2)  
abbb 32 73 ee			ld (debug_mark+2),a  
abbe 18 03			jr .pastdmark  
abc0 ..			.dmark: db "+2v"  
abc3 f1			.pastdmark: pop af  
abc4			endm  
# End of macro DMARK
abc4						CALLMONITOR 
abc4 cd 6b 94			call break_point_state  
abc7				endm  
# End of macro CALLMONITOR
abc7					endif 
abc7			 
abc7 19					add hl, de 
abc8			 
abc8					if DEBUG_FORTH_WORDS 
abc8						DMARK "+2+" 
abc8 f5				push af  
abc9 3a dd ab			ld a, (.dmark)  
abcc 32 71 ee			ld (debug_mark),a  
abcf 3a de ab			ld a, (.dmark+1)  
abd2 32 72 ee			ld (debug_mark+1),a  
abd5 3a df ab			ld a, (.dmark+2)  
abd8 32 73 ee			ld (debug_mark+2),a  
abdb 18 03			jr .pastdmark  
abdd ..			.dmark: db "+2+"  
abe0 f1			.pastdmark: pop af  
abe1			endm  
# End of macro DMARK
abe1						CALLMONITOR 
abe1 cd 6b 94			call break_point_state  
abe4				endm  
# End of macro CALLMONITOR
abe4					endif 
abe4			 
abe4					; move result to de 
abe4			 
abe4 eb					ex de, hl 
abe5			 
abe5					; Address 
abe5			 
abe5 e1					pop hl 
abe6			 
abe6					; save it back 
abe6			 
abe6 73					ld (hl), e 
abe7 23					inc hl 
abe8 72					ld (hl), d 
abe9			 
abe9					if DEBUG_FORTH_WORDS 
abe9						DMARK "+2e" 
abe9 f5				push af  
abea 3a fe ab			ld a, (.dmark)  
abed 32 71 ee			ld (debug_mark),a  
abf0 3a ff ab			ld a, (.dmark+1)  
abf3 32 72 ee			ld (debug_mark+1),a  
abf6 3a 00 ac			ld a, (.dmark+2)  
abf9 32 73 ee			ld (debug_mark+2),a  
abfc 18 03			jr .pastdmark  
abfe ..			.dmark: db "+2e"  
ac01 f1			.pastdmark: pop af  
ac02			endm  
# End of macro DMARK
ac02						CALLMONITOR 
ac02 cd 6b 94			call break_point_state  
ac05				endm  
# End of macro CALLMONITOR
ac05					endif 
ac05			 
ac05			 
ac05			 
ac05			 
ac05			 
ac05				       NEXTW 
ac05 c3 4a 9e			jp macro_next 
ac08				endm 
# End of macro NEXTW
ac08			 
ac08			.DEC2: 
ac08				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ac08 6f				db WORD_SYS_CORE+91             
ac09 b4 ac			dw .GET2            
ac0b 04				db 3 + 1 
ac0c .. 00			db "-2!",0              
ac10				endm 
# End of macro CWHEAD
ac10			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ac10			 
ac10			 
ac10					if DEBUG_FORTH_WORDS_KEY 
ac10						DMARK "-2s" 
ac10 f5				push af  
ac11 3a 25 ac			ld a, (.dmark)  
ac14 32 71 ee			ld (debug_mark),a  
ac17 3a 26 ac			ld a, (.dmark+1)  
ac1a 32 72 ee			ld (debug_mark+1),a  
ac1d 3a 27 ac			ld a, (.dmark+2)  
ac20 32 73 ee			ld (debug_mark+2),a  
ac23 18 03			jr .pastdmark  
ac25 ..			.dmark: db "-2s"  
ac28 f1			.pastdmark: pop af  
ac29			endm  
# End of macro DMARK
ac29						CALLMONITOR 
ac29 cd 6b 94			call break_point_state  
ac2c				endm  
# End of macro CALLMONITOR
ac2c					endif 
ac2c			 
ac2c					; Address 
ac2c			 
ac2c					FORTH_DSP_VALUEHL 
ac2c cd d3 9c			call macro_dsp_valuehl 
ac2f				endm 
# End of macro FORTH_DSP_VALUEHL
ac2f			 
ac2f e5					push hl    ; save address 
ac30			 
ac30					; load content into de 
ac30			 
ac30 5e					ld e,(hl) 
ac31 23					inc hl 
ac32 56					ld d, (hl) 
ac33			 
ac33					if DEBUG_FORTH_WORDS 
ac33						DMARK "-2a" 
ac33 f5				push af  
ac34 3a 48 ac			ld a, (.dmark)  
ac37 32 71 ee			ld (debug_mark),a  
ac3a 3a 49 ac			ld a, (.dmark+1)  
ac3d 32 72 ee			ld (debug_mark+1),a  
ac40 3a 4a ac			ld a, (.dmark+2)  
ac43 32 73 ee			ld (debug_mark+2),a  
ac46 18 03			jr .pastdmark  
ac48 ..			.dmark: db "-2a"  
ac4b f1			.pastdmark: pop af  
ac4c			endm  
# End of macro DMARK
ac4c						CALLMONITOR 
ac4c cd 6b 94			call break_point_state  
ac4f				endm  
# End of macro CALLMONITOR
ac4f					endif 
ac4f			 
ac4f					FORTH_DSP_POP 
ac4f cd 8b 9d			call macro_forth_dsp_pop 
ac52				endm 
# End of macro FORTH_DSP_POP
ac52			 
ac52					; Get value to remove 
ac52			 
ac52					FORTH_DSP_VALUE 
ac52 cd bc 9c			call macro_forth_dsp_value 
ac55				endm 
# End of macro FORTH_DSP_VALUE
ac55			 
ac55					if DEBUG_FORTH_WORDS 
ac55						DMARK "-2v" 
ac55 f5				push af  
ac56 3a 6a ac			ld a, (.dmark)  
ac59 32 71 ee			ld (debug_mark),a  
ac5c 3a 6b ac			ld a, (.dmark+1)  
ac5f 32 72 ee			ld (debug_mark+1),a  
ac62 3a 6c ac			ld a, (.dmark+2)  
ac65 32 73 ee			ld (debug_mark+2),a  
ac68 18 03			jr .pastdmark  
ac6a ..			.dmark: db "-2v"  
ac6d f1			.pastdmark: pop af  
ac6e			endm  
# End of macro DMARK
ac6e						CALLMONITOR 
ac6e cd 6b 94			call break_point_state  
ac71				endm  
# End of macro CALLMONITOR
ac71					endif 
ac71			 
ac71 eb					ex de, hl 
ac72 ed 52				sbc hl, de 
ac74			 
ac74					if DEBUG_FORTH_WORDS 
ac74						DMARK "-2d" 
ac74 f5				push af  
ac75 3a 89 ac			ld a, (.dmark)  
ac78 32 71 ee			ld (debug_mark),a  
ac7b 3a 8a ac			ld a, (.dmark+1)  
ac7e 32 72 ee			ld (debug_mark+1),a  
ac81 3a 8b ac			ld a, (.dmark+2)  
ac84 32 73 ee			ld (debug_mark+2),a  
ac87 18 03			jr .pastdmark  
ac89 ..			.dmark: db "-2d"  
ac8c f1			.pastdmark: pop af  
ac8d			endm  
# End of macro DMARK
ac8d						CALLMONITOR 
ac8d cd 6b 94			call break_point_state  
ac90				endm  
# End of macro CALLMONITOR
ac90					endif 
ac90			 
ac90					; move result to de 
ac90			 
ac90 eb					ex de, hl 
ac91			 
ac91					; Address 
ac91			 
ac91 e1					pop hl 
ac92			 
ac92					; save it back 
ac92			 
ac92 73					ld (hl), e 
ac93 23					inc hl 
ac94 72					ld (hl), d 
ac95			 
ac95					if DEBUG_FORTH_WORDS 
ac95						DMARK "-2e" 
ac95 f5				push af  
ac96 3a aa ac			ld a, (.dmark)  
ac99 32 71 ee			ld (debug_mark),a  
ac9c 3a ab ac			ld a, (.dmark+1)  
ac9f 32 72 ee			ld (debug_mark+1),a  
aca2 3a ac ac			ld a, (.dmark+2)  
aca5 32 73 ee			ld (debug_mark+2),a  
aca8 18 03			jr .pastdmark  
acaa ..			.dmark: db "-2e"  
acad f1			.pastdmark: pop af  
acae			endm  
# End of macro DMARK
acae						CALLMONITOR 
acae cd 6b 94			call break_point_state  
acb1				endm  
# End of macro CALLMONITOR
acb1					endif 
acb1			 
acb1			 
acb1			 
acb1			 
acb1			 
acb1				       NEXTW 
acb1 c3 4a 9e			jp macro_next 
acb4				endm 
# End of macro NEXTW
acb4			.GET2: 
acb4				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
acb4 6f				db WORD_SYS_CORE+91             
acb5 e4 ac			dw .BANG2            
acb7 03				db 2 + 1 
acb8 .. 00			db "2@",0              
acbb				endm 
# End of macro CWHEAD
acbb			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
acbb					if DEBUG_FORTH_WORDS_KEY 
acbb						DMARK "2A_" 
acbb f5				push af  
acbc 3a d0 ac			ld a, (.dmark)  
acbf 32 71 ee			ld (debug_mark),a  
acc2 3a d1 ac			ld a, (.dmark+1)  
acc5 32 72 ee			ld (debug_mark+1),a  
acc8 3a d2 ac			ld a, (.dmark+2)  
accb 32 73 ee			ld (debug_mark+2),a  
acce 18 03			jr .pastdmark  
acd0 ..			.dmark: db "2A_"  
acd3 f1			.pastdmark: pop af  
acd4			endm  
# End of macro DMARK
acd4						CALLMONITOR 
acd4 cd 6b 94			call break_point_state  
acd7				endm  
# End of macro CALLMONITOR
acd7					endif 
acd7			 
acd7					FORTH_DSP_VALUEHL 
acd7 cd d3 9c			call macro_dsp_valuehl 
acda				endm 
# End of macro FORTH_DSP_VALUEHL
acda			 
acda 5e					ld e, (hl) 
acdb 23					inc hl 
acdc 56					ld d, (hl) 
acdd			 
acdd eb					ex de, hl 
acde			 
acde cd dc 9a				call forth_push_numhl 
ace1			 
ace1				       NEXTW 
ace1 c3 4a 9e			jp macro_next 
ace4				endm 
# End of macro NEXTW
ace4			.BANG2: 
ace4				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ace4 6f				db WORD_SYS_CORE+91             
ace5 1c ad			dw .CONFIG            
ace7 03				db 2 + 1 
ace8 .. 00			db "2!",0              
aceb				endm 
# End of macro CWHEAD
aceb			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
aceb					if DEBUG_FORTH_WORDS_KEY 
aceb						DMARK "2S_" 
aceb f5				push af  
acec 3a 00 ad			ld a, (.dmark)  
acef 32 71 ee			ld (debug_mark),a  
acf2 3a 01 ad			ld a, (.dmark+1)  
acf5 32 72 ee			ld (debug_mark+1),a  
acf8 3a 02 ad			ld a, (.dmark+2)  
acfb 32 73 ee			ld (debug_mark+2),a  
acfe 18 03			jr .pastdmark  
ad00 ..			.dmark: db "2S_"  
ad03 f1			.pastdmark: pop af  
ad04			endm  
# End of macro DMARK
ad04						CALLMONITOR 
ad04 cd 6b 94			call break_point_state  
ad07				endm  
# End of macro CALLMONITOR
ad07					endif 
ad07			 
ad07					FORTH_DSP_VALUEHL 
ad07 cd d3 9c			call macro_dsp_valuehl 
ad0a				endm 
# End of macro FORTH_DSP_VALUEHL
ad0a			 
ad0a e5					push hl   ; save address 
ad0b			 
ad0b			 
ad0b					FORTH_DSP_POP 
ad0b cd 8b 9d			call macro_forth_dsp_pop 
ad0e				endm 
# End of macro FORTH_DSP_POP
ad0e			 
ad0e					 
ad0e					FORTH_DSP_VALUEHL 
ad0e cd d3 9c			call macro_dsp_valuehl 
ad11				endm 
# End of macro FORTH_DSP_VALUEHL
ad11			 
ad11					FORTH_DSP_POP 
ad11 cd 8b 9d			call macro_forth_dsp_pop 
ad14				endm 
# End of macro FORTH_DSP_POP
ad14			 
ad14 eb					ex de, hl    ; value now in de 
ad15			 
ad15 e1					pop hl 
ad16			 
ad16 73					ld (hl), e 
ad17			 
ad17 23					inc hl 
ad18			 
ad18 72					ld (hl), d 
ad19			 
ad19			 
ad19				       NEXTW 
ad19 c3 4a 9e			jp macro_next 
ad1c				endm 
# End of macro NEXTW
ad1c			.CONFIG: 
ad1c				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ad1c 6f				db WORD_SYS_CORE+91             
ad1d 2d ad			dw .ENDCORE            
ad1f 07				db 6 + 1 
ad20 .. 00			db "CONFIG",0              
ad27				endm 
# End of macro CWHEAD
ad27			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad27			 
ad27 cd ca 92				call config 
ad2a					NEXTW 
ad2a c3 4a 9e			jp macro_next 
ad2d				endm 
# End of macro NEXTW
ad2d			.ENDCORE: 
ad2d			 
ad2d			; eof 
ad2d			 
ad2d			 
# End of file forth_words_core.asm
ad2d			include "forth_words_flow.asm" 
ad2d			 
ad2d			; | ## Program Flow Words 
ad2d			 
ad2d			.IF: 
ad2d				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ad2d 1e				db WORD_SYS_CORE+10             
ad2e 22 ae			dw .THEN            
ad30 03				db 2 + 1 
ad31 .. 00			db "IF",0              
ad34				endm 
# End of macro CWHEAD
ad34			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ad34			; 
ad34					if DEBUG_FORTH_WORDS_KEY 
ad34						DMARK "IF." 
ad34 f5				push af  
ad35 3a 49 ad			ld a, (.dmark)  
ad38 32 71 ee			ld (debug_mark),a  
ad3b 3a 4a ad			ld a, (.dmark+1)  
ad3e 32 72 ee			ld (debug_mark+1),a  
ad41 3a 4b ad			ld a, (.dmark+2)  
ad44 32 73 ee			ld (debug_mark+2),a  
ad47 18 03			jr .pastdmark  
ad49 ..			.dmark: db "IF."  
ad4c f1			.pastdmark: pop af  
ad4d			endm  
# End of macro DMARK
ad4d						CALLMONITOR 
ad4d cd 6b 94			call break_point_state  
ad50				endm  
# End of macro CALLMONITOR
ad50					endif 
ad50			; eval TOS 
ad50			 
ad50				FORTH_DSP_VALUEHL 
ad50 cd d3 9c			call macro_dsp_valuehl 
ad53				endm 
# End of macro FORTH_DSP_VALUEHL
ad53			 
ad53			;	push hl 
ad53				FORTH_DSP_POP 
ad53 cd 8b 9d			call macro_forth_dsp_pop 
ad56				endm 
# End of macro FORTH_DSP_POP
ad56			;	pop hl 
ad56			 
ad56					if DEBUG_FORTH_WORDS 
ad56						DMARK "IF1" 
ad56 f5				push af  
ad57 3a 6b ad			ld a, (.dmark)  
ad5a 32 71 ee			ld (debug_mark),a  
ad5d 3a 6c ad			ld a, (.dmark+1)  
ad60 32 72 ee			ld (debug_mark+1),a  
ad63 3a 6d ad			ld a, (.dmark+2)  
ad66 32 73 ee			ld (debug_mark+2),a  
ad69 18 03			jr .pastdmark  
ad6b ..			.dmark: db "IF1"  
ad6e f1			.pastdmark: pop af  
ad6f			endm  
# End of macro DMARK
ad6f						CALLMONITOR 
ad6f cd 6b 94			call break_point_state  
ad72				endm  
# End of macro CALLMONITOR
ad72					endif 
ad72 b7				or a        ; clear carry flag 
ad73 11 00 00			ld de, 0 
ad76 eb				ex de,hl 
ad77 ed 52			sbc hl, de 
ad79 c2 03 ae			jp nz, .iftrue 
ad7c			 
ad7c					if DEBUG_FORTH_WORDS 
ad7c						DMARK "IF2" 
ad7c f5				push af  
ad7d 3a 91 ad			ld a, (.dmark)  
ad80 32 71 ee			ld (debug_mark),a  
ad83 3a 92 ad			ld a, (.dmark+1)  
ad86 32 72 ee			ld (debug_mark+1),a  
ad89 3a 93 ad			ld a, (.dmark+2)  
ad8c 32 73 ee			ld (debug_mark+2),a  
ad8f 18 03			jr .pastdmark  
ad91 ..			.dmark: db "IF2"  
ad94 f1			.pastdmark: pop af  
ad95			endm  
# End of macro DMARK
ad95						CALLMONITOR 
ad95 cd 6b 94			call break_point_state  
ad98				endm  
# End of macro CALLMONITOR
ad98					endif 
ad98			 
ad98			; if not true then skip to THEN 
ad98			 
ad98				; TODO get tok_ptr 
ad98				; TODO consume toks until we get to THEN 
ad98			 
ad98 2a 03 e6			ld hl, (os_tok_ptr) 
ad9b					if DEBUG_FORTH_WORDS 
ad9b						DMARK "IF3" 
ad9b f5				push af  
ad9c 3a b0 ad			ld a, (.dmark)  
ad9f 32 71 ee			ld (debug_mark),a  
ada2 3a b1 ad			ld a, (.dmark+1)  
ada5 32 72 ee			ld (debug_mark+1),a  
ada8 3a b2 ad			ld a, (.dmark+2)  
adab 32 73 ee			ld (debug_mark+2),a  
adae 18 03			jr .pastdmark  
adb0 ..			.dmark: db "IF3"  
adb3 f1			.pastdmark: pop af  
adb4			endm  
# End of macro DMARK
adb4						CALLMONITOR 
adb4 cd 6b 94			call break_point_state  
adb7				endm  
# End of macro CALLMONITOR
adb7						 
adb7					endif 
adb7 11 fe ad			ld de, .ifthen 
adba					if DEBUG_FORTH_WORDS 
adba						DMARK "IF4" 
adba f5				push af  
adbb 3a cf ad			ld a, (.dmark)  
adbe 32 71 ee			ld (debug_mark),a  
adc1 3a d0 ad			ld a, (.dmark+1)  
adc4 32 72 ee			ld (debug_mark+1),a  
adc7 3a d1 ad			ld a, (.dmark+2)  
adca 32 73 ee			ld (debug_mark+2),a  
adcd 18 03			jr .pastdmark  
adcf ..			.dmark: db "IF4"  
add2 f1			.pastdmark: pop af  
add3			endm  
# End of macro DMARK
add3						CALLMONITOR 
add3 cd 6b 94			call break_point_state  
add6				endm  
# End of macro CALLMONITOR
add6					endif 
add6 cd 65 9f			call findnexttok  
add9			 
add9					if DEBUG_FORTH_WORDS 
add9						DMARK "IF5" 
add9 f5				push af  
adda 3a ee ad			ld a, (.dmark)  
addd 32 71 ee			ld (debug_mark),a  
ade0 3a ef ad			ld a, (.dmark+1)  
ade3 32 72 ee			ld (debug_mark+1),a  
ade6 3a f0 ad			ld a, (.dmark+2)  
ade9 32 73 ee			ld (debug_mark+2),a  
adec 18 03			jr .pastdmark  
adee ..			.dmark: db "IF5"  
adf1 f1			.pastdmark: pop af  
adf2			endm  
# End of macro DMARK
adf2						CALLMONITOR 
adf2 cd 6b 94			call break_point_state  
adf5				endm  
# End of macro CALLMONITOR
adf5					endif 
adf5				; TODO replace below with ; exec using tok_ptr 
adf5 22 03 e6			ld (os_tok_ptr), hl 
adf8 c3 db 9e			jp exec1 
adfb				NEXTW 
adfb c3 4a 9e			jp macro_next 
adfe				endm 
# End of macro NEXTW
adfe			 
adfe .. 00		.ifthen:  db "THEN",0 
ae03			 
ae03			.iftrue:		 
ae03				; Exec next words normally 
ae03			 
ae03				; if true then exec following IF as normal 
ae03					if DEBUG_FORTH_WORDS 
ae03						DMARK "IFT" 
ae03 f5				push af  
ae04 3a 18 ae			ld a, (.dmark)  
ae07 32 71 ee			ld (debug_mark),a  
ae0a 3a 19 ae			ld a, (.dmark+1)  
ae0d 32 72 ee			ld (debug_mark+1),a  
ae10 3a 1a ae			ld a, (.dmark+2)  
ae13 32 73 ee			ld (debug_mark+2),a  
ae16 18 03			jr .pastdmark  
ae18 ..			.dmark: db "IFT"  
ae1b f1			.pastdmark: pop af  
ae1c			endm  
# End of macro DMARK
ae1c						CALLMONITOR 
ae1c cd 6b 94			call break_point_state  
ae1f				endm  
# End of macro CALLMONITOR
ae1f					endif 
ae1f			 
ae1f					NEXTW 
ae1f c3 4a 9e			jp macro_next 
ae22				endm 
# End of macro NEXTW
ae22			.THEN: 
ae22				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ae22 1f				db WORD_SYS_CORE+11             
ae23 4a ae			dw .ELSE            
ae25 05				db 4 + 1 
ae26 .. 00			db "THEN",0              
ae2b				endm 
# End of macro CWHEAD
ae2b			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ae2b					if DEBUG_FORTH_WORDS_KEY 
ae2b						DMARK "THN" 
ae2b f5				push af  
ae2c 3a 40 ae			ld a, (.dmark)  
ae2f 32 71 ee			ld (debug_mark),a  
ae32 3a 41 ae			ld a, (.dmark+1)  
ae35 32 72 ee			ld (debug_mark+1),a  
ae38 3a 42 ae			ld a, (.dmark+2)  
ae3b 32 73 ee			ld (debug_mark+2),a  
ae3e 18 03			jr .pastdmark  
ae40 ..			.dmark: db "THN"  
ae43 f1			.pastdmark: pop af  
ae44			endm  
# End of macro DMARK
ae44						CALLMONITOR 
ae44 cd 6b 94			call break_point_state  
ae47				endm  
# End of macro CALLMONITOR
ae47					endif 
ae47					NEXTW 
ae47 c3 4a 9e			jp macro_next 
ae4a				endm 
# End of macro NEXTW
ae4a			.ELSE: 
ae4a				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ae4a 20				db WORD_SYS_CORE+12             
ae4b 72 ae			dw .DO            
ae4d 03				db 2 + 1 
ae4e .. 00			db "ELSE",0              
ae53				endm 
# End of macro CWHEAD
ae53			; | ELSE ( -- ) Not supported - does nothing | TODO 
ae53			 
ae53					if DEBUG_FORTH_WORDS_KEY 
ae53						DMARK "ELS" 
ae53 f5				push af  
ae54 3a 68 ae			ld a, (.dmark)  
ae57 32 71 ee			ld (debug_mark),a  
ae5a 3a 69 ae			ld a, (.dmark+1)  
ae5d 32 72 ee			ld (debug_mark+1),a  
ae60 3a 6a ae			ld a, (.dmark+2)  
ae63 32 73 ee			ld (debug_mark+2),a  
ae66 18 03			jr .pastdmark  
ae68 ..			.dmark: db "ELS"  
ae6b f1			.pastdmark: pop af  
ae6c			endm  
# End of macro DMARK
ae6c						CALLMONITOR 
ae6c cd 6b 94			call break_point_state  
ae6f				endm  
# End of macro CALLMONITOR
ae6f					endif 
ae6f			 
ae6f			 
ae6f					NEXTW 
ae6f c3 4a 9e			jp macro_next 
ae72				endm 
# End of macro NEXTW
ae72			.DO: 
ae72				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ae72 21				db WORD_SYS_CORE+13             
ae73 99 af			dw .LOOP            
ae75 03				db 2 + 1 
ae76 .. 00			db "DO",0              
ae79				endm 
# End of macro CWHEAD
ae79			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ae79			 
ae79					if DEBUG_FORTH_WORDS_KEY 
ae79						DMARK "DO." 
ae79 f5				push af  
ae7a 3a 8e ae			ld a, (.dmark)  
ae7d 32 71 ee			ld (debug_mark),a  
ae80 3a 8f ae			ld a, (.dmark+1)  
ae83 32 72 ee			ld (debug_mark+1),a  
ae86 3a 90 ae			ld a, (.dmark+2)  
ae89 32 73 ee			ld (debug_mark+2),a  
ae8c 18 03			jr .pastdmark  
ae8e ..			.dmark: db "DO."  
ae91 f1			.pastdmark: pop af  
ae92			endm  
# End of macro DMARK
ae92						CALLMONITOR 
ae92 cd 6b 94			call break_point_state  
ae95				endm  
# End of macro CALLMONITOR
ae95					endif 
ae95			;  push pc to rsp stack past the DO 
ae95			 
ae95 2a 03 e6				ld hl, (os_tok_ptr) 
ae98 23					inc hl   ; D 
ae99 23					inc hl  ; O 
ae9a 23					inc hl   ; null 
ae9b					if DEBUG_FORTH_WORDS 
ae9b						DMARK "DO2" 
ae9b f5				push af  
ae9c 3a b0 ae			ld a, (.dmark)  
ae9f 32 71 ee			ld (debug_mark),a  
aea2 3a b1 ae			ld a, (.dmark+1)  
aea5 32 72 ee			ld (debug_mark+1),a  
aea8 3a b2 ae			ld a, (.dmark+2)  
aeab 32 73 ee			ld (debug_mark+2),a  
aeae 18 03			jr .pastdmark  
aeb0 ..			.dmark: db "DO2"  
aeb3 f1			.pastdmark: pop af  
aeb4			endm  
# End of macro DMARK
aeb4						CALLMONITOR 
aeb4 cd 6b 94			call break_point_state  
aeb7				endm  
# End of macro CALLMONITOR
aeb7					endif 
aeb7					FORTH_RSP_NEXT 
aeb7 cd 83 9a			call macro_forth_rsp_next 
aeba				endm 
# End of macro FORTH_RSP_NEXT
aeba					if DEBUG_FORTH_WORDS 
aeba						DMARK "DO3" 
aeba f5				push af  
aebb 3a cf ae			ld a, (.dmark)  
aebe 32 71 ee			ld (debug_mark),a  
aec1 3a d0 ae			ld a, (.dmark+1)  
aec4 32 72 ee			ld (debug_mark+1),a  
aec7 3a d1 ae			ld a, (.dmark+2)  
aeca 32 73 ee			ld (debug_mark+2),a  
aecd 18 03			jr .pastdmark  
aecf ..			.dmark: db "DO3"  
aed2 f1			.pastdmark: pop af  
aed3			endm  
# End of macro DMARK
aed3						CALLMONITOR 
aed3 cd 6b 94			call break_point_state  
aed6				endm  
# End of macro CALLMONITOR
aed6					endif 
aed6			 
aed6					;if DEBUG_FORTH_WORDS 
aed6				;		push hl 
aed6			;		endif  
aed6			 
aed6			; get counters from data stack 
aed6			 
aed6			 
aed6					FORTH_DSP_VALUEHL 
aed6 cd d3 9c			call macro_dsp_valuehl 
aed9				endm 
# End of macro FORTH_DSP_VALUEHL
aed9 e5					push hl		 ; hl now has starting counter which needs to be tos 
aeda			 
aeda					if DEBUG_FORTH_WORDS 
aeda						DMARK "DO4" 
aeda f5				push af  
aedb 3a ef ae			ld a, (.dmark)  
aede 32 71 ee			ld (debug_mark),a  
aee1 3a f0 ae			ld a, (.dmark+1)  
aee4 32 72 ee			ld (debug_mark+1),a  
aee7 3a f1 ae			ld a, (.dmark+2)  
aeea 32 73 ee			ld (debug_mark+2),a  
aeed 18 03			jr .pastdmark  
aeef ..			.dmark: db "DO4"  
aef2 f1			.pastdmark: pop af  
aef3			endm  
# End of macro DMARK
aef3						CALLMONITOR 
aef3 cd 6b 94			call break_point_state  
aef6				endm  
# End of macro CALLMONITOR
aef6					endif 
aef6					FORTH_DSP_POP 
aef6 cd 8b 9d			call macro_forth_dsp_pop 
aef9				endm 
# End of macro FORTH_DSP_POP
aef9			 
aef9					if DEBUG_FORTH_WORDS 
aef9						DMARK "DO5" 
aef9 f5				push af  
aefa 3a 0e af			ld a, (.dmark)  
aefd 32 71 ee			ld (debug_mark),a  
af00 3a 0f af			ld a, (.dmark+1)  
af03 32 72 ee			ld (debug_mark+1),a  
af06 3a 10 af			ld a, (.dmark+2)  
af09 32 73 ee			ld (debug_mark+2),a  
af0c 18 03			jr .pastdmark  
af0e ..			.dmark: db "DO5"  
af11 f1			.pastdmark: pop af  
af12			endm  
# End of macro DMARK
af12						CALLMONITOR 
af12 cd 6b 94			call break_point_state  
af15				endm  
# End of macro CALLMONITOR
af15					endif 
af15			 
af15					FORTH_DSP_VALUEHL 
af15 cd d3 9c			call macro_dsp_valuehl 
af18				endm 
# End of macro FORTH_DSP_VALUEHL
af18			;		push hl		 ; hl now has starting limit counter 
af18			 
af18					if DEBUG_FORTH_WORDS 
af18						DMARK "DO6" 
af18 f5				push af  
af19 3a 2d af			ld a, (.dmark)  
af1c 32 71 ee			ld (debug_mark),a  
af1f 3a 2e af			ld a, (.dmark+1)  
af22 32 72 ee			ld (debug_mark+1),a  
af25 3a 2f af			ld a, (.dmark+2)  
af28 32 73 ee			ld (debug_mark+2),a  
af2b 18 03			jr .pastdmark  
af2d ..			.dmark: db "DO6"  
af30 f1			.pastdmark: pop af  
af31			endm  
# End of macro DMARK
af31						CALLMONITOR 
af31 cd 6b 94			call break_point_state  
af34				endm  
# End of macro CALLMONITOR
af34					endif 
af34					FORTH_DSP_POP 
af34 cd 8b 9d			call macro_forth_dsp_pop 
af37				endm 
# End of macro FORTH_DSP_POP
af37			 
af37			; put counters on the loop stack 
af37			 
af37			;		pop hl			 ; limit counter 
af37 d1					pop de			; start counter 
af38			 
af38					; push limit counter 
af38			 
af38					if DEBUG_FORTH_WORDS 
af38						DMARK "DO7" 
af38 f5				push af  
af39 3a 4d af			ld a, (.dmark)  
af3c 32 71 ee			ld (debug_mark),a  
af3f 3a 4e af			ld a, (.dmark+1)  
af42 32 72 ee			ld (debug_mark+1),a  
af45 3a 4f af			ld a, (.dmark+2)  
af48 32 73 ee			ld (debug_mark+2),a  
af4b 18 03			jr .pastdmark  
af4d ..			.dmark: db "DO7"  
af50 f1			.pastdmark: pop af  
af51			endm  
# End of macro DMARK
af51						CALLMONITOR 
af51 cd 6b 94			call break_point_state  
af54				endm  
# End of macro CALLMONITOR
af54					endif 
af54					FORTH_LOOP_NEXT 
af54 cd 04 9d			call macro_forth_loop_next 
af57				endm 
# End of macro FORTH_LOOP_NEXT
af57			 
af57					; push start counter 
af57			 
af57 eb					ex de, hl 
af58					if DEBUG_FORTH_WORDS 
af58						DMARK "DO7" 
af58 f5				push af  
af59 3a 6d af			ld a, (.dmark)  
af5c 32 71 ee			ld (debug_mark),a  
af5f 3a 6e af			ld a, (.dmark+1)  
af62 32 72 ee			ld (debug_mark+1),a  
af65 3a 6f af			ld a, (.dmark+2)  
af68 32 73 ee			ld (debug_mark+2),a  
af6b 18 03			jr .pastdmark  
af6d ..			.dmark: db "DO7"  
af70 f1			.pastdmark: pop af  
af71			endm  
# End of macro DMARK
af71						CALLMONITOR 
af71 cd 6b 94			call break_point_state  
af74				endm  
# End of macro CALLMONITOR
af74					endif 
af74					FORTH_LOOP_NEXT 
af74 cd 04 9d			call macro_forth_loop_next 
af77				endm 
# End of macro FORTH_LOOP_NEXT
af77			 
af77			 
af77					; init first round of I counter 
af77			 
af77 22 27 e6				ld (os_current_i), hl 
af7a			 
af7a					if DEBUG_FORTH_WORDS 
af7a						DMARK "DO8" 
af7a f5				push af  
af7b 3a 8f af			ld a, (.dmark)  
af7e 32 71 ee			ld (debug_mark),a  
af81 3a 90 af			ld a, (.dmark+1)  
af84 32 72 ee			ld (debug_mark+1),a  
af87 3a 91 af			ld a, (.dmark+2)  
af8a 32 73 ee			ld (debug_mark+2),a  
af8d 18 03			jr .pastdmark  
af8f ..			.dmark: db "DO8"  
af92 f1			.pastdmark: pop af  
af93			endm  
# End of macro DMARK
af93						CALLMONITOR 
af93 cd 6b 94			call break_point_state  
af96				endm  
# End of macro CALLMONITOR
af96					endif 
af96			 
af96					NEXTW 
af96 c3 4a 9e			jp macro_next 
af99				endm 
# End of macro NEXTW
af99			.LOOP: 
af99				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
af99 22				db WORD_SYS_CORE+14             
af9a b1 b0			dw .I            
af9c 05				db 4 + 1 
af9d .. 00			db "LOOP",0              
afa2				endm 
# End of macro CWHEAD
afa2			; | LOOP ( -- ) Increment and test loop counter  | DONE 
afa2			 
afa2				; pop tos as current loop count to hl 
afa2			 
afa2				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
afa2			 
afa2				FORTH_LOOP_TOS 
afa2 cd 37 9d			call macro_forth_loop_tos 
afa5				endm 
# End of macro FORTH_LOOP_TOS
afa5 e5				push hl 
afa6			 
afa6					if DEBUG_FORTH_WORDS_KEY 
afa6						DMARK "LOP" 
afa6 f5				push af  
afa7 3a bb af			ld a, (.dmark)  
afaa 32 71 ee			ld (debug_mark),a  
afad 3a bc af			ld a, (.dmark+1)  
afb0 32 72 ee			ld (debug_mark+1),a  
afb3 3a bd af			ld a, (.dmark+2)  
afb6 32 73 ee			ld (debug_mark+2),a  
afb9 18 03			jr .pastdmark  
afbb ..			.dmark: db "LOP"  
afbe f1			.pastdmark: pop af  
afbf			endm  
# End of macro DMARK
afbf						CALLMONITOR 
afbf cd 6b 94			call break_point_state  
afc2				endm  
# End of macro CALLMONITOR
afc2					endif 
afc2				; next item on the stack is the limit. get it 
afc2			 
afc2			 
afc2				FORTH_LOOP_POP 
afc2 cd 41 9d			call macro_forth_loop_pop 
afc5				endm 
# End of macro FORTH_LOOP_POP
afc5			 
afc5				FORTH_LOOP_TOS 
afc5 cd 37 9d			call macro_forth_loop_tos 
afc8				endm 
# End of macro FORTH_LOOP_TOS
afc8			 
afc8 d1				pop de		 ; de = i, hl = limit 
afc9			 
afc9					if DEBUG_FORTH_WORDS 
afc9						DMARK "LP1" 
afc9 f5				push af  
afca 3a de af			ld a, (.dmark)  
afcd 32 71 ee			ld (debug_mark),a  
afd0 3a df af			ld a, (.dmark+1)  
afd3 32 72 ee			ld (debug_mark+1),a  
afd6 3a e0 af			ld a, (.dmark+2)  
afd9 32 73 ee			ld (debug_mark+2),a  
afdc 18 03			jr .pastdmark  
afde ..			.dmark: db "LP1"  
afe1 f1			.pastdmark: pop af  
afe2			endm  
# End of macro DMARK
afe2						CALLMONITOR 
afe2 cd 6b 94			call break_point_state  
afe5				endm  
# End of macro CALLMONITOR
afe5					endif 
afe5			 
afe5				; go back to previous word 
afe5			 
afe5 d5				push de    ; save I for inc later 
afe6			 
afe6			 
afe6				; get limit 
afe6				;  is I at limit? 
afe6			 
afe6			 
afe6					if DEBUG_FORTH_WORDS 
afe6						DMARK "LP1" 
afe6 f5				push af  
afe7 3a fb af			ld a, (.dmark)  
afea 32 71 ee			ld (debug_mark),a  
afed 3a fc af			ld a, (.dmark+1)  
aff0 32 72 ee			ld (debug_mark+1),a  
aff3 3a fd af			ld a, (.dmark+2)  
aff6 32 73 ee			ld (debug_mark+2),a  
aff9 18 03			jr .pastdmark  
affb ..			.dmark: db "LP1"  
affe f1			.pastdmark: pop af  
afff			endm  
# End of macro DMARK
afff						CALLMONITOR 
afff cd 6b 94			call break_point_state  
b002				endm  
# End of macro CALLMONITOR
b002					endif 
b002			 
b002 ed 52			sbc hl, de 
b004			 
b004			 
b004				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b004			 
b004 20 26				jr nz, .loopnotdone 
b006			 
b006 e1				pop hl   ; get rid of saved I 
b007				FORTH_LOOP_POP     ; get rid of limit 
b007 cd 41 9d			call macro_forth_loop_pop 
b00a				endm 
# End of macro FORTH_LOOP_POP
b00a			 
b00a				FORTH_RSP_POP     ; get rid of DO ptr 
b00a cd a4 9a			call macro_forth_rsp_pop 
b00d				endm 
# End of macro FORTH_RSP_POP
b00d			 
b00d			if DEBUG_FORTH_WORDS 
b00d						DMARK "LP>" 
b00d f5				push af  
b00e 3a 22 b0			ld a, (.dmark)  
b011 32 71 ee			ld (debug_mark),a  
b014 3a 23 b0			ld a, (.dmark+1)  
b017 32 72 ee			ld (debug_mark+1),a  
b01a 3a 24 b0			ld a, (.dmark+2)  
b01d 32 73 ee			ld (debug_mark+2),a  
b020 18 03			jr .pastdmark  
b022 ..			.dmark: db "LP>"  
b025 f1			.pastdmark: pop af  
b026			endm  
# End of macro DMARK
b026				CALLMONITOR 
b026 cd 6b 94			call break_point_state  
b029				endm  
# End of macro CALLMONITOR
b029			endif 
b029			 
b029					NEXTW 
b029 c3 4a 9e			jp macro_next 
b02c				endm 
# End of macro NEXTW
b02c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b02c			 
b02c			.loopnotdone: 
b02c			 
b02c e1				pop hl    ; get I 
b02d 23				inc hl 
b02e			 
b02e			   	; save new I 
b02e			 
b02e			 
b02e					; set I counter 
b02e			 
b02e 22 27 e6				ld (os_current_i), hl 
b031			 
b031					if DEBUG_FORTH_WORDS 
b031						DMARK "LPN" 
b031 f5				push af  
b032 3a 46 b0			ld a, (.dmark)  
b035 32 71 ee			ld (debug_mark),a  
b038 3a 47 b0			ld a, (.dmark+1)  
b03b 32 72 ee			ld (debug_mark+1),a  
b03e 3a 48 b0			ld a, (.dmark+2)  
b041 32 73 ee			ld (debug_mark+2),a  
b044 18 03			jr .pastdmark  
b046 ..			.dmark: db "LPN"  
b049 f1			.pastdmark: pop af  
b04a			endm  
# End of macro DMARK
b04a					CALLMONITOR 
b04a cd 6b 94			call break_point_state  
b04d				endm  
# End of macro CALLMONITOR
b04d					endif 
b04d					 
b04d				FORTH_LOOP_NEXT 
b04d cd 04 9d			call macro_forth_loop_next 
b050				endm 
# End of macro FORTH_LOOP_NEXT
b050			 
b050			 
b050					if DEBUG_FORTH_WORDS 
b050 eb						ex de,hl 
b051					endif 
b051			 
b051			;	; get DO ptr 
b051			; 
b051					if DEBUG_FORTH_WORDS 
b051						DMARK "LP7" 
b051 f5				push af  
b052 3a 66 b0			ld a, (.dmark)  
b055 32 71 ee			ld (debug_mark),a  
b058 3a 67 b0			ld a, (.dmark+1)  
b05b 32 72 ee			ld (debug_mark+1),a  
b05e 3a 68 b0			ld a, (.dmark+2)  
b061 32 73 ee			ld (debug_mark+2),a  
b064 18 03			jr .pastdmark  
b066 ..			.dmark: db "LP7"  
b069 f1			.pastdmark: pop af  
b06a			endm  
# End of macro DMARK
b06a					CALLMONITOR 
b06a cd 6b 94			call break_point_state  
b06d				endm  
# End of macro CALLMONITOR
b06d					endif 
b06d				FORTH_RSP_TOS 
b06d cd 9a 9a			call macro_forth_rsp_tos 
b070				endm 
# End of macro FORTH_RSP_TOS
b070			 
b070					if DEBUG_FORTH_WORDS 
b070						DMARK "LP8" 
b070 f5				push af  
b071 3a 85 b0			ld a, (.dmark)  
b074 32 71 ee			ld (debug_mark),a  
b077 3a 86 b0			ld a, (.dmark+1)  
b07a 32 72 ee			ld (debug_mark+1),a  
b07d 3a 87 b0			ld a, (.dmark+2)  
b080 32 73 ee			ld (debug_mark+2),a  
b083 18 03			jr .pastdmark  
b085 ..			.dmark: db "LP8"  
b088 f1			.pastdmark: pop af  
b089			endm  
# End of macro DMARK
b089					CALLMONITOR 
b089 cd 6b 94			call break_point_state  
b08c				endm  
# End of macro CALLMONITOR
b08c					endif 
b08c				;push hl 
b08c			 
b08c				; not going to DO any more 
b08c				; get rid of the RSP pointer as DO will add it back in 
b08c				;FORTH_RSP_POP 
b08c				;pop hl 
b08c			 
b08c				;ld hl,(cli_ret_sp) 
b08c				;ld e, (hl) 
b08c				;inc hl 
b08c				;ld d, (hl) 
b08c				;ex de,hl 
b08c 22 03 e6			ld (os_tok_ptr), hl 
b08f					if DEBUG_FORTH_WORDS 
b08f						DMARK "LP<" 
b08f f5				push af  
b090 3a a4 b0			ld a, (.dmark)  
b093 32 71 ee			ld (debug_mark),a  
b096 3a a5 b0			ld a, (.dmark+1)  
b099 32 72 ee			ld (debug_mark+1),a  
b09c 3a a6 b0			ld a, (.dmark+2)  
b09f 32 73 ee			ld (debug_mark+2),a  
b0a2 18 03			jr .pastdmark  
b0a4 ..			.dmark: db "LP<"  
b0a7 f1			.pastdmark: pop af  
b0a8			endm  
# End of macro DMARK
b0a8					CALLMONITOR 
b0a8 cd 6b 94			call break_point_state  
b0ab				endm  
# End of macro CALLMONITOR
b0ab				endif 
b0ab c3 db 9e			jp exec1 
b0ae			 
b0ae					 
b0ae			 
b0ae			 
b0ae					NEXTW 
b0ae c3 4a 9e			jp macro_next 
b0b1				endm 
# End of macro NEXTW
b0b1			.I:  
b0b1			 
b0b1				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b0b1 5e				db WORD_SYS_CORE+74             
b0b2 dc b0			dw .DLOOP            
b0b4 02				db 1 + 1 
b0b5 .. 00			db "I",0              
b0b7				endm 
# End of macro CWHEAD
b0b7			; | I ( -- ) Current loop counter | DONE 
b0b7					if DEBUG_FORTH_WORDS_KEY 
b0b7						DMARK "I.." 
b0b7 f5				push af  
b0b8 3a cc b0			ld a, (.dmark)  
b0bb 32 71 ee			ld (debug_mark),a  
b0be 3a cd b0			ld a, (.dmark+1)  
b0c1 32 72 ee			ld (debug_mark+1),a  
b0c4 3a ce b0			ld a, (.dmark+2)  
b0c7 32 73 ee			ld (debug_mark+2),a  
b0ca 18 03			jr .pastdmark  
b0cc ..			.dmark: db "I.."  
b0cf f1			.pastdmark: pop af  
b0d0			endm  
# End of macro DMARK
b0d0						CALLMONITOR 
b0d0 cd 6b 94			call break_point_state  
b0d3				endm  
# End of macro CALLMONITOR
b0d3					endif 
b0d3			 
b0d3 2a 27 e6				ld hl,(os_current_i) 
b0d6 cd dc 9a				call forth_push_numhl 
b0d9			 
b0d9					NEXTW 
b0d9 c3 4a 9e			jp macro_next 
b0dc				endm 
# End of macro NEXTW
b0dc			.DLOOP: 
b0dc				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b0dc 5f				db WORD_SYS_CORE+75             
b0dd bd b1			dw .REPEAT            
b0df 06				db 5 + 1 
b0e0 .. 00			db "-LOOP",0              
b0e6				endm 
# End of macro CWHEAD
b0e6			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b0e6				; pop tos as current loop count to hl 
b0e6					if DEBUG_FORTH_WORDS_KEY 
b0e6						DMARK "-LP" 
b0e6 f5				push af  
b0e7 3a fb b0			ld a, (.dmark)  
b0ea 32 71 ee			ld (debug_mark),a  
b0ed 3a fc b0			ld a, (.dmark+1)  
b0f0 32 72 ee			ld (debug_mark+1),a  
b0f3 3a fd b0			ld a, (.dmark+2)  
b0f6 32 73 ee			ld (debug_mark+2),a  
b0f9 18 03			jr .pastdmark  
b0fb ..			.dmark: db "-LP"  
b0fe f1			.pastdmark: pop af  
b0ff			endm  
# End of macro DMARK
b0ff						CALLMONITOR 
b0ff cd 6b 94			call break_point_state  
b102				endm  
# End of macro CALLMONITOR
b102					endif 
b102			 
b102				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b102			 
b102				FORTH_LOOP_TOS 
b102 cd 37 9d			call macro_forth_loop_tos 
b105				endm 
# End of macro FORTH_LOOP_TOS
b105 e5				push hl 
b106			 
b106					if DEBUG_FORTH_WORDS 
b106						DMARK "-LP" 
b106 f5				push af  
b107 3a 1b b1			ld a, (.dmark)  
b10a 32 71 ee			ld (debug_mark),a  
b10d 3a 1c b1			ld a, (.dmark+1)  
b110 32 72 ee			ld (debug_mark+1),a  
b113 3a 1d b1			ld a, (.dmark+2)  
b116 32 73 ee			ld (debug_mark+2),a  
b119 18 03			jr .pastdmark  
b11b ..			.dmark: db "-LP"  
b11e f1			.pastdmark: pop af  
b11f			endm  
# End of macro DMARK
b11f						CALLMONITOR 
b11f cd 6b 94			call break_point_state  
b122				endm  
# End of macro CALLMONITOR
b122					endif 
b122				; next item on the stack is the limit. get it 
b122			 
b122			 
b122				FORTH_LOOP_POP 
b122 cd 41 9d			call macro_forth_loop_pop 
b125				endm 
# End of macro FORTH_LOOP_POP
b125			 
b125				FORTH_LOOP_TOS 
b125 cd 37 9d			call macro_forth_loop_tos 
b128				endm 
# End of macro FORTH_LOOP_TOS
b128			 
b128 d1				pop de		 ; de = i, hl = limit 
b129			 
b129					if DEBUG_FORTH_WORDS 
b129						DMARK "-L1" 
b129 f5				push af  
b12a 3a 3e b1			ld a, (.dmark)  
b12d 32 71 ee			ld (debug_mark),a  
b130 3a 3f b1			ld a, (.dmark+1)  
b133 32 72 ee			ld (debug_mark+1),a  
b136 3a 40 b1			ld a, (.dmark+2)  
b139 32 73 ee			ld (debug_mark+2),a  
b13c 18 03			jr .pastdmark  
b13e ..			.dmark: db "-L1"  
b141 f1			.pastdmark: pop af  
b142			endm  
# End of macro DMARK
b142						CALLMONITOR 
b142 cd 6b 94			call break_point_state  
b145				endm  
# End of macro CALLMONITOR
b145					endif 
b145			 
b145				; go back to previous word 
b145			 
b145 d5				push de    ; save I for inc later 
b146			 
b146			 
b146				; get limit 
b146				;  is I at limit? 
b146			 
b146			 
b146					if DEBUG_FORTH_WORDS 
b146						DMARK "-L1" 
b146 f5				push af  
b147 3a 5b b1			ld a, (.dmark)  
b14a 32 71 ee			ld (debug_mark),a  
b14d 3a 5c b1			ld a, (.dmark+1)  
b150 32 72 ee			ld (debug_mark+1),a  
b153 3a 5d b1			ld a, (.dmark+2)  
b156 32 73 ee			ld (debug_mark+2),a  
b159 18 03			jr .pastdmark  
b15b ..			.dmark: db "-L1"  
b15e f1			.pastdmark: pop af  
b15f			endm  
# End of macro DMARK
b15f						CALLMONITOR 
b15f cd 6b 94			call break_point_state  
b162				endm  
# End of macro CALLMONITOR
b162					endif 
b162			 
b162 ed 52			sbc hl, de 
b164			 
b164			 
b164				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b164			 
b164 20 26				jr nz, .mloopnotdone 
b166			 
b166 e1				pop hl   ; get rid of saved I 
b167				FORTH_LOOP_POP     ; get rid of limit 
b167 cd 41 9d			call macro_forth_loop_pop 
b16a				endm 
# End of macro FORTH_LOOP_POP
b16a			 
b16a				FORTH_RSP_POP     ; get rid of DO ptr 
b16a cd a4 9a			call macro_forth_rsp_pop 
b16d				endm 
# End of macro FORTH_RSP_POP
b16d			 
b16d			if DEBUG_FORTH_WORDS 
b16d						DMARK "-L>" 
b16d f5				push af  
b16e 3a 82 b1			ld a, (.dmark)  
b171 32 71 ee			ld (debug_mark),a  
b174 3a 83 b1			ld a, (.dmark+1)  
b177 32 72 ee			ld (debug_mark+1),a  
b17a 3a 84 b1			ld a, (.dmark+2)  
b17d 32 73 ee			ld (debug_mark+2),a  
b180 18 03			jr .pastdmark  
b182 ..			.dmark: db "-L>"  
b185 f1			.pastdmark: pop af  
b186			endm  
# End of macro DMARK
b186				CALLMONITOR 
b186 cd 6b 94			call break_point_state  
b189				endm  
# End of macro CALLMONITOR
b189			endif 
b189			 
b189					NEXTW 
b189 c3 4a 9e			jp macro_next 
b18c				endm 
# End of macro NEXTW
b18c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b18c			 
b18c			.mloopnotdone: 
b18c			 
b18c e1				pop hl    ; get I 
b18d 2b				dec hl 
b18e			 
b18e			   	; save new I 
b18e			 
b18e			 
b18e					; set I counter 
b18e			 
b18e 22 27 e6				ld (os_current_i), hl 
b191			 
b191					 
b191				FORTH_LOOP_NEXT 
b191 cd 04 9d			call macro_forth_loop_next 
b194				endm 
# End of macro FORTH_LOOP_NEXT
b194			 
b194			 
b194					if DEBUG_FORTH_WORDS 
b194 eb						ex de,hl 
b195					endif 
b195			 
b195			;	; get DO ptr 
b195			; 
b195				FORTH_RSP_TOS 
b195 cd 9a 9a			call macro_forth_rsp_tos 
b198				endm 
# End of macro FORTH_RSP_TOS
b198			 
b198				;push hl 
b198			 
b198				; not going to DO any more 
b198				; get rid of the RSP pointer as DO will add it back in 
b198				;FORTH_RSP_POP 
b198				;pop hl 
b198			 
b198			 
b198 22 03 e6			ld (os_tok_ptr), hl 
b19b					if DEBUG_FORTH_WORDS 
b19b						DMARK "-L<" 
b19b f5				push af  
b19c 3a b0 b1			ld a, (.dmark)  
b19f 32 71 ee			ld (debug_mark),a  
b1a2 3a b1 b1			ld a, (.dmark+1)  
b1a5 32 72 ee			ld (debug_mark+1),a  
b1a8 3a b2 b1			ld a, (.dmark+2)  
b1ab 32 73 ee			ld (debug_mark+2),a  
b1ae 18 03			jr .pastdmark  
b1b0 ..			.dmark: db "-L<"  
b1b3 f1			.pastdmark: pop af  
b1b4			endm  
# End of macro DMARK
b1b4					CALLMONITOR 
b1b4 cd 6b 94			call break_point_state  
b1b7				endm  
# End of macro CALLMONITOR
b1b7				endif 
b1b7 c3 db 9e			jp exec1 
b1ba			 
b1ba					 
b1ba			 
b1ba			 
b1ba			 
b1ba				NEXTW 
b1ba c3 4a 9e			jp macro_next 
b1bd				endm 
# End of macro NEXTW
b1bd			 
b1bd			 
b1bd			 
b1bd			 
b1bd			.REPEAT: 
b1bd				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b1bd 71				db WORD_SYS_CORE+93             
b1be 10 b2			dw .UNTIL            
b1c0 06				db 5 + 1 
b1c1 .. 00			db "REPEAT",0              
b1c8				endm 
# End of macro CWHEAD
b1c8			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b1c8			;  push pc to rsp stack past the REPEAT 
b1c8					if DEBUG_FORTH_WORDS_KEY 
b1c8						DMARK "REP" 
b1c8 f5				push af  
b1c9 3a dd b1			ld a, (.dmark)  
b1cc 32 71 ee			ld (debug_mark),a  
b1cf 3a de b1			ld a, (.dmark+1)  
b1d2 32 72 ee			ld (debug_mark+1),a  
b1d5 3a df b1			ld a, (.dmark+2)  
b1d8 32 73 ee			ld (debug_mark+2),a  
b1db 18 03			jr .pastdmark  
b1dd ..			.dmark: db "REP"  
b1e0 f1			.pastdmark: pop af  
b1e1			endm  
# End of macro DMARK
b1e1						CALLMONITOR 
b1e1 cd 6b 94			call break_point_state  
b1e4				endm  
# End of macro CALLMONITOR
b1e4					endif 
b1e4			 
b1e4 2a 03 e6				ld hl, (os_tok_ptr) 
b1e7 23					inc hl   ; R 
b1e8 23					inc hl  ; E 
b1e9 23					inc hl   ; P 
b1ea 23					inc hl   ; E 
b1eb 23					inc hl   ; A 
b1ec 23					inc hl   ; T 
b1ed 23					inc hl   ; zero 
b1ee					FORTH_RSP_NEXT 
b1ee cd 83 9a			call macro_forth_rsp_next 
b1f1				endm 
# End of macro FORTH_RSP_NEXT
b1f1			 
b1f1			 
b1f1					if DEBUG_FORTH_WORDS 
b1f1						DMARK "REP" 
b1f1 f5				push af  
b1f2 3a 06 b2			ld a, (.dmark)  
b1f5 32 71 ee			ld (debug_mark),a  
b1f8 3a 07 b2			ld a, (.dmark+1)  
b1fb 32 72 ee			ld (debug_mark+1),a  
b1fe 3a 08 b2			ld a, (.dmark+2)  
b201 32 73 ee			ld (debug_mark+2),a  
b204 18 03			jr .pastdmark  
b206 ..			.dmark: db "REP"  
b209 f1			.pastdmark: pop af  
b20a			endm  
# End of macro DMARK
b20a						;pop bc    ; TODO BUG ?????? what is this for???? 
b20a						CALLMONITOR 
b20a cd 6b 94			call break_point_state  
b20d				endm  
# End of macro CALLMONITOR
b20d					endif 
b20d			 
b20d					NEXTW 
b20d c3 4a 9e			jp macro_next 
b210				endm 
# End of macro NEXTW
b210			;	       NEXTW 
b210			 
b210			.UNTIL: 
b210				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b210 72				db WORD_SYS_CORE+94             
b211 a7 b2			dw .ENDFLOW            
b213 06				db 5 + 1 
b214 .. 00			db "UNTIL",0              
b21a				endm 
# End of macro CWHEAD
b21a			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b21a			 
b21a				; pop tos as check 
b21a			 
b21a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b21a			 
b21a				FORTH_DSP_VALUEHL 
b21a cd d3 9c			call macro_dsp_valuehl 
b21d				endm 
# End of macro FORTH_DSP_VALUEHL
b21d			 
b21d					if DEBUG_FORTH_WORDS_KEY 
b21d						DMARK "UNT" 
b21d f5				push af  
b21e 3a 32 b2			ld a, (.dmark)  
b221 32 71 ee			ld (debug_mark),a  
b224 3a 33 b2			ld a, (.dmark+1)  
b227 32 72 ee			ld (debug_mark+1),a  
b22a 3a 34 b2			ld a, (.dmark+2)  
b22d 32 73 ee			ld (debug_mark+2),a  
b230 18 03			jr .pastdmark  
b232 ..			.dmark: db "UNT"  
b235 f1			.pastdmark: pop af  
b236			endm  
# End of macro DMARK
b236						CALLMONITOR 
b236 cd 6b 94			call break_point_state  
b239				endm  
# End of macro CALLMONITOR
b239					endif 
b239			 
b239			;	push hl 
b239				FORTH_DSP_POP 
b239 cd 8b 9d			call macro_forth_dsp_pop 
b23c				endm 
# End of macro FORTH_DSP_POP
b23c			 
b23c			;	pop hl 
b23c			 
b23c				; test if true 
b23c			 
b23c cd 93 8c			call ishlzero 
b23f			;	ld a,l 
b23f			;	add h 
b23f			; 
b23f			;	cp 0 
b23f			 
b23f 20 3e			jr nz, .untilnotdone 
b241			 
b241					if DEBUG_FORTH_WORDS 
b241						DMARK "UNf" 
b241 f5				push af  
b242 3a 56 b2			ld a, (.dmark)  
b245 32 71 ee			ld (debug_mark),a  
b248 3a 57 b2			ld a, (.dmark+1)  
b24b 32 72 ee			ld (debug_mark+1),a  
b24e 3a 58 b2			ld a, (.dmark+2)  
b251 32 73 ee			ld (debug_mark+2),a  
b254 18 03			jr .pastdmark  
b256 ..			.dmark: db "UNf"  
b259 f1			.pastdmark: pop af  
b25a			endm  
# End of macro DMARK
b25a						CALLMONITOR 
b25a cd 6b 94			call break_point_state  
b25d				endm  
# End of macro CALLMONITOR
b25d					endif 
b25d			 
b25d			 
b25d			 
b25d				FORTH_RSP_POP     ; get rid of DO ptr 
b25d cd a4 9a			call macro_forth_rsp_pop 
b260				endm 
# End of macro FORTH_RSP_POP
b260			 
b260			if DEBUG_FORTH_WORDS 
b260						DMARK "UN>" 
b260 f5				push af  
b261 3a 75 b2			ld a, (.dmark)  
b264 32 71 ee			ld (debug_mark),a  
b267 3a 76 b2			ld a, (.dmark+1)  
b26a 32 72 ee			ld (debug_mark+1),a  
b26d 3a 77 b2			ld a, (.dmark+2)  
b270 32 73 ee			ld (debug_mark+2),a  
b273 18 03			jr .pastdmark  
b275 ..			.dmark: db "UN>"  
b278 f1			.pastdmark: pop af  
b279			endm  
# End of macro DMARK
b279				CALLMONITOR 
b279 cd 6b 94			call break_point_state  
b27c				endm  
# End of macro CALLMONITOR
b27c			endif 
b27c			 
b27c					NEXTW 
b27c c3 4a 9e			jp macro_next 
b27f				endm 
# End of macro NEXTW
b27f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b27f			 
b27f			.untilnotdone: 
b27f			 
b27f			 
b27f			;	; get DO ptr 
b27f			; 
b27f				FORTH_RSP_TOS 
b27f cd 9a 9a			call macro_forth_rsp_tos 
b282				endm 
# End of macro FORTH_RSP_TOS
b282			 
b282				;push hl 
b282			 
b282				; not going to DO any more 
b282				; get rid of the RSP pointer as DO will add it back in 
b282				;FORTH_RSP_POP 
b282				;pop hl 
b282			 
b282			 
b282 22 03 e6			ld (os_tok_ptr), hl 
b285					if DEBUG_FORTH_WORDS 
b285						DMARK "UN<" 
b285 f5				push af  
b286 3a 9a b2			ld a, (.dmark)  
b289 32 71 ee			ld (debug_mark),a  
b28c 3a 9b b2			ld a, (.dmark+1)  
b28f 32 72 ee			ld (debug_mark+1),a  
b292 3a 9c b2			ld a, (.dmark+2)  
b295 32 73 ee			ld (debug_mark+2),a  
b298 18 03			jr .pastdmark  
b29a ..			.dmark: db "UN<"  
b29d f1			.pastdmark: pop af  
b29e			endm  
# End of macro DMARK
b29e					CALLMONITOR 
b29e cd 6b 94			call break_point_state  
b2a1				endm  
# End of macro CALLMONITOR
b2a1				endif 
b2a1 c3 db 9e			jp exec1 
b2a4			 
b2a4					 
b2a4			 
b2a4			 
b2a4					NEXTW 
b2a4 c3 4a 9e			jp macro_next 
b2a7				endm 
# End of macro NEXTW
b2a7			 
b2a7			 
b2a7			.ENDFLOW: 
b2a7			 
b2a7			; eof 
b2a7			 
# End of file forth_words_flow.asm
b2a7			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b2a7			include "forth_words_logic.asm" 
b2a7			 
b2a7			; | ## Logic Words 
b2a7			 
b2a7			.NOT: 
b2a7				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b2a7 2d				db WORD_SYS_CORE+25             
b2a8 ef b2			dw .IS            
b2aa 04				db 3 + 1 
b2ab .. 00			db "NOT",0              
b2af				endm 
# End of macro CWHEAD
b2af			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b2af					if DEBUG_FORTH_WORDS_KEY 
b2af						DMARK "NOT" 
b2af f5				push af  
b2b0 3a c4 b2			ld a, (.dmark)  
b2b3 32 71 ee			ld (debug_mark),a  
b2b6 3a c5 b2			ld a, (.dmark+1)  
b2b9 32 72 ee			ld (debug_mark+1),a  
b2bc 3a c6 b2			ld a, (.dmark+2)  
b2bf 32 73 ee			ld (debug_mark+2),a  
b2c2 18 03			jr .pastdmark  
b2c4 ..			.dmark: db "NOT"  
b2c7 f1			.pastdmark: pop af  
b2c8			endm  
# End of macro DMARK
b2c8						CALLMONITOR 
b2c8 cd 6b 94			call break_point_state  
b2cb				endm  
# End of macro CALLMONITOR
b2cb					endif 
b2cb					FORTH_DSP 
b2cb cd 99 9c			call macro_forth_dsp 
b2ce				endm 
# End of macro FORTH_DSP
b2ce 7e					ld a,(hl)	; get type of value on TOS 
b2cf fe 02				cp DS_TYPE_INUM  
b2d1 28 03				jr z, .noti 
b2d3					NEXTW 
b2d3 c3 4a 9e			jp macro_next 
b2d6				endm 
# End of macro NEXTW
b2d6			.noti:          FORTH_DSP_VALUEHL 
b2d6 cd d3 9c			call macro_dsp_valuehl 
b2d9				endm 
# End of macro FORTH_DSP_VALUEHL
b2d9			;		push hl 
b2d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2d9 cd 8b 9d			call macro_forth_dsp_pop 
b2dc				endm 
# End of macro FORTH_DSP_POP
b2dc			;		pop hl 
b2dc 3e 00				ld a,0 
b2de bd					cp l 
b2df 28 04				jr z, .not2t 
b2e1 2e 00				ld l, 0 
b2e3 18 02				jr .notip 
b2e5			 
b2e5 2e ff		.not2t:		ld l, 255 
b2e7			 
b2e7 26 00		.notip:		ld h, 0	 
b2e9			 
b2e9 cd dc 9a				call forth_push_numhl 
b2ec					NEXTW 
b2ec c3 4a 9e			jp macro_next 
b2ef				endm 
# End of macro NEXTW
b2ef			 
b2ef			.IS: 
b2ef				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b2ef 2d				db WORD_SYS_CORE+25             
b2f0 15 b3			dw .LZERO            
b2f2 03				db 2 + 1 
b2f3 .. 00			db "IS",0              
b2f6				endm 
# End of macro CWHEAD
b2f6			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b2f6					if DEBUG_FORTH_WORDS_KEY 
b2f6						DMARK "IS." 
b2f6 f5				push af  
b2f7 3a 0b b3			ld a, (.dmark)  
b2fa 32 71 ee			ld (debug_mark),a  
b2fd 3a 0c b3			ld a, (.dmark+1)  
b300 32 72 ee			ld (debug_mark+1),a  
b303 3a 0d b3			ld a, (.dmark+2)  
b306 32 73 ee			ld (debug_mark+2),a  
b309 18 03			jr .pastdmark  
b30b ..			.dmark: db "IS."  
b30e f1			.pastdmark: pop af  
b30f			endm  
# End of macro DMARK
b30f						CALLMONITOR 
b30f cd 6b 94			call break_point_state  
b312				endm  
# End of macro CALLMONITOR
b312					endif 
b312					NEXTW 
b312 c3 4a 9e			jp macro_next 
b315				endm 
# End of macro NEXTW
b315			.LZERO: 
b315				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b315 2d				db WORD_SYS_CORE+25             
b316 1f b3			dw .TZERO            
b318 03				db 2 + 1 
b319 .. 00			db "0<",0              
b31c				endm 
# End of macro CWHEAD
b31c			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b31c					NEXTW 
b31c c3 4a 9e			jp macro_next 
b31f				endm 
# End of macro NEXTW
b31f			.TZERO: 
b31f				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b31f 2e				db WORD_SYS_CORE+26             
b320 66 b3			dw .LESS            
b322 03				db 2 + 1 
b323 .. 00			db "0=",0              
b326				endm 
# End of macro CWHEAD
b326			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b326				; TODO add floating point number detection 
b326					;v5 FORTH_DSP_VALUE 
b326					if DEBUG_FORTH_WORDS_KEY 
b326						DMARK "0=." 
b326 f5				push af  
b327 3a 3b b3			ld a, (.dmark)  
b32a 32 71 ee			ld (debug_mark),a  
b32d 3a 3c b3			ld a, (.dmark+1)  
b330 32 72 ee			ld (debug_mark+1),a  
b333 3a 3d b3			ld a, (.dmark+2)  
b336 32 73 ee			ld (debug_mark+2),a  
b339 18 03			jr .pastdmark  
b33b ..			.dmark: db "0=."  
b33e f1			.pastdmark: pop af  
b33f			endm  
# End of macro DMARK
b33f						CALLMONITOR 
b33f cd 6b 94			call break_point_state  
b342				endm  
# End of macro CALLMONITOR
b342					endif 
b342					FORTH_DSP 
b342 cd 99 9c			call macro_forth_dsp 
b345				endm 
# End of macro FORTH_DSP
b345 7e					ld a,(hl)	; get type of value on TOS 
b346 fe 02				cp DS_TYPE_INUM  
b348 28 00				jr z, .tz_inum 
b34a			 
b34a				if FORTH_ENABLE_FLOATMATH 
b34a					jr .tz_done 
b34a			 
b34a				endif 
b34a					 
b34a			 
b34a			.tz_inum: 
b34a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b34a cd d3 9c			call macro_dsp_valuehl 
b34d				endm 
# End of macro FORTH_DSP_VALUEHL
b34d			 
b34d			;		push hl 
b34d			 
b34d					; destroy value TOS 
b34d			 
b34d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b34d cd 8b 9d			call macro_forth_dsp_pop 
b350				endm 
# End of macro FORTH_DSP_POP
b350			 
b350			;		pop hl 
b350			 
b350 3e 00				ld a,0 
b352			 
b352 bd					cp l 
b353 20 08				jr nz, .tz_notzero 
b355			 
b355 bc					cp h 
b356			 
b356 20 05				jr nz, .tz_notzero 
b358			 
b358			 
b358 21 01 00				ld hl, FORTH_TRUE 
b35b 18 03				jr .tz_done 
b35d			 
b35d 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b360			 
b360					; push value back onto stack for another op etc 
b360			 
b360			.tz_done: 
b360 cd dc 9a				call forth_push_numhl 
b363			 
b363					NEXTW 
b363 c3 4a 9e			jp macro_next 
b366				endm 
# End of macro NEXTW
b366			.LESS: 
b366				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b366 2f				db WORD_SYS_CORE+27             
b367 cf b3			dw .GT            
b369 02				db 1 + 1 
b36a .. 00			db "<",0              
b36c				endm 
# End of macro CWHEAD
b36c			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b36c				; TODO add floating point number detection 
b36c					if DEBUG_FORTH_WORDS_KEY 
b36c						DMARK "LES" 
b36c f5				push af  
b36d 3a 81 b3			ld a, (.dmark)  
b370 32 71 ee			ld (debug_mark),a  
b373 3a 82 b3			ld a, (.dmark+1)  
b376 32 72 ee			ld (debug_mark+1),a  
b379 3a 83 b3			ld a, (.dmark+2)  
b37c 32 73 ee			ld (debug_mark+2),a  
b37f 18 03			jr .pastdmark  
b381 ..			.dmark: db "LES"  
b384 f1			.pastdmark: pop af  
b385			endm  
# End of macro DMARK
b385						CALLMONITOR 
b385 cd 6b 94			call break_point_state  
b388				endm  
# End of macro CALLMONITOR
b388					endif 
b388					FORTH_DSP 
b388 cd 99 9c			call macro_forth_dsp 
b38b				endm 
# End of macro FORTH_DSP
b38b					;v5 FORTH_DSP_VALUE 
b38b 7e					ld a,(hl)	; get type of value on TOS 
b38c fe 02				cp DS_TYPE_INUM  
b38e 28 00				jr z, .less_inum 
b390			 
b390				if FORTH_ENABLE_FLOATMATH 
b390					jr .less_done 
b390			 
b390				endif 
b390					 
b390			 
b390			.less_inum: 
b390					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b390 cd d3 9c			call macro_dsp_valuehl 
b393				endm 
# End of macro FORTH_DSP_VALUEHL
b393			 
b393 e5					push hl  ; u2 
b394			 
b394					; destroy value TOS 
b394			 
b394					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b394 cd 8b 9d			call macro_forth_dsp_pop 
b397				endm 
# End of macro FORTH_DSP_POP
b397			 
b397			 
b397					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b397 cd d3 9c			call macro_dsp_valuehl 
b39a				endm 
# End of macro FORTH_DSP_VALUEHL
b39a			 
b39a e5					push hl    ; u1 
b39b			 
b39b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b39b cd 8b 9d			call macro_forth_dsp_pop 
b39e				endm 
# End of macro FORTH_DSP_POP
b39e			 
b39e			 
b39e b7			 or a      ;clear carry flag 
b39f 01 00 00		 ld bc, FORTH_FALSE 
b3a2 e1			  pop hl    ; u1 
b3a3 d1			  pop de    ; u2 
b3a4 ed 52		  sbc hl,de 
b3a6 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b3a8			 
b3a8 01 01 00		 ld bc, FORTH_TRUE 
b3ab			.lscont:  
b3ab c5					push bc 
b3ac e1					pop hl 
b3ad			 
b3ad					if DEBUG_FORTH_WORDS 
b3ad						DMARK "LT1" 
b3ad f5				push af  
b3ae 3a c2 b3			ld a, (.dmark)  
b3b1 32 71 ee			ld (debug_mark),a  
b3b4 3a c3 b3			ld a, (.dmark+1)  
b3b7 32 72 ee			ld (debug_mark+1),a  
b3ba 3a c4 b3			ld a, (.dmark+2)  
b3bd 32 73 ee			ld (debug_mark+2),a  
b3c0 18 03			jr .pastdmark  
b3c2 ..			.dmark: db "LT1"  
b3c5 f1			.pastdmark: pop af  
b3c6			endm  
# End of macro DMARK
b3c6						CALLMONITOR 
b3c6 cd 6b 94			call break_point_state  
b3c9				endm  
# End of macro CALLMONITOR
b3c9					endif 
b3c9 cd dc 9a				call forth_push_numhl 
b3cc			 
b3cc					NEXTW 
b3cc c3 4a 9e			jp macro_next 
b3cf				endm 
# End of macro NEXTW
b3cf			.GT: 
b3cf				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b3cf 30				db WORD_SYS_CORE+28             
b3d0 38 b4			dw .EQUAL            
b3d2 02				db 1 + 1 
b3d3 .. 00			db ">",0              
b3d5				endm 
# End of macro CWHEAD
b3d5			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b3d5				; TODO add floating point number detection 
b3d5					if DEBUG_FORTH_WORDS_KEY 
b3d5						DMARK "GRT" 
b3d5 f5				push af  
b3d6 3a ea b3			ld a, (.dmark)  
b3d9 32 71 ee			ld (debug_mark),a  
b3dc 3a eb b3			ld a, (.dmark+1)  
b3df 32 72 ee			ld (debug_mark+1),a  
b3e2 3a ec b3			ld a, (.dmark+2)  
b3e5 32 73 ee			ld (debug_mark+2),a  
b3e8 18 03			jr .pastdmark  
b3ea ..			.dmark: db "GRT"  
b3ed f1			.pastdmark: pop af  
b3ee			endm  
# End of macro DMARK
b3ee						CALLMONITOR 
b3ee cd 6b 94			call break_point_state  
b3f1				endm  
# End of macro CALLMONITOR
b3f1					endif 
b3f1					FORTH_DSP 
b3f1 cd 99 9c			call macro_forth_dsp 
b3f4				endm 
# End of macro FORTH_DSP
b3f4					;FORTH_DSP_VALUE 
b3f4 7e					ld a,(hl)	; get type of value on TOS 
b3f5 fe 02				cp DS_TYPE_INUM  
b3f7 28 00				jr z, .gt_inum 
b3f9			 
b3f9				if FORTH_ENABLE_FLOATMATH 
b3f9					jr .gt_done 
b3f9			 
b3f9				endif 
b3f9					 
b3f9			 
b3f9			.gt_inum: 
b3f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3f9 cd d3 9c			call macro_dsp_valuehl 
b3fc				endm 
# End of macro FORTH_DSP_VALUEHL
b3fc			 
b3fc e5					push hl  ; u2 
b3fd			 
b3fd					; destroy value TOS 
b3fd			 
b3fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3fd cd 8b 9d			call macro_forth_dsp_pop 
b400				endm 
# End of macro FORTH_DSP_POP
b400			 
b400			 
b400					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b400 cd d3 9c			call macro_dsp_valuehl 
b403				endm 
# End of macro FORTH_DSP_VALUEHL
b403			 
b403 e5					push hl    ; u1 
b404			 
b404					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b404 cd 8b 9d			call macro_forth_dsp_pop 
b407				endm 
# End of macro FORTH_DSP_POP
b407			 
b407			 
b407 b7			 or a      ;clear carry flag 
b408 01 00 00		 ld bc, FORTH_FALSE 
b40b e1			  pop hl    ; u1 
b40c d1			  pop de    ; u2 
b40d ed 52		  sbc hl,de 
b40f 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b411			 
b411 01 01 00		 ld bc, FORTH_TRUE 
b414			.gtcont:  
b414 c5					push bc 
b415 e1					pop hl 
b416			 
b416					if DEBUG_FORTH_WORDS 
b416						DMARK "GT1" 
b416 f5				push af  
b417 3a 2b b4			ld a, (.dmark)  
b41a 32 71 ee			ld (debug_mark),a  
b41d 3a 2c b4			ld a, (.dmark+1)  
b420 32 72 ee			ld (debug_mark+1),a  
b423 3a 2d b4			ld a, (.dmark+2)  
b426 32 73 ee			ld (debug_mark+2),a  
b429 18 03			jr .pastdmark  
b42b ..			.dmark: db "GT1"  
b42e f1			.pastdmark: pop af  
b42f			endm  
# End of macro DMARK
b42f						CALLMONITOR 
b42f cd 6b 94			call break_point_state  
b432				endm  
# End of macro CALLMONITOR
b432					endif 
b432 cd dc 9a				call forth_push_numhl 
b435			 
b435					NEXTW 
b435 c3 4a 9e			jp macro_next 
b438				endm 
# End of macro NEXTW
b438			.EQUAL: 
b438				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b438 31				db WORD_SYS_CORE+29             
b439 a3 b4			dw .ENDLOGIC            
b43b 02				db 1 + 1 
b43c .. 00			db "=",0              
b43e				endm 
# End of macro CWHEAD
b43e			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b43e				; TODO add floating point number detection 
b43e					if DEBUG_FORTH_WORDS_KEY 
b43e						DMARK "EQ." 
b43e f5				push af  
b43f 3a 53 b4			ld a, (.dmark)  
b442 32 71 ee			ld (debug_mark),a  
b445 3a 54 b4			ld a, (.dmark+1)  
b448 32 72 ee			ld (debug_mark+1),a  
b44b 3a 55 b4			ld a, (.dmark+2)  
b44e 32 73 ee			ld (debug_mark+2),a  
b451 18 03			jr .pastdmark  
b453 ..			.dmark: db "EQ."  
b456 f1			.pastdmark: pop af  
b457			endm  
# End of macro DMARK
b457						CALLMONITOR 
b457 cd 6b 94			call break_point_state  
b45a				endm  
# End of macro CALLMONITOR
b45a					endif 
b45a					FORTH_DSP 
b45a cd 99 9c			call macro_forth_dsp 
b45d				endm 
# End of macro FORTH_DSP
b45d					;v5 FORTH_DSP_VALUE 
b45d 7e					ld a,(hl)	; get type of value on TOS 
b45e fe 02				cp DS_TYPE_INUM  
b460 28 00				jr z, .eq_inum 
b462			 
b462				if FORTH_ENABLE_FLOATMATH 
b462					jr .eq_done 
b462			 
b462				endif 
b462					 
b462			 
b462			.eq_inum: 
b462					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b462 cd d3 9c			call macro_dsp_valuehl 
b465				endm 
# End of macro FORTH_DSP_VALUEHL
b465			 
b465 e5					push hl 
b466			 
b466					; destroy value TOS 
b466			 
b466					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b466 cd 8b 9d			call macro_forth_dsp_pop 
b469				endm 
# End of macro FORTH_DSP_POP
b469			 
b469			 
b469					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b469 cd d3 9c			call macro_dsp_valuehl 
b46c				endm 
# End of macro FORTH_DSP_VALUEHL
b46c			 
b46c					; one value on hl get other one back 
b46c			 
b46c e5					push hl 
b46d			 
b46d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b46d cd 8b 9d			call macro_forth_dsp_pop 
b470				endm 
# End of macro FORTH_DSP_POP
b470			 
b470 0e 00				ld c, FORTH_FALSE 
b472			 
b472 e1					pop hl 
b473 d1					pop de 
b474			 
b474 7b					ld a, e 
b475 bd					cp l 
b476			 
b476 20 06				jr nz, .eq_done 
b478			 
b478 7a					ld a, d 
b479 bc					cp h 
b47a			 
b47a 20 02				jr nz, .eq_done 
b47c			 
b47c 0e 01				ld c, FORTH_TRUE 
b47e					 
b47e			 
b47e			 
b47e			.eq_done: 
b47e			 
b47e					; TODO push value back onto stack for another op etc 
b47e			 
b47e 26 00				ld h, 0 
b480 69					ld l, c 
b481					if DEBUG_FORTH_WORDS 
b481						DMARK "EQ1" 
b481 f5				push af  
b482 3a 96 b4			ld a, (.dmark)  
b485 32 71 ee			ld (debug_mark),a  
b488 3a 97 b4			ld a, (.dmark+1)  
b48b 32 72 ee			ld (debug_mark+1),a  
b48e 3a 98 b4			ld a, (.dmark+2)  
b491 32 73 ee			ld (debug_mark+2),a  
b494 18 03			jr .pastdmark  
b496 ..			.dmark: db "EQ1"  
b499 f1			.pastdmark: pop af  
b49a			endm  
# End of macro DMARK
b49a						CALLMONITOR 
b49a cd 6b 94			call break_point_state  
b49d				endm  
# End of macro CALLMONITOR
b49d					endif 
b49d cd dc 9a				call forth_push_numhl 
b4a0			 
b4a0					NEXTW 
b4a0 c3 4a 9e			jp macro_next 
b4a3				endm 
# End of macro NEXTW
b4a3			 
b4a3			 
b4a3			.ENDLOGIC: 
b4a3			; eof 
b4a3			 
b4a3			 
# End of file forth_words_logic.asm
b4a3			include "forth_words_maths.asm" 
b4a3			 
b4a3			; | ## Maths Words 
b4a3			 
b4a3			.PLUS:	 
b4a3				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b4a3 15				db WORD_SYS_CORE+1             
b4a4 e5 b4			dw .NEG            
b4a6 02				db 1 + 1 
b4a7 .. 00			db "+",0              
b4a9				endm 
# End of macro CWHEAD
b4a9			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b4a9					if DEBUG_FORTH_WORDS_KEY 
b4a9						DMARK "PLU" 
b4a9 f5				push af  
b4aa 3a be b4			ld a, (.dmark)  
b4ad 32 71 ee			ld (debug_mark),a  
b4b0 3a bf b4			ld a, (.dmark+1)  
b4b3 32 72 ee			ld (debug_mark+1),a  
b4b6 3a c0 b4			ld a, (.dmark+2)  
b4b9 32 73 ee			ld (debug_mark+2),a  
b4bc 18 03			jr .pastdmark  
b4be ..			.dmark: db "PLU"  
b4c1 f1			.pastdmark: pop af  
b4c2			endm  
# End of macro DMARK
b4c2						CALLMONITOR 
b4c2 cd 6b 94			call break_point_state  
b4c5				endm  
# End of macro CALLMONITOR
b4c5					endif 
b4c5					; add top two values and push back result 
b4c5			 
b4c5					;for v5 FORTH_DSP_VALUE 
b4c5					FORTH_DSP 
b4c5 cd 99 9c			call macro_forth_dsp 
b4c8				endm 
# End of macro FORTH_DSP
b4c8 7e					ld a,(hl)	; get type of value on TOS 
b4c9 fe 02				cp DS_TYPE_INUM  
b4cb 28 03				jr z, .dot_inum 
b4cd			 
b4cd					NEXTW 
b4cd c3 4a 9e			jp macro_next 
b4d0				endm 
# End of macro NEXTW
b4d0			 
b4d0			; float maths 
b4d0			 
b4d0				if FORTH_ENABLE_FLOATMATH 
b4d0						inc hl      ; now at start of numeric as string 
b4d0			 
b4d0					if DEBUG_FORTH_MATHS 
b4d0						DMARK "ADD" 
b4d0				CALLMONITOR 
b4d0					endif 
b4d0			 
b4d0					;ld ix, hl 
b4d0					call CON 
b4d0			 
b4d0			 
b4d0					push hl 
b4d0					 
b4d0					 
b4d0			 
b4d0						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b4d0			 
b4d0					; get next number 
b4d0			 
b4d0						FORTH_DSP_VALUE 
b4d0			 
b4d0						inc hl      ; now at start of numeric as string 
b4d0			 
b4d0					;ld ix, hl 
b4d0					call CON 
b4d0			 
b4d0					push hl 
b4d0			 
b4d0			 
b4d0						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4d0			 
b4d0						; TODO do add 
b4d0			 
b4d0						call IADD 
b4d0			 
b4d0						; TODO get result back as ascii 
b4d0			 
b4d0						; TODO push result  
b4d0			 
b4d0			 
b4d0			 
b4d0						jr .dot_done 
b4d0				endif 
b4d0			 
b4d0			.dot_inum: 
b4d0			 
b4d0			 
b4d0					if DEBUG_FORTH_DOT 
b4d0						DMARK "+IT" 
b4d0				CALLMONITOR 
b4d0					endif 
b4d0			 
b4d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d0 cd d3 9c			call macro_dsp_valuehl 
b4d3				endm 
# End of macro FORTH_DSP_VALUEHL
b4d3			 
b4d3				; TODO add floating point number detection 
b4d3			 
b4d3 e5					push hl 
b4d4			 
b4d4					; destroy value TOS 
b4d4			 
b4d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4d4 cd 8b 9d			call macro_forth_dsp_pop 
b4d7				endm 
# End of macro FORTH_DSP_POP
b4d7			 
b4d7			 
b4d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d7 cd d3 9c			call macro_dsp_valuehl 
b4da				endm 
# End of macro FORTH_DSP_VALUEHL
b4da			 
b4da					; one value on hl get other one back 
b4da			 
b4da d1					pop de 
b4db			 
b4db					; do the add 
b4db			 
b4db 19					add hl,de 
b4dc			 
b4dc					; save it 
b4dc			 
b4dc			;		push hl	 
b4dc			 
b4dc					; 
b4dc			 
b4dc					; destroy value TOS 
b4dc			 
b4dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4dc cd 8b 9d			call macro_forth_dsp_pop 
b4df				endm 
# End of macro FORTH_DSP_POP
b4df			 
b4df					; TODO push value back onto stack for another op etc 
b4df			 
b4df			;		pop hl 
b4df			 
b4df			.dot_done: 
b4df cd dc 9a				call forth_push_numhl 
b4e2			 
b4e2					NEXTW 
b4e2 c3 4a 9e			jp macro_next 
b4e5				endm 
# End of macro NEXTW
b4e5			.NEG: 
b4e5			 
b4e5				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b4e5 17				db WORD_SYS_CORE+3             
b4e6 28 b5			dw .DIV            
b4e8 02				db 1 + 1 
b4e9 .. 00			db "-",0              
b4eb				endm 
# End of macro CWHEAD
b4eb			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b4eb					if DEBUG_FORTH_WORDS_KEY 
b4eb						DMARK "SUB" 
b4eb f5				push af  
b4ec 3a 00 b5			ld a, (.dmark)  
b4ef 32 71 ee			ld (debug_mark),a  
b4f2 3a 01 b5			ld a, (.dmark+1)  
b4f5 32 72 ee			ld (debug_mark+1),a  
b4f8 3a 02 b5			ld a, (.dmark+2)  
b4fb 32 73 ee			ld (debug_mark+2),a  
b4fe 18 03			jr .pastdmark  
b500 ..			.dmark: db "SUB"  
b503 f1			.pastdmark: pop af  
b504			endm  
# End of macro DMARK
b504						CALLMONITOR 
b504 cd 6b 94			call break_point_state  
b507				endm  
# End of macro CALLMONITOR
b507					endif 
b507			 
b507			 
b507				; TODO add floating point number detection 
b507					; v5 FORTH_DSP_VALUE 
b507					FORTH_DSP 
b507 cd 99 9c			call macro_forth_dsp 
b50a				endm 
# End of macro FORTH_DSP
b50a 7e					ld a,(hl)	; get type of value on TOS 
b50b fe 02				cp DS_TYPE_INUM  
b50d 28 03				jr z, .neg_inum 
b50f			 
b50f					NEXTW 
b50f c3 4a 9e			jp macro_next 
b512				endm 
# End of macro NEXTW
b512			 
b512			; float maths 
b512			 
b512				if FORTH_ENABLE_FLOATMATH 
b512					jr .neg_done 
b512			 
b512				endif 
b512					 
b512			 
b512			.neg_inum: 
b512					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b512 cd d3 9c			call macro_dsp_valuehl 
b515				endm 
# End of macro FORTH_DSP_VALUEHL
b515			 
b515 e5					push hl 
b516			 
b516					; destroy value TOS 
b516			 
b516					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b516 cd 8b 9d			call macro_forth_dsp_pop 
b519				endm 
# End of macro FORTH_DSP_POP
b519			 
b519			 
b519					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b519 cd d3 9c			call macro_dsp_valuehl 
b51c				endm 
# End of macro FORTH_DSP_VALUEHL
b51c			 
b51c					; one value on hl get other one back 
b51c			 
b51c d1					pop de 
b51d			 
b51d					; do the sub 
b51d			;		ex de, hl 
b51d			 
b51d ed 52				sbc hl,de 
b51f			 
b51f					; save it 
b51f			 
b51f			;		push hl	 
b51f			 
b51f					; 
b51f			 
b51f					; destroy value TOS 
b51f			 
b51f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b51f cd 8b 9d			call macro_forth_dsp_pop 
b522				endm 
# End of macro FORTH_DSP_POP
b522			 
b522					; TODO push value back onto stack for another op etc 
b522			 
b522			;		pop hl 
b522			 
b522 cd dc 9a				call forth_push_numhl 
b525			.neg_done: 
b525			 
b525					NEXTW 
b525 c3 4a 9e			jp macro_next 
b528				endm 
# End of macro NEXTW
b528			.DIV: 
b528				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b528 18				db WORD_SYS_CORE+4             
b529 75 b5			dw .MUL            
b52b 02				db 1 + 1 
b52c .. 00			db "/",0              
b52e				endm 
# End of macro CWHEAD
b52e			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b52e					if DEBUG_FORTH_WORDS_KEY 
b52e						DMARK "DIV" 
b52e f5				push af  
b52f 3a 43 b5			ld a, (.dmark)  
b532 32 71 ee			ld (debug_mark),a  
b535 3a 44 b5			ld a, (.dmark+1)  
b538 32 72 ee			ld (debug_mark+1),a  
b53b 3a 45 b5			ld a, (.dmark+2)  
b53e 32 73 ee			ld (debug_mark+2),a  
b541 18 03			jr .pastdmark  
b543 ..			.dmark: db "DIV"  
b546 f1			.pastdmark: pop af  
b547			endm  
# End of macro DMARK
b547						CALLMONITOR 
b547 cd 6b 94			call break_point_state  
b54a				endm  
# End of macro CALLMONITOR
b54a					endif 
b54a				; TODO add floating point number detection 
b54a					; v5 FORTH_DSP_VALUE 
b54a					FORTH_DSP 
b54a cd 99 9c			call macro_forth_dsp 
b54d				endm 
# End of macro FORTH_DSP
b54d 7e					ld a,(hl)	; get type of value on TOS 
b54e fe 02				cp DS_TYPE_INUM  
b550 28 03				jr z, .div_inum 
b552			 
b552				if FORTH_ENABLE_FLOATMATH 
b552					jr .div_done 
b552			 
b552				endif 
b552					NEXTW 
b552 c3 4a 9e			jp macro_next 
b555				endm 
# End of macro NEXTW
b555			.div_inum: 
b555			 
b555					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b555 cd d3 9c			call macro_dsp_valuehl 
b558				endm 
# End of macro FORTH_DSP_VALUEHL
b558			 
b558 e5					push hl    ; to go to bc 
b559			 
b559					; destroy value TOS 
b559			 
b559					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b559 cd 8b 9d			call macro_forth_dsp_pop 
b55c				endm 
# End of macro FORTH_DSP_POP
b55c			 
b55c			 
b55c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b55c cd d3 9c			call macro_dsp_valuehl 
b55f				endm 
# End of macro FORTH_DSP_VALUEHL
b55f			 
b55f					; hl to go to de 
b55f			 
b55f e5					push hl 
b560			 
b560 c1					pop bc 
b561 d1					pop de		 
b562			 
b562			 
b562					if DEBUG_FORTH_MATHS 
b562						DMARK "DIV" 
b562				CALLMONITOR 
b562					endif 
b562					; one value on hl but move to a get other one back 
b562			 
b562			        
b562 cd c7 8b			call Div16 
b565			 
b565			;	push af	 
b565 e5				push hl 
b566 c5				push bc 
b567			 
b567					if DEBUG_FORTH_MATHS 
b567						DMARK "DI1" 
b567				CALLMONITOR 
b567					endif 
b567			 
b567					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b567 cd 8b 9d			call macro_forth_dsp_pop 
b56a				endm 
# End of macro FORTH_DSP_POP
b56a			 
b56a			 
b56a			 
b56a e1					pop hl    ; result 
b56b			 
b56b cd dc 9a				call forth_push_numhl 
b56e			 
b56e e1					pop hl    ; reminder 
b56f			;		ld h,0 
b56f			;		ld l,d 
b56f			 
b56f cd dc 9a				call forth_push_numhl 
b572			.div_done: 
b572					NEXTW 
b572 c3 4a 9e			jp macro_next 
b575				endm 
# End of macro NEXTW
b575			.MUL: 
b575				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b575 19				db WORD_SYS_CORE+5             
b576 ba b5			dw .MIN            
b578 02				db 1 + 1 
b579 .. 00			db "*",0              
b57b				endm 
# End of macro CWHEAD
b57b			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b57b				; TODO add floating point number detection 
b57b					if DEBUG_FORTH_WORDS_KEY 
b57b						DMARK "MUL" 
b57b f5				push af  
b57c 3a 90 b5			ld a, (.dmark)  
b57f 32 71 ee			ld (debug_mark),a  
b582 3a 91 b5			ld a, (.dmark+1)  
b585 32 72 ee			ld (debug_mark+1),a  
b588 3a 92 b5			ld a, (.dmark+2)  
b58b 32 73 ee			ld (debug_mark+2),a  
b58e 18 03			jr .pastdmark  
b590 ..			.dmark: db "MUL"  
b593 f1			.pastdmark: pop af  
b594			endm  
# End of macro DMARK
b594						CALLMONITOR 
b594 cd 6b 94			call break_point_state  
b597				endm  
# End of macro CALLMONITOR
b597					endif 
b597					FORTH_DSP 
b597 cd 99 9c			call macro_forth_dsp 
b59a				endm 
# End of macro FORTH_DSP
b59a					; v5 FORTH_DSP_VALUE 
b59a 7e					ld a,(hl)	; get type of value on TOS 
b59b fe 02				cp DS_TYPE_INUM  
b59d 28 03				jr z, .mul_inum 
b59f			 
b59f				if FORTH_ENABLE_FLOATMATH 
b59f					jr .mul_done 
b59f			 
b59f				endif 
b59f			 
b59f					NEXTW 
b59f c3 4a 9e			jp macro_next 
b5a2				endm 
# End of macro NEXTW
b5a2			.mul_inum:	 
b5a2			 
b5a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a2 cd d3 9c			call macro_dsp_valuehl 
b5a5				endm 
# End of macro FORTH_DSP_VALUEHL
b5a5			 
b5a5 e5					push hl 
b5a6			 
b5a6					; destroy value TOS 
b5a6			 
b5a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a6 cd 8b 9d			call macro_forth_dsp_pop 
b5a9				endm 
# End of macro FORTH_DSP_POP
b5a9			 
b5a9			 
b5a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a9 cd d3 9c			call macro_dsp_valuehl 
b5ac				endm 
# End of macro FORTH_DSP_VALUEHL
b5ac			 
b5ac					; one value on hl but move to a get other one back 
b5ac			 
b5ac 7d					ld a, l 
b5ad			 
b5ad d1					pop de 
b5ae			 
b5ae					; do the mull 
b5ae			;		ex de, hl 
b5ae			 
b5ae cd ed 8b				call Mult16 
b5b1					; save it 
b5b1			 
b5b1			;		push hl	 
b5b1			 
b5b1					; 
b5b1			 
b5b1					; destroy value TOS 
b5b1			 
b5b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5b1 cd 8b 9d			call macro_forth_dsp_pop 
b5b4				endm 
# End of macro FORTH_DSP_POP
b5b4			 
b5b4					; TODO push value back onto stack for another op etc 
b5b4			 
b5b4			;		pop hl 
b5b4			 
b5b4 cd dc 9a				call forth_push_numhl 
b5b7			 
b5b7			.mul_done: 
b5b7					NEXTW 
b5b7 c3 4a 9e			jp macro_next 
b5ba				endm 
# End of macro NEXTW
b5ba			 
b5ba			 
b5ba			 
b5ba			 
b5ba			.MIN: 
b5ba				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b5ba 49				db WORD_SYS_CORE+53             
b5bb 3b b6			dw .MAX            
b5bd 04				db 3 + 1 
b5be .. 00			db "MIN",0              
b5c2				endm 
# End of macro CWHEAD
b5c2			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b5c2					if DEBUG_FORTH_WORDS_KEY 
b5c2						DMARK "MIN" 
b5c2 f5				push af  
b5c3 3a d7 b5			ld a, (.dmark)  
b5c6 32 71 ee			ld (debug_mark),a  
b5c9 3a d8 b5			ld a, (.dmark+1)  
b5cc 32 72 ee			ld (debug_mark+1),a  
b5cf 3a d9 b5			ld a, (.dmark+2)  
b5d2 32 73 ee			ld (debug_mark+2),a  
b5d5 18 03			jr .pastdmark  
b5d7 ..			.dmark: db "MIN"  
b5da f1			.pastdmark: pop af  
b5db			endm  
# End of macro DMARK
b5db						CALLMONITOR 
b5db cd 6b 94			call break_point_state  
b5de				endm  
# End of macro CALLMONITOR
b5de					endif 
b5de					; get u2 
b5de			 
b5de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5de cd d3 9c			call macro_dsp_valuehl 
b5e1				endm 
# End of macro FORTH_DSP_VALUEHL
b5e1			 
b5e1 e5					push hl   ; u2 
b5e2			 
b5e2					; destroy value TOS 
b5e2			 
b5e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e2 cd 8b 9d			call macro_forth_dsp_pop 
b5e5				endm 
# End of macro FORTH_DSP_POP
b5e5			 
b5e5					; get u1 
b5e5			 
b5e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e5 cd d3 9c			call macro_dsp_valuehl 
b5e8				endm 
# End of macro FORTH_DSP_VALUEHL
b5e8			 
b5e8 e5					push hl  ; u1 
b5e9			 
b5e9					; destroy value TOS 
b5e9			 
b5e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e9 cd 8b 9d			call macro_forth_dsp_pop 
b5ec				endm 
# End of macro FORTH_DSP_POP
b5ec			 
b5ec b7			 or a      ;clear carry flag 
b5ed e1			  pop hl    ; u1 
b5ee d1			  pop de    ; u2 
b5ef e5				push hl   ; saved in case hl is lowest 
b5f0 ed 52		  sbc hl,de 
b5f2 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b5f4			 
b5f4 e1				pop hl 
b5f5					if DEBUG_FORTH_WORDS 
b5f5						DMARK "MIN" 
b5f5 f5				push af  
b5f6 3a 0a b6			ld a, (.dmark)  
b5f9 32 71 ee			ld (debug_mark),a  
b5fc 3a 0b b6			ld a, (.dmark+1)  
b5ff 32 72 ee			ld (debug_mark+1),a  
b602 3a 0c b6			ld a, (.dmark+2)  
b605 32 73 ee			ld (debug_mark+2),a  
b608 18 03			jr .pastdmark  
b60a ..			.dmark: db "MIN"  
b60d f1			.pastdmark: pop af  
b60e			endm  
# End of macro DMARK
b60e						CALLMONITOR 
b60e cd 6b 94			call break_point_state  
b611				endm  
# End of macro CALLMONITOR
b611					endif 
b611 cd dc 9a				call forth_push_numhl 
b614			 
b614				       NEXTW 
b614 c3 4a 9e			jp macro_next 
b617				endm 
# End of macro NEXTW
b617			 
b617			.mincont:  
b617 c1				pop bc   ; tidy up 
b618 eb				ex de , hl  
b619					if DEBUG_FORTH_WORDS 
b619						DMARK "MI1" 
b619 f5				push af  
b61a 3a 2e b6			ld a, (.dmark)  
b61d 32 71 ee			ld (debug_mark),a  
b620 3a 2f b6			ld a, (.dmark+1)  
b623 32 72 ee			ld (debug_mark+1),a  
b626 3a 30 b6			ld a, (.dmark+2)  
b629 32 73 ee			ld (debug_mark+2),a  
b62c 18 03			jr .pastdmark  
b62e ..			.dmark: db "MI1"  
b631 f1			.pastdmark: pop af  
b632			endm  
# End of macro DMARK
b632						CALLMONITOR 
b632 cd 6b 94			call break_point_state  
b635				endm  
# End of macro CALLMONITOR
b635					endif 
b635 cd dc 9a				call forth_push_numhl 
b638			 
b638				       NEXTW 
b638 c3 4a 9e			jp macro_next 
b63b				endm 
# End of macro NEXTW
b63b			.MAX: 
b63b				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b63b 4a				db WORD_SYS_CORE+54             
b63c bc b6			dw .RND16            
b63e 04				db 3 + 1 
b63f .. 00			db "MAX",0              
b643				endm 
# End of macro CWHEAD
b643			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b643					if DEBUG_FORTH_WORDS_KEY 
b643						DMARK "MAX" 
b643 f5				push af  
b644 3a 58 b6			ld a, (.dmark)  
b647 32 71 ee			ld (debug_mark),a  
b64a 3a 59 b6			ld a, (.dmark+1)  
b64d 32 72 ee			ld (debug_mark+1),a  
b650 3a 5a b6			ld a, (.dmark+2)  
b653 32 73 ee			ld (debug_mark+2),a  
b656 18 03			jr .pastdmark  
b658 ..			.dmark: db "MAX"  
b65b f1			.pastdmark: pop af  
b65c			endm  
# End of macro DMARK
b65c						CALLMONITOR 
b65c cd 6b 94			call break_point_state  
b65f				endm  
# End of macro CALLMONITOR
b65f					endif 
b65f					; get u2 
b65f			 
b65f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b65f cd d3 9c			call macro_dsp_valuehl 
b662				endm 
# End of macro FORTH_DSP_VALUEHL
b662			 
b662 e5					push hl   ; u2 
b663			 
b663					; destroy value TOS 
b663			 
b663					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b663 cd 8b 9d			call macro_forth_dsp_pop 
b666				endm 
# End of macro FORTH_DSP_POP
b666			 
b666					; get u1 
b666			 
b666					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b666 cd d3 9c			call macro_dsp_valuehl 
b669				endm 
# End of macro FORTH_DSP_VALUEHL
b669			 
b669 e5					push hl  ; u1 
b66a			 
b66a					; destroy value TOS 
b66a			 
b66a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b66a cd 8b 9d			call macro_forth_dsp_pop 
b66d				endm 
# End of macro FORTH_DSP_POP
b66d			 
b66d b7			 or a      ;clear carry flag 
b66e e1			  pop hl    ; u1 
b66f d1			  pop de    ; u2 
b670 e5				push hl   ; saved in case hl is lowest 
b671 ed 52		  sbc hl,de 
b673 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b675			 
b675 e1				pop hl 
b676					if DEBUG_FORTH_WORDS 
b676						DMARK "MAX" 
b676 f5				push af  
b677 3a 8b b6			ld a, (.dmark)  
b67a 32 71 ee			ld (debug_mark),a  
b67d 3a 8c b6			ld a, (.dmark+1)  
b680 32 72 ee			ld (debug_mark+1),a  
b683 3a 8d b6			ld a, (.dmark+2)  
b686 32 73 ee			ld (debug_mark+2),a  
b689 18 03			jr .pastdmark  
b68b ..			.dmark: db "MAX"  
b68e f1			.pastdmark: pop af  
b68f			endm  
# End of macro DMARK
b68f						CALLMONITOR 
b68f cd 6b 94			call break_point_state  
b692				endm  
# End of macro CALLMONITOR
b692					endif 
b692 cd dc 9a				call forth_push_numhl 
b695			 
b695				       NEXTW 
b695 c3 4a 9e			jp macro_next 
b698				endm 
# End of macro NEXTW
b698			 
b698			.maxcont:  
b698 c1				pop bc   ; tidy up 
b699 eb				ex de , hl  
b69a					if DEBUG_FORTH_WORDS 
b69a						DMARK "MA1" 
b69a f5				push af  
b69b 3a af b6			ld a, (.dmark)  
b69e 32 71 ee			ld (debug_mark),a  
b6a1 3a b0 b6			ld a, (.dmark+1)  
b6a4 32 72 ee			ld (debug_mark+1),a  
b6a7 3a b1 b6			ld a, (.dmark+2)  
b6aa 32 73 ee			ld (debug_mark+2),a  
b6ad 18 03			jr .pastdmark  
b6af ..			.dmark: db "MA1"  
b6b2 f1			.pastdmark: pop af  
b6b3			endm  
# End of macro DMARK
b6b3						CALLMONITOR 
b6b3 cd 6b 94			call break_point_state  
b6b6				endm  
# End of macro CALLMONITOR
b6b6					endif 
b6b6 cd dc 9a				call forth_push_numhl 
b6b9				       NEXTW 
b6b9 c3 4a 9e			jp macro_next 
b6bc				endm 
# End of macro NEXTW
b6bc			 
b6bc			.RND16: 
b6bc				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b6bc 4e				db WORD_SYS_CORE+58             
b6bd eb b6			dw .RND8            
b6bf 06				db 5 + 1 
b6c0 .. 00			db "RND16",0              
b6c6				endm 
# End of macro CWHEAD
b6c6			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b6c6					if DEBUG_FORTH_WORDS_KEY 
b6c6						DMARK "R16" 
b6c6 f5				push af  
b6c7 3a db b6			ld a, (.dmark)  
b6ca 32 71 ee			ld (debug_mark),a  
b6cd 3a dc b6			ld a, (.dmark+1)  
b6d0 32 72 ee			ld (debug_mark+1),a  
b6d3 3a dd b6			ld a, (.dmark+2)  
b6d6 32 73 ee			ld (debug_mark+2),a  
b6d9 18 03			jr .pastdmark  
b6db ..			.dmark: db "R16"  
b6de f1			.pastdmark: pop af  
b6df			endm  
# End of macro DMARK
b6df						CALLMONITOR 
b6df cd 6b 94			call break_point_state  
b6e2				endm  
# End of macro CALLMONITOR
b6e2					endif 
b6e2 cd 91 8b				call prng16  
b6e5 cd dc 9a				call forth_push_numhl 
b6e8				       NEXTW 
b6e8 c3 4a 9e			jp macro_next 
b6eb				endm 
# End of macro NEXTW
b6eb			.RND8: 
b6eb				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b6eb 60				db WORD_SYS_CORE+76             
b6ec 20 b7			dw .RND            
b6ee 05				db 4 + 1 
b6ef .. 00			db "RND8",0              
b6f4				endm 
# End of macro CWHEAD
b6f4			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b6f4					if DEBUG_FORTH_WORDS_KEY 
b6f4						DMARK "RN8" 
b6f4 f5				push af  
b6f5 3a 09 b7			ld a, (.dmark)  
b6f8 32 71 ee			ld (debug_mark),a  
b6fb 3a 0a b7			ld a, (.dmark+1)  
b6fe 32 72 ee			ld (debug_mark+1),a  
b701 3a 0b b7			ld a, (.dmark+2)  
b704 32 73 ee			ld (debug_mark+2),a  
b707 18 03			jr .pastdmark  
b709 ..			.dmark: db "RN8"  
b70c f1			.pastdmark: pop af  
b70d			endm  
# End of macro DMARK
b70d						CALLMONITOR 
b70d cd 6b 94			call break_point_state  
b710				endm  
# End of macro CALLMONITOR
b710					endif 
b710 2a b2 eb				ld hl,(xrandc) 
b713 23					inc hl 
b714 cd ab 8b				call xrnd 
b717 6f					ld l,a	 
b718 26 00				ld h,0 
b71a cd dc 9a				call forth_push_numhl 
b71d				       NEXTW 
b71d c3 4a 9e			jp macro_next 
b720				endm 
# End of macro NEXTW
b720			.RND: 
b720				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b720 60				db WORD_SYS_CORE+76             
b721 26 b8			dw .ENDMATHS            
b723 04				db 3 + 1 
b724 .. 00			db "RND",0              
b728				endm 
# End of macro CWHEAD
b728			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b728			 
b728					if DEBUG_FORTH_WORDS_KEY 
b728						DMARK "RND" 
b728 f5				push af  
b729 3a 3d b7			ld a, (.dmark)  
b72c 32 71 ee			ld (debug_mark),a  
b72f 3a 3e b7			ld a, (.dmark+1)  
b732 32 72 ee			ld (debug_mark+1),a  
b735 3a 3f b7			ld a, (.dmark+2)  
b738 32 73 ee			ld (debug_mark+2),a  
b73b 18 03			jr .pastdmark  
b73d ..			.dmark: db "RND"  
b740 f1			.pastdmark: pop af  
b741			endm  
# End of macro DMARK
b741						CALLMONITOR 
b741 cd 6b 94			call break_point_state  
b744				endm  
# End of macro CALLMONITOR
b744					endif 
b744					 
b744					FORTH_DSP_VALUEHL    ; upper range 
b744 cd d3 9c			call macro_dsp_valuehl 
b747				endm 
# End of macro FORTH_DSP_VALUEHL
b747			 
b747 22 b6 eb				ld (LFSRSeed), hl	 
b74a			 
b74a					if DEBUG_FORTH_WORDS 
b74a						DMARK "RN1" 
b74a f5				push af  
b74b 3a 5f b7			ld a, (.dmark)  
b74e 32 71 ee			ld (debug_mark),a  
b751 3a 60 b7			ld a, (.dmark+1)  
b754 32 72 ee			ld (debug_mark+1),a  
b757 3a 61 b7			ld a, (.dmark+2)  
b75a 32 73 ee			ld (debug_mark+2),a  
b75d 18 03			jr .pastdmark  
b75f ..			.dmark: db "RN1"  
b762 f1			.pastdmark: pop af  
b763			endm  
# End of macro DMARK
b763						CALLMONITOR 
b763 cd 6b 94			call break_point_state  
b766				endm  
# End of macro CALLMONITOR
b766					endif 
b766					FORTH_DSP_POP 
b766 cd 8b 9d			call macro_forth_dsp_pop 
b769				endm 
# End of macro FORTH_DSP_POP
b769			 
b769					FORTH_DSP_VALUEHL    ; low range 
b769 cd d3 9c			call macro_dsp_valuehl 
b76c				endm 
# End of macro FORTH_DSP_VALUEHL
b76c			 
b76c					if DEBUG_FORTH_WORDS 
b76c						DMARK "RN2" 
b76c f5				push af  
b76d 3a 81 b7			ld a, (.dmark)  
b770 32 71 ee			ld (debug_mark),a  
b773 3a 82 b7			ld a, (.dmark+1)  
b776 32 72 ee			ld (debug_mark+1),a  
b779 3a 83 b7			ld a, (.dmark+2)  
b77c 32 73 ee			ld (debug_mark+2),a  
b77f 18 03			jr .pastdmark  
b781 ..			.dmark: db "RN2"  
b784 f1			.pastdmark: pop af  
b785			endm  
# End of macro DMARK
b785						CALLMONITOR 
b785 cd 6b 94			call break_point_state  
b788				endm  
# End of macro CALLMONITOR
b788					endif 
b788 22 b8 eb				ld (LFSRSeed+2), hl 
b78b			 
b78b					FORTH_DSP_POP 
b78b cd 8b 9d			call macro_forth_dsp_pop 
b78e				endm 
# End of macro FORTH_DSP_POP
b78e			 
b78e e5					push hl 
b78f			 
b78f e1			.inrange:	pop hl 
b790 cd 91 8b				call prng16  
b793					if DEBUG_FORTH_WORDS 
b793						DMARK "RN3" 
b793 f5				push af  
b794 3a a8 b7			ld a, (.dmark)  
b797 32 71 ee			ld (debug_mark),a  
b79a 3a a9 b7			ld a, (.dmark+1)  
b79d 32 72 ee			ld (debug_mark+1),a  
b7a0 3a aa b7			ld a, (.dmark+2)  
b7a3 32 73 ee			ld (debug_mark+2),a  
b7a6 18 03			jr .pastdmark  
b7a8 ..			.dmark: db "RN3"  
b7ab f1			.pastdmark: pop af  
b7ac			endm  
# End of macro DMARK
b7ac						CALLMONITOR 
b7ac cd 6b 94			call break_point_state  
b7af				endm  
# End of macro CALLMONITOR
b7af					endif 
b7af					 
b7af					; if the range is 8bit knock out the high byte 
b7af			 
b7af ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
b7b3			 
b7b3 3e 00				ld a, 0 
b7b5 ba					cp d  
b7b6 20 1e				jr nz, .hirange 
b7b8 26 00				ld h, 0   ; knock it down to 8bit 
b7ba			 
b7ba					if DEBUG_FORTH_WORDS 
b7ba						DMARK "RNk" 
b7ba f5				push af  
b7bb 3a cf b7			ld a, (.dmark)  
b7be 32 71 ee			ld (debug_mark),a  
b7c1 3a d0 b7			ld a, (.dmark+1)  
b7c4 32 72 ee			ld (debug_mark+1),a  
b7c7 3a d1 b7			ld a, (.dmark+2)  
b7ca 32 73 ee			ld (debug_mark+2),a  
b7cd 18 03			jr .pastdmark  
b7cf ..			.dmark: db "RNk"  
b7d2 f1			.pastdmark: pop af  
b7d3			endm  
# End of macro DMARK
b7d3						CALLMONITOR 
b7d3 cd 6b 94			call break_point_state  
b7d6				endm  
# End of macro CALLMONITOR
b7d6					endif 
b7d6			.hirange:   
b7d6 e5					push hl  
b7d7 b7					or a  
b7d8 ed 52		                sbc hl, de 
b7da			 
b7da					;call cmp16 
b7da			 
b7da 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b7dc e1					pop hl 
b7dd e5					push hl 
b7de			 
b7de					if DEBUG_FORTH_WORDS 
b7de						DMARK "RN4" 
b7de f5				push af  
b7df 3a f3 b7			ld a, (.dmark)  
b7e2 32 71 ee			ld (debug_mark),a  
b7e5 3a f4 b7			ld a, (.dmark+1)  
b7e8 32 72 ee			ld (debug_mark+1),a  
b7eb 3a f5 b7			ld a, (.dmark+2)  
b7ee 32 73 ee			ld (debug_mark+2),a  
b7f1 18 03			jr .pastdmark  
b7f3 ..			.dmark: db "RN4"  
b7f6 f1			.pastdmark: pop af  
b7f7			endm  
# End of macro DMARK
b7f7						CALLMONITOR 
b7f7 cd 6b 94			call break_point_state  
b7fa				endm  
# End of macro CALLMONITOR
b7fa					endif 
b7fa ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
b7fe					;call cmp16 
b7fe				 
b7fe b7					or a  
b7ff ed 52		                sbc hl, de 
b801 38 8c				jr c, .inrange 
b803			 
b803 e1					pop hl 
b804					 
b804					if DEBUG_FORTH_WORDS 
b804						DMARK "RNd" 
b804 f5				push af  
b805 3a 19 b8			ld a, (.dmark)  
b808 32 71 ee			ld (debug_mark),a  
b80b 3a 1a b8			ld a, (.dmark+1)  
b80e 32 72 ee			ld (debug_mark+1),a  
b811 3a 1b b8			ld a, (.dmark+2)  
b814 32 73 ee			ld (debug_mark+2),a  
b817 18 03			jr .pastdmark  
b819 ..			.dmark: db "RNd"  
b81c f1			.pastdmark: pop af  
b81d			endm  
# End of macro DMARK
b81d						CALLMONITOR 
b81d cd 6b 94			call break_point_state  
b820				endm  
# End of macro CALLMONITOR
b820					endif 
b820			 
b820			 
b820 cd dc 9a				call forth_push_numhl 
b823				       NEXTW 
b823 c3 4a 9e			jp macro_next 
b826				endm 
# End of macro NEXTW
b826			 
b826			.ENDMATHS: 
b826			 
b826			; eof 
b826			 
# End of file forth_words_maths.asm
b826			include "forth_words_display.asm" 
b826			 
b826			; | ## Display Words 
b826			 
b826			.INFO: 
b826			 
b826				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b826 62				db WORD_SYS_CORE+78             
b827 43 b8			dw .ATP            
b829 05				db 4 + 1 
b82a .. 00			db "INFO",0              
b82f				endm 
# End of macro CWHEAD
b82f			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b82f					FORTH_DSP_VALUEHL 
b82f cd d3 9c			call macro_dsp_valuehl 
b832				endm 
# End of macro FORTH_DSP_VALUEHL
b832			 
b832					FORTH_DSP_POP 
b832 cd 8b 9d			call macro_forth_dsp_pop 
b835				endm 
# End of macro FORTH_DSP_POP
b835			 
b835 e5					push hl 
b836			 
b836					FORTH_DSP_VALUEHL 
b836 cd d3 9c			call macro_dsp_valuehl 
b839				endm 
# End of macro FORTH_DSP_VALUEHL
b839			 
b839					FORTH_DSP_POP 
b839 cd 8b 9d			call macro_forth_dsp_pop 
b83c				endm 
# End of macro FORTH_DSP_POP
b83c			 
b83c d1					pop de 
b83d			 
b83d cd ce 89				call info_panel 
b840			 
b840			 
b840					NEXTW 
b840 c3 4a 9e			jp macro_next 
b843				endm 
# End of macro NEXTW
b843			.ATP: 
b843				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b843 62				db WORD_SYS_CORE+78             
b844 ba b8			dw .FB            
b846 04				db 3 + 1 
b847 .. 00			db "AT?",0              
b84b				endm 
# End of macro CWHEAD
b84b			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b84b					if DEBUG_FORTH_WORDS_KEY 
b84b						DMARK "AT?" 
b84b f5				push af  
b84c 3a 60 b8			ld a, (.dmark)  
b84f 32 71 ee			ld (debug_mark),a  
b852 3a 61 b8			ld a, (.dmark+1)  
b855 32 72 ee			ld (debug_mark+1),a  
b858 3a 62 b8			ld a, (.dmark+2)  
b85b 32 73 ee			ld (debug_mark+2),a  
b85e 18 03			jr .pastdmark  
b860 ..			.dmark: db "AT?"  
b863 f1			.pastdmark: pop af  
b864			endm  
# End of macro DMARK
b864						CALLMONITOR 
b864 cd 6b 94			call break_point_state  
b867				endm  
# End of macro CALLMONITOR
b867					endif 
b867 3a 6b ea				ld a, (f_cursor_ptr) 
b86a			 
b86a			if DEBUG_FORTH_WORDS 
b86a				DMARK "AT?" 
b86a f5				push af  
b86b 3a 7f b8			ld a, (.dmark)  
b86e 32 71 ee			ld (debug_mark),a  
b871 3a 80 b8			ld a, (.dmark+1)  
b874 32 72 ee			ld (debug_mark+1),a  
b877 3a 81 b8			ld a, (.dmark+2)  
b87a 32 73 ee			ld (debug_mark+2),a  
b87d 18 03			jr .pastdmark  
b87f ..			.dmark: db "AT?"  
b882 f1			.pastdmark: pop af  
b883			endm  
# End of macro DMARK
b883				CALLMONITOR 
b883 cd 6b 94			call break_point_state  
b886				endm  
# End of macro CALLMONITOR
b886			endif	 
b886					; count the number of rows 
b886			 
b886 06 00				ld b, 0 
b888 4f			.atpr:		ld c, a    ; save in case we go below zero 
b889 d6 28				sub display_cols 
b88b f2 91 b8				jp p, .atprunder 
b88e 04					inc b 
b88f 18 f7				jr .atpr 
b891			.atprunder:	 
b891			if DEBUG_FORTH_WORDS 
b891				DMARK "A?2" 
b891 f5				push af  
b892 3a a6 b8			ld a, (.dmark)  
b895 32 71 ee			ld (debug_mark),a  
b898 3a a7 b8			ld a, (.dmark+1)  
b89b 32 72 ee			ld (debug_mark+1),a  
b89e 3a a8 b8			ld a, (.dmark+2)  
b8a1 32 73 ee			ld (debug_mark+2),a  
b8a4 18 03			jr .pastdmark  
b8a6 ..			.dmark: db "A?2"  
b8a9 f1			.pastdmark: pop af  
b8aa			endm  
# End of macro DMARK
b8aa				CALLMONITOR 
b8aa cd 6b 94			call break_point_state  
b8ad				endm  
# End of macro CALLMONITOR
b8ad			endif	 
b8ad 26 00				ld h, 0 
b8af 69					ld l, c 
b8b0 cd dc 9a				call forth_push_numhl 
b8b3 68					ld l, b  
b8b4 cd dc 9a				call forth_push_numhl 
b8b7			 
b8b7			 
b8b7				NEXTW 
b8b7 c3 4a 9e			jp macro_next 
b8ba				endm 
# End of macro NEXTW
b8ba			 
b8ba			.FB: 
b8ba				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b8ba 1b				db WORD_SYS_CORE+7             
b8bb 08 b9			dw .EMIT            
b8bd 03				db 2 + 1 
b8be .. 00			db "FB",0              
b8c1				endm 
# End of macro CWHEAD
b8c1			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b8c1			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b8c1			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b8c1			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b8c1					if DEBUG_FORTH_WORDS_KEY 
b8c1						DMARK "FB." 
b8c1 f5				push af  
b8c2 3a d6 b8			ld a, (.dmark)  
b8c5 32 71 ee			ld (debug_mark),a  
b8c8 3a d7 b8			ld a, (.dmark+1)  
b8cb 32 72 ee			ld (debug_mark+1),a  
b8ce 3a d8 b8			ld a, (.dmark+2)  
b8d1 32 73 ee			ld (debug_mark+2),a  
b8d4 18 03			jr .pastdmark  
b8d6 ..			.dmark: db "FB."  
b8d9 f1			.pastdmark: pop af  
b8da			endm  
# End of macro DMARK
b8da						CALLMONITOR 
b8da cd 6b 94			call break_point_state  
b8dd				endm  
# End of macro CALLMONITOR
b8dd					endif 
b8dd			 
b8dd					FORTH_DSP_VALUEHL 
b8dd cd d3 9c			call macro_dsp_valuehl 
b8e0				endm 
# End of macro FORTH_DSP_VALUEHL
b8e0			 
b8e0 7d					ld a, l 
b8e1 fe 01				cp 1 
b8e3 20 05				jr nz, .fbn1 
b8e5 21 16 ed				ld hl, display_fb1 
b8e8 18 15				jr .fbset 
b8ea fe 02		.fbn1:		cp 2 
b8ec 20 05				jr nz, .fbn2 
b8ee 21 d4 eb				ld hl, display_fb2 
b8f1 18 0c				jr .fbset 
b8f3 fe 03		.fbn2:		cp 3 
b8f5 20 05				jr nz, .fbn3 
b8f7 21 75 ec				ld hl, display_fb3 
b8fa 18 03				jr .fbset 
b8fc			.fbn3:		 ; if invalid number select first 
b8fc 21 16 ed				ld hl, display_fb1 
b8ff 22 d2 eb		.fbset:		ld (display_fb_active), hl 
b902			 
b902					FORTH_DSP_POP 
b902 cd 8b 9d			call macro_forth_dsp_pop 
b905				endm 
# End of macro FORTH_DSP_POP
b905			 
b905					NEXTW 
b905 c3 4a 9e			jp macro_next 
b908				endm 
# End of macro NEXTW
b908			 
b908			 
b908			.EMIT: 
b908				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b908 1b				db WORD_SYS_CORE+7             
b909 59 b9			dw .DOTH            
b90b 05				db 4 + 1 
b90c .. 00			db "EMIT",0              
b911				endm 
# End of macro CWHEAD
b911			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b911					; get value off TOS and display it 
b911			 
b911					if DEBUG_FORTH_WORDS_KEY 
b911						DMARK "EMT" 
b911 f5				push af  
b912 3a 26 b9			ld a, (.dmark)  
b915 32 71 ee			ld (debug_mark),a  
b918 3a 27 b9			ld a, (.dmark+1)  
b91b 32 72 ee			ld (debug_mark+1),a  
b91e 3a 28 b9			ld a, (.dmark+2)  
b921 32 73 ee			ld (debug_mark+2),a  
b924 18 03			jr .pastdmark  
b926 ..			.dmark: db "EMT"  
b929 f1			.pastdmark: pop af  
b92a			endm  
# End of macro DMARK
b92a						CALLMONITOR 
b92a cd 6b 94			call break_point_state  
b92d				endm  
# End of macro CALLMONITOR
b92d					endif 
b92d			 
b92d					FORTH_DSP_VALUEHL 
b92d cd d3 9c			call macro_dsp_valuehl 
b930				endm 
# End of macro FORTH_DSP_VALUEHL
b930			 
b930 7d					ld a,l 
b931			 
b931					; TODO write to display 
b931			 
b931 32 00 e5				ld (os_input), a 
b934 3e 00				ld a, 0 
b936 32 01 e5				ld (os_input+1), a 
b939					 
b939 3a 6b ea				ld a, (f_cursor_ptr) 
b93c 11 00 e5				ld de, os_input 
b93f cd 50 8a				call str_at_display 
b942			 
b942			 
b942 3a 49 ea				ld a,(cli_autodisplay) 
b945 fe 00				cp 0 
b947 28 03				jr z, .enoupdate 
b949 cd 60 8a						call update_display 
b94c					.enoupdate: 
b94c			 
b94c 3a 6b ea				ld a, (f_cursor_ptr) 
b94f 3c					inc a 
b950 32 6b ea				ld (f_cursor_ptr), a   ; save new pos 
b953			 
b953			 
b953					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b953 cd 8b 9d			call macro_forth_dsp_pop 
b956				endm 
# End of macro FORTH_DSP_POP
b956			  
b956			 
b956					NEXTW 
b956 c3 4a 9e			jp macro_next 
b959				endm 
# End of macro NEXTW
b959			.DOTH: 
b959				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b959 1c				db WORD_SYS_CORE+8             
b95a 89 b9			dw .DOTF            
b95c 03				db 2 + 1 
b95d .. 00			db ".-",0              
b960				endm 
# End of macro CWHEAD
b960			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b960					; get value off TOS and display it 
b960					if DEBUG_FORTH_WORDS_KEY 
b960						DMARK "DTD" 
b960 f5				push af  
b961 3a 75 b9			ld a, (.dmark)  
b964 32 71 ee			ld (debug_mark),a  
b967 3a 76 b9			ld a, (.dmark+1)  
b96a 32 72 ee			ld (debug_mark+1),a  
b96d 3a 77 b9			ld a, (.dmark+2)  
b970 32 73 ee			ld (debug_mark+2),a  
b973 18 03			jr .pastdmark  
b975 ..			.dmark: db "DTD"  
b978 f1			.pastdmark: pop af  
b979			endm  
# End of macro DMARK
b979						CALLMONITOR 
b979 cd 6b 94			call break_point_state  
b97c				endm  
# End of macro CALLMONITOR
b97c					endif 
b97c 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b97e 3e 00			ld a, 0 
b980 32 4a ea			ld (cli_mvdot), a 
b983 c3 e0 b9			jp .dotgo 
b986				NEXTW 
b986 c3 4a 9e			jp macro_next 
b989				endm 
# End of macro NEXTW
b989			.DOTF: 
b989				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b989 1c				db WORD_SYS_CORE+8             
b98a b7 b9			dw .DOT            
b98c 03				db 2 + 1 
b98d .. 00			db ".>",0              
b990				endm 
# End of macro CWHEAD
b990			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b990					; get value off TOS and display it 
b990			        ; TODO BUG adds extra spaces 
b990			        ; TODO BUG handle numerics? 
b990					if DEBUG_FORTH_WORDS_KEY 
b990						DMARK "DTC" 
b990 f5				push af  
b991 3a a5 b9			ld a, (.dmark)  
b994 32 71 ee			ld (debug_mark),a  
b997 3a a6 b9			ld a, (.dmark+1)  
b99a 32 72 ee			ld (debug_mark+1),a  
b99d 3a a7 b9			ld a, (.dmark+2)  
b9a0 32 73 ee			ld (debug_mark+2),a  
b9a3 18 03			jr .pastdmark  
b9a5 ..			.dmark: db "DTC"  
b9a8 f1			.pastdmark: pop af  
b9a9			endm  
# End of macro DMARK
b9a9						CALLMONITOR 
b9a9 cd 6b 94			call break_point_state  
b9ac				endm  
# End of macro CALLMONITOR
b9ac					endif 
b9ac 3e 01			ld a, 1 
b9ae 32 4a ea			ld (cli_mvdot), a 
b9b1 c3 e0 b9			jp .dotgo 
b9b4				NEXTW 
b9b4 c3 4a 9e			jp macro_next 
b9b7				endm 
# End of macro NEXTW
b9b7			 
b9b7			.DOT: 
b9b7				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b9b7 1c				db WORD_SYS_CORE+8             
b9b8 43 ba			dw .CLS            
b9ba 02				db 1 + 1 
b9bb .. 00			db ".",0              
b9bd				endm 
# End of macro CWHEAD
b9bd			        ; | . ( u -- ) Display TOS | DONE 
b9bd					; get value off TOS and display it 
b9bd			 
b9bd					if DEBUG_FORTH_WORDS_KEY 
b9bd						DMARK "DOT" 
b9bd f5				push af  
b9be 3a d2 b9			ld a, (.dmark)  
b9c1 32 71 ee			ld (debug_mark),a  
b9c4 3a d3 b9			ld a, (.dmark+1)  
b9c7 32 72 ee			ld (debug_mark+1),a  
b9ca 3a d4 b9			ld a, (.dmark+2)  
b9cd 32 73 ee			ld (debug_mark+2),a  
b9d0 18 03			jr .pastdmark  
b9d2 ..			.dmark: db "DOT"  
b9d5 f1			.pastdmark: pop af  
b9d6			endm  
# End of macro DMARK
b9d6						CALLMONITOR 
b9d6 cd 6b 94			call break_point_state  
b9d9				endm  
# End of macro CALLMONITOR
b9d9					endif 
b9d9 3e 00			ld a, 0 
b9db 32 4a ea			ld (cli_mvdot), a 
b9de 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b9e0				 
b9e0			 
b9e0			.dotgo: 
b9e0			 
b9e0			; move up type to on stack for parserv5 
b9e0					FORTH_DSP 
b9e0 cd 99 9c			call macro_forth_dsp 
b9e3				endm 
# End of macro FORTH_DSP
b9e3				;FORTH_DSP_VALUE  
b9e3			 
b9e3			if DEBUG_FORTH_DOT 
b9e3				DMARK "DOT" 
b9e3				CALLMONITOR 
b9e3			endif	 
b9e3			;		.print: 
b9e3			 
b9e3 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b9e4 23				inc hl   ; position to the actual value 
b9e5 fe 01			cp DS_TYPE_STR 
b9e7 20 06			jr nz, .dotnum1  
b9e9			 
b9e9			; display string 
b9e9				FORTH_DSP_VALUE  
b9e9 cd bc 9c			call macro_forth_dsp_value 
b9ec				endm 
# End of macro FORTH_DSP_VALUE
b9ec eb				ex de,hl 
b9ed 18 11			jr .dotwrite 
b9ef			 
b9ef			.dotnum1: 
b9ef fe 02			cp DS_TYPE_INUM 
b9f1 20 0c			jr nz, .dotflot 
b9f3			 
b9f3			 
b9f3			; display number 
b9f3			 
b9f3			;	push hl 
b9f3			;	call clear_display 
b9f3			;	pop hl 
b9f3			 
b9f3 5e				ld e, (hl) 
b9f4 23				inc hl 
b9f5 56				ld d, (hl) 
b9f6 21 02 e3			ld hl, scratch 
b9f9			if DEBUG_FORTH_DOT 
b9f9				DMARK "DT1" 
b9f9				CALLMONITOR 
b9f9			endif	 
b9f9			 
b9f9 cd 77 90			call uitoa_16 
b9fc eb				ex de,hl 
b9fd			 
b9fd			if DEBUG_FORTH_DOT 
b9fd				DMARK "DT2" 
b9fd				CALLMONITOR 
b9fd			endif	 
b9fd			 
b9fd			;	ld de, os_word_scratch 
b9fd 18 01			jr .dotwrite 
b9ff			 
b9ff 00			.dotflot:   nop 
ba00			; TODO print floating point number 
ba00			 
ba00			.dotwrite:		 
ba00			 
ba00					; if c is set then set all '-' to spaces 
ba00					; need to also take into account .>  
ba00			 
ba00 3e 01				ld a, 1 
ba02 b9					cp c 
ba03 20 13				jr nz, .nodashswap 
ba05			 
ba05					; DE has the string to write, working with HL 
ba05			 
ba05 06 ff				ld b, 255 
ba07 d5					push de 
ba08 e1					pop hl 
ba09			 
ba09			if DEBUG_FORTH_DOT 
ba09				DMARK "DT-" 
ba09				CALLMONITOR 
ba09			endif	 
ba09 7e			.dashscan:	ld a, (hl) 
ba0a fe 00				cp 0 
ba0c 28 0a				jr z, .nodashswap 
ba0e fe 2d				cp '-' 
ba10 20 03				jr nz, .dashskip 
ba12 3e 20				ld a, ' ' 
ba14 77					ld (hl), a 
ba15 23			.dashskip:	inc hl 
ba16			if DEBUG_FORTH_DOT 
ba16				DMARK "D-2" 
ba16				CALLMONITOR 
ba16			endif	 
ba16 10 f1				djnz .dashscan 
ba18			 
ba18			if DEBUG_FORTH_DOT 
ba18				DMARK "D-1" 
ba18				CALLMONITOR 
ba18			endif	 
ba18			 
ba18			.nodashswap: 
ba18			 
ba18 e5					push hl   ; save string start in case we need to advance print 
ba19			 
ba19 3a 6b ea				ld a, (f_cursor_ptr) 
ba1c cd 50 8a				call str_at_display 
ba1f 3a 49 ea				ld a,(cli_autodisplay) 
ba22 fe 00				cp 0 
ba24 28 03				jr z, .noupdate 
ba26 cd 60 8a						call update_display 
ba29					.noupdate: 
ba29			 
ba29			 
ba29					; see if we need to advance the print position 
ba29			 
ba29 e1					pop hl   ; get back string 
ba2a			 
ba2a 3a 4a ea				ld a, (cli_mvdot) 
ba2d			if DEBUG_FORTH_DOT 
ba2d					ld e,a 
ba2d				DMARK "D>1" 
ba2d				CALLMONITOR 
ba2d			endif	 
ba2d fe 00				cp 0 
ba2f 28 0c				jr z, .noadv 
ba31					; yes, lets advance the print position 
ba31 3e 00				ld a, 0 
ba33 cd d3 90				call strlent 
ba36 3a 6b ea				ld a, (f_cursor_ptr) 
ba39 85					add a,l 
ba3a					;call addatohl 
ba3a					;ld a, l 
ba3a 32 6b ea				ld (f_cursor_ptr), a   ; save new pos 
ba3d			 
ba3d			if DEBUG_FORTH_DOT 
ba3d				DMARK "D->" 
ba3d				CALLMONITOR 
ba3d			endif	 
ba3d			 
ba3d			.noadv:	 
ba3d			 
ba3d					if DEBUG_FORTH_DOT_WAIT 
ba3d							call next_page_prompt 
ba3d					endif	 
ba3d			; TODO this pop off the stack causes a crash. i dont know why 
ba3d			 
ba3d			 
ba3d			if DEBUG_FORTH_DOT 
ba3d				DMARK "DTh" 
ba3d				CALLMONITOR 
ba3d			endif	 
ba3d			 
ba3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba3d cd 8b 9d			call macro_forth_dsp_pop 
ba40				endm 
# End of macro FORTH_DSP_POP
ba40			 
ba40			if DEBUG_FORTH_DOT 
ba40				DMARK "DTi" 
ba40				CALLMONITOR 
ba40			endif	 
ba40			 
ba40			 
ba40					NEXTW 
ba40 c3 4a 9e			jp macro_next 
ba43				endm 
# End of macro NEXTW
ba43			 
ba43			.CLS: 
ba43				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
ba43 35				db WORD_SYS_CORE+33             
ba44 70 ba			dw .DRAW            
ba46 04				db 3 + 1 
ba47 .. 00			db "CLS",0              
ba4b				endm 
# End of macro CWHEAD
ba4b			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
ba4b					if DEBUG_FORTH_WORDS_KEY 
ba4b						DMARK "CLS" 
ba4b f5				push af  
ba4c 3a 60 ba			ld a, (.dmark)  
ba4f 32 71 ee			ld (debug_mark),a  
ba52 3a 61 ba			ld a, (.dmark+1)  
ba55 32 72 ee			ld (debug_mark+1),a  
ba58 3a 62 ba			ld a, (.dmark+2)  
ba5b 32 73 ee			ld (debug_mark+2),a  
ba5e 18 03			jr .pastdmark  
ba60 ..			.dmark: db "CLS"  
ba63 f1			.pastdmark: pop af  
ba64			endm  
# End of macro DMARK
ba64						CALLMONITOR 
ba64 cd 6b 94			call break_point_state  
ba67				endm  
# End of macro CALLMONITOR
ba67					endif 
ba67 cd 3d 8a				call clear_display 
ba6a c3 7e bb				jp .home		; and home cursor 
ba6d					NEXTW 
ba6d c3 4a 9e			jp macro_next 
ba70				endm 
# End of macro NEXTW
ba70			 
ba70			.DRAW: 
ba70				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
ba70 36				db WORD_SYS_CORE+34             
ba71 9b ba			dw .DUMP            
ba73 05				db 4 + 1 
ba74 .. 00			db "DRAW",0              
ba79				endm 
# End of macro CWHEAD
ba79			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
ba79					if DEBUG_FORTH_WORDS_KEY 
ba79						DMARK "DRW" 
ba79 f5				push af  
ba7a 3a 8e ba			ld a, (.dmark)  
ba7d 32 71 ee			ld (debug_mark),a  
ba80 3a 8f ba			ld a, (.dmark+1)  
ba83 32 72 ee			ld (debug_mark+1),a  
ba86 3a 90 ba			ld a, (.dmark+2)  
ba89 32 73 ee			ld (debug_mark+2),a  
ba8c 18 03			jr .pastdmark  
ba8e ..			.dmark: db "DRW"  
ba91 f1			.pastdmark: pop af  
ba92			endm  
# End of macro DMARK
ba92						CALLMONITOR 
ba92 cd 6b 94			call break_point_state  
ba95				endm  
# End of macro CALLMONITOR
ba95					endif 
ba95 cd 60 8a				call update_display 
ba98					NEXTW 
ba98 c3 4a 9e			jp macro_next 
ba9b				endm 
# End of macro NEXTW
ba9b			 
ba9b			.DUMP: 
ba9b				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
ba9b 37				db WORD_SYS_CORE+35             
ba9c d3 ba			dw .CDUMP            
ba9e 05				db 4 + 1 
ba9f .. 00			db "DUMP",0              
baa4				endm 
# End of macro CWHEAD
baa4			; | DUMP ( x -- ) With address x display dump   | DONE 
baa4			; TODO pop address to use off of the stack 
baa4					if DEBUG_FORTH_WORDS_KEY 
baa4						DMARK "DUM" 
baa4 f5				push af  
baa5 3a b9 ba			ld a, (.dmark)  
baa8 32 71 ee			ld (debug_mark),a  
baab 3a ba ba			ld a, (.dmark+1)  
baae 32 72 ee			ld (debug_mark+1),a  
bab1 3a bb ba			ld a, (.dmark+2)  
bab4 32 73 ee			ld (debug_mark+2),a  
bab7 18 03			jr .pastdmark  
bab9 ..			.dmark: db "DUM"  
babc f1			.pastdmark: pop af  
babd			endm  
# End of macro DMARK
babd						CALLMONITOR 
babd cd 6b 94			call break_point_state  
bac0				endm  
# End of macro CALLMONITOR
bac0					endif 
bac0 cd 3d 8a				call clear_display 
bac3			 
bac3					; get address 
bac3			 
bac3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bac3 cd d3 9c			call macro_dsp_valuehl 
bac6				endm 
# End of macro FORTH_DSP_VALUEHL
bac6				 
bac6					; save it for cdump 
bac6			 
bac6 22 25 e6				ld (os_cur_ptr),hl 
bac9			 
bac9					; destroy value TOS 
bac9			 
bac9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bac9 cd 8b 9d			call macro_forth_dsp_pop 
bacc				endm 
# End of macro FORTH_DSP_POP
bacc			 
bacc cd 5c 99				call dumpcont	; skip old style of param parsing	 
bacf c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bad0					NEXTW 
bad0 c3 4a 9e			jp macro_next 
bad3				endm 
# End of macro NEXTW
bad3			.CDUMP: 
bad3				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bad3 38				db WORD_SYS_CORE+36             
bad4 03 bb			dw .DAT            
bad6 06				db 5 + 1 
bad7 .. 00			db "CDUMP",0              
badd				endm 
# End of macro CWHEAD
badd			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
badd					if DEBUG_FORTH_WORDS_KEY 
badd						DMARK "CDP" 
badd f5				push af  
bade 3a f2 ba			ld a, (.dmark)  
bae1 32 71 ee			ld (debug_mark),a  
bae4 3a f3 ba			ld a, (.dmark+1)  
bae7 32 72 ee			ld (debug_mark+1),a  
baea 3a f4 ba			ld a, (.dmark+2)  
baed 32 73 ee			ld (debug_mark+2),a  
baf0 18 03			jr .pastdmark  
baf2 ..			.dmark: db "CDP"  
baf5 f1			.pastdmark: pop af  
baf6			endm  
# End of macro DMARK
baf6						CALLMONITOR 
baf6 cd 6b 94			call break_point_state  
baf9				endm  
# End of macro CALLMONITOR
baf9					endif 
baf9 cd 3d 8a				call clear_display 
bafc cd 5c 99				call dumpcont	 
baff c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bb00					NEXTW 
bb00 c3 4a 9e			jp macro_next 
bb03				endm 
# End of macro NEXTW
bb03			 
bb03			 
bb03			 
bb03			 
bb03			.DAT: 
bb03				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bb03 3d				db WORD_SYS_CORE+41             
bb04 59 bb			dw .HOME            
bb06 03				db 2 + 1 
bb07 .. 00			db "AT",0              
bb0a				endm 
# End of macro CWHEAD
bb0a			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bb0a					if DEBUG_FORTH_WORDS_KEY 
bb0a						DMARK "AT." 
bb0a f5				push af  
bb0b 3a 1f bb			ld a, (.dmark)  
bb0e 32 71 ee			ld (debug_mark),a  
bb11 3a 20 bb			ld a, (.dmark+1)  
bb14 32 72 ee			ld (debug_mark+1),a  
bb17 3a 21 bb			ld a, (.dmark+2)  
bb1a 32 73 ee			ld (debug_mark+2),a  
bb1d 18 03			jr .pastdmark  
bb1f ..			.dmark: db "AT."  
bb22 f1			.pastdmark: pop af  
bb23			endm  
# End of macro DMARK
bb23						CALLMONITOR 
bb23 cd 6b 94			call break_point_state  
bb26				endm  
# End of macro CALLMONITOR
bb26					endif 
bb26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb26 cd d3 9c			call macro_dsp_valuehl 
bb29				endm 
# End of macro FORTH_DSP_VALUEHL
bb29			 
bb29			 
bb29					; TODO save cursor row 
bb29 7d					ld a,l 
bb2a fe 02				cp 2 
bb2c 20 04				jr nz, .crow3 
bb2e 3e 28				ld a, display_row_2 
bb30 18 12				jr .ccol1 
bb32 fe 03		.crow3:		cp 3 
bb34 20 04				jr nz, .crow4 
bb36 3e 50				ld a, display_row_3 
bb38 18 0a				jr .ccol1 
bb3a fe 04		.crow4:		cp 4 
bb3c 20 04				jr nz, .crow1 
bb3e 3e 78				ld a, display_row_4 
bb40 18 02				jr .ccol1 
bb42 3e 00		.crow1:		ld a,display_row_1 
bb44 f5			.ccol1:		push af			; got row offset 
bb45 6f					ld l,a 
bb46 26 00				ld h,0 
bb48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb48 cd 8b 9d			call macro_forth_dsp_pop 
bb4b				endm 
# End of macro FORTH_DSP_POP
bb4b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb4b cd d3 9c			call macro_dsp_valuehl 
bb4e				endm 
# End of macro FORTH_DSP_VALUEHL
bb4e					; TODO save cursor col 
bb4e f1					pop af 
bb4f 85					add l		; add col offset 
bb50 32 6b ea				ld (f_cursor_ptr), a 
bb53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb53 cd 8b 9d			call macro_forth_dsp_pop 
bb56				endm 
# End of macro FORTH_DSP_POP
bb56			 
bb56					; calculate  
bb56			 
bb56					NEXTW 
bb56 c3 4a 9e			jp macro_next 
bb59				endm 
# End of macro NEXTW
bb59			 
bb59			 
bb59			.HOME: 
bb59				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bb59 41				db WORD_SYS_CORE+45             
bb5a 86 bb			dw .SPACE            
bb5c 05				db 4 + 1 
bb5d .. 00			db "HOME",0              
bb62				endm 
# End of macro CWHEAD
bb62			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bb62					if DEBUG_FORTH_WORDS_KEY 
bb62						DMARK "HOM" 
bb62 f5				push af  
bb63 3a 77 bb			ld a, (.dmark)  
bb66 32 71 ee			ld (debug_mark),a  
bb69 3a 78 bb			ld a, (.dmark+1)  
bb6c 32 72 ee			ld (debug_mark+1),a  
bb6f 3a 79 bb			ld a, (.dmark+2)  
bb72 32 73 ee			ld (debug_mark+2),a  
bb75 18 03			jr .pastdmark  
bb77 ..			.dmark: db "HOM"  
bb7a f1			.pastdmark: pop af  
bb7b			endm  
# End of macro DMARK
bb7b						CALLMONITOR 
bb7b cd 6b 94			call break_point_state  
bb7e				endm  
# End of macro CALLMONITOR
bb7e					endif 
bb7e 3e 00		.home:		ld a, 0		; and home cursor 
bb80 32 6b ea				ld (f_cursor_ptr), a 
bb83					NEXTW 
bb83 c3 4a 9e			jp macro_next 
bb86				endm 
# End of macro NEXTW
bb86			 
bb86			 
bb86			.SPACE: 
bb86				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bb86 46				db WORD_SYS_CORE+50             
bb87 b4 bb			dw .SPACES            
bb89 03				db 2 + 1 
bb8a .. 00			db "BL",0              
bb8d				endm 
# End of macro CWHEAD
bb8d			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bb8d					if DEBUG_FORTH_WORDS_KEY 
bb8d						DMARK "BL." 
bb8d f5				push af  
bb8e 3a a2 bb			ld a, (.dmark)  
bb91 32 71 ee			ld (debug_mark),a  
bb94 3a a3 bb			ld a, (.dmark+1)  
bb97 32 72 ee			ld (debug_mark+1),a  
bb9a 3a a4 bb			ld a, (.dmark+2)  
bb9d 32 73 ee			ld (debug_mark+2),a  
bba0 18 03			jr .pastdmark  
bba2 ..			.dmark: db "BL."  
bba5 f1			.pastdmark: pop af  
bba6			endm  
# End of macro DMARK
bba6						CALLMONITOR 
bba6 cd 6b 94			call break_point_state  
bba9				endm  
# End of macro CALLMONITOR
bba9					endif 
bba9 21 b2 bb				ld hl, .blstr 
bbac cd 4a 9b				call forth_push_str 
bbaf					 
bbaf				       NEXTW 
bbaf c3 4a 9e			jp macro_next 
bbb2				endm 
# End of macro NEXTW
bbb2			 
bbb2 .. 00		.blstr: db " ", 0 
bbb4			 
bbb4			.SPACES: 
bbb4				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
bbb4 47				db WORD_SYS_CORE+51             
bbb5 4f bc			dw .SCROLL            
bbb7 07				db 6 + 1 
bbb8 .. 00			db "SPACES",0              
bbbf				endm 
# End of macro CWHEAD
bbbf			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
bbbf					if DEBUG_FORTH_WORDS_KEY 
bbbf						DMARK "SPS" 
bbbf f5				push af  
bbc0 3a d4 bb			ld a, (.dmark)  
bbc3 32 71 ee			ld (debug_mark),a  
bbc6 3a d5 bb			ld a, (.dmark+1)  
bbc9 32 72 ee			ld (debug_mark+1),a  
bbcc 3a d6 bb			ld a, (.dmark+2)  
bbcf 32 73 ee			ld (debug_mark+2),a  
bbd2 18 03			jr .pastdmark  
bbd4 ..			.dmark: db "SPS"  
bbd7 f1			.pastdmark: pop af  
bbd8			endm  
# End of macro DMARK
bbd8						CALLMONITOR 
bbd8 cd 6b 94			call break_point_state  
bbdb				endm  
# End of macro CALLMONITOR
bbdb					endif 
bbdb			 
bbdb			 
bbdb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bbdb cd d3 9c			call macro_dsp_valuehl 
bbde				endm 
# End of macro FORTH_DSP_VALUEHL
bbde			 
bbde			;		push hl    ; u 
bbde					if DEBUG_FORTH_WORDS 
bbde						DMARK "SPA" 
bbde f5				push af  
bbdf 3a f3 bb			ld a, (.dmark)  
bbe2 32 71 ee			ld (debug_mark),a  
bbe5 3a f4 bb			ld a, (.dmark+1)  
bbe8 32 72 ee			ld (debug_mark+1),a  
bbeb 3a f5 bb			ld a, (.dmark+2)  
bbee 32 73 ee			ld (debug_mark+2),a  
bbf1 18 03			jr .pastdmark  
bbf3 ..			.dmark: db "SPA"  
bbf6 f1			.pastdmark: pop af  
bbf7			endm  
# End of macro DMARK
bbf7						CALLMONITOR 
bbf7 cd 6b 94			call break_point_state  
bbfa				endm  
# End of macro CALLMONITOR
bbfa					endif 
bbfa			 
bbfa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bbfa cd 8b 9d			call macro_forth_dsp_pop 
bbfd				endm 
# End of macro FORTH_DSP_POP
bbfd			;		pop hl 
bbfd 4d					ld c, l 
bbfe 06 00				ld b, 0 
bc00 21 02 e3				ld hl, scratch  
bc03			 
bc03					if DEBUG_FORTH_WORDS 
bc03						DMARK "SP2" 
bc03 f5				push af  
bc04 3a 18 bc			ld a, (.dmark)  
bc07 32 71 ee			ld (debug_mark),a  
bc0a 3a 19 bc			ld a, (.dmark+1)  
bc0d 32 72 ee			ld (debug_mark+1),a  
bc10 3a 1a bc			ld a, (.dmark+2)  
bc13 32 73 ee			ld (debug_mark+2),a  
bc16 18 03			jr .pastdmark  
bc18 ..			.dmark: db "SP2"  
bc1b f1			.pastdmark: pop af  
bc1c			endm  
# End of macro DMARK
bc1c						CALLMONITOR 
bc1c cd 6b 94			call break_point_state  
bc1f				endm  
# End of macro CALLMONITOR
bc1f					endif 
bc1f 3e 20				ld a, ' ' 
bc21 c5			.spaces1:	push bc 
bc22 77					ld (hl),a 
bc23 23					inc hl 
bc24 c1					pop bc 
bc25 10 fa				djnz .spaces1 
bc27 3e 00				ld a,0 
bc29 77					ld (hl),a 
bc2a 21 02 e3				ld hl, scratch 
bc2d					if DEBUG_FORTH_WORDS 
bc2d						DMARK "SP3" 
bc2d f5				push af  
bc2e 3a 42 bc			ld a, (.dmark)  
bc31 32 71 ee			ld (debug_mark),a  
bc34 3a 43 bc			ld a, (.dmark+1)  
bc37 32 72 ee			ld (debug_mark+1),a  
bc3a 3a 44 bc			ld a, (.dmark+2)  
bc3d 32 73 ee			ld (debug_mark+2),a  
bc40 18 03			jr .pastdmark  
bc42 ..			.dmark: db "SP3"  
bc45 f1			.pastdmark: pop af  
bc46			endm  
# End of macro DMARK
bc46						CALLMONITOR 
bc46 cd 6b 94			call break_point_state  
bc49				endm  
# End of macro CALLMONITOR
bc49					endif 
bc49 cd 45 9c				call forth_apush 
bc4c			 
bc4c				       NEXTW 
bc4c c3 4a 9e			jp macro_next 
bc4f				endm 
# End of macro NEXTW
bc4f			 
bc4f			 
bc4f			 
bc4f			.SCROLL: 
bc4f				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bc4f 53				db WORD_SYS_CORE+63             
bc50 7c bc			dw .SCROLLD            
bc52 07				db 6 + 1 
bc53 .. 00			db "SCROLL",0              
bc5a				endm 
# End of macro CWHEAD
bc5a			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bc5a					if DEBUG_FORTH_WORDS_KEY 
bc5a						DMARK "SCR" 
bc5a f5				push af  
bc5b 3a 6f bc			ld a, (.dmark)  
bc5e 32 71 ee			ld (debug_mark),a  
bc61 3a 70 bc			ld a, (.dmark+1)  
bc64 32 72 ee			ld (debug_mark+1),a  
bc67 3a 71 bc			ld a, (.dmark+2)  
bc6a 32 73 ee			ld (debug_mark+2),a  
bc6d 18 03			jr .pastdmark  
bc6f ..			.dmark: db "SCR"  
bc72 f1			.pastdmark: pop af  
bc73			endm  
# End of macro DMARK
bc73						CALLMONITOR 
bc73 cd 6b 94			call break_point_state  
bc76				endm  
# End of macro CALLMONITOR
bc76					endif 
bc76			 
bc76 cd ff 89			call scroll_up 
bc79			;	call update_display 
bc79			 
bc79					NEXTW 
bc79 c3 4a 9e			jp macro_next 
bc7c				endm 
# End of macro NEXTW
bc7c			 
bc7c			 
bc7c			 
bc7c			;		; get dir 
bc7c			; 
bc7c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bc7c			; 
bc7c			;		push hl 
bc7c			; 
bc7c			;		; destroy value TOS 
bc7c			; 
bc7c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc7c			; 
bc7c			;		; get count 
bc7c			; 
bc7c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bc7c			; 
bc7c			;		push hl 
bc7c			; 
bc7c			;		; destroy value TOS 
bc7c			; 
bc7c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc7c			; 
bc7c			;		; one value on hl get other one back 
bc7c			; 
bc7c			;		pop bc    ; count 
bc7c			; 
bc7c			;		pop de   ; dir 
bc7c			; 
bc7c			; 
bc7c			;		ld b, c 
bc7c			; 
bc7c			;.scrolldir:     push bc 
bc7c			;		push de 
bc7c			; 
bc7c			;		ld a, 0 
bc7c			;		cp e 
bc7c			;		jr z, .scrollup  
bc7c			;		call scroll_down 
bc7c			;		jr .scrollnext 
bc7c			;.scrollup:	call scroll_up 
bc7c			; 
bc7c			;		 
bc7c			;.scrollnext: 
bc7c			;		pop de 
bc7c			;		pop bc 
bc7c			;		djnz .scrolldir 
bc7c			; 
bc7c			; 
bc7c			; 
bc7c			; 
bc7c			; 
bc7c			;		NEXTW 
bc7c			 
bc7c			.SCROLLD: 
bc7c				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bc7c 53				db WORD_SYS_CORE+63             
bc7d aa bc			dw .ATQ            
bc7f 08				db 7 + 1 
bc80 .. 00			db "SCROLLD",0              
bc88				endm 
# End of macro CWHEAD
bc88			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bc88					if DEBUG_FORTH_WORDS_KEY 
bc88						DMARK "SCD" 
bc88 f5				push af  
bc89 3a 9d bc			ld a, (.dmark)  
bc8c 32 71 ee			ld (debug_mark),a  
bc8f 3a 9e bc			ld a, (.dmark+1)  
bc92 32 72 ee			ld (debug_mark+1),a  
bc95 3a 9f bc			ld a, (.dmark+2)  
bc98 32 73 ee			ld (debug_mark+2),a  
bc9b 18 03			jr .pastdmark  
bc9d ..			.dmark: db "SCD"  
bca0 f1			.pastdmark: pop af  
bca1			endm  
# End of macro DMARK
bca1						CALLMONITOR 
bca1 cd 6b 94			call break_point_state  
bca4				endm  
# End of macro CALLMONITOR
bca4					endif 
bca4			 
bca4 cd 23 8a			call scroll_down 
bca7			;	call update_display 
bca7			 
bca7					NEXTW 
bca7 c3 4a 9e			jp macro_next 
bcaa				endm 
# End of macro NEXTW
bcaa			 
bcaa			 
bcaa			.ATQ: 
bcaa				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bcaa 62				db WORD_SYS_CORE+78             
bcab 08 bd			dw .AUTODSP            
bcad 04				db 3 + 1 
bcae .. 00			db "AT@",0              
bcb2				endm 
# End of macro CWHEAD
bcb2			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bcb2					if DEBUG_FORTH_WORDS_KEY 
bcb2						DMARK "ATA" 
bcb2 f5				push af  
bcb3 3a c7 bc			ld a, (.dmark)  
bcb6 32 71 ee			ld (debug_mark),a  
bcb9 3a c8 bc			ld a, (.dmark+1)  
bcbc 32 72 ee			ld (debug_mark+1),a  
bcbf 3a c9 bc			ld a, (.dmark+2)  
bcc2 32 73 ee			ld (debug_mark+2),a  
bcc5 18 03			jr .pastdmark  
bcc7 ..			.dmark: db "ATA"  
bcca f1			.pastdmark: pop af  
bccb			endm  
# End of macro DMARK
bccb						CALLMONITOR 
bccb cd 6b 94			call break_point_state  
bcce				endm  
# End of macro CALLMONITOR
bcce					endif 
bcce			 
bcce			 
bcce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bcce cd d3 9c			call macro_dsp_valuehl 
bcd1				endm 
# End of macro FORTH_DSP_VALUEHL
bcd1			 
bcd1					; TODO save cursor row 
bcd1 7d					ld a,l 
bcd2 fe 02				cp 2 
bcd4 20 04				jr nz, .crow3aq 
bcd6 3e 28				ld a, display_row_2 
bcd8 18 12				jr .ccol1aq 
bcda fe 03		.crow3aq:		cp 3 
bcdc 20 04				jr nz, .crow4aq 
bcde 3e 50				ld a, display_row_3 
bce0 18 0a				jr .ccol1aq 
bce2 fe 04		.crow4aq:		cp 4 
bce4 20 04				jr nz, .crow1aq 
bce6 3e 78				ld a, display_row_4 
bce8 18 02				jr .ccol1aq 
bcea 3e 00		.crow1aq:		ld a,display_row_1 
bcec f5			.ccol1aq:		push af			; got row offset 
bced 6f					ld l,a 
bcee 26 00				ld h,0 
bcf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcf0 cd 8b 9d			call macro_forth_dsp_pop 
bcf3				endm 
# End of macro FORTH_DSP_POP
bcf3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bcf3 cd d3 9c			call macro_dsp_valuehl 
bcf6				endm 
# End of macro FORTH_DSP_VALUEHL
bcf6					; TODO save cursor col 
bcf6 f1					pop af 
bcf7 85					add l		; add col offset 
bcf8			 
bcf8					; add current frame buffer address 
bcf8 2a d2 eb				ld hl, (display_fb_active) 
bcfb cd 6a 8c				call addatohl 
bcfe			 
bcfe			 
bcfe			 
bcfe			 
bcfe					; get char frame buffer location offset in hl 
bcfe			 
bcfe 7e					ld a,(hl) 
bcff 26 00				ld h, 0 
bd01 6f					ld l, a 
bd02			 
bd02 cd dc 9a				call forth_push_numhl 
bd05			 
bd05			 
bd05					NEXTW 
bd05 c3 4a 9e			jp macro_next 
bd08				endm 
# End of macro NEXTW
bd08			 
bd08			.AUTODSP: 
bd08				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bd08 63				db WORD_SYS_CORE+79             
bd09 1e bd			dw .MENU            
bd0b 05				db 4 + 1 
bd0c .. 00			db "ADSP",0              
bd11				endm 
# End of macro CWHEAD
bd11			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bd11			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bd11			 
bd11					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd11 cd d3 9c			call macro_dsp_valuehl 
bd14				endm 
# End of macro FORTH_DSP_VALUEHL
bd14			 
bd14			;		push hl 
bd14			 
bd14					; destroy value TOS 
bd14			 
bd14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd14 cd 8b 9d			call macro_forth_dsp_pop 
bd17				endm 
# End of macro FORTH_DSP_POP
bd17			 
bd17			;		pop hl 
bd17			 
bd17 7d					ld a,l 
bd18 32 49 ea				ld (cli_autodisplay), a 
bd1b				       NEXTW 
bd1b c3 4a 9e			jp macro_next 
bd1e				endm 
# End of macro NEXTW
bd1e			 
bd1e			.MENU: 
bd1e				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bd1e 70				db WORD_SYS_CORE+92             
bd1f c7 bd			dw .ENDDISPLAY            
bd21 05				db 4 + 1 
bd22 .. 00			db "MENU",0              
bd27				endm 
# End of macro CWHEAD
bd27			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bd27			 
bd27			;		; get number of items on the stack 
bd27			; 
bd27				 
bd27					FORTH_DSP_VALUEHL 
bd27 cd d3 9c			call macro_dsp_valuehl 
bd2a				endm 
# End of macro FORTH_DSP_VALUEHL
bd2a				 
bd2a					if DEBUG_FORTH_WORDS_KEY 
bd2a						DMARK "MNU" 
bd2a f5				push af  
bd2b 3a 3f bd			ld a, (.dmark)  
bd2e 32 71 ee			ld (debug_mark),a  
bd31 3a 40 bd			ld a, (.dmark+1)  
bd34 32 72 ee			ld (debug_mark+1),a  
bd37 3a 41 bd			ld a, (.dmark+2)  
bd3a 32 73 ee			ld (debug_mark+2),a  
bd3d 18 03			jr .pastdmark  
bd3f ..			.dmark: db "MNU"  
bd42 f1			.pastdmark: pop af  
bd43			endm  
# End of macro DMARK
bd43						CALLMONITOR 
bd43 cd 6b 94			call break_point_state  
bd46				endm  
# End of macro CALLMONITOR
bd46					endif 
bd46			 
bd46 45					ld b, l	 
bd47 05					dec b 
bd48			 
bd48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd48 cd 8b 9d			call macro_forth_dsp_pop 
bd4b				endm 
# End of macro FORTH_DSP_POP
bd4b			 
bd4b			 
bd4b					; go directly through the stack to pluck out the string pointers and build an array 
bd4b			 
bd4b			;		FORTH_DSP 
bd4b			 
bd4b					; hl contains top most stack item 
bd4b				 
bd4b 11 02 e3				ld de, scratch 
bd4e			 
bd4e			.mbuild: 
bd4e			 
bd4e					FORTH_DSP_VALUEHL 
bd4e cd d3 9c			call macro_dsp_valuehl 
bd51				endm 
# End of macro FORTH_DSP_VALUEHL
bd51			 
bd51					if DEBUG_FORTH_WORDS 
bd51						DMARK "MN3" 
bd51 f5				push af  
bd52 3a 66 bd			ld a, (.dmark)  
bd55 32 71 ee			ld (debug_mark),a  
bd58 3a 67 bd			ld a, (.dmark+1)  
bd5b 32 72 ee			ld (debug_mark+1),a  
bd5e 3a 68 bd			ld a, (.dmark+2)  
bd61 32 73 ee			ld (debug_mark+2),a  
bd64 18 03			jr .pastdmark  
bd66 ..			.dmark: db "MN3"  
bd69 f1			.pastdmark: pop af  
bd6a			endm  
# End of macro DMARK
bd6a						CALLMONITOR 
bd6a cd 6b 94			call break_point_state  
bd6d				endm  
# End of macro CALLMONITOR
bd6d					endif 
bd6d eb					ex de, hl 
bd6e 73					ld (hl), e 
bd6f 23					inc hl 
bd70 72					ld (hl), d 
bd71 23					inc hl 
bd72 eb					ex de, hl 
bd73			 
bd73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd73 cd 8b 9d			call macro_forth_dsp_pop 
bd76				endm 
# End of macro FORTH_DSP_POP
bd76			 
bd76 10 d6				djnz .mbuild 
bd78			 
bd78					; done add term 
bd78			 
bd78 eb					ex de, hl 
bd79 36 00				ld (hl), 0 
bd7b 23					inc hl 
bd7c 36 00				ld (hl), 0 
bd7e			 
bd7e				 
bd7e					 
bd7e 21 02 e3				ld hl, scratch 
bd81			 
bd81					if DEBUG_FORTH_WORDS 
bd81						DMARK "MNx" 
bd81 f5				push af  
bd82 3a 96 bd			ld a, (.dmark)  
bd85 32 71 ee			ld (debug_mark),a  
bd88 3a 97 bd			ld a, (.dmark+1)  
bd8b 32 72 ee			ld (debug_mark+1),a  
bd8e 3a 98 bd			ld a, (.dmark+2)  
bd91 32 73 ee			ld (debug_mark+2),a  
bd94 18 03			jr .pastdmark  
bd96 ..			.dmark: db "MNx"  
bd99 f1			.pastdmark: pop af  
bd9a			endm  
# End of macro DMARK
bd9a						CALLMONITOR 
bd9a cd 6b 94			call break_point_state  
bd9d				endm  
# End of macro CALLMONITOR
bd9d					endif 
bd9d			 
bd9d			 
bd9d			 
bd9d 3e 00				ld a, 0 
bd9f cd 6e 8a				call menu 
bda2			 
bda2			 
bda2 6f					ld l, a 
bda3 26 00				ld h, 0 
bda5			 
bda5					if DEBUG_FORTH_WORDS 
bda5						DMARK "MNr" 
bda5 f5				push af  
bda6 3a ba bd			ld a, (.dmark)  
bda9 32 71 ee			ld (debug_mark),a  
bdac 3a bb bd			ld a, (.dmark+1)  
bdaf 32 72 ee			ld (debug_mark+1),a  
bdb2 3a bc bd			ld a, (.dmark+2)  
bdb5 32 73 ee			ld (debug_mark+2),a  
bdb8 18 03			jr .pastdmark  
bdba ..			.dmark: db "MNr"  
bdbd f1			.pastdmark: pop af  
bdbe			endm  
# End of macro DMARK
bdbe						CALLMONITOR 
bdbe cd 6b 94			call break_point_state  
bdc1				endm  
# End of macro CALLMONITOR
bdc1					endif 
bdc1			 
bdc1 cd dc 9a				call forth_push_numhl 
bdc4			 
bdc4			 
bdc4			 
bdc4			 
bdc4				       NEXTW 
bdc4 c3 4a 9e			jp macro_next 
bdc7				endm 
# End of macro NEXTW
bdc7			 
bdc7			 
bdc7			.ENDDISPLAY: 
bdc7			 
bdc7			; eof 
# End of file forth_words_display.asm
bdc7			include "forth_words_str.asm" 
bdc7			 
bdc7			; | ## String Words 
bdc7			 
bdc7			.PTR:   
bdc7			 
bdc7				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bdc7 48				db WORD_SYS_CORE+52             
bdc8 f4 bd			dw .STYPE            
bdca 04				db 3 + 1 
bdcb .. 00			db "PTR",0              
bdcf				endm 
# End of macro CWHEAD
bdcf			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bdcf			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bdcf			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bdcf			 
bdcf					if DEBUG_FORTH_WORDS_KEY 
bdcf						DMARK "PTR" 
bdcf f5				push af  
bdd0 3a e4 bd			ld a, (.dmark)  
bdd3 32 71 ee			ld (debug_mark),a  
bdd6 3a e5 bd			ld a, (.dmark+1)  
bdd9 32 72 ee			ld (debug_mark+1),a  
bddc 3a e6 bd			ld a, (.dmark+2)  
bddf 32 73 ee			ld (debug_mark+2),a  
bde2 18 03			jr .pastdmark  
bde4 ..			.dmark: db "PTR"  
bde7 f1			.pastdmark: pop af  
bde8			endm  
# End of macro DMARK
bde8						CALLMONITOR 
bde8 cd 6b 94			call break_point_state  
bdeb				endm  
# End of macro CALLMONITOR
bdeb					endif 
bdeb					FORTH_DSP_VALUEHL 
bdeb cd d3 9c			call macro_dsp_valuehl 
bdee				endm 
# End of macro FORTH_DSP_VALUEHL
bdee cd dc 9a				call forth_push_numhl 
bdf1			 
bdf1			 
bdf1					NEXTW 
bdf1 c3 4a 9e			jp macro_next 
bdf4				endm 
# End of macro NEXTW
bdf4			.STYPE: 
bdf4				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bdf4 48				db WORD_SYS_CORE+52             
bdf5 43 be			dw .UPPER            
bdf7 06				db 5 + 1 
bdf8 .. 00			db "STYPE",0              
bdfe				endm 
# End of macro CWHEAD
bdfe			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bdfe					if DEBUG_FORTH_WORDS_KEY 
bdfe						DMARK "STY" 
bdfe f5				push af  
bdff 3a 13 be			ld a, (.dmark)  
be02 32 71 ee			ld (debug_mark),a  
be05 3a 14 be			ld a, (.dmark+1)  
be08 32 72 ee			ld (debug_mark+1),a  
be0b 3a 15 be			ld a, (.dmark+2)  
be0e 32 73 ee			ld (debug_mark+2),a  
be11 18 03			jr .pastdmark  
be13 ..			.dmark: db "STY"  
be16 f1			.pastdmark: pop af  
be17			endm  
# End of macro DMARK
be17						CALLMONITOR 
be17 cd 6b 94			call break_point_state  
be1a				endm  
# End of macro CALLMONITOR
be1a					endif 
be1a					FORTH_DSP 
be1a cd 99 9c			call macro_forth_dsp 
be1d				endm 
# End of macro FORTH_DSP
be1d					;v5 FORTH_DSP_VALUE 
be1d			 
be1d 7e					ld a, (hl) 
be1e			 
be1e f5					push af 
be1f			 
be1f			; Dont destroy TOS		FORTH_DSP_POP 
be1f			 
be1f f1					pop af 
be20			 
be20 fe 01				cp DS_TYPE_STR 
be22 28 09				jr z, .typestr 
be24			 
be24 fe 02				cp DS_TYPE_INUM 
be26 28 0a				jr z, .typeinum 
be28			 
be28 21 41 be				ld hl, .tna 
be2b 18 0a				jr .tpush 
be2d			 
be2d 21 3d be		.typestr:	ld hl, .tstr 
be30 18 05				jr .tpush 
be32 21 3f be		.typeinum:	ld hl, .tinum 
be35 18 00				jr .tpush 
be37			 
be37			.tpush: 
be37			 
be37 cd 4a 9b				call forth_push_str 
be3a			 
be3a					NEXTW 
be3a c3 4a 9e			jp macro_next 
be3d				endm 
# End of macro NEXTW
be3d .. 00		.tstr:	db "s",0 
be3f .. 00		.tinum:  db "i",0 
be41 .. 00		.tna:   db "?", 0 
be43			 
be43			 
be43			.UPPER: 
be43				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
be43 48				db WORD_SYS_CORE+52             
be44 7e be			dw .LOWER            
be46 06				db 5 + 1 
be47 .. 00			db "UPPER",0              
be4d				endm 
# End of macro CWHEAD
be4d			; | UPPER ( s -- s ) Upper case string s  | DONE 
be4d					if DEBUG_FORTH_WORDS_KEY 
be4d						DMARK "UPR" 
be4d f5				push af  
be4e 3a 62 be			ld a, (.dmark)  
be51 32 71 ee			ld (debug_mark),a  
be54 3a 63 be			ld a, (.dmark+1)  
be57 32 72 ee			ld (debug_mark+1),a  
be5a 3a 64 be			ld a, (.dmark+2)  
be5d 32 73 ee			ld (debug_mark+2),a  
be60 18 03			jr .pastdmark  
be62 ..			.dmark: db "UPR"  
be65 f1			.pastdmark: pop af  
be66			endm  
# End of macro DMARK
be66						CALLMONITOR 
be66 cd 6b 94			call break_point_state  
be69				endm  
# End of macro CALLMONITOR
be69					endif 
be69			 
be69					FORTH_DSP 
be69 cd 99 9c			call macro_forth_dsp 
be6c				endm 
# End of macro FORTH_DSP
be6c					 
be6c			; TODO check is string type 
be6c			 
be6c					FORTH_DSP_VALUEHL 
be6c cd d3 9c			call macro_dsp_valuehl 
be6f				endm 
# End of macro FORTH_DSP_VALUEHL
be6f			; get pointer to string in hl 
be6f			 
be6f 7e			.toup:		ld a, (hl) 
be70 fe 00				cp 0 
be72 28 07				jr z, .toupdone 
be74			 
be74 cd d7 8f				call to_upper 
be77			 
be77 77					ld (hl), a 
be78 23					inc hl 
be79 18 f4				jr .toup 
be7b			 
be7b					 
be7b			 
be7b			 
be7b			; for each char convert to upper 
be7b					 
be7b			.toupdone: 
be7b			 
be7b			 
be7b					NEXTW 
be7b c3 4a 9e			jp macro_next 
be7e				endm 
# End of macro NEXTW
be7e			.LOWER: 
be7e				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
be7e 48				db WORD_SYS_CORE+52             
be7f b9 be			dw .TCASE            
be81 06				db 5 + 1 
be82 .. 00			db "LOWER",0              
be88				endm 
# End of macro CWHEAD
be88			; | LOWER ( s -- s ) Lower case string s  | DONE 
be88					if DEBUG_FORTH_WORDS_KEY 
be88						DMARK "LWR" 
be88 f5				push af  
be89 3a 9d be			ld a, (.dmark)  
be8c 32 71 ee			ld (debug_mark),a  
be8f 3a 9e be			ld a, (.dmark+1)  
be92 32 72 ee			ld (debug_mark+1),a  
be95 3a 9f be			ld a, (.dmark+2)  
be98 32 73 ee			ld (debug_mark+2),a  
be9b 18 03			jr .pastdmark  
be9d ..			.dmark: db "LWR"  
bea0 f1			.pastdmark: pop af  
bea1			endm  
# End of macro DMARK
bea1						CALLMONITOR 
bea1 cd 6b 94			call break_point_state  
bea4				endm  
# End of macro CALLMONITOR
bea4					endif 
bea4			 
bea4					FORTH_DSP 
bea4 cd 99 9c			call macro_forth_dsp 
bea7				endm 
# End of macro FORTH_DSP
bea7					 
bea7			; TODO check is string type 
bea7			 
bea7					FORTH_DSP_VALUEHL 
bea7 cd d3 9c			call macro_dsp_valuehl 
beaa				endm 
# End of macro FORTH_DSP_VALUEHL
beaa			; get pointer to string in hl 
beaa			 
beaa 7e			.tolow:		ld a, (hl) 
beab fe 00				cp 0 
bead 28 07				jr z, .tolowdone 
beaf			 
beaf cd e0 8f				call to_lower 
beb2			 
beb2 77					ld (hl), a 
beb3 23					inc hl 
beb4 18 f4				jr .tolow 
beb6			 
beb6					 
beb6			 
beb6			 
beb6			; for each char convert to low 
beb6					 
beb6			.tolowdone: 
beb6					NEXTW 
beb6 c3 4a 9e			jp macro_next 
beb9				endm 
# End of macro NEXTW
beb9			.TCASE: 
beb9				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
beb9 48				db WORD_SYS_CORE+52             
beba ef bf			dw .SUBSTR            
bebc 06				db 5 + 1 
bebd .. 00			db "TCASE",0              
bec3				endm 
# End of macro CWHEAD
bec3			; | TCASE ( s -- s ) Title case string s  | DONE 
bec3					if DEBUG_FORTH_WORDS_KEY 
bec3						DMARK "TCS" 
bec3 f5				push af  
bec4 3a d8 be			ld a, (.dmark)  
bec7 32 71 ee			ld (debug_mark),a  
beca 3a d9 be			ld a, (.dmark+1)  
becd 32 72 ee			ld (debug_mark+1),a  
bed0 3a da be			ld a, (.dmark+2)  
bed3 32 73 ee			ld (debug_mark+2),a  
bed6 18 03			jr .pastdmark  
bed8 ..			.dmark: db "TCS"  
bedb f1			.pastdmark: pop af  
bedc			endm  
# End of macro DMARK
bedc						CALLMONITOR 
bedc cd 6b 94			call break_point_state  
bedf				endm  
# End of macro CALLMONITOR
bedf					endif 
bedf			 
bedf					FORTH_DSP 
bedf cd 99 9c			call macro_forth_dsp 
bee2				endm 
# End of macro FORTH_DSP
bee2					 
bee2			; TODO check is string type 
bee2			 
bee2					FORTH_DSP_VALUEHL 
bee2 cd d3 9c			call macro_dsp_valuehl 
bee5				endm 
# End of macro FORTH_DSP_VALUEHL
bee5			; get pointer to string in hl 
bee5			 
bee5					if DEBUG_FORTH_WORDS 
bee5						DMARK "TC1" 
bee5 f5				push af  
bee6 3a fa be			ld a, (.dmark)  
bee9 32 71 ee			ld (debug_mark),a  
beec 3a fb be			ld a, (.dmark+1)  
beef 32 72 ee			ld (debug_mark+1),a  
bef2 3a fc be			ld a, (.dmark+2)  
bef5 32 73 ee			ld (debug_mark+2),a  
bef8 18 03			jr .pastdmark  
befa ..			.dmark: db "TC1"  
befd f1			.pastdmark: pop af  
befe			endm  
# End of macro DMARK
befe						CALLMONITOR 
befe cd 6b 94			call break_point_state  
bf01				endm  
# End of macro CALLMONITOR
bf01					endif 
bf01			 
bf01					; first time in turn to upper case first char 
bf01			 
bf01 7e					ld a, (hl) 
bf02 c3 8c bf				jp .totsiptou 
bf05			 
bf05			 
bf05 7e			.tot:		ld a, (hl) 
bf06 fe 00				cp 0 
bf08 ca d0 bf				jp z, .totdone 
bf0b			 
bf0b					if DEBUG_FORTH_WORDS 
bf0b						DMARK "TC2" 
bf0b f5				push af  
bf0c 3a 20 bf			ld a, (.dmark)  
bf0f 32 71 ee			ld (debug_mark),a  
bf12 3a 21 bf			ld a, (.dmark+1)  
bf15 32 72 ee			ld (debug_mark+1),a  
bf18 3a 22 bf			ld a, (.dmark+2)  
bf1b 32 73 ee			ld (debug_mark+2),a  
bf1e 18 03			jr .pastdmark  
bf20 ..			.dmark: db "TC2"  
bf23 f1			.pastdmark: pop af  
bf24			endm  
# End of macro DMARK
bf24						CALLMONITOR 
bf24 cd 6b 94			call break_point_state  
bf27				endm  
# End of macro CALLMONITOR
bf27					endif 
bf27					; check to see if current char is a space 
bf27			 
bf27 fe 20				cp ' ' 
bf29 28 21				jr z, .totsp 
bf2b cd e0 8f				call to_lower 
bf2e					if DEBUG_FORTH_WORDS 
bf2e						DMARK "TC3" 
bf2e f5				push af  
bf2f 3a 43 bf			ld a, (.dmark)  
bf32 32 71 ee			ld (debug_mark),a  
bf35 3a 44 bf			ld a, (.dmark+1)  
bf38 32 72 ee			ld (debug_mark+1),a  
bf3b 3a 45 bf			ld a, (.dmark+2)  
bf3e 32 73 ee			ld (debug_mark+2),a  
bf41 18 03			jr .pastdmark  
bf43 ..			.dmark: db "TC3"  
bf46 f1			.pastdmark: pop af  
bf47			endm  
# End of macro DMARK
bf47						CALLMONITOR 
bf47 cd 6b 94			call break_point_state  
bf4a				endm  
# End of macro CALLMONITOR
bf4a					endif 
bf4a 18 63				jr .totnxt 
bf4c			 
bf4c			.totsp:         ; on a space, find next char which should be upper 
bf4c			 
bf4c					if DEBUG_FORTH_WORDS 
bf4c						DMARK "TC4" 
bf4c f5				push af  
bf4d 3a 61 bf			ld a, (.dmark)  
bf50 32 71 ee			ld (debug_mark),a  
bf53 3a 62 bf			ld a, (.dmark+1)  
bf56 32 72 ee			ld (debug_mark+1),a  
bf59 3a 63 bf			ld a, (.dmark+2)  
bf5c 32 73 ee			ld (debug_mark+2),a  
bf5f 18 03			jr .pastdmark  
bf61 ..			.dmark: db "TC4"  
bf64 f1			.pastdmark: pop af  
bf65			endm  
# End of macro DMARK
bf65						CALLMONITOR 
bf65 cd 6b 94			call break_point_state  
bf68				endm  
# End of macro CALLMONITOR
bf68					endif 
bf68					;; 
bf68			 
bf68 fe 20				cp ' ' 
bf6a 20 20				jr nz, .totsiptou 
bf6c 23					inc hl 
bf6d 7e					ld a, (hl) 
bf6e					if DEBUG_FORTH_WORDS 
bf6e						DMARK "TC5" 
bf6e f5				push af  
bf6f 3a 83 bf			ld a, (.dmark)  
bf72 32 71 ee			ld (debug_mark),a  
bf75 3a 84 bf			ld a, (.dmark+1)  
bf78 32 72 ee			ld (debug_mark+1),a  
bf7b 3a 85 bf			ld a, (.dmark+2)  
bf7e 32 73 ee			ld (debug_mark+2),a  
bf81 18 03			jr .pastdmark  
bf83 ..			.dmark: db "TC5"  
bf86 f1			.pastdmark: pop af  
bf87			endm  
# End of macro DMARK
bf87						CALLMONITOR 
bf87 cd 6b 94			call break_point_state  
bf8a				endm  
# End of macro CALLMONITOR
bf8a					endif 
bf8a 18 c0				jr .totsp 
bf8c fe 00		.totsiptou:    cp 0 
bf8e 28 40				jr z, .totdone 
bf90					; not space and not zero term so upper case it 
bf90 cd d7 8f				call to_upper 
bf93			 
bf93					if DEBUG_FORTH_WORDS 
bf93						DMARK "TC6" 
bf93 f5				push af  
bf94 3a a8 bf			ld a, (.dmark)  
bf97 32 71 ee			ld (debug_mark),a  
bf9a 3a a9 bf			ld a, (.dmark+1)  
bf9d 32 72 ee			ld (debug_mark+1),a  
bfa0 3a aa bf			ld a, (.dmark+2)  
bfa3 32 73 ee			ld (debug_mark+2),a  
bfa6 18 03			jr .pastdmark  
bfa8 ..			.dmark: db "TC6"  
bfab f1			.pastdmark: pop af  
bfac			endm  
# End of macro DMARK
bfac						CALLMONITOR 
bfac cd 6b 94			call break_point_state  
bfaf				endm  
# End of macro CALLMONITOR
bfaf					endif 
bfaf			 
bfaf			 
bfaf			.totnxt: 
bfaf			 
bfaf 77					ld (hl), a 
bfb0 23					inc hl 
bfb1					if DEBUG_FORTH_WORDS 
bfb1						DMARK "TC7" 
bfb1 f5				push af  
bfb2 3a c6 bf			ld a, (.dmark)  
bfb5 32 71 ee			ld (debug_mark),a  
bfb8 3a c7 bf			ld a, (.dmark+1)  
bfbb 32 72 ee			ld (debug_mark+1),a  
bfbe 3a c8 bf			ld a, (.dmark+2)  
bfc1 32 73 ee			ld (debug_mark+2),a  
bfc4 18 03			jr .pastdmark  
bfc6 ..			.dmark: db "TC7"  
bfc9 f1			.pastdmark: pop af  
bfca			endm  
# End of macro DMARK
bfca						CALLMONITOR 
bfca cd 6b 94			call break_point_state  
bfcd				endm  
# End of macro CALLMONITOR
bfcd					endif 
bfcd c3 05 bf				jp .tot 
bfd0			 
bfd0					 
bfd0			 
bfd0			 
bfd0			; for each char convert to low 
bfd0					 
bfd0			.totdone: 
bfd0					if DEBUG_FORTH_WORDS 
bfd0						DMARK "TCd" 
bfd0 f5				push af  
bfd1 3a e5 bf			ld a, (.dmark)  
bfd4 32 71 ee			ld (debug_mark),a  
bfd7 3a e6 bf			ld a, (.dmark+1)  
bfda 32 72 ee			ld (debug_mark+1),a  
bfdd 3a e7 bf			ld a, (.dmark+2)  
bfe0 32 73 ee			ld (debug_mark+2),a  
bfe3 18 03			jr .pastdmark  
bfe5 ..			.dmark: db "TCd"  
bfe8 f1			.pastdmark: pop af  
bfe9			endm  
# End of macro DMARK
bfe9						CALLMONITOR 
bfe9 cd 6b 94			call break_point_state  
bfec				endm  
# End of macro CALLMONITOR
bfec					endif 
bfec					NEXTW 
bfec c3 4a 9e			jp macro_next 
bfef				endm 
# End of macro NEXTW
bfef			 
bfef			.SUBSTR: 
bfef				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bfef 48				db WORD_SYS_CORE+52             
bff0 4d c0			dw .LEFT            
bff2 07				db 6 + 1 
bff3 .. 00			db "SUBSTR",0              
bffa				endm 
# End of macro CWHEAD
bffa			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
bffa			 
bffa					if DEBUG_FORTH_WORDS_KEY 
bffa						DMARK "SST" 
bffa f5				push af  
bffb 3a 0f c0			ld a, (.dmark)  
bffe 32 71 ee			ld (debug_mark),a  
c001 3a 10 c0			ld a, (.dmark+1)  
c004 32 72 ee			ld (debug_mark+1),a  
c007 3a 11 c0			ld a, (.dmark+2)  
c00a 32 73 ee			ld (debug_mark+2),a  
c00d 18 03			jr .pastdmark  
c00f ..			.dmark: db "SST"  
c012 f1			.pastdmark: pop af  
c013			endm  
# End of macro DMARK
c013						CALLMONITOR 
c013 cd 6b 94			call break_point_state  
c016				endm  
# End of macro CALLMONITOR
c016					endif 
c016			; TODO check string type 
c016					FORTH_DSP_VALUEHL 
c016 cd d3 9c			call macro_dsp_valuehl 
c019				endm 
# End of macro FORTH_DSP_VALUEHL
c019			 
c019 e5					push hl      ; string length 
c01a			 
c01a					FORTH_DSP_POP 
c01a cd 8b 9d			call macro_forth_dsp_pop 
c01d				endm 
# End of macro FORTH_DSP_POP
c01d			 
c01d					FORTH_DSP_VALUEHL 
c01d cd d3 9c			call macro_dsp_valuehl 
c020				endm 
# End of macro FORTH_DSP_VALUEHL
c020			 
c020 e5					push hl     ; start char 
c021			 
c021					FORTH_DSP_POP 
c021 cd 8b 9d			call macro_forth_dsp_pop 
c024				endm 
# End of macro FORTH_DSP_POP
c024			 
c024			 
c024					FORTH_DSP_VALUE 
c024 cd bc 9c			call macro_forth_dsp_value 
c027				endm 
# End of macro FORTH_DSP_VALUE
c027			 
c027 d1					pop de    ; get start post offset 
c028			 
c028 19					add hl, de    ; starting offset 
c029			 
c029 c1					pop bc 
c02a c5					push bc      ; grab size of string 
c02b			 
c02b e5					push hl    ; save string start  
c02c			 
c02c 26 00				ld h, 0 
c02e 69					ld l, c 
c02f 23					inc hl 
c030 23					inc hl 
c031			 
c031 cd 31 91				call malloc 
c034				if DEBUG_FORTH_MALLOC_GUARD 
c034 cc b1 c6				call z,malloc_error 
c037				endif 
c037			 
c037 eb					ex de, hl      ; save malloc area for string copy 
c038 e1					pop hl    ; get back source 
c039 c1					pop bc    ; get length of string back 
c03a			 
c03a d5					push de    ; save malloc area for after we push 
c03b ed b0				ldir     ; copy substr 
c03d			 
c03d			 
c03d eb					ex de, hl 
c03e 3e 00				ld a, 0 
c040 77					ld (hl), a   ; term substr 
c041			 
c041					 
c041 e1					pop hl    ; get malloc so we can push it 
c042 e5					push hl   ; save so we can free it afterwards 
c043			 
c043 cd 4a 9b				call forth_push_str 
c046			 
c046 e1					pop hl 
c047 cd fb 91				call free 
c04a			 
c04a					 
c04a					 
c04a			 
c04a			 
c04a					NEXTW 
c04a c3 4a 9e			jp macro_next 
c04d				endm 
# End of macro NEXTW
c04d			 
c04d			.LEFT: 
c04d				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c04d 48				db WORD_SYS_CORE+52             
c04e 75 c0			dw .RIGHT            
c050 05				db 4 + 1 
c051 .. 00			db "LEFT",0              
c056				endm 
# End of macro CWHEAD
c056			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c056					if DEBUG_FORTH_WORDS_KEY 
c056						DMARK "LEF" 
c056 f5				push af  
c057 3a 6b c0			ld a, (.dmark)  
c05a 32 71 ee			ld (debug_mark),a  
c05d 3a 6c c0			ld a, (.dmark+1)  
c060 32 72 ee			ld (debug_mark+1),a  
c063 3a 6d c0			ld a, (.dmark+2)  
c066 32 73 ee			ld (debug_mark+2),a  
c069 18 03			jr .pastdmark  
c06b ..			.dmark: db "LEF"  
c06e f1			.pastdmark: pop af  
c06f			endm  
# End of macro DMARK
c06f						CALLMONITOR 
c06f cd 6b 94			call break_point_state  
c072				endm  
# End of macro CALLMONITOR
c072					endif 
c072			 
c072					NEXTW 
c072 c3 4a 9e			jp macro_next 
c075				endm 
# End of macro NEXTW
c075			.RIGHT: 
c075				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c075 48				db WORD_SYS_CORE+52             
c076 9e c0			dw .STR2NUM            
c078 06				db 5 + 1 
c079 .. 00			db "RIGHT",0              
c07f				endm 
# End of macro CWHEAD
c07f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c07f					if DEBUG_FORTH_WORDS_KEY 
c07f						DMARK "RIG" 
c07f f5				push af  
c080 3a 94 c0			ld a, (.dmark)  
c083 32 71 ee			ld (debug_mark),a  
c086 3a 95 c0			ld a, (.dmark+1)  
c089 32 72 ee			ld (debug_mark+1),a  
c08c 3a 96 c0			ld a, (.dmark+2)  
c08f 32 73 ee			ld (debug_mark+2),a  
c092 18 03			jr .pastdmark  
c094 ..			.dmark: db "RIG"  
c097 f1			.pastdmark: pop af  
c098			endm  
# End of macro DMARK
c098						CALLMONITOR 
c098 cd 6b 94			call break_point_state  
c09b				endm  
# End of macro CALLMONITOR
c09b					endif 
c09b			 
c09b					NEXTW 
c09b c3 4a 9e			jp macro_next 
c09e				endm 
# End of macro NEXTW
c09e			 
c09e			 
c09e			.STR2NUM: 
c09e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c09e 48				db WORD_SYS_CORE+52             
c09f 2a c1			dw .NUM2STR            
c0a1 08				db 7 + 1 
c0a2 .. 00			db "STR2NUM",0              
c0aa				endm 
# End of macro CWHEAD
c0aa			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c0aa			 
c0aa			 
c0aa			; TODO STR type check to do 
c0aa					if DEBUG_FORTH_WORDS_KEY 
c0aa						DMARK "S2N" 
c0aa f5				push af  
c0ab 3a bf c0			ld a, (.dmark)  
c0ae 32 71 ee			ld (debug_mark),a  
c0b1 3a c0 c0			ld a, (.dmark+1)  
c0b4 32 72 ee			ld (debug_mark+1),a  
c0b7 3a c1 c0			ld a, (.dmark+2)  
c0ba 32 73 ee			ld (debug_mark+2),a  
c0bd 18 03			jr .pastdmark  
c0bf ..			.dmark: db "S2N"  
c0c2 f1			.pastdmark: pop af  
c0c3			endm  
# End of macro DMARK
c0c3						CALLMONITOR 
c0c3 cd 6b 94			call break_point_state  
c0c6				endm  
# End of macro CALLMONITOR
c0c6					endif 
c0c6			 
c0c6					;FORTH_DSP 
c0c6					FORTH_DSP_VALUE 
c0c6 cd bc 9c			call macro_forth_dsp_value 
c0c9				endm 
# End of macro FORTH_DSP_VALUE
c0c9					;inc hl 
c0c9			 
c0c9 eb					ex de, hl 
c0ca					if DEBUG_FORTH_WORDS 
c0ca						DMARK "S2a" 
c0ca f5				push af  
c0cb 3a df c0			ld a, (.dmark)  
c0ce 32 71 ee			ld (debug_mark),a  
c0d1 3a e0 c0			ld a, (.dmark+1)  
c0d4 32 72 ee			ld (debug_mark+1),a  
c0d7 3a e1 c0			ld a, (.dmark+2)  
c0da 32 73 ee			ld (debug_mark+2),a  
c0dd 18 03			jr .pastdmark  
c0df ..			.dmark: db "S2a"  
c0e2 f1			.pastdmark: pop af  
c0e3			endm  
# End of macro DMARK
c0e3						CALLMONITOR 
c0e3 cd 6b 94			call break_point_state  
c0e6				endm  
# End of macro CALLMONITOR
c0e6					endif 
c0e6 cd 5f 90				call string_to_uint16 
c0e9			 
c0e9					if DEBUG_FORTH_WORDS 
c0e9						DMARK "S2b" 
c0e9 f5				push af  
c0ea 3a fe c0			ld a, (.dmark)  
c0ed 32 71 ee			ld (debug_mark),a  
c0f0 3a ff c0			ld a, (.dmark+1)  
c0f3 32 72 ee			ld (debug_mark+1),a  
c0f6 3a 00 c1			ld a, (.dmark+2)  
c0f9 32 73 ee			ld (debug_mark+2),a  
c0fc 18 03			jr .pastdmark  
c0fe ..			.dmark: db "S2b"  
c101 f1			.pastdmark: pop af  
c102			endm  
# End of macro DMARK
c102						CALLMONITOR 
c102 cd 6b 94			call break_point_state  
c105				endm  
# End of macro CALLMONITOR
c105					endif 
c105			;		push hl 
c105					FORTH_DSP_POP 
c105 cd 8b 9d			call macro_forth_dsp_pop 
c108				endm 
# End of macro FORTH_DSP_POP
c108			;		pop hl 
c108					 
c108					if DEBUG_FORTH_WORDS 
c108						DMARK "S2b" 
c108 f5				push af  
c109 3a 1d c1			ld a, (.dmark)  
c10c 32 71 ee			ld (debug_mark),a  
c10f 3a 1e c1			ld a, (.dmark+1)  
c112 32 72 ee			ld (debug_mark+1),a  
c115 3a 1f c1			ld a, (.dmark+2)  
c118 32 73 ee			ld (debug_mark+2),a  
c11b 18 03			jr .pastdmark  
c11d ..			.dmark: db "S2b"  
c120 f1			.pastdmark: pop af  
c121			endm  
# End of macro DMARK
c121						CALLMONITOR 
c121 cd 6b 94			call break_point_state  
c124				endm  
# End of macro CALLMONITOR
c124					endif 
c124 cd dc 9a				call forth_push_numhl	 
c127			 
c127				 
c127				       NEXTW 
c127 c3 4a 9e			jp macro_next 
c12a				endm 
# End of macro NEXTW
c12a			.NUM2STR: 
c12a				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c12a 48				db WORD_SYS_CORE+52             
c12b 39 c1			dw .CONCAT            
c12d 08				db 7 + 1 
c12e .. 00			db "NUM2STR",0              
c136				endm 
# End of macro CWHEAD
c136			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c136			 
c136			;		; malloc a string to target 
c136			;		ld hl, 10     ; TODO max string size should be fine 
c136			;		call malloc 
c136			;		push hl    ; save malloc location 
c136			; 
c136			; 
c136			;; TODO check int type 
c136			;		FORTH_DSP_VALUEHL 
c136			;		ld a, l 
c136			;		call DispAToASCII   
c136			;;TODO need to chage above call to dump into string 
c136			; 
c136			; 
c136			 
c136				       NEXTW 
c136 c3 4a 9e			jp macro_next 
c139				endm 
# End of macro NEXTW
c139			 
c139			.CONCAT: 
c139				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c139 48				db WORD_SYS_CORE+52             
c13a ec c1			dw .FIND            
c13c 07				db 6 + 1 
c13d .. 00			db "CONCAT",0              
c144				endm 
# End of macro CWHEAD
c144			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c144			 
c144			; TODO check string type 
c144			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c144			 
c144					if DEBUG_FORTH_WORDS_KEY 
c144						DMARK "CON" 
c144 f5				push af  
c145 3a 59 c1			ld a, (.dmark)  
c148 32 71 ee			ld (debug_mark),a  
c14b 3a 5a c1			ld a, (.dmark+1)  
c14e 32 72 ee			ld (debug_mark+1),a  
c151 3a 5b c1			ld a, (.dmark+2)  
c154 32 73 ee			ld (debug_mark+2),a  
c157 18 03			jr .pastdmark  
c159 ..			.dmark: db "CON"  
c15c f1			.pastdmark: pop af  
c15d			endm  
# End of macro DMARK
c15d						CALLMONITOR 
c15d cd 6b 94			call break_point_state  
c160				endm  
# End of macro CALLMONITOR
c160					endif 
c160			 
c160			 
c160					FORTH_DSP_VALUE 
c160 cd bc 9c			call macro_forth_dsp_value 
c163				endm 
# End of macro FORTH_DSP_VALUE
c163 e5					push hl   ; s2 
c164			 
c164					FORTH_DSP_POP 
c164 cd 8b 9d			call macro_forth_dsp_pop 
c167				endm 
# End of macro FORTH_DSP_POP
c167			 
c167					FORTH_DSP_VALUE 
c167 cd bc 9c			call macro_forth_dsp_value 
c16a				endm 
# End of macro FORTH_DSP_VALUE
c16a			 
c16a e5					push hl   ; s1 
c16b			 
c16b					FORTH_DSP_POP 
c16b cd 8b 9d			call macro_forth_dsp_pop 
c16e				endm 
# End of macro FORTH_DSP_POP
c16e					 
c16e			 
c16e					; copy s1 
c16e			 
c16e				 
c16e					; save ptr 
c16e e1					pop hl  
c16f e5					push hl 
c170 3e 00				ld a, 0 
c172 cd d3 90				call strlent 
c175					;inc hl    ; zer0 
c175 06 00				ld b, 0 
c177 4d					ld c, l 
c178 e1					pop hl		 
c179 11 02 e3				ld de, scratch	 
c17c					if DEBUG_FORTH_WORDS 
c17c						DMARK "CO1" 
c17c f5				push af  
c17d 3a 91 c1			ld a, (.dmark)  
c180 32 71 ee			ld (debug_mark),a  
c183 3a 92 c1			ld a, (.dmark+1)  
c186 32 72 ee			ld (debug_mark+1),a  
c189 3a 93 c1			ld a, (.dmark+2)  
c18c 32 73 ee			ld (debug_mark+2),a  
c18f 18 03			jr .pastdmark  
c191 ..			.dmark: db "CO1"  
c194 f1			.pastdmark: pop af  
c195			endm  
# End of macro DMARK
c195						CALLMONITOR 
c195 cd 6b 94			call break_point_state  
c198				endm  
# End of macro CALLMONITOR
c198					endif 
c198 ed b0				ldir 
c19a			 
c19a e1					pop hl 
c19b e5					push hl 
c19c d5					push de 
c19d			 
c19d			 
c19d 3e 00				ld a, 0 
c19f cd d3 90				call strlent 
c1a2 23					inc hl    ; zer0 
c1a3 23					inc hl 
c1a4 06 00				ld b, 0 
c1a6 4d					ld c, l 
c1a7 d1					pop de 
c1a8 e1					pop hl		 
c1a9					if DEBUG_FORTH_WORDS 
c1a9						DMARK "CO2" 
c1a9 f5				push af  
c1aa 3a be c1			ld a, (.dmark)  
c1ad 32 71 ee			ld (debug_mark),a  
c1b0 3a bf c1			ld a, (.dmark+1)  
c1b3 32 72 ee			ld (debug_mark+1),a  
c1b6 3a c0 c1			ld a, (.dmark+2)  
c1b9 32 73 ee			ld (debug_mark+2),a  
c1bc 18 03			jr .pastdmark  
c1be ..			.dmark: db "CO2"  
c1c1 f1			.pastdmark: pop af  
c1c2			endm  
# End of macro DMARK
c1c2						CALLMONITOR 
c1c2 cd 6b 94			call break_point_state  
c1c5				endm  
# End of macro CALLMONITOR
c1c5					endif 
c1c5 ed b0				ldir 
c1c7			 
c1c7			 
c1c7			 
c1c7 21 02 e3				ld hl, scratch 
c1ca					if DEBUG_FORTH_WORDS 
c1ca						DMARK "CO5" 
c1ca f5				push af  
c1cb 3a df c1			ld a, (.dmark)  
c1ce 32 71 ee			ld (debug_mark),a  
c1d1 3a e0 c1			ld a, (.dmark+1)  
c1d4 32 72 ee			ld (debug_mark+1),a  
c1d7 3a e1 c1			ld a, (.dmark+2)  
c1da 32 73 ee			ld (debug_mark+2),a  
c1dd 18 03			jr .pastdmark  
c1df ..			.dmark: db "CO5"  
c1e2 f1			.pastdmark: pop af  
c1e3			endm  
# End of macro DMARK
c1e3						CALLMONITOR 
c1e3 cd 6b 94			call break_point_state  
c1e6				endm  
# End of macro CALLMONITOR
c1e6					endif 
c1e6			 
c1e6 cd 4a 9b				call forth_push_str 
c1e9			 
c1e9			 
c1e9			 
c1e9			 
c1e9				       NEXTW 
c1e9 c3 4a 9e			jp macro_next 
c1ec				endm 
# End of macro NEXTW
c1ec			 
c1ec			 
c1ec			.FIND: 
c1ec				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c1ec 4b				db WORD_SYS_CORE+55             
c1ed aa c2			dw .LEN            
c1ef 05				db 4 + 1 
c1f0 .. 00			db "FIND",0              
c1f5				endm 
# End of macro CWHEAD
c1f5			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c1f5			 
c1f5					if DEBUG_FORTH_WORDS_KEY 
c1f5						DMARK "FND" 
c1f5 f5				push af  
c1f6 3a 0a c2			ld a, (.dmark)  
c1f9 32 71 ee			ld (debug_mark),a  
c1fc 3a 0b c2			ld a, (.dmark+1)  
c1ff 32 72 ee			ld (debug_mark+1),a  
c202 3a 0c c2			ld a, (.dmark+2)  
c205 32 73 ee			ld (debug_mark+2),a  
c208 18 03			jr .pastdmark  
c20a ..			.dmark: db "FND"  
c20d f1			.pastdmark: pop af  
c20e			endm  
# End of macro DMARK
c20e						CALLMONITOR 
c20e cd 6b 94			call break_point_state  
c211				endm  
# End of macro CALLMONITOR
c211					endif 
c211			 
c211			; TODO check string type 
c211					FORTH_DSP_VALUE 
c211 cd bc 9c			call macro_forth_dsp_value 
c214				endm 
# End of macro FORTH_DSP_VALUE
c214			 
c214 e5					push hl    
c215 7e					ld a,(hl)    ; char to find   
c216			; TODO change char to substr 
c216			 
c216 f5					push af 
c217					 
c217			 
c217			 
c217					if DEBUG_FORTH_WORDS 
c217						DMARK "FN1" 
c217 f5				push af  
c218 3a 2c c2			ld a, (.dmark)  
c21b 32 71 ee			ld (debug_mark),a  
c21e 3a 2d c2			ld a, (.dmark+1)  
c221 32 72 ee			ld (debug_mark+1),a  
c224 3a 2e c2			ld a, (.dmark+2)  
c227 32 73 ee			ld (debug_mark+2),a  
c22a 18 03			jr .pastdmark  
c22c ..			.dmark: db "FN1"  
c22f f1			.pastdmark: pop af  
c230			endm  
# End of macro DMARK
c230						CALLMONITOR 
c230 cd 6b 94			call break_point_state  
c233				endm  
# End of macro CALLMONITOR
c233					endif 
c233			 
c233					FORTH_DSP_POP 
c233 cd 8b 9d			call macro_forth_dsp_pop 
c236				endm 
# End of macro FORTH_DSP_POP
c236			 
c236					; string to search 
c236			 
c236					FORTH_DSP_VALUE 
c236 cd bc 9c			call macro_forth_dsp_value 
c239				endm 
# End of macro FORTH_DSP_VALUE
c239			 
c239 d1					pop de  ; d is char to find  
c23a			 
c23a					if DEBUG_FORTH_WORDS 
c23a						DMARK "FN2" 
c23a f5				push af  
c23b 3a 4f c2			ld a, (.dmark)  
c23e 32 71 ee			ld (debug_mark),a  
c241 3a 50 c2			ld a, (.dmark+1)  
c244 32 72 ee			ld (debug_mark+1),a  
c247 3a 51 c2			ld a, (.dmark+2)  
c24a 32 73 ee			ld (debug_mark+2),a  
c24d 18 03			jr .pastdmark  
c24f ..			.dmark: db "FN2"  
c252 f1			.pastdmark: pop af  
c253			endm  
# End of macro DMARK
c253						CALLMONITOR 
c253 cd 6b 94			call break_point_state  
c256				endm  
# End of macro CALLMONITOR
c256					endif 
c256					 
c256 01 00 00				ld bc, 0 
c259 7e			.findchar:      ld a,(hl) 
c25a fe 00				cp 0   		 
c25c 28 27				jr z, .finddone     
c25e ba					cp d 
c25f 28 20				jr z, .foundchar 
c261 03					inc bc 
c262 23					inc hl 
c263					if DEBUG_FORTH_WORDS 
c263						DMARK "FN3" 
c263 f5				push af  
c264 3a 78 c2			ld a, (.dmark)  
c267 32 71 ee			ld (debug_mark),a  
c26a 3a 79 c2			ld a, (.dmark+1)  
c26d 32 72 ee			ld (debug_mark+1),a  
c270 3a 7a c2			ld a, (.dmark+2)  
c273 32 73 ee			ld (debug_mark+2),a  
c276 18 03			jr .pastdmark  
c278 ..			.dmark: db "FN3"  
c27b f1			.pastdmark: pop af  
c27c			endm  
# End of macro DMARK
c27c						CALLMONITOR 
c27c cd 6b 94			call break_point_state  
c27f				endm  
# End of macro CALLMONITOR
c27f					endif 
c27f 18 d8				jr .findchar 
c281			 
c281			 
c281 c5			.foundchar:	push bc 
c282 e1					pop hl 
c283 18 03				jr .findexit 
c285			 
c285			 
c285							 
c285			 
c285			.finddone:     ; got to end of string with no find 
c285 21 00 00				ld hl, 0 
c288			.findexit: 
c288			 
c288					if DEBUG_FORTH_WORDS 
c288						DMARK "FNd" 
c288 f5				push af  
c289 3a 9d c2			ld a, (.dmark)  
c28c 32 71 ee			ld (debug_mark),a  
c28f 3a 9e c2			ld a, (.dmark+1)  
c292 32 72 ee			ld (debug_mark+1),a  
c295 3a 9f c2			ld a, (.dmark+2)  
c298 32 73 ee			ld (debug_mark+2),a  
c29b 18 03			jr .pastdmark  
c29d ..			.dmark: db "FNd"  
c2a0 f1			.pastdmark: pop af  
c2a1			endm  
# End of macro DMARK
c2a1						CALLMONITOR 
c2a1 cd 6b 94			call break_point_state  
c2a4				endm  
# End of macro CALLMONITOR
c2a4					endif 
c2a4 cd dc 9a			call forth_push_numhl 
c2a7			 
c2a7				       NEXTW 
c2a7 c3 4a 9e			jp macro_next 
c2aa				endm 
# End of macro NEXTW
c2aa			 
c2aa			.LEN: 
c2aa				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c2aa 4c				db WORD_SYS_CORE+56             
c2ab 14 c3			dw .CHAR            
c2ad 06				db 5 + 1 
c2ae .. 00			db "COUNT",0              
c2b4				endm 
# End of macro CWHEAD
c2b4			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c2b4			 
c2b4					if DEBUG_FORTH_WORDS_KEY 
c2b4						DMARK "CNT" 
c2b4 f5				push af  
c2b5 3a c9 c2			ld a, (.dmark)  
c2b8 32 71 ee			ld (debug_mark),a  
c2bb 3a ca c2			ld a, (.dmark+1)  
c2be 32 72 ee			ld (debug_mark+1),a  
c2c1 3a cb c2			ld a, (.dmark+2)  
c2c4 32 73 ee			ld (debug_mark+2),a  
c2c7 18 03			jr .pastdmark  
c2c9 ..			.dmark: db "CNT"  
c2cc f1			.pastdmark: pop af  
c2cd			endm  
# End of macro DMARK
c2cd						CALLMONITOR 
c2cd cd 6b 94			call break_point_state  
c2d0				endm  
# End of macro CALLMONITOR
c2d0					endif 
c2d0			; TODO check string type 
c2d0					FORTH_DSP_VALUE 
c2d0 cd bc 9c			call macro_forth_dsp_value 
c2d3				endm 
# End of macro FORTH_DSP_VALUE
c2d3			 
c2d3			 
c2d3					if DEBUG_FORTH_WORDS 
c2d3						DMARK "CN?" 
c2d3 f5				push af  
c2d4 3a e8 c2			ld a, (.dmark)  
c2d7 32 71 ee			ld (debug_mark),a  
c2da 3a e9 c2			ld a, (.dmark+1)  
c2dd 32 72 ee			ld (debug_mark+1),a  
c2e0 3a ea c2			ld a, (.dmark+2)  
c2e3 32 73 ee			ld (debug_mark+2),a  
c2e6 18 03			jr .pastdmark  
c2e8 ..			.dmark: db "CN?"  
c2eb f1			.pastdmark: pop af  
c2ec			endm  
# End of macro DMARK
c2ec						CALLMONITOR 
c2ec cd 6b 94			call break_point_state  
c2ef				endm  
# End of macro CALLMONITOR
c2ef					endif 
c2ef cd c8 90				call strlenz 
c2f2					if DEBUG_FORTH_WORDS 
c2f2						DMARK "CNl" 
c2f2 f5				push af  
c2f3 3a 07 c3			ld a, (.dmark)  
c2f6 32 71 ee			ld (debug_mark),a  
c2f9 3a 08 c3			ld a, (.dmark+1)  
c2fc 32 72 ee			ld (debug_mark+1),a  
c2ff 3a 09 c3			ld a, (.dmark+2)  
c302 32 73 ee			ld (debug_mark+2),a  
c305 18 03			jr .pastdmark  
c307 ..			.dmark: db "CNl"  
c30a f1			.pastdmark: pop af  
c30b			endm  
# End of macro DMARK
c30b						CALLMONITOR 
c30b cd 6b 94			call break_point_state  
c30e				endm  
# End of macro CALLMONITOR
c30e					endif 
c30e			 
c30e cd dc 9a				call forth_push_numhl 
c311			 
c311			 
c311			 
c311				       NEXTW 
c311 c3 4a 9e			jp macro_next 
c314				endm 
# End of macro NEXTW
c314			.CHAR: 
c314				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c314 4d				db WORD_SYS_CORE+57             
c315 4a c3			dw .ENDSTR            
c317 05				db 4 + 1 
c318 .. 00			db "CHAR",0              
c31d				endm 
# End of macro CWHEAD
c31d			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c31d					if DEBUG_FORTH_WORDS_KEY 
c31d						DMARK "CHR" 
c31d f5				push af  
c31e 3a 32 c3			ld a, (.dmark)  
c321 32 71 ee			ld (debug_mark),a  
c324 3a 33 c3			ld a, (.dmark+1)  
c327 32 72 ee			ld (debug_mark+1),a  
c32a 3a 34 c3			ld a, (.dmark+2)  
c32d 32 73 ee			ld (debug_mark+2),a  
c330 18 03			jr .pastdmark  
c332 ..			.dmark: db "CHR"  
c335 f1			.pastdmark: pop af  
c336			endm  
# End of macro DMARK
c336						CALLMONITOR 
c336 cd 6b 94			call break_point_state  
c339				endm  
# End of macro CALLMONITOR
c339					endif 
c339					FORTH_DSP 
c339 cd 99 9c			call macro_forth_dsp 
c33c				endm 
# End of macro FORTH_DSP
c33c					;v5 FORTH_DSP_VALUE 
c33c 23					inc hl      ; now at start of numeric as string 
c33d			 
c33d			;		push hl 
c33d			 
c33d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c33d cd 8b 9d			call macro_forth_dsp_pop 
c340				endm 
# End of macro FORTH_DSP_POP
c340			 
c340			;		pop hl 
c340			 
c340					; push the content of a onto the stack as a value 
c340			 
c340 7e					ld a,(hl)   ; get char 
c341 26 00				ld h,0 
c343 6f					ld l,a 
c344 cd dc 9a				call forth_push_numhl 
c347			 
c347				       NEXTW 
c347 c3 4a 9e			jp macro_next 
c34a				endm 
# End of macro NEXTW
c34a			 
c34a			 
c34a			 
c34a			 
c34a			.ENDSTR: 
c34a			; eof 
c34a			 
# End of file forth_words_str.asm
c34a			include "forth_words_key.asm" 
c34a			 
c34a			; | ## Keyboard Words 
c34a			 
c34a			.KEY: 
c34a				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c34a 3e				db WORD_SYS_CORE+42             
c34b 7a c3			dw .WAITK            
c34d 04				db 3 + 1 
c34e .. 00			db "KEY",0              
c352				endm 
# End of macro CWHEAD
c352			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c352			 
c352					if DEBUG_FORTH_WORDS_KEY 
c352						DMARK "KEY" 
c352 f5				push af  
c353 3a 67 c3			ld a, (.dmark)  
c356 32 71 ee			ld (debug_mark),a  
c359 3a 68 c3			ld a, (.dmark+1)  
c35c 32 72 ee			ld (debug_mark+1),a  
c35f 3a 69 c3			ld a, (.dmark+2)  
c362 32 73 ee			ld (debug_mark+2),a  
c365 18 03			jr .pastdmark  
c367 ..			.dmark: db "KEY"  
c36a f1			.pastdmark: pop af  
c36b			endm  
# End of macro DMARK
c36b						CALLMONITOR 
c36b cd 6b 94			call break_point_state  
c36e				endm  
# End of macro CALLMONITOR
c36e					endif 
c36e			; TODO currently waits 
c36e cd 44 da				call cin 
c371					;call cin_wait 
c371 6f					ld l, a 
c372 26 00				ld h, 0 
c374 cd dc 9a				call forth_push_numhl 
c377					NEXTW 
c377 c3 4a 9e			jp macro_next 
c37a				endm 
# End of macro NEXTW
c37a			.WAITK: 
c37a				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c37a 3f				db WORD_SYS_CORE+43             
c37b ac c3			dw .ACCEPT            
c37d 06				db 5 + 1 
c37e .. 00			db "WAITK",0              
c384				endm 
# End of macro CWHEAD
c384			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c384					if DEBUG_FORTH_WORDS_KEY 
c384						DMARK "WAI" 
c384 f5				push af  
c385 3a 99 c3			ld a, (.dmark)  
c388 32 71 ee			ld (debug_mark),a  
c38b 3a 9a c3			ld a, (.dmark+1)  
c38e 32 72 ee			ld (debug_mark+1),a  
c391 3a 9b c3			ld a, (.dmark+2)  
c394 32 73 ee			ld (debug_mark+2),a  
c397 18 03			jr .pastdmark  
c399 ..			.dmark: db "WAI"  
c39c f1			.pastdmark: pop af  
c39d			endm  
# End of macro DMARK
c39d						CALLMONITOR 
c39d cd 6b 94			call break_point_state  
c3a0				endm  
# End of macro CALLMONITOR
c3a0					endif 
c3a0 cd 3e da				call cin_wait 
c3a3 6f					ld l, a 
c3a4 26 00				ld h, 0 
c3a6 cd dc 9a				call forth_push_numhl 
c3a9					NEXTW 
c3a9 c3 4a 9e			jp macro_next 
c3ac				endm 
# End of macro NEXTW
c3ac			.ACCEPT: 
c3ac				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c3ac 40				db WORD_SYS_CORE+44             
c3ad 0a c4			dw .EDIT            
c3af 07				db 6 + 1 
c3b0 .. 00			db "ACCEPT",0              
c3b7				endm 
# End of macro CWHEAD
c3b7			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c3b7					; TODO crashes on push 
c3b7					if DEBUG_FORTH_WORDS_KEY 
c3b7						DMARK "ACC" 
c3b7 f5				push af  
c3b8 3a cc c3			ld a, (.dmark)  
c3bb 32 71 ee			ld (debug_mark),a  
c3be 3a cd c3			ld a, (.dmark+1)  
c3c1 32 72 ee			ld (debug_mark+1),a  
c3c4 3a ce c3			ld a, (.dmark+2)  
c3c7 32 73 ee			ld (debug_mark+2),a  
c3ca 18 03			jr .pastdmark  
c3cc ..			.dmark: db "ACC"  
c3cf f1			.pastdmark: pop af  
c3d0			endm  
# End of macro DMARK
c3d0						CALLMONITOR 
c3d0 cd 6b 94			call break_point_state  
c3d3				endm  
# End of macro CALLMONITOR
c3d3					endif 
c3d3 21 00 e5				ld hl, os_input 
c3d6 3e 00				ld a, 0 
c3d8 77					ld (hl),a 
c3d9 3a 6b ea				ld a,(f_cursor_ptr) 
c3dc 16 64				ld d, 100 
c3de 0e 00				ld c, 0 
c3e0 1e 28				ld e, 40 
c3e2 cd 97 8c				call input_str 
c3e5					; TODO perhaps do a type check and wrap in quotes if not a number 
c3e5 21 00 e5				ld hl, os_input 
c3e8					if DEBUG_FORTH_WORDS 
c3e8						DMARK "AC1" 
c3e8 f5				push af  
c3e9 3a fd c3			ld a, (.dmark)  
c3ec 32 71 ee			ld (debug_mark),a  
c3ef 3a fe c3			ld a, (.dmark+1)  
c3f2 32 72 ee			ld (debug_mark+1),a  
c3f5 3a ff c3			ld a, (.dmark+2)  
c3f8 32 73 ee			ld (debug_mark+2),a  
c3fb 18 03			jr .pastdmark  
c3fd ..			.dmark: db "AC1"  
c400 f1			.pastdmark: pop af  
c401			endm  
# End of macro DMARK
c401						CALLMONITOR 
c401 cd 6b 94			call break_point_state  
c404				endm  
# End of macro CALLMONITOR
c404					endif 
c404 cd 4a 9b				call forth_push_str 
c407					NEXTW 
c407 c3 4a 9e			jp macro_next 
c40a				endm 
# End of macro NEXTW
c40a			 
c40a			.EDIT: 
c40a				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c40a 40				db WORD_SYS_CORE+44             
c40b ac c4			dw .ENDKEY            
c40d 05				db 4 + 1 
c40e .. 00			db "EDIT",0              
c413				endm 
# End of macro CWHEAD
c413			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c413			 
c413					; TODO does not copy from stack 
c413					if DEBUG_FORTH_WORDS_KEY 
c413						DMARK "EDT" 
c413 f5				push af  
c414 3a 28 c4			ld a, (.dmark)  
c417 32 71 ee			ld (debug_mark),a  
c41a 3a 29 c4			ld a, (.dmark+1)  
c41d 32 72 ee			ld (debug_mark+1),a  
c420 3a 2a c4			ld a, (.dmark+2)  
c423 32 73 ee			ld (debug_mark+2),a  
c426 18 03			jr .pastdmark  
c428 ..			.dmark: db "EDT"  
c42b f1			.pastdmark: pop af  
c42c			endm  
# End of macro DMARK
c42c						CALLMONITOR 
c42c cd 6b 94			call break_point_state  
c42f				endm  
# End of macro CALLMONITOR
c42f					endif 
c42f			 
c42f					;FORTH_DSP 
c42f					FORTH_DSP_VALUEHL 
c42f cd d3 9c			call macro_dsp_valuehl 
c432				endm 
# End of macro FORTH_DSP_VALUEHL
c432			;		inc hl    ; TODO do type check 
c432			 
c432			;		call get_word_hl 
c432 e5					push hl 
c433					if DEBUG_FORTH_WORDS 
c433						DMARK "EDp" 
c433 f5				push af  
c434 3a 48 c4			ld a, (.dmark)  
c437 32 71 ee			ld (debug_mark),a  
c43a 3a 49 c4			ld a, (.dmark+1)  
c43d 32 72 ee			ld (debug_mark+1),a  
c440 3a 4a c4			ld a, (.dmark+2)  
c443 32 73 ee			ld (debug_mark+2),a  
c446 18 03			jr .pastdmark  
c448 ..			.dmark: db "EDp"  
c44b f1			.pastdmark: pop af  
c44c			endm  
# End of macro DMARK
c44c						CALLMONITOR 
c44c cd 6b 94			call break_point_state  
c44f				endm  
# End of macro CALLMONITOR
c44f					endif 
c44f				;	ld a, 0 
c44f cd c8 90				call strlenz 
c452 23					inc hl 
c453			 
c453 06 00				ld b, 0 
c455 4d					ld c, l 
c456			 
c456 e1					pop hl 
c457 11 00 e5				ld de, os_input 
c45a					if DEBUG_FORTH_WORDS_KEY 
c45a						DMARK "EDc" 
c45a f5				push af  
c45b 3a 6f c4			ld a, (.dmark)  
c45e 32 71 ee			ld (debug_mark),a  
c461 3a 70 c4			ld a, (.dmark+1)  
c464 32 72 ee			ld (debug_mark+1),a  
c467 3a 71 c4			ld a, (.dmark+2)  
c46a 32 73 ee			ld (debug_mark+2),a  
c46d 18 03			jr .pastdmark  
c46f ..			.dmark: db "EDc"  
c472 f1			.pastdmark: pop af  
c473			endm  
# End of macro DMARK
c473						CALLMONITOR 
c473 cd 6b 94			call break_point_state  
c476				endm  
# End of macro CALLMONITOR
c476					endif 
c476 ed b0				ldir 
c478			 
c478			 
c478 21 00 e5				ld hl, os_input 
c47b					;ld a, 0 
c47b					;ld (hl),a 
c47b 3a 6b ea				ld a,(f_cursor_ptr) 
c47e 16 64				ld d, 100 
c480 0e 00				ld c, 0 
c482 1e 28				ld e, 40 
c484 cd 97 8c				call input_str 
c487					; TODO perhaps do a type check and wrap in quotes if not a number 
c487 21 00 e5				ld hl, os_input 
c48a					if DEBUG_FORTH_WORDS 
c48a						DMARK "ED1" 
c48a f5				push af  
c48b 3a 9f c4			ld a, (.dmark)  
c48e 32 71 ee			ld (debug_mark),a  
c491 3a a0 c4			ld a, (.dmark+1)  
c494 32 72 ee			ld (debug_mark+1),a  
c497 3a a1 c4			ld a, (.dmark+2)  
c49a 32 73 ee			ld (debug_mark+2),a  
c49d 18 03			jr .pastdmark  
c49f ..			.dmark: db "ED1"  
c4a2 f1			.pastdmark: pop af  
c4a3			endm  
# End of macro DMARK
c4a3						CALLMONITOR 
c4a3 cd 6b 94			call break_point_state  
c4a6				endm  
# End of macro CALLMONITOR
c4a6					endif 
c4a6 cd 4a 9b				call forth_push_str 
c4a9					NEXTW 
c4a9 c3 4a 9e			jp macro_next 
c4ac				endm 
# End of macro NEXTW
c4ac			 
c4ac			 
c4ac			 
c4ac			.ENDKEY: 
c4ac			; eof 
c4ac			 
# End of file forth_words_key.asm
c4ac			 
c4ac			if STORAGE_SE 
c4ac			   	include "forth_words_storage.asm" 
c4ac			endif 
c4ac				include "forth_words_device.asm" 
c4ac			; Device related words 
c4ac			 
c4ac			; | ## Device Words 
c4ac			 
c4ac			if SOUND_ENABLE 
c4ac			.NOTE: 
c4ac				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c4ac			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c4ac					if DEBUG_FORTH_WORDS_KEY 
c4ac						DMARK "NTE" 
c4ac						CALLMONITOR 
c4ac					endif 
c4ac			 
c4ac				 
c4ac			 
c4ac					NEXTW 
c4ac			.AFTERSOUND: 
c4ac			endif 
c4ac			 
c4ac			 
c4ac			USE_GPIO: equ 0 
c4ac			 
c4ac			if USE_GPIO 
c4ac			.GP1: 
c4ac				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c4ac			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c4ac					NEXTW 
c4ac			.GP2: 
c4ac				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c4ac			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c4ac			 
c4ac					NEXTW 
c4ac			 
c4ac			.GP3: 
c4ac				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c4ac			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c4ac			 
c4ac					NEXTW 
c4ac			 
c4ac			.GP4: 
c4ac				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c4ac			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c4ac			 
c4ac					NEXTW 
c4ac			.SIN: 
c4ac			 
c4ac			 
c4ac			endif 
c4ac			 
c4ac			 
c4ac				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c4ac 33				db WORD_SYS_CORE+31             
c4ad e1 c4			dw .SOUT            
c4af 03				db 2 + 1 
c4b0 .. 00			db "IN",0              
c4b3				endm 
# End of macro CWHEAD
c4b3			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c4b3					if DEBUG_FORTH_WORDS_KEY 
c4b3						DMARK "IN." 
c4b3 f5				push af  
c4b4 3a c8 c4			ld a, (.dmark)  
c4b7 32 71 ee			ld (debug_mark),a  
c4ba 3a c9 c4			ld a, (.dmark+1)  
c4bd 32 72 ee			ld (debug_mark+1),a  
c4c0 3a ca c4			ld a, (.dmark+2)  
c4c3 32 73 ee			ld (debug_mark+2),a  
c4c6 18 03			jr .pastdmark  
c4c8 ..			.dmark: db "IN."  
c4cb f1			.pastdmark: pop af  
c4cc			endm  
# End of macro DMARK
c4cc						CALLMONITOR 
c4cc cd 6b 94			call break_point_state  
c4cf				endm  
# End of macro CALLMONITOR
c4cf					endif 
c4cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c4cf cd d3 9c			call macro_dsp_valuehl 
c4d2				endm 
# End of macro FORTH_DSP_VALUEHL
c4d2			 
c4d2 e5					push hl 
c4d3			 
c4d3					; destroy value TOS 
c4d3			 
c4d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c4d3 cd 8b 9d			call macro_forth_dsp_pop 
c4d6				endm 
# End of macro FORTH_DSP_POP
c4d6			 
c4d6					; one value on hl get other one back 
c4d6			 
c4d6 c1					pop bc 
c4d7			 
c4d7					; do the sub 
c4d7			;		ex de, hl 
c4d7			 
c4d7 ed 68				in l,(c) 
c4d9			 
c4d9					; save it 
c4d9			 
c4d9 26 00				ld h,0 
c4db			 
c4db					; TODO push value back onto stack for another op etc 
c4db			 
c4db cd dc 9a				call forth_push_numhl 
c4de					NEXTW 
c4de c3 4a 9e			jp macro_next 
c4e1				endm 
# End of macro NEXTW
c4e1			.SOUT: 
c4e1				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c4e1 34				db WORD_SYS_CORE+32             
c4e2 34 c5			dw .SPIO            
c4e4 04				db 3 + 1 
c4e5 .. 00			db "OUT",0              
c4e9				endm 
# End of macro CWHEAD
c4e9			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c4e9					if DEBUG_FORTH_WORDS_KEY 
c4e9						DMARK "OUT" 
c4e9 f5				push af  
c4ea 3a fe c4			ld a, (.dmark)  
c4ed 32 71 ee			ld (debug_mark),a  
c4f0 3a ff c4			ld a, (.dmark+1)  
c4f3 32 72 ee			ld (debug_mark+1),a  
c4f6 3a 00 c5			ld a, (.dmark+2)  
c4f9 32 73 ee			ld (debug_mark+2),a  
c4fc 18 03			jr .pastdmark  
c4fe ..			.dmark: db "OUT"  
c501 f1			.pastdmark: pop af  
c502			endm  
# End of macro DMARK
c502						CALLMONITOR 
c502 cd 6b 94			call break_point_state  
c505				endm  
# End of macro CALLMONITOR
c505					endif 
c505			 
c505					; get port 
c505			 
c505					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c505 cd d3 9c			call macro_dsp_valuehl 
c508				endm 
# End of macro FORTH_DSP_VALUEHL
c508			 
c508 e5					push hl 
c509			 
c509					; destroy value TOS 
c509			 
c509					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c509 cd 8b 9d			call macro_forth_dsp_pop 
c50c				endm 
# End of macro FORTH_DSP_POP
c50c			 
c50c					; get byte to send 
c50c			 
c50c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c50c cd d3 9c			call macro_dsp_valuehl 
c50f				endm 
# End of macro FORTH_DSP_VALUEHL
c50f			 
c50f			;		push hl 
c50f			 
c50f					; destroy value TOS 
c50f			 
c50f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c50f cd 8b 9d			call macro_forth_dsp_pop 
c512				endm 
# End of macro FORTH_DSP_POP
c512			 
c512					; one value on hl get other one back 
c512			 
c512			;		pop hl 
c512			 
c512 c1					pop bc 
c513			 
c513					if DEBUG_FORTH_WORDS 
c513						DMARK "OUT" 
c513 f5				push af  
c514 3a 28 c5			ld a, (.dmark)  
c517 32 71 ee			ld (debug_mark),a  
c51a 3a 29 c5			ld a, (.dmark+1)  
c51d 32 72 ee			ld (debug_mark+1),a  
c520 3a 2a c5			ld a, (.dmark+2)  
c523 32 73 ee			ld (debug_mark+2),a  
c526 18 03			jr .pastdmark  
c528 ..			.dmark: db "OUT"  
c52b f1			.pastdmark: pop af  
c52c			endm  
# End of macro DMARK
c52c						CALLMONITOR 
c52c cd 6b 94			call break_point_state  
c52f				endm  
# End of macro CALLMONITOR
c52f					endif 
c52f			 
c52f ed 69				out (c), l 
c531			 
c531					NEXTW 
c531 c3 4a 9e			jp macro_next 
c534				endm 
# End of macro NEXTW
c534			 
c534			 
c534			.SPIO: 
c534			 
c534			if STORAGE_SE 
c534				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c534			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c534			 
c534					call spi_ce_low 
c534			    NEXTW 
c534			 
c534			.SPICEH: 
c534				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c534			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c534			 
c534					call spi_ce_high 
c534			    NEXTW 
c534			 
c534			 
c534			.SPIOb: 
c534			 
c534				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c534			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c534			 
c534					; get port 
c534			 
c534			 
c534					; get byte to send 
c534			 
c534					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c534			 
c534			;		push hl    ; u1  
c534			 
c534					; destroy value TOS 
c534			 
c534					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c534			 
c534					; one value on hl get other one back 
c534			 
c534			;		pop hl   ; u2 - addr 
c534			 
c534					; TODO Send SPI byte 
c534			 
c534					ld a, l 
c534					call spi_send_byte 
c534			 
c534					NEXTW 
c534			 
c534			.SPII: 
c534				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c534			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c534			 
c534					; TODO Get SPI byte 
c534			 
c534					call spi_read_byte 
c534			 
c534					ld h, 0 
c534					ld l, a 
c534					call forth_push_numhl 
c534			 
c534					NEXTW 
c534			 
c534			 
c534			 
c534			.SESEL: 
c534				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c534			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c534					if DEBUG_FORTH_WORDS_KEY 
c534						DMARK "BNK" 
c534						CALLMONITOR 
c534					endif 
c534			 
c534					ld a, 255 
c534					ld (spi_cartdev), a 
c534			 
c534					; get bank 
c534			 
c534					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c534			 
c534			;		push hl 
c534			 
c534					; destroy value TOS 
c534			 
c534					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c534			 
c534					; one value on hl get other one back 
c534			 
c534			;		pop hl 
c534			 
c534			 
c534					ld c, SPI_CE_HIGH 
c534					ld b, '0'    ; human readable bank number 
c534			 
c534					ld a, l 
c534			 
c534					if DEBUG_FORTH_WORDS 
c534						DMARK "BNK" 
c534						CALLMONITOR 
c534					endif 
c534			 
c534					; active low 
c534			 
c534					cp 0 
c534					jr z, .bset 
c534					cp 1 
c534					jr nz, .b2 
c534					res 0, c 
c534					ld b, '1'    ; human readable bank number 
c534			.b2:		cp 2 
c534					jr nz, .b3 
c534					res 1, c 
c534					ld b, '2'    ; human readable bank number 
c534			.b3:		cp 3 
c534					jr nz, .b4 
c534					res 2, c 
c534					ld b, '3'    ; human readable bank number 
c534			.b4:		cp 4 
c534					jr nz, .b5 
c534					res 3, c 
c534					ld b, '4'    ; human readable bank number 
c534			.b5:		cp 5 
c534					jr nz, .bset 
c534					res 4, c 
c534					ld b, '5'    ; human readable bank number 
c534			 
c534			.bset: 
c534					ld a, c 
c534					ld (spi_device),a 
c534					ld a, b 
c534					ld (spi_device_id),a 
c534					if DEBUG_FORTH_WORDS 
c534						DMARK "BN2" 
c534						CALLMONITOR 
c534					endif 
c534			 
c534					NEXTW 
c534			 
c534			.CARTDEV: 
c534				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c534			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c534					if DEBUG_FORTH_WORDS_KEY 
c534						DMARK "CDV" 
c534						CALLMONITOR 
c534					endif 
c534			 
c534					; disable se storage bank selection 
c534			 
c534					ld a, SPI_CE_HIGH		; ce high 
c534					ld (spi_device), a 
c534			 
c534					; get bank 
c534			 
c534					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c534			 
c534			;		push hl 
c534			 
c534					; destroy value TOS 
c534			 
c534					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c534			 
c534					; one value on hl get other one back 
c534			 
c534			;		pop hl 
c534			 
c534					; active low 
c534			 
c534					ld c, 255 
c534			 
c534					ld a, l 
c534					if DEBUG_FORTH_WORDS 
c534						DMARK "CDV" 
c534						CALLMONITOR 
c534					endif 
c534					cp 0 
c534					jr z, .cset 
c534					cp 1 
c534					jr nz, .c2 
c534					res 0, c 
c534			.c2:		cp 2 
c534					jr nz, .c3 
c534					res 1, c 
c534			.c3:		cp 3 
c534					jr nz, .c4 
c534					res 2, c 
c534			.c4:		cp 4 
c534					jr nz, .c5 
c534					res 3, c 
c534			.c5:		cp 5 
c534					jr nz, .c6 
c534					res 4, c 
c534			.c6:		cp 6 
c534					jr nz, .c7 
c534					res 5, c 
c534			.c7:		cp 7 
c534					jr nz, .c8 
c534					res 6, c 
c534			.c8:		cp 8 
c534					jr nz, .cset 
c534					res 7, c 
c534			.cset:		ld a, c 
c534					ld (spi_cartdev),a 
c534			 
c534					if DEBUG_FORTH_WORDS 
c534						DMARK "CD2" 
c534						CALLMONITOR 
c534					endif 
c534					NEXTW 
c534			endif 
c534			 
c534			.ENDDEVICE: 
c534			; eof 
c534			 
# End of file forth_words_device.asm
c534			 
c534			; var handler 
c534			 
c534			 
c534			.VARS: 
c534				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c534 78				db WORD_SYS_CORE+100             
c535 4c c5			dw .V0Q            
c537 04				db 3 + 1 
c538 .. 00			db "V0!",0              
c53c				endm 
# End of macro CWHEAD
c53c			;| V0! ( u1 -- )  Store value to v0  | DONE 
c53c			 
c53c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c53c cd d3 9c			call macro_dsp_valuehl 
c53f				endm 
# End of macro FORTH_DSP_VALUEHL
c53f			 
c53f 11 35 ea				ld de, cli_var_array 
c542			 
c542 eb					ex de, hl 
c543 73					ld (hl), e 
c544 23					inc hl 
c545 72					ld (hl), d 
c546			 
c546					; destroy value TOS 
c546			 
c546					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c546 cd 8b 9d			call macro_forth_dsp_pop 
c549				endm 
# End of macro FORTH_DSP_POP
c549			 
c549				       NEXTW 
c549 c3 4a 9e			jp macro_next 
c54c				endm 
# End of macro NEXTW
c54c			.V0Q: 
c54c				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c54c 79				db WORD_SYS_CORE+101             
c54d 5d c5			dw .V1S            
c54f 04				db 3 + 1 
c550 .. 00			db "V0@",0              
c554				endm 
# End of macro CWHEAD
c554			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c554 2a 35 ea				ld hl, (cli_var_array) 
c557 cd dc 9a				call forth_push_numhl 
c55a			 
c55a				       NEXTW 
c55a c3 4a 9e			jp macro_next 
c55d				endm 
# End of macro NEXTW
c55d			.V1S: 
c55d				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c55d 7a				db WORD_SYS_CORE+102             
c55e 75 c5			dw .V1Q            
c560 04				db 3 + 1 
c561 .. 00			db "V1!",0              
c565				endm 
# End of macro CWHEAD
c565			;| V1! ( u1 -- )  Store value to v1 | DONE 
c565					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c565 cd d3 9c			call macro_dsp_valuehl 
c568				endm 
# End of macro FORTH_DSP_VALUEHL
c568			 
c568 11 37 ea				ld de, cli_var_array+2 
c56b				 
c56b eb					ex de, hl 
c56c 73					ld (hl), e 
c56d 23					inc hl 
c56e 72					ld (hl), d 
c56f			 
c56f					; destroy value TOS 
c56f			 
c56f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c56f cd 8b 9d			call macro_forth_dsp_pop 
c572				endm 
# End of macro FORTH_DSP_POP
c572				       NEXTW 
c572 c3 4a 9e			jp macro_next 
c575				endm 
# End of macro NEXTW
c575			.V1Q: 
c575				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c575 7b				db WORD_SYS_CORE+103             
c576 86 c5			dw .V2S            
c578 04				db 3 + 1 
c579 .. 00			db "V1@",0              
c57d				endm 
# End of macro CWHEAD
c57d			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c57d 2a 37 ea				ld hl, (cli_var_array+2) 
c580 cd dc 9a				call forth_push_numhl 
c583				       NEXTW 
c583 c3 4a 9e			jp macro_next 
c586				endm 
# End of macro NEXTW
c586			.V2S: 
c586				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c586 7c				db WORD_SYS_CORE+104             
c587 9e c5			dw .V2Q            
c589 04				db 3 + 1 
c58a .. 00			db "V2!",0              
c58e				endm 
# End of macro CWHEAD
c58e			;| V2! ( u1 -- )  Store value to v2 | DONE 
c58e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c58e cd d3 9c			call macro_dsp_valuehl 
c591				endm 
# End of macro FORTH_DSP_VALUEHL
c591			 
c591 11 39 ea				ld de, cli_var_array+4 
c594				 
c594 eb					ex de, hl 
c595 73					ld (hl), e 
c596 23					inc hl 
c597 72					ld (hl), d 
c598			 
c598					; destroy value TOS 
c598			 
c598					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c598 cd 8b 9d			call macro_forth_dsp_pop 
c59b				endm 
# End of macro FORTH_DSP_POP
c59b				       NEXTW 
c59b c3 4a 9e			jp macro_next 
c59e				endm 
# End of macro NEXTW
c59e			.V2Q: 
c59e				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c59e 7d				db WORD_SYS_CORE+105             
c59f af c5			dw .V3S            
c5a1 04				db 3 + 1 
c5a2 .. 00			db "V2@",0              
c5a6				endm 
# End of macro CWHEAD
c5a6			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c5a6 2a 39 ea				ld hl, (cli_var_array+4) 
c5a9 cd dc 9a				call forth_push_numhl 
c5ac				       NEXTW 
c5ac c3 4a 9e			jp macro_next 
c5af				endm 
# End of macro NEXTW
c5af			.V3S: 
c5af				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c5af 7c				db WORD_SYS_CORE+104             
c5b0 c7 c5			dw .V3Q            
c5b2 04				db 3 + 1 
c5b3 .. 00			db "V3!",0              
c5b7				endm 
# End of macro CWHEAD
c5b7			;| V3! ( u1 -- )  Store value to v3 | DONE 
c5b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c5b7 cd d3 9c			call macro_dsp_valuehl 
c5ba				endm 
# End of macro FORTH_DSP_VALUEHL
c5ba			 
c5ba 11 3b ea				ld de, cli_var_array+6 
c5bd				 
c5bd eb					ex de, hl 
c5be 73					ld (hl), e 
c5bf 23					inc hl 
c5c0 72					ld (hl), d 
c5c1			 
c5c1					; destroy value TOS 
c5c1			 
c5c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5c1 cd 8b 9d			call macro_forth_dsp_pop 
c5c4				endm 
# End of macro FORTH_DSP_POP
c5c4				       NEXTW 
c5c4 c3 4a 9e			jp macro_next 
c5c7				endm 
# End of macro NEXTW
c5c7			.V3Q: 
c5c7				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c5c7 7d				db WORD_SYS_CORE+105             
c5c8 d8 c5			dw .END            
c5ca 04				db 3 + 1 
c5cb .. 00			db "V3@",0              
c5cf				endm 
# End of macro CWHEAD
c5cf			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c5cf 2a 3b ea				ld hl, (cli_var_array+6) 
c5d2 cd dc 9a				call forth_push_numhl 
c5d5				       NEXTW 
c5d5 c3 4a 9e			jp macro_next 
c5d8				endm 
# End of macro NEXTW
c5d8			 
c5d8			 
c5d8			 
c5d8			 
c5d8			 
c5d8			; end of dict marker 
c5d8			 
c5d8 00			.END:    db WORD_SYS_END 
c5d9 00 00			dw 0 
c5db 00				db 0 
c5dc			 
c5dc			; use to jp here for user dict words to save on macro expansion  
c5dc			 
c5dc			user_dict_next: 
c5dc				NEXTW 
c5dc c3 4a 9e			jp macro_next 
c5df				endm 
# End of macro NEXTW
c5df			 
c5df			 
c5df			user_exec: 
c5df				;    ld hl, <word code> 
c5df				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c5df				;    call forthexec 
c5df				;    jp user_dict_next   (NEXT) 
c5df			        ;    <word code bytes> 
c5df eb				ex de, hl 
c5e0 2a 03 e6			ld hl,(os_tok_ptr) 
c5e3				 
c5e3				FORTH_RSP_NEXT 
c5e3 cd 83 9a			call macro_forth_rsp_next 
c5e6				endm 
# End of macro FORTH_RSP_NEXT
c5e6			 
c5e6			if DEBUG_FORTH_UWORD 
c5e6						DMARK "UEX" 
c5e6 f5				push af  
c5e7 3a fb c5			ld a, (.dmark)  
c5ea 32 71 ee			ld (debug_mark),a  
c5ed 3a fc c5			ld a, (.dmark+1)  
c5f0 32 72 ee			ld (debug_mark+1),a  
c5f3 3a fd c5			ld a, (.dmark+2)  
c5f6 32 73 ee			ld (debug_mark+2),a  
c5f9 18 03			jr .pastdmark  
c5fb ..			.dmark: db "UEX"  
c5fe f1			.pastdmark: pop af  
c5ff			endm  
# End of macro DMARK
c5ff				CALLMONITOR 
c5ff cd 6b 94			call break_point_state  
c602				endm  
# End of macro CALLMONITOR
c602			endif 
c602			 
c602			 
c602			 
c602 eb				ex de, hl 
c603 22 03 e6			ld (os_tok_ptr), hl 
c606				 
c606				; Don't use next - Skips the first word in uword. 
c606			 
c606 c3 db 9e			jp exec1 
c609			;	NEXT 
c609			 
c609			 
c609			; eof 
# End of file forth_wordsv4.asm
c609			endif 
c609			;;;;;;;;;;;;;; Debug code 
c609			 
c609			 
c609			;if DEBUG_FORTH_PARSE 
c609 .. 00		.nowordfound: db "No match",0 
c612 .. 00		.compword:	db "Comparing word ",0 
c622 .. 00		.nextwordat:	db "Next word at",0 
c62f .. 00		.charmatch:	db "Char match",0 
c63a			;endif 
c63a			if DEBUG_FORTH_JP 
c63a			.foundword:	db "Word match. Exec..",0 
c63a			endif 
c63a			;if DEBUG_FORTH_PUSH 
c63a .. 00		.enddict:	db "Dict end. Push.",0 
c64a .. 00		.push_str:	db "Pushing string",0 
c659 .. 00		.push_num:	db "Pushing number",0 
c668 .. 00		.data_sp:	db "SP:",0 
c66c .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c67e .. 00		.wordinde:	db "Word in DE (3/0):",0 
c690 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c6a2			;endif 
c6a2			;if DEBUG_FORTH_MALLOC 
c6a2 .. 00		.push_malloc:	db "Malloc address",0 
c6b1			;endif 
c6b1			 
c6b1			 
c6b1			 
c6b1			; display malloc address and current data stack pointer  
c6b1			 
c6b1			malloc_error: 
c6b1 d5				push de 
c6b2 f5				push af 
c6b3 e5				push hl 
c6b4 cd 3d 8a			call clear_display 
c6b7 11 d9 c6			ld de, .mallocerr 
c6ba 3e 00			ld a,0 
c6bc			;	ld de,os_word_scratch 
c6bc cd 50 8a			call str_at_display 
c6bf 3e 11			ld a, display_row_1+17 
c6c1 11 71 ee			ld de, debug_mark 
c6c4 cd 50 8a			call str_at_display 
c6c7 cd 60 8a			call update_display 
c6ca				;call break_point_state 
c6ca cd 3e da			call cin_wait 
c6cd			 
c6cd 3e 20			ld a, ' ' 
c6cf 32 f3 e2			ld (os_view_disable), a 
c6d2 e1				pop hl 
c6d3 f1				pop af 
c6d4 d1				pop de	 
c6d5				CALLMONITOR 
c6d5 cd 6b 94			call break_point_state  
c6d8				endm  
# End of macro CALLMONITOR
c6d8 c9				ret 
c6d9			 
c6d9 .. 00		.mallocerr: 	db "Malloc Error",0 
c6e6			;if DEBUG_FORTH_PUSH 
c6e6			display_data_sp: 
c6e6 f5				push af 
c6e7			 
c6e7				; see if disabled 
c6e7			 
c6e7 3a f3 e2			ld a, (os_view_disable) 
c6ea fe 2a			cp '*' 
c6ec 28 67			jr z, .skipdsp 
c6ee			 
c6ee e5				push hl 
c6ef e5				push hl 
c6f0 e5			push hl 
c6f1 cd 3d 8a			call clear_display 
c6f4 e1			pop hl 
c6f5 7c				ld a,h 
c6f6 21 07 e6			ld hl, os_word_scratch 
c6f9 cd 6b 8f			call hexout 
c6fc e1				pop hl 
c6fd 7d				ld a,l 
c6fe 21 09 e6			ld hl, os_word_scratch+2 
c701 cd 6b 8f			call hexout 
c704 21 0b e6			ld hl, os_word_scratch+4 
c707 3e 00			ld a,0 
c709 77				ld (hl),a 
c70a 11 07 e6			ld de,os_word_scratch 
c70d 3e 28				ld a, display_row_2 
c70f cd 50 8a				call str_at_display 
c712 11 6c c6			ld de, .wordinhl 
c715 3e 00			ld a, display_row_1 
c717			 
c717 cd 50 8a				call str_at_display 
c71a 11 71 ee			ld de, debug_mark 
c71d 3e 11			ld a, display_row_1+17 
c71f			 
c71f cd 50 8a				call str_at_display 
c722			 
c722				; display current data stack pointer 
c722 11 68 c6			ld de,.data_sp 
c725 3e 30				ld a, display_row_2 + 8 
c727 cd 50 8a				call str_at_display 
c72a			 
c72a 2a 2f ea			ld hl,(cli_data_sp) 
c72d e5				push hl 
c72e 7c				ld a,h 
c72f 21 07 e6			ld hl, os_word_scratch 
c732 cd 6b 8f			call hexout 
c735 e1				pop hl 
c736 7d				ld a,l 
c737 21 09 e6			ld hl, os_word_scratch+2 
c73a cd 6b 8f			call hexout 
c73d 21 0b e6			ld hl, os_word_scratch+4 
c740 3e 00			ld a,0 
c742 77				ld (hl),a 
c743 11 07 e6			ld de,os_word_scratch 
c746 3e 33				ld a, display_row_2 + 11 
c748 cd 50 8a				call str_at_display 
c74b			 
c74b			 
c74b cd 60 8a			call update_display 
c74e cd ba 89			call delay1s 
c751 cd ba 89			call delay1s 
c754 e1				pop hl 
c755			.skipdsp: 
c755 f1				pop af 
c756 c9				ret 
c757			 
c757			display_data_malloc: 
c757			 
c757 f5				push af 
c758 e5				push hl 
c759 e5				push hl 
c75a e5			push hl 
c75b cd 3d 8a			call clear_display 
c75e e1			pop hl 
c75f 7c				ld a,h 
c760 21 07 e6			ld hl, os_word_scratch 
c763 cd 6b 8f			call hexout 
c766 e1				pop hl 
c767 7d				ld a,l 
c768 21 09 e6			ld hl, os_word_scratch+2 
c76b cd 6b 8f			call hexout 
c76e 21 0b e6			ld hl, os_word_scratch+4 
c771 3e 00			ld a,0 
c773 77				ld (hl),a 
c774 11 07 e6			ld de,os_word_scratch 
c777 3e 28				ld a, display_row_2 
c779 cd 50 8a				call str_at_display 
c77c 11 a2 c6			ld de, .push_malloc 
c77f 3e 00			ld a, display_row_1 
c781			 
c781 cd 50 8a				call str_at_display 
c784			 
c784				; display current data stack pointer 
c784 11 68 c6			ld de,.data_sp 
c787 3e 30				ld a, display_row_2 + 8 
c789 cd 50 8a				call str_at_display 
c78c			 
c78c 2a 2f ea			ld hl,(cli_data_sp) 
c78f e5				push hl 
c790 7c				ld a,h 
c791 21 07 e6			ld hl, os_word_scratch 
c794 cd 6b 8f			call hexout 
c797 e1				pop hl 
c798 7d				ld a,l 
c799 21 09 e6			ld hl, os_word_scratch+2 
c79c cd 6b 8f			call hexout 
c79f 21 0b e6			ld hl, os_word_scratch+4 
c7a2 3e 00			ld a,0 
c7a4 77				ld (hl),a 
c7a5 11 07 e6			ld de,os_word_scratch 
c7a8 3e 33				ld a, display_row_2 + 11 
c7aa cd 50 8a				call str_at_display 
c7ad			 
c7ad cd 60 8a			call update_display 
c7b0 cd ba 89			call delay1s 
c7b3 cd ba 89			call delay1s 
c7b6 e1				pop hl 
c7b7 f1				pop af 
c7b8 c9				ret 
c7b9			;endif 
c7b9			 
c7b9			include "forth_autostart.asm" 
c7b9			; list of commands to perform at system start up 
c7b9			 
c7b9			startcmds: 
c7b9			;	dw test11 
c7b9			;	dw test12 
c7b9			;	dw test13 
c7b9			;	dw test14 
c7b9			;	dw test15 
c7b9			;	dw test16 
c7b9			;	dw test17 
c7b9			;	dw ifthtest1 
c7b9			;	dw ifthtest2 
c7b9			;	dw ifthtest3 
c7b9			;	dw mmtest1 
c7b9			;	dw mmtest2 
c7b9			;	dw mmtest3 
c7b9			;	dw mmtest4 
c7b9			;	dw mmtest5 
c7b9			;	dw mmtest6 
c7b9			;	dw iftest1 
c7b9			;	dw iftest2 
c7b9			;	dw iftest3 
c7b9			;	dw looptest1 
c7b9			;	dw looptest2 
c7b9			;	dw test1 
c7b9			;	dw test2 
c7b9			;	dw test3 
c7b9			;	dw test4 
c7b9			;	dw game2r 
c7b9			;	dw game2b1 
c7b9			;	dw game2b2 
c7b9			 
c7b9				; start up words that are actually useful 
c7b9			 
c7b9 19 c8			dw longread 
c7bb 3f c8			dw clrstack 
c7bd 72 c8			dw type 
c7bf 62 ca			dw stest 
c7c1 96 c8			dw strncpy 
c7c3 f8 c9			dw list 
c7c5 f7 c8			dw start1 
c7c7 09 c9			dw start2 
c7c9			;	dw start3 
c7c9 1c c9			dw start3b 
c7cb 98 c9			dw start3c 
c7cd			 
c7cd				; (unit) testing words 
c7cd			 
c7cd d9 ca			dw mtesta 
c7cf 8e cb			dw mtestb 
c7d1 31 cc			dw mtestc 
c7d3 e6 cc			dw mtestd 
c7d5 8a cd			dw mteste 
c7d7			 
c7d7				; demo/game words 
c7d7			 
c7d7 96 d4		        dw game3w 
c7d9 c4 d4		        dw game3p 
c7db e2 d4		        dw game3sc 
c7dd 13 d5		        dw game3vsi 
c7df 3f d5		        dw game3vs 
c7e1				 
c7e1 89 d2			dw game2b 
c7e3 f7 d2			dw game2bf 
c7e5 41 d3			dw game2mba 
c7e7 d7 d3			dw game2mbas 
c7e9 19 d4			dw game2mb 
c7eb			 
c7eb 4a cf			dw game1 
c7ed 5b cf			dw game1a 
c7ef bd cf			dw game1b 
c7f1 f2 cf			dw game1c 
c7f3 28 d0			dw game1d 
c7f5 59 d0			dw game1s 
c7f7 6d d0			dw game1t 
c7f9 82 d0			dw game1f 
c7fb b6 d0			dw game1z 
c7fd fa d0			dw game1zz 
c7ff			 
c7ff 40 ce			dw test5 
c801 78 ce			dw test6 
c803 b0 ce			dw test7 
c805 c4 ce			dw test8 
c807 f0 ce			dw test9 
c809 06 cf			dw test10 
c80b				 
c80b d1 d1		        dw ssv5 
c80d b5 d1		        dw ssv4 
c80f 99 d1		        dw ssv3 
c811 63 d1		        dw ssv2 
c813 ea d1		        dw ssv1 
c815 32 d2		        dw ssv1cpm 
c817			;	dw keyup 
c817			;	dw keydown 
c817			;	dw keyleft 
c817			;	dw keyright 
c817			;	dw 	keyf1 
c817			;	dw keyf2 
c817			;	dw keyf3 
c817			;	dw keyf4 
c817			;	dw keyf5 
c817			;	dw keyf6 
c817			;	dw keyf7 
c817			;	dw keyf8 
c817			;	dw keyf9 
c817			;	dw keyf10 
c817			;	dw keyf11 
c817			;	dw keyf12 
c817			;	dw keytab 
c817			;	dw keycr 
c817			;	dw keyhome 
c817			;	dw keyend 
c817			;	dw keybs 
c817 00 00			db 0, 0	 
c819			 
c819			 
c819			; Long read 
c819			; e.g. $01 lread 
c819			; 
c819			; TODO need some constants 
c819			 
c819 .. 00		longread:   db ": lread read repeat count $3e = if ; ", 0 
c83f			 
c83f			; clear stack  
c83f			 
c83f .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c872			 
c872			; type ( addr count - ) 
c872 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c896			 
c896			; some direct memory words 
c896			; strncpy ( len t f -- t ) 
c896			 
c896 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c8f7			 
c8f7 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c909 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c91c .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
c998 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c9f8			 
c9f8			 
c9f8			; a handy word to list items on the stack 
c9f8			 
c9f8 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
ca62			 
ca62			 
ca62			; test stack  
ca62			; rnd8 stest 
ca62			 
ca62 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
cad9			 
cad9			; random malloc and free cycles 
cad9			 
cad9 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
cb8e			 
cb8e			; fixed malloc and free cycles 
cb8e			 
cb8e .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
cc31			 
cc31			; fixed double string push and drop cycle  
cc31			 
cc31 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
cce6			 
cce6			; consistent fixed string push and drop cycle  
cce6			 
cce6 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cd8a			 
cd8a .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
ce40			 
ce40			;test1:		db ": aa 1 2 3 ;", 0 
ce40			;test2:     	db "111 aa 888 999",0 
ce40			;test3:     	db ": bb 77 ;",0 
ce40			;test4:     	db "$02 $01 do i . loop bb",0 
ce40			 
ce40 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
ce78 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
ceb0 .. 00		test7:     	db ": box hline vline ;",0 
cec4 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cef0 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cf06 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cf2b .. 00		test11:     	db "hello create .",0 
cf3a .. 00		test12:     	db "hello2 create .",0 
cf4a			 
cf4a			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cf4a			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cf4a			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cf4a			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cf4a			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cf4a			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cf4a			 
cf4a			;iftest1:     	db "$0001 IF cls .",0 
cf4a			;iftest2:     	db "$0000 IF cls .",0 
cf4a			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cf4a			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cf4a			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cf4a			 
cf4a			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cf4a			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cf4a			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cf4a			 
cf4a			 
cf4a			 
cf4a			; a small guess the number game 
cf4a			 
cf4a .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cf5b .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
cfbd			 
cfbd .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
cff2 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d028 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d059 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d06d .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d082 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d0b6 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d0fa			 
d0fa			; Using 'ga' save a high score across multiple runs using external storage 
d0fa			 
d0fa .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d163			 
d163			 
d163			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d163			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d163			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d163			 
d163			; simple screen saver to test code memory reuse to destruction 
d163			 
d163 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d199 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d1b5 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d1d1 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d1ea .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d232 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d289			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d289			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d289			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d289			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d289			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d289			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d289			 
d289			 
d289			 
d289			; minesweeper/battleship finding game 
d289			; draws a game board of random ship/mine positions 
d289			; user enters coords to see if it hits on 
d289			; game ends when all are hit 
d289			; when hit or miss says how many may be in the area 
d289			 
d289			; setup the game board and then hide it 
d289 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d2f7 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d341			; prompt for where to target 
d341 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d3d7 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d3fc			; TODO see if the entered coords hits or misses pushes char hit of miss 
d3fc .. 00		game2mbht:      db ": mbckht nop ;",0 
d40b .. 00		game2mbms:      db ": mbcms nop ;",0 
d419			; TODO how many might be near by 
d419 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d496			 
d496			; Game 3 
d496			 
d496			; Vert scroller ski game - avoid the trees! 
d496			 
d496			; v0 score (ie turns) 
d496			; v1 player pos 
d496			; v2 left wall 
d496			; v3 right wall 
d496			 
d496			; Draw side walls randomly 
d496			 
d496 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d4c4			 
d4c4			; Draw player 
d4c4 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d4e2			 
d4e2			; TODO Get Key 
d4e2			 
d4e2			; TODO Move left right 
d4e2			 
d4e2			; scroll and move walls a bit 
d4e2			 
d4e2 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d513			 
d513			; main game loop 
d513			 
d513 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d53f .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d57e			 
d57e			; key board defs 
d57e			 
d57e .. 00		keyup:       db ": keyup $05 ;",0 
d58c .. 00		keydown:       db ": keydown $0a ;",0 
d59c .. 00		keyleft:       db ": keyleft $0b ;",0 
d5ac .. 00		keyright:       db ": keyright $0c ;",0 
d5bd .. 00		keyf1:       db ": keyf1 $10 ;",0 
d5cb .. 00		keyf2:       db ": keyf2 $11 ;",0 
d5d9 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d5e7 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d5f5 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d603 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d611 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d61f .. 00		keyf8:       db ": keyf8 $17 ;",0 
d62d .. 00		keyf9:       db ": keyf9 $18 ;",0 
d63b .. 00		keyf10:       db ": keyf10 $19 ;",0 
d64a .. 00		keyf11:       db ": keyf11 $1a ;",0 
d659 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d668			 
d668 .. 00		keytab:       db ": keytab $09 ;",0 
d677 .. 00		keycr:       db ": keycr $0d ;",0 
d685 .. 00		keyhome:       db ": keyhome $0e ;",0 
d695 .. 00		keyend:       db ": keyend $0f ;",0 
d6a4 .. 00		keybs:       db ": keybs $08 ;",0 
d6b2			 
d6b2			   
d6b2			 
d6b2			 
d6b2			 
d6b2			; eof 
# End of file forth_autostart.asm
d6b2			 
d6b2 .. 00		sprompt1: db "Startup load...",0 
d6c2 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d6d8			 
d6d8			 
d6d8			 
d6d8			 
d6d8			forth_startup: 
d6d8 21 b9 c7			ld hl, startcmds 
d6db 3e 00			ld a, 0 
d6dd 32 28 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d6e0			 
d6e0 e5			.start1:	push hl 
d6e1 cd 3d 8a			call clear_display 
d6e4 11 b2 d6			ld de, sprompt1 
d6e7 3e 00		        ld a, display_row_1 
d6e9 cd 50 8a			call str_at_display 
d6ec 11 c2 d6			ld de, sprompt2 
d6ef 3e 28		        ld a, display_row_2 
d6f1 cd 50 8a			call str_at_display 
d6f4 e1				pop hl 
d6f5 e5				push hl 
d6f6 5e				ld e,(hl) 
d6f7 23				inc hl 
d6f8 56				ld d,(hl) 
d6f9 3e 50		        ld a, display_row_3 
d6fb cd 50 8a			call str_at_display 
d6fe cd 60 8a			call update_display 
d701			 
d701			 
d701 3a 28 e7			ld a, (os_last_cmd) 
d704 fe 00			cp 0 
d706 28 05			jr z, .startprompt 
d708 cd ae 89			call delay250ms 
d70b 18 24			jr .startdo 
d70d				 
d70d				 
d70d			 
d70d			.startprompt: 
d70d			 
d70d 3e 9f			ld a,display_row_4 + display_cols - 1 
d70f 11 52 9a		        ld de, endprg 
d712 cd 50 8a			call str_at_display 
d715 cd 60 8a			call update_display 
d718 cd ba 89			call delay1s 
d71b cd 3e da			call cin_wait 
d71e						 
d71e fe 2a			cp '*' 
d720 28 5e			jr z, .startupend1 
d722 fe 23			cp '#' 
d724 20 07			jr nz, .startno 
d726 3e 01			ld a, 1 
d728 32 28 e7			ld (os_last_cmd),a 
d72b 18 04			jr .startdo 
d72d fe 31		.startno:	cp '1' 
d72f 28 3a			jr z,.startnxt  
d731			 
d731				; exec startup line 
d731			.startdo:	 
d731 e1				pop hl 
d732 e5				push hl 
d733				 
d733 5e				ld e,(hl) 
d734 23				inc hl 
d735 56				ld d,(hl) 
d736 eb				ex de,hl 
d737			 
d737 e5				push hl 
d738			 
d738 3e 00			ld a, 0 
d73a				;ld a, FORTH_END_BUFFER 
d73a cd d3 90			call strlent 
d73d 23				inc hl   ; include zero term to copy 
d73e 06 00			ld b,0 
d740 4d				ld c,l 
d741 e1				pop hl 
d742 11 02 e3			ld de, scratch 
d745 ed b0			ldir 
d747			 
d747			 
d747 21 02 e3			ld hl, scratch 
d74a cd 98 9e			call forthparse 
d74d cd d8 9e			call forthexec 
d750 cd ea 9d			call forthexec_cleanup 
d753			 
d753 3e 78			ld a, display_row_4 
d755 11 f6 97			ld de, endprog 
d758			 
d758 cd 60 8a			call update_display		 
d75b			 
d75b 3a 28 e7			ld a, (os_last_cmd) 
d75e fe 00			cp 0 
d760 20 09			jr nz, .startnxt 
d762 cd 54 9a			call next_page_prompt 
d765 cd 3d 8a		        call clear_display 
d768 cd 60 8a			call update_display		 
d76b			 
d76b				; move onto next startup line? 
d76b			.startnxt: 
d76b			 
d76b cd ae 89			call delay250ms 
d76e e1				pop hl 
d76f			 
d76f 23				inc hl 
d770 23				inc hl 
d771			 
d771 e5				push hl 
d772 5e				ld e, (hl) 
d773 23				inc hl 
d774 56				ld d, (hl) 
d775 e1				pop hl 
d776				; TODO replace 0 test 
d776			 
d776 eb				ex de, hl 
d777 cd 93 8c			call ishlzero 
d77a			;	ld a,e 
d77a			;	add d 
d77a			;	cp 0    ; any left to do? 
d77a eb				ex de, hl 
d77b c2 e0 d6			jp nz, .start1 
d77e 18 01			jr .startupend 
d780			 
d780 e1			.startupend1: pop hl 
d781			.startupend: 
d781			 
d781 cd 3d 8a			call clear_display 
d784 cd 60 8a			call update_display 
d787 c9				ret 
d788			 
d788			 
d788			; stack over and underflow checks 
d788			 
d788			; init the words to detect the under/overflow 
d788			 
d788			chk_stk_init: 
d788				; a vague random number to check so we dont get any "lucky" hits 
d788 3e 2d			ld a, 45 
d78a 6f				ld l, a 
d78b 00				nop 
d78c 3e 17			ld a, 23 
d78e 67				ld h, a 
d78f			 
d78f 22 e9 e2			ld (chk_word), hl     ; the word we need to check against 
d792			 
d792			;	ld (chk_stund), hl	; stack points.... 
d792 22 00 ef			ld (chk_stovr), hl 
d795 22 2d ea			ld (chk_ret_und), hl 
d798 22 eb e9			ld (chk_ret_ovr), hl 
d79b 22 69 e9			ld (chk_loop_ovr), hl 
d79e 22 67 e8			ld (chk_data_ovr), hl 
d7a1 c9				ret 
d7a2				 
d7a2			check_stacks: 
d7a2				; check all stack words 
d7a2			 
d7a2 e5				push hl 
d7a3 d5				push de 
d7a4			 
d7a4			;	ld de,(chk_word) 
d7a4			;	ld hl, (chk_stund)	; stack points.... 
d7a4			;	if DEBUG_STK_FAULT 
d7a4			;		DMARK "FAa" 
d7a4			;		CALLMONITOR 
d7a4			;	endif 
d7a4			;	call cmp16 
d7a4			;	jp z, .chk_faulta 
d7a4			; 
d7a4			;	ld de, sfaultsu 
d7a4			;	jp .chk_fault 
d7a4			 
d7a4 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d7a7 ed 5b e9 e2		ld de,(chk_word) 
d7ab				if DEBUG_STK_FAULT 
d7ab					DMARK "FAb" 
d7ab					CALLMONITOR 
d7ab				endif 
d7ab cd 88 8c			call cmp16 
d7ae 28 06			jr z, .chk_fault1 
d7b0 11 51 d8			ld de, sfaultso 
d7b3 c3 05 d8			jp .chk_fault 
d7b6			.chk_fault1:  
d7b6 2a 2d ea			ld hl, (chk_ret_und) 
d7b9 ed 5b e9 e2		ld de,(chk_word) 
d7bd				if DEBUG_STK_FAULT 
d7bd					DMARK "FAU" 
d7bd					CALLMONITOR 
d7bd				endif 
d7bd cd 88 8c			call cmp16 
d7c0 ca c9 d7			jp z, .chk_fault2 
d7c3 11 61 d8			ld de, sfaultru 
d7c6 c3 05 d8			jp .chk_fault 
d7c9			.chk_fault2:  
d7c9 2a eb e9			ld hl, (chk_ret_ovr) 
d7cc ed 5b e9 e2		ld de,(chk_word) 
d7d0				if DEBUG_STK_FAULT 
d7d0					DMARK "FA1" 
d7d0					CALLMONITOR 
d7d0				endif 
d7d0 cd 88 8c			call cmp16 
d7d3 ca dc d7			jp z, .chk_fault3 
d7d6 11 6f d8			ld de, sfaultro 
d7d9 c3 05 d8			jp .chk_fault 
d7dc			.chk_fault3:  
d7dc 2a 69 e9			ld hl, (chk_loop_ovr) 
d7df ed 5b e9 e2		ld de,(chk_word) 
d7e3				if DEBUG_STK_FAULT 
d7e3					DMARK "FA2" 
d7e3					CALLMONITOR 
d7e3				endif 
d7e3 cd 88 8c			call cmp16 
d7e6 ca ef d7			jp z, .chk_fault4 
d7e9 11 89 d8			ld de, sfaultlo 
d7ec c3 05 d8			jp .chk_fault 
d7ef			.chk_fault4:  
d7ef 2a 67 e8			ld hl, (chk_data_ovr) 
d7f2 ed 5b e9 e2		ld de,(chk_word) 
d7f6				if DEBUG_STK_FAULT 
d7f6					DMARK "FA3" 
d7f6					CALLMONITOR 
d7f6				endif 
d7f6 cd 88 8c			call cmp16 
d7f9 ca 02 d8			jp z, .chk_fault5 
d7fc 11 a3 d8			ld de, sfaultdo 
d7ff c3 05 d8			jp .chk_fault 
d802			 
d802			 
d802			.chk_fault5:  
d802 d1				pop de 
d803 e1				pop hl 
d804			 
d804 c9				ret 
d805			 
d805 cd 3d 8a		.chk_fault: 	call clear_display 
d808 3e 28				ld a, display_row_2 
d80a cd 50 8a				call str_at_display 
d80d 11 33 d8				   ld de, .stackfault 
d810 3e 00				ld a, display_row_1 
d812 cd 50 8a				call str_at_display 
d815 11 71 ee				    ld de, debug_mark 
d818 3e 11				ld a, display_row_1+17 
d81a cd 50 8a				call str_at_display 
d81d cd 60 8a				call update_display 
d820			 
d820				; prompt before entering montior for investigating issue 
d820			 
d820 3e 78			ld a, display_row_4 
d822 11 f6 97			ld de, endprog 
d825			 
d825 cd 60 8a			call update_display		 
d828			 
d828 cd 54 9a			call next_page_prompt 
d82b			 
d82b d1				pop de 
d82c e1				pop hl 
d82d cd 4a 98				call monitor 
d830 c3 44 97				jp warmstart 
d833					;jp 0 
d833					;halt 
d833			 
d833			 
d833			 
d833 .. 00		.stackfault: 	db "Stack fault:",0 
d840			 
d840 .. 00		sfaultsu: 	db	"Stack under flow",0 
d851 .. 00		sfaultso: 	db	"Stack over flow",0 
d861 .. 00		sfaultru:	db "RTS underflow",0 
d86f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d889 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d8a3 .. 00		sfaultdo:	db "DTS overflow", 0 
d8b0			 
d8b0			 
d8b0			fault_dsp_under: 
d8b0 11 c2 d8			ld de, .dsp_under 
d8b3 c3 72 d9			jp .show_fault 
d8b6			 
d8b6			fault_rsp_under: 
d8b6 11 d0 d8			ld de, .rsp_under 
d8b9 c3 72 d9			jp .show_fault 
d8bc			fault_loop_under: 
d8bc 11 de d8			ld de, .loop_under 
d8bf c3 72 d9			jp .show_fault 
d8c2			 
d8c2 .. 00		.dsp_under: db "DSP Underflow",0 
d8d0 .. 00		.rsp_under: db "RSP Underflow",0 
d8de .. 00		.loop_under: db "LOOP Underflow",0 
d8ed			 
d8ed			 
d8ed d5			type_faultn: 	push de 
d8ee e5					push hl 
d8ef cd 3d 8a				call clear_display 
d8f2 11 19 d9				   ld de, .typefaultn 
d8f5 3e 00				ld a, display_row_1 
d8f7 cd 50 8a				call str_at_display 
d8fa 11 71 ee				    ld de, debug_mark 
d8fd 3e 11				ld a, display_row_1+17 
d8ff cd 50 8a				call str_at_display 
d902 cd 60 8a				call update_display 
d905			 
d905				; prompt before entering montior for investigating issue 
d905			 
d905 3e 78			ld a, display_row_4 
d907 11 f6 97			ld de, endprog 
d90a			 
d90a cd 60 8a			call update_display		 
d90d			 
d90d cd 54 9a			call next_page_prompt 
d910			 
d910 e5					push hl 
d911 d5					push de 
d912 cd 4a 98				call monitor 
d915 c3 44 97				jp warmstart 
d918 76					halt 
d919			 
d919			 
d919 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d930			 
d930 d5			type_faults: 	push de 
d931 e5					push hl 
d932 cd 3d 8a				call clear_display 
d935 11 5b d9				   ld de, .typefaults 
d938 3e 00				ld a, display_row_1 
d93a cd 50 8a				call str_at_display 
d93d 11 71 ee				    ld de, debug_mark 
d940 3e 11				ld a, display_row_1+17 
d942 cd 50 8a				call str_at_display 
d945 cd 60 8a				call update_display 
d948			 
d948				; prompt before entering montior for investigating issue 
d948			 
d948 3e 78			ld a, display_row_4 
d94a 11 f6 97			ld de, endprog 
d94d			 
d94d cd 60 8a			call update_display		 
d950			 
d950 cd 54 9a			call next_page_prompt 
d953			 
d953 e1					pop hl 
d954 d1					pop de 
d955 cd 4a 98				call monitor 
d958 c3 44 97				jp warmstart 
d95b			 
d95b			 
d95b .. 00		.typefaults: db "STR Type Expected TOS!",0 
d972			 
d972			.show_fault: 	 
d972 d5					push de 
d973 cd 3d 8a				call clear_display 
d976 d1					pop de 
d977 3e 00				ld a, display_row_1 
d979 cd 50 8a				call str_at_display 
d97c 11 71 ee				    ld de, debug_mark 
d97f 3e 11				ld a, display_row_1+17 
d981 cd 50 8a				call str_at_display 
d984 cd 60 8a				call update_display 
d987			 
d987				; prompt before entering montior for investigating issue 
d987			 
d987 3e 78			ld a, display_row_4 
d989 11 f6 97			ld de, endprog 
d98c			 
d98c cd 60 8a			call update_display		 
d98f			 
d98f cd 54 9a			call next_page_prompt 
d992			 
d992 e1					pop hl 
d993 d1					pop de 
d994 cd 4a 98				call monitor 
d997			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d997			; TODO Make optional fault restart to cli or warm boot? 
d997					;jp warmstart 
d997 c3 9c 97				jp cli 
d99a 76					halt 
d99b			 
d99b			; handle the auto run of code from files in storage 
d99b			 
d99b			 
d99b			if STORAGE_SE 
d99b			 
d99b			sprompt3: db "Loading from start-up file?:",0 
d99b			sprompt4: db "(Y=Any key/N=No)",0 
d99b			 
d99b			 
d99b			forth_autoload: 
d99b			 
d99b				; load block 0 of store 1 
d99b				 
d99b				ld a, $fe      ; bit 0 clear 
d99b				ld (spi_device), a 
d99b			 
d99b				call storage_get_block_0 
d99b			 
d99b				ld a, (store_page+STORE_0_AUTOFILE) 
d99b			 
d99b				cp 0 
d99b				ret z     ; auto start not enabled 
d99b			 
d99b				call clear_display 
d99b			 
d99b				; set bank 
d99b			 
d99b					ld a, (store_page+STORE_0_BANKRUN) 
d99b					ld (spi_device), a 
d99b			 
d99b				; get file id to load from and get the file name to display 
d99b			 
d99b					ld a, (store_page+STORE_0_FILERUN) 
d99b			 
d99b					ld l, 0 
d99b					ld h, a 
d99b					ld de, store_page 
d99b			 
d99b					if DEBUG_FORTH_WORDS 
d99b						DMARK "ASp" 
d99b						CALLMONITOR 
d99b					endif 
d99b					call storage_read 
d99b			 
d99b					if DEBUG_FORTH_WORDS 
d99b						DMARK "ASr" 
d99b						CALLMONITOR 
d99b					endif 
d99b			 
d99b					call ishlzero 
d99b					ret z             ; file not found 
d99b			 
d99b					ld a, display_row_2 + 10 
d99b					ld de, store_page+3 
d99b					call str_at_display 
d99b				 
d99b			; 
d99b			 
d99b				ld a, display_row_1+5 
d99b				ld de, sprompt3 
d99b				call str_at_display 
d99b				ld a, display_row_3+15 
d99b				ld de, sprompt4 
d99b				call str_at_display 
d99b			 
d99b				call update_display 
d99b			 
d99b				call cin_wait 
d99b				cp 'n' 
d99b				ret z 
d99b				cp 'N' 
d99b				ret z 
d99b			 
d99b				call delay1s 
d99b			 
d99b				ld a, (store_page+2) 
d99b				ld (store_openmaxext), a    ; save count of ext 
d99b				ld a, 1  
d99b				ld (store_openext), a    ; save count of ext 
d99b			 
d99b			.autof:  
d99b				ld l , a 
d99b				 
d99b				ld a, (store_page) 
d99b				ld h, a	 
d99b				ld de, store_page 
d99b					if DEBUG_FORTH_WORDS 
d99b						DMARK "ASl" 
d99b						CALLMONITOR 
d99b					endif 
d99b					call storage_read 
d99b				call ishlzero 
d99b				ret z 
d99b			;	jr z, .autoend 
d99b			 
d99b					if DEBUG_FORTH_WORDS 
d99b						DMARK "ASc" 
d99b						CALLMONITOR 
d99b					endif 
d99b				ld de, store_page+2 
d99b				ld a, display_row_4 
d99b				call str_at_display 
d99b			 
d99b				call update_display 
d99b				call delay250ms 
d99b			 
d99b			 
d99b			 
d99b				ld hl, store_page+2 
d99b				call forthparse 
d99b				call forthexec 
d99b				call forthexec_cleanup 
d99b			 
d99b				 
d99b				ld a, (store_openext) 
d99b				inc a 
d99b				ld (store_openext), a    ; save count of ext 
d99b			 
d99b				jr .autof 
d99b			;.autofdone: 
d99b			; 
d99b			;		if DEBUG_FORTH_WORDS 
d99b			;			DMARK "ASx" 
d99b			;			CALLMONITOR 
d99b			;		endif 
d99b			;;	call clear_display 
d99b			;	ret 
d99b			 
d99b			 
d99b			 
d99b			endif 
d99b			 
d99b			 
d99b			; eof 
# End of file forth_kernel.asm
d99b			;include "nascombasic.asm" 
d99b			 
d99b			 
d99b			; find out where the code ends if loaded into RAM (for SC114) 
d99b			;endofcode:  
d99b			;	nop 
d99b			 
d99b			 
d99b			; eof 
d99b			 
# End of file main.asm
d99b			;include "firmware_lcd_4x40.asm" 
d99b			;;include "firmware_lcd_4x20.asm" 
d99b			include "firmware_serial_display.asm" 
d99b			 
d99b			; Serial display interface for SC114 
d99b			 
d99b			 
d99b			display_row_1: equ 0 
d99b			display_row_2: equ display_row_1+display_cols 
d99b			display_row_3: equ display_row_2 + display_cols 
d99b			display_row_4: equ display_row_3 + display_cols 
d99b			 
d99b			kLCDWidth:  EQU display_cols             ;Width in characters 
d99b			kLCD_Line1: EQU 0x00  
d99b			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d99b			; E1 
d99b			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d99b			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d99b			 
d99b			lcd_init: 
d99b				; no init as handled by the SCM bios 
d99b c9				ret 
d99c			 
d99c			 
d99c			; low level functions for direct screen writes 
d99c			 
d99c			; output char at pos? 
d99c			fLCD_Str: 
d99c			        ;out (SC114_SIO_1_OUT),a 
d99c c5				push bc 
d99d 0e 02			ld c, $02 
d99f f7				rst $30 
d9a0 c1				pop bc 
d9a1 c9				ret 
d9a2			 
d9a2			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d9a2			fLCD_Pos: 
d9a2				; use ASCII escape to position 
d9a2			        ;out (SC114_SIO_1_OUT),a 
d9a2 c5				push bc 
d9a3 0e 02			ld c, $02 
d9a5 f7				rst $30 
d9a6 c1				pop bc 
d9a7			 
d9a7 c9				ret 
d9a8			 
d9a8			; output char at pos 
d9a8			fLCD_Data: 
d9a8			      ;  out (SC114_SIO_1_OUT),a 
d9a8 c5				push bc 
d9a9 0e 02			ld c, $02 
d9ab f7				rst $30 
d9ac c1				pop bc 
d9ad			 
d9ad c9				ret 
d9ae			 
d9ae			; ascii cls  
d9ae			 
d9ae 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d9b2			 
d9b2			; write the frame buffer given in hl to hardware  
d9b2			write_display: 
d9b2			 
d9b2			API: equ 0 
d9b2			 
d9b2			if API 
d9b2				push bc 
d9b2				ld b, 4 
d9b2			 
d9b2			        ld (display_write_tmp), hl 	  
d9b2			 
d9b2				; clear and home cursor 
d9b2			 
d9b2				ld c, 6 
d9b2				ld de, .cls 
d9b2				rst $30 
d9b2			 
d9b2			 
d9b2			.writeln: 
d9b2			 
d9b2				ld de, (display_write_tmp) 
d9b2				ld c, 6 
d9b2				rst $30 
d9b2				ld c, 7 
d9b2				rst $30 
d9b2			 
d9b2				ld hl, (display_write_tmp) 
d9b2				ld de, display_cols 
d9b2				add hl,de 
d9b2				ld (display_write_tmp),hl 
d9b2			 
d9b2				djnz  .writeln 
d9b2			 
d9b2				pop bc 
d9b2			 
d9b2			 
d9b2				ret 
d9b2			endif 
d9b2 e5				push hl 
d9b3 c5				push bc 
d9b4 d5				push de 
d9b5			 
d9b5			;	ld c, 2 
d9b5			;	;ld de, .cls 
d9b5			;	ld a, 27 
d9b5			;	rst $30 
d9b5			;	ld c, 2 
d9b5			;	;ld de, .cls 
d9b5			;	ld a, '[' 
d9b5			;	rst $30 
d9b5			; 
d9b5			;	ld c, 2 
d9b5			;	;ld de, .cls 
d9b5			;	ld a, 'H' 
d9b5			;	rst $30 
d9b5			; 
d9b5			 
d9b5 0e 02			ld c, 2 
d9b7				;ld de, .cls 
d9b7 3e 1b			ld a, 27 
d9b9 f7				rst $30 
d9ba			 
d9ba			 
d9ba 0e 02			ld c, 2 
d9bc				;ld de, .cls 
d9bc 3e 5b			ld a, '[' 
d9be f7				rst $30 
d9bf 0e 02			ld c, 2 
d9c1				;ld de, .cls 
d9c1 3e 32			ld a, '2' 
d9c3 f7				rst $30 
d9c4 0e 02			ld c, 2 
d9c6				;ld de, .cls 
d9c6 3e 4a			ld a, 'J' 
d9c8 f7				rst $30 
d9c9 d1				pop de 
d9ca c1				pop bc 
d9cb e1				pop hl 
d9cc			 
d9cc			 
d9cc 22 cf eb		        ld (display_write_tmp), hl 	  
d9cf 3e 00			ld a, kLCD_Line1 
d9d1			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d9d1 06 28			ld b, display_cols 
d9d3 ed 5b cf eb		ld de, (display_write_tmp) 
d9d7 cd 35 da			call write_len_string 
d9da				 
d9da			 
d9da e5			push hl 
d9db d5			push de 
d9dc c5			push bc 
d9dd 0e 07			ld c, 7 
d9df f7				rst $30 
d9e0 c1			pop bc 
d9e1 d1			pop de 
d9e2 e1			pop hl 
d9e3			 
d9e3				 
d9e3 2a cf eb			ld hl, (display_write_tmp) 
d9e6 11 28 00			ld de, display_cols 
d9e9 19				add hl,de 
d9ea 22 cf eb			ld (display_write_tmp),hl 
d9ed			 
d9ed				 
d9ed 3e 28			ld a, kLCD_Line2 
d9ef			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d9ef 06 28			ld b, display_cols 
d9f1 ed 5b cf eb		ld de, (display_write_tmp) 
d9f5 cd 35 da			call write_len_string 
d9f8				 
d9f8 2a cf eb			ld hl, (display_write_tmp) 
d9fb 11 28 00			ld de, display_cols 
d9fe 19				add hl,de 
d9ff 22 cf eb			ld (display_write_tmp),hl 
da02			 
da02 e5			push hl 
da03 d5			push de 
da04 c5			push bc 
da05 0e 07			ld c, 7 
da07 f7				rst $30 
da08 c1			pop bc 
da09 d1			pop de 
da0a e1			pop hl 
da0b			 
da0b				 
da0b 3e 50			ld a, kLCD_Line3 
da0d			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
da0d 06 28			ld b, display_cols 
da0f ed 5b cf eb		ld de, (display_write_tmp) 
da13 cd 35 da			call write_len_string 
da16				 
da16 2a cf eb			ld hl, (display_write_tmp) 
da19 11 28 00			ld de, display_cols 
da1c 19				add hl,de 
da1d 22 cf eb			ld (display_write_tmp),hl 
da20			 
da20 e5			push hl 
da21 d5			push de 
da22 c5			push bc 
da23 0e 07			ld c, 7 
da25 f7				rst $30 
da26 c1			pop bc 
da27 d1			pop de 
da28 e1			pop hl 
da29			 
da29				 
da29 3e 78			ld a, kLCD_Line4 
da2b			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
da2b 06 28			ld b, display_cols 
da2d ed 5b cf eb		ld de, (display_write_tmp) 
da31 cd 35 da			call write_len_string 
da34 c9					ret 
da35			 
da35			 
da35				; write out a fixed length string given in b from de 
da35			 
da35 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
da36 cd a8 d9		            CALL fLCD_Data      ;Write character to display 
da39 13				inc de 
da3a 10 f9			djnz write_len_string 
da3c c9				ret 
da3d			 
da3d			 
da3d			; eof 
# End of file firmware_serial_display.asm
da3d			;include "firmware_key_5x10.asm" 
da3d			;;include "firmware_key_4x10.asm" 
da3d			include "firmware_key_serial.asm" 
da3d			; Serial keyboard interface for SC114 
da3d			 
da3d			key_init: 
da3d				; no init as handled by the SCM bios 
da3d c9				ret 
da3e			 
da3e			 
da3e			cin_wait: 
da3e			;	ld a, 0 
da3e			;	ret 
da3e			 
da3e				;in a,(SC114_SIO_1_IN) 
da3e			        ; Use SCM API to get from whatever console device we are using 
da3e c5				push bc 
da3f 0e 01			ld c, $01 
da41 f7				rst $30 
da42 c1				pop bc 
da43 c9				ret 
da44			 
da44			cin: 
da44			 
da44			 
da44 c5				push bc 
da45			 
da45				; any key waiting to process? 
da45 0e 03			ld c, $03 
da47 f7				rst $30 
da48 28 05			jr z, .cin_skip 
da4a			 
da4a				; yep, get it 
da4a			 
da4a 0e 01			ld c, $01 
da4c f7				rst $30 
da4d c1				pop bc 
da4e c9				ret 
da4f			.cin_skip: 
da4f 3e 00			ld a, 0 
da51 c1				pop bc 
da52 c9				ret 
da53			 
da53			 
da53			 
da53			 
# End of file firmware_key_serial.asm
da53			endofcode:  
da53			baseram:  
da53 00				nop 
da54			 
da54			heap_start: equ baseram+15  ; Starting address of heap 
da54			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
da54			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
da54			;VDU:  EQU     endofcode           ; BASIC Work space 
da54			; eof 
da54			 
# End of file os_mega_sc114.asm
da54
