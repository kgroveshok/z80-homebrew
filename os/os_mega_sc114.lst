# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 dc 95			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-09-06 16:19' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
801f			 
801f			 
801f			 
801f			;        nop  
801f			;        nop 
801f			;;	org 05h		; null out bdos call 
801f			; 
801f			;        nop  
801f			;        nop  
801f			;        nop 
801f			;;	org 08h 
801f			;;; 
801f			;;	jp cin		; rst 8 - char in 
801f			;;; 
801f			; 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;	org 010h 
801f			;; 
801f			;	jp cout		; rest 010h  - char out 
801f			;; 
801f			;	org 01bh   
801f			; 
801f			;	;jp  		; rst 01bh   - write string to display 
801f			;	jp str_at_display 
801f			; 
801f			; 
801f			;	org 020h 
801f			; 
801f			;	; jp		 ; rst 020h - read char at screen location 
801f			; 
801f			;	org 028h 
801f			 
801f				; jp		 ; rst 028h  - storage i/o 
801f			 
801f			; 	org 030h 
801f			;	jp break_point_state 
801f			  
801f			; $30  
801f			; org 038h 
801f			; $38 
801f			 
801f			; TODO any more important entry points to add to jump table for easier coding use? 
801f			 
801f			if BASE_KEV = 1  
801f			 
801f				; need to be at $66 for nmi support 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255 
801f				jp nmi 
801f			endif 
801f			 
801f			include "firmware.asm" 
801f			  
801f			; main constants (used here and in firmware)  
801f			  
801f			; TODO have page 0 of storage as bios  
801f			  
801f			Device_A: equ 0h  
801f			Device_B: equ 040h          ; Sound  
801f			  
801f			if BASE_KEV  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_SC114  
801f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			; TODO fixup for CPM  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			Device_D: equ 0c0h             ; Keyboard and LCD  
801f			  
801f			; Odd specific debug points for testing hardware dev  
801f			  
801f			;if DEBUG_LEVEL0  
801f			;	include "debug_level0.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL1  
801f			;	include "debug_level1.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL2  
801f			;	include "debug_level2.asm"  
801f			;endif  
801f			  
801f			  
801f			CALLMONITOR: macro  
801f			;	call break_point_state  
801f			; now use the break point debug vector  
801f				call debug_vector  
801f				endm  
801f			  
801f			MALLOC_1: equ 1        ; from dk88   
801f			MALLOC_2: equ 0           ; broke  
801f			MALLOC_3: equ 0           ; really broke  
801f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801f			  
801f			if BASE_KEV   
801f			;stacksize: equ 256  
801f			; each stack entry is three bytes (type + word)  
801f			stacksize: equ 3*150  
801f			  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 512  
801f			endif  
801f			if BASE_SC114  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			;if STORAGE_SE == 0  
801f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801f			;endif  
801f			  
801f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801f			  
801f			STORE_0_AUTORUN: equ $20  
801f			  
801f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801f			  
801f			STORE_0_AUTOFILE: equ $21  
801f			STORE_0_BANKRUN: equ $23  
801f			STORE_0_FILERUN: equ $24  
801f			  
801f			; Block 0 offsets for settings  
801f			  
801f			; if set then skip prompt for start up and accept all  
801f			  
801f			STORE_0_QUICKSTART: equ $25  
801f			  
801f			; Blocks where directory table is held  
801f			  
801f			; Reducing the number of entries increases the max file size  
801f			  
801f			;STORE_DIR_START: equ 1  
801f			;STORE_DIR_END: equ 33  
801f			  
801f			; Blocks from where file data is stored  
801f			  
801f			;STORE_DATA_START: equ STORE_DIR_END + 1  
801f			  
801f			; Block indicators (<32 are data files)  
801f			  
801f			;STORE_BLOCK_CFG: equ $8f       ; config block  
801f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801f			;STORE_BLOCK_FREE: equ $85       ; data block free  
801f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801f			  
801f			  
801f			  
801f			; Directory entry flags  
801f			  
801f			;STORE_DIR_FREE: equ 0  
801f			;STORE_DIR_FILE:  equ 1  
801f			  
801f			; Structure offsets to directory entries  
801f			;STORE_DE_FLAG: equ 0  
801f			;STORE_DE_MAXEXT: equ 1  
801f			;STORE_DE_FILENAME: equ 2  
801f			  
801f			; Structure offsets to block 0  
801f			  
801f			;STORE_BK0_ISFOR: equ 1  
801f			;STORE_BK0_LABEL: equ 3  
801f			  
801f			; memory allocation   
801f			  
801f			chk_stund: equ tos+2           ; underflow check word  
801f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801f			  
801f			; keyscan table needs rows x cols buffer  
801f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801f			  
801f			keyscan_table_row1: equ chk_stovr -key_cols-1  
801f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801f			keyscan_scancol: equ keyscan_table-key_cols  
801f			;keyscan_table_len: equ key_rows*key_cols  
801f			;keybufptr: equ keyscan_table - 2  
801f			;keysymbol: equ keybufptr - 1  
801f			key_held: equ keyscan_scancol-1	; currently held  
801f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801f			key_fa: equ key_repeat_ct -1 ;  
801f			key_fb: equ key_fa -1 ;  
801f			key_fc: equ key_fb -1 ;  
801f			key_fd: equ key_fc -1 ;  
801f			key_face_held: equ key_fd - 1   
801f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801f			  
801f			hardware_config: equ key_face_held - 10  
801f			  
801f			; hardware config switches  
801f			; TODO add bitmasks on includes for hardware  
801f			; high byte for expansion ids  
801f			;     0000 0000  no card inserted  
801f			;     0000 0001  storage card inserted  
801f			;     0000 0010  spi sd card active  
801f			  
801f			;       
801f			; low byte:  
801f			;     0000 0001   4x4 keypad  
801f			;     0000 0010   full keyboard  
801f			;     0000 0011   spi/ext keyboard  
801f			;     0000 0100   20x4 lcd  
801f			;     0000 1000   40x4 lcd  
801f			;     0000 1100   spi/ext display  
801f			;     0001 0000   ide interface available  
801f			  
801f			hardware_word: equ hardware_config - 2  
801f			  
801f			; debug marker - optional display of debug point on the debug screens  
801f			  
801f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801f			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
801f			  
801f			debug_umark: equ parse_vector - 6  ; current user mark  
801f			debug_mark: equ debug_umark - 4    ; internal word debug points  
801f			  
801f			; input_str vars  
801f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801f			input_size: equ input_start -1  ; number of chars  
801f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801f			input_len: equ input_cur_onoff - 5 ; length of current input  
801f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801f			  
801f			; cursor blink rate  
801f			CUR_BLINK_RATE: equ $09  
801f			;CUR_BLINK_RATE: equ 15  
801f			  
801f			key_actual_pressed: equ input_cursor - 1   
801f			key_symbol: equ key_actual_pressed - 1   
801f			key_shift: equ key_symbol - 1   
801f			  
801f			; Display allocation  
801f			  
801f			;display_rows: equ 4     ; move out to mini and mega files  
801f			;display_cols: equ 20  
801f			  
801f			display_fb_len: equ display_rows*display_cols  
801f			  
801f			; primary frame buffer     
801f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801f			; working frame buffers  
801f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801f			display_fb3: equ  display_fb1-display_fb_len - 1  
801f			display_fb2: equ  display_fb3-display_fb_len - 1  
801f			;  
801f			; pointer to active frame buffer  
801f			display_fb_active: equ display_fb2 - 2  
801f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801f			display_write_tmp: equ display_lcde1e2 - 2  
801f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801f			  
801f			;  
801f			  
801f			;; can load into de directory  
801f			cursor_col: equ display_active-1  
801f			cursor_row: equ cursor_col-1  
801f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801f			  
801f			; maths vars  
801f			  
801f			LFSRSeed: equ cursor_shape -20   
801f			randData: equ LFSRSeed - 2  
801f			xrandc: equ randData - 2  
801f			stackstore: equ xrandc - 2  
801f			seed1: equ  stackstore -2   
801f			seed2: equ seed1 - 2  
801f			  
801f			; cf storage vars  
801f			  
801f			iErrorNum:  equ seed2-1         ;Error number  
801f			iErrorReg:  equ iErrorNum -1              ;Error register  
801f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801f			  
801f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801f			  
801f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801f			  
801f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801f			store_tmpid: equ store_tmp3 - 1		; page temp id  
801f			store_tmpext: equ store_tmpid - 1		; file extent temp  
801f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801f			;  
801f			; spi vars  
801f			  
801f			  
801f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801f			spi_device_id: equ spi_device - 1    ; human readable bank number  
801f			  
801f			;;;;; forth cli params  
801f			  
801f			; TODO use a different frame buffer for forth???  
801f			  
801f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801f			  
801f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801f			  
801f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801f			  
801f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801f			  
801f			; os/forth token vars  
801f			  
801f			os_last_cmd: equ os_var_array-255  
801f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801f			os_current_i: equ os_cli_cmd-2  
801f			os_cur_ptr: equ os_current_i-2  
801f			os_word_scratch: equ os_cur_ptr-30  
801f			os_tok_len: equ os_word_scratch - 2  
801f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801f			os_tok_malloc: equ os_tok_ptr - 2  
801f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801f			execscratch: equ os_input-255        ; exec cmd eval buffer  
801f			scratch: equ execscratch-255  
801f			  
801f			os_stack_1: equ scratch - 3       ; stack holding area 1  
801f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801f			  
801f			  
801f			; temp locations for new word processing to save on adding more   
801f			  
801f			os_new_malloc: equ os_stack_4-2  
801f			os_new_parse_len: equ os_new_malloc - 2  
801f			os_new_word_len: equ os_new_parse_len - 2  
801f			os_new_work_ptr: equ os_new_word_len - 2  
801f			os_new_src_ptr: equ os_new_work_ptr - 2  
801f			os_new_exec: equ os_new_src_ptr - 2  
801f			os_new_exec_ptr: equ os_new_exec - 2  
801f			  
801f			; resume memory alloocations....  
801f			  
801f			;os_view_disable: equ os_new_exec_ptr - 1  
801f			os_view_af: equ os_new_exec_ptr - 2  
801f			os_view_hl: equ os_view_af -2  
801f			os_view_de: equ os_view_hl - 2  
801f			os_view_bc: equ os_view_de - 2  
801f			  
801f			; stack checksum word  
801f			if DEBUG_STACK_IMB  
801f				curframe: equ  os_view_de - 5  
801f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			else  
801f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			endif  
801f			  
801f			; with data stack could see memory filled with junk. need some memory management   
801f			; malloc and free entry points added  
801f			  
801f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			;heap_end: equ free_list-1  ; Starting address of heap  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			heap_end: equ chk_word-1  ; Starting address of heap  
801f			  
801f			  
801f			;if BASE_KEV   
801f			;heap_start: equ 0800eh  ; Starting address of heap  
801f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;heap_start: equ baseram+15  ; Starting address of heap  
801f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;endif  
801f			  
801f			  
801f			;;;;  
801f			  
801f			  
801f			; change below to point to last memory alloc above  
801f			topusermem:  equ   heap_start  
801f			  
801f			;if BASE_KEV   
801f			;baseusermem: equ 08000h  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;;aseusermem:     equ    12  
801f			;baseusermem:     equ    prompt  
801f			;;baseusermem:     equ    endofcode  
801f			;endif  
801f			  
801f			  
801f			; **********************************************************************  
801f			; **  Constants  
801f			; **********************************************************************  
801f			  
801f			; Constants used by this code module  
801f			kDataReg:   EQU Device_D           ;PIO port A data register  
801f			kContReg:   EQU Device_D+2           ;PIO port A control register  
801f			  
801f			  
801f			portbdata:  equ Device_D+1    ; port b data  
801f			portbctl:   equ Device_D+3    ; port b control  
801f			  
801f			  
801f			;KEY_SHIFT:   equ 5  
801f			;KEY_SYMBOLSHIFT:  equ 6  
801f			  
801f			KEY_SHIFTLOCK: equ 4  
801f			  
801f			  
801f			KEY_UP: equ 5  
801f			KEY_NEXTWORD: equ 6  
801f			KEY_PREVWORD: equ 7  
801f			KEY_BS: equ 8  
801f			KEY_TAB:  equ 9  
801f			KEY_DOWN: equ 10  
801f			KEY_LEFT: equ 11  
801f			KEY_RIGHT: equ 12  
801f			KEY_CR:   equ 13  
801f			KEY_HOME: equ 14  
801f			KEY_END: equ 15  
801f			  
801f			KEY_F1: equ 16  
801f			KEY_F2: equ 17  
801f			KEY_F3: equ 18  
801f			KEY_F4: equ 19  
801f			  
801f			KEY_F5: equ 20  
801f			KEY_F6: equ 21  
801f			KEY_F7: equ 22  
801f			KEY_F8: equ 23  
801f			  
801f			KEY_F9: equ 24  
801f			KEY_F10: equ 25  
801f			KEY_F11: equ 26  
801f			KEY_F12: equ 27  
801f			  
801f			;if DEBUG_KEY  
801f			;	KEY_MATRIX_NO_PRESS: equ '.'  
801f			;	KEY_SHIFT:   equ '.'  
801f			;	KEY_SYMBOLSHIFT:  equ '.'  
801f			;else  
801f				KEY_SHIFT:   equ '~'  
801f				KEY_SYMBOLSHIFT:  equ '~'  
801f				KEY_MATRIX_NO_PRESS: equ '~'  
801f			;endi  
801f			  
801f			  
801f			  
801f			  
801f			; Macro to make adding debug marks easier  
801f			  
801f			DMARK: macro str  
801f				push af  
801f				ld a, (.dmark)  
801f				ld (debug_mark),a  
801f				ld a, (.dmark+1)  
801f				ld (debug_mark+1),a  
801f				ld a, (.dmark+2)  
801f				ld (debug_mark+2),a  
801f				jr .pastdmark  
801f			.dmark: db str  
801f			.pastdmark: pop af  
801f			  
801f			endm  
801f			  
801f			  
801f			; macro to detect for stack imbalances  
801f			  
801f			include "stackimbal.asm"  
801f			; Macro and code to detect stock imbalances 
801f			 
801f			SPPUSH: equ 0 
801f			 
801f			; Add a stack frame which can be checked before return 
801f			 
801f			STACKFRAME: macro onoff frame1 frame2 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f						exx 
801f			 
801f						ld de, frame1 
801f						ld a, d 
801f						ld hl, curframe 
801f						call hexout 
801f						ld a, e 
801f						ld hl, curframe+2 
801f						call hexout 
801f			  
801f						ld hl, frame1 
801f						push hl 
801f						ld hl, frame2 
801f						push hl 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			endm 
801f			 
801f			STACKFRAMECHK: macro onoff frame1 frame2 
801f			 
801f					 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						exx 
801f						; check stack frame SP 
801f			 
801f						ld hl, frame2 
801f						pop de   ; frame2 
801f			 
801f						call cmp16 
801f						jr nz, .spnosame 
801f						 
801f			 
801f						ld hl, frame1 
801f						pop de   ; frame1 
801f			 
801f						call cmp16 
801f						jr z, .spfrsame 
801f			 
801f						.spnosame: call showsperror 
801f			 
801f						.spfrsame: nop 
801f			 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			 
801f			 
801f			endm 
801f			 
801f			 
801f			; for a sub routine, wrap SP collection and comparisons 
801f			 
801f			; Usage: 
801f			; 
801f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801f			 
801f			SAVESP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f			 
801f						ld (store_sp+(storeword*4)), sp 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			CHECKSP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f			 
801f						; save SP after last save 
801f				 
801f						ld (store_sp+(storeword*4)+2), sp 
801f			 
801f						push hl 
801f						ld hl, store_sp+(storeword*4) 
801f						call check_stack_sp  
801f						pop hl 
801f			 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			if DEBUG_STACK_IMB 
801f			 
801f			check_stack_sp: 
801f					push de 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					push de 
801f			 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					pop hl 
801f			 
801f			 
801f					; check to see if the same 
801f			 
801f					call cmp16 
801f					jr z, .spsame 
801f			 
801f					; not same 
801f			 
801f					call showsperror 
801f			.spsame: 
801f			 
801f					pop de 
801f			 
801f					ret 
801f			 
801f			.sperr:  db "Stack imbalance",0 
801f			 
801f			 
801f			showsperror: 
801f			 
801f			 
801f				push hl 
801f				push af 
801f				push de 
801f				call clear_display 
801f				ld de, .sperr 
801f				ld a,0 
801f			;	ld de,os_word_scratch 
801f				call str_at_display 
801f				ld a, display_row_1+17 
801f				ld de, debug_mark 
801f				call str_at_display 
801f				ld a, 0 
801f				ld (curframe+4),a 
801f				ld hl, curframe 
801f				ld de, os_word_scratch 
801f				ld a, display_row_4 
801f				call str_at_display 
801f				call update_display 
801f				;call break_point_state 
801f				call cin_wait 
801f			 
801f			;	ld a, ' ' 
801f			;	ld (os_view_disable), a 
801f				call bp_on 
801f				pop de	 
801f				pop af 
801f				pop hl 
801f				CALLMONITOR 
801f				ret 
801f			 
801f			endif 
801f			 
801f			 
801f			 
801f			; eof 
# End of file stackimbal.asm
801f			  
801f			;TODO macro to calc col and row offset into screen  
801f			  
801f			  
801f			  
801f			hardware_init:  
801f			  
801f				  
801f			  
801f					;ld a, 0  
801f					;ld (hardware_diag), a  
801f			  
801f					; clear all the buffers  
801f			  
801f 21 07 ed				ld hl, display_fb1  
8022 22 c3 eb				ld (display_fb_active), hl  
8025			  
8025 cd bd 8a				call clear_display  
8028			  
8028 21 c5 eb				ld hl, display_fb2  
802b 22 c3 eb				ld (display_fb_active), hl  
802e			  
802e cd bd 8a				call clear_display  
8031			  
8031					; init primary frame buffer area  
8031 21 a8 ed				ld hl, display_fb0  
8034 22 c3 eb				ld (display_fb_active), hl  
8037			  
8037 cd bd 8a				call clear_display  
803a			  
803a			  
803a cd 38 e3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803d			  
803d cd da e3			call key_init  
8040 cd ad 80			call storage_init  
8043			  
8043				; setup malloc functions  
8043			  
8043				if MALLOC_1  
8043 cd a1 90				call  heap_init  
8046				endif  
8046				if MALLOC_4  
8046					call  heap_init  
8046				endif  
8046			  
8046				; init sound hardware if present  
8046			  
8046				if SOUND_ENABLE  
8046					call sound_init  
8046				endif  
8046			  
8046				; lcd test sequence  
8046					  
8046 cd e0 8a			call update_display  
8049 cd 00 8a			call delay1s  
804c 3e 2b			ld a,'+'  
804e cd c2 8a			call fill_display  
8051 cd e0 8a			call update_display  
8054 cd 00 8a			call delay1s  
8057 3e 2a			ld a,'*'  
8059 cd c2 8a			call fill_display  
805c cd e0 8a			call update_display  
805f cd 00 8a			call delay1s  
8062 3e 2d			ld a,'-'  
8064 cd c2 8a			call fill_display  
8067 cd e0 8a			call update_display  
806a cd 00 8a			call delay1s  
806d			  
806d			; boot splash screen  
806d			if display_cols == 20	  
806d			        ld a, display_row_1    
806d			else  
806d 3e 0a		        ld a, display_row_1 +10   
806f			endif  
806f 11 49 95			ld de, prom_bootmsg  
8072 cd d0 8a			call str_at_display  
8075 cd e0 8a			call update_display  
8078			  
8078			  
8078 cd 00 8a			call delay1s  
807b cd 00 8a			call delay1s  
807e			if display_cols == 20	  
807e			            LD   A, display_row_3+2  
807e			else  
807e 3e 5c		            LD   A, display_row_3+12  
8080			endif  
8080 11 5e 95			ld de, prom_bootmsg1  
8083 cd d0 8a			call str_at_display  
8086			; display debug level  
8086 3e 78		            LD   A, display_row_4  
8088 11 1b 80			ld de, debuglevel  
808b cd d0 8a			call str_at_display  
808e			  
808e cd e0 8a			call update_display  
8091 cd 00 8a			call delay1s  
8094 cd 00 8a			call delay1s  
8097			  
8097			;	ld a, display_row_4+3  
8097			;	ld de, bootmsg2  
8097			;	call str_at_display  
8097			;	call update_display  
8097			;	call delay1s  
8097			;	call delay1s  
8097			  
8097			; debug mark setup  
8097			  
8097 3e 5f		ld a, '_'  
8099 32 62 ee		ld (debug_mark),a  
809c 32 63 ee		ld (debug_mark+1),a  
809f 32 64 ee		ld (debug_mark+2),a  
80a2 3e 00		ld a,0  
80a4 32 65 ee		ld (debug_mark+3),a  
80a7 32 66 ee		ld (debug_umark),a  
80aa			  
80aa c9					ret  
80ab			  
80ab			  
80ab			;bootmsg2:	db "Firmware v0.1",0  
80ab			  
80ab			; a 4x20 lcd  
80ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ab			  
80ab			;if display_cols == 20  
80ab			;	include "firmware_lcd_4x20.asm"  
80ab			;endif  
80ab			  
80ab			;if display_cols == 40  
80ab			;	include "firmware_lcd_4x40.asm"  
80ab			;endif  
80ab			  
80ab			;  
80ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ab			; TODO abstract the bit bang video out interface for dual display  
80ab			; TODO wire video out to tx pin on rc2014 bus  
80ab			  
80ab			; must supply cin, and cin_wait for low level hardware abstraction   
80ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ab			; test scancode  
80ab			  
80ab			;;;;;  
80ab			;;;  
80ab			; Moved out to mini and maxi versions  
80ab			;  
80ab			; include "firmware_key_4x4.asm"  
80ab			; using existing 4 wire x 4 resistor array for input  
80ab			;include "firmware_key_4x10.asm"  
80ab			; need to mod the board for 5 rows due to resistor array  
80ab			;include "firmware_key_5x10.asm"  
80ab			  
80ab			; storage hardware interface  
80ab			  
80ab			; use microchip serial eeprom for storage  
80ab			  
80ab			  
80ab			if STORAGE_SE  
80ab				include "firmware_spi.asm"  
80ab				include "firmware_seeprom.asm"  
80ab			else  
80ab			   ; create some stubs for the labels  
80ab c9			se_readbyte: ret  
80ac c9			se_writebyte: ret  
80ad c9			storage_init: ret  
80ae			  
80ae			endif  
80ae			  
80ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80ae			;include "firmware_cf.asm"  
80ae			  
80ae			; load up high level storage hardward abstractions  
80ae			include "firmware_storage.asm"  
80ae			 
80ae			; persisent storage hardware abstraction layer  
80ae			 
80ae			 
80ae			 
80ae			; Block 0 on storage is a config state 
80ae			 
80ae			 
80ae			 
80ae			; TODO add read phy block and write phy block functions 
80ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80ae			 
80ae			; Abstraction layer  
80ae			 
80ae			; Logocial block size is same size as physical size - using tape concept 
80ae			 
80ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80ae			 
80ae			 
80ae			 
80ae			; Filesystem layout (Logical layout) 
80ae			; 
80ae			; Block 0 - Bank config  
80ae			; 
80ae			;      Byte - 0 file id counter 
80ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80ae			;      Byte - 3-20 zero terminated bank label 
80ae			; 
80ae			; Block 1 > File storage 
80ae			; 
80ae			;      Byte 0 file id    - block 0 file details 
80ae			;      Byte 1 block id - block 0 is file  
80ae			;            Byte 2-15 - File name 
80ae			; 
80ae			;       - to end of block data 
80ae			; 
80ae			 
80ae			; Get ID for the file named in pointer held HL 
80ae			; Returns ID in HL = 255 if no file found 
80ae			 
80ae			storage_getid: 
80ae			 
80ae 22 6a ea			ld (store_tmp1), hl 
80b1			 
80b1				if DEBUG_STORESE 
80b1					DMARK "SGI" 
80b1 f5				push af  
80b2 3a c6 80			ld a, (.dmark)  
80b5 32 62 ee			ld (debug_mark),a  
80b8 3a c7 80			ld a, (.dmark+1)  
80bb 32 63 ee			ld (debug_mark+1),a  
80be 3a c8 80			ld a, (.dmark+2)  
80c1 32 64 ee			ld (debug_mark+2),a  
80c4 18 03			jr .pastdmark  
80c6 ..			.dmark: db "SGI"  
80c9 f1			.pastdmark: pop af  
80ca			endm  
# End of macro DMARK
80ca					CALLMONITOR 
80ca cd 6f ee			call debug_vector  
80cd				endm  
# End of macro CALLMONITOR
80cd				endif 
80cd				; get block 0 and set counter for number of files to scan 
80cd			 
80cd cd 38 82			call storage_get_block_0 
80d0			 
80d0 3a 71 ea			ld a, (store_page) 
80d3 47				ld b, a 
80d4			 
80d4				; get extent 0 of each file id 
80d4			 
80d4				if DEBUG_STORESE 
80d4					DMARK "SGc" 
80d4 f5				push af  
80d5 3a e9 80			ld a, (.dmark)  
80d8 32 62 ee			ld (debug_mark),a  
80db 3a ea 80			ld a, (.dmark+1)  
80de 32 63 ee			ld (debug_mark+1),a  
80e1 3a eb 80			ld a, (.dmark+2)  
80e4 32 64 ee			ld (debug_mark+2),a  
80e7 18 03			jr .pastdmark  
80e9 ..			.dmark: db "SGc"  
80ec f1			.pastdmark: pop af  
80ed			endm  
# End of macro DMARK
80ed					CALLMONITOR 
80ed cd 6f ee			call debug_vector  
80f0				endm  
# End of macro CALLMONITOR
80f0				endif 
80f0 60			.getloop:	ld h, b 
80f1 2e 00				ld l, 0 
80f3 c5					push bc 
80f4			 
80f4 11 71 ea				ld de, store_page 
80f7				if DEBUG_STORESE 
80f7					DMARK "SGr" 
80f7 f5				push af  
80f8 3a 0c 81			ld a, (.dmark)  
80fb 32 62 ee			ld (debug_mark),a  
80fe 3a 0d 81			ld a, (.dmark+1)  
8101 32 63 ee			ld (debug_mark+1),a  
8104 3a 0e 81			ld a, (.dmark+2)  
8107 32 64 ee			ld (debug_mark+2),a  
810a 18 03			jr .pastdmark  
810c ..			.dmark: db "SGr"  
810f f1			.pastdmark: pop af  
8110			endm  
# End of macro DMARK
8110					CALLMONITOR 
8110 cd 6f ee			call debug_vector  
8113				endm  
# End of macro CALLMONITOR
8113				endif 
8113 cd e0 86				call storage_read 
8116 cd 13 8d				call ishlzero 
8119 28 2d				jr z, .gap 
811b					 
811b					; have a file name read. Is it one we want. 
811b			 
811b 2a 6a ea				ld hl, (store_tmp1) 
811e 11 74 ea				ld de, store_page+3   ; file name 
8121			 
8121				if DEBUG_STORESE 
8121					DMARK "SGc" 
8121 f5				push af  
8122 3a 36 81			ld a, (.dmark)  
8125 32 62 ee			ld (debug_mark),a  
8128 3a 37 81			ld a, (.dmark+1)  
812b 32 63 ee			ld (debug_mark+1),a  
812e 3a 38 81			ld a, (.dmark+2)  
8131 32 64 ee			ld (debug_mark+2),a  
8134 18 03			jr .pastdmark  
8136 ..			.dmark: db "SGc"  
8139 f1			.pastdmark: pop af  
813a			endm  
# End of macro DMARK
813a					CALLMONITOR 
813a cd 6f ee			call debug_vector  
813d				endm  
# End of macro CALLMONITOR
813d				endif 
813d cd 88 90				call strcmp 
8140 20 06				jr nz, .gap   ; not this one 
8142			 
8142 c1				        pop bc 
8143			 
8143 26 00				ld h, 0 
8145 68					ld l, b 
8146 18 22				jr .getdone 
8148						 
8148			 
8148			 
8148			 
8148			.gap: 
8148				if DEBUG_STORESE 
8148					DMARK "SGg" 
8148 f5				push af  
8149 3a 5d 81			ld a, (.dmark)  
814c 32 62 ee			ld (debug_mark),a  
814f 3a 5e 81			ld a, (.dmark+1)  
8152 32 63 ee			ld (debug_mark+1),a  
8155 3a 5f 81			ld a, (.dmark+2)  
8158 32 64 ee			ld (debug_mark+2),a  
815b 18 03			jr .pastdmark  
815d ..			.dmark: db "SGg"  
8160 f1			.pastdmark: pop af  
8161			endm  
# End of macro DMARK
8161					CALLMONITOR 
8161 cd 6f ee			call debug_vector  
8164				endm  
# End of macro CALLMONITOR
8164				endif 
8164			 
8164 c1					pop bc 
8165 10 89				djnz .getloop 
8167 21 ff 00				ld hl, 255 
816a			.getdone: 
816a			 
816a				if DEBUG_STORESE 
816a					DMARK "SGe" 
816a f5				push af  
816b 3a 7f 81			ld a, (.dmark)  
816e 32 62 ee			ld (debug_mark),a  
8171 3a 80 81			ld a, (.dmark+1)  
8174 32 63 ee			ld (debug_mark+1),a  
8177 3a 81 81			ld a, (.dmark+2)  
817a 32 64 ee			ld (debug_mark+2),a  
817d 18 03			jr .pastdmark  
817f ..			.dmark: db "SGe"  
8182 f1			.pastdmark: pop af  
8183			endm  
# End of macro DMARK
8183					CALLMONITOR 
8183 cd 6f ee			call debug_vector  
8186				endm  
# End of macro CALLMONITOR
8186				endif 
8186			 
8186 c9				ret 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			; Read Block 
8187			; ---------- 
8187			; 
8187			; With current bank 
8187			;  
8187			; Get block number to read 
8187			; Load physical blocks starting at start block into buffer 
8187			 
8187			; de points to buffer to use 
8187			; hl holds logical block number  
8187			 
8187			storage_read_block: 
8187			 
8187				; TODO bank selection 
8187			 
8187				; for each of the physical blocks read it into the buffer 
8187 06 40			ld b, STORE_BLOCK_PHY 
8189			 
8189				if DEBUG_STORESE 
8189 d5					push de 
818a				endif 
818a				 
818a			.rl1:    
818a			 
818a				; read physical block at hl into de 
818a			        ; increment hl and de to next read position on exit 
818a			 
818a e5				push hl 
818b d5				push de	 
818c c5				push bc 
818d			;	if DEBUG_STORESE 
818d			;		push af 
818d			;		ld a, 'R' 
818d			;		ld (debug_mark),a 
818d			;		pop af 
818d			;		CALLMONITOR 
818d			;	endif 
818d cd ab 80			call se_readbyte 
8190			;	if DEBUG_STORESE 
8190			;		ld a,(spi_portbyte) 
8190			;		ld l, a 
8190			;		push af 
8190			;		ld a, '1' 
8190			;		ld (debug_mark),a 
8190			;		pop af 
8190			;		CALLMONITOR 
8190			;	endif 
8190 c1				pop bc 
8191 d1				pop de 
8192 e1				pop hl 
8193 12				ld (de),a 
8194 23				inc hl 
8195 13				inc de 
8196			 
8196			;	if DEBUG_STORESE 
8196			;		push af 
8196			;		ld a, 'r' 
8196			;		ld (debug_mark),a 
8196			;		pop af 
8196			;		CALLMONITOR 
8196			;	endif 
8196			 
8196 10 f2			djnz .rl1 
8198			 
8198				if DEBUG_STORESE 
8198					DMARK "SRB" 
8198 f5				push af  
8199 3a ad 81			ld a, (.dmark)  
819c 32 62 ee			ld (debug_mark),a  
819f 3a ae 81			ld a, (.dmark+1)  
81a2 32 63 ee			ld (debug_mark+1),a  
81a5 3a af 81			ld a, (.dmark+2)  
81a8 32 64 ee			ld (debug_mark+2),a  
81ab 18 03			jr .pastdmark  
81ad ..			.dmark: db "SRB"  
81b0 f1			.pastdmark: pop af  
81b1			endm  
# End of macro DMARK
81b1 d1					pop de 
81b2			; 
81b2			;		push af 
81b2			;		ld a, 'R' 
81b2			;		ld (debug_mark),a 
81b2			;		pop af 
81b2					CALLMONITOR 
81b2 cd 6f ee			call debug_vector  
81b5				endm  
# End of macro CALLMONITOR
81b5				endif 
81b5 c9				ret	 
81b6				 
81b6			 
81b6			; File Size 
81b6			; --------- 
81b6			; 
81b6			;   hl file id 
81b6			; 
81b6			;  returns in hl the number of blocks 
81b6			 
81b6			storage_file_size: 
81b6 5d				ld e, l 
81b7 16 00			ld d, 0 
81b9 21 40 00			ld hl, STORE_BLOCK_PHY 
81bc					if DEBUG_FORTH_WORDS 
81bc						DMARK "SIZ" 
81bc f5				push af  
81bd 3a d1 81			ld a, (.dmark)  
81c0 32 62 ee			ld (debug_mark),a  
81c3 3a d2 81			ld a, (.dmark+1)  
81c6 32 63 ee			ld (debug_mark+1),a  
81c9 3a d3 81			ld a, (.dmark+2)  
81cc 32 64 ee			ld (debug_mark+2),a  
81cf 18 03			jr .pastdmark  
81d1 ..			.dmark: db "SIZ"  
81d4 f1			.pastdmark: pop af  
81d5			endm  
# End of macro DMARK
81d5						CALLMONITOR 
81d5 cd 6f ee			call debug_vector  
81d8				endm  
# End of macro CALLMONITOR
81d8					endif 
81d8 cd ba 84			call storage_findnextid 
81db			 
81db cd 13 8d			call ishlzero 
81de			;	ld a, l 
81de			;	add h 
81de			;	cp 0 
81de c8				ret z			; block not found so EOF 
81df			 
81df 11 71 ea			ld de, store_page 
81e2 cd 87 81			call storage_read_block 
81e5			 
81e5 3a 73 ea			ld a, (store_page+2)	 ; get extent count 
81e8 6f				ld l, a 
81e9 26 00			ld h, 0 
81eb c9			 	ret 
81ec			 
81ec			 
81ec			; Write Block 
81ec			; ----------- 
81ec			; 
81ec			; With current bank 
81ec			;  
81ec			; Get block number to write 
81ec			; Write physical blocks starting at start block from buffer 
81ec			  
81ec			storage_write_block: 
81ec				; TODO bank selection 
81ec			 
81ec				; for each of the physical blocks read it into the buffer 
81ec 06 40			ld b, STORE_BLOCK_PHY 
81ee			 
81ee				if DEBUG_STORESE 
81ee					DMARK "SWB" 
81ee f5				push af  
81ef 3a 03 82			ld a, (.dmark)  
81f2 32 62 ee			ld (debug_mark),a  
81f5 3a 04 82			ld a, (.dmark+1)  
81f8 32 63 ee			ld (debug_mark+1),a  
81fb 3a 05 82			ld a, (.dmark+2)  
81fe 32 64 ee			ld (debug_mark+2),a  
8201 18 03			jr .pastdmark  
8203 ..			.dmark: db "SWB"  
8206 f1			.pastdmark: pop af  
8207			endm  
# End of macro DMARK
8207			 
8207					;push af 
8207					;ld a, 'W' 
8207					;ld (debug_mark),a 
8207					;pop af 
8207					CALLMONITOR 
8207 cd 6f ee			call debug_vector  
820a				endm  
# End of macro CALLMONITOR
820a				endif 
820a			 
820a			; might not be working 
820a			;	call se_writepage 
820a			 
820a			;	ret 
820a			; 
820a			 
820a			 
820a			 
820a			.wl1:    
820a			 
820a				; read physical block at hl into de 
820a			        ; increment hl and de to next read position on exit 
820a			 
820a e5				push hl 
820b d5				push de	 
820c c5				push bc 
820d 1a				ld a,(de) 
820e				;if DEBUG_STORESE 
820e			;		push af 
820e			;		ld a, 'W' 
820e			;		ld (debug_mark),a 
820e			;		pop af 
820e			;		CALLMONITOR 
820e			;	endif 
820e cd ac 80			call se_writebyte 
8211			;	call delay250ms 
8211 00				nop 
8212 00				nop 
8213 00				nop 
8214			;	if DEBUG_STORESE 
8214			;		push af 
8214			;		ld a, 'w' 
8214			;		ld (debug_mark),a 
8214			;		pop af 
8214			;		CALLMONITOR 
8214			;	endif 
8214 c1				pop bc 
8215 d1				pop de 
8216 e1				pop hl 
8217 23				inc hl 
8218 13				inc de 
8219			 
8219			 
8219 10 ef			djnz .wl1 
821b			 
821b				if DEBUG_STORESE 
821b					DMARK "SW2" 
821b f5				push af  
821c 3a 30 82			ld a, (.dmark)  
821f 32 62 ee			ld (debug_mark),a  
8222 3a 31 82			ld a, (.dmark+1)  
8225 32 63 ee			ld (debug_mark+1),a  
8228 3a 32 82			ld a, (.dmark+2)  
822b 32 64 ee			ld (debug_mark+2),a  
822e 18 03			jr .pastdmark  
8230 ..			.dmark: db "SW2"  
8233 f1			.pastdmark: pop af  
8234			endm  
# End of macro DMARK
8234			 
8234					;push af 
8234					;ld a, 'W' 
8234					;ld (debug_mark),a 
8234					;pop af 
8234					CALLMONITOR 
8234 cd 6f ee			call debug_vector  
8237				endm  
# End of macro CALLMONITOR
8237				endif 
8237 c9				ret	 
8238			 
8238			; Init bank 
8238			; --------- 
8238			; 
8238			; With current bank 
8238			; 
8238			; Setup block 0 config 
8238			;     Set 0 file id counter 
8238			;     Set formatted byte pattern 
8238			;     Zero out bank label 
8238			;      
8238			; For every logical block write 0-1 byte as null 
8238			 
8238			storage_get_block_0: 
8238			 
8238				; TODO check presence 
8238			 
8238				; get block 0 config 
8238			 
8238 21 00 00			ld hl, 0 
823b 11 71 ea			ld de, store_page 
823e cd 87 81			call storage_read_block 
8241			 
8241				if DEBUG_STORESE 
8241					DMARK "SB0" 
8241 f5				push af  
8242 3a 56 82			ld a, (.dmark)  
8245 32 62 ee			ld (debug_mark),a  
8248 3a 57 82			ld a, (.dmark+1)  
824b 32 63 ee			ld (debug_mark+1),a  
824e 3a 58 82			ld a, (.dmark+2)  
8251 32 64 ee			ld (debug_mark+2),a  
8254 18 03			jr .pastdmark  
8256 ..			.dmark: db "SB0"  
8259 f1			.pastdmark: pop af  
825a			endm  
# End of macro DMARK
825a 11 71 ea				ld de, store_page 
825d			;		push af 
825d			;		ld a, 'i' 
825d			;		ld (debug_mark),a 
825d			;		pop af 
825d					CALLMONITOR 
825d cd 6f ee			call debug_vector  
8260				endm  
# End of macro CALLMONITOR
8260				endif 
8260			 
8260				; is this area formatted? 
8260			 
8260			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8260 2a 72 ea			ld hl, (store_page+1) 
8263 3e 80			ld a,0x80 
8265 bd				cp l 
8266 20 22			jr nz, .ininotformatted 
8268				; do a double check 
8268 3e 27			ld a, 0x27 
826a bc				cp h 
826b 20 1d			jr nz, .ininotformatted 
826d			 
826d				; formatted then 
826d			 
826d				if DEBUG_STORESE 
826d					DMARK "SB1" 
826d f5				push af  
826e 3a 82 82			ld a, (.dmark)  
8271 32 62 ee			ld (debug_mark),a  
8274 3a 83 82			ld a, (.dmark+1)  
8277 32 63 ee			ld (debug_mark+1),a  
827a 3a 84 82			ld a, (.dmark+2)  
827d 32 64 ee			ld (debug_mark+2),a  
8280 18 03			jr .pastdmark  
8282 ..			.dmark: db "SB1"  
8285 f1			.pastdmark: pop af  
8286			endm  
# End of macro DMARK
8286					;push af 
8286					;ld a, 'I' 
8286					;ld (debug_mark),a 
8286					;pop af 
8286					CALLMONITOR 
8286 cd 6f ee			call debug_vector  
8289				endm  
# End of macro CALLMONITOR
8289				endif 
8289 c9				ret 
828a			 
828a			.ininotformatted: 
828a				; bank not formatted so poke various bits to make sure 
828a			 
828a				if DEBUG_STORESE 
828a					DMARK "SB2" 
828a f5				push af  
828b 3a 9f 82			ld a, (.dmark)  
828e 32 62 ee			ld (debug_mark),a  
8291 3a a0 82			ld a, (.dmark+1)  
8294 32 63 ee			ld (debug_mark+1),a  
8297 3a a1 82			ld a, (.dmark+2)  
829a 32 64 ee			ld (debug_mark+2),a  
829d 18 03			jr .pastdmark  
829f ..			.dmark: db "SB2"  
82a2 f1			.pastdmark: pop af  
82a3			endm  
# End of macro DMARK
82a3					;push af 
82a3					;ld a, 'f' 
82a3					;ld (debug_mark),a 
82a3					;pop af 
82a3					CALLMONITOR 
82a3 cd 6f ee			call debug_vector  
82a6				endm  
# End of macro CALLMONITOR
82a6				endif 
82a6			 
82a6 cd c3 89			call storage_clear_page 
82a9			 
82a9 21 71 ea			ld hl, store_page 
82ac 3e 00			ld a, 0 
82ae				 
82ae 77				ld (hl),a   ; reset file counter 
82af			 
82af 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82b2 22 72 ea		 	ld (store_page+1), hl	 
82b5			 
82b5				; set default label 
82b5			 
82b5 21 51 83			ld hl, .defaultbanklabl 
82b8 11 74 ea		 	ld de, store_page+3 
82bb 01 0f 00			ld bc, 15 
82be ed b0			ldir 
82c0			 
82c0				; Append the current bank id 
82c0 21 7d ea			ld hl, store_page+3+9 
82c3 3a 56 ea			ld a, (spi_device_id) 
82c6 77				ld (hl), a 
82c7			 
82c7				; save default page 0 
82c7			 
82c7 21 00 00			ld hl, 0 
82ca 11 71 ea			ld de, store_page 
82cd				if DEBUG_STORESE 
82cd					DMARK "SB3" 
82cd f5				push af  
82ce 3a e2 82			ld a, (.dmark)  
82d1 32 62 ee			ld (debug_mark),a  
82d4 3a e3 82			ld a, (.dmark+1)  
82d7 32 63 ee			ld (debug_mark+1),a  
82da 3a e4 82			ld a, (.dmark+2)  
82dd 32 64 ee			ld (debug_mark+2),a  
82e0 18 03			jr .pastdmark  
82e2 ..			.dmark: db "SB3"  
82e5 f1			.pastdmark: pop af  
82e6			endm  
# End of macro DMARK
82e6			;		push af 
82e6			;		ld a, 'F' 
82e6			;		ld (debug_mark),a 
82e6			;		pop af 
82e6					CALLMONITOR 
82e6 cd 6f ee			call debug_vector  
82e9				endm  
# End of macro CALLMONITOR
82e9				endif 
82e9 cd ec 81			call storage_write_block 
82ec				if DEBUG_STORESE 
82ec					DMARK "SB4" 
82ec f5				push af  
82ed 3a 01 83			ld a, (.dmark)  
82f0 32 62 ee			ld (debug_mark),a  
82f3 3a 02 83			ld a, (.dmark+1)  
82f6 32 63 ee			ld (debug_mark+1),a  
82f9 3a 03 83			ld a, (.dmark+2)  
82fc 32 64 ee			ld (debug_mark+2),a  
82ff 18 03			jr .pastdmark  
8301 ..			.dmark: db "SB4"  
8304 f1			.pastdmark: pop af  
8305			endm  
# End of macro DMARK
8305			;		push af 
8305			;		ld a, '>' 
8305			;		ld (debug_mark),a 
8305			;		pop af 
8305					CALLMONITOR 
8305 cd 6f ee			call debug_vector  
8308				endm  
# End of macro CALLMONITOR
8308				endif 
8308			 
8308 00				nop 
8309 00				nop 
830a 00				nop 
830b			 
830b				; now set 0 in every page to mark as a free block 
830b			 
830b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
830d 21 40 00			ld hl, STORE_BLOCK_PHY 
8310			 
8310 3e 00		.setmark1:   	ld a,0 
8312 e5					push hl 
8313 c5					push bc 
8314 cd ac 80				call se_writebyte 
8317 3e 0a			ld a, 10 
8319 cd e5 89			call aDelayInMS 
831c 23				inc hl 
831d cd ac 80				call se_writebyte 
8320 3e 0a			ld a, 10 
8322 cd e5 89			call aDelayInMS 
8325 2b				dec hl 
8326 c1					pop bc 
8327 e1					pop hl 
8328 3e 40				ld a, STORE_BLOCK_PHY 
832a cd ea 8c				call addatohl 
832d 10 e1				djnz .setmark1 
832f			 
832f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8331 3e 00		.setmark2:   	ld a,0 
8333 e5					push hl 
8334 c5					push bc 
8335 cd ac 80				call se_writebyte 
8338 3e 0a			ld a, 10 
833a cd e5 89			call aDelayInMS 
833d 23				inc hl 
833e cd ac 80				call se_writebyte 
8341 3e 0a			ld a, 10 
8343 cd e5 89			call aDelayInMS 
8346 2b				dec hl 
8347 c1					pop bc 
8348 e1					pop hl 
8349 3e 40				ld a, STORE_BLOCK_PHY 
834b cd ea 8c				call addatohl 
834e 10 e1				djnz .setmark2 
8350			 
8350					 
8350			 
8350			 
8350 c9				ret 
8351			 
8351			 
8351			 
8351			 
8351 .. 00		.defaultbanklabl:   db "BankLabel_",0 
835c			 
835c			 
835c			 
835c			; Label Bank 
835c			; ---------- 
835c			; 
835c			; With current bank 
835c			; Read block 0 
835c			; Set label 
835c			; Write block 0 
835c			 
835c			; label str pointer in hl 
835c			 
835c			storage_label:     
835c			 
835c				if DEBUG_STORESE 
835c					DMARK "LBL" 
835c f5				push af  
835d 3a 71 83			ld a, (.dmark)  
8360 32 62 ee			ld (debug_mark),a  
8363 3a 72 83			ld a, (.dmark+1)  
8366 32 63 ee			ld (debug_mark+1),a  
8369 3a 73 83			ld a, (.dmark+2)  
836c 32 64 ee			ld (debug_mark+2),a  
836f 18 03			jr .pastdmark  
8371 ..			.dmark: db "LBL"  
8374 f1			.pastdmark: pop af  
8375			endm  
# End of macro DMARK
8375					CALLMONITOR 
8375 cd 6f ee			call debug_vector  
8378				endm  
# End of macro CALLMONITOR
8378				endif 
8378			 
8378 e5				push hl 
8379			 
8379 cd 38 82			call storage_get_block_0 
837c			 
837c				; set default label 
837c			 
837c e1				pop hl 
837d			 
837d 11 74 ea		 	ld de, store_page+3 
8380 01 0f 00			ld bc, 15 
8383				if DEBUG_STORESE 
8383					DMARK "LB3" 
8383 f5				push af  
8384 3a 98 83			ld a, (.dmark)  
8387 32 62 ee			ld (debug_mark),a  
838a 3a 99 83			ld a, (.dmark+1)  
838d 32 63 ee			ld (debug_mark+1),a  
8390 3a 9a 83			ld a, (.dmark+2)  
8393 32 64 ee			ld (debug_mark+2),a  
8396 18 03			jr .pastdmark  
8398 ..			.dmark: db "LB3"  
839b f1			.pastdmark: pop af  
839c			endm  
# End of macro DMARK
839c					CALLMONITOR 
839c cd 6f ee			call debug_vector  
839f				endm  
# End of macro CALLMONITOR
839f				endif 
839f ed b0			ldir 
83a1				; save default page 0 
83a1			 
83a1 21 00 00			ld hl, 0 
83a4 11 71 ea			ld de, store_page 
83a7				if DEBUG_STORESE 
83a7					DMARK "LBW" 
83a7 f5				push af  
83a8 3a bc 83			ld a, (.dmark)  
83ab 32 62 ee			ld (debug_mark),a  
83ae 3a bd 83			ld a, (.dmark+1)  
83b1 32 63 ee			ld (debug_mark+1),a  
83b4 3a be 83			ld a, (.dmark+2)  
83b7 32 64 ee			ld (debug_mark+2),a  
83ba 18 03			jr .pastdmark  
83bc ..			.dmark: db "LBW"  
83bf f1			.pastdmark: pop af  
83c0			endm  
# End of macro DMARK
83c0					CALLMONITOR 
83c0 cd 6f ee			call debug_vector  
83c3				endm  
# End of macro CALLMONITOR
83c3				endif 
83c3 cd ec 81			call storage_write_block 
83c6			 
83c6 c9				ret 
83c7			 
83c7			 
83c7			 
83c7			; Read Block 0 - Config 
83c7			; --------------------- 
83c7			; 
83c7			; With current bank 
83c7			; Call presence test 
83c7			;    If not present format/init bank  
83c7			; Read block 0  
83c7			;  
83c7			 
83c7			 
83c7			; Dir 
83c7			; --- 
83c7			; 
83c7			; With current bank 
83c7			; Load Block 0 Config 
83c7			; Get max file id number 
83c7			; For each logical block 
83c7			;    Read block read byte 2 
83c7			;      if first block of file 
83c7			;         Display file name 
83c7			;         Display type flags for file 
83c7			;        
83c7			 
83c7			; moving to words as this requires stack control 
83c7			 
83c7			 
83c7			; Delete File 
83c7			; ----------- 
83c7			; 
83c7			; With current bank 
83c7			; 
83c7			; Load Block 0 Config 
83c7			; Get max file id number 
83c7			; For each logical block 
83c7			;    Read block file id 
83c7			;      If first block of file and dont have file id 
83c7			;         if file to delete 
83c7			;         Save file id 
83c7			;         Null file id 
83c7			;         Write this block back 
83c7			;      If file id is one saved 
83c7			;         Null file id 
83c7			;         Write this block back 
83c7			 
83c7			 
83c7			.se_done: 
83c7 e1				pop hl 
83c8 c9				ret 
83c9			 
83c9			storage_erase: 
83c9			 
83c9				; hl contains the file id 
83c9			 
83c9 5d				ld e, l 
83ca 16 00			ld d, 0 
83cc 21 40 00			ld hl, STORE_BLOCK_PHY 
83cf					if DEBUG_FORTH_WORDS 
83cf						DMARK "ERA" 
83cf f5				push af  
83d0 3a e4 83			ld a, (.dmark)  
83d3 32 62 ee			ld (debug_mark),a  
83d6 3a e5 83			ld a, (.dmark+1)  
83d9 32 63 ee			ld (debug_mark+1),a  
83dc 3a e6 83			ld a, (.dmark+2)  
83df 32 64 ee			ld (debug_mark+2),a  
83e2 18 03			jr .pastdmark  
83e4 ..			.dmark: db "ERA"  
83e7 f1			.pastdmark: pop af  
83e8			endm  
# End of macro DMARK
83e8						CALLMONITOR 
83e8 cd 6f ee			call debug_vector  
83eb				endm  
# End of macro CALLMONITOR
83eb					endif 
83eb cd ba 84			call storage_findnextid 
83ee cd 13 8d			call ishlzero 
83f1 c8				ret z 
83f2			 
83f2 e5				push hl 
83f3			 
83f3				; TODO check file not found 
83f3			 
83f3 11 71 ea			ld de, store_page 
83f6 cd 87 81			call storage_read_block 
83f9			 
83f9 cd 13 8d			call ishlzero 
83fc ca c7 83			jp z,.se_done 
83ff			 
83ff					if DEBUG_FORTH_WORDS 
83ff						DMARK "ER1" 
83ff f5				push af  
8400 3a 14 84			ld a, (.dmark)  
8403 32 62 ee			ld (debug_mark),a  
8406 3a 15 84			ld a, (.dmark+1)  
8409 32 63 ee			ld (debug_mark+1),a  
840c 3a 16 84			ld a, (.dmark+2)  
840f 32 64 ee			ld (debug_mark+2),a  
8412 18 03			jr .pastdmark  
8414 ..			.dmark: db "ER1"  
8417 f1			.pastdmark: pop af  
8418			endm  
# End of macro DMARK
8418						CALLMONITOR 
8418 cd 6f ee			call debug_vector  
841b				endm  
# End of macro CALLMONITOR
841b					endif 
841b 3a 71 ea			ld a, (store_page)	; get file id 
841e 32 65 ea			ld (store_tmpid), a 
8421			 
8421 3a 73 ea			ld a, (store_page+2)    ; get count of extends 
8424 32 64 ea			ld (store_tmpext), a 
8427			 
8427				; wipe file header 
8427			 
8427 e1				pop hl 
8428 3e 00			ld a, 0 
842a 32 71 ea			ld (store_page), a 
842d 32 72 ea			ld (store_page+1),a 
8430 11 71 ea			ld de, store_page 
8433					if DEBUG_FORTH_WORDS 
8433						DMARK "ER2" 
8433 f5				push af  
8434 3a 48 84			ld a, (.dmark)  
8437 32 62 ee			ld (debug_mark),a  
843a 3a 49 84			ld a, (.dmark+1)  
843d 32 63 ee			ld (debug_mark+1),a  
8440 3a 4a 84			ld a, (.dmark+2)  
8443 32 64 ee			ld (debug_mark+2),a  
8446 18 03			jr .pastdmark  
8448 ..			.dmark: db "ER2"  
844b f1			.pastdmark: pop af  
844c			endm  
# End of macro DMARK
844c						CALLMONITOR 
844c cd 6f ee			call debug_vector  
844f				endm  
# End of macro CALLMONITOR
844f					endif 
844f cd ec 81			call storage_write_block 
8452			 
8452			 
8452				; wipe file extents 
8452			 
8452 3a 64 ea			ld a, (store_tmpext) 
8455 47				ld b, a 
8456			 
8456			.eraext:	  
8456 c5				push bc 
8457			 
8457 21 40 00			ld hl, STORE_BLOCK_PHY 
845a 3a 65 ea			ld a,(store_tmpid) 
845d 5f				ld e, a 
845e 50				ld d, b	 
845f					if DEBUG_FORTH_WORDS 
845f						DMARK "ER3" 
845f f5				push af  
8460 3a 74 84			ld a, (.dmark)  
8463 32 62 ee			ld (debug_mark),a  
8466 3a 75 84			ld a, (.dmark+1)  
8469 32 63 ee			ld (debug_mark+1),a  
846c 3a 76 84			ld a, (.dmark+2)  
846f 32 64 ee			ld (debug_mark+2),a  
8472 18 03			jr .pastdmark  
8474 ..			.dmark: db "ER3"  
8477 f1			.pastdmark: pop af  
8478			endm  
# End of macro DMARK
8478						CALLMONITOR 
8478 cd 6f ee			call debug_vector  
847b				endm  
# End of macro CALLMONITOR
847b					endif 
847b cd ba 84			call storage_findnextid 
847e cd 13 8d			call ishlzero 
8481 ca c7 83			jp z,.se_done 
8484			 
8484 e5				push hl 
8485 11 71 ea			ld de, store_page 
8488 cd 87 81			call storage_read_block 
848b			 
848b				; free block	 
848b			 
848b 3e 00			ld a, 0 
848d 32 71 ea			ld (store_page), a 
8490 32 72 ea			ld (store_page+1),a 
8493 11 71 ea			ld de, store_page 
8496 e1				pop hl 
8497					if DEBUG_FORTH_WORDS 
8497						DMARK "ER4" 
8497 f5				push af  
8498 3a ac 84			ld a, (.dmark)  
849b 32 62 ee			ld (debug_mark),a  
849e 3a ad 84			ld a, (.dmark+1)  
84a1 32 63 ee			ld (debug_mark+1),a  
84a4 3a ae 84			ld a, (.dmark+2)  
84a7 32 64 ee			ld (debug_mark+2),a  
84aa 18 03			jr .pastdmark  
84ac ..			.dmark: db "ER4"  
84af f1			.pastdmark: pop af  
84b0			endm  
# End of macro DMARK
84b0						CALLMONITOR 
84b0 cd 6f ee			call debug_vector  
84b3				endm  
# End of macro CALLMONITOR
84b3					endif 
84b3 cd ec 81			call storage_write_block 
84b6			 
84b6 c1				pop bc 
84b7 10 9d			djnz .eraext 
84b9			 
84b9 c9				ret 
84ba			 
84ba			 
84ba			; Find Free Block 
84ba			; --------------- 
84ba			; 
84ba			; With current bank 
84ba			;  
84ba			; From given starting logical block 
84ba			;    Read block  
84ba			;    If no file id 
84ba			;         Return block id 
84ba			 
84ba			 
84ba			; hl starting page number 
84ba			; hl contains free page number or zero if no pages free 
84ba			; e contains the file id to locate 
84ba			; d contains the block number 
84ba			 
84ba			; TODO change to find file id and use zero for free block 
84ba			 
84ba			storage_findnextid: 
84ba			 
84ba				; now locate first 0 page to mark as a free block 
84ba			 
84ba 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84bc			;	ld hl, STORE_BLOCK_PHY 
84bc			 
84bc					if DEBUG_FORTH_WORDS 
84bc					DMARK "FNI" 
84bc f5				push af  
84bd 3a d1 84			ld a, (.dmark)  
84c0 32 62 ee			ld (debug_mark),a  
84c3 3a d2 84			ld a, (.dmark+1)  
84c6 32 63 ee			ld (debug_mark+1),a  
84c9 3a d3 84			ld a, (.dmark+2)  
84cc 32 64 ee			ld (debug_mark+2),a  
84cf 18 03			jr .pastdmark  
84d1 ..			.dmark: db "FNI"  
84d4 f1			.pastdmark: pop af  
84d5			endm  
# End of macro DMARK
84d5						CALLMONITOR 
84d5 cd 6f ee			call debug_vector  
84d8				endm  
# End of macro CALLMONITOR
84d8					endif 
84d8			.ff1:   	 
84d8 e5					push hl 
84d9 c5					push bc 
84da d5					push de 
84db cd ab 80				call se_readbyte 
84de 5f					ld e,a 
84df 23					inc hl 
84e0 cd ab 80				call se_readbyte 
84e3 57					ld d, a 
84e4 e1					pop hl 
84e5 e5					push hl 
84e6 cd 08 8d				call cmp16 
84e9 28 49				jr z, .fffound 
84eb			 
84eb d1					pop de 
84ec c1					pop bc 
84ed e1					pop hl 
84ee			 
84ee					; is found? 
84ee					;cp e 
84ee					;ret z 
84ee			 
84ee 3e 40				ld a, STORE_BLOCK_PHY 
84f0 cd ea 8c				call addatohl 
84f3 10 e3				djnz .ff1 
84f5			 
84f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84f7			.ff2:   	 
84f7			 
84f7 e5					push hl 
84f8 c5					push bc 
84f9 d5					push de 
84fa cd ab 80				call se_readbyte 
84fd 5f					ld e,a 
84fe 23					inc hl 
84ff cd ab 80				call se_readbyte 
8502 57					ld d, a 
8503			 
8503 e1					pop hl 
8504 e5					push hl 
8505 cd 08 8d				call cmp16 
8508 28 2a				jr z, .fffound 
850a			 
850a d1					pop de 
850b c1					pop bc 
850c e1					pop hl 
850d					; is found? 
850d					;cp e 
850d					;ret z 
850d			 
850d 3e 40				ld a, STORE_BLOCK_PHY 
850f cd ea 8c				call addatohl 
8512 10 e3				djnz .ff2 
8514			 
8514			 
8514					if DEBUG_FORTH_WORDS 
8514					DMARK "FN-" 
8514 f5				push af  
8515 3a 29 85			ld a, (.dmark)  
8518 32 62 ee			ld (debug_mark),a  
851b 3a 2a 85			ld a, (.dmark+1)  
851e 32 63 ee			ld (debug_mark+1),a  
8521 3a 2b 85			ld a, (.dmark+2)  
8524 32 64 ee			ld (debug_mark+2),a  
8527 18 03			jr .pastdmark  
8529 ..			.dmark: db "FN-"  
852c f1			.pastdmark: pop af  
852d			endm  
# End of macro DMARK
852d					;	push af 
852d					;	ld a, 'n' 
852d					;	ld (debug_mark),a 
852d					;	pop af 
852d						CALLMONITOR 
852d cd 6f ee			call debug_vector  
8530				endm  
# End of macro CALLMONITOR
8530					endif 
8530				; no free marks! 
8530 21 00 00				ld hl, 0 
8533 c9				ret 
8534			.fffound: 
8534				 
8534			 
8534 d1					pop de 
8535 c1					pop bc 
8536 e1					pop hl 
8537					if DEBUG_FORTH_WORDS 
8537					DMARK "FNF" 
8537 f5				push af  
8538 3a 4c 85			ld a, (.dmark)  
853b 32 62 ee			ld (debug_mark),a  
853e 3a 4d 85			ld a, (.dmark+1)  
8541 32 63 ee			ld (debug_mark+1),a  
8544 3a 4e 85			ld a, (.dmark+2)  
8547 32 64 ee			ld (debug_mark+2),a  
854a 18 03			jr .pastdmark  
854c ..			.dmark: db "FNF"  
854f f1			.pastdmark: pop af  
8550			endm  
# End of macro DMARK
8550					;	push af 
8550					;	ld a, 'n' 
8550					;	ld (debug_mark),a 
8550					;	pop af 
8550						CALLMONITOR 
8550 cd 6f ee			call debug_vector  
8553				endm  
# End of macro CALLMONITOR
8553					endif 
8553 c9				ret 
8554			 
8554			 
8554			 
8554			; Free Space 
8554			; ---------- 
8554			; 
8554			; With current bank 
8554			; 
8554			; Set block count to zero 
8554			; Starting with first logical block 
8554			;      Find free block  
8554			;      If block id given, increment block count 
8554			; 
8554			;  
8554			 
8554			 
8554			; hl contains count of free blocks 
8554			 
8554			storage_freeblocks: 
8554			 
8554				; now locate first 0 page to mark as a free block 
8554			 
8554 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8556 21 40 00			ld hl, STORE_BLOCK_PHY 
8559 11 00 00			ld de, 0 
855c			 
855c			.fb1:   	 
855c e5					push hl 
855d c5					push bc 
855e d5					push de 
855f cd ab 80				call se_readbyte 
8562 d1					pop de 
8563 c1					pop bc 
8564 e1					pop hl 
8565			 
8565					; is free? 
8565 fe 00				cp 0 
8567 20 01				jr nz, .ff1cont 
8569 13					inc de 
856a			 
856a			.ff1cont: 
856a			 
856a			 
856a 3e 40				ld a, STORE_BLOCK_PHY 
856c cd ea 8c				call addatohl 
856f 10 eb				djnz .fb1 
8571			 
8571 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8573			.fb2:   	 
8573 e5					push hl 
8574 c5					push bc 
8575 d5					push de 
8576 cd ab 80				call se_readbyte 
8579 d1					pop de 
857a c1					pop bc 
857b e1					pop hl 
857c			 
857c					; is free? 
857c fe 00				cp 0 
857e 20 01				jr nz, .ff2cont 
8580 13					inc de 
8581			 
8581			.ff2cont: 
8581			 
8581 3e 40				ld a, STORE_BLOCK_PHY 
8583 cd ea 8c				call addatohl 
8586 10 eb				djnz .fb2 
8588			 
8588 eb				ex de, hl 
8589 c9				ret 
858a			 
858a			; Get File ID 
858a			; ----------- 
858a			; 
858a			; With current bank 
858a			;  
858a			; Load Block 0 Config 
858a			; Get max file id number 
858a			; For each logical block 
858a			;    Read block file id 
858a			;      If first block of file and dont have file id 
858a			;         if file get id and exit 
858a			 
858a			 
858a			 
858a			 
858a			; Create File 
858a			; ----------- 
858a			; 
858a			; With current bank  
858a			; Load Block 0 Config 
858a			; Get max file id number 
858a			; Increment file id number 
858a			; Save Config 
858a			; Find free block 
858a			; Set buffer with file name and file id 
858a			; Write buffer to free block  
858a			 
858a			 
858a			; hl point to file name 
858a			; hl returns file id 
858a			 
858a			; file format: 
858a			; byte 0 - file id 
858a			; byte 1 - extent number 
858a			; byte 2-> data 
858a			 
858a			; format for extent number 0: 
858a			; 
858a			; byte 0 - file id 
858a			; byte 1 - extent 0 
858a			; byte 2 - extent count 
858a			; byte 3 -> file name and meta data 
858a			 
858a			 
858a			storage_create: 
858a				if DEBUG_STORESE 
858a					DMARK "SCR" 
858a f5				push af  
858b 3a 9f 85			ld a, (.dmark)  
858e 32 62 ee			ld (debug_mark),a  
8591 3a a0 85			ld a, (.dmark+1)  
8594 32 63 ee			ld (debug_mark+1),a  
8597 3a a1 85			ld a, (.dmark+2)  
859a 32 64 ee			ld (debug_mark+2),a  
859d 18 03			jr .pastdmark  
859f ..			.dmark: db "SCR"  
85a2 f1			.pastdmark: pop af  
85a3			endm  
# End of macro DMARK
85a3					CALLMONITOR 
85a3 cd 6f ee			call debug_vector  
85a6				endm  
# End of macro CALLMONITOR
85a6				endif 
85a6			 
85a6 e5				push hl		; save file name pointer 
85a7			 
85a7 cd 38 82			call storage_get_block_0 
85aa			 
85aa 3a 71 ea			ld a,(store_page)	; get current file id 
85ad 3c				inc a 
85ae 32 71 ea			ld (store_page),a 
85b1				 
85b1 32 65 ea			ld (store_tmpid),a			; save id 
85b4			 
85b4 21 00 00			ld hl, 0 
85b7 11 71 ea			ld de, store_page 
85ba				if DEBUG_STORESE 
85ba					DMARK "SCw" 
85ba f5				push af  
85bb 3a cf 85			ld a, (.dmark)  
85be 32 62 ee			ld (debug_mark),a  
85c1 3a d0 85			ld a, (.dmark+1)  
85c4 32 63 ee			ld (debug_mark+1),a  
85c7 3a d1 85			ld a, (.dmark+2)  
85ca 32 64 ee			ld (debug_mark+2),a  
85cd 18 03			jr .pastdmark  
85cf ..			.dmark: db "SCw"  
85d2 f1			.pastdmark: pop af  
85d3			endm  
# End of macro DMARK
85d3					CALLMONITOR 
85d3 cd 6f ee			call debug_vector  
85d6				endm  
# End of macro CALLMONITOR
85d6				endif 
85d6 cd ec 81			call storage_write_block	 ; save update 
85d9			 
85d9				if DEBUG_STORESE 
85d9 11 71 ea				ld de, store_page 
85dc					DMARK "SCC" 
85dc f5				push af  
85dd 3a f1 85			ld a, (.dmark)  
85e0 32 62 ee			ld (debug_mark),a  
85e3 3a f2 85			ld a, (.dmark+1)  
85e6 32 63 ee			ld (debug_mark+1),a  
85e9 3a f3 85			ld a, (.dmark+2)  
85ec 32 64 ee			ld (debug_mark+2),a  
85ef 18 03			jr .pastdmark  
85f1 ..			.dmark: db "SCC"  
85f4 f1			.pastdmark: pop af  
85f5			endm  
# End of macro DMARK
85f5					CALLMONITOR 
85f5 cd 6f ee			call debug_vector  
85f8				endm  
# End of macro CALLMONITOR
85f8				endif 
85f8				;  
85f8				 
85f8 21 40 00			ld hl, STORE_BLOCK_PHY 
85fb 11 00 00			ld de, 0 
85fe cd ba 84			call storage_findnextid 
8601			 
8601 22 5c ea			ld (store_tmppageid), hl    ; save page to use  
8604			 
8604				; TODO detect 0 = no spare blocks 
8604			 
8604				; hl now contains the free page to use for the file header page 
8604			 
8604				if DEBUG_STORESE 
8604				DMARK "SCF" 
8604 f5				push af  
8605 3a 19 86			ld a, (.dmark)  
8608 32 62 ee			ld (debug_mark),a  
860b 3a 1a 86			ld a, (.dmark+1)  
860e 32 63 ee			ld (debug_mark+1),a  
8611 3a 1b 86			ld a, (.dmark+2)  
8614 32 64 ee			ld (debug_mark+2),a  
8617 18 03			jr .pastdmark  
8619 ..			.dmark: db "SCF"  
861c f1			.pastdmark: pop af  
861d			endm  
# End of macro DMARK
861d					CALLMONITOR 
861d cd 6f ee			call debug_vector  
8620				endm  
# End of macro CALLMONITOR
8620				endif 
8620			 
8620 22 5c ea			ld (store_tmppageid), hl 
8623				 
8623 3a 65 ea			ld a,(store_tmpid)    ; get file id 
8626			;	ld a, (store_filecache)			; save to cache 
8626			 
8626 32 71 ea			ld (store_page),a    ; set page id 
8629 3e 00			ld a, 0			 ; extent 0 is file header 
862b 32 72 ea			ld (store_page+1), a   ; set file extent 
862e			 
862e 32 73 ea			ld (store_page+2), a   ; extent count for the file 
8631			 
8631			;	inc hl 		; init block 0 of file 
8631			;	inc hl   		; skip file and extent id 
8631			 ;       ld a, 0 
8631			;	ld (hl),a 
8631			;	ld a, (store_filecache+1)  	; save to cache 
8631			 
8631			;	inc hl    ; file name 
8631				 
8631				 
8631 11 74 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8634				if DEBUG_STORESE 
8634					DMARK "SCc" 
8634 f5				push af  
8635 3a 49 86			ld a, (.dmark)  
8638 32 62 ee			ld (debug_mark),a  
863b 3a 4a 86			ld a, (.dmark+1)  
863e 32 63 ee			ld (debug_mark+1),a  
8641 3a 4b 86			ld a, (.dmark+2)  
8644 32 64 ee			ld (debug_mark+2),a  
8647 18 03			jr .pastdmark  
8649 ..			.dmark: db "SCc"  
864c f1			.pastdmark: pop af  
864d			endm  
# End of macro DMARK
864d					CALLMONITOR 
864d cd 6f ee			call debug_vector  
8650				endm  
# End of macro CALLMONITOR
8650				endif 
8650 e1				pop hl    ; get zero term string 
8651 e5				push hl 
8652 3e 00			ld a, 0 
8654 cd 5b 90			call strlent 
8657 23				inc hl   ; cover zero term 
8658 06 00			ld b,0 
865a 4d				ld c,l 
865b e1				pop hl 
865c				;ex de, hl 
865c				if DEBUG_STORESE 
865c					DMARK "SCa" 
865c f5				push af  
865d 3a 71 86			ld a, (.dmark)  
8660 32 62 ee			ld (debug_mark),a  
8663 3a 72 86			ld a, (.dmark+1)  
8666 32 63 ee			ld (debug_mark+1),a  
8669 3a 73 86			ld a, (.dmark+2)  
866c 32 64 ee			ld (debug_mark+2),a  
866f 18 03			jr .pastdmark  
8671 ..			.dmark: db "SCa"  
8674 f1			.pastdmark: pop af  
8675			endm  
# End of macro DMARK
8675					;push af 
8675					;ld a, 'a' 
8675					;ld (debug_mark),a 
8675					;pop af 
8675					CALLMONITOR 
8675 cd 6f ee			call debug_vector  
8678				endm  
# End of macro CALLMONITOR
8678				endif 
8678 ed b0			ldir    ; copy zero term string 
867a				if DEBUG_STORESE 
867a					DMARK "SCA" 
867a f5				push af  
867b 3a 8f 86			ld a, (.dmark)  
867e 32 62 ee			ld (debug_mark),a  
8681 3a 90 86			ld a, (.dmark+1)  
8684 32 63 ee			ld (debug_mark+1),a  
8687 3a 91 86			ld a, (.dmark+2)  
868a 32 64 ee			ld (debug_mark+2),a  
868d 18 03			jr .pastdmark  
868f ..			.dmark: db "SCA"  
8692 f1			.pastdmark: pop af  
8693			endm  
# End of macro DMARK
8693					CALLMONITOR 
8693 cd 6f ee			call debug_vector  
8696				endm  
# End of macro CALLMONITOR
8696				endif 
8696			 
8696				; write file header page 
8696			 
8696 2a 5c ea			ld hl,(store_tmppageid) 
8699 11 71 ea			ld de, store_page 
869c				if DEBUG_STORESE 
869c					DMARK "SCb" 
869c f5				push af  
869d 3a b1 86			ld a, (.dmark)  
86a0 32 62 ee			ld (debug_mark),a  
86a3 3a b2 86			ld a, (.dmark+1)  
86a6 32 63 ee			ld (debug_mark+1),a  
86a9 3a b3 86			ld a, (.dmark+2)  
86ac 32 64 ee			ld (debug_mark+2),a  
86af 18 03			jr .pastdmark  
86b1 ..			.dmark: db "SCb"  
86b4 f1			.pastdmark: pop af  
86b5			endm  
# End of macro DMARK
86b5					;push af 
86b5					;ld a, 'b' 
86b5					;ld (debug_mark),a 
86b5					;pop af 
86b5					CALLMONITOR 
86b5 cd 6f ee			call debug_vector  
86b8				endm  
# End of macro CALLMONITOR
86b8				endif 
86b8 cd ec 81			call storage_write_block 
86bb			 
86bb 3a 65 ea			ld a, (store_tmpid) 
86be 6f				ld l, a 
86bf 26 00			ld h,0 
86c1				if DEBUG_STORESE 
86c1					DMARK "SCz" 
86c1 f5				push af  
86c2 3a d6 86			ld a, (.dmark)  
86c5 32 62 ee			ld (debug_mark),a  
86c8 3a d7 86			ld a, (.dmark+1)  
86cb 32 63 ee			ld (debug_mark+1),a  
86ce 3a d8 86			ld a, (.dmark+2)  
86d1 32 64 ee			ld (debug_mark+2),a  
86d4 18 03			jr .pastdmark  
86d6 ..			.dmark: db "SCz"  
86d9 f1			.pastdmark: pop af  
86da			endm  
# End of macro DMARK
86da					CALLMONITOR 
86da cd 6f ee			call debug_vector  
86dd				endm  
# End of macro CALLMONITOR
86dd				endif 
86dd c9				ret 
86de				 
86de			 
86de			 
86de			; 
86de			; Read File 
86de			; 
86de			; h - file id to locate 
86de			; l - extent to locate 
86de			; de - pointer to string to read into 
86de			; 
86de			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86de			 
86de			.sr_fail: 
86de d1				pop de 
86df c9				ret 
86e0			 
86e0			storage_read: 
86e0			 
86e0			 
86e0 d5				push de 
86e1			 
86e1			; TODO BUG the above push is it popped before the RET Z? 
86e1			 
86e1			; TODO how to handle multiple part blocks 
86e1			 
86e1				; locate file extent to read 
86e1			 
86e1 5c				ld e, h 
86e2 55				ld d, l 
86e3			 
86e3			.srext: 
86e3 22 6f ea			ld (store_readptr), hl     ; save the current extent to load 
86e6 ed 53 6d ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86ea			 
86ea 21 40 00			ld hl, STORE_BLOCK_PHY 
86ed				if DEBUG_STORESE 
86ed					DMARK "sre" 
86ed f5				push af  
86ee 3a 02 87			ld a, (.dmark)  
86f1 32 62 ee			ld (debug_mark),a  
86f4 3a 03 87			ld a, (.dmark+1)  
86f7 32 63 ee			ld (debug_mark+1),a  
86fa 3a 04 87			ld a, (.dmark+2)  
86fd 32 64 ee			ld (debug_mark+2),a  
8700 18 03			jr .pastdmark  
8702 ..			.dmark: db "sre"  
8705 f1			.pastdmark: pop af  
8706			endm  
# End of macro DMARK
8706					CALLMONITOR 
8706 cd 6f ee			call debug_vector  
8709				endm  
# End of macro CALLMONITOR
8709				endif 
8709 cd ba 84			call storage_findnextid 
870c			 
870c				if DEBUG_STORESE 
870c					DMARK "srf" 
870c f5				push af  
870d 3a 21 87			ld a, (.dmark)  
8710 32 62 ee			ld (debug_mark),a  
8713 3a 22 87			ld a, (.dmark+1)  
8716 32 63 ee			ld (debug_mark+1),a  
8719 3a 23 87			ld a, (.dmark+2)  
871c 32 64 ee			ld (debug_mark+2),a  
871f 18 03			jr .pastdmark  
8721 ..			.dmark: db "srf"  
8724 f1			.pastdmark: pop af  
8725			endm  
# End of macro DMARK
8725					CALLMONITOR 
8725 cd 6f ee			call debug_vector  
8728				endm  
# End of macro CALLMONITOR
8728				endif 
8728 cd 13 8d			call ishlzero 
872b			;	ld a, l 
872b			;	add h 
872b			;	cp 0 
872b 28 b1			jr z,.sr_fail			; block not found so EOF 
872d			 
872d				; save current address for use by higher level words etc 
872d			 
872d 22 62 ea			ld (store_openaddr),hl 
8730			 
8730			 
8730				; hl contains page number to load 
8730 d1				pop de   ; get storage 
8731 ed 53 6d ea		ld (store_readbuf), de     ; current buffer to load in to 
8735 d5				push de 
8736				if DEBUG_STORESE 
8736					DMARK "srg" 
8736 f5				push af  
8737 3a 4b 87			ld a, (.dmark)  
873a 32 62 ee			ld (debug_mark),a  
873d 3a 4c 87			ld a, (.dmark+1)  
8740 32 63 ee			ld (debug_mark+1),a  
8743 3a 4d 87			ld a, (.dmark+2)  
8746 32 64 ee			ld (debug_mark+2),a  
8749 18 03			jr .pastdmark  
874b ..			.dmark: db "srg"  
874e f1			.pastdmark: pop af  
874f			endm  
# End of macro DMARK
874f					CALLMONITOR 
874f cd 6f ee			call debug_vector  
8752				endm  
# End of macro CALLMONITOR
8752				endif 
8752 cd 87 81			call storage_read_block 
8755			 
8755				; if this a continuation read??? 
8755			 
8755 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8758			 
8758 3e 3f			ld a, STORE_BLOCK_PHY-1 
875a cd ea 8c			call addatohl 
875d 7e				ld a,(hl) 
875e fe 00			cp 0 
8760 28 02			jr z, .markiscont 
8762 3e ff			ld a, 255 
8764			 
8764			.markiscont: 
8764 32 64 ea			ld (store_readcont), a 
8767			 
8767				if DEBUG_STORESE 
8767					DMARK "srC" 
8767 f5				push af  
8768 3a 7c 87			ld a, (.dmark)  
876b 32 62 ee			ld (debug_mark),a  
876e 3a 7d 87			ld a, (.dmark+1)  
8771 32 63 ee			ld (debug_mark+1),a  
8774 3a 7e 87			ld a, (.dmark+2)  
8777 32 64 ee			ld (debug_mark+2),a  
877a 18 03			jr .pastdmark  
877c ..			.dmark: db "srC"  
877f f1			.pastdmark: pop af  
8780			endm  
# End of macro DMARK
8780					CALLMONITOR 
8780 cd 6f ee			call debug_vector  
8783				endm  
# End of macro CALLMONITOR
8783				endif 
8783				; only short reads enabled 
8783			 
8783 3a 6c ea			ld a, (store_longread) 
8786 fe 00			cp 0 
8788 ca 55 88			jp z, .readdone 
878b			 
878b			; TODO if block has no zeros then need to read next block  
878b			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
878b			; check last byte of physical block. 
878b			; if not zero then the next block needs to be loaded 
878b			 
878b			 
878b 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
878e			 
878e 3e 3f			ld a, STORE_BLOCK_PHY-1 
8790 cd ea 8c			call addatohl 
8793				;dec hl 
8793 7e				ld a,(hl) 
8794				if DEBUG_STORESE 
8794					DMARK "sr?" 
8794 f5				push af  
8795 3a a9 87			ld a, (.dmark)  
8798 32 62 ee			ld (debug_mark),a  
879b 3a aa 87			ld a, (.dmark+1)  
879e 32 63 ee			ld (debug_mark+1),a  
87a1 3a ab 87			ld a, (.dmark+2)  
87a4 32 64 ee			ld (debug_mark+2),a  
87a7 18 03			jr .pastdmark  
87a9 ..			.dmark: db "sr?"  
87ac f1			.pastdmark: pop af  
87ad			endm  
# End of macro DMARK
87ad					CALLMONITOR 
87ad cd 6f ee			call debug_vector  
87b0				endm  
# End of macro CALLMONITOR
87b0				endif 
87b0 fe 00			cp 0 
87b2 ca 55 88			jp z, .readdone 
87b5			 
87b5				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87b5			 
87b5 23				inc hl 
87b6			 
87b6 22 6d ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87b9			 
87b9 ed 5b 6f ea		ld de, (store_readptr)     ; save the current extent to load 
87bd			 
87bd eb				ex de, hl 
87be			 
87be				; next ext 
87be			 
87be 23				inc hl 
87bf 22 6f ea			ld  (store_readptr), hl     ; save the current extent to load 
87c2			 
87c2				if DEBUG_STORESE 
87c2					DMARK "sF2" 
87c2 f5				push af  
87c3 3a d7 87			ld a, (.dmark)  
87c6 32 62 ee			ld (debug_mark),a  
87c9 3a d8 87			ld a, (.dmark+1)  
87cc 32 63 ee			ld (debug_mark+1),a  
87cf 3a d9 87			ld a, (.dmark+2)  
87d2 32 64 ee			ld (debug_mark+2),a  
87d5 18 03			jr .pastdmark  
87d7 ..			.dmark: db "sF2"  
87da f1			.pastdmark: pop af  
87db			endm  
# End of macro DMARK
87db					CALLMONITOR 
87db cd 6f ee			call debug_vector  
87de				endm  
# End of macro CALLMONITOR
87de				endif 
87de			 
87de				; get and load block 
87de			 
87de cd ba 84			call storage_findnextid 
87e1			 
87e1				if DEBUG_STORESE 
87e1					DMARK "sf2" 
87e1 f5				push af  
87e2 3a f6 87			ld a, (.dmark)  
87e5 32 62 ee			ld (debug_mark),a  
87e8 3a f7 87			ld a, (.dmark+1)  
87eb 32 63 ee			ld (debug_mark+1),a  
87ee 3a f8 87			ld a, (.dmark+2)  
87f1 32 64 ee			ld (debug_mark+2),a  
87f4 18 03			jr .pastdmark  
87f6 ..			.dmark: db "sf2"  
87f9 f1			.pastdmark: pop af  
87fa			endm  
# End of macro DMARK
87fa					CALLMONITOR 
87fa cd 6f ee			call debug_vector  
87fd				endm  
# End of macro CALLMONITOR
87fd				endif 
87fd cd 13 8d			call ishlzero 
8800			;	ld a, l 
8800			;	add h 
8800			;	cp 0 
8800 ca de 86			jp z,.sr_fail			; block not found so EOF 
8803				 
8803				; save current address for use by higher level words etc 
8803			 
8803 22 62 ea			ld (store_openaddr),hl 
8806			 
8806 cd 87 81			call storage_read_block 
8809			 
8809				; on a continuation block, we now have the file id and ext in the middle of the block 
8809				; we need to pull everything back  
8809			 
8809 ed 5b 6d ea		ld de, (store_readbuf)     ; current buffer to nudge into 
880d 2a 6d ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8810 23				inc hl 
8811 23				inc hl     ; skip id and ext 
8812 01 40 00			ld bc, STORE_BLOCK_PHY 
8815				if DEBUG_STORESE 
8815					DMARK "SR<" 
8815 f5				push af  
8816 3a 2a 88			ld a, (.dmark)  
8819 32 62 ee			ld (debug_mark),a  
881c 3a 2b 88			ld a, (.dmark+1)  
881f 32 63 ee			ld (debug_mark+1),a  
8822 3a 2c 88			ld a, (.dmark+2)  
8825 32 64 ee			ld (debug_mark+2),a  
8828 18 03			jr .pastdmark  
882a ..			.dmark: db "SR<"  
882d f1			.pastdmark: pop af  
882e			endm  
# End of macro DMARK
882e					CALLMONITOR 
882e cd 6f ee			call debug_vector  
8831				endm  
# End of macro CALLMONITOR
8831				endif 
8831 ed b0			ldir     ; copy data 
8833			 
8833				; move the pointer back and pretend we have a full buffer for next recheck 
8833			 
8833 1b				dec de 
8834 1b				dec de 
8835			 
8835			; TODO do pop below now short circuit loop????? 
8835 c1				pop bc     ; get rid of spare de on stack 
8836				if DEBUG_STORESE 
8836					DMARK "SR>" 
8836 f5				push af  
8837 3a 4b 88			ld a, (.dmark)  
883a 32 62 ee			ld (debug_mark),a  
883d 3a 4c 88			ld a, (.dmark+1)  
8840 32 63 ee			ld (debug_mark+1),a  
8843 3a 4d 88			ld a, (.dmark+2)  
8846 32 64 ee			ld (debug_mark+2),a  
8849 18 03			jr .pastdmark  
884b ..			.dmark: db "SR>"  
884e f1			.pastdmark: pop af  
884f			endm  
# End of macro DMARK
884f					CALLMONITOR 
884f cd 6f ee			call debug_vector  
8852				endm  
# End of macro CALLMONITOR
8852				endif 
8852 c3 e3 86			jp .srext 
8855			 
8855			 
8855			 
8855			 
8855			 
8855			.readdone:		 
8855 e1				pop hl 		 ; return start of data to show as not EOF 
8856 23				inc hl   ; past file id 
8857 23				inc hl   ; past ext 
8858				if DEBUG_STORESE 
8858					DMARK "SRe" 
8858 f5				push af  
8859 3a 6d 88			ld a, (.dmark)  
885c 32 62 ee			ld (debug_mark),a  
885f 3a 6e 88			ld a, (.dmark+1)  
8862 32 63 ee			ld (debug_mark+1),a  
8865 3a 6f 88			ld a, (.dmark+2)  
8868 32 64 ee			ld (debug_mark+2),a  
886b 18 03			jr .pastdmark  
886d ..			.dmark: db "SRe"  
8870 f1			.pastdmark: pop af  
8871			endm  
# End of macro DMARK
8871					CALLMONITOR 
8871 cd 6f ee			call debug_vector  
8874				endm  
# End of macro CALLMONITOR
8874				endif 
8874 c9					ret 
8875			 
8875			 
8875			 
8875			; 
8875			; Append File 
8875			; 
8875			; hl - file id to locate 
8875			; de - pointer to (multi block) string to write 
8875			 
8875			.sa_notfound: 
8875 d1				pop de 
8876 c9				ret 
8877			 
8877			 
8877			storage_append: 
8877				; hl -  file id to append to 
8877				; de - string to append 
8877			 
8877 d5				push de 
8878				 
8878				if DEBUG_STORESE 
8878					DMARK "AP1" 
8878 f5				push af  
8879 3a 8d 88			ld a, (.dmark)  
887c 32 62 ee			ld (debug_mark),a  
887f 3a 8e 88			ld a, (.dmark+1)  
8882 32 63 ee			ld (debug_mark+1),a  
8885 3a 8f 88			ld a, (.dmark+2)  
8888 32 64 ee			ld (debug_mark+2),a  
888b 18 03			jr .pastdmark  
888d ..			.dmark: db "AP1"  
8890 f1			.pastdmark: pop af  
8891			endm  
# End of macro DMARK
8891					CALLMONITOR 
8891 cd 6f ee			call debug_vector  
8894				endm  
# End of macro CALLMONITOR
8894				endif 
8894			 
8894 7d				ld a, l 
8895 32 65 ea			ld (store_tmpid), a 
8898			 
8898				; get file header  
8898			 
8898 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
889a 3a 65 ea			ld a, (store_tmpid) 
889d 5f				ld e, a 
889e			 
889e 21 40 00				ld hl, STORE_BLOCK_PHY 
88a1 cd ba 84				call storage_findnextid 
88a4			 
88a4 cd 13 8d			call ishlzero 
88a7 28 cc			jr z, .sa_notfound 
88a9			 
88a9 22 5c ea			ld (store_tmppageid), hl 
88ac			 
88ac				; TODO handle file id not found 
88ac			 
88ac				if DEBUG_STORESE 
88ac					DMARK "AP2" 
88ac f5				push af  
88ad 3a c1 88			ld a, (.dmark)  
88b0 32 62 ee			ld (debug_mark),a  
88b3 3a c2 88			ld a, (.dmark+1)  
88b6 32 63 ee			ld (debug_mark+1),a  
88b9 3a c3 88			ld a, (.dmark+2)  
88bc 32 64 ee			ld (debug_mark+2),a  
88bf 18 03			jr .pastdmark  
88c1 ..			.dmark: db "AP2"  
88c4 f1			.pastdmark: pop af  
88c5			endm  
# End of macro DMARK
88c5					CALLMONITOR 
88c5 cd 6f ee			call debug_vector  
88c8				endm  
# End of macro CALLMONITOR
88c8				endif 
88c8			 
88c8				; update file extent count 
88c8			 
88c8 11 71 ea			ld de, store_page 
88cb			 
88cb cd 87 81			call storage_read_block 
88ce			 
88ce				if DEBUG_STORESE 
88ce					DMARK "AP3" 
88ce f5				push af  
88cf 3a e3 88			ld a, (.dmark)  
88d2 32 62 ee			ld (debug_mark),a  
88d5 3a e4 88			ld a, (.dmark+1)  
88d8 32 63 ee			ld (debug_mark+1),a  
88db 3a e5 88			ld a, (.dmark+2)  
88de 32 64 ee			ld (debug_mark+2),a  
88e1 18 03			jr .pastdmark  
88e3 ..			.dmark: db "AP3"  
88e6 f1			.pastdmark: pop af  
88e7			endm  
# End of macro DMARK
88e7					CALLMONITOR 
88e7 cd 6f ee			call debug_vector  
88ea				endm  
# End of macro CALLMONITOR
88ea				endif 
88ea			;	ld (store_tmppageid), hl 
88ea			 
88ea 3a 73 ea			ld a, (store_page+2) 
88ed 3c				inc a 
88ee 32 73 ea			ld (store_page+2), a 
88f1 32 64 ea			ld (store_tmpext), a 
88f4				 
88f4				if DEBUG_STORESE 
88f4					DMARK "AP3" 
88f4 f5				push af  
88f5 3a 09 89			ld a, (.dmark)  
88f8 32 62 ee			ld (debug_mark),a  
88fb 3a 0a 89			ld a, (.dmark+1)  
88fe 32 63 ee			ld (debug_mark+1),a  
8901 3a 0b 89			ld a, (.dmark+2)  
8904 32 64 ee			ld (debug_mark+2),a  
8907 18 03			jr .pastdmark  
8909 ..			.dmark: db "AP3"  
890c f1			.pastdmark: pop af  
890d			endm  
# End of macro DMARK
890d					CALLMONITOR 
890d cd 6f ee			call debug_vector  
8910				endm  
# End of macro CALLMONITOR
8910				endif 
8910 2a 5c ea			ld hl, (store_tmppageid) 
8913 11 71 ea			ld de, store_page 
8916 cd ec 81			call storage_write_block 
8919			 
8919				; find free block 
8919			 
8919 11 00 00			ld de, 0			 ; file extent to locate 
891c			 
891c 21 40 00				ld hl, STORE_BLOCK_PHY 
891f cd ba 84				call storage_findnextid 
8922 cd 13 8d			call ishlzero 
8925 ca 75 88			jp z, .sa_notfound 
8928			 
8928					; TODO handle no space left 
8928					 
8928 22 5c ea				ld (store_tmppageid), hl 
892b			 
892b				if DEBUG_STORESE 
892b					DMARK "AP4" 
892b f5				push af  
892c 3a 40 89			ld a, (.dmark)  
892f 32 62 ee			ld (debug_mark),a  
8932 3a 41 89			ld a, (.dmark+1)  
8935 32 63 ee			ld (debug_mark+1),a  
8938 3a 42 89			ld a, (.dmark+2)  
893b 32 64 ee			ld (debug_mark+2),a  
893e 18 03			jr .pastdmark  
8940 ..			.dmark: db "AP4"  
8943 f1			.pastdmark: pop af  
8944			endm  
# End of macro DMARK
8944					CALLMONITOR 
8944 cd 6f ee			call debug_vector  
8947				endm  
# End of macro CALLMONITOR
8947				endif 
8947					; init the buffer with zeros so we can id if the buffer is full or not 
8947			 
8947 e5					push hl 
8948 c5					push bc 
8949			 
8949 21 71 ea				ld hl, store_page 
894c 06 40				ld b, STORE_BLOCK_PHY 
894e 3e 00				ld a, 0 
8950 77			.zeroblock:	ld (hl), a 
8951 23					inc hl 
8952 10 fc				djnz .zeroblock 
8954			 
8954 c1					pop bc 
8955 e1					pop hl 
8956			 
8956					; construct block 
8956			 
8956 3a 65 ea				ld a, (store_tmpid) 
8959 32 71 ea				ld (store_page), a   ; file id 
895c 3a 64 ea				ld a, (store_tmpext)   ; extent for this block 
895f 32 72 ea				ld (store_page+1), a 
8962			 
8962 e1					pop hl    ; get string to write 
8963 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8965 11 73 ea				ld de, store_page+2 
8968			 
8968				if DEBUG_STORESE 
8968					DMARK "AP5" 
8968 f5				push af  
8969 3a 7d 89			ld a, (.dmark)  
896c 32 62 ee			ld (debug_mark),a  
896f 3a 7e 89			ld a, (.dmark+1)  
8972 32 63 ee			ld (debug_mark+1),a  
8975 3a 7f 89			ld a, (.dmark+2)  
8978 32 64 ee			ld (debug_mark+2),a  
897b 18 03			jr .pastdmark  
897d ..			.dmark: db "AP5"  
8980 f1			.pastdmark: pop af  
8981			endm  
# End of macro DMARK
8981					CALLMONITOR 
8981 cd 6f ee			call debug_vector  
8984				endm  
# End of macro CALLMONITOR
8984				endif 
8984			 
8984			 
8984			 
8984					; fill buffer with data until end of string or full block 
8984			 
8984 7e			.appd:		ld a, (hl) 
8985 12					ld (de), a 
8986 fe 00				cp 0 
8988 28 04				jr z, .appdone 
898a 23					inc hl 
898b 13					inc de 
898c 10 f6				djnz .appd 
898e			 
898e e5			.appdone:	push hl		 	; save current source in case we need to go around again 
898f f5					push af   		; save last byte dumped 
8990			 
8990			 
8990 2a 5c ea			ld hl, (store_tmppageid) 
8993 11 71 ea			ld de, store_page 
8996				if DEBUG_STORESE 
8996					DMARK "AP6" 
8996 f5				push af  
8997 3a ab 89			ld a, (.dmark)  
899a 32 62 ee			ld (debug_mark),a  
899d 3a ac 89			ld a, (.dmark+1)  
89a0 32 63 ee			ld (debug_mark+1),a  
89a3 3a ad 89			ld a, (.dmark+2)  
89a6 32 64 ee			ld (debug_mark+2),a  
89a9 18 03			jr .pastdmark  
89ab ..			.dmark: db "AP6"  
89ae f1			.pastdmark: pop af  
89af			endm  
# End of macro DMARK
89af					CALLMONITOR 
89af cd 6f ee			call debug_vector  
89b2				endm  
# End of macro CALLMONITOR
89b2				endif 
89b2 cd ec 81				call storage_write_block 
89b5			 
89b5			 
89b5				; was that a full block of data written? 
89b5				; any more to write out? 
89b5			 
89b5				; if yes then set vars and jump to start of function again 
89b5			 
89b5 f1					pop af 
89b6 d1					pop de 
89b7			 
89b7 fe 00				cp 0		 ; no, string was fully written 
89b9 c8					ret z 
89ba			 
89ba					; setup vars for next cycle 
89ba			 
89ba 3a 65 ea				ld a, (store_tmpid) 
89bd 6f					ld l, a 
89be 26 00				ld h, 0 
89c0			 
89c0 c3 77 88			 	jp storage_append	 ; yes, need to write out some more 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			 
89c3			if DEBUG_STORECF 
89c3			storageput:	 
89c3					ret 
89c3			storageread: 
89c3					ld hl, store_page 
89c3					ld b, 200 
89c3					ld a,0 
89c3			.src:		ld (hl),a 
89c3					inc hl 
89c3					djnz .src 
89c3					 
89c3			 
89c3					ld de, 0 
89c3					ld bc, 1 
89c3					ld hl, store_page 
89c3					call cfRead 
89c3			 
89c3				call cfGetError 
89c3				ld hl,scratch 
89c3				call hexout 
89c3				ld hl, scratch+2 
89c3				ld a, 0 
89c3				ld (hl),a 
89c3				ld de, scratch 
89c3				ld a,display_row_1 
89c3				call str_at_display 
89c3				call update_display 
89c3			 
89c3					ld hl, store_page 
89c3					ld (os_cur_ptr),hl 
89c3			 
89c3					ret 
89c3			endif 
89c3			 
89c3			 
89c3			; Clear out the main buffer store (used to remove junk before writing a new block) 
89c3			 
89c3			storage_clear_page: 
89c3 e5				push hl 
89c4 d5				push de 
89c5 c5				push bc 
89c6 21 71 ea			ld hl, store_page 
89c9 3e 00			ld a, 0 
89cb 77				ld (hl), a 
89cc			 
89cc 11 72 ea			ld de, store_page+1 
89cf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89d2			 
89d2 ed b0			ldir 
89d4				 
89d4 c1				pop bc 
89d5 d1				pop de 
89d6 e1				pop hl 
89d7 c9				ret 
89d8			 
89d8			; eof 
# End of file firmware_storage.asm
89d8			  
89d8			; support routines for above hardware abstraction layer  
89d8			  
89d8			include "firmware_general.asm"        ; general support functions  
89d8			 
89d8			; word look up 
89d8			 
89d8			; in 
89d8			; a is the index 
89d8			; hl is pointer start of array 
89d8			; 
89d8			; returns 
89d8			; hl to the word 
89d8			; 
89d8			 
89d8			table_lookup:  
89d8 d5					push de 
89d9 eb					ex de, hl 
89da			 
89da 6f					ld l, a 
89db 26 00				ld h, 0 
89dd 29					add hl, hl 
89de 19					add hl, de 
89df 7e					ld a, (hl) 
89e0 23					inc hl 
89e1 66					ld h,(hl) 
89e2 6f					ld l, a 
89e3			 
89e3 d1					pop de 
89e4 c9					ret 
89e5			 
89e5			; Delay loops 
89e5			 
89e5			 
89e5			 
89e5			aDelayInMS: 
89e5 c5				push bc 
89e6 47				ld b,a 
89e7			msdelay: 
89e7 c5				push bc 
89e8				 
89e8			 
89e8 01 41 00			ld bc,041h 
89eb cd 03 8a			call delayloop 
89ee c1				pop bc 
89ef 05				dec b 
89f0 20 f5			jr nz,msdelay 
89f2			 
89f2			;if CPU_CLOCK_8MHZ 
89f2			;msdelay8: 
89f2			;	push bc 
89f2			;	 
89f2			; 
89f2			;	ld bc,041h 
89f2			;	call delayloop 
89f2			;	pop bc 
89f2			;	dec b 
89f2			;	jr nz,msdelay8 
89f2			;endif 
89f2			 
89f2			 
89f2 c1				pop bc 
89f3 c9				ret 
89f4			 
89f4			 
89f4			delay250ms: 
89f4				;push de 
89f4 01 00 40			ld bc, 04000h 
89f7 c3 03 8a			jp delayloop 
89fa			delay500ms: 
89fa				;push de 
89fa 01 00 80			ld bc, 08000h 
89fd c3 03 8a			jp delayloop 
8a00			delay1s: 
8a00				;push bc 
8a00			   ; Clobbers A, d and e 
8a00 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
8a03			delayloop: 
8a03 c5			    push bc 
8a04			 
8a04			if BASE_CPM 
8a04				ld bc, CPM_DELAY_TUNE 
8a04			.cpmloop: 
8a04				push bc 
8a04			 
8a04			endif 
8a04			 
8a04			 
8a04			 
8a04			delayloopi: 
8a04			;	push bc 
8a04			;.dl: 
8a04 cb 47		    bit     0,a    	; 8 
8a06 cb 47		    bit     0,a    	; 8 
8a08 cb 47		    bit     0,a    	; 8 
8a0a e6 ff		    and     255  	; 7 
8a0c 0b			    dec     bc      	; 6 
8a0d 79			    ld      a,c     	; 4 
8a0e b0			    or      b     	; 4 
8a0f c2 04 8a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a12			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a12				;pop de 
8a12			;pop bc 
8a12			 
8a12			if BASE_CPM 
8a12				pop bc 
8a12				 
8a12			    dec     bc      	; 6 
8a12			    ld      a,c     	; 4 
8a12			    or      b     	; 4 
8a12			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a12				 
8a12			 
8a12			endif 
8a12			;if CPU_CLOCK_8MHZ 
8a12			;    pop bc 
8a12			;    push bc 
8a12			;.dl8: 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    and     255  	; 7 
8a12			;    dec     bc      	; 6 
8a12			;    ld      a,c     	; 4 
8a12			;    or      b     	; 4 
8a12			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a12			;endif 
8a12			 
8a12			;if CPU_CLOCK_10MHZ 
8a12			;    pop bc 
8a12			;    push bc 
8a12			;.dl8: 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    bit     0,a    	; 8 
8a12			;    and     255  	; 7 
8a12			;    dec     bc      	; 6 
8a12			;    ld      a,c     	; 4 
8a12			;    or      b     	; 4 
8a12			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a12			;endif 
8a12 c1			    pop bc 
8a13			 
8a13 c9				ret 
8a14			 
8a14			 
8a14			 
8a14			; eof 
# End of file firmware_general.asm
8a14			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a14			; display routines that use the physical hardware abstraction layer 
8a14			 
8a14			 
8a14			; Display an activity indicator 
8a14			; Each call returns the new char pointed to in hl 
8a14			 
8a14			active: 
8a14 3a bd eb			ld a, (display_active) 
8a17 fe 06			cp 6 
8a19			 
8a19 20 02			jr nz, .sne 
8a1b				; gone past the last one reset sequence 
8a1b 3e ff			ld a, 255 
8a1d			 
8a1d			.sne:   
8a1d				; get the next char in seq 
8a1d 3c				inc a 
8a1e 32 bd eb			ld (display_active), a 
8a21			 
8a21				; look up the string in the table 
8a21 21 38 8a			ld hl, actseq 
8a24 cb 27			sla a 
8a26 cd ea 8c			call addatohl 
8a29 cd 67 9d			call loadwordinhl 
8a2c			 
8a2c				; forth will write the to string when pushing so move from rom to ram 
8a2c			 
8a2c 11 be eb			ld de, display_active+1 
8a2f 01 02 00			ld bc, 2 
8a32 ed b0			ldir 
8a34			 
8a34 21 be eb			ld hl, display_active+1 
8a37 c9				ret 
8a38				 
8a38				 
8a38			 
8a38			 
8a38			;db "|/-\|-\" 
8a38			 
8a38			actseq: 
8a38			 
8a38 46 8a		dw spin0 
8a3a 48 8a		dw spin1 
8a3c 4a 8a		dw spin2 
8a3e 4c 8a		dw spin3 
8a40 4a 8a		dw spin2 
8a42 48 8a		dw spin1 
8a44 46 8a		dw spin0 
8a46			 
8a46 .. 00		spin0: db " ", 0 
8a48 .. 00		spin1: db "-", 0 
8a4a .. 00		spin2: db "+", 0 
8a4c .. 00		spin3: db "#", 0 
8a4e			 
8a4e			 
8a4e			; information window 
8a4e			 
8a4e			; pass hl with 1st string to display 
8a4e			; pass de with 2nd string to display 
8a4e			 
8a4e			info_panel: 
8a4e e5				push hl 
8a4f			 
8a4f 2a c3 eb			ld hl, (display_fb_active) 
8a52 e5				push hl    ; future de destination 
8a53 21 a8 ed				ld hl, display_fb0 
8a56 22 c3 eb				ld (display_fb_active), hl 
8a59			 
8a59			;	call clear_display 
8a59			 
8a59				if BASE_CPM 
8a59				ld a, '.' 
8a59				else 
8a59 3e a5			ld a, 165 
8a5b				endif 
8a5b cd c2 8a			call fill_display 
8a5e			 
8a5e			 
8a5e 3e 55			ld a, display_row_3 + 5 
8a60 cd d0 8a			call str_at_display 
8a63			 
8a63 e1				pop hl 
8a64 d1				pop de 
8a65			 
8a65 e5				push hl 
8a66			 
8a66			 
8a66 3e 2d			ld a, display_row_2 + 5 
8a68 cd d0 8a			call str_at_display 
8a6b			 
8a6b			 
8a6b cd e0 8a			call update_display 
8a6e cd 6d 99			call next_page_prompt 
8a71 cd bd 8a			call clear_display 
8a74			 
8a74				 
8a74 21 07 ed				ld hl, display_fb1 
8a77 22 c3 eb				ld (display_fb_active), hl 
8a7a cd e0 8a			call update_display 
8a7d			 
8a7d e1				pop hl 
8a7e			 
8a7e c9				ret 
8a7f			 
8a7f			 
8a7f			 
8a7f			 
8a7f			; TODO windowing? 
8a7f			 
8a7f			; TODO scroll line up 
8a7f			 
8a7f			scroll_up: 
8a7f			 
8a7f e5				push hl 
8a80 d5				push de 
8a81 c5				push bc 
8a82			 
8a82				; get frame buffer  
8a82			 
8a82 2a c3 eb			ld hl, (display_fb_active) 
8a85 e5				push hl    ; future de destination 
8a86			 
8a86 11 28 00			ld  de, display_cols 
8a89 19				add hl, de 
8a8a			 
8a8a d1				pop de 
8a8b			 
8a8b				;ex de, hl 
8a8b 01 9f 00			ld bc, display_fb_len -1  
8a8e			;if DEBUG_FORTH_WORDS 
8a8e			;	DMARK "SCL" 
8a8e			;	CALLMONITOR 
8a8e			;endif	 
8a8e ed b0			ldir 
8a90			 
8a90				; wipe bottom row 
8a90			 
8a90			 
8a90 2a c3 eb			ld hl, (display_fb_active) 
8a93 11 a0 00			ld de, display_cols*display_rows 
8a96 19				add hl, de 
8a97 06 28			ld b, display_cols 
8a99 3e 20			ld a, ' ' 
8a9b			.scwipe: 
8a9b 77				ld (hl), a 
8a9c 2b				dec hl 
8a9d 10 fc			djnz .scwipe 
8a9f			 
8a9f				;pop hl 
8a9f			 
8a9f c1				pop bc 
8aa0 d1				pop de 
8aa1 e1				pop hl 
8aa2			 
8aa2 c9				ret 
8aa3			 
8aa3			 
8aa3			;scroll_upo: 
8aa3			;	ld de, display_row_1 
8aa3			 ;	ld hl, display_row_2 
8aa3			;	ld bc, display_cols 
8aa3			;	ldir 
8aa3			;	ld de, display_row_2 
8aa3			 ;	ld hl, display_row_3 
8aa3			;	ld bc, display_cols 
8aa3			;	ldir 
8aa3			;	ld de, display_row_3 
8aa3			 ;	ld hl, display_row_4 
8aa3			;	ld bc, display_cols 
8aa3			;	ldir 
8aa3			 
8aa3			; TODO clear row 4 
8aa3			 
8aa3			;	ret 
8aa3			 
8aa3				 
8aa3			scroll_down: 
8aa3			 
8aa3 e5				push hl 
8aa4 d5				push de 
8aa5 c5				push bc 
8aa6			 
8aa6				; get frame buffer  
8aa6			 
8aa6 2a c3 eb			ld hl, (display_fb_active) 
8aa9			 
8aa9 11 9f 00			ld de, display_fb_len - 1 
8aac 19				add hl, de 
8aad			 
8aad e5			push hl    ; future de destination 
8aae			 
8aae 11 28 00			ld  de, display_cols 
8ab1 ed 52			sbc hl, de 
8ab3			 
8ab3			 
8ab3 d1				pop de 
8ab4			 
8ab4			;	ex de, hl 
8ab4 01 9f 00			ld bc, display_fb_len -1  
8ab7			 
8ab7			 
8ab7				 
8ab7			 
8ab7 ed b0			ldir 
8ab9			 
8ab9				; wipe bottom row 
8ab9			 
8ab9			 
8ab9			;	ld hl, (display_fb_active) 
8ab9			;;	ld de, display_cols*display_rows 
8ab9			;;	add hl, de 
8ab9			;	ld b, display_cols 
8ab9			;	ld a, ' ' 
8ab9			;.scwiped: 
8ab9			;	ld (hl), a 
8ab9			;	dec hl 
8ab9			;	djnz .scwiped 
8ab9			 
8ab9				;pop hl 
8ab9			 
8ab9 c1				pop bc 
8aba d1				pop de 
8abb e1				pop hl 
8abc			 
8abc c9				ret 
8abd			;scroll_down: 
8abd			;	ld de, display_row_4 
8abd			;	ld hl, display_row_3 
8abd			;	ld bc, display_cols 
8abd			;	ldir 
8abd			;	ld de, display_row_3 
8abd			; 	ld hl, display_row_2 
8abd			;	ld bc, display_cols 
8abd			;	ldir 
8abd			;	ld de, display_row_2 
8abd			;	ld hl, display_row_1 
8abd			;	ld bc, display_cols 
8abd			;	ldir 
8abd			;;; TODO clear row 1 
8abd			;	ret 
8abd			 
8abd			 
8abd			 
8abd			 
8abd			 
8abd			; clear active frame buffer 
8abd			 
8abd			clear_display: 
8abd 3e 20			ld a, ' ' 
8abf c3 c2 8a			jp fill_display 
8ac2			 
8ac2			; fill active frame buffer with a char in A 
8ac2			 
8ac2			fill_display: 
8ac2 06 a0			ld b,display_fb_len 
8ac4 2a c3 eb			ld hl, (display_fb_active) 
8ac7 77			.fd1:	ld (hl),a 
8ac8 23				inc hl 
8ac9 10 fc			djnz .fd1 
8acb 23				inc hl 
8acc 3e 00			ld a,0 
8ace 77				ld (hl),a 
8acf			 
8acf			 
8acf c9				ret 
8ad0			; Write string (DE) at pos (A) to active frame buffer 
8ad0			 
8ad0 2a c3 eb		str_at_display:    ld hl,(display_fb_active) 
8ad3 06 00					ld b,0 
8ad5 4f					ld c,a 
8ad6 09					add hl,bc 
8ad7 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ad8 b7			            OR   A              ;Null terminator? 
8ad9 c8			            RET  Z              ;Yes, so finished 
8ada 77					ld (hl),a 
8adb 23				inc hl 
8adc 13			            INC  DE             ;Point to next character 
8add 18 f8		            JR   .sad1     ;Repeat 
8adf c9					ret 
8ae0			 
8ae0			; using current frame buffer write to physical display 
8ae0			 
8ae0			update_display: 
8ae0 e5				push hl 
8ae1 2a c3 eb			ld hl, (display_fb_active) 
8ae4 cd 4f e3			call write_display 
8ae7 e1				pop hl 
8ae8 c9				ret 
8ae9			 
8ae9			; TODO scrolling 
8ae9			 
8ae9			 
8ae9			; move cursor right one char 
8ae9			cursor_right: 
8ae9			 
8ae9				; TODO shift right 
8ae9				; TODO if beyond max col 
8ae9				; TODO       cursor_next_line 
8ae9			 
8ae9 c9				ret 
8aea			 
8aea			 
8aea			cursor_next_line: 
8aea				; TODO first char 
8aea				; TODO line down 
8aea				; TODO if past last row 
8aea				; TODO    scroll up 
8aea			 
8aea c9				ret 
8aeb			 
8aeb			cursor_left: 
8aeb				; TODO shift left 
8aeb				; TODO if beyond left  
8aeb				; TODO     cursor prev line 
8aeb				 
8aeb c9				ret 
8aec			 
8aec			cursor_prev_line: 
8aec				; TODO last char 
8aec				; TODO line up 
8aec				; TODO if past first row 
8aec				; TODO   scroll down 
8aec			 
8aec c9				ret 
8aed			 
8aed			 
8aed			cout: 
8aed				; A - char 
8aed c9				ret 
8aee			 
8aee			 
8aee			; Display a menu and allow item selection (optional toggle items) 
8aee			; 
8aee			; format: 
8aee			; hl pointer to word array with zero term for items 
8aee			; e.g.    db item1 
8aee			;         db .... 
8aee			;         db 0 
8aee			; 
8aee			; a = starting menu item  
8aee			; 
8aee			; de = pointer item toggle array   (todo) 
8aee			; 
8aee			; returns item selected in a 1-... 
8aee			; returns 0 if back button pressed 
8aee			; 
8aee			; NOTE: Uses system frame buffer to display 
8aee			; 
8aee			; LEFT, Q = go back 
8aee			; RIGHT, SPACE, CR = select 
8aee			; UP, A - Up 
8aee			; DOWN, Z - Down 
8aee			 
8aee			 
8aee			 
8aee			 
8aee			 
8aee			menu: 
8aee			 
8aee					; keep array pointer 
8aee			 
8aee 22 6a ea				ld (store_tmp1), hl 
8af1 32 68 ea				ld (store_tmp2), a 
8af4			 
8af4					; check for key bounce 
8af4			 
8af4			if BASE_KEV 
8af4			 
8af4			.mbounce:	call cin 
8af4					cp 0 
8af4					jr nz, .mbounce 
8af4			endif 
8af4					; for ease use ex 
8af4			 
8af4					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8af4 21 a8 ed				ld hl, display_fb0 
8af7 22 c3 eb				ld (display_fb_active), hl 
8afa			 
8afa cd bd 8a		.mloop:		call clear_display 
8afd cd e0 8a				call update_display 
8b00			 
8b00					; draw selection id '>' at 1 
8b00			 
8b00					; init start of list display 
8b00			 
8b00 3e 05				ld a, 5 
8b02 32 66 ea				ld (store_tmp3), a   ; display row count 
8b05 3a 68 ea				ld a,( store_tmp2) 
8b08 32 69 ea				ld (store_tmp2+1), a   ; display item count 
8b0b			 
8b0b					 
8b0b			.mitem:	 
8b0b			 
8b0b			 
8b0b 3a 69 ea				ld a,(store_tmp2+1) 
8b0e 6f					ld l, a 
8b0f 26 00				ld h, 0 
8b11 29					add hl, hl 
8b12 ed 5b 6a ea			ld de, (store_tmp1) 
8b16 19					add hl, de 
8b17 7e					ld a, (hl) 
8b18 23					inc hl 
8b19 66					ld h,(hl) 
8b1a 6f					ld l, a 
8b1b			 
8b1b cd 13 8d				call ishlzero 
8b1e 28 1a				jr z, .mdone 
8b20			 
8b20 eb					ex de, hl 
8b21 3a 66 ea				ld a, (store_tmp3) 
8b24 cd d0 8a				call str_at_display 
8b27					 
8b27			 
8b27					; next item 
8b27 3a 69 ea				ld a, (store_tmp2+1) 
8b2a 3c					inc a 
8b2b 32 69 ea				ld (store_tmp2+1), a   ; display item count 
8b2e			 
8b2e			 		; next row 
8b2e			 
8b2e 3a 66 ea				ld a, (store_tmp3) 
8b31 c6 28				add display_cols 
8b33 32 66 ea				ld (store_tmp3), a 
8b36			 
8b36					; at end of screen? 
8b36			 
8b36 fe 10				cp display_rows*4 
8b38 20 d1				jr nz, .mitem 
8b3a			 
8b3a			 
8b3a			.mdone: 
8b3a cd 13 8d				call ishlzero 
8b3d 28 08				jr z, .nodn 
8b3f			 
8b3f 3e 78				ld a, display_row_4 
8b41 11 c0 8b				ld de, .mdown 
8b44 cd d0 8a				call str_at_display 
8b47			 
8b47					; draw options to fill the screens with active item on line 1 
8b47					; if current option is 2 or more then display ^ in top 
8b47			 
8b47 3a 68 ea		.nodn:		ld a, (store_tmp2) 
8b4a fe 00				cp 0 
8b4c 28 08				jr z, .noup 
8b4e			 
8b4e 3e 00				ld a, 0 
8b50 11 be 8b				ld de, .mup 
8b53 cd d0 8a				call str_at_display 
8b56			 
8b56 3e 02		.noup:		ld a, 2 
8b58 11 bc 8b				ld de, .msel 
8b5b cd d0 8a				call str_at_display 
8b5e			 
8b5e					; if current option + 1 is not null then display V in bottom 
8b5e					; get key 
8b5e cd e0 8a				call update_display 
8b61			 
8b61			 
8b61					; handle key 
8b61			 
8b61 cd db e3				call cin_wait 
8b64			 
8b64 fe 05				cp KEY_UP 
8b66 28 2b				jr z, .mgoup 
8b68 fe 61				cp 'a' 
8b6a 28 27				jr z, .mgoup 
8b6c fe 0a				cp KEY_DOWN 
8b6e 28 32				jr z, .mgod 
8b70 fe 7a				cp 'z' 
8b72 28 2e				jr z, .mgod 
8b74 fe 20				cp ' ' 
8b76 28 34				jr z, .goend 
8b78 fe 0c				cp KEY_RIGHT 
8b7a 28 30				jr z, .goend 
8b7c fe 0d				cp KEY_CR 
8b7e 28 2c				jr z, .goend 
8b80 fe 71				cp 'q' 
8b82 28 0b				jr z, .goback 
8b84			 
8b84 fe 0b				cp KEY_LEFT 
8b86 28 07				jr z, .goback 
8b88 fe 08				cp KEY_BS 
8b8a 28 03				jr z, .goback 
8b8c c3 fa 8a				jp .mloop 
8b8f			 
8b8f			.goback: 
8b8f 3e 00			ld a, 0 
8b91 18 1d			jr .goend2 
8b93			 
8b93				; move up one 
8b93			.mgoup: 
8b93 3a 68 ea				ld a, (store_tmp2) 
8b96 fe 00				cp 0 
8b98 ca fa 8a				jp z, .mloop 
8b9b 3d					dec a 
8b9c 32 68 ea				ld (store_tmp2), a 
8b9f c3 fa 8a				jp .mloop 
8ba2			 
8ba2				; move down one 
8ba2			.mgod: 
8ba2 3a 68 ea				ld a, (store_tmp2) 
8ba5 3c					inc a 
8ba6 32 68 ea				ld (store_tmp2), a 
8ba9 c3 fa 8a				jp .mloop 
8bac			 
8bac			 
8bac			.goend: 
8bac					; get selected item number 
8bac			 
8bac 3a 68 ea				ld a, (store_tmp2) 
8baf 3c					inc a 
8bb0			 
8bb0			.goend2: 
8bb0 f5					push af 
8bb1			 
8bb1					; restore active fb 
8bb1					; TODO BUG assumes fb1 
8bb1			 
8bb1 21 07 ed				ld hl, display_fb1 
8bb4 22 c3 eb				ld (display_fb_active), hl 
8bb7			 
8bb7					; restore main regs 
8bb7			 
8bb7			 
8bb7 cd e0 8a				call update_display 
8bba			 
8bba f1					pop af 
8bbb			 
8bbb c9				ret 
8bbc			 
8bbc .. 00		.msel:   db ">",0 
8bbe .. 00		.mup:   db "^",0 
8bc0 .. 00		.mdown:   db "v",0 
8bc2			 
8bc2			 
8bc2			; eof 
8bc2			 
# End of file firmware_display.asm
8bc2			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bc2			; random number generators 
8bc2			 
8bc2			 
8bc2			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bc2			 
8bc2			 
8bc2			;-----> Generate a random number 
8bc2			; output a=answer 0<=a<=255 
8bc2			; all registers are preserved except: af 
8bc2			random: 
8bc2 e5			        push    hl 
8bc3 d5			        push    de 
8bc4 2a a2 eb		        ld      hl,(randData) 
8bc7 ed 5f		        ld      a,r 
8bc9 57			        ld      d,a 
8bca 5e			        ld      e,(hl) 
8bcb 19			        add     hl,de 
8bcc 85			        add     a,l 
8bcd ac			        xor     h 
8bce 22 a2 eb		        ld      (randData),hl 
8bd1 d1			        pop     de 
8bd2 e1			        pop     hl 
8bd3 c9			        ret 
8bd4			 
8bd4			 
8bd4			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bd4			 
8bd4			 
8bd4			 
8bd4			;------LFSR------ 
8bd4			;James Montelongo 
8bd4			;optimized by Spencer Putt 
8bd4			;out: 
8bd4			; a = 8 bit random number 
8bd4			RandLFSR: 
8bd4 21 a8 eb		        ld hl,LFSRSeed+4 
8bd7 5e			        ld e,(hl) 
8bd8 23			        inc hl 
8bd9 56			        ld d,(hl) 
8bda 23			        inc hl 
8bdb 4e			        ld c,(hl) 
8bdc 23			        inc hl 
8bdd 7e			        ld a,(hl) 
8bde 47			        ld b,a 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed cb 13		        rl e  
8bef cb 12			rl d 
8bf1 cb 11		        rl c  
8bf3 17				rla 
8bf4 67			        ld h,a 
8bf5 cb 13		        rl e  
8bf7 cb 12			rl d 
8bf9 cb 11		        rl c  
8bfb 17				rla 
8bfc a8			        xor b 
8bfd cb 13		        rl e  
8bff cb 12			rl d 
8c01 ac			        xor h 
8c02 a9			        xor c 
8c03 aa			        xor d 
8c04 21 aa eb		        ld hl,LFSRSeed+6 
8c07 11 ab eb		        ld de,LFSRSeed+7 
8c0a 01 07 00		        ld bc,7 
8c0d ed b8		        lddr 
8c0f 12			        ld (de),a 
8c10 c9			        ret 
8c11			 
8c11			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c11			 
8c11			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c11			 
8c11			 
8c11			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c11			 
8c11			prng16: 
8c11			;Inputs: 
8c11			;   (seed1) contains a 16-bit seed value 
8c11			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c11			;Outputs: 
8c11			;   HL is the result 
8c11			;   BC is the result of the LCG, so not that great of quality 
8c11			;   DE is preserved 
8c11			;Destroys: 
8c11			;   AF 
8c11			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c11			;160cc 
8c11			;26 bytes 
8c11 2a 9c eb		    ld hl,(seed1) 
8c14 44			    ld b,h 
8c15 4d			    ld c,l 
8c16 29			    add hl,hl 
8c17 29			    add hl,hl 
8c18 2c			    inc l 
8c19 09			    add hl,bc 
8c1a 22 9c eb		    ld (seed1),hl 
8c1d 2a 9a eb		    ld hl,(seed2) 
8c20 29			    add hl,hl 
8c21 9f			    sbc a,a 
8c22 e6 2d		    and %00101101 
8c24 ad			    xor l 
8c25 6f			    ld l,a 
8c26 22 9a eb		    ld (seed2),hl 
8c29 09			    add hl,bc 
8c2a c9			    ret 
8c2b			 
8c2b			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c2b			 
8c2b			rand32: 
8c2b			;Inputs: 
8c2b			;   (seed1_0) holds the lower 16 bits of the first seed 
8c2b			;   (seed1_1) holds the upper 16 bits of the first seed 
8c2b			;   (seed2_0) holds the lower 16 bits of the second seed 
8c2b			;   (seed2_1) holds the upper 16 bits of the second seed 
8c2b			;   **NOTE: seed2 must be non-zero 
8c2b			;Outputs: 
8c2b			;   HL is the result 
8c2b			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c2b			;Destroys: 
8c2b			;   AF 
8c2b			;Tested and passes all CAcert tests 
8c2b			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c2b			;it has a period of 18,446,744,069,414,584,320 
8c2b			;roughly 18.4 quintillion. 
8c2b			;LFSR taps: 0,2,6,7  = 11000101 
8c2b			;291cc 
8c2b			;seed1_0=$+1 
8c2b			;    ld hl,12345 
8c2b			;seed1_1=$+1 
8c2b			;    ld de,6789 
8c2b			;    ld b,h 
8c2b			;    ld c,l 
8c2b			;    add hl,hl \ rl e \ rl d 
8c2b			;    add hl,hl \ rl e \ rl d 
8c2b			;    inc l 
8c2b			;    add hl,bc 
8c2b			;    ld (seed1_0),hl 
8c2b			;    ld hl,(seed1_1) 
8c2b			;    adc hl,de 
8c2b			;    ld (seed1_1),hl 
8c2b			;    ex de,hl 
8c2b			;seed2_0=$+1 
8c2b			;    ld hl,9876 
8c2b			;seed2_1=$+1 
8c2b			;    ld bc,54321 
8c2b			;    add hl,hl \ rl c \ rl b 
8c2b			;    ld (seed2_1),bc 
8c2b			;    sbc a,a 
8c2b			;    and %11000101 
8c2b			;    xor l 
8c2b			;    ld l,a 
8c2b			;    ld (seed2_0),hl 
8c2b			;    ex de,hl 
8c2b			;    add hl,bc 
8c2b			;    ret 
8c2b			; 
8c2b			 
8c2b			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c2b			; 20 bytes, 86 cycles (excluding ret) 
8c2b			 
8c2b			; returns   hl = pseudorandom number 
8c2b			; corrupts   a 
8c2b			 
8c2b			; generates 16-bit pseudorandom numbers with a period of 65535 
8c2b			; using the xorshift method: 
8c2b			 
8c2b			; hl ^= hl << 7 
8c2b			; hl ^= hl >> 9 
8c2b			; hl ^= hl << 8 
8c2b			 
8c2b			; some alternative shift triplets which also perform well are: 
8c2b			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c2b			 
8c2b			;  org 32768 
8c2b			 
8c2b			xrnd: 
8c2b 2a a0 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c2e 3e 00		  ld a,0 
8c30 bd			  cp l 
8c31 20 02		  jr nz, .xrnd1 
8c33 2e 01		  ld l, 1 
8c35			.xrnd1: 
8c35			 
8c35 7c			  ld a,h 
8c36 1f			  rra 
8c37 7d			  ld a,l 
8c38 1f			  rra 
8c39 ac			  xor h 
8c3a 67			  ld h,a 
8c3b 7d			  ld a,l 
8c3c 1f			  rra 
8c3d 7c			  ld a,h 
8c3e 1f			  rra 
8c3f ad			  xor l 
8c40 6f			  ld l,a 
8c41 ac			  xor h 
8c42 67			  ld h,a 
8c43			 
8c43 22 a0 eb		  ld (xrandc),hl 
8c46			 
8c46 c9			  ret 
8c47			;  
8c47			 
8c47			 
8c47			;;;; int maths 
8c47			 
8c47			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c47			; Divide 16-bit values (with 16-bit result) 
8c47			; In: Divide BC by divider DE 
8c47			; Out: BC = result, HL = rest 
8c47			; 
8c47			Div16: 
8c47 21 00 00		    ld hl,0 
8c4a 78			    ld a,b 
8c4b 06 08		    ld b,8 
8c4d			Div16_Loop1: 
8c4d 17			    rla 
8c4e ed 6a		    adc hl,hl 
8c50 ed 52		    sbc hl,de 
8c52 30 01		    jr nc,Div16_NoAdd1 
8c54 19			    add hl,de 
8c55			Div16_NoAdd1: 
8c55 10 f6		    djnz Div16_Loop1 
8c57 17			    rla 
8c58 2f			    cpl 
8c59 47			    ld b,a 
8c5a 79			    ld a,c 
8c5b 48			    ld c,b 
8c5c 06 08		    ld b,8 
8c5e			Div16_Loop2: 
8c5e 17			    rla 
8c5f ed 6a		    adc hl,hl 
8c61 ed 52		    sbc hl,de 
8c63 30 01		    jr nc,Div16_NoAdd2 
8c65 19			    add hl,de 
8c66			Div16_NoAdd2: 
8c66 10 f6		    djnz Div16_Loop2 
8c68 17			    rla 
8c69 2f			    cpl 
8c6a 41			    ld b,c 
8c6b 4f			    ld c,a 
8c6c c9			ret 
8c6d			 
8c6d			 
8c6d			;http://z80-heaven.wikidot.com/math 
8c6d			; 
8c6d			;Inputs: 
8c6d			;     DE and A are factors 
8c6d			;Outputs: 
8c6d			;     A is not changed 
8c6d			;     B is 0 
8c6d			;     C is not changed 
8c6d			;     DE is not changed 
8c6d			;     HL is the product 
8c6d			;Time: 
8c6d			;     342+6x 
8c6d			; 
8c6d			Mult16: 
8c6d			 
8c6d 06 08		     ld b,8          ;7           7 
8c6f 21 00 00		     ld hl,0         ;10         10 
8c72 29			       add hl,hl     ;11*8       88 
8c73 07			       rlca          ;4*8        32 
8c74 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c76 19			         add hl,de   ;--         -- 
8c77 10 f9		       djnz $-5      ;13*7+8     99 
8c79 c9			ret 
8c7a			 
8c7a			; 
8c7a			; Square root of 16-bit value 
8c7a			; In:  HL = value 
8c7a			; Out:  D = result (rounded down) 
8c7a			; 
8c7a			;Sqr16: 
8c7a			;    ld de,#0040 
8c7a			;    ld a,l 
8c7a			;    ld l,h 
8c7a			;    ld h,d 
8c7a			;    or a 
8c7a			;    ld b,8 
8c7a			;Sqr16_Loop: 
8c7a			;    sbc hl,de 
8c7a			;    jr nc,Sqr16_Skip 
8c7a			;    add hl,de 
8c7a			;Sqr16_Skip: 
8c7a			;    ccf 
8c7a			;    rl d 
8c7a			;    add a,a 
8c7a			;    adc hl,hl 
8c7a			;    add a,a 
8c7a			;    adc hl,hl 
8c7a			;    djnz Sqr16_Loop 
8c7a			;    ret 
8c7a			; 
8c7a			; 
8c7a			; Divide 8-bit values 
8c7a			; In: Divide E by divider C 
8c7a			; Out: A = result, B = rest 
8c7a			; 
8c7a			Div8: 
8c7a af			    xor a 
8c7b 06 08		    ld b,8 
8c7d			Div8_Loop: 
8c7d cb 13		    rl e 
8c7f 17			    rla 
8c80 91			    sub c 
8c81 30 01		    jr nc,Div8_NoAdd 
8c83 81			    add a,c 
8c84			Div8_NoAdd: 
8c84 10 f7		    djnz Div8_Loop 
8c86 47			    ld b,a 
8c87 7b			    ld a,e 
8c88 17			    rla 
8c89 2f			    cpl 
8c8a c9			    ret 
8c8b			 
8c8b			; 
8c8b			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c8b			; In: Multiply A with DE 
8c8b			; Out: HL = result 
8c8b			; 
8c8b			Mult12U: 
8c8b 2e 00		    ld l,0 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd0 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd0: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd1 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd1: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd2 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd2: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd3 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd3: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 30 01		    jr nc,Mult12U_NoAdd4 
8ca4 19			    add hl,de 
8ca5			Mult12U_NoAdd4: 
8ca5 29			    add hl,hl 
8ca6 87			    add a,a 
8ca7 30 01		    jr nc,Mult12U_NoAdd5 
8ca9 19			    add hl,de 
8caa			Mult12U_NoAdd5: 
8caa 29			    add hl,hl 
8cab 87			    add a,a 
8cac 30 01		    jr nc,Mult12U_NoAdd6 
8cae 19			    add hl,de 
8caf			Mult12U_NoAdd6: 
8caf 29			    add hl,hl 
8cb0 87			    add a,a 
8cb1 d0			    ret nc 
8cb2 19			    add hl,de 
8cb3 c9			    ret 
8cb4			 
8cb4			; 
8cb4			; Multiply 8-bit value with a 16-bit value (right rotating) 
8cb4			; In: Multiply A with DE 
8cb4			;      Put lowest value in A for most efficient calculation 
8cb4			; Out: HL = result 
8cb4			; 
8cb4			Mult12R: 
8cb4 21 00 00		    ld hl,0 
8cb7			Mult12R_Loop: 
8cb7 cb 3f		    srl a 
8cb9 30 01		    jr nc,Mult12R_NoAdd 
8cbb 19			    add hl,de 
8cbc			Mult12R_NoAdd: 
8cbc cb 23		    sla e 
8cbe cb 12		    rl d 
8cc0 b7			    or a 
8cc1 c2 b7 8c		    jp nz,Mult12R_Loop 
8cc4 c9			    ret 
8cc5			 
8cc5			; 
8cc5			; Multiply 16-bit values (with 32-bit result) 
8cc5			; In: Multiply BC with DE 
8cc5			; Out: BCHL = result 
8cc5			; 
8cc5			Mult32: 
8cc5 79			    ld a,c 
8cc6 48			    ld c,b 
8cc7 21 00 00		    ld hl,0 
8cca 06 10		    ld b,16 
8ccc			Mult32_Loop: 
8ccc 29			    add hl,hl 
8ccd 17			    rla 
8cce cb 11		    rl c 
8cd0 30 07		    jr nc,Mult32_NoAdd 
8cd2 19			    add hl,de 
8cd3 ce 00		    adc a,0 
8cd5 d2 d9 8c		    jp nc,Mult32_NoAdd 
8cd8 0c			    inc c 
8cd9			Mult32_NoAdd: 
8cd9 10 f1		    djnz Mult32_Loop 
8cdb 41			    ld b,c 
8cdc 4f			    ld c,a 
8cdd c9			    ret 
8cde			 
8cde			 
8cde			 
8cde			; 
8cde			; Multiply 8-bit values 
8cde			; In:  Multiply H with E 
8cde			; Out: HL = result 
8cde			; 
8cde			Mult8: 
8cde 16 00		    ld d,0 
8ce0 6a			    ld l,d 
8ce1 06 08		    ld b,8 
8ce3			Mult8_Loop: 
8ce3 29			    add hl,hl 
8ce4 30 01		    jr nc,Mult8_NoAdd 
8ce6 19			    add hl,de 
8ce7			Mult8_NoAdd: 
8ce7 10 fa		    djnz Mult8_Loop 
8ce9 c9			    ret 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			 
8cea			;;http://z80-heaven.wikidot.com/math 
8cea			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cea			; 
8cea			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cea			;     ld a,16        ;7 
8cea			;     ld hl,0        ;10 
8cea			;     jp $+5         ;10 
8cea			;.DivLoop: 
8cea			;       add hl,bc    ;-- 
8cea			;       dec a        ;64 
8cea			;       jr z,.DivLoopEnd        ;86 
8cea			; 
8cea			;       sla e        ;128 
8cea			;       rl d         ;128 
8cea			;       adc hl,hl    ;240 
8cea			;       sbc hl,bc    ;240 
8cea			;       jr nc,.DivLoop ;23|21 
8cea			;       inc e        ;-- 
8cea			;       jp .DivLoop+1 
8cea			; 
8cea			;.DivLoopEnd: 
8cea			 
8cea			;HL_Div_C: 
8cea			;Inputs: 
8cea			;     HL is the numerator 
8cea			;     C is the denominator 
8cea			;Outputs: 
8cea			;     A is the remainder 
8cea			;     B is 0 
8cea			;     C is not changed 
8cea			;     DE is not changed 
8cea			;     HL is the quotient 
8cea			; 
8cea			;       ld b,16 
8cea			;       xor a 
8cea			;         add hl,hl 
8cea			;         rla 
8cea			;         cp c 
8cea			;         jr c,$+4 
8cea			;           inc l 
8cea			;           sub c 
8cea			;         djnz $-7 
8cea			 
8cea			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cea			 
8cea			addatohl: 
8cea 85			    add   a, l    ; A = A+L 
8ceb 6f			    ld    l, a    ; L = A+L 
8cec 8c			    adc   a, h    ; A = A+L+H+carry 
8ced 95			    sub   l       ; A = H+carry 
8cee 67			    ld    h, a    ; H = H+carry 
8cef c9			ret 
8cf0			 
8cf0			addatode: 
8cf0 83			    add   a, e    ; A = A+L 
8cf1 5f			    ld    e, a    ; L = A+L 
8cf2 8a			    adc   a, d    ; A = A+L+H+carry 
8cf3 93			    sub   e       ; A = H+carry 
8cf4 57			    ld    d, a    ; H = H+carry 
8cf5 c9			ret 
8cf6			 
8cf6			 
8cf6			addatobc: 
8cf6 81			    add   a, c    ; A = A+L 
8cf7 4f			    ld    c, a    ; L = A+L 
8cf8 88			    adc   a, b    ; A = A+L+H+carry 
8cf9 91			    sub   c       ; A = H+carry 
8cfa 47			    ld    b, a    ; H = H+carry 
8cfb c9			ret 
8cfc			 
8cfc			subafromhl: 
8cfc			   ; If A=0 do nothing 
8cfc			    ; Otherwise flip A's sign. Since 
8cfc			    ; the upper byte becomes -1, also 
8cfc			    ; substract 1 from H. 
8cfc ed 44		    neg 
8cfe ca 07 8d		    jp    z, Skip 
8d01 25			    dec   h 
8d02			     
8d02			    ; Now add the low byte as usual 
8d02			    ; Two's complement takes care of 
8d02			    ; ensuring the result is correct 
8d02 85			    add   a, l 
8d03 6f			    ld    l, a 
8d04 8c			    adc   a, h 
8d05 95			    sub   l 
8d06 67			    ld    h, a 
8d07			Skip: 
8d07 c9				ret 
8d08			 
8d08			 
8d08			; compare hl and de 
8d08			; returns:  
8d08			; if hl = de, z=1, s=0, c0=0 
8d08			; if hl > de, z=0, s=0, c=0 
8d08			; if hl < de, z=0, s=1, c=1 
8d08			cmp16:	 
8d08 b7				or a 
8d09 ed 52			sbc hl,de 
8d0b e0				ret po 
8d0c 7c				ld a,h 
8d0d 1f				rra 
8d0e ee 40			xor 01000000B 
8d10 37				scf 
8d11 8f				adc a,a 
8d12 c9				ret 
8d13			 
8d13			 
8d13			; test if hl contains zero   - A is destroyed 
8d13			 
8d13			ishlzero:    
8d13 b7				or a     ; reset flags 
8d14 7c				ld a, h 
8d15 b5				or l        	 
8d16			 
8d16 c9				ret 
8d17			 
8d17			 
8d17			 
8d17			 
8d17			if FORTH_ENABLE_FLOATMATH 
8d17			;include "float/bbcmath.z80" 
8d17			include "float/lpfpcalc.asm" 
8d17			endif 
8d17			 
8d17			 
8d17			; eof 
8d17			 
# End of file firmware_maths.asm
8d17			include "firmware_strings.asm"   ; string handling  
8d17			 
8d17			 
8d17			; TODO string len 
8d17			; input text string, end on cr with zero term 
8d17			; a offset into frame buffer to start prompt 
8d17			; d is max length 
8d17			; e is display size TODO 
8d17			; c is current cursor position 
8d17			; hl is ptr to where string will be stored and edited directly 
8d17			 
8d17			 
8d17			; TODO check limit of buffer for new inserts 
8d17			; TODO check insert does not push beyond buffer 
8d17			; TODO scroll in a limited display area 
8d17			; TODO scroll whole screen on page wrap 
8d17			 
8d17			 
8d17			; TODO use LCD cursor? 
8d17			 
8d17			EDIT_V1: equ 0 
8d17			EDIT_V2: equ 1 
8d17			 
8d17			 
8d17			 
8d17			if EDIT_V2 
8d17			input_str: 
8d17			 
8d17 32 5b ee			    	ld (input_at_pos),a      ; save display position to start 
8d1a			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d1a 22 5e ee				ld (input_start), hl     ; save ptr to buffer 
8d1d			;		ld a, c 
8d1d			;		call addatohl 
8d1d			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1d 7a					ld a,d 
8d1e 32 5d ee			        ld (input_size), a       ; save length of input area 
8d21 79					ld a, c 
8d22 32 4c ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d25 7b					ld a,e 
8d26 32 5c ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d29			 
8d29			 
8d29					; add a trailing space to make screen refresh nicer 
8d29			 
8d29					;ld hl, (input_start) 
8d29					;push hl 
8d29					;ld a, 0 
8d29					;call strlent 
8d29					;ld a, l 
8d29					;pop hl 
8d29					;call addatohl 
8d29					;dec hl 
8d29					;ld a, ' ' 
8d29					;ld (hl), a 
8d29					;inc hl 
8d29					;ld (hl), a 
8d29					;inc hl 
8d29					;ld a, 0 
8d29					;ld (hl), a 
8d29			 
8d29			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d29					; init cursor shape if not set by the cin routines 
8d29 21 b8 eb				ld hl, cursor_shape 
8d2c			if BASE_KEV 
8d2c					ld a, 255 
8d2c			else 
8d2c 3e 23				ld a, '#' 
8d2e			endif 
8d2e 77					ld (hl), a 
8d2f 23					inc hl 
8d30 3e 00				ld a, 0 
8d32 77					ld (hl), a 
8d33			 
8d33 3e 09				ld a, CUR_BLINK_RATE 
8d35 32 57 ee				ld (input_cur_flash), a 
8d38 3e 01				ld a, 1 
8d3a 32 56 ee				ld (input_cur_onoff),a 
8d3d			.inmain:	 
8d3d			 
8d3d cd 65 8e				call input_disp_ref 
8d40			 
8d40					; save current length of string 
8d40			 
8d40 2a 5e ee				ld hl, (input_start) 
8d43 3e 00				ld a, 0 
8d45 cd 5b 90				call strlent 
8d48 7d					ld a,l 
8d49 32 51 ee				ld (input_len), a 
8d4c			 
8d4c					;call input_disp_oncur 
8d4c			 
8d4c					; display current state of input buffer 
8d4c			 
8d4c					; clean any backspace chars 
8d4c			 
8d4c 3e 20				ld a, " " 
8d4e 32 b8 e2				ld (scratch),a 
8d51 3e 00				ld a, 0 
8d53 32 b9 e2				ld (scratch+1),a 
8d56 3a 5b ee				ld a,(input_at_pos) 
8d59 85					add l 
8d5a 11 b8 e2				ld de, scratch 
8d5d cd d0 8a				call str_at_display 
8d60			 
8d60					; pause 1ms 
8d60			 
8d60 3e 01				ld a, 1 
8d62 cd e5 89				call aDelayInMS 
8d65			 
8d65			; display cursor if visible on this cycle 
8d65			 
8d65					; dec flash counter 
8d65 3a 57 ee				ld a, (input_cur_flash) 
8d68 3d					dec a 
8d69 32 57 ee				ld (input_cur_flash), a 
8d6c fe 00				cp 0 
8d6e 20 0d				jr nz, .inochgstate 
8d70			 
8d70			 
8d70					; reset on change of state 
8d70 3e 09				ld a, CUR_BLINK_RATE 
8d72 32 57 ee				ld (input_cur_flash), a 
8d75			 
8d75					; change state 
8d75 3a 56 ee				ld a,(input_cur_onoff) 
8d78 ed 44				neg 
8d7a 32 56 ee				ld (input_cur_onoff),a 
8d7d			 
8d7d			 
8d7d			 
8d7d			 
8d7d					; TODO is cursor visible? 
8d7d					; TODO if so then over write the char at curspos pos with the cursor shape 
8d7d			 
8d7d								 
8d7d			 
8d7d			.inochgstate: 
8d7d 3a 56 ee				ld a,(input_cur_onoff) 
8d80 fe ff				cp 255 
8d82 28 0e				jr z, .skipcursor 
8d84 3a 5b ee				ld a, (input_at_pos) 
8d87 47					ld b, a 
8d88 3a 4c ee				ld a, (input_cursor) 
8d8b 80					add b 
8d8c 11 b8 eb				ld de, cursor_shape 
8d8f					 
8d8f cd d0 8a				call str_at_display 
8d92			 
8d92			.skipcursor: 
8d92				if DEBUG_INPUTV2 
8d92			 
8d92					ld a,(input_at_pos) 
8d92					ld hl, LFSRSeed 
8d92					call hexout 
8d92					ld a, (input_cursor) 
8d92					ld hl, LFSRSeed+2 
8d92					call hexout 
8d92					ld a,(input_size) 
8d92					ld hl, LFSRSeed+4 
8d92					call hexout 
8d92			 
8d92					ld a,(input_cur_onoff) 
8d92					ld hl, LFSRSeed+6 
8d92					call hexout 
8d92			 
8d92					ld a,(input_cur_flash) 
8d92					ld hl, LFSRSeed+8 
8d92					call hexout 
8d92			 
8d92					ld a,(input_len) 
8d92					ld hl, LFSRSeed+10 
8d92					call hexout 
8d92					ld hl, LFSRSeed+12 
8d92					ld a, 0 
8d92					ld (hl),a 
8d92					ld a, display_row_4 
8d92					ld de, LFSRSeed 
8d92					call str_at_display 
8d92				endif 
8d92 cd e0 8a				call update_display 
8d95			 
8d95					; TODO keyboard processing 
8d95			 
8d95			if BASE_CPM 
8d95					call cin_wait 
8d95			else 
8d95 cd e1 e3				call cin    ; _wait 
8d98			endif 
8d98 fe 00				cp 0 
8d9a ca 3d 8d				jp z, .inmain 
8d9d			 
8d9d fe 0b				cp KEY_LEFT    ; cursor left 
8d9f ca 57 8e				jp z, input_left 
8da2				 
8da2 fe 0c				cp KEY_RIGHT      ; cursor right 
8da4 ca 5e 8e				jp z, input_right 
8da7			 
8da7 fe 0d				cp KEY_CR 
8da9 c8					ret z 
8daa			 
8daa fe 08				cp KEY_BS 
8dac ca cc 8e				jp z, input_delchar 
8daf			 
8daf fe 06				cp KEY_NEXTWORD 
8db1 ca d8 8d				jp z, input_nxtword 
8db4			 
8db4 fe 07				cp KEY_PREVWORD 
8db6 ca ff 8d				jp z, input_prvword 
8db9			 
8db9 fe 0e				cp KEY_HOME    ; jump to start of line 
8dbb 20 08				jr nz, .ikh 
8dbd 3e 00				ld a, 0 
8dbf 32 4c ee				ld (input_cursor), a 
8dc2 ca 3d 8d				jp z, .inmain 
8dc5			.ikh: 
8dc5			 
8dc5 fe 0f				cp KEY_END     ; jump to end of line 
8dc7 20 09				jr nz, .ike 
8dc9 3a 51 ee				ld a, (input_len) 
8dcc 32 4c ee				ld (input_cursor),a 
8dcf ca 3d 8d				jp z, .inmain 
8dd2			.ike: 
8dd2 fe 05			        cp KEY_UP      ; recall last command 
8dd4 c8					ret z 
8dd5			;jr nz, .irec 
8dd5			; TODO next word 
8dd5			; TODO prev word 
8dd5			;  
8dd5			; 
8dd5			;	ld hl, scratch 
8dd5			;	ld de, os_last_cmd 
8dd5			;	call strcpy 
8dd5			;		jp  .inmain 
8dd5			.irec: 
8dd5			;		jr .instr1 
8dd5			 
8dd5			 
8dd5			 
8dd5					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
8dd5			 
8dd5			; TODO return if any special keys are given 
8dd5			;		ld l, a 
8dd5			;		ld a, 28 ; KEY_F12   ; 27 
8dd5			;		sub l 
8dd5			;		ret m 
8dd5			;		ld a, l 
8dd5					; if no special key then insert as a char 
8dd5			 
8dd5 c3 9e 8e				jp input_inschr 
8dd8			 
8dd8				 
8dd8			input_nxtword: 
8dd8				; jump to start next word after the cursor 
8dd8			 
8dd8			.insknwn:	 
8dd8 cd 94 8e				call input_curptr	 
8ddb 7e					ld a,(hl)	 
8ddc fe 00				cp 0 
8dde ca 3d 8d				jp z, .inmain    ; end of string 
8de1			 
8de1			; if we are on a word, then move off of it 
8de1			 
8de1 fe 20				cp ' ' 
8de3 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8de5 21 4c ee				ld hl, input_cursor 
8de8 34					inc (hl) 
8de9 18 ed				jr .insknwn 
8deb			 
8deb			.inspace: 
8deb			 
8deb cd 94 8e				call input_curptr	 
8dee 7e					ld a,(hl)	 
8def fe 00				cp 0 
8df1 ca 3d 8d				jp z, .inmain    ; end of string 
8df4			 
8df4			; if we are on a word, then move off of it 
8df4			 
8df4 fe 20				cp ' ' 
8df6 c2 3d 8d				jp nz, .inmain     ; we are on non space so at next word 
8df9 21 4c ee				ld hl, input_cursor 
8dfc 34					inc (hl) 
8dfd 18 ec				jr .inspace 
8dff			 
8dff			 
8dff			 
8dff			 
8dff			input_prvword: 
8dff				; jump to the start of previous word before the cursor 
8dff			 
8dff			; where are we to start with currently? 
8dff			 
8dff cd 94 8e				call input_curptr	 
8e02 7e					ld a, (hl) 
8e03 fe 20				cp ' ' 
8e05 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8e07			 
8e07			 
8e07			 
8e07			.inskpwn:	 
8e07 3a 4c ee				ld a,(input_cursor) 
8e0a fe 00				cp 0 
8e0c ca 3d 8d				jp z, .inmain    ; start of string 
8e0f			 
8e0f			;if we are on a word, then move off of it 
8e0f			 
8e0f cd 94 8e				call input_curptr	 
8e12 7e					ld a, (hl) 
8e13 fe 20				cp ' ' 
8e15 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8e17					;jp z, .inmain    ; start of string 
8e17 21 4c ee				ld hl, input_cursor 
8e1a 35					dec (hl) 
8e1b 18 ea				jr .inskpwn 
8e1d			.iwstart: 
8e1d 21 4c ee				ld hl, input_cursor 
8e20 34					inc (hl) 
8e21 c3 3d 8d				jp .inmain 
8e24					 
8e24			 
8e24			.inspacep: 
8e24			 
8e24					;jp .inmain    ; start of string 
8e24			 
8e24			 
8e24			 
8e24 3a 4c ee				ld a,(input_cursor) 
8e27 fe 00				cp 0 
8e29 ca 3d 8d				jp z, .inmain    ; start of string 
8e2c			 
8e2c			; if we are on a word, then move off of it 
8e2c			 
8e2c cd 94 8e				call input_curptr	 
8e2f 7e					ld a, (hl) 
8e30 fe 20				cp ' ' 
8e32 c2 3b 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e35 21 4c ee				ld hl, input_cursor 
8e38 35					dec (hl) 
8e39 18 e9				jr .inspacep 
8e3b			 
8e3b			 
8e3b			.incharp:	 
8e3b					; eat the word to get to the start 
8e3b 3a 4c ee				ld a,(input_cursor) 
8e3e fe 00				cp 0 
8e40 ca 3d 8d				jp z, .inmain    ; start of string 
8e43			 
8e43			; if we are on a word, then move off of it 
8e43			 
8e43 cd 94 8e				call input_curptr	 
8e46 7e					ld a, (hl) 
8e47 fe 20				cp ' ' 
8e49 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e4b 21 4c ee				ld hl, input_cursor 
8e4e 35					dec (hl) 
8e4f 18 ea				jr .incharp 
8e51			.ipwordst: 
8e51					; at space before the prev word so reposition over it 
8e51 21 4c ee				ld hl, input_cursor 
8e54 34					inc (hl) 
8e55 18 b0				jr .inskpwn 
8e57					 
8e57			 
8e57			 
8e57			input_left: 
8e57				; move cursor left 
8e57 21 4c ee			ld hl, input_cursor 
8e5a 35				dec (hl) 
8e5b			;	cp 0 
8e5b			;	jp z, .inmain    ; ignore left as at the start of the string 
8e5b c3 3d 8d			jp .inmain 
8e5e			 
8e5e			input_right: 
8e5e				; move cursor right 
8e5e				 
8e5e				;ld a, (input_size) 
8e5e				;ld b, a 
8e5e 21 4c ee			ld hl, input_cursor 
8e61 34				inc (hl) 
8e62				;dec b 
8e62				;cp 0 
8e62				;jp z, .inmain   ; ignore as at end of the string buffer 
8e62				;ld a, b 
8e62				;inc a 
8e62				;ld (input_cursor), a 
8e62 c3 3d 8d			jp .inmain 
8e65			 
8e65			 
8e65			 
8e65			input_disp_ref: 
8e65				; display the text from start of buffer (ie full refresh) 
8e65 3a 5b ee			ld a, (input_at_pos) 
8e68 2a 5e ee			ld hl,(input_start) 
8e6b eb				ex de, hl 
8e6c cd d0 8a			call str_at_display  
8e6f c9				ret 
8e70			input_disp_oncur: 
8e70				; display the text from cursor position to end of buffer 
8e70				; TODO position start of string at cursor position on screen 
8e70				; TODO draw from that point on 
8e70 3a 4c ee			ld a, (input_cursor) 
8e73 47				ld b, a 
8e74 3a 5b ee			ld a, (input_at_pos) 
8e77 80				add b 
8e78 48				ld c, b     ; save a 
8e79 78				ld a, b     ; inc string start for cursor 
8e7a 2a 5e ee			ld hl,(input_start) 
8e7d cd ea 8c			call addatohl 
8e80 eb				ex de, hl 
8e81 79				ld a, c 
8e82 cd d0 8a			call str_at_display  
8e85 c9				ret 
8e86			 
8e86			input_nxtw: 
8e86				; Find next word 
8e86 c9				ret 
8e87			 
8e87			input_prvw: 
8e87				; Find previous word 
8e87 c9				ret 
8e88			 
8e88			input_lenrem:   
8e88				; Calculate the length of string remaining from current cursor 
8e88				; position to end of buffer (exc null term) 
8e88				 
8e88 3a 4c ee			ld a, (input_cursor) 
8e8b 4f				ld c, a 
8e8c 3a 5d ee			ld a, (input_size) 
8e8f 91				sub c 
8e90 06 00			ld b, 0 
8e92 0d				dec c 
8e93 c9				ret	 
8e94			 
8e94			input_curptr: 
8e94				; calc address of the character under the cursor 
8e94				 
8e94 2a 5e ee			ld hl, (input_start) 
8e97 3a 4c ee			ld a, (input_cursor) 
8e9a cd ea 8c			call addatohl 
8e9d c9				ret 
8e9e			 
8e9e			input_inschr: 
8e9e				; Insert char at cursor position 
8e9e f5				push af   ; save char 
8e9f				;call input_lenrem    ; get bc length of remaining string 
8e9f			 
8e9f				 
8e9f cd 94 8e			call input_curptr 
8ea2			;	ld hl, (input_start) 
8ea2			;	ld a, (input_cursor) 
8ea2			;	call addatohl 
8ea2				;push hl   ; save to come back to 
8ea2			 
8ea2				; shift everything up one to end of buffer 
8ea2			 
8ea2				;push hl 
8ea2				;dec de 
8ea2				;inc de 
8ea2			;	ldir 
8ea2				 
8ea2				;pop hl 
8ea2			 
8ea2				; are we adding to the end of line? 
8ea2			 
8ea2 3a 4c ee			ld a, (input_cursor) 
8ea5 47				ld b, a 
8ea6 3a 51 ee			ld a, (input_len) 
8ea9 b8				cp b 
8eaa 20 09			jr nz, .insmid   ; no, insert in middle of text 
8eac			 
8eac				; tack on the end of the line 
8eac f1				pop af 
8ead 77				ld (hl), a   ; save new char 
8eae 23				inc hl 
8eaf 3e 00			ld a, 0 
8eb1 77				ld (hl), a 
8eb2 c3 5e 8e			jp input_right 
8eb5				 
8eb5			.insmid: 
8eb5				; hl has insertion point so move everything up one to allow for insertion 
8eb5				;call input_shiftright 
8eb5 f1				pop af 
8eb6			 
8eb6			.shufinsmid: 
8eb6 47				ld b, a     ; b contains new char, c prev char at this position  
8eb7 7e				ld a, (hl) 
8eb8			 
8eb8 fe 00			cp 0    ; at end of string need to then dump new char and add term 
8eba 28 07			jr z, .endinsmid 
8ebc 4f				ld c, a 
8ebd 78				ld a, b 
8ebe 77				ld (hl), a 
8ebf 23				inc hl 
8ec0 79				ld a, c 
8ec1 18 f3			jr .shufinsmid 
8ec3				 
8ec3			 
8ec3			 
8ec3			 
8ec3			.endinsmid: 
8ec3 78				ld a, b 
8ec4 77				ld (hl), a 
8ec5 23				inc hl 
8ec6 3e 00			ld a, 0 
8ec8 77				ld (hl), a 
8ec9			 
8ec9			 
8ec9			;	ld (hl), a   ; save new char 
8ec9			 
8ec9 c3 5e 8e			jp input_right 
8ecc			 
8ecc			;input_shiftright: 
8ecc			;	; shift text right at cursor, hl has shift start 
8ecc			;	push hl 
8ecc			;	push de 
8ecc			;	push bc 
8ecc			; 
8ecc			; 
8ecc			;	; move to end of string past zero term 
8ecc			;	ld hl,(input_start) 
8ecc			;	ld a, (input_len) 
8ecc			;	call addatohl 
8ecc			;	inc hl 
8ecc			;;	inc hl 
8ecc			;;	inc hl 
8ecc			;	ld a, 0 
8ecc			;	ld (hl), a 
8ecc			;;	dec hl 
8ecc			;	 
8ecc			;;	ld (hl), a 
8ecc			;;	dec hl 
8ecc			; 
8ecc			;	push hl 
8ecc			;	pop de 
8ecc			;	inc de 
8ecc			;	 
8ecc			; 
8ecc			;;	ld hl,(input_start) 
8ecc			;;	ld a, (input_cursor) 
8ecc			;;	call addatohl 
8ecc			; 
8ecc			; 
8ecc			;	; calc how many bytes from cursor pos to end of string we need to shift 
8ecc			;	call input_lenrem    ; get bc length of remaining string 
8ecc			;	;ld a, (input_cursor) 
8ecc			;	;ld c, a 
8ecc			;	ld a, (input_len) 
8ecc			;	cp 2 
8ecc			;	jr z, .iskipzero	 
8ecc			;	;sub c 
8ecc			;	;inc a 
8ecc			;	;ld c, a 
8ecc			;	;ld b, 0 
8ecc			;	inc c 
8ecc			;	inc c 
8ecc			;	; move data 
8ecc			;	lddr 
8ecc			;.iskipzero: 
8ecc			; 
8ecc			;	pop bc 
8ecc			;	pop de 
8ecc			;	pop hl 
8ecc			;	ret	 
8ecc			 
8ecc			input_delchar: 
8ecc				; Delete char at cursor position 
8ecc cd 88 8e			call input_lenrem    ; get bc length of remaining string 
8ecf 2a 5e ee			ld hl, (input_start) 
8ed2 3a 4c ee			ld a, (input_cursor) 
8ed5 cd ea 8c			call addatohl 
8ed8			 
8ed8 e5				push hl 
8ed9 d1				pop de 
8eda 1b				dec de 
8edb			 
8edb			.dl:	 
8edb ed a0			ldi  
8edd 7e				ld a, (hl) 
8ede fe 00			cp 0 
8ee0 28 02			jr z, .dldone 
8ee2 18 f7			jr .dl 
8ee4			.dldone: 
8ee4 ed a0			ldi 
8ee6			 
8ee6 c3 57 8e			jp input_left 
8ee9			 
8ee9			 
8ee9			endif 
8ee9			 
8ee9			 
8ee9			 
8ee9			if EDIT_V1 
8ee9			input_str: 
8ee9			 
8ee9				    	ld (input_at_pos),a      ; save display position to start 
8ee9					add c 
8ee9					ld (input_at_cursor),a	; save draw pos of cursor 
8ee9					ld (input_start), hl     ; save ptr to buffer 
8ee9					ld a, c 
8ee9					call addatohl 
8ee9					ld (input_ptr), hl     ; save ptr to point under the cursor 
8ee9					ld a,d 
8ee9				        ld (input_size), a       ; save length of input area 
8ee9					ld a, c 
8ee9					ld (input_cursor),a      ; init cursor start position  
8ee9					ld a,e 
8ee9				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ee9					 
8ee9					 
8ee9			 
8ee9			;		ld a,(input_ptr) 
8ee9			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ee9			 
8ee9			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ee9					; init cursor shape if not set by the cin routines 
8ee9					ld hl, cursor_shape 
8ee9			if BASE_KEV 
8ee9					ld a, 255 
8ee9			else 
8ee9					ld a, '#' 
8ee9			endif 
8ee9					ld (hl), a 
8ee9					inc hl 
8ee9					ld a, 0 
8ee9					ld (hl), a 
8ee9			 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9					ld a, 1 
8ee9					ld (input_cur_onoff),a 
8ee9			 
8ee9			;	if DEBUG_INPUT 
8ee9			;		push af 
8ee9			;		ld a, 'I' 
8ee9			;		ld (debug_mark),a 
8ee9			;		pop af 
8ee9			;		CALLMONITOR 
8ee9			;	endif 
8ee9			.is1:		; main entry loop 
8ee9			 
8ee9			 
8ee9			 
8ee9					; pause 1ms 
8ee9			 
8ee9					ld a, 1 
8ee9					call aDelayInMS 
8ee9			 
8ee9					; dec flash counter 
8ee9					ld a, (input_cur_flash) 
8ee9					dec a 
8ee9					ld (input_cur_flash), a 
8ee9					cp 0 
8ee9					jr nz, .nochgstate 
8ee9			 
8ee9			 
8ee9					; change state 
8ee9					ld a,(input_cur_onoff) 
8ee9					neg 
8ee9					ld (input_cur_onoff),a 
8ee9			 
8ee9			 
8ee9					; reset on change of state 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9			.nochgstate: 
8ee9					 
8ee9					 
8ee9			 
8ee9					; display cursor  
8ee9			 
8ee9			;		ld hl, (input_start) 
8ee9			;		ld a, (input_cursor) 
8ee9			;		call addatohl 
8ee9			 
8ee9					; get char under cursor and replace with cursor 
8ee9			ld hl, (input_ptr) 
8ee9			;		ld a, (hl) 
8ee9			;		ld (input_under_cursor),a 
8ee9			;		ld a, '_' 
8ee9			;		ld (hl), a 
8ee9			 
8ee9					; display string 
8ee9			 
8ee9					ld de, (input_start) 
8ee9					ld a, (input_at_pos) 
8ee9					call str_at_display 
8ee9			;	        call update_display 
8ee9			 
8ee9					; find place to put the cursor 
8ee9			;		add h 
8ee9			;		ld l, display_row_1 
8ee9			;		sub l 
8ee9			; (input_at_pos) 
8ee9					;ld c, a 
8ee9			;		ld a, (input_cursor) 
8ee9			;		ld l, (input_at_pos) 
8ee9			;		;ld b, h 
8ee9			;		add l 
8ee9			;		ld (input_at_cursor),a 
8ee9					;ld l,h 
8ee9			 
8ee9			;		ld h, 0 
8ee9			;		ld l,(input_at_pos) 
8ee9			;		ld a, (input_cursor) 
8ee9			;		call addatohl 
8ee9			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ee9			;		call subafromhl 
8ee9			;		ld a,l 
8ee9			;		ld (input_at_cursor), a 
8ee9			 
8ee9				if DEBUG_INPUT 
8ee9					ld a, (hardware_diag) 
8ee9					cp 0 
8ee9					jr z, .skip_input_diag 
8ee9			 
8ee9					ld a,(input_at_pos) 
8ee9					ld hl, LFSRSeed 
8ee9					call hexout 
8ee9					ld a, (input_cursor) 
8ee9					ld hl, LFSRSeed+2 
8ee9					call hexout 
8ee9					ld a,(input_at_cursor) 
8ee9					ld hl, LFSRSeed+4 
8ee9					call hexout 
8ee9			 
8ee9					ld a,(input_cur_onoff) 
8ee9					ld hl, LFSRSeed+6 
8ee9					call hexout 
8ee9			 
8ee9					ld a,(input_cur_flash) 
8ee9					ld hl, LFSRSeed+8 
8ee9					call hexout 
8ee9			 
8ee9					ld a,(input_len) 
8ee9					ld hl, LFSRSeed+10 
8ee9					call hexout 
8ee9					ld hl, LFSRSeed+12 
8ee9					ld a, 0 
8ee9					ld (hl),a 
8ee9					ld a, display_row_4 
8ee9					ld de, LFSRSeed 
8ee9					call str_at_display 
8ee9					.skip_input_diag: 
8ee9				endif 
8ee9			 
8ee9					; decide on if we are showing the cursor this time round 
8ee9			 
8ee9					ld a, (input_cur_onoff) 
8ee9					cp 255 
8ee9					jr z, .skipcur 
8ee9			 
8ee9			 
8ee9					ld a,(input_at_cursor) 
8ee9					ld de, cursor_shape 
8ee9					call str_at_display 
8ee9			 
8ee9					; save length of current input string 
8ee9					ld hl, (input_start) 
8ee9					ld a, 0 
8ee9					call strlent 
8ee9					ld a,l 
8ee9					ld (input_len),a 
8ee9			 
8ee9			.skipcur: 
8ee9			 
8ee9				        call update_display 
8ee9					 
8ee9			 
8ee9			 
8ee9					; wait 
8ee9				 
8ee9					; TODO loop without wait to flash the cursor and char under cursor	 
8ee9					call cin    ; _wait 
8ee9			 
8ee9					cp 0 
8ee9					jp z, .is1 
8ee9			 
8ee9					; get ptr to char to input into 
8ee9			 
8ee9					ld c,a 
8ee9					ld hl, (input_start) 
8ee9					ld a, (input_cursor) 
8ee9					call addatohl 
8ee9					ld (input_ptr), hl 
8ee9					ld a,c 
8ee9			 
8ee9					; replace char under cursor 
8ee9			 
8ee9			;		ld hl, (input_ptr) 
8ee9			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ee9			;		ld (hl), a 
8ee9			 
8ee9			;	if DEBUG_INPUT 
8ee9			;		push af 
8ee9			;		ld a, 'i' 
8ee9			;		ld (debug_mark),a 
8ee9			;		pop af 
8ee9			;		CALLMONITOR 
8ee9			;	endif 
8ee9					cp KEY_HOME 
8ee9					jr nz, .iske 
8ee9			 
8ee9					ld a, (input_at_pos) 
8ee9					ld (input_at_cursor),a 
8ee9					ld a, 0 
8ee9					ld (input_cursor), a 
8ee9					jp .is1 
8ee9					 
8ee9			.iske:		cp KEY_END 
8ee9					jr nz, .isknw 
8ee9					jp .is1 
8ee9			 
8ee9			.isknw:		cp KEY_NEXTWORD 
8ee9					jr nz, .iskpw 
8ee9			 
8ee9			.isknwm:	ld hl, (input_ptr) 
8ee9					ld a,(hl)	 
8ee9					cp 0 
8ee9					jp z, .is1    ; end of string 
8ee9					cp ' ' 
8ee9					jp z, .is1    ; end of word 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9					jr .isknwm 
8ee9			 
8ee9			.iskpw:		cp KEY_PREVWORD 
8ee9					jr nz, .iskl 
8ee9			.iskpwm:	 
8ee9					ld hl, (input_ptr) 
8ee9					ld a,(hl)	 
8ee9					cp 0  
8ee9					jp z, .is1    ; end of string 
8ee9					cp ' ' 
8ee9					jp z, .is1    ; end of word 
8ee9					dec hl 
8ee9					ld (input_ptr), hl 
8ee9					ld a, (input_at_cursor) 
8ee9					dec a 
8ee9					ld (input_at_cursor), a 
8ee9					jr .iskpwm 
8ee9			 
8ee9			 
8ee9			.iskl:		cp KEY_LEFT 
8ee9					jr nz, .isk1 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9			 
8ee9					cp 0 
8ee9					jp z, .is1 		; at start of line to ignore  
8ee9			 
8ee9					dec  a 		; TODO check underflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					dec hl 
8ee9					ld (input_ptr), hl 
8ee9					 
8ee9					ld a, (input_at_cursor) 
8ee9					dec a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk1:		cp KEY_RIGHT 
8ee9					jr nz, .isk2 
8ee9			 
8ee9					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ee9					ld e,a 
8ee9					ld a, (input_cursor) 
8ee9					cp e 
8ee9					jp z, .is1		; at the end of string so dont go right 
8ee9			 
8ee9					inc  a 		; TODO check overflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk2:		cp KEY_UP 
8ee9			 
8ee9					jr nz, .isk3 
8ee9			 
8ee9					; swap last command with the current on 
8ee9			 
8ee9					; move cursor to start of string 
8ee9					ld hl, (input_start) 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					ld a, (input_at_pos) 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld a, 0 
8ee9					ld (input_cursor), a 
8ee9					 
8ee9					; swap input and last command buffers 
8ee9			 
8ee9					ld hl, os_cli_cmd 
8ee9					ld de, os_last_cmd 
8ee9					ld b, 255 
8ee9			.swap1:		ld a, (hl) 
8ee9					ld c,a 
8ee9					ld a, (de) 
8ee9					ld (hl), a 
8ee9					ld a,c 
8ee9					ld (de),a 
8ee9					inc hl 
8ee9					inc de 
8ee9					djnz .swap1 
8ee9			 
8ee9			 
8ee9			 
8ee9			 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk3:		cp KEY_BS 
8ee9					jr nz, .isk4 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9			 
8ee9					cp 0 
8ee9					jp z, .is1 		; at start of line to ignore  
8ee9			 
8ee9					dec  a 		; TODO check underflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					; hl is source 
8ee9					; de needs to be source - 1 
8ee9			 
8ee9			;		ld a, 0 
8ee9			;		dec hl 
8ee9			;		ld (hl), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					dec hl 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					; shift all data 
8ee9			 
8ee9					push hl 
8ee9					inc hl 
8ee9					pop de 
8ee9					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8ee9					ld c,a 
8ee9					ld b,0 
8ee9					ldir  
8ee9			 
8ee9			 
8ee9			 
8ee9			 
8ee9					ld a, (input_at_cursor) 
8ee9					dec a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9			 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9			 
8ee9					; remove char 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld de,.iblank 
8ee9					call str_at_display 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.isk4:		cp KEY_CR 
8ee9					jr z, .endinput 
8ee9			 
8ee9					; else add the key press to the end 
8ee9			 
8ee9					ld c, a			; save key pressed 
8ee9			 
8ee9					ld a,(hl)		; get what is currently under char 
8ee9			 
8ee9					cp 0			; we are at the end of the string 
8ee9					jr nz, .onchar 
8ee9					 
8ee9					; add a char to the end of the string 
8ee9				 
8ee9					ld (hl),c 
8ee9					inc hl 
8ee9			;		ld a,' ' 
8ee9			;		ld (hl),a 
8ee9			;		inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9					dec hl 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9					inc a				; TODO check max string length and scroll  
8ee9					ld (input_cursor), a		; inc cursor pos 
8ee9							 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					inc hl 
8ee9					ld (input_ptr), hl 
8ee9			;	if DEBUG_INPUT 
8ee9			;		push af 
8ee9			;		ld a, '+' 
8ee9			;		ld (debug_mark),a 
8ee9			;		pop af 
8ee9			;		CALLMONITOR 
8ee9			;	endif 
8ee9					ld a, 1		; show cursor moving 
8ee9					ld (input_cur_onoff),a 
8ee9					ld a, CUR_BLINK_RATE 
8ee9					ld (input_cur_flash), a 
8ee9					jp .is1 
8ee9					 
8ee9			 
8ee9			 
8ee9					; if on a char then insert 
8ee9			.onchar: 
8ee9			 
8ee9					; TODO over flow check: make sure insert does not blow out buffer 
8ee9			 
8ee9					; need to do some maths to use lddr 
8ee9			 
8ee9					push hl   ; save char pos 
8ee9					push bc 
8ee9			 
8ee9					ld hl, (input_start) 
8ee9					ld a, (input_len) 
8ee9					call addatohl  		; end of string 
8ee9					inc hl 
8ee9					inc hl		; past zero term 
8ee9					push hl 
8ee9					inc hl 
8ee9					push hl  
8ee9			 
8ee9								; start and end of lddr set, now how much to move? 
8ee9			 
8ee9							 
8ee9					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ee9					ld b,a 
8ee9					ld a,(input_len) 
8ee9					ld e,a 
8ee9					sub b 
8ee9					inc a		;?? 
8ee9					inc a		;?? 
8ee9					inc a		;?? 
8ee9			 
8ee9					ld b,0 
8ee9					ld c,a 
8ee9			 
8ee9				if DEBUG_INPUT 
8ee9					push af 
8ee9					ld a, 'i' 
8ee9					ld (debug_mark),a 
8ee9					pop af 
8ee9			;		CALLMONITOR 
8ee9				endif 
8ee9					pop de 
8ee9					pop hl 
8ee9				if DEBUG_INPUT 
8ee9					push af 
8ee9					ld a, 'I' 
8ee9					ld (debug_mark),a 
8ee9					pop af 
8ee9			;		CALLMONITOR 
8ee9				endif 
8ee9					lddr 
8ee9				 
8ee9			 
8ee9			 
8ee9					; TODO have a key for insert/overwrite mode???? 
8ee9					pop bc 
8ee9					pop hl 
8ee9					ld (hl), c		; otherwise overwrite current char 
8ee9					 
8ee9			 
8ee9			 
8ee9			 
8ee9					ld a, (input_cursor) 
8ee9					inc  a 		; TODO check overflow 
8ee9					ld (input_cursor), a 
8ee9			 
8ee9					ld a, (input_at_cursor) 
8ee9					inc a 
8ee9					ld (input_at_cursor), a 
8ee9			 
8ee9					jp .is1 
8ee9			 
8ee9			.endinput:	; TODO look for end of string 
8ee9			 
8ee9					; add trailing space for end of token 
8ee9			 
8ee9					ld hl, (input_start) 
8ee9					ld a,(input_len) 
8ee9					call addatohl 
8ee9					ld a, ' ' 
8ee9					ld (hl),a 
8ee9					; TODO eof of parse marker 
8ee9			 
8ee9					inc hl 
8ee9					ld a, 0 
8ee9					ld (hl),a 
8ee9			 
8ee9			 
8ee9					ret 
8ee9			 
8ee9			.iblank: db " ",0 
8ee9			 
8ee9			 
8ee9			input_str_prev:	ld (input_at_pos), a 
8ee9					ld (input_start), hl 
8ee9					ld a,1			; add cursor 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9					ld (input_ptr), hl 
8ee9					ld a,d 
8ee9					ld (input_size), a 
8ee9					ld a,0 
8ee9					ld (input_cursor),a 
8ee9			.instr1:	 
8ee9			 
8ee9					; TODO do block cursor 
8ee9					; TODO switch cursor depending on the modifer key 
8ee9			 
8ee9					; update cursor shape change on key hold 
8ee9			 
8ee9					ld hl, (input_ptr) 
8ee9					dec hl 
8ee9					ld a,(cursor_shape) 
8ee9					ld (hl), a 
8ee9			 
8ee9					; display entered text 
8ee9					ld a,(input_at_pos) 
8ee9			            	CALL fLCD_Pos       ;Position cursor to location in A 
8ee9			            	LD   de, (input_start) 
8ee9			            	CALL fLCD_Str       ;Display string pointed to by DE 
8ee9			 
8ee9					call cin 
8ee9					cp 0 
8ee9					jr z, .instr1 
8ee9			 
8ee9					; proecess keyboard controls first 
8ee9			 
8ee9					ld hl,(input_ptr) 
8ee9			 
8ee9					cp KEY_CR	 ; pressing enter ends input 
8ee9					jr z, .instrcr 
8ee9			 
8ee9					cp KEY_BS 	; back space 
8ee9					jr nz, .instr2 
8ee9					; process back space 
8ee9			 
8ee9					; TODO stop back space if at start of string 
8ee9					dec hl 
8ee9					dec hl ; to over write cursor 
8ee9					ld a,(cursor_shape) 
8ee9					;ld a,0 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a," " 
8ee9					ld (hl),a 
8ee9					ld (input_ptr),hl 
8ee9					 
8ee9			 
8ee9					jr .instr1 
8ee9			 
8ee9			.instr2:	cp KEY_LEFT    ; cursor left 
8ee9					jr nz, .instr3 
8ee9					dec hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9				 
8ee9			.instr3:	cp KEY_RIGHT      ; cursor right 
8ee9					jr nz, .instr4 
8ee9					inc hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9			 
8ee9			.instr4:	cp KEY_HOME    ; jump to start of line 
8ee9					jr nz, .instr5 
8ee9					dec hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9			 
8ee9			.instr5:	cp KEY_END     ; jump to end of line 
8ee9					jr nz, .instr6 
8ee9					dec hl 
8ee9					ld (input_ptr),hl 
8ee9					jr .instr1 
8ee9			.instr6:        cp KEY_UP      ; recall last command 
8ee9					jr nz, .instrnew 
8ee9			 
8ee9				ld hl, scratch 
8ee9				ld de, os_last_cmd 
8ee9				call strcpy 
8ee9					jr .instr1 
8ee9			 
8ee9			 
8ee9			.instrnew:	; no special key pressed to see if we have room to store it 
8ee9			 
8ee9					; TODO do string size test 
8ee9			 
8ee9					dec hl ; to over write cursor 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,(cursor_shape) 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9			 
8ee9					ld (input_ptr),hl 
8ee9					 
8ee9					jr .instr1 
8ee9			.instrcr:	dec hl		; remove cursor 
8ee9					ld a,' '	; TODO add a trailing space for safety 
8ee9					ld (hl),a 
8ee9					inc hl 
8ee9					ld a,0 
8ee9					ld (hl),a 
8ee9			 
8ee9			 
8ee9					; if at end of line scroll up    
8ee9					; TODO detecting only end of line 4 for scroll up  
8ee9			 
8ee9					;ld   
8ee9			 
8ee9					ret 
8ee9			 
8ee9			 
8ee9			endif 
8ee9			; strcpy hl = dest, de source 
8ee9			 
8ee9 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8eea b7			            OR   A              ;Null terminator? 
8eeb c8			            RET  Z              ;Yes, so finished 
8eec 1a					ld a,(de) 
8eed 77					ld (hl),a 
8eee 13			            INC  DE             ;Point to next character 
8eef 23					inc hl 
8ef0 18 f7		            JR   strcpy       ;Repeat 
8ef2 c9					ret 
8ef3			 
8ef3			 
8ef3			; TODO string_at  
8ef3			; pass string which starts with lcd offset address and then null term string 
8ef3			 
8ef3			; TODO string to dec 
8ef3			; TODO string to hex 
8ef3			; TODO byte to string hex 
8ef3			; TODO byte to string dec 
8ef3			 
8ef3			 
8ef3			 
8ef3			; from z80uartmonitor 
8ef3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ef3			; pass hl for where to put the text 
8ef3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef3 c5			hexout:	PUSH BC 
8ef4 f5					PUSH AF 
8ef5 47					LD B, A 
8ef6					; Upper nybble 
8ef6 cb 3f				SRL A 
8ef8 cb 3f				SRL A 
8efa cb 3f				SRL A 
8efc cb 3f				SRL A 
8efe cd 0e 8f				CALL tohex 
8f01 77					ld (hl),a 
8f02 23					inc hl	 
8f03					 
8f03					; Lower nybble 
8f03 78					LD A, B 
8f04 e6 0f				AND 0FH 
8f06 cd 0e 8f				CALL tohex 
8f09 77					ld (hl),a 
8f0a 23					inc hl	 
8f0b					 
8f0b f1					POP AF 
8f0c c1					POP BC 
8f0d c9					RET 
8f0e					 
8f0e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0e			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8f0e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0e			tohex: 
8f0e e5					PUSH HL 
8f0f d5					PUSH DE 
8f10 16 00				LD D, 0 
8f12 5f					LD E, A 
8f13 21 1b 8f				LD HL, .DATA 
8f16 19					ADD HL, DE 
8f17 7e					LD A, (HL) 
8f18 d1					POP DE 
8f19 e1					POP HL 
8f1a c9					RET 
8f1b			 
8f1b			.DATA: 
8f1b 30					DEFB	30h	; 0 
8f1c 31					DEFB	31h	; 1 
8f1d 32					DEFB	32h	; 2 
8f1e 33					DEFB	33h	; 3 
8f1f 34					DEFB	34h	; 4 
8f20 35					DEFB	35h	; 5 
8f21 36					DEFB	36h	; 6 
8f22 37					DEFB	37h	; 7 
8f23 38					DEFB	38h	; 8 
8f24 39					DEFB	39h	; 9 
8f25 41					DEFB	41h	; A 
8f26 42					DEFB	42h	; B 
8f27 43					DEFB	43h	; C 
8f28 44					DEFB	44h	; D 
8f29 45					DEFB	45h	; E 
8f2a 46					DEFB	46h	; F 
8f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f2b			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f2b			;;    subtract $30, if result > 9 then subtract $7 more 
8f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f2b			atohex: 
8f2b d6 30				SUB $30 
8f2d fe 0a				CP 10 
8f2f f8					RET M		; If result negative it was 0-9 so we're done 
8f30 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f32 c9					RET		 
8f33			 
8f33			 
8f33			 
8f33			 
8f33			; Get 2 ASCII characters as hex byte from pointer in hl 
8f33			 
8f33			BYTERD: 
8f33 16 00			LD	D,00h		;Set up 
8f35 cd 3d 8f			CALL	HEXCON		;Get byte and convert to hex 
8f38 87				ADD	A,A		;First nibble so 
8f39 87				ADD	A,A		;multiply by 16 
8f3a 87				ADD	A,A		; 
8f3b 87				ADD	A,A		; 
8f3c 57				LD	D,A		;Save hi nibble in D 
8f3d			HEXCON: 
8f3d 7e				ld a, (hl)		;Get next chr 
8f3e 23				inc hl 
8f3f d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f41 fe 0a			CP	00Ah		;Is it 0-9 ? 
8f43 38 02			JR	C,NALPHA	;If so miss next bit 
8f45 d6 07			SUB	007h		;Else convert alpha 
8f47			NALPHA: 
8f47 b2				OR	D		;Add hi nibble back 
8f48 c9				RET			; 
8f49			 
8f49			 
8f49			; 
8f49			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f49			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f49			; characters (0-9a-f) are accepted. 
8f49			; 
8f49			;get_word        push    af 
8f49			;                call    get_byte        ; Get the upper byte 
8f49			;                ld      h, a 
8f49			;                call    get_byte        ; Get the lower byte 
8f49			;                ld      l, a 
8f49			;                pop     af 
8f49			;                ret 
8f49			; 
8f49			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f49			; the routine get_nibble is used only valid characters are accepted - the  
8f49			; input routine only accepts characters 0-9a-f. 
8f49			; 
8f49 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f4a 7e					ld a,(hl) 
8f4b 23					inc hl 
8f4c cd 71 8f		                call    nibble2val      ; Get upper nibble 
8f4f cb 07		                rlc     a 
8f51 cb 07		                rlc     a 
8f53 cb 07		                rlc     a 
8f55 cb 07		                rlc     a 
8f57 47			                ld      b, a            ; Save upper four bits 
8f58 7e					ld a,(hl) 
8f59 cd 71 8f		                call    nibble2val      ; Get lower nibble 
8f5c b0			                or      b               ; Combine both nibbles 
8f5d c1			                pop     bc              ; Restore B (and C) 
8f5e c9			                ret 
8f5f			; 
8f5f			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f5f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f5f			; to the serial line interface. The lower 4 bits of A contain the value of  
8f5f			; that particular digit. 
8f5f			; 
8f5f			;get_nibble      ld a,(hl)           ; Read a character 
8f5f			;                call    to_upper        ; Convert to upper case 
8f5f			;                call    is_hex          ; Was it a hex digit? 
8f5f			;                jr      nc, get_nibble  ; No, get another character 
8f5f			 ;               call    nibble2val      ; Convert nibble to value 
8f5f			 ;               call    print_nibble 
8f5f			 ;               ret 
8f5f			; 
8f5f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f5f			; A valid hexadecimal digit is denoted by a set C flag. 
8f5f			; 
8f5f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f5f			;                ret     nc              ; Yes 
8f5f			;                cp      '0'             ; Less than '0'? 
8f5f			;                jr      nc, is_hex_1    ; No, continue 
8f5f			;                ccf                     ; Complement carry (i.e. clear it) 
8f5f			;                ret 
8f5f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f5f			;                ret     c               ; Yes 
8f5f			;                cp      'A'             ; Less than 'A'? 
8f5f			;                jr      nc, is_hex_2    ; No, continue 
8f5f			;                ccf                     ; Yes - clear carry and return 
8f5f			;                ret 
8f5f			;is_hex_2        scf                     ; Set carry 
8f5f			;                ret 
8f5f			; 
8f5f			; Convert a single character contained in A to upper case: 
8f5f			; 
8f5f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f61 d8			                ret     c 
8f62 fe 7b		                cp      'z' + 1         ; > 'z'? 
8f64 d0			                ret     nc              ; Nothing to do, either 
8f65 e6 5f		                and     $5f             ; Convert to upper case 
8f67 c9			                ret 
8f68			 
8f68			 
8f68			to_lower: 
8f68			 
8f68			   ; if char is in [A-Z] make it lower case 
8f68			 
8f68			   ; enter : a = char 
8f68			   ; exit  : a = lower case char 
8f68			   ; uses  : af 
8f68			 
8f68 fe 41		   cp 'A' 
8f6a d8			   ret c 
8f6b			    
8f6b fe 5b		   cp 'Z'+1 
8f6d d0			   ret nc 
8f6e			    
8f6e f6 20		   or $20 
8f70 c9			   ret 
8f71			 
8f71			; 
8f71			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f71			; corresponding value in A. 
8f71			; 
8f71 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f73 38 02		                jr      c, nibble2val_1 ; Yes 
8f75 d6 07		                sub     7               ; Adjust for A-F 
8f77 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f79 e6 0f		                and     $f              ; Only return lower 4 bits 
8f7b c9			                ret 
8f7c			; 
8f7c			; Print_nibble prints a single hex nibble which is contained in the lower  
8f7c			; four bits of A: 
8f7c			; 
8f7c			;print_nibble    push    af              ; We won't destroy the contents of A 
8f7c			;                and     $f              ; Just in case... 
8f7c			;                add     a, '0'             ; If we have a digit we are done here. 
8f7c			;                cp      '9' + 1         ; Is the result > 9? 
8f7c			;                jr      c, print_nibble_1 
8f7c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f7c			;print_nibble_1  call    putc            ; Print the nibble and 
8f7c			;                pop     af              ; restore the original value of A 
8f7c			;                ret 
8f7c			;; 
8f7c			;; Send a CR/LF pair: 
8f7c			; 
8f7c			;crlf            push    af 
8f7c			;                ld      a, cr 
8f7c			;                call    putc 
8f7c			;                ld      a, lf 
8f7c			;                call    putc 
8f7c			;                pop     af 
8f7c			;                ret 
8f7c			; 
8f7c			; Print_word prints the four hex digits of a word to the serial line. The  
8f7c			; word is expected to be in HL. 
8f7c			; 
8f7c			;print_word      push    hl 
8f7c			;                push    af 
8f7c			;                ld      a, h 
8f7c			;                call    print_byte 
8f7c			;                ld      a, l 
8f7c			;                call    print_byte 
8f7c			;                pop     af 
8f7c			;                pop     hl 
8f7c			;                ret 
8f7c			; 
8f7c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f7c			; The byte to be printed is expected to be in A. 
8f7c			; 
8f7c			;print_byte      push    af              ; Save the contents of the registers 
8f7c			;                push    bc 
8f7c			;                ld      b, a 
8f7c			;                rrca 
8f7c			;                rrca 
8f7c			;                rrca 
8f7c			;                rrca 
8f7c			;                call    print_nibble    ; Print high nibble 
8f7c			;                ld      a, b 
8f7c			;                call    print_nibble    ; Print low nibble 
8f7c			;                pop     bc              ; Restore original register contents 
8f7c			;                pop     af 
8f7c			;                ret 
8f7c			 
8f7c			 
8f7c			 
8f7c			 
8f7c			 
8f7c			fourehexhl:  
8f7c 7e				ld a,(hl) 
8f7d cd 2b 8f			call atohex 
8f80 cb 3f				SRL A 
8f82 cb 3f				SRL A 
8f84 cb 3f				SRL A 
8f86 cb 3f				SRL A 
8f88 47				ld b, a 
8f89 23				inc hl 
8f8a 7e				ld a,(hl) 
8f8b 23				inc hl 
8f8c cd 2b 8f			call atohex 
8f8f 80				add b 
8f90 57				ld d,a 
8f91 7e				ld a,(hl) 
8f92 cd 2b 8f			call atohex 
8f95 cb 3f				SRL A 
8f97 cb 3f				SRL A 
8f99 cb 3f				SRL A 
8f9b cb 3f				SRL A 
8f9d 47				ld b, a 
8f9e 23				inc hl 
8f9f 7e				ld a,(hl) 
8fa0 23				inc hl 
8fa1 cd 2b 8f			call atohex 
8fa4 80				add b 
8fa5 5f				ld e, a 
8fa6 d5				push de 
8fa7 e1				pop hl 
8fa8 c9				ret 
8fa9			 
8fa9			; pass hl. returns z set if the byte at hl is a digit 
8fa9			;isdigithl:  
8fa9			;	push bc 
8fa9			;	ld a,(hl) 
8fa9			;	cp ':' 
8fa9			;	jr nc, .isdf 		; > 
8fa9			;	cp '0' 
8fa9			;	jr c, .isdf		; < 
8fa9			; 
8fa9			;	; TODO find a better way to set z 
8fa9			; 
8fa9			;	ld b,a 
8fa9			;	cp b 
8fa9			;	pop bc 
8fa9			;	ret 
8fa9			; 
8fa9			;.isdf:	; not digit so clear z 
8fa9			; 
8fa9			;	; TODO find a better way to unset z 
8fa9			; 
8fa9			;	ld b,a 
8fa9			;	inc b 
8fa9			;	cp b 
8fa9			; 
8fa9			;	pop bc 
8fa9			;	ret 
8fa9				 
8fa9				 
8fa9			 
8fa9			 
8fa9			; pass hl as the four byte address to load 
8fa9			 
8fa9			get_word_hl:  
8fa9 e5				push hl 
8faa cd 49 8f			call get_byte 
8fad				 
8fad 47				ld b, a 
8fae			 
8fae e1				pop hl 
8faf 23				inc hl 
8fb0 23				inc hl 
8fb1			 
8fb1			; TODO not able to handle a-f  
8fb1 7e				ld a,(hl) 
8fb2			;	;cp ':' 
8fb2			;	cp 'g' 
8fb2			;	jr nc, .single_byte_hl 		; > 
8fb2			;	cp 'G' 
8fb2			;	jr nc, .single_byte_hl 		; > 
8fb2			;	cp '0' 
8fb2			;	jr c, .single_byte_hl		; < 
8fb2			 
8fb2				;call isdigithl 
8fb2 fe 00			cp 0 
8fb4 28 06			jr z, .single_byte_hl 
8fb6			 
8fb6			.getwhln:   ; hex word so get next byte 
8fb6			 
8fb6 cd 49 8f			call get_byte 
8fb9 6f				ld l, a 
8fba 60				ld h,b 
8fbb c9				ret 
8fbc 68			.single_byte_hl:   ld l,b 
8fbd 26 00				ld h,0 
8fbf c9					ret 
8fc0			 
8fc0			 
8fc0			 
8fc0			 
8fc0 21 d0 96			ld hl,asc+1 
8fc3			;	ld a, (hl) 
8fc3			;	call nibble2val 
8fc3 cd 49 8f			call get_byte 
8fc6			 
8fc6			;	call fourehexhl 
8fc6 32 ec e2			ld (scratch+52),a 
8fc9				 
8fc9 21 ea e2			ld hl,scratch+50 
8fcc 22 db e5			ld (os_cur_ptr),hl 
8fcf			 
8fcf c9				ret 
8fd0			 
8fd0			 
8fd0			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fd0			 
8fd0			; Decimal Unsigned Version 
8fd0			 
8fd0			;Number in a to decimal ASCII 
8fd0			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fd0			;Example: display a=56 as "056" 
8fd0			;input: a = number 
8fd0			;Output: a=0,value of a in the screen 
8fd0			;destroys af,bc (don't know about hl and de) 
8fd0			DispAToASCII: 
8fd0 0e 9c			ld	c,-100 
8fd2 cd dc 8f			call	.Na1 
8fd5 0e f6			ld	c,-10 
8fd7 cd dc 8f			call	.Na1 
8fda 0e ff			ld	c,-1 
8fdc 06 2f		.Na1:	ld	b,'0'-1 
8fde 04			.Na2:	inc	b 
8fdf 81				add	a,c 
8fe0 38 fc			jr	c,.Na2 
8fe2 91				sub	c		;works as add 100/10/1 
8fe3 f5				push af		;safer than ld c,a 
8fe4 78				ld	a,b		;char is in b 
8fe5			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fe5 f1				pop af		;safer than ld a,c 
8fe6 c9				ret 
8fe7			 
8fe7			; Decimal Signed Version 
8fe7			 
8fe7			; DispA 
8fe7			; -------------------------------------------------------------- 
8fe7			; Converts a signed integer value to a zero-terminated ASCII 
8fe7			; string representative of that value (using radix 10). 
8fe7			; -------------------------------------------------------------- 
8fe7			; INPUTS: 
8fe7			;     HL     Value to convert (two's complement integer). 
8fe7			;     DE     Base address of string destination. (pointer). 
8fe7			; -------------------------------------------------------------- 
8fe7			; OUTPUTS: 
8fe7			;     None 
8fe7			; -------------------------------------------------------------- 
8fe7			; REGISTERS/MEMORY DESTROYED 
8fe7			; AF HL 
8fe7			; -------------------------------------------------------------- 
8fe7			 
8fe7			;DispHLToASCII: 
8fe7			;   push    de 
8fe7			;   push    bc 
8fe7			; 
8fe7			;; Detect sign of HL. 
8fe7			;    bit    7, h 
8fe7			;    jr     z, ._DoConvert 
8fe7			; 
8fe7			;; HL is negative. Output '-' to string and negate HL. 
8fe7			;    ld     a, '-' 
8fe7			;    ld     (de), a 
8fe7			;    inc    de 
8fe7			; 
8fe7			;; Negate HL (using two's complement) 
8fe7			;    xor    a 
8fe7			;    sub    l 
8fe7			;    ld     l, a 
8fe7			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fe7			;    sbc    a, h 
8fe7			;    ld     h, a 
8fe7			; 
8fe7			;; Convert HL to digit characters 
8fe7			;._DoConvert: 
8fe7			;    ld     b, 0     ; B will count character length of number 
8fe7			;-   ld     a, 10 
8fe7			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fe7			;    push   af 
8fe7			;    inc    b 
8fe7			;    ld     a, h 
8fe7			;    or     l 
8fe7			;    jr     nz, - 
8fe7			; 
8fe7			;; Retrieve digits from stack 
8fe7			;-   pop    af 
8fe7			;    or     $30 
8fe7			;    ld     (de), a 
8fe7			;    inc    de 
8fe7			;    djnz   - 
8fe7			; 
8fe7			;; Terminate string with NULL 
8fe7			;    xor    a 
8fe7			;    ld     (de), a 
8fe7			; 
8fe7			;    pop    bc 
8fe7			;    pop    de 
8fe7			;    ret 
8fe7			 
8fe7			;Comments 
8fe7			; 
8fe7			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fe7			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fe7			;    Note that the output string will not be fixed-width. 
8fe7			; 
8fe7			;Example Usage 
8fe7			; 
8fe7			;    ld    hl, -1004 
8fe7			;    ld    de, OP1 
8fe7			;    call  DispA 
8fe7			;    ld    hl, OP1 
8fe7			;    syscall  PutS 
8fe7			 
8fe7			 
8fe7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fe7			 
8fe7			 
8fe7			;Converts an ASCII string to an unsigned 16-bit integer 
8fe7			;Quits when it reaches a non-decimal digit 
8fe7			 
8fe7			string_to_uint16: 
8fe7			atoui_16: 
8fe7			;Input: 
8fe7			;     DE points to the string 
8fe7			;Outputs: 
8fe7			;     HL is the result 
8fe7			;     A is the 8-bit value of the number 
8fe7			;     DE points to the byte after the number 
8fe7			;Destroys: 
8fe7			;     BC 
8fe7			;       if the string is non-empty, BC is HL/10 
8fe7			;Size:  24 bytes 
8fe7			;Speed: 42+d(104+{0,9}) 
8fe7			;       d is the number of digits in the number 
8fe7			;       max is 640 cycles for a 5 digit number 
8fe7			;Assuming no leading zeros: 
8fe7			;1 digit:  146cc 
8fe7			;2 digit:  250cc 
8fe7			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fe7			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fe7			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fe7			;avg: 544.81158447265625cc (544+13297/16384) 
8fe7			;=============================================================== 
8fe7 21 00 00		  ld hl,0 
8fea			.u16a: 
8fea 1a			  ld a,(de) 
8feb d6 30		  sub 30h 
8fed fe 0a		  cp 10 
8fef d0			  ret nc 
8ff0 13			  inc de 
8ff1 44			  ld b,h 
8ff2 4d			  ld c,l 
8ff3 29			  add hl,hl 
8ff4 29			  add hl,hl 
8ff5 09			  add hl,bc 
8ff6 29			  add hl,hl 
8ff7 85			  add a,l 
8ff8 6f			  ld l,a 
8ff9 30 ef		  jr nc,.u16a 
8ffb 24			  inc h 
8ffc c3 ea 8f		  jp .u16a 
8fff			 
8fff			 
8fff			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fff			 
8fff			;written by Zeda 
8fff			;Converts a 16-bit unsigned integer to an ASCII string. 
8fff			 
8fff			uitoa_16: 
8fff			;Input: 
8fff			;   DE is the number to convert 
8fff			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8fff			;Output: 
8fff			;   HL points to the null-terminated ASCII string 
8fff			;      NOTE: This isn't necessarily the same as the input HL. 
8fff d5			  push de 
9000 c5			  push bc 
9001 f5			  push af 
9002 eb			  ex de,hl 
9003			 
9003 01 f0 d8		  ld bc,-10000 
9006 3e 2f		  ld a,'0'-1 
9008 3c			  inc a 
9009 09			  add hl,bc  
900a 38 fc		   jr c,$-2 
900c 12			  ld (de),a 
900d 13			  inc de 
900e			 
900e 01 e8 03		  ld bc,1000 
9011 3e 3a		  ld a,'9'+1 
9013 3d			  dec a  
9014 09			  add hl,bc  
9015 30 fc		   jr nc,$-2 
9017 12			  ld (de),a 
9018 13			  inc de 
9019			 
9019 01 9c ff		  ld bc,-100 
901c 3e 2f		  ld a,'0'-1 
901e 3c			  inc a  
901f 09			  add hl,bc  
9020 38 fc		   jr c,$-2 
9022 12			  ld (de),a 
9023 13			  inc de 
9024			 
9024 7d			  ld a,l 
9025 26 3a		  ld h,'9'+1 
9027 25			  dec h  
9028 c6 0a		  add a,10  
902a 30 fb		   jr nc,$-3 
902c c6 30		  add a,'0' 
902e eb			  ex de,hl 
902f 72			  ld (hl),d 
9030 23			  inc hl 
9031 77			  ld (hl),a 
9032 23			  inc hl 
9033 36 00		  ld (hl),0 
9035			 
9035			;Now strip the leading zeros 
9035 0e fa		  ld c,-6 
9037 09			  add hl,bc 
9038 3e 30		  ld a,'0' 
903a 23			  inc hl  
903b be			  cp (hl)  
903c 28 fc		  jr z,$-2 
903e			 
903e			;Make sure that the string is non-empty! 
903e 7e			  ld a,(hl) 
903f b7			  or a 
9040 20 01		  jr nz,.atoub 
9042 2b			  dec hl 
9043			.atoub: 
9043			 
9043 f1			  pop af 
9044 c1			  pop bc 
9045 d1			  pop de 
9046 c9			  ret 
9047			 
9047			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9047			 
9047			toUpper: 
9047			;A is the char. 
9047			;If A is a lowercase letter, this sets it to the matching uppercase 
9047			;18cc or 30cc or 41cc 
9047			;avg: 26.75cc 
9047 fe 61		  cp 'a' 
9049 d8			  ret c 
904a fe 7b		  cp 'z'+1 
904c d0			  ret nc 
904d d6 20		  sub 'a'-'A' 
904f c9			  ret 
9050			 
9050			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9050			 
9050			; String Length 
9050			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9050			 
9050			; Get the length of the null-terminated string starting at $8000 hl 
9050			;    LD     HL, $8000 
9050			 
9050			strlenz: 
9050			 
9050 af			    XOR    A               ; Zero is the value we are looking for. 
9051 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9052 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9053			                           ; 65, 536 bytes (the entire addressable memory space). 
9053 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9055			 
9055			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9055 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9056 6f			    LD     L, A             ; number of bytes 
9057 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9059 2b			    DEC    HL              ; Compensate for null. 
905a c9				ret 
905b			 
905b			; Get the length of the A terminated string starting at $8000 hl 
905b			;    LD     HL, $8000 
905b			 
905b			strlent: 
905b			 
905b			                  ; A is the value we are looking for. 
905b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
905d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
905f			                           ; 65, 536 bytes (the entire addressable memory space). 
905f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9061			 
9061			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9061 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9063 2e 00		    LD     L, 0             ; number of bytes 
9065 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9067 2b			    DEC    HL              ; Compensate for null. 
9068 c9				ret 
9069			 
9069			 
9069			;Comparing Strings 
9069			 
9069			;IN    HL     Address of string1. 
9069			;      DE     Address of string2. 
9069			 
9069			; doc given but wrong??? 
9069			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9069			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9069			; tested 
9069			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9069			 
9069			strcmp_old: 
9069 e5			    PUSH   HL 
906a d5			    PUSH   DE 
906b			 
906b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
906c be			    CP     (HL)            ; (want to minimize work). 
906d 38 01		    JR     C, Str1IsBigger 
906f 7e			    LD     A, (HL) 
9070			 
9070			Str1IsBigger: 
9070 4f			    LD     C, A             ; Put length in BC 
9071 06 00		    LD     B, 0 
9073 13			    INC    DE              ; Increment pointers to meat of string. 
9074 23			    INC    HL 
9075			 
9075			CmpLoop: 
9075 1a			    LD     A, (DE)          ; Compare bytes. 
9076 ed a1		    CPI 
9078 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
907a 13			    INC    DE              ; Update pointer. 
907b ea 75 90		    JP     PE, CmpLoop 
907e			 
907e d1			    POP    DE 
907f e1			    POP    HL 
9080 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9081 be			    CP     (HL) 
9082 c9			    RET 
9083			 
9083			NoMatch: 
9083 2b			    DEC    HL 
9084 be			    CP     (HL)            ; Compare again to affect carry. 
9085 d1			    POP    DE 
9086 e1			    POP    HL 
9087 c9			    RET 
9088			 
9088			;; test strmp 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str2 
9088			;call strcmp 
9088			;jr z, .z1 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "NZ1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.z1: 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "ZZ1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str1 
9088			;call strcmp 
9088			;jr z, .z2 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "NZ2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.z2: 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "ZZ2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str2 
9088			;call strcmp 
9088			;jr c, .c1 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "Nc1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.c1: 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "cc1" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			; 
9088			;ld de, .str1 
9088			;ld hl, .str1 
9088			;call strcmp 
9088			;jr c, .c2 
9088			;;this 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "Nc2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;.c2: 
9088			; 
9088			;	if DEBUG_FORTH_WORDS 
9088			;		DMARK "cc2" 
9088			;		CALLMONITOR 
9088			;	endif 
9088			;	NEXTW 
9088			;.str1:   db "string1",0 
9088			;.str2:   db "string2",0 
9088			 
9088			; only care about direct match or not 
9088			; hl and de strings 
9088			; zero set if the same 
9088			 
9088			strcmp: 
9088 1a				ld a, (de) 
9089 be				cp (hl) 
908a 28 02			jr z, .ssame 
908c b7				or a 
908d c9				ret 
908e			 
908e			.ssame:  
908e fe 00			cp 0 
9090 c8				ret z 
9091			 
9091 23				inc hl 
9092 13				inc de 
9093 18 f3			jr strcmp 
9095				 
9095				 
9095			 
9095			;Copyright (c) 2014, Luke Maurits 
9095			;All rights reserved. 
9095			; 
9095			;Redistribution and use in source and binary forms, with or without 
9095			;modification, are permitted provided that the following conditions are met: 
9095			; 
9095			;* Redistributions of source code must retain the above copyright notice, this 
9095			;  list of conditions and the following disclaimer. 
9095			; 
9095			;* Redistributions in binary form must reproduce the above copyright notice, 
9095			;  this list of conditions and the following disclaimer in the documentation 
9095			;  and/or other materials provided with the distribution. 
9095			; 
9095			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9095			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9095			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9095			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9095			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9095			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9095			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9095			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9095			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9095			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9095			 
9095			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9095			 
9095			StrictStrCmp: 
9095				; Load next chars of each string 
9095 1a				ld a, (de) 
9096 47				ld b, a 
9097 7e				ld a, (hl) 
9098				; Compare 
9098 b8				cp b 
9099				; Return non-zero if chars don't match 
9099 c0				ret nz 
909a				; Check for end of both strings 
909a fe 00			cp "\0" 
909c				; Return if strings have ended 
909c c8				ret z 
909d				; Otherwise, advance to next chars 
909d 23				inc hl 
909e 13				inc de 
909f 18 f4			jr StrictStrCmp 
90a1			 
90a1			;end 
90a1			; eof 
90a1			 
90a1			 
90a1			 
90a1			 
90a1			 
90a1			 
# End of file firmware_strings.asm
90a1			include "firmware_memory.asm"   ; malloc and free  
90a1			 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1			.mallocsize: db "Wants malloc >256",0 
90a1			.mallocasize: db "MALLOC gives >256",0 
90a1			.malloczero: db "MALLOC gives zero",0 
90a1			 
90a1			malloc_guard_zerolen: 
90a1				push hl 
90a1				push de 
90a1				push af 
90a1			 
90a1				ld de, 0 
90a1			        call cmp16 
90a1				jr nz, .lowalloz 
90a1			 
90a1				push hl 
90a1				push de 
90a1					ld hl, display_fb0 
90a1					ld (display_fb_active), hl 
90a1				call clear_display 
90a1				ld a, 0 
90a1				ld de, .malloczero 
90a1				call str_at_display 
90a1				call update_display 
90a1				call delay1s 
90a1				call delay1s 
90a1				call bp_on 
90a1			;	ld a, 0 
90a1			;	ld (os_view_disable), a 
90a1			 
90a1				pop de 
90a1				pop hl 
90a1			 
90a1				 
90a1			 
90a1				CALLMONITOR 
90a1			.lowalloz: 
90a1			 
90a1			 
90a1				pop af 
90a1				pop de 
90a1				pop hl 
90a1			ret 
90a1			 
90a1			malloc_guard_entry: 
90a1				push hl 
90a1				push de 
90a1				push af 
90a1			 
90a1			 	or a      ;clear carry flag 
90a1				push hl 
90a1				ld de, 255 
90a1				sbc hl, de 
90a1				jr c, .lowalloc 
90a1			 
90a1				push de 
90a1					ld hl, display_fb0 
90a1					ld (display_fb_active), hl 
90a1				call clear_display 
90a1				ld a, 0 
90a1				ld de, .mallocsize 
90a1				call str_at_display 
90a1				call update_display 
90a1				call delay1s 
90a1				call delay1s 
90a1			;	ld a, 0 
90a1			;	ld (os_view_disable), a 
90a1				call bp_on 
90a1			 
90a1				pop de 
90a1				pop hl 
90a1			 
90a1				 
90a1			 
90a1				CALLMONITOR 
90a1				jr .lowdone 
90a1			.lowalloc: 
90a1			 
90a1			 
90a1				pop hl 
90a1			.lowdone:	pop af 
90a1				pop de 
90a1				pop hl 
90a1			ret 
90a1			 
90a1			malloc_guard_exit: 
90a1				push hl 
90a1				push de 
90a1				push af 
90a1			 
90a1			 	or a      ;clear carry flag 
90a1				push hl 
90a1				ld de, 255 
90a1				sbc hl, de 
90a1				jr c, .lowallocx 
90a1			 
90a1				push de 
90a1					ld hl, display_fb0 
90a1					ld (display_fb_active), hl 
90a1				call clear_display 
90a1				ld a, 0 
90a1				ld de, .mallocasize 
90a1				call str_at_display 
90a1				call update_display 
90a1				call delay1s 
90a1				call delay1s 
90a1			;	ld a, 0 
90a1			;	ld (os_view_disable), a 
90a1				call bp_on 
90a1				pop de 
90a1				pop hl 
90a1			 
90a1				CALLMONITOR 
90a1				jr .lowdonex 
90a1			.lowallocx: 
90a1			 
90a1				pop hl 
90a1			.lowdonex:	pop af 
90a1				pop de 
90a1				pop hl 
90a1			ret 
90a1			endif 
90a1			 
90a1			if MALLOC_2 
90a1			; Z80 Malloc and Free Functions 
90a1			 
90a1			; Malloc Function: 
90a1			; Input: 
90a1			;   HL: Size of block to allocate 
90a1			; Output: 
90a1			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
90a1			 
90a1			malloc: 
90a1				 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1			call malloc_guard_entry 
90a1			endif 
90a1			 
90a1			 
90a1			 
90a1			 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "mal" 
90a1						CALLMONITOR 
90a1					endif 
90a1			    push af            ; Save AF register 
90a1			    ld a, l            ; Load low byte of size into A 
90a1			    or h               ; Check if size is zero 
90a1			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
90a1			 
90a1			    ; Allocate memory 
90a1			    ld hl, (heap_start) ; Load start of heap into HL 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "ma1" 
90a1						CALLMONITOR 
90a1					endif 
90a1			    call malloc_internal ; Call internal malloc function 
90a1			    pop af             ; Restore AF register 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret                ; Return 
90a1			 
90a1			; Free Function: 
90a1			; Input: 
90a1			;   HL: Pointer to memory block to free 
90a1			; Output: 
90a1			;   None 
90a1			 
90a1			free: 
90a1			    push af            ; Save AF register 
90a1			    ld a, l            ; Load low byte of pointer into A 
90a1			    or h               ; Check if pointer is NULL 
90a1			    jp z, free_exit    ; If pointer is NULL, exit 
90a1			 
90a1			    ; Free memory 
90a1			    ld hl, (heap_start) ; Load start of heap into HL 
90a1			    call free_internal  ; Call internal free function 
90a1			    pop af             ; Restore AF register 
90a1			    ret                ; Return 
90a1			 
90a1			; Internal Malloc Function: 
90a1			; Input: 
90a1			;   HL: Size of block to allocate 
90a1			; Output: 
90a1			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
90a1			 
90a1			malloc_internal: 
90a1			    ld bc, 2           ; Number of bytes to allocate for management overhead 
90a1			    add hl, bc         ; Add management overhead to requested size 
90a1			    ex de, hl          ; Save total size in DE, and keep it in HL 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "ma2" 
90a1						CALLMONITOR 
90a1					endif 
90a1			 
90a1			    ; Search for free memory block 
90a1			    ld de, (heap_end)  ; Load end of heap into DE 
90a1			    ld bc, 0           ; Initialize counter 
90a1			 
90a1					if DEBUG_FORTH_MALLOC 
90a1						DMARK "ma2" 
90a1						CALLMONITOR 
90a1					endif 
90a1			malloc_search_loop: 
90a1			    ; Check if current block is free 
90a1			    ld a, (hl)         ; Load current block's status (free or used) 
90a1			    cp 0               ; Compare with zero (free) 
90a1			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
90a1			 
90a1			    ; Check if current block is large enough 
90a1			    ld a, (hl+1)       ; Load high byte of block size 
90a1			    cp l               ; Compare with low byte of requested size 
90a1			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
90a1			 
90a1			    ld a, (hl+2)       ; Load low byte of block size 
90a1			    cp h               ; Compare with high byte of requested size 
90a1			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
90a1			 
90a1			    ; Mark block as used 
90a1			    ld (hl), 0xFF      ; Set status byte to indicate used block 
90a1			 
90a1			    ; Calculate remaining space in block 
90a1			    ld bc, 0           ; Clear BC 
90a1			    add hl, bc         ; Increment HL to point to start of data block 
90a1			    add hl, de         ; HL = HL + DE (total size) 
90a1			    ld bc, 1           ; Number of bytes to allocate for management overhead 
90a1			    add hl, bc         ; Add management overhead to start of data block 
90a1			 
90a1			    ; Save pointer to allocated block in HL 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1						DMARK "ma5" 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret 
90a1			 
90a1			malloc_skip_block_check: 
90a1			    ; Move to the next block 
90a1			    ld bc, 3           ; Size of management overhead 
90a1			    add hl, bc         ; Move to the next block 
90a1			    inc de             ; Increment counter 
90a1			 
90a1			    ; Check if we have reached the end of heap 
90a1			    ld a, e            ; Load low byte of heap end address 
90a1			    cp (hl)            ; Compare with low byte of current address 
90a1			    jr nz, malloc_search_loop  ; If not equal, continue searching 
90a1			    ld a, d            ; Load high byte of heap end address 
90a1			    cp 0               ; Check if it's zero (end of memory) 
90a1			    jr nz, malloc_search_loop  ; If not zero, continue searching 
90a1			 
90a1			    ; If we reached here, allocation failed 
90a1			    xor a              ; Set result to NULL 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1						DMARK "ma6" 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret 
90a1			malloc_exit: 
90a1			if DEBUG_FORTH_MALLOC_HIGH 
90a1						DMARK "ma7" 
90a1			call malloc_guard_exit 
90a1			call malloc_guard_zerolen 
90a1			endif 
90a1			    ret 
90a1			 
90a1			; Internal Free Function: 
90a1			; Input: 
90a1			;   HL: Pointer to memory block to free 
90a1			; Output: 
90a1			;   None 
90a1			 
90a1			free_internal: 
90a1			    ld de, (heap_start) ; Load start of heap into DE 
90a1			    ld bc, 0            ; Initialize counter 
90a1			 
90a1			free_search_loop: 
90a1			    ; Check if current block contains the pointer 
90a1			    ld a, l             ; Load low byte of pointer 
90a1			    cp (hl+1)           ; Compare with high byte of current block's address 
90a1			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
90a1			    ld a, h             ; Load high byte of pointer 
90a1			    cp (hl+2)           ; Compare with low byte of current block's address 
90a1			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
90a1			 
90a1			    ; Mark block as free 
90a1			    ld (hl), 0          ; Set status byte to indicate free block 
90a1			    ret                 ; Return 
90a1			 
90a1			free_skip_block_check: 
90a1			    ; Move to the next block 
90a1			    ld bc, 3            ; Size of management overhead 
90a1			    add hl, bc          ; Move to the next block 
90a1			    inc de              ; Increment counter 
90a1			 
90a1			    ; Check if we have reached the end of heap 
90a1			    ld a, e             ; Load low byte of heap end address 
90a1			    cp (hl)             ; Compare with low byte of current address 
90a1			    jr nz, free_search_loop  ; If not equal, continue searching 
90a1			    ld a, d             ; Load high byte of heap end address 
90a1			    cp 0                ; Check if it's zero (end of memory) 
90a1			    jr nz, free_search_loop  ; If not zero, continue searching 
90a1			 
90a1			    ; If we reached here, pointer is not found in heap 
90a1			    ret 
90a1			 
90a1			free_exit: 
90a1			    ret                 ; Return 
90a1			 
90a1			; Define heap start and end addresses 
90a1			;heap_start:    .dw 0xC000   ; Start of heap 
90a1			;heap_end:      .dw 0xE000   ; End of heap 
90a1			 
90a1			endif 
90a1			 
90a1			 
90a1			if MALLOC_1 
90a1			 
90a1			 
90a1			 
90a1			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
90a1			 
90a1			;moved to firmware.asm 
90a1			;heap_start        .equ  0x9000      ; Starting address of heap 
90a1			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
90a1			 
90a1			;      .org 0 
90a1			;      jp    main 
90a1			 
90a1			 
90a1			;      .org  0x100 
90a1			;main: 
90a1			;      ld    HL, 0x8100 
90a1			;      ld    SP, HL 
90a1			; 
90a1			;      call  heap_init 
90a1			; 
90a1			;      ; Make some allocations 
90a1			;      ld    HL, 12 
90a1			;      call  malloc            ; Allocates 0x9004 
90a1			; 
90a1			;      ld    HL, 12 
90a1			;      call  malloc            ; Allocates 0x9014 
90a1			; 
90a1			;      ld    HL, 12 
90a1			;      call  malloc            ; Allocates 0x9024 
90a1			; 
90a1			;      ; Free some allocations 
90a1			;      ld    HL, 0x9014 
90a1			;      call  free 
90a1			; 
90a1			;      ld    HL, 0x9004 
90a1			;      call  free 
90a1			; 
90a1			;      ld    HL, 0x9024 
90a1			;      call  free 
90a1			; 
90a1			; 
90a1			;      halt 
90a1			 
90a1			 
90a1			;------------------------------------------------------------------------------ 
90a1			;     heap_init                                                               : 
90a1			;                                                                             : 
90a1			; Description                                                                 : 
90a1			;     Initialise the heap and make it ready for malloc and free operations.   : 
90a1			;                                                                             : 
90a1			;     The heap is maintained as a linked list, starting with an initial       : 
90a1			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
90a1			;     the first free block in the heap. Each block then points to the next    : 
90a1			;     free block within the heap, and the free list ends at the first block   : 
90a1			;     with a null pointer to the next free block.                             : 
90a1			;                                                                             : 
90a1			; Parameters                                                                  : 
90a1			;     Inputs are compile-time only. Two defines which specify the starting    : 
90a1			;     address of the heap and its size are required, along with a memory      : 
90a1			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
90a1			;     principally stores a pointer to the first free block in the heap.       : 
90a1			;                                                                             : 
90a1			; Returns                                                                     : 
90a1			;     Nothing                                                                 : 
90a1			;------------------------------------------------------------------------------ 
90a1			heap_init: 
90a1 e5			      push  HL 
90a2			 
90a2			      ; Initialise free list struct 
90a2 21 ff e3		      ld    HL, heap_start 
90a5 22 fa e3		      ld    (free_list), HL 
90a8 21 00 00		      ld    HL, 0 
90ab 22 fc e3		      ld    (free_list+2), HL 
90ae			 
90ae			      ; Insert first free block at bottom of heap, consumes entire heap 
90ae 21 8f e2		      ld    HL, heap_start+heap_size-4 
90b1 22 ff e3		      ld    (heap_start), HL        ; Next block (end of free list) 
90b4 21 90 fe		      ld    HL, heap_size-4 
90b7 22 01 e4		      ld    (heap_start+2), HL      ; Block size 
90ba			 
90ba			      ; Insert end of free list block at top of heap - two null words will 
90ba			      ; terminate the free list 
90ba 21 00 00		      ld    HL, 0 
90bd 22 91 e2		      ld    (heap_start+heap_size-2), HL 
90c0 22 8f e2		      ld    (heap_start+heap_size-4), HL 
90c3			 
90c3 e1			      pop   HL 
90c4			 
90c4 c9			      ret 
90c5			 
90c5			 
90c5			;------------------------------------------------------------------------------ 
90c5			;     malloc                                                                  : 
90c5			;                                                                             : 
90c5			; Description                                                                 : 
90c5			;     Allocates the wanted space from the heap and returns the address of the : 
90c5			;     first useable byte of the allocation.                                   : 
90c5			;                                                                             : 
90c5			;     Allocations can happen in one of two ways:                              : 
90c5			;                                                                             : 
90c5			;     1. A free block may be found which is the exact size wanted. In this    : 
90c5			;        case the block is removed from the free list and retuedn to the      : 
90c5			;        caller.                                                              : 
90c5			;     2. A free block may be found which is larger than the size wanted. In   : 
90c5			;        this case, the larger block is split into two. The first portion of  : 
90c5			;        this block will become the requested space by the malloc call and    : 
90c5			;        is returned to the caller. The second portion becomes a new free     : 
90c5			;        block, and the free list is adjusted to maintain continuity via this : 
90c5			;        newly created block.                                                 : 
90c5			;                                                                             : 
90c5			;     malloc does not set any initial value in the allocated space, the       : 
90c5			;     caller is required to do this as required.                              : 
90c5			;                                                                             : 
90c5			;     This implementation of malloc uses the stack exclusively, and is        : 
90c5			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90c5			;     advisable to disable interrupts before calling malloc, and recommended  : 
90c5			;     to avoid the use of malloc inside ISRs in general.                      : 
90c5			;                                                                             : 
90c5			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90c5			;                                                                             : 
90c5			; Parameters                                                                  : 
90c5			;     HL  Number of bytes wanted                                              : 
90c5			;                                                                             : 
90c5			; Returns                                                                     : 
90c5			;     HL  Address of the first useable byte of the allocation                 : 
90c5			;                                                                             : 
90c5			; Flags                                                                       : 
90c5			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90c5			;                                                                             : 
90c5			; Stack frame                                                                 : 
90c5			;       |             |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |     BC      |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |     DE      |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |     IX      |                                                       : 
90c5			;       +-------------+                                                       : 
90c5			;       |  prev_free  |                                                       : 
90c5			;   +4  +-------------+                                                       : 
90c5			;       |  this_free  |                                                       : 
90c5			;   +2  +-------------+                                                       : 
90c5			;       |  next_free  |                                                       : 
90c5			;   +0  +-------------+                                                       : 
90c5			;       |             |                                                       : 
90c5			;                                                                             : 
90c5			;------------------------------------------------------------------------------ 
90c5			 
90c5			 
90c5			;malloc: 
90c5			; 
90c5			;	SAVESP ON 1 
90c5			; 
90c5			;	call malloc_code 
90c5			; 
90c5			;	CHECKSP ON 1 
90c5			;	ret 
90c5			 
90c5			 
90c5			malloc: 
90c5 c5			      push  BC 
90c6 d5			      push  DE 
90c7 dd e5		      push  IX 
90c9			if DEBUG_FORTH_MALLOC_HIGH 
90c9			call malloc_guard_entry 
90c9			endif 
90c9			 
90c9					if DEBUG_FORTH_MALLOC 
90c9						DMARK "mal" 
90c9						CALLMONITOR 
90c9					endif 
90c9 7c			      ld    A, H                    ; Exit if no space requested 
90ca b5			      or    L 
90cb ca 8a 91		      jp    Z, malloc_early_exit 
90ce			 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			; 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			;inc hl 
90ce			 
90ce			 
90ce			 
90ce			 
90ce					if DEBUG_FORTH_MALLOC 
90ce						DMARK "maA" 
90ce						CALLMONITOR 
90ce					endif 
90ce			      ; Set up stack frame 
90ce eb			      ex    DE, HL 
90cf 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90d2 39			      add   HL, SP 
90d3 f9			      ld    SP, HL 
90d4 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90d8 dd 39		      add   IX, SP 
90da			 
90da			      ; Setup initial state 
90da 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90dd 19			      add   HL, DE 
90de			 
90de 44			      ld    B, H                    ; Move want to BC 
90df 4d			      ld    C, L 
90e0			 
90e0 21 fa e3		      ld    HL, free_list           ; Store prev_free ptr to stack 
90e3 dd 75 04		      ld    (IX+4), L 
90e6 dd 74 05		      ld    (IX+5), H 
90e9			 
90e9 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90ea 23			      inc   HL 
90eb 56			      ld    D, (HL) 
90ec dd 73 02		      ld    (IX+2), E 
90ef dd 72 03		      ld    (IX+3), D 
90f2 eb			      ex    DE, HL                  ; this_free ptr into HL 
90f3			 
90f3					if DEBUG_FORTH_MALLOC 
90f3						DMARK "maB" 
90f3						CALLMONITOR 
90f3					endif 
90f3			      ; Loop through free block list to find some space 
90f3			malloc_find_space: 
90f3 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90f4 23			      inc   HL 
90f5 56			      ld    D, (HL) 
90f6			 
90f6 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90f7 b3			      or    E 
90f8 ca 84 91		      jp    Z, malloc_no_space 
90fb			 
90fb dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90fe dd 72 01		      ld    (IX+1), D 
9101			 
9101			      ; Does this block have enough space to make the allocation? 
9101 23			      inc   HL                      ; Load free block size into DE 
9102 5e			      ld    E, (HL) 
9103 23			      inc   HL 
9104 56			      ld    D, (HL) 
9105			 
9105 eb			      ex    DE, HL                  ; Check size of block against want 
9106 b7			      or    A                       ; Ensure carry flag clear 
9107 ed 42		      sbc   HL, BC 
9109 e5			      push  HL                      ; Store the result for later (new block size) 
910a			 
910a ca 59 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
910d 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
910f			 
910f			      ; this_free block is not big enough, setup ptrs to test next free block 
910f e1			      pop   HL                      ; Discard previous result 
9110			 
9110 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9113 dd 66 03		      ld    H, (IX+3) 
9116 dd 75 04		      ld    (IX+4), L 
9119 dd 74 05		      ld    (IX+5), H 
911c			 
911c dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
911f dd 66 01		      ld    H, (IX+1) 
9122 dd 75 02		      ld    (IX+2), L 
9125 dd 74 03		      ld    (IX+3), H 
9128			 
9128					if DEBUG_FORTH_MALLOC 
9128						DMARK "MA>" 
9128						CALLMONITOR 
9128					endif 
9128 18 c9		      jr    malloc_find_space 
912a			 
912a			      ; split a bigger block into two - requested size and remaining size 
912a			malloc_alloc_split: 
912a					if DEBUG_FORTH_MALLOC 
912a						DMARK "MAs" 
912a						CALLMONITOR 
912a					endif 
912a eb			      ex    DE, HL                  ; Calculate address of new free block 
912b 2b			      dec   HL 
912c 2b			      dec   HL 
912d 2b			      dec   HL 
912e 09			      add   HL, BC 
912f			 
912f			      ; Create a new block and point it at next_free 
912f dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9132 dd 56 01		      ld    D, (IX+1) 
9135			 
9135 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9136 23			      inc   HL 
9137 72			      ld    (HL), D 
9138			 
9138 d1			      pop   DE                      ; Store size of new block into new block 
9139 23			      inc   HL 
913a 73			      ld    (HL), E 
913b 23			      inc   HL 
913c 72			      ld    (HL), D 
913d			 
913d			      ; Update this_free ptr to point to new block 
913d 2b			      dec   HL 
913e 2b			      dec   HL 
913f 2b			      dec   HL 
9140			 
9140 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9143 dd 56 03		      ld    D, (IX+3) 
9146			 
9146 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9149 dd 74 03		      ld    (IX+3), H 
914c			 
914c			      ; Modify this_free block to be allocation 
914c eb			      ex    DE, HL 
914d af			      xor   A                       ; Null the next block ptr of allocated block 
914e 77			      ld    (HL), A 
914f 23			      inc   HL 
9150 77			      ld    (HL), A 
9151			 
9151 23			      inc   HL                      ; Store want size into allocated block 
9152 71			      ld    (HL), C 
9153 23			      inc   HL 
9154 70			      ld    (HL), B 
9155 23			      inc   HL 
9156 e5			      push  HL                      ; Address of allocation to return 
9157			 
9157 18 19		      jr    malloc_update_links 
9159			 
9159			malloc_alloc_fit: 
9159 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
915a			 
915a					if DEBUG_FORTH_MALLOC 
915a						DMARK "MAf" 
915a						CALLMONITOR 
915a					endif 
915a			      ; Modify this_free block to be allocation 
915a eb			      ex    DE, HL 
915b 2b			      dec   HL 
915c 2b			      dec   HL 
915d 2b			      dec   HL 
915e			 
915e af			      xor   A                       ; Null the next block ptr of allocated block 
915f 77			      ld    (HL), A 
9160 23			      inc   HL 
9161 77			      ld    (HL), A 
9162			 
9162 23			      inc   HL                      ; Store address of allocation to return 
9163 23			      inc   HL 
9164 23			      inc   HL 
9165 e5			      push  HL 
9166			 
9166			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9166 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9169 dd 66 01		      ld    H, (IX+1) 
916c			 
916c dd 75 02		      ld    (IX+2), L               ; HL to this_free 
916f dd 74 03		      ld    (IX+3), H 
9172			 
9172			 
9172			malloc_update_links: 
9172			      ; Update prev_free ptr to point to this_free 
9172 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9175 dd 66 05		      ld    H, (IX+5) 
9178			 
9178 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
917b dd 56 03		      ld    D, (IX+3) 
917e			 
917e 73			      ld    (HL), E                 ; this_free ptr into prev_free 
917f 23			      inc   HL 
9180 72			      ld    (HL), D 
9181			 
9181					if DEBUG_FORTH_MALLOC 
9181						DMARK "Mul" 
9181						CALLMONITOR 
9181					endif 
9181			      ; Clear the Z flag to indicate successful allocation 
9181 7a			      ld    A, D 
9182 b3			      or    E 
9183			 
9183 d1			      pop   DE                      ; Address of allocation 
9184					if DEBUG_FORTH_MALLOC 
9184						DMARK "MAu" 
9184						CALLMONITOR 
9184					endif 
9184			 
9184			malloc_no_space: 
9184 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9187 39			      add   HL, SP 
9188 f9			      ld    SP, HL 
9189			 
9189 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "MAN" 
918a						CALLMONITOR 
918a					endif 
918a			 
918a			malloc_early_exit: 
918a					if DEBUG_FORTH_MALLOC 
918a						DMARK "MAx" 
918a						CALLMONITOR 
918a					endif 
918a dd e1		      pop   IX 
918c d1			      pop   DE 
918d c1			      pop   BC 
918e			 
918e			if DEBUG_FORTH_MALLOC_HIGH 
918e			call malloc_guard_exit 
918e			call malloc_guard_zerolen 
918e			endif 
918e c9			      ret 
918f			 
918f			 
918f			;------------------------------------------------------------------------------ 
918f			;     free                                                                    : 
918f			;                                                                             : 
918f			; Description                                                                 : 
918f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
918f			;     returned by malloc, otherwise the behaviour is undefined.               : 
918f			;                                                                             : 
918f			;     Where possible, directly adjacent free blocks will be merged together   : 
918f			;     into larger blocks to help ensure that the heap does not become         : 
918f			;     excessively fragmented.                                                 : 
918f			;                                                                             : 
918f			;     free does not clear or set any other value into the freed space, and    : 
918f			;     therefore its contents may be visible through subsequent malloc's. The  : 
918f			;     caller should clear the freed space as required.                        : 
918f			;                                                                             : 
918f			;     This implementation of free uses the stack exclusively, and is          : 
918f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
918f			;     advisable to disable interrupts before calling free, and recommended    : 
918f			;     to avoid the use of free inside ISRs in general.                        : 
918f			;                                                                             : 
918f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
918f			;                                                                             : 
918f			; Parameters                                                                  : 
918f			;     HL  Pointer to address of first byte of allocation to be freed          : 
918f			;                                                                             : 
918f			; Returns                                                                     : 
918f			;     Nothing                                                                 : 
918f			;                                                                             : 
918f			; Stack frame                                                                 : 
918f			;       |             |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |     BC      |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |     DE      |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |     IX      |                                                       : 
918f			;       +-------------+                                                       : 
918f			;       |  prev_free  |                                                       : 
918f			;   +2  +-------------+                                                       : 
918f			;       |  next_free  |                                                       : 
918f			;   +0  +-------------+                                                       : 
918f			;       |             |                                                       : 
918f			;                                                                             : 
918f			;------------------------------------------------------------------------------ 
918f			free: 
918f c5			      push  BC 
9190 d5			      push  DE 
9191 dd e5		      push  IX 
9193			 
9193 7c			      ld    A, H                    ; Exit if ptr is null 
9194 b5			      or    L 
9195 ca 59 92		      jp    Z, free_early_exit 
9198			 
9198			      ; Set up stack frame 
9198 eb			      ex    DE, HL 
9199 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
919c 39			      add   HL, SP 
919d f9			      ld    SP, HL 
919e dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91a2 dd 39		      add   IX, SP 
91a4			 
91a4			      ; The address in HL points to the start of the useable allocated space, 
91a4			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
91a4			      ; address of the block itself. 
91a4 eb			      ex    DE, HL 
91a5 11 fc ff		      ld    DE, -4 
91a8 19			      add   HL, DE 
91a9			 
91a9			      ; An allocated block must have a null next block pointer in it 
91a9 7e			      ld    A, (HL) 
91aa 23			      inc   HL 
91ab b6			      or    (HL) 
91ac c2 54 92		      jp    NZ, free_done 
91af			 
91af 2b			      dec   HL 
91b0			 
91b0 44			      ld    B, H                    ; Copy HL to BC 
91b1 4d			      ld    C, L 
91b2			 
91b2			      ; Loop through the free list to find the first block with an address 
91b2			      ; higher than the block being freed 
91b2 21 fa e3		      ld    HL, free_list 
91b5			 
91b5			free_find_higher_block: 
91b5 5e			      ld    E, (HL)                 ; Load next ptr from free block 
91b6 23			      inc   HL 
91b7 56			      ld    D, (HL) 
91b8 2b			      dec   HL 
91b9			 
91b9 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
91bc dd 72 01		      ld    (IX+1), D 
91bf dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
91c2 dd 74 03		      ld    (IX+3), H 
91c5			 
91c5 78			      ld    A, B                    ; Check if DE is greater than BC 
91c6 ba			      cp    D                       ; Compare MSB first 
91c7 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91c9 30 04		      jr    NC, free_find_higher_block_skip 
91cb 79			      ld    A, C 
91cc bb			      cp    E                       ; Then compare LSB 
91cd 38 08		      jr    C, free_found_higher_block 
91cf			 
91cf			free_find_higher_block_skip: 
91cf 7a			      ld    A, D                    ; Reached the end of the free list? 
91d0 b3			      or    E 
91d1 ca 54 92		      jp    Z, free_done 
91d4			 
91d4 eb			      ex    DE, HL 
91d5			 
91d5 18 de		      jr    free_find_higher_block 
91d7			 
91d7			free_found_higher_block: 
91d7			      ; Insert freed block between prev and next free blocks 
91d7 71			      ld    (HL), C                 ; Point prev free block to freed block 
91d8 23			      inc   HL 
91d9 70			      ld    (HL), B 
91da			 
91da 60			      ld    H, B                    ; Point freed block at next free block 
91db 69			      ld    L, C 
91dc 73			      ld    (HL), E 
91dd 23			      inc   HL 
91de 72			      ld    (HL), D 
91df			 
91df			      ; Check if the freed block is adjacent to the next free block 
91df 23			      inc   HL                      ; Load size of freed block into HL 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3 eb			      ex    DE, HL 
91e4			 
91e4 09			      add   HL, BC                  ; Add addr of freed block and its size 
91e5			 
91e5 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91e8 dd 56 01		      ld    D, (IX+1) 
91eb			 
91eb b7			      or    A                       ; Clear the carry flag 
91ec ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91ee 20 22		      jr    NZ, free_check_adjacent_to_prev 
91f0			 
91f0			      ; Freed block is adjacent to next, merge into one bigger block 
91f0 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91f1 5e			      ld    E, (HL) 
91f2 23			      inc   HL 
91f3 56			      ld    D, (HL) 
91f4 e5			      push  HL                      ; Save ptr to next block for later 
91f5			 
91f5 60			      ld    H, B                    ; Store ptr from next block into freed block 
91f6 69			      ld    L, C 
91f7 73			      ld    (HL), E 
91f8 23			      inc   HL 
91f9 72			      ld    (HL), D 
91fa			 
91fa e1			      pop   HL                      ; Restore ptr to next block 
91fb 23			      inc   HL                      ; Load size of next block into DE 
91fc 5e			      ld    E, (HL) 
91fd 23			      inc   HL 
91fe 56			      ld    D, (HL) 
91ff d5			      push  DE                      ; Save next block size for later 
9200			 
9200 60			      ld    H, B                    ; Load size of freed block into HL 
9201 69			      ld    L, C 
9202 23			      inc   HL 
9203 23			      inc   HL 
9204 5e			      ld    E, (HL) 
9205 23			      inc   HL 
9206 56			      ld    D, (HL) 
9207 eb			      ex    DE, HL 
9208			 
9208 d1			      pop   DE                      ; Restore size of next block 
9209 19			      add   HL, DE                  ; Add sizes of both blocks 
920a eb			      ex    DE, HL 
920b			 
920b 60			      ld    H, B                    ; Store new bigger size into freed block 
920c 69			      ld    L, C 
920d 23			      inc   HL 
920e 23			      inc   HL 
920f 73			      ld    (HL), E 
9210 23			      inc   HL 
9211 72			      ld    (HL), D 
9212			 
9212			free_check_adjacent_to_prev: 
9212			      ; Check if the freed block is adjacent to the prev free block 
9212 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9215 dd 66 03		      ld    H, (IX+3) 
9218			 
9218 23			      inc   HL                      ; Size of prev free block into DE 
9219 23			      inc   HL 
921a 5e			      ld    E, (HL) 
921b 23			      inc   HL 
921c 56			      ld    D, (HL) 
921d 2b			      dec   HL 
921e 2b			      dec   HL 
921f 2b			      dec   HL 
9220			 
9220 19			      add   HL, DE                  ; Add prev block addr and size 
9221			 
9221 b7			      or    A                       ; Clear the carry flag 
9222 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9224 20 2e		      jr    NZ, free_done 
9226			 
9226			      ; Freed block is adjacent to prev, merge into one bigger block 
9226 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9227 69			      ld    L, C 
9228 5e			      ld    E, (HL) 
9229 23			      inc   HL 
922a 56			      ld    D, (HL) 
922b e5			      push  HL                      ; Save freed block ptr for later 
922c			 
922c dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
922f dd 66 03		      ld    H, (IX+3) 
9232 73			      ld    (HL), E 
9233 23			      inc   HL 
9234 72			      ld    (HL), D 
9235			 
9235 e1			      pop   HL                      ; Restore freed block ptr 
9236 23			      inc   HL                      ; Load size of freed block into DE 
9237 5e			      ld    E, (HL) 
9238 23			      inc   HL 
9239 56			      ld    D, (HL) 
923a d5			      push  DE                      ; Save freed block size for later 
923b			 
923b dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
923e dd 66 03		      ld    H, (IX+3) 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 5e			      ld    E, (HL) 
9244 23			      inc   HL 
9245 56			      ld    D, (HL) 
9246			 
9246 e1			      pop   HL                      ; Add sizes of both blocks 
9247 19			      add   HL, DE 
9248 eb			      ex    DE, HL 
9249			 
9249 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
924c dd 66 03		      ld    H, (IX+3) 
924f 23			      inc   HL 
9250 23			      inc   HL 
9251 73			      ld    (HL), E 
9252 23			      inc   HL 
9253 72			      ld    (HL), D 
9254			 
9254			free_done: 
9254 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9257 39			      add   HL, SP 
9258 f9			      ld    SP, HL 
9259			 
9259			free_early_exit: 
9259 dd e1		      pop   IX 
925b d1			      pop   DE 
925c c1			      pop   BC 
925d			 
925d c9			      ret 
925e			 
925e			; moved to firmware.asm 
925e			; 
925e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925e			;                  .dw   0 
925e			 
925e			 
925e			endif 
925e			 
925e			 
925e			if MALLOC_3 
925e			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
925e			;heap_start        .equ  0x9000      ; Starting address of heap 
925e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
925e			; 
925e			 ;     .org 0 
925e			  ;    jp    main 
925e			; 
925e			; 
925e			 ;     .org  0x100 
925e			;main: 
925e			 ;     ld    HL, 0x8100 
925e			  ;    ld    SP, HL 
925e			; 
925e			;      call  heap_init 
925e			 
925e			      ; Make some allocations 
925e			;      ld    HL, 12 
925e			;      call  malloc            ; Allocates 0x9004 
925e			; 
925e			 ;     ld    HL, 12 
925e			;      call  malloc            ; Allocates 0x9014 
925e			 
925e			;      ld    HL, 12 
925e			;      call  malloc            ; Allocates 0x9024 
925e			 
925e			      ; Free some allocations 
925e			;      ld    HL, 0x9014 
925e			;      call  free 
925e			 
925e			;      ld    HL, 0x9004 
925e			;      call  free 
925e			; 
925e			;      ld    HL, 0x9024 
925e			;      call  free 
925e			 
925e			 
925e			 ;     halt 
925e			 
925e			 
925e			;------------------------------------------------------------------------------ 
925e			;     heap_init                                                               : 
925e			;                                                                             : 
925e			; Description                                                                 : 
925e			;     Initialise the heap and make it ready for malloc and free operations.   : 
925e			;                                                                             : 
925e			;     The heap is maintained as a linked list, starting with an initial       : 
925e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
925e			;     the first free block in the heap. Each block then points to the next    : 
925e			;     free block within the heap, and the free list ends at the first block   : 
925e			;     with a null pointer to the next free block.                             : 
925e			;                                                                             : 
925e			; Parameters                                                                  : 
925e			;     Inputs are compile-time only. Two defines which specify the starting    : 
925e			;     address of the heap and its size are required, along with a memory      : 
925e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
925e			;     principally stores a pointer to the first free block in the heap.       : 
925e			;                                                                             : 
925e			; Returns                                                                     : 
925e			;     Nothing                                                                 : 
925e			;------------------------------------------------------------------------------ 
925e			heap_init: 
925e			      push  HL 
925e			 
925e			      ; Initialise free list struct 
925e			      ld    HL, heap_start 
925e			      ld    (free_list), HL 
925e			      ld    HL, 0 
925e			      ld    (free_list+2), HL 
925e			 
925e			      ; Insert first free block at bottom of heap, consumes entire heap 
925e			      ld    HL, heap_start+heap_size-4 
925e			      ld    (heap_start), HL        ; Next block (end of free list) 
925e			      ld    HL, heap_size-4 
925e			      ld    (heap_start+2), HL      ; Block size 
925e			 
925e			      ; Insert end of free list block at top of heap - two null words will 
925e			      ; terminate the free list 
925e			      ld    HL, 0 
925e			      ld    (heap_start+heap_size-2), HL 
925e			      ld    (heap_start+heap_size-4), HL 
925e			 
925e			      pop   HL 
925e			 
925e			      ret 
925e			 
925e			 
925e			;------------------------------------------------------------------------------ 
925e			;     malloc                                                                  : 
925e			;                                                                             : 
925e			; Description                                                                 : 
925e			;     Allocates the wanted space from the heap and returns the address of the : 
925e			;     first useable byte of the allocation.                                   : 
925e			;                                                                             : 
925e			;     Allocations can happen in one of two ways:                              : 
925e			;                                                                             : 
925e			;     1. A free block may be found which is the exact size wanted. In this    : 
925e			;        case the block is removed from the free list and retuedn to the      : 
925e			;        caller.                                                              : 
925e			;     2. A free block may be found which is larger than the size wanted. In   : 
925e			;        this case, the larger block is split into two. The first portion of  : 
925e			;        this block will become the requested space by the malloc call and    : 
925e			;        is returned to the caller. The second portion becomes a new free     : 
925e			;        block, and the free list is adjusted to maintain continuity via this : 
925e			;        newly created block.                                                 : 
925e			;                                                                             : 
925e			;     malloc does not set any initial value in the allocated space, the       : 
925e			;     caller is required to do this as required.                              : 
925e			;                                                                             : 
925e			;     This implementation of malloc uses the stack exclusively, and is        : 
925e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925e			;     advisable to disable interrupts before calling malloc, and recommended  : 
925e			;     to avoid the use of malloc inside ISRs in general.                      : 
925e			;                                                                             : 
925e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925e			;                                                                             : 
925e			; Parameters                                                                  : 
925e			;     HL  Number of bytes wanted                                              : 
925e			;                                                                             : 
925e			; Returns                                                                     : 
925e			;     HL  Address of the first useable byte of the allocation                 : 
925e			;                                                                             : 
925e			; Flags                                                                       : 
925e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
925e			;                                                                             : 
925e			; Stack frame                                                                 : 
925e			;       |             |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     BC      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     DE      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     IX      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |  prev_free  |                                                       : 
925e			;   +4  +-------------+                                                       : 
925e			;       |  this_free  |                                                       : 
925e			;   +2  +-------------+                                                       : 
925e			;       |  next_free  |                                                       : 
925e			;   +0  +-------------+                                                       : 
925e			;       |             |                                                       : 
925e			;                                                                             : 
925e			;------------------------------------------------------------------------------ 
925e			malloc: 
925e			      push  BC 
925e			      push  DE 
925e			      push  IX 
925e			 
925e			      ld    A, H                    ; Exit if no space requested 
925e			      or    L 
925e			      jp    Z, malloc_early_exit 
925e			 
925e			      ; Set up stack frame 
925e			      ex    DE, HL 
925e			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			      ld    IX, 0                   ; Use IX as a frame pointer 
925e			      add   IX, SP 
925e			 
925e			      ; Setup initial state 
925e			      ld    HL, 4                   ; want must also include space used by block struct 
925e			      add   HL, DE 
925e			 
925e			      ld    B, H                    ; Move want to BC 
925e			      ld    C, L 
925e			 
925e			      ld    HL, free_list           ; Store prev_free ptr to stack 
925e			      ld    (IX+4), L 
925e			      ld    (IX+5), H 
925e			 
925e			      ld    E, (HL)                 ; Store this_free ptr to stack 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      ld    (IX+2), E 
925e			      ld    (IX+3), D 
925e			      ex    DE, HL                  ; this_free ptr into HL 
925e			 
925e			      ; Loop through free block list to find some space 
925e			malloc_find_space: 
925e			      ld    E, (HL)                 ; Load next_free ptr into DE 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			 
925e			      ld    A, D                    ; Check for null next_free ptr - end of free list 
925e			      or    E 
925e			      jp    Z, malloc_no_space 
925e			 
925e			      ld    (IX+0), E               ; Store next_free ptr to stack 
925e			      ld    (IX+1), D 
925e			 
925e			      ; Does this block have enough space to make the allocation? 
925e			      inc   HL                      ; Load free block size into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			 
925e			      ex    DE, HL                  ; Check size of block against want 
925e			      or    A                       ; Ensure carry flag clear 
925e			      sbc   HL, BC 
925e			      push  HL                      ; Store the result for later (new block size) 
925e			 
925e			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
925e			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
925e			 
925e			      ; this_free block is not big enough, setup ptrs to test next free block 
925e			      pop   HL                      ; Discard previous result 
925e			 
925e			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
925e			      ld    H, (IX+3) 
925e			      ld    (IX+4), L 
925e			      ld    (IX+5), H 
925e			 
925e			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
925e			      ld    H, (IX+1) 
925e			      ld    (IX+2), L 
925e			      ld    (IX+3), H 
925e			 
925e			      jr    malloc_find_space 
925e			 
925e			      ; split a bigger block into two - requested size and remaining size 
925e			malloc_alloc_split: 
925e			      ex    DE, HL                  ; Calculate address of new free block 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			      add   HL, BC 
925e			 
925e			      ; Create a new block and point it at next_free 
925e			      ld    E, (IX+0)               ; Load next_free ptr into DE 
925e			      ld    D, (IX+1) 
925e			 
925e			      ld    (HL), E                 ; Store next_free ptr into new block 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      pop   DE                      ; Store size of new block into new block 
925e			      inc   HL 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      ; Update this_free ptr to point to new block 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			 
925e			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
925e			      ld    D, (IX+3) 
925e			 
925e			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
925e			      ld    (IX+3), H 
925e			 
925e			      ; Modify this_free block to be allocation 
925e			      ex    DE, HL 
925e			      xor   A                       ; Null the next block ptr of allocated block 
925e			      ld    (HL), A 
925e			      inc   HL 
925e			      ld    (HL), A 
925e			 
925e			      inc   HL                      ; Store want size into allocated block 
925e			      ld    (HL), C 
925e			      inc   HL 
925e			      ld    (HL), B 
925e			      inc   HL 
925e			      push  HL                      ; Address of allocation to return 
925e			 
925e			      jr    malloc_update_links 
925e			 
925e			malloc_alloc_fit: 
925e			      pop   HL                      ; Dont need new block size, want is exact fit 
925e			 
925e			      ; Modify this_free block to be allocation 
925e			      ex    DE, HL 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			 
925e			      xor   A                       ; Null the next block ptr of allocated block 
925e			      ld    (HL), A 
925e			      inc   HL 
925e			      ld    (HL), A 
925e			 
925e			      inc   HL                      ; Store address of allocation to return 
925e			      inc   HL 
925e			      inc   HL 
925e			      push  HL 
925e			 
925e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
925e			      ld    L, (IX+0)               ; next_free to HL 
925e			      ld    H, (IX+1) 
925e			 
925e			      ld    (IX+2), L               ; HL to this_free 
925e			      ld    (IX+3), H 
925e			 
925e			 
925e			malloc_update_links: 
925e			      ; Update prev_free ptr to point to this_free 
925e			      ld    L, (IX+4)               ; prev_free ptr to HL 
925e			      ld    H, (IX+5) 
925e			 
925e			      ld    E, (IX+2)               ; this_free ptr to DE 
925e			      ld    D, (IX+3) 
925e			 
925e			      ld    (HL), E                 ; this_free ptr into prev_free 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      ; Clear the Z flag to indicate successful allocation 
925e			      ld    A, D 
925e			      or    E 
925e			 
925e			      pop   DE                      ; Address of allocation 
925e			 
925e			malloc_no_space: 
925e			      ld    HL, 6                   ; Clean up stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			 
925e			      ex    DE, HL                  ; Alloc addr into HL for return 
925e			 
925e			malloc_early_exit: 
925e			      pop   IX 
925e			      pop   DE 
925e			      pop   BC 
925e			 
925e			      ret 
925e			 
925e			 
925e			;------------------------------------------------------------------------------ 
925e			;     free                                                                    : 
925e			;                                                                             : 
925e			; Description                                                                 : 
925e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
925e			;     returned by malloc, otherwise the behaviour is undefined.               : 
925e			;                                                                             : 
925e			;     Where possible, directly adjacent free blocks will be merged together   : 
925e			;     into larger blocks to help ensure that the heap does not become         : 
925e			;     excessively fragmented.                                                 : 
925e			;                                                                             : 
925e			;     free does not clear or set any other value into the freed space, and    : 
925e			;     therefore its contents may be visible through subsequent malloc's. The  : 
925e			;     caller should clear the freed space as required.                        : 
925e			;                                                                             : 
925e			;     This implementation of free uses the stack exclusively, and is          : 
925e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925e			;     advisable to disable interrupts before calling free, and recommended    : 
925e			;     to avoid the use of free inside ISRs in general.                        : 
925e			;                                                                             : 
925e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925e			;                                                                             : 
925e			; Parameters                                                                  : 
925e			;     HL  Pointer to address of first byte of allocation to be freed          : 
925e			;                                                                             : 
925e			; Returns                                                                     : 
925e			;     Nothing                                                                 : 
925e			;                                                                             : 
925e			; Stack frame                                                                 : 
925e			;       |             |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     BC      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     DE      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |     IX      |                                                       : 
925e			;       +-------------+                                                       : 
925e			;       |  prev_free  |                                                       : 
925e			;   +2  +-------------+                                                       : 
925e			;       |  next_free  |                                                       : 
925e			;   +0  +-------------+                                                       : 
925e			;       |             |                                                       : 
925e			;                                                                             : 
925e			;------------------------------------------------------------------------------ 
925e			free: 
925e			      push  BC 
925e			      push  DE 
925e			      push  IX 
925e			 
925e			      ld    A, H                    ; Exit if ptr is null 
925e			      or    L 
925e			      jp    Z, free_early_exit 
925e			 
925e			      ; Set up stack frame 
925e			      ex    DE, HL 
925e			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			      ld    IX, 0                   ; Use IX as a frame pointer 
925e			      add   IX, SP 
925e			 
925e			      ; The address in HL points to the start of the useable allocated space, 
925e			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
925e			      ; address of the block itself. 
925e			      ex    DE, HL 
925e			      ld    DE, -4 
925e			      add   HL, DE 
925e			 
925e			      ; An allocated block must have a null next block pointer in it 
925e			      ld    A, (HL) 
925e			      inc   HL 
925e			      or    (HL) 
925e			      jp    NZ, free_done 
925e			 
925e			      dec   HL 
925e			 
925e			      ld    B, H                    ; Copy HL to BC 
925e			      ld    C, L 
925e			 
925e			      ; Loop through the free list to find the first block with an address 
925e			      ; higher than the block being freed 
925e			      ld    HL, free_list 
925e			 
925e			free_find_higher_block: 
925e			      ld    E, (HL)                 ; Load next ptr from free block 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      dec   HL 
925e			 
925e			      ld    (IX+0), E               ; Save ptr to next free block 
925e			      ld    (IX+1), D 
925e			      ld    (IX+2), L               ; Save ptr to prev free block 
925e			      ld    (IX+3), H 
925e			 
925e			      ld    A, B                    ; Check if DE is greater than BC 
925e			      cp    D                       ; Compare MSB first 
925e			      jr    Z, $+4                  ; MSB the same, compare LSB 
925e			      jr    NC, free_find_higher_block_skip 
925e			      ld    A, C 
925e			      cp    E                       ; Then compare LSB 
925e			      jr    C, free_found_higher_block 
925e			 
925e			free_find_higher_block_skip: 
925e			      ld    A, D                    ; Reached the end of the free list? 
925e			      or    E 
925e			      jp    Z, free_done 
925e			 
925e			      ex    DE, HL 
925e			 
925e			      jr    free_find_higher_block 
925e			 
925e			free_found_higher_block: 
925e			      ; Insert freed block between prev and next free blocks 
925e			      ld    (HL), C                 ; Point prev free block to freed block 
925e			      inc   HL 
925e			      ld    (HL), B 
925e			 
925e			      ld    H, B                    ; Point freed block at next free block 
925e			      ld    L, C 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      ; Check if the freed block is adjacent to the next free block 
925e			      inc   HL                      ; Load size of freed block into HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      ex    DE, HL 
925e			 
925e			      add   HL, BC                  ; Add addr of freed block and its size 
925e			 
925e			      ld    E, (IX+0)               ; Load addr of next free block into DE 
925e			      ld    D, (IX+1) 
925e			 
925e			      or    A                       ; Clear the carry flag 
925e			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
925e			      jr    NZ, free_check_adjacent_to_prev 
925e			 
925e			      ; Freed block is adjacent to next, merge into one bigger block 
925e			      ex    DE, HL                  ; Load next ptr from next block into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  HL                      ; Save ptr to next block for later 
925e			 
925e			      ld    H, B                    ; Store ptr from next block into freed block 
925e			      ld    L, C 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      pop   HL                      ; Restore ptr to next block 
925e			      inc   HL                      ; Load size of next block into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  DE                      ; Save next block size for later 
925e			 
925e			      ld    H, B                    ; Load size of freed block into HL 
925e			      ld    L, C 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      ex    DE, HL 
925e			 
925e			      pop   DE                      ; Restore size of next block 
925e			      add   HL, DE                  ; Add sizes of both blocks 
925e			      ex    DE, HL 
925e			 
925e			      ld    H, B                    ; Store new bigger size into freed block 
925e			      ld    L, C 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			free_check_adjacent_to_prev: 
925e			      ; Check if the freed block is adjacent to the prev free block 
925e			      ld    L, (IX+2)               ; Prev free block ptr into HL 
925e			      ld    H, (IX+3) 
925e			 
925e			      inc   HL                      ; Size of prev free block into DE 
925e			      inc   HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      dec   HL 
925e			      dec   HL 
925e			      dec   HL 
925e			 
925e			      add   HL, DE                  ; Add prev block addr and size 
925e			 
925e			      or    A                       ; Clear the carry flag 
925e			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
925e			      jr    NZ, free_done 
925e			 
925e			      ; Freed block is adjacent to prev, merge into one bigger block 
925e			      ld    H, B                    ; Load next ptr from freed block into DE 
925e			      ld    L, C 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  HL                      ; Save freed block ptr for later 
925e			 
925e			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
925e			      ld    H, (IX+3) 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			      pop   HL                      ; Restore freed block ptr 
925e			      inc   HL                      ; Load size of freed block into DE 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			      push  DE                      ; Save freed block size for later 
925e			 
925e			      ld    L, (IX+2)               ; Load size of prev block into DE 
925e			      ld    H, (IX+3) 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    E, (HL) 
925e			      inc   HL 
925e			      ld    D, (HL) 
925e			 
925e			      pop   HL                      ; Add sizes of both blocks 
925e			      add   HL, DE 
925e			      ex    DE, HL 
925e			 
925e			      ld    L, (IX+2)               ; Store new bigger size into prev block 
925e			      ld    H, (IX+3) 
925e			      inc   HL 
925e			      inc   HL 
925e			      ld    (HL), E 
925e			      inc   HL 
925e			      ld    (HL), D 
925e			 
925e			free_done: 
925e			      ld    HL, 4                   ; Clean up stack frame 
925e			      add   HL, SP 
925e			      ld    SP, HL 
925e			 
925e			free_early_exit: 
925e			      pop   IX 
925e			      pop   DE 
925e			      pop   BC 
925e			 
925e			      ret 
925e			 
925e			 
925e			;      .org 0x8000 
925e			; 
925e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925e			 ;                 .dw   0 
925e			 
925e			endif 
925e			 
925e			 
925e			if MALLOC_4 
925e			 
925e			; My memory allocation code. Very very simple.... 
925e			; allocate space under 250 chars 
925e			 
925e			heap_init: 
925e				; init start of heap as zero 
925e				;  
925e			 
925e				ld hl, heap_start 
925e				ld a, 0 
925e				ld (hl), a      ; empty block 
925e				inc hl 
925e				ld a, 0 
925e				ld (hl), a      ; length of block 
925e				; write end of list 
925e				inc hl 
925e				ld a,(hl) 
925e				inc hl 
925e				ld a,(hl) 
925e				 
925e			 
925e				; init some malloc vars 
925e			 
925e				ld hl, 0 
925e				ld (free_list), hl       ; store last malloc location 
925e			 
925e				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
925e				ld a, 0 
925e				ld (hl), a 
925e			 
925e			 
925e				ld hl, heap_start 
925e				;  
925e				  
925e				ret 
925e			 
925e			 
925e			;    free block marker 
925e			;    requested size  
925e			;    pointer to next block 
925e			;    .... 
925e			;    next block marker 
925e			 
925e			 
925e			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
925e			; 
925e			 
925e			 
925e			malloc:  
925e				push de 
925e				push bc 
925e				push af 
925e			 
925e				; hl space required 
925e				 
925e				ld c, l    ; hold space   (TODO only a max of 255) 
925e			 
925e			;	inc c     ; TODO BUG need to fix memory leak on push str 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			;	inc c 
925e			 
925e			 
925e			 
925e				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
925e			 
925e				ld a, (free_list+3) 
925e				cp 0 
925e				jr z, .contheap 
925e			 
925e				ld hl, (free_list)     ; get last alloc 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mrs" 
925e						CALLMONITOR 
925e					endif 
925e				jr .startalloc 
925e			 
925e			.contheap: 
925e				ld hl, heap_start 
925e			 
925e			.startalloc: 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mym" 
925e						CALLMONITOR 
925e					endif 
925e			.findblock: 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mmf" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e				ld a,(hl)  
925e				; if byte is zero then clear to use 
925e			 
925e				cp 0 
925e				jr z, .foundemptyblock 
925e			 
925e				; if byte is not clear 
925e				;     then byte is offset to next block 
925e			 
925e				inc hl 
925e				ld a, (hl) ; get size 
925e			.nextblock:	inc hl 
925e					ld e, (hl) 
925e					inc hl 
925e					ld d, (hl) 
925e					ex de, hl 
925e			;	inc hl  ; move past the store space 
925e			;	inc hl  ; move past zero index  
925e			 
925e				; TODO detect no more space 
925e			 
925e				push hl 
925e				ld de, heap_end 
925e				call cmp16 
925e				pop hl 
925e				jr nc, .nospace 
925e			 
925e				jr .findblock 
925e			 
925e			.nospace: ld hl, 0 
925e				jp .exit 
925e			 
925e			 
925e			.foundemptyblock:	 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mme" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			; TODO has block enough space if reusing??? 
925e			 
925e				;  
925e			 
925e			; see if this block has been previously used 
925e				inc hl 
925e				ld a, (hl) 
925e				dec hl 
925e				cp 0 
925e				jr z, .newblock 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "meR" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			; no reusing previously allocated block 
925e			 
925e			; is it smaller than previously used? 
925e				 
925e				inc hl    ; move to size 
925e				ld a, c 
925e				sub (hl)        ; we want c < (hl) 
925e				dec hl    ; move back to marker 
925e			        jr z, .findblock 
925e			 
925e				; update with the new size which should be lower 
925e			 
925e			        ;inc  hl   ; negate next move. move back to size  
925e			 
925e			.newblock: 
925e				; need to be at marker here 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "meN" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			 
925e				ld a, c 
925e			 
925e				ld (free_list+3), a	 ; flag resume from last malloc  
925e				ld (free_list), hl    ; save out last location 
925e			 
925e			 
925e				;inc a     ; space for length byte 
925e				ld (hl), a     ; save block in use marker 
925e			 
925e				inc hl   ; move to space marker 
925e				ld (hl), a    ; save new space 
925e			 
925e				inc hl   ; move to start of allocated area 
925e				 
925e			;	push hl     ; save where we are - 1  
925e			 
925e			;	inc hl  ; move past zero index  
925e				; skip space to set down new marker 
925e			 
925e				; provide some extra space for now 
925e			 
925e				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
925e				inc a 
925e				inc a 
925e			 
925e				push hl   ; save where we are in the node block 
925e			 
925e				call addatohl 
925e			 
925e				; write linked list point 
925e			 
925e				pop de     ; get our node position 
925e				ex de, hl 
925e			 
925e				ld (hl), e 
925e				inc hl 
925e				ld (hl), d 
925e			 
925e				inc hl 
925e			 
925e				; now at start of allocated data so save pointer 
925e			 
925e				push hl 
925e			 
925e				; jump to position of next node and setup empty header in DE 
925e			 
925e				ex de, hl 
925e			 
925e			;	inc hl ; move past end of block 
925e			 
925e				ld a, 0 
925e				ld (hl), a   ; empty marker 
925e				inc hl 
925e				ld (hl), a   ; size 
925e				inc hl  
925e				ld (hl), a   ; ptr 
925e				inc hl 
925e				ld (hl), a   ; ptr 
925e			 
925e			 
925e				pop hl 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "mmr" 
925e						CALLMONITOR 
925e					endif 
925e			 
925e			.exit: 
925e				pop af 
925e				pop bc 
925e				pop de  
925e				ret 
925e			 
925e			 
925e			 
925e			 
925e			free:  
925e				push hl 
925e				push af 
925e				; get address in hl 
925e			 
925e					if DEBUG_FORTH_MALLOC_INT 
925e						DMARK "fre" 
925e						CALLMONITOR 
925e					endif 
925e				; data is at hl - move to block count 
925e				dec hl 
925e				dec hl    ; get past pointer 
925e				dec hl 
925e			 
925e				ld a, (hl)    ; need this for a validation check 
925e			 
925e				dec hl    ; move to block marker 
925e			 
925e				; now check that the block count and block marker are the same  
925e			        ; this checks that we are on a malloc node and not random memory 
925e			        ; OK a faint chance this could be a problem but rare - famous last words! 
925e			 
925e				ld c, a 
925e				ld a, (hl)    
925e			 
925e				cp c 
925e				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
925e			 
925e				; yes good chance we are on a malloc node 
925e			 
925e				ld a, 0      
925e				ld (hl), a   ; mark as free 
925e			 
925e				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
925e			 
925e			.freeignore:  
925e			 
925e				pop af 
925e				pop hl 
925e			 
925e				ret 
925e			 
925e			 
925e			 
925e			endif 
925e			 
925e			; eof 
# End of file firmware_memory.asm
925e			  
925e			; device C  
925e			; Now handled by SPI  
925e			;if SOUND_ENABLE  
925e			;	include "firmware_sound.asm"  
925e			;endif  
925e			  
925e			include "firmware_diags.asm"  
925e			; Hardware diags menu 
925e			 
925e			 
925e			config: 
925e			 
925e 3e 00			ld a, 0 
9260 21 7f 92			ld hl, .configmn 
9263 cd ee 8a			call menu 
9266			 
9266 fe 00			cp 0 
9268 c8				ret z 
9269			 
9269			;	cp 1 
9269			;	call z, .savetostore 
9269			 
9269 fe 01			cp 1 
926b			if STARTUP_V1 
926b cc 93 92			call z, .selautoload 
926e			endif 
926e			 
926e			if STARTUP_V2 
926e				call z, .enautoload 
926e			endif 
926e fe 02			cp 2 
9270 cc 89 92			call z, .disautoload 
9273			;	cp 3 
9273			;	call z, .selbank 
9273 fe 03			cp 3 
9275 cc b1 92			call z, .debug_tog 
9278 fe 04			cp 4 
927a cc 80 93			call z, .bpsgo 
927d			;	cp 5 
927d			;	call z, hardware_diags 
927d			if STARTUP_V2 
927d				cp 5 
927d				call z, create_startup 
927d			endif 
927d 18 df			jr config 
927f			 
927f			.configmn: 
927f			;	dw prom_c3 
927f 6e 95			dw prom_c2 
9281 83 95			dw prom_c2a 
9283			;	dw prom_c2b 
9283			;	dw prom_c4 
9283 a2 95			dw prom_m4 
9285 bd 95			dw prom_m4b 
9287			;	dw prom_c1 
9287			if STARTUP_V2 
9287				dw prom_c9 
9287			endif 
9287 00 00			dw 0 
9289				 
9289			 
9289			if STARTUP_V2 
9289			.enautoload: 
9289				if STORAGE_SE 
9289				ld a, $fe      ; bit 0 clear 
9289				ld (spi_device), a 
9289			 
9289				call storage_get_block_0 
9289			 
9289				ld a, 1 
9289				ld (store_page+STORE_0_AUTOFILE), a 
9289			 
9289					ld hl, 0 
9289					ld de, store_page 
9289				call storage_write_block	 ; save update 
9289				else 
9289			 
9289				ld hl, prom_notav 
9289				ld de, prom_empty 
9289				call info_panel 
9289				endif 
9289			 
9289			 
9289				ret 
9289			endif 
9289			 
9289			.disautoload: 
9289				if STORAGE_SE 
9289				ld a, $fe      ; bit 0 clear 
9289				ld (spi_device), a 
9289			 
9289				call storage_get_block_0 
9289			 
9289				ld a, 0 
9289				ld (store_page+STORE_0_AUTOFILE), a 
9289			 
9289					ld hl, 0 
9289					ld de, store_page 
9289				call storage_write_block	 ; save update 
9289				else 
9289			 
9289 21 c5 95			ld hl, prom_notav 
928c 11 db 95			ld de, prom_empty 
928f cd 4e 8a			call info_panel 
9292				endif 
9292			 
9292			 
9292 c9				ret 
9293			 
9293			if STARTUP_V1 
9293			 
9293			; Select auto start 
9293			 
9293			.selautoload: 
9293			 
9293				 
9293				if STORAGE_SE 
9293			 
9293					call config_dir 
9293				        ld hl, scratch 
9293					ld a, 0 
9293					call menu 
9293			 
9293					cp 0 
9293					ret z 
9293			 
9293					dec a 
9293			 
9293			 
9293					; locate menu option 
9293			 
9293					ld hl, scratch 
9293					call table_lookup 
9293			 
9293					if DEBUG_FORTH_WORDS 
9293						DMARK "ALl" 
9293						CALLMONITOR 
9293					endif 
9293					; with the pointer to the menu it, the byte following the zero term is the file id 
9293			 
9293					ld a, 0 
9293					ld bc, 50   ; max of bytes to look at 
9293					cpir  
9293			 
9293					if DEBUG_FORTH_WORDS 
9293						DMARK "ALb" 
9293						CALLMONITOR 
9293					endif 
9293					;inc hl 
9293			 
9293					ld a, (hl)   ; file id 
9293					 
9293				        ; save bank and file ids 
9293			 
9293					push af 
9293			 
9293			; TODO need to save to block 0 on bank 1	 
9293			 
9293					call storage_get_block_0 
9293			 
9293					if DEBUG_FORTH_WORDS 
9293						DMARK "AL0" 
9293						CALLMONITOR 
9293					endif 
9293					pop af 
9293			 
9293					ld (store_page+STORE_0_FILERUN),a 
9293					 
9293					; save bank id 
9293			 
9293					ld a,(spi_device) 
9293					ld (store_page+STORE_0_BANKRUN),a 
9293			 
9293					; enable auto run of store file 
9293			 
9293					ld a, 1 
9293					ld (store_page+STORE_0_AUTOFILE),a 
9293			 
9293					; save buffer 
9293			 
9293					ld hl, 0 
9293					ld de, store_page 
9293					if DEBUG_FORTH_WORDS 
9293						DMARK "ALw" 
9293						CALLMONITOR 
9293					endif 
9293				call storage_write_block	 ; save update 
9293			  
9293			 
9293			 
9293			 
9293					ld hl, scratch 
9293					call config_fdir 
9293			 
9293				else 
9293			 
9293 21 c5 95			ld hl, prom_notav 
9296 11 db 95			ld de, prom_empty 
9299 cd 4e 8a			call info_panel 
929c			 
929c				endif 
929c c9				ret 
929d			endif 
929d			 
929d			 
929d			; Select storage bank 
929d			 
929d			.selbank: 
929d			 
929d			;	if STORAGE_SE 
929d			;	else 
929d			 
929d 21 c5 95			ld hl, prom_notav 
92a0 11 db 95			ld de, prom_empty 
92a3 cd 4e 8a			call info_panel 
92a6			;	endif 
92a6				 
92a6 c9				ret 
92a7			 
92a7			if STORAGE_SE 
92a7			 
92a7			.config_ldir:   
92a7				; Load storage bank labels into menu array 
92a7			 
92a7				 
92a7			 
92a7			 
92a7				ret 
92a7			 
92a7			 
92a7			endif 
92a7			 
92a7			 
92a7			; Save user words to storage 
92a7			 
92a7			.savetostore: 
92a7			 
92a7			;	if STORAGE_SE 
92a7			; 
92a7			;		call config_dir 
92a7			;	        ld hl, scratch 
92a7			;		ld a, 0 
92a7			;		call menu 
92a7			;		 
92a7			;		ld hl, scratch 
92a7			;		call config_fdir 
92a7			; 
92a7			;	else 
92a7			 
92a7 21 c5 95			ld hl, prom_notav 
92aa 11 db 95			ld de, prom_empty 
92ad cd 4e 8a			call info_panel 
92b0			 
92b0			;	endif 
92b0			 
92b0 c9				ret 
92b1			 
92b1			if STARTUP_V2 
92b1			 
92b1			create_startup: 
92b1			 
92b1				ld a, 0 
92b1				ld hl, .crstart 
92b1				call menu 
92b1			 
92b1				cp 0 
92b1				ret z 
92b1			 
92b1				cp 1 
92b1				call z, .genlsword 
92b1				cp 2 
92b1				call z, .genedword 
92b1			 
92b1				cp 3 
92b1				call z, .gendemword 
92b1			 
92b1				cp 4 
92b1				call z, .genutlword 
92b1				cp 5 
92b1				call z, .genspiword 
92b1				cp 6 
92b1				call z, .genkeyword 
92b1				cp 7 
92b1				call z, .gensoundword 
92b1				cp 8 
92b1				call z, .genhwword 
92b1				jr create_startup 
92b1			 
92b1			.genhwword: 
92b1				ld hl, crs_hw 
92b1				ld de, .hwworddef 
92b1				call .genfile 
92b1				ret 
92b1			.gensoundword: 
92b1				ld hl, crs_sound 
92b1				ld de, .soundworddef 
92b1				call .genfile 
92b1				ret 
92b1			.genlsword: 
92b1				ld hl, crs_s1 
92b1				ld de, .lsworddef 
92b1				call .genfile 
92b1				ret 
92b1			 
92b1			.genedword: 
92b1				ld de, .edworddef 
92b1				ld hl, crs_s2 
92b1				call .genfile 
92b1				ret 
92b1			 
92b1			.gendemword: 
92b1				ld de, .demoworddef 
92b1				ld hl, crs_s3 
92b1				call .genfile 
92b1				ret 
92b1			 
92b1			.genutlword: 
92b1				ld hl, crs_s4 
92b1				ld de, .utilwordef 
92b1				call .genfile 
92b1				ret 
92b1			.genspiword: 
92b1				ld hl, crs_s5 
92b1				ld de, .spiworddef 
92b1				call .genfile 
92b1				ret 
92b1			.genkeyword: 
92b1				ld hl, crs_s6 
92b1				ld de, .keyworddef 
92b1				call .genfile 
92b1				ret 
92b1			 
92b1			; hl - points to file name 
92b1			; de - points to strings to add to file 
92b1			 
92b1			.genfile: 
92b1				push hl 
92b1				push de 
92b1			 
92b1				call clear_display 
92b1				ld a, display_row_1 
92b1				ld de, .genfiletxt 
92b1				call str_at_display 
92b1				call update_display 
92b1			 
92b1				pop de 
92b1				pop hl 
92b1			 
92b1			 
92b1				push de 
92b1				call storage_create 
92b1				; id in hl 
92b1				pop de   ; table of strings to add 
92b1			 
92b1			.genloop: 
92b1			 
92b1				push hl ; save id for next time around 
92b1				push de ; save de for next time around 
92b1			 
92b1				ex de, hl 
92b1				call loadwordinhl 
92b1				ex de, hl 
92b1			 
92b1				; need hl to be the id 
92b1				; need de to be the string ptr 
92b1				 
92b1				call storage_append 
92b1			 
92b1				pop de 
92b1				pop hl 
92b1			 
92b1				inc de 
92b1				inc de 
92b1			 
92b1				ld a,(de) 
92b1				cp 0 
92b1				jr nz, .genloop 
92b1				inc de 
92b1				ld a, (de) 
92b1				dec de 
92b1				cp 0 
92b1				jr nz, .genloop	 
92b1			 
92b1				ret 
92b1			 
92b1			.genfiletxt:  db "Creating file...",0 
92b1			 
92b1			.hwworddef: 
92b1				dw test5 
92b1				dw test6 
92b1				dw test7 
92b1				dw test8 
92b1				dw test9 
92b1				dw test10 
92b1				dw 0 
92b1			 
92b1			.soundworddef: 
92b1				dw sound1 
92b1				dw sound2 
92b1				dw sound3 
92b1				dw sound4 
92b1				dw sound5 
92b1				dw sound6 
92b1				dw sound7 
92b1				dw sound8 
92b1				dw sound9 
92b1				dw 0 
92b1			 
92b1			.utilwordef: 
92b1				dw strncpy 
92b1				dw type 
92b1				dw tuck 
92b1				dw clrstack 
92b1				dw longread 
92b1				dw start1 
92b1				dw start2 
92b1			; duplicated 
92b1			;	dw start3b 
92b1			;	dw start3c 
92b1				dw list 
92b1				dw 0 
92b1			 
92b1			.lsworddef: 
92b1				dw start3b 
92b1				dw 0 
92b1			 
92b1			.edworddef: 
92b1				dw edit1 
92b1				dw edit2 
92b1				dw edit3 
92b1				dw 0 
92b1			 
92b1			.demoworddef: 
92b1				dw game1 
92b1				dw game1a 
92b1				dw game1b 
92b1				dw game1c 
92b1				dw game1d 
92b1				dw game1s 
92b1				dw game1t 
92b1				dw game1f 
92b1				dw game1z 
92b1				dw game1zz 
92b1				dw ssv2 
92b1				dw ssv3 
92b1				dw ssv4 
92b1				dw ssv5 
92b1				dw ssv1 
92b1				dw ssv1cpm	 
92b1			;	dw game2b 
92b1			;	dw game2bf 
92b1			;	dw game2mba 
92b1			;	dw game2mbas	 
92b1			;	dw game2mbht 
92b1			;	dw game2mbms 
92b1			;	dw game2mb 
92b1			;	dw game3w 
92b1			;	dw game3p 
92b1			;	dw game3sc 
92b1			;	dw game3vsi 
92b1			;	dw game3vs 
92b1				dw 0 
92b1			 
92b1			 
92b1			.spiworddef: 
92b1			 
92b1			    dw spi1 
92b1			    dw spi2 
92b1			    dw spi2b 
92b1			    dw spi3 
92b1			    dw spi4 
92b1			    dw spi5 
92b1			;    dw spi6 
92b1			;    dw spi7 
92b1			 
92b1			;    dw spi8 
92b1			;    dw spi9 
92b1			;    dw spi10 
92b1			    dw 0 
92b1			 
92b1			.keyworddef: 
92b1			 
92b1				dw keyup 
92b1				dw keydown 
92b1				dw keyleft 
92b1				dw keyright 
92b1				dw 	keyf1 
92b1				dw keyf2 
92b1				dw keyf3 
92b1				dw keyf4 
92b1				dw keyf5 
92b1				dw keyf6 
92b1				dw keyf7 
92b1				dw keyf8 
92b1				dw keyf9 
92b1				dw keyf10 
92b1				dw keyf11 
92b1				dw keyf12 
92b1				dw keytab 
92b1				dw keycr 
92b1				dw keyhome 
92b1				dw keyend 
92b1				dw keybs 
92b1				dw 0 
92b1			 
92b1			.crstart: 
92b1				dw crs_s1 
92b1				dw crs_s2 
92b1				dw crs_s3 
92b1				dw crs_s4 
92b1				dw crs_s5 
92b1				dw crs_s6 
92b1				dw crs_sound 
92b1				dw crs_hw 
92b1				dw 0 
92b1			 
92b1			endif 
92b1			 
92b1			 
92b1			if STORAGE_SE 
92b1			 
92b1			config_fdir: 
92b1				; using the scratch dir go through and release the memory allocated for each string 
92b1				 
92b1				ld hl, scratch 
92b1			.cfdir:	ld e,(hl) 
92b1				inc hl 
92b1				ld d,(hl) 
92b1				inc hl 
92b1			 
92b1				ex de, hl 
92b1				call ishlzero 
92b1				ret z     ; return on null pointer 
92b1				call free 
92b1				ex de, hl 
92b1				jr .cfdir 
92b1			 
92b1			 
92b1				ret 
92b1			 
92b1			 
92b1			config_dir: 
92b1			 
92b1				; for the config menus that need to build a directory of storage call this routine 
92b1				; it will construct a menu in scratch to pass to menu 
92b1			 
92b1				; open storage device 
92b1			 
92b1				; execute DIR to build a list of files and their ids into scratch in menu format 
92b1				; once the menu has finished then will need to call config_fdir to release the strings 
92b1				 
92b1				; c = number items 
92b1			 
92b1				 
92b1				call storage_get_block_0 
92b1			 
92b1				ld hl, store_page     ; get current id count 
92b1				ld b, (hl) 
92b1				ld c, 0    ; count of files   
92b1			 
92b1			 
92b1				ld hl, scratch 
92b1				ld (store_tmp2), hl    ; location to poke strings 
92b1			 
92b1				; check for empty drive 
92b1			 
92b1				ld a, 0 
92b1				cp b 
92b1				jp z, .dirdone 
92b1			 
92b1				 
92b1					if DEBUG_FORTH_WORDS 
92b1						DMARK "Cdc" 
92b1						CALLMONITOR 
92b1					endif 
92b1			 
92b1			 
92b1			.diritem:	 
92b1				push bc 
92b1				; for each of the current ids do a search for them and if found push to stack 
92b1			 
92b1					ld hl, STORE_BLOCK_PHY 
92b1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
92b1					ld e,b 
92b1			 
92b1					call storage_findnextid 
92b1			 
92b1			 
92b1					; if found hl will be non zero 
92b1			 
92b1					call ishlzero 
92b1					jr z, .dirnotfound 
92b1			 
92b1					; increase count 
92b1			 
92b1					pop bc	 
92b1					inc c 
92b1					push bc 
92b1					 
92b1			 
92b1					; get file header and push the file name 
92b1			 
92b1					ld de, store_page 
92b1					call storage_read_block 
92b1			 
92b1					; push file id to stack 
92b1				 
92b1					ld a, (store_page) 
92b1					ld h, 0 
92b1					ld l, a 
92b1			 
92b1					;call forth_push_numhl 
92b1					; TODO store id 
92b1			 
92b1					push hl 
92b1			 
92b1					; push extent count to stack  
92b1				 
92b1					ld hl, store_page+3 
92b1			 
92b1					; get file name length 
92b1			 
92b1					call strlenz   
92b1			 
92b1					inc hl   ; cover zero term 
92b1					inc hl  ; stick the id at the end of the area 
92b1			 
92b1					push hl 
92b1					pop bc    ; move length to bc 
92b1			 
92b1					call malloc 
92b1			 
92b1					; TODO save malloc area to scratch 
92b1			 
92b1					ex de, hl 
92b1					ld hl, (store_tmp2) 
92b1					ld (hl), e 
92b1					inc hl 
92b1					ld (hl), d 
92b1					inc hl 
92b1					ld (store_tmp2), hl 
92b1			 
92b1					 
92b1			 
92b1					;pop hl   ; get source 
92b1			;		ex de, hl    ; swap aronund	 
92b1			 
92b1					ld hl, store_page+3 
92b1					if DEBUG_FORTH_WORDS 
92b1						DMARK "CFd" 
92b1						CALLMONITOR 
92b1					endif 
92b1					ldir 
92b1			 
92b1					; de is past string, move back one and store id 
92b1					 
92b1					dec de 
92b1			 
92b1					; store file id 
92b1			 
92b1					pop hl 
92b1					ex de,hl 
92b1					ld (hl), e 
92b1			 
92b1					if DEBUG_FORTH_WORDS 
92b1						DMARK "Cdi" 
92b1						CALLMONITOR 
92b1					endif 
92b1					 
92b1			.dirnotfound: 
92b1					pop bc     
92b1					djnz .diritem 
92b1				 
92b1			.dirdone:	 
92b1			 
92b1					ld a, 0 
92b1					ld hl, (store_tmp2) 
92b1					ld (hl), a 
92b1					inc hl 
92b1					ld (hl), a 
92b1					inc hl 
92b1					; push a count of the dir items found 
92b1			 
92b1			;		ld h, 0 
92b1			;		ld l, c 
92b1			 
92b1				ret 
92b1			 
92b1			endif 
92b1			 
92b1			 
92b1			; Settings 
92b1			; Run  
92b1			 
92b1			 
92b1			 
92b1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
92b1			;;hd_menu2:   db "        2: Editor",0   
92b1			;hd_menu2:   db "        2: Editor       6: Menu",0   
92b1			;hd_menu3:   db "        3: Storage",0 
92b1			;hd_menu4:   db "0=quit  4: Debug",0 
92b1			;hd_don:     db "ON",0 
92b1			;hd_doff:     db "OFF",0 
92b1			; 
92b1			; 
92b1			; 
92b1			;hardware_diags_old:       
92b1			; 
92b1			;.diagmenu: 
92b1			;	call clear_display 
92b1			;	ld a, display_row_1 
92b1			;	ld de, hd_menu1 
92b1			;	call str_at_display 
92b1			; 
92b1			;	ld a, display_row_2 
92b1			;	ld de, hd_menu2 
92b1			;	call str_at_display 
92b1			; 
92b1			;	ld a, display_row_3 
92b1			;	ld de, hd_menu3 
92b1			;	call str_at_display 
92b1			; 
92b1			;	ld a,  display_row_4 
92b1			;	ld de, hd_menu4 
92b1			;	call str_at_display 
92b1			; 
92b1			;	; display debug state 
92b1			; 
92b1			;	ld de, hd_don 
92b1			;	ld a, (os_view_disable) 
92b1			;	cp 0 
92b1			;	jr z, .distog 
92b1			;	ld de, hd_doff 
92b1			;.distog: ld a, display_row_4+17 
92b1			;	call str_at_display 
92b1			; 
92b1			;	call update_display 
92b1			; 
92b1			;	call cin_wait 
92b1			; 
92b1			; 
92b1			; 
92b1			;	cp '4' 
92b1			;	jr nz, .diagn1 
92b1			; 
92b1			;	; debug toggle 
92b1			; 
92b1			;	ld a, (os_view_disable) 
92b1			;	ld b, '*' 
92b1			;	cp 0 
92b1			;	jr z, .debtog 
92b1			;	ld b, 0 
92b1			;.debtog:	 
92b1			;	ld a,b 
92b1			;	ld (os_view_disable),a 
92b1			; 
92b1			;.diagn1: cp '0' 
92b1			;	 ret z 
92b1			; 
92b1			;;	cp '1' 
92b1			;;       jp z, matrix	 
92b1			;;   TODO keyboard matrix test 
92b1			; 
92b1			;	cp '2' 
92b1			;	jp z, .diagedit 
92b1			; 
92b1			;;	cp '6' 
92b1			;;	jp z, .menutest 
92b1			;;if ENABLE_BASIC 
92b1			;;	cp '6' 
92b1			;;	jp z, basic 
92b1			;;endif 
92b1			 ; 
92b1			;	jp .diagmenu 
92b1			; 
92b1			; 
92b1			;	ret 
92b1			 
92b1			 
92b1			.debug_tog: 
92b1 21 da 92			ld hl, .menudebug 
92b4				 
92b4			;	ld a, (os_view_disable) 
92b4			;	cp '*' 
92b4 3a 6f ee			ld a,(debug_vector) 
92b7 fe c9			cp $C9   ; RET 
92b9 20 04			jr nz,.tdon  
92bb 3e 01			ld a, 1 
92bd 18 02			jr .tog1 
92bf 3e 00		.tdon: ld a, 0 
92c1			 
92c1			.tog1: 
92c1 cd ee 8a			call menu 
92c4 fe 00			cp 0 
92c6 c8				ret z 
92c7 fe 01			cp 1    ; disable debug 
92c9 28 04			jr z, .dtog0 
92cb 3e 2a			ld a, '*' 
92cd 18 05			jr .dtogset 
92cf			.dtog0:  
92cf				;ld a, 0 
92cf cd 6e 93			call bp_on 
92d2 18 dd			jr .debug_tog 
92d4			.dtogset:  
92d4				; ld (os_view_disable), a 
92d4 cd 7a 93			call bp_off 
92d7 c3 b1 92			jp .debug_tog 
92da			 
92da			 
92da			.menudebug: 
92da e0 92				dw .m6 
92dc e9 92				dw .m7 
92de 00 00				dw 0 
92e0 .. 00		.m6:   db "Debug ON",0 
92e9 .. 00		.m7:   db "Debug OFF",0 
92f3			;hardware_diags:       
92f3			 
92f3			ENABLE_HDIAGS: equ 0 
92f3			 
92f3			if ENABLE_HDIAGS 
92f3			.diagm: 
92f3				ld hl, .menuitems 
92f3				ld a, 0 
92f3				call menu 
92f3			 
92f3			         cp 0 
92f3				 ret z 
92f3			 
92f3				cp 2 
92f3				jp z, .diagedit 
92f3			 
92f3			;	cp '6' 
92f3			;	jp z, .menutest 
92f3			;if ENABLE_BASIC 
92f3			;	cp '6' 
92f3			;	jp z, basic 
92f3			;endif 
92f3			  
92f3				jp .diagm 
92f3			 
92f3				 
92f3			.menuitems:   	dw .m1 
92f3					dw .m2 
92f3					dw .m3 
92f3					dw .m5 
92f3					dw .m5a 
92f3					dw .m5b 
92f3					dw 0 
92f3			 
92f3			 
92f3			.m1:   db "Key Matrix",0 
92f3			.m2:   db "Editor",0 
92f3			.m3:   db "Storage",0 
92f3			.m5:   db "Sound",0 
92f3			.m5a:  db "RAM Test",0 
92f3			.m5b:  db "LCD Test",0 
92f3			 
92f3			 
92f3			; debug editor 
92f3			 
92f3			.diagedit: 
92f3			 
92f3				ld hl, scratch 
92f3			;	ld bc, 250 
92f3			;	ldir 
92f3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
92f3				ld a, 0 
92f3				ld (hl), a 
92f3				inc hl 
92f3				ld (hl), a 
92f3				inc hl 
92f3				ld (hl), a 
92f3			 
92f3			        call clear_display 
92f3				call update_display 
92f3				;ld a, 1 
92f3				;ld (hardware_diag), a 
92f3			.diloop: 
92f3				ld a, display_row_1 
92f3				ld c, 0 
92f3				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
92f3				ld e, 40 
92f3			 
92f3				ld hl, scratch	 
92f3				call input_str 
92f3			 
92f3				ld a, display_row_2 
92f3				ld de, scratch 
92f3				call str_at_display 
92f3				call update_display 
92f3			 
92f3				jp .diloop 
92f3			endif 
92f3			 
92f3			; pass word in hl 
92f3			; a has display location 
92f3			display_word_at: 
92f3 f5				push af 
92f4 e5				push hl 
92f5 7c				ld a,h 
92f6 21 bd e5			ld hl, os_word_scratch 
92f9 cd f3 8e			call hexout 
92fc e1				pop hl 
92fd 7d				ld a,l 
92fe 21 bf e5			ld hl, os_word_scratch+2 
9301 cd f3 8e			call hexout 
9304 21 c1 e5			ld hl, os_word_scratch+4 
9307 3e 00			ld a,0 
9309 77				ld (hl),a 
930a 11 bd e5			ld de,os_word_scratch 
930d f1				pop af 
930e cd d0 8a				call str_at_display 
9311 c9				ret 
9312			 
9312			display_ptr_state: 
9312			 
9312				; to restore afterwards 
9312			 
9312 d5				push de 
9313 c5				push bc 
9314 e5				push hl 
9315 f5				push af 
9316			 
9316				; for use in here 
9316			 
9316			;	push bc 
9316			;	push de 
9316			;	push hl 
9316			;	push af 
9316			 
9316 cd bd 8a			call clear_display 
9319			 
9319 11 f1 94			ld de, .ptrstate 
931c 3e 00			ld a, display_row_1 
931e cd d0 8a			call str_at_display 
9321			 
9321				; display debug step 
9321			 
9321			 
9321 11 62 ee			ld de, debug_mark 
9324 3e 26			ld a, display_row_1+display_cols-2 
9326 cd d0 8a			call str_at_display 
9329			 
9329				; display a 
9329 11 fb 94			ld de, .ptrcliptr 
932c 3e 28			ld a, display_row_2 
932e cd d0 8a			call str_at_display 
9331			 
9331 f1				pop af 
9332 2a 37 ea			ld hl,(cli_ptr) 
9335 3e 30			ld a, display_row_2+8 
9337 cd f3 92			call display_word_at 
933a			 
933a			 
933a				; display hl 
933a			 
933a			 
933a 11 03 95			ld de, .ptrclioptr 
933d 3e 32			ld a, display_row_2+10 
933f cd d0 8a			call str_at_display 
9342			; 
9342			;	pop hl 
9342 3e 35			ld a, display_row_2+13 
9344 2a 35 ea			ld hl,(cli_origptr) 
9347 cd f3 92			call display_word_at 
934a			; 
934a			;	 
934a			;	; display de 
934a			 
934a			;	ld de, .regstatede 
934a			;	ld a, display_row_3 
934a			;	call str_at_display 
934a			 
934a			;	pop de 
934a			;	ld h,d 
934a			;	ld l, e 
934a			;	ld a, display_row_3+3 
934a			;	call display_word_at 
934a			 
934a			 
934a				; display bc 
934a			 
934a			;	ld de, .regstatebc 
934a			;	ld a, display_row_3+10 
934a			;	call str_at_display 
934a			 
934a			;	pop bc 
934a			;	ld h,b 
934a			;	ld l, c 
934a			;	ld a, display_row_3+13 
934a			;	call display_word_at 
934a			 
934a			 
934a				; display dsp 
934a			 
934a			;	ld de, .regstatedsp 
934a			;	ld a, display_row_4 
934a			;	call str_at_display 
934a			 
934a				 
934a			;	ld hl,(cli_data_sp) 
934a			;	ld a, display_row_4+4 
934a			;	call display_word_at 
934a			 
934a				; display rsp 
934a			 
934a 11 32 95			ld de, .regstatersp 
934d 3e 82			ld a, display_row_4+10 
934f cd d0 8a			call str_at_display 
9352			 
9352				 
9352 2a e9 e9			ld hl,(cli_ret_sp) 
9355 3e 86			ld a, display_row_4+14 
9357 cd f3 92			call display_word_at 
935a			 
935a cd e0 8a			call update_display 
935d			 
935d cd 00 8a			call delay1s 
9360 cd 00 8a			call delay1s 
9363 cd 00 8a			call delay1s 
9366			 
9366			 
9366 cd 6d 99			call next_page_prompt 
9369			 
9369				; restore  
9369			 
9369 f1				pop af 
936a e1				pop hl 
936b c1				pop bc 
936c d1				pop de 
936d c9				ret 
936e			 
936e			; Update the break point vector so that the user can hook a new routine 
936e			 
936e			bp_on: 
936e 3e c3			ld a, $c3    ; JP 
9370 32 6f ee			ld (debug_vector), a 
9373 21 80 93			ld hl, break_point_state 
9376 22 70 ee			ld (debug_vector+1), hl 
9379 c9				ret 
937a			 
937a			bp_off: 
937a 3e c9			ld a, $c9    ; RET 
937c 32 6f ee			ld (debug_vector), a 
937f c9				ret 
9380			 
9380			 
9380			break_point_state: 
9380			;	push af 
9380			; 
9380			;	; see if disabled 
9380			; 
9380			;	ld a, (os_view_disable) 
9380			;	cp '*' 
9380			;	jr nz, .bpsgo 
9380			;	pop af 
9380			;	ret 
9380			 
9380			.bpsgo: 
9380			;	pop af 
9380 f5				push af 
9381 22 9a e2			ld (os_view_hl), hl 
9384 ed 53 98 e2		ld (os_view_de), de 
9388 ed 43 96 e2		ld (os_view_bc), bc 
938c e5				push hl 
938d 6f				ld l, a 
938e 26 00			ld h, 0 
9390 22 9c e2			ld (os_view_af),hl 
9393			 
9393 21 a8 ed				ld hl, display_fb0 
9396 22 c3 eb				ld (display_fb_active), hl 
9399 e1				pop hl	 
939a			 
939a 3e 31			ld a, '1' 
939c fe 2a		.bps1:  cp '*' 
939e cc 7a 93			call z, bp_off 
93a1			;	jr nz, .bps1b 
93a1			;	ld (os_view_disable),a 
93a1 fe 31		.bps1b:  cp '1' 
93a3 20 14			jr nz, .bps2 
93a5			 
93a5				; display reg 
93a5			 
93a5				 
93a5			 
93a5 3a 9c e2			ld a, (os_view_af) 
93a8 2a 9a e2			ld hl, (os_view_hl) 
93ab ed 5b 98 e2		ld de, (os_view_de) 
93af ed 4b 96 e2		ld bc, (os_view_bc) 
93b3 cd 4d 94			call display_reg_state 
93b6 c3 39 94			jp .bpschk 
93b9			 
93b9 fe 32		.bps2:  cp '2' 
93bb 20 08			jr nz, .bps3 
93bd				 
93bd				; display hl 
93bd 2a 9a e2			ld hl, (os_view_hl) 
93c0 cd 37 95			call display_dump_at_hl 
93c3			 
93c3 18 74			jr .bpschk 
93c5			 
93c5 fe 33		.bps3:  cp '3' 
93c7 20 08			jr nz, .bps4 
93c9			 
93c9			        ; display de 
93c9 2a 98 e2			ld hl, (os_view_de) 
93cc cd 37 95			call display_dump_at_hl 
93cf			 
93cf 18 68			jr .bpschk 
93d1 fe 34		.bps4:  cp '4' 
93d3 20 08			jr nz, .bps5 
93d5			 
93d5			        ; display bc 
93d5 2a 96 e2			ld hl, (os_view_bc) 
93d8 cd 37 95			call display_dump_at_hl 
93db			 
93db 18 5c			jr .bpschk 
93dd fe 35		.bps5:  cp '5' 
93df 20 08		        jr nz, .bps7 
93e1			 
93e1				; display cur ptr 
93e1 2a 37 ea			ld hl, (cli_ptr) 
93e4 cd 37 95			call display_dump_at_hl 
93e7			 
93e7 18 50			jr .bpschk 
93e9 fe 36		.bps7:  cp '6' 
93eb 20 08			jr nz, .bps8b 
93ed				 
93ed				; display cur orig ptr 
93ed 2a 35 ea			ld hl, (cli_origptr) 
93f0 cd 37 95			call display_dump_at_hl 
93f3 18 44			jr .bpschk 
93f5 fe 37		.bps8b:  cp '7' 
93f7 20 08			jr nz, .bps9 
93f9				 
93f9				; display dsp 
93f9 2a e5 e9			ld hl, (cli_data_sp) 
93fc cd 37 95			call display_dump_at_hl 
93ff			 
93ff 18 38			jr .bpschk 
9401 fe 39		.bps9:  cp '9' 
9403 20 05			jr nz, .bps8c 
9405				 
9405				; display SP 
9405			;	ld hl, sp 
9405 cd 37 95			call display_dump_at_hl 
9408			 
9408 18 2f			jr .bpschk 
940a fe 38		.bps8c:  cp '8' 
940c 20 08			jr nz, .bps8d 
940e				 
940e				; display rsp 
940e 2a e9 e9			ld hl, (cli_ret_sp) 
9411 cd 37 95			call display_dump_at_hl 
9414			 
9414 18 23			jr .bpschk 
9416 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9418 20 05			jr nz, .bps8 
941a cd 27 97			call monitor 
941d			 
941d 18 1a			jr .bpschk 
941f fe 30		.bps8:  cp '0' 
9421 20 16			jr nz, .bpschk 
9423			 
9423 21 07 ed				ld hl, display_fb1 
9426 22 c3 eb				ld (display_fb_active), hl 
9429 cd e0 8a				call update_display 
942c			 
942c				;ld a, (os_view_af) 
942c 2a 9a e2			ld hl, (os_view_hl) 
942f ed 5b 98 e2		ld de, (os_view_de) 
9433 ed 4b 96 e2		ld bc, (os_view_bc) 
9437 f1				pop af 
9438 c9				ret 
9439			 
9439			.bpschk:   
9439 cd 00 8a			call delay1s 
943c 3e 9f		ld a,display_row_4 + display_cols - 1 
943e 11 6b 99		        ld de, endprg 
9441 cd d0 8a			call str_at_display 
9444 cd e0 8a			call update_display 
9447 cd db e3			call cin_wait 
944a			 
944a c3 9c 93			jp .bps1 
944d			 
944d			 
944d			display_reg_state: 
944d			 
944d				; to restore afterwards 
944d			 
944d d5				push de 
944e c5				push bc 
944f e5				push hl 
9450 f5				push af 
9451			 
9451				; for use in here 
9451			 
9451 c5				push bc 
9452 d5				push de 
9453 e5				push hl 
9454 f5				push af 
9455			 
9455 cd bd 8a			call clear_display 
9458			 
9458 11 0d 95			ld de, .regstate 
945b 3e 00			ld a, display_row_1 
945d cd d0 8a			call str_at_display 
9460			 
9460				; display debug step 
9460			 
9460			 
9460 11 62 ee			ld de, debug_mark 
9463 3e 25			ld a, display_row_1+display_cols-3 
9465 cd d0 8a			call str_at_display 
9468			 
9468				; display a 
9468 11 29 95			ld de, .regstatea 
946b 3e 28			ld a, display_row_2 
946d cd d0 8a			call str_at_display 
9470			 
9470 e1				pop hl 
9471			;	ld h,0 
9471			;	ld l, a 
9471 3e 2b			ld a, display_row_2+3 
9473 cd f3 92			call display_word_at 
9476			 
9476			 
9476				; display hl 
9476			 
9476			 
9476 11 1d 95			ld de, .regstatehl 
9479 3e 32			ld a, display_row_2+10 
947b cd d0 8a			call str_at_display 
947e			 
947e e1				pop hl 
947f 3e 35			ld a, display_row_2+13 
9481 cd f3 92			call display_word_at 
9484			 
9484				 
9484				; display de 
9484			 
9484 11 21 95			ld de, .regstatede 
9487 3e 50			ld a, display_row_3 
9489 cd d0 8a			call str_at_display 
948c			 
948c e1				pop hl 
948d			;	ld h,d 
948d			;	ld l, e 
948d 3e 53			ld a, display_row_3+3 
948f cd f3 92			call display_word_at 
9492			 
9492			 
9492				; display bc 
9492			 
9492 11 25 95			ld de, .regstatebc 
9495 3e 5a			ld a, display_row_3+10 
9497 cd d0 8a			call str_at_display 
949a			 
949a e1				pop hl 
949b			;	ld h,b 
949b			;	ld l, c 
949b 3e 5d			ld a, display_row_3+13 
949d cd f3 92			call display_word_at 
94a0			 
94a0			 
94a0				; display dsp 
94a0			 
94a0 11 2d 95			ld de, .regstatedsp 
94a3 3e 78			ld a, display_row_4 
94a5 cd d0 8a			call str_at_display 
94a8			 
94a8				 
94a8 2a e5 e9			ld hl,(cli_data_sp) 
94ab 3e 7c			ld a, display_row_4+4 
94ad cd f3 92			call display_word_at 
94b0			 
94b0				; display rsp 
94b0			 
94b0 11 32 95			ld de, .regstatersp 
94b3 3e 82			ld a, display_row_4+10 
94b5 cd d0 8a			call str_at_display 
94b8			 
94b8				 
94b8 2a e9 e9			ld hl,(cli_ret_sp) 
94bb 3e 86			ld a, display_row_4+14 
94bd cd f3 92			call display_word_at 
94c0			 
94c0 cd e0 8a			call update_display 
94c3			 
94c3			;	call delay1s 
94c3			;	call delay1s 
94c3			;	call delay1s 
94c3			 
94c3			 
94c3			;	call next_page_prompt 
94c3			 
94c3				; restore  
94c3			 
94c3 f1				pop af 
94c4 e1				pop hl 
94c5 c1				pop bc 
94c6 d1				pop de 
94c7 c9				ret 
94c8			 
94c8 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
94dc .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
94f1 .. 00		.ptrstate:	db "Ptr State",0 
94fb .. 00		.ptrcliptr:     db "cli_ptr",0 
9503 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
950d .. 00		.regstate:	db "Reg State (1/0)",0 
951d .. 00		.regstatehl:	db "HL:",0 
9521 .. 00		.regstatede:	db "DE:",0 
9525 .. 00		.regstatebc:	db "BC:",0 
9529 .. 00		.regstatea:	db "A :",0 
952d .. 00		.regstatedsp:	db "DSP:",0 
9532 .. 00		.regstatersp:	db "RSP:",0 
9537			 
9537			display_dump_at_hl: 
9537 e5				push hl 
9538 d5				push de 
9539 c5				push bc 
953a f5				push af 
953b			 
953b 22 db e5			ld (os_cur_ptr),hl	 
953e cd bd 8a			call clear_display 
9541 cd 75 98			call dumpcont 
9544			;	call delay1s 
9544			;	call next_page_prompt 
9544			 
9544			 
9544 f1				pop af 
9545 c1				pop bc 
9546 d1				pop de 
9547 e1				pop hl 
9548 c9				ret 
9549			 
9549			;if ENABLE_BASIC 
9549			;	include "nascombasic.asm" 
9549			;	basic: 
9549			;	include "forth/FORTH.ASM" 
9549			;endif 
9549			 
9549			; eof 
9549			 
9549			 
# End of file firmware_diags.asm
9549			  
9549			include "firmware_prompts.asm"  
9549			; Prompts  
9549			 
9549			; boot messages 
9549			 
9549 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
955e .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
956e			 
956e			 
956e			; config menus 
956e			 
956e			;prom_c3: db "Add Dictionary To File",0 
956e			 
956e			if STARTUP_V1 
956e .. 00		prom_c2: db "Select Autoload File",0 
9583 .. 00		prom_c2a: db "Disable Autoload File", 0 
9599			endif 
9599			 
9599			if STARTUP_V2 
9599			prom_c2: db "Enable Autoload Files",0 
9599			prom_c2a: db "Disable Autoload Files", 0 
9599			 
9599			crs_s1: db "*ls-word", 0 
9599			crs_s2: db "*ed-word", 0 
9599			crs_s3: db "*Demo-Games", 0 
9599			crs_s4: db "*Utils", 0 
9599			crs_s5: db "*SPI-Util", 0 
9599			crs_s6: db "*Key-Constants", 0 
9599			crs_sound: db "*Sound-Util", 0 
9599			crs_hw: db "*Hello-World",0 
9599			 
9599			 
9599			 
9599			endif 
9599			;prom_c2b: db "Select Storage Bank",0 
9599 .. 00		prom_c4: db "Settings",0 
95a2 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
95bd .. 00		prom_m4b:   db "Monitor",0 
95c5			;prom_c1: db "Hardware Diags",0 
95c5			 
95c5			 
95c5			if STARTUP_V2 
95c5			prom_c9: db "Create Startup Files",0 
95c5			endif 
95c5			 
95c5 .. 00		prom_notav:    db "Feature not available",0 
95db .. 00		prom_empty:    db "",0 
95dc			 
95dc			; eof 
95dc			 
# End of file firmware_prompts.asm
95dc			  
95dc			; eof  
95dc			  
# End of file firmware.asm
95dc			 
95dc			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
95dc			;if BASE_KEV  
95dc			;baseram: equ 08000h 
95dc			;endif 
95dc			 
95dc			;if BASE_SC114 
95dc			;baseram:     equ    endofcode 
95dc			;endif 
95dc			 
95dc			 
95dc			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
95dc			 
95dc			; start system 
95dc			 
95dc			coldstart: 
95dc				; set sp 
95dc				; di/ei 
95dc			 
95dc f3				di 
95dd 31 00 f0			ld sp, tos 
95e0 cd 25 e3			call init_nmi 
95e3			;	ei 
95e3			 
95e3				; init spinner 
95e3 3e 00			ld a,0 
95e5 32 bd eb			ld (display_active), a 
95e8			 
95e8				; disable breakpoint by default 
95e8			 
95e8				;ld a,'*' 
95e8			;	ld a,' ' 
95e8			;	ld (os_view_disable),a 
95e8			 
95e8				; set break point vector as new break point on or off 
95e8 cd 7a 93			call bp_off 
95eb			 
95eb			 
95eb				; default the parse vector to just a RET 
95eb 3e c9			ld a, $c9 
95ed 32 6c ee			ld (parse_vector), a 
95f0			 
95f0				; init hardware 
95f0			 
95f0				; init keyboard and screen hardware 
95f0			 
95f0 cd 1f 80			call hardware_init 
95f3			 
95f3			 
95f3 cd 00 8a			call delay1s 
95f6 3e 58			ld a, display_row_3+8 
95f8 11 03 80			ld de, buildtime 
95fb cd d0 8a			call str_at_display 
95fe cd e0 8a			call update_display 
9601			 
9601 cd 00 8a			call delay1s 
9604 cd 00 8a			call delay1s 
9607 cd 00 8a			call delay1s 
960a			 
960a				; detect if any keys are held down to enable breakpoints at start up 
960a			 
960a cd e1 e3			call cin  
960d fe 00			cp 0 
960f 28 03			jr z, .nokeys 
9611			 
9611				;call hardware_diags 
9611 cd 5e 92			call config 
9614			 
9614			;	ld de, .bpen 
9614			;	ld a, display_row_4 
9614			;	call str_at_display 
9614			;	call update_display 
9614			; 
9614			;	ld a,0 
9614			;	ld (os_view_disable),a 
9614			; 
9614			;.bpwait: 
9614			;	call cin 
9614			;	cp 0 
9614			;	jr z, .bpwait 
9614			;	jr .nokeys 
9614			; 
9614			; 
9614			;.bpen:  db "Break points enabled!",0 
9614			 
9614			 
9614			 
9614			 
9614			 
9614			 
9614			.nokeys: 
9614			 
9614			 
9614				 
9614			 
9614			;jp  testkey 
9614			 
9614			;call storage_get_block_0 
9614			; 
9614			;ld hl, 0 
9614			;ld de, store_page 
9614			;call storage_read_block 
9614			 
9614				 
9614			;ld hl, 10 
9614			;ld de, store_page 
9614			;call storage_read_block 
9614			 
9614			 
9614			 
9614			 
9614			 
9614			;stop:	nop 
9614			;	jp stop 
9614			 
9614			 
9614			 
9614			main: 
9614 cd bd 8a			call clear_display 
9617 cd e0 8a			call update_display 
961a			 
961a			 
961a			 
961a			;	call testlcd 
961a			 
961a			 
961a			 
961a cd b5 9d			call forth_init 
961d			 
961d			 
961d			warmstart: 
961d cd 8b 9d			call forth_warmstart 
9620			 
9620				; run startup word load 
9620			        ; TODO prevent this running at warmstart after crash  
9620			 
9620				if STARTUP_ENABLE 
9620			 
9620					if STARTUP_V1 
9620			 
9620						if STORAGE_SE 
9620							call forth_autoload 
9620						endif 
9620 cd 75 e2					call forth_startup 
9623					endif 
9623			 
9623					if STARTUP_V2 
9623			 
9623						if STORAGE_SE 
9623							call forth_autoload 
9623						else 
9623							call forth_startup 
9623						endif 
9623			 
9623			 
9623					endif 
9623			 
9623				endif 
9623			 
9623			warmstart_afterauto: 
9623			 
9623				; show free memory after boot 
9623 11 c2 96			ld de, freeram 
9626 3e 00			ld a, display_row_1 
9628 cd d0 8a			call str_at_display 
962b			 
962b				; get current heap start after loading any uwords 
962b			 
962b				;ld de, (os_last_new_uword) 
962b				;ex de, hl 
962b			 
962b			; Or use heap_size word???? 
962b				;ld hl, heap_end 
962b				;ld hl, heap_size 
962b				;ld de, topusermem 
962b				;ld de, heap_start 
962b ed 5b fa e3			ld de, (free_list )      
962f 21 93 e2				ld hl, heap_end 
9632 ed 52			sbc hl, de 
9634				;push hl 
9634				;ld a,h	         	 
9634				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9634				;call hexout 
9634			   	;pop hl 
9634			; 
9634			;	ld a,l 
9634			;	ld hl, os_word_scratch+2 
9634			;	call hexout 
9634			;	ld hl, os_word_scratch+4 
9634			;	ld a, 0 
9634			;	ld (hl),a 
9634 eb				ex de, hl 
9635 21 bd e5			ld hl, os_word_scratch 
9638 cd ff 8f			call uitoa_16 
963b			 
963b			 
963b 11 bd e5			ld de, os_word_scratch 
963e 3e 0d			ld a, display_row_1 + 13 
9640 cd d0 8a			call str_at_display 
9643 cd e0 8a			call update_display 
9646			 
9646			 
9646				;call demo 
9646			 
9646			 
9646				; init scratch input area for cli commands 
9646			 
9646 21 df e5			ld hl, os_cli_cmd 
9649 3e 00			ld a,0 
964b 77				ld (hl),a 
964c 23				inc hl 
964d 77				ld (hl),a 
964e			 
964e 3e 00			ld a,0 
9650 32 de e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
9653			 
9653 32 db e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
9656 32 dc e5			ld (os_cur_ptr+1),a	 
9659			 
9659 32 bd e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
965c 32 be e5			ld (os_word_scratch+1),a	 
965f				 
965f			 
965f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
965f 21 df e5			ld hl, os_cli_cmd 
9662			 
9662 3e 00			ld a, 0		 ; init cli input 
9664 77				ld (hl), a 
9665 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9667			cli: 
9667				; show cli prompt 
9667				;push af 
9667				;ld a, 0 
9667				;ld de, prompt 
9667				;call str_at_display 
9667			 
9667				;call update_display 
9667				;pop af 
9667				;inc a 
9667				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9667			 
9667			.lastrecall: 
9667			 
9667 0e 00			ld c, 0 
9669 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
966b 1e 28			ld e, 40 
966d			 
966d 21 df e5			ld hl, os_cli_cmd 
9670			 
9670				STACKFRAME OFF $fefe $9f9f 
9670				if DEBUG_STACK_IMB 
9670					if OFF 
9670						exx 
9670						ld de, $fefe 
9670						ld a, d 
9670						ld hl, curframe 
9670						call hexout 
9670						ld a, e 
9670						ld hl, curframe+2 
9670						call hexout 
9670						ld hl, $fefe 
9670						push hl 
9670						ld hl, $9f9f 
9670						push hl 
9670						exx 
9670					endif 
9670				endif 
9670			endm 
# End of macro STACKFRAME
9670			 
9670 cd 17 8d			call input_str 
9673			 
9673				STACKFRAMECHK OFF $fefe $9f9f 
9673				if DEBUG_STACK_IMB 
9673					if OFF 
9673						exx 
9673						ld hl, $9f9f 
9673						pop de   ; $9f9f 
9673						call cmp16 
9673						jr nz, .spnosame 
9673						ld hl, $fefe 
9673						pop de   ; $fefe 
9673						call cmp16 
9673						jr z, .spfrsame 
9673						.spnosame: call showsperror 
9673						.spfrsame: nop 
9673						exx 
9673					endif 
9673				endif 
9673			endm 
# End of macro STACKFRAMECHK
9673			 
9673			 
9673				; check to see if last line recall has been requested 
9673			 
9673			if EDIT_V2 
9673 fe 05			cp KEY_UP 
9675 20 0f			jr nz, .noexecline 
9677			 
9677 11 df e5			ld de, os_cli_cmd 
967a 21 de e6			ld hl, os_last_cmd 
967d 01 ff 00			ld bc, 255 
9680 ed b0			ldir 
9682 3e 00			ld a, 0 
9684 18 e1			jr .lastrecall 
9686			endif 
9686			 
9686			.noexecline: 
9686				; no so exec the line		 
9686			 
9686				; copy input to last command 
9686			 
9686 21 df e5			ld hl, os_cli_cmd 
9689 11 de e6			ld de, os_last_cmd 
968c 01 ff 00			ld bc, 255 
968f ed b0			ldir 
9691			 
9691				; wipe current buffer 
9691			 
9691			;	ld a, 0 
9691			;	ld hl, os_cli_cmd 
9691			;	ld de, os_cli_cmd+1 
9691			;	ld bc, 254 
9691			;	ldir 
9691				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9691			;	call strcpy 
9691			;	ld a, 0 
9691			;	ld (hl), a 
9691			;	inc hl 
9691			;	ld (hl), a 
9691			;	inc hl 
9691			;	ld (hl), a 
9691			 
9691				; switch frame buffer to program  
9691			 
9691 21 07 ed				ld hl, display_fb1 
9694 22 c3 eb				ld (display_fb_active), hl 
9697			 
9697			;	nop 
9697				STACKFRAME ON $fbfe $8f9f 
9697				if DEBUG_STACK_IMB 
9697					if ON 
9697						exx 
9697						ld de, $fbfe 
9697						ld a, d 
9697						ld hl, curframe 
9697						call hexout 
9697						ld a, e 
9697						ld hl, curframe+2 
9697						call hexout 
9697						ld hl, $fbfe 
9697						push hl 
9697						ld hl, $8f9f 
9697						push hl 
9697						exx 
9697					endif 
9697				endif 
9697			endm 
# End of macro STACKFRAME
9697				; first time into the parser so pass over the current scratch pad 
9697 21 df e5			ld hl,os_cli_cmd 
969a				; tokenise the entered statement(s) in HL 
969a cd 2f 9e			call forthparse 
969d			        ; exec forth statements in top of return stack 
969d cd 6b 9e			call forthexec 
96a0				;call forthexec_cleanup 
96a0			;	call parsenext 
96a0			 
96a0				STACKFRAMECHK ON $fbfe $8f9f 
96a0				if DEBUG_STACK_IMB 
96a0					if ON 
96a0						exx 
96a0						ld hl, $8f9f 
96a0						pop de   ; $8f9f 
96a0						call cmp16 
96a0						jr nz, .spnosame 
96a0						ld hl, $fbfe 
96a0						pop de   ; $fbfe 
96a0						call cmp16 
96a0						jr z, .spfrsame 
96a0						.spnosame: call showsperror 
96a0						.spfrsame: nop 
96a0						exx 
96a0					endif 
96a0				endif 
96a0			endm 
# End of macro STACKFRAMECHK
96a0				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
96a0			 
96a0 3e 78			ld a, display_row_4 
96a2 11 d3 96			ld de, endprog 
96a5			 
96a5 cd e0 8a			call update_display		 
96a8			 
96a8 cd 6d 99			call next_page_prompt 
96ab			 
96ab				; switch frame buffer to cli 
96ab			 
96ab 21 a8 ed				ld hl, display_fb0 
96ae 22 c3 eb				ld (display_fb_active), hl 
96b1			 
96b1			 
96b1 cd bd 8a		        call clear_display 
96b4 cd e0 8a			call update_display		 
96b7			 
96b7 21 df e5			ld hl, os_cli_cmd 
96ba			 
96ba 3e 00			ld a, 0		 ; init cli input 
96bc 77				ld (hl), a 
96bd			 
96bd				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
96bd			 
96bd				; now on last line 
96bd			 
96bd				; TODO scroll screen up 
96bd			 
96bd				; TODO instead just clear screen and place at top of screen 
96bd			 
96bd			;	ld a, 0 
96bd			;	ld (f_cursor_ptr),a 
96bd			 
96bd				;call clear_display 
96bd				;call update_display 
96bd			 
96bd				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96bd 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96bf c3 67 96			jp cli 
96c2			 
96c2 .. 00		freeram: db "Free bytes: ",0 
96cf ..			asc: db "1A2F" 
96d3 .. 00		endprog: db "End prog...",0 
96df			 
96df			testenter2:   
96df 21 ea e2			ld hl,scratch+50 
96e2 22 db e5			ld (os_cur_ptr),hl 
96e5 c3 67 96			jp cli 
96e8			 
96e8			testenter:  
96e8			 
96e8 21 cf 96			ld hl,asc 
96eb			;	ld a,(hl) 
96eb			;	call nibble2val 
96eb cd 49 8f			call get_byte 
96ee			 
96ee			 
96ee			;	ld a,(hl) 
96ee			;	call atohex 
96ee			 
96ee			;	call fourehexhl 
96ee 32 ea e2			ld (scratch+50),a 
96f1			 
96f1			 
96f1			 
96f1 21 d1 96			ld hl,asc+2 
96f4			;	ld a, (hl) 
96f4			;	call nibble2val 
96f4 cd 49 8f			call get_byte 
96f7			 
96f7			;	call fourehexhl 
96f7 32 ec e2			ld (scratch+52),a 
96fa				 
96fa 21 ea e2			ld hl,scratch+50 
96fd 22 db e5			ld (os_cur_ptr),hl 
9700 c3 67 96			jp cli 
9703			 
9703			enter:	 
9703 3a bc e2			ld a,(scratch+4) 
9706 fe 00			cp 0 
9708 28 0c			jr z, .entercont 
970a				; no, not a null term line so has an address to work out.... 
970a			 
970a 21 ba e2			ld hl,scratch+2 
970d cd a9 8f			call get_word_hl 
9710			 
9710 22 db e5			ld (os_cur_ptr),hl	 
9713 c3 67 96			jp cli 
9716			 
9716			 
9716			.entercont:  
9716			 
9716 21 ba e2			ld hl, scratch+2 
9719 cd 49 8f			call get_byte 
971c			 
971c 2a db e5		   	ld hl,(os_cur_ptr) 
971f 77					ld (hl),a 
9720 23					inc hl 
9721 22 db e5				ld (os_cur_ptr),hl 
9724				 
9724			; get byte  
9724			 
9724			 
9724 c3 67 96			jp cli 
9727			 
9727			 
9727			; basic monitor support 
9727			 
9727			monitor: 
9727				;  
9727 cd bd 8a			call clear_display 
972a 3e 00			ld a, 0 
972c 11 80 97			ld de, .monprompt 
972f cd d0 8a			call str_at_display 
9732 cd e0 8a			call update_display 
9735			 
9735				; get a monitor command 
9735			 
9735 0e 00			ld c, 0     ; entry at top left 
9737 16 64			ld d, 100   ; max buffer size 
9739 1e 0f			ld e, 15    ; input scroll area 
973b 3e 00			ld a, 0     ; init string 
973d 21 b6 e4			ld hl, os_input 
9740 77				ld (hl), a 
9741 23				inc hl 
9742 77				ld (hl), a 
9743 21 b6 e4			ld hl, os_input 
9746 3e 01			ld a, 1     ; init string 
9748 cd 17 8d			call input_str 
974b			 
974b cd bd 8a		        call clear_display 
974e cd e0 8a			call update_display		 
9751			 
9751 3a b6 e4			ld a, (os_input) 
9754 cd 47 90			call toUpper 
9757 fe 48		        cp 'H' 
9759 ca f4 97		        jp z, .monhelp 
975c fe 44			cp 'D'		; dump 
975e ca 27 98			jp z, .mondump	 
9761 fe 43			cp 'C'		; dump 
9763 ca 41 98			jp z, .moncdump	 
9766 fe 4d			cp 'M'		; dump 
9768 ca 82 97			jp z, .moneditstart 
976b fe 55			cp 'U'		; dump 
976d ca 8e 97			jp z, .monedit	 
9770 fe 47			cp 'G'		; dump 
9772 ca 1d 98			jp z, .monjump 
9775 fe 42			cp 'B'		; forth breakpoint 
9777 cc 80 93			call z, break_point_state 
977a fe 51			cp 'Q'		; dump 
977c c8				ret z	 
977d			 
977d			 
977d				; TODO "S" to access symbol by name and not need the address 
977d				; TODO "F" to find a string in memory 
977d			 
977d c3 27 97			jp monitor 
9780			 
9780 .. 00		.monprompt: db ">", 0 
9782			 
9782			.moneditstart: 
9782				; get starting address 
9782			 
9782 21 b8 e4			ld hl,os_input+2 
9785 cd a9 8f			call get_word_hl 
9788			 
9788 22 db e5			ld (os_cur_ptr),hl	 
978b			 
978b c3 27 97			jp monitor 
978e			 
978e			.monedit: 
978e				; get byte to load 
978e			 
978e 21 b8 e4			ld hl,os_input+2 
9791 cd 49 8f			call get_byte 
9794			 
9794				; get address to update 
9794 2a db e5			ld hl, (os_cur_ptr) 
9797			 
9797				; update byte 
9797			 
9797 77				ld (hl), a 
9798			 
9798				; move to next address and save it 
9798			 
9798 23				inc hl 
9799 22 db e5			ld (os_cur_ptr),hl	 
979c			 
979c c3 27 97			jp monitor 
979f			 
979f			 
979f .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
97b3 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
97cf .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
97ed .. 00		.monhelptext4:  db "Q-Quit",0 
97f4			        
97f4			.monhelp: 
97f4 3e 00			ld a, display_row_1 
97f6 11 9f 97		        ld de, .monhelptext1 
97f9			 
97f9 cd d0 8a			call str_at_display 
97fc 3e 28			ld a, display_row_2 
97fe 11 b3 97		        ld de, .monhelptext2 
9801					 
9801 cd d0 8a			call str_at_display 
9804 3e 50			ld a, display_row_3 
9806 11 cf 97		        ld de, .monhelptext3 
9809					 
9809 cd d0 8a			call str_at_display 
980c 3e 78			ld a, display_row_4 
980e 11 ed 97		        ld de, .monhelptext4 
9811 cd d0 8a			call str_at_display 
9814			 
9814 cd e0 8a			call update_display		 
9817			 
9817 cd 6d 99			call next_page_prompt 
981a c3 27 97			jp monitor 
981d			 
981d			.monjump:    
981d 21 b8 e4			ld hl,os_input+2 
9820 cd a9 8f			call get_word_hl 
9823			 
9823 e9				jp (hl) 
9824 c3 27 97			jp monitor 
9827			 
9827			.mondump:    
9827 21 b8 e4			ld hl,os_input+2 
982a cd a9 8f			call get_word_hl 
982d			 
982d 22 db e5			ld (os_cur_ptr),hl	 
9830 cd 75 98			call dumpcont 
9833 3e 78			ld a, display_row_4 
9835 11 d3 96			ld de, endprog 
9838			 
9838 cd e0 8a			call update_display		 
983b			 
983b cd 6d 99			call next_page_prompt 
983e c3 27 97			jp monitor 
9841			.moncdump: 
9841 cd 75 98			call dumpcont 
9844 3e 78			ld a, display_row_4 
9846 11 d3 96			ld de, endprog 
9849			 
9849 cd e0 8a			call update_display		 
984c			 
984c cd 6d 99			call next_page_prompt 
984f c3 27 97			jp monitor 
9852			 
9852			 
9852			; TODO symbol access  
9852			 
9852			.symbols:     ;; A list of symbols that can be called up  
9852 a8 ed			dw display_fb0 
9854 .. 00			db "fb0",0  
9858 71 ea		     	dw store_page 
985a .. 00			db "store_page",0 
9865			 
9865			 
9865			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9865			 
9865 3a b9 e2			ld a,(scratch+1) 
9868 fe 00			cp 0 
986a 28 09			jr z, dumpcont 
986c			 
986c				; no, not a null term line so has an address to work out.... 
986c			 
986c 21 ba e2			ld hl,scratch+2 
986f cd a9 8f			call get_word_hl 
9872			 
9872 22 db e5			ld (os_cur_ptr),hl	 
9875			 
9875			 
9875			 
9875			dumpcont: 
9875			 
9875				; dump bytes at ptr 
9875			 
9875			 
9875 3e 00			ld a, display_row_1 
9877 2a c3 eb			ld hl, (display_fb_active) 
987a cd ea 8c			call addatohl 
987d cd a5 98			call .dumpbyterow 
9880			 
9880 3e 28			ld a, display_row_2 
9882 2a c3 eb			ld hl, (display_fb_active) 
9885 cd ea 8c			call addatohl 
9888 cd a5 98			call .dumpbyterow 
988b			 
988b			 
988b 3e 50			ld a, display_row_3 
988d 2a c3 eb			ld hl, (display_fb_active) 
9890 cd ea 8c			call addatohl 
9893 cd a5 98			call .dumpbyterow 
9896			 
9896 3e 78			ld a, display_row_4 
9898 2a c3 eb			ld hl, (display_fb_active) 
989b cd ea 8c			call addatohl 
989e cd a5 98			call .dumpbyterow 
98a1			 
98a1 cd e0 8a			call update_display 
98a4			;		jp cli 
98a4 c9				ret 
98a5			 
98a5			.dumpbyterow: 
98a5			 
98a5				;push af 
98a5			 
98a5 e5				push hl 
98a6			 
98a6				; calc where to poke the ascii 
98a6			if display_cols == 20 
98a6				ld a, 16 
98a6			else 
98a6 3e 1f			ld a, 31 
98a8			endif 
98a8			 
98a8 cd ea 8c			call addatohl 
98ab 22 bd e5			ld (os_word_scratch),hl  		; save pos for later 
98ae			 
98ae			 
98ae			; display decoding address 
98ae 2a db e5		   	ld hl,(os_cur_ptr) 
98b1			 
98b1 7c				ld a,h 
98b2 e1				pop hl 
98b3 e5				push hl 
98b4			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
98b4 cd f3 8e			call hexout 
98b7 2a db e5		   	ld hl,(os_cur_ptr) 
98ba			 
98ba 7d				ld a,l 
98bb e1				pop hl 
98bc 23				inc hl 
98bd 23				inc hl 
98be e5				push hl 
98bf			;	ld hl, os_word_scratch+2 
98bf cd f3 8e			call hexout 
98c2 e1				pop hl 
98c3 23				inc hl 
98c4 23				inc hl 
98c5				;ld hl, os_word_scratch+4 
98c5 3e 3a			ld a, ':' 
98c7 77				ld (hl),a 
98c8 23				inc hl 
98c9				;ld a, 0 
98c9				;ld (hl),a 
98c9				;ld de, os_word_scratch 
98c9				;pop af 
98c9				;push af 
98c9			;		ld a, display_row_2 
98c9			;		call str_at_display 
98c9			;		call update_display 
98c9			 
98c9			 
98c9			;pop af 
98c9			;	add 5 
98c9			 
98c9			if display_cols == 20 
98c9				ld b, 4 
98c9			else 
98c9 06 08			ld b, 8 
98cb			endif	 
98cb			 
98cb			.dumpbyte: 
98cb c5				push bc 
98cc e5				push hl 
98cd			 
98cd			 
98cd 2a db e5		   	ld hl,(os_cur_ptr) 
98d0 7e					ld a,(hl) 
98d1			 
98d1					; poke the ascii to display 
98d1 2a bd e5				ld hl,(os_word_scratch) 
98d4 77					ld (hl),a 
98d5 23					inc hl 
98d6 22 bd e5				ld (os_word_scratch),hl 
98d9			 
98d9					 
98d9			 
98d9			 
98d9 e1					pop hl 
98da e5					push hl 
98db			 
98db cd f3 8e				call hexout 
98de			 
98de					 
98de 2a db e5		   	ld hl,(os_cur_ptr) 
98e1 23				inc hl 
98e2 22 db e5		   	ld (os_cur_ptr),hl 
98e5			 
98e5 e1					pop hl 
98e6 23					inc hl 
98e7 23					inc hl 
98e8 23					inc hl 
98e9			 
98e9			 
98e9			 
98e9					;ld a,0 
98e9					;ld (os_word_scratch+2),a 
98e9					;pop af 
98e9					;push af 
98e9			 
98e9					;ld de, os_word_scratch 
98e9					;call str_at_display 
98e9			;		call update_display 
98e9			;		pop af 
98e9 c1					pop bc 
98ea c6 03				add 3 
98ec 10 dd			djnz .dumpbyte 
98ee			 
98ee				 
98ee			 
98ee c9				ret 
98ef			 
98ef			jump:	 
98ef			 
98ef 21 ba e2			ld hl,scratch+2 
98f2 cd a9 8f			call get_word_hl 
98f5				;ld hl,(scratch+2) 
98f5				;call fourehexhl 
98f5			 
98f5 22 db e5			ld (os_cur_ptr),hl	 
98f8			 
98f8 e9				jp (hl) 
98f9			 
98f9			 
98f9			 
98f9			; TODO implement a basic monitor mode to start with 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			; testing and demo code during development 
98f9			 
98f9			 
98f9 .. 00		str1: db "Enter some text...",0 
990c .. 00		clear: db "                    ",0 
9921			 
9921			demo: 
9921			 
9921			 
9921			 
9921			;	call update_display 
9921			 
9921				; init scratch input area for testing 
9921 21 b8 e2			ld hl, scratch	 
9924 3e 00			ld a,0 
9926 77				ld (hl),a 
9927			 
9927			 
9927 3e 28		            LD   A, display_row_2 
9929			;            CALL fLCD_Pos       ;Position cursor to location in A 
9929 11 f9 98		            LD   DE, str1 
992c cd d0 8a			call str_at_display 
992f			 
992f			;            CALL fLCD_Str       ;Display string pointed to by DE 
992f			cloop:	 
992f 3e 50		            LD   A, display_row_3 
9931			;            CALL fLCD_Pos       ;Position cursor to location in A 
9931 11 0c 99		            LD   DE, clear 
9934			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9934 cd d0 8a				call str_at_display 
9937 3e 78			ld a, display_row_4 
9939 11 69 99			ld de, prompt 
993c			 
993c cd d0 8a				call str_at_display 
993f cd e0 8a			call update_display 
9942			 
9942 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9944 16 0a			ld d, 10 
9946 21 b8 e2			ld hl, scratch	 
9949 cd 17 8d			call input_str 
994c			 
994c			;	call clear_display 
994c			;'	call update_display 
994c			 
994c 3e 00		            LD   A, display_row_1 
994e			;            CALL fLCD_Pos       ;Position cursor to location in A 
994e 11 0c 99		            LD   DE, clear 
9951 cd d0 8a				call str_at_display 
9954			;            CALL fLCD_Str       ;Display string pointed to by DE 
9954 3e 00		            LD   A, display_row_1 
9956			;            CALL fLCD_Pos       ;Position cursor to location in A 
9956 11 b8 e2		            LD   DE, scratch 
9959			;            CALL fLCD_Str       ;Display string pointed to by DE 
9959 cd d0 8a				call str_at_display 
995c cd e0 8a			call update_display 
995f			 
995f 3e 00				ld a,0 
9961 21 b8 e2			ld hl, scratch 
9964 77				ld (hl),a 
9965			 
9965 00				nop 
9966 c3 2f 99			jp cloop 
9969			 
9969			 
9969			 
9969			; OS Prompt 
9969			 
9969 .. 00		prompt: db ">",0 
996b .. 00		endprg: db "?",0 
996d			 
996d			 
996d			; handy next page prompt 
996d			next_page_prompt: 
996d e5				push hl 
996e d5				push de 
996f f5				push af 
9970 c5				push bc 
9971			 
9971 3e 9f			ld a,display_row_4 + display_cols - 1 
9973 11 6b 99		        ld de, endprg 
9976 cd d0 8a			call str_at_display 
9979 cd e0 8a			call update_display 
997c cd db e3			call cin_wait 
997f c1				pop bc 
9980 f1				pop af 
9981 d1				pop de 
9982 e1				pop hl 
9983			 
9983			 
9983 c9				ret 
9984			 
9984			 
9984			; forth parser 
9984			 
9984			; My forth kernel 
9984			include "forth_kernel.asm" 
9984			; 
9984			; kernel to the forth OS 
9984			 
9984			DS_TYPE_STR: equ 1     ; string type 
9984			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9984			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9984			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9984			 
9984			FORTH_PARSEV1: equ 0 
9984			FORTH_PARSEV2: equ 0 
9984			FORTH_PARSEV3: equ 0 
9984			FORTH_PARSEV4: equ 0 
9984			FORTH_PARSEV5: equ 0 
9984			FORTH_PARSEV6: equ 1 
9984			 
9984			;if FORTH_PARSEV5 
9984			;	FORTH_END_BUFFER: equ 0 
9984			;else 
9984			FORTH_END_BUFFER: equ 127 
9984			;endif 
9984			 
9984			FORTH_TRUE: equ 1 
9984			FORTH_FALSE: equ 0 
9984			 
9984			if FORTH_PARSEV4 
9984			include "forth_stackops.asm" 
9984			endif 
9984			 
9984			if FORTH_PARSEV5 
9984			include "forth_stackopsv5.asm" 
9984			endif 
9984			 
9984			if FORTH_PARSEV6 
9984			include "forth_stackopsv5.asm" 
9984			 
9984			; Stack operations for v5 parser on wards 
9984			; * DATA stack 
9984			; * LOOP stack 
9984			; * RETURN stack 
9984			 
9984			 
9984			 
9984			FORTH_CHK_DSP_UNDER: macro 
9984				push hl 
9984				push de 
9984				ld hl,(cli_data_sp) 
9984				ld de, cli_data_stack 
9984				call cmp16 
9984				jp c, fault_dsp_under 
9984				pop de 
9984				pop hl 
9984				endm 
9984			 
9984			 
9984			FORTH_CHK_RSP_UNDER: macro 
9984				push hl 
9984				push de 
9984				ld hl,(cli_ret_sp) 
9984				ld de, cli_ret_stack 
9984				call cmp16 
9984				jp c, fault_rsp_under 
9984				pop de 
9984				pop hl 
9984				endm 
9984			 
9984			FORTH_CHK_LOOP_UNDER: macro 
9984				push hl 
9984				push de 
9984				ld hl,(cli_loop_sp) 
9984				ld de, cli_loop_stack 
9984				call cmp16 
9984				jp c, fault_loop_under 
9984				pop de 
9984				pop hl 
9984				endm 
9984			 
9984			FORTH_ERR_TOS_NOTSTR: macro 
9984				; TOSO might need more for checks when used 
9984				push af 
9984				ld a,(hl) 
9984				cp DS_TYPE_STR 
9984				jp nz, type_faultn   
9984				pop af 
9984				endm 
9984			 
9984			FORTH_ERR_TOS_NOTNUM: macro 
9984				push af 
9984				ld a,(hl) 
9984				cp DS_TYPE_INUM 
9984				jp nz, type_faultn   
9984				pop af 
9984				endm 
9984			 
9984			 
9984			; increase data stack pointer and save hl to it 
9984				 
9984			FORTH_DSP_NEXT: macro 
9984				call macro_forth_dsp_next 
9984				endm 
9984			 
9984			 
9984			macro_forth_dsp_next: 
9984				if DEBUG_FORTH_STACK_GUARD 
9984 cd 4d e0				call check_stacks 
9987				endif 
9987 e5				push hl 
9988 d5				push de 
9989 eb				ex de,hl 
998a 2a e5 e9			ld hl,(cli_data_sp) 
998d 23				inc hl 
998e 23				inc hl 
998f			 
998f			; PARSEV5 
998f 23				inc hl 
9990 22 e5 e9			ld (cli_data_sp),hl 
9993 73				ld (hl), e 
9994 23				inc hl 
9995 72				ld (hl), d 
9996 d1				pop de 
9997 e1				pop hl 
9998				if DEBUG_FORTH_STACK_GUARD 
9998 cd 4d e0				call check_stacks 
999b				endif 
999b c9				ret 
999c			 
999c			 
999c			; increase ret stack pointer and save hl to it 
999c				 
999c			FORTH_RSP_NEXT: macro 
999c				call macro_forth_rsp_next 
999c				endm 
999c			 
999c			macro_forth_rsp_next: 
999c				if DEBUG_FORTH_STACK_GUARD 
999c cd 4d e0				call check_stacks 
999f				endif 
999f e5				push hl 
99a0 d5				push de 
99a1 eb				ex de,hl 
99a2 2a e9 e9			ld hl,(cli_ret_sp) 
99a5 23				inc hl 
99a6 23				inc hl 
99a7 22 e9 e9			ld (cli_ret_sp),hl 
99aa 73				ld (hl), e 
99ab 23				inc hl 
99ac 72				ld (hl), d 
99ad d1				pop de 
99ae e1				pop hl 
99af				if DEBUG_FORTH_STACK_GUARD 
99af cd 4d e0				call check_stacks 
99b2				endif 
99b2 c9				ret 
99b3			 
99b3			; get current ret stack pointer and save to hl  
99b3				 
99b3			FORTH_RSP_TOS: macro 
99b3				call macro_forth_rsp_tos 
99b3				endm 
99b3			 
99b3			macro_forth_rsp_tos: 
99b3				;push de 
99b3 2a e9 e9			ld hl,(cli_ret_sp) 
99b6 cd ee 99			call loadhlptrtohl 
99b9				;ld e, (hl) 
99b9				;inc hl 
99b9				;ld d, (hl) 
99b9				;ex de, hl 
99b9					if DEBUG_FORTH_WORDS 
99b9			;			DMARK "RST" 
99b9						CALLMONITOR 
99b9 cd 6f ee			call debug_vector  
99bc				endm  
# End of macro CALLMONITOR
99bc					endif 
99bc				;pop de 
99bc c9				ret 
99bd			 
99bd			; pop ret stack pointer 
99bd				 
99bd			FORTH_RSP_POP: macro 
99bd				call macro_forth_rsp_pop 
99bd				endm 
99bd			 
99bd			 
99bd			macro_forth_rsp_pop: 
99bd				if DEBUG_FORTH_STACK_GUARD 
99bd			;		DMARK "RPP" 
99bd cd 4d e0				call check_stacks 
99c0					FORTH_CHK_RSP_UNDER 
99c0 e5				push hl 
99c1 d5				push de 
99c2 2a e9 e9			ld hl,(cli_ret_sp) 
99c5 11 a3 e9			ld de, cli_ret_stack 
99c8 cd 08 8d			call cmp16 
99cb da 64 e1			jp c, fault_rsp_under 
99ce d1				pop de 
99cf e1				pop hl 
99d0				endm 
# End of macro FORTH_CHK_RSP_UNDER
99d0				endif 
99d0 e5				push hl 
99d1 2a e9 e9			ld hl,(cli_ret_sp) 
99d4			 
99d4			 
99d4				if FORTH_ENABLE_FREE 
99d4			 
99d4					; get pointer 
99d4			 
99d4					push de 
99d4					push hl 
99d4			 
99d4					ld e, (hl) 
99d4					inc hl 
99d4					ld d, (hl) 
99d4			 
99d4					ex de, hl 
99d4					call free 
99d4			 
99d4					pop hl 
99d4					pop de 
99d4			 
99d4			 
99d4				endif 
99d4			 
99d4			 
99d4 2b				dec hl 
99d5 2b				dec hl 
99d6 22 e9 e9			ld (cli_ret_sp), hl 
99d9				; do stack underflow checks 
99d9 e1				pop hl 
99da				if DEBUG_FORTH_STACK_GUARD 
99da cd 4d e0				call check_stacks 
99dd					FORTH_CHK_RSP_UNDER 
99dd e5				push hl 
99de d5				push de 
99df 2a e9 e9			ld hl,(cli_ret_sp) 
99e2 11 a3 e9			ld de, cli_ret_stack 
99e5 cd 08 8d			call cmp16 
99e8 da 64 e1			jp c, fault_rsp_under 
99eb d1				pop de 
99ec e1				pop hl 
99ed				endm 
# End of macro FORTH_CHK_RSP_UNDER
99ed				endif 
99ed c9				ret 
99ee			 
99ee			 
99ee			 
99ee			; routine to load word pointed to by hl into hl 
99ee			 
99ee			loadhlptrtohl: 
99ee			 
99ee d5				push de 
99ef 5e				ld e, (hl) 
99f0 23				inc hl 
99f1 56				ld d, (hl) 
99f2 eb				ex de, hl 
99f3 d1				pop de 
99f4			 
99f4 c9				ret 
99f5			 
99f5			 
99f5			 
99f5			 
99f5			 
99f5			; push a number held in HL onto the data stack 
99f5			; entry point for pushing a value when already in hl used in function above 
99f5			 
99f5			forth_push_numhl: 
99f5			 
99f5 e5				push hl    ; save value to push 
99f6			 
99f6			if DEBUG_FORTH_PUSH 
99f6				; see if disabled 
99f6			 
99f6			 
99f6 f5				push af 
99f7 3a 6f ee			ld a,(debug_vector) 
99fa fe c9			cp $c9   ; ret 
99fc			;	ld a, (os_view_disable) 
99fc			;	cp '*' 
99fc 28 34			jr z, .pskip2 
99fe e5				push hl 
99ff e5			push hl 
9a00 cd bd 8a			call clear_display 
9a03 e1			pop hl 
9a04 7c				ld a,h 
9a05 21 bd e5			ld hl, os_word_scratch 
9a08 cd f3 8e			call hexout 
9a0b e1				pop hl 
9a0c 7d				ld a,l 
9a0d 21 bf e5			ld hl, os_word_scratch+2 
9a10 cd f3 8e			call hexout 
9a13			 
9a13 21 c1 e5			ld hl, os_word_scratch+4 
9a16 3e 00			ld a,0 
9a18 77				ld (hl),a 
9a19 11 bd e5			ld de,os_word_scratch 
9a1c 3e 28				ld a, display_row_2 
9a1e cd d0 8a				call str_at_display 
9a21 11 46 d2			ld de, .push_num 
9a24 3e 00			ld a, display_row_1 
9a26			 
9a26 cd d0 8a				call str_at_display 
9a29			 
9a29			 
9a29 cd e0 8a			call update_display 
9a2c cd 00 8a			call delay1s 
9a2f cd 00 8a			call delay1s 
9a32			.pskip2:  
9a32			 
9a32 f1				pop af 
9a33			endif	 
9a33			 
9a33			 
9a33				FORTH_DSP_NEXT 
9a33 cd 84 99			call macro_forth_dsp_next 
9a36				endm 
# End of macro FORTH_DSP_NEXT
9a36			 
9a36 2a e5 e9			ld hl, (cli_data_sp) 
9a39			 
9a39				; save item type 
9a39 3e 02			ld a,  DS_TYPE_INUM 
9a3b 77				ld (hl), a 
9a3c 23				inc hl 
9a3d			 
9a3d				; get word off stack 
9a3d d1				pop de 
9a3e 7b				ld a,e 
9a3f 77				ld (hl), a 
9a40 23				inc hl 
9a41 7a				ld a,d 
9a42 77				ld (hl), a 
9a43			 
9a43			if DEBUG_FORTH_PUSH 
9a43 2b				dec hl 
9a44 2b				dec hl 
9a45 2b				dec hl 
9a46						DMARK "PH5" 
9a46 f5				push af  
9a47 3a 5b 9a			ld a, (.dmark)  
9a4a 32 62 ee			ld (debug_mark),a  
9a4d 3a 5c 9a			ld a, (.dmark+1)  
9a50 32 63 ee			ld (debug_mark+1),a  
9a53 3a 5d 9a			ld a, (.dmark+2)  
9a56 32 64 ee			ld (debug_mark+2),a  
9a59 18 03			jr .pastdmark  
9a5b ..			.dmark: db "PH5"  
9a5e f1			.pastdmark: pop af  
9a5f			endm  
# End of macro DMARK
9a5f				CALLMONITOR 
9a5f cd 6f ee			call debug_vector  
9a62				endm  
# End of macro CALLMONITOR
9a62			endif	 
9a62			 
9a62 c9				ret 
9a63			 
9a63			 
9a63			; Push a string to stack pointed to by hl 
9a63			 
9a63			forth_push_str: 
9a63			 
9a63			if DEBUG_FORTH_PUSH 
9a63						DMARK "PSQ" 
9a63 f5				push af  
9a64 3a 78 9a			ld a, (.dmark)  
9a67 32 62 ee			ld (debug_mark),a  
9a6a 3a 79 9a			ld a, (.dmark+1)  
9a6d 32 63 ee			ld (debug_mark+1),a  
9a70 3a 7a 9a			ld a, (.dmark+2)  
9a73 32 64 ee			ld (debug_mark+2),a  
9a76 18 03			jr .pastdmark  
9a78 ..			.dmark: db "PSQ"  
9a7b f1			.pastdmark: pop af  
9a7c			endm  
# End of macro DMARK
9a7c				CALLMONITOR 
9a7c cd 6f ee			call debug_vector  
9a7f				endm  
# End of macro CALLMONITOR
9a7f			endif	 
9a7f			 
9a7f			 
9a7f			    
9a7f e5				push hl 
9a80 e5				push hl 
9a81			 
9a81			;	ld a, 0   ; find end of string 
9a81 cd 50 90			call strlenz 
9a84			if DEBUG_FORTH_PUSH 
9a84						DMARK "PQ2" 
9a84 f5				push af  
9a85 3a 99 9a			ld a, (.dmark)  
9a88 32 62 ee			ld (debug_mark),a  
9a8b 3a 9a 9a			ld a, (.dmark+1)  
9a8e 32 63 ee			ld (debug_mark+1),a  
9a91 3a 9b 9a			ld a, (.dmark+2)  
9a94 32 64 ee			ld (debug_mark+2),a  
9a97 18 03			jr .pastdmark  
9a99 ..			.dmark: db "PQ2"  
9a9c f1			.pastdmark: pop af  
9a9d			endm  
# End of macro DMARK
9a9d				CALLMONITOR 
9a9d cd 6f ee			call debug_vector  
9aa0				endm  
# End of macro CALLMONITOR
9aa0			endif	 
9aa0 eb				ex de, hl 
9aa1 e1				pop hl   ; get ptr to start of string 
9aa2			if DEBUG_FORTH_PUSH 
9aa2						DMARK "PQ3" 
9aa2 f5				push af  
9aa3 3a b7 9a			ld a, (.dmark)  
9aa6 32 62 ee			ld (debug_mark),a  
9aa9 3a b8 9a			ld a, (.dmark+1)  
9aac 32 63 ee			ld (debug_mark+1),a  
9aaf 3a b9 9a			ld a, (.dmark+2)  
9ab2 32 64 ee			ld (debug_mark+2),a  
9ab5 18 03			jr .pastdmark  
9ab7 ..			.dmark: db "PQ3"  
9aba f1			.pastdmark: pop af  
9abb			endm  
# End of macro DMARK
9abb				CALLMONITOR 
9abb cd 6f ee			call debug_vector  
9abe				endm  
# End of macro CALLMONITOR
9abe			endif	 
9abe 19				add hl,de 
9abf			if DEBUG_FORTH_PUSH 
9abf						DMARK "PQE" 
9abf f5				push af  
9ac0 3a d4 9a			ld a, (.dmark)  
9ac3 32 62 ee			ld (debug_mark),a  
9ac6 3a d5 9a			ld a, (.dmark+1)  
9ac9 32 63 ee			ld (debug_mark+1),a  
9acc 3a d6 9a			ld a, (.dmark+2)  
9acf 32 64 ee			ld (debug_mark+2),a  
9ad2 18 03			jr .pastdmark  
9ad4 ..			.dmark: db "PQE"  
9ad7 f1			.pastdmark: pop af  
9ad8			endm  
# End of macro DMARK
9ad8				CALLMONITOR 
9ad8 cd 6f ee			call debug_vector  
9adb				endm  
# End of macro CALLMONITOR
9adb			endif	 
9adb			 
9adb 2b				dec hl    ; see if there is an optional trailing double quote 
9adc 7e				ld a,(hl) 
9add fe 22			cp '"' 
9adf 20 03			jr nz, .strnoq 
9ae1 3e 00			ld a, 0      ; get rid of double quote 
9ae3 77				ld (hl), a 
9ae4 23			.strnoq: inc hl 
9ae5			 
9ae5 3e 00			ld a, 0 
9ae7 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9ae8			 
9ae8 13				inc de ; add one for the type string 
9ae9 13				inc de ; add one for null term??? 
9aea			 
9aea				; tos is get string pointer again 
9aea				; de contains space to allocate 
9aea				 
9aea d5				push de 
9aeb			 
9aeb eb				ex de, hl 
9aec			 
9aec				;push af 
9aec			 
9aec			if DEBUG_FORTH_PUSH 
9aec						DMARK "PHm" 
9aec f5				push af  
9aed 3a 01 9b			ld a, (.dmark)  
9af0 32 62 ee			ld (debug_mark),a  
9af3 3a 02 9b			ld a, (.dmark+1)  
9af6 32 63 ee			ld (debug_mark+1),a  
9af9 3a 03 9b			ld a, (.dmark+2)  
9afc 32 64 ee			ld (debug_mark+2),a  
9aff 18 03			jr .pastdmark  
9b01 ..			.dmark: db "PHm"  
9b04 f1			.pastdmark: pop af  
9b05			endm  
# End of macro DMARK
9b05				CALLMONITOR 
9b05 cd 6f ee			call debug_vector  
9b08				endm  
# End of macro CALLMONITOR
9b08			endif	 
9b08 cd c5 90			call malloc	; on ret hl now contains allocated memory 
9b0b				if DEBUG_FORTH_MALLOC_GUARD 
9b0b cc 9e d2				call z,malloc_error 
9b0e				endif 
9b0e			 
9b0e				 
9b0e c1				pop bc    ; get length 
9b0f d1				pop de   ;  get string start    
9b10			 
9b10				; hl has destination from malloc 
9b10			 
9b10 eb				ex de, hl    ; prep for ldir 
9b11			 
9b11 d5				push de   ; save malloc area for DSP later 
9b12				;push hl   ; save malloc area for DSP later 
9b12			 
9b12			if DEBUG_FORTH_PUSH 
9b12						DMARK "PHc" 
9b12 f5				push af  
9b13 3a 27 9b			ld a, (.dmark)  
9b16 32 62 ee			ld (debug_mark),a  
9b19 3a 28 9b			ld a, (.dmark+1)  
9b1c 32 63 ee			ld (debug_mark+1),a  
9b1f 3a 29 9b			ld a, (.dmark+2)  
9b22 32 64 ee			ld (debug_mark+2),a  
9b25 18 03			jr .pastdmark  
9b27 ..			.dmark: db "PHc"  
9b2a f1			.pastdmark: pop af  
9b2b			endm  
# End of macro DMARK
9b2b				CALLMONITOR 
9b2b cd 6f ee			call debug_vector  
9b2e				endm  
# End of macro CALLMONITOR
9b2e			endif	 
9b2e			 
9b2e			 
9b2e ed b0			ldir 
9b30			 
9b30			 
9b30				; push malloc to data stack     macro?????  
9b30			 
9b30				FORTH_DSP_NEXT 
9b30 cd 84 99			call macro_forth_dsp_next 
9b33				endm 
# End of macro FORTH_DSP_NEXT
9b33			 
9b33				; save value and type 
9b33			 
9b33 2a e5 e9			ld hl, (cli_data_sp) 
9b36			 
9b36				; save item type 
9b36 3e 01			ld a,  DS_TYPE_STR 
9b38 77				ld (hl), a 
9b39 23				inc hl 
9b3a			 
9b3a				; get malloc word off stack 
9b3a d1				pop de 
9b3b 73				ld (hl), e 
9b3c 23				inc hl 
9b3d 72				ld (hl), d 
9b3e			 
9b3e			 
9b3e			 
9b3e			if DEBUG_FORTH_PUSH 
9b3e 2a e5 e9			ld hl, (cli_data_sp) 
9b41						DMARK "PHS" 
9b41 f5				push af  
9b42 3a 56 9b			ld a, (.dmark)  
9b45 32 62 ee			ld (debug_mark),a  
9b48 3a 57 9b			ld a, (.dmark+1)  
9b4b 32 63 ee			ld (debug_mark+1),a  
9b4e 3a 58 9b			ld a, (.dmark+2)  
9b51 32 64 ee			ld (debug_mark+2),a  
9b54 18 03			jr .pastdmark  
9b56 ..			.dmark: db "PHS"  
9b59 f1			.pastdmark: pop af  
9b5a			endm  
# End of macro DMARK
9b5a				CALLMONITOR 
9b5a cd 6f ee			call debug_vector  
9b5d				endm  
# End of macro CALLMONITOR
9b5d			;	ex de,hl 
9b5d			endif	 
9b5d				; in case of spaces, skip the ptr past the copied string 
9b5d				;pop af 
9b5d				;ld (cli_origptr),hl 
9b5d			 
9b5d c9				ret 
9b5e			 
9b5e			 
9b5e			 
9b5e			; TODO ascii push input onto stack given hl to start of input 
9b5e			 
9b5e			; identify type 
9b5e			; if starts with a " then a string 
9b5e			; otherwise it is a number 
9b5e			;  
9b5e			; if a string 
9b5e			;     scan for ending " to get length of string to malloc for + 1 
9b5e			;     malloc 
9b5e			;     put pointer to string on stack first byte flags as string 
9b5e			; 
9b5e			; else a number 
9b5e			;    look for number format identifier 
9b5e			;    $xx hex 
9b5e			;    %xxxxx bin 
9b5e			;    xxxxx decimal 
9b5e			;    convert number to 16bit word.  
9b5e			;    malloc word + 1 with flag to identiy as num 
9b5e			;    put pointer to number on stack 
9b5e			;   
9b5e			;  
9b5e			  
9b5e			forth_apush: 
9b5e				; kernel push 
9b5e			 
9b5e			if DEBUG_FORTH_PUSH 
9b5e						DMARK "PSH" 
9b5e f5				push af  
9b5f 3a 73 9b			ld a, (.dmark)  
9b62 32 62 ee			ld (debug_mark),a  
9b65 3a 74 9b			ld a, (.dmark+1)  
9b68 32 63 ee			ld (debug_mark+1),a  
9b6b 3a 75 9b			ld a, (.dmark+2)  
9b6e 32 64 ee			ld (debug_mark+2),a  
9b71 18 03			jr .pastdmark  
9b73 ..			.dmark: db "PSH"  
9b76 f1			.pastdmark: pop af  
9b77			endm  
# End of macro DMARK
9b77				CALLMONITOR 
9b77 cd 6f ee			call debug_vector  
9b7a				endm  
# End of macro CALLMONITOR
9b7a			endif	 
9b7a				; identify input type 
9b7a			 
9b7a 7e				ld a,(hl) 
9b7b			 
9b7b fe 23			cp '#' 
9b7d ca b7 9b			jp z, .fapdec 
9b80			 
9b80			 
9b80 fe 22			cp '"' 
9b82 28 0a			jr z, .fapstr 
9b84 fe 24			cp '$' 
9b86 ca ae 9b			jp z, .faphex 
9b89 fe 25			cp '%' 
9b8b ca 96 9b			jp z, .fapbin 
9b8e			;	cp 'b' 
9b8e			;	jp z, .fabin 
9b8e				; else decimal 
9b8e			 
9b8e				; TODO do decimal conversion 
9b8e				; decimal is stored as a 16bit word 
9b8e			 
9b8e				; by default everything is a string if type is not detected 
9b8e			.fapstr: ; 
9b8e fe 22			cp '"' 
9b90 20 01			jr nz, .strnoqu 
9b92 23				inc hl 
9b93			.strnoqu: 
9b93 c3 63 9a			jp forth_push_str 
9b96			 
9b96			 
9b96			 
9b96			.fapbin:    ; push a binary string.  
9b96 11 00 00			ld de, 0   ; hold a 16bit value 
9b99			 
9b99 23			.fapbinshift:	inc hl  
9b9a 7e				ld a,(hl) 
9b9b fe 00			cp 0     ; done scanning  
9b9d 28 0b			jr z, .fapbdone  	; got it in HL so push  
9b9f			 
9b9f				; left shift de 
9b9f eb				ex de, hl	 
9ba0 29				add hl, hl 
9ba1			 
9ba1				; is 1 
9ba1 fe 31			cp '1' 
9ba3 20 02			jr nz, .binzero 
9ba5 cb 4d			bit 1, l 
9ba7			.binzero: 
9ba7 eb				ex de, hl	 ; save current de 
9ba8 18 ef			jr .fapbinshift 
9baa			 
9baa			.fapbdone: 
9baa eb				ex de, hl 
9bab c3 f5 99			jp forth_push_numhl 
9bae			 
9bae			 
9bae			.faphex:   ; hex is always stored as a 16bit word 
9bae				; skip number prefix 
9bae 23				inc hl 
9baf				; turn ascii into number 
9baf cd a9 8f			call get_word_hl	; ret 16bit word in hl 
9bb2			 
9bb2 c3 f5 99			jp forth_push_numhl 
9bb5			 
9bb5 00				 nop 
9bb6			 
9bb6			.fabin:   ; TODO bin conversion 
9bb6			 
9bb6			 
9bb6 c9				ret 
9bb7			.fapdec:	 
9bb7				; string to dec conversion 
9bb7 23				inc hl 
9bb8 eb				ex de, hl 
9bb9 cd e7 8f			call string_to_uint16 
9bbc c3 f5 99			jp forth_push_numhl 
9bbf c9				ret 
9bc0				 
9bc0			;atoui_16: 
9bc0			 
9bc0			; get either a string ptr or a 16bit word from the data stack 
9bc0			 
9bc0			FORTH_DSP: macro 
9bc0				call macro_forth_dsp 
9bc0				endm 
9bc0			 
9bc0			macro_forth_dsp: 
9bc0				; data stack pointer points to current word on tos 
9bc0			 
9bc0 2a e5 e9			ld hl,(cli_data_sp) 
9bc3			 
9bc3				if DEBUG_FORTH_PUSH 
9bc3						DMARK "DSP" 
9bc3 f5				push af  
9bc4 3a d8 9b			ld a, (.dmark)  
9bc7 32 62 ee			ld (debug_mark),a  
9bca 3a d9 9b			ld a, (.dmark+1)  
9bcd 32 63 ee			ld (debug_mark+1),a  
9bd0 3a da 9b			ld a, (.dmark+2)  
9bd3 32 64 ee			ld (debug_mark+2),a  
9bd6 18 03			jr .pastdmark  
9bd8 ..			.dmark: db "DSP"  
9bdb f1			.pastdmark: pop af  
9bdc			endm  
# End of macro DMARK
9bdc			 
9bdc cd d1 d2				call display_data_sp 
9bdf				;call break_point_state 
9bdf				;rst 030h 
9bdf				CALLMONITOR 
9bdf cd 6f ee			call debug_vector  
9be2				endm  
# End of macro CALLMONITOR
9be2				endif 
9be2			 
9be2 c9				ret 
9be3			 
9be3			; return hl to start of value on stack 
9be3			 
9be3			FORTH_DSP_VALUE: macro 
9be3				call macro_forth_dsp_value 
9be3				endm 
9be3			 
9be3			macro_forth_dsp_value: 
9be3			 
9be3				FORTH_DSP 
9be3 cd c0 9b			call macro_forth_dsp 
9be6				endm 
# End of macro FORTH_DSP
9be6			 
9be6 d5				push de 
9be7			 
9be7 23				inc hl ; skip type 
9be8			 
9be8 5e				ld e, (hl) 
9be9 23				inc hl 
9bea 56				ld d, (hl) 
9beb eb				ex de,hl  
9bec			 
9bec d1				pop de 
9bed			 
9bed c9				ret 
9bee			 
9bee			; return hl to start of value to second item on stack 
9bee			 
9bee			FORTH_DSP_VALUEM1: macro 
9bee				call macro_forth_dsp_value_m1 
9bee				endm 
9bee			 
9bee			macro_forth_dsp_value_m1: 
9bee			 
9bee				FORTH_DSP 
9bee cd c0 9b			call macro_forth_dsp 
9bf1				endm 
# End of macro FORTH_DSP
9bf1			 
9bf1 2b				dec hl 
9bf2 2b				dec hl 
9bf3			;	dec hl 
9bf3			 
9bf3 d5				push de 
9bf4			 
9bf4 5e				ld e, (hl) 
9bf5 23				inc hl 
9bf6 56				ld d, (hl) 
9bf7 eb				ex de,hl  
9bf8			 
9bf8 d1				pop de 
9bf9			 
9bf9 c9				ret 
9bfa			 
9bfa				 
9bfa			 
9bfa			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9bfa			 
9bfa			FORTH_DSP_POP: macro 
9bfa				call macro_forth_dsp_pop 
9bfa				endm 
9bfa			 
9bfa			 
9bfa			; get the tos data type 
9bfa			 
9bfa			FORTH_DSP_TYPE:   macro 
9bfa			 
9bfa				;FORTH_DSP_VALUE 
9bfa				FORTH_DSP 
9bfa				 
9bfa				; hl points to value 
9bfa				; check type 
9bfa			 
9bfa				ld a,(hl) 
9bfa			 
9bfa				endm 
9bfa			 
9bfa			; load the tos value into hl 
9bfa			 
9bfa			 
9bfa			FORTH_DSP_VALUEHL:  macro 
9bfa				call macro_dsp_valuehl 
9bfa				endm 
9bfa			 
9bfa			 
9bfa			 
9bfa			macro_dsp_valuehl: 
9bfa				FORTH_DSP_VALUE 
9bfa cd e3 9b			call macro_forth_dsp_value 
9bfd				endm 
# End of macro FORTH_DSP_VALUE
9bfd			 
9bfd				;FORTH_ERR_TOS_NOTNUM 
9bfd			 
9bfd				;inc hl   ; skip type id 
9bfd			 
9bfd			;	push de 
9bfd			; 
9bfd			;	ld e, (hl) 
9bfd			;	inc hl 
9bfd			;	ld d, (hl) 
9bfd			;	ex de,hl  
9bfd			 
9bfd			;	pop de 
9bfd			 
9bfd				if DEBUG_FORTH_PUSH 
9bfd						DMARK "DVL" 
9bfd f5				push af  
9bfe 3a 12 9c			ld a, (.dmark)  
9c01 32 62 ee			ld (debug_mark),a  
9c04 3a 13 9c			ld a, (.dmark+1)  
9c07 32 63 ee			ld (debug_mark+1),a  
9c0a 3a 14 9c			ld a, (.dmark+2)  
9c0d 32 64 ee			ld (debug_mark+2),a  
9c10 18 03			jr .pastdmark  
9c12 ..			.dmark: db "DVL"  
9c15 f1			.pastdmark: pop af  
9c16			endm  
# End of macro DMARK
9c16				CALLMONITOR 
9c16 cd 6f ee			call debug_vector  
9c19				endm  
# End of macro CALLMONITOR
9c19				endif 
9c19 c9				ret 
9c1a			 
9c1a			forth_apushstrhl:      
9c1a				; push of string requires use of cli_origptr 
9c1a				; bodge use 
9c1a			 
9c1a				; get current cli_origptr, save, update with temp pointer  
9c1a ed 5b 35 ea		ld de, (cli_origptr) 
9c1e 22 35 ea			ld (cli_origptr), hl 
9c21 d5				push de 
9c22 cd 5e 9b			call forth_apush 
9c25 d1				pop de 
9c26 ed 53 35 ea		ld (cli_origptr), de 
9c2a c9			        ret	 
9c2b			 
9c2b			 
9c2b			; increase loop stack pointer and save hl to it 
9c2b				 
9c2b			FORTH_LOOP_NEXT: macro 
9c2b				call macro_forth_loop_next 
9c2b				;nop 
9c2b				endm 
9c2b			 
9c2b			macro_forth_loop_next: 
9c2b				if DEBUG_FORTH_STACK_GUARD 
9c2b cd 4d e0				call check_stacks 
9c2e				endif 
9c2e e5				push hl 
9c2f d5				push de 
9c30 eb				ex de,hl 
9c31 2a e7 e9			ld hl,(cli_loop_sp) 
9c34 23				inc hl 
9c35 23				inc hl 
9c36					if DEBUG_FORTH_WORDS 
9c36						DMARK "LNX" 
9c36 f5				push af  
9c37 3a 4b 9c			ld a, (.dmark)  
9c3a 32 62 ee			ld (debug_mark),a  
9c3d 3a 4c 9c			ld a, (.dmark+1)  
9c40 32 63 ee			ld (debug_mark+1),a  
9c43 3a 4d 9c			ld a, (.dmark+2)  
9c46 32 64 ee			ld (debug_mark+2),a  
9c49 18 03			jr .pastdmark  
9c4b ..			.dmark: db "LNX"  
9c4e f1			.pastdmark: pop af  
9c4f			endm  
# End of macro DMARK
9c4f						CALLMONITOR 
9c4f cd 6f ee			call debug_vector  
9c52				endm  
# End of macro CALLMONITOR
9c52					endif 
9c52 22 e7 e9			ld (cli_loop_sp),hl 
9c55 73				ld (hl), e 
9c56 23				inc hl 
9c57 72				ld (hl), d 
9c58 d1				pop de    ; been reversed so save a swap on restore 
9c59 e1				pop hl 
9c5a				if DEBUG_FORTH_STACK_GUARD 
9c5a cd 4d e0				call check_stacks 
9c5d				endif 
9c5d c9				ret 
9c5e			 
9c5e			; get current ret stack pointer and save to hl  
9c5e				 
9c5e			FORTH_LOOP_TOS: macro 
9c5e				call macro_forth_loop_tos 
9c5e				endm 
9c5e			 
9c5e			macro_forth_loop_tos: 
9c5e d5				push de 
9c5f 2a e7 e9			ld hl,(cli_loop_sp) 
9c62 5e				ld e, (hl) 
9c63 23				inc hl 
9c64 56				ld d, (hl) 
9c65 eb				ex de, hl 
9c66 d1				pop de 
9c67 c9				ret 
9c68			 
9c68			; pop loop stack pointer 
9c68				 
9c68			FORTH_LOOP_POP: macro 
9c68				call macro_forth_loop_pop 
9c68				endm 
9c68			 
9c68			 
9c68			macro_forth_loop_pop: 
9c68				if DEBUG_FORTH_STACK_GUARD 
9c68					DMARK "LPP" 
9c68 f5				push af  
9c69 3a 7d 9c			ld a, (.dmark)  
9c6c 32 62 ee			ld (debug_mark),a  
9c6f 3a 7e 9c			ld a, (.dmark+1)  
9c72 32 63 ee			ld (debug_mark+1),a  
9c75 3a 7f 9c			ld a, (.dmark+2)  
9c78 32 64 ee			ld (debug_mark+2),a  
9c7b 18 03			jr .pastdmark  
9c7d ..			.dmark: db "LPP"  
9c80 f1			.pastdmark: pop af  
9c81			endm  
# End of macro DMARK
9c81 cd 4d e0				call check_stacks 
9c84					FORTH_CHK_LOOP_UNDER 
9c84 e5				push hl 
9c85 d5				push de 
9c86 2a e7 e9			ld hl,(cli_loop_sp) 
9c89 11 21 e9			ld de, cli_loop_stack 
9c8c cd 08 8d			call cmp16 
9c8f da 6a e1			jp c, fault_loop_under 
9c92 d1				pop de 
9c93 e1				pop hl 
9c94				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c94				endif 
9c94 e5				push hl 
9c95 2a e7 e9			ld hl,(cli_loop_sp) 
9c98 2b				dec hl 
9c99 2b				dec hl 
9c9a 22 e7 e9			ld (cli_loop_sp), hl 
9c9d				; TODO do stack underflow checks 
9c9d e1				pop hl 
9c9e				if DEBUG_FORTH_STACK_GUARD 
9c9e cd 4d e0				call check_stacks 
9ca1					FORTH_CHK_LOOP_UNDER 
9ca1 e5				push hl 
9ca2 d5				push de 
9ca3 2a e7 e9			ld hl,(cli_loop_sp) 
9ca6 11 21 e9			ld de, cli_loop_stack 
9ca9 cd 08 8d			call cmp16 
9cac da 6a e1			jp c, fault_loop_under 
9caf d1				pop de 
9cb0 e1				pop hl 
9cb1				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9cb1				endif 
9cb1 c9				ret 
9cb2			 
9cb2			macro_forth_dsp_pop: 
9cb2			 
9cb2 e5				push hl 
9cb3			 
9cb3				; release malloc data 
9cb3			 
9cb3				if DEBUG_FORTH_STACK_GUARD 
9cb3 cd 4d e0				call check_stacks 
9cb6					FORTH_CHK_DSP_UNDER 
9cb6 e5				push hl 
9cb7 d5				push de 
9cb8 2a e5 e9			ld hl,(cli_data_sp) 
9cbb 11 1f e8			ld de, cli_data_stack 
9cbe cd 08 8d			call cmp16 
9cc1 da 5e e1			jp c, fault_dsp_under 
9cc4 d1				pop de 
9cc5 e1				pop hl 
9cc6				endm 
# End of macro FORTH_CHK_DSP_UNDER
9cc6				endif 
9cc6				;ld hl,(cli_data_sp) 
9cc6			if DEBUG_FORTH_DOT 
9cc6				DMARK "DPP" 
9cc6 f5				push af  
9cc7 3a db 9c			ld a, (.dmark)  
9cca 32 62 ee			ld (debug_mark),a  
9ccd 3a dc 9c			ld a, (.dmark+1)  
9cd0 32 63 ee			ld (debug_mark+1),a  
9cd3 3a dd 9c			ld a, (.dmark+2)  
9cd6 32 64 ee			ld (debug_mark+2),a  
9cd9 18 03			jr .pastdmark  
9cdb ..			.dmark: db "DPP"  
9cde f1			.pastdmark: pop af  
9cdf			endm  
# End of macro DMARK
9cdf				CALLMONITOR 
9cdf cd 6f ee			call debug_vector  
9ce2				endm  
# End of macro CALLMONITOR
9ce2			endif	 
9ce2			 
9ce2			 
9ce2			if FORTH_ENABLE_DSPPOPFREE 
9ce2			 
9ce2				FORTH_DSP 
9ce2 cd c0 9b			call macro_forth_dsp 
9ce5				endm 
# End of macro FORTH_DSP
9ce5			 
9ce5 7e				ld a, (hl) 
9ce6 fe 01			cp DS_TYPE_STR 
9ce8 20 22			jr nz, .skippopfree 
9cea			 
9cea				FORTH_DSP_VALUEHL 
9cea cd fa 9b			call macro_dsp_valuehl 
9ced				endm 
# End of macro FORTH_DSP_VALUEHL
9ced			;	nop 
9ced			if DEBUG_FORTH_DOT 
9ced				DMARK "DPf" 
9ced f5				push af  
9cee 3a 02 9d			ld a, (.dmark)  
9cf1 32 62 ee			ld (debug_mark),a  
9cf4 3a 03 9d			ld a, (.dmark+1)  
9cf7 32 63 ee			ld (debug_mark+1),a  
9cfa 3a 04 9d			ld a, (.dmark+2)  
9cfd 32 64 ee			ld (debug_mark+2),a  
9d00 18 03			jr .pastdmark  
9d02 ..			.dmark: db "DPf"  
9d05 f1			.pastdmark: pop af  
9d06			endm  
# End of macro DMARK
9d06				CALLMONITOR 
9d06 cd 6f ee			call debug_vector  
9d09				endm  
# End of macro CALLMONITOR
9d09			endif	 
9d09 cd 8f 91			call free 
9d0c			.skippopfree: 
9d0c				 
9d0c			 
9d0c			endif 
9d0c			 
9d0c			if DEBUG_FORTH_DOT_KEY 
9d0c				DMARK "DP2" 
9d0c				CALLMONITOR 
9d0c			endif	 
9d0c			 
9d0c				; move pointer down 
9d0c			 
9d0c 2a e5 e9			ld hl,(cli_data_sp) 
9d0f 2b				dec hl 
9d10 2b				dec hl 
9d11			; PARSEV5 
9d11 2b				dec hl 
9d12 22 e5 e9			ld (cli_data_sp), hl 
9d15			 
9d15				if DEBUG_FORTH_STACK_GUARD 
9d15 cd 4d e0				call check_stacks 
9d18					FORTH_CHK_DSP_UNDER 
9d18 e5				push hl 
9d19 d5				push de 
9d1a 2a e5 e9			ld hl,(cli_data_sp) 
9d1d 11 1f e8			ld de, cli_data_stack 
9d20 cd 08 8d			call cmp16 
9d23 da 5e e1			jp c, fault_dsp_under 
9d26 d1				pop de 
9d27 e1				pop hl 
9d28				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d28				endif 
9d28			 
9d28 e1				pop hl 
9d29			 
9d29 c9				ret 
9d2a			 
9d2a			getwordathl: 
9d2a				; hl points to an address 
9d2a				; load hl with the word at that address 
9d2a			 
9d2a d5				push de 
9d2b			 
9d2b 5e				ld e, (hl) 
9d2c 23				inc hl 
9d2d 56				ld d, (hl) 
9d2e eb				ex de, hl 
9d2f			 
9d2f d1				pop de 
9d30 c9				ret 
9d31			 
9d31			 
9d31			; functions to manuplite stack pointers 
9d31			 
9d31			; generate fragment to set hl to be pointer to a stack item 
9d31			 
9d31			FORTH_DSP_PTR: macro  x 
9d31				ld hl,(cli_data_sp) 
9d31				ld de, x * 3 
9d31				sbc hl, de 
9d31				endm 
9d31			 
9d31			 
9d31			 
9d31			; copy point in hl to stack tmp storage slots 1-4 
9d31			hltostack1: 
9d31 11 b5 e2			ld de, os_stack_1  
9d34 c3 5f 9d			jp hltostackmv 
9d37			 
9d37			hltostack2:  
9d37 11 b2 e2			ld de, os_stack_2 
9d3a c3 5f 9d			jp hltostackmv 
9d3d			 
9d3d			hltostack3:  
9d3d 11 af e2			ld de, os_stack_3 
9d40 c3 5f 9d			jp hltostackmv 
9d43			 
9d43			hltostack4:  
9d43 11 ac e2			ld de, os_stack_4  
9d46 c3 5f 9d			jp hltostackmv 
9d49			 
9d49			; copy to point in hl from stack tmp storage slots 1-4 
9d49			hlfromstack1: 
9d49 11 b5 e2			ld de, os_stack_1 
9d4c c3 5e 9d			jp hlfromsttackmv 
9d4f			 
9d4f			hlfromstack2:  
9d4f 11 b2 e2			ld de, os_stack_2 
9d52 c3 5e 9d			jp hlfromsttackmv 
9d55			 
9d55			hlfromstack3:  
9d55 11 af e2			ld de, os_stack_3 
9d58 c3 5e 9d			jp hlfromsttackmv 
9d5b			 
9d5b			hlfromstack4:  
9d5b 11 ac e2			ld de, os_stack_4 
9d5e			 
9d5e			hlfromsttackmv: 
9d5e eb				ex de, hl 
9d5f			 
9d5f			hltostackmv: 
9d5f			 
9d5f				; do stack move 
9d5f c5				push bc 
9d60 01 03 00			ld bc, 3 
9d63 ed b0			ldir  
9d65 c1				pop bc	 
9d66 c9				ret 
9d67			 
9d67			; eof 
9d67			 
# End of file forth_stackopsv5.asm
9d67			endif 
9d67			loadwordinhl:	 
9d67			 
9d67 d5				push de 
9d68			 
9d68 5e				ld e, (hl) 
9d69 23				inc hl 
9d6a 56				ld d, (hl) 
9d6b eb				ex de,hl  
9d6c			 
9d6c d1				pop de 
9d6d			 
9d6d c9				ret 
9d6e			 
9d6e			user_word_eol:  
9d6e				; hl contains the pointer to where to create a linked list item from the end 
9d6e				; of the user dict to continue on at the system word dict 
9d6e				 
9d6e				; poke the stub of the word list linked list to repoint to rom words 
9d6e			 
9d6e				; stub format 
9d6e				; db   word id 
9d6e				; dw    link to next word 
9d6e			        ; db char length of token 
9d6e				; db string + 0 term 
9d6e				; db exec code....  
9d6e			 
9d6e 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9d70 77				ld (hl), a		; word id 
9d71 23				inc hl 
9d72			 
9d72 11 29 9f			ld de, sysdict 
9d75 73				ld (hl), e		; next word link ie system dict 
9d76 23				inc hl 
9d77 72				ld (hl), d		; next word link ie system dict 
9d78 23				inc hl	 
9d79			 
9d79			;	ld (hl), sysdict		; next word link ie system dict 
9d79			;	inc hl 
9d79			;	inc hl 
9d79			 
9d79			;	inc hl 
9d79			;	inc hl 
9d79			 
9d79 3e 02			ld a, 2			; word length is 0 
9d7b 77				ld (hl), a	 
9d7c 23				inc hl 
9d7d			 
9d7d 3e 7e			ld a, '~'			; word length is 0 
9d7f 77				ld (hl), a	 
9d80 23				inc hl 
9d81 3e 00			ld a, 0			; save empty word 
9d83 77				ld (hl), a 
9d84			 
9d84 c9				ret 
9d85			 
9d85				 
9d85			 
9d85			forthexec_cleanup: 
9d85				FORTH_RSP_POP 
9d85 cd bd 99			call macro_forth_rsp_pop 
9d88				endm 
# End of macro FORTH_RSP_POP
9d88 c9				ret 
9d89			 
9d89			forth_call_hl: 
9d89				; taking hl 
9d89 e5				push hl 
9d8a c9				ret 
9d8b			 
9d8b			; this is called to reset Forth system but keep existing uwords etc 
9d8b			 
9d8b			forth_warmstart: 
9d8b				; setup stack over/under flow checks 
9d8b				if DEBUG_FORTH_STACK_GUARD 
9d8b cd 33 e0				call chk_stk_init 
9d8e				endif 
9d8e			 
9d8e				; init stack pointers  - * these stacks go upwards *  
9d8e 21 a3 e9			ld hl, cli_ret_stack 
9d91 22 e9 e9			ld (cli_ret_sp), hl	 
9d94				; set bottom of stack 
9d94 3e 00			ld a,0 
9d96 77				ld (hl),a 
9d97 23				inc hl 
9d98 77				ld (hl),a 
9d99			 
9d99 21 1f e8			ld hl, cli_data_stack 
9d9c 22 e5 e9			ld (cli_data_sp), hl	 
9d9f				; set bottom of stack 
9d9f 3e 00			ld a,0 
9da1 77				ld (hl),a 
9da2 23				inc hl 
9da3 77				ld (hl),a 
9da4			 
9da4 21 21 e9			ld hl, cli_loop_stack 
9da7 22 e7 e9			ld (cli_loop_sp), hl	 
9daa				; set bottom of stack 
9daa 3e 00			ld a,0 
9dac 77				ld (hl),a 
9dad 23				inc hl 
9dae 77				ld (hl),a 
9daf			 
9daf				; init extent of current open file 
9daf			 
9daf 3e 00			ld a, 0 
9db1 32 61 ea			ld (store_openext), a 
9db4			 
9db4 c9				ret 
9db5			 
9db5			 
9db5			 
9db5			; Cold Start - this is called to setup the whole Forth system 
9db5			 
9db5			forth_init: 
9db5			 
9db5				; setup stack over/under flow checks 
9db5			 
9db5			;	if DEBUG_FORTH_STACK_GUARD 
9db5			;		call chk_stk_init 
9db5			;	endif 
9db5			 
9db5				; enable auto display updates (slow.....) 
9db5			 
9db5 3e 01			ld a, 1 
9db7 32 33 ea			ld (cli_autodisplay), a 
9dba			 
9dba				; if storage is in use disable long reads for now 
9dba 3e 00			ld a, 0 
9dbc 32 6c ea			ld (store_longread), a 
9dbf			 
9dbf			 
9dbf				; show start up screen 
9dbf			 
9dbf cd bd 8a			call clear_display 
9dc2			 
9dc2 3e 00			ld a,0 
9dc4 32 55 ea			ld (f_cursor_ptr), a 
9dc7			 
9dc7				; set start of word list in start of ram - for use when creating user words 
9dc7			 
9dc7 21 f0 e3			ld hl, baseram 
9dca 22 b5 e5			ld (os_last_new_uword), hl 
9dcd cd 6e 9d			call user_word_eol 
9dd0				 
9dd0			;		call display_data_sp 
9dd0			;		call next_page_prompt 
9dd0			 
9dd0			 
9dd0			 
9dd0			 
9dd0 c9				ret 
9dd1			 
9dd1 .. 00		.bootforth: db " Forth Kernel Init ",0 
9de5			 
9de5			; TODO push to stack 
9de5			 
9de5			;  
9de5			 
9de5			if FORTH_PARSEV2 
9de5			 
9de5			 
9de5				include "forth_parserv2.asm" 
9de5			 
9de5			endif 
9de5			 
9de5			 
9de5			; parse cli version 1 
9de5			 
9de5			if FORTH_PARSEV1 
9de5			 
9de5			 
9de5			 
9de5			      include "forth_parserv1.asm" 
9de5			endif 
9de5				 
9de5			if FORTH_PARSEV3 
9de5			      include "forth_parserv3.asm" 
9de5				include "forth_wordsv3.asm" 
9de5			endif 
9de5			 
9de5			if FORTH_PARSEV4 
9de5			      include "forth_parserv4.asm" 
9de5				include "forth_wordsv4.asm" 
9de5			endif 
9de5			 
9de5			if FORTH_PARSEV5 
9de5			      include "forth_parserv5.asm" 
9de5				include "forth_wordsv4.asm" 
9de5			endif 
9de5			 
9de5			if FORTH_PARSEV6 
9de5			      include "forth_parserv6.asm" 
9de5			 
9de5			 
9de5			; A better parser without using malloc and string copies all over the place.  
9de5			; Exec in situ should be faster 
9de5			 
9de5			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9de5			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9de5			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9de5			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9de5			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9de5			WORD_SYS_END: equ 0   ; Opcode for all user words 
9de5			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9de5			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9de5			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9de5			 
9de5			; Core word preamble macro 
9de5			 
9de5			CWHEAD:   macro nxtword opcode lit len opflags 
9de5				db WORD_SYS_CORE+opcode             
9de5				; internal op code number 
9de5				dw nxtword            
9de5				; link to next dict word block 
9de5				db len + 1 
9de5				; literal length of dict word inc zero term 
9de5				db lit,0              
9de5				; literal dict word 
9de5			        ; TODO db opflags        
9de5				endm 
9de5			 
9de5			 
9de5			NEXTW: macro  
9de5				call parse_vector 
9de5				jp macro_next 
9de5				endm 
9de5			 
9de5			macro_next: 
9de5			if DEBUG_FORTH_PARSE_EXEC 
9de5				DMARK "NXT" 
9de5				CALLMONITOR 
9de5			endif	 
9de5			;	inc hl  ; skip token null term  
9de5 ed 4b 37 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9de9 ed 5b 35 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9ded 2a b9 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9df0			if DEBUG_FORTH_PARSE_EXEC 
9df0				DMARK "}AA" 
9df0				CALLMONITOR 
9df0			endif	 
9df0 c3 df 9e			jp execnext 
9df3				;jp exec1 
9df3			       
9df3			 
9df3			 
9df3			; Another go at the parser to compile  
9df3			 
9df3			 
9df3			; TODO rework parser to change all of the string words to byte tokens 
9df3			; TODO do a search for  
9df3			 
9df3			; TODO first run normal parser to zero term sections 
9df3			; TODO for each word do a token look up to get the op code 
9df3			; TODO need some means to flag to the exec that this is a byte code form    
9df3			 
9df3			 
9df3			forthcompile: 
9df3			 
9df3			; 
9df3			; line parse: 
9df3			;       parse raw input buffer 
9df3			;       tokenise the words 
9df3			;       malloc new copy (for looping etc) 
9df3			;       copy to malloc + current pc in line to start of string and add line term 
9df3			;       save on new rsp 
9df3			; 
9df3			 
9df3			; hl to point to the line to tokenise 
9df3			 
9df3			;	push hl 
9df3 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9df6			 
9df6			;	ld a,0		; string term on input 
9df6			;	call strlent 
9df6			 
9df6			;	ld (os_tok_len), hl	 ; save string length 
9df6			 
9df6			;if DEBUG_FORTH_TOK 
9df6			;	ex de,hl		 
9df6			;endif 
9df6			 
9df6			;	pop hl 		; get back string pointer 
9df6			 
9df6			if DEBUG_FORTH_TOK 
9df6						DMARK "TOc" 
9df6				CALLMONITOR 
9df6			endif 
9df6 7e			.cptoken2:    ld a,(hl) 
9df7 23				inc hl 
9df8 fe 7f			cp FORTH_END_BUFFER 
9dfa 28 29			jr z, .cptokendone2 
9dfc fe 00			cp 0 
9dfe 28 25			jr z, .cptokendone2 
9e00 fe 22			cp '"' 
9e02 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e04 fe 20			cp ' ' 
9e06 20 ee			jr nz,  .cptoken2 
9e08			 
9e08			; TODO consume comments held between ( and ) 
9e08			 
9e08				; we have a space so change to zero term for dict match later 
9e08 2b				dec hl 
9e09 3e 00			ld a,0 
9e0b 77				ld (hl), a 
9e0c 23				inc hl 
9e0d 18 e7			jr .cptoken2 
9e0f				 
9e0f			 
9e0f			.cptokenstr2: 
9e0f				; skip all white space until either eol (because forgot to term) or end double quote 
9e0f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e0f				;inc hl ; skip current double quote 
9e0f 7e				ld a,(hl) 
9e10 23				inc hl 
9e11 fe 22			cp '"' 
9e13 28 e1			jr z, .cptoken2 
9e15 fe 7f			cp FORTH_END_BUFFER 
9e17 28 0c			jr z, .cptokendone2 
9e19 fe 00			cp 0 
9e1b 28 08			jr z, .cptokendone2 
9e1d fe 20			cp ' ' 
9e1f 28 02			jr z, .cptmp2 
9e21 18 ec			jr .cptokenstr2 
9e23			 
9e23			.cptmp2:	; we have a space so change to zero term for dict match later 
9e23				;dec hl 
9e23				;ld a,"-"	; TODO remove this when working 
9e23				;ld (hl), a 
9e23				;inc hl 
9e23 18 ea			jr .cptokenstr2 
9e25			 
9e25			.cptokendone2: 
9e25				;inc hl 
9e25 3e 7f			ld a, FORTH_END_BUFFER 
9e27 77				ld (hl),a 
9e28			;	inc hl 
9e28			;	ld a, '!' 
9e28			;	ld (hl),a 
9e28			 
9e28 2a b9 e5			ld hl,(os_tok_ptr) 
9e2b			         
9e2b			if DEBUG_FORTH_TOK 
9e2b						DMARK "Tc1" 
9e2b				CALLMONITOR 
9e2b			endif 
9e2b			 
9e2b				; push exec string to top of return stack 
9e2b				FORTH_RSP_NEXT 
9e2b cd 9c 99			call macro_forth_rsp_next 
9e2e				endm 
# End of macro FORTH_RSP_NEXT
9e2e c9				ret 
9e2f			 
9e2f			; Another go at the parser need to simplify the process 
9e2f			 
9e2f			forthparse: 
9e2f			 
9e2f			; 
9e2f			; line parse: 
9e2f			;       parse raw input buffer 
9e2f			;       tokenise the words 
9e2f			;       malloc new copy (for looping etc) 
9e2f			;       copy to malloc + current pc in line to start of string and add line term 
9e2f			;       save on new rsp 
9e2f			; 
9e2f			 
9e2f			; hl to point to the line to tokenise 
9e2f			 
9e2f			;	push hl 
9e2f 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e32			 
9e32			;	ld a,0		; string term on input 
9e32			;	call strlent 
9e32			 
9e32			;	ld (os_tok_len), hl	 ; save string length 
9e32			 
9e32			;if DEBUG_FORTH_TOK 
9e32			;	ex de,hl		 
9e32			;endif 
9e32			 
9e32			;	pop hl 		; get back string pointer 
9e32			 
9e32			if DEBUG_FORTH_TOK 
9e32						DMARK "TOK" 
9e32				CALLMONITOR 
9e32			endif 
9e32 7e			.ptoken2:    ld a,(hl) 
9e33 23				inc hl 
9e34 fe 7f			cp FORTH_END_BUFFER 
9e36 28 29			jr z, .ptokendone2 
9e38 fe 00			cp 0 
9e3a 28 25			jr z, .ptokendone2 
9e3c fe 22			cp '"' 
9e3e 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9e40 fe 20			cp ' ' 
9e42 20 ee			jr nz,  .ptoken2 
9e44			 
9e44			; TODO consume comments held between ( and ) 
9e44			 
9e44				; we have a space so change to zero term for dict match later 
9e44 2b				dec hl 
9e45 3e 00			ld a,0 
9e47 77				ld (hl), a 
9e48 23				inc hl 
9e49 18 e7			jr .ptoken2 
9e4b				 
9e4b			 
9e4b			.ptokenstr2: 
9e4b				; skip all white space until either eol (because forgot to term) or end double quote 
9e4b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e4b				;inc hl ; skip current double quote 
9e4b 7e				ld a,(hl) 
9e4c 23				inc hl 
9e4d fe 22			cp '"' 
9e4f 28 e1			jr z, .ptoken2 
9e51 fe 7f			cp FORTH_END_BUFFER 
9e53 28 0c			jr z, .ptokendone2 
9e55 fe 00			cp 0 
9e57 28 08			jr z, .ptokendone2 
9e59 fe 20			cp ' ' 
9e5b 28 02			jr z, .ptmp2 
9e5d 18 ec			jr .ptokenstr2 
9e5f			 
9e5f			.ptmp2:	; we have a space so change to zero term for dict match later 
9e5f				;dec hl 
9e5f				;ld a,"-"	; TODO remove this when working 
9e5f				;ld (hl), a 
9e5f				;inc hl 
9e5f 18 ea			jr .ptokenstr2 
9e61			 
9e61			.ptokendone2: 
9e61				;inc hl 
9e61 3e 7f			ld a, FORTH_END_BUFFER 
9e63 77				ld (hl),a 
9e64			;	inc hl 
9e64			;	ld a, '!' 
9e64			;	ld (hl),a 
9e64			 
9e64 2a b9 e5			ld hl,(os_tok_ptr) 
9e67			         
9e67			if DEBUG_FORTH_TOK 
9e67						DMARK "TK1" 
9e67				CALLMONITOR 
9e67			endif 
9e67			 
9e67				; push exec string to top of return stack 
9e67				FORTH_RSP_NEXT 
9e67 cd 9c 99			call macro_forth_rsp_next 
9e6a				endm 
# End of macro FORTH_RSP_NEXT
9e6a c9				ret 
9e6b			 
9e6b			; 
9e6b			;	; malloc size + buffer pointer + if is loop flag 
9e6b			;	ld hl,(os_tok_len) 		 ; get string length 
9e6b			; 
9e6b			;	ld a,l 
9e6b			; 
9e6b			;	cp 0			; we dont want to use a null string 
9e6b			;	ret z 
9e6b			; 
9e6b			;;	add 3    ; prefix malloc with buffer for current word ptr 
9e6b			; 
9e6b			;	add 5     ; TODO when certain not over writing memory remove 
9e6b			; 
9e6b			;		 
9e6b			; 
9e6b			;if DEBUG_FORTH_TOK 
9e6b			;			DMARK "TKE" 
9e6b			;	CALLMONITOR 
9e6b			;endif 
9e6b			; 
9e6b			;	ld l,a 
9e6b			;	ld h,0 
9e6b			;;	push hl   ; save required space for the copy later 
9e6b			;	call malloc 
9e6b			;if DEBUG_FORTH_TOK 
9e6b			;			DMARK "TKM" 
9e6b			;	CALLMONITOR 
9e6b			;endif 
9e6b			;	if DEBUG_FORTH_MALLOC_GUARD 
9e6b			;		push af 
9e6b			;		call ishlzero 
9e6b			;;		ld a, l 
9e6b			;;		add h 
9e6b			;;		cp 0 
9e6b			;		pop af 
9e6b			;		 
9e6b			;		call z,malloc_error 
9e6b			;	endif 
9e6b			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9e6b			; 
9e6b			; 
9e6b			;if DEBUG_FORTH_TOK 
9e6b			;			DMARK "TKR" 
9e6b			;	CALLMONITOR 
9e6b			;endif 
9e6b			; 
9e6b			;	FORTH_RSP_NEXT 
9e6b			; 
9e6b			;	;inc hl	 ; go past current buffer pointer 
9e6b			;	;inc hl 
9e6b			;	;inc hl   ; and past if loop flag 
9e6b			;		; TODO Need to set flag  
9e6b			; 
9e6b			;	 
9e6b			;	 
9e6b			;	ex de,hl	; malloc is dest 
9e6b			;	ld hl, (os_tok_len) 
9e6b			;;	pop bc 
9e6b			;	ld c, l                
9e6b			;	ld b,0 
9e6b			;	ld hl, (os_tok_ptr) 
9e6b			; 
9e6b			;if DEBUG_FORTH_TOK 
9e6b			;			DMARK "TKT" 
9e6b			;	CALLMONITOR 
9e6b			;endif 
9e6b			; 
9e6b			;	; do str cpy 
9e6b			; 
9e6b			;	ldir      ; copy byte in hl to de 
9e6b			; 
9e6b			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9e6b			; 
9e6b			;if DEBUG_FORTH_TOK 
9e6b			; 
9e6b			;			DMARK "TKY" 
9e6b			;	CALLMONITOR 
9e6b			;endif 
9e6b			;	;ld a,0 
9e6b			;	;ld a,FORTH_END_BUFFER 
9e6b			;	ex de, hl 
9e6b			;	;dec hl			 ; go back over the space delim at the end of word 
9e6b			;	;ld (hl),a 
9e6b			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9e6b			;	ld a,FORTH_END_BUFFER 
9e6b			;	ld (hl),a 
9e6b			;	inc hl 
9e6b			;	ld a,FORTH_END_BUFFER 
9e6b			;	ld (hl),a 
9e6b			; 
9e6b			;	; init the malloc area data 
9e6b			;	; set pc for in current area 
9e6b			;	;ld hl, (os_tok_malloc) 
9e6b			;	;inc hl 
9e6b			;	;inc hl 
9e6b			;	;inc hl 
9e6b			;	;ex de,hl 
9e6b			;	;ld hl, (os_tok_malloc) 
9e6b			;	;ld (hl),e 
9e6b			;	;inc hl 
9e6b			;	;ld (hl),d 
9e6b			; 
9e6b			; 
9e6b			;	ld hl,(os_tok_malloc) 
9e6b			;if DEBUG_FORTH_PARSE_KEY 
9e6b			;			DMARK "TKU" 
9e6b			;	CALLMONITOR 
9e6b			;endif 
9e6b			; 
9e6b			;	ret 
9e6b			 
9e6b			forthexec: 
9e6b			 
9e6b			; line exec: 
9e6b			; forth parser 
9e6b			 
9e6b			; 
9e6b			;       get current exec line on rsp 
9e6b			 
9e6b				FORTH_RSP_TOS 
9e6b cd b3 99			call macro_forth_rsp_tos 
9e6e				endm 
# End of macro FORTH_RSP_TOS
9e6e			 
9e6e			;       restore current pc - hl points to malloc of data 
9e6e			 
9e6e				;ld e, (hl) 
9e6e				;inc hl 
9e6e				;ld d, (hl) 
9e6e				;ex de,hl 
9e6e			 
9e6e			 
9e6e			exec1: 
9e6e 22 b9 e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
9e71			 
9e71				; copy our PC to working vars  
9e71 22 37 ea			ld (cli_ptr), hl                    ; here 
9e74 22 35 ea			ld (cli_origptr), hl                ; here 
9e77			 
9e77 7e				ld a,(hl)                           ; here make hl be the ram ptr 
9e78 fe 7f			cp FORTH_END_BUFFER 
9e7a c8				ret z 
9e7b			 
9e7b				; skip any nulls 
9e7b			 
9e7b fe 00			cp 0 
9e7d 20 03			jr nz, .execword 
9e7f 23				inc hl 
9e80 18 ec			jr exec1 
9e82			 
9e82			 
9e82			.execword: 
9e82			 
9e82			 
9e82			 
9e82			if DEBUG_FORTH_PARSE_EXEC 
9e82						DMARK "KYQ" 
9e82				CALLMONITOR 
9e82			endif 
9e82			;       while at start of word: 
9e82			; get start of dict (in user area first) 
9e82			 
9e82 21 f0 e3		ld hl, baseram 
9e85			;ld hl, sysdict 
9e85 22 39 ea		ld (cli_nextword),hl                            ; here do we need to do this? 
9e88			;           match word at pc 
9e88			;           exec word 
9e88			;           or push to dsp 
9e88			;           forward to next token 
9e88			;           if line term pop rsp and exit 
9e88			;        
9e88			 
9e88			if DEBUG_FORTH_PARSE_EXEC 
9e88						DMARK "KYq" 
9e88				CALLMONITOR 
9e88			endif 
9e88			 
9e88			; 
9e88			; word comp 
9e88			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9e88			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9e88			;    move to start of word  
9e88			;    compare word to cli_token 
9e88			 
9e88			.execpnword:	; HL at start of a word in the dictionary to check 
9e88			 
9e88 2a 39 ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
9e8b			 
9e8b cd 22 9f			call forth_tok_next 
9e8e			; tok next end here 
9e8e 22 39 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9e91 eb				ex de, hl 
9e92			 
9e92			 
9e92				; save the pointer of the current token - 1 to check against 
9e92				 
9e92 22 3d ea			ld (cli_token), hl   
9e95				; TODO maybe remove below save if no debug 
9e95				; save token string ptr for any debug later 
9e95 23				inc hl  
9e96 22 3f ea			ld (cli_origtoken), hl 
9e99 2b				dec hl 
9e9a				; save pointer to the start of the next dictionay word 
9e9a 7e				ld a,(hl)   ; get string length 
9e9b 47				ld b,a 
9e9c			.execpnwordinc:  
9e9c 23				inc hl 
9e9d 10 fd			djnz .execpnwordinc 
9e9f 22 3b ea			ld (cli_execword), hl      ; save start of this words code 
9ea2			 
9ea2				; now check the word token against the string being parsed 
9ea2			 
9ea2 2a 3d ea			ld hl,(cli_token) 
9ea5 23				inc hl     ; skip string length (use zero term instead to end) 
9ea6				;ld (cli_token), hl 
9ea6			 
9ea6			.execpnchar:    ; compare char between token and string to parse 
9ea6			 
9ea6			 
9ea6				;ld hl, (cli_token)     ; the dict word  
9ea6 ed 5b 37 ea		ld de, (cli_ptr)     ; cli to parse 
9eaa			 
9eaa			 
9eaa			.execpncharl:    ; compare char between token and string to parse (loop) 
9eaa			 
9eaa 1a				ld a,(de) 
9eab cd 47 90			call toUpper 		; make sure the input string matches case 
9eae be				cp (hl) 
9eaf			 
9eaf c2 c8 9e			jp nz, .execpnskipword	 ; no match so move to next word 
9eb2				 
9eb2			;    if same 
9eb2			;       scan for string terms 0 for token and 32 for input 
9eb2 46				ld b,(hl) 
9eb3 80				add b			 
9eb4 23				inc hl 
9eb5 13				inc de 
9eb6 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9eb8							; TODO need to make sure last word in zero term string is accounted for 
9eb8 20 f0			jr nz, .execpncharl 		 ; not at end of strings yet 
9eba			 
9eba			 
9eba				; at end of both strings so both are exact match 
9eba			 
9eba			;       skip ptr for next word 
9eba			 
9eba 2a 37 ea			ld hl,(cli_ptr) 	; at input string term 
9ebd 23				inc hl			 ; at next char 
9ebe 22 37 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9ec1 22 35 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9ec4				 
9ec4				 
9ec4			 
9ec4			 
9ec4			 
9ec4			;       exec code block 
9ec4			if DEBUG_FORTH_JP 
9ec4				call clear_display 
9ec4				call update_display 
9ec4				call delay1s 
9ec4				ld hl, (cli_execword)     ; save for next check if no match on this word 
9ec4				ld a,h 
9ec4				ld hl, os_word_scratch 
9ec4				call hexout 
9ec4				ld hl, (cli_execword)     ; save for next check if no match on this word 
9ec4				ld a,l 
9ec4				ld hl, os_word_scratch+2 
9ec4				call hexout 
9ec4				ld hl, os_word_scratch+4 
9ec4				ld a,0 
9ec4				ld (hl),a 
9ec4				ld de,os_word_scratch 
9ec4				call str_at_display 
9ec4					ld a, display_row_2 
9ec4					call str_at_display 
9ec4				ld de, (cli_origtoken) 
9ec4				ld a, display_row_1+10 
9ec4					call str_at_display 
9ec4			 
9ec4				ld a,display_row_1 
9ec4				ld de, .foundword 
9ec4				ld a, display_row_3 
9ec4				call str_at_display 
9ec4				call update_display 
9ec4				call delay1s 
9ec4				call delay1s 
9ec4				call delay1s 
9ec4			endif 
9ec4			 
9ec4			if DEBUG_FORTH_PARSE_EXEC 
9ec4						DMARK "KYj" 
9ec4			endif 
9ec4				; TODO save the word pointer in this exec 
9ec4			 
9ec4 2a 3b ea			ld hl,(cli_execword) 
9ec7 e9				jp (hl) 
9ec8			 
9ec8			 
9ec8			;    if not same 
9ec8			;	scan for zero term 
9ec8			;	get ptr for next word 
9ec8			;	goto word comp 
9ec8			 
9ec8			.execpnskipword:	; get pointer to next word 
9ec8 2a 39 ea			ld hl,(cli_nextword) 
9ecb			 
9ecb 7e				ld a,(hl) 
9ecc fe 00			cp WORD_SYS_END 
9ece			;	cp 0 
9ece 28 09			jr z, .execendofdict			 ; at end of words 
9ed0			 
9ed0			if DEBUG_FORTH_PARSE_EXEC 
9ed0						DMARK "KY4" 
9ed0			endif 
9ed0			if DEBUG_FORTH_PARSE_EXEC 
9ed0			 
9ed0				; see if disabled 
9ed0			 
9ed0			;	ld a, (os_view_disable) 
9ed0			;	cp '*' 
9ed0				ld a,(debug_vector) 
9ed0				cp $c9   ; RET 
9ed0				jr z, .noskip 
9ed0			 
9ed0			 
9ed0				ld de, .nowordfound 
9ed0				ld a, display_row_3 
9ed0				call str_at_display 
9ed0				call update_display 
9ed0				ld a, 100 
9ed0				call aDelayInMS 
9ed0				 
9ed0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ed0					call delay250ms 
9ed0				endif 
9ed0			.noskip:  
9ed0			 
9ed0			endif	 
9ed0			 
9ed0 2a 35 ea			ld hl,(cli_origptr) 
9ed3 22 37 ea			ld (cli_ptr),hl 
9ed6			 
9ed6			if DEBUG_FORTH_PARSE_EXEC 
9ed6						DMARK "KY5" 
9ed6			endif 
9ed6 c3 88 9e			jp .execpnword			; else go to next word 
9ed9			 
9ed9			.execendofdict:  
9ed9			 
9ed9			if DEBUG_FORTH_PARSE_EXEC 
9ed9						DMARK "KYe" 
9ed9			endif 
9ed9			if DEBUG_FORTH_PARSE_EXEC 
9ed9				; see if disabled 
9ed9			 
9ed9			;	ld a, (os_view_disable) 
9ed9			;	cp '*' 
9ed9				ld a,(debug_vector) 
9ed9				cp $c9   ; ret 
9ed9				jr z, .ispskip 
9ed9			 
9ed9				call clear_display 
9ed9				call update_display 
9ed9				call delay1s 
9ed9				ld de, (cli_origptr) 
9ed9				ld a, display_row_1 
9ed9				call str_at_display 
9ed9				 
9ed9				ld de, .enddict 
9ed9				ld a, display_row_3 
9ed9				call str_at_display 
9ed9				call update_display 
9ed9				ld a, 100 
9ed9				call aDelayInMS 
9ed9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ed9				call delay1s 
9ed9				call delay1s 
9ed9				call delay1s 
9ed9				endif 
9ed9			.ispskip:  
9ed9				 
9ed9			endif	 
9ed9			 
9ed9			 
9ed9			 
9ed9				; if the word is not a keyword then must be a literal so push it to stack 
9ed9			 
9ed9			; push token to stack to end of word 
9ed9			 
9ed9				STACKFRAME ON $1efe $2f9f 
9ed9				if DEBUG_STACK_IMB 
9ed9					if ON 
9ed9						exx 
9ed9						ld de, $1efe 
9ed9						ld a, d 
9ed9						ld hl, curframe 
9ed9						call hexout 
9ed9						ld a, e 
9ed9						ld hl, curframe+2 
9ed9						call hexout 
9ed9						ld hl, $1efe 
9ed9						push hl 
9ed9						ld hl, $2f9f 
9ed9						push hl 
9ed9						exx 
9ed9					endif 
9ed9				endif 
9ed9			endm 
# End of macro STACKFRAME
9ed9			 
9ed9 2a b9 e5		ld hl,(os_tok_ptr) 
9edc cd 5e 9b		call forth_apush 
9edf			 
9edf				STACKFRAMECHK ON $1efe $2f9f 
9edf				if DEBUG_STACK_IMB 
9edf					if ON 
9edf						exx 
9edf						ld hl, $2f9f 
9edf						pop de   ; $2f9f 
9edf						call cmp16 
9edf						jr nz, .spnosame 
9edf						ld hl, $1efe 
9edf						pop de   ; $1efe 
9edf						call cmp16 
9edf						jr z, .spfrsame 
9edf						.spnosame: call showsperror 
9edf						.spfrsame: nop 
9edf						exx 
9edf					endif 
9edf				endif 
9edf			endm 
# End of macro STACKFRAMECHK
9edf			 
9edf			execnext: 
9edf			 
9edf			if DEBUG_FORTH_PARSE_EXEC 
9edf						DMARK "KY>" 
9edf			endif 
9edf			; move past token to next word 
9edf			 
9edf 2a b9 e5		ld hl, (os_tok_ptr) 
9ee2 3e 00		ld a, 0 
9ee4 01 ff 00		ld bc, 255     ; input buffer size 
9ee7 ed b1		cpir 
9ee9			 
9ee9			if DEBUG_FORTH_PARSE_EXEC 
9ee9						DMARK "KY!" 
9ee9				CALLMONITOR 
9ee9			endif	 
9ee9			; TODO this might place hl on the null, so will need to forward on??? 
9ee9			;inc hl   ; see if this gets onto the next item 
9ee9			 
9ee9			 
9ee9			; TODO pass a pointer to the buffer to push 
9ee9			; TODO call function to push 
9ee9			 
9ee9			; look for end of input 
9ee9			 
9ee9			;inc hl 
9ee9			;ld a,(hl) 
9ee9			;cp FORTH_END_BUFFER 
9ee9			;ret z 
9ee9			 
9ee9			 
9ee9 c3 6e 9e		jp exec1 
9eec			 
9eec			 
9eec			 
9eec			 
9eec			 
9eec			 
9eec			 
9eec			 
9eec			 
9eec			findnexttok: 
9eec			 
9eec				; hl is pointer to move 
9eec				; de is the token to locate 
9eec			 
9eec					if DEBUG_FORTH 
9eec						DMARK "NTK" 
9eec						CALLMONITOR 
9eec					endif 
9eec d5				push de 
9eed			 
9eed			.fnt1:	 
9eed				; find first char of token to locate 
9eed			 
9eed 1a				ld a, (de) 
9eee 4f				ld c,a 
9eef 7e				ld a,(hl) 
9ef0 cd 47 90			call toUpper 
9ef3					if DEBUG_FORTH 
9ef3						DMARK "NT1" 
9ef3						CALLMONITOR 
9ef3					endif 
9ef3 b9				cp c 
9ef4			 
9ef4 28 03			jr z, .fnt2cmpmorefirst	 
9ef6			 
9ef6				; first char not found move to next char 
9ef6			 
9ef6 23				inc hl 
9ef7 18 f4			jr .fnt1 
9ef9			 
9ef9			.fnt2cmpmorefirst:	 
9ef9				; first char of token found.  
9ef9			 
9ef9 e5				push hl     ; save start of token just in case it is the right one 
9efa d9				exx 
9efb e1				pop hl        ; save it to hl' 
9efc d9				exx 
9efd			 
9efd			 
9efd			.fnt2cmpmore:	 
9efd				; compare the rest 
9efd				 
9efd 23				inc hl 
9efe 13				inc de 
9eff				 
9eff 1a				ld a, (de) 
9f00 4f				ld c,a 
9f01 7e				ld a,(hl) 
9f02 cd 47 90			call toUpper 
9f05			 
9f05					if DEBUG_FORTH 
9f05						DMARK "NT2" 
9f05						CALLMONITOR 
9f05					endif 
9f05				; c has the token to find char 
9f05				; a has the mem to scan char 
9f05			 
9f05 b9				cp c 
9f06 28 04			jr z,.fntmatch1 
9f08			 
9f08				; they are not the same 
9f08			 
9f08					if DEBUG_FORTH 
9f08						DMARK "NT3" 
9f08						CALLMONITOR 
9f08					endif 
9f08 d1				pop de	; reset de token to look for 
9f09 d5				push de 
9f0a 18 e1			jr .fnt1 
9f0c				 
9f0c			.fntmatch1: 
9f0c			 
9f0c				; is the same char a null which means we might have a full hit? 
9f0c					if DEBUG_FORTH 
9f0c						DMARK "NT4" 
9f0c						CALLMONITOR 
9f0c					endif 
9f0c			 
9f0c fe 00			cp 0 
9f0e 28 0b			jr z, .fntmatchyes 
9f10			 
9f10				; are we at the end of the token to find? 
9f10			 
9f10					if DEBUG_FORTH 
9f10						DMARK "NT5" 
9f10						CALLMONITOR 
9f10					endif 
9f10 3e 00			ld a, 0 
9f12 b9				cp c 
9f13			 
9f13 c2 fd 9e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9f16			 
9f16					if DEBUG_FORTH 
9f16						DMARK "NT6" 
9f16						CALLMONITOR 
9f16					endif 
9f16				; token to find is exhusted but no match to stream 
9f16			 
9f16				; restore tok pointer and continue on 
9f16 d1				pop de 
9f17 d5				push de 
9f18 c3 ed 9e			jp .fnt1 
9f1b			 
9f1b			 
9f1b			.fntmatchyes: 
9f1b			 
9f1b				; hl now contains the end of the found token 
9f1b			 
9f1b				; get rid of saved token pointer to find 
9f1b			 
9f1b d1				pop de 
9f1c			 
9f1c					if DEBUG_FORTH 
9f1c						DMARK "NT9" 
9f1c						CALLMONITOR 
9f1c					endif 
9f1c			 
9f1c				; hl will be on the null term so forward on 
9f1c			 
9f1c				; get back the saved start of the token 
9f1c			 
9f1c d9				exx 
9f1d e5				push hl     ; save start of token just in case it is the right one 
9f1e d9				exx 
9f1f e1				pop hl        ; save it to hl 
9f20			 
9f20 c9				ret 
9f21			 
9f21			 
9f21			; LIST needs to find a specific token   
9f21			; FORGET needs to find a spefici token 
9f21			 
9f21			; SAVE needs to find all tokens by flag 
9f21			; WORDS just needs to scan through all  by flag 
9f21			; UWORDS needs to scan through all by flag 
9f21			 
9f21			 
9f21			; given hl as pointer to start of dict look up string 
9f21			; return hl as pointer to start of word block 
9f21			; or 0 if not found 
9f21			 
9f21			forth_find_tok: 
9f21 c9				ret 
9f22			 
9f22			; given hl as pointer to dict structure 
9f22			; move to the next dict block structure 
9f22			 
9f22			forth_tok_next: 
9f22				; hl now points to the address of the next word pointer  
9f22				; TODO skip compiled symbol for now 
9f22			;	push de 
9f22 23				inc hl 
9f23 5e				ld e, (hl) 
9f24 23				inc hl 
9f25 56				ld d, (hl) 
9f26 23				inc hl 
9f27			 
9f27 eb				ex de,hl 
9f28			if DEBUG_FORTH_PARSE_NEXTWORD 
9f28				push bc 
9f28				ld bc, (cli_nextword) 
9f28						DMARK "NXW" 
9f28				CALLMONITOR 
9f28				pop bc 
9f28			endif 
9f28			;	pop de	 
9f28 c9				ret 
9f29			 
9f29			 
9f29			 
9f29			; eof 
# End of file forth_parserv6.asm
9f29				include "forth_wordsv4.asm" 
9f29			 
9f29			; the core word dictionary v4 
9f29			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9f29			 
9f29			; this is a linked list for each of the system words used 
9f29			; user defined words will follow the same format but will be in ram 
9f29			 
9f29			 
9f29			; 
9f29			; 
9f29			; define linked list: 
9f29			; 
9f29			; 1. compiled byte op code 
9f29			; 2. len of text word 
9f29			; 3. text word 
9f29			; 4. ptr to next dictionary word 
9f29			; 5. asm, calls etc for the word 
9f29			; 
9f29			;  if 1 == 0 then last word in dict  
9f29			;   
9f29			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9f29			;  
9f29			;  
9f29			; create basic standard set of words 
9f29			; 
9f29			;  
9f29			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9f29			; 2DUP 2DROP 2SWAP  
9f29			; @ C@ - get byte  
9f29			; ! C! - store byte 
9f29			; 0< true if less than zero 
9f29			; 0= true if zero 
9f29			; < >  
9f29			; = true if same 
9f29			; variables 
9f29			 
9f29			 
9f29			; Hardware specific words I may need 
9f29			; 
9f29			; IN OUT  
9f29			; calls to key util functions 
9f29			; calls to hardward abstraction stuff 
9f29			; easy control of frame buffers and lcd i/o 
9f29			; keyboard  
9f29			 
9f29			 
9f29			;DICT: macro 
9f29			; op_code, len, word, next 
9f29			;    word: 
9f29			;    db op_code 
9f29			;    ds word zero term 
9f29			;    dw next 
9f29			;    endm 
9f29			 
9f29			 
9f29			 
9f29			 
9f29			; op code 1 is a flag for user define words which are to be handled differently 
9f29			 
9f29			 
9f29			; 
9f29			; 
9f29			;    TODO on entry to a word this should be the expected environment 
9f29			;    hl - tos value if number then held, if string this is the ptr 
9f29			;    de -  
9f29			 
9f29			 
9f29			; opcode ranges 
9f29			; 0 - end of word dict 
9f29			; 255 - user define words 
9f29			 
9f29			sysdict: 
9f29			include "forth_opcodes.asm" 
9f29			; op codes for forth keywords 
9f29			 
9f29			; Changing use of opcodes to flag is the word exists in compiled form or not.  
9f29			; This provides a means to compile uwords if required for higher performance 
9f29			; by avoiding the use of the keyword parser and just jumping directly to the code 
9f29			; Actually there is already a flag for if the code exists as binary thinking about it... 
9f29			 
9f29			 
9f29			 
9f29			 
9f29			 
9f29			; free to use code 0  
9f29				OPCODE_HEAP: equ  1 
9f29				OPCODE_EXEC: equ 2 
9f29				OPCODE_DUP: equ 3 
9f29				OPCODE_SWAP: equ 4 
9f29				OPCODE_COLN: equ 5 
9f29				OPCODE_SCOLN: equ 6 
9f29				OPCODE_DROP: equ 7 
9f29				OPCODE_DUP2: equ 8 
9f29				OPCODE_DROP2: equ 9 
9f29				OPCODE_SWAP2: equ 10 
9f29				OPCODE_AT: equ 11 
9f29				OPCODE_CAT: equ 12 
9f29				OPCODE_BANG: equ 13 
9f29				OPCODE_CBANG: equ 14 
9f29				OPCODE_SCALL: equ 15 
9f29				OPCODE_DEPTH: equ 16 
9f29				OPCODE_OVER: equ 17 
9f29				OPCODE_PAUSE: equ 18 
9f29				OPCODE_PAUSES: equ 19 
9f29				OPCODE_ROT: equ 20 
9f29			;free to reuse	OPCODE_WORDS: equ 21 
9f29			        OPCODE_NOT: equ 21 
9f29				OPCODE_UWORDS: equ 22 
9f29				OPCODE_BP: equ 23 
9f29				OPCODE_MONITOR: equ 24  
9f29				OPCODE_MALLOC: equ 25 
9f29				OPCODE_FREE: equ 26 
9f29				OPCODE_LIST: equ 27 
9f29				OPCODE_FORGET: equ 28 
9f29				OPCODE_NOP: equ 29 
9f29				OPCODE_COMO: equ 30 
9f29				OPCODE_COMC: equ 31 
9f29			;free to reuse	OPCODE_ENDCORE: equ 32 
9f29				OPCODE_AFTERSOUND: equ 33 
9f29				OPCODE_GP2: equ 34 
9f29				OPCODE_GP3: equ 35 
9f29				OPCODE_GP4: equ 36 
9f29				OPCODE_SIN: equ 37 
9f29				OPCODE_SOUT: equ 38 
9f29				OPCODE_SPIO: equ 39 
9f29				OPCODE_SPICEH: equ 40 
9f29				OPCODE_SPIOb: equ 41 
9f29				OPCODE_SPII: equ 42 
9f29				OPCODE_SESEL: equ 43 
9f29				OPCODE_CARTDEV: equ 44 
9f29			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9f29				OPCODE_FB: equ 46 
9f29				OPCODE_EMIT: equ 47 
9f29				OPCODE_DOTH: equ 48 
9f29				OPCODE_DOTF: equ 49 
9f29				OPCODE_DOT: equ 50 
9f29				OPCODE_CLS: equ 51 
9f29				OPCODE_DRAW: equ 52 
9f29				OPCODE_DUMP: equ 53 
9f29				OPCODE_CDUMP: equ 54 
9f29				OPCODE_DAT: equ 55 
9f29				OPCODE_HOME: equ 56 
9f29				OPCODE_SPACE: equ 57 
9f29				OPCODE_SPACES: equ 58 
9f29				OPCODE_SCROLL: equ 59 
9f29				OPCODE_ATQ: equ 60 
9f29				OPCODE_AUTODSP: equ 61 
9f29				OPCODE_MENU: equ 62 
9f29			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9f29				OPCODE_THEN: equ 64 
9f29				OPCODE_ELSE: equ 65 
9f29				OPCODE_DO: equ 66 
9f29				OPCODE_LOOP: equ 67 
9f29				OPCODE_I: equ 68 
9f29				OPCODE_DLOOP: equ 69  
9f29				OPCODE_REPEAT: equ 70  
9f29				OPCODE_UNTIL: equ 71 
9f29				OPCODE_ENDFLOW: equ 72 
9f29				OPCODE_WAITK: equ 73 
9f29				OPCODE_ACCEPT: equ 74 
9f29				OPCODE_EDIT: equ 75 
9f29			;free to reuse	OPCODE_ENDKEY: equ 76 
9f29				OPCODE_LZERO: equ 77 
9f29				OPCODE_TZERO: equ 78 
9f29				OPCODE_LESS: equ 79 
9f29				OPCODE_GT: equ 80 
9f29				OPCODE_EQUAL: equ 81  
9f29			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9f29				OPCODE_NEG: equ 83 
9f29				OPCODE_DIV: equ 84 
9f29				OPCODE_MUL: equ 85 
9f29				OPCODE_MIN: equ 86 
9f29				OPCODE_MAX: equ 87 
9f29				OPCODE_RND16: equ 88 
9f29				OPCODE_RND8: equ 89 
9f29				OPCODE_RND: equ 90 
9f29			;free to reuse	OPCODE_ENDMATHS: equ 91  
9f29				OPCODE_BYNAME: equ 92 
9f29				OPCODE_DIR: equ 93 
9f29				OPCODE_SAVE: equ 94 
9f29				OPCODE_LOAD: equ 95 
9f29				OPCODE_BSAVE: equ 96 
9f29				OPCODE_BLOAD: equ 97 
9f29				OPCODE_SEO: equ 98  
9f29				OPCODE_SEI: equ 99 
9f29				OPCODE_SFREE: equ 100 
9f29				OPCODE_SIZE: equ 101 
9f29				OPCODE_CREATE: equ 102 
9f29				OPCODE_APPEND: equ 103 
9f29				OPCODE_SDEL: equ 104 
9f29				OPCODE_OPEN: equ 105 
9f29				OPCODE_READ: equ 106 
9f29				OPCODE_EOF: equ 106 
9f29				OPCODE_FORMAT: equ 107 
9f29				OPCODE_LABEL: equ 108 
9f29				OPCODE_LABELS: equ 109 
9f29			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9f29				OPCODE_UPPER: equ 111 
9f29				OPCODE_LOWER: equ 112 
9f29				OPCODE_SUBSTR: equ 113 
9f29				OPCODE_LEFT: equ 114 
9f29				OPCODE_RIGHT: equ 115 
9f29				OPCODE_STR2NUM: equ 116 
9f29				OPCODE_NUM2STR: equ 117 
9f29				OPCODE_CONCAT: equ 118 
9f29				OPCODE_FIND: equ 119 
9f29				OPCODE_LEN: equ 120 
9f29				OPCODE_CHAR: equ 121 
9f29			; free to reuse	OPCODE_STRLEN: equ 122 
9f29			; free to reuse	OPCODE_ENDSTR: equ 123 
9f29				OPCODE_V0S: equ 124 
9f29				OPCODE_V0Q: equ 125 
9f29				OPCODE_V1S: equ 126 
9f29				OPCODE_V1Q: equ 127 
9f29				OPCODE_V2S: equ 128 
9f29				OPCODE_V2Q: equ 129 
9f29				OPCODE_V3S: equ 130 
9f29				OPCODE_V3Q: equ 131 
9f29			;free to reuse	OPCODE_END: equ 132 
9f29				OPCODE_ZDUP: equ 133 
9f29			 
9f29			; eof 
# End of file forth_opcodes.asm
9f29			 
9f29			include "forth_words_core.asm" 
9f29			 
9f29			; | ## Core Words 
9f29			 
9f29			;if MALLOC_4 
9f29			 
9f29			.HEAP: 
9f29			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9f29 15				db WORD_SYS_CORE+OPCODE_HEAP             
9f2a 6b 9f			dw .EXEC            
9f2c 05				db 4 + 1 
9f2d .. 00			db "HEAP",0              
9f32				endm 
# End of macro CWHEAD
9f32			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9f32			; | | u1 - Current number of bytes in the heap 
9f32			; | | u2 - Remaining bytes left on the heap 
9f32			; | |  
9f32			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9f32			 
9f32			 
9f32				if DEBUG_FORTH_WORDS_KEY 
9f32					DMARK "HEP" 
9f32 f5				push af  
9f33 3a 47 9f			ld a, (.dmark)  
9f36 32 62 ee			ld (debug_mark),a  
9f39 3a 48 9f			ld a, (.dmark+1)  
9f3c 32 63 ee			ld (debug_mark+1),a  
9f3f 3a 49 9f			ld a, (.dmark+2)  
9f42 32 64 ee			ld (debug_mark+2),a  
9f45 18 03			jr .pastdmark  
9f47 ..			.dmark: db "HEP"  
9f4a f1			.pastdmark: pop af  
9f4b			endm  
# End of macro DMARK
9f4b					CALLMONITOR 
9f4b cd 6f ee			call debug_vector  
9f4e				endm  
# End of macro CALLMONITOR
9f4e				endif 
9f4e 2a fa e3			ld hl, (free_list )      
9f51 11 ff e3			ld de, heap_start 
9f54			 
9f54 ed 52			sbc hl, de  
9f56			 
9f56 cd f5 99			call forth_push_numhl 
9f59			 
9f59			 
9f59 ed 5b fa e3		ld de, (free_list )      
9f5d 21 93 e2			ld hl, heap_end 
9f60			 
9f60 ed 52			sbc hl, de 
9f62			 
9f62 cd f5 99			call forth_push_numhl 
9f65				 
9f65			 
9f65				 
9f65			 
9f65			 
9f65			 
9f65				NEXTW 
9f65 cd 6c ee			call parse_vector 
9f68 c3 e5 9d			jp macro_next 
9f6b				endm 
# End of macro NEXTW
9f6b			;endif 
9f6b			 
9f6b			.EXEC: 
9f6b			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9f6b			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9f6b			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9f6b			;; > > 
9f6b			;; > >   
9f6b			;	STACKFRAME OFF $5efe $5f9f 
9f6b			; 
9f6b			;		if DEBUG_FORTH_WORDS_KEY 
9f6b			;			DMARK "EXE" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			; 
9f6b			;	FORTH_DSP_VALUEHL 
9f6b			; 
9f6b			;	FORTH_DSP_POP 
9f6b			; 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EX1" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			;;	ld e,(hl) 
9f6b			;;	inc hl 
9f6b			;;	ld d,(hl) 
9f6b			;;	ex de,hl 
9f6b			; 
9f6b			;;		if DEBUG_FORTH_WORDS 
9f6b			;;			DMARK "EX2" 
9f6b			;;			CALLMONITOR 
9f6b			;;		endif 
9f6b			;	push hl 
9f6b			; 
9f6b			;	;ld a, 0 
9f6b			;	;ld a, FORTH_END_BUFFER 
9f6b			;	call strlenz 
9f6b			;	inc hl   ; include zero term to copy 
9f6b			;	inc hl   ; include term 
9f6b			;	inc hl   ; include term 
9f6b			;	ld b,0 
9f6b			;	ld c,l 
9f6b			;	pop hl 
9f6b			;	ld de, execscratch 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EX3" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			;	ldir 
9f6b			; 
9f6b			; 
9f6b			;	ld hl, execscratch 
9f6b			; 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EXe" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			; 
9f6b			;	call forthparse 
9f6b			;	call forthexec 
9f6b			;;	call forthexec_cleanup 
9f6b			;;	call forthparse 
9f6b			;;	call forthexec 
9f6b			; 
9f6b			;	STACKFRAMECHK OFF $5efe $5f9f 
9f6b			; 
9f6b			;	; an immediate word so no need to process any more words 
9f6b			;	ret 
9f6b			;	NEXTW 
9f6b			 
9f6b			; dead code - old version  
9f6b			;	FORTH_RSP_NEXT 
9f6b			 
9f6b			;  
9f6b			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9f6b			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9f6b			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f6b			;	push hl 
9f6b			;	push de 
9f6b			;	push bc 
9f6b			; 
9f6b			; 
9f6b			;		if DEBUG_FORTH_WORDS_KEY 
9f6b			;			DMARK "EXR" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			; 
9f6b			; 
9f6b			; 
9f6b			;	;v5 FORTH_DSP_VALUE 
9f6b			;	FORTH_DSP_VALUEHL 
9f6b			; 
9f6b			;	; TODO do string type checks 
9f6b			; 
9f6b			;;v5	inc hl   ; skip type 
9f6b			; 
9f6b			;	push hl  ; source code  
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EX1" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			;	ld a, 0 
9f6b			;	call strlent 
9f6b			; 
9f6b			;	inc hl 
9f6b			;	inc hl 
9f6b			;	inc hl 
9f6b			;	inc hl 
9f6b			; 
9f6b			;	push hl    ; size 
9f6b			; 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EX2" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			;	call malloc 
9f6b			; 
9f6b			;	ex de, hl    ; de now contains malloc area 
9f6b			;	pop bc   	; get byte count 
9f6b			;	pop hl      ; get string to copy 
9f6b			; 
9f6b			;	push de     ; save malloc for free later 
9f6b			; 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EX3" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			;	ldir       ; duplicate string 
9f6b			; 
9f6b			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9f6b			;	 
9f6b			;	; TODO fix the parse would be better than this...  
9f6b			;	ex de, hl 
9f6b			;	dec hl 
9f6b			;	ld a, 0 
9f6b			;	ld (hl), a 
9f6b			;	dec hl 
9f6b			;	ld a, ' ' 
9f6b			;	ld (hl), a 
9f6b			;	dec hl 
9f6b			;	ld (hl), a 
9f6b			; 
9f6b			;	dec hl 
9f6b			;	ld (hl), a 
9f6b			; 
9f6b			; 
9f6b			;	FORTH_DSP_POP  
9f6b			; 
9f6b			;	pop hl     
9f6b			;	push hl    ; save malloc area 
9f6b			; 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EX4" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			; 
9f6b			;	call forthparse 
9f6b			;	call forthexec 
9f6b			;	 
9f6b			;	pop hl 
9f6b			;	if DEBUG_FORTH_WORDS 
9f6b			;		DMARK "EX5" 
9f6b			;		CALLMONITOR 
9f6b			;	endif 
9f6b			; 
9f6b			;	if FORTH_ENABLE_FREE 
9f6b			;	call free 
9f6b			;	endif 
9f6b			; 
9f6b			;	if DEBUG_FORTH_WORDS 
9f6b			;		DMARK "EX6" 
9f6b			;		CALLMONITOR 
9f6b			;	endif 
9f6b			; 
9f6b			;	pop bc 
9f6b			;	pop de 
9f6b			;	pop hl 
9f6b			;;	FORTH_RSP_POP	  
9f6b			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9f6b			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9f6b			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9f6b			; 
9f6b			;	if DEBUG_FORTH_WORDS 
9f6b			;		DMARK "EX7" 
9f6b			;		CALLMONITOR 
9f6b			;	endif 
9f6b			;	NEXTW 
9f6b			 
9f6b			;.STKEXEC: 
9f6b			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9f6b			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9f6b			; 
9f6b			; 
9f6b			;		if DEBUG_FORTH_WORDS_KEY 
9f6b			;			DMARK "STX" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			; 
9f6b			;	FORTH_DSP_VALUEHL 
9f6b			; 
9f6b			;	ld (store_tmp1), hl    ; count 
9f6b			; 
9f6b			;	FORTH_DSP_POP 
9f6b			;.stkexec1: 
9f6b			;	ld hl, (store_tmp1)   ; count 
9f6b			;	ld a, 0 
9f6b			;	cp l 
9f6b			;	ret z 
9f6b			; 
9f6b			;	dec hl 
9f6b			;	ld (store_tmp1), hl    ; count 
9f6b			;	 
9f6b			;	FORTH_DSP_VALUEHL 
9f6b			;	push hl 
9f6b			;	 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EXp" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			;	FORTH_DSP_POP 
9f6b			; 
9f6b			;	call strlenz 
9f6b			;	inc hl   ; include zero term to copy 
9f6b			;	inc hl   ; include zero term to copy 
9f6b			;	inc hl   ; include zero term to copy 
9f6b			;	ld b,0 
9f6b			;	ld c,l 
9f6b			;	pop hl 
9f6b			;	ld de, execscratch 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EX3" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			;	ldir 
9f6b			; 
9f6b			; 
9f6b			;	ld hl, execscratch 
9f6b			; 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EXP" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			; 
9f6b			;	call forthparse 
9f6b			;	ld hl, execscratch 
9f6b			;		if DEBUG_FORTH_WORDS 
9f6b			;			DMARK "EXx" 
9f6b			;			CALLMONITOR 
9f6b			;		endif 
9f6b			;	call forthexec 
9f6b			; 
9f6b			;	jp .stkexec1 
9f6b			; 
9f6b			;	ret 
9f6b			 
9f6b			 
9f6b			.DUP: 
9f6b			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9f6b 17				db WORD_SYS_CORE+OPCODE_DUP             
9f6c e7 9f			dw .ZDUP            
9f6e 04				db 3 + 1 
9f6f .. 00			db "DUP",0              
9f73				endm 
# End of macro CWHEAD
9f73			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9f73			 
9f73				if DEBUG_FORTH_WORDS_KEY 
9f73					DMARK "DUP" 
9f73 f5				push af  
9f74 3a 88 9f			ld a, (.dmark)  
9f77 32 62 ee			ld (debug_mark),a  
9f7a 3a 89 9f			ld a, (.dmark+1)  
9f7d 32 63 ee			ld (debug_mark+1),a  
9f80 3a 8a 9f			ld a, (.dmark+2)  
9f83 32 64 ee			ld (debug_mark+2),a  
9f86 18 03			jr .pastdmark  
9f88 ..			.dmark: db "DUP"  
9f8b f1			.pastdmark: pop af  
9f8c			endm  
# End of macro DMARK
9f8c					CALLMONITOR 
9f8c cd 6f ee			call debug_vector  
9f8f				endm  
# End of macro CALLMONITOR
9f8f				endif 
9f8f			 
9f8f				FORTH_DSP 
9f8f cd c0 9b			call macro_forth_dsp 
9f92				endm 
# End of macro FORTH_DSP
9f92			 
9f92 7e				ld a, (HL) 
9f93 fe 01			cp DS_TYPE_STR 
9f95 20 28			jr nz, .dupinum 
9f97			 
9f97				; push another string 
9f97			 
9f97				FORTH_DSP_VALUEHL     		 
9f97 cd fa 9b			call macro_dsp_valuehl 
9f9a				endm 
# End of macro FORTH_DSP_VALUEHL
9f9a			 
9f9a			if DEBUG_FORTH_WORDS 
9f9a				DMARK "DUs" 
9f9a f5				push af  
9f9b 3a af 9f			ld a, (.dmark)  
9f9e 32 62 ee			ld (debug_mark),a  
9fa1 3a b0 9f			ld a, (.dmark+1)  
9fa4 32 63 ee			ld (debug_mark+1),a  
9fa7 3a b1 9f			ld a, (.dmark+2)  
9faa 32 64 ee			ld (debug_mark+2),a  
9fad 18 03			jr .pastdmark  
9faf ..			.dmark: db "DUs"  
9fb2 f1			.pastdmark: pop af  
9fb3			endm  
# End of macro DMARK
9fb3				CALLMONITOR 
9fb3 cd 6f ee			call debug_vector  
9fb6				endm  
# End of macro CALLMONITOR
9fb6			endif 
9fb6 cd 63 9a			call forth_push_str 
9fb9			 
9fb9				NEXTW 
9fb9 cd 6c ee			call parse_vector 
9fbc c3 e5 9d			jp macro_next 
9fbf				endm 
# End of macro NEXTW
9fbf			 
9fbf			 
9fbf			.dupinum: 
9fbf				 
9fbf			 
9fbf			 
9fbf				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9fbf cd fa 9b			call macro_dsp_valuehl 
9fc2				endm 
# End of macro FORTH_DSP_VALUEHL
9fc2			 
9fc2			; TODO add floating point number detection 
9fc2			 
9fc2			if DEBUG_FORTH_WORDS 
9fc2				DMARK "DUi" 
9fc2 f5				push af  
9fc3 3a d7 9f			ld a, (.dmark)  
9fc6 32 62 ee			ld (debug_mark),a  
9fc9 3a d8 9f			ld a, (.dmark+1)  
9fcc 32 63 ee			ld (debug_mark+1),a  
9fcf 3a d9 9f			ld a, (.dmark+2)  
9fd2 32 64 ee			ld (debug_mark+2),a  
9fd5 18 03			jr .pastdmark  
9fd7 ..			.dmark: db "DUi"  
9fda f1			.pastdmark: pop af  
9fdb			endm  
# End of macro DMARK
9fdb				CALLMONITOR 
9fdb cd 6f ee			call debug_vector  
9fde				endm  
# End of macro CALLMONITOR
9fde			endif 
9fde			 
9fde cd f5 99			call forth_push_numhl 
9fe1				NEXTW 
9fe1 cd 6c ee			call parse_vector 
9fe4 c3 e5 9d			jp macro_next 
9fe7				endm 
# End of macro NEXTW
9fe7			.ZDUP: 
9fe7			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9fe7 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9fe8 22 a0			dw .DMRK            
9fea 05				db 4 + 1 
9feb .. 00			db "?DUP",0              
9ff0				endm 
# End of macro CWHEAD
9ff0			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
9ff0			 
9ff0				if DEBUG_FORTH_WORDS_KEY 
9ff0					DMARK "qDU" 
9ff0 f5				push af  
9ff1 3a 05 a0			ld a, (.dmark)  
9ff4 32 62 ee			ld (debug_mark),a  
9ff7 3a 06 a0			ld a, (.dmark+1)  
9ffa 32 63 ee			ld (debug_mark+1),a  
9ffd 3a 07 a0			ld a, (.dmark+2)  
a000 32 64 ee			ld (debug_mark+2),a  
a003 18 03			jr .pastdmark  
a005 ..			.dmark: db "qDU"  
a008 f1			.pastdmark: pop af  
a009			endm  
# End of macro DMARK
a009					CALLMONITOR 
a009 cd 6f ee			call debug_vector  
a00c				endm  
# End of macro CALLMONITOR
a00c				endif 
a00c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a00c cd fa 9b			call macro_dsp_valuehl 
a00f				endm 
# End of macro FORTH_DSP_VALUEHL
a00f			 
a00f e5				push hl 
a010			 
a010				; is it a zero? 
a010			 
a010 3e 00			ld a, 0 
a012 84				add h 
a013 85				add l 
a014			 
a014 e1				pop hl 
a015			 
a015 fe 00			cp 0 
a017 28 03			jr z, .dup2orig 
a019			 
a019			 
a019 cd f5 99			call forth_push_numhl 
a01c			 
a01c			 
a01c			; TODO add floating point number detection 
a01c			 
a01c			.dup2orig: 
a01c			 
a01c				NEXTW 
a01c cd 6c ee			call parse_vector 
a01f c3 e5 9d			jp macro_next 
a022				endm 
# End of macro NEXTW
a022			.DMRK: 
a022			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
a022 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a023 62 a0			dw .LSHIFT            
a025 06				db 5 + 1 
a026 .. 00			db "DMARK",0              
a02c				endm 
# End of macro CWHEAD
a02c			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
a02c			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
a02c				if DEBUG_FORTH_WORDS_KEY 
a02c					DMARK "DMK" 
a02c f5				push af  
a02d 3a 41 a0			ld a, (.dmark)  
a030 32 62 ee			ld (debug_mark),a  
a033 3a 42 a0			ld a, (.dmark+1)  
a036 32 63 ee			ld (debug_mark+1),a  
a039 3a 43 a0			ld a, (.dmark+2)  
a03c 32 64 ee			ld (debug_mark+2),a  
a03f 18 03			jr .pastdmark  
a041 ..			.dmark: db "DMK"  
a044 f1			.pastdmark: pop af  
a045			endm  
# End of macro DMARK
a045					CALLMONITOR 
a045 cd 6f ee			call debug_vector  
a048				endm  
# End of macro CALLMONITOR
a048				endif 
a048				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a048 cd fa 9b			call macro_dsp_valuehl 
a04b				endm 
# End of macro FORTH_DSP_VALUEHL
a04b			 
a04b 7e				ld a, (hl) 
a04c 32 62 ee			ld (debug_mark),a 
a04f 23				inc hl 
a050 7e				ld a, (hl) 
a051 32 63 ee			ld (debug_mark+1),a 
a054 23				inc hl 
a055 7e				ld a, (hl) 
a056 32 64 ee			ld (debug_mark+2),a 
a059			 
a059			 
a059				FORTH_DSP_POP 
a059 cd b2 9c			call macro_forth_dsp_pop 
a05c				endm 
# End of macro FORTH_DSP_POP
a05c				NEXTW 
a05c cd 6c ee			call parse_vector 
a05f c3 e5 9d			jp macro_next 
a062				endm 
# End of macro NEXTW
a062			.LSHIFT: 
a062			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
a062 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a063 99 a0			dw .RSHIFT            
a065 07				db 6 + 1 
a066 .. 00			db "LSHIFT",0              
a06d				endm 
# End of macro CWHEAD
a06d			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
a06d				if DEBUG_FORTH_WORDS_KEY 
a06d					DMARK "LSH" 
a06d f5				push af  
a06e 3a 82 a0			ld a, (.dmark)  
a071 32 62 ee			ld (debug_mark),a  
a074 3a 83 a0			ld a, (.dmark+1)  
a077 32 63 ee			ld (debug_mark+1),a  
a07a 3a 84 a0			ld a, (.dmark+2)  
a07d 32 64 ee			ld (debug_mark+2),a  
a080 18 03			jr .pastdmark  
a082 ..			.dmark: db "LSH"  
a085 f1			.pastdmark: pop af  
a086			endm  
# End of macro DMARK
a086					CALLMONITOR 
a086 cd 6f ee			call debug_vector  
a089				endm  
# End of macro CALLMONITOR
a089				endif 
a089				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a089 cd fa 9b			call macro_dsp_valuehl 
a08c				endm 
# End of macro FORTH_DSP_VALUEHL
a08c				FORTH_DSP_POP 
a08c cd b2 9c			call macro_forth_dsp_pop 
a08f				endm 
# End of macro FORTH_DSP_POP
a08f			 
a08f 29				add hl, hl 
a090 cd f5 99			call forth_push_numhl 
a093				NEXTW 
a093 cd 6c ee			call parse_vector 
a096 c3 e5 9d			jp macro_next 
a099				endm 
# End of macro NEXTW
a099			.RSHIFT: 
a099			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
a099 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a09a d3 a0			dw .SWAP            
a09c 07				db 6 + 1 
a09d .. 00			db "RSHIFT",0              
a0a4				endm 
# End of macro CWHEAD
a0a4			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
a0a4				if DEBUG_FORTH_WORDS_KEY 
a0a4					DMARK "RSH" 
a0a4 f5				push af  
a0a5 3a b9 a0			ld a, (.dmark)  
a0a8 32 62 ee			ld (debug_mark),a  
a0ab 3a ba a0			ld a, (.dmark+1)  
a0ae 32 63 ee			ld (debug_mark+1),a  
a0b1 3a bb a0			ld a, (.dmark+2)  
a0b4 32 64 ee			ld (debug_mark+2),a  
a0b7 18 03			jr .pastdmark  
a0b9 ..			.dmark: db "RSH"  
a0bc f1			.pastdmark: pop af  
a0bd			endm  
# End of macro DMARK
a0bd					CALLMONITOR 
a0bd cd 6f ee			call debug_vector  
a0c0				endm  
# End of macro CALLMONITOR
a0c0				endif 
a0c0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0c0 cd fa 9b			call macro_dsp_valuehl 
a0c3				endm 
# End of macro FORTH_DSP_VALUEHL
a0c3				FORTH_DSP_POP 
a0c3 cd b2 9c			call macro_forth_dsp_pop 
a0c6				endm 
# End of macro FORTH_DSP_POP
a0c6 cb 3c			srl h 
a0c8 cb 1d			rr l 
a0ca cd f5 99			call forth_push_numhl 
a0cd				NEXTW 
a0cd cd 6c ee			call parse_vector 
a0d0 c3 e5 9d			jp macro_next 
a0d3				endm 
# End of macro NEXTW
a0d3			.SWAP: 
a0d3			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a0d3 18				db WORD_SYS_CORE+OPCODE_SWAP             
a0d4 2a a1			dw .COLN            
a0d6 05				db 4 + 1 
a0d7 .. 00			db "SWAP",0              
a0dc				endm 
# End of macro CWHEAD
a0dc			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a0dc				if DEBUG_FORTH_WORDS_KEY 
a0dc					DMARK "SWP" 
a0dc f5				push af  
a0dd 3a f1 a0			ld a, (.dmark)  
a0e0 32 62 ee			ld (debug_mark),a  
a0e3 3a f2 a0			ld a, (.dmark+1)  
a0e6 32 63 ee			ld (debug_mark+1),a  
a0e9 3a f3 a0			ld a, (.dmark+2)  
a0ec 32 64 ee			ld (debug_mark+2),a  
a0ef 18 03			jr .pastdmark  
a0f1 ..			.dmark: db "SWP"  
a0f4 f1			.pastdmark: pop af  
a0f5			endm  
# End of macro DMARK
a0f5					CALLMONITOR 
a0f5 cd 6f ee			call debug_vector  
a0f8				endm  
# End of macro CALLMONITOR
a0f8				endif 
a0f8			 
a0f8			; DONE Use os stack swap memory 
a0f8			 
a0f8				FORTH_DSP_PTR 0     ; TOS 
a0f8 2a e5 e9			ld hl,(cli_data_sp) 
a0fb 11 00 00			ld de, 0 * 3 
a0fe ed 52			sbc hl, de 
a100				endm 
# End of macro FORTH_DSP_PTR
a100 cd 31 9d			call hltostack1 
a103			  
a103				FORTH_DSP_PTR 1     ; TOS 
a103 2a e5 e9			ld hl,(cli_data_sp) 
a106 11 03 00			ld de, 1 * 3 
a109 ed 52			sbc hl, de 
a10b				endm 
# End of macro FORTH_DSP_PTR
a10b cd 37 9d			call hltostack2 
a10e			 
a10e				FORTH_DSP_PTR 0     ; TOS 
a10e 2a e5 e9			ld hl,(cli_data_sp) 
a111 11 00 00			ld de, 0 * 3 
a114 ed 52			sbc hl, de 
a116				endm 
# End of macro FORTH_DSP_PTR
a116 cd 4f 9d			call hlfromstack2 
a119			 
a119				FORTH_DSP_PTR 1     ; TOS 
a119 2a e5 e9			ld hl,(cli_data_sp) 
a11c 11 03 00			ld de, 1 * 3 
a11f ed 52			sbc hl, de 
a121				endm 
# End of macro FORTH_DSP_PTR
a121 cd 49 9d			call hlfromstack1 
a124			;	FORTH_DSP_VALUEHL 
a124			;	push hl     ; w2 
a124			; 
a124			;	FORTH_DSP_POP 
a124			; 
a124			;	FORTH_DSP_VALUEHL 
a124			; 
a124			;	FORTH_DSP_POP 
a124			; 
a124			;	pop de     ; w2	, hl = w1 
a124			; 
a124			;	ex de, hl 
a124			;	push de 
a124			; 
a124			;	call forth_push_numhl 
a124			; 
a124			;	pop hl 
a124			; 
a124			;	call forth_push_numhl 
a124				 
a124			 
a124				NEXTW 
a124 cd 6c ee			call parse_vector 
a127 c3 e5 9d			jp macro_next 
a12a				endm 
# End of macro NEXTW
a12a			.COLN: 
a12a			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a12a 19				db WORD_SYS_CORE+OPCODE_COLN             
a12b b6 a2			dw .SCOLN            
a12d 02				db 1 + 1 
a12e .. 00			db ":",0              
a130				endm 
# End of macro CWHEAD
a130			; | : ( -- )         Create new word | DONE 
a130			 
a130				if DEBUG_FORTH_WORDS_KEY 
a130					DMARK "CLN" 
a130 f5				push af  
a131 3a 45 a1			ld a, (.dmark)  
a134 32 62 ee			ld (debug_mark),a  
a137 3a 46 a1			ld a, (.dmark+1)  
a13a 32 63 ee			ld (debug_mark+1),a  
a13d 3a 47 a1			ld a, (.dmark+2)  
a140 32 64 ee			ld (debug_mark+2),a  
a143 18 03			jr .pastdmark  
a145 ..			.dmark: db "CLN"  
a148 f1			.pastdmark: pop af  
a149			endm  
# End of macro DMARK
a149					CALLMONITOR 
a149 cd 6f ee			call debug_vector  
a14c				endm  
# End of macro CALLMONITOR
a14c				endif 
a14c			STACKFRAME OFF $8efe $989f 
a14c				if DEBUG_STACK_IMB 
a14c					if OFF 
a14c						exx 
a14c						ld de, $8efe 
a14c						ld a, d 
a14c						ld hl, curframe 
a14c						call hexout 
a14c						ld a, e 
a14c						ld hl, curframe+2 
a14c						call hexout 
a14c						ld hl, $8efe 
a14c						push hl 
a14c						ld hl, $989f 
a14c						push hl 
a14c						exx 
a14c					endif 
a14c				endif 
a14c			endm 
# End of macro STACKFRAME
a14c			; get parser buffer length  of new word 
a14c			 
a14c			 
a14c			 
a14c				; move tok past this to start of name defintition 
a14c				; TODO get word to define 
a14c				; TODO Move past word token 
a14c				; TODO get length of string up to the ';' 
a14c			 
a14c 2a b9 e5		ld hl, (os_tok_ptr) 
a14f 23			inc hl 
a150 23			inc hl 
a151			 
a151 3e 3b		ld a, ';' 
a153 cd 5b 90		call strlent 
a156			 
a156 7d			ld a,l 
a157 32 a8 e2		ld (os_new_parse_len), a 
a15a			 
a15a			 
a15a			if DEBUG_FORTH_UWORD 
a15a ed 5b b9 e5	ld de, (os_tok_ptr) 
a15e					DMARK ":01" 
a15e f5				push af  
a15f 3a 73 a1			ld a, (.dmark)  
a162 32 62 ee			ld (debug_mark),a  
a165 3a 74 a1			ld a, (.dmark+1)  
a168 32 63 ee			ld (debug_mark+1),a  
a16b 3a 75 a1			ld a, (.dmark+2)  
a16e 32 64 ee			ld (debug_mark+2),a  
a171 18 03			jr .pastdmark  
a173 ..			.dmark: db ":01"  
a176 f1			.pastdmark: pop af  
a177			endm  
# End of macro DMARK
a177			CALLMONITOR 
a177 cd 6f ee			call debug_vector  
a17a				endm  
# End of macro CALLMONITOR
a17a			endif 
a17a			 
a17a			; 
a17a			;  new word memory layout: 
a17a			;  
a17a			;    : adg 6666 ;  
a17a			; 
a17a			;    db   1     ; user defined word  
a17a 23			inc hl    
a17b			;    dw   sysdict 
a17b 23			inc hl 
a17c 23			inc hl 
a17d			;    db <word len>+1 (for null) 
a17d 23			inc hl 
a17e			;    db .... <word> 
a17e			; 
a17e			 
a17e 23			inc hl    ; some extras for the word preamble before the above 
a17f 23			inc hl 
a180 23			inc hl 
a181 23			inc hl 
a182 23			inc hl 
a183 23			inc hl 
a184 23			inc hl  
a185 23			inc hl 
a186 23			inc hl 
a187 23			inc hl 
a188 23			inc hl 
a189 23			inc hl 
a18a 23			inc hl 
a18b 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a18c			;       exec word buffer 
a18c			;	<ptr word>   
a18c 23			inc hl 
a18d 23			inc hl 
a18e			;       <word list><null term> 7F final term 
a18e			 
a18e			 
a18e			if DEBUG_FORTH_UWORD 
a18e					DMARK ":02" 
a18e f5				push af  
a18f 3a a3 a1			ld a, (.dmark)  
a192 32 62 ee			ld (debug_mark),a  
a195 3a a4 a1			ld a, (.dmark+1)  
a198 32 63 ee			ld (debug_mark+1),a  
a19b 3a a5 a1			ld a, (.dmark+2)  
a19e 32 64 ee			ld (debug_mark+2),a  
a1a1 18 03			jr .pastdmark  
a1a3 ..			.dmark: db ":02"  
a1a6 f1			.pastdmark: pop af  
a1a7			endm  
# End of macro DMARK
a1a7			CALLMONITOR 
a1a7 cd 6f ee			call debug_vector  
a1aa				endm  
# End of macro CALLMONITOR
a1aa			endif 
a1aa			 
a1aa			 
a1aa				; malloc the size 
a1aa			 
a1aa cd c5 90			call malloc 
a1ad 22 aa e2			ld (os_new_malloc), hl     ; save malloc start 
a1b0			 
a1b0			;    db   1     ; user defined word  
a1b0 3e 01			ld a, WORD_SYS_UWORD  
a1b2 77				ld (hl), a 
a1b3			 
a1b3 23			inc hl    
a1b4			;    dw   sysdict 
a1b4 11 29 9f		ld de, sysdict       ; continue on with the scan to the system dict 
a1b7 73			ld (hl), e 
a1b8 23			inc hl 
a1b9 72			ld (hl), d 
a1ba 23			inc hl 
a1bb			 
a1bb			 
a1bb			;    Setup dict word 
a1bb			 
a1bb 23			inc hl 
a1bc 22 a4 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a1bf			 
a1bf			; 1. get length of dict word 
a1bf			 
a1bf			 
a1bf 2a b9 e5		ld hl, (os_tok_ptr) 
a1c2 23			inc hl 
a1c3 23			inc hl    ; position to start of dict word 
a1c4 3e 00		ld a, 0 
a1c6 cd 5b 90		call strlent 
a1c9			 
a1c9			 
a1c9 23			inc hl    ; to include null??? 
a1ca			 
a1ca			; write length of dict word 
a1ca			 
a1ca ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1ce 1b			dec de 
a1cf eb			ex de, hl 
a1d0 73			ld (hl), e 
a1d1 eb			ex de, hl 
a1d2			 
a1d2			 
a1d2			 
a1d2			; copy  
a1d2 4d			ld c, l 
a1d3 06 00		ld b, 0 
a1d5 ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1d9 2a b9 e5		ld hl, (os_tok_ptr) 
a1dc 23			inc hl 
a1dd 23			inc hl    ; position to start of dict word 
a1de			 
a1de			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a1de			 
a1de			; TODO need to convert word to upper case 
a1de			 
a1de			ucasetok:	 
a1de 7e			ld a,(hl) 
a1df cd 47 90		call toUpper 
a1e2 77			ld (hl),a 
a1e3 ed a0		ldi 
a1e5 f2 de a1		jp p, ucasetok 
a1e8			 
a1e8			 
a1e8			 
a1e8			; de now points to start of where the word body code should be placed 
a1e8 ed 53 a4 e2	ld (os_new_work_ptr), de 
a1ec			; hl now points to the words to throw at forthexec which needs to be copied 
a1ec 22 a2 e2		ld (os_new_src_ptr), hl 
a1ef			 
a1ef			; TODO add 'call to forthexec' 
a1ef			 
a1ef			if DEBUG_FORTH_UWORD 
a1ef c5			push bc 
a1f0 ed 4b aa e2	ld bc, (os_new_malloc) 
a1f4					DMARK ":0x" 
a1f4 f5				push af  
a1f5 3a 09 a2			ld a, (.dmark)  
a1f8 32 62 ee			ld (debug_mark),a  
a1fb 3a 0a a2			ld a, (.dmark+1)  
a1fe 32 63 ee			ld (debug_mark+1),a  
a201 3a 0b a2			ld a, (.dmark+2)  
a204 32 64 ee			ld (debug_mark+2),a  
a207 18 03			jr .pastdmark  
a209 ..			.dmark: db ":0x"  
a20c f1			.pastdmark: pop af  
a20d			endm  
# End of macro DMARK
a20d			CALLMONITOR 
a20d cd 6f ee			call debug_vector  
a210				endm  
# End of macro CALLMONITOR
a210 c1			pop bc 
a211			endif 
a211			 
a211			 
a211			; create word preamble which should be: 
a211			 
a211			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a211			 
a211			;    ld hl, <word code> 
a211			;    jp user_exec 
a211			;    <word code bytes> 
a211			 
a211			 
a211			;	inc de     ; TODO ??? or are we already past the word's null 
a211 eb			ex de, hl 
a212			 
a212 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a214			 
a214 23			inc hl 
a215 22 9e e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a218 23			inc hl 
a219			 
a219 23			inc hl 
a21a 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a21c			 
a21c 01 cc d1		ld bc, user_exec 
a21f 23			inc hl 
a220 71			ld (hl), c     ; poke address of user_exec 
a221 23			inc hl 
a222 70			ld (hl), b     
a223			; 
a223			;	inc hl 
a223			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a223			; 
a223			; 
a223			;	ld bc, macro_forth_rsp_next 
a223			;	inc hl 
a223			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a223			;	inc hl 
a223			;	ld (hl), b     
a223			; 
a223			;	inc hl 
a223			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a223			; 
a223			; 
a223			;	inc hl 
a223			;	ld bc, forthexec 
a223			;	ld (hl), c     ; poke address of forthexec 
a223			;	inc hl 
a223			;	ld (hl), b      
a223			; 
a223			;	inc hl 
a223			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a223			; 
a223			;	ld bc, user_dict_next 
a223			;	inc hl 
a223			;	ld (hl), c     ; poke address of forthexec 
a223			;	inc hl 
a223			;	ld (hl), b      
a223			 
a223			; hl is now where we need to copy the word byte data to save this 
a223			 
a223 23			inc hl 
a224 22 a0 e2		ld (os_new_exec), hl 
a227			 
a227			; copy definition 
a227			 
a227 eb			ex de, hl 
a228			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a228			;	inc de    ; skip the PC for this parse 
a228 3a a8 e2		ld a, (os_new_parse_len) 
a22b 4f			ld c, a 
a22c 06 00		ld b, 0 
a22e ed b0		ldir		 ; copy defintion 
a230			 
a230			 
a230			; poke the address of where the new word bytes live for forthexec 
a230			 
a230 2a 9e e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a233			 
a233 ed 5b a0 e2	ld de, (os_new_exec)      
a237			 
a237 73			ld (hl), e 
a238 23			inc hl 
a239 72			ld (hl), d 
a23a			 
a23a				; TODO copy last user dict word next link to this word 
a23a				; TODO update last user dict word to point to this word 
a23a			; 
a23a			; hl f923 de 812a ; bc 811a 
a23a			 
a23a			if DEBUG_FORTH_UWORD 
a23a c5			push bc 
a23b ed 4b aa e2	ld bc, (os_new_malloc) 
a23f					DMARK ":0A" 
a23f f5				push af  
a240 3a 54 a2			ld a, (.dmark)  
a243 32 62 ee			ld (debug_mark),a  
a246 3a 55 a2			ld a, (.dmark+1)  
a249 32 63 ee			ld (debug_mark+1),a  
a24c 3a 56 a2			ld a, (.dmark+2)  
a24f 32 64 ee			ld (debug_mark+2),a  
a252 18 03			jr .pastdmark  
a254 ..			.dmark: db ":0A"  
a257 f1			.pastdmark: pop af  
a258			endm  
# End of macro DMARK
a258			CALLMONITOR 
a258 cd 6f ee			call debug_vector  
a25b				endm  
# End of macro CALLMONITOR
a25b c1			pop bc 
a25c			endif 
a25c			if DEBUG_FORTH_UWORD 
a25c c5			push bc 
a25d ed 4b aa e2	ld bc, (os_new_malloc) 
a261 03			inc bc 
a262 03			inc bc 
a263 03			inc bc 
a264 03			inc bc 
a265 03			inc bc 
a266 03			inc bc 
a267 03			inc bc 
a268 03			inc bc 
a269			 
a269					DMARK ":0B" 
a269 f5				push af  
a26a 3a 7e a2			ld a, (.dmark)  
a26d 32 62 ee			ld (debug_mark),a  
a270 3a 7f a2			ld a, (.dmark+1)  
a273 32 63 ee			ld (debug_mark+1),a  
a276 3a 80 a2			ld a, (.dmark+2)  
a279 32 64 ee			ld (debug_mark+2),a  
a27c 18 03			jr .pastdmark  
a27e ..			.dmark: db ":0B"  
a281 f1			.pastdmark: pop af  
a282			endm  
# End of macro DMARK
a282			CALLMONITOR 
a282 cd 6f ee			call debug_vector  
a285				endm  
# End of macro CALLMONITOR
a285 c1			pop bc 
a286			endif 
a286			 
a286			; update word dict linked list for new word 
a286			 
a286			 
a286 2a b5 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a289 23			inc hl     ; move to next work linked list ptr 
a28a			 
a28a ed 5b aa e2	ld de, (os_new_malloc)		 ; new next word 
a28e 73			ld (hl), e 
a28f 23			inc hl 
a290 72			ld (hl), d 
a291			 
a291			if DEBUG_FORTH_UWORD 
a291 ed 4b b5 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a295			endif 
a295			 
a295 ed 53 b5 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a299			 
a299			 
a299			if DEBUG_FORTH_UWORD 
a299					DMARK ":0+" 
a299 f5				push af  
a29a 3a ae a2			ld a, (.dmark)  
a29d 32 62 ee			ld (debug_mark),a  
a2a0 3a af a2			ld a, (.dmark+1)  
a2a3 32 63 ee			ld (debug_mark+1),a  
a2a6 3a b0 a2			ld a, (.dmark+2)  
a2a9 32 64 ee			ld (debug_mark+2),a  
a2ac 18 03			jr .pastdmark  
a2ae ..			.dmark: db ":0+"  
a2b1 f1			.pastdmark: pop af  
a2b2			endm  
# End of macro DMARK
a2b2			CALLMONITOR 
a2b2 cd 6f ee			call debug_vector  
a2b5				endm  
# End of macro CALLMONITOR
a2b5			endif 
a2b5			 
a2b5			STACKFRAMECHK OFF $8efe $989f 
a2b5				if DEBUG_STACK_IMB 
a2b5					if OFF 
a2b5						exx 
a2b5						ld hl, $989f 
a2b5						pop de   ; $989f 
a2b5						call cmp16 
a2b5						jr nz, .spnosame 
a2b5						ld hl, $8efe 
a2b5						pop de   ; $8efe 
a2b5						call cmp16 
a2b5						jr z, .spfrsame 
a2b5						.spnosame: call showsperror 
a2b5						.spfrsame: nop 
a2b5						exx 
a2b5					endif 
a2b5				endif 
a2b5			endm 
# End of macro STACKFRAMECHK
a2b5			 
a2b5 c9			ret    ; dont process any remaining parser tokens as they form new word 
a2b6			 
a2b6			 
a2b6			 
a2b6			 
a2b6			;		NEXT 
a2b6			.SCOLN: 
a2b6			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a2b6 06			db OPCODE_SCOLN 
a2b7 05 a3		dw .DROP 
a2b9 02			db 2 
a2ba .. 00		db ";",0           
a2bc			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a2bc				if DEBUG_FORTH_WORDS_KEY 
a2bc					DMARK "SCN" 
a2bc f5				push af  
a2bd 3a d1 a2			ld a, (.dmark)  
a2c0 32 62 ee			ld (debug_mark),a  
a2c3 3a d2 a2			ld a, (.dmark+1)  
a2c6 32 63 ee			ld (debug_mark+1),a  
a2c9 3a d3 a2			ld a, (.dmark+2)  
a2cc 32 64 ee			ld (debug_mark+2),a  
a2cf 18 03			jr .pastdmark  
a2d1 ..			.dmark: db "SCN"  
a2d4 f1			.pastdmark: pop af  
a2d5			endm  
# End of macro DMARK
a2d5					CALLMONITOR 
a2d5 cd 6f ee			call debug_vector  
a2d8				endm  
# End of macro CALLMONITOR
a2d8				endif 
a2d8				FORTH_RSP_TOS 
a2d8 cd b3 99			call macro_forth_rsp_tos 
a2db				endm 
# End of macro FORTH_RSP_TOS
a2db e5				push hl 
a2dc				FORTH_RSP_POP 
a2dc cd bd 99			call macro_forth_rsp_pop 
a2df				endm 
# End of macro FORTH_RSP_POP
a2df e1				pop hl 
a2e0			;		ex de,hl 
a2e0 22 b9 e5			ld (os_tok_ptr),hl 
a2e3			 
a2e3			if DEBUG_FORTH_UWORD 
a2e3					DMARK "SCL" 
a2e3 f5				push af  
a2e4 3a f8 a2			ld a, (.dmark)  
a2e7 32 62 ee			ld (debug_mark),a  
a2ea 3a f9 a2			ld a, (.dmark+1)  
a2ed 32 63 ee			ld (debug_mark+1),a  
a2f0 3a fa a2			ld a, (.dmark+2)  
a2f3 32 64 ee			ld (debug_mark+2),a  
a2f6 18 03			jr .pastdmark  
a2f8 ..			.dmark: db "SCL"  
a2fb f1			.pastdmark: pop af  
a2fc			endm  
# End of macro DMARK
a2fc			CALLMONITOR 
a2fc cd 6f ee			call debug_vector  
a2ff				endm  
# End of macro CALLMONITOR
a2ff			endif 
a2ff				NEXTW 
a2ff cd 6c ee			call parse_vector 
a302 c3 e5 9d			jp macro_next 
a305				endm 
# End of macro NEXTW
a305			 
a305			.DROP: 
a305			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a305 1b				db WORD_SYS_CORE+OPCODE_DROP             
a306 33 a3			dw .DUP2            
a308 05				db 4 + 1 
a309 .. 00			db "DROP",0              
a30e				endm 
# End of macro CWHEAD
a30e			; | DROP ( w -- )   drop the TOS item   | DONE 
a30e				if DEBUG_FORTH_WORDS_KEY 
a30e					DMARK "DRP" 
a30e f5				push af  
a30f 3a 23 a3			ld a, (.dmark)  
a312 32 62 ee			ld (debug_mark),a  
a315 3a 24 a3			ld a, (.dmark+1)  
a318 32 63 ee			ld (debug_mark+1),a  
a31b 3a 25 a3			ld a, (.dmark+2)  
a31e 32 64 ee			ld (debug_mark+2),a  
a321 18 03			jr .pastdmark  
a323 ..			.dmark: db "DRP"  
a326 f1			.pastdmark: pop af  
a327			endm  
# End of macro DMARK
a327					CALLMONITOR 
a327 cd 6f ee			call debug_vector  
a32a				endm  
# End of macro CALLMONITOR
a32a				endif 
a32a				FORTH_DSP_POP 
a32a cd b2 9c			call macro_forth_dsp_pop 
a32d				endm 
# End of macro FORTH_DSP_POP
a32d				NEXTW 
a32d cd 6c ee			call parse_vector 
a330 c3 e5 9d			jp macro_next 
a333				endm 
# End of macro NEXTW
a333			.DUP2: 
a333			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a333 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a334 7b a3			dw .DROP2            
a336 05				db 4 + 1 
a337 .. 00			db "2DUP",0              
a33c				endm 
# End of macro CWHEAD
a33c			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
a33c				if DEBUG_FORTH_WORDS_KEY 
a33c					DMARK "2DU" 
a33c f5				push af  
a33d 3a 51 a3			ld a, (.dmark)  
a340 32 62 ee			ld (debug_mark),a  
a343 3a 52 a3			ld a, (.dmark+1)  
a346 32 63 ee			ld (debug_mark+1),a  
a349 3a 53 a3			ld a, (.dmark+2)  
a34c 32 64 ee			ld (debug_mark+2),a  
a34f 18 03			jr .pastdmark  
a351 ..			.dmark: db "2DU"  
a354 f1			.pastdmark: pop af  
a355			endm  
# End of macro DMARK
a355					CALLMONITOR 
a355 cd 6f ee			call debug_vector  
a358				endm  
# End of macro CALLMONITOR
a358				endif 
a358				FORTH_DSP_VALUEHL 
a358 cd fa 9b			call macro_dsp_valuehl 
a35b				endm 
# End of macro FORTH_DSP_VALUEHL
a35b e5				push hl      ; 2 
a35c			 
a35c				FORTH_DSP_POP 
a35c cd b2 9c			call macro_forth_dsp_pop 
a35f				endm 
# End of macro FORTH_DSP_POP
a35f				 
a35f				FORTH_DSP_VALUEHL 
a35f cd fa 9b			call macro_dsp_valuehl 
a362				endm 
# End of macro FORTH_DSP_VALUEHL
a362			;		push hl      ; 1 
a362			 
a362				FORTH_DSP_POP 
a362 cd b2 9c			call macro_forth_dsp_pop 
a365				endm 
# End of macro FORTH_DSP_POP
a365			 
a365			;		pop hl       ; 1 
a365 d1				pop de       ; 2 
a366			 
a366 cd f5 99			call forth_push_numhl 
a369 eb				ex de, hl 
a36a cd f5 99			call forth_push_numhl 
a36d			 
a36d				 
a36d eb				ex de, hl 
a36e			 
a36e cd f5 99			call forth_push_numhl 
a371 eb				ex de, hl 
a372 cd f5 99			call forth_push_numhl 
a375			 
a375			 
a375				NEXTW 
a375 cd 6c ee			call parse_vector 
a378 c3 e5 9d			jp macro_next 
a37b				endm 
# End of macro NEXTW
a37b			.DROP2: 
a37b			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a37b 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a37c ad a3			dw .PICK            
a37e 06				db 5 + 1 
a37f .. 00			db "2DROP",0              
a385				endm 
# End of macro CWHEAD
a385			; | 2DROP ( w w -- )    Double drop | DONE 
a385				if DEBUG_FORTH_WORDS_KEY 
a385					DMARK "2DR" 
a385 f5				push af  
a386 3a 9a a3			ld a, (.dmark)  
a389 32 62 ee			ld (debug_mark),a  
a38c 3a 9b a3			ld a, (.dmark+1)  
a38f 32 63 ee			ld (debug_mark+1),a  
a392 3a 9c a3			ld a, (.dmark+2)  
a395 32 64 ee			ld (debug_mark+2),a  
a398 18 03			jr .pastdmark  
a39a ..			.dmark: db "2DR"  
a39d f1			.pastdmark: pop af  
a39e			endm  
# End of macro DMARK
a39e					CALLMONITOR 
a39e cd 6f ee			call debug_vector  
a3a1				endm  
# End of macro CALLMONITOR
a3a1				endif 
a3a1				FORTH_DSP_POP 
a3a1 cd b2 9c			call macro_forth_dsp_pop 
a3a4				endm 
# End of macro FORTH_DSP_POP
a3a4				FORTH_DSP_POP 
a3a4 cd b2 9c			call macro_forth_dsp_pop 
a3a7				endm 
# End of macro FORTH_DSP_POP
a3a7				NEXTW 
a3a7 cd 6c ee			call parse_vector 
a3aa c3 e5 9d			jp macro_next 
a3ad				endm 
# End of macro NEXTW
a3ad			.PICK: 
a3ad			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
a3ad 77				db WORD_SYS_CORE+99             
a3ae 4a a4			dw .SWAP2            
a3b0 05				db 4 + 1 
a3b1 .. 00			db "PICK",0              
a3b6				endm 
# End of macro CWHEAD
a3b6			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
a3b6			; | | >[!NOTE] 
a3b6			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
a3b6				if DEBUG_FORTH_WORDS_KEY 
a3b6					DMARK "PIK" 
a3b6 f5				push af  
a3b7 3a cb a3			ld a, (.dmark)  
a3ba 32 62 ee			ld (debug_mark),a  
a3bd 3a cc a3			ld a, (.dmark+1)  
a3c0 32 63 ee			ld (debug_mark+1),a  
a3c3 3a cd a3			ld a, (.dmark+2)  
a3c6 32 64 ee			ld (debug_mark+2),a  
a3c9 18 03			jr .pastdmark  
a3cb ..			.dmark: db "PIK"  
a3ce f1			.pastdmark: pop af  
a3cf			endm  
# End of macro DMARK
a3cf					CALLMONITOR 
a3cf cd 6f ee			call debug_vector  
a3d2				endm  
# End of macro CALLMONITOR
a3d2				endif 
a3d2			 
a3d2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3d2 cd fa 9b			call macro_dsp_valuehl 
a3d5				endm 
# End of macro FORTH_DSP_VALUEHL
a3d5				 
a3d5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3d5 cd b2 9c			call macro_forth_dsp_pop 
a3d8				endm 
# End of macro FORTH_DSP_POP
a3d8			 
a3d8				; init from TOS 
a3d8 e5				push hl 
a3d9				FORTH_DSP 
a3d9 cd c0 9b			call macro_forth_dsp 
a3dc				endm 
# End of macro FORTH_DSP
a3dc			;	ld hl, cli_data_sp 
a3dc				if DEBUG_FORTH_WORDS 
a3dc					DMARK "PK1" 
a3dc f5				push af  
a3dd 3a f1 a3			ld a, (.dmark)  
a3e0 32 62 ee			ld (debug_mark),a  
a3e3 3a f2 a3			ld a, (.dmark+1)  
a3e6 32 63 ee			ld (debug_mark+1),a  
a3e9 3a f3 a3			ld a, (.dmark+2)  
a3ec 32 64 ee			ld (debug_mark+2),a  
a3ef 18 03			jr .pastdmark  
a3f1 ..			.dmark: db "PK1"  
a3f4 f1			.pastdmark: pop af  
a3f5			endm  
# End of macro DMARK
a3f5					CALLMONITOR 
a3f5 cd 6f ee			call debug_vector  
a3f8				endm  
# End of macro CALLMONITOR
a3f8				endif 
a3f8 c1				pop bc 
a3f9 41				ld b,c 
a3fa 3e 00			ld a, 0 
a3fc b8				cp b 
a3fd 28 21			jr z, .pdone	 
a3ff			.pkl: 
a3ff 2b				dec hl 
a400 2b				dec hl 
a401 2b				dec hl 
a402			 
a402				if DEBUG_FORTH_WORDS 
a402					DMARK "PKl" 
a402 f5				push af  
a403 3a 17 a4			ld a, (.dmark)  
a406 32 62 ee			ld (debug_mark),a  
a409 3a 18 a4			ld a, (.dmark+1)  
a40c 32 63 ee			ld (debug_mark+1),a  
a40f 3a 19 a4			ld a, (.dmark+2)  
a412 32 64 ee			ld (debug_mark+2),a  
a415 18 03			jr .pastdmark  
a417 ..			.dmark: db "PKl"  
a41a f1			.pastdmark: pop af  
a41b			endm  
# End of macro DMARK
a41b					CALLMONITOR 
a41b cd 6f ee			call debug_vector  
a41e				endm  
# End of macro CALLMONITOR
a41e				endif 
a41e 10 df			djnz .pkl 
a420			.pdone: 
a420				 
a420				; TODO do type check with correct push 
a420			 
a420 23				inc hl 
a421				;call loadwordinhl 
a421 5e				ld e, (hl) 
a422 23				inc hl 
a423 56				ld d, (hl) 
a424 eb				ex de,hl 
a425				if DEBUG_FORTH_WORDS 
a425					DMARK "PKp" 
a425 f5				push af  
a426 3a 3a a4			ld a, (.dmark)  
a429 32 62 ee			ld (debug_mark),a  
a42c 3a 3b a4			ld a, (.dmark+1)  
a42f 32 63 ee			ld (debug_mark+1),a  
a432 3a 3c a4			ld a, (.dmark+2)  
a435 32 64 ee			ld (debug_mark+2),a  
a438 18 03			jr .pastdmark  
a43a ..			.dmark: db "PKp"  
a43d f1			.pastdmark: pop af  
a43e			endm  
# End of macro DMARK
a43e					CALLMONITOR 
a43e cd 6f ee			call debug_vector  
a441				endm  
# End of macro CALLMONITOR
a441				endif 
a441 cd f5 99			call forth_push_numhl 
a444			 
a444				NEXTW 
a444 cd 6c ee			call parse_vector 
a447 c3 e5 9d			jp macro_next 
a44a				endm 
# End of macro NEXTW
a44a			.SWAP2: 
a44a			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a44a 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a44b ce a4			dw .AT            
a44d 06				db 5 + 1 
a44e .. 00			db "2SWAP",0              
a454				endm 
# End of macro CWHEAD
a454			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a454				if DEBUG_FORTH_WORDS_KEY 
a454					DMARK "2SW" 
a454 f5				push af  
a455 3a 69 a4			ld a, (.dmark)  
a458 32 62 ee			ld (debug_mark),a  
a45b 3a 6a a4			ld a, (.dmark+1)  
a45e 32 63 ee			ld (debug_mark+1),a  
a461 3a 6b a4			ld a, (.dmark+2)  
a464 32 64 ee			ld (debug_mark+2),a  
a467 18 03			jr .pastdmark  
a469 ..			.dmark: db "2SW"  
a46c f1			.pastdmark: pop af  
a46d			endm  
# End of macro DMARK
a46d					CALLMONITOR 
a46d cd 6f ee			call debug_vector  
a470				endm  
# End of macro CALLMONITOR
a470				endif 
a470			; TODO Use os stack swap memory 
a470			 
a470				FORTH_DSP_PTR 0     ; TOS    w4 
a470 2a e5 e9			ld hl,(cli_data_sp) 
a473 11 00 00			ld de, 0 * 3 
a476 ed 52			sbc hl, de 
a478				endm 
# End of macro FORTH_DSP_PTR
a478 cd 31 9d			call hltostack1 
a47b			  
a47b				FORTH_DSP_PTR 1     ; TOS    w3 
a47b 2a e5 e9			ld hl,(cli_data_sp) 
a47e 11 03 00			ld de, 1 * 3 
a481 ed 52			sbc hl, de 
a483				endm 
# End of macro FORTH_DSP_PTR
a483 cd 37 9d			call hltostack2 
a486			 
a486			 
a486			 
a486				FORTH_DSP_PTR 2     ; TOS    w2 
a486 2a e5 e9			ld hl,(cli_data_sp) 
a489 11 06 00			ld de, 2 * 3 
a48c ed 52			sbc hl, de 
a48e				endm 
# End of macro FORTH_DSP_PTR
a48e cd 3d 9d			call hltostack3 
a491			 
a491				FORTH_DSP_PTR 3     ; TOS   w1 
a491 2a e5 e9			ld hl,(cli_data_sp) 
a494 11 09 00			ld de, 3 * 3 
a497 ed 52			sbc hl, de 
a499				endm 
# End of macro FORTH_DSP_PTR
a499 cd 43 9d			call hltostack4 
a49c			 
a49c			 
a49c			 
a49c			 
a49c				FORTH_DSP_PTR 0     ; TOS 
a49c 2a e5 e9			ld hl,(cli_data_sp) 
a49f 11 00 00			ld de, 0 * 3 
a4a2 ed 52			sbc hl, de 
a4a4				endm 
# End of macro FORTH_DSP_PTR
a4a4 cd 55 9d			call hlfromstack3 
a4a7			 
a4a7				FORTH_DSP_PTR 1     ; TOS 
a4a7 2a e5 e9			ld hl,(cli_data_sp) 
a4aa 11 03 00			ld de, 1 * 3 
a4ad ed 52			sbc hl, de 
a4af				endm 
# End of macro FORTH_DSP_PTR
a4af cd 5b 9d			call hlfromstack4 
a4b2			 
a4b2			 
a4b2			 
a4b2				FORTH_DSP_PTR 2     ; TOS 
a4b2 2a e5 e9			ld hl,(cli_data_sp) 
a4b5 11 06 00			ld de, 2 * 3 
a4b8 ed 52			sbc hl, de 
a4ba				endm 
# End of macro FORTH_DSP_PTR
a4ba cd 49 9d			call hlfromstack1 
a4bd			 
a4bd				FORTH_DSP_PTR 3     ; TOS 
a4bd 2a e5 e9			ld hl,(cli_data_sp) 
a4c0 11 09 00			ld de, 3 * 3 
a4c3 ed 52			sbc hl, de 
a4c5				endm 
# End of macro FORTH_DSP_PTR
a4c5 cd 4f 9d			call hlfromstack2 
a4c8			 
a4c8				NEXTW 
a4c8 cd 6c ee			call parse_vector 
a4cb c3 e5 9d			jp macro_next 
a4ce				endm 
# End of macro NEXTW
a4ce			.AT: 
a4ce			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a4ce 1f				db WORD_SYS_CORE+OPCODE_AT             
a4cf 03 a5			dw .CAT            
a4d1 02				db 1 + 1 
a4d2 .. 00			db "@",0              
a4d4				endm 
# End of macro CWHEAD
a4d4			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a4d4			 
a4d4				if DEBUG_FORTH_WORDS_KEY 
a4d4					DMARK "AT." 
a4d4 f5				push af  
a4d5 3a e9 a4			ld a, (.dmark)  
a4d8 32 62 ee			ld (debug_mark),a  
a4db 3a ea a4			ld a, (.dmark+1)  
a4de 32 63 ee			ld (debug_mark+1),a  
a4e1 3a eb a4			ld a, (.dmark+2)  
a4e4 32 64 ee			ld (debug_mark+2),a  
a4e7 18 03			jr .pastdmark  
a4e9 ..			.dmark: db "AT."  
a4ec f1			.pastdmark: pop af  
a4ed			endm  
# End of macro DMARK
a4ed					CALLMONITOR 
a4ed cd 6f ee			call debug_vector  
a4f0				endm  
# End of macro CALLMONITOR
a4f0				endif 
a4f0			.getbyteat:	 
a4f0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4f0 cd fa 9b			call macro_dsp_valuehl 
a4f3				endm 
# End of macro FORTH_DSP_VALUEHL
a4f3				 
a4f3			;		push hl 
a4f3			 
a4f3				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4f3 cd b2 9c			call macro_forth_dsp_pop 
a4f6				endm 
# End of macro FORTH_DSP_POP
a4f6			 
a4f6			;		pop hl 
a4f6			 
a4f6 7e				ld a, (hl) 
a4f7			 
a4f7 6f				ld l, a 
a4f8 26 00			ld h, 0 
a4fa cd f5 99			call forth_push_numhl 
a4fd			 
a4fd				NEXTW 
a4fd cd 6c ee			call parse_vector 
a500 c3 e5 9d			jp macro_next 
a503				endm 
# End of macro NEXTW
a503			.CAT: 
a503			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a503 20				db WORD_SYS_CORE+OPCODE_CAT             
a504 2f a5			dw .BANG            
a506 03				db 2 + 1 
a507 .. 00			db "C@",0              
a50a				endm 
# End of macro CWHEAD
a50a			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a50a				if DEBUG_FORTH_WORDS_KEY 
a50a					DMARK "CAA" 
a50a f5				push af  
a50b 3a 1f a5			ld a, (.dmark)  
a50e 32 62 ee			ld (debug_mark),a  
a511 3a 20 a5			ld a, (.dmark+1)  
a514 32 63 ee			ld (debug_mark+1),a  
a517 3a 21 a5			ld a, (.dmark+2)  
a51a 32 64 ee			ld (debug_mark+2),a  
a51d 18 03			jr .pastdmark  
a51f ..			.dmark: db "CAA"  
a522 f1			.pastdmark: pop af  
a523			endm  
# End of macro DMARK
a523					CALLMONITOR 
a523 cd 6f ee			call debug_vector  
a526				endm  
# End of macro CALLMONITOR
a526				endif 
a526 c3 f0 a4			jp .getbyteat 
a529				NEXTW 
a529 cd 6c ee			call parse_vector 
a52c c3 e5 9d			jp macro_next 
a52f				endm 
# End of macro NEXTW
a52f			.BANG: 
a52f			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a52f 21				db WORD_SYS_CORE+OPCODE_BANG             
a530 68 a5			dw .CBANG            
a532 02				db 1 + 1 
a533 .. 00			db "!",0              
a535				endm 
# End of macro CWHEAD
a535			; | ! ( x w -- ) Store x at address w      | DONE 
a535				if DEBUG_FORTH_WORDS_KEY 
a535					DMARK "BNG" 
a535 f5				push af  
a536 3a 4a a5			ld a, (.dmark)  
a539 32 62 ee			ld (debug_mark),a  
a53c 3a 4b a5			ld a, (.dmark+1)  
a53f 32 63 ee			ld (debug_mark+1),a  
a542 3a 4c a5			ld a, (.dmark+2)  
a545 32 64 ee			ld (debug_mark+2),a  
a548 18 03			jr .pastdmark  
a54a ..			.dmark: db "BNG"  
a54d f1			.pastdmark: pop af  
a54e			endm  
# End of macro DMARK
a54e					CALLMONITOR 
a54e cd 6f ee			call debug_vector  
a551				endm  
# End of macro CALLMONITOR
a551				endif 
a551			 
a551			.storebyteat:		 
a551				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a551 cd fa 9b			call macro_dsp_valuehl 
a554				endm 
# End of macro FORTH_DSP_VALUEHL
a554				 
a554 e5				push hl 
a555			 
a555				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a555 cd b2 9c			call macro_forth_dsp_pop 
a558				endm 
# End of macro FORTH_DSP_POP
a558			 
a558				; get byte to poke 
a558			 
a558				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a558 cd fa 9b			call macro_dsp_valuehl 
a55b				endm 
# End of macro FORTH_DSP_VALUEHL
a55b e5				push hl 
a55c			 
a55c			 
a55c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a55c cd b2 9c			call macro_forth_dsp_pop 
a55f				endm 
# End of macro FORTH_DSP_POP
a55f			 
a55f			 
a55f d1				pop de 
a560 e1				pop hl 
a561			 
a561 73				ld (hl),e 
a562			 
a562			 
a562				NEXTW 
a562 cd 6c ee			call parse_vector 
a565 c3 e5 9d			jp macro_next 
a568				endm 
# End of macro NEXTW
a568			.CBANG: 
a568			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a568 22				db WORD_SYS_CORE+OPCODE_CBANG             
a569 94 a5			dw .SCALL            
a56b 03				db 2 + 1 
a56c .. 00			db "C!",0              
a56f				endm 
# End of macro CWHEAD
a56f			; | C!  ( x w -- ) Store x at address w  | DONE 
a56f				if DEBUG_FORTH_WORDS_KEY 
a56f					DMARK "CBA" 
a56f f5				push af  
a570 3a 84 a5			ld a, (.dmark)  
a573 32 62 ee			ld (debug_mark),a  
a576 3a 85 a5			ld a, (.dmark+1)  
a579 32 63 ee			ld (debug_mark+1),a  
a57c 3a 86 a5			ld a, (.dmark+2)  
a57f 32 64 ee			ld (debug_mark+2),a  
a582 18 03			jr .pastdmark  
a584 ..			.dmark: db "CBA"  
a587 f1			.pastdmark: pop af  
a588			endm  
# End of macro DMARK
a588					CALLMONITOR 
a588 cd 6f ee			call debug_vector  
a58b				endm  
# End of macro CALLMONITOR
a58b				endif 
a58b c3 51 a5			jp .storebyteat 
a58e				NEXTW 
a58e cd 6c ee			call parse_vector 
a591 c3 e5 9d			jp macro_next 
a594				endm 
# End of macro NEXTW
a594			.SCALL: 
a594			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a594 23				db WORD_SYS_CORE+OPCODE_SCALL             
a595 cb a5			dw .DEPTH            
a597 05				db 4 + 1 
a598 .. 00			db "CALL",0              
a59d				endm 
# End of macro CWHEAD
a59d			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a59d				if DEBUG_FORTH_WORDS_KEY 
a59d					DMARK "CLL" 
a59d f5				push af  
a59e 3a b2 a5			ld a, (.dmark)  
a5a1 32 62 ee			ld (debug_mark),a  
a5a4 3a b3 a5			ld a, (.dmark+1)  
a5a7 32 63 ee			ld (debug_mark+1),a  
a5aa 3a b4 a5			ld a, (.dmark+2)  
a5ad 32 64 ee			ld (debug_mark+2),a  
a5b0 18 03			jr .pastdmark  
a5b2 ..			.dmark: db "CLL"  
a5b5 f1			.pastdmark: pop af  
a5b6			endm  
# End of macro DMARK
a5b6					CALLMONITOR 
a5b6 cd 6f ee			call debug_vector  
a5b9				endm  
# End of macro CALLMONITOR
a5b9				endif 
a5b9			 
a5b9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b9 cd fa 9b			call macro_dsp_valuehl 
a5bc				endm 
# End of macro FORTH_DSP_VALUEHL
a5bc			 
a5bc			;		push hl 
a5bc			 
a5bc				; destroy value TOS 
a5bc			 
a5bc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5bc cd b2 9c			call macro_forth_dsp_pop 
a5bf				endm 
# End of macro FORTH_DSP_POP
a5bf			 
a5bf					 
a5bf			;		pop hl 
a5bf			 
a5bf				; how to do a call with hl???? save SP? 
a5bf cd 89 9d			call forth_call_hl 
a5c2			 
a5c2			 
a5c2				; TODO push value back onto stack for another op etc 
a5c2			 
a5c2 cd f5 99			call forth_push_numhl 
a5c5				NEXTW 
a5c5 cd 6c ee			call parse_vector 
a5c8 c3 e5 9d			jp macro_next 
a5cb				endm 
# End of macro NEXTW
a5cb			.DEPTH: 
a5cb			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a5cb 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a5cc 0b a6			dw .OVER            
a5ce 06				db 5 + 1 
a5cf .. 00			db "DEPTH",0              
a5d5				endm 
# End of macro CWHEAD
a5d5			; | DEPTH ( -- u ) Push count of stack | DONE 
a5d5				; take current TOS and remove from base value div by two to get count 
a5d5				if DEBUG_FORTH_WORDS_KEY 
a5d5					DMARK "DEP" 
a5d5 f5				push af  
a5d6 3a ea a5			ld a, (.dmark)  
a5d9 32 62 ee			ld (debug_mark),a  
a5dc 3a eb a5			ld a, (.dmark+1)  
a5df 32 63 ee			ld (debug_mark+1),a  
a5e2 3a ec a5			ld a, (.dmark+2)  
a5e5 32 64 ee			ld (debug_mark+2),a  
a5e8 18 03			jr .pastdmark  
a5ea ..			.dmark: db "DEP"  
a5ed f1			.pastdmark: pop af  
a5ee			endm  
# End of macro DMARK
a5ee					CALLMONITOR 
a5ee cd 6f ee			call debug_vector  
a5f1				endm  
# End of macro CALLMONITOR
a5f1				endif 
a5f1			 
a5f1			 
a5f1 2a e5 e9		ld hl, (cli_data_sp) 
a5f4 11 1f e8		ld de, cli_data_stack 
a5f7 ed 52		sbc hl,de 
a5f9			 
a5f9			; div by size of stack item 
a5f9			 
a5f9 5d			ld e,l 
a5fa 0e 03		ld c, 3 
a5fc cd 7a 8c		call Div8 
a5ff			 
a5ff 6f			ld l,a 
a600 26 00		ld h,0 
a602			 
a602			;srl h 
a602			;rr l 
a602			 
a602 cd f5 99			call forth_push_numhl 
a605				NEXTW 
a605 cd 6c ee			call parse_vector 
a608 c3 e5 9d			jp macro_next 
a60b				endm 
# End of macro NEXTW
a60b			.OVER: 
a60b			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a60b 42				db WORD_SYS_CORE+46             
a60c 5b a6			dw .PAUSE            
a60e 05				db 4 + 1 
a60f .. 00			db "OVER",0              
a614				endm 
# End of macro CWHEAD
a614			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a614			; | | If the copied item is a string it is properly duplicated allowing for a safe release after use.  
a614				if DEBUG_FORTH_WORDS_KEY 
a614					DMARK "OVR" 
a614 f5				push af  
a615 3a 29 a6			ld a, (.dmark)  
a618 32 62 ee			ld (debug_mark),a  
a61b 3a 2a a6			ld a, (.dmark+1)  
a61e 32 63 ee			ld (debug_mark+1),a  
a621 3a 2b a6			ld a, (.dmark+2)  
a624 32 64 ee			ld (debug_mark+2),a  
a627 18 03			jr .pastdmark  
a629 ..			.dmark: db "OVR"  
a62c f1			.pastdmark: pop af  
a62d			endm  
# End of macro DMARK
a62d					CALLMONITOR 
a62d cd 6f ee			call debug_vector  
a630				endm  
# End of macro CALLMONITOR
a630				endif 
a630			 
a630			; TODO Use os stack swap memory 
a630			 
a630				; work out what type we are looking at 
a630			 
a630				FORTH_DSP_PTR 1 
a630 2a e5 e9			ld hl,(cli_data_sp) 
a633 11 03 00			ld de, 1 * 3 
a636 ed 52			sbc hl, de 
a638				endm 
# End of macro FORTH_DSP_PTR
a638			 
a638 7e				ld a, (hl) 
a639				 
a639 f5				push af 
a63a				; whatever the type lets get the pointer or word 
a63a 23				inc hl 
a63b			;; 
a63b			 
a63b				; type check now to decide on how to push  
a63b			 
a63b cd 67 9d			call loadwordinhl 
a63e f1				pop af 
a63f fe 01			cp DS_TYPE_STR 
a641 28 09			jr z, .ovstr 
a643			 
a643				; we have a numeric so load the word and push 
a643			;	ld e, (hl) 
a643			;	inc hl 
a643			;	ld d, (hl) 
a643			;	ex de, hl 
a643 cd f5 99			call forth_push_numhl 
a646				NEXTW 
a646 cd 6c ee			call parse_vector 
a649 c3 e5 9d			jp macro_next 
a64c				endm 
# End of macro NEXTW
a64c			 
a64c			.ovstr: 
a64c				; ok, a string so get the pointer and push as a string 
a64c			 
a64c			;	call loadwordinhl 
a64c cd 63 9a			call forth_push_str 
a64f				NEXTW 
a64f cd 6c ee			call parse_vector 
a652 c3 e5 9d			jp macro_next 
a655				endm 
# End of macro NEXTW
a655			 
a655			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a655			;	push hl    ; n2 
a655			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a655			; 
a655			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a655			;	push hl    ; n1 
a655			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a655			; 
a655			;	pop de     ; n1 
a655			;	pop hl     ; n2 
a655			; 
a655			;	push de 
a655			;	push hl 
a655			;	push de 
a655			 
a655				; push back  
a655			 
a655			;	pop hl 
a655			;	call forth_push_numhl 
a655			;	pop hl 
a655			;	call forth_push_numhl 
a655			;	pop hl 
a655			;	call forth_push_numhl 
a655				NEXTW 
a655 cd 6c ee			call parse_vector 
a658 c3 e5 9d			jp macro_next 
a65b				endm 
# End of macro NEXTW
a65b			 
a65b			.PAUSE: 
a65b			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a65b 43				db WORD_SYS_CORE+47             
a65c 93 a6			dw .PAUSES            
a65e 08				db 7 + 1 
a65f .. 00			db "PAUSEMS",0              
a667				endm 
# End of macro CWHEAD
a667			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a667				if DEBUG_FORTH_WORDS_KEY 
a667					DMARK "PMS" 
a667 f5				push af  
a668 3a 7c a6			ld a, (.dmark)  
a66b 32 62 ee			ld (debug_mark),a  
a66e 3a 7d a6			ld a, (.dmark+1)  
a671 32 63 ee			ld (debug_mark+1),a  
a674 3a 7e a6			ld a, (.dmark+2)  
a677 32 64 ee			ld (debug_mark+2),a  
a67a 18 03			jr .pastdmark  
a67c ..			.dmark: db "PMS"  
a67f f1			.pastdmark: pop af  
a680			endm  
# End of macro DMARK
a680					CALLMONITOR 
a680 cd 6f ee			call debug_vector  
a683				endm  
# End of macro CALLMONITOR
a683				endif 
a683				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a683 cd fa 9b			call macro_dsp_valuehl 
a686				endm 
# End of macro FORTH_DSP_VALUEHL
a686			;		push hl    ; n2 
a686				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a686 cd b2 9c			call macro_forth_dsp_pop 
a689				endm 
# End of macro FORTH_DSP_POP
a689			;		pop hl 
a689			 
a689 7d				ld a, l 
a68a cd e5 89			call aDelayInMS 
a68d			       NEXTW 
a68d cd 6c ee			call parse_vector 
a690 c3 e5 9d			jp macro_next 
a693				endm 
# End of macro NEXTW
a693			.PAUSES:  
a693			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a693 44				db WORD_SYS_CORE+48             
a694 05 a7			dw .ROT            
a696 06				db 5 + 1 
a697 .. 00			db "PAUSE",0              
a69d				endm 
# End of macro CWHEAD
a69d			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a69d				if DEBUG_FORTH_WORDS_KEY 
a69d					DMARK "PAU" 
a69d f5				push af  
a69e 3a b2 a6			ld a, (.dmark)  
a6a1 32 62 ee			ld (debug_mark),a  
a6a4 3a b3 a6			ld a, (.dmark+1)  
a6a7 32 63 ee			ld (debug_mark+1),a  
a6aa 3a b4 a6			ld a, (.dmark+2)  
a6ad 32 64 ee			ld (debug_mark+2),a  
a6b0 18 03			jr .pastdmark  
a6b2 ..			.dmark: db "PAU"  
a6b5 f1			.pastdmark: pop af  
a6b6			endm  
# End of macro DMARK
a6b6					CALLMONITOR 
a6b6 cd 6f ee			call debug_vector  
a6b9				endm  
# End of macro CALLMONITOR
a6b9				endif 
a6b9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6b9 cd fa 9b			call macro_dsp_valuehl 
a6bc				endm 
# End of macro FORTH_DSP_VALUEHL
a6bc			;		push hl    ; n2 
a6bc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6bc cd b2 9c			call macro_forth_dsp_pop 
a6bf				endm 
# End of macro FORTH_DSP_POP
a6bf			;		pop hl 
a6bf 45				ld b, l 
a6c0				if DEBUG_FORTH_WORDS 
a6c0					DMARK "PAU" 
a6c0 f5				push af  
a6c1 3a d5 a6			ld a, (.dmark)  
a6c4 32 62 ee			ld (debug_mark),a  
a6c7 3a d6 a6			ld a, (.dmark+1)  
a6ca 32 63 ee			ld (debug_mark+1),a  
a6cd 3a d7 a6			ld a, (.dmark+2)  
a6d0 32 64 ee			ld (debug_mark+2),a  
a6d3 18 03			jr .pastdmark  
a6d5 ..			.dmark: db "PAU"  
a6d8 f1			.pastdmark: pop af  
a6d9			endm  
# End of macro DMARK
a6d9					CALLMONITOR 
a6d9 cd 6f ee			call debug_vector  
a6dc				endm  
# End of macro CALLMONITOR
a6dc				endif 
a6dc c5			.pauses1:	push bc 
a6dd cd 00 8a			call delay1s 
a6e0 c1				pop bc 
a6e1				if DEBUG_FORTH_WORDS 
a6e1					DMARK "PA1" 
a6e1 f5				push af  
a6e2 3a f6 a6			ld a, (.dmark)  
a6e5 32 62 ee			ld (debug_mark),a  
a6e8 3a f7 a6			ld a, (.dmark+1)  
a6eb 32 63 ee			ld (debug_mark+1),a  
a6ee 3a f8 a6			ld a, (.dmark+2)  
a6f1 32 64 ee			ld (debug_mark+2),a  
a6f4 18 03			jr .pastdmark  
a6f6 ..			.dmark: db "PA1"  
a6f9 f1			.pastdmark: pop af  
a6fa			endm  
# End of macro DMARK
a6fa					CALLMONITOR 
a6fa cd 6f ee			call debug_vector  
a6fd				endm  
# End of macro CALLMONITOR
a6fd				endif 
a6fd 10 dd			djnz .pauses1 
a6ff			 
a6ff			       NEXTW 
a6ff cd 6c ee			call parse_vector 
a702 c3 e5 9d			jp macro_next 
a705				endm 
# End of macro NEXTW
a705			.ROT: 
a705			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a705 45				db WORD_SYS_CORE+49             
a706 71 a7			dw .UWORDS            
a708 04				db 3 + 1 
a709 .. 00			db "ROT",0              
a70d				endm 
# End of macro CWHEAD
a70d			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a70d				if DEBUG_FORTH_WORDS_KEY 
a70d					DMARK "ROT" 
a70d f5				push af  
a70e 3a 22 a7			ld a, (.dmark)  
a711 32 62 ee			ld (debug_mark),a  
a714 3a 23 a7			ld a, (.dmark+1)  
a717 32 63 ee			ld (debug_mark+1),a  
a71a 3a 24 a7			ld a, (.dmark+2)  
a71d 32 64 ee			ld (debug_mark+2),a  
a720 18 03			jr .pastdmark  
a722 ..			.dmark: db "ROT"  
a725 f1			.pastdmark: pop af  
a726			endm  
# End of macro DMARK
a726					CALLMONITOR 
a726 cd 6f ee			call debug_vector  
a729				endm  
# End of macro CALLMONITOR
a729				endif 
a729			 
a729			; DONE Use os stack swap memory 
a729			 
a729				FORTH_DSP_PTR 0     ; u3 
a729 2a e5 e9			ld hl,(cli_data_sp) 
a72c 11 00 00			ld de, 0 * 3 
a72f ed 52			sbc hl, de 
a731				endm 
# End of macro FORTH_DSP_PTR
a731 cd 31 9d			call hltostack1     
a734			  
a734				FORTH_DSP_PTR 1     ; u2 
a734 2a e5 e9			ld hl,(cli_data_sp) 
a737 11 03 00			ld de, 1 * 3 
a73a ed 52			sbc hl, de 
a73c				endm 
# End of macro FORTH_DSP_PTR
a73c cd 37 9d			call hltostack2      
a73f			 
a73f				FORTH_DSP_PTR 2     ; u1 
a73f 2a e5 e9			ld hl,(cli_data_sp) 
a742 11 06 00			ld de, 2 * 3 
a745 ed 52			sbc hl, de 
a747				endm 
# End of macro FORTH_DSP_PTR
a747 cd 3d 9d			call hltostack3 
a74a			 
a74a			 
a74a				FORTH_DSP_PTR 0     ;  
a74a 2a e5 e9			ld hl,(cli_data_sp) 
a74d 11 00 00			ld de, 0 * 3 
a750 ed 52			sbc hl, de 
a752				endm 
# End of macro FORTH_DSP_PTR
a752 cd 55 9d			call hlfromstack3 
a755			 
a755				FORTH_DSP_PTR 1     ; TOS 
a755 2a e5 e9			ld hl,(cli_data_sp) 
a758 11 03 00			ld de, 1 * 3 
a75b ed 52			sbc hl, de 
a75d				endm 
# End of macro FORTH_DSP_PTR
a75d cd 49 9d			call hlfromstack1 
a760			 
a760				FORTH_DSP_PTR 2     ; TOS 
a760 2a e5 e9			ld hl,(cli_data_sp) 
a763 11 06 00			ld de, 2 * 3 
a766 ed 52			sbc hl, de 
a768				endm 
# End of macro FORTH_DSP_PTR
a768 cd 4f 9d			call hlfromstack2 
a76b			 
a76b			 
a76b			;	FORTH_DSP_VALUEHL 
a76b			;	push hl    ; u3  
a76b			; 
a76b			;	FORTH_DSP_POP 
a76b			; 
a76b			;	FORTH_DSP_VALUEHL 
a76b			;	push hl     ; u2 
a76b			; 
a76b			;	FORTH_DSP_POP 
a76b			; 
a76b			;	FORTH_DSP_VALUEHL 
a76b			;	push hl     ; u1 
a76b			; 
a76b			;	FORTH_DSP_POP 
a76b			; 
a76b			;	pop bc      ; u1 
a76b			;	pop hl      ; u2 
a76b			;	pop de      ; u3 
a76b			; 
a76b			; 
a76b			;	push bc 
a76b			;	push de 
a76b			;	push hl 
a76b			; 
a76b			; 
a76b			;	pop hl 
a76b			;	call forth_push_numhl 
a76b			; 
a76b			;	pop hl 
a76b			;	call forth_push_numhl 
a76b			; 
a76b			;	pop hl 
a76b			;	call forth_push_numhl 
a76b				 
a76b			 
a76b			 
a76b			 
a76b			 
a76b			 
a76b			       NEXTW 
a76b cd 6c ee			call parse_vector 
a76e c3 e5 9d			jp macro_next 
a771				endm 
# End of macro NEXTW
a771			 
a771			.UWORDS: 
a771			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a771 50				db WORD_SYS_CORE+60             
a772 36 a8			dw .BP            
a774 07				db 6 + 1 
a775 .. 00			db "UWORDS",0              
a77c				endm 
# End of macro CWHEAD
a77c			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a77c			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a77c			; | | Following the count are the individual words. 
a77c			; | | 
a77c			; | | e.g. UWORDS 
a77c			; | | BOX DIRLIST 2 
a77c			; | |  
a77c			; | | Can be used to save the words to storage via: 
a77c			; | | UWORDS $01 DO $01 APPEND LOOP 
a77c			if DEBUG_FORTH_WORDS_KEY 
a77c				DMARK "UWR" 
a77c f5				push af  
a77d 3a 91 a7			ld a, (.dmark)  
a780 32 62 ee			ld (debug_mark),a  
a783 3a 92 a7			ld a, (.dmark+1)  
a786 32 63 ee			ld (debug_mark+1),a  
a789 3a 93 a7			ld a, (.dmark+2)  
a78c 32 64 ee			ld (debug_mark+2),a  
a78f 18 03			jr .pastdmark  
a791 ..			.dmark: db "UWR"  
a794 f1			.pastdmark: pop af  
a795			endm  
# End of macro DMARK
a795				CALLMONITOR 
a795 cd 6f ee			call debug_vector  
a798				endm  
# End of macro CALLMONITOR
a798			endif 
a798 21 f0 e3			ld hl, baseram 
a79b				;ld hl, baseusermem 
a79b 01 00 00			ld bc, 0    ; start a counter 
a79e			 
a79e			; skip dict stub 
a79e			 
a79e cd 22 9f			call forth_tok_next 
a7a1			 
a7a1			 
a7a1			; while we have words to look for 
a7a1			 
a7a1 7e			.douscan:	ld a, (hl)      
a7a2			if DEBUG_FORTH_WORDS 
a7a2				DMARK "UWs" 
a7a2 f5				push af  
a7a3 3a b7 a7			ld a, (.dmark)  
a7a6 32 62 ee			ld (debug_mark),a  
a7a9 3a b8 a7			ld a, (.dmark+1)  
a7ac 32 63 ee			ld (debug_mark+1),a  
a7af 3a b9 a7			ld a, (.dmark+2)  
a7b2 32 64 ee			ld (debug_mark+2),a  
a7b5 18 03			jr .pastdmark  
a7b7 ..			.dmark: db "UWs"  
a7ba f1			.pastdmark: pop af  
a7bb			endm  
# End of macro DMARK
a7bb				CALLMONITOR 
a7bb cd 6f ee			call debug_vector  
a7be				endm  
# End of macro CALLMONITOR
a7be			endif 
a7be fe 00			cp WORD_SYS_END 
a7c0 28 4d			jr z, .udone 
a7c2 fe 01			cp WORD_SYS_UWORD 
a7c4 20 44			jr nz, .nuword 
a7c6			 
a7c6			if DEBUG_FORTH_WORDS 
a7c6				DMARK "UWu" 
a7c6 f5				push af  
a7c7 3a db a7			ld a, (.dmark)  
a7ca 32 62 ee			ld (debug_mark),a  
a7cd 3a dc a7			ld a, (.dmark+1)  
a7d0 32 63 ee			ld (debug_mark+1),a  
a7d3 3a dd a7			ld a, (.dmark+2)  
a7d6 32 64 ee			ld (debug_mark+2),a  
a7d9 18 03			jr .pastdmark  
a7db ..			.dmark: db "UWu"  
a7de f1			.pastdmark: pop af  
a7df			endm  
# End of macro DMARK
a7df				CALLMONITOR 
a7df cd 6f ee			call debug_vector  
a7e2				endm  
# End of macro CALLMONITOR
a7e2			endif 
a7e2				; we have a uword so push its name to the stack 
a7e2			 
a7e2 e5				push hl  ; save so we can move to next dict block 
a7e3			 
a7e3				; skip opcode 
a7e3 23				inc hl  
a7e4				; skip next ptr 
a7e4 23				inc hl  
a7e5 23				inc hl 
a7e6				; skip len 
a7e6 23				inc hl 
a7e7			if DEBUG_FORTH_WORDS 
a7e7				DMARK "UWt" 
a7e7 f5				push af  
a7e8 3a fc a7			ld a, (.dmark)  
a7eb 32 62 ee			ld (debug_mark),a  
a7ee 3a fd a7			ld a, (.dmark+1)  
a7f1 32 63 ee			ld (debug_mark+1),a  
a7f4 3a fe a7			ld a, (.dmark+2)  
a7f7 32 64 ee			ld (debug_mark+2),a  
a7fa 18 03			jr .pastdmark  
a7fc ..			.dmark: db "UWt"  
a7ff f1			.pastdmark: pop af  
a800			endm  
# End of macro DMARK
a800				CALLMONITOR 
a800 cd 6f ee			call debug_vector  
a803				endm  
# End of macro CALLMONITOR
a803			endif 
a803 03				inc bc 
a804			 
a804 c5				push bc 
a805 cd 63 9a			call forth_push_str 
a808 c1				pop bc 
a809			 
a809 e1				pop hl 	 
a80a			 
a80a cd 22 9f		.nuword:	call forth_tok_next 
a80d 18 92			jr .douscan  
a80f			 
a80f			.udone:		 ; push count of uwords found 
a80f c5				push bc 
a810 e1				pop hl 
a811			 
a811			if DEBUG_FORTH_WORDS 
a811				DMARK "UWc" 
a811 f5				push af  
a812 3a 26 a8			ld a, (.dmark)  
a815 32 62 ee			ld (debug_mark),a  
a818 3a 27 a8			ld a, (.dmark+1)  
a81b 32 63 ee			ld (debug_mark+1),a  
a81e 3a 28 a8			ld a, (.dmark+2)  
a821 32 64 ee			ld (debug_mark+2),a  
a824 18 03			jr .pastdmark  
a826 ..			.dmark: db "UWc"  
a829 f1			.pastdmark: pop af  
a82a			endm  
# End of macro DMARK
a82a				CALLMONITOR 
a82a cd 6f ee			call debug_vector  
a82d				endm  
# End of macro CALLMONITOR
a82d			endif 
a82d cd f5 99			call forth_push_numhl 
a830			 
a830			 
a830			       NEXTW 
a830 cd 6c ee			call parse_vector 
a833 c3 e5 9d			jp macro_next 
a836				endm 
# End of macro NEXTW
a836			 
a836			.BP: 
a836			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a836 54				db WORD_SYS_CORE+64             
a837 76 a8			dw .MONITOR            
a839 03				db 2 + 1 
a83a .. 00			db "BP",0              
a83d				endm 
# End of macro CWHEAD
a83d			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a83d			; | | $00 Will enable the break points within specific code paths 
a83d			; | | $01 Will disable break points 
a83d			; | |  
a83d			; | | By default break points are off. Either the above can be used to enable them 
a83d			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a83d			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a83d			; | | can disable break points. Exiting will then continue boot process. 
a83d				; get byte count 
a83d				if DEBUG_FORTH_WORDS_KEY 
a83d					DMARK "BP." 
a83d f5				push af  
a83e 3a 52 a8			ld a, (.dmark)  
a841 32 62 ee			ld (debug_mark),a  
a844 3a 53 a8			ld a, (.dmark+1)  
a847 32 63 ee			ld (debug_mark+1),a  
a84a 3a 54 a8			ld a, (.dmark+2)  
a84d 32 64 ee			ld (debug_mark+2),a  
a850 18 03			jr .pastdmark  
a852 ..			.dmark: db "BP."  
a855 f1			.pastdmark: pop af  
a856			endm  
# End of macro DMARK
a856					CALLMONITOR 
a856 cd 6f ee			call debug_vector  
a859				endm  
# End of macro CALLMONITOR
a859				endif 
a859			 
a859				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a859 cd fa 9b			call macro_dsp_valuehl 
a85c				endm 
# End of macro FORTH_DSP_VALUEHL
a85c			 
a85c			;		push hl 
a85c			 
a85c				; destroy value TOS 
a85c			 
a85c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a85c cd b2 9c			call macro_forth_dsp_pop 
a85f				endm 
# End of macro FORTH_DSP_POP
a85f			 
a85f			;		pop hl 
a85f			 
a85f 3e 00			ld a,0 
a861 bd				cp l 
a862 28 09			jr z, .bpset 
a864			;		ld a, '*' 
a864 cd 7a 93			call bp_off 
a867				NEXTW 
a867 cd 6c ee			call parse_vector 
a86a c3 e5 9d			jp macro_next 
a86d				endm 
# End of macro NEXTW
a86d			 
a86d			.bpset:	 
a86d				;	ld (os_view_disable), a 
a86d cd 6e 93			call bp_on 
a870			 
a870			 
a870				NEXTW 
a870 cd 6c ee			call parse_vector 
a873 c3 e5 9d			jp macro_next 
a876				endm 
# End of macro NEXTW
a876			 
a876			 
a876			.MONITOR: 
a876			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a876 55				db WORD_SYS_CORE+65             
a877 aa a8			dw .MALLOC            
a879 08				db 7 + 1 
a87a .. 00			db "MONITOR",0              
a882				endm 
# End of macro CWHEAD
a882			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a882			; | | At start the current various registers will be displayed with contents. 
a882			; | | Top right corner will show the most recent debug marker seen. 
a882			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a882			; | | and the return stack pointer (RSP). 
a882			; | | Pressing: 
a882			; | |    1 - Initial screen 
a882			; | |    2 - Display a data dump of HL 
a882			; | |    3 - Display a data dump of DE 
a882			; | |    4 - Display a data dump of BC 
a882			; | |    5 - Display a data dump of HL 
a882			; | |    6 - Display a data dump of DSP 
a882			; | |    7 - Display a data dump of RSP 
a882			; | |    8 - Display a data dump of what is at DSP 
a882			; | |    9 - Display a data dump of what is at RSP 
a882			; | |    0 - Exit monitor and continue running. This will also enable break points 
a882			; | |    * - Disable break points 
a882			; | |    # - Enter traditional monitor mode 
a882			; | | 
a882			; | | Monitor Mode 
a882			; | | ------------ 
a882			; | | A prompt of '>' will be shown for various commands: 
a882			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a882			; | |    C - Continue display a data dump from the last set address 
a882			; | |    M xxxx - Set start of memory edit at address xx 
a882			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a882			; | |    G xxxx - Exec code at specific address 
a882			; | |    Q - Return to previous 
a882				if DEBUG_FORTH_WORDS_KEY 
a882					DMARK "MON" 
a882 f5				push af  
a883 3a 97 a8			ld a, (.dmark)  
a886 32 62 ee			ld (debug_mark),a  
a889 3a 98 a8			ld a, (.dmark+1)  
a88c 32 63 ee			ld (debug_mark+1),a  
a88f 3a 99 a8			ld a, (.dmark+2)  
a892 32 64 ee			ld (debug_mark+2),a  
a895 18 03			jr .pastdmark  
a897 ..			.dmark: db "MON"  
a89a f1			.pastdmark: pop af  
a89b			endm  
# End of macro DMARK
a89b					CALLMONITOR 
a89b cd 6f ee			call debug_vector  
a89e				endm  
# End of macro CALLMONITOR
a89e				endif 
a89e			;		ld a, 0 
a89e			;		ld (os_view_disable), a 
a89e cd 6e 93			call bp_on 
a8a1			 
a8a1				CALLMONITOR 
a8a1 cd 6f ee			call debug_vector  
a8a4				endm  
# End of macro CALLMONITOR
a8a4			 
a8a4			;	call monitor 
a8a4			 
a8a4				NEXTW 
a8a4 cd 6c ee			call parse_vector 
a8a7 c3 e5 9d			jp macro_next 
a8aa				endm 
# End of macro NEXTW
a8aa			 
a8aa			 
a8aa			.MALLOC: 
a8aa			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a8aa 56				db WORD_SYS_CORE+66             
a8ab d3 a8			dw .MALLOC2            
a8ad 06				db 5 + 1 
a8ae .. 00			db "ALLOT",0              
a8b4				endm 
# End of macro CWHEAD
a8b4			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a8b4				if DEBUG_FORTH_WORDS_KEY 
a8b4					DMARK "ALL" 
a8b4 f5				push af  
a8b5 3a c9 a8			ld a, (.dmark)  
a8b8 32 62 ee			ld (debug_mark),a  
a8bb 3a ca a8			ld a, (.dmark+1)  
a8be 32 63 ee			ld (debug_mark+1),a  
a8c1 3a cb a8			ld a, (.dmark+2)  
a8c4 32 64 ee			ld (debug_mark+2),a  
a8c7 18 03			jr .pastdmark  
a8c9 ..			.dmark: db "ALL"  
a8cc f1			.pastdmark: pop af  
a8cd			endm  
# End of macro DMARK
a8cd					CALLMONITOR 
a8cd cd 6f ee			call debug_vector  
a8d0				endm  
# End of macro CALLMONITOR
a8d0				endif 
a8d0 c3 fa a8			jp .mallocc 
a8d3			.MALLOC2: 
a8d3			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a8d3 56				db WORD_SYS_CORE+66             
a8d4 14 a9			dw .FREE            
a8d6 07				db 6 + 1 
a8d7 .. 00			db "MALLOC",0              
a8de				endm 
# End of macro CWHEAD
a8de			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a8de				; get byte count 
a8de				if DEBUG_FORTH_WORDS_KEY 
a8de					DMARK "MAL" 
a8de f5				push af  
a8df 3a f3 a8			ld a, (.dmark)  
a8e2 32 62 ee			ld (debug_mark),a  
a8e5 3a f4 a8			ld a, (.dmark+1)  
a8e8 32 63 ee			ld (debug_mark+1),a  
a8eb 3a f5 a8			ld a, (.dmark+2)  
a8ee 32 64 ee			ld (debug_mark+2),a  
a8f1 18 03			jr .pastdmark  
a8f3 ..			.dmark: db "MAL"  
a8f6 f1			.pastdmark: pop af  
a8f7			endm  
# End of macro DMARK
a8f7					CALLMONITOR 
a8f7 cd 6f ee			call debug_vector  
a8fa				endm  
# End of macro CALLMONITOR
a8fa				endif 
a8fa			.mallocc: 
a8fa				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a8fa cd fa 9b			call macro_dsp_valuehl 
a8fd				endm 
# End of macro FORTH_DSP_VALUEHL
a8fd			 
a8fd			;		push hl 
a8fd			 
a8fd				; destroy value TOS 
a8fd			 
a8fd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a8fd cd b2 9c			call macro_forth_dsp_pop 
a900				endm 
# End of macro FORTH_DSP_POP
a900			 
a900			;		pop hl 
a900 cd c5 90			call malloc 
a903			if DEBUG_FORTH_MALLOC_GUARD 
a903 f5				push af 
a904 cd 13 8d			call ishlzero 
a907			;		ld a, l 
a907			;		add h 
a907			;		cp 0 
a907 f1				pop af 
a908				 
a908 cc 9e d2			call z,malloc_error 
a90b			endif 
a90b			 
a90b cd f5 99			call forth_push_numhl 
a90e				NEXTW 
a90e cd 6c ee			call parse_vector 
a911 c3 e5 9d			jp macro_next 
a914				endm 
# End of macro NEXTW
a914			 
a914			.FREE: 
a914			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
a914 57				db WORD_SYS_CORE+67             
a915 48 a9			dw .UPTR            
a917 05				db 4 + 1 
a918 .. 00			db "FREE",0              
a91d				endm 
# End of macro CWHEAD
a91d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a91d				if DEBUG_FORTH_WORDS_KEY 
a91d					DMARK "FRE" 
a91d f5				push af  
a91e 3a 32 a9			ld a, (.dmark)  
a921 32 62 ee			ld (debug_mark),a  
a924 3a 33 a9			ld a, (.dmark+1)  
a927 32 63 ee			ld (debug_mark+1),a  
a92a 3a 34 a9			ld a, (.dmark+2)  
a92d 32 64 ee			ld (debug_mark+2),a  
a930 18 03			jr .pastdmark  
a932 ..			.dmark: db "FRE"  
a935 f1			.pastdmark: pop af  
a936			endm  
# End of macro DMARK
a936					CALLMONITOR 
a936 cd 6f ee			call debug_vector  
a939				endm  
# End of macro CALLMONITOR
a939				endif 
a939				; get address 
a939			 
a939				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a939 cd fa 9b			call macro_dsp_valuehl 
a93c				endm 
# End of macro FORTH_DSP_VALUEHL
a93c			 
a93c			;		push hl 
a93c			 
a93c				; destroy value TOS 
a93c			 
a93c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a93c cd b2 9c			call macro_forth_dsp_pop 
a93f				endm 
# End of macro FORTH_DSP_POP
a93f			 
a93f			;		pop hl 
a93f			if FORTH_ENABLE_MALLOCFREE 
a93f cd 8f 91			call free 
a942			endif 
a942				NEXTW 
a942 cd 6c ee			call parse_vector 
a945 c3 e5 9d			jp macro_next 
a948				endm 
# End of macro NEXTW
a948			.UPTR: 
a948			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
a948 57				db WORD_SYS_CORE+67             
a949 4e aa			dw .LIST            
a94b 05				db 4 + 1 
a94c .. 00			db "UPTR",0              
a951				endm 
# End of macro CWHEAD
a951			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
a951				if DEBUG_FORTH_WORDS_KEY 
a951					DMARK "UPT" 
a951 f5				push af  
a952 3a 66 a9			ld a, (.dmark)  
a955 32 62 ee			ld (debug_mark),a  
a958 3a 67 a9			ld a, (.dmark+1)  
a95b 32 63 ee			ld (debug_mark+1),a  
a95e 3a 68 a9			ld a, (.dmark+2)  
a961 32 64 ee			ld (debug_mark+2),a  
a964 18 03			jr .pastdmark  
a966 ..			.dmark: db "UPT"  
a969 f1			.pastdmark: pop af  
a96a			endm  
# End of macro DMARK
a96a					CALLMONITOR 
a96a cd 6f ee			call debug_vector  
a96d				endm  
# End of macro CALLMONITOR
a96d				endif 
a96d				FORTH_DSP_VALUEHL 
a96d cd fa 9b			call macro_dsp_valuehl 
a970				endm 
# End of macro FORTH_DSP_VALUEHL
a970			 
a970 e5				push hl 
a971				FORTH_DSP_POP 
a971 cd b2 9c			call macro_forth_dsp_pop 
a974				endm 
# End of macro FORTH_DSP_POP
a974 c1				pop bc 
a975			 
a975			 
a975				; Get ptr to the word we need to look up 
a975			 
a975			;		FORTH_DSP_VALUEHL 
a975				;v5 FORTH_DSP_VALUE 
a975			; TODO type check 
a975			;		inc hl    ; Skip type check  
a975			;		push hl 
a975			;		ex de, hl    ; put into DE 
a975			 
a975			 
a975 21 f0 e3			ld hl, baseram 
a978				;ld hl, baseusermem 
a978			 
a978 e5			push hl   ; sacreifical push 
a979			 
a979			.uldouscanm: 
a979 e1			pop hl 
a97a			.uldouscan: 
a97a			if DEBUG_FORTH_WORDS 
a97a				DMARK "LSs" 
a97a f5				push af  
a97b 3a 8f a9			ld a, (.dmark)  
a97e 32 62 ee			ld (debug_mark),a  
a981 3a 90 a9			ld a, (.dmark+1)  
a984 32 63 ee			ld (debug_mark+1),a  
a987 3a 91 a9			ld a, (.dmark+2)  
a98a 32 64 ee			ld (debug_mark+2),a  
a98d 18 03			jr .pastdmark  
a98f ..			.dmark: db "LSs"  
a992 f1			.pastdmark: pop af  
a993			endm  
# End of macro DMARK
a993				CALLMONITOR 
a993 cd 6f ee			call debug_vector  
a996				endm  
# End of macro CALLMONITOR
a996			endif 
a996			; skip dict stub 
a996 cd 22 9f			call forth_tok_next 
a999			 
a999			 
a999			; while we have words to look for 
a999			 
a999 7e			ld a, (hl)      
a99a			if DEBUG_FORTH_WORDS 
a99a				DMARK "LSk" 
a99a f5				push af  
a99b 3a af a9			ld a, (.dmark)  
a99e 32 62 ee			ld (debug_mark),a  
a9a1 3a b0 a9			ld a, (.dmark+1)  
a9a4 32 63 ee			ld (debug_mark+1),a  
a9a7 3a b1 a9			ld a, (.dmark+2)  
a9aa 32 64 ee			ld (debug_mark+2),a  
a9ad 18 03			jr .pastdmark  
a9af ..			.dmark: db "LSk"  
a9b2 f1			.pastdmark: pop af  
a9b3			endm  
# End of macro DMARK
a9b3				CALLMONITOR 
a9b3 cd 6f ee			call debug_vector  
a9b6				endm  
# End of macro CALLMONITOR
a9b6			endif 
a9b6				;cp WORD_SYS_END 
a9b6				;jp z, .lunotfound 
a9b6			 
a9b6					; if we hit non uwords then gone too far 
a9b6 fe 01				cp WORD_SYS_UWORD 
a9b8 c2 45 aa				jp nz, .ulunotfound 
a9bb			 
a9bb				if DEBUG_FORTH_WORDS 
a9bb					DMARK "LSu" 
a9bb f5				push af  
a9bc 3a d0 a9			ld a, (.dmark)  
a9bf 32 62 ee			ld (debug_mark),a  
a9c2 3a d1 a9			ld a, (.dmark+1)  
a9c5 32 63 ee			ld (debug_mark+1),a  
a9c8 3a d2 a9			ld a, (.dmark+2)  
a9cb 32 64 ee			ld (debug_mark+2),a  
a9ce 18 03			jr .pastdmark  
a9d0 ..			.dmark: db "LSu"  
a9d3 f1			.pastdmark: pop af  
a9d4			endm  
# End of macro DMARK
a9d4					CALLMONITOR 
a9d4 cd 6f ee			call debug_vector  
a9d7				endm  
# End of macro CALLMONITOR
a9d7				endif 
a9d7			 
a9d7					; found a uword but is it the one we want... 
a9d7			 
a9d7 c5					push bc     ; uword to find is on bc 
a9d8 d1					pop de 
a9d9			 
a9d9 e5					push hl  ; to save the ptr 
a9da			 
a9da					; skip opcode 
a9da 23					inc hl  
a9db					; skip next ptr 
a9db 23					inc hl  
a9dc 23					inc hl 
a9dd					; skip len 
a9dd 23					inc hl 
a9de			 
a9de				if DEBUG_FORTH_WORDS 
a9de					DMARK "LSc" 
a9de f5				push af  
a9df 3a f3 a9			ld a, (.dmark)  
a9e2 32 62 ee			ld (debug_mark),a  
a9e5 3a f4 a9			ld a, (.dmark+1)  
a9e8 32 63 ee			ld (debug_mark+1),a  
a9eb 3a f5 a9			ld a, (.dmark+2)  
a9ee 32 64 ee			ld (debug_mark+2),a  
a9f1 18 03			jr .pastdmark  
a9f3 ..			.dmark: db "LSc"  
a9f6 f1			.pastdmark: pop af  
a9f7			endm  
# End of macro DMARK
a9f7					CALLMONITOR 
a9f7 cd 6f ee			call debug_vector  
a9fa				endm  
# End of macro CALLMONITOR
a9fa				endif 
a9fa			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a9fa			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a9fa			; Nope that has gone the other way. It needs to be exact not on first zero 
a9fa			;		call strcmp 
a9fa c5					push bc 
a9fb cd 95 90				call StrictStrCmp 
a9fe c1					pop bc 
a9ff c2 79 a9				jp nz, .uldouscanm 
aa02				 
aa02			 
aa02			 
aa02					; we have a uword so push its name to the stack 
aa02			 
aa02			;	   	push hl  ; save so we can move to next dict block 
aa02 e1			pop hl 
aa03			 
aa03				if DEBUG_FORTH_WORDS 
aa03					DMARK "LSm" 
aa03 f5				push af  
aa04 3a 18 aa			ld a, (.dmark)  
aa07 32 62 ee			ld (debug_mark),a  
aa0a 3a 19 aa			ld a, (.dmark+1)  
aa0d 32 63 ee			ld (debug_mark+1),a  
aa10 3a 1a aa			ld a, (.dmark+2)  
aa13 32 64 ee			ld (debug_mark+2),a  
aa16 18 03			jr .pastdmark  
aa18 ..			.dmark: db "LSm"  
aa1b f1			.pastdmark: pop af  
aa1c			endm  
# End of macro DMARK
aa1c					CALLMONITOR 
aa1c cd 6f ee			call debug_vector  
aa1f				endm  
# End of macro CALLMONITOR
aa1f				endif 
aa1f			 
aa1f					; skip opcode 
aa1f 23					inc hl  
aa20					; skip next ptr 
aa20 23					inc hl  
aa21 23					inc hl 
aa22					; skip len 
aa22 7e					ld a, (hl)   ; save length to add 
aa23				if DEBUG_FORTH_WORDS 
aa23					DMARK "LS2" 
aa23 f5				push af  
aa24 3a 38 aa			ld a, (.dmark)  
aa27 32 62 ee			ld (debug_mark),a  
aa2a 3a 39 aa			ld a, (.dmark+1)  
aa2d 32 63 ee			ld (debug_mark+1),a  
aa30 3a 3a aa			ld a, (.dmark+2)  
aa33 32 64 ee			ld (debug_mark+2),a  
aa36 18 03			jr .pastdmark  
aa38 ..			.dmark: db "LS2"  
aa3b f1			.pastdmark: pop af  
aa3c			endm  
# End of macro DMARK
aa3c					CALLMONITOR 
aa3c cd 6f ee			call debug_vector  
aa3f				endm  
# End of macro CALLMONITOR
aa3f				endif 
aa3f			 
aa3f				; skip zero term and other uword defs to position right at the exec code 
aa3f 06 04			ld b, 4 
aa41 80				add a,b 
aa42			 
aa42 cd ea 8c			call addatohl 
aa45					; save this location 
aa45				 
aa45			.ulunotfound: 
aa45 cd f5 99			call forth_push_numhl 
aa48						 
aa48				NEXTW 
aa48 cd 6c ee			call parse_vector 
aa4b c3 e5 9d			jp macro_next 
aa4e				endm 
# End of macro NEXTW
aa4e			.LIST: 
aa4e			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
aa4e 5c				db WORD_SYS_CORE+72             
aa4f 53 ac			dw .FORGET            
aa51 05				db 4 + 1 
aa52 .. 00			db "LIST",0              
aa57				endm 
# End of macro CWHEAD
aa57			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
aa57			; | | The quoted word must be in upper case. 
aa57			if DEBUG_FORTH_WORDS_KEY 
aa57				DMARK "LST" 
aa57 f5				push af  
aa58 3a 6c aa			ld a, (.dmark)  
aa5b 32 62 ee			ld (debug_mark),a  
aa5e 3a 6d aa			ld a, (.dmark+1)  
aa61 32 63 ee			ld (debug_mark+1),a  
aa64 3a 6e aa			ld a, (.dmark+2)  
aa67 32 64 ee			ld (debug_mark+2),a  
aa6a 18 03			jr .pastdmark  
aa6c ..			.dmark: db "LST"  
aa6f f1			.pastdmark: pop af  
aa70			endm  
# End of macro DMARK
aa70				CALLMONITOR 
aa70 cd 6f ee			call debug_vector  
aa73				endm  
# End of macro CALLMONITOR
aa73			endif 
aa73			 
aa73				FORTH_DSP_VALUEHL 
aa73 cd fa 9b			call macro_dsp_valuehl 
aa76				endm 
# End of macro FORTH_DSP_VALUEHL
aa76			 
aa76 e5				push hl 
aa77				FORTH_DSP_POP 
aa77 cd b2 9c			call macro_forth_dsp_pop 
aa7a				endm 
# End of macro FORTH_DSP_POP
aa7a c1				pop bc 
aa7b			 
aa7b			; Start format of scratch string 
aa7b			 
aa7b 21 b8 e2			ld hl, scratch 
aa7e			 
aa7e 3e 3a			ld a, ':' 
aa80 77				ld (hl),a 
aa81 23				inc hl 
aa82 3e 20			ld a, ' ' 
aa84 77				ld (hl), a 
aa85			 
aa85				; Get ptr to the word we need to look up 
aa85			 
aa85			;		FORTH_DSP_VALUEHL 
aa85				;v5 FORTH_DSP_VALUE 
aa85			; TODO type check 
aa85			;		inc hl    ; Skip type check  
aa85			;		push hl 
aa85			;		ex de, hl    ; put into DE 
aa85			 
aa85			 
aa85 21 f0 e3			ld hl, baseram 
aa88				;ld hl, baseusermem 
aa88			 
aa88 e5			push hl   ; sacreifical push 
aa89			 
aa89			.ldouscanm: 
aa89 e1			pop hl 
aa8a			.ldouscan: 
aa8a			if DEBUG_FORTH_WORDS 
aa8a				DMARK "LSs" 
aa8a f5				push af  
aa8b 3a 9f aa			ld a, (.dmark)  
aa8e 32 62 ee			ld (debug_mark),a  
aa91 3a a0 aa			ld a, (.dmark+1)  
aa94 32 63 ee			ld (debug_mark+1),a  
aa97 3a a1 aa			ld a, (.dmark+2)  
aa9a 32 64 ee			ld (debug_mark+2),a  
aa9d 18 03			jr .pastdmark  
aa9f ..			.dmark: db "LSs"  
aaa2 f1			.pastdmark: pop af  
aaa3			endm  
# End of macro DMARK
aaa3				CALLMONITOR 
aaa3 cd 6f ee			call debug_vector  
aaa6				endm  
# End of macro CALLMONITOR
aaa6			endif 
aaa6			; skip dict stub 
aaa6 cd 22 9f			call forth_tok_next 
aaa9			 
aaa9			 
aaa9			; while we have words to look for 
aaa9			 
aaa9 7e			ld a, (hl)      
aaaa			if DEBUG_FORTH_WORDS 
aaaa				DMARK "LSk" 
aaaa f5				push af  
aaab 3a bf aa			ld a, (.dmark)  
aaae 32 62 ee			ld (debug_mark),a  
aab1 3a c0 aa			ld a, (.dmark+1)  
aab4 32 63 ee			ld (debug_mark+1),a  
aab7 3a c1 aa			ld a, (.dmark+2)  
aaba 32 64 ee			ld (debug_mark+2),a  
aabd 18 03			jr .pastdmark  
aabf ..			.dmark: db "LSk"  
aac2 f1			.pastdmark: pop af  
aac3			endm  
# End of macro DMARK
aac3				CALLMONITOR 
aac3 cd 6f ee			call debug_vector  
aac6				endm  
# End of macro CALLMONITOR
aac6			endif 
aac6				;cp WORD_SYS_END 
aac6				;jp z, .lunotfound 
aac6			 
aac6					; if we hit non uwords then gone too far 
aac6 fe 01				cp WORD_SYS_UWORD 
aac8 c2 06 ac				jp nz, .lunotfound 
aacb			 
aacb				if DEBUG_FORTH_WORDS 
aacb					DMARK "LSu" 
aacb f5				push af  
aacc 3a e0 aa			ld a, (.dmark)  
aacf 32 62 ee			ld (debug_mark),a  
aad2 3a e1 aa			ld a, (.dmark+1)  
aad5 32 63 ee			ld (debug_mark+1),a  
aad8 3a e2 aa			ld a, (.dmark+2)  
aadb 32 64 ee			ld (debug_mark+2),a  
aade 18 03			jr .pastdmark  
aae0 ..			.dmark: db "LSu"  
aae3 f1			.pastdmark: pop af  
aae4			endm  
# End of macro DMARK
aae4					CALLMONITOR 
aae4 cd 6f ee			call debug_vector  
aae7				endm  
# End of macro CALLMONITOR
aae7				endif 
aae7			 
aae7					; found a uword but is it the one we want... 
aae7			 
aae7 c5					push bc     ; uword to find is on bc 
aae8 d1					pop de 
aae9			 
aae9 e5					push hl  ; to save the ptr 
aaea			 
aaea					; skip opcode 
aaea 23					inc hl  
aaeb					; skip next ptr 
aaeb 23					inc hl  
aaec 23					inc hl 
aaed					; skip len 
aaed 23					inc hl 
aaee			 
aaee				if DEBUG_FORTH_WORDS 
aaee					DMARK "LSc" 
aaee f5				push af  
aaef 3a 03 ab			ld a, (.dmark)  
aaf2 32 62 ee			ld (debug_mark),a  
aaf5 3a 04 ab			ld a, (.dmark+1)  
aaf8 32 63 ee			ld (debug_mark+1),a  
aafb 3a 05 ab			ld a, (.dmark+2)  
aafe 32 64 ee			ld (debug_mark+2),a  
ab01 18 03			jr .pastdmark  
ab03 ..			.dmark: db "LSc"  
ab06 f1			.pastdmark: pop af  
ab07			endm  
# End of macro DMARK
ab07					CALLMONITOR 
ab07 cd 6f ee			call debug_vector  
ab0a				endm  
# End of macro CALLMONITOR
ab0a				endif 
ab0a			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
ab0a			; ie. If WOO is defined first and then WO. Couldnt list WO. 
ab0a			; Nope that has gone the other way. It needs to be exact not on first zero 
ab0a			;		call strcmp 
ab0a c5					push bc 
ab0b cd 95 90				call StrictStrCmp 
ab0e c1					pop bc 
ab0f c2 89 aa				jp nz, .ldouscanm 
ab12				 
ab12			 
ab12			 
ab12					; we have a uword so push its name to the stack 
ab12			 
ab12			;	   	push hl  ; save so we can move to next dict block 
ab12 e1			pop hl 
ab13			 
ab13				if DEBUG_FORTH_WORDS 
ab13					DMARK "LSm" 
ab13 f5				push af  
ab14 3a 28 ab			ld a, (.dmark)  
ab17 32 62 ee			ld (debug_mark),a  
ab1a 3a 29 ab			ld a, (.dmark+1)  
ab1d 32 63 ee			ld (debug_mark+1),a  
ab20 3a 2a ab			ld a, (.dmark+2)  
ab23 32 64 ee			ld (debug_mark+2),a  
ab26 18 03			jr .pastdmark  
ab28 ..			.dmark: db "LSm"  
ab2b f1			.pastdmark: pop af  
ab2c			endm  
# End of macro DMARK
ab2c					CALLMONITOR 
ab2c cd 6f ee			call debug_vector  
ab2f				endm  
# End of macro CALLMONITOR
ab2f				endif 
ab2f			 
ab2f					; skip opcode 
ab2f 23					inc hl  
ab30					; skip next ptr 
ab30 23					inc hl  
ab31 23					inc hl 
ab32					; skip len 
ab32 7e					ld a, (hl)   ; save length to add 
ab33				if DEBUG_FORTH_WORDS 
ab33					DMARK "LS2" 
ab33 f5				push af  
ab34 3a 48 ab			ld a, (.dmark)  
ab37 32 62 ee			ld (debug_mark),a  
ab3a 3a 49 ab			ld a, (.dmark+1)  
ab3d 32 63 ee			ld (debug_mark+1),a  
ab40 3a 4a ab			ld a, (.dmark+2)  
ab43 32 64 ee			ld (debug_mark+2),a  
ab46 18 03			jr .pastdmark  
ab48 ..			.dmark: db "LS2"  
ab4b f1			.pastdmark: pop af  
ab4c			endm  
# End of macro DMARK
ab4c					CALLMONITOR 
ab4c cd 6f ee			call debug_vector  
ab4f				endm  
# End of macro CALLMONITOR
ab4f				endif 
ab4f			 
ab4f					; save this location 
ab4f				 
ab4f e5					push hl 
ab50			 
ab50 23					inc hl 
ab51 11 ba e2				ld de, scratch+2 
ab54 4f					ld c, a 
ab55 06 00				ld b, 0 
ab57			 
ab57				if DEBUG_FORTH_WORDS 
ab57					DMARK "LSn" 
ab57 f5				push af  
ab58 3a 6c ab			ld a, (.dmark)  
ab5b 32 62 ee			ld (debug_mark),a  
ab5e 3a 6d ab			ld a, (.dmark+1)  
ab61 32 63 ee			ld (debug_mark+1),a  
ab64 3a 6e ab			ld a, (.dmark+2)  
ab67 32 64 ee			ld (debug_mark+2),a  
ab6a 18 03			jr .pastdmark  
ab6c ..			.dmark: db "LSn"  
ab6f f1			.pastdmark: pop af  
ab70			endm  
# End of macro DMARK
ab70					CALLMONITOR 
ab70 cd 6f ee			call debug_vector  
ab73				endm  
# End of macro CALLMONITOR
ab73				endif 
ab73			 
ab73					; copy uword name to scratch 
ab73			 
ab73			;		ldir 
ab73			.licplw:	; copy uword name to scratch converting to lower case as we go 
ab73 ed a0				ldi 
ab75 1b					dec de 
ab76 1a					ld a, (de) 
ab77 cd 68 8f				call to_lower 
ab7a 12					ld (de),a 
ab7b 13					inc de 
ab7c 3e 00				ld a, 0 
ab7e b9					cp c 
ab7f 20 f2				jr nz, .licplw 
ab81			 
ab81			 
ab81			 
ab81 1b					dec de 
ab82 3e 20				ld a, ' '    ; change null to space 
ab84 12					ld (de), a 
ab85			 
ab85 13					inc de 
ab86			 
ab86 d5					push de 
ab87 c1					pop bc     ; move scratch pointer to end of word name and save it 
ab88			 
ab88 e1					pop hl 
ab89 7e					ld a, (hl) 
ab8a					;inc hl 
ab8a					; skip word string 
ab8a cd ea 8c				call addatohl 
ab8d			 
ab8d 23					inc hl 
ab8e			 
ab8e				if DEBUG_FORTH_WORDS 
ab8e					DMARK "LS3" 
ab8e f5				push af  
ab8f 3a a3 ab			ld a, (.dmark)  
ab92 32 62 ee			ld (debug_mark),a  
ab95 3a a4 ab			ld a, (.dmark+1)  
ab98 32 63 ee			ld (debug_mark+1),a  
ab9b 3a a5 ab			ld a, (.dmark+2)  
ab9e 32 64 ee			ld (debug_mark+2),a  
aba1 18 03			jr .pastdmark  
aba3 ..			.dmark: db "LS3"  
aba6 f1			.pastdmark: pop af  
aba7			endm  
# End of macro DMARK
aba7					CALLMONITOR 
aba7 cd 6f ee			call debug_vector  
abaa				endm  
# End of macro CALLMONITOR
abaa				endif 
abaa					; should now be at the start of the machine code to setup the eval of the uword 
abaa					; now locate the ptr to the string defintion 
abaa			 
abaa					; skip ld hl, 
abaa					; then load the ptr 
abaa			; TODO use get from hl ptr 
abaa 23					inc hl 
abab 5e					ld e, (hl) 
abac 23					inc hl 
abad 56					ld d, (hl) 
abae eb					ex de, hl 
abaf			 
abaf			 
abaf				if DEBUG_FORTH_WORDS 
abaf					DMARK "LSt" 
abaf f5				push af  
abb0 3a c4 ab			ld a, (.dmark)  
abb3 32 62 ee			ld (debug_mark),a  
abb6 3a c5 ab			ld a, (.dmark+1)  
abb9 32 63 ee			ld (debug_mark+1),a  
abbc 3a c6 ab			ld a, (.dmark+2)  
abbf 32 64 ee			ld (debug_mark+2),a  
abc2 18 03			jr .pastdmark  
abc4 ..			.dmark: db "LSt"  
abc7 f1			.pastdmark: pop af  
abc8			endm  
# End of macro DMARK
abc8					CALLMONITOR 
abc8 cd 6f ee			call debug_vector  
abcb				endm  
# End of macro CALLMONITOR
abcb				endif 
abcb			 
abcb			; cant push right now due to tokenised strings  
abcb			 
abcb			; get the destination of where to copy this definition to. 
abcb			 
abcb c5					push bc 
abcc d1					pop de 
abcd			 
abcd 7e			.listl:         ld a,(hl) 
abce fe 00				cp 0 
abd0 28 09				jr z, .lreplsp     ; replace zero with space 
abd2					;cp FORTH_END_BUFFER 
abd2 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
abd4 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
abd6				 
abd6					; just copy this char as is then 
abd6			 
abd6 12					ld (de), a 
abd7			 
abd7 23			.listnxt:	inc hl 
abd8 13					inc de 
abd9 18 f2				jr .listl 
abdb			 
abdb 3e 20		.lreplsp:	ld a,' ' 
abdd 12					ld (de), a 
abde 18 f7				jr .listnxt 
abe0			 
abe0			; close up uword def 
abe0			 
abe0			.listdone: 
abe0 12					ld (de), a 
abe1 13					inc de 
abe2 3e 00				ld a, 0 
abe4 12					ld (de), a 
abe5			 
abe5			; now have def so clean up and push to stack 
abe5			 
abe5 21 b8 e2				ld hl, scratch 
abe8				if DEBUG_FORTH_WORDS 
abe8					DMARK "Ltp" 
abe8 f5				push af  
abe9 3a fd ab			ld a, (.dmark)  
abec 32 62 ee			ld (debug_mark),a  
abef 3a fe ab			ld a, (.dmark+1)  
abf2 32 63 ee			ld (debug_mark+1),a  
abf5 3a ff ab			ld a, (.dmark+2)  
abf8 32 64 ee			ld (debug_mark+2),a  
abfb 18 03			jr .pastdmark  
abfd ..			.dmark: db "Ltp"  
ac00 f1			.pastdmark: pop af  
ac01			endm  
# End of macro DMARK
ac01					CALLMONITOR 
ac01 cd 6f ee			call debug_vector  
ac04				endm  
# End of macro CALLMONITOR
ac04				endif 
ac04			 
ac04 18 22			jr .listpush 
ac06			 
ac06			;.lnuword:	pop hl 
ac06			;		call forth_tok_next 
ac06			;		jp .ldouscan  
ac06			 
ac06			.lunotfound:		  
ac06			 
ac06				if DEBUG_FORTH_WORDS 
ac06					DMARK "LSn" 
ac06 f5				push af  
ac07 3a 1b ac			ld a, (.dmark)  
ac0a 32 62 ee			ld (debug_mark),a  
ac0d 3a 1c ac			ld a, (.dmark+1)  
ac10 32 63 ee			ld (debug_mark+1),a  
ac13 3a 1d ac			ld a, (.dmark+2)  
ac16 32 64 ee			ld (debug_mark+2),a  
ac19 18 03			jr .pastdmark  
ac1b ..			.dmark: db "LSn"  
ac1e f1			.pastdmark: pop af  
ac1f			endm  
# End of macro DMARK
ac1f					CALLMONITOR 
ac1f cd 6f ee			call debug_vector  
ac22				endm  
# End of macro CALLMONITOR
ac22				endif 
ac22			 
ac22					 
ac22			;		FORTH_DSP_POP 
ac22			;		ld hl, .luno 
ac22			 
ac22					NEXTW			 
ac22 cd 6c ee			call parse_vector 
ac25 c3 e5 9d			jp macro_next 
ac28				endm 
# End of macro NEXTW
ac28			 
ac28			.listpush: 
ac28				if DEBUG_FORTH_WORDS 
ac28					DMARK "LS>" 
ac28 f5				push af  
ac29 3a 3d ac			ld a, (.dmark)  
ac2c 32 62 ee			ld (debug_mark),a  
ac2f 3a 3e ac			ld a, (.dmark+1)  
ac32 32 63 ee			ld (debug_mark+1),a  
ac35 3a 3f ac			ld a, (.dmark+2)  
ac38 32 64 ee			ld (debug_mark+2),a  
ac3b 18 03			jr .pastdmark  
ac3d ..			.dmark: db "LS>"  
ac40 f1			.pastdmark: pop af  
ac41			endm  
# End of macro DMARK
ac41					CALLMONITOR 
ac41 cd 6f ee			call debug_vector  
ac44				endm  
# End of macro CALLMONITOR
ac44				endif 
ac44 cd 63 9a				call forth_push_str 
ac47			 
ac47			 
ac47			 
ac47					NEXTW 
ac47 cd 6c ee			call parse_vector 
ac4a c3 e5 9d			jp macro_next 
ac4d				endm 
# End of macro NEXTW
ac4d			 
ac4d			;.luno:    db "Word not found",0 
ac4d			 
ac4d			 
ac4d			 
ac4d			 
ac4d			 
ac4d			;		push hl   ; save pointer to start of uword def string 
ac4d			; 
ac4d			;; look for FORTH_EOL_LINE 
ac4d			;		ld a, FORTH_END_BUFFER 
ac4d			;		call strlent 
ac4d			; 
ac4d			;		inc hl		 ; space for coln def 
ac4d			;		inc hl 
ac4d			;		inc hl          ; space for terms 
ac4d			;		inc hl 
ac4d			; 
ac4d			;		ld a, 20   ; TODO get actual length 
ac4d			;		call addatohl    ; include a random amount of room for the uword name 
ac4d			; 
ac4d			;		 
ac4d			;	if DEBUG_FORTH_WORDS 
ac4d			;		DMARK "Lt1" 
ac4d			;		CALLMONITOR 
ac4d			;	endif 
ac4d			;		 
ac4d			; 
ac4d			;; malloc space for the string because we cant change it 
ac4d			; 
ac4d			;		call malloc 
ac4d			;	if DEBUG_FORTH_MALLOC_GUARD 
ac4d			;		push af 
ac4d			;		call ishlzero 
ac4d			;		pop af 
ac4d			;		 
ac4d			;		call z,malloc_error 
ac4d			;	endif 
ac4d			; 
ac4d			;	if DEBUG_FORTH_WORDS 
ac4d			;		DMARK "Lt2" 
ac4d			;		CALLMONITOR 
ac4d			;	endif 
ac4d			;		pop de 
ac4d			;		push hl    ; push the malloc to release later 
ac4d			;		push hl   ;  push back a copy for the later stack push 
ac4d			;		 
ac4d			;; copy the string swapping out the zero terms for spaces 
ac4d			; 
ac4d			;		; de has our source 
ac4d			;		; hl has our dest 
ac4d			; 
ac4d			;; add the coln def 
ac4d			; 
ac4d			;		ld a, ':' 
ac4d			;		ld (hl), a 
ac4d			;		inc hl 
ac4d			;		ld a, ' ' 
ac4d			;		ld (hl), a 
ac4d			;		inc hl 
ac4d			; 
ac4d			;; add the uname word 
ac4d			;		push de   ; save our string for now 
ac4d			;		ex de, hl 
ac4d			; 
ac4d			;		FORTH_DSP_VALUE 
ac4d			;		;v5 FORTH_DSP_VALUE 
ac4d			; 
ac4d			;		inc hl   ; skip type but we know by now this is OK 
ac4d			; 
ac4d			;.luword:	ld a,(hl) 
ac4d			;		cp 0 
ac4d			;		jr z, .luword2 
ac4d			;		ld (de), a 
ac4d			;		inc de 
ac4d			;		inc hl 
ac4d			;		jr .luword 
ac4d			; 
ac4d			;.luword2:	ld a, ' ' 
ac4d			;		ld (de), a 
ac4d			;;		inc hl 
ac4d			;;		inc de 
ac4d			;;		ld (de), a 
ac4d			;;		inc hl 
ac4d			;		inc de 
ac4d			; 
ac4d			;		ex de, hl 
ac4d			;		pop de 
ac4d			;		 
ac4d			;		 
ac4d			; 
ac4d			;; detoken that string and copy it 
ac4d			; 
ac4d			;	if DEBUG_FORTH_WORDS 
ac4d			;		DMARK "Lt2" 
ac4d			;		CALLMONITOR 
ac4d			;	endif 
ac4d			;.ldetok:	ld a, (de) 
ac4d			;		cp FORTH_END_BUFFER 
ac4d			;		jr z, .ldetokend 
ac4d			;		; swap out any zero term for space 
ac4d			;		cp 0 
ac4d			;		jr nz, .ldetoknext 
ac4d			;		ld a, ' ' 
ac4d			; 
ac4d			;	if DEBUG_FORTH_WORDS 
ac4d			;		DMARK "LtS" 
ac4d			;		CALLMONITOR 
ac4d			;	endif 
ac4d			;.ldetoknext:	ld (hl), a 
ac4d			;		inc de 
ac4d			;		inc hl 
ac4d			;		jr .ldetok 
ac4d			; 
ac4d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
ac4d			;		ld (hl), a  
ac4d			; 
ac4d			;; free that temp malloc 
ac4d			; 
ac4d			;		pop hl    
ac4d			; 
ac4d			;	if DEBUG_FORTH_WORDS 
ac4d			;		DMARK "Lt4" 
ac4d			;		CALLMONITOR 
ac4d			;	endif 
ac4d			;		call forth_apushstrhl 
ac4d			; 
ac4d			;		; get rid of temp malloc area 
ac4d			; 
ac4d			;		pop hl 
ac4d			;		call free 
ac4d			; 
ac4d			;		jr .ludone 
ac4d			; 
ac4d			;.lnuword:	pop hl 
ac4d			;		call forth_tok_next 
ac4d			;		jp .ldouscan  
ac4d			; 
ac4d			;.ludone:		 pop hl 
ac4d			; 
ac4d					NEXTW 
ac4d cd 6c ee			call parse_vector 
ac50 c3 e5 9d			jp macro_next 
ac53				endm 
# End of macro NEXTW
ac53			 
ac53			.FORGET: 
ac53				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
ac53 5d				db WORD_SYS_CORE+73             
ac54 cf ac			dw .NOP            
ac56 07				db 6 + 1 
ac57 .. 00			db "FORGET",0              
ac5e				endm 
# End of macro CWHEAD
ac5e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
ac5e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
ac5e			; | |  
ac5e			; | | e.g. "MORE" forget 
ac5e					if DEBUG_FORTH_WORDS_KEY 
ac5e						DMARK "FRG" 
ac5e f5				push af  
ac5f 3a 73 ac			ld a, (.dmark)  
ac62 32 62 ee			ld (debug_mark),a  
ac65 3a 74 ac			ld a, (.dmark+1)  
ac68 32 63 ee			ld (debug_mark+1),a  
ac6b 3a 75 ac			ld a, (.dmark+2)  
ac6e 32 64 ee			ld (debug_mark+2),a  
ac71 18 03			jr .pastdmark  
ac73 ..			.dmark: db "FRG"  
ac76 f1			.pastdmark: pop af  
ac77			endm  
# End of macro DMARK
ac77						CALLMONITOR 
ac77 cd 6f ee			call debug_vector  
ac7a				endm  
# End of macro CALLMONITOR
ac7a					endif 
ac7a			 
ac7a				; find uword 
ac7a			        ; update start of word with "_" 
ac7a				; replace uword with deleted flag 
ac7a			 
ac7a			 
ac7a			;	if DEBUG_FORTH_WORDS 
ac7a			;		DMARK "FOG" 
ac7a			;		CALLMONITOR 
ac7a			;	endif 
ac7a			 
ac7a			 
ac7a					; Get ptr to the word we need to look up 
ac7a			 
ac7a					FORTH_DSP_VALUEHL 
ac7a cd fa 9b			call macro_dsp_valuehl 
ac7d				endm 
# End of macro FORTH_DSP_VALUEHL
ac7d					;v5 FORTH_DSP_VALUE 
ac7d				; TODO type check 
ac7d			;		inc hl    ; Skip type check  
ac7d e5					push hl 
ac7e c1					pop bc 
ac7f			;		ex de, hl    ; put into DE 
ac7f			 
ac7f			 
ac7f 21 f0 e3				ld hl, baseram 
ac82					;ld hl, baseusermem 
ac82			 
ac82				; skip dict stub 
ac82			;	call forth_tok_next 
ac82 e5			push hl   ; sacreifical push 
ac83			 
ac83			.fldouscanm: 
ac83 e1				pop hl 
ac84			.fldouscan: 
ac84			;	if DEBUG_FORTH_WORDS 
ac84			;		DMARK "LSs" 
ac84			;		CALLMONITOR 
ac84			;	endif 
ac84				; skip dict stub 
ac84 cd 22 9f				call forth_tok_next 
ac87			 
ac87			 
ac87			; while we have words to look for 
ac87			 
ac87 7e				ld a, (hl)      
ac88			;	if DEBUG_FORTH_WORDS 
ac88			;		DMARK "LSk" 
ac88			;		CALLMONITOR 
ac88			;	endif 
ac88 fe 00				cp WORD_SYS_END 
ac8a ca c6 ac				jp z, .flunotfound 
ac8d fe 01				cp WORD_SYS_UWORD 
ac8f c2 84 ac				jp nz, .fldouscan 
ac92			 
ac92			;	if DEBUG_FORTH_WORDS 
ac92			;		DMARK "LSu" 
ac92			;		CALLMONITOR 
ac92			;	endif 
ac92			 
ac92					; found a uword but is it the one we want... 
ac92			 
ac92 c5					push bc     ; uword to find is on bc 
ac93 d1					pop de 
ac94			 
ac94 e5					push hl  ; to save the ptr 
ac95			 
ac95					; skip opcode 
ac95 23					inc hl  
ac96					; skip next ptr 
ac96 23					inc hl  
ac97 23					inc hl 
ac98					; skip len 
ac98 23					inc hl 
ac99			 
ac99			;	if DEBUG_FORTH_WORDS 
ac99			;		DMARK "LSc" 
ac99			;		CALLMONITOR 
ac99			;	endif 
ac99 cd 88 90				call strcmp 
ac9c c2 83 ac				jp nz, .fldouscanm 
ac9f			; 
ac9f			; 
ac9f			;; while we have words to look for 
ac9f			; 
ac9f			;.fdouscan:	ld a, (hl)      
ac9f			;	if DEBUG_FORTH_WORDS 
ac9f			;		DMARK "LSs" 
ac9f			;		CALLMONITOR 
ac9f			;	endif 
ac9f			;		cp WORD_SYS_END 
ac9f			;		jp z, .fudone 
ac9f			;		cp WORD_SYS_UWORD 
ac9f			;		jp nz, .fnuword 
ac9f			; 
ac9f			;	if DEBUG_FORTH_WORDS 
ac9f			;		DMARK "FGu" 
ac9f			;		CALLMONITOR 
ac9f			;	endif 
ac9f			; 
ac9f			;		; found a uword but is it the one we want... 
ac9f			; 
ac9f			; 
ac9f			;	        pop de   ; get back the dsp name 
ac9f			;		push de 
ac9f			; 
ac9f			;		push hl  ; to save the ptr 
ac9f			; 
ac9f			;		; skip opcode 
ac9f			;		inc hl  
ac9f			;		; skip next ptr 
ac9f			;		inc hl  
ac9f			;		inc hl 
ac9f			;		; skip len 
ac9f			;		inc hl 
ac9f			; 
ac9f			;	if DEBUG_FORTH_WORDS 
ac9f			;		DMARK "FGc" 
ac9f			;		CALLMONITOR 
ac9f			;	endif 
ac9f			;		call strcmp 
ac9f			;		jp nz, .fnuword 
ac9f			 
ac9f			 
ac9f e1			pop hl 
aca0			 
aca0				 
aca0				if DEBUG_FORTH_WORDS 
aca0					DMARK "FGm" 
aca0 f5				push af  
aca1 3a b5 ac			ld a, (.dmark)  
aca4 32 62 ee			ld (debug_mark),a  
aca7 3a b6 ac			ld a, (.dmark+1)  
acaa 32 63 ee			ld (debug_mark+1),a  
acad 3a b7 ac			ld a, (.dmark+2)  
acb0 32 64 ee			ld (debug_mark+2),a  
acb3 18 03			jr .pastdmark  
acb5 ..			.dmark: db "FGm"  
acb8 f1			.pastdmark: pop af  
acb9			endm  
# End of macro DMARK
acb9					CALLMONITOR 
acb9 cd 6f ee			call debug_vector  
acbc				endm  
# End of macro CALLMONITOR
acbc				endif 
acbc			 
acbc			 
acbc			 
acbc					; we have a uword so push its name to the stack 
acbc			 
acbc			;	   	push hl  ; save so we can move to next dict block 
acbc			;pop hl 
acbc			 
acbc					; update opcode to deleted 
acbc 3e 03				ld a, WORD_SYS_DELETED 
acbe 77					ld (hl), a 
acbf			 
acbf 23					inc hl  
acc0					; skip next ptr 
acc0 23					inc hl  
acc1 23					inc hl 
acc2					; skip len 
acc2 23					inc hl 
acc3			 
acc3					; TODO change parser to skip deleted words but for now mark it out 
acc3 3e 5f				ld a, "_" 
acc5 77					ld  (hl),a 
acc6			 
acc6			;		jr .fudone 
acc6			; 
acc6			;.fnuword:	pop hl 
acc6			;		call forth_tok_next 
acc6			;		jp .fdouscan  
acc6			 
acc6			.flunotfound:		  
acc6			 
acc6			 
acc6					 
acc6					FORTH_DSP_POP 
acc6 cd b2 9c			call macro_forth_dsp_pop 
acc9				endm 
# End of macro FORTH_DSP_POP
acc9			;		ld hl, .luno 
acc9			;.fudone:		 pop hl 
acc9					NEXTW 
acc9 cd 6c ee			call parse_vector 
accc c3 e5 9d			jp macro_next 
accf				endm 
# End of macro NEXTW
accf			.NOP: 
accf				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
accf 61				db WORD_SYS_CORE+77             
acd0 f9 ac			dw .COMO            
acd2 04				db 3 + 1 
acd3 .. 00			db "NOP",0              
acd7				endm 
# End of macro CWHEAD
acd7			; | NOP (  --  ) Do nothing | DONE 
acd7					if DEBUG_FORTH_WORDS_KEY 
acd7						DMARK "NOP" 
acd7 f5				push af  
acd8 3a ec ac			ld a, (.dmark)  
acdb 32 62 ee			ld (debug_mark),a  
acde 3a ed ac			ld a, (.dmark+1)  
ace1 32 63 ee			ld (debug_mark+1),a  
ace4 3a ee ac			ld a, (.dmark+2)  
ace7 32 64 ee			ld (debug_mark+2),a  
acea 18 03			jr .pastdmark  
acec ..			.dmark: db "NOP"  
acef f1			.pastdmark: pop af  
acf0			endm  
# End of macro DMARK
acf0						CALLMONITOR 
acf0 cd 6f ee			call debug_vector  
acf3				endm  
# End of macro CALLMONITOR
acf3					endif 
acf3				       NEXTW 
acf3 cd 6c ee			call parse_vector 
acf6 c3 e5 9d			jp macro_next 
acf9				endm 
# End of macro NEXTW
acf9			.COMO: 
acf9				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
acf9 6e				db WORD_SYS_CORE+90             
acfa 4e ad			dw .COMC            
acfc 02				db 1 + 1 
acfd .. 00			db "(",0              
acff				endm 
# End of macro CWHEAD
acff			; | ( ( -- )  Start of comment | DONE 
acff			 
acff			 
acff 2a b9 e5				ld hl, ( os_tok_ptr) 
ad02 11 46 ad			ld de, .closepar 
ad05					 
ad05					if DEBUG_FORTH_WORDS 
ad05						DMARK ").." 
ad05 f5				push af  
ad06 3a 1a ad			ld a, (.dmark)  
ad09 32 62 ee			ld (debug_mark),a  
ad0c 3a 1b ad			ld a, (.dmark+1)  
ad0f 32 63 ee			ld (debug_mark+1),a  
ad12 3a 1c ad			ld a, (.dmark+2)  
ad15 32 64 ee			ld (debug_mark+2),a  
ad18 18 03			jr .pastdmark  
ad1a ..			.dmark: db ").."  
ad1d f1			.pastdmark: pop af  
ad1e			endm  
# End of macro DMARK
ad1e						CALLMONITOR 
ad1e cd 6f ee			call debug_vector  
ad21				endm  
# End of macro CALLMONITOR
ad21					endif 
ad21 cd ec 9e			call findnexttok  
ad24			 
ad24					if DEBUG_FORTH_WORDS 
ad24						DMARK "IF5" 
ad24 f5				push af  
ad25 3a 39 ad			ld a, (.dmark)  
ad28 32 62 ee			ld (debug_mark),a  
ad2b 3a 3a ad			ld a, (.dmark+1)  
ad2e 32 63 ee			ld (debug_mark+1),a  
ad31 3a 3b ad			ld a, (.dmark+2)  
ad34 32 64 ee			ld (debug_mark+2),a  
ad37 18 03			jr .pastdmark  
ad39 ..			.dmark: db "IF5"  
ad3c f1			.pastdmark: pop af  
ad3d			endm  
# End of macro DMARK
ad3d						CALLMONITOR 
ad3d cd 6f ee			call debug_vector  
ad40				endm  
# End of macro CALLMONITOR
ad40					endif 
ad40				; replace below with ) exec using tok_ptr 
ad40 22 b9 e5			ld (os_tok_ptr), hl 
ad43 c3 6e 9e			jp exec1 
ad46			 
ad46 .. 00			.closepar:   db ")",0 
ad48			 
ad48				       NEXTW 
ad48 cd 6c ee			call parse_vector 
ad4b c3 e5 9d			jp macro_next 
ad4e				endm 
# End of macro NEXTW
ad4e			.COMC: 
ad4e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ad4e 6f				db WORD_SYS_CORE+91             
ad4f 5a ad			dw .SCRATCH            
ad51 02				db 1 + 1 
ad52 .. 00			db ")",0              
ad54				endm 
# End of macro CWHEAD
ad54			; | ) ( -- )  End of comment |  DONE  
ad54				       NEXTW 
ad54 cd 6c ee			call parse_vector 
ad57 c3 e5 9d			jp macro_next 
ad5a				endm 
# End of macro NEXTW
ad5a			 
ad5a			.SCRATCH: 
ad5a				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ad5a 6f				db WORD_SYS_CORE+91             
ad5b 98 ad			dw .INC            
ad5d 08				db 7 + 1 
ad5e .. 00			db "SCRATCH",0              
ad66				endm 
# End of macro CWHEAD
ad66			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ad66			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ad66			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ad66			; | |  
ad66			; | | e.g.    : score $00 scratch ; 
ad66			; | |  
ad66			; | | $00 score ! 
ad66			; | | $01 score +! 
ad66			; | |  
ad66			; | | e.g.   : varword $0a scratch ;  
ad66			; | | 
ad66			; | | $8000 varword ! 
ad66					if DEBUG_FORTH_WORDS_KEY 
ad66						DMARK "SCR" 
ad66 f5				push af  
ad67 3a 7b ad			ld a, (.dmark)  
ad6a 32 62 ee			ld (debug_mark),a  
ad6d 3a 7c ad			ld a, (.dmark+1)  
ad70 32 63 ee			ld (debug_mark+1),a  
ad73 3a 7d ad			ld a, (.dmark+2)  
ad76 32 64 ee			ld (debug_mark+2),a  
ad79 18 03			jr .pastdmark  
ad7b ..			.dmark: db "SCR"  
ad7e f1			.pastdmark: pop af  
ad7f			endm  
# End of macro DMARK
ad7f						CALLMONITOR 
ad7f cd 6f ee			call debug_vector  
ad82				endm  
# End of macro CALLMONITOR
ad82					endif 
ad82			 
ad82					FORTH_DSP_VALUEHL 
ad82 cd fa 9b			call macro_dsp_valuehl 
ad85				endm 
# End of macro FORTH_DSP_VALUEHL
ad85				 
ad85					FORTH_DSP_POP 
ad85 cd b2 9c			call macro_forth_dsp_pop 
ad88				endm 
# End of macro FORTH_DSP_POP
ad88			 
ad88 7d					ld a, l 
ad89 21 dd e7				ld hl, os_var_array 
ad8c cd ea 8c				call addatohl 
ad8f			 
ad8f cd f5 99				call forth_push_numhl 
ad92			 
ad92				       NEXTW 
ad92 cd 6c ee			call parse_vector 
ad95 c3 e5 9d			jp macro_next 
ad98				endm 
# End of macro NEXTW
ad98			 
ad98			.INC: 
ad98				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ad98 6f				db WORD_SYS_CORE+91             
ad99 f1 ad			dw .DEC            
ad9b 03				db 2 + 1 
ad9c .. 00			db "+!",0              
ad9f				endm 
# End of macro CWHEAD
ad9f			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ad9f					if DEBUG_FORTH_WORDS_KEY 
ad9f						DMARK "+s_" 
ad9f f5				push af  
ada0 3a b4 ad			ld a, (.dmark)  
ada3 32 62 ee			ld (debug_mark),a  
ada6 3a b5 ad			ld a, (.dmark+1)  
ada9 32 63 ee			ld (debug_mark+1),a  
adac 3a b6 ad			ld a, (.dmark+2)  
adaf 32 64 ee			ld (debug_mark+2),a  
adb2 18 03			jr .pastdmark  
adb4 ..			.dmark: db "+s_"  
adb7 f1			.pastdmark: pop af  
adb8			endm  
# End of macro DMARK
adb8						CALLMONITOR 
adb8 cd 6f ee			call debug_vector  
adbb				endm  
# End of macro CALLMONITOR
adbb					endif 
adbb			 
adbb					FORTH_DSP_VALUEHL 
adbb cd fa 9b			call macro_dsp_valuehl 
adbe				endm 
# End of macro FORTH_DSP_VALUEHL
adbe			 
adbe e5					push hl   ; save address 
adbf			 
adbf					FORTH_DSP_POP 
adbf cd b2 9c			call macro_forth_dsp_pop 
adc2				endm 
# End of macro FORTH_DSP_POP
adc2			 
adc2					FORTH_DSP_VALUEHL 
adc2 cd fa 9b			call macro_dsp_valuehl 
adc5				endm 
# End of macro FORTH_DSP_VALUEHL
adc5			 
adc5 e5					push hl 
adc6					FORTH_DSP_POP 
adc6 cd b2 9c			call macro_forth_dsp_pop 
adc9				endm 
# End of macro FORTH_DSP_POP
adc9 e1					pop hl 
adca			 
adca					; hl contains value to add to byte at a 
adca				 
adca eb					ex de, hl 
adcb			 
adcb e1					pop hl 
adcc			 
adcc					if DEBUG_FORTH_WORDS 
adcc						DMARK "INC" 
adcc f5				push af  
adcd 3a e1 ad			ld a, (.dmark)  
add0 32 62 ee			ld (debug_mark),a  
add3 3a e2 ad			ld a, (.dmark+1)  
add6 32 63 ee			ld (debug_mark+1),a  
add9 3a e3 ad			ld a, (.dmark+2)  
addc 32 64 ee			ld (debug_mark+2),a  
addf 18 03			jr .pastdmark  
ade1 ..			.dmark: db "INC"  
ade4 f1			.pastdmark: pop af  
ade5			endm  
# End of macro DMARK
ade5						CALLMONITOR 
ade5 cd 6f ee			call debug_vector  
ade8				endm  
# End of macro CALLMONITOR
ade8					endif 
ade8			 
ade8 7e					ld a,(hl) 
ade9 83					add e 
adea 77					ld (hl),a 
adeb			 
adeb			 
adeb			 
adeb				       NEXTW 
adeb cd 6c ee			call parse_vector 
adee c3 e5 9d			jp macro_next 
adf1				endm 
# End of macro NEXTW
adf1			 
adf1			.DEC: 
adf1				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
adf1 6f				db WORD_SYS_CORE+91             
adf2 48 ae			dw .INC2            
adf4 03				db 2 + 1 
adf5 .. 00			db "-!",0              
adf8				endm 
# End of macro CWHEAD
adf8			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
adf8					if DEBUG_FORTH_WORDS_KEY 
adf8						DMARK "-s_" 
adf8 f5				push af  
adf9 3a 0d ae			ld a, (.dmark)  
adfc 32 62 ee			ld (debug_mark),a  
adff 3a 0e ae			ld a, (.dmark+1)  
ae02 32 63 ee			ld (debug_mark+1),a  
ae05 3a 0f ae			ld a, (.dmark+2)  
ae08 32 64 ee			ld (debug_mark+2),a  
ae0b 18 03			jr .pastdmark  
ae0d ..			.dmark: db "-s_"  
ae10 f1			.pastdmark: pop af  
ae11			endm  
# End of macro DMARK
ae11						CALLMONITOR 
ae11 cd 6f ee			call debug_vector  
ae14				endm  
# End of macro CALLMONITOR
ae14					endif 
ae14			 
ae14					FORTH_DSP_VALUEHL 
ae14 cd fa 9b			call macro_dsp_valuehl 
ae17				endm 
# End of macro FORTH_DSP_VALUEHL
ae17			 
ae17 e5					push hl   ; save address 
ae18			 
ae18					FORTH_DSP_POP 
ae18 cd b2 9c			call macro_forth_dsp_pop 
ae1b				endm 
# End of macro FORTH_DSP_POP
ae1b			 
ae1b					FORTH_DSP_VALUEHL 
ae1b cd fa 9b			call macro_dsp_valuehl 
ae1e				endm 
# End of macro FORTH_DSP_VALUEHL
ae1e			 
ae1e					; hl contains value to add to byte at a 
ae1e				 
ae1e eb					ex de, hl 
ae1f			 
ae1f e1					pop hl 
ae20			 
ae20					if DEBUG_FORTH_WORDS 
ae20						DMARK "DEC" 
ae20 f5				push af  
ae21 3a 35 ae			ld a, (.dmark)  
ae24 32 62 ee			ld (debug_mark),a  
ae27 3a 36 ae			ld a, (.dmark+1)  
ae2a 32 63 ee			ld (debug_mark+1),a  
ae2d 3a 37 ae			ld a, (.dmark+2)  
ae30 32 64 ee			ld (debug_mark+2),a  
ae33 18 03			jr .pastdmark  
ae35 ..			.dmark: db "DEC"  
ae38 f1			.pastdmark: pop af  
ae39			endm  
# End of macro DMARK
ae39						CALLMONITOR 
ae39 cd 6f ee			call debug_vector  
ae3c				endm  
# End of macro CALLMONITOR
ae3c					endif 
ae3c			 
ae3c 7e					ld a,(hl) 
ae3d 93					sub e 
ae3e 77					ld (hl),a 
ae3f			 
ae3f			 
ae3f					FORTH_DSP_POP 
ae3f cd b2 9c			call macro_forth_dsp_pop 
ae42				endm 
# End of macro FORTH_DSP_POP
ae42			 
ae42				       NEXTW 
ae42 cd 6c ee			call parse_vector 
ae45 c3 e5 9d			jp macro_next 
ae48				endm 
# End of macro NEXTW
ae48			 
ae48			.INC2: 
ae48				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ae48 6f				db WORD_SYS_CORE+91             
ae49 f8 ae			dw .DEC2            
ae4b 04				db 3 + 1 
ae4c .. 00			db "+2!",0              
ae50				endm 
# End of macro CWHEAD
ae50			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ae50			 
ae50					if DEBUG_FORTH_WORDS_KEY 
ae50						DMARK "+2s" 
ae50 f5				push af  
ae51 3a 65 ae			ld a, (.dmark)  
ae54 32 62 ee			ld (debug_mark),a  
ae57 3a 66 ae			ld a, (.dmark+1)  
ae5a 32 63 ee			ld (debug_mark+1),a  
ae5d 3a 67 ae			ld a, (.dmark+2)  
ae60 32 64 ee			ld (debug_mark+2),a  
ae63 18 03			jr .pastdmark  
ae65 ..			.dmark: db "+2s"  
ae68 f1			.pastdmark: pop af  
ae69			endm  
# End of macro DMARK
ae69						CALLMONITOR 
ae69 cd 6f ee			call debug_vector  
ae6c				endm  
# End of macro CALLMONITOR
ae6c					endif 
ae6c			 
ae6c					; Address 
ae6c			 
ae6c					FORTH_DSP_VALUEHL 
ae6c cd fa 9b			call macro_dsp_valuehl 
ae6f				endm 
# End of macro FORTH_DSP_VALUEHL
ae6f			 
ae6f e5					push hl    ; save address 
ae70			 
ae70					; load content into de 
ae70			 
ae70 5e					ld e,(hl) 
ae71 23					inc hl 
ae72 56					ld d, (hl) 
ae73			 
ae73					if DEBUG_FORTH_WORDS 
ae73						DMARK "+2a" 
ae73 f5				push af  
ae74 3a 88 ae			ld a, (.dmark)  
ae77 32 62 ee			ld (debug_mark),a  
ae7a 3a 89 ae			ld a, (.dmark+1)  
ae7d 32 63 ee			ld (debug_mark+1),a  
ae80 3a 8a ae			ld a, (.dmark+2)  
ae83 32 64 ee			ld (debug_mark+2),a  
ae86 18 03			jr .pastdmark  
ae88 ..			.dmark: db "+2a"  
ae8b f1			.pastdmark: pop af  
ae8c			endm  
# End of macro DMARK
ae8c						CALLMONITOR 
ae8c cd 6f ee			call debug_vector  
ae8f				endm  
# End of macro CALLMONITOR
ae8f					endif 
ae8f			 
ae8f					FORTH_DSP_POP 
ae8f cd b2 9c			call macro_forth_dsp_pop 
ae92				endm 
# End of macro FORTH_DSP_POP
ae92			 
ae92					; Get value to add 
ae92			 
ae92					FORTH_DSP_VALUE 
ae92 cd e3 9b			call macro_forth_dsp_value 
ae95				endm 
# End of macro FORTH_DSP_VALUE
ae95			 
ae95					if DEBUG_FORTH_WORDS 
ae95						DMARK "+2v" 
ae95 f5				push af  
ae96 3a aa ae			ld a, (.dmark)  
ae99 32 62 ee			ld (debug_mark),a  
ae9c 3a ab ae			ld a, (.dmark+1)  
ae9f 32 63 ee			ld (debug_mark+1),a  
aea2 3a ac ae			ld a, (.dmark+2)  
aea5 32 64 ee			ld (debug_mark+2),a  
aea8 18 03			jr .pastdmark  
aeaa ..			.dmark: db "+2v"  
aead f1			.pastdmark: pop af  
aeae			endm  
# End of macro DMARK
aeae						CALLMONITOR 
aeae cd 6f ee			call debug_vector  
aeb1				endm  
# End of macro CALLMONITOR
aeb1					endif 
aeb1			 
aeb1 19					add hl, de 
aeb2			 
aeb2					if DEBUG_FORTH_WORDS 
aeb2						DMARK "+2+" 
aeb2 f5				push af  
aeb3 3a c7 ae			ld a, (.dmark)  
aeb6 32 62 ee			ld (debug_mark),a  
aeb9 3a c8 ae			ld a, (.dmark+1)  
aebc 32 63 ee			ld (debug_mark+1),a  
aebf 3a c9 ae			ld a, (.dmark+2)  
aec2 32 64 ee			ld (debug_mark+2),a  
aec5 18 03			jr .pastdmark  
aec7 ..			.dmark: db "+2+"  
aeca f1			.pastdmark: pop af  
aecb			endm  
# End of macro DMARK
aecb						CALLMONITOR 
aecb cd 6f ee			call debug_vector  
aece				endm  
# End of macro CALLMONITOR
aece					endif 
aece			 
aece					; move result to de 
aece			 
aece eb					ex de, hl 
aecf			 
aecf					; Address 
aecf			 
aecf e1					pop hl 
aed0			 
aed0					; save it back 
aed0			 
aed0 73					ld (hl), e 
aed1 23					inc hl 
aed2 72					ld (hl), d 
aed3			 
aed3					if DEBUG_FORTH_WORDS 
aed3						DMARK "+2e" 
aed3 f5				push af  
aed4 3a e8 ae			ld a, (.dmark)  
aed7 32 62 ee			ld (debug_mark),a  
aeda 3a e9 ae			ld a, (.dmark+1)  
aedd 32 63 ee			ld (debug_mark+1),a  
aee0 3a ea ae			ld a, (.dmark+2)  
aee3 32 64 ee			ld (debug_mark+2),a  
aee6 18 03			jr .pastdmark  
aee8 ..			.dmark: db "+2e"  
aeeb f1			.pastdmark: pop af  
aeec			endm  
# End of macro DMARK
aeec						CALLMONITOR 
aeec cd 6f ee			call debug_vector  
aeef				endm  
# End of macro CALLMONITOR
aeef					endif 
aeef			 
aeef			 
aeef			 
aeef					FORTH_DSP_POP 
aeef cd b2 9c			call macro_forth_dsp_pop 
aef2				endm 
# End of macro FORTH_DSP_POP
aef2			 
aef2			 
aef2				       NEXTW 
aef2 cd 6c ee			call parse_vector 
aef5 c3 e5 9d			jp macro_next 
aef8				endm 
# End of macro NEXTW
aef8			 
aef8			.DEC2: 
aef8				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aef8 6f				db WORD_SYS_CORE+91             
aef9 aa af			dw .GET2            
aefb 04				db 3 + 1 
aefc .. 00			db "-2!",0              
af00				endm 
# End of macro CWHEAD
af00			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
af00			 
af00			 
af00					if DEBUG_FORTH_WORDS_KEY 
af00						DMARK "-2s" 
af00 f5				push af  
af01 3a 15 af			ld a, (.dmark)  
af04 32 62 ee			ld (debug_mark),a  
af07 3a 16 af			ld a, (.dmark+1)  
af0a 32 63 ee			ld (debug_mark+1),a  
af0d 3a 17 af			ld a, (.dmark+2)  
af10 32 64 ee			ld (debug_mark+2),a  
af13 18 03			jr .pastdmark  
af15 ..			.dmark: db "-2s"  
af18 f1			.pastdmark: pop af  
af19			endm  
# End of macro DMARK
af19						CALLMONITOR 
af19 cd 6f ee			call debug_vector  
af1c				endm  
# End of macro CALLMONITOR
af1c					endif 
af1c			 
af1c					; Address 
af1c			 
af1c					FORTH_DSP_VALUEHL 
af1c cd fa 9b			call macro_dsp_valuehl 
af1f				endm 
# End of macro FORTH_DSP_VALUEHL
af1f			 
af1f e5					push hl    ; save address 
af20			 
af20					; load content into de 
af20			 
af20 5e					ld e,(hl) 
af21 23					inc hl 
af22 56					ld d, (hl) 
af23			 
af23					if DEBUG_FORTH_WORDS 
af23						DMARK "-2a" 
af23 f5				push af  
af24 3a 38 af			ld a, (.dmark)  
af27 32 62 ee			ld (debug_mark),a  
af2a 3a 39 af			ld a, (.dmark+1)  
af2d 32 63 ee			ld (debug_mark+1),a  
af30 3a 3a af			ld a, (.dmark+2)  
af33 32 64 ee			ld (debug_mark+2),a  
af36 18 03			jr .pastdmark  
af38 ..			.dmark: db "-2a"  
af3b f1			.pastdmark: pop af  
af3c			endm  
# End of macro DMARK
af3c						CALLMONITOR 
af3c cd 6f ee			call debug_vector  
af3f				endm  
# End of macro CALLMONITOR
af3f					endif 
af3f			 
af3f					FORTH_DSP_POP 
af3f cd b2 9c			call macro_forth_dsp_pop 
af42				endm 
# End of macro FORTH_DSP_POP
af42			 
af42					; Get value to remove 
af42			 
af42					FORTH_DSP_VALUE 
af42 cd e3 9b			call macro_forth_dsp_value 
af45				endm 
# End of macro FORTH_DSP_VALUE
af45			 
af45					if DEBUG_FORTH_WORDS 
af45						DMARK "-2v" 
af45 f5				push af  
af46 3a 5a af			ld a, (.dmark)  
af49 32 62 ee			ld (debug_mark),a  
af4c 3a 5b af			ld a, (.dmark+1)  
af4f 32 63 ee			ld (debug_mark+1),a  
af52 3a 5c af			ld a, (.dmark+2)  
af55 32 64 ee			ld (debug_mark+2),a  
af58 18 03			jr .pastdmark  
af5a ..			.dmark: db "-2v"  
af5d f1			.pastdmark: pop af  
af5e			endm  
# End of macro DMARK
af5e						CALLMONITOR 
af5e cd 6f ee			call debug_vector  
af61				endm  
# End of macro CALLMONITOR
af61					endif 
af61			 
af61 eb					ex de, hl 
af62 ed 52				sbc hl, de 
af64			 
af64					if DEBUG_FORTH_WORDS 
af64						DMARK "-2d" 
af64 f5				push af  
af65 3a 79 af			ld a, (.dmark)  
af68 32 62 ee			ld (debug_mark),a  
af6b 3a 7a af			ld a, (.dmark+1)  
af6e 32 63 ee			ld (debug_mark+1),a  
af71 3a 7b af			ld a, (.dmark+2)  
af74 32 64 ee			ld (debug_mark+2),a  
af77 18 03			jr .pastdmark  
af79 ..			.dmark: db "-2d"  
af7c f1			.pastdmark: pop af  
af7d			endm  
# End of macro DMARK
af7d						CALLMONITOR 
af7d cd 6f ee			call debug_vector  
af80				endm  
# End of macro CALLMONITOR
af80					endif 
af80			 
af80					; move result to de 
af80			 
af80 eb					ex de, hl 
af81			 
af81					; Address 
af81			 
af81 e1					pop hl 
af82			 
af82					; save it back 
af82			 
af82 73					ld (hl), e 
af83 23					inc hl 
af84 72					ld (hl), d 
af85			 
af85					if DEBUG_FORTH_WORDS 
af85						DMARK "-2e" 
af85 f5				push af  
af86 3a 9a af			ld a, (.dmark)  
af89 32 62 ee			ld (debug_mark),a  
af8c 3a 9b af			ld a, (.dmark+1)  
af8f 32 63 ee			ld (debug_mark+1),a  
af92 3a 9c af			ld a, (.dmark+2)  
af95 32 64 ee			ld (debug_mark+2),a  
af98 18 03			jr .pastdmark  
af9a ..			.dmark: db "-2e"  
af9d f1			.pastdmark: pop af  
af9e			endm  
# End of macro DMARK
af9e						CALLMONITOR 
af9e cd 6f ee			call debug_vector  
afa1				endm  
# End of macro CALLMONITOR
afa1					endif 
afa1			 
afa1			 
afa1					FORTH_DSP_POP 
afa1 cd b2 9c			call macro_forth_dsp_pop 
afa4				endm 
# End of macro FORTH_DSP_POP
afa4			 
afa4			 
afa4			 
afa4				       NEXTW 
afa4 cd 6c ee			call parse_vector 
afa7 c3 e5 9d			jp macro_next 
afaa				endm 
# End of macro NEXTW
afaa			.GET2: 
afaa				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
afaa 6f				db WORD_SYS_CORE+91             
afab e2 af			dw .BANG2            
afad 03				db 2 + 1 
afae .. 00			db "2@",0              
afb1				endm 
# End of macro CWHEAD
afb1			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
afb1					if DEBUG_FORTH_WORDS_KEY 
afb1						DMARK "2A_" 
afb1 f5				push af  
afb2 3a c6 af			ld a, (.dmark)  
afb5 32 62 ee			ld (debug_mark),a  
afb8 3a c7 af			ld a, (.dmark+1)  
afbb 32 63 ee			ld (debug_mark+1),a  
afbe 3a c8 af			ld a, (.dmark+2)  
afc1 32 64 ee			ld (debug_mark+2),a  
afc4 18 03			jr .pastdmark  
afc6 ..			.dmark: db "2A_"  
afc9 f1			.pastdmark: pop af  
afca			endm  
# End of macro DMARK
afca						CALLMONITOR 
afca cd 6f ee			call debug_vector  
afcd				endm  
# End of macro CALLMONITOR
afcd					endif 
afcd			 
afcd					FORTH_DSP_VALUEHL 
afcd cd fa 9b			call macro_dsp_valuehl 
afd0				endm 
# End of macro FORTH_DSP_VALUEHL
afd0			 
afd0 e5					push hl   ; save address 
afd1			 
afd1					FORTH_DSP_POP 
afd1 cd b2 9c			call macro_forth_dsp_pop 
afd4				endm 
# End of macro FORTH_DSP_POP
afd4			 
afd4 e1					pop hl 
afd5			 
afd5 5e					ld e, (hl) 
afd6 23					inc hl 
afd7 56					ld d, (hl) 
afd8			 
afd8 eb					ex de, hl 
afd9			 
afd9 cd f5 99				call forth_push_numhl 
afdc			 
afdc				       NEXTW 
afdc cd 6c ee			call parse_vector 
afdf c3 e5 9d			jp macro_next 
afe2				endm 
# End of macro NEXTW
afe2			.BANG2: 
afe2				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
afe2 6f				db WORD_SYS_CORE+91             
afe3 1d b0			dw .CONFIG            
afe5 03				db 2 + 1 
afe6 .. 00			db "2!",0              
afe9				endm 
# End of macro CWHEAD
afe9			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
afe9					if DEBUG_FORTH_WORDS_KEY 
afe9						DMARK "2S_" 
afe9 f5				push af  
afea 3a fe af			ld a, (.dmark)  
afed 32 62 ee			ld (debug_mark),a  
aff0 3a ff af			ld a, (.dmark+1)  
aff3 32 63 ee			ld (debug_mark+1),a  
aff6 3a 00 b0			ld a, (.dmark+2)  
aff9 32 64 ee			ld (debug_mark+2),a  
affc 18 03			jr .pastdmark  
affe ..			.dmark: db "2S_"  
b001 f1			.pastdmark: pop af  
b002			endm  
# End of macro DMARK
b002						CALLMONITOR 
b002 cd 6f ee			call debug_vector  
b005				endm  
# End of macro CALLMONITOR
b005					endif 
b005			 
b005					FORTH_DSP_VALUEHL 
b005 cd fa 9b			call macro_dsp_valuehl 
b008				endm 
# End of macro FORTH_DSP_VALUEHL
b008			 
b008 e5					push hl   ; save address 
b009			 
b009			 
b009					FORTH_DSP_POP 
b009 cd b2 9c			call macro_forth_dsp_pop 
b00c				endm 
# End of macro FORTH_DSP_POP
b00c			 
b00c					 
b00c					FORTH_DSP_VALUEHL 
b00c cd fa 9b			call macro_dsp_valuehl 
b00f				endm 
# End of macro FORTH_DSP_VALUEHL
b00f			 
b00f					FORTH_DSP_POP 
b00f cd b2 9c			call macro_forth_dsp_pop 
b012				endm 
# End of macro FORTH_DSP_POP
b012			 
b012 eb					ex de, hl    ; value now in de 
b013			 
b013 e1					pop hl 
b014			 
b014 73					ld (hl), e 
b015			 
b015 23					inc hl 
b016			 
b016 72					ld (hl), d 
b017			 
b017			 
b017				       NEXTW 
b017 cd 6c ee			call parse_vector 
b01a c3 e5 9d			jp macro_next 
b01d				endm 
# End of macro NEXTW
b01d			.CONFIG: 
b01d				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
b01d 6f				db WORD_SYS_CORE+91             
b01e 31 b0			dw .ADTOS            
b020 07				db 6 + 1 
b021 .. 00			db "CONFIG",0              
b028				endm 
# End of macro CWHEAD
b028			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
b028			 
b028 cd 5e 92				call config 
b02b					NEXTW 
b02b cd 6c ee			call parse_vector 
b02e c3 e5 9d			jp macro_next 
b031				endm 
# End of macro NEXTW
b031			 
b031			.ADTOS: 
b031				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
b031 6f				db WORD_SYS_CORE+91             
b032 4a b0			dw .SBTOS            
b034 03				db 2 + 1 
b035 .. 00			db "1+",0              
b038				endm 
# End of macro CWHEAD
b038			; | 1+ ( u -- u )  Increment value on TOS | DONE 
b038			 
b038					FORTH_DSP_VALUEHL 
b038 cd fa 9b			call macro_dsp_valuehl 
b03b				endm 
# End of macro FORTH_DSP_VALUEHL
b03b e5					push hl 
b03c			 
b03c					FORTH_DSP_POP 
b03c cd b2 9c			call macro_forth_dsp_pop 
b03f				endm 
# End of macro FORTH_DSP_POP
b03f e1					pop hl 
b040			 
b040 23					inc hl 
b041 cd f5 99				call forth_push_numhl 
b044					 
b044					NEXTW 
b044 cd 6c ee			call parse_vector 
b047 c3 e5 9d			jp macro_next 
b04a				endm 
# End of macro NEXTW
b04a			.SBTOS: 
b04a				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
b04a 6f				db WORD_SYS_CORE+91             
b04b 63 b0			dw .ADSTORE            
b04d 03				db 2 + 1 
b04e .. 00			db "1-",0              
b051				endm 
# End of macro CWHEAD
b051			; | 1- ( u -- u )  Decrement value on TOS | DONE 
b051			 
b051					FORTH_DSP_VALUEHL 
b051 cd fa 9b			call macro_dsp_valuehl 
b054				endm 
# End of macro FORTH_DSP_VALUEHL
b054 e5					push hl 
b055			 
b055					FORTH_DSP_POP 
b055 cd b2 9c			call macro_forth_dsp_pop 
b058				endm 
# End of macro FORTH_DSP_POP
b058 e1					pop hl 
b059			 
b059 2b					dec hl 
b05a cd f5 99				call forth_push_numhl 
b05d					 
b05d					NEXTW 
b05d cd 6c ee			call parse_vector 
b060 c3 e5 9d			jp macro_next 
b063				endm 
# End of macro NEXTW
b063			.ADSTORE: 
b063				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
b063 6f				db WORD_SYS_CORE+91             
b064 7c b0			dw .ADWSTORE            
b066 04				db 3 + 1 
b067 .. 00			db "1+!",0              
b06b				endm 
# End of macro CWHEAD
b06b			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
b06b			 
b06b					FORTH_DSP_VALUEHL 
b06b cd fa 9b			call macro_dsp_valuehl 
b06e				endm 
# End of macro FORTH_DSP_VALUEHL
b06e e5					push hl 
b06f			 
b06f					FORTH_DSP_POP 
b06f cd b2 9c			call macro_forth_dsp_pop 
b072				endm 
# End of macro FORTH_DSP_POP
b072 e1					pop hl 
b073			 
b073 7e					ld a, (hl) 
b074 3c					inc a 
b075 77					ld (hl), a 
b076					 
b076					NEXTW 
b076 cd 6c ee			call parse_vector 
b079 c3 e5 9d			jp macro_next 
b07c				endm 
# End of macro NEXTW
b07c			.ADWSTORE: 
b07c				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
b07c 6f				db WORD_SYS_CORE+91             
b07d 9d b0			dw .SBSTORE            
b07f 05				db 4 + 1 
b080 .. 00			db "1+2!",0              
b085				endm 
# End of macro CWHEAD
b085			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
b085			 
b085					FORTH_DSP_VALUEHL 
b085 cd fa 9b			call macro_dsp_valuehl 
b088				endm 
# End of macro FORTH_DSP_VALUEHL
b088 e5					push hl 
b089			 
b089					FORTH_DSP_POP 
b089 cd b2 9c			call macro_forth_dsp_pop 
b08c				endm 
# End of macro FORTH_DSP_POP
b08c e1					pop hl 
b08d			 
b08d e5					push hl 
b08e			 
b08e cd 67 9d				call loadwordinhl 
b091 23					inc hl 
b092			 
b092 d1					pop de 
b093 eb					ex de, hl 
b094 73					ld (hl), e 
b095 23					inc hl 
b096 72					ld (hl), d 
b097					 
b097					NEXTW 
b097 cd 6c ee			call parse_vector 
b09a c3 e5 9d			jp macro_next 
b09d				endm 
# End of macro NEXTW
b09d			.SBSTORE: 
b09d				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
b09d 6f				db WORD_SYS_CORE+91             
b09e b6 b0			dw .SBWSTORE            
b0a0 04				db 3 + 1 
b0a1 .. 00			db "1-!",0              
b0a5				endm 
# End of macro CWHEAD
b0a5			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
b0a5			 
b0a5					FORTH_DSP_VALUEHL 
b0a5 cd fa 9b			call macro_dsp_valuehl 
b0a8				endm 
# End of macro FORTH_DSP_VALUEHL
b0a8 e5					push hl 
b0a9			 
b0a9					FORTH_DSP_POP 
b0a9 cd b2 9c			call macro_forth_dsp_pop 
b0ac				endm 
# End of macro FORTH_DSP_POP
b0ac e1					pop hl 
b0ad			 
b0ad 7e					ld a, (hl) 
b0ae 3d					dec a 
b0af 77					ld (hl), a 
b0b0					 
b0b0					NEXTW 
b0b0 cd 6c ee			call parse_vector 
b0b3 c3 e5 9d			jp macro_next 
b0b6				endm 
# End of macro NEXTW
b0b6			.SBWSTORE: 
b0b6				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
b0b6 6f				db WORD_SYS_CORE+91             
b0b7 d7 b0			dw .ENDCORE            
b0b9 05				db 4 + 1 
b0ba .. 00			db "1-2!",0              
b0bf				endm 
# End of macro CWHEAD
b0bf			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
b0bf			 
b0bf					FORTH_DSP_VALUEHL 
b0bf cd fa 9b			call macro_dsp_valuehl 
b0c2				endm 
# End of macro FORTH_DSP_VALUEHL
b0c2 e5					push hl 
b0c3			 
b0c3					FORTH_DSP_POP 
b0c3 cd b2 9c			call macro_forth_dsp_pop 
b0c6				endm 
# End of macro FORTH_DSP_POP
b0c6 e1					pop hl 
b0c7			 
b0c7 e5					push hl 
b0c8			 
b0c8 cd 67 9d				call loadwordinhl 
b0cb 2b					dec hl 
b0cc			 
b0cc d1					pop de 
b0cd eb					ex de, hl 
b0ce 73					ld (hl), e 
b0cf 23					inc hl 
b0d0 72					ld (hl), d 
b0d1					 
b0d1					NEXTW 
b0d1 cd 6c ee			call parse_vector 
b0d4 c3 e5 9d			jp macro_next 
b0d7				endm 
# End of macro NEXTW
b0d7			.ENDCORE: 
b0d7			 
b0d7			; eof 
b0d7			 
b0d7			 
# End of file forth_words_core.asm
b0d7			include "forth_words_flow.asm" 
b0d7			 
b0d7			; | ## Program Flow Words 
b0d7			 
b0d7			.IF: 
b0d7				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
b0d7 1e				db WORD_SYS_CORE+10             
b0d8 d2 b1			dw .THEN            
b0da 03				db 2 + 1 
b0db .. 00			db "IF",0              
b0de				endm 
# End of macro CWHEAD
b0de			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
b0de			; | | Note: currently not supporting ELSE or nested IF 
b0de			; 
b0de					if DEBUG_FORTH_WORDS_KEY 
b0de						DMARK "IF." 
b0de f5				push af  
b0df 3a f3 b0			ld a, (.dmark)  
b0e2 32 62 ee			ld (debug_mark),a  
b0e5 3a f4 b0			ld a, (.dmark+1)  
b0e8 32 63 ee			ld (debug_mark+1),a  
b0eb 3a f5 b0			ld a, (.dmark+2)  
b0ee 32 64 ee			ld (debug_mark+2),a  
b0f1 18 03			jr .pastdmark  
b0f3 ..			.dmark: db "IF."  
b0f6 f1			.pastdmark: pop af  
b0f7			endm  
# End of macro DMARK
b0f7						CALLMONITOR 
b0f7 cd 6f ee			call debug_vector  
b0fa				endm  
# End of macro CALLMONITOR
b0fa					endif 
b0fa			; eval TOS 
b0fa			 
b0fa				FORTH_DSP_VALUEHL 
b0fa cd fa 9b			call macro_dsp_valuehl 
b0fd				endm 
# End of macro FORTH_DSP_VALUEHL
b0fd			 
b0fd			;	push hl 
b0fd				FORTH_DSP_POP 
b0fd cd b2 9c			call macro_forth_dsp_pop 
b100				endm 
# End of macro FORTH_DSP_POP
b100			;	pop hl 
b100			 
b100					if DEBUG_FORTH_WORDS 
b100						DMARK "IF1" 
b100 f5				push af  
b101 3a 15 b1			ld a, (.dmark)  
b104 32 62 ee			ld (debug_mark),a  
b107 3a 16 b1			ld a, (.dmark+1)  
b10a 32 63 ee			ld (debug_mark+1),a  
b10d 3a 17 b1			ld a, (.dmark+2)  
b110 32 64 ee			ld (debug_mark+2),a  
b113 18 03			jr .pastdmark  
b115 ..			.dmark: db "IF1"  
b118 f1			.pastdmark: pop af  
b119			endm  
# End of macro DMARK
b119						CALLMONITOR 
b119 cd 6f ee			call debug_vector  
b11c				endm  
# End of macro CALLMONITOR
b11c					endif 
b11c b7				or a        ; clear carry flag 
b11d 11 00 00			ld de, 0 
b120 eb				ex de,hl 
b121 ed 52			sbc hl, de 
b123 c2 b0 b1			jp nz, .iftrue 
b126			 
b126					if DEBUG_FORTH_WORDS 
b126						DMARK "IF2" 
b126 f5				push af  
b127 3a 3b b1			ld a, (.dmark)  
b12a 32 62 ee			ld (debug_mark),a  
b12d 3a 3c b1			ld a, (.dmark+1)  
b130 32 63 ee			ld (debug_mark+1),a  
b133 3a 3d b1			ld a, (.dmark+2)  
b136 32 64 ee			ld (debug_mark+2),a  
b139 18 03			jr .pastdmark  
b13b ..			.dmark: db "IF2"  
b13e f1			.pastdmark: pop af  
b13f			endm  
# End of macro DMARK
b13f						CALLMONITOR 
b13f cd 6f ee			call debug_vector  
b142				endm  
# End of macro CALLMONITOR
b142					endif 
b142			 
b142			; if not true then skip to THEN 
b142			 
b142				; TODO get tok_ptr 
b142				; TODO consume toks until we get to THEN 
b142			 
b142 2a b9 e5			ld hl, (os_tok_ptr) 
b145					if DEBUG_FORTH_WORDS 
b145						DMARK "IF3" 
b145 f5				push af  
b146 3a 5a b1			ld a, (.dmark)  
b149 32 62 ee			ld (debug_mark),a  
b14c 3a 5b b1			ld a, (.dmark+1)  
b14f 32 63 ee			ld (debug_mark+1),a  
b152 3a 5c b1			ld a, (.dmark+2)  
b155 32 64 ee			ld (debug_mark+2),a  
b158 18 03			jr .pastdmark  
b15a ..			.dmark: db "IF3"  
b15d f1			.pastdmark: pop af  
b15e			endm  
# End of macro DMARK
b15e						CALLMONITOR 
b15e cd 6f ee			call debug_vector  
b161				endm  
# End of macro CALLMONITOR
b161						 
b161					endif 
b161 11 ab b1			ld de, .ifthen 
b164					if DEBUG_FORTH_WORDS 
b164						DMARK "IF4" 
b164 f5				push af  
b165 3a 79 b1			ld a, (.dmark)  
b168 32 62 ee			ld (debug_mark),a  
b16b 3a 7a b1			ld a, (.dmark+1)  
b16e 32 63 ee			ld (debug_mark+1),a  
b171 3a 7b b1			ld a, (.dmark+2)  
b174 32 64 ee			ld (debug_mark+2),a  
b177 18 03			jr .pastdmark  
b179 ..			.dmark: db "IF4"  
b17c f1			.pastdmark: pop af  
b17d			endm  
# End of macro DMARK
b17d						CALLMONITOR 
b17d cd 6f ee			call debug_vector  
b180				endm  
# End of macro CALLMONITOR
b180					endif 
b180 cd ec 9e			call findnexttok  
b183			 
b183					if DEBUG_FORTH_WORDS 
b183						DMARK "IF5" 
b183 f5				push af  
b184 3a 98 b1			ld a, (.dmark)  
b187 32 62 ee			ld (debug_mark),a  
b18a 3a 99 b1			ld a, (.dmark+1)  
b18d 32 63 ee			ld (debug_mark+1),a  
b190 3a 9a b1			ld a, (.dmark+2)  
b193 32 64 ee			ld (debug_mark+2),a  
b196 18 03			jr .pastdmark  
b198 ..			.dmark: db "IF5"  
b19b f1			.pastdmark: pop af  
b19c			endm  
# End of macro DMARK
b19c						CALLMONITOR 
b19c cd 6f ee			call debug_vector  
b19f				endm  
# End of macro CALLMONITOR
b19f					endif 
b19f				; TODO replace below with ; exec using tok_ptr 
b19f 22 b9 e5			ld (os_tok_ptr), hl 
b1a2 c3 6e 9e			jp exec1 
b1a5				NEXTW 
b1a5 cd 6c ee			call parse_vector 
b1a8 c3 e5 9d			jp macro_next 
b1ab				endm 
# End of macro NEXTW
b1ab			 
b1ab .. 00		.ifthen:  db "THEN",0 
b1b0			 
b1b0			.iftrue:		 
b1b0				; Exec next words normally 
b1b0			 
b1b0				; if true then exec following IF as normal 
b1b0					if DEBUG_FORTH_WORDS 
b1b0						DMARK "IFT" 
b1b0 f5				push af  
b1b1 3a c5 b1			ld a, (.dmark)  
b1b4 32 62 ee			ld (debug_mark),a  
b1b7 3a c6 b1			ld a, (.dmark+1)  
b1ba 32 63 ee			ld (debug_mark+1),a  
b1bd 3a c7 b1			ld a, (.dmark+2)  
b1c0 32 64 ee			ld (debug_mark+2),a  
b1c3 18 03			jr .pastdmark  
b1c5 ..			.dmark: db "IFT"  
b1c8 f1			.pastdmark: pop af  
b1c9			endm  
# End of macro DMARK
b1c9						CALLMONITOR 
b1c9 cd 6f ee			call debug_vector  
b1cc				endm  
# End of macro CALLMONITOR
b1cc					endif 
b1cc			 
b1cc					NEXTW 
b1cc cd 6c ee			call parse_vector 
b1cf c3 e5 9d			jp macro_next 
b1d2				endm 
# End of macro NEXTW
b1d2			.THEN: 
b1d2				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
b1d2 1f				db WORD_SYS_CORE+11             
b1d3 fd b1			dw .ELSE            
b1d5 05				db 4 + 1 
b1d6 .. 00			db "THEN",0              
b1db				endm 
# End of macro CWHEAD
b1db			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
b1db					if DEBUG_FORTH_WORDS_KEY 
b1db						DMARK "THN" 
b1db f5				push af  
b1dc 3a f0 b1			ld a, (.dmark)  
b1df 32 62 ee			ld (debug_mark),a  
b1e2 3a f1 b1			ld a, (.dmark+1)  
b1e5 32 63 ee			ld (debug_mark+1),a  
b1e8 3a f2 b1			ld a, (.dmark+2)  
b1eb 32 64 ee			ld (debug_mark+2),a  
b1ee 18 03			jr .pastdmark  
b1f0 ..			.dmark: db "THN"  
b1f3 f1			.pastdmark: pop af  
b1f4			endm  
# End of macro DMARK
b1f4						CALLMONITOR 
b1f4 cd 6f ee			call debug_vector  
b1f7				endm  
# End of macro CALLMONITOR
b1f7					endif 
b1f7					NEXTW 
b1f7 cd 6c ee			call parse_vector 
b1fa c3 e5 9d			jp macro_next 
b1fd				endm 
# End of macro NEXTW
b1fd			.ELSE: 
b1fd				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
b1fd 20				db WORD_SYS_CORE+12             
b1fe 28 b2			dw .DO            
b200 03				db 2 + 1 
b201 .. 00			db "ELSE",0              
b206				endm 
# End of macro CWHEAD
b206			; | ELSE ( -- ) Not supported - does nothing | TODO 
b206			 
b206					if DEBUG_FORTH_WORDS_KEY 
b206						DMARK "ELS" 
b206 f5				push af  
b207 3a 1b b2			ld a, (.dmark)  
b20a 32 62 ee			ld (debug_mark),a  
b20d 3a 1c b2			ld a, (.dmark+1)  
b210 32 63 ee			ld (debug_mark+1),a  
b213 3a 1d b2			ld a, (.dmark+2)  
b216 32 64 ee			ld (debug_mark+2),a  
b219 18 03			jr .pastdmark  
b21b ..			.dmark: db "ELS"  
b21e f1			.pastdmark: pop af  
b21f			endm  
# End of macro DMARK
b21f						CALLMONITOR 
b21f cd 6f ee			call debug_vector  
b222				endm  
# End of macro CALLMONITOR
b222					endif 
b222			 
b222			 
b222					NEXTW 
b222 cd 6c ee			call parse_vector 
b225 c3 e5 9d			jp macro_next 
b228				endm 
# End of macro NEXTW
b228			.DO: 
b228				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
b228 21				db WORD_SYS_CORE+13             
b229 52 b3			dw .LOOP            
b22b 03				db 2 + 1 
b22c .. 00			db "DO",0              
b22f				endm 
# End of macro CWHEAD
b22f			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
b22f			 
b22f					if DEBUG_FORTH_WORDS_KEY 
b22f						DMARK "DO." 
b22f f5				push af  
b230 3a 44 b2			ld a, (.dmark)  
b233 32 62 ee			ld (debug_mark),a  
b236 3a 45 b2			ld a, (.dmark+1)  
b239 32 63 ee			ld (debug_mark+1),a  
b23c 3a 46 b2			ld a, (.dmark+2)  
b23f 32 64 ee			ld (debug_mark+2),a  
b242 18 03			jr .pastdmark  
b244 ..			.dmark: db "DO."  
b247 f1			.pastdmark: pop af  
b248			endm  
# End of macro DMARK
b248						CALLMONITOR 
b248 cd 6f ee			call debug_vector  
b24b				endm  
# End of macro CALLMONITOR
b24b					endif 
b24b			;  push pc to rsp stack past the DO 
b24b			 
b24b 2a b9 e5				ld hl, (os_tok_ptr) 
b24e 23					inc hl   ; D 
b24f 23					inc hl  ; O 
b250 23					inc hl   ; null 
b251					if DEBUG_FORTH_WORDS 
b251						DMARK "DO2" 
b251 f5				push af  
b252 3a 66 b2			ld a, (.dmark)  
b255 32 62 ee			ld (debug_mark),a  
b258 3a 67 b2			ld a, (.dmark+1)  
b25b 32 63 ee			ld (debug_mark+1),a  
b25e 3a 68 b2			ld a, (.dmark+2)  
b261 32 64 ee			ld (debug_mark+2),a  
b264 18 03			jr .pastdmark  
b266 ..			.dmark: db "DO2"  
b269 f1			.pastdmark: pop af  
b26a			endm  
# End of macro DMARK
b26a						CALLMONITOR 
b26a cd 6f ee			call debug_vector  
b26d				endm  
# End of macro CALLMONITOR
b26d					endif 
b26d					FORTH_RSP_NEXT 
b26d cd 9c 99			call macro_forth_rsp_next 
b270				endm 
# End of macro FORTH_RSP_NEXT
b270					if DEBUG_FORTH_WORDS 
b270						DMARK "DO3" 
b270 f5				push af  
b271 3a 85 b2			ld a, (.dmark)  
b274 32 62 ee			ld (debug_mark),a  
b277 3a 86 b2			ld a, (.dmark+1)  
b27a 32 63 ee			ld (debug_mark+1),a  
b27d 3a 87 b2			ld a, (.dmark+2)  
b280 32 64 ee			ld (debug_mark+2),a  
b283 18 03			jr .pastdmark  
b285 ..			.dmark: db "DO3"  
b288 f1			.pastdmark: pop af  
b289			endm  
# End of macro DMARK
b289						CALLMONITOR 
b289 cd 6f ee			call debug_vector  
b28c				endm  
# End of macro CALLMONITOR
b28c					endif 
b28c			 
b28c					;if DEBUG_FORTH_WORDS 
b28c				;		push hl 
b28c			;		endif  
b28c			 
b28c			; get counters from data stack 
b28c			 
b28c			 
b28c					FORTH_DSP_VALUEHL 
b28c cd fa 9b			call macro_dsp_valuehl 
b28f				endm 
# End of macro FORTH_DSP_VALUEHL
b28f e5					push hl		 ; hl now has starting counter which needs to be tos 
b290			 
b290					if DEBUG_FORTH_WORDS 
b290						DMARK "DO4" 
b290 f5				push af  
b291 3a a5 b2			ld a, (.dmark)  
b294 32 62 ee			ld (debug_mark),a  
b297 3a a6 b2			ld a, (.dmark+1)  
b29a 32 63 ee			ld (debug_mark+1),a  
b29d 3a a7 b2			ld a, (.dmark+2)  
b2a0 32 64 ee			ld (debug_mark+2),a  
b2a3 18 03			jr .pastdmark  
b2a5 ..			.dmark: db "DO4"  
b2a8 f1			.pastdmark: pop af  
b2a9			endm  
# End of macro DMARK
b2a9						CALLMONITOR 
b2a9 cd 6f ee			call debug_vector  
b2ac				endm  
# End of macro CALLMONITOR
b2ac					endif 
b2ac					FORTH_DSP_POP 
b2ac cd b2 9c			call macro_forth_dsp_pop 
b2af				endm 
# End of macro FORTH_DSP_POP
b2af			 
b2af					if DEBUG_FORTH_WORDS 
b2af						DMARK "DO5" 
b2af f5				push af  
b2b0 3a c4 b2			ld a, (.dmark)  
b2b3 32 62 ee			ld (debug_mark),a  
b2b6 3a c5 b2			ld a, (.dmark+1)  
b2b9 32 63 ee			ld (debug_mark+1),a  
b2bc 3a c6 b2			ld a, (.dmark+2)  
b2bf 32 64 ee			ld (debug_mark+2),a  
b2c2 18 03			jr .pastdmark  
b2c4 ..			.dmark: db "DO5"  
b2c7 f1			.pastdmark: pop af  
b2c8			endm  
# End of macro DMARK
b2c8						CALLMONITOR 
b2c8 cd 6f ee			call debug_vector  
b2cb				endm  
# End of macro CALLMONITOR
b2cb					endif 
b2cb			 
b2cb					FORTH_DSP_VALUEHL 
b2cb cd fa 9b			call macro_dsp_valuehl 
b2ce				endm 
# End of macro FORTH_DSP_VALUEHL
b2ce			;		push hl		 ; hl now has starting limit counter 
b2ce			 
b2ce					if DEBUG_FORTH_WORDS 
b2ce						DMARK "DO6" 
b2ce f5				push af  
b2cf 3a e3 b2			ld a, (.dmark)  
b2d2 32 62 ee			ld (debug_mark),a  
b2d5 3a e4 b2			ld a, (.dmark+1)  
b2d8 32 63 ee			ld (debug_mark+1),a  
b2db 3a e5 b2			ld a, (.dmark+2)  
b2de 32 64 ee			ld (debug_mark+2),a  
b2e1 18 03			jr .pastdmark  
b2e3 ..			.dmark: db "DO6"  
b2e6 f1			.pastdmark: pop af  
b2e7			endm  
# End of macro DMARK
b2e7						CALLMONITOR 
b2e7 cd 6f ee			call debug_vector  
b2ea				endm  
# End of macro CALLMONITOR
b2ea					endif 
b2ea					FORTH_DSP_POP 
b2ea cd b2 9c			call macro_forth_dsp_pop 
b2ed				endm 
# End of macro FORTH_DSP_POP
b2ed			 
b2ed			; put counters on the loop stack 
b2ed			 
b2ed			;		pop hl			 ; limit counter 
b2ed d1					pop de			; start counter 
b2ee			 
b2ee					; push limit counter 
b2ee			 
b2ee					if DEBUG_FORTH_WORDS 
b2ee						DMARK "DO7" 
b2ee f5				push af  
b2ef 3a 03 b3			ld a, (.dmark)  
b2f2 32 62 ee			ld (debug_mark),a  
b2f5 3a 04 b3			ld a, (.dmark+1)  
b2f8 32 63 ee			ld (debug_mark+1),a  
b2fb 3a 05 b3			ld a, (.dmark+2)  
b2fe 32 64 ee			ld (debug_mark+2),a  
b301 18 03			jr .pastdmark  
b303 ..			.dmark: db "DO7"  
b306 f1			.pastdmark: pop af  
b307			endm  
# End of macro DMARK
b307						CALLMONITOR 
b307 cd 6f ee			call debug_vector  
b30a				endm  
# End of macro CALLMONITOR
b30a					endif 
b30a					FORTH_LOOP_NEXT 
b30a cd 2b 9c			call macro_forth_loop_next 
b30d				endm 
# End of macro FORTH_LOOP_NEXT
b30d			 
b30d					; push start counter 
b30d			 
b30d eb					ex de, hl 
b30e					if DEBUG_FORTH_WORDS 
b30e						DMARK "DO7" 
b30e f5				push af  
b30f 3a 23 b3			ld a, (.dmark)  
b312 32 62 ee			ld (debug_mark),a  
b315 3a 24 b3			ld a, (.dmark+1)  
b318 32 63 ee			ld (debug_mark+1),a  
b31b 3a 25 b3			ld a, (.dmark+2)  
b31e 32 64 ee			ld (debug_mark+2),a  
b321 18 03			jr .pastdmark  
b323 ..			.dmark: db "DO7"  
b326 f1			.pastdmark: pop af  
b327			endm  
# End of macro DMARK
b327						CALLMONITOR 
b327 cd 6f ee			call debug_vector  
b32a				endm  
# End of macro CALLMONITOR
b32a					endif 
b32a					FORTH_LOOP_NEXT 
b32a cd 2b 9c			call macro_forth_loop_next 
b32d				endm 
# End of macro FORTH_LOOP_NEXT
b32d			 
b32d			 
b32d					; init first round of I counter 
b32d			 
b32d 22 dd e5				ld (os_current_i), hl 
b330			 
b330					if DEBUG_FORTH_WORDS 
b330						DMARK "DO8" 
b330 f5				push af  
b331 3a 45 b3			ld a, (.dmark)  
b334 32 62 ee			ld (debug_mark),a  
b337 3a 46 b3			ld a, (.dmark+1)  
b33a 32 63 ee			ld (debug_mark+1),a  
b33d 3a 47 b3			ld a, (.dmark+2)  
b340 32 64 ee			ld (debug_mark+2),a  
b343 18 03			jr .pastdmark  
b345 ..			.dmark: db "DO8"  
b348 f1			.pastdmark: pop af  
b349			endm  
# End of macro DMARK
b349						CALLMONITOR 
b349 cd 6f ee			call debug_vector  
b34c				endm  
# End of macro CALLMONITOR
b34c					endif 
b34c			 
b34c					NEXTW 
b34c cd 6c ee			call parse_vector 
b34f c3 e5 9d			jp macro_next 
b352				endm 
# End of macro NEXTW
b352			.LOOP: 
b352				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b352 22				db WORD_SYS_CORE+14             
b353 70 b4			dw .I            
b355 05				db 4 + 1 
b356 .. 00			db "LOOP",0              
b35b				endm 
# End of macro CWHEAD
b35b			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b35b			 
b35b				; pop tos as current loop count to hl 
b35b			 
b35b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b35b			 
b35b				FORTH_LOOP_TOS 
b35b cd 5e 9c			call macro_forth_loop_tos 
b35e				endm 
# End of macro FORTH_LOOP_TOS
b35e e5				push hl 
b35f			 
b35f					if DEBUG_FORTH_WORDS_KEY 
b35f						DMARK "LOP" 
b35f f5				push af  
b360 3a 74 b3			ld a, (.dmark)  
b363 32 62 ee			ld (debug_mark),a  
b366 3a 75 b3			ld a, (.dmark+1)  
b369 32 63 ee			ld (debug_mark+1),a  
b36c 3a 76 b3			ld a, (.dmark+2)  
b36f 32 64 ee			ld (debug_mark+2),a  
b372 18 03			jr .pastdmark  
b374 ..			.dmark: db "LOP"  
b377 f1			.pastdmark: pop af  
b378			endm  
# End of macro DMARK
b378						CALLMONITOR 
b378 cd 6f ee			call debug_vector  
b37b				endm  
# End of macro CALLMONITOR
b37b					endif 
b37b				; next item on the stack is the limit. get it 
b37b			 
b37b			 
b37b				FORTH_LOOP_POP 
b37b cd 68 9c			call macro_forth_loop_pop 
b37e				endm 
# End of macro FORTH_LOOP_POP
b37e			 
b37e				FORTH_LOOP_TOS 
b37e cd 5e 9c			call macro_forth_loop_tos 
b381				endm 
# End of macro FORTH_LOOP_TOS
b381			 
b381 d1				pop de		 ; de = i, hl = limit 
b382			 
b382					if DEBUG_FORTH_WORDS 
b382						DMARK "LP1" 
b382 f5				push af  
b383 3a 97 b3			ld a, (.dmark)  
b386 32 62 ee			ld (debug_mark),a  
b389 3a 98 b3			ld a, (.dmark+1)  
b38c 32 63 ee			ld (debug_mark+1),a  
b38f 3a 99 b3			ld a, (.dmark+2)  
b392 32 64 ee			ld (debug_mark+2),a  
b395 18 03			jr .pastdmark  
b397 ..			.dmark: db "LP1"  
b39a f1			.pastdmark: pop af  
b39b			endm  
# End of macro DMARK
b39b						CALLMONITOR 
b39b cd 6f ee			call debug_vector  
b39e				endm  
# End of macro CALLMONITOR
b39e					endif 
b39e			 
b39e				; go back to previous word 
b39e			 
b39e d5				push de    ; save I for inc later 
b39f			 
b39f			 
b39f				; get limit 
b39f				;  is I at limit? 
b39f			 
b39f			 
b39f					if DEBUG_FORTH_WORDS 
b39f						DMARK "LP1" 
b39f f5				push af  
b3a0 3a b4 b3			ld a, (.dmark)  
b3a3 32 62 ee			ld (debug_mark),a  
b3a6 3a b5 b3			ld a, (.dmark+1)  
b3a9 32 63 ee			ld (debug_mark+1),a  
b3ac 3a b6 b3			ld a, (.dmark+2)  
b3af 32 64 ee			ld (debug_mark+2),a  
b3b2 18 03			jr .pastdmark  
b3b4 ..			.dmark: db "LP1"  
b3b7 f1			.pastdmark: pop af  
b3b8			endm  
# End of macro DMARK
b3b8						CALLMONITOR 
b3b8 cd 6f ee			call debug_vector  
b3bb				endm  
# End of macro CALLMONITOR
b3bb					endif 
b3bb			 
b3bb ed 52			sbc hl, de 
b3bd			 
b3bd			 
b3bd				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b3bd			 
b3bd 20 29				jr nz, .loopnotdone 
b3bf			 
b3bf e1				pop hl   ; get rid of saved I 
b3c0				FORTH_LOOP_POP     ; get rid of limit 
b3c0 cd 68 9c			call macro_forth_loop_pop 
b3c3				endm 
# End of macro FORTH_LOOP_POP
b3c3			 
b3c3				FORTH_RSP_POP     ; get rid of DO ptr 
b3c3 cd bd 99			call macro_forth_rsp_pop 
b3c6				endm 
# End of macro FORTH_RSP_POP
b3c6			 
b3c6			if DEBUG_FORTH_WORDS 
b3c6						DMARK "LP>" 
b3c6 f5				push af  
b3c7 3a db b3			ld a, (.dmark)  
b3ca 32 62 ee			ld (debug_mark),a  
b3cd 3a dc b3			ld a, (.dmark+1)  
b3d0 32 63 ee			ld (debug_mark+1),a  
b3d3 3a dd b3			ld a, (.dmark+2)  
b3d6 32 64 ee			ld (debug_mark+2),a  
b3d9 18 03			jr .pastdmark  
b3db ..			.dmark: db "LP>"  
b3de f1			.pastdmark: pop af  
b3df			endm  
# End of macro DMARK
b3df				CALLMONITOR 
b3df cd 6f ee			call debug_vector  
b3e2				endm  
# End of macro CALLMONITOR
b3e2			endif 
b3e2			 
b3e2					NEXTW 
b3e2 cd 6c ee			call parse_vector 
b3e5 c3 e5 9d			jp macro_next 
b3e8				endm 
# End of macro NEXTW
b3e8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b3e8			 
b3e8			.loopnotdone: 
b3e8			 
b3e8 e1				pop hl    ; get I 
b3e9 23				inc hl 
b3ea			 
b3ea			   	; save new I 
b3ea			 
b3ea			 
b3ea					; set I counter 
b3ea			 
b3ea 22 dd e5				ld (os_current_i), hl 
b3ed			 
b3ed					if DEBUG_FORTH_WORDS 
b3ed						DMARK "LPN" 
b3ed f5				push af  
b3ee 3a 02 b4			ld a, (.dmark)  
b3f1 32 62 ee			ld (debug_mark),a  
b3f4 3a 03 b4			ld a, (.dmark+1)  
b3f7 32 63 ee			ld (debug_mark+1),a  
b3fa 3a 04 b4			ld a, (.dmark+2)  
b3fd 32 64 ee			ld (debug_mark+2),a  
b400 18 03			jr .pastdmark  
b402 ..			.dmark: db "LPN"  
b405 f1			.pastdmark: pop af  
b406			endm  
# End of macro DMARK
b406					CALLMONITOR 
b406 cd 6f ee			call debug_vector  
b409				endm  
# End of macro CALLMONITOR
b409					endif 
b409					 
b409				FORTH_LOOP_NEXT 
b409 cd 2b 9c			call macro_forth_loop_next 
b40c				endm 
# End of macro FORTH_LOOP_NEXT
b40c			 
b40c			 
b40c					if DEBUG_FORTH_WORDS 
b40c eb						ex de,hl 
b40d					endif 
b40d			 
b40d			;	; get DO ptr 
b40d			; 
b40d					if DEBUG_FORTH_WORDS 
b40d						DMARK "LP7" 
b40d f5				push af  
b40e 3a 22 b4			ld a, (.dmark)  
b411 32 62 ee			ld (debug_mark),a  
b414 3a 23 b4			ld a, (.dmark+1)  
b417 32 63 ee			ld (debug_mark+1),a  
b41a 3a 24 b4			ld a, (.dmark+2)  
b41d 32 64 ee			ld (debug_mark+2),a  
b420 18 03			jr .pastdmark  
b422 ..			.dmark: db "LP7"  
b425 f1			.pastdmark: pop af  
b426			endm  
# End of macro DMARK
b426					CALLMONITOR 
b426 cd 6f ee			call debug_vector  
b429				endm  
# End of macro CALLMONITOR
b429					endif 
b429				FORTH_RSP_TOS 
b429 cd b3 99			call macro_forth_rsp_tos 
b42c				endm 
# End of macro FORTH_RSP_TOS
b42c			 
b42c					if DEBUG_FORTH_WORDS 
b42c						DMARK "LP8" 
b42c f5				push af  
b42d 3a 41 b4			ld a, (.dmark)  
b430 32 62 ee			ld (debug_mark),a  
b433 3a 42 b4			ld a, (.dmark+1)  
b436 32 63 ee			ld (debug_mark+1),a  
b439 3a 43 b4			ld a, (.dmark+2)  
b43c 32 64 ee			ld (debug_mark+2),a  
b43f 18 03			jr .pastdmark  
b441 ..			.dmark: db "LP8"  
b444 f1			.pastdmark: pop af  
b445			endm  
# End of macro DMARK
b445					CALLMONITOR 
b445 cd 6f ee			call debug_vector  
b448				endm  
# End of macro CALLMONITOR
b448					endif 
b448				;push hl 
b448			 
b448				; not going to DO any more 
b448				; get rid of the RSP pointer as DO will add it back in 
b448				;FORTH_RSP_POP 
b448				;pop hl 
b448			 
b448				;ld hl,(cli_ret_sp) 
b448				;ld e, (hl) 
b448				;inc hl 
b448				;ld d, (hl) 
b448				;ex de,hl 
b448 22 b9 e5			ld (os_tok_ptr), hl 
b44b					if DEBUG_FORTH_WORDS 
b44b						DMARK "LP<" 
b44b f5				push af  
b44c 3a 60 b4			ld a, (.dmark)  
b44f 32 62 ee			ld (debug_mark),a  
b452 3a 61 b4			ld a, (.dmark+1)  
b455 32 63 ee			ld (debug_mark+1),a  
b458 3a 62 b4			ld a, (.dmark+2)  
b45b 32 64 ee			ld (debug_mark+2),a  
b45e 18 03			jr .pastdmark  
b460 ..			.dmark: db "LP<"  
b463 f1			.pastdmark: pop af  
b464			endm  
# End of macro DMARK
b464					CALLMONITOR 
b464 cd 6f ee			call debug_vector  
b467				endm  
# End of macro CALLMONITOR
b467				endif 
b467 c3 6e 9e			jp exec1 
b46a			 
b46a					 
b46a			 
b46a			 
b46a					NEXTW 
b46a cd 6c ee			call parse_vector 
b46d c3 e5 9d			jp macro_next 
b470				endm 
# End of macro NEXTW
b470			.I:  
b470			 
b470				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b470 5e				db WORD_SYS_CORE+74             
b471 9e b4			dw .DLOOP            
b473 02				db 1 + 1 
b474 .. 00			db "I",0              
b476				endm 
# End of macro CWHEAD
b476			; | I ( -- ) Current loop counter | DONE 
b476					if DEBUG_FORTH_WORDS_KEY 
b476						DMARK "I.." 
b476 f5				push af  
b477 3a 8b b4			ld a, (.dmark)  
b47a 32 62 ee			ld (debug_mark),a  
b47d 3a 8c b4			ld a, (.dmark+1)  
b480 32 63 ee			ld (debug_mark+1),a  
b483 3a 8d b4			ld a, (.dmark+2)  
b486 32 64 ee			ld (debug_mark+2),a  
b489 18 03			jr .pastdmark  
b48b ..			.dmark: db "I.."  
b48e f1			.pastdmark: pop af  
b48f			endm  
# End of macro DMARK
b48f						CALLMONITOR 
b48f cd 6f ee			call debug_vector  
b492				endm  
# End of macro CALLMONITOR
b492					endif 
b492			 
b492 2a dd e5				ld hl,(os_current_i) 
b495 cd f5 99				call forth_push_numhl 
b498			 
b498					NEXTW 
b498 cd 6c ee			call parse_vector 
b49b c3 e5 9d			jp macro_next 
b49e				endm 
# End of macro NEXTW
b49e			.DLOOP: 
b49e				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b49e 5f				db WORD_SYS_CORE+75             
b49f 85 b5			dw .REPEAT            
b4a1 06				db 5 + 1 
b4a2 .. 00			db "-LOOP",0              
b4a8				endm 
# End of macro CWHEAD
b4a8			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b4a8				; pop tos as current loop count to hl 
b4a8					if DEBUG_FORTH_WORDS_KEY 
b4a8						DMARK "-LP" 
b4a8 f5				push af  
b4a9 3a bd b4			ld a, (.dmark)  
b4ac 32 62 ee			ld (debug_mark),a  
b4af 3a be b4			ld a, (.dmark+1)  
b4b2 32 63 ee			ld (debug_mark+1),a  
b4b5 3a bf b4			ld a, (.dmark+2)  
b4b8 32 64 ee			ld (debug_mark+2),a  
b4bb 18 03			jr .pastdmark  
b4bd ..			.dmark: db "-LP"  
b4c0 f1			.pastdmark: pop af  
b4c1			endm  
# End of macro DMARK
b4c1						CALLMONITOR 
b4c1 cd 6f ee			call debug_vector  
b4c4				endm  
# End of macro CALLMONITOR
b4c4					endif 
b4c4			 
b4c4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b4c4			 
b4c4				FORTH_LOOP_TOS 
b4c4 cd 5e 9c			call macro_forth_loop_tos 
b4c7				endm 
# End of macro FORTH_LOOP_TOS
b4c7 e5				push hl 
b4c8			 
b4c8					if DEBUG_FORTH_WORDS 
b4c8						DMARK "-LP" 
b4c8 f5				push af  
b4c9 3a dd b4			ld a, (.dmark)  
b4cc 32 62 ee			ld (debug_mark),a  
b4cf 3a de b4			ld a, (.dmark+1)  
b4d2 32 63 ee			ld (debug_mark+1),a  
b4d5 3a df b4			ld a, (.dmark+2)  
b4d8 32 64 ee			ld (debug_mark+2),a  
b4db 18 03			jr .pastdmark  
b4dd ..			.dmark: db "-LP"  
b4e0 f1			.pastdmark: pop af  
b4e1			endm  
# End of macro DMARK
b4e1						CALLMONITOR 
b4e1 cd 6f ee			call debug_vector  
b4e4				endm  
# End of macro CALLMONITOR
b4e4					endif 
b4e4				; next item on the stack is the limit. get it 
b4e4			 
b4e4			 
b4e4				FORTH_LOOP_POP 
b4e4 cd 68 9c			call macro_forth_loop_pop 
b4e7				endm 
# End of macro FORTH_LOOP_POP
b4e7			 
b4e7				FORTH_LOOP_TOS 
b4e7 cd 5e 9c			call macro_forth_loop_tos 
b4ea				endm 
# End of macro FORTH_LOOP_TOS
b4ea			 
b4ea d1				pop de		 ; de = i, hl = limit 
b4eb			 
b4eb					if DEBUG_FORTH_WORDS 
b4eb						DMARK "-L1" 
b4eb f5				push af  
b4ec 3a 00 b5			ld a, (.dmark)  
b4ef 32 62 ee			ld (debug_mark),a  
b4f2 3a 01 b5			ld a, (.dmark+1)  
b4f5 32 63 ee			ld (debug_mark+1),a  
b4f8 3a 02 b5			ld a, (.dmark+2)  
b4fb 32 64 ee			ld (debug_mark+2),a  
b4fe 18 03			jr .pastdmark  
b500 ..			.dmark: db "-L1"  
b503 f1			.pastdmark: pop af  
b504			endm  
# End of macro DMARK
b504						CALLMONITOR 
b504 cd 6f ee			call debug_vector  
b507				endm  
# End of macro CALLMONITOR
b507					endif 
b507			 
b507				; go back to previous word 
b507			 
b507 d5				push de    ; save I for inc later 
b508			 
b508			 
b508				; get limit 
b508				;  is I at limit? 
b508			 
b508			 
b508					if DEBUG_FORTH_WORDS 
b508						DMARK "-L1" 
b508 f5				push af  
b509 3a 1d b5			ld a, (.dmark)  
b50c 32 62 ee			ld (debug_mark),a  
b50f 3a 1e b5			ld a, (.dmark+1)  
b512 32 63 ee			ld (debug_mark+1),a  
b515 3a 1f b5			ld a, (.dmark+2)  
b518 32 64 ee			ld (debug_mark+2),a  
b51b 18 03			jr .pastdmark  
b51d ..			.dmark: db "-L1"  
b520 f1			.pastdmark: pop af  
b521			endm  
# End of macro DMARK
b521						CALLMONITOR 
b521 cd 6f ee			call debug_vector  
b524				endm  
# End of macro CALLMONITOR
b524					endif 
b524			 
b524 ed 52			sbc hl, de 
b526			 
b526			 
b526				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b526			 
b526 20 29				jr nz, .mloopnotdone 
b528			 
b528 e1				pop hl   ; get rid of saved I 
b529				FORTH_LOOP_POP     ; get rid of limit 
b529 cd 68 9c			call macro_forth_loop_pop 
b52c				endm 
# End of macro FORTH_LOOP_POP
b52c			 
b52c				FORTH_RSP_POP     ; get rid of DO ptr 
b52c cd bd 99			call macro_forth_rsp_pop 
b52f				endm 
# End of macro FORTH_RSP_POP
b52f			 
b52f			if DEBUG_FORTH_WORDS 
b52f						DMARK "-L>" 
b52f f5				push af  
b530 3a 44 b5			ld a, (.dmark)  
b533 32 62 ee			ld (debug_mark),a  
b536 3a 45 b5			ld a, (.dmark+1)  
b539 32 63 ee			ld (debug_mark+1),a  
b53c 3a 46 b5			ld a, (.dmark+2)  
b53f 32 64 ee			ld (debug_mark+2),a  
b542 18 03			jr .pastdmark  
b544 ..			.dmark: db "-L>"  
b547 f1			.pastdmark: pop af  
b548			endm  
# End of macro DMARK
b548				CALLMONITOR 
b548 cd 6f ee			call debug_vector  
b54b				endm  
# End of macro CALLMONITOR
b54b			endif 
b54b			 
b54b					NEXTW 
b54b cd 6c ee			call parse_vector 
b54e c3 e5 9d			jp macro_next 
b551				endm 
# End of macro NEXTW
b551				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b551			 
b551			.mloopnotdone: 
b551			 
b551 e1				pop hl    ; get I 
b552 2b				dec hl 
b553			 
b553			   	; save new I 
b553			 
b553			 
b553					; set I counter 
b553			 
b553 22 dd e5				ld (os_current_i), hl 
b556			 
b556					 
b556				FORTH_LOOP_NEXT 
b556 cd 2b 9c			call macro_forth_loop_next 
b559				endm 
# End of macro FORTH_LOOP_NEXT
b559			 
b559			 
b559					if DEBUG_FORTH_WORDS 
b559 eb						ex de,hl 
b55a					endif 
b55a			 
b55a			;	; get DO ptr 
b55a			; 
b55a				FORTH_RSP_TOS 
b55a cd b3 99			call macro_forth_rsp_tos 
b55d				endm 
# End of macro FORTH_RSP_TOS
b55d			 
b55d				;push hl 
b55d			 
b55d				; not going to DO any more 
b55d				; get rid of the RSP pointer as DO will add it back in 
b55d				;FORTH_RSP_POP 
b55d				;pop hl 
b55d			 
b55d			 
b55d 22 b9 e5			ld (os_tok_ptr), hl 
b560					if DEBUG_FORTH_WORDS 
b560						DMARK "-L<" 
b560 f5				push af  
b561 3a 75 b5			ld a, (.dmark)  
b564 32 62 ee			ld (debug_mark),a  
b567 3a 76 b5			ld a, (.dmark+1)  
b56a 32 63 ee			ld (debug_mark+1),a  
b56d 3a 77 b5			ld a, (.dmark+2)  
b570 32 64 ee			ld (debug_mark+2),a  
b573 18 03			jr .pastdmark  
b575 ..			.dmark: db "-L<"  
b578 f1			.pastdmark: pop af  
b579			endm  
# End of macro DMARK
b579					CALLMONITOR 
b579 cd 6f ee			call debug_vector  
b57c				endm  
# End of macro CALLMONITOR
b57c				endif 
b57c c3 6e 9e			jp exec1 
b57f			 
b57f					 
b57f			 
b57f			 
b57f			 
b57f				NEXTW 
b57f cd 6c ee			call parse_vector 
b582 c3 e5 9d			jp macro_next 
b585				endm 
# End of macro NEXTW
b585			 
b585			 
b585			 
b585			 
b585			.REPEAT: 
b585				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b585 71				db WORD_SYS_CORE+93             
b586 db b5			dw .UNTIL            
b588 06				db 5 + 1 
b589 .. 00			db "REPEAT",0              
b590				endm 
# End of macro CWHEAD
b590			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b590			;  push pc to rsp stack past the REPEAT 
b590					if DEBUG_FORTH_WORDS_KEY 
b590						DMARK "REP" 
b590 f5				push af  
b591 3a a5 b5			ld a, (.dmark)  
b594 32 62 ee			ld (debug_mark),a  
b597 3a a6 b5			ld a, (.dmark+1)  
b59a 32 63 ee			ld (debug_mark+1),a  
b59d 3a a7 b5			ld a, (.dmark+2)  
b5a0 32 64 ee			ld (debug_mark+2),a  
b5a3 18 03			jr .pastdmark  
b5a5 ..			.dmark: db "REP"  
b5a8 f1			.pastdmark: pop af  
b5a9			endm  
# End of macro DMARK
b5a9						CALLMONITOR 
b5a9 cd 6f ee			call debug_vector  
b5ac				endm  
# End of macro CALLMONITOR
b5ac					endif 
b5ac			 
b5ac 2a b9 e5				ld hl, (os_tok_ptr) 
b5af 23					inc hl   ; R 
b5b0 23					inc hl  ; E 
b5b1 23					inc hl   ; P 
b5b2 23					inc hl   ; E 
b5b3 23					inc hl   ; A 
b5b4 23					inc hl   ; T 
b5b5 23					inc hl   ; zero 
b5b6					FORTH_RSP_NEXT 
b5b6 cd 9c 99			call macro_forth_rsp_next 
b5b9				endm 
# End of macro FORTH_RSP_NEXT
b5b9			 
b5b9			 
b5b9					if DEBUG_FORTH_WORDS 
b5b9						DMARK "REP" 
b5b9 f5				push af  
b5ba 3a ce b5			ld a, (.dmark)  
b5bd 32 62 ee			ld (debug_mark),a  
b5c0 3a cf b5			ld a, (.dmark+1)  
b5c3 32 63 ee			ld (debug_mark+1),a  
b5c6 3a d0 b5			ld a, (.dmark+2)  
b5c9 32 64 ee			ld (debug_mark+2),a  
b5cc 18 03			jr .pastdmark  
b5ce ..			.dmark: db "REP"  
b5d1 f1			.pastdmark: pop af  
b5d2			endm  
# End of macro DMARK
b5d2						;pop bc    ; TODO BUG ?????? what is this for???? 
b5d2						CALLMONITOR 
b5d2 cd 6f ee			call debug_vector  
b5d5				endm  
# End of macro CALLMONITOR
b5d5					endif 
b5d5			 
b5d5					NEXTW 
b5d5 cd 6c ee			call parse_vector 
b5d8 c3 e5 9d			jp macro_next 
b5db				endm 
# End of macro NEXTW
b5db			;	       NEXTW 
b5db			 
b5db			.UNTIL: 
b5db				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b5db 72				db WORD_SYS_CORE+94             
b5dc 78 b6			dw .ENDFLOW            
b5de 06				db 5 + 1 
b5df .. 00			db "UNTIL",0              
b5e5				endm 
# End of macro CWHEAD
b5e5			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b5e5			 
b5e5				; pop tos as check 
b5e5			 
b5e5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b5e5			 
b5e5				FORTH_DSP_VALUEHL 
b5e5 cd fa 9b			call macro_dsp_valuehl 
b5e8				endm 
# End of macro FORTH_DSP_VALUEHL
b5e8			 
b5e8					if DEBUG_FORTH_WORDS_KEY 
b5e8						DMARK "UNT" 
b5e8 f5				push af  
b5e9 3a fd b5			ld a, (.dmark)  
b5ec 32 62 ee			ld (debug_mark),a  
b5ef 3a fe b5			ld a, (.dmark+1)  
b5f2 32 63 ee			ld (debug_mark+1),a  
b5f5 3a ff b5			ld a, (.dmark+2)  
b5f8 32 64 ee			ld (debug_mark+2),a  
b5fb 18 03			jr .pastdmark  
b5fd ..			.dmark: db "UNT"  
b600 f1			.pastdmark: pop af  
b601			endm  
# End of macro DMARK
b601						CALLMONITOR 
b601 cd 6f ee			call debug_vector  
b604				endm  
# End of macro CALLMONITOR
b604					endif 
b604			 
b604			;	push hl 
b604				FORTH_DSP_POP 
b604 cd b2 9c			call macro_forth_dsp_pop 
b607				endm 
# End of macro FORTH_DSP_POP
b607			 
b607			;	pop hl 
b607			 
b607				; test if true 
b607			 
b607 cd 13 8d			call ishlzero 
b60a			;	ld a,l 
b60a			;	add h 
b60a			; 
b60a			;	cp 0 
b60a			 
b60a 20 41			jr nz, .untilnotdone 
b60c			 
b60c					if DEBUG_FORTH_WORDS 
b60c						DMARK "UNf" 
b60c f5				push af  
b60d 3a 21 b6			ld a, (.dmark)  
b610 32 62 ee			ld (debug_mark),a  
b613 3a 22 b6			ld a, (.dmark+1)  
b616 32 63 ee			ld (debug_mark+1),a  
b619 3a 23 b6			ld a, (.dmark+2)  
b61c 32 64 ee			ld (debug_mark+2),a  
b61f 18 03			jr .pastdmark  
b621 ..			.dmark: db "UNf"  
b624 f1			.pastdmark: pop af  
b625			endm  
# End of macro DMARK
b625						CALLMONITOR 
b625 cd 6f ee			call debug_vector  
b628				endm  
# End of macro CALLMONITOR
b628					endif 
b628			 
b628			 
b628			 
b628				FORTH_RSP_POP     ; get rid of DO ptr 
b628 cd bd 99			call macro_forth_rsp_pop 
b62b				endm 
# End of macro FORTH_RSP_POP
b62b			 
b62b			if DEBUG_FORTH_WORDS 
b62b						DMARK "UN>" 
b62b f5				push af  
b62c 3a 40 b6			ld a, (.dmark)  
b62f 32 62 ee			ld (debug_mark),a  
b632 3a 41 b6			ld a, (.dmark+1)  
b635 32 63 ee			ld (debug_mark+1),a  
b638 3a 42 b6			ld a, (.dmark+2)  
b63b 32 64 ee			ld (debug_mark+2),a  
b63e 18 03			jr .pastdmark  
b640 ..			.dmark: db "UN>"  
b643 f1			.pastdmark: pop af  
b644			endm  
# End of macro DMARK
b644				CALLMONITOR 
b644 cd 6f ee			call debug_vector  
b647				endm  
# End of macro CALLMONITOR
b647			endif 
b647			 
b647					NEXTW 
b647 cd 6c ee			call parse_vector 
b64a c3 e5 9d			jp macro_next 
b64d				endm 
# End of macro NEXTW
b64d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b64d			 
b64d			.untilnotdone: 
b64d			 
b64d			 
b64d			;	; get DO ptr 
b64d			; 
b64d				FORTH_RSP_TOS 
b64d cd b3 99			call macro_forth_rsp_tos 
b650				endm 
# End of macro FORTH_RSP_TOS
b650			 
b650				;push hl 
b650			 
b650				; not going to DO any more 
b650				; get rid of the RSP pointer as DO will add it back in 
b650				;FORTH_RSP_POP 
b650				;pop hl 
b650			 
b650			 
b650 22 b9 e5			ld (os_tok_ptr), hl 
b653					if DEBUG_FORTH_WORDS 
b653						DMARK "UN<" 
b653 f5				push af  
b654 3a 68 b6			ld a, (.dmark)  
b657 32 62 ee			ld (debug_mark),a  
b65a 3a 69 b6			ld a, (.dmark+1)  
b65d 32 63 ee			ld (debug_mark+1),a  
b660 3a 6a b6			ld a, (.dmark+2)  
b663 32 64 ee			ld (debug_mark+2),a  
b666 18 03			jr .pastdmark  
b668 ..			.dmark: db "UN<"  
b66b f1			.pastdmark: pop af  
b66c			endm  
# End of macro DMARK
b66c					CALLMONITOR 
b66c cd 6f ee			call debug_vector  
b66f				endm  
# End of macro CALLMONITOR
b66f				endif 
b66f c3 6e 9e			jp exec1 
b672			 
b672					 
b672			 
b672			 
b672					NEXTW 
b672 cd 6c ee			call parse_vector 
b675 c3 e5 9d			jp macro_next 
b678				endm 
# End of macro NEXTW
b678			 
b678			 
b678			.ENDFLOW: 
b678			 
b678			; eof 
b678			 
# End of file forth_words_flow.asm
b678			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b678			include "forth_words_logic.asm" 
b678			 
b678			; | ## Logic Words 
b678			 
b678			.NOT: 
b678				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b678 2d				db WORD_SYS_CORE+25             
b679 c6 b6			dw .IS            
b67b 04				db 3 + 1 
b67c .. 00			db "NOT",0              
b680				endm 
# End of macro CWHEAD
b680			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b680					if DEBUG_FORTH_WORDS_KEY 
b680						DMARK "NOT" 
b680 f5				push af  
b681 3a 95 b6			ld a, (.dmark)  
b684 32 62 ee			ld (debug_mark),a  
b687 3a 96 b6			ld a, (.dmark+1)  
b68a 32 63 ee			ld (debug_mark+1),a  
b68d 3a 97 b6			ld a, (.dmark+2)  
b690 32 64 ee			ld (debug_mark+2),a  
b693 18 03			jr .pastdmark  
b695 ..			.dmark: db "NOT"  
b698 f1			.pastdmark: pop af  
b699			endm  
# End of macro DMARK
b699						CALLMONITOR 
b699 cd 6f ee			call debug_vector  
b69c				endm  
# End of macro CALLMONITOR
b69c					endif 
b69c					FORTH_DSP 
b69c cd c0 9b			call macro_forth_dsp 
b69f				endm 
# End of macro FORTH_DSP
b69f 7e					ld a,(hl)	; get type of value on TOS 
b6a0 fe 02				cp DS_TYPE_INUM  
b6a2 28 06				jr z, .noti 
b6a4					NEXTW 
b6a4 cd 6c ee			call parse_vector 
b6a7 c3 e5 9d			jp macro_next 
b6aa				endm 
# End of macro NEXTW
b6aa			.noti:          FORTH_DSP_VALUEHL 
b6aa cd fa 9b			call macro_dsp_valuehl 
b6ad				endm 
# End of macro FORTH_DSP_VALUEHL
b6ad			;		push hl 
b6ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6ad cd b2 9c			call macro_forth_dsp_pop 
b6b0				endm 
# End of macro FORTH_DSP_POP
b6b0			;		pop hl 
b6b0 3e 00				ld a,0 
b6b2 bd					cp l 
b6b3 28 04				jr z, .not2t 
b6b5 2e 00				ld l, 0 
b6b7 18 02				jr .notip 
b6b9			 
b6b9 2e ff		.not2t:		ld l, 255 
b6bb			 
b6bb 26 00		.notip:		ld h, 0	 
b6bd			 
b6bd cd f5 99				call forth_push_numhl 
b6c0					NEXTW 
b6c0 cd 6c ee			call parse_vector 
b6c3 c3 e5 9d			jp macro_next 
b6c6				endm 
# End of macro NEXTW
b6c6			 
b6c6			.IS: 
b6c6				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
b6c6 2d				db WORD_SYS_CORE+25             
b6c7 0a b7			dw .LZERO            
b6c9 08				db 7 + 1 
b6ca .. 00			db "COMPARE",0              
b6d2				endm 
# End of macro CWHEAD
b6d2			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
b6d2					if DEBUG_FORTH_WORDS_KEY 
b6d2						DMARK "CMP" 
b6d2 f5				push af  
b6d3 3a e7 b6			ld a, (.dmark)  
b6d6 32 62 ee			ld (debug_mark),a  
b6d9 3a e8 b6			ld a, (.dmark+1)  
b6dc 32 63 ee			ld (debug_mark+1),a  
b6df 3a e9 b6			ld a, (.dmark+2)  
b6e2 32 64 ee			ld (debug_mark+2),a  
b6e5 18 03			jr .pastdmark  
b6e7 ..			.dmark: db "CMP"  
b6ea f1			.pastdmark: pop af  
b6eb			endm  
# End of macro DMARK
b6eb						CALLMONITOR 
b6eb cd 6f ee			call debug_vector  
b6ee				endm  
# End of macro CALLMONITOR
b6ee					endif 
b6ee			 
b6ee					FORTH_DSP_VALUEHL 
b6ee cd fa 9b			call macro_dsp_valuehl 
b6f1				endm 
# End of macro FORTH_DSP_VALUEHL
b6f1			 
b6f1 e5					push hl 
b6f2			 
b6f2					FORTH_DSP_VALUEM1 
b6f2 cd ee 9b			call macro_forth_dsp_value_m1 
b6f5				endm 
# End of macro FORTH_DSP_VALUEM1
b6f5			 
b6f5 d1					pop de 
b6f6			 
b6f6					; got pointers to both. Now check. 
b6f6			 
b6f6 cd 88 90				call strcmp 
b6f9				 
b6f9 26 00				ld h, 0 
b6fb 2e 00				ld l, 0 
b6fd 20 02				jr nz, .compnsame 
b6ff 2e 01				ld l, 1	 
b701			.compnsame: 
b701 cd f5 99				call forth_push_numhl 
b704			 
b704					NEXTW 
b704 cd 6c ee			call parse_vector 
b707 c3 e5 9d			jp macro_next 
b70a				endm 
# End of macro NEXTW
b70a			.LZERO: 
b70a				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b70a 2d				db WORD_SYS_CORE+25             
b70b 17 b7			dw .TZERO            
b70d 03				db 2 + 1 
b70e .. 00			db "0<",0              
b711				endm 
# End of macro CWHEAD
b711			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b711					NEXTW 
b711 cd 6c ee			call parse_vector 
b714 c3 e5 9d			jp macro_next 
b717				endm 
# End of macro NEXTW
b717			.TZERO: 
b717				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b717 2e				db WORD_SYS_CORE+26             
b718 61 b7			dw .LESS            
b71a 03				db 2 + 1 
b71b .. 00			db "0=",0              
b71e				endm 
# End of macro CWHEAD
b71e			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b71e				; TODO add floating point number detection 
b71e					;v5 FORTH_DSP_VALUE 
b71e					if DEBUG_FORTH_WORDS_KEY 
b71e						DMARK "0=." 
b71e f5				push af  
b71f 3a 33 b7			ld a, (.dmark)  
b722 32 62 ee			ld (debug_mark),a  
b725 3a 34 b7			ld a, (.dmark+1)  
b728 32 63 ee			ld (debug_mark+1),a  
b72b 3a 35 b7			ld a, (.dmark+2)  
b72e 32 64 ee			ld (debug_mark+2),a  
b731 18 03			jr .pastdmark  
b733 ..			.dmark: db "0=."  
b736 f1			.pastdmark: pop af  
b737			endm  
# End of macro DMARK
b737						CALLMONITOR 
b737 cd 6f ee			call debug_vector  
b73a				endm  
# End of macro CALLMONITOR
b73a					endif 
b73a					FORTH_DSP 
b73a cd c0 9b			call macro_forth_dsp 
b73d				endm 
# End of macro FORTH_DSP
b73d 7e					ld a,(hl)	; get type of value on TOS 
b73e fe 02				cp DS_TYPE_INUM  
b740 28 00				jr z, .tz_inum 
b742			 
b742				if FORTH_ENABLE_FLOATMATH 
b742					jr .tz_done 
b742			 
b742				endif 
b742					 
b742			 
b742			.tz_inum: 
b742					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b742 cd fa 9b			call macro_dsp_valuehl 
b745				endm 
# End of macro FORTH_DSP_VALUEHL
b745			 
b745			;		push hl 
b745			 
b745					; destroy value TOS 
b745			 
b745					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b745 cd b2 9c			call macro_forth_dsp_pop 
b748				endm 
# End of macro FORTH_DSP_POP
b748			 
b748			;		pop hl 
b748			 
b748 3e 00				ld a,0 
b74a			 
b74a bd					cp l 
b74b 20 08				jr nz, .tz_notzero 
b74d			 
b74d bc					cp h 
b74e			 
b74e 20 05				jr nz, .tz_notzero 
b750			 
b750			 
b750 21 01 00				ld hl, FORTH_TRUE 
b753 18 03				jr .tz_done 
b755			 
b755 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b758			 
b758					; push value back onto stack for another op etc 
b758			 
b758			.tz_done: 
b758 cd f5 99				call forth_push_numhl 
b75b			 
b75b					NEXTW 
b75b cd 6c ee			call parse_vector 
b75e c3 e5 9d			jp macro_next 
b761				endm 
# End of macro NEXTW
b761			.LESS: 
b761				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b761 2f				db WORD_SYS_CORE+27             
b762 cd b7			dw .GT            
b764 02				db 1 + 1 
b765 .. 00			db "<",0              
b767				endm 
# End of macro CWHEAD
b767			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b767				; TODO add floating point number detection 
b767					if DEBUG_FORTH_WORDS_KEY 
b767						DMARK "LES" 
b767 f5				push af  
b768 3a 7c b7			ld a, (.dmark)  
b76b 32 62 ee			ld (debug_mark),a  
b76e 3a 7d b7			ld a, (.dmark+1)  
b771 32 63 ee			ld (debug_mark+1),a  
b774 3a 7e b7			ld a, (.dmark+2)  
b777 32 64 ee			ld (debug_mark+2),a  
b77a 18 03			jr .pastdmark  
b77c ..			.dmark: db "LES"  
b77f f1			.pastdmark: pop af  
b780			endm  
# End of macro DMARK
b780						CALLMONITOR 
b780 cd 6f ee			call debug_vector  
b783				endm  
# End of macro CALLMONITOR
b783					endif 
b783					FORTH_DSP 
b783 cd c0 9b			call macro_forth_dsp 
b786				endm 
# End of macro FORTH_DSP
b786					;v5 FORTH_DSP_VALUE 
b786 7e					ld a,(hl)	; get type of value on TOS 
b787 fe 02				cp DS_TYPE_INUM  
b789 28 00				jr z, .less_inum 
b78b			 
b78b				if FORTH_ENABLE_FLOATMATH 
b78b					jr .less_done 
b78b			 
b78b				endif 
b78b					 
b78b			 
b78b			.less_inum: 
b78b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b78b cd fa 9b			call macro_dsp_valuehl 
b78e				endm 
# End of macro FORTH_DSP_VALUEHL
b78e			 
b78e e5					push hl  ; u2 
b78f			 
b78f					; destroy value TOS 
b78f			 
b78f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b78f cd b2 9c			call macro_forth_dsp_pop 
b792				endm 
# End of macro FORTH_DSP_POP
b792			 
b792			 
b792					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b792 cd fa 9b			call macro_dsp_valuehl 
b795				endm 
# End of macro FORTH_DSP_VALUEHL
b795			 
b795 e5					push hl    ; u1 
b796			 
b796					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b796 cd b2 9c			call macro_forth_dsp_pop 
b799				endm 
# End of macro FORTH_DSP_POP
b799			 
b799			 
b799 b7			 or a      ;clear carry flag 
b79a 01 00 00		 ld bc, FORTH_FALSE 
b79d e1			  pop hl    ; u1 
b79e d1			  pop de    ; u2 
b79f ed 52		  sbc hl,de 
b7a1 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b7a3			 
b7a3 01 01 00		 ld bc, FORTH_TRUE 
b7a6			.lscont:  
b7a6 c5					push bc 
b7a7 e1					pop hl 
b7a8			 
b7a8					if DEBUG_FORTH_WORDS 
b7a8						DMARK "LT1" 
b7a8 f5				push af  
b7a9 3a bd b7			ld a, (.dmark)  
b7ac 32 62 ee			ld (debug_mark),a  
b7af 3a be b7			ld a, (.dmark+1)  
b7b2 32 63 ee			ld (debug_mark+1),a  
b7b5 3a bf b7			ld a, (.dmark+2)  
b7b8 32 64 ee			ld (debug_mark+2),a  
b7bb 18 03			jr .pastdmark  
b7bd ..			.dmark: db "LT1"  
b7c0 f1			.pastdmark: pop af  
b7c1			endm  
# End of macro DMARK
b7c1						CALLMONITOR 
b7c1 cd 6f ee			call debug_vector  
b7c4				endm  
# End of macro CALLMONITOR
b7c4					endif 
b7c4 cd f5 99				call forth_push_numhl 
b7c7			 
b7c7					NEXTW 
b7c7 cd 6c ee			call parse_vector 
b7ca c3 e5 9d			jp macro_next 
b7cd				endm 
# End of macro NEXTW
b7cd			.GT: 
b7cd				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b7cd 30				db WORD_SYS_CORE+28             
b7ce 39 b8			dw .EQUAL            
b7d0 02				db 1 + 1 
b7d1 .. 00			db ">",0              
b7d3				endm 
# End of macro CWHEAD
b7d3			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b7d3				; TODO add floating point number detection 
b7d3					if DEBUG_FORTH_WORDS_KEY 
b7d3						DMARK "GRT" 
b7d3 f5				push af  
b7d4 3a e8 b7			ld a, (.dmark)  
b7d7 32 62 ee			ld (debug_mark),a  
b7da 3a e9 b7			ld a, (.dmark+1)  
b7dd 32 63 ee			ld (debug_mark+1),a  
b7e0 3a ea b7			ld a, (.dmark+2)  
b7e3 32 64 ee			ld (debug_mark+2),a  
b7e6 18 03			jr .pastdmark  
b7e8 ..			.dmark: db "GRT"  
b7eb f1			.pastdmark: pop af  
b7ec			endm  
# End of macro DMARK
b7ec						CALLMONITOR 
b7ec cd 6f ee			call debug_vector  
b7ef				endm  
# End of macro CALLMONITOR
b7ef					endif 
b7ef					FORTH_DSP 
b7ef cd c0 9b			call macro_forth_dsp 
b7f2				endm 
# End of macro FORTH_DSP
b7f2					;FORTH_DSP_VALUE 
b7f2 7e					ld a,(hl)	; get type of value on TOS 
b7f3 fe 02				cp DS_TYPE_INUM  
b7f5 28 00				jr z, .gt_inum 
b7f7			 
b7f7				if FORTH_ENABLE_FLOATMATH 
b7f7					jr .gt_done 
b7f7			 
b7f7				endif 
b7f7					 
b7f7			 
b7f7			.gt_inum: 
b7f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7f7 cd fa 9b			call macro_dsp_valuehl 
b7fa				endm 
# End of macro FORTH_DSP_VALUEHL
b7fa			 
b7fa e5					push hl  ; u2 
b7fb			 
b7fb					; destroy value TOS 
b7fb			 
b7fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7fb cd b2 9c			call macro_forth_dsp_pop 
b7fe				endm 
# End of macro FORTH_DSP_POP
b7fe			 
b7fe			 
b7fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7fe cd fa 9b			call macro_dsp_valuehl 
b801				endm 
# End of macro FORTH_DSP_VALUEHL
b801			 
b801 e5					push hl    ; u1 
b802			 
b802					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b802 cd b2 9c			call macro_forth_dsp_pop 
b805				endm 
# End of macro FORTH_DSP_POP
b805			 
b805			 
b805 b7			 or a      ;clear carry flag 
b806 01 00 00		 ld bc, FORTH_FALSE 
b809 e1			  pop hl    ; u1 
b80a d1			  pop de    ; u2 
b80b ed 52		  sbc hl,de 
b80d 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b80f			 
b80f 01 01 00		 ld bc, FORTH_TRUE 
b812			.gtcont:  
b812 c5					push bc 
b813 e1					pop hl 
b814			 
b814					if DEBUG_FORTH_WORDS 
b814						DMARK "GT1" 
b814 f5				push af  
b815 3a 29 b8			ld a, (.dmark)  
b818 32 62 ee			ld (debug_mark),a  
b81b 3a 2a b8			ld a, (.dmark+1)  
b81e 32 63 ee			ld (debug_mark+1),a  
b821 3a 2b b8			ld a, (.dmark+2)  
b824 32 64 ee			ld (debug_mark+2),a  
b827 18 03			jr .pastdmark  
b829 ..			.dmark: db "GT1"  
b82c f1			.pastdmark: pop af  
b82d			endm  
# End of macro DMARK
b82d						CALLMONITOR 
b82d cd 6f ee			call debug_vector  
b830				endm  
# End of macro CALLMONITOR
b830					endif 
b830 cd f5 99				call forth_push_numhl 
b833			 
b833					NEXTW 
b833 cd 6c ee			call parse_vector 
b836 c3 e5 9d			jp macro_next 
b839				endm 
# End of macro NEXTW
b839			.EQUAL: 
b839				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b839 31				db WORD_SYS_CORE+29             
b83a a7 b8			dw .ENDLOGIC            
b83c 02				db 1 + 1 
b83d .. 00			db "=",0              
b83f				endm 
# End of macro CWHEAD
b83f			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b83f				; TODO add floating point number detection 
b83f					if DEBUG_FORTH_WORDS_KEY 
b83f						DMARK "EQ." 
b83f f5				push af  
b840 3a 54 b8			ld a, (.dmark)  
b843 32 62 ee			ld (debug_mark),a  
b846 3a 55 b8			ld a, (.dmark+1)  
b849 32 63 ee			ld (debug_mark+1),a  
b84c 3a 56 b8			ld a, (.dmark+2)  
b84f 32 64 ee			ld (debug_mark+2),a  
b852 18 03			jr .pastdmark  
b854 ..			.dmark: db "EQ."  
b857 f1			.pastdmark: pop af  
b858			endm  
# End of macro DMARK
b858						CALLMONITOR 
b858 cd 6f ee			call debug_vector  
b85b				endm  
# End of macro CALLMONITOR
b85b					endif 
b85b					FORTH_DSP 
b85b cd c0 9b			call macro_forth_dsp 
b85e				endm 
# End of macro FORTH_DSP
b85e					;v5 FORTH_DSP_VALUE 
b85e 7e					ld a,(hl)	; get type of value on TOS 
b85f fe 02				cp DS_TYPE_INUM  
b861 28 00				jr z, .eq_inum 
b863			 
b863				if FORTH_ENABLE_FLOATMATH 
b863					jr .eq_done 
b863			 
b863				endif 
b863					 
b863			 
b863			.eq_inum: 
b863					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b863 cd fa 9b			call macro_dsp_valuehl 
b866				endm 
# End of macro FORTH_DSP_VALUEHL
b866			 
b866 e5					push hl 
b867			 
b867					; destroy value TOS 
b867			 
b867					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b867 cd b2 9c			call macro_forth_dsp_pop 
b86a				endm 
# End of macro FORTH_DSP_POP
b86a			 
b86a			 
b86a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b86a cd fa 9b			call macro_dsp_valuehl 
b86d				endm 
# End of macro FORTH_DSP_VALUEHL
b86d			 
b86d					; one value on hl get other one back 
b86d			 
b86d e5					push hl 
b86e			 
b86e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b86e cd b2 9c			call macro_forth_dsp_pop 
b871				endm 
# End of macro FORTH_DSP_POP
b871			 
b871 0e 00				ld c, FORTH_FALSE 
b873			 
b873 e1					pop hl 
b874 d1					pop de 
b875			 
b875 7b					ld a, e 
b876 bd					cp l 
b877			 
b877 20 06				jr nz, .eq_done 
b879			 
b879 7a					ld a, d 
b87a bc					cp h 
b87b			 
b87b 20 02				jr nz, .eq_done 
b87d			 
b87d 0e 01				ld c, FORTH_TRUE 
b87f					 
b87f			 
b87f			 
b87f			.eq_done: 
b87f			 
b87f					; TODO push value back onto stack for another op etc 
b87f			 
b87f 26 00				ld h, 0 
b881 69					ld l, c 
b882					if DEBUG_FORTH_WORDS 
b882						DMARK "EQ1" 
b882 f5				push af  
b883 3a 97 b8			ld a, (.dmark)  
b886 32 62 ee			ld (debug_mark),a  
b889 3a 98 b8			ld a, (.dmark+1)  
b88c 32 63 ee			ld (debug_mark+1),a  
b88f 3a 99 b8			ld a, (.dmark+2)  
b892 32 64 ee			ld (debug_mark+2),a  
b895 18 03			jr .pastdmark  
b897 ..			.dmark: db "EQ1"  
b89a f1			.pastdmark: pop af  
b89b			endm  
# End of macro DMARK
b89b						CALLMONITOR 
b89b cd 6f ee			call debug_vector  
b89e				endm  
# End of macro CALLMONITOR
b89e					endif 
b89e cd f5 99				call forth_push_numhl 
b8a1			 
b8a1					NEXTW 
b8a1 cd 6c ee			call parse_vector 
b8a4 c3 e5 9d			jp macro_next 
b8a7				endm 
# End of macro NEXTW
b8a7			 
b8a7			 
b8a7			.ENDLOGIC: 
b8a7			; eof 
b8a7			 
b8a7			 
# End of file forth_words_logic.asm
b8a7			include "forth_words_maths.asm" 
b8a7			 
b8a7			; | ## Maths Words 
b8a7			 
b8a7			.PLUS:	 
b8a7				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b8a7 15				db WORD_SYS_CORE+1             
b8a8 0b b9			dw .NEG            
b8aa 02				db 1 + 1 
b8ab .. 00			db "+",0              
b8ad				endm 
# End of macro CWHEAD
b8ad			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b8ad					if DEBUG_FORTH_WORDS_KEY 
b8ad						DMARK "PLU" 
b8ad f5				push af  
b8ae 3a c2 b8			ld a, (.dmark)  
b8b1 32 62 ee			ld (debug_mark),a  
b8b4 3a c3 b8			ld a, (.dmark+1)  
b8b7 32 63 ee			ld (debug_mark+1),a  
b8ba 3a c4 b8			ld a, (.dmark+2)  
b8bd 32 64 ee			ld (debug_mark+2),a  
b8c0 18 03			jr .pastdmark  
b8c2 ..			.dmark: db "PLU"  
b8c5 f1			.pastdmark: pop af  
b8c6			endm  
# End of macro DMARK
b8c6						CALLMONITOR 
b8c6 cd 6f ee			call debug_vector  
b8c9				endm  
# End of macro CALLMONITOR
b8c9					endif 
b8c9					; add top two values and push back result 
b8c9			 
b8c9					;for v5 FORTH_DSP_VALUE 
b8c9					FORTH_DSP 
b8c9 cd c0 9b			call macro_forth_dsp 
b8cc				endm 
# End of macro FORTH_DSP
b8cc 7e					ld a,(hl)	; get type of value on TOS 
b8cd fe 02				cp DS_TYPE_INUM  
b8cf 28 06				jr z, .dot_inum 
b8d1			 
b8d1					NEXTW 
b8d1 cd 6c ee			call parse_vector 
b8d4 c3 e5 9d			jp macro_next 
b8d7				endm 
# End of macro NEXTW
b8d7			 
b8d7			; float maths 
b8d7			 
b8d7				if FORTH_ENABLE_FLOATMATH 
b8d7						inc hl      ; now at start of numeric as string 
b8d7			 
b8d7					if DEBUG_FORTH_MATHS 
b8d7						DMARK "ADD" 
b8d7				CALLMONITOR 
b8d7					endif 
b8d7			 
b8d7					;ld ix, hl 
b8d7					call CON 
b8d7			 
b8d7			 
b8d7					push hl 
b8d7					 
b8d7					 
b8d7			 
b8d7						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b8d7			 
b8d7					; get next number 
b8d7			 
b8d7						FORTH_DSP_VALUE 
b8d7			 
b8d7						inc hl      ; now at start of numeric as string 
b8d7			 
b8d7					;ld ix, hl 
b8d7					call CON 
b8d7			 
b8d7					push hl 
b8d7			 
b8d7			 
b8d7						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8d7			 
b8d7						; TODO do add 
b8d7			 
b8d7						call IADD 
b8d7			 
b8d7						; TODO get result back as ascii 
b8d7			 
b8d7						; TODO push result  
b8d7			 
b8d7			 
b8d7			 
b8d7						jr .dot_done 
b8d7				endif 
b8d7			 
b8d7			.dot_inum: 
b8d7			 
b8d7			 
b8d7					if DEBUG_FORTH_DOT 
b8d7						DMARK "+IT" 
b8d7 f5				push af  
b8d8 3a ec b8			ld a, (.dmark)  
b8db 32 62 ee			ld (debug_mark),a  
b8de 3a ed b8			ld a, (.dmark+1)  
b8e1 32 63 ee			ld (debug_mark+1),a  
b8e4 3a ee b8			ld a, (.dmark+2)  
b8e7 32 64 ee			ld (debug_mark+2),a  
b8ea 18 03			jr .pastdmark  
b8ec ..			.dmark: db "+IT"  
b8ef f1			.pastdmark: pop af  
b8f0			endm  
# End of macro DMARK
b8f0				CALLMONITOR 
b8f0 cd 6f ee			call debug_vector  
b8f3				endm  
# End of macro CALLMONITOR
b8f3					endif 
b8f3			 
b8f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8f3 cd fa 9b			call macro_dsp_valuehl 
b8f6				endm 
# End of macro FORTH_DSP_VALUEHL
b8f6			 
b8f6				; TODO add floating point number detection 
b8f6			 
b8f6 e5					push hl 
b8f7			 
b8f7					; destroy value TOS 
b8f7			 
b8f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8f7 cd b2 9c			call macro_forth_dsp_pop 
b8fa				endm 
# End of macro FORTH_DSP_POP
b8fa			 
b8fa			 
b8fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8fa cd fa 9b			call macro_dsp_valuehl 
b8fd				endm 
# End of macro FORTH_DSP_VALUEHL
b8fd			 
b8fd					; one value on hl get other one back 
b8fd			 
b8fd d1					pop de 
b8fe			 
b8fe					; do the add 
b8fe			 
b8fe 19					add hl,de 
b8ff			 
b8ff					; save it 
b8ff			 
b8ff			;		push hl	 
b8ff			 
b8ff					; 
b8ff			 
b8ff					; destroy value TOS 
b8ff			 
b8ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8ff cd b2 9c			call macro_forth_dsp_pop 
b902				endm 
# End of macro FORTH_DSP_POP
b902			 
b902					; TODO push value back onto stack for another op etc 
b902			 
b902			;		pop hl 
b902			 
b902			.dot_done: 
b902 cd f5 99				call forth_push_numhl 
b905			 
b905					NEXTW 
b905 cd 6c ee			call parse_vector 
b908 c3 e5 9d			jp macro_next 
b90b				endm 
# End of macro NEXTW
b90b			.NEG: 
b90b			 
b90b				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b90b 17				db WORD_SYS_CORE+3             
b90c 54 b9			dw .DIV            
b90e 02				db 1 + 1 
b90f .. 00			db "-",0              
b911				endm 
# End of macro CWHEAD
b911			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b911					if DEBUG_FORTH_WORDS_KEY 
b911						DMARK "SUB" 
b911 f5				push af  
b912 3a 26 b9			ld a, (.dmark)  
b915 32 62 ee			ld (debug_mark),a  
b918 3a 27 b9			ld a, (.dmark+1)  
b91b 32 63 ee			ld (debug_mark+1),a  
b91e 3a 28 b9			ld a, (.dmark+2)  
b921 32 64 ee			ld (debug_mark+2),a  
b924 18 03			jr .pastdmark  
b926 ..			.dmark: db "SUB"  
b929 f1			.pastdmark: pop af  
b92a			endm  
# End of macro DMARK
b92a						CALLMONITOR 
b92a cd 6f ee			call debug_vector  
b92d				endm  
# End of macro CALLMONITOR
b92d					endif 
b92d			 
b92d			 
b92d				; TODO add floating point number detection 
b92d					; v5 FORTH_DSP_VALUE 
b92d					FORTH_DSP 
b92d cd c0 9b			call macro_forth_dsp 
b930				endm 
# End of macro FORTH_DSP
b930 7e					ld a,(hl)	; get type of value on TOS 
b931 fe 02				cp DS_TYPE_INUM  
b933 28 06				jr z, .neg_inum 
b935			 
b935					NEXTW 
b935 cd 6c ee			call parse_vector 
b938 c3 e5 9d			jp macro_next 
b93b				endm 
# End of macro NEXTW
b93b			 
b93b			; float maths 
b93b			 
b93b				if FORTH_ENABLE_FLOATMATH 
b93b					jr .neg_done 
b93b			 
b93b				endif 
b93b					 
b93b			 
b93b			.neg_inum: 
b93b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b93b cd fa 9b			call macro_dsp_valuehl 
b93e				endm 
# End of macro FORTH_DSP_VALUEHL
b93e			 
b93e e5					push hl 
b93f			 
b93f					; destroy value TOS 
b93f			 
b93f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b93f cd b2 9c			call macro_forth_dsp_pop 
b942				endm 
# End of macro FORTH_DSP_POP
b942			 
b942			 
b942					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b942 cd fa 9b			call macro_dsp_valuehl 
b945				endm 
# End of macro FORTH_DSP_VALUEHL
b945			 
b945					; one value on hl get other one back 
b945			 
b945 d1					pop de 
b946			 
b946					; do the sub 
b946			;		ex de, hl 
b946			 
b946 ed 52				sbc hl,de 
b948			 
b948					; save it 
b948			 
b948			;		push hl	 
b948			 
b948					; 
b948			 
b948					; destroy value TOS 
b948			 
b948					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b948 cd b2 9c			call macro_forth_dsp_pop 
b94b				endm 
# End of macro FORTH_DSP_POP
b94b			 
b94b					; TODO push value back onto stack for another op etc 
b94b			 
b94b			;		pop hl 
b94b			 
b94b cd f5 99				call forth_push_numhl 
b94e			.neg_done: 
b94e			 
b94e					NEXTW 
b94e cd 6c ee			call parse_vector 
b951 c3 e5 9d			jp macro_next 
b954				endm 
# End of macro NEXTW
b954			.DIV: 
b954				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b954 18				db WORD_SYS_CORE+4             
b955 a7 b9			dw .MUL            
b957 02				db 1 + 1 
b958 .. 00			db "/",0              
b95a				endm 
# End of macro CWHEAD
b95a			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b95a					if DEBUG_FORTH_WORDS_KEY 
b95a						DMARK "DIV" 
b95a f5				push af  
b95b 3a 6f b9			ld a, (.dmark)  
b95e 32 62 ee			ld (debug_mark),a  
b961 3a 70 b9			ld a, (.dmark+1)  
b964 32 63 ee			ld (debug_mark+1),a  
b967 3a 71 b9			ld a, (.dmark+2)  
b96a 32 64 ee			ld (debug_mark+2),a  
b96d 18 03			jr .pastdmark  
b96f ..			.dmark: db "DIV"  
b972 f1			.pastdmark: pop af  
b973			endm  
# End of macro DMARK
b973						CALLMONITOR 
b973 cd 6f ee			call debug_vector  
b976				endm  
# End of macro CALLMONITOR
b976					endif 
b976				; TODO add floating point number detection 
b976					; v5 FORTH_DSP_VALUE 
b976					FORTH_DSP 
b976 cd c0 9b			call macro_forth_dsp 
b979				endm 
# End of macro FORTH_DSP
b979 7e					ld a,(hl)	; get type of value on TOS 
b97a fe 02				cp DS_TYPE_INUM  
b97c 28 06				jr z, .div_inum 
b97e			 
b97e				if FORTH_ENABLE_FLOATMATH 
b97e					jr .div_done 
b97e			 
b97e				endif 
b97e					NEXTW 
b97e cd 6c ee			call parse_vector 
b981 c3 e5 9d			jp macro_next 
b984				endm 
# End of macro NEXTW
b984			.div_inum: 
b984			 
b984					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b984 cd fa 9b			call macro_dsp_valuehl 
b987				endm 
# End of macro FORTH_DSP_VALUEHL
b987			 
b987 e5					push hl    ; to go to bc 
b988			 
b988					; destroy value TOS 
b988			 
b988					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b988 cd b2 9c			call macro_forth_dsp_pop 
b98b				endm 
# End of macro FORTH_DSP_POP
b98b			 
b98b			 
b98b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b98b cd fa 9b			call macro_dsp_valuehl 
b98e				endm 
# End of macro FORTH_DSP_VALUEHL
b98e			 
b98e					; hl to go to de 
b98e			 
b98e e5					push hl 
b98f			 
b98f c1					pop bc 
b990 d1					pop de		 
b991			 
b991			 
b991					if DEBUG_FORTH_MATHS 
b991						DMARK "DIV" 
b991				CALLMONITOR 
b991					endif 
b991					; one value on hl but move to a get other one back 
b991			 
b991			        
b991 cd 47 8c			call Div16 
b994			 
b994			;	push af	 
b994 e5				push hl 
b995 c5				push bc 
b996			 
b996					if DEBUG_FORTH_MATHS 
b996						DMARK "DI1" 
b996				CALLMONITOR 
b996					endif 
b996			 
b996					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b996 cd b2 9c			call macro_forth_dsp_pop 
b999				endm 
# End of macro FORTH_DSP_POP
b999			 
b999			 
b999			 
b999 e1					pop hl    ; result 
b99a			 
b99a cd f5 99				call forth_push_numhl 
b99d			 
b99d e1					pop hl    ; reminder 
b99e			;		ld h,0 
b99e			;		ld l,d 
b99e			 
b99e cd f5 99				call forth_push_numhl 
b9a1			.div_done: 
b9a1					NEXTW 
b9a1 cd 6c ee			call parse_vector 
b9a4 c3 e5 9d			jp macro_next 
b9a7				endm 
# End of macro NEXTW
b9a7			.MUL: 
b9a7				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b9a7 19				db WORD_SYS_CORE+5             
b9a8 f2 b9			dw .MIN            
b9aa 02				db 1 + 1 
b9ab .. 00			db "*",0              
b9ad				endm 
# End of macro CWHEAD
b9ad			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b9ad				; TODO add floating point number detection 
b9ad					if DEBUG_FORTH_WORDS_KEY 
b9ad						DMARK "MUL" 
b9ad f5				push af  
b9ae 3a c2 b9			ld a, (.dmark)  
b9b1 32 62 ee			ld (debug_mark),a  
b9b4 3a c3 b9			ld a, (.dmark+1)  
b9b7 32 63 ee			ld (debug_mark+1),a  
b9ba 3a c4 b9			ld a, (.dmark+2)  
b9bd 32 64 ee			ld (debug_mark+2),a  
b9c0 18 03			jr .pastdmark  
b9c2 ..			.dmark: db "MUL"  
b9c5 f1			.pastdmark: pop af  
b9c6			endm  
# End of macro DMARK
b9c6						CALLMONITOR 
b9c6 cd 6f ee			call debug_vector  
b9c9				endm  
# End of macro CALLMONITOR
b9c9					endif 
b9c9					FORTH_DSP 
b9c9 cd c0 9b			call macro_forth_dsp 
b9cc				endm 
# End of macro FORTH_DSP
b9cc					; v5 FORTH_DSP_VALUE 
b9cc 7e					ld a,(hl)	; get type of value on TOS 
b9cd fe 02				cp DS_TYPE_INUM  
b9cf 28 06				jr z, .mul_inum 
b9d1			 
b9d1				if FORTH_ENABLE_FLOATMATH 
b9d1					jr .mul_done 
b9d1			 
b9d1				endif 
b9d1			 
b9d1					NEXTW 
b9d1 cd 6c ee			call parse_vector 
b9d4 c3 e5 9d			jp macro_next 
b9d7				endm 
# End of macro NEXTW
b9d7			.mul_inum:	 
b9d7			 
b9d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9d7 cd fa 9b			call macro_dsp_valuehl 
b9da				endm 
# End of macro FORTH_DSP_VALUEHL
b9da			 
b9da e5					push hl 
b9db			 
b9db					; destroy value TOS 
b9db			 
b9db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9db cd b2 9c			call macro_forth_dsp_pop 
b9de				endm 
# End of macro FORTH_DSP_POP
b9de			 
b9de			 
b9de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9de cd fa 9b			call macro_dsp_valuehl 
b9e1				endm 
# End of macro FORTH_DSP_VALUEHL
b9e1			 
b9e1					; one value on hl but move to a get other one back 
b9e1			 
b9e1 7d					ld a, l 
b9e2			 
b9e2 d1					pop de 
b9e3			 
b9e3					; do the mull 
b9e3			;		ex de, hl 
b9e3			 
b9e3 cd 6d 8c				call Mult16 
b9e6					; save it 
b9e6			 
b9e6			;		push hl	 
b9e6			 
b9e6					; 
b9e6			 
b9e6					; destroy value TOS 
b9e6			 
b9e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9e6 cd b2 9c			call macro_forth_dsp_pop 
b9e9				endm 
# End of macro FORTH_DSP_POP
b9e9			 
b9e9					; TODO push value back onto stack for another op etc 
b9e9			 
b9e9			;		pop hl 
b9e9			 
b9e9 cd f5 99				call forth_push_numhl 
b9ec			 
b9ec			.mul_done: 
b9ec					NEXTW 
b9ec cd 6c ee			call parse_vector 
b9ef c3 e5 9d			jp macro_next 
b9f2				endm 
# End of macro NEXTW
b9f2			 
b9f2			 
b9f2			 
b9f2			 
b9f2			.MIN: 
b9f2				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b9f2 49				db WORD_SYS_CORE+53             
b9f3 79 ba			dw .MAX            
b9f5 04				db 3 + 1 
b9f6 .. 00			db "MIN",0              
b9fa				endm 
# End of macro CWHEAD
b9fa			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b9fa					if DEBUG_FORTH_WORDS_KEY 
b9fa						DMARK "MIN" 
b9fa f5				push af  
b9fb 3a 0f ba			ld a, (.dmark)  
b9fe 32 62 ee			ld (debug_mark),a  
ba01 3a 10 ba			ld a, (.dmark+1)  
ba04 32 63 ee			ld (debug_mark+1),a  
ba07 3a 11 ba			ld a, (.dmark+2)  
ba0a 32 64 ee			ld (debug_mark+2),a  
ba0d 18 03			jr .pastdmark  
ba0f ..			.dmark: db "MIN"  
ba12 f1			.pastdmark: pop af  
ba13			endm  
# End of macro DMARK
ba13						CALLMONITOR 
ba13 cd 6f ee			call debug_vector  
ba16				endm  
# End of macro CALLMONITOR
ba16					endif 
ba16					; get u2 
ba16			 
ba16					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba16 cd fa 9b			call macro_dsp_valuehl 
ba19				endm 
# End of macro FORTH_DSP_VALUEHL
ba19			 
ba19 e5					push hl   ; u2 
ba1a			 
ba1a					; destroy value TOS 
ba1a			 
ba1a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba1a cd b2 9c			call macro_forth_dsp_pop 
ba1d				endm 
# End of macro FORTH_DSP_POP
ba1d			 
ba1d					; get u1 
ba1d			 
ba1d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba1d cd fa 9b			call macro_dsp_valuehl 
ba20				endm 
# End of macro FORTH_DSP_VALUEHL
ba20			 
ba20 e5					push hl  ; u1 
ba21			 
ba21					; destroy value TOS 
ba21			 
ba21					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba21 cd b2 9c			call macro_forth_dsp_pop 
ba24				endm 
# End of macro FORTH_DSP_POP
ba24			 
ba24 b7			 or a      ;clear carry flag 
ba25 e1			  pop hl    ; u1 
ba26 d1			  pop de    ; u2 
ba27 e5				push hl   ; saved in case hl is lowest 
ba28 ed 52		  sbc hl,de 
ba2a 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
ba2c			 
ba2c e1				pop hl 
ba2d					if DEBUG_FORTH_WORDS 
ba2d						DMARK "MIN" 
ba2d f5				push af  
ba2e 3a 42 ba			ld a, (.dmark)  
ba31 32 62 ee			ld (debug_mark),a  
ba34 3a 43 ba			ld a, (.dmark+1)  
ba37 32 63 ee			ld (debug_mark+1),a  
ba3a 3a 44 ba			ld a, (.dmark+2)  
ba3d 32 64 ee			ld (debug_mark+2),a  
ba40 18 03			jr .pastdmark  
ba42 ..			.dmark: db "MIN"  
ba45 f1			.pastdmark: pop af  
ba46			endm  
# End of macro DMARK
ba46						CALLMONITOR 
ba46 cd 6f ee			call debug_vector  
ba49				endm  
# End of macro CALLMONITOR
ba49					endif 
ba49 cd f5 99				call forth_push_numhl 
ba4c			 
ba4c				       NEXTW 
ba4c cd 6c ee			call parse_vector 
ba4f c3 e5 9d			jp macro_next 
ba52				endm 
# End of macro NEXTW
ba52			 
ba52			.mincont:  
ba52 c1				pop bc   ; tidy up 
ba53 eb				ex de , hl  
ba54					if DEBUG_FORTH_WORDS 
ba54						DMARK "MI1" 
ba54 f5				push af  
ba55 3a 69 ba			ld a, (.dmark)  
ba58 32 62 ee			ld (debug_mark),a  
ba5b 3a 6a ba			ld a, (.dmark+1)  
ba5e 32 63 ee			ld (debug_mark+1),a  
ba61 3a 6b ba			ld a, (.dmark+2)  
ba64 32 64 ee			ld (debug_mark+2),a  
ba67 18 03			jr .pastdmark  
ba69 ..			.dmark: db "MI1"  
ba6c f1			.pastdmark: pop af  
ba6d			endm  
# End of macro DMARK
ba6d						CALLMONITOR 
ba6d cd 6f ee			call debug_vector  
ba70				endm  
# End of macro CALLMONITOR
ba70					endif 
ba70 cd f5 99				call forth_push_numhl 
ba73			 
ba73				       NEXTW 
ba73 cd 6c ee			call parse_vector 
ba76 c3 e5 9d			jp macro_next 
ba79				endm 
# End of macro NEXTW
ba79			.MAX: 
ba79				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
ba79 4a				db WORD_SYS_CORE+54             
ba7a 00 bb			dw .RND16            
ba7c 04				db 3 + 1 
ba7d .. 00			db "MAX",0              
ba81				endm 
# End of macro CWHEAD
ba81			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
ba81					if DEBUG_FORTH_WORDS_KEY 
ba81						DMARK "MAX" 
ba81 f5				push af  
ba82 3a 96 ba			ld a, (.dmark)  
ba85 32 62 ee			ld (debug_mark),a  
ba88 3a 97 ba			ld a, (.dmark+1)  
ba8b 32 63 ee			ld (debug_mark+1),a  
ba8e 3a 98 ba			ld a, (.dmark+2)  
ba91 32 64 ee			ld (debug_mark+2),a  
ba94 18 03			jr .pastdmark  
ba96 ..			.dmark: db "MAX"  
ba99 f1			.pastdmark: pop af  
ba9a			endm  
# End of macro DMARK
ba9a						CALLMONITOR 
ba9a cd 6f ee			call debug_vector  
ba9d				endm  
# End of macro CALLMONITOR
ba9d					endif 
ba9d					; get u2 
ba9d			 
ba9d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba9d cd fa 9b			call macro_dsp_valuehl 
baa0				endm 
# End of macro FORTH_DSP_VALUEHL
baa0			 
baa0 e5					push hl   ; u2 
baa1			 
baa1					; destroy value TOS 
baa1			 
baa1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baa1 cd b2 9c			call macro_forth_dsp_pop 
baa4				endm 
# End of macro FORTH_DSP_POP
baa4			 
baa4					; get u1 
baa4			 
baa4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
baa4 cd fa 9b			call macro_dsp_valuehl 
baa7				endm 
# End of macro FORTH_DSP_VALUEHL
baa7			 
baa7 e5					push hl  ; u1 
baa8			 
baa8					; destroy value TOS 
baa8			 
baa8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baa8 cd b2 9c			call macro_forth_dsp_pop 
baab				endm 
# End of macro FORTH_DSP_POP
baab			 
baab b7			 or a      ;clear carry flag 
baac e1			  pop hl    ; u1 
baad d1			  pop de    ; u2 
baae e5				push hl   ; saved in case hl is lowest 
baaf ed 52		  sbc hl,de 
bab1 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
bab3			 
bab3 e1				pop hl 
bab4					if DEBUG_FORTH_WORDS 
bab4						DMARK "MAX" 
bab4 f5				push af  
bab5 3a c9 ba			ld a, (.dmark)  
bab8 32 62 ee			ld (debug_mark),a  
babb 3a ca ba			ld a, (.dmark+1)  
babe 32 63 ee			ld (debug_mark+1),a  
bac1 3a cb ba			ld a, (.dmark+2)  
bac4 32 64 ee			ld (debug_mark+2),a  
bac7 18 03			jr .pastdmark  
bac9 ..			.dmark: db "MAX"  
bacc f1			.pastdmark: pop af  
bacd			endm  
# End of macro DMARK
bacd						CALLMONITOR 
bacd cd 6f ee			call debug_vector  
bad0				endm  
# End of macro CALLMONITOR
bad0					endif 
bad0 cd f5 99				call forth_push_numhl 
bad3			 
bad3				       NEXTW 
bad3 cd 6c ee			call parse_vector 
bad6 c3 e5 9d			jp macro_next 
bad9				endm 
# End of macro NEXTW
bad9			 
bad9			.maxcont:  
bad9 c1				pop bc   ; tidy up 
bada eb				ex de , hl  
badb					if DEBUG_FORTH_WORDS 
badb						DMARK "MA1" 
badb f5				push af  
badc 3a f0 ba			ld a, (.dmark)  
badf 32 62 ee			ld (debug_mark),a  
bae2 3a f1 ba			ld a, (.dmark+1)  
bae5 32 63 ee			ld (debug_mark+1),a  
bae8 3a f2 ba			ld a, (.dmark+2)  
baeb 32 64 ee			ld (debug_mark+2),a  
baee 18 03			jr .pastdmark  
baf0 ..			.dmark: db "MA1"  
baf3 f1			.pastdmark: pop af  
baf4			endm  
# End of macro DMARK
baf4						CALLMONITOR 
baf4 cd 6f ee			call debug_vector  
baf7				endm  
# End of macro CALLMONITOR
baf7					endif 
baf7 cd f5 99				call forth_push_numhl 
bafa				       NEXTW 
bafa cd 6c ee			call parse_vector 
bafd c3 e5 9d			jp macro_next 
bb00				endm 
# End of macro NEXTW
bb00			 
bb00			.RND16: 
bb00				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
bb00 4e				db WORD_SYS_CORE+58             
bb01 32 bb			dw .RND8            
bb03 06				db 5 + 1 
bb04 .. 00			db "RND16",0              
bb0a				endm 
# End of macro CWHEAD
bb0a			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
bb0a					if DEBUG_FORTH_WORDS_KEY 
bb0a						DMARK "R16" 
bb0a f5				push af  
bb0b 3a 1f bb			ld a, (.dmark)  
bb0e 32 62 ee			ld (debug_mark),a  
bb11 3a 20 bb			ld a, (.dmark+1)  
bb14 32 63 ee			ld (debug_mark+1),a  
bb17 3a 21 bb			ld a, (.dmark+2)  
bb1a 32 64 ee			ld (debug_mark+2),a  
bb1d 18 03			jr .pastdmark  
bb1f ..			.dmark: db "R16"  
bb22 f1			.pastdmark: pop af  
bb23			endm  
# End of macro DMARK
bb23						CALLMONITOR 
bb23 cd 6f ee			call debug_vector  
bb26				endm  
# End of macro CALLMONITOR
bb26					endif 
bb26 cd 11 8c				call prng16  
bb29 cd f5 99				call forth_push_numhl 
bb2c				       NEXTW 
bb2c cd 6c ee			call parse_vector 
bb2f c3 e5 9d			jp macro_next 
bb32				endm 
# End of macro NEXTW
bb32			.RND8: 
bb32				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
bb32 60				db WORD_SYS_CORE+76             
bb33 6a bb			dw .RND            
bb35 05				db 4 + 1 
bb36 .. 00			db "RND8",0              
bb3b				endm 
# End of macro CWHEAD
bb3b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
bb3b					if DEBUG_FORTH_WORDS_KEY 
bb3b						DMARK "RN8" 
bb3b f5				push af  
bb3c 3a 50 bb			ld a, (.dmark)  
bb3f 32 62 ee			ld (debug_mark),a  
bb42 3a 51 bb			ld a, (.dmark+1)  
bb45 32 63 ee			ld (debug_mark+1),a  
bb48 3a 52 bb			ld a, (.dmark+2)  
bb4b 32 64 ee			ld (debug_mark+2),a  
bb4e 18 03			jr .pastdmark  
bb50 ..			.dmark: db "RN8"  
bb53 f1			.pastdmark: pop af  
bb54			endm  
# End of macro DMARK
bb54						CALLMONITOR 
bb54 cd 6f ee			call debug_vector  
bb57				endm  
# End of macro CALLMONITOR
bb57					endif 
bb57 2a a0 eb				ld hl,(xrandc) 
bb5a 23					inc hl 
bb5b cd 2b 8c				call xrnd 
bb5e 6f					ld l,a	 
bb5f 26 00				ld h,0 
bb61 cd f5 99				call forth_push_numhl 
bb64				       NEXTW 
bb64 cd 6c ee			call parse_vector 
bb67 c3 e5 9d			jp macro_next 
bb6a				endm 
# End of macro NEXTW
bb6a			.RND: 
bb6a				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
bb6a 60				db WORD_SYS_CORE+76             
bb6b 73 bc			dw .ENDMATHS            
bb6d 04				db 3 + 1 
bb6e .. 00			db "RND",0              
bb72				endm 
# End of macro CWHEAD
bb72			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
bb72			 
bb72					if DEBUG_FORTH_WORDS_KEY 
bb72						DMARK "RND" 
bb72 f5				push af  
bb73 3a 87 bb			ld a, (.dmark)  
bb76 32 62 ee			ld (debug_mark),a  
bb79 3a 88 bb			ld a, (.dmark+1)  
bb7c 32 63 ee			ld (debug_mark+1),a  
bb7f 3a 89 bb			ld a, (.dmark+2)  
bb82 32 64 ee			ld (debug_mark+2),a  
bb85 18 03			jr .pastdmark  
bb87 ..			.dmark: db "RND"  
bb8a f1			.pastdmark: pop af  
bb8b			endm  
# End of macro DMARK
bb8b						CALLMONITOR 
bb8b cd 6f ee			call debug_vector  
bb8e				endm  
# End of macro CALLMONITOR
bb8e					endif 
bb8e					 
bb8e					FORTH_DSP_VALUEHL    ; upper range 
bb8e cd fa 9b			call macro_dsp_valuehl 
bb91				endm 
# End of macro FORTH_DSP_VALUEHL
bb91			 
bb91 22 a4 eb				ld (LFSRSeed), hl	 
bb94			 
bb94					if DEBUG_FORTH_WORDS 
bb94						DMARK "RN1" 
bb94 f5				push af  
bb95 3a a9 bb			ld a, (.dmark)  
bb98 32 62 ee			ld (debug_mark),a  
bb9b 3a aa bb			ld a, (.dmark+1)  
bb9e 32 63 ee			ld (debug_mark+1),a  
bba1 3a ab bb			ld a, (.dmark+2)  
bba4 32 64 ee			ld (debug_mark+2),a  
bba7 18 03			jr .pastdmark  
bba9 ..			.dmark: db "RN1"  
bbac f1			.pastdmark: pop af  
bbad			endm  
# End of macro DMARK
bbad						CALLMONITOR 
bbad cd 6f ee			call debug_vector  
bbb0				endm  
# End of macro CALLMONITOR
bbb0					endif 
bbb0					FORTH_DSP_POP 
bbb0 cd b2 9c			call macro_forth_dsp_pop 
bbb3				endm 
# End of macro FORTH_DSP_POP
bbb3			 
bbb3					FORTH_DSP_VALUEHL    ; low range 
bbb3 cd fa 9b			call macro_dsp_valuehl 
bbb6				endm 
# End of macro FORTH_DSP_VALUEHL
bbb6			 
bbb6					if DEBUG_FORTH_WORDS 
bbb6						DMARK "RN2" 
bbb6 f5				push af  
bbb7 3a cb bb			ld a, (.dmark)  
bbba 32 62 ee			ld (debug_mark),a  
bbbd 3a cc bb			ld a, (.dmark+1)  
bbc0 32 63 ee			ld (debug_mark+1),a  
bbc3 3a cd bb			ld a, (.dmark+2)  
bbc6 32 64 ee			ld (debug_mark+2),a  
bbc9 18 03			jr .pastdmark  
bbcb ..			.dmark: db "RN2"  
bbce f1			.pastdmark: pop af  
bbcf			endm  
# End of macro DMARK
bbcf						CALLMONITOR 
bbcf cd 6f ee			call debug_vector  
bbd2				endm  
# End of macro CALLMONITOR
bbd2					endif 
bbd2 22 a6 eb				ld (LFSRSeed+2), hl 
bbd5			 
bbd5					FORTH_DSP_POP 
bbd5 cd b2 9c			call macro_forth_dsp_pop 
bbd8				endm 
# End of macro FORTH_DSP_POP
bbd8			 
bbd8 e5					push hl 
bbd9			 
bbd9 e1			.inrange:	pop hl 
bbda cd 11 8c				call prng16  
bbdd					if DEBUG_FORTH_WORDS 
bbdd						DMARK "RN3" 
bbdd f5				push af  
bbde 3a f2 bb			ld a, (.dmark)  
bbe1 32 62 ee			ld (debug_mark),a  
bbe4 3a f3 bb			ld a, (.dmark+1)  
bbe7 32 63 ee			ld (debug_mark+1),a  
bbea 3a f4 bb			ld a, (.dmark+2)  
bbed 32 64 ee			ld (debug_mark+2),a  
bbf0 18 03			jr .pastdmark  
bbf2 ..			.dmark: db "RN3"  
bbf5 f1			.pastdmark: pop af  
bbf6			endm  
# End of macro DMARK
bbf6						CALLMONITOR 
bbf6 cd 6f ee			call debug_vector  
bbf9				endm  
# End of macro CALLMONITOR
bbf9					endif 
bbf9					 
bbf9					; if the range is 8bit knock out the high byte 
bbf9			 
bbf9 ed 5b a4 eb			ld de, (LFSRSeed)     ; check high level 
bbfd			 
bbfd 3e 00				ld a, 0 
bbff ba					cp d  
bc00 20 1e				jr nz, .hirange 
bc02 26 00				ld h, 0   ; knock it down to 8bit 
bc04			 
bc04					if DEBUG_FORTH_WORDS 
bc04						DMARK "RNk" 
bc04 f5				push af  
bc05 3a 19 bc			ld a, (.dmark)  
bc08 32 62 ee			ld (debug_mark),a  
bc0b 3a 1a bc			ld a, (.dmark+1)  
bc0e 32 63 ee			ld (debug_mark+1),a  
bc11 3a 1b bc			ld a, (.dmark+2)  
bc14 32 64 ee			ld (debug_mark+2),a  
bc17 18 03			jr .pastdmark  
bc19 ..			.dmark: db "RNk"  
bc1c f1			.pastdmark: pop af  
bc1d			endm  
# End of macro DMARK
bc1d						CALLMONITOR 
bc1d cd 6f ee			call debug_vector  
bc20				endm  
# End of macro CALLMONITOR
bc20					endif 
bc20			.hirange:   
bc20 e5					push hl  
bc21 b7					or a  
bc22 ed 52		                sbc hl, de 
bc24			 
bc24					;call cmp16 
bc24			 
bc24 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
bc26 e1					pop hl 
bc27 e5					push hl 
bc28			 
bc28					if DEBUG_FORTH_WORDS 
bc28						DMARK "RN4" 
bc28 f5				push af  
bc29 3a 3d bc			ld a, (.dmark)  
bc2c 32 62 ee			ld (debug_mark),a  
bc2f 3a 3e bc			ld a, (.dmark+1)  
bc32 32 63 ee			ld (debug_mark+1),a  
bc35 3a 3f bc			ld a, (.dmark+2)  
bc38 32 64 ee			ld (debug_mark+2),a  
bc3b 18 03			jr .pastdmark  
bc3d ..			.dmark: db "RN4"  
bc40 f1			.pastdmark: pop af  
bc41			endm  
# End of macro DMARK
bc41						CALLMONITOR 
bc41 cd 6f ee			call debug_vector  
bc44				endm  
# End of macro CALLMONITOR
bc44					endif 
bc44 ed 5b a6 eb			ld de, (LFSRSeed+2)   ; check low range 
bc48					;call cmp16 
bc48				 
bc48 b7					or a  
bc49 ed 52		                sbc hl, de 
bc4b 38 8c				jr c, .inrange 
bc4d			 
bc4d e1					pop hl 
bc4e					 
bc4e					if DEBUG_FORTH_WORDS 
bc4e						DMARK "RNd" 
bc4e f5				push af  
bc4f 3a 63 bc			ld a, (.dmark)  
bc52 32 62 ee			ld (debug_mark),a  
bc55 3a 64 bc			ld a, (.dmark+1)  
bc58 32 63 ee			ld (debug_mark+1),a  
bc5b 3a 65 bc			ld a, (.dmark+2)  
bc5e 32 64 ee			ld (debug_mark+2),a  
bc61 18 03			jr .pastdmark  
bc63 ..			.dmark: db "RNd"  
bc66 f1			.pastdmark: pop af  
bc67			endm  
# End of macro DMARK
bc67						CALLMONITOR 
bc67 cd 6f ee			call debug_vector  
bc6a				endm  
# End of macro CALLMONITOR
bc6a					endif 
bc6a			 
bc6a			 
bc6a cd f5 99				call forth_push_numhl 
bc6d				       NEXTW 
bc6d cd 6c ee			call parse_vector 
bc70 c3 e5 9d			jp macro_next 
bc73				endm 
# End of macro NEXTW
bc73			 
bc73			.ENDMATHS: 
bc73			 
bc73			; eof 
bc73			 
# End of file forth_words_maths.asm
bc73			include "forth_words_display.asm" 
bc73			 
bc73			; | ## Display Words 
bc73			 
bc73			.ACT: 
bc73			 
bc73				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
bc73 62				db WORD_SYS_CORE+78             
bc74 c2 bc			dw .INFO            
bc76 07				db 6 + 1 
bc77 .. 00			db "ACTIVE",0              
bc7e				endm 
# End of macro CWHEAD
bc7e			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
bc7e			;  
bc7e			; | | To display a pulsing activity indicator in a processing loop do this... 
bc7e			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
bc7e			 
bc7e					if DEBUG_FORTH_WORDS_KEY 
bc7e						DMARK "ACT" 
bc7e f5				push af  
bc7f 3a 93 bc			ld a, (.dmark)  
bc82 32 62 ee			ld (debug_mark),a  
bc85 3a 94 bc			ld a, (.dmark+1)  
bc88 32 63 ee			ld (debug_mark+1),a  
bc8b 3a 95 bc			ld a, (.dmark+2)  
bc8e 32 64 ee			ld (debug_mark+2),a  
bc91 18 03			jr .pastdmark  
bc93 ..			.dmark: db "ACT"  
bc96 f1			.pastdmark: pop af  
bc97			endm  
# End of macro DMARK
bc97						CALLMONITOR 
bc97 cd 6f ee			call debug_vector  
bc9a				endm  
# End of macro CALLMONITOR
bc9a					endif 
bc9a cd 14 8a				call active 
bc9d					if DEBUG_FORTH_WORDS 
bc9d						DMARK "ACp" 
bc9d f5				push af  
bc9e 3a b2 bc			ld a, (.dmark)  
bca1 32 62 ee			ld (debug_mark),a  
bca4 3a b3 bc			ld a, (.dmark+1)  
bca7 32 63 ee			ld (debug_mark+1),a  
bcaa 3a b4 bc			ld a, (.dmark+2)  
bcad 32 64 ee			ld (debug_mark+2),a  
bcb0 18 03			jr .pastdmark  
bcb2 ..			.dmark: db "ACp"  
bcb5 f1			.pastdmark: pop af  
bcb6			endm  
# End of macro DMARK
bcb6						CALLMONITOR 
bcb6 cd 6f ee			call debug_vector  
bcb9				endm  
# End of macro CALLMONITOR
bcb9					endif 
bcb9 cd 63 9a				call forth_push_str 
bcbc			 
bcbc					NEXTW 
bcbc cd 6c ee			call parse_vector 
bcbf c3 e5 9d			jp macro_next 
bcc2				endm 
# End of macro NEXTW
bcc2			.INFO: 
bcc2			 
bcc2				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
bcc2 62				db WORD_SYS_CORE+78             
bcc3 e2 bc			dw .ATP            
bcc5 05				db 4 + 1 
bcc6 .. 00			db "INFO",0              
bccb				endm 
# End of macro CWHEAD
bccb			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
bccb					FORTH_DSP_VALUEHL 
bccb cd fa 9b			call macro_dsp_valuehl 
bcce				endm 
# End of macro FORTH_DSP_VALUEHL
bcce			 
bcce					FORTH_DSP_POP 
bcce cd b2 9c			call macro_forth_dsp_pop 
bcd1				endm 
# End of macro FORTH_DSP_POP
bcd1			 
bcd1 e5					push hl 
bcd2			 
bcd2					FORTH_DSP_VALUEHL 
bcd2 cd fa 9b			call macro_dsp_valuehl 
bcd5				endm 
# End of macro FORTH_DSP_VALUEHL
bcd5			 
bcd5					FORTH_DSP_POP 
bcd5 cd b2 9c			call macro_forth_dsp_pop 
bcd8				endm 
# End of macro FORTH_DSP_POP
bcd8			 
bcd8 d1					pop de 
bcd9			 
bcd9 cd 4e 8a				call info_panel 
bcdc			 
bcdc			 
bcdc					NEXTW 
bcdc cd 6c ee			call parse_vector 
bcdf c3 e5 9d			jp macro_next 
bce2				endm 
# End of macro NEXTW
bce2			.ATP: 
bce2				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
bce2 62				db WORD_SYS_CORE+78             
bce3 5c bd			dw .FB            
bce5 04				db 3 + 1 
bce6 .. 00			db "AT?",0              
bcea				endm 
# End of macro CWHEAD
bcea			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
bcea					if DEBUG_FORTH_WORDS_KEY 
bcea						DMARK "AT?" 
bcea f5				push af  
bceb 3a ff bc			ld a, (.dmark)  
bcee 32 62 ee			ld (debug_mark),a  
bcf1 3a 00 bd			ld a, (.dmark+1)  
bcf4 32 63 ee			ld (debug_mark+1),a  
bcf7 3a 01 bd			ld a, (.dmark+2)  
bcfa 32 64 ee			ld (debug_mark+2),a  
bcfd 18 03			jr .pastdmark  
bcff ..			.dmark: db "AT?"  
bd02 f1			.pastdmark: pop af  
bd03			endm  
# End of macro DMARK
bd03						CALLMONITOR 
bd03 cd 6f ee			call debug_vector  
bd06				endm  
# End of macro CALLMONITOR
bd06					endif 
bd06 3a 55 ea				ld a, (f_cursor_ptr) 
bd09			 
bd09			if DEBUG_FORTH_WORDS 
bd09				DMARK "AT?" 
bd09 f5				push af  
bd0a 3a 1e bd			ld a, (.dmark)  
bd0d 32 62 ee			ld (debug_mark),a  
bd10 3a 1f bd			ld a, (.dmark+1)  
bd13 32 63 ee			ld (debug_mark+1),a  
bd16 3a 20 bd			ld a, (.dmark+2)  
bd19 32 64 ee			ld (debug_mark+2),a  
bd1c 18 03			jr .pastdmark  
bd1e ..			.dmark: db "AT?"  
bd21 f1			.pastdmark: pop af  
bd22			endm  
# End of macro DMARK
bd22				CALLMONITOR 
bd22 cd 6f ee			call debug_vector  
bd25				endm  
# End of macro CALLMONITOR
bd25			endif	 
bd25					; count the number of rows 
bd25			 
bd25 06 00				ld b, 0 
bd27 4f			.atpr:		ld c, a    ; save in case we go below zero 
bd28 d6 28				sub display_cols 
bd2a f2 30 bd				jp p, .atprunder 
bd2d 04					inc b 
bd2e 18 f7				jr .atpr 
bd30			.atprunder:	 
bd30			if DEBUG_FORTH_WORDS 
bd30				DMARK "A?2" 
bd30 f5				push af  
bd31 3a 45 bd			ld a, (.dmark)  
bd34 32 62 ee			ld (debug_mark),a  
bd37 3a 46 bd			ld a, (.dmark+1)  
bd3a 32 63 ee			ld (debug_mark+1),a  
bd3d 3a 47 bd			ld a, (.dmark+2)  
bd40 32 64 ee			ld (debug_mark+2),a  
bd43 18 03			jr .pastdmark  
bd45 ..			.dmark: db "A?2"  
bd48 f1			.pastdmark: pop af  
bd49			endm  
# End of macro DMARK
bd49				CALLMONITOR 
bd49 cd 6f ee			call debug_vector  
bd4c				endm  
# End of macro CALLMONITOR
bd4c			endif	 
bd4c 26 00				ld h, 0 
bd4e 69					ld l, c 
bd4f cd f5 99				call forth_push_numhl 
bd52 68					ld l, b  
bd53 cd f5 99				call forth_push_numhl 
bd56			 
bd56			 
bd56				NEXTW 
bd56 cd 6c ee			call parse_vector 
bd59 c3 e5 9d			jp macro_next 
bd5c				endm 
# End of macro NEXTW
bd5c			 
bd5c			.FB: 
bd5c				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
bd5c 1b				db WORD_SYS_CORE+7             
bd5d ad bd			dw .EMIT            
bd5f 03				db 2 + 1 
bd60 .. 00			db "FB",0              
bd63				endm 
# End of macro CWHEAD
bd63			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
bd63			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
bd63			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
bd63			; | | If automatic display is off then updates will not be shown until DRAW is used. 
bd63					if DEBUG_FORTH_WORDS_KEY 
bd63						DMARK "FB." 
bd63 f5				push af  
bd64 3a 78 bd			ld a, (.dmark)  
bd67 32 62 ee			ld (debug_mark),a  
bd6a 3a 79 bd			ld a, (.dmark+1)  
bd6d 32 63 ee			ld (debug_mark+1),a  
bd70 3a 7a bd			ld a, (.dmark+2)  
bd73 32 64 ee			ld (debug_mark+2),a  
bd76 18 03			jr .pastdmark  
bd78 ..			.dmark: db "FB."  
bd7b f1			.pastdmark: pop af  
bd7c			endm  
# End of macro DMARK
bd7c						CALLMONITOR 
bd7c cd 6f ee			call debug_vector  
bd7f				endm  
# End of macro CALLMONITOR
bd7f					endif 
bd7f			 
bd7f					FORTH_DSP_VALUEHL 
bd7f cd fa 9b			call macro_dsp_valuehl 
bd82				endm 
# End of macro FORTH_DSP_VALUEHL
bd82			 
bd82 7d					ld a, l 
bd83 fe 01				cp 1 
bd85 20 05				jr nz, .fbn1 
bd87 21 07 ed				ld hl, display_fb1 
bd8a 18 15				jr .fbset 
bd8c fe 02		.fbn1:		cp 2 
bd8e 20 05				jr nz, .fbn2 
bd90 21 c5 eb				ld hl, display_fb2 
bd93 18 0c				jr .fbset 
bd95 fe 03		.fbn2:		cp 3 
bd97 20 05				jr nz, .fbn3 
bd99 21 66 ec				ld hl, display_fb3 
bd9c 18 03				jr .fbset 
bd9e			.fbn3:		 ; if invalid number select first 
bd9e 21 07 ed				ld hl, display_fb1 
bda1 22 c3 eb		.fbset:		ld (display_fb_active), hl 
bda4			 
bda4					FORTH_DSP_POP 
bda4 cd b2 9c			call macro_forth_dsp_pop 
bda7				endm 
# End of macro FORTH_DSP_POP
bda7			 
bda7					NEXTW 
bda7 cd 6c ee			call parse_vector 
bdaa c3 e5 9d			jp macro_next 
bdad				endm 
# End of macro NEXTW
bdad			 
bdad			 
bdad			.EMIT: 
bdad				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
bdad 1b				db WORD_SYS_CORE+7             
bdae 01 be			dw .DOTH            
bdb0 05				db 4 + 1 
bdb1 .. 00			db "EMIT",0              
bdb6				endm 
# End of macro CWHEAD
bdb6			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
bdb6					; get value off TOS and display it 
bdb6			 
bdb6					if DEBUG_FORTH_WORDS_KEY 
bdb6						DMARK "EMT" 
bdb6 f5				push af  
bdb7 3a cb bd			ld a, (.dmark)  
bdba 32 62 ee			ld (debug_mark),a  
bdbd 3a cc bd			ld a, (.dmark+1)  
bdc0 32 63 ee			ld (debug_mark+1),a  
bdc3 3a cd bd			ld a, (.dmark+2)  
bdc6 32 64 ee			ld (debug_mark+2),a  
bdc9 18 03			jr .pastdmark  
bdcb ..			.dmark: db "EMT"  
bdce f1			.pastdmark: pop af  
bdcf			endm  
# End of macro DMARK
bdcf						CALLMONITOR 
bdcf cd 6f ee			call debug_vector  
bdd2				endm  
# End of macro CALLMONITOR
bdd2					endif 
bdd2			 
bdd2					FORTH_DSP_VALUEHL 
bdd2 cd fa 9b			call macro_dsp_valuehl 
bdd5				endm 
# End of macro FORTH_DSP_VALUEHL
bdd5			 
bdd5 7d					ld a,l 
bdd6			 
bdd6					; TODO write to display 
bdd6			 
bdd6 32 b6 e4				ld (os_input), a 
bdd9 3e 00				ld a, 0 
bddb 32 b7 e4				ld (os_input+1), a 
bdde					 
bdde 3a 55 ea				ld a, (f_cursor_ptr) 
bde1 11 b6 e4				ld de, os_input 
bde4 cd d0 8a				call str_at_display 
bde7			 
bde7			 
bde7 3a 33 ea				ld a,(cli_autodisplay) 
bdea fe 00				cp 0 
bdec 28 03				jr z, .enoupdate 
bdee cd e0 8a						call update_display 
bdf1					.enoupdate: 
bdf1			 
bdf1 3a 55 ea				ld a, (f_cursor_ptr) 
bdf4 3c					inc a 
bdf5 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
bdf8			 
bdf8			 
bdf8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdf8 cd b2 9c			call macro_forth_dsp_pop 
bdfb				endm 
# End of macro FORTH_DSP_POP
bdfb			  
bdfb			 
bdfb					NEXTW 
bdfb cd 6c ee			call parse_vector 
bdfe c3 e5 9d			jp macro_next 
be01				endm 
# End of macro NEXTW
be01			.DOTH: 
be01				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
be01 1c				db WORD_SYS_CORE+8             
be02 34 be			dw .DOTF            
be04 03				db 2 + 1 
be05 .. 00			db ".-",0              
be08				endm 
# End of macro CWHEAD
be08			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
be08					; get value off TOS and display it 
be08					if DEBUG_FORTH_WORDS_KEY 
be08						DMARK "DTD" 
be08 f5				push af  
be09 3a 1d be			ld a, (.dmark)  
be0c 32 62 ee			ld (debug_mark),a  
be0f 3a 1e be			ld a, (.dmark+1)  
be12 32 63 ee			ld (debug_mark+1),a  
be15 3a 1f be			ld a, (.dmark+2)  
be18 32 64 ee			ld (debug_mark+2),a  
be1b 18 03			jr .pastdmark  
be1d ..			.dmark: db "DTD"  
be20 f1			.pastdmark: pop af  
be21			endm  
# End of macro DMARK
be21						CALLMONITOR 
be21 cd 6f ee			call debug_vector  
be24				endm  
# End of macro CALLMONITOR
be24					endif 
be24 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
be26 3e 00			ld a, 0 
be28 32 34 ea			ld (cli_mvdot), a 
be2b c3 8e be			jp .dotgo 
be2e				NEXTW 
be2e cd 6c ee			call parse_vector 
be31 c3 e5 9d			jp macro_next 
be34				endm 
# End of macro NEXTW
be34			.DOTF: 
be34				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
be34 1c				db WORD_SYS_CORE+8             
be35 65 be			dw .DOT            
be37 03				db 2 + 1 
be38 .. 00			db ".>",0              
be3b				endm 
# End of macro CWHEAD
be3b			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
be3b					; get value off TOS and display it 
be3b			        ; TODO BUG adds extra spaces 
be3b			        ; TODO BUG handle numerics? 
be3b					if DEBUG_FORTH_WORDS_KEY 
be3b						DMARK "DTC" 
be3b f5				push af  
be3c 3a 50 be			ld a, (.dmark)  
be3f 32 62 ee			ld (debug_mark),a  
be42 3a 51 be			ld a, (.dmark+1)  
be45 32 63 ee			ld (debug_mark+1),a  
be48 3a 52 be			ld a, (.dmark+2)  
be4b 32 64 ee			ld (debug_mark+2),a  
be4e 18 03			jr .pastdmark  
be50 ..			.dmark: db "DTC"  
be53 f1			.pastdmark: pop af  
be54			endm  
# End of macro DMARK
be54						CALLMONITOR 
be54 cd 6f ee			call debug_vector  
be57				endm  
# End of macro CALLMONITOR
be57					endif 
be57 3e 01			ld a, 1 
be59 32 34 ea			ld (cli_mvdot), a 
be5c c3 8e be			jp .dotgo 
be5f				NEXTW 
be5f cd 6c ee			call parse_vector 
be62 c3 e5 9d			jp macro_next 
be65				endm 
# End of macro NEXTW
be65			 
be65			.DOT: 
be65				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
be65 1c				db WORD_SYS_CORE+8             
be66 44 c0			dw .CLS            
be68 02				db 1 + 1 
be69 .. 00			db ".",0              
be6b				endm 
# End of macro CWHEAD
be6b			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
be6b					; get value off TOS and display it 
be6b			 
be6b					if DEBUG_FORTH_WORDS_KEY 
be6b						DMARK "DOT" 
be6b f5				push af  
be6c 3a 80 be			ld a, (.dmark)  
be6f 32 62 ee			ld (debug_mark),a  
be72 3a 81 be			ld a, (.dmark+1)  
be75 32 63 ee			ld (debug_mark+1),a  
be78 3a 82 be			ld a, (.dmark+2)  
be7b 32 64 ee			ld (debug_mark+2),a  
be7e 18 03			jr .pastdmark  
be80 ..			.dmark: db "DOT"  
be83 f1			.pastdmark: pop af  
be84			endm  
# End of macro DMARK
be84						CALLMONITOR 
be84 cd 6f ee			call debug_vector  
be87				endm  
# End of macro CALLMONITOR
be87					endif 
be87 3e 00			ld a, 0 
be89 32 34 ea			ld (cli_mvdot), a 
be8c 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
be8e				 
be8e			 
be8e			.dotgo: 
be8e			 
be8e			; move up type to on stack for parserv5 
be8e					FORTH_DSP 
be8e cd c0 9b			call macro_forth_dsp 
be91				endm 
# End of macro FORTH_DSP
be91				;FORTH_DSP_VALUE  
be91			 
be91			if DEBUG_FORTH_DOT 
be91				DMARK "DOT" 
be91 f5				push af  
be92 3a a6 be			ld a, (.dmark)  
be95 32 62 ee			ld (debug_mark),a  
be98 3a a7 be			ld a, (.dmark+1)  
be9b 32 63 ee			ld (debug_mark+1),a  
be9e 3a a8 be			ld a, (.dmark+2)  
bea1 32 64 ee			ld (debug_mark+2),a  
bea4 18 03			jr .pastdmark  
bea6 ..			.dmark: db "DOT"  
bea9 f1			.pastdmark: pop af  
beaa			endm  
# End of macro DMARK
beaa				CALLMONITOR 
beaa cd 6f ee			call debug_vector  
bead				endm  
# End of macro CALLMONITOR
bead			endif	 
bead			;		.print: 
bead			 
bead 7e				ld a,(hl)  ; work out what type of value is on the TOS 
beae 23				inc hl   ; position to the actual value 
beaf fe 01			cp DS_TYPE_STR 
beb1 20 06			jr nz, .dotnum1  
beb3			 
beb3			; display string 
beb3				FORTH_DSP_VALUE  
beb3 cd e3 9b			call macro_forth_dsp_value 
beb6				endm 
# End of macro FORTH_DSP_VALUE
beb6 eb				ex de,hl 
beb7 18 49			jr .dotwrite 
beb9			 
beb9			.dotnum1: 
beb9 fe 02			cp DS_TYPE_INUM 
bebb 20 44			jr nz, .dotflot 
bebd			 
bebd			 
bebd			; display number 
bebd			 
bebd			;	push hl 
bebd			;	call clear_display 
bebd			;	pop hl 
bebd			 
bebd 5e				ld e, (hl) 
bebe 23				inc hl 
bebf 56				ld d, (hl) 
bec0 21 b8 e2			ld hl, scratch 
bec3			if DEBUG_FORTH_DOT 
bec3				DMARK "DT1" 
bec3 f5				push af  
bec4 3a d8 be			ld a, (.dmark)  
bec7 32 62 ee			ld (debug_mark),a  
beca 3a d9 be			ld a, (.dmark+1)  
becd 32 63 ee			ld (debug_mark+1),a  
bed0 3a da be			ld a, (.dmark+2)  
bed3 32 64 ee			ld (debug_mark+2),a  
bed6 18 03			jr .pastdmark  
bed8 ..			.dmark: db "DT1"  
bedb f1			.pastdmark: pop af  
bedc			endm  
# End of macro DMARK
bedc				CALLMONITOR 
bedc cd 6f ee			call debug_vector  
bedf				endm  
# End of macro CALLMONITOR
bedf			endif	 
bedf			 
bedf cd ff 8f			call uitoa_16 
bee2 eb				ex de,hl 
bee3			 
bee3			if DEBUG_FORTH_DOT 
bee3				DMARK "DT2" 
bee3 f5				push af  
bee4 3a f8 be			ld a, (.dmark)  
bee7 32 62 ee			ld (debug_mark),a  
beea 3a f9 be			ld a, (.dmark+1)  
beed 32 63 ee			ld (debug_mark+1),a  
bef0 3a fa be			ld a, (.dmark+2)  
bef3 32 64 ee			ld (debug_mark+2),a  
bef6 18 03			jr .pastdmark  
bef8 ..			.dmark: db "DT2"  
befb f1			.pastdmark: pop af  
befc			endm  
# End of macro DMARK
befc				CALLMONITOR 
befc cd 6f ee			call debug_vector  
beff				endm  
# End of macro CALLMONITOR
beff			endif	 
beff			 
beff			;	ld de, os_word_scratch 
beff 18 01			jr .dotwrite 
bf01			 
bf01 00			.dotflot:   nop 
bf02			; TODO print floating point number 
bf02			 
bf02			.dotwrite:		 
bf02			 
bf02					; if c is set then set all '-' to spaces 
bf02					; need to also take into account .>  
bf02			 
bf02 3e 01				ld a, 1 
bf04 b9					cp c 
bf05 20 67				jr nz, .nodashswap 
bf07			 
bf07					; DE has the string to write, working with HL 
bf07			 
bf07 06 ff				ld b, 255 
bf09 d5					push de 
bf0a e1					pop hl 
bf0b			 
bf0b			if DEBUG_FORTH_DOT 
bf0b				DMARK "DT-" 
bf0b f5				push af  
bf0c 3a 20 bf			ld a, (.dmark)  
bf0f 32 62 ee			ld (debug_mark),a  
bf12 3a 21 bf			ld a, (.dmark+1)  
bf15 32 63 ee			ld (debug_mark+1),a  
bf18 3a 22 bf			ld a, (.dmark+2)  
bf1b 32 64 ee			ld (debug_mark+2),a  
bf1e 18 03			jr .pastdmark  
bf20 ..			.dmark: db "DT-"  
bf23 f1			.pastdmark: pop af  
bf24			endm  
# End of macro DMARK
bf24				CALLMONITOR 
bf24 cd 6f ee			call debug_vector  
bf27				endm  
# End of macro CALLMONITOR
bf27			endif	 
bf27 7e			.dashscan:	ld a, (hl) 
bf28 fe 00				cp 0 
bf2a 28 42				jr z, .nodashswap 
bf2c fe 2d				cp '-' 
bf2e 20 03				jr nz, .dashskip 
bf30 3e 20				ld a, ' ' 
bf32 77					ld (hl), a 
bf33 23			.dashskip:	inc hl 
bf34			if DEBUG_FORTH_DOT 
bf34				DMARK "D-2" 
bf34 f5				push af  
bf35 3a 49 bf			ld a, (.dmark)  
bf38 32 62 ee			ld (debug_mark),a  
bf3b 3a 4a bf			ld a, (.dmark+1)  
bf3e 32 63 ee			ld (debug_mark+1),a  
bf41 3a 4b bf			ld a, (.dmark+2)  
bf44 32 64 ee			ld (debug_mark+2),a  
bf47 18 03			jr .pastdmark  
bf49 ..			.dmark: db "D-2"  
bf4c f1			.pastdmark: pop af  
bf4d			endm  
# End of macro DMARK
bf4d				CALLMONITOR 
bf4d cd 6f ee			call debug_vector  
bf50				endm  
# End of macro CALLMONITOR
bf50			endif	 
bf50 10 d5				djnz .dashscan 
bf52			 
bf52			if DEBUG_FORTH_DOT 
bf52				DMARK "D-1" 
bf52 f5				push af  
bf53 3a 67 bf			ld a, (.dmark)  
bf56 32 62 ee			ld (debug_mark),a  
bf59 3a 68 bf			ld a, (.dmark+1)  
bf5c 32 63 ee			ld (debug_mark+1),a  
bf5f 3a 69 bf			ld a, (.dmark+2)  
bf62 32 64 ee			ld (debug_mark+2),a  
bf65 18 03			jr .pastdmark  
bf67 ..			.dmark: db "D-1"  
bf6a f1			.pastdmark: pop af  
bf6b			endm  
# End of macro DMARK
bf6b				CALLMONITOR 
bf6b cd 6f ee			call debug_vector  
bf6e				endm  
# End of macro CALLMONITOR
bf6e			endif	 
bf6e			 
bf6e			.nodashswap: 
bf6e			 
bf6e			if DEBUG_FORTH_DOT 
bf6e				DMARK "D-o" 
bf6e f5				push af  
bf6f 3a 83 bf			ld a, (.dmark)  
bf72 32 62 ee			ld (debug_mark),a  
bf75 3a 84 bf			ld a, (.dmark+1)  
bf78 32 63 ee			ld (debug_mark+1),a  
bf7b 3a 85 bf			ld a, (.dmark+2)  
bf7e 32 64 ee			ld (debug_mark+2),a  
bf81 18 03			jr .pastdmark  
bf83 ..			.dmark: db "D-o"  
bf86 f1			.pastdmark: pop af  
bf87			endm  
# End of macro DMARK
bf87				CALLMONITOR 
bf87 cd 6f ee			call debug_vector  
bf8a				endm  
# End of macro CALLMONITOR
bf8a			endif	 
bf8a			 
bf8a d5					push de   ; save string start in case we need to advance print 
bf8b			 
bf8b 3a 55 ea				ld a, (f_cursor_ptr) 
bf8e cd d0 8a				call str_at_display 
bf91 3a 33 ea				ld a,(cli_autodisplay) 
bf94 fe 00				cp 0 
bf96 28 03				jr z, .noupdate 
bf98 cd e0 8a						call update_display 
bf9b					.noupdate: 
bf9b			 
bf9b			 
bf9b					; see if we need to advance the print position 
bf9b			 
bf9b e1					pop hl   ; get back string 
bf9c			;		ex de,hl 
bf9c			 
bf9c 3a 34 ea				ld a, (cli_mvdot) 
bf9f			if DEBUG_FORTH_DOT 
bf9f			;		ld e,a 
bf9f				DMARK "D>1" 
bf9f f5				push af  
bfa0 3a b4 bf			ld a, (.dmark)  
bfa3 32 62 ee			ld (debug_mark),a  
bfa6 3a b5 bf			ld a, (.dmark+1)  
bfa9 32 63 ee			ld (debug_mark+1),a  
bfac 3a b6 bf			ld a, (.dmark+2)  
bfaf 32 64 ee			ld (debug_mark+2),a  
bfb2 18 03			jr .pastdmark  
bfb4 ..			.dmark: db "D>1"  
bfb7 f1			.pastdmark: pop af  
bfb8			endm  
# End of macro DMARK
bfb8				CALLMONITOR 
bfb8 cd 6f ee			call debug_vector  
bfbb				endm  
# End of macro CALLMONITOR
bfbb			endif	 
bfbb fe 00				cp 0 
bfbd 28 44				jr z, .noadv 
bfbf					; yes, lets advance the print position 
bfbf 3e 00				ld a, 0 
bfc1 cd 5b 90				call strlent 
bfc4			if DEBUG_FORTH_DOT 
bfc4				DMARK "D-?" 
bfc4 f5				push af  
bfc5 3a d9 bf			ld a, (.dmark)  
bfc8 32 62 ee			ld (debug_mark),a  
bfcb 3a da bf			ld a, (.dmark+1)  
bfce 32 63 ee			ld (debug_mark+1),a  
bfd1 3a db bf			ld a, (.dmark+2)  
bfd4 32 64 ee			ld (debug_mark+2),a  
bfd7 18 03			jr .pastdmark  
bfd9 ..			.dmark: db "D-?"  
bfdc f1			.pastdmark: pop af  
bfdd			endm  
# End of macro DMARK
bfdd				CALLMONITOR 
bfdd cd 6f ee			call debug_vector  
bfe0				endm  
# End of macro CALLMONITOR
bfe0			endif	 
bfe0 3a 55 ea				ld a, (f_cursor_ptr) 
bfe3 85					add a,l 
bfe4					;call addatohl 
bfe4					;ld a, l 
bfe4 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
bfe7			 
bfe7			if DEBUG_FORTH_DOT 
bfe7				DMARK "D->" 
bfe7 f5				push af  
bfe8 3a fc bf			ld a, (.dmark)  
bfeb 32 62 ee			ld (debug_mark),a  
bfee 3a fd bf			ld a, (.dmark+1)  
bff1 32 63 ee			ld (debug_mark+1),a  
bff4 3a fe bf			ld a, (.dmark+2)  
bff7 32 64 ee			ld (debug_mark+2),a  
bffa 18 03			jr .pastdmark  
bffc ..			.dmark: db "D->"  
bfff f1			.pastdmark: pop af  
c000			endm  
# End of macro DMARK
c000				CALLMONITOR 
c000 cd 6f ee			call debug_vector  
c003				endm  
# End of macro CALLMONITOR
c003			endif	 
c003			 
c003			.noadv:	 
c003			 
c003					if DEBUG_FORTH_DOT_WAIT 
c003							call next_page_prompt 
c003					endif	 
c003			; TODO this pop off the stack causes a crash. i dont know why 
c003			 
c003			 
c003			if DEBUG_FORTH_DOT 
c003				DMARK "DTh" 
c003 f5				push af  
c004 3a 18 c0			ld a, (.dmark)  
c007 32 62 ee			ld (debug_mark),a  
c00a 3a 19 c0			ld a, (.dmark+1)  
c00d 32 63 ee			ld (debug_mark+1),a  
c010 3a 1a c0			ld a, (.dmark+2)  
c013 32 64 ee			ld (debug_mark+2),a  
c016 18 03			jr .pastdmark  
c018 ..			.dmark: db "DTh"  
c01b f1			.pastdmark: pop af  
c01c			endm  
# End of macro DMARK
c01c				CALLMONITOR 
c01c cd 6f ee			call debug_vector  
c01f				endm  
# End of macro CALLMONITOR
c01f			endif	 
c01f			 
c01f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c01f cd b2 9c			call macro_forth_dsp_pop 
c022				endm 
# End of macro FORTH_DSP_POP
c022			 
c022			if DEBUG_FORTH_DOT 
c022				DMARK "DTi" 
c022 f5				push af  
c023 3a 37 c0			ld a, (.dmark)  
c026 32 62 ee			ld (debug_mark),a  
c029 3a 38 c0			ld a, (.dmark+1)  
c02c 32 63 ee			ld (debug_mark+1),a  
c02f 3a 39 c0			ld a, (.dmark+2)  
c032 32 64 ee			ld (debug_mark+2),a  
c035 18 03			jr .pastdmark  
c037 ..			.dmark: db "DTi"  
c03a f1			.pastdmark: pop af  
c03b			endm  
# End of macro DMARK
c03b				CALLMONITOR 
c03b cd 6f ee			call debug_vector  
c03e				endm  
# End of macro CALLMONITOR
c03e			endif	 
c03e			 
c03e			 
c03e					NEXTW 
c03e cd 6c ee			call parse_vector 
c041 c3 e5 9d			jp macro_next 
c044				endm 
# End of macro NEXTW
c044			 
c044			.CLS: 
c044				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
c044 35				db WORD_SYS_CORE+33             
c045 74 c0			dw .DRAW            
c047 04				db 3 + 1 
c048 .. 00			db "CLS",0              
c04c				endm 
# End of macro CWHEAD
c04c			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
c04c					if DEBUG_FORTH_WORDS_KEY 
c04c						DMARK "CLS" 
c04c f5				push af  
c04d 3a 61 c0			ld a, (.dmark)  
c050 32 62 ee			ld (debug_mark),a  
c053 3a 62 c0			ld a, (.dmark+1)  
c056 32 63 ee			ld (debug_mark+1),a  
c059 3a 63 c0			ld a, (.dmark+2)  
c05c 32 64 ee			ld (debug_mark+2),a  
c05f 18 03			jr .pastdmark  
c061 ..			.dmark: db "CLS"  
c064 f1			.pastdmark: pop af  
c065			endm  
# End of macro DMARK
c065						CALLMONITOR 
c065 cd 6f ee			call debug_vector  
c068				endm  
# End of macro CALLMONITOR
c068					endif 
c068 cd bd 8a				call clear_display 
c06b c3 8e c1				jp .home		; and home cursor 
c06e					NEXTW 
c06e cd 6c ee			call parse_vector 
c071 c3 e5 9d			jp macro_next 
c074				endm 
# End of macro NEXTW
c074			 
c074			.DRAW: 
c074				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
c074 36				db WORD_SYS_CORE+34             
c075 a2 c0			dw .DUMP            
c077 05				db 4 + 1 
c078 .. 00			db "DRAW",0              
c07d				endm 
# End of macro CWHEAD
c07d			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
c07d					if DEBUG_FORTH_WORDS_KEY 
c07d						DMARK "DRW" 
c07d f5				push af  
c07e 3a 92 c0			ld a, (.dmark)  
c081 32 62 ee			ld (debug_mark),a  
c084 3a 93 c0			ld a, (.dmark+1)  
c087 32 63 ee			ld (debug_mark+1),a  
c08a 3a 94 c0			ld a, (.dmark+2)  
c08d 32 64 ee			ld (debug_mark+2),a  
c090 18 03			jr .pastdmark  
c092 ..			.dmark: db "DRW"  
c095 f1			.pastdmark: pop af  
c096			endm  
# End of macro DMARK
c096						CALLMONITOR 
c096 cd 6f ee			call debug_vector  
c099				endm  
# End of macro CALLMONITOR
c099					endif 
c099 cd e0 8a				call update_display 
c09c					NEXTW 
c09c cd 6c ee			call parse_vector 
c09f c3 e5 9d			jp macro_next 
c0a2				endm 
# End of macro NEXTW
c0a2			 
c0a2			.DUMP: 
c0a2				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
c0a2 37				db WORD_SYS_CORE+35             
c0a3 dd c0			dw .CDUMP            
c0a5 05				db 4 + 1 
c0a6 .. 00			db "DUMP",0              
c0ab				endm 
# End of macro CWHEAD
c0ab			; | DUMP ( x -- ) With address x display dump   | DONE 
c0ab			; TODO pop address to use off of the stack 
c0ab					if DEBUG_FORTH_WORDS_KEY 
c0ab						DMARK "DUM" 
c0ab f5				push af  
c0ac 3a c0 c0			ld a, (.dmark)  
c0af 32 62 ee			ld (debug_mark),a  
c0b2 3a c1 c0			ld a, (.dmark+1)  
c0b5 32 63 ee			ld (debug_mark+1),a  
c0b8 3a c2 c0			ld a, (.dmark+2)  
c0bb 32 64 ee			ld (debug_mark+2),a  
c0be 18 03			jr .pastdmark  
c0c0 ..			.dmark: db "DUM"  
c0c3 f1			.pastdmark: pop af  
c0c4			endm  
# End of macro DMARK
c0c4						CALLMONITOR 
c0c4 cd 6f ee			call debug_vector  
c0c7				endm  
# End of macro CALLMONITOR
c0c7					endif 
c0c7 cd bd 8a				call clear_display 
c0ca			 
c0ca					; get address 
c0ca			 
c0ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c0ca cd fa 9b			call macro_dsp_valuehl 
c0cd				endm 
# End of macro FORTH_DSP_VALUEHL
c0cd				 
c0cd					; save it for cdump 
c0cd			 
c0cd 22 db e5				ld (os_cur_ptr),hl 
c0d0			 
c0d0					; destroy value TOS 
c0d0			 
c0d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c0d0 cd b2 9c			call macro_forth_dsp_pop 
c0d3				endm 
# End of macro FORTH_DSP_POP
c0d3			 
c0d3 cd 75 98				call dumpcont	; skip old style of param parsing	 
c0d6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
c0d7					NEXTW 
c0d7 cd 6c ee			call parse_vector 
c0da c3 e5 9d			jp macro_next 
c0dd				endm 
# End of macro NEXTW
c0dd			.CDUMP: 
c0dd				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
c0dd 38				db WORD_SYS_CORE+36             
c0de 10 c1			dw .DAT            
c0e0 06				db 5 + 1 
c0e1 .. 00			db "CDUMP",0              
c0e7				endm 
# End of macro CWHEAD
c0e7			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
c0e7					if DEBUG_FORTH_WORDS_KEY 
c0e7						DMARK "CDP" 
c0e7 f5				push af  
c0e8 3a fc c0			ld a, (.dmark)  
c0eb 32 62 ee			ld (debug_mark),a  
c0ee 3a fd c0			ld a, (.dmark+1)  
c0f1 32 63 ee			ld (debug_mark+1),a  
c0f4 3a fe c0			ld a, (.dmark+2)  
c0f7 32 64 ee			ld (debug_mark+2),a  
c0fa 18 03			jr .pastdmark  
c0fc ..			.dmark: db "CDP"  
c0ff f1			.pastdmark: pop af  
c100			endm  
# End of macro DMARK
c100						CALLMONITOR 
c100 cd 6f ee			call debug_vector  
c103				endm  
# End of macro CALLMONITOR
c103					endif 
c103 cd bd 8a				call clear_display 
c106 cd 75 98				call dumpcont	 
c109 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
c10a					NEXTW 
c10a cd 6c ee			call parse_vector 
c10d c3 e5 9d			jp macro_next 
c110				endm 
# End of macro NEXTW
c110			 
c110			 
c110			 
c110			 
c110			.DAT: 
c110				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
c110 3d				db WORD_SYS_CORE+41             
c111 69 c1			dw .HOME            
c113 03				db 2 + 1 
c114 .. 00			db "AT",0              
c117				endm 
# End of macro CWHEAD
c117			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
c117					if DEBUG_FORTH_WORDS_KEY 
c117						DMARK "AT." 
c117 f5				push af  
c118 3a 2c c1			ld a, (.dmark)  
c11b 32 62 ee			ld (debug_mark),a  
c11e 3a 2d c1			ld a, (.dmark+1)  
c121 32 63 ee			ld (debug_mark+1),a  
c124 3a 2e c1			ld a, (.dmark+2)  
c127 32 64 ee			ld (debug_mark+2),a  
c12a 18 03			jr .pastdmark  
c12c ..			.dmark: db "AT."  
c12f f1			.pastdmark: pop af  
c130			endm  
# End of macro DMARK
c130						CALLMONITOR 
c130 cd 6f ee			call debug_vector  
c133				endm  
# End of macro CALLMONITOR
c133					endif 
c133					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c133 cd fa 9b			call macro_dsp_valuehl 
c136				endm 
# End of macro FORTH_DSP_VALUEHL
c136			 
c136			 
c136					; TODO save cursor row 
c136 7d					ld a,l 
c137 fe 02				cp 2 
c139 20 04				jr nz, .crow3 
c13b 3e 28				ld a, display_row_2 
c13d 18 12				jr .ccol1 
c13f fe 03		.crow3:		cp 3 
c141 20 04				jr nz, .crow4 
c143 3e 50				ld a, display_row_3 
c145 18 0a				jr .ccol1 
c147 fe 04		.crow4:		cp 4 
c149 20 04				jr nz, .crow1 
c14b 3e 78				ld a, display_row_4 
c14d 18 02				jr .ccol1 
c14f 3e 00		.crow1:		ld a,display_row_1 
c151 f5			.ccol1:		push af			; got row offset 
c152 6f					ld l,a 
c153 26 00				ld h,0 
c155					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c155 cd b2 9c			call macro_forth_dsp_pop 
c158				endm 
# End of macro FORTH_DSP_POP
c158					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c158 cd fa 9b			call macro_dsp_valuehl 
c15b				endm 
# End of macro FORTH_DSP_VALUEHL
c15b					; TODO save cursor col 
c15b f1					pop af 
c15c 85					add l		; add col offset 
c15d 32 55 ea				ld (f_cursor_ptr), a 
c160					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c160 cd b2 9c			call macro_forth_dsp_pop 
c163				endm 
# End of macro FORTH_DSP_POP
c163			 
c163					; calculate  
c163			 
c163					NEXTW 
c163 cd 6c ee			call parse_vector 
c166 c3 e5 9d			jp macro_next 
c169				endm 
# End of macro NEXTW
c169			 
c169			 
c169			.HOME: 
c169				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
c169 41				db WORD_SYS_CORE+45             
c16a 99 c1			dw .CR            
c16c 05				db 4 + 1 
c16d .. 00			db "HOME",0              
c172				endm 
# End of macro CWHEAD
c172			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
c172					if DEBUG_FORTH_WORDS_KEY 
c172						DMARK "HOM" 
c172 f5				push af  
c173 3a 87 c1			ld a, (.dmark)  
c176 32 62 ee			ld (debug_mark),a  
c179 3a 88 c1			ld a, (.dmark+1)  
c17c 32 63 ee			ld (debug_mark+1),a  
c17f 3a 89 c1			ld a, (.dmark+2)  
c182 32 64 ee			ld (debug_mark+2),a  
c185 18 03			jr .pastdmark  
c187 ..			.dmark: db "HOM"  
c18a f1			.pastdmark: pop af  
c18b			endm  
# End of macro DMARK
c18b						CALLMONITOR 
c18b cd 6f ee			call debug_vector  
c18e				endm  
# End of macro CALLMONITOR
c18e					endif 
c18e 3e 00		.home:		ld a, 0		; and home cursor 
c190 32 55 ea				ld (f_cursor_ptr), a 
c193					NEXTW 
c193 cd 6c ee			call parse_vector 
c196 c3 e5 9d			jp macro_next 
c199				endm 
# End of macro NEXTW
c199			 
c199			 
c199			.CR: 
c199				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
c199 46				db WORD_SYS_CORE+50             
c19a d7 c1			dw .SPACE            
c19c 03				db 2 + 1 
c19d .. 00			db "CR",0              
c1a0				endm 
# End of macro CWHEAD
c1a0			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
c1a0					if DEBUG_FORTH_WORDS_KEY 
c1a0						DMARK "CR." 
c1a0 f5				push af  
c1a1 3a b5 c1			ld a, (.dmark)  
c1a4 32 62 ee			ld (debug_mark),a  
c1a7 3a b6 c1			ld a, (.dmark+1)  
c1aa 32 63 ee			ld (debug_mark+1),a  
c1ad 3a b7 c1			ld a, (.dmark+2)  
c1b0 32 64 ee			ld (debug_mark+2),a  
c1b3 18 03			jr .pastdmark  
c1b5 ..			.dmark: db "CR."  
c1b8 f1			.pastdmark: pop af  
c1b9			endm  
# End of macro DMARK
c1b9						CALLMONITOR 
c1b9 cd 6f ee			call debug_vector  
c1bc				endm  
# End of macro CALLMONITOR
c1bc					endif 
c1bc 3e 0d				ld a, 13 
c1be 32 b8 e2				ld (scratch),a 
c1c1 3e 0a				ld a, 10 
c1c3 32 b9 e2				ld (scratch+1),a 
c1c6 3e 00				ld a, 0 
c1c8 32 ba e2				ld (scratch+2),a 
c1cb 21 b8 e2				ld hl, scratch 
c1ce cd 63 9a				call forth_push_str 
c1d1					 
c1d1				       NEXTW 
c1d1 cd 6c ee			call parse_vector 
c1d4 c3 e5 9d			jp macro_next 
c1d7				endm 
# End of macro NEXTW
c1d7			.SPACE: 
c1d7				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
c1d7 46				db WORD_SYS_CORE+50             
c1d8 10 c2			dw .SPACES            
c1da 03				db 2 + 1 
c1db .. 00			db "BL",0              
c1de				endm 
# End of macro CWHEAD
c1de			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
c1de					if DEBUG_FORTH_WORDS_KEY 
c1de						DMARK "BL." 
c1de f5				push af  
c1df 3a f3 c1			ld a, (.dmark)  
c1e2 32 62 ee			ld (debug_mark),a  
c1e5 3a f4 c1			ld a, (.dmark+1)  
c1e8 32 63 ee			ld (debug_mark+1),a  
c1eb 3a f5 c1			ld a, (.dmark+2)  
c1ee 32 64 ee			ld (debug_mark+2),a  
c1f1 18 03			jr .pastdmark  
c1f3 ..			.dmark: db "BL."  
c1f6 f1			.pastdmark: pop af  
c1f7			endm  
# End of macro DMARK
c1f7						CALLMONITOR 
c1f7 cd 6f ee			call debug_vector  
c1fa				endm  
# End of macro CALLMONITOR
c1fa					endif 
c1fa 3e 20				ld a, " " 
c1fc 32 b8 e2				ld (scratch),a 
c1ff 3e 00				ld a, 0 
c201 32 b9 e2				ld (scratch+1),a 
c204 21 b8 e2				ld hl, scratch 
c207 cd 63 9a				call forth_push_str 
c20a					 
c20a				       NEXTW 
c20a cd 6c ee			call parse_vector 
c20d c3 e5 9d			jp macro_next 
c210				endm 
# End of macro NEXTW
c210			 
c210			;.blstr: db " ", 0 
c210			 
c210			.SPACES: 
c210				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
c210 47				db WORD_SYS_CORE+51             
c211 ae c2			dw .SCROLL            
c213 07				db 6 + 1 
c214 .. 00			db "SPACES",0              
c21b				endm 
# End of macro CWHEAD
c21b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
c21b					if DEBUG_FORTH_WORDS_KEY 
c21b						DMARK "SPS" 
c21b f5				push af  
c21c 3a 30 c2			ld a, (.dmark)  
c21f 32 62 ee			ld (debug_mark),a  
c222 3a 31 c2			ld a, (.dmark+1)  
c225 32 63 ee			ld (debug_mark+1),a  
c228 3a 32 c2			ld a, (.dmark+2)  
c22b 32 64 ee			ld (debug_mark+2),a  
c22e 18 03			jr .pastdmark  
c230 ..			.dmark: db "SPS"  
c233 f1			.pastdmark: pop af  
c234			endm  
# End of macro DMARK
c234						CALLMONITOR 
c234 cd 6f ee			call debug_vector  
c237				endm  
# End of macro CALLMONITOR
c237					endif 
c237			 
c237			 
c237					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c237 cd fa 9b			call macro_dsp_valuehl 
c23a				endm 
# End of macro FORTH_DSP_VALUEHL
c23a			 
c23a e5					push hl    ; u 
c23b					if DEBUG_FORTH_WORDS 
c23b						DMARK "SPA" 
c23b f5				push af  
c23c 3a 50 c2			ld a, (.dmark)  
c23f 32 62 ee			ld (debug_mark),a  
c242 3a 51 c2			ld a, (.dmark+1)  
c245 32 63 ee			ld (debug_mark+1),a  
c248 3a 52 c2			ld a, (.dmark+2)  
c24b 32 64 ee			ld (debug_mark+2),a  
c24e 18 03			jr .pastdmark  
c250 ..			.dmark: db "SPA"  
c253 f1			.pastdmark: pop af  
c254			endm  
# End of macro DMARK
c254						CALLMONITOR 
c254 cd 6f ee			call debug_vector  
c257				endm  
# End of macro CALLMONITOR
c257					endif 
c257			 
c257					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c257 cd b2 9c			call macro_forth_dsp_pop 
c25a				endm 
# End of macro FORTH_DSP_POP
c25a e1					pop hl 
c25b 0e 00				ld c, 0 
c25d 45					ld b, l 
c25e 21 b8 e2				ld hl, scratch  
c261			 
c261					if DEBUG_FORTH_WORDS 
c261						DMARK "SP2" 
c261 f5				push af  
c262 3a 76 c2			ld a, (.dmark)  
c265 32 62 ee			ld (debug_mark),a  
c268 3a 77 c2			ld a, (.dmark+1)  
c26b 32 63 ee			ld (debug_mark+1),a  
c26e 3a 78 c2			ld a, (.dmark+2)  
c271 32 64 ee			ld (debug_mark+2),a  
c274 18 03			jr .pastdmark  
c276 ..			.dmark: db "SP2"  
c279 f1			.pastdmark: pop af  
c27a			endm  
# End of macro DMARK
c27a						CALLMONITOR 
c27a cd 6f ee			call debug_vector  
c27d				endm  
# End of macro CALLMONITOR
c27d					endif 
c27d 3e 20				ld a, ' ' 
c27f			.spaces1:	 
c27f 77					ld (hl),a 
c280 23					inc hl 
c281					 
c281 10 fc				djnz .spaces1 
c283 3e 00				ld a,0 
c285 77					ld (hl),a 
c286 21 b8 e2				ld hl, scratch 
c289					if DEBUG_FORTH_WORDS 
c289						DMARK "SP3" 
c289 f5				push af  
c28a 3a 9e c2			ld a, (.dmark)  
c28d 32 62 ee			ld (debug_mark),a  
c290 3a 9f c2			ld a, (.dmark+1)  
c293 32 63 ee			ld (debug_mark+1),a  
c296 3a a0 c2			ld a, (.dmark+2)  
c299 32 64 ee			ld (debug_mark+2),a  
c29c 18 03			jr .pastdmark  
c29e ..			.dmark: db "SP3"  
c2a1 f1			.pastdmark: pop af  
c2a2			endm  
# End of macro DMARK
c2a2						CALLMONITOR 
c2a2 cd 6f ee			call debug_vector  
c2a5				endm  
# End of macro CALLMONITOR
c2a5					endif 
c2a5 cd 63 9a				call forth_push_str 
c2a8			 
c2a8				       NEXTW 
c2a8 cd 6c ee			call parse_vector 
c2ab c3 e5 9d			jp macro_next 
c2ae				endm 
# End of macro NEXTW
c2ae			 
c2ae			 
c2ae			 
c2ae			.SCROLL: 
c2ae				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
c2ae 53				db WORD_SYS_CORE+63             
c2af de c2			dw .SCROLLD            
c2b1 07				db 6 + 1 
c2b2 .. 00			db "SCROLL",0              
c2b9				endm 
# End of macro CWHEAD
c2b9			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
c2b9					if DEBUG_FORTH_WORDS_KEY 
c2b9						DMARK "SCR" 
c2b9 f5				push af  
c2ba 3a ce c2			ld a, (.dmark)  
c2bd 32 62 ee			ld (debug_mark),a  
c2c0 3a cf c2			ld a, (.dmark+1)  
c2c3 32 63 ee			ld (debug_mark+1),a  
c2c6 3a d0 c2			ld a, (.dmark+2)  
c2c9 32 64 ee			ld (debug_mark+2),a  
c2cc 18 03			jr .pastdmark  
c2ce ..			.dmark: db "SCR"  
c2d1 f1			.pastdmark: pop af  
c2d2			endm  
# End of macro DMARK
c2d2						CALLMONITOR 
c2d2 cd 6f ee			call debug_vector  
c2d5				endm  
# End of macro CALLMONITOR
c2d5					endif 
c2d5			 
c2d5 cd 7f 8a			call scroll_up 
c2d8			;	call update_display 
c2d8			 
c2d8					NEXTW 
c2d8 cd 6c ee			call parse_vector 
c2db c3 e5 9d			jp macro_next 
c2de				endm 
# End of macro NEXTW
c2de			 
c2de			 
c2de			 
c2de			;		; get dir 
c2de			; 
c2de			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2de			; 
c2de			;		push hl 
c2de			; 
c2de			;		; destroy value TOS 
c2de			; 
c2de			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2de			; 
c2de			;		; get count 
c2de			; 
c2de			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2de			; 
c2de			;		push hl 
c2de			; 
c2de			;		; destroy value TOS 
c2de			; 
c2de			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2de			; 
c2de			;		; one value on hl get other one back 
c2de			; 
c2de			;		pop bc    ; count 
c2de			; 
c2de			;		pop de   ; dir 
c2de			; 
c2de			; 
c2de			;		ld b, c 
c2de			; 
c2de			;.scrolldir:     push bc 
c2de			;		push de 
c2de			; 
c2de			;		ld a, 0 
c2de			;		cp e 
c2de			;		jr z, .scrollup  
c2de			;		call scroll_down 
c2de			;		jr .scrollnext 
c2de			;.scrollup:	call scroll_up 
c2de			; 
c2de			;		 
c2de			;.scrollnext: 
c2de			;		pop de 
c2de			;		pop bc 
c2de			;		djnz .scrolldir 
c2de			; 
c2de			; 
c2de			; 
c2de			; 
c2de			; 
c2de			;		NEXTW 
c2de			 
c2de			.SCROLLD: 
c2de				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
c2de 53				db WORD_SYS_CORE+63             
c2df 0f c3			dw .ATQ            
c2e1 08				db 7 + 1 
c2e2 .. 00			db "SCROLLD",0              
c2ea				endm 
# End of macro CWHEAD
c2ea			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
c2ea					if DEBUG_FORTH_WORDS_KEY 
c2ea						DMARK "SCD" 
c2ea f5				push af  
c2eb 3a ff c2			ld a, (.dmark)  
c2ee 32 62 ee			ld (debug_mark),a  
c2f1 3a 00 c3			ld a, (.dmark+1)  
c2f4 32 63 ee			ld (debug_mark+1),a  
c2f7 3a 01 c3			ld a, (.dmark+2)  
c2fa 32 64 ee			ld (debug_mark+2),a  
c2fd 18 03			jr .pastdmark  
c2ff ..			.dmark: db "SCD"  
c302 f1			.pastdmark: pop af  
c303			endm  
# End of macro DMARK
c303						CALLMONITOR 
c303 cd 6f ee			call debug_vector  
c306				endm  
# End of macro CALLMONITOR
c306					endif 
c306			 
c306 cd a3 8a			call scroll_down 
c309			;	call update_display 
c309			 
c309					NEXTW 
c309 cd 6c ee			call parse_vector 
c30c c3 e5 9d			jp macro_next 
c30f				endm 
# End of macro NEXTW
c30f			 
c30f			 
c30f			.ATQ: 
c30f				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
c30f 62				db WORD_SYS_CORE+78             
c310 70 c3			dw .AUTODSP            
c312 04				db 3 + 1 
c313 .. 00			db "AT@",0              
c317				endm 
# End of macro CWHEAD
c317			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
c317					if DEBUG_FORTH_WORDS_KEY 
c317						DMARK "ATA" 
c317 f5				push af  
c318 3a 2c c3			ld a, (.dmark)  
c31b 32 62 ee			ld (debug_mark),a  
c31e 3a 2d c3			ld a, (.dmark+1)  
c321 32 63 ee			ld (debug_mark+1),a  
c324 3a 2e c3			ld a, (.dmark+2)  
c327 32 64 ee			ld (debug_mark+2),a  
c32a 18 03			jr .pastdmark  
c32c ..			.dmark: db "ATA"  
c32f f1			.pastdmark: pop af  
c330			endm  
# End of macro DMARK
c330						CALLMONITOR 
c330 cd 6f ee			call debug_vector  
c333				endm  
# End of macro CALLMONITOR
c333					endif 
c333			 
c333			 
c333					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c333 cd fa 9b			call macro_dsp_valuehl 
c336				endm 
# End of macro FORTH_DSP_VALUEHL
c336			 
c336					; TODO save cursor row 
c336 7d					ld a,l 
c337 fe 02				cp 2 
c339 20 04				jr nz, .crow3aq 
c33b 3e 28				ld a, display_row_2 
c33d 18 12				jr .ccol1aq 
c33f fe 03		.crow3aq:		cp 3 
c341 20 04				jr nz, .crow4aq 
c343 3e 50				ld a, display_row_3 
c345 18 0a				jr .ccol1aq 
c347 fe 04		.crow4aq:		cp 4 
c349 20 04				jr nz, .crow1aq 
c34b 3e 78				ld a, display_row_4 
c34d 18 02				jr .ccol1aq 
c34f 3e 00		.crow1aq:		ld a,display_row_1 
c351 f5			.ccol1aq:		push af			; got row offset 
c352 6f					ld l,a 
c353 26 00				ld h,0 
c355					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c355 cd b2 9c			call macro_forth_dsp_pop 
c358				endm 
# End of macro FORTH_DSP_POP
c358					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c358 cd fa 9b			call macro_dsp_valuehl 
c35b				endm 
# End of macro FORTH_DSP_VALUEHL
c35b					; TODO save cursor col 
c35b f1					pop af 
c35c 85					add l		; add col offset 
c35d			 
c35d					; add current frame buffer address 
c35d 2a c3 eb				ld hl, (display_fb_active) 
c360 cd ea 8c				call addatohl 
c363			 
c363			 
c363			 
c363			 
c363					; get char frame buffer location offset in hl 
c363			 
c363 7e					ld a,(hl) 
c364 26 00				ld h, 0 
c366 6f					ld l, a 
c367			 
c367 cd f5 99				call forth_push_numhl 
c36a			 
c36a			 
c36a					NEXTW 
c36a cd 6c ee			call parse_vector 
c36d c3 e5 9d			jp macro_next 
c370				endm 
# End of macro NEXTW
c370			 
c370			.AUTODSP: 
c370				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c370 63				db WORD_SYS_CORE+79             
c371 89 c3			dw .MENU            
c373 05				db 4 + 1 
c374 .. 00			db "ADSP",0              
c379				endm 
# End of macro CWHEAD
c379			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c379			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c379			 
c379					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c379 cd fa 9b			call macro_dsp_valuehl 
c37c				endm 
# End of macro FORTH_DSP_VALUEHL
c37c			 
c37c			;		push hl 
c37c			 
c37c					; destroy value TOS 
c37c			 
c37c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c37c cd b2 9c			call macro_forth_dsp_pop 
c37f				endm 
# End of macro FORTH_DSP_POP
c37f			 
c37f			;		pop hl 
c37f			 
c37f 7d					ld a,l 
c380 32 33 ea				ld (cli_autodisplay), a 
c383				       NEXTW 
c383 cd 6c ee			call parse_vector 
c386 c3 e5 9d			jp macro_next 
c389				endm 
# End of macro NEXTW
c389			 
c389			.MENU: 
c389				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c389 70				db WORD_SYS_CORE+92             
c38a 35 c4			dw .ENDDISPLAY            
c38c 05				db 4 + 1 
c38d .. 00			db "MENU",0              
c392				endm 
# End of macro CWHEAD
c392			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
c392			 
c392			;		; get number of items on the stack 
c392			; 
c392				 
c392					FORTH_DSP_VALUEHL 
c392 cd fa 9b			call macro_dsp_valuehl 
c395				endm 
# End of macro FORTH_DSP_VALUEHL
c395				 
c395					if DEBUG_FORTH_WORDS_KEY 
c395						DMARK "MNU" 
c395 f5				push af  
c396 3a aa c3			ld a, (.dmark)  
c399 32 62 ee			ld (debug_mark),a  
c39c 3a ab c3			ld a, (.dmark+1)  
c39f 32 63 ee			ld (debug_mark+1),a  
c3a2 3a ac c3			ld a, (.dmark+2)  
c3a5 32 64 ee			ld (debug_mark+2),a  
c3a8 18 03			jr .pastdmark  
c3aa ..			.dmark: db "MNU"  
c3ad f1			.pastdmark: pop af  
c3ae			endm  
# End of macro DMARK
c3ae						CALLMONITOR 
c3ae cd 6f ee			call debug_vector  
c3b1				endm  
# End of macro CALLMONITOR
c3b1					endif 
c3b1			 
c3b1 45					ld b, l	 
c3b2 05					dec b 
c3b3			 
c3b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3b3 cd b2 9c			call macro_forth_dsp_pop 
c3b6				endm 
# End of macro FORTH_DSP_POP
c3b6			 
c3b6			 
c3b6					; go directly through the stack to pluck out the string pointers and build an array 
c3b6			 
c3b6			;		FORTH_DSP 
c3b6			 
c3b6					; hl contains top most stack item 
c3b6				 
c3b6 11 b8 e2				ld de, scratch 
c3b9			 
c3b9			.mbuild: 
c3b9			 
c3b9					FORTH_DSP_VALUEHL 
c3b9 cd fa 9b			call macro_dsp_valuehl 
c3bc				endm 
# End of macro FORTH_DSP_VALUEHL
c3bc			 
c3bc					if DEBUG_FORTH_WORDS 
c3bc						DMARK "MN3" 
c3bc f5				push af  
c3bd 3a d1 c3			ld a, (.dmark)  
c3c0 32 62 ee			ld (debug_mark),a  
c3c3 3a d2 c3			ld a, (.dmark+1)  
c3c6 32 63 ee			ld (debug_mark+1),a  
c3c9 3a d3 c3			ld a, (.dmark+2)  
c3cc 32 64 ee			ld (debug_mark+2),a  
c3cf 18 03			jr .pastdmark  
c3d1 ..			.dmark: db "MN3"  
c3d4 f1			.pastdmark: pop af  
c3d5			endm  
# End of macro DMARK
c3d5						CALLMONITOR 
c3d5 cd 6f ee			call debug_vector  
c3d8				endm  
# End of macro CALLMONITOR
c3d8					endif 
c3d8 eb					ex de, hl 
c3d9 73					ld (hl), e 
c3da 23					inc hl 
c3db 72					ld (hl), d 
c3dc 23					inc hl 
c3dd eb					ex de, hl 
c3de			 
c3de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3de cd b2 9c			call macro_forth_dsp_pop 
c3e1				endm 
# End of macro FORTH_DSP_POP
c3e1			 
c3e1 10 d6				djnz .mbuild 
c3e3			 
c3e3					; done add term 
c3e3			 
c3e3 eb					ex de, hl 
c3e4 36 00				ld (hl), 0 
c3e6 23					inc hl 
c3e7 36 00				ld (hl), 0 
c3e9			 
c3e9				 
c3e9					 
c3e9 21 b8 e2				ld hl, scratch 
c3ec			 
c3ec					if DEBUG_FORTH_WORDS 
c3ec						DMARK "MNx" 
c3ec f5				push af  
c3ed 3a 01 c4			ld a, (.dmark)  
c3f0 32 62 ee			ld (debug_mark),a  
c3f3 3a 02 c4			ld a, (.dmark+1)  
c3f6 32 63 ee			ld (debug_mark+1),a  
c3f9 3a 03 c4			ld a, (.dmark+2)  
c3fc 32 64 ee			ld (debug_mark+2),a  
c3ff 18 03			jr .pastdmark  
c401 ..			.dmark: db "MNx"  
c404 f1			.pastdmark: pop af  
c405			endm  
# End of macro DMARK
c405						CALLMONITOR 
c405 cd 6f ee			call debug_vector  
c408				endm  
# End of macro CALLMONITOR
c408					endif 
c408			 
c408			 
c408			 
c408 3e 00				ld a, 0 
c40a cd ee 8a				call menu 
c40d			 
c40d			 
c40d 6f					ld l, a 
c40e 26 00				ld h, 0 
c410			 
c410					if DEBUG_FORTH_WORDS 
c410						DMARK "MNr" 
c410 f5				push af  
c411 3a 25 c4			ld a, (.dmark)  
c414 32 62 ee			ld (debug_mark),a  
c417 3a 26 c4			ld a, (.dmark+1)  
c41a 32 63 ee			ld (debug_mark+1),a  
c41d 3a 27 c4			ld a, (.dmark+2)  
c420 32 64 ee			ld (debug_mark+2),a  
c423 18 03			jr .pastdmark  
c425 ..			.dmark: db "MNr"  
c428 f1			.pastdmark: pop af  
c429			endm  
# End of macro DMARK
c429						CALLMONITOR 
c429 cd 6f ee			call debug_vector  
c42c				endm  
# End of macro CALLMONITOR
c42c					endif 
c42c			 
c42c cd f5 99				call forth_push_numhl 
c42f			 
c42f			 
c42f			 
c42f			 
c42f				       NEXTW 
c42f cd 6c ee			call parse_vector 
c432 c3 e5 9d			jp macro_next 
c435				endm 
# End of macro NEXTW
c435			 
c435			 
c435			.ENDDISPLAY: 
c435			 
c435			; eof 
# End of file forth_words_display.asm
c435			include "forth_words_str.asm" 
c435			 
c435			; | ## String Words 
c435			 
c435			.SPLIT:   
c435			 
c435				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
c435 48				db WORD_SYS_CORE+52             
c436 2d c5			dw .PTR            
c438 06				db 5 + 1 
c439 .. 00			db "SPLIT",0              
c43f				endm 
# End of macro CWHEAD
c43f			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
c43f					if DEBUG_FORTH_WORDS_KEY 
c43f						DMARK "SPT" 
c43f f5				push af  
c440 3a 54 c4			ld a, (.dmark)  
c443 32 62 ee			ld (debug_mark),a  
c446 3a 55 c4			ld a, (.dmark+1)  
c449 32 63 ee			ld (debug_mark+1),a  
c44c 3a 56 c4			ld a, (.dmark+2)  
c44f 32 64 ee			ld (debug_mark+2),a  
c452 18 03			jr .pastdmark  
c454 ..			.dmark: db "SPT"  
c457 f1			.pastdmark: pop af  
c458			endm  
# End of macro DMARK
c458						CALLMONITOR 
c458 cd 6f ee			call debug_vector  
c45b				endm  
# End of macro CALLMONITOR
c45b					endif 
c45b			 
c45b					; get delim 
c45b					FORTH_DSP_VALUEHL 
c45b cd fa 9b			call macro_dsp_valuehl 
c45e				endm 
# End of macro FORTH_DSP_VALUEHL
c45e			 
c45e					FORTH_DSP_POP 
c45e cd b2 9c			call macro_forth_dsp_pop 
c461				endm 
# End of macro FORTH_DSP_POP
c461					 
c461			 
c461 45					ld b, l    ; move delim to b 
c462 0e 01				ld c, 1   ; count of poritions 
c464			 
c464 c5					push bc 
c465			 
c465					if DEBUG_FORTH_WORDS 
c465						DMARK "SPa" 
c465 f5				push af  
c466 3a 7a c4			ld a, (.dmark)  
c469 32 62 ee			ld (debug_mark),a  
c46c 3a 7b c4			ld a, (.dmark+1)  
c46f 32 63 ee			ld (debug_mark+1),a  
c472 3a 7c c4			ld a, (.dmark+2)  
c475 32 64 ee			ld (debug_mark+2),a  
c478 18 03			jr .pastdmark  
c47a ..			.dmark: db "SPa"  
c47d f1			.pastdmark: pop af  
c47e			endm  
# End of macro DMARK
c47e						CALLMONITOR 
c47e cd 6f ee			call debug_vector  
c481				endm  
# End of macro CALLMONITOR
c481					endif 
c481					; get pointer to string to chop up 
c481					FORTH_DSP_VALUEHL 
c481 cd fa 9b			call macro_dsp_valuehl 
c484				endm 
# End of macro FORTH_DSP_VALUEHL
c484			 
c484			;		push hl 
c484 11 b8 e2				ld de, scratch 
c487			.spllop: 
c487 c1					pop bc 
c488 c5					push bc 
c489			;		pop hl 
c489					if DEBUG_FORTH_WORDS 
c489						DMARK "SPl" 
c489 f5				push af  
c48a 3a 9e c4			ld a, (.dmark)  
c48d 32 62 ee			ld (debug_mark),a  
c490 3a 9f c4			ld a, (.dmark+1)  
c493 32 63 ee			ld (debug_mark+1),a  
c496 3a a0 c4			ld a, (.dmark+2)  
c499 32 64 ee			ld (debug_mark+2),a  
c49c 18 03			jr .pastdmark  
c49e ..			.dmark: db "SPl"  
c4a1 f1			.pastdmark: pop af  
c4a2			endm  
# End of macro DMARK
c4a2						CALLMONITOR 
c4a2 cd 6f ee			call debug_vector  
c4a5				endm  
# End of macro CALLMONITOR
c4a5					endif 
c4a5 7e					ld a, (hl) 
c4a6 b8					cp b 
c4a7 28 08				jr z, .splnxt 
c4a9 fe 00				cp 0 
c4ab 28 34				jr z, .splend 
c4ad ed a0				ldi 
c4af 18 d6				jr .spllop 
c4b1			 
c4b1					; hit dlim 
c4b1			 
c4b1			.splnxt: 
c4b1					if DEBUG_FORTH_WORDS 
c4b1						DMARK "SPx" 
c4b1 f5				push af  
c4b2 3a c6 c4			ld a, (.dmark)  
c4b5 32 62 ee			ld (debug_mark),a  
c4b8 3a c7 c4			ld a, (.dmark+1)  
c4bb 32 63 ee			ld (debug_mark+1),a  
c4be 3a c8 c4			ld a, (.dmark+2)  
c4c1 32 64 ee			ld (debug_mark+2),a  
c4c4 18 03			jr .pastdmark  
c4c6 ..			.dmark: db "SPx"  
c4c9 f1			.pastdmark: pop af  
c4ca			endm  
# End of macro DMARK
c4ca						CALLMONITOR 
c4ca cd 6f ee			call debug_vector  
c4cd				endm  
# End of macro CALLMONITOR
c4cd					endif 
c4cd 3e 00				ld a, 0 
c4cf 12					ld (de), a 
c4d0					;ex de, hl 
c4d0 e5					push hl 
c4d1 21 b8 e2				ld hl, scratch 
c4d4 cd 63 9a				call forth_push_str 
c4d7 e1					pop hl 
c4d8					;ex de, hl 
c4d8 23					inc hl 
c4d9 c1					pop bc 
c4da 0c					inc c 
c4db c5					push bc 
c4dc 11 b8 e2				ld de, scratch 
c4df 18 a6				jr .spllop 
c4e1			 
c4e1			.splend:		 
c4e1					if DEBUG_FORTH_WORDS 
c4e1						DMARK "SPe" 
c4e1 f5				push af  
c4e2 3a f6 c4			ld a, (.dmark)  
c4e5 32 62 ee			ld (debug_mark),a  
c4e8 3a f7 c4			ld a, (.dmark+1)  
c4eb 32 63 ee			ld (debug_mark+1),a  
c4ee 3a f8 c4			ld a, (.dmark+2)  
c4f1 32 64 ee			ld (debug_mark+2),a  
c4f4 18 03			jr .pastdmark  
c4f6 ..			.dmark: db "SPe"  
c4f9 f1			.pastdmark: pop af  
c4fa			endm  
# End of macro DMARK
c4fa						CALLMONITOR 
c4fa cd 6f ee			call debug_vector  
c4fd				endm  
# End of macro CALLMONITOR
c4fd					endif 
c4fd 12					ld (de), a 
c4fe eb					ex de, hl 
c4ff			;		push hl 
c4ff 21 b8 e2				ld hl, scratch 
c502 cd 63 9a				call forth_push_str 
c505					 
c505					if DEBUG_FORTH_WORDS 
c505						DMARK "SPc" 
c505 f5				push af  
c506 3a 1a c5			ld a, (.dmark)  
c509 32 62 ee			ld (debug_mark),a  
c50c 3a 1b c5			ld a, (.dmark+1)  
c50f 32 63 ee			ld (debug_mark+1),a  
c512 3a 1c c5			ld a, (.dmark+2)  
c515 32 64 ee			ld (debug_mark+2),a  
c518 18 03			jr .pastdmark  
c51a ..			.dmark: db "SPc"  
c51d f1			.pastdmark: pop af  
c51e			endm  
# End of macro DMARK
c51e						CALLMONITOR 
c51e cd 6f ee			call debug_vector  
c521				endm  
# End of macro CALLMONITOR
c521					endif 
c521			 
c521 e1					pop hl    ; get counter from bc which has been push 
c522 26 00				ld h, 0 
c524			;		ld l, c 
c524 cd f5 99				call forth_push_numhl 
c527			 
c527			 
c527				NEXTW 
c527 cd 6c ee			call parse_vector 
c52a c3 e5 9d			jp macro_next 
c52d				endm 
# End of macro NEXTW
c52d			.PTR:   
c52d			 
c52d				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c52d 48				db WORD_SYS_CORE+52             
c52e 5d c5			dw .STYPE            
c530 04				db 3 + 1 
c531 .. 00			db "PTR",0              
c535				endm 
# End of macro CWHEAD
c535			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c535			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c535			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c535			 
c535					if DEBUG_FORTH_WORDS_KEY 
c535						DMARK "PTR" 
c535 f5				push af  
c536 3a 4a c5			ld a, (.dmark)  
c539 32 62 ee			ld (debug_mark),a  
c53c 3a 4b c5			ld a, (.dmark+1)  
c53f 32 63 ee			ld (debug_mark+1),a  
c542 3a 4c c5			ld a, (.dmark+2)  
c545 32 64 ee			ld (debug_mark+2),a  
c548 18 03			jr .pastdmark  
c54a ..			.dmark: db "PTR"  
c54d f1			.pastdmark: pop af  
c54e			endm  
# End of macro DMARK
c54e						CALLMONITOR 
c54e cd 6f ee			call debug_vector  
c551				endm  
# End of macro CALLMONITOR
c551					endif 
c551					FORTH_DSP_VALUEHL 
c551 cd fa 9b			call macro_dsp_valuehl 
c554				endm 
# End of macro FORTH_DSP_VALUEHL
c554 cd f5 99				call forth_push_numhl 
c557			 
c557			 
c557					NEXTW 
c557 cd 6c ee			call parse_vector 
c55a c3 e5 9d			jp macro_next 
c55d				endm 
# End of macro NEXTW
c55d			.STYPE: 
c55d				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c55d 48				db WORD_SYS_CORE+52             
c55e af c5			dw .UPPER            
c560 06				db 5 + 1 
c561 .. 00			db "STYPE",0              
c567				endm 
# End of macro CWHEAD
c567			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
c567			; | | 's' string or 'i' integer 
c567					if DEBUG_FORTH_WORDS_KEY 
c567						DMARK "STY" 
c567 f5				push af  
c568 3a 7c c5			ld a, (.dmark)  
c56b 32 62 ee			ld (debug_mark),a  
c56e 3a 7d c5			ld a, (.dmark+1)  
c571 32 63 ee			ld (debug_mark+1),a  
c574 3a 7e c5			ld a, (.dmark+2)  
c577 32 64 ee			ld (debug_mark+2),a  
c57a 18 03			jr .pastdmark  
c57c ..			.dmark: db "STY"  
c57f f1			.pastdmark: pop af  
c580			endm  
# End of macro DMARK
c580						CALLMONITOR 
c580 cd 6f ee			call debug_vector  
c583				endm  
# End of macro CALLMONITOR
c583					endif 
c583					FORTH_DSP 
c583 cd c0 9b			call macro_forth_dsp 
c586				endm 
# End of macro FORTH_DSP
c586					;v5 FORTH_DSP_VALUE 
c586			 
c586 7e					ld a, (hl) 
c587			 
c587 f5					push af 
c588			 
c588			; Dont destroy TOS		FORTH_DSP_POP 
c588			 
c588 f1					pop af 
c589			 
c589 fe 01				cp DS_TYPE_STR 
c58b 28 09				jr z, .typestr 
c58d			 
c58d fe 02				cp DS_TYPE_INUM 
c58f 28 0a				jr z, .typeinum 
c591			 
c591 21 ad c5				ld hl, .tna 
c594 18 0a				jr .tpush 
c596			 
c596 21 a9 c5		.typestr:	ld hl, .tstr 
c599 18 05				jr .tpush 
c59b 21 ab c5		.typeinum:	ld hl, .tinum 
c59e 18 00				jr .tpush 
c5a0			 
c5a0			.tpush: 
c5a0			 
c5a0 cd 63 9a				call forth_push_str 
c5a3			 
c5a3					NEXTW 
c5a3 cd 6c ee			call parse_vector 
c5a6 c3 e5 9d			jp macro_next 
c5a9				endm 
# End of macro NEXTW
c5a9 .. 00		.tstr:	db "s",0 
c5ab .. 00		.tinum:  db "i",0 
c5ad .. 00		.tna:   db "?", 0 
c5af			 
c5af			 
c5af			.UPPER: 
c5af				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c5af 48				db WORD_SYS_CORE+52             
c5b0 ed c5			dw .LOWER            
c5b2 06				db 5 + 1 
c5b3 .. 00			db "UPPER",0              
c5b9				endm 
# End of macro CWHEAD
c5b9			; | UPPER ( s -- s ) Upper case string s  | DONE 
c5b9					if DEBUG_FORTH_WORDS_KEY 
c5b9						DMARK "UPR" 
c5b9 f5				push af  
c5ba 3a ce c5			ld a, (.dmark)  
c5bd 32 62 ee			ld (debug_mark),a  
c5c0 3a cf c5			ld a, (.dmark+1)  
c5c3 32 63 ee			ld (debug_mark+1),a  
c5c6 3a d0 c5			ld a, (.dmark+2)  
c5c9 32 64 ee			ld (debug_mark+2),a  
c5cc 18 03			jr .pastdmark  
c5ce ..			.dmark: db "UPR"  
c5d1 f1			.pastdmark: pop af  
c5d2			endm  
# End of macro DMARK
c5d2						CALLMONITOR 
c5d2 cd 6f ee			call debug_vector  
c5d5				endm  
# End of macro CALLMONITOR
c5d5					endif 
c5d5			 
c5d5					FORTH_DSP 
c5d5 cd c0 9b			call macro_forth_dsp 
c5d8				endm 
# End of macro FORTH_DSP
c5d8					 
c5d8			; TODO check is string type 
c5d8			 
c5d8					FORTH_DSP_VALUEHL 
c5d8 cd fa 9b			call macro_dsp_valuehl 
c5db				endm 
# End of macro FORTH_DSP_VALUEHL
c5db			; get pointer to string in hl 
c5db			 
c5db 7e			.toup:		ld a, (hl) 
c5dc fe 00				cp 0 
c5de 28 07				jr z, .toupdone 
c5e0			 
c5e0 cd 5f 8f				call to_upper 
c5e3			 
c5e3 77					ld (hl), a 
c5e4 23					inc hl 
c5e5 18 f4				jr .toup 
c5e7			 
c5e7					 
c5e7			 
c5e7			 
c5e7			; for each char convert to upper 
c5e7					 
c5e7			.toupdone: 
c5e7			 
c5e7			 
c5e7					NEXTW 
c5e7 cd 6c ee			call parse_vector 
c5ea c3 e5 9d			jp macro_next 
c5ed				endm 
# End of macro NEXTW
c5ed			.LOWER: 
c5ed				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c5ed 48				db WORD_SYS_CORE+52             
c5ee 2b c6			dw .TCASE            
c5f0 06				db 5 + 1 
c5f1 .. 00			db "LOWER",0              
c5f7				endm 
# End of macro CWHEAD
c5f7			; | LOWER ( s -- s ) Lower case string s  | DONE 
c5f7					if DEBUG_FORTH_WORDS_KEY 
c5f7						DMARK "LWR" 
c5f7 f5				push af  
c5f8 3a 0c c6			ld a, (.dmark)  
c5fb 32 62 ee			ld (debug_mark),a  
c5fe 3a 0d c6			ld a, (.dmark+1)  
c601 32 63 ee			ld (debug_mark+1),a  
c604 3a 0e c6			ld a, (.dmark+2)  
c607 32 64 ee			ld (debug_mark+2),a  
c60a 18 03			jr .pastdmark  
c60c ..			.dmark: db "LWR"  
c60f f1			.pastdmark: pop af  
c610			endm  
# End of macro DMARK
c610						CALLMONITOR 
c610 cd 6f ee			call debug_vector  
c613				endm  
# End of macro CALLMONITOR
c613					endif 
c613			 
c613					FORTH_DSP 
c613 cd c0 9b			call macro_forth_dsp 
c616				endm 
# End of macro FORTH_DSP
c616					 
c616			; TODO check is string type 
c616			 
c616					FORTH_DSP_VALUEHL 
c616 cd fa 9b			call macro_dsp_valuehl 
c619				endm 
# End of macro FORTH_DSP_VALUEHL
c619			; get pointer to string in hl 
c619			 
c619 7e			.tolow:		ld a, (hl) 
c61a fe 00				cp 0 
c61c 28 07				jr z, .tolowdone 
c61e			 
c61e cd 68 8f				call to_lower 
c621			 
c621 77					ld (hl), a 
c622 23					inc hl 
c623 18 f4				jr .tolow 
c625			 
c625					 
c625			 
c625			 
c625			; for each char convert to low 
c625					 
c625			.tolowdone: 
c625					NEXTW 
c625 cd 6c ee			call parse_vector 
c628 c3 e5 9d			jp macro_next 
c62b				endm 
# End of macro NEXTW
c62b			.TCASE: 
c62b				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c62b 48				db WORD_SYS_CORE+52             
c62c 64 c7			dw .SUBSTR            
c62e 06				db 5 + 1 
c62f .. 00			db "TCASE",0              
c635				endm 
# End of macro CWHEAD
c635			; | TCASE ( s -- s ) Title case string s  | DONE 
c635					if DEBUG_FORTH_WORDS_KEY 
c635						DMARK "TCS" 
c635 f5				push af  
c636 3a 4a c6			ld a, (.dmark)  
c639 32 62 ee			ld (debug_mark),a  
c63c 3a 4b c6			ld a, (.dmark+1)  
c63f 32 63 ee			ld (debug_mark+1),a  
c642 3a 4c c6			ld a, (.dmark+2)  
c645 32 64 ee			ld (debug_mark+2),a  
c648 18 03			jr .pastdmark  
c64a ..			.dmark: db "TCS"  
c64d f1			.pastdmark: pop af  
c64e			endm  
# End of macro DMARK
c64e						CALLMONITOR 
c64e cd 6f ee			call debug_vector  
c651				endm  
# End of macro CALLMONITOR
c651					endif 
c651			 
c651					FORTH_DSP 
c651 cd c0 9b			call macro_forth_dsp 
c654				endm 
# End of macro FORTH_DSP
c654					 
c654			; TODO check is string type 
c654			 
c654					FORTH_DSP_VALUEHL 
c654 cd fa 9b			call macro_dsp_valuehl 
c657				endm 
# End of macro FORTH_DSP_VALUEHL
c657			; get pointer to string in hl 
c657			 
c657					if DEBUG_FORTH_WORDS 
c657						DMARK "TC1" 
c657 f5				push af  
c658 3a 6c c6			ld a, (.dmark)  
c65b 32 62 ee			ld (debug_mark),a  
c65e 3a 6d c6			ld a, (.dmark+1)  
c661 32 63 ee			ld (debug_mark+1),a  
c664 3a 6e c6			ld a, (.dmark+2)  
c667 32 64 ee			ld (debug_mark+2),a  
c66a 18 03			jr .pastdmark  
c66c ..			.dmark: db "TC1"  
c66f f1			.pastdmark: pop af  
c670			endm  
# End of macro DMARK
c670						CALLMONITOR 
c670 cd 6f ee			call debug_vector  
c673				endm  
# End of macro CALLMONITOR
c673					endif 
c673			 
c673					; first time in turn to upper case first char 
c673			 
c673 7e					ld a, (hl) 
c674 c3 fe c6				jp .totsiptou 
c677			 
c677			 
c677 7e			.tot:		ld a, (hl) 
c678 fe 00				cp 0 
c67a ca 42 c7				jp z, .totdone 
c67d			 
c67d					if DEBUG_FORTH_WORDS 
c67d						DMARK "TC2" 
c67d f5				push af  
c67e 3a 92 c6			ld a, (.dmark)  
c681 32 62 ee			ld (debug_mark),a  
c684 3a 93 c6			ld a, (.dmark+1)  
c687 32 63 ee			ld (debug_mark+1),a  
c68a 3a 94 c6			ld a, (.dmark+2)  
c68d 32 64 ee			ld (debug_mark+2),a  
c690 18 03			jr .pastdmark  
c692 ..			.dmark: db "TC2"  
c695 f1			.pastdmark: pop af  
c696			endm  
# End of macro DMARK
c696						CALLMONITOR 
c696 cd 6f ee			call debug_vector  
c699				endm  
# End of macro CALLMONITOR
c699					endif 
c699					; check to see if current char is a space 
c699			 
c699 fe 20				cp ' ' 
c69b 28 21				jr z, .totsp 
c69d cd 68 8f				call to_lower 
c6a0					if DEBUG_FORTH_WORDS 
c6a0						DMARK "TC3" 
c6a0 f5				push af  
c6a1 3a b5 c6			ld a, (.dmark)  
c6a4 32 62 ee			ld (debug_mark),a  
c6a7 3a b6 c6			ld a, (.dmark+1)  
c6aa 32 63 ee			ld (debug_mark+1),a  
c6ad 3a b7 c6			ld a, (.dmark+2)  
c6b0 32 64 ee			ld (debug_mark+2),a  
c6b3 18 03			jr .pastdmark  
c6b5 ..			.dmark: db "TC3"  
c6b8 f1			.pastdmark: pop af  
c6b9			endm  
# End of macro DMARK
c6b9						CALLMONITOR 
c6b9 cd 6f ee			call debug_vector  
c6bc				endm  
# End of macro CALLMONITOR
c6bc					endif 
c6bc 18 63				jr .totnxt 
c6be			 
c6be			.totsp:         ; on a space, find next char which should be upper 
c6be			 
c6be					if DEBUG_FORTH_WORDS 
c6be						DMARK "TC4" 
c6be f5				push af  
c6bf 3a d3 c6			ld a, (.dmark)  
c6c2 32 62 ee			ld (debug_mark),a  
c6c5 3a d4 c6			ld a, (.dmark+1)  
c6c8 32 63 ee			ld (debug_mark+1),a  
c6cb 3a d5 c6			ld a, (.dmark+2)  
c6ce 32 64 ee			ld (debug_mark+2),a  
c6d1 18 03			jr .pastdmark  
c6d3 ..			.dmark: db "TC4"  
c6d6 f1			.pastdmark: pop af  
c6d7			endm  
# End of macro DMARK
c6d7						CALLMONITOR 
c6d7 cd 6f ee			call debug_vector  
c6da				endm  
# End of macro CALLMONITOR
c6da					endif 
c6da					;; 
c6da			 
c6da fe 20				cp ' ' 
c6dc 20 20				jr nz, .totsiptou 
c6de 23					inc hl 
c6df 7e					ld a, (hl) 
c6e0					if DEBUG_FORTH_WORDS 
c6e0						DMARK "TC5" 
c6e0 f5				push af  
c6e1 3a f5 c6			ld a, (.dmark)  
c6e4 32 62 ee			ld (debug_mark),a  
c6e7 3a f6 c6			ld a, (.dmark+1)  
c6ea 32 63 ee			ld (debug_mark+1),a  
c6ed 3a f7 c6			ld a, (.dmark+2)  
c6f0 32 64 ee			ld (debug_mark+2),a  
c6f3 18 03			jr .pastdmark  
c6f5 ..			.dmark: db "TC5"  
c6f8 f1			.pastdmark: pop af  
c6f9			endm  
# End of macro DMARK
c6f9						CALLMONITOR 
c6f9 cd 6f ee			call debug_vector  
c6fc				endm  
# End of macro CALLMONITOR
c6fc					endif 
c6fc 18 c0				jr .totsp 
c6fe fe 00		.totsiptou:    cp 0 
c700 28 40				jr z, .totdone 
c702					; not space and not zero term so upper case it 
c702 cd 5f 8f				call to_upper 
c705			 
c705					if DEBUG_FORTH_WORDS 
c705						DMARK "TC6" 
c705 f5				push af  
c706 3a 1a c7			ld a, (.dmark)  
c709 32 62 ee			ld (debug_mark),a  
c70c 3a 1b c7			ld a, (.dmark+1)  
c70f 32 63 ee			ld (debug_mark+1),a  
c712 3a 1c c7			ld a, (.dmark+2)  
c715 32 64 ee			ld (debug_mark+2),a  
c718 18 03			jr .pastdmark  
c71a ..			.dmark: db "TC6"  
c71d f1			.pastdmark: pop af  
c71e			endm  
# End of macro DMARK
c71e						CALLMONITOR 
c71e cd 6f ee			call debug_vector  
c721				endm  
# End of macro CALLMONITOR
c721					endif 
c721			 
c721			 
c721			.totnxt: 
c721			 
c721 77					ld (hl), a 
c722 23					inc hl 
c723					if DEBUG_FORTH_WORDS 
c723						DMARK "TC7" 
c723 f5				push af  
c724 3a 38 c7			ld a, (.dmark)  
c727 32 62 ee			ld (debug_mark),a  
c72a 3a 39 c7			ld a, (.dmark+1)  
c72d 32 63 ee			ld (debug_mark+1),a  
c730 3a 3a c7			ld a, (.dmark+2)  
c733 32 64 ee			ld (debug_mark+2),a  
c736 18 03			jr .pastdmark  
c738 ..			.dmark: db "TC7"  
c73b f1			.pastdmark: pop af  
c73c			endm  
# End of macro DMARK
c73c						CALLMONITOR 
c73c cd 6f ee			call debug_vector  
c73f				endm  
# End of macro CALLMONITOR
c73f					endif 
c73f c3 77 c6				jp .tot 
c742			 
c742					 
c742			 
c742			 
c742			; for each char convert to low 
c742					 
c742			.totdone: 
c742					if DEBUG_FORTH_WORDS 
c742						DMARK "TCd" 
c742 f5				push af  
c743 3a 57 c7			ld a, (.dmark)  
c746 32 62 ee			ld (debug_mark),a  
c749 3a 58 c7			ld a, (.dmark+1)  
c74c 32 63 ee			ld (debug_mark+1),a  
c74f 3a 59 c7			ld a, (.dmark+2)  
c752 32 64 ee			ld (debug_mark+2),a  
c755 18 03			jr .pastdmark  
c757 ..			.dmark: db "TCd"  
c75a f1			.pastdmark: pop af  
c75b			endm  
# End of macro DMARK
c75b						CALLMONITOR 
c75b cd 6f ee			call debug_vector  
c75e				endm  
# End of macro CALLMONITOR
c75e					endif 
c75e					NEXTW 
c75e cd 6c ee			call parse_vector 
c761 c3 e5 9d			jp macro_next 
c764				endm 
# End of macro NEXTW
c764			 
c764			.SUBSTR: 
c764				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c764 48				db WORD_SYS_CORE+52             
c765 c5 c7			dw .LEFT            
c767 07				db 6 + 1 
c768 .. 00			db "SUBSTR",0              
c76f				endm 
# End of macro CWHEAD
c76f			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c76f			 
c76f					if DEBUG_FORTH_WORDS_KEY 
c76f						DMARK "SST" 
c76f f5				push af  
c770 3a 84 c7			ld a, (.dmark)  
c773 32 62 ee			ld (debug_mark),a  
c776 3a 85 c7			ld a, (.dmark+1)  
c779 32 63 ee			ld (debug_mark+1),a  
c77c 3a 86 c7			ld a, (.dmark+2)  
c77f 32 64 ee			ld (debug_mark+2),a  
c782 18 03			jr .pastdmark  
c784 ..			.dmark: db "SST"  
c787 f1			.pastdmark: pop af  
c788			endm  
# End of macro DMARK
c788						CALLMONITOR 
c788 cd 6f ee			call debug_vector  
c78b				endm  
# End of macro CALLMONITOR
c78b					endif 
c78b			; TODO check string type 
c78b					FORTH_DSP_VALUEHL 
c78b cd fa 9b			call macro_dsp_valuehl 
c78e				endm 
# End of macro FORTH_DSP_VALUEHL
c78e			 
c78e e5					push hl      ; string length 
c78f			 
c78f					FORTH_DSP_POP 
c78f cd b2 9c			call macro_forth_dsp_pop 
c792				endm 
# End of macro FORTH_DSP_POP
c792			 
c792					FORTH_DSP_VALUEHL 
c792 cd fa 9b			call macro_dsp_valuehl 
c795				endm 
# End of macro FORTH_DSP_VALUEHL
c795			 
c795 e5					push hl     ; start char 
c796			 
c796					FORTH_DSP_POP 
c796 cd b2 9c			call macro_forth_dsp_pop 
c799				endm 
# End of macro FORTH_DSP_POP
c799			 
c799			 
c799					FORTH_DSP_VALUE 
c799 cd e3 9b			call macro_forth_dsp_value 
c79c				endm 
# End of macro FORTH_DSP_VALUE
c79c			 
c79c d1					pop de    ; get start post offset 
c79d			 
c79d 19					add hl, de    ; starting offset 
c79e			 
c79e c1					pop bc 
c79f c5					push bc      ; grab size of string 
c7a0			 
c7a0 e5					push hl    ; save string start  
c7a1			 
c7a1 26 00				ld h, 0 
c7a3 69					ld l, c 
c7a4 23					inc hl 
c7a5 23					inc hl 
c7a6			 
c7a6 cd c5 90				call malloc 
c7a9				if DEBUG_FORTH_MALLOC_GUARD 
c7a9 cc 9e d2				call z,malloc_error 
c7ac				endif 
c7ac			 
c7ac eb					ex de, hl      ; save malloc area for string copy 
c7ad e1					pop hl    ; get back source 
c7ae c1					pop bc    ; get length of string back 
c7af			 
c7af d5					push de    ; save malloc area for after we push 
c7b0 ed b0				ldir     ; copy substr 
c7b2			 
c7b2			 
c7b2 eb					ex de, hl 
c7b3 3e 00				ld a, 0 
c7b5 77					ld (hl), a   ; term substr 
c7b6			 
c7b6					 
c7b6 e1					pop hl    ; get malloc so we can push it 
c7b7 e5					push hl   ; save so we can free it afterwards 
c7b8			 
c7b8 cd 63 9a				call forth_push_str 
c7bb			 
c7bb e1					pop hl 
c7bc cd 8f 91				call free 
c7bf			 
c7bf					 
c7bf					 
c7bf			 
c7bf			 
c7bf					NEXTW 
c7bf cd 6c ee			call parse_vector 
c7c2 c3 e5 9d			jp macro_next 
c7c5				endm 
# End of macro NEXTW
c7c5			 
c7c5			.LEFT: 
c7c5				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c7c5 48				db WORD_SYS_CORE+52             
c7c6 09 c8			dw .RIGHT            
c7c8 05				db 4 + 1 
c7c9 .. 00			db "LEFT",0              
c7ce				endm 
# End of macro CWHEAD
c7ce			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
c7ce					if DEBUG_FORTH_WORDS_KEY 
c7ce						DMARK "LEF" 
c7ce f5				push af  
c7cf 3a e3 c7			ld a, (.dmark)  
c7d2 32 62 ee			ld (debug_mark),a  
c7d5 3a e4 c7			ld a, (.dmark+1)  
c7d8 32 63 ee			ld (debug_mark+1),a  
c7db 3a e5 c7			ld a, (.dmark+2)  
c7de 32 64 ee			ld (debug_mark+2),a  
c7e1 18 03			jr .pastdmark  
c7e3 ..			.dmark: db "LEF"  
c7e6 f1			.pastdmark: pop af  
c7e7			endm  
# End of macro DMARK
c7e7						CALLMONITOR 
c7e7 cd 6f ee			call debug_vector  
c7ea				endm  
# End of macro CALLMONITOR
c7ea					endif 
c7ea			 
c7ea					 
c7ea			; TODO check string type 
c7ea					FORTH_DSP_VALUEHL 
c7ea cd fa 9b			call macro_dsp_valuehl 
c7ed				endm 
# End of macro FORTH_DSP_VALUEHL
c7ed			 
c7ed e5					push hl      ; string length 
c7ee			 
c7ee					FORTH_DSP_POP 
c7ee cd b2 9c			call macro_forth_dsp_pop 
c7f1				endm 
# End of macro FORTH_DSP_POP
c7f1			 
c7f1					FORTH_DSP_VALUEHL 
c7f1 cd fa 9b			call macro_dsp_valuehl 
c7f4				endm 
# End of macro FORTH_DSP_VALUEHL
c7f4			 
c7f4 c1					pop bc 
c7f5			 
c7f5 11 b8 e2				ld de, scratch 
c7f8 ed b0				ldir 
c7fa 3e 00				ld a, 0 
c7fc 12					ld (de), a 
c7fd					 
c7fd 21 b8 e2				ld hl, scratch 
c800 cd 63 9a				call forth_push_str 
c803			 
c803					NEXTW 
c803 cd 6c ee			call parse_vector 
c806 c3 e5 9d			jp macro_next 
c809				endm 
# End of macro NEXTW
c809			.RIGHT: 
c809				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c809 48				db WORD_SYS_CORE+52             
c80a ca c8			dw .STR2NUM            
c80c 06				db 5 + 1 
c80d .. 00			db "RIGHT",0              
c813				endm 
# End of macro CWHEAD
c813			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
c813					if DEBUG_FORTH_WORDS_KEY 
c813						DMARK "RIG" 
c813 f5				push af  
c814 3a 28 c8			ld a, (.dmark)  
c817 32 62 ee			ld (debug_mark),a  
c81a 3a 29 c8			ld a, (.dmark+1)  
c81d 32 63 ee			ld (debug_mark+1),a  
c820 3a 2a c8			ld a, (.dmark+2)  
c823 32 64 ee			ld (debug_mark+2),a  
c826 18 03			jr .pastdmark  
c828 ..			.dmark: db "RIG"  
c82b f1			.pastdmark: pop af  
c82c			endm  
# End of macro DMARK
c82c						CALLMONITOR 
c82c cd 6f ee			call debug_vector  
c82f				endm  
# End of macro CALLMONITOR
c82f					endif 
c82f			 
c82f			; TODO check string type 
c82f					FORTH_DSP_VALUEHL 
c82f cd fa 9b			call macro_dsp_valuehl 
c832				endm 
# End of macro FORTH_DSP_VALUEHL
c832			 
c832 e5					push hl      ; string length 
c833			 
c833					FORTH_DSP_POP 
c833 cd b2 9c			call macro_forth_dsp_pop 
c836				endm 
# End of macro FORTH_DSP_POP
c836			 
c836					FORTH_DSP_VALUEHL 
c836 cd fa 9b			call macro_dsp_valuehl 
c839				endm 
# End of macro FORTH_DSP_VALUEHL
c839			 
c839					if DEBUG_FORTH_WORDS 
c839						DMARK "RI1" 
c839 f5				push af  
c83a 3a 4e c8			ld a, (.dmark)  
c83d 32 62 ee			ld (debug_mark),a  
c840 3a 4f c8			ld a, (.dmark+1)  
c843 32 63 ee			ld (debug_mark+1),a  
c846 3a 50 c8			ld a, (.dmark+2)  
c849 32 64 ee			ld (debug_mark+2),a  
c84c 18 03			jr .pastdmark  
c84e ..			.dmark: db "RI1"  
c851 f1			.pastdmark: pop af  
c852			endm  
# End of macro DMARK
c852						CALLMONITOR 
c852 cd 6f ee			call debug_vector  
c855				endm  
# End of macro CALLMONITOR
c855					endif 
c855					; from the pointer to string get to the end of string 
c855			 
c855 01 ff 00				ld bc, 255 
c858 3e 00				ld a, 0 
c85a ed b1				cpir 
c85c 2b					dec hl 
c85d			 
c85d					;  
c85d			 
c85d					if DEBUG_FORTH_WORDS 
c85d						DMARK "RI2" 
c85d f5				push af  
c85e 3a 72 c8			ld a, (.dmark)  
c861 32 62 ee			ld (debug_mark),a  
c864 3a 73 c8			ld a, (.dmark+1)  
c867 32 63 ee			ld (debug_mark+1),a  
c86a 3a 74 c8			ld a, (.dmark+2)  
c86d 32 64 ee			ld (debug_mark+2),a  
c870 18 03			jr .pastdmark  
c872 ..			.dmark: db "RI2"  
c875 f1			.pastdmark: pop af  
c876			endm  
# End of macro DMARK
c876						CALLMONITOR 
c876 cd 6f ee			call debug_vector  
c879				endm  
# End of macro CALLMONITOR
c879					endif 
c879			 
c879 c1					pop bc    ;  length of string to copy 
c87a			 
c87a 79					ld a, c 
c87b eb					ex de, hl 
c87c 21 b8 e2				ld hl, scratch  
c87f cd ea 8c				call addatohl 
c882			 
c882 eb					ex de, hl 
c883			 
c883					if DEBUG_FORTH_WORDS 
c883						DMARK "RI3" 
c883 f5				push af  
c884 3a 98 c8			ld a, (.dmark)  
c887 32 62 ee			ld (debug_mark),a  
c88a 3a 99 c8			ld a, (.dmark+1)  
c88d 32 63 ee			ld (debug_mark+1),a  
c890 3a 9a c8			ld a, (.dmark+2)  
c893 32 64 ee			ld (debug_mark+2),a  
c896 18 03			jr .pastdmark  
c898 ..			.dmark: db "RI3"  
c89b f1			.pastdmark: pop af  
c89c			endm  
# End of macro DMARK
c89c						CALLMONITOR 
c89c cd 6f ee			call debug_vector  
c89f				endm  
# End of macro CALLMONITOR
c89f					endif 
c89f			 
c89f 03					inc bc 
c8a0 ed b8				lddr 
c8a2					 
c8a2 21 b8 e2				ld hl, scratch 
c8a5					if DEBUG_FORTH_WORDS 
c8a5						DMARK "RI4" 
c8a5 f5				push af  
c8a6 3a ba c8			ld a, (.dmark)  
c8a9 32 62 ee			ld (debug_mark),a  
c8ac 3a bb c8			ld a, (.dmark+1)  
c8af 32 63 ee			ld (debug_mark+1),a  
c8b2 3a bc c8			ld a, (.dmark+2)  
c8b5 32 64 ee			ld (debug_mark+2),a  
c8b8 18 03			jr .pastdmark  
c8ba ..			.dmark: db "RI4"  
c8bd f1			.pastdmark: pop af  
c8be			endm  
# End of macro DMARK
c8be						CALLMONITOR 
c8be cd 6f ee			call debug_vector  
c8c1				endm  
# End of macro CALLMONITOR
c8c1					endif 
c8c1 cd 63 9a				call forth_push_str 
c8c4			 
c8c4			 
c8c4					NEXTW 
c8c4 cd 6c ee			call parse_vector 
c8c7 c3 e5 9d			jp macro_next 
c8ca				endm 
# End of macro NEXTW
c8ca			 
c8ca			 
c8ca			.STR2NUM: 
c8ca				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c8ca 48				db WORD_SYS_CORE+52             
c8cb 59 c9			dw .NUM2STR            
c8cd 08				db 7 + 1 
c8ce .. 00			db "STR2NUM",0              
c8d6				endm 
# End of macro CWHEAD
c8d6			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c8d6			 
c8d6			 
c8d6			; TODO STR type check to do 
c8d6					if DEBUG_FORTH_WORDS_KEY 
c8d6						DMARK "S2N" 
c8d6 f5				push af  
c8d7 3a eb c8			ld a, (.dmark)  
c8da 32 62 ee			ld (debug_mark),a  
c8dd 3a ec c8			ld a, (.dmark+1)  
c8e0 32 63 ee			ld (debug_mark+1),a  
c8e3 3a ed c8			ld a, (.dmark+2)  
c8e6 32 64 ee			ld (debug_mark+2),a  
c8e9 18 03			jr .pastdmark  
c8eb ..			.dmark: db "S2N"  
c8ee f1			.pastdmark: pop af  
c8ef			endm  
# End of macro DMARK
c8ef						CALLMONITOR 
c8ef cd 6f ee			call debug_vector  
c8f2				endm  
# End of macro CALLMONITOR
c8f2					endif 
c8f2			 
c8f2					;FORTH_DSP 
c8f2					FORTH_DSP_VALUE 
c8f2 cd e3 9b			call macro_forth_dsp_value 
c8f5				endm 
# End of macro FORTH_DSP_VALUE
c8f5					;inc hl 
c8f5			 
c8f5 eb					ex de, hl 
c8f6					if DEBUG_FORTH_WORDS 
c8f6						DMARK "S2a" 
c8f6 f5				push af  
c8f7 3a 0b c9			ld a, (.dmark)  
c8fa 32 62 ee			ld (debug_mark),a  
c8fd 3a 0c c9			ld a, (.dmark+1)  
c900 32 63 ee			ld (debug_mark+1),a  
c903 3a 0d c9			ld a, (.dmark+2)  
c906 32 64 ee			ld (debug_mark+2),a  
c909 18 03			jr .pastdmark  
c90b ..			.dmark: db "S2a"  
c90e f1			.pastdmark: pop af  
c90f			endm  
# End of macro DMARK
c90f						CALLMONITOR 
c90f cd 6f ee			call debug_vector  
c912				endm  
# End of macro CALLMONITOR
c912					endif 
c912 cd e7 8f				call string_to_uint16 
c915			 
c915					if DEBUG_FORTH_WORDS 
c915						DMARK "S2b" 
c915 f5				push af  
c916 3a 2a c9			ld a, (.dmark)  
c919 32 62 ee			ld (debug_mark),a  
c91c 3a 2b c9			ld a, (.dmark+1)  
c91f 32 63 ee			ld (debug_mark+1),a  
c922 3a 2c c9			ld a, (.dmark+2)  
c925 32 64 ee			ld (debug_mark+2),a  
c928 18 03			jr .pastdmark  
c92a ..			.dmark: db "S2b"  
c92d f1			.pastdmark: pop af  
c92e			endm  
# End of macro DMARK
c92e						CALLMONITOR 
c92e cd 6f ee			call debug_vector  
c931				endm  
# End of macro CALLMONITOR
c931					endif 
c931			;		push hl 
c931					FORTH_DSP_POP 
c931 cd b2 9c			call macro_forth_dsp_pop 
c934				endm 
# End of macro FORTH_DSP_POP
c934			;		pop hl 
c934					 
c934					if DEBUG_FORTH_WORDS 
c934						DMARK "S2b" 
c934 f5				push af  
c935 3a 49 c9			ld a, (.dmark)  
c938 32 62 ee			ld (debug_mark),a  
c93b 3a 4a c9			ld a, (.dmark+1)  
c93e 32 63 ee			ld (debug_mark+1),a  
c941 3a 4b c9			ld a, (.dmark+2)  
c944 32 64 ee			ld (debug_mark+2),a  
c947 18 03			jr .pastdmark  
c949 ..			.dmark: db "S2b"  
c94c f1			.pastdmark: pop af  
c94d			endm  
# End of macro DMARK
c94d						CALLMONITOR 
c94d cd 6f ee			call debug_vector  
c950				endm  
# End of macro CALLMONITOR
c950					endif 
c950 cd f5 99				call forth_push_numhl	 
c953			 
c953				 
c953				       NEXTW 
c953 cd 6c ee			call parse_vector 
c956 c3 e5 9d			jp macro_next 
c959				endm 
# End of macro NEXTW
c959			.NUM2STR: 
c959				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c959 48				db WORD_SYS_CORE+52             
c95a ee c9			dw .CONCAT            
c95c 08				db 7 + 1 
c95d .. 00			db "NUM2STR",0              
c965				endm 
# End of macro CWHEAD
c965			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
c965			 
c965			;		; malloc a string to target 
c965			;		ld hl, 10     ; TODO max string size should be fine 
c965			;		call malloc 
c965			;		push hl    ; save malloc location 
c965			; 
c965			; 
c965			;; TODO check int type 
c965					if DEBUG_FORTH_WORDS_KEY 
c965						DMARK "N2S" 
c965 f5				push af  
c966 3a 7a c9			ld a, (.dmark)  
c969 32 62 ee			ld (debug_mark),a  
c96c 3a 7b c9			ld a, (.dmark+1)  
c96f 32 63 ee			ld (debug_mark+1),a  
c972 3a 7c c9			ld a, (.dmark+2)  
c975 32 64 ee			ld (debug_mark+2),a  
c978 18 03			jr .pastdmark  
c97a ..			.dmark: db "N2S"  
c97d f1			.pastdmark: pop af  
c97e			endm  
# End of macro DMARK
c97e						CALLMONITOR 
c97e cd 6f ee			call debug_vector  
c981				endm  
# End of macro CALLMONITOR
c981					endif 
c981			 
c981					FORTH_DSP_VALUEHL 
c981 cd fa 9b			call macro_dsp_valuehl 
c984				endm 
# End of macro FORTH_DSP_VALUEHL
c984			 
c984					if DEBUG_FORTH_WORDS 
c984						DMARK "NS1" 
c984 f5				push af  
c985 3a 99 c9			ld a, (.dmark)  
c988 32 62 ee			ld (debug_mark),a  
c98b 3a 9a c9			ld a, (.dmark+1)  
c98e 32 63 ee			ld (debug_mark+1),a  
c991 3a 9b c9			ld a, (.dmark+2)  
c994 32 64 ee			ld (debug_mark+2),a  
c997 18 03			jr .pastdmark  
c999 ..			.dmark: db "NS1"  
c99c f1			.pastdmark: pop af  
c99d			endm  
# End of macro DMARK
c99d						CALLMONITOR 
c99d cd 6f ee			call debug_vector  
c9a0				endm  
# End of macro CALLMONITOR
c9a0					endif 
c9a0					FORTH_DSP_POP 
c9a0 cd b2 9c			call macro_forth_dsp_pop 
c9a3				endm 
# End of macro FORTH_DSP_POP
c9a3			 
c9a3 eb					ex de, hl 
c9a4 21 b8 e2				ld hl, scratch 
c9a7					if DEBUG_FORTH_WORDS 
c9a7						DMARK "NS2" 
c9a7 f5				push af  
c9a8 3a bc c9			ld a, (.dmark)  
c9ab 32 62 ee			ld (debug_mark),a  
c9ae 3a bd c9			ld a, (.dmark+1)  
c9b1 32 63 ee			ld (debug_mark+1),a  
c9b4 3a be c9			ld a, (.dmark+2)  
c9b7 32 64 ee			ld (debug_mark+2),a  
c9ba 18 03			jr .pastdmark  
c9bc ..			.dmark: db "NS2"  
c9bf f1			.pastdmark: pop af  
c9c0			endm  
# End of macro DMARK
c9c0						CALLMONITOR 
c9c0 cd 6f ee			call debug_vector  
c9c3				endm  
# End of macro CALLMONITOR
c9c3					endif 
c9c3 cd ff 8f				call uitoa_16 
c9c6 21 b8 e2				ld hl, scratch 
c9c9					if DEBUG_FORTH_WORDS 
c9c9						DMARK "NS3" 
c9c9 f5				push af  
c9ca 3a de c9			ld a, (.dmark)  
c9cd 32 62 ee			ld (debug_mark),a  
c9d0 3a df c9			ld a, (.dmark+1)  
c9d3 32 63 ee			ld (debug_mark+1),a  
c9d6 3a e0 c9			ld a, (.dmark+2)  
c9d9 32 64 ee			ld (debug_mark+2),a  
c9dc 18 03			jr .pastdmark  
c9de ..			.dmark: db "NS3"  
c9e1 f1			.pastdmark: pop af  
c9e2			endm  
# End of macro DMARK
c9e2						CALLMONITOR 
c9e2 cd 6f ee			call debug_vector  
c9e5				endm  
# End of macro CALLMONITOR
c9e5					endif 
c9e5 cd 63 9a				call forth_push_str 
c9e8			;		ld a, l 
c9e8			;		call DispAToASCII   
c9e8			;;TODO need to chage above call to dump into string 
c9e8			; 
c9e8			; 
c9e8			 
c9e8				       NEXTW 
c9e8 cd 6c ee			call parse_vector 
c9eb c3 e5 9d			jp macro_next 
c9ee				endm 
# End of macro NEXTW
c9ee			 
c9ee			.CONCAT: 
c9ee				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c9ee 48				db WORD_SYS_CORE+52             
c9ef a4 ca			dw .FIND            
c9f1 07				db 6 + 1 
c9f2 .. 00			db "CONCAT",0              
c9f9				endm 
# End of macro CWHEAD
c9f9			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c9f9			 
c9f9			; TODO check string type 
c9f9			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c9f9			 
c9f9					if DEBUG_FORTH_WORDS_KEY 
c9f9						DMARK "CON" 
c9f9 f5				push af  
c9fa 3a 0e ca			ld a, (.dmark)  
c9fd 32 62 ee			ld (debug_mark),a  
ca00 3a 0f ca			ld a, (.dmark+1)  
ca03 32 63 ee			ld (debug_mark+1),a  
ca06 3a 10 ca			ld a, (.dmark+2)  
ca09 32 64 ee			ld (debug_mark+2),a  
ca0c 18 03			jr .pastdmark  
ca0e ..			.dmark: db "CON"  
ca11 f1			.pastdmark: pop af  
ca12			endm  
# End of macro DMARK
ca12						CALLMONITOR 
ca12 cd 6f ee			call debug_vector  
ca15				endm  
# End of macro CALLMONITOR
ca15					endif 
ca15			 
ca15			 
ca15					FORTH_DSP_VALUE 
ca15 cd e3 9b			call macro_forth_dsp_value 
ca18				endm 
# End of macro FORTH_DSP_VALUE
ca18 e5					push hl   ; s2 
ca19			 
ca19					FORTH_DSP_POP 
ca19 cd b2 9c			call macro_forth_dsp_pop 
ca1c				endm 
# End of macro FORTH_DSP_POP
ca1c			 
ca1c					FORTH_DSP_VALUE 
ca1c cd e3 9b			call macro_forth_dsp_value 
ca1f				endm 
# End of macro FORTH_DSP_VALUE
ca1f			 
ca1f e5					push hl   ; s1 
ca20			 
ca20					FORTH_DSP_POP 
ca20 cd b2 9c			call macro_forth_dsp_pop 
ca23				endm 
# End of macro FORTH_DSP_POP
ca23					 
ca23			 
ca23					; copy s1 
ca23			 
ca23				 
ca23					; save ptr 
ca23 e1					pop hl  
ca24 e5					push hl 
ca25 3e 00				ld a, 0 
ca27 cd 5b 90				call strlent 
ca2a					;inc hl    ; zer0 
ca2a 06 00				ld b, 0 
ca2c 4d					ld c, l 
ca2d e1					pop hl		 
ca2e 11 b8 e2				ld de, scratch	 
ca31					if DEBUG_FORTH_WORDS 
ca31						DMARK "CO1" 
ca31 f5				push af  
ca32 3a 46 ca			ld a, (.dmark)  
ca35 32 62 ee			ld (debug_mark),a  
ca38 3a 47 ca			ld a, (.dmark+1)  
ca3b 32 63 ee			ld (debug_mark+1),a  
ca3e 3a 48 ca			ld a, (.dmark+2)  
ca41 32 64 ee			ld (debug_mark+2),a  
ca44 18 03			jr .pastdmark  
ca46 ..			.dmark: db "CO1"  
ca49 f1			.pastdmark: pop af  
ca4a			endm  
# End of macro DMARK
ca4a						CALLMONITOR 
ca4a cd 6f ee			call debug_vector  
ca4d				endm  
# End of macro CALLMONITOR
ca4d					endif 
ca4d ed b0				ldir 
ca4f			 
ca4f e1					pop hl 
ca50 e5					push hl 
ca51 d5					push de 
ca52			 
ca52			 
ca52 3e 00				ld a, 0 
ca54 cd 5b 90				call strlent 
ca57 23					inc hl    ; zer0 
ca58 23					inc hl 
ca59 06 00				ld b, 0 
ca5b 4d					ld c, l 
ca5c d1					pop de 
ca5d e1					pop hl		 
ca5e					if DEBUG_FORTH_WORDS 
ca5e						DMARK "CO2" 
ca5e f5				push af  
ca5f 3a 73 ca			ld a, (.dmark)  
ca62 32 62 ee			ld (debug_mark),a  
ca65 3a 74 ca			ld a, (.dmark+1)  
ca68 32 63 ee			ld (debug_mark+1),a  
ca6b 3a 75 ca			ld a, (.dmark+2)  
ca6e 32 64 ee			ld (debug_mark+2),a  
ca71 18 03			jr .pastdmark  
ca73 ..			.dmark: db "CO2"  
ca76 f1			.pastdmark: pop af  
ca77			endm  
# End of macro DMARK
ca77						CALLMONITOR 
ca77 cd 6f ee			call debug_vector  
ca7a				endm  
# End of macro CALLMONITOR
ca7a					endif 
ca7a ed b0				ldir 
ca7c			 
ca7c			 
ca7c			 
ca7c 21 b8 e2				ld hl, scratch 
ca7f					if DEBUG_FORTH_WORDS 
ca7f						DMARK "CO5" 
ca7f f5				push af  
ca80 3a 94 ca			ld a, (.dmark)  
ca83 32 62 ee			ld (debug_mark),a  
ca86 3a 95 ca			ld a, (.dmark+1)  
ca89 32 63 ee			ld (debug_mark+1),a  
ca8c 3a 96 ca			ld a, (.dmark+2)  
ca8f 32 64 ee			ld (debug_mark+2),a  
ca92 18 03			jr .pastdmark  
ca94 ..			.dmark: db "CO5"  
ca97 f1			.pastdmark: pop af  
ca98			endm  
# End of macro DMARK
ca98						CALLMONITOR 
ca98 cd 6f ee			call debug_vector  
ca9b				endm  
# End of macro CALLMONITOR
ca9b					endif 
ca9b			 
ca9b cd 63 9a				call forth_push_str 
ca9e			 
ca9e			 
ca9e			 
ca9e			 
ca9e				       NEXTW 
ca9e cd 6c ee			call parse_vector 
caa1 c3 e5 9d			jp macro_next 
caa4				endm 
# End of macro NEXTW
caa4			 
caa4			 
caa4			.FIND: 
caa4				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
caa4 4b				db WORD_SYS_CORE+55             
caa5 65 cb			dw .LEN            
caa7 05				db 4 + 1 
caa8 .. 00			db "FIND",0              
caad				endm 
# End of macro CWHEAD
caad			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
caad			 
caad					if DEBUG_FORTH_WORDS_KEY 
caad						DMARK "FND" 
caad f5				push af  
caae 3a c2 ca			ld a, (.dmark)  
cab1 32 62 ee			ld (debug_mark),a  
cab4 3a c3 ca			ld a, (.dmark+1)  
cab7 32 63 ee			ld (debug_mark+1),a  
caba 3a c4 ca			ld a, (.dmark+2)  
cabd 32 64 ee			ld (debug_mark+2),a  
cac0 18 03			jr .pastdmark  
cac2 ..			.dmark: db "FND"  
cac5 f1			.pastdmark: pop af  
cac6			endm  
# End of macro DMARK
cac6						CALLMONITOR 
cac6 cd 6f ee			call debug_vector  
cac9				endm  
# End of macro CALLMONITOR
cac9					endif 
cac9			 
cac9			; TODO check string type 
cac9					FORTH_DSP_VALUE 
cac9 cd e3 9b			call macro_forth_dsp_value 
cacc				endm 
# End of macro FORTH_DSP_VALUE
cacc			 
cacc e5					push hl    
cacd 7e					ld a,(hl)    ; char to find   
cace			; TODO change char to substr 
cace			 
cace f5					push af 
cacf					 
cacf			 
cacf			 
cacf					if DEBUG_FORTH_WORDS 
cacf						DMARK "FN1" 
cacf f5				push af  
cad0 3a e4 ca			ld a, (.dmark)  
cad3 32 62 ee			ld (debug_mark),a  
cad6 3a e5 ca			ld a, (.dmark+1)  
cad9 32 63 ee			ld (debug_mark+1),a  
cadc 3a e6 ca			ld a, (.dmark+2)  
cadf 32 64 ee			ld (debug_mark+2),a  
cae2 18 03			jr .pastdmark  
cae4 ..			.dmark: db "FN1"  
cae7 f1			.pastdmark: pop af  
cae8			endm  
# End of macro DMARK
cae8						CALLMONITOR 
cae8 cd 6f ee			call debug_vector  
caeb				endm  
# End of macro CALLMONITOR
caeb					endif 
caeb			 
caeb					FORTH_DSP_POP 
caeb cd b2 9c			call macro_forth_dsp_pop 
caee				endm 
# End of macro FORTH_DSP_POP
caee			 
caee					; string to search 
caee			 
caee					FORTH_DSP_VALUE 
caee cd e3 9b			call macro_forth_dsp_value 
caf1				endm 
# End of macro FORTH_DSP_VALUE
caf1			 
caf1 d1					pop de  ; d is char to find  
caf2			 
caf2					if DEBUG_FORTH_WORDS 
caf2						DMARK "FN2" 
caf2 f5				push af  
caf3 3a 07 cb			ld a, (.dmark)  
caf6 32 62 ee			ld (debug_mark),a  
caf9 3a 08 cb			ld a, (.dmark+1)  
cafc 32 63 ee			ld (debug_mark+1),a  
caff 3a 09 cb			ld a, (.dmark+2)  
cb02 32 64 ee			ld (debug_mark+2),a  
cb05 18 03			jr .pastdmark  
cb07 ..			.dmark: db "FN2"  
cb0a f1			.pastdmark: pop af  
cb0b			endm  
# End of macro DMARK
cb0b						CALLMONITOR 
cb0b cd 6f ee			call debug_vector  
cb0e				endm  
# End of macro CALLMONITOR
cb0e					endif 
cb0e					 
cb0e 01 00 00				ld bc, 0 
cb11 7e			.findchar:      ld a,(hl) 
cb12 fe 00				cp 0   		 
cb14 28 27				jr z, .finddone     
cb16 ba					cp d 
cb17 28 20				jr z, .foundchar 
cb19 03					inc bc 
cb1a 23					inc hl 
cb1b					if DEBUG_FORTH_WORDS 
cb1b						DMARK "FN3" 
cb1b f5				push af  
cb1c 3a 30 cb			ld a, (.dmark)  
cb1f 32 62 ee			ld (debug_mark),a  
cb22 3a 31 cb			ld a, (.dmark+1)  
cb25 32 63 ee			ld (debug_mark+1),a  
cb28 3a 32 cb			ld a, (.dmark+2)  
cb2b 32 64 ee			ld (debug_mark+2),a  
cb2e 18 03			jr .pastdmark  
cb30 ..			.dmark: db "FN3"  
cb33 f1			.pastdmark: pop af  
cb34			endm  
# End of macro DMARK
cb34						CALLMONITOR 
cb34 cd 6f ee			call debug_vector  
cb37				endm  
# End of macro CALLMONITOR
cb37					endif 
cb37 18 d8				jr .findchar 
cb39			 
cb39			 
cb39 c5			.foundchar:	push bc 
cb3a e1					pop hl 
cb3b 18 03				jr .findexit 
cb3d			 
cb3d			 
cb3d							 
cb3d			 
cb3d			.finddone:     ; got to end of string with no find 
cb3d 21 00 00				ld hl, 0 
cb40			.findexit: 
cb40			 
cb40					if DEBUG_FORTH_WORDS 
cb40						DMARK "FNd" 
cb40 f5				push af  
cb41 3a 55 cb			ld a, (.dmark)  
cb44 32 62 ee			ld (debug_mark),a  
cb47 3a 56 cb			ld a, (.dmark+1)  
cb4a 32 63 ee			ld (debug_mark+1),a  
cb4d 3a 57 cb			ld a, (.dmark+2)  
cb50 32 64 ee			ld (debug_mark+2),a  
cb53 18 03			jr .pastdmark  
cb55 ..			.dmark: db "FNd"  
cb58 f1			.pastdmark: pop af  
cb59			endm  
# End of macro DMARK
cb59						CALLMONITOR 
cb59 cd 6f ee			call debug_vector  
cb5c				endm  
# End of macro CALLMONITOR
cb5c					endif 
cb5c cd f5 99			call forth_push_numhl 
cb5f			 
cb5f				       NEXTW 
cb5f cd 6c ee			call parse_vector 
cb62 c3 e5 9d			jp macro_next 
cb65				endm 
# End of macro NEXTW
cb65			 
cb65			.LEN: 
cb65				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
cb65 4c				db WORD_SYS_CORE+56             
cb66 d2 cb			dw .ASC            
cb68 06				db 5 + 1 
cb69 .. 00			db "COUNT",0              
cb6f				endm 
# End of macro CWHEAD
cb6f			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
cb6f			 
cb6f					if DEBUG_FORTH_WORDS_KEY 
cb6f						DMARK "CNT" 
cb6f f5				push af  
cb70 3a 84 cb			ld a, (.dmark)  
cb73 32 62 ee			ld (debug_mark),a  
cb76 3a 85 cb			ld a, (.dmark+1)  
cb79 32 63 ee			ld (debug_mark+1),a  
cb7c 3a 86 cb			ld a, (.dmark+2)  
cb7f 32 64 ee			ld (debug_mark+2),a  
cb82 18 03			jr .pastdmark  
cb84 ..			.dmark: db "CNT"  
cb87 f1			.pastdmark: pop af  
cb88			endm  
# End of macro DMARK
cb88						CALLMONITOR 
cb88 cd 6f ee			call debug_vector  
cb8b				endm  
# End of macro CALLMONITOR
cb8b					endif 
cb8b			; TODO check string type 
cb8b					FORTH_DSP_VALUE 
cb8b cd e3 9b			call macro_forth_dsp_value 
cb8e				endm 
# End of macro FORTH_DSP_VALUE
cb8e			 
cb8e			 
cb8e					if DEBUG_FORTH_WORDS 
cb8e						DMARK "CN?" 
cb8e f5				push af  
cb8f 3a a3 cb			ld a, (.dmark)  
cb92 32 62 ee			ld (debug_mark),a  
cb95 3a a4 cb			ld a, (.dmark+1)  
cb98 32 63 ee			ld (debug_mark+1),a  
cb9b 3a a5 cb			ld a, (.dmark+2)  
cb9e 32 64 ee			ld (debug_mark+2),a  
cba1 18 03			jr .pastdmark  
cba3 ..			.dmark: db "CN?"  
cba6 f1			.pastdmark: pop af  
cba7			endm  
# End of macro DMARK
cba7						CALLMONITOR 
cba7 cd 6f ee			call debug_vector  
cbaa				endm  
# End of macro CALLMONITOR
cbaa					endif 
cbaa cd 50 90				call strlenz 
cbad					if DEBUG_FORTH_WORDS 
cbad						DMARK "CNl" 
cbad f5				push af  
cbae 3a c2 cb			ld a, (.dmark)  
cbb1 32 62 ee			ld (debug_mark),a  
cbb4 3a c3 cb			ld a, (.dmark+1)  
cbb7 32 63 ee			ld (debug_mark+1),a  
cbba 3a c4 cb			ld a, (.dmark+2)  
cbbd 32 64 ee			ld (debug_mark+2),a  
cbc0 18 03			jr .pastdmark  
cbc2 ..			.dmark: db "CNl"  
cbc5 f1			.pastdmark: pop af  
cbc6			endm  
# End of macro DMARK
cbc6						CALLMONITOR 
cbc6 cd 6f ee			call debug_vector  
cbc9				endm  
# End of macro CALLMONITOR
cbc9					endif 
cbc9			 
cbc9 cd f5 99				call forth_push_numhl 
cbcc			 
cbcc			 
cbcc			 
cbcc				       NEXTW 
cbcc cd 6c ee			call parse_vector 
cbcf c3 e5 9d			jp macro_next 
cbd2				endm 
# End of macro NEXTW
cbd2			.ASC: 
cbd2				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
cbd2 4d				db WORD_SYS_CORE+57             
cbd3 43 cc			dw .CHR            
cbd5 04				db 3 + 1 
cbd6 .. 00			db "ASC",0              
cbda				endm 
# End of macro CWHEAD
cbda			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
cbda					if DEBUG_FORTH_WORDS_KEY 
cbda						DMARK "ASC" 
cbda f5				push af  
cbdb 3a ef cb			ld a, (.dmark)  
cbde 32 62 ee			ld (debug_mark),a  
cbe1 3a f0 cb			ld a, (.dmark+1)  
cbe4 32 63 ee			ld (debug_mark+1),a  
cbe7 3a f1 cb			ld a, (.dmark+2)  
cbea 32 64 ee			ld (debug_mark+2),a  
cbed 18 03			jr .pastdmark  
cbef ..			.dmark: db "ASC"  
cbf2 f1			.pastdmark: pop af  
cbf3			endm  
# End of macro DMARK
cbf3						CALLMONITOR 
cbf3 cd 6f ee			call debug_vector  
cbf6				endm  
# End of macro CALLMONITOR
cbf6					endif 
cbf6					FORTH_DSP_VALUE 
cbf6 cd e3 9b			call macro_forth_dsp_value 
cbf9				endm 
# End of macro FORTH_DSP_VALUE
cbf9					;v5 FORTH_DSP_VALUE 
cbf9			;		inc hl      ; now at start of numeric as string 
cbf9			 
cbf9 e5					push hl 
cbfa			 
cbfa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbfa cd b2 9c			call macro_forth_dsp_pop 
cbfd				endm 
# End of macro FORTH_DSP_POP
cbfd			 
cbfd e1					pop hl 
cbfe			 
cbfe					if DEBUG_FORTH_WORDS 
cbfe						DMARK "AS1" 
cbfe f5				push af  
cbff 3a 13 cc			ld a, (.dmark)  
cc02 32 62 ee			ld (debug_mark),a  
cc05 3a 14 cc			ld a, (.dmark+1)  
cc08 32 63 ee			ld (debug_mark+1),a  
cc0b 3a 15 cc			ld a, (.dmark+2)  
cc0e 32 64 ee			ld (debug_mark+2),a  
cc11 18 03			jr .pastdmark  
cc13 ..			.dmark: db "AS1"  
cc16 f1			.pastdmark: pop af  
cc17			endm  
# End of macro DMARK
cc17						CALLMONITOR 
cc17 cd 6f ee			call debug_vector  
cc1a				endm  
# End of macro CALLMONITOR
cc1a					endif 
cc1a					; push the content of a onto the stack as a value 
cc1a			 
cc1a 7e					ld a,(hl)   ; get char 
cc1b 26 00				ld h,0 
cc1d 6f					ld l,a 
cc1e					if DEBUG_FORTH_WORDS 
cc1e						DMARK "AS2" 
cc1e f5				push af  
cc1f 3a 33 cc			ld a, (.dmark)  
cc22 32 62 ee			ld (debug_mark),a  
cc25 3a 34 cc			ld a, (.dmark+1)  
cc28 32 63 ee			ld (debug_mark+1),a  
cc2b 3a 35 cc			ld a, (.dmark+2)  
cc2e 32 64 ee			ld (debug_mark+2),a  
cc31 18 03			jr .pastdmark  
cc33 ..			.dmark: db "AS2"  
cc36 f1			.pastdmark: pop af  
cc37			endm  
# End of macro DMARK
cc37						CALLMONITOR 
cc37 cd 6f ee			call debug_vector  
cc3a				endm  
# End of macro CALLMONITOR
cc3a					endif 
cc3a cd f5 99				call forth_push_numhl 
cc3d			 
cc3d				       NEXTW 
cc3d cd 6c ee			call parse_vector 
cc40 c3 e5 9d			jp macro_next 
cc43				endm 
# End of macro NEXTW
cc43			 
cc43			.CHR: 
cc43				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
cc43 4d				db WORD_SYS_CORE+57             
cc44 82 cc			dw .ENDSTR            
cc46 04				db 3 + 1 
cc47 .. 00			db "CHR",0              
cc4b				endm 
# End of macro CWHEAD
cc4b			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
cc4b					if DEBUG_FORTH_WORDS_KEY 
cc4b						DMARK "CHR" 
cc4b f5				push af  
cc4c 3a 60 cc			ld a, (.dmark)  
cc4f 32 62 ee			ld (debug_mark),a  
cc52 3a 61 cc			ld a, (.dmark+1)  
cc55 32 63 ee			ld (debug_mark+1),a  
cc58 3a 62 cc			ld a, (.dmark+2)  
cc5b 32 64 ee			ld (debug_mark+2),a  
cc5e 18 03			jr .pastdmark  
cc60 ..			.dmark: db "CHR"  
cc63 f1			.pastdmark: pop af  
cc64			endm  
# End of macro DMARK
cc64						CALLMONITOR 
cc64 cd 6f ee			call debug_vector  
cc67				endm  
# End of macro CALLMONITOR
cc67					endif 
cc67					FORTH_DSP_VALUEHL 
cc67 cd fa 9b			call macro_dsp_valuehl 
cc6a				endm 
# End of macro FORTH_DSP_VALUEHL
cc6a			 
cc6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc6a cd b2 9c			call macro_forth_dsp_pop 
cc6d				endm 
# End of macro FORTH_DSP_POP
cc6d			 
cc6d					; save asci byte as a zero term string and push string 
cc6d			 
cc6d 7d					ld a,l 
cc6e 32 b8 e2				ld (scratch), a 
cc71			 
cc71 3e 00				ld a, 0 
cc73 32 b9 e2				ld (scratch+1), a 
cc76			 
cc76 21 b8 e2				ld hl, scratch 
cc79 cd 63 9a				call forth_push_str 
cc7c			 
cc7c			 
cc7c				       NEXTW 
cc7c cd 6c ee			call parse_vector 
cc7f c3 e5 9d			jp macro_next 
cc82				endm 
# End of macro NEXTW
cc82			 
cc82			 
cc82			 
cc82			 
cc82			.ENDSTR: 
cc82			; eof 
cc82			 
# End of file forth_words_str.asm
cc82			include "forth_words_key.asm" 
cc82			 
cc82			; | ## Keyboard Words 
cc82			 
cc82			.KEY: 
cc82				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
cc82 3e				db WORD_SYS_CORE+42             
cc83 b5 cc			dw .KEYDB            
cc85 04				db 3 + 1 
cc86 .. 00			db "KEY",0              
cc8a				endm 
# End of macro CWHEAD
cc8a			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
cc8a			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
cc8a			; | | Can use something like this to process: 
cc8a			; | | > repeat active . key ?dup if emit then #1 until  
cc8a			 
cc8a					if DEBUG_FORTH_WORDS_KEY 
cc8a						DMARK "KEY" 
cc8a f5				push af  
cc8b 3a 9f cc			ld a, (.dmark)  
cc8e 32 62 ee			ld (debug_mark),a  
cc91 3a a0 cc			ld a, (.dmark+1)  
cc94 32 63 ee			ld (debug_mark+1),a  
cc97 3a a1 cc			ld a, (.dmark+2)  
cc9a 32 64 ee			ld (debug_mark+2),a  
cc9d 18 03			jr .pastdmark  
cc9f ..			.dmark: db "KEY"  
cca2 f1			.pastdmark: pop af  
cca3			endm  
# End of macro DMARK
cca3						CALLMONITOR 
cca3 cd 6f ee			call debug_vector  
cca6				endm  
# End of macro CALLMONITOR
cca6					endif 
cca6			; TODO currently waits 
cca6 cd e1 e3				call cinndb 
cca9					;call cin_wait 
cca9 6f					ld l, a 
ccaa 26 00				ld h, 0 
ccac cd f5 99				call forth_push_numhl 
ccaf					NEXTW 
ccaf cd 6c ee			call parse_vector 
ccb2 c3 e5 9d			jp macro_next 
ccb5				endm 
# End of macro NEXTW
ccb5			.KEYDB: 
ccb5				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
ccb5 3e				db WORD_SYS_CORE+42             
ccb6 ea cc			dw .WAITK            
ccb8 06				db 5 + 1 
ccb9 .. 00			db "KEYDB",0              
ccbf				endm 
# End of macro CWHEAD
ccbf			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
ccbf			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
ccbf			; | | Can use something like this to process: 
ccbf			; | | > repeat active . key ?dup if emit then #1 until  
ccbf			 
ccbf					if DEBUG_FORTH_WORDS_KEY 
ccbf						DMARK "KEB" 
ccbf f5				push af  
ccc0 3a d4 cc			ld a, (.dmark)  
ccc3 32 62 ee			ld (debug_mark),a  
ccc6 3a d5 cc			ld a, (.dmark+1)  
ccc9 32 63 ee			ld (debug_mark+1),a  
cccc 3a d6 cc			ld a, (.dmark+2)  
cccf 32 64 ee			ld (debug_mark+2),a  
ccd2 18 03			jr .pastdmark  
ccd4 ..			.dmark: db "KEB"  
ccd7 f1			.pastdmark: pop af  
ccd8			endm  
# End of macro DMARK
ccd8						CALLMONITOR 
ccd8 cd 6f ee			call debug_vector  
ccdb				endm  
# End of macro CALLMONITOR
ccdb					endif 
ccdb			; TODO currently waits 
ccdb cd e1 e3				call cin 
ccde					;call cin_wait 
ccde 6f					ld l, a 
ccdf 26 00				ld h, 0 
cce1 cd f5 99				call forth_push_numhl 
cce4					NEXTW 
cce4 cd 6c ee			call parse_vector 
cce7 c3 e5 9d			jp macro_next 
ccea				endm 
# End of macro NEXTW
ccea			.WAITK: 
ccea				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
ccea 3f				db WORD_SYS_CORE+43             
cceb 1f cd			dw .ACCEPT            
cced 06				db 5 + 1 
ccee .. 00			db "WAITK",0              
ccf4				endm 
# End of macro CWHEAD
ccf4			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
ccf4					if DEBUG_FORTH_WORDS_KEY 
ccf4						DMARK "WAI" 
ccf4 f5				push af  
ccf5 3a 09 cd			ld a, (.dmark)  
ccf8 32 62 ee			ld (debug_mark),a  
ccfb 3a 0a cd			ld a, (.dmark+1)  
ccfe 32 63 ee			ld (debug_mark+1),a  
cd01 3a 0b cd			ld a, (.dmark+2)  
cd04 32 64 ee			ld (debug_mark+2),a  
cd07 18 03			jr .pastdmark  
cd09 ..			.dmark: db "WAI"  
cd0c f1			.pastdmark: pop af  
cd0d			endm  
# End of macro DMARK
cd0d						CALLMONITOR 
cd0d cd 6f ee			call debug_vector  
cd10				endm  
# End of macro CALLMONITOR
cd10					endif 
cd10 cd db e3				call cin_wait 
cd13 6f					ld l, a 
cd14 26 00				ld h, 0 
cd16 cd f5 99				call forth_push_numhl 
cd19					NEXTW 
cd19 cd 6c ee			call parse_vector 
cd1c c3 e5 9d			jp macro_next 
cd1f				endm 
# End of macro NEXTW
cd1f			.ACCEPT: 
cd1f				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
cd1f 40				db WORD_SYS_CORE+44             
cd20 80 cd			dw .EDIT            
cd22 07				db 6 + 1 
cd23 .. 00			db "ACCEPT",0              
cd2a				endm 
# End of macro CWHEAD
cd2a			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
cd2a					; TODO crashes on push 
cd2a					if DEBUG_FORTH_WORDS_KEY 
cd2a						DMARK "ACC" 
cd2a f5				push af  
cd2b 3a 3f cd			ld a, (.dmark)  
cd2e 32 62 ee			ld (debug_mark),a  
cd31 3a 40 cd			ld a, (.dmark+1)  
cd34 32 63 ee			ld (debug_mark+1),a  
cd37 3a 41 cd			ld a, (.dmark+2)  
cd3a 32 64 ee			ld (debug_mark+2),a  
cd3d 18 03			jr .pastdmark  
cd3f ..			.dmark: db "ACC"  
cd42 f1			.pastdmark: pop af  
cd43			endm  
# End of macro DMARK
cd43						CALLMONITOR 
cd43 cd 6f ee			call debug_vector  
cd46				endm  
# End of macro CALLMONITOR
cd46					endif 
cd46 21 b6 e4				ld hl, os_input 
cd49 3e 00				ld a, 0 
cd4b 77					ld (hl),a 
cd4c 3a 55 ea				ld a,(f_cursor_ptr) 
cd4f 16 64				ld d, 100 
cd51 0e 00				ld c, 0 
cd53 1e 28				ld e, 40 
cd55 cd 17 8d				call input_str 
cd58					; TODO perhaps do a type check and wrap in quotes if not a number 
cd58 21 b6 e4				ld hl, os_input 
cd5b					if DEBUG_FORTH_WORDS 
cd5b						DMARK "AC1" 
cd5b f5				push af  
cd5c 3a 70 cd			ld a, (.dmark)  
cd5f 32 62 ee			ld (debug_mark),a  
cd62 3a 71 cd			ld a, (.dmark+1)  
cd65 32 63 ee			ld (debug_mark+1),a  
cd68 3a 72 cd			ld a, (.dmark+2)  
cd6b 32 64 ee			ld (debug_mark+2),a  
cd6e 18 03			jr .pastdmark  
cd70 ..			.dmark: db "AC1"  
cd73 f1			.pastdmark: pop af  
cd74			endm  
# End of macro DMARK
cd74						CALLMONITOR 
cd74 cd 6f ee			call debug_vector  
cd77				endm  
# End of macro CALLMONITOR
cd77					endif 
cd77 cd 63 9a				call forth_push_str 
cd7a					NEXTW 
cd7a cd 6c ee			call parse_vector 
cd7d c3 e5 9d			jp macro_next 
cd80				endm 
# End of macro NEXTW
cd80			 
cd80			.EDIT: 
cd80				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
cd80 40				db WORD_SYS_CORE+44             
cd81 25 ce			dw .DEDIT            
cd83 05				db 4 + 1 
cd84 .. 00			db "EDIT",0              
cd89				endm 
# End of macro CWHEAD
cd89			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
cd89			 
cd89					; TODO does not copy from stack 
cd89					if DEBUG_FORTH_WORDS_KEY 
cd89						DMARK "EDT" 
cd89 f5				push af  
cd8a 3a 9e cd			ld a, (.dmark)  
cd8d 32 62 ee			ld (debug_mark),a  
cd90 3a 9f cd			ld a, (.dmark+1)  
cd93 32 63 ee			ld (debug_mark+1),a  
cd96 3a a0 cd			ld a, (.dmark+2)  
cd99 32 64 ee			ld (debug_mark+2),a  
cd9c 18 03			jr .pastdmark  
cd9e ..			.dmark: db "EDT"  
cda1 f1			.pastdmark: pop af  
cda2			endm  
# End of macro DMARK
cda2						CALLMONITOR 
cda2 cd 6f ee			call debug_vector  
cda5				endm  
# End of macro CALLMONITOR
cda5					endif 
cda5			 
cda5					;FORTH_DSP 
cda5					FORTH_DSP_VALUEHL 
cda5 cd fa 9b			call macro_dsp_valuehl 
cda8				endm 
# End of macro FORTH_DSP_VALUEHL
cda8			;		inc hl    ; TODO do type check 
cda8			 
cda8			;		call get_word_hl 
cda8 e5					push hl 
cda9					if DEBUG_FORTH_WORDS 
cda9						DMARK "EDp" 
cda9 f5				push af  
cdaa 3a be cd			ld a, (.dmark)  
cdad 32 62 ee			ld (debug_mark),a  
cdb0 3a bf cd			ld a, (.dmark+1)  
cdb3 32 63 ee			ld (debug_mark+1),a  
cdb6 3a c0 cd			ld a, (.dmark+2)  
cdb9 32 64 ee			ld (debug_mark+2),a  
cdbc 18 03			jr .pastdmark  
cdbe ..			.dmark: db "EDp"  
cdc1 f1			.pastdmark: pop af  
cdc2			endm  
# End of macro DMARK
cdc2						CALLMONITOR 
cdc2 cd 6f ee			call debug_vector  
cdc5				endm  
# End of macro CALLMONITOR
cdc5					endif 
cdc5				;	ld a, 0 
cdc5 cd 50 90				call strlenz 
cdc8 23					inc hl 
cdc9			 
cdc9 06 00				ld b, 0 
cdcb 4d					ld c, l 
cdcc			 
cdcc e1					pop hl 
cdcd 11 b6 e4				ld de, os_input 
cdd0					if DEBUG_FORTH_WORDS_KEY 
cdd0						DMARK "EDc" 
cdd0 f5				push af  
cdd1 3a e5 cd			ld a, (.dmark)  
cdd4 32 62 ee			ld (debug_mark),a  
cdd7 3a e6 cd			ld a, (.dmark+1)  
cdda 32 63 ee			ld (debug_mark+1),a  
cddd 3a e7 cd			ld a, (.dmark+2)  
cde0 32 64 ee			ld (debug_mark+2),a  
cde3 18 03			jr .pastdmark  
cde5 ..			.dmark: db "EDc"  
cde8 f1			.pastdmark: pop af  
cde9			endm  
# End of macro DMARK
cde9						CALLMONITOR 
cde9 cd 6f ee			call debug_vector  
cdec				endm  
# End of macro CALLMONITOR
cdec					endif 
cdec ed b0				ldir 
cdee			 
cdee			 
cdee 21 b6 e4				ld hl, os_input 
cdf1					;ld a, 0 
cdf1					;ld (hl),a 
cdf1 3a 55 ea				ld a,(f_cursor_ptr) 
cdf4 16 64				ld d, 100 
cdf6 0e 00				ld c, 0 
cdf8 1e 28				ld e, 40 
cdfa cd 17 8d				call input_str 
cdfd					; TODO perhaps do a type check and wrap in quotes if not a number 
cdfd 21 b6 e4				ld hl, os_input 
ce00					if DEBUG_FORTH_WORDS 
ce00						DMARK "ED1" 
ce00 f5				push af  
ce01 3a 15 ce			ld a, (.dmark)  
ce04 32 62 ee			ld (debug_mark),a  
ce07 3a 16 ce			ld a, (.dmark+1)  
ce0a 32 63 ee			ld (debug_mark+1),a  
ce0d 3a 17 ce			ld a, (.dmark+2)  
ce10 32 64 ee			ld (debug_mark+2),a  
ce13 18 03			jr .pastdmark  
ce15 ..			.dmark: db "ED1"  
ce18 f1			.pastdmark: pop af  
ce19			endm  
# End of macro DMARK
ce19						CALLMONITOR 
ce19 cd 6f ee			call debug_vector  
ce1c				endm  
# End of macro CALLMONITOR
ce1c					endif 
ce1c cd 63 9a				call forth_push_str 
ce1f					NEXTW 
ce1f cd 6c ee			call parse_vector 
ce22 c3 e5 9d			jp macro_next 
ce25				endm 
# End of macro NEXTW
ce25			 
ce25			.DEDIT: 
ce25				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
ce25 40				db WORD_SYS_CORE+44             
ce26 8a ce			dw .ENDKEY            
ce28 06				db 5 + 1 
ce29 .. 00			db "DEDIT",0              
ce2f				endm 
# End of macro CWHEAD
ce2f			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
ce2f			 
ce2f					; TODO does not copy from stack 
ce2f					if DEBUG_FORTH_WORDS_KEY 
ce2f						DMARK "DED" 
ce2f f5				push af  
ce30 3a 44 ce			ld a, (.dmark)  
ce33 32 62 ee			ld (debug_mark),a  
ce36 3a 45 ce			ld a, (.dmark+1)  
ce39 32 63 ee			ld (debug_mark+1),a  
ce3c 3a 46 ce			ld a, (.dmark+2)  
ce3f 32 64 ee			ld (debug_mark+2),a  
ce42 18 03			jr .pastdmark  
ce44 ..			.dmark: db "DED"  
ce47 f1			.pastdmark: pop af  
ce48			endm  
# End of macro DMARK
ce48						CALLMONITOR 
ce48 cd 6f ee			call debug_vector  
ce4b				endm  
# End of macro CALLMONITOR
ce4b					endif 
ce4b			 
ce4b					;FORTH_DSP 
ce4b					FORTH_DSP_VALUEHL 
ce4b cd fa 9b			call macro_dsp_valuehl 
ce4e				endm 
# End of macro FORTH_DSP_VALUEHL
ce4e			;		inc hl    ; TODO do type check 
ce4e			 
ce4e			;		call get_word_hl 
ce4e e5					push hl 
ce4f e5					push hl 
ce50					FORTH_DSP_POP 
ce50 cd b2 9c			call macro_forth_dsp_pop 
ce53				endm 
# End of macro FORTH_DSP_POP
ce53 e1					pop hl 
ce54					if DEBUG_FORTH_WORDS 
ce54						DMARK "EDp" 
ce54 f5				push af  
ce55 3a 69 ce			ld a, (.dmark)  
ce58 32 62 ee			ld (debug_mark),a  
ce5b 3a 6a ce			ld a, (.dmark+1)  
ce5e 32 63 ee			ld (debug_mark+1),a  
ce61 3a 6b ce			ld a, (.dmark+2)  
ce64 32 64 ee			ld (debug_mark+2),a  
ce67 18 03			jr .pastdmark  
ce69 ..			.dmark: db "EDp"  
ce6c f1			.pastdmark: pop af  
ce6d			endm  
# End of macro DMARK
ce6d						CALLMONITOR 
ce6d cd 6f ee			call debug_vector  
ce70				endm  
# End of macro CALLMONITOR
ce70					endif 
ce70				;	ld a, 0 
ce70 cd 50 90				call strlenz 
ce73 23					inc hl 
ce74			 
ce74 06 00				ld b, 0 
ce76 4d					ld c, l 
ce77			 
ce77 e1					pop hl 
ce78			 
ce78					;ld a, 0 
ce78					;ld (hl),a 
ce78 3a 55 ea				ld a,(f_cursor_ptr) 
ce7b 16 64				ld d, 100 
ce7d 0e 00				ld c, 0 
ce7f 1e 28				ld e, 40 
ce81 cd 17 8d				call input_str 
ce84					; TODO perhaps do a type check and wrap in quotes if not a number 
ce84					NEXTW 
ce84 cd 6c ee			call parse_vector 
ce87 c3 e5 9d			jp macro_next 
ce8a				endm 
# End of macro NEXTW
ce8a			 
ce8a			 
ce8a			.ENDKEY: 
ce8a			; eof 
ce8a			 
# End of file forth_words_key.asm
ce8a			include "forth_words_const.asm" 
ce8a			 
ce8a			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
ce8a			 
ce8a			 
ce8a			.SPITIME: 
ce8a				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
ce8a 77				db WORD_SYS_CORE+99             
ce8b a2 ce			dw .VA            
ce8d 08				db 7 + 1 
ce8e .. 00			db "SPITIME",0              
ce96				endm 
# End of macro CWHEAD
ce96			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
ce96			; 
ce96			; | | If using BANK devices then leave as is. 
ce96			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
ce96			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
ce96			 
ce96 21 5b ea				ld hl, spi_clktime  
ce99 cd f5 99				call forth_push_numhl 
ce9c			 
ce9c					NEXTW 
ce9c cd 6c ee			call parse_vector 
ce9f c3 e5 9d			jp macro_next 
cea2				endm 
# End of macro NEXTW
cea2			 
cea2			 
cea2			.VA: 
cea2				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
cea2 77				db WORD_SYS_CORE+99             
cea3 b5 ce			dw .SYMBOL            
cea5 03				db 2 + 1 
cea6 .. 00			db "VA",0              
cea9				endm 
# End of macro CWHEAD
cea9			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
cea9 21 1f ea				ld hl, cli_var_array 
ceac cd f5 99				call forth_push_numhl 
ceaf			 
ceaf					NEXTW 
ceaf cd 6c ee			call parse_vector 
ceb2 c3 e5 9d			jp macro_next 
ceb5				endm 
# End of macro NEXTW
ceb5			 
ceb5			.SYMBOL: 
ceb5				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
ceb5 77				db WORD_SYS_CORE+99             
ceb6 c4 cf			dw .ENDCONST            
ceb8 07				db 6 + 1 
ceb9 .. 00			db "SYMBOL",0              
cec0				endm 
# End of macro CWHEAD
cec0			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
cec0			; | 
cec0			; | | The value is the number reference and the final address is pushed to stack 
cec0			 
cec0			; | | ``` 
cec0			; | | dw sym_table 
cec0			; | | dw nmi_vector 
cec0			; | | dw cli_autodisplay 
cec0			; | | dw cli_data_sp 
cec0			; | | dw cli_data_stack 
cec0			; | | dw cli_loop_sp 
cec0			; | | dw cli_loop_stack 
cec0			; | | dw cli_var_array 
cec0			; | | dw cursor_col 
cec0			; | | dw cursor_ptr 
cec0			; | | ; 10 
cec0			; | | dw cursor_row 
cec0			; | | dw debug_mark 
cec0			; | | dw display_fb0 
cec0			; | | dw display_fb1 
cec0			; | | dw display_fb2 
cec0			; | | dw display_fb3 
cec0			; | | dw display_fb_active 
cec0			; | | dw execscratch 
cec0			; | | dw f_cursor_ptr 
cec0			; | | dw hardware_word 
cec0			; | | ;20 
cec0			; | | dw input_at_cursor 
cec0			; | | dw input_at_pos 
cec0			; | | dw input_cur_flash 
cec0			; | | dw input_cur_onoff 
cec0			; | | dw input_cursor 
cec0			; | | dw input_display_size 
cec0			; | | dw input_len 
cec0			; | | dw input_ptr 
cec0			; | | dw input_size 
cec0			; | | dw input_start 
cec0			; | | ; 30 
cec0			; | | dw input_str 
cec0			; | | dw input_under_cursor 
cec0			; | | dw os_cli_cmd 
cec0			; | | dw os_cur_ptr 
cec0			; | | dw os_current_i 
cec0			; | | dw os_input 
cec0			; | | dw os_last_cmd 
cec0			; | | dw os_last_new_uword 
cec0			; | | dw debug_vector 
cec0			; | | dw os_view_hl 
cec0			; | | ;40 
cec0			; | | dw os_word_scratch 
cec0			; | | dw portbctl 
cec0			; | | dw portbdata 
cec0			; | | dw spi_cartdev 
cec0			; | | dw spi_cartdev2 
cec0			; | | dw spi_clktime 
cec0			; | | dw spi_device 
cec0			; | | dw spi_device_id 
cec0			; | | dw spi_portbyte 
cec0			; | | dw stackstore 
cec0			; | | ; 50 
cec0			; | | if STORAGE_SE 
cec0			; | | dw storage_actl 
cec0			; | | dw storage_adata 
cec0			; | | else 
cec0			; | | dw 0 
cec0			; | | dw 0 
cec0			; | | endif 
cec0			; | | dw storage_append 
cec0			; | | if STORAGE_SE 
cec0			; | | dw storage_bctl 
cec0			; | | else 
cec0			; | | dw 0 
cec0			; | | endif 
cec0			; | | dw store_bank_active 
cec0			; | | dw store_filecache 
cec0			; | | dw store_longread 
cec0			; | | dw store_openaddr 
cec0			; | | dw store_openext 
cec0			; | | dw store_openmaxext 
cec0			; | | ; 60 
cec0			; | | dw store_page 
cec0			; | | dw store_readbuf 
cec0			; | | dw store_readcont 
cec0			; | | dw store_readptr 
cec0			; | | dw store_tmpext 
cec0			; | | dw store_tmpid 
cec0			; | | dw store_tmppageid 
cec0			; | | dw malloc 
cec0			; | | dw free 
cec0			; | | dw cin 
cec0			; | | ; 70 
cec0			; | | dw cin_wait 
cec0			; | | dw forth_push_numhl 
cec0			; | | dw forth_push_str 
cec0			; | | dw parse_vector 
cec0			; | | ``` 
cec0			 
cec0					if DEBUG_FORTH_WORDS_KEY 
cec0						DMARK "SYM" 
cec0 f5				push af  
cec1 3a d5 ce			ld a, (.dmark)  
cec4 32 62 ee			ld (debug_mark),a  
cec7 3a d6 ce			ld a, (.dmark+1)  
ceca 32 63 ee			ld (debug_mark+1),a  
cecd 3a d7 ce			ld a, (.dmark+2)  
ced0 32 64 ee			ld (debug_mark+2),a  
ced3 18 03			jr .pastdmark  
ced5 ..			.dmark: db "SYM"  
ced8 f1			.pastdmark: pop af  
ced9			endm  
# End of macro DMARK
ced9						CALLMONITOR 
ced9 cd 6f ee			call debug_vector  
cedc				endm  
# End of macro CALLMONITOR
cedc					endif 
cedc			 
cedc					FORTH_DSP_VALUEHL 
cedc cd fa 9b			call macro_dsp_valuehl 
cedf				endm 
# End of macro FORTH_DSP_VALUEHL
cedf			 
cedf 7d					ld a, l     
cee0			 
cee0			 
cee0					if DEBUG_FORTH_WORDS 
cee0						DMARK "SY1" 
cee0 f5				push af  
cee1 3a f5 ce			ld a, (.dmark)  
cee4 32 62 ee			ld (debug_mark),a  
cee7 3a f6 ce			ld a, (.dmark+1)  
ceea 32 63 ee			ld (debug_mark+1),a  
ceed 3a f7 ce			ld a, (.dmark+2)  
cef0 32 64 ee			ld (debug_mark+2),a  
cef3 18 03			jr .pastdmark  
cef5 ..			.dmark: db "SY1"  
cef8 f1			.pastdmark: pop af  
cef9			endm  
# End of macro DMARK
cef9						CALLMONITOR 
cef9 cd 6f ee			call debug_vector  
cefc				endm  
# End of macro CALLMONITOR
cefc					endif 
cefc					 
cefc f5					push af	 
cefd					FORTH_DSP_POP 
cefd cd b2 9c			call macro_forth_dsp_pop 
cf00				endm 
# End of macro FORTH_DSP_POP
cf00 f1					pop af 
cf01			 
cf01 cb 27				sla a  
cf03				 
cf03					 
cf03					if DEBUG_FORTH_WORDS 
cf03						DMARK "SY" 
cf03 f5				push af  
cf04 3a 18 cf			ld a, (.dmark)  
cf07 32 62 ee			ld (debug_mark),a  
cf0a 3a 19 cf			ld a, (.dmark+1)  
cf0d 32 63 ee			ld (debug_mark+1),a  
cf10 3a 1a cf			ld a, (.dmark+2)  
cf13 32 64 ee			ld (debug_mark+2),a  
cf16 18 02			jr .pastdmark  
cf18 ..			.dmark: db "SY"  
cf1a f1			.pastdmark: pop af  
cf1b			endm  
# End of macro DMARK
cf1b						CALLMONITOR 
cf1b cd 6f ee			call debug_vector  
cf1e				endm  
# End of macro CALLMONITOR
cf1e					endif 
cf1e			 
cf1e 21 30 cf				ld hl, sym_table 
cf21 cd ea 8c				call addatohl 
cf24 cd 67 9d				call loadwordinhl 
cf27 cd f5 99				call forth_push_numhl 
cf2a			 
cf2a			 
cf2a				       NEXTW 
cf2a cd 6c ee			call parse_vector 
cf2d c3 e5 9d			jp macro_next 
cf30				endm 
# End of macro NEXTW
cf30			 
cf30			sym_table: 
cf30			 
cf30			; 0 
cf30 30 cf		dw sym_table 
cf32 72 ee		dw nmi_vector 
cf34 33 ea		dw cli_autodisplay 
cf36 e5 e9		dw cli_data_sp 
cf38 1f e8		dw cli_data_stack 
cf3a e7 e9		dw cli_loop_sp 
cf3c 21 e9		dw cli_loop_stack 
cf3e 1f ea		dw cli_var_array 
cf40 bc eb		dw cursor_col 
cf42 ba eb		dw cursor_ptr 
cf44			; 10 
cf44 bb eb		dw cursor_row 
cf46 62 ee		dw debug_mark 
cf48 a8 ed		dw display_fb0 
cf4a 07 ed		dw display_fb1 
cf4c c5 eb		dw display_fb2 
cf4e 66 ec		dw display_fb3 
cf50 c3 eb		dw display_fb_active 
cf52 b7 e3		dw execscratch 
cf54 55 ea		dw f_cursor_ptr 
cf56 75 ee		dw hardware_word 
cf58			;20 
cf58 59 ee		dw input_at_cursor 
cf5a 5b ee		dw input_at_pos 
cf5c 57 ee		dw input_cur_flash 
cf5e 56 ee		dw input_cur_onoff 
cf60 4c ee		dw input_cursor 
cf62 5c ee		dw input_display_size 
cf64 51 ee		dw input_len 
cf66 60 ee		dw input_ptr 
cf68 5d ee		dw input_size 
cf6a 5e ee		dw input_start 
cf6c			; 30 
cf6c 17 8d		dw input_str 
cf6e 5a ee		dw input_under_cursor 
cf70 df e5		dw os_cli_cmd 
cf72 db e5		dw os_cur_ptr 
cf74 dd e5		dw os_current_i 
cf76 b6 e4		dw os_input 
cf78 de e6		dw os_last_cmd 
cf7a b5 e5		dw os_last_new_uword 
cf7c 6f ee		dw debug_vector 
cf7e 9a e2		dw os_view_hl 
cf80			;40 
cf80 bd e5		dw os_word_scratch 
cf82 c3 00		dw portbctl 
cf84 c1 00		dw portbdata 
cf86 5a ea		dw spi_cartdev 
cf88 59 ea		dw spi_cartdev2 
cf8a 5b ea		dw spi_clktime 
cf8c 57 ea		dw spi_device 
cf8e 56 ea		dw spi_device_id 
cf90 58 ea		dw spi_portbyte 
cf92 9e eb		dw stackstore 
cf94			; 50 
cf94			if STORAGE_SE 
cf94			dw storage_actl 
cf94			dw storage_adata 
cf94			else 
cf94 00 00		dw 0 
cf96 00 00		dw 0 
cf98			endif 
cf98 77 88		dw storage_append 
cf9a			if STORAGE_SE 
cf9a			dw storage_bctl 
cf9a			else 
cf9a 00 00		dw 0 
cf9c			endif 
cf9c 8a eb		dw store_bank_active 
cf9e 5e ea		dw store_filecache 
cfa0 6c ea		dw store_longread 
cfa2 62 ea		dw store_openaddr 
cfa4 61 ea		dw store_openext 
cfa6 60 ea		dw store_openmaxext 
cfa8			; 60 
cfa8 71 ea		dw store_page 
cfaa 6d ea		dw store_readbuf 
cfac 64 ea		dw store_readcont 
cfae 6f ea		dw store_readptr 
cfb0 64 ea		dw store_tmpext 
cfb2 65 ea		dw store_tmpid 
cfb4 5c ea		dw store_tmppageid 
cfb6 c5 90		dw malloc 
cfb8 8f 91		dw free 
cfba e1 e3		dw cin 
cfbc			; 70 
cfbc db e3		dw cin_wait 
cfbe f5 99		dw forth_push_numhl 
cfc0 63 9a		dw forth_push_str 
cfc2 6c ee		dw parse_vector 
cfc4			 
cfc4			.ENDCONST: 
cfc4			 
cfc4			; eof 
cfc4			 
cfc4			 
# End of file forth_words_const.asm
cfc4			 
cfc4			if STORAGE_SE 
cfc4			   	include "forth_words_storage.asm" 
cfc4			endif 
cfc4				include "forth_words_device.asm" 
cfc4			; Device related words 
cfc4			 
cfc4			; | ## Device Words 
cfc4			 
cfc4			;if SOUND_ENABLE 
cfc4			;.NOTE: 
cfc4			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
cfc4			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
cfc4			;		if DEBUG_FORTH_WORDS_KEY 
cfc4			;			DMARK "NTE" 
cfc4			;			CALLMONITOR 
cfc4			;		endif 
cfc4			; 
cfc4			;	 
cfc4			; 
cfc4			;		NEXTW 
cfc4			;.AFTERSOUND: 
cfc4			;endif 
cfc4			 
cfc4			 
cfc4			USE_GPIO: equ 0 
cfc4			 
cfc4			if USE_GPIO 
cfc4			.GP1: 
cfc4				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
cfc4			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
cfc4					NEXTW 
cfc4			.GP2: 
cfc4				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
cfc4			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
cfc4			 
cfc4					NEXTW 
cfc4			 
cfc4			.GP3: 
cfc4				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
cfc4			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
cfc4			 
cfc4					NEXTW 
cfc4			 
cfc4			.GP4: 
cfc4				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
cfc4			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
cfc4			 
cfc4					NEXTW 
cfc4			.SIN: 
cfc4			 
cfc4			 
cfc4			endif 
cfc4			 
cfc4			 
cfc4				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
cfc4 33				db WORD_SYS_CORE+31             
cfc5 fc cf			dw .SOUT            
cfc7 03				db 2 + 1 
cfc8 .. 00			db "IN",0              
cfcb				endm 
# End of macro CWHEAD
cfcb			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
cfcb					if DEBUG_FORTH_WORDS_KEY 
cfcb						DMARK "IN." 
cfcb f5				push af  
cfcc 3a e0 cf			ld a, (.dmark)  
cfcf 32 62 ee			ld (debug_mark),a  
cfd2 3a e1 cf			ld a, (.dmark+1)  
cfd5 32 63 ee			ld (debug_mark+1),a  
cfd8 3a e2 cf			ld a, (.dmark+2)  
cfdb 32 64 ee			ld (debug_mark+2),a  
cfde 18 03			jr .pastdmark  
cfe0 ..			.dmark: db "IN."  
cfe3 f1			.pastdmark: pop af  
cfe4			endm  
# End of macro DMARK
cfe4						CALLMONITOR 
cfe4 cd 6f ee			call debug_vector  
cfe7				endm  
# End of macro CALLMONITOR
cfe7					endif 
cfe7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cfe7 cd fa 9b			call macro_dsp_valuehl 
cfea				endm 
# End of macro FORTH_DSP_VALUEHL
cfea			 
cfea e5					push hl 
cfeb			 
cfeb					; destroy value TOS 
cfeb			 
cfeb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cfeb cd b2 9c			call macro_forth_dsp_pop 
cfee				endm 
# End of macro FORTH_DSP_POP
cfee			 
cfee					; one value on hl get other one back 
cfee			 
cfee c1					pop bc 
cfef			 
cfef					; do the sub 
cfef			;		ex de, hl 
cfef			 
cfef ed 68				in l,(c) 
cff1			 
cff1					; save it 
cff1			 
cff1 26 00				ld h,0 
cff3			 
cff3					; TODO push value back onto stack for another op etc 
cff3			 
cff3 cd f5 99				call forth_push_numhl 
cff6					NEXTW 
cff6 cd 6c ee			call parse_vector 
cff9 c3 e5 9d			jp macro_next 
cffc				endm 
# End of macro NEXTW
cffc			.SOUT: 
cffc				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
cffc 34				db WORD_SYS_CORE+32             
cffd 52 d0			dw .SPIO            
cfff 04				db 3 + 1 
d000 .. 00			db "OUT",0              
d004				endm 
# End of macro CWHEAD
d004			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
d004					if DEBUG_FORTH_WORDS_KEY 
d004						DMARK "OUT" 
d004 f5				push af  
d005 3a 19 d0			ld a, (.dmark)  
d008 32 62 ee			ld (debug_mark),a  
d00b 3a 1a d0			ld a, (.dmark+1)  
d00e 32 63 ee			ld (debug_mark+1),a  
d011 3a 1b d0			ld a, (.dmark+2)  
d014 32 64 ee			ld (debug_mark+2),a  
d017 18 03			jr .pastdmark  
d019 ..			.dmark: db "OUT"  
d01c f1			.pastdmark: pop af  
d01d			endm  
# End of macro DMARK
d01d						CALLMONITOR 
d01d cd 6f ee			call debug_vector  
d020				endm  
# End of macro CALLMONITOR
d020					endif 
d020			 
d020					; get port 
d020			 
d020					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d020 cd fa 9b			call macro_dsp_valuehl 
d023				endm 
# End of macro FORTH_DSP_VALUEHL
d023			 
d023 e5					push hl 
d024			 
d024					; destroy value TOS 
d024			 
d024					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d024 cd b2 9c			call macro_forth_dsp_pop 
d027				endm 
# End of macro FORTH_DSP_POP
d027			 
d027					; get byte to send 
d027			 
d027					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d027 cd fa 9b			call macro_dsp_valuehl 
d02a				endm 
# End of macro FORTH_DSP_VALUEHL
d02a			 
d02a			;		push hl 
d02a			 
d02a					; destroy value TOS 
d02a			 
d02a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d02a cd b2 9c			call macro_forth_dsp_pop 
d02d				endm 
# End of macro FORTH_DSP_POP
d02d			 
d02d					; one value on hl get other one back 
d02d			 
d02d			;		pop hl 
d02d			 
d02d c1					pop bc 
d02e			 
d02e					if DEBUG_FORTH_WORDS 
d02e						DMARK "OUT" 
d02e f5				push af  
d02f 3a 43 d0			ld a, (.dmark)  
d032 32 62 ee			ld (debug_mark),a  
d035 3a 44 d0			ld a, (.dmark+1)  
d038 32 63 ee			ld (debug_mark+1),a  
d03b 3a 45 d0			ld a, (.dmark+2)  
d03e 32 64 ee			ld (debug_mark+2),a  
d041 18 03			jr .pastdmark  
d043 ..			.dmark: db "OUT"  
d046 f1			.pastdmark: pop af  
d047			endm  
# End of macro DMARK
d047						CALLMONITOR 
d047 cd 6f ee			call debug_vector  
d04a				endm  
# End of macro CALLMONITOR
d04a					endif 
d04a			 
d04a ed 69				out (c), l 
d04c			 
d04c					NEXTW 
d04c cd 6c ee			call parse_vector 
d04f c3 e5 9d			jp macro_next 
d052				endm 
# End of macro NEXTW
d052			 
d052			 
d052			.SPIO: 
d052			 
d052			if STORAGE_SE 
d052				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
d052			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
d052			 
d052					call spi_ce_low 
d052			    NEXTW 
d052			 
d052			.SPICEH: 
d052				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
d052			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
d052			 
d052					call spi_ce_high 
d052			    NEXTW 
d052			 
d052			 
d052			.SPIOb: 
d052			 
d052				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
d052			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
d052			 
d052					if DEBUG_FORTH_WORDS_KEY 
d052						DMARK "SPo" 
d052						CALLMONITOR 
d052					endif 
d052					; get port 
d052			 
d052			 
d052					; get byte to send 
d052			 
d052					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d052			 
d052			;		push hl    ; u1  
d052			 
d052					; destroy value TOS 
d052			 
d052					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d052			 
d052					; one value on hl get other one back 
d052			 
d052			;		pop hl   ; u2 - addr 
d052			 
d052					; TODO Send SPI byte 
d052			 
d052			;		push hl 
d052			;		call spi_ce_low 
d052			;		pop hl 
d052					ld a, l 
d052					call spi_send_byte 
d052			;		call spi_ce_high 
d052			 
d052					NEXTW 
d052			 
d052			.SPII: 
d052				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
d052			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
d052					if DEBUG_FORTH_WORDS_KEY 
d052						DMARK "SPi" 
d052						CALLMONITOR 
d052					endif 
d052			 
d052					; TODO Get SPI byte 
d052			 
d052					call spi_read_byte 
d052			 
d052					if DEBUG_FORTH_WORDS 
d052						DMARK "Si2" 
d052						CALLMONITOR 
d052					endif 
d052					ld h, 0 
d052					ld l, a 
d052					if DEBUG_FORTH_WORDS 
d052						DMARK "Si3" 
d052						CALLMONITOR 
d052					endif 
d052					call forth_push_numhl 
d052			 
d052					NEXTW 
d052			 
d052			 
d052			 
d052			.SESEL: 
d052				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
d052			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
d052					if DEBUG_FORTH_WORDS_KEY 
d052						DMARK "BNK" 
d052						CALLMONITOR 
d052					endif 
d052			 
d052					ld a, 255 
d052					ld (spi_cartdev), a 
d052			 
d052					; get bank 
d052			 
d052					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d052			 
d052			;		push hl 
d052			 
d052					; destroy value TOS 
d052			 
d052					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d052			 
d052					; one value on hl get other one back 
d052			 
d052			;		pop hl 
d052			 
d052			 
d052					ld c, SPI_CE_HIGH 
d052					ld b, '0'    ; human readable bank number 
d052			 
d052					ld a, l 
d052			 
d052					if DEBUG_FORTH_WORDS 
d052						DMARK "BNK" 
d052						CALLMONITOR 
d052					endif 
d052			 
d052					; active low 
d052			 
d052					cp 0 
d052					jr z, .bset 
d052					cp 1 
d052					jr nz, .b2 
d052					res 0, c 
d052					ld b, '1'    ; human readable bank number 
d052			.b2:		cp 2 
d052					jr nz, .b3 
d052					res 1, c 
d052					ld b, '2'    ; human readable bank number 
d052			.b3:		cp 3 
d052					jr nz, .b4 
d052					res 2, c 
d052					ld b, '3'    ; human readable bank number 
d052			.b4:		cp 4 
d052					jr nz, .b5 
d052					res 3, c 
d052					ld b, '4'    ; human readable bank number 
d052			.b5:		cp 5 
d052					jr nz, .bset 
d052					res 4, c 
d052					ld b, '5'    ; human readable bank number 
d052			 
d052			.bset: 
d052					ld a, c 
d052					ld (spi_device),a 
d052					ld a, b 
d052					ld (spi_device_id),a 
d052					if DEBUG_FORTH_WORDS 
d052						DMARK "BN2" 
d052						CALLMONITOR 
d052					endif 
d052			 
d052					; set default SPI clk pulse time as disabled for BANK use 
d052			 
d052					ld a, 0 
d052					ld (spi_clktime), a 
d052			 
d052					NEXTW 
d052			 
d052			.CARTDEV: 
d052				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
d052			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
d052					if DEBUG_FORTH_WORDS_KEY 
d052						DMARK "CDV" 
d052						CALLMONITOR 
d052					endif 
d052			 
d052					; disable se storage bank selection 
d052			 
d052					ld a, SPI_CE_HIGH		; ce high 
d052					ld (spi_device), a 
d052			 
d052					; get bank 
d052			 
d052					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d052			 
d052			;		push hl 
d052			 
d052					; destroy value TOS 
d052			 
d052					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d052			 
d052					; one value on hl get other one back 
d052			 
d052			;		pop hl 
d052			 
d052					; active low 
d052			 
d052					ld c, 255 
d052			 
d052					ld a, l 
d052					if DEBUG_FORTH_WORDS 
d052						DMARK "CDV" 
d052						CALLMONITOR 
d052					endif 
d052					cp 0 
d052					jr z, .cset 
d052					cp 1 
d052					jr nz, .c2 
d052					res 0, c 
d052			.c2:		cp 2 
d052					jr nz, .c3 
d052					res 1, c 
d052			.c3:		cp 3 
d052					jr nz, .c4 
d052					res 2, c 
d052			.c4:		cp 4 
d052					jr nz, .c5 
d052					res 3, c 
d052			.c5:		cp 5 
d052					jr nz, .c6 
d052					res 4, c 
d052			.c6:		cp 6 
d052					jr nz, .c7 
d052					res 5, c 
d052			.c7:		cp 7 
d052					jr nz, .c8 
d052					res 6, c 
d052			.c8:		cp 8 
d052					jr nz, .cset 
d052					res 7, c 
d052			.cset:		ld a, c 
d052					ld (spi_cartdev),a 
d052			 
d052					if DEBUG_FORTH_WORDS 
d052						DMARK "CD2" 
d052						CALLMONITOR 
d052					endif 
d052			 
d052					; set default SPI clk pulse time as 10ms for CARTDEV use 
d052			 
d052					ld a, $0a 
d052					ld (spi_clktime), a 
d052					NEXTW 
d052			endif 
d052			 
d052			.ENDDEVICE: 
d052			; eof 
d052			 
# End of file forth_words_device.asm
d052			 
d052			; var handler 
d052			 
d052			 
d052			.VARS: 
d052				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
d052 77				db WORD_SYS_CORE+99             
d053 06 d1			dw .V0            
d055 04				db 3 + 1 
d056 .. 00			db "VAR",0              
d05a				endm 
# End of macro CWHEAD
d05a			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
d05a			;| 
d05a			;| The variable name should consist of a single letter. e.g. "a" 
d05a			;! If a full string is passed then only the first char is looked at 
d05a			;| Any other char could exceed bounds checks!  
d05a			 
d05a					if DEBUG_FORTH_WORDS_KEY 
d05a						DMARK "VAR" 
d05a f5				push af  
d05b 3a 6f d0			ld a, (.dmark)  
d05e 32 62 ee			ld (debug_mark),a  
d061 3a 70 d0			ld a, (.dmark+1)  
d064 32 63 ee			ld (debug_mark+1),a  
d067 3a 71 d0			ld a, (.dmark+2)  
d06a 32 64 ee			ld (debug_mark+2),a  
d06d 18 03			jr .pastdmark  
d06f ..			.dmark: db "VAR"  
d072 f1			.pastdmark: pop af  
d073			endm  
# End of macro DMARK
d073						CALLMONITOR 
d073 cd 6f ee			call debug_vector  
d076				endm  
# End of macro CALLMONITOR
d076					endif 
d076			 
d076					FORTH_DSP_VALUEHL 
d076 cd fa 9b			call macro_dsp_valuehl 
d079				endm 
# End of macro FORTH_DSP_VALUEHL
d079			 
d079 7e					ld a, (hl)    ; get first char on of the string 
d07a			 
d07a			 
d07a					if DEBUG_FORTH_WORDS 
d07a						DMARK "VR1" 
d07a f5				push af  
d07b 3a 8f d0			ld a, (.dmark)  
d07e 32 62 ee			ld (debug_mark),a  
d081 3a 90 d0			ld a, (.dmark+1)  
d084 32 63 ee			ld (debug_mark+1),a  
d087 3a 91 d0			ld a, (.dmark+2)  
d08a 32 64 ee			ld (debug_mark+2),a  
d08d 18 03			jr .pastdmark  
d08f ..			.dmark: db "VR1"  
d092 f1			.pastdmark: pop af  
d093			endm  
# End of macro DMARK
d093						CALLMONITOR 
d093 cd 6f ee			call debug_vector  
d096				endm  
# End of macro CALLMONITOR
d096					endif 
d096					 
d096 f5					push af	 
d097					FORTH_DSP_POP 
d097 cd b2 9c			call macro_forth_dsp_pop 
d09a				endm 
# End of macro FORTH_DSP_POP
d09a f1					pop af 
d09b			 
d09b					; convert to upper 
d09b			 
d09b cd 5f 8f				call to_upper 
d09e					if DEBUG_FORTH_WORDS 
d09e						DMARK "Vaa" 
d09e f5				push af  
d09f 3a b3 d0			ld a, (.dmark)  
d0a2 32 62 ee			ld (debug_mark),a  
d0a5 3a b4 d0			ld a, (.dmark+1)  
d0a8 32 63 ee			ld (debug_mark+1),a  
d0ab 3a b5 d0			ld a, (.dmark+2)  
d0ae 32 64 ee			ld (debug_mark+2),a  
d0b1 18 03			jr .pastdmark  
d0b3 ..			.dmark: db "Vaa"  
d0b6 f1			.pastdmark: pop af  
d0b7			endm  
# End of macro DMARK
d0b7						CALLMONITOR 
d0b7 cd 6f ee			call debug_vector  
d0ba				endm  
# End of macro CALLMONITOR
d0ba					endif 
d0ba 06 41				ld b, 'A' 
d0bc 90					sub b			; set offset 
d0bd					if DEBUG_FORTH_WORDS 
d0bd						DMARK "Vbb" 
d0bd f5				push af  
d0be 3a d2 d0			ld a, (.dmark)  
d0c1 32 62 ee			ld (debug_mark),a  
d0c4 3a d3 d0			ld a, (.dmark+1)  
d0c7 32 63 ee			ld (debug_mark+1),a  
d0ca 3a d4 d0			ld a, (.dmark+2)  
d0cd 32 64 ee			ld (debug_mark+2),a  
d0d0 18 03			jr .pastdmark  
d0d2 ..			.dmark: db "Vbb"  
d0d5 f1			.pastdmark: pop af  
d0d6			endm  
# End of macro DMARK
d0d6						CALLMONITOR 
d0d6 cd 6f ee			call debug_vector  
d0d9				endm  
# End of macro CALLMONITOR
d0d9					endif 
d0d9 cb 27				sla a  
d0db				 
d0db					 
d0db					if DEBUG_FORTH_WORDS 
d0db						DMARK "VR2" 
d0db f5				push af  
d0dc 3a f0 d0			ld a, (.dmark)  
d0df 32 62 ee			ld (debug_mark),a  
d0e2 3a f1 d0			ld a, (.dmark+1)  
d0e5 32 63 ee			ld (debug_mark+1),a  
d0e8 3a f2 d0			ld a, (.dmark+2)  
d0eb 32 64 ee			ld (debug_mark+2),a  
d0ee 18 03			jr .pastdmark  
d0f0 ..			.dmark: db "VR2"  
d0f3 f1			.pastdmark: pop af  
d0f4			endm  
# End of macro DMARK
d0f4						CALLMONITOR 
d0f4 cd 6f ee			call debug_vector  
d0f7				endm  
# End of macro CALLMONITOR
d0f7					endif 
d0f7			 
d0f7 21 eb e9				ld hl, cli_var_array2 
d0fa cd ea 8c				call addatohl 
d0fd cd f5 99				call forth_push_numhl 
d100			 
d100			 
d100				       NEXTW 
d100 cd 6c ee			call parse_vector 
d103 c3 e5 9d			jp macro_next 
d106				endm 
# End of macro NEXTW
d106			.V0: 
d106				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
d106 78				db WORD_SYS_CORE+100             
d107 21 d1			dw .V0Q            
d109 04				db 3 + 1 
d10a .. 00			db "V0!",0              
d10e				endm 
# End of macro CWHEAD
d10e			;| V0! ( u1 -- )  Store value to v0  | DONE 
d10e			 
d10e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d10e cd fa 9b			call macro_dsp_valuehl 
d111				endm 
# End of macro FORTH_DSP_VALUEHL
d111			 
d111 11 1f ea				ld de, cli_var_array 
d114			 
d114 eb					ex de, hl 
d115 73					ld (hl), e 
d116 23					inc hl 
d117 72					ld (hl), d 
d118			 
d118					; destroy value TOS 
d118			 
d118					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d118 cd b2 9c			call macro_forth_dsp_pop 
d11b				endm 
# End of macro FORTH_DSP_POP
d11b			 
d11b				       NEXTW 
d11b cd 6c ee			call parse_vector 
d11e c3 e5 9d			jp macro_next 
d121				endm 
# End of macro NEXTW
d121			.V0Q: 
d121				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
d121 79				db WORD_SYS_CORE+101             
d122 35 d1			dw .V1S            
d124 04				db 3 + 1 
d125 .. 00			db "V0@",0              
d129				endm 
# End of macro CWHEAD
d129			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
d129 2a 1f ea				ld hl, (cli_var_array) 
d12c cd f5 99				call forth_push_numhl 
d12f			 
d12f				       NEXTW 
d12f cd 6c ee			call parse_vector 
d132 c3 e5 9d			jp macro_next 
d135				endm 
# End of macro NEXTW
d135			.V1S: 
d135				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
d135 7a				db WORD_SYS_CORE+102             
d136 50 d1			dw .V1Q            
d138 04				db 3 + 1 
d139 .. 00			db "V1!",0              
d13d				endm 
# End of macro CWHEAD
d13d			;| V1! ( u1 -- )  Store value to v1 | DONE 
d13d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d13d cd fa 9b			call macro_dsp_valuehl 
d140				endm 
# End of macro FORTH_DSP_VALUEHL
d140			 
d140 11 21 ea				ld de, cli_var_array+2 
d143				 
d143 eb					ex de, hl 
d144 73					ld (hl), e 
d145 23					inc hl 
d146 72					ld (hl), d 
d147			 
d147					; destroy value TOS 
d147			 
d147					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d147 cd b2 9c			call macro_forth_dsp_pop 
d14a				endm 
# End of macro FORTH_DSP_POP
d14a				       NEXTW 
d14a cd 6c ee			call parse_vector 
d14d c3 e5 9d			jp macro_next 
d150				endm 
# End of macro NEXTW
d150			.V1Q: 
d150				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
d150 7b				db WORD_SYS_CORE+103             
d151 64 d1			dw .V2S            
d153 04				db 3 + 1 
d154 .. 00			db "V1@",0              
d158				endm 
# End of macro CWHEAD
d158			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
d158 2a 21 ea				ld hl, (cli_var_array+2) 
d15b cd f5 99				call forth_push_numhl 
d15e				       NEXTW 
d15e cd 6c ee			call parse_vector 
d161 c3 e5 9d			jp macro_next 
d164				endm 
# End of macro NEXTW
d164			.V2S: 
d164				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
d164 7c				db WORD_SYS_CORE+104             
d165 7f d1			dw .V2Q            
d167 04				db 3 + 1 
d168 .. 00			db "V2!",0              
d16c				endm 
# End of macro CWHEAD
d16c			;| V2! ( u1 -- )  Store value to v2 | DONE 
d16c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d16c cd fa 9b			call macro_dsp_valuehl 
d16f				endm 
# End of macro FORTH_DSP_VALUEHL
d16f			 
d16f 11 23 ea				ld de, cli_var_array+4 
d172				 
d172 eb					ex de, hl 
d173 73					ld (hl), e 
d174 23					inc hl 
d175 72					ld (hl), d 
d176			 
d176					; destroy value TOS 
d176			 
d176					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d176 cd b2 9c			call macro_forth_dsp_pop 
d179				endm 
# End of macro FORTH_DSP_POP
d179				       NEXTW 
d179 cd 6c ee			call parse_vector 
d17c c3 e5 9d			jp macro_next 
d17f				endm 
# End of macro NEXTW
d17f			.V2Q: 
d17f				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
d17f 7d				db WORD_SYS_CORE+105             
d180 93 d1			dw .V3S            
d182 04				db 3 + 1 
d183 .. 00			db "V2@",0              
d187				endm 
# End of macro CWHEAD
d187			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
d187 2a 23 ea				ld hl, (cli_var_array+4) 
d18a cd f5 99				call forth_push_numhl 
d18d				       NEXTW 
d18d cd 6c ee			call parse_vector 
d190 c3 e5 9d			jp macro_next 
d193				endm 
# End of macro NEXTW
d193			.V3S: 
d193				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
d193 7c				db WORD_SYS_CORE+104             
d194 ae d1			dw .V3Q            
d196 04				db 3 + 1 
d197 .. 00			db "V3!",0              
d19b				endm 
# End of macro CWHEAD
d19b			;| V3! ( u1 -- )  Store value to v3 | DONE 
d19b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d19b cd fa 9b			call macro_dsp_valuehl 
d19e				endm 
# End of macro FORTH_DSP_VALUEHL
d19e			 
d19e 11 25 ea				ld de, cli_var_array+6 
d1a1				 
d1a1 eb					ex de, hl 
d1a2 73					ld (hl), e 
d1a3 23					inc hl 
d1a4 72					ld (hl), d 
d1a5			 
d1a5					; destroy value TOS 
d1a5			 
d1a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d1a5 cd b2 9c			call macro_forth_dsp_pop 
d1a8				endm 
# End of macro FORTH_DSP_POP
d1a8				       NEXTW 
d1a8 cd 6c ee			call parse_vector 
d1ab c3 e5 9d			jp macro_next 
d1ae				endm 
# End of macro NEXTW
d1ae			.V3Q: 
d1ae				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
d1ae 7d				db WORD_SYS_CORE+105             
d1af c2 d1			dw .END            
d1b1 04				db 3 + 1 
d1b2 .. 00			db "V3@",0              
d1b6				endm 
# End of macro CWHEAD
d1b6			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
d1b6 2a 25 ea				ld hl, (cli_var_array+6) 
d1b9 cd f5 99				call forth_push_numhl 
d1bc				       NEXTW 
d1bc cd 6c ee			call parse_vector 
d1bf c3 e5 9d			jp macro_next 
d1c2				endm 
# End of macro NEXTW
d1c2			 
d1c2			 
d1c2			 
d1c2			 
d1c2			 
d1c2			; end of dict marker 
d1c2			 
d1c2 00			.END:    db WORD_SYS_END 
d1c3 00 00			dw 0 
d1c5 00				db 0 
d1c6			 
d1c6			; use to jp here for user dict words to save on macro expansion  
d1c6			 
d1c6			user_dict_next: 
d1c6				NEXTW 
d1c6 cd 6c ee			call parse_vector 
d1c9 c3 e5 9d			jp macro_next 
d1cc				endm 
# End of macro NEXTW
d1cc			 
d1cc			 
d1cc			user_exec: 
d1cc				;    ld hl, <word code> 
d1cc				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
d1cc				;    call forthexec 
d1cc				;    jp user_dict_next   (NEXT) 
d1cc			        ;    <word code bytes> 
d1cc eb				ex de, hl 
d1cd 2a b9 e5			ld hl,(os_tok_ptr) 
d1d0				 
d1d0				FORTH_RSP_NEXT 
d1d0 cd 9c 99			call macro_forth_rsp_next 
d1d3				endm 
# End of macro FORTH_RSP_NEXT
d1d3			 
d1d3			if DEBUG_FORTH_UWORD 
d1d3						DMARK "UEX" 
d1d3 f5				push af  
d1d4 3a e8 d1			ld a, (.dmark)  
d1d7 32 62 ee			ld (debug_mark),a  
d1da 3a e9 d1			ld a, (.dmark+1)  
d1dd 32 63 ee			ld (debug_mark+1),a  
d1e0 3a ea d1			ld a, (.dmark+2)  
d1e3 32 64 ee			ld (debug_mark+2),a  
d1e6 18 03			jr .pastdmark  
d1e8 ..			.dmark: db "UEX"  
d1eb f1			.pastdmark: pop af  
d1ec			endm  
# End of macro DMARK
d1ec				CALLMONITOR 
d1ec cd 6f ee			call debug_vector  
d1ef				endm  
# End of macro CALLMONITOR
d1ef			endif 
d1ef			 
d1ef			 
d1ef			 
d1ef eb				ex de, hl 
d1f0 22 b9 e5			ld (os_tok_ptr), hl 
d1f3				 
d1f3				; Don't use next - Skips the first word in uword. 
d1f3			 
d1f3 c3 6e 9e			jp exec1 
d1f6			;	NEXT 
d1f6			 
d1f6			 
d1f6			; eof 
# End of file forth_wordsv4.asm
d1f6			endif 
d1f6			;;;;;;;;;;;;;; Debug code 
d1f6			 
d1f6			 
d1f6			;if DEBUG_FORTH_PARSE 
d1f6 .. 00		.nowordfound: db "No match",0 
d1ff .. 00		.compword:	db "Comparing word ",0 
d20f .. 00		.nextwordat:	db "Next word at",0 
d21c .. 00		.charmatch:	db "Char match",0 
d227			;endif 
d227			if DEBUG_FORTH_JP 
d227			.foundword:	db "Word match. Exec..",0 
d227			endif 
d227			;if DEBUG_FORTH_PUSH 
d227 .. 00		.enddict:	db "Dict end. Push.",0 
d237 .. 00		.push_str:	db "Pushing string",0 
d246 .. 00		.push_num:	db "Pushing number",0 
d255 .. 00		.data_sp:	db "SP:",0 
d259 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
d26b .. 00		.wordinde:	db "Word in DE (3/0):",0 
d27d .. 00		.wordinbc:	db "Word in BC (4/0):",0 
d28f			;endif 
d28f			;if DEBUG_FORTH_MALLOC 
d28f .. 00		.push_malloc:	db "Malloc address",0 
d29e			;endif 
d29e			 
d29e			 
d29e			 
d29e			; display malloc address and current data stack pointer  
d29e			 
d29e			malloc_error: 
d29e d5				push de 
d29f f5				push af 
d2a0 e5				push hl 
d2a1 cd bd 8a			call clear_display 
d2a4 11 c4 d2			ld de, .mallocerr 
d2a7 3e 00			ld a,0 
d2a9			;	ld de,os_word_scratch 
d2a9 cd d0 8a			call str_at_display 
d2ac 3e 11			ld a, display_row_1+17 
d2ae 11 62 ee			ld de, debug_mark 
d2b1 cd d0 8a			call str_at_display 
d2b4 cd e0 8a			call update_display 
d2b7				;call break_point_state 
d2b7 cd db e3			call cin_wait 
d2ba			 
d2ba			;	ld a, ' ' 
d2ba			;	ld (os_view_disable), a 
d2ba cd 6e 93			call bp_on 
d2bd e1				pop hl 
d2be f1				pop af 
d2bf d1				pop de	 
d2c0				CALLMONITOR 
d2c0 cd 6f ee			call debug_vector  
d2c3				endm  
# End of macro CALLMONITOR
d2c3 c9				ret 
d2c4			 
d2c4 .. 00		.mallocerr: 	db "Malloc Error",0 
d2d1			;if DEBUG_FORTH_PUSH 
d2d1			display_data_sp: 
d2d1 f5				push af 
d2d2			 
d2d2				; see if disabled 
d2d2			 
d2d2			 
d2d2 3a 6f ee			ld a, (debug_vector) 
d2d5 fe c9			cp $C9  ; RET 
d2d7				;ld a, (os_view_disable) 
d2d7				;cp '*' 
d2d7 28 67			jr z, .skipdsp 
d2d9			 
d2d9 e5				push hl 
d2da e5				push hl 
d2db e5			push hl 
d2dc cd bd 8a			call clear_display 
d2df e1			pop hl 
d2e0 7c				ld a,h 
d2e1 21 bd e5			ld hl, os_word_scratch 
d2e4 cd f3 8e			call hexout 
d2e7 e1				pop hl 
d2e8 7d				ld a,l 
d2e9 21 bf e5			ld hl, os_word_scratch+2 
d2ec cd f3 8e			call hexout 
d2ef 21 c1 e5			ld hl, os_word_scratch+4 
d2f2 3e 00			ld a,0 
d2f4 77				ld (hl),a 
d2f5 11 bd e5			ld de,os_word_scratch 
d2f8 3e 28				ld a, display_row_2 
d2fa cd d0 8a				call str_at_display 
d2fd 11 59 d2			ld de, .wordinhl 
d300 3e 00			ld a, display_row_1 
d302			 
d302 cd d0 8a				call str_at_display 
d305 11 62 ee			ld de, debug_mark 
d308 3e 11			ld a, display_row_1+17 
d30a			 
d30a cd d0 8a				call str_at_display 
d30d			 
d30d				; display current data stack pointer 
d30d 11 55 d2			ld de,.data_sp 
d310 3e 30				ld a, display_row_2 + 8 
d312 cd d0 8a				call str_at_display 
d315			 
d315 2a e5 e9			ld hl,(cli_data_sp) 
d318 e5				push hl 
d319 7c				ld a,h 
d31a 21 bd e5			ld hl, os_word_scratch 
d31d cd f3 8e			call hexout 
d320 e1				pop hl 
d321 7d				ld a,l 
d322 21 bf e5			ld hl, os_word_scratch+2 
d325 cd f3 8e			call hexout 
d328 21 c1 e5			ld hl, os_word_scratch+4 
d32b 3e 00			ld a,0 
d32d 77				ld (hl),a 
d32e 11 bd e5			ld de,os_word_scratch 
d331 3e 33				ld a, display_row_2 + 11 
d333 cd d0 8a				call str_at_display 
d336			 
d336			 
d336 cd e0 8a			call update_display 
d339 cd 00 8a			call delay1s 
d33c cd 00 8a			call delay1s 
d33f e1				pop hl 
d340			.skipdsp: 
d340 f1				pop af 
d341 c9				ret 
d342			 
d342			display_data_malloc: 
d342			 
d342 f5				push af 
d343 e5				push hl 
d344 e5				push hl 
d345 e5			push hl 
d346 cd bd 8a			call clear_display 
d349 e1			pop hl 
d34a 7c				ld a,h 
d34b 21 bd e5			ld hl, os_word_scratch 
d34e cd f3 8e			call hexout 
d351 e1				pop hl 
d352 7d				ld a,l 
d353 21 bf e5			ld hl, os_word_scratch+2 
d356 cd f3 8e			call hexout 
d359 21 c1 e5			ld hl, os_word_scratch+4 
d35c 3e 00			ld a,0 
d35e 77				ld (hl),a 
d35f 11 bd e5			ld de,os_word_scratch 
d362 3e 28				ld a, display_row_2 
d364 cd d0 8a				call str_at_display 
d367 11 8f d2			ld de, .push_malloc 
d36a 3e 00			ld a, display_row_1 
d36c			 
d36c cd d0 8a				call str_at_display 
d36f			 
d36f				; display current data stack pointer 
d36f 11 55 d2			ld de,.data_sp 
d372 3e 30				ld a, display_row_2 + 8 
d374 cd d0 8a				call str_at_display 
d377			 
d377 2a e5 e9			ld hl,(cli_data_sp) 
d37a e5				push hl 
d37b 7c				ld a,h 
d37c 21 bd e5			ld hl, os_word_scratch 
d37f cd f3 8e			call hexout 
d382 e1				pop hl 
d383 7d				ld a,l 
d384 21 bf e5			ld hl, os_word_scratch+2 
d387 cd f3 8e			call hexout 
d38a 21 c1 e5			ld hl, os_word_scratch+4 
d38d 3e 00			ld a,0 
d38f 77				ld (hl),a 
d390 11 bd e5			ld de,os_word_scratch 
d393 3e 33				ld a, display_row_2 + 11 
d395 cd d0 8a				call str_at_display 
d398			 
d398 cd e0 8a			call update_display 
d39b cd 00 8a			call delay1s 
d39e cd 00 8a			call delay1s 
d3a1 e1				pop hl 
d3a2 f1				pop af 
d3a3 c9				ret 
d3a4			;endif 
d3a4			 
d3a4			include "forth_autostart.asm" 
d3a4			; list of commands to perform at system start up 
d3a4			 
d3a4			startcmds: 
d3a4			;	dw test11 
d3a4			;	dw test12 
d3a4			;	dw test13 
d3a4			;	dw test14 
d3a4			;	dw test15 
d3a4			;	dw test16 
d3a4			;	dw test17 
d3a4			;	dw ifthtest1 
d3a4			;	dw ifthtest2 
d3a4			;	dw ifthtest3 
d3a4			;	dw mmtest1 
d3a4			;	dw mmtest2 
d3a4			;	dw mmtest3 
d3a4			;	dw mmtest4 
d3a4			;	dw mmtest5 
d3a4			;	dw mmtest6 
d3a4			;	dw iftest1 
d3a4			;	dw iftest2 
d3a4			;	dw iftest3 
d3a4			;	dw looptest1 
d3a4			;	dw looptest2 
d3a4			;	dw test1 
d3a4			;	dw test2 
d3a4			;	dw test3 
d3a4			;	dw test4 
d3a4			;	dw game2r 
d3a4			;	dw game2b1 
d3a4			;	dw game2b2 
d3a4			 
d3a4				; start up words that are actually useful 
d3a4			 
d3a4			;    dw spi1 
d3a4			;    dw spi2 
d3a4			;    dw spi3 
d3a4			;    dw spi4 
d3a4			;    dw spi5 
d3a4			;    dw spi6 
d3a4			;    dw spi7 
d3a4			; 
d3a4			;    dw spi8 
d3a4			;    dw spi9 
d3a4			;    dw spi10 
d3a4			 
d3a4			; file editor 
d3a4			;	dw edit1 
d3a4			;	dw edit2 
d3a4			;	dw edit3 
d3a4			 
d3a4			;	dw longread 
d3a4 c6 d7			dw clrstack 
d3a6 fa d7			dw type 
d3a8			;	dw stest 
d3a8 1f d8			dw strncpy 
d3aa 8f d9			dw list 
d3ac 80 d8			dw start1 
d3ae 90 d8			dw start2 
d3b0			;	dw start3 
d3b0			;	dw start3b 
d3b0			;	dw start3c 
d3b0			 
d3b0				; (unit) testing words 
d3b0			 
d3b0			;	dw mtesta 
d3b0			;	dw mtestb 
d3b0			;	dw mtestc 
d3b0			;	dw mtestd 
d3b0			;	dw mteste 
d3b0			 
d3b0				; demo/game words 
d3b0			 
d3b0			;        dw game3w 
d3b0			;        dw game3p 
d3b0			;        dw game3sc 
d3b0			;        dw game3vsi 
d3b0			;        dw game3vs 
d3b0				 
d3b0			;	dw game2b 
d3b0			;	dw game2bf 
d3b0			;	dw game2mba 
d3b0			;	dw game2mbas 
d3b0			;	dw game2mb 
d3b0			 
d3b0 c0 db			dw game1 
d3b2 d1 db			dw game1a 
d3b4 33 dc			dw game1b 
d3b6 68 dc			dw game1c 
d3b8 9e dc			dw game1d 
d3ba cf dc			dw game1s 
d3bc e3 dc			dw game1t 
d3be f8 dc			dw game1f 
d3c0 2c dd			dw game1z 
d3c2 70 dd			dw game1zz 
d3c4			 
d3c4 f9 d9			dw test5 
d3c6 31 da			dw test6 
d3c8 69 da			dw test7 
d3ca 7d da			dw test8 
d3cc a9 da			dw test9 
d3ce bf da			dw test10 
d3d0				 
d3d0 47 de		        dw ssv5 
d3d2 2b de		        dw ssv4 
d3d4 0f de		        dw ssv3 
d3d6 d9 dd		        dw ssv2 
d3d8 60 de		        dw ssv1 
d3da a8 de		        dw ssv1cpm 
d3dc			;	dw keyup 
d3dc			;	dw keydown 
d3dc			;	dw keyleft 
d3dc			;	dw keyright 
d3dc			;	dw 	keyf1 
d3dc			;	dw keyf2 
d3dc			;	dw keyf3 
d3dc			;	dw keyf4 
d3dc			;	dw keyf5 
d3dc			;	dw keyf6 
d3dc			;	dw keyf7 
d3dc			;	dw keyf8 
d3dc			;	dw keyf9 
d3dc			;	dw keyf10 
d3dc			;	dw keyf11 
d3dc			;	dw keyf12 
d3dc			;	dw keytab 
d3dc			;	dw keycr 
d3dc			;	dw keyhome 
d3dc			;	dw keyend 
d3dc			;	dw keybs 
d3dc 00 00			db 0, 0	 
d3de			 
d3de			 
d3de			; File Editor 
d3de			 
d3de			; ( id - ) use 'e' to edit the displayed line 
d3de .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
d3ff .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d434			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d434 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
d46c			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
d46c			 
d46c			; SPI Net support words 
d46c			 
d46c			; v0! = node to send to 
d46c			; ( str count - ) 
d46c .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
d4c5			 
d4c5			; spiputc ( char node - ) 
d4c5 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
d4f9			; spiputc ( u node - ) 
d4f9 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
d527			 
d527			; spigetc ( - n ) 
d527 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
d550			 
d550			; getnode ( - n ) 
d550 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
d57d			 
d57d			; ( str node - )  
d57d .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
d5e3			; store string ( str i - ) 
d5e3			 
d5e3			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
d5e3 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
d638			 
d638			; get string ( addr i -  )    TO FIX 
d638			 
d638 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d690			 
d690			 
d690			; NETCHAT (TODO) 
d690			; Program to allow two nodes to chat with eachother 
d690			; 
d690			; v0 - target node 
d690			;  
d690			; accept input at 0,0 
d690			; if input is string send spitype to target node 
d690			; starting at row 2,0 , while spigetchr is not zero ->  
d690			; 
d690			; 
d690			; TODO add paging of get request 
d690			 
d690			; ( node - ) 
d690 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d6af .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d707 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d77f			 
d77f			 
d77f			; Long read of currently open file 
d77f .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d7c6			 
d7c6			; clear stack  
d7c6			 
d7c6 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d7fa			 
d7fa			; type ( addr count - ) 
d7fa .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d81f			 
d81f			; some direct memory words 
d81f			; strncpy ( len t f -- t ) 
d81f			 
d81f .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d880			 
d880 .. 00		start1:     	db ": bpon $00 bp ;",0 
d890 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d8a1 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d91c .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d97c			 
d97c .. 00		tuck:         db ": tuck swap over ;", 0 
d98f			 
d98f			; a handy word to list items on the stack 
d98f			 
d98f .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d9f9			 
d9f9			 
d9f9			; test stack  
d9f9			; rnd8 stest 
d9f9			 
d9f9			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d9f9			 
d9f9			; random malloc and free cycles 
d9f9			 
d9f9			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d9f9			 
d9f9			; fixed malloc and free cycles 
d9f9			 
d9f9			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d9f9			 
d9f9			; fixed double string push and drop cycle  
d9f9			 
d9f9			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d9f9			 
d9f9			; consistent fixed string push and drop cycle  
d9f9			 
d9f9			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d9f9			 
d9f9			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d9f9			 
d9f9			;test1:		db ": aa 1 2 3 ;", 0 
d9f9			;test2:     	db "111 aa 888 999",0 
d9f9			;test3:     	db ": bb 77 ;",0 
d9f9			;test4:     	db "$02 $01 do i . loop bb",0 
d9f9			 
d9f9 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
da31 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
da69 .. 00		test7:     	db ": box hline vline ;",0 
da7d .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
daa9 .. 00		test9:     	db ": sw $01 adsp world ;",0 
dabf .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
dae4			;test11:     	db "hello create .",0 
dae4			;test12:     	db "hello2 create .",0 
dae4			 
dae4			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
dae4			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
dae4			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
dae4			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
dae4			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
dae4			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
dae4			 
dae4			;iftest1:     	db "$0001 IF cls .",0 
dae4			;iftest2:     	db "$0000 IF cls .",0 
dae4			;iftest3:     	db "$0002 $0003 - IF cls .",0 
dae4			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
dae4			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
dae4			 
dae4			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
dae4			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
dae4			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
dae4			 
dae4			 
dae4 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
db08 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
db38 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
db5d .. 00		sound4: db ": cha $00 ; ",0 
db6a .. 00		sound5: db ": chb $20 ; ",0 
db77 .. 00		sound6: db ": chc $40 ; ",0 
db84 .. 00		sound7: db ": chd $60 ; ",0 
db91 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
dba9 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
dbc0			 
dbc0			 
dbc0			 
dbc0			 
dbc0			; a small guess the number game 
dbc0			 
dbc0 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
dbd1 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
dc33			 
dc33 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
dc68 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
dc9e .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
dccf .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
dce3 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
dcf8 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
dd2c .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dd70			 
dd70			; Using 'ga' save a high score across multiple runs using external storage 
dd70			 
dd70 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
ddd9			 
ddd9			 
ddd9			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
ddd9			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
ddd9			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
ddd9			 
ddd9			; simple screen saver to test code memory reuse to destruction 
ddd9			 
ddd9 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
de0f .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
de2b .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
de47 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
de60 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dea8 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
deff			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
deff			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
deff			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
deff			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
deff			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
deff			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
deff			 
deff			 
deff			 
deff			; minesweeper/battleship finding game 
deff			; draws a game board of random ship/mine positions 
deff			; user enters coords to see if it hits on 
deff			; game ends when all are hit 
deff			; when hit or miss says how many may be in the area 
deff			 
deff			; setup the game board and then hide it 
deff			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
deff			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
deff			;; prompt for where to target 
deff			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
deff			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
deff			;; TODO see if the entered coords hits or misses pushes char hit of miss 
deff			;game2mbht:      db ": mbckht nop ;",0 
deff			;game2mbms:      db ": mbcms nop ;",0 
deff			; TODO how many might be near by 
deff			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
deff			 
deff			; Game 3 
deff			 
deff			; Vert scroller ski game - avoid the trees! 
deff			 
deff			; v0 score (ie turns) 
deff			; v1 player pos 
deff			; v2 left wall 
deff			; v3 right wall 
deff			 
deff			; Draw side walls randomly 
deff			 
deff			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
deff			 
deff			; Draw player 
deff			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
deff			 
deff			; TODO Get Key 
deff			 
deff			; TODO Move left right 
deff			 
deff			; scroll and move walls a bit 
deff			 
deff			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
deff			 
deff			; main game loop 
deff			 
deff			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
deff			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
deff			 
deff			; key board defs 
deff			 
deff .. 00		keyup:       db ": keyup $05 ;",0 
df0d .. 00		keydown:       db ": keydown $0a ;",0 
df1d .. 00		keyleft:       db ": keyleft $0b ;",0 
df2d .. 00		keyright:       db ": keyright $0c ;",0 
df3e .. 00		keyf1:       db ": keyf1 $10 ;",0 
df4c .. 00		keyf2:       db ": keyf2 $11 ;",0 
df5a .. 00		keyf3:       db ": keyf3 $12 ;",0 
df68 .. 00		keyf4:       db ": keyf4 $13 ;",0 
df76 .. 00		keyf5:       db ": keyf5 $14 ;",0 
df84 .. 00		keyf6:       db ": keyf6 $15 ;",0 
df92 .. 00		keyf7:       db ": keyf7 $16 ;",0 
dfa0 .. 00		keyf8:       db ": keyf8 $17 ;",0 
dfae .. 00		keyf9:       db ": keyf9 $18 ;",0 
dfbc .. 00		keyf10:       db ": keyf10 $19 ;",0 
dfcb .. 00		keyf11:       db ": keyf11 $1a ;",0 
dfda .. 00		keyf12:       db ": keyf12 $1b ;",0 
dfe9			 
dfe9 .. 00		keytab:       db ": keytab $09 ;",0 
dff8 .. 00		keycr:       db ": keycr $0d ;",0 
e006 .. 00		keyhome:       db ": keyhome $0e ;",0 
e016 .. 00		keyend:       db ": keyend $0f ;",0 
e025 .. 00		keybs:       db ": keybs $08 ;",0 
e033			 
e033			   
e033			 
e033			 
e033			 
e033			; eof 
# End of file forth_autostart.asm
e033			 
e033			 
e033			 
e033			; stack over and underflow checks 
e033			 
e033			; init the words to detect the under/overflow 
e033			 
e033			chk_stk_init: 
e033				; a vague random number to check so we dont get any "lucky" hits 
e033 3e 2d			ld a, 45 
e035 6f				ld l, a 
e036 00				nop 
e037 3e 17			ld a, 23 
e039 67				ld h, a 
e03a			 
e03a 22 94 e2			ld (chk_word), hl     ; the word we need to check against 
e03d			 
e03d			;	ld (chk_stund), hl	; stack points.... 
e03d 22 00 ef			ld (chk_stovr), hl 
e040 22 e3 e9			ld (chk_ret_und), hl 
e043 22 a1 e9			ld (chk_ret_ovr), hl 
e046 22 1f e9			ld (chk_loop_ovr), hl 
e049 22 1d e8			ld (chk_data_ovr), hl 
e04c c9				ret 
e04d				 
e04d			check_stacks: 
e04d				; check all stack words 
e04d			 
e04d e5				push hl 
e04e d5				push de 
e04f			 
e04f			;	ld de,(chk_word) 
e04f			;	ld hl, (chk_stund)	; stack points.... 
e04f			;	if DEBUG_STK_FAULT 
e04f			;		DMARK "FAa" 
e04f			;		CALLMONITOR 
e04f			;	endif 
e04f			;	call cmp16 
e04f			;	jp z, .chk_faulta 
e04f			; 
e04f			;	ld de, sfaultsu 
e04f			;	jp .chk_fault 
e04f			 
e04f 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e052 ed 5b 94 e2		ld de,(chk_word) 
e056				if DEBUG_STK_FAULT 
e056					DMARK "FAb" 
e056					CALLMONITOR 
e056				endif 
e056 cd 08 8d			call cmp16 
e059 28 06			jr z, .chk_fault1 
e05b 11 ff e0			ld de, sfaultso 
e05e c3 b0 e0			jp .chk_fault 
e061			.chk_fault1:  
e061 2a e3 e9			ld hl, (chk_ret_und) 
e064 ed 5b 94 e2		ld de,(chk_word) 
e068				if DEBUG_STK_FAULT 
e068					DMARK "FAU" 
e068					CALLMONITOR 
e068				endif 
e068 cd 08 8d			call cmp16 
e06b ca 74 e0			jp z, .chk_fault2 
e06e 11 0f e1			ld de, sfaultru 
e071 c3 b0 e0			jp .chk_fault 
e074			.chk_fault2:  
e074 2a a1 e9			ld hl, (chk_ret_ovr) 
e077 ed 5b 94 e2		ld de,(chk_word) 
e07b				if DEBUG_STK_FAULT 
e07b					DMARK "FA1" 
e07b					CALLMONITOR 
e07b				endif 
e07b cd 08 8d			call cmp16 
e07e ca 87 e0			jp z, .chk_fault3 
e081 11 1d e1			ld de, sfaultro 
e084 c3 b0 e0			jp .chk_fault 
e087			.chk_fault3:  
e087 2a 1f e9			ld hl, (chk_loop_ovr) 
e08a ed 5b 94 e2		ld de,(chk_word) 
e08e				if DEBUG_STK_FAULT 
e08e					DMARK "FA2" 
e08e					CALLMONITOR 
e08e				endif 
e08e cd 08 8d			call cmp16 
e091 ca 9a e0			jp z, .chk_fault4 
e094 11 37 e1			ld de, sfaultlo 
e097 c3 b0 e0			jp .chk_fault 
e09a			.chk_fault4:  
e09a 2a 1d e8			ld hl, (chk_data_ovr) 
e09d ed 5b 94 e2		ld de,(chk_word) 
e0a1				if DEBUG_STK_FAULT 
e0a1					DMARK "FA3" 
e0a1					CALLMONITOR 
e0a1				endif 
e0a1 cd 08 8d			call cmp16 
e0a4 ca ad e0			jp z, .chk_fault5 
e0a7 11 51 e1			ld de, sfaultdo 
e0aa c3 b0 e0			jp .chk_fault 
e0ad			 
e0ad			 
e0ad			.chk_fault5:  
e0ad d1				pop de 
e0ae e1				pop hl 
e0af			 
e0af c9				ret 
e0b0			 
e0b0 cd bd 8a		.chk_fault: 	call clear_display 
e0b3 3e 28				ld a, display_row_2 
e0b5 cd d0 8a				call str_at_display 
e0b8 11 e1 e0				   ld de, .stackfault 
e0bb 3e 00				ld a, display_row_1 
e0bd cd d0 8a				call str_at_display 
e0c0 11 62 ee				    ld de, debug_mark 
e0c3 3e 11				ld a, display_row_1+17 
e0c5 cd d0 8a				call str_at_display 
e0c8 cd e0 8a				call update_display 
e0cb			 
e0cb				; prompt before entering montior for investigating issue 
e0cb			 
e0cb 3e 78			ld a, display_row_4 
e0cd 11 d3 96			ld de, endprog 
e0d0			 
e0d0 cd e0 8a			call update_display		 
e0d3			 
e0d3 cd 6d 99			call next_page_prompt 
e0d6			 
e0d6 d1				pop de 
e0d7 e1				pop hl 
e0d8 cd 27 97				call monitor 
e0db cd 8b 9d				call forth_warmstart 
e0de c3 23 96				jp warmstart_afterauto 
e0e1					;jp 0 
e0e1					;halt 
e0e1			 
e0e1			 
e0e1			 
e0e1 .. 00		.stackfault: 	db "Stack fault:",0 
e0ee			 
e0ee .. 00		sfaultsu: 	db	"Stack under flow",0 
e0ff .. 00		sfaultso: 	db	"Stack over flow",0 
e10f .. 00		sfaultru:	db "RTS underflow",0 
e11d .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e137 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e151 .. 00		sfaultdo:	db "DTS overflow", 0 
e15e			 
e15e			 
e15e			fault_dsp_under: 
e15e 11 70 e1			ld de, .dsp_under 
e161 c3 26 e2			jp .show_fault 
e164			 
e164			fault_rsp_under: 
e164 11 7e e1			ld de, .rsp_under 
e167 c3 26 e2			jp .show_fault 
e16a			fault_loop_under: 
e16a 11 8c e1			ld de, .loop_under 
e16d c3 26 e2			jp .show_fault 
e170			 
e170 .. 00		.dsp_under: db "DSP Underflow",0 
e17e .. 00		.rsp_under: db "RSP Underflow",0 
e18c .. 00		.loop_under: db "LOOP Underflow",0 
e19b			 
e19b			 
e19b d5			type_faultn: 	push de 
e19c e5					push hl 
e19d cd bd 8a				call clear_display 
e1a0 11 ca e1				   ld de, .typefaultn 
e1a3 3e 00				ld a, display_row_1 
e1a5 cd d0 8a				call str_at_display 
e1a8 11 62 ee				    ld de, debug_mark 
e1ab 3e 11				ld a, display_row_1+17 
e1ad cd d0 8a				call str_at_display 
e1b0 cd e0 8a				call update_display 
e1b3			 
e1b3				; prompt before entering montior for investigating issue 
e1b3			 
e1b3 3e 78			ld a, display_row_4 
e1b5 11 d3 96			ld de, endprog 
e1b8			 
e1b8 cd e0 8a			call update_display		 
e1bb			 
e1bb cd 6d 99			call next_page_prompt 
e1be			 
e1be e5					push hl 
e1bf d5					push de 
e1c0 cd 27 97				call monitor 
e1c3 cd 8b 9d				call forth_warmstart 
e1c6 c3 23 96				jp warmstart_afterauto 
e1c9 76					halt 
e1ca			 
e1ca			 
e1ca .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e1e1			 
e1e1 d5			type_faults: 	push de 
e1e2 e5					push hl 
e1e3 cd bd 8a				call clear_display 
e1e6 11 0f e2				   ld de, .typefaults 
e1e9 3e 00				ld a, display_row_1 
e1eb cd d0 8a				call str_at_display 
e1ee 11 62 ee				    ld de, debug_mark 
e1f1 3e 11				ld a, display_row_1+17 
e1f3 cd d0 8a				call str_at_display 
e1f6 cd e0 8a				call update_display 
e1f9			 
e1f9				; prompt before entering montior for investigating issue 
e1f9			 
e1f9 3e 78			ld a, display_row_4 
e1fb 11 d3 96			ld de, endprog 
e1fe			 
e1fe cd e0 8a			call update_display		 
e201			 
e201 cd 6d 99			call next_page_prompt 
e204			 
e204 e1					pop hl 
e205 d1					pop de 
e206 cd 27 97				call monitor 
e209 cd 8b 9d				call forth_warmstart 
e20c c3 23 96				jp warmstart_afterauto 
e20f			 
e20f			 
e20f .. 00		.typefaults: db "STR Type Expected TOS!",0 
e226			 
e226			.show_fault: 	 
e226 d5					push de 
e227 cd bd 8a				call clear_display 
e22a d1					pop de 
e22b 3e 00				ld a, display_row_1 
e22d cd d0 8a				call str_at_display 
e230 11 62 ee				    ld de, debug_mark 
e233 3e 11				ld a, display_row_1+17 
e235 cd d0 8a				call str_at_display 
e238 cd e0 8a				call update_display 
e23b			 
e23b				; prompt before entering montior for investigating issue 
e23b			 
e23b 3e 78			ld a, display_row_4 
e23d 11 d3 96			ld de, endprog 
e240			 
e240 cd e0 8a			call update_display		 
e243			 
e243 cd 6d 99			call next_page_prompt 
e246			 
e246 e1					pop hl 
e247 d1					pop de 
e248 cd 27 97				call monitor 
e24b			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e24b			; TODO Make optional fault restart to cli or warm boot? 
e24b					;jp warmstart 
e24b c3 67 96				jp cli 
e24e 76					halt 
e24f			 
e24f			 
e24f			; handle the auto run of code from files in storage 
e24f			 
e24f			 
e24f			include "forth_startup.asm" 
e24f			; Which startup method to use? 
e24f			; 
e24f			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e24f			; followed by loading of a list of scripts in eeprom 
e24f			 
e24f			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e24f			; from eeprom 
e24f			 
e24f			; Select with define in main stubs 
e24f			 
e24f			if STARTUP_V1 
e24f				include "forth_startupv1.asm" 
e24f			; Startup script loading version 1 
e24f			 
e24f			; If SE storage is available first stage is to use the selected file 
e24f			; then go through the eeprom list 
e24f			 
e24f .. 00		sprompt1: db "Startup load...",0 
e25f .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e275			 
e275			 
e275			 
e275			 
e275			forth_startup: 
e275 21 a4 d3			ld hl, startcmds 
e278 3e 00			ld a, 0 
e27a 32 de e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e27d			 
e27d e5			.start1:	push hl 
e27e cd bd 8a			call clear_display 
e281 11 4f e2			ld de, sprompt1 
e284 3e 00		        ld a, display_row_1 
e286 cd d0 8a			call str_at_display 
e289 11 5f e2			ld de, sprompt2 
e28c 3e 28		        ld a, display_row_2 
e28e cd d0 8a			call str_at_display 
e291 e1				pop hl 
e292 e5				push hl 
e293 5e				ld e,(hl) 
e294 23				inc hl 
e295 56				ld d,(hl) 
e296 3e 50		        ld a, display_row_3 
e298 cd d0 8a			call str_at_display 
e29b cd e0 8a			call update_display 
e29e			 
e29e			 
e29e 3a de e6			ld a, (os_last_cmd) 
e2a1 fe 00			cp 0 
e2a3 28 05			jr z, .startprompt 
e2a5 cd f4 89			call delay250ms 
e2a8 18 24			jr .startdo 
e2aa				 
e2aa				 
e2aa			 
e2aa			.startprompt: 
e2aa			 
e2aa 3e 9f			ld a,display_row_4 + display_cols - 1 
e2ac 11 6b 99		        ld de, endprg 
e2af cd d0 8a			call str_at_display 
e2b2 cd e0 8a			call update_display 
e2b5 cd 00 8a			call delay1s 
e2b8 cd db e3			call cin_wait 
e2bb						 
e2bb fe 2a			cp '*' 
e2bd 28 5e			jr z, .startupend1 
e2bf fe 23			cp '#' 
e2c1 20 07			jr nz, .startno 
e2c3 3e 01			ld a, 1 
e2c5 32 de e6			ld (os_last_cmd),a 
e2c8 18 04			jr .startdo 
e2ca fe 31		.startno:	cp '1' 
e2cc 28 3a			jr z,.startnxt  
e2ce			 
e2ce				; exec startup line 
e2ce			.startdo:	 
e2ce e1				pop hl 
e2cf e5				push hl 
e2d0				 
e2d0 5e				ld e,(hl) 
e2d1 23				inc hl 
e2d2 56				ld d,(hl) 
e2d3 eb				ex de,hl 
e2d4			 
e2d4 e5				push hl 
e2d5			 
e2d5 3e 00			ld a, 0 
e2d7				;ld a, FORTH_END_BUFFER 
e2d7 cd 5b 90			call strlent 
e2da 23				inc hl   ; include zero term to copy 
e2db 06 00			ld b,0 
e2dd 4d				ld c,l 
e2de e1				pop hl 
e2df 11 b8 e2			ld de, scratch 
e2e2 ed b0			ldir 
e2e4			 
e2e4			 
e2e4 21 b8 e2			ld hl, scratch 
e2e7 cd 2f 9e			call forthparse 
e2ea cd 6b 9e			call forthexec 
e2ed cd 85 9d			call forthexec_cleanup 
e2f0			 
e2f0 3e 78			ld a, display_row_4 
e2f2 11 d3 96			ld de, endprog 
e2f5			 
e2f5 cd e0 8a			call update_display		 
e2f8			 
e2f8 3a de e6			ld a, (os_last_cmd) 
e2fb fe 00			cp 0 
e2fd 20 09			jr nz, .startnxt 
e2ff cd 6d 99			call next_page_prompt 
e302 cd bd 8a		        call clear_display 
e305 cd e0 8a			call update_display		 
e308			 
e308				; move onto next startup line? 
e308			.startnxt: 
e308			 
e308 cd f4 89			call delay250ms 
e30b e1				pop hl 
e30c			 
e30c 23				inc hl 
e30d 23				inc hl 
e30e			 
e30e e5				push hl 
e30f 5e				ld e, (hl) 
e310 23				inc hl 
e311 56				ld d, (hl) 
e312 e1				pop hl 
e313				; TODO replace 0 test 
e313			 
e313 eb				ex de, hl 
e314 cd 13 8d			call ishlzero 
e317			;	ld a,e 
e317			;	add d 
e317			;	cp 0    ; any left to do? 
e317 eb				ex de, hl 
e318 c2 7d e2			jp nz, .start1 
e31b 18 01			jr .startupend 
e31d			 
e31d e1			.startupend1: pop hl 
e31e			.startupend: 
e31e			 
e31e cd bd 8a			call clear_display 
e321 cd e0 8a			call update_display 
e324 c9				ret 
e325			if STORAGE_SE 
e325			 
e325			sprompt3: db "Loading from start-up file?:",0 
e325			sprompt4: db "(Y=Any key/N=No)",0 
e325			 
e325			 
e325			forth_autoload: 
e325			 
e325				; load block 0 of store 1 
e325				 
e325				ld a, $fe      ; bit 0 clear 
e325				ld (spi_device), a 
e325			 
e325				call storage_get_block_0 
e325			 
e325				ld a, (store_page+STORE_0_AUTOFILE) 
e325			 
e325				cp 0 
e325				ret z     ; auto start not enabled 
e325			 
e325				call clear_display 
e325			 
e325				; set bank 
e325			 
e325					ld a, (store_page+STORE_0_BANKRUN) 
e325					ld (spi_device), a 
e325			 
e325				; get file id to load from and get the file name to display 
e325			 
e325					ld a, (store_page+STORE_0_FILERUN) 
e325			 
e325					ld l, 0 
e325					ld h, a 
e325					ld de, store_page 
e325			 
e325					if DEBUG_FORTH_WORDS 
e325						DMARK "ASp" 
e325						CALLMONITOR 
e325					endif 
e325					call storage_read 
e325			 
e325					if DEBUG_FORTH_WORDS 
e325						DMARK "ASr" 
e325						CALLMONITOR 
e325					endif 
e325			 
e325					call ishlzero 
e325					ret z             ; file not found 
e325			 
e325					ld a, display_row_2 + 10 
e325					ld de, store_page+3 
e325					call str_at_display 
e325				 
e325			; 
e325			 
e325				ld a, display_row_1+5 
e325				ld de, sprompt3 
e325				call str_at_display 
e325				ld a, display_row_3+15 
e325				ld de, sprompt4 
e325				call str_at_display 
e325			 
e325				call update_display 
e325			 
e325				call cin_wait 
e325				cp 'n' 
e325				ret z 
e325				cp 'N' 
e325				ret z 
e325			 
e325				call delay1s 
e325			 
e325				ld a, (store_page+2) 
e325				ld (store_openmaxext), a    ; save count of ext 
e325				ld a, 1  
e325				ld (store_openext), a    ; save count of ext 
e325			 
e325			.autof:  
e325				ld l , a 
e325				 
e325				ld a, (store_page) 
e325				ld h, a	 
e325				ld de, store_page 
e325					if DEBUG_FORTH_WORDS 
e325						DMARK "ASl" 
e325						CALLMONITOR 
e325					endif 
e325					call storage_read 
e325				call ishlzero 
e325				ret z 
e325			;	jr z, .autoend 
e325			 
e325					if DEBUG_FORTH_WORDS 
e325						DMARK "ASc" 
e325						CALLMONITOR 
e325					endif 
e325				ld de, store_page+2 
e325				ld a, display_row_4 
e325				call str_at_display 
e325			 
e325				call update_display 
e325				call delay250ms 
e325			 
e325			 
e325			 
e325				ld hl, store_page+2 
e325				call forthparse 
e325				call forthexec 
e325				call forthexec_cleanup 
e325			 
e325				 
e325				ld a, (store_openext) 
e325				inc a 
e325				ld (store_openext), a    ; save count of ext 
e325			 
e325				jr .autof 
e325			;.autofdone: 
e325			; 
e325			;		if DEBUG_FORTH_WORDS 
e325			;			DMARK "ASx" 
e325			;			CALLMONITOR 
e325			;		endif 
e325			;;	call clear_display 
e325			;	ret 
e325			 
e325			 
e325			 
e325			endif 
# End of file forth_startupv1.asm
e325			endif 
e325			if STARTUP_V2 
e325				include "forth_startupv2.asm" 
e325			endif 
e325			 
# End of file forth_startup.asm
e325			 
e325			; eof 
# End of file forth_kernel.asm
e325			;include "nascombasic.asm" 
e325			 
e325			 
e325			; find out where the code ends if loaded into RAM (for SC114) 
e325			;endofcode:  
e325			;	nop 
e325			 
e325			 
e325			; jump to nmi vector 
e325			 
e325			init_nmi: 
e325 3e c9			ld a, $c9   ; RET 
e327 32 72 ee			ld (nmi_vector), a 
e32a c9				ret 
e32b			nmi: 
e32b e5				push hl 
e32c d5				push de 
e32d c5				push bc 
e32e f5				push af 
e32f cd 72 ee			call nmi_vector 
e332 f5				push af 
e333 c5				push bc 
e334 d5				push de 
e335 e5				push hl 
e336 ed 4d			reti 
e338			 
e338			 
e338			; eof 
e338			 
# End of file main.asm
e338			;include "firmware_lcd_4x40.asm" 
e338			;;include "firmware_lcd_4x20.asm" 
e338			include "firmware_serial_display.asm" 
e338			 
e338			; Serial display interface for SC114 
e338			 
e338			 
e338			display_row_1: equ 0 
e338			display_row_2: equ display_row_1+display_cols 
e338			display_row_3: equ display_row_2 + display_cols 
e338			display_row_4: equ display_row_3 + display_cols 
e338			 
e338			kLCDWidth:  EQU display_cols             ;Width in characters 
e338			kLCD_Line1: EQU 0x00  
e338			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e338			; E1 
e338			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e338			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e338			 
e338			lcd_init: 
e338				; no init as handled by the SCM bios 
e338 c9				ret 
e339			 
e339			 
e339			; low level functions for direct screen writes 
e339			 
e339			; output char at pos? 
e339			fLCD_Str: 
e339			        ;out (SC114_SIO_1_OUT),a 
e339 c5				push bc 
e33a 0e 02			ld c, $02 
e33c f7				rst $30 
e33d c1				pop bc 
e33e c9				ret 
e33f			 
e33f			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e33f			fLCD_Pos: 
e33f				; use ASCII escape to position 
e33f			        ;out (SC114_SIO_1_OUT),a 
e33f c5				push bc 
e340 0e 02			ld c, $02 
e342 f7				rst $30 
e343 c1				pop bc 
e344			 
e344 c9				ret 
e345			 
e345			; output char at pos 
e345			fLCD_Data: 
e345			      ;  out (SC114_SIO_1_OUT),a 
e345 c5				push bc 
e346 0e 02			ld c, $02 
e348 f7				rst $30 
e349 c1				pop bc 
e34a			 
e34a c9				ret 
e34b			 
e34b			; ascii cls  
e34b			 
e34b 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e34f			 
e34f			; write the frame buffer given in hl to hardware  
e34f			write_display: 
e34f			 
e34f			API: equ 0 
e34f			 
e34f			if API 
e34f				push bc 
e34f				ld b, 4 
e34f			 
e34f			        ld (display_write_tmp), hl 	  
e34f			 
e34f				; clear and home cursor 
e34f			 
e34f				ld c, 6 
e34f				ld de, .cls 
e34f				rst $30 
e34f			 
e34f			 
e34f			.writeln: 
e34f			 
e34f				ld de, (display_write_tmp) 
e34f				ld c, 6 
e34f				rst $30 
e34f				ld c, 7 
e34f				rst $30 
e34f			 
e34f				ld hl, (display_write_tmp) 
e34f				ld de, display_cols 
e34f				add hl,de 
e34f				ld (display_write_tmp),hl 
e34f			 
e34f				djnz  .writeln 
e34f			 
e34f				pop bc 
e34f			 
e34f			 
e34f				ret 
e34f			endif 
e34f e5				push hl 
e350 c5				push bc 
e351 d5				push de 
e352			 
e352			;	ld c, 2 
e352			;	;ld de, .cls 
e352			;	ld a, 27 
e352			;	rst $30 
e352			;	ld c, 2 
e352			;	;ld de, .cls 
e352			;	ld a, '[' 
e352			;	rst $30 
e352			; 
e352			;	ld c, 2 
e352			;	;ld de, .cls 
e352			;	ld a, 'H' 
e352			;	rst $30 
e352			; 
e352			 
e352 0e 02			ld c, 2 
e354				;ld de, .cls 
e354 3e 1b			ld a, 27 
e356 f7				rst $30 
e357			 
e357			 
e357 0e 02			ld c, 2 
e359				;ld de, .cls 
e359 3e 5b			ld a, '[' 
e35b f7				rst $30 
e35c 0e 02			ld c, 2 
e35e				;ld de, .cls 
e35e 3e 32			ld a, '2' 
e360 f7				rst $30 
e361 0e 02			ld c, 2 
e363				;ld de, .cls 
e363 3e 4a			ld a, 'J' 
e365 f7				rst $30 
e366 d1				pop de 
e367 c1				pop bc 
e368 e1				pop hl 
e369			 
e369			 
e369 22 c0 eb		        ld (display_write_tmp), hl 	  
e36c 3e 00			ld a, kLCD_Line1 
e36e			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e36e 06 28			ld b, display_cols 
e370 ed 5b c0 eb		ld de, (display_write_tmp) 
e374 cd d2 e3			call write_len_string 
e377				 
e377			 
e377 e5			push hl 
e378 d5			push de 
e379 c5			push bc 
e37a 0e 07			ld c, 7 
e37c f7				rst $30 
e37d c1			pop bc 
e37e d1			pop de 
e37f e1			pop hl 
e380			 
e380				 
e380 2a c0 eb			ld hl, (display_write_tmp) 
e383 11 28 00			ld de, display_cols 
e386 19				add hl,de 
e387 22 c0 eb			ld (display_write_tmp),hl 
e38a			 
e38a				 
e38a 3e 28			ld a, kLCD_Line2 
e38c			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e38c 06 28			ld b, display_cols 
e38e ed 5b c0 eb		ld de, (display_write_tmp) 
e392 cd d2 e3			call write_len_string 
e395				 
e395 2a c0 eb			ld hl, (display_write_tmp) 
e398 11 28 00			ld de, display_cols 
e39b 19				add hl,de 
e39c 22 c0 eb			ld (display_write_tmp),hl 
e39f			 
e39f e5			push hl 
e3a0 d5			push de 
e3a1 c5			push bc 
e3a2 0e 07			ld c, 7 
e3a4 f7				rst $30 
e3a5 c1			pop bc 
e3a6 d1			pop de 
e3a7 e1			pop hl 
e3a8			 
e3a8				 
e3a8 3e 50			ld a, kLCD_Line3 
e3aa			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e3aa 06 28			ld b, display_cols 
e3ac ed 5b c0 eb		ld de, (display_write_tmp) 
e3b0 cd d2 e3			call write_len_string 
e3b3				 
e3b3 2a c0 eb			ld hl, (display_write_tmp) 
e3b6 11 28 00			ld de, display_cols 
e3b9 19				add hl,de 
e3ba 22 c0 eb			ld (display_write_tmp),hl 
e3bd			 
e3bd e5			push hl 
e3be d5			push de 
e3bf c5			push bc 
e3c0 0e 07			ld c, 7 
e3c2 f7				rst $30 
e3c3 c1			pop bc 
e3c4 d1			pop de 
e3c5 e1			pop hl 
e3c6			 
e3c6				 
e3c6 3e 78			ld a, kLCD_Line4 
e3c8			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e3c8 06 28			ld b, display_cols 
e3ca ed 5b c0 eb		ld de, (display_write_tmp) 
e3ce cd d2 e3			call write_len_string 
e3d1 c9					ret 
e3d2			 
e3d2			 
e3d2				; write out a fixed length string given in b from de 
e3d2			 
e3d2 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e3d3 cd 45 e3		            CALL fLCD_Data      ;Write character to display 
e3d6 13				inc de 
e3d7 10 f9			djnz write_len_string 
e3d9 c9				ret 
e3da			 
e3da			 
e3da			; eof 
# End of file firmware_serial_display.asm
e3da			;include "firmware_key_5x10.asm" 
e3da			;;include "firmware_key_4x10.asm" 
e3da			include "firmware_key_serial.asm" 
e3da			; Serial keyboard interface for SC114 
e3da			 
e3da			key_init: 
e3da				; no init as handled by the SCM bios 
e3da c9				ret 
e3db			 
e3db			 
e3db			cin_wait: 
e3db			;	ld a, 0 
e3db			;	ret 
e3db			 
e3db				;in a,(SC114_SIO_1_IN) 
e3db			        ; Use SCM API to get from whatever console device we are using 
e3db c5				push bc 
e3dc 0e 01			ld c, $01 
e3de f7				rst $30 
e3df c1				pop bc 
e3e0 c9				ret 
e3e1			 
e3e1			cinndb: 	 
e3e1			cin: 
e3e1			 
e3e1			 
e3e1 c5				push bc 
e3e2			 
e3e2				; any key waiting to process? 
e3e2 0e 03			ld c, $03 
e3e4 f7				rst $30 
e3e5 28 05			jr z, .cin_skip 
e3e7			 
e3e7				; yep, get it 
e3e7			 
e3e7 0e 01			ld c, $01 
e3e9 f7				rst $30 
e3ea c1				pop bc 
e3eb c9				ret 
e3ec			.cin_skip: 
e3ec 3e 00			ld a, 0 
e3ee c1				pop bc 
e3ef c9				ret 
e3f0			 
e3f0			 
e3f0			 
e3f0			 
# End of file firmware_key_serial.asm
e3f0			endofcode:  
e3f0			baseram:  
e3f0 00				nop 
e3f1			 
e3f1			heap_start: equ baseram+15  ; Starting address of heap 
e3f1			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e3f1			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e3f1			;VDU:  EQU     endofcode           ; BASIC Work space 
e3f1			; eof 
e3f1			 
# End of file os_mega_sc114.asm
e3f1
